"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{13781:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphAngleBetweenBlock:()=>C,FlowGraphAxisAngleFromQuaternionBlock:()=>X,FlowGraphConjugateBlock:()=>v,FlowGraphCrossBlock:()=>I,FlowGraphDotBlock:()=>e,FlowGraphLengthBlock:()=>y,FlowGraphNormalizeBlock:()=>i,FlowGraphQuaternionFromAxisAngleBlock:()=>n,FlowGraphQuaternionFromDirectionsBlock:()=>g,FlowGraphRotate2DBlock:()=>E,FlowGraphRotate3DBlock:()=>O,FlowGraphTransformBlock:()=>G,FlowGraphTransformCoordinatesBlock:()=>D});var T=c(12543),Y=c(12517),Z=c(642),w=c(13763),A=c(13772),u=c(694),s=c(12554),x=c(12178);const j="cachedOperationAxis",N="cachedOperationAngle",q="cachedExecutionId";class y extends A.b{constructor(W){super(Y.c,Y.n,(W=>this._polymorphicLength(W)),"FlowGraphLengthBlock",W)}_polymorphicLength(W){switch((0,s.l)(W)){case"Vector2":case"oi":case"Vector4":case"Quaternion":return W.length();default:throw new Error(`Cannot compute length of value ${W}`)}}}(0,Z.h)("FlowGraphLengthBlock",y);class i extends A.b{constructor(W){super(Y.c,Y.c,(W=>this._polymorphicNormalize(W)),"FlowGraphNormalizeBlock",W)}_polymorphicNormalize(W){var F;let c;switch((0,s.l)(W)){case"Vector2":case"oi":case"Vector4":case"Quaternion":if(c=W.normalizeToNew(),null!==(F=this.config)&&void 0!==F&&F.nanOnZeroLength){0===W.length()&&c.ni(NaN)}return c;default:throw new Error(`Cannot normalize value ${W}`)}}}(0,Z.h)("FlowGraphNormalizeBlock",i);class e extends w.c{constructor(W){super(Y.c,Y.c,Y.n,((W,F)=>this._polymorphicDot(W,F)),"FlowGraphDotBlock",W)}_polymorphicDot(W,F){switch((0,s.l)(W)){case"Vector2":case"oi":case"Vector4":case"Quaternion":return W.dot(F);default:throw new Error(`Cannot get dot product of ${W} and ${F}`)}}}(0,Z.h)("FlowGraphDotBlock",e);class I extends w.c{constructor(W){super(Y.t,Y.t,Y.t,((W,F)=>u.l.Cross(W,F)),"FlowGraphCrossBlock",W)}}(0,Z.h)("FlowGraphCrossBlock",I);class E extends w.c{constructor(W){super(Y.s,Y.n,Y.s,((W,F)=>W.rotate(F)),"FlowGraphRotate2DBlock",W)}}(0,Z.h)("FlowGraphRotate2DBlock",E);class O extends w.c{constructor(W){super(Y.t,Y.p,Y.t,((W,F)=>W.applyRotationQuaternion(F)),"FlowGraphRotate3DBlock",W)}}function z(W,F){switch((0,s.l)(W)){case"Vector2":case"oi":return F.transformVector(W);case"Vector4":return new u.m(W.x*F.m[0]+W.y*F.m[1]+W.z*F.m[2]+W.w*F.m[3],W.x*F.m[4]+W.y*F.m[5]+W.z*F.m[6]+W.w*F.m[7],W.x*F.m[8]+W.y*F.m[9]+W.z*F.m[10]+W.w*F.m[11],W.x*F.m[12]+W.y*F.m[13]+W.z*F.m[14]+W.w*F.m[15]);default:throw new Error(`Cannot transform value ${W}`)}}(0,Z.h)("FlowGraphRotate3DBlock",O);class G extends w.c{constructor(W){const F=(null===W||void 0===W?void 0:W.vectorType)||"oi",c="Vector2"===F?"Matrix2D":"oi"===F?"Matrix3D":"Matrix";super((0,Y.F)(F),(0,Y.F)(c),(0,Y.F)(F),z,"FlowGraphTransformVectorBlock",W)}}(0,Z.h)("FlowGraphTransformVectorBlock",G);class D extends w.c{constructor(W){super(Y.t,Y.i,Y.t,((W,F)=>u.l.TransformCoordinates(W,F)),"FlowGraphTransformCoordinatesBlock",W)}}(0,Z.h)("FlowGraphTransformCoordinatesBlock",D);class v extends A.b{constructor(W){super(Y.p,Y.p,(W=>W.conjugate()),"FlowGraphConjugateBlock",W)}}(0,Z.h)("FlowGraphConjugateBlock",v);class C extends w.c{constructor(W){super(Y.p,Y.p,Y.n,((W,F)=>(0,x.e)(W,F)),"FlowGraphAngleBetweenBlock",W)}}(0,Z.h)("FlowGraphAngleBetweenBlock",C);class n extends w.c{constructor(W){super(Y.t,Y.n,Y.p,((W,F)=>u.e.RotationAxis(W,F)),"FlowGraphQuaternionFromAxisAngleBlock",W)}}(0,Z.h)("FlowGraphQuaternionFromAxisAngleBlock",n);class X extends T.d{constructor(W){super(W),this.a=this.registerDataInput("a",Y.p),this.axis=this.registerDataOutput("axis",Y.t),this.angle=this.registerDataOutput("angle",Y.n),this.isValid=this.registerDataOutput("isValid",Y.e)}_updateOutputs(W){const F=W._getExecutionVariable(this,q,-1),c=W._getExecutionVariable(this,j,null),T=W._getExecutionVariable(this,N,null);if(void 0!==c&&null!==c&&void 0!==T&&null!==T&&F===W.executionId)this.axis.setValue(c,W),this.angle.setValue(T,W);else try{const{axis:F,angle:c}=this.a.getValue(W).toAxisAngle();W._setExecutionVariable(this,j,F),W._setExecutionVariable(this,N,c),W._setExecutionVariable(this,q,W.executionId),this.axis.setValue(F,W),this.angle.setValue(c,W),this.isValid.setValue(!0,W)}catch(Y){this.isValid.setValue(!1,W)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,Z.h)("FlowGraphAxisAngleFromQuaternionBlock",X);class g extends w.c{constructor(W){super(Y.t,Y.t,Y.p,((W,F)=>(0,x.i)(W,F)),"FlowGraphQuaternionFromDirectionsBlock",W)}}},13763:(W,F,c)=>{c.d(F,{c:()=>Y});var T=c(13768);class Y extends T.d{constructor(W,F,c,T,Y,Z){super(c,Z),this._operation=T,this._className=Y,this.a=this.registerDataInput("a",W),this.b=this.registerDataInput("b",F)}_doOperation(W){const F=this.a.getValue(W),c=this.b.getValue(W);return this._operation(F,c)}getClassName(){return this._className}}},13768:(W,F,c)=>{c.d(F,{d:()=>A});var T=c(12543),Y=c(12517);const Z="cachedOperationValue",w="cachedExecutionId";class A extends T.d{constructor(W,F){super(F),this.value=this.registerDataOutput("value",W),this.isValid=this.registerDataOutput("isValid",Y.e)}_updateOutputs(W){const F=W._getExecutionVariable(this,w,-1),c=W._getExecutionVariable(this,Z,null);if(void 0!==c&&null!==c&&F===W.executionId)this.isValid.setValue(!0,W),this.value.setValue(c,W);else try{const F=this._doOperation(W);if(void 0===F||null===F)return void this.isValid.setValue(!1,W);W._setExecutionVariable(this,Z,F),W._setExecutionVariable(this,w,W.executionId),this.value.setValue(F,W),this.isValid.setValue(!0,W)}catch(T){this.isValid.setValue(!1,W)}}}},13772:(W,F,c)=>{c.d(F,{b:()=>Y});var T=c(13768);class Y extends T.d{constructor(W,F,c,T,Y){super(F,Y),this._operation=c,this._className=T,this.a=this.registerDataInput("a",W)}_doOperation(W){return this._operation(this.a.getValue(W))}getClassName(){return this._className}}}}]);