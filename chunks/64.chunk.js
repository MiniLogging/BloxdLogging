"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{13852:(A,X,s)=>{s.r(X),s.d(X,{FlowGraphAngleBetweenBlock:()=>b,FlowGraphAxisAngleFromQuaternionBlock:()=>j,FlowGraphConjugateBlock:()=>m,FlowGraphCrossBlock:()=>R,FlowGraphDotBlock:()=>w,FlowGraphLengthBlock:()=>d,FlowGraphNormalizeBlock:()=>Q,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>G,FlowGraphRotate2DBlock:()=>C,FlowGraphRotate3DBlock:()=>J,FlowGraphTransformBlock:()=>u,FlowGraphTransformCoordinatesBlock:()=>z});var N=s(12701),f=s(12677),E=s(616),g=s(13835),K=s(13846),r=s(678),i=s(12706),Y=s(12327);const v="cachedOperationAxis",c="cachedOperationAngle",M="cachedExecutionId";class d extends K.d{constructor(A){super(f.b,f.n,(A=>this._polymorphicLength(A)),"FlowGraphLengthBlock",A)}_polymorphicLength(A){switch((0,i.l)(A)){case"Vector2":case"oi":case"Vector4":case"Quaternion":return A.length();default:throw new Error(`Cannot compute length of value ${A}`)}}}(0,E.f)("FlowGraphLengthBlock",d);class Q extends K.d{constructor(A){super(f.b,f.b,(A=>this._polymorphicNormalize(A)),"FlowGraphNormalizeBlock",A)}_polymorphicNormalize(A){var X;let s;switch((0,i.l)(A)){case"Vector2":case"oi":case"Vector4":case"Quaternion":if(s=A.normalizeToNew(),null!==(X=this.config)&&void 0!==X&&X.nanOnZeroLength){0===A.length()&&s.ni(NaN)}return s;default:throw new Error(`Cannot normalize value ${A}`)}}}(0,E.f)("FlowGraphNormalizeBlock",Q);class w extends g.c{constructor(A){super(f.b,f.b,f.n,((A,X)=>this._polymorphicDot(A,X)),"FlowGraphDotBlock",A)}_polymorphicDot(A,X){switch((0,i.l)(A)){case"Vector2":case"oi":case"Vector4":case"Quaternion":return A.dot(X);default:throw new Error(`Cannot get dot product of ${A} and ${X}`)}}}(0,E.f)("FlowGraphDotBlock",w);class R extends g.c{constructor(A){super(f.u,f.u,f.u,((A,X)=>r.k.Cross(A,X)),"FlowGraphCrossBlock",A)}}(0,E.f)("FlowGraphCrossBlock",R);class C extends g.c{constructor(A){super(f.t,f.n,f.t,((A,X)=>A.rotate(X)),"FlowGraphRotate2DBlock",A)}}(0,E.f)("FlowGraphRotate2DBlock",C);class J extends g.c{constructor(A){super(f.u,f.p,f.u,((A,X)=>A.applyRotationQuaternion(X)),"FlowGraphRotate3DBlock",A)}}function a(A,X){switch((0,i.l)(A)){case"Vector2":case"oi":return X.transformVector(A);case"Vector4":return new r.m(A.x*X.m[0]+A.y*X.m[1]+A.z*X.m[2]+A.w*X.m[3],A.x*X.m[4]+A.y*X.m[5]+A.z*X.m[6]+A.w*X.m[7],A.x*X.m[8]+A.y*X.m[9]+A.z*X.m[10]+A.w*X.m[11],A.x*X.m[12]+A.y*X.m[13]+A.z*X.m[14]+A.w*X.m[15]);default:throw new Error(`Cannot transform value ${A}`)}}(0,E.f)("FlowGraphRotate3DBlock",J);class u extends g.c{constructor(A){const X=(null===A||void 0===A?void 0:A.vectorType)||"oi",s="Vector2"===X?"Matrix2D":"oi"===X?"Matrix3D":"Matrix";super((0,f.C)(X),(0,f.C)(s),(0,f.C)(X),a,"FlowGraphTransformVectorBlock",A)}}(0,E.f)("FlowGraphTransformVectorBlock",u);class z extends g.c{constructor(A){super(f.u,f.g,f.u,((A,X)=>r.k.TransformCoordinates(A,X)),"FlowGraphTransformCoordinatesBlock",A)}}(0,E.f)("FlowGraphTransformCoordinatesBlock",z);class m extends K.d{constructor(A){super(f.p,f.p,(A=>A.conjugate()),"FlowGraphConjugateBlock",A)}}(0,E.f)("FlowGraphConjugateBlock",m);class b extends g.c{constructor(A){super(f.p,f.p,f.n,((A,X)=>(0,Y.e)(A,X)),"FlowGraphAngleBetweenBlock",A)}}(0,E.f)("FlowGraphAngleBetweenBlock",b);class y extends g.c{constructor(A){super(f.u,f.n,f.p,((A,X)=>r.d.RotationAxis(A,X)),"FlowGraphQuaternionFromAxisAngleBlock",A)}}(0,E.f)("FlowGraphQuaternionFromAxisAngleBlock",y);class j extends N.e{constructor(A){super(A),this.a=this.registerDataInput("a",f.p),this.axis=this.registerDataOutput("axis",f.u),this.angle=this.registerDataOutput("angle",f.n),this.isValid=this.registerDataOutput("isValid",f.c)}_updateOutputs(A){const X=A._getExecutionVariable(this,M,-1),s=A._getExecutionVariable(this,v,null),N=A._getExecutionVariable(this,c,null);if(void 0!==s&&null!==s&&void 0!==N&&null!==N&&X===A.executionId)this.axis.setValue(s,A),this.angle.setValue(N,A);else try{const{axis:X,angle:s}=this.a.getValue(A).toAxisAngle();A._setExecutionVariable(this,v,X),A._setExecutionVariable(this,c,s),A._setExecutionVariable(this,M,A.executionId),this.axis.setValue(X,A),this.angle.setValue(s,A),this.isValid.setValue(!0,A)}catch(f){this.isValid.setValue(!1,A)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,E.f)("FlowGraphAxisAngleFromQuaternionBlock",j);class G extends g.c{constructor(A){super(f.u,f.u,f.p,((A,X)=>(0,Y.i)(A,X)),"FlowGraphQuaternionFromDirectionsBlock",A)}}},13835:(A,X,s)=>{s.d(X,{c:()=>f});var N=s(13839);class f extends N.e{constructor(A,X,s,N,f,E){super(s,E),this._operation=N,this._className=f,this.a=this.registerDataInput("a",A),this.b=this.registerDataInput("b",X)}_doOperation(A){const X=this.a.getValue(A),s=this.b.getValue(A);return this._operation(X,s)}getClassName(){return this._className}}},13839:(A,X,s)=>{s.d(X,{e:()=>K});var N=s(12701),f=s(12677);const E="cachedOperationValue",g="cachedExecutionId";class K extends N.e{constructor(A,X){super(X),this.value=this.registerDataOutput("value",A),this.isValid=this.registerDataOutput("isValid",f.c)}_updateOutputs(A){const X=A._getExecutionVariable(this,g,-1),s=A._getExecutionVariable(this,E,null);if(void 0!==s&&null!==s&&X===A.executionId)this.isValid.setValue(!0,A),this.value.setValue(s,A);else try{const X=this._doOperation(A);if(void 0===X||null===X)return void this.isValid.setValue(!1,A);A._setExecutionVariable(this,E,X),A._setExecutionVariable(this,g,A.executionId),this.value.setValue(X,A),this.isValid.setValue(!0,A)}catch(N){this.isValid.setValue(!1,A)}}}},13846:(A,X,s)=>{s.d(X,{d:()=>f});var N=s(13839);class f extends N.e{constructor(A,X,s,N,f){super(X,f),this._operation=s,this._className=N,this.a=this.registerDataInput("a",A)}_doOperation(A){return this._operation(this.a.getValue(A))}getClassName(){return this._className}}}}]);