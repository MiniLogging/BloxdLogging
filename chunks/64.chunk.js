"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{14150:(u,F,z)=>{z.r(F),z.d(F,{FlowGraphAngleBetweenBlock:()=>H,FlowGraphAxisAngleFromQuaternionBlock:()=>U,FlowGraphConjugateBlock:()=>T,FlowGraphCrossBlock:()=>e,FlowGraphDotBlock:()=>Y,FlowGraphLengthBlock:()=>k,FlowGraphNormalizeBlock:()=>N,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>a,FlowGraphRotate2DBlock:()=>d,FlowGraphRotate3DBlock:()=>C,FlowGraphTransformBlock:()=>f,FlowGraphTransformCoordinatesBlock:()=>n});var p=z(12980),b=z(12952),R=z(668),c=z(14129),I=z(14142),G=z(730),X=z(12986),j=z(12536);const W="cachedOperationAxis",E="cachedOperationAngle",L="cachedExecutionId";class k extends I.e{constructor(u){super(b.e,b.t,(u=>this._polymorphicLength(u)),"FlowGraphLengthBlock",u)}_polymorphicLength(u){switch((0,X.m)(u)){case"Vector2":case"$j":case"Vector4":case"Quaternion":return u.length();default:throw new Error(`Cannot compute length of value ${u}`)}}}(0,R.h)("FlowGraphLengthBlock",k);class N extends I.e{constructor(u){super(b.e,b.e,(u=>this._polymorphicNormalize(u)),"FlowGraphNormalizeBlock",u)}_polymorphicNormalize(u){var F;let z;switch((0,X.m)(u)){case"Vector2":case"$j":case"Vector4":case"Quaternion":if(z=u.normalizeToNew(),null!==(F=this.config)&&void 0!==F&&F.nanOnZeroLength){0===u.length()&&z._j(NaN)}return z;default:throw new Error(`Cannot normalize value ${u}`)}}}(0,R.h)("FlowGraphNormalizeBlock",N);class Y extends c.c{constructor(u){super(b.e,b.e,b.t,((u,F)=>this._polymorphicDot(u,F)),"FlowGraphDotBlock",u)}_polymorphicDot(u,F){switch((0,X.m)(u)){case"Vector2":case"$j":case"Vector4":case"Quaternion":return u.dot(F);default:throw new Error(`Cannot get dot product of ${u} and ${F}`)}}}(0,R.h)("FlowGraphDotBlock",Y);class e extends c.c{constructor(u){super(b.C,b.C,b.C,((u,F)=>G.l.Cross(u,F)),"FlowGraphCrossBlock",u)}}(0,R.h)("FlowGraphCrossBlock",e);class d extends c.c{constructor(u){super(b.z,b.t,b.z,((u,F)=>u.rotate(F)),"FlowGraphRotate2DBlock",u)}}(0,R.h)("FlowGraphRotate2DBlock",d);class C extends c.c{constructor(u){super(b.C,b.u,b.C,((u,F)=>u.applyRotationQuaternion(F)),"FlowGraphRotate3DBlock",u)}}function r(u,F){switch((0,X.m)(u)){case"Vector2":case"$j":return F.transformVector(u);case"Vector4":return new G.p(u.x*F.m[0]+u.y*F.m[1]+u.z*F.m[2]+u.w*F.m[3],u.x*F.m[4]+u.y*F.m[5]+u.z*F.m[6]+u.w*F.m[7],u.x*F.m[8]+u.y*F.m[9]+u.z*F.m[10]+u.w*F.m[11],u.x*F.m[12]+u.y*F.m[13]+u.z*F.m[14]+u.w*F.m[15]);default:throw new Error(`Cannot transform value ${u}`)}}(0,R.h)("FlowGraphRotate3DBlock",C);class f extends c.c{constructor(u){const F=(null===u||void 0===u?void 0:u.vectorType)||"$j",z="Vector2"===F?"Matrix2D":"$j"===F?"Matrix3D":"Matrix";super((0,b.M)(F),(0,b.M)(z),(0,b.M)(F),r,"FlowGraphTransformVectorBlock",u)}}(0,R.h)("FlowGraphTransformVectorBlock",f);class n extends c.c{constructor(u){super(b.C,b.p,b.C,((u,F)=>G.l.TransformCoordinates(u,F)),"FlowGraphTransformCoordinatesBlock",u)}}(0,R.h)("FlowGraphTransformCoordinatesBlock",n);class T extends I.e{constructor(u){super(b.u,b.u,(u=>u.conjugate()),"FlowGraphConjugateBlock",u)}}(0,R.h)("FlowGraphConjugateBlock",T);class H extends c.c{constructor(u){super(b.u,b.u,b.t,((u,F)=>(0,j.b)(u,F)),"FlowGraphAngleBetweenBlock",u)}}(0,R.h)("FlowGraphAngleBetweenBlock",H);class y extends c.c{constructor(u){super(b.C,b.t,b.u,((u,F)=>G.f.RotationAxis(u,F)),"FlowGraphQuaternionFromAxisAngleBlock",u)}}(0,R.h)("FlowGraphQuaternionFromAxisAngleBlock",y);class U extends p.d{constructor(u){super(u),this.a=this.registerDataInput("a",b.u),this.axis=this.registerDataOutput("axis",b.C),this.angle=this.registerDataOutput("angle",b.t),this.isValid=this.registerDataOutput("isValid",b.i)}_updateOutputs(u){const F=u._getExecutionVariable(this,L,-1),z=u._getExecutionVariable(this,W,null),p=u._getExecutionVariable(this,E,null);if(void 0!==z&&null!==z&&void 0!==p&&null!==p&&F===u.executionId)this.axis.setValue(z,u),this.angle.setValue(p,u);else try{const{axis:F,angle:z}=this.a.getValue(u).toAxisAngle();u._setExecutionVariable(this,W,F),u._setExecutionVariable(this,E,z),u._setExecutionVariable(this,L,u.executionId),this.axis.setValue(F,u),this.angle.setValue(z,u),this.isValid.setValue(!0,u)}catch(b){this.isValid.setValue(!1,u)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,R.h)("FlowGraphAxisAngleFromQuaternionBlock",U);class a extends c.c{constructor(u){super(b.C,b.C,b.u,((u,F)=>(0,j.d)(u,F)),"FlowGraphQuaternionFromDirectionsBlock",u)}}},14129:(u,F,z)=>{z.d(F,{c:()=>b});var p=z(14133);class b extends p.e{constructor(u,F,z,p,b,R){super(z,R),this._operation=p,this._className=b,this.a=this.registerDataInput("a",u),this.b=this.registerDataInput("b",F)}_doOperation(u){const F=this.a.getValue(u),z=this.b.getValue(u);return this._operation(F,z)}getClassName(){return this._className}}},14133:(u,F,z)=>{z.d(F,{e:()=>I});var p=z(12980),b=z(12952);const R="cachedOperationValue",c="cachedExecutionId";class I extends p.d{constructor(u,F){super(F),this.value=this.registerDataOutput("value",u),this.isValid=this.registerDataOutput("isValid",b.i)}_updateOutputs(u){const F=u._getExecutionVariable(this,c,-1),z=u._getExecutionVariable(this,R,null);if(void 0!==z&&null!==z&&F===u.executionId)this.isValid.setValue(!0,u),this.value.setValue(z,u);else try{const F=this._doOperation(u);if(void 0===F||null===F)return void this.isValid.setValue(!1,u);u._setExecutionVariable(this,R,F),u._setExecutionVariable(this,c,u.executionId),this.value.setValue(F,u),this.isValid.setValue(!0,u)}catch(p){this.isValid.setValue(!1,u)}}}},14142:(u,F,z)=>{z.d(F,{e:()=>b});var p=z(14133);class b extends p.e{constructor(u,F,z,p,b){super(F,b),this._operation=z,this._className=p,this.a=this.registerDataInput("a",u)}_doOperation(u){return this._operation(this.a.getValue(u))}getClassName(){return this._className}}}}]);