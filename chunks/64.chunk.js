"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{14051:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphAngleBetweenBlock:()=>B,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>t,FlowGraphCrossBlock:()=>r,FlowGraphDotBlock:()=>W,FlowGraphLengthBlock:()=>j,FlowGraphNormalizeBlock:()=>w,FlowGraphQuaternionFromAxisAngleBlock:()=>I,FlowGraphQuaternionFromDirectionsBlock:()=>M,FlowGraphRotate2DBlock:()=>K,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>u,FlowGraphTransformCoordinatesBlock:()=>H});var b=O(12885),F=O(12871),g=O(696),m=O(14033),q=O(14046),R=O(751),X=O(12900),C=O(12499);const L="cachedOperationAxis",G="cachedOperationAngle",A="cachedExecutionId";class j extends q.b{constructor(P){super(F.d,F.o,(P=>this._polymorphicLength(P)),"FlowGraphLengthBlock",P)}_polymorphicLength(P){switch((0,X.j)(P)){case"Vector2":case"dk":case"Vector4":case"Quaternion":return P.length();default:throw new Error(`Cannot compute length of value ${P}`)}}}(0,g.f)("FlowGraphLengthBlock",j);class w extends q.b{constructor(P){super(F.d,F.d,(P=>this._polymorphicNormalize(P)),"FlowGraphNormalizeBlock",P)}_polymorphicNormalize(P){var Q;let O;switch((0,X.j)(P)){case"Vector2":case"dk":case"Vector4":case"Quaternion":if(O=P.normalizeToNew(),null!==(Q=this.config)&&void 0!==Q&&Q.nanOnZeroLength){0===P.length()&&O.ek(NaN)}return O;default:throw new Error(`Cannot normalize value ${P}`)}}}(0,g.f)("FlowGraphNormalizeBlock",w);class W extends m.d{constructor(P){super(F.d,F.d,F.o,((P,Q)=>this._polymorphicDot(P,Q)),"FlowGraphDotBlock",P)}_polymorphicDot(P,Q){switch((0,X.j)(P)){case"Vector2":case"dk":case"Vector4":case"Quaternion":return P.dot(Q);default:throw new Error(`Cannot get dot product of ${P} and ${Q}`)}}}(0,g.f)("FlowGraphDotBlock",W);class r extends m.d{constructor(P){super(F.A,F.A,F.A,((P,Q)=>R.j.Cross(P,Q)),"FlowGraphCrossBlock",P)}}(0,g.f)("FlowGraphCrossBlock",r);class K extends m.d{constructor(P){super(F.w,F.o,F.w,((P,Q)=>P.rotate(Q)),"FlowGraphRotate2DBlock",P)}}(0,g.f)("FlowGraphRotate2DBlock",K);class T extends m.d{constructor(P){super(F.A,F.r,F.A,((P,Q)=>P.applyRotationQuaternion(Q)),"FlowGraphRotate3DBlock",P)}}function x(P,Q){switch((0,X.j)(P)){case"Vector2":case"dk":return Q.transformVector(P);case"Vector4":return new R.k(P.x*Q.m[0]+P.y*Q.m[1]+P.z*Q.m[2]+P.w*Q.m[3],P.x*Q.m[4]+P.y*Q.m[5]+P.z*Q.m[6]+P.w*Q.m[7],P.x*Q.m[8]+P.y*Q.m[9]+P.z*Q.m[10]+P.w*Q.m[11],P.x*Q.m[12]+P.y*Q.m[13]+P.z*Q.m[14]+P.w*Q.m[15]);default:throw new Error(`Cannot transform value ${P}`)}}(0,g.f)("FlowGraphRotate3DBlock",T);class u extends m.d{constructor(P){const Q=(null===P||void 0===P?void 0:P.vectorType)||"dk",O="Vector2"===Q?"Matrix2D":"dk"===Q?"Matrix3D":"Matrix";super((0,F.K)(Q),(0,F.K)(O),(0,F.K)(Q),x,"FlowGraphTransformVectorBlock",P)}}(0,g.f)("FlowGraphTransformVectorBlock",u);class H extends m.d{constructor(P){super(F.A,F.k,F.A,((P,Q)=>R.j.TransformCoordinates(P,Q)),"FlowGraphTransformCoordinatesBlock",P)}}(0,g.f)("FlowGraphTransformCoordinatesBlock",H);class t extends q.b{constructor(P){super(F.r,F.r,(P=>P.conjugate()),"FlowGraphConjugateBlock",P)}}(0,g.f)("FlowGraphConjugateBlock",t);class B extends m.d{constructor(P){super(F.r,F.r,F.o,((P,Q)=>(0,C.b)(P,Q)),"FlowGraphAngleBetweenBlock",P)}}(0,g.f)("FlowGraphAngleBetweenBlock",B);class I extends m.d{constructor(P){super(F.A,F.o,F.r,((P,Q)=>R.d.RotationAxis(P,Q)),"FlowGraphQuaternionFromAxisAngleBlock",P)}}(0,g.f)("FlowGraphQuaternionFromAxisAngleBlock",I);class l extends b.c{constructor(P){super(P),this.a=this.registerDataInput("a",F.r),this.axis=this.registerDataOutput("axis",F.A),this.angle=this.registerDataOutput("angle",F.o),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(P){const Q=P._getExecutionVariable(this,A,-1),O=P._getExecutionVariable(this,L,null),b=P._getExecutionVariable(this,G,null);if(void 0!==O&&null!==O&&void 0!==b&&null!==b&&Q===P.executionId)this.axis.setValue(O,P),this.angle.setValue(b,P);else try{const{axis:Q,angle:O}=this.a.getValue(P).toAxisAngle();P._setExecutionVariable(this,L,Q),P._setExecutionVariable(this,G,O),P._setExecutionVariable(this,A,P.executionId),this.axis.setValue(Q,P),this.angle.setValue(O,P),this.isValid.setValue(!0,P)}catch(F){this.isValid.setValue(!1,P)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,g.f)("FlowGraphAxisAngleFromQuaternionBlock",l);class M extends m.d{constructor(P){super(F.A,F.A,F.r,((P,Q)=>(0,C.d)(P,Q)),"FlowGraphQuaternionFromDirectionsBlock",P)}}},14033:(P,Q,O)=>{O.d(Q,{d:()=>F});var b=O(14042);class F extends b.e{constructor(P,Q,O,b,F,g){super(O,g),this._operation=b,this._className=F,this.a=this.registerDataInput("a",P),this.b=this.registerDataInput("b",Q)}_doOperation(P){const Q=this.a.getValue(P),O=this.b.getValue(P);return this._operation(Q,O)}getClassName(){return this._className}}},14042:(P,Q,O)=>{O.d(Q,{e:()=>q});var b=O(12885),F=O(12871);const g="cachedOperationValue",m="cachedExecutionId";class q extends b.c{constructor(P,Q){super(Q),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(P){const Q=P._getExecutionVariable(this,m,-1),O=P._getExecutionVariable(this,g,null);if(void 0!==O&&null!==O&&Q===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(O,P);else try{const Q=this._doOperation(P);if(void 0===Q||null===Q)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,g,Q),P._setExecutionVariable(this,m,P.executionId),this.value.setValue(Q,P),this.isValid.setValue(!0,P)}catch(b){this.isValid.setValue(!1,P)}}}},14046:(P,Q,O)=>{O.d(Q,{b:()=>F});var b=O(14042);class F extends b.e{constructor(P,Q,O,b,F){super(Q,F),this._operation=O,this._className=b,this.a=this.registerDataInput("a",P)}_doOperation(P){return this._operation(this.a.getValue(P))}getClassName(){return this._className}}}}]);