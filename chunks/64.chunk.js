"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{14422:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphStopAnimationBlock:()=>D});var k=H(13246),c=H(610),t=H(493),A=H(13299);class D extends A.b{constructor(R){super(R),this.animationGroup=this.registerDataInput("animationGroup",k.b),this.stopAtFrame=this.registerDataInput("stopAtFrame",k.m,-1)}_preparePendingTasks(R){const x=this.animationGroup.getValue(R),H=this.stopAtFrame.getValue(R)??-1,k=R._getGlobalContextVariable("pendingStopAnimations",[]);k.push({uniqueId:x.uniqueId,stopAtFrame:H}),R._setGlobalContextVariable("pendingStopAnimations",k)}_cancelPendingTasks(R){const x=this.animationGroup.getValue(R),H=R._getGlobalContextVariable("pendingStopAnimations",[]);for(let k=0;k<H.length;k++)if(H[k].uniqueId===x.uniqueId){H.splice(k,1),R._setGlobalContextVariable("pendingStopAnimations",H);break}}_execute(R){const x=this.animationGroup.getValue(R),H=this.stopAtFrame.getValue(R)??-1;return x?isNaN(H)?this._reportError(R,"Invalid stop time."):(H>0?this._startPendingTasks(R):this._stopAnimation(x,R),void this.out._activateSignal(R)):(t.c.Warn("No animation group provided to stop."),this._reportError(R,"No animation group provided to stop."))}_executeOnTick(R){const x=this.animationGroup.getValue(R),H=R._getGlobalContextVariable("pendingStopAnimations",[]);for(let k=0;k<H.length;k++)if(H[k].uniqueId===x.uniqueId&&x.getCurrentFrame()>=H[k].stopAtFrame){this._stopAnimation(x,R),H.splice(k,1),R._setGlobalContextVariable("pendingStopAnimations",H),this.done._activateSignal(R),R._removePendingBlock(this);break}}getClassName(){return"FlowGraphStopAnimationBlock"}_stopAnimation(R,x){const H=x._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),k=H.indexOf(R.uniqueId);-1!==k&&(R.stop(),H.splice(k,1),x._setGlobalContextVariable("currentlyRunningAnimationGroups",H))}}(0,c.h)("FlowGraphStopAnimationBlock",D)}}]);