"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{14021:(U,M,b)=>{b.r(M),b.d(M,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>d,FlowGraphConjugateBlock:()=>h,FlowGraphCrossBlock:()=>F,FlowGraphDotBlock:()=>J,FlowGraphLengthBlock:()=>r,FlowGraphNormalizeBlock:()=>B,FlowGraphQuaternionFromAxisAngleBlock:()=>Y,FlowGraphQuaternionFromDirectionsBlock:()=>s,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>L,FlowGraphTransformBlock:()=>o,FlowGraphTransformCoordinatesBlock:()=>S});var a=b(12795),A=b(12775),H=b(609),W=b(14006),y=b(14015),O=b(670),e=b(12809),x=b(12418);const P="cachedOperationAxis",Z="cachedOperationAngle",C="cachedExecutionId";class r extends y.b{constructor(U){super(A.c,A.t,(U=>this._polymorphicLength(U)),"FlowGraphLengthBlock",U)}_polymorphicLength(U){switch((0,e.k)(U)){case"Vector2":case"lk":case"Vector4":case"Quaternion":return U.length();default:throw new Error(`Cannot compute length of value ${U}`)}}}(0,H.i)("FlowGraphLengthBlock",r);class B extends y.b{constructor(U){super(A.c,A.c,(U=>this._polymorphicNormalize(U)),"FlowGraphNormalizeBlock",U)}_polymorphicNormalize(U){var M;let b;switch((0,e.k)(U)){case"Vector2":case"lk":case"Vector4":case"Quaternion":if(b=U.normalizeToNew(),null!==(M=this.config)&&void 0!==M&&M.nanOnZeroLength){0===U.length()&&b.mk(NaN)}return b;default:throw new Error(`Cannot normalize value ${U}`)}}}(0,H.i)("FlowGraphNormalizeBlock",B);class J extends W.d{constructor(U){super(A.c,A.c,A.t,((U,M)=>this._polymorphicDot(U,M)),"FlowGraphDotBlock",U)}_polymorphicDot(U,M){switch((0,e.k)(U)){case"Vector2":case"lk":case"Vector4":case"Quaternion":return U.dot(M);default:throw new Error(`Cannot get dot product of ${U} and ${M}`)}}}(0,H.i)("FlowGraphDotBlock",J);class F extends W.d{constructor(U){super(A.G,A.G,A.G,((U,M)=>O.l.Cross(U,M)),"FlowGraphCrossBlock",U)}}(0,H.i)("FlowGraphCrossBlock",F);class f extends W.d{constructor(U){super(A.D,A.t,A.D,((U,M)=>U.rotate(M)),"FlowGraphRotate2DBlock",U)}}(0,H.i)("FlowGraphRotate2DBlock",f);class L extends W.d{constructor(U){super(A.G,A.x,A.G,((U,M)=>U.applyRotationQuaternion(M)),"FlowGraphRotate3DBlock",U)}}function z(U,M){switch((0,e.k)(U)){case"Vector2":case"lk":return M.transformVector(U);case"Vector4":return new O.n(U.x*M.m[0]+U.y*M.m[1]+U.z*M.m[2]+U.w*M.m[3],U.x*M.m[4]+U.y*M.m[5]+U.z*M.m[6]+U.w*M.m[7],U.x*M.m[8]+U.y*M.m[9]+U.z*M.m[10]+U.w*M.m[11],U.x*M.m[12]+U.y*M.m[13]+U.z*M.m[14]+U.w*M.m[15]);default:throw new Error(`Cannot transform value ${U}`)}}(0,H.i)("FlowGraphRotate3DBlock",L);class o extends W.d{constructor(U){const M=(null===U||void 0===U?void 0:U.vectorType)||"lk",b="Vector2"===M?"Matrix2D":"lk"===M?"Matrix3D":"Matrix";super((0,A.M)(M),(0,A.M)(b),(0,A.M)(M),z,"FlowGraphTransformVectorBlock",U)}}(0,H.i)("FlowGraphTransformVectorBlock",o);class S extends W.d{constructor(U){super(A.G,A.m,A.G,((U,M)=>O.l.TransformCoordinates(U,M)),"FlowGraphTransformCoordinatesBlock",U)}}(0,H.i)("FlowGraphTransformCoordinatesBlock",S);class h extends y.b{constructor(U){super(A.x,A.x,(U=>U.conjugate()),"FlowGraphConjugateBlock",U)}}(0,H.i)("FlowGraphConjugateBlock",h);class i extends W.d{constructor(U){super(A.x,A.x,A.t,((U,M)=>(0,x.c)(U,M)),"FlowGraphAngleBetweenBlock",U)}}(0,H.i)("FlowGraphAngleBetweenBlock",i);class Y extends W.d{constructor(U){super(A.G,A.t,A.x,((U,M)=>O.e.RotationAxis(U,M)),"FlowGraphQuaternionFromAxisAngleBlock",U)}}(0,H.i)("FlowGraphQuaternionFromAxisAngleBlock",Y);class d extends a.c{constructor(U){super(U),this.a=this.registerDataInput("a",A.x),this.axis=this.registerDataOutput("axis",A.G),this.angle=this.registerDataOutput("angle",A.t),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(U){const M=U._getExecutionVariable(this,C,-1),b=U._getExecutionVariable(this,P,null),a=U._getExecutionVariable(this,Z,null);if(void 0!==b&&null!==b&&void 0!==a&&null!==a&&M===U.executionId)this.axis.setValue(b,U),this.angle.setValue(a,U);else try{const{axis:M,angle:b}=this.a.getValue(U).toAxisAngle();U._setExecutionVariable(this,P,M),U._setExecutionVariable(this,Z,b),U._setExecutionVariable(this,C,U.executionId),this.axis.setValue(M,U),this.angle.setValue(b,U),this.isValid.setValue(!0,U)}catch(A){this.isValid.setValue(!1,U)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,H.i)("FlowGraphAxisAngleFromQuaternionBlock",d);class s extends W.d{constructor(U){super(A.G,A.G,A.x,((U,M)=>(0,x.d)(U,M)),"FlowGraphQuaternionFromDirectionsBlock",U)}}},14006:(U,M,b)=>{b.d(M,{d:()=>A});var a=b(14008);class A extends a.c{constructor(U,M,b,a,A,H){super(b,H),this._operation=a,this._className=A,this.a=this.registerDataInput("a",U),this.b=this.registerDataInput("b",M)}_doOperation(U){const M=this.a.getValue(U),b=this.b.getValue(U);return this._operation(M,b)}getClassName(){return this._className}}},14008:(U,M,b)=>{b.d(M,{c:()=>y});var a=b(12795),A=b(12775);const H="cachedOperationValue",W="cachedExecutionId";class y extends a.c{constructor(U,M){super(M),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(U){const M=U._getExecutionVariable(this,W,-1),b=U._getExecutionVariable(this,H,null);if(void 0!==b&&null!==b&&M===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(b,U);else try{const M=this._doOperation(U);if(void 0===M||null===M)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,H,M),U._setExecutionVariable(this,W,U.executionId),this.value.setValue(M,U),this.isValid.setValue(!0,U)}catch(a){this.isValid.setValue(!1,U)}}}},14015:(U,M,b)=>{b.d(M,{b:()=>A});var a=b(14008);class A extends a.c{constructor(U,M,b,a,A){super(M,A),this._operation=b,this._className=a,this.a=this.registerDataInput("a",U)}_doOperation(U){return this._operation(this.a.getValue(U))}getClassName(){return this._className}}}}]);