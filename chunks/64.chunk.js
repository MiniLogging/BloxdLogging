"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{14061:(n,k,T)=>{T.r(k),T.d(k,{FlowGraphAngleBetweenBlock:()=>A,FlowGraphAxisAngleFromQuaternionBlock:()=>F,FlowGraphConjugateBlock:()=>f,FlowGraphCrossBlock:()=>C,FlowGraphDotBlock:()=>b,FlowGraphLengthBlock:()=>H,FlowGraphNormalizeBlock:()=>s,FlowGraphQuaternionFromAxisAngleBlock:()=>v,FlowGraphQuaternionFromDirectionsBlock:()=>m,FlowGraphRotate2DBlock:()=>z,FlowGraphRotate3DBlock:()=>r,FlowGraphTransformBlock:()=>O,FlowGraphTransformCoordinatesBlock:()=>u});var c=T(12845),K=T(12831),Q=T(675),G=T(14044),w=T(14055),E=T(730),I=T(12861),S=T(12454);const P="cachedOperationAxis",W="cachedOperationAngle",J="cachedExecutionId";class H extends w.c{constructor(n){super(K.e,K.w,(n=>this._polymorphicLength(n)),"FlowGraphLengthBlock",n)}_polymorphicLength(n){switch((0,I.m)(n)){case"Vector2":case"li":case"Vector4":case"Quaternion":return n.length();default:throw new Error(`Cannot compute length of value ${n}`)}}}(0,Q.f)("FlowGraphLengthBlock",H);class s extends w.c{constructor(n){super(K.e,K.e,(n=>this._polymorphicNormalize(n)),"FlowGraphNormalizeBlock",n)}_polymorphicNormalize(n){var k;let T;switch((0,I.m)(n)){case"Vector2":case"li":case"Vector4":case"Quaternion":if(T=n.normalizeToNew(),null!==(k=this.config)&&void 0!==k&&k.nanOnZeroLength){0===n.length()&&T.ki(NaN)}return T;default:throw new Error(`Cannot normalize value ${n}`)}}}(0,Q.f)("FlowGraphNormalizeBlock",s);class b extends G.e{constructor(n){super(K.e,K.e,K.w,((n,k)=>this._polymorphicDot(n,k)),"FlowGraphDotBlock",n)}_polymorphicDot(n,k){switch((0,I.m)(n)){case"Vector2":case"li":case"Vector4":case"Quaternion":return n.dot(k);default:throw new Error(`Cannot get dot product of ${n} and ${k}`)}}}(0,Q.f)("FlowGraphDotBlock",b);class C extends G.e{constructor(n){super(K.C,K.C,K.C,((n,k)=>E.o.Cross(n,k)),"FlowGraphCrossBlock",n)}}(0,Q.f)("FlowGraphCrossBlock",C);class z extends G.e{constructor(n){super(K.A,K.w,K.A,((n,k)=>n.rotate(k)),"FlowGraphRotate2DBlock",n)}}(0,Q.f)("FlowGraphRotate2DBlock",z);class r extends G.e{constructor(n){super(K.C,K.x,K.C,((n,k)=>n.applyRotationQuaternion(k)),"FlowGraphRotate3DBlock",n)}}function q(n,k){switch((0,I.m)(n)){case"Vector2":case"li":return k.transformVector(n);case"Vector4":return new E.p(n.x*k.m[0]+n.y*k.m[1]+n.z*k.m[2]+n.w*k.m[3],n.x*k.m[4]+n.y*k.m[5]+n.z*k.m[6]+n.w*k.m[7],n.x*k.m[8]+n.y*k.m[9]+n.z*k.m[10]+n.w*k.m[11],n.x*k.m[12]+n.y*k.m[13]+n.z*k.m[14]+n.w*k.m[15]);default:throw new Error(`Cannot transform value ${n}`)}}(0,Q.f)("FlowGraphRotate3DBlock",r);class O extends G.e{constructor(n){const k=(null===n||void 0===n?void 0:n.vectorType)||"li",T="Vector2"===k?"Matrix2D":"li"===k?"Matrix3D":"Matrix";super((0,K.L)(k),(0,K.L)(T),(0,K.L)(k),q,"FlowGraphTransformVectorBlock",n)}}(0,Q.f)("FlowGraphTransformVectorBlock",O);class u extends G.e{constructor(n){super(K.C,K.m,K.C,((n,k)=>E.o.TransformCoordinates(n,k)),"FlowGraphTransformCoordinatesBlock",n)}}(0,Q.f)("FlowGraphTransformCoordinatesBlock",u);class f extends w.c{constructor(n){super(K.x,K.x,(n=>n.conjugate()),"FlowGraphConjugateBlock",n)}}(0,Q.f)("FlowGraphConjugateBlock",f);class A extends G.e{constructor(n){super(K.x,K.x,K.w,((n,k)=>(0,S.e)(n,k)),"FlowGraphAngleBetweenBlock",n)}}(0,Q.f)("FlowGraphAngleBetweenBlock",A);class v extends G.e{constructor(n){super(K.C,K.w,K.x,((n,k)=>E.h.RotationAxis(n,k)),"FlowGraphQuaternionFromAxisAngleBlock",n)}}(0,Q.f)("FlowGraphQuaternionFromAxisAngleBlock",v);class F extends c.b{constructor(n){super(n),this.a=this.registerDataInput("a",K.x),this.axis=this.registerDataOutput("axis",K.C),this.angle=this.registerDataOutput("angle",K.w),this.isValid=this.registerDataOutput("isValid",K.g)}_updateOutputs(n){const k=n._getExecutionVariable(this,J,-1),T=n._getExecutionVariable(this,P,null),c=n._getExecutionVariable(this,W,null);if(void 0!==T&&null!==T&&void 0!==c&&null!==c&&k===n.executionId)this.axis.setValue(T,n),this.angle.setValue(c,n);else try{const{axis:k,angle:T}=this.a.getValue(n).toAxisAngle();n._setExecutionVariable(this,P,k),n._setExecutionVariable(this,W,T),n._setExecutionVariable(this,J,n.executionId),this.axis.setValue(k,n),this.angle.setValue(T,n),this.isValid.setValue(!0,n)}catch(K){this.isValid.setValue(!1,n)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,Q.f)("FlowGraphAxisAngleFromQuaternionBlock",F);class m extends G.e{constructor(n){super(K.C,K.C,K.x,((n,k)=>(0,S.i)(n,k)),"FlowGraphQuaternionFromDirectionsBlock",n)}}},14044:(n,k,T)=>{T.d(k,{e:()=>K});var c=T(14053);class K extends c.b{constructor(n,k,T,c,K,Q){super(T,Q),this._operation=c,this._className=K,this.a=this.registerDataInput("a",n),this.b=this.registerDataInput("b",k)}_doOperation(n){const k=this.a.getValue(n),T=this.b.getValue(n);return this._operation(k,T)}getClassName(){return this._className}}},14053:(n,k,T)=>{T.d(k,{b:()=>w});var c=T(12845),K=T(12831);const Q="cachedOperationValue",G="cachedExecutionId";class w extends c.b{constructor(n,k){super(k),this.value=this.registerDataOutput("value",n),this.isValid=this.registerDataOutput("isValid",K.g)}_updateOutputs(n){const k=n._getExecutionVariable(this,G,-1),T=n._getExecutionVariable(this,Q,null);if(void 0!==T&&null!==T&&k===n.executionId)this.isValid.setValue(!0,n),this.value.setValue(T,n);else try{const k=this._doOperation(n);if(void 0===k||null===k)return void this.isValid.setValue(!1,n);n._setExecutionVariable(this,Q,k),n._setExecutionVariable(this,G,n.executionId),this.value.setValue(k,n),this.isValid.setValue(!0,n)}catch(c){this.isValid.setValue(!1,n)}}}},14055:(n,k,T)=>{T.d(k,{c:()=>K});var c=T(14053);class K extends c.b{constructor(n,k,T,c,K){super(k,K),this._operation=T,this._className=c,this.a=this.registerDataInput("a",n)}_doOperation(n){return this._operation(this.a.getValue(n))}getClassName(){return this._className}}}}]);