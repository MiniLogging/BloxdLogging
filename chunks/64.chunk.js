"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[64],{13878:(J,T,b)=>{b.r(T),b.d(T,{FlowGraphAngleBetweenBlock:()=>o,FlowGraphAxisAngleFromQuaternionBlock:()=>H,FlowGraphConjugateBlock:()=>p,FlowGraphCrossBlock:()=>u,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>G,FlowGraphNormalizeBlock:()=>x,FlowGraphQuaternionFromAxisAngleBlock:()=>S,FlowGraphQuaternionFromDirectionsBlock:()=>s,FlowGraphRotate2DBlock:()=>U,FlowGraphRotate3DBlock:()=>K,FlowGraphTransformBlock:()=>l,FlowGraphTransformCoordinatesBlock:()=>W});var q=b(12627),t=b(12603),j=b(639),B=b(13861),Y=b(13872),C=b(697),F=b(12633),A=b(12180);const a="cachedOperationAxis",P="cachedOperationAngle",v="cachedExecutionId";class G extends Y.d{constructor(J){super(t.c,t.r,(J=>this._polymorphicLength(J)),"FlowGraphLengthBlock",J)}_polymorphicLength(J){switch((0,F.k)(J)){case"Vector2":case"pi":case"Vector4":case"Quaternion":return J.length();default:throw new Error(`Cannot compute length of value ${J}`)}}}(0,j.g)("FlowGraphLengthBlock",G);class x extends Y.d{constructor(J){super(t.c,t.c,(J=>this._polymorphicNormalize(J)),"FlowGraphNormalizeBlock",J)}_polymorphicNormalize(J){var T;let b;switch((0,F.k)(J)){case"Vector2":case"pi":case"Vector4":case"Quaternion":if(b=J.normalizeToNew(),null!==(T=this.config)&&void 0!==T&&T.nanOnZeroLength){0===J.length()&&b.oi(NaN)}return b;default:throw new Error(`Cannot normalize value ${J}`)}}}(0,j.g)("FlowGraphNormalizeBlock",x);class I extends B.d{constructor(J){super(t.c,t.c,t.r,((J,T)=>this._polymorphicDot(J,T)),"FlowGraphDotBlock",J)}_polymorphicDot(J,T){switch((0,F.k)(J)){case"Vector2":case"pi":case"Vector4":case"Quaternion":return J.dot(T);default:throw new Error(`Cannot get dot product of ${J} and ${T}`)}}}(0,j.g)("FlowGraphDotBlock",I);class u extends B.d{constructor(J){super(t.E,t.E,t.E,((J,T)=>C.n.Cross(J,T)),"FlowGraphCrossBlock",J)}}(0,j.g)("FlowGraphCrossBlock",u);class U extends B.d{constructor(J){super(t.B,t.r,t.B,((J,T)=>J.rotate(T)),"FlowGraphRotate2DBlock",J)}}(0,j.g)("FlowGraphRotate2DBlock",U);class K extends B.d{constructor(J){super(t.E,t.u,t.E,((J,T)=>J.applyRotationQuaternion(T)),"FlowGraphRotate3DBlock",J)}}function E(J,T){switch((0,F.k)(J)){case"Vector2":case"pi":return T.transformVector(J);case"Vector4":return new C.p(J.x*T.m[0]+J.y*T.m[1]+J.z*T.m[2]+J.w*T.m[3],J.x*T.m[4]+J.y*T.m[5]+J.z*T.m[6]+J.w*T.m[7],J.x*T.m[8]+J.y*T.m[9]+J.z*T.m[10]+J.w*T.m[11],J.x*T.m[12]+J.y*T.m[13]+J.z*T.m[14]+J.w*T.m[15]);default:throw new Error(`Cannot transform value ${J}`)}}(0,j.g)("FlowGraphRotate3DBlock",K);class l extends B.d{constructor(J){const T=(null===J||void 0===J?void 0:J.vectorType)||"pi",b="Vector2"===T?"Matrix2D":"pi"===T?"Matrix3D":"Matrix";super((0,t.O)(T),(0,t.O)(b),(0,t.O)(T),E,"FlowGraphTransformVectorBlock",J)}}(0,j.g)("FlowGraphTransformVectorBlock",l);class W extends B.d{constructor(J){super(t.E,t.l,t.E,((J,T)=>C.n.TransformCoordinates(J,T)),"FlowGraphTransformCoordinatesBlock",J)}}(0,j.g)("FlowGraphTransformCoordinatesBlock",W);class p extends Y.d{constructor(J){super(t.u,t.u,(J=>J.conjugate()),"FlowGraphConjugateBlock",J)}}(0,j.g)("FlowGraphConjugateBlock",p);class o extends B.d{constructor(J){super(t.u,t.u,t.r,((J,T)=>(0,A.b)(J,T)),"FlowGraphAngleBetweenBlock",J)}}(0,j.g)("FlowGraphAngleBetweenBlock",o);class S extends B.d{constructor(J){super(t.E,t.r,t.u,((J,T)=>C.h.RotationAxis(J,T)),"FlowGraphQuaternionFromAxisAngleBlock",J)}}(0,j.g)("FlowGraphQuaternionFromAxisAngleBlock",S);class H extends q.b{constructor(J){super(J),this.a=this.registerDataInput("a",t.u),this.axis=this.registerDataOutput("axis",t.E),this.angle=this.registerDataOutput("angle",t.r),this.isValid=this.registerDataOutput("isValid",t.e)}_updateOutputs(J){const T=J._getExecutionVariable(this,v,-1),b=J._getExecutionVariable(this,a,null),q=J._getExecutionVariable(this,P,null);if(void 0!==b&&null!==b&&void 0!==q&&null!==q&&T===J.executionId)this.axis.setValue(b,J),this.angle.setValue(q,J);else try{const{axis:T,angle:b}=this.a.getValue(J).toAxisAngle();J._setExecutionVariable(this,a,T),J._setExecutionVariable(this,P,b),J._setExecutionVariable(this,v,J.executionId),this.axis.setValue(T,J),this.angle.setValue(b,J),this.isValid.setValue(!0,J)}catch(t){this.isValid.setValue(!1,J)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,j.g)("FlowGraphAxisAngleFromQuaternionBlock",H);class s extends B.d{constructor(J){super(t.E,t.E,t.u,((J,T)=>(0,A.c)(J,T)),"FlowGraphQuaternionFromDirectionsBlock",J)}}},13861:(J,T,b)=>{b.d(T,{d:()=>t});var q=b(13865);class t extends q.c{constructor(J,T,b,q,t,j){super(b,j),this._operation=q,this._className=t,this.a=this.registerDataInput("a",J),this.b=this.registerDataInput("b",T)}_doOperation(J){const T=this.a.getValue(J),b=this.b.getValue(J);return this._operation(T,b)}getClassName(){return this._className}}},13865:(J,T,b)=>{b.d(T,{c:()=>Y});var q=b(12627),t=b(12603);const j="cachedOperationValue",B="cachedExecutionId";class Y extends q.b{constructor(J,T){super(T),this.value=this.registerDataOutput("value",J),this.isValid=this.registerDataOutput("isValid",t.e)}_updateOutputs(J){const T=J._getExecutionVariable(this,B,-1),b=J._getExecutionVariable(this,j,null);if(void 0!==b&&null!==b&&T===J.executionId)this.isValid.setValue(!0,J),this.value.setValue(b,J);else try{const T=this._doOperation(J);if(void 0===T||null===T)return void this.isValid.setValue(!1,J);J._setExecutionVariable(this,j,T),J._setExecutionVariable(this,B,J.executionId),this.value.setValue(T,J),this.isValid.setValue(!0,J)}catch(q){this.isValid.setValue(!1,J)}}}},13872:(J,T,b)=>{b.d(T,{d:()=>t});var q=b(13865);class t extends q.c{constructor(J,T,b,q,t){super(T,t),this._operation=b,this._className=q,this.a=this.registerDataInput("a",J)}_doOperation(J){return this._operation(this.a.getValue(J))}getClassName(){return this._className}}}}]);