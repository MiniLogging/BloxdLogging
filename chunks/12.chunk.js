"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{11287:(x,Z,l)=>{l.r(Z),l.d(Z,{_ExrTextureLoader:()=>K});var t=l(1156),L=l(1076);const z=65536,A=14,P=65537,C=16384;var j,V;!function(x){x[x.NO_COMPRESSION=0]="NO_COMPRESSION",x[x.RLE_COMPRESSION=1]="RLE_COMPRESSION",x[x.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",x[x.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",x[x.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",x[x.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(j||(j={})),function(x){x[x.INCREASING_Y=0]="INCREASING_Y",x[x.DECREASING_Y=1]="DECREASING_Y"}(V||(V={}));const Q=function(){const x=new ArrayBuffer(4),Z=new Float32Array(x),l=new Uint32Array(x),t=new Uint32Array(512),L=new Uint32Array(512);for(let C=0;C<256;++C){const x=C-127;x<-27?(t[C]=0,t[256|C]=32768,L[C]=24,L[256|C]=24):x<-14?(t[C]=1024>>-x-14,t[256|C]=1024>>-x-14|32768,L[C]=-x-1,L[256|C]=-x-1):x<=15?(t[C]=x+15<<10,t[256|C]=x+15<<10|32768,L[C]=13,L[256|C]=13):x<128?(t[C]=31744,t[256|C]=64512,L[C]=24,L[256|C]=24):(t[C]=31744,t[256|C]=64512,L[C]=13,L[256|C]=13)}const z=new Uint32Array(2048),A=new Uint32Array(64),P=new Uint32Array(64);for(let C=1;C<1024;++C){let x=C<<13,Z=0;for(;0===(8388608&x);)x<<=1,Z-=8388608;x&=-8388609,Z+=947912704,z[C]=x|Z}for(let C=1024;C<2048;++C)z[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)A[C]=C<<23;A[31]=1199570944,A[32]=2147483648;for(let C=33;C<63;++C)A[C]=2147483648+(C-32<<23);A[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(P[C]=1024);return{floatView:Z,uint32View:l,baseTable:t,shiftTable:L,mantissaTable:z,exponentTable:A,offsetTable:P}}();function c(x,Z){const l=new Uint8Array(x);let t=0;for(;0!=l[Z.value+t];)t+=1;const L=(new TextDecoder).decode(l.slice(Z.value,Z.value+t));return Z.value=Z.value+t+1,L}function a(x,Z){const l=x.getInt32(Z.value,!0);return Z.value+=4,l}function I(x,Z){const l=x.getUint32(Z.value,!0);return Z.value+=4,l}function u(x,Z){const l=x.getUint8(Z.value);return Z.value+=1,l}function n(x,Z){const l=x.getUint16(Z.value,!0);return Z.value+=2,l}function v(x,Z){const l=x[Z.value];return Z.value+=1,l}function X(x,Z){let l;return l="getBigInt64"in DataView.prototype?Number(x.getBigInt64(Z.value,!0)):x.getUint32(Z.value+4,!0)+Number(x.getUint32(Z.value,!0)<<32),Z.value+=8,l}function W(x,Z){const l=x.getFloat32(Z.value,!0);return Z.value+=4,l}function f(x,Z){return function(x){const Z=(31744&x)>>10,l=1023&x;return(x>>15?-1:1)*(Z?31===Z?l?NaN:1/0:Math.pow(2,Z-15)*(1+l/1024):l/1024*6103515625e-14)}(n(x,Z))}function S(x,Z){return function(x){if(Math.abs(x)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");x=(0,L.d)(x,-65504,65504),Q.floatView[0]=x;const Z=Q.uint32View[0],l=Z>>23&511;return Q.baseTable[l]+((8388607&Z)>>Q.shiftTable[l])}(W(x,Z))}function T(x,Z,l,t){switch(l){case"string":case"stringvector":case"iccProfile":return function(x,Z,l){const t=(new TextDecoder).decode(new Uint8Array(x).slice(Z.value,Z.value+l));return Z.value=Z.value+l,t}(x.buffer,Z,t);case"chlist":return function(x,Z,l){const t=Z.value,L=[];for(;Z.value<t+l-1;){const l=c(x.buffer,Z),t=a(x,Z),z=u(x,Z);Z.value+=3;const A=a(x,Z),P=a(x,Z);L.push({name:l,pixelType:t,pLinear:z,xSampling:A,ySampling:P})}return Z.value+=1,L}(x,Z,t);case"chromaticities":return function(x,Z){return{redX:W(x,Z),redY:W(x,Z),greenX:W(x,Z),greenY:W(x,Z),blueX:W(x,Z),blueY:W(x,Z),whiteX:W(x,Z),whiteY:W(x,Z)}}(x,Z);case"compression":return function(x,Z){return u(x,Z)}(x,Z);case"box2i":return function(x,Z){return{xMin:a(x,Z),yMin:a(x,Z),xMax:a(x,Z),yMax:a(x,Z)}}(x,Z);case"lineOrder":return function(x,Z){const l=u(x,Z);return V[l]}(x,Z);case"float":return W(x,Z);case"v2f":return function(x,Z){return[W(x,Z),W(x,Z)]}(x,Z);case"v3f":return function(x,Z){return[W(x,Z),W(x,Z),W(x,Z)]}(x,Z);case"int":return a(x,Z);case"rational":return function(x,Z){return[a(x,Z),I(x,Z)]}(x,Z);case"timecode":return function(x,Z){return[I(x,Z),I(x,Z)]}(x,Z);case"preview":return Z.value+=t,"skipped";default:return void(Z.value+=t)}}function H(x){for(let Z=1;Z<x.length;Z++){const l=x[Z-1]+x[Z]-128;x[Z]=l}}function R(x,Z){let l=0,t=Math.floor((x.length+1)/2),L=0;const z=x.length-1;for(;!(L>z)&&(Z[L++]=x[l++],!(L>z));)Z[L++]=x[t++]}function J(x,Z,l,t,L){for(;l<x;)Z=Z<<8|v(t,L),l+=8;return{l:Z>>(l-=x)&(1<<x)-1,c:Z,lc:l}}function U(x,Z,l,t){return{c:x=x<<8|v(l,t),lc:Z+=8}}function d(x,Z,l,t,L,z,A,P,C){if(x==Z){if(t<8){const x=U(l,t,L,z);l=x.c,t=x.lc}let x=l>>(t-=8);if(x=new Uint8Array([x])[0],P.value+x>C)return null;const Z=A[P.value-1];for(;x-- >0;)A[P.value++]=Z}else{if(!(P.value<C))return null;A[P.value++]=x}return{c:l,lc:t}}const k=new Array(59);function G(x,Z,l,t,L,z){const A=Z;let C=0,j=0;for(;t<=L;t++){if(A.value-Z.value>l)return;let P=J(6,C,j,x,A);const V=P.l;if(C=P.c,j=P.lc,z[t]=V,63==V){if(A.value-Z.value>l)throw new Error("Error in HufUnpackEncTable");P=J(8,C,j,x,A);let V=P.l+6;if(C=P.c,j=P.lc,t+V>L+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)z[t++]=0;t--}else if(V>=59){let x=V-59+2;if(t+x>L+1)throw new Error("Error in HufUnpackEncTable");for(;x--;)z[t++]=0;t--}}!function(x){for(let l=0;l<=58;++l)k[l]=0;for(let l=0;l<P;++l)k[x[l]]+=1;let Z=0;for(let l=58;l>0;--l){const x=Z+k[l]>>1;k[l]=Z,Z=x}for(let l=0;l<P;++l){const Z=x[l];Z>0&&(x[l]=Z|k[Z]++<<6)}}(z)}function p(x){return 63&x}function N(x){return x>>6}function B(x,Z,l,t,L,z){const j=l.value,V=I(Z,l),Q=I(Z,l);l.value+=4;const c=I(Z,l);if(l.value+=4,V<0||V>=P||Q<0||Q>=P)throw new Error("Wrong HUF_ENCSIZE");const a=new Array(P),u=new Array(C);!function(x){for(let Z=0;Z<C;Z++)x[Z]={},x[Z].len=0,x[Z].lit=0,x[Z].p=null}(u);if(G(x,l,t-(l.value-j),V,Q,a),c>8*(t-(l.value-j)))throw new Error("Wrong hufUncompress");!function(x,Z,l,t){for(;Z<=l;Z++){const l=N(x[Z]),L=p(x[Z]);if(l>>L)throw new Error("Invalid table entry");if(L>A){const x=t[l>>L-A];if(x.len)throw new Error("Invalid table entry");if(x.lit++,x.p){const Z=x.p;x.p=new Array(x.lit);for(let l=0;l<x.lit-1;++l)x.p[l]=Z[l]}else x.p=new Array(1);x.p[x.lit-1]=Z}else if(L){let x=0;for(let z=1<<A-L;z>0;z--){const z=t[(l<<A-L)+x];if(z.len||z.p)throw new Error("Invalid table entry");z.len=L,z.lit=Z,x++}}}}(a,V,Q,u),function(x,Z,l,t,L,z,P,C,j){let V=0,Q=0;const c=P,a=Math.trunc(t.value+(L+7)/8);for(;t.value<a;){let L=U(V,Q,l,t);for(V=L.c,Q=L.lc;Q>=A;){const P=Z[V>>Q-A&16383];if(P.len){Q-=P.len;const x=d(P.lit,z,V,Q,l,t,C,j,c);x&&(V=x.c,Q=x.lc)}else{if(!P.p)throw new Error("hufDecode issues");let Z;for(Z=0;Z<P.lit;Z++){const A=p(x[P.p[Z]]);for(;Q<A&&t.value<a;)L=U(V,Q,l,t),V=L.c,Q=L.lc;if(Q>=A&&N(x[P.p[Z]])==(V>>Q-A&(1<<A)-1)){Q-=A;const x=d(P.p[Z],z,V,Q,l,t,C,j,c);x&&(V=x.c,Q=x.lc);break}}if(Z==P.lit)throw new Error("HufDecode issues")}}}const I=8-L&7;for(V>>=I,Q-=I;Q>0;){const x=Z[V<<A-Q&16383];if(!x.len)throw new Error("HufDecode issues");{Q-=x.len;const Z=d(x.lit,z,V,Q,l,t,C,j,c);Z&&(V=Z.c,Q=Z.lc)}}}(a,u,x,l,c,Q,z,L,{value:0})}function m(x){return 65535&x}function h(x){const Z=m(x);return Z>32767?Z-65536:Z}function s(x,Z){const l=h(x),t=h(Z),L=l+(1&t)+(t>>1);return{a:L,b:L-t}}function o(x,Z){const l=m(x),t=m(Z),L=l-(t>>1)&65535;return{a:t+L-32768&65535,b:L}}function r(x,Z,l,t,L,z,A){const P=A<16384,C=l>L?L:l;let j,V,Q=1;for(;Q<=C;)Q<<=1;for(Q>>=1,j=Q,Q>>=1;Q>=1;){V=0;const A=V+z*(L-j),C=z*Q,c=z*j,a=t*Q,I=t*j;let u,n,v,X;for(;V<=A;V+=c){let L=V;const z=V+t*(l-j);for(;L<=z;L+=I){const l=L+a,t=L+C,z=t+a;if(P){let A=s(x[L+Z],x[t+Z]);u=A.a,v=A.b,A=s(x[l+Z],x[z+Z]),n=A.a,X=A.b,A=s(u,n),x[L+Z]=A.a,x[l+Z]=A.b,A=s(v,X),x[t+Z]=A.a,x[z+Z]=A.b}else{let A=o(x[L+Z],x[t+Z]);u=A.a,v=A.b,A=o(x[l+Z],x[z+Z]),n=A.a,X=A.b,A=o(u,n),x[L+Z]=A.a,x[l+Z]=A.b,A=o(v,X),x[t+Z]=A.a,x[z+Z]=A.b}}if(l&Q){const l=L+C;let t;t=P?s(x[L+Z],x[l+Z]):o(x[L+Z],x[l+Z]),u=t.a,x[l+Z]=t.b,x[L+Z]=u}}if(L&Q){let L=V;const z=V+t*(l-j);for(;L<=z;L+=I){const l=L+a;let t;t=P?s(x[L+Z],x[l+Z]):o(x[L+Z],x[l+Z]),u=t.a,x[l+Z]=t.b,x[L+Z]=u}}j=Q,Q>>=1}return V}function M(x){return new DataView(x.array.buffer,x.offset.value,x.size)}function O(x){const Z=x.viewer.buffer.slice(x.offset.value,x.offset.value+x.size),l=new Uint8Array(function(x){let Z=x.byteLength;const l=new Array;let t=0;const L=new DataView(x);for(;Z>0;){const x=L.getInt8(t++);if(x<0){const z=-x;Z-=z+1;for(let x=0;x<z;x++)l.push(L.getUint8(t++))}else{const z=x;Z-=2;const A=L.getUint8(t++);for(let x=0;x<z+1;x++)l.push(A)}}return l}(Z)),t=new Uint8Array(l.length);return H(l),R(l,t),new DataView(t.buffer)}function E(x){const Z=x.array.slice(x.offset.value,x.offset.value+x.size),l=fflate.unzlibSync(Z),t=new Uint8Array(l.length);return H(l),R(l,t),new DataView(t.buffer)}function D(x){const Z=x.array.slice(x.offset.value,x.offset.value+x.size),l=fflate.unzlibSync(Z),t=x.lines*x.channels*x.width,L=1==x.type?new Uint16Array(t):new Uint32Array(t);let z=0,A=0;const P=new Array(4);for(let C=0;C<x.lines;C++)for(let Z=0;Z<x.channels;Z++){let Z=0;switch(x.type){case 1:P[0]=z,P[1]=P[0]+x.width,z=P[1]+x.width;for(let t=0;t<x.width;++t){Z+=l[P[0]++]<<8|l[P[1]++],L[A]=Z,A++}break;case 2:P[0]=z,P[1]=P[0]+x.width,P[2]=P[1]+x.width,z=P[2]+x.width;for(let t=0;t<x.width;++t){Z+=l[P[0]++]<<24|l[P[1]++]<<16|l[P[2]++]<<8,L[A]=Z,A++}}}return new DataView(L.buffer)}function e(x){const Z=x.viewer,l={value:x.offset.value},t=new Uint16Array(x.width*x.scanlineBlockSize*(x.channels*x.type)),L=new Uint8Array(8192);let A=0;const P=new Array(x.channels);for(let z=0;z<x.channels;z++)P[z]={},P[z].start=A,P[z].end=P[z].start,P[z].nx=x.width,P[z].ny=x.lines,P[z].size=x.type,A+=P[z].nx*P[z].ny*P[z].size;const C=n(Z,l),j=n(Z,l);if(j>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(C<=j)for(let z=0;z<j-C+1;z++)L[z+C]=u(Z,l);const V=new Uint16Array(z),Q=function(x,Z){let l=0;for(let L=0;L<z;++L)(0==L||x[L>>3]&1<<(7&L))&&(Z[l++]=L);const t=l-1;for(;l<z;)Z[l++]=0;return t}(L,V),c=I(Z,l);B(x.array,Z,l,c,t,A);for(let z=0;z<x.channels;++z){const x=P[z];for(let Z=0;Z<P[z].size;++Z)r(t,x.start+Z,x.nx,x.size,x.ny,x.nx*x.size,Q)}!function(x,Z,l){for(let t=0;t<l;++t)Z[t]=x[Z[t]]}(V,t,A);let a=0;const v=new Uint8Array(t.buffer.byteLength);for(let z=0;z<x.lines;z++)for(let Z=0;Z<x.channels;Z++){const x=P[Z],l=x.nx*x.size,L=new Uint8Array(t.buffer,2*x.end,2*l);v.set(L,a),a+=2*l,x.end+=l}return new DataView(v.buffer)}var i,g=l(1274);!function(x){x[x.Float=0]="Float",x[x.HalfFloat=1]="HalfFloat"}(i||(i={}));class F{}F.DefaultOutputType=i.HalfFloat,F.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class K{constructor(){this.supportCascades=!1}loadCubeData(x,Z,l,t,L){throw".exr not supported in Cube."}async loadData(x,Z,l){const L=new DataView(x.buffer),z={value:0},A=function(x,Z){if(20000630!=x.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const l=x.getUint8(4),L=x.getUint8(5),z={singleTile:!!(2&L),longName:!!(4&L),deepFormat:!!(8&L),multiPart:!!(16&L)};Z.value=8;const A={};let P=!0;for(;P;){const l=c(x.buffer,Z);if(l){const L=c(x.buffer,Z),z=T(x,Z,L,I(x,Z));void 0===z?t.b.Warn(`Unknown header attribute type ${L}'.`):A[l]=z}else P=!1}if(0!=(-5&L))throw new Error("Unsupported file format");return{version:l,spec:z,...A}}(L,z),P=await async function(x,Z,l,t){const L={size:0,viewer:Z,array:new Uint8Array(Z.buffer),offset:l,width:x.dataWindow.xMax-x.dataWindow.xMin+1,height:x.dataWindow.yMax-x.dataWindow.yMin+1,channels:x.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(x.compression){case j.NO_COMPRESSION:L.lines=1,L.uncompress=M;break;case j.RLE_COMPRESSION:L.lines=1,L.uncompress=O;break;case j.ZIPS_COMPRESSION:L.lines=1,L.uncompress=E,await g.f.LoadScriptAsync(F.FFLATEUrl);break;case j.ZIP_COMPRESSION:L.lines=16,L.uncompress=E,await g.f.LoadScriptAsync(F.FFLATEUrl);break;case j.PIZ_COMPRESSION:L.lines=32,L.uncompress=e;break;case j.PXR24_COMPRESSION:L.lines=16,L.uncompress=D,await g.f.LoadScriptAsync(F.FFLATEUrl);break;default:throw new Error(j[x.compression]+" is unsupported")}L.scanlineBlockSize=L.lines;const z={};for(const j of x.channels)switch(j.name){case"Y":case"R":case"G":case"B":case"A":z[j.name]=!0,L.type=j.pixelType}let A=!1;if(z.R&&z.G&&z.B)A=!z.A,L.outputChannels=4,L.decodeChannels={R:0,G:1,B:2,A:3};else{if(!z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");L.outputChannels=1,L.decodeChannels={Y:0}}if(1===L.type)switch(t){case i.Float:L.getter=f,L.inputSize=2;break;case i.HalfFloat:L.getter=n,L.inputSize=2}else{if(2!==L.type)throw new Error("Unsupported pixelType "+L.type+" for "+x.compression);switch(t){case i.Float:L.getter=W,L.inputSize=4;break;case i.HalfFloat:L.getter=S,L.inputSize=4}}L.blockCount=L.height/L.scanlineBlockSize;for(let j=0;j<L.blockCount;j++)X(Z,l);const P=L.width*L.height*L.outputChannels;switch(t){case i.Float:L.byteArray=new Float32Array(P),L.textureType=1,A&&L.byteArray.fill(1,0,P);break;case i.HalfFloat:L.byteArray=new Uint16Array(P),L.textureType=2,A&&L.byteArray.fill(15360,0,P);break;default:throw new Error("Unsupported type: "+t)}let C=0;for(const j of x.channels)void 0!==L.decodeChannels[j.name]&&(L.channelLineOffsets[j.name]=C*L.width),C+=2*j.pixelType;return L.bytesPerLine=L.width*C,L.outLineWidth=L.width*L.outputChannels,"INCREASING_Y"===x.lineOrder?L.scanOrder=x=>x:L.scanOrder=x=>L.height-1-x,4==L.outputChannels?(L.format=5,L.linearSpace=!0):(L.format=6,L.linearSpace=!1),L}(A,L,z,F.DefaultOutputType);!function(x,Z,l,t){const L={value:0};for(let z=0;z<x.height/x.scanlineBlockSize;z++){const A=a(l,t)-Z.dataWindow.yMin;x.size=I(l,t),x.lines=A+x.scanlineBlockSize>x.height?x.height-A:x.scanlineBlockSize;const P=x.size<x.lines*x.bytesPerLine&&x.uncompress?x.uncompress(x):M(x);t.value+=x.size;for(let l=0;l<x.scanlineBlockSize;l++){const t=z*x.scanlineBlockSize,A=l+x.scanOrder(t);if(A>=x.height)continue;const C=l*x.bytesPerLine,j=(x.height-1-A)*x.outLineWidth;for(let l=0;l<x.channels;l++){const t=Z.channels[l].name,z=x.channelLineOffsets[t],A=x.decodeChannels[t];if(void 0!==A){L.value=C+z;for(let Z=0;Z<x.width;Z++){const l=j+Z*x.outputChannels+A;x.byteArray&&(x.byteArray[l]=x.getter(P,L))}}}}}}(P,A,L,z);l(A.dataWindow.xMax-A.dataWindow.xMin+1,A.dataWindow.yMax-A.dataWindow.yMin+1,Z.generateMipMaps,!1,(()=>{const x=Z.getEngine();Z.format=A.format,Z.type=P.textureType,Z.invertY=!1,Z._gammaSpace=!A.linearSpace,P.byteArray&&x._uploadDataToTextureDirectly(Z,P.byteArray,0,0,void 0,!0)}))}}}}]);