"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12723:(a,R,Y)=>{Y.r(R),Y.d(R,{_DDSTextureLoader:()=>K});var T=Y(11577),c=Y(11590);class K{constructor(){this.supportCascades=!0}loadCubeData(a,R,Y,K){const g=R.getEngine();let t,U=!1,b=1e3;if(Array.isArray(a))for(let T=0;T<a.length;T++){const Y=a[T];t=c.b.GetDDSInfo(Y),R.width=t.width,R.height=t.height,U=(t.isRGB||t.isLuminance||t.mipmapCount>1)&&R.generateMipMaps,g._unpackFlipY(t.isCompressed),c.b.UploadDDSLevels(g,R,Y,t,U,6,-1,T),t.isFourCC||1!==t.mipmapCount?b=t.mipmapCount-1:g.generateMipMapsForCubemap(R)}else{const K=a;t=c.b.GetDDSInfo(K),R.width=t.width,R.height=t.height,Y&&(t.sphericalPolynomial=new T.e),U=(t.isRGB||t.isLuminance||t.mipmapCount>1)&&R.generateMipMaps,g._unpackFlipY(t.isCompressed),c.b.UploadDDSLevels(g,R,K,t,U,6),t.isFourCC||1!==t.mipmapCount?b=t.mipmapCount-1:g.generateMipMapsForCubemap(R,!1)}g._setCubeMapTextureParams(R,U,b),R.isReady=!0,R.onLoadedObservable.notifyObservers(R),R.onLoadedObservable.clear(),K&&K({isDDS:!0,width:R.width,info:t,data:a,texture:R})}loadData(a,R,Y){const T=c.b.GetDDSInfo(a),K=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&R.generateMipMaps&&Math.max(T.width,T.height)>>T.mipmapCount-1===1;Y(T.width,T.height,K,T.isFourCC,(()=>{c.b.UploadDDSLevels(R.getEngine(),R,a,T,K,1)}))}}}}]);