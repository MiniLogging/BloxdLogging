"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12756:(d,t,A)=>{A.r(t),A.d(t,{_DDSTextureLoader:()=>p});var w=A(11541),N=A(11560);class p{constructor(){this.supportCascades=!0}loadCubeData(d,t,A,p){const B=t.getEngine();let X,W=!1,a=1e3;if(Array.isArray(d))for(let w=0;w<d.length;w++){const A=d[w];X=N.d.GetDDSInfo(A),t.width=X.width,t.height=X.height,W=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&t.generateMipMaps,B._unpackFlipY(X.isCompressed),N.d.UploadDDSLevels(B,t,A,X,W,6,-1,w),X.isFourCC||1!==X.mipmapCount?a=X.mipmapCount-1:B.generateMipMapsForCubemap(t)}else{const p=d;X=N.d.GetDDSInfo(p),t.width=X.width,t.height=X.height,A&&(X.sphericalPolynomial=new w.f),W=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&t.generateMipMaps,B._unpackFlipY(X.isCompressed),N.d.UploadDDSLevels(B,t,p,X,W,6),X.isFourCC||1!==X.mipmapCount?a=X.mipmapCount-1:B.generateMipMapsForCubemap(t,!1)}B._setCubeMapTextureParams(t,W,a),t.isReady=!0,t.onLoadedObservable.notifyObservers(t),t.onLoadedObservable.clear(),p&&p({isDDS:!0,width:t.width,info:X,data:d,texture:t})}loadData(d,t,A){const w=N.d.GetDDSInfo(d),p=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&t.generateMipMaps&&Math.max(w.width,w.height)>>w.mipmapCount-1===1;A(w.width,w.height,p,w.isFourCC,(()=>{N.d.UploadDDSLevels(t.getEngine(),t,d,w,p,1)}))}}}}]);