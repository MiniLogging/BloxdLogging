"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12730:(R,q,L)=>{L.r(q),L.d(q,{_DDSTextureLoader:()=>h});var B=L(11562),N=L(11587);class h{constructor(){this.supportCascades=!0}loadCubeData(R,q,L,h){const Z=q.getEngine();let z,Y=!1,F=1e3;if(Array.isArray(R))for(let B=0;B<R.length;B++){const L=R[B];z=N.b.GetDDSInfo(L),q.width=z.width,q.height=z.height,Y=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&q.generateMipMaps,Z._unpackFlipY(z.isCompressed),N.b.UploadDDSLevels(Z,q,L,z,Y,6,-1,B),z.isFourCC||1!==z.mipmapCount?F=z.mipmapCount-1:Z.generateMipMapsForCubemap(q)}else{const h=R;z=N.b.GetDDSInfo(h),q.width=z.width,q.height=z.height,L&&(z.sphericalPolynomial=new B.d),Y=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&q.generateMipMaps,Z._unpackFlipY(z.isCompressed),N.b.UploadDDSLevels(Z,q,h,z,Y,6),z.isFourCC||1!==z.mipmapCount?F=z.mipmapCount-1:Z.generateMipMapsForCubemap(q,!1)}Z._setCubeMapTextureParams(q,Y,F),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),h&&h({isDDS:!0,width:q.width,info:z,data:R,texture:q})}loadData(R,q,L){const B=N.b.GetDDSInfo(R),h=(B.isRGB||B.isLuminance||B.mipmapCount>1)&&q.generateMipMaps&&Math.max(B.width,B.height)>>B.mipmapCount-1===1;L(B.width,B.height,h,B.isFourCC,(()=>{N.b.UploadDDSLevels(q.getEngine(),q,R,B,h,1)}))}}}}]);