"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2563:(W,F,c)=>{c.r(F),c.d(F,{_HDRTextureLoader:()=>x});var T=c(694);class Y{static ConvertPanoramaToCubemap(W,F,c,T){let Y=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!W)throw"ConvertPanoramaToCubemap: input cannot be null";if(W.length!=F*c*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(T,this.FACE_FRONT,W,F,c,Y),back:this.CreateCubemapTexture(T,this.FACE_BACK,W,F,c,Y),left:this.CreateCubemapTexture(T,this.FACE_LEFT,W,F,c,Y),right:this.CreateCubemapTexture(T,this.FACE_RIGHT,W,F,c,Y),up:this.CreateCubemapTexture(T,this.FACE_UP,W,F,c,Y),down:this.CreateCubemapTexture(T,this.FACE_DOWN,W,F,c,Y),size:T,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(W,F,c,T,Y){let Z=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const w=new ArrayBuffer(W*W*4*3),A=new Float32Array(w),u=Z?Math.max(1,Math.round(T/4/W)):1,s=1/u,x=s*s,j=F[1].Bg(F[0]).scale(s/W),N=F[3].Bg(F[2]).scale(s/W),q=1/W;let y=0;for(let i=0;i<W;i++)for(let Z=0;Z<u;Z++){let Z=F[0],w=F[2];for(let F=0;F<W;F++)for(let s=0;s<u;s++){const u=w.Bg(Z).scale(y).add(Z);u.normalize();const s=this.CalcProjectionSpherical(u,c,T,Y);A[i*W*3+3*F+0]+=s.r*x,A[i*W*3+3*F+1]+=s.g*x,A[i*W*3+3*F+2]+=s.b*x,Z=Z.add(j),w=w.add(N)}y+=q*s}return A}static CalcProjectionSpherical(W,F,c,T){let Y=Math.atan2(W.z,W.x);const Z=Math.acos(W.y);for(;Y<-Math.PI;)Y+=2*Math.PI;for(;Y>Math.PI;)Y-=2*Math.PI;let w=Y/Math.PI;const A=Z/Math.PI;w=.5*w+.5;let u=Math.round(w*c);u<0?u=0:u>=c&&(u=c-1);let s=Math.round(A*T);s<0?s=0:s>=T&&(s=T-1);const x=T-s-1;return{r:F[x*c*3+3*u+0],g:F[x*c*3+3*u+1],b:F[x*c*3+3*u+2]}}}function Z(W,F,c,T,Y,Z){Y>0?(Y=function(W,F){return F>1023?W*Math.pow(2,1023)*Math.pow(2,F-1023):F<-1074?W*Math.pow(2,-1074)*Math.pow(2,F+1074):W*Math.pow(2,F)}(1,Y-136),W[Z+0]=F*Y,W[Z+1]=c*Y,W[Z+2]=T*Y):(W[Z+0]=0,W[Z+1]=0,W[Z+2]=0)}function w(W,F){let c="",T="";for(let Y=F;Y<W.length-F&&(T=String.fromCharCode(W[Y]),"\n"!=T);Y++)c+=T;return c}function A(W){let F=0,c=0,T=w(W,0);if("#"!=T[0]||"?"!=T[1])throw"Bad HDR Format.";let Y=!1,Z=!1,A=0;do{A+=T.length+1,T=w(W,A),"FORMAT=32-bit_rle_rgbe"==T?Z=!0:0==T.length&&(Y=!0)}while(!Y);if(!Z)throw"HDR Bad header format, unsupported FORMAT";A+=T.length+1,T=w(W,A);const u=/^-Y (.*) \+X (.*)$/g.exec(T);if(!u||u.length<3)throw"HDR Bad header format, no size";if(c=parseInt(u[2]),F=parseInt(u[1]),c<8||c>32767)throw"HDR Bad header format, unsupported size";return A+=T.length+1,{height:F,width:c,dataPosition:A}}function u(W,F){return function(W,F){let c=F.height;const T=F.width;let Y,w,A,u,x,j=F.dataPosition,N=0,q=0,y=0;const i=new ArrayBuffer(4*T),e=new Uint8Array(i),I=new ArrayBuffer(F.width*F.height*4*3),E=new Float32Array(I);for(;c>0;){if(Y=W[j++],w=W[j++],A=W[j++],u=W[j++],2!=Y||2!=w||128&A||F.width<8||F.width>32767)return s(W,F);if((A<<8|u)!=T)throw"HDR Bad header format, wrong scan line width";for(N=0,y=0;y<4;y++)for(q=(y+1)*T;N<q;)if(Y=W[j++],w=W[j++],Y>128){if(x=Y-128,0==x||x>q-N)throw"HDR Bad Format, bad scanline data (run)";for(;x-- >0;)e[N++]=w}else{if(x=Y,0==x||x>q-N)throw"HDR Bad Format, bad scanline data (non-run)";if(e[N++]=w,--x>0)for(let F=0;F<x;F++)e[N++]=W[j++]}for(y=0;y<T;y++)Y=e[y],w=e[y+T],A=e[y+2*T],u=e[y+3*T],Z(E,Y,w,A,u,(F.height-c)*T*3+3*y);c--}return E}(W,F)}function s(W,F){let c=F.height;const T=F.width;let Y,w,A,u,s,x=F.dataPosition;const j=new ArrayBuffer(F.width*F.height*4*3),N=new Float32Array(j);for(;c>0;){for(s=0;s<F.width;s++)Y=W[x++],w=W[x++],A=W[x++],u=W[x++],Z(N,Y,w,A,u,(F.height-c)*T*3+3*s);c--}return N}Y.FACE_LEFT=[new T.l(-1,-1,-1),new T.l(1,-1,-1),new T.l(-1,1,-1),new T.l(1,1,-1)],Y.FACE_RIGHT=[new T.l(1,-1,1),new T.l(-1,-1,1),new T.l(1,1,1),new T.l(-1,1,1)],Y.FACE_FRONT=[new T.l(1,-1,-1),new T.l(1,-1,1),new T.l(1,1,-1),new T.l(1,1,1)],Y.FACE_BACK=[new T.l(-1,-1,1),new T.l(-1,-1,-1),new T.l(-1,1,1),new T.l(-1,1,-1)],Y.FACE_DOWN=[new T.l(1,1,-1),new T.l(1,1,1),new T.l(-1,1,-1),new T.l(-1,1,1)],Y.FACE_UP=[new T.l(-1,-1,-1),new T.l(-1,-1,1),new T.l(1,-1,-1),new T.l(1,-1,1)];class x{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(W,F,c){const T=new Uint8Array(W.buffer,W.byteOffset,W.byteLength),Y=A(T),Z=u(T,Y),w=Y.width*Y.height,s=new Float32Array(4*w);for(let A=0;A<w;A+=1)s[4*A]=Z[3*A],s[4*A+1]=Z[3*A+1],s[4*A+2]=Z[3*A+2],s[4*A+3]=1;c(Y.width,Y.height,F.generateMipMaps,!1,(()=>{const W=F.getEngine();F.type=1,F.format=5,F._gammaSpace=!1,W._uploadDataToTextureDirectly(F,s)}))}}}}]);