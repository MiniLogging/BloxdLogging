"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12763:(Z,J,E)=>{E.r(J),E.d(J,{_DDSTextureLoader:()=>Y});var O=E(11661),i=E(11677);class Y{constructor(){this.supportCascades=!0}loadCubeData(Z,J,E,Y){const C=J.getEngine();let d,z=!1,g=1e3;if(Array.isArray(Z))for(let O=0;O<Z.length;O++){const E=Z[O];d=i.b.GetDDSInfo(E),J.width=d.width,J.height=d.height,z=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&J.generateMipMaps,C._unpackFlipY(d.isCompressed),i.b.UploadDDSLevels(C,J,E,d,z,6,-1,O),d.isFourCC||1!==d.mipmapCount?g=d.mipmapCount-1:C.generateMipMapsForCubemap(J)}else{const Y=Z;d=i.b.GetDDSInfo(Y),J.width=d.width,J.height=d.height,E&&(d.sphericalPolynomial=new O.g),z=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&J.generateMipMaps,C._unpackFlipY(d.isCompressed),i.b.UploadDDSLevels(C,J,Y,d,z,6),d.isFourCC||1!==d.mipmapCount?g=d.mipmapCount-1:C.generateMipMapsForCubemap(J,!1)}C._setCubeMapTextureParams(J,z,g),J.isReady=!0,J.onLoadedObservable.notifyObservers(J),J.onLoadedObservable.clear(),Y&&Y({isDDS:!0,width:J.width,info:d,data:Z,texture:J})}loadData(Z,J,E){const O=i.b.GetDDSInfo(Z),Y=(O.isRGB||O.isLuminance||O.mipmapCount>1)&&J.generateMipMaps&&Math.max(O.width,O.height)>>O.mipmapCount-1===1;E(O.width,O.height,Y,O.isFourCC,(()=>{i.b.UploadDDSLevels(J.getEngine(),J,Z,O,Y,1)}))}}}}]);