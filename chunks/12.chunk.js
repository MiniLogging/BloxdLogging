"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10274:(B,q,C)=>{C.r(q),C.d(q,{_ExrTextureLoader:()=>E});var v=C(1040),m=C(981);const O=65536,S=14,D=65537,R=16384;var T,l;!function(B){B[B.NO_COMPRESSION=0]="NO_COMPRESSION",B[B.RLE_COMPRESSION=1]="RLE_COMPRESSION",B[B.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",B[B.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",B[B.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",B[B.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(B){B[B.INCREASING_Y=0]="INCREASING_Y",B[B.DECREASING_Y=1]="DECREASING_Y"}(l||(l={}));const z=function(){const B=new ArrayBuffer(4),q=new Float32Array(B),C=new Uint32Array(B),v=new Uint32Array(512),m=new Uint32Array(512);for(let R=0;R<256;++R){const B=R-127;B<-27?(v[R]=0,v[256|R]=32768,m[R]=24,m[256|R]=24):B<-14?(v[R]=1024>>-B-14,v[256|R]=1024>>-B-14|32768,m[R]=-B-1,m[256|R]=-B-1):B<=15?(v[R]=B+15<<10,v[256|R]=B+15<<10|32768,m[R]=13,m[256|R]=13):B<128?(v[R]=31744,v[256|R]=64512,m[R]=24,m[256|R]=24):(v[R]=31744,v[256|R]=64512,m[R]=13,m[256|R]=13)}const O=new Uint32Array(2048),S=new Uint32Array(64),D=new Uint32Array(64);for(let R=1;R<1024;++R){let B=R<<13,q=0;for(;0===(8388608&B);)B<<=1,q-=8388608;B&=-8388609,q+=947912704,O[R]=B|q}for(let R=1024;R<2048;++R)O[R]=939524096+(R-1024<<13);for(let R=1;R<31;++R)S[R]=R<<23;S[31]=1199570944,S[32]=2147483648;for(let R=33;R<63;++R)S[R]=2147483648+(R-32<<23);S[63]=3347054592;for(let R=1;R<64;++R)32!==R&&(D[R]=1024);return{floatView:q,uint32View:C,baseTable:v,shiftTable:m,mantissaTable:O,exponentTable:S,offsetTable:D}}();function W(B,q){const C=new Uint8Array(B);let v=0;for(;0!=C[q.value+v];)v+=1;const m=(new TextDecoder).decode(C.slice(q.value,q.value+v));return q.value=q.value+v+1,m}function Z(B,q){const C=B.getInt32(q.value,!0);return q.value+=4,C}function G(B,q){const C=B.getUint32(q.value,!0);return q.value+=4,C}function y(B,q){const C=B.getUint8(q.value);return q.value+=1,C}function e(B,q){const C=B.getUint16(q.value,!0);return q.value+=2,C}function U(B,q){const C=B[q.value];return q.value+=1,C}function s(B,q){let C;return C="getBigInt64"in DataView.prototype?Number(B.getBigInt64(q.value,!0)):B.getUint32(q.value+4,!0)+Number(B.getUint32(q.value,!0)<<32),q.value+=8,C}function A(B,q){const C=B.getFloat32(q.value,!0);return q.value+=4,C}function r(B,q){return function(B){const q=(31744&B)>>10,C=1023&B;return(B>>15?-1:1)*(q?31===q?C?NaN:1/0:Math.pow(2,q-15)*(1+C/1024):C/1024*6103515625e-14)}(e(B,q))}function X(B,q){return function(B){if(Math.abs(B)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");B=(0,m.c)(B,-65504,65504),z.floatView[0]=B;const q=z.uint32View[0],C=q>>23&511;return z.baseTable[C]+((8388607&q)>>z.shiftTable[C])}(A(B,q))}function V(B,q,C,v){switch(C){case"string":case"stringvector":case"iccProfile":return function(B,q,C){const v=(new TextDecoder).decode(new Uint8Array(B).slice(q.value,q.value+C));return q.value=q.value+C,v}(B.buffer,q,v);case"chlist":return function(B,q,C){const v=q.value,m=[];for(;q.value<v+C-1;){const C=W(B.buffer,q),v=Z(B,q),O=y(B,q);q.value+=3;const S=Z(B,q),D=Z(B,q);m.push({name:C,pixelType:v,pLinear:O,xSampling:S,ySampling:D})}return q.value+=1,m}(B,q,v);case"chromaticities":return function(B,q){return{redX:A(B,q),redY:A(B,q),greenX:A(B,q),greenY:A(B,q),blueX:A(B,q),blueY:A(B,q),whiteX:A(B,q),whiteY:A(B,q)}}(B,q);case"compression":return function(B,q){return y(B,q)}(B,q);case"box2i":return function(B,q){return{xMin:Z(B,q),yMin:Z(B,q),xMax:Z(B,q),yMax:Z(B,q)}}(B,q);case"lineOrder":return function(B,q){const C=y(B,q);return l[C]}(B,q);case"float":return A(B,q);case"v2f":return function(B,q){return[A(B,q),A(B,q)]}(B,q);case"v3f":return function(B,q){return[A(B,q),A(B,q),A(B,q)]}(B,q);case"int":return Z(B,q);case"rational":return function(B,q){return[Z(B,q),G(B,q)]}(B,q);case"timecode":return function(B,q){return[G(B,q),G(B,q)]}(B,q);case"preview":return q.value+=v,"skipped";default:return void(q.value+=v)}}function I(B){for(let q=1;q<B.length;q++){const C=B[q-1]+B[q]-128;B[q]=C}}function o(B,q){let C=0,v=Math.floor((B.length+1)/2),m=0;const O=B.length-1;for(;!(m>O)&&(q[m++]=B[C++],!(m>O));)q[m++]=B[v++]}function Q(B,q,C,v,m){for(;C<B;)q=q<<8|U(v,m),C+=8;return{l:q>>(C-=B)&(1<<B)-1,c:q,lc:C}}function a(B,q,C,v){return{c:B=B<<8|U(C,v),lc:q+=8}}function i(B,q,C,v,m,O,S,D,R){if(B==q){if(v<8){const B=a(C,v,m,O);C=B.c,v=B.lc}let B=C>>(v-=8);if(B=new Uint8Array([B])[0],D.value+B>R)return null;const q=S[D.value-1];for(;B-- >0;)S[D.value++]=q}else{if(!(D.value<R))return null;S[D.value++]=B}return{c:C,lc:v}}const u=new Array(59);function k(B,q,C,v,m,O){const S=q;let R=0,T=0;for(;v<=m;v++){if(S.value-q.value>C)return;let D=Q(6,R,T,B,S);const l=D.l;if(R=D.c,T=D.lc,O[v]=l,63==l){if(S.value-q.value>C)throw new Error("Error in HufUnpackEncTable");D=Q(8,R,T,B,S);let l=D.l+6;if(R=D.c,T=D.lc,v+l>m+1)throw new Error("Error in HufUnpackEncTable");for(;l--;)O[v++]=0;v--}else if(l>=59){let B=l-59+2;if(v+B>m+1)throw new Error("Error in HufUnpackEncTable");for(;B--;)O[v++]=0;v--}}!function(B){for(let C=0;C<=58;++C)u[C]=0;for(let C=0;C<D;++C)u[B[C]]+=1;let q=0;for(let C=58;C>0;--C){const B=q+u[C]>>1;u[C]=q,q=B}for(let C=0;C<D;++C){const q=B[C];q>0&&(B[C]=q|u[q]++<<6)}}(O)}function h(B){return 63&B}function K(B){return B>>6}function d(B,q,C,v,m,O){const T=C.value,l=G(q,C),z=G(q,C);C.value+=4;const W=G(q,C);if(C.value+=4,l<0||l>=D||z<0||z>=D)throw new Error("Wrong HUF_ENCSIZE");const Z=new Array(D),y=new Array(R);!function(B){for(let q=0;q<R;q++)B[q]={},B[q].len=0,B[q].lit=0,B[q].p=null}(y);if(k(B,C,v-(C.value-T),l,z,Z),W>8*(v-(C.value-T)))throw new Error("Wrong hufUncompress");!function(B,q,C,v){for(;q<=C;q++){const C=K(B[q]),m=h(B[q]);if(C>>m)throw new Error("Invalid table entry");if(m>S){const B=v[C>>m-S];if(B.len)throw new Error("Invalid table entry");if(B.lit++,B.p){const q=B.p;B.p=new Array(B.lit);for(let C=0;C<B.lit-1;++C)B.p[C]=q[C]}else B.p=new Array(1);B.p[B.lit-1]=q}else if(m){let B=0;for(let O=1<<S-m;O>0;O--){const O=v[(C<<S-m)+B];if(O.len||O.p)throw new Error("Invalid table entry");O.len=m,O.lit=q,B++}}}}(Z,l,z,y),function(B,q,C,v,m,O,D,R,T){let l=0,z=0;const W=D,Z=Math.trunc(v.value+(m+7)/8);for(;v.value<Z;){let m=a(l,z,C,v);for(l=m.c,z=m.lc;z>=S;){const D=q[l>>z-S&16383];if(D.len){z-=D.len;const B=i(D.lit,O,l,z,C,v,R,T,W);B&&(l=B.c,z=B.lc)}else{if(!D.p)throw new Error("hufDecode issues");let q;for(q=0;q<D.lit;q++){const S=h(B[D.p[q]]);for(;z<S&&v.value<Z;)m=a(l,z,C,v),l=m.c,z=m.lc;if(z>=S&&K(B[D.p[q]])==(l>>z-S&(1<<S)-1)){z-=S;const B=i(D.p[q],O,l,z,C,v,R,T,W);B&&(l=B.c,z=B.lc);break}}if(q==D.lit)throw new Error("HufDecode issues")}}}const G=8-m&7;for(l>>=G,z-=G;z>0;){const B=q[l<<S-z&16383];if(!B.len)throw new Error("HufDecode issues");{z-=B.len;const q=i(B.lit,O,l,z,C,v,R,T,W);q&&(l=q.c,z=q.lc)}}}(Z,y,B,C,W,z,O,m,{value:0})}function g(B){return 65535&B}function x(B){const q=g(B);return q>32767?q-65536:q}function j(B,q){const C=x(B),v=x(q),m=C+(1&v)+(v>>1);return{a:m,b:m-v}}function Y(B,q){const C=g(B),v=g(q),m=C-(v>>1)&65535;return{a:v+m-32768&65535,b:m}}function J(B,q,C,v,m,O,S){const D=S<16384,R=C>m?m:C;let T,l,z=1;for(;z<=R;)z<<=1;for(z>>=1,T=z,z>>=1;z>=1;){l=0;const S=l+O*(m-T),R=O*z,W=O*T,Z=v*z,G=v*T;let y,e,U,s;for(;l<=S;l+=W){let m=l;const O=l+v*(C-T);for(;m<=O;m+=G){const C=m+Z,v=m+R,O=v+Z;if(D){let S=j(B[m+q],B[v+q]);y=S.a,U=S.b,S=j(B[C+q],B[O+q]),e=S.a,s=S.b,S=j(y,e),B[m+q]=S.a,B[C+q]=S.b,S=j(U,s),B[v+q]=S.a,B[O+q]=S.b}else{let S=Y(B[m+q],B[v+q]);y=S.a,U=S.b,S=Y(B[C+q],B[O+q]),e=S.a,s=S.b,S=Y(y,e),B[m+q]=S.a,B[C+q]=S.b,S=Y(U,s),B[v+q]=S.a,B[O+q]=S.b}}if(C&z){const C=m+R;let v;v=D?j(B[m+q],B[C+q]):Y(B[m+q],B[C+q]),y=v.a,B[C+q]=v.b,B[m+q]=y}}if(m&z){let m=l;const O=l+v*(C-T);for(;m<=O;m+=G){const C=m+Z;let v;v=D?j(B[m+q],B[C+q]):Y(B[m+q],B[C+q]),y=v.a,B[C+q]=v.b,B[m+q]=y}}T=z,z>>=1}return l}function P(B){return new DataView(B.array.buffer,B.offset.value,B.size)}function p(B){const q=B.viewer.buffer.slice(B.offset.value,B.offset.value+B.size),C=new Uint8Array(function(B){let q=B.byteLength;const C=new Array;let v=0;const m=new DataView(B);for(;q>0;){const B=m.getInt8(v++);if(B<0){const O=-B;q-=O+1;for(let B=0;B<O;B++)C.push(m.getUint8(v++))}else{const O=B;q-=2;const S=m.getUint8(v++);for(let B=0;B<O+1;B++)C.push(S)}}return C}(q)),v=new Uint8Array(C.length);return I(C),o(C,v),new DataView(v.buffer)}function w(B){const q=B.array.slice(B.offset.value,B.offset.value+B.size),C=fflate.unzlibSync(q),v=new Uint8Array(C.length);return I(C),o(C,v),new DataView(v.buffer)}function t(B){const q=B.array.slice(B.offset.value,B.offset.value+B.size),C=fflate.unzlibSync(q),v=B.lines*B.channels*B.width,m=1==B.type?new Uint16Array(v):new Uint32Array(v);let O=0,S=0;const D=new Array(4);for(let R=0;R<B.lines;R++)for(let q=0;q<B.channels;q++){let q=0;switch(B.type){case 1:D[0]=O,D[1]=D[0]+B.width,O=D[1]+B.width;for(let v=0;v<B.width;++v){q+=C[D[0]++]<<8|C[D[1]++],m[S]=q,S++}break;case 2:D[0]=O,D[1]=D[0]+B.width,D[2]=D[1]+B.width,O=D[2]+B.width;for(let v=0;v<B.width;++v){q+=C[D[0]++]<<24|C[D[1]++]<<16|C[D[2]++]<<8,m[S]=q,S++}}}return new DataView(m.buffer)}function c(B){const q=B.viewer,C={value:B.offset.value},v=new Uint16Array(B.width*B.scanlineBlockSize*(B.channels*B.type)),m=new Uint8Array(8192);let S=0;const D=new Array(B.channels);for(let O=0;O<B.channels;O++)D[O]={},D[O].start=S,D[O].end=D[O].start,D[O].nx=B.width,D[O].ny=B.lines,D[O].size=B.type,S+=D[O].nx*D[O].ny*D[O].size;const R=e(q,C),T=e(q,C);if(T>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(R<=T)for(let O=0;O<T-R+1;O++)m[O+R]=y(q,C);const l=new Uint16Array(O),z=function(B,q){let C=0;for(let m=0;m<O;++m)(0==m||B[m>>3]&1<<(7&m))&&(q[C++]=m);const v=C-1;for(;C<O;)q[C++]=0;return v}(m,l),W=G(q,C);d(B.array,q,C,W,v,S);for(let O=0;O<B.channels;++O){const B=D[O];for(let q=0;q<D[O].size;++q)J(v,B.start+q,B.nx,B.size,B.ny,B.nx*B.size,z)}!function(B,q,C){for(let v=0;v<C;++v)q[v]=B[q[v]]}(l,v,S);let Z=0;const U=new Uint8Array(v.buffer.byteLength);for(let O=0;O<B.lines;O++)for(let q=0;q<B.channels;q++){const B=D[q],C=B.nx*B.size,m=new Uint8Array(v.buffer,2*B.end,2*C);U.set(m,Z),Z+=2*C,B.end+=C}return new DataView(U.buffer)}var f,b=C(1161);!function(B){B[B.Float=0]="Float",B[B.HalfFloat=1]="HalfFloat"}(f||(f={}));class L{}L.DefaultOutputType=f.HalfFloat,L.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class E{constructor(){this.supportCascades=!1}loadCubeData(B,q,C,v,m){throw".exr not supported in Cube."}async loadData(B,q,C){const m=new DataView(B.buffer),O={value:0},S=function(B,q){if(20000630!=B.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const C=B.getUint8(4),m=B.getUint8(5),O={singleTile:!!(2&m),longName:!!(4&m),deepFormat:!!(8&m),multiPart:!!(16&m)};q.value=8;const S={};let D=!0;for(;D;){const C=W(B.buffer,q);if(C){const m=W(B.buffer,q),O=V(B,q,m,G(B,q));void 0===O?v.d.Warn(`Unknown header attribute type ${m}'.`):S[C]=O}else D=!1}if(0!=(-5&m))throw new Error("Unsupported file format");return{version:C,spec:O,...S}}(m,O),D=await async function(B,q,C,v){const m={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:C,width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,channels:B.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(B.compression){case T.NO_COMPRESSION:m.lines=1,m.uncompress=P;break;case T.RLE_COMPRESSION:m.lines=1,m.uncompress=p;break;case T.ZIPS_COMPRESSION:m.lines=1,m.uncompress=w,await b.f.LoadScriptAsync(L.FFLATEUrl);break;case T.ZIP_COMPRESSION:m.lines=16,m.uncompress=w,await b.f.LoadScriptAsync(L.FFLATEUrl);break;case T.PIZ_COMPRESSION:m.lines=32,m.uncompress=c;break;case T.PXR24_COMPRESSION:m.lines=16,m.uncompress=t,await b.f.LoadScriptAsync(L.FFLATEUrl);break;default:throw new Error(T[B.compression]+" is unsupported")}m.scanlineBlockSize=m.lines;const O={};for(const T of B.channels)switch(T.name){case"Y":case"R":case"G":case"B":case"A":O[T.name]=!0,m.type=T.pixelType}let S=!1;if(O.R&&O.G&&O.B)S=!O.A,m.outputChannels=4,m.decodeChannels={R:0,G:1,B:2,A:3};else{if(!O.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");m.outputChannels=1,m.decodeChannels={Y:0}}if(1===m.type)switch(v){case f.Float:m.getter=r,m.inputSize=2;break;case f.HalfFloat:m.getter=e,m.inputSize=2}else{if(2!==m.type)throw new Error("Unsupported pixelType "+m.type+" for "+B.compression);switch(v){case f.Float:m.getter=A,m.inputSize=4;break;case f.HalfFloat:m.getter=X,m.inputSize=4}}m.blockCount=m.height/m.scanlineBlockSize;for(let T=0;T<m.blockCount;T++)s(q,C);const D=m.width*m.height*m.outputChannels;switch(v){case f.Float:m.byteArray=new Float32Array(D),m.textureType=1,S&&m.byteArray.fill(1,0,D);break;case f.HalfFloat:m.byteArray=new Uint16Array(D),m.textureType=2,S&&m.byteArray.fill(15360,0,D);break;default:throw new Error("Unsupported type: "+v)}let R=0;for(const T of B.channels)void 0!==m.decodeChannels[T.name]&&(m.channelLineOffsets[T.name]=R*m.width),R+=2*T.pixelType;return m.bytesPerLine=m.width*R,m.outLineWidth=m.width*m.outputChannels,"INCREASING_Y"===B.lineOrder?m.scanOrder=B=>B:m.scanOrder=B=>m.height-1-B,4==m.outputChannels?(m.format=5,m.linearSpace=!0):(m.format=6,m.linearSpace=!1),m}(S,m,O,L.DefaultOutputType);!function(B,q,C,v){const m={value:0};for(let O=0;O<B.height/B.scanlineBlockSize;O++){const S=Z(C,v)-q.dataWindow.yMin;B.size=G(C,v),B.lines=S+B.scanlineBlockSize>B.height?B.height-S:B.scanlineBlockSize;const D=B.size<B.lines*B.bytesPerLine&&B.uncompress?B.uncompress(B):P(B);v.value+=B.size;for(let C=0;C<B.scanlineBlockSize;C++){const v=O*B.scanlineBlockSize,S=C+B.scanOrder(v);if(S>=B.height)continue;const R=C*B.bytesPerLine,T=(B.height-1-S)*B.outLineWidth;for(let C=0;C<B.channels;C++){const v=q.channels[C].name,O=B.channelLineOffsets[v],S=B.decodeChannels[v];if(void 0!==S){m.value=R+O;for(let q=0;q<B.width;q++){const C=T+q*B.outputChannels+S;B.byteArray&&(B.byteArray[C]=B.getter(D,m))}}}}}}(D,S,m,O);C(S.dataWindow.xMax-S.dataWindow.xMin+1,S.dataWindow.yMax-S.dataWindow.yMin+1,q.generateMipMaps,!1,(()=>{const B=q.getEngine();q.format=S.format,q.type=D.textureType,q.invertY=!1,q._gammaSpace=!S.linearSpace,D.byteArray&&B._uploadDataToTextureDirectly(q,D.byteArray,0,0,void 0,!0)}))}}}}]);