"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[12,20],{11550:(m,S,h)=>{h.r(S),h.d(S,{Dispose:()=>Z,DumpData:()=>I,DumpDataAsync:()=>V,DumpFramebuffer:()=>Y,DumpTools:()=>C});var l=h(11446),M=h(11156),O=h(11359),u=h(11196);let b,q=null;async function Y(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",O=arguments.length>5?arguments[5]:void 0,u=arguments.length>6?arguments[6]:void 0;const b=await h.readPixels(0,0,m,S);I(m,S,new Uint8Array(b.buffer),l,M,O,!0,void 0,u)}async function V(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",M=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],b=arguments.length>7?arguments[7]:void 0;return await new Promise((q=>{I(m,S,h,(m=>q(m)),l,M,O,u,b)}))}function I(m,S,Y,V){let I=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",C=arguments.length>5?arguments[5]:void 0,B=arguments.length>6&&void 0!==arguments[6]&&arguments[6],D=arguments.length>7&&void 0!==arguments[7]&&arguments[7],E=arguments.length>8?arguments[8]:void 0;(async function(){return q||(q=new Promise(((m,S)=>{let M,O=null;const q={o:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(h.bind(h,11463)).then((Y=>{let{ThinEngine:V}=Y;const I=u.d.Instances.length;try{M=new OffscreenCanvas(100,100),O=new V(M,!1,q)}catch(D){var C;I<u.d.Instances.length&&(null===(C=u.d.Instances.pop())||void 0===C||C.dispose()),M=document.createElement("canvas"),O=new V(M,!1,q)}u.d.Instances.pop(),u.d.OnEnginesDisposedObservable.add((m=>{O&&m!==O&&!O.u&&0===u.d.Instances.length&&Z()})),O.getCaps().parallelShaderCompile=void 0;const B=new l.b(O);h.e(52).then(h.bind(h,13867)).then((h=>{let{passPixelShader:u}=h;if(!O)return void S("Engine is not defined");const q=new l.d({ES:O,name:u.name,fragmentShader:u.shader,samplerNames:["textureSampler"]});b={canvas:M,ES:O,renderer:B,wrapper:q},m(b)}))})).catch(S)}))),await q})().then((h=>{if(h.ES.setSize(m,S,!0),Y instanceof Float32Array){const m=new Uint8Array(Y.length);let S=Y.length;for(;S--;){const h=Y[S];m[S]=Math.round(255*(0,O.Clamp)(h))}Y=m}const l=h.ES.createRawTexture(Y,m,S,5,!1,!B,1);h.renderer.setViewport(),h.renderer.applyEffectWrapper(h.wrapper),h.wrapper.effect._bindTexture("textureSampler",l),h.renderer.draw(),D?M.Tools.ToBlob(h.canvas,(m=>{const S=new FileReader;S.onload=m=>{const S=m.target.result;V&&V(S)},S.readAsArrayBuffer(m)}),I,E):M.Tools.EncodeScreenshotCanvasData(h.canvas,V,I,C,E),l.dispose()}))}function Z(){var m;b?(b.wrapper.dispose(),b.renderer.dispose(),b.ES.dispose()):null===(m=q)||void 0===m||m.then((m=>{m.wrapper.dispose(),m.renderer.dispose(),m.ES.dispose()}));q=null,b=null}const C={DumpData:I,DumpDataAsync:V,DumpFramebuffer:Y,Dispose:Z};M.Tools.DumpData=I,M.Tools.DumpDataAsync=V,M.Tools.DumpFramebuffer=Y},11313:(m,S,h)=>{h.r(S),h.d(S,{CreateScreenshot:()=>U,CreateScreenshotAsync:()=>H,CreateScreenshotUsingRenderTarget:()=>y,CreateScreenshotUsingRenderTargetAsync:()=>o,CreateScreenshotWithResizeAsync:()=>R,ScreenshotTools:()=>v});var l=h(11321),M=h(11398),O=h(11441),u=h(11293),b=h(11377),q=h(11446),Y=h(11456),V=h(11347);class I extends q.d{static _GetDefines(m){if(!m)return null;return m.extractDriverInfo().toLowerCase().indexOf("mali")>-1?"#define MALI 1\n":null}_gatherImports(m,S){m?(this._webGPUReady=!0,S.push(Promise.all([h.e(54).then(h.bind(h,13882)),h.e(55).then(h.bind(h,13891))]))):S.push(Promise.all([h.e(56).then(h.bind(h,13895)),h.e(57).then(h.bind(h,13900))]))}constructor(m){const S={...arguments.length>2?arguments[2]:void 0,name:m,ES:(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null)||Y.d.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,vertexShader:I.VertexUrl,fragmentShader:I.FragmentUrl,uniforms:I.Uniforms};super({...S,defines:I._GetDefines(S.ES)}),this.texelSize=new V.Vector2(0,0)}bind(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];super.bind(m),this._drawWrapper.effect.setFloat2("texelSize",this.texelSize.x,this.texelSize.y)}}I.VertexUrl="fxaa",I.FragmentUrl="fxaa",I.Uniforms=["texelSize"];class Z extends O.e{getClassName(){return"FxaaPostProcess"}constructor(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,M=arguments.length>3?arguments[3]:void 0,O=arguments.length>4?arguments[4]:void 0,u=arguments.length>5?arguments[5]:void 0,b=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const q={uniforms:I.Uniforms,size:"number"===typeof S?S:void 0,camera:h,samplingMode:M||l.e.BILINEAR_SAMPLINGMODE,ES:O,reusable:u,textureType:b,...S};super(m,I.FragmentUrl,{effectWrapper:"number"!==typeof S&&S.effectWrapper?void 0:new I(m,O,q),...q}),this.onApplyObservable.add((m=>{this._effectWrapper.texelSize=this.texelSize}))}static _Parse(m,S,h,l){return b.e.Parse((()=>new Z(m.name,m.options,S,m.renderTargetSamplingMode,h.getEngine(),m.reusable)),m,h,l)}}(0,u.e)("BABYLON.FxaaPostProcess",Z);var C=h(11173),B=h(11156),D=h(11550),E=h(11556),n=h(11226);let L=null;function U(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",O=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const{height:q,width:Y}=s(m,S,h);if(!q||!Y)return void C.e.Error("Invalid 'size' parameter !");S.sm().activeCamera===S?m.onEndFrameObservable.addOnce((()=>{L||(L=document.createElement("canvas")),L.width=Y,L.height=q;const S=L.getContext("2d"),h=m.getRenderingCanvas();if(!S||!h)return void C.e.Error("Failed to create screenshot. Rendering context or rendering canvas is not available.");const V=h.width,I=h.height,Z=L.width,D=L.height,E=Z/V,n=D/I,U=b?Math.max(E,n):Math.min(E,n),H=V*U,R=I*U,y=(Z-H)/2,o=(D-R)/2;S.drawImage(h,0,0,V,I,y,o,H,R),O?(B.Tools.EncodeScreenshotCanvasData(L,void 0,M,void 0,u),l&&l("")):B.Tools.EncodeScreenshotCanvasData(L,l,M,void 0,u)})):y(m,S,h,(m=>{if(O){const S=new Blob([m]);B.Tools.DownloadBlob(S),l&&l("")}else l&&l(m)}),M,1,m.getCreationOptions().antialias,void 0,void 0,void 0,void 0,u)}async function H(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",M=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return await new Promise(((u,b)=>{U(m,S,h,(m=>{"undefined"!==typeof m?u(m):b(new Error("Data is undefined"))}),l,void 0,M,O)}))}async function R(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",O=arguments.length>5?arguments[5]:void 0,u=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return await new Promise((b=>{U(m,S,{width:h,height:l},(()=>{b()}),M,!0,O,u)}))}function y(m,S,O,u){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6],V=arguments.length>7?arguments[7]:void 0,I=arguments.length>8&&void 0!==arguments[8]&&arguments[8],B=arguments.length>9&&void 0!==arguments[9]&&arguments[9],L=!(arguments.length>10&&void 0!==arguments[10])||arguments[10],U=arguments.length>11?arguments[11]:void 0,H=arguments.length>12?arguments[12]:void 0,R=arguments.length>13?arguments[13]:void 0;const{height:y,width:o,finalWidth:v,finalHeight:T}=s(m,S,O),X={width:o,height:y};if(!y||!o)return void C.e.Error("Invalid 'size' parameter !");m.skipFrameRender=!0;const g=m.getRenderWidth,G=m.getRenderHeight;m.getRenderWidth=function(){return!(arguments.length>0&&void 0!==arguments[0]&&arguments[0])&&m._currentRenderTarget?m._currentRenderTarget.width:o},m.getRenderHeight=function(){return!(arguments.length>0&&void 0!==arguments[0]&&arguments[0])&&m._currentRenderTarget?m._currentRenderTarget.height:y},m.onResizeObservable.hasObservers()&&m.onResizeObservable.notifyObservers(m);const e=S.sm(),a=new M.d("screenShot",X,e,!1,!1,0,!1,l.e.BILINEAR_SAMPLINGMODE,void 0,B,void 0,void 0,void 0,q);a.renderList=e.meshes.slice(),a.samples=q,a.renderSprites=I,a.activeCamera=S,a.forceLayerMaskCheck=L,null===H||void 0===H||H(a);const x=R||D.DumpData,P=()=>{e.incrementRenderId(),e.resetCachedMaterial(),(0,n.e)((()=>a.isReadyForRendering()&&S.isReady(!0)),(()=>{m.onEndFrameObservable.addOnce((()=>{v===o&&T===y?a.readPixels(void 0,void 0,void 0,!1).then((m=>{x(o,y,m,u,b,V,!0,void 0,U),a.dispose()})):(m.isWebGPU?h.e(51).then(h.bind(h,13858)):h.e(52).then(h.bind(h,13867))).then((async()=>await(0,E.e)("pass",a.getInternalTexture(),e,void 0,void 0,void 0,v,T).then((S=>{m._readTexturePixels(S,v,T,-1,0,null,!0,!1,0,0).then((m=>{x(v,T,m,u,b,V,!0,void 0,U),S.dispose()}))}))))})),e.incrementRenderId(),e.resetCachedMaterial();const l=e.activeCamera,M=e.activeCameras,O=S.outputRenderTarget,q=e.spritesEnabled;e.activeCamera=S,e.activeCameras=null,S.outputRenderTarget=a,e.spritesEnabled=I;const Y=e.meshes;e.meshes=a.renderList||e.meshes;try{e.render()}finally{e.activeCamera=l,e.activeCameras=M,S.outputRenderTarget=O,e.spritesEnabled=q,e.meshes=Y,m.getRenderWidth=g,m.getRenderHeight=G,m.onResizeObservable.hasObservers()&&m.onResizeObservable.notifyObservers(m),S.getProjectionMatrix(!0),m.skipFrameRender=!1}}),(()=>{m.skipFrameRender=!1,m.getRenderWidth=g,m.getRenderHeight=G}))};if(Y){const m=new Z("antialiasing",1,e.activeCamera);a.addPostProcess(m),m.Ah=!0,m.onEffectCreatedObservable.addOnce((m=>{m.isReady()?P():m.onCompiled=()=>{P()}}))}else P()}async function o(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,O=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6?arguments[6]:void 0,b=arguments.length>7&&void 0!==arguments[7]&&arguments[7],q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Y=!(arguments.length>9&&void 0!==arguments[9])||arguments[9],V=arguments.length>10?arguments[10]:void 0,I=arguments.length>11?arguments[11]:void 0,Z=arguments.length>12?arguments[12]:void 0;return await new Promise(((C,B)=>{y(m,S,h,(m=>{"undefined"!==typeof m?C(m):B(new Error("Data is undefined"))}),l,M,O,u,b,q,Y,V,I,Z)}))}function s(m,S,h){let l=0,M=0,O=0,u=0;if("object"===typeof h){const b=h.precision?Math.abs(h.precision):1;h.width&&h.height?(l=h.height*b,M=h.width*b):h.width&&!h.height?(M=h.width*b,l=Math.round(M/m.getAspectRatio(S))):h.height&&!h.width?(l=h.height*b,M=Math.round(l*m.getAspectRatio(S))):(M=Math.round(m.getRenderWidth()*b),l=Math.round(M/m.getAspectRatio(S))),h.finalWidth&&h.finalHeight?(u=h.finalHeight,O=h.finalWidth):h.finalWidth&&!h.finalHeight?(O=h.finalWidth,u=Math.round(O/m.getAspectRatio(S))):h.finalHeight&&!h.finalWidth?(u=h.finalHeight,O=Math.round(u*m.getAspectRatio(S))):(O=M,u=l)}else isNaN(h)||(l=h,M=h,O=h,u=h);return M&&(M=Math.floor(M)),l&&(l=Math.floor(l)),O&&(O=Math.floor(O)),u&&(u=Math.floor(u)),{height:0|l,width:0|M,finalWidth:0|O,finalHeight:0|u}}const v={CreateScreenshot:U,CreateScreenshotAsync:H,CreateScreenshotWithResizeAsync:R,CreateScreenshotUsingRenderTarget:y,CreateScreenshotUsingRenderTargetAsync:o};B.Tools.CreateScreenshot=U,B.Tools.CreateScreenshotAsync=H,B.Tools.CreateScreenshotUsingRenderTarget=y,B.Tools.CreateScreenshotUsingRenderTargetAsync=o}}]);