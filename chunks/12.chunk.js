"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10747:(O,q,s)=>{s.r(q),s.d(q,{_ExrTextureLoader:()=>F});var Z=s(1077),D=s(1022);const B=65536,P=14,y=65537,o=16384;var w,h;!function(O){O[O.NO_COMPRESSION=0]="NO_COMPRESSION",O[O.RLE_COMPRESSION=1]="RLE_COMPRESSION",O[O.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",O[O.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",O[O.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",O[O.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(w||(w={})),function(O){O[O.INCREASING_Y=0]="INCREASING_Y",O[O.DECREASING_Y=1]="DECREASING_Y"}(h||(h={}));const n=function(){const O=new ArrayBuffer(4),q=new Float32Array(O),s=new Uint32Array(O),Z=new Uint32Array(512),D=new Uint32Array(512);for(let o=0;o<256;++o){const O=o-127;O<-27?(Z[o]=0,Z[256|o]=32768,D[o]=24,D[256|o]=24):O<-14?(Z[o]=1024>>-O-14,Z[256|o]=1024>>-O-14|32768,D[o]=-O-1,D[256|o]=-O-1):O<=15?(Z[o]=O+15<<10,Z[256|o]=O+15<<10|32768,D[o]=13,D[256|o]=13):O<128?(Z[o]=31744,Z[256|o]=64512,D[o]=24,D[256|o]=24):(Z[o]=31744,Z[256|o]=64512,D[o]=13,D[256|o]=13)}const B=new Uint32Array(2048),P=new Uint32Array(64),y=new Uint32Array(64);for(let o=1;o<1024;++o){let O=o<<13,q=0;for(;0===(8388608&O);)O<<=1,q-=8388608;O&=-8388609,q+=947912704,B[o]=O|q}for(let o=1024;o<2048;++o)B[o]=939524096+(o-1024<<13);for(let o=1;o<31;++o)P[o]=o<<23;P[31]=1199570944,P[32]=2147483648;for(let o=33;o<63;++o)P[o]=2147483648+(o-32<<23);P[63]=3347054592;for(let o=1;o<64;++o)32!==o&&(y[o]=1024);return{floatView:q,uint32View:s,baseTable:Z,shiftTable:D,mantissaTable:B,exponentTable:P,offsetTable:y}}();function r(O,q){const s=new Uint8Array(O);let Z=0;for(;0!=s[q.value+Z];)Z+=1;const D=(new TextDecoder).decode(s.slice(q.value,q.value+Z));return q.value=q.value+Z+1,D}function j(O,q){const s=O.getInt32(q.value,!0);return q.value+=4,s}function f(O,q){const s=O.getUint32(q.value,!0);return q.value+=4,s}function u(O,q){const s=O.getUint8(q.value);return q.value+=1,s}function c(O,q){const s=O.getUint16(q.value,!0);return q.value+=2,s}function W(O,q){const s=O[q.value];return q.value+=1,s}function m(O,q){let s;return s="getBigInt64"in DataView.prototype?Number(O.getBigInt64(q.value,!0)):O.getUint32(q.value+4,!0)+Number(O.getUint32(q.value,!0)<<32),q.value+=8,s}function g(O,q){const s=O.getFloat32(q.value,!0);return q.value+=4,s}function R(O,q){return function(O){const q=(31744&O)>>10,s=1023&O;return(O>>15?-1:1)*(q?31===q?s?NaN:1/0:Math.pow(2,q-15)*(1+s/1024):s/1024*6103515625e-14)}(c(O,q))}function N(O,q){return function(O){if(Math.abs(O)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");O=(0,D.e)(O,-65504,65504),n.floatView[0]=O;const q=n.uint32View[0],s=q>>23&511;return n.baseTable[s]+((8388607&q)>>n.shiftTable[s])}(g(O,q))}function L(O,q,s,Z){switch(s){case"string":case"stringvector":case"iccProfile":return function(O,q,s){const Z=(new TextDecoder).decode(new Uint8Array(O).slice(q.value,q.value+s));return q.value=q.value+s,Z}(O.buffer,q,Z);case"chlist":return function(O,q,s){const Z=q.value,D=[];for(;q.value<Z+s-1;){const s=r(O.buffer,q),Z=j(O,q),B=u(O,q);q.value+=3;const P=j(O,q),y=j(O,q);D.push({name:s,pixelType:Z,pLinear:B,xSampling:P,ySampling:y})}return q.value+=1,D}(O,q,Z);case"chromaticities":return function(O,q){return{redX:g(O,q),redY:g(O,q),greenX:g(O,q),greenY:g(O,q),blueX:g(O,q),blueY:g(O,q),whiteX:g(O,q),whiteY:g(O,q)}}(O,q);case"compression":return function(O,q){return u(O,q)}(O,q);case"box2i":return function(O,q){return{xMin:j(O,q),yMin:j(O,q),xMax:j(O,q),yMax:j(O,q)}}(O,q);case"lineOrder":return function(O,q){const s=u(O,q);return h[s]}(O,q);case"float":return g(O,q);case"v2f":return function(O,q){return[g(O,q),g(O,q)]}(O,q);case"v3f":return function(O,q){return[g(O,q),g(O,q),g(O,q)]}(O,q);case"int":return j(O,q);case"rational":return function(O,q){return[j(O,q),f(O,q)]}(O,q);case"timecode":return function(O,q){return[f(O,q),f(O,q)]}(O,q);case"preview":return q.value+=Z,"skipped";default:return void(q.value+=Z)}}function U(O){for(let q=1;q<O.length;q++){const s=O[q-1]+O[q]-128;O[q]=s}}function k(O,q){let s=0,Z=Math.floor((O.length+1)/2),D=0;const B=O.length-1;for(;!(D>B)&&(q[D++]=O[s++],!(D>B));)q[D++]=O[Z++]}function x(O,q,s,Z,D){for(;s<O;)q=q<<8|W(Z,D),s+=8;return{l:q>>(s-=O)&(1<<O)-1,c:q,lc:s}}function M(O,q,s,Z){return{c:O=O<<8|W(s,Z),lc:q+=8}}function V(O,q,s,Z,D,B,P,y,o){if(O==q){if(Z<8){const O=M(s,Z,D,B);s=O.c,Z=O.lc}let O=s>>(Z-=8);if(O=new Uint8Array([O])[0],y.value+O>o)return null;const q=P[y.value-1];for(;O-- >0;)P[y.value++]=q}else{if(!(y.value<o))return null;P[y.value++]=O}return{c:s,lc:Z}}const H=new Array(59);function e(O,q,s,Z,D,B){const P=q;let o=0,w=0;for(;Z<=D;Z++){if(P.value-q.value>s)return;let y=x(6,o,w,O,P);const h=y.l;if(o=y.c,w=y.lc,B[Z]=h,63==h){if(P.value-q.value>s)throw new Error("Error in HufUnpackEncTable");y=x(8,o,w,O,P);let h=y.l+6;if(o=y.c,w=y.lc,Z+h>D+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)B[Z++]=0;Z--}else if(h>=59){let O=h-59+2;if(Z+O>D+1)throw new Error("Error in HufUnpackEncTable");for(;O--;)B[Z++]=0;Z--}}!function(O){for(let s=0;s<=58;++s)H[s]=0;for(let s=0;s<y;++s)H[O[s]]+=1;let q=0;for(let s=58;s>0;--s){const O=q+H[s]>>1;H[s]=q,q=O}for(let s=0;s<y;++s){const q=O[s];q>0&&(O[s]=q|H[q]++<<6)}}(B)}function A(O){return 63&O}function C(O){return O>>6}function K(O,q,s,Z,D,B){const w=s.value,h=f(q,s),n=f(q,s);s.value+=4;const r=f(q,s);if(s.value+=4,h<0||h>=y||n<0||n>=y)throw new Error("Wrong HUF_ENCSIZE");const j=new Array(y),u=new Array(o);!function(O){for(let q=0;q<o;q++)O[q]={},O[q].len=0,O[q].lit=0,O[q].p=null}(u);if(e(O,s,Z-(s.value-w),h,n,j),r>8*(Z-(s.value-w)))throw new Error("Wrong hufUncompress");!function(O,q,s,Z){for(;q<=s;q++){const s=C(O[q]),D=A(O[q]);if(s>>D)throw new Error("Invalid table entry");if(D>P){const O=Z[s>>D-P];if(O.len)throw new Error("Invalid table entry");if(O.lit++,O.p){const q=O.p;O.p=new Array(O.lit);for(let s=0;s<O.lit-1;++s)O.p[s]=q[s]}else O.p=new Array(1);O.p[O.lit-1]=q}else if(D){let O=0;for(let B=1<<P-D;B>0;B--){const B=Z[(s<<P-D)+O];if(B.len||B.p)throw new Error("Invalid table entry");B.len=D,B.lit=q,O++}}}}(j,h,n,u),function(O,q,s,Z,D,B,y,o,w){let h=0,n=0;const r=y,j=Math.trunc(Z.value+(D+7)/8);for(;Z.value<j;){let D=M(h,n,s,Z);for(h=D.c,n=D.lc;n>=P;){const y=q[h>>n-P&16383];if(y.len){n-=y.len;const O=V(y.lit,B,h,n,s,Z,o,w,r);O&&(h=O.c,n=O.lc)}else{if(!y.p)throw new Error("hufDecode issues");let q;for(q=0;q<y.lit;q++){const P=A(O[y.p[q]]);for(;n<P&&Z.value<j;)D=M(h,n,s,Z),h=D.c,n=D.lc;if(n>=P&&C(O[y.p[q]])==(h>>n-P&(1<<P)-1)){n-=P;const O=V(y.p[q],B,h,n,s,Z,o,w,r);O&&(h=O.c,n=O.lc);break}}if(q==y.lit)throw new Error("HufDecode issues")}}}const f=8-D&7;for(h>>=f,n-=f;n>0;){const O=q[h<<P-n&16383];if(!O.len)throw new Error("HufDecode issues");{n-=O.len;const q=V(O.lit,B,h,n,s,Z,o,w,r);q&&(h=q.c,n=q.lc)}}}(j,u,O,s,r,n,B,D,{value:0})}function l(O){return 65535&O}function T(O){const q=l(O);return q>32767?q-65536:q}function a(O,q){const s=T(O),Z=T(q),D=s+(1&Z)+(Z>>1);return{a:D,b:D-Z}}function p(O,q){const s=l(O),Z=l(q),D=s-(Z>>1)&65535;return{a:Z+D-32768&65535,b:D}}function d(O,q,s,Z,D,B,P){const y=P<16384,o=s>D?D:s;let w,h,n=1;for(;n<=o;)n<<=1;for(n>>=1,w=n,n>>=1;n>=1;){h=0;const P=h+B*(D-w),o=B*n,r=B*w,j=Z*n,f=Z*w;let u,c,W,m;for(;h<=P;h+=r){let D=h;const B=h+Z*(s-w);for(;D<=B;D+=f){const s=D+j,Z=D+o,B=Z+j;if(y){let P=a(O[D+q],O[Z+q]);u=P.a,W=P.b,P=a(O[s+q],O[B+q]),c=P.a,m=P.b,P=a(u,c),O[D+q]=P.a,O[s+q]=P.b,P=a(W,m),O[Z+q]=P.a,O[B+q]=P.b}else{let P=p(O[D+q],O[Z+q]);u=P.a,W=P.b,P=p(O[s+q],O[B+q]),c=P.a,m=P.b,P=p(u,c),O[D+q]=P.a,O[s+q]=P.b,P=p(W,m),O[Z+q]=P.a,O[B+q]=P.b}}if(s&n){const s=D+o;let Z;Z=y?a(O[D+q],O[s+q]):p(O[D+q],O[s+q]),u=Z.a,O[s+q]=Z.b,O[D+q]=u}}if(D&n){let D=h;const B=h+Z*(s-w);for(;D<=B;D+=f){const s=D+j;let Z;Z=y?a(O[D+q],O[s+q]):p(O[D+q],O[s+q]),u=Z.a,O[s+q]=Z.b,O[D+q]=u}}w=n,n>>=1}return h}function v(O){return new DataView(O.array.buffer,O.offset.value,O.size)}function z(O){const q=O.viewer.buffer.slice(O.offset.value,O.offset.value+O.size),s=new Uint8Array(function(O){let q=O.byteLength;const s=new Array;let Z=0;const D=new DataView(O);for(;q>0;){const O=D.getInt8(Z++);if(O<0){const B=-O;q-=B+1;for(let O=0;O<B;O++)s.push(D.getUint8(Z++))}else{const B=O;q-=2;const P=D.getUint8(Z++);for(let O=0;O<B+1;O++)s.push(P)}}return s}(q)),Z=new Uint8Array(s.length);return U(s),k(s,Z),new DataView(Z.buffer)}function G(O){const q=O.array.slice(O.offset.value,O.offset.value+O.size),s=fflate.unzlibSync(q),Z=new Uint8Array(s.length);return U(s),k(s,Z),new DataView(Z.buffer)}function Y(O){const q=O.array.slice(O.offset.value,O.offset.value+O.size),s=fflate.unzlibSync(q),Z=O.lines*O.channels*O.width,D=1==O.type?new Uint16Array(Z):new Uint32Array(Z);let B=0,P=0;const y=new Array(4);for(let o=0;o<O.lines;o++)for(let q=0;q<O.channels;q++){let q=0;switch(O.type){case 1:y[0]=B,y[1]=y[0]+O.width,B=y[1]+O.width;for(let Z=0;Z<O.width;++Z){q+=s[y[0]++]<<8|s[y[1]++],D[P]=q,P++}break;case 2:y[0]=B,y[1]=y[0]+O.width,y[2]=y[1]+O.width,B=y[2]+O.width;for(let Z=0;Z<O.width;++Z){q+=s[y[0]++]<<24|s[y[1]++]<<16|s[y[2]++]<<8,D[P]=q,P++}}}return new DataView(D.buffer)}function X(O){const q=O.viewer,s={value:O.offset.value},Z=new Uint16Array(O.width*O.scanlineBlockSize*(O.channels*O.type)),D=new Uint8Array(8192);let P=0;const y=new Array(O.channels);for(let B=0;B<O.channels;B++)y[B]={},y[B].start=P,y[B].end=y[B].start,y[B].nx=O.width,y[B].ny=O.lines,y[B].size=O.type,P+=y[B].nx*y[B].ny*y[B].size;const o=c(q,s),w=c(q,s);if(w>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=w)for(let B=0;B<w-o+1;B++)D[B+o]=u(q,s);const h=new Uint16Array(B),n=function(O,q){let s=0;for(let D=0;D<B;++D)(0==D||O[D>>3]&1<<(7&D))&&(q[s++]=D);const Z=s-1;for(;s<B;)q[s++]=0;return Z}(D,h),r=f(q,s);K(O.array,q,s,r,Z,P);for(let B=0;B<O.channels;++B){const O=y[B];for(let q=0;q<y[B].size;++q)d(Z,O.start+q,O.nx,O.size,O.ny,O.nx*O.size,n)}!function(O,q,s){for(let Z=0;Z<s;++Z)q[Z]=O[q[Z]]}(h,Z,P);let j=0;const W=new Uint8Array(Z.buffer.byteLength);for(let B=0;B<O.lines;B++)for(let q=0;q<O.channels;q++){const O=y[q],s=O.nx*O.size,D=new Uint8Array(Z.buffer,2*O.end,2*s);W.set(D,j),j+=2*s,O.end+=s}return new DataView(W.buffer)}var b,t=s(1183);!function(O){O[O.Float=0]="Float",O[O.HalfFloat=1]="HalfFloat"}(b||(b={}));class S{}S.DefaultOutputType=b.HalfFloat,S.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class F{constructor(){this.supportCascades=!1}loadCubeData(O,q,s,Z,D){throw".exr not supported in Cube."}async loadData(O,q,s){const D=new DataView(O.buffer),B={value:0},P=function(O,q){if(20000630!=O.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const s=O.getUint8(4),D=O.getUint8(5),B={singleTile:!!(2&D),longName:!!(4&D),deepFormat:!!(8&D),multiPart:!!(16&D)};q.value=8;const P={};let y=!0;for(;y;){const s=r(O.buffer,q);if(s){const D=r(O.buffer,q),B=L(O,q,D,f(O,q));void 0===B?Z.d.Warn(`Unknown header attribute type ${D}'.`):P[s]=B}else y=!1}if(0!=(-5&D))throw new Error("Unsupported file format");return{version:s,spec:B,...P}}(D,B),y=await async function(O,q,s,Z){const D={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:s,width:O.dataWindow.xMax-O.dataWindow.xMin+1,height:O.dataWindow.yMax-O.dataWindow.yMin+1,channels:O.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(O.compression){case w.NO_COMPRESSION:D.lines=1,D.uncompress=v;break;case w.RLE_COMPRESSION:D.lines=1,D.uncompress=z;break;case w.ZIPS_COMPRESSION:D.lines=1,D.uncompress=G,await t.f.LoadScriptAsync(S.FFLATEUrl);break;case w.ZIP_COMPRESSION:D.lines=16,D.uncompress=G,await t.f.LoadScriptAsync(S.FFLATEUrl);break;case w.PIZ_COMPRESSION:D.lines=32,D.uncompress=X;break;case w.PXR24_COMPRESSION:D.lines=16,D.uncompress=Y,await t.f.LoadScriptAsync(S.FFLATEUrl);break;default:throw new Error(w[O.compression]+" is unsupported")}D.scanlineBlockSize=D.lines;const B={};for(const w of O.channels)switch(w.name){case"Y":case"R":case"G":case"B":case"A":B[w.name]=!0,D.type=w.pixelType}let P=!1;if(B.R&&B.G&&B.B)P=!B.A,D.outputChannels=4,D.decodeChannels={R:0,G:1,B:2,A:3};else{if(!B.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");D.outputChannels=1,D.decodeChannels={Y:0}}if(1===D.type)switch(Z){case b.Float:D.getter=R,D.inputSize=2;break;case b.HalfFloat:D.getter=c,D.inputSize=2}else{if(2!==D.type)throw new Error("Unsupported pixelType "+D.type+" for "+O.compression);switch(Z){case b.Float:D.getter=g,D.inputSize=4;break;case b.HalfFloat:D.getter=N,D.inputSize=4}}D.blockCount=D.height/D.scanlineBlockSize;for(let w=0;w<D.blockCount;w++)m(q,s);const y=D.width*D.height*D.outputChannels;switch(Z){case b.Float:D.byteArray=new Float32Array(y),D.textureType=1,P&&D.byteArray.fill(1,0,y);break;case b.HalfFloat:D.byteArray=new Uint16Array(y),D.textureType=2,P&&D.byteArray.fill(15360,0,y);break;default:throw new Error("Unsupported type: "+Z)}let o=0;for(const w of O.channels)void 0!==D.decodeChannels[w.name]&&(D.channelLineOffsets[w.name]=o*D.width),o+=2*w.pixelType;return D.bytesPerLine=D.width*o,D.outLineWidth=D.width*D.outputChannels,"INCREASING_Y"===O.lineOrder?D.scanOrder=O=>O:D.scanOrder=O=>D.height-1-O,4==D.outputChannels?(D.format=5,D.linearSpace=!0):(D.format=6,D.linearSpace=!1),D}(P,D,B,S.DefaultOutputType);!function(O,q,s,Z){const D={value:0};for(let B=0;B<O.height/O.scanlineBlockSize;B++){const P=j(s,Z)-q.dataWindow.yMin;O.size=f(s,Z),O.lines=P+O.scanlineBlockSize>O.height?O.height-P:O.scanlineBlockSize;const y=O.size<O.lines*O.bytesPerLine&&O.uncompress?O.uncompress(O):v(O);Z.value+=O.size;for(let s=0;s<O.scanlineBlockSize;s++){const Z=B*O.scanlineBlockSize,P=s+O.scanOrder(Z);if(P>=O.height)continue;const o=s*O.bytesPerLine,w=(O.height-1-P)*O.outLineWidth;for(let s=0;s<O.channels;s++){const Z=q.channels[s].name,B=O.channelLineOffsets[Z],P=O.decodeChannels[Z];if(void 0!==P){D.value=o+B;for(let q=0;q<O.width;q++){const s=w+q*O.outputChannels+P;O.byteArray&&(O.byteArray[s]=O.getter(y,D))}}}}}}(y,P,D,B);s(P.dataWindow.xMax-P.dataWindow.xMin+1,P.dataWindow.yMax-P.dataWindow.yMin+1,q.generateMipMaps,!1,(()=>{const O=q.getEngine();q.format=P.format,q.type=y.textureType,q.invertY=!1,q._gammaSpace=!P.linearSpace,y.byteArray&&O._uploadDataToTextureDirectly(q,y.byteArray,0,0,void 0,!0)}))}}}}]);