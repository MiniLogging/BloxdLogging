"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12833:(E,b,h)=>{h.r(b),h.d(b,{_DDSTextureLoader:()=>G});var a=h(11659),k=h(11677);class G{constructor(){this.supportCascades=!0}loadCubeData(E,b,h,G){const V=b.getEngine();let l,O=!1,v=1e3;if(Array.isArray(E))for(let a=0;a<E.length;a++){const h=E[a];l=k.c.GetDDSInfo(h),b.width=l.width,b.height=l.height,O=(l.isRGB||l.isLuminance||l.mipmapCount>1)&&b.generateMipMaps,V._unpackFlipY(l.isCompressed),k.c.UploadDDSLevels(V,b,h,l,O,6,-1,a),l.isFourCC||1!==l.mipmapCount?v=l.mipmapCount-1:V.generateMipMapsForCubemap(b)}else{const G=E;l=k.c.GetDDSInfo(G),b.width=l.width,b.height=l.height,h&&(l.sphericalPolynomial=new a.h),O=(l.isRGB||l.isLuminance||l.mipmapCount>1)&&b.generateMipMaps,V._unpackFlipY(l.isCompressed),k.c.UploadDDSLevels(V,b,G,l,O,6),l.isFourCC||1!==l.mipmapCount?v=l.mipmapCount-1:V.generateMipMapsForCubemap(b,!1)}V._setCubeMapTextureParams(b,O,v),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),G&&G({isDDS:!0,width:b.width,info:l,data:E,texture:b})}loadData(E,b,h){const a=k.c.GetDDSInfo(E),G=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&b.generateMipMaps&&Math.max(a.width,a.height)>>a.mipmapCount-1===1;h(a.width,a.height,G,a.isFourCC,(()=>{k.c.UploadDDSLevels(b.getEngine(),b,E,a,G,1)}))}}}}]);