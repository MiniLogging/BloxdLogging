"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10142:(V,H,t)=>{t.r(H),t.d(H,{_ExrTextureLoader:()=>w});var I=t(1023),Z=t(960);const h=65536,f=14,m=65537,K=16384;var E,d;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(E||(E={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(d||(d={}));const a=function(){const V=new ArrayBuffer(4),H=new Float32Array(V),t=new Uint32Array(V),I=new Uint32Array(512),Z=new Uint32Array(512);for(let K=0;K<256;++K){const V=K-127;V<-27?(I[K]=0,I[256|K]=32768,Z[K]=24,Z[256|K]=24):V<-14?(I[K]=1024>>-V-14,I[256|K]=1024>>-V-14|32768,Z[K]=-V-1,Z[256|K]=-V-1):V<=15?(I[K]=V+15<<10,I[256|K]=V+15<<10|32768,Z[K]=13,Z[256|K]=13):V<128?(I[K]=31744,I[256|K]=64512,Z[K]=24,Z[256|K]=24):(I[K]=31744,I[256|K]=64512,Z[K]=13,Z[256|K]=13)}const h=new Uint32Array(2048),f=new Uint32Array(64),m=new Uint32Array(64);for(let K=1;K<1024;++K){let V=K<<13,H=0;for(;0===(8388608&V);)V<<=1,H-=8388608;V&=-8388609,H+=947912704,h[K]=V|H}for(let K=1024;K<2048;++K)h[K]=939524096+(K-1024<<13);for(let K=1;K<31;++K)f[K]=K<<23;f[31]=1199570944,f[32]=2147483648;for(let K=33;K<63;++K)f[K]=2147483648+(K-32<<23);f[63]=3347054592;for(let K=1;K<64;++K)32!==K&&(m[K]=1024);return{floatView:H,uint32View:t,baseTable:I,shiftTable:Z,mantissaTable:h,exponentTable:f,offsetTable:m}}();function J(V,H){const t=new Uint8Array(V);let I=0;for(;0!=t[H.value+I];)I+=1;const Z=(new TextDecoder).decode(t.slice(H.value,H.value+I));return H.value=H.value+I+1,Z}function O(V,H){const t=V.getInt32(H.value,!0);return H.value+=4,t}function C(V,H){const t=V.getUint32(H.value,!0);return H.value+=4,t}function S(V,H){const t=V.getUint8(H.value);return H.value+=1,t}function v(V,H){const t=V.getUint16(H.value,!0);return H.value+=2,t}function Q(V,H){const t=V[H.value];return H.value+=1,t}function e(V,H){let t;return t="getBigInt64"in DataView.prototype?Number(V.getBigInt64(H.value,!0)):V.getUint32(H.value+4,!0)+Number(V.getUint32(H.value,!0)<<32),H.value+=8,t}function W(V,H){const t=V.getFloat32(H.value,!0);return H.value+=4,t}function c(V,H){return function(V){const H=(31744&V)>>10,t=1023&V;return(V>>15?-1:1)*(H?31===H?t?NaN:1/0:Math.pow(2,H-15)*(1+t/1024):t/1024*6103515625e-14)}(v(V,H))}function o(V,H){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,Z.b)(V,-65504,65504),a.floatView[0]=V;const H=a.uint32View[0],t=H>>23&511;return a.baseTable[t]+((8388607&H)>>a.shiftTable[t])}(W(V,H))}function i(V,H,t,I){switch(t){case"string":case"stringvector":case"iccProfile":return function(V,H,t){const I=(new TextDecoder).decode(new Uint8Array(V).slice(H.value,H.value+t));return H.value=H.value+t,I}(V.buffer,H,I);case"chlist":return function(V,H,t){const I=H.value,Z=[];for(;H.value<I+t-1;){const t=J(V.buffer,H),I=O(V,H),h=S(V,H);H.value+=3;const f=O(V,H),m=O(V,H);Z.push({name:t,pixelType:I,pLinear:h,xSampling:f,ySampling:m})}return H.value+=1,Z}(V,H,I);case"chromaticities":return function(V,H){return{redX:W(V,H),redY:W(V,H),greenX:W(V,H),greenY:W(V,H),blueX:W(V,H),blueY:W(V,H),whiteX:W(V,H),whiteY:W(V,H)}}(V,H);case"compression":return function(V,H){return S(V,H)}(V,H);case"box2i":return function(V,H){return{xMin:O(V,H),yMin:O(V,H),xMax:O(V,H),yMax:O(V,H)}}(V,H);case"lineOrder":return function(V,H){const t=S(V,H);return d[t]}(V,H);case"float":return W(V,H);case"v2f":return function(V,H){return[W(V,H),W(V,H)]}(V,H);case"v3f":return function(V,H){return[W(V,H),W(V,H),W(V,H)]}(V,H);case"int":return O(V,H);case"rational":return function(V,H){return[O(V,H),C(V,H)]}(V,H);case"timecode":return function(V,H){return[C(V,H),C(V,H)]}(V,H);case"preview":return H.value+=I,"skipped";default:return void(H.value+=I)}}function U(V){for(let H=1;H<V.length;H++){const t=V[H-1]+V[H]-128;V[H]=t}}function D(V,H){let t=0,I=Math.floor((V.length+1)/2),Z=0;const h=V.length-1;for(;!(Z>h)&&(H[Z++]=V[t++],!(Z>h));)H[Z++]=V[I++]}function L(V,H,t,I,Z){for(;t<V;)H=H<<8|Q(I,Z),t+=8;return{l:H>>(t-=V)&(1<<V)-1,c:H,lc:t}}function N(V,H,t,I){return{c:V=V<<8|Q(t,I),lc:H+=8}}function j(V,H,t,I,Z,h,f,m,K){if(V==H){if(I<8){const V=N(t,I,Z,h);t=V.c,I=V.lc}let V=t>>(I-=8);if(V=new Uint8Array([V])[0],m.value+V>K)return null;const H=f[m.value-1];for(;V-- >0;)f[m.value++]=H}else{if(!(m.value<K))return null;f[m.value++]=V}return{c:t,lc:I}}const s=new Array(59);function A(V,H,t,I,Z,h){const f=H;let K=0,E=0;for(;I<=Z;I++){if(f.value-H.value>t)return;let m=L(6,K,E,V,f);const d=m.l;if(K=m.c,E=m.lc,h[I]=d,63==d){if(f.value-H.value>t)throw new Error("Error in HufUnpackEncTable");m=L(8,K,E,V,f);let d=m.l+6;if(K=m.c,E=m.lc,I+d>Z+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)h[I++]=0;I--}else if(d>=59){let V=d-59+2;if(I+V>Z+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)h[I++]=0;I--}}!function(V){for(let t=0;t<=58;++t)s[t]=0;for(let t=0;t<m;++t)s[V[t]]+=1;let H=0;for(let t=58;t>0;--t){const V=H+s[t]>>1;s[t]=H,H=V}for(let t=0;t<m;++t){const H=V[t];H>0&&(V[t]=H|s[H]++<<6)}}(h)}function q(V){return 63&V}function M(V){return V>>6}function g(V,H,t,I,Z,h){const E=t.value,d=C(H,t),a=C(H,t);t.value+=4;const J=C(H,t);if(t.value+=4,d<0||d>=m||a<0||a>=m)throw new Error("Wrong HUF_ENCSIZE");const O=new Array(m),S=new Array(K);!function(V){for(let H=0;H<K;H++)V[H]={},V[H].len=0,V[H].lit=0,V[H].p=null}(S);if(A(V,t,I-(t.value-E),d,a,O),J>8*(I-(t.value-E)))throw new Error("Wrong hufUncompress");!function(V,H,t,I){for(;H<=t;H++){const t=M(V[H]),Z=q(V[H]);if(t>>Z)throw new Error("Invalid table entry");if(Z>f){const V=I[t>>Z-f];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const H=V.p;V.p=new Array(V.lit);for(let t=0;t<V.lit-1;++t)V.p[t]=H[t]}else V.p=new Array(1);V.p[V.lit-1]=H}else if(Z){let V=0;for(let h=1<<f-Z;h>0;h--){const h=I[(t<<f-Z)+V];if(h.len||h.p)throw new Error("Invalid table entry");h.len=Z,h.lit=H,V++}}}}(O,d,a,S),function(V,H,t,I,Z,h,m,K,E){let d=0,a=0;const J=m,O=Math.trunc(I.value+(Z+7)/8);for(;I.value<O;){let Z=N(d,a,t,I);for(d=Z.c,a=Z.lc;a>=f;){const m=H[d>>a-f&16383];if(m.len){a-=m.len;const V=j(m.lit,h,d,a,t,I,K,E,J);V&&(d=V.c,a=V.lc)}else{if(!m.p)throw new Error("hufDecode issues");let H;for(H=0;H<m.lit;H++){const f=q(V[m.p[H]]);for(;a<f&&I.value<O;)Z=N(d,a,t,I),d=Z.c,a=Z.lc;if(a>=f&&M(V[m.p[H]])==(d>>a-f&(1<<f)-1)){a-=f;const V=j(m.p[H],h,d,a,t,I,K,E,J);V&&(d=V.c,a=V.lc);break}}if(H==m.lit)throw new Error("HufDecode issues")}}}const C=8-Z&7;for(d>>=C,a-=C;a>0;){const V=H[d<<f-a&16383];if(!V.len)throw new Error("HufDecode issues");{a-=V.len;const H=j(V.lit,h,d,a,t,I,K,E,J);H&&(d=H.c,a=H.lc)}}}(O,S,V,t,J,a,h,Z,{value:0})}function z(V){return 65535&V}function G(V){const H=z(V);return H>32767?H-65536:H}function r(V,H){const t=G(V),I=G(H),Z=t+(1&I)+(I>>1);return{a:Z,b:Z-I}}function p(V,H){const t=z(V),I=z(H),Z=t-(I>>1)&65535;return{a:I+Z-32768&65535,b:Z}}function B(V,H,t,I,Z,h,f){const m=f<16384,K=t>Z?Z:t;let E,d,a=1;for(;a<=K;)a<<=1;for(a>>=1,E=a,a>>=1;a>=1;){d=0;const f=d+h*(Z-E),K=h*a,J=h*E,O=I*a,C=I*E;let S,v,Q,e;for(;d<=f;d+=J){let Z=d;const h=d+I*(t-E);for(;Z<=h;Z+=C){const t=Z+O,I=Z+K,h=I+O;if(m){let f=r(V[Z+H],V[I+H]);S=f.a,Q=f.b,f=r(V[t+H],V[h+H]),v=f.a,e=f.b,f=r(S,v),V[Z+H]=f.a,V[t+H]=f.b,f=r(Q,e),V[I+H]=f.a,V[h+H]=f.b}else{let f=p(V[Z+H],V[I+H]);S=f.a,Q=f.b,f=p(V[t+H],V[h+H]),v=f.a,e=f.b,f=p(S,v),V[Z+H]=f.a,V[t+H]=f.b,f=p(Q,e),V[I+H]=f.a,V[h+H]=f.b}}if(t&a){const t=Z+K;let I;I=m?r(V[Z+H],V[t+H]):p(V[Z+H],V[t+H]),S=I.a,V[t+H]=I.b,V[Z+H]=S}}if(Z&a){let Z=d;const h=d+I*(t-E);for(;Z<=h;Z+=C){const t=Z+O;let I;I=m?r(V[Z+H],V[t+H]):p(V[Z+H],V[t+H]),S=I.a,V[t+H]=I.b,V[Z+H]=S}}E=a,a>>=1}return d}function F(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function b(V){const H=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),t=new Uint8Array(function(V){let H=V.byteLength;const t=new Array;let I=0;const Z=new DataView(V);for(;H>0;){const V=Z.getInt8(I++);if(V<0){const h=-V;H-=h+1;for(let V=0;V<h;V++)t.push(Z.getUint8(I++))}else{const h=V;H-=2;const f=Z.getUint8(I++);for(let V=0;V<h+1;V++)t.push(f)}}return t}(H)),I=new Uint8Array(t.length);return U(t),D(t,I),new DataView(I.buffer)}function X(V){const H=V.array.slice(V.offset.value,V.offset.value+V.size),t=fflate.unzlibSync(H),I=new Uint8Array(t.length);return U(t),D(t,I),new DataView(I.buffer)}function R(V){const H=V.array.slice(V.offset.value,V.offset.value+V.size),t=fflate.unzlibSync(H),I=V.lines*V.channels*V.width,Z=1==V.type?new Uint16Array(I):new Uint32Array(I);let h=0,f=0;const m=new Array(4);for(let K=0;K<V.lines;K++)for(let H=0;H<V.channels;H++){let H=0;switch(V.type){case 1:m[0]=h,m[1]=m[0]+V.width,h=m[1]+V.width;for(let I=0;I<V.width;++I){H+=t[m[0]++]<<8|t[m[1]++],Z[f]=H,f++}break;case 2:m[0]=h,m[1]=m[0]+V.width,m[2]=m[1]+V.width,h=m[2]+V.width;for(let I=0;I<V.width;++I){H+=t[m[0]++]<<24|t[m[1]++]<<16|t[m[2]++]<<8,Z[f]=H,f++}}}return new DataView(Z.buffer)}function u(V){const H=V.viewer,t={value:V.offset.value},I=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),Z=new Uint8Array(8192);let f=0;const m=new Array(V.channels);for(let h=0;h<V.channels;h++)m[h]={},m[h].start=f,m[h].end=m[h].start,m[h].nx=V.width,m[h].ny=V.lines,m[h].size=V.type,f+=m[h].nx*m[h].ny*m[h].size;const K=v(H,t),E=v(H,t);if(E>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(K<=E)for(let h=0;h<E-K+1;h++)Z[h+K]=S(H,t);const d=new Uint16Array(h),a=function(V,H){let t=0;for(let Z=0;Z<h;++Z)(0==Z||V[Z>>3]&1<<(7&Z))&&(H[t++]=Z);const I=t-1;for(;t<h;)H[t++]=0;return I}(Z,d),J=C(H,t);g(V.array,H,t,J,I,f);for(let h=0;h<V.channels;++h){const V=m[h];for(let H=0;H<m[h].size;++H)B(I,V.start+H,V.nx,V.size,V.ny,V.nx*V.size,a)}!function(V,H,t){for(let I=0;I<t;++I)H[I]=V[H[I]]}(d,I,f);let O=0;const Q=new Uint8Array(I.buffer.byteLength);for(let h=0;h<V.lines;h++)for(let H=0;H<V.channels;H++){const V=m[H],t=V.nx*V.size,Z=new Uint8Array(I.buffer,2*V.end,2*t);Q.set(Z,O),O+=2*t,V.end+=t}return new DataView(Q.buffer)}var P,n=t(1145);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(P||(P={}));class l{}l.DefaultOutputType=P.HalfFloat,l.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class w{constructor(){this.supportCascades=!1}loadCubeData(V,H,t,I,Z){throw".exr not supported in Cube."}async loadData(V,H,t){const Z=new DataView(V.buffer),h={value:0},f=function(V,H){if(20000630!=V.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const t=V.getUint8(4),Z=V.getUint8(5),h={singleTile:!!(2&Z),longName:!!(4&Z),deepFormat:!!(8&Z),multiPart:!!(16&Z)};H.value=8;const f={};let m=!0;for(;m;){const t=J(V.buffer,H);if(t){const Z=J(V.buffer,H),h=i(V,H,Z,C(V,H));void 0===h?I.c.Warn(`Unknown header attribute type ${Z}'.`):f[t]=h}else m=!1}if(0!=(-5&Z))throw new Error("Unsupported file format");return{version:t,spec:h,...f}}(Z,h),m=await async function(V,H,t,I){const Z={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:t,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case E.NO_COMPRESSION:Z.lines=1,Z.uncompress=F;break;case E.RLE_COMPRESSION:Z.lines=1,Z.uncompress=b;break;case E.ZIPS_COMPRESSION:Z.lines=1,Z.uncompress=X,await n.f.LoadScriptAsync(l.FFLATEUrl);break;case E.ZIP_COMPRESSION:Z.lines=16,Z.uncompress=X,await n.f.LoadScriptAsync(l.FFLATEUrl);break;case E.PIZ_COMPRESSION:Z.lines=32,Z.uncompress=u;break;case E.PXR24_COMPRESSION:Z.lines=16,Z.uncompress=R,await n.f.LoadScriptAsync(l.FFLATEUrl);break;default:throw new Error(E[V.compression]+" is unsupported")}Z.scanlineBlockSize=Z.lines;const h={};for(const E of V.channels)switch(E.name){case"Y":case"R":case"G":case"B":case"A":h[E.name]=!0,Z.type=E.pixelType}let f=!1;if(h.R&&h.G&&h.B)f=!h.A,Z.outputChannels=4,Z.decodeChannels={R:0,G:1,B:2,A:3};else{if(!h.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Z.outputChannels=1,Z.decodeChannels={Y:0}}if(1===Z.type)switch(I){case P.Float:Z.getter=c,Z.inputSize=2;break;case P.HalfFloat:Z.getter=v,Z.inputSize=2}else{if(2!==Z.type)throw new Error("Unsupported pixelType "+Z.type+" for "+V.compression);switch(I){case P.Float:Z.getter=W,Z.inputSize=4;break;case P.HalfFloat:Z.getter=o,Z.inputSize=4}}Z.blockCount=Z.height/Z.scanlineBlockSize;for(let E=0;E<Z.blockCount;E++)e(H,t);const m=Z.width*Z.height*Z.outputChannels;switch(I){case P.Float:Z.byteArray=new Float32Array(m),Z.textureType=1,f&&Z.byteArray.fill(1,0,m);break;case P.HalfFloat:Z.byteArray=new Uint16Array(m),Z.textureType=2,f&&Z.byteArray.fill(15360,0,m);break;default:throw new Error("Unsupported type: "+I)}let K=0;for(const E of V.channels)void 0!==Z.decodeChannels[E.name]&&(Z.channelLineOffsets[E.name]=K*Z.width),K+=2*E.pixelType;return Z.bytesPerLine=Z.width*K,Z.outLineWidth=Z.width*Z.outputChannels,"INCREASING_Y"===V.lineOrder?Z.scanOrder=V=>V:Z.scanOrder=V=>Z.height-1-V,4==Z.outputChannels?(Z.format=5,Z.linearSpace=!0):(Z.format=6,Z.linearSpace=!1),Z}(f,Z,h,l.DefaultOutputType);!function(V,H,t,I){const Z={value:0};for(let h=0;h<V.height/V.scanlineBlockSize;h++){const f=O(t,I)-H.dataWindow.yMin;V.size=C(t,I),V.lines=f+V.scanlineBlockSize>V.height?V.height-f:V.scanlineBlockSize;const m=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):F(V);I.value+=V.size;for(let t=0;t<V.scanlineBlockSize;t++){const I=h*V.scanlineBlockSize,f=t+V.scanOrder(I);if(f>=V.height)continue;const K=t*V.bytesPerLine,E=(V.height-1-f)*V.outLineWidth;for(let t=0;t<V.channels;t++){const I=H.channels[t].name,h=V.channelLineOffsets[I],f=V.decodeChannels[I];if(void 0!==f){Z.value=K+h;for(let H=0;H<V.width;H++){const t=E+H*V.outputChannels+f;V.byteArray&&(V.byteArray[t]=V.getter(m,Z))}}}}}}(m,f,Z,h);t(f.dataWindow.xMax-f.dataWindow.xMin+1,f.dataWindow.yMax-f.dataWindow.yMin+1,H.generateMipMaps,!1,(()=>{const V=H.getEngine();H.format=f.format,H.type=m.textureType,H.invertY=!1,H._gammaSpace=!f.linearSpace,m.byteArray&&V._uploadDataToTextureDirectly(H,m.byteArray,0,0,void 0,!0)}))}}}}]);