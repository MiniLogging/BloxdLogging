"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12559:(u,G,s)=>{s.r(G),s.d(G,{_DDSTextureLoader:()=>O});var T=s(11378),z=s(11388);class O{constructor(){this.supportCascades=!0}loadCubeData(u,G,s,O){const m=G.getEngine();let f,C=!1,x=1e3;if(Array.isArray(u))for(let T=0;T<u.length;T++){const s=u[T];f=z.e.GetDDSInfo(s),G.width=f.width,G.height=f.height,C=(f.isRGB||f.isLuminance||f.mipmapCount>1)&&G.generateMipMaps,m._unpackFlipY(f.isCompressed),z.e.UploadDDSLevels(m,G,s,f,C,6,-1,T),f.isFourCC||1!==f.mipmapCount?x=f.mipmapCount-1:m.generateMipMapsForCubemap(G)}else{const O=u;f=z.e.GetDDSInfo(O),G.width=f.width,G.height=f.height,s&&(f.sphericalPolynomial=new T.h),C=(f.isRGB||f.isLuminance||f.mipmapCount>1)&&G.generateMipMaps,m._unpackFlipY(f.isCompressed),z.e.UploadDDSLevels(m,G,O,f,C,6),f.isFourCC||1!==f.mipmapCount?x=f.mipmapCount-1:m.generateMipMapsForCubemap(G,!1)}m._setCubeMapTextureParams(G,C,x),G.isReady=!0,G.onLoadedObservable.notifyObservers(G),G.onLoadedObservable.clear(),O&&O({isDDS:!0,width:G.width,info:f,data:u,texture:G})}loadData(u,G,s){const T=z.e.GetDDSInfo(u),O=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&G.generateMipMaps&&Math.max(T.width,T.height)>>T.mipmapCount-1===1;s(T.width,T.height,O,T.isFourCC,(()=>{z.e.UploadDDSLevels(G.getEngine(),G,u,T,O,1)}))}}}}]);