"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10716:(t,b,Y)=>{Y.r(b),Y.d(b,{_ExrTextureLoader:()=>k});var o=Y(1144),x=Y(1058);const F=65536,r=14,R=65537,d=16384;var E,U;!function(t){t[t.NO_COMPRESSION=0]="NO_COMPRESSION",t[t.RLE_COMPRESSION=1]="RLE_COMPRESSION",t[t.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",t[t.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",t[t.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",t[t.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(E||(E={})),function(t){t[t.INCREASING_Y=0]="INCREASING_Y",t[t.DECREASING_Y=1]="DECREASING_Y"}(U||(U={}));const C=function(){const t=new ArrayBuffer(4),b=new Float32Array(t),Y=new Uint32Array(t),o=new Uint32Array(512),x=new Uint32Array(512);for(let d=0;d<256;++d){const t=d-127;t<-27?(o[d]=0,o[256|d]=32768,x[d]=24,x[256|d]=24):t<-14?(o[d]=1024>>-t-14,o[256|d]=1024>>-t-14|32768,x[d]=-t-1,x[256|d]=-t-1):t<=15?(o[d]=t+15<<10,o[256|d]=t+15<<10|32768,x[d]=13,x[256|d]=13):t<128?(o[d]=31744,o[256|d]=64512,x[d]=24,x[256|d]=24):(o[d]=31744,o[256|d]=64512,x[d]=13,x[256|d]=13)}const F=new Uint32Array(2048),r=new Uint32Array(64),R=new Uint32Array(64);for(let d=1;d<1024;++d){let t=d<<13,b=0;for(;0===(8388608&t);)t<<=1,b-=8388608;t&=-8388609,b+=947912704,F[d]=t|b}for(let d=1024;d<2048;++d)F[d]=939524096+(d-1024<<13);for(let d=1;d<31;++d)r[d]=d<<23;r[31]=1199570944,r[32]=2147483648;for(let d=33;d<63;++d)r[d]=2147483648+(d-32<<23);r[63]=3347054592;for(let d=1;d<64;++d)32!==d&&(R[d]=1024);return{floatView:b,uint32View:Y,baseTable:o,shiftTable:x,mantissaTable:F,exponentTable:r,offsetTable:R}}();function p(t,b){const Y=new Uint8Array(t);let o=0;for(;0!=Y[b.value+o];)o+=1;const x=(new TextDecoder).decode(Y.slice(b.value,b.value+o));return b.value=b.value+o+1,x}function W(t,b){const Y=t.getInt32(b.value,!0);return b.value+=4,Y}function T(t,b){const Y=t.getUint32(b.value,!0);return b.value+=4,Y}function y(t,b){const Y=t.getUint8(b.value);return b.value+=1,Y}function v(t,b){const Y=t.getUint16(b.value,!0);return b.value+=2,Y}function B(t,b){const Y=t[b.value];return b.value+=1,Y}function J(t,b){let Y;return Y="getBigInt64"in DataView.prototype?Number(t.getBigInt64(b.value,!0)):t.getUint32(b.value+4,!0)+Number(t.getUint32(b.value,!0)<<32),b.value+=8,Y}function m(t,b){const Y=t.getFloat32(b.value,!0);return b.value+=4,Y}function K(t,b){return function(t){const b=(31744&t)>>10,Y=1023&t;return(t>>15?-1:1)*(b?31===b?Y?NaN:1/0:Math.pow(2,b-15)*(1+Y/1024):Y/1024*6103515625e-14)}(v(t,b))}function L(t,b){return function(t){if(Math.abs(t)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");t=(0,x.e)(t,-65504,65504),C.floatView[0]=t;const b=C.uint32View[0],Y=b>>23&511;return C.baseTable[Y]+((8388607&b)>>C.shiftTable[Y])}(m(t,b))}function z(t,b,Y,o){switch(Y){case"string":case"stringvector":case"iccProfile":return function(t,b,Y){const o=(new TextDecoder).decode(new Uint8Array(t).slice(b.value,b.value+Y));return b.value=b.value+Y,o}(t.buffer,b,o);case"chlist":return function(t,b,Y){const o=b.value,x=[];for(;b.value<o+Y-1;){const Y=p(t.buffer,b),o=W(t,b),F=y(t,b);b.value+=3;const r=W(t,b),R=W(t,b);x.push({name:Y,pixelType:o,pLinear:F,xSampling:r,ySampling:R})}return b.value+=1,x}(t,b,o);case"chromaticities":return function(t,b){return{redX:m(t,b),redY:m(t,b),greenX:m(t,b),greenY:m(t,b),blueX:m(t,b),blueY:m(t,b),whiteX:m(t,b),whiteY:m(t,b)}}(t,b);case"compression":return function(t,b){return y(t,b)}(t,b);case"box2i":return function(t,b){return{xMin:W(t,b),yMin:W(t,b),xMax:W(t,b),yMax:W(t,b)}}(t,b);case"lineOrder":return function(t,b){const Y=y(t,b);return U[Y]}(t,b);case"float":return m(t,b);case"v2f":return function(t,b){return[m(t,b),m(t,b)]}(t,b);case"v3f":return function(t,b){return[m(t,b),m(t,b),m(t,b)]}(t,b);case"int":return W(t,b);case"rational":return function(t,b){return[W(t,b),T(t,b)]}(t,b);case"timecode":return function(t,b){return[T(t,b),T(t,b)]}(t,b);case"preview":return b.value+=o,"skipped";default:return void(b.value+=o)}}function S(t){for(let b=1;b<t.length;b++){const Y=t[b-1]+t[b]-128;t[b]=Y}}function e(t,b){let Y=0,o=Math.floor((t.length+1)/2),x=0;const F=t.length-1;for(;!(x>F)&&(b[x++]=t[Y++],!(x>F));)b[x++]=t[o++]}function g(t,b,Y,o,x){for(;Y<t;)b=b<<8|B(o,x),Y+=8;return{l:b>>(Y-=t)&(1<<t)-1,c:b,lc:Y}}function D(t,b,Y,o){return{c:t=t<<8|B(Y,o),lc:b+=8}}function H(t,b,Y,o,x,F,r,R,d){if(t==b){if(o<8){const t=D(Y,o,x,F);Y=t.c,o=t.lc}let t=Y>>(o-=8);if(t=new Uint8Array([t])[0],R.value+t>d)return null;const b=r[R.value-1];for(;t-- >0;)r[R.value++]=b}else{if(!(R.value<d))return null;r[R.value++]=t}return{c:Y,lc:o}}const f=new Array(59);function n(t,b,Y,o,x,F){const r=b;let d=0,E=0;for(;o<=x;o++){if(r.value-b.value>Y)return;let R=g(6,d,E,t,r);const U=R.l;if(d=R.c,E=R.lc,F[o]=U,63==U){if(r.value-b.value>Y)throw new Error("Error in HufUnpackEncTable");R=g(8,d,E,t,r);let U=R.l+6;if(d=R.c,E=R.lc,o+U>x+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)F[o++]=0;o--}else if(U>=59){let t=U-59+2;if(o+t>x+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)F[o++]=0;o--}}!function(t){for(let Y=0;Y<=58;++Y)f[Y]=0;for(let Y=0;Y<R;++Y)f[t[Y]]+=1;let b=0;for(let Y=58;Y>0;--Y){const t=b+f[Y]>>1;f[Y]=b,b=t}for(let Y=0;Y<R;++Y){const b=t[Y];b>0&&(t[Y]=b|f[b]++<<6)}}(F)}function X(t){return 63&t}function Q(t){return t>>6}function N(t,b,Y,o,x,F){const E=Y.value,U=T(b,Y),C=T(b,Y);Y.value+=4;const p=T(b,Y);if(Y.value+=4,U<0||U>=R||C<0||C>=R)throw new Error("Wrong HUF_ENCSIZE");const W=new Array(R),y=new Array(d);!function(t){for(let b=0;b<d;b++)t[b]={},t[b].len=0,t[b].lit=0,t[b].p=null}(y);if(n(t,Y,o-(Y.value-E),U,C,W),p>8*(o-(Y.value-E)))throw new Error("Wrong hufUncompress");!function(t,b,Y,o){for(;b<=Y;b++){const Y=Q(t[b]),x=X(t[b]);if(Y>>x)throw new Error("Invalid table entry");if(x>r){const t=o[Y>>x-r];if(t.len)throw new Error("Invalid table entry");if(t.lit++,t.p){const b=t.p;t.p=new Array(t.lit);for(let Y=0;Y<t.lit-1;++Y)t.p[Y]=b[Y]}else t.p=new Array(1);t.p[t.lit-1]=b}else if(x){let t=0;for(let F=1<<r-x;F>0;F--){const F=o[(Y<<r-x)+t];if(F.len||F.p)throw new Error("Invalid table entry");F.len=x,F.lit=b,t++}}}}(W,U,C,y),function(t,b,Y,o,x,F,R,d,E){let U=0,C=0;const p=R,W=Math.trunc(o.value+(x+7)/8);for(;o.value<W;){let x=D(U,C,Y,o);for(U=x.c,C=x.lc;C>=r;){const R=b[U>>C-r&16383];if(R.len){C-=R.len;const t=H(R.lit,F,U,C,Y,o,d,E,p);t&&(U=t.c,C=t.lc)}else{if(!R.p)throw new Error("hufDecode issues");let b;for(b=0;b<R.lit;b++){const r=X(t[R.p[b]]);for(;C<r&&o.value<W;)x=D(U,C,Y,o),U=x.c,C=x.lc;if(C>=r&&Q(t[R.p[b]])==(U>>C-r&(1<<r)-1)){C-=r;const t=H(R.p[b],F,U,C,Y,o,d,E,p);t&&(U=t.c,C=t.lc);break}}if(b==R.lit)throw new Error("HufDecode issues")}}}const T=8-x&7;for(U>>=T,C-=T;C>0;){const t=b[U<<r-C&16383];if(!t.len)throw new Error("HufDecode issues");{C-=t.len;const b=H(t.lit,F,U,C,Y,o,d,E,p);b&&(U=b.c,C=b.lc)}}}(W,y,t,Y,p,C,F,x,{value:0})}function u(t){return 65535&t}function Z(t){const b=u(t);return b>32767?b-65536:b}function a(t,b){const Y=Z(t),o=Z(b),x=Y+(1&o)+(o>>1);return{a:x,b:x-o}}function A(t,b){const Y=u(t),o=u(b),x=Y-(o>>1)&65535;return{a:o+x-32768&65535,b:x}}function M(t,b,Y,o,x,F,r){const R=r<16384,d=Y>x?x:Y;let E,U,C=1;for(;C<=d;)C<<=1;for(C>>=1,E=C,C>>=1;C>=1;){U=0;const r=U+F*(x-E),d=F*C,p=F*E,W=o*C,T=o*E;let y,v,B,J;for(;U<=r;U+=p){let x=U;const F=U+o*(Y-E);for(;x<=F;x+=T){const Y=x+W,o=x+d,F=o+W;if(R){let r=a(t[x+b],t[o+b]);y=r.a,B=r.b,r=a(t[Y+b],t[F+b]),v=r.a,J=r.b,r=a(y,v),t[x+b]=r.a,t[Y+b]=r.b,r=a(B,J),t[o+b]=r.a,t[F+b]=r.b}else{let r=A(t[x+b],t[o+b]);y=r.a,B=r.b,r=A(t[Y+b],t[F+b]),v=r.a,J=r.b,r=A(y,v),t[x+b]=r.a,t[Y+b]=r.b,r=A(B,J),t[o+b]=r.a,t[F+b]=r.b}}if(Y&C){const Y=x+d;let o;o=R?a(t[x+b],t[Y+b]):A(t[x+b],t[Y+b]),y=o.a,t[Y+b]=o.b,t[x+b]=y}}if(x&C){let x=U;const F=U+o*(Y-E);for(;x<=F;x+=T){const Y=x+W;let o;o=R?a(t[x+b],t[Y+b]):A(t[x+b],t[Y+b]),y=o.a,t[Y+b]=o.b,t[x+b]=y}}E=C,C>>=1}return U}function w(t){return new DataView(t.array.buffer,t.offset.value,t.size)}function c(t){const b=t.viewer.buffer.slice(t.offset.value,t.offset.value+t.size),Y=new Uint8Array(function(t){let b=t.byteLength;const Y=new Array;let o=0;const x=new DataView(t);for(;b>0;){const t=x.getInt8(o++);if(t<0){const F=-t;b-=F+1;for(let t=0;t<F;t++)Y.push(x.getUint8(o++))}else{const F=t;b-=2;const r=x.getUint8(o++);for(let t=0;t<F+1;t++)Y.push(r)}}return Y}(b)),o=new Uint8Array(Y.length);return S(Y),e(Y,o),new DataView(o.buffer)}function I(t){const b=t.array.slice(t.offset.value,t.offset.value+t.size),Y=fflate.unzlibSync(b),o=new Uint8Array(Y.length);return S(Y),e(Y,o),new DataView(o.buffer)}function s(t){const b=t.array.slice(t.offset.value,t.offset.value+t.size),Y=fflate.unzlibSync(b),o=t.lines*t.channels*t.width,x=1==t.type?new Uint16Array(o):new Uint32Array(o);let F=0,r=0;const R=new Array(4);for(let d=0;d<t.lines;d++)for(let b=0;b<t.channels;b++){let b=0;switch(t.type){case 1:R[0]=F,R[1]=R[0]+t.width,F=R[1]+t.width;for(let o=0;o<t.width;++o){b+=Y[R[0]++]<<8|Y[R[1]++],x[r]=b,r++}break;case 2:R[0]=F,R[1]=R[0]+t.width,R[2]=R[1]+t.width,F=R[2]+t.width;for(let o=0;o<t.width;++o){b+=Y[R[0]++]<<24|Y[R[1]++]<<16|Y[R[2]++]<<8,x[r]=b,r++}}}return new DataView(x.buffer)}function l(t){const b=t.viewer,Y={value:t.offset.value},o=new Uint16Array(t.width*t.scanlineBlockSize*(t.channels*t.type)),x=new Uint8Array(8192);let r=0;const R=new Array(t.channels);for(let F=0;F<t.channels;F++)R[F]={},R[F].start=r,R[F].end=R[F].start,R[F].nx=t.width,R[F].ny=t.lines,R[F].size=t.type,r+=R[F].nx*R[F].ny*R[F].size;const d=v(b,Y),E=v(b,Y);if(E>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(d<=E)for(let F=0;F<E-d+1;F++)x[F+d]=y(b,Y);const U=new Uint16Array(F),C=function(t,b){let Y=0;for(let x=0;x<F;++x)(0==x||t[x>>3]&1<<(7&x))&&(b[Y++]=x);const o=Y-1;for(;Y<F;)b[Y++]=0;return o}(x,U),p=T(b,Y);N(t.array,b,Y,p,o,r);for(let F=0;F<t.channels;++F){const t=R[F];for(let b=0;b<R[F].size;++b)M(o,t.start+b,t.nx,t.size,t.ny,t.nx*t.size,C)}!function(t,b,Y){for(let o=0;o<Y;++o)b[o]=t[b[o]]}(U,o,r);let W=0;const B=new Uint8Array(o.buffer.byteLength);for(let F=0;F<t.lines;F++)for(let b=0;b<t.channels;b++){const t=R[b],Y=t.nx*t.size,x=new Uint8Array(o.buffer,2*t.end,2*Y);B.set(x,W),W+=2*Y,t.end+=Y}return new DataView(B.buffer)}var i,V=Y(1265);!function(t){t[t.Float=0]="Float",t[t.HalfFloat=1]="HalfFloat"}(i||(i={}));class P{}P.DefaultOutputType=i.HalfFloat,P.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class k{constructor(){this.supportCascades=!1}loadCubeData(t,b,Y,o,x){throw".exr not supported in Cube."}async loadData(t,b,Y){const x=new DataView(t.buffer),F={value:0},r=function(t,b){if(20000630!=t.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Y=t.getUint8(4),x=t.getUint8(5),F={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};b.value=8;const r={};let R=!0;for(;R;){const Y=p(t.buffer,b);if(Y){const x=p(t.buffer,b),F=z(t,b,x,T(t,b));void 0===F?o.b.Warn(`Unknown header attribute type ${x}'.`):r[Y]=F}else R=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:Y,spec:F,...r}}(x,F),R=await async function(t,b,Y,o){const x={size:0,viewer:b,array:new Uint8Array(b.buffer),offset:Y,width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,channels:t.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(t.compression){case E.NO_COMPRESSION:x.lines=1,x.uncompress=w;break;case E.RLE_COMPRESSION:x.lines=1,x.uncompress=c;break;case E.ZIPS_COMPRESSION:x.lines=1,x.uncompress=I,await V.f.LoadScriptAsync(P.FFLATEUrl);break;case E.ZIP_COMPRESSION:x.lines=16,x.uncompress=I,await V.f.LoadScriptAsync(P.FFLATEUrl);break;case E.PIZ_COMPRESSION:x.lines=32,x.uncompress=l;break;case E.PXR24_COMPRESSION:x.lines=16,x.uncompress=s,await V.f.LoadScriptAsync(P.FFLATEUrl);break;default:throw new Error(E[t.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const F={};for(const E of t.channels)switch(E.name){case"Y":case"R":case"G":case"B":case"A":F[E.name]=!0,x.type=E.pixelType}let r=!1;if(F.R&&F.G&&F.B)r=!F.A,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else{if(!F.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(o){case i.Float:x.getter=K,x.inputSize=2;break;case i.HalfFloat:x.getter=v,x.inputSize=2}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+t.compression);switch(o){case i.Float:x.getter=m,x.inputSize=4;break;case i.HalfFloat:x.getter=L,x.inputSize=4}}x.blockCount=x.height/x.scanlineBlockSize;for(let E=0;E<x.blockCount;E++)J(b,Y);const R=x.width*x.height*x.outputChannels;switch(o){case i.Float:x.byteArray=new Float32Array(R),x.textureType=1,r&&x.byteArray.fill(1,0,R);break;case i.HalfFloat:x.byteArray=new Uint16Array(R),x.textureType=2,r&&x.byteArray.fill(15360,0,R);break;default:throw new Error("Unsupported type: "+o)}let d=0;for(const E of t.channels)void 0!==x.decodeChannels[E.name]&&(x.channelLineOffsets[E.name]=d*x.width),d+=2*E.pixelType;return x.bytesPerLine=x.width*d,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===t.lineOrder?x.scanOrder=t=>t:x.scanOrder=t=>x.height-1-t,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}(r,x,F,P.DefaultOutputType);!function(t,b,Y,o){const x={value:0};for(let F=0;F<t.height/t.scanlineBlockSize;F++){const r=W(Y,o)-b.dataWindow.yMin;t.size=T(Y,o),t.lines=r+t.scanlineBlockSize>t.height?t.height-r:t.scanlineBlockSize;const R=t.size<t.lines*t.bytesPerLine&&t.uncompress?t.uncompress(t):w(t);o.value+=t.size;for(let Y=0;Y<t.scanlineBlockSize;Y++){const o=F*t.scanlineBlockSize,r=Y+t.scanOrder(o);if(r>=t.height)continue;const d=Y*t.bytesPerLine,E=(t.height-1-r)*t.outLineWidth;for(let Y=0;Y<t.channels;Y++){const o=b.channels[Y].name,F=t.channelLineOffsets[o],r=t.decodeChannels[o];if(void 0!==r){x.value=d+F;for(let b=0;b<t.width;b++){const Y=E+b*t.outputChannels+r;t.byteArray&&(t.byteArray[Y]=t.getter(R,x))}}}}}}(R,r,x,F);Y(r.dataWindow.xMax-r.dataWindow.xMin+1,r.dataWindow.yMax-r.dataWindow.yMin+1,b.generateMipMaps,!1,(()=>{const t=b.getEngine();b.format=r.format,b.type=R.textureType,b.invertY=!1,b._gammaSpace=!r.linearSpace,R.byteArray&&t._uploadDataToTextureDirectly(b,R.byteArray,0,0,void 0,!0)}))}}}}]);