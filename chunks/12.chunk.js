"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10356:(G,D,N)=>{N.r(D),N.d(D,{_ExrTextureLoader:()=>k});var T=N(1105),o=N(1038);const Z=65536,n=14,C=65537,P=16384;var r,v;!function(G){G[G.NO_COMPRESSION=0]="NO_COMPRESSION",G[G.RLE_COMPRESSION=1]="RLE_COMPRESSION",G[G.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",G[G.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",G[G.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",G[G.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(r||(r={})),function(G){G[G.INCREASING_Y=0]="INCREASING_Y",G[G.DECREASING_Y=1]="DECREASING_Y"}(v||(v={}));const q=function(){const G=new ArrayBuffer(4),D=new Float32Array(G),N=new Uint32Array(G),T=new Uint32Array(512),o=new Uint32Array(512);for(let P=0;P<256;++P){const G=P-127;G<-27?(T[P]=0,T[256|P]=32768,o[P]=24,o[256|P]=24):G<-14?(T[P]=1024>>-G-14,T[256|P]=1024>>-G-14|32768,o[P]=-G-1,o[256|P]=-G-1):G<=15?(T[P]=G+15<<10,T[256|P]=G+15<<10|32768,o[P]=13,o[256|P]=13):G<128?(T[P]=31744,T[256|P]=64512,o[P]=24,o[256|P]=24):(T[P]=31744,T[256|P]=64512,o[P]=13,o[256|P]=13)}const Z=new Uint32Array(2048),n=new Uint32Array(64),C=new Uint32Array(64);for(let P=1;P<1024;++P){let G=P<<13,D=0;for(;0===(8388608&G);)G<<=1,D-=8388608;G&=-8388609,D+=947912704,Z[P]=G|D}for(let P=1024;P<2048;++P)Z[P]=939524096+(P-1024<<13);for(let P=1;P<31;++P)n[P]=P<<23;n[31]=1199570944,n[32]=2147483648;for(let P=33;P<63;++P)n[P]=2147483648+(P-32<<23);n[63]=3347054592;for(let P=1;P<64;++P)32!==P&&(C[P]=1024);return{floatView:D,uint32View:N,baseTable:T,shiftTable:o,mantissaTable:Z,exponentTable:n,offsetTable:C}}();function g(G,D){const N=new Uint8Array(G);let T=0;for(;0!=N[D.value+T];)T+=1;const o=(new TextDecoder).decode(N.slice(D.value,D.value+T));return D.value=D.value+T+1,o}function X(G,D){const N=G.getInt32(D.value,!0);return D.value+=4,N}function W(G,D){const N=G.getUint32(D.value,!0);return D.value+=4,N}function j(G,D){const N=G.getUint8(D.value);return D.value+=1,N}function Y(G,D){const N=G.getUint16(D.value,!0);return D.value+=2,N}function y(G,D){const N=G[D.value];return D.value+=1,N}function h(G,D){let N;return N="getBigInt64"in DataView.prototype?Number(G.getBigInt64(D.value,!0)):G.getUint32(D.value+4,!0)+Number(G.getUint32(D.value,!0)<<32),D.value+=8,N}function m(G,D){const N=G.getFloat32(D.value,!0);return D.value+=4,N}function R(G,D){return function(G){const D=(31744&G)>>10,N=1023&G;return(G>>15?-1:1)*(D?31===D?N?NaN:1/0:Math.pow(2,D-15)*(1+N/1024):N/1024*6103515625e-14)}(Y(G,D))}function L(G,D){return function(G){if(Math.abs(G)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");G=(0,o.e)(G,-65504,65504),q.floatView[0]=G;const D=q.uint32View[0],N=D>>23&511;return q.baseTable[N]+((8388607&D)>>q.shiftTable[N])}(m(G,D))}function w(G,D,N,T){switch(N){case"string":case"stringvector":case"iccProfile":return function(G,D,N){const T=(new TextDecoder).decode(new Uint8Array(G).slice(D.value,D.value+N));return D.value=D.value+N,T}(G.buffer,D,T);case"chlist":return function(G,D,N){const T=D.value,o=[];for(;D.value<T+N-1;){const N=g(G.buffer,D),T=X(G,D),Z=j(G,D);D.value+=3;const n=X(G,D),C=X(G,D);o.push({name:N,pixelType:T,pLinear:Z,xSampling:n,ySampling:C})}return D.value+=1,o}(G,D,T);case"chromaticities":return function(G,D){return{redX:m(G,D),redY:m(G,D),greenX:m(G,D),greenY:m(G,D),blueX:m(G,D),blueY:m(G,D),whiteX:m(G,D),whiteY:m(G,D)}}(G,D);case"compression":return function(G,D){return j(G,D)}(G,D);case"box2i":return function(G,D){return{xMin:X(G,D),yMin:X(G,D),xMax:X(G,D),yMax:X(G,D)}}(G,D);case"lineOrder":return function(G,D){const N=j(G,D);return v[N]}(G,D);case"float":return m(G,D);case"v2f":return function(G,D){return[m(G,D),m(G,D)]}(G,D);case"v3f":return function(G,D){return[m(G,D),m(G,D),m(G,D)]}(G,D);case"int":return X(G,D);case"rational":return function(G,D){return[X(G,D),W(G,D)]}(G,D);case"timecode":return function(G,D){return[W(G,D),W(G,D)]}(G,D);case"preview":return D.value+=T,"skipped";default:return void(D.value+=T)}}function B(G){for(let D=1;D<G.length;D++){const N=G[D-1]+G[D]-128;G[D]=N}}function F(G,D){let N=0,T=Math.floor((G.length+1)/2),o=0;const Z=G.length-1;for(;!(o>Z)&&(D[o++]=G[N++],!(o>Z));)D[o++]=G[T++]}function S(G,D,N,T,o){for(;N<G;)D=D<<8|y(T,o),N+=8;return{l:D>>(N-=G)&(1<<G)-1,c:D,lc:N}}function V(G,D,N,T){return{c:G=G<<8|y(N,T),lc:D+=8}}function U(G,D,N,T,o,Z,n,C,P){if(G==D){if(T<8){const G=V(N,T,o,Z);N=G.c,T=G.lc}let G=N>>(T-=8);if(G=new Uint8Array([G])[0],C.value+G>P)return null;const D=n[C.value-1];for(;G-- >0;)n[C.value++]=D}else{if(!(C.value<P))return null;n[C.value++]=G}return{c:N,lc:T}}const z=new Array(59);function i(G,D,N,T,o,Z){const n=D;let P=0,r=0;for(;T<=o;T++){if(n.value-D.value>N)return;let C=S(6,P,r,G,n);const v=C.l;if(P=C.c,r=C.lc,Z[T]=v,63==v){if(n.value-D.value>N)throw new Error("Error in HufUnpackEncTable");C=S(8,P,r,G,n);let v=C.l+6;if(P=C.c,r=C.lc,T+v>o+1)throw new Error("Error in HufUnpackEncTable");for(;v--;)Z[T++]=0;T--}else if(v>=59){let G=v-59+2;if(T+G>o+1)throw new Error("Error in HufUnpackEncTable");for(;G--;)Z[T++]=0;T--}}!function(G){for(let N=0;N<=58;++N)z[N]=0;for(let N=0;N<C;++N)z[G[N]]+=1;let D=0;for(let N=58;N>0;--N){const G=D+z[N]>>1;z[N]=D,D=G}for(let N=0;N<C;++N){const D=G[N];D>0&&(G[N]=D|z[D]++<<6)}}(Z)}function J(G){return 63&G}function p(G){return G>>6}function t(G,D,N,T,o,Z){const r=N.value,v=W(D,N),q=W(D,N);N.value+=4;const g=W(D,N);if(N.value+=4,v<0||v>=C||q<0||q>=C)throw new Error("Wrong HUF_ENCSIZE");const X=new Array(C),j=new Array(P);!function(G){for(let D=0;D<P;D++)G[D]={},G[D].len=0,G[D].lit=0,G[D].p=null}(j);if(i(G,N,T-(N.value-r),v,q,X),g>8*(T-(N.value-r)))throw new Error("Wrong hufUncompress");!function(G,D,N,T){for(;D<=N;D++){const N=p(G[D]),o=J(G[D]);if(N>>o)throw new Error("Invalid table entry");if(o>n){const G=T[N>>o-n];if(G.len)throw new Error("Invalid table entry");if(G.lit++,G.p){const D=G.p;G.p=new Array(G.lit);for(let N=0;N<G.lit-1;++N)G.p[N]=D[N]}else G.p=new Array(1);G.p[G.lit-1]=D}else if(o){let G=0;for(let Z=1<<n-o;Z>0;Z--){const Z=T[(N<<n-o)+G];if(Z.len||Z.p)throw new Error("Invalid table entry");Z.len=o,Z.lit=D,G++}}}}(X,v,q,j),function(G,D,N,T,o,Z,C,P,r){let v=0,q=0;const g=C,X=Math.trunc(T.value+(o+7)/8);for(;T.value<X;){let o=V(v,q,N,T);for(v=o.c,q=o.lc;q>=n;){const C=D[v>>q-n&16383];if(C.len){q-=C.len;const G=U(C.lit,Z,v,q,N,T,P,r,g);G&&(v=G.c,q=G.lc)}else{if(!C.p)throw new Error("hufDecode issues");let D;for(D=0;D<C.lit;D++){const n=J(G[C.p[D]]);for(;q<n&&T.value<X;)o=V(v,q,N,T),v=o.c,q=o.lc;if(q>=n&&p(G[C.p[D]])==(v>>q-n&(1<<n)-1)){q-=n;const G=U(C.p[D],Z,v,q,N,T,P,r,g);G&&(v=G.c,q=G.lc);break}}if(D==C.lit)throw new Error("HufDecode issues")}}}const W=8-o&7;for(v>>=W,q-=W;q>0;){const G=D[v<<n-q&16383];if(!G.len)throw new Error("HufDecode issues");{q-=G.len;const D=U(G.lit,Z,v,q,N,T,P,r,g);D&&(v=D.c,q=D.lc)}}}(X,j,G,N,g,q,Z,o,{value:0})}function H(G){return 65535&G}function s(G){const D=H(G);return D>32767?D-65536:D}function c(G,D){const N=s(G),T=s(D),o=N+(1&T)+(T>>1);return{a:o,b:o-T}}function K(G,D){const N=H(G),T=H(D),o=N-(T>>1)&65535;return{a:T+o-32768&65535,b:o}}function b(G,D,N,T,o,Z,n){const C=n<16384,P=N>o?o:N;let r,v,q=1;for(;q<=P;)q<<=1;for(q>>=1,r=q,q>>=1;q>=1;){v=0;const n=v+Z*(o-r),P=Z*q,g=Z*r,X=T*q,W=T*r;let j,Y,y,h;for(;v<=n;v+=g){let o=v;const Z=v+T*(N-r);for(;o<=Z;o+=W){const N=o+X,T=o+P,Z=T+X;if(C){let n=c(G[o+D],G[T+D]);j=n.a,y=n.b,n=c(G[N+D],G[Z+D]),Y=n.a,h=n.b,n=c(j,Y),G[o+D]=n.a,G[N+D]=n.b,n=c(y,h),G[T+D]=n.a,G[Z+D]=n.b}else{let n=K(G[o+D],G[T+D]);j=n.a,y=n.b,n=K(G[N+D],G[Z+D]),Y=n.a,h=n.b,n=K(j,Y),G[o+D]=n.a,G[N+D]=n.b,n=K(y,h),G[T+D]=n.a,G[Z+D]=n.b}}if(N&q){const N=o+P;let T;T=C?c(G[o+D],G[N+D]):K(G[o+D],G[N+D]),j=T.a,G[N+D]=T.b,G[o+D]=j}}if(o&q){let o=v;const Z=v+T*(N-r);for(;o<=Z;o+=W){const N=o+X;let T;T=C?c(G[o+D],G[N+D]):K(G[o+D],G[N+D]),j=T.a,G[N+D]=T.b,G[o+D]=j}}r=q,q>>=1}return v}function O(G){return new DataView(G.array.buffer,G.offset.value,G.size)}function Q(G){const D=G.viewer.buffer.slice(G.offset.value,G.offset.value+G.size),N=new Uint8Array(function(G){let D=G.byteLength;const N=new Array;let T=0;const o=new DataView(G);for(;D>0;){const G=o.getInt8(T++);if(G<0){const Z=-G;D-=Z+1;for(let G=0;G<Z;G++)N.push(o.getUint8(T++))}else{const Z=G;D-=2;const n=o.getUint8(T++);for(let G=0;G<Z+1;G++)N.push(n)}}return N}(D)),T=new Uint8Array(N.length);return B(N),F(N,T),new DataView(T.buffer)}function A(G){const D=G.array.slice(G.offset.value,G.offset.value+G.size),N=fflate.unzlibSync(D),T=new Uint8Array(N.length);return B(N),F(N,T),new DataView(T.buffer)}function I(G){const D=G.array.slice(G.offset.value,G.offset.value+G.size),N=fflate.unzlibSync(D),T=G.lines*G.channels*G.width,o=1==G.type?new Uint16Array(T):new Uint32Array(T);let Z=0,n=0;const C=new Array(4);for(let P=0;P<G.lines;P++)for(let D=0;D<G.channels;D++){let D=0;switch(G.type){case 1:C[0]=Z,C[1]=C[0]+G.width,Z=C[1]+G.width;for(let T=0;T<G.width;++T){D+=N[C[0]++]<<8|N[C[1]++],o[n]=D,n++}break;case 2:C[0]=Z,C[1]=C[0]+G.width,C[2]=C[1]+G.width,Z=C[2]+G.width;for(let T=0;T<G.width;++T){D+=N[C[0]++]<<24|N[C[1]++]<<16|N[C[2]++]<<8,o[n]=D,n++}}}return new DataView(o.buffer)}function d(G){const D=G.viewer,N={value:G.offset.value},T=new Uint16Array(G.width*G.scanlineBlockSize*(G.channels*G.type)),o=new Uint8Array(8192);let n=0;const C=new Array(G.channels);for(let Z=0;Z<G.channels;Z++)C[Z]={},C[Z].start=n,C[Z].end=C[Z].start,C[Z].nx=G.width,C[Z].ny=G.lines,C[Z].size=G.type,n+=C[Z].nx*C[Z].ny*C[Z].size;const P=Y(D,N),r=Y(D,N);if(r>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(P<=r)for(let Z=0;Z<r-P+1;Z++)o[Z+P]=j(D,N);const v=new Uint16Array(Z),q=function(G,D){let N=0;for(let o=0;o<Z;++o)(0==o||G[o>>3]&1<<(7&o))&&(D[N++]=o);const T=N-1;for(;N<Z;)D[N++]=0;return T}(o,v),g=W(D,N);t(G.array,D,N,g,T,n);for(let Z=0;Z<G.channels;++Z){const G=C[Z];for(let D=0;D<C[Z].size;++D)b(T,G.start+D,G.nx,G.size,G.ny,G.nx*G.size,q)}!function(G,D,N){for(let T=0;T<N;++T)D[T]=G[D[T]]}(v,T,n);let X=0;const y=new Uint8Array(T.buffer.byteLength);for(let Z=0;Z<G.lines;Z++)for(let D=0;D<G.channels;D++){const G=C[D],N=G.nx*G.size,o=new Uint8Array(T.buffer,2*G.end,2*N);y.set(o,X),X+=2*N,G.end+=N}return new DataView(y.buffer)}var u,l=N(1223);!function(G){G[G.Float=0]="Float",G[G.HalfFloat=1]="HalfFloat"}(u||(u={}));class x{}x.DefaultOutputType=u.HalfFloat,x.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class k{constructor(){this.supportCascades=!1}loadCubeData(G,D,N,T,o){throw".exr not supported in Cube."}async loadData(G,D,N){const o=new DataView(G.buffer),Z={value:0},n=function(G,D){if(20000630!=G.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const N=G.getUint8(4),o=G.getUint8(5),Z={singleTile:!!(2&o),longName:!!(4&o),deepFormat:!!(8&o),multiPart:!!(16&o)};D.value=8;const n={};let C=!0;for(;C;){const N=g(G.buffer,D);if(N){const o=g(G.buffer,D),Z=w(G,D,o,W(G,D));void 0===Z?T.d.Warn(`Unknown header attribute type ${o}'.`):n[N]=Z}else C=!1}if(0!=(-5&o))throw new Error("Unsupported file format");return{version:N,spec:Z,...n}}(o,Z),C=await async function(G,D,N,T){const o={size:0,viewer:D,array:new Uint8Array(D.buffer),offset:N,width:G.dataWindow.xMax-G.dataWindow.xMin+1,height:G.dataWindow.yMax-G.dataWindow.yMin+1,channels:G.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(G.compression){case r.NO_COMPRESSION:o.lines=1,o.uncompress=O;break;case r.RLE_COMPRESSION:o.lines=1,o.uncompress=Q;break;case r.ZIPS_COMPRESSION:o.lines=1,o.uncompress=A,await l.f.LoadScriptAsync(x.FFLATEUrl);break;case r.ZIP_COMPRESSION:o.lines=16,o.uncompress=A,await l.f.LoadScriptAsync(x.FFLATEUrl);break;case r.PIZ_COMPRESSION:o.lines=32,o.uncompress=d;break;case r.PXR24_COMPRESSION:o.lines=16,o.uncompress=I,await l.f.LoadScriptAsync(x.FFLATEUrl);break;default:throw new Error(r[G.compression]+" is unsupported")}o.scanlineBlockSize=o.lines;const Z={};for(const r of G.channels)switch(r.name){case"Y":case"R":case"G":case"B":case"A":Z[r.name]=!0,o.type=r.pixelType}let n=!1;if(Z.R&&Z.G&&Z.B)n=!Z.A,o.outputChannels=4,o.decodeChannels={R:0,G:1,B:2,A:3};else{if(!Z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");o.outputChannels=1,o.decodeChannels={Y:0}}if(1===o.type)switch(T){case u.Float:o.getter=R,o.inputSize=2;break;case u.HalfFloat:o.getter=Y,o.inputSize=2}else{if(2!==o.type)throw new Error("Unsupported pixelType "+o.type+" for "+G.compression);switch(T){case u.Float:o.getter=m,o.inputSize=4;break;case u.HalfFloat:o.getter=L,o.inputSize=4}}o.blockCount=o.height/o.scanlineBlockSize;for(let r=0;r<o.blockCount;r++)h(D,N);const C=o.width*o.height*o.outputChannels;switch(T){case u.Float:o.byteArray=new Float32Array(C),o.textureType=1,n&&o.byteArray.fill(1,0,C);break;case u.HalfFloat:o.byteArray=new Uint16Array(C),o.textureType=2,n&&o.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+T)}let P=0;for(const r of G.channels)void 0!==o.decodeChannels[r.name]&&(o.channelLineOffsets[r.name]=P*o.width),P+=2*r.pixelType;return o.bytesPerLine=o.width*P,o.outLineWidth=o.width*o.outputChannels,"INCREASING_Y"===G.lineOrder?o.scanOrder=G=>G:o.scanOrder=G=>o.height-1-G,4==o.outputChannels?(o.format=5,o.linearSpace=!0):(o.format=6,o.linearSpace=!1),o}(n,o,Z,x.DefaultOutputType);!function(G,D,N,T){const o={value:0};for(let Z=0;Z<G.height/G.scanlineBlockSize;Z++){const n=X(N,T)-D.dataWindow.yMin;G.size=W(N,T),G.lines=n+G.scanlineBlockSize>G.height?G.height-n:G.scanlineBlockSize;const C=G.size<G.lines*G.bytesPerLine&&G.uncompress?G.uncompress(G):O(G);T.value+=G.size;for(let N=0;N<G.scanlineBlockSize;N++){const T=Z*G.scanlineBlockSize,n=N+G.scanOrder(T);if(n>=G.height)continue;const P=N*G.bytesPerLine,r=(G.height-1-n)*G.outLineWidth;for(let N=0;N<G.channels;N++){const T=D.channels[N].name,Z=G.channelLineOffsets[T],n=G.decodeChannels[T];if(void 0!==n){o.value=P+Z;for(let D=0;D<G.width;D++){const N=r+D*G.outputChannels+n;G.byteArray&&(G.byteArray[N]=G.getter(C,o))}}}}}}(C,n,o,Z);N(n.dataWindow.xMax-n.dataWindow.xMin+1,n.dataWindow.yMax-n.dataWindow.yMin+1,D.generateMipMaps,!1,(()=>{const G=D.getEngine();D.format=n.format,D.type=C.textureType,D.invertY=!1,D._gammaSpace=!n.linearSpace,C.byteArray&&G._uploadDataToTextureDirectly(D,C.byteArray,0,0,void 0,!0)}))}}}}]);