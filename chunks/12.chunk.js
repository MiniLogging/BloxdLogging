"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{13006:(H,p,V)=>{V.r(p),V.d(p,{_DDSTextureLoader:()=>E});var c=V(11563),C=V(11575);class E{constructor(){this.supportCascades=!0}loadCubeData(H,p,V,E){const z=p.getEngine();let w,t=!1,Q=1e3;if(Array.isArray(H))for(let c=0;c<H.length;c++){const V=H[c];w=C.d.GetDDSInfo(V),p.width=w.width,p.height=w.height,t=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&p.generateMipMaps,z._unpackFlipY(w.isCompressed),C.d.UploadDDSLevels(z,p,V,w,t,6,-1,c),w.isFourCC||1!==w.mipmapCount?Q=w.mipmapCount-1:z.generateMipMapsForCubemap(p)}else{const E=H;w=C.d.GetDDSInfo(E),p.width=w.width,p.height=w.height,V&&(w.sphericalPolynomial=new c.g),t=(w.isRGB||w.isLuminance||w.mipmapCount>1)&&p.generateMipMaps,z._unpackFlipY(w.isCompressed),C.d.UploadDDSLevels(z,p,E,w,t,6),w.isFourCC||1!==w.mipmapCount?Q=w.mipmapCount-1:z.generateMipMapsForCubemap(p,!1)}z._setCubeMapTextureParams(p,t,Q),p.isReady=!0,p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),E&&E({isDDS:!0,width:p.width,info:w,data:H,texture:p})}loadData(H,p,V){const c=C.d.GetDDSInfo(H),E=(c.isRGB||c.isLuminance||c.mipmapCount>1)&&p.generateMipMaps&&Math.max(c.width,c.height)>>c.mipmapCount-1===1;V(c.width,c.height,E,c.isFourCC,(()=>{C.d.UploadDDSLevels(p.getEngine(),p,H,c,E,1)}))}}}}]);