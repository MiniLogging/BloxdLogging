"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10884:(Q,z,I)=>{I.r(z),I.d(z,{_ExrTextureLoader:()=>L});var P=I(1066),w=I(1015);const T=65536,A=14,e=65537,m=16384;var f,j;!function(Q){Q[Q.NO_COMPRESSION=0]="NO_COMPRESSION",Q[Q.RLE_COMPRESSION=1]="RLE_COMPRESSION",Q[Q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Q[Q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Q[Q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Q[Q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(f||(f={})),function(Q){Q[Q.INCREASING_Y=0]="INCREASING_Y",Q[Q.DECREASING_Y=1]="DECREASING_Y"}(j||(j={}));const D=function(){const Q=new ArrayBuffer(4),z=new Float32Array(Q),I=new Uint32Array(Q),P=new Uint32Array(512),w=new Uint32Array(512);for(let m=0;m<256;++m){const Q=m-127;Q<-27?(P[m]=0,P[256|m]=32768,w[m]=24,w[256|m]=24):Q<-14?(P[m]=1024>>-Q-14,P[256|m]=1024>>-Q-14|32768,w[m]=-Q-1,w[256|m]=-Q-1):Q<=15?(P[m]=Q+15<<10,P[256|m]=Q+15<<10|32768,w[m]=13,w[256|m]=13):Q<128?(P[m]=31744,P[256|m]=64512,w[m]=24,w[256|m]=24):(P[m]=31744,P[256|m]=64512,w[m]=13,w[256|m]=13)}const T=new Uint32Array(2048),A=new Uint32Array(64),e=new Uint32Array(64);for(let m=1;m<1024;++m){let Q=m<<13,z=0;for(;0===(8388608&Q);)Q<<=1,z-=8388608;Q&=-8388609,z+=947912704,T[m]=Q|z}for(let m=1024;m<2048;++m)T[m]=939524096+(m-1024<<13);for(let m=1;m<31;++m)A[m]=m<<23;A[31]=1199570944,A[32]=2147483648;for(let m=33;m<63;++m)A[m]=2147483648+(m-32<<23);A[63]=3347054592;for(let m=1;m<64;++m)32!==m&&(e[m]=1024);return{floatView:z,uint32View:I,baseTable:P,shiftTable:w,mantissaTable:T,exponentTable:A,offsetTable:e}}();function k(Q,z){const I=new Uint8Array(Q);let P=0;for(;0!=I[z.value+P];)P+=1;const w=(new TextDecoder).decode(I.slice(z.value,z.value+P));return z.value=z.value+P+1,w}function s(Q,z){const I=Q.getInt32(z.value,!0);return z.value+=4,I}function J(Q,z){const I=Q.getUint32(z.value,!0);return z.value+=4,I}function l(Q,z){const I=Q.getUint8(z.value);return z.value+=1,I}function X(Q,z){const I=Q.getUint16(z.value,!0);return z.value+=2,I}function n(Q,z){const I=Q[z.value];return z.value+=1,I}function d(Q,z){let I;return I="getBigInt64"in DataView.prototype?Number(Q.getBigInt64(z.value,!0)):Q.getUint32(z.value+4,!0)+Number(Q.getUint32(z.value,!0)<<32),z.value+=8,I}function K(Q,z){const I=Q.getFloat32(z.value,!0);return z.value+=4,I}function N(Q,z){return function(Q){const z=(31744&Q)>>10,I=1023&Q;return(Q>>15?-1:1)*(z?31===z?I?NaN:1/0:Math.pow(2,z-15)*(1+I/1024):I/1024*6103515625e-14)}(X(Q,z))}function q(Q,z){return function(Q){if(Math.abs(Q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Q=(0,w.b)(Q,-65504,65504),D.floatView[0]=Q;const z=D.uint32View[0],I=z>>23&511;return D.baseTable[I]+((8388607&z)>>D.shiftTable[I])}(K(Q,z))}function c(Q,z,I,P){switch(I){case"string":case"stringvector":case"iccProfile":return function(Q,z,I){const P=(new TextDecoder).decode(new Uint8Array(Q).slice(z.value,z.value+I));return z.value=z.value+I,P}(Q.buffer,z,P);case"chlist":return function(Q,z,I){const P=z.value,w=[];for(;z.value<P+I-1;){const I=k(Q.buffer,z),P=s(Q,z),T=l(Q,z);z.value+=3;const A=s(Q,z),e=s(Q,z);w.push({name:I,pixelType:P,pLinear:T,xSampling:A,ySampling:e})}return z.value+=1,w}(Q,z,P);case"chromaticities":return function(Q,z){return{redX:K(Q,z),redY:K(Q,z),greenX:K(Q,z),greenY:K(Q,z),blueX:K(Q,z),blueY:K(Q,z),whiteX:K(Q,z),whiteY:K(Q,z)}}(Q,z);case"compression":return function(Q,z){return l(Q,z)}(Q,z);case"box2i":return function(Q,z){return{xMin:s(Q,z),yMin:s(Q,z),xMax:s(Q,z),yMax:s(Q,z)}}(Q,z);case"lineOrder":return function(Q,z){const I=l(Q,z);return j[I]}(Q,z);case"float":return K(Q,z);case"v2f":return function(Q,z){return[K(Q,z),K(Q,z)]}(Q,z);case"v3f":return function(Q,z){return[K(Q,z),K(Q,z),K(Q,z)]}(Q,z);case"int":return s(Q,z);case"rational":return function(Q,z){return[s(Q,z),J(Q,z)]}(Q,z);case"timecode":return function(Q,z){return[J(Q,z),J(Q,z)]}(Q,z);case"preview":return z.value+=P,"skipped";default:return void(z.value+=P)}}function H(Q){for(let z=1;z<Q.length;z++){const I=Q[z-1]+Q[z]-128;Q[z]=I}}function V(Q,z){let I=0,P=Math.floor((Q.length+1)/2),w=0;const T=Q.length-1;for(;!(w>T)&&(z[w++]=Q[I++],!(w>T));)z[w++]=Q[P++]}function M(Q,z,I,P,w){for(;I<Q;)z=z<<8|n(P,w),I+=8;return{l:z>>(I-=Q)&(1<<Q)-1,c:z,lc:I}}function h(Q,z,I,P){return{c:Q=Q<<8|n(I,P),lc:z+=8}}function C(Q,z,I,P,w,T,A,e,m){if(Q==z){if(P<8){const Q=h(I,P,w,T);I=Q.c,P=Q.lc}let Q=I>>(P-=8);if(Q=new Uint8Array([Q])[0],e.value+Q>m)return null;const z=A[e.value-1];for(;Q-- >0;)A[e.value++]=z}else{if(!(e.value<m))return null;A[e.value++]=Q}return{c:I,lc:P}}const i=new Array(59);function o(Q,z,I,P,w,T){const A=z;let m=0,f=0;for(;P<=w;P++){if(A.value-z.value>I)return;let e=M(6,m,f,Q,A);const j=e.l;if(m=e.c,f=e.lc,T[P]=j,63==j){if(A.value-z.value>I)throw new Error("Error in HufUnpackEncTable");e=M(8,m,f,Q,A);let j=e.l+6;if(m=e.c,f=e.lc,P+j>w+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)T[P++]=0;P--}else if(j>=59){let Q=j-59+2;if(P+Q>w+1)throw new Error("Error in HufUnpackEncTable");for(;Q--;)T[P++]=0;P--}}!function(Q){for(let I=0;I<=58;++I)i[I]=0;for(let I=0;I<e;++I)i[Q[I]]+=1;let z=0;for(let I=58;I>0;--I){const Q=z+i[I]>>1;i[I]=z,z=Q}for(let I=0;I<e;++I){const z=Q[I];z>0&&(Q[I]=z|i[z]++<<6)}}(T)}function O(Q){return 63&Q}function G(Q){return Q>>6}function R(Q,z,I,P,w,T){const f=I.value,j=J(z,I),D=J(z,I);I.value+=4;const k=J(z,I);if(I.value+=4,j<0||j>=e||D<0||D>=e)throw new Error("Wrong HUF_ENCSIZE");const s=new Array(e),l=new Array(m);!function(Q){for(let z=0;z<m;z++)Q[z]={},Q[z].len=0,Q[z].lit=0,Q[z].p=null}(l);if(o(Q,I,P-(I.value-f),j,D,s),k>8*(P-(I.value-f)))throw new Error("Wrong hufUncompress");!function(Q,z,I,P){for(;z<=I;z++){const I=G(Q[z]),w=O(Q[z]);if(I>>w)throw new Error("Invalid table entry");if(w>A){const Q=P[I>>w-A];if(Q.len)throw new Error("Invalid table entry");if(Q.lit++,Q.p){const z=Q.p;Q.p=new Array(Q.lit);for(let I=0;I<Q.lit-1;++I)Q.p[I]=z[I]}else Q.p=new Array(1);Q.p[Q.lit-1]=z}else if(w){let Q=0;for(let T=1<<A-w;T>0;T--){const T=P[(I<<A-w)+Q];if(T.len||T.p)throw new Error("Invalid table entry");T.len=w,T.lit=z,Q++}}}}(s,j,D,l),function(Q,z,I,P,w,T,e,m,f){let j=0,D=0;const k=e,s=Math.trunc(P.value+(w+7)/8);for(;P.value<s;){let w=h(j,D,I,P);for(j=w.c,D=w.lc;D>=A;){const e=z[j>>D-A&16383];if(e.len){D-=e.len;const Q=C(e.lit,T,j,D,I,P,m,f,k);Q&&(j=Q.c,D=Q.lc)}else{if(!e.p)throw new Error("hufDecode issues");let z;for(z=0;z<e.lit;z++){const A=O(Q[e.p[z]]);for(;D<A&&P.value<s;)w=h(j,D,I,P),j=w.c,D=w.lc;if(D>=A&&G(Q[e.p[z]])==(j>>D-A&(1<<A)-1)){D-=A;const Q=C(e.p[z],T,j,D,I,P,m,f,k);Q&&(j=Q.c,D=Q.lc);break}}if(z==e.lit)throw new Error("HufDecode issues")}}}const J=8-w&7;for(j>>=J,D-=J;D>0;){const Q=z[j<<A-D&16383];if(!Q.len)throw new Error("HufDecode issues");{D-=Q.len;const z=C(Q.lit,T,j,D,I,P,m,f,k);z&&(j=z.c,D=z.lc)}}}(s,l,Q,I,k,D,T,w,{value:0})}function r(Q){return 65535&Q}function t(Q){const z=r(Q);return z>32767?z-65536:z}function W(Q,z){const I=t(Q),P=t(z),w=I+(1&P)+(P>>1);return{a:w,b:w-P}}function E(Q,z){const I=r(Q),P=r(z),w=I-(P>>1)&65535;return{a:P+w-32768&65535,b:w}}function p(Q,z,I,P,w,T,A){const e=A<16384,m=I>w?w:I;let f,j,D=1;for(;D<=m;)D<<=1;for(D>>=1,f=D,D>>=1;D>=1;){j=0;const A=j+T*(w-f),m=T*D,k=T*f,s=P*D,J=P*f;let l,X,n,d;for(;j<=A;j+=k){let w=j;const T=j+P*(I-f);for(;w<=T;w+=J){const I=w+s,P=w+m,T=P+s;if(e){let A=W(Q[w+z],Q[P+z]);l=A.a,n=A.b,A=W(Q[I+z],Q[T+z]),X=A.a,d=A.b,A=W(l,X),Q[w+z]=A.a,Q[I+z]=A.b,A=W(n,d),Q[P+z]=A.a,Q[T+z]=A.b}else{let A=E(Q[w+z],Q[P+z]);l=A.a,n=A.b,A=E(Q[I+z],Q[T+z]),X=A.a,d=A.b,A=E(l,X),Q[w+z]=A.a,Q[I+z]=A.b,A=E(n,d),Q[P+z]=A.a,Q[T+z]=A.b}}if(I&D){const I=w+m;let P;P=e?W(Q[w+z],Q[I+z]):E(Q[w+z],Q[I+z]),l=P.a,Q[I+z]=P.b,Q[w+z]=l}}if(w&D){let w=j;const T=j+P*(I-f);for(;w<=T;w+=J){const I=w+s;let P;P=e?W(Q[w+z],Q[I+z]):E(Q[w+z],Q[I+z]),l=P.a,Q[I+z]=P.b,Q[w+z]=l}}f=D,D>>=1}return j}function y(Q){return new DataView(Q.array.buffer,Q.offset.value,Q.size)}function S(Q){const z=Q.viewer.buffer.slice(Q.offset.value,Q.offset.value+Q.size),I=new Uint8Array(function(Q){let z=Q.byteLength;const I=new Array;let P=0;const w=new DataView(Q);for(;z>0;){const Q=w.getInt8(P++);if(Q<0){const T=-Q;z-=T+1;for(let Q=0;Q<T;Q++)I.push(w.getUint8(P++))}else{const T=Q;z-=2;const A=w.getUint8(P++);for(let Q=0;Q<T+1;Q++)I.push(A)}}return I}(z)),P=new Uint8Array(I.length);return H(I),V(I,P),new DataView(P.buffer)}function a(Q){const z=Q.array.slice(Q.offset.value,Q.offset.value+Q.size),I=fflate.unzlibSync(z),P=new Uint8Array(I.length);return H(I),V(I,P),new DataView(P.buffer)}function Z(Q){const z=Q.array.slice(Q.offset.value,Q.offset.value+Q.size),I=fflate.unzlibSync(z),P=Q.lines*Q.channels*Q.width,w=1==Q.type?new Uint16Array(P):new Uint32Array(P);let T=0,A=0;const e=new Array(4);for(let m=0;m<Q.lines;m++)for(let z=0;z<Q.channels;z++){let z=0;switch(Q.type){case 1:e[0]=T,e[1]=e[0]+Q.width,T=e[1]+Q.width;for(let P=0;P<Q.width;++P){z+=I[e[0]++]<<8|I[e[1]++],w[A]=z,A++}break;case 2:e[0]=T,e[1]=e[0]+Q.width,e[2]=e[1]+Q.width,T=e[2]+Q.width;for(let P=0;P<Q.width;++P){z+=I[e[0]++]<<24|I[e[1]++]<<16|I[e[2]++]<<8,w[A]=z,A++}}}return new DataView(w.buffer)}function U(Q){const z=Q.viewer,I={value:Q.offset.value},P=new Uint16Array(Q.width*Q.scanlineBlockSize*(Q.channels*Q.type)),w=new Uint8Array(8192);let A=0;const e=new Array(Q.channels);for(let T=0;T<Q.channels;T++)e[T]={},e[T].start=A,e[T].end=e[T].start,e[T].nx=Q.width,e[T].ny=Q.lines,e[T].size=Q.type,A+=e[T].nx*e[T].ny*e[T].size;const m=X(z,I),f=X(z,I);if(f>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(m<=f)for(let T=0;T<f-m+1;T++)w[T+m]=l(z,I);const j=new Uint16Array(T),D=function(Q,z){let I=0;for(let w=0;w<T;++w)(0==w||Q[w>>3]&1<<(7&w))&&(z[I++]=w);const P=I-1;for(;I<T;)z[I++]=0;return P}(w,j),k=J(z,I);R(Q.array,z,I,k,P,A);for(let T=0;T<Q.channels;++T){const Q=e[T];for(let z=0;z<e[T].size;++z)p(P,Q.start+z,Q.nx,Q.size,Q.ny,Q.nx*Q.size,D)}!function(Q,z,I){for(let P=0;P<I;++P)z[P]=Q[z[P]]}(j,P,A);let s=0;const n=new Uint8Array(P.buffer.byteLength);for(let T=0;T<Q.lines;T++)for(let z=0;z<Q.channels;z++){const Q=e[z],I=Q.nx*Q.size,w=new Uint8Array(P.buffer,2*Q.end,2*I);n.set(w,s),s+=2*I,Q.end+=I}return new DataView(n.buffer)}var v,u=I(1180);!function(Q){Q[Q.Float=0]="Float",Q[Q.HalfFloat=1]="HalfFloat"}(v||(v={}));class Y{}Y.DefaultOutputType=v.HalfFloat,Y.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class L{constructor(){this.supportCascades=!1}loadCubeData(Q,z,I,P,w){throw".exr not supported in Cube."}async loadData(Q,z,I){const w=new DataView(Q.buffer),T={value:0},A=function(Q,z){if(20000630!=Q.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const I=Q.getUint8(4),w=Q.getUint8(5),T={singleTile:!!(2&w),longName:!!(4&w),deepFormat:!!(8&w),multiPart:!!(16&w)};z.value=8;const A={};let e=!0;for(;e;){const I=k(Q.buffer,z);if(I){const w=k(Q.buffer,z),T=c(Q,z,w,J(Q,z));void 0===T?P.b.Warn(`Unknown header attribute type ${w}'.`):A[I]=T}else e=!1}if(0!=(-5&w))throw new Error("Unsupported file format");return{version:I,spec:T,...A}}(w,T),e=await async function(Q,z,I,P){const w={size:0,viewer:z,array:new Uint8Array(z.buffer),offset:I,width:Q.dataWindow.xMax-Q.dataWindow.xMin+1,height:Q.dataWindow.yMax-Q.dataWindow.yMin+1,channels:Q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Q.compression){case f.NO_COMPRESSION:w.lines=1,w.uncompress=y;break;case f.RLE_COMPRESSION:w.lines=1,w.uncompress=S;break;case f.ZIPS_COMPRESSION:w.lines=1,w.uncompress=a,await u.h.LoadScriptAsync(Y.FFLATEUrl);break;case f.ZIP_COMPRESSION:w.lines=16,w.uncompress=a,await u.h.LoadScriptAsync(Y.FFLATEUrl);break;case f.PIZ_COMPRESSION:w.lines=32,w.uncompress=U;break;case f.PXR24_COMPRESSION:w.lines=16,w.uncompress=Z,await u.h.LoadScriptAsync(Y.FFLATEUrl);break;default:throw new Error(f[Q.compression]+" is unsupported")}w.scanlineBlockSize=w.lines;const T={};for(const f of Q.channels)switch(f.name){case"Y":case"R":case"G":case"B":case"A":T[f.name]=!0,w.type=f.pixelType}let A=!1;if(T.R&&T.G&&T.B)A=!T.A,w.outputChannels=4,w.decodeChannels={R:0,G:1,B:2,A:3};else{if(!T.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");w.outputChannels=1,w.decodeChannels={Y:0}}if(1===w.type)switch(P){case v.Float:w.getter=N,w.inputSize=2;break;case v.HalfFloat:w.getter=X,w.inputSize=2}else{if(2!==w.type)throw new Error("Unsupported pixelType "+w.type+" for "+Q.compression);switch(P){case v.Float:w.getter=K,w.inputSize=4;break;case v.HalfFloat:w.getter=q,w.inputSize=4}}w.blockCount=w.height/w.scanlineBlockSize;for(let f=0;f<w.blockCount;f++)d(z,I);const e=w.width*w.height*w.outputChannels;switch(P){case v.Float:w.byteArray=new Float32Array(e),w.textureType=1,A&&w.byteArray.fill(1,0,e);break;case v.HalfFloat:w.byteArray=new Uint16Array(e),w.textureType=2,A&&w.byteArray.fill(15360,0,e);break;default:throw new Error("Unsupported type: "+P)}let m=0;for(const f of Q.channels)void 0!==w.decodeChannels[f.name]&&(w.channelLineOffsets[f.name]=m*w.width),m+=2*f.pixelType;return w.bytesPerLine=w.width*m,w.outLineWidth=w.width*w.outputChannels,"INCREASING_Y"===Q.lineOrder?w.scanOrder=Q=>Q:w.scanOrder=Q=>w.height-1-Q,4==w.outputChannels?(w.format=5,w.linearSpace=!0):(w.format=6,w.linearSpace=!1),w}(A,w,T,Y.DefaultOutputType);!function(Q,z,I,P){const w={value:0};for(let T=0;T<Q.height/Q.scanlineBlockSize;T++){const A=s(I,P)-z.dataWindow.yMin;Q.size=J(I,P),Q.lines=A+Q.scanlineBlockSize>Q.height?Q.height-A:Q.scanlineBlockSize;const e=Q.size<Q.lines*Q.bytesPerLine&&Q.uncompress?Q.uncompress(Q):y(Q);P.value+=Q.size;for(let I=0;I<Q.scanlineBlockSize;I++){const P=T*Q.scanlineBlockSize,A=I+Q.scanOrder(P);if(A>=Q.height)continue;const m=I*Q.bytesPerLine,f=(Q.height-1-A)*Q.outLineWidth;for(let I=0;I<Q.channels;I++){const P=z.channels[I].name,T=Q.channelLineOffsets[P],A=Q.decodeChannels[P];if(void 0!==A){w.value=m+T;for(let z=0;z<Q.width;z++){const I=f+z*Q.outputChannels+A;Q.byteArray&&(Q.byteArray[I]=Q.getter(e,w))}}}}}}(e,A,w,T);I(A.dataWindow.xMax-A.dataWindow.xMin+1,A.dataWindow.yMax-A.dataWindow.yMin+1,z.generateMipMaps,!1,(()=>{const Q=z.getEngine();z.format=A.format,z.type=e.textureType,z.invertY=!1,z._gammaSpace=!A.linearSpace,e.byteArray&&Q._uploadDataToTextureDirectly(z,e.byteArray,0,0,void 0,!0)}))}}}}]);