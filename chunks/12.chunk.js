"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2676:(P,Q,O)=>{O.r(Q),O.d(Q,{_HDRTextureLoader:()=>C});var b=O(751);class F{static ConvertPanoramaToCubemap(P,Q,O,b){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!P)throw"ConvertPanoramaToCubemap: input cannot be null";if(P.length!=Q*O*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(b,this.FACE_FRONT,P,Q,O,F),back:this.CreateCubemapTexture(b,this.FACE_BACK,P,Q,O,F),left:this.CreateCubemapTexture(b,this.FACE_LEFT,P,Q,O,F),right:this.CreateCubemapTexture(b,this.FACE_RIGHT,P,Q,O,F),up:this.CreateCubemapTexture(b,this.FACE_UP,P,Q,O,F),down:this.CreateCubemapTexture(b,this.FACE_DOWN,P,Q,O,F),size:b,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(P,Q,O,b,F){let g=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const m=new ArrayBuffer(P*P*4*3),q=new Float32Array(m),R=g?Math.max(1,Math.round(b/4/P)):1,X=1/R,C=X*X,L=Q[1].ae(Q[0]).scale(X/P),G=Q[3].ae(Q[2]).scale(X/P),A=1/P;let j=0;for(let w=0;w<P;w++)for(let g=0;g<R;g++){let g=Q[0],m=Q[2];for(let Q=0;Q<P;Q++)for(let X=0;X<R;X++){const R=m.ae(g).scale(j).add(g);R.normalize();const X=this.CalcProjectionSpherical(R,O,b,F);q[w*P*3+3*Q+0]+=X.r*C,q[w*P*3+3*Q+1]+=X.g*C,q[w*P*3+3*Q+2]+=X.b*C,g=g.add(L),m=m.add(G)}j+=A*X}return q}static CalcProjectionSpherical(P,Q,O,b){let F=Math.atan2(P.z,P.x);const g=Math.acos(P.y);for(;F<-Math.PI;)F+=2*Math.PI;for(;F>Math.PI;)F-=2*Math.PI;let m=F/Math.PI;const q=g/Math.PI;m=.5*m+.5;let R=Math.round(m*O);R<0?R=0:R>=O&&(R=O-1);let X=Math.round(q*b);X<0?X=0:X>=b&&(X=b-1);const C=b-X-1;return{r:Q[C*O*3+3*R+0],g:Q[C*O*3+3*R+1],b:Q[C*O*3+3*R+2]}}}function g(P,Q,O,b,F,g){F>0?(F=function(P,Q){return Q>1023?P*Math.pow(2,1023)*Math.pow(2,Q-1023):Q<-1074?P*Math.pow(2,-1074)*Math.pow(2,Q+1074):P*Math.pow(2,Q)}(1,F-136),P[g+0]=Q*F,P[g+1]=O*F,P[g+2]=b*F):(P[g+0]=0,P[g+1]=0,P[g+2]=0)}function m(P,Q){let O="",b="";for(let F=Q;F<P.length-Q&&(b=String.fromCharCode(P[F]),"\n"!=b);F++)O+=b;return O}function q(P){let Q=0,O=0,b=m(P,0);if("#"!=b[0]||"?"!=b[1])throw"Bad HDR Format.";let F=!1,g=!1,q=0;do{q+=b.length+1,b=m(P,q),"FORMAT=32-bit_rle_rgbe"==b?g=!0:0==b.length&&(F=!0)}while(!F);if(!g)throw"HDR Bad header format, unsupported FORMAT";q+=b.length+1,b=m(P,q);const R=/^-Y (.*) \+X (.*)$/g.exec(b);if(!R||R.length<3)throw"HDR Bad header format, no size";if(O=parseInt(R[2]),Q=parseInt(R[1]),O<8||O>32767)throw"HDR Bad header format, unsupported size";return q+=b.length+1,{height:Q,width:O,dataPosition:q}}function R(P,Q){return function(P,Q){let O=Q.height;const b=Q.width;let F,m,q,R,C,L=Q.dataPosition,G=0,A=0,j=0;const w=new ArrayBuffer(4*b),W=new Uint8Array(w),r=new ArrayBuffer(Q.width*Q.height*4*3),K=new Float32Array(r);for(;O>0;){if(F=P[L++],m=P[L++],q=P[L++],R=P[L++],2!=F||2!=m||128&q||Q.width<8||Q.width>32767)return X(P,Q);if((q<<8|R)!=b)throw"HDR Bad header format, wrong scan line width";for(G=0,j=0;j<4;j++)for(A=(j+1)*b;G<A;)if(F=P[L++],m=P[L++],F>128){if(C=F-128,0==C||C>A-G)throw"HDR Bad Format, bad scanline data (run)";for(;C-- >0;)W[G++]=m}else{if(C=F,0==C||C>A-G)throw"HDR Bad Format, bad scanline data (non-run)";if(W[G++]=m,--C>0)for(let Q=0;Q<C;Q++)W[G++]=P[L++]}for(j=0;j<b;j++)F=W[j],m=W[j+b],q=W[j+2*b],R=W[j+3*b],g(K,F,m,q,R,(Q.height-O)*b*3+3*j);O--}return K}(P,Q)}function X(P,Q){let O=Q.height;const b=Q.width;let F,m,q,R,X,C=Q.dataPosition;const L=new ArrayBuffer(Q.width*Q.height*4*3),G=new Float32Array(L);for(;O>0;){for(X=0;X<Q.width;X++)F=P[C++],m=P[C++],q=P[C++],R=P[C++],g(G,F,m,q,R,(Q.height-O)*b*3+3*X);O--}return G}F.FACE_LEFT=[new b.j(-1,-1,-1),new b.j(1,-1,-1),new b.j(-1,1,-1),new b.j(1,1,-1)],F.FACE_RIGHT=[new b.j(1,-1,1),new b.j(-1,-1,1),new b.j(1,1,1),new b.j(-1,1,1)],F.FACE_FRONT=[new b.j(1,-1,-1),new b.j(1,-1,1),new b.j(1,1,-1),new b.j(1,1,1)],F.FACE_BACK=[new b.j(-1,-1,1),new b.j(-1,-1,-1),new b.j(-1,1,1),new b.j(-1,1,-1)],F.FACE_DOWN=[new b.j(1,1,-1),new b.j(1,1,1),new b.j(-1,1,-1),new b.j(-1,1,1)],F.FACE_UP=[new b.j(-1,-1,-1),new b.j(-1,-1,1),new b.j(1,-1,-1),new b.j(1,-1,1)];class C{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(P,Q,O){const b=new Uint8Array(P.buffer,P.byteOffset,P.byteLength),F=q(b),g=R(b,F),m=F.width*F.height,X=new Float32Array(4*m);for(let q=0;q<m;q+=1)X[4*q]=g[3*q],X[4*q+1]=g[3*q+1],X[4*q+2]=g[3*q+2],X[4*q+3]=1;O(F.width,F.height,Q.generateMipMaps,!1,(()=>{const P=Q.getEngine();Q.type=1,Q.format=5,Q._gammaSpace=!1,P._uploadDataToTextureDirectly(Q,X)}))}}}}]);