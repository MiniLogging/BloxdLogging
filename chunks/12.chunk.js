"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12727:(E,Y,C)=>{C.r(Y),C.d(Y,{_DDSTextureLoader:()=>m});var P=C(11563),K=C(11579);class m{constructor(){this.supportCascades=!0}loadCubeData(E,Y,C,m){const u=Y.getEngine();let T,a=!1,J=1e3;if(Array.isArray(E))for(let P=0;P<E.length;P++){const C=E[P];T=K.d.GetDDSInfo(C),Y.width=T.width,Y.height=T.height,a=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&Y.generateMipMaps,u._unpackFlipY(T.isCompressed),K.d.UploadDDSLevels(u,Y,C,T,a,6,-1,P),T.isFourCC||1!==T.mipmapCount?J=T.mipmapCount-1:u.generateMipMapsForCubemap(Y)}else{const m=E;T=K.d.GetDDSInfo(m),Y.width=T.width,Y.height=T.height,C&&(T.sphericalPolynomial=new P.d),a=(T.isRGB||T.isLuminance||T.mipmapCount>1)&&Y.generateMipMaps,u._unpackFlipY(T.isCompressed),K.d.UploadDDSLevels(u,Y,m,T,a,6),T.isFourCC||1!==T.mipmapCount?J=T.mipmapCount-1:u.generateMipMapsForCubemap(Y,!1)}u._setCubeMapTextureParams(Y,a,J),Y.isReady=!0,Y.onLoadedObservable.notifyObservers(Y),Y.onLoadedObservable.clear(),m&&m({isDDS:!0,width:Y.width,info:T,data:E,texture:Y})}loadData(E,Y,C){const P=K.d.GetDDSInfo(E),m=(P.isRGB||P.isLuminance||P.mipmapCount>1)&&Y.generateMipMaps&&Math.max(P.width,P.height)>>P.mipmapCount-1===1;C(P.width,P.height,m,P.isFourCC,(()=>{K.d.UploadDDSLevels(Y.getEngine(),Y,E,P,m,1)}))}}}}]);