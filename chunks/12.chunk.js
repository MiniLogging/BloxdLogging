"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2508:(J,T,b)=>{b.r(T),b.d(T,{_HDRTextureLoader:()=>A});var q=b(697);class t{static ConvertPanoramaToCubemap(J,T,b,q){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!J)throw"ConvertPanoramaToCubemap: input cannot be null";if(J.length!=T*b*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(q,this.FACE_FRONT,J,T,b,t),back:this.CreateCubemapTexture(q,this.FACE_BACK,J,T,b,t),left:this.CreateCubemapTexture(q,this.FACE_LEFT,J,T,b,t),right:this.CreateCubemapTexture(q,this.FACE_RIGHT,J,T,b,t),up:this.CreateCubemapTexture(q,this.FACE_UP,J,T,b,t),down:this.CreateCubemapTexture(q,this.FACE_DOWN,J,T,b,t),size:q,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(J,T,b,q,t){let j=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const B=new ArrayBuffer(J*J*4*3),Y=new Float32Array(B),C=j?Math.max(1,Math.round(q/4/J)):1,F=1/C,A=F*F,a=T[1].Jg(T[0]).scale(F/J),P=T[3].Jg(T[2]).scale(F/J),v=1/J;let G=0;for(let x=0;x<J;x++)for(let j=0;j<C;j++){let j=T[0],B=T[2];for(let T=0;T<J;T++)for(let F=0;F<C;F++){const C=B.Jg(j).scale(G).add(j);C.normalize();const F=this.CalcProjectionSpherical(C,b,q,t);Y[x*J*3+3*T+0]+=F.r*A,Y[x*J*3+3*T+1]+=F.g*A,Y[x*J*3+3*T+2]+=F.b*A,j=j.add(a),B=B.add(P)}G+=v*F}return Y}static CalcProjectionSpherical(J,T,b,q){let t=Math.atan2(J.z,J.x);const j=Math.acos(J.y);for(;t<-Math.PI;)t+=2*Math.PI;for(;t>Math.PI;)t-=2*Math.PI;let B=t/Math.PI;const Y=j/Math.PI;B=.5*B+.5;let C=Math.round(B*b);C<0?C=0:C>=b&&(C=b-1);let F=Math.round(Y*q);F<0?F=0:F>=q&&(F=q-1);const A=q-F-1;return{r:T[A*b*3+3*C+0],g:T[A*b*3+3*C+1],b:T[A*b*3+3*C+2]}}}function j(J,T,b,q,t,j){t>0?(t=function(J,T){return T>1023?J*Math.pow(2,1023)*Math.pow(2,T-1023):T<-1074?J*Math.pow(2,-1074)*Math.pow(2,T+1074):J*Math.pow(2,T)}(1,t-136),J[j+0]=T*t,J[j+1]=b*t,J[j+2]=q*t):(J[j+0]=0,J[j+1]=0,J[j+2]=0)}function B(J,T){let b="",q="";for(let t=T;t<J.length-T&&(q=String.fromCharCode(J[t]),"\n"!=q);t++)b+=q;return b}function Y(J){let T=0,b=0,q=B(J,0);if("#"!=q[0]||"?"!=q[1])throw"Bad HDR Format.";let t=!1,j=!1,Y=0;do{Y+=q.length+1,q=B(J,Y),"FORMAT=32-bit_rle_rgbe"==q?j=!0:0==q.length&&(t=!0)}while(!t);if(!j)throw"HDR Bad header format, unsupported FORMAT";Y+=q.length+1,q=B(J,Y);const C=/^-Y (.*) \+X (.*)$/g.exec(q);if(!C||C.length<3)throw"HDR Bad header format, no size";if(b=parseInt(C[2]),T=parseInt(C[1]),b<8||b>32767)throw"HDR Bad header format, unsupported size";return Y+=q.length+1,{height:T,width:b,dataPosition:Y}}function C(J,T){return function(J,T){let b=T.height;const q=T.width;let t,B,Y,C,A,a=T.dataPosition,P=0,v=0,G=0;const x=new ArrayBuffer(4*q),I=new Uint8Array(x),u=new ArrayBuffer(T.width*T.height*4*3),U=new Float32Array(u);for(;b>0;){if(t=J[a++],B=J[a++],Y=J[a++],C=J[a++],2!=t||2!=B||128&Y||T.width<8||T.width>32767)return F(J,T);if((Y<<8|C)!=q)throw"HDR Bad header format, wrong scan line width";for(P=0,G=0;G<4;G++)for(v=(G+1)*q;P<v;)if(t=J[a++],B=J[a++],t>128){if(A=t-128,0==A||A>v-P)throw"HDR Bad Format, bad scanline data (run)";for(;A-- >0;)I[P++]=B}else{if(A=t,0==A||A>v-P)throw"HDR Bad Format, bad scanline data (non-run)";if(I[P++]=B,--A>0)for(let T=0;T<A;T++)I[P++]=J[a++]}for(G=0;G<q;G++)t=I[G],B=I[G+q],Y=I[G+2*q],C=I[G+3*q],j(U,t,B,Y,C,(T.height-b)*q*3+3*G);b--}return U}(J,T)}function F(J,T){let b=T.height;const q=T.width;let t,B,Y,C,F,A=T.dataPosition;const a=new ArrayBuffer(T.width*T.height*4*3),P=new Float32Array(a);for(;b>0;){for(F=0;F<T.width;F++)t=J[A++],B=J[A++],Y=J[A++],C=J[A++],j(P,t,B,Y,C,(T.height-b)*q*3+3*F);b--}return P}t.FACE_LEFT=[new q.n(-1,-1,-1),new q.n(1,-1,-1),new q.n(-1,1,-1),new q.n(1,1,-1)],t.FACE_RIGHT=[new q.n(1,-1,1),new q.n(-1,-1,1),new q.n(1,1,1),new q.n(-1,1,1)],t.FACE_FRONT=[new q.n(1,-1,-1),new q.n(1,-1,1),new q.n(1,1,-1),new q.n(1,1,1)],t.FACE_BACK=[new q.n(-1,-1,1),new q.n(-1,-1,-1),new q.n(-1,1,1),new q.n(-1,1,-1)],t.FACE_DOWN=[new q.n(1,1,-1),new q.n(1,1,1),new q.n(-1,1,-1),new q.n(-1,1,1)],t.FACE_UP=[new q.n(-1,-1,-1),new q.n(-1,-1,1),new q.n(1,-1,-1),new q.n(1,-1,1)];class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(J,T,b){const q=new Uint8Array(J.buffer,J.byteOffset,J.byteLength),t=Y(q),j=C(q,t),B=t.width*t.height,F=new Float32Array(4*B);for(let Y=0;Y<B;Y+=1)F[4*Y]=j[3*Y],F[4*Y+1]=j[3*Y+1],F[4*Y+2]=j[3*Y+2],F[4*Y+3]=1;b(t.width,t.height,T.generateMipMaps,!1,(()=>{const J=T.getEngine();T.type=1,T.format=5,T._gammaSpace=!1,J._uploadDataToTextureDirectly(T,F)}))}}}}]);