"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10991:(I,S,d)=>{d.r(S),d.d(S,{_ExrTextureLoader:()=>X});var N=d(1098),O=d(1037);const g=65536,T=14,q=65537,a=16384;var f,Y;!function(I){I[I.NO_COMPRESSION=0]="NO_COMPRESSION",I[I.RLE_COMPRESSION=1]="RLE_COMPRESSION",I[I.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",I[I.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",I[I.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",I[I.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(f||(f={})),function(I){I[I.INCREASING_Y=0]="INCREASING_Y",I[I.DECREASING_Y=1]="DECREASING_Y"}(Y||(Y={}));const p=function(){const I=new ArrayBuffer(4),S=new Float32Array(I),d=new Uint32Array(I),N=new Uint32Array(512),O=new Uint32Array(512);for(let a=0;a<256;++a){const I=a-127;I<-27?(N[a]=0,N[256|a]=32768,O[a]=24,O[256|a]=24):I<-14?(N[a]=1024>>-I-14,N[256|a]=1024>>-I-14|32768,O[a]=-I-1,O[256|a]=-I-1):I<=15?(N[a]=I+15<<10,N[256|a]=I+15<<10|32768,O[a]=13,O[256|a]=13):I<128?(N[a]=31744,N[256|a]=64512,O[a]=24,O[256|a]=24):(N[a]=31744,N[256|a]=64512,O[a]=13,O[256|a]=13)}const g=new Uint32Array(2048),T=new Uint32Array(64),q=new Uint32Array(64);for(let a=1;a<1024;++a){let I=a<<13,S=0;for(;0===(8388608&I);)I<<=1,S-=8388608;I&=-8388609,S+=947912704,g[a]=I|S}for(let a=1024;a<2048;++a)g[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)T[a]=a<<23;T[31]=1199570944,T[32]=2147483648;for(let a=33;a<63;++a)T[a]=2147483648+(a-32<<23);T[63]=3347054592;for(let a=1;a<64;++a)32!==a&&(q[a]=1024);return{floatView:S,uint32View:d,baseTable:N,shiftTable:O,mantissaTable:g,exponentTable:T,offsetTable:q}}();function E(I,S){const d=new Uint8Array(I);let N=0;for(;0!=d[S.value+N];)N+=1;const O=(new TextDecoder).decode(d.slice(S.value,S.value+N));return S.value=S.value+N+1,O}function o(I,S){const d=I.getInt32(S.value,!0);return S.value+=4,d}function k(I,S){const d=I.getUint32(S.value,!0);return S.value+=4,d}function U(I,S){const d=I.getUint8(S.value);return S.value+=1,d}function i(I,S){const d=I.getUint16(S.value,!0);return S.value+=2,d}function G(I,S){const d=I[S.value];return S.value+=1,d}function t(I,S){let d;return d="getBigInt64"in DataView.prototype?Number(I.getBigInt64(S.value,!0)):I.getUint32(S.value+4,!0)+Number(I.getUint32(S.value,!0)<<32),S.value+=8,d}function j(I,S){const d=I.getFloat32(S.value,!0);return S.value+=4,d}function C(I,S){return function(I){const S=(31744&I)>>10,d=1023&I;return(I>>15?-1:1)*(S?31===S?d?NaN:1/0:Math.pow(2,S-15)*(1+d/1024):d/1024*6103515625e-14)}(i(I,S))}function n(I,S){return function(I){if(Math.abs(I)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");I=(0,O.e)(I,-65504,65504),p.floatView[0]=I;const S=p.uint32View[0],d=S>>23&511;return p.baseTable[d]+((8388607&S)>>p.shiftTable[d])}(j(I,S))}function R(I,S,d,N){switch(d){case"string":case"stringvector":case"iccProfile":return function(I,S,d){const N=(new TextDecoder).decode(new Uint8Array(I).slice(S.value,S.value+d));return S.value=S.value+d,N}(I.buffer,S,N);case"chlist":return function(I,S,d){const N=S.value,O=[];for(;S.value<N+d-1;){const d=E(I.buffer,S),N=o(I,S),g=U(I,S);S.value+=3;const T=o(I,S),q=o(I,S);O.push({name:d,pixelType:N,pLinear:g,xSampling:T,ySampling:q})}return S.value+=1,O}(I,S,N);case"chromaticities":return function(I,S){return{redX:j(I,S),redY:j(I,S),greenX:j(I,S),greenY:j(I,S),blueX:j(I,S),blueY:j(I,S),whiteX:j(I,S),whiteY:j(I,S)}}(I,S);case"compression":return function(I,S){return U(I,S)}(I,S);case"box2i":return function(I,S){return{xMin:o(I,S),yMin:o(I,S),xMax:o(I,S),yMax:o(I,S)}}(I,S);case"lineOrder":return function(I,S){const d=U(I,S);return Y[d]}(I,S);case"float":return j(I,S);case"v2f":return function(I,S){return[j(I,S),j(I,S)]}(I,S);case"v3f":return function(I,S){return[j(I,S),j(I,S),j(I,S)]}(I,S);case"int":return o(I,S);case"rational":return function(I,S){return[o(I,S),k(I,S)]}(I,S);case"timecode":return function(I,S){return[k(I,S),k(I,S)]}(I,S);case"preview":return S.value+=N,"skipped";default:return void(S.value+=N)}}function e(I){for(let S=1;S<I.length;S++){const d=I[S-1]+I[S]-128;I[S]=d}}function z(I,S){let d=0,N=Math.floor((I.length+1)/2),O=0;const g=I.length-1;for(;!(O>g)&&(S[O++]=I[d++],!(O>g));)S[O++]=I[N++]}function u(I,S,d,N,O){for(;d<I;)S=S<<8|G(N,O),d+=8;return{l:S>>(d-=I)&(1<<I)-1,c:S,lc:d}}function F(I,S,d,N){return{c:I=I<<8|G(d,N),lc:S+=8}}function x(I,S,d,N,O,g,T,q,a){if(I==S){if(N<8){const I=F(d,N,O,g);d=I.c,N=I.lc}let I=d>>(N-=8);if(I=new Uint8Array([I])[0],q.value+I>a)return null;const S=T[q.value-1];for(;I-- >0;)T[q.value++]=S}else{if(!(q.value<a))return null;T[q.value++]=I}return{c:d,lc:N}}const H=new Array(59);function h(I,S,d,N,O,g){const T=S;let a=0,f=0;for(;N<=O;N++){if(T.value-S.value>d)return;let q=u(6,a,f,I,T);const Y=q.l;if(a=q.c,f=q.lc,g[N]=Y,63==Y){if(T.value-S.value>d)throw new Error("Error in HufUnpackEncTable");q=u(8,a,f,I,T);let Y=q.l+6;if(a=q.c,f=q.lc,N+Y>O+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)g[N++]=0;N--}else if(Y>=59){let I=Y-59+2;if(N+I>O+1)throw new Error("Error in HufUnpackEncTable");for(;I--;)g[N++]=0;N--}}!function(I){for(let d=0;d<=58;++d)H[d]=0;for(let d=0;d<q;++d)H[I[d]]+=1;let S=0;for(let d=58;d>0;--d){const I=S+H[d]>>1;H[d]=S,S=I}for(let d=0;d<q;++d){const S=I[d];S>0&&(I[d]=S|H[S]++<<6)}}(g)}function s(I){return 63&I}function W(I){return I>>6}function m(I,S,d,N,O,g){const f=d.value,Y=k(S,d),p=k(S,d);d.value+=4;const E=k(S,d);if(d.value+=4,Y<0||Y>=q||p<0||p>=q)throw new Error("Wrong HUF_ENCSIZE");const o=new Array(q),U=new Array(a);!function(I){for(let S=0;S<a;S++)I[S]={},I[S].len=0,I[S].lit=0,I[S].p=null}(U);if(h(I,d,N-(d.value-f),Y,p,o),E>8*(N-(d.value-f)))throw new Error("Wrong hufUncompress");!function(I,S,d,N){for(;S<=d;S++){const d=W(I[S]),O=s(I[S]);if(d>>O)throw new Error("Invalid table entry");if(O>T){const I=N[d>>O-T];if(I.len)throw new Error("Invalid table entry");if(I.lit++,I.p){const S=I.p;I.p=new Array(I.lit);for(let d=0;d<I.lit-1;++d)I.p[d]=S[d]}else I.p=new Array(1);I.p[I.lit-1]=S}else if(O){let I=0;for(let g=1<<T-O;g>0;g--){const g=N[(d<<T-O)+I];if(g.len||g.p)throw new Error("Invalid table entry");g.len=O,g.lit=S,I++}}}}(o,Y,p,U),function(I,S,d,N,O,g,q,a,f){let Y=0,p=0;const E=q,o=Math.trunc(N.value+(O+7)/8);for(;N.value<o;){let O=F(Y,p,d,N);for(Y=O.c,p=O.lc;p>=T;){const q=S[Y>>p-T&16383];if(q.len){p-=q.len;const I=x(q.lit,g,Y,p,d,N,a,f,E);I&&(Y=I.c,p=I.lc)}else{if(!q.p)throw new Error("hufDecode issues");let S;for(S=0;S<q.lit;S++){const T=s(I[q.p[S]]);for(;p<T&&N.value<o;)O=F(Y,p,d,N),Y=O.c,p=O.lc;if(p>=T&&W(I[q.p[S]])==(Y>>p-T&(1<<T)-1)){p-=T;const I=x(q.p[S],g,Y,p,d,N,a,f,E);I&&(Y=I.c,p=I.lc);break}}if(S==q.lit)throw new Error("HufDecode issues")}}}const k=8-O&7;for(Y>>=k,p-=k;p>0;){const I=S[Y<<T-p&16383];if(!I.len)throw new Error("HufDecode issues");{p-=I.len;const S=x(I.lit,g,Y,p,d,N,a,f,E);S&&(Y=S.c,p=S.lc)}}}(o,U,I,d,E,p,g,O,{value:0})}function c(I){return 65535&I}function B(I){const S=c(I);return S>32767?S-65536:S}function A(I,S){const d=B(I),N=B(S),O=d+(1&N)+(N>>1);return{a:O,b:O-N}}function V(I,S){const d=c(I),N=c(S),O=d-(N>>1)&65535;return{a:N+O-32768&65535,b:O}}function y(I,S,d,N,O,g,T){const q=T<16384,a=d>O?O:d;let f,Y,p=1;for(;p<=a;)p<<=1;for(p>>=1,f=p,p>>=1;p>=1;){Y=0;const T=Y+g*(O-f),a=g*p,E=g*f,o=N*p,k=N*f;let U,i,G,t;for(;Y<=T;Y+=E){let O=Y;const g=Y+N*(d-f);for(;O<=g;O+=k){const d=O+o,N=O+a,g=N+o;if(q){let T=A(I[O+S],I[N+S]);U=T.a,G=T.b,T=A(I[d+S],I[g+S]),i=T.a,t=T.b,T=A(U,i),I[O+S]=T.a,I[d+S]=T.b,T=A(G,t),I[N+S]=T.a,I[g+S]=T.b}else{let T=V(I[O+S],I[N+S]);U=T.a,G=T.b,T=V(I[d+S],I[g+S]),i=T.a,t=T.b,T=V(U,i),I[O+S]=T.a,I[d+S]=T.b,T=V(G,t),I[N+S]=T.a,I[g+S]=T.b}}if(d&p){const d=O+a;let N;N=q?A(I[O+S],I[d+S]):V(I[O+S],I[d+S]),U=N.a,I[d+S]=N.b,I[O+S]=U}}if(O&p){let O=Y;const g=Y+N*(d-f);for(;O<=g;O+=k){const d=O+o;let N;N=q?A(I[O+S],I[d+S]):V(I[O+S],I[d+S]),U=N.a,I[d+S]=N.b,I[O+S]=U}}f=p,p>>=1}return Y}function L(I){return new DataView(I.array.buffer,I.offset.value,I.size)}function M(I){const S=I.viewer.buffer.slice(I.offset.value,I.offset.value+I.size),d=new Uint8Array(function(I){let S=I.byteLength;const d=new Array;let N=0;const O=new DataView(I);for(;S>0;){const I=O.getInt8(N++);if(I<0){const g=-I;S-=g+1;for(let I=0;I<g;I++)d.push(O.getUint8(N++))}else{const g=I;S-=2;const T=O.getUint8(N++);for(let I=0;I<g+1;I++)d.push(T)}}return d}(S)),N=new Uint8Array(d.length);return e(d),z(d,N),new DataView(N.buffer)}function Q(I){const S=I.array.slice(I.offset.value,I.offset.value+I.size),d=fflate.unzlibSync(S),N=new Uint8Array(d.length);return e(d),z(d,N),new DataView(N.buffer)}function w(I){const S=I.array.slice(I.offset.value,I.offset.value+I.size),d=fflate.unzlibSync(S),N=I.lines*I.channels*I.width,O=1==I.type?new Uint16Array(N):new Uint32Array(N);let g=0,T=0;const q=new Array(4);for(let a=0;a<I.lines;a++)for(let S=0;S<I.channels;S++){let S=0;switch(I.type){case 1:q[0]=g,q[1]=q[0]+I.width,g=q[1]+I.width;for(let N=0;N<I.width;++N){S+=d[q[0]++]<<8|d[q[1]++],O[T]=S,T++}break;case 2:q[0]=g,q[1]=q[0]+I.width,q[2]=q[1]+I.width,g=q[2]+I.width;for(let N=0;N<I.width;++N){S+=d[q[0]++]<<24|d[q[1]++]<<16|d[q[2]++]<<8,O[T]=S,T++}}}return new DataView(O.buffer)}function D(I){const S=I.viewer,d={value:I.offset.value},N=new Uint16Array(I.width*I.scanlineBlockSize*(I.channels*I.type)),O=new Uint8Array(8192);let T=0;const q=new Array(I.channels);for(let g=0;g<I.channels;g++)q[g]={},q[g].start=T,q[g].end=q[g].start,q[g].nx=I.width,q[g].ny=I.lines,q[g].size=I.type,T+=q[g].nx*q[g].ny*q[g].size;const a=i(S,d),f=i(S,d);if(f>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=f)for(let g=0;g<f-a+1;g++)O[g+a]=U(S,d);const Y=new Uint16Array(g),p=function(I,S){let d=0;for(let O=0;O<g;++O)(0==O||I[O>>3]&1<<(7&O))&&(S[d++]=O);const N=d-1;for(;d<g;)S[d++]=0;return N}(O,Y),E=k(S,d);m(I.array,S,d,E,N,T);for(let g=0;g<I.channels;++g){const I=q[g];for(let S=0;S<q[g].size;++S)y(N,I.start+S,I.nx,I.size,I.ny,I.nx*I.size,p)}!function(I,S,d){for(let N=0;N<d;++N)S[N]=I[S[N]]}(Y,N,T);let o=0;const G=new Uint8Array(N.buffer.byteLength);for(let g=0;g<I.lines;g++)for(let S=0;S<I.channels;S++){const I=q[S],d=I.nx*I.size,O=new Uint8Array(N.buffer,2*I.end,2*d);G.set(O,o),o+=2*d,I.end+=d}return new DataView(G.buffer)}var P,J=d(1216);!function(I){I[I.Float=0]="Float",I[I.HalfFloat=1]="HalfFloat"}(P||(P={}));class b{}b.DefaultOutputType=P.HalfFloat,b.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class X{constructor(){this.supportCascades=!1}loadCubeData(I,S,d,N,O){throw".exr not supported in Cube."}async loadData(I,S,d){const O=new DataView(I.buffer),g={value:0},T=function(I,S){if(20000630!=I.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const d=I.getUint8(4),O=I.getUint8(5),g={singleTile:!!(2&O),longName:!!(4&O),deepFormat:!!(8&O),multiPart:!!(16&O)};S.value=8;const T={};let q=!0;for(;q;){const d=E(I.buffer,S);if(d){const O=E(I.buffer,S),g=R(I,S,O,k(I,S));void 0===g?N.e.Warn(`Unknown header attribute type ${O}'.`):T[d]=g}else q=!1}if(0!=(-5&O))throw new Error("Unsupported file format");return{version:d,spec:g,...T}}(O,g),q=await async function(I,S,d,N){const O={size:0,viewer:S,array:new Uint8Array(S.buffer),offset:d,width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,channels:I.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(I.compression){case f.NO_COMPRESSION:O.lines=1,O.uncompress=L;break;case f.RLE_COMPRESSION:O.lines=1,O.uncompress=M;break;case f.ZIPS_COMPRESSION:O.lines=1,O.uncompress=Q,await J.d.LoadScriptAsync(b.FFLATEUrl);break;case f.ZIP_COMPRESSION:O.lines=16,O.uncompress=Q,await J.d.LoadScriptAsync(b.FFLATEUrl);break;case f.PIZ_COMPRESSION:O.lines=32,O.uncompress=D;break;case f.PXR24_COMPRESSION:O.lines=16,O.uncompress=w,await J.d.LoadScriptAsync(b.FFLATEUrl);break;default:throw new Error(f[I.compression]+" is unsupported")}O.scanlineBlockSize=O.lines;const g={};for(const f of I.channels)switch(f.name){case"Y":case"R":case"G":case"B":case"A":g[f.name]=!0,O.type=f.pixelType}let T=!1;if(g.R&&g.G&&g.B)T=!g.A,O.outputChannels=4,O.decodeChannels={R:0,G:1,B:2,A:3};else{if(!g.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");O.outputChannels=1,O.decodeChannels={Y:0}}if(1===O.type)switch(N){case P.Float:O.getter=C,O.inputSize=2;break;case P.HalfFloat:O.getter=i,O.inputSize=2}else{if(2!==O.type)throw new Error("Unsupported pixelType "+O.type+" for "+I.compression);switch(N){case P.Float:O.getter=j,O.inputSize=4;break;case P.HalfFloat:O.getter=n,O.inputSize=4}}O.blockCount=O.height/O.scanlineBlockSize;for(let f=0;f<O.blockCount;f++)t(S,d);const q=O.width*O.height*O.outputChannels;switch(N){case P.Float:O.byteArray=new Float32Array(q),O.textureType=1,T&&O.byteArray.fill(1,0,q);break;case P.HalfFloat:O.byteArray=new Uint16Array(q),O.textureType=2,T&&O.byteArray.fill(15360,0,q);break;default:throw new Error("Unsupported type: "+N)}let a=0;for(const f of I.channels)void 0!==O.decodeChannels[f.name]&&(O.channelLineOffsets[f.name]=a*O.width),a+=2*f.pixelType;return O.bytesPerLine=O.width*a,O.outLineWidth=O.width*O.outputChannels,"INCREASING_Y"===I.lineOrder?O.scanOrder=I=>I:O.scanOrder=I=>O.height-1-I,4==O.outputChannels?(O.format=5,O.linearSpace=!0):(O.format=6,O.linearSpace=!1),O}(T,O,g,b.DefaultOutputType);!function(I,S,d,N){const O={value:0};for(let g=0;g<I.height/I.scanlineBlockSize;g++){const T=o(d,N)-S.dataWindow.yMin;I.size=k(d,N),I.lines=T+I.scanlineBlockSize>I.height?I.height-T:I.scanlineBlockSize;const q=I.size<I.lines*I.bytesPerLine&&I.uncompress?I.uncompress(I):L(I);N.value+=I.size;for(let d=0;d<I.scanlineBlockSize;d++){const N=g*I.scanlineBlockSize,T=d+I.scanOrder(N);if(T>=I.height)continue;const a=d*I.bytesPerLine,f=(I.height-1-T)*I.outLineWidth;for(let d=0;d<I.channels;d++){const N=S.channels[d].name,g=I.channelLineOffsets[N],T=I.decodeChannels[N];if(void 0!==T){O.value=a+g;for(let S=0;S<I.width;S++){const d=f+S*I.outputChannels+T;I.byteArray&&(I.byteArray[d]=I.getter(q,O))}}}}}}(q,T,O,g);d(T.dataWindow.xMax-T.dataWindow.xMin+1,T.dataWindow.yMax-T.dataWindow.yMin+1,S.generateMipMaps,!1,(()=>{const I=S.getEngine();S.format=T.format,S.type=q.textureType,S.invertY=!1,S._gammaSpace=!T.linearSpace,q.byteArray&&I._uploadDataToTextureDirectly(S,q.byteArray,0,0,void 0,!0)}))}}}}]);