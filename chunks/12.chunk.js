"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12693:(A,e,E)=>{E.r(e),E.d(e,{_DDSTextureLoader:()=>t});var Q=E(11501),x=E(11515);class t{constructor(){this.supportCascades=!0}loadCubeData(A,e,E,t){const H=e.getEngine();let h,Y=!1,F=1e3;if(Array.isArray(A))for(let Q=0;Q<A.length;Q++){const E=A[Q];h=x.c.GetDDSInfo(E),e.width=h.width,e.height=h.height,Y=(h.isRGB||h.isLuminance||h.mipmapCount>1)&&e.generateMipMaps,H._unpackFlipY(h.isCompressed),x.c.UploadDDSLevels(H,e,E,h,Y,6,-1,Q),h.isFourCC||1!==h.mipmapCount?F=h.mipmapCount-1:H.generateMipMapsForCubemap(e)}else{const t=A;h=x.c.GetDDSInfo(t),e.width=h.width,e.height=h.height,E&&(h.sphericalPolynomial=new Q.h),Y=(h.isRGB||h.isLuminance||h.mipmapCount>1)&&e.generateMipMaps,H._unpackFlipY(h.isCompressed),x.c.UploadDDSLevels(H,e,t,h,Y,6),h.isFourCC||1!==h.mipmapCount?F=h.mipmapCount-1:H.generateMipMapsForCubemap(e,!1)}H._setCubeMapTextureParams(e,Y,F),e.isReady=!0,e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),t&&t({isDDS:!0,width:e.width,info:h,data:A,texture:e})}loadData(A,e,E){const Q=x.c.GetDDSInfo(A),t=(Q.isRGB||Q.isLuminance||Q.mipmapCount>1)&&e.generateMipMaps&&Math.max(Q.width,Q.height)>>Q.mipmapCount-1===1;E(Q.width,Q.height,t,Q.isFourCC,(()=>{x.c.UploadDDSLevels(e.getEngine(),e,A,Q,t,1)}))}}}}]);