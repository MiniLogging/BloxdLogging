"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10450:(A,I,y)=>{y.r(I),y.d(I,{_ExrTextureLoader:()=>O});var X=y(1098),F=y(1055);const M=65536,g=14,d=65537,V=16384;var k,U;!function(A){A[A.NO_COMPRESSION=0]="NO_COMPRESSION",A[A.RLE_COMPRESSION=1]="RLE_COMPRESSION",A[A.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",A[A.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",A[A.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",A[A.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(k||(k={})),function(A){A[A.INCREASING_Y=0]="INCREASING_Y",A[A.DECREASING_Y=1]="DECREASING_Y"}(U||(U={}));const P=function(){const A=new ArrayBuffer(4),I=new Float32Array(A),y=new Uint32Array(A),X=new Uint32Array(512),F=new Uint32Array(512);for(let V=0;V<256;++V){const A=V-127;A<-27?(X[V]=0,X[256|V]=32768,F[V]=24,F[256|V]=24):A<-14?(X[V]=1024>>-A-14,X[256|V]=1024>>-A-14|32768,F[V]=-A-1,F[256|V]=-A-1):A<=15?(X[V]=A+15<<10,X[256|V]=A+15<<10|32768,F[V]=13,F[256|V]=13):A<128?(X[V]=31744,X[256|V]=64512,F[V]=24,F[256|V]=24):(X[V]=31744,X[256|V]=64512,F[V]=13,F[256|V]=13)}const M=new Uint32Array(2048),g=new Uint32Array(64),d=new Uint32Array(64);for(let V=1;V<1024;++V){let A=V<<13,I=0;for(;0===(8388608&A);)A<<=1,I-=8388608;A&=-8388609,I+=947912704,M[V]=A|I}for(let V=1024;V<2048;++V)M[V]=939524096+(V-1024<<13);for(let V=1;V<31;++V)g[V]=V<<23;g[31]=1199570944,g[32]=2147483648;for(let V=33;V<63;++V)g[V]=2147483648+(V-32<<23);g[63]=3347054592;for(let V=1;V<64;++V)32!==V&&(d[V]=1024);return{floatView:I,uint32View:y,baseTable:X,shiftTable:F,mantissaTable:M,exponentTable:g,offsetTable:d}}();function f(A,I){const y=new Uint8Array(A);let X=0;for(;0!=y[I.value+X];)X+=1;const F=(new TextDecoder).decode(y.slice(I.value,I.value+X));return I.value=I.value+X+1,F}function z(A,I){const y=A.getInt32(I.value,!0);return I.value+=4,y}function l(A,I){const y=A.getUint32(I.value,!0);return I.value+=4,y}function u(A,I){const y=A.getUint8(I.value);return I.value+=1,y}function K(A,I){const y=A.getUint16(I.value,!0);return I.value+=2,y}function x(A,I){const y=A[I.value];return I.value+=1,y}function t(A,I){let y;return y="getBigInt64"in DataView.prototype?Number(A.getBigInt64(I.value,!0)):A.getUint32(I.value+4,!0)+Number(A.getUint32(I.value,!0)<<32),I.value+=8,y}function N(A,I){const y=A.getFloat32(I.value,!0);return I.value+=4,y}function R(A,I){return function(A){const I=(31744&A)>>10,y=1023&A;return(A>>15?-1:1)*(I?31===I?y?NaN:1/0:Math.pow(2,I-15)*(1+y/1024):y/1024*6103515625e-14)}(K(A,I))}function Z(A,I){return function(A){if(Math.abs(A)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");A=(0,F.b)(A,-65504,65504),P.floatView[0]=A;const I=P.uint32View[0],y=I>>23&511;return P.baseTable[y]+((8388607&I)>>P.shiftTable[y])}(N(A,I))}function b(A,I,y,X){switch(y){case"string":case"stringvector":case"iccProfile":return function(A,I,y){const X=(new TextDecoder).decode(new Uint8Array(A).slice(I.value,I.value+y));return I.value=I.value+y,X}(A.buffer,I,X);case"chlist":return function(A,I,y){const X=I.value,F=[];for(;I.value<X+y-1;){const y=f(A.buffer,I),X=z(A,I),M=u(A,I);I.value+=3;const g=z(A,I),d=z(A,I);F.push({name:y,pixelType:X,pLinear:M,xSampling:g,ySampling:d})}return I.value+=1,F}(A,I,X);case"chromaticities":return function(A,I){return{redX:N(A,I),redY:N(A,I),greenX:N(A,I),greenY:N(A,I),blueX:N(A,I),blueY:N(A,I),whiteX:N(A,I),whiteY:N(A,I)}}(A,I);case"compression":return function(A,I){return u(A,I)}(A,I);case"box2i":return function(A,I){return{xMin:z(A,I),yMin:z(A,I),xMax:z(A,I),yMax:z(A,I)}}(A,I);case"lineOrder":return function(A,I){const y=u(A,I);return U[y]}(A,I);case"float":return N(A,I);case"v2f":return function(A,I){return[N(A,I),N(A,I)]}(A,I);case"v3f":return function(A,I){return[N(A,I),N(A,I),N(A,I)]}(A,I);case"int":return z(A,I);case"rational":return function(A,I){return[z(A,I),l(A,I)]}(A,I);case"timecode":return function(A,I){return[l(A,I),l(A,I)]}(A,I);case"preview":return I.value+=X,"skipped";default:return void(I.value+=X)}}function Q(A){for(let I=1;I<A.length;I++){const y=A[I-1]+A[I]-128;A[I]=y}}function D(A,I){let y=0,X=Math.floor((A.length+1)/2),F=0;const M=A.length-1;for(;!(F>M)&&(I[F++]=A[y++],!(F>M));)I[F++]=A[X++]}function j(A,I,y,X,F){for(;y<A;)I=I<<8|x(X,F),y+=8;return{l:I>>(y-=A)&(1<<A)-1,c:I,lc:y}}function v(A,I,y,X){return{c:A=A<<8|x(y,X),lc:I+=8}}function T(A,I,y,X,F,M,g,d,V){if(A==I){if(X<8){const A=v(y,X,F,M);y=A.c,X=A.lc}let A=y>>(X-=8);if(A=new Uint8Array([A])[0],d.value+A>V)return null;const I=g[d.value-1];for(;A-- >0;)g[d.value++]=I}else{if(!(d.value<V))return null;g[d.value++]=A}return{c:y,lc:X}}const G=new Array(59);function S(A,I,y,X,F,M){const g=I;let V=0,k=0;for(;X<=F;X++){if(g.value-I.value>y)return;let d=j(6,V,k,A,g);const U=d.l;if(V=d.c,k=d.lc,M[X]=U,63==U){if(g.value-I.value>y)throw new Error("Error in HufUnpackEncTable");d=j(8,V,k,A,g);let U=d.l+6;if(V=d.c,k=d.lc,X+U>F+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)M[X++]=0;X--}else if(U>=59){let A=U-59+2;if(X+A>F+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)M[X++]=0;X--}}!function(A){for(let y=0;y<=58;++y)G[y]=0;for(let y=0;y<d;++y)G[A[y]]+=1;let I=0;for(let y=58;y>0;--y){const A=I+G[y]>>1;G[y]=I,I=A}for(let y=0;y<d;++y){const I=A[y];I>0&&(A[y]=I|G[I]++<<6)}}(M)}function n(A){return 63&A}function L(A){return A>>6}function J(A,I,y,X,F,M){const k=y.value,U=l(I,y),P=l(I,y);y.value+=4;const f=l(I,y);if(y.value+=4,U<0||U>=d||P<0||P>=d)throw new Error("Wrong HUF_ENCSIZE");const z=new Array(d),u=new Array(V);!function(A){for(let I=0;I<V;I++)A[I]={},A[I].len=0,A[I].lit=0,A[I].p=null}(u);if(S(A,y,X-(y.value-k),U,P,z),f>8*(X-(y.value-k)))throw new Error("Wrong hufUncompress");!function(A,I,y,X){for(;I<=y;I++){const y=L(A[I]),F=n(A[I]);if(y>>F)throw new Error("Invalid table entry");if(F>g){const A=X[y>>F-g];if(A.len)throw new Error("Invalid table entry");if(A.lit++,A.p){const I=A.p;A.p=new Array(A.lit);for(let y=0;y<A.lit-1;++y)A.p[y]=I[y]}else A.p=new Array(1);A.p[A.lit-1]=I}else if(F){let A=0;for(let M=1<<g-F;M>0;M--){const M=X[(y<<g-F)+A];if(M.len||M.p)throw new Error("Invalid table entry");M.len=F,M.lit=I,A++}}}}(z,U,P,u),function(A,I,y,X,F,M,d,V,k){let U=0,P=0;const f=d,z=Math.trunc(X.value+(F+7)/8);for(;X.value<z;){let F=v(U,P,y,X);for(U=F.c,P=F.lc;P>=g;){const d=I[U>>P-g&16383];if(d.len){P-=d.len;const A=T(d.lit,M,U,P,y,X,V,k,f);A&&(U=A.c,P=A.lc)}else{if(!d.p)throw new Error("hufDecode issues");let I;for(I=0;I<d.lit;I++){const g=n(A[d.p[I]]);for(;P<g&&X.value<z;)F=v(U,P,y,X),U=F.c,P=F.lc;if(P>=g&&L(A[d.p[I]])==(U>>P-g&(1<<g)-1)){P-=g;const A=T(d.p[I],M,U,P,y,X,V,k,f);A&&(U=A.c,P=A.lc);break}}if(I==d.lit)throw new Error("HufDecode issues")}}}const l=8-F&7;for(U>>=l,P-=l;P>0;){const A=I[U<<g-P&16383];if(!A.len)throw new Error("HufDecode issues");{P-=A.len;const I=T(A.lit,M,U,P,y,X,V,k,f);I&&(U=I.c,P=I.lc)}}}(z,u,A,y,f,P,M,F,{value:0})}function s(A){return 65535&A}function p(A){const I=s(A);return I>32767?I-65536:I}function W(A,I){const y=p(A),X=p(I),F=y+(1&X)+(X>>1);return{a:F,b:F-X}}function w(A,I){const y=s(A),X=s(I),F=y-(X>>1)&65535;return{a:X+F-32768&65535,b:F}}function e(A,I,y,X,F,M,g){const d=g<16384,V=y>F?F:y;let k,U,P=1;for(;P<=V;)P<<=1;for(P>>=1,k=P,P>>=1;P>=1;){U=0;const g=U+M*(F-k),V=M*P,f=M*k,z=X*P,l=X*k;let u,K,x,t;for(;U<=g;U+=f){let F=U;const M=U+X*(y-k);for(;F<=M;F+=l){const y=F+z,X=F+V,M=X+z;if(d){let g=W(A[F+I],A[X+I]);u=g.a,x=g.b,g=W(A[y+I],A[M+I]),K=g.a,t=g.b,g=W(u,K),A[F+I]=g.a,A[y+I]=g.b,g=W(x,t),A[X+I]=g.a,A[M+I]=g.b}else{let g=w(A[F+I],A[X+I]);u=g.a,x=g.b,g=w(A[y+I],A[M+I]),K=g.a,t=g.b,g=w(u,K),A[F+I]=g.a,A[y+I]=g.b,g=w(x,t),A[X+I]=g.a,A[M+I]=g.b}}if(y&P){const y=F+V;let X;X=d?W(A[F+I],A[y+I]):w(A[F+I],A[y+I]),u=X.a,A[y+I]=X.b,A[F+I]=u}}if(F&P){let F=U;const M=U+X*(y-k);for(;F<=M;F+=l){const y=F+z;let X;X=d?W(A[F+I],A[y+I]):w(A[F+I],A[y+I]),u=X.a,A[y+I]=X.b,A[F+I]=u}}k=P,P>>=1}return U}function H(A){return new DataView(A.array.buffer,A.offset.value,A.size)}function E(A){const I=A.viewer.buffer.slice(A.offset.value,A.offset.value+A.size),y=new Uint8Array(function(A){let I=A.byteLength;const y=new Array;let X=0;const F=new DataView(A);for(;I>0;){const A=F.getInt8(X++);if(A<0){const M=-A;I-=M+1;for(let A=0;A<M;A++)y.push(F.getUint8(X++))}else{const M=A;I-=2;const g=F.getUint8(X++);for(let A=0;A<M+1;A++)y.push(g)}}return y}(I)),X=new Uint8Array(y.length);return Q(y),D(y,X),new DataView(X.buffer)}function i(A){const I=A.array.slice(A.offset.value,A.offset.value+A.size),y=fflate.unzlibSync(I),X=new Uint8Array(y.length);return Q(y),D(y,X),new DataView(X.buffer)}function o(A){const I=A.array.slice(A.offset.value,A.offset.value+A.size),y=fflate.unzlibSync(I),X=A.lines*A.channels*A.width,F=1==A.type?new Uint16Array(X):new Uint32Array(X);let M=0,g=0;const d=new Array(4);for(let V=0;V<A.lines;V++)for(let I=0;I<A.channels;I++){let I=0;switch(A.type){case 1:d[0]=M,d[1]=d[0]+A.width,M=d[1]+A.width;for(let X=0;X<A.width;++X){I+=y[d[0]++]<<8|y[d[1]++],F[g]=I,g++}break;case 2:d[0]=M,d[1]=d[0]+A.width,d[2]=d[1]+A.width,M=d[2]+A.width;for(let X=0;X<A.width;++X){I+=y[d[0]++]<<24|y[d[1]++]<<16|y[d[2]++]<<8,F[g]=I,g++}}}return new DataView(F.buffer)}function C(A){const I=A.viewer,y={value:A.offset.value},X=new Uint16Array(A.width*A.scanlineBlockSize*(A.channels*A.type)),F=new Uint8Array(8192);let g=0;const d=new Array(A.channels);for(let M=0;M<A.channels;M++)d[M]={},d[M].start=g,d[M].end=d[M].start,d[M].nx=A.width,d[M].ny=A.lines,d[M].size=A.type,g+=d[M].nx*d[M].ny*d[M].size;const V=K(I,y),k=K(I,y);if(k>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(V<=k)for(let M=0;M<k-V+1;M++)F[M+V]=u(I,y);const U=new Uint16Array(M),P=function(A,I){let y=0;for(let F=0;F<M;++F)(0==F||A[F>>3]&1<<(7&F))&&(I[y++]=F);const X=y-1;for(;y<M;)I[y++]=0;return X}(F,U),f=l(I,y);J(A.array,I,y,f,X,g);for(let M=0;M<A.channels;++M){const A=d[M];for(let I=0;I<d[M].size;++I)e(X,A.start+I,A.nx,A.size,A.ny,A.nx*A.size,P)}!function(A,I,y){for(let X=0;X<y;++X)I[X]=A[I[X]]}(U,X,g);let z=0;const x=new Uint8Array(X.buffer.byteLength);for(let M=0;M<A.lines;M++)for(let I=0;I<A.channels;I++){const A=d[I],y=A.nx*A.size,F=new Uint8Array(X.buffer,2*A.end,2*y);x.set(F,z),z+=2*y,A.end+=y}return new DataView(x.buffer)}var c,h=y(1213);!function(A){A[A.Float=0]="Float",A[A.HalfFloat=1]="HalfFloat"}(c||(c={}));class Y{}Y.DefaultOutputType=c.HalfFloat,Y.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class O{constructor(){this.supportCascades=!1}loadCubeData(A,I,y,X,F){throw".exr not supported in Cube."}async loadData(A,I,y){const F=new DataView(A.buffer),M={value:0},g=function(A,I){if(20000630!=A.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const y=A.getUint8(4),F=A.getUint8(5),M={singleTile:!!(2&F),longName:!!(4&F),deepFormat:!!(8&F),multiPart:!!(16&F)};I.value=8;const g={};let d=!0;for(;d;){const y=f(A.buffer,I);if(y){const F=f(A.buffer,I),M=b(A,I,F,l(A,I));void 0===M?X.e.Warn(`Unknown header attribute type ${F}'.`):g[y]=M}else d=!1}if(0!=(-5&F))throw new Error("Unsupported file format");return{version:y,spec:M,...g}}(F,M),d=await async function(A,I,y,X){const F={size:0,viewer:I,array:new Uint8Array(I.buffer),offset:y,width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,channels:A.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(A.compression){case k.NO_COMPRESSION:F.lines=1,F.uncompress=H;break;case k.RLE_COMPRESSION:F.lines=1,F.uncompress=E;break;case k.ZIPS_COMPRESSION:F.lines=1,F.uncompress=i,await h.e.LoadScriptAsync(Y.FFLATEUrl);break;case k.ZIP_COMPRESSION:F.lines=16,F.uncompress=i,await h.e.LoadScriptAsync(Y.FFLATEUrl);break;case k.PIZ_COMPRESSION:F.lines=32,F.uncompress=C;break;case k.PXR24_COMPRESSION:F.lines=16,F.uncompress=o,await h.e.LoadScriptAsync(Y.FFLATEUrl);break;default:throw new Error(k[A.compression]+" is unsupported")}F.scanlineBlockSize=F.lines;const M={};for(const k of A.channels)switch(k.name){case"Y":case"R":case"G":case"B":case"A":M[k.name]=!0,F.type=k.pixelType}let g=!1;if(M.R&&M.G&&M.B)g=!M.A,F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else{if(!M.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");F.outputChannels=1,F.decodeChannels={Y:0}}if(1===F.type)switch(X){case c.Float:F.getter=R,F.inputSize=2;break;case c.HalfFloat:F.getter=K,F.inputSize=2}else{if(2!==F.type)throw new Error("Unsupported pixelType "+F.type+" for "+A.compression);switch(X){case c.Float:F.getter=N,F.inputSize=4;break;case c.HalfFloat:F.getter=Z,F.inputSize=4}}F.blockCount=F.height/F.scanlineBlockSize;for(let k=0;k<F.blockCount;k++)t(I,y);const d=F.width*F.height*F.outputChannels;switch(X){case c.Float:F.byteArray=new Float32Array(d),F.textureType=1,g&&F.byteArray.fill(1,0,d);break;case c.HalfFloat:F.byteArray=new Uint16Array(d),F.textureType=2,g&&F.byteArray.fill(15360,0,d);break;default:throw new Error("Unsupported type: "+X)}let V=0;for(const k of A.channels)void 0!==F.decodeChannels[k.name]&&(F.channelLineOffsets[k.name]=V*F.width),V+=2*k.pixelType;return F.bytesPerLine=F.width*V,F.outLineWidth=F.width*F.outputChannels,"INCREASING_Y"===A.lineOrder?F.scanOrder=A=>A:F.scanOrder=A=>F.height-1-A,4==F.outputChannels?(F.format=5,F.linearSpace=!0):(F.format=6,F.linearSpace=!1),F}(g,F,M,Y.DefaultOutputType);!function(A,I,y,X){const F={value:0};for(let M=0;M<A.height/A.scanlineBlockSize;M++){const g=z(y,X)-I.dataWindow.yMin;A.size=l(y,X),A.lines=g+A.scanlineBlockSize>A.height?A.height-g:A.scanlineBlockSize;const d=A.size<A.lines*A.bytesPerLine&&A.uncompress?A.uncompress(A):H(A);X.value+=A.size;for(let y=0;y<A.scanlineBlockSize;y++){const X=M*A.scanlineBlockSize,g=y+A.scanOrder(X);if(g>=A.height)continue;const V=y*A.bytesPerLine,k=(A.height-1-g)*A.outLineWidth;for(let y=0;y<A.channels;y++){const X=I.channels[y].name,M=A.channelLineOffsets[X],g=A.decodeChannels[X];if(void 0!==g){F.value=V+M;for(let I=0;I<A.width;I++){const y=k+I*A.outputChannels+g;A.byteArray&&(A.byteArray[y]=A.getter(d,F))}}}}}}(d,g,F,M);y(g.dataWindow.xMax-g.dataWindow.xMin+1,g.dataWindow.yMax-g.dataWindow.yMin+1,I.generateMipMaps,!1,(()=>{const A=I.getEngine();I.format=g.format,I.type=d.textureType,I.invertY=!1,I._gammaSpace=!g.linearSpace,d.byteArray&&A._uploadDataToTextureDirectly(I,d.byteArray,0,0,void 0,!0)}))}}}}]);