"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10727:(j,S,h)=>{h.r(S),h.d(S,{_ExrTextureLoader:()=>y});var m=h(1050),I=h(1005);const d=65536,U=14,f=65537,r=16384;var a,M;!function(j){j[j.NO_COMPRESSION=0]="NO_COMPRESSION",j[j.RLE_COMPRESSION=1]="RLE_COMPRESSION",j[j.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",j[j.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",j[j.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",j[j.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(j){j[j.INCREASING_Y=0]="INCREASING_Y",j[j.DECREASING_Y=1]="DECREASING_Y"}(M||(M={}));const O=function(){const j=new ArrayBuffer(4),S=new Float32Array(j),h=new Uint32Array(j),m=new Uint32Array(512),I=new Uint32Array(512);for(let r=0;r<256;++r){const j=r-127;j<-27?(m[r]=0,m[256|r]=32768,I[r]=24,I[256|r]=24):j<-14?(m[r]=1024>>-j-14,m[256|r]=1024>>-j-14|32768,I[r]=-j-1,I[256|r]=-j-1):j<=15?(m[r]=j+15<<10,m[256|r]=j+15<<10|32768,I[r]=13,I[256|r]=13):j<128?(m[r]=31744,m[256|r]=64512,I[r]=24,I[256|r]=24):(m[r]=31744,m[256|r]=64512,I[r]=13,I[256|r]=13)}const d=new Uint32Array(2048),U=new Uint32Array(64),f=new Uint32Array(64);for(let r=1;r<1024;++r){let j=r<<13,S=0;for(;0===(8388608&j);)j<<=1,S-=8388608;j&=-8388609,S+=947912704,d[r]=j|S}for(let r=1024;r<2048;++r)d[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)U[r]=r<<23;U[31]=1199570944,U[32]=2147483648;for(let r=33;r<63;++r)U[r]=2147483648+(r-32<<23);U[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(f[r]=1024);return{floatView:S,uint32View:h,baseTable:m,shiftTable:I,mantissaTable:d,exponentTable:U,offsetTable:f}}();function p(j,S){const h=new Uint8Array(j);let m=0;for(;0!=h[S.value+m];)m+=1;const I=(new TextDecoder).decode(h.slice(S.value,S.value+m));return S.value=S.value+m+1,I}function e(j,S){const h=j.getInt32(S.value,!0);return S.value+=4,h}function w(j,S){const h=j.getUint32(S.value,!0);return S.value+=4,h}function l(j,S){const h=j.getUint8(S.value);return S.value+=1,h}function P(j,S){const h=j.getUint16(S.value,!0);return S.value+=2,h}function v(j,S){const h=j[S.value];return S.value+=1,h}function o(j,S){let h;return h="getBigInt64"in DataView.prototype?Number(j.getBigInt64(S.value,!0)):j.getUint32(S.value+4,!0)+Number(j.getUint32(S.value,!0)<<32),S.value+=8,h}function R(j,S){const h=j.getFloat32(S.value,!0);return S.value+=4,h}function i(j,S){return function(j){const S=(31744&j)>>10,h=1023&j;return(j>>15?-1:1)*(S?31===S?h?NaN:1/0:Math.pow(2,S-15)*(1+h/1024):h/1024*6103515625e-14)}(P(j,S))}function N(j,S){return function(j){if(Math.abs(j)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");j=(0,I.d)(j,-65504,65504),O.floatView[0]=j;const S=O.uint32View[0],h=S>>23&511;return O.baseTable[h]+((8388607&S)>>O.shiftTable[h])}(R(j,S))}function u(j,S,h,m){switch(h){case"string":case"stringvector":case"iccProfile":return function(j,S,h){const m=(new TextDecoder).decode(new Uint8Array(j).slice(S.value,S.value+h));return S.value=S.value+h,m}(j.buffer,S,m);case"chlist":return function(j,S,h){const m=S.value,I=[];for(;S.value<m+h-1;){const h=p(j.buffer,S),m=e(j,S),d=l(j,S);S.value+=3;const U=e(j,S),f=e(j,S);I.push({name:h,pixelType:m,pLinear:d,xSampling:U,ySampling:f})}return S.value+=1,I}(j,S,m);case"chromaticities":return function(j,S){return{redX:R(j,S),redY:R(j,S),greenX:R(j,S),greenY:R(j,S),blueX:R(j,S),blueY:R(j,S),whiteX:R(j,S),whiteY:R(j,S)}}(j,S);case"compression":return function(j,S){return l(j,S)}(j,S);case"box2i":return function(j,S){return{xMin:e(j,S),yMin:e(j,S),xMax:e(j,S),yMax:e(j,S)}}(j,S);case"lineOrder":return function(j,S){const h=l(j,S);return M[h]}(j,S);case"float":return R(j,S);case"v2f":return function(j,S){return[R(j,S),R(j,S)]}(j,S);case"v3f":return function(j,S){return[R(j,S),R(j,S),R(j,S)]}(j,S);case"int":return e(j,S);case"rational":return function(j,S){return[e(j,S),w(j,S)]}(j,S);case"timecode":return function(j,S){return[w(j,S),w(j,S)]}(j,S);case"preview":return S.value+=m,"skipped";default:return void(S.value+=m)}}function x(j){for(let S=1;S<j.length;S++){const h=j[S-1]+j[S]-128;j[S]=h}}function K(j,S){let h=0,m=Math.floor((j.length+1)/2),I=0;const d=j.length-1;for(;!(I>d)&&(S[I++]=j[h++],!(I>d));)S[I++]=j[m++]}function k(j,S,h,m,I){for(;h<j;)S=S<<8|v(m,I),h+=8;return{l:S>>(h-=j)&(1<<j)-1,c:S,lc:h}}function q(j,S,h,m){return{c:j=j<<8|v(h,m),lc:S+=8}}function g(j,S,h,m,I,d,U,f,r){if(j==S){if(m<8){const j=q(h,m,I,d);h=j.c,m=j.lc}let j=h>>(m-=8);if(j=new Uint8Array([j])[0],f.value+j>r)return null;const S=U[f.value-1];for(;j-- >0;)U[f.value++]=S}else{if(!(f.value<r))return null;U[f.value++]=j}return{c:h,lc:m}}const D=new Array(59);function b(j,S,h,m,I,d){const U=S;let r=0,a=0;for(;m<=I;m++){if(U.value-S.value>h)return;let f=k(6,r,a,j,U);const M=f.l;if(r=f.c,a=f.lc,d[m]=M,63==M){if(U.value-S.value>h)throw new Error("Error in HufUnpackEncTable");f=k(8,r,a,j,U);let M=f.l+6;if(r=f.c,a=f.lc,m+M>I+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)d[m++]=0;m--}else if(M>=59){let j=M-59+2;if(m+j>I+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)d[m++]=0;m--}}!function(j){for(let h=0;h<=58;++h)D[h]=0;for(let h=0;h<f;++h)D[j[h]]+=1;let S=0;for(let h=58;h>0;--h){const j=S+D[h]>>1;D[h]=S,S=j}for(let h=0;h<f;++h){const S=j[h];S>0&&(j[h]=S|D[S]++<<6)}}(d)}function n(j){return 63&j}function s(j){return j>>6}function Z(j,S,h,m,I,d){const a=h.value,M=w(S,h),O=w(S,h);h.value+=4;const p=w(S,h);if(h.value+=4,M<0||M>=f||O<0||O>=f)throw new Error("Wrong HUF_ENCSIZE");const e=new Array(f),l=new Array(r);!function(j){for(let S=0;S<r;S++)j[S]={},j[S].len=0,j[S].lit=0,j[S].p=null}(l);if(b(j,h,m-(h.value-a),M,O,e),p>8*(m-(h.value-a)))throw new Error("Wrong hufUncompress");!function(j,S,h,m){for(;S<=h;S++){const h=s(j[S]),I=n(j[S]);if(h>>I)throw new Error("Invalid table entry");if(I>U){const j=m[h>>I-U];if(j.len)throw new Error("Invalid table entry");if(j.lit++,j.p){const S=j.p;j.p=new Array(j.lit);for(let h=0;h<j.lit-1;++h)j.p[h]=S[h]}else j.p=new Array(1);j.p[j.lit-1]=S}else if(I){let j=0;for(let d=1<<U-I;d>0;d--){const d=m[(h<<U-I)+j];if(d.len||d.p)throw new Error("Invalid table entry");d.len=I,d.lit=S,j++}}}}(e,M,O,l),function(j,S,h,m,I,d,f,r,a){let M=0,O=0;const p=f,e=Math.trunc(m.value+(I+7)/8);for(;m.value<e;){let I=q(M,O,h,m);for(M=I.c,O=I.lc;O>=U;){const f=S[M>>O-U&16383];if(f.len){O-=f.len;const j=g(f.lit,d,M,O,h,m,r,a,p);j&&(M=j.c,O=j.lc)}else{if(!f.p)throw new Error("hufDecode issues");let S;for(S=0;S<f.lit;S++){const U=n(j[f.p[S]]);for(;O<U&&m.value<e;)I=q(M,O,h,m),M=I.c,O=I.lc;if(O>=U&&s(j[f.p[S]])==(M>>O-U&(1<<U)-1)){O-=U;const j=g(f.p[S],d,M,O,h,m,r,a,p);j&&(M=j.c,O=j.lc);break}}if(S==f.lit)throw new Error("HufDecode issues")}}}const w=8-I&7;for(M>>=w,O-=w;O>0;){const j=S[M<<U-O&16383];if(!j.len)throw new Error("HufDecode issues");{O-=j.len;const S=g(j.lit,d,M,O,h,m,r,a,p);S&&(M=S.c,O=S.lc)}}}(e,l,j,h,p,O,d,I,{value:0})}function X(j){return 65535&j}function C(j){const S=X(j);return S>32767?S-65536:S}function E(j,S){const h=C(j),m=C(S),I=h+(1&m)+(m>>1);return{a:I,b:I-m}}function G(j,S){const h=X(j),m=X(S),I=h-(m>>1)&65535;return{a:m+I-32768&65535,b:I}}function c(j,S,h,m,I,d,U){const f=U<16384,r=h>I?I:h;let a,M,O=1;for(;O<=r;)O<<=1;for(O>>=1,a=O,O>>=1;O>=1;){M=0;const U=M+d*(I-a),r=d*O,p=d*a,e=m*O,w=m*a;let l,P,v,o;for(;M<=U;M+=p){let I=M;const d=M+m*(h-a);for(;I<=d;I+=w){const h=I+e,m=I+r,d=m+e;if(f){let U=E(j[I+S],j[m+S]);l=U.a,v=U.b,U=E(j[h+S],j[d+S]),P=U.a,o=U.b,U=E(l,P),j[I+S]=U.a,j[h+S]=U.b,U=E(v,o),j[m+S]=U.a,j[d+S]=U.b}else{let U=G(j[I+S],j[m+S]);l=U.a,v=U.b,U=G(j[h+S],j[d+S]),P=U.a,o=U.b,U=G(l,P),j[I+S]=U.a,j[h+S]=U.b,U=G(v,o),j[m+S]=U.a,j[d+S]=U.b}}if(h&O){const h=I+r;let m;m=f?E(j[I+S],j[h+S]):G(j[I+S],j[h+S]),l=m.a,j[h+S]=m.b,j[I+S]=l}}if(I&O){let I=M;const d=M+m*(h-a);for(;I<=d;I+=w){const h=I+e;let m;m=f?E(j[I+S],j[h+S]):G(j[I+S],j[h+S]),l=m.a,j[h+S]=m.b,j[I+S]=l}}a=O,O>>=1}return M}function B(j){return new DataView(j.array.buffer,j.offset.value,j.size)}function J(j){const S=j.viewer.buffer.slice(j.offset.value,j.offset.value+j.size),h=new Uint8Array(function(j){let S=j.byteLength;const h=new Array;let m=0;const I=new DataView(j);for(;S>0;){const j=I.getInt8(m++);if(j<0){const d=-j;S-=d+1;for(let j=0;j<d;j++)h.push(I.getUint8(m++))}else{const d=j;S-=2;const U=I.getUint8(m++);for(let j=0;j<d+1;j++)h.push(U)}}return h}(S)),m=new Uint8Array(h.length);return x(h),K(h,m),new DataView(m.buffer)}function H(j){const S=j.array.slice(j.offset.value,j.offset.value+j.size),h=fflate.unzlibSync(S),m=new Uint8Array(h.length);return x(h),K(h,m),new DataView(m.buffer)}function T(j){const S=j.array.slice(j.offset.value,j.offset.value+j.size),h=fflate.unzlibSync(S),m=j.lines*j.channels*j.width,I=1==j.type?new Uint16Array(m):new Uint32Array(m);let d=0,U=0;const f=new Array(4);for(let r=0;r<j.lines;r++)for(let S=0;S<j.channels;S++){let S=0;switch(j.type){case 1:f[0]=d,f[1]=f[0]+j.width,d=f[1]+j.width;for(let m=0;m<j.width;++m){S+=h[f[0]++]<<8|h[f[1]++],I[U]=S,U++}break;case 2:f[0]=d,f[1]=f[0]+j.width,f[2]=f[1]+j.width,d=f[2]+j.width;for(let m=0;m<j.width;++m){S+=h[f[0]++]<<24|h[f[1]++]<<16|h[f[2]++]<<8,I[U]=S,U++}}}return new DataView(I.buffer)}function Q(j){const S=j.viewer,h={value:j.offset.value},m=new Uint16Array(j.width*j.scanlineBlockSize*(j.channels*j.type)),I=new Uint8Array(8192);let U=0;const f=new Array(j.channels);for(let d=0;d<j.channels;d++)f[d]={},f[d].start=U,f[d].end=f[d].start,f[d].nx=j.width,f[d].ny=j.lines,f[d].size=j.type,U+=f[d].nx*f[d].ny*f[d].size;const r=P(S,h),a=P(S,h);if(a>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(r<=a)for(let d=0;d<a-r+1;d++)I[d+r]=l(S,h);const M=new Uint16Array(d),O=function(j,S){let h=0;for(let I=0;I<d;++I)(0==I||j[I>>3]&1<<(7&I))&&(S[h++]=I);const m=h-1;for(;h<d;)S[h++]=0;return m}(I,M),p=w(S,h);Z(j.array,S,h,p,m,U);for(let d=0;d<j.channels;++d){const j=f[d];for(let S=0;S<f[d].size;++S)c(m,j.start+S,j.nx,j.size,j.ny,j.nx*j.size,O)}!function(j,S,h){for(let m=0;m<h;++m)S[m]=j[S[m]]}(M,m,U);let e=0;const v=new Uint8Array(m.buffer.byteLength);for(let d=0;d<j.lines;d++)for(let S=0;S<j.channels;S++){const j=f[S],h=j.nx*j.size,I=new Uint8Array(m.buffer,2*j.end,2*h);v.set(I,e),e+=2*h,j.end+=h}return new DataView(v.buffer)}var Y,F=h(1166);!function(j){j[j.Float=0]="Float",j[j.HalfFloat=1]="HalfFloat"}(Y||(Y={}));class L{}L.DefaultOutputType=Y.HalfFloat,L.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class y{constructor(){this.supportCascades=!1}loadCubeData(j,S,h,m,I){throw".exr not supported in Cube."}async loadData(j,S,h){const I=new DataView(j.buffer),d={value:0},U=function(j,S){if(20000630!=j.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const h=j.getUint8(4),I=j.getUint8(5),d={singleTile:!!(2&I),longName:!!(4&I),deepFormat:!!(8&I),multiPart:!!(16&I)};S.value=8;const U={};let f=!0;for(;f;){const h=p(j.buffer,S);if(h){const I=p(j.buffer,S),d=u(j,S,I,w(j,S));void 0===d?m.b.Warn(`Unknown header attribute type ${I}'.`):U[h]=d}else f=!1}if(0!=(-5&I))throw new Error("Unsupported file format");return{version:h,spec:d,...U}}(I,d),f=await async function(j,S,h,m){const I={size:0,viewer:S,array:new Uint8Array(S.buffer),offset:h,width:j.dataWindow.xMax-j.dataWindow.xMin+1,height:j.dataWindow.yMax-j.dataWindow.yMin+1,channels:j.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(j.compression){case a.NO_COMPRESSION:I.lines=1,I.uncompress=B;break;case a.RLE_COMPRESSION:I.lines=1,I.uncompress=J;break;case a.ZIPS_COMPRESSION:I.lines=1,I.uncompress=H,await F.e.LoadScriptAsync(L.FFLATEUrl);break;case a.ZIP_COMPRESSION:I.lines=16,I.uncompress=H,await F.e.LoadScriptAsync(L.FFLATEUrl);break;case a.PIZ_COMPRESSION:I.lines=32,I.uncompress=Q;break;case a.PXR24_COMPRESSION:I.lines=16,I.uncompress=T,await F.e.LoadScriptAsync(L.FFLATEUrl);break;default:throw new Error(a[j.compression]+" is unsupported")}I.scanlineBlockSize=I.lines;const d={};for(const a of j.channels)switch(a.name){case"Y":case"R":case"G":case"B":case"A":d[a.name]=!0,I.type=a.pixelType}let U=!1;if(d.R&&d.G&&d.B)U=!d.A,I.outputChannels=4,I.decodeChannels={R:0,G:1,B:2,A:3};else{if(!d.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");I.outputChannels=1,I.decodeChannels={Y:0}}if(1===I.type)switch(m){case Y.Float:I.getter=i,I.inputSize=2;break;case Y.HalfFloat:I.getter=P,I.inputSize=2}else{if(2!==I.type)throw new Error("Unsupported pixelType "+I.type+" for "+j.compression);switch(m){case Y.Float:I.getter=R,I.inputSize=4;break;case Y.HalfFloat:I.getter=N,I.inputSize=4}}I.blockCount=I.height/I.scanlineBlockSize;for(let a=0;a<I.blockCount;a++)o(S,h);const f=I.width*I.height*I.outputChannels;switch(m){case Y.Float:I.byteArray=new Float32Array(f),I.textureType=1,U&&I.byteArray.fill(1,0,f);break;case Y.HalfFloat:I.byteArray=new Uint16Array(f),I.textureType=2,U&&I.byteArray.fill(15360,0,f);break;default:throw new Error("Unsupported type: "+m)}let r=0;for(const a of j.channels)void 0!==I.decodeChannels[a.name]&&(I.channelLineOffsets[a.name]=r*I.width),r+=2*a.pixelType;return I.bytesPerLine=I.width*r,I.outLineWidth=I.width*I.outputChannels,"INCREASING_Y"===j.lineOrder?I.scanOrder=j=>j:I.scanOrder=j=>I.height-1-j,4==I.outputChannels?(I.format=5,I.linearSpace=!0):(I.format=6,I.linearSpace=!1),I}(U,I,d,L.DefaultOutputType);!function(j,S,h,m){const I={value:0};for(let d=0;d<j.height/j.scanlineBlockSize;d++){const U=e(h,m)-S.dataWindow.yMin;j.size=w(h,m),j.lines=U+j.scanlineBlockSize>j.height?j.height-U:j.scanlineBlockSize;const f=j.size<j.lines*j.bytesPerLine&&j.uncompress?j.uncompress(j):B(j);m.value+=j.size;for(let h=0;h<j.scanlineBlockSize;h++){const m=d*j.scanlineBlockSize,U=h+j.scanOrder(m);if(U>=j.height)continue;const r=h*j.bytesPerLine,a=(j.height-1-U)*j.outLineWidth;for(let h=0;h<j.channels;h++){const m=S.channels[h].name,d=j.channelLineOffsets[m],U=j.decodeChannels[m];if(void 0!==U){I.value=r+d;for(let S=0;S<j.width;S++){const h=a+S*j.outputChannels+U;j.byteArray&&(j.byteArray[h]=j.getter(f,I))}}}}}}(f,U,I,d);h(U.dataWindow.xMax-U.dataWindow.xMin+1,U.dataWindow.yMax-U.dataWindow.yMin+1,S.generateMipMaps,!1,(()=>{const j=S.getEngine();S.format=U.format,S.type=f.textureType,S.invertY=!1,S._gammaSpace=!U.linearSpace,f.byteArray&&j._uploadDataToTextureDirectly(S,f.byteArray,0,0,void 0,!0)}))}}}}]);