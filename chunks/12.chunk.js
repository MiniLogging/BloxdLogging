"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{13025:(v,y,n)=>{n.r(y),n.d(y,{_DDSTextureLoader:()=>P});var B=n(11559),J=n(11576);class P{constructor(){this.supportCascades=!0}loadCubeData(v,y,n,P){const b=y.getEngine();let Y,l=!1,a=1e3;if(Array.isArray(v))for(let B=0;B<v.length;B++){const n=v[B];Y=J.e.GetDDSInfo(n),y.width=Y.width,y.height=Y.height,l=(Y.isRGB||Y.isLuminance||Y.mipmapCount>1)&&y.generateMipMaps,b._unpackFlipY(Y.isCompressed),J.e.UploadDDSLevels(b,y,n,Y,l,6,-1,B),Y.isFourCC||1!==Y.mipmapCount?a=Y.mipmapCount-1:b.generateMipMapsForCubemap(y)}else{const P=v;Y=J.e.GetDDSInfo(P),y.width=Y.width,y.height=Y.height,n&&(Y.sphericalPolynomial=new B.f),l=(Y.isRGB||Y.isLuminance||Y.mipmapCount>1)&&y.generateMipMaps,b._unpackFlipY(Y.isCompressed),J.e.UploadDDSLevels(b,y,P,Y,l,6),Y.isFourCC||1!==Y.mipmapCount?a=Y.mipmapCount-1:b.generateMipMapsForCubemap(y,!1)}b._setCubeMapTextureParams(y,l,a),y.isReady=!0,y.onLoadedObservable.notifyObservers(y),y.onLoadedObservable.clear(),P&&P({isDDS:!0,width:y.width,info:Y,data:v,texture:y})}loadData(v,y,n){const B=J.e.GetDDSInfo(v),P=(B.isRGB||B.isLuminance||B.mipmapCount>1)&&y.generateMipMaps&&Math.max(B.width,B.height)>>B.mipmapCount-1===1;n(B.width,B.height,P,B.isFourCC,(()=>{J.e.UploadDDSLevels(y.getEngine(),y,v,B,P,1)}))}}}}]);