"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10292:(f,Q,H)=>{H.r(Q),H.d(Q,{_ExrTextureLoader:()=>h});var X=H(1092),i=H(1034);const S=65536,x=14,K=65537,Z=16384;var B,N;!function(f){f[f.NO_COMPRESSION=0]="NO_COMPRESSION",f[f.RLE_COMPRESSION=1]="RLE_COMPRESSION",f[f.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",f[f.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",f[f.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",f[f.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(B||(B={})),function(f){f[f.INCREASING_Y=0]="INCREASING_Y",f[f.DECREASING_Y=1]="DECREASING_Y"}(N||(N={}));const J=function(){const f=new ArrayBuffer(4),Q=new Float32Array(f),H=new Uint32Array(f),X=new Uint32Array(512),i=new Uint32Array(512);for(let Z=0;Z<256;++Z){const f=Z-127;f<-27?(X[Z]=0,X[256|Z]=32768,i[Z]=24,i[256|Z]=24):f<-14?(X[Z]=1024>>-f-14,X[256|Z]=1024>>-f-14|32768,i[Z]=-f-1,i[256|Z]=-f-1):f<=15?(X[Z]=f+15<<10,X[256|Z]=f+15<<10|32768,i[Z]=13,i[256|Z]=13):f<128?(X[Z]=31744,X[256|Z]=64512,i[Z]=24,i[256|Z]=24):(X[Z]=31744,X[256|Z]=64512,i[Z]=13,i[256|Z]=13)}const S=new Uint32Array(2048),x=new Uint32Array(64),K=new Uint32Array(64);for(let Z=1;Z<1024;++Z){let f=Z<<13,Q=0;for(;0===(8388608&f);)f<<=1,Q-=8388608;f&=-8388609,Q+=947912704,S[Z]=f|Q}for(let Z=1024;Z<2048;++Z)S[Z]=939524096+(Z-1024<<13);for(let Z=1;Z<31;++Z)x[Z]=Z<<23;x[31]=1199570944,x[32]=2147483648;for(let Z=33;Z<63;++Z)x[Z]=2147483648+(Z-32<<23);x[63]=3347054592;for(let Z=1;Z<64;++Z)32!==Z&&(K[Z]=1024);return{floatView:Q,uint32View:H,baseTable:X,shiftTable:i,mantissaTable:S,exponentTable:x,offsetTable:K}}();function g(f,Q){const H=new Uint8Array(f);let X=0;for(;0!=H[Q.value+X];)X+=1;const i=(new TextDecoder).decode(H.slice(Q.value,Q.value+X));return Q.value=Q.value+X+1,i}function z(f,Q){const H=f.getInt32(Q.value,!0);return Q.value+=4,H}function v(f,Q){const H=f.getUint32(Q.value,!0);return Q.value+=4,H}function Y(f,Q){const H=f.getUint8(Q.value);return Q.value+=1,H}function O(f,Q){const H=f.getUint16(Q.value,!0);return Q.value+=2,H}function n(f,Q){const H=f[Q.value];return Q.value+=1,H}function e(f,Q){let H;return H="getBigInt64"in DataView.prototype?Number(f.getBigInt64(Q.value,!0)):f.getUint32(Q.value+4,!0)+Number(f.getUint32(Q.value,!0)<<32),Q.value+=8,H}function G(f,Q){const H=f.getFloat32(Q.value,!0);return Q.value+=4,H}function I(f,Q){return function(f){const Q=(31744&f)>>10,H=1023&f;return(f>>15?-1:1)*(Q?31===Q?H?NaN:1/0:Math.pow(2,Q-15)*(1+H/1024):H/1024*6103515625e-14)}(O(f,Q))}function l(f,Q){return function(f){if(Math.abs(f)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");f=(0,i.c)(f,-65504,65504),J.floatView[0]=f;const Q=J.uint32View[0],H=Q>>23&511;return J.baseTable[H]+((8388607&Q)>>J.shiftTable[H])}(G(f,Q))}function q(f,Q,H,X){switch(H){case"string":case"stringvector":case"iccProfile":return function(f,Q,H){const X=(new TextDecoder).decode(new Uint8Array(f).slice(Q.value,Q.value+H));return Q.value=Q.value+H,X}(f.buffer,Q,X);case"chlist":return function(f,Q,H){const X=Q.value,i=[];for(;Q.value<X+H-1;){const H=g(f.buffer,Q),X=z(f,Q),S=Y(f,Q);Q.value+=3;const x=z(f,Q),K=z(f,Q);i.push({name:H,pixelType:X,pLinear:S,xSampling:x,ySampling:K})}return Q.value+=1,i}(f,Q,X);case"chromaticities":return function(f,Q){return{redX:G(f,Q),redY:G(f,Q),greenX:G(f,Q),greenY:G(f,Q),blueX:G(f,Q),blueY:G(f,Q),whiteX:G(f,Q),whiteY:G(f,Q)}}(f,Q);case"compression":return function(f,Q){return Y(f,Q)}(f,Q);case"box2i":return function(f,Q){return{xMin:z(f,Q),yMin:z(f,Q),xMax:z(f,Q),yMax:z(f,Q)}}(f,Q);case"lineOrder":return function(f,Q){const H=Y(f,Q);return N[H]}(f,Q);case"float":return G(f,Q);case"v2f":return function(f,Q){return[G(f,Q),G(f,Q)]}(f,Q);case"v3f":return function(f,Q){return[G(f,Q),G(f,Q),G(f,Q)]}(f,Q);case"int":return z(f,Q);case"rational":return function(f,Q){return[z(f,Q),v(f,Q)]}(f,Q);case"timecode":return function(f,Q){return[v(f,Q),v(f,Q)]}(f,Q);case"preview":return Q.value+=X,"skipped";default:return void(Q.value+=X)}}function D(f){for(let Q=1;Q<f.length;Q++){const H=f[Q-1]+f[Q]-128;f[Q]=H}}function d(f,Q){let H=0,X=Math.floor((f.length+1)/2),i=0;const S=f.length-1;for(;!(i>S)&&(Q[i++]=f[H++],!(i>S));)Q[i++]=f[X++]}function s(f,Q,H,X,i){for(;H<f;)Q=Q<<8|n(X,i),H+=8;return{l:Q>>(H-=f)&(1<<f)-1,c:Q,lc:H}}function F(f,Q,H,X){return{c:f=f<<8|n(H,X),lc:Q+=8}}function P(f,Q,H,X,i,S,x,K,Z){if(f==Q){if(X<8){const f=F(H,X,i,S);H=f.c,X=f.lc}let f=H>>(X-=8);if(f=new Uint8Array([f])[0],K.value+f>Z)return null;const Q=x[K.value-1];for(;f-- >0;)x[K.value++]=Q}else{if(!(K.value<Z))return null;x[K.value++]=f}return{c:H,lc:X}}const m=new Array(59);function c(f,Q,H,X,i,S){const x=Q;let Z=0,B=0;for(;X<=i;X++){if(x.value-Q.value>H)return;let K=s(6,Z,B,f,x);const N=K.l;if(Z=K.c,B=K.lc,S[X]=N,63==N){if(x.value-Q.value>H)throw new Error("Error in HufUnpackEncTable");K=s(8,Z,B,f,x);let N=K.l+6;if(Z=K.c,B=K.lc,X+N>i+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)S[X++]=0;X--}else if(N>=59){let f=N-59+2;if(X+f>i+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)S[X++]=0;X--}}!function(f){for(let H=0;H<=58;++H)m[H]=0;for(let H=0;H<K;++H)m[f[H]]+=1;let Q=0;for(let H=58;H>0;--H){const f=Q+m[H]>>1;m[H]=Q,Q=f}for(let H=0;H<K;++H){const Q=f[H];Q>0&&(f[H]=Q|m[Q]++<<6)}}(S)}function W(f){return 63&f}function R(f){return f>>6}function U(f,Q,H,X,i,S){const B=H.value,N=v(Q,H),J=v(Q,H);H.value+=4;const g=v(Q,H);if(H.value+=4,N<0||N>=K||J<0||J>=K)throw new Error("Wrong HUF_ENCSIZE");const z=new Array(K),Y=new Array(Z);!function(f){for(let Q=0;Q<Z;Q++)f[Q]={},f[Q].len=0,f[Q].lit=0,f[Q].p=null}(Y);if(c(f,H,X-(H.value-B),N,J,z),g>8*(X-(H.value-B)))throw new Error("Wrong hufUncompress");!function(f,Q,H,X){for(;Q<=H;Q++){const H=R(f[Q]),i=W(f[Q]);if(H>>i)throw new Error("Invalid table entry");if(i>x){const f=X[H>>i-x];if(f.len)throw new Error("Invalid table entry");if(f.lit++,f.p){const Q=f.p;f.p=new Array(f.lit);for(let H=0;H<f.lit-1;++H)f.p[H]=Q[H]}else f.p=new Array(1);f.p[f.lit-1]=Q}else if(i){let f=0;for(let S=1<<x-i;S>0;S--){const S=X[(H<<x-i)+f];if(S.len||S.p)throw new Error("Invalid table entry");S.len=i,S.lit=Q,f++}}}}(z,N,J,Y),function(f,Q,H,X,i,S,K,Z,B){let N=0,J=0;const g=K,z=Math.trunc(X.value+(i+7)/8);for(;X.value<z;){let i=F(N,J,H,X);for(N=i.c,J=i.lc;J>=x;){const K=Q[N>>J-x&16383];if(K.len){J-=K.len;const f=P(K.lit,S,N,J,H,X,Z,B,g);f&&(N=f.c,J=f.lc)}else{if(!K.p)throw new Error("hufDecode issues");let Q;for(Q=0;Q<K.lit;Q++){const x=W(f[K.p[Q]]);for(;J<x&&X.value<z;)i=F(N,J,H,X),N=i.c,J=i.lc;if(J>=x&&R(f[K.p[Q]])==(N>>J-x&(1<<x)-1)){J-=x;const f=P(K.p[Q],S,N,J,H,X,Z,B,g);f&&(N=f.c,J=f.lc);break}}if(Q==K.lit)throw new Error("HufDecode issues")}}}const v=8-i&7;for(N>>=v,J-=v;J>0;){const f=Q[N<<x-J&16383];if(!f.len)throw new Error("HufDecode issues");{J-=f.len;const Q=P(f.lit,S,N,J,H,X,Z,B,g);Q&&(N=Q.c,J=Q.lc)}}}(z,Y,f,H,g,J,S,i,{value:0})}function E(f){return 65535&f}function t(f){const Q=E(f);return Q>32767?Q-65536:Q}function u(f,Q){const H=t(f),X=t(Q),i=H+(1&X)+(X>>1);return{a:i,b:i-X}}function L(f,Q){const H=E(f),X=E(Q),i=H-(X>>1)&65535;return{a:X+i-32768&65535,b:i}}function A(f,Q,H,X,i,S,x){const K=x<16384,Z=H>i?i:H;let B,N,J=1;for(;J<=Z;)J<<=1;for(J>>=1,B=J,J>>=1;J>=1;){N=0;const x=N+S*(i-B),Z=S*J,g=S*B,z=X*J,v=X*B;let Y,O,n,e;for(;N<=x;N+=g){let i=N;const S=N+X*(H-B);for(;i<=S;i+=v){const H=i+z,X=i+Z,S=X+z;if(K){let x=u(f[i+Q],f[X+Q]);Y=x.a,n=x.b,x=u(f[H+Q],f[S+Q]),O=x.a,e=x.b,x=u(Y,O),f[i+Q]=x.a,f[H+Q]=x.b,x=u(n,e),f[X+Q]=x.a,f[S+Q]=x.b}else{let x=L(f[i+Q],f[X+Q]);Y=x.a,n=x.b,x=L(f[H+Q],f[S+Q]),O=x.a,e=x.b,x=L(Y,O),f[i+Q]=x.a,f[H+Q]=x.b,x=L(n,e),f[X+Q]=x.a,f[S+Q]=x.b}}if(H&J){const H=i+Z;let X;X=K?u(f[i+Q],f[H+Q]):L(f[i+Q],f[H+Q]),Y=X.a,f[H+Q]=X.b,f[i+Q]=Y}}if(i&J){let i=N;const S=N+X*(H-B);for(;i<=S;i+=v){const H=i+z;let X;X=K?u(f[i+Q],f[H+Q]):L(f[i+Q],f[H+Q]),Y=X.a,f[H+Q]=X.b,f[i+Q]=Y}}B=J,J>>=1}return N}function a(f){return new DataView(f.array.buffer,f.offset.value,f.size)}function V(f){const Q=f.viewer.buffer.slice(f.offset.value,f.offset.value+f.size),H=new Uint8Array(function(f){let Q=f.byteLength;const H=new Array;let X=0;const i=new DataView(f);for(;Q>0;){const f=i.getInt8(X++);if(f<0){const S=-f;Q-=S+1;for(let f=0;f<S;f++)H.push(i.getUint8(X++))}else{const S=f;Q-=2;const x=i.getUint8(X++);for(let f=0;f<S+1;f++)H.push(x)}}return H}(Q)),X=new Uint8Array(H.length);return D(H),d(H,X),new DataView(X.buffer)}function M(f){const Q=f.array.slice(f.offset.value,f.offset.value+f.size),H=fflate.unzlibSync(Q),X=new Uint8Array(H.length);return D(H),d(H,X),new DataView(X.buffer)}function r(f){const Q=f.array.slice(f.offset.value,f.offset.value+f.size),H=fflate.unzlibSync(Q),X=f.lines*f.channels*f.width,i=1==f.type?new Uint16Array(X):new Uint32Array(X);let S=0,x=0;const K=new Array(4);for(let Z=0;Z<f.lines;Z++)for(let Q=0;Q<f.channels;Q++){let Q=0;switch(f.type){case 1:K[0]=S,K[1]=K[0]+f.width,S=K[1]+f.width;for(let X=0;X<f.width;++X){Q+=H[K[0]++]<<8|H[K[1]++],i[x]=Q,x++}break;case 2:K[0]=S,K[1]=K[0]+f.width,K[2]=K[1]+f.width,S=K[2]+f.width;for(let X=0;X<f.width;++X){Q+=H[K[0]++]<<24|H[K[1]++]<<16|H[K[2]++]<<8,i[x]=Q,x++}}}return new DataView(i.buffer)}function j(f){const Q=f.viewer,H={value:f.offset.value},X=new Uint16Array(f.width*f.scanlineBlockSize*(f.channels*f.type)),i=new Uint8Array(8192);let x=0;const K=new Array(f.channels);for(let S=0;S<f.channels;S++)K[S]={},K[S].start=x,K[S].end=K[S].start,K[S].nx=f.width,K[S].ny=f.lines,K[S].size=f.type,x+=K[S].nx*K[S].ny*K[S].size;const Z=O(Q,H),B=O(Q,H);if(B>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Z<=B)for(let S=0;S<B-Z+1;S++)i[S+Z]=Y(Q,H);const N=new Uint16Array(S),J=function(f,Q){let H=0;for(let i=0;i<S;++i)(0==i||f[i>>3]&1<<(7&i))&&(Q[H++]=i);const X=H-1;for(;H<S;)Q[H++]=0;return X}(i,N),g=v(Q,H);U(f.array,Q,H,g,X,x);for(let S=0;S<f.channels;++S){const f=K[S];for(let Q=0;Q<K[S].size;++Q)A(X,f.start+Q,f.nx,f.size,f.ny,f.nx*f.size,J)}!function(f,Q,H){for(let X=0;X<H;++X)Q[X]=f[Q[X]]}(N,X,x);let z=0;const n=new Uint8Array(X.buffer.byteLength);for(let S=0;S<f.lines;S++)for(let Q=0;Q<f.channels;Q++){const f=K[Q],H=f.nx*f.size,i=new Uint8Array(X.buffer,2*f.end,2*H);n.set(i,z),z+=2*H,f.end+=H}return new DataView(n.buffer)}var T,k=H(1203);!function(f){f[f.Float=0]="Float",f[f.HalfFloat=1]="HalfFloat"}(T||(T={}));class y{}y.DefaultOutputType=T.HalfFloat,y.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class h{constructor(){this.supportCascades=!1}loadCubeData(f,Q,H,X,i){throw".exr not supported in Cube."}async loadData(f,Q,H){const i=new DataView(f.buffer),S={value:0},x=function(f,Q){if(20000630!=f.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const H=f.getUint8(4),i=f.getUint8(5),S={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)};Q.value=8;const x={};let K=!0;for(;K;){const H=g(f.buffer,Q);if(H){const i=g(f.buffer,Q),S=q(f,Q,i,v(f,Q));void 0===S?X.b.Warn(`Unknown header attribute type ${i}'.`):x[H]=S}else K=!1}if(0!=(-5&i))throw new Error("Unsupported file format");return{version:H,spec:S,...x}}(i,S),K=await async function(f,Q,H,X){const i={size:0,viewer:Q,array:new Uint8Array(Q.buffer),offset:H,width:f.dataWindow.xMax-f.dataWindow.xMin+1,height:f.dataWindow.yMax-f.dataWindow.yMin+1,channels:f.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(f.compression){case B.NO_COMPRESSION:i.lines=1,i.uncompress=a;break;case B.RLE_COMPRESSION:i.lines=1,i.uncompress=V;break;case B.ZIPS_COMPRESSION:i.lines=1,i.uncompress=M,await k.g.LoadScriptAsync(y.FFLATEUrl);break;case B.ZIP_COMPRESSION:i.lines=16,i.uncompress=M,await k.g.LoadScriptAsync(y.FFLATEUrl);break;case B.PIZ_COMPRESSION:i.lines=32,i.uncompress=j;break;case B.PXR24_COMPRESSION:i.lines=16,i.uncompress=r,await k.g.LoadScriptAsync(y.FFLATEUrl);break;default:throw new Error(B[f.compression]+" is unsupported")}i.scanlineBlockSize=i.lines;const S={};for(const B of f.channels)switch(B.name){case"Y":case"R":case"G":case"B":case"A":S[B.name]=!0,i.type=B.pixelType}let x=!1;if(S.R&&S.G&&S.B)x=!S.A,i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else{if(!S.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");i.outputChannels=1,i.decodeChannels={Y:0}}if(1===i.type)switch(X){case T.Float:i.getter=I,i.inputSize=2;break;case T.HalfFloat:i.getter=O,i.inputSize=2}else{if(2!==i.type)throw new Error("Unsupported pixelType "+i.type+" for "+f.compression);switch(X){case T.Float:i.getter=G,i.inputSize=4;break;case T.HalfFloat:i.getter=l,i.inputSize=4}}i.blockCount=i.height/i.scanlineBlockSize;for(let B=0;B<i.blockCount;B++)e(Q,H);const K=i.width*i.height*i.outputChannels;switch(X){case T.Float:i.byteArray=new Float32Array(K),i.textureType=1,x&&i.byteArray.fill(1,0,K);break;case T.HalfFloat:i.byteArray=new Uint16Array(K),i.textureType=2,x&&i.byteArray.fill(15360,0,K);break;default:throw new Error("Unsupported type: "+X)}let Z=0;for(const B of f.channels)void 0!==i.decodeChannels[B.name]&&(i.channelLineOffsets[B.name]=Z*i.width),Z+=2*B.pixelType;return i.bytesPerLine=i.width*Z,i.outLineWidth=i.width*i.outputChannels,"INCREASING_Y"===f.lineOrder?i.scanOrder=f=>f:i.scanOrder=f=>i.height-1-f,4==i.outputChannels?(i.format=5,i.linearSpace=!0):(i.format=6,i.linearSpace=!1),i}(x,i,S,y.DefaultOutputType);!function(f,Q,H,X){const i={value:0};for(let S=0;S<f.height/f.scanlineBlockSize;S++){const x=z(H,X)-Q.dataWindow.yMin;f.size=v(H,X),f.lines=x+f.scanlineBlockSize>f.height?f.height-x:f.scanlineBlockSize;const K=f.size<f.lines*f.bytesPerLine&&f.uncompress?f.uncompress(f):a(f);X.value+=f.size;for(let H=0;H<f.scanlineBlockSize;H++){const X=S*f.scanlineBlockSize,x=H+f.scanOrder(X);if(x>=f.height)continue;const Z=H*f.bytesPerLine,B=(f.height-1-x)*f.outLineWidth;for(let H=0;H<f.channels;H++){const X=Q.channels[H].name,S=f.channelLineOffsets[X],x=f.decodeChannels[X];if(void 0!==x){i.value=Z+S;for(let Q=0;Q<f.width;Q++){const H=B+Q*f.outputChannels+x;f.byteArray&&(f.byteArray[H]=f.getter(K,i))}}}}}}(K,x,i,S);H(x.dataWindow.xMax-x.dataWindow.xMin+1,x.dataWindow.yMax-x.dataWindow.yMin+1,Q.generateMipMaps,!1,(()=>{const f=Q.getEngine();Q.format=x.format,Q.type=K.textureType,Q.invertY=!1,Q._gammaSpace=!x.linearSpace,K.byteArray&&f._uploadDataToTextureDirectly(Q,K.byteArray,0,0,void 0,!0)}))}}}}]);