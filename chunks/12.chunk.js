"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{11114:(f,H,Q)=>{Q.r(H),Q.d(H,{_ExrTextureLoader:()=>i});var a=Q(1093),d=Q(1026);const s=65536,n=14,e=65537,c=16384;var J,u;!function(f){f[f.NO_COMPRESSION=0]="NO_COMPRESSION",f[f.RLE_COMPRESSION=1]="RLE_COMPRESSION",f[f.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",f[f.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",f[f.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",f[f.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(J||(J={})),function(f){f[f.INCREASING_Y=0]="INCREASING_Y",f[f.DECREASING_Y=1]="DECREASING_Y"}(u||(u={}));const Y=function(){const f=new ArrayBuffer(4),H=new Float32Array(f),Q=new Uint32Array(f),a=new Uint32Array(512),d=new Uint32Array(512);for(let c=0;c<256;++c){const f=c-127;f<-27?(a[c]=0,a[256|c]=32768,d[c]=24,d[256|c]=24):f<-14?(a[c]=1024>>-f-14,a[256|c]=1024>>-f-14|32768,d[c]=-f-1,d[256|c]=-f-1):f<=15?(a[c]=f+15<<10,a[256|c]=f+15<<10|32768,d[c]=13,d[256|c]=13):f<128?(a[c]=31744,a[256|c]=64512,d[c]=24,d[256|c]=24):(a[c]=31744,a[256|c]=64512,d[c]=13,d[256|c]=13)}const s=new Uint32Array(2048),n=new Uint32Array(64),e=new Uint32Array(64);for(let c=1;c<1024;++c){let f=c<<13,H=0;for(;0===(8388608&f);)f<<=1,H-=8388608;f&=-8388609,H+=947912704,s[c]=f|H}for(let c=1024;c<2048;++c)s[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)n[c]=c<<23;n[31]=1199570944,n[32]=2147483648;for(let c=33;c<63;++c)n[c]=2147483648+(c-32<<23);n[63]=3347054592;for(let c=1;c<64;++c)32!==c&&(e[c]=1024);return{floatView:H,uint32View:Q,baseTable:a,shiftTable:d,mantissaTable:s,exponentTable:n,offsetTable:e}}();function k(f,H){const Q=new Uint8Array(f);let a=0;for(;0!=Q[H.value+a];)a+=1;const d=(new TextDecoder).decode(Q.slice(H.value,H.value+a));return H.value=H.value+a+1,d}function X(f,H){const Q=f.getInt32(H.value,!0);return H.value+=4,Q}function F(f,H){const Q=f.getUint32(H.value,!0);return H.value+=4,Q}function r(f,H){const Q=f.getUint8(H.value);return H.value+=1,Q}function v(f,H){const Q=f.getUint16(H.value,!0);return H.value+=2,Q}function S(f,H){const Q=f[H.value];return H.value+=1,Q}function M(f,H){let Q;return Q="getBigInt64"in DataView.prototype?Number(f.getBigInt64(H.value,!0)):f.getUint32(H.value+4,!0)+Number(f.getUint32(H.value,!0)<<32),H.value+=8,Q}function q(f,H){const Q=f.getFloat32(H.value,!0);return H.value+=4,Q}function z(f,H){return function(f){const H=(31744&f)>>10,Q=1023&f;return(f>>15?-1:1)*(H?31===H?Q?NaN:1/0:Math.pow(2,H-15)*(1+Q/1024):Q/1024*6103515625e-14)}(v(f,H))}function I(f,H){return function(f){if(Math.abs(f)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");f=(0,d.b)(f,-65504,65504),Y.floatView[0]=f;const H=Y.uint32View[0],Q=H>>23&511;return Y.baseTable[Q]+((8388607&H)>>Y.shiftTable[Q])}(q(f,H))}function p(f,H,Q,a){switch(Q){case"string":case"stringvector":case"iccProfile":return function(f,H,Q){const a=(new TextDecoder).decode(new Uint8Array(f).slice(H.value,H.value+Q));return H.value=H.value+Q,a}(f.buffer,H,a);case"chlist":return function(f,H,Q){const a=H.value,d=[];for(;H.value<a+Q-1;){const Q=k(f.buffer,H),a=X(f,H),s=r(f,H);H.value+=3;const n=X(f,H),e=X(f,H);d.push({name:Q,pixelType:a,pLinear:s,xSampling:n,ySampling:e})}return H.value+=1,d}(f,H,a);case"chromaticities":return function(f,H){return{redX:q(f,H),redY:q(f,H),greenX:q(f,H),greenY:q(f,H),blueX:q(f,H),blueY:q(f,H),whiteX:q(f,H),whiteY:q(f,H)}}(f,H);case"compression":return function(f,H){return r(f,H)}(f,H);case"box2i":return function(f,H){return{xMin:X(f,H),yMin:X(f,H),xMax:X(f,H),yMax:X(f,H)}}(f,H);case"lineOrder":return function(f,H){const Q=r(f,H);return u[Q]}(f,H);case"float":return q(f,H);case"v2f":return function(f,H){return[q(f,H),q(f,H)]}(f,H);case"v3f":return function(f,H){return[q(f,H),q(f,H),q(f,H)]}(f,H);case"int":return X(f,H);case"rational":return function(f,H){return[X(f,H),F(f,H)]}(f,H);case"timecode":return function(f,H){return[F(f,H),F(f,H)]}(f,H);case"preview":return H.value+=a,"skipped";default:return void(H.value+=a)}}function G(f){for(let H=1;H<f.length;H++){const Q=f[H-1]+f[H]-128;f[H]=Q}}function D(f,H){let Q=0,a=Math.floor((f.length+1)/2),d=0;const s=f.length-1;for(;!(d>s)&&(H[d++]=f[Q++],!(d>s));)H[d++]=f[a++]}function h(f,H,Q,a,d){for(;Q<f;)H=H<<8|S(a,d),Q+=8;return{l:H>>(Q-=f)&(1<<f)-1,c:H,lc:Q}}function w(f,H,Q,a){return{c:f=f<<8|S(Q,a),lc:H+=8}}function y(f,H,Q,a,d,s,n,e,c){if(f==H){if(a<8){const f=w(Q,a,d,s);Q=f.c,a=f.lc}let f=Q>>(a-=8);if(f=new Uint8Array([f])[0],e.value+f>c)return null;const H=n[e.value-1];for(;f-- >0;)n[e.value++]=H}else{if(!(e.value<c))return null;n[e.value++]=f}return{c:Q,lc:a}}const P=new Array(59);function R(f,H,Q,a,d,s){const n=H;let c=0,J=0;for(;a<=d;a++){if(n.value-H.value>Q)return;let e=h(6,c,J,f,n);const u=e.l;if(c=e.c,J=e.lc,s[a]=u,63==u){if(n.value-H.value>Q)throw new Error("Error in HufUnpackEncTable");e=h(8,c,J,f,n);let u=e.l+6;if(c=e.c,J=e.lc,a+u>d+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)s[a++]=0;a--}else if(u>=59){let f=u-59+2;if(a+f>d+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)s[a++]=0;a--}}!function(f){for(let Q=0;Q<=58;++Q)P[Q]=0;for(let Q=0;Q<e;++Q)P[f[Q]]+=1;let H=0;for(let Q=58;Q>0;--Q){const f=H+P[Q]>>1;P[Q]=H,H=f}for(let Q=0;Q<e;++Q){const H=f[Q];H>0&&(f[Q]=H|P[H]++<<6)}}(s)}function E(f){return 63&f}function g(f){return f>>6}function K(f,H,Q,a,d,s){const J=Q.value,u=F(H,Q),Y=F(H,Q);Q.value+=4;const k=F(H,Q);if(Q.value+=4,u<0||u>=e||Y<0||Y>=e)throw new Error("Wrong HUF_ENCSIZE");const X=new Array(e),r=new Array(c);!function(f){for(let H=0;H<c;H++)f[H]={},f[H].len=0,f[H].lit=0,f[H].p=null}(r);if(R(f,Q,a-(Q.value-J),u,Y,X),k>8*(a-(Q.value-J)))throw new Error("Wrong hufUncompress");!function(f,H,Q,a){for(;H<=Q;H++){const Q=g(f[H]),d=E(f[H]);if(Q>>d)throw new Error("Invalid table entry");if(d>n){const f=a[Q>>d-n];if(f.len)throw new Error("Invalid table entry");if(f.lit++,f.p){const H=f.p;f.p=new Array(f.lit);for(let Q=0;Q<f.lit-1;++Q)f.p[Q]=H[Q]}else f.p=new Array(1);f.p[f.lit-1]=H}else if(d){let f=0;for(let s=1<<n-d;s>0;s--){const s=a[(Q<<n-d)+f];if(s.len||s.p)throw new Error("Invalid table entry");s.len=d,s.lit=H,f++}}}}(X,u,Y,r),function(f,H,Q,a,d,s,e,c,J){let u=0,Y=0;const k=e,X=Math.trunc(a.value+(d+7)/8);for(;a.value<X;){let d=w(u,Y,Q,a);for(u=d.c,Y=d.lc;Y>=n;){const e=H[u>>Y-n&16383];if(e.len){Y-=e.len;const f=y(e.lit,s,u,Y,Q,a,c,J,k);f&&(u=f.c,Y=f.lc)}else{if(!e.p)throw new Error("hufDecode issues");let H;for(H=0;H<e.lit;H++){const n=E(f[e.p[H]]);for(;Y<n&&a.value<X;)d=w(u,Y,Q,a),u=d.c,Y=d.lc;if(Y>=n&&g(f[e.p[H]])==(u>>Y-n&(1<<n)-1)){Y-=n;const f=y(e.p[H],s,u,Y,Q,a,c,J,k);f&&(u=f.c,Y=f.lc);break}}if(H==e.lit)throw new Error("HufDecode issues")}}}const F=8-d&7;for(u>>=F,Y-=F;Y>0;){const f=H[u<<n-Y&16383];if(!f.len)throw new Error("HufDecode issues");{Y-=f.len;const H=y(f.lit,s,u,Y,Q,a,c,J,k);H&&(u=H.c,Y=H.lc)}}}(X,r,f,Q,k,Y,s,d,{value:0})}function b(f){return 65535&f}function l(f){const H=b(f);return H>32767?H-65536:H}function V(f,H){const Q=l(f),a=l(H),d=Q+(1&a)+(a>>1);return{a:d,b:d-a}}function C(f,H){const Q=b(f),a=b(H),d=Q-(a>>1)&65535;return{a:a+d-32768&65535,b:d}}function m(f,H,Q,a,d,s,n){const e=n<16384,c=Q>d?d:Q;let J,u,Y=1;for(;Y<=c;)Y<<=1;for(Y>>=1,J=Y,Y>>=1;Y>=1;){u=0;const n=u+s*(d-J),c=s*Y,k=s*J,X=a*Y,F=a*J;let r,v,S,M;for(;u<=n;u+=k){let d=u;const s=u+a*(Q-J);for(;d<=s;d+=F){const Q=d+X,a=d+c,s=a+X;if(e){let n=V(f[d+H],f[a+H]);r=n.a,S=n.b,n=V(f[Q+H],f[s+H]),v=n.a,M=n.b,n=V(r,v),f[d+H]=n.a,f[Q+H]=n.b,n=V(S,M),f[a+H]=n.a,f[s+H]=n.b}else{let n=C(f[d+H],f[a+H]);r=n.a,S=n.b,n=C(f[Q+H],f[s+H]),v=n.a,M=n.b,n=C(r,v),f[d+H]=n.a,f[Q+H]=n.b,n=C(S,M),f[a+H]=n.a,f[s+H]=n.b}}if(Q&Y){const Q=d+c;let a;a=e?V(f[d+H],f[Q+H]):C(f[d+H],f[Q+H]),r=a.a,f[Q+H]=a.b,f[d+H]=r}}if(d&Y){let d=u;const s=u+a*(Q-J);for(;d<=s;d+=F){const Q=d+X;let a;a=e?V(f[d+H],f[Q+H]):C(f[d+H],f[Q+H]),r=a.a,f[Q+H]=a.b,f[d+H]=r}}J=Y,Y>>=1}return u}function L(f){return new DataView(f.array.buffer,f.offset.value,f.size)}function B(f){const H=f.viewer.buffer.slice(f.offset.value,f.offset.value+f.size),Q=new Uint8Array(function(f){let H=f.byteLength;const Q=new Array;let a=0;const d=new DataView(f);for(;H>0;){const f=d.getInt8(a++);if(f<0){const s=-f;H-=s+1;for(let f=0;f<s;f++)Q.push(d.getUint8(a++))}else{const s=f;H-=2;const n=d.getUint8(a++);for(let f=0;f<s+1;f++)Q.push(n)}}return Q}(H)),a=new Uint8Array(Q.length);return G(Q),D(Q,a),new DataView(a.buffer)}function O(f){const H=f.array.slice(f.offset.value,f.offset.value+f.size),Q=fflate.unzlibSync(H),a=new Uint8Array(Q.length);return G(Q),D(Q,a),new DataView(a.buffer)}function t(f){const H=f.array.slice(f.offset.value,f.offset.value+f.size),Q=fflate.unzlibSync(H),a=f.lines*f.channels*f.width,d=1==f.type?new Uint16Array(a):new Uint32Array(a);let s=0,n=0;const e=new Array(4);for(let c=0;c<f.lines;c++)for(let H=0;H<f.channels;H++){let H=0;switch(f.type){case 1:e[0]=s,e[1]=e[0]+f.width,s=e[1]+f.width;for(let a=0;a<f.width;++a){H+=Q[e[0]++]<<8|Q[e[1]++],d[n]=H,n++}break;case 2:e[0]=s,e[1]=e[0]+f.width,e[2]=e[1]+f.width,s=e[2]+f.width;for(let a=0;a<f.width;++a){H+=Q[e[0]++]<<24|Q[e[1]++]<<16|Q[e[2]++]<<8,d[n]=H,n++}}}return new DataView(d.buffer)}function Z(f){const H=f.viewer,Q={value:f.offset.value},a=new Uint16Array(f.width*f.scanlineBlockSize*(f.channels*f.type)),d=new Uint8Array(8192);let n=0;const e=new Array(f.channels);for(let s=0;s<f.channels;s++)e[s]={},e[s].start=n,e[s].end=e[s].start,e[s].nx=f.width,e[s].ny=f.lines,e[s].size=f.type,n+=e[s].nx*e[s].ny*e[s].size;const c=v(H,Q),J=v(H,Q);if(J>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(c<=J)for(let s=0;s<J-c+1;s++)d[s+c]=r(H,Q);const u=new Uint16Array(s),Y=function(f,H){let Q=0;for(let d=0;d<s;++d)(0==d||f[d>>3]&1<<(7&d))&&(H[Q++]=d);const a=Q-1;for(;Q<s;)H[Q++]=0;return a}(d,u),k=F(H,Q);K(f.array,H,Q,k,a,n);for(let s=0;s<f.channels;++s){const f=e[s];for(let H=0;H<e[s].size;++H)m(a,f.start+H,f.nx,f.size,f.ny,f.nx*f.size,Y)}!function(f,H,Q){for(let a=0;a<Q;++a)H[a]=f[H[a]]}(u,a,n);let X=0;const S=new Uint8Array(a.buffer.byteLength);for(let s=0;s<f.lines;s++)for(let H=0;H<f.channels;H++){const f=e[H],Q=f.nx*f.size,d=new Uint8Array(a.buffer,2*f.end,2*Q);S.set(d,X),X+=2*Q,f.end+=Q}return new DataView(S.buffer)}var A,T=Q(1220);!function(f){f[f.Float=0]="Float",f[f.HalfFloat=1]="HalfFloat"}(A||(A={}));class U{}U.DefaultOutputType=A.HalfFloat,U.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class i{constructor(){this.supportCascades=!1}loadCubeData(f,H,Q,a,d){throw".exr not supported in Cube."}async loadData(f,H,Q){const d=new DataView(f.buffer),s={value:0},n=function(f,H){if(20000630!=f.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Q=f.getUint8(4),d=f.getUint8(5),s={singleTile:!!(2&d),longName:!!(4&d),deepFormat:!!(8&d),multiPart:!!(16&d)};H.value=8;const n={};let e=!0;for(;e;){const Q=k(f.buffer,H);if(Q){const d=k(f.buffer,H),s=p(f,H,d,F(f,H));void 0===s?a.c.Warn(`Unknown header attribute type ${d}'.`):n[Q]=s}else e=!1}if(0!=(-5&d))throw new Error("Unsupported file format");return{version:Q,spec:s,...n}}(d,s),e=await async function(f,H,Q,a){const d={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:Q,width:f.dataWindow.xMax-f.dataWindow.xMin+1,height:f.dataWindow.yMax-f.dataWindow.yMin+1,channels:f.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(f.compression){case J.NO_COMPRESSION:d.lines=1,d.uncompress=L;break;case J.RLE_COMPRESSION:d.lines=1,d.uncompress=B;break;case J.ZIPS_COMPRESSION:d.lines=1,d.uncompress=O,await T.e.LoadScriptAsync(U.FFLATEUrl);break;case J.ZIP_COMPRESSION:d.lines=16,d.uncompress=O,await T.e.LoadScriptAsync(U.FFLATEUrl);break;case J.PIZ_COMPRESSION:d.lines=32,d.uncompress=Z;break;case J.PXR24_COMPRESSION:d.lines=16,d.uncompress=t,await T.e.LoadScriptAsync(U.FFLATEUrl);break;default:throw new Error(J[f.compression]+" is unsupported")}d.scanlineBlockSize=d.lines;const s={};for(const J of f.channels)switch(J.name){case"Y":case"R":case"G":case"B":case"A":s[J.name]=!0,d.type=J.pixelType}let n=!1;if(s.R&&s.G&&s.B)n=!s.A,d.outputChannels=4,d.decodeChannels={R:0,G:1,B:2,A:3};else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");d.outputChannels=1,d.decodeChannels={Y:0}}if(1===d.type)switch(a){case A.Float:d.getter=z,d.inputSize=2;break;case A.HalfFloat:d.getter=v,d.inputSize=2}else{if(2!==d.type)throw new Error("Unsupported pixelType "+d.type+" for "+f.compression);switch(a){case A.Float:d.getter=q,d.inputSize=4;break;case A.HalfFloat:d.getter=I,d.inputSize=4}}d.blockCount=d.height/d.scanlineBlockSize;for(let J=0;J<d.blockCount;J++)M(H,Q);const e=d.width*d.height*d.outputChannels;switch(a){case A.Float:d.byteArray=new Float32Array(e),d.textureType=1,n&&d.byteArray.fill(1,0,e);break;case A.HalfFloat:d.byteArray=new Uint16Array(e),d.textureType=2,n&&d.byteArray.fill(15360,0,e);break;default:throw new Error("Unsupported type: "+a)}let c=0;for(const J of f.channels)void 0!==d.decodeChannels[J.name]&&(d.channelLineOffsets[J.name]=c*d.width),c+=2*J.pixelType;return d.bytesPerLine=d.width*c,d.outLineWidth=d.width*d.outputChannels,"INCREASING_Y"===f.lineOrder?d.scanOrder=f=>f:d.scanOrder=f=>d.height-1-f,4==d.outputChannels?(d.format=5,d.linearSpace=!0):(d.format=6,d.linearSpace=!1),d}(n,d,s,U.DefaultOutputType);!function(f,H,Q,a){const d={value:0};for(let s=0;s<f.height/f.scanlineBlockSize;s++){const n=X(Q,a)-H.dataWindow.yMin;f.size=F(Q,a),f.lines=n+f.scanlineBlockSize>f.height?f.height-n:f.scanlineBlockSize;const e=f.size<f.lines*f.bytesPerLine&&f.uncompress?f.uncompress(f):L(f);a.value+=f.size;for(let Q=0;Q<f.scanlineBlockSize;Q++){const a=s*f.scanlineBlockSize,n=Q+f.scanOrder(a);if(n>=f.height)continue;const c=Q*f.bytesPerLine,J=(f.height-1-n)*f.outLineWidth;for(let Q=0;Q<f.channels;Q++){const a=H.channels[Q].name,s=f.channelLineOffsets[a],n=f.decodeChannels[a];if(void 0!==n){d.value=c+s;for(let H=0;H<f.width;H++){const Q=J+H*f.outputChannels+n;f.byteArray&&(f.byteArray[Q]=f.getter(e,d))}}}}}}(e,n,d,s);Q(n.dataWindow.xMax-n.dataWindow.xMin+1,n.dataWindow.yMax-n.dataWindow.yMin+1,H.generateMipMaps,!1,(()=>{const f=H.getEngine();H.format=n.format,H.type=e.textureType,H.invertY=!1,H._gammaSpace=!n.linearSpace,e.byteArray&&f._uploadDataToTextureDirectly(H,e.byteArray,0,0,void 0,!0)}))}}}}]);