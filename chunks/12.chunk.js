"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[12,20],{11360:(P,e,n)=>{n.r(e),n.d(e,{Dispose:()=>A,DumpData:()=>q,DumpDataAsync:()=>R,DumpFramebuffer:()=>C,DumpTools:()=>F});var H=n(11245),S=n(10972),p=n(11148),k=n(11017);let m,t=null;async function C(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",p=arguments.length>5?arguments[5]:void 0,k=arguments.length>6?arguments[6]:void 0;const m=await n.readPixels(0,0,P,e);q(P,e,new Uint8Array(m.buffer),H,S,p,!0,void 0,k)}async function R(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",S=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6&&void 0!==arguments[6]&&arguments[6],m=arguments.length>7?arguments[7]:void 0;return await new Promise((t=>{q(P,e,n,(P=>t(P)),H,S,p,k,m)}))}function q(P,e,C,R){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",F=arguments.length>5?arguments[5]:void 0,Y=arguments.length>6&&void 0!==arguments[6]&&arguments[6],j=arguments.length>7&&void 0!==arguments[7]&&arguments[7],z=arguments.length>8?arguments[8]:void 0;(async function(){return t||(t=new Promise(((P,e)=>{let S,p=null;const t={o:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(n.bind(n,11274)).then((C=>{let{ThinEngine:R}=C;const q=k.d.Instances.length;try{S=new OffscreenCanvas(100,100),p=new R(S,!1,t)}catch(j){var F;q<k.d.Instances.length&&(null===(F=k.d.Instances.pop())||void 0===F||F.dispose()),S=document.createElement("canvas"),p=new R(S,!1,t)}k.d.Instances.pop(),k.d.OnEnginesDisposedObservable.add((P=>{p&&P!==p&&!p.C&&0===k.d.Instances.length&&A()})),p.getCaps().parallelShaderCompile=void 0;const Y=new H.b(p);n.e(52).then(n.bind(n,13572)).then((n=>{let{passPixelShader:k}=n;if(!p)return void e("Engine is not defined");const t=new H.d({Je:p,name:k.name,fragmentShader:k.shader,samplerNames:["textureSampler"]});m={canvas:S,Je:p,renderer:Y,wrapper:t},P(m)}))})).catch(e)}))),await t})().then((n=>{if(n.Je.setSize(P,e,!0),C instanceof Float32Array){const P=new Uint8Array(C.length);let e=C.length;for(;e--;){const n=C[e];P[e]=Math.round(255*(0,p.Clamp)(n))}C=P}const H=n.Je.createRawTexture(C,P,e,5,!1,!Y,1);n.renderer.setViewport(),n.renderer.applyEffectWrapper(n.wrapper),n.wrapper.effect._bindTexture("textureSampler",H),n.renderer.draw(),j?S.Tools.ToBlob(n.canvas,(P=>{const e=new FileReader;e.onload=P=>{const e=P.target.result;R&&R(e)},e.readAsArrayBuffer(P)}),q,z):S.Tools.EncodeScreenshotCanvasData(n.canvas,R,q,F,z),H.dispose()}))}function A(){var P;m?(m.wrapper.dispose(),m.renderer.dispose(),m.Je.dispose()):null===(P=t)||void 0===P||P.then((P=>{P.wrapper.dispose(),P.renderer.dispose(),P.Je.dispose()}));t=null,m=null}const F={DumpData:q,DumpDataAsync:R,DumpFramebuffer:C,Dispose:A};S.Tools.DumpData=q,S.Tools.DumpDataAsync=R,S.Tools.DumpFramebuffer=C},11117:(P,e,n)=>{n.r(e),n.d(e,{CreateScreenshot:()=>I,CreateScreenshotAsync:()=>O,CreateScreenshotUsingRenderTarget:()=>i,CreateScreenshotUsingRenderTargetAsync:()=>B,CreateScreenshotWithResizeAsync:()=>V,ScreenshotTools:()=>b});var H=n(11119),S=n(11199),p=n(11241),k=n(11096),m=n(11170),t=n(11245),C=n(11271),R=n(11133);class q extends t.d{static _GetDefines(P){if(!P)return null;return P.extractDriverInfo().toLowerCase().indexOf("mali")>-1?"#define MALI 1\n":null}_gatherImports(P,e){P?(this._webGPUReady=!0,e.push(Promise.all([n.e(54).then(n.bind(n,13577)),n.e(55).then(n.bind(n,13580))]))):e.push(Promise.all([n.e(56).then(n.bind(n,13583)),n.e(57).then(n.bind(n,13588))]))}constructor(P){const e={...arguments.length>2?arguments[2]:void 0,name:P,Je:(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null)||C.b.LastCreatedEngine,useShaderStore:!0,useAsPostProcess:!0,vertexShader:q.VertexUrl,fragmentShader:q.FragmentUrl,uniforms:q.Uniforms};super({...e,defines:q._GetDefines(e.Je)}),this.texelSize=new R.Vector2(0,0)}bind(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];super.bind(P),this._drawWrapper.effect.setFloat2("texelSize",this.texelSize.x,this.texelSize.y)}}q.VertexUrl="fxaa",q.FragmentUrl="fxaa",q.Uniforms=["texelSize"];class A extends p.e{getClassName(){return"FxaaPostProcess"}constructor(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,S=arguments.length>3?arguments[3]:void 0,p=arguments.length>4?arguments[4]:void 0,k=arguments.length>5?arguments[5]:void 0,m=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const t={uniforms:q.Uniforms,size:"number"===typeof e?e:void 0,camera:n,samplingMode:S||H.e.BILINEAR_SAMPLINGMODE,Je:p,reusable:k,textureType:m,...e};super(P,q.FragmentUrl,{effectWrapper:"number"!==typeof e&&e.effectWrapper?void 0:new q(P,p,t),...t}),this.onApplyObservable.add((P=>{this._effectWrapper.texelSize=this.texelSize}))}static _Parse(P,e,n,H){return m.c.Parse((()=>new A(P.name,P.options,e,P.renderTargetSamplingMode,n.getEngine(),P.reusable)),P,n,H)}}(0,k.h)("BABYLON.FxaaPostProcess",A);var F=n(10988),Y=n(10972),j=n(11360),z=n(11364),w=n(11047);let J=null;function I(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const{height:t,width:C}=l(P,e,n);if(!t||!C)return void F.c.Error("Invalid 'size' parameter !");e.BP().activeCamera===e?P.onEndFrameObservable.addOnce((()=>{J||(J=document.createElement("canvas")),J.width=C,J.height=t;const e=J.getContext("2d"),n=P.getRenderingCanvas();if(!e||!n)return void F.c.Error("Failed to create screenshot. Rendering context or rendering canvas is not available.");const R=n.width,q=n.height,A=J.width,j=J.height,z=A/R,w=j/q,I=m?Math.max(z,w):Math.min(z,w),O=R*I,V=q*I,i=(A-O)/2,B=(j-V)/2;e.drawImage(n,0,0,R,q,i,B,O,V),p?(Y.Tools.EncodeScreenshotCanvasData(J,void 0,S,void 0,k),H&&H("")):Y.Tools.EncodeScreenshotCanvasData(J,H,S,void 0,k)})):i(P,e,n,(P=>{if(p){const e=new Blob([P]);Y.Tools.DownloadBlob(e),H&&H("")}else H&&H(P)}),S,1,P.getCreationOptions().antialias,void 0,void 0,void 0,void 0,k)}async function O(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",S=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]&&arguments[5];return await new Promise(((k,m)=>{I(P,e,n,(P=>{"undefined"!==typeof P?k(P):m(new Error("Data is undefined"))}),H,void 0,S,p)}))}async function V(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",p=arguments.length>5?arguments[5]:void 0,k=arguments.length>6&&void 0!==arguments[6]&&arguments[6];return await new Promise((m=>{I(P,e,{width:n,height:H},(()=>{m()}),S,!0,p,k)}))}function i(P,e,p,k){let m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6&&void 0!==arguments[6]&&arguments[6],R=arguments.length>7?arguments[7]:void 0,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Y=arguments.length>9&&void 0!==arguments[9]&&arguments[9],J=!(arguments.length>10&&void 0!==arguments[10])||arguments[10],I=arguments.length>11?arguments[11]:void 0,O=arguments.length>12?arguments[12]:void 0,V=arguments.length>13?arguments[13]:void 0;const{height:i,width:B,finalWidth:b,finalHeight:T}=l(P,e,p),d={width:B,height:i};if(!i||!B)return void F.c.Error("Invalid 'size' parameter !");P.skipFrameRender=!0;const N=P.getRenderWidth,Q=P.getRenderHeight;P.getRenderWidth=function(){return!(arguments.length>0&&void 0!==arguments[0]&&arguments[0])&&P._currentRenderTarget?P._currentRenderTarget.width:B},P.getRenderHeight=function(){return!(arguments.length>0&&void 0!==arguments[0]&&arguments[0])&&P._currentRenderTarget?P._currentRenderTarget.height:i},P.onResizeObservable.hasObservers()&&P.onResizeObservable.notifyObservers(P);const c=e.BP(),r=new S.b("screenShot",d,c,!1,!1,0,!1,H.e.BILINEAR_SAMPLINGMODE,void 0,Y,void 0,void 0,void 0,t);r.renderList=c.meshes.slice(),r.samples=t,r.renderSprites=q,r.activeCamera=e,r.forceLayerMaskCheck=J,null===O||void 0===O||O(r);const o=V||j.DumpData,G=()=>{c.incrementRenderId(),c.resetCachedMaterial(),(0,w.d)((()=>r.isReadyForRendering()&&e.isReady(!0)),(()=>{P.onEndFrameObservable.addOnce((()=>{b===B&&T===i?r.readPixels(void 0,void 0,void 0,!1).then((P=>{o(B,i,P,k,m,R,!0,void 0,I),r.dispose()})):(P.isWebGPU?n.e(51).then(n.bind(n,13563)):n.e(52).then(n.bind(n,13572))).then((async()=>await(0,z.b)("pass",r.getInternalTexture(),c,void 0,void 0,void 0,b,T).then((e=>{P._readTexturePixels(e,b,T,-1,0,null,!0,!1,0,0).then((P=>{o(b,T,P,k,m,R,!0,void 0,I),e.dispose()}))}))))})),c.incrementRenderId(),c.resetCachedMaterial();const H=c.activeCamera,S=c.activeCameras,p=e.outputRenderTarget,t=c.spritesEnabled;c.activeCamera=e,c.activeCameras=null,e.outputRenderTarget=r,c.spritesEnabled=q;const C=c.meshes;c.meshes=r.renderList||c.meshes;try{c.render()}finally{c.activeCamera=H,c.activeCameras=S,e.outputRenderTarget=p,c.spritesEnabled=t,c.meshes=C,P.getRenderWidth=N,P.getRenderHeight=Q,P.onResizeObservable.hasObservers()&&P.onResizeObservable.notifyObservers(P),e.getProjectionMatrix(!0),P.skipFrameRender=!1}}),(()=>{P.skipFrameRender=!1,P.getRenderWidth=N,P.getRenderHeight=Q}))};if(C){const P=new A("antialiasing",1,c.activeCamera);r.addPostProcess(P),P.oe=!0,P.onEffectCreatedObservable.addOnce((P=>{P.isReady()?G():P.onCompiled=()=>{G()}}))}else G()}async function B(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6?arguments[6]:void 0,m=arguments.length>7&&void 0!==arguments[7]&&arguments[7],t=arguments.length>8&&void 0!==arguments[8]&&arguments[8],C=!(arguments.length>9&&void 0!==arguments[9])||arguments[9],R=arguments.length>10?arguments[10]:void 0,q=arguments.length>11?arguments[11]:void 0,A=arguments.length>12?arguments[12]:void 0;return await new Promise(((F,Y)=>{i(P,e,n,(P=>{"undefined"!==typeof P?F(P):Y(new Error("Data is undefined"))}),H,S,p,k,m,t,C,R,q,A)}))}function l(P,e,n){let H=0,S=0,p=0,k=0;if("object"===typeof n){const m=n.precision?Math.abs(n.precision):1;n.width&&n.height?(H=n.height*m,S=n.width*m):n.width&&!n.height?(S=n.width*m,H=Math.round(S/P.getAspectRatio(e))):n.height&&!n.width?(H=n.height*m,S=Math.round(H*P.getAspectRatio(e))):(S=Math.round(P.getRenderWidth()*m),H=Math.round(S/P.getAspectRatio(e))),n.finalWidth&&n.finalHeight?(k=n.finalHeight,p=n.finalWidth):n.finalWidth&&!n.finalHeight?(p=n.finalWidth,k=Math.round(p/P.getAspectRatio(e))):n.finalHeight&&!n.finalWidth?(k=n.finalHeight,p=Math.round(k*P.getAspectRatio(e))):(p=S,k=H)}else isNaN(n)||(H=n,S=n,p=n,k=n);return S&&(S=Math.floor(S)),H&&(H=Math.floor(H)),p&&(p=Math.floor(p)),k&&(k=Math.floor(k)),{height:0|H,width:0|S,finalWidth:0|p,finalHeight:0|k}}const b={CreateScreenshot:I,CreateScreenshotAsync:O,CreateScreenshotWithResizeAsync:V,CreateScreenshotUsingRenderTarget:i,CreateScreenshotUsingRenderTargetAsync:B};Y.Tools.CreateScreenshot=I,Y.Tools.CreateScreenshotAsync=O,Y.Tools.CreateScreenshotUsingRenderTarget=i,Y.Tools.CreateScreenshotUsingRenderTargetAsync=B}}]);