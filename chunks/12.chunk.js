"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2601:(u,F,z)=>{z.r(F),z.d(F,{_HDRTextureLoader:()=>j});var p=z(730);class b{static ConvertPanoramaToCubemap(u,F,z,p){let b=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!u)throw"ConvertPanoramaToCubemap: input cannot be null";if(u.length!=F*z*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(p,this.FACE_FRONT,u,F,z,b),back:this.CreateCubemapTexture(p,this.FACE_BACK,u,F,z,b),left:this.CreateCubemapTexture(p,this.FACE_LEFT,u,F,z,b),right:this.CreateCubemapTexture(p,this.FACE_RIGHT,u,F,z,b),up:this.CreateCubemapTexture(p,this.FACE_UP,u,F,z,b),down:this.CreateCubemapTexture(p,this.FACE_DOWN,u,F,z,b),size:p,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(u,F,z,p,b){let R=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const c=new ArrayBuffer(u*u*4*3),I=new Float32Array(c),G=R?Math.max(1,Math.round(p/4/u)):1,X=1/G,j=X*X,W=F[1].Md(F[0]).scale(X/u),E=F[3].Md(F[2]).scale(X/u),L=1/u;let k=0;for(let N=0;N<u;N++)for(let R=0;R<G;R++){let R=F[0],c=F[2];for(let F=0;F<u;F++)for(let X=0;X<G;X++){const G=c.Md(R).scale(k).add(R);G.normalize();const X=this.CalcProjectionSpherical(G,z,p,b);I[N*u*3+3*F+0]+=X.r*j,I[N*u*3+3*F+1]+=X.g*j,I[N*u*3+3*F+2]+=X.b*j,R=R.add(W),c=c.add(E)}k+=L*X}return I}static CalcProjectionSpherical(u,F,z,p){let b=Math.atan2(u.z,u.x);const R=Math.acos(u.y);for(;b<-Math.PI;)b+=2*Math.PI;for(;b>Math.PI;)b-=2*Math.PI;let c=b/Math.PI;const I=R/Math.PI;c=.5*c+.5;let G=Math.round(c*z);G<0?G=0:G>=z&&(G=z-1);let X=Math.round(I*p);X<0?X=0:X>=p&&(X=p-1);const j=p-X-1;return{r:F[j*z*3+3*G+0],g:F[j*z*3+3*G+1],b:F[j*z*3+3*G+2]}}}function R(u,F,z,p,b,R){b>0?(b=function(u,F){return F>1023?u*Math.pow(2,1023)*Math.pow(2,F-1023):F<-1074?u*Math.pow(2,-1074)*Math.pow(2,F+1074):u*Math.pow(2,F)}(1,b-136),u[R+0]=F*b,u[R+1]=z*b,u[R+2]=p*b):(u[R+0]=0,u[R+1]=0,u[R+2]=0)}function c(u,F){let z="",p="";for(let b=F;b<u.length-F&&(p=String.fromCharCode(u[b]),"\n"!=p);b++)z+=p;return z}function I(u){let F=0,z=0,p=c(u,0);if("#"!=p[0]||"?"!=p[1])throw"Bad HDR Format.";let b=!1,R=!1,I=0;do{I+=p.length+1,p=c(u,I),"FORMAT=32-bit_rle_rgbe"==p?R=!0:0==p.length&&(b=!0)}while(!b);if(!R)throw"HDR Bad header format, unsupported FORMAT";I+=p.length+1,p=c(u,I);const G=/^-Y (.*) \+X (.*)$/g.exec(p);if(!G||G.length<3)throw"HDR Bad header format, no size";if(z=parseInt(G[2]),F=parseInt(G[1]),z<8||z>32767)throw"HDR Bad header format, unsupported size";return I+=p.length+1,{height:F,width:z,dataPosition:I}}function G(u,F){return function(u,F){let z=F.height;const p=F.width;let b,c,I,G,j,W=F.dataPosition,E=0,L=0,k=0;const N=new ArrayBuffer(4*p),Y=new Uint8Array(N),e=new ArrayBuffer(F.width*F.height*4*3),d=new Float32Array(e);for(;z>0;){if(b=u[W++],c=u[W++],I=u[W++],G=u[W++],2!=b||2!=c||128&I||F.width<8||F.width>32767)return X(u,F);if((I<<8|G)!=p)throw"HDR Bad header format, wrong scan line width";for(E=0,k=0;k<4;k++)for(L=(k+1)*p;E<L;)if(b=u[W++],c=u[W++],b>128){if(j=b-128,0==j||j>L-E)throw"HDR Bad Format, bad scanline data (run)";for(;j-- >0;)Y[E++]=c}else{if(j=b,0==j||j>L-E)throw"HDR Bad Format, bad scanline data (non-run)";if(Y[E++]=c,--j>0)for(let F=0;F<j;F++)Y[E++]=u[W++]}for(k=0;k<p;k++)b=Y[k],c=Y[k+p],I=Y[k+2*p],G=Y[k+3*p],R(d,b,c,I,G,(F.height-z)*p*3+3*k);z--}return d}(u,F)}function X(u,F){let z=F.height;const p=F.width;let b,c,I,G,X,j=F.dataPosition;const W=new ArrayBuffer(F.width*F.height*4*3),E=new Float32Array(W);for(;z>0;){for(X=0;X<F.width;X++)b=u[j++],c=u[j++],I=u[j++],G=u[j++],R(E,b,c,I,G,(F.height-z)*p*3+3*X);z--}return E}b.FACE_LEFT=[new p.l(-1,-1,-1),new p.l(1,-1,-1),new p.l(-1,1,-1),new p.l(1,1,-1)],b.FACE_RIGHT=[new p.l(1,-1,1),new p.l(-1,-1,1),new p.l(1,1,1),new p.l(-1,1,1)],b.FACE_FRONT=[new p.l(1,-1,-1),new p.l(1,-1,1),new p.l(1,1,-1),new p.l(1,1,1)],b.FACE_BACK=[new p.l(-1,-1,1),new p.l(-1,-1,-1),new p.l(-1,1,1),new p.l(-1,1,-1)],b.FACE_DOWN=[new p.l(1,1,-1),new p.l(1,1,1),new p.l(-1,1,-1),new p.l(-1,1,1)],b.FACE_UP=[new p.l(-1,-1,-1),new p.l(-1,-1,1),new p.l(1,-1,-1),new p.l(1,-1,1)];class j{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(u,F,z){const p=new Uint8Array(u.buffer,u.byteOffset,u.byteLength),b=I(p),R=G(p,b),c=b.width*b.height,X=new Float32Array(4*c);for(let I=0;I<c;I+=1)X[4*I]=R[3*I],X[4*I+1]=R[3*I+1],X[4*I+2]=R[3*I+2],X[4*I+3]=1;z(b.width,b.height,F.generateMipMaps,!1,(()=>{const u=F.getEngine();F.type=1,F.format=5,F._gammaSpace=!1,u._uploadDataToTextureDirectly(F,X)}))}}}}]);