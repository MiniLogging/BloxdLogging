"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{11015:(T,z,X)=>{X.r(z),X.d(z,{_ExrTextureLoader:()=>f});var b=X(1065),F=X(1014);const A=65536,u=14,y=65537,E=16384;var v,k;!function(T){T[T.NO_COMPRESSION=0]="NO_COMPRESSION",T[T.RLE_COMPRESSION=1]="RLE_COMPRESSION",T[T.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",T[T.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",T[T.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",T[T.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(v||(v={})),function(T){T[T.INCREASING_Y=0]="INCREASING_Y",T[T.DECREASING_Y=1]="DECREASING_Y"}(k||(k={}));const L=function(){const T=new ArrayBuffer(4),z=new Float32Array(T),X=new Uint32Array(T),b=new Uint32Array(512),F=new Uint32Array(512);for(let E=0;E<256;++E){const T=E-127;T<-27?(b[E]=0,b[256|E]=32768,F[E]=24,F[256|E]=24):T<-14?(b[E]=1024>>-T-14,b[256|E]=1024>>-T-14|32768,F[E]=-T-1,F[256|E]=-T-1):T<=15?(b[E]=T+15<<10,b[256|E]=T+15<<10|32768,F[E]=13,F[256|E]=13):T<128?(b[E]=31744,b[256|E]=64512,F[E]=24,F[256|E]=24):(b[E]=31744,b[256|E]=64512,F[E]=13,F[256|E]=13)}const A=new Uint32Array(2048),u=new Uint32Array(64),y=new Uint32Array(64);for(let E=1;E<1024;++E){let T=E<<13,z=0;for(;0===(8388608&T);)T<<=1,z-=8388608;T&=-8388609,z+=947912704,A[E]=T|z}for(let E=1024;E<2048;++E)A[E]=939524096+(E-1024<<13);for(let E=1;E<31;++E)u[E]=E<<23;u[31]=1199570944,u[32]=2147483648;for(let E=33;E<63;++E)u[E]=2147483648+(E-32<<23);u[63]=3347054592;for(let E=1;E<64;++E)32!==E&&(y[E]=1024);return{floatView:z,uint32View:X,baseTable:b,shiftTable:F,mantissaTable:A,exponentTable:u,offsetTable:y}}();function D(T,z){const X=new Uint8Array(T);let b=0;for(;0!=X[z.value+b];)b+=1;const F=(new TextDecoder).decode(X.slice(z.value,z.value+b));return z.value=z.value+b+1,F}function c(T,z){const X=T.getInt32(z.value,!0);return z.value+=4,X}function p(T,z){const X=T.getUint32(z.value,!0);return z.value+=4,X}function H(T,z){const X=T.getUint8(z.value);return z.value+=1,X}function U(T,z){const X=T.getUint16(z.value,!0);return z.value+=2,X}function s(T,z){const X=T[z.value];return z.value+=1,X}function x(T,z){let X;return X="getBigInt64"in DataView.prototype?Number(T.getBigInt64(z.value,!0)):T.getUint32(z.value+4,!0)+Number(T.getUint32(z.value,!0)<<32),z.value+=8,X}function K(T,z){const X=T.getFloat32(z.value,!0);return z.value+=4,X}function d(T,z){return function(T){const z=(31744&T)>>10,X=1023&T;return(T>>15?-1:1)*(z?31===z?X?NaN:1/0:Math.pow(2,z-15)*(1+X/1024):X/1024*6103515625e-14)}(U(T,z))}function N(T,z){return function(T){if(Math.abs(T)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");T=(0,F.d)(T,-65504,65504),L.floatView[0]=T;const z=L.uint32View[0],X=z>>23&511;return L.baseTable[X]+((8388607&z)>>L.shiftTable[X])}(K(T,z))}function l(T,z,X,b){switch(X){case"string":case"stringvector":case"iccProfile":return function(T,z,X){const b=(new TextDecoder).decode(new Uint8Array(T).slice(z.value,z.value+X));return z.value=z.value+X,b}(T.buffer,z,b);case"chlist":return function(T,z,X){const b=z.value,F=[];for(;z.value<b+X-1;){const X=D(T.buffer,z),b=c(T,z),A=H(T,z);z.value+=3;const u=c(T,z),y=c(T,z);F.push({name:X,pixelType:b,pLinear:A,xSampling:u,ySampling:y})}return z.value+=1,F}(T,z,b);case"chromaticities":return function(T,z){return{redX:K(T,z),redY:K(T,z),greenX:K(T,z),greenY:K(T,z),blueX:K(T,z),blueY:K(T,z),whiteX:K(T,z),whiteY:K(T,z)}}(T,z);case"compression":return function(T,z){return H(T,z)}(T,z);case"box2i":return function(T,z){return{xMin:c(T,z),yMin:c(T,z),xMax:c(T,z),yMax:c(T,z)}}(T,z);case"lineOrder":return function(T,z){const X=H(T,z);return k[X]}(T,z);case"float":return K(T,z);case"v2f":return function(T,z){return[K(T,z),K(T,z)]}(T,z);case"v3f":return function(T,z){return[K(T,z),K(T,z),K(T,z)]}(T,z);case"int":return c(T,z);case"rational":return function(T,z){return[c(T,z),p(T,z)]}(T,z);case"timecode":return function(T,z){return[p(T,z),p(T,z)]}(T,z);case"preview":return z.value+=b,"skipped";default:return void(z.value+=b)}}function a(T){for(let z=1;z<T.length;z++){const X=T[z-1]+T[z]-128;T[z]=X}}function q(T,z){let X=0,b=Math.floor((T.length+1)/2),F=0;const A=T.length-1;for(;!(F>A)&&(z[F++]=T[X++],!(F>A));)z[F++]=T[b++]}function V(T,z,X,b,F){for(;X<T;)z=z<<8|s(b,F),X+=8;return{l:z>>(X-=T)&(1<<T)-1,c:z,lc:X}}function C(T,z,X,b){return{c:T=T<<8|s(X,b),lc:z+=8}}function G(T,z,X,b,F,A,u,y,E){if(T==z){if(b<8){const T=C(X,b,F,A);X=T.c,b=T.lc}let T=X>>(b-=8);if(T=new Uint8Array([T])[0],y.value+T>E)return null;const z=u[y.value-1];for(;T-- >0;)u[y.value++]=z}else{if(!(y.value<E))return null;u[y.value++]=T}return{c:X,lc:b}}const j=new Array(59);function Z(T,z,X,b,F,A){const u=z;let E=0,v=0;for(;b<=F;b++){if(u.value-z.value>X)return;let y=V(6,E,v,T,u);const k=y.l;if(E=y.c,v=y.lc,A[b]=k,63==k){if(u.value-z.value>X)throw new Error("Error in HufUnpackEncTable");y=V(8,E,v,T,u);let k=y.l+6;if(E=y.c,v=y.lc,b+k>F+1)throw new Error("Error in HufUnpackEncTable");for(;k--;)A[b++]=0;b--}else if(k>=59){let T=k-59+2;if(b+T>F+1)throw new Error("Error in HufUnpackEncTable");for(;T--;)A[b++]=0;b--}}!function(T){for(let X=0;X<=58;++X)j[X]=0;for(let X=0;X<y;++X)j[T[X]]+=1;let z=0;for(let X=58;X>0;--X){const T=z+j[X]>>1;j[X]=z,z=T}for(let X=0;X<y;++X){const z=T[X];z>0&&(T[X]=z|j[z]++<<6)}}(A)}function m(T){return 63&T}function S(T){return T>>6}function n(T,z,X,b,F,A){const v=X.value,k=p(z,X),L=p(z,X);X.value+=4;const D=p(z,X);if(X.value+=4,k<0||k>=y||L<0||L>=y)throw new Error("Wrong HUF_ENCSIZE");const c=new Array(y),H=new Array(E);!function(T){for(let z=0;z<E;z++)T[z]={},T[z].len=0,T[z].lit=0,T[z].p=null}(H);if(Z(T,X,b-(X.value-v),k,L,c),D>8*(b-(X.value-v)))throw new Error("Wrong hufUncompress");!function(T,z,X,b){for(;z<=X;z++){const X=S(T[z]),F=m(T[z]);if(X>>F)throw new Error("Invalid table entry");if(F>u){const T=b[X>>F-u];if(T.len)throw new Error("Invalid table entry");if(T.lit++,T.p){const z=T.p;T.p=new Array(T.lit);for(let X=0;X<T.lit-1;++X)T.p[X]=z[X]}else T.p=new Array(1);T.p[T.lit-1]=z}else if(F){let T=0;for(let A=1<<u-F;A>0;A--){const A=b[(X<<u-F)+T];if(A.len||A.p)throw new Error("Invalid table entry");A.len=F,A.lit=z,T++}}}}(c,k,L,H),function(T,z,X,b,F,A,y,E,v){let k=0,L=0;const D=y,c=Math.trunc(b.value+(F+7)/8);for(;b.value<c;){let F=C(k,L,X,b);for(k=F.c,L=F.lc;L>=u;){const y=z[k>>L-u&16383];if(y.len){L-=y.len;const T=G(y.lit,A,k,L,X,b,E,v,D);T&&(k=T.c,L=T.lc)}else{if(!y.p)throw new Error("hufDecode issues");let z;for(z=0;z<y.lit;z++){const u=m(T[y.p[z]]);for(;L<u&&b.value<c;)F=C(k,L,X,b),k=F.c,L=F.lc;if(L>=u&&S(T[y.p[z]])==(k>>L-u&(1<<u)-1)){L-=u;const T=G(y.p[z],A,k,L,X,b,E,v,D);T&&(k=T.c,L=T.lc);break}}if(z==y.lit)throw new Error("HufDecode issues")}}}const p=8-F&7;for(k>>=p,L-=p;L>0;){const T=z[k<<u-L&16383];if(!T.len)throw new Error("HufDecode issues");{L-=T.len;const z=G(T.lit,A,k,L,X,b,E,v,D);z&&(k=z.c,L=z.lc)}}}(c,H,T,X,D,L,A,F,{value:0})}function O(T){return 65535&T}function P(T){const z=O(T);return z>32767?z-65536:z}function W(T,z){const X=P(T),b=P(z),F=X+(1&b)+(b>>1);return{a:F,b:F-b}}function B(T,z){const X=O(T),b=O(z),F=X-(b>>1)&65535;return{a:b+F-32768&65535,b:F}}function e(T,z,X,b,F,A,u){const y=u<16384,E=X>F?F:X;let v,k,L=1;for(;L<=E;)L<<=1;for(L>>=1,v=L,L>>=1;L>=1;){k=0;const u=k+A*(F-v),E=A*L,D=A*v,c=b*L,p=b*v;let H,U,s,x;for(;k<=u;k+=D){let F=k;const A=k+b*(X-v);for(;F<=A;F+=p){const X=F+c,b=F+E,A=b+c;if(y){let u=W(T[F+z],T[b+z]);H=u.a,s=u.b,u=W(T[X+z],T[A+z]),U=u.a,x=u.b,u=W(H,U),T[F+z]=u.a,T[X+z]=u.b,u=W(s,x),T[b+z]=u.a,T[A+z]=u.b}else{let u=B(T[F+z],T[b+z]);H=u.a,s=u.b,u=B(T[X+z],T[A+z]),U=u.a,x=u.b,u=B(H,U),T[F+z]=u.a,T[X+z]=u.b,u=B(s,x),T[b+z]=u.a,T[A+z]=u.b}}if(X&L){const X=F+E;let b;b=y?W(T[F+z],T[X+z]):B(T[F+z],T[X+z]),H=b.a,T[X+z]=b.b,T[F+z]=H}}if(F&L){let F=k;const A=k+b*(X-v);for(;F<=A;F+=p){const X=F+c;let b;b=y?W(T[F+z],T[X+z]):B(T[F+z],T[X+z]),H=b.a,T[X+z]=b.b,T[F+z]=H}}v=L,L>>=1}return k}function R(T){return new DataView(T.array.buffer,T.offset.value,T.size)}function Y(T){const z=T.viewer.buffer.slice(T.offset.value,T.offset.value+T.size),X=new Uint8Array(function(T){let z=T.byteLength;const X=new Array;let b=0;const F=new DataView(T);for(;z>0;){const T=F.getInt8(b++);if(T<0){const A=-T;z-=A+1;for(let T=0;T<A;T++)X.push(F.getUint8(b++))}else{const A=T;z-=2;const u=F.getUint8(b++);for(let T=0;T<A+1;T++)X.push(u)}}return X}(z)),b=new Uint8Array(X.length);return a(X),q(X,b),new DataView(b.buffer)}function i(T){const z=T.array.slice(T.offset.value,T.offset.value+T.size),X=fflate.unzlibSync(z),b=new Uint8Array(X.length);return a(X),q(X,b),new DataView(b.buffer)}function t(T){const z=T.array.slice(T.offset.value,T.offset.value+T.size),X=fflate.unzlibSync(z),b=T.lines*T.channels*T.width,F=1==T.type?new Uint16Array(b):new Uint32Array(b);let A=0,u=0;const y=new Array(4);for(let E=0;E<T.lines;E++)for(let z=0;z<T.channels;z++){let z=0;switch(T.type){case 1:y[0]=A,y[1]=y[0]+T.width,A=y[1]+T.width;for(let b=0;b<T.width;++b){z+=X[y[0]++]<<8|X[y[1]++],F[u]=z,u++}break;case 2:y[0]=A,y[1]=y[0]+T.width,y[2]=y[1]+T.width,A=y[2]+T.width;for(let b=0;b<T.width;++b){z+=X[y[0]++]<<24|X[y[1]++]<<16|X[y[2]++]<<8,F[u]=z,u++}}}return new DataView(F.buffer)}function g(T){const z=T.viewer,X={value:T.offset.value},b=new Uint16Array(T.width*T.scanlineBlockSize*(T.channels*T.type)),F=new Uint8Array(8192);let u=0;const y=new Array(T.channels);for(let A=0;A<T.channels;A++)y[A]={},y[A].start=u,y[A].end=y[A].start,y[A].nx=T.width,y[A].ny=T.lines,y[A].size=T.type,u+=y[A].nx*y[A].ny*y[A].size;const E=U(z,X),v=U(z,X);if(v>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(E<=v)for(let A=0;A<v-E+1;A++)F[A+E]=H(z,X);const k=new Uint16Array(A),L=function(T,z){let X=0;for(let F=0;F<A;++F)(0==F||T[F>>3]&1<<(7&F))&&(z[X++]=F);const b=X-1;for(;X<A;)z[X++]=0;return b}(F,k),D=p(z,X);n(T.array,z,X,D,b,u);for(let A=0;A<T.channels;++A){const T=y[A];for(let z=0;z<y[A].size;++z)e(b,T.start+z,T.nx,T.size,T.ny,T.nx*T.size,L)}!function(T,z,X){for(let b=0;b<X;++b)z[b]=T[z[b]]}(k,b,u);let c=0;const s=new Uint8Array(b.buffer.byteLength);for(let A=0;A<T.lines;A++)for(let z=0;z<T.channels;z++){const T=y[z],X=T.nx*T.size,F=new Uint8Array(b.buffer,2*T.end,2*X);s.set(F,c),c+=2*X,T.end+=X}return new DataView(s.buffer)}var M,r=X(1166);!function(T){T[T.Float=0]="Float",T[T.HalfFloat=1]="HalfFloat"}(M||(M={}));class o{}o.DefaultOutputType=M.HalfFloat,o.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class f{constructor(){this.supportCascades=!1}loadCubeData(T,z,X,b,F){throw".exr not supported in Cube."}async loadData(T,z,X){const F=new DataView(T.buffer),A={value:0},u=function(T,z){if(20000630!=T.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const X=T.getUint8(4),F=T.getUint8(5),A={singleTile:!!(2&F),longName:!!(4&F),deepFormat:!!(8&F),multiPart:!!(16&F)};z.value=8;const u={};let y=!0;for(;y;){const X=D(T.buffer,z);if(X){const F=D(T.buffer,z),A=l(T,z,F,p(T,z));void 0===A?b.e.Warn(`Unknown header attribute type ${F}'.`):u[X]=A}else y=!1}if(0!=(-5&F))throw new Error("Unsupported file format");return{version:X,spec:A,...u}}(F,A),y=await async function(T,z,X,b){const F={size:0,viewer:z,array:new Uint8Array(z.buffer),offset:X,width:T.dataWindow.xMax-T.dataWindow.xMin+1,height:T.dataWindow.yMax-T.dataWindow.yMin+1,channels:T.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(T.compression){case v.NO_COMPRESSION:F.lines=1,F.uncompress=R;break;case v.RLE_COMPRESSION:F.lines=1,F.uncompress=Y;break;case v.ZIPS_COMPRESSION:F.lines=1,F.uncompress=i,await r.g.LoadScriptAsync(o.FFLATEUrl);break;case v.ZIP_COMPRESSION:F.lines=16,F.uncompress=i,await r.g.LoadScriptAsync(o.FFLATEUrl);break;case v.PIZ_COMPRESSION:F.lines=32,F.uncompress=g;break;case v.PXR24_COMPRESSION:F.lines=16,F.uncompress=t,await r.g.LoadScriptAsync(o.FFLATEUrl);break;default:throw new Error(v[T.compression]+" is unsupported")}F.scanlineBlockSize=F.lines;const A={};for(const v of T.channels)switch(v.name){case"Y":case"R":case"G":case"B":case"A":A[v.name]=!0,F.type=v.pixelType}let u=!1;if(A.R&&A.G&&A.B)u=!A.A,F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else{if(!A.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");F.outputChannels=1,F.decodeChannels={Y:0}}if(1===F.type)switch(b){case M.Float:F.getter=d,F.inputSize=2;break;case M.HalfFloat:F.getter=U,F.inputSize=2}else{if(2!==F.type)throw new Error("Unsupported pixelType "+F.type+" for "+T.compression);switch(b){case M.Float:F.getter=K,F.inputSize=4;break;case M.HalfFloat:F.getter=N,F.inputSize=4}}F.blockCount=F.height/F.scanlineBlockSize;for(let v=0;v<F.blockCount;v++)x(z,X);const y=F.width*F.height*F.outputChannels;switch(b){case M.Float:F.byteArray=new Float32Array(y),F.textureType=1,u&&F.byteArray.fill(1,0,y);break;case M.HalfFloat:F.byteArray=new Uint16Array(y),F.textureType=2,u&&F.byteArray.fill(15360,0,y);break;default:throw new Error("Unsupported type: "+b)}let E=0;for(const v of T.channels)void 0!==F.decodeChannels[v.name]&&(F.channelLineOffsets[v.name]=E*F.width),E+=2*v.pixelType;return F.bytesPerLine=F.width*E,F.outLineWidth=F.width*F.outputChannels,"INCREASING_Y"===T.lineOrder?F.scanOrder=T=>T:F.scanOrder=T=>F.height-1-T,4==F.outputChannels?(F.format=5,F.linearSpace=!0):(F.format=6,F.linearSpace=!1),F}(u,F,A,o.DefaultOutputType);!function(T,z,X,b){const F={value:0};for(let A=0;A<T.height/T.scanlineBlockSize;A++){const u=c(X,b)-z.dataWindow.yMin;T.size=p(X,b),T.lines=u+T.scanlineBlockSize>T.height?T.height-u:T.scanlineBlockSize;const y=T.size<T.lines*T.bytesPerLine&&T.uncompress?T.uncompress(T):R(T);b.value+=T.size;for(let X=0;X<T.scanlineBlockSize;X++){const b=A*T.scanlineBlockSize,u=X+T.scanOrder(b);if(u>=T.height)continue;const E=X*T.bytesPerLine,v=(T.height-1-u)*T.outLineWidth;for(let X=0;X<T.channels;X++){const b=z.channels[X].name,A=T.channelLineOffsets[b],u=T.decodeChannels[b];if(void 0!==u){F.value=E+A;for(let z=0;z<T.width;z++){const X=v+z*T.outputChannels+u;T.byteArray&&(T.byteArray[X]=T.getter(y,F))}}}}}}(y,u,F,A);X(u.dataWindow.xMax-u.dataWindow.xMin+1,u.dataWindow.yMax-u.dataWindow.yMin+1,z.generateMipMaps,!1,(()=>{const T=z.getEngine();z.format=u.format,z.type=y.textureType,z.invertY=!1,z._gammaSpace=!u.linearSpace,y.byteArray&&T._uploadDataToTextureDirectly(z,y.byteArray,0,0,void 0,!0)}))}}}}]);