"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12698:(Y,j,X)=>{X.r(j),X.d(j,{_DDSTextureLoader:()=>U});var u=X(11555),K=X(11572);class U{constructor(){this.supportCascades=!0}loadCubeData(Y,j,X,U){const I=j.getEngine();let y,T=!1,E=1e3;if(Array.isArray(Y))for(let u=0;u<Y.length;u++){const X=Y[u];y=K.e.GetDDSInfo(X),j.width=y.width,j.height=y.height,T=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&j.generateMipMaps,I._unpackFlipY(y.isCompressed),K.e.UploadDDSLevels(I,j,X,y,T,6,-1,u),y.isFourCC||1!==y.mipmapCount?E=y.mipmapCount-1:I.generateMipMapsForCubemap(j)}else{const U=Y;y=K.e.GetDDSInfo(U),j.width=y.width,j.height=y.height,X&&(y.sphericalPolynomial=new u.h),T=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&j.generateMipMaps,I._unpackFlipY(y.isCompressed),K.e.UploadDDSLevels(I,j,U,y,T,6),y.isFourCC||1!==y.mipmapCount?E=y.mipmapCount-1:I.generateMipMapsForCubemap(j,!1)}I._setCubeMapTextureParams(j,T,E),j.isReady=!0,j.onLoadedObservable.notifyObservers(j),j.onLoadedObservable.clear(),U&&U({isDDS:!0,width:j.width,info:y,data:Y,texture:j})}loadData(Y,j,X){const u=K.e.GetDDSInfo(Y),U=(u.isRGB||u.isLuminance||u.mipmapCount>1)&&j.generateMipMaps&&Math.max(u.width,u.height)>>u.mipmapCount-1===1;X(u.width,u.height,U,u.isFourCC,(()=>{K.e.UploadDDSLevels(j.getEngine(),j,Y,u,U,1)}))}}}}]);