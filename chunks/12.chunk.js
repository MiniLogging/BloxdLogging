"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2552:(n,k,T)=>{T.r(k),T.d(k,{_HDRTextureLoader:()=>S});var c=T(730);class K{static ConvertPanoramaToCubemap(n,k,T,c){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!n)throw"ConvertPanoramaToCubemap: input cannot be null";if(n.length!=k*T*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(c,this.FACE_FRONT,n,k,T,K),back:this.CreateCubemapTexture(c,this.FACE_BACK,n,k,T,K),left:this.CreateCubemapTexture(c,this.FACE_LEFT,n,k,T,K),right:this.CreateCubemapTexture(c,this.FACE_RIGHT,n,k,T,K),up:this.CreateCubemapTexture(c,this.FACE_UP,n,k,T,K),down:this.CreateCubemapTexture(c,this.FACE_DOWN,n,k,T,K),size:c,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(n,k,T,c,K){let Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const G=new ArrayBuffer(n*n*4*3),w=new Float32Array(G),E=Q?Math.max(1,Math.round(c/4/n)):1,I=1/E,S=I*I,P=k[1].Fg(k[0]).scale(I/n),W=k[3].Fg(k[2]).scale(I/n),J=1/n;let H=0;for(let s=0;s<n;s++)for(let Q=0;Q<E;Q++){let Q=k[0],G=k[2];for(let k=0;k<n;k++)for(let I=0;I<E;I++){const E=G.Fg(Q).scale(H).add(Q);E.normalize();const I=this.CalcProjectionSpherical(E,T,c,K);w[s*n*3+3*k+0]+=I.r*S,w[s*n*3+3*k+1]+=I.g*S,w[s*n*3+3*k+2]+=I.b*S,Q=Q.add(P),G=G.add(W)}H+=J*I}return w}static CalcProjectionSpherical(n,k,T,c){let K=Math.atan2(n.z,n.x);const Q=Math.acos(n.y);for(;K<-Math.PI;)K+=2*Math.PI;for(;K>Math.PI;)K-=2*Math.PI;let G=K/Math.PI;const w=Q/Math.PI;G=.5*G+.5;let E=Math.round(G*T);E<0?E=0:E>=T&&(E=T-1);let I=Math.round(w*c);I<0?I=0:I>=c&&(I=c-1);const S=c-I-1;return{r:k[S*T*3+3*E+0],g:k[S*T*3+3*E+1],b:k[S*T*3+3*E+2]}}}function Q(n,k,T,c,K,Q){K>0?(K=function(n,k){return k>1023?n*Math.pow(2,1023)*Math.pow(2,k-1023):k<-1074?n*Math.pow(2,-1074)*Math.pow(2,k+1074):n*Math.pow(2,k)}(1,K-136),n[Q+0]=k*K,n[Q+1]=T*K,n[Q+2]=c*K):(n[Q+0]=0,n[Q+1]=0,n[Q+2]=0)}function G(n,k){let T="",c="";for(let K=k;K<n.length-k&&(c=String.fromCharCode(n[K]),"\n"!=c);K++)T+=c;return T}function w(n){let k=0,T=0,c=G(n,0);if("#"!=c[0]||"?"!=c[1])throw"Bad HDR Format.";let K=!1,Q=!1,w=0;do{w+=c.length+1,c=G(n,w),"FORMAT=32-bit_rle_rgbe"==c?Q=!0:0==c.length&&(K=!0)}while(!K);if(!Q)throw"HDR Bad header format, unsupported FORMAT";w+=c.length+1,c=G(n,w);const E=/^-Y (.*) \+X (.*)$/g.exec(c);if(!E||E.length<3)throw"HDR Bad header format, no size";if(T=parseInt(E[2]),k=parseInt(E[1]),T<8||T>32767)throw"HDR Bad header format, unsupported size";return w+=c.length+1,{height:k,width:T,dataPosition:w}}function E(n,k){return function(n,k){let T=k.height;const c=k.width;let K,G,w,E,S,P=k.dataPosition,W=0,J=0,H=0;const s=new ArrayBuffer(4*c),b=new Uint8Array(s),C=new ArrayBuffer(k.width*k.height*4*3),z=new Float32Array(C);for(;T>0;){if(K=n[P++],G=n[P++],w=n[P++],E=n[P++],2!=K||2!=G||128&w||k.width<8||k.width>32767)return I(n,k);if((w<<8|E)!=c)throw"HDR Bad header format, wrong scan line width";for(W=0,H=0;H<4;H++)for(J=(H+1)*c;W<J;)if(K=n[P++],G=n[P++],K>128){if(S=K-128,0==S||S>J-W)throw"HDR Bad Format, bad scanline data (run)";for(;S-- >0;)b[W++]=G}else{if(S=K,0==S||S>J-W)throw"HDR Bad Format, bad scanline data (non-run)";if(b[W++]=G,--S>0)for(let k=0;k<S;k++)b[W++]=n[P++]}for(H=0;H<c;H++)K=b[H],G=b[H+c],w=b[H+2*c],E=b[H+3*c],Q(z,K,G,w,E,(k.height-T)*c*3+3*H);T--}return z}(n,k)}function I(n,k){let T=k.height;const c=k.width;let K,G,w,E,I,S=k.dataPosition;const P=new ArrayBuffer(k.width*k.height*4*3),W=new Float32Array(P);for(;T>0;){for(I=0;I<k.width;I++)K=n[S++],G=n[S++],w=n[S++],E=n[S++],Q(W,K,G,w,E,(k.height-T)*c*3+3*I);T--}return W}K.FACE_LEFT=[new c.o(-1,-1,-1),new c.o(1,-1,-1),new c.o(-1,1,-1),new c.o(1,1,-1)],K.FACE_RIGHT=[new c.o(1,-1,1),new c.o(-1,-1,1),new c.o(1,1,1),new c.o(-1,1,1)],K.FACE_FRONT=[new c.o(1,-1,-1),new c.o(1,-1,1),new c.o(1,1,-1),new c.o(1,1,1)],K.FACE_BACK=[new c.o(-1,-1,1),new c.o(-1,-1,-1),new c.o(-1,1,1),new c.o(-1,1,-1)],K.FACE_DOWN=[new c.o(1,1,-1),new c.o(1,1,1),new c.o(-1,1,-1),new c.o(-1,1,1)],K.FACE_UP=[new c.o(-1,-1,-1),new c.o(-1,-1,1),new c.o(1,-1,-1),new c.o(1,-1,1)];class S{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(n,k,T){const c=new Uint8Array(n.buffer,n.byteOffset,n.byteLength),K=w(c),Q=E(c,K),G=K.width*K.height,I=new Float32Array(4*G);for(let w=0;w<G;w+=1)I[4*w]=Q[3*w],I[4*w+1]=Q[3*w+1],I[4*w+2]=Q[3*w+2],I[4*w+3]=1;T(K.width,K.height,k.generateMipMaps,!1,(()=>{const n=k.getEngine();k.type=1,k.format=5,k._gammaSpace=!1,n._uploadDataToTextureDirectly(k,I)}))}}}}]);