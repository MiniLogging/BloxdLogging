"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10079:(a,i,K)=>{K.r(i),K.d(i,{_ExrTextureLoader:()=>D});var j=K(1112),N=K(1052);const E=65536,v=14,e=65537,Y=16384;var H,f;!function(a){a[a.NO_COMPRESSION=0]="NO_COMPRESSION",a[a.RLE_COMPRESSION=1]="RLE_COMPRESSION",a[a.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",a[a.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",a[a.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",a[a.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(H||(H={})),function(a){a[a.INCREASING_Y=0]="INCREASING_Y",a[a.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const o=function(){const a=new ArrayBuffer(4),i=new Float32Array(a),K=new Uint32Array(a),j=new Uint32Array(512),N=new Uint32Array(512);for(let Y=0;Y<256;++Y){const a=Y-127;a<-27?(j[Y]=0,j[256|Y]=32768,N[Y]=24,N[256|Y]=24):a<-14?(j[Y]=1024>>-a-14,j[256|Y]=1024>>-a-14|32768,N[Y]=-a-1,N[256|Y]=-a-1):a<=15?(j[Y]=a+15<<10,j[256|Y]=a+15<<10|32768,N[Y]=13,N[256|Y]=13):a<128?(j[Y]=31744,j[256|Y]=64512,N[Y]=24,N[256|Y]=24):(j[Y]=31744,j[256|Y]=64512,N[Y]=13,N[256|Y]=13)}const E=new Uint32Array(2048),v=new Uint32Array(64),e=new Uint32Array(64);for(let Y=1;Y<1024;++Y){let a=Y<<13,i=0;for(;0===(8388608&a);)a<<=1,i-=8388608;a&=-8388609,i+=947912704,E[Y]=a|i}for(let Y=1024;Y<2048;++Y)E[Y]=939524096+(Y-1024<<13);for(let Y=1;Y<31;++Y)v[Y]=Y<<23;v[31]=1199570944,v[32]=2147483648;for(let Y=33;Y<63;++Y)v[Y]=2147483648+(Y-32<<23);v[63]=3347054592;for(let Y=1;Y<64;++Y)32!==Y&&(e[Y]=1024);return{floatView:i,uint32View:K,baseTable:j,shiftTable:N,mantissaTable:E,exponentTable:v,offsetTable:e}}();function U(a,i){const K=new Uint8Array(a);let j=0;for(;0!=K[i.value+j];)j+=1;const N=(new TextDecoder).decode(K.slice(i.value,i.value+j));return i.value=i.value+j+1,N}function q(a,i){const K=a.getInt32(i.value,!0);return i.value+=4,K}function u(a,i){const K=a.getUint32(i.value,!0);return i.value+=4,K}function g(a,i){const K=a.getUint8(i.value);return i.value+=1,K}function s(a,i){const K=a.getUint16(i.value,!0);return i.value+=2,K}function B(a,i){const K=a[i.value];return i.value+=1,K}function h(a,i){let K;return K="getBigInt64"in DataView.prototype?Number(a.getBigInt64(i.value,!0)):a.getUint32(i.value+4,!0)+Number(a.getUint32(i.value,!0)<<32),i.value+=8,K}function p(a,i){const K=a.getFloat32(i.value,!0);return i.value+=4,K}function T(a,i){return function(a){const i=(31744&a)>>10,K=1023&a;return(a>>15?-1:1)*(i?31===i?K?NaN:1/0:Math.pow(2,i-15)*(1+K/1024):K/1024*6103515625e-14)}(s(a,i))}function G(a,i){return function(a){if(Math.abs(a)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");a=(0,N.b)(a,-65504,65504),o.floatView[0]=a;const i=o.uint32View[0],K=i>>23&511;return o.baseTable[K]+((8388607&i)>>o.shiftTable[K])}(p(a,i))}function z(a,i,K,j){switch(K){case"string":case"stringvector":case"iccProfile":return function(a,i,K){const j=(new TextDecoder).decode(new Uint8Array(a).slice(i.value,i.value+K));return i.value=i.value+K,j}(a.buffer,i,j);case"chlist":return function(a,i,K){const j=i.value,N=[];for(;i.value<j+K-1;){const K=U(a.buffer,i),j=q(a,i),E=g(a,i);i.value+=3;const v=q(a,i),e=q(a,i);N.push({name:K,pixelType:j,pLinear:E,xSampling:v,ySampling:e})}return i.value+=1,N}(a,i,j);case"chromaticities":return function(a,i){return{redX:p(a,i),redY:p(a,i),greenX:p(a,i),greenY:p(a,i),blueX:p(a,i),blueY:p(a,i),whiteX:p(a,i),whiteY:p(a,i)}}(a,i);case"compression":return function(a,i){return g(a,i)}(a,i);case"box2i":return function(a,i){return{xMin:q(a,i),yMin:q(a,i),xMax:q(a,i),yMax:q(a,i)}}(a,i);case"lineOrder":return function(a,i){const K=g(a,i);return f[K]}(a,i);case"float":return p(a,i);case"v2f":return function(a,i){return[p(a,i),p(a,i)]}(a,i);case"v3f":return function(a,i){return[p(a,i),p(a,i),p(a,i)]}(a,i);case"int":return q(a,i);case"rational":return function(a,i){return[q(a,i),u(a,i)]}(a,i);case"timecode":return function(a,i){return[u(a,i),u(a,i)]}(a,i);case"preview":return i.value+=j,"skipped";default:return void(i.value+=j)}}function R(a){for(let i=1;i<a.length;i++){const K=a[i-1]+a[i]-128;a[i]=K}}function P(a,i){let K=0,j=Math.floor((a.length+1)/2),N=0;const E=a.length-1;for(;!(N>E)&&(i[N++]=a[K++],!(N>E));)i[N++]=a[j++]}function S(a,i,K,j,N){for(;K<a;)i=i<<8|B(j,N),K+=8;return{l:i>>(K-=a)&(1<<a)-1,c:i,lc:K}}function m(a,i,K,j){return{c:a=a<<8|B(K,j),lc:i+=8}}function d(a,i,K,j,N,E,v,e,Y){if(a==i){if(j<8){const a=m(K,j,N,E);K=a.c,j=a.lc}let a=K>>(j-=8);if(a=new Uint8Array([a])[0],e.value+a>Y)return null;const i=v[e.value-1];for(;a-- >0;)v[e.value++]=i}else{if(!(e.value<Y))return null;v[e.value++]=a}return{c:K,lc:j}}const X=new Array(59);function M(a,i,K,j,N,E){const v=i;let Y=0,H=0;for(;j<=N;j++){if(v.value-i.value>K)return;let e=S(6,Y,H,a,v);const f=e.l;if(Y=e.c,H=e.lc,E[j]=f,63==f){if(v.value-i.value>K)throw new Error("Error in HufUnpackEncTable");e=S(8,Y,H,a,v);let f=e.l+6;if(Y=e.c,H=e.lc,j+f>N+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)E[j++]=0;j--}else if(f>=59){let a=f-59+2;if(j+a>N+1)throw new Error("Error in HufUnpackEncTable");for(;a--;)E[j++]=0;j--}}!function(a){for(let K=0;K<=58;++K)X[K]=0;for(let K=0;K<e;++K)X[a[K]]+=1;let i=0;for(let K=58;K>0;--K){const a=i+X[K]>>1;X[K]=i,i=a}for(let K=0;K<e;++K){const i=a[K];i>0&&(a[K]=i|X[i]++<<6)}}(E)}function V(a){return 63&a}function w(a){return a>>6}function y(a,i,K,j,N,E){const H=K.value,f=u(i,K),o=u(i,K);K.value+=4;const U=u(i,K);if(K.value+=4,f<0||f>=e||o<0||o>=e)throw new Error("Wrong HUF_ENCSIZE");const q=new Array(e),g=new Array(Y);!function(a){for(let i=0;i<Y;i++)a[i]={},a[i].len=0,a[i].lit=0,a[i].p=null}(g);if(M(a,K,j-(K.value-H),f,o,q),U>8*(j-(K.value-H)))throw new Error("Wrong hufUncompress");!function(a,i,K,j){for(;i<=K;i++){const K=w(a[i]),N=V(a[i]);if(K>>N)throw new Error("Invalid table entry");if(N>v){const a=j[K>>N-v];if(a.len)throw new Error("Invalid table entry");if(a.lit++,a.p){const i=a.p;a.p=new Array(a.lit);for(let K=0;K<a.lit-1;++K)a.p[K]=i[K]}else a.p=new Array(1);a.p[a.lit-1]=i}else if(N){let a=0;for(let E=1<<v-N;E>0;E--){const E=j[(K<<v-N)+a];if(E.len||E.p)throw new Error("Invalid table entry");E.len=N,E.lit=i,a++}}}}(q,f,o,g),function(a,i,K,j,N,E,e,Y,H){let f=0,o=0;const U=e,q=Math.trunc(j.value+(N+7)/8);for(;j.value<q;){let N=m(f,o,K,j);for(f=N.c,o=N.lc;o>=v;){const e=i[f>>o-v&16383];if(e.len){o-=e.len;const a=d(e.lit,E,f,o,K,j,Y,H,U);a&&(f=a.c,o=a.lc)}else{if(!e.p)throw new Error("hufDecode issues");let i;for(i=0;i<e.lit;i++){const v=V(a[e.p[i]]);for(;o<v&&j.value<q;)N=m(f,o,K,j),f=N.c,o=N.lc;if(o>=v&&w(a[e.p[i]])==(f>>o-v&(1<<v)-1)){o-=v;const a=d(e.p[i],E,f,o,K,j,Y,H,U);a&&(f=a.c,o=a.lc);break}}if(i==e.lit)throw new Error("HufDecode issues")}}}const u=8-N&7;for(f>>=u,o-=u;o>0;){const a=i[f<<v-o&16383];if(!a.len)throw new Error("HufDecode issues");{o-=a.len;const i=d(a.lit,E,f,o,K,j,Y,H,U);i&&(f=i.c,o=i.lc)}}}(q,g,a,K,U,o,E,N,{value:0})}function O(a){return 65535&a}function c(a){const i=O(a);return i>32767?i-65536:i}function x(a,i){const K=c(a),j=c(i),N=K+(1&j)+(j>>1);return{a:N,b:N-j}}function r(a,i){const K=O(a),j=O(i),N=K-(j>>1)&65535;return{a:j+N-32768&65535,b:N}}function J(a,i,K,j,N,E,v){const e=v<16384,Y=K>N?N:K;let H,f,o=1;for(;o<=Y;)o<<=1;for(o>>=1,H=o,o>>=1;o>=1;){f=0;const v=f+E*(N-H),Y=E*o,U=E*H,q=j*o,u=j*H;let g,s,B,h;for(;f<=v;f+=U){let N=f;const E=f+j*(K-H);for(;N<=E;N+=u){const K=N+q,j=N+Y,E=j+q;if(e){let v=x(a[N+i],a[j+i]);g=v.a,B=v.b,v=x(a[K+i],a[E+i]),s=v.a,h=v.b,v=x(g,s),a[N+i]=v.a,a[K+i]=v.b,v=x(B,h),a[j+i]=v.a,a[E+i]=v.b}else{let v=r(a[N+i],a[j+i]);g=v.a,B=v.b,v=r(a[K+i],a[E+i]),s=v.a,h=v.b,v=r(g,s),a[N+i]=v.a,a[K+i]=v.b,v=r(B,h),a[j+i]=v.a,a[E+i]=v.b}}if(K&o){const K=N+Y;let j;j=e?x(a[N+i],a[K+i]):r(a[N+i],a[K+i]),g=j.a,a[K+i]=j.b,a[N+i]=g}}if(N&o){let N=f;const E=f+j*(K-H);for(;N<=E;N+=u){const K=N+q;let j;j=e?x(a[N+i],a[K+i]):r(a[N+i],a[K+i]),g=j.a,a[K+i]=j.b,a[N+i]=g}}H=o,o>>=1}return f}function l(a){return new DataView(a.array.buffer,a.offset.value,a.size)}function k(a){const i=a.viewer.buffer.slice(a.offset.value,a.offset.value+a.size),K=new Uint8Array(function(a){let i=a.byteLength;const K=new Array;let j=0;const N=new DataView(a);for(;i>0;){const a=N.getInt8(j++);if(a<0){const E=-a;i-=E+1;for(let a=0;a<E;a++)K.push(N.getUint8(j++))}else{const E=a;i-=2;const v=N.getUint8(j++);for(let a=0;a<E+1;a++)K.push(v)}}return K}(i)),j=new Uint8Array(K.length);return R(K),P(K,j),new DataView(j.buffer)}function W(a){const i=a.array.slice(a.offset.value,a.offset.value+a.size),K=fflate.unzlibSync(i),j=new Uint8Array(K.length);return R(K),P(K,j),new DataView(j.buffer)}function I(a){const i=a.array.slice(a.offset.value,a.offset.value+a.size),K=fflate.unzlibSync(i),j=a.lines*a.channels*a.width,N=1==a.type?new Uint16Array(j):new Uint32Array(j);let E=0,v=0;const e=new Array(4);for(let Y=0;Y<a.lines;Y++)for(let i=0;i<a.channels;i++){let i=0;switch(a.type){case 1:e[0]=E,e[1]=e[0]+a.width,E=e[1]+a.width;for(let j=0;j<a.width;++j){i+=K[e[0]++]<<8|K[e[1]++],N[v]=i,v++}break;case 2:e[0]=E,e[1]=e[0]+a.width,e[2]=e[1]+a.width,E=e[2]+a.width;for(let j=0;j<a.width;++j){i+=K[e[0]++]<<24|K[e[1]++]<<16|K[e[2]++]<<8,N[v]=i,v++}}}return new DataView(N.buffer)}function C(a){const i=a.viewer,K={value:a.offset.value},j=new Uint16Array(a.width*a.scanlineBlockSize*(a.channels*a.type)),N=new Uint8Array(8192);let v=0;const e=new Array(a.channels);for(let E=0;E<a.channels;E++)e[E]={},e[E].start=v,e[E].end=e[E].start,e[E].nx=a.width,e[E].ny=a.lines,e[E].size=a.type,v+=e[E].nx*e[E].ny*e[E].size;const Y=s(i,K),H=s(i,K);if(H>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=H)for(let E=0;E<H-Y+1;E++)N[E+Y]=g(i,K);const f=new Uint16Array(E),o=function(a,i){let K=0;for(let N=0;N<E;++N)(0==N||a[N>>3]&1<<(7&N))&&(i[K++]=N);const j=K-1;for(;K<E;)i[K++]=0;return j}(N,f),U=u(i,K);y(a.array,i,K,U,j,v);for(let E=0;E<a.channels;++E){const a=e[E];for(let i=0;i<e[E].size;++i)J(j,a.start+i,a.nx,a.size,a.ny,a.nx*a.size,o)}!function(a,i,K){for(let j=0;j<K;++j)i[j]=a[i[j]]}(f,j,v);let q=0;const B=new Uint8Array(j.buffer.byteLength);for(let E=0;E<a.lines;E++)for(let i=0;i<a.channels;i++){const a=e[i],K=a.nx*a.size,N=new Uint8Array(j.buffer,2*a.end,2*K);B.set(N,q),q+=2*K,a.end+=K}return new DataView(B.buffer)}var Q,b=K(1225);!function(a){a[a.Float=0]="Float",a[a.HalfFloat=1]="HalfFloat"}(Q||(Q={}));class Z{}Z.DefaultOutputType=Q.HalfFloat,Z.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class D{constructor(){this.supportCascades=!1}loadCubeData(a,i,K,j,N){throw".exr not supported in Cube."}async loadData(a,i,K){const N=new DataView(a.buffer),E={value:0},v=function(a,i){if(20000630!=a.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const K=a.getUint8(4),N=a.getUint8(5),E={singleTile:!!(2&N),longName:!!(4&N),deepFormat:!!(8&N),multiPart:!!(16&N)};i.value=8;const v={};let e=!0;for(;e;){const K=U(a.buffer,i);if(K){const N=U(a.buffer,i),E=z(a,i,N,u(a,i));void 0===E?j.c.Warn(`Unknown header attribute type ${N}'.`):v[K]=E}else e=!1}if(0!=(-5&N))throw new Error("Unsupported file format");return{version:K,spec:E,...v}}(N,E),e=await async function(a,i,K,j){const N={size:0,viewer:i,array:new Uint8Array(i.buffer),offset:K,width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,channels:a.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(a.compression){case H.NO_COMPRESSION:N.lines=1,N.uncompress=l;break;case H.RLE_COMPRESSION:N.lines=1,N.uncompress=k;break;case H.ZIPS_COMPRESSION:N.lines=1,N.uncompress=W,await b.e.LoadScriptAsync(Z.FFLATEUrl);break;case H.ZIP_COMPRESSION:N.lines=16,N.uncompress=W,await b.e.LoadScriptAsync(Z.FFLATEUrl);break;case H.PIZ_COMPRESSION:N.lines=32,N.uncompress=C;break;case H.PXR24_COMPRESSION:N.lines=16,N.uncompress=I,await b.e.LoadScriptAsync(Z.FFLATEUrl);break;default:throw new Error(H[a.compression]+" is unsupported")}N.scanlineBlockSize=N.lines;const E={};for(const H of a.channels)switch(H.name){case"Y":case"R":case"G":case"B":case"A":E[H.name]=!0,N.type=H.pixelType}let v=!1;if(E.R&&E.G&&E.B)v=!E.A,N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else{if(!E.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");N.outputChannels=1,N.decodeChannels={Y:0}}if(1===N.type)switch(j){case Q.Float:N.getter=T,N.inputSize=2;break;case Q.HalfFloat:N.getter=s,N.inputSize=2}else{if(2!==N.type)throw new Error("Unsupported pixelType "+N.type+" for "+a.compression);switch(j){case Q.Float:N.getter=p,N.inputSize=4;break;case Q.HalfFloat:N.getter=G,N.inputSize=4}}N.blockCount=N.height/N.scanlineBlockSize;for(let H=0;H<N.blockCount;H++)h(i,K);const e=N.width*N.height*N.outputChannels;switch(j){case Q.Float:N.byteArray=new Float32Array(e),N.textureType=1,v&&N.byteArray.fill(1,0,e);break;case Q.HalfFloat:N.byteArray=new Uint16Array(e),N.textureType=2,v&&N.byteArray.fill(15360,0,e);break;default:throw new Error("Unsupported type: "+j)}let Y=0;for(const H of a.channels)void 0!==N.decodeChannels[H.name]&&(N.channelLineOffsets[H.name]=Y*N.width),Y+=2*H.pixelType;return N.bytesPerLine=N.width*Y,N.outLineWidth=N.width*N.outputChannels,"INCREASING_Y"===a.lineOrder?N.scanOrder=a=>a:N.scanOrder=a=>N.height-1-a,4==N.outputChannels?(N.format=5,N.linearSpace=!0):(N.format=6,N.linearSpace=!1),N}(v,N,E,Z.DefaultOutputType);!function(a,i,K,j){const N={value:0};for(let E=0;E<a.height/a.scanlineBlockSize;E++){const v=q(K,j)-i.dataWindow.yMin;a.size=u(K,j),a.lines=v+a.scanlineBlockSize>a.height?a.height-v:a.scanlineBlockSize;const e=a.size<a.lines*a.bytesPerLine&&a.uncompress?a.uncompress(a):l(a);j.value+=a.size;for(let K=0;K<a.scanlineBlockSize;K++){const j=E*a.scanlineBlockSize,v=K+a.scanOrder(j);if(v>=a.height)continue;const Y=K*a.bytesPerLine,H=(a.height-1-v)*a.outLineWidth;for(let K=0;K<a.channels;K++){const j=i.channels[K].name,E=a.channelLineOffsets[j],v=a.decodeChannels[j];if(void 0!==v){N.value=Y+E;for(let i=0;i<a.width;i++){const K=H+i*a.outputChannels+v;a.byteArray&&(a.byteArray[K]=a.getter(e,N))}}}}}}(e,v,N,E);K(v.dataWindow.xMax-v.dataWindow.xMin+1,v.dataWindow.yMax-v.dataWindow.yMin+1,i.generateMipMaps,!1,(()=>{const a=i.getEngine();i.format=v.format,i.type=e.textureType,i.invertY=!1,i._gammaSpace=!v.linearSpace,e.byteArray&&a._uploadDataToTextureDirectly(i,e.byteArray,0,0,void 0,!0)}))}}}}]);