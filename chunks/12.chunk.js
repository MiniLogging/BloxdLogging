"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10176:(I,k,i)=>{i.r(k),i.d(k,{_ExrTextureLoader:()=>K});var d=i(1079),u=i(1024);const H=65536,Y=14,x=65537,j=16384;var l,g;!function(I){I[I.NO_COMPRESSION=0]="NO_COMPRESSION",I[I.RLE_COMPRESSION=1]="RLE_COMPRESSION",I[I.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",I[I.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",I[I.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",I[I.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(l||(l={})),function(I){I[I.INCREASING_Y=0]="INCREASING_Y",I[I.DECREASING_Y=1]="DECREASING_Y"}(g||(g={}));const P=function(){const I=new ArrayBuffer(4),k=new Float32Array(I),i=new Uint32Array(I),d=new Uint32Array(512),u=new Uint32Array(512);for(let j=0;j<256;++j){const I=j-127;I<-27?(d[j]=0,d[256|j]=32768,u[j]=24,u[256|j]=24):I<-14?(d[j]=1024>>-I-14,d[256|j]=1024>>-I-14|32768,u[j]=-I-1,u[256|j]=-I-1):I<=15?(d[j]=I+15<<10,d[256|j]=I+15<<10|32768,u[j]=13,u[256|j]=13):I<128?(d[j]=31744,d[256|j]=64512,u[j]=24,u[256|j]=24):(d[j]=31744,d[256|j]=64512,u[j]=13,u[256|j]=13)}const H=new Uint32Array(2048),Y=new Uint32Array(64),x=new Uint32Array(64);for(let j=1;j<1024;++j){let I=j<<13,k=0;for(;0===(8388608&I);)I<<=1,k-=8388608;I&=-8388609,k+=947912704,H[j]=I|k}for(let j=1024;j<2048;++j)H[j]=939524096+(j-1024<<13);for(let j=1;j<31;++j)Y[j]=j<<23;Y[31]=1199570944,Y[32]=2147483648;for(let j=33;j<63;++j)Y[j]=2147483648+(j-32<<23);Y[63]=3347054592;for(let j=1;j<64;++j)32!==j&&(x[j]=1024);return{floatView:k,uint32View:i,baseTable:d,shiftTable:u,mantissaTable:H,exponentTable:Y,offsetTable:x}}();function J(I,k){const i=new Uint8Array(I);let d=0;for(;0!=i[k.value+d];)d+=1;const u=(new TextDecoder).decode(i.slice(k.value,k.value+d));return k.value=k.value+d+1,u}function L(I,k){const i=I.getInt32(k.value,!0);return k.value+=4,i}function s(I,k){const i=I.getUint32(k.value,!0);return k.value+=4,i}function h(I,k){const i=I.getUint8(k.value);return k.value+=1,i}function Z(I,k){const i=I.getUint16(k.value,!0);return k.value+=2,i}function n(I,k){const i=I[k.value];return k.value+=1,i}function B(I,k){let i;return i="getBigInt64"in DataView.prototype?Number(I.getBigInt64(k.value,!0)):I.getUint32(k.value+4,!0)+Number(I.getUint32(k.value,!0)<<32),k.value+=8,i}function b(I,k){const i=I.getFloat32(k.value,!0);return k.value+=4,i}function o(I,k){return function(I){const k=(31744&I)>>10,i=1023&I;return(I>>15?-1:1)*(k?31===k?i?NaN:1/0:Math.pow(2,k-15)*(1+i/1024):i/1024*6103515625e-14)}(Z(I,k))}function F(I,k){return function(I){if(Math.abs(I)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");I=(0,u.d)(I,-65504,65504),P.floatView[0]=I;const k=P.uint32View[0],i=k>>23&511;return P.baseTable[i]+((8388607&k)>>P.shiftTable[i])}(b(I,k))}function T(I,k,i,d){switch(i){case"string":case"stringvector":case"iccProfile":return function(I,k,i){const d=(new TextDecoder).decode(new Uint8Array(I).slice(k.value,k.value+i));return k.value=k.value+i,d}(I.buffer,k,d);case"chlist":return function(I,k,i){const d=k.value,u=[];for(;k.value<d+i-1;){const i=J(I.buffer,k),d=L(I,k),H=h(I,k);k.value+=3;const Y=L(I,k),x=L(I,k);u.push({name:i,pixelType:d,pLinear:H,xSampling:Y,ySampling:x})}return k.value+=1,u}(I,k,d);case"chromaticities":return function(I,k){return{redX:b(I,k),redY:b(I,k),greenX:b(I,k),greenY:b(I,k),blueX:b(I,k),blueY:b(I,k),whiteX:b(I,k),whiteY:b(I,k)}}(I,k);case"compression":return function(I,k){return h(I,k)}(I,k);case"box2i":return function(I,k){return{xMin:L(I,k),yMin:L(I,k),xMax:L(I,k),yMax:L(I,k)}}(I,k);case"lineOrder":return function(I,k){const i=h(I,k);return g[i]}(I,k);case"float":return b(I,k);case"v2f":return function(I,k){return[b(I,k),b(I,k)]}(I,k);case"v3f":return function(I,k){return[b(I,k),b(I,k),b(I,k)]}(I,k);case"int":return L(I,k);case"rational":return function(I,k){return[L(I,k),s(I,k)]}(I,k);case"timecode":return function(I,k){return[s(I,k),s(I,k)]}(I,k);case"preview":return k.value+=d,"skipped";default:return void(k.value+=d)}}function W(I){for(let k=1;k<I.length;k++){const i=I[k-1]+I[k]-128;I[k]=i}}function G(I,k){let i=0,d=Math.floor((I.length+1)/2),u=0;const H=I.length-1;for(;!(u>H)&&(k[u++]=I[i++],!(u>H));)k[u++]=I[d++]}function V(I,k,i,d,u){for(;i<I;)k=k<<8|n(d,u),i+=8;return{l:k>>(i-=I)&(1<<I)-1,c:k,lc:i}}function w(I,k,i,d){return{c:I=I<<8|n(i,d),lc:k+=8}}function r(I,k,i,d,u,H,Y,x,j){if(I==k){if(d<8){const I=w(i,d,u,H);i=I.c,d=I.lc}let I=i>>(d-=8);if(I=new Uint8Array([I])[0],x.value+I>j)return null;const k=Y[x.value-1];for(;I-- >0;)Y[x.value++]=k}else{if(!(x.value<j))return null;Y[x.value++]=I}return{c:i,lc:d}}const Q=new Array(59);function t(I,k,i,d,u,H){const Y=k;let j=0,l=0;for(;d<=u;d++){if(Y.value-k.value>i)return;let x=V(6,j,l,I,Y);const g=x.l;if(j=x.c,l=x.lc,H[d]=g,63==g){if(Y.value-k.value>i)throw new Error("Error in HufUnpackEncTable");x=V(8,j,l,I,Y);let g=x.l+6;if(j=x.c,l=x.lc,d+g>u+1)throw new Error("Error in HufUnpackEncTable");for(;g--;)H[d++]=0;d--}else if(g>=59){let I=g-59+2;if(d+I>u+1)throw new Error("Error in HufUnpackEncTable");for(;I--;)H[d++]=0;d--}}!function(I){for(let i=0;i<=58;++i)Q[i]=0;for(let i=0;i<x;++i)Q[I[i]]+=1;let k=0;for(let i=58;i>0;--i){const I=k+Q[i]>>1;Q[i]=k,k=I}for(let i=0;i<x;++i){const k=I[i];k>0&&(I[i]=k|Q[k]++<<6)}}(H)}function a(I){return 63&I}function v(I){return I>>6}function R(I,k,i,d,u,H){const l=i.value,g=s(k,i),P=s(k,i);i.value+=4;const J=s(k,i);if(i.value+=4,g<0||g>=x||P<0||P>=x)throw new Error("Wrong HUF_ENCSIZE");const L=new Array(x),h=new Array(j);!function(I){for(let k=0;k<j;k++)I[k]={},I[k].len=0,I[k].lit=0,I[k].p=null}(h);if(t(I,i,d-(i.value-l),g,P,L),J>8*(d-(i.value-l)))throw new Error("Wrong hufUncompress");!function(I,k,i,d){for(;k<=i;k++){const i=v(I[k]),u=a(I[k]);if(i>>u)throw new Error("Invalid table entry");if(u>Y){const I=d[i>>u-Y];if(I.len)throw new Error("Invalid table entry");if(I.lit++,I.p){const k=I.p;I.p=new Array(I.lit);for(let i=0;i<I.lit-1;++i)I.p[i]=k[i]}else I.p=new Array(1);I.p[I.lit-1]=k}else if(u){let I=0;for(let H=1<<Y-u;H>0;H--){const H=d[(i<<Y-u)+I];if(H.len||H.p)throw new Error("Invalid table entry");H.len=u,H.lit=k,I++}}}}(L,g,P,h),function(I,k,i,d,u,H,x,j,l){let g=0,P=0;const J=x,L=Math.trunc(d.value+(u+7)/8);for(;d.value<L;){let u=w(g,P,i,d);for(g=u.c,P=u.lc;P>=Y;){const x=k[g>>P-Y&16383];if(x.len){P-=x.len;const I=r(x.lit,H,g,P,i,d,j,l,J);I&&(g=I.c,P=I.lc)}else{if(!x.p)throw new Error("hufDecode issues");let k;for(k=0;k<x.lit;k++){const Y=a(I[x.p[k]]);for(;P<Y&&d.value<L;)u=w(g,P,i,d),g=u.c,P=u.lc;if(P>=Y&&v(I[x.p[k]])==(g>>P-Y&(1<<Y)-1)){P-=Y;const I=r(x.p[k],H,g,P,i,d,j,l,J);I&&(g=I.c,P=I.lc);break}}if(k==x.lit)throw new Error("HufDecode issues")}}}const s=8-u&7;for(g>>=s,P-=s;P>0;){const I=k[g<<Y-P&16383];if(!I.len)throw new Error("HufDecode issues");{P-=I.len;const k=r(I.lit,H,g,P,i,d,j,l,J);k&&(g=k.c,P=k.lc)}}}(L,h,I,i,J,P,H,u,{value:0})}function E(I){return 65535&I}function O(I){const k=E(I);return k>32767?k-65536:k}function f(I,k){const i=O(I),d=O(k),u=i+(1&d)+(d>>1);return{a:u,b:u-d}}function C(I,k){const i=E(I),d=E(k),u=i-(d>>1)&65535;return{a:d+u-32768&65535,b:u}}function e(I,k,i,d,u,H,Y){const x=Y<16384,j=i>u?u:i;let l,g,P=1;for(;P<=j;)P<<=1;for(P>>=1,l=P,P>>=1;P>=1;){g=0;const Y=g+H*(u-l),j=H*P,J=H*l,L=d*P,s=d*l;let h,Z,n,B;for(;g<=Y;g+=J){let u=g;const H=g+d*(i-l);for(;u<=H;u+=s){const i=u+L,d=u+j,H=d+L;if(x){let Y=f(I[u+k],I[d+k]);h=Y.a,n=Y.b,Y=f(I[i+k],I[H+k]),Z=Y.a,B=Y.b,Y=f(h,Z),I[u+k]=Y.a,I[i+k]=Y.b,Y=f(n,B),I[d+k]=Y.a,I[H+k]=Y.b}else{let Y=C(I[u+k],I[d+k]);h=Y.a,n=Y.b,Y=C(I[i+k],I[H+k]),Z=Y.a,B=Y.b,Y=C(h,Z),I[u+k]=Y.a,I[i+k]=Y.b,Y=C(n,B),I[d+k]=Y.a,I[H+k]=Y.b}}if(i&P){const i=u+j;let d;d=x?f(I[u+k],I[i+k]):C(I[u+k],I[i+k]),h=d.a,I[i+k]=d.b,I[u+k]=h}}if(u&P){let u=g;const H=g+d*(i-l);for(;u<=H;u+=s){const i=u+L;let d;d=x?f(I[u+k],I[i+k]):C(I[u+k],I[i+k]),h=d.a,I[i+k]=d.b,I[u+k]=h}}l=P,P>>=1}return g}function X(I){return new DataView(I.array.buffer,I.offset.value,I.size)}function p(I){const k=I.viewer.buffer.slice(I.offset.value,I.offset.value+I.size),i=new Uint8Array(function(I){let k=I.byteLength;const i=new Array;let d=0;const u=new DataView(I);for(;k>0;){const I=u.getInt8(d++);if(I<0){const H=-I;k-=H+1;for(let I=0;I<H;I++)i.push(u.getUint8(d++))}else{const H=I;k-=2;const Y=u.getUint8(d++);for(let I=0;I<H+1;I++)i.push(Y)}}return i}(k)),d=new Uint8Array(i.length);return W(i),G(i,d),new DataView(d.buffer)}function D(I){const k=I.array.slice(I.offset.value,I.offset.value+I.size),i=fflate.unzlibSync(k),d=new Uint8Array(i.length);return W(i),G(i,d),new DataView(d.buffer)}function A(I){const k=I.array.slice(I.offset.value,I.offset.value+I.size),i=fflate.unzlibSync(k),d=I.lines*I.channels*I.width,u=1==I.type?new Uint16Array(d):new Uint32Array(d);let H=0,Y=0;const x=new Array(4);for(let j=0;j<I.lines;j++)for(let k=0;k<I.channels;k++){let k=0;switch(I.type){case 1:x[0]=H,x[1]=x[0]+I.width,H=x[1]+I.width;for(let d=0;d<I.width;++d){k+=i[x[0]++]<<8|i[x[1]++],u[Y]=k,Y++}break;case 2:x[0]=H,x[1]=x[0]+I.width,x[2]=x[1]+I.width,H=x[2]+I.width;for(let d=0;d<I.width;++d){k+=i[x[0]++]<<24|i[x[1]++]<<16|i[x[2]++]<<8,u[Y]=k,Y++}}}return new DataView(u.buffer)}function c(I){const k=I.viewer,i={value:I.offset.value},d=new Uint16Array(I.width*I.scanlineBlockSize*(I.channels*I.type)),u=new Uint8Array(8192);let Y=0;const x=new Array(I.channels);for(let H=0;H<I.channels;H++)x[H]={},x[H].start=Y,x[H].end=x[H].start,x[H].nx=I.width,x[H].ny=I.lines,x[H].size=I.type,Y+=x[H].nx*x[H].ny*x[H].size;const j=Z(k,i),l=Z(k,i);if(l>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(j<=l)for(let H=0;H<l-j+1;H++)u[H+j]=h(k,i);const g=new Uint16Array(H),P=function(I,k){let i=0;for(let u=0;u<H;++u)(0==u||I[u>>3]&1<<(7&u))&&(k[i++]=u);const d=i-1;for(;i<H;)k[i++]=0;return d}(u,g),J=s(k,i);R(I.array,k,i,J,d,Y);for(let H=0;H<I.channels;++H){const I=x[H];for(let k=0;k<x[H].size;++k)e(d,I.start+k,I.nx,I.size,I.ny,I.nx*I.size,P)}!function(I,k,i){for(let d=0;d<i;++d)k[d]=I[k[d]]}(g,d,Y);let L=0;const n=new Uint8Array(d.buffer.byteLength);for(let H=0;H<I.lines;H++)for(let k=0;k<I.channels;k++){const I=x[k],i=I.nx*I.size,u=new Uint8Array(d.buffer,2*I.end,2*i);n.set(u,L),L+=2*i,I.end+=i}return new DataView(n.buffer)}var S,z=i(1179);!function(I){I[I.Float=0]="Float",I[I.HalfFloat=1]="HalfFloat"}(S||(S={}));class m{}m.DefaultOutputType=S.HalfFloat,m.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class K{constructor(){this.supportCascades=!1}loadCubeData(I,k,i,d,u){throw".exr not supported in Cube."}async loadData(I,k,i){const u=new DataView(I.buffer),H={value:0},Y=function(I,k){if(20000630!=I.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const i=I.getUint8(4),u=I.getUint8(5),H={singleTile:!!(2&u),longName:!!(4&u),deepFormat:!!(8&u),multiPart:!!(16&u)};k.value=8;const Y={};let x=!0;for(;x;){const i=J(I.buffer,k);if(i){const u=J(I.buffer,k),H=T(I,k,u,s(I,k));void 0===H?d.d.Warn(`Unknown header attribute type ${u}'.`):Y[i]=H}else x=!1}if(0!=(-5&u))throw new Error("Unsupported file format");return{version:i,spec:H,...Y}}(u,H),x=await async function(I,k,i,d){const u={size:0,viewer:k,array:new Uint8Array(k.buffer),offset:i,width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,channels:I.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(I.compression){case l.NO_COMPRESSION:u.lines=1,u.uncompress=X;break;case l.RLE_COMPRESSION:u.lines=1,u.uncompress=p;break;case l.ZIPS_COMPRESSION:u.lines=1,u.uncompress=D,await z.d.LoadScriptAsync(m.FFLATEUrl);break;case l.ZIP_COMPRESSION:u.lines=16,u.uncompress=D,await z.d.LoadScriptAsync(m.FFLATEUrl);break;case l.PIZ_COMPRESSION:u.lines=32,u.uncompress=c;break;case l.PXR24_COMPRESSION:u.lines=16,u.uncompress=A,await z.d.LoadScriptAsync(m.FFLATEUrl);break;default:throw new Error(l[I.compression]+" is unsupported")}u.scanlineBlockSize=u.lines;const H={};for(const l of I.channels)switch(l.name){case"Y":case"R":case"G":case"B":case"A":H[l.name]=!0,u.type=l.pixelType}let Y=!1;if(H.R&&H.G&&H.B)Y=!H.A,u.outputChannels=4,u.decodeChannels={R:0,G:1,B:2,A:3};else{if(!H.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");u.outputChannels=1,u.decodeChannels={Y:0}}if(1===u.type)switch(d){case S.Float:u.getter=o,u.inputSize=2;break;case S.HalfFloat:u.getter=Z,u.inputSize=2}else{if(2!==u.type)throw new Error("Unsupported pixelType "+u.type+" for "+I.compression);switch(d){case S.Float:u.getter=b,u.inputSize=4;break;case S.HalfFloat:u.getter=F,u.inputSize=4}}u.blockCount=u.height/u.scanlineBlockSize;for(let l=0;l<u.blockCount;l++)B(k,i);const x=u.width*u.height*u.outputChannels;switch(d){case S.Float:u.byteArray=new Float32Array(x),u.textureType=1,Y&&u.byteArray.fill(1,0,x);break;case S.HalfFloat:u.byteArray=new Uint16Array(x),u.textureType=2,Y&&u.byteArray.fill(15360,0,x);break;default:throw new Error("Unsupported type: "+d)}let j=0;for(const l of I.channels)void 0!==u.decodeChannels[l.name]&&(u.channelLineOffsets[l.name]=j*u.width),j+=2*l.pixelType;return u.bytesPerLine=u.width*j,u.outLineWidth=u.width*u.outputChannels,"INCREASING_Y"===I.lineOrder?u.scanOrder=I=>I:u.scanOrder=I=>u.height-1-I,4==u.outputChannels?(u.format=5,u.linearSpace=!0):(u.format=6,u.linearSpace=!1),u}(Y,u,H,m.DefaultOutputType);!function(I,k,i,d){const u={value:0};for(let H=0;H<I.height/I.scanlineBlockSize;H++){const Y=L(i,d)-k.dataWindow.yMin;I.size=s(i,d),I.lines=Y+I.scanlineBlockSize>I.height?I.height-Y:I.scanlineBlockSize;const x=I.size<I.lines*I.bytesPerLine&&I.uncompress?I.uncompress(I):X(I);d.value+=I.size;for(let i=0;i<I.scanlineBlockSize;i++){const d=H*I.scanlineBlockSize,Y=i+I.scanOrder(d);if(Y>=I.height)continue;const j=i*I.bytesPerLine,l=(I.height-1-Y)*I.outLineWidth;for(let i=0;i<I.channels;i++){const d=k.channels[i].name,H=I.channelLineOffsets[d],Y=I.decodeChannels[d];if(void 0!==Y){u.value=j+H;for(let k=0;k<I.width;k++){const i=l+k*I.outputChannels+Y;I.byteArray&&(I.byteArray[i]=I.getter(x,u))}}}}}}(x,Y,u,H);i(Y.dataWindow.xMax-Y.dataWindow.xMin+1,Y.dataWindow.yMax-Y.dataWindow.yMin+1,k.generateMipMaps,!1,(()=>{const I=k.getEngine();k.format=Y.format,k.type=x.textureType,k.invertY=!1,k._gammaSpace=!Y.linearSpace,x.byteArray&&I._uploadDataToTextureDirectly(k,x.byteArray,0,0,void 0,!0)}))}}}}]);