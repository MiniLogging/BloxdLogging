"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{13101:(a,v,p)=>{p.r(v),p.d(v,{_DDSTextureLoader:()=>L});var P=p(11714),b=p(11733);class L{constructor(){this.supportCascades=!0}loadCubeData(a,v,p,L){const t=v.getEngine();let V,K=!1,C=1e3;if(Array.isArray(a))for(let P=0;P<a.length;P++){const p=a[P];V=b.d.GetDDSInfo(p),v.width=V.width,v.height=V.height,K=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&v.generateMipMaps,t._unpackFlipY(V.isCompressed),b.d.UploadDDSLevels(t,v,p,V,K,6,-1,P),V.isFourCC||1!==V.mipmapCount?C=V.mipmapCount-1:t.generateMipMapsForCubemap(v)}else{const L=a;V=b.d.GetDDSInfo(L),v.width=V.width,v.height=V.height,p&&(V.sphericalPolynomial=new P.f),K=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&v.generateMipMaps,t._unpackFlipY(V.isCompressed),b.d.UploadDDSLevels(t,v,L,V,K,6),V.isFourCC||1!==V.mipmapCount?C=V.mipmapCount-1:t.generateMipMapsForCubemap(v,!1)}t._setCubeMapTextureParams(v,K,C),v.isReady=!0,v.onLoadedObservable.notifyObservers(v),v.onLoadedObservable.clear(),L&&L({isDDS:!0,width:v.width,info:V,data:a,texture:v})}loadData(a,v,p){const P=b.d.GetDDSInfo(a),L=(P.isRGB||P.isLuminance||P.mipmapCount>1)&&v.generateMipMaps&&Math.max(P.width,P.height)>>P.mipmapCount-1===1;p(P.width,P.height,L,P.isFourCC,(()=>{b.d.UploadDDSLevels(v.getEngine(),v,a,P,L,1)}))}}}}]);