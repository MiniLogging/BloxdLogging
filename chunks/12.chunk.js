"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{11155:(L,i,P)=>{P.r(i),P.d(i,{_ExrTextureLoader:()=>E});var D=P(1098),V=P(1033);const M=65536,a=14,w=65537,O=16384;var U,C;!function(L){L[L.NO_COMPRESSION=0]="NO_COMPRESSION",L[L.RLE_COMPRESSION=1]="RLE_COMPRESSION",L[L.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",L[L.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",L[L.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",L[L.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(L){L[L.INCREASING_Y=0]="INCREASING_Y",L[L.DECREASING_Y=1]="DECREASING_Y"}(C||(C={}));const T=function(){const L=new ArrayBuffer(4),i=new Float32Array(L),P=new Uint32Array(L),D=new Uint32Array(512),V=new Uint32Array(512);for(let O=0;O<256;++O){const L=O-127;L<-27?(D[O]=0,D[256|O]=32768,V[O]=24,V[256|O]=24):L<-14?(D[O]=1024>>-L-14,D[256|O]=1024>>-L-14|32768,V[O]=-L-1,V[256|O]=-L-1):L<=15?(D[O]=L+15<<10,D[256|O]=L+15<<10|32768,V[O]=13,V[256|O]=13):L<128?(D[O]=31744,D[256|O]=64512,V[O]=24,V[256|O]=24):(D[O]=31744,D[256|O]=64512,V[O]=13,V[256|O]=13)}const M=new Uint32Array(2048),a=new Uint32Array(64),w=new Uint32Array(64);for(let O=1;O<1024;++O){let L=O<<13,i=0;for(;0===(8388608&L);)L<<=1,i-=8388608;L&=-8388609,i+=947912704,M[O]=L|i}for(let O=1024;O<2048;++O)M[O]=939524096+(O-1024<<13);for(let O=1;O<31;++O)a[O]=O<<23;a[31]=1199570944,a[32]=2147483648;for(let O=33;O<63;++O)a[O]=2147483648+(O-32<<23);a[63]=3347054592;for(let O=1;O<64;++O)32!==O&&(w[O]=1024);return{floatView:i,uint32View:P,baseTable:D,shiftTable:V,mantissaTable:M,exponentTable:a,offsetTable:w}}();function c(L,i){const P=new Uint8Array(L);let D=0;for(;0!=P[i.value+D];)D+=1;const V=(new TextDecoder).decode(P.slice(i.value,i.value+D));return i.value=i.value+D+1,V}function r(L,i){const P=L.getInt32(i.value,!0);return i.value+=4,P}function F(L,i){const P=L.getUint32(i.value,!0);return i.value+=4,P}function S(L,i){const P=L.getUint8(i.value);return i.value+=1,P}function q(L,i){const P=L.getUint16(i.value,!0);return i.value+=2,P}function H(L,i){const P=L[i.value];return i.value+=1,P}function j(L,i){let P;return P="getBigInt64"in DataView.prototype?Number(L.getBigInt64(i.value,!0)):L.getUint32(i.value+4,!0)+Number(L.getUint32(i.value,!0)<<32),i.value+=8,P}function B(L,i){const P=L.getFloat32(i.value,!0);return i.value+=4,P}function u(L,i){return function(L){const i=(31744&L)>>10,P=1023&L;return(L>>15?-1:1)*(i?31===i?P?NaN:1/0:Math.pow(2,i-15)*(1+P/1024):P/1024*6103515625e-14)}(q(L,i))}function p(L,i){return function(L){if(Math.abs(L)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");L=(0,V.c)(L,-65504,65504),T.floatView[0]=L;const i=T.uint32View[0],P=i>>23&511;return T.baseTable[P]+((8388607&i)>>T.shiftTable[P])}(B(L,i))}function m(L,i,P,D){switch(P){case"string":case"stringvector":case"iccProfile":return function(L,i,P){const D=(new TextDecoder).decode(new Uint8Array(L).slice(i.value,i.value+P));return i.value=i.value+P,D}(L.buffer,i,D);case"chlist":return function(L,i,P){const D=i.value,V=[];for(;i.value<D+P-1;){const P=c(L.buffer,i),D=r(L,i),M=S(L,i);i.value+=3;const a=r(L,i),w=r(L,i);V.push({name:P,pixelType:D,pLinear:M,xSampling:a,ySampling:w})}return i.value+=1,V}(L,i,D);case"chromaticities":return function(L,i){return{redX:B(L,i),redY:B(L,i),greenX:B(L,i),greenY:B(L,i),blueX:B(L,i),blueY:B(L,i),whiteX:B(L,i),whiteY:B(L,i)}}(L,i);case"compression":return function(L,i){return S(L,i)}(L,i);case"box2i":return function(L,i){return{xMin:r(L,i),yMin:r(L,i),xMax:r(L,i),yMax:r(L,i)}}(L,i);case"lineOrder":return function(L,i){const P=S(L,i);return C[P]}(L,i);case"float":return B(L,i);case"v2f":return function(L,i){return[B(L,i),B(L,i)]}(L,i);case"v3f":return function(L,i){return[B(L,i),B(L,i),B(L,i)]}(L,i);case"int":return r(L,i);case"rational":return function(L,i){return[r(L,i),F(L,i)]}(L,i);case"timecode":return function(L,i){return[F(L,i),F(L,i)]}(L,i);case"preview":return i.value+=D,"skipped";default:return void(i.value+=D)}}function X(L){for(let i=1;i<L.length;i++){const P=L[i-1]+L[i]-128;L[i]=P}}function o(L,i){let P=0,D=Math.floor((L.length+1)/2),V=0;const M=L.length-1;for(;!(V>M)&&(i[V++]=L[P++],!(V>M));)i[V++]=L[D++]}function g(L,i,P,D,V){for(;P<L;)i=i<<8|H(D,V),P+=8;return{l:i>>(P-=L)&(1<<L)-1,c:i,lc:P}}function Z(L,i,P,D){return{c:L=L<<8|H(P,D),lc:i+=8}}function G(L,i,P,D,V,M,a,w,O){if(L==i){if(D<8){const L=Z(P,D,V,M);P=L.c,D=L.lc}let L=P>>(D-=8);if(L=new Uint8Array([L])[0],w.value+L>O)return null;const i=a[w.value-1];for(;L-- >0;)a[w.value++]=i}else{if(!(w.value<O))return null;a[w.value++]=L}return{c:P,lc:D}}const n=new Array(59);function K(L,i,P,D,V,M){const a=i;let O=0,U=0;for(;D<=V;D++){if(a.value-i.value>P)return;let w=g(6,O,U,L,a);const C=w.l;if(O=w.c,U=w.lc,M[D]=C,63==C){if(a.value-i.value>P)throw new Error("Error in HufUnpackEncTable");w=g(8,O,U,L,a);let C=w.l+6;if(O=w.c,U=w.lc,D+C>V+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)M[D++]=0;D--}else if(C>=59){let L=C-59+2;if(D+L>V+1)throw new Error("Error in HufUnpackEncTable");for(;L--;)M[D++]=0;D--}}!function(L){for(let P=0;P<=58;++P)n[P]=0;for(let P=0;P<w;++P)n[L[P]]+=1;let i=0;for(let P=58;P>0;--P){const L=i+n[P]>>1;n[P]=i,i=L}for(let P=0;P<w;++P){const i=L[P];i>0&&(L[P]=i|n[i]++<<6)}}(M)}function I(L){return 63&L}function s(L){return L>>6}function A(L,i,P,D,V,M){const U=P.value,C=F(i,P),T=F(i,P);P.value+=4;const c=F(i,P);if(P.value+=4,C<0||C>=w||T<0||T>=w)throw new Error("Wrong HUF_ENCSIZE");const r=new Array(w),S=new Array(O);!function(L){for(let i=0;i<O;i++)L[i]={},L[i].len=0,L[i].lit=0,L[i].p=null}(S);if(K(L,P,D-(P.value-U),C,T,r),c>8*(D-(P.value-U)))throw new Error("Wrong hufUncompress");!function(L,i,P,D){for(;i<=P;i++){const P=s(L[i]),V=I(L[i]);if(P>>V)throw new Error("Invalid table entry");if(V>a){const L=D[P>>V-a];if(L.len)throw new Error("Invalid table entry");if(L.lit++,L.p){const i=L.p;L.p=new Array(L.lit);for(let P=0;P<L.lit-1;++P)L.p[P]=i[P]}else L.p=new Array(1);L.p[L.lit-1]=i}else if(V){let L=0;for(let M=1<<a-V;M>0;M--){const M=D[(P<<a-V)+L];if(M.len||M.p)throw new Error("Invalid table entry");M.len=V,M.lit=i,L++}}}}(r,C,T,S),function(L,i,P,D,V,M,w,O,U){let C=0,T=0;const c=w,r=Math.trunc(D.value+(V+7)/8);for(;D.value<r;){let V=Z(C,T,P,D);for(C=V.c,T=V.lc;T>=a;){const w=i[C>>T-a&16383];if(w.len){T-=w.len;const L=G(w.lit,M,C,T,P,D,O,U,c);L&&(C=L.c,T=L.lc)}else{if(!w.p)throw new Error("hufDecode issues");let i;for(i=0;i<w.lit;i++){const a=I(L[w.p[i]]);for(;T<a&&D.value<r;)V=Z(C,T,P,D),C=V.c,T=V.lc;if(T>=a&&s(L[w.p[i]])==(C>>T-a&(1<<a)-1)){T-=a;const L=G(w.p[i],M,C,T,P,D,O,U,c);L&&(C=L.c,T=L.lc);break}}if(i==w.lit)throw new Error("HufDecode issues")}}}const F=8-V&7;for(C>>=F,T-=F;T>0;){const L=i[C<<a-T&16383];if(!L.len)throw new Error("HufDecode issues");{T-=L.len;const i=G(L.lit,M,C,T,P,D,O,U,c);i&&(C=i.c,T=i.lc)}}}(r,S,L,P,c,T,M,V,{value:0})}function e(L){return 65535&L}function v(L){const i=e(L);return i>32767?i-65536:i}function z(L,i){const P=v(L),D=v(i),V=P+(1&D)+(D>>1);return{a:V,b:V-D}}function d(L,i){const P=e(L),D=e(i),V=P-(D>>1)&65535;return{a:D+V-32768&65535,b:V}}function h(L,i,P,D,V,M,a){const w=a<16384,O=P>V?V:P;let U,C,T=1;for(;T<=O;)T<<=1;for(T>>=1,U=T,T>>=1;T>=1;){C=0;const a=C+M*(V-U),O=M*T,c=M*U,r=D*T,F=D*U;let S,q,H,j;for(;C<=a;C+=c){let V=C;const M=C+D*(P-U);for(;V<=M;V+=F){const P=V+r,D=V+O,M=D+r;if(w){let a=z(L[V+i],L[D+i]);S=a.a,H=a.b,a=z(L[P+i],L[M+i]),q=a.a,j=a.b,a=z(S,q),L[V+i]=a.a,L[P+i]=a.b,a=z(H,j),L[D+i]=a.a,L[M+i]=a.b}else{let a=d(L[V+i],L[D+i]);S=a.a,H=a.b,a=d(L[P+i],L[M+i]),q=a.a,j=a.b,a=d(S,q),L[V+i]=a.a,L[P+i]=a.b,a=d(H,j),L[D+i]=a.a,L[M+i]=a.b}}if(P&T){const P=V+O;let D;D=w?z(L[V+i],L[P+i]):d(L[V+i],L[P+i]),S=D.a,L[P+i]=D.b,L[V+i]=S}}if(V&T){let V=C;const M=C+D*(P-U);for(;V<=M;V+=F){const P=V+r;let D;D=w?z(L[V+i],L[P+i]):d(L[V+i],L[P+i]),S=D.a,L[P+i]=D.b,L[V+i]=S}}U=T,T>>=1}return C}function R(L){return new DataView(L.array.buffer,L.offset.value,L.size)}function l(L){const i=L.viewer.buffer.slice(L.offset.value,L.offset.value+L.size),P=new Uint8Array(function(L){let i=L.byteLength;const P=new Array;let D=0;const V=new DataView(L);for(;i>0;){const L=V.getInt8(D++);if(L<0){const M=-L;i-=M+1;for(let L=0;L<M;L++)P.push(V.getUint8(D++))}else{const M=L;i-=2;const a=V.getUint8(D++);for(let L=0;L<M+1;L++)P.push(a)}}return P}(i)),D=new Uint8Array(P.length);return X(P),o(P,D),new DataView(D.buffer)}function b(L){const i=L.array.slice(L.offset.value,L.offset.value+L.size),P=fflate.unzlibSync(i),D=new Uint8Array(P.length);return X(P),o(P,D),new DataView(D.buffer)}function x(L){const i=L.array.slice(L.offset.value,L.offset.value+L.size),P=fflate.unzlibSync(i),D=L.lines*L.channels*L.width,V=1==L.type?new Uint16Array(D):new Uint32Array(D);let M=0,a=0;const w=new Array(4);for(let O=0;O<L.lines;O++)for(let i=0;i<L.channels;i++){let i=0;switch(L.type){case 1:w[0]=M,w[1]=w[0]+L.width,M=w[1]+L.width;for(let D=0;D<L.width;++D){i+=P[w[0]++]<<8|P[w[1]++],V[a]=i,a++}break;case 2:w[0]=M,w[1]=w[0]+L.width,w[2]=w[1]+L.width,M=w[2]+L.width;for(let D=0;D<L.width;++D){i+=P[w[0]++]<<24|P[w[1]++]<<16|P[w[2]++]<<8,V[a]=i,a++}}}return new DataView(V.buffer)}function t(L){const i=L.viewer,P={value:L.offset.value},D=new Uint16Array(L.width*L.scanlineBlockSize*(L.channels*L.type)),V=new Uint8Array(8192);let a=0;const w=new Array(L.channels);for(let M=0;M<L.channels;M++)w[M]={},w[M].start=a,w[M].end=w[M].start,w[M].nx=L.width,w[M].ny=L.lines,w[M].size=L.type,a+=w[M].nx*w[M].ny*w[M].size;const O=q(i,P),U=q(i,P);if(U>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(O<=U)for(let M=0;M<U-O+1;M++)V[M+O]=S(i,P);const C=new Uint16Array(M),T=function(L,i){let P=0;for(let V=0;V<M;++V)(0==V||L[V>>3]&1<<(7&V))&&(i[P++]=V);const D=P-1;for(;P<M;)i[P++]=0;return D}(V,C),c=F(i,P);A(L.array,i,P,c,D,a);for(let M=0;M<L.channels;++M){const L=w[M];for(let i=0;i<w[M].size;++i)h(D,L.start+i,L.nx,L.size,L.ny,L.nx*L.size,T)}!function(L,i,P){for(let D=0;D<P;++D)i[D]=L[i[D]]}(C,D,a);let r=0;const H=new Uint8Array(D.buffer.byteLength);for(let M=0;M<L.lines;M++)for(let i=0;i<L.channels;i++){const L=w[i],P=L.nx*L.size,V=new Uint8Array(D.buffer,2*L.end,2*P);H.set(V,r),r+=2*P,L.end+=P}return new DataView(H.buffer)}var f,N=P(1217);!function(L){L[L.Float=0]="Float",L[L.HalfFloat=1]="HalfFloat"}(f||(f={}));class Y{}Y.DefaultOutputType=f.HalfFloat,Y.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class E{constructor(){this.supportCascades=!1}loadCubeData(L,i,P,D,V){throw".exr not supported in Cube."}async loadData(L,i,P){const V=new DataView(L.buffer),M={value:0},a=function(L,i){if(20000630!=L.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const P=L.getUint8(4),V=L.getUint8(5),M={singleTile:!!(2&V),longName:!!(4&V),deepFormat:!!(8&V),multiPart:!!(16&V)};i.value=8;const a={};let w=!0;for(;w;){const P=c(L.buffer,i);if(P){const V=c(L.buffer,i),M=m(L,i,V,F(L,i));void 0===M?D.d.Warn(`Unknown header attribute type ${V}'.`):a[P]=M}else w=!1}if(0!=(-5&V))throw new Error("Unsupported file format");return{version:P,spec:M,...a}}(V,M),w=await async function(L,i,P,D){const V={size:0,viewer:i,array:new Uint8Array(i.buffer),offset:P,width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,channels:L.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(L.compression){case U.NO_COMPRESSION:V.lines=1,V.uncompress=R;break;case U.RLE_COMPRESSION:V.lines=1,V.uncompress=l;break;case U.ZIPS_COMPRESSION:V.lines=1,V.uncompress=b,await N.g.LoadScriptAsync(Y.FFLATEUrl);break;case U.ZIP_COMPRESSION:V.lines=16,V.uncompress=b,await N.g.LoadScriptAsync(Y.FFLATEUrl);break;case U.PIZ_COMPRESSION:V.lines=32,V.uncompress=t;break;case U.PXR24_COMPRESSION:V.lines=16,V.uncompress=x,await N.g.LoadScriptAsync(Y.FFLATEUrl);break;default:throw new Error(U[L.compression]+" is unsupported")}V.scanlineBlockSize=V.lines;const M={};for(const U of L.channels)switch(U.name){case"Y":case"R":case"G":case"B":case"A":M[U.name]=!0,V.type=U.pixelType}let a=!1;if(M.R&&M.G&&M.B)a=!M.A,V.outputChannels=4,V.decodeChannels={R:0,G:1,B:2,A:3};else{if(!M.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");V.outputChannels=1,V.decodeChannels={Y:0}}if(1===V.type)switch(D){case f.Float:V.getter=u,V.inputSize=2;break;case f.HalfFloat:V.getter=q,V.inputSize=2}else{if(2!==V.type)throw new Error("Unsupported pixelType "+V.type+" for "+L.compression);switch(D){case f.Float:V.getter=B,V.inputSize=4;break;case f.HalfFloat:V.getter=p,V.inputSize=4}}V.blockCount=V.height/V.scanlineBlockSize;for(let U=0;U<V.blockCount;U++)j(i,P);const w=V.width*V.height*V.outputChannels;switch(D){case f.Float:V.byteArray=new Float32Array(w),V.textureType=1,a&&V.byteArray.fill(1,0,w);break;case f.HalfFloat:V.byteArray=new Uint16Array(w),V.textureType=2,a&&V.byteArray.fill(15360,0,w);break;default:throw new Error("Unsupported type: "+D)}let O=0;for(const U of L.channels)void 0!==V.decodeChannels[U.name]&&(V.channelLineOffsets[U.name]=O*V.width),O+=2*U.pixelType;return V.bytesPerLine=V.width*O,V.outLineWidth=V.width*V.outputChannels,"INCREASING_Y"===L.lineOrder?V.scanOrder=L=>L:V.scanOrder=L=>V.height-1-L,4==V.outputChannels?(V.format=5,V.linearSpace=!0):(V.format=6,V.linearSpace=!1),V}(a,V,M,Y.DefaultOutputType);!function(L,i,P,D){const V={value:0};for(let M=0;M<L.height/L.scanlineBlockSize;M++){const a=r(P,D)-i.dataWindow.yMin;L.size=F(P,D),L.lines=a+L.scanlineBlockSize>L.height?L.height-a:L.scanlineBlockSize;const w=L.size<L.lines*L.bytesPerLine&&L.uncompress?L.uncompress(L):R(L);D.value+=L.size;for(let P=0;P<L.scanlineBlockSize;P++){const D=M*L.scanlineBlockSize,a=P+L.scanOrder(D);if(a>=L.height)continue;const O=P*L.bytesPerLine,U=(L.height-1-a)*L.outLineWidth;for(let P=0;P<L.channels;P++){const D=i.channels[P].name,M=L.channelLineOffsets[D],a=L.decodeChannels[D];if(void 0!==a){V.value=O+M;for(let i=0;i<L.width;i++){const P=U+i*L.outputChannels+a;L.byteArray&&(L.byteArray[P]=L.getter(w,V))}}}}}}(w,a,V,M);P(a.dataWindow.xMax-a.dataWindow.xMin+1,a.dataWindow.yMax-a.dataWindow.yMin+1,i.generateMipMaps,!1,(()=>{const L=i.getEngine();i.format=a.format,i.type=w.textureType,i.invertY=!1,i._gammaSpace=!a.linearSpace,w.byteArray&&L._uploadDataToTextureDirectly(i,w.byteArray,0,0,void 0,!0)}))}}}}]);