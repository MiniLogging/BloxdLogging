"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10324:(L,J,o)=>{o.r(J),o.d(J,{_ExrTextureLoader:()=>s});var g=o(1082),V=o(1011);const q=65536,I=14,b=65537,D=16384;var Z,C;!function(L){L[L.NO_COMPRESSION=0]="NO_COMPRESSION",L[L.RLE_COMPRESSION=1]="RLE_COMPRESSION",L[L.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",L[L.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",L[L.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",L[L.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(Z||(Z={})),function(L){L[L.INCREASING_Y=0]="INCREASING_Y",L[L.DECREASING_Y=1]="DECREASING_Y"}(C||(C={}));const v=function(){const L=new ArrayBuffer(4),J=new Float32Array(L),o=new Uint32Array(L),g=new Uint32Array(512),V=new Uint32Array(512);for(let D=0;D<256;++D){const L=D-127;L<-27?(g[D]=0,g[256|D]=32768,V[D]=24,V[256|D]=24):L<-14?(g[D]=1024>>-L-14,g[256|D]=1024>>-L-14|32768,V[D]=-L-1,V[256|D]=-L-1):L<=15?(g[D]=L+15<<10,g[256|D]=L+15<<10|32768,V[D]=13,V[256|D]=13):L<128?(g[D]=31744,g[256|D]=64512,V[D]=24,V[256|D]=24):(g[D]=31744,g[256|D]=64512,V[D]=13,V[256|D]=13)}const q=new Uint32Array(2048),I=new Uint32Array(64),b=new Uint32Array(64);for(let D=1;D<1024;++D){let L=D<<13,J=0;for(;0===(8388608&L);)L<<=1,J-=8388608;L&=-8388609,J+=947912704,q[D]=L|J}for(let D=1024;D<2048;++D)q[D]=939524096+(D-1024<<13);for(let D=1;D<31;++D)I[D]=D<<23;I[31]=1199570944,I[32]=2147483648;for(let D=33;D<63;++D)I[D]=2147483648+(D-32<<23);I[63]=3347054592;for(let D=1;D<64;++D)32!==D&&(b[D]=1024);return{floatView:J,uint32View:o,baseTable:g,shiftTable:V,mantissaTable:q,exponentTable:I,offsetTable:b}}();function U(L,J){const o=new Uint8Array(L);let g=0;for(;0!=o[J.value+g];)g+=1;const V=(new TextDecoder).decode(o.slice(J.value,J.value+g));return J.value=J.value+g+1,V}function k(L,J){const o=L.getInt32(J.value,!0);return J.value+=4,o}function H(L,J){const o=L.getUint32(J.value,!0);return J.value+=4,o}function e(L,J){const o=L.getUint8(J.value);return J.value+=1,o}function T(L,J){const o=L.getUint16(J.value,!0);return J.value+=2,o}function O(L,J){const o=L[J.value];return J.value+=1,o}function l(L,J){let o;return o="getBigInt64"in DataView.prototype?Number(L.getBigInt64(J.value,!0)):L.getUint32(J.value+4,!0)+Number(L.getUint32(J.value,!0)<<32),J.value+=8,o}function a(L,J){const o=L.getFloat32(J.value,!0);return J.value+=4,o}function S(L,J){return function(L){const J=(31744&L)>>10,o=1023&L;return(L>>15?-1:1)*(J?31===J?o?NaN:1/0:Math.pow(2,J-15)*(1+o/1024):o/1024*6103515625e-14)}(T(L,J))}function y(L,J){return function(L){if(Math.abs(L)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");L=(0,V.c)(L,-65504,65504),v.floatView[0]=L;const J=v.uint32View[0],o=J>>23&511;return v.baseTable[o]+((8388607&J)>>v.shiftTable[o])}(a(L,J))}function u(L,J,o,g){switch(o){case"string":case"stringvector":case"iccProfile":return function(L,J,o){const g=(new TextDecoder).decode(new Uint8Array(L).slice(J.value,J.value+o));return J.value=J.value+o,g}(L.buffer,J,g);case"chlist":return function(L,J,o){const g=J.value,V=[];for(;J.value<g+o-1;){const o=U(L.buffer,J),g=k(L,J),q=e(L,J);J.value+=3;const I=k(L,J),b=k(L,J);V.push({name:o,pixelType:g,pLinear:q,xSampling:I,ySampling:b})}return J.value+=1,V}(L,J,g);case"chromaticities":return function(L,J){return{redX:a(L,J),redY:a(L,J),greenX:a(L,J),greenY:a(L,J),blueX:a(L,J),blueY:a(L,J),whiteX:a(L,J),whiteY:a(L,J)}}(L,J);case"compression":return function(L,J){return e(L,J)}(L,J);case"box2i":return function(L,J){return{xMin:k(L,J),yMin:k(L,J),xMax:k(L,J),yMax:k(L,J)}}(L,J);case"lineOrder":return function(L,J){const o=e(L,J);return C[o]}(L,J);case"float":return a(L,J);case"v2f":return function(L,J){return[a(L,J),a(L,J)]}(L,J);case"v3f":return function(L,J){return[a(L,J),a(L,J),a(L,J)]}(L,J);case"int":return k(L,J);case"rational":return function(L,J){return[k(L,J),H(L,J)]}(L,J);case"timecode":return function(L,J){return[H(L,J),H(L,J)]}(L,J);case"preview":return J.value+=g,"skipped";default:return void(J.value+=g)}}function j(L){for(let J=1;J<L.length;J++){const o=L[J-1]+L[J]-128;L[J]=o}}function x(L,J){let o=0,g=Math.floor((L.length+1)/2),V=0;const q=L.length-1;for(;!(V>q)&&(J[V++]=L[o++],!(V>q));)J[V++]=L[g++]}function Y(L,J,o,g,V){for(;o<L;)J=J<<8|O(g,V),o+=8;return{l:J>>(o-=L)&(1<<L)-1,c:J,lc:o}}function r(L,J,o,g){return{c:L=L<<8|O(o,g),lc:J+=8}}function h(L,J,o,g,V,q,I,b,D){if(L==J){if(g<8){const L=r(o,g,V,q);o=L.c,g=L.lc}let L=o>>(g-=8);if(L=new Uint8Array([L])[0],b.value+L>D)return null;const J=I[b.value-1];for(;L-- >0;)I[b.value++]=J}else{if(!(b.value<D))return null;I[b.value++]=L}return{c:o,lc:g}}const c=new Array(59);function m(L,J,o,g,V,q){const I=J;let D=0,Z=0;for(;g<=V;g++){if(I.value-J.value>o)return;let b=Y(6,D,Z,L,I);const C=b.l;if(D=b.c,Z=b.lc,q[g]=C,63==C){if(I.value-J.value>o)throw new Error("Error in HufUnpackEncTable");b=Y(8,D,Z,L,I);let C=b.l+6;if(D=b.c,Z=b.lc,g+C>V+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)q[g++]=0;g--}else if(C>=59){let L=C-59+2;if(g+L>V+1)throw new Error("Error in HufUnpackEncTable");for(;L--;)q[g++]=0;g--}}!function(L){for(let o=0;o<=58;++o)c[o]=0;for(let o=0;o<b;++o)c[L[o]]+=1;let J=0;for(let o=58;o>0;--o){const L=J+c[o]>>1;c[o]=J,J=L}for(let o=0;o<b;++o){const J=L[o];J>0&&(L[o]=J|c[J]++<<6)}}(q)}function p(L){return 63&L}function B(L){return L>>6}function N(L,J,o,g,V,q){const Z=o.value,C=H(J,o),v=H(J,o);o.value+=4;const U=H(J,o);if(o.value+=4,C<0||C>=b||v<0||v>=b)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(b),e=new Array(D);!function(L){for(let J=0;J<D;J++)L[J]={},L[J].len=0,L[J].lit=0,L[J].p=null}(e);if(m(L,o,g-(o.value-Z),C,v,k),U>8*(g-(o.value-Z)))throw new Error("Wrong hufUncompress");!function(L,J,o,g){for(;J<=o;J++){const o=B(L[J]),V=p(L[J]);if(o>>V)throw new Error("Invalid table entry");if(V>I){const L=g[o>>V-I];if(L.len)throw new Error("Invalid table entry");if(L.lit++,L.p){const J=L.p;L.p=new Array(L.lit);for(let o=0;o<L.lit-1;++o)L.p[o]=J[o]}else L.p=new Array(1);L.p[L.lit-1]=J}else if(V){let L=0;for(let q=1<<I-V;q>0;q--){const q=g[(o<<I-V)+L];if(q.len||q.p)throw new Error("Invalid table entry");q.len=V,q.lit=J,L++}}}}(k,C,v,e),function(L,J,o,g,V,q,b,D,Z){let C=0,v=0;const U=b,k=Math.trunc(g.value+(V+7)/8);for(;g.value<k;){let V=r(C,v,o,g);for(C=V.c,v=V.lc;v>=I;){const b=J[C>>v-I&16383];if(b.len){v-=b.len;const L=h(b.lit,q,C,v,o,g,D,Z,U);L&&(C=L.c,v=L.lc)}else{if(!b.p)throw new Error("hufDecode issues");let J;for(J=0;J<b.lit;J++){const I=p(L[b.p[J]]);for(;v<I&&g.value<k;)V=r(C,v,o,g),C=V.c,v=V.lc;if(v>=I&&B(L[b.p[J]])==(C>>v-I&(1<<I)-1)){v-=I;const L=h(b.p[J],q,C,v,o,g,D,Z,U);L&&(C=L.c,v=L.lc);break}}if(J==b.lit)throw new Error("HufDecode issues")}}}const H=8-V&7;for(C>>=H,v-=H;v>0;){const L=J[C<<I-v&16383];if(!L.len)throw new Error("HufDecode issues");{v-=L.len;const J=h(L.lit,q,C,v,o,g,D,Z,U);J&&(C=J.c,v=J.lc)}}}(k,e,L,o,U,v,q,V,{value:0})}function z(L){return 65535&L}function P(L){const J=z(L);return J>32767?J-65536:J}function d(L,J){const o=P(L),g=P(J),V=o+(1&g)+(g>>1);return{a:V,b:V-g}}function w(L,J){const o=z(L),g=z(J),V=o-(g>>1)&65535;return{a:g+V-32768&65535,b:V}}function K(L,J,o,g,V,q,I){const b=I<16384,D=o>V?V:o;let Z,C,v=1;for(;v<=D;)v<<=1;for(v>>=1,Z=v,v>>=1;v>=1;){C=0;const I=C+q*(V-Z),D=q*v,U=q*Z,k=g*v,H=g*Z;let e,T,O,l;for(;C<=I;C+=U){let V=C;const q=C+g*(o-Z);for(;V<=q;V+=H){const o=V+k,g=V+D,q=g+k;if(b){let I=d(L[V+J],L[g+J]);e=I.a,O=I.b,I=d(L[o+J],L[q+J]),T=I.a,l=I.b,I=d(e,T),L[V+J]=I.a,L[o+J]=I.b,I=d(O,l),L[g+J]=I.a,L[q+J]=I.b}else{let I=w(L[V+J],L[g+J]);e=I.a,O=I.b,I=w(L[o+J],L[q+J]),T=I.a,l=I.b,I=w(e,T),L[V+J]=I.a,L[o+J]=I.b,I=w(O,l),L[g+J]=I.a,L[q+J]=I.b}}if(o&v){const o=V+D;let g;g=b?d(L[V+J],L[o+J]):w(L[V+J],L[o+J]),e=g.a,L[o+J]=g.b,L[V+J]=e}}if(V&v){let V=C;const q=C+g*(o-Z);for(;V<=q;V+=H){const o=V+k;let g;g=b?d(L[V+J],L[o+J]):w(L[V+J],L[o+J]),e=g.a,L[o+J]=g.b,L[V+J]=e}}Z=v,v>>=1}return C}function X(L){return new DataView(L.array.buffer,L.offset.value,L.size)}function W(L){const J=L.viewer.buffer.slice(L.offset.value,L.offset.value+L.size),o=new Uint8Array(function(L){let J=L.byteLength;const o=new Array;let g=0;const V=new DataView(L);for(;J>0;){const L=V.getInt8(g++);if(L<0){const q=-L;J-=q+1;for(let L=0;L<q;L++)o.push(V.getUint8(g++))}else{const q=L;J-=2;const I=V.getUint8(g++);for(let L=0;L<q+1;L++)o.push(I)}}return o}(J)),g=new Uint8Array(o.length);return j(o),x(o,g),new DataView(g.buffer)}function Q(L){const J=L.array.slice(L.offset.value,L.offset.value+L.size),o=fflate.unzlibSync(J),g=new Uint8Array(o.length);return j(o),x(o,g),new DataView(g.buffer)}function E(L){const J=L.array.slice(L.offset.value,L.offset.value+L.size),o=fflate.unzlibSync(J),g=L.lines*L.channels*L.width,V=1==L.type?new Uint16Array(g):new Uint32Array(g);let q=0,I=0;const b=new Array(4);for(let D=0;D<L.lines;D++)for(let J=0;J<L.channels;J++){let J=0;switch(L.type){case 1:b[0]=q,b[1]=b[0]+L.width,q=b[1]+L.width;for(let g=0;g<L.width;++g){J+=o[b[0]++]<<8|o[b[1]++],V[I]=J,I++}break;case 2:b[0]=q,b[1]=b[0]+L.width,b[2]=b[1]+L.width,q=b[2]+L.width;for(let g=0;g<L.width;++g){J+=o[b[0]++]<<24|o[b[1]++]<<16|o[b[2]++]<<8,V[I]=J,I++}}}return new DataView(V.buffer)}function F(L){const J=L.viewer,o={value:L.offset.value},g=new Uint16Array(L.width*L.scanlineBlockSize*(L.channels*L.type)),V=new Uint8Array(8192);let I=0;const b=new Array(L.channels);for(let q=0;q<L.channels;q++)b[q]={},b[q].start=I,b[q].end=b[q].start,b[q].nx=L.width,b[q].ny=L.lines,b[q].size=L.type,I+=b[q].nx*b[q].ny*b[q].size;const D=T(J,o),Z=T(J,o);if(Z>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(D<=Z)for(let q=0;q<Z-D+1;q++)V[q+D]=e(J,o);const C=new Uint16Array(q),v=function(L,J){let o=0;for(let V=0;V<q;++V)(0==V||L[V>>3]&1<<(7&V))&&(J[o++]=V);const g=o-1;for(;o<q;)J[o++]=0;return g}(V,C),U=H(J,o);N(L.array,J,o,U,g,I);for(let q=0;q<L.channels;++q){const L=b[q];for(let J=0;J<b[q].size;++J)K(g,L.start+J,L.nx,L.size,L.ny,L.nx*L.size,v)}!function(L,J,o){for(let g=0;g<o;++g)J[g]=L[J[g]]}(C,g,I);let k=0;const O=new Uint8Array(g.buffer.byteLength);for(let q=0;q<L.lines;q++)for(let J=0;J<L.channels;J++){const L=b[J],o=L.nx*L.size,V=new Uint8Array(g.buffer,2*L.end,2*o);O.set(V,k),k+=2*o,L.end+=o}return new DataView(O.buffer)}var n,f=o(1193);!function(L){L[L.Float=0]="Float",L[L.HalfFloat=1]="HalfFloat"}(n||(n={}));class R{}R.DefaultOutputType=n.HalfFloat,R.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class s{constructor(){this.supportCascades=!1}loadCubeData(L,J,o,g,V){throw".exr not supported in Cube."}async loadData(L,J,o){const V=new DataView(L.buffer),q={value:0},I=function(L,J){if(20000630!=L.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const o=L.getUint8(4),V=L.getUint8(5),q={singleTile:!!(2&V),longName:!!(4&V),deepFormat:!!(8&V),multiPart:!!(16&V)};J.value=8;const I={};let b=!0;for(;b;){const o=U(L.buffer,J);if(o){const V=U(L.buffer,J),q=u(L,J,V,H(L,J));void 0===q?g.e.Warn(`Unknown header attribute type ${V}'.`):I[o]=q}else b=!1}if(0!=(-5&V))throw new Error("Unsupported file format");return{version:o,spec:q,...I}}(V,q),b=await async function(L,J,o,g){const V={size:0,viewer:J,array:new Uint8Array(J.buffer),offset:o,width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,channels:L.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(L.compression){case Z.NO_COMPRESSION:V.lines=1,V.uncompress=X;break;case Z.RLE_COMPRESSION:V.lines=1,V.uncompress=W;break;case Z.ZIPS_COMPRESSION:V.lines=1,V.uncompress=Q,await f.c.LoadScriptAsync(R.FFLATEUrl);break;case Z.ZIP_COMPRESSION:V.lines=16,V.uncompress=Q,await f.c.LoadScriptAsync(R.FFLATEUrl);break;case Z.PIZ_COMPRESSION:V.lines=32,V.uncompress=F;break;case Z.PXR24_COMPRESSION:V.lines=16,V.uncompress=E,await f.c.LoadScriptAsync(R.FFLATEUrl);break;default:throw new Error(Z[L.compression]+" is unsupported")}V.scanlineBlockSize=V.lines;const q={};for(const Z of L.channels)switch(Z.name){case"Y":case"R":case"G":case"B":case"A":q[Z.name]=!0,V.type=Z.pixelType}let I=!1;if(q.R&&q.G&&q.B)I=!q.A,V.outputChannels=4,V.decodeChannels={R:0,G:1,B:2,A:3};else{if(!q.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");V.outputChannels=1,V.decodeChannels={Y:0}}if(1===V.type)switch(g){case n.Float:V.getter=S,V.inputSize=2;break;case n.HalfFloat:V.getter=T,V.inputSize=2}else{if(2!==V.type)throw new Error("Unsupported pixelType "+V.type+" for "+L.compression);switch(g){case n.Float:V.getter=a,V.inputSize=4;break;case n.HalfFloat:V.getter=y,V.inputSize=4}}V.blockCount=V.height/V.scanlineBlockSize;for(let Z=0;Z<V.blockCount;Z++)l(J,o);const b=V.width*V.height*V.outputChannels;switch(g){case n.Float:V.byteArray=new Float32Array(b),V.textureType=1,I&&V.byteArray.fill(1,0,b);break;case n.HalfFloat:V.byteArray=new Uint16Array(b),V.textureType=2,I&&V.byteArray.fill(15360,0,b);break;default:throw new Error("Unsupported type: "+g)}let D=0;for(const Z of L.channels)void 0!==V.decodeChannels[Z.name]&&(V.channelLineOffsets[Z.name]=D*V.width),D+=2*Z.pixelType;return V.bytesPerLine=V.width*D,V.outLineWidth=V.width*V.outputChannels,"INCREASING_Y"===L.lineOrder?V.scanOrder=L=>L:V.scanOrder=L=>V.height-1-L,4==V.outputChannels?(V.format=5,V.linearSpace=!0):(V.format=6,V.linearSpace=!1),V}(I,V,q,R.DefaultOutputType);!function(L,J,o,g){const V={value:0};for(let q=0;q<L.height/L.scanlineBlockSize;q++){const I=k(o,g)-J.dataWindow.yMin;L.size=H(o,g),L.lines=I+L.scanlineBlockSize>L.height?L.height-I:L.scanlineBlockSize;const b=L.size<L.lines*L.bytesPerLine&&L.uncompress?L.uncompress(L):X(L);g.value+=L.size;for(let o=0;o<L.scanlineBlockSize;o++){const g=q*L.scanlineBlockSize,I=o+L.scanOrder(g);if(I>=L.height)continue;const D=o*L.bytesPerLine,Z=(L.height-1-I)*L.outLineWidth;for(let o=0;o<L.channels;o++){const g=J.channels[o].name,q=L.channelLineOffsets[g],I=L.decodeChannels[g];if(void 0!==I){V.value=D+q;for(let J=0;J<L.width;J++){const o=Z+J*L.outputChannels+I;L.byteArray&&(L.byteArray[o]=L.getter(b,V))}}}}}}(b,I,V,q);o(I.dataWindow.xMax-I.dataWindow.xMin+1,I.dataWindow.yMax-I.dataWindow.yMin+1,J.generateMipMaps,!1,(()=>{const L=J.getEngine();J.format=I.format,J.type=b.textureType,J.invertY=!1,J._gammaSpace=!I.linearSpace,b.byteArray&&L._uploadDataToTextureDirectly(J,b.byteArray,0,0,void 0,!0)}))}}}}]);