"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10418:(d,m,g)=>{g.r(m),g.d(m,{_ExrTextureLoader:()=>W});var V=g(1102),u=g(1045);const D=65536,j=14,z=65537,s=16384;var U,X;!function(d){d[d.NO_COMPRESSION=0]="NO_COMPRESSION",d[d.RLE_COMPRESSION=1]="RLE_COMPRESSION",d[d.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",d[d.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",d[d.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",d[d.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(d){d[d.INCREASING_Y=0]="INCREASING_Y",d[d.DECREASING_Y=1]="DECREASING_Y"}(X||(X={}));const Y=function(){const d=new ArrayBuffer(4),m=new Float32Array(d),g=new Uint32Array(d),V=new Uint32Array(512),u=new Uint32Array(512);for(let s=0;s<256;++s){const d=s-127;d<-27?(V[s]=0,V[256|s]=32768,u[s]=24,u[256|s]=24):d<-14?(V[s]=1024>>-d-14,V[256|s]=1024>>-d-14|32768,u[s]=-d-1,u[256|s]=-d-1):d<=15?(V[s]=d+15<<10,V[256|s]=d+15<<10|32768,u[s]=13,u[256|s]=13):d<128?(V[s]=31744,V[256|s]=64512,u[s]=24,u[256|s]=24):(V[s]=31744,V[256|s]=64512,u[s]=13,u[256|s]=13)}const D=new Uint32Array(2048),j=new Uint32Array(64),z=new Uint32Array(64);for(let s=1;s<1024;++s){let d=s<<13,m=0;for(;0===(8388608&d);)d<<=1,m-=8388608;d&=-8388609,m+=947912704,D[s]=d|m}for(let s=1024;s<2048;++s)D[s]=939524096+(s-1024<<13);for(let s=1;s<31;++s)j[s]=s<<23;j[31]=1199570944,j[32]=2147483648;for(let s=33;s<63;++s)j[s]=2147483648+(s-32<<23);j[63]=3347054592;for(let s=1;s<64;++s)32!==s&&(z[s]=1024);return{floatView:m,uint32View:g,baseTable:V,shiftTable:u,mantissaTable:D,exponentTable:j,offsetTable:z}}();function Q(d,m){const g=new Uint8Array(d);let V=0;for(;0!=g[m.value+V];)V+=1;const u=(new TextDecoder).decode(g.slice(m.value,m.value+V));return m.value=m.value+V+1,u}function B(d,m){const g=d.getInt32(m.value,!0);return m.value+=4,g}function i(d,m){const g=d.getUint32(m.value,!0);return m.value+=4,g}function C(d,m){const g=d.getUint8(m.value);return m.value+=1,g}function L(d,m){const g=d.getUint16(m.value,!0);return m.value+=2,g}function O(d,m){const g=d[m.value];return m.value+=1,g}function R(d,m){let g;return g="getBigInt64"in DataView.prototype?Number(d.getBigInt64(m.value,!0)):d.getUint32(m.value+4,!0)+Number(d.getUint32(m.value,!0)<<32),m.value+=8,g}function J(d,m){const g=d.getFloat32(m.value,!0);return m.value+=4,g}function c(d,m){return function(d){const m=(31744&d)>>10,g=1023&d;return(d>>15?-1:1)*(m?31===m?g?NaN:1/0:Math.pow(2,m-15)*(1+g/1024):g/1024*6103515625e-14)}(L(d,m))}function A(d,m){return function(d){if(Math.abs(d)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");d=(0,u.b)(d,-65504,65504),Y.floatView[0]=d;const m=Y.uint32View[0],g=m>>23&511;return Y.baseTable[g]+((8388607&m)>>Y.shiftTable[g])}(J(d,m))}function H(d,m,g,V){switch(g){case"string":case"stringvector":case"iccProfile":return function(d,m,g){const V=(new TextDecoder).decode(new Uint8Array(d).slice(m.value,m.value+g));return m.value=m.value+g,V}(d.buffer,m,V);case"chlist":return function(d,m,g){const V=m.value,u=[];for(;m.value<V+g-1;){const g=Q(d.buffer,m),V=B(d,m),D=C(d,m);m.value+=3;const j=B(d,m),z=B(d,m);u.push({name:g,pixelType:V,pLinear:D,xSampling:j,ySampling:z})}return m.value+=1,u}(d,m,V);case"chromaticities":return function(d,m){return{redX:J(d,m),redY:J(d,m),greenX:J(d,m),greenY:J(d,m),blueX:J(d,m),blueY:J(d,m),whiteX:J(d,m),whiteY:J(d,m)}}(d,m);case"compression":return function(d,m){return C(d,m)}(d,m);case"box2i":return function(d,m){return{xMin:B(d,m),yMin:B(d,m),xMax:B(d,m),yMax:B(d,m)}}(d,m);case"lineOrder":return function(d,m){const g=C(d,m);return X[g]}(d,m);case"float":return J(d,m);case"v2f":return function(d,m){return[J(d,m),J(d,m)]}(d,m);case"v3f":return function(d,m){return[J(d,m),J(d,m),J(d,m)]}(d,m);case"int":return B(d,m);case"rational":return function(d,m){return[B(d,m),i(d,m)]}(d,m);case"timecode":return function(d,m){return[i(d,m),i(d,m)]}(d,m);case"preview":return m.value+=V,"skipped";default:return void(m.value+=V)}}function T(d){for(let m=1;m<d.length;m++){const g=d[m-1]+d[m]-128;d[m]=g}}function N(d,m){let g=0,V=Math.floor((d.length+1)/2),u=0;const D=d.length-1;for(;!(u>D)&&(m[u++]=d[g++],!(u>D));)m[u++]=d[V++]}function F(d,m,g,V,u){for(;g<d;)m=m<<8|O(V,u),g+=8;return{l:m>>(g-=d)&(1<<d)-1,c:m,lc:g}}function p(d,m,g,V){return{c:d=d<<8|O(g,V),lc:m+=8}}function l(d,m,g,V,u,D,j,z,s){if(d==m){if(V<8){const d=p(g,V,u,D);g=d.c,V=d.lc}let d=g>>(V-=8);if(d=new Uint8Array([d])[0],z.value+d>s)return null;const m=j[z.value-1];for(;d-- >0;)j[z.value++]=m}else{if(!(z.value<s))return null;j[z.value++]=d}return{c:g,lc:V}}const y=new Array(59);function K(d,m,g,V,u,D){const j=m;let s=0,U=0;for(;V<=u;V++){if(j.value-m.value>g)return;let z=F(6,s,U,d,j);const X=z.l;if(s=z.c,U=z.lc,D[V]=X,63==X){if(j.value-m.value>g)throw new Error("Error in HufUnpackEncTable");z=F(8,s,U,d,j);let X=z.l+6;if(s=z.c,U=z.lc,V+X>u+1)throw new Error("Error in HufUnpackEncTable");for(;X--;)D[V++]=0;V--}else if(X>=59){let d=X-59+2;if(V+d>u+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)D[V++]=0;V--}}!function(d){for(let g=0;g<=58;++g)y[g]=0;for(let g=0;g<z;++g)y[d[g]]+=1;let m=0;for(let g=58;g>0;--g){const d=m+y[g]>>1;y[g]=m,m=d}for(let g=0;g<z;++g){const m=d[g];m>0&&(d[g]=m|y[m]++<<6)}}(D)}function n(d){return 63&d}function P(d){return d>>6}function w(d,m,g,V,u,D){const U=g.value,X=i(m,g),Y=i(m,g);g.value+=4;const Q=i(m,g);if(g.value+=4,X<0||X>=z||Y<0||Y>=z)throw new Error("Wrong HUF_ENCSIZE");const B=new Array(z),C=new Array(s);!function(d){for(let m=0;m<s;m++)d[m]={},d[m].len=0,d[m].lit=0,d[m].p=null}(C);if(K(d,g,V-(g.value-U),X,Y,B),Q>8*(V-(g.value-U)))throw new Error("Wrong hufUncompress");!function(d,m,g,V){for(;m<=g;m++){const g=P(d[m]),u=n(d[m]);if(g>>u)throw new Error("Invalid table entry");if(u>j){const d=V[g>>u-j];if(d.len)throw new Error("Invalid table entry");if(d.lit++,d.p){const m=d.p;d.p=new Array(d.lit);for(let g=0;g<d.lit-1;++g)d.p[g]=m[g]}else d.p=new Array(1);d.p[d.lit-1]=m}else if(u){let d=0;for(let D=1<<j-u;D>0;D--){const D=V[(g<<j-u)+d];if(D.len||D.p)throw new Error("Invalid table entry");D.len=u,D.lit=m,d++}}}}(B,X,Y,C),function(d,m,g,V,u,D,z,s,U){let X=0,Y=0;const Q=z,B=Math.trunc(V.value+(u+7)/8);for(;V.value<B;){let u=p(X,Y,g,V);for(X=u.c,Y=u.lc;Y>=j;){const z=m[X>>Y-j&16383];if(z.len){Y-=z.len;const d=l(z.lit,D,X,Y,g,V,s,U,Q);d&&(X=d.c,Y=d.lc)}else{if(!z.p)throw new Error("hufDecode issues");let m;for(m=0;m<z.lit;m++){const j=n(d[z.p[m]]);for(;Y<j&&V.value<B;)u=p(X,Y,g,V),X=u.c,Y=u.lc;if(Y>=j&&P(d[z.p[m]])==(X>>Y-j&(1<<j)-1)){Y-=j;const d=l(z.p[m],D,X,Y,g,V,s,U,Q);d&&(X=d.c,Y=d.lc);break}}if(m==z.lit)throw new Error("HufDecode issues")}}}const i=8-u&7;for(X>>=i,Y-=i;Y>0;){const d=m[X<<j-Y&16383];if(!d.len)throw new Error("HufDecode issues");{Y-=d.len;const m=l(d.lit,D,X,Y,g,V,s,U,Q);m&&(X=m.c,Y=m.lc)}}}(B,C,d,g,Q,Y,D,u,{value:0})}function E(d){return 65535&d}function t(d){const m=E(d);return m>32767?m-65536:m}function x(d,m){const g=t(d),V=t(m),u=g+(1&V)+(V>>1);return{a:u,b:u-V}}function S(d,m){const g=E(d),V=E(m),u=g-(V>>1)&65535;return{a:V+u-32768&65535,b:u}}function o(d,m,g,V,u,D,j){const z=j<16384,s=g>u?u:g;let U,X,Y=1;for(;Y<=s;)Y<<=1;for(Y>>=1,U=Y,Y>>=1;Y>=1;){X=0;const j=X+D*(u-U),s=D*Y,Q=D*U,B=V*Y,i=V*U;let C,L,O,R;for(;X<=j;X+=Q){let u=X;const D=X+V*(g-U);for(;u<=D;u+=i){const g=u+B,V=u+s,D=V+B;if(z){let j=x(d[u+m],d[V+m]);C=j.a,O=j.b,j=x(d[g+m],d[D+m]),L=j.a,R=j.b,j=x(C,L),d[u+m]=j.a,d[g+m]=j.b,j=x(O,R),d[V+m]=j.a,d[D+m]=j.b}else{let j=S(d[u+m],d[V+m]);C=j.a,O=j.b,j=S(d[g+m],d[D+m]),L=j.a,R=j.b,j=S(C,L),d[u+m]=j.a,d[g+m]=j.b,j=S(O,R),d[V+m]=j.a,d[D+m]=j.b}}if(g&Y){const g=u+s;let V;V=z?x(d[u+m],d[g+m]):S(d[u+m],d[g+m]),C=V.a,d[g+m]=V.b,d[u+m]=C}}if(u&Y){let u=X;const D=X+V*(g-U);for(;u<=D;u+=i){const g=u+B;let V;V=z?x(d[u+m],d[g+m]):S(d[u+m],d[g+m]),C=V.a,d[g+m]=V.b,d[u+m]=C}}U=Y,Y>>=1}return X}function b(d){return new DataView(d.array.buffer,d.offset.value,d.size)}function I(d){const m=d.viewer.buffer.slice(d.offset.value,d.offset.value+d.size),g=new Uint8Array(function(d){let m=d.byteLength;const g=new Array;let V=0;const u=new DataView(d);for(;m>0;){const d=u.getInt8(V++);if(d<0){const D=-d;m-=D+1;for(let d=0;d<D;d++)g.push(u.getUint8(V++))}else{const D=d;m-=2;const j=u.getUint8(V++);for(let d=0;d<D+1;d++)g.push(j)}}return g}(m)),V=new Uint8Array(g.length);return T(g),N(g,V),new DataView(V.buffer)}function k(d){const m=d.array.slice(d.offset.value,d.offset.value+d.size),g=fflate.unzlibSync(m),V=new Uint8Array(g.length);return T(g),N(g,V),new DataView(V.buffer)}function r(d){const m=d.array.slice(d.offset.value,d.offset.value+d.size),g=fflate.unzlibSync(m),V=d.lines*d.channels*d.width,u=1==d.type?new Uint16Array(V):new Uint32Array(V);let D=0,j=0;const z=new Array(4);for(let s=0;s<d.lines;s++)for(let m=0;m<d.channels;m++){let m=0;switch(d.type){case 1:z[0]=D,z[1]=z[0]+d.width,D=z[1]+d.width;for(let V=0;V<d.width;++V){m+=g[z[0]++]<<8|g[z[1]++],u[j]=m,j++}break;case 2:z[0]=D,z[1]=z[0]+d.width,z[2]=z[1]+d.width,D=z[2]+d.width;for(let V=0;V<d.width;++V){m+=g[z[0]++]<<24|g[z[1]++]<<16|g[z[2]++]<<8,u[j]=m,j++}}}return new DataView(u.buffer)}function M(d){const m=d.viewer,g={value:d.offset.value},V=new Uint16Array(d.width*d.scanlineBlockSize*(d.channels*d.type)),u=new Uint8Array(8192);let j=0;const z=new Array(d.channels);for(let D=0;D<d.channels;D++)z[D]={},z[D].start=j,z[D].end=z[D].start,z[D].nx=d.width,z[D].ny=d.lines,z[D].size=d.type,j+=z[D].nx*z[D].ny*z[D].size;const s=L(m,g),U=L(m,g);if(U>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(s<=U)for(let D=0;D<U-s+1;D++)u[D+s]=C(m,g);const X=new Uint16Array(D),Y=function(d,m){let g=0;for(let u=0;u<D;++u)(0==u||d[u>>3]&1<<(7&u))&&(m[g++]=u);const V=g-1;for(;g<D;)m[g++]=0;return V}(u,X),Q=i(m,g);w(d.array,m,g,Q,V,j);for(let D=0;D<d.channels;++D){const d=z[D];for(let m=0;m<z[D].size;++m)o(V,d.start+m,d.nx,d.size,d.ny,d.nx*d.size,Y)}!function(d,m,g){for(let V=0;V<g;++V)m[V]=d[m[V]]}(X,V,j);let B=0;const O=new Uint8Array(V.buffer.byteLength);for(let D=0;D<d.lines;D++)for(let m=0;m<d.channels;m++){const d=z[m],g=d.nx*d.size,u=new Uint8Array(V.buffer,2*d.end,2*g);O.set(u,B),B+=2*g,d.end+=g}return new DataView(O.buffer)}var h,Z=g(1190);!function(d){d[d.Float=0]="Float",d[d.HalfFloat=1]="HalfFloat"}(h||(h={}));class a{}a.DefaultOutputType=h.HalfFloat,a.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class W{constructor(){this.supportCascades=!1}loadCubeData(d,m,g,V,u){throw".exr not supported in Cube."}async loadData(d,m,g){const u=new DataView(d.buffer),D={value:0},j=function(d,m){if(20000630!=d.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const g=d.getUint8(4),u=d.getUint8(5),D={singleTile:!!(2&u),longName:!!(4&u),deepFormat:!!(8&u),multiPart:!!(16&u)};m.value=8;const j={};let z=!0;for(;z;){const g=Q(d.buffer,m);if(g){const u=Q(d.buffer,m),D=H(d,m,u,i(d,m));void 0===D?V.c.Warn(`Unknown header attribute type ${u}'.`):j[g]=D}else z=!1}if(0!=(-5&u))throw new Error("Unsupported file format");return{version:g,spec:D,...j}}(u,D),z=await async function(d,m,g,V){const u={size:0,viewer:m,array:new Uint8Array(m.buffer),offset:g,width:d.dataWindow.xMax-d.dataWindow.xMin+1,height:d.dataWindow.yMax-d.dataWindow.yMin+1,channels:d.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(d.compression){case U.NO_COMPRESSION:u.lines=1,u.uncompress=b;break;case U.RLE_COMPRESSION:u.lines=1,u.uncompress=I;break;case U.ZIPS_COMPRESSION:u.lines=1,u.uncompress=k,await Z.f.LoadScriptAsync(a.FFLATEUrl);break;case U.ZIP_COMPRESSION:u.lines=16,u.uncompress=k,await Z.f.LoadScriptAsync(a.FFLATEUrl);break;case U.PIZ_COMPRESSION:u.lines=32,u.uncompress=M;break;case U.PXR24_COMPRESSION:u.lines=16,u.uncompress=r,await Z.f.LoadScriptAsync(a.FFLATEUrl);break;default:throw new Error(U[d.compression]+" is unsupported")}u.scanlineBlockSize=u.lines;const D={};for(const U of d.channels)switch(U.name){case"Y":case"R":case"G":case"B":case"A":D[U.name]=!0,u.type=U.pixelType}let j=!1;if(D.R&&D.G&&D.B)j=!D.A,u.outputChannels=4,u.decodeChannels={R:0,G:1,B:2,A:3};else{if(!D.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");u.outputChannels=1,u.decodeChannels={Y:0}}if(1===u.type)switch(V){case h.Float:u.getter=c,u.inputSize=2;break;case h.HalfFloat:u.getter=L,u.inputSize=2}else{if(2!==u.type)throw new Error("Unsupported pixelType "+u.type+" for "+d.compression);switch(V){case h.Float:u.getter=J,u.inputSize=4;break;case h.HalfFloat:u.getter=A,u.inputSize=4}}u.blockCount=u.height/u.scanlineBlockSize;for(let U=0;U<u.blockCount;U++)R(m,g);const z=u.width*u.height*u.outputChannels;switch(V){case h.Float:u.byteArray=new Float32Array(z),u.textureType=1,j&&u.byteArray.fill(1,0,z);break;case h.HalfFloat:u.byteArray=new Uint16Array(z),u.textureType=2,j&&u.byteArray.fill(15360,0,z);break;default:throw new Error("Unsupported type: "+V)}let s=0;for(const U of d.channels)void 0!==u.decodeChannels[U.name]&&(u.channelLineOffsets[U.name]=s*u.width),s+=2*U.pixelType;return u.bytesPerLine=u.width*s,u.outLineWidth=u.width*u.outputChannels,"INCREASING_Y"===d.lineOrder?u.scanOrder=d=>d:u.scanOrder=d=>u.height-1-d,4==u.outputChannels?(u.format=5,u.linearSpace=!0):(u.format=6,u.linearSpace=!1),u}(j,u,D,a.DefaultOutputType);!function(d,m,g,V){const u={value:0};for(let D=0;D<d.height/d.scanlineBlockSize;D++){const j=B(g,V)-m.dataWindow.yMin;d.size=i(g,V),d.lines=j+d.scanlineBlockSize>d.height?d.height-j:d.scanlineBlockSize;const z=d.size<d.lines*d.bytesPerLine&&d.uncompress?d.uncompress(d):b(d);V.value+=d.size;for(let g=0;g<d.scanlineBlockSize;g++){const V=D*d.scanlineBlockSize,j=g+d.scanOrder(V);if(j>=d.height)continue;const s=g*d.bytesPerLine,U=(d.height-1-j)*d.outLineWidth;for(let g=0;g<d.channels;g++){const V=m.channels[g].name,D=d.channelLineOffsets[V],j=d.decodeChannels[V];if(void 0!==j){u.value=s+D;for(let m=0;m<d.width;m++){const g=U+m*d.outputChannels+j;d.byteArray&&(d.byteArray[g]=d.getter(z,u))}}}}}}(z,j,u,D);g(j.dataWindow.xMax-j.dataWindow.xMin+1,j.dataWindow.yMax-j.dataWindow.yMin+1,m.generateMipMaps,!1,(()=>{const d=m.getEngine();m.format=j.format,m.type=z.textureType,m.invertY=!1,m._gammaSpace=!j.linearSpace,z.byteArray&&d._uploadDataToTextureDirectly(m,z.byteArray,0,0,void 0,!0)}))}}}}]);