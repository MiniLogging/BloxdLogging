"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10651:(p,O,E)=>{E.r(O),E.d(O,{_ExrTextureLoader:()=>U});var e=E(1065),x=E(1027);const F=65536,q=14,a=65537,Y=16384;var B,s;!function(p){p[p.NO_COMPRESSION=0]="NO_COMPRESSION",p[p.RLE_COMPRESSION=1]="RLE_COMPRESSION",p[p.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",p[p.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",p[p.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",p[p.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(B||(B={})),function(p){p[p.INCREASING_Y=0]="INCREASING_Y",p[p.DECREASING_Y=1]="DECREASING_Y"}(s||(s={}));const D=function(){const p=new ArrayBuffer(4),O=new Float32Array(p),E=new Uint32Array(p),e=new Uint32Array(512),x=new Uint32Array(512);for(let Y=0;Y<256;++Y){const p=Y-127;p<-27?(e[Y]=0,e[256|Y]=32768,x[Y]=24,x[256|Y]=24):p<-14?(e[Y]=1024>>-p-14,e[256|Y]=1024>>-p-14|32768,x[Y]=-p-1,x[256|Y]=-p-1):p<=15?(e[Y]=p+15<<10,e[256|Y]=p+15<<10|32768,x[Y]=13,x[256|Y]=13):p<128?(e[Y]=31744,e[256|Y]=64512,x[Y]=24,x[256|Y]=24):(e[Y]=31744,e[256|Y]=64512,x[Y]=13,x[256|Y]=13)}const F=new Uint32Array(2048),q=new Uint32Array(64),a=new Uint32Array(64);for(let Y=1;Y<1024;++Y){let p=Y<<13,O=0;for(;0===(8388608&p);)p<<=1,O-=8388608;p&=-8388609,O+=947912704,F[Y]=p|O}for(let Y=1024;Y<2048;++Y)F[Y]=939524096+(Y-1024<<13);for(let Y=1;Y<31;++Y)q[Y]=Y<<23;q[31]=1199570944,q[32]=2147483648;for(let Y=33;Y<63;++Y)q[Y]=2147483648+(Y-32<<23);q[63]=3347054592;for(let Y=1;Y<64;++Y)32!==Y&&(a[Y]=1024);return{floatView:O,uint32View:E,baseTable:e,shiftTable:x,mantissaTable:F,exponentTable:q,offsetTable:a}}();function Z(p,O){const E=new Uint8Array(p);let e=0;for(;0!=E[O.value+e];)e+=1;const x=(new TextDecoder).decode(E.slice(O.value,O.value+e));return O.value=O.value+e+1,x}function m(p,O){const E=p.getInt32(O.value,!0);return O.value+=4,E}function h(p,O){const E=p.getUint32(O.value,!0);return O.value+=4,E}function T(p,O){const E=p.getUint8(O.value);return O.value+=1,E}function A(p,O){const E=p.getUint16(O.value,!0);return O.value+=2,E}function H(p,O){const E=p[O.value];return O.value+=1,E}function t(p,O){let E;return E="getBigInt64"in DataView.prototype?Number(p.getBigInt64(O.value,!0)):p.getUint32(O.value+4,!0)+Number(p.getUint32(O.value,!0)<<32),O.value+=8,E}function r(p,O){const E=p.getFloat32(O.value,!0);return O.value+=4,E}function Q(p,O){return function(p){const O=(31744&p)>>10,E=1023&p;return(p>>15?-1:1)*(O?31===O?E?NaN:1/0:Math.pow(2,O-15)*(1+E/1024):E/1024*6103515625e-14)}(A(p,O))}function W(p,O){return function(p){if(Math.abs(p)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");p=(0,x.b)(p,-65504,65504),D.floatView[0]=p;const O=D.uint32View[0],E=O>>23&511;return D.baseTable[E]+((8388607&O)>>D.shiftTable[E])}(r(p,O))}function V(p,O,E,e){switch(E){case"string":case"stringvector":case"iccProfile":return function(p,O,E){const e=(new TextDecoder).decode(new Uint8Array(p).slice(O.value,O.value+E));return O.value=O.value+E,e}(p.buffer,O,e);case"chlist":return function(p,O,E){const e=O.value,x=[];for(;O.value<e+E-1;){const E=Z(p.buffer,O),e=m(p,O),F=T(p,O);O.value+=3;const q=m(p,O),a=m(p,O);x.push({name:E,pixelType:e,pLinear:F,xSampling:q,ySampling:a})}return O.value+=1,x}(p,O,e);case"chromaticities":return function(p,O){return{redX:r(p,O),redY:r(p,O),greenX:r(p,O),greenY:r(p,O),blueX:r(p,O),blueY:r(p,O),whiteX:r(p,O),whiteY:r(p,O)}}(p,O);case"compression":return function(p,O){return T(p,O)}(p,O);case"box2i":return function(p,O){return{xMin:m(p,O),yMin:m(p,O),xMax:m(p,O),yMax:m(p,O)}}(p,O);case"lineOrder":return function(p,O){const E=T(p,O);return s[E]}(p,O);case"float":return r(p,O);case"v2f":return function(p,O){return[r(p,O),r(p,O)]}(p,O);case"v3f":return function(p,O){return[r(p,O),r(p,O),r(p,O)]}(p,O);case"int":return m(p,O);case"rational":return function(p,O){return[m(p,O),h(p,O)]}(p,O);case"timecode":return function(p,O){return[h(p,O),h(p,O)]}(p,O);case"preview":return O.value+=e,"skipped";default:return void(O.value+=e)}}function g(p){for(let O=1;O<p.length;O++){const E=p[O-1]+p[O]-128;p[O]=E}}function b(p,O){let E=0,e=Math.floor((p.length+1)/2),x=0;const F=p.length-1;for(;!(x>F)&&(O[x++]=p[E++],!(x>F));)O[x++]=p[e++]}function S(p,O,E,e,x){for(;E<p;)O=O<<8|H(e,x),E+=8;return{l:O>>(E-=p)&(1<<p)-1,c:O,lc:E}}function L(p,O,E,e){return{c:p=p<<8|H(E,e),lc:O+=8}}function P(p,O,E,e,x,F,q,a,Y){if(p==O){if(e<8){const p=L(E,e,x,F);E=p.c,e=p.lc}let p=E>>(e-=8);if(p=new Uint8Array([p])[0],a.value+p>Y)return null;const O=q[a.value-1];for(;p-- >0;)q[a.value++]=O}else{if(!(a.value<Y))return null;q[a.value++]=p}return{c:E,lc:e}}const d=new Array(59);function M(p,O,E,e,x,F){const q=O;let Y=0,B=0;for(;e<=x;e++){if(q.value-O.value>E)return;let a=S(6,Y,B,p,q);const s=a.l;if(Y=a.c,B=a.lc,F[e]=s,63==s){if(q.value-O.value>E)throw new Error("Error in HufUnpackEncTable");a=S(8,Y,B,p,q);let s=a.l+6;if(Y=a.c,B=a.lc,e+s>x+1)throw new Error("Error in HufUnpackEncTable");for(;s--;)F[e++]=0;e--}else if(s>=59){let p=s-59+2;if(e+p>x+1)throw new Error("Error in HufUnpackEncTable");for(;p--;)F[e++]=0;e--}}!function(p){for(let E=0;E<=58;++E)d[E]=0;for(let E=0;E<a;++E)d[p[E]]+=1;let O=0;for(let E=58;E>0;--E){const p=O+d[E]>>1;d[E]=O,O=p}for(let E=0;E<a;++E){const O=p[E];O>0&&(p[E]=O|d[O]++<<6)}}(F)}function j(p){return 63&p}function c(p){return p>>6}function G(p,O,E,e,x,F){const B=E.value,s=h(O,E),D=h(O,E);E.value+=4;const Z=h(O,E);if(E.value+=4,s<0||s>=a||D<0||D>=a)throw new Error("Wrong HUF_ENCSIZE");const m=new Array(a),T=new Array(Y);!function(p){for(let O=0;O<Y;O++)p[O]={},p[O].len=0,p[O].lit=0,p[O].p=null}(T);if(M(p,E,e-(E.value-B),s,D,m),Z>8*(e-(E.value-B)))throw new Error("Wrong hufUncompress");!function(p,O,E,e){for(;O<=E;O++){const E=c(p[O]),x=j(p[O]);if(E>>x)throw new Error("Invalid table entry");if(x>q){const p=e[E>>x-q];if(p.len)throw new Error("Invalid table entry");if(p.lit++,p.p){const O=p.p;p.p=new Array(p.lit);for(let E=0;E<p.lit-1;++E)p.p[E]=O[E]}else p.p=new Array(1);p.p[p.lit-1]=O}else if(x){let p=0;for(let F=1<<q-x;F>0;F--){const F=e[(E<<q-x)+p];if(F.len||F.p)throw new Error("Invalid table entry");F.len=x,F.lit=O,p++}}}}(m,s,D,T),function(p,O,E,e,x,F,a,Y,B){let s=0,D=0;const Z=a,m=Math.trunc(e.value+(x+7)/8);for(;e.value<m;){let x=L(s,D,E,e);for(s=x.c,D=x.lc;D>=q;){const a=O[s>>D-q&16383];if(a.len){D-=a.len;const p=P(a.lit,F,s,D,E,e,Y,B,Z);p&&(s=p.c,D=p.lc)}else{if(!a.p)throw new Error("hufDecode issues");let O;for(O=0;O<a.lit;O++){const q=j(p[a.p[O]]);for(;D<q&&e.value<m;)x=L(s,D,E,e),s=x.c,D=x.lc;if(D>=q&&c(p[a.p[O]])==(s>>D-q&(1<<q)-1)){D-=q;const p=P(a.p[O],F,s,D,E,e,Y,B,Z);p&&(s=p.c,D=p.lc);break}}if(O==a.lit)throw new Error("HufDecode issues")}}}const h=8-x&7;for(s>>=h,D-=h;D>0;){const p=O[s<<q-D&16383];if(!p.len)throw new Error("HufDecode issues");{D-=p.len;const O=P(p.lit,F,s,D,E,e,Y,B,Z);O&&(s=O.c,D=O.lc)}}}(m,T,p,E,Z,D,F,x,{value:0})}function w(p){return 65535&p}function N(p){const O=w(p);return O>32767?O-65536:O}function f(p,O){const E=N(p),e=N(O),x=E+(1&e)+(e>>1);return{a:x,b:x-e}}function o(p,O){const E=w(p),e=w(O),x=E-(e>>1)&65535;return{a:e+x-32768&65535,b:x}}function K(p,O,E,e,x,F,q){const a=q<16384,Y=E>x?x:E;let B,s,D=1;for(;D<=Y;)D<<=1;for(D>>=1,B=D,D>>=1;D>=1;){s=0;const q=s+F*(x-B),Y=F*D,Z=F*B,m=e*D,h=e*B;let T,A,H,t;for(;s<=q;s+=Z){let x=s;const F=s+e*(E-B);for(;x<=F;x+=h){const E=x+m,e=x+Y,F=e+m;if(a){let q=f(p[x+O],p[e+O]);T=q.a,H=q.b,q=f(p[E+O],p[F+O]),A=q.a,t=q.b,q=f(T,A),p[x+O]=q.a,p[E+O]=q.b,q=f(H,t),p[e+O]=q.a,p[F+O]=q.b}else{let q=o(p[x+O],p[e+O]);T=q.a,H=q.b,q=o(p[E+O],p[F+O]),A=q.a,t=q.b,q=o(T,A),p[x+O]=q.a,p[E+O]=q.b,q=o(H,t),p[e+O]=q.a,p[F+O]=q.b}}if(E&D){const E=x+Y;let e;e=a?f(p[x+O],p[E+O]):o(p[x+O],p[E+O]),T=e.a,p[E+O]=e.b,p[x+O]=T}}if(x&D){let x=s;const F=s+e*(E-B);for(;x<=F;x+=h){const E=x+m;let e;e=a?f(p[x+O],p[E+O]):o(p[x+O],p[E+O]),T=e.a,p[E+O]=e.b,p[x+O]=T}}B=D,D>>=1}return s}function C(p){return new DataView(p.array.buffer,p.offset.value,p.size)}function l(p){const O=p.viewer.buffer.slice(p.offset.value,p.offset.value+p.size),E=new Uint8Array(function(p){let O=p.byteLength;const E=new Array;let e=0;const x=new DataView(p);for(;O>0;){const p=x.getInt8(e++);if(p<0){const F=-p;O-=F+1;for(let p=0;p<F;p++)E.push(x.getUint8(e++))}else{const F=p;O-=2;const q=x.getUint8(e++);for(let p=0;p<F+1;p++)E.push(q)}}return E}(O)),e=new Uint8Array(E.length);return g(E),b(E,e),new DataView(e.buffer)}function k(p){const O=p.array.slice(p.offset.value,p.offset.value+p.size),E=fflate.unzlibSync(O),e=new Uint8Array(E.length);return g(E),b(E,e),new DataView(e.buffer)}function J(p){const O=p.array.slice(p.offset.value,p.offset.value+p.size),E=fflate.unzlibSync(O),e=p.lines*p.channels*p.width,x=1==p.type?new Uint16Array(e):new Uint32Array(e);let F=0,q=0;const a=new Array(4);for(let Y=0;Y<p.lines;Y++)for(let O=0;O<p.channels;O++){let O=0;switch(p.type){case 1:a[0]=F,a[1]=a[0]+p.width,F=a[1]+p.width;for(let e=0;e<p.width;++e){O+=E[a[0]++]<<8|E[a[1]++],x[q]=O,q++}break;case 2:a[0]=F,a[1]=a[0]+p.width,a[2]=a[1]+p.width,F=a[2]+p.width;for(let e=0;e<p.width;++e){O+=E[a[0]++]<<24|E[a[1]++]<<16|E[a[2]++]<<8,x[q]=O,q++}}}return new DataView(x.buffer)}function y(p){const O=p.viewer,E={value:p.offset.value},e=new Uint16Array(p.width*p.scanlineBlockSize*(p.channels*p.type)),x=new Uint8Array(8192);let q=0;const a=new Array(p.channels);for(let F=0;F<p.channels;F++)a[F]={},a[F].start=q,a[F].end=a[F].start,a[F].nx=p.width,a[F].ny=p.lines,a[F].size=p.type,q+=a[F].nx*a[F].ny*a[F].size;const Y=A(O,E),B=A(O,E);if(B>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=B)for(let F=0;F<B-Y+1;F++)x[F+Y]=T(O,E);const s=new Uint16Array(F),D=function(p,O){let E=0;for(let x=0;x<F;++x)(0==x||p[x>>3]&1<<(7&x))&&(O[E++]=x);const e=E-1;for(;E<F;)O[E++]=0;return e}(x,s),Z=h(O,E);G(p.array,O,E,Z,e,q);for(let F=0;F<p.channels;++F){const p=a[F];for(let O=0;O<a[F].size;++O)K(e,p.start+O,p.nx,p.size,p.ny,p.nx*p.size,D)}!function(p,O,E){for(let e=0;e<E;++e)O[e]=p[O[e]]}(s,e,q);let m=0;const H=new Uint8Array(e.buffer.byteLength);for(let F=0;F<p.lines;F++)for(let O=0;O<p.channels;O++){const p=a[O],E=p.nx*p.size,x=new Uint8Array(e.buffer,2*p.end,2*E);H.set(x,m),m+=2*E,p.end+=E}return new DataView(H.buffer)}var I,X=E(1177);!function(p){p[p.Float=0]="Float",p[p.HalfFloat=1]="HalfFloat"}(I||(I={}));class z{}z.DefaultOutputType=I.HalfFloat,z.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class U{constructor(){this.supportCascades=!1}loadCubeData(p,O,E,e,x){throw".exr not supported in Cube."}async loadData(p,O,E){const x=new DataView(p.buffer),F={value:0},q=function(p,O){if(20000630!=p.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const E=p.getUint8(4),x=p.getUint8(5),F={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};O.value=8;const q={};let a=!0;for(;a;){const E=Z(p.buffer,O);if(E){const x=Z(p.buffer,O),F=V(p,O,x,h(p,O));void 0===F?e.b.Warn(`Unknown header attribute type ${x}'.`):q[E]=F}else a=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:E,spec:F,...q}}(x,F),a=await async function(p,O,E,e){const x={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:E,width:p.dataWindow.xMax-p.dataWindow.xMin+1,height:p.dataWindow.yMax-p.dataWindow.yMin+1,channels:p.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(p.compression){case B.NO_COMPRESSION:x.lines=1,x.uncompress=C;break;case B.RLE_COMPRESSION:x.lines=1,x.uncompress=l;break;case B.ZIPS_COMPRESSION:x.lines=1,x.uncompress=k,await X.d.LoadScriptAsync(z.FFLATEUrl);break;case B.ZIP_COMPRESSION:x.lines=16,x.uncompress=k,await X.d.LoadScriptAsync(z.FFLATEUrl);break;case B.PIZ_COMPRESSION:x.lines=32,x.uncompress=y;break;case B.PXR24_COMPRESSION:x.lines=16,x.uncompress=J,await X.d.LoadScriptAsync(z.FFLATEUrl);break;default:throw new Error(B[p.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const F={};for(const B of p.channels)switch(B.name){case"Y":case"R":case"G":case"B":case"A":F[B.name]=!0,x.type=B.pixelType}let q=!1;if(F.R&&F.G&&F.B)q=!F.A,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else{if(!F.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(e){case I.Float:x.getter=Q,x.inputSize=2;break;case I.HalfFloat:x.getter=A,x.inputSize=2}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+p.compression);switch(e){case I.Float:x.getter=r,x.inputSize=4;break;case I.HalfFloat:x.getter=W,x.inputSize=4}}x.blockCount=x.height/x.scanlineBlockSize;for(let B=0;B<x.blockCount;B++)t(O,E);const a=x.width*x.height*x.outputChannels;switch(e){case I.Float:x.byteArray=new Float32Array(a),x.textureType=1,q&&x.byteArray.fill(1,0,a);break;case I.HalfFloat:x.byteArray=new Uint16Array(a),x.textureType=2,q&&x.byteArray.fill(15360,0,a);break;default:throw new Error("Unsupported type: "+e)}let Y=0;for(const B of p.channels)void 0!==x.decodeChannels[B.name]&&(x.channelLineOffsets[B.name]=Y*x.width),Y+=2*B.pixelType;return x.bytesPerLine=x.width*Y,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===p.lineOrder?x.scanOrder=p=>p:x.scanOrder=p=>x.height-1-p,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}(q,x,F,z.DefaultOutputType);!function(p,O,E,e){const x={value:0};for(let F=0;F<p.height/p.scanlineBlockSize;F++){const q=m(E,e)-O.dataWindow.yMin;p.size=h(E,e),p.lines=q+p.scanlineBlockSize>p.height?p.height-q:p.scanlineBlockSize;const a=p.size<p.lines*p.bytesPerLine&&p.uncompress?p.uncompress(p):C(p);e.value+=p.size;for(let E=0;E<p.scanlineBlockSize;E++){const e=F*p.scanlineBlockSize,q=E+p.scanOrder(e);if(q>=p.height)continue;const Y=E*p.bytesPerLine,B=(p.height-1-q)*p.outLineWidth;for(let E=0;E<p.channels;E++){const e=O.channels[E].name,F=p.channelLineOffsets[e],q=p.decodeChannels[e];if(void 0!==q){x.value=Y+F;for(let O=0;O<p.width;O++){const E=B+O*p.outputChannels+q;p.byteArray&&(p.byteArray[E]=p.getter(a,x))}}}}}}(a,q,x,F);E(q.dataWindow.xMax-q.dataWindow.xMin+1,q.dataWindow.yMax-q.dataWindow.yMin+1,O.generateMipMaps,!1,(()=>{const p=O.getEngine();O.format=q.format,O.type=a.textureType,O.invertY=!1,O._gammaSpace=!q.linearSpace,a.byteArray&&p._uploadDataToTextureDirectly(O,a.byteArray,0,0,void 0,!0)}))}}}}]);