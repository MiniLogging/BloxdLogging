"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12900:(O,f,y)=>{y.r(f),y.d(f,{_DDSTextureLoader:()=>b});var S=y(11776),H=y(11789);class b{constructor(){this.supportCascades=!0}loadCubeData(O,f,y,b){const h=f.getEngine();let v,N=!1,m=1e3;if(Array.isArray(O))for(let S=0;S<O.length;S++){const y=O[S];v=H.c.GetDDSInfo(y),f.width=v.width,f.height=v.height,N=(v.isRGB||v.isLuminance||v.mipmapCount>1)&&f.generateMipMaps,h._unpackFlipY(v.isCompressed),H.c.UploadDDSLevels(h,f,y,v,N,6,-1,S),v.isFourCC||1!==v.mipmapCount?m=v.mipmapCount-1:h.generateMipMapsForCubemap(f)}else{const b=O;v=H.c.GetDDSInfo(b),f.width=v.width,f.height=v.height,y&&(v.sphericalPolynomial=new S.h),N=(v.isRGB||v.isLuminance||v.mipmapCount>1)&&f.generateMipMaps,h._unpackFlipY(v.isCompressed),H.c.UploadDDSLevels(h,f,b,v,N,6),v.isFourCC||1!==v.mipmapCount?m=v.mipmapCount-1:h.generateMipMapsForCubemap(f,!1)}h._setCubeMapTextureParams(f,N,m),f.isReady=!0,f.onLoadedObservable.notifyObservers(f),f.onLoadedObservable.clear(),b&&b({isDDS:!0,width:f.width,info:v,data:O,texture:f})}loadData(O,f,y){const S=H.c.GetDDSInfo(O),b=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&f.generateMipMaps&&Math.max(S.width,S.height)>>S.mipmapCount-1===1;y(S.width,S.height,b,S.isFourCC,(()=>{H.c.UploadDDSLevels(f.getEngine(),f,O,S,b,1)}))}}}}]);