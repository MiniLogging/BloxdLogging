"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12856:(V,O,Z)=>{Z.r(O),Z.d(O,{_DDSTextureLoader:()=>r});var d=Z(11713),p=Z(11726);class r{constructor(){this.supportCascades=!0}loadCubeData(V,O,Z,r){const Y=O.getEngine();let m,a=!1,R=1e3;if(Array.isArray(V))for(let d=0;d<V.length;d++){const Z=V[d];m=p.c.GetDDSInfo(Z),O.width=m.width,O.height=m.height,a=(m.isRGB||m.isLuminance||m.mipmapCount>1)&&O.generateMipMaps,Y._unpackFlipY(m.isCompressed),p.c.UploadDDSLevels(Y,O,Z,m,a,6,-1,d),m.isFourCC||1!==m.mipmapCount?R=m.mipmapCount-1:Y.generateMipMapsForCubemap(O)}else{const r=V;m=p.c.GetDDSInfo(r),O.width=m.width,O.height=m.height,Z&&(m.sphericalPolynomial=new d.g),a=(m.isRGB||m.isLuminance||m.mipmapCount>1)&&O.generateMipMaps,Y._unpackFlipY(m.isCompressed),p.c.UploadDDSLevels(Y,O,r,m,a,6),m.isFourCC||1!==m.mipmapCount?R=m.mipmapCount-1:Y.generateMipMapsForCubemap(O,!1)}Y._setCubeMapTextureParams(O,a,R),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),r&&r({isDDS:!0,width:O.width,info:m,data:V,texture:O})}loadData(V,O,Z){const d=p.c.GetDDSInfo(V),r=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&O.generateMipMaps&&Math.max(d.width,d.height)>>d.mipmapCount-1===1;Z(d.width,d.height,r,d.isFourCC,(()=>{p.c.UploadDDSLevels(O.getEngine(),O,V,d,r,1)}))}}}}]);