"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12648:(K,q,p)=>{p.r(q),p.d(q,{_DDSTextureLoader:()=>S});var Z=p(11478),z=p(11499);class S{constructor(){this.supportCascades=!0}loadCubeData(K,q,p,S){const X=q.getEngine();let y,V=!1,C=1e3;if(Array.isArray(K))for(let Z=0;Z<K.length;Z++){const p=K[Z];y=z.b.GetDDSInfo(p),q.width=y.width,q.height=y.height,V=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&q.generateMipMaps,X._unpackFlipY(y.isCompressed),z.b.UploadDDSLevels(X,q,p,y,V,6,-1,Z),y.isFourCC||1!==y.mipmapCount?C=y.mipmapCount-1:X.generateMipMapsForCubemap(q)}else{const S=K;y=z.b.GetDDSInfo(S),q.width=y.width,q.height=y.height,p&&(y.sphericalPolynomial=new Z.g),V=(y.isRGB||y.isLuminance||y.mipmapCount>1)&&q.generateMipMaps,X._unpackFlipY(y.isCompressed),z.b.UploadDDSLevels(X,q,S,y,V,6),y.isFourCC||1!==y.mipmapCount?C=y.mipmapCount-1:X.generateMipMapsForCubemap(q,!1)}X._setCubeMapTextureParams(q,V,C),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),S&&S({isDDS:!0,width:q.width,info:y,data:K,texture:q})}loadData(K,q,p){const Z=z.b.GetDDSInfo(K),S=(Z.isRGB||Z.isLuminance||Z.mipmapCount>1)&&q.generateMipMaps&&Math.max(Z.width,Z.height)>>Z.mipmapCount-1===1;p(Z.width,Z.height,S,Z.isFourCC,(()=>{z.b.UploadDDSLevels(q.getEngine(),q,K,Z,S,1)}))}}}}]);