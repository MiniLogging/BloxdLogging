"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2558:(U,M,b)=>{b.r(M),b.d(M,{_HDRTextureLoader:()=>x});var a=b(670);class A{static ConvertPanoramaToCubemap(U,M,b,a){let A=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!U)throw"ConvertPanoramaToCubemap: input cannot be null";if(U.length!=M*b*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(a,this.FACE_FRONT,U,M,b,A),back:this.CreateCubemapTexture(a,this.FACE_BACK,U,M,b,A),left:this.CreateCubemapTexture(a,this.FACE_LEFT,U,M,b,A),right:this.CreateCubemapTexture(a,this.FACE_RIGHT,U,M,b,A),up:this.CreateCubemapTexture(a,this.FACE_UP,U,M,b,A),down:this.CreateCubemapTexture(a,this.FACE_DOWN,U,M,b,A),size:a,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(U,M,b,a,A){let H=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const W=new ArrayBuffer(U*U*4*3),y=new Float32Array(W),O=H?Math.max(1,Math.round(a/4/U)):1,e=1/O,x=e*e,P=M[1].je(M[0]).scale(e/U),Z=M[3].je(M[2]).scale(e/U),C=1/U;let r=0;for(let B=0;B<U;B++)for(let H=0;H<O;H++){let H=M[0],W=M[2];for(let M=0;M<U;M++)for(let e=0;e<O;e++){const O=W.je(H).scale(r).add(H);O.normalize();const e=this.CalcProjectionSpherical(O,b,a,A);y[B*U*3+3*M+0]+=e.r*x,y[B*U*3+3*M+1]+=e.g*x,y[B*U*3+3*M+2]+=e.b*x,H=H.add(P),W=W.add(Z)}r+=C*e}return y}static CalcProjectionSpherical(U,M,b,a){let A=Math.atan2(U.z,U.x);const H=Math.acos(U.y);for(;A<-Math.PI;)A+=2*Math.PI;for(;A>Math.PI;)A-=2*Math.PI;let W=A/Math.PI;const y=H/Math.PI;W=.5*W+.5;let O=Math.round(W*b);O<0?O=0:O>=b&&(O=b-1);let e=Math.round(y*a);e<0?e=0:e>=a&&(e=a-1);const x=a-e-1;return{r:M[x*b*3+3*O+0],g:M[x*b*3+3*O+1],b:M[x*b*3+3*O+2]}}}function H(U,M,b,a,A,H){A>0?(A=function(U,M){return M>1023?U*Math.pow(2,1023)*Math.pow(2,M-1023):M<-1074?U*Math.pow(2,-1074)*Math.pow(2,M+1074):U*Math.pow(2,M)}(1,A-136),U[H+0]=M*A,U[H+1]=b*A,U[H+2]=a*A):(U[H+0]=0,U[H+1]=0,U[H+2]=0)}function W(U,M){let b="",a="";for(let A=M;A<U.length-M&&(a=String.fromCharCode(U[A]),"\n"!=a);A++)b+=a;return b}function y(U){let M=0,b=0,a=W(U,0);if("#"!=a[0]||"?"!=a[1])throw"Bad HDR Format.";let A=!1,H=!1,y=0;do{y+=a.length+1,a=W(U,y),"FORMAT=32-bit_rle_rgbe"==a?H=!0:0==a.length&&(A=!0)}while(!A);if(!H)throw"HDR Bad header format, unsupported FORMAT";y+=a.length+1,a=W(U,y);const O=/^-Y (.*) \+X (.*)$/g.exec(a);if(!O||O.length<3)throw"HDR Bad header format, no size";if(b=parseInt(O[2]),M=parseInt(O[1]),b<8||b>32767)throw"HDR Bad header format, unsupported size";return y+=a.length+1,{height:M,width:b,dataPosition:y}}function O(U,M){return function(U,M){let b=M.height;const a=M.width;let A,W,y,O,x,P=M.dataPosition,Z=0,C=0,r=0;const B=new ArrayBuffer(4*a),J=new Uint8Array(B),F=new ArrayBuffer(M.width*M.height*4*3),f=new Float32Array(F);for(;b>0;){if(A=U[P++],W=U[P++],y=U[P++],O=U[P++],2!=A||2!=W||128&y||M.width<8||M.width>32767)return e(U,M);if((y<<8|O)!=a)throw"HDR Bad header format, wrong scan line width";for(Z=0,r=0;r<4;r++)for(C=(r+1)*a;Z<C;)if(A=U[P++],W=U[P++],A>128){if(x=A-128,0==x||x>C-Z)throw"HDR Bad Format, bad scanline data (run)";for(;x-- >0;)J[Z++]=W}else{if(x=A,0==x||x>C-Z)throw"HDR Bad Format, bad scanline data (non-run)";if(J[Z++]=W,--x>0)for(let M=0;M<x;M++)J[Z++]=U[P++]}for(r=0;r<a;r++)A=J[r],W=J[r+a],y=J[r+2*a],O=J[r+3*a],H(f,A,W,y,O,(M.height-b)*a*3+3*r);b--}return f}(U,M)}function e(U,M){let b=M.height;const a=M.width;let A,W,y,O,e,x=M.dataPosition;const P=new ArrayBuffer(M.width*M.height*4*3),Z=new Float32Array(P);for(;b>0;){for(e=0;e<M.width;e++)A=U[x++],W=U[x++],y=U[x++],O=U[x++],H(Z,A,W,y,O,(M.height-b)*a*3+3*e);b--}return Z}A.FACE_LEFT=[new a.l(-1,-1,-1),new a.l(1,-1,-1),new a.l(-1,1,-1),new a.l(1,1,-1)],A.FACE_RIGHT=[new a.l(1,-1,1),new a.l(-1,-1,1),new a.l(1,1,1),new a.l(-1,1,1)],A.FACE_FRONT=[new a.l(1,-1,-1),new a.l(1,-1,1),new a.l(1,1,-1),new a.l(1,1,1)],A.FACE_BACK=[new a.l(-1,-1,1),new a.l(-1,-1,-1),new a.l(-1,1,1),new a.l(-1,1,-1)],A.FACE_DOWN=[new a.l(1,1,-1),new a.l(1,1,1),new a.l(-1,1,-1),new a.l(-1,1,1)],A.FACE_UP=[new a.l(-1,-1,-1),new a.l(-1,-1,1),new a.l(1,-1,-1),new a.l(1,-1,1)];class x{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(U,M,b){const a=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),A=y(a),H=O(a,A),W=A.width*A.height,e=new Float32Array(4*W);for(let y=0;y<W;y+=1)e[4*y]=H[3*y],e[4*y+1]=H[3*y+1],e[4*y+2]=H[3*y+2],e[4*y+3]=1;b(A.width,A.height,M.generateMipMaps,!1,(()=>{const U=M.getEngine();M.type=1,M.format=5,M._gammaSpace=!1,U._uploadDataToTextureDirectly(M,e)}))}}}}]);