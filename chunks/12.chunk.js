"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12724:(h,b,I)=>{I.r(b),I.d(b,{_DDSTextureLoader:()=>T});var g=I(11639),O=I(11658);class T{constructor(){this.supportCascades=!0}loadCubeData(h,b,I,T){const N=b.getEngine();let V,M=!1,y=1e3;if(Array.isArray(h))for(let g=0;g<h.length;g++){const I=h[g];V=O.e.GetDDSInfo(I),b.width=V.width,b.height=V.height,M=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&b.generateMipMaps,N._unpackFlipY(V.isCompressed),O.e.UploadDDSLevels(N,b,I,V,M,6,-1,g),V.isFourCC||1!==V.mipmapCount?y=V.mipmapCount-1:N.generateMipMapsForCubemap(b)}else{const T=h;V=O.e.GetDDSInfo(T),b.width=V.width,b.height=V.height,I&&(V.sphericalPolynomial=new g.f),M=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&b.generateMipMaps,N._unpackFlipY(V.isCompressed),O.e.UploadDDSLevels(N,b,T,V,M,6),V.isFourCC||1!==V.mipmapCount?y=V.mipmapCount-1:N.generateMipMapsForCubemap(b,!1)}N._setCubeMapTextureParams(b,M,y),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),T&&T({isDDS:!0,width:b.width,info:V,data:h,texture:b})}loadData(h,b,I){const g=O.e.GetDDSInfo(h),T=(g.isRGB||g.isLuminance||g.mipmapCount>1)&&b.generateMipMaps&&Math.max(g.width,g.height)>>g.mipmapCount-1===1;I(g.width,g.height,T,g.isFourCC,(()=>{O.e.UploadDDSLevels(b.getEngine(),b,h,g,T,1)}))}}}}]);