"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{2496:(A,X,s)=>{s.r(X),s.d(X,{_HDRTextureLoader:()=>Y});var N=s(678);class f{static ConvertPanoramaToCubemap(A,X,s,N){let f=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!A)throw"ConvertPanoramaToCubemap: input cannot be null";if(A.length!=X*s*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(N,this.FACE_FRONT,A,X,s,f),back:this.CreateCubemapTexture(N,this.FACE_BACK,A,X,s,f),left:this.CreateCubemapTexture(N,this.FACE_LEFT,A,X,s,f),right:this.CreateCubemapTexture(N,this.FACE_RIGHT,A,X,s,f),up:this.CreateCubemapTexture(N,this.FACE_UP,A,X,s,f),down:this.CreateCubemapTexture(N,this.FACE_DOWN,A,X,s,f),size:N,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(A,X,s,N,f){let E=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const g=new ArrayBuffer(A*A*4*3),K=new Float32Array(g),r=E?Math.max(1,Math.round(N/4/A)):1,i=1/r,Y=i*i,v=X[1].Pg(X[0]).scale(i/A),c=X[3].Pg(X[2]).scale(i/A),M=1/A;let d=0;for(let Q=0;Q<A;Q++)for(let E=0;E<r;E++){let E=X[0],g=X[2];for(let X=0;X<A;X++)for(let i=0;i<r;i++){const r=g.Pg(E).scale(d).add(E);r.normalize();const i=this.CalcProjectionSpherical(r,s,N,f);K[Q*A*3+3*X+0]+=i.r*Y,K[Q*A*3+3*X+1]+=i.g*Y,K[Q*A*3+3*X+2]+=i.b*Y,E=E.add(v),g=g.add(c)}d+=M*i}return K}static CalcProjectionSpherical(A,X,s,N){let f=Math.atan2(A.z,A.x);const E=Math.acos(A.y);for(;f<-Math.PI;)f+=2*Math.PI;for(;f>Math.PI;)f-=2*Math.PI;let g=f/Math.PI;const K=E/Math.PI;g=.5*g+.5;let r=Math.round(g*s);r<0?r=0:r>=s&&(r=s-1);let i=Math.round(K*N);i<0?i=0:i>=N&&(i=N-1);const Y=N-i-1;return{r:X[Y*s*3+3*r+0],g:X[Y*s*3+3*r+1],b:X[Y*s*3+3*r+2]}}}function E(A,X,s,N,f,E){f>0?(f=function(A,X){return X>1023?A*Math.pow(2,1023)*Math.pow(2,X-1023):X<-1074?A*Math.pow(2,-1074)*Math.pow(2,X+1074):A*Math.pow(2,X)}(1,f-136),A[E+0]=X*f,A[E+1]=s*f,A[E+2]=N*f):(A[E+0]=0,A[E+1]=0,A[E+2]=0)}function g(A,X){let s="",N="";for(let f=X;f<A.length-X&&(N=String.fromCharCode(A[f]),"\n"!=N);f++)s+=N;return s}function K(A){let X=0,s=0,N=g(A,0);if("#"!=N[0]||"?"!=N[1])throw"Bad HDR Format.";let f=!1,E=!1,K=0;do{K+=N.length+1,N=g(A,K),"FORMAT=32-bit_rle_rgbe"==N?E=!0:0==N.length&&(f=!0)}while(!f);if(!E)throw"HDR Bad header format, unsupported FORMAT";K+=N.length+1,N=g(A,K);const r=/^-Y (.*) \+X (.*)$/g.exec(N);if(!r||r.length<3)throw"HDR Bad header format, no size";if(s=parseInt(r[2]),X=parseInt(r[1]),s<8||s>32767)throw"HDR Bad header format, unsupported size";return K+=N.length+1,{height:X,width:s,dataPosition:K}}function r(A,X){return function(A,X){let s=X.height;const N=X.width;let f,g,K,r,Y,v=X.dataPosition,c=0,M=0,d=0;const Q=new ArrayBuffer(4*N),w=new Uint8Array(Q),R=new ArrayBuffer(X.width*X.height*4*3),C=new Float32Array(R);for(;s>0;){if(f=A[v++],g=A[v++],K=A[v++],r=A[v++],2!=f||2!=g||128&K||X.width<8||X.width>32767)return i(A,X);if((K<<8|r)!=N)throw"HDR Bad header format, wrong scan line width";for(c=0,d=0;d<4;d++)for(M=(d+1)*N;c<M;)if(f=A[v++],g=A[v++],f>128){if(Y=f-128,0==Y||Y>M-c)throw"HDR Bad Format, bad scanline data (run)";for(;Y-- >0;)w[c++]=g}else{if(Y=f,0==Y||Y>M-c)throw"HDR Bad Format, bad scanline data (non-run)";if(w[c++]=g,--Y>0)for(let X=0;X<Y;X++)w[c++]=A[v++]}for(d=0;d<N;d++)f=w[d],g=w[d+N],K=w[d+2*N],r=w[d+3*N],E(C,f,g,K,r,(X.height-s)*N*3+3*d);s--}return C}(A,X)}function i(A,X){let s=X.height;const N=X.width;let f,g,K,r,i,Y=X.dataPosition;const v=new ArrayBuffer(X.width*X.height*4*3),c=new Float32Array(v);for(;s>0;){for(i=0;i<X.width;i++)f=A[Y++],g=A[Y++],K=A[Y++],r=A[Y++],E(c,f,g,K,r,(X.height-s)*N*3+3*i);s--}return c}f.FACE_LEFT=[new N.k(-1,-1,-1),new N.k(1,-1,-1),new N.k(-1,1,-1),new N.k(1,1,-1)],f.FACE_RIGHT=[new N.k(1,-1,1),new N.k(-1,-1,1),new N.k(1,1,1),new N.k(-1,1,1)],f.FACE_FRONT=[new N.k(1,-1,-1),new N.k(1,-1,1),new N.k(1,1,-1),new N.k(1,1,1)],f.FACE_BACK=[new N.k(-1,-1,1),new N.k(-1,-1,-1),new N.k(-1,1,1),new N.k(-1,1,-1)],f.FACE_DOWN=[new N.k(1,1,-1),new N.k(1,1,1),new N.k(-1,1,-1),new N.k(-1,1,1)],f.FACE_UP=[new N.k(-1,-1,-1),new N.k(-1,-1,1),new N.k(1,-1,-1),new N.k(1,-1,1)];class Y{constructor(){this.supportCascades=!1}loadCubeData(){throw".hdr not supported in Cube."}loadData(A,X,s){const N=new Uint8Array(A.buffer,A.byteOffset,A.byteLength),f=K(N),E=r(N,f),g=f.width*f.height,i=new Float32Array(4*g);for(let K=0;K<g;K+=1)i[4*K]=E[3*K],i[4*K+1]=E[3*K+1],i[4*K+2]=E[3*K+2],i[4*K+3]=1;s(f.width,f.height,X.generateMipMaps,!1,(()=>{const A=X.getEngine();X.type=1,X.format=5,X._gammaSpace=!1,A._uploadDataToTextureDirectly(X,i)}))}}}}]);