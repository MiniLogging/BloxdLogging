"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10730:(V,n,O)=>{O.r(n),O.d(n,{_ExrTextureLoader:()=>h});var H=O(1118),g=O(1056);const f=65536,x=14,c=65537,e=16384;var U,M;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(M||(M={}));const p=function(){const V=new ArrayBuffer(4),n=new Float32Array(V),O=new Uint32Array(V),H=new Uint32Array(512),g=new Uint32Array(512);for(let e=0;e<256;++e){const V=e-127;V<-27?(H[e]=0,H[256|e]=32768,g[e]=24,g[256|e]=24):V<-14?(H[e]=1024>>-V-14,H[256|e]=1024>>-V-14|32768,g[e]=-V-1,g[256|e]=-V-1):V<=15?(H[e]=V+15<<10,H[256|e]=V+15<<10|32768,g[e]=13,g[256|e]=13):V<128?(H[e]=31744,H[256|e]=64512,g[e]=24,g[256|e]=24):(H[e]=31744,H[256|e]=64512,g[e]=13,g[256|e]=13)}const f=new Uint32Array(2048),x=new Uint32Array(64),c=new Uint32Array(64);for(let e=1;e<1024;++e){let V=e<<13,n=0;for(;0===(8388608&V);)V<<=1,n-=8388608;V&=-8388609,n+=947912704,f[e]=V|n}for(let e=1024;e<2048;++e)f[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)x[e]=e<<23;x[31]=1199570944,x[32]=2147483648;for(let e=33;e<63;++e)x[e]=2147483648+(e-32<<23);x[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(c[e]=1024);return{floatView:n,uint32View:O,baseTable:H,shiftTable:g,mantissaTable:f,exponentTable:x,offsetTable:c}}();function j(V,n){const O=new Uint8Array(V);let H=0;for(;0!=O[n.value+H];)H+=1;const g=(new TextDecoder).decode(O.slice(n.value,n.value+H));return n.value=n.value+H+1,g}function i(V,n){const O=V.getInt32(n.value,!0);return n.value+=4,O}function A(V,n){const O=V.getUint32(n.value,!0);return n.value+=4,O}function S(V,n){const O=V.getUint8(n.value);return n.value+=1,O}function B(V,n){const O=V.getUint16(n.value,!0);return n.value+=2,O}function X(V,n){const O=V[n.value];return n.value+=1,O}function a(V,n){let O;return O="getBigInt64"in DataView.prototype?Number(V.getBigInt64(n.value,!0)):V.getUint32(n.value+4,!0)+Number(V.getUint32(n.value,!0)<<32),n.value+=8,O}function q(V,n){const O=V.getFloat32(n.value,!0);return n.value+=4,O}function G(V,n){return function(V){const n=(31744&V)>>10,O=1023&V;return(V>>15?-1:1)*(n?31===n?O?NaN:1/0:Math.pow(2,n-15)*(1+O/1024):O/1024*6103515625e-14)}(B(V,n))}function W(V,n){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,g.b)(V,-65504,65504),p.floatView[0]=V;const n=p.uint32View[0],O=n>>23&511;return p.baseTable[O]+((8388607&n)>>p.shiftTable[O])}(q(V,n))}function v(V,n,O,H){switch(O){case"string":case"stringvector":case"iccProfile":return function(V,n,O){const H=(new TextDecoder).decode(new Uint8Array(V).slice(n.value,n.value+O));return n.value=n.value+O,H}(V.buffer,n,H);case"chlist":return function(V,n,O){const H=n.value,g=[];for(;n.value<H+O-1;){const O=j(V.buffer,n),H=i(V,n),f=S(V,n);n.value+=3;const x=i(V,n),c=i(V,n);g.push({name:O,pixelType:H,pLinear:f,xSampling:x,ySampling:c})}return n.value+=1,g}(V,n,H);case"chromaticities":return function(V,n){return{redX:q(V,n),redY:q(V,n),greenX:q(V,n),greenY:q(V,n),blueX:q(V,n),blueY:q(V,n),whiteX:q(V,n),whiteY:q(V,n)}}(V,n);case"compression":return function(V,n){return S(V,n)}(V,n);case"box2i":return function(V,n){return{xMin:i(V,n),yMin:i(V,n),xMax:i(V,n),yMax:i(V,n)}}(V,n);case"lineOrder":return function(V,n){const O=S(V,n);return M[O]}(V,n);case"float":return q(V,n);case"v2f":return function(V,n){return[q(V,n),q(V,n)]}(V,n);case"v3f":return function(V,n){return[q(V,n),q(V,n),q(V,n)]}(V,n);case"int":return i(V,n);case"rational":return function(V,n){return[i(V,n),A(V,n)]}(V,n);case"timecode":return function(V,n){return[A(V,n),A(V,n)]}(V,n);case"preview":return n.value+=H,"skipped";default:return void(n.value+=H)}}function Z(V){for(let n=1;n<V.length;n++){const O=V[n-1]+V[n]-128;V[n]=O}}function T(V,n){let O=0,H=Math.floor((V.length+1)/2),g=0;const f=V.length-1;for(;!(g>f)&&(n[g++]=V[O++],!(g>f));)n[g++]=V[H++]}function K(V,n,O,H,g){for(;O<V;)n=n<<8|X(H,g),O+=8;return{l:n>>(O-=V)&(1<<V)-1,c:n,lc:O}}function P(V,n,O,H){return{c:V=V<<8|X(O,H),lc:n+=8}}function w(V,n,O,H,g,f,x,c,e){if(V==n){if(H<8){const V=P(O,H,g,f);O=V.c,H=V.lc}let V=O>>(H-=8);if(V=new Uint8Array([V])[0],c.value+V>e)return null;const n=x[c.value-1];for(;V-- >0;)x[c.value++]=n}else{if(!(c.value<e))return null;x[c.value++]=V}return{c:O,lc:H}}const r=new Array(59);function Y(V,n,O,H,g,f){const x=n;let e=0,U=0;for(;H<=g;H++){if(x.value-n.value>O)return;let c=K(6,e,U,V,x);const M=c.l;if(e=c.c,U=c.lc,f[H]=M,63==M){if(x.value-n.value>O)throw new Error("Error in HufUnpackEncTable");c=K(8,e,U,V,x);let M=c.l+6;if(e=c.c,U=c.lc,H+M>g+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)f[H++]=0;H--}else if(M>=59){let V=M-59+2;if(H+V>g+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)f[H++]=0;H--}}!function(V){for(let O=0;O<=58;++O)r[O]=0;for(let O=0;O<c;++O)r[V[O]]+=1;let n=0;for(let O=58;O>0;--O){const V=n+r[O]>>1;r[O]=n,n=V}for(let O=0;O<c;++O){const n=V[O];n>0&&(V[O]=n|r[n]++<<6)}}(f)}function E(V){return 63&V}function s(V){return V>>6}function l(V,n,O,H,g,f){const U=O.value,M=A(n,O),p=A(n,O);O.value+=4;const j=A(n,O);if(O.value+=4,M<0||M>=c||p<0||p>=c)throw new Error("Wrong HUF_ENCSIZE");const i=new Array(c),S=new Array(e);!function(V){for(let n=0;n<e;n++)V[n]={},V[n].len=0,V[n].lit=0,V[n].p=null}(S);if(Y(V,O,H-(O.value-U),M,p,i),j>8*(H-(O.value-U)))throw new Error("Wrong hufUncompress");!function(V,n,O,H){for(;n<=O;n++){const O=s(V[n]),g=E(V[n]);if(O>>g)throw new Error("Invalid table entry");if(g>x){const V=H[O>>g-x];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const n=V.p;V.p=new Array(V.lit);for(let O=0;O<V.lit-1;++O)V.p[O]=n[O]}else V.p=new Array(1);V.p[V.lit-1]=n}else if(g){let V=0;for(let f=1<<x-g;f>0;f--){const f=H[(O<<x-g)+V];if(f.len||f.p)throw new Error("Invalid table entry");f.len=g,f.lit=n,V++}}}}(i,M,p,S),function(V,n,O,H,g,f,c,e,U){let M=0,p=0;const j=c,i=Math.trunc(H.value+(g+7)/8);for(;H.value<i;){let g=P(M,p,O,H);for(M=g.c,p=g.lc;p>=x;){const c=n[M>>p-x&16383];if(c.len){p-=c.len;const V=w(c.lit,f,M,p,O,H,e,U,j);V&&(M=V.c,p=V.lc)}else{if(!c.p)throw new Error("hufDecode issues");let n;for(n=0;n<c.lit;n++){const x=E(V[c.p[n]]);for(;p<x&&H.value<i;)g=P(M,p,O,H),M=g.c,p=g.lc;if(p>=x&&s(V[c.p[n]])==(M>>p-x&(1<<x)-1)){p-=x;const V=w(c.p[n],f,M,p,O,H,e,U,j);V&&(M=V.c,p=V.lc);break}}if(n==c.lit)throw new Error("HufDecode issues")}}}const A=8-g&7;for(M>>=A,p-=A;p>0;){const V=n[M<<x-p&16383];if(!V.len)throw new Error("HufDecode issues");{p-=V.len;const n=w(V.lit,f,M,p,O,H,e,U,j);n&&(M=n.c,p=n.lc)}}}(i,S,V,O,j,p,f,g,{value:0})}function t(V){return 65535&V}function k(V){const n=t(V);return n>32767?n-65536:n}function R(V,n){const O=k(V),H=k(n),g=O+(1&H)+(H>>1);return{a:g,b:g-H}}function z(V,n){const O=t(V),H=t(n),g=O-(H>>1)&65535;return{a:H+g-32768&65535,b:g}}function Q(V,n,O,H,g,f,x){const c=x<16384,e=O>g?g:O;let U,M,p=1;for(;p<=e;)p<<=1;for(p>>=1,U=p,p>>=1;p>=1;){M=0;const x=M+f*(g-U),e=f*p,j=f*U,i=H*p,A=H*U;let S,B,X,a;for(;M<=x;M+=j){let g=M;const f=M+H*(O-U);for(;g<=f;g+=A){const O=g+i,H=g+e,f=H+i;if(c){let x=R(V[g+n],V[H+n]);S=x.a,X=x.b,x=R(V[O+n],V[f+n]),B=x.a,a=x.b,x=R(S,B),V[g+n]=x.a,V[O+n]=x.b,x=R(X,a),V[H+n]=x.a,V[f+n]=x.b}else{let x=z(V[g+n],V[H+n]);S=x.a,X=x.b,x=z(V[O+n],V[f+n]),B=x.a,a=x.b,x=z(S,B),V[g+n]=x.a,V[O+n]=x.b,x=z(X,a),V[H+n]=x.a,V[f+n]=x.b}}if(O&p){const O=g+e;let H;H=c?R(V[g+n],V[O+n]):z(V[g+n],V[O+n]),S=H.a,V[O+n]=H.b,V[g+n]=S}}if(g&p){let g=M;const f=M+H*(O-U);for(;g<=f;g+=A){const O=g+i;let H;H=c?R(V[g+n],V[O+n]):z(V[g+n],V[O+n]),S=H.a,V[O+n]=H.b,V[g+n]=S}}U=p,p>>=1}return M}function N(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function o(V){const n=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),O=new Uint8Array(function(V){let n=V.byteLength;const O=new Array;let H=0;const g=new DataView(V);for(;n>0;){const V=g.getInt8(H++);if(V<0){const f=-V;n-=f+1;for(let V=0;V<f;V++)O.push(g.getUint8(H++))}else{const f=V;n-=2;const x=g.getUint8(H++);for(let V=0;V<f+1;V++)O.push(x)}}return O}(n)),H=new Uint8Array(O.length);return Z(O),T(O,H),new DataView(H.buffer)}function D(V){const n=V.array.slice(V.offset.value,V.offset.value+V.size),O=fflate.unzlibSync(n),H=new Uint8Array(O.length);return Z(O),T(O,H),new DataView(H.buffer)}function J(V){const n=V.array.slice(V.offset.value,V.offset.value+V.size),O=fflate.unzlibSync(n),H=V.lines*V.channels*V.width,g=1==V.type?new Uint16Array(H):new Uint32Array(H);let f=0,x=0;const c=new Array(4);for(let e=0;e<V.lines;e++)for(let n=0;n<V.channels;n++){let n=0;switch(V.type){case 1:c[0]=f,c[1]=c[0]+V.width,f=c[1]+V.width;for(let H=0;H<V.width;++H){n+=O[c[0]++]<<8|O[c[1]++],g[x]=n,x++}break;case 2:c[0]=f,c[1]=c[0]+V.width,c[2]=c[1]+V.width,f=c[2]+V.width;for(let H=0;H<V.width;++H){n+=O[c[0]++]<<24|O[c[1]++]<<16|O[c[2]++]<<8,g[x]=n,x++}}}return new DataView(g.buffer)}function m(V){const n=V.viewer,O={value:V.offset.value},H=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),g=new Uint8Array(8192);let x=0;const c=new Array(V.channels);for(let f=0;f<V.channels;f++)c[f]={},c[f].start=x,c[f].end=c[f].start,c[f].nx=V.width,c[f].ny=V.lines,c[f].size=V.type,x+=c[f].nx*c[f].ny*c[f].size;const e=B(n,O),U=B(n,O);if(U>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(e<=U)for(let f=0;f<U-e+1;f++)g[f+e]=S(n,O);const M=new Uint16Array(f),p=function(V,n){let O=0;for(let g=0;g<f;++g)(0==g||V[g>>3]&1<<(7&g))&&(n[O++]=g);const H=O-1;for(;O<f;)n[O++]=0;return H}(g,M),j=A(n,O);l(V.array,n,O,j,H,x);for(let f=0;f<V.channels;++f){const V=c[f];for(let n=0;n<c[f].size;++n)Q(H,V.start+n,V.nx,V.size,V.ny,V.nx*V.size,p)}!function(V,n,O){for(let H=0;H<O;++H)n[H]=V[n[H]]}(M,H,x);let i=0;const X=new Uint8Array(H.buffer.byteLength);for(let f=0;f<V.lines;f++)for(let n=0;n<V.channels;n++){const V=c[n],O=V.nx*V.size,g=new Uint8Array(H.buffer,2*V.end,2*O);X.set(g,i),i+=2*O,V.end+=O}return new DataView(X.buffer)}var b,C=O(1244);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(b||(b={}));class u{}u.DefaultOutputType=b.HalfFloat,u.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class h{constructor(){this.supportCascades=!1}loadCubeData(V,n,O,H,g){throw".exr not supported in Cube."}async loadData(V,n,O){const g=new DataView(V.buffer),f={value:0},x=function(V,n){if(20000630!=V.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const O=V.getUint8(4),g=V.getUint8(5),f={singleTile:!!(2&g),longName:!!(4&g),deepFormat:!!(8&g),multiPart:!!(16&g)};n.value=8;const x={};let c=!0;for(;c;){const O=j(V.buffer,n);if(O){const g=j(V.buffer,n),f=v(V,n,g,A(V,n));void 0===f?H.b.Warn(`Unknown header attribute type ${g}'.`):x[O]=f}else c=!1}if(0!=(-5&g))throw new Error("Unsupported file format");return{version:O,spec:f,...x}}(g,f),c=await async function(V,n,O,H){const g={size:0,viewer:n,array:new Uint8Array(n.buffer),offset:O,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case U.NO_COMPRESSION:g.lines=1,g.uncompress=N;break;case U.RLE_COMPRESSION:g.lines=1,g.uncompress=o;break;case U.ZIPS_COMPRESSION:g.lines=1,g.uncompress=D,await C.f.LoadScriptAsync(u.FFLATEUrl);break;case U.ZIP_COMPRESSION:g.lines=16,g.uncompress=D,await C.f.LoadScriptAsync(u.FFLATEUrl);break;case U.PIZ_COMPRESSION:g.lines=32,g.uncompress=m;break;case U.PXR24_COMPRESSION:g.lines=16,g.uncompress=J,await C.f.LoadScriptAsync(u.FFLATEUrl);break;default:throw new Error(U[V.compression]+" is unsupported")}g.scanlineBlockSize=g.lines;const f={};for(const U of V.channels)switch(U.name){case"Y":case"R":case"G":case"B":case"A":f[U.name]=!0,g.type=U.pixelType}let x=!1;if(f.R&&f.G&&f.B)x=!f.A,g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else{if(!f.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");g.outputChannels=1,g.decodeChannels={Y:0}}if(1===g.type)switch(H){case b.Float:g.getter=G,g.inputSize=2;break;case b.HalfFloat:g.getter=B,g.inputSize=2}else{if(2!==g.type)throw new Error("Unsupported pixelType "+g.type+" for "+V.compression);switch(H){case b.Float:g.getter=q,g.inputSize=4;break;case b.HalfFloat:g.getter=W,g.inputSize=4}}g.blockCount=g.height/g.scanlineBlockSize;for(let U=0;U<g.blockCount;U++)a(n,O);const c=g.width*g.height*g.outputChannels;switch(H){case b.Float:g.byteArray=new Float32Array(c),g.textureType=1,x&&g.byteArray.fill(1,0,c);break;case b.HalfFloat:g.byteArray=new Uint16Array(c),g.textureType=2,x&&g.byteArray.fill(15360,0,c);break;default:throw new Error("Unsupported type: "+H)}let e=0;for(const U of V.channels)void 0!==g.decodeChannels[U.name]&&(g.channelLineOffsets[U.name]=e*g.width),e+=2*U.pixelType;return g.bytesPerLine=g.width*e,g.outLineWidth=g.width*g.outputChannels,"INCREASING_Y"===V.lineOrder?g.scanOrder=V=>V:g.scanOrder=V=>g.height-1-V,4==g.outputChannels?(g.format=5,g.linearSpace=!0):(g.format=6,g.linearSpace=!1),g}(x,g,f,u.DefaultOutputType);!function(V,n,O,H){const g={value:0};for(let f=0;f<V.height/V.scanlineBlockSize;f++){const x=i(O,H)-n.dataWindow.yMin;V.size=A(O,H),V.lines=x+V.scanlineBlockSize>V.height?V.height-x:V.scanlineBlockSize;const c=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):N(V);H.value+=V.size;for(let O=0;O<V.scanlineBlockSize;O++){const H=f*V.scanlineBlockSize,x=O+V.scanOrder(H);if(x>=V.height)continue;const e=O*V.bytesPerLine,U=(V.height-1-x)*V.outLineWidth;for(let O=0;O<V.channels;O++){const H=n.channels[O].name,f=V.channelLineOffsets[H],x=V.decodeChannels[H];if(void 0!==x){g.value=e+f;for(let n=0;n<V.width;n++){const O=U+n*V.outputChannels+x;V.byteArray&&(V.byteArray[O]=V.getter(c,g))}}}}}}(c,x,g,f);O(x.dataWindow.xMax-x.dataWindow.xMin+1,x.dataWindow.yMax-x.dataWindow.yMin+1,n.generateMipMaps,!1,(()=>{const V=n.getEngine();n.format=x.format,n.type=c.textureType,n.invertY=!1,n._gammaSpace=!x.linearSpace,c.byteArray&&V._uploadDataToTextureDirectly(n,c.byteArray,0,0,void 0,!0)}))}}}}]);