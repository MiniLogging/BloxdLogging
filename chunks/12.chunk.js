"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12817:(N,q,R)=>{R.r(q),R.d(q,{_DDSTextureLoader:()=>B});var z=R(11680),v=R(11699);class B{constructor(){this.supportCascades=!0}loadCubeData(N,q,R,B){const F=q.getEngine();let S,A=!1,y=1e3;if(Array.isArray(N))for(let z=0;z<N.length;z++){const R=N[z];S=v.b.GetDDSInfo(R),q.width=S.width,q.height=S.height,A=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&q.generateMipMaps,F._unpackFlipY(S.isCompressed),v.b.UploadDDSLevels(F,q,R,S,A,6,-1,z),S.isFourCC||1!==S.mipmapCount?y=S.mipmapCount-1:F.generateMipMapsForCubemap(q)}else{const B=N;S=v.b.GetDDSInfo(B),q.width=S.width,q.height=S.height,R&&(S.sphericalPolynomial=new z.d),A=(S.isRGB||S.isLuminance||S.mipmapCount>1)&&q.generateMipMaps,F._unpackFlipY(S.isCompressed),v.b.UploadDDSLevels(F,q,B,S,A,6),S.isFourCC||1!==S.mipmapCount?y=S.mipmapCount-1:F.generateMipMapsForCubemap(q,!1)}F._setCubeMapTextureParams(q,A,y),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),B&&B({isDDS:!0,width:q.width,info:S,data:N,texture:q})}loadData(N,q,R){const z=v.b.GetDDSInfo(N),B=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&q.generateMipMaps&&Math.max(z.width,z.height)>>z.mipmapCount-1===1;R(z.width,z.height,B,z.isFourCC,(()=>{v.b.UploadDDSLevels(q.getEngine(),q,N,z,B,1)}))}}}}]);