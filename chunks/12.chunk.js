"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10272:(q,X,Q)=>{Q.r(X),Q.d(X,{_ExrTextureLoader:()=>E});var y=Q(1099),x=Q(1032);const u=65536,H=14,b=65537,D=16384;var a,R;!function(q){q[q.NO_COMPRESSION=0]="NO_COMPRESSION",q[q.RLE_COMPRESSION=1]="RLE_COMPRESSION",q[q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",q[q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",q[q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",q[q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(q){q[q.INCREASING_Y=0]="INCREASING_Y",q[q.DECREASING_Y=1]="DECREASING_Y"}(R||(R={}));const L=function(){const q=new ArrayBuffer(4),X=new Float32Array(q),Q=new Uint32Array(q),y=new Uint32Array(512),x=new Uint32Array(512);for(let D=0;D<256;++D){const q=D-127;q<-27?(y[D]=0,y[256|D]=32768,x[D]=24,x[256|D]=24):q<-14?(y[D]=1024>>-q-14,y[256|D]=1024>>-q-14|32768,x[D]=-q-1,x[256|D]=-q-1):q<=15?(y[D]=q+15<<10,y[256|D]=q+15<<10|32768,x[D]=13,x[256|D]=13):q<128?(y[D]=31744,y[256|D]=64512,x[D]=24,x[256|D]=24):(y[D]=31744,y[256|D]=64512,x[D]=13,x[256|D]=13)}const u=new Uint32Array(2048),H=new Uint32Array(64),b=new Uint32Array(64);for(let D=1;D<1024;++D){let q=D<<13,X=0;for(;0===(8388608&q);)q<<=1,X-=8388608;q&=-8388609,X+=947912704,u[D]=q|X}for(let D=1024;D<2048;++D)u[D]=939524096+(D-1024<<13);for(let D=1;D<31;++D)H[D]=D<<23;H[31]=1199570944,H[32]=2147483648;for(let D=33;D<63;++D)H[D]=2147483648+(D-32<<23);H[63]=3347054592;for(let D=1;D<64;++D)32!==D&&(b[D]=1024);return{floatView:X,uint32View:Q,baseTable:y,shiftTable:x,mantissaTable:u,exponentTable:H,offsetTable:b}}();function f(q,X){const Q=new Uint8Array(q);let y=0;for(;0!=Q[X.value+y];)y+=1;const x=(new TextDecoder).decode(Q.slice(X.value,X.value+y));return X.value=X.value+y+1,x}function k(q,X){const Q=q.getInt32(X.value,!0);return X.value+=4,Q}function j(q,X){const Q=q.getUint32(X.value,!0);return X.value+=4,Q}function I(q,X){const Q=q.getUint8(X.value);return X.value+=1,Q}function d(q,X){const Q=q.getUint16(X.value,!0);return X.value+=2,Q}function e(q,X){const Q=q[X.value];return X.value+=1,Q}function i(q,X){let Q;return Q="getBigInt64"in DataView.prototype?Number(q.getBigInt64(X.value,!0)):q.getUint32(X.value+4,!0)+Number(q.getUint32(X.value,!0)<<32),X.value+=8,Q}function A(q,X){const Q=q.getFloat32(X.value,!0);return X.value+=4,Q}function B(q,X){return function(q){const X=(31744&q)>>10,Q=1023&q;return(q>>15?-1:1)*(X?31===X?Q?NaN:1/0:Math.pow(2,X-15)*(1+Q/1024):Q/1024*6103515625e-14)}(d(q,X))}function w(q,X){return function(q){if(Math.abs(q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");q=(0,x.d)(q,-65504,65504),L.floatView[0]=q;const X=L.uint32View[0],Q=X>>23&511;return L.baseTable[Q]+((8388607&X)>>L.shiftTable[Q])}(A(q,X))}function V(q,X,Q,y){switch(Q){case"string":case"stringvector":case"iccProfile":return function(q,X,Q){const y=(new TextDecoder).decode(new Uint8Array(q).slice(X.value,X.value+Q));return X.value=X.value+Q,y}(q.buffer,X,y);case"chlist":return function(q,X,Q){const y=X.value,x=[];for(;X.value<y+Q-1;){const Q=f(q.buffer,X),y=k(q,X),u=I(q,X);X.value+=3;const H=k(q,X),b=k(q,X);x.push({name:Q,pixelType:y,pLinear:u,xSampling:H,ySampling:b})}return X.value+=1,x}(q,X,y);case"chromaticities":return function(q,X){return{redX:A(q,X),redY:A(q,X),greenX:A(q,X),greenY:A(q,X),blueX:A(q,X),blueY:A(q,X),whiteX:A(q,X),whiteY:A(q,X)}}(q,X);case"compression":return function(q,X){return I(q,X)}(q,X);case"box2i":return function(q,X){return{xMin:k(q,X),yMin:k(q,X),xMax:k(q,X),yMax:k(q,X)}}(q,X);case"lineOrder":return function(q,X){const Q=I(q,X);return R[Q]}(q,X);case"float":return A(q,X);case"v2f":return function(q,X){return[A(q,X),A(q,X)]}(q,X);case"v3f":return function(q,X){return[A(q,X),A(q,X),A(q,X)]}(q,X);case"int":return k(q,X);case"rational":return function(q,X){return[k(q,X),j(q,X)]}(q,X);case"timecode":return function(q,X){return[j(q,X),j(q,X)]}(q,X);case"preview":return X.value+=y,"skipped";default:return void(X.value+=y)}}function W(q){for(let X=1;X<q.length;X++){const Q=q[X-1]+q[X]-128;q[X]=Q}}function v(q,X){let Q=0,y=Math.floor((q.length+1)/2),x=0;const u=q.length-1;for(;!(x>u)&&(X[x++]=q[Q++],!(x>u));)X[x++]=q[y++]}function Z(q,X,Q,y,x){for(;Q<q;)X=X<<8|e(y,x),Q+=8;return{l:X>>(Q-=q)&(1<<q)-1,c:X,lc:Q}}function U(q,X,Q,y){return{c:q=q<<8|e(Q,y),lc:X+=8}}function O(q,X,Q,y,x,u,H,b,D){if(q==X){if(y<8){const q=U(Q,y,x,u);Q=q.c,y=q.lc}let q=Q>>(y-=8);if(q=new Uint8Array([q])[0],b.value+q>D)return null;const X=H[b.value-1];for(;q-- >0;)H[b.value++]=X}else{if(!(b.value<D))return null;H[b.value++]=q}return{c:Q,lc:y}}const g=new Array(59);function P(q,X,Q,y,x,u){const H=X;let D=0,a=0;for(;y<=x;y++){if(H.value-X.value>Q)return;let b=Z(6,D,a,q,H);const R=b.l;if(D=b.c,a=b.lc,u[y]=R,63==R){if(H.value-X.value>Q)throw new Error("Error in HufUnpackEncTable");b=Z(8,D,a,q,H);let R=b.l+6;if(D=b.c,a=b.lc,y+R>x+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)u[y++]=0;y--}else if(R>=59){let q=R-59+2;if(y+q>x+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)u[y++]=0;y--}}!function(q){for(let Q=0;Q<=58;++Q)g[Q]=0;for(let Q=0;Q<b;++Q)g[q[Q]]+=1;let X=0;for(let Q=58;Q>0;--Q){const q=X+g[Q]>>1;g[Q]=X,X=q}for(let Q=0;Q<b;++Q){const X=q[Q];X>0&&(q[Q]=X|g[X]++<<6)}}(u)}function F(q){return 63&q}function l(q){return q>>6}function m(q,X,Q,y,x,u){const a=Q.value,R=j(X,Q),L=j(X,Q);Q.value+=4;const f=j(X,Q);if(Q.value+=4,R<0||R>=b||L<0||L>=b)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(b),I=new Array(D);!function(q){for(let X=0;X<D;X++)q[X]={},q[X].len=0,q[X].lit=0,q[X].p=null}(I);if(P(q,Q,y-(Q.value-a),R,L,k),f>8*(y-(Q.value-a)))throw new Error("Wrong hufUncompress");!function(q,X,Q,y){for(;X<=Q;X++){const Q=l(q[X]),x=F(q[X]);if(Q>>x)throw new Error("Invalid table entry");if(x>H){const q=y[Q>>x-H];if(q.len)throw new Error("Invalid table entry");if(q.lit++,q.p){const X=q.p;q.p=new Array(q.lit);for(let Q=0;Q<q.lit-1;++Q)q.p[Q]=X[Q]}else q.p=new Array(1);q.p[q.lit-1]=X}else if(x){let q=0;for(let u=1<<H-x;u>0;u--){const u=y[(Q<<H-x)+q];if(u.len||u.p)throw new Error("Invalid table entry");u.len=x,u.lit=X,q++}}}}(k,R,L,I),function(q,X,Q,y,x,u,b,D,a){let R=0,L=0;const f=b,k=Math.trunc(y.value+(x+7)/8);for(;y.value<k;){let x=U(R,L,Q,y);for(R=x.c,L=x.lc;L>=H;){const b=X[R>>L-H&16383];if(b.len){L-=b.len;const q=O(b.lit,u,R,L,Q,y,D,a,f);q&&(R=q.c,L=q.lc)}else{if(!b.p)throw new Error("hufDecode issues");let X;for(X=0;X<b.lit;X++){const H=F(q[b.p[X]]);for(;L<H&&y.value<k;)x=U(R,L,Q,y),R=x.c,L=x.lc;if(L>=H&&l(q[b.p[X]])==(R>>L-H&(1<<H)-1)){L-=H;const q=O(b.p[X],u,R,L,Q,y,D,a,f);q&&(R=q.c,L=q.lc);break}}if(X==b.lit)throw new Error("HufDecode issues")}}}const j=8-x&7;for(R>>=j,L-=j;L>0;){const q=X[R<<H-L&16383];if(!q.len)throw new Error("HufDecode issues");{L-=q.len;const X=O(q.lit,u,R,L,Q,y,D,a,f);X&&(R=X.c,L=X.lc)}}}(k,I,q,Q,f,L,u,x,{value:0})}function M(q){return 65535&q}function o(q){const X=M(q);return X>32767?X-65536:X}function Y(q,X){const Q=o(q),y=o(X),x=Q+(1&y)+(y>>1);return{a:x,b:x-y}}function N(q,X){const Q=M(q),y=M(X),x=Q-(y>>1)&65535;return{a:y+x-32768&65535,b:x}}function S(q,X,Q,y,x,u,H){const b=H<16384,D=Q>x?x:Q;let a,R,L=1;for(;L<=D;)L<<=1;for(L>>=1,a=L,L>>=1;L>=1;){R=0;const H=R+u*(x-a),D=u*L,f=u*a,k=y*L,j=y*a;let I,d,e,i;for(;R<=H;R+=f){let x=R;const u=R+y*(Q-a);for(;x<=u;x+=j){const Q=x+k,y=x+D,u=y+k;if(b){let H=Y(q[x+X],q[y+X]);I=H.a,e=H.b,H=Y(q[Q+X],q[u+X]),d=H.a,i=H.b,H=Y(I,d),q[x+X]=H.a,q[Q+X]=H.b,H=Y(e,i),q[y+X]=H.a,q[u+X]=H.b}else{let H=N(q[x+X],q[y+X]);I=H.a,e=H.b,H=N(q[Q+X],q[u+X]),d=H.a,i=H.b,H=N(I,d),q[x+X]=H.a,q[Q+X]=H.b,H=N(e,i),q[y+X]=H.a,q[u+X]=H.b}}if(Q&L){const Q=x+D;let y;y=b?Y(q[x+X],q[Q+X]):N(q[x+X],q[Q+X]),I=y.a,q[Q+X]=y.b,q[x+X]=I}}if(x&L){let x=R;const u=R+y*(Q-a);for(;x<=u;x+=j){const Q=x+k;let y;y=b?Y(q[x+X],q[Q+X]):N(q[x+X],q[Q+X]),I=y.a,q[Q+X]=y.b,q[x+X]=I}}a=L,L>>=1}return R}function c(q){return new DataView(q.array.buffer,q.offset.value,q.size)}function p(q){const X=q.viewer.buffer.slice(q.offset.value,q.offset.value+q.size),Q=new Uint8Array(function(q){let X=q.byteLength;const Q=new Array;let y=0;const x=new DataView(q);for(;X>0;){const q=x.getInt8(y++);if(q<0){const u=-q;X-=u+1;for(let q=0;q<u;q++)Q.push(x.getUint8(y++))}else{const u=q;X-=2;const H=x.getUint8(y++);for(let q=0;q<u+1;q++)Q.push(H)}}return Q}(X)),y=new Uint8Array(Q.length);return W(Q),v(Q,y),new DataView(y.buffer)}function t(q){const X=q.array.slice(q.offset.value,q.offset.value+q.size),Q=fflate.unzlibSync(X),y=new Uint8Array(Q.length);return W(Q),v(Q,y),new DataView(y.buffer)}function z(q){const X=q.array.slice(q.offset.value,q.offset.value+q.size),Q=fflate.unzlibSync(X),y=q.lines*q.channels*q.width,x=1==q.type?new Uint16Array(y):new Uint32Array(y);let u=0,H=0;const b=new Array(4);for(let D=0;D<q.lines;D++)for(let X=0;X<q.channels;X++){let X=0;switch(q.type){case 1:b[0]=u,b[1]=b[0]+q.width,u=b[1]+q.width;for(let y=0;y<q.width;++y){X+=Q[b[0]++]<<8|Q[b[1]++],x[H]=X,H++}break;case 2:b[0]=u,b[1]=b[0]+q.width,b[2]=b[1]+q.width,u=b[2]+q.width;for(let y=0;y<q.width;++y){X+=Q[b[0]++]<<24|Q[b[1]++]<<16|Q[b[2]++]<<8,x[H]=X,H++}}}return new DataView(x.buffer)}function K(q){const X=q.viewer,Q={value:q.offset.value},y=new Uint16Array(q.width*q.scanlineBlockSize*(q.channels*q.type)),x=new Uint8Array(8192);let H=0;const b=new Array(q.channels);for(let u=0;u<q.channels;u++)b[u]={},b[u].start=H,b[u].end=b[u].start,b[u].nx=q.width,b[u].ny=q.lines,b[u].size=q.type,H+=b[u].nx*b[u].ny*b[u].size;const D=d(X,Q),a=d(X,Q);if(a>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(D<=a)for(let u=0;u<a-D+1;u++)x[u+D]=I(X,Q);const R=new Uint16Array(u),L=function(q,X){let Q=0;for(let x=0;x<u;++x)(0==x||q[x>>3]&1<<(7&x))&&(X[Q++]=x);const y=Q-1;for(;Q<u;)X[Q++]=0;return y}(x,R),f=j(X,Q);m(q.array,X,Q,f,y,H);for(let u=0;u<q.channels;++u){const q=b[u];for(let X=0;X<b[u].size;++X)S(y,q.start+X,q.nx,q.size,q.ny,q.nx*q.size,L)}!function(q,X,Q){for(let y=0;y<Q;++y)X[y]=q[X[y]]}(R,y,H);let k=0;const e=new Uint8Array(y.buffer.byteLength);for(let u=0;u<q.lines;u++)for(let X=0;X<q.channels;X++){const q=b[X],Q=q.nx*q.size,x=new Uint8Array(y.buffer,2*q.end,2*Q);e.set(x,k),k+=2*Q,q.end+=Q}return new DataView(e.buffer)}var h,G=Q(1215);!function(q){q[q.Float=0]="Float",q[q.HalfFloat=1]="HalfFloat"}(h||(h={}));class C{}C.DefaultOutputType=h.HalfFloat,C.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class E{constructor(){this.supportCascades=!1}loadCubeData(q,X,Q,y,x){throw".exr not supported in Cube."}async loadData(q,X,Q){const x=new DataView(q.buffer),u={value:0},H=function(q,X){if(20000630!=q.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const Q=q.getUint8(4),x=q.getUint8(5),u={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};X.value=8;const H={};let b=!0;for(;b;){const Q=f(q.buffer,X);if(Q){const x=f(q.buffer,X),u=V(q,X,x,j(q,X));void 0===u?y.b.Warn(`Unknown header attribute type ${x}'.`):H[Q]=u}else b=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:Q,spec:u,...H}}(x,u),b=await async function(q,X,Q,y){const x={size:0,viewer:X,array:new Uint8Array(X.buffer),offset:Q,width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,channels:q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(q.compression){case a.NO_COMPRESSION:x.lines=1,x.uncompress=c;break;case a.RLE_COMPRESSION:x.lines=1,x.uncompress=p;break;case a.ZIPS_COMPRESSION:x.lines=1,x.uncompress=t,await G.f.LoadScriptAsync(C.FFLATEUrl);break;case a.ZIP_COMPRESSION:x.lines=16,x.uncompress=t,await G.f.LoadScriptAsync(C.FFLATEUrl);break;case a.PIZ_COMPRESSION:x.lines=32,x.uncompress=K;break;case a.PXR24_COMPRESSION:x.lines=16,x.uncompress=z,await G.f.LoadScriptAsync(C.FFLATEUrl);break;default:throw new Error(a[q.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const u={};for(const a of q.channels)switch(a.name){case"Y":case"R":case"G":case"B":case"A":u[a.name]=!0,x.type=a.pixelType}let H=!1;if(u.R&&u.G&&u.B)H=!u.A,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else{if(!u.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(y){case h.Float:x.getter=B,x.inputSize=2;break;case h.HalfFloat:x.getter=d,x.inputSize=2}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+q.compression);switch(y){case h.Float:x.getter=A,x.inputSize=4;break;case h.HalfFloat:x.getter=w,x.inputSize=4}}x.blockCount=x.height/x.scanlineBlockSize;for(let a=0;a<x.blockCount;a++)i(X,Q);const b=x.width*x.height*x.outputChannels;switch(y){case h.Float:x.byteArray=new Float32Array(b),x.textureType=1,H&&x.byteArray.fill(1,0,b);break;case h.HalfFloat:x.byteArray=new Uint16Array(b),x.textureType=2,H&&x.byteArray.fill(15360,0,b);break;default:throw new Error("Unsupported type: "+y)}let D=0;for(const a of q.channels)void 0!==x.decodeChannels[a.name]&&(x.channelLineOffsets[a.name]=D*x.width),D+=2*a.pixelType;return x.bytesPerLine=x.width*D,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===q.lineOrder?x.scanOrder=q=>q:x.scanOrder=q=>x.height-1-q,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}(H,x,u,C.DefaultOutputType);!function(q,X,Q,y){const x={value:0};for(let u=0;u<q.height/q.scanlineBlockSize;u++){const H=k(Q,y)-X.dataWindow.yMin;q.size=j(Q,y),q.lines=H+q.scanlineBlockSize>q.height?q.height-H:q.scanlineBlockSize;const b=q.size<q.lines*q.bytesPerLine&&q.uncompress?q.uncompress(q):c(q);y.value+=q.size;for(let Q=0;Q<q.scanlineBlockSize;Q++){const y=u*q.scanlineBlockSize,H=Q+q.scanOrder(y);if(H>=q.height)continue;const D=Q*q.bytesPerLine,a=(q.height-1-H)*q.outLineWidth;for(let Q=0;Q<q.channels;Q++){const y=X.channels[Q].name,u=q.channelLineOffsets[y],H=q.decodeChannels[y];if(void 0!==H){x.value=D+u;for(let X=0;X<q.width;X++){const Q=a+X*q.outputChannels+H;q.byteArray&&(q.byteArray[Q]=q.getter(b,x))}}}}}}(b,H,x,u);Q(H.dataWindow.xMax-H.dataWindow.xMin+1,H.dataWindow.yMax-H.dataWindow.yMin+1,X.generateMipMaps,!1,(()=>{const q=X.getEngine();X.format=H.format,X.type=b.textureType,X.invertY=!1,X._gammaSpace=!H.linearSpace,b.byteArray&&q._uploadDataToTextureDirectly(X,b.byteArray,0,0,void 0,!0)}))}}}}]);