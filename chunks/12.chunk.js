"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{13090:(H,c,y)=>{y.r(c),y.d(c,{_DDSTextureLoader:()=>P});var Z=y(11600),F=y(11625);class P{constructor(){this.supportCascades=!0}loadCubeData(H,c,y,P){const S=c.getEngine();let n,O=!1,a=1e3;if(Array.isArray(H))for(let Z=0;Z<H.length;Z++){const y=H[Z];n=F.c.GetDDSInfo(y),c.width=n.width,c.height=n.height,O=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&c.generateMipMaps,S._unpackFlipY(n.isCompressed),F.c.UploadDDSLevels(S,c,y,n,O,6,-1,Z),n.isFourCC||1!==n.mipmapCount?a=n.mipmapCount-1:S.generateMipMapsForCubemap(c)}else{const P=H;n=F.c.GetDDSInfo(P),c.width=n.width,c.height=n.height,y&&(n.sphericalPolynomial=new Z.f),O=(n.isRGB||n.isLuminance||n.mipmapCount>1)&&c.generateMipMaps,S._unpackFlipY(n.isCompressed),F.c.UploadDDSLevels(S,c,P,n,O,6),n.isFourCC||1!==n.mipmapCount?a=n.mipmapCount-1:S.generateMipMapsForCubemap(c,!1)}S._setCubeMapTextureParams(c,O,a),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),P&&P({isDDS:!0,width:c.width,info:n,data:H,texture:c})}loadData(H,c,y){const Z=F.c.GetDDSInfo(H),P=(Z.isRGB||Z.isLuminance||Z.mipmapCount>1)&&c.generateMipMaps&&Math.max(Z.width,Z.height)>>Z.mipmapCount-1===1;y(Z.width,Z.height,P,Z.isFourCC,(()=>{F.c.UploadDDSLevels(c.getEngine(),c,H,Z,P,1)}))}}}}]);