"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10291:(N,Z,d)=>{d.r(Z),d.d(Z,{_ExrTextureLoader:()=>u});var X=d(1051),I=d(994);const m=65536,z=14,w=65537,S=16384;var e,j;!function(N){N[N.NO_COMPRESSION=0]="NO_COMPRESSION",N[N.RLE_COMPRESSION=1]="RLE_COMPRESSION",N[N.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",N[N.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",N[N.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",N[N.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(e||(e={})),function(N){N[N.INCREASING_Y=0]="INCREASING_Y",N[N.DECREASING_Y=1]="DECREASING_Y"}(j||(j={}));const B=function(){const N=new ArrayBuffer(4),Z=new Float32Array(N),d=new Uint32Array(N),X=new Uint32Array(512),I=new Uint32Array(512);for(let S=0;S<256;++S){const N=S-127;N<-27?(X[S]=0,X[256|S]=32768,I[S]=24,I[256|S]=24):N<-14?(X[S]=1024>>-N-14,X[256|S]=1024>>-N-14|32768,I[S]=-N-1,I[256|S]=-N-1):N<=15?(X[S]=N+15<<10,X[256|S]=N+15<<10|32768,I[S]=13,I[256|S]=13):N<128?(X[S]=31744,X[256|S]=64512,I[S]=24,I[256|S]=24):(X[S]=31744,X[256|S]=64512,I[S]=13,I[256|S]=13)}const m=new Uint32Array(2048),z=new Uint32Array(64),w=new Uint32Array(64);for(let S=1;S<1024;++S){let N=S<<13,Z=0;for(;0===(8388608&N);)N<<=1,Z-=8388608;N&=-8388609,Z+=947912704,m[S]=N|Z}for(let S=1024;S<2048;++S)m[S]=939524096+(S-1024<<13);for(let S=1;S<31;++S)z[S]=S<<23;z[31]=1199570944,z[32]=2147483648;for(let S=33;S<63;++S)z[S]=2147483648+(S-32<<23);z[63]=3347054592;for(let S=1;S<64;++S)32!==S&&(w[S]=1024);return{floatView:Z,uint32View:d,baseTable:X,shiftTable:I,mantissaTable:m,exponentTable:z,offsetTable:w}}();function D(N,Z){const d=new Uint8Array(N);let X=0;for(;0!=d[Z.value+X];)X+=1;const I=(new TextDecoder).decode(d.slice(Z.value,Z.value+X));return Z.value=Z.value+X+1,I}function v(N,Z){const d=N.getInt32(Z.value,!0);return Z.value+=4,d}function T(N,Z){const d=N.getUint32(Z.value,!0);return Z.value+=4,d}function k(N,Z){const d=N.getUint8(Z.value);return Z.value+=1,d}function h(N,Z){const d=N.getUint16(Z.value,!0);return Z.value+=2,d}function U(N,Z){const d=N[Z.value];return Z.value+=1,d}function C(N,Z){let d;return d="getBigInt64"in DataView.prototype?Number(N.getBigInt64(Z.value,!0)):N.getUint32(Z.value+4,!0)+Number(N.getUint32(Z.value,!0)<<32),Z.value+=8,d}function M(N,Z){const d=N.getFloat32(Z.value,!0);return Z.value+=4,d}function Q(N,Z){return function(N){const Z=(31744&N)>>10,d=1023&N;return(N>>15?-1:1)*(Z?31===Z?d?NaN:1/0:Math.pow(2,Z-15)*(1+d/1024):d/1024*6103515625e-14)}(h(N,Z))}function A(N,Z){return function(N){if(Math.abs(N)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");N=(0,I.e)(N,-65504,65504),B.floatView[0]=N;const Z=B.uint32View[0],d=Z>>23&511;return B.baseTable[d]+((8388607&Z)>>B.shiftTable[d])}(M(N,Z))}function n(N,Z,d,X){switch(d){case"string":case"stringvector":case"iccProfile":return function(N,Z,d){const X=(new TextDecoder).decode(new Uint8Array(N).slice(Z.value,Z.value+d));return Z.value=Z.value+d,X}(N.buffer,Z,X);case"chlist":return function(N,Z,d){const X=Z.value,I=[];for(;Z.value<X+d-1;){const d=D(N.buffer,Z),X=v(N,Z),m=k(N,Z);Z.value+=3;const z=v(N,Z),w=v(N,Z);I.push({name:d,pixelType:X,pLinear:m,xSampling:z,ySampling:w})}return Z.value+=1,I}(N,Z,X);case"chromaticities":return function(N,Z){return{redX:M(N,Z),redY:M(N,Z),greenX:M(N,Z),greenY:M(N,Z),blueX:M(N,Z),blueY:M(N,Z),whiteX:M(N,Z),whiteY:M(N,Z)}}(N,Z);case"compression":return function(N,Z){return k(N,Z)}(N,Z);case"box2i":return function(N,Z){return{xMin:v(N,Z),yMin:v(N,Z),xMax:v(N,Z),yMax:v(N,Z)}}(N,Z);case"lineOrder":return function(N,Z){const d=k(N,Z);return j[d]}(N,Z);case"float":return M(N,Z);case"v2f":return function(N,Z){return[M(N,Z),M(N,Z)]}(N,Z);case"v3f":return function(N,Z){return[M(N,Z),M(N,Z),M(N,Z)]}(N,Z);case"int":return v(N,Z);case"rational":return function(N,Z){return[v(N,Z),T(N,Z)]}(N,Z);case"timecode":return function(N,Z){return[T(N,Z),T(N,Z)]}(N,Z);case"preview":return Z.value+=X,"skipped";default:return void(Z.value+=X)}}function g(N){for(let Z=1;Z<N.length;Z++){const d=N[Z-1]+N[Z]-128;N[Z]=d}}function E(N,Z){let d=0,X=Math.floor((N.length+1)/2),I=0;const m=N.length-1;for(;!(I>m)&&(Z[I++]=N[d++],!(I>m));)Z[I++]=N[X++]}function V(N,Z,d,X,I){for(;d<N;)Z=Z<<8|U(X,I),d+=8;return{l:Z>>(d-=N)&(1<<N)-1,c:Z,lc:d}}function O(N,Z,d,X){return{c:N=N<<8|U(d,X),lc:Z+=8}}function K(N,Z,d,X,I,m,z,w,S){if(N==Z){if(X<8){const N=O(d,X,I,m);d=N.c,X=N.lc}let N=d>>(X-=8);if(N=new Uint8Array([N])[0],w.value+N>S)return null;const Z=z[w.value-1];for(;N-- >0;)z[w.value++]=Z}else{if(!(w.value<S))return null;z[w.value++]=N}return{c:d,lc:X}}const r=new Array(59);function P(N,Z,d,X,I,m){const z=Z;let S=0,e=0;for(;X<=I;X++){if(z.value-Z.value>d)return;let w=V(6,S,e,N,z);const j=w.l;if(S=w.c,e=w.lc,m[X]=j,63==j){if(z.value-Z.value>d)throw new Error("Error in HufUnpackEncTable");w=V(8,S,e,N,z);let j=w.l+6;if(S=w.c,e=w.lc,X+j>I+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)m[X++]=0;X--}else if(j>=59){let N=j-59+2;if(X+N>I+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)m[X++]=0;X--}}!function(N){for(let d=0;d<=58;++d)r[d]=0;for(let d=0;d<w;++d)r[N[d]]+=1;let Z=0;for(let d=58;d>0;--d){const N=Z+r[d]>>1;r[d]=Z,Z=N}for(let d=0;d<w;++d){const Z=N[d];Z>0&&(N[d]=Z|r[Z]++<<6)}}(m)}function W(N){return 63&N}function b(N){return N>>6}function J(N,Z,d,X,I,m){const e=d.value,j=T(Z,d),B=T(Z,d);d.value+=4;const D=T(Z,d);if(d.value+=4,j<0||j>=w||B<0||B>=w)throw new Error("Wrong HUF_ENCSIZE");const v=new Array(w),k=new Array(S);!function(N){for(let Z=0;Z<S;Z++)N[Z]={},N[Z].len=0,N[Z].lit=0,N[Z].p=null}(k);if(P(N,d,X-(d.value-e),j,B,v),D>8*(X-(d.value-e)))throw new Error("Wrong hufUncompress");!function(N,Z,d,X){for(;Z<=d;Z++){const d=b(N[Z]),I=W(N[Z]);if(d>>I)throw new Error("Invalid table entry");if(I>z){const N=X[d>>I-z];if(N.len)throw new Error("Invalid table entry");if(N.lit++,N.p){const Z=N.p;N.p=new Array(N.lit);for(let d=0;d<N.lit-1;++d)N.p[d]=Z[d]}else N.p=new Array(1);N.p[N.lit-1]=Z}else if(I){let N=0;for(let m=1<<z-I;m>0;m--){const m=X[(d<<z-I)+N];if(m.len||m.p)throw new Error("Invalid table entry");m.len=I,m.lit=Z,N++}}}}(v,j,B,k),function(N,Z,d,X,I,m,w,S,e){let j=0,B=0;const D=w,v=Math.trunc(X.value+(I+7)/8);for(;X.value<v;){let I=O(j,B,d,X);for(j=I.c,B=I.lc;B>=z;){const w=Z[j>>B-z&16383];if(w.len){B-=w.len;const N=K(w.lit,m,j,B,d,X,S,e,D);N&&(j=N.c,B=N.lc)}else{if(!w.p)throw new Error("hufDecode issues");let Z;for(Z=0;Z<w.lit;Z++){const z=W(N[w.p[Z]]);for(;B<z&&X.value<v;)I=O(j,B,d,X),j=I.c,B=I.lc;if(B>=z&&b(N[w.p[Z]])==(j>>B-z&(1<<z)-1)){B-=z;const N=K(w.p[Z],m,j,B,d,X,S,e,D);N&&(j=N.c,B=N.lc);break}}if(Z==w.lit)throw new Error("HufDecode issues")}}}const T=8-I&7;for(j>>=T,B-=T;B>0;){const N=Z[j<<z-B&16383];if(!N.len)throw new Error("HufDecode issues");{B-=N.len;const Z=K(N.lit,m,j,B,d,X,S,e,D);Z&&(j=Z.c,B=Z.lc)}}}(v,k,N,d,D,B,m,I,{value:0})}function F(N){return 65535&N}function G(N){const Z=F(N);return Z>32767?Z-65536:Z}function x(N,Z){const d=G(N),X=G(Z),I=d+(1&X)+(X>>1);return{a:I,b:I-X}}function t(N,Z){const d=F(N),X=F(Z),I=d-(X>>1)&65535;return{a:X+I-32768&65535,b:I}}function q(N,Z,d,X,I,m,z){const w=z<16384,S=d>I?I:d;let e,j,B=1;for(;B<=S;)B<<=1;for(B>>=1,e=B,B>>=1;B>=1;){j=0;const z=j+m*(I-e),S=m*B,D=m*e,v=X*B,T=X*e;let k,h,U,C;for(;j<=z;j+=D){let I=j;const m=j+X*(d-e);for(;I<=m;I+=T){const d=I+v,X=I+S,m=X+v;if(w){let z=x(N[I+Z],N[X+Z]);k=z.a,U=z.b,z=x(N[d+Z],N[m+Z]),h=z.a,C=z.b,z=x(k,h),N[I+Z]=z.a,N[d+Z]=z.b,z=x(U,C),N[X+Z]=z.a,N[m+Z]=z.b}else{let z=t(N[I+Z],N[X+Z]);k=z.a,U=z.b,z=t(N[d+Z],N[m+Z]),h=z.a,C=z.b,z=t(k,h),N[I+Z]=z.a,N[d+Z]=z.b,z=t(U,C),N[X+Z]=z.a,N[m+Z]=z.b}}if(d&B){const d=I+S;let X;X=w?x(N[I+Z],N[d+Z]):t(N[I+Z],N[d+Z]),k=X.a,N[d+Z]=X.b,N[I+Z]=k}}if(I&B){let I=j;const m=j+X*(d-e);for(;I<=m;I+=T){const d=I+v;let X;X=w?x(N[I+Z],N[d+Z]):t(N[I+Z],N[d+Z]),k=X.a,N[d+Z]=X.b,N[I+Z]=k}}e=B,B>>=1}return j}function Y(N){return new DataView(N.array.buffer,N.offset.value,N.size)}function s(N){const Z=N.viewer.buffer.slice(N.offset.value,N.offset.value+N.size),d=new Uint8Array(function(N){let Z=N.byteLength;const d=new Array;let X=0;const I=new DataView(N);for(;Z>0;){const N=I.getInt8(X++);if(N<0){const m=-N;Z-=m+1;for(let N=0;N<m;N++)d.push(I.getUint8(X++))}else{const m=N;Z-=2;const z=I.getUint8(X++);for(let N=0;N<m+1;N++)d.push(z)}}return d}(Z)),X=new Uint8Array(d.length);return g(d),E(d,X),new DataView(X.buffer)}function L(N){const Z=N.array.slice(N.offset.value,N.offset.value+N.size),d=fflate.unzlibSync(Z),X=new Uint8Array(d.length);return g(d),E(d,X),new DataView(X.buffer)}function H(N){const Z=N.array.slice(N.offset.value,N.offset.value+N.size),d=fflate.unzlibSync(Z),X=N.lines*N.channels*N.width,I=1==N.type?new Uint16Array(X):new Uint32Array(X);let m=0,z=0;const w=new Array(4);for(let S=0;S<N.lines;S++)for(let Z=0;Z<N.channels;Z++){let Z=0;switch(N.type){case 1:w[0]=m,w[1]=w[0]+N.width,m=w[1]+N.width;for(let X=0;X<N.width;++X){Z+=d[w[0]++]<<8|d[w[1]++],I[z]=Z,z++}break;case 2:w[0]=m,w[1]=w[0]+N.width,w[2]=w[1]+N.width,m=w[2]+N.width;for(let X=0;X<N.width;++X){Z+=d[w[0]++]<<24|d[w[1]++]<<16|d[w[2]++]<<8,I[z]=Z,z++}}}return new DataView(I.buffer)}function i(N){const Z=N.viewer,d={value:N.offset.value},X=new Uint16Array(N.width*N.scanlineBlockSize*(N.channels*N.type)),I=new Uint8Array(8192);let z=0;const w=new Array(N.channels);for(let m=0;m<N.channels;m++)w[m]={},w[m].start=z,w[m].end=w[m].start,w[m].nx=N.width,w[m].ny=N.lines,w[m].size=N.type,z+=w[m].nx*w[m].ny*w[m].size;const S=h(Z,d),e=h(Z,d);if(e>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(S<=e)for(let m=0;m<e-S+1;m++)I[m+S]=k(Z,d);const j=new Uint16Array(m),B=function(N,Z){let d=0;for(let I=0;I<m;++I)(0==I||N[I>>3]&1<<(7&I))&&(Z[d++]=I);const X=d-1;for(;d<m;)Z[d++]=0;return X}(I,j),D=T(Z,d);J(N.array,Z,d,D,X,z);for(let m=0;m<N.channels;++m){const N=w[m];for(let Z=0;Z<w[m].size;++Z)q(X,N.start+Z,N.nx,N.size,N.ny,N.nx*N.size,B)}!function(N,Z,d){for(let X=0;X<d;++X)Z[X]=N[Z[X]]}(j,X,z);let v=0;const U=new Uint8Array(X.buffer.byteLength);for(let m=0;m<N.lines;m++)for(let Z=0;Z<N.channels;Z++){const N=w[Z],d=N.nx*N.size,I=new Uint8Array(X.buffer,2*N.end,2*d);U.set(I,v),v+=2*d,N.end+=d}return new DataView(U.buffer)}var p,y=d(1133);!function(N){N[N.Float=0]="Float",N[N.HalfFloat=1]="HalfFloat"}(p||(p={}));class l{}l.DefaultOutputType=p.HalfFloat,l.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class u{constructor(){this.supportCascades=!1}loadCubeData(N,Z,d,X,I){throw".exr not supported in Cube."}async loadData(N,Z,d){const I=new DataView(N.buffer),m={value:0},z=function(N,Z){if(20000630!=N.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const d=N.getUint8(4),I=N.getUint8(5),m={singleTile:!!(2&I),longName:!!(4&I),deepFormat:!!(8&I),multiPart:!!(16&I)};Z.value=8;const z={};let w=!0;for(;w;){const d=D(N.buffer,Z);if(d){const I=D(N.buffer,Z),m=n(N,Z,I,T(N,Z));void 0===m?X.e.Warn(`Unknown header attribute type ${I}'.`):z[d]=m}else w=!1}if(0!=(-5&I))throw new Error("Unsupported file format");return{version:d,spec:m,...z}}(I,m),w=await async function(N,Z,d,X){const I={size:0,viewer:Z,array:new Uint8Array(Z.buffer),offset:d,width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,channels:N.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(N.compression){case e.NO_COMPRESSION:I.lines=1,I.uncompress=Y;break;case e.RLE_COMPRESSION:I.lines=1,I.uncompress=s;break;case e.ZIPS_COMPRESSION:I.lines=1,I.uncompress=L,await y.g.LoadScriptAsync(l.FFLATEUrl);break;case e.ZIP_COMPRESSION:I.lines=16,I.uncompress=L,await y.g.LoadScriptAsync(l.FFLATEUrl);break;case e.PIZ_COMPRESSION:I.lines=32,I.uncompress=i;break;case e.PXR24_COMPRESSION:I.lines=16,I.uncompress=H,await y.g.LoadScriptAsync(l.FFLATEUrl);break;default:throw new Error(e[N.compression]+" is unsupported")}I.scanlineBlockSize=I.lines;const m={};for(const e of N.channels)switch(e.name){case"Y":case"R":case"G":case"B":case"A":m[e.name]=!0,I.type=e.pixelType}let z=!1;if(m.R&&m.G&&m.B)z=!m.A,I.outputChannels=4,I.decodeChannels={R:0,G:1,B:2,A:3};else{if(!m.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");I.outputChannels=1,I.decodeChannels={Y:0}}if(1===I.type)switch(X){case p.Float:I.getter=Q,I.inputSize=2;break;case p.HalfFloat:I.getter=h,I.inputSize=2}else{if(2!==I.type)throw new Error("Unsupported pixelType "+I.type+" for "+N.compression);switch(X){case p.Float:I.getter=M,I.inputSize=4;break;case p.HalfFloat:I.getter=A,I.inputSize=4}}I.blockCount=I.height/I.scanlineBlockSize;for(let e=0;e<I.blockCount;e++)C(Z,d);const w=I.width*I.height*I.outputChannels;switch(X){case p.Float:I.byteArray=new Float32Array(w),I.textureType=1,z&&I.byteArray.fill(1,0,w);break;case p.HalfFloat:I.byteArray=new Uint16Array(w),I.textureType=2,z&&I.byteArray.fill(15360,0,w);break;default:throw new Error("Unsupported type: "+X)}let S=0;for(const e of N.channels)void 0!==I.decodeChannels[e.name]&&(I.channelLineOffsets[e.name]=S*I.width),S+=2*e.pixelType;return I.bytesPerLine=I.width*S,I.outLineWidth=I.width*I.outputChannels,"INCREASING_Y"===N.lineOrder?I.scanOrder=N=>N:I.scanOrder=N=>I.height-1-N,4==I.outputChannels?(I.format=5,I.linearSpace=!0):(I.format=6,I.linearSpace=!1),I}(z,I,m,l.DefaultOutputType);!function(N,Z,d,X){const I={value:0};for(let m=0;m<N.height/N.scanlineBlockSize;m++){const z=v(d,X)-Z.dataWindow.yMin;N.size=T(d,X),N.lines=z+N.scanlineBlockSize>N.height?N.height-z:N.scanlineBlockSize;const w=N.size<N.lines*N.bytesPerLine&&N.uncompress?N.uncompress(N):Y(N);X.value+=N.size;for(let d=0;d<N.scanlineBlockSize;d++){const X=m*N.scanlineBlockSize,z=d+N.scanOrder(X);if(z>=N.height)continue;const S=d*N.bytesPerLine,e=(N.height-1-z)*N.outLineWidth;for(let d=0;d<N.channels;d++){const X=Z.channels[d].name,m=N.channelLineOffsets[X],z=N.decodeChannels[X];if(void 0!==z){I.value=S+m;for(let Z=0;Z<N.width;Z++){const d=e+Z*N.outputChannels+z;N.byteArray&&(N.byteArray[d]=N.getter(w,I))}}}}}}(w,z,I,m);d(z.dataWindow.xMax-z.dataWindow.xMin+1,z.dataWindow.yMax-z.dataWindow.yMin+1,Z.generateMipMaps,!1,(()=>{const N=Z.getEngine();Z.format=z.format,Z.type=w.textureType,Z.invertY=!1,Z._gammaSpace=!z.linearSpace,w.byteArray&&N._uploadDataToTextureDirectly(Z,w.byteArray,0,0,void 0,!0)}))}}}}]);