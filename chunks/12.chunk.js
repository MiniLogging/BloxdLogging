"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10709:(C,M,x)=>{x.r(M),x.d(M,{_ExrTextureLoader:()=>Y});var f=x(1078),T=x(1015);const z=65536,s=14,S=65537,m=16384;var Q,V;!function(C){C[C.NO_COMPRESSION=0]="NO_COMPRESSION",C[C.RLE_COMPRESSION=1]="RLE_COMPRESSION",C[C.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",C[C.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",C[C.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",C[C.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(Q||(Q={})),function(C){C[C.INCREASING_Y=0]="INCREASING_Y",C[C.DECREASING_Y=1]="DECREASING_Y"}(V||(V={}));const y=function(){const C=new ArrayBuffer(4),M=new Float32Array(C),x=new Uint32Array(C),f=new Uint32Array(512),T=new Uint32Array(512);for(let m=0;m<256;++m){const C=m-127;C<-27?(f[m]=0,f[256|m]=32768,T[m]=24,T[256|m]=24):C<-14?(f[m]=1024>>-C-14,f[256|m]=1024>>-C-14|32768,T[m]=-C-1,T[256|m]=-C-1):C<=15?(f[m]=C+15<<10,f[256|m]=C+15<<10|32768,T[m]=13,T[256|m]=13):C<128?(f[m]=31744,f[256|m]=64512,T[m]=24,T[256|m]=24):(f[m]=31744,f[256|m]=64512,T[m]=13,T[256|m]=13)}const z=new Uint32Array(2048),s=new Uint32Array(64),S=new Uint32Array(64);for(let m=1;m<1024;++m){let C=m<<13,M=0;for(;0===(8388608&C);)C<<=1,M-=8388608;C&=-8388609,M+=947912704,z[m]=C|M}for(let m=1024;m<2048;++m)z[m]=939524096+(m-1024<<13);for(let m=1;m<31;++m)s[m]=m<<23;s[31]=1199570944,s[32]=2147483648;for(let m=33;m<63;++m)s[m]=2147483648+(m-32<<23);s[63]=3347054592;for(let m=1;m<64;++m)32!==m&&(S[m]=1024);return{floatView:M,uint32View:x,baseTable:f,shiftTable:T,mantissaTable:z,exponentTable:s,offsetTable:S}}();function U(C,M){const x=new Uint8Array(C);let f=0;for(;0!=x[M.value+f];)f+=1;const T=(new TextDecoder).decode(x.slice(M.value,M.value+f));return M.value=M.value+f+1,T}function O(C,M){const x=C.getInt32(M.value,!0);return M.value+=4,x}function d(C,M){const x=C.getUint32(M.value,!0);return M.value+=4,x}function D(C,M){const x=C.getUint8(M.value);return M.value+=1,x}function o(C,M){const x=C.getUint16(M.value,!0);return M.value+=2,x}function L(C,M){const x=C[M.value];return M.value+=1,x}function t(C,M){let x;return x="getBigInt64"in DataView.prototype?Number(C.getBigInt64(M.value,!0)):C.getUint32(M.value+4,!0)+Number(C.getUint32(M.value,!0)<<32),M.value+=8,x}function A(C,M){const x=C.getFloat32(M.value,!0);return M.value+=4,x}function H(C,M){return function(C){const M=(31744&C)>>10,x=1023&C;return(C>>15?-1:1)*(M?31===M?x?NaN:1/0:Math.pow(2,M-15)*(1+x/1024):x/1024*6103515625e-14)}(o(C,M))}function j(C,M){return function(C){if(Math.abs(C)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");C=(0,T.d)(C,-65504,65504),y.floatView[0]=C;const M=y.uint32View[0],x=M>>23&511;return y.baseTable[x]+((8388607&M)>>y.shiftTable[x])}(A(C,M))}function b(C,M,x,f){switch(x){case"string":case"stringvector":case"iccProfile":return function(C,M,x){const f=(new TextDecoder).decode(new Uint8Array(C).slice(M.value,M.value+x));return M.value=M.value+x,f}(C.buffer,M,f);case"chlist":return function(C,M,x){const f=M.value,T=[];for(;M.value<f+x-1;){const x=U(C.buffer,M),f=O(C,M),z=D(C,M);M.value+=3;const s=O(C,M),S=O(C,M);T.push({name:x,pixelType:f,pLinear:z,xSampling:s,ySampling:S})}return M.value+=1,T}(C,M,f);case"chromaticities":return function(C,M){return{redX:A(C,M),redY:A(C,M),greenX:A(C,M),greenY:A(C,M),blueX:A(C,M),blueY:A(C,M),whiteX:A(C,M),whiteY:A(C,M)}}(C,M);case"compression":return function(C,M){return D(C,M)}(C,M);case"box2i":return function(C,M){return{xMin:O(C,M),yMin:O(C,M),xMax:O(C,M),yMax:O(C,M)}}(C,M);case"lineOrder":return function(C,M){const x=D(C,M);return V[x]}(C,M);case"float":return A(C,M);case"v2f":return function(C,M){return[A(C,M),A(C,M)]}(C,M);case"v3f":return function(C,M){return[A(C,M),A(C,M),A(C,M)]}(C,M);case"int":return O(C,M);case"rational":return function(C,M){return[O(C,M),d(C,M)]}(C,M);case"timecode":return function(C,M){return[d(C,M),d(C,M)]}(C,M);case"preview":return M.value+=f,"skipped";default:return void(M.value+=f)}}function R(C){for(let M=1;M<C.length;M++){const x=C[M-1]+C[M]-128;C[M]=x}}function n(C,M){let x=0,f=Math.floor((C.length+1)/2),T=0;const z=C.length-1;for(;!(T>z)&&(M[T++]=C[x++],!(T>z));)M[T++]=C[f++]}function I(C,M,x,f,T){for(;x<C;)M=M<<8|L(f,T),x+=8;return{l:M>>(x-=C)&(1<<C)-1,c:M,lc:x}}function X(C,M,x,f){return{c:C=C<<8|L(x,f),lc:M+=8}}function g(C,M,x,f,T,z,s,S,m){if(C==M){if(f<8){const C=X(x,f,T,z);x=C.c,f=C.lc}let C=x>>(f-=8);if(C=new Uint8Array([C])[0],S.value+C>m)return null;const M=s[S.value-1];for(;C-- >0;)s[S.value++]=M}else{if(!(S.value<m))return null;s[S.value++]=C}return{c:x,lc:f}}const B=new Array(59);function F(C,M,x,f,T,z){const s=M;let m=0,Q=0;for(;f<=T;f++){if(s.value-M.value>x)return;let S=I(6,m,Q,C,s);const V=S.l;if(m=S.c,Q=S.lc,z[f]=V,63==V){if(s.value-M.value>x)throw new Error("Error in HufUnpackEncTable");S=I(8,m,Q,C,s);let V=S.l+6;if(m=S.c,Q=S.lc,f+V>T+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)z[f++]=0;f--}else if(V>=59){let C=V-59+2;if(f+C>T+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)z[f++]=0;f--}}!function(C){for(let x=0;x<=58;++x)B[x]=0;for(let x=0;x<S;++x)B[C[x]]+=1;let M=0;for(let x=58;x>0;--x){const C=M+B[x]>>1;B[x]=M,M=C}for(let x=0;x<S;++x){const M=C[x];M>0&&(C[x]=M|B[M]++<<6)}}(z)}function P(C){return 63&C}function h(C){return C>>6}function c(C,M,x,f,T,z){const Q=x.value,V=d(M,x),y=d(M,x);x.value+=4;const U=d(M,x);if(x.value+=4,V<0||V>=S||y<0||y>=S)throw new Error("Wrong HUF_ENCSIZE");const O=new Array(S),D=new Array(m);!function(C){for(let M=0;M<m;M++)C[M]={},C[M].len=0,C[M].lit=0,C[M].p=null}(D);if(F(C,x,f-(x.value-Q),V,y,O),U>8*(f-(x.value-Q)))throw new Error("Wrong hufUncompress");!function(C,M,x,f){for(;M<=x;M++){const x=h(C[M]),T=P(C[M]);if(x>>T)throw new Error("Invalid table entry");if(T>s){const C=f[x>>T-s];if(C.len)throw new Error("Invalid table entry");if(C.lit++,C.p){const M=C.p;C.p=new Array(C.lit);for(let x=0;x<C.lit-1;++x)C.p[x]=M[x]}else C.p=new Array(1);C.p[C.lit-1]=M}else if(T){let C=0;for(let z=1<<s-T;z>0;z--){const z=f[(x<<s-T)+C];if(z.len||z.p)throw new Error("Invalid table entry");z.len=T,z.lit=M,C++}}}}(O,V,y,D),function(C,M,x,f,T,z,S,m,Q){let V=0,y=0;const U=S,O=Math.trunc(f.value+(T+7)/8);for(;f.value<O;){let T=X(V,y,x,f);for(V=T.c,y=T.lc;y>=s;){const S=M[V>>y-s&16383];if(S.len){y-=S.len;const C=g(S.lit,z,V,y,x,f,m,Q,U);C&&(V=C.c,y=C.lc)}else{if(!S.p)throw new Error("hufDecode issues");let M;for(M=0;M<S.lit;M++){const s=P(C[S.p[M]]);for(;y<s&&f.value<O;)T=X(V,y,x,f),V=T.c,y=T.lc;if(y>=s&&h(C[S.p[M]])==(V>>y-s&(1<<s)-1)){y-=s;const C=g(S.p[M],z,V,y,x,f,m,Q,U);C&&(V=C.c,y=C.lc);break}}if(M==S.lit)throw new Error("HufDecode issues")}}}const d=8-T&7;for(V>>=d,y-=d;y>0;){const C=M[V<<s-y&16383];if(!C.len)throw new Error("HufDecode issues");{y-=C.len;const M=g(C.lit,z,V,y,x,f,m,Q,U);M&&(V=M.c,y=M.lc)}}}(O,D,C,x,U,y,z,T,{value:0})}function q(C){return 65535&C}function i(C){const M=q(C);return M>32767?M-65536:M}function Z(C,M){const x=i(C),f=i(M),T=x+(1&f)+(f>>1);return{a:T,b:T-f}}function E(C,M){const x=q(C),f=q(M),T=x-(f>>1)&65535;return{a:f+T-32768&65535,b:T}}function K(C,M,x,f,T,z,s){const S=s<16384,m=x>T?T:x;let Q,V,y=1;for(;y<=m;)y<<=1;for(y>>=1,Q=y,y>>=1;y>=1;){V=0;const s=V+z*(T-Q),m=z*y,U=z*Q,O=f*y,d=f*Q;let D,o,L,t;for(;V<=s;V+=U){let T=V;const z=V+f*(x-Q);for(;T<=z;T+=d){const x=T+O,f=T+m,z=f+O;if(S){let s=Z(C[T+M],C[f+M]);D=s.a,L=s.b,s=Z(C[x+M],C[z+M]),o=s.a,t=s.b,s=Z(D,o),C[T+M]=s.a,C[x+M]=s.b,s=Z(L,t),C[f+M]=s.a,C[z+M]=s.b}else{let s=E(C[T+M],C[f+M]);D=s.a,L=s.b,s=E(C[x+M],C[z+M]),o=s.a,t=s.b,s=E(D,o),C[T+M]=s.a,C[x+M]=s.b,s=E(L,t),C[f+M]=s.a,C[z+M]=s.b}}if(x&y){const x=T+m;let f;f=S?Z(C[T+M],C[x+M]):E(C[T+M],C[x+M]),D=f.a,C[x+M]=f.b,C[T+M]=D}}if(T&y){let T=V;const z=V+f*(x-Q);for(;T<=z;T+=d){const x=T+O;let f;f=S?Z(C[T+M],C[x+M]):E(C[T+M],C[x+M]),D=f.a,C[x+M]=f.b,C[T+M]=D}}Q=y,y>>=1}return V}function G(C){return new DataView(C.array.buffer,C.offset.value,C.size)}function a(C){const M=C.viewer.buffer.slice(C.offset.value,C.offset.value+C.size),x=new Uint8Array(function(C){let M=C.byteLength;const x=new Array;let f=0;const T=new DataView(C);for(;M>0;){const C=T.getInt8(f++);if(C<0){const z=-C;M-=z+1;for(let C=0;C<z;C++)x.push(T.getUint8(f++))}else{const z=C;M-=2;const s=T.getUint8(f++);for(let C=0;C<z+1;C++)x.push(s)}}return x}(M)),f=new Uint8Array(x.length);return R(x),n(x,f),new DataView(f.buffer)}function J(C){const M=C.array.slice(C.offset.value,C.offset.value+C.size),x=fflate.unzlibSync(M),f=new Uint8Array(x.length);return R(x),n(x,f),new DataView(f.buffer)}function N(C){const M=C.array.slice(C.offset.value,C.offset.value+C.size),x=fflate.unzlibSync(M),f=C.lines*C.channels*C.width,T=1==C.type?new Uint16Array(f):new Uint32Array(f);let z=0,s=0;const S=new Array(4);for(let m=0;m<C.lines;m++)for(let M=0;M<C.channels;M++){let M=0;switch(C.type){case 1:S[0]=z,S[1]=S[0]+C.width,z=S[1]+C.width;for(let f=0;f<C.width;++f){M+=x[S[0]++]<<8|x[S[1]++],T[s]=M,s++}break;case 2:S[0]=z,S[1]=S[0]+C.width,S[2]=S[1]+C.width,z=S[2]+C.width;for(let f=0;f<C.width;++f){M+=x[S[0]++]<<24|x[S[1]++]<<16|x[S[2]++]<<8,T[s]=M,s++}}}return new DataView(T.buffer)}function k(C){const M=C.viewer,x={value:C.offset.value},f=new Uint16Array(C.width*C.scanlineBlockSize*(C.channels*C.type)),T=new Uint8Array(8192);let s=0;const S=new Array(C.channels);for(let z=0;z<C.channels;z++)S[z]={},S[z].start=s,S[z].end=S[z].start,S[z].nx=C.width,S[z].ny=C.lines,S[z].size=C.type,s+=S[z].nx*S[z].ny*S[z].size;const m=o(M,x),Q=o(M,x);if(Q>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(m<=Q)for(let z=0;z<Q-m+1;z++)T[z+m]=D(M,x);const V=new Uint16Array(z),y=function(C,M){let x=0;for(let T=0;T<z;++T)(0==T||C[T>>3]&1<<(7&T))&&(M[x++]=T);const f=x-1;for(;x<z;)M[x++]=0;return f}(T,V),U=d(M,x);c(C.array,M,x,U,f,s);for(let z=0;z<C.channels;++z){const C=S[z];for(let M=0;M<S[z].size;++M)K(f,C.start+M,C.nx,C.size,C.ny,C.nx*C.size,y)}!function(C,M,x){for(let f=0;f<x;++f)M[f]=C[M[f]]}(V,f,s);let O=0;const L=new Uint8Array(f.buffer.byteLength);for(let z=0;z<C.lines;z++)for(let M=0;M<C.channels;M++){const C=S[M],x=C.nx*C.size,T=new Uint8Array(f.buffer,2*C.end,2*x);L.set(T,O),O+=2*x,C.end+=x}return new DataView(L.buffer)}var v,p=x(1192);!function(C){C[C.Float=0]="Float",C[C.HalfFloat=1]="HalfFloat"}(v||(v={}));class u{}u.DefaultOutputType=v.HalfFloat,u.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Y{constructor(){this.supportCascades=!1}loadCubeData(C,M,x,f,T){throw".exr not supported in Cube."}async loadData(C,M,x){const T=new DataView(C.buffer),z={value:0},s=function(C,M){if(20000630!=C.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const x=C.getUint8(4),T=C.getUint8(5),z={singleTile:!!(2&T),longName:!!(4&T),deepFormat:!!(8&T),multiPart:!!(16&T)};M.value=8;const s={};let S=!0;for(;S;){const x=U(C.buffer,M);if(x){const T=U(C.buffer,M),z=b(C,M,T,d(C,M));void 0===z?f.e.Warn(`Unknown header attribute type ${T}'.`):s[x]=z}else S=!1}if(0!=(-5&T))throw new Error("Unsupported file format");return{version:x,spec:z,...s}}(T,z),S=await async function(C,M,x,f){const T={size:0,viewer:M,array:new Uint8Array(M.buffer),offset:x,width:C.dataWindow.xMax-C.dataWindow.xMin+1,height:C.dataWindow.yMax-C.dataWindow.yMin+1,channels:C.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(C.compression){case Q.NO_COMPRESSION:T.lines=1,T.uncompress=G;break;case Q.RLE_COMPRESSION:T.lines=1,T.uncompress=a;break;case Q.ZIPS_COMPRESSION:T.lines=1,T.uncompress=J,await p.i.LoadScriptAsync(u.FFLATEUrl);break;case Q.ZIP_COMPRESSION:T.lines=16,T.uncompress=J,await p.i.LoadScriptAsync(u.FFLATEUrl);break;case Q.PIZ_COMPRESSION:T.lines=32,T.uncompress=k;break;case Q.PXR24_COMPRESSION:T.lines=16,T.uncompress=N,await p.i.LoadScriptAsync(u.FFLATEUrl);break;default:throw new Error(Q[C.compression]+" is unsupported")}T.scanlineBlockSize=T.lines;const z={};for(const Q of C.channels)switch(Q.name){case"Y":case"R":case"G":case"B":case"A":z[Q.name]=!0,T.type=Q.pixelType}let s=!1;if(z.R&&z.G&&z.B)s=!z.A,T.outputChannels=4,T.decodeChannels={R:0,G:1,B:2,A:3};else{if(!z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");T.outputChannels=1,T.decodeChannels={Y:0}}if(1===T.type)switch(f){case v.Float:T.getter=H,T.inputSize=2;break;case v.HalfFloat:T.getter=o,T.inputSize=2}else{if(2!==T.type)throw new Error("Unsupported pixelType "+T.type+" for "+C.compression);switch(f){case v.Float:T.getter=A,T.inputSize=4;break;case v.HalfFloat:T.getter=j,T.inputSize=4}}T.blockCount=T.height/T.scanlineBlockSize;for(let Q=0;Q<T.blockCount;Q++)t(M,x);const S=T.width*T.height*T.outputChannels;switch(f){case v.Float:T.byteArray=new Float32Array(S),T.textureType=1,s&&T.byteArray.fill(1,0,S);break;case v.HalfFloat:T.byteArray=new Uint16Array(S),T.textureType=2,s&&T.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+f)}let m=0;for(const Q of C.channels)void 0!==T.decodeChannels[Q.name]&&(T.channelLineOffsets[Q.name]=m*T.width),m+=2*Q.pixelType;return T.bytesPerLine=T.width*m,T.outLineWidth=T.width*T.outputChannels,"INCREASING_Y"===C.lineOrder?T.scanOrder=C=>C:T.scanOrder=C=>T.height-1-C,4==T.outputChannels?(T.format=5,T.linearSpace=!0):(T.format=6,T.linearSpace=!1),T}(s,T,z,u.DefaultOutputType);!function(C,M,x,f){const T={value:0};for(let z=0;z<C.height/C.scanlineBlockSize;z++){const s=O(x,f)-M.dataWindow.yMin;C.size=d(x,f),C.lines=s+C.scanlineBlockSize>C.height?C.height-s:C.scanlineBlockSize;const S=C.size<C.lines*C.bytesPerLine&&C.uncompress?C.uncompress(C):G(C);f.value+=C.size;for(let x=0;x<C.scanlineBlockSize;x++){const f=z*C.scanlineBlockSize,s=x+C.scanOrder(f);if(s>=C.height)continue;const m=x*C.bytesPerLine,Q=(C.height-1-s)*C.outLineWidth;for(let x=0;x<C.channels;x++){const f=M.channels[x].name,z=C.channelLineOffsets[f],s=C.decodeChannels[f];if(void 0!==s){T.value=m+z;for(let M=0;M<C.width;M++){const x=Q+M*C.outputChannels+s;C.byteArray&&(C.byteArray[x]=C.getter(S,T))}}}}}}(S,s,T,z);x(s.dataWindow.xMax-s.dataWindow.xMin+1,s.dataWindow.yMax-s.dataWindow.yMin+1,M.generateMipMaps,!1,(()=>{const C=M.getEngine();M.format=s.format,M.type=S.textureType,M.invertY=!1,M._gammaSpace=!s.linearSpace,S.byteArray&&C._uploadDataToTextureDirectly(M,S.byteArray,0,0,void 0,!0)}))}}}}]);