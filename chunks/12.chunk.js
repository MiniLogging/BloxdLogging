"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{12601:(z,a,K)=>{K.r(a),K.d(a,{_DDSTextureLoader:()=>m});var v=K(11435),T=K(11455);class m{constructor(){this.supportCascades=!0}loadCubeData(z,a,K,m){const p=a.getEngine();let j,s=!1,M=1e3;if(Array.isArray(z))for(let v=0;v<z.length;v++){const K=z[v];j=T.e.GetDDSInfo(K),a.width=j.width,a.height=j.height,s=(j.isRGB||j.isLuminance||j.mipmapCount>1)&&a.generateMipMaps,p._unpackFlipY(j.isCompressed),T.e.UploadDDSLevels(p,a,K,j,s,6,-1,v),j.isFourCC||1!==j.mipmapCount?M=j.mipmapCount-1:p.generateMipMapsForCubemap(a)}else{const m=z;j=T.e.GetDDSInfo(m),a.width=j.width,a.height=j.height,K&&(j.sphericalPolynomial=new v.f),s=(j.isRGB||j.isLuminance||j.mipmapCount>1)&&a.generateMipMaps,p._unpackFlipY(j.isCompressed),T.e.UploadDDSLevels(p,a,m,j,s,6),j.isFourCC||1!==j.mipmapCount?M=j.mipmapCount-1:p.generateMipMapsForCubemap(a,!1)}p._setCubeMapTextureParams(a,s,M),a.isReady=!0,a.onLoadedObservable.notifyObservers(a),a.onLoadedObservable.clear(),m&&m({isDDS:!0,width:a.width,info:j,data:z,texture:a})}loadData(z,a,K){const v=T.e.GetDDSInfo(z),m=(v.isRGB||v.isLuminance||v.mipmapCount>1)&&a.generateMipMaps&&Math.max(v.width,v.height)>>v.mipmapCount-1===1;K(v.width,v.height,m,v.isFourCC,(()=>{T.e.UploadDDSLevels(a.getEngine(),a,z,v,m,1)}))}}}}]);