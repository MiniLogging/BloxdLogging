"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10393:(R,N,q)=>{q.r(N),q.d(N,{_ExrTextureLoader:()=>B});var w=q(1056),u=q(1001);const M=65536,v=14,G=65537,J=16384;var y,a;!function(R){R[R.NO_COMPRESSION=0]="NO_COMPRESSION",R[R.RLE_COMPRESSION=1]="RLE_COMPRESSION",R[R.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",R[R.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",R[R.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",R[R.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(y||(y={})),function(R){R[R.INCREASING_Y=0]="INCREASING_Y",R[R.DECREASING_Y=1]="DECREASING_Y"}(a||(a={}));const j=function(){const R=new ArrayBuffer(4),N=new Float32Array(R),q=new Uint32Array(R),w=new Uint32Array(512),u=new Uint32Array(512);for(let J=0;J<256;++J){const R=J-127;R<-27?(w[J]=0,w[256|J]=32768,u[J]=24,u[256|J]=24):R<-14?(w[J]=1024>>-R-14,w[256|J]=1024>>-R-14|32768,u[J]=-R-1,u[256|J]=-R-1):R<=15?(w[J]=R+15<<10,w[256|J]=R+15<<10|32768,u[J]=13,u[256|J]=13):R<128?(w[J]=31744,w[256|J]=64512,u[J]=24,u[256|J]=24):(w[J]=31744,w[256|J]=64512,u[J]=13,u[256|J]=13)}const M=new Uint32Array(2048),v=new Uint32Array(64),G=new Uint32Array(64);for(let J=1;J<1024;++J){let R=J<<13,N=0;for(;0===(8388608&R);)R<<=1,N-=8388608;R&=-8388609,N+=947912704,M[J]=R|N}for(let J=1024;J<2048;++J)M[J]=939524096+(J-1024<<13);for(let J=1;J<31;++J)v[J]=J<<23;v[31]=1199570944,v[32]=2147483648;for(let J=33;J<63;++J)v[J]=2147483648+(J-32<<23);v[63]=3347054592;for(let J=1;J<64;++J)32!==J&&(G[J]=1024);return{floatView:N,uint32View:q,baseTable:w,shiftTable:u,mantissaTable:M,exponentTable:v,offsetTable:G}}();function F(R,N){const q=new Uint8Array(R);let w=0;for(;0!=q[N.value+w];)w+=1;const u=(new TextDecoder).decode(q.slice(N.value,N.value+w));return N.value=N.value+w+1,u}function S(R,N){const q=R.getInt32(N.value,!0);return N.value+=4,q}function H(R,N){const q=R.getUint32(N.value,!0);return N.value+=4,q}function W(R,N){const q=R.getUint8(N.value);return N.value+=1,q}function k(R,N){const q=R.getUint16(N.value,!0);return N.value+=2,q}function C(R,N){const q=R[N.value];return N.value+=1,q}function e(R,N){let q;return q="getBigInt64"in DataView.prototype?Number(R.getBigInt64(N.value,!0)):R.getUint32(N.value+4,!0)+Number(R.getUint32(N.value,!0)<<32),N.value+=8,q}function K(R,N){const q=R.getFloat32(N.value,!0);return N.value+=4,q}function r(R,N){return function(R){const N=(31744&R)>>10,q=1023&R;return(R>>15?-1:1)*(N?31===N?q?NaN:1/0:Math.pow(2,N-15)*(1+q/1024):q/1024*6103515625e-14)}(k(R,N))}function Z(R,N){return function(R){if(Math.abs(R)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");R=(0,u.b)(R,-65504,65504),j.floatView[0]=R;const N=j.uint32View[0],q=N>>23&511;return j.baseTable[q]+((8388607&N)>>j.shiftTable[q])}(K(R,N))}function z(R,N,q,w){switch(q){case"string":case"stringvector":case"iccProfile":return function(R,N,q){const w=(new TextDecoder).decode(new Uint8Array(R).slice(N.value,N.value+q));return N.value=N.value+q,w}(R.buffer,N,w);case"chlist":return function(R,N,q){const w=N.value,u=[];for(;N.value<w+q-1;){const q=F(R.buffer,N),w=S(R,N),M=W(R,N);N.value+=3;const v=S(R,N),G=S(R,N);u.push({name:q,pixelType:w,pLinear:M,xSampling:v,ySampling:G})}return N.value+=1,u}(R,N,w);case"chromaticities":return function(R,N){return{redX:K(R,N),redY:K(R,N),greenX:K(R,N),greenY:K(R,N),blueX:K(R,N),blueY:K(R,N),whiteX:K(R,N),whiteY:K(R,N)}}(R,N);case"compression":return function(R,N){return W(R,N)}(R,N);case"box2i":return function(R,N){return{xMin:S(R,N),yMin:S(R,N),xMax:S(R,N),yMax:S(R,N)}}(R,N);case"lineOrder":return function(R,N){const q=W(R,N);return a[q]}(R,N);case"float":return K(R,N);case"v2f":return function(R,N){return[K(R,N),K(R,N)]}(R,N);case"v3f":return function(R,N){return[K(R,N),K(R,N),K(R,N)]}(R,N);case"int":return S(R,N);case"rational":return function(R,N){return[S(R,N),H(R,N)]}(R,N);case"timecode":return function(R,N){return[H(R,N),H(R,N)]}(R,N);case"preview":return N.value+=w,"skipped";default:return void(N.value+=w)}}function d(R){for(let N=1;N<R.length;N++){const q=R[N-1]+R[N]-128;R[N]=q}}function x(R,N){let q=0,w=Math.floor((R.length+1)/2),u=0;const M=R.length-1;for(;!(u>M)&&(N[u++]=R[q++],!(u>M));)N[u++]=R[w++]}function E(R,N,q,w,u){for(;q<R;)N=N<<8|C(w,u),q+=8;return{l:N>>(q-=R)&(1<<R)-1,c:N,lc:q}}function P(R,N,q,w){return{c:R=R<<8|C(q,w),lc:N+=8}}function s(R,N,q,w,u,M,v,G,J){if(R==N){if(w<8){const R=P(q,w,u,M);q=R.c,w=R.lc}let R=q>>(w-=8);if(R=new Uint8Array([R])[0],G.value+R>J)return null;const N=v[G.value-1];for(;R-- >0;)v[G.value++]=N}else{if(!(G.value<J))return null;v[G.value++]=R}return{c:q,lc:w}}const O=new Array(59);function L(R,N,q,w,u,M){const v=N;let J=0,y=0;for(;w<=u;w++){if(v.value-N.value>q)return;let G=E(6,J,y,R,v);const a=G.l;if(J=G.c,y=G.lc,M[w]=a,63==a){if(v.value-N.value>q)throw new Error("Error in HufUnpackEncTable");G=E(8,J,y,R,v);let a=G.l+6;if(J=G.c,y=G.lc,w+a>u+1)throw new Error("Error in HufUnpackEncTable");for(;a--;)M[w++]=0;w--}else if(a>=59){let R=a-59+2;if(w+R>u+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)M[w++]=0;w--}}!function(R){for(let q=0;q<=58;++q)O[q]=0;for(let q=0;q<G;++q)O[R[q]]+=1;let N=0;for(let q=58;q>0;--q){const R=N+O[q]>>1;O[q]=N,N=R}for(let q=0;q<G;++q){const N=R[q];N>0&&(R[q]=N|O[N]++<<6)}}(M)}function m(R){return 63&R}function o(R){return R>>6}function A(R,N,q,w,u,M){const y=q.value,a=H(N,q),j=H(N,q);q.value+=4;const F=H(N,q);if(q.value+=4,a<0||a>=G||j<0||j>=G)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(G),W=new Array(J);!function(R){for(let N=0;N<J;N++)R[N]={},R[N].len=0,R[N].lit=0,R[N].p=null}(W);if(L(R,q,w-(q.value-y),a,j,S),F>8*(w-(q.value-y)))throw new Error("Wrong hufUncompress");!function(R,N,q,w){for(;N<=q;N++){const q=o(R[N]),u=m(R[N]);if(q>>u)throw new Error("Invalid table entry");if(u>v){const R=w[q>>u-v];if(R.len)throw new Error("Invalid table entry");if(R.lit++,R.p){const N=R.p;R.p=new Array(R.lit);for(let q=0;q<R.lit-1;++q)R.p[q]=N[q]}else R.p=new Array(1);R.p[R.lit-1]=N}else if(u){let R=0;for(let M=1<<v-u;M>0;M--){const M=w[(q<<v-u)+R];if(M.len||M.p)throw new Error("Invalid table entry");M.len=u,M.lit=N,R++}}}}(S,a,j,W),function(R,N,q,w,u,M,G,J,y){let a=0,j=0;const F=G,S=Math.trunc(w.value+(u+7)/8);for(;w.value<S;){let u=P(a,j,q,w);for(a=u.c,j=u.lc;j>=v;){const G=N[a>>j-v&16383];if(G.len){j-=G.len;const R=s(G.lit,M,a,j,q,w,J,y,F);R&&(a=R.c,j=R.lc)}else{if(!G.p)throw new Error("hufDecode issues");let N;for(N=0;N<G.lit;N++){const v=m(R[G.p[N]]);for(;j<v&&w.value<S;)u=P(a,j,q,w),a=u.c,j=u.lc;if(j>=v&&o(R[G.p[N]])==(a>>j-v&(1<<v)-1)){j-=v;const R=s(G.p[N],M,a,j,q,w,J,y,F);R&&(a=R.c,j=R.lc);break}}if(N==G.lit)throw new Error("HufDecode issues")}}}const H=8-u&7;for(a>>=H,j-=H;j>0;){const R=N[a<<v-j&16383];if(!R.len)throw new Error("HufDecode issues");{j-=R.len;const N=s(R.lit,M,a,j,q,w,J,y,F);N&&(a=N.c,j=N.lc)}}}(S,W,R,q,F,j,M,u,{value:0})}function n(R){return 65535&R}function Q(R){const N=n(R);return N>32767?N-65536:N}function Y(R,N){const q=Q(R),w=Q(N),u=q+(1&w)+(w>>1);return{a:u,b:u-w}}function T(R,N){const q=n(R),w=n(N),u=q-(w>>1)&65535;return{a:w+u-32768&65535,b:u}}function f(R,N,q,w,u,M,v){const G=v<16384,J=q>u?u:q;let y,a,j=1;for(;j<=J;)j<<=1;for(j>>=1,y=j,j>>=1;j>=1;){a=0;const v=a+M*(u-y),J=M*j,F=M*y,S=w*j,H=w*y;let W,k,C,e;for(;a<=v;a+=F){let u=a;const M=a+w*(q-y);for(;u<=M;u+=H){const q=u+S,w=u+J,M=w+S;if(G){let v=Y(R[u+N],R[w+N]);W=v.a,C=v.b,v=Y(R[q+N],R[M+N]),k=v.a,e=v.b,v=Y(W,k),R[u+N]=v.a,R[q+N]=v.b,v=Y(C,e),R[w+N]=v.a,R[M+N]=v.b}else{let v=T(R[u+N],R[w+N]);W=v.a,C=v.b,v=T(R[q+N],R[M+N]),k=v.a,e=v.b,v=T(W,k),R[u+N]=v.a,R[q+N]=v.b,v=T(C,e),R[w+N]=v.a,R[M+N]=v.b}}if(q&j){const q=u+J;let w;w=G?Y(R[u+N],R[q+N]):T(R[u+N],R[q+N]),W=w.a,R[q+N]=w.b,R[u+N]=W}}if(u&j){let u=a;const M=a+w*(q-y);for(;u<=M;u+=H){const q=u+S;let w;w=G?Y(R[u+N],R[q+N]):T(R[u+N],R[q+N]),W=w.a,R[q+N]=w.b,R[u+N]=W}}y=j,j>>=1}return a}function c(R){return new DataView(R.array.buffer,R.offset.value,R.size)}function b(R){const N=R.viewer.buffer.slice(R.offset.value,R.offset.value+R.size),q=new Uint8Array(function(R){let N=R.byteLength;const q=new Array;let w=0;const u=new DataView(R);for(;N>0;){const R=u.getInt8(w++);if(R<0){const M=-R;N-=M+1;for(let R=0;R<M;R++)q.push(u.getUint8(w++))}else{const M=R;N-=2;const v=u.getUint8(w++);for(let R=0;R<M+1;R++)q.push(v)}}return q}(N)),w=new Uint8Array(q.length);return d(q),x(q,w),new DataView(w.buffer)}function I(R){const N=R.array.slice(R.offset.value,R.offset.value+R.size),q=fflate.unzlibSync(N),w=new Uint8Array(q.length);return d(q),x(q,w),new DataView(w.buffer)}function V(R){const N=R.array.slice(R.offset.value,R.offset.value+R.size),q=fflate.unzlibSync(N),w=R.lines*R.channels*R.width,u=1==R.type?new Uint16Array(w):new Uint32Array(w);let M=0,v=0;const G=new Array(4);for(let J=0;J<R.lines;J++)for(let N=0;N<R.channels;N++){let N=0;switch(R.type){case 1:G[0]=M,G[1]=G[0]+R.width,M=G[1]+R.width;for(let w=0;w<R.width;++w){N+=q[G[0]++]<<8|q[G[1]++],u[v]=N,v++}break;case 2:G[0]=M,G[1]=G[0]+R.width,G[2]=G[1]+R.width,M=G[2]+R.width;for(let w=0;w<R.width;++w){N+=q[G[0]++]<<24|q[G[1]++]<<16|q[G[2]++]<<8,u[v]=N,v++}}}return new DataView(u.buffer)}function t(R){const N=R.viewer,q={value:R.offset.value},w=new Uint16Array(R.width*R.scanlineBlockSize*(R.channels*R.type)),u=new Uint8Array(8192);let v=0;const G=new Array(R.channels);for(let M=0;M<R.channels;M++)G[M]={},G[M].start=v,G[M].end=G[M].start,G[M].nx=R.width,G[M].ny=R.lines,G[M].size=R.type,v+=G[M].nx*G[M].ny*G[M].size;const J=k(N,q),y=k(N,q);if(y>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(J<=y)for(let M=0;M<y-J+1;M++)u[M+J]=W(N,q);const a=new Uint16Array(M),j=function(R,N){let q=0;for(let u=0;u<M;++u)(0==u||R[u>>3]&1<<(7&u))&&(N[q++]=u);const w=q-1;for(;q<M;)N[q++]=0;return w}(u,a),F=H(N,q);A(R.array,N,q,F,w,v);for(let M=0;M<R.channels;++M){const R=G[M];for(let N=0;N<G[M].size;++N)f(w,R.start+N,R.nx,R.size,R.ny,R.nx*R.size,j)}!function(R,N,q){for(let w=0;w<q;++w)N[w]=R[N[w]]}(a,w,v);let S=0;const C=new Uint8Array(w.buffer.byteLength);for(let M=0;M<R.lines;M++)for(let N=0;N<R.channels;N++){const R=G[N],q=R.nx*R.size,u=new Uint8Array(w.buffer,2*R.end,2*q);C.set(u,S),S+=2*q,R.end+=q}return new DataView(C.buffer)}var i,g=q(1177);!function(R){R[R.Float=0]="Float",R[R.HalfFloat=1]="HalfFloat"}(i||(i={}));class U{}U.DefaultOutputType=i.HalfFloat,U.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class B{constructor(){this.supportCascades=!1}loadCubeData(R,N,q,w,u){throw".exr not supported in Cube."}async loadData(R,N,q){const u=new DataView(R.buffer),M={value:0},v=function(R,N){if(20000630!=R.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const q=R.getUint8(4),u=R.getUint8(5),M={singleTile:!!(2&u),longName:!!(4&u),deepFormat:!!(8&u),multiPart:!!(16&u)};N.value=8;const v={};let G=!0;for(;G;){const q=F(R.buffer,N);if(q){const u=F(R.buffer,N),M=z(R,N,u,H(R,N));void 0===M?w.e.Warn(`Unknown header attribute type ${u}'.`):v[q]=M}else G=!1}if(0!=(-5&u))throw new Error("Unsupported file format");return{version:q,spec:M,...v}}(u,M),G=await async function(R,N,q,w){const u={size:0,viewer:N,array:new Uint8Array(N.buffer),offset:q,width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,channels:R.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(R.compression){case y.NO_COMPRESSION:u.lines=1,u.uncompress=c;break;case y.RLE_COMPRESSION:u.lines=1,u.uncompress=b;break;case y.ZIPS_COMPRESSION:u.lines=1,u.uncompress=I,await g.i.LoadScriptAsync(U.FFLATEUrl);break;case y.ZIP_COMPRESSION:u.lines=16,u.uncompress=I,await g.i.LoadScriptAsync(U.FFLATEUrl);break;case y.PIZ_COMPRESSION:u.lines=32,u.uncompress=t;break;case y.PXR24_COMPRESSION:u.lines=16,u.uncompress=V,await g.i.LoadScriptAsync(U.FFLATEUrl);break;default:throw new Error(y[R.compression]+" is unsupported")}u.scanlineBlockSize=u.lines;const M={};for(const y of R.channels)switch(y.name){case"Y":case"R":case"G":case"B":case"A":M[y.name]=!0,u.type=y.pixelType}let v=!1;if(M.R&&M.G&&M.B)v=!M.A,u.outputChannels=4,u.decodeChannels={R:0,G:1,B:2,A:3};else{if(!M.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");u.outputChannels=1,u.decodeChannels={Y:0}}if(1===u.type)switch(w){case i.Float:u.getter=r,u.inputSize=2;break;case i.HalfFloat:u.getter=k,u.inputSize=2}else{if(2!==u.type)throw new Error("Unsupported pixelType "+u.type+" for "+R.compression);switch(w){case i.Float:u.getter=K,u.inputSize=4;break;case i.HalfFloat:u.getter=Z,u.inputSize=4}}u.blockCount=u.height/u.scanlineBlockSize;for(let y=0;y<u.blockCount;y++)e(N,q);const G=u.width*u.height*u.outputChannels;switch(w){case i.Float:u.byteArray=new Float32Array(G),u.textureType=1,v&&u.byteArray.fill(1,0,G);break;case i.HalfFloat:u.byteArray=new Uint16Array(G),u.textureType=2,v&&u.byteArray.fill(15360,0,G);break;default:throw new Error("Unsupported type: "+w)}let J=0;for(const y of R.channels)void 0!==u.decodeChannels[y.name]&&(u.channelLineOffsets[y.name]=J*u.width),J+=2*y.pixelType;return u.bytesPerLine=u.width*J,u.outLineWidth=u.width*u.outputChannels,"INCREASING_Y"===R.lineOrder?u.scanOrder=R=>R:u.scanOrder=R=>u.height-1-R,4==u.outputChannels?(u.format=5,u.linearSpace=!0):(u.format=6,u.linearSpace=!1),u}(v,u,M,U.DefaultOutputType);!function(R,N,q,w){const u={value:0};for(let M=0;M<R.height/R.scanlineBlockSize;M++){const v=S(q,w)-N.dataWindow.yMin;R.size=H(q,w),R.lines=v+R.scanlineBlockSize>R.height?R.height-v:R.scanlineBlockSize;const G=R.size<R.lines*R.bytesPerLine&&R.uncompress?R.uncompress(R):c(R);w.value+=R.size;for(let q=0;q<R.scanlineBlockSize;q++){const w=M*R.scanlineBlockSize,v=q+R.scanOrder(w);if(v>=R.height)continue;const J=q*R.bytesPerLine,y=(R.height-1-v)*R.outLineWidth;for(let q=0;q<R.channels;q++){const w=N.channels[q].name,M=R.channelLineOffsets[w],v=R.decodeChannels[w];if(void 0!==v){u.value=J+M;for(let N=0;N<R.width;N++){const q=y+N*R.outputChannels+v;R.byteArray&&(R.byteArray[q]=R.getter(G,u))}}}}}}(G,v,u,M);q(v.dataWindow.xMax-v.dataWindow.xMin+1,v.dataWindow.yMax-v.dataWindow.yMin+1,N.generateMipMaps,!1,(()=>{const R=N.getEngine();N.format=v.format,N.type=G.textureType,N.invertY=!1,N._gammaSpace=!v.linearSpace,G.byteArray&&R._uploadDataToTextureDirectly(N,G.byteArray,0,0,void 0,!0)}))}}}}]);