"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10890:(v,T,X)=>{X.r(T),X.d(T,{_ExrTextureLoader:()=>S});var O=X(1103),u=X(1040);const B=65536,m=14,A=65537,x=16384;var f,M;!function(v){v[v.NO_COMPRESSION=0]="NO_COMPRESSION",v[v.RLE_COMPRESSION=1]="RLE_COMPRESSION",v[v.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",v[v.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",v[v.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",v[v.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(f||(f={})),function(v){v[v.INCREASING_Y=0]="INCREASING_Y",v[v.DECREASING_Y=1]="DECREASING_Y"}(M||(M={}));const H=function(){const v=new ArrayBuffer(4),T=new Float32Array(v),X=new Uint32Array(v),O=new Uint32Array(512),u=new Uint32Array(512);for(let x=0;x<256;++x){const v=x-127;v<-27?(O[x]=0,O[256|x]=32768,u[x]=24,u[256|x]=24):v<-14?(O[x]=1024>>-v-14,O[256|x]=1024>>-v-14|32768,u[x]=-v-1,u[256|x]=-v-1):v<=15?(O[x]=v+15<<10,O[256|x]=v+15<<10|32768,u[x]=13,u[256|x]=13):v<128?(O[x]=31744,O[256|x]=64512,u[x]=24,u[256|x]=24):(O[x]=31744,O[256|x]=64512,u[x]=13,u[256|x]=13)}const B=new Uint32Array(2048),m=new Uint32Array(64),A=new Uint32Array(64);for(let x=1;x<1024;++x){let v=x<<13,T=0;for(;0===(8388608&v);)v<<=1,T-=8388608;v&=-8388609,T+=947912704,B[x]=v|T}for(let x=1024;x<2048;++x)B[x]=939524096+(x-1024<<13);for(let x=1;x<31;++x)m[x]=x<<23;m[31]=1199570944,m[32]=2147483648;for(let x=33;x<63;++x)m[x]=2147483648+(x-32<<23);m[63]=3347054592;for(let x=1;x<64;++x)32!==x&&(A[x]=1024);return{floatView:T,uint32View:X,baseTable:O,shiftTable:u,mantissaTable:B,exponentTable:m,offsetTable:A}}();function n(v,T){const X=new Uint8Array(v);let O=0;for(;0!=X[T.value+O];)O+=1;const u=(new TextDecoder).decode(X.slice(T.value,T.value+O));return T.value=T.value+O+1,u}function V(v,T){const X=v.getInt32(T.value,!0);return T.value+=4,X}function D(v,T){const X=v.getUint32(T.value,!0);return T.value+=4,X}function s(v,T){const X=v.getUint8(T.value);return T.value+=1,X}function F(v,T){const X=v.getUint16(T.value,!0);return T.value+=2,X}function k(v,T){const X=v[T.value];return T.value+=1,X}function b(v,T){let X;return X="getBigInt64"in DataView.prototype?Number(v.getBigInt64(T.value,!0)):v.getUint32(T.value+4,!0)+Number(v.getUint32(T.value,!0)<<32),T.value+=8,X}function l(v,T){const X=v.getFloat32(T.value,!0);return T.value+=4,X}function Q(v,T){return function(v){const T=(31744&v)>>10,X=1023&v;return(v>>15?-1:1)*(T?31===T?X?NaN:1/0:Math.pow(2,T-15)*(1+X/1024):X/1024*6103515625e-14)}(F(v,T))}function K(v,T){return function(v){if(Math.abs(v)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");v=(0,u.c)(v,-65504,65504),H.floatView[0]=v;const T=H.uint32View[0],X=T>>23&511;return H.baseTable[X]+((8388607&T)>>H.shiftTable[X])}(l(v,T))}function p(v,T,X,O){switch(X){case"string":case"stringvector":case"iccProfile":return function(v,T,X){const O=(new TextDecoder).decode(new Uint8Array(v).slice(T.value,T.value+X));return T.value=T.value+X,O}(v.buffer,T,O);case"chlist":return function(v,T,X){const O=T.value,u=[];for(;T.value<O+X-1;){const X=n(v.buffer,T),O=V(v,T),B=s(v,T);T.value+=3;const m=V(v,T),A=V(v,T);u.push({name:X,pixelType:O,pLinear:B,xSampling:m,ySampling:A})}return T.value+=1,u}(v,T,O);case"chromaticities":return function(v,T){return{redX:l(v,T),redY:l(v,T),greenX:l(v,T),greenY:l(v,T),blueX:l(v,T),blueY:l(v,T),whiteX:l(v,T),whiteY:l(v,T)}}(v,T);case"compression":return function(v,T){return s(v,T)}(v,T);case"box2i":return function(v,T){return{xMin:V(v,T),yMin:V(v,T),xMax:V(v,T),yMax:V(v,T)}}(v,T);case"lineOrder":return function(v,T){const X=s(v,T);return M[X]}(v,T);case"float":return l(v,T);case"v2f":return function(v,T){return[l(v,T),l(v,T)]}(v,T);case"v3f":return function(v,T){return[l(v,T),l(v,T),l(v,T)]}(v,T);case"int":return V(v,T);case"rational":return function(v,T){return[V(v,T),D(v,T)]}(v,T);case"timecode":return function(v,T){return[D(v,T),D(v,T)]}(v,T);case"preview":return T.value+=O,"skipped";default:return void(T.value+=O)}}function G(v){for(let T=1;T<v.length;T++){const X=v[T-1]+v[T]-128;v[T]=X}}function L(v,T){let X=0,O=Math.floor((v.length+1)/2),u=0;const B=v.length-1;for(;!(u>B)&&(T[u++]=v[X++],!(u>B));)T[u++]=v[O++]}function r(v,T,X,O,u){for(;X<v;)T=T<<8|k(O,u),X+=8;return{l:T>>(X-=v)&(1<<v)-1,c:T,lc:X}}function o(v,T,X,O){return{c:v=v<<8|k(X,O),lc:T+=8}}function Z(v,T,X,O,u,B,m,A,x){if(v==T){if(O<8){const v=o(X,O,u,B);X=v.c,O=v.lc}let v=X>>(O-=8);if(v=new Uint8Array([v])[0],A.value+v>x)return null;const T=m[A.value-1];for(;v-- >0;)m[A.value++]=T}else{if(!(A.value<x))return null;m[A.value++]=v}return{c:X,lc:O}}const U=new Array(59);function J(v,T,X,O,u,B){const m=T;let x=0,f=0;for(;O<=u;O++){if(m.value-T.value>X)return;let A=r(6,x,f,v,m);const M=A.l;if(x=A.c,f=A.lc,B[O]=M,63==M){if(m.value-T.value>X)throw new Error("Error in HufUnpackEncTable");A=r(8,x,f,v,m);let M=A.l+6;if(x=A.c,f=A.lc,O+M>u+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)B[O++]=0;O--}else if(M>=59){let v=M-59+2;if(O+v>u+1)throw new Error("Error in HufUnpackEncTable");for(;v--;)B[O++]=0;O--}}!function(v){for(let X=0;X<=58;++X)U[X]=0;for(let X=0;X<A;++X)U[v[X]]+=1;let T=0;for(let X=58;X>0;--X){const v=T+U[X]>>1;U[X]=T,T=v}for(let X=0;X<A;++X){const T=v[X];T>0&&(v[X]=T|U[T]++<<6)}}(B)}function y(v){return 63&v}function P(v){return v>>6}function a(v,T,X,O,u,B){const f=X.value,M=D(T,X),H=D(T,X);X.value+=4;const n=D(T,X);if(X.value+=4,M<0||M>=A||H<0||H>=A)throw new Error("Wrong HUF_ENCSIZE");const V=new Array(A),s=new Array(x);!function(v){for(let T=0;T<x;T++)v[T]={},v[T].len=0,v[T].lit=0,v[T].p=null}(s);if(J(v,X,O-(X.value-f),M,H,V),n>8*(O-(X.value-f)))throw new Error("Wrong hufUncompress");!function(v,T,X,O){for(;T<=X;T++){const X=P(v[T]),u=y(v[T]);if(X>>u)throw new Error("Invalid table entry");if(u>m){const v=O[X>>u-m];if(v.len)throw new Error("Invalid table entry");if(v.lit++,v.p){const T=v.p;v.p=new Array(v.lit);for(let X=0;X<v.lit-1;++X)v.p[X]=T[X]}else v.p=new Array(1);v.p[v.lit-1]=T}else if(u){let v=0;for(let B=1<<m-u;B>0;B--){const B=O[(X<<m-u)+v];if(B.len||B.p)throw new Error("Invalid table entry");B.len=u,B.lit=T,v++}}}}(V,M,H,s),function(v,T,X,O,u,B,A,x,f){let M=0,H=0;const n=A,V=Math.trunc(O.value+(u+7)/8);for(;O.value<V;){let u=o(M,H,X,O);for(M=u.c,H=u.lc;H>=m;){const A=T[M>>H-m&16383];if(A.len){H-=A.len;const v=Z(A.lit,B,M,H,X,O,x,f,n);v&&(M=v.c,H=v.lc)}else{if(!A.p)throw new Error("hufDecode issues");let T;for(T=0;T<A.lit;T++){const m=y(v[A.p[T]]);for(;H<m&&O.value<V;)u=o(M,H,X,O),M=u.c,H=u.lc;if(H>=m&&P(v[A.p[T]])==(M>>H-m&(1<<m)-1)){H-=m;const v=Z(A.p[T],B,M,H,X,O,x,f,n);v&&(M=v.c,H=v.lc);break}}if(T==A.lit)throw new Error("HufDecode issues")}}}const D=8-u&7;for(M>>=D,H-=D;H>0;){const v=T[M<<m-H&16383];if(!v.len)throw new Error("HufDecode issues");{H-=v.len;const T=Z(v.lit,B,M,H,X,O,x,f,n);T&&(M=T.c,H=T.lc)}}}(V,s,v,X,n,H,B,u,{value:0})}function E(v){return 65535&v}function i(v){const T=E(v);return T>32767?T-65536:T}function t(v,T){const X=i(v),O=i(T),u=X+(1&O)+(O>>1);return{a:u,b:u-O}}function C(v,T){const X=E(v),O=E(T),u=X-(O>>1)&65535;return{a:O+u-32768&65535,b:u}}function c(v,T,X,O,u,B,m){const A=m<16384,x=X>u?u:X;let f,M,H=1;for(;H<=x;)H<<=1;for(H>>=1,f=H,H>>=1;H>=1;){M=0;const m=M+B*(u-f),x=B*H,n=B*f,V=O*H,D=O*f;let s,F,k,b;for(;M<=m;M+=n){let u=M;const B=M+O*(X-f);for(;u<=B;u+=D){const X=u+V,O=u+x,B=O+V;if(A){let m=t(v[u+T],v[O+T]);s=m.a,k=m.b,m=t(v[X+T],v[B+T]),F=m.a,b=m.b,m=t(s,F),v[u+T]=m.a,v[X+T]=m.b,m=t(k,b),v[O+T]=m.a,v[B+T]=m.b}else{let m=C(v[u+T],v[O+T]);s=m.a,k=m.b,m=C(v[X+T],v[B+T]),F=m.a,b=m.b,m=C(s,F),v[u+T]=m.a,v[X+T]=m.b,m=C(k,b),v[O+T]=m.a,v[B+T]=m.b}}if(X&H){const X=u+x;let O;O=A?t(v[u+T],v[X+T]):C(v[u+T],v[X+T]),s=O.a,v[X+T]=O.b,v[u+T]=s}}if(u&H){let u=M;const B=M+O*(X-f);for(;u<=B;u+=D){const X=u+V;let O;O=A?t(v[u+T],v[X+T]):C(v[u+T],v[X+T]),s=O.a,v[X+T]=O.b,v[u+T]=s}}f=H,H>>=1}return M}function N(v){return new DataView(v.array.buffer,v.offset.value,v.size)}function d(v){const T=v.viewer.buffer.slice(v.offset.value,v.offset.value+v.size),X=new Uint8Array(function(v){let T=v.byteLength;const X=new Array;let O=0;const u=new DataView(v);for(;T>0;){const v=u.getInt8(O++);if(v<0){const B=-v;T-=B+1;for(let v=0;v<B;v++)X.push(u.getUint8(O++))}else{const B=v;T-=2;const m=u.getUint8(O++);for(let v=0;v<B+1;v++)X.push(m)}}return X}(T)),O=new Uint8Array(X.length);return G(X),L(X,O),new DataView(O.buffer)}function I(v){const T=v.array.slice(v.offset.value,v.offset.value+v.size),X=fflate.unzlibSync(T),O=new Uint8Array(X.length);return G(X),L(X,O),new DataView(O.buffer)}function W(v){const T=v.array.slice(v.offset.value,v.offset.value+v.size),X=fflate.unzlibSync(T),O=v.lines*v.channels*v.width,u=1==v.type?new Uint16Array(O):new Uint32Array(O);let B=0,m=0;const A=new Array(4);for(let x=0;x<v.lines;x++)for(let T=0;T<v.channels;T++){let T=0;switch(v.type){case 1:A[0]=B,A[1]=A[0]+v.width,B=A[1]+v.width;for(let O=0;O<v.width;++O){T+=X[A[0]++]<<8|X[A[1]++],u[m]=T,m++}break;case 2:A[0]=B,A[1]=A[0]+v.width,A[2]=A[1]+v.width,B=A[2]+v.width;for(let O=0;O<v.width;++O){T+=X[A[0]++]<<24|X[A[1]++]<<16|X[A[2]++]<<8,u[m]=T,m++}}}return new DataView(u.buffer)}function g(v){const T=v.viewer,X={value:v.offset.value},O=new Uint16Array(v.width*v.scanlineBlockSize*(v.channels*v.type)),u=new Uint8Array(8192);let m=0;const A=new Array(v.channels);for(let B=0;B<v.channels;B++)A[B]={},A[B].start=m,A[B].end=A[B].start,A[B].nx=v.width,A[B].ny=v.lines,A[B].size=v.type,m+=A[B].nx*A[B].ny*A[B].size;const x=F(T,X),f=F(T,X);if(f>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(x<=f)for(let B=0;B<f-x+1;B++)u[B+x]=s(T,X);const M=new Uint16Array(B),H=function(v,T){let X=0;for(let u=0;u<B;++u)(0==u||v[u>>3]&1<<(7&u))&&(T[X++]=u);const O=X-1;for(;X<B;)T[X++]=0;return O}(u,M),n=D(T,X);a(v.array,T,X,n,O,m);for(let B=0;B<v.channels;++B){const v=A[B];for(let T=0;T<A[B].size;++T)c(O,v.start+T,v.nx,v.size,v.ny,v.nx*v.size,H)}!function(v,T,X){for(let O=0;O<X;++O)T[O]=v[T[O]]}(M,O,m);let V=0;const k=new Uint8Array(O.buffer.byteLength);for(let B=0;B<v.lines;B++)for(let T=0;T<v.channels;T++){const v=A[T],X=v.nx*v.size,u=new Uint8Array(O.buffer,2*v.end,2*X);k.set(u,V),V+=2*X,v.end+=X}return new DataView(k.buffer)}var j,e=X(1217);!function(v){v[v.Float=0]="Float",v[v.HalfFloat=1]="HalfFloat"}(j||(j={}));class h{}h.DefaultOutputType=j.HalfFloat,h.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class S{constructor(){this.supportCascades=!1}loadCubeData(v,T,X,O,u){throw".exr not supported in Cube."}async loadData(v,T,X){const u=new DataView(v.buffer),B={value:0},m=function(v,T){if(20000630!=v.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const X=v.getUint8(4),u=v.getUint8(5),B={singleTile:!!(2&u),longName:!!(4&u),deepFormat:!!(8&u),multiPart:!!(16&u)};T.value=8;const m={};let A=!0;for(;A;){const X=n(v.buffer,T);if(X){const u=n(v.buffer,T),B=p(v,T,u,D(v,T));void 0===B?O.d.Warn(`Unknown header attribute type ${u}'.`):m[X]=B}else A=!1}if(0!=(-5&u))throw new Error("Unsupported file format");return{version:X,spec:B,...m}}(u,B),A=await async function(v,T,X,O){const u={size:0,viewer:T,array:new Uint8Array(T.buffer),offset:X,width:v.dataWindow.xMax-v.dataWindow.xMin+1,height:v.dataWindow.yMax-v.dataWindow.yMin+1,channels:v.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(v.compression){case f.NO_COMPRESSION:u.lines=1,u.uncompress=N;break;case f.RLE_COMPRESSION:u.lines=1,u.uncompress=d;break;case f.ZIPS_COMPRESSION:u.lines=1,u.uncompress=I,await e.c.LoadScriptAsync(h.FFLATEUrl);break;case f.ZIP_COMPRESSION:u.lines=16,u.uncompress=I,await e.c.LoadScriptAsync(h.FFLATEUrl);break;case f.PIZ_COMPRESSION:u.lines=32,u.uncompress=g;break;case f.PXR24_COMPRESSION:u.lines=16,u.uncompress=W,await e.c.LoadScriptAsync(h.FFLATEUrl);break;default:throw new Error(f[v.compression]+" is unsupported")}u.scanlineBlockSize=u.lines;const B={};for(const f of v.channels)switch(f.name){case"Y":case"R":case"G":case"B":case"A":B[f.name]=!0,u.type=f.pixelType}let m=!1;if(B.R&&B.G&&B.B)m=!B.A,u.outputChannels=4,u.decodeChannels={R:0,G:1,B:2,A:3};else{if(!B.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");u.outputChannels=1,u.decodeChannels={Y:0}}if(1===u.type)switch(O){case j.Float:u.getter=Q,u.inputSize=2;break;case j.HalfFloat:u.getter=F,u.inputSize=2}else{if(2!==u.type)throw new Error("Unsupported pixelType "+u.type+" for "+v.compression);switch(O){case j.Float:u.getter=l,u.inputSize=4;break;case j.HalfFloat:u.getter=K,u.inputSize=4}}u.blockCount=u.height/u.scanlineBlockSize;for(let f=0;f<u.blockCount;f++)b(T,X);const A=u.width*u.height*u.outputChannels;switch(O){case j.Float:u.byteArray=new Float32Array(A),u.textureType=1,m&&u.byteArray.fill(1,0,A);break;case j.HalfFloat:u.byteArray=new Uint16Array(A),u.textureType=2,m&&u.byteArray.fill(15360,0,A);break;default:throw new Error("Unsupported type: "+O)}let x=0;for(const f of v.channels)void 0!==u.decodeChannels[f.name]&&(u.channelLineOffsets[f.name]=x*u.width),x+=2*f.pixelType;return u.bytesPerLine=u.width*x,u.outLineWidth=u.width*u.outputChannels,"INCREASING_Y"===v.lineOrder?u.scanOrder=v=>v:u.scanOrder=v=>u.height-1-v,4==u.outputChannels?(u.format=5,u.linearSpace=!0):(u.format=6,u.linearSpace=!1),u}(m,u,B,h.DefaultOutputType);!function(v,T,X,O){const u={value:0};for(let B=0;B<v.height/v.scanlineBlockSize;B++){const m=V(X,O)-T.dataWindow.yMin;v.size=D(X,O),v.lines=m+v.scanlineBlockSize>v.height?v.height-m:v.scanlineBlockSize;const A=v.size<v.lines*v.bytesPerLine&&v.uncompress?v.uncompress(v):N(v);O.value+=v.size;for(let X=0;X<v.scanlineBlockSize;X++){const O=B*v.scanlineBlockSize,m=X+v.scanOrder(O);if(m>=v.height)continue;const x=X*v.bytesPerLine,f=(v.height-1-m)*v.outLineWidth;for(let X=0;X<v.channels;X++){const O=T.channels[X].name,B=v.channelLineOffsets[O],m=v.decodeChannels[O];if(void 0!==m){u.value=x+B;for(let T=0;T<v.width;T++){const X=f+T*v.outputChannels+m;v.byteArray&&(v.byteArray[X]=v.getter(A,u))}}}}}}(A,m,u,B);X(m.dataWindow.xMax-m.dataWindow.xMin+1,m.dataWindow.yMax-m.dataWindow.yMin+1,T.generateMipMaps,!1,(()=>{const v=T.getEngine();T.format=m.format,T.type=A.textureType,T.invertY=!1,T._gammaSpace=!m.linearSpace,A.byteArray&&v._uploadDataToTextureDirectly(T,A.byteArray,0,0,void 0,!0)}))}}}}]);