"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10533:(M,E,b)=>{b.r(E),b.d(E,{_ExrTextureLoader:()=>G});var x=b(1060),k=b(1009);const a=65536,g=14,n=65537,J=16384;var u,T;!function(M){M[M.NO_COMPRESSION=0]="NO_COMPRESSION",M[M.RLE_COMPRESSION=1]="RLE_COMPRESSION",M[M.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",M[M.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",M[M.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",M[M.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(u||(u={})),function(M){M[M.INCREASING_Y=0]="INCREASING_Y",M[M.DECREASING_Y=1]="DECREASING_Y"}(T||(T={}));const V=function(){const M=new ArrayBuffer(4),E=new Float32Array(M),b=new Uint32Array(M),x=new Uint32Array(512),k=new Uint32Array(512);for(let J=0;J<256;++J){const M=J-127;M<-27?(x[J]=0,x[256|J]=32768,k[J]=24,k[256|J]=24):M<-14?(x[J]=1024>>-M-14,x[256|J]=1024>>-M-14|32768,k[J]=-M-1,k[256|J]=-M-1):M<=15?(x[J]=M+15<<10,x[256|J]=M+15<<10|32768,k[J]=13,k[256|J]=13):M<128?(x[J]=31744,x[256|J]=64512,k[J]=24,k[256|J]=24):(x[J]=31744,x[256|J]=64512,k[J]=13,k[256|J]=13)}const a=new Uint32Array(2048),g=new Uint32Array(64),n=new Uint32Array(64);for(let J=1;J<1024;++J){let M=J<<13,E=0;for(;0===(8388608&M);)M<<=1,E-=8388608;M&=-8388609,E+=947912704,a[J]=M|E}for(let J=1024;J<2048;++J)a[J]=939524096+(J-1024<<13);for(let J=1;J<31;++J)g[J]=J<<23;g[31]=1199570944,g[32]=2147483648;for(let J=33;J<63;++J)g[J]=2147483648+(J-32<<23);g[63]=3347054592;for(let J=1;J<64;++J)32!==J&&(n[J]=1024);return{floatView:E,uint32View:b,baseTable:x,shiftTable:k,mantissaTable:a,exponentTable:g,offsetTable:n}}();function I(M,E){const b=new Uint8Array(M);let x=0;for(;0!=b[E.value+x];)x+=1;const k=(new TextDecoder).decode(b.slice(E.value,E.value+x));return E.value=E.value+x+1,k}function t(M,E){const b=M.getInt32(E.value,!0);return E.value+=4,b}function y(M,E){const b=M.getUint32(E.value,!0);return E.value+=4,b}function B(M,E){const b=M.getUint8(E.value);return E.value+=1,b}function r(M,E){const b=M.getUint16(E.value,!0);return E.value+=2,b}function c(M,E){const b=M[E.value];return E.value+=1,b}function C(M,E){let b;return b="getBigInt64"in DataView.prototype?Number(M.getBigInt64(E.value,!0)):M.getUint32(E.value+4,!0)+Number(M.getUint32(E.value,!0)<<32),E.value+=8,b}function R(M,E){const b=M.getFloat32(E.value,!0);return E.value+=4,b}function w(M,E){return function(M){const E=(31744&M)>>10,b=1023&M;return(M>>15?-1:1)*(E?31===E?b?NaN:1/0:Math.pow(2,E-15)*(1+b/1024):b/1024*6103515625e-14)}(r(M,E))}function S(M,E){return function(M){if(Math.abs(M)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");M=(0,k.d)(M,-65504,65504),V.floatView[0]=M;const E=V.uint32View[0],b=E>>23&511;return V.baseTable[b]+((8388607&E)>>V.shiftTable[b])}(R(M,E))}function X(M,E,b,x){switch(b){case"string":case"stringvector":case"iccProfile":return function(M,E,b){const x=(new TextDecoder).decode(new Uint8Array(M).slice(E.value,E.value+b));return E.value=E.value+b,x}(M.buffer,E,x);case"chlist":return function(M,E,b){const x=E.value,k=[];for(;E.value<x+b-1;){const b=I(M.buffer,E),x=t(M,E),a=B(M,E);E.value+=3;const g=t(M,E),n=t(M,E);k.push({name:b,pixelType:x,pLinear:a,xSampling:g,ySampling:n})}return E.value+=1,k}(M,E,x);case"chromaticities":return function(M,E){return{redX:R(M,E),redY:R(M,E),greenX:R(M,E),greenY:R(M,E),blueX:R(M,E),blueY:R(M,E),whiteX:R(M,E),whiteY:R(M,E)}}(M,E);case"compression":return function(M,E){return B(M,E)}(M,E);case"box2i":return function(M,E){return{xMin:t(M,E),yMin:t(M,E),xMax:t(M,E),yMax:t(M,E)}}(M,E);case"lineOrder":return function(M,E){const b=B(M,E);return T[b]}(M,E);case"float":return R(M,E);case"v2f":return function(M,E){return[R(M,E),R(M,E)]}(M,E);case"v3f":return function(M,E){return[R(M,E),R(M,E),R(M,E)]}(M,E);case"int":return t(M,E);case"rational":return function(M,E){return[t(M,E),y(M,E)]}(M,E);case"timecode":return function(M,E){return[y(M,E),y(M,E)]}(M,E);case"preview":return E.value+=x,"skipped";default:return void(E.value+=x)}}function U(M){for(let E=1;E<M.length;E++){const b=M[E-1]+M[E]-128;M[E]=b}}function v(M,E){let b=0,x=Math.floor((M.length+1)/2),k=0;const a=M.length-1;for(;!(k>a)&&(E[k++]=M[b++],!(k>a));)E[k++]=M[x++]}function N(M,E,b,x,k){for(;b<M;)E=E<<8|c(x,k),b+=8;return{l:E>>(b-=M)&(1<<M)-1,c:E,lc:b}}function K(M,E,b,x){return{c:M=M<<8|c(b,x),lc:E+=8}}function h(M,E,b,x,k,a,g,n,J){if(M==E){if(x<8){const M=K(b,x,k,a);b=M.c,x=M.lc}let M=b>>(x-=8);if(M=new Uint8Array([M])[0],n.value+M>J)return null;const E=g[n.value-1];for(;M-- >0;)g[n.value++]=E}else{if(!(n.value<J))return null;g[n.value++]=M}return{c:b,lc:x}}const Z=new Array(59);function O(M,E,b,x,k,a){const g=E;let J=0,u=0;for(;x<=k;x++){if(g.value-E.value>b)return;let n=N(6,J,u,M,g);const T=n.l;if(J=n.c,u=n.lc,a[x]=T,63==T){if(g.value-E.value>b)throw new Error("Error in HufUnpackEncTable");n=N(8,J,u,M,g);let T=n.l+6;if(J=n.c,u=n.lc,x+T>k+1)throw new Error("Error in HufUnpackEncTable");for(;T--;)a[x++]=0;x--}else if(T>=59){let M=T-59+2;if(x+M>k+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)a[x++]=0;x--}}!function(M){for(let b=0;b<=58;++b)Z[b]=0;for(let b=0;b<n;++b)Z[M[b]]+=1;let E=0;for(let b=58;b>0;--b){const M=E+Z[b]>>1;Z[b]=E,E=M}for(let b=0;b<n;++b){const E=M[b];E>0&&(M[b]=E|Z[E]++<<6)}}(a)}function p(M){return 63&M}function P(M){return M>>6}function F(M,E,b,x,k,a){const u=b.value,T=y(E,b),V=y(E,b);b.value+=4;const I=y(E,b);if(b.value+=4,T<0||T>=n||V<0||V>=n)throw new Error("Wrong HUF_ENCSIZE");const t=new Array(n),B=new Array(J);!function(M){for(let E=0;E<J;E++)M[E]={},M[E].len=0,M[E].lit=0,M[E].p=null}(B);if(O(M,b,x-(b.value-u),T,V,t),I>8*(x-(b.value-u)))throw new Error("Wrong hufUncompress");!function(M,E,b,x){for(;E<=b;E++){const b=P(M[E]),k=p(M[E]);if(b>>k)throw new Error("Invalid table entry");if(k>g){const M=x[b>>k-g];if(M.len)throw new Error("Invalid table entry");if(M.lit++,M.p){const E=M.p;M.p=new Array(M.lit);for(let b=0;b<M.lit-1;++b)M.p[b]=E[b]}else M.p=new Array(1);M.p[M.lit-1]=E}else if(k){let M=0;for(let a=1<<g-k;a>0;a--){const a=x[(b<<g-k)+M];if(a.len||a.p)throw new Error("Invalid table entry");a.len=k,a.lit=E,M++}}}}(t,T,V,B),function(M,E,b,x,k,a,n,J,u){let T=0,V=0;const I=n,t=Math.trunc(x.value+(k+7)/8);for(;x.value<t;){let k=K(T,V,b,x);for(T=k.c,V=k.lc;V>=g;){const n=E[T>>V-g&16383];if(n.len){V-=n.len;const M=h(n.lit,a,T,V,b,x,J,u,I);M&&(T=M.c,V=M.lc)}else{if(!n.p)throw new Error("hufDecode issues");let E;for(E=0;E<n.lit;E++){const g=p(M[n.p[E]]);for(;V<g&&x.value<t;)k=K(T,V,b,x),T=k.c,V=k.lc;if(V>=g&&P(M[n.p[E]])==(T>>V-g&(1<<g)-1)){V-=g;const M=h(n.p[E],a,T,V,b,x,J,u,I);M&&(T=M.c,V=M.lc);break}}if(E==n.lit)throw new Error("HufDecode issues")}}}const y=8-k&7;for(T>>=y,V-=y;V>0;){const M=E[T<<g-V&16383];if(!M.len)throw new Error("HufDecode issues");{V-=M.len;const E=h(M.lit,a,T,V,b,x,J,u,I);E&&(T=E.c,V=E.lc)}}}(t,B,M,b,I,V,a,k,{value:0})}function l(M){return 65535&M}function d(M){const E=l(M);return E>32767?E-65536:E}function W(M,E){const b=d(M),x=d(E),k=b+(1&x)+(x>>1);return{a:k,b:k-x}}function m(M,E){const b=l(M),x=l(E),k=b-(x>>1)&65535;return{a:x+k-32768&65535,b:k}}function o(M,E,b,x,k,a,g){const n=g<16384,J=b>k?k:b;let u,T,V=1;for(;V<=J;)V<<=1;for(V>>=1,u=V,V>>=1;V>=1;){T=0;const g=T+a*(k-u),J=a*V,I=a*u,t=x*V,y=x*u;let B,r,c,C;for(;T<=g;T+=I){let k=T;const a=T+x*(b-u);for(;k<=a;k+=y){const b=k+t,x=k+J,a=x+t;if(n){let g=W(M[k+E],M[x+E]);B=g.a,c=g.b,g=W(M[b+E],M[a+E]),r=g.a,C=g.b,g=W(B,r),M[k+E]=g.a,M[b+E]=g.b,g=W(c,C),M[x+E]=g.a,M[a+E]=g.b}else{let g=m(M[k+E],M[x+E]);B=g.a,c=g.b,g=m(M[b+E],M[a+E]),r=g.a,C=g.b,g=m(B,r),M[k+E]=g.a,M[b+E]=g.b,g=m(c,C),M[x+E]=g.a,M[a+E]=g.b}}if(b&V){const b=k+J;let x;x=n?W(M[k+E],M[b+E]):m(M[k+E],M[b+E]),B=x.a,M[b+E]=x.b,M[k+E]=B}}if(k&V){let k=T;const a=T+x*(b-u);for(;k<=a;k+=y){const b=k+t;let x;x=n?W(M[k+E],M[b+E]):m(M[k+E],M[b+E]),B=x.a,M[b+E]=x.b,M[k+E]=B}}u=V,V>>=1}return T}function j(M){return new DataView(M.array.buffer,M.offset.value,M.size)}function s(M){const E=M.viewer.buffer.slice(M.offset.value,M.offset.value+M.size),b=new Uint8Array(function(M){let E=M.byteLength;const b=new Array;let x=0;const k=new DataView(M);for(;E>0;){const M=k.getInt8(x++);if(M<0){const a=-M;E-=a+1;for(let M=0;M<a;M++)b.push(k.getUint8(x++))}else{const a=M;E-=2;const g=k.getUint8(x++);for(let M=0;M<a+1;M++)b.push(g)}}return b}(E)),x=new Uint8Array(b.length);return U(b),v(b,x),new DataView(x.buffer)}function q(M){const E=M.array.slice(M.offset.value,M.offset.value+M.size),b=fflate.unzlibSync(E),x=new Uint8Array(b.length);return U(b),v(b,x),new DataView(x.buffer)}function D(M){const E=M.array.slice(M.offset.value,M.offset.value+M.size),b=fflate.unzlibSync(E),x=M.lines*M.channels*M.width,k=1==M.type?new Uint16Array(x):new Uint32Array(x);let a=0,g=0;const n=new Array(4);for(let J=0;J<M.lines;J++)for(let E=0;E<M.channels;E++){let E=0;switch(M.type){case 1:n[0]=a,n[1]=n[0]+M.width,a=n[1]+M.width;for(let x=0;x<M.width;++x){E+=b[n[0]++]<<8|b[n[1]++],k[g]=E,g++}break;case 2:n[0]=a,n[1]=n[0]+M.width,n[2]=n[1]+M.width,a=n[2]+M.width;for(let x=0;x<M.width;++x){E+=b[n[0]++]<<24|b[n[1]++]<<16|b[n[2]++]<<8,k[g]=E,g++}}}return new DataView(k.buffer)}function z(M){const E=M.viewer,b={value:M.offset.value},x=new Uint16Array(M.width*M.scanlineBlockSize*(M.channels*M.type)),k=new Uint8Array(8192);let g=0;const n=new Array(M.channels);for(let a=0;a<M.channels;a++)n[a]={},n[a].start=g,n[a].end=n[a].start,n[a].nx=M.width,n[a].ny=M.lines,n[a].size=M.type,g+=n[a].nx*n[a].ny*n[a].size;const J=r(E,b),u=r(E,b);if(u>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(J<=u)for(let a=0;a<u-J+1;a++)k[a+J]=B(E,b);const T=new Uint16Array(a),V=function(M,E){let b=0;for(let k=0;k<a;++k)(0==k||M[k>>3]&1<<(7&k))&&(E[b++]=k);const x=b-1;for(;b<a;)E[b++]=0;return x}(k,T),I=y(E,b);F(M.array,E,b,I,x,g);for(let a=0;a<M.channels;++a){const M=n[a];for(let E=0;E<n[a].size;++E)o(x,M.start+E,M.nx,M.size,M.ny,M.nx*M.size,V)}!function(M,E,b){for(let x=0;x<b;++x)E[x]=M[E[x]]}(T,x,g);let t=0;const c=new Uint8Array(x.buffer.byteLength);for(let a=0;a<M.lines;a++)for(let E=0;E<M.channels;E++){const M=n[E],b=M.nx*M.size,k=new Uint8Array(x.buffer,2*M.end,2*b);c.set(k,t),t+=2*b,M.end+=b}return new DataView(c.buffer)}var A,Y=b(1176);!function(M){M[M.Float=0]="Float",M[M.HalfFloat=1]="HalfFloat"}(A||(A={}));class i{}i.DefaultOutputType=A.HalfFloat,i.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class G{constructor(){this.supportCascades=!1}loadCubeData(M,E,b,x,k){throw".exr not supported in Cube."}async loadData(M,E,b){const k=new DataView(M.buffer),a={value:0},g=function(M,E){if(20000630!=M.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const b=M.getUint8(4),k=M.getUint8(5),a={singleTile:!!(2&k),longName:!!(4&k),deepFormat:!!(8&k),multiPart:!!(16&k)};E.value=8;const g={};let n=!0;for(;n;){const b=I(M.buffer,E);if(b){const k=I(M.buffer,E),a=X(M,E,k,y(M,E));void 0===a?x.d.Warn(`Unknown header attribute type ${k}'.`):g[b]=a}else n=!1}if(0!=(-5&k))throw new Error("Unsupported file format");return{version:b,spec:a,...g}}(k,a),n=await async function(M,E,b,x){const k={size:0,viewer:E,array:new Uint8Array(E.buffer),offset:b,width:M.dataWindow.xMax-M.dataWindow.xMin+1,height:M.dataWindow.yMax-M.dataWindow.yMin+1,channels:M.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(M.compression){case u.NO_COMPRESSION:k.lines=1,k.uncompress=j;break;case u.RLE_COMPRESSION:k.lines=1,k.uncompress=s;break;case u.ZIPS_COMPRESSION:k.lines=1,k.uncompress=q,await Y.e.LoadScriptAsync(i.FFLATEUrl);break;case u.ZIP_COMPRESSION:k.lines=16,k.uncompress=q,await Y.e.LoadScriptAsync(i.FFLATEUrl);break;case u.PIZ_COMPRESSION:k.lines=32,k.uncompress=z;break;case u.PXR24_COMPRESSION:k.lines=16,k.uncompress=D,await Y.e.LoadScriptAsync(i.FFLATEUrl);break;default:throw new Error(u[M.compression]+" is unsupported")}k.scanlineBlockSize=k.lines;const a={};for(const u of M.channels)switch(u.name){case"Y":case"R":case"G":case"B":case"A":a[u.name]=!0,k.type=u.pixelType}let g=!1;if(a.R&&a.G&&a.B)g=!a.A,k.outputChannels=4,k.decodeChannels={R:0,G:1,B:2,A:3};else{if(!a.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");k.outputChannels=1,k.decodeChannels={Y:0}}if(1===k.type)switch(x){case A.Float:k.getter=w,k.inputSize=2;break;case A.HalfFloat:k.getter=r,k.inputSize=2}else{if(2!==k.type)throw new Error("Unsupported pixelType "+k.type+" for "+M.compression);switch(x){case A.Float:k.getter=R,k.inputSize=4;break;case A.HalfFloat:k.getter=S,k.inputSize=4}}k.blockCount=k.height/k.scanlineBlockSize;for(let u=0;u<k.blockCount;u++)C(E,b);const n=k.width*k.height*k.outputChannels;switch(x){case A.Float:k.byteArray=new Float32Array(n),k.textureType=1,g&&k.byteArray.fill(1,0,n);break;case A.HalfFloat:k.byteArray=new Uint16Array(n),k.textureType=2,g&&k.byteArray.fill(15360,0,n);break;default:throw new Error("Unsupported type: "+x)}let J=0;for(const u of M.channels)void 0!==k.decodeChannels[u.name]&&(k.channelLineOffsets[u.name]=J*k.width),J+=2*u.pixelType;return k.bytesPerLine=k.width*J,k.outLineWidth=k.width*k.outputChannels,"INCREASING_Y"===M.lineOrder?k.scanOrder=M=>M:k.scanOrder=M=>k.height-1-M,4==k.outputChannels?(k.format=5,k.linearSpace=!0):(k.format=6,k.linearSpace=!1),k}(g,k,a,i.DefaultOutputType);!function(M,E,b,x){const k={value:0};for(let a=0;a<M.height/M.scanlineBlockSize;a++){const g=t(b,x)-E.dataWindow.yMin;M.size=y(b,x),M.lines=g+M.scanlineBlockSize>M.height?M.height-g:M.scanlineBlockSize;const n=M.size<M.lines*M.bytesPerLine&&M.uncompress?M.uncompress(M):j(M);x.value+=M.size;for(let b=0;b<M.scanlineBlockSize;b++){const x=a*M.scanlineBlockSize,g=b+M.scanOrder(x);if(g>=M.height)continue;const J=b*M.bytesPerLine,u=(M.height-1-g)*M.outLineWidth;for(let b=0;b<M.channels;b++){const x=E.channels[b].name,a=M.channelLineOffsets[x],g=M.decodeChannels[x];if(void 0!==g){k.value=J+a;for(let E=0;E<M.width;E++){const b=u+E*M.outputChannels+g;M.byteArray&&(M.byteArray[b]=M.getter(n,k))}}}}}}(n,g,k,a);b(g.dataWindow.xMax-g.dataWindow.xMin+1,g.dataWindow.yMax-g.dataWindow.yMin+1,E.generateMipMaps,!1,(()=>{const M=E.getEngine();E.format=g.format,E.type=n.textureType,E.invertY=!1,E._gammaSpace=!g.linearSpace,n.byteArray&&M._uploadDataToTextureDirectly(E,n.byteArray,0,0,void 0,!0)}))}}}}]);