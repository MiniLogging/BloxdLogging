"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{10939:(F,e,a)=>{a.r(e),a.d(e,{_ExrTextureLoader:()=>X});var k=a(1095),h=a(1038);const z=65536,x=14,t=65537,H=16384;var p,y;!function(F){F[F.NO_COMPRESSION=0]="NO_COMPRESSION",F[F.RLE_COMPRESSION=1]="RLE_COMPRESSION",F[F.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",F[F.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",F[F.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",F[F.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(p||(p={})),function(F){F[F.INCREASING_Y=0]="INCREASING_Y",F[F.DECREASING_Y=1]="DECREASING_Y"}(y||(y={}));const L=function(){const F=new ArrayBuffer(4),e=new Float32Array(F),a=new Uint32Array(F),k=new Uint32Array(512),h=new Uint32Array(512);for(let H=0;H<256;++H){const F=H-127;F<-27?(k[H]=0,k[256|H]=32768,h[H]=24,h[256|H]=24):F<-14?(k[H]=1024>>-F-14,k[256|H]=1024>>-F-14|32768,h[H]=-F-1,h[256|H]=-F-1):F<=15?(k[H]=F+15<<10,k[256|H]=F+15<<10|32768,h[H]=13,h[256|H]=13):F<128?(k[H]=31744,k[256|H]=64512,h[H]=24,h[256|H]=24):(k[H]=31744,k[256|H]=64512,h[H]=13,h[256|H]=13)}const z=new Uint32Array(2048),x=new Uint32Array(64),t=new Uint32Array(64);for(let H=1;H<1024;++H){let F=H<<13,e=0;for(;0===(8388608&F);)F<<=1,e-=8388608;F&=-8388609,e+=947912704,z[H]=F|e}for(let H=1024;H<2048;++H)z[H]=939524096+(H-1024<<13);for(let H=1;H<31;++H)x[H]=H<<23;x[31]=1199570944,x[32]=2147483648;for(let H=33;H<63;++H)x[H]=2147483648+(H-32<<23);x[63]=3347054592;for(let H=1;H<64;++H)32!==H&&(t[H]=1024);return{floatView:e,uint32View:a,baseTable:k,shiftTable:h,mantissaTable:z,exponentTable:x,offsetTable:t}}();function s(F,e){const a=new Uint8Array(F);let k=0;for(;0!=a[e.value+k];)k+=1;const h=(new TextDecoder).decode(a.slice(e.value,e.value+k));return e.value=e.value+k+1,h}function Z(F,e){const a=F.getInt32(e.value,!0);return e.value+=4,a}function A(F,e){const a=F.getUint32(e.value,!0);return e.value+=4,a}function w(F,e){const a=F.getUint8(e.value);return e.value+=1,a}function I(F,e){const a=F.getUint16(e.value,!0);return e.value+=2,a}function b(F,e){const a=F[e.value];return e.value+=1,a}function u(F,e){let a;return a="getBigInt64"in DataView.prototype?Number(F.getBigInt64(e.value,!0)):F.getUint32(e.value+4,!0)+Number(F.getUint32(e.value,!0)<<32),e.value+=8,a}function r(F,e){const a=F.getFloat32(e.value,!0);return e.value+=4,a}function O(F,e){return function(F){const e=(31744&F)>>10,a=1023&F;return(F>>15?-1:1)*(e?31===e?a?NaN:1/0:Math.pow(2,e-15)*(1+a/1024):a/1024*6103515625e-14)}(I(F,e))}function j(F,e){return function(F){if(Math.abs(F)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");F=(0,h.d)(F,-65504,65504),L.floatView[0]=F;const e=L.uint32View[0],a=e>>23&511;return L.baseTable[a]+((8388607&e)>>L.shiftTable[a])}(r(F,e))}function V(F,e,a,k){switch(a){case"string":case"stringvector":case"iccProfile":return function(F,e,a){const k=(new TextDecoder).decode(new Uint8Array(F).slice(e.value,e.value+a));return e.value=e.value+a,k}(F.buffer,e,k);case"chlist":return function(F,e,a){const k=e.value,h=[];for(;e.value<k+a-1;){const a=s(F.buffer,e),k=Z(F,e),z=w(F,e);e.value+=3;const x=Z(F,e),t=Z(F,e);h.push({name:a,pixelType:k,pLinear:z,xSampling:x,ySampling:t})}return e.value+=1,h}(F,e,k);case"chromaticities":return function(F,e){return{redX:r(F,e),redY:r(F,e),greenX:r(F,e),greenY:r(F,e),blueX:r(F,e),blueY:r(F,e),whiteX:r(F,e),whiteY:r(F,e)}}(F,e);case"compression":return function(F,e){return w(F,e)}(F,e);case"box2i":return function(F,e){return{xMin:Z(F,e),yMin:Z(F,e),xMax:Z(F,e),yMax:Z(F,e)}}(F,e);case"lineOrder":return function(F,e){const a=w(F,e);return y[a]}(F,e);case"float":return r(F,e);case"v2f":return function(F,e){return[r(F,e),r(F,e)]}(F,e);case"v3f":return function(F,e){return[r(F,e),r(F,e),r(F,e)]}(F,e);case"int":return Z(F,e);case"rational":return function(F,e){return[Z(F,e),A(F,e)]}(F,e);case"timecode":return function(F,e){return[A(F,e),A(F,e)]}(F,e);case"preview":return e.value+=k,"skipped";default:return void(e.value+=k)}}function Q(F){for(let e=1;e<F.length;e++){const a=F[e-1]+F[e]-128;F[e]=a}}function q(F,e){let a=0,k=Math.floor((F.length+1)/2),h=0;const z=F.length-1;for(;!(h>z)&&(e[h++]=F[a++],!(h>z));)e[h++]=F[k++]}function B(F,e,a,k,h){for(;a<F;)e=e<<8|b(k,h),a+=8;return{l:e>>(a-=F)&(1<<F)-1,c:e,lc:a}}function P(F,e,a,k){return{c:F=F<<8|b(a,k),lc:e+=8}}function E(F,e,a,k,h,z,x,t,H){if(F==e){if(k<8){const F=P(a,k,h,z);a=F.c,k=F.lc}let F=a>>(k-=8);if(F=new Uint8Array([F])[0],t.value+F>H)return null;const e=x[t.value-1];for(;F-- >0;)x[t.value++]=e}else{if(!(t.value<H))return null;x[t.value++]=F}return{c:a,lc:k}}const G=new Array(59);function d(F,e,a,k,h,z){const x=e;let H=0,p=0;for(;k<=h;k++){if(x.value-e.value>a)return;let t=B(6,H,p,F,x);const y=t.l;if(H=t.c,p=t.lc,z[k]=y,63==y){if(x.value-e.value>a)throw new Error("Error in HufUnpackEncTable");t=B(8,H,p,F,x);let y=t.l+6;if(H=t.c,p=t.lc,k+y>h+1)throw new Error("Error in HufUnpackEncTable");for(;y--;)z[k++]=0;k--}else if(y>=59){let F=y-59+2;if(k+F>h+1)throw new Error("Error in HufUnpackEncTable");for(;F--;)z[k++]=0;k--}}!function(F){for(let a=0;a<=58;++a)G[a]=0;for(let a=0;a<t;++a)G[F[a]]+=1;let e=0;for(let a=58;a>0;--a){const F=e+G[a]>>1;G[a]=e,e=F}for(let a=0;a<t;++a){const e=F[a];e>0&&(F[a]=e|G[e]++<<6)}}(z)}function Y(F){return 63&F}function m(F){return F>>6}function R(F,e,a,k,h,z){const p=a.value,y=A(e,a),L=A(e,a);a.value+=4;const s=A(e,a);if(a.value+=4,y<0||y>=t||L<0||L>=t)throw new Error("Wrong HUF_ENCSIZE");const Z=new Array(t),w=new Array(H);!function(F){for(let e=0;e<H;e++)F[e]={},F[e].len=0,F[e].lit=0,F[e].p=null}(w);if(d(F,a,k-(a.value-p),y,L,Z),s>8*(k-(a.value-p)))throw new Error("Wrong hufUncompress");!function(F,e,a,k){for(;e<=a;e++){const a=m(F[e]),h=Y(F[e]);if(a>>h)throw new Error("Invalid table entry");if(h>x){const F=k[a>>h-x];if(F.len)throw new Error("Invalid table entry");if(F.lit++,F.p){const e=F.p;F.p=new Array(F.lit);for(let a=0;a<F.lit-1;++a)F.p[a]=e[a]}else F.p=new Array(1);F.p[F.lit-1]=e}else if(h){let F=0;for(let z=1<<x-h;z>0;z--){const z=k[(a<<x-h)+F];if(z.len||z.p)throw new Error("Invalid table entry");z.len=h,z.lit=e,F++}}}}(Z,y,L,w),function(F,e,a,k,h,z,t,H,p){let y=0,L=0;const s=t,Z=Math.trunc(k.value+(h+7)/8);for(;k.value<Z;){let h=P(y,L,a,k);for(y=h.c,L=h.lc;L>=x;){const t=e[y>>L-x&16383];if(t.len){L-=t.len;const F=E(t.lit,z,y,L,a,k,H,p,s);F&&(y=F.c,L=F.lc)}else{if(!t.p)throw new Error("hufDecode issues");let e;for(e=0;e<t.lit;e++){const x=Y(F[t.p[e]]);for(;L<x&&k.value<Z;)h=P(y,L,a,k),y=h.c,L=h.lc;if(L>=x&&m(F[t.p[e]])==(y>>L-x&(1<<x)-1)){L-=x;const F=E(t.p[e],z,y,L,a,k,H,p,s);F&&(y=F.c,L=F.lc);break}}if(e==t.lit)throw new Error("HufDecode issues")}}}const A=8-h&7;for(y>>=A,L-=A;L>0;){const F=e[y<<x-L&16383];if(!F.len)throw new Error("HufDecode issues");{L-=F.len;const e=E(F.lit,z,y,L,a,k,H,p,s);e&&(y=e.c,L=e.lc)}}}(Z,w,F,a,s,L,z,h,{value:0})}function N(F){return 65535&F}function n(F){const e=N(F);return e>32767?e-65536:e}function g(F,e){const a=n(F),k=n(e),h=a+(1&k)+(k>>1);return{a:h,b:h-k}}function i(F,e){const a=N(F),k=N(e),h=a-(k>>1)&65535;return{a:k+h-32768&65535,b:h}}function c(F,e,a,k,h,z,x){const t=x<16384,H=a>h?h:a;let p,y,L=1;for(;L<=H;)L<<=1;for(L>>=1,p=L,L>>=1;L>=1;){y=0;const x=y+z*(h-p),H=z*L,s=z*p,Z=k*L,A=k*p;let w,I,b,u;for(;y<=x;y+=s){let h=y;const z=y+k*(a-p);for(;h<=z;h+=A){const a=h+Z,k=h+H,z=k+Z;if(t){let x=g(F[h+e],F[k+e]);w=x.a,b=x.b,x=g(F[a+e],F[z+e]),I=x.a,u=x.b,x=g(w,I),F[h+e]=x.a,F[a+e]=x.b,x=g(b,u),F[k+e]=x.a,F[z+e]=x.b}else{let x=i(F[h+e],F[k+e]);w=x.a,b=x.b,x=i(F[a+e],F[z+e]),I=x.a,u=x.b,x=i(w,I),F[h+e]=x.a,F[a+e]=x.b,x=i(b,u),F[k+e]=x.a,F[z+e]=x.b}}if(a&L){const a=h+H;let k;k=t?g(F[h+e],F[a+e]):i(F[h+e],F[a+e]),w=k.a,F[a+e]=k.b,F[h+e]=w}}if(h&L){let h=y;const z=y+k*(a-p);for(;h<=z;h+=A){const a=h+Z;let k;k=t?g(F[h+e],F[a+e]):i(F[h+e],F[a+e]),w=k.a,F[a+e]=k.b,F[h+e]=w}}p=L,L>>=1}return y}function K(F){return new DataView(F.array.buffer,F.offset.value,F.size)}function T(F){const e=F.viewer.buffer.slice(F.offset.value,F.offset.value+F.size),a=new Uint8Array(function(F){let e=F.byteLength;const a=new Array;let k=0;const h=new DataView(F);for(;e>0;){const F=h.getInt8(k++);if(F<0){const z=-F;e-=z+1;for(let F=0;F<z;F++)a.push(h.getUint8(k++))}else{const z=F;e-=2;const x=h.getUint8(k++);for(let F=0;F<z+1;F++)a.push(x)}}return a}(e)),k=new Uint8Array(a.length);return Q(a),q(a,k),new DataView(k.buffer)}function D(F){const e=F.array.slice(F.offset.value,F.offset.value+F.size),a=fflate.unzlibSync(e),k=new Uint8Array(a.length);return Q(a),q(a,k),new DataView(k.buffer)}function U(F){const e=F.array.slice(F.offset.value,F.offset.value+F.size),a=fflate.unzlibSync(e),k=F.lines*F.channels*F.width,h=1==F.type?new Uint16Array(k):new Uint32Array(k);let z=0,x=0;const t=new Array(4);for(let H=0;H<F.lines;H++)for(let e=0;e<F.channels;e++){let e=0;switch(F.type){case 1:t[0]=z,t[1]=t[0]+F.width,z=t[1]+F.width;for(let k=0;k<F.width;++k){e+=a[t[0]++]<<8|a[t[1]++],h[x]=e,x++}break;case 2:t[0]=z,t[1]=t[0]+F.width,t[2]=t[1]+F.width,z=t[2]+F.width;for(let k=0;k<F.width;++k){e+=a[t[0]++]<<24|a[t[1]++]<<16|a[t[2]++]<<8,h[x]=e,x++}}}return new DataView(h.buffer)}function S(F){const e=F.viewer,a={value:F.offset.value},k=new Uint16Array(F.width*F.scanlineBlockSize*(F.channels*F.type)),h=new Uint8Array(8192);let x=0;const t=new Array(F.channels);for(let z=0;z<F.channels;z++)t[z]={},t[z].start=x,t[z].end=t[z].start,t[z].nx=F.width,t[z].ny=F.lines,t[z].size=F.type,x+=t[z].nx*t[z].ny*t[z].size;const H=I(e,a),p=I(e,a);if(p>=8192)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(H<=p)for(let z=0;z<p-H+1;z++)h[z+H]=w(e,a);const y=new Uint16Array(z),L=function(F,e){let a=0;for(let h=0;h<z;++h)(0==h||F[h>>3]&1<<(7&h))&&(e[a++]=h);const k=a-1;for(;a<z;)e[a++]=0;return k}(h,y),s=A(e,a);R(F.array,e,a,s,k,x);for(let z=0;z<F.channels;++z){const F=t[z];for(let e=0;e<t[z].size;++e)c(k,F.start+e,F.nx,F.size,F.ny,F.nx*F.size,L)}!function(F,e,a){for(let k=0;k<a;++k)e[k]=F[e[k]]}(y,k,x);let Z=0;const b=new Uint8Array(k.buffer.byteLength);for(let z=0;z<F.lines;z++)for(let e=0;e<F.channels;e++){const F=t[e],a=F.nx*F.size,h=new Uint8Array(k.buffer,2*F.end,2*a);b.set(h,Z),Z+=2*a,F.end+=a}return new DataView(b.buffer)}var v,C=a(1220);!function(F){F[F.Float=0]="Float",F[F.HalfFloat=1]="HalfFloat"}(v||(v={}));class M{}M.DefaultOutputType=v.HalfFloat,M.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class X{constructor(){this.supportCascades=!1}loadCubeData(F,e,a,k,h){throw".exr not supported in Cube."}async loadData(F,e,a){const h=new DataView(F.buffer),z={value:0},x=function(F,e){if(20000630!=F.getUint32(0,!0))throw new Error("Incorrect OpenEXR format");const a=F.getUint8(4),h=F.getUint8(5),z={singleTile:!!(2&h),longName:!!(4&h),deepFormat:!!(8&h),multiPart:!!(16&h)};e.value=8;const x={};let t=!0;for(;t;){const a=s(F.buffer,e);if(a){const h=s(F.buffer,e),z=V(F,e,h,A(F,e));void 0===z?k.b.Warn(`Unknown header attribute type ${h}'.`):x[a]=z}else t=!1}if(0!=(-5&h))throw new Error("Unsupported file format");return{version:a,spec:z,...x}}(h,z),t=await async function(F,e,a,k){const h={size:0,viewer:e,array:new Uint8Array(e.buffer),offset:a,width:F.dataWindow.xMax-F.dataWindow.xMin+1,height:F.dataWindow.yMax-F.dataWindow.yMin+1,channels:F.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(F.compression){case p.NO_COMPRESSION:h.lines=1,h.uncompress=K;break;case p.RLE_COMPRESSION:h.lines=1,h.uncompress=T;break;case p.ZIPS_COMPRESSION:h.lines=1,h.uncompress=D,await C.c.LoadScriptAsync(M.FFLATEUrl);break;case p.ZIP_COMPRESSION:h.lines=16,h.uncompress=D,await C.c.LoadScriptAsync(M.FFLATEUrl);break;case p.PIZ_COMPRESSION:h.lines=32,h.uncompress=S;break;case p.PXR24_COMPRESSION:h.lines=16,h.uncompress=U,await C.c.LoadScriptAsync(M.FFLATEUrl);break;default:throw new Error(p[F.compression]+" is unsupported")}h.scanlineBlockSize=h.lines;const z={};for(const p of F.channels)switch(p.name){case"Y":case"R":case"G":case"B":case"A":z[p.name]=!0,h.type=p.pixelType}let x=!1;if(z.R&&z.G&&z.B)x=!z.A,h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else{if(!z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");h.outputChannels=1,h.decodeChannels={Y:0}}if(1===h.type)switch(k){case v.Float:h.getter=O,h.inputSize=2;break;case v.HalfFloat:h.getter=I,h.inputSize=2}else{if(2!==h.type)throw new Error("Unsupported pixelType "+h.type+" for "+F.compression);switch(k){case v.Float:h.getter=r,h.inputSize=4;break;case v.HalfFloat:h.getter=j,h.inputSize=4}}h.blockCount=h.height/h.scanlineBlockSize;for(let p=0;p<h.blockCount;p++)u(e,a);const t=h.width*h.height*h.outputChannels;switch(k){case v.Float:h.byteArray=new Float32Array(t),h.textureType=1,x&&h.byteArray.fill(1,0,t);break;case v.HalfFloat:h.byteArray=new Uint16Array(t),h.textureType=2,x&&h.byteArray.fill(15360,0,t);break;default:throw new Error("Unsupported type: "+k)}let H=0;for(const p of F.channels)void 0!==h.decodeChannels[p.name]&&(h.channelLineOffsets[p.name]=H*h.width),H+=2*p.pixelType;return h.bytesPerLine=h.width*H,h.outLineWidth=h.width*h.outputChannels,"INCREASING_Y"===F.lineOrder?h.scanOrder=F=>F:h.scanOrder=F=>h.height-1-F,4==h.outputChannels?(h.format=5,h.linearSpace=!0):(h.format=6,h.linearSpace=!1),h}(x,h,z,M.DefaultOutputType);!function(F,e,a,k){const h={value:0};for(let z=0;z<F.height/F.scanlineBlockSize;z++){const x=Z(a,k)-e.dataWindow.yMin;F.size=A(a,k),F.lines=x+F.scanlineBlockSize>F.height?F.height-x:F.scanlineBlockSize;const t=F.size<F.lines*F.bytesPerLine&&F.uncompress?F.uncompress(F):K(F);k.value+=F.size;for(let a=0;a<F.scanlineBlockSize;a++){const k=z*F.scanlineBlockSize,x=a+F.scanOrder(k);if(x>=F.height)continue;const H=a*F.bytesPerLine,p=(F.height-1-x)*F.outLineWidth;for(let a=0;a<F.channels;a++){const k=e.channels[a].name,z=F.channelLineOffsets[k],x=F.decodeChannels[k];if(void 0!==x){h.value=H+z;for(let e=0;e<F.width;e++){const a=p+e*F.outputChannels+x;F.byteArray&&(F.byteArray[a]=F.getter(t,h))}}}}}}(t,x,h,z);a(x.dataWindow.xMax-x.dataWindow.xMin+1,x.dataWindow.yMax-x.dataWindow.yMin+1,e.generateMipMaps,!1,(()=>{const F=e.getEngine();e.format=x.format,e.type=t.textureType,e.invertY=!1,e._gammaSpace=!x.linearSpace,t.byteArray&&F._uploadDataToTextureDirectly(e,t.byteArray,0,0,void 0,!0)}))}}}}]);