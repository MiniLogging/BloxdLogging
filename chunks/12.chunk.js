"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[12],{13017:(y,g,f)=>{f.r(g),f.d(g,{_DDSTextureLoader:()=>k});var p=f(11555),S=f(11568);class k{constructor(){this.supportCascades=!0}loadCubeData(y,g,f,k){const i=g.getEngine();let H,U=!1,l=1e3;if(Array.isArray(y))for(let p=0;p<y.length;p++){const f=y[p];H=S.d.GetDDSInfo(f),g.width=H.width,g.height=H.height,U=(H.isRGB||H.isLuminance||H.mipmapCount>1)&&g.generateMipMaps,i._unpackFlipY(H.isCompressed),S.d.UploadDDSLevels(i,g,f,H,U,6,-1,p),H.isFourCC||1!==H.mipmapCount?l=H.mipmapCount-1:i.generateMipMapsForCubemap(g)}else{const k=y;H=S.d.GetDDSInfo(k),g.width=H.width,g.height=H.height,f&&(H.sphericalPolynomial=new p.f),U=(H.isRGB||H.isLuminance||H.mipmapCount>1)&&g.generateMipMaps,i._unpackFlipY(H.isCompressed),S.d.UploadDDSLevels(i,g,k,H,U,6),H.isFourCC||1!==H.mipmapCount?l=H.mipmapCount-1:i.generateMipMapsForCubemap(g,!1)}i._setCubeMapTextureParams(g,U,l),g.isReady=!0,g.onLoadedObservable.notifyObservers(g),g.onLoadedObservable.clear(),k&&k({isDDS:!0,width:g.width,info:H,data:y,texture:g})}loadData(y,g,f){const p=S.d.GetDDSInfo(y),k=(p.isRGB||p.isLuminance||p.mipmapCount>1)&&g.generateMipMaps&&Math.max(p.width,p.height)>>p.mipmapCount-1===1;f(p.width,p.height,k,p.isFourCC,(()=>{S.d.UploadDDSLevels(g.getEngine(),g,y,p,k,1)}))}}}}]);