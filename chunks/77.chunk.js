"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14619:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphJsonPointerParserBlock:()=>n});var k=H(13244),c=H(13246);const t=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class A{constructor(R,x){this.path=R,this.ownerBlock=x,this.templatedInputs=[];let H=t.exec(R);const A=new Set;for(;H;){const[,D]=H;if(A.has(D))throw new Error("Duplicate template variable detected.");A.add(D),this.templatedInputs.push(x.registerDataInput(D,c.d,new k.e(0))),H=t.exec(R)}}getAccessor(R,x){let H=this.path;for(const k of this.templatedInputs){const R=k.getValue(x).value;if("number"!==typeof R||R<0)throw new Error("Invalid value for templated input.");H=H.replace(`{${k.name}}`,R.toString())}return R.convert(H)}}var D=H(610),U=H(661),J=H(695),V=H(14472);class n extends V.c{constructor(R){super(c.b,R),this.config=R,this.object=this.registerDataOutput("object",c.b),this.propertyName=this.registerDataOutput("propertyName",c.b),this.setterFunction=this.registerDataOutput("setFunction",c.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",c.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",c.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new A(R.jsonPointer,this)}_doOperation(R){var x,H,k;const c=this.templateComponent.getAccessor(this.config.pathConverter,R),t=c.info.get(c.object),A=null===(x=(H=c.info).getTarget)||void 0===x?void 0:x.call(H,c.object),D=null===(k=c.info.getPropertyName)||void 0===k?void 0:k[0](c.object);if(!A)throw new Error("Object is undefined");return this.object.setValue(A,R),D&&this.propertyName.setValue(D,R),t}_setPropertyValue(R,x,H,k){var c,t;const A=this.templateComponent.getAccessor(this.config.pathConverter,k),D=A.info.type;D.startsWith("Color")&&(H=g(H,D)),null===(c=(t=A.info).set)||void 0===c||c.call(t,H,A.object)}_getPropertyValue(R,x,H){const k=this.templateComponent.getAccessor(this.config.pathConverter,H),c=k.info.type,t=k.info.get(k.object);return c.startsWith("Color")?function(R){if(R instanceof J.c)return new U.o(R.r,R.g,R.b);if(R instanceof J.d)return new U.p(R.r,R.g,R.b,R.a);throw new Error("Invalid color type")}(t):t}_getInterpolationAnimationPropertyInfo(R,x,H){const k=this.templateComponent.getAccessor(this.config.pathConverter,H);return(R,x,H,c)=>{var t;const A=[],D=k.info.type;return D.startsWith("Color")&&(R=R.map((R=>({frame:R.frame,value:g(R.value,D)})))),null===(t=k.info.interpolation)||void 0===t||t.forEach(((x,t)=>{var D;const U=(null===(D=k.info.getPropertyName)||void 0===D?void 0:D[t](k.object))||"Animation-interpolation-"+t;let J=R;H!==x.type&&(J=R.map((R=>({frame:R.frame,value:x.getValue(void 0,R.value.Li?R.value.Li():[R.value],0,1)}))));const V=x.buildAnimations(k.object,U,60,J);for(const R of V)c&&R.babylonAnimation.setEasingFunction(c),A.push(R.babylonAnimation)})),A}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function g(R,x){return R.getClassName().startsWith("Color")?R:"fj"===x?new J.c(R.x,R.y,R.z):"gj"===x?new J.d(R.x,R.y,R.z,R.w):R}(0,D.h)("FlowGraphJsonPointerParserBlock",n)},14472:(R,x,H)=>{H.d(x,{c:()=>D});var k=H(13268),c=H(13246);const t="cachedOperationValue",A="cachedExecutionId";class D extends k.b{constructor(R,x){super(x),this.value=this.registerDataOutput("value",R),this.isValid=this.registerDataOutput("isValid",c.c)}_updateOutputs(R){const x=R._getExecutionVariable(this,A,-1),H=R._getExecutionVariable(this,t,null);if(void 0!==H&&null!==H&&x===R.executionId)this.isValid.setValue(!0,R),this.value.setValue(H,R);else try{const x=this._doOperation(R);if(void 0===x||null===x)return void this.isValid.setValue(!1,R);R._setExecutionVariable(this,t,x),R._setExecutionVariable(this,A,R.executionId),this.value.setValue(x,R),this.isValid.setValue(!0,R)}catch(k){this.isValid.setValue(!1,R)}}}}}]);