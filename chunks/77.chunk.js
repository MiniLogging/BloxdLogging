"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14323:(t,q,S)=>{S.r(q),S.d(q,{FlowGraphJsonPointerParserBlock:()=>b});var o=S(12922),B=S(12927);const z=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class L{constructor(t,q){this.path=t,this.ownerBlock=q,this.templatedInputs=[];let S=z.exec(t);const L=new Set;for(;S;){const[,r]=S;if(L.has(r))throw new Error("Duplicate template variable detected.");L.add(r),this.templatedInputs.push(q.registerDataInput(r,B.h,new o.e(0))),S=z.exec(t)}}getAccessor(t,q){let S=this.path;for(const o of this.templatedInputs){const t=o.getValue(q).value;if("number"!==typeof t||t<0)throw new Error("Invalid value for templated input.");S=S.replace(`{${o.name}}`,t.toString())}return t.convert(S)}}var r=S(622),e=S(678),C=S(706),Z=S(14163);class b extends Z.c{constructor(t){super(B.b,t),this.config=t,this.object=this.registerDataOutput("object",B.b),this.propertyName=this.registerDataOutput("propertyName",B.b),this.setterFunction=this.registerDataOutput("setFunction",B.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",B.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",B.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new L(t.jsonPointer,this)}_doOperation(t){var q,S,o;const B=this.templateComponent.getAccessor(this.config.pathConverter,t),z=B.info.get(B.object),L=null===(q=(S=B.info).getTarget)||void 0===q?void 0:q.call(S,B.object),r=null===(o=B.info.getPropertyName)||void 0===o?void 0:o[0](B.object);if(!L)throw new Error("Object is undefined");return this.object.setValue(L,t),r&&this.propertyName.setValue(r,t),z}_setPropertyValue(t,q,S,o){var B,z;const L=this.templateComponent.getAccessor(this.config.pathConverter,o),r=L.info.type;r.startsWith("Color")&&(S=O(S,r)),null===(B=(z=L.info).set)||void 0===B||B.call(z,S,L.object)}_getPropertyValue(t,q,S){const o=this.templateComponent.getAccessor(this.config.pathConverter,S),B=o.info.type,z=o.info.get(o.object);return B.startsWith("Color")?function(t){if(t instanceof C.c)return new e.o(t.r,t.g,t.b);if(t instanceof C.d)return new e.s(t.r,t.g,t.b,t.a);throw new Error("Invalid color type")}(z):z}_getInterpolationAnimationPropertyInfo(t,q,S){const o=this.templateComponent.getAccessor(this.config.pathConverter,S);return(t,q,S,B)=>{var z;const L=[],r=o.info.type;return r.startsWith("Color")&&(t=t.map((t=>({frame:t.frame,value:O(t.value,r)})))),null===(z=o.info.interpolation)||void 0===z||z.forEach(((q,z)=>{var r;const e=(null===(r=o.info.getPropertyName)||void 0===r?void 0:r[z](o.object))||"Animation-interpolation-"+z;let C=t;S!==q.type&&(C=t.map((t=>({frame:t.frame,value:q.getValue(void 0,t.value.Gi?t.value.Gi():[t.value],0,1)}))));const Z=q.buildAnimations(o.object,e,60,C);for(const t of Z)B&&t.babylonAnimation.setEasingFunction(B),L.push(t.babylonAnimation)})),L}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function O(t,q){return t.getClassName().startsWith("Color")?t:"aj"===q?new C.c(t.x,t.y,t.z):"bj"===q?new C.d(t.x,t.y,t.z,t.w):t}(0,r.c)("FlowGraphJsonPointerParserBlock",b)},14163:(t,q,S)=>{S.d(q,{c:()=>r});var o=S(12946),B=S(12927);const z="cachedOperationValue",L="cachedExecutionId";class r extends o.d{constructor(t,q){super(q),this.value=this.registerDataOutput("value",t),this.isValid=this.registerDataOutput("isValid",B.f)}_updateOutputs(t){const q=t._getExecutionVariable(this,L,-1),S=t._getExecutionVariable(this,z,null);if(void 0!==S&&null!==S&&q===t.executionId)this.isValid.setValue(!0,t),this.value.setValue(S,t);else try{const q=this._doOperation(t);if(void 0===q||null===q)return void this.isValid.setValue(!1,t);t._setExecutionVariable(this,z,q),t._setExecutionVariable(this,L,t.executionId),this.value.setValue(q,t),this.isValid.setValue(!0,t)}catch(o){this.isValid.setValue(!1,t)}}}}}]);