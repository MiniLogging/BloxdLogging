"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14121:(U,W,l)=>{l.r(W),l.d(W,{FlowGraphJsonPointerParserBlock:()=>y});var M=l(12699),t=l(12704);const L=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class p{constructor(U,W){this.path=U,this.ownerBlock=W,this.templatedInputs=[];let l=L.exec(U);const p=new Set;for(;l;){const[,B]=l;if(p.has(B))throw new Error("Duplicate template variable detected.");p.add(B),this.templatedInputs.push(W.registerDataInput(B,t.k,new M.d(0))),l=L.exec(U)}}getAccessor(U,W){let l=this.path;for(const M of this.templatedInputs){const U=M.getValue(W).value;if("number"!==typeof U||U<0)throw new Error("Invalid value for templated input.");l=l.replace(`{${M.name}}`,U.toString())}return U.convert(l)}}var B=l(655),k=l(706),A=l(742),q=l(13983);class y extends q.c{constructor(U){super(t.d,U),this.config=U,this.object=this.registerDataOutput("object",t.d),this.propertyName=this.registerDataOutput("propertyName",t.d),this.setterFunction=this.registerDataOutput("setFunction",t.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",t.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",t.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new p(U.jsonPointer,this)}_doOperation(U){var W,l,M;const t=this.templateComponent.getAccessor(this.config.pathConverter,U),L=t.info.get(t.object),p=null===(W=(l=t.info).getTarget)||void 0===W?void 0:W.call(l,t.object),B=null===(M=t.info.getPropertyName)||void 0===M?void 0:M[0](t.object);if(!p)throw new Error("Object is undefined");return this.object.setValue(p,U),B&&this.propertyName.setValue(B,U),L}_setPropertyValue(U,W,l,M){var t,L;const p=this.templateComponent.getAccessor(this.config.pathConverter,M),B=p.info.type;B.startsWith("Color")&&(l=j(l,B)),null===(t=(L=p.info).set)||void 0===t||t.call(L,l,p.object)}_getPropertyValue(U,W,l){const M=this.templateComponent.getAccessor(this.config.pathConverter,l),t=M.info.type,L=M.info.get(M.object);return t.startsWith("Color")?function(U){if(U instanceof A.e)return new k.l(U.r,U.g,U.b);if(U instanceof A.f)return new k.p(U.r,U.g,U.b,U.a);throw new Error("Invalid color type")}(L):L}_getInterpolationAnimationPropertyInfo(U,W,l){const M=this.templateComponent.getAccessor(this.config.pathConverter,l);return(U,W,l,t)=>{var L;const p=[],B=M.info.type;return B.startsWith("Color")&&(U=U.map((U=>({frame:U.frame,value:j(U.value,B)})))),null===(L=M.info.interpolation)||void 0===L||L.forEach(((W,L)=>{var B;const k=(null===(B=M.info.getPropertyName)||void 0===B?void 0:B[L](M.object))||"Animation-interpolation-"+L;let A=U;l!==W.type&&(A=U.map((U=>({frame:U.frame,value:W.getValue(void 0,U.value.qk?U.value.qk():[U.value],0,1)}))));const q=W.buildAnimations(M.object,k,60,A);for(const U of q)t&&U.babylonAnimation.setEasingFunction(t),p.push(U.babylonAnimation)})),p}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function j(U,W){return U.getClassName().startsWith("Color")?U:"zk"===W?new A.e(U.x,U.y,U.z):"Ak"===W?new A.f(U.x,U.y,U.z,U.w):U}(0,B.f)("FlowGraphJsonPointerParserBlock",y)},13983:(U,W,l)=>{l.d(W,{c:()=>B});var M=l(12739),t=l(12704);const L="cachedOperationValue",p="cachedExecutionId";class B extends M.e{constructor(U,W){super(W),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",t.h)}_updateOutputs(U){const W=U._getExecutionVariable(this,p,-1),l=U._getExecutionVariable(this,L,null);if(void 0!==l&&null!==l&&W===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(l,U);else try{const W=this._doOperation(U);if(void 0===W||null===W)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,L,W),U._setExecutionVariable(this,p,U.executionId),this.value.setValue(W,U),this.isValid.setValue(!0,U)}catch(M){this.isValid.setValue(!1,U)}}}}}]);