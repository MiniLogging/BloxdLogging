"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14338:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphJsonPointerParserBlock:()=>y});var n=Q(12904),T=Q(12908);const L=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class e{constructor(v,d){this.path=v,this.ownerBlock=d,this.templatedInputs=[];let Q=L.exec(v);const e=new Set;for(;Q;){const[,F]=Q;if(e.has(F))throw new Error("Duplicate template variable detected.");e.add(F),this.templatedInputs.push(d.registerDataInput(F,T.h,new n.b(0))),Q=L.exec(v)}}getAccessor(v,d){let Q=this.path;for(const n of this.templatedInputs){const v=n.getValue(d).value;if("number"!==typeof v||v<0)throw new Error("Invalid value for templated input.");Q=Q.replace(`{${n.name}}`,v.toString())}return v.convert(Q)}}var F=Q(591),r=Q(651),C=Q(686),u=Q(14208);class y extends u.c{constructor(v){super(T.c,v),this.config=v,this.object=this.registerDataOutput("object",T.c),this.propertyName=this.registerDataOutput("propertyName",T.c),this.setterFunction=this.registerDataOutput("setFunction",T.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",T.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",T.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new e(v.jsonPointer,this)}_doOperation(v){var d,Q,n;const T=this.templateComponent.getAccessor(this.config.pathConverter,v),L=T.info.get(T.object),e=null===(d=(Q=T.info).getTarget)||void 0===d?void 0:d.call(Q,T.object),F=null===(n=T.info.getPropertyName)||void 0===n?void 0:n[0](T.object);if(!e)throw new Error("Object is undefined");return this.object.setValue(e,v),F&&this.propertyName.setValue(F,v),L}_setPropertyValue(v,d,Q,n){var T,L;const e=this.templateComponent.getAccessor(this.config.pathConverter,n),F=e.info.type;F.startsWith("Color")&&(Q=z(Q,F)),null===(T=(L=e.info).set)||void 0===T||T.call(L,Q,e.object)}_getPropertyValue(v,d,Q){const n=this.templateComponent.getAccessor(this.config.pathConverter,Q),T=n.info.type,L=n.info.get(n.object);return T.startsWith("Color")?function(v){if(v instanceof C.c)return new r.j(v.r,v.g,v.b);if(v instanceof C.f)return new r.k(v.r,v.g,v.b,v.a);throw new Error("Invalid color type")}(L):L}_getInterpolationAnimationPropertyInfo(v,d,Q){const n=this.templateComponent.getAccessor(this.config.pathConverter,Q);return(v,d,Q,T)=>{var L;const e=[],F=n.info.type;return F.startsWith("Color")&&(v=v.map((v=>({frame:v.frame,value:z(v.value,F)})))),null===(L=n.info.interpolation)||void 0===L||L.forEach(((d,L)=>{var F;const r=(null===(F=n.info.getPropertyName)||void 0===F?void 0:F[L](n.object))||"Animation-interpolation-"+L;let C=v;Q!==d.type&&(C=v.map((v=>({frame:v.frame,value:d.getValue(void 0,v.value.mk?v.value.mk():[v.value],0,1)}))));const u=d.buildAnimations(n.object,r,60,C);for(const v of u)T&&v.babylonAnimation.setEasingFunction(T),e.push(v.babylonAnimation)})),e}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function z(v,d){return v.getClassName().startsWith("Color")?v:"wk"===d?new C.c(v.x,v.y,v.z):"xk"===d?new C.f(v.x,v.y,v.z,v.w):v}(0,F.f)("FlowGraphJsonPointerParserBlock",y)},14208:(v,d,Q)=>{Q.d(d,{c:()=>F});var n=Q(12934),T=Q(12908);const L="cachedOperationValue",e="cachedExecutionId";class F extends n.b{constructor(v,d){super(d),this.value=this.registerDataOutput("value",v),this.isValid=this.registerDataOutput("isValid",T.f)}_updateOutputs(v){const d=v._getExecutionVariable(this,e,-1),Q=v._getExecutionVariable(this,L,null);if(void 0!==Q&&null!==Q&&d===v.executionId)this.isValid.setValue(!0,v),this.value.setValue(Q,v);else try{const d=this._doOperation(v);if(void 0===d||null===d)return void this.isValid.setValue(!1,v);v._setExecutionVariable(this,L,d),v._setExecutionVariable(this,e,v.executionId),this.value.setValue(d,v),this.isValid.setValue(!0,v)}catch(n){this.isValid.setValue(!1,v)}}}}}]);