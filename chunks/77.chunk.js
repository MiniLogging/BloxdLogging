"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{13896:(L,j,P)=>{P.r(j),P.d(j,{FlowGraphJsonPointerParserBlock:()=>g});var A=P(12506),R=P(12510);const o=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class Y{constructor(L,j){this.path=L,this.ownerBlock=j,this.templatedInputs=[];let P=o.exec(L);const Y=new Set;for(;P;){const[,u]=P;if(Y.has(u))throw new Error("Duplicate template variable detected.");Y.add(u),this.templatedInputs.push(j.registerDataInput(u,R.f,new A.b(0))),P=o.exec(L)}}getAccessor(L,j){let P=this.path;for(const A of this.templatedInputs){const L=A.getValue(j).value;if("number"!==typeof L||L<0)throw new Error("Invalid value for templated input.");P=P.replace(`{${A.name}}`,L.toString())}return L.convert(P)}}var u=P(606),a=P(656),D=P(685),S=P(13762);class g extends S.b{constructor(L){super(R.d,L),this.config=L,this.object=this.registerDataOutput("object",R.d),this.propertyName=this.registerDataOutput("propertyName",R.d),this.setterFunction=this.registerDataOutput("setFunction",R.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",R.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",R.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new Y(L.jsonPointer,this)}_doOperation(L){var j,P,A;const R=this.templateComponent.getAccessor(this.config.pathConverter,L),o=R.info.get(R.object),Y=null===(j=(P=R.info).getTarget)||void 0===j?void 0:j.call(P,R.object),u=null===(A=R.info.getPropertyName)||void 0===A?void 0:A[0](R.object);if(!Y)throw new Error("Object is undefined");return this.object.setValue(Y,L),u&&this.propertyName.setValue(u,L),o}_setPropertyValue(L,j,P,A){var R,o;const Y=this.templateComponent.getAccessor(this.config.pathConverter,A),u=Y.info.type;u.startsWith("Color")&&(P=V(P,u)),null===(R=(o=Y.info).set)||void 0===R||R.call(o,P,Y.object)}_getPropertyValue(L,j,P){const A=this.templateComponent.getAccessor(this.config.pathConverter,P),R=A.info.type,o=A.info.get(A.object);return R.startsWith("Color")?function(L){if(L instanceof D.e)return new a.r(L.r,L.g,L.b);if(L instanceof D.i)return new a.s(L.r,L.g,L.b,L.a);throw new Error("Invalid color type")}(o):o}_getInterpolationAnimationPropertyInfo(L,j,P){const A=this.templateComponent.getAccessor(this.config.pathConverter,P);return(L,j,P,R)=>{var o;const Y=[],u=A.info.type;return u.startsWith("Color")&&(L=L.map((L=>({frame:L.frame,value:V(L.value,u)})))),null===(o=A.info.interpolation)||void 0===o||o.forEach(((j,o)=>{var u;const a=(null===(u=A.info.getPropertyName)||void 0===u?void 0:u[o](A.object))||"Animation-interpolation-"+o;let D=L;P!==j.type&&(D=L.map((L=>({frame:L.frame,value:j.getValue(void 0,L.value.Ei?L.value.Ei():[L.value],0,1)}))));const S=j.buildAnimations(A.object,a,60,D);for(const L of S)R&&L.babylonAnimation.setEasingFunction(R),Y.push(L.babylonAnimation)})),Y}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function V(L,j){return L.getClassName().startsWith("Color")?L:"Zi"===j?new D.e(L.x,L.y,L.z):"_i"===j?new D.i(L.x,L.y,L.z,L.w):L}(0,u.h)("FlowGraphJsonPointerParserBlock",g)},13762:(L,j,P)=>{P.d(j,{b:()=>u});var A=P(12523),R=P(12510);const o="cachedOperationValue",Y="cachedExecutionId";class u extends A.d{constructor(L,j){super(j),this.value=this.registerDataOutput("value",L),this.isValid=this.registerDataOutput("isValid",R.e)}_updateOutputs(L){const j=L._getExecutionVariable(this,Y,-1),P=L._getExecutionVariable(this,o,null);if(void 0!==P&&null!==P&&j===L.executionId)this.isValid.setValue(!0,L),this.value.setValue(P,L);else try{const j=this._doOperation(L);if(void 0===j||null===j)return void this.isValid.setValue(!1,L);L._setExecutionVariable(this,o,j),L._setExecutionVariable(this,Y,L.executionId),this.value.setValue(j,L),this.isValid.setValue(!0,L)}catch(A){this.isValid.setValue(!1,L)}}}}}]);