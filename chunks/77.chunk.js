"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14217:(Z,U,n)=>{n.r(U),n.d(U,{FlowGraphJsonPointerParserBlock:()=>F});var i=n(12817),B=n(12826);const l=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class H{constructor(Z,U){this.path=Z,this.ownerBlock=U,this.templatedInputs=[];let n=l.exec(Z);const H=new Set;for(;n;){const[,V]=n;if(H.has(V))throw new Error("Duplicate template variable detected.");H.add(V),this.templatedInputs.push(U.registerDataInput(V,B.g,new i.d(0))),n=l.exec(Z)}}getAccessor(Z,U){let n=this.path;for(const i of this.templatedInputs){const Z=i.getValue(U).value;if("number"!==typeof Z||Z<0)throw new Error("Invalid value for templated input.");n=n.replace(`{${i.name}}`,Z.toString())}return Z.convert(n)}}var V=n(633),G=n(702),R=n(739),d=n(14076);class F extends d.d{constructor(Z){super(B.b,Z),this.config=Z,this.object=this.registerDataOutput("object",B.b),this.propertyName=this.registerDataOutput("propertyName",B.b),this.setterFunction=this.registerDataOutput("setFunction",B.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",B.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",B.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new H(Z.jsonPointer,this)}_doOperation(Z){var U,n,i;const B=this.templateComponent.getAccessor(this.config.pathConverter,Z),l=B.info.get(B.object),H=null===(U=(n=B.info).getTarget)||void 0===U?void 0:U.call(n,B.object),V=null===(i=B.info.getPropertyName)||void 0===i?void 0:i[0](B.object);if(!H)throw new Error("Object is undefined");return this.object.setValue(H,Z),V&&this.propertyName.setValue(V,Z),l}_setPropertyValue(Z,U,n,i){var B,l;const H=this.templateComponent.getAccessor(this.config.pathConverter,i),V=H.info.type;V.startsWith("Color")&&(n=y(n,V)),null===(B=(l=H.info).set)||void 0===B||B.call(l,n,H.object)}_getPropertyValue(Z,U,n){const i=this.templateComponent.getAccessor(this.config.pathConverter,n),B=i.info.type,l=i.info.get(i.object);return B.startsWith("Color")?function(Z){if(Z instanceof R.b)return new G.k(Z.r,Z.g,Z.b);if(Z instanceof R.d)return new G.o(Z.r,Z.g,Z.b,Z.a);throw new Error("Invalid color type")}(l):l}_getInterpolationAnimationPropertyInfo(Z,U,n){const i=this.templateComponent.getAccessor(this.config.pathConverter,n);return(Z,U,n,B)=>{var l;const H=[],V=i.info.type;return V.startsWith("Color")&&(Z=Z.map((Z=>({frame:Z.frame,value:y(Z.value,V)})))),null===(l=i.info.interpolation)||void 0===l||l.forEach(((U,l)=>{var V;const G=(null===(V=i.info.getPropertyName)||void 0===V?void 0:V[l](i.object))||"Animation-interpolation-"+l;let R=Z;n!==U.type&&(R=Z.map((Z=>({frame:Z.frame,value:U.getValue(void 0,Z.value.Ei?Z.value.Ei():[Z.value],0,1)}))));const d=U.buildAnimations(i.object,G,60,R);for(const Z of d)B&&Z.babylonAnimation.setEasingFunction(B),H.push(Z.babylonAnimation)})),H}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function y(Z,U){return Z.getClassName().startsWith("Color")?Z:"Zi"===U?new R.b(Z.x,Z.y,Z.z):"_i"===U?new R.d(Z.x,Z.y,Z.z,Z.w):Z}(0,V.g)("FlowGraphJsonPointerParserBlock",F)},14076:(Z,U,n)=>{n.d(U,{d:()=>V});var i=n(12837),B=n(12826);const l="cachedOperationValue",H="cachedExecutionId";class V extends i.b{constructor(Z,U){super(U),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",B.e)}_updateOutputs(Z){const U=Z._getExecutionVariable(this,H,-1),n=Z._getExecutionVariable(this,l,null);if(void 0!==n&&null!==n&&U===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(n,Z);else try{const U=this._doOperation(Z);if(void 0===U||null===U)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,l,U),Z._setExecutionVariable(this,H,Z.executionId),this.value.setValue(U,Z),this.isValid.setValue(!0,Z)}catch(i){this.isValid.setValue(!1,Z)}}}}}]);