"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[77],{14473:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphJsonPointerParserBlock:()=>L});var l=C(13060),h=C(13063);const M=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class f{constructor(Q,X){this.path=Q,this.ownerBlock=X,this.templatedInputs=[];let C=M.exec(Q);const f=new Set;for(;C;){const[,O]=C;if(f.has(O))throw new Error("Duplicate template variable detected.");f.add(O),this.templatedInputs.push(X.registerDataInput(O,h.f,new l.d(0))),C=M.exec(Q)}}getAccessor(Q,X){let C=this.path;for(const l of this.templatedInputs){const Q=l.getValue(X).value;if("number"!==typeof Q||Q<0)throw new Error("Invalid value for templated input.");C=C.replace(`{${l.name}}`,Q.toString())}return Q.convert(C)}}var O=C(620),m=C(668),W=C(702),U=C(14320);class L extends U.d{constructor(Q){super(h.d,Q),this.config=Q,this.object=this.registerDataOutput("object",h.d),this.propertyName=this.registerDataOutput("propertyName",h.d),this.setterFunction=this.registerDataOutput("setFunction",h.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",h.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",h.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new f(Q.jsonPointer,this)}_doOperation(Q){var X,C,l;const h=this.templateComponent.getAccessor(this.config.pathConverter,Q),M=h.info.get(h.object),f=null===(X=(C=h.info).getTarget)||void 0===X?void 0:X.call(C,h.object),O=null===(l=h.info.getPropertyName)||void 0===l?void 0:l[0](h.object);if(!f)throw new Error("Object is undefined");return this.object.setValue(f,Q),O&&this.propertyName.setValue(O,Q),M}_setPropertyValue(Q,X,C,l){var h,M;const f=this.templateComponent.getAccessor(this.config.pathConverter,l),O=f.info.type;O.startsWith("Color")&&(C=w(C,O)),null===(h=(M=f.info).set)||void 0===h||h.call(M,C,f.object)}_getPropertyValue(Q,X,C){const l=this.templateComponent.getAccessor(this.config.pathConverter,C),h=l.info.type,M=l.info.get(l.object);return h.startsWith("Color")?function(Q){if(Q instanceof W.b)return new m.k(Q.r,Q.g,Q.b);if(Q instanceof W.d)return new m.o(Q.r,Q.g,Q.b,Q.a);throw new Error("Invalid color type")}(M):M}_getInterpolationAnimationPropertyInfo(Q,X,C){const l=this.templateComponent.getAccessor(this.config.pathConverter,C);return(Q,X,C,h)=>{var M;const f=[],O=l.info.type;return O.startsWith("Color")&&(Q=Q.map((Q=>({frame:Q.frame,value:w(Q.value,O)})))),null===(M=l.info.interpolation)||void 0===M||M.forEach(((X,M)=>{var O;const m=(null===(O=l.info.getPropertyName)||void 0===O?void 0:O[M](l.object))||"Animation-interpolation-"+M;let W=Q;C!==X.type&&(W=Q.map((Q=>({frame:Q.frame,value:X.getValue(void 0,Q.value.dk?Q.value.dk():[Q.value],0,1)}))));const U=X.buildAnimations(l.object,m,60,W);for(const Q of U)h&&Q.babylonAnimation.setEasingFunction(h),f.push(Q.babylonAnimation)})),f}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function w(Q,X){return Q.getClassName().startsWith("Color")?Q:"mk"===X?new W.b(Q.x,Q.y,Q.z):"nk"===X?new W.d(Q.x,Q.y,Q.z,Q.w):Q}(0,O.g)("FlowGraphJsonPointerParserBlock",L)},14320:(Q,X,C)=>{C.d(X,{d:()=>O});var l=C(13092),h=C(13063);const M="cachedOperationValue",f="cachedExecutionId";class O extends l.c{constructor(Q,X){super(X),this.value=this.registerDataOutput("value",Q),this.isValid=this.registerDataOutput("isValid",h.e)}_updateOutputs(Q){const X=Q._getExecutionVariable(this,f,-1),C=Q._getExecutionVariable(this,M,null);if(void 0!==C&&null!==C&&X===Q.executionId)this.isValid.setValue(!0,Q),this.value.setValue(C,Q);else try{const X=this._doOperation(Q);if(void 0===X||null===X)return void this.isValid.setValue(!1,Q);Q._setExecutionVariable(this,M,X),Q._setExecutionVariable(this,f,Q.executionId),this.value.setValue(X,Q),this.isValid.setValue(!0,Q)}catch(l){this.isValid.setValue(!1,Q)}}}}}]);