"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[76],{14123:(q,c,U)=>{U.r(c),U.d(c,{FlowGraphSetDelayBlock:()=>u});var J,Q=U(12693),s=U(12648),g=U(10866);!function(q){q[q.INIT=0]="INIT",q[q.STARTED=1]="STARTED",q[q.ENDED=2]="ENDED"}(J||(J={}));class X{constructor(q){this.onEachCountObservable=new g.e,this.onTimerAbortedObservable=new g.e,this.onTimerEndedObservable=new g.e,this.onStateChangedObservable=new g.e,this._observer=null,this._breakOnNextTick=!1,this._tick=q=>{const c=Date.now();this._timer=c-this._startTime;const U={startTime:this._startTime,currentTime:c,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:q},J=this._breakOnNextTick||this._breakCondition(U);J||this._timer>=this._timeToEnd?this._stop(U,J):this.onEachCountObservable.notifyObservers(U)},this._setState(0),this._contextObservable=q.contextObservable,this._observableParameters=q.observableParameters??{},this._breakCondition=q.breakCondition??(()=>!1),this._timeToEnd=q.timeout,q.onEnded&&this.onTimerEndedObservable.add(q.onEnded),q.BD&&this.onEachCountObservable.add(q.BD),q.onAborted&&this.onTimerAbortedObservable.add(q.onAborted)}set breakCondition(q){this._breakCondition=q}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=q,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(q){this._state=q,this.onStateChangedObservable.notifyObservers(this._state)}_stop(q){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),c?this.onTimerAbortedObservable.notifyObservers(q):this.onTimerEndedObservable.notifyObservers(q)}}var n=U(10886),W=U(10850),D=U(12642);class u extends Q.d{constructor(q){super(q),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",s.t),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",s.i,new D.b(-1))}_preparePendingTasks(q){const c=this.duration.getValue(q);if(c<0||isNaN(c)||!isFinite(c))return this._reportError(q,"Invalid duration in SetDelay block");if(q._getGlobalContextVariable("activeDelays",0)>=u.MaxParallelDelayCount)return this._reportError(q,"Max parallel delays reached");const U=q._getGlobalContextVariable("lastDelayIndex",-1),J=q._getExecutionVariable(this,"pendingDelays",[]),Q=q.configuration.mc,s=new X({timeout:1e3*c,contextObservable:Q.onBeforeRenderObservable,onEnded:()=>this._onEnded(s,q)});s.start();const g=U+1;this.lastDelayIndex.setValue(new D.b(g),q),q._setGlobalContextVariable("lastDelayIndex",g),J[g]=s,q._setExecutionVariable(this,"pendingDelays",J),this._updateGlobalTimers(q)}_cancelPendingTasks(q){const c=q._getExecutionVariable(this,"pendingDelays",[]);for(const U of c)null===U||void 0===U||U.dispose();q._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new D.b(-1),q),this._updateGlobalTimers(q)}_execute(q,c){c!==this.cancel?(this._preparePendingTasks(q),this.out._activateSignal(q)):this._cancelPendingTasks(q)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(q,c){const U=c._getExecutionVariable(this,"pendingDelays",[]),J=U.indexOf(q);-1!==J?U.splice(J,1):n.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),c._removePendingBlock(this),this.done._activateSignal(c),this._updateGlobalTimers(c)}_updateGlobalTimers(q){const c=q._getExecutionVariable(this,"pendingDelays",[]),U=q._getGlobalContextVariable("pendingDelays",[]);for(let J=0;J<c.length;J++){if(!c[J])continue;const q=c[J];U[J]&&U[J]!==q?n.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):U[J]=q}q._setGlobalContextVariable("pendingDelays",U)}}u.MaxParallelDelayCount=100,(0,W.f)("FlowGraphSetDelayBlock",u)}}]);