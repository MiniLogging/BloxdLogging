"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[76],{14567:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphSetDelayBlock:()=>x});var J,R=W(13108),d=W(13071),k=W(11176);!function(G){G[G.INIT=0]="INIT",G[G.STARTED=1]="STARTED",G[G.ENDED=2]="ENDED"}(J||(J={}));class z{constructor(G){this.onEachCountObservable=new k.b,this.onTimerAbortedObservable=new k.b,this.onTimerEndedObservable=new k.b,this.onStateChangedObservable=new k.b,this._observer=null,this._breakOnNextTick=!1,this._tick=G=>{const V=Date.now();this._timer=V-this._startTime;const W={startTime:this._startTime,currentTime:V,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:G},J=this._breakOnNextTick||this._breakCondition(W);J||this._timer>=this._timeToEnd?this._stop(W,J):this.onEachCountObservable.notifyObservers(W)},this._setState(0),this._contextObservable=G.contextObservable,this._observableParameters=G.observableParameters??{},this._breakCondition=G.breakCondition??(()=>!1),this._timeToEnd=G.timeout,G.onEnded&&this.onTimerEndedObservable.add(G.onEnded),G.BA&&this.onEachCountObservable.add(G.BA),G.onAborted&&this.onTimerAbortedObservable.add(G.onAborted)}set breakCondition(G){this._breakCondition=G}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=G,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(G){this._state=G,this.onStateChangedObservable.notifyObservers(this._state)}_stop(G){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),V?this.onTimerAbortedObservable.notifyObservers(G):this.onTimerEndedObservable.notifyObservers(G)}}var X=W(11201),P=W(11159),A=W(13067);class x extends R.c{constructor(G){super(G),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",d.r),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",d.h,new A.e(-1))}_preparePendingTasks(G){const V=this.duration.getValue(G);if(V<0||isNaN(V)||!isFinite(V))return this._reportError(G,"Invalid duration in SetDelay block");if(G._getGlobalContextVariable("activeDelays",0)>=x.MaxParallelDelayCount)return this._reportError(G,"Max parallel delays reached");const W=G._getGlobalContextVariable("lastDelayIndex",-1),J=G._getExecutionVariable(this,"pendingDelays",[]),R=G.configuration.tV,d=new z({timeout:1e3*V,contextObservable:R.onBeforeRenderObservable,onEnded:()=>this._onEnded(d,G)});d.start();const k=W+1;this.lastDelayIndex.setValue(new A.e(k),G),G._setGlobalContextVariable("lastDelayIndex",k),J[k]=d,G._setExecutionVariable(this,"pendingDelays",J),this._updateGlobalTimers(G)}_cancelPendingTasks(G){const V=G._getExecutionVariable(this,"pendingDelays",[]);for(const W of V)null===W||void 0===W||W.dispose();G._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new A.e(-1),G),this._updateGlobalTimers(G)}_execute(G,V){V!==this.cancel?(this._preparePendingTasks(G),this.out._activateSignal(G)):this._cancelPendingTasks(G)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(G,V){const W=V._getExecutionVariable(this,"pendingDelays",[]),J=W.indexOf(G);-1!==J?W.splice(J,1):X.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),V._removePendingBlock(this),this.done._activateSignal(V),this._updateGlobalTimers(V)}_updateGlobalTimers(G){const V=G._getExecutionVariable(this,"pendingDelays",[]),W=G._getGlobalContextVariable("pendingDelays",[]);for(let J=0;J<V.length;J++){if(!V[J])continue;const G=V[J];W[J]&&W[J]!==G?X.c.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):W[J]=G}G._setGlobalContextVariable("pendingDelays",W)}}x.MaxParallelDelayCount=100,(0,P.d)("FlowGraphSetDelayBlock",x)}}]);