"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14315:(q,f,j)=>{j.r(f),j.d(f,{FlowGraphJsonPointerParserBlock:()=>X});var d=j(12704),g=j(12709);const h=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class L{constructor(q,f){this.path=q,this.ownerBlock=f,this.templatedInputs=[];let j=h.exec(q);const L=new Set;for(;j;){const[,Q]=j;if(L.has(Q))throw new Error("Duplicate template variable detected.");L.add(Q),this.templatedInputs.push(f.registerDataInput(Q,g.e,new d.c(0))),j=h.exec(q)}}getAccessor(q,f){let j=this.path;for(const d of this.templatedInputs){const q=d.getValue(f).value;if("number"!==typeof q||q<0)throw new Error("Invalid value for templated input.");j=j.replace(`{${d.name}}`,q.toString())}return q.convert(j)}}var Q=j(10965),H=j(10941),r=j(11210),u=j(14173);class X extends u.d{constructor(q){super(g.c,q),this.config=q,this.object=this.registerDataOutput("object",g.c),this.propertyName=this.registerDataOutput("propertyName",g.c),this.setterFunction=this.registerDataOutput("setFunction",g.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",g.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",g.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new L(q.jsonPointer,this)}_doOperation(q){var f,j,d;const g=this.templateComponent.getAccessor(this.config.pathConverter,q),h=g.info.get(g.object),L=null===(f=(j=g.info).getTarget)||void 0===f?void 0:f.call(j,g.object),Q=null===(d=g.info.getPropertyName)||void 0===d?void 0:d[0](g.object);if(!L)throw new Error("Object is undefined");return this.object.setValue(L,q),Q&&this.propertyName.setValue(Q,q),h}_setPropertyValue(q,f,j,d){var g,h;const L=this.templateComponent.getAccessor(this.config.pathConverter,d),Q=L.info.type;Q.startsWith("Color")&&(j=z(j,Q)),null===(g=(h=L.info).set)||void 0===g||g.call(h,j,L.object)}_getPropertyValue(q,f,j){const d=this.templateComponent.getAccessor(this.config.pathConverter,j),g=d.info.type,h=d.info.get(d.object);return g.startsWith("Color")?function(q){if(q instanceof r.c)return new H.j(q.r,q.g,q.b);if(q instanceof r.e)return new H.m(q.r,q.g,q.b,q.a);throw new Error("Invalid color type")}(h):h}_getInterpolationAnimationPropertyInfo(q,f,j){const d=this.templateComponent.getAccessor(this.config.pathConverter,j);return(q,f,j,g)=>{var h;const L=[],Q=d.info.type;return Q.startsWith("Color")&&(q=q.map((q=>({frame:q.frame,value:z(q.value,Q)})))),null===(h=d.info.interpolation)||void 0===h||h.forEach(((f,h)=>{var Q;const H=(null===(Q=d.info.getPropertyName)||void 0===Q?void 0:Q[h](d.object))||"Animation-interpolation-"+h;let r=q;j!==f.type&&(r=q.map((q=>({frame:q.frame,value:f.getValue(void 0,q.value.Yf?q.value.Yf():[q.value],0,1)}))));const u=f.buildAnimations(d.object,H,60,r);for(const q of u)g&&q.babylonAnimation.setEasingFunction(g),L.push(q.babylonAnimation)})),L}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function z(q,f){return q.getClassName().startsWith("Color")?q:"o"===f?new r.c(q.x,q.y,q.z):"wd"===f?new r.e(q.x,q.y,q.z,q.w):q}(0,Q.f)("FlowGraphJsonPointerParserBlock",X)},14173:(q,f,j)=>{j.d(f,{d:()=>Q});var d=j(12726),g=j(12709);const h="cachedOperationValue",L="cachedExecutionId";class Q extends d.e{constructor(q,f){super(f),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(q){const f=q._getExecutionVariable(this,L,-1),j=q._getExecutionVariable(this,h,null);if(void 0!==j&&null!==j&&f===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(j,q);else try{const f=this._doOperation(q);if(void 0===f||null===f)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,h,f),q._setExecutionVariable(this,L,q.executionId),this.value.setValue(f,q),this.isValid.setValue(!0,q)}catch(d){this.isValid.setValue(!1,q)}}}}}]);