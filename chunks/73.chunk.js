"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{13989:(U,W,l)=>{l.r(W),l.d(W,{FlowGraphAngleBetweenBlock:()=>o,FlowGraphAxisAngleFromQuaternionBlock:()=>O,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>m,FlowGraphDotBlock:()=>r,FlowGraphLengthBlock:()=>w,FlowGraphNormalizeBlock:()=>K,FlowGraphQuaternionFromAxisAngleBlock:()=>i,FlowGraphQuaternionFromDirectionsBlock:()=>e,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>g,FlowGraphTransformBlock:()=>Z,FlowGraphTransformCoordinatesBlock:()=>N});var M=l(12739),t=l(12704),L=l(655),p=l(13974),B=l(13986),k=l(706),A=l(12746),q=l(12394);const y="cachedOperationAxis",j="cachedOperationAngle",s="cachedExecutionId";class w extends B.e{constructor(U){super(t.d,t.s,(U=>this._polymorphicLength(U)),"FlowGraphLengthBlock",U)}_polymorphicLength(U){switch((0,A.i)(U)){case"Vector2":case"ik":case"Vector4":case"Quaternion":return U.length();default:throw new Error(`Cannot compute length of value ${U}`)}}}(0,L.f)("FlowGraphLengthBlock",w);class K extends B.e{constructor(U){super(t.d,t.d,(U=>this._polymorphicNormalize(U)),"FlowGraphNormalizeBlock",U)}_polymorphicNormalize(U){var W;let l;switch((0,A.i)(U)){case"Vector2":case"ik":case"Vector4":case"Quaternion":if(l=U.normalizeToNew(),null!==(W=this.config)&&void 0!==W&&W.nanOnZeroLength){0===U.length()&&l.jk(NaN)}return l;default:throw new Error(`Cannot normalize value ${U}`)}}}(0,L.f)("FlowGraphNormalizeBlock",K);class r extends p.e{constructor(U){super(t.d,t.d,t.s,((U,W)=>this._polymorphicDot(U,W)),"FlowGraphDotBlock",U)}_polymorphicDot(U,W){switch((0,A.i)(U)){case"Vector2":case"ik":case"Vector4":case"Quaternion":return U.dot(W);default:throw new Error(`Cannot get dot product of ${U} and ${W}`)}}}(0,L.f)("FlowGraphDotBlock",r);class m extends p.e{constructor(U){super(t.E,t.E,t.E,((U,W)=>k.l.Cross(U,W)),"FlowGraphCrossBlock",U)}}(0,L.f)("FlowGraphCrossBlock",m);class f extends p.e{constructor(U){super(t.A,t.s,t.A,((U,W)=>U.rotate(W)),"FlowGraphRotate2DBlock",U)}}(0,L.f)("FlowGraphRotate2DBlock",f);class g extends p.e{constructor(U){super(t.E,t.u,t.E,((U,W)=>U.applyRotationQuaternion(W)),"FlowGraphRotate3DBlock",U)}}function E(U,W){switch((0,A.i)(U)){case"Vector2":case"ik":return W.transformVector(U);case"Vector4":return new k.p(U.x*W.m[0]+U.y*W.m[1]+U.z*W.m[2]+U.w*W.m[3],U.x*W.m[4]+U.y*W.m[5]+U.z*W.m[6]+U.w*W.m[7],U.x*W.m[8]+U.y*W.m[9]+U.z*W.m[10]+U.w*W.m[11],U.x*W.m[12]+U.y*W.m[13]+U.z*W.m[14]+U.w*W.m[15]);default:throw new Error(`Cannot transform value ${U}`)}}(0,L.f)("FlowGraphRotate3DBlock",g);class Z extends p.e{constructor(U){const W=(null===U||void 0===U?void 0:U.vectorType)||"ik",l="Vector2"===W?"Matrix2D":"ik"===W?"Matrix3D":"Matrix";super((0,t.Q)(W),(0,t.Q)(l),(0,t.Q)(W),E,"FlowGraphTransformVectorBlock",U)}}(0,L.f)("FlowGraphTransformVectorBlock",Z);class N extends p.e{constructor(U){super(t.E,t.n,t.E,((U,W)=>k.l.TransformCoordinates(U,W)),"FlowGraphTransformCoordinatesBlock",U)}}(0,L.f)("FlowGraphTransformCoordinatesBlock",N);class D extends B.e{constructor(U){super(t.u,t.u,(U=>U.conjugate()),"FlowGraphConjugateBlock",U)}}(0,L.f)("FlowGraphConjugateBlock",D);class o extends p.e{constructor(U){super(t.u,t.u,t.s,((U,W)=>(0,q.c)(U,W)),"FlowGraphAngleBetweenBlock",U)}}(0,L.f)("FlowGraphAngleBetweenBlock",o);class i extends p.e{constructor(U){super(t.E,t.s,t.u,((U,W)=>k.e.RotationAxis(U,W)),"FlowGraphQuaternionFromAxisAngleBlock",U)}}(0,L.f)("FlowGraphQuaternionFromAxisAngleBlock",i);class O extends M.e{constructor(U){super(U),this.a=this.registerDataInput("a",t.u),this.axis=this.registerDataOutput("axis",t.E),this.angle=this.registerDataOutput("angle",t.s),this.isValid=this.registerDataOutput("isValid",t.h)}_updateOutputs(U){const W=U._getExecutionVariable(this,s,-1),l=U._getExecutionVariable(this,y,null),M=U._getExecutionVariable(this,j,null);if(void 0!==l&&null!==l&&void 0!==M&&null!==M&&W===U.executionId)this.axis.setValue(l,U),this.angle.setValue(M,U);else try{const{axis:W,angle:l}=this.a.getValue(U).toAxisAngle();U._setExecutionVariable(this,y,W),U._setExecutionVariable(this,j,l),U._setExecutionVariable(this,s,U.executionId),this.axis.setValue(W,U),this.angle.setValue(l,U),this.isValid.setValue(!0,U)}catch(t){this.isValid.setValue(!1,U)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,L.f)("FlowGraphAxisAngleFromQuaternionBlock",O);class e extends p.e{constructor(U){super(t.E,t.E,t.u,((U,W)=>(0,q.f)(U,W)),"FlowGraphQuaternionFromDirectionsBlock",U)}}},13974:(U,W,l)=>{l.d(W,{e:()=>t});var M=l(13983);class t extends M.c{constructor(U,W,l,M,t,L){super(l,L),this._operation=M,this._className=t,this.a=this.registerDataInput("a",U),this.b=this.registerDataInput("b",W)}_doOperation(U){const W=this.a.getValue(U),l=this.b.getValue(U);return this._operation(W,l)}getClassName(){return this._className}}},13983:(U,W,l)=>{l.d(W,{c:()=>B});var M=l(12739),t=l(12704);const L="cachedOperationValue",p="cachedExecutionId";class B extends M.e{constructor(U,W){super(W),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",t.h)}_updateOutputs(U){const W=U._getExecutionVariable(this,p,-1),l=U._getExecutionVariable(this,L,null);if(void 0!==l&&null!==l&&W===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(l,U);else try{const W=this._doOperation(U);if(void 0===W||null===W)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,L,W),U._setExecutionVariable(this,p,U.executionId),this.value.setValue(W,U),this.isValid.setValue(!0,U)}catch(M){this.isValid.setValue(!1,U)}}}},13986:(U,W,l)=>{l.d(W,{e:()=>t});var M=l(13983);class t extends M.c{constructor(U,W,l,M,t){super(W,t),this._operation=l,this._className=M,this.a=this.registerDataInput("a",U)}_doOperation(U){return this._operation(this.a.getValue(U))}getClassName(){return this._className}}}}]);