"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14685:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphJsonPointerParserBlock:()=>x});var J=W(13067),R=W(13071);const d=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class k{constructor(G,V){this.path=G,this.ownerBlock=V,this.templatedInputs=[];let W=d.exec(G);const k=new Set;for(;W;){const[,z]=W;if(k.has(z))throw new Error("Duplicate template variable detected.");k.add(z),this.templatedInputs.push(V.registerDataInput(z,R.h,new J.e(0))),W=d.exec(G)}}getAccessor(G,V){let W=this.path;for(const J of this.templatedInputs){const G=J.getValue(V).value;if("number"!==typeof G||G<0)throw new Error("Invalid value for templated input.");W=W.replace(`{${J.name}}`,G.toString())}return G.convert(W)}}var z=W(11159),X=W(11136),P=W(11424),A=W(14535);class x extends A.c{constructor(G){super(R.b,G),this.config=G,this.object=this.registerDataOutput("object",R.b),this.propertyName=this.registerDataOutput("propertyName",R.b),this.setterFunction=this.registerDataOutput("setFunction",R.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",R.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",R.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new k(G.jsonPointer,this)}_doOperation(G){var V,W,J;const R=this.templateComponent.getAccessor(this.config.pathConverter,G),d=R.info.get(R.object),k=null===(V=(W=R.info).getTarget)||void 0===V?void 0:V.call(W,R.object),z=null===(J=R.info.getPropertyName)||void 0===J?void 0:J[0](R.object);if(!k)throw new Error("Object is undefined");return this.object.setValue(k,G),z&&this.propertyName.setValue(z,G),d}_setPropertyValue(G,V,W,J){var R,d;const k=this.templateComponent.getAccessor(this.config.pathConverter,J),z=k.info.type;z.startsWith("Color")&&(W=q(W,z)),null===(R=(d=k.info).set)||void 0===R||R.call(d,W,k.object)}_getPropertyValue(G,V,W){const J=this.templateComponent.getAccessor(this.config.pathConverter,W),R=J.info.type,d=J.info.get(J.object);return R.startsWith("Color")?function(G){if(G instanceof P.d)return new X.o(G.r,G.g,G.b);if(G instanceof P.h)return new X.q(G.r,G.g,G.b,G.a);throw new Error("Invalid color type")}(d):d}_getInterpolationAnimationPropertyInfo(G,V,W){const J=this.templateComponent.getAccessor(this.config.pathConverter,W);return(G,V,W,R)=>{var d;const k=[],z=J.info.type;return z.startsWith("Color")&&(G=G.map((G=>({frame:G.frame,value:q(G.value,z)})))),null===(d=J.info.interpolation)||void 0===d||d.forEach(((V,d)=>{var z;const X=(null===(z=J.info.getPropertyName)||void 0===z?void 0:z[d](J.object))||"Animation-interpolation-"+d;let P=G;W!==V.type&&(P=G.map((G=>({frame:G.frame,value:V.getValue(void 0,G.value.Bd?G.value.Bd():[G.value],0,1)}))));const A=V.buildAnimations(J.object,X,60,P);for(const G of A)R&&G.babylonAnimation.setEasingFunction(R),k.push(G.babylonAnimation)})),k}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function q(G,V){return G.getClassName().startsWith("Color")?G:"pz"===V?new P.d(G.x,G.y,G.z):"nz"===V?new P.h(G.x,G.y,G.z,G.w):G}(0,z.d)("FlowGraphJsonPointerParserBlock",x)},14535:(G,V,W)=>{W.d(V,{c:()=>z});var J=W(13093),R=W(13071);const d="cachedOperationValue",k="cachedExecutionId";class z extends J.c{constructor(G,V){super(V),this.value=this.registerDataOutput("value",G),this.isValid=this.registerDataOutput("isValid",R.d)}_updateOutputs(G){const V=G._getExecutionVariable(this,k,-1),W=G._getExecutionVariable(this,d,null);if(void 0!==W&&null!==W&&V===G.executionId)this.isValid.setValue(!0,G),this.value.setValue(W,G);else try{const V=this._doOperation(G);if(void 0===V||null===V)return void this.isValid.setValue(!1,G);G._setExecutionVariable(this,d,V),G._setExecutionVariable(this,k,G.executionId),this.value.setValue(V,G),this.isValid.setValue(!0,G)}catch(J){this.isValid.setValue(!1,G)}}}}}]);