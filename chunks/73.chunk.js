"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14251:(q,c,U)=>{U.r(c),U.d(c,{FlowGraphJsonPointerParserBlock:()=>u});var J=U(12642),Q=U(12648);const s=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class g{constructor(q,c){this.path=q,this.ownerBlock=c,this.templatedInputs=[];let U=s.exec(q);const g=new Set;for(;U;){const[,X]=U;if(g.has(X))throw new Error("Duplicate template variable detected.");g.add(X),this.templatedInputs.push(c.registerDataInput(X,Q.i,new J.b(0))),U=s.exec(q)}}getAccessor(q,c){let U=this.path;for(const J of this.templatedInputs){const q=J.getValue(c).value;if("number"!==typeof q||q<0)throw new Error("Invalid value for templated input.");U=U.replace(`{${J.name}}`,q.toString())}return q.convert(U)}}var X=U(10850),n=U(10833),W=U(11093),D=U(14099);class u extends D.d{constructor(q){super(Q.c,q),this.config=q,this.object=this.registerDataOutput("object",Q.c),this.propertyName=this.registerDataOutput("propertyName",Q.c),this.setterFunction=this.registerDataOutput("setFunction",Q.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",Q.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",Q.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new g(q.jsonPointer,this)}_doOperation(q){var c,U,J;const Q=this.templateComponent.getAccessor(this.config.pathConverter,q),s=Q.info.get(Q.object),g=null===(c=(U=Q.info).getTarget)||void 0===c?void 0:c.call(U,Q.object),X=null===(J=Q.info.getPropertyName)||void 0===J?void 0:J[0](Q.object);if(!g)throw new Error("Object is undefined");return this.object.setValue(g,q),X&&this.propertyName.setValue(X,q),s}_setPropertyValue(q,c,U,J){var Q,s;const g=this.templateComponent.getAccessor(this.config.pathConverter,J),X=g.info.type;X.startsWith("Color")&&(U=K(U,X)),null===(Q=(s=g.info).set)||void 0===Q||Q.call(s,U,g.object)}_getPropertyValue(q,c,U){const J=this.templateComponent.getAccessor(this.config.pathConverter,U),Q=J.info.type,s=J.info.get(J.object);return Q.startsWith("Color")?function(q){if(q instanceof W.c)return new n.p(q.r,q.g,q.b);if(q instanceof W.e)return new n.q(q.r,q.g,q.b,q.a);throw new Error("Invalid color type")}(s):s}_getInterpolationAnimationPropertyInfo(q,c,U){const J=this.templateComponent.getAccessor(this.config.pathConverter,U);return(q,c,U,Q)=>{var s;const g=[],X=J.info.type;return X.startsWith("Color")&&(q=q.map((q=>({frame:q.frame,value:K(q.value,X)})))),null===(s=J.info.interpolation)||void 0===s||s.forEach(((c,s)=>{var X;const n=(null===(X=J.info.getPropertyName)||void 0===X?void 0:X[s](J.object))||"Animation-interpolation-"+s;let W=q;U!==c.type&&(W=q.map((q=>({frame:q.frame,value:c.getValue(void 0,q.value.rc?q.value.rc():[q.value],0,1)}))));const D=c.buildAnimations(J.object,n,60,W);for(const q of D)Q&&q.babylonAnimation.setEasingFunction(Q),g.push(q.babylonAnimation)})),g}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function K(q,c){return q.getClassName().startsWith("Color")?q:"Nc"===c?new W.c(q.x,q.y,q.z):"Pc"===c?new W.e(q.x,q.y,q.z,q.w):q}(0,X.f)("FlowGraphJsonPointerParserBlock",u)},14099:(q,c,U)=>{U.d(c,{d:()=>X});var J=U(12667),Q=U(12648);const s="cachedOperationValue",g="cachedExecutionId";class X extends J.c{constructor(q,c){super(c),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",Q.e)}_updateOutputs(q){const c=q._getExecutionVariable(this,g,-1),U=q._getExecutionVariable(this,s,null);if(void 0!==U&&null!==U&&c===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(U,q);else try{const c=this._doOperation(q);if(void 0===c||null===c)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,s,c),q._setExecutionVariable(this,g,q.executionId),this.value.setValue(c,q),this.isValid.setValue(!0,q)}catch(J){this.isValid.setValue(!1,q)}}}}}]);