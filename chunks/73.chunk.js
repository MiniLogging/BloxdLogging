"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14403:(s,Z,o)=>{o.r(Z),o.d(Z,{FlowGraphJsonPointerParserBlock:()=>Q});var t=o(12771),j=o(12775);const S=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class a{constructor(s,Z){this.path=s,this.ownerBlock=Z,this.templatedInputs=[];let o=S.exec(s);const a=new Set;for(;o;){const[,O]=o;if(a.has(O))throw new Error("Duplicate template variable detected.");a.add(O),this.templatedInputs.push(Z.registerDataInput(O,j.j,new t.b(0))),o=S.exec(s)}}getAccessor(s,Z){let o=this.path;for(const t of this.templatedInputs){const s=t.getValue(Z).value;if("number"!==typeof s||s<0)throw new Error("Invalid value for templated input.");o=o.replace(`{${t.name}}`,s.toString())}return s.convert(o)}}var O=o(10916),v=o(10900),G=o(11174),B=o(14271);class Q extends B.e{constructor(s){super(j.d,s),this.config=s,this.object=this.registerDataOutput("object",j.d),this.propertyName=this.registerDataOutput("propertyName",j.d),this.setterFunction=this.registerDataOutput("setFunction",j.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",j.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",j.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new a(s.jsonPointer,this)}_doOperation(s){var Z,o,t;const j=this.templateComponent.getAccessor(this.config.pathConverter,s),S=j.info.get(j.object),a=null===(Z=(o=j.info).getTarget)||void 0===Z?void 0:Z.call(o,j.object),O=null===(t=j.info.getPropertyName)||void 0===t?void 0:t[0](j.object);if(!a)throw new Error("Object is undefined");return this.object.setValue(a,s),O&&this.propertyName.setValue(O,s),S}_setPropertyValue(s,Z,o,t){var j,S;const a=this.templateComponent.getAccessor(this.config.pathConverter,t),O=a.info.type;O.startsWith("Color")&&(o=D(o,O)),null===(j=(S=a.info).set)||void 0===j||j.call(S,o,a.object)}_getPropertyValue(s,Z,o){const t=this.templateComponent.getAccessor(this.config.pathConverter,o),j=t.info.type,S=t.info.get(t.object);return j.startsWith("Color")?function(s){if(s instanceof G.d)return new v.n(s.r,s.g,s.b);if(s instanceof G.h)return new v.p(s.r,s.g,s.b,s.a);throw new Error("Invalid color type")}(S):S}_getInterpolationAnimationPropertyInfo(s,Z,o){const t=this.templateComponent.getAccessor(this.config.pathConverter,o);return(s,Z,o,j)=>{var S;const a=[],O=t.info.type;return O.startsWith("Color")&&(s=s.map((s=>({frame:s.frame,value:D(s.value,O)})))),null===(S=t.info.interpolation)||void 0===S||S.forEach(((Z,S)=>{var O;const v=(null===(O=t.info.getPropertyName)||void 0===O?void 0:O[S](t.object))||"Animation-interpolation-"+S;let G=s;o!==Z.type&&(G=s.map((s=>({frame:s.frame,value:Z.getValue(void 0,s.value.ma?s.value.ma():[s.value],0,1)}))));const B=Z.buildAnimations(t.object,v,60,G);for(const s of B)j&&s.babylonAnimation.setEasingFunction(j),a.push(s.babylonAnimation)})),a}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function D(s,Z){return s.getClassName().startsWith("Color")?s:"pz"===Z?new G.d(s.x,s.y,s.z):"nz"===Z?new G.h(s.x,s.y,s.z,s.w):s}(0,O.f)("FlowGraphJsonPointerParserBlock",Q)},14271:(s,Z,o)=>{o.d(Z,{e:()=>O});var t=o(12802),j=o(12775);const S="cachedOperationValue",a="cachedExecutionId";class O extends t.e{constructor(s,Z){super(Z),this.value=this.registerDataOutput("value",s),this.isValid=this.registerDataOutput("isValid",j.g)}_updateOutputs(s){const Z=s._getExecutionVariable(this,a,-1),o=s._getExecutionVariable(this,S,null);if(void 0!==o&&null!==o&&Z===s.executionId)this.isValid.setValue(!0,s),this.value.setValue(o,s);else try{const Z=this._doOperation(s);if(void 0===Z||null===Z)return void this.isValid.setValue(!1,s);s._setExecutionVariable(this,S,Z),s._setExecutionVariable(this,a,s.executionId),this.value.setValue(Z,s),this.isValid.setValue(!0,s)}catch(t){this.isValid.setValue(!1,s)}}}}}]);