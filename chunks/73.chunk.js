"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14364:(x,O,Q)=>{Q.r(O),Q.d(O,{FlowGraphJsonPointerParserBlock:()=>L});var X=Q(12703),Z=Q(12707);const n=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class V{constructor(x,O){this.path=x,this.ownerBlock=O,this.templatedInputs=[];let Q=n.exec(x);const V=new Set;for(;Q;){const[,o]=Q;if(V.has(o))throw new Error("Duplicate template variable detected.");V.add(o),this.templatedInputs.push(O.registerDataInput(o,Z.i,new X.b(0))),Q=n.exec(x)}}getAccessor(x,O){let Q=this.path;for(const X of this.templatedInputs){const x=X.getValue(O).value;if("number"!==typeof x||x<0)throw new Error("Invalid value for templated input.");Q=Q.replace(`{${X.name}}`,x.toString())}return x.convert(Q)}}var o=Q(10866),l=Q(10849),C=Q(11133),U=Q(14213);class L extends U.d{constructor(x){super(Z.d,x),this.config=x,this.object=this.registerDataOutput("object",Z.d),this.propertyName=this.registerDataOutput("propertyName",Z.d),this.setterFunction=this.registerDataOutput("setFunction",Z.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",Z.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",Z.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new V(x.jsonPointer,this)}_doOperation(x){var O,Q,X;const Z=this.templateComponent.getAccessor(this.config.pathConverter,x),n=Z.info.get(Z.object),V=null===(O=(Q=Z.info).getTarget)||void 0===O?void 0:O.call(Q,Z.object),o=null===(X=Z.info.getPropertyName)||void 0===X?void 0:X[0](Z.object);if(!V)throw new Error("Object is undefined");return this.object.setValue(V,x),o&&this.propertyName.setValue(o,x),n}_setPropertyValue(x,O,Q,X){var Z,n;const V=this.templateComponent.getAccessor(this.config.pathConverter,X),o=V.info.type;o.startsWith("Color")&&(Q=h(Q,o)),null===(Z=(n=V.info).set)||void 0===Z||Z.call(n,Q,V.object)}_getPropertyValue(x,O,Q){const X=this.templateComponent.getAccessor(this.config.pathConverter,Q),Z=X.info.type,n=X.info.get(X.object);return Z.startsWith("Color")?function(x){if(x instanceof C.d)return new l.n(x.r,x.g,x.b);if(x instanceof C.h)return new l.o(x.r,x.g,x.b,x.a);throw new Error("Invalid color type")}(n):n}_getInterpolationAnimationPropertyInfo(x,O,Q){const X=this.templateComponent.getAccessor(this.config.pathConverter,Q);return(x,O,Q,Z)=>{var n;const V=[],o=X.info.type;return o.startsWith("Color")&&(x=x.map((x=>({frame:x.frame,value:h(x.value,o)})))),null===(n=X.info.interpolation)||void 0===n||n.forEach(((O,n)=>{var o;const l=(null===(o=X.info.getPropertyName)||void 0===o?void 0:o[n](X.object))||"Animation-interpolation-"+n;let C=x;Q!==O.type&&(C=x.map((x=>({frame:x.frame,value:O.getValue(void 0,x.value.mV?x.value.mV():[x.value],0,1)}))));const U=O.buildAnimations(X.object,l,60,C);for(const x of U)Z&&x.babylonAnimation.setEasingFunction(Z),V.push(x.babylonAnimation)})),V}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function h(x,O){return x.getClassName().startsWith("Color")?x:"rl"===O?new C.d(x.x,x.y,x.z):"nh"===O?new C.h(x.x,x.y,x.z,x.w):x}(0,o.d)("FlowGraphJsonPointerParserBlock",L)},14213:(x,O,Q)=>{Q.d(O,{d:()=>o});var X=Q(12726),Z=Q(12707);const n="cachedOperationValue",V="cachedExecutionId";class o extends X.d{constructor(x,O){super(O),this.value=this.registerDataOutput("value",x),this.isValid=this.registerDataOutput("isValid",Z.g)}_updateOutputs(x){const O=x._getExecutionVariable(this,V,-1),Q=x._getExecutionVariable(this,n,null);if(void 0!==Q&&null!==Q&&O===x.executionId)this.isValid.setValue(!0,x),this.value.setValue(Q,x);else try{const O=this._doOperation(x);if(void 0===O||null===O)return void this.isValid.setValue(!1,x);x._setExecutionVariable(this,n,O),x._setExecutionVariable(this,V,x.executionId),this.value.setValue(O,x),this.isValid.setValue(!0,x)}catch(X){this.isValid.setValue(!1,x)}}}}}]);