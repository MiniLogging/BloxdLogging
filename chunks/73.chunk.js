"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14546:(w,p,e)=>{e.r(p),e.d(p,{FlowGraphJsonPointerParserBlock:()=>k});var r=e(12867),I=e(12872);const d=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class f{constructor(w,p){this.path=w,this.ownerBlock=p,this.templatedInputs=[];let e=d.exec(w);const f=new Set;for(;e;){const[,q]=e;if(f.has(q))throw new Error("Duplicate template variable detected.");f.add(q),this.templatedInputs.push(p.registerDataInput(q,I.h,new r.b(0))),e=d.exec(w)}}getAccessor(w,p){let e=this.path;for(const r of this.templatedInputs){const w=r.getValue(p).value;if("number"!==typeof w||w<0)throw new Error("Invalid value for templated input.");e=e.replace(`{${r.name}}`,w.toString())}return w.convert(e)}}var q=e(11038),E=e(11023),j=e(11308),X=e(14402);class k extends X.c{constructor(w){super(I.c,w),this.config=w,this.object=this.registerDataOutput("object",I.c),this.propertyName=this.registerDataOutput("propertyName",I.c),this.setterFunction=this.registerDataOutput("setFunction",I.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",I.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",I.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new f(w.jsonPointer,this)}_doOperation(w){var p,e,r;const I=this.templateComponent.getAccessor(this.config.pathConverter,w),d=I.info.get(I.object),f=null===(p=(e=I.info).getTarget)||void 0===p?void 0:p.call(e,I.object),q=null===(r=I.info.getPropertyName)||void 0===r?void 0:r[0](I.object);if(!f)throw new Error("Object is undefined");return this.object.setValue(f,w),q&&this.propertyName.setValue(q,w),d}_setPropertyValue(w,p,e,r){var I,d;const f=this.templateComponent.getAccessor(this.config.pathConverter,r),q=f.info.type;q.startsWith("Color")&&(e=m(e,q)),null===(I=(d=f.info).set)||void 0===I||I.call(d,e,f.object)}_getPropertyValue(w,p,e){const r=this.templateComponent.getAccessor(this.config.pathConverter,e),I=r.info.type,d=r.info.get(r.object);return I.startsWith("Color")?function(w){if(w instanceof j.b)return new E.k(w.r,w.g,w.b);if(w instanceof j.e)return new E.o(w.r,w.g,w.b,w.a);throw new Error("Invalid color type")}(d):d}_getInterpolationAnimationPropertyInfo(w,p,e){const r=this.templateComponent.getAccessor(this.config.pathConverter,e);return(w,p,e,I)=>{var d;const f=[],q=r.info.type;return q.startsWith("Color")&&(w=w.map((w=>({frame:w.frame,value:m(w.value,q)})))),null===(d=r.info.interpolation)||void 0===d||d.forEach(((p,d)=>{var q;const E=(null===(q=r.info.getPropertyName)||void 0===q?void 0:q[d](r.object))||"Animation-interpolation-"+d;let j=w;e!==p.type&&(j=w.map((w=>({frame:w.frame,value:p.getValue(void 0,w.value.ze?w.value.ze():[w.value],0,1)}))));const X=p.buildAnimations(r.object,E,60,j);for(const w of X)I&&w.babylonAnimation.setEasingFunction(I),f.push(w.babylonAnimation)})),f}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function m(w,p){return w.getClassName().startsWith("Color")?w:"pd"===p?new j.b(w.x,w.y,w.z):"ed"===p?new j.e(w.x,w.y,w.z,w.w):w}(0,q.d)("FlowGraphJsonPointerParserBlock",k)},14402:(w,p,e)=>{e.d(p,{c:()=>q});var r=e(12893),I=e(12872);const d="cachedOperationValue",f="cachedExecutionId";class q extends r.e{constructor(w,p){super(p),this.value=this.registerDataOutput("value",w),this.isValid=this.registerDataOutput("isValid",I.g)}_updateOutputs(w){const p=w._getExecutionVariable(this,f,-1),e=w._getExecutionVariable(this,d,null);if(void 0!==e&&null!==e&&p===w.executionId)this.isValid.setValue(!0,w),this.value.setValue(e,w);else try{const p=this._doOperation(w);if(void 0===p||null===p)return void this.isValid.setValue(!1,w);w._setExecutionVariable(this,d,p),w._setExecutionVariable(this,f,w.executionId),this.value.setValue(p,w),this.isValid.setValue(!0,w)}catch(r){this.isValid.setValue(!1,w)}}}}}]);