"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14335:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphAngleBetweenBlock:()=>g,FlowGraphAxisAngleFromQuaternionBlock:()=>e,FlowGraphConjugateBlock:()=>Z,FlowGraphCrossBlock:()=>z,FlowGraphDotBlock:()=>s,FlowGraphLengthBlock:()=>a,FlowGraphNormalizeBlock:()=>F,FlowGraphQuaternionFromAxisAngleBlock:()=>S,FlowGraphQuaternionFromDirectionsBlock:()=>k,FlowGraphRotate2DBlock:()=>x,FlowGraphRotate3DBlock:()=>r,FlowGraphTransformBlock:()=>j,FlowGraphTransformCoordinatesBlock:()=>v});var l=C(13092),h=C(13063),M=C(620),f=C(14311),O=C(14326),m=C(668),W=C(13104),U=C(12761);const L="cachedOperationAxis",w="cachedOperationAngle",i="cachedExecutionId";class a extends O.d{constructor(Q){super(h.d,h.p,(Q=>this._polymorphicLength(Q)),"FlowGraphLengthBlock",Q)}_polymorphicLength(Q){switch((0,W.m)(Q)){case"Vector2":case"Yj":case"Vector4":case"Quaternion":return Q.length();default:throw new Error(`Cannot compute length of value ${Q}`)}}}(0,M.g)("FlowGraphLengthBlock",a);class F extends O.d{constructor(Q){super(h.d,h.d,(Q=>this._polymorphicNormalize(Q)),"FlowGraphNormalizeBlock",Q)}_polymorphicNormalize(Q){var X;let C;switch((0,W.m)(Q)){case"Vector2":case"Yj":case"Vector4":case"Quaternion":if(C=Q.normalizeToNew(),null!==(X=this.config)&&void 0!==X&&X.nanOnZeroLength){0===Q.length()&&C.Zj(NaN)}return C;default:throw new Error(`Cannot normalize value ${Q}`)}}}(0,M.g)("FlowGraphNormalizeBlock",F);class s extends f.e{constructor(Q){super(h.d,h.d,h.p,((Q,X)=>this._polymorphicDot(Q,X)),"FlowGraphDotBlock",Q)}_polymorphicDot(Q,X){switch((0,W.m)(Q)){case"Vector2":case"Yj":case"Vector4":case"Quaternion":return Q.dot(X);default:throw new Error(`Cannot get dot product of ${Q} and ${X}`)}}}(0,M.g)("FlowGraphDotBlock",s);class z extends f.e{constructor(Q){super(h.y,h.y,h.y,((Q,X)=>m.k.Cross(Q,X)),"FlowGraphCrossBlock",Q)}}(0,M.g)("FlowGraphCrossBlock",z);class x extends f.e{constructor(Q){super(h.w,h.p,h.w,((Q,X)=>Q.rotate(X)),"FlowGraphRotate2DBlock",Q)}}(0,M.g)("FlowGraphRotate2DBlock",x);class r extends f.e{constructor(Q){super(h.y,h.t,h.y,((Q,X)=>Q.applyRotationQuaternion(X)),"FlowGraphRotate3DBlock",Q)}}function P(Q,X){switch((0,W.m)(Q)){case"Vector2":case"Yj":return X.transformVector(Q);case"Vector4":return new m.o(Q.x*X.m[0]+Q.y*X.m[1]+Q.z*X.m[2]+Q.w*X.m[3],Q.x*X.m[4]+Q.y*X.m[5]+Q.z*X.m[6]+Q.w*X.m[7],Q.x*X.m[8]+Q.y*X.m[9]+Q.z*X.m[10]+Q.w*X.m[11],Q.x*X.m[12]+Q.y*X.m[13]+Q.z*X.m[14]+Q.w*X.m[15]);default:throw new Error(`Cannot transform value ${Q}`)}}(0,M.g)("FlowGraphRotate3DBlock",r);class j extends f.e{constructor(Q){const X=(null===Q||void 0===Q?void 0:Q.vectorType)||"Yj",C="Vector2"===X?"Matrix2D":"Yj"===X?"Matrix3D":"Matrix";super((0,h.H)(X),(0,h.H)(C),(0,h.H)(X),P,"FlowGraphTransformVectorBlock",Q)}}(0,M.g)("FlowGraphTransformVectorBlock",j);class v extends f.e{constructor(Q){super(h.y,h.h,h.y,((Q,X)=>m.k.TransformCoordinates(Q,X)),"FlowGraphTransformCoordinatesBlock",Q)}}(0,M.g)("FlowGraphTransformCoordinatesBlock",v);class Z extends O.d{constructor(Q){super(h.t,h.t,(Q=>Q.conjugate()),"FlowGraphConjugateBlock",Q)}}(0,M.g)("FlowGraphConjugateBlock",Z);class g extends f.e{constructor(Q){super(h.t,h.t,h.p,((Q,X)=>(0,U.d)(Q,X)),"FlowGraphAngleBetweenBlock",Q)}}(0,M.g)("FlowGraphAngleBetweenBlock",g);class S extends f.e{constructor(Q){super(h.y,h.p,h.t,((Q,X)=>m.c.RotationAxis(Q,X)),"FlowGraphQuaternionFromAxisAngleBlock",Q)}}(0,M.g)("FlowGraphQuaternionFromAxisAngleBlock",S);class e extends l.c{constructor(Q){super(Q),this.a=this.registerDataInput("a",h.t),this.axis=this.registerDataOutput("axis",h.y),this.angle=this.registerDataOutput("angle",h.p),this.isValid=this.registerDataOutput("isValid",h.e)}_updateOutputs(Q){const X=Q._getExecutionVariable(this,i,-1),C=Q._getExecutionVariable(this,L,null),l=Q._getExecutionVariable(this,w,null);if(void 0!==C&&null!==C&&void 0!==l&&null!==l&&X===Q.executionId)this.axis.setValue(C,Q),this.angle.setValue(l,Q);else try{const{axis:X,angle:C}=this.a.getValue(Q).toAxisAngle();Q._setExecutionVariable(this,L,X),Q._setExecutionVariable(this,w,C),Q._setExecutionVariable(this,i,Q.executionId),this.axis.setValue(X,Q),this.angle.setValue(C,Q),this.isValid.setValue(!0,Q)}catch(h){this.isValid.setValue(!1,Q)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,M.g)("FlowGraphAxisAngleFromQuaternionBlock",e);class k extends f.e{constructor(Q){super(h.y,h.y,h.t,((Q,X)=>(0,U.e)(Q,X)),"FlowGraphQuaternionFromDirectionsBlock",Q)}}},14311:(Q,X,C)=>{C.d(X,{e:()=>h});var l=C(14320);class h extends l.d{constructor(Q,X,C,l,h,M){super(C,M),this._operation=l,this._className=h,this.a=this.registerDataInput("a",Q),this.b=this.registerDataInput("b",X)}_doOperation(Q){const X=this.a.getValue(Q),C=this.b.getValue(Q);return this._operation(X,C)}getClassName(){return this._className}}},14320:(Q,X,C)=>{C.d(X,{d:()=>O});var l=C(13092),h=C(13063);const M="cachedOperationValue",f="cachedExecutionId";class O extends l.c{constructor(Q,X){super(X),this.value=this.registerDataOutput("value",Q),this.isValid=this.registerDataOutput("isValid",h.e)}_updateOutputs(Q){const X=Q._getExecutionVariable(this,f,-1),C=Q._getExecutionVariable(this,M,null);if(void 0!==C&&null!==C&&X===Q.executionId)this.isValid.setValue(!0,Q),this.value.setValue(C,Q);else try{const X=this._doOperation(Q);if(void 0===X||null===X)return void this.isValid.setValue(!1,Q);Q._setExecutionVariable(this,M,X),Q._setExecutionVariable(this,f,Q.executionId),this.value.setValue(X,Q),this.isValid.setValue(!0,Q)}catch(l){this.isValid.setValue(!1,Q)}}}},14326:(Q,X,C)=>{C.d(X,{d:()=>h});var l=C(14320);class h extends l.d{constructor(Q,X,C,l,h){super(X,h),this._operation=C,this._className=l,this.a=this.registerDataInput("a",Q)}_doOperation(Q){return this._operation(this.a.getValue(Q))}getClassName(){return this._className}}}}]);