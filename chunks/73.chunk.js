"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14173:(t,q,S)=>{S.r(q),S.d(q,{FlowGraphAngleBetweenBlock:()=>U,FlowGraphAxisAngleFromQuaternionBlock:()=>j,FlowGraphConjugateBlock:()=>J,FlowGraphCrossBlock:()=>a,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>h,FlowGraphNormalizeBlock:()=>l,FlowGraphQuaternionFromAxisAngleBlock:()=>H,FlowGraphQuaternionFromDirectionsBlock:()=>y,FlowGraphRotate2DBlock:()=>v,FlowGraphRotate3DBlock:()=>M,FlowGraphTransformBlock:()=>k,FlowGraphTransformCoordinatesBlock:()=>V});var o=S(12946),B=S(12927),z=S(622),L=S(14160),r=S(14165),e=S(678),C=S(12957),Z=S(12622);const b="cachedOperationAxis",O="cachedOperationAngle",i="cachedExecutionId";class h extends r.b{constructor(t){super(B.b,B.v,(t=>this._polymorphicLength(t)),"FlowGraphLengthBlock",t)}_polymorphicLength(t){switch((0,C.i)(t)){case"Vector2":case"wi":case"Vector4":case"Quaternion":return t.length();default:throw new Error(`Cannot compute length of value ${t}`)}}}(0,z.c)("FlowGraphLengthBlock",h);class l extends r.b{constructor(t){super(B.b,B.b,(t=>this._polymorphicNormalize(t)),"FlowGraphNormalizeBlock",t)}_polymorphicNormalize(t){var q;let S;switch((0,C.i)(t)){case"Vector2":case"wi":case"Vector4":case"Quaternion":if(S=t.normalizeToNew(),null!==(q=this.config)&&void 0!==q&&q.nanOnZeroLength){0===t.length()&&S.ui(NaN)}return S;default:throw new Error(`Cannot normalize value ${t}`)}}}(0,z.c)("FlowGraphNormalizeBlock",l);class I extends L.e{constructor(t){super(B.b,B.b,B.v,((t,q)=>this._polymorphicDot(t,q)),"FlowGraphDotBlock",t)}_polymorphicDot(t,q){switch((0,C.i)(t)){case"Vector2":case"wi":case"Vector4":case"Quaternion":return t.dot(q);default:throw new Error(`Cannot get dot product of ${t} and ${q}`)}}}(0,z.c)("FlowGraphDotBlock",I);class a extends L.e{constructor(t){super(B.G,B.G,B.G,((t,q)=>e.o.Cross(t,q)),"FlowGraphCrossBlock",t)}}(0,z.c)("FlowGraphCrossBlock",a);class v extends L.e{constructor(t){super(B.D,B.v,B.D,((t,q)=>t.rotate(q)),"FlowGraphRotate2DBlock",t)}}(0,z.c)("FlowGraphRotate2DBlock",v);class M extends L.e{constructor(t){super(B.G,B.x,B.G,((t,q)=>t.applyRotationQuaternion(q)),"FlowGraphRotate3DBlock",t)}}function x(t,q){switch((0,C.i)(t)){case"Vector2":case"wi":return q.transformVector(t);case"Vector4":return new e.s(t.x*q.m[0]+t.y*q.m[1]+t.z*q.m[2]+t.w*q.m[3],t.x*q.m[4]+t.y*q.m[5]+t.z*q.m[6]+t.w*q.m[7],t.x*q.m[8]+t.y*q.m[9]+t.z*q.m[10]+t.w*q.m[11],t.x*q.m[12]+t.y*q.m[13]+t.z*q.m[14]+t.w*q.m[15]);default:throw new Error(`Cannot transform value ${t}`)}}(0,z.c)("FlowGraphRotate3DBlock",M);class k extends L.e{constructor(t){const q=(null===t||void 0===t?void 0:t.vectorType)||"wi",S="Vector2"===q?"Matrix2D":"wi"===q?"Matrix3D":"Matrix";super((0,B.R)(q),(0,B.R)(S),(0,B.R)(q),x,"FlowGraphTransformVectorBlock",t)}}(0,z.c)("FlowGraphTransformVectorBlock",k);class V extends L.e{constructor(t){super(B.G,B.l,B.G,((t,q)=>e.o.TransformCoordinates(t,q)),"FlowGraphTransformCoordinatesBlock",t)}}(0,z.c)("FlowGraphTransformCoordinatesBlock",V);class J extends r.b{constructor(t){super(B.x,B.x,(t=>t.conjugate()),"FlowGraphConjugateBlock",t)}}(0,z.c)("FlowGraphConjugateBlock",J);class U extends L.e{constructor(t){super(B.x,B.x,B.v,((t,q)=>(0,Z.b)(t,q)),"FlowGraphAngleBetweenBlock",t)}}(0,z.c)("FlowGraphAngleBetweenBlock",U);class H extends L.e{constructor(t){super(B.G,B.v,B.x,((t,q)=>e.g.RotationAxis(t,q)),"FlowGraphQuaternionFromAxisAngleBlock",t)}}(0,z.c)("FlowGraphQuaternionFromAxisAngleBlock",H);class j extends o.d{constructor(t){super(t),this.a=this.registerDataInput("a",B.x),this.axis=this.registerDataOutput("axis",B.G),this.angle=this.registerDataOutput("angle",B.v),this.isValid=this.registerDataOutput("isValid",B.f)}_updateOutputs(t){const q=t._getExecutionVariable(this,i,-1),S=t._getExecutionVariable(this,b,null),o=t._getExecutionVariable(this,O,null);if(void 0!==S&&null!==S&&void 0!==o&&null!==o&&q===t.executionId)this.axis.setValue(S,t),this.angle.setValue(o,t);else try{const{axis:q,angle:S}=this.a.getValue(t).toAxisAngle();t._setExecutionVariable(this,b,q),t._setExecutionVariable(this,O,S),t._setExecutionVariable(this,i,t.executionId),this.axis.setValue(q,t),this.angle.setValue(S,t),this.isValid.setValue(!0,t)}catch(B){this.isValid.setValue(!1,t)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,z.c)("FlowGraphAxisAngleFromQuaternionBlock",j);class y extends L.e{constructor(t){super(B.G,B.G,B.x,((t,q)=>(0,Z.d)(t,q)),"FlowGraphQuaternionFromDirectionsBlock",t)}}},14160:(t,q,S)=>{S.d(q,{e:()=>B});var o=S(14163);class B extends o.c{constructor(t,q,S,o,B,z){super(S,z),this._operation=o,this._className=B,this.a=this.registerDataInput("a",t),this.b=this.registerDataInput("b",q)}_doOperation(t){const q=this.a.getValue(t),S=this.b.getValue(t);return this._operation(q,S)}getClassName(){return this._className}}},14163:(t,q,S)=>{S.d(q,{c:()=>r});var o=S(12946),B=S(12927);const z="cachedOperationValue",L="cachedExecutionId";class r extends o.d{constructor(t,q){super(q),this.value=this.registerDataOutput("value",t),this.isValid=this.registerDataOutput("isValid",B.f)}_updateOutputs(t){const q=t._getExecutionVariable(this,L,-1),S=t._getExecutionVariable(this,z,null);if(void 0!==S&&null!==S&&q===t.executionId)this.isValid.setValue(!0,t),this.value.setValue(S,t);else try{const q=this._doOperation(t);if(void 0===q||null===q)return void this.isValid.setValue(!1,t);t._setExecutionVariable(this,z,q),t._setExecutionVariable(this,L,t.executionId),this.value.setValue(q,t),this.isValid.setValue(!0,t)}catch(o){this.isValid.setValue(!1,t)}}}},14165:(t,q,S)=>{S.d(q,{b:()=>B});var o=S(14163);class B extends o.c{constructor(t,q,S,o,B){super(q,B),this._operation=S,this._className=o,this.a=this.registerDataInput("a",t)}_doOperation(t){return this._operation(this.a.getValue(t))}getClassName(){return this._className}}}}]);