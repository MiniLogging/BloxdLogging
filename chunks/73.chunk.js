"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14484:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphAngleBetweenBlock:()=>X,FlowGraphAxisAngleFromQuaternionBlock:()=>B,FlowGraphConjugateBlock:()=>a,FlowGraphCrossBlock:()=>L,FlowGraphDotBlock:()=>S,FlowGraphLengthBlock:()=>i,FlowGraphNormalizeBlock:()=>q,FlowGraphQuaternionFromAxisAngleBlock:()=>M,FlowGraphQuaternionFromDirectionsBlock:()=>o,FlowGraphRotate2DBlock:()=>b,FlowGraphRotate3DBlock:()=>C,FlowGraphTransformBlock:()=>d,FlowGraphTransformCoordinatesBlock:()=>P});var k=H(13268),c=H(13246),t=H(610),A=H(14469),D=H(14476),U=H(661),J=H(13283),V=H(12945);const n="cachedOperationAxis",g="cachedOperationAngle",I="cachedExecutionId";class i extends D.e{constructor(R){super(c.b,c.m,(R=>this._polymorphicLength(R)),"FlowGraphLengthBlock",R)}_polymorphicLength(R){switch((0,J.i)(R)){case"Vector2":case"Bi":case"Vector4":case"Quaternion":return R.length();default:throw new Error(`Cannot compute length of value ${R}`)}}}(0,t.h)("FlowGraphLengthBlock",i);class q extends D.e{constructor(R){super(c.b,c.b,(R=>this._polymorphicNormalize(R)),"FlowGraphNormalizeBlock",R)}_polymorphicNormalize(R){var x;let H;switch((0,J.i)(R)){case"Vector2":case"Bi":case"Vector4":case"Quaternion":if(H=R.normalizeToNew(),null!==(x=this.config)&&void 0!==x&&x.nanOnZeroLength){0===R.length()&&H.Ai(NaN)}return H;default:throw new Error(`Cannot normalize value ${R}`)}}}(0,t.h)("FlowGraphNormalizeBlock",q);class S extends A.e{constructor(R){super(c.b,c.b,c.m,((R,x)=>this._polymorphicDot(R,x)),"FlowGraphDotBlock",R)}_polymorphicDot(R,x){switch((0,J.i)(R)){case"Vector2":case"Bi":case"Vector4":case"Quaternion":return R.dot(x);default:throw new Error(`Cannot get dot product of ${R} and ${x}`)}}}(0,t.h)("FlowGraphDotBlock",S);class L extends A.e{constructor(R){super(c.t,c.t,c.t,((R,x)=>U.o.Cross(R,x)),"FlowGraphCrossBlock",R)}}(0,t.h)("FlowGraphCrossBlock",L);class b extends A.e{constructor(R){super(c.s,c.m,c.s,((R,x)=>R.rotate(x)),"FlowGraphRotate2DBlock",R)}}(0,t.h)("FlowGraphRotate2DBlock",b);class C extends A.e{constructor(R){super(c.t,c.o,c.t,((R,x)=>R.applyRotationQuaternion(x)),"FlowGraphRotate3DBlock",R)}}function F(R,x){switch((0,J.i)(R)){case"Vector2":case"Bi":return x.transformVector(R);case"Vector4":return new U.p(R.x*x.m[0]+R.y*x.m[1]+R.z*x.m[2]+R.w*x.m[3],R.x*x.m[4]+R.y*x.m[5]+R.z*x.m[6]+R.w*x.m[7],R.x*x.m[8]+R.y*x.m[9]+R.z*x.m[10]+R.w*x.m[11],R.x*x.m[12]+R.y*x.m[13]+R.z*x.m[14]+R.w*x.m[15]);default:throw new Error(`Cannot transform value ${R}`)}}(0,t.h)("FlowGraphRotate3DBlock",C);class d extends A.e{constructor(R){const x=(null===R||void 0===R?void 0:R.vectorType)||"Bi",H="Vector2"===x?"Matrix2D":"Bi"===x?"Matrix3D":"Matrix";super((0,c.C)(x),(0,c.C)(H),(0,c.C)(x),F,"FlowGraphTransformVectorBlock",R)}}(0,t.h)("FlowGraphTransformVectorBlock",d);class P extends A.e{constructor(R){super(c.t,c.f,c.t,((R,x)=>U.o.TransformCoordinates(R,x)),"FlowGraphTransformCoordinatesBlock",R)}}(0,t.h)("FlowGraphTransformCoordinatesBlock",P);class a extends D.e{constructor(R){super(c.o,c.o,(R=>R.conjugate()),"FlowGraphConjugateBlock",R)}}(0,t.h)("FlowGraphConjugateBlock",a);class X extends A.e{constructor(R){super(c.o,c.o,c.m,((R,x)=>(0,V.d)(R,x)),"FlowGraphAngleBetweenBlock",R)}}(0,t.h)("FlowGraphAngleBetweenBlock",X);class M extends A.e{constructor(R){super(c.t,c.m,c.o,((R,x)=>U.f.RotationAxis(R,x)),"FlowGraphQuaternionFromAxisAngleBlock",R)}}(0,t.h)("FlowGraphQuaternionFromAxisAngleBlock",M);class B extends k.b{constructor(R){super(R),this.a=this.registerDataInput("a",c.o),this.axis=this.registerDataOutput("axis",c.t),this.angle=this.registerDataOutput("angle",c.m),this.isValid=this.registerDataOutput("isValid",c.c)}_updateOutputs(R){const x=R._getExecutionVariable(this,I,-1),H=R._getExecutionVariable(this,n,null),k=R._getExecutionVariable(this,g,null);if(void 0!==H&&null!==H&&void 0!==k&&null!==k&&x===R.executionId)this.axis.setValue(H,R),this.angle.setValue(k,R);else try{const{axis:x,angle:H}=this.a.getValue(R).toAxisAngle();R._setExecutionVariable(this,n,x),R._setExecutionVariable(this,g,H),R._setExecutionVariable(this,I,R.executionId),this.axis.setValue(x,R),this.angle.setValue(H,R),this.isValid.setValue(!0,R)}catch(c){this.isValid.setValue(!1,R)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,t.h)("FlowGraphAxisAngleFromQuaternionBlock",B);class o extends A.e{constructor(R){super(c.t,c.t,c.o,((R,x)=>(0,V.f)(R,x)),"FlowGraphQuaternionFromDirectionsBlock",R)}}},14469:(R,x,H)=>{H.d(x,{e:()=>c});var k=H(14472);class c extends k.c{constructor(R,x,H,k,c,t){super(H,t),this._operation=k,this._className=c,this.a=this.registerDataInput("a",R),this.b=this.registerDataInput("b",x)}_doOperation(R){const x=this.a.getValue(R),H=this.b.getValue(R);return this._operation(x,H)}getClassName(){return this._className}}},14472:(R,x,H)=>{H.d(x,{c:()=>D});var k=H(13268),c=H(13246);const t="cachedOperationValue",A="cachedExecutionId";class D extends k.b{constructor(R,x){super(x),this.value=this.registerDataOutput("value",R),this.isValid=this.registerDataOutput("isValid",c.c)}_updateOutputs(R){const x=R._getExecutionVariable(this,A,-1),H=R._getExecutionVariable(this,t,null);if(void 0!==H&&null!==H&&x===R.executionId)this.isValid.setValue(!0,R),this.value.setValue(H,R);else try{const x=this._doOperation(R);if(void 0===x||null===x)return void this.isValid.setValue(!1,R);R._setExecutionVariable(this,t,x),R._setExecutionVariable(this,A,R.executionId),this.value.setValue(x,R),this.isValid.setValue(!0,R)}catch(k){this.isValid.setValue(!1,R)}}}},14476:(R,x,H)=>{H.d(x,{e:()=>c});var k=H(14472);class c extends k.c{constructor(R,x,H,k,c){super(x,c),this._operation=H,this._className=k,this.a=this.registerDataInput("a",R)}_doOperation(R){return this._operation(this.a.getValue(R))}getClassName(){return this._className}}}}]);