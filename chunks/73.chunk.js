"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14253:(h,d,m)=>{m.r(d),m.d(d,{FlowGraphJsonPointerParserBlock:()=>q});var j=m(12668),A=m(12671);const b=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class w{constructor(h,d){this.path=h,this.ownerBlock=d,this.templatedInputs=[];let m=b.exec(h);const w=new Set;for(;m;){const[,a]=m;if(w.has(a))throw new Error("Duplicate template variable detected.");w.add(a),this.templatedInputs.push(d.registerDataInput(a,A.i,new j.b(0))),m=b.exec(h)}}getAccessor(h,d){let m=this.path;for(const j of this.templatedInputs){const h=j.getValue(d).value;if("number"!==typeof h||h<0)throw new Error("Invalid value for templated input.");m=m.replace(`{${j.name}}`,h.toString())}return h.convert(m)}}var a=m(11080),D=m(11058),S=m(11353),M=m(14124);class q extends M.d{constructor(h){super(A.e,h),this.config=h,this.object=this.registerDataOutput("object",A.e),this.propertyName=this.registerDataOutput("propertyName",A.e),this.setterFunction=this.registerDataOutput("setFunction",A.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",A.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",A.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new w(h.jsonPointer,this)}_doOperation(h){var d,m,j;const A=this.templateComponent.getAccessor(this.config.pathConverter,h),b=A.info.get(A.object),w=null===(d=(m=A.info).getTarget)||void 0===d?void 0:d.call(m,A.object),a=null===(j=A.info.getPropertyName)||void 0===j?void 0:j[0](A.object);if(!w)throw new Error("Object is undefined");return this.object.setValue(w,h),a&&this.propertyName.setValue(a,h),b}_setPropertyValue(h,d,m,j){var A,b;const w=this.templateComponent.getAccessor(this.config.pathConverter,j),a=w.info.type;a.startsWith("Color")&&(m=E(m,a)),null===(A=(b=w.info).set)||void 0===A||A.call(b,m,w.object)}_getPropertyValue(h,d,m){const j=this.templateComponent.getAccessor(this.config.pathConverter,m),A=j.info.type,b=j.info.get(j.object);return A.startsWith("Color")?function(h){if(h instanceof S.d)return new D.i(h.r,h.g,h.b);if(h instanceof S.f)return new D.m(h.r,h.g,h.b,h.a);throw new Error("Invalid color type")}(b):b}_getInterpolationAnimationPropertyInfo(h,d,m){const j=this.templateComponent.getAccessor(this.config.pathConverter,m);return(h,d,m,A)=>{var b;const w=[],a=j.info.type;return a.startsWith("Color")&&(h=h.map((h=>({frame:h.frame,value:E(h.value,a)})))),null===(b=j.info.interpolation)||void 0===b||b.forEach(((d,b)=>{var a;const D=(null===(a=j.info.getPropertyName)||void 0===a?void 0:a[b](j.object))||"Animation-interpolation-"+b;let S=h;m!==d.type&&(S=h.map((h=>({frame:h.frame,value:d.getValue(void 0,h.value.fd?h.value.fd():[h.value],0,1)}))));const M=d.buildAnimations(j.object,D,60,S);for(const h of M)A&&h.babylonAnimation.setEasingFunction(A),w.push(h.babylonAnimation)})),w}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function E(h,d){return h.getClassName().startsWith("Color")?h:"qb"===d?new S.d(h.x,h.y,h.z):"Eb"===d?new S.f(h.x,h.y,h.z,h.w):h}(0,a.i)("FlowGraphJsonPointerParserBlock",q)},14124:(h,d,m)=>{m.d(d,{d:()=>a});var j=m(12687),A=m(12671);const b="cachedOperationValue",w="cachedExecutionId";class a extends j.d{constructor(h,d){super(d),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(h){const d=h._getExecutionVariable(this,w,-1),m=h._getExecutionVariable(this,b,null);if(void 0!==m&&null!==m&&d===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(m,h);else try{const d=this._doOperation(h);if(void 0===d||null===d)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,b,d),h._setExecutionVariable(this,w,h.executionId),this.value.setValue(d,h),this.isValid.setValue(!0,h)}catch(j){this.isValid.setValue(!1,h)}}}}}]);