"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14144:(z,u,Y)=>{Y.r(u),Y.d(u,{FlowGraphJsonPointerParserBlock:()=>g});var H=Y(12523),E=Y(12531);const J=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class l{constructor(z,u){this.path=z,this.ownerBlock=u,this.templatedInputs=[];let Y=J.exec(z);const l=new Set;for(;Y;){const[,T]=Y;if(l.has(T))throw new Error("Duplicate template variable detected.");l.add(T),this.templatedInputs.push(u.registerDataInput(T,E.g,new H.b(0))),Y=J.exec(z)}}getAccessor(z,u){let Y=this.path;for(const H of this.templatedInputs){const z=H.getValue(u).value;if("number"!==typeof z||z<0)throw new Error("Invalid value for templated input.");Y=Y.replace(`{${H.name}}`,z.toString())}return z.convert(Y)}}var T=Y(10918),b=Y(10903),L=Y(11188),D=Y(13983);class g extends D.e{constructor(z){super(E.e,z),this.config=z,this.object=this.registerDataOutput("object",E.e),this.propertyName=this.registerDataOutput("propertyName",E.e),this.setterFunction=this.registerDataOutput("setFunction",E.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",E.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",E.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new l(z.jsonPointer,this)}_doOperation(z){var u,Y,H;const E=this.templateComponent.getAccessor(this.config.pathConverter,z),J=E.info.get(E.object),l=null===(u=(Y=E.info).getTarget)||void 0===u?void 0:u.call(Y,E.object),T=null===(H=E.info.getPropertyName)||void 0===H?void 0:H[0](E.object);if(!l)throw new Error("Object is undefined");return this.object.setValue(l,z),T&&this.propertyName.setValue(T,z),J}_setPropertyValue(z,u,Y,H){var E,J;const l=this.templateComponent.getAccessor(this.config.pathConverter,H),T=l.info.type;T.startsWith("Color")&&(Y=M(Y,T)),null===(E=(J=l.info).set)||void 0===E||E.call(J,Y,l.object)}_getPropertyValue(z,u,Y){const H=this.templateComponent.getAccessor(this.config.pathConverter,Y),E=H.info.type,J=H.info.get(H.object);return E.startsWith("Color")?function(z){if(z instanceof L.c)return new b.p(z.r,z.g,z.b);if(z instanceof L.e)return new b.t(z.r,z.g,z.b,z.a);throw new Error("Invalid color type")}(J):J}_getInterpolationAnimationPropertyInfo(z,u,Y){const H=this.templateComponent.getAccessor(this.config.pathConverter,Y);return(z,u,Y,E)=>{var J;const l=[],T=H.info.type;return T.startsWith("Color")&&(z=z.map((z=>({frame:z.frame,value:M(z.value,T)})))),null===(J=H.info.interpolation)||void 0===J||J.forEach(((u,J)=>{var T;const b=(null===(T=H.info.getPropertyName)||void 0===T?void 0:T[J](H.object))||"Animation-interpolation-"+J;let L=z;Y!==u.type&&(L=z.map((z=>({frame:z.frame,value:u.getValue(void 0,z.value.al?z.value.al():[z.value],0,1)}))));const D=u.buildAnimations(H.object,b,60,L);for(const z of D)E&&z.babylonAnimation.setEasingFunction(E),l.push(z.babylonAnimation)})),l}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function M(z,u){return z.getClassName().startsWith("Color")?z:"o"===u?new L.c(z.x,z.y,z.z):"zb"===u?new L.e(z.x,z.y,z.z,z.w):z}(0,T.d)("FlowGraphJsonPointerParserBlock",g)},13983:(z,u,Y)=>{Y.d(u,{e:()=>T});var H=Y(12549),E=Y(12531);const J="cachedOperationValue",l="cachedExecutionId";class T extends H.b{constructor(z,u){super(u),this.value=this.registerDataOutput("value",z),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(z){const u=z._getExecutionVariable(this,l,-1),Y=z._getExecutionVariable(this,J,null);if(void 0!==Y&&null!==Y&&u===z.executionId)this.isValid.setValue(!0,z),this.value.setValue(Y,z);else try{const u=this._doOperation(z);if(void 0===u||null===u)return void this.isValid.setValue(!1,z);z._setExecutionVariable(this,J,u),z._setExecutionVariable(this,l,z.executionId),this.value.setValue(u,z),this.isValid.setValue(!0,z)}catch(H){this.isValid.setValue(!1,z)}}}}}]);