"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14216:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphAngleBetweenBlock:()=>K,FlowGraphAxisAngleFromQuaternionBlock:()=>g,FlowGraphConjugateBlock:()=>J,FlowGraphCrossBlock:()=>h,FlowGraphDotBlock:()=>V,FlowGraphLengthBlock:()=>X,FlowGraphNormalizeBlock:()=>m,FlowGraphQuaternionFromAxisAngleBlock:()=>o,FlowGraphQuaternionFromDirectionsBlock:()=>R,FlowGraphRotate2DBlock:()=>S,FlowGraphRotate3DBlock:()=>A,FlowGraphTransformBlock:()=>P,FlowGraphTransformCoordinatesBlock:()=>O});var n=Q(12934),T=Q(12908),L=Q(591),e=Q(14201),F=Q(14212),r=Q(651),C=Q(12950),u=Q(12582);const y="cachedOperationAxis",z="cachedOperationAngle",B="cachedExecutionId";class X extends F.c{constructor(v){super(T.c,T.u,(v=>this._polymorphicLength(v)),"FlowGraphLengthBlock",v)}_polymorphicLength(v){switch((0,C.o)(v)){case"Vector2":case"fk":case"Vector4":case"Quaternion":return v.length();default:throw new Error(`Cannot compute length of value ${v}`)}}}(0,L.f)("FlowGraphLengthBlock",X);class m extends F.c{constructor(v){super(T.c,T.c,(v=>this._polymorphicNormalize(v)),"FlowGraphNormalizeBlock",v)}_polymorphicNormalize(v){var d;let Q;switch((0,C.o)(v)){case"Vector2":case"fk":case"Vector4":case"Quaternion":if(Q=v.normalizeToNew(),null!==(d=this.config)&&void 0!==d&&d.nanOnZeroLength){0===v.length()&&Q.gk(NaN)}return Q;default:throw new Error(`Cannot normalize value ${v}`)}}}(0,L.f)("FlowGraphNormalizeBlock",m);class V extends e.b{constructor(v){super(T.c,T.c,T.u,((v,d)=>this._polymorphicDot(v,d)),"FlowGraphDotBlock",v)}_polymorphicDot(v,d){switch((0,C.o)(v)){case"Vector2":case"fk":case"Vector4":case"Quaternion":return v.dot(d);default:throw new Error(`Cannot get dot product of ${v} and ${d}`)}}}(0,L.f)("FlowGraphDotBlock",V);class h extends e.b{constructor(v){super(T.E,T.E,T.E,((v,d)=>r.j.Cross(v,d)),"FlowGraphCrossBlock",v)}}(0,L.f)("FlowGraphCrossBlock",h);class S extends e.b{constructor(v){super(T.C,T.u,T.C,((v,d)=>v.rotate(d)),"FlowGraphRotate2DBlock",v)}}(0,L.f)("FlowGraphRotate2DBlock",S);class A extends e.b{constructor(v){super(T.E,T.x,T.E,((v,d)=>v.applyRotationQuaternion(d)),"FlowGraphRotate3DBlock",v)}}function f(v,d){switch((0,C.o)(v)){case"Vector2":case"fk":return d.transformVector(v);case"Vector4":return new r.k(v.x*d.m[0]+v.y*d.m[1]+v.z*d.m[2]+v.w*d.m[3],v.x*d.m[4]+v.y*d.m[5]+v.z*d.m[6]+v.w*d.m[7],v.x*d.m[8]+v.y*d.m[9]+v.z*d.m[10]+v.w*d.m[11],v.x*d.m[12]+v.y*d.m[13]+v.z*d.m[14]+v.w*d.m[15]);default:throw new Error(`Cannot transform value ${v}`)}}(0,L.f)("FlowGraphRotate3DBlock",A);class P extends e.b{constructor(v){const d=(null===v||void 0===v?void 0:v.vectorType)||"fk",Q="Vector2"===d?"Matrix2D":"fk"===d?"Matrix3D":"Matrix";super((0,T.R)(d),(0,T.R)(Q),(0,T.R)(d),f,"FlowGraphTransformVectorBlock",v)}}(0,L.f)("FlowGraphTransformVectorBlock",P);class O extends e.b{constructor(v){super(T.E,T.l,T.E,((v,d)=>r.j.TransformCoordinates(v,d)),"FlowGraphTransformCoordinatesBlock",v)}}(0,L.f)("FlowGraphTransformCoordinatesBlock",O);class J extends F.c{constructor(v){super(T.x,T.x,(v=>v.conjugate()),"FlowGraphConjugateBlock",v)}}(0,L.f)("FlowGraphConjugateBlock",J);class K extends e.b{constructor(v){super(T.x,T.x,T.u,((v,d)=>(0,u.d)(v,d)),"FlowGraphAngleBetweenBlock",v)}}(0,L.f)("FlowGraphAngleBetweenBlock",K);class o extends e.b{constructor(v){super(T.E,T.u,T.x,((v,d)=>r.c.RotationAxis(v,d)),"FlowGraphQuaternionFromAxisAngleBlock",v)}}(0,L.f)("FlowGraphQuaternionFromAxisAngleBlock",o);class g extends n.b{constructor(v){super(v),this.a=this.registerDataInput("a",T.x),this.axis=this.registerDataOutput("axis",T.E),this.angle=this.registerDataOutput("angle",T.u),this.isValid=this.registerDataOutput("isValid",T.f)}_updateOutputs(v){const d=v._getExecutionVariable(this,B,-1),Q=v._getExecutionVariable(this,y,null),n=v._getExecutionVariable(this,z,null);if(void 0!==Q&&null!==Q&&void 0!==n&&null!==n&&d===v.executionId)this.axis.setValue(Q,v),this.angle.setValue(n,v);else try{const{axis:d,angle:Q}=this.a.getValue(v).toAxisAngle();v._setExecutionVariable(this,y,d),v._setExecutionVariable(this,z,Q),v._setExecutionVariable(this,B,v.executionId),this.axis.setValue(d,v),this.angle.setValue(Q,v),this.isValid.setValue(!0,v)}catch(T){this.isValid.setValue(!1,v)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,L.f)("FlowGraphAxisAngleFromQuaternionBlock",g);class R extends e.b{constructor(v){super(T.E,T.E,T.x,((v,d)=>(0,u.g)(v,d)),"FlowGraphQuaternionFromDirectionsBlock",v)}}},14201:(v,d,Q)=>{Q.d(d,{b:()=>T});var n=Q(14208);class T extends n.c{constructor(v,d,Q,n,T,L){super(Q,L),this._operation=n,this._className=T,this.a=this.registerDataInput("a",v),this.b=this.registerDataInput("b",d)}_doOperation(v){const d=this.a.getValue(v),Q=this.b.getValue(v);return this._operation(d,Q)}getClassName(){return this._className}}},14208:(v,d,Q)=>{Q.d(d,{c:()=>F});var n=Q(12934),T=Q(12908);const L="cachedOperationValue",e="cachedExecutionId";class F extends n.b{constructor(v,d){super(d),this.value=this.registerDataOutput("value",v),this.isValid=this.registerDataOutput("isValid",T.f)}_updateOutputs(v){const d=v._getExecutionVariable(this,e,-1),Q=v._getExecutionVariable(this,L,null);if(void 0!==Q&&null!==Q&&d===v.executionId)this.isValid.setValue(!0,v),this.value.setValue(Q,v);else try{const d=this._doOperation(v);if(void 0===d||null===d)return void this.isValid.setValue(!1,v);v._setExecutionVariable(this,L,d),v._setExecutionVariable(this,e,v.executionId),this.value.setValue(d,v),this.isValid.setValue(!0,v)}catch(n){this.isValid.setValue(!1,v)}}}},14212:(v,d,Q)=>{Q.d(d,{c:()=>T});var n=Q(14208);class T extends n.c{constructor(v,d,Q,n,T){super(d,T),this._operation=Q,this._className=n,this.a=this.registerDataInput("a",v)}_doOperation(v){return this._operation(this.a.getValue(v))}getClassName(){return this._className}}}}]);