"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14087:(Z,U,n)=>{n.r(U),n.d(U,{FlowGraphAngleBetweenBlock:()=>D,FlowGraphAxisAngleFromQuaternionBlock:()=>j,FlowGraphConjugateBlock:()=>C,FlowGraphCrossBlock:()=>z,FlowGraphDotBlock:()=>s,FlowGraphLengthBlock:()=>q,FlowGraphNormalizeBlock:()=>c,FlowGraphQuaternionFromAxisAngleBlock:()=>u,FlowGraphQuaternionFromDirectionsBlock:()=>v,FlowGraphRotate2DBlock:()=>O,FlowGraphRotate3DBlock:()=>E,FlowGraphTransformBlock:()=>p,FlowGraphTransformCoordinatesBlock:()=>K});var i=n(12837),B=n(12826),l=n(633),H=n(14070),V=n(14078),G=n(702),R=n(12848),d=n(12566);const F="cachedOperationAxis",y="cachedOperationAngle",S="cachedExecutionId";class q extends V.e{constructor(Z){super(B.b,B.s,(Z=>this._polymorphicLength(Z)),"FlowGraphLengthBlock",Z)}_polymorphicLength(Z){switch((0,R.i)(Z)){case"Vector2":case"ti":case"Vector4":case"Quaternion":return Z.length();default:throw new Error(`Cannot compute length of value ${Z}`)}}}(0,l.g)("FlowGraphLengthBlock",q);class c extends V.e{constructor(Z){super(B.b,B.b,(Z=>this._polymorphicNormalize(Z)),"FlowGraphNormalizeBlock",Z)}_polymorphicNormalize(Z){var U;let n;switch((0,R.i)(Z)){case"Vector2":case"ti":case"Vector4":case"Quaternion":if(n=Z.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===Z.length()&&n.si(NaN)}return n;default:throw new Error(`Cannot normalize value ${Z}`)}}}(0,l.g)("FlowGraphNormalizeBlock",c);class s extends H.c{constructor(Z){super(B.b,B.b,B.s,((Z,U)=>this._polymorphicDot(Z,U)),"FlowGraphDotBlock",Z)}_polymorphicDot(Z,U){switch((0,R.i)(Z)){case"Vector2":case"ti":case"Vector4":case"Quaternion":return Z.dot(U);default:throw new Error(`Cannot get dot product of ${Z} and ${U}`)}}}(0,l.g)("FlowGraphDotBlock",s);class z extends H.c{constructor(Z){super(B.z,B.z,B.z,((Z,U)=>G.k.Cross(Z,U)),"FlowGraphCrossBlock",Z)}}(0,l.g)("FlowGraphCrossBlock",z);class O extends H.c{constructor(Z){super(B.y,B.s,B.y,((Z,U)=>Z.rotate(U)),"FlowGraphRotate2DBlock",Z)}}(0,l.g)("FlowGraphRotate2DBlock",O);class E extends H.c{constructor(Z){super(B.z,B.u,B.z,((Z,U)=>Z.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",Z)}}function t(Z,U){switch((0,R.i)(Z)){case"Vector2":case"ti":return U.transformVector(Z);case"Vector4":return new G.o(Z.x*U.m[0]+Z.y*U.m[1]+Z.z*U.m[2]+Z.w*U.m[3],Z.x*U.m[4]+Z.y*U.m[5]+Z.z*U.m[6]+Z.w*U.m[7],Z.x*U.m[8]+Z.y*U.m[9]+Z.z*U.m[10]+Z.w*U.m[11],Z.x*U.m[12]+Z.y*U.m[13]+Z.z*U.m[14]+Z.w*U.m[15]);default:throw new Error(`Cannot transform value ${Z}`)}}(0,l.g)("FlowGraphRotate3DBlock",E);class p extends H.c{constructor(Z){const U=(null===Z||void 0===Z?void 0:Z.vectorType)||"ti",n="Vector2"===U?"Matrix2D":"ti"===U?"Matrix3D":"Matrix";super((0,B.J)(U),(0,B.J)(n),(0,B.J)(U),t,"FlowGraphTransformVectorBlock",Z)}}(0,l.g)("FlowGraphTransformVectorBlock",p);class K extends H.c{constructor(Z){super(B.z,B.j,B.z,((Z,U)=>G.k.TransformCoordinates(Z,U)),"FlowGraphTransformCoordinatesBlock",Z)}}(0,l.g)("FlowGraphTransformCoordinatesBlock",K);class C extends V.e{constructor(Z){super(B.u,B.u,(Z=>Z.conjugate()),"FlowGraphConjugateBlock",Z)}}(0,l.g)("FlowGraphConjugateBlock",C);class D extends H.c{constructor(Z){super(B.u,B.u,B.s,((Z,U)=>(0,d.b)(Z,U)),"FlowGraphAngleBetweenBlock",Z)}}(0,l.g)("FlowGraphAngleBetweenBlock",D);class u extends H.c{constructor(Z){super(B.z,B.s,B.u,((Z,U)=>G.d.RotationAxis(Z,U)),"FlowGraphQuaternionFromAxisAngleBlock",Z)}}(0,l.g)("FlowGraphQuaternionFromAxisAngleBlock",u);class j extends i.b{constructor(Z){super(Z),this.a=this.registerDataInput("a",B.u),this.axis=this.registerDataOutput("axis",B.z),this.angle=this.registerDataOutput("angle",B.s),this.isValid=this.registerDataOutput("isValid",B.e)}_updateOutputs(Z){const U=Z._getExecutionVariable(this,S,-1),n=Z._getExecutionVariable(this,F,null),i=Z._getExecutionVariable(this,y,null);if(void 0!==n&&null!==n&&void 0!==i&&null!==i&&U===Z.executionId)this.axis.setValue(n,Z),this.angle.setValue(i,Z);else try{const{axis:U,angle:n}=this.a.getValue(Z).toAxisAngle();Z._setExecutionVariable(this,F,U),Z._setExecutionVariable(this,y,n),Z._setExecutionVariable(this,S,Z.executionId),this.axis.setValue(U,Z),this.angle.setValue(n,Z),this.isValid.setValue(!0,Z)}catch(B){this.isValid.setValue(!1,Z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,l.g)("FlowGraphAxisAngleFromQuaternionBlock",j);class v extends H.c{constructor(Z){super(B.z,B.z,B.u,((Z,U)=>(0,d.c)(Z,U)),"FlowGraphQuaternionFromDirectionsBlock",Z)}}},14070:(Z,U,n)=>{n.d(U,{c:()=>B});var i=n(14076);class B extends i.d{constructor(Z,U,n,i,B,l){super(n,l),this._operation=i,this._className=B,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",U)}_doOperation(Z){const U=this.a.getValue(Z),n=this.b.getValue(Z);return this._operation(U,n)}getClassName(){return this._className}}},14076:(Z,U,n)=>{n.d(U,{d:()=>V});var i=n(12837),B=n(12826);const l="cachedOperationValue",H="cachedExecutionId";class V extends i.b{constructor(Z,U){super(U),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",B.e)}_updateOutputs(Z){const U=Z._getExecutionVariable(this,H,-1),n=Z._getExecutionVariable(this,l,null);if(void 0!==n&&null!==n&&U===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(n,Z);else try{const U=this._doOperation(Z);if(void 0===U||null===U)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,l,U),Z._setExecutionVariable(this,H,Z.executionId),this.value.setValue(U,Z),this.isValid.setValue(!0,Z)}catch(i){this.isValid.setValue(!1,Z)}}}},14078:(Z,U,n)=>{n.d(U,{e:()=>B});var i=n(14076);class B extends i.d{constructor(Z,U,n,i,B){super(U,B),this._operation=n,this._className=i,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);