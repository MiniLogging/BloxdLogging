"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{13771:(L,j,P)=>{P.r(j),P.d(j,{FlowGraphAngleBetweenBlock:()=>M,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>G,FlowGraphCrossBlock:()=>h,FlowGraphDotBlock:()=>f,FlowGraphLengthBlock:()=>C,FlowGraphNormalizeBlock:()=>b,FlowGraphQuaternionFromAxisAngleBlock:()=>Q,FlowGraphQuaternionFromDirectionsBlock:()=>w,FlowGraphRotate2DBlock:()=>K,FlowGraphRotate3DBlock:()=>v,FlowGraphTransformBlock:()=>y,FlowGraphTransformCoordinatesBlock:()=>T});var A=P(12523),R=P(12510),o=P(606),Y=P(13760),u=P(13764),a=P(656),D=P(12531),S=P(12188);const g="cachedOperationAxis",V="cachedOperationAngle",N="cachedExecutionId";class C extends u.c{constructor(L){super(R.d,R.p,(L=>this._polymorphicLength(L)),"FlowGraphLengthBlock",L)}_polymorphicLength(L){switch((0,D.m)(L)){case"Vector2":case"ti":case"Vector4":case"Quaternion":return L.length();default:throw new Error(`Cannot compute length of value ${L}`)}}}(0,o.h)("FlowGraphLengthBlock",C);class b extends u.c{constructor(L){super(R.d,R.d,(L=>this._polymorphicNormalize(L)),"FlowGraphNormalizeBlock",L)}_polymorphicNormalize(L){var j;let P;switch((0,D.m)(L)){case"Vector2":case"ti":case"Vector4":case"Quaternion":if(P=L.normalizeToNew(),null!==(j=this.config)&&void 0!==j&&j.nanOnZeroLength){0===L.length()&&P.si(NaN)}return P;default:throw new Error(`Cannot normalize value ${L}`)}}}(0,o.h)("FlowGraphNormalizeBlock",b);class f extends Y.d{constructor(L){super(R.d,R.d,R.p,((L,j)=>this._polymorphicDot(L,j)),"FlowGraphDotBlock",L)}_polymorphicDot(L,j){switch((0,D.m)(L)){case"Vector2":case"ti":case"Vector4":case"Quaternion":return L.dot(j);default:throw new Error(`Cannot get dot product of ${L} and ${j}`)}}}(0,o.h)("FlowGraphDotBlock",f);class h extends Y.d{constructor(L){super(R.B,R.B,R.B,((L,j)=>a.r.Cross(L,j)),"FlowGraphCrossBlock",L)}}(0,o.h)("FlowGraphCrossBlock",h);class K extends Y.d{constructor(L){super(R.y,R.p,R.y,((L,j)=>L.rotate(j)),"FlowGraphRotate2DBlock",L)}}(0,o.h)("FlowGraphRotate2DBlock",K);class v extends Y.d{constructor(L){super(R.B,R.t,R.B,((L,j)=>L.applyRotationQuaternion(j)),"FlowGraphRotate3DBlock",L)}}function q(L,j){switch((0,D.m)(L)){case"Vector2":case"ti":return j.transformVector(L);case"Vector4":return new a.s(L.x*j.m[0]+L.y*j.m[1]+L.z*j.m[2]+L.w*j.m[3],L.x*j.m[4]+L.y*j.m[5]+L.z*j.m[6]+L.w*j.m[7],L.x*j.m[8]+L.y*j.m[9]+L.z*j.m[10]+L.w*j.m[11],L.x*j.m[12]+L.y*j.m[13]+L.z*j.m[14]+L.w*j.m[15]);default:throw new Error(`Cannot transform value ${L}`)}}(0,o.h)("FlowGraphRotate3DBlock",v);class y extends Y.d{constructor(L){const j=(null===L||void 0===L?void 0:L.vectorType)||"ti",P="Vector2"===j?"Matrix2D":"ti"===j?"Matrix3D":"Matrix";super((0,R.N)(j),(0,R.N)(P),(0,R.N)(j),q,"FlowGraphTransformVectorBlock",L)}}(0,o.h)("FlowGraphTransformVectorBlock",y);class T extends Y.d{constructor(L){super(R.B,R.j,R.B,((L,j)=>a.r.TransformCoordinates(L,j)),"FlowGraphTransformCoordinatesBlock",L)}}(0,o.h)("FlowGraphTransformCoordinatesBlock",T);class G extends u.c{constructor(L){super(R.t,R.t,(L=>L.conjugate()),"FlowGraphConjugateBlock",L)}}(0,o.h)("FlowGraphConjugateBlock",G);class M extends Y.d{constructor(L){super(R.t,R.t,R.p,((L,j)=>(0,S.d)(L,j)),"FlowGraphAngleBetweenBlock",L)}}(0,o.h)("FlowGraphAngleBetweenBlock",M);class Q extends Y.d{constructor(L){super(R.B,R.p,R.t,((L,j)=>a.i.RotationAxis(L,j)),"FlowGraphQuaternionFromAxisAngleBlock",L)}}(0,o.h)("FlowGraphQuaternionFromAxisAngleBlock",Q);class l extends A.d{constructor(L){super(L),this.a=this.registerDataInput("a",R.t),this.axis=this.registerDataOutput("axis",R.B),this.angle=this.registerDataOutput("angle",R.p),this.isValid=this.registerDataOutput("isValid",R.e)}_updateOutputs(L){const j=L._getExecutionVariable(this,N,-1),P=L._getExecutionVariable(this,g,null),A=L._getExecutionVariable(this,V,null);if(void 0!==P&&null!==P&&void 0!==A&&null!==A&&j===L.executionId)this.axis.setValue(P,L),this.angle.setValue(A,L);else try{const{axis:j,angle:P}=this.a.getValue(L).toAxisAngle();L._setExecutionVariable(this,g,j),L._setExecutionVariable(this,V,P),L._setExecutionVariable(this,N,L.executionId),this.axis.setValue(j,L),this.angle.setValue(P,L),this.isValid.setValue(!0,L)}catch(R){this.isValid.setValue(!1,L)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,o.h)("FlowGraphAxisAngleFromQuaternionBlock",l);class w extends Y.d{constructor(L){super(R.B,R.B,R.t,((L,j)=>(0,S.h)(L,j)),"FlowGraphQuaternionFromDirectionsBlock",L)}}},13760:(L,j,P)=>{P.d(j,{d:()=>R});var A=P(13762);class R extends A.b{constructor(L,j,P,A,R,o){super(P,o),this._operation=A,this._className=R,this.a=this.registerDataInput("a",L),this.b=this.registerDataInput("b",j)}_doOperation(L){const j=this.a.getValue(L),P=this.b.getValue(L);return this._operation(j,P)}getClassName(){return this._className}}},13762:(L,j,P)=>{P.d(j,{b:()=>u});var A=P(12523),R=P(12510);const o="cachedOperationValue",Y="cachedExecutionId";class u extends A.d{constructor(L,j){super(j),this.value=this.registerDataOutput("value",L),this.isValid=this.registerDataOutput("isValid",R.e)}_updateOutputs(L){const j=L._getExecutionVariable(this,Y,-1),P=L._getExecutionVariable(this,o,null);if(void 0!==P&&null!==P&&j===L.executionId)this.isValid.setValue(!0,L),this.value.setValue(P,L);else try{const j=this._doOperation(L);if(void 0===j||null===j)return void this.isValid.setValue(!1,L);L._setExecutionVariable(this,o,j),L._setExecutionVariable(this,Y,L.executionId),this.value.setValue(j,L),this.isValid.setValue(!0,L)}catch(A){this.isValid.setValue(!1,L)}}}},13764:(L,j,P)=>{P.d(j,{c:()=>R});var A=P(13762);class R extends A.b{constructor(L,j,P,A,R){super(j,R),this._operation=P,this._className=A,this.a=this.registerDataInput("a",L)}_doOperation(L){return this._operation(this.a.getValue(L))}getClassName(){return this._className}}}}]);