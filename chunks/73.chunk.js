"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14517:(Z,c,L)=>{L.r(c),L.d(c,{FlowGraphJsonPointerParserBlock:()=>i});var k=L(12817),N=L(12825);const R=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class G{constructor(Z,c){this.path=Z,this.ownerBlock=c,this.templatedInputs=[];let L=R.exec(Z);const G=new Set;for(;L;){const[,V]=L;if(G.has(V))throw new Error("Duplicate template variable detected.");G.add(V),this.templatedInputs.push(c.registerDataInput(V,N.i,new k.b(0))),L=R.exec(Z)}}getAccessor(Z,c){let L=this.path;for(const k of this.templatedInputs){const Z=k.getValue(c).value;if("number"!==typeof Z||Z<0)throw new Error("Invalid value for templated input.");L=L.replace(`{${k.name}}`,Z.toString())}return Z.convert(L)}}var V=L(11012),p=L(10993),J=L(11255),z=L(14364);class i extends z.d{constructor(Z){super(N.e,Z),this.config=Z,this.object=this.registerDataOutput("object",N.e),this.propertyName=this.registerDataOutput("propertyName",N.e),this.setterFunction=this.registerDataOutput("setFunction",N.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",N.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",N.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new G(Z.jsonPointer,this)}_doOperation(Z){var c,L,k;const N=this.templateComponent.getAccessor(this.config.pathConverter,Z),R=N.info.get(N.object),G=null===(c=(L=N.info).getTarget)||void 0===c?void 0:c.call(L,N.object),V=null===(k=N.info.getPropertyName)||void 0===k?void 0:k[0](N.object);if(!G)throw new Error("Object is undefined");return this.object.setValue(G,Z),V&&this.propertyName.setValue(V,Z),R}_setPropertyValue(Z,c,L,k){var N,R;const G=this.templateComponent.getAccessor(this.config.pathConverter,k),V=G.info.type;V.startsWith("Color")&&(L=t(L,V)),null===(N=(R=G.info).set)||void 0===N||N.call(R,L,G.object)}_getPropertyValue(Z,c,L){const k=this.templateComponent.getAccessor(this.config.pathConverter,L),N=k.info.type,R=k.info.get(k.object);return N.startsWith("Color")?function(Z){if(Z instanceof J.d)return new p.h(Z.r,Z.g,Z.b);if(Z instanceof J.h)return new p.j(Z.r,Z.g,Z.b,Z.a);throw new Error("Invalid color type")}(R):R}_getInterpolationAnimationPropertyInfo(Z,c,L){const k=this.templateComponent.getAccessor(this.config.pathConverter,L);return(Z,c,L,N)=>{var R;const G=[],V=k.info.type;return V.startsWith("Color")&&(Z=Z.map((Z=>({frame:Z.frame,value:t(Z.value,V)})))),null===(R=k.info.interpolation)||void 0===R||R.forEach(((c,R)=>{var V;const p=(null===(V=k.info.getPropertyName)||void 0===V?void 0:V[R](k.object))||"Animation-interpolation-"+R;let J=Z;L!==c.type&&(J=Z.map((Z=>({frame:Z.frame,value:c.getValue(void 0,Z.value.xc?Z.value.xc():[Z.value],0,1)}))));const z=c.buildAnimations(k.object,p,60,J);for(const Z of z)N&&Z.babylonAnimation.setEasingFunction(N),G.push(Z.babylonAnimation)})),G}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function t(Z,c){return Z.getClassName().startsWith("Color")?Z:"sc"===c?new J.d(Z.x,Z.y,Z.z):"mc"===c?new J.h(Z.x,Z.y,Z.z,Z.w):Z}(0,V.g)("FlowGraphJsonPointerParserBlock",i)},14364:(Z,c,L)=>{L.d(c,{d:()=>V});var k=L(12846),N=L(12825);const R="cachedOperationValue",G="cachedExecutionId";class V extends k.c{constructor(Z,c){super(c),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(Z){const c=Z._getExecutionVariable(this,G,-1),L=Z._getExecutionVariable(this,R,null);if(void 0!==L&&null!==L&&c===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(L,Z);else try{const c=this._doOperation(Z);if(void 0===c||null===c)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,R,c),Z._setExecutionVariable(this,G,Z.executionId),this.value.setValue(c,Z),this.isValid.setValue(!0,Z)}catch(k){this.isValid.setValue(!1,Z)}}}}}]);