"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[73],{14555:(V,I,m)=>{m.r(I),m.d(I,{FlowGraphJsonPointerParserBlock:()=>Y});var C=m(12896),l=m(12899);const s=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class F{constructor(V,I){this.path=V,this.ownerBlock=I,this.templatedInputs=[];let m=s.exec(V);const F=new Set;for(;m;){const[,k]=m;if(F.has(k))throw new Error("Duplicate template variable detected.");F.add(k),this.templatedInputs.push(I.registerDataInput(k,l.h,new C.b(0))),m=s.exec(V)}}getAccessor(V,I){let m=this.path;for(const C of this.templatedInputs){const V=C.getValue(I).value;if("number"!==typeof V||V<0)throw new Error("Invalid value for templated input.");m=m.replace(`{${C.name}}`,V.toString())}return V.convert(m)}}var k=m(11048),j=m(11040),E=m(11312),K=m(14427);class Y extends K.e{constructor(V){super(l.b,V),this.config=V,this.object=this.registerDataOutput("object",l.b),this.propertyName=this.registerDataOutput("propertyName",l.b),this.setterFunction=this.registerDataOutput("setFunction",l.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",l.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",l.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new F(V.jsonPointer,this)}_doOperation(V){var I,m,C;const l=this.templateComponent.getAccessor(this.config.pathConverter,V),s=l.info.get(l.object),F=null===(I=(m=l.info).getTarget)||void 0===I?void 0:I.call(m,l.object),k=null===(C=l.info.getPropertyName)||void 0===C?void 0:C[0](l.object);if(!F)throw new Error("Object is undefined");return this.object.setValue(F,V),k&&this.propertyName.setValue(k,V),s}_setPropertyValue(V,I,m,C){var l,s;const F=this.templateComponent.getAccessor(this.config.pathConverter,C),k=F.info.type;k.startsWith("Color")&&(m=X(m,k)),null===(l=(s=F.info).set)||void 0===l||l.call(s,m,F.object)}_getPropertyValue(V,I,m){const C=this.templateComponent.getAccessor(this.config.pathConverter,m),l=C.info.type,s=C.info.get(C.object);return l.startsWith("Color")?function(V){if(V instanceof E.c)return new j.m(V.r,V.g,V.b);if(V instanceof E.d)return new j.n(V.r,V.g,V.b,V.a);throw new Error("Invalid color type")}(s):s}_getInterpolationAnimationPropertyInfo(V,I,m){const C=this.templateComponent.getAccessor(this.config.pathConverter,m);return(V,I,m,l)=>{var s;const F=[],k=C.info.type;return k.startsWith("Color")&&(V=V.map((V=>({frame:V.frame,value:X(V.value,k)})))),null===(s=C.info.interpolation)||void 0===s||s.forEach(((I,s)=>{var k;const j=(null===(k=C.info.getPropertyName)||void 0===k?void 0:k[s](C.object))||"Animation-interpolation-"+s;let E=V;m!==I.type&&(E=V.map((V=>({frame:V.frame,value:I.getValue(void 0,V.value.UF?V.value.UF():[V.value],0,1)}))));const K=I.buildAnimations(C.object,j,60,E);for(const V of K)l&&V.babylonAnimation.setEasingFunction(l),F.push(V.babylonAnimation)})),F}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function X(V,I){return V.getClassName().startsWith("Color")?V:"dY"===I?new E.c(V.x,V.y,V.z):"dX"===I?new E.d(V.x,V.y,V.z,V.w):V}(0,k.h)("FlowGraphJsonPointerParserBlock",Y)},14427:(V,I,m)=>{m.d(I,{e:()=>k});var C=m(12921),l=m(12899);const s="cachedOperationValue",F="cachedExecutionId";class k extends C.e{constructor(V,I){super(I),this.value=this.registerDataOutput("value",V),this.isValid=this.registerDataOutput("isValid",l.d)}_updateOutputs(V){const I=V._getExecutionVariable(this,F,-1),m=V._getExecutionVariable(this,s,null);if(void 0!==m&&null!==m&&I===V.executionId)this.isValid.setValue(!0,V),this.value.setValue(m,V);else try{const I=this._doOperation(V);if(void 0===I||null===I)return void this.isValid.setValue(!1,V);V._setExecutionVariable(this,s,I),V._setExecutionVariable(this,F,V.executionId),this.value.setValue(I,V),this.isValid.setValue(!0,V)}catch(C){this.isValid.setValue(!1,V)}}}}}]);