"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[19],{11300:(V,I,A)=>{A.d(I,{d:()=>Y,g:()=>H});var B=A(11305),F=A(11064),E=A(11311);class Y{get H(){return this._isDisposed}constructor(V,I,A){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],H=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7?arguments[7]:void 0,b=arguments.length>8?arguments[8]:void 0;this._isAlreadyOwned=!1,this._isDisposed=!1,V&&V.sV?this._engine=V.sV().getEngine():this._engine=V,this._updatable=A,this._instanced=Y,this._divisor=c||1,this._label=b,I instanceof B.d?(this._data=null,this._buffer=I):(this._data=I,this._buffer=null),this.byteStride=H?F:F*Float32Array.BYTES_PER_ELEMENT,E||this.create()}createVertexBuffer(V,I,A,B,F){let E=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6?arguments[6]:void 0;const c=E?I:I*Float32Array.BYTES_PER_ELEMENT,b=B?E?B:B*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new H(this._engine,this,V,this._updatable,!0,b,void 0===F?this._instanced:F,c,A,void 0,void 0,!0,this._divisor||Y)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;!V&&this._buffer||(V=V||this._data,V&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,V),this._data=V):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(V,this._label),this._data=V):this._buffer=this._engine.createVertexBuffer(V,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.tA>0)return void(this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.tA,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.tA,void 0,this._label));F.b.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(V){this.create(V)}updateDirectly(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,V,B?I:I*Float32Array.BYTES_PER_ELEMENT,A?A*this.byteStride:void 0),this._data=0===I&&void 0===A?V:null)}_increaseReferences(){this._buffer&&(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class H{get H(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(V){const I=0!=V;this._instanceDivisor=V,I!==this._instanced&&(this._instanced=I,this._computeHashCode())}get _maxVerticesCount(){const V=this.getData();return V?Array.isArray(V)?V.length/(this.byteStride/4)-this.byteOffset/4:(V.byteLength-this.byteOffset)/this.byteStride:0}constructor(V,I,A,B,F,c,b,X,P,J){let G=arguments.length>10&&void 0!==arguments[10]&&arguments[10],w=arguments.length>11&&void 0!==arguments[11]&&arguments[11],t=arguments.length>12&&void 0!==arguments[12]?arguments[12]:1,u=arguments.length>13&&void 0!==arguments[13]&&arguments[13];this._isDisposed=!1;let W=!1;if(this.wI=V,"object"===typeof B&&null!==B?(W=B.updatable??!1,F=B.postponeInternalCreation,c=B.stride,b=B.instanced,X=B.offset,P=B.size,J=B.type,G=B.normalized??!1,w=B.useBytes??!1,t=B.divisor??1,u=B.takeBufferOwnership??!1,this._label=B.label):W=!!B,I instanceof Y?(this._buffer=I,this._ownsBuffer=u):(this._buffer=new Y(V,I,W,c,F,b,w,t,this._label),this._ownsBuffer=!0),this.uniqueId=H._Counter++,this._kind=A,void 0===J){const V=this.getData();this.type=V?H.GetDataType(V):H.FLOAT}else this.type=J;const g=(0,E.l)(this.type);w?(this._size=P||(c?c/g:H.DeduceStride(A)),this.byteStride=c||this._buffer.byteStride||this._size*g,this.byteOffset=X||0):(this._size=P||c||H.DeduceStride(A),this.byteStride=c?c*g:this._buffer.byteStride||this._size*g,this.byteOffset=(X||0)*g),this.normalized=G,this._instanced=void 0!==b&&b,this._instanceDivisor=b?t:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120|0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){var V;null===(V=this._buffer)||void 0===V||V._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(V,I){const A=this.getData();return A?(0,E.i)(A,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,V,I):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/(0,E.l)(this.type)}getOffset(){return this.byteOffset/(0,E.l)(this.type)}getSize(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this._size*(0,E.l)(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(V){this._buffer.create(V),this._alignBuffer()}update(V){this._buffer.update(V),this._alignBuffer()}updateDirectly(V,I){let A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._buffer.updateDirectly(V,I,void 0,A),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(V,I){(0,E.h)(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,V,this.normalized,((V,A)=>{for(let B=0;B<this._size;B++)I(V[B],A+B)}))}_alignBuffer(){}static DeduceStride(V){switch(V){case H.UVKind:case H.UV2Kind:case H.UV3Kind:case H.UV4Kind:case H.UV5Kind:case H.UV6Kind:return 2;case H.NormalKind:case H.PositionKind:return 3;case H.ColorKind:case H.ColorInstanceKind:case H.MatricesIndicesKind:case H.MatricesIndicesExtraKind:case H.MatricesWeightsKind:case H.MatricesWeightsExtraKind:case H.TangentKind:return 4;default:throw new Error("Invalid kind '"+V+"'")}}static GetDataType(V){return V instanceof Int8Array?H.BYTE:V instanceof Uint8Array?H.UNSIGNED_BYTE:V instanceof Int16Array?H.SHORT:V instanceof Uint16Array?H.UNSIGNED_SHORT:V instanceof Int32Array?H.INT:V instanceof Uint32Array?H.UNSIGNED_INT:H.FLOAT}static GetTypeByteLength(V){return(0,E.l)(V)}static ForEach(V,I,A,B,F,Y,H,c){(0,E.h)(V,I,A,B,F,Y,H,((V,I)=>{for(let A=0;A<B;A++)c(V[A],I+A)}))}static GetFloatData(V,I,A,B,F,Y,H,c){return(0,E.i)(V,I,A,B,F,Y,H,c)}}H._Counter=0,H.BYTE=5120,H.UNSIGNED_BYTE=5121,H.SHORT=5122,H.UNSIGNED_SHORT=5123,H.INT=5124,H.UNSIGNED_INT=5125,H.FLOAT=5126,H.PositionKind="position",H.NormalKind="normal",H.TangentKind="tangent",H.UVKind="uv",H.UV2Kind="uv2",H.UV3Kind="uv3",H.UV4Kind="uv4",H.UV5Kind="uv5",H.UV6Kind="uv6",H.ColorKind="color",H.ColorInstanceKind="instanceColor",H.MatricesIndicesKind="matricesIndices",H.MatricesWeightsKind="matricesWeights",H.MatricesIndicesExtraKind="matricesIndicesExtra",H.MatricesWeightsExtraKind="matricesWeightsExtra"},11311:(V,I,A)=>{A.d(I,{d:()=>J,f:()=>P,h:()=>c,i:()=>b,l:()=>Y,p:()=>H,s:()=>X});var B=A(11064);function F(V,I,A,B){switch(I){case 5120:{let I=V.getInt8(A);return B&&(I=Math.max(I/127,-1)),I}case 5121:{let I=V.getUint8(A);return B&&(I/=255),I}case 5122:{let I=V.getInt16(A,!0);return B&&(I=Math.max(I/32767,-1)),I}case 5123:{let I=V.getUint16(A,!0);return B&&(I/=65535),I}case 5124:return V.getInt32(A,!0);case 5125:return V.getUint32(A,!0);case 5126:return V.getFloat32(A,!0);default:throw new Error(`Invalid component type ${I}`)}}function E(V,I,A,B,F){switch(I){case 5120:B&&(F=Math.round(127*F)),V.setInt8(A,F);break;case 5121:B&&(F=Math.round(255*F)),V.setUint8(A,F);break;case 5122:B&&(F=Math.round(32767*F)),V.setInt16(A,F,!0);break;case 5123:B&&(F=Math.round(65535*F)),V.setUint16(A,F,!0);break;case 5124:V.setInt32(A,F,!0);break;case 5125:V.setUint32(A,F,!0);break;case 5126:V.setFloat32(A,F,!0);break;default:throw new Error(`Invalid component type ${I}`)}}function Y(V){switch(V){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${V}'`)}}function H(V){switch(V){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Invalid component type '${V}'`)}}function c(V,I,A,B,H,c,b,X){const P=new Array(B),J=new Array(B);if(V instanceof Array){let F=I/4;const E=A/4;for(let I=0;I<c;I+=B){for(let I=0;I<B;I++)P[I]=J[I]=V[F+I];X(J,I);for(let I=0;I<B;I++)P[I]!==J[I]&&(V[F+I]=J[I]);F+=E}}else{const G=ArrayBuffer.isView(V)?new DataView(V.buffer,V.byteOffset,V.byteLength):new DataView(V),w=Y(H);for(let V=0;V<c;V+=B){for(let V=0,A=I;V<B;V++,A+=w)P[V]=J[V]=F(G,H,A,b);X(J,V);for(let V=0,A=I;V<B;V++,A+=w)P[V]!==J[V]&&E(G,H,A,b,J[V]);I+=A}}}function b(V,I,A,F,E,H,b,X){const P=I*Y(A),J=b*I;if(5126!==A||E!==P){const B=new Float32Array(J);return c(V,F,E,I,A,J,H,((V,A)=>{for(let F=0;F<I;F++)B[A+F]=V[F]})),B}if(!(V instanceof Array||V instanceof Float32Array)||0!==F||V.length!==J){if(V instanceof Array){const I=F/4;return V.slice(I,I+J)}if(V instanceof ArrayBuffer)return new Float32Array(V,F,J);{const I=V.byteOffset+F;return 0!==(3&I)&&(B.b.Warn("Float array must be aligned to 4-bytes border"),X=!0),X?new Float32Array(V.buffer.slice(I,I+J*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(V.buffer,I,J)}}return X?V.slice():V}function X(V,I,A,F,E,b,X,P){const J=Y(A),G=H(A),w=X*I;if(Array.isArray(V)){if(0!==(3&F)||0!==(3&E))throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");const B=F/4,Y=E/4;if(B+(X-1)*Y+I>V.length)throw new Error("Last accessed index is out of bounds.");if(Y<I)throw new Error("Data stride cannot be smaller than the component size.");if(Y!==I){const B=new G(w);return c(V,F,E,I,A,w,b,((V,A)=>{for(let F=0;F<I;F++)B[A+F]=V[F]})),B}return new G(V.slice(B,B+w))}let t,u=F;V instanceof ArrayBuffer?t=V:(t=V.buffer,u+=V.byteOffset);if(u+(X-1)*E+I*J>t.byteLength)throw new Error("Last accessed byte is out of bounds.");const W=I*J;if(E<W)throw new Error("Byte stride cannot be smaller than the component's byte size.");if(E!==W){const V=new G(w);return c(t,u,E,I,A,w,b,((A,B)=>{for(let F=0;F<I;F++)V[B+F]=A[F]})),V}return 1!==J&&0!==(u&J-1)&&(B.b.Warn("Array must be aligned to border of element size. Data will be copied."),P=!0),P?new G(t.slice(u,u+w*J)):new G(t,u,w)}function P(V,I,A,F,E,H,b,X){const P=I*Y(A),J=b*I;if(X.length!==J)throw new Error("Output length is not valid");if(5126===A&&E===P)if(V instanceof Array){const I=F/4;X.set(V,I)}else if(V instanceof ArrayBuffer){const I=new Float32Array(V,F,J);X.set(I)}else{const I=V.byteOffset+F;if(0!==(3&I))return B.b.Warn("Float array must be aligned to 4-bytes border"),void X.set(new Float32Array(V.buffer.slice(I,I+J*Float32Array.BYTES_PER_ELEMENT)));const A=new Float32Array(V.buffer,I,J);X.set(A)}else c(V,F,E,I,A,J,H,((V,A)=>{for(let B=0;B<I;B++)X[A+B]=V[B]}))}function J(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(Array.isArray(V)){for(let F=0;F<I;F++)if(V[A+F]-B>65535)return!0;return!1}return 4===V.BYTES_PER_ELEMENT}},11305:(V,I,A)=>{A.d(I,{d:()=>B});class B{get underlyingResource(){return null}constructor(){this.references=0,this.tA=0,this.is32Bits=!1,this.uniqueId=B._Counter++}}B._Counter=0},11347:(V,I,A)=>{A.d(I,{e:()=>F});var B=A(11135);class F{static GetEffect(V){return void 0===V.getPipelineContext?V.effect:V}constructor(V){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=V.createDrawContext(),I&&(this.materialContext=V.createMaterialContext())}setEffect(V,I){let A=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];var B;(this.effect=V,void 0!==I&&(this.defines=I),A)&&(null===(B=this.drawContext)||void 0===B||B.reset())}dispose(){var V;let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.effect){const V=this.effect;I?V.dispose():B.c.SetImmediate((()=>{V.getEngine().onEndFrameObservable.addOnce((()=>{V.dispose()}))})),this.effect=null}null===(V=this.drawContext)||void 0===V||V.dispose()}}},11436:(V,I,A)=>{A.d(I,{d:()=>F});var B=A(11278);class F{static GetPlanes(V){const I=[];for(let A=0;A<6;A++)I.push(new B.d(0,0,0,0));return F.GetPlanesToRef(V,I),I}static GetNearPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]+A[2],I.normal.y=A[7]+A[6],I.normal.z=A[11]+A[10],I.d=A[15]+A[14],I.normalize()}static GetFarPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]-A[2],I.normal.y=A[7]-A[6],I.normal.z=A[11]-A[10],I.d=A[15]-A[14],I.normalize()}static GetLeftPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]+A[0],I.normal.y=A[7]+A[4],I.normal.z=A[11]+A[8],I.d=A[15]+A[12],I.normalize()}static GetRightPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]-A[0],I.normal.y=A[7]-A[4],I.normal.z=A[11]-A[8],I.d=A[15]-A[12],I.normalize()}static GetTopPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]-A[1],I.normal.y=A[7]-A[5],I.normal.z=A[11]-A[9],I.d=A[15]-A[13],I.normalize()}static GetBottomPlaneToRef(V,I){const A=V.m;I.normal.x=A[3]+A[1],I.normal.y=A[7]+A[5],I.normal.z=A[11]+A[9],I.d=A[15]+A[13],I.normalize()}static GetPlanesToRef(V,I){F.GetNearPlaneToRef(V,I[0]),F.GetFarPlaneToRef(V,I[1]),F.GetLeftPlaneToRef(V,I[2]),F.GetRightPlaneToRef(V,I[3]),F.GetTopPlaneToRef(V,I[4]),F.GetBottomPlaneToRef(V,I[5])}static IsPointInFrustum(V,I){for(let A=0;A<6;A++)if(I[A].dotCoordinate(V)<0)return!1;return!0}}},11447:(V,I,A)=>{A.d(I,{d:()=>F});var B=A(11075);class F{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(V,I){F.Enabled&&(this._current+=V,I&&this._fetchResult())}beginMonitoring(){F.Enabled&&(this._startMonitoringTime=B.e.Now)}endMonitoring(){let V=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(!F.Enabled)return;V&&this.fetchNewFrame();const I=B.e.Now;this._current=I-this._startMonitoringTime,V&&this._fetchResult()}ZY(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const V=B.e.Now;V-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=V,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}F.Enabled=!0},11323:(V,I,A)=>{A.d(I,{b:()=>F,e:()=>B});class B{constructor(V){this.length=0,this.data=new Array(V),this._id=B._GlobalId++}push(V){this.data[this.length++]=V,this.length>this.data.length&&(this.data.length*=2)}forEach(V){for(let I=0;I<this.length;I++)V(this.data[I])}sort(V){this.data.sort(V)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(V){if(0!==V.length){this.length+V.length>this.data.length&&(this.data.length=2*(this.length+V.length));for(let I=0;I<V.length;I++)this.data[this.length++]=(V.data||V)[I]}}indexOf(V){const I=this.data.indexOf(V);return I>=this.length?-1:I}contains(V){return-1!==this.indexOf(V)}}B._GlobalId=0;class F extends B{constructor(){super(...arguments),this._duplicateId=0}push(V){super.push(V),V.__smartArrayFlags||(V.__smartArrayFlags={}),V.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(V){return(!V.__smartArrayFlags||V.__smartArrayFlags[this._id]!==this._duplicateId)&&(this.push(V),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(V){if(0!==V.length){this.length+V.length>this.data.length&&(this.data.length=2*(this.length+V.length));for(let I=0;I<V.length;I++){const A=(V.data||V)[I];this.pushNoDuplicate(A)}}}}},11292:(V,I,A)=>{A.d(I,{c:()=>E});var B=A(11300),F=A(11057);class E{constructor(V){this._vertexBuffers={},this.onBeforeRenderObservable=new F.c,this._scene=V}_prepareBuffers(){if(this._vertexBuffers[B.g.PositionKind])return;const V=[];V.push(1,1),V.push(-1,1),V.push(-1,-1),V.push(1,-1),this._vertexBuffers[B.g.PositionKind]=new B.g(this._scene.getEngine(),V,B.g.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const V=[];V.push(0),V.push(1),V.push(2),V.push(0),V.push(2),V.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(V)}_rebuild(){const V=this._vertexBuffers[B.g.PositionKind];V&&(V._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const A=this._scene.activeCamera;return!!A&&(I=I||A._postProcesses.filter((V=>null!=V)),!(!I||0===I.length||!this._scene.postProcessesEnabled)&&(I[0].activate(A,V,null!==I&&void 0!==I),!0))}directRender(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,A=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,E=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:V.length;const H=this._scene.getEngine();for(let b=0;b<Y;b++){var c;if(b<V.length-1)V[b+1].activate(this._scene.activeCamera||this._scene,null===I||void 0===I?void 0:I.texture);else I?H.bindFramebuffer(I,B,void 0,void 0,A,F):E||H.restoreDefaultFramebuffer(),null===(c=H._debugInsertMarker)||void 0===c||c.call(H,`post process ${V[b].name} output`);const Y=V[b],X=Y.apply();X&&(Y.onBeforeRenderObservable.notifyObservers(X),this._prepareBuffers(),H.bindBuffers(this._vertexBuffers,this._indexBuffer,X),H.drawElementsType(0,0,6),Y.onAfterRenderObservable.notifyObservers(X))}H.setDepthBuffer(!0),H.setDepthWrite(!0)}_finalizeFrame(V,I,A,B){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const E=this._scene.activeCamera;if(!E)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(B=B||E._postProcesses.filter((V=>null!=V))).length||!this._scene.postProcessesEnabled)return;const Y=this._scene.getEngine();for(let c=0,b=B.length;c<b;c++){const X=B[c];var H;if(c<b-1)X._outputTexture=B[c+1].activate(E,null===I||void 0===I?void 0:I.texture);else I?(Y.bindFramebuffer(I,A,void 0,void 0,F),X._outputTexture=I):(Y.restoreDefaultFramebuffer(),X._outputTexture=null),null===(H=Y._debugInsertMarker)||void 0===H||H.call(Y,`post process ${B[c].name} output`);if(V)break;const P=X.apply();P&&(X.onBeforeRenderObservable.notifyObservers(P),this._prepareBuffers(),Y.bindBuffers(this._vertexBuffers,this._indexBuffer,P),Y.drawElementsType(0,0,6),X.onAfterRenderObservable.notifyObservers(P))}Y.setDepthBuffer(!0),Y.setDepthWrite(!0),Y.setAlphaMode(0)}dispose(){const V=this._vertexBuffers[B.g.PositionKind];V&&(V.dispose(),this._vertexBuffers[B.g.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},11320:(V,I,A)=>{A.d(I,{c:()=>H});var B=A(11323),F=A(11231);class E{set opaqueSortCompareFn(V){this._opaqueSortCompareFn=V||E.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(V){this._alphaTestSortCompareFn=V||E.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(V){this._transparentSortCompareFn=V||E.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=V,this._opaqueSubMeshes=new B.e(256),this._transparentSubMeshes=new B.e(256),this._alphaTestSubMeshes=new B.e(256),this._depthOnlySubMeshes=new B.e(256),this._particleSystems=new B.e(256),this._spriteManagers=new B.e(256),this._empty=!0,this._edgesRenderers=new B.b(16),this._scene=I,this.opaqueSortCompareFn=A,this.alphaTestSortCompareFn=F,this.transparentSortCompareFn=E}render(V,I,A,B){if(V)return void V(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const F=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(F.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),F.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const E=F.getStencilBuffer();if(F.setStencilBuffer(!1),I&&this._renderSprites(),A&&this._renderParticles(B),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(F.setStencilBuffer(E),this._scene.useOrderIndependentTransparency){const V=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);V.length&&this._renderTransparent(V)}else this._renderTransparent(this._transparentSubMeshes);F.setAlphaMode(0)}if(F.setStencilBuffer(!1),this._edgesRenderers.length){for(let V=0;V<this._edgesRenderers.length;V++)this._edgesRenderers.data[V].render();F.setAlphaMode(0)}F.setStencilBuffer(E)}_renderOpaqueSorted(V){E._RenderSorted(V,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(V){E._RenderSorted(V,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(V){E._RenderSorted(V,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(V,I,A,B){let Y,H=0;const c=A?A.globalPosition:E._ZeroVector;if(B)for(;H<V.length;H++)Y=V.data[H],Y._alphaIndex=Y.getMesh().alphaIndex,Y._distanceToCamera=F.tI.Distance(Y.getBoundingInfo().boundingSphere.centerWorld,c);const b=V.length===V.data.length?V.data:V.data.slice(0,V.length);I&&b.sort(I);const X=b[0].getMesh().sV();for(H=0;H<b.length;H++)if(Y=b[H],!X._activeMeshesFrozenButKeepClipping||Y.isInFrustum(X._frustumPlanes)){if(B){const V=Y.lV();if(V&&V.needDepthPrePass){const I=V.sV().getEngine();I.setColorWrite(!1),I.setAlphaMode(0),Y.render(!1),I.setColorWrite(!0)}}Y.render(B)}}static defaultTransparentSortCompare(V,I){return V._alphaIndex>I._alphaIndex?1:V._alphaIndex<I._alphaIndex?-1:E.backToFrontSortCompare(V,I)}static backToFrontSortCompare(V,I){return V._distanceToCamera<I._distanceToCamera?1:V._distanceToCamera>I._distanceToCamera?-1:0}static frontToBackSortCompare(V,I){return V._distanceToCamera<I._distanceToCamera?-1:V._distanceToCamera>I._distanceToCamera?1:0}static PainterSortCompare(V,I){const A=V.getMesh(),B=I.getMesh();return A.material&&B.material?A.material.uniqueId-B.material.uniqueId:A.uniqueId-B.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(V,I,A){void 0===I&&(I=V.getMesh()),void 0===A&&(A=V.lV()),null!==A&&void 0!==A&&(A.needAlphaBlendingForMesh(I)?this._transparentSubMeshes.push(V):A.needAlphaTestingForMesh(I)?(A.needDepthPrePass&&this._depthOnlySubMeshes.push(V),this._alphaTestSubMeshes.push(V)):(A.needDepthPrePass&&this._depthOnlySubMeshes.push(V),this._opaqueSubMeshes.push(V)),I._renderingGroup=this,I._edgesRenderer&&I.isEnabled()&&I.isVisible&&I._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(I._edgesRenderer),this._empty=!1)}dispatchSprites(V){this._spriteManagers.push(V),this._empty=!1}dispatchParticles(V){this._particleSystems.push(V),this._empty=!1}_renderParticles(V){if(0===this._particleSystems.length)return;const I=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let A=0;A<this._particleSystems.length;A++){const B=this._particleSystems.data[A];if(0===(I&&I.layerMask&B.layerMask))continue;const F=B.BI;F.position&&V&&-1===V.indexOf(F)||this._scene._activeParticles.addCount(B.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const V=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let I=0;I<this._spriteManagers.length;I++){const A=this._spriteManagers.data[I];0!==(V&&V.layerMask&A.layerMask)&&A.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}E._ZeroVector=F.tI.Zero();class Y{}class H{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(V){V!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=V,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const V of this._scene.meshes)if(V.IH)for(const I of V.IH)I._wasDispatched=!1;if(this._scene.spriteManagers)for(const V of this._scene.spriteManagers)V._wasDispatched=!1;for(const V of this._scene.XG)V._wasDispatched=!1}constructor(V){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new Y,this._maintainStateBetweenFrames=!1,this._scene=V;for(let I=H.MIN_RENDERINGGROUPS;I<H.MAX_RENDERINGGROUPS;I++)this._autoClearDepthStencil[I]={VH:!0,depth:!0,stencil:!0}}getRenderingGroup(V){const I=V||0;return this._prepareRenderingGroup(I),this._renderingGroups[I]}_clearDepthStencilBuffer(){let V=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,V,I),this._depthStencilBufferAlreadyCleaned=!0)}render(V,I,A,B){const F=this._renderingGroupInfo;if(F.WI=this._scene,F.camera=this._scene.activeCamera,F.renderingManager=this,this._scene.spriteManagers&&B)for(let E=0;E<this._scene.spriteManagers.length;E++){const V=this._scene.spriteManagers[E];this.dispatchSprites(V)}for(let E=H.MIN_RENDERINGGROUPS;E<H.MAX_RENDERINGGROUPS;E++){this._depthStencilBufferAlreadyCleaned=E===H.MIN_RENDERINGGROUPS;const Y=this._renderingGroups[E];if(!Y||Y._empty)continue;const c=1<<E;if(F.renderingGroupId=E,this._scene.onBeforeRenderingGroupObservable.notifyObservers(F,c),H.AUTOCLEAR){const V=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(E):this._autoClearDepthStencil[E];V&&V.VH&&this._clearDepthStencilBuffer(V.depth,V.stencil)}for(const V of this._scene._beforeRenderingGroupDrawStage)V.action(E);Y.render(V,B,A,I);for(const V of this._scene._afterRenderingGroupDrawStage)V.action(E);this._scene.onAfterRenderingGroupObservable.notifyObservers(F,c)}}reset(){if(!this.maintainStateBetweenFrames)for(let V=H.MIN_RENDERINGGROUPS;V<H.MAX_RENDERINGGROUPS;V++){const I=this._renderingGroups[V];I&&I.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let V=H.MIN_RENDERINGGROUPS;V<H.MAX_RENDERINGGROUPS;V++){const I=this._renderingGroups[V];I&&I.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let V=H.MIN_RENDERINGGROUPS;V<H.MAX_RENDERINGGROUPS;V++){const I=this._renderingGroups[V];I&&I.dispose()}}_prepareRenderingGroup(V){void 0===this._renderingGroups[V]&&(this._renderingGroups[V]=new E(V,this._scene,this._customOpaqueSortCompareFn[V],this._customAlphaTestSortCompareFn[V],this._customTransparentSortCompareFn[V]))}dispatchSprites(V){this.maintainStateBetweenFrames&&V._wasDispatched||(V._wasDispatched=!0,this.getRenderingGroup(V.renderingGroupId).dispatchSprites(V))}dispatchParticles(V){this.maintainStateBetweenFrames&&V._wasDispatched||(V._wasDispatched=!0,this.getRenderingGroup(V.renderingGroupId).dispatchParticles(V))}dispatch(V,I,A){void 0===I&&(I=V.getMesh()),this.maintainStateBetweenFrames&&V._wasDispatched||(V._wasDispatched=!0,this.getRenderingGroup(I.renderingGroupId).dispatch(V,I,A))}setRenderingOrder(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[V]=I,this._customAlphaTestSortCompareFn[V]=A,this._customTransparentSortCompareFn[V]=B,this._renderingGroups[V]){const I=this._renderingGroups[V];I.opaqueSortCompareFn=this._customOpaqueSortCompareFn[V],I.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[V],I.transparentSortCompareFn=this._customTransparentSortCompareFn[V]}}setRenderingAutoClearDepthStencil(V,I){let A=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],B=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[V]={VH:I,depth:A,stencil:B}}getAutoClearDepthStencilSetup(V){return this._autoClearDepthStencil[V]}}H.MAX_RENDERINGGROUPS=4,H.MIN_RENDERINGGROUPS=0,H.AUTOCLEAR=!0}}]);