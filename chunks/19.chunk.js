"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[19],{11706:(F,P,f)=>{f.d(P,{e:()=>H,f:()=>A});var c=f(11710),N=f(11474),q=f(11713);class H{get u(){return this._isDisposed}constructor(F,P,f){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,q=arguments.length>4&&void 0!==arguments[4]&&arguments[4],H=arguments.length>5&&void 0!==arguments[5]&&arguments[5],A=arguments.length>6&&void 0!==arguments[6]&&arguments[6],o=arguments.length>7?arguments[7]:void 0,j=arguments.length>8?arguments[8]:void 0;this._isAlreadyOwned=!1,this._isDisposed=!1,F&&F.OF?this._engine=F.OF().getEngine():this._engine=F,this._updatable=f,this._instanced=H,this._divisor=o||1,this._label=j,P instanceof c.e?(this._data=null,this._buffer=P):(this._data=P,this._buffer=null),this.byteStride=A?N:N*Float32Array.BYTES_PER_ELEMENT,q||this.create()}createVertexBuffer(F,P,f,c,N){let q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],H=arguments.length>6?arguments[6]:void 0;const o=q?P:P*Float32Array.BYTES_PER_ELEMENT,j=c?q?c:c*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new A(this._engine,this,F,this._updatable,!0,j,void 0===N?this._instanced:N,o,f,void 0,void 0,!0,this._divisor||H)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;!F&&this._buffer||(F=F||this._data,F&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,F),this._data=F):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(F,this._label),this._data=F):this._buffer=this._engine.createVertexBuffer(F,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.pP>0)return void(this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.pP,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.pP,void 0,this._label));N.d.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(F){this.create(F)}updateDirectly(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,F,c?P:P*Float32Array.BYTES_PER_ELEMENT,f?f*this.byteStride:void 0),this._data=0===P&&void 0===f?F:null)}_increaseReferences(){this._buffer&&(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class A{get u(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(F){const P=0!=F;this._instanceDivisor=F,P!==this._instanced&&(this._instanced=P,this._computeHashCode())}get _maxVerticesCount(){const F=this.getData();return F?Array.isArray(F)?F.length/(this.byteStride/4)-this.byteOffset/4:(F.byteLength-this.byteOffset)/this.byteStride:0}constructor(F,P,f,c,N,o,j,i,u,T){let Y=arguments.length>10&&void 0!==arguments[10]&&arguments[10],t=arguments.length>11&&void 0!==arguments[11]&&arguments[11],C=arguments.length>12&&void 0!==arguments[12]?arguments[12]:1,L=arguments.length>13&&void 0!==arguments[13]&&arguments[13];this._isDisposed=!1;let J=!1;if(this.YP=F,"object"===typeof c&&null!==c?(J=c.updatable??!1,N=c.postponeInternalCreation,o=c.stride,j=c.instanced,i=c.offset,u=c.size,T=c.type,Y=c.normalized??!1,t=c.useBytes??!1,C=c.divisor??1,L=c.takeBufferOwnership??!1,this._label=c.label):J=!!c,P instanceof H?(this._buffer=P,this._ownsBuffer=L):(this._buffer=new H(F,P,J,o,N,j,t,C,this._label),this._ownsBuffer=!0),this.uniqueId=A._Counter++,this._kind=f,void 0===T){const F=this.getData();this.type=F?A.GetDataType(F):A.FLOAT}else this.type=T;const B=(0,q.r)(this.type);t?(this._size=u||(o?o/B:A.DeduceStride(f)),this.byteStride=o||this._buffer.byteStride||this._size*B,this.byteOffset=i||0):(this._size=u||o||A.DeduceStride(f),this.byteStride=o?o*B:this._buffer.byteStride||this._size*B,this.byteOffset=(i||0)*B),this.normalized=Y,this._instanced=void 0!==j&&j,this._instanceDivisor=j?C:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120|0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){var F;null===(F=this._buffer)||void 0===F||F._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(F,P){const f=this.getData();return f?(0,q.n)(f,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,F,P):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/(0,q.r)(this.type)}getOffset(){return this.byteOffset/(0,q.r)(this.type)}getSize(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this._size*(0,q.r)(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(F){this._buffer.create(F),this._alignBuffer()}update(F){this._buffer.update(F),this._alignBuffer()}updateDirectly(F,P){let f=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._buffer.updateDirectly(F,P,void 0,f),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(F,P){(0,q.j)(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,F,this.normalized,((F,f)=>{for(let c=0;c<this._size;c++)P(F[c],f+c)}))}_alignBuffer(){}static DeduceStride(F){switch(F){case A.UVKind:case A.UV2Kind:case A.UV3Kind:case A.UV4Kind:case A.UV5Kind:case A.UV6Kind:return 2;case A.NormalKind:case A.PositionKind:return 3;case A.ColorKind:case A.ColorInstanceKind:case A.MatricesIndicesKind:case A.MatricesIndicesExtraKind:case A.MatricesWeightsKind:case A.MatricesWeightsExtraKind:case A.TangentKind:return 4;default:throw new Error("Invalid kind '"+F+"'")}}static GetDataType(F){return F instanceof Int8Array?A.BYTE:F instanceof Uint8Array?A.UNSIGNED_BYTE:F instanceof Int16Array?A.SHORT:F instanceof Uint16Array?A.UNSIGNED_SHORT:F instanceof Int32Array?A.INT:F instanceof Uint32Array?A.UNSIGNED_INT:A.FLOAT}static GetTypeByteLength(F){return(0,q.r)(F)}static ForEach(F,P,f,c,N,H,A,o){(0,q.j)(F,P,f,c,N,H,A,((F,P)=>{for(let f=0;f<c;f++)o(F[f],P+f)}))}static GetFloatData(F,P,f,c,N,H,A,o){return(0,q.n)(F,P,f,c,N,H,A,o)}}A._Counter=0,A.BYTE=5120,A.UNSIGNED_BYTE=5121,A.SHORT=5122,A.UNSIGNED_SHORT=5123,A.INT=5124,A.UNSIGNED_INT=5125,A.FLOAT=5126,A.PositionKind="position",A.NormalKind="normal",A.TangentKind="tangent",A.UVKind="uv",A.UV2Kind="uv2",A.UV3Kind="uv3",A.UV4Kind="uv4",A.UV5Kind="uv5",A.UV6Kind="uv6",A.ColorKind="color",A.ColorInstanceKind="instanceColor",A.MatricesIndicesKind="matricesIndices",A.MatricesWeightsKind="matricesWeights",A.MatricesIndicesExtraKind="matricesIndicesExtra",A.MatricesWeightsExtraKind="matricesWeightsExtra"},11713:(F,P,f)=>{f.d(P,{d:()=>T,f:()=>u,j:()=>o,n:()=>j,r:()=>H,u:()=>A,x:()=>i});var c=f(11474);function N(F,P,f,c){switch(P){case 5120:{let P=F.getInt8(f);return c&&(P=Math.max(P/127,-1)),P}case 5121:{let P=F.getUint8(f);return c&&(P/=255),P}case 5122:{let P=F.getInt16(f,!0);return c&&(P=Math.max(P/32767,-1)),P}case 5123:{let P=F.getUint16(f,!0);return c&&(P/=65535),P}case 5124:return F.getInt32(f,!0);case 5125:return F.getUint32(f,!0);case 5126:return F.getFloat32(f,!0);default:throw new Error(`Invalid component type ${P}`)}}function q(F,P,f,c,N){switch(P){case 5120:c&&(N=Math.round(127*N)),F.setInt8(f,N);break;case 5121:c&&(N=Math.round(255*N)),F.setUint8(f,N);break;case 5122:c&&(N=Math.round(32767*N)),F.setInt16(f,N,!0);break;case 5123:c&&(N=Math.round(65535*N)),F.setUint16(f,N,!0);break;case 5124:F.setInt32(f,N,!0);break;case 5125:F.setUint32(f,N,!0);break;case 5126:F.setFloat32(f,N,!0);break;default:throw new Error(`Invalid component type ${P}`)}}function H(F){switch(F){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${F}'`)}}function A(F){switch(F){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Invalid component type '${F}'`)}}function o(F,P,f,c,A,o,j,i){const u=new Array(c),T=new Array(c);if(F instanceof Array){let N=P/4;const q=f/4;for(let P=0;P<o;P+=c){for(let P=0;P<c;P++)u[P]=T[P]=F[N+P];i(T,P);for(let P=0;P<c;P++)u[P]!==T[P]&&(F[N+P]=T[P]);N+=q}}else{const Y=ArrayBuffer.isView(F)?new DataView(F.buffer,F.byteOffset,F.byteLength):new DataView(F),t=H(A);for(let F=0;F<o;F+=c){for(let F=0,f=P;F<c;F++,f+=t)u[F]=T[F]=N(Y,A,f,j);i(T,F);for(let F=0,f=P;F<c;F++,f+=t)u[F]!==T[F]&&q(Y,A,f,j,T[F]);P+=f}}}function j(F,P,f,N,q,A,j,i){const u=P*H(f),T=j*P;if(5126!==f||q!==u){const c=new Float32Array(T);return o(F,N,q,P,f,T,A,((F,f)=>{for(let N=0;N<P;N++)c[f+N]=F[N]})),c}if(!(F instanceof Array||F instanceof Float32Array)||0!==N||F.length!==T){if(F instanceof Array){const P=N/4;return F.slice(P,P+T)}if(F instanceof ArrayBuffer)return new Float32Array(F,N,T);{const P=F.byteOffset+N;return 0!==(3&P)&&(c.d.Warn("Float array must be aligned to 4-bytes border"),i=!0),i?new Float32Array(F.buffer.slice(P,P+T*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(F.buffer,P,T)}}return i?F.slice():F}function i(F,P,f,N,q,j,i,u){const T=H(f),Y=A(f),t=i*P;if(Array.isArray(F)){if(0!==(3&N)||0!==(3&q))throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");const c=N/4,H=q/4;if(c+(i-1)*H+P>F.length)throw new Error("Last accessed index is out of bounds.");if(H<P)throw new Error("Data stride cannot be smaller than the component size.");if(H!==P){const c=new Y(t);return o(F,N,q,P,f,t,j,((F,f)=>{for(let N=0;N<P;N++)c[f+N]=F[N]})),c}return new Y(F.slice(c,c+t))}let C,L=N;F instanceof ArrayBuffer?C=F:(C=F.buffer,L+=F.byteOffset);if(L+(i-1)*q+P*T>C.byteLength)throw new Error("Last accessed byte is out of bounds.");const J=P*T;if(q<J)throw new Error("Byte stride cannot be smaller than the component's byte size.");if(q!==J){const F=new Y(t);return o(C,L,q,P,f,t,j,((f,c)=>{for(let N=0;N<P;N++)F[c+N]=f[N]})),F}return 1!==T&&0!==(L&T-1)&&(c.d.Warn("Array must be aligned to border of element size. Data will be copied."),u=!0),u?new Y(C.slice(L,L+t*T)):new Y(C,L,t)}function u(F,P,f,N,q,A,j,i){const u=P*H(f),T=j*P;if(i.length!==T)throw new Error("Output length is not valid");if(5126===f&&q===u)if(F instanceof Array){const P=N/4;i.set(F,P)}else if(F instanceof ArrayBuffer){const P=new Float32Array(F,N,T);i.set(P)}else{const P=F.byteOffset+N;if(0!==(3&P))return c.d.Warn("Float array must be aligned to 4-bytes border"),void i.set(new Float32Array(F.buffer.slice(P,P+T*Float32Array.BYTES_PER_ELEMENT)));const f=new Float32Array(F.buffer,P,T);i.set(f)}else o(F,N,q,P,f,T,A,((F,f)=>{for(let c=0;c<P;c++)i[f+c]=F[c]}))}function T(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(Array.isArray(F)){for(let N=0;N<P;N++)if(F[f+N]-c>65535)return!0;return!1}return 4===F.BYTES_PER_ELEMENT}},11710:(F,P,f)=>{f.d(P,{e:()=>c});class c{get underlyingResource(){return null}constructor(){this.references=0,this.pP=0,this.is32Bits=!1,this.uniqueId=c._Counter++}}c._Counter=0},11739:(F,P,f)=>{f.d(P,{d:()=>N});var c=f(11538);class N{static GetEffect(F){return void 0===F.getPipelineContext?F.effect:F}constructor(F){let P=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=F.createDrawContext(),P&&(this.materialContext=F.createMaterialContext())}setEffect(F,P){let f=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];var c;(this.effect=F,void 0!==P&&(this.defines=P),f)&&(null===(c=this.drawContext)||void 0===c||c.reset())}dispose(){var F;let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.effect){const F=this.effect;P?F.dispose():c.c.SetImmediate((()=>{F.getEngine().onEndFrameObservable.addOnce((()=>{F.dispose()}))})),this.effect=null}null===(F=this.drawContext)||void 0===F||F.dispose()}}},11820:(F,P,f)=>{f.d(P,{d:()=>N});var c=f(11697);class N{static GetPlanes(F){const P=[];for(let f=0;f<6;f++)P.push(new c.e(0,0,0,0));return N.GetPlanesToRef(F,P),P}static GetNearPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]+f[2],P.normal.y=f[7]+f[6],P.normal.z=f[11]+f[10],P.d=f[15]+f[14],P.normalize()}static GetFarPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]-f[2],P.normal.y=f[7]-f[6],P.normal.z=f[11]-f[10],P.d=f[15]-f[14],P.normalize()}static GetLeftPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]+f[0],P.normal.y=f[7]+f[4],P.normal.z=f[11]+f[8],P.d=f[15]+f[12],P.normalize()}static GetRightPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]-f[0],P.normal.y=f[7]-f[4],P.normal.z=f[11]-f[8],P.d=f[15]-f[12],P.normalize()}static GetTopPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]-f[1],P.normal.y=f[7]-f[5],P.normal.z=f[11]-f[9],P.d=f[15]-f[13],P.normalize()}static GetBottomPlaneToRef(F,P){const f=F.m;P.normal.x=f[3]+f[1],P.normal.y=f[7]+f[5],P.normal.z=f[11]+f[9],P.d=f[15]+f[13],P.normalize()}static GetPlanesToRef(F,P){N.GetNearPlaneToRef(F,P[0]),N.GetFarPlaneToRef(F,P[1]),N.GetLeftPlaneToRef(F,P[2]),N.GetRightPlaneToRef(F,P[3]),N.GetTopPlaneToRef(F,P[4]),N.GetBottomPlaneToRef(F,P[5])}static IsPointInFrustum(F,P){for(let f=0;f<6;f++)if(P[f].dotCoordinate(F)<0)return!1;return!0}}},11833:(F,P,f)=>{f.d(P,{b:()=>N});var c=f(11480);class N{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(F,P){N.Enabled&&(this._current+=F,P&&this._fetchResult())}beginMonitoring(){N.Enabled&&(this._startMonitoringTime=c.d.Now)}endMonitoring(){let F=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(!N.Enabled)return;F&&this.fetchNewFrame();const P=c.d.Now;this._current=P-this._startMonitoringTime,F&&this._fetchResult()}Yf(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const F=c.d.Now;F-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=F,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}N.Enabled=!0},11723:(F,P,f)=>{f.d(P,{c:()=>N,d:()=>c});class c{constructor(F){this.length=0,this.data=new Array(F),this._id=c._GlobalId++}push(F){this.data[this.length++]=F,this.length>this.data.length&&(this.data.length*=2)}forEach(F){for(let P=0;P<this.length;P++)F(this.data[P])}sort(F){this.data.sort(F)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(F){if(0!==F.length){this.length+F.length>this.data.length&&(this.data.length=2*(this.length+F.length));for(let P=0;P<F.length;P++)this.data[this.length++]=(F.data||F)[P]}}indexOf(F){const P=this.data.indexOf(F);return P>=this.length?-1:P}contains(F){return-1!==this.indexOf(F)}}c._GlobalId=0;class N extends c{constructor(){super(...arguments),this._duplicateId=0}push(F){super.push(F),F.__smartArrayFlags||(F.__smartArrayFlags={}),F.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(F){return(!F.__smartArrayFlags||F.__smartArrayFlags[this._id]!==this._duplicateId)&&(this.push(F),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(F){if(0!==F.length){this.length+F.length>this.data.length&&(this.data.length=2*(this.length+F.length));for(let P=0;P<F.length;P++){const f=(F.data||F)[P];this.pushNoDuplicate(f)}}}}},11704:(F,P,f)=>{f.d(P,{e:()=>q});var c=f(11706),N=f(11464);class q{constructor(F){this._vertexBuffers={},this.onBeforeRenderObservable=new N.d,this._scene=F}_prepareBuffers(){if(this._vertexBuffers[c.f.PositionKind])return;const F=[];F.push(1,1),F.push(-1,1),F.push(-1,-1),F.push(1,-1),this._vertexBuffers[c.f.PositionKind]=new c.f(this._scene.getEngine(),F,c.f.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const F=[];F.push(0),F.push(1),F.push(2),F.push(0),F.push(2),F.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(F)}_rebuild(){const F=this._vertexBuffers[c.f.PositionKind];F&&(F._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const f=this._scene.activeCamera;return!!f&&(P=P||f._postProcesses.filter((F=>null!=F)),!(!P||0===P.length||!this._scene.postProcessesEnabled)&&(P[0].activate(f,F,null!==P&&void 0!==P),!0))}directRender(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,f=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],H=arguments.length>6&&void 0!==arguments[6]?arguments[6]:F.length;const A=this._scene.getEngine();for(let j=0;j<H;j++){var o;if(j<F.length-1)F[j+1].activate(this._scene.activeCamera||this._scene,null===P||void 0===P?void 0:P.texture);else P?A.bindFramebuffer(P,c,void 0,void 0,f,N):q||A.restoreDefaultFramebuffer(),null===(o=A._debugInsertMarker)||void 0===o||o.call(A,`post process ${F[j].name} output`);const H=F[j],i=H.apply();i&&(H.onBeforeRenderObservable.notifyObservers(i),this._prepareBuffers(),A.bindBuffers(this._vertexBuffers,this._indexBuffer,i),A.drawElementsType(0,0,6),H.onAfterRenderObservable.notifyObservers(i))}A.setDepthBuffer(!0),A.setDepthWrite(!0)}_finalizeFrame(F,P,f,c){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const q=this._scene.activeCamera;if(!q)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(c=c||q._postProcesses.filter((F=>null!=F))).length||!this._scene.postProcessesEnabled)return;const H=this._scene.getEngine();for(let o=0,j=c.length;o<j;o++){const i=c[o];var A;if(o<j-1)i._outputTexture=c[o+1].activate(q,null===P||void 0===P?void 0:P.texture);else P?(H.bindFramebuffer(P,f,void 0,void 0,N),i._outputTexture=P):(H.restoreDefaultFramebuffer(),i._outputTexture=null),null===(A=H._debugInsertMarker)||void 0===A||A.call(H,`post process ${c[o].name} output`);if(F)break;const u=i.apply();u&&(i.onBeforeRenderObservable.notifyObservers(u),this._prepareBuffers(),H.bindBuffers(this._vertexBuffers,this._indexBuffer,u),H.drawElementsType(0,0,6),i.onAfterRenderObservable.notifyObservers(u))}H.setDepthBuffer(!0),H.setDepthWrite(!0),H.setAlphaMode(0)}dispose(){const F=this._vertexBuffers[c.f.PositionKind];F&&(F.dispose(),this._vertexBuffers[c.f.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},11718:(F,P,f)=>{f.d(P,{d:()=>A});var c=f(11723),N=f(11639);class q{set opaqueSortCompareFn(F){this._opaqueSortCompareFn=F||q.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(F){this._alphaTestSortCompareFn=F||q.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(F){this._transparentSortCompareFn=F||q.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=F,this._opaqueSubMeshes=new c.d(256),this._transparentSubMeshes=new c.d(256),this._alphaTestSubMeshes=new c.d(256),this._depthOnlySubMeshes=new c.d(256),this._particleSystems=new c.d(256),this._spriteManagers=new c.d(256),this._empty=!0,this._edgesRenderers=new c.c(16),this._scene=P,this.opaqueSortCompareFn=f,this.alphaTestSortCompareFn=N,this.transparentSortCompareFn=q}render(F,P,f,c){if(F)return void F(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const N=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(N.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),N.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const q=N.getStencilBuffer();if(N.setStencilBuffer(!1),P&&this._renderSprites(),f&&this._renderParticles(c),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(N.setStencilBuffer(q),this._scene.useOrderIndependentTransparency){const F=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);F.length&&this._renderTransparent(F)}else this._renderTransparent(this._transparentSubMeshes);N.setAlphaMode(0)}if(N.setStencilBuffer(!1),this._edgesRenderers.length){for(let F=0;F<this._edgesRenderers.length;F++)this._edgesRenderers.data[F].render();N.setAlphaMode(0)}N.setStencilBuffer(q)}_renderOpaqueSorted(F){q._RenderSorted(F,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(F){q._RenderSorted(F,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(F){q._RenderSorted(F,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(F,P,f,c){let H,A=0;const o=f?f.globalPosition:q._ZeroVector;if(c)for(;A<F.length;A++)H=F.data[A],H._alphaIndex=H.getMesh().alphaIndex,H._distanceToCamera=N.tP.Distance(H.getBoundingInfo().boundingSphere.centerWorld,o);const j=F.length===F.data.length?F.data:F.data.slice(0,F.length);P&&j.sort(P);const i=j[0].getMesh().OF();for(A=0;A<j.length;A++)if(H=j[A],!i._activeMeshesFrozenButKeepClipping||H.isInFrustum(i._frustumPlanes)){if(c){const F=H.pF();if(F&&F.needDepthPrePass){const P=F.OF().getEngine();P.setColorWrite(!1),P.setAlphaMode(0),H.render(!1),P.setColorWrite(!0)}}H.render(c)}}static defaultTransparentSortCompare(F,P){return F._alphaIndex>P._alphaIndex?1:F._alphaIndex<P._alphaIndex?-1:q.backToFrontSortCompare(F,P)}static backToFrontSortCompare(F,P){return F._distanceToCamera<P._distanceToCamera?1:F._distanceToCamera>P._distanceToCamera?-1:0}static frontToBackSortCompare(F,P){return F._distanceToCamera<P._distanceToCamera?-1:F._distanceToCamera>P._distanceToCamera?1:0}static PainterSortCompare(F,P){const f=F.getMesh(),c=P.getMesh();return f.material&&c.material?f.material.uniqueId-c.material.uniqueId:f.uniqueId-c.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(F,P,f){void 0===P&&(P=F.getMesh()),void 0===f&&(f=F.pF()),null!==f&&void 0!==f&&(f.needAlphaBlendingForMesh(P)?this._transparentSubMeshes.push(F):f.needAlphaTestingForMesh(P)?(f.needDepthPrePass&&this._depthOnlySubMeshes.push(F),this._alphaTestSubMeshes.push(F)):(f.needDepthPrePass&&this._depthOnlySubMeshes.push(F),this._opaqueSubMeshes.push(F)),P._renderingGroup=this,P._edgesRenderer&&P.isEnabled()&&P.isVisible&&P._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(P._edgesRenderer),this._empty=!1)}dispatchSprites(F){this._spriteManagers.push(F),this._empty=!1}dispatchParticles(F){this._particleSystems.push(F),this._empty=!1}_renderParticles(F){if(0===this._particleSystems.length)return;const P=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let f=0;f<this._particleSystems.length;f++){const c=this._particleSystems.data[f];if(0===(P&&P.layerMask&c.layerMask))continue;const N=c.cP;N.position&&F&&-1===F.indexOf(N)||this._scene._activeParticles.addCount(c.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const F=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let P=0;P<this._spriteManagers.length;P++){const f=this._spriteManagers.data[P];0!==(F&&F.layerMask&f.layerMask)&&f.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}q._ZeroVector=N.tP.Zero();class H{}class A{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(F){F!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=F,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const F of this._scene.meshes)if(F.nf)for(const P of F.nf)P._wasDispatched=!1;if(this._scene.spriteManagers)for(const F of this._scene.spriteManagers)F._wasDispatched=!1;for(const F of this._scene.zT)F._wasDispatched=!1}constructor(F){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new H,this._maintainStateBetweenFrames=!1,this._scene=F;for(let P=A.MIN_RENDERINGGROUPS;P<A.MAX_RENDERINGGROUPS;P++)this._autoClearDepthStencil[P]={Ef:!0,depth:!0,stencil:!0}}getRenderingGroup(F){const P=F||0;return this._prepareRenderingGroup(P),this._renderingGroups[P]}_clearDepthStencilBuffer(){let F=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],P=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,F,P),this._depthStencilBufferAlreadyCleaned=!0)}render(F,P,f,c){const N=this._renderingGroupInfo;if(N.LP=this._scene,N.camera=this._scene.activeCamera,N.renderingManager=this,this._scene.spriteManagers&&c)for(let q=0;q<this._scene.spriteManagers.length;q++){const F=this._scene.spriteManagers[q];this.dispatchSprites(F)}for(let q=A.MIN_RENDERINGGROUPS;q<A.MAX_RENDERINGGROUPS;q++){this._depthStencilBufferAlreadyCleaned=q===A.MIN_RENDERINGGROUPS;const H=this._renderingGroups[q];if(!H||H._empty)continue;const o=1<<q;if(N.renderingGroupId=q,this._scene.onBeforeRenderingGroupObservable.notifyObservers(N,o),A.AUTOCLEAR){const F=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(q):this._autoClearDepthStencil[q];F&&F.Ef&&this._clearDepthStencilBuffer(F.depth,F.stencil)}for(const F of this._scene._beforeRenderingGroupDrawStage)F.action(q);H.render(F,c,f,P);for(const F of this._scene._afterRenderingGroupDrawStage)F.action(q);this._scene.onAfterRenderingGroupObservable.notifyObservers(N,o)}}reset(){if(!this.maintainStateBetweenFrames)for(let F=A.MIN_RENDERINGGROUPS;F<A.MAX_RENDERINGGROUPS;F++){const P=this._renderingGroups[F];P&&P.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let F=A.MIN_RENDERINGGROUPS;F<A.MAX_RENDERINGGROUPS;F++){const P=this._renderingGroups[F];P&&P.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let F=A.MIN_RENDERINGGROUPS;F<A.MAX_RENDERINGGROUPS;F++){const P=this._renderingGroups[F];P&&P.dispose()}}_prepareRenderingGroup(F){void 0===this._renderingGroups[F]&&(this._renderingGroups[F]=new q(F,this._scene,this._customOpaqueSortCompareFn[F],this._customAlphaTestSortCompareFn[F],this._customTransparentSortCompareFn[F]))}dispatchSprites(F){this.maintainStateBetweenFrames&&F._wasDispatched||(F._wasDispatched=!0,this.getRenderingGroup(F.renderingGroupId).dispatchSprites(F))}dispatchParticles(F){this.maintainStateBetweenFrames&&F._wasDispatched||(F._wasDispatched=!0,this.getRenderingGroup(F.renderingGroupId).dispatchParticles(F))}dispatch(F,P,f){void 0===P&&(P=F.getMesh()),this.maintainStateBetweenFrames&&F._wasDispatched||(F._wasDispatched=!0,this.getRenderingGroup(P.renderingGroupId).dispatch(F,P,f))}setRenderingOrder(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[F]=P,this._customAlphaTestSortCompareFn[F]=f,this._customTransparentSortCompareFn[F]=c,this._renderingGroups[F]){const P=this._renderingGroups[F];P.opaqueSortCompareFn=this._customOpaqueSortCompareFn[F],P.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[F],P.transparentSortCompareFn=this._customTransparentSortCompareFn[F]}}setRenderingAutoClearDepthStencil(F,P){let f=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],c=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[F]={Ef:P,depth:f,stencil:c}}getAutoClearDepthStencilSetup(F){return this._autoClearDepthStencil[F]}}A.MAX_RENDERINGGROUPS=4,A.MIN_RENDERINGGROUPS=0,A.AUTOCLEAR=!0}}]);