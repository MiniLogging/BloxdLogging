"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[19],{13048:(I,x,L)=>{L.d(x,{e:()=>Y,g:()=>p});var F=L(13056),X=L(12809),G=L(13061);class Y{get p(){return this._isDisposed}constructor(I,x,L){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,G=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],p=arguments.length>6&&void 0!==arguments[6]&&arguments[6],B=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0;this._isAlreadyOwned=!1,this._isDisposed=!1,I&&I.tI?this._engine=I.tI().getEngine():this._engine=I,this._updatable=L,this._instanced=Y,this._divisor=B||1,this._label=l,x instanceof F.b?(this._data=null,this._buffer=x):(this._data=x,this._buffer=null),this.byteStride=p?X:X*Float32Array.BYTES_PER_ELEMENT,G||this.create()}createVertexBuffer(I,x,L,F,X){let G=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6?arguments[6]:void 0;const B=G?x:x*Float32Array.BYTES_PER_ELEMENT,l=F?G?F:F*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new p(this._engine,this,I,this._updatable,!0,l,void 0===X?this._instanced:X,B,L,void 0,void 0,!0,this._divisor||Y)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;!I&&this._buffer||(I=I||this._data,I&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,I),this._data=I):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(I,this._label),this._data=I):this._buffer=this._engine.createVertexBuffer(I,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.tL>0)return void(this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.tL,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.tL,void 0,this._label));X.c.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(I){this.create(I)}updateDirectly(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,I,F?x:x*Float32Array.BYTES_PER_ELEMENT,L?L*this.byteStride:void 0),this._data=0===x&&void 0===L?I:null)}_increaseReferences(){this._buffer&&(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class p{get p(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(I){const x=0!=I;this._instanceDivisor=I,x!==this._instanced&&(this._instanced=x,this._computeHashCode())}get _maxVerticesCount(){const I=this.getData();return I?Array.isArray(I)?I.length/(this.byteStride/4)-this.byteOffset/4:(I.byteLength-this.byteOffset)/this.byteStride:0}constructor(I,x,L,F,X,B,l,W,Q,e){let g=arguments.length>10&&void 0!==arguments[10]&&arguments[10],v=arguments.length>11&&void 0!==arguments[11]&&arguments[11],z=arguments.length>12&&void 0!==arguments[12]?arguments[12]:1,H=arguments.length>13&&void 0!==arguments[13]&&arguments[13];this._isDisposed=!1;let s=!1;if(this.Hx=I,"object"===typeof F&&null!==F?(s=F.updatable??!1,X=F.postponeInternalCreation,B=F.stride,l=F.instanced,W=F.offset,Q=F.size,e=F.type,g=F.normalized??!1,v=F.useBytes??!1,z=F.divisor??1,H=F.takeBufferOwnership??!1,this._label=F.label):s=!!F,x instanceof Y?(this._buffer=x,this._ownsBuffer=H):(this._buffer=new Y(I,x,s,B,X,l,v,z,this._label),this._ownsBuffer=!0),this.uniqueId=p._Counter++,this._kind=L,void 0===e){const I=this.getData();this.type=I?p.GetDataType(I):p.FLOAT}else this.type=e;const U=(0,G.l)(this.type);v?(this._size=Q||(B?B/U:p.DeduceStride(L)),this.byteStride=B||this._buffer.byteStride||this._size*U,this.byteOffset=W||0):(this._size=Q||B||p.DeduceStride(L),this.byteStride=B?B*U:this._buffer.byteStride||this._size*U,this.byteOffset=(W||0)*U),this.normalized=g,this._instanced=void 0!==l&&l,this._instanceDivisor=l?z:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120|0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){var I;null===(I=this._buffer)||void 0===I||I._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(I,x){const L=this.getData();return L?(0,G.i)(L,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,I,x):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/(0,G.l)(this.type)}getOffset(){return this.byteOffset/(0,G.l)(this.type)}getSize(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this._size*(0,G.l)(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(I){this._buffer.create(I),this._alignBuffer()}update(I){this._buffer.update(I),this._alignBuffer()}updateDirectly(I,x){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._buffer.updateDirectly(I,x,void 0,L),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(I,x){(0,G.h)(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,I,this.normalized,((I,L)=>{for(let F=0;F<this._size;F++)x(I[F],L+F)}))}_alignBuffer(){}static DeduceStride(I){switch(I){case p.UVKind:case p.UV2Kind:case p.UV3Kind:case p.UV4Kind:case p.UV5Kind:case p.UV6Kind:return 2;case p.NormalKind:case p.PositionKind:return 3;case p.ColorKind:case p.ColorInstanceKind:case p.MatricesIndicesKind:case p.MatricesIndicesExtraKind:case p.MatricesWeightsKind:case p.MatricesWeightsExtraKind:case p.TangentKind:return 4;default:throw new Error("Invalid kind '"+I+"'")}}static GetDataType(I){return I instanceof Int8Array?p.BYTE:I instanceof Uint8Array?p.UNSIGNED_BYTE:I instanceof Int16Array?p.SHORT:I instanceof Uint16Array?p.UNSIGNED_SHORT:I instanceof Int32Array?p.INT:I instanceof Uint32Array?p.UNSIGNED_INT:p.FLOAT}static GetTypeByteLength(I){return(0,G.l)(I)}static ForEach(I,x,L,F,X,Y,p,B){(0,G.h)(I,x,L,F,X,Y,p,((I,x)=>{for(let L=0;L<F;L++)B(I[L],x+L)}))}static GetFloatData(I,x,L,F,X,Y,p,B){return(0,G.i)(I,x,L,F,X,Y,p,B)}}p._Counter=0,p.BYTE=5120,p.UNSIGNED_BYTE=5121,p.SHORT=5122,p.UNSIGNED_SHORT=5123,p.INT=5124,p.UNSIGNED_INT=5125,p.FLOAT=5126,p.PositionKind="position",p.NormalKind="normal",p.TangentKind="tangent",p.UVKind="uv",p.UV2Kind="uv2",p.UV3Kind="uv3",p.UV4Kind="uv4",p.UV5Kind="uv5",p.UV6Kind="uv6",p.ColorKind="color",p.ColorInstanceKind="instanceColor",p.MatricesIndicesKind="matricesIndices",p.MatricesWeightsKind="matricesWeights",p.MatricesIndicesExtraKind="matricesIndicesExtra",p.MatricesWeightsExtraKind="matricesWeightsExtra"},13061:(I,x,L)=>{L.d(x,{d:()=>e,f:()=>Q,h:()=>B,i:()=>l,l:()=>Y,n:()=>p,r:()=>W});var F=L(12809);function X(I,x,L,F){switch(x){case 5120:{let x=I.getInt8(L);return F&&(x=Math.max(x/127,-1)),x}case 5121:{let x=I.getUint8(L);return F&&(x/=255),x}case 5122:{let x=I.getInt16(L,!0);return F&&(x=Math.max(x/32767,-1)),x}case 5123:{let x=I.getUint16(L,!0);return F&&(x/=65535),x}case 5124:return I.getInt32(L,!0);case 5125:return I.getUint32(L,!0);case 5126:return I.getFloat32(L,!0);default:throw new Error(`Invalid component type ${x}`)}}function G(I,x,L,F,X){switch(x){case 5120:F&&(X=Math.round(127*X)),I.setInt8(L,X);break;case 5121:F&&(X=Math.round(255*X)),I.setUint8(L,X);break;case 5122:F&&(X=Math.round(32767*X)),I.setInt16(L,X,!0);break;case 5123:F&&(X=Math.round(65535*X)),I.setUint16(L,X,!0);break;case 5124:I.setInt32(L,X,!0);break;case 5125:I.setUint32(L,X,!0);break;case 5126:I.setFloat32(L,X,!0);break;default:throw new Error(`Invalid component type ${x}`)}}function Y(I){switch(I){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${I}'`)}}function p(I){switch(I){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Invalid component type '${I}'`)}}function B(I,x,L,F,p,B,l,W){const Q=new Array(F),e=new Array(F);if(I instanceof Array){let X=x/4;const G=L/4;for(let x=0;x<B;x+=F){for(let x=0;x<F;x++)Q[x]=e[x]=I[X+x];W(e,x);for(let x=0;x<F;x++)Q[x]!==e[x]&&(I[X+x]=e[x]);X+=G}}else{const g=ArrayBuffer.isView(I)?new DataView(I.buffer,I.byteOffset,I.byteLength):new DataView(I),v=Y(p);for(let I=0;I<B;I+=F){for(let I=0,L=x;I<F;I++,L+=v)Q[I]=e[I]=X(g,p,L,l);W(e,I);for(let I=0,L=x;I<F;I++,L+=v)Q[I]!==e[I]&&G(g,p,L,l,e[I]);x+=L}}}function l(I,x,L,X,G,p,l,W){const Q=x*Y(L),e=l*x;if(5126!==L||G!==Q){const F=new Float32Array(e);return B(I,X,G,x,L,e,p,((I,L)=>{for(let X=0;X<x;X++)F[L+X]=I[X]})),F}if(!(I instanceof Array||I instanceof Float32Array)||0!==X||I.length!==e){if(I instanceof Array){const x=X/4;return I.slice(x,x+e)}if(I instanceof ArrayBuffer)return new Float32Array(I,X,e);{const x=I.byteOffset+X;return 0!==(3&x)&&(F.c.Warn("Float array must be aligned to 4-bytes border"),W=!0),W?new Float32Array(I.buffer.slice(x,x+e*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(I.buffer,x,e)}}return W?I.slice():I}function W(I,x,L,X,G,l,W,Q){const e=Y(L),g=p(L),v=W*x;if(Array.isArray(I)){if(0!==(3&X)||0!==(3&G))throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");const F=X/4,Y=G/4;if(F+(W-1)*Y+x>I.length)throw new Error("Last accessed index is out of bounds.");if(Y<x)throw new Error("Data stride cannot be smaller than the component size.");if(Y!==x){const F=new g(v);return B(I,X,G,x,L,v,l,((I,L)=>{for(let X=0;X<x;X++)F[L+X]=I[X]})),F}return new g(I.slice(F,F+v))}let z,H=X;I instanceof ArrayBuffer?z=I:(z=I.buffer,H+=I.byteOffset);if(H+(W-1)*G+x*e>z.byteLength)throw new Error("Last accessed byte is out of bounds.");const s=x*e;if(G<s)throw new Error("Byte stride cannot be smaller than the component's byte size.");if(G!==s){const I=new g(v);return B(z,H,G,x,L,v,l,((L,F)=>{for(let X=0;X<x;X++)I[F+X]=L[X]})),I}return 1!==e&&0!==(H&e-1)&&(F.c.Warn("Array must be aligned to border of element size. Data will be copied."),Q=!0),Q?new g(z.slice(H,H+v*e)):new g(z,H,v)}function Q(I,x,L,X,G,p,l,W){const Q=x*Y(L),e=l*x;if(W.length!==e)throw new Error("Output length is not valid");if(5126===L&&G===Q)if(I instanceof Array){const x=X/4;W.set(I,x)}else if(I instanceof ArrayBuffer){const x=new Float32Array(I,X,e);W.set(x)}else{const x=I.byteOffset+X;if(0!==(3&x))return F.c.Warn("Float array must be aligned to 4-bytes border"),void W.set(new Float32Array(I.buffer.slice(x,x+e*Float32Array.BYTES_PER_ELEMENT)));const L=new Float32Array(I.buffer,x,e);W.set(L)}else B(I,X,G,x,L,e,p,((I,L)=>{for(let F=0;F<x;F++)W[L+F]=I[F]}))}function e(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(Array.isArray(I)){for(let X=0;X<x;X++)if(I[L+X]-F>65535)return!0;return!1}return 4===I.BYTES_PER_ELEMENT}},13056:(I,x,L)=>{L.d(x,{b:()=>F});class F{get underlyingResource(){return null}constructor(){this.references=0,this.tL=0,this.is32Bits=!1,this.uniqueId=F._Counter++}}F._Counter=0},13101:(I,x,L)=>{L.d(x,{d:()=>X});var F=L(12865);class X{static GetEffect(I){return void 0===I.getPipelineContext?I.effect:I}constructor(I){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=I.createDrawContext(),x&&(this.materialContext=I.createMaterialContext())}setEffect(I,x){let L=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];var F;(this.effect=I,void 0!==x&&(this.defines=x),L)&&(null===(F=this.drawContext)||void 0===F||F.reset())}dispose(){var I;let x=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.effect){const I=this.effect;x?I.dispose():F.c.SetImmediate((()=>{I.getEngine().onEndFrameObservable.addOnce((()=>{I.dispose()}))})),this.effect=null}null===(I=this.drawContext)||void 0===I||I.dispose()}}},13185:(I,x,L)=>{L.d(x,{b:()=>X});var F=L(13026);class X{static GetPlanes(I){const x=[];for(let L=0;L<6;L++)x.push(new F.b(0,0,0,0));return X.GetPlanesToRef(I,x),x}static GetNearPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]+L[2],x.normal.y=L[7]+L[6],x.normal.z=L[11]+L[10],x.d=L[15]+L[14],x.normalize()}static GetFarPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]-L[2],x.normal.y=L[7]-L[6],x.normal.z=L[11]-L[10],x.d=L[15]-L[14],x.normalize()}static GetLeftPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]+L[0],x.normal.y=L[7]+L[4],x.normal.z=L[11]+L[8],x.d=L[15]+L[12],x.normalize()}static GetRightPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]-L[0],x.normal.y=L[7]-L[4],x.normal.z=L[11]-L[8],x.d=L[15]-L[12],x.normalize()}static GetTopPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]-L[1],x.normal.y=L[7]-L[5],x.normal.z=L[11]-L[9],x.d=L[15]-L[13],x.normalize()}static GetBottomPlaneToRef(I,x){const L=I.m;x.normal.x=L[3]+L[1],x.normal.y=L[7]+L[5],x.normal.z=L[11]+L[9],x.d=L[15]+L[13],x.normalize()}static GetPlanesToRef(I,x){X.GetNearPlaneToRef(I,x[0]),X.GetFarPlaneToRef(I,x[1]),X.GetLeftPlaneToRef(I,x[2]),X.GetRightPlaneToRef(I,x[3]),X.GetTopPlaneToRef(I,x[4]),X.GetBottomPlaneToRef(I,x[5])}static IsPointInFrustum(I,x){for(let L=0;L<6;L++)if(x[L].dotCoordinate(I)<0)return!1;return!0}}},13197:(I,x,L)=>{L.d(x,{c:()=>X});var F=L(12823);class X{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(I,x){X.Enabled&&(this._current+=I,x&&this._fetchResult())}beginMonitoring(){X.Enabled&&(this._startMonitoringTime=F.c.Now)}endMonitoring(){let I=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(!X.Enabled)return;I&&this.fetchNewFrame();const x=F.c.Now;this._current=x-this._startMonitoringTime,I&&this._fetchResult()}Sp(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const I=F.c.Now;I-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=I,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}X.Enabled=!0},13076:(I,x,L)=>{L.d(x,{b:()=>X,e:()=>F});class F{constructor(I){this.length=0,this.data=new Array(I),this._id=F._GlobalId++}push(I){this.data[this.length++]=I,this.length>this.data.length&&(this.data.length*=2)}forEach(I){for(let x=0;x<this.length;x++)I(this.data[x])}sort(I){this.data.sort(I)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(I){if(0!==I.length){this.length+I.length>this.data.length&&(this.data.length=2*(this.length+I.length));for(let x=0;x<I.length;x++)this.data[this.length++]=(I.data||I)[x]}}indexOf(I){const x=this.data.indexOf(I);return x>=this.length?-1:x}contains(I){return-1!==this.indexOf(I)}}F._GlobalId=0;class X extends F{constructor(){super(...arguments),this._duplicateId=0}push(I){super.push(I),I.__smartArrayFlags||(I.__smartArrayFlags={}),I.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(I){return(!I.__smartArrayFlags||I.__smartArrayFlags[this._id]!==this._duplicateId)&&(this.push(I),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(I){if(0!==I.length){this.length+I.length>this.data.length&&(this.data.length=2*(this.length+I.length));for(let x=0;x<I.length;x++){const L=(I.data||I)[x];this.pushNoDuplicate(L)}}}}},13044:(I,x,L)=>{L.d(x,{c:()=>G});var F=L(13048),X=L(12797);class G{constructor(I){this._vertexBuffers={},this.onBeforeRenderObservable=new X.c,this._scene=I}_prepareBuffers(){if(this._vertexBuffers[F.g.PositionKind])return;const I=[];I.push(1,1),I.push(-1,1),I.push(-1,-1),I.push(1,-1),this._vertexBuffers[F.g.PositionKind]=new F.g(this._scene.getEngine(),I,F.g.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const I=[];I.push(0),I.push(1),I.push(2),I.push(0),I.push(2),I.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(I)}_rebuild(){const I=this._vertexBuffers[F.g.PositionKind];I&&(I._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const L=this._scene.activeCamera;return!!L&&(x=x||L._postProcesses.filter((I=>null!=I)),!(!x||0===x.length||!this._scene.postProcessesEnabled)&&(x[0].activate(L,I,null!==x&&void 0!==x),!0))}directRender(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,G=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:I.length;const p=this._scene.getEngine();for(let l=0;l<Y;l++){var B;if(l<I.length-1)I[l+1].activate(this._scene.activeCamera||this._scene,null===x||void 0===x?void 0:x.texture);else x?p.bindFramebuffer(x,F,void 0,void 0,L,X):G||p.restoreDefaultFramebuffer(),null===(B=p._debugInsertMarker)||void 0===B||B.call(p,`post process ${I[l].name} output`);const Y=I[l],W=Y.apply();W&&(Y.onBeforeRenderObservable.notifyObservers(W),this._prepareBuffers(),p.bindBuffers(this._vertexBuffers,this._indexBuffer,W),p.drawElementsType(0,0,6),Y.onAfterRenderObservable.notifyObservers(W))}p.setDepthBuffer(!0),p.setDepthWrite(!0)}_finalizeFrame(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const G=this._scene.activeCamera;if(!G)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(F=F||G._postProcesses.filter((I=>null!=I))).length||!this._scene.postProcessesEnabled)return;const Y=this._scene.getEngine();for(let B=0,l=F.length;B<l;B++){const W=F[B];var p;if(B<l-1)W._outputTexture=F[B+1].activate(G,null===x||void 0===x?void 0:x.texture);else x?(Y.bindFramebuffer(x,L,void 0,void 0,X),W._outputTexture=x):(Y.restoreDefaultFramebuffer(),W._outputTexture=null),null===(p=Y._debugInsertMarker)||void 0===p||p.call(Y,`post process ${F[B].name} output`);if(I)break;const Q=W.apply();Q&&(W.onBeforeRenderObservable.notifyObservers(Q),this._prepareBuffers(),Y.bindBuffers(this._vertexBuffers,this._indexBuffer,Q),Y.drawElementsType(0,0,6),W.onAfterRenderObservable.notifyObservers(Q))}Y.setDepthBuffer(!0),Y.setDepthWrite(!0),Y.setAlphaMode(0)}dispose(){const I=this._vertexBuffers[F.g.PositionKind];I&&(I.dispose(),this._vertexBuffers[F.g.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},13068:(I,x,L)=>{L.d(x,{c:()=>p});var F=L(13076),X=L(12983);class G{set opaqueSortCompareFn(I){this._opaqueSortCompareFn=I||G.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(I){this._alphaTestSortCompareFn=I||G.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(I){this._transparentSortCompareFn=I||G.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=I,this._opaqueSubMeshes=new F.e(256),this._transparentSubMeshes=new F.e(256),this._alphaTestSubMeshes=new F.e(256),this._depthOnlySubMeshes=new F.e(256),this._particleSystems=new F.e(256),this._spriteManagers=new F.e(256),this._empty=!0,this._edgesRenderers=new F.b(16),this._scene=x,this.opaqueSortCompareFn=L,this.alphaTestSortCompareFn=X,this.transparentSortCompareFn=G}render(I,x,L,F){if(I)return void I(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const X=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(X.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),X.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const G=X.getStencilBuffer();if(X.setStencilBuffer(!1),x&&this._renderSprites(),L&&this._renderParticles(F),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(X.setStencilBuffer(G),this._scene.useOrderIndependentTransparency){const I=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);I.length&&this._renderTransparent(I)}else this._renderTransparent(this._transparentSubMeshes);X.setAlphaMode(0)}if(X.setStencilBuffer(!1),this._edgesRenderers.length){for(let I=0;I<this._edgesRenderers.length;I++)this._edgesRenderers.data[I].render();X.setAlphaMode(0)}X.setStencilBuffer(G)}_renderOpaqueSorted(I){G._RenderSorted(I,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(I){G._RenderSorted(I,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(I){G._RenderSorted(I,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(I,x,L,F){let Y,p=0;const B=L?L.globalPosition:G._ZeroVector;if(F)for(;p<I.length;p++)Y=I.data[p],Y._alphaIndex=Y.getMesh().alphaIndex,Y._distanceToCamera=X.sx.Distance(Y.getBoundingInfo().boundingSphere.centerWorld,B);const l=I.length===I.data.length?I.data:I.data.slice(0,I.length);x&&l.sort(x);const W=l[0].getMesh().tI();for(p=0;p<l.length;p++)if(Y=l[p],!W._activeMeshesFrozenButKeepClipping||Y.isInFrustum(W._frustumPlanes)){if(F){const I=Y.kI();if(I&&I.needDepthPrePass){const x=I.tI().getEngine();x.setColorWrite(!1),x.setAlphaMode(0),Y.render(!1),x.setColorWrite(!0)}}Y.render(F)}}static defaultTransparentSortCompare(I,x){return I._alphaIndex>x._alphaIndex?1:I._alphaIndex<x._alphaIndex?-1:G.backToFrontSortCompare(I,x)}static backToFrontSortCompare(I,x){return I._distanceToCamera<x._distanceToCamera?1:I._distanceToCamera>x._distanceToCamera?-1:0}static frontToBackSortCompare(I,x){return I._distanceToCamera<x._distanceToCamera?-1:I._distanceToCamera>x._distanceToCamera?1:0}static PainterSortCompare(I,x){const L=I.getMesh(),F=x.getMesh();return L.material&&F.material?L.material.uniqueId-F.material.uniqueId:L.uniqueId-F.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(I,x,L){void 0===x&&(x=I.getMesh()),void 0===L&&(L=I.kI()),null!==L&&void 0!==L&&(L.needAlphaBlendingForMesh(x)?this._transparentSubMeshes.push(I):L.needAlphaTestingForMesh(x)?(L.needDepthPrePass&&this._depthOnlySubMeshes.push(I),this._alphaTestSubMeshes.push(I)):(L.needDepthPrePass&&this._depthOnlySubMeshes.push(I),this._opaqueSubMeshes.push(I)),x._renderingGroup=this,x._edgesRenderer&&x.isEnabled()&&x.isVisible&&x._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(x._edgesRenderer),this._empty=!1)}dispatchSprites(I){this._spriteManagers.push(I),this._empty=!1}dispatchParticles(I){this._particleSystems.push(I),this._empty=!1}_renderParticles(I){if(0===this._particleSystems.length)return;const x=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let L=0;L<this._particleSystems.length;L++){const F=this._particleSystems.data[L];if(0===(x&&x.layerMask&F.layerMask))continue;const X=F.Xx;X.position&&I&&-1===I.indexOf(X)||this._scene._activeParticles.addCount(F.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const I=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let x=0;x<this._spriteManagers.length;x++){const L=this._spriteManagers.data[x];0!==(I&&I.layerMask&L.layerMask)&&L.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}G._ZeroVector=X.sx.Zero();class Y{}class p{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(I){I!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=I,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const I of this._scene.meshes)if(I.jp)for(const x of I.jp)x._wasDispatched=!1;if(this._scene.spriteManagers)for(const I of this._scene.spriteManagers)I._wasDispatched=!1;for(const I of this._scene.Gg)I._wasDispatched=!1}constructor(I){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new Y,this._maintainStateBetweenFrames=!1,this._scene=I;for(let x=p.MIN_RENDERINGGROUPS;x<p.MAX_RENDERINGGROUPS;x++)this._autoClearDepthStencil[x]={Vp:!0,depth:!0,op:!0}}getRenderingGroup(I){const x=I||0;return this._prepareRenderingGroup(x),this._renderingGroups[x]}_clearDepthStencilBuffer(){let I=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,I,x),this._depthStencilBufferAlreadyCleaned=!0)}render(I,x,L,F){const X=this._renderingGroupInfo;if(X.qx=this._scene,X.camera=this._scene.activeCamera,X.renderingManager=this,this._scene.spriteManagers&&F)for(let G=0;G<this._scene.spriteManagers.length;G++){const I=this._scene.spriteManagers[G];this.dispatchSprites(I)}for(let G=p.MIN_RENDERINGGROUPS;G<p.MAX_RENDERINGGROUPS;G++){this._depthStencilBufferAlreadyCleaned=G===p.MIN_RENDERINGGROUPS;const Y=this._renderingGroups[G];if(!Y||Y._empty)continue;const B=1<<G;if(X.renderingGroupId=G,this._scene.onBeforeRenderingGroupObservable.notifyObservers(X,B),p.AUTOCLEAR){const I=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(G):this._autoClearDepthStencil[G];I&&I.Vp&&this._clearDepthStencilBuffer(I.depth,I.op)}for(const I of this._scene._beforeRenderingGroupDrawStage)I.action(G);Y.render(I,F,L,x);for(const I of this._scene._afterRenderingGroupDrawStage)I.action(G);this._scene.onAfterRenderingGroupObservable.notifyObservers(X,B)}}reset(){if(!this.maintainStateBetweenFrames)for(let I=p.MIN_RENDERINGGROUPS;I<p.MAX_RENDERINGGROUPS;I++){const x=this._renderingGroups[I];x&&x.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let I=p.MIN_RENDERINGGROUPS;I<p.MAX_RENDERINGGROUPS;I++){const x=this._renderingGroups[I];x&&x.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let I=p.MIN_RENDERINGGROUPS;I<p.MAX_RENDERINGGROUPS;I++){const x=this._renderingGroups[I];x&&x.dispose()}}_prepareRenderingGroup(I){void 0===this._renderingGroups[I]&&(this._renderingGroups[I]=new G(I,this._scene,this._customOpaqueSortCompareFn[I],this._customAlphaTestSortCompareFn[I],this._customTransparentSortCompareFn[I]))}dispatchSprites(I){this.maintainStateBetweenFrames&&I._wasDispatched||(I._wasDispatched=!0,this.getRenderingGroup(I.renderingGroupId).dispatchSprites(I))}dispatchParticles(I){this.maintainStateBetweenFrames&&I._wasDispatched||(I._wasDispatched=!0,this.getRenderingGroup(I.renderingGroupId).dispatchParticles(I))}dispatch(I,x,L){void 0===x&&(x=I.getMesh()),this.maintainStateBetweenFrames&&I._wasDispatched||(I._wasDispatched=!0,this.getRenderingGroup(x.renderingGroupId).dispatch(I,x,L))}setRenderingOrder(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[I]=x,this._customAlphaTestSortCompareFn[I]=L,this._customTransparentSortCompareFn[I]=F,this._renderingGroups[I]){const x=this._renderingGroups[I];x.opaqueSortCompareFn=this._customOpaqueSortCompareFn[I],x.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[I],x.transparentSortCompareFn=this._customTransparentSortCompareFn[I]}}setRenderingAutoClearDepthStencil(I,x){let L=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],F=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[I]={Vp:x,depth:L,op:F}}getAutoClearDepthStencilSetup(I){return this._autoClearDepthStencil[I]}}p.MAX_RENDERINGGROUPS=4,p.MIN_RENDERINGGROUPS=0,p.AUTOCLEAR=!0}}]);