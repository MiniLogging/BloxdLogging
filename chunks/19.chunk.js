"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[19],{12951:(Y,c,h)=>{h.d(c,{d:()=>Q,f:()=>b});var C=h(12954),E=h(12700),N=h(12961);class Q{get q(){return this._isDisposed}constructor(Y,c,h){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],b=arguments.length>6&&void 0!==arguments[6]&&arguments[6],H=arguments.length>7?arguments[7]:void 0,w=arguments.length>8?arguments[8]:void 0;this._isAlreadyOwned=!1,this._isDisposed=!1,Y&&Y.ZY?this._engine=Y.ZY().getEngine():this._engine=Y,this._updatable=h,this._instanced=Q,this._divisor=H||1,this._label=w,c instanceof C.b?(this._data=null,this._buffer=c):(this._data=c,this._buffer=null),this.byteStride=b?E:E*Float32Array.BYTES_PER_ELEMENT,N||this.create()}createVertexBuffer(Y,c,h,C,E){let N=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Q=arguments.length>6?arguments[6]:void 0;const H=N?c:c*Float32Array.BYTES_PER_ELEMENT,w=C?N?C:C*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new b(this._engine,this,Y,this._updatable,!0,w,void 0===E?this._instanced:E,H,h,void 0,void 0,!0,this._divisor||Q)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;!Y&&this._buffer||(Y=Y||this._data,Y&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,Y),this._data=Y):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(Y,this._label),this._data=Y):this._buffer=this._engine.createVertexBuffer(Y,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.ZC>0)return void(this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.ZC,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.ZC,void 0,this._label));E.e.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(Y){this.create(Y)}updateDirectly(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,Y,C?c:c*Float32Array.BYTES_PER_ELEMENT,h?h*this.byteStride:void 0),this._data=0===c&&void 0===h?Y:null)}_increaseReferences(){this._buffer&&(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class b{get q(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(Y){const c=0!=Y;this._instanceDivisor=Y,c!==this._instanced&&(this._instanced=c,this._computeHashCode())}get _maxVerticesCount(){const Y=this.getData();return Y?Array.isArray(Y)?Y.length/(this.byteStride/4)-this.byteOffset/4:(Y.byteLength-this.byteOffset)/this.byteStride:0}constructor(Y,c,h,C,E,H,w,W,q,k){let M=arguments.length>10&&void 0!==arguments[10]&&arguments[10],p=arguments.length>11&&void 0!==arguments[11]&&arguments[11],P=arguments.length>12&&void 0!==arguments[12]?arguments[12]:1,y=arguments.length>13&&void 0!==arguments[13]&&arguments[13];this._isDisposed=!1;let d=!1;if(this.Qh=Y,"object"===typeof C&&null!==C?(d=C.updatable??!1,E=C.postponeInternalCreation,H=C.stride,w=C.instanced,W=C.offset,q=C.size,k=C.type,M=C.normalized??!1,p=C.useBytes??!1,P=C.divisor??1,y=C.takeBufferOwnership??!1,this._label=C.label):d=!!C,c instanceof Q?(this._buffer=c,this._ownsBuffer=y):(this._buffer=new Q(Y,c,d,H,E,w,p,P,this._label),this._ownsBuffer=!0),this.uniqueId=b._Counter++,this._kind=h,void 0===k){const Y=this.getData();this.type=Y?b.GetDataType(Y):b.FLOAT}else this.type=k;const D=(0,N.o)(this.type);p?(this._size=q||(H?H/D:b.DeduceStride(h)),this.byteStride=H||this._buffer.byteStride||this._size*D,this.byteOffset=W||0):(this._size=q||H||b.DeduceStride(h),this.byteStride=H?H*D:this._buffer.byteStride||this._size*D,this.byteOffset=(W||0)*D),this.normalized=M,this._instanced=void 0!==w&&w,this._instanceDivisor=w?P:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120|0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){var Y;null===(Y=this._buffer)||void 0===Y||Y._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(Y,c){const h=this.getData();return h?(0,N.l)(h,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,Y,c):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/(0,N.o)(this.type)}getOffset(){return this.byteOffset/(0,N.o)(this.type)}getSize(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this._size*(0,N.o)(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(Y){this._buffer.create(Y),this._alignBuffer()}update(Y){this._buffer.update(Y),this._alignBuffer()}updateDirectly(Y,c){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._buffer.updateDirectly(Y,c,void 0,h),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(Y,c){(0,N.k)(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,Y,this.normalized,((Y,h)=>{for(let C=0;C<this._size;C++)c(Y[C],h+C)}))}_alignBuffer(){}static DeduceStride(Y){switch(Y){case b.UVKind:case b.UV2Kind:case b.UV3Kind:case b.UV4Kind:case b.UV5Kind:case b.UV6Kind:return 2;case b.NormalKind:case b.PositionKind:return 3;case b.ColorKind:case b.ColorInstanceKind:case b.MatricesIndicesKind:case b.MatricesIndicesExtraKind:case b.MatricesWeightsKind:case b.MatricesWeightsExtraKind:case b.TangentKind:return 4;default:throw new Error("Invalid kind '"+Y+"'")}}static GetDataType(Y){return Y instanceof Int8Array?b.BYTE:Y instanceof Uint8Array?b.UNSIGNED_BYTE:Y instanceof Int16Array?b.SHORT:Y instanceof Uint16Array?b.UNSIGNED_SHORT:Y instanceof Int32Array?b.INT:Y instanceof Uint32Array?b.UNSIGNED_INT:b.FLOAT}static GetTypeByteLength(Y){return(0,N.o)(Y)}static ForEach(Y,c,h,C,E,Q,b,H){(0,N.k)(Y,c,h,C,E,Q,b,((Y,c)=>{for(let h=0;h<C;h++)H(Y[h],c+h)}))}static GetFloatData(Y,c,h,C,E,Q,b,H){return(0,N.l)(Y,c,h,C,E,Q,b,H)}}b._Counter=0,b.BYTE=5120,b.UNSIGNED_BYTE=5121,b.SHORT=5122,b.UNSIGNED_SHORT=5123,b.INT=5124,b.UNSIGNED_INT=5125,b.FLOAT=5126,b.PositionKind="position",b.NormalKind="normal",b.TangentKind="tangent",b.UVKind="uv",b.UV2Kind="uv2",b.UV3Kind="uv3",b.UV4Kind="uv4",b.UV5Kind="uv5",b.UV6Kind="uv6",b.ColorKind="color",b.ColorInstanceKind="instanceColor",b.MatricesIndicesKind="matricesIndices",b.MatricesWeightsKind="matricesWeights",b.MatricesIndicesExtraKind="matricesIndicesExtra",b.MatricesWeightsExtraKind="matricesWeightsExtra"},12961:(Y,c,h)=>{h.d(c,{e:()=>k,g:()=>q,k:()=>H,l:()=>w,o:()=>Q,p:()=>b,r:()=>W});var C=h(12700);function E(Y,c,h,C){switch(c){case 5120:{let c=Y.getInt8(h);return C&&(c=Math.max(c/127,-1)),c}case 5121:{let c=Y.getUint8(h);return C&&(c/=255),c}case 5122:{let c=Y.getInt16(h,!0);return C&&(c=Math.max(c/32767,-1)),c}case 5123:{let c=Y.getUint16(h,!0);return C&&(c/=65535),c}case 5124:return Y.getInt32(h,!0);case 5125:return Y.getUint32(h,!0);case 5126:return Y.getFloat32(h,!0);default:throw new Error(`Invalid component type ${c}`)}}function N(Y,c,h,C,E){switch(c){case 5120:C&&(E=Math.round(127*E)),Y.setInt8(h,E);break;case 5121:C&&(E=Math.round(255*E)),Y.setUint8(h,E);break;case 5122:C&&(E=Math.round(32767*E)),Y.setInt16(h,E,!0);break;case 5123:C&&(E=Math.round(65535*E)),Y.setUint16(h,E,!0);break;case 5124:Y.setInt32(h,E,!0);break;case 5125:Y.setUint32(h,E,!0);break;case 5126:Y.setFloat32(h,E,!0);break;default:throw new Error(`Invalid component type ${c}`)}}function Q(Y){switch(Y){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${Y}'`)}}function b(Y){switch(Y){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Invalid component type '${Y}'`)}}function H(Y,c,h,C,b,H,w,W){const q=new Array(C),k=new Array(C);if(Y instanceof Array){let E=c/4;const N=h/4;for(let c=0;c<H;c+=C){for(let c=0;c<C;c++)q[c]=k[c]=Y[E+c];W(k,c);for(let c=0;c<C;c++)q[c]!==k[c]&&(Y[E+c]=k[c]);E+=N}}else{const M=ArrayBuffer.isView(Y)?new DataView(Y.buffer,Y.byteOffset,Y.byteLength):new DataView(Y),p=Q(b);for(let Y=0;Y<H;Y+=C){for(let Y=0,h=c;Y<C;Y++,h+=p)q[Y]=k[Y]=E(M,b,h,w);W(k,Y);for(let Y=0,h=c;Y<C;Y++,h+=p)q[Y]!==k[Y]&&N(M,b,h,w,k[Y]);c+=h}}}function w(Y,c,h,E,N,b,w,W){const q=c*Q(h),k=w*c;if(5126!==h||N!==q){const C=new Float32Array(k);return H(Y,E,N,c,h,k,b,((Y,h)=>{for(let E=0;E<c;E++)C[h+E]=Y[E]})),C}if(!(Y instanceof Array||Y instanceof Float32Array)||0!==E||Y.length!==k){if(Y instanceof Array){const c=E/4;return Y.slice(c,c+k)}if(Y instanceof ArrayBuffer)return new Float32Array(Y,E,k);{const c=Y.byteOffset+E;return 0!==(3&c)&&(C.e.Warn("Float array must be aligned to 4-bytes border"),W=!0),W?new Float32Array(Y.buffer.slice(c,c+k*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(Y.buffer,c,k)}}return W?Y.slice():Y}function W(Y,c,h,E,N,w,W,q){const k=Q(h),M=b(h),p=W*c;if(Array.isArray(Y)){if(0!==(3&E)||0!==(3&N))throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");const C=E/4,Q=N/4;if(C+(W-1)*Q+c>Y.length)throw new Error("Last accessed index is out of bounds.");if(Q<c)throw new Error("Data stride cannot be smaller than the component size.");if(Q!==c){const C=new M(p);return H(Y,E,N,c,h,p,w,((Y,h)=>{for(let E=0;E<c;E++)C[h+E]=Y[E]})),C}return new M(Y.slice(C,C+p))}let P,y=E;Y instanceof ArrayBuffer?P=Y:(P=Y.buffer,y+=Y.byteOffset);if(y+(W-1)*N+c*k>P.byteLength)throw new Error("Last accessed byte is out of bounds.");const d=c*k;if(N<d)throw new Error("Byte stride cannot be smaller than the component's byte size.");if(N!==d){const Y=new M(p);return H(P,y,N,c,h,p,w,((h,C)=>{for(let E=0;E<c;E++)Y[C+E]=h[E]})),Y}return 1!==k&&0!==(y&k-1)&&(C.e.Warn("Array must be aligned to border of element size. Data will be copied."),q=!0),q?new M(P.slice(y,y+p*k)):new M(P,y,p)}function q(Y,c,h,E,N,b,w,W){const q=c*Q(h),k=w*c;if(W.length!==k)throw new Error("Output length is not valid");if(5126===h&&N===q)if(Y instanceof Array){const c=E/4;W.set(Y,c)}else if(Y instanceof ArrayBuffer){const c=new Float32Array(Y,E,k);W.set(c)}else{const c=Y.byteOffset+E;if(0!==(3&c))return C.e.Warn("Float array must be aligned to 4-bytes border"),void W.set(new Float32Array(Y.buffer.slice(c,c+k*Float32Array.BYTES_PER_ELEMENT)));const h=new Float32Array(Y.buffer,c,k);W.set(h)}else H(Y,E,N,c,h,k,b,((Y,h)=>{for(let C=0;C<c;C++)W[h+C]=Y[C]}))}function k(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(Array.isArray(Y)){for(let E=0;E<c;E++)if(Y[h+E]-C>65535)return!0;return!1}return 4===Y.BYTES_PER_ELEMENT}},12954:(Y,c,h)=>{h.d(c,{b:()=>C});class C{get underlyingResource(){return null}constructor(){this.references=0,this.ZC=0,this.is32Bits=!1,this.uniqueId=C._Counter++}}C._Counter=0},12999:(Y,c,h)=>{h.d(c,{e:()=>E});var C=h(12756);class E{static GetEffect(Y){return void 0===Y.getPipelineContext?Y.effect:Y}constructor(Y){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=Y.createDrawContext(),c&&(this.materialContext=Y.createMaterialContext())}setEffect(Y,c){let h=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];var C;(this.effect=Y,void 0!==c&&(this.defines=c),h)&&(null===(C=this.drawContext)||void 0===C||C.reset())}dispose(){var Y;let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.effect){const Y=this.effect;c?Y.dispose():C.c.SetImmediate((()=>{Y.getEngine().onEndFrameObservable.addOnce((()=>{Y.dispose()}))})),this.effect=null}null===(Y=this.drawContext)||void 0===Y||Y.dispose()}}},13078:(Y,c,h)=>{h.d(c,{c:()=>E});var C=h(12926);class E{static GetPlanes(Y){const c=[];for(let h=0;h<6;h++)c.push(new C.c(0,0,0,0));return E.GetPlanesToRef(Y,c),c}static GetNearPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]+h[2],c.normal.y=h[7]+h[6],c.normal.z=h[11]+h[10],c.d=h[15]+h[14],c.normalize()}static GetFarPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]-h[2],c.normal.y=h[7]-h[6],c.normal.z=h[11]-h[10],c.d=h[15]-h[14],c.normalize()}static GetLeftPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]+h[0],c.normal.y=h[7]+h[4],c.normal.z=h[11]+h[8],c.d=h[15]+h[12],c.normalize()}static GetRightPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]-h[0],c.normal.y=h[7]-h[4],c.normal.z=h[11]-h[8],c.d=h[15]-h[12],c.normalize()}static GetTopPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]-h[1],c.normal.y=h[7]-h[5],c.normal.z=h[11]-h[9],c.d=h[15]-h[13],c.normalize()}static GetBottomPlaneToRef(Y,c){const h=Y.m;c.normal.x=h[3]+h[1],c.normal.y=h[7]+h[5],c.normal.z=h[11]+h[9],c.d=h[15]+h[13],c.normalize()}static GetPlanesToRef(Y,c){E.GetNearPlaneToRef(Y,c[0]),E.GetFarPlaneToRef(Y,c[1]),E.GetLeftPlaneToRef(Y,c[2]),E.GetRightPlaneToRef(Y,c[3]),E.GetTopPlaneToRef(Y,c[4]),E.GetBottomPlaneToRef(Y,c[5])}static IsPointInFrustum(Y,c){for(let h=0;h<6;h++)if(c[h].dotCoordinate(Y)<0)return!1;return!0}}},13091:(Y,c,h)=>{h.d(c,{b:()=>E});var C=h(12709);class E{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(Y,c){E.Enabled&&(this._current+=Y,c&&this._fetchResult())}beginMonitoring(){E.Enabled&&(this._startMonitoringTime=C.d.Now)}endMonitoring(){let Y=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(!E.Enabled)return;Y&&this.fetchNewFrame();const c=C.d.Now;this._current=c-this._startMonitoringTime,Y&&this._fetchResult()}kc(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const Y=C.d.Now;Y-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=Y,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}E.Enabled=!0},12975:(Y,c,h)=>{h.d(c,{e:()=>E,h:()=>C});class C{constructor(Y){this.length=0,this.data=new Array(Y),this._id=C._GlobalId++}push(Y){this.data[this.length++]=Y,this.length>this.data.length&&(this.data.length*=2)}forEach(Y){for(let c=0;c<this.length;c++)Y(this.data[c])}sort(Y){this.data.sort(Y)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(Y){if(0!==Y.length){this.length+Y.length>this.data.length&&(this.data.length=2*(this.length+Y.length));for(let c=0;c<Y.length;c++)this.data[this.length++]=(Y.data||Y)[c]}}indexOf(Y){const c=this.data.indexOf(Y);return c>=this.length?-1:c}contains(Y){return-1!==this.indexOf(Y)}}C._GlobalId=0;class E extends C{constructor(){super(...arguments),this._duplicateId=0}push(Y){super.push(Y),Y.__smartArrayFlags||(Y.__smartArrayFlags={}),Y.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(Y){return(!Y.__smartArrayFlags||Y.__smartArrayFlags[this._id]!==this._duplicateId)&&(this.push(Y),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(Y){if(0!==Y.length){this.length+Y.length>this.data.length&&(this.data.length=2*(this.length+Y.length));for(let c=0;c<Y.length;c++){const h=(Y.data||Y)[c];this.pushNoDuplicate(h)}}}}},12942:(Y,c,h)=>{h.d(c,{e:()=>N});var C=h(12951),E=h(12690);class N{constructor(Y){this._vertexBuffers={},this.onBeforeRenderObservable=new E.c,this._scene=Y}_prepareBuffers(){if(this._vertexBuffers[C.f.PositionKind])return;const Y=[];Y.push(1,1),Y.push(-1,1),Y.push(-1,-1),Y.push(1,-1),this._vertexBuffers[C.f.PositionKind]=new C.f(this._scene.getEngine(),Y,C.f.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const Y=[];Y.push(0),Y.push(1),Y.push(2),Y.push(0),Y.push(2),Y.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(Y)}_rebuild(){const Y=this._vertexBuffers[C.f.PositionKind];Y&&(Y._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const h=this._scene.activeCamera;return!!h&&(c=c||h._postProcesses.filter((Y=>null!=Y)),!(!c||0===c.length||!this._scene.postProcessesEnabled)&&(c[0].activate(h,Y,null!==c&&void 0!==c),!0))}directRender(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,N=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:Y.length;const b=this._scene.getEngine();for(let w=0;w<Q;w++){var H;if(w<Y.length-1)Y[w+1].activate(this._scene.activeCamera||this._scene,null===c||void 0===c?void 0:c.texture);else c?b.bindFramebuffer(c,C,void 0,void 0,h,E):N||b.restoreDefaultFramebuffer(),null===(H=b._debugInsertMarker)||void 0===H||H.call(b,`post process ${Y[w].name} output`);const Q=Y[w],W=Q.apply();W&&(Q.onBeforeRenderObservable.notifyObservers(W),this._prepareBuffers(),b.bindBuffers(this._vertexBuffers,this._indexBuffer,W),b.drawElementsType(0,0,6),Q.onAfterRenderObservable.notifyObservers(W))}b.setDepthBuffer(!0),b.setDepthWrite(!0)}_finalizeFrame(Y,c,h,C){let E=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const N=this._scene.activeCamera;if(!N)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(C=C||N._postProcesses.filter((Y=>null!=Y))).length||!this._scene.postProcessesEnabled)return;const Q=this._scene.getEngine();for(let H=0,w=C.length;H<w;H++){const W=C[H];var b;if(H<w-1)W._outputTexture=C[H+1].activate(N,null===c||void 0===c?void 0:c.texture);else c?(Q.bindFramebuffer(c,h,void 0,void 0,E),W._outputTexture=c):(Q.restoreDefaultFramebuffer(),W._outputTexture=null),null===(b=Q._debugInsertMarker)||void 0===b||b.call(Q,`post process ${C[H].name} output`);if(Y)break;const q=W.apply();q&&(W.onBeforeRenderObservable.notifyObservers(q),this._prepareBuffers(),Q.bindBuffers(this._vertexBuffers,this._indexBuffer,q),Q.drawElementsType(0,0,6),W.onAfterRenderObservable.notifyObservers(q))}Q.setDepthBuffer(!0),Q.setDepthWrite(!0),Q.setAlphaMode(0)}dispose(){const Y=this._vertexBuffers[C.f.PositionKind];Y&&(Y.dispose(),this._vertexBuffers[C.f.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},12966:(Y,c,h)=>{h.d(c,{b:()=>b});var C=h(12975),E=h(12869);class N{set opaqueSortCompareFn(Y){this._opaqueSortCompareFn=Y||N.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(Y){this._alphaTestSortCompareFn=Y||N.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(Y){this._transparentSortCompareFn=Y||N.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=Y,this._opaqueSubMeshes=new C.h(256),this._transparentSubMeshes=new C.h(256),this._alphaTestSubMeshes=new C.h(256),this._depthOnlySubMeshes=new C.h(256),this._particleSystems=new C.h(256),this._spriteManagers=new C.h(256),this._empty=!0,this._edgesRenderers=new C.e(16),this._scene=c,this.opaqueSortCompareFn=h,this.alphaTestSortCompareFn=E,this.transparentSortCompareFn=N}render(Y,c,h,C){if(Y)return void Y(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const E=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(E.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),E.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const N=E.getStencilBuffer();if(E.setStencilBuffer(!1),c&&this._renderSprites(),h&&this._renderParticles(C),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(E.setStencilBuffer(N),this._scene.useOrderIndependentTransparency){const Y=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);Y.length&&this._renderTransparent(Y)}else this._renderTransparent(this._transparentSubMeshes);E.setAlphaMode(0)}if(E.setStencilBuffer(!1),this._edgesRenderers.length){for(let Y=0;Y<this._edgesRenderers.length;Y++)this._edgesRenderers.data[Y].render();E.setAlphaMode(0)}E.setStencilBuffer(N)}_renderOpaqueSorted(Y){N._RenderSorted(Y,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(Y){N._RenderSorted(Y,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(Y){N._RenderSorted(Y,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(Y,c,h,C){let Q,b=0;const H=h?h.globalPosition:N._ZeroVector;if(C)for(;b<Y.length;b++)Q=Y.data[b],Q._alphaIndex=Q.getMesh().alphaIndex,Q._distanceToCamera=E.bh.Distance(Q.getBoundingInfo().boundingSphere.centerWorld,H);const w=Y.length===Y.data.length?Y.data:Y.data.slice(0,Y.length);c&&w.sort(c);const W=w[0].getMesh().ZY();for(b=0;b<w.length;b++)if(Q=w[b],!W._activeMeshesFrozenButKeepClipping||Q.isInFrustum(W._frustumPlanes)){if(C){const Y=Q.vY();if(Y&&Y.needDepthPrePass){const c=Y.ZY().getEngine();c.setColorWrite(!1),c.setAlphaMode(0),Q.render(!1),c.setColorWrite(!0)}}Q.render(C)}}static defaultTransparentSortCompare(Y,c){return Y._alphaIndex>c._alphaIndex?1:Y._alphaIndex<c._alphaIndex?-1:N.backToFrontSortCompare(Y,c)}static backToFrontSortCompare(Y,c){return Y._distanceToCamera<c._distanceToCamera?1:Y._distanceToCamera>c._distanceToCamera?-1:0}static frontToBackSortCompare(Y,c){return Y._distanceToCamera<c._distanceToCamera?-1:Y._distanceToCamera>c._distanceToCamera?1:0}static PainterSortCompare(Y,c){const h=Y.getMesh(),C=c.getMesh();return h.material&&C.material?h.material.uniqueId-C.material.uniqueId:h.uniqueId-C.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(Y,c,h){void 0===c&&(c=Y.getMesh()),void 0===h&&(h=Y.vY()),null!==h&&void 0!==h&&(h.needAlphaBlendingForMesh(c)?this._transparentSubMeshes.push(Y):h.needAlphaTestingForMesh(c)?(h.needDepthPrePass&&this._depthOnlySubMeshes.push(Y),this._alphaTestSubMeshes.push(Y)):(h.needDepthPrePass&&this._depthOnlySubMeshes.push(Y),this._opaqueSubMeshes.push(Y)),c._renderingGroup=this,c._edgesRenderer&&c.isEnabled()&&c.isVisible&&c._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(c._edgesRenderer),this._empty=!1)}dispatchSprites(Y){this._spriteManagers.push(Y),this._empty=!1}dispatchParticles(Y){this._particleSystems.push(Y),this._empty=!1}_renderParticles(Y){if(0===this._particleSystems.length)return;const c=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let h=0;h<this._particleSystems.length;h++){const C=this._particleSystems.data[h];if(0===(c&&c.layerMask&C.layerMask))continue;const E=C.Cc;E.position&&Y&&-1===Y.indexOf(E)||this._scene._activeParticles.addCount(C.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const Y=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let c=0;c<this._spriteManagers.length;c++){const h=this._spriteManagers.data[c];0!==(Y&&Y.layerMask&h.layerMask)&&h.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}N._ZeroVector=E.bh.Zero();class Q{}class b{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(Y){Y!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=Y,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const Y of this._scene.meshes)if(Y.rc)for(const c of Y.rc)c._wasDispatched=!1;if(this._scene.spriteManagers)for(const Y of this._scene.spriteManagers)Y._wasDispatched=!1;for(const Y of this._scene.OM)Y._wasDispatched=!1}constructor(Y){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new Q,this._maintainStateBetweenFrames=!1,this._scene=Y;for(let c=b.MIN_RENDERINGGROUPS;c<b.MAX_RENDERINGGROUPS;c++)this._autoClearDepthStencil[c]={ec:!0,depth:!0,Pc:!0}}getRenderingGroup(Y){const c=Y||0;return this._prepareRenderingGroup(c),this._renderingGroups[c]}_clearDepthStencilBuffer(){let Y=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,Y,c),this._depthStencilBufferAlreadyCleaned=!0)}render(Y,c,h,C){const E=this._renderingGroupInfo;if(E.wh=this._scene,E.camera=this._scene.activeCamera,E.renderingManager=this,this._scene.spriteManagers&&C)for(let N=0;N<this._scene.spriteManagers.length;N++){const Y=this._scene.spriteManagers[N];this.dispatchSprites(Y)}for(let N=b.MIN_RENDERINGGROUPS;N<b.MAX_RENDERINGGROUPS;N++){this._depthStencilBufferAlreadyCleaned=N===b.MIN_RENDERINGGROUPS;const Q=this._renderingGroups[N];if(!Q||Q._empty)continue;const H=1<<N;if(E.renderingGroupId=N,this._scene.onBeforeRenderingGroupObservable.notifyObservers(E,H),b.AUTOCLEAR){const Y=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(N):this._autoClearDepthStencil[N];Y&&Y.ec&&this._clearDepthStencilBuffer(Y.depth,Y.Pc)}for(const Y of this._scene._beforeRenderingGroupDrawStage)Y.action(N);Q.render(Y,C,h,c);for(const Y of this._scene._afterRenderingGroupDrawStage)Y.action(N);this._scene.onAfterRenderingGroupObservable.notifyObservers(E,H)}}reset(){if(!this.maintainStateBetweenFrames)for(let Y=b.MIN_RENDERINGGROUPS;Y<b.MAX_RENDERINGGROUPS;Y++){const c=this._renderingGroups[Y];c&&c.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let Y=b.MIN_RENDERINGGROUPS;Y<b.MAX_RENDERINGGROUPS;Y++){const c=this._renderingGroups[Y];c&&c.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let Y=b.MIN_RENDERINGGROUPS;Y<b.MAX_RENDERINGGROUPS;Y++){const c=this._renderingGroups[Y];c&&c.dispose()}}_prepareRenderingGroup(Y){void 0===this._renderingGroups[Y]&&(this._renderingGroups[Y]=new N(Y,this._scene,this._customOpaqueSortCompareFn[Y],this._customAlphaTestSortCompareFn[Y],this._customTransparentSortCompareFn[Y]))}dispatchSprites(Y){this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(Y.renderingGroupId).dispatchSprites(Y))}dispatchParticles(Y){this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(Y.renderingGroupId).dispatchParticles(Y))}dispatch(Y,c,h){void 0===c&&(c=Y.getMesh()),this.maintainStateBetweenFrames&&Y._wasDispatched||(Y._wasDispatched=!0,this.getRenderingGroup(c.renderingGroupId).dispatch(Y,c,h))}setRenderingOrder(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[Y]=c,this._customAlphaTestSortCompareFn[Y]=h,this._customTransparentSortCompareFn[Y]=C,this._renderingGroups[Y]){const c=this._renderingGroups[Y];c.opaqueSortCompareFn=this._customOpaqueSortCompareFn[Y],c.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[Y],c.transparentSortCompareFn=this._customTransparentSortCompareFn[Y]}}setRenderingAutoClearDepthStencil(Y,c){let h=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],C=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[Y]={ec:c,depth:h,Pc:C}}getAutoClearDepthStencilSetup(Y){return this._autoClearDepthStencil[Y]}}b.MAX_RENDERINGGROUPS=4,b.MIN_RENDERINGGROUPS=0,b.AUTOCLEAR=!0}}]);