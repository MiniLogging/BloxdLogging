"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[19],{12430:(M,Z,P)=>{P.d(Z,{c:()=>v,g:()=>G});var x=P(12439),c=P(12199),w=P(12448);class v{get K(){return this._isDisposed}constructor(M,Z,P){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,w=arguments.length>4&&void 0!==arguments[4]&&arguments[4],v=arguments.length>5&&void 0!==arguments[5]&&arguments[5],G=arguments.length>6&&void 0!==arguments[6]&&arguments[6],mM=arguments.length>7?arguments[7]:void 0,K=arguments.length>8?arguments[8]:void 0;this._isAlreadyOwned=!1,this._isDisposed=!1,M&&M.DM?this._engine=M.DM().getEngine():this._engine=M,this._updatable=P,this._instanced=v,this._divisor=mM||1,this._label=K,Z instanceof x.b?(this._data=null,this._buffer=Z):(this._data=Z,this._buffer=null),this.byteStride=G?c:c*Float32Array.BYTES_PER_ELEMENT,w||this.create()}createVertexBuffer(M,Z,P,x,c){let w=arguments.length>5&&void 0!==arguments[5]&&arguments[5],v=arguments.length>6?arguments[6]:void 0;const mM=w?Z:Z*Float32Array.BYTES_PER_ELEMENT,K=x?w?x:x*Float32Array.BYTES_PER_ELEMENT:this.byteStride;return new G(this._engine,this,M,this._updatable,!0,K,void 0===c?this._instanced:c,mM,P,void 0,void 0,!0,this._divisor||v)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;!M&&this._buffer||(M=M||this._data,M&&(this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,M),this._data=M):this._updatable?(this._buffer=this._engine.createDynamicVertexBuffer(M,this._label),this._data=M):this._buffer=this._engine.createVertexBuffer(M,void 0,this._label)))}_rebuild(){if(this._data)this._buffer=null,this.create(this._data);else{if(!this._buffer)return;if(this._buffer.tZ>0)return void(this._updatable?this._buffer=this._engine.createDynamicVertexBuffer(this._buffer.tZ,this._label):this._buffer=this._engine.createVertexBuffer(this._buffer.tZ,void 0,this._label));c.d.Warn(`Missing data for buffer "${this._label}" ${this._buffer?"(uniqueId: "+this._buffer.uniqueId+")":""}. Buffer reconstruction failed.`),this._buffer=null}}update(M){this.create(M)}updateDirectly(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,M,x?Z:Z*Float32Array.BYTES_PER_ELEMENT,P?P*this.byteStride:void 0),this._data=0===Z&&void 0===P?M:null)}_increaseReferences(){this._buffer&&(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._isDisposed=!0,this._data=null,this._buffer=null)}}class G{get K(){return this._isDisposed}get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(M){const Z=0!=M;this._instanceDivisor=M,Z!==this._instanced&&(this._instanced=Z,this._computeHashCode())}get _maxVerticesCount(){const M=this.getData();return M?Array.isArray(M)?M.length/(this.byteStride/4)-this.byteOffset/4:(M.byteLength-this.byteOffset)/this.byteStride:0}constructor(M,Z,P,x,c,mM,K,d,O,H){let j=arguments.length>10&&void 0!==arguments[10]&&arguments[10],B=arguments.length>11&&void 0!==arguments[11]&&arguments[11],U=arguments.length>12&&void 0!==arguments[12]?arguments[12]:1,n=arguments.length>13&&void 0!==arguments[13]&&arguments[13];this._isDisposed=!1;let L=!1;if(this.jZ=M,"object"===typeof x&&null!==x?(L=x.updatable??!1,c=x.postponeInternalCreation,mM=x.stride,K=x.instanced,d=x.offset,O=x.size,H=x.type,j=x.normalized??!1,B=x.useBytes??!1,U=x.divisor??1,n=x.takeBufferOwnership??!1,this._label=x.label):L=!!x,Z instanceof v?(this._buffer=Z,this._ownsBuffer=n):(this._buffer=new v(M,Z,L,mM,c,K,B,U,this._label),this._ownsBuffer=!0),this.uniqueId=G._Counter++,this._kind=P,void 0===H){const M=this.getData();this.type=M?G.GetDataType(M):G.FLOAT}else this.type=H;const u=(0,w.q)(this.type);B?(this._size=O||(mM?mM/u:G.DeduceStride(P)),this.byteStride=mM||this._buffer.byteStride||this._size*u,this.byteOffset=d||0):(this._size=O||mM||G.DeduceStride(P),this.byteStride=mM?mM*u:this._buffer.byteStride||this._size*u,this.byteOffset=(d||0)*u),this.normalized=j,this._instanced=void 0!==K&&K,this._instanceDivisor=K?U:0,this._alignBuffer(),this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120|0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){var M;null===(M=this._buffer)||void 0===M||M._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(M,Z){const P=this.getData();return P?(0,w.n)(P,this._size,this.type,this.byteOffset,this.byteStride,this.normalized,M,Z):null}getBuffer(){return this._buffer.getBuffer()}getWrapperBuffer(){return this._buffer}getStrideSize(){return this.byteStride/(0,w.q)(this.type)}getOffset(){return this.byteOffset/(0,w.q)(this.type)}getSize(){return arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this._size*(0,w.q)(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(M){this._buffer.create(M),this._alignBuffer()}update(M){this._buffer.update(M),this._alignBuffer()}updateDirectly(M,Z){let P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];this._buffer.updateDirectly(M,Z,void 0,P),this._alignBuffer()}dispose(){this._ownsBuffer&&this._buffer.dispose(),this._isDisposed=!0}forEach(M,Z){(0,w.l)(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,M,this.normalized,((M,P)=>{for(let x=0;x<this._size;x++)Z(M[x],P+x)}))}_alignBuffer(){}static DeduceStride(M){switch(M){case G.UVKind:case G.UV2Kind:case G.UV3Kind:case G.UV4Kind:case G.UV5Kind:case G.UV6Kind:return 2;case G.NormalKind:case G.PositionKind:return 3;case G.ColorKind:case G.ColorInstanceKind:case G.MatricesIndicesKind:case G.MatricesIndicesExtraKind:case G.MatricesWeightsKind:case G.MatricesWeightsExtraKind:case G.TangentKind:return 4;default:throw new Error("Invalid kind '"+M+"'")}}static GetDataType(M){return M instanceof Int8Array?G.BYTE:M instanceof Uint8Array?G.UNSIGNED_BYTE:M instanceof Int16Array?G.SHORT:M instanceof Uint16Array?G.UNSIGNED_SHORT:M instanceof Int32Array?G.INT:M instanceof Uint32Array?G.UNSIGNED_INT:G.FLOAT}static GetTypeByteLength(M){return(0,w.q)(M)}static ForEach(M,Z,P,x,c,v,G,mM){(0,w.l)(M,Z,P,x,c,v,G,((M,Z)=>{for(let P=0;P<x;P++)mM(M[P],Z+P)}))}static GetFloatData(M,Z,P,x,c,v,G,mM){return(0,w.n)(M,Z,P,x,c,v,G,mM)}}G._Counter=0,G.BYTE=5120,G.UNSIGNED_BYTE=5121,G.SHORT=5122,G.UNSIGNED_SHORT=5123,G.INT=5124,G.UNSIGNED_INT=5125,G.FLOAT=5126,G.PositionKind="position",G.NormalKind="normal",G.TangentKind="tangent",G.UVKind="uv",G.UV2Kind="uv2",G.UV3Kind="uv3",G.UV4Kind="uv4",G.UV5Kind="uv5",G.UV6Kind="uv6",G.ColorKind="color",G.ColorInstanceKind="instanceColor",G.MatricesIndicesKind="matricesIndices",G.MatricesWeightsKind="matricesWeights",G.MatricesIndicesExtraKind="matricesIndicesExtra",G.MatricesWeightsExtraKind="matricesWeightsExtra"},12448:(M,Z,P)=>{P.d(Z,{e:()=>H,i:()=>O,l:()=>mM,n:()=>K,q:()=>v,s:()=>G,w:()=>d});var x=P(12199);function c(M,Z,P,x){switch(Z){case 5120:{let Z=M.getInt8(P);return x&&(Z=Math.max(Z/127,-1)),Z}case 5121:{let Z=M.getUint8(P);return x&&(Z/=255),Z}case 5122:{let Z=M.getInt16(P,!0);return x&&(Z=Math.max(Z/32767,-1)),Z}case 5123:{let Z=M.getUint16(P,!0);return x&&(Z/=65535),Z}case 5124:return M.getInt32(P,!0);case 5125:return M.getUint32(P,!0);case 5126:return M.getFloat32(P,!0);default:throw new Error(`Invalid component type ${Z}`)}}function w(M,Z,P,x,c){switch(Z){case 5120:x&&(c=Math.round(127*c)),M.setInt8(P,c);break;case 5121:x&&(c=Math.round(255*c)),M.setUint8(P,c);break;case 5122:x&&(c=Math.round(32767*c)),M.setInt16(P,c,!0);break;case 5123:x&&(c=Math.round(65535*c)),M.setUint16(P,c,!0);break;case 5124:M.setInt32(P,c,!0);break;case 5125:M.setUint32(P,c,!0);break;case 5126:M.setFloat32(P,c,!0);break;default:throw new Error(`Invalid component type ${Z}`)}}function v(M){switch(M){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5124:case 5125:case 5126:return 4;default:throw new Error(`Invalid type '${M}'`)}}function G(M){switch(M){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5124:return Int32Array;case 5125:return Uint32Array;case 5126:return Float32Array;default:throw new Error(`Invalid component type '${M}'`)}}function mM(M,Z,P,x,G,mM,K,d){const O=new Array(x),H=new Array(x);if(M instanceof Array){let c=Z/4;const w=P/4;for(let Z=0;Z<mM;Z+=x){for(let Z=0;Z<x;Z++)O[Z]=H[Z]=M[c+Z];d(H,Z);for(let Z=0;Z<x;Z++)O[Z]!==H[Z]&&(M[c+Z]=H[Z]);c+=w}}else{const j=ArrayBuffer.isView(M)?new DataView(M.buffer,M.byteOffset,M.byteLength):new DataView(M),B=v(G);for(let M=0;M<mM;M+=x){for(let M=0,P=Z;M<x;M++,P+=B)O[M]=H[M]=c(j,G,P,K);d(H,M);for(let M=0,P=Z;M<x;M++,P+=B)O[M]!==H[M]&&w(j,G,P,K,H[M]);Z+=P}}}function K(M,Z,P,c,w,G,K,d){const O=Z*v(P),H=K*Z;if(5126!==P||w!==O){const x=new Float32Array(H);return mM(M,c,w,Z,P,H,G,((M,P)=>{for(let c=0;c<Z;c++)x[P+c]=M[c]})),x}if(!(M instanceof Array||M instanceof Float32Array)||0!==c||M.length!==H){if(M instanceof Array){const Z=c/4;return M.slice(Z,Z+H)}if(M instanceof ArrayBuffer)return new Float32Array(M,c,H);{const Z=M.byteOffset+c;return 0!==(3&Z)&&(x.d.Warn("Float array must be aligned to 4-bytes border"),d=!0),d?new Float32Array(M.buffer.slice(Z,Z+H*Float32Array.BYTES_PER_ELEMENT)):new Float32Array(M.buffer,Z,H)}}return d?M.slice():M}function d(M,Z,P,c,w,K,d,O){const H=v(P),j=G(P),B=d*Z;if(Array.isArray(M)){if(0!==(3&c)||0!==(3&w))throw new Error("byteOffset and byteStride must be a multiple of 4 for number[] data.");const x=c/4,v=w/4;if(x+(d-1)*v+Z>M.length)throw new Error("Last accessed index is out of bounds.");if(v<Z)throw new Error("Data stride cannot be smaller than the component size.");if(v!==Z){const x=new j(B);return mM(M,c,w,Z,P,B,K,((M,P)=>{for(let c=0;c<Z;c++)x[P+c]=M[c]})),x}return new j(M.slice(x,x+B))}let U,n=c;M instanceof ArrayBuffer?U=M:(U=M.buffer,n+=M.byteOffset);if(n+(d-1)*w+Z*H>U.byteLength)throw new Error("Last accessed byte is out of bounds.");const L=Z*H;if(w<L)throw new Error("Byte stride cannot be smaller than the component's byte size.");if(w!==L){const M=new j(B);return mM(U,n,w,Z,P,B,K,((P,x)=>{for(let c=0;c<Z;c++)M[x+c]=P[c]})),M}return 1!==H&&0!==(n&H-1)&&(x.d.Warn("Array must be aligned to border of element size. Data will be copied."),O=!0),O?new j(U.slice(n,n+B*H)):new j(U,n,B)}function O(M,Z,P,c,w,G,K,d){const O=Z*v(P),H=K*Z;if(d.length!==H)throw new Error("Output length is not valid");if(5126===P&&w===O)if(M instanceof Array){const Z=c/4;d.set(M,Z)}else if(M instanceof ArrayBuffer){const Z=new Float32Array(M,c,H);d.set(Z)}else{const Z=M.byteOffset+c;if(0!==(3&Z))return x.d.Warn("Float array must be aligned to 4-bytes border"),void d.set(new Float32Array(M.buffer.slice(Z,Z+H*Float32Array.BYTES_PER_ELEMENT)));const P=new Float32Array(M.buffer,Z,H);d.set(P)}else mM(M,c,w,Z,P,H,G,((M,P)=>{for(let x=0;x<Z;x++)d[P+x]=M[x]}))}function H(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;if(Array.isArray(M)){for(let c=0;c<Z;c++)if(M[P+c]-x>65535)return!0;return!1}return 4===M.BYTES_PER_ELEMENT}},12439:(M,Z,P)=>{P.d(Z,{b:()=>x});class x{get underlyingResource(){return null}constructor(){this.references=0,this.tZ=0,this.is32Bits=!1,this.uniqueId=x._Counter++}}x._Counter=0},12471:(M,Z,P)=>{P.d(Z,{e:()=>c});var x=P(12258);class c{static GetEffect(M){return void 0===M.getPipelineContext?M.effect:M}constructor(M){let Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._wasPreviouslyReady=!1,this._forceRebindOnNextCall=!0,this._wasPreviouslyUsingInstances=null,this.effect=null,this.defines=null,this.drawContext=M.createDrawContext(),Z&&(this.materialContext=M.createMaterialContext())}setEffect(M,Z){let P=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];var x;(this.effect=M,void 0!==Z&&(this.defines=Z),P)&&(null===(x=this.drawContext)||void 0===x||x.reset())}dispose(){var M;let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.effect){const M=this.effect;Z?M.dispose():x.b.SetImmediate((()=>{M.getEngine().onEndFrameObservable.addOnce((()=>{M.dispose()}))})),this.effect=null}null===(M=this.drawContext)||void 0===M||M.dispose()}}},12567:(M,Z,P)=>{P.d(Z,{c:()=>c});var x=P(12408);class c{static GetPlanes(M){const Z=[];for(let P=0;P<6;P++)Z.push(new x.c(0,0,0,0));return c.GetPlanesToRef(M,Z),Z}static GetNearPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]+P[2],Z.normal.y=P[7]+P[6],Z.normal.z=P[11]+P[10],Z.d=P[15]+P[14],Z.normalize()}static GetFarPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]-P[2],Z.normal.y=P[7]-P[6],Z.normal.z=P[11]-P[10],Z.d=P[15]-P[14],Z.normalize()}static GetLeftPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]+P[0],Z.normal.y=P[7]+P[4],Z.normal.z=P[11]+P[8],Z.d=P[15]+P[12],Z.normalize()}static GetRightPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]-P[0],Z.normal.y=P[7]-P[4],Z.normal.z=P[11]-P[8],Z.d=P[15]-P[12],Z.normalize()}static GetTopPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]-P[1],Z.normal.y=P[7]-P[5],Z.normal.z=P[11]-P[9],Z.d=P[15]-P[13],Z.normalize()}static GetBottomPlaneToRef(M,Z){const P=M.m;Z.normal.x=P[3]+P[1],Z.normal.y=P[7]+P[5],Z.normal.z=P[11]+P[9],Z.d=P[15]+P[13],Z.normalize()}static GetPlanesToRef(M,Z){c.GetNearPlaneToRef(M,Z[0]),c.GetFarPlaneToRef(M,Z[1]),c.GetLeftPlaneToRef(M,Z[2]),c.GetRightPlaneToRef(M,Z[3]),c.GetTopPlaneToRef(M,Z[4]),c.GetBottomPlaneToRef(M,Z[5])}static IsPointInFrustum(M,Z){for(let P=0;P<6;P++)if(Z[P].dotCoordinate(M)<0)return!1;return!0}}},12572:(M,Z,P)=>{P.d(Z,{b:()=>c});var x=P(12209);class c{get min(){return this._min}get max(){return this._max}get average(){return this._average}get lastSecAverage(){return this._lastSecAverage}get current(){return this._current}get total(){return this._totalAccumulated}get count(){return this._totalValueCount}constructor(){this._startMonitoringTime=0,this._min=0,this._max=0,this._average=0,this._lastSecAverage=0,this._current=0,this._totalValueCount=0,this._totalAccumulated=0,this._lastSecAccumulated=0,this._lastSecTime=0,this._lastSecValueCount=0}fetchNewFrame(){this._totalValueCount++,this._current=0,this._lastSecValueCount++}addCount(M,Z){c.Enabled&&(this._current+=M,Z&&this._fetchResult())}beginMonitoring(){c.Enabled&&(this._startMonitoringTime=x.c.Now)}endMonitoring(){let M=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];if(!c.Enabled)return;M&&this.fetchNewFrame();const Z=x.c.Now;this._current=Z-this._startMonitoringTime,M&&this._fetchResult()}vc(){this._fetchResult()}_fetchResult(){this._totalAccumulated+=this._current,this._lastSecAccumulated+=this._current,this._min=Math.min(this._min,this._current),this._max=Math.max(this._max,this._current),this._average=this._totalAccumulated/this._totalValueCount;const M=x.c.Now;M-this._lastSecTime>1e3&&(this._lastSecAverage=this._lastSecAccumulated/this._lastSecValueCount,this._lastSecTime=M,this._lastSecAccumulated=0,this._lastSecValueCount=0)}}c.Enabled=!0},12457:(M,Z,P)=>{P.d(Z,{d:()=>c,g:()=>x});class x{constructor(M){this.length=0,this.data=new Array(M),this._id=x._GlobalId++}push(M){this.data[this.length++]=M,this.length>this.data.length&&(this.data.length*=2)}forEach(M){for(let Z=0;Z<this.length;Z++)M(this.data[Z])}sort(M){this.data.sort(M)}reset(){this.length=0}dispose(){this.reset(),this.data&&(this.data.length=0)}concat(M){if(0!==M.length){this.length+M.length>this.data.length&&(this.data.length=2*(this.length+M.length));for(let Z=0;Z<M.length;Z++)this.data[this.length++]=(M.data||M)[Z]}}indexOf(M){const Z=this.data.indexOf(M);return Z>=this.length?-1:Z}contains(M){return-1!==this.indexOf(M)}}x._GlobalId=0;class c extends x{constructor(){super(...arguments),this._duplicateId=0}push(M){super.push(M),M.__smartArrayFlags||(M.__smartArrayFlags={}),M.__smartArrayFlags[this._id]=this._duplicateId}pushNoDuplicate(M){return(!M.__smartArrayFlags||M.__smartArrayFlags[this._id]!==this._duplicateId)&&(this.push(M),!0)}reset(){super.reset(),this._duplicateId++}concatWithNoDuplicate(M){if(0!==M.length){this.length+M.length>this.data.length&&(this.data.length=2*(this.length+M.length));for(let Z=0;Z<M.length;Z++){const P=(M.data||M)[Z];this.pushNoDuplicate(P)}}}}},12426:(M,Z,P)=>{P.d(Z,{c:()=>w});var x=P(12430),c=P(12184);class w{constructor(M){this._vertexBuffers={},this.onBeforeRenderObservable=new c.b,this._scene=M}_prepareBuffers(){if(this._vertexBuffers[x.g.PositionKind])return;const M=[];M.push(1,1),M.push(-1,1),M.push(-1,-1),M.push(1,-1),this._vertexBuffers[x.g.PositionKind]=new x.g(this._scene.getEngine(),M,x.g.PositionKind,!1,!1,2),this._buildIndexBuffer()}_buildIndexBuffer(){const M=[];M.push(0),M.push(1),M.push(2),M.push(0),M.push(2),M.push(3),this._indexBuffer=this._scene.getEngine().createIndexBuffer(M)}_rebuild(){const M=this._vertexBuffers[x.g.PositionKind];M&&(M._rebuild(),this._buildIndexBuffer())}_prepareFrame(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const P=this._scene.activeCamera;return!!P&&(Z=Z||P._postProcesses.filter((M=>null!=M)),!(!Z||0===Z.length||!this._scene.postProcessesEnabled)&&(Z[0].activate(P,M,null!==Z&&void 0!==Z),!0))}directRender(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]&&arguments[2],x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,w=arguments.length>5&&void 0!==arguments[5]&&arguments[5],v=arguments.length>6&&void 0!==arguments[6]?arguments[6]:M.length;const G=this._scene.getEngine();for(let K=0;K<v;K++){var mM;if(K<M.length-1)M[K+1].activate(this._scene.activeCamera||this._scene,null===Z||void 0===Z?void 0:Z.texture);else Z?G.bindFramebuffer(Z,x,void 0,void 0,P,c):w||G.restoreDefaultFramebuffer(),null===(mM=G._debugInsertMarker)||void 0===mM||mM.call(G,`post process ${M[K].name} output`);const v=M[K],d=v.apply();d&&(v.onBeforeRenderObservable.notifyObservers(d),this._prepareBuffers(),G.bindBuffers(this._vertexBuffers,this._indexBuffer,d),G.drawElementsType(0,0,6),v.onAfterRenderObservable.notifyObservers(d))}G.setDepthBuffer(!0),G.setDepthWrite(!0)}_finalizeFrame(M,Z,P,x){let c=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const w=this._scene.activeCamera;if(!w)return;if(this.onBeforeRenderObservable.notifyObservers(this),0===(x=x||w._postProcesses.filter((M=>null!=M))).length||!this._scene.postProcessesEnabled)return;const v=this._scene.getEngine();for(let mM=0,K=x.length;mM<K;mM++){const d=x[mM];var G;if(mM<K-1)d._outputTexture=x[mM+1].activate(w,null===Z||void 0===Z?void 0:Z.texture);else Z?(v.bindFramebuffer(Z,P,void 0,void 0,c),d._outputTexture=Z):(v.restoreDefaultFramebuffer(),d._outputTexture=null),null===(G=v._debugInsertMarker)||void 0===G||G.call(v,`post process ${x[mM].name} output`);if(M)break;const O=d.apply();O&&(d.onBeforeRenderObservable.notifyObservers(O),this._prepareBuffers(),v.bindBuffers(this._vertexBuffers,this._indexBuffer,O),v.drawElementsType(0,0,6),d.onAfterRenderObservable.notifyObservers(O))}v.setDepthBuffer(!0),v.setDepthWrite(!0),v.setAlphaMode(0)}dispose(){const M=this._vertexBuffers[x.g.PositionKind];M&&(M.dispose(),this._vertexBuffers[x.g.PositionKind]=null),this._indexBuffer&&(this._scene.getEngine()._releaseBuffer(this._indexBuffer),this._indexBuffer=null)}}},12452:(M,Z,P)=>{P.d(Z,{d:()=>G});var x=P(12457),c=P(12373);class w{set opaqueSortCompareFn(M){this._opaqueSortCompareFn=M||w.PainterSortCompare,this._renderOpaque=this._renderOpaqueSorted}set alphaTestSortCompareFn(M){this._alphaTestSortCompareFn=M||w.PainterSortCompare,this._renderAlphaTest=this._renderAlphaTestSorted}set transparentSortCompareFn(M){this._transparentSortCompareFn=M||w.defaultTransparentSortCompare,this._renderTransparent=this._renderTransparentSorted}constructor(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.index=M,this._opaqueSubMeshes=new x.g(256),this._transparentSubMeshes=new x.g(256),this._alphaTestSubMeshes=new x.g(256),this._depthOnlySubMeshes=new x.g(256),this._particleSystems=new x.g(256),this._spriteManagers=new x.g(256),this._empty=!0,this._edgesRenderers=new x.d(16),this._scene=Z,this.opaqueSortCompareFn=P,this.alphaTestSortCompareFn=c,this.transparentSortCompareFn=w}render(M,Z,P,x){if(M)return void M(this._opaqueSubMeshes,this._alphaTestSubMeshes,this._transparentSubMeshes,this._depthOnlySubMeshes);const c=this._scene.getEngine();0!==this._depthOnlySubMeshes.length&&(c.setColorWrite(!1),this._renderAlphaTest(this._depthOnlySubMeshes),c.setColorWrite(!0)),0!==this._opaqueSubMeshes.length&&this._renderOpaque(this._opaqueSubMeshes),0!==this._alphaTestSubMeshes.length&&this._renderAlphaTest(this._alphaTestSubMeshes);const w=c.getStencilBuffer();if(c.setStencilBuffer(!1),Z&&this._renderSprites(),P&&this._renderParticles(x),this.onBeforeTransparentRendering&&this.onBeforeTransparentRendering(),0!==this._transparentSubMeshes.length||this._scene.useOrderIndependentTransparency){if(c.setStencilBuffer(w),this._scene.useOrderIndependentTransparency){const M=this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);M.length&&this._renderTransparent(M)}else this._renderTransparent(this._transparentSubMeshes);c.setAlphaMode(0)}if(c.setStencilBuffer(!1),this._edgesRenderers.length){for(let M=0;M<this._edgesRenderers.length;M++)this._edgesRenderers.data[M].render();c.setAlphaMode(0)}c.setStencilBuffer(w)}_renderOpaqueSorted(M){w._RenderSorted(M,this._opaqueSortCompareFn,this._scene.activeCamera,!1)}_renderAlphaTestSorted(M){w._RenderSorted(M,this._alphaTestSortCompareFn,this._scene.activeCamera,!1)}_renderTransparentSorted(M){w._RenderSorted(M,this._transparentSortCompareFn,this._scene.activeCamera,!0)}static _RenderSorted(M,Z,P,x){let v,G=0;const mM=P?P.globalPosition:w._ZeroVector;if(x)for(;G<M.length;G++)v=M.data[G],v._alphaIndex=v.getMesh().alphaIndex,v._distanceToCamera=c.BZ.Distance(v.getBoundingInfo().boundingSphere.centerWorld,mM);const K=M.length===M.data.length?M.data:M.data.slice(0,M.length);Z&&K.sort(Z);const d=K[0].getMesh().DM();for(G=0;G<K.length;G++)if(v=K[G],!d._activeMeshesFrozenButKeepClipping||v.isInFrustum(d._frustumPlanes)){if(x){const M=v.EM();if(M&&M.needDepthPrePass){const Z=M.DM().getEngine();Z.setColorWrite(!1),Z.setAlphaMode(0),v.render(!1),Z.setColorWrite(!0)}}v.render(x)}}static defaultTransparentSortCompare(M,Z){return M._alphaIndex>Z._alphaIndex?1:M._alphaIndex<Z._alphaIndex?-1:w.backToFrontSortCompare(M,Z)}static backToFrontSortCompare(M,Z){return M._distanceToCamera<Z._distanceToCamera?1:M._distanceToCamera>Z._distanceToCamera?-1:0}static frontToBackSortCompare(M,Z){return M._distanceToCamera<Z._distanceToCamera?-1:M._distanceToCamera>Z._distanceToCamera?1:0}static PainterSortCompare(M,Z){const P=M.getMesh(),x=Z.getMesh();return P.material&&x.material?P.material.uniqueId-x.material.uniqueId:P.uniqueId-x.uniqueId}prepare(){this._opaqueSubMeshes.reset(),this._transparentSubMeshes.reset(),this._alphaTestSubMeshes.reset(),this._depthOnlySubMeshes.reset(),this._particleSystems.reset(),this.prepareSprites(),this._edgesRenderers.reset(),this._empty=!0}prepareSprites(){this._spriteManagers.reset()}dispose(){this._opaqueSubMeshes.dispose(),this._transparentSubMeshes.dispose(),this._alphaTestSubMeshes.dispose(),this._depthOnlySubMeshes.dispose(),this._particleSystems.dispose(),this._spriteManagers.dispose(),this._edgesRenderers.dispose()}dispatch(M,Z,P){void 0===Z&&(Z=M.getMesh()),void 0===P&&(P=M.EM()),null!==P&&void 0!==P&&(P.needAlphaBlendingForMesh(Z)?this._transparentSubMeshes.push(M):P.needAlphaTestingForMesh(Z)?(P.needDepthPrePass&&this._depthOnlySubMeshes.push(M),this._alphaTestSubMeshes.push(M)):(P.needDepthPrePass&&this._depthOnlySubMeshes.push(M),this._opaqueSubMeshes.push(M)),Z._renderingGroup=this,Z._edgesRenderer&&Z.isEnabled()&&Z.isVisible&&Z._edgesRenderer.isEnabled&&this._edgesRenderers.pushNoDuplicate(Z._edgesRenderer),this._empty=!1)}dispatchSprites(M){this._spriteManagers.push(M),this._empty=!1}dispatchParticles(M){this._particleSystems.push(M),this._empty=!1}_renderParticles(M){if(0===this._particleSystems.length)return;const Z=this._scene.activeCamera;this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);for(let P=0;P<this._particleSystems.length;P++){const x=this._particleSystems.data[P];if(0===(Z&&Z.layerMask&x.layerMask))continue;const c=x.xZ;c.position&&M&&-1===M.indexOf(c)||this._scene._activeParticles.addCount(x.render(),!1)}this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene)}_renderSprites(){if(!this._scene.spritesEnabled||0===this._spriteManagers.length)return;const M=this._scene.activeCamera;this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);for(let Z=0;Z<this._spriteManagers.length;Z++){const P=this._spriteManagers.data[Z];0!==(M&&M.layerMask&P.layerMask)&&P.render()}this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene)}}w._ZeroVector=c.BZ.Zero();class v{}class G{get maintainStateBetweenFrames(){return this._maintainStateBetweenFrames}set maintainStateBetweenFrames(M){M!==this._maintainStateBetweenFrames&&(this._maintainStateBetweenFrames=M,this._maintainStateBetweenFrames||this.restoreDispachedFlags())}restoreDispachedFlags(){for(const M of this._scene.meshes)if(M.Uc)for(const Z of M.Uc)Z._wasDispatched=!1;if(this._scene.spriteManagers)for(const M of this._scene.spriteManagers)M._wasDispatched=!1;for(const M of this._scene.SH)M._wasDispatched=!1}constructor(M){this._useSceneAutoClearSetup=!1,this._renderingGroups=new Array,this._autoClearDepthStencil={},this._customOpaqueSortCompareFn={},this._customAlphaTestSortCompareFn={},this._customTransparentSortCompareFn={},this._renderingGroupInfo=new v,this._maintainStateBetweenFrames=!1,this._scene=M;for(let Z=G.MIN_RENDERINGGROUPS;Z<G.MAX_RENDERINGGROUPS;Z++)this._autoClearDepthStencil[Z]={Bc:!0,depth:!0,Kc:!0}}getRenderingGroup(M){const Z=M||0;return this._prepareRenderingGroup(Z),this._renderingGroups[Z]}_clearDepthStencilBuffer(){let M=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],Z=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];this._depthStencilBufferAlreadyCleaned||(this._scene.getEngine().clear(null,!1,M,Z),this._depthStencilBufferAlreadyCleaned=!0)}render(M,Z,P,x){const c=this._renderingGroupInfo;if(c.nZ=this._scene,c.camera=this._scene.activeCamera,c.renderingManager=this,this._scene.spriteManagers&&x)for(let w=0;w<this._scene.spriteManagers.length;w++){const M=this._scene.spriteManagers[w];this.dispatchSprites(M)}for(let w=G.MIN_RENDERINGGROUPS;w<G.MAX_RENDERINGGROUPS;w++){this._depthStencilBufferAlreadyCleaned=w===G.MIN_RENDERINGGROUPS;const v=this._renderingGroups[w];if(!v||v._empty)continue;const mM=1<<w;if(c.renderingGroupId=w,this._scene.onBeforeRenderingGroupObservable.notifyObservers(c,mM),G.AUTOCLEAR){const M=this._useSceneAutoClearSetup?this._scene.getAutoClearDepthStencilSetup(w):this._autoClearDepthStencil[w];M&&M.Bc&&this._clearDepthStencilBuffer(M.depth,M.Kc)}for(const M of this._scene._beforeRenderingGroupDrawStage)M.action(w);v.render(M,x,P,Z);for(const M of this._scene._afterRenderingGroupDrawStage)M.action(w);this._scene.onAfterRenderingGroupObservable.notifyObservers(c,mM)}}reset(){if(!this.maintainStateBetweenFrames)for(let M=G.MIN_RENDERINGGROUPS;M<G.MAX_RENDERINGGROUPS;M++){const Z=this._renderingGroups[M];Z&&Z.prepare()}}resetSprites(){if(!this.maintainStateBetweenFrames)for(let M=G.MIN_RENDERINGGROUPS;M<G.MAX_RENDERINGGROUPS;M++){const Z=this._renderingGroups[M];Z&&Z.prepareSprites()}}dispose(){this.freeRenderingGroups(),this._renderingGroups.length=0,this._renderingGroupInfo=null}freeRenderingGroups(){for(let M=G.MIN_RENDERINGGROUPS;M<G.MAX_RENDERINGGROUPS;M++){const Z=this._renderingGroups[M];Z&&Z.dispose()}}_prepareRenderingGroup(M){void 0===this._renderingGroups[M]&&(this._renderingGroups[M]=new w(M,this._scene,this._customOpaqueSortCompareFn[M],this._customAlphaTestSortCompareFn[M],this._customTransparentSortCompareFn[M]))}dispatchSprites(M){this.maintainStateBetweenFrames&&M._wasDispatched||(M._wasDispatched=!0,this.getRenderingGroup(M.renderingGroupId).dispatchSprites(M))}dispatchParticles(M){this.maintainStateBetweenFrames&&M._wasDispatched||(M._wasDispatched=!0,this.getRenderingGroup(M.renderingGroupId).dispatchParticles(M))}dispatch(M,Z,P){void 0===Z&&(Z=M.getMesh()),this.maintainStateBetweenFrames&&M._wasDispatched||(M._wasDispatched=!0,this.getRenderingGroup(Z.renderingGroupId).dispatch(M,Z,P))}setRenderingOrder(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;if(this._customOpaqueSortCompareFn[M]=Z,this._customAlphaTestSortCompareFn[M]=P,this._customTransparentSortCompareFn[M]=x,this._renderingGroups[M]){const Z=this._renderingGroups[M];Z.opaqueSortCompareFn=this._customOpaqueSortCompareFn[M],Z.alphaTestSortCompareFn=this._customAlphaTestSortCompareFn[M],Z.transparentSortCompareFn=this._customTransparentSortCompareFn[M]}}setRenderingAutoClearDepthStencil(M,Z){let P=!(arguments.length>2&&void 0!==arguments[2])||arguments[2],x=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];this._autoClearDepthStencil[M]={Bc:Z,depth:P,Kc:x}}getAutoClearDepthStencilSetup(M){return this._autoClearDepthStencil[M]}}G.MAX_RENDERINGGROUPS=4,G.MIN_RENDERINGGROUPS=0,G.AUTOCLEAR=!0}}]);