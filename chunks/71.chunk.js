"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[71],{14038:(U,M,b)=>{b.r(M),b.d(M,{FlowGraphSetDelayBlock:()=>P});var a,A=b(12823),H=b(12775),W=b(474);!function(U){U[U.INIT=0]="INIT",U[U.STARTED=1]="STARTED",U[U.ENDED=2]="ENDED"}(a||(a={}));class y{constructor(U){this.onEachCountObservable=new W.e,this.onTimerAbortedObservable=new W.e,this.onTimerEndedObservable=new W.e,this.onStateChangedObservable=new W.e,this._observer=null,this._breakOnNextTick=!1,this._tick=U=>{const M=Date.now();this._timer=M-this._startTime;const b={startTime:this._startTime,currentTime:M,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:U},a=this._breakOnNextTick||this._breakCondition(b);a||this._timer>=this._timeToEnd?this._stop(b,a):this.onEachCountObservable.notifyObservers(b)},this._setState(0),this._contextObservable=U.contextObservable,this._observableParameters=U.observableParameters??{},this._breakCondition=U.breakCondition??(()=>!1),this._timeToEnd=U.timeout,U.onEnded&&this.onTimerEndedObservable.add(U.onEnded),U.hl&&this.onEachCountObservable.add(U.hl),U.onAborted&&this.onTimerAbortedObservable.add(U.onAborted)}set breakCondition(U){this._breakCondition=U}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=U,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(U){this._state=U,this.onStateChangedObservable.notifyObservers(this._state)}_stop(U){let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),M?this.onTimerAbortedObservable.notifyObservers(U):this.onTimerEndedObservable.notifyObservers(U)}}var O=b(497),e=b(609),x=b(12767);class P extends A.d{constructor(U){super(U),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",H.t),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",H.i,new x.e(-1))}_preparePendingTasks(U){const M=this.duration.getValue(U);if(M<0||isNaN(M)||!isFinite(M))return this._reportError(U,"Invalid duration in SetDelay block");if(U._getGlobalContextVariable("activeDelays",0)>=P.MaxParallelDelayCount)return this._reportError(U,"Max parallel delays reached");const b=U._getGlobalContextVariable("lastDelayIndex",-1),a=U._getExecutionVariable(this,"pendingDelays",[]),A=U.configuration.$e,H=new y({timeout:1e3*M,contextObservable:A.onBeforeRenderObservable,onEnded:()=>this._onEnded(H,U)});H.start();const W=b+1;this.lastDelayIndex.setValue(new x.e(W),U),U._setGlobalContextVariable("lastDelayIndex",W),a[W]=H,U._setExecutionVariable(this,"pendingDelays",a),this._updateGlobalTimers(U)}_cancelPendingTasks(U){const M=U._getExecutionVariable(this,"pendingDelays",[]);for(const b of M)null===b||void 0===b||b.dispose();U._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new x.e(-1),U),this._updateGlobalTimers(U)}_execute(U,M){M!==this.cancel?(this._preparePendingTasks(U),this.out._activateSignal(U)):this._cancelPendingTasks(U)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(U,M){const b=M._getExecutionVariable(this,"pendingDelays",[]),a=b.indexOf(U);-1!==a?b.splice(a,1):O.b.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),M._removePendingBlock(this),this.done._activateSignal(M),this._updateGlobalTimers(M)}_updateGlobalTimers(U){const M=U._getExecutionVariable(this,"pendingDelays",[]),b=U._getGlobalContextVariable("pendingDelays",[]);for(let a=0;a<M.length;a++){if(!M[a])continue;const U=M[a];b[a]&&b[a]!==U?O.b.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):b[a]=U}U._setGlobalContextVariable("pendingDelays",b)}}P.MaxParallelDelayCount=100,(0,e.i)("FlowGraphSetDelayBlock",P)}}]);