"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[71],{13798:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphSetDelayBlock:()=>j});var T,Y=c(12563),Z=c(12517),w=c(511);!function(W){W[W.INIT=0]="INIT",W[W.STARTED=1]="STARTED",W[W.ENDED=2]="ENDED"}(T||(T={}));class A{constructor(W){this.onEachCountObservable=new w.b,this.onTimerAbortedObservable=new w.b,this.onTimerEndedObservable=new w.b,this.onStateChangedObservable=new w.b,this._observer=null,this._breakOnNextTick=!1,this._tick=W=>{const F=Date.now();this._timer=F-this._startTime;const c={startTime:this._startTime,currentTime:F,deltaTime:this._timer,completeRate:this._timer/this._timeToEnd,payload:W},T=this._breakOnNextTick||this._breakCondition(c);T||this._timer>=this._timeToEnd?this._stop(c,T):this.onEachCountObservable.notifyObservers(c)},this._setState(0),this._contextObservable=W.contextObservable,this._observableParameters=W.observableParameters??{},this._breakCondition=W.breakCondition??(()=>!1),this._timeToEnd=W.timeout,W.onEnded&&this.onTimerEndedObservable.add(W.onEnded),W.al&&this.onEachCountObservable.add(W.al),W.onAborted&&this.onTimerAbortedObservable.add(W.onAborted)}set breakCondition(W){this._breakCondition=W}clearObservables(){this.onEachCountObservable.clear(),this.onTimerAbortedObservable.clear(),this.onTimerEndedObservable.clear(),this.onStateChangedObservable.clear()}start(){let W=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._timeToEnd;if(1===this._state)throw new Error("Timer already started. Please stop it before starting again");this._timeToEnd=W,this._startTime=Date.now(),this._timer=0,this._observer=this._contextObservable.add(this._tick,this._observableParameters.mask,this._observableParameters.insertFirst,this._observableParameters.scope),this._setState(1)}stop(){1===this._state&&(this._breakOnNextTick=!0)}dispose(){this._observer&&this._contextObservable.remove(this._observer),this.clearObservables()}_setState(W){this._state=W,this.onStateChangedObservable.notifyObservers(this._state)}_stop(W){let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this._contextObservable.remove(this._observer),this._setState(2),F?this.onTimerAbortedObservable.notifyObservers(W):this.onTimerEndedObservable.notifyObservers(W)}}var u=c(520),s=c(642),x=c(12512);class j extends Y.c{constructor(W){super(W),this.cancel=this._registerSignalInput("cancel"),this.duration=this.registerDataInput("duration",Z.n),this.lastDelayIndex=this.registerDataOutput("lastDelayIndex",Z.f,new x.c(-1))}_preparePendingTasks(W){const F=this.duration.getValue(W);if(F<0||isNaN(F)||!isFinite(F))return this._reportError(W,"Invalid duration in SetDelay block");if(W._getGlobalContextVariable("activeDelays",0)>=j.MaxParallelDelayCount)return this._reportError(W,"Max parallel delays reached");const c=W._getGlobalContextVariable("lastDelayIndex",-1),T=W._getExecutionVariable(this,"pendingDelays",[]),Y=W.configuration.rg,Z=new A({timeout:1e3*F,contextObservable:Y.onBeforeRenderObservable,onEnded:()=>this._onEnded(Z,W)});Z.start();const w=c+1;this.lastDelayIndex.setValue(new x.c(w),W),W._setGlobalContextVariable("lastDelayIndex",w),T[w]=Z,W._setExecutionVariable(this,"pendingDelays",T),this._updateGlobalTimers(W)}_cancelPendingTasks(W){const F=W._getExecutionVariable(this,"pendingDelays",[]);for(const c of F)null===c||void 0===c||c.dispose();W._deleteExecutionVariable(this,"pendingDelays"),this.lastDelayIndex.setValue(new x.c(-1),W),this._updateGlobalTimers(W)}_execute(W,F){F!==this.cancel?(this._preparePendingTasks(W),this.out._activateSignal(W)):this._cancelPendingTasks(W)}getClassName(){return"FlowGraphSetDelayBlock"}_onEnded(W,F){const c=F._getExecutionVariable(this,"pendingDelays",[]),T=c.indexOf(W);-1!==T?c.splice(T,1):u.e.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"),F._removePendingBlock(this),this.done._activateSignal(F),this._updateGlobalTimers(F)}_updateGlobalTimers(W){const F=W._getExecutionVariable(this,"pendingDelays",[]),c=W._getGlobalContextVariable("pendingDelays",[]);for(let T=0;T<F.length;T++){if(!F[T])continue;const W=F[T];c[T]&&c[T]!==W?u.e.Warn("FlowGraphTimerBlock: Timer ended but was not found in the running timers list"):c[T]=W}W._setGlobalContextVariable("pendingDelays",c)}}j.MaxParallelDelayCount=100,(0,s.h)("FlowGraphSetDelayBlock",j)}}]);