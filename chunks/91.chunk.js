"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14249:(t,q,S)=>{S.r(q),S.d(q,{FlowGraphWaitAllBlock:()=>r});var o=S(12981),B=S(622),z=S(12927),L=S(12922);class r extends o.d{constructor(t){super(t),this.config=t,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",z.h,new L.e(this.config.inputSignalCount||0));for(let q=0;q<this.config.inputSignalCount;q++)this.inFlows.push(this._registerSignalInput(`in_${q}`));this._unregisterSignalInput("in")}_getCurrentActivationState(t){const q=this._cachedActivationState;if(q.length=0,t._hasExecutionVariable(this,"activationState")){const S=t._getExecutionVariable(this,"activationState",[]);for(let t=0;t<S.length;t++)q.push(S[t])}else for(let S=0;S<this.config.inputSignalCount;S++)q.push(!1);return q}_execute(t,q){const S=this._getCurrentActivationState(t);if(q===this.reset)for(let o=0;o<this.config.inputSignalCount;o++)S[o]=!1;else{const t=this.inFlows.indexOf(q);t>=0&&(S[t]=!0)}if(this.remainingInputs.setValue(new L.e(S.filter((t=>!t)).length),t),t._setExecutionVariable(this,"activationState",S.slice()),S.includes(!1))q!==this.reset&&this.out._activateSignal(t);else{this.completed._activateSignal(t);for(let t=0;t<this.config.inputSignalCount;t++)S[t]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(t){super.serialize(t),t.config.inputFlows=this.config.inputSignalCount}}(0,B.c)("FlowGraphWaitAllBlock",r)}}]);