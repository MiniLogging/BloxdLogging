"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14289:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphWaitAllBlock:()=>F});var n=Q(12966),T=Q(591),L=Q(12908),e=Q(12904);class F extends n.d{constructor(v){super(v),this.config=v,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",L.h,new e.b(this.config.inputSignalCount||0));for(let d=0;d<this.config.inputSignalCount;d++)this.inFlows.push(this._registerSignalInput(`in_${d}`));this._unregisterSignalInput("in")}_getCurrentActivationState(v){const d=this._cachedActivationState;if(d.length=0,v._hasExecutionVariable(this,"activationState")){const Q=v._getExecutionVariable(this,"activationState",[]);for(let v=0;v<Q.length;v++)d.push(Q[v])}else for(let Q=0;Q<this.config.inputSignalCount;Q++)d.push(!1);return d}_execute(v,d){const Q=this._getCurrentActivationState(v);if(d===this.reset)for(let n=0;n<this.config.inputSignalCount;n++)Q[n]=!1;else{const v=this.inFlows.indexOf(d);v>=0&&(Q[v]=!0)}if(this.remainingInputs.setValue(new e.b(Q.filter((v=>!v)).length),v),v._setExecutionVariable(this,"activationState",Q.slice()),Q.includes(!1))d!==this.reset&&this.out._activateSignal(v);else{this.completed._activateSignal(v);for(let v=0;v<this.config.inputSignalCount;v++)Q[v]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(v){super.serialize(v),v.config.inputFlows=this.config.inputSignalCount}}(0,T.f)("FlowGraphWaitAllBlock",F)}}]);