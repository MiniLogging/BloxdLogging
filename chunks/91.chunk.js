"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14558:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphWaitAllBlock:()=>D});var k=H(13301),c=H(610),t=H(13246),A=H(13244);class D extends k.d{constructor(R){super(R),this.config=R,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",t.d,new A.e(this.config.inputSignalCount||0));for(let x=0;x<this.config.inputSignalCount;x++)this.inFlows.push(this._registerSignalInput(`in_${x}`));this._unregisterSignalInput("in")}_getCurrentActivationState(R){const x=this._cachedActivationState;if(x.length=0,R._hasExecutionVariable(this,"activationState")){const H=R._getExecutionVariable(this,"activationState",[]);for(let R=0;R<H.length;R++)x.push(H[R])}else for(let H=0;H<this.config.inputSignalCount;H++)x.push(!1);return x}_execute(R,x){const H=this._getCurrentActivationState(R);if(x===this.reset)for(let k=0;k<this.config.inputSignalCount;k++)H[k]=!1;else{const R=this.inFlows.indexOf(x);R>=0&&(H[R]=!0)}if(this.remainingInputs.setValue(new A.e(H.filter((R=>!R)).length),R),R._setExecutionVariable(this,"activationState",H.slice()),H.includes(!1))x!==this.reset&&this.out._activateSignal(R);else{this.completed._activateSignal(R);for(let R=0;R<this.config.inputSignalCount;R++)H[R]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(R){super.serialize(R),R.config.inputFlows=this.config.inputSignalCount}}(0,c.h)("FlowGraphWaitAllBlock",D)}}]);