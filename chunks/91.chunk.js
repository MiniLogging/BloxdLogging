"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14057:(U,W,l)=>{l.r(W),l.d(W,{FlowGraphWaitAllBlock:()=>B});var M=l(12766),t=l(655),L=l(12704),p=l(12699);class B extends M.e{constructor(U){super(U),this.config=U,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",L.k,new p.d(this.config.inputSignalCount||0));for(let W=0;W<this.config.inputSignalCount;W++)this.inFlows.push(this._registerSignalInput(`in_${W}`));this._unregisterSignalInput("in")}_getCurrentActivationState(U){const W=this._cachedActivationState;if(W.length=0,U._hasExecutionVariable(this,"activationState")){const l=U._getExecutionVariable(this,"activationState",[]);for(let U=0;U<l.length;U++)W.push(l[U])}else for(let l=0;l<this.config.inputSignalCount;l++)W.push(!1);return W}_execute(U,W){const l=this._getCurrentActivationState(U);if(W===this.reset)for(let M=0;M<this.config.inputSignalCount;M++)l[M]=!1;else{const U=this.inFlows.indexOf(W);U>=0&&(l[U]=!0)}if(this.remainingInputs.setValue(new p.d(l.filter((U=>!U)).length),U),U._setExecutionVariable(this,"activationState",l.slice()),l.includes(!1))W!==this.reset&&this.out._activateSignal(U);else{this.completed._activateSignal(U);for(let U=0;U<this.config.inputSignalCount;U++)l[U]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(U){super.serialize(U),U.config.inputFlows=this.config.inputSignalCount}}(0,t.f)("FlowGraphWaitAllBlock",B)}}]);