"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{13849:(L,j,P)=>{P.r(j),P.d(j,{FlowGraphWaitAllBlock:()=>u});var A=P(12554),R=P(606),o=P(12510),Y=P(12506);class u extends A.b{constructor(L){super(L),this.config=L,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",o.f,new Y.b(this.config.inputSignalCount||0));for(let j=0;j<this.config.inputSignalCount;j++)this.inFlows.push(this._registerSignalInput(`in_${j}`));this._unregisterSignalInput("in")}_getCurrentActivationState(L){const j=this._cachedActivationState;if(j.length=0,L._hasExecutionVariable(this,"activationState")){const P=L._getExecutionVariable(this,"activationState",[]);for(let L=0;L<P.length;L++)j.push(P[L])}else for(let P=0;P<this.config.inputSignalCount;P++)j.push(!1);return j}_execute(L,j){const P=this._getCurrentActivationState(L);if(j===this.reset)for(let A=0;A<this.config.inputSignalCount;A++)P[A]=!1;else{const L=this.inFlows.indexOf(j);L>=0&&(P[L]=!0)}if(this.remainingInputs.setValue(new Y.b(P.filter((L=>!L)).length),L),L._setExecutionVariable(this,"activationState",P.slice()),P.includes(!1))j!==this.reset&&this.out._activateSignal(L);else{this.completed._activateSignal(L);for(let L=0;L<this.config.inputSignalCount;L++)P[L]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(L){super.serialize(L),L.config.inputFlows=this.config.inputSignalCount}}(0,R.h)("FlowGraphWaitAllBlock",u)}}]);