"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14147:(Z,U,n)=>{n.r(U),n.d(U,{FlowGraphWaitAllBlock:()=>V});var i=n(12861),B=n(633),l=n(12826),H=n(12817);class V extends i.e{constructor(Z){super(Z),this.config=Z,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",l.g,new H.d(this.config.inputSignalCount||0));for(let U=0;U<this.config.inputSignalCount;U++)this.inFlows.push(this._registerSignalInput(`in_${U}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Z){const U=this._cachedActivationState;if(U.length=0,Z._hasExecutionVariable(this,"activationState")){const n=Z._getExecutionVariable(this,"activationState",[]);for(let Z=0;Z<n.length;Z++)U.push(n[Z])}else for(let n=0;n<this.config.inputSignalCount;n++)U.push(!1);return U}_execute(Z,U){const n=this._getCurrentActivationState(Z);if(U===this.reset)for(let i=0;i<this.config.inputSignalCount;i++)n[i]=!1;else{const Z=this.inFlows.indexOf(U);Z>=0&&(n[Z]=!0)}if(this.remainingInputs.setValue(new H.d(n.filter((Z=>!Z)).length),Z),Z._setExecutionVariable(this,"activationState",n.slice()),n.includes(!1))U!==this.reset&&this.out._activateSignal(Z);else{this.completed._activateSignal(Z);for(let Z=0;Z<this.config.inputSignalCount;Z++)n[Z]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Z){super.serialize(Z),Z.config.inputFlows=this.config.inputSignalCount}}(0,B.g)("FlowGraphWaitAllBlock",V)}}]);