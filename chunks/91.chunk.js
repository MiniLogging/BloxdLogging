"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14128:(c,b,A)=>{A.r(b),A.d(b,{FlowGraphWaitAllBlock:()=>s});var o=A(12813),t=A(633),n=A(12763),h=A(12760);class s extends o.d{constructor(c){super(c),this.config=c,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",n.g,new h.d(this.config.inputSignalCount||0));for(let b=0;b<this.config.inputSignalCount;b++)this.inFlows.push(this._registerSignalInput(`in_${b}`));this._unregisterSignalInput("in")}_getCurrentActivationState(c){const b=this._cachedActivationState;if(b.length=0,c._hasExecutionVariable(this,"activationState")){const A=c._getExecutionVariable(this,"activationState",[]);for(let c=0;c<A.length;c++)b.push(A[c])}else for(let A=0;A<this.config.inputSignalCount;A++)b.push(!1);return b}_execute(c,b){const A=this._getCurrentActivationState(c);if(b===this.reset)for(let o=0;o<this.config.inputSignalCount;o++)A[o]=!1;else{const c=this.inFlows.indexOf(b);c>=0&&(A[c]=!0)}if(this.remainingInputs.setValue(new h.d(A.filter((c=>!c)).length),c),c._setExecutionVariable(this,"activationState",A.slice()),A.includes(!1))b!==this.reset&&this.out._activateSignal(c);else{this.completed._activateSignal(c);for(let c=0;c<this.config.inputSignalCount;c++)A[c]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(c){super.serialize(c),c.config.inputFlows=this.config.inputSignalCount}}(0,t.d)("FlowGraphWaitAllBlock",s)}}]);