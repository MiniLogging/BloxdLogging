"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[91],{14414:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphWaitAllBlock:()=>O});var l=C(13120),h=C(620),M=C(13063),f=C(13060);class O extends l.c{constructor(Q){super(Q),this.config=Q,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",M.f,new f.d(this.config.inputSignalCount||0));for(let X=0;X<this.config.inputSignalCount;X++)this.inFlows.push(this._registerSignalInput(`in_${X}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Q){const X=this._cachedActivationState;if(X.length=0,Q._hasExecutionVariable(this,"activationState")){const C=Q._getExecutionVariable(this,"activationState",[]);for(let Q=0;Q<C.length;Q++)X.push(C[Q])}else for(let C=0;C<this.config.inputSignalCount;C++)X.push(!1);return X}_execute(Q,X){const C=this._getCurrentActivationState(Q);if(X===this.reset)for(let l=0;l<this.config.inputSignalCount;l++)C[l]=!1;else{const Q=this.inFlows.indexOf(X);Q>=0&&(C[Q]=!0)}if(this.remainingInputs.setValue(new f.d(C.filter((Q=>!Q)).length),Q),Q._setExecutionVariable(this,"activationState",C.slice()),C.includes(!1))X!==this.reset&&this.out._activateSignal(Q);else{this.completed._activateSignal(Q);for(let Q=0;Q<this.config.inputSignalCount;Q++)C[Q]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Q){super.serialize(Q),Q.config.inputFlows=this.config.inputSignalCount}}(0,h.g)("FlowGraphWaitAllBlock",O)}}]);