"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[127],{16687:(P,a,R)=>{R.r(a),R.d(a,{EasingFunctionType:()=>S,FlowGraphEasingBlock:()=>U});var S,A=R(15059),Z=R(14549),p=R(14524),j=R(12376);!function(P){P[P.CircleEase=0]="CircleEase",P[P.BackEase=1]="BackEase",P[P.BounceEase=2]="BounceEase",P[P.CubicEase=3]="CubicEase",P[P.ElasticEase=4]="ElasticEase",P[P.ExponentialEase=5]="ExponentialEase",P[P.PowerEase=6]="PowerEase",P[P.QuadraticEase=7]="QuadraticEase",P[P.QuarticEase=8]="QuarticEase",P[P.QuinticEase=9]="QuinticEase",P[P.SineEase=10]="SineEase",P[P.BezierCurveEase=11]="BezierCurveEase"}(S||(S={}));class U extends Z.e{constructor(P){super(P),this.config=P,this._easingFunctions={},this.type=this.registerDataInput("type",p.c,11),this.mode=this.registerDataInput("mode",p.p,0),this.parameters=this.registerDataInput("parameters",p.c,[1,0,0,1]),this.easingFunction=this.registerDataOutput("easingFunction",p.c)}_updateOutputs(P){const a=this.type.getValue(P),R=this.mode.getValue(P),S=this.parameters.getValue(P);if(void 0===a||void 0===R)return;const Z=`${a}-${R}-${S.join("-")}`;if(!this._easingFunctions[Z]){const P=function(P){for(var a=arguments.length,R=new Array(a>1?a-1:0),S=1;S<a;S++)R[S-1]=arguments[S];switch(P){case 11:return new A.h(...R);case 0:return new A.m;case 1:return new A.e(...R);case 2:return new A.i(...R);case 3:return new A.q;case 4:return new A.v(...R);case 5:return new A.y(...R);default:throw new Error("Easing type not yet implemented")}}(a,...S);P.setEasingMode(R),this._easingFunctions[Z]=P}this.easingFunction.setValue(this._easingFunctions[Z],P)}getClassName(){return"FlowGraphEasingBlock"}}(0,j.d)("FlowGraphEasingBlock",U)}}]);