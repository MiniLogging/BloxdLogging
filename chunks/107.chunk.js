"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[107],{15692:(E,U,g)=>{g.r(U),g.d(U,{FlowGraphWaitAllBlock:()=>u});var N=g(14100),L=g(12292),D=g(14058),S=g(14050);class u extends N.e{constructor(E){super(E),this.config=E,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",D.j,new S.c(this.config.inputSignalCount||0));for(let U=0;U<this.config.inputSignalCount;U++)this.inFlows.push(this._registerSignalInput(`in_${U}`));this._unregisterSignalInput("in")}_getCurrentActivationState(E){const U=this._cachedActivationState;if(U.length=0,E._hasExecutionVariable(this,"activationState")){const g=E._getExecutionVariable(this,"activationState",[]);for(let E=0;E<g.length;E++)U.push(g[E])}else for(let g=0;g<this.config.inputSignalCount;g++)U.push(!1);return U}_execute(E,U){const g=this._getCurrentActivationState(E);if(U===this.reset)for(let N=0;N<this.config.inputSignalCount;N++)g[N]=!1;else{const E=this.inFlows.indexOf(U);E>=0&&(g[E]=!0)}if(this.remainingInputs.setValue(new S.c(g.filter((E=>!E)).length),E),E._setExecutionVariable(this,"activationState",g.slice()),g.includes(!1))U!==this.reset&&this.out._activateSignal(E);else{this.completed._activateSignal(E);for(let E=0;E<this.config.inputSignalCount;E++)g[E]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(E){super.serialize(E),E.config.inputFlows=this.config.inputSignalCount}}(0,L.f)("FlowGraphWaitAllBlock",u)}}]);