"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14406:(g,w,q)=>{q.r(w),q.d(w,{FlowGraphWaitAllBlock:()=>i});var R=q(12879),o=q(11128),r=q(12836),S=q(12828);class i extends R.c{constructor(g){super(g),this.config=g,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",r.l,new S.b(this.config.inputSignalCount||0));for(let w=0;w<this.config.inputSignalCount;w++)this.inFlows.push(this._registerSignalInput(`in_${w}`));this._unregisterSignalInput("in")}_getCurrentActivationState(g){const w=this._cachedActivationState;if(w.length=0,g._hasExecutionVariable(this,"activationState")){const q=g._getExecutionVariable(this,"activationState",[]);for(let g=0;g<q.length;g++)w.push(q[g])}else for(let q=0;q<this.config.inputSignalCount;q++)w.push(!1);return w}_execute(g,w){const q=this._getCurrentActivationState(g);if(w===this.reset)for(let R=0;R<this.config.inputSignalCount;R++)q[R]=!1;else{const g=this.inFlows.indexOf(w);g>=0&&(q[g]=!0)}if(this.remainingInputs.setValue(new S.b(q.filter((g=>!g)).length),g),g._setExecutionVariable(this,"activationState",q.slice()),q.includes(!1))w!==this.reset&&this.out._activateSignal(g);else{this.completed._activateSignal(g);for(let g=0;g<this.config.inputSignalCount;g++)q[g]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(g){super.serialize(g),g.config.inputFlows=this.config.inputSignalCount}}(0,o.g)("FlowGraphWaitAllBlock",i)}}]);