"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14567:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphWaitAllBlock:()=>j});var u=F(13007),G=F(11136),f=F(12954),Y=F(12949);class j extends u.e{constructor(Z){super(Z),this.config=Z,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",f.g,new Y.d(this.config.inputSignalCount||0));for(let x=0;x<this.config.inputSignalCount;x++)this.inFlows.push(this._registerSignalInput(`in_${x}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Z){const x=this._cachedActivationState;if(x.length=0,Z._hasExecutionVariable(this,"activationState")){const F=Z._getExecutionVariable(this,"activationState",[]);for(let Z=0;Z<F.length;Z++)x.push(F[Z])}else for(let F=0;F<this.config.inputSignalCount;F++)x.push(!1);return x}_execute(Z,x){const F=this._getCurrentActivationState(Z);if(x===this.reset)for(let u=0;u<this.config.inputSignalCount;u++)F[u]=!1;else{const Z=this.inFlows.indexOf(x);Z>=0&&(F[Z]=!0)}if(this.remainingInputs.setValue(new Y.d(F.filter((Z=>!Z)).length),Z),Z._setExecutionVariable(this,"activationState",F.slice()),F.includes(!1))x!==this.reset&&this.out._activateSignal(Z);else{this.completed._activateSignal(Z);for(let Z=0;Z<this.config.inputSignalCount;Z++)F[Z]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Z){super.serialize(Z),Z.config.inputFlows=this.config.inputSignalCount}}(0,G.g)("FlowGraphWaitAllBlock",j)}}]);