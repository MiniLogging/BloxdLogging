"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[107],{16213:(Y,b,C)=>{C.r(b),C.d(b,{FlowGraphWaitAllBlock:()=>B});var R=C(14466),q=C(12790),A=C(14424),E=C(14420);class B extends R.d{constructor(Y){super(Y),this.config=Y,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",A.i,new E.d(this.config.inputSignalCount||0));for(let b=0;b<this.config.inputSignalCount;b++)this.inFlows.push(this._registerSignalInput(`in_${b}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Y){const b=this._cachedActivationState;if(b.length=0,Y._hasExecutionVariable(this,"activationState")){const C=Y._getExecutionVariable(this,"activationState",[]);for(let Y=0;Y<C.length;Y++)b.push(C[Y])}else for(let C=0;C<this.config.inputSignalCount;C++)b.push(!1);return b}_execute(Y,b){const C=this._getCurrentActivationState(Y);if(b===this.reset)for(let R=0;R<this.config.inputSignalCount;R++)C[R]=!1;else{const Y=this.inFlows.indexOf(b);Y>=0&&(C[Y]=!0)}if(this.remainingInputs.setValue(new E.d(C.filter((Y=>!Y)).length),Y),Y._setExecutionVariable(this,"activationState",C.slice()),C.includes(!1))b!==this.reset&&this.out._activateSignal(Y);else{this.completed._activateSignal(Y);for(let Y=0;Y<this.config.inputSignalCount;Y++)C[Y]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Y){super.serialize(Y),Y.config.inputFlows=this.config.inputSignalCount}}(0,q.g)("FlowGraphWaitAllBlock",B)}}]);