"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14507:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphWaitAllBlock:()=>L});var M=C(12952),x=C(11149),y=C(12901),f=C(12895);class L extends M.b{constructor(B){super(B),this.config=B,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",y.f,new f.b(this.config.inputSignalCount||0));for(let I=0;I<this.config.inputSignalCount;I++)this.inFlows.push(this._registerSignalInput(`in_${I}`));this._unregisterSignalInput("in")}_getCurrentActivationState(B){const I=this._cachedActivationState;if(I.length=0,B._hasExecutionVariable(this,"activationState")){const C=B._getExecutionVariable(this,"activationState",[]);for(let B=0;B<C.length;B++)I.push(C[B])}else for(let C=0;C<this.config.inputSignalCount;C++)I.push(!1);return I}_execute(B,I){const C=this._getCurrentActivationState(B);if(I===this.reset)for(let M=0;M<this.config.inputSignalCount;M++)C[M]=!1;else{const B=this.inFlows.indexOf(I);B>=0&&(C[B]=!0)}if(this.remainingInputs.setValue(new f.b(C.filter((B=>!B)).length),B),B._setExecutionVariable(this,"activationState",C.slice()),C.includes(!1))I!==this.reset&&this.out._activateSignal(B);else{this.completed._activateSignal(B);for(let B=0;B<this.config.inputSignalCount;B++)C[B]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(B){super.serialize(B),B.config.inputFlows=this.config.inputSignalCount}}(0,x.h)("FlowGraphWaitAllBlock",L)}}]);