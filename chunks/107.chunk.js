"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[107],{14907:(U,X,b)=>{b.r(X),b.d(X,{FlowGraphWaitAllBlock:()=>z});var F=b(13333),E=b(11551),w=b(13281),Q=b(13276);class z extends F.d{constructor(U){super(U),this.config=U,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",w.h,new Q.e(this.config.inputSignalCount||0));for(let X=0;X<this.config.inputSignalCount;X++)this.inFlows.push(this._registerSignalInput(`in_${X}`));this._unregisterSignalInput("in")}_getCurrentActivationState(U){const X=this._cachedActivationState;if(X.length=0,U._hasExecutionVariable(this,"activationState")){const b=U._getExecutionVariable(this,"activationState",[]);for(let U=0;U<b.length;U++)X.push(b[U])}else for(let b=0;b<this.config.inputSignalCount;b++)X.push(!1);return X}_execute(U,X){const b=this._getCurrentActivationState(U);if(X===this.reset)for(let F=0;F<this.config.inputSignalCount;F++)b[F]=!1;else{const U=this.inFlows.indexOf(X);U>=0&&(b[U]=!0)}if(this.remainingInputs.setValue(new Q.e(b.filter((U=>!U)).length),U),U._setExecutionVariable(this,"activationState",b.slice()),b.includes(!1))X!==this.reset&&this.out._activateSignal(U);else{this.completed._activateSignal(U);for(let U=0;U<this.config.inputSignalCount;U++)b[U]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(U){super.serialize(U),U.config.inputFlows=this.config.inputSignalCount}}(0,E.f)("FlowGraphWaitAllBlock",z)}}]);