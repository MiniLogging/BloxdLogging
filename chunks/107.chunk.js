"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[107],{15962:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphWaitAllBlock:()=>a});var mL=x(14401),p=x(12547),G=x(14348),F=x(14343);class a extends mL.d{constructor(L){super(L),this.config=L,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",G.i,new F.b(this.config.inputSignalCount||0));for(let U=0;U<this.config.inputSignalCount;U++)this.inFlows.push(this._registerSignalInput(`in_${U}`));this._unregisterSignalInput("in")}_getCurrentActivationState(L){const U=this._cachedActivationState;if(U.length=0,L._hasExecutionVariable(this,"activationState")){const x=L._getExecutionVariable(this,"activationState",[]);for(let L=0;L<x.length;L++)U.push(x[L])}else for(let x=0;x<this.config.inputSignalCount;x++)U.push(!1);return U}_execute(L,U){const x=this._getCurrentActivationState(L);if(U===this.reset)for(let mL=0;mL<this.config.inputSignalCount;mL++)x[mL]=!1;else{const L=this.inFlows.indexOf(U);L>=0&&(x[L]=!0)}if(this.remainingInputs.setValue(new F.b(x.filter((L=>!L)).length),L),L._setExecutionVariable(this,"activationState",x.slice()),x.includes(!1))U!==this.reset&&this.out._activateSignal(L);else{this.completed._activateSignal(L);for(let L=0;L<this.config.inputSignalCount;L++)x[L]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(L){super.serialize(L),L.config.inputFlows=this.config.inputSignalCount}}(0,p.d)("FlowGraphWaitAllBlock",a)}}]);