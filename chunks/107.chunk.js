"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[107],{14491:(k,h,o)=>{o.r(h),o.d(h,{FlowGraphWaitAllBlock:()=>J});var x=o(12986),I=o(11199),q=o(12936),Y=o(12928);class J extends x.e{constructor(k){super(k),this.config=k,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",q.j,new Y.c(this.config.inputSignalCount||0));for(let h=0;h<this.config.inputSignalCount;h++)this.inFlows.push(this._registerSignalInput(`in_${h}`));this._unregisterSignalInput("in")}_getCurrentActivationState(k){const h=this._cachedActivationState;if(h.length=0,k._hasExecutionVariable(this,"activationState")){const o=k._getExecutionVariable(this,"activationState",[]);for(let k=0;k<o.length;k++)h.push(o[k])}else for(let o=0;o<this.config.inputSignalCount;o++)h.push(!1);return h}_execute(k,h){const o=this._getCurrentActivationState(k);if(h===this.reset)for(let x=0;x<this.config.inputSignalCount;x++)o[x]=!1;else{const k=this.inFlows.indexOf(h);k>=0&&(o[k]=!0)}if(this.remainingInputs.setValue(new Y.c(o.filter((k=>!k)).length),k),k._setExecutionVariable(this,"activationState",o.slice()),o.includes(!1))h!==this.reset&&this.out._activateSignal(k);else{this.completed._activateSignal(k);for(let k=0;k<this.config.inputSignalCount;k++)o[k]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(k){super.serialize(k),k.config.inputFlows=this.config.inputSignalCount}}(0,I.g)("FlowGraphWaitAllBlock",J)}}]);