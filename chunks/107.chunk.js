"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[107],{14928:(F,P,f)=>{f.r(P),f.d(P,{FlowGraphWaitAllBlock:()=>A});var c=f(13312),N=f(11587),q=f(13265),H=f(13258);class A extends c.d{constructor(F){super(F),this.config=F,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",q.h,new H.b(this.config.inputSignalCount||0));for(let P=0;P<this.config.inputSignalCount;P++)this.inFlows.push(this._registerSignalInput(`in_${P}`));this._unregisterSignalInput("in")}_getCurrentActivationState(F){const P=this._cachedActivationState;if(P.length=0,F._hasExecutionVariable(this,"activationState")){const f=F._getExecutionVariable(this,"activationState",[]);for(let F=0;F<f.length;F++)P.push(f[F])}else for(let f=0;f<this.config.inputSignalCount;f++)P.push(!1);return P}_execute(F,P){const f=this._getCurrentActivationState(F);if(P===this.reset)for(let c=0;c<this.config.inputSignalCount;c++)f[c]=!1;else{const F=this.inFlows.indexOf(P);F>=0&&(f[F]=!0)}if(this.remainingInputs.setValue(new H.b(f.filter((F=>!F)).length),F),F._setExecutionVariable(this,"activationState",f.slice()),f.includes(!1))P!==this.reset&&this.out._activateSignal(F);else{this.completed._activateSignal(F);for(let F=0;F<this.config.inputSignalCount;F++)f[F]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(F){super.serialize(F),F.config.inputFlows=this.config.inputSignalCount}}(0,N.f)("FlowGraphWaitAllBlock",A)}}]);