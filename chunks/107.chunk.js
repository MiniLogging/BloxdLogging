"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[107],{14369:(P,e,n)=>{n.r(e),n.d(e,{FlowGraphWaitAllBlock:()=>m});var H=n(12860),S=n(11096),p=n(12819),k=n(12812);class m extends H.c{constructor(P){super(P),this.config=P,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",p.e,new k.e(this.config.inputSignalCount||0));for(let e=0;e<this.config.inputSignalCount;e++)this.inFlows.push(this._registerSignalInput(`in_${e}`));this._unregisterSignalInput("in")}_getCurrentActivationState(P){const e=this._cachedActivationState;if(e.length=0,P._hasExecutionVariable(this,"activationState")){const n=P._getExecutionVariable(this,"activationState",[]);for(let P=0;P<n.length;P++)e.push(n[P])}else for(let n=0;n<this.config.inputSignalCount;n++)e.push(!1);return e}_execute(P,e){const n=this._getCurrentActivationState(P);if(e===this.reset)for(let H=0;H<this.config.inputSignalCount;H++)n[H]=!1;else{const P=this.inFlows.indexOf(e);P>=0&&(n[P]=!0)}if(this.remainingInputs.setValue(new k.e(n.filter((P=>!P)).length),P),P._setExecutionVariable(this,"activationState",n.slice()),n.includes(!1))e!==this.reset&&this.out._activateSignal(P);else{this.completed._activateSignal(P);for(let P=0;P<this.config.inputSignalCount;P++)n[P]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(P){super.serialize(P),P.config.inputFlows=this.config.inputSignalCount}}(0,S.h)("FlowGraphWaitAllBlock",m)}}]);