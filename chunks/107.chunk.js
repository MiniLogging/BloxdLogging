"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[107],{14671:(B,E,v)=>{v.r(E),v.d(E,{FlowGraphWaitAllBlock:()=>S});var z=v(13142),o=v(11345),q=v(13102),c=v(13099);class S extends z.d{constructor(B){super(B),this.config=B,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",q.g,new c.d(this.config.inputSignalCount||0));for(let E=0;E<this.config.inputSignalCount;E++)this.inFlows.push(this._registerSignalInput(`in_${E}`));this._unregisterSignalInput("in")}_getCurrentActivationState(B){const E=this._cachedActivationState;if(E.length=0,B._hasExecutionVariable(this,"activationState")){const v=B._getExecutionVariable(this,"activationState",[]);for(let B=0;B<v.length;B++)E.push(v[B])}else for(let v=0;v<this.config.inputSignalCount;v++)E.push(!1);return E}_execute(B,E){const v=this._getCurrentActivationState(B);if(E===this.reset)for(let z=0;z<this.config.inputSignalCount;z++)v[z]=!1;else{const B=this.inFlows.indexOf(E);B>=0&&(v[B]=!0)}if(this.remainingInputs.setValue(new c.d(v.filter((B=>!B)).length),B),B._setExecutionVariable(this,"activationState",v.slice()),v.includes(!1))E!==this.reset&&this.out._activateSignal(B);else{this.completed._activateSignal(B);for(let B=0;B<this.config.inputSignalCount;B++)v[B]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(B){super.serialize(B),B.config.inputFlows=this.config.inputSignalCount}}(0,o.f)("FlowGraphWaitAllBlock",S)}}]);