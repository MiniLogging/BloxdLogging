"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[107],{16277:(Y,c,h)=>{h.r(c),h.d(c,{FlowGraphWaitAllBlock:()=>b});var C=h(14506),E=h(12825),N=h(14459),Q=h(14450);class b extends C.c{constructor(Y){super(Y),this.config=Y,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",N.h,new Q.c(this.config.inputSignalCount||0));for(let c=0;c<this.config.inputSignalCount;c++)this.inFlows.push(this._registerSignalInput(`in_${c}`));this._unregisterSignalInput("in")}_getCurrentActivationState(Y){const c=this._cachedActivationState;if(c.length=0,Y._hasExecutionVariable(this,"activationState")){const h=Y._getExecutionVariable(this,"activationState",[]);for(let Y=0;Y<h.length;Y++)c.push(h[Y])}else for(let h=0;h<this.config.inputSignalCount;h++)c.push(!1);return c}_execute(Y,c){const h=this._getCurrentActivationState(Y);if(c===this.reset)for(let C=0;C<this.config.inputSignalCount;C++)h[C]=!1;else{const Y=this.inFlows.indexOf(c);Y>=0&&(h[Y]=!0)}if(this.remainingInputs.setValue(new Q.c(h.filter((Y=>!Y)).length),Y),Y._setExecutionVariable(this,"activationState",h.slice()),h.includes(!1))c!==this.reset&&this.out._activateSignal(Y);else{this.completed._activateSignal(Y);for(let Y=0;Y<this.config.inputSignalCount;Y++)h[Y]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(Y){super.serialize(Y),Y.config.inputFlows=this.config.inputSignalCount}}(0,E.e)("FlowGraphWaitAllBlock",b)}}]);