"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[107],{15628:(N,p,T)=>{T.r(p),T.d(p,{FlowGraphWaitAllBlock:()=>X});var A=T(14129),a=T(12331),C=T(14082),U=T(14079);class X extends A.d{constructor(N){super(N),this.config=N,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",C.h,new U.c(this.config.inputSignalCount||0));for(let p=0;p<this.config.inputSignalCount;p++)this.inFlows.push(this._registerSignalInput(`in_${p}`));this._unregisterSignalInput("in")}_getCurrentActivationState(N){const p=this._cachedActivationState;if(p.length=0,N._hasExecutionVariable(this,"activationState")){const T=N._getExecutionVariable(this,"activationState",[]);for(let N=0;N<T.length;N++)p.push(T[N])}else for(let T=0;T<this.config.inputSignalCount;T++)p.push(!1);return p}_execute(N,p){const T=this._getCurrentActivationState(N);if(p===this.reset)for(let A=0;A<this.config.inputSignalCount;A++)T[A]=!1;else{const N=this.inFlows.indexOf(p);N>=0&&(T[N]=!0)}if(this.remainingInputs.setValue(new U.c(T.filter((N=>!N)).length),N),N._setExecutionVariable(this,"activationState",T.slice()),T.includes(!1))p!==this.reset&&this.out._activateSignal(N);else{this.completed._activateSignal(N);for(let N=0;N<this.config.inputSignalCount;N++)T[N]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(N){super.serialize(N),N.config.inputFlows=this.config.inputSignalCount}}(0,a.d)("FlowGraphWaitAllBlock",X)}}]);