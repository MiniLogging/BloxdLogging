"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[107],{14480:(R,J,B)=>{B.r(J),B.d(J,{FlowGraphWaitAllBlock:()=>r});var Q=B(12947),h=B(11142),y=B(12894),N=B(12892);class r extends Q.d{constructor(R){super(R),this.config=R,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",y.k,new N.d(this.config.inputSignalCount||0));for(let J=0;J<this.config.inputSignalCount;J++)this.inFlows.push(this._registerSignalInput(`in_${J}`));this._unregisterSignalInput("in")}_getCurrentActivationState(R){const J=this._cachedActivationState;if(J.length=0,R._hasExecutionVariable(this,"activationState")){const B=R._getExecutionVariable(this,"activationState",[]);for(let R=0;R<B.length;R++)J.push(B[R])}else for(let B=0;B<this.config.inputSignalCount;B++)J.push(!1);return J}_execute(R,J){const B=this._getCurrentActivationState(R);if(J===this.reset)for(let Q=0;Q<this.config.inputSignalCount;Q++)B[Q]=!1;else{const R=this.inFlows.indexOf(J);R>=0&&(B[R]=!0)}if(this.remainingInputs.setValue(new N.d(B.filter((R=>!R)).length),R),R._setExecutionVariable(this,"activationState",B.slice()),B.includes(!1))J!==this.reset&&this.out._activateSignal(R);else{this.completed._activateSignal(R);for(let R=0;R<this.config.inputSignalCount;R++)B[R]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(R){super.serialize(R),R.config.inputFlows=this.config.inputSignalCount}}(0,h.h)("FlowGraphWaitAllBlock",r)}}]);