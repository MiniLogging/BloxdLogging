"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14512:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphWaitAllBlock:()=>o});var C=Y(12974),q=Y(11134),m=Y(12917),L=Y(12908);class o extends C.d{constructor(P){super(P),this.config=P,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",m.f,new L.c(this.config.inputSignalCount||0));for(let f=0;f<this.config.inputSignalCount;f++)this.inFlows.push(this._registerSignalInput(`in_${f}`));this._unregisterSignalInput("in")}_getCurrentActivationState(P){const f=this._cachedActivationState;if(f.length=0,P._hasExecutionVariable(this,"activationState")){const Y=P._getExecutionVariable(this,"activationState",[]);for(let P=0;P<Y.length;P++)f.push(Y[P])}else for(let Y=0;Y<this.config.inputSignalCount;Y++)f.push(!1);return f}_execute(P,f){const Y=this._getCurrentActivationState(P);if(f===this.reset)for(let C=0;C<this.config.inputSignalCount;C++)Y[C]=!1;else{const P=this.inFlows.indexOf(f);P>=0&&(Y[P]=!0)}if(this.remainingInputs.setValue(new L.c(Y.filter((P=>!P)).length),P),P._setExecutionVariable(this,"activationState",Y.slice()),Y.includes(!1))f!==this.reset&&this.out._activateSignal(P);else{this.completed._activateSignal(P);for(let P=0;P<this.config.inputSignalCount;P++)Y[P]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(P){super.serialize(P),P.config.inputFlows=this.config.inputSignalCount}}(0,q.d)("FlowGraphWaitAllBlock",o)}}]);