"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[107],{15495:(t,U,y)=>{y.r(U),y.d(U,{FlowGraphWaitAllBlock:()=>X});var I=y(13899),r=y(12338),Y=y(13845),mt=y(13842);class X extends I.e{constructor(t){super(t),this.config=t,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",Y.j,new mt.c(this.config.inputSignalCount||0));for(let U=0;U<this.config.inputSignalCount;U++)this.inFlows.push(this._registerSignalInput(`in_${U}`));this._unregisterSignalInput("in")}_getCurrentActivationState(t){const U=this._cachedActivationState;if(U.length=0,t._hasExecutionVariable(this,"activationState")){const y=t._getExecutionVariable(this,"activationState",[]);for(let t=0;t<y.length;t++)U.push(y[t])}else for(let y=0;y<this.config.inputSignalCount;y++)U.push(!1);return U}_execute(t,U){const y=this._getCurrentActivationState(t);if(U===this.reset)for(let I=0;I<this.config.inputSignalCount;I++)y[I]=!1;else{const t=this.inFlows.indexOf(U);t>=0&&(y[t]=!0)}if(this.remainingInputs.setValue(new mt.c(y.filter((t=>!t)).length),t),t._setExecutionVariable(this,"activationState",y.slice()),y.includes(!1))U!==this.reset&&this.out._activateSignal(t);else{this.completed._activateSignal(t);for(let t=0;t<this.config.inputSignalCount;t++)y[t]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(t){super.serialize(t),t.config.inputFlows=this.config.inputSignalCount}}(0,r.f)("FlowGraphWaitAllBlock",X)}}]);