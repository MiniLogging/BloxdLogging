"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[107],{14598:(H,O,S)=>{S.r(O),S.d(O,{FlowGraphWaitAllBlock:()=>U});var t=S(13090),q=S(11262),p=S(13035),G=S(13030);class U extends t.d{constructor(H){super(H),this.config=H,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",p.l,new G.d(this.config.inputSignalCount||0));for(let O=0;O<this.config.inputSignalCount;O++)this.inFlows.push(this._registerSignalInput(`in_${O}`));this._unregisterSignalInput("in")}_getCurrentActivationState(H){const O=this._cachedActivationState;if(O.length=0,H._hasExecutionVariable(this,"activationState")){const S=H._getExecutionVariable(this,"activationState",[]);for(let H=0;H<S.length;H++)O.push(S[H])}else for(let S=0;S<this.config.inputSignalCount;S++)O.push(!1);return O}_execute(H,O){const S=this._getCurrentActivationState(H);if(O===this.reset)for(let t=0;t<this.config.inputSignalCount;t++)S[t]=!1;else{const H=this.inFlows.indexOf(O);H>=0&&(S[H]=!0)}if(this.remainingInputs.setValue(new G.d(S.filter((H=>!H)).length),H),H._setExecutionVariable(this,"activationState",S.slice()),S.includes(!1))O!==this.reset&&this.out._activateSignal(H);else{this.completed._activateSignal(H);for(let H=0;H<this.config.inputSignalCount;H++)S[H]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(H){super.serialize(H),H.config.inputFlows=this.config.inputSignalCount}}(0,q.g)("FlowGraphWaitAllBlock",U)}}]);