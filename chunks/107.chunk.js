"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[107],{15758:(U,G,C)=>{C.r(G),C.d(G,{FlowGraphWaitAllBlock:()=>E});var L=C(14188),X=C(12850),l=C(14134),t=C(14130);class E extends L.d{constructor(U){super(U),this.config=U,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",l.k,new t.c(this.config.inputSignalCount||0));for(let G=0;G<this.config.inputSignalCount;G++)this.inFlows.push(this._registerSignalInput("in_".concat(G)));this._unregisterSignalInput("in")}_getCurrentActivationState(U){const G=this._cachedActivationState;if(G.length=0,U._hasExecutionVariable(this,"activationState")){const C=U._getExecutionVariable(this,"activationState",[]);for(let U=0;U<C.length;U++)G.push(C[U])}else for(let C=0;C<this.config.inputSignalCount;C++)G.push(!1);return G}_execute(U,G){const C=this._getCurrentActivationState(U);if(G===this.reset)for(let L=0;L<this.config.inputSignalCount;L++)C[L]=!1;else{const U=this.inFlows.indexOf(G);U>=0&&(C[U]=!0)}if(this.remainingInputs.setValue(new t.c(C.filter((U=>!U)).length),U),U._setExecutionVariable(this,"activationState",C.slice()),C.includes(!1))G!==this.reset&&this.out._activateSignal(U);else{this.completed._activateSignal(U);for(let U=0;U<this.config.inputSignalCount;U++)C[U]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(U){super.serialize(U),U.config.inputFlows=this.config.inputSignalCount}}(0,X.e)("FlowGraphWaitAllBlock",E)}}]);