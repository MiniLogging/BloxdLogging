"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[107],{14443:(I,E,j)=>{j.r(E),j.d(E,{FlowGraphWaitAllBlock:()=>t});var e=j(12859),w=j(11073),z=j(12819),h=j(12812);class t extends e.b{constructor(I){super(I),this.config=I,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",z.i,new h.b(this.config.inputSignalCount||0));for(let E=0;E<this.config.inputSignalCount;E++)this.inFlows.push(this._registerSignalInput(`in_${E}`));this._unregisterSignalInput("in")}_getCurrentActivationState(I){const E=this._cachedActivationState;if(E.length=0,I._hasExecutionVariable(this,"activationState")){const j=I._getExecutionVariable(this,"activationState",[]);for(let I=0;I<j.length;I++)E.push(j[I])}else for(let j=0;j<this.config.inputSignalCount;j++)E.push(!1);return E}_execute(I,E){const j=this._getCurrentActivationState(I);if(E===this.reset)for(let e=0;e<this.config.inputSignalCount;e++)j[e]=!1;else{const I=this.inFlows.indexOf(E);I>=0&&(j[I]=!0)}if(this.remainingInputs.setValue(new h.b(j.filter((I=>!I)).length),I),I._setExecutionVariable(this,"activationState",j.slice()),j.includes(!1))E!==this.reset&&this.out._activateSignal(I);else{this.completed._activateSignal(I);for(let I=0;I<this.config.inputSignalCount;I++)j[I]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(I){super.serialize(I),I.config.inputFlows=this.config.inputSignalCount}}(0,w.h)("FlowGraphWaitAllBlock",t)}}]);