"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[107],{15628:(y,S,I)=>{I.r(S),I.d(S,{FlowGraphWaitAllBlock:()=>d});var V=I(14080),i=I(12282),A=I(14033),B=I(14029);class d extends V.d{constructor(y){super(y),this.config=y,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",A.i,new B.c(this.config.inputSignalCount||0));for(let S=0;S<this.config.inputSignalCount;S++)this.inFlows.push(this._registerSignalInput(`in_${S}`));this._unregisterSignalInput("in")}_getCurrentActivationState(y){const S=this._cachedActivationState;if(S.length=0,y._hasExecutionVariable(this,"activationState")){const I=y._getExecutionVariable(this,"activationState",[]);for(let y=0;y<I.length;y++)S.push(I[y])}else for(let I=0;I<this.config.inputSignalCount;I++)S.push(!1);return S}_execute(y,S){const I=this._getCurrentActivationState(y);if(S===this.reset)for(let V=0;V<this.config.inputSignalCount;V++)I[V]=!1;else{const y=this.inFlows.indexOf(S);y>=0&&(I[y]=!0)}if(this.remainingInputs.setValue(new B.c(I.filter((y=>!y)).length),y),y._setExecutionVariable(this,"activationState",I.slice()),I.includes(!1))S!==this.reset&&this.out._activateSignal(y);else{this.completed._activateSignal(y);for(let y=0;y<this.config.inputSignalCount;y++)I[y]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(y){super.serialize(y),y.config.inputFlows=this.config.inputSignalCount}}(0,i.e)("FlowGraphWaitAllBlock",d)}}]);