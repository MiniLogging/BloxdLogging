"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[107],{14984:(e,E,H)=>{H.r(E),H.d(E,{FlowGraphWaitAllBlock:()=>M});var N=H(13475),u=H(11690),z=H(13415),P=H(13407);class M extends N.d{constructor(e){super(e),this.config=e,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",z.h,new P.b(this.config.inputSignalCount||0));for(let E=0;E<this.config.inputSignalCount;E++)this.inFlows.push(this._registerSignalInput(`in_${E}`));this._unregisterSignalInput("in")}_getCurrentActivationState(e){const E=this._cachedActivationState;if(E.length=0,e._hasExecutionVariable(this,"activationState")){const H=e._getExecutionVariable(this,"activationState",[]);for(let e=0;e<H.length;e++)E.push(H[e])}else for(let H=0;H<this.config.inputSignalCount;H++)E.push(!1);return E}_execute(e,E){const H=this._getCurrentActivationState(e);if(E===this.reset)for(let N=0;N<this.config.inputSignalCount;N++)H[N]=!1;else{const e=this.inFlows.indexOf(E);e>=0&&(H[e]=!0)}if(this.remainingInputs.setValue(new P.b(H.filter((e=>!e)).length),e),e._setExecutionVariable(this,"activationState",H.slice()),H.includes(!1))E!==this.reset&&this.out._activateSignal(e);else{this.completed._activateSignal(e);for(let e=0;e<this.config.inputSignalCount;e++)H[e]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(e){super.serialize(e),e.config.inputFlows=this.config.inputSignalCount}}(0,u.g)("FlowGraphWaitAllBlock",M)}}]);