"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[107],{15698:(V,h,mV)=>{mV.r(h),mV.d(h,{FlowGraphWaitAllBlock:()=>k});var t=mV(14144),L=mV(12388),N=mV(14109),A=mV(14102);class k extends t.c{constructor(V){super(V),this.config=V,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",N.j,new A.d(this.config.inputSignalCount||0));for(let h=0;h<this.config.inputSignalCount;h++)this.inFlows.push(this._registerSignalInput(`in_${h}`));this._unregisterSignalInput("in")}_getCurrentActivationState(V){const h=this._cachedActivationState;if(h.length=0,V._hasExecutionVariable(this,"activationState")){const mV=V._getExecutionVariable(this,"activationState",[]);for(let V=0;V<mV.length;V++)h.push(mV[V])}else for(let mV=0;mV<this.config.inputSignalCount;mV++)h.push(!1);return h}_execute(V,h){const mV=this._getCurrentActivationState(V);if(h===this.reset)for(let t=0;t<this.config.inputSignalCount;t++)mV[t]=!1;else{const V=this.inFlows.indexOf(h);V>=0&&(mV[V]=!0)}if(this.remainingInputs.setValue(new A.d(mV.filter((V=>!V)).length),V),V._setExecutionVariable(this,"activationState",mV.slice()),mV.includes(!1))h!==this.reset&&this.out._activateSignal(V);else{this.completed._activateSignal(V);for(let V=0;V<this.config.inputSignalCount;V++)mV[V]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(V){super.serialize(V),V.config.inputFlows=this.config.inputSignalCount}}(0,L.i)("FlowGraphWaitAllBlock",k)}}]);