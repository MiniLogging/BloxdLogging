"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14480:(h,V,i)=>{i.r(V),i.d(V,{FlowGraphWaitAllBlock:()=>q});var S=i(12861),l=i(11091),Y=i(12805),g=i(12800);class q extends S.e{constructor(h){super(h),this.config=h,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",Y.i,new g.b(this.config.inputSignalCount||0));for(let V=0;V<this.config.inputSignalCount;V++)this.inFlows.push(this._registerSignalInput(`in_${V}`));this._unregisterSignalInput("in")}_getCurrentActivationState(h){const V=this._cachedActivationState;if(V.length=0,h._hasExecutionVariable(this,"activationState")){const i=h._getExecutionVariable(this,"activationState",[]);for(let h=0;h<i.length;h++)V.push(i[h])}else for(let i=0;i<this.config.inputSignalCount;i++)V.push(!1);return V}_execute(h,V){const i=this._getCurrentActivationState(h);if(V===this.reset)for(let S=0;S<this.config.inputSignalCount;S++)i[S]=!1;else{const h=this.inFlows.indexOf(V);h>=0&&(i[h]=!0)}if(this.remainingInputs.setValue(new g.b(i.filter((h=>!h)).length),h),h._setExecutionVariable(this,"activationState",i.slice()),i.includes(!1))V!==this.reset&&this.out._activateSignal(h);else{this.completed._activateSignal(h);for(let h=0;h<this.config.inputSignalCount;h++)i[h]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(h){super.serialize(h),h.config.inputFlows=this.config.inputSignalCount}}(0,l.f)("FlowGraphWaitAllBlock",q)}}]);