"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14437:(q,S,b)=>{b.r(S),b.d(S,{FlowGraphWaitAllBlock:()=>g});var z=b(12866),C=b(11058),v=b(12839),U=b(12836);class g extends z.e{constructor(q){super(q),this.config=q,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",v.h,new U.d(this.config.inputSignalCount||0));for(let S=0;S<this.config.inputSignalCount;S++)this.inFlows.push(this._registerSignalInput(`in_${S}`));this._unregisterSignalInput("in")}_getCurrentActivationState(q){const S=this._cachedActivationState;if(S.length=0,q._hasExecutionVariable(this,"activationState")){const b=q._getExecutionVariable(this,"activationState",[]);for(let q=0;q<b.length;q++)S.push(b[q])}else for(let b=0;b<this.config.inputSignalCount;b++)S.push(!1);return S}_execute(q,S){const b=this._getCurrentActivationState(q);if(S===this.reset)for(let z=0;z<this.config.inputSignalCount;z++)b[z]=!1;else{const q=this.inFlows.indexOf(S);q>=0&&(b[q]=!0)}if(this.remainingInputs.setValue(new U.d(b.filter((q=>!q)).length),q),q._setExecutionVariable(this,"activationState",b.slice()),b.includes(!1))S!==this.reset&&this.out._activateSignal(q);else{this.completed._activateSignal(q);for(let q=0;q<this.config.inputSignalCount;q++)b[q]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(q){super.serialize(q),q.config.inputFlows=this.config.inputSignalCount}}(0,C.f)("FlowGraphWaitAllBlock",g)}}]);