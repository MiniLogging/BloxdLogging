"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[107],{16089:(q,I,l)=>{l.r(I),l.d(I,{FlowGraphWaitAllBlock:()=>a});var w=l(14488),t=l(12711),O=l(14441),c=l(14437);class a extends w.e{constructor(q){super(q),this.config=q,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",O.k,new c.d(this.config.inputSignalCount||0));for(let I=0;I<this.config.inputSignalCount;I++)this.inFlows.push(this._registerSignalInput(`in_${I}`));this._unregisterSignalInput("in")}_getCurrentActivationState(q){const I=this._cachedActivationState;if(I.length=0,q._hasExecutionVariable(this,"activationState")){const l=q._getExecutionVariable(this,"activationState",[]);for(let q=0;q<l.length;q++)I.push(l[q])}else for(let l=0;l<this.config.inputSignalCount;l++)I.push(!1);return I}_execute(q,I){const l=this._getCurrentActivationState(q);if(I===this.reset)for(let w=0;w<this.config.inputSignalCount;w++)l[w]=!1;else{const q=this.inFlows.indexOf(I);q>=0&&(l[q]=!0)}if(this.remainingInputs.setValue(new c.d(l.filter((q=>!q)).length),q),q._setExecutionVariable(this,"activationState",l.slice()),l.includes(!1))I!==this.reset&&this.out._activateSignal(q);else{this.completed._activateSignal(q);for(let q=0;q<this.config.inputSignalCount;q++)l[q]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(q){super.serialize(q),q.config.inputFlows=this.config.inputSignalCount}}(0,t.e)("FlowGraphWaitAllBlock",a)}}]);