"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[107],{14554:(F,b,Q)=>{Q.r(b),Q.d(b,{FlowGraphWaitAllBlock:()=>W});var C=Q(13e3),z=Q(11265),t=Q(12951),g=Q(12948);class W extends C.d{constructor(F){super(F),this.config=F,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",t.g,new g.b(this.config.inputSignalCount||0));for(let b=0;b<this.config.inputSignalCount;b++)this.inFlows.push(this._registerSignalInput(`in_${b}`));this._unregisterSignalInput("in")}_getCurrentActivationState(F){const b=this._cachedActivationState;if(b.length=0,F._hasExecutionVariable(this,"activationState")){const Q=F._getExecutionVariable(this,"activationState",[]);for(let F=0;F<Q.length;F++)b.push(Q[F])}else for(let Q=0;Q<this.config.inputSignalCount;Q++)b.push(!1);return b}_execute(F,b){const Q=this._getCurrentActivationState(F);if(b===this.reset)for(let C=0;C<this.config.inputSignalCount;C++)Q[C]=!1;else{const F=this.inFlows.indexOf(b);F>=0&&(Q[F]=!0)}if(this.remainingInputs.setValue(new g.b(Q.filter((F=>!F)).length),F),F._setExecutionVariable(this,"activationState",Q.slice()),Q.includes(!1))b!==this.reset&&this.out._activateSignal(F);else{this.completed._activateSignal(F);for(let F=0;F<this.config.inputSignalCount;F++)Q[F]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(F){super.serialize(F),F.config.inputFlows=this.config.inputSignalCount}}(0,z.g)("FlowGraphWaitAllBlock",W)}}]);