"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[107],{15616:(H,u,J)=>{J.r(u),J.d(u,{FlowGraphWaitAllBlock:()=>g});var O=J(14064),U=J(12304),h=J(14018),w=J(14011);class g extends O.e{constructor(H){super(H),this.config=H,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",h.j,new w.d(this.config.inputSignalCount||0));for(let u=0;u<this.config.inputSignalCount;u++)this.inFlows.push(this._registerSignalInput(`in_${u}`));this._unregisterSignalInput("in")}_getCurrentActivationState(H){const u=this._cachedActivationState;if(u.length=0,H._hasExecutionVariable(this,"activationState")){const J=H._getExecutionVariable(this,"activationState",[]);for(let H=0;H<J.length;H++)u.push(J[H])}else for(let J=0;J<this.config.inputSignalCount;J++)u.push(!1);return u}_execute(H,u){const J=this._getCurrentActivationState(H);if(u===this.reset)for(let O=0;O<this.config.inputSignalCount;O++)J[O]=!1;else{const H=this.inFlows.indexOf(u);H>=0&&(J[H]=!0)}if(this.remainingInputs.setValue(new w.d(J.filter((H=>!H)).length),H),H._setExecutionVariable(this,"activationState",J.slice()),J.includes(!1))u!==this.reset&&this.out._activateSignal(H);else{this.completed._activateSignal(H);for(let H=0;H<this.config.inputSignalCount;H++)J[H]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(H){super.serialize(H),H.config.inputFlows=this.config.inputSignalCount}}(0,U.f)("FlowGraphWaitAllBlock",g)}}]);