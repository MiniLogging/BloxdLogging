"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[107],{16149:(I,x,L)=>{L.r(x),L.d(x,{FlowGraphWaitAllBlock:()=>p});var F=L(14540),X=L(12938),G=L(14498),Y=L(14493);class p extends F.e{constructor(I){super(I),this.config=I,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",G.l,new Y.b(this.config.inputSignalCount||0));for(let x=0;x<this.config.inputSignalCount;x++)this.inFlows.push(this._registerSignalInput(`in_${x}`));this._unregisterSignalInput("in")}_getCurrentActivationState(I){const x=this._cachedActivationState;if(x.length=0,I._hasExecutionVariable(this,"activationState")){const L=I._getExecutionVariable(this,"activationState",[]);for(let I=0;I<L.length;I++)x.push(L[I])}else for(let L=0;L<this.config.inputSignalCount;L++)x.push(!1);return x}_execute(I,x){const L=this._getCurrentActivationState(I);if(x===this.reset)for(let F=0;F<this.config.inputSignalCount;F++)L[F]=!1;else{const I=this.inFlows.indexOf(x);I>=0&&(L[I]=!0)}if(this.remainingInputs.setValue(new Y.b(L.filter((I=>!I)).length),I),I._setExecutionVariable(this,"activationState",L.slice()),L.includes(!1))x!==this.reset&&this.out._activateSignal(I);else{this.completed._activateSignal(I);for(let I=0;I<this.config.inputSignalCount;I++)L[I]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(I){super.serialize(I),I.config.inputFlows=this.config.inputSignalCount}}(0,X.d)("FlowGraphWaitAllBlock",p)}}]);