"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[107],{14554:(o,H,n)=>{n.r(H),n.d(H,{FlowGraphWaitAllBlock:()=>Y});var E=n(12983),k=n(11140),g=n(12933),O=n(12929);class Y extends E.c{constructor(o){super(o),this.config=o,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",g.e,new O.c(this.config.inputSignalCount||0));for(let H=0;H<this.config.inputSignalCount;H++)this.inFlows.push(this._registerSignalInput(`in_${H}`));this._unregisterSignalInput("in")}_getCurrentActivationState(o){const H=this._cachedActivationState;if(H.length=0,o._hasExecutionVariable(this,"activationState")){const n=o._getExecutionVariable(this,"activationState",[]);for(let o=0;o<n.length;o++)H.push(n[o])}else for(let n=0;n<this.config.inputSignalCount;n++)H.push(!1);return H}_execute(o,H){const n=this._getCurrentActivationState(o);if(H===this.reset)for(let E=0;E<this.config.inputSignalCount;E++)n[E]=!1;else{const o=this.inFlows.indexOf(H);o>=0&&(n[o]=!0)}if(this.remainingInputs.setValue(new O.c(n.filter((o=>!o)).length),o),o._setExecutionVariable(this,"activationState",n.slice()),n.includes(!1))H!==this.reset&&this.out._activateSignal(o);else{this.completed._activateSignal(o);for(let o=0;o<this.config.inputSignalCount;o++)n[o]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(o){super.serialize(o),o.config.inputFlows=this.config.inputSignalCount}}(0,k.e)("FlowGraphWaitAllBlock",Y)}}]);