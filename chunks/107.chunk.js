"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[107],{15687:(M,Z,P)=>{P.r(Z),P.d(Z,{FlowGraphWaitAllBlock:()=>G});var x=P(14117),c=P(12317),w=P(14073),v=P(14067);class G extends x.e{constructor(M){super(M),this.config=M,this.inFlows=[],this._cachedActivationState=[],this.reset=this._registerSignalInput("reset"),this.completed=this._registerSignalOutput("completed"),this.remainingInputs=this.registerDataOutput("remainingInputs",w.j,new v.e(this.config.inputSignalCount||0));for(let Z=0;Z<this.config.inputSignalCount;Z++)this.inFlows.push(this._registerSignalInput(`in_${Z}`));this._unregisterSignalInput("in")}_getCurrentActivationState(M){const Z=this._cachedActivationState;if(Z.length=0,M._hasExecutionVariable(this,"activationState")){const P=M._getExecutionVariable(this,"activationState",[]);for(let M=0;M<P.length;M++)Z.push(P[M])}else for(let P=0;P<this.config.inputSignalCount;P++)Z.push(!1);return Z}_execute(M,Z){const P=this._getCurrentActivationState(M);if(Z===this.reset)for(let x=0;x<this.config.inputSignalCount;x++)P[x]=!1;else{const M=this.inFlows.indexOf(Z);M>=0&&(P[M]=!0)}if(this.remainingInputs.setValue(new v.e(P.filter((M=>!M)).length),M),M._setExecutionVariable(this,"activationState",P.slice()),P.includes(!1))Z!==this.reset&&this.out._activateSignal(M);else{this.completed._activateSignal(M);for(let M=0;M<this.config.inputSignalCount;M++)P[M]=!1}}getClassName(){return"FlowGraphWaitAllBlock"}serialize(M){super.serialize(M),M.config.inputFlows=this.config.inputSignalCount}}(0,c.g)("FlowGraphWaitAllBlock",G)}}]);