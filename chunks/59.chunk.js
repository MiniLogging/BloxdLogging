"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{13924:(z,u,Y)=>{Y.r(u),Y.d(u,{FlowGraphPlayAnimationBlock:()=>T});var H=Y(12577),E=Y(12531),J=Y(10918),l=Y(13920);class T extends H.c{constructor(z){super(z,["animationLoop","animationEnd","animationGroupLoop"]),this.config=z,this.speed=this.registerDataInput("speed",E.p),this.loop=this.registerDataInput("loop",E.f),this.from=this.registerDataInput("from",E.p,0),this.to=this.registerDataInput("to",E.p),this.currentFrame=this.registerDataOutput("currentFrame",E.p),this.currentTime=this.registerDataOutput("currentTime",E.p),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",E.e),this.animationGroup=this.registerDataInput("animationGroup",E.e,null===z||void 0===z?void 0:z.animationGroup),this.animation=this.registerDataInput("animation",E.e),this.object=this.registerDataInput("object",E.e)}_preparePendingTasks(z){const u=this.animationGroup.getValue(z),Y=this.animation.getValue(z);if(!u&&!Y)return this._reportError(z,"No animation or animation group provided");{const E=this.currentAnimationGroup.getValue(z);E&&E!==u&&E.dispose();let J=u;if(Y&&!J){const u=this.object.getValue(z);if(!u)return this._reportError(z,"No target object provided");const H=Array.isArray(Y)?Y:[Y],E=H[0].name;J=new l.AnimationGroup("flowGraphAnimationGroup-"+E+"-"+u.name,z.configuration.Cu);let T=!1;const b=z._getGlobalContextVariable("interpolationAnimations",[]);for(const z of H)J.addTargetedAnimation(z,u),-1!==b.indexOf(z.uniqueId)&&(T=!0);T&&this._checkInterpolationDuplications(z,H,u)}const T=this.speed.getValue(z)||1,b=this.from.getValue(z)??0,L=this.to.getValue(z)||J.to,D=!isFinite(L)||this.loop.getValue(z);this.currentAnimationGroup.setValue(J,z);const g=z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==g.indexOf(J.uniqueId)&&J.stop();try{J.start(D,T,b,L),J.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(z))),J.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(z))),J.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(z))),J.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(z))),g.push(J.uniqueId),z._setGlobalContextVariable("currentlyRunningAnimationGroups",g)}catch(H){this._reportError(z,H)}}}_reportError(z,u){super._reportError(z,u),this.currentFrame.setValue(-1,z),this.currentTime.setValue(-1,z)}_executeOnTick(z){const u=this.currentAnimationGroup.getValue(z);var Y;u&&(this.currentFrame.setValue(u.getCurrentFrame(),z),this.currentTime.setValue((null===(Y=u.animatables[0])||void 0===Y?void 0:Y.elapsedTime)??0,z))}_execute(z){this._startPendingTasks(z)}_onAnimationGroupEnd(z){this._removeFromCurrentlyRunning(z,this.currentAnimationGroup.getValue(z)),this._resetAfterCanceled(z),this.done._activateSignal(z)}_checkInterpolationDuplications(z,u,Y){const H=z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const E of H){const H=z.assetsContext.animationGroups.find((z=>z.uniqueId===E));if(H)for(const E of H.targetedAnimations)for(const J of u)E.animation.targetProperty===J.targetProperty&&E.target===Y&&this._stopAnimationGroup(z,H)}}_stopAnimationGroup(z,u){u.stop(!0),u.dispose(),this._removeFromCurrentlyRunning(z,u)}_removeFromCurrentlyRunning(z,u){const Y=z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),H=Y.indexOf(u.uniqueId);-1!==H&&(Y.splice(H,1),z._setGlobalContextVariable("currentlyRunningAnimationGroups",Y))}_cancelPendingTasks(z){const u=this.currentAnimationGroup.getValue(z);u&&this._stopAnimationGroup(z,u)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,J.d)("FlowGraphPlayAnimationBlock",T)}}]);