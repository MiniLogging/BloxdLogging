"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14223:(s,Z,o)=>{o.r(Z),o.d(Z,{FlowGraphPlayAnimationBlock:()=>O});var t=o(12828),j=o(12775),S=o(10916),a=o(14214);class O extends t.c{constructor(s){super(s,["animationLoop","animationEnd","animationGroupLoop"]),this.config=s,this.speed=this.registerDataInput("speed",j.w),this.loop=this.registerDataInput("loop",j.g),this.from=this.registerDataInput("from",j.w,0),this.to=this.registerDataInput("to",j.w),this.currentFrame=this.registerDataOutput("currentFrame",j.w),this.currentTime=this.registerDataOutput("currentTime",j.w),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",j.d),this.animationGroup=this.registerDataInput("animationGroup",j.d,null===s||void 0===s?void 0:s.animationGroup),this.animation=this.registerDataInput("animation",j.d),this.object=this.registerDataInput("object",j.d)}_preparePendingTasks(s){const Z=this.animationGroup.getValue(s),o=this.animation.getValue(s);if(!Z&&!o)return this._reportError(s,"No animation or animation group provided");{const j=this.currentAnimationGroup.getValue(s);j&&j!==Z&&j.dispose();let S=Z;if(o&&!S){const Z=this.object.getValue(s);if(!Z)return this._reportError(s,"No target object provided");const t=Array.isArray(o)?o:[o],j=t[0].name;S=new a.AnimationGroup("flowGraphAnimationGroup-"+j+"-"+Z.name,s.configuration.fZ);let O=!1;const v=s._getGlobalContextVariable("interpolationAnimations",[]);for(const s of t)S.addTargetedAnimation(s,Z),-1!==v.indexOf(s.uniqueId)&&(O=!0);O&&this._checkInterpolationDuplications(s,t,Z)}const O=this.speed.getValue(s)||1,v=this.from.getValue(s)??0,G=this.to.getValue(s)||S.to,B=!isFinite(G)||this.loop.getValue(s);this.currentAnimationGroup.setValue(S,s);const Q=s._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==Q.indexOf(S.uniqueId)&&S.stop();try{S.start(B,O,v,G),S.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(s))),S.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(s))),S.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(s))),S.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(s))),Q.push(S.uniqueId),s._setGlobalContextVariable("currentlyRunningAnimationGroups",Q)}catch(t){this._reportError(s,t)}}}_reportError(s,Z){super._reportError(s,Z),this.currentFrame.setValue(-1,s),this.currentTime.setValue(-1,s)}_executeOnTick(s){const Z=this.currentAnimationGroup.getValue(s);var o;Z&&(this.currentFrame.setValue(Z.getCurrentFrame(),s),this.currentTime.setValue((null===(o=Z.animatables[0])||void 0===o?void 0:o.elapsedTime)??0,s))}_execute(s){this._startPendingTasks(s)}_onAnimationGroupEnd(s){this._removeFromCurrentlyRunning(s,this.currentAnimationGroup.getValue(s)),this._resetAfterCanceled(s),this.done._activateSignal(s)}_checkInterpolationDuplications(s,Z,o){const t=s._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const j of t){const t=s.assetsContext.animationGroups.find((s=>s.uniqueId===j));if(t)for(const j of t.targetedAnimations)for(const S of Z)j.animation.targetProperty===S.targetProperty&&j.target===o&&this._stopAnimationGroup(s,t)}}_stopAnimationGroup(s,Z){Z.stop(!0),Z.dispose(),this._removeFromCurrentlyRunning(s,Z)}_removeFromCurrentlyRunning(s,Z){const o=s._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),t=o.indexOf(Z.uniqueId);-1!==t&&(o.splice(t,1),s._setGlobalContextVariable("currentlyRunningAnimationGroups",o))}_cancelPendingTasks(s){const Z=this.currentAnimationGroup.getValue(s);Z&&this._stopAnimationGroup(s,Z)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,S.f)("FlowGraphPlayAnimationBlock",O)}}]);