"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14150:(x,O,Q)=>{Q.r(O),Q.d(O,{FlowGraphPlayAnimationBlock:()=>o});var X=Q(12741),Z=Q(12707),n=Q(10866),V=Q(14144);class o extends X.c{constructor(x){super(x,["animationLoop","animationEnd","animationGroupLoop"]),this.config=x,this.speed=this.registerDataInput("speed",Z.q),this.loop=this.registerDataInput("loop",Z.g),this.from=this.registerDataInput("from",Z.q,0),this.to=this.registerDataInput("to",Z.q),this.currentFrame=this.registerDataOutput("currentFrame",Z.q),this.currentTime=this.registerDataOutput("currentTime",Z.q),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",Z.d),this.animationGroup=this.registerDataInput("animationGroup",Z.d,null===x||void 0===x?void 0:x.animationGroup),this.animation=this.registerDataInput("animation",Z.d),this.object=this.registerDataInput("object",Z.d)}_preparePendingTasks(x){const O=this.animationGroup.getValue(x),Q=this.animation.getValue(x);if(!O&&!Q)return this._reportError(x,"No animation or animation group provided");{const Z=this.currentAnimationGroup.getValue(x);Z&&Z!==O&&Z.dispose();let n=O;if(Q&&!n){const O=this.object.getValue(x);if(!O)return this._reportError(x,"No target object provided");const X=Array.isArray(Q)?Q:[Q],Z=X[0].name;n=new V.AnimationGroup("flowGraphAnimationGroup-"+Z+"-"+O.name,x.configuration.RO);let o=!1;const l=x._getGlobalContextVariable("interpolationAnimations",[]);for(const x of X)n.addTargetedAnimation(x,O),-1!==l.indexOf(x.uniqueId)&&(o=!0);o&&this._checkInterpolationDuplications(x,X,O)}const o=this.speed.getValue(x)||1,l=this.from.getValue(x)??0,C=this.to.getValue(x)||n.to,U=!isFinite(C)||this.loop.getValue(x);this.currentAnimationGroup.setValue(n,x);const L=x._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==L.indexOf(n.uniqueId)&&n.stop();try{n.start(U,o,l,C),n.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(x))),n.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(x))),n.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(x))),n.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(x))),L.push(n.uniqueId),x._setGlobalContextVariable("currentlyRunningAnimationGroups",L)}catch(X){this._reportError(x,X)}}}_reportError(x,O){super._reportError(x,O),this.currentFrame.setValue(-1,x),this.currentTime.setValue(-1,x)}_executeOnTick(x){const O=this.currentAnimationGroup.getValue(x);var Q;O&&(this.currentFrame.setValue(O.getCurrentFrame(),x),this.currentTime.setValue((null===(Q=O.animatables[0])||void 0===Q?void 0:Q.elapsedTime)??0,x))}_execute(x){this._startPendingTasks(x)}_onAnimationGroupEnd(x){this._removeFromCurrentlyRunning(x,this.currentAnimationGroup.getValue(x)),this._resetAfterCanceled(x),this.done._activateSignal(x)}_checkInterpolationDuplications(x,O,Q){const X=x._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const Z of X){const X=x.assetsContext.animationGroups.find((x=>x.uniqueId===Z));if(X)for(const Z of X.targetedAnimations)for(const n of O)Z.animation.targetProperty===n.targetProperty&&Z.target===Q&&this._stopAnimationGroup(x,X)}}_stopAnimationGroup(x,O){O.stop(!0),O.dispose(),this._removeFromCurrentlyRunning(x,O)}_removeFromCurrentlyRunning(x,O){const Q=x._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),X=Q.indexOf(O.uniqueId);-1!==X&&(Q.splice(X,1),x._setGlobalContextVariable("currentlyRunningAnimationGroups",Q))}_cancelPendingTasks(x){const O=this.currentAnimationGroup.getValue(x);O&&this._stopAnimationGroup(x,O)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,n.d)("FlowGraphPlayAnimationBlock",o)}}]);