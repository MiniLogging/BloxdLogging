"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14045:(h,d,m)=>{m.r(d),m.d(d,{FlowGraphPlayAnimationBlock:()=>a});var j=m(12708),A=m(12671),b=m(11080),w=m(14043);class a extends j.d{constructor(h){super(h,["animationLoop","animationEnd","animationGroupLoop"]),this.config=h,this.speed=this.registerDataInput("speed",A.y),this.loop=this.registerDataInput("loop",A.f),this.from=this.registerDataInput("from",A.y,0),this.to=this.registerDataInput("to",A.y),this.currentFrame=this.registerDataOutput("currentFrame",A.y),this.currentTime=this.registerDataOutput("currentTime",A.y),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",A.e),this.animationGroup=this.registerDataInput("animationGroup",A.e,null===h||void 0===h?void 0:h.animationGroup),this.animation=this.registerDataInput("animation",A.e),this.object=this.registerDataInput("object",A.e)}_preparePendingTasks(h){const d=this.animationGroup.getValue(h),m=this.animation.getValue(h);if(!d&&!m)return this._reportError(h,"No animation or animation group provided");{const A=this.currentAnimationGroup.getValue(h);A&&A!==d&&A.dispose();let b=d;if(m&&!b){const d=this.object.getValue(h);if(!d)return this._reportError(h,"No target object provided");const j=Array.isArray(m)?m:[m],A=j[0].name;b=new w.AnimationGroup("flowGraphAnimationGroup-"+A+"-"+d.name,h.configuration.Fd);let a=!1;const D=h._getGlobalContextVariable("interpolationAnimations",[]);for(const h of j)b.addTargetedAnimation(h,d),-1!==D.indexOf(h.uniqueId)&&(a=!0);a&&this._checkInterpolationDuplications(h,j,d)}const a=this.speed.getValue(h)||1,D=this.from.getValue(h)??0,S=this.to.getValue(h)||b.to,M=!isFinite(S)||this.loop.getValue(h);this.currentAnimationGroup.setValue(b,h);const q=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==q.indexOf(b.uniqueId)&&b.stop();try{b.start(M,a,D,S),b.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(h))),b.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(h))),b.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(h))),b.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(h))),q.push(b.uniqueId),h._setGlobalContextVariable("currentlyRunningAnimationGroups",q)}catch(j){this._reportError(h,j)}}}_reportError(h,d){super._reportError(h,d),this.currentFrame.setValue(-1,h),this.currentTime.setValue(-1,h)}_executeOnTick(h){const d=this.currentAnimationGroup.getValue(h);var m;d&&(this.currentFrame.setValue(d.getCurrentFrame(),h),this.currentTime.setValue((null===(m=d.animatables[0])||void 0===m?void 0:m.elapsedTime)??0,h))}_execute(h){this._startPendingTasks(h)}_onAnimationGroupEnd(h){this._removeFromCurrentlyRunning(h,this.currentAnimationGroup.getValue(h)),this._resetAfterCanceled(h),this.done._activateSignal(h)}_checkInterpolationDuplications(h,d,m){const j=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const A of j){const j=h.assetsContext.animationGroups.find((h=>h.uniqueId===A));if(j)for(const A of j.targetedAnimations)for(const b of d)A.animation.targetProperty===b.targetProperty&&A.target===m&&this._stopAnimationGroup(h,j)}}_stopAnimationGroup(h,d){d.stop(!0),d.dispose(),this._removeFromCurrentlyRunning(h,d)}_removeFromCurrentlyRunning(h,d){const m=h._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),j=m.indexOf(d.uniqueId);-1!==j&&(m.splice(j,1),h._setGlobalContextVariable("currentlyRunningAnimationGroups",m))}_cancelPendingTasks(h){const d=this.currentAnimationGroup.getValue(h);d&&this._stopAnimationGroup(h,d)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,b.i)("FlowGraphPlayAnimationBlock",a)}}]);