"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14383:(V,I,m)=>{m.r(I),m.d(I,{FlowGraphPlayAnimationBlock:()=>k});var C=m(12932),l=m(12899),s=m(11048),F=m(14376);class k extends C.c{constructor(V){super(V,["animationLoop","animationEnd","animationGroupLoop"]),this.config=V,this.speed=this.registerDataInput("speed",l.r),this.loop=this.registerDataInput("loop",l.d),this.from=this.registerDataInput("from",l.r,0),this.to=this.registerDataInput("to",l.r),this.currentFrame=this.registerDataOutput("currentFrame",l.r),this.currentTime=this.registerDataOutput("currentTime",l.r),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",l.b),this.animationGroup=this.registerDataInput("animationGroup",l.b,null===V||void 0===V?void 0:V.animationGroup),this.animation=this.registerDataInput("animation",l.b),this.object=this.registerDataInput("object",l.b)}_preparePendingTasks(V){const I=this.animationGroup.getValue(V),m=this.animation.getValue(V);if(!I&&!m)return this._reportError(V,"No animation or animation group provided");{const l=this.currentAnimationGroup.getValue(V);l&&l!==I&&l.dispose();let s=I;if(m&&!s){const I=this.object.getValue(V);if(!I)return this._reportError(V,"No target object provided");const C=Array.isArray(m)?m:[m],l=C[0].name;s=new F.AnimationGroup("flowGraphAnimationGroup-"+l+"-"+I.name,V.configuration.OI);let k=!1;const j=V._getGlobalContextVariable("interpolationAnimations",[]);for(const V of C)s.addTargetedAnimation(V,I),-1!==j.indexOf(V.uniqueId)&&(k=!0);k&&this._checkInterpolationDuplications(V,C,I)}const k=this.speed.getValue(V)||1,j=this.from.getValue(V)??0,E=this.to.getValue(V)||s.to,K=!isFinite(E)||this.loop.getValue(V);this.currentAnimationGroup.setValue(s,V);const Y=V._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==Y.indexOf(s.uniqueId)&&s.stop();try{s.start(K,k,j,E),s.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(V))),s.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(V))),s.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(V))),s.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(V))),Y.push(s.uniqueId),V._setGlobalContextVariable("currentlyRunningAnimationGroups",Y)}catch(C){this._reportError(V,C)}}}_reportError(V,I){super._reportError(V,I),this.currentFrame.setValue(-1,V),this.currentTime.setValue(-1,V)}_executeOnTick(V){const I=this.currentAnimationGroup.getValue(V);var m;I&&(this.currentFrame.setValue(I.getCurrentFrame(),V),this.currentTime.setValue((null===(m=I.animatables[0])||void 0===m?void 0:m.elapsedTime)??0,V))}_execute(V){this._startPendingTasks(V)}_onAnimationGroupEnd(V){this._removeFromCurrentlyRunning(V,this.currentAnimationGroup.getValue(V)),this._resetAfterCanceled(V),this.done._activateSignal(V)}_checkInterpolationDuplications(V,I,m){const C=V._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const l of C){const C=V.assetsContext.animationGroups.find((V=>V.uniqueId===l));if(C)for(const l of C.targetedAnimations)for(const s of I)l.animation.targetProperty===s.targetProperty&&l.target===m&&this._stopAnimationGroup(V,C)}}_stopAnimationGroup(V,I){I.stop(!0),I.dispose(),this._removeFromCurrentlyRunning(V,I)}_removeFromCurrentlyRunning(V,I){const m=V._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),C=m.indexOf(I.uniqueId);-1!==C&&(m.splice(C,1),V._setGlobalContextVariable("currentlyRunningAnimationGroups",m))}_cancelPendingTasks(V){const I=this.currentAnimationGroup.getValue(V);I&&this._stopAnimationGroup(V,I)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,s.h)("FlowGraphPlayAnimationBlock",k)}}]);