"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14117:(q,f,j)=>{j.r(f),j.d(f,{FlowGraphPlayAnimationBlock:()=>Q});var d=j(12749),g=j(12709),h=j(10965),L=j(14109);class Q extends d.d{constructor(q){super(q,["animationLoop","animationEnd","animationGroupLoop"]),this.config=q,this.speed=this.registerDataInput("speed",g.o),this.loop=this.registerDataInput("loop",g.d),this.from=this.registerDataInput("from",g.o,0),this.to=this.registerDataInput("to",g.o),this.currentFrame=this.registerDataOutput("currentFrame",g.o),this.currentTime=this.registerDataOutput("currentTime",g.o),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",g.c),this.animationGroup=this.registerDataInput("animationGroup",g.c,null===q||void 0===q?void 0:q.animationGroup),this.animation=this.registerDataInput("animation",g.c),this.object=this.registerDataInput("object",g.c)}_preparePendingTasks(q){const f=this.animationGroup.getValue(q),j=this.animation.getValue(q);if(!f&&!j)return this._reportError(q,"No animation or animation group provided");{const g=this.currentAnimationGroup.getValue(q);g&&g!==f&&g.dispose();let h=f;if(j&&!h){const f=this.object.getValue(q);if(!f)return this._reportError(q,"No target object provided");const d=Array.isArray(j)?j:[j],g=d[0].name;h=new L.AnimationGroup("flowGraphAnimationGroup-"+g+"-"+f.name,q.configuration.Sf);let Q=!1;const H=q._getGlobalContextVariable("interpolationAnimations",[]);for(const q of d)h.addTargetedAnimation(q,f),-1!==H.indexOf(q.uniqueId)&&(Q=!0);Q&&this._checkInterpolationDuplications(q,d,f)}const Q=this.speed.getValue(q)||1,H=this.from.getValue(q)??0,r=this.to.getValue(q)||h.to,u=!isFinite(r)||this.loop.getValue(q);this.currentAnimationGroup.setValue(h,q);const X=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==X.indexOf(h.uniqueId)&&h.stop();try{h.start(u,Q,H,r),h.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(q))),h.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(q))),h.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(q))),h.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(q))),X.push(h.uniqueId),q._setGlobalContextVariable("currentlyRunningAnimationGroups",X)}catch(d){this._reportError(q,d)}}}_reportError(q,f){super._reportError(q,f),this.currentFrame.setValue(-1,q),this.currentTime.setValue(-1,q)}_executeOnTick(q){const f=this.currentAnimationGroup.getValue(q);var j;f&&(this.currentFrame.setValue(f.getCurrentFrame(),q),this.currentTime.setValue((null===(j=f.animatables[0])||void 0===j?void 0:j.elapsedTime)??0,q))}_execute(q){this._startPendingTasks(q)}_onAnimationGroupEnd(q){this._removeFromCurrentlyRunning(q,this.currentAnimationGroup.getValue(q)),this._resetAfterCanceled(q),this.done._activateSignal(q)}_checkInterpolationDuplications(q,f,j){const d=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const g of d){const d=q.assetsContext.animationGroups.find((q=>q.uniqueId===g));if(d)for(const g of d.targetedAnimations)for(const h of f)g.animation.targetProperty===h.targetProperty&&g.target===j&&this._stopAnimationGroup(q,d)}}_stopAnimationGroup(q,f){f.stop(!0),f.dispose(),this._removeFromCurrentlyRunning(q,f)}_removeFromCurrentlyRunning(q,f){const j=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),d=j.indexOf(f.uniqueId);-1!==d&&(j.splice(d,1),q._setGlobalContextVariable("currentlyRunningAnimationGroups",j))}_cancelPendingTasks(q){const f=this.currentAnimationGroup.getValue(q);f&&this._stopAnimationGroup(q,f)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,h.f)("FlowGraphPlayAnimationBlock",Q)}}]);