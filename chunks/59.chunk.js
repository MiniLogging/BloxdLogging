"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14041:(q,c,U)=>{U.r(c),U.d(c,{FlowGraphPlayAnimationBlock:()=>X});var J=U(12693),Q=U(12648),s=U(10850),g=U(14039);class X extends J.d{constructor(q){super(q,["animationLoop","animationEnd","animationGroupLoop"]),this.config=q,this.speed=this.registerDataInput("speed",Q.t),this.loop=this.registerDataInput("loop",Q.e),this.from=this.registerDataInput("from",Q.t,0),this.to=this.registerDataInput("to",Q.t),this.currentFrame=this.registerDataOutput("currentFrame",Q.t),this.currentTime=this.registerDataOutput("currentTime",Q.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",Q.c),this.animationGroup=this.registerDataInput("animationGroup",Q.c,null===q||void 0===q?void 0:q.animationGroup),this.animation=this.registerDataInput("animation",Q.c),this.object=this.registerDataInput("object",Q.c)}_preparePendingTasks(q){const c=this.animationGroup.getValue(q),U=this.animation.getValue(q);if(!c&&!U)return this._reportError(q,"No animation or animation group provided");{const Q=this.currentAnimationGroup.getValue(q);Q&&Q!==c&&Q.dispose();let s=c;if(U&&!s){const c=this.object.getValue(q);if(!c)return this._reportError(q,"No target object provided");const J=Array.isArray(U)?U:[U],Q=J[0].name;s=new g.AnimationGroup("flowGraphAnimationGroup-"+Q+"-"+c.name,q.configuration.mc);let X=!1;const n=q._getGlobalContextVariable("interpolationAnimations",[]);for(const q of J)s.addTargetedAnimation(q,c),-1!==n.indexOf(q.uniqueId)&&(X=!0);X&&this._checkInterpolationDuplications(q,J,c)}const X=this.speed.getValue(q)||1,n=this.from.getValue(q)??0,W=this.to.getValue(q)||s.to,D=!isFinite(W)||this.loop.getValue(q);this.currentAnimationGroup.setValue(s,q);const u=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==u.indexOf(s.uniqueId)&&s.stop();try{s.start(D,X,n,W),s.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(q))),s.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(q))),s.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(q))),s.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(q))),u.push(s.uniqueId),q._setGlobalContextVariable("currentlyRunningAnimationGroups",u)}catch(J){this._reportError(q,J)}}}_reportError(q,c){super._reportError(q,c),this.currentFrame.setValue(-1,q),this.currentTime.setValue(-1,q)}_executeOnTick(q){const c=this.currentAnimationGroup.getValue(q);var U;c&&(this.currentFrame.setValue(c.getCurrentFrame(),q),this.currentTime.setValue((null===(U=c.animatables[0])||void 0===U?void 0:U.elapsedTime)??0,q))}_execute(q){this._startPendingTasks(q)}_onAnimationGroupEnd(q){this._removeFromCurrentlyRunning(q,this.currentAnimationGroup.getValue(q)),this._resetAfterCanceled(q),this.done._activateSignal(q)}_checkInterpolationDuplications(q,c,U){const J=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const Q of J){const J=q.assetsContext.animationGroups.find((q=>q.uniqueId===Q));if(J)for(const Q of J.targetedAnimations)for(const s of c)Q.animation.targetProperty===s.targetProperty&&Q.target===U&&this._stopAnimationGroup(q,J)}}_stopAnimationGroup(q,c){c.stop(!0),c.dispose(),this._removeFromCurrentlyRunning(q,c)}_removeFromCurrentlyRunning(q,c){const U=q._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),J=U.indexOf(c.uniqueId);-1!==J&&(U.splice(J,1),q._setGlobalContextVariable("currentlyRunningAnimationGroups",U))}_cancelPendingTasks(q){const c=this.currentAnimationGroup.getValue(q);c&&this._stopAnimationGroup(q,c)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,s.f)("FlowGraphPlayAnimationBlock",X)}}]);