"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14303:(Z,c,L)=>{L.r(c),L.d(c,{FlowGraphPlayAnimationBlock:()=>V});var k=L(12870),N=L(12825),R=L(11012),G=L(14296);class V extends k.d{constructor(Z){super(Z,["animationLoop","animationEnd","animationGroupLoop"]),this.config=Z,this.speed=this.registerDataInput("speed",N.t),this.loop=this.registerDataInput("loop",N.g),this.from=this.registerDataInput("from",N.t,0),this.to=this.registerDataInput("to",N.t),this.currentFrame=this.registerDataOutput("currentFrame",N.t),this.currentTime=this.registerDataOutput("currentTime",N.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",N.e),this.animationGroup=this.registerDataInput("animationGroup",N.e,null===Z||void 0===Z?void 0:Z.animationGroup),this.animation=this.registerDataInput("animation",N.e),this.object=this.registerDataInput("object",N.e)}_preparePendingTasks(Z){const c=this.animationGroup.getValue(Z),L=this.animation.getValue(Z);if(!c&&!L)return this._reportError(Z,"No animation or animation group provided");{const N=this.currentAnimationGroup.getValue(Z);N&&N!==c&&N.dispose();let R=c;if(L&&!R){const c=this.object.getValue(Z);if(!c)return this._reportError(Z,"No target object provided");const k=Array.isArray(L)?L:[L],N=k[0].name;R=new G.AnimationGroup("flowGraphAnimationGroup-"+N+"-"+c.name,Z.configuration.LL);let V=!1;const p=Z._getGlobalContextVariable("interpolationAnimations",[]);for(const Z of k)R.addTargetedAnimation(Z,c),-1!==p.indexOf(Z.uniqueId)&&(V=!0);V&&this._checkInterpolationDuplications(Z,k,c)}const V=this.speed.getValue(Z)||1,p=this.from.getValue(Z)??0,J=this.to.getValue(Z)||R.to,z=!isFinite(J)||this.loop.getValue(Z);this.currentAnimationGroup.setValue(R,Z);const i=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==i.indexOf(R.uniqueId)&&R.stop();try{R.start(z,V,p,J),R.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(Z))),R.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(Z))),R.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(Z))),R.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(Z))),i.push(R.uniqueId),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",i)}catch(k){this._reportError(Z,k)}}}_reportError(Z,c){super._reportError(Z,c),this.currentFrame.setValue(-1,Z),this.currentTime.setValue(-1,Z)}_executeOnTick(Z){const c=this.currentAnimationGroup.getValue(Z);var L;c&&(this.currentFrame.setValue(c.getCurrentFrame(),Z),this.currentTime.setValue((null===(L=c.animatables[0])||void 0===L?void 0:L.elapsedTime)??0,Z))}_execute(Z){this._startPendingTasks(Z)}_onAnimationGroupEnd(Z){this._removeFromCurrentlyRunning(Z,this.currentAnimationGroup.getValue(Z)),this._resetAfterCanceled(Z),this.done._activateSignal(Z)}_checkInterpolationDuplications(Z,c,L){const k=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const N of k){const k=Z.assetsContext.animationGroups.find((Z=>Z.uniqueId===N));if(k)for(const N of k.targetedAnimations)for(const R of c)N.animation.targetProperty===R.targetProperty&&N.target===L&&this._stopAnimationGroup(Z,k)}}_stopAnimationGroup(Z,c){c.stop(!0),c.dispose(),this._removeFromCurrentlyRunning(Z,c)}_removeFromCurrentlyRunning(Z,c){const L=Z._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),k=L.indexOf(c.uniqueId);-1!==k&&(L.splice(k,1),Z._setGlobalContextVariable("currentlyRunningAnimationGroups",L))}_cancelPendingTasks(Z){const c=this.currentAnimationGroup.getValue(Z);c&&this._stopAnimationGroup(Z,c)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,R.g)("FlowGraphPlayAnimationBlock",V)}}]);