"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[59],{14482:(G,V,W)=>{W.r(V),W.d(V,{FlowGraphPlayAnimationBlock:()=>z});var J=W(13108),R=W(13071),d=W(11159),k=W(14477);class z extends J.c{constructor(G){super(G,["animationLoop","animationEnd","animationGroupLoop"]),this.config=G,this.speed=this.registerDataInput("speed",R.r),this.loop=this.registerDataInput("loop",R.d),this.from=this.registerDataInput("from",R.r,0),this.to=this.registerDataInput("to",R.r),this.currentFrame=this.registerDataOutput("currentFrame",R.r),this.currentTime=this.registerDataOutput("currentTime",R.r),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",R.b),this.animationGroup=this.registerDataInput("animationGroup",R.b,null===G||void 0===G?void 0:G.animationGroup),this.animation=this.registerDataInput("animation",R.b),this.object=this.registerDataInput("object",R.b)}_preparePendingTasks(G){const V=this.animationGroup.getValue(G),W=this.animation.getValue(G);if(!V&&!W)return this._reportError(G,"No animation or animation group provided");{const R=this.currentAnimationGroup.getValue(G);R&&R!==V&&R.dispose();let d=V;if(W&&!d){const V=this.object.getValue(G);if(!V)return this._reportError(G,"No target object provided");const J=Array.isArray(W)?W:[W],R=J[0].name;d=new k.AnimationGroup("flowGraphAnimationGroup-"+R+"-"+V.name,G.configuration.tV);let z=!1;const X=G._getGlobalContextVariable("interpolationAnimations",[]);for(const G of J)d.addTargetedAnimation(G,V),-1!==X.indexOf(G.uniqueId)&&(z=!0);z&&this._checkInterpolationDuplications(G,J,V)}const z=this.speed.getValue(G)||1,X=this.from.getValue(G)??0,P=this.to.getValue(G)||d.to,A=!isFinite(P)||this.loop.getValue(G);this.currentAnimationGroup.setValue(d,G);const x=G._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==x.indexOf(d.uniqueId)&&d.stop();try{d.start(A,z,X,P),d.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(G))),d.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(G))),d.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(G))),d.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(G))),x.push(d.uniqueId),G._setGlobalContextVariable("currentlyRunningAnimationGroups",x)}catch(J){this._reportError(G,J)}}}_reportError(G,V){super._reportError(G,V),this.currentFrame.setValue(-1,G),this.currentTime.setValue(-1,G)}_executeOnTick(G){const V=this.currentAnimationGroup.getValue(G);var W;V&&(this.currentFrame.setValue(V.getCurrentFrame(),G),this.currentTime.setValue((null===(W=V.animatables[0])||void 0===W?void 0:W.elapsedTime)??0,G))}_execute(G){this._startPendingTasks(G)}_onAnimationGroupEnd(G){this._removeFromCurrentlyRunning(G,this.currentAnimationGroup.getValue(G)),this._resetAfterCanceled(G),this.done._activateSignal(G)}_checkInterpolationDuplications(G,V,W){const J=G._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const R of J){const J=G.assetsContext.animationGroups.find((G=>G.uniqueId===R));if(J)for(const R of J.targetedAnimations)for(const d of V)R.animation.targetProperty===d.targetProperty&&R.target===W&&this._stopAnimationGroup(G,J)}}_stopAnimationGroup(G,V){V.stop(!0),V.dispose(),this._removeFromCurrentlyRunning(G,V)}_removeFromCurrentlyRunning(G,V){const W=G._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),J=W.indexOf(V.uniqueId);-1!==J&&(W.splice(J,1),G._setGlobalContextVariable("currentlyRunningAnimationGroups",W))}_cancelPendingTasks(G){const V=this.currentAnimationGroup.getValue(G);V&&this._stopAnimationGroup(G,V)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,d.d)("FlowGraphPlayAnimationBlock",z)}}]);