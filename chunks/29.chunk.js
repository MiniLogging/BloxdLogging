"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[29],{14568:(h,R,l)=>{var j=l(12835),a=l(12711),D=l(12758),U=l(12855),F=l(12797),w=l(12842);F.c.prototype._partialLoadFile=function(h,R,l,j){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(h,(h=>{l[R]=h,l._internalCount++,6===l._internalCount&&j(l)}),void 0,void 0,!0,((h,R)=>{a&&h&&a(h.status+" "+h.statusText,R)}))},F.c.prototype._cascadeLoadFiles=function(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const a=[];a._internalCount=0;for(let D=0;D<6;D++)this._partialLoadFile(l[D],D,a,R,j)},F.c.prototype._cascadeLoadImgs=function(h,R,l,j){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,D=arguments.length>5?arguments[5]:void 0;const U=[];U._internalCount=0;for(let F=0;F<6;F++)this._partialLoadImg(j[F],F,U,h,R,l,a,D)},F.c.prototype._partialLoadImg=function(h,R,l,j,a,F){let w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,mh=arguments.length>7?arguments[7]:void 0;const u=(0,U.e)();(0,D.l)(h,(h=>{l[R]=h,l._internalCount++,j&&j.removePendingData(u),6===l._internalCount&&F&&F(a,l)}),((h,R)=>{j&&j.removePendingData(u),w&&w(h,R)}),j?j.offlineProvider:null,mh),j&&j.addPendingData(u)},F.c.prototype.createCubeTextureBase=function(h,R,l,D){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,mh=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,c=arguments.length>8&&void 0!==arguments[8]&&arguments[8],J=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Q=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,Y=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,s=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,t=arguments.length>14&&void 0!==arguments[14]&&arguments[14],f=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const T=Q||new j.e(this,7);T.isCube=!0,T.url=h,T.generateMipMaps=!D,T._lodGenerationScale=J,T._lodGenerationOffset=q,T._useSRGBBuffer=!!t&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!D),T!==Q&&(T.label=h.substring(0,60)),this._doNotHandleContextLost||(T._extension=u,T._files=l,T._buffer=f);const E=h;this._transformTextureUrl&&!Q&&(h=this._transformTextureUrl(h));const x=u??function(h){const R=h.split("?")[0],l=R.lastIndexOf(".");return l>-1?R.substring(l).toLowerCase():""}(h),G=(0,w.e)(x),p=(h,R)=>{T.dispose(),F?F(h,R):h&&a.c.Warn(h)},O=(j,F)=>{h===E?j&&p(j.status+" "+j.statusText,F):(a.c.Warn(`Failed to load ${h}, falling back to the ${E}`),this.createCubeTextureBase(E,R,l,!!D,U,p,mh,u,c,J,q,T,Y,s,t,f))};if(G)G.then((j=>{const a=h=>{Y&&Y(T,h),j.loadCubeData(h,T,c,U,((h,R)=>{p(h,R)}))};f?a(f):l&&6===l.length?j.supportCascades?this._cascadeLoadFiles(R,(h=>a(h.map((h=>new Uint8Array(h))))),l,p):p("Textures type does not support cascades."):this._loadFile(h,(h=>a(new Uint8Array(h))),void 0,void 0,!0,O)}));else{if(!l||0===l.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(R,T,((h,R)=>{s&&s(h,R)}),l,p)}return this._internalTexturesCache.push(T),T}},13393:(h,R,l)=>{l.d(R,{b:()=>mh});var j=l(12900),a=l(12917),D=l(13075),U=l(12902),F=l(12952);class w{constructor(h,R,l,j){this.name=h,this.worldAxisForNormal=R,this.worldAxisForFileX=l,this.worldAxisForFileY=j}}class mh{static ConvertCubeMapTextureToSphericalPolynomial(h){var R;if(!h.isCube)return null;null===(R=h.yh())||void 0===R||R.getEngine().flushFramebuffer();const l=h.getSize().width,j=h.readPixels(0,void 0,void 0,!1),a=h.readPixels(1,void 0,void 0,!1);let D,U;h.isRenderTarget?(D=h.readPixels(3,void 0,void 0,!1),U=h.readPixels(2,void 0,void 0,!1)):(D=h.readPixels(2,void 0,void 0,!1),U=h.readPixels(3,void 0,void 0,!1));const F=h.readPixels(4,void 0,void 0,!1),w=h.readPixels(5,void 0,void 0,!1),mh=h.gammaSpace;let u=0;return 1!=h.textureType&&2!=h.textureType||(u=1),new Promise((h=>{Promise.all([a,j,D,U,F,w]).then((R=>{let[j,a,D,U,F,w]=R;const c={size:l,right:a,left:j,up:D,down:U,front:F,back:w,format:5,type:u,gammaSpace:mh};h(this.ConvertCubeMapToSphericalPolynomial(c))}))}))}static _AreaElement(h,R){return Math.atan2(h*R,Math.sqrt(h*h+R*R+1))}static ConvertCubeMapToSphericalPolynomial(h){const R=new D.b;let l=0;const j=2/h.size,w=j,mh=.5*j,u=mh-1;for(let D=0;D<6;D++){const c=this._FileFaces[D],J=h[c.name];let q=u;const Q=5===h.format?4:3;for(let D=0;D<h.size;D++){let Y=u;for(let w=0;w<h.size;w++){const u=c.worldAxisForFileX.scale(Y).add(c.worldAxisForFileY.scale(q)).add(c.worldAxisForNormal);u.normalize();const s=this._AreaElement(Y-mh,q-mh)-this._AreaElement(Y-mh,q+mh)-this._AreaElement(Y+mh,q-mh)+this._AreaElement(Y+mh,q+mh);let t=J[D*h.size*Q+w*Q+0],f=J[D*h.size*Q+w*Q+1],T=J[D*h.size*Q+w*Q+2];isNaN(t)&&(t=0),isNaN(f)&&(f=0),isNaN(T)&&(T=0),0===h.type&&(t/=255,f/=255,T/=255),h.gammaSpace&&(t=Math.pow((0,a.Clamp)(t),U.j),f=Math.pow((0,a.Clamp)(f),U.j),T=Math.pow((0,a.Clamp)(T),U.j));const E=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const h=Math.max(t,f,T);if(h>E){const R=E/h;t*=R,f*=R,T*=R}}else t=(0,a.Clamp)(t,0,E),f=(0,a.Clamp)(f,0,E),T=(0,a.Clamp)(T,0,E);const x=new F.xR(t,f,T);R.addLight(u,x,s),l+=s,Y+=j}q+=w}}const c=6*(4*Math.PI)/6/l;return R.scaleInPlace(c),R.convertIncidentRadianceToIrradiance(),R.convertIrradianceToLambertianRadiance(),D.f.FromHarmonics(R)}}mh._FileFaces=[new w("right",new j.tR(1,0,0),new j.tR(0,0,-1),new j.tR(0,-1,0)),new w("left",new j.tR(-1,0,0),new j.tR(0,0,1),new j.tR(0,-1,0)),new w("up",new j.tR(0,1,0),new j.tR(1,0,0),new j.tR(0,0,1)),new w("down",new j.tR(0,-1,0),new j.tR(1,0,0),new j.tR(0,0,-1)),new w("front",new j.tR(0,0,1),new j.tR(1,0,0),new j.tR(0,-1,0)),new w("back",new j.tR(0,0,-1),new j.tR(-1,0,0),new j.tR(0,-1,0))],mh.MAX_HDRI_VALUE=4096,mh.PRESERVE_CLAMPED_COLORS=!1},15360:(h,R,l)=>{l.d(R,{DDSTools:()=>Q});var j=l(12917),a=l(12711),D=l(13393),U=l(13112);l(14568);const F=131072,w=131072;function mh(h){return h.charCodeAt(0)+(h.charCodeAt(1)<<8)+(h.charCodeAt(2)<<16)+(h.charCodeAt(3)<<24)}const u=mh("DXT1"),c=mh("DXT3"),J=mh("DXT5"),q=mh("DX10");class Q{static GetDDSInfo(h){const R=new Int32Array(h.buffer,h.byteOffset,31),l=new Int32Array(h.buffer,h.byteOffset,35);let j=1;R[2]&F&&(j=Math.max(1,R[7]));const a=R[21],D=a===q?l[32]:0;let U=0;switch(a){case 113:U=2;break;case 116:U=1;break;case q:if(10===D){U=2;break}if(2===D){U=1;break}}return{width:R[4],height:R[3],mipmapCount:j,isFourCC:4===(4&R[20]),isRGB:64===(64&R[20]),isLuminance:(R[20]&w)===w,isCube:512===(512&R[28]),isCompressed:a===u||a===c||a===J,dxgiFormat:D,textureType:U}}static _GetHalfFloatAsFloatRGBAArrayBuffer(h,R,l,j,a,D){const F=new Float32Array(j),w=new Uint16Array(a,l);let mh=0;for(let u=0;u<R;u++)for(let R=0;R<h;R++){const l=4*(R+u*h);F[mh]=(0,U.e)(w[l]),F[mh+1]=(0,U.e)(w[l+1]),F[mh+2]=(0,U.e)(w[l+2]),Q.StoreLODInAlphaChannel?F[mh+3]=D:F[mh+3]=(0,U.e)(w[l+3]),mh+=4}return F}static _GetHalfFloatRGBAArrayBuffer(h,R,l,j,a,D){if(Q.StoreLODInAlphaChannel){const F=new Uint16Array(j),w=new Uint16Array(a,l);let mh=0;for(let l=0;l<R;l++)for(let R=0;R<h;R++){const j=4*(R+l*h);F[mh]=w[j],F[mh+1]=w[j+1],F[mh+2]=w[j+2],F[mh+3]=(0,U.i)(D),mh+=4}return F}return new Uint16Array(a,l,j)}static _GetFloatRGBAArrayBuffer(h,R,l,j,a,D){if(Q.StoreLODInAlphaChannel){const U=new Float32Array(j),F=new Float32Array(a,l);let w=0;for(let l=0;l<R;l++)for(let R=0;R<h;R++){const j=4*(R+l*h);U[w]=F[j],U[w+1]=F[j+1],U[w+2]=F[j+2],U[w+3]=D,w+=4}return U}return new Float32Array(a,l,j)}static _GetFloatAsHalfFloatRGBAArrayBuffer(h,R,l,j,a,D){const F=new Uint16Array(j),w=new Float32Array(a,l);let mh=0;for(let u=0;u<R;u++)for(let R=0;R<h;R++)F[mh]=(0,U.i)(w[mh]),F[mh+1]=(0,U.i)(w[mh+1]),F[mh+2]=(0,U.i)(w[mh+2]),Q.StoreLODInAlphaChannel?F[mh+3]=(0,U.i)(D):F[mh+3]=(0,U.i)(w[mh+3]),mh+=4;return F}static _GetFloatAsUIntRGBAArrayBuffer(h,R,l,a,D,U){const F=new Uint8Array(a),w=new Float32Array(D,l);let mh=0;for(let u=0;u<R;u++)for(let R=0;R<h;R++){const l=4*(R+u*h);F[mh]=255*(0,j.Clamp)(w[l]),F[mh+1]=255*(0,j.Clamp)(w[l+1]),F[mh+2]=255*(0,j.Clamp)(w[l+2]),Q.StoreLODInAlphaChannel?F[mh+3]=U:F[mh+3]=255*(0,j.Clamp)(w[l+3]),mh+=4}return F}static _GetHalfFloatAsUIntRGBAArrayBuffer(h,R,l,a,D,F){const w=new Uint8Array(a),mh=new Uint16Array(D,l);let u=0;for(let c=0;c<R;c++)for(let R=0;R<h;R++){const l=4*(R+c*h);w[u]=255*(0,j.Clamp)((0,U.e)(mh[l])),w[u+1]=255*(0,j.Clamp)((0,U.e)(mh[l+1])),w[u+2]=255*(0,j.Clamp)((0,U.e)(mh[l+2])),Q.StoreLODInAlphaChannel?w[u+3]=F:w[u+3]=255*(0,j.Clamp)((0,U.e)(mh[l+3])),u+=4}return w}static _GetRGBAArrayBuffer(h,R,l,j,a,D,U,F,w){const mh=new Uint8Array(j),u=new Uint8Array(a,l);let c=0;for(let J=0;J<R;J++)for(let R=0;R<h;R++){const l=4*(R+J*h);mh[c]=u[l+D],mh[c+1]=u[l+U],mh[c+2]=u[l+F],mh[c+3]=u[l+w],c+=4}return mh}static _ExtractLongWordOrder(h){return 0===h||255===h||-16777216===h?0:1+Q._ExtractLongWordOrder(h>>8)}static _GetRGBArrayBuffer(h,R,l,j,a,D,U,F){const w=new Uint8Array(j),mh=new Uint8Array(a,l);let u=0;for(let c=0;c<R;c++)for(let R=0;R<h;R++){const l=3*(R+c*h);w[u]=mh[l+D],w[u+1]=mh[l+U],w[u+2]=mh[l+F],u+=3}return w}static _GetLuminanceArrayBuffer(h,R,l,j,a){const D=new Uint8Array(j),U=new Uint8Array(a,l);let F=0;for(let w=0;w<R;w++)for(let R=0;R<h;R++){const l=R+w*h;D[F]=U[l],F++}return D}static UploadDDSLevels(h,R,l,j,U,w){let mh=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,Y=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=null;j.sphericalPolynomial&&(t=[]);const f=!!h.getCaps().s3tc;R.generateMipMaps=U;const T=new Int32Array(l.buffer,l.byteOffset,31);let E,x,G,p,O,y,v,b=0,I=0,L=1;if(542327876!==T[0])return void a.c.Error("Invalid magic number in DDS header");if(!j.isFourCC&&!j.isRGB&&!j.isLuminance)return void a.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(j.isCompressed&&!f)return void a.c.Error("Compressed textures are not supported on this platform.");let n=T[22];p=T[1]+4;let r=!1;if(j.isFourCC)switch(E=T[21],E){case u:L=8,I=33777;break;case c:L=16,I=33778;break;case J:L=16,I=33779;break;case 113:r=!0,n=64;break;case 116:r=!0,n=128;break;case q:{p+=20;let h=!1;switch(j.dxgiFormat){case 10:r=!0,n=64,h=!0;break;case 2:r=!0,n=128,h=!0;break;case 88:j.isRGB=!0,j.isFourCC=!1,n=32,h=!0}if(h)break}default:return void a.c.Error(["Unsupported FourCC code:",(P=E,String.fromCharCode(255&P,P>>8&255,P>>16&255,P>>24&255))])}var P;const z=Q._ExtractLongWordOrder(T[23]),o=Q._ExtractLongWordOrder(T[24]),K=Q._ExtractLongWordOrder(T[25]),W=Q._ExtractLongWordOrder(T[26]);r&&(I=h._getRGBABufferInternalSizedFormat(j.textureType)),y=1,T[2]&F&&!1!==U&&(y=Math.max(1,T[7]));const g=Y||0,H=h.getCaps();for(let a=g;a<w;a++){for(x=T[4],G=T[3],v=0;v<y;++v){if(-1===mh||mh===v){const D=-1===mh?v:0;if(!j.isCompressed&&j.isFourCC){R.format=5,b=x*G*4;let j=null;if(h._badOS||h._badDesktopOS||!H.textureHalfFloat&&!H.textureFloat)128===n?(j=Q._GetFloatAsUIntRGBAArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,D),t&&0==D&&t.push(Q._GetFloatRGBAArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,D))):64===n&&(j=Q._GetHalfFloatAsUIntRGBAArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,D),t&&0==D&&t.push(Q._GetHalfFloatAsFloatRGBAArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,D))),R.type=0;else{const h=H.textureFloat&&(s&&H.textureFloatLinearFiltering||!s),a=H.textureHalfFloat&&(s&&H.textureHalfFloatLinearFiltering||!s),U=(128===n||64===n&&!a)&&h?1:(64===n||128===n&&!h)&&a?2:0;let F,w=null;if(128===n)switch(U){case 1:F=Q._GetFloatRGBAArrayBuffer,w=null;break;case 2:F=Q._GetFloatAsHalfFloatRGBAArrayBuffer,w=Q._GetFloatRGBAArrayBuffer;break;case 0:F=Q._GetFloatAsUIntRGBAArrayBuffer,w=Q._GetFloatRGBAArrayBuffer}else switch(U){case 1:F=Q._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:F=Q._GetHalfFloatRGBAArrayBuffer,w=Q._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:F=Q._GetHalfFloatAsUIntRGBAArrayBuffer,w=Q._GetHalfFloatAsFloatRGBAArrayBuffer}R.type=U,j=F(x,G,l.byteOffset+p,b,l.buffer,D),t&&0==D&&t.push(w?w(x,G,l.byteOffset+p,b,l.buffer,D):j)}j&&h._uploadDataToTextureDirectly(R,j,a,D)}else if(j.isRGB)R.type=0,24===n?(R.format=4,b=x*G*3,O=Q._GetRGBArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,z,o,K),h._uploadDataToTextureDirectly(R,O,a,D)):(R.format=5,b=x*G*4,O=Q._GetRGBAArrayBuffer(x,G,l.byteOffset+p,b,l.buffer,z,o,K,W),h._uploadDataToTextureDirectly(R,O,a,D));else if(j.isLuminance){const j=h._getUnpackAlignement(),U=x;b=Math.floor((x+j-1)/j)*j*(G-1)+U,O=Q._GetLuminanceArrayBuffer(x,G,l.byteOffset+p,b,l.buffer),R.format=1,R.type=0,h._uploadDataToTextureDirectly(R,O,a,D)}else b=Math.max(4,x)/4*Math.max(4,G)/4*L,O=new Uint8Array(l.buffer,l.byteOffset+p,b),R.type=0,h._uploadCompressedDataToTextureDirectly(R,I,x,G,O,a,D)}p+=n?x*G*(n/8):b,x*=.5,G*=.5,x=Math.max(1,x),G=Math.max(1,G)}if(void 0!==Y)break}t&&t.length>0?j.sphericalPolynomial=D.b.ConvertCubeMapToSphericalPolynomial({size:T[4],right:t[0],left:t[1],up:t[2],down:t[3],front:t[4],back:t[5],format:5,type:1,gammaSpace:!1}):j.sphericalPolynomial=void 0}}Q.StoreLODInAlphaChannel=!1}}]);