"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[29],{13027:(m,S,h)=>{var l=h(11262),M=h(11173),O=h(11205),u=h(11302),b=h(11229),q=h(11278);b.b.prototype._partialLoadFile=function(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(m,(m=>{h[S]=m,h._internalCount++,6===h._internalCount&&l(h)}),void 0,void 0,!0,((m,S)=>{M&&m&&M(m.status+" "+m.statusText,S)}))},b.b.prototype._cascadeLoadFiles=function(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const M=[];M._internalCount=0;for(let O=0;O<6;O++)this._partialLoadFile(h[O],O,M,S,l)},b.b.prototype._cascadeLoadImgs=function(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,O=arguments.length>5?arguments[5]:void 0;const u=[];u._internalCount=0;for(let b=0;b<6;b++)this._partialLoadImg(l[b],b,u,m,S,h,M,O)},b.b.prototype._partialLoadImg=function(m,S,h,l,M,b){let q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,Y=arguments.length>7?arguments[7]:void 0;const V=(0,u.b)();(0,O.u)(m,(m=>{h[S]=m,h._internalCount++,l&&l.removePendingData(V),6===h._internalCount&&b&&b(M,h)}),((m,S)=>{l&&l.removePendingData(V),q&&q(m,S)}),l?l.offlineProvider:null,Y),l&&l.addPendingData(V)},b.b.prototype.createCubeTextureBase=function(m,S,h,O){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,Y=arguments.length>6?arguments[6]:void 0,V=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,I=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,C=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,B=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,D=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,E=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,n=arguments.length>14&&void 0!==arguments[14]&&arguments[14],L=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const U=B||new l.d(this,7);U.isCube=!0,U.url=m,U.generateMipMaps=!O,U._lodGenerationScale=Z,U._lodGenerationOffset=C,U._useSRGBBuffer=!!n&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!O),U!==B&&(U.label=m.substring(0,60)),this._doNotHandleContextLost||(U._extension=V,U._files=h,U._buffer=L);const H=m;this._transformTextureUrl&&!B&&(m=this._transformTextureUrl(m));const R=V??function(m){const S=m.split("?")[0],h=S.lastIndexOf(".");return h>-1?S.substring(h).toLowerCase():""}(m),y=(0,q.c)(R),o=(m,S)=>{U.dispose(),b?b(m,S):m&&M.e.Warn(m)},s=(l,b)=>{m===H?l&&o(l.status+" "+l.statusText,b):(M.e.Warn(`Failed to load ${m}, falling back to the ${H}`),this.createCubeTextureBase(H,S,h,!!O,u,o,Y,V,I,Z,C,U,D,E,n,L))};if(y)y.then((l=>{const M=m=>{D&&D(U,m),l.loadCubeData(m,U,I,u,((m,S)=>{o(m,S)}))};L?M(L):h&&6===h.length?l.supportCascades?this._cascadeLoadFiles(S,(m=>M(m.map((m=>new Uint8Array(m))))),h,o):o("Textures type does not support cascades."):this._loadFile(m,(m=>M(new Uint8Array(m))),void 0,void 0,!0,s)}));else{if(!h||0===h.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(S,U,((m,S)=>{E&&E(m,S)}),h,o)}return this._internalTexturesCache.push(U),U}},11829:(m,S,h)=>{h.d(S,{b:()=>Y});var l=h(11347),M=h(11359),O=h(11520),u=h(11350),b=h(11387);class q{constructor(m,S,h,l){this.name=m,this.worldAxisForNormal=S,this.worldAxisForFileX=h,this.worldAxisForFileY=l}}class Y{static ConvertCubeMapTextureToSphericalPolynomial(m){var S;if(!m.isCube)return null;null===(S=m.sm())||void 0===S||S.getEngine().flushFramebuffer();const h=m.getSize().width,l=m.readPixels(0,void 0,void 0,!1),M=m.readPixels(1,void 0,void 0,!1);let O,u;m.isRenderTarget?(O=m.readPixels(3,void 0,void 0,!1),u=m.readPixels(2,void 0,void 0,!1)):(O=m.readPixels(2,void 0,void 0,!1),u=m.readPixels(3,void 0,void 0,!1));const b=m.readPixels(4,void 0,void 0,!1),q=m.readPixels(5,void 0,void 0,!1),Y=m.gammaSpace;let V=0;return 1!=m.textureType&&2!=m.textureType||(V=1),new Promise((m=>{Promise.all([M,l,O,u,b,q]).then((S=>{let[l,M,O,u,b,q]=S;const I={size:h,right:M,left:l,up:O,down:u,front:b,back:q,format:5,type:V,gammaSpace:Y};m(this.ConvertCubeMapToSphericalPolynomial(I))}))}))}static _AreaElement(m,S){return Math.atan2(m*S,Math.sqrt(m*m+S*S+1))}static ConvertCubeMapToSphericalPolynomial(m){const S=new O.e;let h=0;const l=2/m.size,q=l,Y=.5*l,V=Y-1;for(let O=0;O<6;O++){const I=this._FileFaces[O],Z=m[I.name];let C=V;const B=5===m.format?4:3;for(let O=0;O<m.size;O++){let D=V;for(let q=0;q<m.size;q++){const V=I.worldAxisForFileX.scale(D).add(I.worldAxisForFileY.scale(C)).add(I.worldAxisForNormal);V.normalize();const E=this._AreaElement(D-Y,C-Y)-this._AreaElement(D-Y,C+Y)-this._AreaElement(D+Y,C-Y)+this._AreaElement(D+Y,C+Y);let n=Z[O*m.size*B+q*B+0],L=Z[O*m.size*B+q*B+1],U=Z[O*m.size*B+q*B+2];isNaN(n)&&(n=0),isNaN(L)&&(L=0),isNaN(U)&&(U=0),0===m.type&&(n/=255,L/=255,U/=255),m.gammaSpace&&(n=Math.pow((0,M.Clamp)(n),u.h),L=Math.pow((0,M.Clamp)(L),u.h),U=Math.pow((0,M.Clamp)(U),u.h));const H=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const m=Math.max(n,L,U);if(m>H){const S=H/m;n*=S,L*=S,U*=S}}else n=(0,M.Clamp)(n,0,H),L=(0,M.Clamp)(L,0,H),U=(0,M.Clamp)(U,0,H);const R=new b.RS(n,L,U);S.addLight(V,R,E),h+=E,D+=l}C+=q}}const I=6*(4*Math.PI)/6/h;return S.scaleInPlace(I),S.convertIncidentRadianceToIrradiance(),S.convertIrradianceToLambertianRadiance(),O.i.FromHarmonics(S)}}Y._FileFaces=[new q("right",new l.nS(1,0,0),new l.nS(0,0,-1),new l.nS(0,-1,0)),new q("left",new l.nS(-1,0,0),new l.nS(0,0,1),new l.nS(0,-1,0)),new q("up",new l.nS(0,1,0),new l.nS(1,0,0),new l.nS(0,0,1)),new q("down",new l.nS(0,-1,0),new l.nS(1,0,0),new l.nS(0,0,-1)),new q("front",new l.nS(0,0,1),new l.nS(1,0,0),new l.nS(0,-1,0)),new q("back",new l.nS(0,0,-1),new l.nS(-1,0,0),new l.nS(0,-1,0))],Y.MAX_HDRI_VALUE=4096,Y.PRESERVE_CLAMPED_COLORS=!1},13823:(m,S,h)=>{h.d(S,{DDSTools:()=>B});var l=h(11359),M=h(11173),O=h(11829),u=h(11556);h(13027);const b=131072,q=131072;function Y(m){return m.charCodeAt(0)+(m.charCodeAt(1)<<8)+(m.charCodeAt(2)<<16)+(m.charCodeAt(3)<<24)}const V=Y("DXT1"),I=Y("DXT3"),Z=Y("DXT5"),C=Y("DX10");class B{static GetDDSInfo(m){const S=new Int32Array(m.buffer,m.byteOffset,31),h=new Int32Array(m.buffer,m.byteOffset,35);let l=1;S[2]&b&&(l=Math.max(1,S[7]));const M=S[21],O=M===C?h[32]:0;let u=0;switch(M){case 113:u=2;break;case 116:u=1;break;case C:if(10===O){u=2;break}if(2===O){u=1;break}}return{width:S[4],height:S[3],mipmapCount:l,isFourCC:4===(4&S[20]),isRGB:64===(64&S[20]),isLuminance:(S[20]&q)===q,isCube:512===(512&S[28]),isCompressed:M===V||M===I||M===Z,dxgiFormat:O,textureType:u}}static _GetHalfFloatAsFloatRGBAArrayBuffer(m,S,h,l,M,O){const b=new Float32Array(l),q=new Uint16Array(M,h);let Y=0;for(let V=0;V<S;V++)for(let S=0;S<m;S++){const h=4*(S+V*m);b[Y]=(0,u.f)(q[h]),b[Y+1]=(0,u.f)(q[h+1]),b[Y+2]=(0,u.f)(q[h+2]),B.StoreLODInAlphaChannel?b[Y+3]=O:b[Y+3]=(0,u.f)(q[h+3]),Y+=4}return b}static _GetHalfFloatRGBAArrayBuffer(m,S,h,l,M,O){if(B.StoreLODInAlphaChannel){const b=new Uint16Array(l),q=new Uint16Array(M,h);let Y=0;for(let h=0;h<S;h++)for(let S=0;S<m;S++){const l=4*(S+h*m);b[Y]=q[l],b[Y+1]=q[l+1],b[Y+2]=q[l+2],b[Y+3]=(0,u.n)(O),Y+=4}return b}return new Uint16Array(M,h,l)}static _GetFloatRGBAArrayBuffer(m,S,h,l,M,O){if(B.StoreLODInAlphaChannel){const u=new Float32Array(l),b=new Float32Array(M,h);let q=0;for(let h=0;h<S;h++)for(let S=0;S<m;S++){const l=4*(S+h*m);u[q]=b[l],u[q+1]=b[l+1],u[q+2]=b[l+2],u[q+3]=O,q+=4}return u}return new Float32Array(M,h,l)}static _GetFloatAsHalfFloatRGBAArrayBuffer(m,S,h,l,M,O){const b=new Uint16Array(l),q=new Float32Array(M,h);let Y=0;for(let V=0;V<S;V++)for(let S=0;S<m;S++)b[Y]=(0,u.n)(q[Y]),b[Y+1]=(0,u.n)(q[Y+1]),b[Y+2]=(0,u.n)(q[Y+2]),B.StoreLODInAlphaChannel?b[Y+3]=(0,u.n)(O):b[Y+3]=(0,u.n)(q[Y+3]),Y+=4;return b}static _GetFloatAsUIntRGBAArrayBuffer(m,S,h,M,O,u){const b=new Uint8Array(M),q=new Float32Array(O,h);let Y=0;for(let V=0;V<S;V++)for(let S=0;S<m;S++){const h=4*(S+V*m);b[Y]=255*(0,l.Clamp)(q[h]),b[Y+1]=255*(0,l.Clamp)(q[h+1]),b[Y+2]=255*(0,l.Clamp)(q[h+2]),B.StoreLODInAlphaChannel?b[Y+3]=u:b[Y+3]=255*(0,l.Clamp)(q[h+3]),Y+=4}return b}static _GetHalfFloatAsUIntRGBAArrayBuffer(m,S,h,M,O,b){const q=new Uint8Array(M),Y=new Uint16Array(O,h);let V=0;for(let I=0;I<S;I++)for(let S=0;S<m;S++){const h=4*(S+I*m);q[V]=255*(0,l.Clamp)((0,u.f)(Y[h])),q[V+1]=255*(0,l.Clamp)((0,u.f)(Y[h+1])),q[V+2]=255*(0,l.Clamp)((0,u.f)(Y[h+2])),B.StoreLODInAlphaChannel?q[V+3]=b:q[V+3]=255*(0,l.Clamp)((0,u.f)(Y[h+3])),V+=4}return q}static _GetRGBAArrayBuffer(m,S,h,l,M,O,u,b,q){const Y=new Uint8Array(l),V=new Uint8Array(M,h);let I=0;for(let Z=0;Z<S;Z++)for(let S=0;S<m;S++){const h=4*(S+Z*m);Y[I]=V[h+O],Y[I+1]=V[h+u],Y[I+2]=V[h+b],Y[I+3]=V[h+q],I+=4}return Y}static _ExtractLongWordOrder(m){return 0===m||255===m||-16777216===m?0:1+B._ExtractLongWordOrder(m>>8)}static _GetRGBArrayBuffer(m,S,h,l,M,O,u,b){const q=new Uint8Array(l),Y=new Uint8Array(M,h);let V=0;for(let I=0;I<S;I++)for(let S=0;S<m;S++){const h=3*(S+I*m);q[V]=Y[h+O],q[V+1]=Y[h+u],q[V+2]=Y[h+b],V+=3}return q}static _GetLuminanceArrayBuffer(m,S,h,l,M){const O=new Uint8Array(l),u=new Uint8Array(M,h);let b=0;for(let q=0;q<S;q++)for(let S=0;S<m;S++){const h=S+q*m;O[b]=u[h],b++}return O}static UploadDDSLevels(m,S,h,l,u,q){let Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,D=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],n=null;l.sphericalPolynomial&&(n=[]);const L=!!m.getCaps().s3tc;S.generateMipMaps=u;const U=new Int32Array(h.buffer,h.byteOffset,31);let H,R,y,o,s,v,T,X=0,g=0,G=1;if(542327876!==U[0])return void M.e.Error("Invalid magic number in DDS header");if(!l.isFourCC&&!l.isRGB&&!l.isLuminance)return void M.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(l.isCompressed&&!L)return void M.e.Error("Compressed textures are not supported on this platform.");let e=U[22];o=U[1]+4;let a=!1;if(l.isFourCC)switch(H=U[21],H){case V:G=8,g=33777;break;case I:G=16,g=33778;break;case Z:G=16,g=33779;break;case 113:a=!0,e=64;break;case 116:a=!0,e=128;break;case C:{o+=20;let m=!1;switch(l.dxgiFormat){case 10:a=!0,e=64,m=!0;break;case 2:a=!0,e=128,m=!0;break;case 88:l.isRGB=!0,l.isFourCC=!1,e=32,m=!0}if(m)break}default:return void M.e.Error(["Unsupported FourCC code:",(x=H,String.fromCharCode(255&x,x>>8&255,x>>16&255,x>>24&255))])}var x;const P=B._ExtractLongWordOrder(U[23]),d=B._ExtractLongWordOrder(U[24]),J=B._ExtractLongWordOrder(U[25]),N=B._ExtractLongWordOrder(U[26]);a&&(g=m._getRGBABufferInternalSizedFormat(l.textureType)),v=1,U[2]&b&&!1!==u&&(v=Math.max(1,U[7]));const j=D||0,K=m.getCaps();for(let M=j;M<q;M++){for(R=U[4],y=U[3],T=0;T<v;++T){if(-1===Y||Y===T){const O=-1===Y?T:0;if(!l.isCompressed&&l.isFourCC){S.format=5,X=R*y*4;let l=null;if(m._badOS||m._badDesktopOS||!K.textureHalfFloat&&!K.textureFloat)128===e?(l=B._GetFloatAsUIntRGBAArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,O),n&&0==O&&n.push(B._GetFloatRGBAArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,O))):64===e&&(l=B._GetHalfFloatAsUIntRGBAArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,O),n&&0==O&&n.push(B._GetHalfFloatAsFloatRGBAArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,O))),S.type=0;else{const m=K.textureFloat&&(E&&K.textureFloatLinearFiltering||!E),M=K.textureHalfFloat&&(E&&K.textureHalfFloatLinearFiltering||!E),u=(128===e||64===e&&!M)&&m?1:(64===e||128===e&&!m)&&M?2:0;let b,q=null;if(128===e)switch(u){case 1:b=B._GetFloatRGBAArrayBuffer,q=null;break;case 2:b=B._GetFloatAsHalfFloatRGBAArrayBuffer,q=B._GetFloatRGBAArrayBuffer;break;case 0:b=B._GetFloatAsUIntRGBAArrayBuffer,q=B._GetFloatRGBAArrayBuffer}else switch(u){case 1:b=B._GetHalfFloatAsFloatRGBAArrayBuffer,q=null;break;case 2:b=B._GetHalfFloatRGBAArrayBuffer,q=B._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:b=B._GetHalfFloatAsUIntRGBAArrayBuffer,q=B._GetHalfFloatAsFloatRGBAArrayBuffer}S.type=u,l=b(R,y,h.byteOffset+o,X,h.buffer,O),n&&0==O&&n.push(q?q(R,y,h.byteOffset+o,X,h.buffer,O):l)}l&&m._uploadDataToTextureDirectly(S,l,M,O)}else if(l.isRGB)S.type=0,24===e?(S.format=4,X=R*y*3,s=B._GetRGBArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,P,d,J),m._uploadDataToTextureDirectly(S,s,M,O)):(S.format=5,X=R*y*4,s=B._GetRGBAArrayBuffer(R,y,h.byteOffset+o,X,h.buffer,P,d,J,N),m._uploadDataToTextureDirectly(S,s,M,O));else if(l.isLuminance){const l=m._getUnpackAlignement(),u=R;X=Math.floor((R+l-1)/l)*l*(y-1)+u,s=B._GetLuminanceArrayBuffer(R,y,h.byteOffset+o,X,h.buffer),S.format=1,S.type=0,m._uploadDataToTextureDirectly(S,s,M,O)}else X=Math.max(4,R)/4*Math.max(4,y)/4*G,s=new Uint8Array(h.buffer,h.byteOffset+o,X),S.type=0,m._uploadCompressedDataToTextureDirectly(S,g,R,y,s,M,O)}o+=e?R*y*(e/8):X,R*=.5,y*=.5,R=Math.max(1,R),y=Math.max(1,y)}if(void 0!==D)break}n&&n.length>0?l.sphericalPolynomial=O.b.ConvertCubeMapToSphericalPolynomial({size:U[4],right:n[0],left:n[1],up:n[2],down:n[3],front:n[4],back:n[5],format:5,type:1,gammaSpace:!1}):l.sphericalPolynomial=void 0}}B.StoreLODInAlphaChannel=!1}}]);