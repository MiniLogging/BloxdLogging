"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[29],{13959:(y,c,A)=>{var l=A(12255),w=A(12161),N=A(12191),p=A(12287),W=A(12220),h=A(12267);W.b.prototype._partialLoadFile=function(y,c,A,l){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(y,(y=>{A[c]=y,A._internalCount++,6===A._internalCount&&l(A)}),void 0,void 0,!0,((y,c)=>{w&&y&&w(y.status+" "+y.statusText,c)}))},W.b.prototype._cascadeLoadFiles=function(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const w=[];w._internalCount=0;for(let N=0;N<6;N++)this._partialLoadFile(A[N],N,w,c,l)},W.b.prototype._cascadeLoadImgs=function(y,c,A,l){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,N=arguments.length>5?arguments[5]:void 0;const p=[];p._internalCount=0;for(let W=0;W<6;W++)this._partialLoadImg(l[W],W,p,y,c,A,w,N)},W.b.prototype._partialLoadImg=function(y,c,A,l,w,W){let h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,I=arguments.length>7?arguments[7]:void 0;const q=(0,p.e)();(0,N.t)(y,(y=>{A[c]=y,A._internalCount++,l&&l.removePendingData(q),6===A._internalCount&&W&&W(w,A)}),((y,c)=>{l&&l.removePendingData(q),h&&h(y,c)}),l?l.offlineProvider:null,I),l&&l.addPendingData(q)},W.b.prototype.createCubeTextureBase=function(y,c,A,N){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,I=arguments.length>6?arguments[6]:void 0,q=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8],O=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,i=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,H=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,P=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,D=arguments.length>14&&void 0!==arguments[14]&&arguments[14],t=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const s=i||new l.c(this,7);s.isCube=!0,s.url=y,s.generateMipMaps=!N,s._lodGenerationScale=O,s._lodGenerationOffset=L,s._useSRGBBuffer=!!D&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!N),s!==i&&(s.label=y.substring(0,60)),this._doNotHandleContextLost||(s._extension=q,s._files=A,s._buffer=t);const B=y;this._transformTextureUrl&&!i&&(y=this._transformTextureUrl(y));const X=q??function(y){const c=y.split("?")[0],A=c.lastIndexOf(".");return A>-1?c.substring(A).toLowerCase():""}(y),C=(0,h.b)(X),K=(y,c)=>{s.dispose(),W?W(y,c):y&&w.c.Warn(y)},my=(l,W)=>{y===B?l&&K(l.status+" "+l.statusText,W):(w.c.Warn(`Failed to load ${y}, falling back to the ${B}`),this.createCubeTextureBase(B,c,A,!!N,p,K,I,q,o,O,L,s,H,P,D,t))};if(C)C.then((l=>{const w=y=>{H&&H(s,y),l.loadCubeData(y,s,o,p,((y,c)=>{K(y,c)}))};t?w(t):A&&6===A.length?l.supportCascades?this._cascadeLoadFiles(c,(y=>w(y.map((y=>new Uint8Array(y))))),A,K):K("Textures type does not support cascades."):this._loadFile(y,(y=>w(new Uint8Array(y))),void 0,void 0,!0,my)}));else{if(!A||0===A.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(c,s,((y,c)=>{P&&P(y,c)}),A,K)}return this._internalTexturesCache.push(s),s}},12839:(y,c,A)=>{A.d(c,{b:()=>I});var l=A(12325),w=A(12340),N=A(12511),p=A(12330),W=A(12375);class h{constructor(y,c,A,l){this.name=y,this.worldAxisForNormal=c,this.worldAxisForFileX=A,this.worldAxisForFileY=l}}class I{static ConvertCubeMapTextureToSphericalPolynomial(y){var c;if(!y.isCube)return null;null===(c=y.mc())||void 0===c||c.getEngine().flushFramebuffer();const A=y.getSize().width,l=y.readPixels(0,void 0,void 0,!1),w=y.readPixels(1,void 0,void 0,!1);let N,p;y.isRenderTarget?(N=y.readPixels(3,void 0,void 0,!1),p=y.readPixels(2,void 0,void 0,!1)):(N=y.readPixels(2,void 0,void 0,!1),p=y.readPixels(3,void 0,void 0,!1));const W=y.readPixels(4,void 0,void 0,!1),h=y.readPixels(5,void 0,void 0,!1),I=y.gammaSpace;let q=0;return 1!=y.textureType&&2!=y.textureType||(q=1),new Promise((y=>{Promise.all([w,l,N,p,W,h]).then((c=>{let[l,w,N,p,W,h]=c;const o={size:A,right:w,left:l,up:N,down:p,front:W,back:h,format:5,type:q,gammaSpace:I};y(this.ConvertCubeMapToSphericalPolynomial(o))}))}))}static _AreaElement(y,c){return Math.atan2(y*c,Math.sqrt(y*y+c*c+1))}static ConvertCubeMapToSphericalPolynomial(y){const c=new N.d;let A=0;const l=2/y.size,h=l,I=.5*l,q=I-1;for(let N=0;N<6;N++){const o=this._FileFaces[N],O=y[o.name];let L=q;const i=5===y.format?4:3;for(let N=0;N<y.size;N++){let H=q;for(let h=0;h<y.size;h++){const q=o.worldAxisForFileX.scale(H).add(o.worldAxisForFileY.scale(L)).add(o.worldAxisForNormal);q.normalize();const P=this._AreaElement(H-I,L-I)-this._AreaElement(H-I,L+I)-this._AreaElement(H+I,L-I)+this._AreaElement(H+I,L+I);let D=O[N*y.size*i+h*i+0],t=O[N*y.size*i+h*i+1],s=O[N*y.size*i+h*i+2];isNaN(D)&&(D=0),isNaN(t)&&(t=0),isNaN(s)&&(s=0),0===y.type&&(D/=255,t/=255,s/=255),y.gammaSpace&&(D=Math.pow((0,w.Clamp)(D),p.j),t=Math.pow((0,w.Clamp)(t),p.j),s=Math.pow((0,w.Clamp)(s),p.j));const B=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const y=Math.max(D,t,s);if(y>B){const c=B/y;D*=c,t*=c,s*=c}}else D=(0,w.Clamp)(D,0,B),t=(0,w.Clamp)(t,0,B),s=(0,w.Clamp)(s,0,B);const X=new W.dc(D,t,s);c.addLight(q,X,P),A+=P,H+=l}L+=h}}const o=6*(4*Math.PI)/6/A;return c.scaleInPlace(o),c.convertIncidentRadianceToIrradiance(),c.convertIrradianceToLambertianRadiance(),N.e.FromHarmonics(c)}}I._FileFaces=[new h("right",new l.gc(1,0,0),new l.gc(0,0,-1),new l.gc(0,-1,0)),new h("left",new l.gc(-1,0,0),new l.gc(0,0,1),new l.gc(0,-1,0)),new h("up",new l.gc(0,1,0),new l.gc(1,0,0),new l.gc(0,0,1)),new h("down",new l.gc(0,-1,0),new l.gc(1,0,0),new l.gc(0,0,-1)),new h("front",new l.gc(0,0,1),new l.gc(1,0,0),new l.gc(0,-1,0)),new h("back",new l.gc(0,0,-1),new l.gc(-1,0,0),new l.gc(0,-1,0))],I.MAX_HDRI_VALUE=4096,I.PRESERVE_CLAMPED_COLORS=!1},14765:(y,c,A)=>{A.d(c,{DDSTools:()=>i});var l=A(12340),w=A(12161),N=A(12839),p=A(12547);A(13959);const W=131072,h=131072;function I(y){return y.charCodeAt(0)+(y.charCodeAt(1)<<8)+(y.charCodeAt(2)<<16)+(y.charCodeAt(3)<<24)}const q=I("DXT1"),o=I("DXT3"),O=I("DXT5"),L=I("DX10");class i{static GetDDSInfo(y){const c=new Int32Array(y.buffer,y.byteOffset,31),A=new Int32Array(y.buffer,y.byteOffset,35);let l=1;c[2]&W&&(l=Math.max(1,c[7]));const w=c[21],N=w===L?A[32]:0;let p=0;switch(w){case 113:p=2;break;case 116:p=1;break;case L:if(10===N){p=2;break}if(2===N){p=1;break}}return{width:c[4],height:c[3],mipmapCount:l,isFourCC:4===(4&c[20]),isRGB:64===(64&c[20]),isLuminance:(c[20]&h)===h,isCube:512===(512&c[28]),isCompressed:w===q||w===o||w===O,dxgiFormat:N,textureType:p}}static _GetHalfFloatAsFloatRGBAArrayBuffer(y,c,A,l,w,N){const W=new Float32Array(l),h=new Uint16Array(w,A);let I=0;for(let q=0;q<c;q++)for(let c=0;c<y;c++){const A=4*(c+q*y);W[I]=(0,p.g)(h[A]),W[I+1]=(0,p.g)(h[A+1]),W[I+2]=(0,p.g)(h[A+2]),i.StoreLODInAlphaChannel?W[I+3]=N:W[I+3]=(0,p.g)(h[A+3]),I+=4}return W}static _GetHalfFloatRGBAArrayBuffer(y,c,A,l,w,N){if(i.StoreLODInAlphaChannel){const W=new Uint16Array(l),h=new Uint16Array(w,A);let I=0;for(let A=0;A<c;A++)for(let c=0;c<y;c++){const l=4*(c+A*y);W[I]=h[l],W[I+1]=h[l+1],W[I+2]=h[l+2],W[I+3]=(0,p.p)(N),I+=4}return W}return new Uint16Array(w,A,l)}static _GetFloatRGBAArrayBuffer(y,c,A,l,w,N){if(i.StoreLODInAlphaChannel){const p=new Float32Array(l),W=new Float32Array(w,A);let h=0;for(let A=0;A<c;A++)for(let c=0;c<y;c++){const l=4*(c+A*y);p[h]=W[l],p[h+1]=W[l+1],p[h+2]=W[l+2],p[h+3]=N,h+=4}return p}return new Float32Array(w,A,l)}static _GetFloatAsHalfFloatRGBAArrayBuffer(y,c,A,l,w,N){const W=new Uint16Array(l),h=new Float32Array(w,A);let I=0;for(let q=0;q<c;q++)for(let c=0;c<y;c++)W[I]=(0,p.p)(h[I]),W[I+1]=(0,p.p)(h[I+1]),W[I+2]=(0,p.p)(h[I+2]),i.StoreLODInAlphaChannel?W[I+3]=(0,p.p)(N):W[I+3]=(0,p.p)(h[I+3]),I+=4;return W}static _GetFloatAsUIntRGBAArrayBuffer(y,c,A,w,N,p){const W=new Uint8Array(w),h=new Float32Array(N,A);let I=0;for(let q=0;q<c;q++)for(let c=0;c<y;c++){const A=4*(c+q*y);W[I]=255*(0,l.Clamp)(h[A]),W[I+1]=255*(0,l.Clamp)(h[A+1]),W[I+2]=255*(0,l.Clamp)(h[A+2]),i.StoreLODInAlphaChannel?W[I+3]=p:W[I+3]=255*(0,l.Clamp)(h[A+3]),I+=4}return W}static _GetHalfFloatAsUIntRGBAArrayBuffer(y,c,A,w,N,W){const h=new Uint8Array(w),I=new Uint16Array(N,A);let q=0;for(let o=0;o<c;o++)for(let c=0;c<y;c++){const A=4*(c+o*y);h[q]=255*(0,l.Clamp)((0,p.g)(I[A])),h[q+1]=255*(0,l.Clamp)((0,p.g)(I[A+1])),h[q+2]=255*(0,l.Clamp)((0,p.g)(I[A+2])),i.StoreLODInAlphaChannel?h[q+3]=W:h[q+3]=255*(0,l.Clamp)((0,p.g)(I[A+3])),q+=4}return h}static _GetRGBAArrayBuffer(y,c,A,l,w,N,p,W,h){const I=new Uint8Array(l),q=new Uint8Array(w,A);let o=0;for(let O=0;O<c;O++)for(let c=0;c<y;c++){const A=4*(c+O*y);I[o]=q[A+N],I[o+1]=q[A+p],I[o+2]=q[A+W],I[o+3]=q[A+h],o+=4}return I}static _ExtractLongWordOrder(y){return 0===y||255===y||-16777216===y?0:1+i._ExtractLongWordOrder(y>>8)}static _GetRGBArrayBuffer(y,c,A,l,w,N,p,W){const h=new Uint8Array(l),I=new Uint8Array(w,A);let q=0;for(let o=0;o<c;o++)for(let c=0;c<y;c++){const A=3*(c+o*y);h[q]=I[A+N],h[q+1]=I[A+p],h[q+2]=I[A+W],q+=3}return h}static _GetLuminanceArrayBuffer(y,c,A,l,w){const N=new Uint8Array(l),p=new Uint8Array(w,A);let W=0;for(let h=0;h<c;h++)for(let c=0;c<y;c++){const A=c+h*y;N[W]=p[A],W++}return N}static UploadDDSLevels(y,c,A,l,p,h){let I=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,H=arguments.length>7?arguments[7]:void 0,P=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],D=null;l.sphericalPolynomial&&(D=[]);const t=!!y.getCaps().s3tc;c.generateMipMaps=p;const s=new Int32Array(A.buffer,A.byteOffset,31);let B,X,C,K,my,T,z,S=0,M=0,k=1;if(542327876!==s[0])return void w.c.Error("Invalid magic number in DDS header");if(!l.isFourCC&&!l.isRGB&&!l.isLuminance)return void w.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(l.isCompressed&&!t)return void w.c.Error("Compressed textures are not supported on this platform.");let a=s[22];K=s[1]+4;let u=!1;if(l.isFourCC)switch(B=s[21],B){case q:k=8,M=33777;break;case o:k=16,M=33778;break;case O:k=16,M=33779;break;case 113:u=!0,a=64;break;case 116:u=!0,a=128;break;case L:{K+=20;let y=!1;switch(l.dxgiFormat){case 10:u=!0,a=64,y=!0;break;case 2:u=!0,a=128,y=!0;break;case 88:l.isRGB=!0,l.isFourCC=!1,a=32,y=!0}if(y)break}default:return void w.c.Error(["Unsupported FourCC code:",(G=B,String.fromCharCode(255&G,G>>8&255,G>>16&255,G>>24&255))])}var G;const j=i._ExtractLongWordOrder(s[23]),f=i._ExtractLongWordOrder(s[24]),V=i._ExtractLongWordOrder(s[25]),J=i._ExtractLongWordOrder(s[26]);u&&(M=y._getRGBABufferInternalSizedFormat(l.textureType)),T=1,s[2]&W&&!1!==p&&(T=Math.max(1,s[7]));const U=H||0,e=y.getCaps();for(let w=U;w<h;w++){for(X=s[4],C=s[3],z=0;z<T;++z){if(-1===I||I===z){const N=-1===I?z:0;if(!l.isCompressed&&l.isFourCC){c.format=5,S=X*C*4;let l=null;if(y._badOS||y._badDesktopOS||!e.textureHalfFloat&&!e.textureFloat)128===a?(l=i._GetFloatAsUIntRGBAArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,N),D&&0==N&&D.push(i._GetFloatRGBAArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,N))):64===a&&(l=i._GetHalfFloatAsUIntRGBAArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,N),D&&0==N&&D.push(i._GetHalfFloatAsFloatRGBAArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,N))),c.type=0;else{const y=e.textureFloat&&(P&&e.textureFloatLinearFiltering||!P),w=e.textureHalfFloat&&(P&&e.textureHalfFloatLinearFiltering||!P),p=(128===a||64===a&&!w)&&y?1:(64===a||128===a&&!y)&&w?2:0;let W,h=null;if(128===a)switch(p){case 1:W=i._GetFloatRGBAArrayBuffer,h=null;break;case 2:W=i._GetFloatAsHalfFloatRGBAArrayBuffer,h=i._GetFloatRGBAArrayBuffer;break;case 0:W=i._GetFloatAsUIntRGBAArrayBuffer,h=i._GetFloatRGBAArrayBuffer}else switch(p){case 1:W=i._GetHalfFloatAsFloatRGBAArrayBuffer,h=null;break;case 2:W=i._GetHalfFloatRGBAArrayBuffer,h=i._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:W=i._GetHalfFloatAsUIntRGBAArrayBuffer,h=i._GetHalfFloatAsFloatRGBAArrayBuffer}c.type=p,l=W(X,C,A.byteOffset+K,S,A.buffer,N),D&&0==N&&D.push(h?h(X,C,A.byteOffset+K,S,A.buffer,N):l)}l&&y._uploadDataToTextureDirectly(c,l,w,N)}else if(l.isRGB)c.type=0,24===a?(c.format=4,S=X*C*3,my=i._GetRGBArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,j,f,V),y._uploadDataToTextureDirectly(c,my,w,N)):(c.format=5,S=X*C*4,my=i._GetRGBAArrayBuffer(X,C,A.byteOffset+K,S,A.buffer,j,f,V,J),y._uploadDataToTextureDirectly(c,my,w,N));else if(l.isLuminance){const l=y._getUnpackAlignement(),p=X;S=Math.floor((X+l-1)/l)*l*(C-1)+p,my=i._GetLuminanceArrayBuffer(X,C,A.byteOffset+K,S,A.buffer),c.format=1,c.type=0,y._uploadDataToTextureDirectly(c,my,w,N)}else S=Math.max(4,X)/4*Math.max(4,C)/4*k,my=new Uint8Array(A.buffer,A.byteOffset+K,S),c.type=0,y._uploadCompressedDataToTextureDirectly(c,M,X,C,my,w,N)}K+=a?X*C*(a/8):S,X*=.5,C*=.5,X=Math.max(1,X),C=Math.max(1,C)}if(void 0!==H)break}D&&D.length>0?l.sphericalPolynomial=N.b.ConvertCubeMapToSphericalPolynomial({size:s[4],right:D[0],left:D[1],up:D[2],down:D[3],front:D[4],back:D[5],format:5,type:1,gammaSpace:!1}):l.sphericalPolynomial=void 0}}i.StoreLODInAlphaChannel=!1}}]);