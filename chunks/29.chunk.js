"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[29],{14107:(U,G,C)=>{var L=C(12826),X=C(12731),l=C(12772),t=C(12853),E=C(12800),K=C(12837);E.b.prototype._partialLoadFile=function(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(U,(U=>{C[G]=U,C._internalCount++,6===C._internalCount&&L(C)}),void 0,void 0,!0,((U,G)=>{X&&U&&X(U.status+" "+U.statusText,G)}))},E.b.prototype._cascadeLoadFiles=function(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const X=[];X._internalCount=0;for(let l=0;l<6;l++)this._partialLoadFile(C[l],l,X,G,L)},E.b.prototype._cascadeLoadImgs=function(U,G,C,L){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,l=arguments.length>5?arguments[5]:void 0;const t=[];t._internalCount=0;for(let E=0;E<6;E++)this._partialLoadImg(L[E],E,t,U,G,C,X,l)},E.b.prototype._partialLoadImg=function(U,G,C,L,X,E){let K=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,P=arguments.length>7?arguments[7]:void 0;const O=(0,t.c)();(0,l.t)(U,(U=>{C[G]=U,C._internalCount++,L&&L.removePendingData(O),6===C._internalCount&&E&&E(X,C)}),((U,G)=>{L&&L.removePendingData(O),K&&K(U,G)}),L?L.offlineProvider:null,P),L&&L.addPendingData(O)},E.b.prototype.createCubeTextureBase=function(U,G,C,l){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,P=arguments.length>6?arguments[6]:void 0,O=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,T=arguments.length>8&&void 0!==arguments[8]&&arguments[8],D=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,V=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,p=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,I=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,H=arguments.length>14&&void 0!==arguments[14]&&arguments[14],x=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const h=V||new L.b(this,7);h.isCube=!0,h.url=U,h.generateMipMaps=!l,h._lodGenerationScale=D,h._lodGenerationOffset=y,h._useSRGBBuffer=!!H&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!l),h!==V&&(h.label=U.substring(0,60)),this._doNotHandleContextLost||(h._extension=O,h._files=C,h._buffer=x);const N=U;this._transformTextureUrl&&!V&&(U=this._transformTextureUrl(U));const b=null!==O&&void 0!==O?O:function(U){const G=U.split("?")[0],C=G.lastIndexOf(".");return C>-1?G.substring(C).toLowerCase():""}(U),o=(0,K.b)(b),w=(U,G)=>{h.dispose(),E?E(U,G):U&&X.d.Warn(U)},S=(L,E)=>{U===N?L&&w(L.status+" "+L.statusText,E):(X.d.Warn("Failed to load ".concat(U,", falling back to the ").concat(N)),this.createCubeTextureBase(N,G,C,!!l,t,w,P,O,T,D,y,h,p,I,H,x))};if(o)o.then((L=>{const X=U=>{p&&p(h,U),L.loadCubeData(U,h,T,t,((U,G)=>{w(U,G)}))};x?X(x):C&&6===C.length?L.supportCascades?this._cascadeLoadFiles(G,(U=>X(U.map((U=>new Uint8Array(U))))),C,w):w("Textures type does not support cascades."):this._loadFile(U,(U=>X(new Uint8Array(U))),void 0,void 0,!0,S)}));else{if(!C||0===C.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(G,h,((U,G)=>{I&&I(U,G)}),C,w)}return this._internalTexturesCache.push(h),h}},13390:(U,G,C)=>{C.d(G,{c:()=>P});var L=C(12896),X=C(12911),l=C(13064),t=C(12898),E=C(12934);class K{constructor(U,G,C,L){this.name=U,this.worldAxisForNormal=G,this.worldAxisForFileX=C,this.worldAxisForFileY=L}}class P{static ConvertCubeMapTextureToSphericalPolynomial(U){var G;if(!U.isCube)return null;null===(G=U.wU())||void 0===G||G.getEngine().flushFramebuffer();const C=U.getSize().width,L=U.readPixels(0,void 0,void 0,!1),X=U.readPixels(1,void 0,void 0,!1);let l,t;U.isRenderTarget?(l=U.readPixels(3,void 0,void 0,!1),t=U.readPixels(2,void 0,void 0,!1)):(l=U.readPixels(2,void 0,void 0,!1),t=U.readPixels(3,void 0,void 0,!1));const E=U.readPixels(4,void 0,void 0,!1),K=U.readPixels(5,void 0,void 0,!1),P=U.gammaSpace;let O=0;return 1!=U.textureType&&2!=U.textureType||(O=1),new Promise((U=>{Promise.all([X,L,l,t,E,K]).then((G=>{let[L,X,l,t,E,K]=G;const T={size:C,right:X,left:L,up:l,down:t,front:E,back:K,format:5,type:O,gammaSpace:P};U(this.ConvertCubeMapToSphericalPolynomial(T))}))}))}static _AreaElement(U,G){return Math.atan2(U*G,Math.sqrt(U*U+G*G+1))}static ConvertCubeMapToSphericalPolynomial(U){const G=new l.c;let C=0;const L=2/U.size,K=L,P=.5*L,O=P-1;for(let l=0;l<6;l++){const T=this._FileFaces[l],D=U[T.name];let y=O;const V=5===U.format?4:3;for(let l=0;l<U.size;l++){let p=O;for(let K=0;K<U.size;K++){const O=T.worldAxisForFileX.scale(p).add(T.worldAxisForFileY.scale(y)).add(T.worldAxisForNormal);O.normalize();const I=this._AreaElement(p-P,y-P)-this._AreaElement(p-P,y+P)-this._AreaElement(p+P,y-P)+this._AreaElement(p+P,y+P);let H=D[l*U.size*V+K*V+0],x=D[l*U.size*V+K*V+1],h=D[l*U.size*V+K*V+2];isNaN(H)&&(H=0),isNaN(x)&&(x=0),isNaN(h)&&(h=0),0===U.type&&(H/=255,x/=255,h/=255),U.gammaSpace&&(H=Math.pow((0,X.Clamp)(H),t.l),x=Math.pow((0,X.Clamp)(x),t.l),h=Math.pow((0,X.Clamp)(h),t.l));const N=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const U=Math.max(H,x,h);if(U>N){const G=N/U;H*=G,x*=G,h*=G}}else H=(0,X.Clamp)(H,0,N),x=(0,X.Clamp)(x,0,N),h=(0,X.Clamp)(h,0,N);const b=new E.hG(H,x,h);G.addLight(O,b,I),C+=I,p+=L}y+=K}}const T=6*(4*Math.PI)/6/C;return G.scaleInPlace(T),G.convertIncidentRadianceToIrradiance(),G.convertIrradianceToLambertianRadiance(),l.g.FromHarmonics(G)}}P._FileFaces=[new K("right",new L.pG(1,0,0),new L.pG(0,0,-1),new L.pG(0,-1,0)),new K("left",new L.pG(-1,0,0),new L.pG(0,0,1),new L.pG(0,-1,0)),new K("up",new L.pG(0,1,0),new L.pG(1,0,0),new L.pG(0,0,1)),new K("down",new L.pG(0,-1,0),new L.pG(1,0,0),new L.pG(0,0,-1)),new K("front",new L.pG(0,0,1),new L.pG(1,0,0),new L.pG(0,-1,0)),new K("back",new L.pG(0,0,-1),new L.pG(-1,0,0),new L.pG(0,-1,0))],P.MAX_HDRI_VALUE=4096,P.PRESERVE_CLAMPED_COLORS=!1},14908:(U,G,C)=>{C.d(G,{DDSTools:()=>V});var L=C(12911),X=C(12731),l=C(13390),t=C(13092);C(14107);const E=131072,K=131072;function P(U){return U.charCodeAt(0)+(U.charCodeAt(1)<<8)+(U.charCodeAt(2)<<16)+(U.charCodeAt(3)<<24)}const O=P("DXT1"),T=P("DXT3"),D=P("DXT5"),y=P("DX10");class V{static GetDDSInfo(U){const G=new Int32Array(U.buffer,U.byteOffset,31),C=new Int32Array(U.buffer,U.byteOffset,35);let L=1;G[2]&E&&(L=Math.max(1,G[7]));const X=G[21],l=X===y?C[32]:0;let t=0;switch(X){case 113:t=2;break;case 116:t=1;break;case y:if(10===l){t=2;break}if(2===l){t=1;break}}return{width:G[4],height:G[3],mipmapCount:L,isFourCC:4===(4&G[20]),isRGB:64===(64&G[20]),isLuminance:(G[20]&K)===K,isCube:512===(512&G[28]),isCompressed:X===O||X===T||X===D,dxgiFormat:l,textureType:t}}static _GetHalfFloatAsFloatRGBAArrayBuffer(U,G,C,L,X,l){const E=new Float32Array(L),K=new Uint16Array(X,C);let P=0;for(let O=0;O<G;O++)for(let G=0;G<U;G++){const C=4*(G+O*U);E[P]=(0,t.e)(K[C]),E[P+1]=(0,t.e)(K[C+1]),E[P+2]=(0,t.e)(K[C+2]),V.StoreLODInAlphaChannel?E[P+3]=l:E[P+3]=(0,t.e)(K[C+3]),P+=4}return E}static _GetHalfFloatRGBAArrayBuffer(U,G,C,L,X,l){if(V.StoreLODInAlphaChannel){const E=new Uint16Array(L),K=new Uint16Array(X,C);let P=0;for(let C=0;C<G;C++)for(let G=0;G<U;G++){const L=4*(G+C*U);E[P]=K[L],E[P+1]=K[L+1],E[P+2]=K[L+2],E[P+3]=(0,t.i)(l),P+=4}return E}return new Uint16Array(X,C,L)}static _GetFloatRGBAArrayBuffer(U,G,C,L,X,l){if(V.StoreLODInAlphaChannel){const t=new Float32Array(L),E=new Float32Array(X,C);let K=0;for(let C=0;C<G;C++)for(let G=0;G<U;G++){const L=4*(G+C*U);t[K]=E[L],t[K+1]=E[L+1],t[K+2]=E[L+2],t[K+3]=l,K+=4}return t}return new Float32Array(X,C,L)}static _GetFloatAsHalfFloatRGBAArrayBuffer(U,G,C,L,X,l){const E=new Uint16Array(L),K=new Float32Array(X,C);let P=0;for(let O=0;O<G;O++)for(let G=0;G<U;G++)E[P]=(0,t.i)(K[P]),E[P+1]=(0,t.i)(K[P+1]),E[P+2]=(0,t.i)(K[P+2]),V.StoreLODInAlphaChannel?E[P+3]=(0,t.i)(l):E[P+3]=(0,t.i)(K[P+3]),P+=4;return E}static _GetFloatAsUIntRGBAArrayBuffer(U,G,C,X,l,t){const E=new Uint8Array(X),K=new Float32Array(l,C);let P=0;for(let O=0;O<G;O++)for(let G=0;G<U;G++){const C=4*(G+O*U);E[P]=255*(0,L.Clamp)(K[C]),E[P+1]=255*(0,L.Clamp)(K[C+1]),E[P+2]=255*(0,L.Clamp)(K[C+2]),V.StoreLODInAlphaChannel?E[P+3]=t:E[P+3]=255*(0,L.Clamp)(K[C+3]),P+=4}return E}static _GetHalfFloatAsUIntRGBAArrayBuffer(U,G,C,X,l,E){const K=new Uint8Array(X),P=new Uint16Array(l,C);let O=0;for(let T=0;T<G;T++)for(let G=0;G<U;G++){const C=4*(G+T*U);K[O]=255*(0,L.Clamp)((0,t.e)(P[C])),K[O+1]=255*(0,L.Clamp)((0,t.e)(P[C+1])),K[O+2]=255*(0,L.Clamp)((0,t.e)(P[C+2])),V.StoreLODInAlphaChannel?K[O+3]=E:K[O+3]=255*(0,L.Clamp)((0,t.e)(P[C+3])),O+=4}return K}static _GetRGBAArrayBuffer(U,G,C,L,X,l,t,E,K){const P=new Uint8Array(L),O=new Uint8Array(X,C);let T=0;for(let D=0;D<G;D++)for(let G=0;G<U;G++){const C=4*(G+D*U);P[T]=O[C+l],P[T+1]=O[C+t],P[T+2]=O[C+E],P[T+3]=O[C+K],T+=4}return P}static _ExtractLongWordOrder(U){return 0===U||255===U||-16777216===U?0:1+V._ExtractLongWordOrder(U>>8)}static _GetRGBArrayBuffer(U,G,C,L,X,l,t,E){const K=new Uint8Array(L),P=new Uint8Array(X,C);let O=0;for(let T=0;T<G;T++)for(let G=0;G<U;G++){const C=3*(G+T*U);K[O]=P[C+l],K[O+1]=P[C+t],K[O+2]=P[C+E],O+=3}return K}static _GetLuminanceArrayBuffer(U,G,C,L,X){const l=new Uint8Array(L),t=new Uint8Array(X,C);let E=0;for(let K=0;K<G;K++)for(let G=0;G<U;G++){const C=G+K*U;l[E]=t[C],E++}return l}static UploadDDSLevels(U,G,C,L,t,K){let P=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,p=arguments.length>7?arguments[7]:void 0,I=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],H=null;L.sphericalPolynomial&&(H=[]);const x=!!U.getCaps().s3tc;G.generateMipMaps=t;const h=new Int32Array(C.buffer,C.byteOffset,31);let N,b,o,w,S,v,u,d=0,g=0,Z=1;if(542327876!==h[0])return void X.d.Error("Invalid magic number in DDS header");if(!L.isFourCC&&!L.isRGB&&!L.isLuminance)return void X.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(L.isCompressed&&!x)return void X.d.Error("Compressed textures are not supported on this platform.");let F=h[22];w=h[1]+4;let q=!1;if(L.isFourCC)switch(N=h[21],N){case O:Z=8,g=33777;break;case T:Z=16,g=33778;break;case D:Z=16,g=33779;break;case 113:q=!0,F=64;break;case 116:q=!0,F=128;break;case y:{w+=20;let U=!1;switch(L.dxgiFormat){case 10:q=!0,F=64,U=!0;break;case 2:q=!0,F=128,U=!0;break;case 88:L.isRGB=!0,L.isFourCC=!1,F=32,U=!0}if(U)break}default:return void X.d.Error(["Unsupported FourCC code:",(a=N,String.fromCharCode(255&a,a>>8&255,a>>16&255,a>>24&255))])}var a;const k=V._ExtractLongWordOrder(h[23]),n=V._ExtractLongWordOrder(h[24]),Q=V._ExtractLongWordOrder(h[25]),mU=V._ExtractLongWordOrder(h[26]);q&&(g=U._getRGBABufferInternalSizedFormat(L.textureType)),v=1,h[2]&E&&!1!==t&&(v=Math.max(1,h[7]));const B=p||0,M=U.getCaps();for(let X=B;X<K;X++){for(b=h[4],o=h[3],u=0;u<v;++u){if(-1===P||P===u){const l=-1===P?u:0;if(!L.isCompressed&&L.isFourCC){G.format=5,d=b*o*4;let L=null;if(U._badOS||U._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)128===F?(L=V._GetFloatAsUIntRGBAArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,l),H&&0==l&&H.push(V._GetFloatRGBAArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,l))):64===F&&(L=V._GetHalfFloatAsUIntRGBAArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,l),H&&0==l&&H.push(V._GetHalfFloatAsFloatRGBAArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,l))),G.type=0;else{const U=M.textureFloat&&(I&&M.textureFloatLinearFiltering||!I),X=M.textureHalfFloat&&(I&&M.textureHalfFloatLinearFiltering||!I),t=(128===F||64===F&&!X)&&U?1:(64===F||128===F&&!U)&&X?2:0;let E,K=null;if(128===F)switch(t){case 1:E=V._GetFloatRGBAArrayBuffer,K=null;break;case 2:E=V._GetFloatAsHalfFloatRGBAArrayBuffer,K=V._GetFloatRGBAArrayBuffer;break;case 0:E=V._GetFloatAsUIntRGBAArrayBuffer,K=V._GetFloatRGBAArrayBuffer}else switch(t){case 1:E=V._GetHalfFloatAsFloatRGBAArrayBuffer,K=null;break;case 2:E=V._GetHalfFloatRGBAArrayBuffer,K=V._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:E=V._GetHalfFloatAsUIntRGBAArrayBuffer,K=V._GetHalfFloatAsFloatRGBAArrayBuffer}G.type=t,L=E(b,o,C.byteOffset+w,d,C.buffer,l),H&&0==l&&H.push(K?K(b,o,C.byteOffset+w,d,C.buffer,l):L)}L&&U._uploadDataToTextureDirectly(G,L,X,l)}else if(L.isRGB)G.type=0,24===F?(G.format=4,d=b*o*3,S=V._GetRGBArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,k,n,Q),U._uploadDataToTextureDirectly(G,S,X,l)):(G.format=5,d=b*o*4,S=V._GetRGBAArrayBuffer(b,o,C.byteOffset+w,d,C.buffer,k,n,Q,mU),U._uploadDataToTextureDirectly(G,S,X,l));else if(L.isLuminance){const L=U._getUnpackAlignement(),t=b;d=Math.floor((b+L-1)/L)*L*(o-1)+t,S=V._GetLuminanceArrayBuffer(b,o,C.byteOffset+w,d,C.buffer),G.format=1,G.type=0,U._uploadDataToTextureDirectly(G,S,X,l)}else d=Math.max(4,b)/4*Math.max(4,o)/4*Z,S=new Uint8Array(C.buffer,C.byteOffset+w,d),G.type=0,U._uploadCompressedDataToTextureDirectly(G,g,b,o,S,X,l)}w+=F?b*o*(F/8):d,b*=.5,o*=.5,b=Math.max(1,b),o=Math.max(1,o)}if(void 0!==p)break}H&&H.length>0?L.sphericalPolynomial=l.c.ConvertCubeMapToSphericalPolynomial({size:h[4],right:H[0],left:H[1],up:H[2],down:H[3],front:H[4],back:H[5],format:5,type:1,gammaSpace:!1}):L.sphericalPolynomial=void 0}}V.StoreLODInAlphaChannel=!1}}]);