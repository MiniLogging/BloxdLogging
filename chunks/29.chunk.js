"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13779:(G,V,W)=>{W.r(V),W.d(V,{_BasisTextureLoader:()=>B});var J,R=W(11189),d=W(11666),k=W(11285);function z(){const G=0,V=1,W=2,J=3,R=6,d=8,k=9,z=10,X=14;let P=null;function A(G,V,W,J,R){const d=G.getImageTranscodedSizeInBytes(V,W,J);let k=new Uint8Array(d);if(!G.transcodeImage(k,V,W,J,1,0))return null;if(R){k=function(G,V,W,J){const R=new Uint16Array(4),d=new Uint16Array(W*J),k=W/4,z=J/4;for(let X=0;X<z;X++)for(let J=0;J<k;J++){const z=V+8*(X*k+J);R[0]=G[z]|G[z+1]<<8,R[1]=G[z+2]|G[z+3]<<8,R[2]=(2*(31&R[0])+1*(31&R[1]))/3|(2*(2016&R[0])+1*(2016&R[1]))/3&2016|(2*(63488&R[0])+1*(63488&R[1]))/3&63488,R[3]=(2*(31&R[1])+1*(31&R[0]))/3|(2*(2016&R[1])+1*(2016&R[0]))/3&2016|(2*(63488&R[1])+1*(63488&R[0]))/3&63488;for(let V=0;V<4;V++){const k=G[z+4+V];let P=(4*X+V)*W+4*J;d[P++]=R[3&k],d[P++]=R[k>>2&3],d[P++]=R[k>>4&3],d[P++]=R[k>>6&3]}}return d}(k,0,G.getImageWidth(V,W)+3&-4,G.getImageHeight(V,W)+3&-4)}return k}onmessage=x=>{if("init"===x.data.action){if(x.data.url)try{importScripts(x.data.url)}catch(q){postMessage({action:"error",error:q})}P||(P=BASIS({wasmBinary:x.data.wasmBinary})),null!==P&&P.then((G=>{BASIS=G,G.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===x.data.action){const P=x.data.config,q=x.data.imageData,L=new BASIS.BasisFile(q),t=function(G){const V=G.getHasAlpha(),W=G.getNumImages(),J=[];for(let R=0;R<W;R++){const V={levels:[]},W=G.getNumLevels(R);for(let J=0;J<W;J++){const W={width:G.getImageWidth(R,J),height:G.getImageHeight(R,J)};V.levels.push(W)}J.push(V)}return{bd:V,images:J}}(L);let Y=x.data.ignoreSupportedFormats?null:function(P,A){let x=null;P.supportedCompressionFormats&&(x=P.supportedCompressionFormats.astc?z:P.supportedCompressionFormats.bc7?R:P.supportedCompressionFormats.s3tc?A.bd?J:W:P.supportedCompressionFormats.pvrtc?A.bd?k:d:P.supportedCompressionFormats.etc2?V:P.supportedCompressionFormats.etc1?G:X);return x}(x.data.config,t),g=!1;null===Y&&(g=!0,Y=t.bd?J:W);let B=!0;L.startTranscoding()||(B=!1);const S=[];for(let G=0;G<t.images.length&&B;G++){const V=t.images[G];if(void 0===P.loadSingleImage||P.loadSingleImage===G){let W=V.levels.length;!1===P.loadMipmapLevels&&(W=1);for(let J=0;J<W;J++){const W=V.levels[J],R=A(L,G,J,Y,g);if(!R){B=!1;break}W.transcodedPixels=R,S.push(W.transcodedPixels.buffer)}}}L.close(),L.delete(),g&&(Y=-1),B?postMessage({action:"transcode",success:B,id:x.data.id,fileInfo:t,format:Y},S):postMessage({action:"transcode",success:B,id:x.data.id})}}}!function(G){G[G.cTFETC1=0]="cTFETC1",G[G.cTFETC2=1]="cTFETC2",G[G.cTFBC1=2]="cTFBC1",G[G.cTFBC3=3]="cTFBC3",G[G.cTFBC4=4]="cTFBC4",G[G.cTFBC5=5]="cTFBC5",G[G.cTFBC7=6]="cTFBC7",G[G.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",G[G.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",G[G.cTFASTC_4x4=10]="cTFASTC_4x4",G[G.cTFATC_RGB=11]="cTFATC_RGB",G[G.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",G[G.cTFRGBA32=13]="cTFRGBA32",G[G.cTFRGB565=14]="cTFRGB565",G[G.cTFBGR565=15]="cTFBGR565",G[G.cTFRGBA4444=16]="cTFRGBA4444",G[G.cTFFXT1_RGB=17]="cTFFXT1_RGB",G[G.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",G[G.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",G[G.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",G[G.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(J||(J={}));const X={JSModuleURL:`${R.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${R.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let P=null,A=null,x=0;const q=async()=>(P||(P=new Promise(((G,V)=>{A?G(A):R.h.LoadFileAsync(R.h.GetBabylonScriptURL(X.WasmModuleURL)).then((W=>{if("function"!==typeof URL)return V("Basis transcoder requires an environment with a URL constructor");const J=URL.createObjectURL(new Blob([`(${z})()`],{type:"application/javascript"}));A=new Worker(J),async function(G,V,W){return await new Promise(((J,d)=>{const k=V=>{"init"===V.data.action?(G.removeEventListener("message",k),J(G)):"error"===V.data.action&&d(V.data.error||"error initializing worker")};G.addEventListener("message",k),G.postMessage({action:"init",url:W?R.h.GetBabylonScriptURL(W):void 0,wasmBinary:V},[V])}))}(A,W,X.JSModuleURL).then(G,V)})).catch(V)}))),await P),L=async(G,V)=>{const W=G instanceof ArrayBuffer?new Uint8Array(G):G;return await new Promise(((G,J)=>{q().then((()=>{const R=x++,d=V=>{"transcode"===V.data.action&&V.data.id===R&&(A.removeEventListener("message",d),V.data.success?G(V.data):J("Transcode is not supported on this device"))};A.addEventListener("message",d);const k=new Uint8Array(W.byteLength);k.set(new Uint8Array(W.buffer,W.byteOffset,W.byteLength)),A.postMessage({action:"transcode",id:R,imageData:k,config:V,ignoreSupportedFormats:false},[k.buffer])}),(G=>{J(G)}))}))},t=(G,V)=>{var W;let J=null===(W=V._gl)||void 0===W?void 0:W.TEXTURE_2D;var R;G.isCube&&(J=null===(R=V._gl)||void 0===R?void 0:R.TEXTURE_CUBE_MAP);V._bindTextureDirectly(J,G,!0)},Y=(G,V)=>{const W=G.getEngine();for(let z=0;z<V.fileInfo.images.length;z++){const X=V.fileInfo.images[z].levels[0];if(G._invertVScale=G.invertY,-1===V.format||V.format===J.cTFRGB565)if(G.type=10,G.format=4,!W._features.basisNeedsPOT||Math.log2(X.width)%1===0&&Math.log2(X.height)%1===0)G._invertVScale=!G.invertY,G.width=X.width+3&-4,G.height=X.height+3&-4,G.samplingMode=2,t(G,W),W._uploadDataToTextureDirectly(G,new Uint16Array(X.transcodedPixels.buffer),z,0,4,!0);else{const V=new k.d(W,2);G._invertVScale=G.invertY,V.type=10,V.format=4,V.width=X.width+3&-4,V.height=X.height+3&-4,t(V,W),W._uploadDataToTextureDirectly(V,new Uint16Array(X.transcodedPixels.buffer),z,0,4,!0),W._rescaleTexture(V,G,W.scenes[0],W._getInternalFormat(4),(()=>{W._releaseTexture(V),t(G,W)}))}else{G.width=X.width,G.height=X.height,G.generateMipMaps=V.fileInfo.images[z].levels.length>1;const J=g.GetInternalFormatFromBasisFormat(V.format,W);G.format=J,t(G,W);const k=V.fileInfo.images[z].levels;for(let V=0;V<k.length;V++){const R=k[V];W._uploadCompressedDataToTextureDirectly(G,J,R.width,R.height,R.transcodedPixels,z,V)}!W._features.basisNeedsPOT||Math.log2(G.width)%1===0&&Math.log2(G.height)%1===0||(R.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),G._cachedWrapU=d.d.CLAMP_ADDRESSMODE,G._cachedWrapV=d.d.CLAMP_ADDRESSMODE)}}},g={JSModuleURL:X.JSModuleURL,WasmModuleURL:X.WasmModuleURL,GetInternalFormatFromBasisFormat:(G,V)=>{let W;switch(G){case J.cTFETC1:W=36196;break;case J.cTFBC1:W=33776;break;case J.cTFBC4:W=33779;break;case J.cTFASTC_4x4:W=37808;break;case J.cTFETC2:W=37496;break;case J.cTFBC7:W=36492}if(void 0===W)throw"The chosen Basis transcoder format is not currently supported";return W},TranscodeAsync:L,LoadTextureFromTranscodeResult:Y};Object.defineProperty(g,"JSModuleURL",{get:function(){return X.JSModuleURL},set:function(G){X.JSModuleURL=G}}),Object.defineProperty(g,"WasmModuleURL",{get:function(){return X.WasmModuleURL},set:function(G){X.WasmModuleURL=G}});class B{constructor(){this.supportCascades=!1}loadCubeData(G,V,W,J,d){if(Array.isArray(G))return;const k=V.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};L(G,z).then((G=>{const W=G.fileInfo.images[0].levels.length>1&&V.generateMipMaps;Y(V,G),V.getEngine()._setCubeMapTextureParams(V,W),V.isReady=!0,V.onLoadedObservable.notifyObservers(V),V.onLoadedObservable.clear(),J&&J()})).catch((G=>{R.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),V.isReady=!0,d&&d(G)}))}loadData(G,V,W){const J=V.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!J.etc1,s3tc:!!J.s3tc,pvrtc:!!J.pvrtc,etc2:!!J.etc2,astc:!!J.astc,bc7:!!J.bptc}};L(G,d).then((G=>{const J=G.fileInfo.images[0].levels[0],R=G.fileInfo.images[0].levels.length>1&&V.generateMipMaps;W(J.width,J.height,R,-1!==G.format,(()=>{Y(V,G)}))})).catch((G=>{R.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),R.h.Warn(`Failed to transcode Basis file: ${G}`),W(0,0,!1,!1,(()=>{}),!0)}))}}}}]);