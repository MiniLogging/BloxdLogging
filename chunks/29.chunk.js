"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[29],{12841:(G,A,j)=>{var u=j(11156),k=j(11065),B=j(11089),x=j(11189),s=j(11120),O=j(11168);s.e.prototype._partialLoadFile=function(G,A,j,u){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(G,(G=>{j[A]=G,j._internalCount++,6===j._internalCount&&u(j)}),void 0,void 0,!0,((G,A)=>{k&&G&&k(G.status+" "+G.statusText,A)}))},s.e.prototype._cascadeLoadFiles=function(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const k=[];k._internalCount=0;for(let B=0;B<6;B++)this._partialLoadFile(j[B],B,k,A,u)},s.e.prototype._cascadeLoadImgs=function(G,A,j,u){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,B=arguments.length>5?arguments[5]:void 0;const x=[];x._internalCount=0;for(let s=0;s<6;s++)this._partialLoadImg(u[s],s,x,G,A,j,k,B)},s.e.prototype._partialLoadImg=function(G,A,j,u,k,s){let O=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,d=arguments.length>7?arguments[7]:void 0;const h=(0,x.c)();(0,B.o)(G,(G=>{j[A]=G,j._internalCount++,u&&u.removePendingData(h),6===j._internalCount&&s&&s(k,j)}),((G,A)=>{u&&u.removePendingData(h),O&&O(G,A)}),u?u.offlineProvider:null,d),u&&u.addPendingData(h)},s.e.prototype.createCubeTextureBase=function(G,A,j,B){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,d=arguments.length>6?arguments[6]:void 0,h=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,H=arguments.length>8&&void 0!==arguments[8]&&arguments[8],F=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,R=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,U=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,S=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,C=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,t=arguments.length>14&&void 0!==arguments[14]&&arguments[14],Y=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const n=U||new u.d(this,7);n.isCube=!0,n.url=G,n.generateMipMaps=!B,n._lodGenerationScale=F,n._lodGenerationOffset=R,n._useSRGBBuffer=!!t&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!B),n!==U&&(n.label=G.substring(0,60)),this._doNotHandleContextLost||(n._extension=h,n._files=j,n._buffer=Y);const Q=G;this._transformTextureUrl&&!U&&(G=this._transformTextureUrl(G));const X=h??function(G){const A=G.split("?")[0],j=A.lastIndexOf(".");return j>-1?A.substring(j).toLowerCase():""}(G),I=(0,O.b)(X),D=(G,A)=>{n.dispose(),s?s(G,A):G&&k.e.Warn(G)},g=(u,s)=>{G===Q?u&&D(u.status+" "+u.statusText,s):(k.e.Warn(`Failed to load ${G}, falling back to the ${Q}`),this.createCubeTextureBase(Q,A,j,!!B,x,D,d,h,H,F,R,n,S,C,t,Y))};if(I)I.then((u=>{const k=G=>{S&&S(n,G),u.loadCubeData(G,n,H,x,((G,A)=>{D(G,A)}))};Y?k(Y):j&&6===j.length?u.supportCascades?this._cascadeLoadFiles(A,(G=>k(G.map((G=>new Uint8Array(G))))),j,D):D("Textures type does not support cascades."):this._loadFile(G,(G=>k(new Uint8Array(G))),void 0,void 0,!0,g)}));else{if(!j||0===j.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(A,n,((G,A)=>{C&&C(G,A)}),j,D)}return this._internalTexturesCache.push(n),n}},11705:(G,A,j)=>{j.d(A,{c:()=>d});var u=j(11218),k=j(11237),B=j(11402),x=j(11222),s=j(11262);class O{constructor(G,A,j,u){this.name=G,this.worldAxisForNormal=A,this.worldAxisForFileX=j,this.worldAxisForFileY=u}}class d{static ConvertCubeMapTextureToSphericalPolynomial(G){var A;if(!G.isCube)return null;null===(A=G.gG())||void 0===A||A.getEngine().flushFramebuffer();const j=G.getSize().width,u=G.readPixels(0,void 0,void 0,!1),k=G.readPixels(1,void 0,void 0,!1);let B,x;G.isRenderTarget?(B=G.readPixels(3,void 0,void 0,!1),x=G.readPixels(2,void 0,void 0,!1)):(B=G.readPixels(2,void 0,void 0,!1),x=G.readPixels(3,void 0,void 0,!1));const s=G.readPixels(4,void 0,void 0,!1),O=G.readPixels(5,void 0,void 0,!1),d=G.gammaSpace;let h=0;return 1!=G.textureType&&2!=G.textureType||(h=1),new Promise((G=>{Promise.all([k,u,B,x,s,O]).then((A=>{let[u,k,B,x,s,O]=A;const H={size:j,right:k,left:u,up:B,down:x,front:s,back:O,format:5,type:h,gammaSpace:d};G(this.ConvertCubeMapToSphericalPolynomial(H))}))}))}static _AreaElement(G,A){return Math.atan2(G*A,Math.sqrt(G*G+A*A+1))}static ConvertCubeMapToSphericalPolynomial(G){const A=new B.e;let j=0;const u=2/G.size,O=u,d=.5*u,h=d-1;for(let B=0;B<6;B++){const H=this._FileFaces[B],F=G[H.name];let R=h;const U=5===G.format?4:3;for(let B=0;B<G.size;B++){let S=h;for(let O=0;O<G.size;O++){const h=H.worldAxisForFileX.scale(S).add(H.worldAxisForFileY.scale(R)).add(H.worldAxisForNormal);h.normalize();const C=this._AreaElement(S-d,R-d)-this._AreaElement(S-d,R+d)-this._AreaElement(S+d,R-d)+this._AreaElement(S+d,R+d);let t=F[B*G.size*U+O*U+0],Y=F[B*G.size*U+O*U+1],n=F[B*G.size*U+O*U+2];isNaN(t)&&(t=0),isNaN(Y)&&(Y=0),isNaN(n)&&(n=0),0===G.type&&(t/=255,Y/=255,n/=255),G.gammaSpace&&(t=Math.pow((0,k.Clamp)(t),x.j),Y=Math.pow((0,k.Clamp)(Y),x.j),n=Math.pow((0,k.Clamp)(n),x.j));const Q=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const G=Math.max(t,Y,n);if(G>Q){const A=Q/G;t*=A,Y*=A,n*=A}}else t=(0,k.Clamp)(t,0,Q),Y=(0,k.Clamp)(Y,0,Q),n=(0,k.Clamp)(n,0,Q);const X=new s.nA(t,Y,n);A.addLight(h,X,C),j+=C,S+=u}R+=O}}const H=6*(4*Math.PI)/6/j;return A.scaleInPlace(H),A.convertIncidentRadianceToIrradiance(),A.convertIrradianceToLambertianRadiance(),B.h.FromHarmonics(A)}}d._FileFaces=[new O("right",new u.SA(1,0,0),new u.SA(0,0,-1),new u.SA(0,-1,0)),new O("left",new u.SA(-1,0,0),new u.SA(0,0,1),new u.SA(0,-1,0)),new O("up",new u.SA(0,1,0),new u.SA(1,0,0),new u.SA(0,0,1)),new O("down",new u.SA(0,-1,0),new u.SA(1,0,0),new u.SA(0,0,-1)),new O("front",new u.SA(0,0,1),new u.SA(1,0,0),new u.SA(0,-1,0)),new O("back",new u.SA(0,0,-1),new u.SA(-1,0,0),new u.SA(0,-1,0))],d.MAX_HDRI_VALUE=4096,d.PRESERVE_CLAMPED_COLORS=!1},13630:(G,A,j)=>{j.d(A,{DDSTools:()=>U});var u=j(11237),k=j(11065),B=j(11705),x=j(11447);j(12841);const s=131072,O=131072;function d(G){return G.charCodeAt(0)+(G.charCodeAt(1)<<8)+(G.charCodeAt(2)<<16)+(G.charCodeAt(3)<<24)}const h=d("DXT1"),H=d("DXT3"),F=d("DXT5"),R=d("DX10");class U{static GetDDSInfo(G){const A=new Int32Array(G.buffer,G.byteOffset,31),j=new Int32Array(G.buffer,G.byteOffset,35);let u=1;A[2]&s&&(u=Math.max(1,A[7]));const k=A[21],B=k===R?j[32]:0;let x=0;switch(k){case 113:x=2;break;case 116:x=1;break;case R:if(10===B){x=2;break}if(2===B){x=1;break}}return{width:A[4],height:A[3],mipmapCount:u,isFourCC:4===(4&A[20]),isRGB:64===(64&A[20]),isLuminance:(A[20]&O)===O,isCube:512===(512&A[28]),isCompressed:k===h||k===H||k===F,dxgiFormat:B,textureType:x}}static _GetHalfFloatAsFloatRGBAArrayBuffer(G,A,j,u,k,B){const s=new Float32Array(u),O=new Uint16Array(k,j);let d=0;for(let h=0;h<A;h++)for(let A=0;A<G;A++){const j=4*(A+h*G);s[d]=(0,x.d)(O[j]),s[d+1]=(0,x.d)(O[j+1]),s[d+2]=(0,x.d)(O[j+2]),U.StoreLODInAlphaChannel?s[d+3]=B:s[d+3]=(0,x.d)(O[j+3]),d+=4}return s}static _GetHalfFloatRGBAArrayBuffer(G,A,j,u,k,B){if(U.StoreLODInAlphaChannel){const s=new Uint16Array(u),O=new Uint16Array(k,j);let d=0;for(let j=0;j<A;j++)for(let A=0;A<G;A++){const u=4*(A+j*G);s[d]=O[u],s[d+1]=O[u+1],s[d+2]=O[u+2],s[d+3]=(0,x.i)(B),d+=4}return s}return new Uint16Array(k,j,u)}static _GetFloatRGBAArrayBuffer(G,A,j,u,k,B){if(U.StoreLODInAlphaChannel){const x=new Float32Array(u),s=new Float32Array(k,j);let O=0;for(let j=0;j<A;j++)for(let A=0;A<G;A++){const u=4*(A+j*G);x[O]=s[u],x[O+1]=s[u+1],x[O+2]=s[u+2],x[O+3]=B,O+=4}return x}return new Float32Array(k,j,u)}static _GetFloatAsHalfFloatRGBAArrayBuffer(G,A,j,u,k,B){const s=new Uint16Array(u),O=new Float32Array(k,j);let d=0;for(let h=0;h<A;h++)for(let A=0;A<G;A++)s[d]=(0,x.i)(O[d]),s[d+1]=(0,x.i)(O[d+1]),s[d+2]=(0,x.i)(O[d+2]),U.StoreLODInAlphaChannel?s[d+3]=(0,x.i)(B):s[d+3]=(0,x.i)(O[d+3]),d+=4;return s}static _GetFloatAsUIntRGBAArrayBuffer(G,A,j,k,B,x){const s=new Uint8Array(k),O=new Float32Array(B,j);let d=0;for(let h=0;h<A;h++)for(let A=0;A<G;A++){const j=4*(A+h*G);s[d]=255*(0,u.Clamp)(O[j]),s[d+1]=255*(0,u.Clamp)(O[j+1]),s[d+2]=255*(0,u.Clamp)(O[j+2]),U.StoreLODInAlphaChannel?s[d+3]=x:s[d+3]=255*(0,u.Clamp)(O[j+3]),d+=4}return s}static _GetHalfFloatAsUIntRGBAArrayBuffer(G,A,j,k,B,s){const O=new Uint8Array(k),d=new Uint16Array(B,j);let h=0;for(let H=0;H<A;H++)for(let A=0;A<G;A++){const j=4*(A+H*G);O[h]=255*(0,u.Clamp)((0,x.d)(d[j])),O[h+1]=255*(0,u.Clamp)((0,x.d)(d[j+1])),O[h+2]=255*(0,u.Clamp)((0,x.d)(d[j+2])),U.StoreLODInAlphaChannel?O[h+3]=s:O[h+3]=255*(0,u.Clamp)((0,x.d)(d[j+3])),h+=4}return O}static _GetRGBAArrayBuffer(G,A,j,u,k,B,x,s,O){const d=new Uint8Array(u),h=new Uint8Array(k,j);let H=0;for(let F=0;F<A;F++)for(let A=0;A<G;A++){const j=4*(A+F*G);d[H]=h[j+B],d[H+1]=h[j+x],d[H+2]=h[j+s],d[H+3]=h[j+O],H+=4}return d}static _ExtractLongWordOrder(G){return 0===G||255===G||-16777216===G?0:1+U._ExtractLongWordOrder(G>>8)}static _GetRGBArrayBuffer(G,A,j,u,k,B,x,s){const O=new Uint8Array(u),d=new Uint8Array(k,j);let h=0;for(let H=0;H<A;H++)for(let A=0;A<G;A++){const j=3*(A+H*G);O[h]=d[j+B],O[h+1]=d[j+x],O[h+2]=d[j+s],h+=3}return O}static _GetLuminanceArrayBuffer(G,A,j,u,k){const B=new Uint8Array(u),x=new Uint8Array(k,j);let s=0;for(let O=0;O<A;O++)for(let A=0;A<G;A++){const j=A+O*G;B[s]=x[j],s++}return B}static UploadDDSLevels(G,A,j,u,x,O){let d=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,S=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],t=null;u.sphericalPolynomial&&(t=[]);const Y=!!G.getCaps().s3tc;A.generateMipMaps=x;const n=new Int32Array(j.buffer,j.byteOffset,31);let Q,X,I,D,g,c,E,r=0,b=0,M=1;if(542327876!==n[0])return void k.e.Error("Invalid magic number in DDS header");if(!u.isFourCC&&!u.isRGB&&!u.isLuminance)return void k.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(u.isCompressed&&!Y)return void k.e.Error("Compressed textures are not supported on this platform.");let o=n[22];D=n[1]+4;let W=!1;if(u.isFourCC)switch(Q=n[21],Q){case h:M=8,b=33777;break;case H:M=16,b=33778;break;case F:M=16,b=33779;break;case 113:W=!0,o=64;break;case 116:W=!0,o=128;break;case R:{D+=20;let G=!1;switch(u.dxgiFormat){case 10:W=!0,o=64,G=!0;break;case 2:W=!0,o=128,G=!0;break;case 88:u.isRGB=!0,u.isFourCC=!1,o=32,G=!0}if(G)break}default:return void k.e.Error(["Unsupported FourCC code:",(J=Q,String.fromCharCode(255&J,J>>8&255,J>>16&255,J>>24&255))])}var J;const p=U._ExtractLongWordOrder(n[23]),e=U._ExtractLongWordOrder(n[24]),l=U._ExtractLongWordOrder(n[25]),w=U._ExtractLongWordOrder(n[26]);W&&(b=G._getRGBABufferInternalSizedFormat(u.textureType)),c=1,n[2]&s&&!1!==x&&(c=Math.max(1,n[7]));const Z=S||0,P=G.getCaps();for(let k=Z;k<O;k++){for(X=n[4],I=n[3],E=0;E<c;++E){if(-1===d||d===E){const B=-1===d?E:0;if(!u.isCompressed&&u.isFourCC){A.format=5,r=X*I*4;let u=null;if(G._badOS||G._badDesktopOS||!P.textureHalfFloat&&!P.textureFloat)128===o?(u=U._GetFloatAsUIntRGBAArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,B),t&&0==B&&t.push(U._GetFloatRGBAArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,B))):64===o&&(u=U._GetHalfFloatAsUIntRGBAArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,B),t&&0==B&&t.push(U._GetHalfFloatAsFloatRGBAArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,B))),A.type=0;else{const G=P.textureFloat&&(C&&P.textureFloatLinearFiltering||!C),k=P.textureHalfFloat&&(C&&P.textureHalfFloatLinearFiltering||!C),x=(128===o||64===o&&!k)&&G?1:(64===o||128===o&&!G)&&k?2:0;let s,O=null;if(128===o)switch(x){case 1:s=U._GetFloatRGBAArrayBuffer,O=null;break;case 2:s=U._GetFloatAsHalfFloatRGBAArrayBuffer,O=U._GetFloatRGBAArrayBuffer;break;case 0:s=U._GetFloatAsUIntRGBAArrayBuffer,O=U._GetFloatRGBAArrayBuffer}else switch(x){case 1:s=U._GetHalfFloatAsFloatRGBAArrayBuffer,O=null;break;case 2:s=U._GetHalfFloatRGBAArrayBuffer,O=U._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:s=U._GetHalfFloatAsUIntRGBAArrayBuffer,O=U._GetHalfFloatAsFloatRGBAArrayBuffer}A.type=x,u=s(X,I,j.byteOffset+D,r,j.buffer,B),t&&0==B&&t.push(O?O(X,I,j.byteOffset+D,r,j.buffer,B):u)}u&&G._uploadDataToTextureDirectly(A,u,k,B)}else if(u.isRGB)A.type=0,24===o?(A.format=4,r=X*I*3,g=U._GetRGBArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,p,e,l),G._uploadDataToTextureDirectly(A,g,k,B)):(A.format=5,r=X*I*4,g=U._GetRGBAArrayBuffer(X,I,j.byteOffset+D,r,j.buffer,p,e,l,w),G._uploadDataToTextureDirectly(A,g,k,B));else if(u.isLuminance){const u=G._getUnpackAlignement(),x=X;r=Math.floor((X+u-1)/u)*u*(I-1)+x,g=U._GetLuminanceArrayBuffer(X,I,j.byteOffset+D,r,j.buffer),A.format=1,A.type=0,G._uploadDataToTextureDirectly(A,g,k,B)}else r=Math.max(4,X)/4*Math.max(4,I)/4*M,g=new Uint8Array(j.buffer,j.byteOffset+D,r),A.type=0,G._uploadCompressedDataToTextureDirectly(A,b,X,I,g,k,B)}D+=o?X*I*(o/8):r,X*=.5,I*=.5,X=Math.max(1,X),I=Math.max(1,I)}if(void 0!==S)break}t&&t.length>0?u.sphericalPolynomial=B.c.ConvertCubeMapToSphericalPolynomial({size:n[4],right:t[0],left:t[1],up:t[2],down:t[3],front:t[4],back:t[5],format:5,type:1,gammaSpace:!1}):u.sphericalPolynomial=void 0}}U.StoreLODInAlphaChannel=!1}}]);