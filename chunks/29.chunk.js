"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[29],{13415:(w,o,H)=>{var h=H(11640),E=H(11551),e=H(11573),D=H(11675),t=H(11615),X=H(11656);t.c.prototype._partialLoadFile=function(w,o,H,h){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(w,(w=>{H[o]=w,H._internalCount++,6===H._internalCount&&h(H)}),void 0,void 0,!0,((w,o)=>{E&&w&&E(w.status+" "+w.statusText,o)}))},t.c.prototype._cascadeLoadFiles=function(w,o,H){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const E=[];E._internalCount=0;for(let e=0;e<6;e++)this._partialLoadFile(H[e],e,E,o,h)},t.c.prototype._cascadeLoadImgs=function(w,o,H,h){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,e=arguments.length>5?arguments[5]:void 0;const D=[];D._internalCount=0;for(let t=0;t<6;t++)this._partialLoadImg(h[t],t,D,w,o,H,E,e)},t.c.prototype._partialLoadImg=function(w,o,H,h,E,t){let X=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,L=arguments.length>7?arguments[7]:void 0;const A=(0,D.e)();(0,e.q)(w,(w=>{H[o]=w,H._internalCount++,h&&h.removePendingData(A),6===H._internalCount&&t&&t(E,H)}),((w,o)=>{h&&h.removePendingData(A),X&&X(w,o)}),h?h.offlineProvider:null,L),h&&h.addPendingData(A)},t.c.prototype.createCubeTextureBase=function(w,o,H,e){let D=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,L=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8],z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,C=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Q=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,M=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,i=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,s=arguments.length>14&&void 0!==arguments[14]&&arguments[14],V=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const r=Q||new h.c(this,7);r.isCube=!0,r.url=w,r.generateMipMaps=!e,r._lodGenerationScale=z,r._lodGenerationOffset=C,r._useSRGBBuffer=!!s&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!e),r!==Q&&(r.label=w.substring(0,60)),this._doNotHandleContextLost||(r._extension=A,r._files=H,r._buffer=V);const k=w;this._transformTextureUrl&&!Q&&(w=this._transformTextureUrl(w));const P=A??function(w){const o=w.split("?")[0],H=o.lastIndexOf(".");return H>-1?o.substring(H).toLowerCase():""}(w),l=(0,X.b)(P),O=(w,o)=>{r.dispose(),t?t(w,o):w&&E.d.Warn(w)},T=(h,t)=>{w===k?h&&O(h.status+" "+h.statusText,t):(E.d.Warn(`Failed to load ${w}, falling back to the ${k}`),this.createCubeTextureBase(k,o,H,!!e,D,O,L,A,y,z,C,r,M,i,s,V))};if(l)l.then((h=>{const E=w=>{M&&M(r,w),h.loadCubeData(w,r,y,D,((w,o)=>{O(w,o)}))};V?E(V):H&&6===H.length?h.supportCascades?this._cascadeLoadFiles(o,(w=>E(w.map((w=>new Uint8Array(w))))),H,O):O("Textures type does not support cascades."):this._loadFile(w,(w=>E(new Uint8Array(w))),void 0,void 0,!0,T)}));else{if(!H||0===H.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(o,r,((w,o)=>{i&&i(w,o)}),H,O)}return this._internalTexturesCache.push(r),r}},12239:(w,o,H)=>{H.d(o,{b:()=>L});var h=H(11720),E=H(11729),e=H(11902),D=H(11722),t=H(11757);class X{constructor(w,o,H,h){this.name=w,this.worldAxisForNormal=o,this.worldAxisForFileX=H,this.worldAxisForFileY=h}}class L{static ConvertCubeMapTextureToSphericalPolynomial(w){var o;if(!w.isCube)return null;null===(o=w.Ow())||void 0===o||o.getEngine().flushFramebuffer();const H=w.getSize().width,h=w.readPixels(0,void 0,void 0,!1),E=w.readPixels(1,void 0,void 0,!1);let e,D;w.isRenderTarget?(e=w.readPixels(3,void 0,void 0,!1),D=w.readPixels(2,void 0,void 0,!1)):(e=w.readPixels(2,void 0,void 0,!1),D=w.readPixels(3,void 0,void 0,!1));const t=w.readPixels(4,void 0,void 0,!1),X=w.readPixels(5,void 0,void 0,!1),L=w.gammaSpace;let A=0;return 1!=w.textureType&&2!=w.textureType||(A=1),new Promise((w=>{Promise.all([E,h,e,D,t,X]).then((o=>{let[h,E,e,D,t,X]=o;const y={size:H,right:E,left:h,up:e,down:D,front:t,back:X,format:5,type:A,gammaSpace:L};w(this.ConvertCubeMapToSphericalPolynomial(y))}))}))}static _AreaElement(w,o){return Math.atan2(w*o,Math.sqrt(w*w+o*o+1))}static ConvertCubeMapToSphericalPolynomial(w){const o=new e.d;let H=0;const h=2/w.size,X=h,L=.5*h,A=L-1;for(let e=0;e<6;e++){const y=this._FileFaces[e],z=w[y.name];let C=A;const Q=5===w.format?4:3;for(let e=0;e<w.size;e++){let M=A;for(let X=0;X<w.size;X++){const A=y.worldAxisForFileX.scale(M).add(y.worldAxisForFileY.scale(C)).add(y.worldAxisForNormal);A.normalize();const i=this._AreaElement(M-L,C-L)-this._AreaElement(M-L,C+L)-this._AreaElement(M+L,C-L)+this._AreaElement(M+L,C+L);let s=z[e*w.size*Q+X*Q+0],V=z[e*w.size*Q+X*Q+1],r=z[e*w.size*Q+X*Q+2];isNaN(s)&&(s=0),isNaN(V)&&(V=0),isNaN(r)&&(r=0),0===w.type&&(s/=255,V/=255,r/=255),w.gammaSpace&&(s=Math.pow((0,E.Clamp)(s),D.g),V=Math.pow((0,E.Clamp)(V),D.g),r=Math.pow((0,E.Clamp)(r),D.g));const k=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const w=Math.max(s,V,r);if(w>k){const o=k/w;s*=o,V*=o,r*=o}}else s=(0,E.Clamp)(s,0,k),V=(0,E.Clamp)(V,0,k),r=(0,E.Clamp)(r,0,k);const P=new t.ko(s,V,r);o.addLight(A,P,i),H+=i,M+=h}C+=X}}const y=6*(4*Math.PI)/6/H;return o.scaleInPlace(y),o.convertIncidentRadianceToIrradiance(),o.convertIrradianceToLambertianRadiance(),e.h.FromHarmonics(o)}}L._FileFaces=[new X("right",new h.io(1,0,0),new h.io(0,0,-1),new h.io(0,-1,0)),new X("left",new h.io(-1,0,0),new h.io(0,0,1),new h.io(0,-1,0)),new X("up",new h.io(0,1,0),new h.io(1,0,0),new h.io(0,0,1)),new X("down",new h.io(0,-1,0),new h.io(1,0,0),new h.io(0,0,-1)),new X("front",new h.io(0,0,1),new h.io(1,0,0),new h.io(0,-1,0)),new X("back",new h.io(0,0,-1),new h.io(-1,0,0),new h.io(0,-1,0))],L.MAX_HDRI_VALUE=4096,L.PRESERVE_CLAMPED_COLORS=!1},14245:(w,o,H)=>{H.d(o,{DDSTools:()=>Q});var h=H(11729),E=H(11551),e=H(12239),D=H(11945);H(13415);const t=131072,X=131072;function L(w){return w.charCodeAt(0)+(w.charCodeAt(1)<<8)+(w.charCodeAt(2)<<16)+(w.charCodeAt(3)<<24)}const A=L("DXT1"),y=L("DXT3"),z=L("DXT5"),C=L("DX10");class Q{static GetDDSInfo(w){const o=new Int32Array(w.buffer,w.byteOffset,31),H=new Int32Array(w.buffer,w.byteOffset,35);let h=1;o[2]&t&&(h=Math.max(1,o[7]));const E=o[21],e=E===C?H[32]:0;let D=0;switch(E){case 113:D=2;break;case 116:D=1;break;case C:if(10===e){D=2;break}if(2===e){D=1;break}}return{width:o[4],height:o[3],mipmapCount:h,isFourCC:4===(4&o[20]),isRGB:64===(64&o[20]),isLuminance:(o[20]&X)===X,isCube:512===(512&o[28]),isCompressed:E===A||E===y||E===z,dxgiFormat:e,textureType:D}}static _GetHalfFloatAsFloatRGBAArrayBuffer(w,o,H,h,E,e){const t=new Float32Array(h),X=new Uint16Array(E,H);let L=0;for(let A=0;A<o;A++)for(let o=0;o<w;o++){const H=4*(o+A*w);t[L]=(0,D.h)(X[H]),t[L+1]=(0,D.h)(X[H+1]),t[L+2]=(0,D.h)(X[H+2]),Q.StoreLODInAlphaChannel?t[L+3]=e:t[L+3]=(0,D.h)(X[H+3]),L+=4}return t}static _GetHalfFloatRGBAArrayBuffer(w,o,H,h,E,e){if(Q.StoreLODInAlphaChannel){const t=new Uint16Array(h),X=new Uint16Array(E,H);let L=0;for(let H=0;H<o;H++)for(let o=0;o<w;o++){const h=4*(o+H*w);t[L]=X[h],t[L+1]=X[h+1],t[L+2]=X[h+2],t[L+3]=(0,D.n)(e),L+=4}return t}return new Uint16Array(E,H,h)}static _GetFloatRGBAArrayBuffer(w,o,H,h,E,e){if(Q.StoreLODInAlphaChannel){const D=new Float32Array(h),t=new Float32Array(E,H);let X=0;for(let H=0;H<o;H++)for(let o=0;o<w;o++){const h=4*(o+H*w);D[X]=t[h],D[X+1]=t[h+1],D[X+2]=t[h+2],D[X+3]=e,X+=4}return D}return new Float32Array(E,H,h)}static _GetFloatAsHalfFloatRGBAArrayBuffer(w,o,H,h,E,e){const t=new Uint16Array(h),X=new Float32Array(E,H);let L=0;for(let A=0;A<o;A++)for(let o=0;o<w;o++)t[L]=(0,D.n)(X[L]),t[L+1]=(0,D.n)(X[L+1]),t[L+2]=(0,D.n)(X[L+2]),Q.StoreLODInAlphaChannel?t[L+3]=(0,D.n)(e):t[L+3]=(0,D.n)(X[L+3]),L+=4;return t}static _GetFloatAsUIntRGBAArrayBuffer(w,o,H,E,e,D){const t=new Uint8Array(E),X=new Float32Array(e,H);let L=0;for(let A=0;A<o;A++)for(let o=0;o<w;o++){const H=4*(o+A*w);t[L]=255*(0,h.Clamp)(X[H]),t[L+1]=255*(0,h.Clamp)(X[H+1]),t[L+2]=255*(0,h.Clamp)(X[H+2]),Q.StoreLODInAlphaChannel?t[L+3]=D:t[L+3]=255*(0,h.Clamp)(X[H+3]),L+=4}return t}static _GetHalfFloatAsUIntRGBAArrayBuffer(w,o,H,E,e,t){const X=new Uint8Array(E),L=new Uint16Array(e,H);let A=0;for(let y=0;y<o;y++)for(let o=0;o<w;o++){const H=4*(o+y*w);X[A]=255*(0,h.Clamp)((0,D.h)(L[H])),X[A+1]=255*(0,h.Clamp)((0,D.h)(L[H+1])),X[A+2]=255*(0,h.Clamp)((0,D.h)(L[H+2])),Q.StoreLODInAlphaChannel?X[A+3]=t:X[A+3]=255*(0,h.Clamp)((0,D.h)(L[H+3])),A+=4}return X}static _GetRGBAArrayBuffer(w,o,H,h,E,e,D,t,X){const L=new Uint8Array(h),A=new Uint8Array(E,H);let y=0;for(let z=0;z<o;z++)for(let o=0;o<w;o++){const H=4*(o+z*w);L[y]=A[H+e],L[y+1]=A[H+D],L[y+2]=A[H+t],L[y+3]=A[H+X],y+=4}return L}static _ExtractLongWordOrder(w){return 0===w||255===w||-16777216===w?0:1+Q._ExtractLongWordOrder(w>>8)}static _GetRGBArrayBuffer(w,o,H,h,E,e,D,t){const X=new Uint8Array(h),L=new Uint8Array(E,H);let A=0;for(let y=0;y<o;y++)for(let o=0;o<w;o++){const H=3*(o+y*w);X[A]=L[H+e],X[A+1]=L[H+D],X[A+2]=L[H+t],A+=3}return X}static _GetLuminanceArrayBuffer(w,o,H,h,E){const e=new Uint8Array(h),D=new Uint8Array(E,H);let t=0;for(let X=0;X<o;X++)for(let o=0;o<w;o++){const H=o+X*w;e[t]=D[H],t++}return e}static UploadDDSLevels(w,o,H,h,D,X){let L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,M=arguments.length>7?arguments[7]:void 0,i=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],s=null;h.sphericalPolynomial&&(s=[]);const V=!!w.getCaps().s3tc;o.generateMipMaps=D;const r=new Int32Array(H.buffer,H.byteOffset,31);let k,P,l,O,T,S,c,W=0,B=0,J=1;if(542327876!==r[0])return void E.d.Error("Invalid magic number in DDS header");if(!h.isFourCC&&!h.isRGB&&!h.isLuminance)return void E.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(h.isCompressed&&!V)return void E.d.Error("Compressed textures are not supported on this platform.");let g=r[22];O=r[1]+4;let b=!1;if(h.isFourCC)switch(k=r[21],k){case A:J=8,B=33777;break;case y:J=16,B=33778;break;case z:J=16,B=33779;break;case 113:b=!0,g=64;break;case 116:b=!0,g=128;break;case C:{O+=20;let w=!1;switch(h.dxgiFormat){case 10:b=!0,g=64,w=!0;break;case 2:b=!0,g=128,w=!0;break;case 88:h.isRGB=!0,h.isFourCC=!1,g=32,w=!0}if(w)break}default:return void E.d.Error(["Unsupported FourCC code:",(p=k,String.fromCharCode(255&p,p>>8&255,p>>16&255,p>>24&255))])}var p;const f=Q._ExtractLongWordOrder(r[23]),N=Q._ExtractLongWordOrder(r[24]),j=Q._ExtractLongWordOrder(r[25]),q=Q._ExtractLongWordOrder(r[26]);b&&(B=w._getRGBABufferInternalSizedFormat(h.textureType)),S=1,r[2]&t&&!1!==D&&(S=Math.max(1,r[7]));const u=M||0,n=w.getCaps();for(let E=u;E<X;E++){for(P=r[4],l=r[3],c=0;c<S;++c){if(-1===L||L===c){const e=-1===L?c:0;if(!h.isCompressed&&h.isFourCC){o.format=5,W=P*l*4;let h=null;if(w._badOS||w._badDesktopOS||!n.textureHalfFloat&&!n.textureFloat)128===g?(h=Q._GetFloatAsUIntRGBAArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,e),s&&0==e&&s.push(Q._GetFloatRGBAArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,e))):64===g&&(h=Q._GetHalfFloatAsUIntRGBAArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,e),s&&0==e&&s.push(Q._GetHalfFloatAsFloatRGBAArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,e))),o.type=0;else{const w=n.textureFloat&&(i&&n.textureFloatLinearFiltering||!i),E=n.textureHalfFloat&&(i&&n.textureHalfFloatLinearFiltering||!i),D=(128===g||64===g&&!E)&&w?1:(64===g||128===g&&!w)&&E?2:0;let t,X=null;if(128===g)switch(D){case 1:t=Q._GetFloatRGBAArrayBuffer,X=null;break;case 2:t=Q._GetFloatAsHalfFloatRGBAArrayBuffer,X=Q._GetFloatRGBAArrayBuffer;break;case 0:t=Q._GetFloatAsUIntRGBAArrayBuffer,X=Q._GetFloatRGBAArrayBuffer}else switch(D){case 1:t=Q._GetHalfFloatAsFloatRGBAArrayBuffer,X=null;break;case 2:t=Q._GetHalfFloatRGBAArrayBuffer,X=Q._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:t=Q._GetHalfFloatAsUIntRGBAArrayBuffer,X=Q._GetHalfFloatAsFloatRGBAArrayBuffer}o.type=D,h=t(P,l,H.byteOffset+O,W,H.buffer,e),s&&0==e&&s.push(X?X(P,l,H.byteOffset+O,W,H.buffer,e):h)}h&&w._uploadDataToTextureDirectly(o,h,E,e)}else if(h.isRGB)o.type=0,24===g?(o.format=4,W=P*l*3,T=Q._GetRGBArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,f,N,j),w._uploadDataToTextureDirectly(o,T,E,e)):(o.format=5,W=P*l*4,T=Q._GetRGBAArrayBuffer(P,l,H.byteOffset+O,W,H.buffer,f,N,j,q),w._uploadDataToTextureDirectly(o,T,E,e));else if(h.isLuminance){const h=w._getUnpackAlignement(),D=P;W=Math.floor((P+h-1)/h)*h*(l-1)+D,T=Q._GetLuminanceArrayBuffer(P,l,H.byteOffset+O,W,H.buffer),o.format=1,o.type=0,w._uploadDataToTextureDirectly(o,T,E,e)}else W=Math.max(4,P)/4*Math.max(4,l)/4*J,T=new Uint8Array(H.buffer,H.byteOffset+O,W),o.type=0,w._uploadCompressedDataToTextureDirectly(o,B,P,l,T,E,e)}O+=g?P*l*(g/8):W,P*=.5,l*=.5,P=Math.max(1,P),l=Math.max(1,l)}if(void 0!==M)break}s&&s.length>0?h.sphericalPolynomial=e.b.ConvertCubeMapToSphericalPolynomial({size:r[4],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):h.sphericalPolynomial=void 0}}Q.StoreLODInAlphaChannel=!1}}]);