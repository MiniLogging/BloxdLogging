"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[29],{14021:(E,U,g)=>{var N=g(12273),L=g(12186),D=g(12210),S=g(12296),u=g(12243),s=g(12282);u.b.prototype._partialLoadFile=function(E,U,g,N){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(E,(E=>{g[U]=E,g._internalCount++,6===g._internalCount&&N(g)}),void 0,void 0,!0,((E,U)=>{L&&E&&L(E.status+" "+E.statusText,U)}))},u.b.prototype._cascadeLoadFiles=function(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const L=[];L._internalCount=0;for(let D=0;D<6;D++)this._partialLoadFile(g[D],D,L,U,N)},u.b.prototype._cascadeLoadImgs=function(E,U,g,N){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,D=arguments.length>5?arguments[5]:void 0;const S=[];S._internalCount=0;for(let u=0;u<6;u++)this._partialLoadImg(N[u],u,S,E,U,g,L,D)},u.b.prototype._partialLoadImg=function(E,U,g,N,L,u){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,C=arguments.length>7?arguments[7]:void 0;const B=(0,S.e)();(0,D.n)(E,(E=>{g[U]=E,g._internalCount++,N&&N.removePendingData(B),6===g._internalCount&&u&&u(L,g)}),((E,U)=>{N&&N.removePendingData(B),s&&s(E,U)}),N?N.offlineProvider:null,C),N&&N.addPendingData(B)},u.b.prototype.createCubeTextureBase=function(E,U,g,D){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,C=arguments.length>6?arguments[6]:void 0,B=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,P=arguments.length>8&&void 0!==arguments[8]&&arguments[8],F=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,f=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,d=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,I=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,y=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,h=arguments.length>14&&void 0!==arguments[14]&&arguments[14],V=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const e=d||new N.c(this,7);e.isCube=!0,e.url=E,e.generateMipMaps=!D,e._lodGenerationScale=F,e._lodGenerationOffset=f,e._useSRGBBuffer=!!h&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!D),e!==d&&(e.label=E.substring(0,60)),this._doNotHandleContextLost||(e._extension=B,e._files=g,e._buffer=V);const x=E;this._transformTextureUrl&&!d&&(E=this._transformTextureUrl(E));const l=B??function(E){const U=E.split("?")[0],g=U.lastIndexOf(".");return g>-1?U.substring(g).toLowerCase():""}(E),Y=(0,s.b)(l),t=(E,U)=>{e.dispose(),u?u(E,U):E&&L.d.Warn(E)},G=(N,u)=>{E===x?N&&t(N.status+" "+N.statusText,u):(L.d.Warn(`Failed to load ${E}, falling back to the ${x}`),this.createCubeTextureBase(x,U,g,!!D,S,t,C,B,P,F,f,e,I,y,h,V))};if(Y)Y.then((N=>{const L=E=>{I&&I(e,E),N.loadCubeData(E,e,P,S,((E,U)=>{t(E,U)}))};V?L(V):g&&6===g.length?N.supportCascades?this._cascadeLoadFiles(U,(E=>L(E.map((E=>new Uint8Array(E))))),g,t):t("Textures type does not support cascades."):this._loadFile(E,(E=>L(new Uint8Array(E))),void 0,void 0,!0,G)}));else{if(!g||0===g.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(U,e,((E,U)=>{y&&y(E,U)}),g,t)}return this._internalTexturesCache.push(e),e}},12847:(E,U,g)=>{g.d(U,{d:()=>C});var N=g(12334),L=g(12353),D=g(12527),S=g(12336),u=g(12379);class s{constructor(E,U,g,N){this.name=E,this.worldAxisForNormal=U,this.worldAxisForFileX=g,this.worldAxisForFileY=N}}class C{static ConvertCubeMapTextureToSphericalPolynomial(E){var U;if(!E.isCube)return null;null===(U=E.tE())||void 0===U||U.getEngine().flushFramebuffer();const g=E.getSize().width,N=E.readPixels(0,void 0,void 0,!1),L=E.readPixels(1,void 0,void 0,!1);let D,S;E.isRenderTarget?(D=E.readPixels(3,void 0,void 0,!1),S=E.readPixels(2,void 0,void 0,!1)):(D=E.readPixels(2,void 0,void 0,!1),S=E.readPixels(3,void 0,void 0,!1));const u=E.readPixels(4,void 0,void 0,!1),s=E.readPixels(5,void 0,void 0,!1),C=E.gammaSpace;let B=0;return 1!=E.textureType&&2!=E.textureType||(B=1),new Promise((E=>{Promise.all([L,N,D,S,u,s]).then((U=>{let[N,L,D,S,u,s]=U;const P={size:g,right:L,left:N,up:D,down:S,front:u,back:s,format:5,type:B,gammaSpace:C};E(this.ConvertCubeMapToSphericalPolynomial(P))}))}))}static _AreaElement(E,U){return Math.atan2(E*U,Math.sqrt(E*E+U*U+1))}static ConvertCubeMapToSphericalPolynomial(E){const U=new D.c;let g=0;const N=2/E.size,s=N,C=.5*N,B=C-1;for(let D=0;D<6;D++){const P=this._FileFaces[D],F=E[P.name];let f=B;const d=5===E.format?4:3;for(let D=0;D<E.size;D++){let I=B;for(let s=0;s<E.size;s++){const B=P.worldAxisForFileX.scale(I).add(P.worldAxisForFileY.scale(f)).add(P.worldAxisForNormal);B.normalize();const y=this._AreaElement(I-C,f-C)-this._AreaElement(I-C,f+C)-this._AreaElement(I+C,f-C)+this._AreaElement(I+C,f+C);let h=F[D*E.size*d+s*d+0],V=F[D*E.size*d+s*d+1],e=F[D*E.size*d+s*d+2];isNaN(h)&&(h=0),isNaN(V)&&(V=0),isNaN(e)&&(e=0),0===E.type&&(h/=255,V/=255,e/=255),E.gammaSpace&&(h=Math.pow((0,L.Clamp)(h),S.i),V=Math.pow((0,L.Clamp)(V),S.i),e=Math.pow((0,L.Clamp)(e),S.i));const x=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const E=Math.max(h,V,e);if(E>x){const U=x/E;h*=U,V*=U,e*=U}}else h=(0,L.Clamp)(h,0,x),V=(0,L.Clamp)(V,0,x),e=(0,L.Clamp)(e,0,x);const l=new u.VU(h,V,e);U.addLight(B,l,y),g+=y,I+=N}f+=s}}const P=6*(4*Math.PI)/6/g;return U.scaleInPlace(P),U.convertIncidentRadianceToIrradiance(),U.convertIrradianceToLambertianRadiance(),D.f.FromHarmonics(U)}}C._FileFaces=[new s("right",new N.dU(1,0,0),new N.dU(0,0,-1),new N.dU(0,-1,0)),new s("left",new N.dU(-1,0,0),new N.dU(0,0,1),new N.dU(0,-1,0)),new s("up",new N.dU(0,1,0),new N.dU(1,0,0),new N.dU(0,0,1)),new s("down",new N.dU(0,-1,0),new N.dU(1,0,0),new N.dU(0,0,-1)),new s("front",new N.dU(0,0,1),new N.dU(1,0,0),new N.dU(0,-1,0)),new s("back",new N.dU(0,0,-1),new N.dU(-1,0,0),new N.dU(0,-1,0))],C.MAX_HDRI_VALUE=4096,C.PRESERVE_CLAMPED_COLORS=!1},14819:(E,U,g)=>{g.d(U,{DDSTools:()=>d});var N=g(12353),L=g(12186),D=g(12847),S=g(12557);g(14021);const u=131072,s=131072;function C(E){return E.charCodeAt(0)+(E.charCodeAt(1)<<8)+(E.charCodeAt(2)<<16)+(E.charCodeAt(3)<<24)}const B=C("DXT1"),P=C("DXT3"),F=C("DXT5"),f=C("DX10");class d{static GetDDSInfo(E){const U=new Int32Array(E.buffer,E.byteOffset,31),g=new Int32Array(E.buffer,E.byteOffset,35);let N=1;U[2]&u&&(N=Math.max(1,U[7]));const L=U[21],D=L===f?g[32]:0;let S=0;switch(L){case 113:S=2;break;case 116:S=1;break;case f:if(10===D){S=2;break}if(2===D){S=1;break}}return{width:U[4],height:U[3],mipmapCount:N,isFourCC:4===(4&U[20]),isRGB:64===(64&U[20]),isLuminance:(U[20]&s)===s,isCube:512===(512&U[28]),isCompressed:L===B||L===P||L===F,dxgiFormat:D,textureType:S}}static _GetHalfFloatAsFloatRGBAArrayBuffer(E,U,g,N,L,D){const u=new Float32Array(N),s=new Uint16Array(L,g);let C=0;for(let B=0;B<U;B++)for(let U=0;U<E;U++){const g=4*(U+B*E);u[C]=(0,S.e)(s[g]),u[C+1]=(0,S.e)(s[g+1]),u[C+2]=(0,S.e)(s[g+2]),d.StoreLODInAlphaChannel?u[C+3]=D:u[C+3]=(0,S.e)(s[g+3]),C+=4}return u}static _GetHalfFloatRGBAArrayBuffer(E,U,g,N,L,D){if(d.StoreLODInAlphaChannel){const u=new Uint16Array(N),s=new Uint16Array(L,g);let C=0;for(let g=0;g<U;g++)for(let U=0;U<E;U++){const N=4*(U+g*E);u[C]=s[N],u[C+1]=s[N+1],u[C+2]=s[N+2],u[C+3]=(0,S.j)(D),C+=4}return u}return new Uint16Array(L,g,N)}static _GetFloatRGBAArrayBuffer(E,U,g,N,L,D){if(d.StoreLODInAlphaChannel){const S=new Float32Array(N),u=new Float32Array(L,g);let s=0;for(let g=0;g<U;g++)for(let U=0;U<E;U++){const N=4*(U+g*E);S[s]=u[N],S[s+1]=u[N+1],S[s+2]=u[N+2],S[s+3]=D,s+=4}return S}return new Float32Array(L,g,N)}static _GetFloatAsHalfFloatRGBAArrayBuffer(E,U,g,N,L,D){const u=new Uint16Array(N),s=new Float32Array(L,g);let C=0;for(let B=0;B<U;B++)for(let U=0;U<E;U++)u[C]=(0,S.j)(s[C]),u[C+1]=(0,S.j)(s[C+1]),u[C+2]=(0,S.j)(s[C+2]),d.StoreLODInAlphaChannel?u[C+3]=(0,S.j)(D):u[C+3]=(0,S.j)(s[C+3]),C+=4;return u}static _GetFloatAsUIntRGBAArrayBuffer(E,U,g,L,D,S){const u=new Uint8Array(L),s=new Float32Array(D,g);let C=0;for(let B=0;B<U;B++)for(let U=0;U<E;U++){const g=4*(U+B*E);u[C]=255*(0,N.Clamp)(s[g]),u[C+1]=255*(0,N.Clamp)(s[g+1]),u[C+2]=255*(0,N.Clamp)(s[g+2]),d.StoreLODInAlphaChannel?u[C+3]=S:u[C+3]=255*(0,N.Clamp)(s[g+3]),C+=4}return u}static _GetHalfFloatAsUIntRGBAArrayBuffer(E,U,g,L,D,u){const s=new Uint8Array(L),C=new Uint16Array(D,g);let B=0;for(let P=0;P<U;P++)for(let U=0;U<E;U++){const g=4*(U+P*E);s[B]=255*(0,N.Clamp)((0,S.e)(C[g])),s[B+1]=255*(0,N.Clamp)((0,S.e)(C[g+1])),s[B+2]=255*(0,N.Clamp)((0,S.e)(C[g+2])),d.StoreLODInAlphaChannel?s[B+3]=u:s[B+3]=255*(0,N.Clamp)((0,S.e)(C[g+3])),B+=4}return s}static _GetRGBAArrayBuffer(E,U,g,N,L,D,S,u,s){const C=new Uint8Array(N),B=new Uint8Array(L,g);let P=0;for(let F=0;F<U;F++)for(let U=0;U<E;U++){const g=4*(U+F*E);C[P]=B[g+D],C[P+1]=B[g+S],C[P+2]=B[g+u],C[P+3]=B[g+s],P+=4}return C}static _ExtractLongWordOrder(E){return 0===E||255===E||-16777216===E?0:1+d._ExtractLongWordOrder(E>>8)}static _GetRGBArrayBuffer(E,U,g,N,L,D,S,u){const s=new Uint8Array(N),C=new Uint8Array(L,g);let B=0;for(let P=0;P<U;P++)for(let U=0;U<E;U++){const g=3*(U+P*E);s[B]=C[g+D],s[B+1]=C[g+S],s[B+2]=C[g+u],B+=3}return s}static _GetLuminanceArrayBuffer(E,U,g,N,L){const D=new Uint8Array(N),S=new Uint8Array(L,g);let u=0;for(let s=0;s<U;s++)for(let U=0;U<E;U++){const g=U+s*E;D[u]=S[g],u++}return D}static UploadDDSLevels(E,U,g,N,S,s){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,I=arguments.length>7?arguments[7]:void 0,y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],h=null;N.sphericalPolynomial&&(h=[]);const V=!!E.getCaps().s3tc;U.generateMipMaps=S;const e=new Int32Array(g.buffer,g.byteOffset,31);let x,l,Y,t,G,b,T,v=0,o=0,c=1;if(542327876!==e[0])return void L.d.Error("Invalid magic number in DDS header");if(!N.isFourCC&&!N.isRGB&&!N.isLuminance)return void L.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(N.isCompressed&&!V)return void L.d.Error("Compressed textures are not supported on this platform.");let r=e[22];t=e[1]+4;let j=!1;if(N.isFourCC)switch(x=e[21],x){case B:c=8,o=33777;break;case P:c=16,o=33778;break;case F:c=16,o=33779;break;case 113:j=!0,r=64;break;case 116:j=!0,r=128;break;case f:{t+=20;let E=!1;switch(N.dxgiFormat){case 10:j=!0,r=64,E=!0;break;case 2:j=!0,r=128,E=!0;break;case 88:N.isRGB=!0,N.isFourCC=!1,r=32,E=!0}if(E)break}default:return void L.d.Error(["Unsupported FourCC code:",(Z=x,String.fromCharCode(255&Z,Z>>8&255,Z>>16&255,Z>>24&255))])}var Z;const A=d._ExtractLongWordOrder(e[23]),w=d._ExtractLongWordOrder(e[24]),a=d._ExtractLongWordOrder(e[25]),J=d._ExtractLongWordOrder(e[26]);j&&(o=E._getRGBABufferInternalSizedFormat(N.textureType)),b=1,e[2]&u&&!1!==S&&(b=Math.max(1,e[7]));const q=I||0,M=E.getCaps();for(let L=q;L<s;L++){for(l=e[4],Y=e[3],T=0;T<b;++T){if(-1===C||C===T){const D=-1===C?T:0;if(!N.isCompressed&&N.isFourCC){U.format=5,v=l*Y*4;let N=null;if(E._badOS||E._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)128===r?(N=d._GetFloatAsUIntRGBAArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,D),h&&0==D&&h.push(d._GetFloatRGBAArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,D))):64===r&&(N=d._GetHalfFloatAsUIntRGBAArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,D),h&&0==D&&h.push(d._GetHalfFloatAsFloatRGBAArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,D))),U.type=0;else{const E=M.textureFloat&&(y&&M.textureFloatLinearFiltering||!y),L=M.textureHalfFloat&&(y&&M.textureHalfFloatLinearFiltering||!y),S=(128===r||64===r&&!L)&&E?1:(64===r||128===r&&!E)&&L?2:0;let u,s=null;if(128===r)switch(S){case 1:u=d._GetFloatRGBAArrayBuffer,s=null;break;case 2:u=d._GetFloatAsHalfFloatRGBAArrayBuffer,s=d._GetFloatRGBAArrayBuffer;break;case 0:u=d._GetFloatAsUIntRGBAArrayBuffer,s=d._GetFloatRGBAArrayBuffer}else switch(S){case 1:u=d._GetHalfFloatAsFloatRGBAArrayBuffer,s=null;break;case 2:u=d._GetHalfFloatRGBAArrayBuffer,s=d._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:u=d._GetHalfFloatAsUIntRGBAArrayBuffer,s=d._GetHalfFloatAsFloatRGBAArrayBuffer}U.type=S,N=u(l,Y,g.byteOffset+t,v,g.buffer,D),h&&0==D&&h.push(s?s(l,Y,g.byteOffset+t,v,g.buffer,D):N)}N&&E._uploadDataToTextureDirectly(U,N,L,D)}else if(N.isRGB)U.type=0,24===r?(U.format=4,v=l*Y*3,G=d._GetRGBArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,A,w,a),E._uploadDataToTextureDirectly(U,G,L,D)):(U.format=5,v=l*Y*4,G=d._GetRGBAArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer,A,w,a,J),E._uploadDataToTextureDirectly(U,G,L,D));else if(N.isLuminance){const N=E._getUnpackAlignement(),S=l;v=Math.floor((l+N-1)/N)*N*(Y-1)+S,G=d._GetLuminanceArrayBuffer(l,Y,g.byteOffset+t,v,g.buffer),U.format=1,U.type=0,E._uploadDataToTextureDirectly(U,G,L,D)}else v=Math.max(4,l)/4*Math.max(4,Y)/4*c,G=new Uint8Array(g.buffer,g.byteOffset+t,v),U.type=0,E._uploadCompressedDataToTextureDirectly(U,o,l,Y,G,L,D)}t+=r?l*Y*(r/8):v,l*=.5,Y*=.5,l=Math.max(1,l),Y=Math.max(1,Y)}if(void 0!==I)break}h&&h.length>0?N.sphericalPolynomial=D.d.ConvertCubeMapToSphericalPolynomial({size:e[4],right:h[0],left:h[1],up:h[2],down:h[3],front:h[4],back:h[5],format:5,type:1,gammaSpace:!1}):N.sphericalPolynomial=void 0}}d.StoreLODInAlphaChannel=!1}}]);