"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13374:(q,c,U)=>{U.r(c),U.d(c,{_BasisTextureLoader:()=>o});var J,Q=U(10879),s=U(11288),g=U(10976);function X(){const q=0,c=1,U=2,J=3,Q=6,s=8,g=9,X=10,n=14;let W=null;function D(q,c,U,J,Q){const s=q.getImageTranscodedSizeInBytes(c,U,J);let g=new Uint8Array(s);if(!q.transcodeImage(g,c,U,J,1,0))return null;if(Q){g=function(q,c,U,J){const Q=new Uint16Array(4),s=new Uint16Array(U*J),g=U/4,X=J/4;for(let n=0;n<X;n++)for(let J=0;J<g;J++){const X=c+8*(n*g+J);Q[0]=q[X]|q[X+1]<<8,Q[1]=q[X+2]|q[X+3]<<8,Q[2]=(2*(31&Q[0])+1*(31&Q[1]))/3|(2*(2016&Q[0])+1*(2016&Q[1]))/3&2016|(2*(63488&Q[0])+1*(63488&Q[1]))/3&63488,Q[3]=(2*(31&Q[1])+1*(31&Q[0]))/3|(2*(2016&Q[1])+1*(2016&Q[0]))/3&2016|(2*(63488&Q[1])+1*(63488&Q[0]))/3&63488;for(let c=0;c<4;c++){const g=q[X+4+c];let W=(4*n+c)*U+4*J;s[W++]=Q[3&g],s[W++]=Q[g>>2&3],s[W++]=Q[g>>4&3],s[W++]=Q[g>>6&3]}}return s}(g,0,q.getImageWidth(c,U)+3&-4,q.getImageHeight(c,U)+3&-4)}return g}onmessage=u=>{if("init"===u.data.action){if(u.data.url)try{importScripts(u.data.url)}catch(K){postMessage({action:"error",error:K})}W||(W=BASIS({wasmBinary:u.data.wasmBinary})),null!==W&&W.then((q=>{BASIS=q,q.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===u.data.action){const W=u.data.config,K=u.data.imageData,r=new BASIS.BasisFile(K),H=function(q){const c=q.getHasAlpha(),U=q.getNumImages(),J=[];for(let Q=0;Q<U;Q++){const c={levels:[]},U=q.getNumLevels(Q);for(let J=0;J<U;J++){const U={width:q.getImageWidth(Q,J),height:q.getImageHeight(Q,J)};c.levels.push(U)}J.push(c)}return{Hc:c,images:J}}(r);let b=u.data.ignoreSupportedFormats?null:function(W,D){let u=null;W.supportedCompressionFormats&&(u=W.supportedCompressionFormats.astc?X:W.supportedCompressionFormats.bc7?Q:W.supportedCompressionFormats.s3tc?D.Hc?J:U:W.supportedCompressionFormats.pvrtc?D.Hc?g:s:W.supportedCompressionFormats.etc2?c:W.supportedCompressionFormats.etc1?q:n);return u}(u.data.config,H),h=!1;null===b&&(h=!0,b=H.Hc?J:U);let o=!0;r.startTranscoding()||(o=!1);const a=[];for(let q=0;q<H.images.length&&o;q++){const c=H.images[q];if(void 0===W.loadSingleImage||W.loadSingleImage===q){let U=c.levels.length;!1===W.loadMipmapLevels&&(U=1);for(let J=0;J<U;J++){const U=c.levels[J],Q=D(r,q,J,b,h);if(!Q){o=!1;break}U.transcodedPixels=Q,a.push(U.transcodedPixels.buffer)}}}r.close(),r.delete(),h&&(b=-1),o?postMessage({action:"transcode",success:o,id:u.data.id,fileInfo:H,format:b},a):postMessage({action:"transcode",success:o,id:u.data.id})}}}!function(q){q[q.cTFETC1=0]="cTFETC1",q[q.cTFETC2=1]="cTFETC2",q[q.cTFBC1=2]="cTFBC1",q[q.cTFBC3=3]="cTFBC3",q[q.cTFBC4=4]="cTFBC4",q[q.cTFBC5=5]="cTFBC5",q[q.cTFBC7=6]="cTFBC7",q[q.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",q[q.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",q[q.cTFASTC_4x4=10]="cTFASTC_4x4",q[q.cTFATC_RGB=11]="cTFATC_RGB",q[q.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",q[q.cTFRGBA32=13]="cTFRGBA32",q[q.cTFRGB565=14]="cTFRGB565",q[q.cTFBGR565=15]="cTFBGR565",q[q.cTFRGBA4444=16]="cTFRGBA4444",q[q.cTFFXT1_RGB=17]="cTFFXT1_RGB",q[q.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",q[q.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",q[q.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",q[q.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(J||(J={}));const n={JSModuleURL:`${Q.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${Q.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let W=null,D=null,u=0;const K=async()=>(W||(W=new Promise(((q,c)=>{D?q(D):Q.e.LoadFileAsync(Q.e.GetBabylonScriptURL(n.WasmModuleURL)).then((U=>{if("function"!==typeof URL)return c("Basis transcoder requires an environment with a URL constructor");const J=URL.createObjectURL(new Blob([`(${X})()`],{type:"application/javascript"}));D=new Worker(J),async function(q,c,U){return await new Promise(((J,s)=>{const g=c=>{"init"===c.data.action?(q.removeEventListener("message",g),J(q)):"error"===c.data.action&&s(c.data.error||"error initializing worker")};q.addEventListener("message",g),q.postMessage({action:"init",url:U?Q.e.GetBabylonScriptURL(U):void 0,wasmBinary:c},[c])}))}(D,U,n.JSModuleURL).then(q,c)})).catch(c)}))),await W),r=async(q,c)=>{const U=q instanceof ArrayBuffer?new Uint8Array(q):q;return await new Promise(((q,J)=>{K().then((()=>{const Q=u++,s=c=>{"transcode"===c.data.action&&c.data.id===Q&&(D.removeEventListener("message",s),c.data.success?q(c.data):J("Transcode is not supported on this device"))};D.addEventListener("message",s);const g=new Uint8Array(U.byteLength);g.set(new Uint8Array(U.buffer,U.byteOffset,U.byteLength)),D.postMessage({action:"transcode",id:Q,imageData:g,config:c,ignoreSupportedFormats:false},[g.buffer])}),(q=>{J(q)}))}))},H=(q,c)=>{var U;let J=null===(U=c._gl)||void 0===U?void 0:U.TEXTURE_2D;var Q;q.isCube&&(J=null===(Q=c._gl)||void 0===Q?void 0:Q.TEXTURE_CUBE_MAP);c._bindTextureDirectly(J,q,!0)},b=(q,c)=>{const U=q.getEngine();for(let X=0;X<c.fileInfo.images.length;X++){const n=c.fileInfo.images[X].levels[0];if(q._invertVScale=q.invertY,-1===c.format||c.format===J.cTFRGB565)if(q.type=10,q.format=4,!U._features.basisNeedsPOT||Math.log2(n.width)%1===0&&Math.log2(n.height)%1===0)q._invertVScale=!q.invertY,q.width=n.width+3&-4,q.height=n.height+3&-4,q.samplingMode=2,H(q,U),U._uploadDataToTextureDirectly(q,new Uint16Array(n.transcodedPixels.buffer),X,0,4,!0);else{const c=new g.e(U,2);q._invertVScale=q.invertY,c.type=10,c.format=4,c.width=n.width+3&-4,c.height=n.height+3&-4,H(c,U),U._uploadDataToTextureDirectly(c,new Uint16Array(n.transcodedPixels.buffer),X,0,4,!0),U._rescaleTexture(c,q,U.scenes[0],U._getInternalFormat(4),(()=>{U._releaseTexture(c),H(q,U)}))}else{q.width=n.width,q.height=n.height,q.generateMipMaps=c.fileInfo.images[X].levels.length>1;const J=h.GetInternalFormatFromBasisFormat(c.format,U);q.format=J,H(q,U);const g=c.fileInfo.images[X].levels;for(let c=0;c<g.length;c++){const Q=g[c];U._uploadCompressedDataToTextureDirectly(q,J,Q.width,Q.height,Q.transcodedPixels,X,c)}!U._features.basisNeedsPOT||Math.log2(q.width)%1===0&&Math.log2(q.height)%1===0||(Q.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),q._cachedWrapU=s.c.CLAMP_ADDRESSMODE,q._cachedWrapV=s.c.CLAMP_ADDRESSMODE)}}},h={JSModuleURL:n.JSModuleURL,WasmModuleURL:n.WasmModuleURL,GetInternalFormatFromBasisFormat:(q,c)=>{let U;switch(q){case J.cTFETC1:U=36196;break;case J.cTFBC1:U=33776;break;case J.cTFBC4:U=33779;break;case J.cTFASTC_4x4:U=37808;break;case J.cTFETC2:U=37496;break;case J.cTFBC7:U=36492}if(void 0===U)throw"The chosen Basis transcoder format is not currently supported";return U},TranscodeAsync:r,LoadTextureFromTranscodeResult:b};Object.defineProperty(h,"JSModuleURL",{get:function(){return n.JSModuleURL},set:function(q){n.JSModuleURL=q}}),Object.defineProperty(h,"WasmModuleURL",{get:function(){return n.WasmModuleURL},set:function(q){n.WasmModuleURL=q}});class o{constructor(){this.supportCascades=!1}loadCubeData(q,c,U,J,s){if(Array.isArray(q))return;const g=c.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};r(q,X).then((q=>{const U=q.fileInfo.images[0].levels.length>1&&c.generateMipMaps;b(c,q),c.getEngine()._setCubeMapTextureParams(c,U),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),J&&J()})).catch((q=>{Q.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.isReady=!0,s&&s(q)}))}loadData(q,c,U){const J=c.getEngine().getCaps(),s={supportedCompressionFormats:{etc1:!!J.etc1,s3tc:!!J.s3tc,pvrtc:!!J.pvrtc,etc2:!!J.etc2,astc:!!J.astc,bc7:!!J.bptc}};r(q,s).then((q=>{const J=q.fileInfo.images[0].levels[0],Q=q.fileInfo.images[0].levels.length>1&&c.generateMipMaps;U(J.width,J.height,Q,-1!==q.format,(()=>{b(c,q)}))})).catch((q=>{Q.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Q.e.Warn(`Failed to transcode Basis file: ${q}`),U(0,0,!1,!1,(()=>{}),!0)}))}}}}]);