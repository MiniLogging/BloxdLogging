"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[29],{13801:(Z,l,C)=>{var B=C(12382),x=C(12263),b=C(12298),K=C(12403),f=C(12346),W=C(12389);f.d.prototype._partialLoadFile=function(Z,l,C,B){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(Z,(Z=>{C[l]=Z,C._internalCount++,6===C._internalCount&&B(C)}),void 0,void 0,!0,((Z,l)=>{x&&Z&&x(Z.status+" "+Z.statusText,l)}))},f.d.prototype._cascadeLoadFiles=function(Z,l,C){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const x=[];x._internalCount=0;for(let b=0;b<6;b++)this._partialLoadFile(C[b],b,x,l,B)},f.d.prototype._cascadeLoadImgs=function(Z,l,C,B){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,b=arguments.length>5?arguments[5]:void 0;const K=[];K._internalCount=0;for(let f=0;f<6;f++)this._partialLoadImg(B[f],f,K,Z,l,C,x,b)},f.d.prototype._partialLoadImg=function(Z,l,C,B,x,f){let W=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,J=arguments.length>7?arguments[7]:void 0;const d=(0,K.d)();(0,b.p)(Z,(Z=>{C[l]=Z,C._internalCount++,B&&B.removePendingData(d),6===C._internalCount&&f&&f(x,C)}),((Z,l)=>{B&&B.removePendingData(d),W&&W(Z,l)}),B?B.offlineProvider:null,J),B&&B.addPendingData(d)},f.d.prototype.createCubeTextureBase=function(Z,l,C,b){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,J=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,E=arguments.length>8&&void 0!==arguments[8]&&arguments[8],G=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,a=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,q=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,z=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,Y=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,P=arguments.length>14&&void 0!==arguments[14]&&arguments[14],S=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const i=q||new B.c(this,7);i.isCube=!0,i.url=Z,i.generateMipMaps=!b,i._lodGenerationScale=G,i._lodGenerationOffset=a,i._useSRGBBuffer=!!P&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!b),i!==q&&(i.label=Z.substring(0,60)),this._doNotHandleContextLost||(i._extension=d,i._files=C,i._buffer=S);const s=Z;this._transformTextureUrl&&!q&&(Z=this._transformTextureUrl(Z));const F=d??function(Z){const l=Z.split("?")[0],C=l.lastIndexOf(".");return C>-1?l.substring(C).toLowerCase():""}(Z),n=(0,W.d)(F),c=(Z,l)=>{i.dispose(),f?f(Z,l):Z&&x.e.Warn(Z)},U=(B,f)=>{Z===s?B&&c(B.status+" "+B.statusText,f):(x.e.Warn(`Failed to load ${Z}, falling back to the ${s}`),this.createCubeTextureBase(s,l,C,!!b,K,c,J,d,E,G,a,i,z,Y,P,S))};if(n)n.then((B=>{const x=Z=>{z&&z(i,Z),B.loadCubeData(Z,i,E,K,((Z,l)=>{c(Z,l)}))};S?x(S):C&&6===C.length?B.supportCascades?this._cascadeLoadFiles(l,(Z=>x(Z.map((Z=>new Uint8Array(Z))))),C,c):c("Textures type does not support cascades."):this._loadFile(Z,(Z=>x(new Uint8Array(Z))),void 0,void 0,!0,U)}));else{if(!C||0===C.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(l,i,((Z,l)=>{Y&&Y(Z,l)}),C,c)}return this._internalTexturesCache.push(i),i}},12940:(Z,l,C)=>{C.d(l,{c:()=>J});var B=C(12442),x=C(12460),b=C(12652),K=C(12451),f=C(12494);class W{constructor(Z,l,C,B){this.name=Z,this.worldAxisForNormal=l,this.worldAxisForFileX=C,this.worldAxisForFileY=B}}class J{static ConvertCubeMapTextureToSphericalPolynomial(Z){var l;if(!Z.isCube)return null;null===(l=Z.cZ())||void 0===l||l.getEngine().flushFramebuffer();const C=Z.getSize().width,B=Z.readPixels(0,void 0,void 0,!1),x=Z.readPixels(1,void 0,void 0,!1);let b,K;Z.isRenderTarget?(b=Z.readPixels(3,void 0,void 0,!1),K=Z.readPixels(2,void 0,void 0,!1)):(b=Z.readPixels(2,void 0,void 0,!1),K=Z.readPixels(3,void 0,void 0,!1));const f=Z.readPixels(4,void 0,void 0,!1),W=Z.readPixels(5,void 0,void 0,!1),J=Z.gammaSpace;let d=0;return 1!=Z.textureType&&2!=Z.textureType||(d=1),new Promise((Z=>{Promise.all([x,B,b,K,f,W]).then((l=>{let[B,x,b,K,f,W]=l;const E={size:C,right:x,left:B,up:b,down:K,front:f,back:W,format:5,type:d,gammaSpace:J};Z(this.ConvertCubeMapToSphericalPolynomial(E))}))}))}static _AreaElement(Z,l){return Math.atan2(Z*l,Math.sqrt(Z*Z+l*l+1))}static ConvertCubeMapToSphericalPolynomial(Z){const l=new b.d;let C=0;const B=2/Z.size,W=B,J=.5*B,d=J-1;for(let b=0;b<6;b++){const E=this._FileFaces[b],G=Z[E.name];let a=d;const q=5===Z.format?4:3;for(let b=0;b<Z.size;b++){let z=d;for(let W=0;W<Z.size;W++){const d=E.worldAxisForFileX.scale(z).add(E.worldAxisForFileY.scale(a)).add(E.worldAxisForNormal);d.normalize();const Y=this._AreaElement(z-J,a-J)-this._AreaElement(z-J,a+J)-this._AreaElement(z+J,a-J)+this._AreaElement(z+J,a+J);let P=G[b*Z.size*q+W*q+0],S=G[b*Z.size*q+W*q+1],i=G[b*Z.size*q+W*q+2];isNaN(P)&&(P=0),isNaN(S)&&(S=0),isNaN(i)&&(i=0),0===Z.type&&(P/=255,S/=255,i/=255),Z.gammaSpace&&(P=Math.pow((0,x.Clamp)(P),K.j),S=Math.pow((0,x.Clamp)(S),K.j),i=Math.pow((0,x.Clamp)(i),K.j));const s=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Z=Math.max(P,S,i);if(Z>s){const l=s/Z;P*=l,S*=l,i*=l}}else P=(0,x.Clamp)(P,0,s),S=(0,x.Clamp)(S,0,s),i=(0,x.Clamp)(i,0,s);const F=new f.Sl(P,S,i);l.addLight(d,F,Y),C+=Y,z+=B}a+=W}}const E=6*(4*Math.PI)/6/C;return l.scaleInPlace(E),l.convertIncidentRadianceToIrradiance(),l.convertIrradianceToLambertianRadiance(),b.g.FromHarmonics(l)}}J._FileFaces=[new W("right",new B.ql(1,0,0),new B.ql(0,0,-1),new B.ql(0,-1,0)),new W("left",new B.ql(-1,0,0),new B.ql(0,0,1),new B.ql(0,-1,0)),new W("up",new B.ql(0,1,0),new B.ql(1,0,0),new B.ql(0,0,1)),new W("down",new B.ql(0,-1,0),new B.ql(1,0,0),new B.ql(0,0,-1)),new W("front",new B.ql(0,0,1),new B.ql(1,0,0),new B.ql(0,-1,0)),new W("back",new B.ql(0,0,-1),new B.ql(-1,0,0),new B.ql(0,-1,0))],J.MAX_HDRI_VALUE=4096,J.PRESERVE_CLAMPED_COLORS=!1},14566:(Z,l,C)=>{C.d(l,{DDSTools:()=>q});var B=C(12460),x=C(12263),b=C(12940),K=C(12693);C(13801);const f=131072,W=131072;function J(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}const d=J("DXT1"),E=J("DXT3"),G=J("DXT5"),a=J("DX10");class q{static GetDDSInfo(Z){const l=new Int32Array(Z.buffer,Z.byteOffset,31),C=new Int32Array(Z.buffer,Z.byteOffset,35);let B=1;l[2]&f&&(B=Math.max(1,l[7]));const x=l[21],b=x===a?C[32]:0;let K=0;switch(x){case 113:K=2;break;case 116:K=1;break;case a:if(10===b){K=2;break}if(2===b){K=1;break}}return{width:l[4],height:l[3],mipmapCount:B,isFourCC:4===(4&l[20]),isRGB:64===(64&l[20]),isLuminance:(l[20]&W)===W,isCube:512===(512&l[28]),isCompressed:x===d||x===E||x===G,dxgiFormat:b,textureType:K}}static _GetHalfFloatAsFloatRGBAArrayBuffer(Z,l,C,B,x,b){const f=new Float32Array(B),W=new Uint16Array(x,C);let J=0;for(let d=0;d<l;d++)for(let l=0;l<Z;l++){const C=4*(l+d*Z);f[J]=(0,K.d)(W[C]),f[J+1]=(0,K.d)(W[C+1]),f[J+2]=(0,K.d)(W[C+2]),q.StoreLODInAlphaChannel?f[J+3]=b:f[J+3]=(0,K.d)(W[C+3]),J+=4}return f}static _GetHalfFloatRGBAArrayBuffer(Z,l,C,B,x,b){if(q.StoreLODInAlphaChannel){const f=new Uint16Array(B),W=new Uint16Array(x,C);let J=0;for(let C=0;C<l;C++)for(let l=0;l<Z;l++){const B=4*(l+C*Z);f[J]=W[B],f[J+1]=W[B+1],f[J+2]=W[B+2],f[J+3]=(0,K.o)(b),J+=4}return f}return new Uint16Array(x,C,B)}static _GetFloatRGBAArrayBuffer(Z,l,C,B,x,b){if(q.StoreLODInAlphaChannel){const K=new Float32Array(B),f=new Float32Array(x,C);let W=0;for(let C=0;C<l;C++)for(let l=0;l<Z;l++){const B=4*(l+C*Z);K[W]=f[B],K[W+1]=f[B+1],K[W+2]=f[B+2],K[W+3]=b,W+=4}return K}return new Float32Array(x,C,B)}static _GetFloatAsHalfFloatRGBAArrayBuffer(Z,l,C,B,x,b){const f=new Uint16Array(B),W=new Float32Array(x,C);let J=0;for(let d=0;d<l;d++)for(let l=0;l<Z;l++)f[J]=(0,K.o)(W[J]),f[J+1]=(0,K.o)(W[J+1]),f[J+2]=(0,K.o)(W[J+2]),q.StoreLODInAlphaChannel?f[J+3]=(0,K.o)(b):f[J+3]=(0,K.o)(W[J+3]),J+=4;return f}static _GetFloatAsUIntRGBAArrayBuffer(Z,l,C,x,b,K){const f=new Uint8Array(x),W=new Float32Array(b,C);let J=0;for(let d=0;d<l;d++)for(let l=0;l<Z;l++){const C=4*(l+d*Z);f[J]=255*(0,B.Clamp)(W[C]),f[J+1]=255*(0,B.Clamp)(W[C+1]),f[J+2]=255*(0,B.Clamp)(W[C+2]),q.StoreLODInAlphaChannel?f[J+3]=K:f[J+3]=255*(0,B.Clamp)(W[C+3]),J+=4}return f}static _GetHalfFloatAsUIntRGBAArrayBuffer(Z,l,C,x,b,f){const W=new Uint8Array(x),J=new Uint16Array(b,C);let d=0;for(let E=0;E<l;E++)for(let l=0;l<Z;l++){const C=4*(l+E*Z);W[d]=255*(0,B.Clamp)((0,K.d)(J[C])),W[d+1]=255*(0,B.Clamp)((0,K.d)(J[C+1])),W[d+2]=255*(0,B.Clamp)((0,K.d)(J[C+2])),q.StoreLODInAlphaChannel?W[d+3]=f:W[d+3]=255*(0,B.Clamp)((0,K.d)(J[C+3])),d+=4}return W}static _GetRGBAArrayBuffer(Z,l,C,B,x,b,K,f,W){const J=new Uint8Array(B),d=new Uint8Array(x,C);let E=0;for(let G=0;G<l;G++)for(let l=0;l<Z;l++){const C=4*(l+G*Z);J[E]=d[C+b],J[E+1]=d[C+K],J[E+2]=d[C+f],J[E+3]=d[C+W],E+=4}return J}static _ExtractLongWordOrder(Z){return 0===Z||255===Z||-16777216===Z?0:1+q._ExtractLongWordOrder(Z>>8)}static _GetRGBArrayBuffer(Z,l,C,B,x,b,K,f){const W=new Uint8Array(B),J=new Uint8Array(x,C);let d=0;for(let E=0;E<l;E++)for(let l=0;l<Z;l++){const C=3*(l+E*Z);W[d]=J[C+b],W[d+1]=J[C+K],W[d+2]=J[C+f],d+=3}return W}static _GetLuminanceArrayBuffer(Z,l,C,B,x){const b=new Uint8Array(B),K=new Uint8Array(x,C);let f=0;for(let W=0;W<l;W++)for(let l=0;l<Z;l++){const C=l+W*Z;b[f]=K[C],f++}return b}static UploadDDSLevels(Z,l,C,B,K,W){let J=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,z=arguments.length>7?arguments[7]:void 0,Y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],P=null;B.sphericalPolynomial&&(P=[]);const S=!!Z.getCaps().s3tc;l.generateMipMaps=K;const i=new Int32Array(C.buffer,C.byteOffset,31);let s,F,n,c,U,t,r,e=0,o=0,v=1;if(542327876!==i[0])return void x.e.Error("Invalid magic number in DDS header");if(!B.isFourCC&&!B.isRGB&&!B.isLuminance)return void x.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(B.isCompressed&&!S)return void x.e.Error("Compressed textures are not supported on this platform.");let R=i[22];c=i[1]+4;let k=!1;if(B.isFourCC)switch(s=i[21],s){case d:v=8,o=33777;break;case E:v=16,o=33778;break;case G:v=16,o=33779;break;case 113:k=!0,R=64;break;case 116:k=!0,R=128;break;case a:{c+=20;let Z=!1;switch(B.dxgiFormat){case 10:k=!0,R=64,Z=!0;break;case 2:k=!0,R=128,Z=!0;break;case 88:B.isRGB=!0,B.isFourCC=!1,R=32,Z=!0}if(Z)break}default:return void x.e.Error(["Unsupported FourCC code:",(V=s,String.fromCharCode(255&V,V>>8&255,V>>16&255,V>>24&255))])}var V;const g=q._ExtractLongWordOrder(i[23]),j=q._ExtractLongWordOrder(i[24]),M=q._ExtractLongWordOrder(i[25]),I=q._ExtractLongWordOrder(i[26]);k&&(o=Z._getRGBABufferInternalSizedFormat(B.textureType)),t=1,i[2]&f&&!1!==K&&(t=Math.max(1,i[7]));const w=z||0,O=Z.getCaps();for(let x=w;x<W;x++){for(F=i[4],n=i[3],r=0;r<t;++r){if(-1===J||J===r){const b=-1===J?r:0;if(!B.isCompressed&&B.isFourCC){l.format=5,e=F*n*4;let B=null;if(Z._badOS||Z._badDesktopOS||!O.textureHalfFloat&&!O.textureFloat)128===R?(B=q._GetFloatAsUIntRGBAArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,b),P&&0==b&&P.push(q._GetFloatRGBAArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,b))):64===R&&(B=q._GetHalfFloatAsUIntRGBAArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,b),P&&0==b&&P.push(q._GetHalfFloatAsFloatRGBAArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,b))),l.type=0;else{const Z=O.textureFloat&&(Y&&O.textureFloatLinearFiltering||!Y),x=O.textureHalfFloat&&(Y&&O.textureHalfFloatLinearFiltering||!Y),K=(128===R||64===R&&!x)&&Z?1:(64===R||128===R&&!Z)&&x?2:0;let f,W=null;if(128===R)switch(K){case 1:f=q._GetFloatRGBAArrayBuffer,W=null;break;case 2:f=q._GetFloatAsHalfFloatRGBAArrayBuffer,W=q._GetFloatRGBAArrayBuffer;break;case 0:f=q._GetFloatAsUIntRGBAArrayBuffer,W=q._GetFloatRGBAArrayBuffer}else switch(K){case 1:f=q._GetHalfFloatAsFloatRGBAArrayBuffer,W=null;break;case 2:f=q._GetHalfFloatRGBAArrayBuffer,W=q._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:f=q._GetHalfFloatAsUIntRGBAArrayBuffer,W=q._GetHalfFloatAsFloatRGBAArrayBuffer}l.type=K,B=f(F,n,C.byteOffset+c,e,C.buffer,b),P&&0==b&&P.push(W?W(F,n,C.byteOffset+c,e,C.buffer,b):B)}B&&Z._uploadDataToTextureDirectly(l,B,x,b)}else if(B.isRGB)l.type=0,24===R?(l.format=4,e=F*n*3,U=q._GetRGBArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,g,j,M),Z._uploadDataToTextureDirectly(l,U,x,b)):(l.format=5,e=F*n*4,U=q._GetRGBAArrayBuffer(F,n,C.byteOffset+c,e,C.buffer,g,j,M,I),Z._uploadDataToTextureDirectly(l,U,x,b));else if(B.isLuminance){const B=Z._getUnpackAlignement(),K=F;e=Math.floor((F+B-1)/B)*B*(n-1)+K,U=q._GetLuminanceArrayBuffer(F,n,C.byteOffset+c,e,C.buffer),l.format=1,l.type=0,Z._uploadDataToTextureDirectly(l,U,x,b)}else e=Math.max(4,F)/4*Math.max(4,n)/4*v,U=new Uint8Array(C.buffer,C.byteOffset+c,e),l.type=0,Z._uploadCompressedDataToTextureDirectly(l,o,F,n,U,x,b)}c+=R?F*n*(R/8):e,F*=.5,n*=.5,F=Math.max(1,F),n=Math.max(1,n)}if(void 0!==z)break}P&&P.length>0?B.sphericalPolynomial=b.c.ConvertCubeMapToSphericalPolynomial({size:i[4],right:P[0],left:P[1],up:P[2],down:P[3],front:P[4],back:P[5],format:5,type:1,gammaSpace:!1}):B.sphericalPolynomial=void 0}}q.StoreLODInAlphaChannel=!1}}]);