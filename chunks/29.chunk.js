"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[29],{14334:(D,h,o)=>{var H=o(12771),g=o(12658),j=o(12691),M=o(12798),R=o(12731),t=o(12784);R.e.prototype._partialLoadFile=function(D,h,o,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(D,(D=>{o[h]=D,o._internalCount++,6===o._internalCount&&H(o)}),void 0,void 0,!0,((D,h)=>{g&&D&&g(D.status+" "+D.statusText,h)}))},R.e.prototype._cascadeLoadFiles=function(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const g=[];g._internalCount=0;for(let j=0;j<6;j++)this._partialLoadFile(o[j],j,g,h,H)},R.e.prototype._cascadeLoadImgs=function(D,h,o,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,j=arguments.length>5?arguments[5]:void 0;const M=[];M._internalCount=0;for(let R=0;R<6;R++)this._partialLoadImg(H[R],R,M,D,h,o,g,j)},R.e.prototype._partialLoadImg=function(D,h,o,H,g,R){let t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,S=arguments.length>7?arguments[7]:void 0;const k=(0,M.d)();(0,j.s)(D,(D=>{o[h]=D,o._internalCount++,H&&H.removePendingData(k),6===o._internalCount&&R&&R(g,o)}),((D,h)=>{H&&H.removePendingData(k),t&&t(D,h)}),H?H.offlineProvider:null,S),H&&H.addPendingData(k)},R.e.prototype.createCubeTextureBase=function(D,h,o,j){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,S=arguments.length>6?arguments[6]:void 0,k=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,K=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Q=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,v=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,r=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,B=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,s=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,U=arguments.length>14&&void 0!==arguments[14]&&arguments[14],q=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const c=r||new H.c(this,7);c.isCube=!0,c.url=D,c.generateMipMaps=!j,c._lodGenerationScale=Q,c._lodGenerationOffset=v,c._useSRGBBuffer=!!U&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!j),c!==r&&(c.label=D.substring(0,60)),this._doNotHandleContextLost||(c._extension=k,c._files=o,c._buffer=q);const y=D;this._transformTextureUrl&&!r&&(D=this._transformTextureUrl(D));const b=k??function(D){const h=D.split("?")[0],o=h.lastIndexOf(".");return o>-1?h.substring(o).toLowerCase():""}(D),i=(0,t.d)(b),G=(D,h)=>{c.dispose(),R?R(D,h):D&&g.d.Warn(D)},N=(H,R)=>{D===y?H&&G(H.status+" "+H.statusText,R):(g.d.Warn(`Failed to load ${D}, falling back to the ${y}`),this.createCubeTextureBase(y,h,o,!!j,M,G,S,k,K,Q,v,c,B,s,U,q))};if(i)i.then((H=>{const g=D=>{B&&B(c,D),H.loadCubeData(D,c,K,M,((D,h)=>{G(D,h)}))};q?g(q):o&&6===o.length?H.supportCascades?this._cascadeLoadFiles(h,(D=>g(D.map((D=>new Uint8Array(D))))),o,G):G("Textures type does not support cascades."):this._loadFile(D,(D=>g(new Uint8Array(D))),void 0,void 0,!0,N)}));else{if(!o||0===o.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(h,c,((D,h)=>{s&&s(D,h)}),o,G)}return this._internalTexturesCache.push(c),c}},13370:(D,h,o)=>{o.d(h,{b:()=>S});var H=o(12831),g=o(12842),j=o(13016),M=o(12833),R=o(12870);class t{constructor(D,h,o,H){this.name=D,this.worldAxisForNormal=h,this.worldAxisForFileX=o,this.worldAxisForFileY=H}}class S{static ConvertCubeMapTextureToSphericalPolynomial(D){var h;if(!D.isCube)return null;null===(h=D.GD())||void 0===h||h.getEngine().flushFramebuffer();const o=D.getSize().width,H=D.readPixels(0,void 0,void 0,!1),g=D.readPixels(1,void 0,void 0,!1);let j,M;D.isRenderTarget?(j=D.readPixels(3,void 0,void 0,!1),M=D.readPixels(2,void 0,void 0,!1)):(j=D.readPixels(2,void 0,void 0,!1),M=D.readPixels(3,void 0,void 0,!1));const R=D.readPixels(4,void 0,void 0,!1),t=D.readPixels(5,void 0,void 0,!1),S=D.gammaSpace;let k=0;return 1!=D.textureType&&2!=D.textureType||(k=1),new Promise((D=>{Promise.all([g,H,j,M,R,t]).then((h=>{let[H,g,j,M,R,t]=h;const K={size:o,right:g,left:H,up:j,down:M,front:R,back:t,format:5,type:k,gammaSpace:S};D(this.ConvertCubeMapToSphericalPolynomial(K))}))}))}static _AreaElement(D,h){return Math.atan2(D*h,Math.sqrt(D*D+h*h+1))}static ConvertCubeMapToSphericalPolynomial(D){const h=new j.c;let o=0;const H=2/D.size,t=H,S=.5*H,k=S-1;for(let j=0;j<6;j++){const K=this._FileFaces[j],Q=D[K.name];let v=k;const r=5===D.format?4:3;for(let j=0;j<D.size;j++){let B=k;for(let t=0;t<D.size;t++){const k=K.worldAxisForFileX.scale(B).add(K.worldAxisForFileY.scale(v)).add(K.worldAxisForNormal);k.normalize();const s=this._AreaElement(B-S,v-S)-this._AreaElement(B-S,v+S)-this._AreaElement(B+S,v-S)+this._AreaElement(B+S,v+S);let U=Q[j*D.size*r+t*r+0],q=Q[j*D.size*r+t*r+1],c=Q[j*D.size*r+t*r+2];isNaN(U)&&(U=0),isNaN(q)&&(q=0),isNaN(c)&&(c=0),0===D.type&&(U/=255,q/=255,c/=255),D.gammaSpace&&(U=Math.pow((0,g.Clamp)(U),M.l),q=Math.pow((0,g.Clamp)(q),M.l),c=Math.pow((0,g.Clamp)(c),M.l));const y=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const D=Math.max(U,q,c);if(D>y){const h=y/D;U*=h,q*=h,c*=h}}else U=(0,g.Clamp)(U,0,y),q=(0,g.Clamp)(q,0,y),c=(0,g.Clamp)(c,0,y);const b=new R.mo(U,q,c);h.addLight(k,b,s),o+=s,B+=H}v+=t}}const K=6*(4*Math.PI)/6/o;return h.scaleInPlace(K),h.convertIncidentRadianceToIrradiance(),h.convertIrradianceToLambertianRadiance(),j.g.FromHarmonics(h)}}S._FileFaces=[new t("right",new H.Gh(1,0,0),new H.Gh(0,0,-1),new H.Gh(0,-1,0)),new t("left",new H.Gh(-1,0,0),new H.Gh(0,0,1),new H.Gh(0,-1,0)),new t("up",new H.Gh(0,1,0),new H.Gh(1,0,0),new H.Gh(0,0,1)),new t("down",new H.Gh(0,-1,0),new H.Gh(1,0,0),new H.Gh(0,0,-1)),new t("front",new H.Gh(0,0,1),new H.Gh(1,0,0),new H.Gh(0,-1,0)),new t("back",new H.Gh(0,0,-1),new H.Gh(-1,0,0),new H.Gh(0,-1,0))],S.MAX_HDRI_VALUE=4096,S.PRESERVE_CLAMPED_COLORS=!1},15156:(D,h,o)=>{o.d(h,{DDSTools:()=>r});var H=o(12842),g=o(12658),j=o(13370),M=o(13053);o(14334);const R=131072,t=131072;function S(D){return D.charCodeAt(0)+(D.charCodeAt(1)<<8)+(D.charCodeAt(2)<<16)+(D.charCodeAt(3)<<24)}const k=S("DXT1"),K=S("DXT3"),Q=S("DXT5"),v=S("DX10");class r{static GetDDSInfo(D){const h=new Int32Array(D.buffer,D.byteOffset,31),o=new Int32Array(D.buffer,D.byteOffset,35);let H=1;h[2]&R&&(H=Math.max(1,h[7]));const g=h[21],j=g===v?o[32]:0;let M=0;switch(g){case 113:M=2;break;case 116:M=1;break;case v:if(10===j){M=2;break}if(2===j){M=1;break}}return{width:h[4],height:h[3],mipmapCount:H,isFourCC:4===(4&h[20]),isRGB:64===(64&h[20]),isLuminance:(h[20]&t)===t,isCube:512===(512&h[28]),isCompressed:g===k||g===K||g===Q,dxgiFormat:j,textureType:M}}static _GetHalfFloatAsFloatRGBAArrayBuffer(D,h,o,H,g,j){const R=new Float32Array(H),t=new Uint16Array(g,o);let S=0;for(let k=0;k<h;k++)for(let h=0;h<D;h++){const o=4*(h+k*D);R[S]=(0,M.h)(t[o]),R[S+1]=(0,M.h)(t[o+1]),R[S+2]=(0,M.h)(t[o+2]),r.StoreLODInAlphaChannel?R[S+3]=j:R[S+3]=(0,M.h)(t[o+3]),S+=4}return R}static _GetHalfFloatRGBAArrayBuffer(D,h,o,H,g,j){if(r.StoreLODInAlphaChannel){const R=new Uint16Array(H),t=new Uint16Array(g,o);let S=0;for(let o=0;o<h;o++)for(let h=0;h<D;h++){const H=4*(h+o*D);R[S]=t[H],R[S+1]=t[H+1],R[S+2]=t[H+2],R[S+3]=(0,M.p)(j),S+=4}return R}return new Uint16Array(g,o,H)}static _GetFloatRGBAArrayBuffer(D,h,o,H,g,j){if(r.StoreLODInAlphaChannel){const M=new Float32Array(H),R=new Float32Array(g,o);let t=0;for(let o=0;o<h;o++)for(let h=0;h<D;h++){const H=4*(h+o*D);M[t]=R[H],M[t+1]=R[H+1],M[t+2]=R[H+2],M[t+3]=j,t+=4}return M}return new Float32Array(g,o,H)}static _GetFloatAsHalfFloatRGBAArrayBuffer(D,h,o,H,g,j){const R=new Uint16Array(H),t=new Float32Array(g,o);let S=0;for(let k=0;k<h;k++)for(let h=0;h<D;h++)R[S]=(0,M.p)(t[S]),R[S+1]=(0,M.p)(t[S+1]),R[S+2]=(0,M.p)(t[S+2]),r.StoreLODInAlphaChannel?R[S+3]=(0,M.p)(j):R[S+3]=(0,M.p)(t[S+3]),S+=4;return R}static _GetFloatAsUIntRGBAArrayBuffer(D,h,o,g,j,M){const R=new Uint8Array(g),t=new Float32Array(j,o);let S=0;for(let k=0;k<h;k++)for(let h=0;h<D;h++){const o=4*(h+k*D);R[S]=255*(0,H.Clamp)(t[o]),R[S+1]=255*(0,H.Clamp)(t[o+1]),R[S+2]=255*(0,H.Clamp)(t[o+2]),r.StoreLODInAlphaChannel?R[S+3]=M:R[S+3]=255*(0,H.Clamp)(t[o+3]),S+=4}return R}static _GetHalfFloatAsUIntRGBAArrayBuffer(D,h,o,g,j,R){const t=new Uint8Array(g),S=new Uint16Array(j,o);let k=0;for(let K=0;K<h;K++)for(let h=0;h<D;h++){const o=4*(h+K*D);t[k]=255*(0,H.Clamp)((0,M.h)(S[o])),t[k+1]=255*(0,H.Clamp)((0,M.h)(S[o+1])),t[k+2]=255*(0,H.Clamp)((0,M.h)(S[o+2])),r.StoreLODInAlphaChannel?t[k+3]=R:t[k+3]=255*(0,H.Clamp)((0,M.h)(S[o+3])),k+=4}return t}static _GetRGBAArrayBuffer(D,h,o,H,g,j,M,R,t){const S=new Uint8Array(H),k=new Uint8Array(g,o);let K=0;for(let Q=0;Q<h;Q++)for(let h=0;h<D;h++){const o=4*(h+Q*D);S[K]=k[o+j],S[K+1]=k[o+M],S[K+2]=k[o+R],S[K+3]=k[o+t],K+=4}return S}static _ExtractLongWordOrder(D){return 0===D||255===D||-16777216===D?0:1+r._ExtractLongWordOrder(D>>8)}static _GetRGBArrayBuffer(D,h,o,H,g,j,M,R){const t=new Uint8Array(H),S=new Uint8Array(g,o);let k=0;for(let K=0;K<h;K++)for(let h=0;h<D;h++){const o=3*(h+K*D);t[k]=S[o+j],t[k+1]=S[o+M],t[k+2]=S[o+R],k+=3}return t}static _GetLuminanceArrayBuffer(D,h,o,H,g){const j=new Uint8Array(H),M=new Uint8Array(g,o);let R=0;for(let t=0;t<h;t++)for(let h=0;h<D;h++){const o=h+t*D;j[R]=M[o],R++}return j}static UploadDDSLevels(D,h,o,H,M,t){let S=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,B=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],U=null;H.sphericalPolynomial&&(U=[]);const q=!!D.getCaps().s3tc;h.generateMipMaps=M;const c=new Int32Array(o.buffer,o.byteOffset,31);let y,b,i,G,N,J,O,E=0,L=0,T=1;if(542327876!==c[0])return void g.d.Error("Invalid magic number in DDS header");if(!H.isFourCC&&!H.isRGB&&!H.isLuminance)return void g.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(H.isCompressed&&!q)return void g.d.Error("Compressed textures are not supported on this platform.");let Z=c[22];G=c[1]+4;let e=!1;if(H.isFourCC)switch(y=c[21],y){case k:T=8,L=33777;break;case K:T=16,L=33778;break;case Q:T=16,L=33779;break;case 113:e=!0,Z=64;break;case 116:e=!0,Z=128;break;case v:{G+=20;let D=!1;switch(H.dxgiFormat){case 10:e=!0,Z=64,D=!0;break;case 2:e=!0,Z=128,D=!0;break;case 88:H.isRGB=!0,H.isFourCC=!1,Z=32,D=!0}if(D)break}default:return void g.d.Error(["Unsupported FourCC code:",(p=y,String.fromCharCode(255&p,p>>8&255,p>>16&255,p>>24&255))])}var p;const mD=r._ExtractLongWordOrder(c[23]),a=r._ExtractLongWordOrder(c[24]),u=r._ExtractLongWordOrder(c[25]),I=r._ExtractLongWordOrder(c[26]);e&&(L=D._getRGBABufferInternalSizedFormat(H.textureType)),J=1,c[2]&R&&!1!==M&&(J=Math.max(1,c[7]));const P=B||0,n=D.getCaps();for(let g=P;g<t;g++){for(b=c[4],i=c[3],O=0;O<J;++O){if(-1===S||S===O){const j=-1===S?O:0;if(!H.isCompressed&&H.isFourCC){h.format=5,E=b*i*4;let H=null;if(D._badOS||D._badDesktopOS||!n.textureHalfFloat&&!n.textureFloat)128===Z?(H=r._GetFloatAsUIntRGBAArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,j),U&&0==j&&U.push(r._GetFloatRGBAArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,j))):64===Z&&(H=r._GetHalfFloatAsUIntRGBAArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,j),U&&0==j&&U.push(r._GetHalfFloatAsFloatRGBAArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,j))),h.type=0;else{const D=n.textureFloat&&(s&&n.textureFloatLinearFiltering||!s),g=n.textureHalfFloat&&(s&&n.textureHalfFloatLinearFiltering||!s),M=(128===Z||64===Z&&!g)&&D?1:(64===Z||128===Z&&!D)&&g?2:0;let R,t=null;if(128===Z)switch(M){case 1:R=r._GetFloatRGBAArrayBuffer,t=null;break;case 2:R=r._GetFloatAsHalfFloatRGBAArrayBuffer,t=r._GetFloatRGBAArrayBuffer;break;case 0:R=r._GetFloatAsUIntRGBAArrayBuffer,t=r._GetFloatRGBAArrayBuffer}else switch(M){case 1:R=r._GetHalfFloatAsFloatRGBAArrayBuffer,t=null;break;case 2:R=r._GetHalfFloatRGBAArrayBuffer,t=r._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:R=r._GetHalfFloatAsUIntRGBAArrayBuffer,t=r._GetHalfFloatAsFloatRGBAArrayBuffer}h.type=M,H=R(b,i,o.byteOffset+G,E,o.buffer,j),U&&0==j&&U.push(t?t(b,i,o.byteOffset+G,E,o.buffer,j):H)}H&&D._uploadDataToTextureDirectly(h,H,g,j)}else if(H.isRGB)h.type=0,24===Z?(h.format=4,E=b*i*3,N=r._GetRGBArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,mD,a,u),D._uploadDataToTextureDirectly(h,N,g,j)):(h.format=5,E=b*i*4,N=r._GetRGBAArrayBuffer(b,i,o.byteOffset+G,E,o.buffer,mD,a,u,I),D._uploadDataToTextureDirectly(h,N,g,j));else if(H.isLuminance){const H=D._getUnpackAlignement(),M=b;E=Math.floor((b+H-1)/H)*H*(i-1)+M,N=r._GetLuminanceArrayBuffer(b,i,o.byteOffset+G,E,o.buffer),h.format=1,h.type=0,D._uploadDataToTextureDirectly(h,N,g,j)}else E=Math.max(4,b)/4*Math.max(4,i)/4*T,N=new Uint8Array(o.buffer,o.byteOffset+G,E),h.type=0,D._uploadCompressedDataToTextureDirectly(h,L,b,i,N,g,j)}G+=Z?b*i*(Z/8):E,b*=.5,i*=.5,b=Math.max(1,b),i=Math.max(1,i)}if(void 0!==B)break}U&&U.length>0?H.sphericalPolynomial=j.b.ConvertCubeMapToSphericalPolynomial({size:c[4],right:U[0],left:U[1],up:U[2],down:U[3],front:U[4],back:U[5],format:5,type:1,gammaSpace:!1}):H.sphericalPolynomial=void 0}}r.StoreLODInAlphaChannel=!1}}]);