"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[29],{12920:(F,b,Q)=>{var C=Q(11241),z=Q(11146),t=Q(11170),g=Q(11272),W=Q(11203),Z=Q(11259);W.d.prototype._partialLoadFile=function(F,b,Q,C){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(F,(F=>{Q[b]=F,Q._internalCount++,6===Q._internalCount&&C(Q)}),void 0,void 0,!0,((F,b)=>{z&&F&&z(F.status+" "+F.statusText,b)}))},W.d.prototype._cascadeLoadFiles=function(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const z=[];z._internalCount=0;for(let t=0;t<6;t++)this._partialLoadFile(Q[t],t,z,b,C)},W.d.prototype._cascadeLoadImgs=function(F,b,Q,C){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,t=arguments.length>5?arguments[5]:void 0;const g=[];g._internalCount=0;for(let W=0;W<6;W++)this._partialLoadImg(C[W],W,g,F,b,Q,z,t)},W.d.prototype._partialLoadImg=function(F,b,Q,C,z,W){let Z=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,q=arguments.length>7?arguments[7]:void 0;const G=(0,g.b)();(0,t.t)(F,(F=>{Q[b]=F,Q._internalCount++,C&&C.removePendingData(G),6===Q._internalCount&&W&&W(z,Q)}),((F,b)=>{C&&C.removePendingData(G),Z&&Z(F,b)}),C?C.offlineProvider:null,q),C&&C.addPendingData(G)},W.d.prototype.createCubeTextureBase=function(F,b,Q,t){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,W=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,q=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,K=arguments.length>8&&void 0!==arguments[8]&&arguments[8],e=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,N=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,y=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,E=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,c=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,X=arguments.length>14&&void 0!==arguments[14]&&arguments[14],L=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const i=y||new C.b(this,7);i.isCube=!0,i.url=F,i.generateMipMaps=!t,i._lodGenerationScale=e,i._lodGenerationOffset=N,i._useSRGBBuffer=!!X&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!t),i!==y&&(i.label=F.substring(0,60)),this._doNotHandleContextLost||(i._extension=G,i._files=Q,i._buffer=L);const f=F;this._transformTextureUrl&&!y&&(F=this._transformTextureUrl(F));const k=G??function(F){const b=F.split("?")[0],Q=b.lastIndexOf(".");return Q>-1?b.substring(Q).toLowerCase():""}(F),m=(0,Z.b)(k),R=(F,b)=>{i.dispose(),W?W(F,b):F&&z.e.Warn(F)},p=(C,W)=>{F===f?C&&R(C.status+" "+C.statusText,W):(z.e.Warn(`Failed to load ${F}, falling back to the ${f}`),this.createCubeTextureBase(f,b,Q,!!t,g,R,q,G,K,e,N,i,E,c,X,L))};if(m)m.then((C=>{const z=F=>{E&&E(i,F),C.loadCubeData(F,i,K,g,((F,b)=>{R(F,b)}))};L?z(L):Q&&6===Q.length?C.supportCascades?this._cascadeLoadFiles(b,(F=>z(F.map((F=>new Uint8Array(F))))),Q,R):R("Textures type does not support cascades."):this._loadFile(F,(F=>z(new Uint8Array(F))),void 0,void 0,!0,p)}));else{if(!Q||0===Q.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(b,i,((F,b)=>{c&&c(F,b)}),Q,R)}return this._internalTexturesCache.push(i),i}},11805:(F,b,Q)=>{Q.d(b,{e:()=>q});var C=Q(11309),z=Q(11329),t=Q(11505),g=Q(11318),W=Q(11359);class Z{constructor(F,b,Q,C){this.name=F,this.worldAxisForNormal=b,this.worldAxisForFileX=Q,this.worldAxisForFileY=C}}class q{static ConvertCubeMapTextureToSphericalPolynomial(F){var b;if(!F.isCube)return null;null===(b=F.RF())||void 0===b||b.getEngine().flushFramebuffer();const Q=F.getSize().width,C=F.readPixels(0,void 0,void 0,!1),z=F.readPixels(1,void 0,void 0,!1);let t,g;F.isRenderTarget?(t=F.readPixels(3,void 0,void 0,!1),g=F.readPixels(2,void 0,void 0,!1)):(t=F.readPixels(2,void 0,void 0,!1),g=F.readPixels(3,void 0,void 0,!1));const W=F.readPixels(4,void 0,void 0,!1),Z=F.readPixels(5,void 0,void 0,!1),q=F.gammaSpace;let G=0;return 1!=F.textureType&&2!=F.textureType||(G=1),new Promise((F=>{Promise.all([z,C,t,g,W,Z]).then((b=>{let[C,z,t,g,W,Z]=b;const K={size:Q,right:z,left:C,up:t,down:g,front:W,back:Z,format:5,type:G,gammaSpace:q};F(this.ConvertCubeMapToSphericalPolynomial(K))}))}))}static _AreaElement(F,b){return Math.atan2(F*b,Math.sqrt(F*F+b*b+1))}static ConvertCubeMapToSphericalPolynomial(F){const b=new t.c;let Q=0;const C=2/F.size,Z=C,q=.5*C,G=q-1;for(let t=0;t<6;t++){const K=this._FileFaces[t],e=F[K.name];let N=G;const y=5===F.format?4:3;for(let t=0;t<F.size;t++){let E=G;for(let Z=0;Z<F.size;Z++){const G=K.worldAxisForFileX.scale(E).add(K.worldAxisForFileY.scale(N)).add(K.worldAxisForNormal);G.normalize();const c=this._AreaElement(E-q,N-q)-this._AreaElement(E-q,N+q)-this._AreaElement(E+q,N-q)+this._AreaElement(E+q,N+q);let X=e[t*F.size*y+Z*y+0],L=e[t*F.size*y+Z*y+1],i=e[t*F.size*y+Z*y+2];isNaN(X)&&(X=0),isNaN(L)&&(L=0),isNaN(i)&&(i=0),0===F.type&&(X/=255,L/=255,i/=255),F.gammaSpace&&(X=Math.pow((0,z.Clamp)(X),g.j),L=Math.pow((0,z.Clamp)(L),g.j),i=Math.pow((0,z.Clamp)(i),g.j));const f=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const F=Math.max(X,L,i);if(F>f){const b=f/F;X*=b,L*=b,i*=b}}else X=(0,z.Clamp)(X,0,f),L=(0,z.Clamp)(L,0,f),i=(0,z.Clamp)(i,0,f);const k=new W.GQ(X,L,i);b.addLight(G,k,c),Q+=c,E+=C}N+=Z}}const K=6*(4*Math.PI)/6/Q;return b.scaleInPlace(K),b.convertIncidentRadianceToIrradiance(),b.convertIrradianceToLambertianRadiance(),t.e.FromHarmonics(b)}}q._FileFaces=[new Z("right",new C.gQ(1,0,0),new C.gQ(0,0,-1),new C.gQ(0,-1,0)),new Z("left",new C.gQ(-1,0,0),new C.gQ(0,0,1),new C.gQ(0,-1,0)),new Z("up",new C.gQ(0,1,0),new C.gQ(1,0,0),new C.gQ(0,0,1)),new Z("down",new C.gQ(0,-1,0),new C.gQ(1,0,0),new C.gQ(0,0,-1)),new Z("front",new C.gQ(0,0,1),new C.gQ(1,0,0),new C.gQ(0,-1,0)),new Z("back",new C.gQ(0,0,-1),new C.gQ(-1,0,0),new C.gQ(0,-1,0))],q.MAX_HDRI_VALUE=4096,q.PRESERVE_CLAMPED_COLORS=!1},13692:(F,b,Q)=>{Q.d(b,{DDSTools:()=>y});var C=Q(11329),z=Q(11146),t=Q(11805),g=Q(11529);Q(12920);const W=131072,Z=131072;function q(F){return F.charCodeAt(0)+(F.charCodeAt(1)<<8)+(F.charCodeAt(2)<<16)+(F.charCodeAt(3)<<24)}const G=q("DXT1"),K=q("DXT3"),e=q("DXT5"),N=q("DX10");class y{static GetDDSInfo(F){const b=new Int32Array(F.buffer,F.byteOffset,31),Q=new Int32Array(F.buffer,F.byteOffset,35);let C=1;b[2]&W&&(C=Math.max(1,b[7]));const z=b[21],t=z===N?Q[32]:0;let g=0;switch(z){case 113:g=2;break;case 116:g=1;break;case N:if(10===t){g=2;break}if(2===t){g=1;break}}return{width:b[4],height:b[3],mipmapCount:C,isFourCC:4===(4&b[20]),isRGB:64===(64&b[20]),isLuminance:(b[20]&Z)===Z,isCube:512===(512&b[28]),isCompressed:z===G||z===K||z===e,dxgiFormat:t,textureType:g}}static _GetHalfFloatAsFloatRGBAArrayBuffer(F,b,Q,C,z,t){const W=new Float32Array(C),Z=new Uint16Array(z,Q);let q=0;for(let G=0;G<b;G++)for(let b=0;b<F;b++){const Q=4*(b+G*F);W[q]=(0,g.e)(Z[Q]),W[q+1]=(0,g.e)(Z[Q+1]),W[q+2]=(0,g.e)(Z[Q+2]),y.StoreLODInAlphaChannel?W[q+3]=t:W[q+3]=(0,g.e)(Z[Q+3]),q+=4}return W}static _GetHalfFloatRGBAArrayBuffer(F,b,Q,C,z,t){if(y.StoreLODInAlphaChannel){const W=new Uint16Array(C),Z=new Uint16Array(z,Q);let q=0;for(let Q=0;Q<b;Q++)for(let b=0;b<F;b++){const C=4*(b+Q*F);W[q]=Z[C],W[q+1]=Z[C+1],W[q+2]=Z[C+2],W[q+3]=(0,g.n)(t),q+=4}return W}return new Uint16Array(z,Q,C)}static _GetFloatRGBAArrayBuffer(F,b,Q,C,z,t){if(y.StoreLODInAlphaChannel){const g=new Float32Array(C),W=new Float32Array(z,Q);let Z=0;for(let Q=0;Q<b;Q++)for(let b=0;b<F;b++){const C=4*(b+Q*F);g[Z]=W[C],g[Z+1]=W[C+1],g[Z+2]=W[C+2],g[Z+3]=t,Z+=4}return g}return new Float32Array(z,Q,C)}static _GetFloatAsHalfFloatRGBAArrayBuffer(F,b,Q,C,z,t){const W=new Uint16Array(C),Z=new Float32Array(z,Q);let q=0;for(let G=0;G<b;G++)for(let b=0;b<F;b++)W[q]=(0,g.n)(Z[q]),W[q+1]=(0,g.n)(Z[q+1]),W[q+2]=(0,g.n)(Z[q+2]),y.StoreLODInAlphaChannel?W[q+3]=(0,g.n)(t):W[q+3]=(0,g.n)(Z[q+3]),q+=4;return W}static _GetFloatAsUIntRGBAArrayBuffer(F,b,Q,z,t,g){const W=new Uint8Array(z),Z=new Float32Array(t,Q);let q=0;for(let G=0;G<b;G++)for(let b=0;b<F;b++){const Q=4*(b+G*F);W[q]=255*(0,C.Clamp)(Z[Q]),W[q+1]=255*(0,C.Clamp)(Z[Q+1]),W[q+2]=255*(0,C.Clamp)(Z[Q+2]),y.StoreLODInAlphaChannel?W[q+3]=g:W[q+3]=255*(0,C.Clamp)(Z[Q+3]),q+=4}return W}static _GetHalfFloatAsUIntRGBAArrayBuffer(F,b,Q,z,t,W){const Z=new Uint8Array(z),q=new Uint16Array(t,Q);let G=0;for(let K=0;K<b;K++)for(let b=0;b<F;b++){const Q=4*(b+K*F);Z[G]=255*(0,C.Clamp)((0,g.e)(q[Q])),Z[G+1]=255*(0,C.Clamp)((0,g.e)(q[Q+1])),Z[G+2]=255*(0,C.Clamp)((0,g.e)(q[Q+2])),y.StoreLODInAlphaChannel?Z[G+3]=W:Z[G+3]=255*(0,C.Clamp)((0,g.e)(q[Q+3])),G+=4}return Z}static _GetRGBAArrayBuffer(F,b,Q,C,z,t,g,W,Z){const q=new Uint8Array(C),G=new Uint8Array(z,Q);let K=0;for(let e=0;e<b;e++)for(let b=0;b<F;b++){const Q=4*(b+e*F);q[K]=G[Q+t],q[K+1]=G[Q+g],q[K+2]=G[Q+W],q[K+3]=G[Q+Z],K+=4}return q}static _ExtractLongWordOrder(F){return 0===F||255===F||-16777216===F?0:1+y._ExtractLongWordOrder(F>>8)}static _GetRGBArrayBuffer(F,b,Q,C,z,t,g,W){const Z=new Uint8Array(C),q=new Uint8Array(z,Q);let G=0;for(let K=0;K<b;K++)for(let b=0;b<F;b++){const Q=3*(b+K*F);Z[G]=q[Q+t],Z[G+1]=q[Q+g],Z[G+2]=q[Q+W],G+=3}return Z}static _GetLuminanceArrayBuffer(F,b,Q,C,z){const t=new Uint8Array(C),g=new Uint8Array(z,Q);let W=0;for(let Z=0;Z<b;Z++)for(let b=0;b<F;b++){const Q=b+Z*F;t[W]=g[Q],W++}return t}static UploadDDSLevels(F,b,Q,C,g,Z){let q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,E=arguments.length>7?arguments[7]:void 0,c=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],X=null;C.sphericalPolynomial&&(X=[]);const L=!!F.getCaps().s3tc;b.generateMipMaps=g;const i=new Int32Array(Q.buffer,Q.byteOffset,31);let f,k,m,R,p,D,P,n=0,j=0,w=1;if(542327876!==i[0])return void z.e.Error("Invalid magic number in DDS header");if(!C.isFourCC&&!C.isRGB&&!C.isLuminance)return void z.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(C.isCompressed&&!L)return void z.e.Error("Compressed textures are not supported on this platform.");let Y=i[22];R=i[1]+4;let s=!1;if(C.isFourCC)switch(f=i[21],f){case G:w=8,j=33777;break;case K:w=16,j=33778;break;case e:w=16,j=33779;break;case 113:s=!0,Y=64;break;case 116:s=!0,Y=128;break;case N:{R+=20;let F=!1;switch(C.dxgiFormat){case 10:s=!0,Y=64,F=!0;break;case 2:s=!0,Y=128,F=!0;break;case 88:C.isRGB=!0,C.isFourCC=!1,Y=32,F=!0}if(F)break}default:return void z.e.Error(["Unsupported FourCC code:",(V=f,String.fromCharCode(255&V,V>>8&255,V>>16&255,V>>24&255))])}var V;const h=y._ExtractLongWordOrder(i[23]),l=y._ExtractLongWordOrder(i[24]),T=y._ExtractLongWordOrder(i[25]),o=y._ExtractLongWordOrder(i[26]);s&&(j=F._getRGBABufferInternalSizedFormat(C.textureType)),D=1,i[2]&W&&!1!==g&&(D=Math.max(1,i[7]));const S=E||0,O=F.getCaps();for(let z=S;z<Z;z++){for(k=i[4],m=i[3],P=0;P<D;++P){if(-1===q||q===P){const t=-1===q?P:0;if(!C.isCompressed&&C.isFourCC){b.format=5,n=k*m*4;let C=null;if(F._badOS||F._badDesktopOS||!O.textureHalfFloat&&!O.textureFloat)128===Y?(C=y._GetFloatAsUIntRGBAArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,t),X&&0==t&&X.push(y._GetFloatRGBAArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,t))):64===Y&&(C=y._GetHalfFloatAsUIntRGBAArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,t),X&&0==t&&X.push(y._GetHalfFloatAsFloatRGBAArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,t))),b.type=0;else{const F=O.textureFloat&&(c&&O.textureFloatLinearFiltering||!c),z=O.textureHalfFloat&&(c&&O.textureHalfFloatLinearFiltering||!c),g=(128===Y||64===Y&&!z)&&F?1:(64===Y||128===Y&&!F)&&z?2:0;let W,Z=null;if(128===Y)switch(g){case 1:W=y._GetFloatRGBAArrayBuffer,Z=null;break;case 2:W=y._GetFloatAsHalfFloatRGBAArrayBuffer,Z=y._GetFloatRGBAArrayBuffer;break;case 0:W=y._GetFloatAsUIntRGBAArrayBuffer,Z=y._GetFloatRGBAArrayBuffer}else switch(g){case 1:W=y._GetHalfFloatAsFloatRGBAArrayBuffer,Z=null;break;case 2:W=y._GetHalfFloatRGBAArrayBuffer,Z=y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:W=y._GetHalfFloatAsUIntRGBAArrayBuffer,Z=y._GetHalfFloatAsFloatRGBAArrayBuffer}b.type=g,C=W(k,m,Q.byteOffset+R,n,Q.buffer,t),X&&0==t&&X.push(Z?Z(k,m,Q.byteOffset+R,n,Q.buffer,t):C)}C&&F._uploadDataToTextureDirectly(b,C,z,t)}else if(C.isRGB)b.type=0,24===Y?(b.format=4,n=k*m*3,p=y._GetRGBArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,h,l,T),F._uploadDataToTextureDirectly(b,p,z,t)):(b.format=5,n=k*m*4,p=y._GetRGBAArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer,h,l,T,o),F._uploadDataToTextureDirectly(b,p,z,t));else if(C.isLuminance){const C=F._getUnpackAlignement(),g=k;n=Math.floor((k+C-1)/C)*C*(m-1)+g,p=y._GetLuminanceArrayBuffer(k,m,Q.byteOffset+R,n,Q.buffer),b.format=1,b.type=0,F._uploadDataToTextureDirectly(b,p,z,t)}else n=Math.max(4,k)/4*Math.max(4,m)/4*w,p=new Uint8Array(Q.buffer,Q.byteOffset+R,n),b.type=0,F._uploadCompressedDataToTextureDirectly(b,j,k,m,p,z,t)}R+=Y?k*m*(Y/8):n,k*=.5,m*=.5,k=Math.max(1,k),m=Math.max(1,m)}if(void 0!==E)break}X&&X.length>0?C.sphericalPolynomial=t.e.ConvertCubeMapToSphericalPolynomial({size:i[4],right:X[0],left:X[1],up:X[2],down:X[3],front:X[4],back:X[5],format:5,type:1,gammaSpace:!1}):C.sphericalPolynomial=void 0}}y.StoreLODInAlphaChannel=!1}}]);