"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{12888:(P,f,Y)=>{var C=Y(11119),q=Y(11025),m=Y(11059),L=Y(11139),o=Y(11089),w=Y(11129);o.c.prototype._partialLoadFile=function(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(P,(P=>{Y[f]=P,Y._internalCount++,6===Y._internalCount&&C(Y)}),void 0,void 0,!0,((P,f)=>{q&&P&&q(P.status+" "+P.statusText,f)}))},o.c.prototype._cascadeLoadFiles=function(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const q=[];q._internalCount=0;for(let m=0;m<6;m++)this._partialLoadFile(Y[m],m,q,f,C)},o.c.prototype._cascadeLoadImgs=function(P,f,Y,C){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,m=arguments.length>5?arguments[5]:void 0;const L=[];L._internalCount=0;for(let o=0;o<6;o++)this._partialLoadImg(C[o],o,L,P,f,Y,q,m)},o.c.prototype._partialLoadImg=function(P,f,Y,C,q,o){let w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,d=arguments.length>7?arguments[7]:void 0;const R=(0,L.b)();(0,m.q)(P,(P=>{Y[f]=P,Y._internalCount++,C&&C.removePendingData(R),6===Y._internalCount&&o&&o(q,Y)}),((P,f)=>{C&&C.removePendingData(R),w&&w(P,f)}),C?C.offlineProvider:null,d),C&&C.addPendingData(R)},o.c.prototype.createCubeTextureBase=function(P,f,Y,m){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,d=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,y=arguments.length>8&&void 0!==arguments[8]&&arguments[8],r=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,i=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,u=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,g=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,S=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,K=arguments.length>14&&void 0!==arguments[14]&&arguments[14],M=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const V=u||new C.b(this,7);V.isCube=!0,V.url=P,V.generateMipMaps=!m,V._lodGenerationScale=r,V._lodGenerationOffset=i,V._useSRGBBuffer=!!K&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!m),V!==u&&(V.label=P.substring(0,60)),this._doNotHandleContextLost||(V._extension=R,V._files=Y,V._buffer=M);const O=P;this._transformTextureUrl&&!u&&(P=this._transformTextureUrl(P));const n=R??function(P){const f=P.split("?")[0],Y=f.lastIndexOf(".");return Y>-1?f.substring(Y).toLowerCase():""}(P),l=(0,w.d)(n),v=(P,f)=>{V.dispose(),o?o(P,f):P&&q.e.Warn(P)},c=(C,o)=>{P===O?C&&v(C.status+" "+C.statusText,o):(q.e.Warn(`Failed to load ${P}, falling back to the ${O}`),this.createCubeTextureBase(O,f,Y,!!m,L,v,d,R,y,r,i,V,g,S,K,M))};if(l)l.then((C=>{const q=P=>{g&&g(V,P),C.loadCubeData(P,V,y,L,((P,f)=>{v(P,f)}))};M?q(M):Y&&6===Y.length?C.supportCascades?this._cascadeLoadFiles(f,(P=>q(P.map((P=>new Uint8Array(P))))),Y,v):v("Textures type does not support cascades."):this._loadFile(P,(P=>q(new Uint8Array(P))),void 0,void 0,!0,c)}));else{if(!Y||0===Y.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(f,V,((P,f)=>{S&&S(P,f)}),Y,v)}return this._internalTexturesCache.push(V),V}},11723:(P,f,Y)=>{Y.d(f,{b:()=>d});var C=Y(11179),q=Y(11198),m=Y(11377),L=Y(11187),o=Y(11228);class w{constructor(P,f,Y,C){this.name=P,this.worldAxisForNormal=f,this.worldAxisForFileX=Y,this.worldAxisForFileY=C}}class d{static ConvertCubeMapTextureToSphericalPolynomial(P){var f;if(!P.isCube)return null;null===(f=P.vP())||void 0===f||f.getEngine().flushFramebuffer();const Y=P.getSize().width,C=P.readPixels(0,void 0,void 0,!1),q=P.readPixels(1,void 0,void 0,!1);let m,L;P.isRenderTarget?(m=P.readPixels(3,void 0,void 0,!1),L=P.readPixels(2,void 0,void 0,!1)):(m=P.readPixels(2,void 0,void 0,!1),L=P.readPixels(3,void 0,void 0,!1));const o=P.readPixels(4,void 0,void 0,!1),w=P.readPixels(5,void 0,void 0,!1),d=P.gammaSpace;let R=0;return 1!=P.textureType&&2!=P.textureType||(R=1),new Promise((P=>{Promise.all([q,C,m,L,o,w]).then((f=>{let[C,q,m,L,o,w]=f;const y={size:Y,right:q,left:C,up:m,down:L,front:o,back:w,format:5,type:R,gammaSpace:d};P(this.ConvertCubeMapToSphericalPolynomial(y))}))}))}static _AreaElement(P,f){return Math.atan2(P*f,Math.sqrt(P*P+f*f+1))}static ConvertCubeMapToSphericalPolynomial(P){const f=new m.e;let Y=0;const C=2/P.size,w=C,d=.5*C,R=d-1;for(let m=0;m<6;m++){const y=this._FileFaces[m],r=P[y.name];let i=R;const u=5===P.format?4:3;for(let m=0;m<P.size;m++){let g=R;for(let w=0;w<P.size;w++){const R=y.worldAxisForFileX.scale(g).add(y.worldAxisForFileY.scale(i)).add(y.worldAxisForNormal);R.normalize();const S=this._AreaElement(g-d,i-d)-this._AreaElement(g-d,i+d)-this._AreaElement(g+d,i-d)+this._AreaElement(g+d,i+d);let K=r[m*P.size*u+w*u+0],M=r[m*P.size*u+w*u+1],V=r[m*P.size*u+w*u+2];isNaN(K)&&(K=0),isNaN(M)&&(M=0),isNaN(V)&&(V=0),0===P.type&&(K/=255,M/=255,V/=255),P.gammaSpace&&(K=Math.pow((0,q.Clamp)(K),L.k),M=Math.pow((0,q.Clamp)(M),L.k),V=Math.pow((0,q.Clamp)(V),L.k));const O=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const P=Math.max(K,M,V);if(P>O){const f=O/P;K*=f,M*=f,V*=f}}else K=(0,q.Clamp)(K,0,O),M=(0,q.Clamp)(M,0,O),V=(0,q.Clamp)(V,0,O);const n=new o.Df(K,M,V);f.addLight(R,n,S),Y+=S,g+=C}i+=w}}const y=6*(4*Math.PI)/6/Y;return f.scaleInPlace(y),f.convertIncidentRadianceToIrradiance(),f.convertIrradianceToLambertianRadiance(),m.f.FromHarmonics(f)}}d._FileFaces=[new w("right",new C.Of(1,0,0),new C.Of(0,0,-1),new C.Of(0,-1,0)),new w("left",new C.Of(-1,0,0),new C.Of(0,0,1),new C.Of(0,-1,0)),new w("up",new C.Of(0,1,0),new C.Of(1,0,0),new C.Of(0,0,1)),new w("down",new C.Of(0,-1,0),new C.Of(1,0,0),new C.Of(0,0,-1)),new w("front",new C.Of(0,0,1),new C.Of(1,0,0),new C.Of(0,-1,0)),new w("back",new C.Of(0,0,-1),new C.Of(-1,0,0),new C.Of(0,-1,0))],d.MAX_HDRI_VALUE=4096,d.PRESERVE_CLAMPED_COLORS=!1},13660:(P,f,Y)=>{Y.d(f,{DDSTools:()=>u});var C=Y(11198),q=Y(11025),m=Y(11723),L=Y(11421);Y(12888);const o=131072,w=131072;function d(P){return P.charCodeAt(0)+(P.charCodeAt(1)<<8)+(P.charCodeAt(2)<<16)+(P.charCodeAt(3)<<24)}const R=d("DXT1"),y=d("DXT3"),r=d("DXT5"),i=d("DX10");class u{static GetDDSInfo(P){const f=new Int32Array(P.buffer,P.byteOffset,31),Y=new Int32Array(P.buffer,P.byteOffset,35);let C=1;f[2]&o&&(C=Math.max(1,f[7]));const q=f[21],m=q===i?Y[32]:0;let L=0;switch(q){case 113:L=2;break;case 116:L=1;break;case i:if(10===m){L=2;break}if(2===m){L=1;break}}return{width:f[4],height:f[3],mipmapCount:C,isFourCC:4===(4&f[20]),isRGB:64===(64&f[20]),isLuminance:(f[20]&w)===w,isCube:512===(512&f[28]),isCompressed:q===R||q===y||q===r,dxgiFormat:m,textureType:L}}static _GetHalfFloatAsFloatRGBAArrayBuffer(P,f,Y,C,q,m){const o=new Float32Array(C),w=new Uint16Array(q,Y);let d=0;for(let R=0;R<f;R++)for(let f=0;f<P;f++){const Y=4*(f+R*P);o[d]=(0,L.c)(w[Y]),o[d+1]=(0,L.c)(w[Y+1]),o[d+2]=(0,L.c)(w[Y+2]),u.StoreLODInAlphaChannel?o[d+3]=m:o[d+3]=(0,L.c)(w[Y+3]),d+=4}return o}static _GetHalfFloatRGBAArrayBuffer(P,f,Y,C,q,m){if(u.StoreLODInAlphaChannel){const o=new Uint16Array(C),w=new Uint16Array(q,Y);let d=0;for(let Y=0;Y<f;Y++)for(let f=0;f<P;f++){const C=4*(f+Y*P);o[d]=w[C],o[d+1]=w[C+1],o[d+2]=w[C+2],o[d+3]=(0,L.k)(m),d+=4}return o}return new Uint16Array(q,Y,C)}static _GetFloatRGBAArrayBuffer(P,f,Y,C,q,m){if(u.StoreLODInAlphaChannel){const L=new Float32Array(C),o=new Float32Array(q,Y);let w=0;for(let Y=0;Y<f;Y++)for(let f=0;f<P;f++){const C=4*(f+Y*P);L[w]=o[C],L[w+1]=o[C+1],L[w+2]=o[C+2],L[w+3]=m,w+=4}return L}return new Float32Array(q,Y,C)}static _GetFloatAsHalfFloatRGBAArrayBuffer(P,f,Y,C,q,m){const o=new Uint16Array(C),w=new Float32Array(q,Y);let d=0;for(let R=0;R<f;R++)for(let f=0;f<P;f++)o[d]=(0,L.k)(w[d]),o[d+1]=(0,L.k)(w[d+1]),o[d+2]=(0,L.k)(w[d+2]),u.StoreLODInAlphaChannel?o[d+3]=(0,L.k)(m):o[d+3]=(0,L.k)(w[d+3]),d+=4;return o}static _GetFloatAsUIntRGBAArrayBuffer(P,f,Y,q,m,L){const o=new Uint8Array(q),w=new Float32Array(m,Y);let d=0;for(let R=0;R<f;R++)for(let f=0;f<P;f++){const Y=4*(f+R*P);o[d]=255*(0,C.Clamp)(w[Y]),o[d+1]=255*(0,C.Clamp)(w[Y+1]),o[d+2]=255*(0,C.Clamp)(w[Y+2]),u.StoreLODInAlphaChannel?o[d+3]=L:o[d+3]=255*(0,C.Clamp)(w[Y+3]),d+=4}return o}static _GetHalfFloatAsUIntRGBAArrayBuffer(P,f,Y,q,m,o){const w=new Uint8Array(q),d=new Uint16Array(m,Y);let R=0;for(let y=0;y<f;y++)for(let f=0;f<P;f++){const Y=4*(f+y*P);w[R]=255*(0,C.Clamp)((0,L.c)(d[Y])),w[R+1]=255*(0,C.Clamp)((0,L.c)(d[Y+1])),w[R+2]=255*(0,C.Clamp)((0,L.c)(d[Y+2])),u.StoreLODInAlphaChannel?w[R+3]=o:w[R+3]=255*(0,C.Clamp)((0,L.c)(d[Y+3])),R+=4}return w}static _GetRGBAArrayBuffer(P,f,Y,C,q,m,L,o,w){const d=new Uint8Array(C),R=new Uint8Array(q,Y);let y=0;for(let r=0;r<f;r++)for(let f=0;f<P;f++){const Y=4*(f+r*P);d[y]=R[Y+m],d[y+1]=R[Y+L],d[y+2]=R[Y+o],d[y+3]=R[Y+w],y+=4}return d}static _ExtractLongWordOrder(P){return 0===P||255===P||-16777216===P?0:1+u._ExtractLongWordOrder(P>>8)}static _GetRGBArrayBuffer(P,f,Y,C,q,m,L,o){const w=new Uint8Array(C),d=new Uint8Array(q,Y);let R=0;for(let y=0;y<f;y++)for(let f=0;f<P;f++){const Y=3*(f+y*P);w[R]=d[Y+m],w[R+1]=d[Y+L],w[R+2]=d[Y+o],R+=3}return w}static _GetLuminanceArrayBuffer(P,f,Y,C,q){const m=new Uint8Array(C),L=new Uint8Array(q,Y);let o=0;for(let w=0;w<f;w++)for(let f=0;f<P;f++){const Y=f+w*P;m[o]=L[Y],o++}return m}static UploadDDSLevels(P,f,Y,C,L,w){let d=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,g=arguments.length>7?arguments[7]:void 0,S=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],K=null;C.sphericalPolynomial&&(K=[]);const M=!!P.getCaps().s3tc;f.generateMipMaps=L;const V=new Int32Array(Y.buffer,Y.byteOffset,31);let O,n,l,v,c,T,U,D=0,j=0,e=1;if(542327876!==V[0])return void q.e.Error("Invalid magic number in DDS header");if(!C.isFourCC&&!C.isRGB&&!C.isLuminance)return void q.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(C.isCompressed&&!M)return void q.e.Error("Compressed textures are not supported on this platform.");let s=V[22];v=V[1]+4;let a=!1;if(C.isFourCC)switch(O=V[21],O){case R:e=8,j=33777;break;case y:e=16,j=33778;break;case r:e=16,j=33779;break;case 113:a=!0,s=64;break;case 116:a=!0,s=128;break;case i:{v+=20;let P=!1;switch(C.dxgiFormat){case 10:a=!0,s=64,P=!0;break;case 2:a=!0,s=128,P=!0;break;case 88:C.isRGB=!0,C.isFourCC=!1,s=32,P=!0}if(P)break}default:return void q.e.Error(["Unsupported FourCC code:",(Q=O,String.fromCharCode(255&Q,Q>>8&255,Q>>16&255,Q>>24&255))])}var Q;const J=u._ExtractLongWordOrder(V[23]),N=u._ExtractLongWordOrder(V[24]),I=u._ExtractLongWordOrder(V[25]),X=u._ExtractLongWordOrder(V[26]);a&&(j=P._getRGBABufferInternalSizedFormat(C.textureType)),T=1,V[2]&o&&!1!==L&&(T=Math.max(1,V[7]));const x=g||0,k=P.getCaps();for(let q=x;q<w;q++){for(n=V[4],l=V[3],U=0;U<T;++U){if(-1===d||d===U){const m=-1===d?U:0;if(!C.isCompressed&&C.isFourCC){f.format=5,D=n*l*4;let C=null;if(P._badOS||P._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)128===s?(C=u._GetFloatAsUIntRGBAArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,m),K&&0==m&&K.push(u._GetFloatRGBAArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,m))):64===s&&(C=u._GetHalfFloatAsUIntRGBAArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,m),K&&0==m&&K.push(u._GetHalfFloatAsFloatRGBAArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,m))),f.type=0;else{const P=k.textureFloat&&(S&&k.textureFloatLinearFiltering||!S),q=k.textureHalfFloat&&(S&&k.textureHalfFloatLinearFiltering||!S),L=(128===s||64===s&&!q)&&P?1:(64===s||128===s&&!P)&&q?2:0;let o,w=null;if(128===s)switch(L){case 1:o=u._GetFloatRGBAArrayBuffer,w=null;break;case 2:o=u._GetFloatAsHalfFloatRGBAArrayBuffer,w=u._GetFloatRGBAArrayBuffer;break;case 0:o=u._GetFloatAsUIntRGBAArrayBuffer,w=u._GetFloatRGBAArrayBuffer}else switch(L){case 1:o=u._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:o=u._GetHalfFloatRGBAArrayBuffer,w=u._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:o=u._GetHalfFloatAsUIntRGBAArrayBuffer,w=u._GetHalfFloatAsFloatRGBAArrayBuffer}f.type=L,C=o(n,l,Y.byteOffset+v,D,Y.buffer,m),K&&0==m&&K.push(w?w(n,l,Y.byteOffset+v,D,Y.buffer,m):C)}C&&P._uploadDataToTextureDirectly(f,C,q,m)}else if(C.isRGB)f.type=0,24===s?(f.format=4,D=n*l*3,c=u._GetRGBArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,J,N,I),P._uploadDataToTextureDirectly(f,c,q,m)):(f.format=5,D=n*l*4,c=u._GetRGBAArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer,J,N,I,X),P._uploadDataToTextureDirectly(f,c,q,m));else if(C.isLuminance){const C=P._getUnpackAlignement(),L=n;D=Math.floor((n+C-1)/C)*C*(l-1)+L,c=u._GetLuminanceArrayBuffer(n,l,Y.byteOffset+v,D,Y.buffer),f.format=1,f.type=0,P._uploadDataToTextureDirectly(f,c,q,m)}else D=Math.max(4,n)/4*Math.max(4,l)/4*e,c=new Uint8Array(Y.buffer,Y.byteOffset+v,D),f.type=0,P._uploadCompressedDataToTextureDirectly(f,j,n,l,c,q,m)}v+=s?n*l*(s/8):D,n*=.5,l*=.5,n=Math.max(1,n),l=Math.max(1,l)}if(void 0!==g)break}K&&K.length>0?C.sphericalPolynomial=m.b.ConvertCubeMapToSphericalPolynomial({size:V[4],right:K[0],left:K[1],up:K[2],down:K[3],front:K[4],back:K[5],format:5,type:1,gammaSpace:!1}):C.sphericalPolynomial=void 0}}u.StoreLODInAlphaChannel=!1}}]);