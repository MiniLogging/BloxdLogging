"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13580:(Z,c,L)=>{L.r(c),L.d(c,{_BasisTextureLoader:()=>w});var k,N=L(11038),R=L(11508),G=L(11139);function V(){const Z=0,c=1,L=2,k=3,N=6,R=8,G=9,V=10,p=14;let J=null;function z(Z,c,L,k,N){const R=Z.getImageTranscodedSizeInBytes(c,L,k);let G=new Uint8Array(R);if(!Z.transcodeImage(G,c,L,k,1,0))return null;if(N){G=function(Z,c,L,k){const N=new Uint16Array(4),R=new Uint16Array(L*k),G=L/4,V=k/4;for(let p=0;p<V;p++)for(let k=0;k<G;k++){const V=c+8*(p*G+k);N[0]=Z[V]|Z[V+1]<<8,N[1]=Z[V+2]|Z[V+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let c=0;c<4;c++){const G=Z[V+4+c];let J=(4*p+c)*L+4*k;R[J++]=N[3&G],R[J++]=N[G>>2&3],R[J++]=N[G>>4&3],R[J++]=N[G>>6&3]}}return R}(G,0,Z.getImageWidth(c,L)+3&-4,Z.getImageHeight(c,L)+3&-4)}return G}onmessage=i=>{if("init"===i.data.action){if(i.data.url)try{importScripts(i.data.url)}catch(t){postMessage({action:"error",error:t})}J||(J=BASIS({wasmBinary:i.data.wasmBinary})),null!==J&&J.then((Z=>{BASIS=Z,Z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===i.data.action){const J=i.data.config,t=i.data.imageData,E=new BASIS.BasisFile(t),x=function(Z){const c=Z.getHasAlpha(),L=Z.getNumImages(),k=[];for(let N=0;N<L;N++){const c={levels:[]},L=Z.getNumLevels(N);for(let k=0;k<L;k++){const L={width:Z.getImageWidth(N,k),height:Z.getImageHeight(N,k)};c.levels.push(L)}k.push(c)}return{Oc:c,images:k}}(E);let q=i.data.ignoreSupportedFormats?null:function(J,z){let i=null;J.supportedCompressionFormats&&(i=J.supportedCompressionFormats.astc?V:J.supportedCompressionFormats.bc7?N:J.supportedCompressionFormats.s3tc?z.Oc?k:L:J.supportedCompressionFormats.pvrtc?z.Oc?G:R:J.supportedCompressionFormats.etc2?c:J.supportedCompressionFormats.etc1?Z:p);return i}(i.data.config,x),O=!1;null===q&&(O=!0,q=x.Oc?k:L);let w=!0;E.startTranscoding()||(w=!1);const M=[];for(let Z=0;Z<x.images.length&&w;Z++){const c=x.images[Z];if(void 0===J.loadSingleImage||J.loadSingleImage===Z){let L=c.levels.length;!1===J.loadMipmapLevels&&(L=1);for(let k=0;k<L;k++){const L=c.levels[k],N=z(E,Z,k,q,O);if(!N){w=!1;break}L.transcodedPixels=N,M.push(L.transcodedPixels.buffer)}}}E.close(),E.delete(),O&&(q=-1),w?postMessage({action:"transcode",success:w,id:i.data.id,fileInfo:x,format:q},M):postMessage({action:"transcode",success:w,id:i.data.id})}}}!function(Z){Z[Z.cTFETC1=0]="cTFETC1",Z[Z.cTFETC2=1]="cTFETC2",Z[Z.cTFBC1=2]="cTFBC1",Z[Z.cTFBC3=3]="cTFBC3",Z[Z.cTFBC4=4]="cTFBC4",Z[Z.cTFBC5=5]="cTFBC5",Z[Z.cTFBC7=6]="cTFBC7",Z[Z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Z[Z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Z[Z.cTFASTC_4x4=10]="cTFASTC_4x4",Z[Z.cTFATC_RGB=11]="cTFATC_RGB",Z[Z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Z[Z.cTFRGBA32=13]="cTFRGBA32",Z[Z.cTFRGB565=14]="cTFRGB565",Z[Z.cTFBGR565=15]="cTFBGR565",Z[Z.cTFRGBA4444=16]="cTFRGBA4444",Z[Z.cTFFXT1_RGB=17]="cTFFXT1_RGB",Z[Z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Z[Z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Z[Z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Z[Z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(k||(k={}));const p={JSModuleURL:`${N.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,z=null,i=0;const t=async()=>(J||(J=new Promise(((Z,c)=>{z?Z(z):N.c.LoadFileAsync(N.c.GetBabylonScriptURL(p.WasmModuleURL)).then((L=>{if("function"!==typeof URL)return c("Basis transcoder requires an environment with a URL constructor");const k=URL.createObjectURL(new Blob([`(${V})()`],{type:"application/javascript"}));z=new Worker(k),async function(Z,c,L){return await new Promise(((k,R)=>{const G=c=>{"init"===c.data.action?(Z.removeEventListener("message",G),k(Z)):"error"===c.data.action&&R(c.data.error||"error initializing worker")};Z.addEventListener("message",G),Z.postMessage({action:"init",url:L?N.c.GetBabylonScriptURL(L):void 0,wasmBinary:c},[c])}))}(z,L,p.JSModuleURL).then(Z,c)})).catch(c)}))),await J),E=async(Z,c)=>{const L=Z instanceof ArrayBuffer?new Uint8Array(Z):Z;return await new Promise(((Z,k)=>{t().then((()=>{const N=i++,R=c=>{"transcode"===c.data.action&&c.data.id===N&&(z.removeEventListener("message",R),c.data.success?Z(c.data):k("Transcode is not supported on this device"))};z.addEventListener("message",R);const G=new Uint8Array(L.byteLength);G.set(new Uint8Array(L.buffer,L.byteOffset,L.byteLength)),z.postMessage({action:"transcode",id:N,imageData:G,config:c,ignoreSupportedFormats:false},[G.buffer])}),(Z=>{k(Z)}))}))},x=(Z,c)=>{var L;let k=null===(L=c._gl)||void 0===L?void 0:L.TEXTURE_2D;var N;Z.isCube&&(k=null===(N=c._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);c._bindTextureDirectly(k,Z,!0)},q=(Z,c)=>{const L=Z.getEngine();for(let V=0;V<c.fileInfo.images.length;V++){const p=c.fileInfo.images[V].levels[0];if(Z._invertVScale=Z.invertY,-1===c.format||c.format===k.cTFRGB565)if(Z.type=10,Z.format=4,!L._features.basisNeedsPOT||Math.log2(p.width)%1===0&&Math.log2(p.height)%1===0)Z._invertVScale=!Z.invertY,Z.width=p.width+3&-4,Z.height=p.height+3&-4,Z.samplingMode=2,x(Z,L),L._uploadDataToTextureDirectly(Z,new Uint16Array(p.transcodedPixels.buffer),V,0,4,!0);else{const c=new G.e(L,2);Z._invertVScale=Z.invertY,c.type=10,c.format=4,c.width=p.width+3&-4,c.height=p.height+3&-4,x(c,L),L._uploadDataToTextureDirectly(c,new Uint16Array(p.transcodedPixels.buffer),V,0,4,!0),L._rescaleTexture(c,Z,L.scenes[0],L._getInternalFormat(4),(()=>{L._releaseTexture(c),x(Z,L)}))}else{Z.width=p.width,Z.height=p.height,Z.generateMipMaps=c.fileInfo.images[V].levels.length>1;const k=O.GetInternalFormatFromBasisFormat(c.format,L);Z.format=k,x(Z,L);const G=c.fileInfo.images[V].levels;for(let c=0;c<G.length;c++){const N=G[c];L._uploadCompressedDataToTextureDirectly(Z,k,N.width,N.height,N.transcodedPixels,V,c)}!L._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0||(N.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Z._cachedWrapU=R.c.CLAMP_ADDRESSMODE,Z._cachedWrapV=R.c.CLAMP_ADDRESSMODE)}}},O={JSModuleURL:p.JSModuleURL,WasmModuleURL:p.WasmModuleURL,GetInternalFormatFromBasisFormat:(Z,c)=>{let L;switch(Z){case k.cTFETC1:L=36196;break;case k.cTFBC1:L=33776;break;case k.cTFBC4:L=33779;break;case k.cTFASTC_4x4:L=37808;break;case k.cTFETC2:L=37496;break;case k.cTFBC7:L=36492}if(void 0===L)throw"The chosen Basis transcoder format is not currently supported";return L},TranscodeAsync:E,LoadTextureFromTranscodeResult:q};Object.defineProperty(O,"JSModuleURL",{get:function(){return p.JSModuleURL},set:function(Z){p.JSModuleURL=Z}}),Object.defineProperty(O,"WasmModuleURL",{get:function(){return p.WasmModuleURL},set:function(Z){p.WasmModuleURL=Z}});class w{constructor(){this.supportCascades=!1}loadCubeData(Z,c,L,k,R){if(Array.isArray(Z))return;const G=c.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!G.etc1,s3tc:!!G.s3tc,pvrtc:!!G.pvrtc,etc2:!!G.etc2,astc:!!G.astc,bc7:!!G.bptc}};E(Z,V).then((Z=>{const L=Z.fileInfo.images[0].levels.length>1&&c.generateMipMaps;q(c,Z),c.getEngine()._setCubeMapTextureParams(c,L),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),k&&k()})).catch((Z=>{N.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.isReady=!0,R&&R(Z)}))}loadData(Z,c,L){const k=c.getEngine().getCaps(),R={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};E(Z,R).then((Z=>{const k=Z.fileInfo.images[0].levels[0],N=Z.fileInfo.images[0].levels.length>1&&c.generateMipMaps;L(k.width,k.height,N,-1!==Z.format,(()=>{q(c,Z)}))})).catch((Z=>{N.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.c.Warn(`Failed to transcode Basis file: ${Z}`),L(0,0,!1,!1,(()=>{}),!0)}))}}}}]);