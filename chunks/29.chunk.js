"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[29],{13392:(D,l,G)=>{var V=G(11644),N=G(11546),M=G(11573),b=G(11672),X=G(11613),t=G(11657);X.e.prototype._partialLoadFile=function(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(D,(D=>{G[l]=D,G._internalCount++,6===G._internalCount&&V(G)}),void 0,void 0,!0,((D,l)=>{N&&D&&N(D.status+" "+D.statusText,l)}))},X.e.prototype._cascadeLoadFiles=function(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const N=[];N._internalCount=0;for(let M=0;M<6;M++)this._partialLoadFile(G[M],M,N,l,V)},X.e.prototype._cascadeLoadImgs=function(D,l,G,V){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,M=arguments.length>5?arguments[5]:void 0;const b=[];b._internalCount=0;for(let X=0;X<6;X++)this._partialLoadImg(V[X],X,b,D,l,G,N,M)},X.e.prototype._partialLoadImg=function(D,l,G,V,N,X){let t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,R=arguments.length>7?arguments[7]:void 0;const n=(0,b.c)();(0,M.p)(D,(D=>{G[l]=D,G._internalCount++,V&&V.removePendingData(n),6===G._internalCount&&X&&X(N,G)}),((D,l)=>{V&&V.removePendingData(n),t&&t(D,l)}),V?V.offlineProvider:null,R),V&&V.addPendingData(n)},X.e.prototype.createCubeTextureBase=function(D,l,G,M){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,R=arguments.length>6?arguments[6]:void 0,n=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8],j=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,e=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,K=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,F=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,d=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,H=arguments.length>14&&void 0!==arguments[14]&&arguments[14],h=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const x=K||new V.b(this,7);x.isCube=!0,x.url=D,x.generateMipMaps=!M,x._lodGenerationScale=j,x._lodGenerationOffset=e,x._useSRGBBuffer=!!H&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!M),x!==K&&(x.label=D.substring(0,60)),this._doNotHandleContextLost||(x._extension=n,x._files=G,x._buffer=h);const r=D;this._transformTextureUrl&&!K&&(D=this._transformTextureUrl(D));const o=n??function(D){const l=D.split("?")[0],G=l.lastIndexOf(".");return G>-1?l.substring(G).toLowerCase():""}(D),L=(0,t.c)(o),u=(D,l)=>{x.dispose(),X?X(D,l):D&&N.d.Warn(D)},B=(V,X)=>{D===r?V&&u(V.status+" "+V.statusText,X):(N.d.Warn(`Failed to load ${D}, falling back to the ${r}`),this.createCubeTextureBase(r,l,G,!!M,b,u,R,n,g,j,e,x,F,d,H,h))};if(L)L.then((V=>{const N=D=>{F&&F(x,D),V.loadCubeData(D,x,g,b,((D,l)=>{u(D,l)}))};h?N(h):G&&6===G.length?V.supportCascades?this._cascadeLoadFiles(l,(D=>N(D.map((D=>new Uint8Array(D))))),G,u):u("Textures type does not support cascades."):this._loadFile(D,(D=>N(new Uint8Array(D))),void 0,void 0,!0,B)}));else{if(!G||0===G.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(l,x,((D,l)=>{d&&d(D,l)}),G,u)}return this._internalTexturesCache.push(x),x}},12238:(D,l,G)=>{G.d(l,{e:()=>R});var V=G(11710),N=G(11728),M=G(11904),b=G(11713),X=G(11755);class t{constructor(D,l,G,V){this.name=D,this.worldAxisForNormal=l,this.worldAxisForFileX=G,this.worldAxisForFileY=V}}class R{static ConvertCubeMapTextureToSphericalPolynomial(D){var l;if(!D.isCube)return null;null===(l=D.uD())||void 0===l||l.getEngine().flushFramebuffer();const G=D.getSize().width,V=D.readPixels(0,void 0,void 0,!1),N=D.readPixels(1,void 0,void 0,!1);let M,b;D.isRenderTarget?(M=D.readPixels(3,void 0,void 0,!1),b=D.readPixels(2,void 0,void 0,!1)):(M=D.readPixels(2,void 0,void 0,!1),b=D.readPixels(3,void 0,void 0,!1));const X=D.readPixels(4,void 0,void 0,!1),t=D.readPixels(5,void 0,void 0,!1),R=D.gammaSpace;let n=0;return 1!=D.textureType&&2!=D.textureType||(n=1),new Promise((D=>{Promise.all([N,V,M,b,X,t]).then((l=>{let[V,N,M,b,X,t]=l;const g={size:G,right:N,left:V,up:M,down:b,front:X,back:t,format:5,type:n,gammaSpace:R};D(this.ConvertCubeMapToSphericalPolynomial(g))}))}))}static _AreaElement(D,l){return Math.atan2(D*l,Math.sqrt(D*D+l*l+1))}static ConvertCubeMapToSphericalPolynomial(D){const l=new M.e;let G=0;const V=2/D.size,t=V,R=.5*V,n=R-1;for(let M=0;M<6;M++){const g=this._FileFaces[M],j=D[g.name];let e=n;const K=5===D.format?4:3;for(let M=0;M<D.size;M++){let F=n;for(let t=0;t<D.size;t++){const n=g.worldAxisForFileX.scale(F).add(g.worldAxisForFileY.scale(e)).add(g.worldAxisForNormal);n.normalize();const d=this._AreaElement(F-R,e-R)-this._AreaElement(F-R,e+R)-this._AreaElement(F+R,e-R)+this._AreaElement(F+R,e+R);let H=j[M*D.size*K+t*K+0],h=j[M*D.size*K+t*K+1],x=j[M*D.size*K+t*K+2];isNaN(H)&&(H=0),isNaN(h)&&(h=0),isNaN(x)&&(x=0),0===D.type&&(H/=255,h/=255,x/=255),D.gammaSpace&&(H=Math.pow((0,N.Clamp)(H),b.k),h=Math.pow((0,N.Clamp)(h),b.k),x=Math.pow((0,N.Clamp)(x),b.k));const r=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const D=Math.max(H,h,x);if(D>r){const l=r/D;H*=l,h*=l,x*=l}}else H=(0,N.Clamp)(H,0,r),h=(0,N.Clamp)(h,0,r),x=(0,N.Clamp)(x,0,r);const o=new X.hl(H,h,x);l.addLight(n,o,d),G+=d,F+=V}e+=t}}const g=6*(4*Math.PI)/6/G;return l.scaleInPlace(g),l.convertIncidentRadianceToIrradiance(),l.convertIrradianceToLambertianRadiance(),M.h.FromHarmonics(l)}}R._FileFaces=[new t("right",new V.Kl(1,0,0),new V.Kl(0,0,-1),new V.Kl(0,-1,0)),new t("left",new V.Kl(-1,0,0),new V.Kl(0,0,1),new V.Kl(0,-1,0)),new t("up",new V.Kl(0,1,0),new V.Kl(1,0,0),new V.Kl(0,0,1)),new t("down",new V.Kl(0,-1,0),new V.Kl(1,0,0),new V.Kl(0,0,-1)),new t("front",new V.Kl(0,0,1),new V.Kl(1,0,0),new V.Kl(0,-1,0)),new t("back",new V.Kl(0,0,-1),new V.Kl(-1,0,0),new V.Kl(0,-1,0))],R.MAX_HDRI_VALUE=4096,R.PRESERVE_CLAMPED_COLORS=!1},14124:(D,l,G)=>{G.d(l,{DDSTools:()=>K});var V=G(11728),N=G(11546),M=G(12238),b=G(11948);G(13392);const X=131072,t=131072;function R(D){return D.charCodeAt(0)+(D.charCodeAt(1)<<8)+(D.charCodeAt(2)<<16)+(D.charCodeAt(3)<<24)}const n=R("DXT1"),g=R("DXT3"),j=R("DXT5"),e=R("DX10");class K{static GetDDSInfo(D){const l=new Int32Array(D.buffer,D.byteOffset,31),G=new Int32Array(D.buffer,D.byteOffset,35);let V=1;l[2]&X&&(V=Math.max(1,l[7]));const N=l[21],M=N===e?G[32]:0;let b=0;switch(N){case 113:b=2;break;case 116:b=1;break;case e:if(10===M){b=2;break}if(2===M){b=1;break}}return{width:l[4],height:l[3],mipmapCount:V,isFourCC:4===(4&l[20]),isRGB:64===(64&l[20]),isLuminance:(l[20]&t)===t,isCube:512===(512&l[28]),isCompressed:N===n||N===g||N===j,dxgiFormat:M,textureType:b}}static _GetHalfFloatAsFloatRGBAArrayBuffer(D,l,G,V,N,M){const X=new Float32Array(V),t=new Uint16Array(N,G);let R=0;for(let n=0;n<l;n++)for(let l=0;l<D;l++){const G=4*(l+n*D);X[R]=(0,b.f)(t[G]),X[R+1]=(0,b.f)(t[G+1]),X[R+2]=(0,b.f)(t[G+2]),K.StoreLODInAlphaChannel?X[R+3]=M:X[R+3]=(0,b.f)(t[G+3]),R+=4}return X}static _GetHalfFloatRGBAArrayBuffer(D,l,G,V,N,M){if(K.StoreLODInAlphaChannel){const X=new Uint16Array(V),t=new Uint16Array(N,G);let R=0;for(let G=0;G<l;G++)for(let l=0;l<D;l++){const V=4*(l+G*D);X[R]=t[V],X[R+1]=t[V+1],X[R+2]=t[V+2],X[R+3]=(0,b.k)(M),R+=4}return X}return new Uint16Array(N,G,V)}static _GetFloatRGBAArrayBuffer(D,l,G,V,N,M){if(K.StoreLODInAlphaChannel){const b=new Float32Array(V),X=new Float32Array(N,G);let t=0;for(let G=0;G<l;G++)for(let l=0;l<D;l++){const V=4*(l+G*D);b[t]=X[V],b[t+1]=X[V+1],b[t+2]=X[V+2],b[t+3]=M,t+=4}return b}return new Float32Array(N,G,V)}static _GetFloatAsHalfFloatRGBAArrayBuffer(D,l,G,V,N,M){const X=new Uint16Array(V),t=new Float32Array(N,G);let R=0;for(let n=0;n<l;n++)for(let l=0;l<D;l++)X[R]=(0,b.k)(t[R]),X[R+1]=(0,b.k)(t[R+1]),X[R+2]=(0,b.k)(t[R+2]),K.StoreLODInAlphaChannel?X[R+3]=(0,b.k)(M):X[R+3]=(0,b.k)(t[R+3]),R+=4;return X}static _GetFloatAsUIntRGBAArrayBuffer(D,l,G,N,M,b){const X=new Uint8Array(N),t=new Float32Array(M,G);let R=0;for(let n=0;n<l;n++)for(let l=0;l<D;l++){const G=4*(l+n*D);X[R]=255*(0,V.Clamp)(t[G]),X[R+1]=255*(0,V.Clamp)(t[G+1]),X[R+2]=255*(0,V.Clamp)(t[G+2]),K.StoreLODInAlphaChannel?X[R+3]=b:X[R+3]=255*(0,V.Clamp)(t[G+3]),R+=4}return X}static _GetHalfFloatAsUIntRGBAArrayBuffer(D,l,G,N,M,X){const t=new Uint8Array(N),R=new Uint16Array(M,G);let n=0;for(let g=0;g<l;g++)for(let l=0;l<D;l++){const G=4*(l+g*D);t[n]=255*(0,V.Clamp)((0,b.f)(R[G])),t[n+1]=255*(0,V.Clamp)((0,b.f)(R[G+1])),t[n+2]=255*(0,V.Clamp)((0,b.f)(R[G+2])),K.StoreLODInAlphaChannel?t[n+3]=X:t[n+3]=255*(0,V.Clamp)((0,b.f)(R[G+3])),n+=4}return t}static _GetRGBAArrayBuffer(D,l,G,V,N,M,b,X,t){const R=new Uint8Array(V),n=new Uint8Array(N,G);let g=0;for(let j=0;j<l;j++)for(let l=0;l<D;l++){const G=4*(l+j*D);R[g]=n[G+M],R[g+1]=n[G+b],R[g+2]=n[G+X],R[g+3]=n[G+t],g+=4}return R}static _ExtractLongWordOrder(D){return 0===D||255===D||-16777216===D?0:1+K._ExtractLongWordOrder(D>>8)}static _GetRGBArrayBuffer(D,l,G,V,N,M,b,X){const t=new Uint8Array(V),R=new Uint8Array(N,G);let n=0;for(let g=0;g<l;g++)for(let l=0;l<D;l++){const G=3*(l+g*D);t[n]=R[G+M],t[n+1]=R[G+b],t[n+2]=R[G+X],n+=3}return t}static _GetLuminanceArrayBuffer(D,l,G,V,N){const M=new Uint8Array(V),b=new Uint8Array(N,G);let X=0;for(let t=0;t<l;t++)for(let l=0;l<D;l++){const G=l+t*D;M[X]=b[G],X++}return M}static UploadDDSLevels(D,l,G,V,b,t){let R=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,F=arguments.length>7?arguments[7]:void 0,d=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],H=null;V.sphericalPolynomial&&(H=[]);const h=!!D.getCaps().s3tc;l.generateMipMaps=b;const x=new Int32Array(G.buffer,G.byteOffset,31);let r,o,L,u,B,I,W,i=0,y=0,S=1;if(542327876!==x[0])return void N.d.Error("Invalid magic number in DDS header");if(!V.isFourCC&&!V.isRGB&&!V.isLuminance)return void N.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(V.isCompressed&&!h)return void N.d.Error("Compressed textures are not supported on this platform.");let O=x[22];u=x[1]+4;let s=!1;if(V.isFourCC)switch(r=x[21],r){case n:S=8,y=33777;break;case g:S=16,y=33778;break;case j:S=16,y=33779;break;case 113:s=!0,O=64;break;case 116:s=!0,O=128;break;case e:{u+=20;let D=!1;switch(V.dxgiFormat){case 10:s=!0,O=64,D=!0;break;case 2:s=!0,O=128,D=!0;break;case 88:V.isRGB=!0,V.isFourCC=!1,O=32,D=!0}if(D)break}default:return void N.d.Error(["Unsupported FourCC code:",(U=r,String.fromCharCode(255&U,U>>8&255,U>>16&255,U>>24&255))])}var U;const f=K._ExtractLongWordOrder(x[23]),q=K._ExtractLongWordOrder(x[24]),c=K._ExtractLongWordOrder(x[25]),v=K._ExtractLongWordOrder(x[26]);s&&(y=D._getRGBABufferInternalSizedFormat(V.textureType)),I=1,x[2]&X&&!1!==b&&(I=Math.max(1,x[7]));const Z=F||0,J=D.getCaps();for(let N=Z;N<t;N++){for(o=x[4],L=x[3],W=0;W<I;++W){if(-1===R||R===W){const M=-1===R?W:0;if(!V.isCompressed&&V.isFourCC){l.format=5,i=o*L*4;let V=null;if(D._badOS||D._badDesktopOS||!J.textureHalfFloat&&!J.textureFloat)128===O?(V=K._GetFloatAsUIntRGBAArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,M),H&&0==M&&H.push(K._GetFloatRGBAArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,M))):64===O&&(V=K._GetHalfFloatAsUIntRGBAArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,M),H&&0==M&&H.push(K._GetHalfFloatAsFloatRGBAArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,M))),l.type=0;else{const D=J.textureFloat&&(d&&J.textureFloatLinearFiltering||!d),N=J.textureHalfFloat&&(d&&J.textureHalfFloatLinearFiltering||!d),b=(128===O||64===O&&!N)&&D?1:(64===O||128===O&&!D)&&N?2:0;let X,t=null;if(128===O)switch(b){case 1:X=K._GetFloatRGBAArrayBuffer,t=null;break;case 2:X=K._GetFloatAsHalfFloatRGBAArrayBuffer,t=K._GetFloatRGBAArrayBuffer;break;case 0:X=K._GetFloatAsUIntRGBAArrayBuffer,t=K._GetFloatRGBAArrayBuffer}else switch(b){case 1:X=K._GetHalfFloatAsFloatRGBAArrayBuffer,t=null;break;case 2:X=K._GetHalfFloatRGBAArrayBuffer,t=K._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:X=K._GetHalfFloatAsUIntRGBAArrayBuffer,t=K._GetHalfFloatAsFloatRGBAArrayBuffer}l.type=b,V=X(o,L,G.byteOffset+u,i,G.buffer,M),H&&0==M&&H.push(t?t(o,L,G.byteOffset+u,i,G.buffer,M):V)}V&&D._uploadDataToTextureDirectly(l,V,N,M)}else if(V.isRGB)l.type=0,24===O?(l.format=4,i=o*L*3,B=K._GetRGBArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,f,q,c),D._uploadDataToTextureDirectly(l,B,N,M)):(l.format=5,i=o*L*4,B=K._GetRGBAArrayBuffer(o,L,G.byteOffset+u,i,G.buffer,f,q,c,v),D._uploadDataToTextureDirectly(l,B,N,M));else if(V.isLuminance){const V=D._getUnpackAlignement(),b=o;i=Math.floor((o+V-1)/V)*V*(L-1)+b,B=K._GetLuminanceArrayBuffer(o,L,G.byteOffset+u,i,G.buffer),l.format=1,l.type=0,D._uploadDataToTextureDirectly(l,B,N,M)}else i=Math.max(4,o)/4*Math.max(4,L)/4*S,B=new Uint8Array(G.buffer,G.byteOffset+u,i),l.type=0,D._uploadCompressedDataToTextureDirectly(l,y,o,L,B,N,M)}u+=O?o*L*(O/8):i,o*=.5,L*=.5,o=Math.max(1,o),L=Math.max(1,L)}if(void 0!==F)break}H&&H.length>0?V.sphericalPolynomial=M.e.ConvertCubeMapToSphericalPolynomial({size:x[4],right:H[0],left:H[1],up:H[2],down:H[3],front:H[4],back:H[5],format:5,type:1,gammaSpace:!1}):V.sphericalPolynomial=void 0}}K.StoreLODInAlphaChannel=!1}}]);