"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[29],{14082:(V,h,mV)=>{var t=mV(12359),L=mV(12264),N=mV(12303),A=mV(12393),k=mV(12331),C=mV(12371);k.b.prototype._partialLoadFile=function(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(V,(V=>{mV[h]=V,mV._internalCount++,6===mV._internalCount&&t(mV)}),void 0,void 0,!0,((V,h)=>{L&&V&&L(V.status+" "+V.statusText,h)}))},k.b.prototype._cascadeLoadFiles=function(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const L=[];L._internalCount=0;for(let N=0;N<6;N++)this._partialLoadFile(mV[N],N,L,h,t)},k.b.prototype._cascadeLoadImgs=function(V,h,mV,t){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,N=arguments.length>5?arguments[5]:void 0;const A=[];A._internalCount=0;for(let k=0;k<6;k++)this._partialLoadImg(t[k],k,A,V,h,mV,L,N)},k.b.prototype._partialLoadImg=function(V,h,mV,t,L,k){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,K=arguments.length>7?arguments[7]:void 0;const o=(0,A.b)();(0,N.x)(V,(V=>{mV[h]=V,mV._internalCount++,t&&t.removePendingData(o),6===mV._internalCount&&k&&k(L,mV)}),((V,h)=>{t&&t.removePendingData(o),C&&C(V,h)}),t?t.offlineProvider:null,K),t&&t.addPendingData(o)},k.b.prototype.createCubeTextureBase=function(V,h,mV,N){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,K=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,n=arguments.length>8&&void 0!==arguments[8]&&arguments[8],q=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,R=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,d=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,s=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,M=arguments.length>14&&void 0!==arguments[14]&&arguments[14],c=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const z=R||new t.d(this,7);z.isCube=!0,z.url=V,z.generateMipMaps=!N,z._lodGenerationScale=q,z._lodGenerationOffset=x,z._useSRGBBuffer=!!M&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!N),z!==R&&(z.label=V.substring(0,60)),this._doNotHandleContextLost||(z._extension=o,z._files=mV,z._buffer=c);const Q=V;this._transformTextureUrl&&!R&&(V=this._transformTextureUrl(V));const J=o??function(V){const h=V.split("?")[0],mV=h.lastIndexOf(".");return mV>-1?h.substring(mV).toLowerCase():""}(V),v=(0,C.b)(J),D=(V,h)=>{z.dispose(),k?k(V,h):V&&L.e.Warn(V)},H=(t,k)=>{V===Q?t&&D(t.status+" "+t.statusText,k):(L.e.Warn(`Failed to load ${V}, falling back to the ${Q}`),this.createCubeTextureBase(Q,h,mV,!!N,A,D,K,o,n,q,x,z,d,s,M,c))};if(v)v.then((t=>{const L=V=>{d&&d(z,V),t.loadCubeData(V,z,n,A,((V,h)=>{D(V,h)}))};c?L(c):mV&&6===mV.length?t.supportCascades?this._cascadeLoadFiles(h,(V=>L(V.map((V=>new Uint8Array(V))))),mV,D):D("Textures type does not support cascades."):this._loadFile(V,(V=>L(new Uint8Array(V))),void 0,void 0,!0,H)}));else{if(!mV||0===mV.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(h,z,((V,h)=>{s&&s(V,h)}),mV,D)}return this._internalTexturesCache.push(z),z}},12915:(V,h,mV)=>{mV.d(h,{c:()=>K});var t=mV(12422),L=mV(12435),N=mV(12597),A=mV(12425),k=mV(12453);class C{constructor(V,h,mV,t){this.name=V,this.worldAxisForNormal=h,this.worldAxisForFileX=mV,this.worldAxisForFileY=t}}class K{static ConvertCubeMapTextureToSphericalPolynomial(V){var h;if(!V.isCube)return null;null===(h=V.DV())||void 0===h||h.getEngine().flushFramebuffer();const mV=V.getSize().width,t=V.readPixels(0,void 0,void 0,!1),L=V.readPixels(1,void 0,void 0,!1);let N,A;V.isRenderTarget?(N=V.readPixels(3,void 0,void 0,!1),A=V.readPixels(2,void 0,void 0,!1)):(N=V.readPixels(2,void 0,void 0,!1),A=V.readPixels(3,void 0,void 0,!1));const k=V.readPixels(4,void 0,void 0,!1),C=V.readPixels(5,void 0,void 0,!1),K=V.gammaSpace;let o=0;return 1!=V.textureType&&2!=V.textureType||(o=1),new Promise((V=>{Promise.all([L,t,N,A,k,C]).then((h=>{let[t,L,N,A,k,C]=h;const n={size:mV,right:L,left:t,up:N,down:A,front:k,back:C,format:5,type:o,gammaSpace:K};V(this.ConvertCubeMapToSphericalPolynomial(n))}))}))}static _AreaElement(V,h){return Math.atan2(V*h,Math.sqrt(V*V+h*h+1))}static ConvertCubeMapToSphericalPolynomial(V){const h=new N.b;let mV=0;const t=2/V.size,C=t,K=.5*t,o=K-1;for(let N=0;N<6;N++){const n=this._FileFaces[N],q=V[n.name];let x=o;const R=5===V.format?4:3;for(let N=0;N<V.size;N++){let d=o;for(let C=0;C<V.size;C++){const o=n.worldAxisForFileX.scale(d).add(n.worldAxisForFileY.scale(x)).add(n.worldAxisForNormal);o.normalize();const s=this._AreaElement(d-K,x-K)-this._AreaElement(d-K,x+K)-this._AreaElement(d+K,x-K)+this._AreaElement(d+K,x+K);let M=q[N*V.size*R+C*R+0],c=q[N*V.size*R+C*R+1],z=q[N*V.size*R+C*R+2];isNaN(M)&&(M=0),isNaN(c)&&(c=0),isNaN(z)&&(z=0),0===V.type&&(M/=255,c/=255,z/=255),V.gammaSpace&&(M=Math.pow((0,L.Clamp)(M),A.j),c=Math.pow((0,L.Clamp)(c),A.j),z=Math.pow((0,L.Clamp)(z),A.j));const Q=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const V=Math.max(M,c,z);if(V>Q){const h=Q/V;M*=h,c*=h,z*=h}}else M=(0,L.Clamp)(M,0,Q),c=(0,L.Clamp)(c,0,Q),z=(0,L.Clamp)(z,0,Q);const J=new k.Jh(M,c,z);h.addLight(o,J,s),mV+=s,d+=t}x+=C}}const n=6*(4*Math.PI)/6/mV;return h.scaleInPlace(n),h.convertIncidentRadianceToIrradiance(),h.convertIrradianceToLambertianRadiance(),N.f.FromHarmonics(h)}}K._FileFaces=[new C("right",new t.sh(1,0,0),new t.sh(0,0,-1),new t.sh(0,-1,0)),new C("left",new t.sh(-1,0,0),new t.sh(0,0,1),new t.sh(0,-1,0)),new C("up",new t.sh(0,1,0),new t.sh(1,0,0),new t.sh(0,0,1)),new C("down",new t.sh(0,-1,0),new t.sh(1,0,0),new t.sh(0,0,-1)),new C("front",new t.sh(0,0,1),new t.sh(1,0,0),new t.sh(0,-1,0)),new C("back",new t.sh(0,0,-1),new t.sh(-1,0,0),new t.sh(0,-1,0))],K.MAX_HDRI_VALUE=4096,K.PRESERVE_CLAMPED_COLORS=!1},14814:(V,h,mV)=>{mV.d(h,{DDSTools:()=>R});var t=mV(12435),L=mV(12264),N=mV(12915),A=mV(12632);mV(14082);const k=131072,C=131072;function K(V){return V.charCodeAt(0)+(V.charCodeAt(1)<<8)+(V.charCodeAt(2)<<16)+(V.charCodeAt(3)<<24)}const o=K("DXT1"),n=K("DXT3"),q=K("DXT5"),x=K("DX10");class R{static GetDDSInfo(V){const h=new Int32Array(V.buffer,V.byteOffset,31),mV=new Int32Array(V.buffer,V.byteOffset,35);let t=1;h[2]&k&&(t=Math.max(1,h[7]));const L=h[21],N=L===x?mV[32]:0;let A=0;switch(L){case 113:A=2;break;case 116:A=1;break;case x:if(10===N){A=2;break}if(2===N){A=1;break}}return{width:h[4],height:h[3],mipmapCount:t,isFourCC:4===(4&h[20]),isRGB:64===(64&h[20]),isLuminance:(h[20]&C)===C,isCube:512===(512&h[28]),isCompressed:L===o||L===n||L===q,dxgiFormat:N,textureType:A}}static _GetHalfFloatAsFloatRGBAArrayBuffer(V,h,mV,t,L,N){const k=new Float32Array(t),C=new Uint16Array(L,mV);let K=0;for(let o=0;o<h;o++)for(let h=0;h<V;h++){const mV=4*(h+o*V);k[K]=(0,A.h)(C[mV]),k[K+1]=(0,A.h)(C[mV+1]),k[K+2]=(0,A.h)(C[mV+2]),R.StoreLODInAlphaChannel?k[K+3]=N:k[K+3]=(0,A.h)(C[mV+3]),K+=4}return k}static _GetHalfFloatRGBAArrayBuffer(V,h,mV,t,L,N){if(R.StoreLODInAlphaChannel){const k=new Uint16Array(t),C=new Uint16Array(L,mV);let K=0;for(let mV=0;mV<h;mV++)for(let h=0;h<V;h++){const t=4*(h+mV*V);k[K]=C[t],k[K+1]=C[t+1],k[K+2]=C[t+2],k[K+3]=(0,A.s)(N),K+=4}return k}return new Uint16Array(L,mV,t)}static _GetFloatRGBAArrayBuffer(V,h,mV,t,L,N){if(R.StoreLODInAlphaChannel){const A=new Float32Array(t),k=new Float32Array(L,mV);let C=0;for(let mV=0;mV<h;mV++)for(let h=0;h<V;h++){const t=4*(h+mV*V);A[C]=k[t],A[C+1]=k[t+1],A[C+2]=k[t+2],A[C+3]=N,C+=4}return A}return new Float32Array(L,mV,t)}static _GetFloatAsHalfFloatRGBAArrayBuffer(V,h,mV,t,L,N){const k=new Uint16Array(t),C=new Float32Array(L,mV);let K=0;for(let o=0;o<h;o++)for(let h=0;h<V;h++)k[K]=(0,A.s)(C[K]),k[K+1]=(0,A.s)(C[K+1]),k[K+2]=(0,A.s)(C[K+2]),R.StoreLODInAlphaChannel?k[K+3]=(0,A.s)(N):k[K+3]=(0,A.s)(C[K+3]),K+=4;return k}static _GetFloatAsUIntRGBAArrayBuffer(V,h,mV,L,N,A){const k=new Uint8Array(L),C=new Float32Array(N,mV);let K=0;for(let o=0;o<h;o++)for(let h=0;h<V;h++){const mV=4*(h+o*V);k[K]=255*(0,t.Clamp)(C[mV]),k[K+1]=255*(0,t.Clamp)(C[mV+1]),k[K+2]=255*(0,t.Clamp)(C[mV+2]),R.StoreLODInAlphaChannel?k[K+3]=A:k[K+3]=255*(0,t.Clamp)(C[mV+3]),K+=4}return k}static _GetHalfFloatAsUIntRGBAArrayBuffer(V,h,mV,L,N,k){const C=new Uint8Array(L),K=new Uint16Array(N,mV);let o=0;for(let n=0;n<h;n++)for(let h=0;h<V;h++){const mV=4*(h+n*V);C[o]=255*(0,t.Clamp)((0,A.h)(K[mV])),C[o+1]=255*(0,t.Clamp)((0,A.h)(K[mV+1])),C[o+2]=255*(0,t.Clamp)((0,A.h)(K[mV+2])),R.StoreLODInAlphaChannel?C[o+3]=k:C[o+3]=255*(0,t.Clamp)((0,A.h)(K[mV+3])),o+=4}return C}static _GetRGBAArrayBuffer(V,h,mV,t,L,N,A,k,C){const K=new Uint8Array(t),o=new Uint8Array(L,mV);let n=0;for(let q=0;q<h;q++)for(let h=0;h<V;h++){const mV=4*(h+q*V);K[n]=o[mV+N],K[n+1]=o[mV+A],K[n+2]=o[mV+k],K[n+3]=o[mV+C],n+=4}return K}static _ExtractLongWordOrder(V){return 0===V||255===V||-16777216===V?0:1+R._ExtractLongWordOrder(V>>8)}static _GetRGBArrayBuffer(V,h,mV,t,L,N,A,k){const C=new Uint8Array(t),K=new Uint8Array(L,mV);let o=0;for(let n=0;n<h;n++)for(let h=0;h<V;h++){const mV=3*(h+n*V);C[o]=K[mV+N],C[o+1]=K[mV+A],C[o+2]=K[mV+k],o+=3}return C}static _GetLuminanceArrayBuffer(V,h,mV,t,L){const N=new Uint8Array(t),A=new Uint8Array(L,mV);let k=0;for(let C=0;C<h;C++)for(let h=0;h<V;h++){const mV=h+C*V;N[k]=A[mV],k++}return N}static UploadDDSLevels(V,h,mV,t,A,C){let K=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,d=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],M=null;t.sphericalPolynomial&&(M=[]);const c=!!V.getCaps().s3tc;h.generateMipMaps=A;const z=new Int32Array(mV.buffer,mV.byteOffset,31);let Q,J,v,D,H,j,l,G=0,y=0,O=1;if(542327876!==z[0])return void L.e.Error("Invalid magic number in DDS header");if(!t.isFourCC&&!t.isRGB&&!t.isLuminance)return void L.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(t.isCompressed&&!c)return void L.e.Error("Compressed textures are not supported on this platform.");let I=z[22];D=z[1]+4;let r=!1;if(t.isFourCC)switch(Q=z[21],Q){case o:O=8,y=33777;break;case n:O=16,y=33778;break;case q:O=16,y=33779;break;case 113:r=!0,I=64;break;case 116:r=!0,I=128;break;case x:{D+=20;let V=!1;switch(t.dxgiFormat){case 10:r=!0,I=64,V=!0;break;case 2:r=!0,I=128,V=!0;break;case 88:t.isRGB=!0,t.isFourCC=!1,I=32,V=!0}if(V)break}default:return void L.e.Error(["Unsupported FourCC code:",(T=Q,String.fromCharCode(255&T,T>>8&255,T>>16&255,T>>24&255))])}var T;const F=R._ExtractLongWordOrder(z[23]),p=R._ExtractLongWordOrder(z[24]),Z=R._ExtractLongWordOrder(z[25]),f=R._ExtractLongWordOrder(z[26]);r&&(y=V._getRGBABufferInternalSizedFormat(t.textureType)),j=1,z[2]&k&&!1!==A&&(j=Math.max(1,z[7]));const S=d||0,Y=V.getCaps();for(let L=S;L<C;L++){for(J=z[4],v=z[3],l=0;l<j;++l){if(-1===K||K===l){const N=-1===K?l:0;if(!t.isCompressed&&t.isFourCC){h.format=5,G=J*v*4;let t=null;if(V._badOS||V._badDesktopOS||!Y.textureHalfFloat&&!Y.textureFloat)128===I?(t=R._GetFloatAsUIntRGBAArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,N),M&&0==N&&M.push(R._GetFloatRGBAArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,N))):64===I&&(t=R._GetHalfFloatAsUIntRGBAArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,N),M&&0==N&&M.push(R._GetHalfFloatAsFloatRGBAArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,N))),h.type=0;else{const V=Y.textureFloat&&(s&&Y.textureFloatLinearFiltering||!s),L=Y.textureHalfFloat&&(s&&Y.textureHalfFloatLinearFiltering||!s),A=(128===I||64===I&&!L)&&V?1:(64===I||128===I&&!V)&&L?2:0;let k,C=null;if(128===I)switch(A){case 1:k=R._GetFloatRGBAArrayBuffer,C=null;break;case 2:k=R._GetFloatAsHalfFloatRGBAArrayBuffer,C=R._GetFloatRGBAArrayBuffer;break;case 0:k=R._GetFloatAsUIntRGBAArrayBuffer,C=R._GetFloatRGBAArrayBuffer}else switch(A){case 1:k=R._GetHalfFloatAsFloatRGBAArrayBuffer,C=null;break;case 2:k=R._GetHalfFloatRGBAArrayBuffer,C=R._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:k=R._GetHalfFloatAsUIntRGBAArrayBuffer,C=R._GetHalfFloatAsFloatRGBAArrayBuffer}h.type=A,t=k(J,v,mV.byteOffset+D,G,mV.buffer,N),M&&0==N&&M.push(C?C(J,v,mV.byteOffset+D,G,mV.buffer,N):t)}t&&V._uploadDataToTextureDirectly(h,t,L,N)}else if(t.isRGB)h.type=0,24===I?(h.format=4,G=J*v*3,H=R._GetRGBArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,F,p,Z),V._uploadDataToTextureDirectly(h,H,L,N)):(h.format=5,G=J*v*4,H=R._GetRGBAArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer,F,p,Z,f),V._uploadDataToTextureDirectly(h,H,L,N));else if(t.isLuminance){const t=V._getUnpackAlignement(),A=J;G=Math.floor((J+t-1)/t)*t*(v-1)+A,H=R._GetLuminanceArrayBuffer(J,v,mV.byteOffset+D,G,mV.buffer),h.format=1,h.type=0,V._uploadDataToTextureDirectly(h,H,L,N)}else G=Math.max(4,J)/4*Math.max(4,v)/4*O,H=new Uint8Array(mV.buffer,mV.byteOffset+D,G),h.type=0,V._uploadCompressedDataToTextureDirectly(h,y,J,v,H,L,N)}D+=I?J*v*(I/8):G,J*=.5,v*=.5,J=Math.max(1,J),v=Math.max(1,v)}if(void 0!==d)break}M&&M.length>0?t.sphericalPolynomial=N.c.ConvertCubeMapToSphericalPolynomial({size:z[4],right:M[0],left:M[1],up:M[2],down:M[3],front:M[4],back:M[5],format:5,type:1,gammaSpace:!1}):t.sphericalPolynomial=void 0}}R.StoreLODInAlphaChannel=!1}}]);