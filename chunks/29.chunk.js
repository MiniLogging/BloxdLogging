"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[29],{12865:(R,J,B)=>{var Q=B(11124),h=B(11043),y=B(11073),N=B(11148),r=B(11094),q=B(11133);r.c.prototype._partialLoadFile=function(R,J,B,Q){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(R,(R=>{B[J]=R,B._internalCount++,6===B._internalCount&&Q(B)}),void 0,void 0,!0,((R,J)=>{h&&R&&h(R.status+" "+R.statusText,J)}))},r.c.prototype._cascadeLoadFiles=function(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const h=[];h._internalCount=0;for(let y=0;y<6;y++)this._partialLoadFile(B[y],y,h,J,Q)},r.c.prototype._cascadeLoadImgs=function(R,J,B,Q){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,y=arguments.length>5?arguments[5]:void 0;const N=[];N._internalCount=0;for(let r=0;r<6;r++)this._partialLoadImg(Q[r],r,N,R,J,B,h,y)},r.c.prototype._partialLoadImg=function(R,J,B,Q,h,r){let q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,e=arguments.length>7?arguments[7]:void 0;const D=(0,N.c)();(0,y.q)(R,(R=>{B[J]=R,B._internalCount++,Q&&Q.removePendingData(D),6===B._internalCount&&r&&r(h,B)}),((R,J)=>{Q&&Q.removePendingData(D),q&&q(R,J)}),Q?Q.offlineProvider:null,e),Q&&Q.addPendingData(D)},r.c.prototype.createCubeTextureBase=function(R,J,B,y){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,e=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,l=arguments.length>8&&void 0!==arguments[8]&&arguments[8],E=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,n=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,P=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,A=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,u=arguments.length>14&&void 0!==arguments[14]&&arguments[14],S=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const f=n||new Q.c(this,7);f.isCube=!0,f.url=R,f.generateMipMaps=!y,f._lodGenerationScale=E,f._lodGenerationOffset=O,f._useSRGBBuffer=!!u&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!y),f!==n&&(f.label=R.substring(0,60)),this._doNotHandleContextLost||(f._extension=D,f._files=B,f._buffer=S);const a=R;this._transformTextureUrl&&!n&&(R=this._transformTextureUrl(R));const s=D??function(R){const J=R.split("?")[0],B=J.lastIndexOf(".");return B>-1?J.substring(B).toLowerCase():""}(R),x=(0,q.c)(s),I=(R,J)=>{f.dispose(),r?r(R,J):R&&h.d.Warn(R)},V=(Q,r)=>{R===a?Q&&I(Q.status+" "+Q.statusText,r):(h.d.Warn(`Failed to load ${R}, falling back to the ${a}`),this.createCubeTextureBase(a,J,B,!!y,N,I,e,D,l,E,O,f,P,A,u,S))};if(x)x.then((Q=>{const h=R=>{P&&P(f,R),Q.loadCubeData(R,f,l,N,((R,J)=>{I(R,J)}))};S?h(S):B&&6===B.length?Q.supportCascades?this._cascadeLoadFiles(J,(R=>h(R.map((R=>new Uint8Array(R))))),B,I):I("Textures type does not support cascades."):this._loadFile(R,(R=>h(new Uint8Array(R))),void 0,void 0,!0,V)}));else{if(!B||0===B.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(J,f,((R,J)=>{A&&A(R,J)}),B,I)}return this._internalTexturesCache.push(f),f}},11711:(R,J,B)=>{B.d(J,{d:()=>e});var Q=B(11186),h=B(11201),y=B(11370),N=B(11189),r=B(11224);class q{constructor(R,J,B,Q){this.name=R,this.worldAxisForNormal=J,this.worldAxisForFileX=B,this.worldAxisForFileY=Q}}class e{static ConvertCubeMapTextureToSphericalPolynomial(R){var J;if(!R.isCube)return null;null===(J=R.IR())||void 0===J||J.getEngine().flushFramebuffer();const B=R.getSize().width,Q=R.readPixels(0,void 0,void 0,!1),h=R.readPixels(1,void 0,void 0,!1);let y,N;R.isRenderTarget?(y=R.readPixels(3,void 0,void 0,!1),N=R.readPixels(2,void 0,void 0,!1)):(y=R.readPixels(2,void 0,void 0,!1),N=R.readPixels(3,void 0,void 0,!1));const r=R.readPixels(4,void 0,void 0,!1),q=R.readPixels(5,void 0,void 0,!1),e=R.gammaSpace;let D=0;return 1!=R.textureType&&2!=R.textureType||(D=1),new Promise((R=>{Promise.all([h,Q,y,N,r,q]).then((J=>{let[Q,h,y,N,r,q]=J;const l={size:B,right:h,left:Q,up:y,down:N,front:r,back:q,format:5,type:D,gammaSpace:e};R(this.ConvertCubeMapToSphericalPolynomial(l))}))}))}static _AreaElement(R,J){return Math.atan2(R*J,Math.sqrt(R*R+J*J+1))}static ConvertCubeMapToSphericalPolynomial(R){const J=new y.b;let B=0;const Q=2/R.size,q=Q,e=.5*Q,D=e-1;for(let y=0;y<6;y++){const l=this._FileFaces[y],E=R[l.name];let O=D;const n=5===R.format?4:3;for(let y=0;y<R.size;y++){let P=D;for(let q=0;q<R.size;q++){const D=l.worldAxisForFileX.scale(P).add(l.worldAxisForFileY.scale(O)).add(l.worldAxisForNormal);D.normalize();const A=this._AreaElement(P-e,O-e)-this._AreaElement(P-e,O+e)-this._AreaElement(P+e,O-e)+this._AreaElement(P+e,O+e);let u=E[y*R.size*n+q*n+0],S=E[y*R.size*n+q*n+1],f=E[y*R.size*n+q*n+2];isNaN(u)&&(u=0),isNaN(S)&&(S=0),isNaN(f)&&(f=0),0===R.type&&(u/=255,S/=255,f/=255),R.gammaSpace&&(u=Math.pow((0,h.Clamp)(u),N.i),S=Math.pow((0,h.Clamp)(S),N.i),f=Math.pow((0,h.Clamp)(f),N.i));const a=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const R=Math.max(u,S,f);if(R>a){const J=a/R;u*=J,S*=J,f*=J}}else u=(0,h.Clamp)(u,0,a),S=(0,h.Clamp)(S,0,a),f=(0,h.Clamp)(f,0,a);const s=new r.SJ(u,S,f);J.addLight(D,s,A),B+=A,P+=Q}O+=q}}const l=6*(4*Math.PI)/6/B;return J.scaleInPlace(l),J.convertIncidentRadianceToIrradiance(),J.convertIrradianceToLambertianRadiance(),y.d.FromHarmonics(J)}}e._FileFaces=[new q("right",new Q.nJ(1,0,0),new Q.nJ(0,0,-1),new Q.nJ(0,-1,0)),new q("left",new Q.nJ(-1,0,0),new Q.nJ(0,0,1),new Q.nJ(0,-1,0)),new q("up",new Q.nJ(0,1,0),new Q.nJ(1,0,0),new Q.nJ(0,0,1)),new q("down",new Q.nJ(0,-1,0),new Q.nJ(1,0,0),new Q.nJ(0,0,-1)),new q("front",new Q.nJ(0,0,1),new Q.nJ(1,0,0),new Q.nJ(0,-1,0)),new q("back",new Q.nJ(0,0,-1),new Q.nJ(-1,0,0),new Q.nJ(0,-1,0))],e.MAX_HDRI_VALUE=4096,e.PRESERVE_CLAMPED_COLORS=!1},13637:(R,J,B)=>{B.d(J,{DDSTools:()=>n});var Q=B(11201),h=B(11043),y=B(11711),N=B(11408);B(12865);const r=131072,q=131072;function e(R){return R.charCodeAt(0)+(R.charCodeAt(1)<<8)+(R.charCodeAt(2)<<16)+(R.charCodeAt(3)<<24)}const D=e("DXT1"),l=e("DXT3"),E=e("DXT5"),O=e("DX10");class n{static GetDDSInfo(R){const J=new Int32Array(R.buffer,R.byteOffset,31),B=new Int32Array(R.buffer,R.byteOffset,35);let Q=1;J[2]&r&&(Q=Math.max(1,J[7]));const h=J[21],y=h===O?B[32]:0;let N=0;switch(h){case 113:N=2;break;case 116:N=1;break;case O:if(10===y){N=2;break}if(2===y){N=1;break}}return{width:J[4],height:J[3],mipmapCount:Q,isFourCC:4===(4&J[20]),isRGB:64===(64&J[20]),isLuminance:(J[20]&q)===q,isCube:512===(512&J[28]),isCompressed:h===D||h===l||h===E,dxgiFormat:y,textureType:N}}static _GetHalfFloatAsFloatRGBAArrayBuffer(R,J,B,Q,h,y){const r=new Float32Array(Q),q=new Uint16Array(h,B);let e=0;for(let D=0;D<J;D++)for(let J=0;J<R;J++){const B=4*(J+D*R);r[e]=(0,N.f)(q[B]),r[e+1]=(0,N.f)(q[B+1]),r[e+2]=(0,N.f)(q[B+2]),n.StoreLODInAlphaChannel?r[e+3]=y:r[e+3]=(0,N.f)(q[B+3]),e+=4}return r}static _GetHalfFloatRGBAArrayBuffer(R,J,B,Q,h,y){if(n.StoreLODInAlphaChannel){const r=new Uint16Array(Q),q=new Uint16Array(h,B);let e=0;for(let B=0;B<J;B++)for(let J=0;J<R;J++){const Q=4*(J+B*R);r[e]=q[Q],r[e+1]=q[Q+1],r[e+2]=q[Q+2],r[e+3]=(0,N.k)(y),e+=4}return r}return new Uint16Array(h,B,Q)}static _GetFloatRGBAArrayBuffer(R,J,B,Q,h,y){if(n.StoreLODInAlphaChannel){const N=new Float32Array(Q),r=new Float32Array(h,B);let q=0;for(let B=0;B<J;B++)for(let J=0;J<R;J++){const Q=4*(J+B*R);N[q]=r[Q],N[q+1]=r[Q+1],N[q+2]=r[Q+2],N[q+3]=y,q+=4}return N}return new Float32Array(h,B,Q)}static _GetFloatAsHalfFloatRGBAArrayBuffer(R,J,B,Q,h,y){const r=new Uint16Array(Q),q=new Float32Array(h,B);let e=0;for(let D=0;D<J;D++)for(let J=0;J<R;J++)r[e]=(0,N.k)(q[e]),r[e+1]=(0,N.k)(q[e+1]),r[e+2]=(0,N.k)(q[e+2]),n.StoreLODInAlphaChannel?r[e+3]=(0,N.k)(y):r[e+3]=(0,N.k)(q[e+3]),e+=4;return r}static _GetFloatAsUIntRGBAArrayBuffer(R,J,B,h,y,N){const r=new Uint8Array(h),q=new Float32Array(y,B);let e=0;for(let D=0;D<J;D++)for(let J=0;J<R;J++){const B=4*(J+D*R);r[e]=255*(0,Q.Clamp)(q[B]),r[e+1]=255*(0,Q.Clamp)(q[B+1]),r[e+2]=255*(0,Q.Clamp)(q[B+2]),n.StoreLODInAlphaChannel?r[e+3]=N:r[e+3]=255*(0,Q.Clamp)(q[B+3]),e+=4}return r}static _GetHalfFloatAsUIntRGBAArrayBuffer(R,J,B,h,y,r){const q=new Uint8Array(h),e=new Uint16Array(y,B);let D=0;for(let l=0;l<J;l++)for(let J=0;J<R;J++){const B=4*(J+l*R);q[D]=255*(0,Q.Clamp)((0,N.f)(e[B])),q[D+1]=255*(0,Q.Clamp)((0,N.f)(e[B+1])),q[D+2]=255*(0,Q.Clamp)((0,N.f)(e[B+2])),n.StoreLODInAlphaChannel?q[D+3]=r:q[D+3]=255*(0,Q.Clamp)((0,N.f)(e[B+3])),D+=4}return q}static _GetRGBAArrayBuffer(R,J,B,Q,h,y,N,r,q){const e=new Uint8Array(Q),D=new Uint8Array(h,B);let l=0;for(let E=0;E<J;E++)for(let J=0;J<R;J++){const B=4*(J+E*R);e[l]=D[B+y],e[l+1]=D[B+N],e[l+2]=D[B+r],e[l+3]=D[B+q],l+=4}return e}static _ExtractLongWordOrder(R){return 0===R||255===R||-16777216===R?0:1+n._ExtractLongWordOrder(R>>8)}static _GetRGBArrayBuffer(R,J,B,Q,h,y,N,r){const q=new Uint8Array(Q),e=new Uint8Array(h,B);let D=0;for(let l=0;l<J;l++)for(let J=0;J<R;J++){const B=3*(J+l*R);q[D]=e[B+y],q[D+1]=e[B+N],q[D+2]=e[B+r],D+=3}return q}static _GetLuminanceArrayBuffer(R,J,B,Q,h){const y=new Uint8Array(Q),N=new Uint8Array(h,B);let r=0;for(let q=0;q<J;q++)for(let J=0;J<R;J++){const B=J+q*R;y[r]=N[B],r++}return y}static UploadDDSLevels(R,J,B,Q,N,q){let e=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,P=arguments.length>7?arguments[7]:void 0,A=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],u=null;Q.sphericalPolynomial&&(u=[]);const S=!!R.getCaps().s3tc;J.generateMipMaps=N;const f=new Int32Array(B.buffer,B.byteOffset,31);let a,s,x,I,V,M,H,d=0,X=0,c=1;if(542327876!==f[0])return void h.d.Error("Invalid magic number in DDS header");if(!Q.isFourCC&&!Q.isRGB&&!Q.isLuminance)return void h.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(Q.isCompressed&&!S)return void h.d.Error("Compressed textures are not supported on this platform.");let z=f[22];I=f[1]+4;let p=!1;if(Q.isFourCC)switch(a=f[21],a){case D:c=8,X=33777;break;case l:c=16,X=33778;break;case E:c=16,X=33779;break;case 113:p=!0,z=64;break;case 116:p=!0,z=128;break;case O:{I+=20;let R=!1;switch(Q.dxgiFormat){case 10:p=!0,z=64,R=!0;break;case 2:p=!0,z=128,R=!0;break;case 88:Q.isRGB=!0,Q.isFourCC=!1,z=32,R=!0}if(R)break}default:return void h.d.Error(["Unsupported FourCC code:",(i=a,String.fromCharCode(255&i,i>>8&255,i>>16&255,i>>24&255))])}var i;const W=n._ExtractLongWordOrder(f[23]),k=n._ExtractLongWordOrder(f[24]),Y=n._ExtractLongWordOrder(f[25]),G=n._ExtractLongWordOrder(f[26]);p&&(X=R._getRGBABufferInternalSizedFormat(Q.textureType)),M=1,f[2]&r&&!1!==N&&(M=Math.max(1,f[7]));const g=P||0,L=R.getCaps();for(let h=g;h<q;h++){for(s=f[4],x=f[3],H=0;H<M;++H){if(-1===e||e===H){const y=-1===e?H:0;if(!Q.isCompressed&&Q.isFourCC){J.format=5,d=s*x*4;let Q=null;if(R._badOS||R._badDesktopOS||!L.textureHalfFloat&&!L.textureFloat)128===z?(Q=n._GetFloatAsUIntRGBAArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,y),u&&0==y&&u.push(n._GetFloatRGBAArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,y))):64===z&&(Q=n._GetHalfFloatAsUIntRGBAArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,y),u&&0==y&&u.push(n._GetHalfFloatAsFloatRGBAArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,y))),J.type=0;else{const R=L.textureFloat&&(A&&L.textureFloatLinearFiltering||!A),h=L.textureHalfFloat&&(A&&L.textureHalfFloatLinearFiltering||!A),N=(128===z||64===z&&!h)&&R?1:(64===z||128===z&&!R)&&h?2:0;let r,q=null;if(128===z)switch(N){case 1:r=n._GetFloatRGBAArrayBuffer,q=null;break;case 2:r=n._GetFloatAsHalfFloatRGBAArrayBuffer,q=n._GetFloatRGBAArrayBuffer;break;case 0:r=n._GetFloatAsUIntRGBAArrayBuffer,q=n._GetFloatRGBAArrayBuffer}else switch(N){case 1:r=n._GetHalfFloatAsFloatRGBAArrayBuffer,q=null;break;case 2:r=n._GetHalfFloatRGBAArrayBuffer,q=n._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:r=n._GetHalfFloatAsUIntRGBAArrayBuffer,q=n._GetHalfFloatAsFloatRGBAArrayBuffer}J.type=N,Q=r(s,x,B.byteOffset+I,d,B.buffer,y),u&&0==y&&u.push(q?q(s,x,B.byteOffset+I,d,B.buffer,y):Q)}Q&&R._uploadDataToTextureDirectly(J,Q,h,y)}else if(Q.isRGB)J.type=0,24===z?(J.format=4,d=s*x*3,V=n._GetRGBArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,W,k,Y),R._uploadDataToTextureDirectly(J,V,h,y)):(J.format=5,d=s*x*4,V=n._GetRGBAArrayBuffer(s,x,B.byteOffset+I,d,B.buffer,W,k,Y,G),R._uploadDataToTextureDirectly(J,V,h,y));else if(Q.isLuminance){const Q=R._getUnpackAlignement(),N=s;d=Math.floor((s+Q-1)/Q)*Q*(x-1)+N,V=n._GetLuminanceArrayBuffer(s,x,B.byteOffset+I,d,B.buffer),J.format=1,J.type=0,R._uploadDataToTextureDirectly(J,V,h,y)}else d=Math.max(4,s)/4*Math.max(4,x)/4*c,V=new Uint8Array(B.buffer,B.byteOffset+I,d),J.type=0,R._uploadCompressedDataToTextureDirectly(J,X,s,x,V,h,y)}I+=z?s*x*(z/8):d,s*=.5,x*=.5,s=Math.max(1,s),x=Math.max(1,x)}if(void 0!==P)break}u&&u.length>0?Q.sphericalPolynomial=y.d.ConvertCubeMapToSphericalPolynomial({size:f[4],right:u[0],left:u[1],up:u[2],down:u[3],front:u[4],back:u[5],format:5,type:1,gammaSpace:!1}):Q.sphericalPolynomial=void 0}}n.StoreLODInAlphaChannel=!1}}]);