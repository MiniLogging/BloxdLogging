"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[29],{13227:(F,P,f)=>{var c=f(11567),N=f(11474),q=f(11510),H=f(11596),A=f(11541),o=f(11580);A.b.prototype._partialLoadFile=function(F,P,f,c){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(F,(F=>{f[P]=F,f._internalCount++,6===f._internalCount&&c(f)}),void 0,void 0,!0,((F,P)=>{N&&F&&N(F.status+" "+F.statusText,P)}))},A.b.prototype._cascadeLoadFiles=function(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const N=[];N._internalCount=0;for(let q=0;q<6;q++)this._partialLoadFile(f[q],q,N,P,c)},A.b.prototype._cascadeLoadImgs=function(F,P,f,c){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,q=arguments.length>5?arguments[5]:void 0;const H=[];H._internalCount=0;for(let A=0;A<6;A++)this._partialLoadImg(c[A],A,H,F,P,f,N,q)},A.b.prototype._partialLoadImg=function(F,P,f,c,N,A){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,j=arguments.length>7?arguments[7]:void 0;const i=(0,H.e)();(0,q.r)(F,(F=>{f[P]=F,f._internalCount++,c&&c.removePendingData(i),6===f._internalCount&&A&&A(N,f)}),((F,P)=>{c&&c.removePendingData(i),o&&o(F,P)}),c?c.offlineProvider:null,j),c&&c.addPendingData(i)},A.b.prototype.createCubeTextureBase=function(F,P,f,q){let H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,A=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,j=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,u=arguments.length>8&&void 0!==arguments[8]&&arguments[8],T=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,Y=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,t=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,C=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,L=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,J=arguments.length>14&&void 0!==arguments[14]&&arguments[14],B=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const z=t||new c.b(this,7);z.isCube=!0,z.url=F,z.generateMipMaps=!q,z._lodGenerationScale=T,z._lodGenerationOffset=Y,z._useSRGBBuffer=!!J&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!q),z!==t&&(z.label=F.substring(0,60)),this._doNotHandleContextLost||(z._extension=i,z._files=f,z._buffer=B);const Z=F;this._transformTextureUrl&&!t&&(F=this._transformTextureUrl(F));const R=i??function(F){const P=F.split("?")[0],f=P.lastIndexOf(".");return f>-1?P.substring(f).toLowerCase():""}(F),y=(0,o.e)(R),O=(F,P)=>{z.dispose(),A?A(F,P):F&&N.d.Warn(F)},d=(c,A)=>{F===Z?c&&O(c.status+" "+c.statusText,A):(N.d.Warn(`Failed to load ${F}, falling back to the ${Z}`),this.createCubeTextureBase(Z,P,f,!!q,H,O,j,i,u,T,Y,z,C,L,J,B))};if(y)y.then((c=>{const N=F=>{C&&C(z,F),c.loadCubeData(F,z,u,H,((F,P)=>{O(F,P)}))};B?N(B):f&&6===f.length?c.supportCascades?this._cascadeLoadFiles(P,(F=>N(F.map((F=>new Uint8Array(F))))),f,O):O("Textures type does not support cascades."):this._loadFile(F,(F=>N(new Uint8Array(F))),void 0,void 0,!0,d)}));else{if(!f||0===f.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(P,z,((F,P)=>{L&&L(F,P)}),f,O)}return this._internalTexturesCache.push(z),z}},12145:(F,P,f)=>{f.d(P,{c:()=>j});var c=f(11639),N=f(11664),q=f(11801),H=f(11648),A=f(11690);class o{constructor(F,P,f,c){this.name=F,this.worldAxisForNormal=P,this.worldAxisForFileX=f,this.worldAxisForFileY=c}}class j{static ConvertCubeMapTextureToSphericalPolynomial(F){var P;if(!F.isCube)return null;null===(P=F.OF())||void 0===P||P.getEngine().flushFramebuffer();const f=F.getSize().width,c=F.readPixels(0,void 0,void 0,!1),N=F.readPixels(1,void 0,void 0,!1);let q,H;F.isRenderTarget?(q=F.readPixels(3,void 0,void 0,!1),H=F.readPixels(2,void 0,void 0,!1)):(q=F.readPixels(2,void 0,void 0,!1),H=F.readPixels(3,void 0,void 0,!1));const A=F.readPixels(4,void 0,void 0,!1),o=F.readPixels(5,void 0,void 0,!1),j=F.gammaSpace;let i=0;return 1!=F.textureType&&2!=F.textureType||(i=1),new Promise((F=>{Promise.all([N,c,q,H,A,o]).then((P=>{let[c,N,q,H,A,o]=P;const u={size:f,right:N,left:c,up:q,down:H,front:A,back:o,format:5,type:i,gammaSpace:j};F(this.ConvertCubeMapToSphericalPolynomial(u))}))}))}static _AreaElement(F,P){return Math.atan2(F*P,Math.sqrt(F*F+P*P+1))}static ConvertCubeMapToSphericalPolynomial(F){const P=new q.e;let f=0;const c=2/F.size,o=c,j=.5*c,i=j-1;for(let q=0;q<6;q++){const u=this._FileFaces[q],T=F[u.name];let Y=i;const t=5===F.format?4:3;for(let q=0;q<F.size;q++){let C=i;for(let o=0;o<F.size;o++){const i=u.worldAxisForFileX.scale(C).add(u.worldAxisForFileY.scale(Y)).add(u.worldAxisForNormal);i.normalize();const L=this._AreaElement(C-j,Y-j)-this._AreaElement(C-j,Y+j)-this._AreaElement(C+j,Y-j)+this._AreaElement(C+j,Y+j);let J=T[q*F.size*t+o*t+0],B=T[q*F.size*t+o*t+1],z=T[q*F.size*t+o*t+2];isNaN(J)&&(J=0),isNaN(B)&&(B=0),isNaN(z)&&(z=0),0===F.type&&(J/=255,B/=255,z/=255),F.gammaSpace&&(J=Math.pow((0,N.Clamp)(J),H.l),B=Math.pow((0,N.Clamp)(B),H.l),z=Math.pow((0,N.Clamp)(z),H.l));const Z=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const F=Math.max(J,B,z);if(F>Z){const P=Z/F;J*=P,B*=P,z*=P}}else J=(0,N.Clamp)(J,0,Z),B=(0,N.Clamp)(B,0,Z),z=(0,N.Clamp)(z,0,Z);const R=new A.BP(J,B,z);P.addLight(i,R,L),f+=L,C+=c}Y+=o}}const u=6*(4*Math.PI)/6/f;return P.scaleInPlace(u),P.convertIncidentRadianceToIrradiance(),P.convertIrradianceToLambertianRadiance(),q.h.FromHarmonics(P)}}j._FileFaces=[new o("right",new c.tP(1,0,0),new c.tP(0,0,-1),new c.tP(0,-1,0)),new o("left",new c.tP(-1,0,0),new c.tP(0,0,1),new c.tP(0,-1,0)),new o("up",new c.tP(0,1,0),new c.tP(1,0,0),new c.tP(0,0,1)),new o("down",new c.tP(0,-1,0),new c.tP(1,0,0),new c.tP(0,0,-1)),new o("front",new c.tP(0,0,1),new c.tP(1,0,0),new c.tP(0,-1,0)),new o("back",new c.tP(0,0,-1),new c.tP(-1,0,0),new c.tP(0,-1,0))],j.MAX_HDRI_VALUE=4096,j.PRESERVE_CLAMPED_COLORS=!1},14042:(F,P,f)=>{f.d(P,{DDSTools:()=>t});var c=f(11664),N=f(11474),q=f(12145),H=f(11841);f(13227);const A=131072,o=131072;function j(F){return F.charCodeAt(0)+(F.charCodeAt(1)<<8)+(F.charCodeAt(2)<<16)+(F.charCodeAt(3)<<24)}const i=j("DXT1"),u=j("DXT3"),T=j("DXT5"),Y=j("DX10");class t{static GetDDSInfo(F){const P=new Int32Array(F.buffer,F.byteOffset,31),f=new Int32Array(F.buffer,F.byteOffset,35);let c=1;P[2]&A&&(c=Math.max(1,P[7]));const N=P[21],q=N===Y?f[32]:0;let H=0;switch(N){case 113:H=2;break;case 116:H=1;break;case Y:if(10===q){H=2;break}if(2===q){H=1;break}}return{width:P[4],height:P[3],mipmapCount:c,isFourCC:4===(4&P[20]),isRGB:64===(64&P[20]),isLuminance:(P[20]&o)===o,isCube:512===(512&P[28]),isCompressed:N===i||N===u||N===T,dxgiFormat:q,textureType:H}}static _GetHalfFloatAsFloatRGBAArrayBuffer(F,P,f,c,N,q){const A=new Float32Array(c),o=new Uint16Array(N,f);let j=0;for(let i=0;i<P;i++)for(let P=0;P<F;P++){const f=4*(P+i*F);A[j]=(0,H.e)(o[f]),A[j+1]=(0,H.e)(o[f+1]),A[j+2]=(0,H.e)(o[f+2]),t.StoreLODInAlphaChannel?A[j+3]=q:A[j+3]=(0,H.e)(o[f+3]),j+=4}return A}static _GetHalfFloatRGBAArrayBuffer(F,P,f,c,N,q){if(t.StoreLODInAlphaChannel){const A=new Uint16Array(c),o=new Uint16Array(N,f);let j=0;for(let f=0;f<P;f++)for(let P=0;P<F;P++){const c=4*(P+f*F);A[j]=o[c],A[j+1]=o[c+1],A[j+2]=o[c+2],A[j+3]=(0,H.k)(q),j+=4}return A}return new Uint16Array(N,f,c)}static _GetFloatRGBAArrayBuffer(F,P,f,c,N,q){if(t.StoreLODInAlphaChannel){const H=new Float32Array(c),A=new Float32Array(N,f);let o=0;for(let f=0;f<P;f++)for(let P=0;P<F;P++){const c=4*(P+f*F);H[o]=A[c],H[o+1]=A[c+1],H[o+2]=A[c+2],H[o+3]=q,o+=4}return H}return new Float32Array(N,f,c)}static _GetFloatAsHalfFloatRGBAArrayBuffer(F,P,f,c,N,q){const A=new Uint16Array(c),o=new Float32Array(N,f);let j=0;for(let i=0;i<P;i++)for(let P=0;P<F;P++)A[j]=(0,H.k)(o[j]),A[j+1]=(0,H.k)(o[j+1]),A[j+2]=(0,H.k)(o[j+2]),t.StoreLODInAlphaChannel?A[j+3]=(0,H.k)(q):A[j+3]=(0,H.k)(o[j+3]),j+=4;return A}static _GetFloatAsUIntRGBAArrayBuffer(F,P,f,N,q,H){const A=new Uint8Array(N),o=new Float32Array(q,f);let j=0;for(let i=0;i<P;i++)for(let P=0;P<F;P++){const f=4*(P+i*F);A[j]=255*(0,c.Clamp)(o[f]),A[j+1]=255*(0,c.Clamp)(o[f+1]),A[j+2]=255*(0,c.Clamp)(o[f+2]),t.StoreLODInAlphaChannel?A[j+3]=H:A[j+3]=255*(0,c.Clamp)(o[f+3]),j+=4}return A}static _GetHalfFloatAsUIntRGBAArrayBuffer(F,P,f,N,q,A){const o=new Uint8Array(N),j=new Uint16Array(q,f);let i=0;for(let u=0;u<P;u++)for(let P=0;P<F;P++){const f=4*(P+u*F);o[i]=255*(0,c.Clamp)((0,H.e)(j[f])),o[i+1]=255*(0,c.Clamp)((0,H.e)(j[f+1])),o[i+2]=255*(0,c.Clamp)((0,H.e)(j[f+2])),t.StoreLODInAlphaChannel?o[i+3]=A:o[i+3]=255*(0,c.Clamp)((0,H.e)(j[f+3])),i+=4}return o}static _GetRGBAArrayBuffer(F,P,f,c,N,q,H,A,o){const j=new Uint8Array(c),i=new Uint8Array(N,f);let u=0;for(let T=0;T<P;T++)for(let P=0;P<F;P++){const f=4*(P+T*F);j[u]=i[f+q],j[u+1]=i[f+H],j[u+2]=i[f+A],j[u+3]=i[f+o],u+=4}return j}static _ExtractLongWordOrder(F){return 0===F||255===F||-16777216===F?0:1+t._ExtractLongWordOrder(F>>8)}static _GetRGBArrayBuffer(F,P,f,c,N,q,H,A){const o=new Uint8Array(c),j=new Uint8Array(N,f);let i=0;for(let u=0;u<P;u++)for(let P=0;P<F;P++){const f=3*(P+u*F);o[i]=j[f+q],o[i+1]=j[f+H],o[i+2]=j[f+A],i+=3}return o}static _GetLuminanceArrayBuffer(F,P,f,c,N){const q=new Uint8Array(c),H=new Uint8Array(N,f);let A=0;for(let o=0;o<P;o++)for(let P=0;P<F;P++){const f=P+o*F;q[A]=H[f],A++}return q}static UploadDDSLevels(F,P,f,c,H,o){let j=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,C=arguments.length>7?arguments[7]:void 0,L=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=null;c.sphericalPolynomial&&(J=[]);const B=!!F.getCaps().s3tc;P.generateMipMaps=H;const z=new Int32Array(f.buffer,f.byteOffset,31);let Z,R,y,O,d,M,V,Q=0,K=0,x=1;if(542327876!==z[0])return void N.d.Error("Invalid magic number in DDS header");if(!c.isFourCC&&!c.isRGB&&!c.isLuminance)return void N.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(c.isCompressed&&!B)return void N.d.Error("Compressed textures are not supported on this platform.");let k=z[22];O=z[1]+4;let I=!1;if(c.isFourCC)switch(Z=z[21],Z){case i:x=8,K=33777;break;case u:x=16,K=33778;break;case T:x=16,K=33779;break;case 113:I=!0,k=64;break;case 116:I=!0,k=128;break;case Y:{O+=20;let F=!1;switch(c.dxgiFormat){case 10:I=!0,k=64,F=!0;break;case 2:I=!0,k=128,F=!0;break;case 88:c.isRGB=!0,c.isFourCC=!1,k=32,F=!0}if(F)break}default:return void N.d.Error(["Unsupported FourCC code:",(E=Z,String.fromCharCode(255&E,E>>8&255,E>>16&255,E>>24&255))])}var E;const r=t._ExtractLongWordOrder(z[23]),n=t._ExtractLongWordOrder(z[24]),p=t._ExtractLongWordOrder(z[25]),U=t._ExtractLongWordOrder(z[26]);I&&(K=F._getRGBABufferInternalSizedFormat(c.textureType)),M=1,z[2]&A&&!1!==H&&(M=Math.max(1,z[7]));const e=C||0,D=F.getCaps();for(let N=e;N<o;N++){for(R=z[4],y=z[3],V=0;V<M;++V){if(-1===j||j===V){const q=-1===j?V:0;if(!c.isCompressed&&c.isFourCC){P.format=5,Q=R*y*4;let c=null;if(F._badOS||F._badDesktopOS||!D.textureHalfFloat&&!D.textureFloat)128===k?(c=t._GetFloatAsUIntRGBAArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,q),J&&0==q&&J.push(t._GetFloatRGBAArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,q))):64===k&&(c=t._GetHalfFloatAsUIntRGBAArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,q),J&&0==q&&J.push(t._GetHalfFloatAsFloatRGBAArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,q))),P.type=0;else{const F=D.textureFloat&&(L&&D.textureFloatLinearFiltering||!L),N=D.textureHalfFloat&&(L&&D.textureHalfFloatLinearFiltering||!L),H=(128===k||64===k&&!N)&&F?1:(64===k||128===k&&!F)&&N?2:0;let A,o=null;if(128===k)switch(H){case 1:A=t._GetFloatRGBAArrayBuffer,o=null;break;case 2:A=t._GetFloatAsHalfFloatRGBAArrayBuffer,o=t._GetFloatRGBAArrayBuffer;break;case 0:A=t._GetFloatAsUIntRGBAArrayBuffer,o=t._GetFloatRGBAArrayBuffer}else switch(H){case 1:A=t._GetHalfFloatAsFloatRGBAArrayBuffer,o=null;break;case 2:A=t._GetHalfFloatRGBAArrayBuffer,o=t._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:A=t._GetHalfFloatAsUIntRGBAArrayBuffer,o=t._GetHalfFloatAsFloatRGBAArrayBuffer}P.type=H,c=A(R,y,f.byteOffset+O,Q,f.buffer,q),J&&0==q&&J.push(o?o(R,y,f.byteOffset+O,Q,f.buffer,q):c)}c&&F._uploadDataToTextureDirectly(P,c,N,q)}else if(c.isRGB)P.type=0,24===k?(P.format=4,Q=R*y*3,d=t._GetRGBArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,r,n,p),F._uploadDataToTextureDirectly(P,d,N,q)):(P.format=5,Q=R*y*4,d=t._GetRGBAArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer,r,n,p,U),F._uploadDataToTextureDirectly(P,d,N,q));else if(c.isLuminance){const c=F._getUnpackAlignement(),H=R;Q=Math.floor((R+c-1)/c)*c*(y-1)+H,d=t._GetLuminanceArrayBuffer(R,y,f.byteOffset+O,Q,f.buffer),P.format=1,P.type=0,F._uploadDataToTextureDirectly(P,d,N,q)}else Q=Math.max(4,R)/4*Math.max(4,y)/4*x,d=new Uint8Array(f.buffer,f.byteOffset+O,Q),P.type=0,F._uploadCompressedDataToTextureDirectly(P,K,R,y,d,N,q)}O+=k?R*y*(k/8):Q,R*=.5,y*=.5,R=Math.max(1,R),y=Math.max(1,y)}if(void 0!==C)break}J&&J.length>0?c.sphericalPolynomial=q.c.ConvertCubeMapToSphericalPolynomial({size:z[4],right:J[0],left:J[1],up:J[2],down:J[3],front:J[4],back:J[5],format:5,type:1,gammaSpace:!1}):c.sphericalPolynomial=void 0}}t.StoreLODInAlphaChannel=!1}}]);