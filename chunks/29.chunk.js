"use strict";(self.i6szn8jgzh=self.i6szn8jgzh||[]).push([[29],{13483:(b,n,i)=>{var e=i(11706),V=i(11621),Q=i(11655),U=i(11737),Y=i(11676),L=i(11721);Y.b.prototype._partialLoadFile=function(b,n,i,e){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(b,(b=>{i[n]=b,i._internalCount++,6===i._internalCount&&e(i)}),void 0,void 0,!0,((b,n)=>{V&&b&&V(b.status+" "+b.statusText,n)}))},Y.b.prototype._cascadeLoadFiles=function(b,n,i){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const V=[];V._internalCount=0;for(let Q=0;Q<6;Q++)this._partialLoadFile(i[Q],Q,V,n,e)},Y.b.prototype._cascadeLoadImgs=function(b,n,i,e){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Q=arguments.length>5?arguments[5]:void 0;const U=[];U._internalCount=0;for(let Y=0;Y<6;Y++)this._partialLoadImg(e[Y],Y,U,b,n,i,V,Q)},Y.b.prototype._partialLoadImg=function(b,n,i,e,V,Y){let L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,B=arguments.length>7?arguments[7]:void 0;const mb=(0,U.d)();(0,Q.p)(b,(b=>{i[n]=b,i._internalCount++,e&&e.removePendingData(mb),6===i._internalCount&&Y&&Y(V,i)}),((b,n)=>{e&&e.removePendingData(mb),L&&L(b,n)}),e?e.offlineProvider:null,B),e&&e.addPendingData(mb)},Y.b.prototype.createCubeTextureBase=function(b,n,i,Q){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,B=arguments.length>6?arguments[6]:void 0,mb=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,N=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,T=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,z=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,K=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,I=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,O=arguments.length>14&&void 0!==arguments[14]&&arguments[14],u=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const d=z||new e.e(this,7);d.isCube=!0,d.url=b,d.generateMipMaps=!Q,d._lodGenerationScale=Z,d._lodGenerationOffset=T,d._useSRGBBuffer=!!O&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!Q),d!==z&&(d.label=b.substring(0,60)),this._doNotHandleContextLost||(d._extension=mb,d._files=i,d._buffer=u);const G=b;this._transformTextureUrl&&!z&&(b=this._transformTextureUrl(b));const o=mb??function(b){const n=b.split("?")[0],i=n.lastIndexOf(".");return i>-1?n.substring(i).toLowerCase():""}(b),M=(0,L.d)(o),j=(b,n)=>{d.dispose(),Y?Y(b,n):b&&V.b.Warn(b)},a=(e,Y)=>{b===G?e&&j(e.status+" "+e.statusText,Y):(V.b.Warn(`Failed to load ${b}, falling back to the ${G}`),this.createCubeTextureBase(G,n,i,!!Q,U,j,B,mb,N,Z,T,d,K,I,O,u))};if(M)M.then((e=>{const V=b=>{K&&K(d,b),e.loadCubeData(b,d,N,U,((b,n)=>{j(b,n)}))};u?V(u):i&&6===i.length?e.supportCascades?this._cascadeLoadFiles(n,(b=>V(b.map((b=>new Uint8Array(b))))),i,j):j("Textures type does not support cascades."):this._loadFile(b,(b=>V(new Uint8Array(b))),void 0,void 0,!0,a)}));else{if(!i||0===i.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(n,d,((b,n)=>{I&&I(b,n)}),i,j)}return this._internalTexturesCache.push(d),d}},12298:(b,n,i)=>{i.d(n,{b:()=>B});var e=i(11778),V=i(11796),Q=i(11960),U=i(11786),Y=i(11822);class L{constructor(b,n,i,e){this.name=b,this.worldAxisForNormal=n,this.worldAxisForFileX=i,this.worldAxisForFileY=e}}class B{static ConvertCubeMapTextureToSphericalPolynomial(b){var n;if(!b.isCube)return null;null===(n=b.ab())||void 0===n||n.getEngine().flushFramebuffer();const i=b.getSize().width,e=b.readPixels(0,void 0,void 0,!1),V=b.readPixels(1,void 0,void 0,!1);let Q,U;b.isRenderTarget?(Q=b.readPixels(3,void 0,void 0,!1),U=b.readPixels(2,void 0,void 0,!1)):(Q=b.readPixels(2,void 0,void 0,!1),U=b.readPixels(3,void 0,void 0,!1));const Y=b.readPixels(4,void 0,void 0,!1),L=b.readPixels(5,void 0,void 0,!1),B=b.gammaSpace;let mb=0;return 1!=b.textureType&&2!=b.textureType||(mb=1),new Promise((b=>{Promise.all([V,e,Q,U,Y,L]).then((n=>{let[e,V,Q,U,Y,L]=n;const N={size:i,right:V,left:e,up:Q,down:U,front:Y,back:L,format:5,type:mb,gammaSpace:B};b(this.ConvertCubeMapToSphericalPolynomial(N))}))}))}static _AreaElement(b,n){return Math.atan2(b*n,Math.sqrt(b*b+n*n+1))}static ConvertCubeMapToSphericalPolynomial(b){const n=new Q.e;let i=0;const e=2/b.size,L=e,B=.5*e,mb=B-1;for(let Q=0;Q<6;Q++){const N=this._FileFaces[Q],Z=b[N.name];let T=mb;const z=5===b.format?4:3;for(let Q=0;Q<b.size;Q++){let K=mb;for(let L=0;L<b.size;L++){const mb=N.worldAxisForFileX.scale(K).add(N.worldAxisForFileY.scale(T)).add(N.worldAxisForNormal);mb.normalize();const I=this._AreaElement(K-B,T-B)-this._AreaElement(K-B,T+B)-this._AreaElement(K+B,T-B)+this._AreaElement(K+B,T+B);let O=Z[Q*b.size*z+L*z+0],u=Z[Q*b.size*z+L*z+1],d=Z[Q*b.size*z+L*z+2];isNaN(O)&&(O=0),isNaN(u)&&(u=0),isNaN(d)&&(d=0),0===b.type&&(O/=255,u/=255,d/=255),b.gammaSpace&&(O=Math.pow((0,V.Clamp)(O),U.j),u=Math.pow((0,V.Clamp)(u),U.j),d=Math.pow((0,V.Clamp)(d),U.j));const G=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const b=Math.max(O,u,d);if(b>G){const n=G/b;O*=n,u*=n,d*=n}}else O=(0,V.Clamp)(O,0,G),u=(0,V.Clamp)(u,0,G),d=(0,V.Clamp)(d,0,G);const o=new Y.Mn(O,u,d);n.addLight(mb,o,I),i+=I,K+=e}T+=L}}const N=6*(4*Math.PI)/6/i;return n.scaleInPlace(N),n.convertIncidentRadianceToIrradiance(),n.convertIrradianceToLambertianRadiance(),Q.h.FromHarmonics(n)}}B._FileFaces=[new L("right",new e.On(1,0,0),new e.On(0,0,-1),new e.On(0,-1,0)),new L("left",new e.On(-1,0,0),new e.On(0,0,1),new e.On(0,-1,0)),new L("up",new e.On(0,1,0),new e.On(1,0,0),new e.On(0,0,1)),new L("down",new e.On(0,-1,0),new e.On(1,0,0),new e.On(0,0,-1)),new L("front",new e.On(0,0,1),new e.On(1,0,0),new e.On(0,-1,0)),new L("back",new e.On(0,0,-1),new e.On(-1,0,0),new e.On(0,-1,0))],B.MAX_HDRI_VALUE=4096,B.PRESERVE_CLAMPED_COLORS=!1},14301:(b,n,i)=>{i.d(n,{DDSTools:()=>z});var e=i(11796),V=i(11621),Q=i(12298),U=i(11994);i(13483);const Y=131072,L=131072;function B(b){return b.charCodeAt(0)+(b.charCodeAt(1)<<8)+(b.charCodeAt(2)<<16)+(b.charCodeAt(3)<<24)}const mb=B("DXT1"),N=B("DXT3"),Z=B("DXT5"),T=B("DX10");class z{static GetDDSInfo(b){const n=new Int32Array(b.buffer,b.byteOffset,31),i=new Int32Array(b.buffer,b.byteOffset,35);let e=1;n[2]&Y&&(e=Math.max(1,n[7]));const V=n[21],Q=V===T?i[32]:0;let U=0;switch(V){case 113:U=2;break;case 116:U=1;break;case T:if(10===Q){U=2;break}if(2===Q){U=1;break}}return{width:n[4],height:n[3],mipmapCount:e,isFourCC:4===(4&n[20]),isRGB:64===(64&n[20]),isLuminance:(n[20]&L)===L,isCube:512===(512&n[28]),isCompressed:V===mb||V===N||V===Z,dxgiFormat:Q,textureType:U}}static _GetHalfFloatAsFloatRGBAArrayBuffer(b,n,i,e,V,Q){const Y=new Float32Array(e),L=new Uint16Array(V,i);let B=0;for(let mb=0;mb<n;mb++)for(let n=0;n<b;n++){const i=4*(n+mb*b);Y[B]=(0,U.e)(L[i]),Y[B+1]=(0,U.e)(L[i+1]),Y[B+2]=(0,U.e)(L[i+2]),z.StoreLODInAlphaChannel?Y[B+3]=Q:Y[B+3]=(0,U.e)(L[i+3]),B+=4}return Y}static _GetHalfFloatRGBAArrayBuffer(b,n,i,e,V,Q){if(z.StoreLODInAlphaChannel){const Y=new Uint16Array(e),L=new Uint16Array(V,i);let B=0;for(let i=0;i<n;i++)for(let n=0;n<b;n++){const e=4*(n+i*b);Y[B]=L[e],Y[B+1]=L[e+1],Y[B+2]=L[e+2],Y[B+3]=(0,U.o)(Q),B+=4}return Y}return new Uint16Array(V,i,e)}static _GetFloatRGBAArrayBuffer(b,n,i,e,V,Q){if(z.StoreLODInAlphaChannel){const U=new Float32Array(e),Y=new Float32Array(V,i);let L=0;for(let i=0;i<n;i++)for(let n=0;n<b;n++){const e=4*(n+i*b);U[L]=Y[e],U[L+1]=Y[e+1],U[L+2]=Y[e+2],U[L+3]=Q,L+=4}return U}return new Float32Array(V,i,e)}static _GetFloatAsHalfFloatRGBAArrayBuffer(b,n,i,e,V,Q){const Y=new Uint16Array(e),L=new Float32Array(V,i);let B=0;for(let mb=0;mb<n;mb++)for(let n=0;n<b;n++)Y[B]=(0,U.o)(L[B]),Y[B+1]=(0,U.o)(L[B+1]),Y[B+2]=(0,U.o)(L[B+2]),z.StoreLODInAlphaChannel?Y[B+3]=(0,U.o)(Q):Y[B+3]=(0,U.o)(L[B+3]),B+=4;return Y}static _GetFloatAsUIntRGBAArrayBuffer(b,n,i,V,Q,U){const Y=new Uint8Array(V),L=new Float32Array(Q,i);let B=0;for(let mb=0;mb<n;mb++)for(let n=0;n<b;n++){const i=4*(n+mb*b);Y[B]=255*(0,e.Clamp)(L[i]),Y[B+1]=255*(0,e.Clamp)(L[i+1]),Y[B+2]=255*(0,e.Clamp)(L[i+2]),z.StoreLODInAlphaChannel?Y[B+3]=U:Y[B+3]=255*(0,e.Clamp)(L[i+3]),B+=4}return Y}static _GetHalfFloatAsUIntRGBAArrayBuffer(b,n,i,V,Q,Y){const L=new Uint8Array(V),B=new Uint16Array(Q,i);let mb=0;for(let N=0;N<n;N++)for(let n=0;n<b;n++){const i=4*(n+N*b);L[mb]=255*(0,e.Clamp)((0,U.e)(B[i])),L[mb+1]=255*(0,e.Clamp)((0,U.e)(B[i+1])),L[mb+2]=255*(0,e.Clamp)((0,U.e)(B[i+2])),z.StoreLODInAlphaChannel?L[mb+3]=Y:L[mb+3]=255*(0,e.Clamp)((0,U.e)(B[i+3])),mb+=4}return L}static _GetRGBAArrayBuffer(b,n,i,e,V,Q,U,Y,L){const B=new Uint8Array(e),mb=new Uint8Array(V,i);let N=0;for(let Z=0;Z<n;Z++)for(let n=0;n<b;n++){const i=4*(n+Z*b);B[N]=mb[i+Q],B[N+1]=mb[i+U],B[N+2]=mb[i+Y],B[N+3]=mb[i+L],N+=4}return B}static _ExtractLongWordOrder(b){return 0===b||255===b||-16777216===b?0:1+z._ExtractLongWordOrder(b>>8)}static _GetRGBArrayBuffer(b,n,i,e,V,Q,U,Y){const L=new Uint8Array(e),B=new Uint8Array(V,i);let mb=0;for(let N=0;N<n;N++)for(let n=0;n<b;n++){const i=3*(n+N*b);L[mb]=B[i+Q],L[mb+1]=B[i+U],L[mb+2]=B[i+Y],mb+=3}return L}static _GetLuminanceArrayBuffer(b,n,i,e,V){const Q=new Uint8Array(e),U=new Uint8Array(V,i);let Y=0;for(let L=0;L<n;L++)for(let n=0;n<b;n++){const i=n+L*b;Q[Y]=U[i],Y++}return Q}static UploadDDSLevels(b,n,i,e,U,L){let B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,K=arguments.length>7?arguments[7]:void 0,I=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],O=null;e.sphericalPolynomial&&(O=[]);const u=!!b.getCaps().s3tc;n.generateMipMaps=U;const d=new Int32Array(i.buffer,i.byteOffset,31);let G,o,M,j,a,D,x,y=0,s=0,A=1;if(542327876!==d[0])return void V.b.Error("Invalid magic number in DDS header");if(!e.isFourCC&&!e.isRGB&&!e.isLuminance)return void V.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(e.isCompressed&&!u)return void V.b.Error("Compressed textures are not supported on this platform.");let E=d[22];j=d[1]+4;let C=!1;if(e.isFourCC)switch(G=d[21],G){case mb:A=8,s=33777;break;case N:A=16,s=33778;break;case Z:A=16,s=33779;break;case 113:C=!0,E=64;break;case 116:C=!0,E=128;break;case T:{j+=20;let b=!1;switch(e.dxgiFormat){case 10:C=!0,E=64,b=!0;break;case 2:C=!0,E=128,b=!0;break;case 88:e.isRGB=!0,e.isFourCC=!1,E=32,b=!0}if(b)break}default:return void V.b.Error(["Unsupported FourCC code:",(t=G,String.fromCharCode(255&t,t>>8&255,t>>16&255,t>>24&255))])}var t;const w=z._ExtractLongWordOrder(d[23]),h=z._ExtractLongWordOrder(d[24]),W=z._ExtractLongWordOrder(d[25]),J=z._ExtractLongWordOrder(d[26]);C&&(s=b._getRGBABufferInternalSizedFormat(e.textureType)),D=1,d[2]&Y&&!1!==U&&(D=Math.max(1,d[7]));const R=K||0,k=b.getCaps();for(let V=R;V<L;V++){for(o=d[4],M=d[3],x=0;x<D;++x){if(-1===B||B===x){const Q=-1===B?x:0;if(!e.isCompressed&&e.isFourCC){n.format=5,y=o*M*4;let e=null;if(b._badOS||b._badDesktopOS||!k.textureHalfFloat&&!k.textureFloat)128===E?(e=z._GetFloatAsUIntRGBAArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,Q),O&&0==Q&&O.push(z._GetFloatRGBAArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,Q))):64===E&&(e=z._GetHalfFloatAsUIntRGBAArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,Q),O&&0==Q&&O.push(z._GetHalfFloatAsFloatRGBAArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,Q))),n.type=0;else{const b=k.textureFloat&&(I&&k.textureFloatLinearFiltering||!I),V=k.textureHalfFloat&&(I&&k.textureHalfFloatLinearFiltering||!I),U=(128===E||64===E&&!V)&&b?1:(64===E||128===E&&!b)&&V?2:0;let Y,L=null;if(128===E)switch(U){case 1:Y=z._GetFloatRGBAArrayBuffer,L=null;break;case 2:Y=z._GetFloatAsHalfFloatRGBAArrayBuffer,L=z._GetFloatRGBAArrayBuffer;break;case 0:Y=z._GetFloatAsUIntRGBAArrayBuffer,L=z._GetFloatRGBAArrayBuffer}else switch(U){case 1:Y=z._GetHalfFloatAsFloatRGBAArrayBuffer,L=null;break;case 2:Y=z._GetHalfFloatRGBAArrayBuffer,L=z._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:Y=z._GetHalfFloatAsUIntRGBAArrayBuffer,L=z._GetHalfFloatAsFloatRGBAArrayBuffer}n.type=U,e=Y(o,M,i.byteOffset+j,y,i.buffer,Q),O&&0==Q&&O.push(L?L(o,M,i.byteOffset+j,y,i.buffer,Q):e)}e&&b._uploadDataToTextureDirectly(n,e,V,Q)}else if(e.isRGB)n.type=0,24===E?(n.format=4,y=o*M*3,a=z._GetRGBArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,w,h,W),b._uploadDataToTextureDirectly(n,a,V,Q)):(n.format=5,y=o*M*4,a=z._GetRGBAArrayBuffer(o,M,i.byteOffset+j,y,i.buffer,w,h,W,J),b._uploadDataToTextureDirectly(n,a,V,Q));else if(e.isLuminance){const e=b._getUnpackAlignement(),U=o;y=Math.floor((o+e-1)/e)*e*(M-1)+U,a=z._GetLuminanceArrayBuffer(o,M,i.byteOffset+j,y,i.buffer),n.format=1,n.type=0,b._uploadDataToTextureDirectly(n,a,V,Q)}else y=Math.max(4,o)/4*Math.max(4,M)/4*A,a=new Uint8Array(i.buffer,i.byteOffset+j,y),n.type=0,b._uploadCompressedDataToTextureDirectly(n,s,o,M,a,V,Q)}j+=E?o*M*(E/8):y,o*=.5,M*=.5,o=Math.max(1,o),M=Math.max(1,M)}if(void 0!==K)break}O&&O.length>0?e.sphericalPolynomial=Q.b.ConvertCubeMapToSphericalPolynomial({size:d[4],right:O[0],left:O[1],up:O[2],down:O[3],front:O[4],back:O[5],format:5,type:1,gammaSpace:!1}):e.sphericalPolynomial=void 0}}z.StoreLODInAlphaChannel=!1}}]);