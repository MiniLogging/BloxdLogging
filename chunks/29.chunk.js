"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[29],{13375:(e,E,H)=>{var N=H(11660),u=H(11548),z=H(11587),P=H(11693),M=H(11618),D=H(11674);M.c.prototype._partialLoadFile=function(e,E,H,N){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(e,(e=>{H[E]=e,H._internalCount++,6===H._internalCount&&N(H)}),void 0,void 0,!0,((e,E)=>{u&&e&&u(e.status+" "+e.statusText,E)}))},M.c.prototype._cascadeLoadFiles=function(e,E,H){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const u=[];u._internalCount=0;for(let z=0;z<6;z++)this._partialLoadFile(H[z],z,u,E,N)},M.c.prototype._cascadeLoadImgs=function(e,E,H,N){let u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,z=arguments.length>5?arguments[5]:void 0;const P=[];P._internalCount=0;for(let M=0;M<6;M++)this._partialLoadImg(N[M],M,P,e,E,H,u,z)},M.c.prototype._partialLoadImg=function(e,E,H,N,u,M){let D=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,A=arguments.length>7?arguments[7]:void 0;const C=(0,P.e)();(0,z.w)(e,(e=>{H[E]=e,H._internalCount++,N&&N.removePendingData(C),6===H._internalCount&&M&&M(u,H)}),((e,E)=>{N&&N.removePendingData(C),D&&D(e,E)}),N?N.offlineProvider:null,A),N&&N.addPendingData(C)},M.c.prototype.createCubeTextureBase=function(e,E,H,z){let P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,A=arguments.length>6?arguments[6]:void 0,C=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,i=arguments.length>8&&void 0!==arguments[8]&&arguments[8],V=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,U=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,j=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,F=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,h=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,S=arguments.length>14&&void 0!==arguments[14]&&arguments[14],X=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const a=j||new N.e(this,7);a.isCube=!0,a.url=e,a.generateMipMaps=!z,a._lodGenerationScale=V,a._lodGenerationOffset=U,a._useSRGBBuffer=!!S&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!z),a!==j&&(a.label=e.substring(0,60)),this._doNotHandleContextLost||(a._extension=C,a._files=H,a._buffer=X);const W=e;this._transformTextureUrl&&!j&&(e=this._transformTextureUrl(e));const r=C??function(e){const E=e.split("?")[0],H=E.lastIndexOf(".");return H>-1?E.substring(H).toLowerCase():""}(e),Y=(0,D.c)(r),f=(e,E)=>{a.dispose(),M?M(e,E):e&&u.d.Warn(e)},w=(N,M)=>{e===W?N&&f(N.status+" "+N.statusText,M):(u.d.Warn(`Failed to load ${e}, falling back to the ${W}`),this.createCubeTextureBase(W,E,H,!!z,P,f,A,C,i,V,U,a,F,h,S,X))};if(Y)Y.then((N=>{const u=e=>{F&&F(a,e),N.loadCubeData(e,a,i,P,((e,E)=>{f(e,E)}))};X?u(X):H&&6===H.length?N.supportCascades?this._cascadeLoadFiles(E,(e=>u(e.map((e=>new Uint8Array(e))))),H,f):f("Textures type does not support cascades."):this._loadFile(e,(e=>u(new Uint8Array(e))),void 0,void 0,!0,w)}));else{if(!H||0===H.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(E,a,((e,E)=>{h&&h(e,E)}),H,f)}return this._internalTexturesCache.push(a),a}},12231:(e,E,H)=>{H.d(E,{e:()=>A});var N=H(11738),u=H(11756),z=H(11924),P=H(11746),M=H(11789);class D{constructor(e,E,H,N){this.name=e,this.worldAxisForNormal=E,this.worldAxisForFileX=H,this.worldAxisForFileY=N}}class A{static ConvertCubeMapTextureToSphericalPolynomial(e){var E;if(!e.isCube)return null;null===(E=e.fe())||void 0===E||E.getEngine().flushFramebuffer();const H=e.getSize().width,N=e.readPixels(0,void 0,void 0,!1),u=e.readPixels(1,void 0,void 0,!1);let z,P;e.isRenderTarget?(z=e.readPixels(3,void 0,void 0,!1),P=e.readPixels(2,void 0,void 0,!1)):(z=e.readPixels(2,void 0,void 0,!1),P=e.readPixels(3,void 0,void 0,!1));const M=e.readPixels(4,void 0,void 0,!1),D=e.readPixels(5,void 0,void 0,!1),A=e.gammaSpace;let C=0;return 1!=e.textureType&&2!=e.textureType||(C=1),new Promise((e=>{Promise.all([u,N,z,P,M,D]).then((E=>{let[N,u,z,P,M,D]=E;const i={size:H,right:u,left:N,up:z,down:P,front:M,back:D,format:5,type:C,gammaSpace:A};e(this.ConvertCubeMapToSphericalPolynomial(i))}))}))}static _AreaElement(e,E){return Math.atan2(e*E,Math.sqrt(e*e+E*E+1))}static ConvertCubeMapToSphericalPolynomial(e){const E=new z.b;let H=0;const N=2/e.size,D=N,A=.5*N,C=A-1;for(let z=0;z<6;z++){const i=this._FileFaces[z],V=e[i.name];let U=C;const j=5===e.format?4:3;for(let z=0;z<e.size;z++){let F=C;for(let D=0;D<e.size;D++){const C=i.worldAxisForFileX.scale(F).add(i.worldAxisForFileY.scale(U)).add(i.worldAxisForNormal);C.normalize();const h=this._AreaElement(F-A,U-A)-this._AreaElement(F-A,U+A)-this._AreaElement(F+A,U-A)+this._AreaElement(F+A,U+A);let S=V[z*e.size*j+D*j+0],X=V[z*e.size*j+D*j+1],a=V[z*e.size*j+D*j+2];isNaN(S)&&(S=0),isNaN(X)&&(X=0),isNaN(a)&&(a=0),0===e.type&&(S/=255,X/=255,a/=255),e.gammaSpace&&(S=Math.pow((0,u.Clamp)(S),P.j),X=Math.pow((0,u.Clamp)(X),P.j),a=Math.pow((0,u.Clamp)(a),P.j));const W=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const e=Math.max(S,X,a);if(e>W){const E=W/e;S*=E,X*=E,a*=E}}else S=(0,u.Clamp)(S,0,W),X=(0,u.Clamp)(X,0,W),a=(0,u.Clamp)(a,0,W);const r=new M.XE(S,X,a);E.addLight(C,r,h),H+=h,F+=N}U+=D}}const i=6*(4*Math.PI)/6/H;return E.scaleInPlace(i),E.convertIncidentRadianceToIrradiance(),E.convertIrradianceToLambertianRadiance(),z.f.FromHarmonics(E)}}A._FileFaces=[new D("right",new N.jE(1,0,0),new N.jE(0,0,-1),new N.jE(0,-1,0)),new D("left",new N.jE(-1,0,0),new N.jE(0,0,1),new N.jE(0,-1,0)),new D("up",new N.jE(0,1,0),new N.jE(1,0,0),new N.jE(0,0,1)),new D("down",new N.jE(0,-1,0),new N.jE(1,0,0),new N.jE(0,0,-1)),new D("front",new N.jE(0,0,1),new N.jE(1,0,0),new N.jE(0,-1,0)),new D("back",new N.jE(0,0,-1),new N.jE(-1,0,0),new N.jE(0,-1,0))],A.MAX_HDRI_VALUE=4096,A.PRESERVE_CLAMPED_COLORS=!1},14132:(e,E,H)=>{H.d(E,{DDSTools:()=>j});var N=H(11756),u=H(11548),z=H(12231),P=H(11952);H(13375);const M=131072,D=131072;function A(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}const C=A("DXT1"),i=A("DXT3"),V=A("DXT5"),U=A("DX10");class j{static GetDDSInfo(e){const E=new Int32Array(e.buffer,e.byteOffset,31),H=new Int32Array(e.buffer,e.byteOffset,35);let N=1;E[2]&M&&(N=Math.max(1,E[7]));const u=E[21],z=u===U?H[32]:0;let P=0;switch(u){case 113:P=2;break;case 116:P=1;break;case U:if(10===z){P=2;break}if(2===z){P=1;break}}return{width:E[4],height:E[3],mipmapCount:N,isFourCC:4===(4&E[20]),isRGB:64===(64&E[20]),isLuminance:(E[20]&D)===D,isCube:512===(512&E[28]),isCompressed:u===C||u===i||u===V,dxgiFormat:z,textureType:P}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,E,H,N,u,z){const M=new Float32Array(N),D=new Uint16Array(u,H);let A=0;for(let C=0;C<E;C++)for(let E=0;E<e;E++){const H=4*(E+C*e);M[A]=(0,P.f)(D[H]),M[A+1]=(0,P.f)(D[H+1]),M[A+2]=(0,P.f)(D[H+2]),j.StoreLODInAlphaChannel?M[A+3]=z:M[A+3]=(0,P.f)(D[H+3]),A+=4}return M}static _GetHalfFloatRGBAArrayBuffer(e,E,H,N,u,z){if(j.StoreLODInAlphaChannel){const M=new Uint16Array(N),D=new Uint16Array(u,H);let A=0;for(let H=0;H<E;H++)for(let E=0;E<e;E++){const N=4*(E+H*e);M[A]=D[N],M[A+1]=D[N+1],M[A+2]=D[N+2],M[A+3]=(0,P.k)(z),A+=4}return M}return new Uint16Array(u,H,N)}static _GetFloatRGBAArrayBuffer(e,E,H,N,u,z){if(j.StoreLODInAlphaChannel){const P=new Float32Array(N),M=new Float32Array(u,H);let D=0;for(let H=0;H<E;H++)for(let E=0;E<e;E++){const N=4*(E+H*e);P[D]=M[N],P[D+1]=M[N+1],P[D+2]=M[N+2],P[D+3]=z,D+=4}return P}return new Float32Array(u,H,N)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,E,H,N,u,z){const M=new Uint16Array(N),D=new Float32Array(u,H);let A=0;for(let C=0;C<E;C++)for(let E=0;E<e;E++)M[A]=(0,P.k)(D[A]),M[A+1]=(0,P.k)(D[A+1]),M[A+2]=(0,P.k)(D[A+2]),j.StoreLODInAlphaChannel?M[A+3]=(0,P.k)(z):M[A+3]=(0,P.k)(D[A+3]),A+=4;return M}static _GetFloatAsUIntRGBAArrayBuffer(e,E,H,u,z,P){const M=new Uint8Array(u),D=new Float32Array(z,H);let A=0;for(let C=0;C<E;C++)for(let E=0;E<e;E++){const H=4*(E+C*e);M[A]=255*(0,N.Clamp)(D[H]),M[A+1]=255*(0,N.Clamp)(D[H+1]),M[A+2]=255*(0,N.Clamp)(D[H+2]),j.StoreLODInAlphaChannel?M[A+3]=P:M[A+3]=255*(0,N.Clamp)(D[H+3]),A+=4}return M}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,E,H,u,z,M){const D=new Uint8Array(u),A=new Uint16Array(z,H);let C=0;for(let i=0;i<E;i++)for(let E=0;E<e;E++){const H=4*(E+i*e);D[C]=255*(0,N.Clamp)((0,P.f)(A[H])),D[C+1]=255*(0,N.Clamp)((0,P.f)(A[H+1])),D[C+2]=255*(0,N.Clamp)((0,P.f)(A[H+2])),j.StoreLODInAlphaChannel?D[C+3]=M:D[C+3]=255*(0,N.Clamp)((0,P.f)(A[H+3])),C+=4}return D}static _GetRGBAArrayBuffer(e,E,H,N,u,z,P,M,D){const A=new Uint8Array(N),C=new Uint8Array(u,H);let i=0;for(let V=0;V<E;V++)for(let E=0;E<e;E++){const H=4*(E+V*e);A[i]=C[H+z],A[i+1]=C[H+P],A[i+2]=C[H+M],A[i+3]=C[H+D],i+=4}return A}static _ExtractLongWordOrder(e){return 0===e||255===e||-16777216===e?0:1+j._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,E,H,N,u,z,P,M){const D=new Uint8Array(N),A=new Uint8Array(u,H);let C=0;for(let i=0;i<E;i++)for(let E=0;E<e;E++){const H=3*(E+i*e);D[C]=A[H+z],D[C+1]=A[H+P],D[C+2]=A[H+M],C+=3}return D}static _GetLuminanceArrayBuffer(e,E,H,N,u){const z=new Uint8Array(N),P=new Uint8Array(u,H);let M=0;for(let D=0;D<E;D++)for(let E=0;E<e;E++){const H=E+D*e;z[M]=P[H],M++}return z}static UploadDDSLevels(e,E,H,N,P,D){let A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,F=arguments.length>7?arguments[7]:void 0,h=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],S=null;N.sphericalPolynomial&&(S=[]);const X=!!e.getCaps().s3tc;E.generateMipMaps=P;const a=new Int32Array(H.buffer,H.byteOffset,31);let W,r,Y,f,w,s,p,o=0,y=0,b=1;if(542327876!==a[0])return void u.d.Error("Invalid magic number in DDS header");if(!N.isFourCC&&!N.isRGB&&!N.isLuminance)return void u.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(N.isCompressed&&!X)return void u.d.Error("Compressed textures are not supported on this platform.");let K=a[22];f=a[1]+4;let l=!1;if(N.isFourCC)switch(W=a[21],W){case C:b=8,y=33777;break;case i:b=16,y=33778;break;case V:b=16,y=33779;break;case 113:l=!0,K=64;break;case 116:l=!0,K=128;break;case U:{f+=20;let e=!1;switch(N.dxgiFormat){case 10:l=!0,K=64,e=!0;break;case 2:l=!0,K=128,e=!0;break;case 88:N.isRGB=!0,N.isFourCC=!1,K=32,e=!0}if(e)break}default:return void u.d.Error(["Unsupported FourCC code:",(O=W,String.fromCharCode(255&O,O>>8&255,O>>16&255,O>>24&255))])}var O;const v=j._ExtractLongWordOrder(a[23]),R=j._ExtractLongWordOrder(a[24]),T=j._ExtractLongWordOrder(a[25]),L=j._ExtractLongWordOrder(a[26]);l&&(y=e._getRGBABufferInternalSizedFormat(N.textureType)),s=1,a[2]&M&&!1!==P&&(s=Math.max(1,a[7]));const d=F||0,G=e.getCaps();for(let u=d;u<D;u++){for(r=a[4],Y=a[3],p=0;p<s;++p){if(-1===A||A===p){const z=-1===A?p:0;if(!N.isCompressed&&N.isFourCC){E.format=5,o=r*Y*4;let N=null;if(e._badOS||e._badDesktopOS||!G.textureHalfFloat&&!G.textureFloat)128===K?(N=j._GetFloatAsUIntRGBAArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,z),S&&0==z&&S.push(j._GetFloatRGBAArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,z))):64===K&&(N=j._GetHalfFloatAsUIntRGBAArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,z),S&&0==z&&S.push(j._GetHalfFloatAsFloatRGBAArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,z))),E.type=0;else{const e=G.textureFloat&&(h&&G.textureFloatLinearFiltering||!h),u=G.textureHalfFloat&&(h&&G.textureHalfFloatLinearFiltering||!h),P=(128===K||64===K&&!u)&&e?1:(64===K||128===K&&!e)&&u?2:0;let M,D=null;if(128===K)switch(P){case 1:M=j._GetFloatRGBAArrayBuffer,D=null;break;case 2:M=j._GetFloatAsHalfFloatRGBAArrayBuffer,D=j._GetFloatRGBAArrayBuffer;break;case 0:M=j._GetFloatAsUIntRGBAArrayBuffer,D=j._GetFloatRGBAArrayBuffer}else switch(P){case 1:M=j._GetHalfFloatAsFloatRGBAArrayBuffer,D=null;break;case 2:M=j._GetHalfFloatRGBAArrayBuffer,D=j._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:M=j._GetHalfFloatAsUIntRGBAArrayBuffer,D=j._GetHalfFloatAsFloatRGBAArrayBuffer}E.type=P,N=M(r,Y,H.byteOffset+f,o,H.buffer,z),S&&0==z&&S.push(D?D(r,Y,H.byteOffset+f,o,H.buffer,z):N)}N&&e._uploadDataToTextureDirectly(E,N,u,z)}else if(N.isRGB)E.type=0,24===K?(E.format=4,o=r*Y*3,w=j._GetRGBArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,v,R,T),e._uploadDataToTextureDirectly(E,w,u,z)):(E.format=5,o=r*Y*4,w=j._GetRGBAArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer,v,R,T,L),e._uploadDataToTextureDirectly(E,w,u,z));else if(N.isLuminance){const N=e._getUnpackAlignement(),P=r;o=Math.floor((r+N-1)/N)*N*(Y-1)+P,w=j._GetLuminanceArrayBuffer(r,Y,H.byteOffset+f,o,H.buffer),E.format=1,E.type=0,e._uploadDataToTextureDirectly(E,w,u,z)}else o=Math.max(4,r)/4*Math.max(4,Y)/4*b,w=new Uint8Array(H.buffer,H.byteOffset+f,o),E.type=0,e._uploadCompressedDataToTextureDirectly(E,y,r,Y,w,u,z)}f+=K?r*Y*(K/8):o,r*=.5,Y*=.5,r=Math.max(1,r),Y=Math.max(1,Y)}if(void 0!==F)break}S&&S.length>0?N.sphericalPolynomial=z.e.ConvertCubeMapToSphericalPolynomial({size:a[4],right:S[0],left:S[1],up:S[2],down:S[3],front:S[4],back:S[5],format:5,type:1,gammaSpace:!1}):N.sphericalPolynomial=void 0}}j.StoreLODInAlphaChannel=!1}}]);