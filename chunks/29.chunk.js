"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[29],{14250:(I,g,b)=>{var e=b(12529),c=b(12420),z=b(12456),M=b(12561),J=b(12497),o=b(12544);J.c.prototype._partialLoadFile=function(I,g,b,e){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(I,(I=>{b[g]=I,b._internalCount++,6===b._internalCount&&e(b)}),void 0,void 0,!0,((I,g)=>{c&&I&&c(I.status+" "+I.statusText,g)}))},J.c.prototype._cascadeLoadFiles=function(I,g,b){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const c=[];c._internalCount=0;for(let z=0;z<6;z++)this._partialLoadFile(b[z],z,c,g,e)},J.c.prototype._cascadeLoadImgs=function(I,g,b,e){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,z=arguments.length>5?arguments[5]:void 0;const M=[];M._internalCount=0;for(let J=0;J<6;J++)this._partialLoadImg(e[J],J,M,I,g,b,c,z)},J.c.prototype._partialLoadImg=function(I,g,b,e,c,J){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,n=arguments.length>7?arguments[7]:void 0;const G=(0,M.e)();(0,z.u)(I,(I=>{b[g]=I,b._internalCount++,e&&e.removePendingData(G),6===b._internalCount&&J&&J(c,b)}),((I,g)=>{e&&e.removePendingData(G),o&&o(I,g)}),e?e.offlineProvider:null,n),e&&e.addPendingData(G)},J.c.prototype.createCubeTextureBase=function(I,g,b,z){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,J=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,n=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,D=arguments.length>8&&void 0!==arguments[8]&&arguments[8],p=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Z=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,k=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,S=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,f=arguments.length>14&&void 0!==arguments[14]&&arguments[14],V=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const a=Z||new e.e(this,7);a.isCube=!0,a.url=I,a.generateMipMaps=!z,a._lodGenerationScale=p,a._lodGenerationOffset=x,a._useSRGBBuffer=!!f&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!z),a!==Z&&(a.label=I.substring(0,60)),this._doNotHandleContextLost||(a._extension=G,a._files=b,a._buffer=V);const v=I;this._transformTextureUrl&&!Z&&(I=this._transformTextureUrl(I));const X=G??function(I){const g=I.split("?")[0],b=g.lastIndexOf(".");return b>-1?g.substring(b).toLowerCase():""}(I),R=(0,o.b)(X),E=(I,g)=>{a.dispose(),J?J(I,g):I&&c.b.Warn(I)},mI=(e,J)=>{I===v?e&&E(e.status+" "+e.statusText,J):(c.b.Warn(`Failed to load ${I}, falling back to the ${v}`),this.createCubeTextureBase(v,g,b,!!z,M,E,n,G,D,p,x,a,k,S,f,V))};if(R)R.then((e=>{const c=I=>{k&&k(a,I),e.loadCubeData(I,a,D,M,((I,g)=>{E(I,g)}))};V?c(V):b&&6===b.length?e.supportCascades?this._cascadeLoadFiles(g,(I=>c(I.map((I=>new Uint8Array(I))))),b,E):E("Textures type does not support cascades."):this._loadFile(I,(I=>c(new Uint8Array(I))),void 0,void 0,!0,mI)}));else{if(!b||0===b.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(g,a,((I,g)=>{S&&S(I,g)}),b,E)}return this._internalTexturesCache.push(a),a}},13095:(I,g,b)=>{b.d(g,{b:()=>n});var e=b(12590),c=b(12610),z=b(12769),M=b(12597),J=b(12637);class o{constructor(I,g,b,e){this.name=I,this.worldAxisForNormal=g,this.worldAxisForFileX=b,this.worldAxisForFileY=e}}class n{static ConvertCubeMapTextureToSphericalPolynomial(I){var g;if(!I.isCube)return null;null===(g=I.EI())||void 0===g||g.getEngine().flushFramebuffer();const b=I.getSize().width,e=I.readPixels(0,void 0,void 0,!1),c=I.readPixels(1,void 0,void 0,!1);let z,M;I.isRenderTarget?(z=I.readPixels(3,void 0,void 0,!1),M=I.readPixels(2,void 0,void 0,!1)):(z=I.readPixels(2,void 0,void 0,!1),M=I.readPixels(3,void 0,void 0,!1));const J=I.readPixels(4,void 0,void 0,!1),o=I.readPixels(5,void 0,void 0,!1),n=I.gammaSpace;let G=0;return 1!=I.textureType&&2!=I.textureType||(G=1),new Promise((I=>{Promise.all([c,e,z,M,J,o]).then((g=>{let[e,c,z,M,J,o]=g;const D={size:b,right:c,left:e,up:z,down:M,front:J,back:o,format:5,type:G,gammaSpace:n};I(this.ConvertCubeMapToSphericalPolynomial(D))}))}))}static _AreaElement(I,g){return Math.atan2(I*g,Math.sqrt(I*I+g*g+1))}static ConvertCubeMapToSphericalPolynomial(I){const g=new z.e;let b=0;const e=2/I.size,o=e,n=.5*e,G=n-1;for(let z=0;z<6;z++){const D=this._FileFaces[z],p=I[D.name];let x=G;const Z=5===I.format?4:3;for(let z=0;z<I.size;z++){let k=G;for(let o=0;o<I.size;o++){const G=D.worldAxisForFileX.scale(k).add(D.worldAxisForFileY.scale(x)).add(D.worldAxisForNormal);G.normalize();const S=this._AreaElement(k-n,x-n)-this._AreaElement(k-n,x+n)-this._AreaElement(k+n,x-n)+this._AreaElement(k+n,x+n);let f=p[z*I.size*Z+o*Z+0],V=p[z*I.size*Z+o*Z+1],a=p[z*I.size*Z+o*Z+2];isNaN(f)&&(f=0),isNaN(V)&&(V=0),isNaN(a)&&(a=0),0===I.type&&(f/=255,V/=255,a/=255),I.gammaSpace&&(f=Math.pow((0,c.Clamp)(f),M.l),V=Math.pow((0,c.Clamp)(V),M.l),a=Math.pow((0,c.Clamp)(a),M.l));const v=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const I=Math.max(f,V,a);if(I>v){const g=v/I;f*=g,V*=g,a*=g}}else f=(0,c.Clamp)(f,0,v),V=(0,c.Clamp)(V,0,v),a=(0,c.Clamp)(a,0,v);const X=new J.Eg(f,V,a);g.addLight(G,X,S),b+=S,k+=e}x+=o}}const D=6*(4*Math.PI)/6/b;return g.scaleInPlace(D),g.convertIncidentRadianceToIrradiance(),g.convertIrradianceToLambertianRadiance(),z.f.FromHarmonics(g)}}n._FileFaces=[new o("right",new e.Vg(1,0,0),new e.Vg(0,0,-1),new e.Vg(0,-1,0)),new o("left",new e.Vg(-1,0,0),new e.Vg(0,0,1),new e.Vg(0,-1,0)),new o("up",new e.Vg(0,1,0),new e.Vg(1,0,0),new e.Vg(0,0,1)),new o("down",new e.Vg(0,-1,0),new e.Vg(1,0,0),new e.Vg(0,0,-1)),new o("front",new e.Vg(0,0,1),new e.Vg(1,0,0),new e.Vg(0,-1,0)),new o("back",new e.Vg(0,0,-1),new e.Vg(-1,0,0),new e.Vg(0,-1,0))],n.MAX_HDRI_VALUE=4096,n.PRESERVE_CLAMPED_COLORS=!1},14996:(I,g,b)=>{b.d(g,{DDSTools:()=>Z});var e=b(12610),c=b(12420),z=b(13095),M=b(12803);b(14250);const J=131072,o=131072;function n(I){return I.charCodeAt(0)+(I.charCodeAt(1)<<8)+(I.charCodeAt(2)<<16)+(I.charCodeAt(3)<<24)}const G=n("DXT1"),D=n("DXT3"),p=n("DXT5"),x=n("DX10");class Z{static GetDDSInfo(I){const g=new Int32Array(I.buffer,I.byteOffset,31),b=new Int32Array(I.buffer,I.byteOffset,35);let e=1;g[2]&J&&(e=Math.max(1,g[7]));const c=g[21],z=c===x?b[32]:0;let M=0;switch(c){case 113:M=2;break;case 116:M=1;break;case x:if(10===z){M=2;break}if(2===z){M=1;break}}return{width:g[4],height:g[3],mipmapCount:e,isFourCC:4===(4&g[20]),isRGB:64===(64&g[20]),isLuminance:(g[20]&o)===o,isCube:512===(512&g[28]),isCompressed:c===G||c===D||c===p,dxgiFormat:z,textureType:M}}static _GetHalfFloatAsFloatRGBAArrayBuffer(I,g,b,e,c,z){const J=new Float32Array(e),o=new Uint16Array(c,b);let n=0;for(let G=0;G<g;G++)for(let g=0;g<I;g++){const b=4*(g+G*I);J[n]=(0,M.g)(o[b]),J[n+1]=(0,M.g)(o[b+1]),J[n+2]=(0,M.g)(o[b+2]),Z.StoreLODInAlphaChannel?J[n+3]=z:J[n+3]=(0,M.g)(o[b+3]),n+=4}return J}static _GetHalfFloatRGBAArrayBuffer(I,g,b,e,c,z){if(Z.StoreLODInAlphaChannel){const J=new Uint16Array(e),o=new Uint16Array(c,b);let n=0;for(let b=0;b<g;b++)for(let g=0;g<I;g++){const e=4*(g+b*I);J[n]=o[e],J[n+1]=o[e+1],J[n+2]=o[e+2],J[n+3]=(0,M.m)(z),n+=4}return J}return new Uint16Array(c,b,e)}static _GetFloatRGBAArrayBuffer(I,g,b,e,c,z){if(Z.StoreLODInAlphaChannel){const M=new Float32Array(e),J=new Float32Array(c,b);let o=0;for(let b=0;b<g;b++)for(let g=0;g<I;g++){const e=4*(g+b*I);M[o]=J[e],M[o+1]=J[e+1],M[o+2]=J[e+2],M[o+3]=z,o+=4}return M}return new Float32Array(c,b,e)}static _GetFloatAsHalfFloatRGBAArrayBuffer(I,g,b,e,c,z){const J=new Uint16Array(e),o=new Float32Array(c,b);let n=0;for(let G=0;G<g;G++)for(let g=0;g<I;g++)J[n]=(0,M.m)(o[n]),J[n+1]=(0,M.m)(o[n+1]),J[n+2]=(0,M.m)(o[n+2]),Z.StoreLODInAlphaChannel?J[n+3]=(0,M.m)(z):J[n+3]=(0,M.m)(o[n+3]),n+=4;return J}static _GetFloatAsUIntRGBAArrayBuffer(I,g,b,c,z,M){const J=new Uint8Array(c),o=new Float32Array(z,b);let n=0;for(let G=0;G<g;G++)for(let g=0;g<I;g++){const b=4*(g+G*I);J[n]=255*(0,e.Clamp)(o[b]),J[n+1]=255*(0,e.Clamp)(o[b+1]),J[n+2]=255*(0,e.Clamp)(o[b+2]),Z.StoreLODInAlphaChannel?J[n+3]=M:J[n+3]=255*(0,e.Clamp)(o[b+3]),n+=4}return J}static _GetHalfFloatAsUIntRGBAArrayBuffer(I,g,b,c,z,J){const o=new Uint8Array(c),n=new Uint16Array(z,b);let G=0;for(let D=0;D<g;D++)for(let g=0;g<I;g++){const b=4*(g+D*I);o[G]=255*(0,e.Clamp)((0,M.g)(n[b])),o[G+1]=255*(0,e.Clamp)((0,M.g)(n[b+1])),o[G+2]=255*(0,e.Clamp)((0,M.g)(n[b+2])),Z.StoreLODInAlphaChannel?o[G+3]=J:o[G+3]=255*(0,e.Clamp)((0,M.g)(n[b+3])),G+=4}return o}static _GetRGBAArrayBuffer(I,g,b,e,c,z,M,J,o){const n=new Uint8Array(e),G=new Uint8Array(c,b);let D=0;for(let p=0;p<g;p++)for(let g=0;g<I;g++){const b=4*(g+p*I);n[D]=G[b+z],n[D+1]=G[b+M],n[D+2]=G[b+J],n[D+3]=G[b+o],D+=4}return n}static _ExtractLongWordOrder(I){return 0===I||255===I||-16777216===I?0:1+Z._ExtractLongWordOrder(I>>8)}static _GetRGBArrayBuffer(I,g,b,e,c,z,M,J){const o=new Uint8Array(e),n=new Uint8Array(c,b);let G=0;for(let D=0;D<g;D++)for(let g=0;g<I;g++){const b=3*(g+D*I);o[G]=n[b+z],o[G+1]=n[b+M],o[G+2]=n[b+J],G+=3}return o}static _GetLuminanceArrayBuffer(I,g,b,e,c){const z=new Uint8Array(e),M=new Uint8Array(c,b);let J=0;for(let o=0;o<g;o++)for(let g=0;g<I;g++){const b=g+o*I;z[J]=M[b],J++}return z}static UploadDDSLevels(I,g,b,e,M,o){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,k=arguments.length>7?arguments[7]:void 0,S=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],f=null;e.sphericalPolynomial&&(f=[]);const V=!!I.getCaps().s3tc;g.generateMipMaps=M;const a=new Int32Array(b.buffer,b.byteOffset,31);let v,X,R,E,mI,s,F,Y=0,d=0,C=1;if(542327876!==a[0])return void c.b.Error("Invalid magic number in DDS header");if(!e.isFourCC&&!e.isRGB&&!e.isLuminance)return void c.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(e.isCompressed&&!V)return void c.b.Error("Compressed textures are not supported on this platform.");let r=a[22];E=a[1]+4;let O=!1;if(e.isFourCC)switch(v=a[21],v){case G:C=8,d=33777;break;case D:C=16,d=33778;break;case p:C=16,d=33779;break;case 113:O=!0,r=64;break;case 116:O=!0,r=128;break;case x:{E+=20;let I=!1;switch(e.dxgiFormat){case 10:O=!0,r=64,I=!0;break;case 2:O=!0,r=128,I=!0;break;case 88:e.isRGB=!0,e.isFourCC=!1,r=32,I=!0}if(I)break}default:return void c.b.Error(["Unsupported FourCC code:",(H=v,String.fromCharCode(255&H,H>>8&255,H>>16&255,H>>24&255))])}var H;const i=Z._ExtractLongWordOrder(a[23]),U=Z._ExtractLongWordOrder(a[24]),h=Z._ExtractLongWordOrder(a[25]),A=Z._ExtractLongWordOrder(a[26]);O&&(d=I._getRGBABufferInternalSizedFormat(e.textureType)),s=1,a[2]&J&&!1!==M&&(s=Math.max(1,a[7]));const j=k||0,Q=I.getCaps();for(let c=j;c<o;c++){for(X=a[4],R=a[3],F=0;F<s;++F){if(-1===n||n===F){const z=-1===n?F:0;if(!e.isCompressed&&e.isFourCC){g.format=5,Y=X*R*4;let e=null;if(I._badOS||I._badDesktopOS||!Q.textureHalfFloat&&!Q.textureFloat)128===r?(e=Z._GetFloatAsUIntRGBAArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,z),f&&0==z&&f.push(Z._GetFloatRGBAArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,z))):64===r&&(e=Z._GetHalfFloatAsUIntRGBAArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,z),f&&0==z&&f.push(Z._GetHalfFloatAsFloatRGBAArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,z))),g.type=0;else{const I=Q.textureFloat&&(S&&Q.textureFloatLinearFiltering||!S),c=Q.textureHalfFloat&&(S&&Q.textureHalfFloatLinearFiltering||!S),M=(128===r||64===r&&!c)&&I?1:(64===r||128===r&&!I)&&c?2:0;let J,o=null;if(128===r)switch(M){case 1:J=Z._GetFloatRGBAArrayBuffer,o=null;break;case 2:J=Z._GetFloatAsHalfFloatRGBAArrayBuffer,o=Z._GetFloatRGBAArrayBuffer;break;case 0:J=Z._GetFloatAsUIntRGBAArrayBuffer,o=Z._GetFloatRGBAArrayBuffer}else switch(M){case 1:J=Z._GetHalfFloatAsFloatRGBAArrayBuffer,o=null;break;case 2:J=Z._GetHalfFloatRGBAArrayBuffer,o=Z._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:J=Z._GetHalfFloatAsUIntRGBAArrayBuffer,o=Z._GetHalfFloatAsFloatRGBAArrayBuffer}g.type=M,e=J(X,R,b.byteOffset+E,Y,b.buffer,z),f&&0==z&&f.push(o?o(X,R,b.byteOffset+E,Y,b.buffer,z):e)}e&&I._uploadDataToTextureDirectly(g,e,c,z)}else if(e.isRGB)g.type=0,24===r?(g.format=4,Y=X*R*3,mI=Z._GetRGBArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,i,U,h),I._uploadDataToTextureDirectly(g,mI,c,z)):(g.format=5,Y=X*R*4,mI=Z._GetRGBAArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer,i,U,h,A),I._uploadDataToTextureDirectly(g,mI,c,z));else if(e.isLuminance){const e=I._getUnpackAlignement(),M=X;Y=Math.floor((X+e-1)/e)*e*(R-1)+M,mI=Z._GetLuminanceArrayBuffer(X,R,b.byteOffset+E,Y,b.buffer),g.format=1,g.type=0,I._uploadDataToTextureDirectly(g,mI,c,z)}else Y=Math.max(4,X)/4*Math.max(4,R)/4*C,mI=new Uint8Array(b.buffer,b.byteOffset+E,Y),g.type=0,I._uploadCompressedDataToTextureDirectly(g,d,X,R,mI,c,z)}E+=r?X*R*(r/8):Y,X*=.5,R*=.5,X=Math.max(1,X),R=Math.max(1,R)}if(void 0!==k)break}f&&f.length>0?e.sphericalPolynomial=z.b.ConvertCubeMapToSphericalPolynomial({size:a[4],right:f[0],left:f[1],up:f[2],down:f[3],front:f[4],back:f[5],format:5,type:1,gammaSpace:!1}):e.sphericalPolynomial=void 0}}Z.StoreLODInAlphaChannel=!1}}]);