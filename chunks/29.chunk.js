"use strict";(self.n4ygn1cq9vg=self.n4ygn1cq9vg||[]).push([[29],{14153:(e,d,v)=>{var P=v(12357),p=v(12253),L=v(12283),B=v(12384),X=v(12319),z=v(12366);X.b.prototype._partialLoadFile=function(e,d,v,P){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(e,(e=>{v[d]=e,v._internalCount++,6===v._internalCount&&P(v)}),void 0,void 0,!0,((e,d)=>{p&&e&&p(e.status+" "+e.statusText,d)}))},X.b.prototype._cascadeLoadFiles=function(e,d,v){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const p=[];p._internalCount=0;for(let L=0;L<6;L++)this._partialLoadFile(v[L],L,p,d,P)},X.b.prototype._cascadeLoadImgs=function(e,d,v,P){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,L=arguments.length>5?arguments[5]:void 0;const B=[];B._internalCount=0;for(let X=0;X<6;X++)this._partialLoadImg(P[X],X,B,e,d,v,p,L)},X.b.prototype._partialLoadImg=function(e,d,v,P,p,X){let z=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,W=arguments.length>7?arguments[7]:void 0;const V=(0,B.b)();(0,L.q)(e,(e=>{v[d]=e,v._internalCount++,P&&P.removePendingData(V),6===v._internalCount&&X&&X(p,v)}),((e,d)=>{P&&P.removePendingData(V),z&&z(e,d)}),P?P.offlineProvider:null,W),P&&P.addPendingData(V)},X.b.prototype.createCubeTextureBase=function(e,d,v,L){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,X=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,W=arguments.length>6?arguments[6]:void 0,V=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,k=arguments.length>8&&void 0!==arguments[8]&&arguments[8],g=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,w=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,G=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,U=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,D=arguments.length>14&&void 0!==arguments[14]&&arguments[14],C=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const q=w||new P.b(this,7);q.isCube=!0,q.url=e,q.generateMipMaps=!L,q._lodGenerationScale=g,q._lodGenerationOffset=F,q._useSRGBBuffer=!!D&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!L),q!==w&&(q.label=e.substring(0,60)),this._doNotHandleContextLost||(q._extension=V,q._files=v,q._buffer=C);const h=e;this._transformTextureUrl&&!w&&(e=this._transformTextureUrl(e));const l=V??function(e){const d=e.split("?")[0],v=d.lastIndexOf(".");return v>-1?d.substring(v).toLowerCase():""}(e),n=(0,z.e)(l),A=(e,d)=>{q.dispose(),X?X(e,d):e&&p.c.Warn(e)},x=(P,X)=>{e===h?P&&A(P.status+" "+P.statusText,X):(p.c.Warn(`Failed to load ${e}, falling back to the ${h}`),this.createCubeTextureBase(h,d,v,!!L,B,A,W,V,k,g,F,q,G,U,D,C))};if(n)n.then((P=>{const p=e=>{G&&G(q,e),P.loadCubeData(e,q,k,B,((e,d)=>{A(e,d)}))};C?p(C):v&&6===v.length?P.supportCascades?this._cascadeLoadFiles(d,(e=>p(e.map((e=>new Uint8Array(e))))),v,A):A("Textures type does not support cascades."):this._loadFile(e,(e=>p(new Uint8Array(e))),void 0,void 0,!0,x)}));else{if(!v||0===v.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(d,q,((e,d)=>{U&&U(e,d)}),v,A)}return this._internalTexturesCache.push(q),q}},12941:(e,d,v)=>{v.d(d,{d:()=>W});var P=v(12420),p=v(12440),L=v(12609),B=v(12429),X=v(12463);class z{constructor(e,d,v,P){this.name=e,this.worldAxisForNormal=d,this.worldAxisForFileX=v,this.worldAxisForFileY=P}}class W{static ConvertCubeMapTextureToSphericalPolynomial(e){var d;if(!e.isCube)return null;null===(d=e.Ae())||void 0===d||d.getEngine().flushFramebuffer();const v=e.getSize().width,P=e.readPixels(0,void 0,void 0,!1),p=e.readPixels(1,void 0,void 0,!1);let L,B;e.isRenderTarget?(L=e.readPixels(3,void 0,void 0,!1),B=e.readPixels(2,void 0,void 0,!1)):(L=e.readPixels(2,void 0,void 0,!1),B=e.readPixels(3,void 0,void 0,!1));const X=e.readPixels(4,void 0,void 0,!1),z=e.readPixels(5,void 0,void 0,!1),W=e.gammaSpace;let V=0;return 1!=e.textureType&&2!=e.textureType||(V=1),new Promise((e=>{Promise.all([p,P,L,B,X,z]).then((d=>{let[P,p,L,B,X,z]=d;const k={size:v,right:p,left:P,up:L,down:B,front:X,back:z,format:5,type:V,gammaSpace:W};e(this.ConvertCubeMapToSphericalPolynomial(k))}))}))}static _AreaElement(e,d){return Math.atan2(e*d,Math.sqrt(e*e+d*d+1))}static ConvertCubeMapToSphericalPolynomial(e){const d=new L.c;let v=0;const P=2/e.size,z=P,W=.5*P,V=W-1;for(let L=0;L<6;L++){const k=this._FileFaces[L],g=e[k.name];let F=V;const w=5===e.format?4:3;for(let L=0;L<e.size;L++){let G=V;for(let z=0;z<e.size;z++){const V=k.worldAxisForFileX.scale(G).add(k.worldAxisForFileY.scale(F)).add(k.worldAxisForNormal);V.normalize();const U=this._AreaElement(G-W,F-W)-this._AreaElement(G-W,F+W)-this._AreaElement(G+W,F-W)+this._AreaElement(G+W,F+W);let D=g[L*e.size*w+z*w+0],C=g[L*e.size*w+z*w+1],q=g[L*e.size*w+z*w+2];isNaN(D)&&(D=0),isNaN(C)&&(C=0),isNaN(q)&&(q=0),0===e.type&&(D/=255,C/=255,q/=255),e.gammaSpace&&(D=Math.pow((0,p.Clamp)(D),B.p),C=Math.pow((0,p.Clamp)(C),B.p),q=Math.pow((0,p.Clamp)(q),B.p));const h=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const e=Math.max(D,C,q);if(e>h){const d=h/e;D*=d,C*=d,q*=d}}else D=(0,p.Clamp)(D,0,h),C=(0,p.Clamp)(C,0,h),q=(0,p.Clamp)(q,0,h);const l=new X.Kd(D,C,q);d.addLight(V,l,U),v+=U,G+=P}F+=z}}const k=6*(4*Math.PI)/6/v;return d.scaleInPlace(k),d.convertIncidentRadianceToIrradiance(),d.convertIrradianceToLambertianRadiance(),L.f.FromHarmonics(d)}}W._FileFaces=[new z("right",new P.mv(1,0,0),new P.mv(0,0,-1),new P.mv(0,-1,0)),new z("left",new P.mv(-1,0,0),new P.mv(0,0,1),new P.mv(0,-1,0)),new z("up",new P.mv(0,1,0),new P.mv(1,0,0),new P.mv(0,0,1)),new z("down",new P.mv(0,-1,0),new P.mv(1,0,0),new P.mv(0,0,-1)),new z("front",new P.mv(0,0,1),new P.mv(1,0,0),new P.mv(0,-1,0)),new z("back",new P.mv(0,0,-1),new P.mv(-1,0,0),new P.mv(0,-1,0))],W.MAX_HDRI_VALUE=4096,W.PRESERVE_CLAMPED_COLORS=!1},14873:(e,d,v)=>{v.d(d,{DDSTools:()=>w});var P=v(12440),p=v(12253),L=v(12941),B=v(12643);v(14153);const X=131072,z=131072;function W(e){return e.charCodeAt(0)+(e.charCodeAt(1)<<8)+(e.charCodeAt(2)<<16)+(e.charCodeAt(3)<<24)}const V=W("DXT1"),k=W("DXT3"),g=W("DXT5"),F=W("DX10");class w{static GetDDSInfo(e){const d=new Int32Array(e.buffer,e.byteOffset,31),v=new Int32Array(e.buffer,e.byteOffset,35);let P=1;d[2]&X&&(P=Math.max(1,d[7]));const p=d[21],L=p===F?v[32]:0;let B=0;switch(p){case 113:B=2;break;case 116:B=1;break;case F:if(10===L){B=2;break}if(2===L){B=1;break}}return{width:d[4],height:d[3],mipmapCount:P,isFourCC:4===(4&d[20]),isRGB:64===(64&d[20]),isLuminance:(d[20]&z)===z,isCube:512===(512&d[28]),isCompressed:p===V||p===k||p===g,dxgiFormat:L,textureType:B}}static _GetHalfFloatAsFloatRGBAArrayBuffer(e,d,v,P,p,L){const X=new Float32Array(P),z=new Uint16Array(p,v);let W=0;for(let V=0;V<d;V++)for(let d=0;d<e;d++){const v=4*(d+V*e);X[W]=(0,B.f)(z[v]),X[W+1]=(0,B.f)(z[v+1]),X[W+2]=(0,B.f)(z[v+2]),w.StoreLODInAlphaChannel?X[W+3]=L:X[W+3]=(0,B.f)(z[v+3]),W+=4}return X}static _GetHalfFloatRGBAArrayBuffer(e,d,v,P,p,L){if(w.StoreLODInAlphaChannel){const X=new Uint16Array(P),z=new Uint16Array(p,v);let W=0;for(let v=0;v<d;v++)for(let d=0;d<e;d++){const P=4*(d+v*e);X[W]=z[P],X[W+1]=z[P+1],X[W+2]=z[P+2],X[W+3]=(0,B.i)(L),W+=4}return X}return new Uint16Array(p,v,P)}static _GetFloatRGBAArrayBuffer(e,d,v,P,p,L){if(w.StoreLODInAlphaChannel){const B=new Float32Array(P),X=new Float32Array(p,v);let z=0;for(let v=0;v<d;v++)for(let d=0;d<e;d++){const P=4*(d+v*e);B[z]=X[P],B[z+1]=X[P+1],B[z+2]=X[P+2],B[z+3]=L,z+=4}return B}return new Float32Array(p,v,P)}static _GetFloatAsHalfFloatRGBAArrayBuffer(e,d,v,P,p,L){const X=new Uint16Array(P),z=new Float32Array(p,v);let W=0;for(let V=0;V<d;V++)for(let d=0;d<e;d++)X[W]=(0,B.i)(z[W]),X[W+1]=(0,B.i)(z[W+1]),X[W+2]=(0,B.i)(z[W+2]),w.StoreLODInAlphaChannel?X[W+3]=(0,B.i)(L):X[W+3]=(0,B.i)(z[W+3]),W+=4;return X}static _GetFloatAsUIntRGBAArrayBuffer(e,d,v,p,L,B){const X=new Uint8Array(p),z=new Float32Array(L,v);let W=0;for(let V=0;V<d;V++)for(let d=0;d<e;d++){const v=4*(d+V*e);X[W]=255*(0,P.Clamp)(z[v]),X[W+1]=255*(0,P.Clamp)(z[v+1]),X[W+2]=255*(0,P.Clamp)(z[v+2]),w.StoreLODInAlphaChannel?X[W+3]=B:X[W+3]=255*(0,P.Clamp)(z[v+3]),W+=4}return X}static _GetHalfFloatAsUIntRGBAArrayBuffer(e,d,v,p,L,X){const z=new Uint8Array(p),W=new Uint16Array(L,v);let V=0;for(let k=0;k<d;k++)for(let d=0;d<e;d++){const v=4*(d+k*e);z[V]=255*(0,P.Clamp)((0,B.f)(W[v])),z[V+1]=255*(0,P.Clamp)((0,B.f)(W[v+1])),z[V+2]=255*(0,P.Clamp)((0,B.f)(W[v+2])),w.StoreLODInAlphaChannel?z[V+3]=X:z[V+3]=255*(0,P.Clamp)((0,B.f)(W[v+3])),V+=4}return z}static _GetRGBAArrayBuffer(e,d,v,P,p,L,B,X,z){const W=new Uint8Array(P),V=new Uint8Array(p,v);let k=0;for(let g=0;g<d;g++)for(let d=0;d<e;d++){const v=4*(d+g*e);W[k]=V[v+L],W[k+1]=V[v+B],W[k+2]=V[v+X],W[k+3]=V[v+z],k+=4}return W}static _ExtractLongWordOrder(e){return 0===e||255===e||-16777216===e?0:1+w._ExtractLongWordOrder(e>>8)}static _GetRGBArrayBuffer(e,d,v,P,p,L,B,X){const z=new Uint8Array(P),W=new Uint8Array(p,v);let V=0;for(let k=0;k<d;k++)for(let d=0;d<e;d++){const v=3*(d+k*e);z[V]=W[v+L],z[V+1]=W[v+B],z[V+2]=W[v+X],V+=3}return z}static _GetLuminanceArrayBuffer(e,d,v,P,p){const L=new Uint8Array(P),B=new Uint8Array(p,v);let X=0;for(let z=0;z<d;z++)for(let d=0;d<e;d++){const v=d+z*e;L[X]=B[v],X++}return L}static UploadDDSLevels(e,d,v,P,B,z){let W=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,G=arguments.length>7?arguments[7]:void 0,U=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],D=null;P.sphericalPolynomial&&(D=[]);const C=!!e.getCaps().s3tc;d.generateMipMaps=B;const q=new Int32Array(v.buffer,v.byteOffset,31);let h,l,n,A,x,i,me,r=0,Z=0,f=1;if(542327876!==q[0])return void p.c.Error("Invalid magic number in DDS header");if(!P.isFourCC&&!P.isRGB&&!P.isLuminance)return void p.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(P.isCompressed&&!C)return void p.c.Error("Compressed textures are not supported on this platform.");let T=q[22];A=q[1]+4;let S=!1;if(P.isFourCC)switch(h=q[21],h){case V:f=8,Z=33777;break;case k:f=16,Z=33778;break;case g:f=16,Z=33779;break;case 113:S=!0,T=64;break;case 116:S=!0,T=128;break;case F:{A+=20;let e=!1;switch(P.dxgiFormat){case 10:S=!0,T=64,e=!0;break;case 2:S=!0,T=128,e=!0;break;case 88:P.isRGB=!0,P.isFourCC=!1,T=32,e=!0}if(e)break}default:return void p.c.Error(["Unsupported FourCC code:",(o=h,String.fromCharCode(255&o,o>>8&255,o>>16&255,o>>24&255))])}var o;const K=w._ExtractLongWordOrder(q[23]),Q=w._ExtractLongWordOrder(q[24]),N=w._ExtractLongWordOrder(q[25]),u=w._ExtractLongWordOrder(q[26]);S&&(Z=e._getRGBABufferInternalSizedFormat(P.textureType)),i=1,q[2]&X&&!1!==B&&(i=Math.max(1,q[7]));const O=G||0,R=e.getCaps();for(let p=O;p<z;p++){for(l=q[4],n=q[3],me=0;me<i;++me){if(-1===W||W===me){const L=-1===W?me:0;if(!P.isCompressed&&P.isFourCC){d.format=5,r=l*n*4;let P=null;if(e._badOS||e._badDesktopOS||!R.textureHalfFloat&&!R.textureFloat)128===T?(P=w._GetFloatAsUIntRGBAArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,L),D&&0==L&&D.push(w._GetFloatRGBAArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,L))):64===T&&(P=w._GetHalfFloatAsUIntRGBAArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,L),D&&0==L&&D.push(w._GetHalfFloatAsFloatRGBAArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,L))),d.type=0;else{const e=R.textureFloat&&(U&&R.textureFloatLinearFiltering||!U),p=R.textureHalfFloat&&(U&&R.textureHalfFloatLinearFiltering||!U),B=(128===T||64===T&&!p)&&e?1:(64===T||128===T&&!e)&&p?2:0;let X,z=null;if(128===T)switch(B){case 1:X=w._GetFloatRGBAArrayBuffer,z=null;break;case 2:X=w._GetFloatAsHalfFloatRGBAArrayBuffer,z=w._GetFloatRGBAArrayBuffer;break;case 0:X=w._GetFloatAsUIntRGBAArrayBuffer,z=w._GetFloatRGBAArrayBuffer}else switch(B){case 1:X=w._GetHalfFloatAsFloatRGBAArrayBuffer,z=null;break;case 2:X=w._GetHalfFloatRGBAArrayBuffer,z=w._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:X=w._GetHalfFloatAsUIntRGBAArrayBuffer,z=w._GetHalfFloatAsFloatRGBAArrayBuffer}d.type=B,P=X(l,n,v.byteOffset+A,r,v.buffer,L),D&&0==L&&D.push(z?z(l,n,v.byteOffset+A,r,v.buffer,L):P)}P&&e._uploadDataToTextureDirectly(d,P,p,L)}else if(P.isRGB)d.type=0,24===T?(d.format=4,r=l*n*3,x=w._GetRGBArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,K,Q,N),e._uploadDataToTextureDirectly(d,x,p,L)):(d.format=5,r=l*n*4,x=w._GetRGBAArrayBuffer(l,n,v.byteOffset+A,r,v.buffer,K,Q,N,u),e._uploadDataToTextureDirectly(d,x,p,L));else if(P.isLuminance){const P=e._getUnpackAlignement(),B=l;r=Math.floor((l+P-1)/P)*P*(n-1)+B,x=w._GetLuminanceArrayBuffer(l,n,v.byteOffset+A,r,v.buffer),d.format=1,d.type=0,e._uploadDataToTextureDirectly(d,x,p,L)}else r=Math.max(4,l)/4*Math.max(4,n)/4*f,x=new Uint8Array(v.buffer,v.byteOffset+A,r),d.type=0,e._uploadCompressedDataToTextureDirectly(d,Z,l,n,x,p,L)}A+=T?l*n*(T/8):r,l*=.5,n*=.5,l=Math.max(1,l),n=Math.max(1,n)}if(void 0!==G)break}D&&D.length>0?P.sphericalPolynomial=L.d.ConvertCubeMapToSphericalPolynomial({size:q[4],right:D[0],left:D[1],up:D[2],down:D[3],front:D[4],back:D[5],format:5,type:1,gammaSpace:!1}):P.sphericalPolynomial=void 0}}w.StoreLODInAlphaChannel=!1}}]);