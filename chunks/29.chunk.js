"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13660:(V,I,m)=>{m.r(I),m.d(I,{_BasisTextureLoader:()=>D});var C,l=m(11076),s=m(11518),F=m(11161);function k(){const V=0,I=1,m=2,C=3,l=6,s=8,F=9,k=10,j=14;let E=null;function K(V,I,m,C,l){const s=V.getImageTranscodedSizeInBytes(I,m,C);let F=new Uint8Array(s);if(!V.transcodeImage(F,I,m,C,1,0))return null;if(l){F=function(V,I,m,C){const l=new Uint16Array(4),s=new Uint16Array(m*C),F=m/4,k=C/4;for(let j=0;j<k;j++)for(let C=0;C<F;C++){const k=I+8*(j*F+C);l[0]=V[k]|V[k+1]<<8,l[1]=V[k+2]|V[k+3]<<8,l[2]=(2*(31&l[0])+1*(31&l[1]))/3|(2*(2016&l[0])+1*(2016&l[1]))/3&2016|(2*(63488&l[0])+1*(63488&l[1]))/3&63488,l[3]=(2*(31&l[1])+1*(31&l[0]))/3|(2*(2016&l[1])+1*(2016&l[0]))/3&2016|(2*(63488&l[1])+1*(63488&l[0]))/3&63488;for(let I=0;I<4;I++){const F=V[k+4+I];let E=(4*j+I)*m+4*C;s[E++]=l[3&F],s[E++]=l[F>>2&3],s[E++]=l[F>>4&3],s[E++]=l[F>>6&3]}}return s}(F,0,V.getImageWidth(I,m)+3&-4,V.getImageHeight(I,m)+3&-4)}return F}onmessage=Y=>{if("init"===Y.data.action){if(Y.data.url)try{importScripts(Y.data.url)}catch(X){postMessage({action:"error",error:X})}E||(E=BASIS({wasmBinary:Y.data.wasmBinary})),null!==E&&E.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Y.data.action){const E=Y.data.config,X=Y.data.imageData,O=new BASIS.BasisFile(X),v=function(V){const I=V.getHasAlpha(),m=V.getNumImages(),C=[];for(let l=0;l<m;l++){const I={levels:[]},m=V.getNumLevels(l);for(let C=0;C<m;C++){const m={width:V.getImageWidth(l,C),height:V.getImageHeight(l,C)};I.levels.push(m)}C.push(I)}return{eF:I,images:C}}(O);let N=Y.data.ignoreSupportedFormats?null:function(E,K){let Y=null;E.supportedCompressionFormats&&(Y=E.supportedCompressionFormats.astc?k:E.supportedCompressionFormats.bc7?l:E.supportedCompressionFormats.s3tc?K.eF?C:m:E.supportedCompressionFormats.pvrtc?K.eF?F:s:E.supportedCompressionFormats.etc2?I:E.supportedCompressionFormats.etc1?V:j);return Y}(Y.data.config,v),t=!1;null===N&&(t=!0,N=v.eF?C:m);let D=!0;O.startTranscoding()||(D=!1);const b=[];for(let V=0;V<v.images.length&&D;V++){const I=v.images[V];if(void 0===E.loadSingleImage||E.loadSingleImage===V){let m=I.levels.length;!1===E.loadMipmapLevels&&(m=1);for(let C=0;C<m;C++){const m=I.levels[C],l=K(O,V,C,N,t);if(!l){D=!1;break}m.transcodedPixels=l,b.push(m.transcodedPixels.buffer)}}}O.close(),O.delete(),t&&(N=-1),D?postMessage({action:"transcode",success:D,id:Y.data.id,fileInfo:v,format:N},b):postMessage({action:"transcode",success:D,id:Y.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(C||(C={}));const j={JSModuleURL:`${l.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${l.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let E=null,K=null,Y=0;const X=async()=>(E||(E=new Promise(((V,I)=>{K?V(K):l.d.LoadFileAsync(l.d.GetBabylonScriptURL(j.WasmModuleURL)).then((m=>{if("function"!==typeof URL)return I("Basis transcoder requires an environment with a URL constructor");const C=URL.createObjectURL(new Blob([`(${k})()`],{type:"application/javascript"}));K=new Worker(C),async function(V,I,m){return await new Promise(((C,s)=>{const F=I=>{"init"===I.data.action?(V.removeEventListener("message",F),C(V)):"error"===I.data.action&&s(I.data.error||"error initializing worker")};V.addEventListener("message",F),V.postMessage({action:"init",url:m?l.d.GetBabylonScriptURL(m):void 0,wasmBinary:I},[I])}))}(K,m,j.JSModuleURL).then(V,I)})).catch(I)}))),await E),O=async(V,I)=>{const m=V instanceof ArrayBuffer?new Uint8Array(V):V;return await new Promise(((V,C)=>{X().then((()=>{const l=Y++,s=I=>{"transcode"===I.data.action&&I.data.id===l&&(K.removeEventListener("message",s),I.data.success?V(I.data):C("Transcode is not supported on this device"))};K.addEventListener("message",s);const F=new Uint8Array(m.byteLength);F.set(new Uint8Array(m.buffer,m.byteOffset,m.byteLength)),K.postMessage({action:"transcode",id:l,imageData:F,config:I,ignoreSupportedFormats:false},[F.buffer])}),(V=>{C(V)}))}))},v=(V,I)=>{var m;let C=null===(m=I._gl)||void 0===m?void 0:m.TEXTURE_2D;var l;V.isCube&&(C=null===(l=I._gl)||void 0===l?void 0:l.TEXTURE_CUBE_MAP);I._bindTextureDirectly(C,V,!0)},N=(V,I)=>{const m=V.getEngine();for(let k=0;k<I.fileInfo.images.length;k++){const j=I.fileInfo.images[k].levels[0];if(V._invertVScale=V.invertY,-1===I.format||I.format===C.cTFRGB565)if(V.type=10,V.format=4,!m._features.basisNeedsPOT||Math.log2(j.width)%1===0&&Math.log2(j.height)%1===0)V._invertVScale=!V.invertY,V.width=j.width+3&-4,V.height=j.height+3&-4,V.samplingMode=2,v(V,m),m._uploadDataToTextureDirectly(V,new Uint16Array(j.transcodedPixels.buffer),k,0,4,!0);else{const I=new F.e(m,2);V._invertVScale=V.invertY,I.type=10,I.format=4,I.width=j.width+3&-4,I.height=j.height+3&-4,v(I,m),m._uploadDataToTextureDirectly(I,new Uint16Array(j.transcodedPixels.buffer),k,0,4,!0),m._rescaleTexture(I,V,m.scenes[0],m._getInternalFormat(4),(()=>{m._releaseTexture(I),v(V,m)}))}else{V.width=j.width,V.height=j.height,V.generateMipMaps=I.fileInfo.images[k].levels.length>1;const C=t.GetInternalFormatFromBasisFormat(I.format,m);V.format=C,v(V,m);const F=I.fileInfo.images[k].levels;for(let I=0;I<F.length;I++){const l=F[I];m._uploadCompressedDataToTextureDirectly(V,C,l.width,l.height,l.transcodedPixels,k,I)}!m._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(l.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=s.e.CLAMP_ADDRESSMODE,V._cachedWrapV=s.e.CLAMP_ADDRESSMODE)}}},t={JSModuleURL:j.JSModuleURL,WasmModuleURL:j.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,I)=>{let m;switch(V){case C.cTFETC1:m=36196;break;case C.cTFBC1:m=33776;break;case C.cTFBC4:m=33779;break;case C.cTFASTC_4x4:m=37808;break;case C.cTFETC2:m=37496;break;case C.cTFBC7:m=36492}if(void 0===m)throw"The chosen Basis transcoder format is not currently supported";return m},TranscodeAsync:O,LoadTextureFromTranscodeResult:N};Object.defineProperty(t,"JSModuleURL",{get:function(){return j.JSModuleURL},set:function(V){j.JSModuleURL=V}}),Object.defineProperty(t,"WasmModuleURL",{get:function(){return j.WasmModuleURL},set:function(V){j.WasmModuleURL=V}});class D{constructor(){this.supportCascades=!1}loadCubeData(V,I,m,C,s){if(Array.isArray(V))return;const F=I.getEngine().getCaps(),k={supportedCompressionFormats:{etc1:!!F.etc1,s3tc:!!F.s3tc,pvrtc:!!F.pvrtc,etc2:!!F.etc2,astc:!!F.astc,bc7:!!F.bptc}};O(V,k).then((V=>{const m=V.fileInfo.images[0].levels.length>1&&I.generateMipMaps;N(I,V),I.getEngine()._setCubeMapTextureParams(I,m),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),C&&C()})).catch((V=>{l.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.isReady=!0,s&&s(V)}))}loadData(V,I,m){const C=I.getEngine().getCaps(),s={supportedCompressionFormats:{etc1:!!C.etc1,s3tc:!!C.s3tc,pvrtc:!!C.pvrtc,etc2:!!C.etc2,astc:!!C.astc,bc7:!!C.bptc}};O(V,s).then((V=>{const C=V.fileInfo.images[0].levels[0],l=V.fileInfo.images[0].levels.length>1&&I.generateMipMaps;m(C.width,C.height,l,-1!==V.format,(()=>{N(I,V)}))})).catch((V=>{l.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),l.d.Warn(`Failed to transcode Basis file: ${V}`),m(0,0,!1,!1,(()=>{}),!0)}))}}}}]);