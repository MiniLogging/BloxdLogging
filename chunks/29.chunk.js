"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13453:(x,O,Q)=>{Q.r(O),Q.d(O,{_BasisTextureLoader:()=>Y});var X,Z=Q(10894),n=Q(11335),V=Q(10994);function o(){const x=0,O=1,Q=2,X=3,Z=6,n=8,V=9,o=10,l=14;let C=null;function U(x,O,Q,X,Z){const n=x.getImageTranscodedSizeInBytes(O,Q,X);let V=new Uint8Array(n);if(!x.transcodeImage(V,O,Q,X,1,0))return null;if(Z){V=function(x,O,Q,X){const Z=new Uint16Array(4),n=new Uint16Array(Q*X),V=Q/4,o=X/4;for(let l=0;l<o;l++)for(let X=0;X<V;X++){const o=O+8*(l*V+X);Z[0]=x[o]|x[o+1]<<8,Z[1]=x[o+2]|x[o+3]<<8,Z[2]=(2*(31&Z[0])+1*(31&Z[1]))/3|(2*(2016&Z[0])+1*(2016&Z[1]))/3&2016|(2*(63488&Z[0])+1*(63488&Z[1]))/3&63488,Z[3]=(2*(31&Z[1])+1*(31&Z[0]))/3|(2*(2016&Z[1])+1*(2016&Z[0]))/3&2016|(2*(63488&Z[1])+1*(63488&Z[0]))/3&63488;for(let O=0;O<4;O++){const V=x[o+4+O];let C=(4*l+O)*Q+4*X;n[C++]=Z[3&V],n[C++]=Z[V>>2&3],n[C++]=Z[V>>4&3],n[C++]=Z[V>>6&3]}}return n}(V,0,x.getImageWidth(O,Q)+3&-4,x.getImageHeight(O,Q)+3&-4)}return V}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(h){postMessage({action:"error",error:h})}C||(C=BASIS({wasmBinary:L.data.wasmBinary})),null!==C&&C.then((x=>{BASIS=x,x.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const C=L.data.config,h=L.data.imageData,N=new BASIS.BasisFile(h),a=function(x){const O=x.getHasAlpha(),Q=x.getNumImages(),X=[];for(let Z=0;Z<Q;Z++){const O={levels:[]},Q=x.getNumLevels(Z);for(let X=0;X<Q;X++){const Q={width:x.getImageWidth(Z,X),height:x.getImageHeight(Z,X)};O.levels.push(Q)}X.push(O)}return{wV:O,images:X}}(N);let K=L.data.ignoreSupportedFormats?null:function(C,U){let L=null;C.supportedCompressionFormats&&(L=C.supportedCompressionFormats.astc?o:C.supportedCompressionFormats.bc7?Z:C.supportedCompressionFormats.s3tc?U.wV?X:Q:C.supportedCompressionFormats.pvrtc?U.wV?V:n:C.supportedCompressionFormats.etc2?O:C.supportedCompressionFormats.etc1?x:l);return L}(L.data.config,a),M=!1;null===K&&(M=!0,K=a.wV?X:Q);let Y=!0;N.startTranscoding()||(Y=!1);const g=[];for(let x=0;x<a.images.length&&Y;x++){const O=a.images[x];if(void 0===C.loadSingleImage||C.loadSingleImage===x){let Q=O.levels.length;!1===C.loadMipmapLevels&&(Q=1);for(let X=0;X<Q;X++){const Q=O.levels[X],Z=U(N,x,X,K,M);if(!Z){Y=!1;break}Q.transcodedPixels=Z,g.push(Q.transcodedPixels.buffer)}}}N.close(),N.delete(),M&&(K=-1),Y?postMessage({action:"transcode",success:Y,id:L.data.id,fileInfo:a,format:K},g):postMessage({action:"transcode",success:Y,id:L.data.id})}}}!function(x){x[x.cTFETC1=0]="cTFETC1",x[x.cTFETC2=1]="cTFETC2",x[x.cTFBC1=2]="cTFBC1",x[x.cTFBC3=3]="cTFBC3",x[x.cTFBC4=4]="cTFBC4",x[x.cTFBC5=5]="cTFBC5",x[x.cTFBC7=6]="cTFBC7",x[x.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",x[x.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",x[x.cTFASTC_4x4=10]="cTFASTC_4x4",x[x.cTFATC_RGB=11]="cTFATC_RGB",x[x.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",x[x.cTFRGBA32=13]="cTFRGBA32",x[x.cTFRGB565=14]="cTFRGB565",x[x.cTFBGR565=15]="cTFBGR565",x[x.cTFRGBA4444=16]="cTFRGBA4444",x[x.cTFFXT1_RGB=17]="cTFFXT1_RGB",x[x.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",x[x.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",x[x.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",x[x.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(X||(X={}));const l={JSModuleURL:`${Z.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${Z.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,U=null,L=0;const h=async()=>(C||(C=new Promise(((x,O)=>{U?x(U):Z.g.LoadFileAsync(Z.g.GetBabylonScriptURL(l.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return O("Basis transcoder requires an environment with a URL constructor");const X=URL.createObjectURL(new Blob([`(${o})()`],{type:"application/javascript"}));U=new Worker(X),async function(x,O,Q){return await new Promise(((X,n)=>{const V=O=>{"init"===O.data.action?(x.removeEventListener("message",V),X(x)):"error"===O.data.action&&n(O.data.error||"error initializing worker")};x.addEventListener("message",V),x.postMessage({action:"init",url:Q?Z.g.GetBabylonScriptURL(Q):void 0,wasmBinary:O},[O])}))}(U,Q,l.JSModuleURL).then(x,O)})).catch(O)}))),await C),N=async(x,O)=>{const Q=x instanceof ArrayBuffer?new Uint8Array(x):x;return await new Promise(((x,X)=>{h().then((()=>{const Z=L++,n=O=>{"transcode"===O.data.action&&O.data.id===Z&&(U.removeEventListener("message",n),O.data.success?x(O.data):X("Transcode is not supported on this device"))};U.addEventListener("message",n);const V=new Uint8Array(Q.byteLength);V.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),U.postMessage({action:"transcode",id:Z,imageData:V,config:O,ignoreSupportedFormats:false},[V.buffer])}),(x=>{X(x)}))}))},a=(x,O)=>{var Q;let X=null===(Q=O._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var Z;x.isCube&&(X=null===(Z=O._gl)||void 0===Z?void 0:Z.TEXTURE_CUBE_MAP);O._bindTextureDirectly(X,x,!0)},K=(x,O)=>{const Q=x.getEngine();for(let o=0;o<O.fileInfo.images.length;o++){const l=O.fileInfo.images[o].levels[0];if(x._invertVScale=x.invertY,-1===O.format||O.format===X.cTFRGB565)if(x.type=10,x.format=4,!Q._features.basisNeedsPOT||Math.log2(l.width)%1===0&&Math.log2(l.height)%1===0)x._invertVScale=!x.invertY,x.width=l.width+3&-4,x.height=l.height+3&-4,x.samplingMode=2,a(x,Q),Q._uploadDataToTextureDirectly(x,new Uint16Array(l.transcodedPixels.buffer),o,0,4,!0);else{const O=new V.e(Q,2);x._invertVScale=x.invertY,O.type=10,O.format=4,O.width=l.width+3&-4,O.height=l.height+3&-4,a(O,Q),Q._uploadDataToTextureDirectly(O,new Uint16Array(l.transcodedPixels.buffer),o,0,4,!0),Q._rescaleTexture(O,x,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(O),a(x,Q)}))}else{x.width=l.width,x.height=l.height,x.generateMipMaps=O.fileInfo.images[o].levels.length>1;const X=M.GetInternalFormatFromBasisFormat(O.format,Q);x.format=X,a(x,Q);const V=O.fileInfo.images[o].levels;for(let O=0;O<V.length;O++){const Z=V[O];Q._uploadCompressedDataToTextureDirectly(x,X,Z.width,Z.height,Z.transcodedPixels,o,O)}!Q._features.basisNeedsPOT||Math.log2(x.width)%1===0&&Math.log2(x.height)%1===0||(Z.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),x._cachedWrapU=n.b.CLAMP_ADDRESSMODE,x._cachedWrapV=n.b.CLAMP_ADDRESSMODE)}}},M={JSModuleURL:l.JSModuleURL,WasmModuleURL:l.WasmModuleURL,GetInternalFormatFromBasisFormat:(x,O)=>{let Q;switch(x){case X.cTFETC1:Q=36196;break;case X.cTFBC1:Q=33776;break;case X.cTFBC4:Q=33779;break;case X.cTFASTC_4x4:Q=37808;break;case X.cTFETC2:Q=37496;break;case X.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:N,LoadTextureFromTranscodeResult:K};Object.defineProperty(M,"JSModuleURL",{get:function(){return l.JSModuleURL},set:function(x){l.JSModuleURL=x}}),Object.defineProperty(M,"WasmModuleURL",{get:function(){return l.WasmModuleURL},set:function(x){l.WasmModuleURL=x}});class Y{constructor(){this.supportCascades=!1}loadCubeData(x,O,Q,X,n){if(Array.isArray(x))return;const V=O.getEngine().getCaps(),o={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};N(x,o).then((x=>{const Q=x.fileInfo.images[0].levels.length>1&&O.generateMipMaps;K(O,x),O.getEngine()._setCubeMapTextureParams(O,Q),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),X&&X()})).catch((x=>{Z.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.isReady=!0,n&&n(x)}))}loadData(x,O,Q){const X=O.getEngine().getCaps(),n={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};N(x,n).then((x=>{const X=x.fileInfo.images[0].levels[0],Z=x.fileInfo.images[0].levels.length>1&&O.generateMipMaps;Q(X.width,X.height,Z,-1!==x.format,(()=>{K(O,x)}))})).catch((x=>{Z.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.g.Warn(`Failed to transcode Basis file: ${x}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);