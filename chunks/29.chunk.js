"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[29],{14066:(E,H,d)=>{var n=d(12323),Z=d(12237),I=d(12271),g=d(12350),l=d(12296),r=d(12331);l.c.prototype._partialLoadFile=function(E,H,d,n){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(E,(E=>{d[H]=E,d._internalCount++,6===d._internalCount&&n(d)}),void 0,void 0,!0,((E,H)=>{Z&&E&&Z(E.status+" "+E.statusText,H)}))},l.c.prototype._cascadeLoadFiles=function(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const Z=[];Z._internalCount=0;for(let I=0;I<6;I++)this._partialLoadFile(d[I],I,Z,H,n)},l.c.prototype._cascadeLoadImgs=function(E,H,d,n){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,I=arguments.length>5?arguments[5]:void 0;const g=[];g._internalCount=0;for(let l=0;l<6;l++)this._partialLoadImg(n[l],l,g,E,H,d,Z,I)},l.c.prototype._partialLoadImg=function(E,H,d,n,Z,l){let r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,t=arguments.length>7?arguments[7]:void 0;const S=(0,g.e)();(0,I.p)(E,(E=>{d[H]=E,d._internalCount++,n&&n.removePendingData(S),6===d._internalCount&&l&&l(Z,d)}),((E,H)=>{n&&n.removePendingData(S),r&&r(E,H)}),n?n.offlineProvider:null,t),n&&n.addPendingData(S)},l.c.prototype.createCubeTextureBase=function(E,H,d,I){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,t=arguments.length>6?arguments[6]:void 0,S=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,M=arguments.length>8&&void 0!==arguments[8]&&arguments[8],V=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,C=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,w=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,R=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,Q=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,L=arguments.length>14&&void 0!==arguments[14]&&arguments[14],D=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const e=w||new n.d(this,7);e.isCube=!0,e.url=E,e.generateMipMaps=!I,e._lodGenerationScale=V,e._lodGenerationOffset=C,e._useSRGBBuffer=!!L&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!I),e!==w&&(e.label=E.substring(0,60)),this._doNotHandleContextLost||(e._extension=S,e._files=d,e._buffer=D);const s=E;this._transformTextureUrl&&!w&&(E=this._transformTextureUrl(E));const i=S??function(E){const H=E.split("?")[0],d=H.lastIndexOf(".");return d>-1?H.substring(d).toLowerCase():""}(E),p=(0,r.c)(i),f=(E,H)=>{e.dispose(),l?l(E,H):E&&Z.b.Warn(E)},P=(n,l)=>{E===s?n&&f(n.status+" "+n.statusText,l):(Z.b.Warn(`Failed to load ${E}, falling back to the ${s}`),this.createCubeTextureBase(s,H,d,!!I,g,f,t,S,M,V,C,e,R,Q,L,D))};if(p)p.then((n=>{const Z=E=>{R&&R(e,E),n.loadCubeData(E,e,M,g,((E,H)=>{f(E,H)}))};D?Z(D):d&&6===d.length?n.supportCascades?this._cascadeLoadFiles(H,(E=>Z(E.map((E=>new Uint8Array(E))))),d,f):f("Textures type does not support cascades."):this._loadFile(E,(E=>Z(new Uint8Array(E))),void 0,void 0,!0,P)}));else{if(!d||0===d.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(H,e,((E,H)=>{Q&&Q(E,H)}),d,f)}return this._internalTexturesCache.push(e),e}},12902:(E,H,d)=>{d.d(H,{d:()=>t});var n=d(12384),Z=d(12406),I=d(12582),g=d(12391),l=d(12437);class r{constructor(E,H,d,n){this.name=E,this.worldAxisForNormal=H,this.worldAxisForFileX=d,this.worldAxisForFileY=n}}class t{static ConvertCubeMapTextureToSphericalPolynomial(E){var H;if(!E.isCube)return null;null===(H=E.fE())||void 0===H||H.getEngine().flushFramebuffer();const d=E.getSize().width,n=E.readPixels(0,void 0,void 0,!1),Z=E.readPixels(1,void 0,void 0,!1);let I,g;E.isRenderTarget?(I=E.readPixels(3,void 0,void 0,!1),g=E.readPixels(2,void 0,void 0,!1)):(I=E.readPixels(2,void 0,void 0,!1),g=E.readPixels(3,void 0,void 0,!1));const l=E.readPixels(4,void 0,void 0,!1),r=E.readPixels(5,void 0,void 0,!1),t=E.gammaSpace;let S=0;return 1!=E.textureType&&2!=E.textureType||(S=1),new Promise((E=>{Promise.all([Z,n,I,g,l,r]).then((H=>{let[n,Z,I,g,l,r]=H;const M={size:d,right:Z,left:n,up:I,down:g,front:l,back:r,format:5,type:S,gammaSpace:t};E(this.ConvertCubeMapToSphericalPolynomial(M))}))}))}static _AreaElement(E,H){return Math.atan2(E*H,Math.sqrt(E*E+H*H+1))}static ConvertCubeMapToSphericalPolynomial(E){const H=new I.b;let d=0;const n=2/E.size,r=n,t=.5*n,S=t-1;for(let I=0;I<6;I++){const M=this._FileFaces[I],V=E[M.name];let C=S;const w=5===E.format?4:3;for(let I=0;I<E.size;I++){let R=S;for(let r=0;r<E.size;r++){const S=M.worldAxisForFileX.scale(R).add(M.worldAxisForFileY.scale(C)).add(M.worldAxisForNormal);S.normalize();const Q=this._AreaElement(R-t,C-t)-this._AreaElement(R-t,C+t)-this._AreaElement(R+t,C-t)+this._AreaElement(R+t,C+t);let L=V[I*E.size*w+r*w+0],D=V[I*E.size*w+r*w+1],e=V[I*E.size*w+r*w+2];isNaN(L)&&(L=0),isNaN(D)&&(D=0),isNaN(e)&&(e=0),0===E.type&&(L/=255,D/=255,e/=255),E.gammaSpace&&(L=Math.pow((0,Z.Clamp)(L),g.n),D=Math.pow((0,Z.Clamp)(D),g.n),e=Math.pow((0,Z.Clamp)(e),g.n));const s=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const E=Math.max(L,D,e);if(E>s){const H=s/E;L*=H,D*=H,e*=H}}else L=(0,Z.Clamp)(L,0,s),D=(0,Z.Clamp)(D,0,s),e=(0,Z.Clamp)(e,0,s);const i=new l.DH(L,D,e);H.addLight(S,i,Q),d+=Q,R+=n}C+=r}}const M=6*(4*Math.PI)/6/d;return H.scaleInPlace(M),H.convertIncidentRadianceToIrradiance(),H.convertIrradianceToLambertianRadiance(),I.e.FromHarmonics(H)}}t._FileFaces=[new r("right",new n.wH(1,0,0),new n.wH(0,0,-1),new n.wH(0,-1,0)),new r("left",new n.wH(-1,0,0),new n.wH(0,0,1),new n.wH(0,-1,0)),new r("up",new n.wH(0,1,0),new n.wH(1,0,0),new n.wH(0,0,1)),new r("down",new n.wH(0,-1,0),new n.wH(1,0,0),new n.wH(0,0,-1)),new r("front",new n.wH(0,0,1),new n.wH(1,0,0),new n.wH(0,-1,0)),new r("back",new n.wH(0,0,-1),new n.wH(-1,0,0),new n.wH(0,-1,0))],t.MAX_HDRI_VALUE=4096,t.PRESERVE_CLAMPED_COLORS=!1},14839:(E,H,d)=>{d.d(H,{DDSTools:()=>w});var n=d(12406),Z=d(12237),I=d(12902),g=d(12622);d(14066);const l=131072,r=131072;function t(E){return E.charCodeAt(0)+(E.charCodeAt(1)<<8)+(E.charCodeAt(2)<<16)+(E.charCodeAt(3)<<24)}const S=t("DXT1"),M=t("DXT3"),V=t("DXT5"),C=t("DX10");class w{static GetDDSInfo(E){const H=new Int32Array(E.buffer,E.byteOffset,31),d=new Int32Array(E.buffer,E.byteOffset,35);let n=1;H[2]&l&&(n=Math.max(1,H[7]));const Z=H[21],I=Z===C?d[32]:0;let g=0;switch(Z){case 113:g=2;break;case 116:g=1;break;case C:if(10===I){g=2;break}if(2===I){g=1;break}}return{width:H[4],height:H[3],mipmapCount:n,isFourCC:4===(4&H[20]),isRGB:64===(64&H[20]),isLuminance:(H[20]&r)===r,isCube:512===(512&H[28]),isCompressed:Z===S||Z===M||Z===V,dxgiFormat:I,textureType:g}}static _GetHalfFloatAsFloatRGBAArrayBuffer(E,H,d,n,Z,I){const l=new Float32Array(n),r=new Uint16Array(Z,d);let t=0;for(let S=0;S<H;S++)for(let H=0;H<E;H++){const d=4*(H+S*E);l[t]=(0,g.i)(r[d]),l[t+1]=(0,g.i)(r[d+1]),l[t+2]=(0,g.i)(r[d+2]),w.StoreLODInAlphaChannel?l[t+3]=I:l[t+3]=(0,g.i)(r[d+3]),t+=4}return l}static _GetHalfFloatRGBAArrayBuffer(E,H,d,n,Z,I){if(w.StoreLODInAlphaChannel){const l=new Uint16Array(n),r=new Uint16Array(Z,d);let t=0;for(let d=0;d<H;d++)for(let H=0;H<E;H++){const n=4*(H+d*E);l[t]=r[n],l[t+1]=r[n+1],l[t+2]=r[n+2],l[t+3]=(0,g.r)(I),t+=4}return l}return new Uint16Array(Z,d,n)}static _GetFloatRGBAArrayBuffer(E,H,d,n,Z,I){if(w.StoreLODInAlphaChannel){const g=new Float32Array(n),l=new Float32Array(Z,d);let r=0;for(let d=0;d<H;d++)for(let H=0;H<E;H++){const n=4*(H+d*E);g[r]=l[n],g[r+1]=l[n+1],g[r+2]=l[n+2],g[r+3]=I,r+=4}return g}return new Float32Array(Z,d,n)}static _GetFloatAsHalfFloatRGBAArrayBuffer(E,H,d,n,Z,I){const l=new Uint16Array(n),r=new Float32Array(Z,d);let t=0;for(let S=0;S<H;S++)for(let H=0;H<E;H++)l[t]=(0,g.r)(r[t]),l[t+1]=(0,g.r)(r[t+1]),l[t+2]=(0,g.r)(r[t+2]),w.StoreLODInAlphaChannel?l[t+3]=(0,g.r)(I):l[t+3]=(0,g.r)(r[t+3]),t+=4;return l}static _GetFloatAsUIntRGBAArrayBuffer(E,H,d,Z,I,g){const l=new Uint8Array(Z),r=new Float32Array(I,d);let t=0;for(let S=0;S<H;S++)for(let H=0;H<E;H++){const d=4*(H+S*E);l[t]=255*(0,n.Clamp)(r[d]),l[t+1]=255*(0,n.Clamp)(r[d+1]),l[t+2]=255*(0,n.Clamp)(r[d+2]),w.StoreLODInAlphaChannel?l[t+3]=g:l[t+3]=255*(0,n.Clamp)(r[d+3]),t+=4}return l}static _GetHalfFloatAsUIntRGBAArrayBuffer(E,H,d,Z,I,l){const r=new Uint8Array(Z),t=new Uint16Array(I,d);let S=0;for(let M=0;M<H;M++)for(let H=0;H<E;H++){const d=4*(H+M*E);r[S]=255*(0,n.Clamp)((0,g.i)(t[d])),r[S+1]=255*(0,n.Clamp)((0,g.i)(t[d+1])),r[S+2]=255*(0,n.Clamp)((0,g.i)(t[d+2])),w.StoreLODInAlphaChannel?r[S+3]=l:r[S+3]=255*(0,n.Clamp)((0,g.i)(t[d+3])),S+=4}return r}static _GetRGBAArrayBuffer(E,H,d,n,Z,I,g,l,r){const t=new Uint8Array(n),S=new Uint8Array(Z,d);let M=0;for(let V=0;V<H;V++)for(let H=0;H<E;H++){const d=4*(H+V*E);t[M]=S[d+I],t[M+1]=S[d+g],t[M+2]=S[d+l],t[M+3]=S[d+r],M+=4}return t}static _ExtractLongWordOrder(E){return 0===E||255===E||-16777216===E?0:1+w._ExtractLongWordOrder(E>>8)}static _GetRGBArrayBuffer(E,H,d,n,Z,I,g,l){const r=new Uint8Array(n),t=new Uint8Array(Z,d);let S=0;for(let M=0;M<H;M++)for(let H=0;H<E;H++){const d=3*(H+M*E);r[S]=t[d+I],r[S+1]=t[d+g],r[S+2]=t[d+l],S+=3}return r}static _GetLuminanceArrayBuffer(E,H,d,n,Z){const I=new Uint8Array(n),g=new Uint8Array(Z,d);let l=0;for(let r=0;r<H;r++)for(let H=0;H<E;H++){const d=H+r*E;I[l]=g[d],l++}return I}static UploadDDSLevels(E,H,d,n,g,r){let t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,R=arguments.length>7?arguments[7]:void 0,Q=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=null;n.sphericalPolynomial&&(L=[]);const D=!!E.getCaps().s3tc;H.generateMipMaps=g;const e=new Int32Array(d.buffer,d.byteOffset,31);let s,i,p,f,P,j,X,W=0,U=0,Y=1;if(542327876!==e[0])return void Z.b.Error("Invalid magic number in DDS header");if(!n.isFourCC&&!n.isRGB&&!n.isLuminance)return void Z.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(n.isCompressed&&!D)return void Z.b.Error("Compressed textures are not supported on this platform.");let c=e[22];f=e[1]+4;let u=!1;if(n.isFourCC)switch(s=e[21],s){case S:Y=8,U=33777;break;case M:Y=16,U=33778;break;case V:Y=16,U=33779;break;case 113:u=!0,c=64;break;case 116:u=!0,c=128;break;case C:{f+=20;let E=!1;switch(n.dxgiFormat){case 10:u=!0,c=64,E=!0;break;case 2:u=!0,c=128,E=!0;break;case 88:n.isRGB=!0,n.isFourCC=!1,c=32,E=!0}if(E)break}default:return void Z.b.Error(["Unsupported FourCC code:",(o=s,String.fromCharCode(255&o,o>>8&255,o>>16&255,o>>24&255))])}var o;const F=w._ExtractLongWordOrder(e[23]),a=w._ExtractLongWordOrder(e[24]),k=w._ExtractLongWordOrder(e[25]),O=w._ExtractLongWordOrder(e[26]);u&&(U=E._getRGBABufferInternalSizedFormat(n.textureType)),j=1,e[2]&l&&!1!==g&&(j=Math.max(1,e[7]));const G=R||0,x=E.getCaps();for(let Z=G;Z<r;Z++){for(i=e[4],p=e[3],X=0;X<j;++X){if(-1===t||t===X){const I=-1===t?X:0;if(!n.isCompressed&&n.isFourCC){H.format=5,W=i*p*4;let n=null;if(E._badOS||E._badDesktopOS||!x.textureHalfFloat&&!x.textureFloat)128===c?(n=w._GetFloatAsUIntRGBAArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,I),L&&0==I&&L.push(w._GetFloatRGBAArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,I))):64===c&&(n=w._GetHalfFloatAsUIntRGBAArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,I),L&&0==I&&L.push(w._GetHalfFloatAsFloatRGBAArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,I))),H.type=0;else{const E=x.textureFloat&&(Q&&x.textureFloatLinearFiltering||!Q),Z=x.textureHalfFloat&&(Q&&x.textureHalfFloatLinearFiltering||!Q),g=(128===c||64===c&&!Z)&&E?1:(64===c||128===c&&!E)&&Z?2:0;let l,r=null;if(128===c)switch(g){case 1:l=w._GetFloatRGBAArrayBuffer,r=null;break;case 2:l=w._GetFloatAsHalfFloatRGBAArrayBuffer,r=w._GetFloatRGBAArrayBuffer;break;case 0:l=w._GetFloatAsUIntRGBAArrayBuffer,r=w._GetFloatRGBAArrayBuffer}else switch(g){case 1:l=w._GetHalfFloatAsFloatRGBAArrayBuffer,r=null;break;case 2:l=w._GetHalfFloatRGBAArrayBuffer,r=w._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:l=w._GetHalfFloatAsUIntRGBAArrayBuffer,r=w._GetHalfFloatAsFloatRGBAArrayBuffer}H.type=g,n=l(i,p,d.byteOffset+f,W,d.buffer,I),L&&0==I&&L.push(r?r(i,p,d.byteOffset+f,W,d.buffer,I):n)}n&&E._uploadDataToTextureDirectly(H,n,Z,I)}else if(n.isRGB)H.type=0,24===c?(H.format=4,W=i*p*3,P=w._GetRGBArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,F,a,k),E._uploadDataToTextureDirectly(H,P,Z,I)):(H.format=5,W=i*p*4,P=w._GetRGBAArrayBuffer(i,p,d.byteOffset+f,W,d.buffer,F,a,k,O),E._uploadDataToTextureDirectly(H,P,Z,I));else if(n.isLuminance){const n=E._getUnpackAlignement(),g=i;W=Math.floor((i+n-1)/n)*n*(p-1)+g,P=w._GetLuminanceArrayBuffer(i,p,d.byteOffset+f,W,d.buffer),H.format=1,H.type=0,E._uploadDataToTextureDirectly(H,P,Z,I)}else W=Math.max(4,i)/4*Math.max(4,p)/4*Y,P=new Uint8Array(d.buffer,d.byteOffset+f,W),H.type=0,E._uploadCompressedDataToTextureDirectly(H,U,i,p,P,Z,I)}f+=c?i*p*(c/8):W,i*=.5,p*=.5,i=Math.max(1,i),p=Math.max(1,p)}if(void 0!==R)break}L&&L.length>0?n.sphericalPolynomial=I.d.ConvertCubeMapToSphericalPolynomial({size:e[4],right:L[0],left:L[1],up:L[2],down:L[3],front:L[4],back:L[5],format:5,type:1,gammaSpace:!1}):n.sphericalPolynomial=void 0}}w.StoreLODInAlphaChannel=!1}}]);