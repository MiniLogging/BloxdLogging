"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[29],{12803:(N,q,C)=>{var d=C(11055),U=C(10962),W=C(11e3),a=C(11083),F=C(11032),w=C(11065);F.b.prototype._partialLoadFile=function(N,q,C,d){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(N,(N=>{C[q]=N,C._internalCount++,6===C._internalCount&&d(C)}),void 0,void 0,!0,((N,q)=>{U&&N&&U(N.status+" "+N.statusText,q)}))},F.b.prototype._cascadeLoadFiles=function(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const U=[];U._internalCount=0;for(let W=0;W<6;W++)this._partialLoadFile(C[W],W,U,q,d)},F.b.prototype._cascadeLoadImgs=function(N,q,C,d){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,W=arguments.length>5?arguments[5]:void 0;const a=[];a._internalCount=0;for(let F=0;F<6;F++)this._partialLoadImg(d[F],F,a,N,q,C,U,W)},F.b.prototype._partialLoadImg=function(N,q,C,d,U,F){let w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,A=arguments.length>7?arguments[7]:void 0;const n=(0,a.d)();(0,W.s)(N,(N=>{C[q]=N,C._internalCount++,d&&d.removePendingData(n),6===C._internalCount&&F&&F(U,C)}),((N,q)=>{d&&d.removePendingData(n),w&&w(N,q)}),d?d.offlineProvider:null,A),d&&d.addPendingData(n)},F.b.prototype.createCubeTextureBase=function(N,q,C,W){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,A=arguments.length>6?arguments[6]:void 0,n=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,t=arguments.length>8&&void 0!==arguments[8]&&arguments[8],V=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,Z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,J=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,Q=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,v=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,r=arguments.length>14&&void 0!==arguments[14]&&arguments[14],O=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const K=J||new d.e(this,7);K.isCube=!0,K.url=N,K.generateMipMaps=!W,K._lodGenerationScale=V,K._lodGenerationOffset=Z,K._useSRGBBuffer=!!r&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!W),K!==J&&(K.label=N.substring(0,60)),this._doNotHandleContextLost||(K._extension=n,K._files=C,K._buffer=O);const i=N;this._transformTextureUrl&&!J&&(N=this._transformTextureUrl(N));const I=n??function(N){const q=N.split("?")[0],C=q.lastIndexOf(".");return C>-1?q.substring(C).toLowerCase():""}(N),j=(0,w.b)(I),l=(N,q)=>{K.dispose(),F?F(N,q):N&&U.c.Warn(N)},T=(d,F)=>{N===i?d&&l(d.status+" "+d.statusText,F):(U.c.Warn(`Failed to load ${N}, falling back to the ${i}`),this.createCubeTextureBase(i,q,C,!!W,a,l,A,n,t,V,Z,K,Q,v,r,O))};if(j)j.then((d=>{const U=N=>{Q&&Q(K,N),d.loadCubeData(N,K,t,a,((N,q)=>{l(N,q)}))};O?U(O):C&&6===C.length?d.supportCascades?this._cascadeLoadFiles(q,(N=>U(N.map((N=>new Uint8Array(N))))),C,l):l("Textures type does not support cascades."):this._loadFile(N,(N=>U(new Uint8Array(N))),void 0,void 0,!0,T)}));else{if(!C||0===C.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(q,K,((N,q)=>{v&&v(N,q)}),C,l)}return this._internalTexturesCache.push(K),K}},11643:(N,q,C)=>{C.d(q,{e:()=>A});var d=C(11122),U=C(11142),W=C(11316),a=C(11129),F=C(11167);class w{constructor(N,q,C,d){this.name=N,this.worldAxisForNormal=q,this.worldAxisForFileX=C,this.worldAxisForFileY=d}}class A{static ConvertCubeMapTextureToSphericalPolynomial(N){var q;if(!N.isCube)return null;null===(q=N.lN())||void 0===q||q.getEngine().flushFramebuffer();const C=N.getSize().width,d=N.readPixels(0,void 0,void 0,!1),U=N.readPixels(1,void 0,void 0,!1);let W,a;N.isRenderTarget?(W=N.readPixels(3,void 0,void 0,!1),a=N.readPixels(2,void 0,void 0,!1)):(W=N.readPixels(2,void 0,void 0,!1),a=N.readPixels(3,void 0,void 0,!1));const F=N.readPixels(4,void 0,void 0,!1),w=N.readPixels(5,void 0,void 0,!1),A=N.gammaSpace;let n=0;return 1!=N.textureType&&2!=N.textureType||(n=1),new Promise((N=>{Promise.all([U,d,W,a,F,w]).then((q=>{let[d,U,W,a,F,w]=q;const t={size:C,right:U,left:d,up:W,down:a,front:F,back:w,format:5,type:n,gammaSpace:A};N(this.ConvertCubeMapToSphericalPolynomial(t))}))}))}static _AreaElement(N,q){return Math.atan2(N*q,Math.sqrt(N*N+q*q+1))}static ConvertCubeMapToSphericalPolynomial(N){const q=new W.c;let C=0;const d=2/N.size,w=d,A=.5*d,n=A-1;for(let W=0;W<6;W++){const t=this._FileFaces[W],V=N[t.name];let Z=n;const J=5===N.format?4:3;for(let W=0;W<N.size;W++){let Q=n;for(let w=0;w<N.size;w++){const n=t.worldAxisForFileX.scale(Q).add(t.worldAxisForFileY.scale(Z)).add(t.worldAxisForNormal);n.normalize();const v=this._AreaElement(Q-A,Z-A)-this._AreaElement(Q-A,Z+A)-this._AreaElement(Q+A,Z-A)+this._AreaElement(Q+A,Z+A);let r=V[W*N.size*J+w*J+0],O=V[W*N.size*J+w*J+1],K=V[W*N.size*J+w*J+2];isNaN(r)&&(r=0),isNaN(O)&&(O=0),isNaN(K)&&(K=0),0===N.type&&(r/=255,O/=255,K/=255),N.gammaSpace&&(r=Math.pow((0,U.Clamp)(r),a.m),O=Math.pow((0,U.Clamp)(O),a.m),K=Math.pow((0,U.Clamp)(K),a.m));const i=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const N=Math.max(r,O,K);if(N>i){const q=i/N;r*=q,O*=q,K*=q}}else r=(0,U.Clamp)(r,0,i),O=(0,U.Clamp)(O,0,i),K=(0,U.Clamp)(K,0,i);const I=new F.Oq(r,O,K);q.addLight(n,I,v),C+=v,Q+=d}Z+=w}}const t=6*(4*Math.PI)/6/C;return q.scaleInPlace(t),q.convertIncidentRadianceToIrradiance(),q.convertIrradianceToLambertianRadiance(),W.g.FromHarmonics(q)}}A._FileFaces=[new w("right",new d.Jq(1,0,0),new d.Jq(0,0,-1),new d.Jq(0,-1,0)),new w("left",new d.Jq(-1,0,0),new d.Jq(0,0,1),new d.Jq(0,-1,0)),new w("up",new d.Jq(0,1,0),new d.Jq(1,0,0),new d.Jq(0,0,1)),new w("down",new d.Jq(0,-1,0),new d.Jq(1,0,0),new d.Jq(0,0,-1)),new w("front",new d.Jq(0,0,1),new d.Jq(1,0,0),new d.Jq(0,-1,0)),new w("back",new d.Jq(0,0,-1),new d.Jq(-1,0,0),new d.Jq(0,-1,0))],A.MAX_HDRI_VALUE=4096,A.PRESERVE_CLAMPED_COLORS=!1},13534:(N,q,C)=>{C.d(q,{DDSTools:()=>J});var d=C(11142),U=C(10962),W=C(11643),a=C(11356);C(12803);const F=131072,w=131072;function A(N){return N.charCodeAt(0)+(N.charCodeAt(1)<<8)+(N.charCodeAt(2)<<16)+(N.charCodeAt(3)<<24)}const n=A("DXT1"),t=A("DXT3"),V=A("DXT5"),Z=A("DX10");class J{static GetDDSInfo(N){const q=new Int32Array(N.buffer,N.byteOffset,31),C=new Int32Array(N.buffer,N.byteOffset,35);let d=1;q[2]&F&&(d=Math.max(1,q[7]));const U=q[21],W=U===Z?C[32]:0;let a=0;switch(U){case 113:a=2;break;case 116:a=1;break;case Z:if(10===W){a=2;break}if(2===W){a=1;break}}return{width:q[4],height:q[3],mipmapCount:d,isFourCC:4===(4&q[20]),isRGB:64===(64&q[20]),isLuminance:(q[20]&w)===w,isCube:512===(512&q[28]),isCompressed:U===n||U===t||U===V,dxgiFormat:W,textureType:a}}static _GetHalfFloatAsFloatRGBAArrayBuffer(N,q,C,d,U,W){const F=new Float32Array(d),w=new Uint16Array(U,C);let A=0;for(let n=0;n<q;n++)for(let q=0;q<N;q++){const C=4*(q+n*N);F[A]=(0,a.e)(w[C]),F[A+1]=(0,a.e)(w[C+1]),F[A+2]=(0,a.e)(w[C+2]),J.StoreLODInAlphaChannel?F[A+3]=W:F[A+3]=(0,a.e)(w[C+3]),A+=4}return F}static _GetHalfFloatRGBAArrayBuffer(N,q,C,d,U,W){if(J.StoreLODInAlphaChannel){const F=new Uint16Array(d),w=new Uint16Array(U,C);let A=0;for(let C=0;C<q;C++)for(let q=0;q<N;q++){const d=4*(q+C*N);F[A]=w[d],F[A+1]=w[d+1],F[A+2]=w[d+2],F[A+3]=(0,a.q)(W),A+=4}return F}return new Uint16Array(U,C,d)}static _GetFloatRGBAArrayBuffer(N,q,C,d,U,W){if(J.StoreLODInAlphaChannel){const a=new Float32Array(d),F=new Float32Array(U,C);let w=0;for(let C=0;C<q;C++)for(let q=0;q<N;q++){const d=4*(q+C*N);a[w]=F[d],a[w+1]=F[d+1],a[w+2]=F[d+2],a[w+3]=W,w+=4}return a}return new Float32Array(U,C,d)}static _GetFloatAsHalfFloatRGBAArrayBuffer(N,q,C,d,U,W){const F=new Uint16Array(d),w=new Float32Array(U,C);let A=0;for(let n=0;n<q;n++)for(let q=0;q<N;q++)F[A]=(0,a.q)(w[A]),F[A+1]=(0,a.q)(w[A+1]),F[A+2]=(0,a.q)(w[A+2]),J.StoreLODInAlphaChannel?F[A+3]=(0,a.q)(W):F[A+3]=(0,a.q)(w[A+3]),A+=4;return F}static _GetFloatAsUIntRGBAArrayBuffer(N,q,C,U,W,a){const F=new Uint8Array(U),w=new Float32Array(W,C);let A=0;for(let n=0;n<q;n++)for(let q=0;q<N;q++){const C=4*(q+n*N);F[A]=255*(0,d.Clamp)(w[C]),F[A+1]=255*(0,d.Clamp)(w[C+1]),F[A+2]=255*(0,d.Clamp)(w[C+2]),J.StoreLODInAlphaChannel?F[A+3]=a:F[A+3]=255*(0,d.Clamp)(w[C+3]),A+=4}return F}static _GetHalfFloatAsUIntRGBAArrayBuffer(N,q,C,U,W,F){const w=new Uint8Array(U),A=new Uint16Array(W,C);let n=0;for(let t=0;t<q;t++)for(let q=0;q<N;q++){const C=4*(q+t*N);w[n]=255*(0,d.Clamp)((0,a.e)(A[C])),w[n+1]=255*(0,d.Clamp)((0,a.e)(A[C+1])),w[n+2]=255*(0,d.Clamp)((0,a.e)(A[C+2])),J.StoreLODInAlphaChannel?w[n+3]=F:w[n+3]=255*(0,d.Clamp)((0,a.e)(A[C+3])),n+=4}return w}static _GetRGBAArrayBuffer(N,q,C,d,U,W,a,F,w){const A=new Uint8Array(d),n=new Uint8Array(U,C);let t=0;for(let V=0;V<q;V++)for(let q=0;q<N;q++){const C=4*(q+V*N);A[t]=n[C+W],A[t+1]=n[C+a],A[t+2]=n[C+F],A[t+3]=n[C+w],t+=4}return A}static _ExtractLongWordOrder(N){return 0===N||255===N||-16777216===N?0:1+J._ExtractLongWordOrder(N>>8)}static _GetRGBArrayBuffer(N,q,C,d,U,W,a,F){const w=new Uint8Array(d),A=new Uint8Array(U,C);let n=0;for(let t=0;t<q;t++)for(let q=0;q<N;q++){const C=3*(q+t*N);w[n]=A[C+W],w[n+1]=A[C+a],w[n+2]=A[C+F],n+=3}return w}static _GetLuminanceArrayBuffer(N,q,C,d,U){const W=new Uint8Array(d),a=new Uint8Array(U,C);let F=0;for(let w=0;w<q;w++)for(let q=0;q<N;q++){const C=q+w*N;W[F]=a[C],F++}return W}static UploadDDSLevels(N,q,C,d,a,w){let A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,Q=arguments.length>7?arguments[7]:void 0,v=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],r=null;d.sphericalPolynomial&&(r=[]);const O=!!N.getCaps().s3tc;q.generateMipMaps=a;const K=new Int32Array(C.buffer,C.byteOffset,31);let i,I,j,l,T,z,p,s=0,X=0,P=1;if(542327876!==K[0])return void U.c.Error("Invalid magic number in DDS header");if(!d.isFourCC&&!d.isRGB&&!d.isLuminance)return void U.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(d.isCompressed&&!O)return void U.c.Error("Compressed textures are not supported on this platform.");let M=K[22];l=K[1]+4;let Y=!1;if(d.isFourCC)switch(i=K[21],i){case n:P=8,X=33777;break;case t:P=16,X=33778;break;case V:P=16,X=33779;break;case 113:Y=!0,M=64;break;case 116:Y=!0,M=128;break;case Z:{l+=20;let N=!1;switch(d.dxgiFormat){case 10:Y=!0,M=64,N=!0;break;case 2:Y=!0,M=128,N=!0;break;case 88:d.isRGB=!0,d.isFourCC=!1,M=32,N=!0}if(N)break}default:return void U.c.Error(["Unsupported FourCC code:",(E=i,String.fromCharCode(255&E,E>>8&255,E>>16&255,E>>24&255))])}var E;const H=J._ExtractLongWordOrder(K[23]),e=J._ExtractLongWordOrder(K[24]),b=J._ExtractLongWordOrder(K[25]),o=J._ExtractLongWordOrder(K[26]);Y&&(X=N._getRGBABufferInternalSizedFormat(d.textureType)),z=1,K[2]&F&&!1!==a&&(z=Math.max(1,K[7]));const S=Q||0,D=N.getCaps();for(let U=S;U<w;U++){for(I=K[4],j=K[3],p=0;p<z;++p){if(-1===A||A===p){const W=-1===A?p:0;if(!d.isCompressed&&d.isFourCC){q.format=5,s=I*j*4;let d=null;if(N._badOS||N._badDesktopOS||!D.textureHalfFloat&&!D.textureFloat)128===M?(d=J._GetFloatAsUIntRGBAArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,W),r&&0==W&&r.push(J._GetFloatRGBAArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,W))):64===M&&(d=J._GetHalfFloatAsUIntRGBAArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,W),r&&0==W&&r.push(J._GetHalfFloatAsFloatRGBAArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,W))),q.type=0;else{const N=D.textureFloat&&(v&&D.textureFloatLinearFiltering||!v),U=D.textureHalfFloat&&(v&&D.textureHalfFloatLinearFiltering||!v),a=(128===M||64===M&&!U)&&N?1:(64===M||128===M&&!N)&&U?2:0;let F,w=null;if(128===M)switch(a){case 1:F=J._GetFloatRGBAArrayBuffer,w=null;break;case 2:F=J._GetFloatAsHalfFloatRGBAArrayBuffer,w=J._GetFloatRGBAArrayBuffer;break;case 0:F=J._GetFloatAsUIntRGBAArrayBuffer,w=J._GetFloatRGBAArrayBuffer}else switch(a){case 1:F=J._GetHalfFloatAsFloatRGBAArrayBuffer,w=null;break;case 2:F=J._GetHalfFloatRGBAArrayBuffer,w=J._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:F=J._GetHalfFloatAsUIntRGBAArrayBuffer,w=J._GetHalfFloatAsFloatRGBAArrayBuffer}q.type=a,d=F(I,j,C.byteOffset+l,s,C.buffer,W),r&&0==W&&r.push(w?w(I,j,C.byteOffset+l,s,C.buffer,W):d)}d&&N._uploadDataToTextureDirectly(q,d,U,W)}else if(d.isRGB)q.type=0,24===M?(q.format=4,s=I*j*3,T=J._GetRGBArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,H,e,b),N._uploadDataToTextureDirectly(q,T,U,W)):(q.format=5,s=I*j*4,T=J._GetRGBAArrayBuffer(I,j,C.byteOffset+l,s,C.buffer,H,e,b,o),N._uploadDataToTextureDirectly(q,T,U,W));else if(d.isLuminance){const d=N._getUnpackAlignement(),a=I;s=Math.floor((I+d-1)/d)*d*(j-1)+a,T=J._GetLuminanceArrayBuffer(I,j,C.byteOffset+l,s,C.buffer),q.format=1,q.type=0,N._uploadDataToTextureDirectly(q,T,U,W)}else s=Math.max(4,I)/4*Math.max(4,j)/4*P,T=new Uint8Array(C.buffer,C.byteOffset+l,s),q.type=0,N._uploadCompressedDataToTextureDirectly(q,X,I,j,T,U,W)}l+=M?I*j*(M/8):s,I*=.5,j*=.5,I=Math.max(1,I),j=Math.max(1,j)}if(void 0!==Q)break}r&&r.length>0?d.sphericalPolynomial=W.e.ConvertCubeMapToSphericalPolynomial({size:K[4],right:r[0],left:r[1],up:r[2],down:r[3],front:r[4],back:r[5],format:5,type:1,gammaSpace:!1}):d.sphericalPolynomial=void 0}}J.StoreLODInAlphaChannel=!1}}]);