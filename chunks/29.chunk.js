"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[29],{12786:(I,E,j)=>{var e=j(11056),w=j(10974),z=j(11e3),h=j(11080),t=j(11033),U=j(11063);t.c.prototype._partialLoadFile=function(I,E,j,e){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(I,(I=>{j[E]=I,j._internalCount++,6===j._internalCount&&e(j)}),void 0,void 0,!0,((I,E)=>{w&&I&&w(I.status+" "+I.statusText,E)}))},t.c.prototype._cascadeLoadFiles=function(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const w=[];w._internalCount=0;for(let z=0;z<6;z++)this._partialLoadFile(j[z],z,w,E,e)},t.c.prototype._cascadeLoadImgs=function(I,E,j,e){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,z=arguments.length>5?arguments[5]:void 0;const h=[];h._internalCount=0;for(let t=0;t<6;t++)this._partialLoadImg(e[t],t,h,I,E,j,w,z)},t.c.prototype._partialLoadImg=function(I,E,j,e,w,t){let U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,R=arguments.length>7?arguments[7]:void 0;const P=(0,h.d)();(0,z.n)(I,(I=>{j[E]=I,j._internalCount++,e&&e.removePendingData(P),6===j._internalCount&&t&&t(w,j)}),((I,E)=>{e&&e.removePendingData(P),U&&U(I,E)}),e?e.offlineProvider:null,R),e&&e.addPendingData(P)},t.c.prototype.createCubeTextureBase=function(I,E,j,z){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,R=arguments.length>6?arguments[6]:void 0,P=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,o=arguments.length>8&&void 0!==arguments[8]&&arguments[8],Z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,c=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,K=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,L=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,F=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,C=arguments.length>14&&void 0!==arguments[14]&&arguments[14],X=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const q=K||new e.e(this,7);q.isCube=!0,q.url=I,q.generateMipMaps=!z,q._lodGenerationScale=Z,q._lodGenerationOffset=c,q._useSRGBBuffer=!!C&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!z),q!==K&&(q.label=I.substring(0,60)),this._doNotHandleContextLost||(q._extension=P,q._files=j,q._buffer=X);const x=I;this._transformTextureUrl&&!K&&(I=this._transformTextureUrl(I));const u=P??function(I){const E=I.split("?")[0],j=E.lastIndexOf(".");return j>-1?E.substring(j).toLowerCase():""}(I),b=(0,U.b)(u),Q=(I,E)=>{q.dispose(),t?t(I,E):I&&w.b.Warn(I)},G=(e,t)=>{I===x?e&&Q(e.status+" "+e.statusText,t):(w.b.Warn(`Failed to load ${I}, falling back to the ${x}`),this.createCubeTextureBase(x,E,j,!!z,h,Q,R,P,o,Z,c,q,L,F,C,X))};if(b)b.then((e=>{const w=I=>{L&&L(q,I),e.loadCubeData(I,q,o,h,((I,E)=>{Q(I,E)}))};X?w(X):j&&6===j.length?e.supportCascades?this._cascadeLoadFiles(E,(I=>w(I.map((I=>new Uint8Array(I))))),j,Q):Q("Textures type does not support cascades."):this._loadFile(I,(I=>w(new Uint8Array(I))),void 0,void 0,!0,G)}));else{if(!j||0===j.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(E,q,((I,E)=>{F&&F(I,E)}),j,Q)}return this._internalTexturesCache.push(q),q}},11632:(I,E,j)=>{j.d(E,{c:()=>R});var e=j(11117),w=j(11136),z=j(11307),h=j(11120),t=j(11165);class U{constructor(I,E,j,e){this.name=I,this.worldAxisForNormal=E,this.worldAxisForFileX=j,this.worldAxisForFileY=e}}class R{static ConvertCubeMapTextureToSphericalPolynomial(I){var E;if(!I.isCube)return null;null===(E=I.GI())||void 0===E||E.getEngine().flushFramebuffer();const j=I.getSize().width,e=I.readPixels(0,void 0,void 0,!1),w=I.readPixels(1,void 0,void 0,!1);let z,h;I.isRenderTarget?(z=I.readPixels(3,void 0,void 0,!1),h=I.readPixels(2,void 0,void 0,!1)):(z=I.readPixels(2,void 0,void 0,!1),h=I.readPixels(3,void 0,void 0,!1));const t=I.readPixels(4,void 0,void 0,!1),U=I.readPixels(5,void 0,void 0,!1),R=I.gammaSpace;let P=0;return 1!=I.textureType&&2!=I.textureType||(P=1),new Promise((I=>{Promise.all([w,e,z,h,t,U]).then((E=>{let[e,w,z,h,t,U]=E;const o={size:j,right:w,left:e,up:z,down:h,front:t,back:U,format:5,type:P,gammaSpace:R};I(this.ConvertCubeMapToSphericalPolynomial(o))}))}))}static _AreaElement(I,E){return Math.atan2(I*E,Math.sqrt(I*I+E*E+1))}static ConvertCubeMapToSphericalPolynomial(I){const E=new z.b;let j=0;const e=2/I.size,U=e,R=.5*e,P=R-1;for(let z=0;z<6;z++){const o=this._FileFaces[z],Z=I[o.name];let c=P;const K=5===I.format?4:3;for(let z=0;z<I.size;z++){let L=P;for(let U=0;U<I.size;U++){const P=o.worldAxisForFileX.scale(L).add(o.worldAxisForFileY.scale(c)).add(o.worldAxisForNormal);P.normalize();const F=this._AreaElement(L-R,c-R)-this._AreaElement(L-R,c+R)-this._AreaElement(L+R,c-R)+this._AreaElement(L+R,c+R);let C=Z[z*I.size*K+U*K+0],X=Z[z*I.size*K+U*K+1],q=Z[z*I.size*K+U*K+2];isNaN(C)&&(C=0),isNaN(X)&&(X=0),isNaN(q)&&(q=0),0===I.type&&(C/=255,X/=255,q/=255),I.gammaSpace&&(C=Math.pow((0,w.Clamp)(C),h.l),X=Math.pow((0,w.Clamp)(X),h.l),q=Math.pow((0,w.Clamp)(q),h.l));const x=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const I=Math.max(C,X,q);if(I>x){const E=x/I;C*=E,X*=E,q*=E}}else C=(0,w.Clamp)(C,0,x),X=(0,w.Clamp)(X,0,x),q=(0,w.Clamp)(q,0,x);const u=new t.qE(C,X,q);E.addLight(P,u,F),j+=F,L+=e}c+=U}}const o=6*(4*Math.PI)/6/j;return E.scaleInPlace(o),E.convertIncidentRadianceToIrradiance(),E.convertIrradianceToLambertianRadiance(),z.d.FromHarmonics(E)}}R._FileFaces=[new U("right",new e.LE(1,0,0),new e.LE(0,0,-1),new e.LE(0,-1,0)),new U("left",new e.LE(-1,0,0),new e.LE(0,0,1),new e.LE(0,-1,0)),new U("up",new e.LE(0,1,0),new e.LE(1,0,0),new e.LE(0,0,1)),new U("down",new e.LE(0,-1,0),new e.LE(1,0,0),new e.LE(0,0,-1)),new U("front",new e.LE(0,0,1),new e.LE(1,0,0),new e.LE(0,-1,0)),new U("back",new e.LE(0,0,-1),new e.LE(-1,0,0),new e.LE(0,-1,0))],R.MAX_HDRI_VALUE=4096,R.PRESERVE_CLAMPED_COLORS=!1},13557:(I,E,j)=>{j.d(E,{DDSTools:()=>K});var e=j(11136),w=j(10974),z=j(11632),h=j(11348);j(12786);const t=131072,U=131072;function R(I){return I.charCodeAt(0)+(I.charCodeAt(1)<<8)+(I.charCodeAt(2)<<16)+(I.charCodeAt(3)<<24)}const P=R("DXT1"),o=R("DXT3"),Z=R("DXT5"),c=R("DX10");class K{static GetDDSInfo(I){const E=new Int32Array(I.buffer,I.byteOffset,31),j=new Int32Array(I.buffer,I.byteOffset,35);let e=1;E[2]&t&&(e=Math.max(1,E[7]));const w=E[21],z=w===c?j[32]:0;let h=0;switch(w){case 113:h=2;break;case 116:h=1;break;case c:if(10===z){h=2;break}if(2===z){h=1;break}}return{width:E[4],height:E[3],mipmapCount:e,isFourCC:4===(4&E[20]),isRGB:64===(64&E[20]),isLuminance:(E[20]&U)===U,isCube:512===(512&E[28]),isCompressed:w===P||w===o||w===Z,dxgiFormat:z,textureType:h}}static _GetHalfFloatAsFloatRGBAArrayBuffer(I,E,j,e,w,z){const t=new Float32Array(e),U=new Uint16Array(w,j);let R=0;for(let P=0;P<E;P++)for(let E=0;E<I;E++){const j=4*(E+P*I);t[R]=(0,h.g)(U[j]),t[R+1]=(0,h.g)(U[j+1]),t[R+2]=(0,h.g)(U[j+2]),K.StoreLODInAlphaChannel?t[R+3]=z:t[R+3]=(0,h.g)(U[j+3]),R+=4}return t}static _GetHalfFloatRGBAArrayBuffer(I,E,j,e,w,z){if(K.StoreLODInAlphaChannel){const t=new Uint16Array(e),U=new Uint16Array(w,j);let R=0;for(let j=0;j<E;j++)for(let E=0;E<I;E++){const e=4*(E+j*I);t[R]=U[e],t[R+1]=U[e+1],t[R+2]=U[e+2],t[R+3]=(0,h.m)(z),R+=4}return t}return new Uint16Array(w,j,e)}static _GetFloatRGBAArrayBuffer(I,E,j,e,w,z){if(K.StoreLODInAlphaChannel){const h=new Float32Array(e),t=new Float32Array(w,j);let U=0;for(let j=0;j<E;j++)for(let E=0;E<I;E++){const e=4*(E+j*I);h[U]=t[e],h[U+1]=t[e+1],h[U+2]=t[e+2],h[U+3]=z,U+=4}return h}return new Float32Array(w,j,e)}static _GetFloatAsHalfFloatRGBAArrayBuffer(I,E,j,e,w,z){const t=new Uint16Array(e),U=new Float32Array(w,j);let R=0;for(let P=0;P<E;P++)for(let E=0;E<I;E++)t[R]=(0,h.m)(U[R]),t[R+1]=(0,h.m)(U[R+1]),t[R+2]=(0,h.m)(U[R+2]),K.StoreLODInAlphaChannel?t[R+3]=(0,h.m)(z):t[R+3]=(0,h.m)(U[R+3]),R+=4;return t}static _GetFloatAsUIntRGBAArrayBuffer(I,E,j,w,z,h){const t=new Uint8Array(w),U=new Float32Array(z,j);let R=0;for(let P=0;P<E;P++)for(let E=0;E<I;E++){const j=4*(E+P*I);t[R]=255*(0,e.Clamp)(U[j]),t[R+1]=255*(0,e.Clamp)(U[j+1]),t[R+2]=255*(0,e.Clamp)(U[j+2]),K.StoreLODInAlphaChannel?t[R+3]=h:t[R+3]=255*(0,e.Clamp)(U[j+3]),R+=4}return t}static _GetHalfFloatAsUIntRGBAArrayBuffer(I,E,j,w,z,t){const U=new Uint8Array(w),R=new Uint16Array(z,j);let P=0;for(let o=0;o<E;o++)for(let E=0;E<I;E++){const j=4*(E+o*I);U[P]=255*(0,e.Clamp)((0,h.g)(R[j])),U[P+1]=255*(0,e.Clamp)((0,h.g)(R[j+1])),U[P+2]=255*(0,e.Clamp)((0,h.g)(R[j+2])),K.StoreLODInAlphaChannel?U[P+3]=t:U[P+3]=255*(0,e.Clamp)((0,h.g)(R[j+3])),P+=4}return U}static _GetRGBAArrayBuffer(I,E,j,e,w,z,h,t,U){const R=new Uint8Array(e),P=new Uint8Array(w,j);let o=0;for(let Z=0;Z<E;Z++)for(let E=0;E<I;E++){const j=4*(E+Z*I);R[o]=P[j+z],R[o+1]=P[j+h],R[o+2]=P[j+t],R[o+3]=P[j+U],o+=4}return R}static _ExtractLongWordOrder(I){return 0===I||255===I||-16777216===I?0:1+K._ExtractLongWordOrder(I>>8)}static _GetRGBArrayBuffer(I,E,j,e,w,z,h,t){const U=new Uint8Array(e),R=new Uint8Array(w,j);let P=0;for(let o=0;o<E;o++)for(let E=0;E<I;E++){const j=3*(E+o*I);U[P]=R[j+z],U[P+1]=R[j+h],U[P+2]=R[j+t],P+=3}return U}static _GetLuminanceArrayBuffer(I,E,j,e,w){const z=new Uint8Array(e),h=new Uint8Array(w,j);let t=0;for(let U=0;U<E;U++)for(let E=0;E<I;E++){const j=E+U*I;z[t]=h[j],t++}return z}static UploadDDSLevels(I,E,j,e,h,U){let R=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,L=arguments.length>7?arguments[7]:void 0,F=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],C=null;e.sphericalPolynomial&&(C=[]);const X=!!I.getCaps().s3tc;E.generateMipMaps=h;const q=new Int32Array(j.buffer,j.byteOffset,31);let x,u,b,Q,G,y,d,a=0,l=0,i=1;if(542327876!==q[0])return void w.b.Error("Invalid magic number in DDS header");if(!e.isFourCC&&!e.isRGB&&!e.isLuminance)return void w.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(e.isCompressed&&!X)return void w.b.Error("Compressed textures are not supported on this platform.");let r=q[22];Q=q[1]+4;let n=!1;if(e.isFourCC)switch(x=q[21],x){case P:i=8,l=33777;break;case o:i=16,l=33778;break;case Z:i=16,l=33779;break;case 113:n=!0,r=64;break;case 116:n=!0,r=128;break;case c:{Q+=20;let I=!1;switch(e.dxgiFormat){case 10:n=!0,r=64,I=!0;break;case 2:n=!0,r=128,I=!0;break;case 88:e.isRGB=!0,e.isFourCC=!1,r=32,I=!0}if(I)break}default:return void w.b.Error(["Unsupported FourCC code:",(H=x,String.fromCharCode(255&H,H>>8&255,H>>16&255,H>>24&255))])}var H;const g=K._ExtractLongWordOrder(q[23]),Y=K._ExtractLongWordOrder(q[24]),A=K._ExtractLongWordOrder(q[25]),T=K._ExtractLongWordOrder(q[26]);n&&(l=I._getRGBABufferInternalSizedFormat(e.textureType)),y=1,q[2]&t&&!1!==h&&(y=Math.max(1,q[7]));const M=L||0,W=I.getCaps();for(let w=M;w<U;w++){for(u=q[4],b=q[3],d=0;d<y;++d){if(-1===R||R===d){const z=-1===R?d:0;if(!e.isCompressed&&e.isFourCC){E.format=5,a=u*b*4;let e=null;if(I._badOS||I._badDesktopOS||!W.textureHalfFloat&&!W.textureFloat)128===r?(e=K._GetFloatAsUIntRGBAArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,z),C&&0==z&&C.push(K._GetFloatRGBAArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,z))):64===r&&(e=K._GetHalfFloatAsUIntRGBAArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,z),C&&0==z&&C.push(K._GetHalfFloatAsFloatRGBAArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,z))),E.type=0;else{const I=W.textureFloat&&(F&&W.textureFloatLinearFiltering||!F),w=W.textureHalfFloat&&(F&&W.textureHalfFloatLinearFiltering||!F),h=(128===r||64===r&&!w)&&I?1:(64===r||128===r&&!I)&&w?2:0;let t,U=null;if(128===r)switch(h){case 1:t=K._GetFloatRGBAArrayBuffer,U=null;break;case 2:t=K._GetFloatAsHalfFloatRGBAArrayBuffer,U=K._GetFloatRGBAArrayBuffer;break;case 0:t=K._GetFloatAsUIntRGBAArrayBuffer,U=K._GetFloatRGBAArrayBuffer}else switch(h){case 1:t=K._GetHalfFloatAsFloatRGBAArrayBuffer,U=null;break;case 2:t=K._GetHalfFloatRGBAArrayBuffer,U=K._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:t=K._GetHalfFloatAsUIntRGBAArrayBuffer,U=K._GetHalfFloatAsFloatRGBAArrayBuffer}E.type=h,e=t(u,b,j.byteOffset+Q,a,j.buffer,z),C&&0==z&&C.push(U?U(u,b,j.byteOffset+Q,a,j.buffer,z):e)}e&&I._uploadDataToTextureDirectly(E,e,w,z)}else if(e.isRGB)E.type=0,24===r?(E.format=4,a=u*b*3,G=K._GetRGBArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,g,Y,A),I._uploadDataToTextureDirectly(E,G,w,z)):(E.format=5,a=u*b*4,G=K._GetRGBAArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer,g,Y,A,T),I._uploadDataToTextureDirectly(E,G,w,z));else if(e.isLuminance){const e=I._getUnpackAlignement(),h=u;a=Math.floor((u+e-1)/e)*e*(b-1)+h,G=K._GetLuminanceArrayBuffer(u,b,j.byteOffset+Q,a,j.buffer),E.format=1,E.type=0,I._uploadDataToTextureDirectly(E,G,w,z)}else a=Math.max(4,u)/4*Math.max(4,b)/4*i,G=new Uint8Array(j.buffer,j.byteOffset+Q,a),E.type=0,I._uploadCompressedDataToTextureDirectly(E,l,u,b,G,w,z)}Q+=r?u*b*(r/8):a,u*=.5,b*=.5,u=Math.max(1,u),b=Math.max(1,b)}if(void 0!==L)break}C&&C.length>0?e.sphericalPolynomial=z.c.ConvertCubeMapToSphericalPolynomial({size:q[4],right:C[0],left:C[1],up:C[2],down:C[3],front:C[4],back:C[5],format:5,type:1,gammaSpace:!1}):e.sphericalPolynomial=void 0}}K.StoreLODInAlphaChannel=!1}}]);