"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[29],{12787:(P,e,n)=>{var H=n(11079),S=n(10988),p=n(11019),k=n(11102),m=n(11051),t=n(11085);m.b.prototype._partialLoadFile=function(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(P,(P=>{n[e]=P,n._internalCount++,6===n._internalCount&&H(n)}),void 0,void 0,!0,((P,e)=>{S&&P&&S(P.status+" "+P.statusText,e)}))},m.b.prototype._cascadeLoadFiles=function(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const S=[];S._internalCount=0;for(let p=0;p<6;p++)this._partialLoadFile(n[p],p,S,e,H)},m.b.prototype._cascadeLoadImgs=function(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,p=arguments.length>5?arguments[5]:void 0;const k=[];k._internalCount=0;for(let m=0;m<6;m++)this._partialLoadImg(H[m],m,k,P,e,n,S,p)},m.b.prototype._partialLoadImg=function(P,e,n,H,S,m){let t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,C=arguments.length>7?arguments[7]:void 0;const R=(0,k.c)();(0,p.r)(P,(P=>{n[e]=P,n._internalCount++,H&&H.removePendingData(R),6===n._internalCount&&m&&m(S,n)}),((P,e)=>{H&&H.removePendingData(R),t&&t(P,e)}),H?H.offlineProvider:null,C),H&&H.addPendingData(R)},m.b.prototype.createCubeTextureBase=function(P,e,n,p){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,C=arguments.length>6?arguments[6]:void 0,R=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],A=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,F=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Y=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,j=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,z=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,w=arguments.length>14&&void 0!==arguments[14]&&arguments[14],J=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const I=Y||new H.b(this,7);I.isCube=!0,I.url=P,I.generateMipMaps=!p,I._lodGenerationScale=A,I._lodGenerationOffset=F,I._useSRGBBuffer=!!w&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!p),I!==Y&&(I.label=P.substring(0,60)),this._doNotHandleContextLost||(I._extension=R,I._files=n,I._buffer=J);const O=P;this._transformTextureUrl&&!Y&&(P=this._transformTextureUrl(P));const V=R??function(P){const e=P.split("?")[0],n=e.lastIndexOf(".");return n>-1?e.substring(n).toLowerCase():""}(P),i=(0,t.b)(V),B=(P,e)=>{I.dispose(),m?m(P,e):P&&S.c.Warn(P)},l=(H,m)=>{P===O?H&&B(H.status+" "+H.statusText,m):(S.c.Warn(`Failed to load ${P}, falling back to the ${O}`),this.createCubeTextureBase(O,e,n,!!p,k,B,C,R,q,A,F,I,j,z,w,J))};if(i)i.then((H=>{const S=P=>{j&&j(I,P),H.loadCubeData(P,I,q,k,((P,e)=>{B(P,e)}))};J?S(J):n&&6===n.length?H.supportCascades?this._cascadeLoadFiles(e,(P=>S(P.map((P=>new Uint8Array(P))))),n,B):B("Textures type does not support cascades."):this._loadFile(P,(P=>S(new Uint8Array(P))),void 0,void 0,!0,l)}));else{if(!n||0===n.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(e,I,((P,e)=>{z&&z(P,e)}),n,B)}return this._internalTexturesCache.push(I),I}},11635:(P,e,n)=>{n.d(e,{e:()=>C});var H=n(11133),S=n(11148),p=n(11338),k=n(11140),m=n(11183);class t{constructor(P,e,n,H){this.name=P,this.worldAxisForNormal=e,this.worldAxisForFileX=n,this.worldAxisForFileY=H}}class C{static ConvertCubeMapTextureToSphericalPolynomial(P){var e;if(!P.isCube)return null;null===(e=P.BP())||void 0===e||e.getEngine().flushFramebuffer();const n=P.getSize().width,H=P.readPixels(0,void 0,void 0,!1),S=P.readPixels(1,void 0,void 0,!1);let p,k;P.isRenderTarget?(p=P.readPixels(3,void 0,void 0,!1),k=P.readPixels(2,void 0,void 0,!1)):(p=P.readPixels(2,void 0,void 0,!1),k=P.readPixels(3,void 0,void 0,!1));const m=P.readPixels(4,void 0,void 0,!1),t=P.readPixels(5,void 0,void 0,!1),C=P.gammaSpace;let R=0;return 1!=P.textureType&&2!=P.textureType||(R=1),new Promise((P=>{Promise.all([S,H,p,k,m,t]).then((e=>{let[H,S,p,k,m,t]=e;const q={size:n,right:S,left:H,up:p,down:k,front:m,back:t,format:5,type:R,gammaSpace:C};P(this.ConvertCubeMapToSphericalPolynomial(q))}))}))}static _AreaElement(P,e){return Math.atan2(P*e,Math.sqrt(P*P+e*e+1))}static ConvertCubeMapToSphericalPolynomial(P){const e=new p.c;let n=0;const H=2/P.size,t=H,C=.5*H,R=C-1;for(let p=0;p<6;p++){const q=this._FileFaces[p],A=P[q.name];let F=R;const Y=5===P.format?4:3;for(let p=0;p<P.size;p++){let j=R;for(let t=0;t<P.size;t++){const R=q.worldAxisForFileX.scale(j).add(q.worldAxisForFileY.scale(F)).add(q.worldAxisForNormal);R.normalize();const z=this._AreaElement(j-C,F-C)-this._AreaElement(j-C,F+C)-this._AreaElement(j+C,F-C)+this._AreaElement(j+C,F+C);let w=A[p*P.size*Y+t*Y+0],J=A[p*P.size*Y+t*Y+1],I=A[p*P.size*Y+t*Y+2];isNaN(w)&&(w=0),isNaN(J)&&(J=0),isNaN(I)&&(I=0),0===P.type&&(w/=255,J/=255,I/=255),P.gammaSpace&&(w=Math.pow((0,S.Clamp)(w),k.i),J=Math.pow((0,S.Clamp)(J),k.i),I=Math.pow((0,S.Clamp)(I),k.i));const O=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const P=Math.max(w,J,I);if(P>O){const e=O/P;w*=e,J*=e,I*=e}}else w=(0,S.Clamp)(w,0,O),J=(0,S.Clamp)(J,0,O),I=(0,S.Clamp)(I,0,O);const V=new m.Ne(w,J,I);e.addLight(R,V,z),n+=z,j+=H}F+=t}}const q=6*(4*Math.PI)/6/n;return e.scaleInPlace(q),e.convertIncidentRadianceToIrradiance(),e.convertIrradianceToLambertianRadiance(),p.d.FromHarmonics(e)}}C._FileFaces=[new t("right",new H.Ie(1,0,0),new H.Ie(0,0,-1),new H.Ie(0,-1,0)),new t("left",new H.Ie(-1,0,0),new H.Ie(0,0,1),new H.Ie(0,-1,0)),new t("up",new H.Ie(0,1,0),new H.Ie(1,0,0),new H.Ie(0,0,1)),new t("down",new H.Ie(0,-1,0),new H.Ie(1,0,0),new H.Ie(0,0,-1)),new t("front",new H.Ie(0,0,1),new H.Ie(1,0,0),new H.Ie(0,-1,0)),new t("back",new H.Ie(0,0,-1),new H.Ie(-1,0,0),new H.Ie(0,-1,0))],C.MAX_HDRI_VALUE=4096,C.PRESERVE_CLAMPED_COLORS=!1},13537:(P,e,n)=>{n.d(e,{DDSTools:()=>Y});var H=n(11148),S=n(10988),p=n(11635),k=n(11364);n(12787);const m=131072,t=131072;function C(P){return P.charCodeAt(0)+(P.charCodeAt(1)<<8)+(P.charCodeAt(2)<<16)+(P.charCodeAt(3)<<24)}const R=C("DXT1"),q=C("DXT3"),A=C("DXT5"),F=C("DX10");class Y{static GetDDSInfo(P){const e=new Int32Array(P.buffer,P.byteOffset,31),n=new Int32Array(P.buffer,P.byteOffset,35);let H=1;e[2]&m&&(H=Math.max(1,e[7]));const S=e[21],p=S===F?n[32]:0;let k=0;switch(S){case 113:k=2;break;case 116:k=1;break;case F:if(10===p){k=2;break}if(2===p){k=1;break}}return{width:e[4],height:e[3],mipmapCount:H,isFourCC:4===(4&e[20]),isRGB:64===(64&e[20]),isLuminance:(e[20]&t)===t,isCube:512===(512&e[28]),isCompressed:S===R||S===q||S===A,dxgiFormat:p,textureType:k}}static _GetHalfFloatAsFloatRGBAArrayBuffer(P,e,n,H,S,p){const m=new Float32Array(H),t=new Uint16Array(S,n);let C=0;for(let R=0;R<e;R++)for(let e=0;e<P;e++){const n=4*(e+R*P);m[C]=(0,k.f)(t[n]),m[C+1]=(0,k.f)(t[n+1]),m[C+2]=(0,k.f)(t[n+2]),Y.StoreLODInAlphaChannel?m[C+3]=p:m[C+3]=(0,k.f)(t[n+3]),C+=4}return m}static _GetHalfFloatRGBAArrayBuffer(P,e,n,H,S,p){if(Y.StoreLODInAlphaChannel){const m=new Uint16Array(H),t=new Uint16Array(S,n);let C=0;for(let n=0;n<e;n++)for(let e=0;e<P;e++){const H=4*(e+n*P);m[C]=t[H],m[C+1]=t[H+1],m[C+2]=t[H+2],m[C+3]=(0,k.m)(p),C+=4}return m}return new Uint16Array(S,n,H)}static _GetFloatRGBAArrayBuffer(P,e,n,H,S,p){if(Y.StoreLODInAlphaChannel){const k=new Float32Array(H),m=new Float32Array(S,n);let t=0;for(let n=0;n<e;n++)for(let e=0;e<P;e++){const H=4*(e+n*P);k[t]=m[H],k[t+1]=m[H+1],k[t+2]=m[H+2],k[t+3]=p,t+=4}return k}return new Float32Array(S,n,H)}static _GetFloatAsHalfFloatRGBAArrayBuffer(P,e,n,H,S,p){const m=new Uint16Array(H),t=new Float32Array(S,n);let C=0;for(let R=0;R<e;R++)for(let e=0;e<P;e++)m[C]=(0,k.m)(t[C]),m[C+1]=(0,k.m)(t[C+1]),m[C+2]=(0,k.m)(t[C+2]),Y.StoreLODInAlphaChannel?m[C+3]=(0,k.m)(p):m[C+3]=(0,k.m)(t[C+3]),C+=4;return m}static _GetFloatAsUIntRGBAArrayBuffer(P,e,n,S,p,k){const m=new Uint8Array(S),t=new Float32Array(p,n);let C=0;for(let R=0;R<e;R++)for(let e=0;e<P;e++){const n=4*(e+R*P);m[C]=255*(0,H.Clamp)(t[n]),m[C+1]=255*(0,H.Clamp)(t[n+1]),m[C+2]=255*(0,H.Clamp)(t[n+2]),Y.StoreLODInAlphaChannel?m[C+3]=k:m[C+3]=255*(0,H.Clamp)(t[n+3]),C+=4}return m}static _GetHalfFloatAsUIntRGBAArrayBuffer(P,e,n,S,p,m){const t=new Uint8Array(S),C=new Uint16Array(p,n);let R=0;for(let q=0;q<e;q++)for(let e=0;e<P;e++){const n=4*(e+q*P);t[R]=255*(0,H.Clamp)((0,k.f)(C[n])),t[R+1]=255*(0,H.Clamp)((0,k.f)(C[n+1])),t[R+2]=255*(0,H.Clamp)((0,k.f)(C[n+2])),Y.StoreLODInAlphaChannel?t[R+3]=m:t[R+3]=255*(0,H.Clamp)((0,k.f)(C[n+3])),R+=4}return t}static _GetRGBAArrayBuffer(P,e,n,H,S,p,k,m,t){const C=new Uint8Array(H),R=new Uint8Array(S,n);let q=0;for(let A=0;A<e;A++)for(let e=0;e<P;e++){const n=4*(e+A*P);C[q]=R[n+p],C[q+1]=R[n+k],C[q+2]=R[n+m],C[q+3]=R[n+t],q+=4}return C}static _ExtractLongWordOrder(P){return 0===P||255===P||-16777216===P?0:1+Y._ExtractLongWordOrder(P>>8)}static _GetRGBArrayBuffer(P,e,n,H,S,p,k,m){const t=new Uint8Array(H),C=new Uint8Array(S,n);let R=0;for(let q=0;q<e;q++)for(let e=0;e<P;e++){const n=3*(e+q*P);t[R]=C[n+p],t[R+1]=C[n+k],t[R+2]=C[n+m],R+=3}return t}static _GetLuminanceArrayBuffer(P,e,n,H,S){const p=new Uint8Array(H),k=new Uint8Array(S,n);let m=0;for(let t=0;t<e;t++)for(let e=0;e<P;e++){const n=e+t*P;p[m]=k[n],m++}return p}static UploadDDSLevels(P,e,n,H,k,t){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,j=arguments.length>7?arguments[7]:void 0,z=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],w=null;H.sphericalPolynomial&&(w=[]);const J=!!P.getCaps().s3tc;e.generateMipMaps=k;const I=new Int32Array(n.buffer,n.byteOffset,31);let O,V,i,B,l,b,T,d=0,N=0,Q=1;if(542327876!==I[0])return void S.c.Error("Invalid magic number in DDS header");if(!H.isFourCC&&!H.isRGB&&!H.isLuminance)return void S.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(H.isCompressed&&!J)return void S.c.Error("Compressed textures are not supported on this platform.");let c=I[22];B=I[1]+4;let r=!1;if(H.isFourCC)switch(O=I[21],O){case R:Q=8,N=33777;break;case q:Q=16,N=33778;break;case A:Q=16,N=33779;break;case 113:r=!0,c=64;break;case 116:r=!0,c=128;break;case F:{B+=20;let P=!1;switch(H.dxgiFormat){case 10:r=!0,c=64,P=!0;break;case 2:r=!0,c=128,P=!0;break;case 88:H.isRGB=!0,H.isFourCC=!1,c=32,P=!0}if(P)break}default:return void S.c.Error(["Unsupported FourCC code:",(o=O,String.fromCharCode(255&o,o>>8&255,o>>16&255,o>>24&255))])}var o;const G=Y._ExtractLongWordOrder(I[23]),g=Y._ExtractLongWordOrder(I[24]),y=Y._ExtractLongWordOrder(I[25]),f=Y._ExtractLongWordOrder(I[26]);r&&(N=P._getRGBABufferInternalSizedFormat(H.textureType)),b=1,I[2]&m&&!1!==k&&(b=Math.max(1,I[7]));const Z=j||0,v=P.getCaps();for(let S=Z;S<t;S++){for(V=I[4],i=I[3],T=0;T<b;++T){if(-1===C||C===T){const p=-1===C?T:0;if(!H.isCompressed&&H.isFourCC){e.format=5,d=V*i*4;let H=null;if(P._badOS||P._badDesktopOS||!v.textureHalfFloat&&!v.textureFloat)128===c?(H=Y._GetFloatAsUIntRGBAArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,p),w&&0==p&&w.push(Y._GetFloatRGBAArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,p))):64===c&&(H=Y._GetHalfFloatAsUIntRGBAArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,p),w&&0==p&&w.push(Y._GetHalfFloatAsFloatRGBAArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,p))),e.type=0;else{const P=v.textureFloat&&(z&&v.textureFloatLinearFiltering||!z),S=v.textureHalfFloat&&(z&&v.textureHalfFloatLinearFiltering||!z),k=(128===c||64===c&&!S)&&P?1:(64===c||128===c&&!P)&&S?2:0;let m,t=null;if(128===c)switch(k){case 1:m=Y._GetFloatRGBAArrayBuffer,t=null;break;case 2:m=Y._GetFloatAsHalfFloatRGBAArrayBuffer,t=Y._GetFloatRGBAArrayBuffer;break;case 0:m=Y._GetFloatAsUIntRGBAArrayBuffer,t=Y._GetFloatRGBAArrayBuffer}else switch(k){case 1:m=Y._GetHalfFloatAsFloatRGBAArrayBuffer,t=null;break;case 2:m=Y._GetHalfFloatRGBAArrayBuffer,t=Y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:m=Y._GetHalfFloatAsUIntRGBAArrayBuffer,t=Y._GetHalfFloatAsFloatRGBAArrayBuffer}e.type=k,H=m(V,i,n.byteOffset+B,d,n.buffer,p),w&&0==p&&w.push(t?t(V,i,n.byteOffset+B,d,n.buffer,p):H)}H&&P._uploadDataToTextureDirectly(e,H,S,p)}else if(H.isRGB)e.type=0,24===c?(e.format=4,d=V*i*3,l=Y._GetRGBArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,G,g,y),P._uploadDataToTextureDirectly(e,l,S,p)):(e.format=5,d=V*i*4,l=Y._GetRGBAArrayBuffer(V,i,n.byteOffset+B,d,n.buffer,G,g,y,f),P._uploadDataToTextureDirectly(e,l,S,p));else if(H.isLuminance){const H=P._getUnpackAlignement(),k=V;d=Math.floor((V+H-1)/H)*H*(i-1)+k,l=Y._GetLuminanceArrayBuffer(V,i,n.byteOffset+B,d,n.buffer),e.format=1,e.type=0,P._uploadDataToTextureDirectly(e,l,S,p)}else d=Math.max(4,V)/4*Math.max(4,i)/4*Q,l=new Uint8Array(n.buffer,n.byteOffset+B,d),e.type=0,P._uploadCompressedDataToTextureDirectly(e,N,V,i,l,S,p)}B+=c?V*i*(c/8):d,V*=.5,i*=.5,V=Math.max(1,V),i=Math.max(1,i)}if(void 0!==j)break}w&&w.length>0?H.sphericalPolynomial=p.e.ConvertCubeMapToSphericalPolynomial({size:I[4],right:w[0],left:w[1],up:w[2],down:w[3],front:w[4],back:w[5],format:5,type:1,gammaSpace:!1}):H.sphericalPolynomial=void 0}}Y.StoreLODInAlphaChannel=!1}}]);