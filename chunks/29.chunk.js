"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[29],{13426:(Z,h,V)=>{var v=V(11673),A=V(11580),H=V(11602),K=V(11700),d=V(11635),a=V(11683);d.d.prototype._partialLoadFile=function(Z,h,V,v){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(Z,(Z=>{V[h]=Z,V._internalCount++,6===V._internalCount&&v(V)}),void 0,void 0,!0,((Z,h)=>{A&&Z&&A(Z.status+" "+Z.statusText,h)}))},d.d.prototype._cascadeLoadFiles=function(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const A=[];A._internalCount=0;for(let H=0;H<6;H++)this._partialLoadFile(V[H],H,A,h,v)},d.d.prototype._cascadeLoadImgs=function(Z,h,V,v){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,H=arguments.length>5?arguments[5]:void 0;const K=[];K._internalCount=0;for(let d=0;d<6;d++)this._partialLoadImg(v[d],d,K,Z,h,V,A,H)},d.d.prototype._partialLoadImg=function(Z,h,V,v,A,d){let a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,n=arguments.length>7?arguments[7]:void 0;const x=(0,K.e)();(0,H.u)(Z,(Z=>{V[h]=Z,V._internalCount++,v&&v.removePendingData(x),6===V._internalCount&&d&&d(A,V)}),((Z,h)=>{v&&v.removePendingData(x),a&&a(Z,h)}),v?v.offlineProvider:null,n),v&&v.addPendingData(x)},d.d.prototype.createCubeTextureBase=function(Z,h,V,H){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,n=arguments.length>6?arguments[6]:void 0,x=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,N=arguments.length>8&&void 0!==arguments[8]&&arguments[8],D=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,k=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,u=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,F=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,b=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,o=arguments.length>14&&void 0!==arguments[14]&&arguments[14],q=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const X=u||new v.c(this,7);X.isCube=!0,X.url=Z,X.generateMipMaps=!H,X._lodGenerationScale=D,X._lodGenerationOffset=k,X._useSRGBBuffer=!!o&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!H),X!==u&&(X.label=Z.substring(0,60)),this._doNotHandleContextLost||(X._extension=x,X._files=V,X._buffer=q);const E=Z;this._transformTextureUrl&&!u&&(Z=this._transformTextureUrl(Z));const j=x??function(Z){const h=Z.split("?")[0],V=h.lastIndexOf(".");return V>-1?h.substring(V).toLowerCase():""}(Z),P=(0,a.b)(j),C=(Z,h)=>{X.dispose(),d?d(Z,h):Z&&A.b.Warn(Z)},l=(v,d)=>{Z===E?v&&C(v.status+" "+v.statusText,d):(A.b.Warn(`Failed to load ${Z}, falling back to the ${E}`),this.createCubeTextureBase(E,h,V,!!H,K,C,n,x,N,D,k,X,F,b,o,q))};if(P)P.then((v=>{const A=Z=>{F&&F(X,Z),v.loadCubeData(Z,X,N,K,((Z,h)=>{C(Z,h)}))};q?A(q):V&&6===V.length?v.supportCascades?this._cascadeLoadFiles(h,(Z=>A(Z.map((Z=>new Uint8Array(Z))))),V,C):C("Textures type does not support cascades."):this._loadFile(Z,(Z=>A(new Uint8Array(Z))),void 0,void 0,!0,l)}));else{if(!V||0===V.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(h,X,((Z,h)=>{b&&b(Z,h)}),V,C)}return this._internalTexturesCache.push(X),X}},12260:(Z,h,V)=>{V.d(h,{c:()=>n});var v=V(11729),A=V(11748),H=V(11925),K=V(11737),d=V(11781);class a{constructor(Z,h,V,v){this.name=Z,this.worldAxisForNormal=h,this.worldAxisForFileX=V,this.worldAxisForFileY=v}}class n{static ConvertCubeMapTextureToSphericalPolynomial(Z){var h;if(!Z.isCube)return null;null===(h=Z.CZ())||void 0===h||h.getEngine().flushFramebuffer();const V=Z.getSize().width,v=Z.readPixels(0,void 0,void 0,!1),A=Z.readPixels(1,void 0,void 0,!1);let H,K;Z.isRenderTarget?(H=Z.readPixels(3,void 0,void 0,!1),K=Z.readPixels(2,void 0,void 0,!1)):(H=Z.readPixels(2,void 0,void 0,!1),K=Z.readPixels(3,void 0,void 0,!1));const d=Z.readPixels(4,void 0,void 0,!1),a=Z.readPixels(5,void 0,void 0,!1),n=Z.gammaSpace;let x=0;return 1!=Z.textureType&&2!=Z.textureType||(x=1),new Promise((Z=>{Promise.all([A,v,H,K,d,a]).then((h=>{let[v,A,H,K,d,a]=h;const N={size:V,right:A,left:v,up:H,down:K,front:d,back:a,format:5,type:x,gammaSpace:n};Z(this.ConvertCubeMapToSphericalPolynomial(N))}))}))}static _AreaElement(Z,h){return Math.atan2(Z*h,Math.sqrt(Z*Z+h*h+1))}static ConvertCubeMapToSphericalPolynomial(Z){const h=new H.d;let V=0;const v=2/Z.size,a=v,n=.5*v,x=n-1;for(let H=0;H<6;H++){const N=this._FileFaces[H],D=Z[N.name];let k=x;const u=5===Z.format?4:3;for(let H=0;H<Z.size;H++){let F=x;for(let a=0;a<Z.size;a++){const x=N.worldAxisForFileX.scale(F).add(N.worldAxisForFileY.scale(k)).add(N.worldAxisForNormal);x.normalize();const b=this._AreaElement(F-n,k-n)-this._AreaElement(F-n,k+n)-this._AreaElement(F+n,k-n)+this._AreaElement(F+n,k+n);let o=D[H*Z.size*u+a*u+0],q=D[H*Z.size*u+a*u+1],X=D[H*Z.size*u+a*u+2];isNaN(o)&&(o=0),isNaN(q)&&(q=0),isNaN(X)&&(X=0),0===Z.type&&(o/=255,q/=255,X/=255),Z.gammaSpace&&(o=Math.pow((0,A.Clamp)(o),K.k),q=Math.pow((0,A.Clamp)(q),K.k),X=Math.pow((0,A.Clamp)(X),K.k));const E=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const Z=Math.max(o,q,X);if(Z>E){const h=E/Z;o*=h,q*=h,X*=h}}else o=(0,A.Clamp)(o,0,E),q=(0,A.Clamp)(q,0,E),X=(0,A.Clamp)(X,0,E);const j=new d.Ih(o,q,X);h.addLight(x,j,b),V+=b,F+=v}k+=a}}const N=6*(4*Math.PI)/6/V;return h.scaleInPlace(N),h.convertIncidentRadianceToIrradiance(),h.convertIrradianceToLambertianRadiance(),H.g.FromHarmonics(h)}}n._FileFaces=[new a("right",new v.Ch(1,0,0),new v.Ch(0,0,-1),new v.Ch(0,-1,0)),new a("left",new v.Ch(-1,0,0),new v.Ch(0,0,1),new v.Ch(0,-1,0)),new a("up",new v.Ch(0,1,0),new v.Ch(1,0,0),new v.Ch(0,0,1)),new a("down",new v.Ch(0,-1,0),new v.Ch(1,0,0),new v.Ch(0,0,-1)),new a("front",new v.Ch(0,0,1),new v.Ch(1,0,0),new v.Ch(0,-1,0)),new a("back",new v.Ch(0,0,-1),new v.Ch(-1,0,0),new v.Ch(0,-1,0))],n.MAX_HDRI_VALUE=4096,n.PRESERVE_CLAMPED_COLORS=!1},14246:(Z,h,V)=>{V.d(h,{DDSTools:()=>u});var v=V(11748),A=V(11580),H=V(12260),K=V(11975);V(13426);const d=131072,a=131072;function n(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}const x=n("DXT1"),N=n("DXT3"),D=n("DXT5"),k=n("DX10");class u{static GetDDSInfo(Z){const h=new Int32Array(Z.buffer,Z.byteOffset,31),V=new Int32Array(Z.buffer,Z.byteOffset,35);let v=1;h[2]&d&&(v=Math.max(1,h[7]));const A=h[21],H=A===k?V[32]:0;let K=0;switch(A){case 113:K=2;break;case 116:K=1;break;case k:if(10===H){K=2;break}if(2===H){K=1;break}}return{width:h[4],height:h[3],mipmapCount:v,isFourCC:4===(4&h[20]),isRGB:64===(64&h[20]),isLuminance:(h[20]&a)===a,isCube:512===(512&h[28]),isCompressed:A===x||A===N||A===D,dxgiFormat:H,textureType:K}}static _GetHalfFloatAsFloatRGBAArrayBuffer(Z,h,V,v,A,H){const d=new Float32Array(v),a=new Uint16Array(A,V);let n=0;for(let x=0;x<h;x++)for(let h=0;h<Z;h++){const V=4*(h+x*Z);d[n]=(0,K.c)(a[V]),d[n+1]=(0,K.c)(a[V+1]),d[n+2]=(0,K.c)(a[V+2]),u.StoreLODInAlphaChannel?d[n+3]=H:d[n+3]=(0,K.c)(a[V+3]),n+=4}return d}static _GetHalfFloatRGBAArrayBuffer(Z,h,V,v,A,H){if(u.StoreLODInAlphaChannel){const d=new Uint16Array(v),a=new Uint16Array(A,V);let n=0;for(let V=0;V<h;V++)for(let h=0;h<Z;h++){const v=4*(h+V*Z);d[n]=a[v],d[n+1]=a[v+1],d[n+2]=a[v+2],d[n+3]=(0,K.k)(H),n+=4}return d}return new Uint16Array(A,V,v)}static _GetFloatRGBAArrayBuffer(Z,h,V,v,A,H){if(u.StoreLODInAlphaChannel){const K=new Float32Array(v),d=new Float32Array(A,V);let a=0;for(let V=0;V<h;V++)for(let h=0;h<Z;h++){const v=4*(h+V*Z);K[a]=d[v],K[a+1]=d[v+1],K[a+2]=d[v+2],K[a+3]=H,a+=4}return K}return new Float32Array(A,V,v)}static _GetFloatAsHalfFloatRGBAArrayBuffer(Z,h,V,v,A,H){const d=new Uint16Array(v),a=new Float32Array(A,V);let n=0;for(let x=0;x<h;x++)for(let h=0;h<Z;h++)d[n]=(0,K.k)(a[n]),d[n+1]=(0,K.k)(a[n+1]),d[n+2]=(0,K.k)(a[n+2]),u.StoreLODInAlphaChannel?d[n+3]=(0,K.k)(H):d[n+3]=(0,K.k)(a[n+3]),n+=4;return d}static _GetFloatAsUIntRGBAArrayBuffer(Z,h,V,A,H,K){const d=new Uint8Array(A),a=new Float32Array(H,V);let n=0;for(let x=0;x<h;x++)for(let h=0;h<Z;h++){const V=4*(h+x*Z);d[n]=255*(0,v.Clamp)(a[V]),d[n+1]=255*(0,v.Clamp)(a[V+1]),d[n+2]=255*(0,v.Clamp)(a[V+2]),u.StoreLODInAlphaChannel?d[n+3]=K:d[n+3]=255*(0,v.Clamp)(a[V+3]),n+=4}return d}static _GetHalfFloatAsUIntRGBAArrayBuffer(Z,h,V,A,H,d){const a=new Uint8Array(A),n=new Uint16Array(H,V);let x=0;for(let N=0;N<h;N++)for(let h=0;h<Z;h++){const V=4*(h+N*Z);a[x]=255*(0,v.Clamp)((0,K.c)(n[V])),a[x+1]=255*(0,v.Clamp)((0,K.c)(n[V+1])),a[x+2]=255*(0,v.Clamp)((0,K.c)(n[V+2])),u.StoreLODInAlphaChannel?a[x+3]=d:a[x+3]=255*(0,v.Clamp)((0,K.c)(n[V+3])),x+=4}return a}static _GetRGBAArrayBuffer(Z,h,V,v,A,H,K,d,a){const n=new Uint8Array(v),x=new Uint8Array(A,V);let N=0;for(let D=0;D<h;D++)for(let h=0;h<Z;h++){const V=4*(h+D*Z);n[N]=x[V+H],n[N+1]=x[V+K],n[N+2]=x[V+d],n[N+3]=x[V+a],N+=4}return n}static _ExtractLongWordOrder(Z){return 0===Z||255===Z||-16777216===Z?0:1+u._ExtractLongWordOrder(Z>>8)}static _GetRGBArrayBuffer(Z,h,V,v,A,H,K,d){const a=new Uint8Array(v),n=new Uint8Array(A,V);let x=0;for(let N=0;N<h;N++)for(let h=0;h<Z;h++){const V=3*(h+N*Z);a[x]=n[V+H],a[x+1]=n[V+K],a[x+2]=n[V+d],x+=3}return a}static _GetLuminanceArrayBuffer(Z,h,V,v,A){const H=new Uint8Array(v),K=new Uint8Array(A,V);let d=0;for(let a=0;a<h;a++)for(let h=0;h<Z;h++){const V=h+a*Z;H[d]=K[V],d++}return H}static UploadDDSLevels(Z,h,V,v,K,a){let n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,F=arguments.length>7?arguments[7]:void 0,b=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],o=null;v.sphericalPolynomial&&(o=[]);const q=!!Z.getCaps().s3tc;h.generateMipMaps=K;const X=new Int32Array(V.buffer,V.byteOffset,31);let E,j,P,C,l,B,S,r=0,L=0,y=1;if(542327876!==X[0])return void A.b.Error("Invalid magic number in DDS header");if(!v.isFourCC&&!v.isRGB&&!v.isLuminance)return void A.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(v.isCompressed&&!q)return void A.b.Error("Compressed textures are not supported on this platform.");let W=X[22];C=X[1]+4;let z=!1;if(v.isFourCC)switch(E=X[21],E){case x:y=8,L=33777;break;case N:y=16,L=33778;break;case D:y=16,L=33779;break;case 113:z=!0,W=64;break;case 116:z=!0,W=128;break;case k:{C+=20;let Z=!1;switch(v.dxgiFormat){case 10:z=!0,W=64,Z=!0;break;case 2:z=!0,W=128,Z=!0;break;case 88:v.isRGB=!0,v.isFourCC=!1,W=32,Z=!0}if(Z)break}default:return void A.b.Error(["Unsupported FourCC code:",(m=E,String.fromCharCode(255&m,m>>8&255,m>>16&255,m>>24&255))])}var m;const g=u._ExtractLongWordOrder(X[23]),I=u._ExtractLongWordOrder(X[24]),e=u._ExtractLongWordOrder(X[25]),U=u._ExtractLongWordOrder(X[26]);z&&(L=Z._getRGBABufferInternalSizedFormat(v.textureType)),B=1,X[2]&d&&!1!==K&&(B=Math.max(1,X[7]));const R=F||0,Q=Z.getCaps();for(let A=R;A<a;A++){for(j=X[4],P=X[3],S=0;S<B;++S){if(-1===n||n===S){const H=-1===n?S:0;if(!v.isCompressed&&v.isFourCC){h.format=5,r=j*P*4;let v=null;if(Z._badOS||Z._badDesktopOS||!Q.textureHalfFloat&&!Q.textureFloat)128===W?(v=u._GetFloatAsUIntRGBAArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,H),o&&0==H&&o.push(u._GetFloatRGBAArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,H))):64===W&&(v=u._GetHalfFloatAsUIntRGBAArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,H),o&&0==H&&o.push(u._GetHalfFloatAsFloatRGBAArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,H))),h.type=0;else{const Z=Q.textureFloat&&(b&&Q.textureFloatLinearFiltering||!b),A=Q.textureHalfFloat&&(b&&Q.textureHalfFloatLinearFiltering||!b),K=(128===W||64===W&&!A)&&Z?1:(64===W||128===W&&!Z)&&A?2:0;let d,a=null;if(128===W)switch(K){case 1:d=u._GetFloatRGBAArrayBuffer,a=null;break;case 2:d=u._GetFloatAsHalfFloatRGBAArrayBuffer,a=u._GetFloatRGBAArrayBuffer;break;case 0:d=u._GetFloatAsUIntRGBAArrayBuffer,a=u._GetFloatRGBAArrayBuffer}else switch(K){case 1:d=u._GetHalfFloatAsFloatRGBAArrayBuffer,a=null;break;case 2:d=u._GetHalfFloatRGBAArrayBuffer,a=u._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:d=u._GetHalfFloatAsUIntRGBAArrayBuffer,a=u._GetHalfFloatAsFloatRGBAArrayBuffer}h.type=K,v=d(j,P,V.byteOffset+C,r,V.buffer,H),o&&0==H&&o.push(a?a(j,P,V.byteOffset+C,r,V.buffer,H):v)}v&&Z._uploadDataToTextureDirectly(h,v,A,H)}else if(v.isRGB)h.type=0,24===W?(h.format=4,r=j*P*3,l=u._GetRGBArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,g,I,e),Z._uploadDataToTextureDirectly(h,l,A,H)):(h.format=5,r=j*P*4,l=u._GetRGBAArrayBuffer(j,P,V.byteOffset+C,r,V.buffer,g,I,e,U),Z._uploadDataToTextureDirectly(h,l,A,H));else if(v.isLuminance){const v=Z._getUnpackAlignement(),K=j;r=Math.floor((j+v-1)/v)*v*(P-1)+K,l=u._GetLuminanceArrayBuffer(j,P,V.byteOffset+C,r,V.buffer),h.format=1,h.type=0,Z._uploadDataToTextureDirectly(h,l,A,H)}else r=Math.max(4,j)/4*Math.max(4,P)/4*y,l=new Uint8Array(V.buffer,V.byteOffset+C,r),h.type=0,Z._uploadCompressedDataToTextureDirectly(h,L,j,P,l,A,H)}C+=W?j*P*(W/8):r,j*=.5,P*=.5,j=Math.max(1,j),P=Math.max(1,P)}if(void 0!==F)break}o&&o.length>0?v.sphericalPolynomial=H.c.ConvertCubeMapToSphericalPolynomial({size:X[4],right:o[0],left:o[1],up:o[2],down:o[3],front:o[4],back:o[5],format:5,type:1,gammaSpace:!1}):v.sphericalPolynomial=void 0}}u.StoreLODInAlphaChannel=!1}}]);