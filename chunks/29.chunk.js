"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[29],{14466:(I,x,L)=>{var F=L(12909),X=L(12809),G=L(12842),Y=L(12945),p=L(12872),B=L(12924);p.d.prototype._partialLoadFile=function(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(I,(I=>{L[x]=I,L._internalCount++,6===L._internalCount&&F(L)}),void 0,void 0,!0,((I,x)=>{X&&I&&X(I.status+" "+I.statusText,x)}))},p.d.prototype._cascadeLoadFiles=function(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const X=[];X._internalCount=0;for(let G=0;G<6;G++)this._partialLoadFile(L[G],G,X,x,F)},p.d.prototype._cascadeLoadImgs=function(I,x,L,F){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,G=arguments.length>5?arguments[5]:void 0;const Y=[];Y._internalCount=0;for(let p=0;p<6;p++)this._partialLoadImg(F[p],p,Y,I,x,L,X,G)},p.d.prototype._partialLoadImg=function(I,x,L,F,X,p){let B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7?arguments[7]:void 0;const W=(0,Y.e)();(0,G.p)(I,(I=>{L[x]=I,L._internalCount++,F&&F.removePendingData(W),6===L._internalCount&&p&&p(X,L)}),((I,x)=>{F&&F.removePendingData(W),B&&B(I,x)}),F?F.offlineProvider:null,l),F&&F.addPendingData(W)},p.d.prototype.createCubeTextureBase=function(I,x,L,G){let Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,l=arguments.length>6?arguments[6]:void 0,W=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],e=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,g=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,v=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,z=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,H=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,s=arguments.length>14&&void 0!==arguments[14]&&arguments[14],U=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const q=v||new F.d(this,7);q.isCube=!0,q.url=I,q.generateMipMaps=!G,q._lodGenerationScale=e,q._lodGenerationOffset=g,q._useSRGBBuffer=!!s&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!G),q!==v&&(q.label=I.substring(0,60)),this._doNotHandleContextLost||(q._extension=W,q._files=L,q._buffer=U);const y=I;this._transformTextureUrl&&!v&&(I=this._transformTextureUrl(I));const T=W??function(I){const x=I.split("?")[0],L=x.lastIndexOf(".");return L>-1?x.substring(L).toLowerCase():""}(I),Z=(0,B.d)(T),t=(I,x)=>{q.dispose(),p?p(I,x):I&&X.c.Warn(I)},f=(F,p)=>{I===y?F&&t(F.status+" "+F.statusText,p):(X.c.Warn(`Failed to load ${I}, falling back to the ${y}`),this.createCubeTextureBase(y,x,L,!!G,Y,t,l,W,Q,e,g,q,z,H,s,U))};if(Z)Z.then((F=>{const X=I=>{z&&z(q,I),F.loadCubeData(I,q,Q,Y,((I,x)=>{t(I,x)}))};U?X(U):L&&6===L.length?F.supportCascades?this._cascadeLoadFiles(x,(I=>X(I.map((I=>new Uint8Array(I))))),L,t):t("Textures type does not support cascades."):this._loadFile(I,(I=>X(new Uint8Array(I))),void 0,void 0,!0,f)}));else{if(!L||0===L.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(x,q,((I,x)=>{H&&H(I,x)}),L,t)}return this._internalTexturesCache.push(q),q}},13487:(I,x,L)=>{L.d(x,{e:()=>l});var F=L(12983),X=L(13001),G=L(13171),Y=L(12989),p=L(13020);class B{constructor(I,x,L,F){this.name=I,this.worldAxisForNormal=x,this.worldAxisForFileX=L,this.worldAxisForFileY=F}}class l{static ConvertCubeMapTextureToSphericalPolynomial(I){var x;if(!I.isCube)return null;null===(x=I.tI())||void 0===x||x.getEngine().flushFramebuffer();const L=I.getSize().width,F=I.readPixels(0,void 0,void 0,!1),X=I.readPixels(1,void 0,void 0,!1);let G,Y;I.isRenderTarget?(G=I.readPixels(3,void 0,void 0,!1),Y=I.readPixels(2,void 0,void 0,!1)):(G=I.readPixels(2,void 0,void 0,!1),Y=I.readPixels(3,void 0,void 0,!1));const p=I.readPixels(4,void 0,void 0,!1),B=I.readPixels(5,void 0,void 0,!1),l=I.gammaSpace;let W=0;return 1!=I.textureType&&2!=I.textureType||(W=1),new Promise((I=>{Promise.all([X,F,G,Y,p,B]).then((x=>{let[F,X,G,Y,p,B]=x;const Q={size:L,right:X,left:F,up:G,down:Y,front:p,back:B,format:5,type:W,gammaSpace:l};I(this.ConvertCubeMapToSphericalPolynomial(Q))}))}))}static _AreaElement(I,x){return Math.atan2(I*x,Math.sqrt(I*I+x*x+1))}static ConvertCubeMapToSphericalPolynomial(I){const x=new G.d;let L=0;const F=2/I.size,B=F,l=.5*F,W=l-1;for(let G=0;G<6;G++){const Q=this._FileFaces[G],e=I[Q.name];let g=W;const v=5===I.format?4:3;for(let G=0;G<I.size;G++){let z=W;for(let B=0;B<I.size;B++){const W=Q.worldAxisForFileX.scale(z).add(Q.worldAxisForFileY.scale(g)).add(Q.worldAxisForNormal);W.normalize();const H=this._AreaElement(z-l,g-l)-this._AreaElement(z-l,g+l)-this._AreaElement(z+l,g-l)+this._AreaElement(z+l,g+l);let s=e[G*I.size*v+B*v+0],U=e[G*I.size*v+B*v+1],q=e[G*I.size*v+B*v+2];isNaN(s)&&(s=0),isNaN(U)&&(U=0),isNaN(q)&&(q=0),0===I.type&&(s/=255,U/=255,q/=255),I.gammaSpace&&(s=Math.pow((0,X.Clamp)(s),Y.m),U=Math.pow((0,X.Clamp)(U),Y.m),q=Math.pow((0,X.Clamp)(q),Y.m));const y=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const I=Math.max(s,U,q);if(I>y){const x=y/I;s*=x,U*=x,q*=x}}else s=(0,X.Clamp)(s,0,y),U=(0,X.Clamp)(U,0,y),q=(0,X.Clamp)(q,0,y);const T=new p.Tx(s,U,q);x.addLight(W,T,H),L+=H,z+=F}g+=B}}const Q=6*(4*Math.PI)/6/L;return x.scaleInPlace(Q),x.convertIncidentRadianceToIrradiance(),x.convertIrradianceToLambertianRadiance(),G.g.FromHarmonics(x)}}l._FileFaces=[new B("right",new F.sx(1,0,0),new F.sx(0,0,-1),new F.sx(0,-1,0)),new B("left",new F.sx(-1,0,0),new F.sx(0,0,1),new F.sx(0,-1,0)),new B("up",new F.sx(0,1,0),new F.sx(1,0,0),new F.sx(0,0,1)),new B("down",new F.sx(0,-1,0),new F.sx(1,0,0),new F.sx(0,0,-1)),new B("front",new F.sx(0,0,1),new F.sx(1,0,0),new F.sx(0,-1,0)),new B("back",new F.sx(0,0,-1),new F.sx(-1,0,0),new F.sx(0,-1,0))],l.MAX_HDRI_VALUE=4096,l.PRESERVE_CLAMPED_COLORS=!1},15326:(I,x,L)=>{L.d(x,{DDSTools:()=>v});var F=L(13001),X=L(12809),G=L(13487),Y=L(13209);L(14466);const p=131072,B=131072;function l(I){return I.charCodeAt(0)+(I.charCodeAt(1)<<8)+(I.charCodeAt(2)<<16)+(I.charCodeAt(3)<<24)}const W=l("DXT1"),Q=l("DXT3"),e=l("DXT5"),g=l("DX10");class v{static GetDDSInfo(I){const x=new Int32Array(I.buffer,I.byteOffset,31),L=new Int32Array(I.buffer,I.byteOffset,35);let F=1;x[2]&p&&(F=Math.max(1,x[7]));const X=x[21],G=X===g?L[32]:0;let Y=0;switch(X){case 113:Y=2;break;case 116:Y=1;break;case g:if(10===G){Y=2;break}if(2===G){Y=1;break}}return{width:x[4],height:x[3],mipmapCount:F,isFourCC:4===(4&x[20]),isRGB:64===(64&x[20]),isLuminance:(x[20]&B)===B,isCube:512===(512&x[28]),isCompressed:X===W||X===Q||X===e,dxgiFormat:G,textureType:Y}}static _GetHalfFloatAsFloatRGBAArrayBuffer(I,x,L,F,X,G){const p=new Float32Array(F),B=new Uint16Array(X,L);let l=0;for(let W=0;W<x;W++)for(let x=0;x<I;x++){const L=4*(x+W*I);p[l]=(0,Y.f)(B[L]),p[l+1]=(0,Y.f)(B[L+1]),p[l+2]=(0,Y.f)(B[L+2]),v.StoreLODInAlphaChannel?p[l+3]=G:p[l+3]=(0,Y.f)(B[L+3]),l+=4}return p}static _GetHalfFloatRGBAArrayBuffer(I,x,L,F,X,G){if(v.StoreLODInAlphaChannel){const p=new Uint16Array(F),B=new Uint16Array(X,L);let l=0;for(let L=0;L<x;L++)for(let x=0;x<I;x++){const F=4*(x+L*I);p[l]=B[F],p[l+1]=B[F+1],p[l+2]=B[F+2],p[l+3]=(0,Y.l)(G),l+=4}return p}return new Uint16Array(X,L,F)}static _GetFloatRGBAArrayBuffer(I,x,L,F,X,G){if(v.StoreLODInAlphaChannel){const Y=new Float32Array(F),p=new Float32Array(X,L);let B=0;for(let L=0;L<x;L++)for(let x=0;x<I;x++){const F=4*(x+L*I);Y[B]=p[F],Y[B+1]=p[F+1],Y[B+2]=p[F+2],Y[B+3]=G,B+=4}return Y}return new Float32Array(X,L,F)}static _GetFloatAsHalfFloatRGBAArrayBuffer(I,x,L,F,X,G){const p=new Uint16Array(F),B=new Float32Array(X,L);let l=0;for(let W=0;W<x;W++)for(let x=0;x<I;x++)p[l]=(0,Y.l)(B[l]),p[l+1]=(0,Y.l)(B[l+1]),p[l+2]=(0,Y.l)(B[l+2]),v.StoreLODInAlphaChannel?p[l+3]=(0,Y.l)(G):p[l+3]=(0,Y.l)(B[l+3]),l+=4;return p}static _GetFloatAsUIntRGBAArrayBuffer(I,x,L,X,G,Y){const p=new Uint8Array(X),B=new Float32Array(G,L);let l=0;for(let W=0;W<x;W++)for(let x=0;x<I;x++){const L=4*(x+W*I);p[l]=255*(0,F.Clamp)(B[L]),p[l+1]=255*(0,F.Clamp)(B[L+1]),p[l+2]=255*(0,F.Clamp)(B[L+2]),v.StoreLODInAlphaChannel?p[l+3]=Y:p[l+3]=255*(0,F.Clamp)(B[L+3]),l+=4}return p}static _GetHalfFloatAsUIntRGBAArrayBuffer(I,x,L,X,G,p){const B=new Uint8Array(X),l=new Uint16Array(G,L);let W=0;for(let Q=0;Q<x;Q++)for(let x=0;x<I;x++){const L=4*(x+Q*I);B[W]=255*(0,F.Clamp)((0,Y.f)(l[L])),B[W+1]=255*(0,F.Clamp)((0,Y.f)(l[L+1])),B[W+2]=255*(0,F.Clamp)((0,Y.f)(l[L+2])),v.StoreLODInAlphaChannel?B[W+3]=p:B[W+3]=255*(0,F.Clamp)((0,Y.f)(l[L+3])),W+=4}return B}static _GetRGBAArrayBuffer(I,x,L,F,X,G,Y,p,B){const l=new Uint8Array(F),W=new Uint8Array(X,L);let Q=0;for(let e=0;e<x;e++)for(let x=0;x<I;x++){const L=4*(x+e*I);l[Q]=W[L+G],l[Q+1]=W[L+Y],l[Q+2]=W[L+p],l[Q+3]=W[L+B],Q+=4}return l}static _ExtractLongWordOrder(I){return 0===I||255===I||-16777216===I?0:1+v._ExtractLongWordOrder(I>>8)}static _GetRGBArrayBuffer(I,x,L,F,X,G,Y,p){const B=new Uint8Array(F),l=new Uint8Array(X,L);let W=0;for(let Q=0;Q<x;Q++)for(let x=0;x<I;x++){const L=3*(x+Q*I);B[W]=l[L+G],B[W+1]=l[L+Y],B[W+2]=l[L+p],W+=3}return B}static _GetLuminanceArrayBuffer(I,x,L,F,X){const G=new Uint8Array(F),Y=new Uint8Array(X,L);let p=0;for(let B=0;B<x;B++)for(let x=0;x<I;x++){const L=x+B*I;G[p]=Y[L],p++}return G}static UploadDDSLevels(I,x,L,F,Y,B){let l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,z=arguments.length>7?arguments[7]:void 0,H=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],s=null;F.sphericalPolynomial&&(s=[]);const U=!!I.getCaps().s3tc;x.generateMipMaps=Y;const q=new Int32Array(L.buffer,L.byteOffset,31);let y,T,Z,t,f,R,n,P=0,d=0,M=1;if(542327876!==q[0])return void X.c.Error("Invalid magic number in DDS header");if(!F.isFourCC&&!F.isRGB&&!F.isLuminance)return void X.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(F.isCompressed&&!U)return void X.c.Error("Compressed textures are not supported on this platform.");let K=q[22];t=q[1]+4;let u=!1;if(F.isFourCC)switch(y=q[21],y){case W:M=8,d=33777;break;case Q:M=16,d=33778;break;case e:M=16,d=33779;break;case 113:u=!0,K=64;break;case 116:u=!0,K=128;break;case g:{t+=20;let I=!1;switch(F.dxgiFormat){case 10:u=!0,K=64,I=!0;break;case 2:u=!0,K=128,I=!0;break;case 88:F.isRGB=!0,F.isFourCC=!1,K=32,I=!0}if(I)break}default:return void X.c.Error(["Unsupported FourCC code:",(A=y,String.fromCharCode(255&A,A>>8&255,A>>16&255,A>>24&255))])}var A;const mI=v._ExtractLongWordOrder(q[23]),O=v._ExtractLongWordOrder(q[24]),w=v._ExtractLongWordOrder(q[25]),k=v._ExtractLongWordOrder(q[26]);u&&(d=I._getRGBABufferInternalSizedFormat(F.textureType)),R=1,q[2]&p&&!1!==Y&&(R=Math.max(1,q[7]));const a=z||0,D=I.getCaps();for(let X=a;X<B;X++){for(T=q[4],Z=q[3],n=0;n<R;++n){if(-1===l||l===n){const G=-1===l?n:0;if(!F.isCompressed&&F.isFourCC){x.format=5,P=T*Z*4;let F=null;if(I._badOS||I._badDesktopOS||!D.textureHalfFloat&&!D.textureFloat)128===K?(F=v._GetFloatAsUIntRGBAArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,G),s&&0==G&&s.push(v._GetFloatRGBAArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,G))):64===K&&(F=v._GetHalfFloatAsUIntRGBAArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,G),s&&0==G&&s.push(v._GetHalfFloatAsFloatRGBAArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,G))),x.type=0;else{const I=D.textureFloat&&(H&&D.textureFloatLinearFiltering||!H),X=D.textureHalfFloat&&(H&&D.textureHalfFloatLinearFiltering||!H),Y=(128===K||64===K&&!X)&&I?1:(64===K||128===K&&!I)&&X?2:0;let p,B=null;if(128===K)switch(Y){case 1:p=v._GetFloatRGBAArrayBuffer,B=null;break;case 2:p=v._GetFloatAsHalfFloatRGBAArrayBuffer,B=v._GetFloatRGBAArrayBuffer;break;case 0:p=v._GetFloatAsUIntRGBAArrayBuffer,B=v._GetFloatRGBAArrayBuffer}else switch(Y){case 1:p=v._GetHalfFloatAsFloatRGBAArrayBuffer,B=null;break;case 2:p=v._GetHalfFloatRGBAArrayBuffer,B=v._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:p=v._GetHalfFloatAsUIntRGBAArrayBuffer,B=v._GetHalfFloatAsFloatRGBAArrayBuffer}x.type=Y,F=p(T,Z,L.byteOffset+t,P,L.buffer,G),s&&0==G&&s.push(B?B(T,Z,L.byteOffset+t,P,L.buffer,G):F)}F&&I._uploadDataToTextureDirectly(x,F,X,G)}else if(F.isRGB)x.type=0,24===K?(x.format=4,P=T*Z*3,f=v._GetRGBArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,mI,O,w),I._uploadDataToTextureDirectly(x,f,X,G)):(x.format=5,P=T*Z*4,f=v._GetRGBAArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer,mI,O,w,k),I._uploadDataToTextureDirectly(x,f,X,G));else if(F.isLuminance){const F=I._getUnpackAlignement(),Y=T;P=Math.floor((T+F-1)/F)*F*(Z-1)+Y,f=v._GetLuminanceArrayBuffer(T,Z,L.byteOffset+t,P,L.buffer),x.format=1,x.type=0,I._uploadDataToTextureDirectly(x,f,X,G)}else P=Math.max(4,T)/4*Math.max(4,Z)/4*M,f=new Uint8Array(L.buffer,L.byteOffset+t,P),x.type=0,I._uploadCompressedDataToTextureDirectly(x,d,T,Z,f,X,G)}t+=K?T*Z*(K/8):P,T*=.5,Z*=.5,T=Math.max(1,T),Z=Math.max(1,Z)}if(void 0!==z)break}s&&s.length>0?F.sphericalPolynomial=G.e.ConvertCubeMapToSphericalPolynomial({size:q[4],right:s[0],left:s[1],up:s[2],down:s[3],front:s[4],back:s[5],format:5,type:1,gammaSpace:!1}):F.sphericalPolynomial=void 0}}v.StoreLODInAlphaChannel=!1}}]);