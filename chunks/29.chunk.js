"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[29],{13841:(I,O,C)=>{var j=C(12201),K=C(12103),i=C(12139),y=C(12234),S=C(12167),U=C(12213);S.b.prototype._partialLoadFile=function(I,O,C,j){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(I,(I=>{C[O]=I,C._internalCount++,6===C._internalCount&&j(C)}),void 0,void 0,!0,((I,O)=>{K&&I&&K(I.status+" "+I.statusText,O)}))},S.b.prototype._cascadeLoadFiles=function(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const K=[];K._internalCount=0;for(let i=0;i<6;i++)this._partialLoadFile(C[i],i,K,O,j)},S.b.prototype._cascadeLoadImgs=function(I,O,C,j){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,i=arguments.length>5?arguments[5]:void 0;const y=[];y._internalCount=0;for(let S=0;S<6;S++)this._partialLoadImg(j[S],S,y,I,O,C,K,i)},S.b.prototype._partialLoadImg=function(I,O,C,j,K,S){let U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,p=arguments.length>7?arguments[7]:void 0;const N=(0,y.c)();(0,i.t)(I,(I=>{C[O]=I,C._internalCount++,j&&j.removePendingData(N),6===C._internalCount&&S&&S(K,C)}),((I,O)=>{j&&j.removePendingData(N),U&&U(I,O)}),j?j.offlineProvider:null,p),j&&j.addPendingData(N)},S.b.prototype.createCubeTextureBase=function(I,O,C,i){let y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,p=arguments.length>6?arguments[6]:void 0,N=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],s=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,Z=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,q=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,mI=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,E=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,h=arguments.length>14&&void 0!==arguments[14]&&arguments[14],r=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const W=q||new j.c(this,7);W.isCube=!0,W.url=I,W.generateMipMaps=!i,W._lodGenerationScale=s,W._lodGenerationOffset=Z,W._useSRGBBuffer=!!h&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!i),W!==q&&(W.label=I.substring(0,60)),this._doNotHandleContextLost||(W._extension=N,W._files=C,W._buffer=r);const Y=I;this._transformTextureUrl&&!q&&(I=this._transformTextureUrl(I));const o=N??function(I){const O=I.split("?")[0],C=O.lastIndexOf(".");return C>-1?O.substring(C).toLowerCase():""}(I),c=(0,U.c)(o),n=(I,O)=>{W.dispose(),S?S(I,O):I&&K.c.Warn(I)},X=(j,S)=>{I===Y?j&&n(j.status+" "+j.statusText,S):(K.c.Warn(`Failed to load ${I}, falling back to the ${Y}`),this.createCubeTextureBase(Y,O,C,!!i,y,n,p,N,Q,s,Z,W,mI,E,h,r))};if(c)c.then((j=>{const K=I=>{mI&&mI(W,I),j.loadCubeData(I,W,Q,y,((I,O)=>{n(I,O)}))};r?K(r):C&&6===C.length?j.supportCascades?this._cascadeLoadFiles(O,(I=>K(I.map((I=>new Uint8Array(I))))),C,n):n("Textures type does not support cascades."):this._loadFile(I,(I=>K(new Uint8Array(I))),void 0,void 0,!0,X)}));else{if(!C||0===C.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(O,W,((I,O)=>{E&&E(I,O)}),C,n)}return this._internalTexturesCache.push(W),W}},12755:(I,O,C)=>{C.d(O,{b:()=>p});var j=C(12272),K=C(12282),i=C(12447),y=C(12274),S=C(12307);class U{constructor(I,O,C,j){this.name=I,this.worldAxisForNormal=O,this.worldAxisForFileX=C,this.worldAxisForFileY=j}}class p{static ConvertCubeMapTextureToSphericalPolynomial(I){var O;if(!I.isCube)return null;null===(O=I.nI())||void 0===O||O.getEngine().flushFramebuffer();const C=I.getSize().width,j=I.readPixels(0,void 0,void 0,!1),K=I.readPixels(1,void 0,void 0,!1);let i,y;I.isRenderTarget?(i=I.readPixels(3,void 0,void 0,!1),y=I.readPixels(2,void 0,void 0,!1)):(i=I.readPixels(2,void 0,void 0,!1),y=I.readPixels(3,void 0,void 0,!1));const S=I.readPixels(4,void 0,void 0,!1),U=I.readPixels(5,void 0,void 0,!1),p=I.gammaSpace;let N=0;return 1!=I.textureType&&2!=I.textureType||(N=1),new Promise((I=>{Promise.all([K,j,i,y,S,U]).then((O=>{let[j,K,i,y,S,U]=O;const Q={size:C,right:K,left:j,up:i,down:y,front:S,back:U,format:5,type:N,gammaSpace:p};I(this.ConvertCubeMapToSphericalPolynomial(Q))}))}))}static _AreaElement(I,O){return Math.atan2(I*O,Math.sqrt(I*I+O*O+1))}static ConvertCubeMapToSphericalPolynomial(I){const O=new i.b;let C=0;const j=2/I.size,U=j,p=.5*j,N=p-1;for(let i=0;i<6;i++){const Q=this._FileFaces[i],s=I[Q.name];let Z=N;const q=5===I.format?4:3;for(let i=0;i<I.size;i++){let mI=N;for(let U=0;U<I.size;U++){const N=Q.worldAxisForFileX.scale(mI).add(Q.worldAxisForFileY.scale(Z)).add(Q.worldAxisForNormal);N.normalize();const E=this._AreaElement(mI-p,Z-p)-this._AreaElement(mI-p,Z+p)-this._AreaElement(mI+p,Z-p)+this._AreaElement(mI+p,Z+p);let h=s[i*I.size*q+U*q+0],r=s[i*I.size*q+U*q+1],W=s[i*I.size*q+U*q+2];isNaN(h)&&(h=0),isNaN(r)&&(r=0),isNaN(W)&&(W=0),0===I.type&&(h/=255,r/=255,W/=255),I.gammaSpace&&(h=Math.pow((0,K.Clamp)(h),y.j),r=Math.pow((0,K.Clamp)(r),y.j),W=Math.pow((0,K.Clamp)(W),y.j));const Y=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const I=Math.max(h,r,W);if(I>Y){const O=Y/I;h*=O,r*=O,W*=O}}else h=(0,K.Clamp)(h,0,Y),r=(0,K.Clamp)(r,0,Y),W=(0,K.Clamp)(W,0,Y);const o=new S.WO(h,r,W);O.addLight(N,o,E),C+=E,mI+=j}Z+=U}}const Q=6*(4*Math.PI)/6/C;return O.scaleInPlace(Q),O.convertIncidentRadianceToIrradiance(),O.convertIrradianceToLambertianRadiance(),i.f.FromHarmonics(O)}}p._FileFaces=[new U("right",new j.mC(1,0,0),new j.mC(0,0,-1),new j.mC(0,-1,0)),new U("left",new j.mC(-1,0,0),new j.mC(0,0,1),new j.mC(0,-1,0)),new U("up",new j.mC(0,1,0),new j.mC(1,0,0),new j.mC(0,0,1)),new U("down",new j.mC(0,-1,0),new j.mC(1,0,0),new j.mC(0,0,-1)),new U("front",new j.mC(0,0,1),new j.mC(1,0,0),new j.mC(0,-1,0)),new U("back",new j.mC(0,0,-1),new j.mC(-1,0,0),new j.mC(0,-1,0))],p.MAX_HDRI_VALUE=4096,p.PRESERVE_CLAMPED_COLORS=!1},14614:(I,O,C)=>{C.d(O,{DDSTools:()=>q});var j=C(12282),K=C(12103),i=C(12755),y=C(12476);C(13841);const S=131072,U=131072;function p(I){return I.charCodeAt(0)+(I.charCodeAt(1)<<8)+(I.charCodeAt(2)<<16)+(I.charCodeAt(3)<<24)}const N=p("DXT1"),Q=p("DXT3"),s=p("DXT5"),Z=p("DX10");class q{static GetDDSInfo(I){const O=new Int32Array(I.buffer,I.byteOffset,31),C=new Int32Array(I.buffer,I.byteOffset,35);let j=1;O[2]&S&&(j=Math.max(1,O[7]));const K=O[21],i=K===Z?C[32]:0;let y=0;switch(K){case 113:y=2;break;case 116:y=1;break;case Z:if(10===i){y=2;break}if(2===i){y=1;break}}return{width:O[4],height:O[3],mipmapCount:j,isFourCC:4===(4&O[20]),isRGB:64===(64&O[20]),isLuminance:(O[20]&U)===U,isCube:512===(512&O[28]),isCompressed:K===N||K===Q||K===s,dxgiFormat:i,textureType:y}}static _GetHalfFloatAsFloatRGBAArrayBuffer(I,O,C,j,K,i){const S=new Float32Array(j),U=new Uint16Array(K,C);let p=0;for(let N=0;N<O;N++)for(let O=0;O<I;O++){const C=4*(O+N*I);S[p]=(0,y.h)(U[C]),S[p+1]=(0,y.h)(U[C+1]),S[p+2]=(0,y.h)(U[C+2]),q.StoreLODInAlphaChannel?S[p+3]=i:S[p+3]=(0,y.h)(U[C+3]),p+=4}return S}static _GetHalfFloatRGBAArrayBuffer(I,O,C,j,K,i){if(q.StoreLODInAlphaChannel){const S=new Uint16Array(j),U=new Uint16Array(K,C);let p=0;for(let C=0;C<O;C++)for(let O=0;O<I;O++){const j=4*(O+C*I);S[p]=U[j],S[p+1]=U[j+1],S[p+2]=U[j+2],S[p+3]=(0,y.l)(i),p+=4}return S}return new Uint16Array(K,C,j)}static _GetFloatRGBAArrayBuffer(I,O,C,j,K,i){if(q.StoreLODInAlphaChannel){const y=new Float32Array(j),S=new Float32Array(K,C);let U=0;for(let C=0;C<O;C++)for(let O=0;O<I;O++){const j=4*(O+C*I);y[U]=S[j],y[U+1]=S[j+1],y[U+2]=S[j+2],y[U+3]=i,U+=4}return y}return new Float32Array(K,C,j)}static _GetFloatAsHalfFloatRGBAArrayBuffer(I,O,C,j,K,i){const S=new Uint16Array(j),U=new Float32Array(K,C);let p=0;for(let N=0;N<O;N++)for(let O=0;O<I;O++)S[p]=(0,y.l)(U[p]),S[p+1]=(0,y.l)(U[p+1]),S[p+2]=(0,y.l)(U[p+2]),q.StoreLODInAlphaChannel?S[p+3]=(0,y.l)(i):S[p+3]=(0,y.l)(U[p+3]),p+=4;return S}static _GetFloatAsUIntRGBAArrayBuffer(I,O,C,K,i,y){const S=new Uint8Array(K),U=new Float32Array(i,C);let p=0;for(let N=0;N<O;N++)for(let O=0;O<I;O++){const C=4*(O+N*I);S[p]=255*(0,j.Clamp)(U[C]),S[p+1]=255*(0,j.Clamp)(U[C+1]),S[p+2]=255*(0,j.Clamp)(U[C+2]),q.StoreLODInAlphaChannel?S[p+3]=y:S[p+3]=255*(0,j.Clamp)(U[C+3]),p+=4}return S}static _GetHalfFloatAsUIntRGBAArrayBuffer(I,O,C,K,i,S){const U=new Uint8Array(K),p=new Uint16Array(i,C);let N=0;for(let Q=0;Q<O;Q++)for(let O=0;O<I;O++){const C=4*(O+Q*I);U[N]=255*(0,j.Clamp)((0,y.h)(p[C])),U[N+1]=255*(0,j.Clamp)((0,y.h)(p[C+1])),U[N+2]=255*(0,j.Clamp)((0,y.h)(p[C+2])),q.StoreLODInAlphaChannel?U[N+3]=S:U[N+3]=255*(0,j.Clamp)((0,y.h)(p[C+3])),N+=4}return U}static _GetRGBAArrayBuffer(I,O,C,j,K,i,y,S,U){const p=new Uint8Array(j),N=new Uint8Array(K,C);let Q=0;for(let s=0;s<O;s++)for(let O=0;O<I;O++){const C=4*(O+s*I);p[Q]=N[C+i],p[Q+1]=N[C+y],p[Q+2]=N[C+S],p[Q+3]=N[C+U],Q+=4}return p}static _ExtractLongWordOrder(I){return 0===I||255===I||-16777216===I?0:1+q._ExtractLongWordOrder(I>>8)}static _GetRGBArrayBuffer(I,O,C,j,K,i,y,S){const U=new Uint8Array(j),p=new Uint8Array(K,C);let N=0;for(let Q=0;Q<O;Q++)for(let O=0;O<I;O++){const C=3*(O+Q*I);U[N]=p[C+i],U[N+1]=p[C+y],U[N+2]=p[C+S],N+=3}return U}static _GetLuminanceArrayBuffer(I,O,C,j,K){const i=new Uint8Array(j),y=new Uint8Array(K,C);let S=0;for(let U=0;U<O;U++)for(let O=0;O<I;O++){const C=O+U*I;i[S]=y[C],S++}return i}static UploadDDSLevels(I,O,C,j,y,U){let p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,mI=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],h=null;j.sphericalPolynomial&&(h=[]);const r=!!I.getCaps().s3tc;O.generateMipMaps=y;const W=new Int32Array(C.buffer,C.byteOffset,31);let Y,o,c,n,X,T,H,b=0,a=0,M=1;if(542327876!==W[0])return void K.c.Error("Invalid magic number in DDS header");if(!j.isFourCC&&!j.isRGB&&!j.isLuminance)return void K.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(j.isCompressed&&!r)return void K.c.Error("Compressed textures are not supported on this platform.");let u=W[22];n=W[1]+4;let J=!1;if(j.isFourCC)switch(Y=W[21],Y){case N:M=8,a=33777;break;case Q:M=16,a=33778;break;case s:M=16,a=33779;break;case 113:J=!0,u=64;break;case 116:J=!0,u=128;break;case Z:{n+=20;let I=!1;switch(j.dxgiFormat){case 10:J=!0,u=64,I=!0;break;case 2:J=!0,u=128,I=!0;break;case 88:j.isRGB=!0,j.isFourCC=!1,u=32,I=!0}if(I)break}default:return void K.c.Error(["Unsupported FourCC code:",(f=Y,String.fromCharCode(255&f,f>>8&255,f>>16&255,f>>24&255))])}var f;const l=q._ExtractLongWordOrder(W[23]),x=q._ExtractLongWordOrder(W[24]),D=q._ExtractLongWordOrder(W[25]),t=q._ExtractLongWordOrder(W[26]);J&&(a=I._getRGBABufferInternalSizedFormat(j.textureType)),T=1,W[2]&S&&!1!==y&&(T=Math.max(1,W[7]));const d=mI||0,w=I.getCaps();for(let K=d;K<U;K++){for(o=W[4],c=W[3],H=0;H<T;++H){if(-1===p||p===H){const i=-1===p?H:0;if(!j.isCompressed&&j.isFourCC){O.format=5,b=o*c*4;let j=null;if(I._badOS||I._badDesktopOS||!w.textureHalfFloat&&!w.textureFloat)128===u?(j=q._GetFloatAsUIntRGBAArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,i),h&&0==i&&h.push(q._GetFloatRGBAArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,i))):64===u&&(j=q._GetHalfFloatAsUIntRGBAArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,i),h&&0==i&&h.push(q._GetHalfFloatAsFloatRGBAArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,i))),O.type=0;else{const I=w.textureFloat&&(E&&w.textureFloatLinearFiltering||!E),K=w.textureHalfFloat&&(E&&w.textureHalfFloatLinearFiltering||!E),y=(128===u||64===u&&!K)&&I?1:(64===u||128===u&&!I)&&K?2:0;let S,U=null;if(128===u)switch(y){case 1:S=q._GetFloatRGBAArrayBuffer,U=null;break;case 2:S=q._GetFloatAsHalfFloatRGBAArrayBuffer,U=q._GetFloatRGBAArrayBuffer;break;case 0:S=q._GetFloatAsUIntRGBAArrayBuffer,U=q._GetFloatRGBAArrayBuffer}else switch(y){case 1:S=q._GetHalfFloatAsFloatRGBAArrayBuffer,U=null;break;case 2:S=q._GetHalfFloatRGBAArrayBuffer,U=q._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:S=q._GetHalfFloatAsUIntRGBAArrayBuffer,U=q._GetHalfFloatAsFloatRGBAArrayBuffer}O.type=y,j=S(o,c,C.byteOffset+n,b,C.buffer,i),h&&0==i&&h.push(U?U(o,c,C.byteOffset+n,b,C.buffer,i):j)}j&&I._uploadDataToTextureDirectly(O,j,K,i)}else if(j.isRGB)O.type=0,24===u?(O.format=4,b=o*c*3,X=q._GetRGBArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,l,x,D),I._uploadDataToTextureDirectly(O,X,K,i)):(O.format=5,b=o*c*4,X=q._GetRGBAArrayBuffer(o,c,C.byteOffset+n,b,C.buffer,l,x,D,t),I._uploadDataToTextureDirectly(O,X,K,i));else if(j.isLuminance){const j=I._getUnpackAlignement(),y=o;b=Math.floor((o+j-1)/j)*j*(c-1)+y,X=q._GetLuminanceArrayBuffer(o,c,C.byteOffset+n,b,C.buffer),O.format=1,O.type=0,I._uploadDataToTextureDirectly(O,X,K,i)}else b=Math.max(4,o)/4*Math.max(4,c)/4*M,X=new Uint8Array(C.buffer,C.byteOffset+n,b),O.type=0,I._uploadCompressedDataToTextureDirectly(O,a,o,c,X,K,i)}n+=u?o*c*(u/8):b,o*=.5,c*=.5,o=Math.max(1,o),c=Math.max(1,c)}if(void 0!==mI)break}h&&h.length>0?j.sphericalPolynomial=i.b.ConvertCubeMapToSphericalPolynomial({size:W[4],right:h[0],left:h[1],up:h[2],down:h[3],front:h[4],back:h[5],format:5,type:1,gammaSpace:!1}):j.sphericalPolynomial=void 0}}q.StoreLODInAlphaChannel=!1}}]);