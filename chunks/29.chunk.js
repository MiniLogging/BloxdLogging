"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[29],{13501:(s,Z,o)=>{o.r(Z),o.d(Z,{_BasisTextureLoader:()=>A});var t,j=o(10938),S=o(11410),a=o(11044);function O(){const s=0,Z=1,o=2,t=3,j=6,S=8,a=9,O=10,v=14;let G=null;function B(s,Z,o,t,j){const S=s.getImageTranscodedSizeInBytes(Z,o,t);let a=new Uint8Array(S);if(!s.transcodeImage(a,Z,o,t,1,0))return null;if(j){a=function(s,Z,o,t){const j=new Uint16Array(4),S=new Uint16Array(o*t),a=o/4,O=t/4;for(let v=0;v<O;v++)for(let t=0;t<a;t++){const O=Z+8*(v*a+t);j[0]=s[O]|s[O+1]<<8,j[1]=s[O+2]|s[O+3]<<8,j[2]=(2*(31&j[0])+1*(31&j[1]))/3|(2*(2016&j[0])+1*(2016&j[1]))/3&2016|(2*(63488&j[0])+1*(63488&j[1]))/3&63488,j[3]=(2*(31&j[1])+1*(31&j[0]))/3|(2*(2016&j[1])+1*(2016&j[0]))/3&2016|(2*(63488&j[1])+1*(63488&j[0]))/3&63488;for(let Z=0;Z<4;Z++){const a=s[O+4+Z];let G=(4*v+Z)*o+4*t;S[G++]=j[3&a],S[G++]=j[a>>2&3],S[G++]=j[a>>4&3],S[G++]=j[a>>6&3]}}return S}(a,0,s.getImageWidth(Z,o)+3&-4,s.getImageHeight(Z,o)+3&-4)}return a}onmessage=Q=>{if("init"===Q.data.action){if(Q.data.url)try{importScripts(Q.data.url)}catch(D){postMessage({action:"error",error:D})}G||(G=BASIS({wasmBinary:Q.data.wasmBinary})),null!==G&&G.then((s=>{BASIS=s,s.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Q.data.action){const G=Q.data.config,D=Q.data.imageData,z=new BASIS.BasisFile(D),Y=function(s){const Z=s.getHasAlpha(),o=s.getNumImages(),t=[];for(let j=0;j<o;j++){const Z={levels:[]},o=s.getNumLevels(j);for(let t=0;t<o;t++){const o={width:s.getImageWidth(j,t),height:s.getImageHeight(j,t)};Z.levels.push(o)}t.push(Z)}return{na:Z,images:t}}(z);let b=Q.data.ignoreSupportedFormats?null:function(G,B){let Q=null;G.supportedCompressionFormats&&(Q=G.supportedCompressionFormats.astc?O:G.supportedCompressionFormats.bc7?j:G.supportedCompressionFormats.s3tc?B.na?t:o:G.supportedCompressionFormats.pvrtc?B.na?a:S:G.supportedCompressionFormats.etc2?Z:G.supportedCompressionFormats.etc1?s:v);return Q}(Q.data.config,Y),f=!1;null===b&&(f=!0,b=Y.na?t:o);let A=!0;z.startTranscoding()||(A=!1);const d=[];for(let s=0;s<Y.images.length&&A;s++){const Z=Y.images[s];if(void 0===G.loadSingleImage||G.loadSingleImage===s){let o=Z.levels.length;!1===G.loadMipmapLevels&&(o=1);for(let t=0;t<o;t++){const o=Z.levels[t],j=B(z,s,t,b,f);if(!j){A=!1;break}o.transcodedPixels=j,d.push(o.transcodedPixels.buffer)}}}z.close(),z.delete(),f&&(b=-1),A?postMessage({action:"transcode",success:A,id:Q.data.id,fileInfo:Y,format:b},d):postMessage({action:"transcode",success:A,id:Q.data.id})}}}!function(s){s[s.cTFETC1=0]="cTFETC1",s[s.cTFETC2=1]="cTFETC2",s[s.cTFBC1=2]="cTFBC1",s[s.cTFBC3=3]="cTFBC3",s[s.cTFBC4=4]="cTFBC4",s[s.cTFBC5=5]="cTFBC5",s[s.cTFBC7=6]="cTFBC7",s[s.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",s[s.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",s[s.cTFASTC_4x4=10]="cTFASTC_4x4",s[s.cTFATC_RGB=11]="cTFATC_RGB",s[s.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",s[s.cTFRGBA32=13]="cTFRGBA32",s[s.cTFRGB565=14]="cTFRGB565",s[s.cTFBGR565=15]="cTFBGR565",s[s.cTFRGBA4444=16]="cTFRGBA4444",s[s.cTFFXT1_RGB=17]="cTFFXT1_RGB",s[s.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",s[s.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",s[s.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",s[s.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(t||(t={}));const v={JSModuleURL:`${j.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${j.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let G=null,B=null,Q=0;const D=async()=>(G||(G=new Promise(((s,Z)=>{B?s(B):j.g.LoadFileAsync(j.g.GetBabylonScriptURL(v.WasmModuleURL)).then((o=>{if("function"!==typeof URL)return Z("Basis transcoder requires an environment with a URL constructor");const t=URL.createObjectURL(new Blob([`(${O})()`],{type:"application/javascript"}));B=new Worker(t),async function(s,Z,o){return await new Promise(((t,S)=>{const a=Z=>{"init"===Z.data.action?(s.removeEventListener("message",a),t(s)):"error"===Z.data.action&&S(Z.data.error||"error initializing worker")};s.addEventListener("message",a),s.postMessage({action:"init",url:o?j.g.GetBabylonScriptURL(o):void 0,wasmBinary:Z},[Z])}))}(B,o,v.JSModuleURL).then(s,Z)})).catch(Z)}))),await G),z=async(s,Z)=>{const o=s instanceof ArrayBuffer?new Uint8Array(s):s;return await new Promise(((s,t)=>{D().then((()=>{const j=Q++,S=Z=>{"transcode"===Z.data.action&&Z.data.id===j&&(B.removeEventListener("message",S),Z.data.success?s(Z.data):t("Transcode is not supported on this device"))};B.addEventListener("message",S);const a=new Uint8Array(o.byteLength);a.set(new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),B.postMessage({action:"transcode",id:j,imageData:a,config:Z,ignoreSupportedFormats:false},[a.buffer])}),(s=>{t(s)}))}))},Y=(s,Z)=>{var o;let t=null===(o=Z._gl)||void 0===o?void 0:o.TEXTURE_2D;var j;s.isCube&&(t=null===(j=Z._gl)||void 0===j?void 0:j.TEXTURE_CUBE_MAP);Z._bindTextureDirectly(t,s,!0)},b=(s,Z)=>{const o=s.getEngine();for(let O=0;O<Z.fileInfo.images.length;O++){const v=Z.fileInfo.images[O].levels[0];if(s._invertVScale=s.invertY,-1===Z.format||Z.format===t.cTFRGB565)if(s.type=10,s.format=4,!o._features.basisNeedsPOT||Math.log2(v.width)%1===0&&Math.log2(v.height)%1===0)s._invertVScale=!s.invertY,s.width=v.width+3&-4,s.height=v.height+3&-4,s.samplingMode=2,Y(s,o),o._uploadDataToTextureDirectly(s,new Uint16Array(v.transcodedPixels.buffer),O,0,4,!0);else{const Z=new a.b(o,2);s._invertVScale=s.invertY,Z.type=10,Z.format=4,Z.width=v.width+3&-4,Z.height=v.height+3&-4,Y(Z,o),o._uploadDataToTextureDirectly(Z,new Uint16Array(v.transcodedPixels.buffer),O,0,4,!0),o._rescaleTexture(Z,s,o.scenes[0],o._getInternalFormat(4),(()=>{o._releaseTexture(Z),Y(s,o)}))}else{s.width=v.width,s.height=v.height,s.generateMipMaps=Z.fileInfo.images[O].levels.length>1;const t=f.GetInternalFormatFromBasisFormat(Z.format,o);s.format=t,Y(s,o);const a=Z.fileInfo.images[O].levels;for(let Z=0;Z<a.length;Z++){const j=a[Z];o._uploadCompressedDataToTextureDirectly(s,t,j.width,j.height,j.transcodedPixels,O,Z)}!o._features.basisNeedsPOT||Math.log2(s.width)%1===0&&Math.log2(s.height)%1===0||(j.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),s._cachedWrapU=S.c.CLAMP_ADDRESSMODE,s._cachedWrapV=S.c.CLAMP_ADDRESSMODE)}}},f={JSModuleURL:v.JSModuleURL,WasmModuleURL:v.WasmModuleURL,GetInternalFormatFromBasisFormat:(s,Z)=>{let o;switch(s){case t.cTFETC1:o=36196;break;case t.cTFBC1:o=33776;break;case t.cTFBC4:o=33779;break;case t.cTFASTC_4x4:o=37808;break;case t.cTFETC2:o=37496;break;case t.cTFBC7:o=36492}if(void 0===o)throw"The chosen Basis transcoder format is not currently supported";return o},TranscodeAsync:z,LoadTextureFromTranscodeResult:b};Object.defineProperty(f,"JSModuleURL",{get:function(){return v.JSModuleURL},set:function(s){v.JSModuleURL=s}}),Object.defineProperty(f,"WasmModuleURL",{get:function(){return v.WasmModuleURL},set:function(s){v.WasmModuleURL=s}});class A{constructor(){this.supportCascades=!1}loadCubeData(s,Z,o,t,S){if(Array.isArray(s))return;const a=Z.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!a.etc1,s3tc:!!a.s3tc,pvrtc:!!a.pvrtc,etc2:!!a.etc2,astc:!!a.astc,bc7:!!a.bptc}};z(s,O).then((s=>{const o=s.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;b(Z,s),Z.getEngine()._setCubeMapTextureParams(Z,o),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),t&&t()})).catch((s=>{j.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.isReady=!0,S&&S(s)}))}loadData(s,Z,o){const t=Z.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!t.etc1,s3tc:!!t.s3tc,pvrtc:!!t.pvrtc,etc2:!!t.etc2,astc:!!t.astc,bc7:!!t.bptc}};z(s,S).then((s=>{const t=s.fileInfo.images[0].levels[0],j=s.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;o(t.width,t.height,j,-1!==s.format,(()=>{b(Z,s)}))})).catch((s=>{j.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),j.g.Warn(`Failed to transcode Basis file: ${s}`),o(0,0,!1,!1,(()=>{}),!0)}))}}}}]);