"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[29],{13995:(H,u,J)=>{var O=J(12280),U=J(12185),h=J(12210),w=J(12306),g=J(12247),B=J(12290);g.d.prototype._partialLoadFile=function(H,u,J,O){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(H,(H=>{J[u]=H,J._internalCount++,6===J._internalCount&&O(J)}),void 0,void 0,!0,((H,u)=>{U&&H&&U(H.status+" "+H.statusText,u)}))},g.d.prototype._cascadeLoadFiles=function(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const U=[];U._internalCount=0;for(let h=0;h<6;h++)this._partialLoadFile(J[h],h,U,u,O)},g.d.prototype._cascadeLoadImgs=function(H,u,J,O){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,h=arguments.length>5?arguments[5]:void 0;const w=[];w._internalCount=0;for(let g=0;g<6;g++)this._partialLoadImg(O[g],g,w,H,u,J,U,h)},g.d.prototype._partialLoadImg=function(H,u,J,O,U,g){let B=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,b=arguments.length>7?arguments[7]:void 0;const d=(0,w.c)();(0,h.p)(H,(H=>{J[u]=H,J._internalCount++,O&&O.removePendingData(d),6===J._internalCount&&g&&g(U,J)}),((H,u)=>{O&&O.removePendingData(d),B&&B(H,u)}),O?O.offlineProvider:null,b),O&&O.addPendingData(d)},g.d.prototype.createCubeTextureBase=function(H,u,J,h){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,g=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,b=arguments.length>6?arguments[6]:void 0,d=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,G=arguments.length>8&&void 0!==arguments[8]&&arguments[8],P=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,mH=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,l=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,r=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,p=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,a=arguments.length>14&&void 0!==arguments[14]&&arguments[14],k=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const C=l||new O.c(this,7);C.isCube=!0,C.url=H,C.generateMipMaps=!h,C._lodGenerationScale=P,C._lodGenerationOffset=mH,C._useSRGBBuffer=!!a&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!h),C!==l&&(C.label=H.substring(0,60)),this._doNotHandleContextLost||(C._extension=d,C._files=J,C._buffer=k);const j=H;this._transformTextureUrl&&!l&&(H=this._transformTextureUrl(H));const M=d??function(H){const u=H.split("?")[0],J=u.lastIndexOf(".");return J>-1?u.substring(J).toLowerCase():""}(H),L=(0,B.c)(M),Z=(H,u)=>{C.dispose(),g?g(H,u):H&&U.b.Warn(H)},Y=(O,g)=>{H===j?O&&Z(O.status+" "+O.statusText,g):(U.b.Warn(`Failed to load ${H}, falling back to the ${j}`),this.createCubeTextureBase(j,u,J,!!h,w,Z,b,d,G,P,mH,C,r,p,a,k))};if(L)L.then((O=>{const U=H=>{r&&r(C,H),O.loadCubeData(H,C,G,w,((H,u)=>{Z(H,u)}))};k?U(k):J&&6===J.length?O.supportCascades?this._cascadeLoadFiles(u,(H=>U(H.map((H=>new Uint8Array(H))))),J,Z):Z("Textures type does not support cascades."):this._loadFile(H,(H=>U(new Uint8Array(H))),void 0,void 0,!0,Y)}));else{if(!J||0===J.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(u,C,((H,u)=>{p&&p(H,u)}),J,Z)}return this._internalTexturesCache.push(C),C}},12850:(H,u,J)=>{J.d(u,{b:()=>b});var O=J(12338),U=J(12349),h=J(12512),w=J(12343),g=J(12379);class B{constructor(H,u,J,O){this.name=H,this.worldAxisForNormal=u,this.worldAxisForFileX=J,this.worldAxisForFileY=O}}class b{static ConvertCubeMapTextureToSphericalPolynomial(H){var u;if(!H.isCube)return null;null===(u=H.ZH())||void 0===u||u.getEngine().flushFramebuffer();const J=H.getSize().width,O=H.readPixels(0,void 0,void 0,!1),U=H.readPixels(1,void 0,void 0,!1);let h,w;H.isRenderTarget?(h=H.readPixels(3,void 0,void 0,!1),w=H.readPixels(2,void 0,void 0,!1)):(h=H.readPixels(2,void 0,void 0,!1),w=H.readPixels(3,void 0,void 0,!1));const g=H.readPixels(4,void 0,void 0,!1),B=H.readPixels(5,void 0,void 0,!1),b=H.gammaSpace;let d=0;return 1!=H.textureType&&2!=H.textureType||(d=1),new Promise((H=>{Promise.all([U,O,h,w,g,B]).then((u=>{let[O,U,h,w,g,B]=u;const G={size:J,right:U,left:O,up:h,down:w,front:g,back:B,format:5,type:d,gammaSpace:b};H(this.ConvertCubeMapToSphericalPolynomial(G))}))}))}static _AreaElement(H,u){return Math.atan2(H*u,Math.sqrt(H*H+u*u+1))}static ConvertCubeMapToSphericalPolynomial(H){const u=new h.b;let J=0;const O=2/H.size,B=O,b=.5*O,d=b-1;for(let h=0;h<6;h++){const G=this._FileFaces[h],P=H[G.name];let mH=d;const l=5===H.format?4:3;for(let h=0;h<H.size;h++){let r=d;for(let B=0;B<H.size;B++){const d=G.worldAxisForFileX.scale(r).add(G.worldAxisForFileY.scale(mH)).add(G.worldAxisForNormal);d.normalize();const p=this._AreaElement(r-b,mH-b)-this._AreaElement(r-b,mH+b)-this._AreaElement(r+b,mH-b)+this._AreaElement(r+b,mH+b);let a=P[h*H.size*l+B*l+0],k=P[h*H.size*l+B*l+1],C=P[h*H.size*l+B*l+2];isNaN(a)&&(a=0),isNaN(k)&&(k=0),isNaN(C)&&(C=0),0===H.type&&(a/=255,k/=255,C/=255),H.gammaSpace&&(a=Math.pow((0,U.Clamp)(a),w.n),k=Math.pow((0,U.Clamp)(k),w.n),C=Math.pow((0,U.Clamp)(C),w.n));const j=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const H=Math.max(a,k,C);if(H>j){const u=j/H;a*=u,k*=u,C*=u}}else a=(0,U.Clamp)(a,0,j),k=(0,U.Clamp)(k,0,j),C=(0,U.Clamp)(C,0,j);const M=new g.ku(a,k,C);u.addLight(d,M,p),J+=p,r+=O}mH+=B}}const G=6*(4*Math.PI)/6/J;return u.scaleInPlace(G),u.convertIncidentRadianceToIrradiance(),u.convertIrradianceToLambertianRadiance(),h.e.FromHarmonics(u)}}b._FileFaces=[new B("right",new O.lu(1,0,0),new O.lu(0,0,-1),new O.lu(0,-1,0)),new B("left",new O.lu(-1,0,0),new O.lu(0,0,1),new O.lu(0,-1,0)),new B("up",new O.lu(0,1,0),new O.lu(1,0,0),new O.lu(0,0,1)),new B("down",new O.lu(0,-1,0),new O.lu(1,0,0),new O.lu(0,0,-1)),new B("front",new O.lu(0,0,1),new O.lu(1,0,0),new O.lu(0,-1,0)),new B("back",new O.lu(0,0,-1),new O.lu(-1,0,0),new O.lu(0,-1,0))],b.MAX_HDRI_VALUE=4096,b.PRESERVE_CLAMPED_COLORS=!1},14741:(H,u,J)=>{J.d(u,{DDSTools:()=>l});var O=J(12349),U=J(12185),h=J(12850),w=J(12555);J(13995);const g=131072,B=131072;function b(H){return H.charCodeAt(0)+(H.charCodeAt(1)<<8)+(H.charCodeAt(2)<<16)+(H.charCodeAt(3)<<24)}const d=b("DXT1"),G=b("DXT3"),P=b("DXT5"),mH=b("DX10");class l{static GetDDSInfo(H){const u=new Int32Array(H.buffer,H.byteOffset,31),J=new Int32Array(H.buffer,H.byteOffset,35);let O=1;u[2]&g&&(O=Math.max(1,u[7]));const U=u[21],h=U===mH?J[32]:0;let w=0;switch(U){case 113:w=2;break;case 116:w=1;break;case mH:if(10===h){w=2;break}if(2===h){w=1;break}}return{width:u[4],height:u[3],mipmapCount:O,isFourCC:4===(4&u[20]),isRGB:64===(64&u[20]),isLuminance:(u[20]&B)===B,isCube:512===(512&u[28]),isCompressed:U===d||U===G||U===P,dxgiFormat:h,textureType:w}}static _GetHalfFloatAsFloatRGBAArrayBuffer(H,u,J,O,U,h){const g=new Float32Array(O),B=new Uint16Array(U,J);let b=0;for(let d=0;d<u;d++)for(let u=0;u<H;u++){const J=4*(u+d*H);g[b]=(0,w.i)(B[J]),g[b+1]=(0,w.i)(B[J+1]),g[b+2]=(0,w.i)(B[J+2]),l.StoreLODInAlphaChannel?g[b+3]=h:g[b+3]=(0,w.i)(B[J+3]),b+=4}return g}static _GetHalfFloatRGBAArrayBuffer(H,u,J,O,U,h){if(l.StoreLODInAlphaChannel){const g=new Uint16Array(O),B=new Uint16Array(U,J);let b=0;for(let J=0;J<u;J++)for(let u=0;u<H;u++){const O=4*(u+J*H);g[b]=B[O],g[b+1]=B[O+1],g[b+2]=B[O+2],g[b+3]=(0,w.o)(h),b+=4}return g}return new Uint16Array(U,J,O)}static _GetFloatRGBAArrayBuffer(H,u,J,O,U,h){if(l.StoreLODInAlphaChannel){const w=new Float32Array(O),g=new Float32Array(U,J);let B=0;for(let J=0;J<u;J++)for(let u=0;u<H;u++){const O=4*(u+J*H);w[B]=g[O],w[B+1]=g[O+1],w[B+2]=g[O+2],w[B+3]=h,B+=4}return w}return new Float32Array(U,J,O)}static _GetFloatAsHalfFloatRGBAArrayBuffer(H,u,J,O,U,h){const g=new Uint16Array(O),B=new Float32Array(U,J);let b=0;for(let d=0;d<u;d++)for(let u=0;u<H;u++)g[b]=(0,w.o)(B[b]),g[b+1]=(0,w.o)(B[b+1]),g[b+2]=(0,w.o)(B[b+2]),l.StoreLODInAlphaChannel?g[b+3]=(0,w.o)(h):g[b+3]=(0,w.o)(B[b+3]),b+=4;return g}static _GetFloatAsUIntRGBAArrayBuffer(H,u,J,U,h,w){const g=new Uint8Array(U),B=new Float32Array(h,J);let b=0;for(let d=0;d<u;d++)for(let u=0;u<H;u++){const J=4*(u+d*H);g[b]=255*(0,O.Clamp)(B[J]),g[b+1]=255*(0,O.Clamp)(B[J+1]),g[b+2]=255*(0,O.Clamp)(B[J+2]),l.StoreLODInAlphaChannel?g[b+3]=w:g[b+3]=255*(0,O.Clamp)(B[J+3]),b+=4}return g}static _GetHalfFloatAsUIntRGBAArrayBuffer(H,u,J,U,h,g){const B=new Uint8Array(U),b=new Uint16Array(h,J);let d=0;for(let G=0;G<u;G++)for(let u=0;u<H;u++){const J=4*(u+G*H);B[d]=255*(0,O.Clamp)((0,w.i)(b[J])),B[d+1]=255*(0,O.Clamp)((0,w.i)(b[J+1])),B[d+2]=255*(0,O.Clamp)((0,w.i)(b[J+2])),l.StoreLODInAlphaChannel?B[d+3]=g:B[d+3]=255*(0,O.Clamp)((0,w.i)(b[J+3])),d+=4}return B}static _GetRGBAArrayBuffer(H,u,J,O,U,h,w,g,B){const b=new Uint8Array(O),d=new Uint8Array(U,J);let G=0;for(let P=0;P<u;P++)for(let u=0;u<H;u++){const J=4*(u+P*H);b[G]=d[J+h],b[G+1]=d[J+w],b[G+2]=d[J+g],b[G+3]=d[J+B],G+=4}return b}static _ExtractLongWordOrder(H){return 0===H||255===H||-16777216===H?0:1+l._ExtractLongWordOrder(H>>8)}static _GetRGBArrayBuffer(H,u,J,O,U,h,w,g){const B=new Uint8Array(O),b=new Uint8Array(U,J);let d=0;for(let G=0;G<u;G++)for(let u=0;u<H;u++){const J=3*(u+G*H);B[d]=b[J+h],B[d+1]=b[J+w],B[d+2]=b[J+g],d+=3}return B}static _GetLuminanceArrayBuffer(H,u,J,O,U){const h=new Uint8Array(O),w=new Uint8Array(U,J);let g=0;for(let B=0;B<u;B++)for(let u=0;u<H;u++){const J=u+B*H;h[g]=w[J],g++}return h}static UploadDDSLevels(H,u,J,O,w,B){let b=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,r=arguments.length>7?arguments[7]:void 0,p=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=null;O.sphericalPolynomial&&(a=[]);const k=!!H.getCaps().s3tc;u.generateMipMaps=w;const C=new Int32Array(J.buffer,J.byteOffset,31);let j,M,L,Z,Y,F,s,A=0,t=0,e=1;if(542327876!==C[0])return void U.b.Error("Invalid magic number in DDS header");if(!O.isFourCC&&!O.isRGB&&!O.isLuminance)return void U.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(O.isCompressed&&!k)return void U.b.Error("Compressed textures are not supported on this platform.");let c=C[22];Z=C[1]+4;let n=!1;if(O.isFourCC)switch(j=C[21],j){case d:e=8,t=33777;break;case G:e=16,t=33778;break;case P:e=16,t=33779;break;case 113:n=!0,c=64;break;case 116:n=!0,c=128;break;case mH:{Z+=20;let H=!1;switch(O.dxgiFormat){case 10:n=!0,c=64,H=!0;break;case 2:n=!0,c=128,H=!0;break;case 88:O.isRGB=!0,O.isFourCC=!1,c=32,H=!0}if(H)break}default:return void U.b.Error(["Unsupported FourCC code:",(V=j,String.fromCharCode(255&V,V>>8&255,V>>16&255,V>>24&255))])}var V;const T=l._ExtractLongWordOrder(C[23]),R=l._ExtractLongWordOrder(C[24]),X=l._ExtractLongWordOrder(C[25]),W=l._ExtractLongWordOrder(C[26]);n&&(t=H._getRGBABufferInternalSizedFormat(O.textureType)),F=1,C[2]&g&&!1!==w&&(F=Math.max(1,C[7]));const f=r||0,i=H.getCaps();for(let U=f;U<B;U++){for(M=C[4],L=C[3],s=0;s<F;++s){if(-1===b||b===s){const h=-1===b?s:0;if(!O.isCompressed&&O.isFourCC){u.format=5,A=M*L*4;let O=null;if(H._badOS||H._badDesktopOS||!i.textureHalfFloat&&!i.textureFloat)128===c?(O=l._GetFloatAsUIntRGBAArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,h),a&&0==h&&a.push(l._GetFloatRGBAArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,h))):64===c&&(O=l._GetHalfFloatAsUIntRGBAArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,h),a&&0==h&&a.push(l._GetHalfFloatAsFloatRGBAArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,h))),u.type=0;else{const H=i.textureFloat&&(p&&i.textureFloatLinearFiltering||!p),U=i.textureHalfFloat&&(p&&i.textureHalfFloatLinearFiltering||!p),w=(128===c||64===c&&!U)&&H?1:(64===c||128===c&&!H)&&U?2:0;let g,B=null;if(128===c)switch(w){case 1:g=l._GetFloatRGBAArrayBuffer,B=null;break;case 2:g=l._GetFloatAsHalfFloatRGBAArrayBuffer,B=l._GetFloatRGBAArrayBuffer;break;case 0:g=l._GetFloatAsUIntRGBAArrayBuffer,B=l._GetFloatRGBAArrayBuffer}else switch(w){case 1:g=l._GetHalfFloatAsFloatRGBAArrayBuffer,B=null;break;case 2:g=l._GetHalfFloatRGBAArrayBuffer,B=l._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:g=l._GetHalfFloatAsUIntRGBAArrayBuffer,B=l._GetHalfFloatAsFloatRGBAArrayBuffer}u.type=w,O=g(M,L,J.byteOffset+Z,A,J.buffer,h),a&&0==h&&a.push(B?B(M,L,J.byteOffset+Z,A,J.buffer,h):O)}O&&H._uploadDataToTextureDirectly(u,O,U,h)}else if(O.isRGB)u.type=0,24===c?(u.format=4,A=M*L*3,Y=l._GetRGBArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,T,R,X),H._uploadDataToTextureDirectly(u,Y,U,h)):(u.format=5,A=M*L*4,Y=l._GetRGBAArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer,T,R,X,W),H._uploadDataToTextureDirectly(u,Y,U,h));else if(O.isLuminance){const O=H._getUnpackAlignement(),w=M;A=Math.floor((M+O-1)/O)*O*(L-1)+w,Y=l._GetLuminanceArrayBuffer(M,L,J.byteOffset+Z,A,J.buffer),u.format=1,u.type=0,H._uploadDataToTextureDirectly(u,Y,U,h)}else A=Math.max(4,M)/4*Math.max(4,L)/4*e,Y=new Uint8Array(J.buffer,J.byteOffset+Z,A),u.type=0,H._uploadCompressedDataToTextureDirectly(u,t,M,L,Y,U,h)}Z+=c?M*L*(c/8):A,M*=.5,L*=.5,M=Math.max(1,M),L=Math.max(1,L)}if(void 0!==r)break}a&&a.length>0?O.sphericalPolynomial=h.b.ConvertCubeMapToSphericalPolynomial({size:C[4],right:a[0],left:a[1],up:a[2],down:a[3],front:a[4],back:a[5],format:5,type:1,gammaSpace:!1}):O.sphericalPolynomial=void 0}}l.StoreLODInAlphaChannel=!1}}]);