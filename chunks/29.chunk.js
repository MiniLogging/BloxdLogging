"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[29],{14192:(K,A,T)=>{var G=T(12637),B=T(12548),L=T(12571),f=T(12653),O=T(12604),C=T(12642);O.c.prototype._partialLoadFile=function(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(K,(K=>{T[A]=K,T._internalCount++,6===T._internalCount&&G(T)}),void 0,void 0,!0,((K,A)=>{B&&K&&B(K.status+" "+K.statusText,A)}))},O.c.prototype._cascadeLoadFiles=function(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const B=[];B._internalCount=0;for(let L=0;L<6;L++)this._partialLoadFile(T[L],L,B,A,G)},O.c.prototype._cascadeLoadImgs=function(K,A,T,G){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,L=arguments.length>5?arguments[5]:void 0;const f=[];f._internalCount=0;for(let O=0;O<6;O++)this._partialLoadImg(G[O],O,f,K,A,T,B,L)},O.c.prototype._partialLoadImg=function(K,A,T,G,B,O){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,Q=arguments.length>7?arguments[7]:void 0;const Y=(0,f.d)();(0,L.u)(K,(K=>{T[A]=K,T._internalCount++,G&&G.removePendingData(Y),6===T._internalCount&&O&&O(B,T)}),((K,A)=>{G&&G.removePendingData(Y),C&&C(K,A)}),G?G.offlineProvider:null,Q),G&&G.addPendingData(Y)},O.c.prototype.createCubeTextureBase=function(K,A,T,L){let f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,Q=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Z=arguments.length>8&&void 0!==arguments[8]&&arguments[8],x=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,J=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,b=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,P=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,F=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,d=arguments.length>14&&void 0!==arguments[14]&&arguments[14],N=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const D=b||new G.b(this,7);D.isCube=!0,D.url=K,D.generateMipMaps=!L,D._lodGenerationScale=x,D._lodGenerationOffset=J,D._useSRGBBuffer=!!d&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!L),D!==b&&(D.label=K.substring(0,60)),this._doNotHandleContextLost||(D._extension=Y,D._files=T,D._buffer=N);const mK=K;this._transformTextureUrl&&!b&&(K=this._transformTextureUrl(K));const U=Y??function(K){const A=K.split("?")[0],T=A.lastIndexOf(".");return T>-1?A.substring(T).toLowerCase():""}(K),z=(0,C.b)(U),g=(K,A)=>{D.dispose(),O?O(K,A):K&&B.d.Warn(K)},S=(G,O)=>{K===mK?G&&g(G.status+" "+G.statusText,O):(B.d.Warn(`Failed to load ${K}, falling back to the ${mK}`),this.createCubeTextureBase(mK,A,T,!!L,f,g,Q,Y,Z,x,J,D,P,F,d,N))};if(z)z.then((G=>{const B=K=>{P&&P(D,K),G.loadCubeData(K,D,Z,f,((K,A)=>{g(K,A)}))};N?B(N):T&&6===T.length?G.supportCascades?this._cascadeLoadFiles(A,(K=>B(K.map((K=>new Uint8Array(K))))),T,g):g("Textures type does not support cascades."):this._loadFile(K,(K=>B(new Uint8Array(K))),void 0,void 0,!0,S)}));else{if(!T||0===T.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(A,D,((K,A)=>{F&&F(K,A)}),T,g)}return this._internalTexturesCache.push(D),D}},13222:(K,A,T)=>{T.d(A,{e:()=>Q});var G=T(12700),B=T(12716),L=T(12883),f=T(12706),O=T(12743);class C{constructor(K,A,T,G){this.name=K,this.worldAxisForNormal=A,this.worldAxisForFileX=T,this.worldAxisForFileY=G}}class Q{static ConvertCubeMapTextureToSphericalPolynomial(K){var A;if(!K.isCube)return null;null===(A=K.SK())||void 0===A||A.getEngine().flushFramebuffer();const T=K.getSize().width,G=K.readPixels(0,void 0,void 0,!1),B=K.readPixels(1,void 0,void 0,!1);let L,f;K.isRenderTarget?(L=K.readPixels(3,void 0,void 0,!1),f=K.readPixels(2,void 0,void 0,!1)):(L=K.readPixels(2,void 0,void 0,!1),f=K.readPixels(3,void 0,void 0,!1));const O=K.readPixels(4,void 0,void 0,!1),C=K.readPixels(5,void 0,void 0,!1),Q=K.gammaSpace;let Y=0;return 1!=K.textureType&&2!=K.textureType||(Y=1),new Promise((K=>{Promise.all([B,G,L,f,O,C]).then((A=>{let[G,B,L,f,O,C]=A;const Z={size:T,right:B,left:G,up:L,down:f,front:O,back:C,format:5,type:Y,gammaSpace:Q};K(this.ConvertCubeMapToSphericalPolynomial(Z))}))}))}static _AreaElement(K,A){return Math.atan2(K*A,Math.sqrt(K*K+A*A+1))}static ConvertCubeMapToSphericalPolynomial(K){const A=new L.e;let T=0;const G=2/K.size,C=G,Q=.5*G,Y=Q-1;for(let L=0;L<6;L++){const Z=this._FileFaces[L],x=K[Z.name];let J=Y;const b=5===K.format?4:3;for(let L=0;L<K.size;L++){let P=Y;for(let C=0;C<K.size;C++){const Y=Z.worldAxisForFileX.scale(P).add(Z.worldAxisForFileY.scale(J)).add(Z.worldAxisForNormal);Y.normalize();const F=this._AreaElement(P-Q,J-Q)-this._AreaElement(P-Q,J+Q)-this._AreaElement(P+Q,J-Q)+this._AreaElement(P+Q,J+Q);let d=x[L*K.size*b+C*b+0],N=x[L*K.size*b+C*b+1],D=x[L*K.size*b+C*b+2];isNaN(d)&&(d=0),isNaN(N)&&(N=0),isNaN(D)&&(D=0),0===K.type&&(d/=255,N/=255,D/=255),K.gammaSpace&&(d=Math.pow((0,B.Clamp)(d),f.k),N=Math.pow((0,B.Clamp)(N),f.k),D=Math.pow((0,B.Clamp)(D),f.k));const mK=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const K=Math.max(d,N,D);if(K>mK){const A=mK/K;d*=A,N*=A,D*=A}}else d=(0,B.Clamp)(d,0,mK),N=(0,B.Clamp)(N,0,mK),D=(0,B.Clamp)(D,0,mK);const U=new O.DA(d,N,D);A.addLight(Y,U,F),T+=F,P+=G}J+=C}}const Z=6*(4*Math.PI)/6/T;return A.scaleInPlace(Z),A.convertIncidentRadianceToIrradiance(),A.convertIrradianceToLambertianRadiance(),L.g.FromHarmonics(A)}}Q._FileFaces=[new C("right",new G.PA(1,0,0),new G.PA(0,0,-1),new G.PA(0,-1,0)),new C("left",new G.PA(-1,0,0),new G.PA(0,0,1),new G.PA(0,-1,0)),new C("up",new G.PA(0,1,0),new G.PA(1,0,0),new G.PA(0,0,1)),new C("down",new G.PA(0,-1,0),new G.PA(1,0,0),new G.PA(0,0,-1)),new C("front",new G.PA(0,0,1),new G.PA(1,0,0),new G.PA(0,-1,0)),new C("back",new G.PA(0,0,-1),new G.PA(-1,0,0),new G.PA(0,-1,0))],Q.MAX_HDRI_VALUE=4096,Q.PRESERVE_CLAMPED_COLORS=!1},15132:(K,A,T)=>{T.d(A,{DDSTools:()=>b});var G=T(12716),B=T(12548),L=T(13222),f=T(12920);T(14192);const O=131072,C=131072;function Q(K){return K.charCodeAt(0)+(K.charCodeAt(1)<<8)+(K.charCodeAt(2)<<16)+(K.charCodeAt(3)<<24)}const Y=Q("DXT1"),Z=Q("DXT3"),x=Q("DXT5"),J=Q("DX10");class b{static GetDDSInfo(K){const A=new Int32Array(K.buffer,K.byteOffset,31),T=new Int32Array(K.buffer,K.byteOffset,35);let G=1;A[2]&O&&(G=Math.max(1,A[7]));const B=A[21],L=B===J?T[32]:0;let f=0;switch(B){case 113:f=2;break;case 116:f=1;break;case J:if(10===L){f=2;break}if(2===L){f=1;break}}return{width:A[4],height:A[3],mipmapCount:G,isFourCC:4===(4&A[20]),isRGB:64===(64&A[20]),isLuminance:(A[20]&C)===C,isCube:512===(512&A[28]),isCompressed:B===Y||B===Z||B===x,dxgiFormat:L,textureType:f}}static _GetHalfFloatAsFloatRGBAArrayBuffer(K,A,T,G,B,L){const O=new Float32Array(G),C=new Uint16Array(B,T);let Q=0;for(let Y=0;Y<A;Y++)for(let A=0;A<K;A++){const T=4*(A+Y*K);O[Q]=(0,f.e)(C[T]),O[Q+1]=(0,f.e)(C[T+1]),O[Q+2]=(0,f.e)(C[T+2]),b.StoreLODInAlphaChannel?O[Q+3]=L:O[Q+3]=(0,f.e)(C[T+3]),Q+=4}return O}static _GetHalfFloatRGBAArrayBuffer(K,A,T,G,B,L){if(b.StoreLODInAlphaChannel){const O=new Uint16Array(G),C=new Uint16Array(B,T);let Q=0;for(let T=0;T<A;T++)for(let A=0;A<K;A++){const G=4*(A+T*K);O[Q]=C[G],O[Q+1]=C[G+1],O[Q+2]=C[G+2],O[Q+3]=(0,f.k)(L),Q+=4}return O}return new Uint16Array(B,T,G)}static _GetFloatRGBAArrayBuffer(K,A,T,G,B,L){if(b.StoreLODInAlphaChannel){const f=new Float32Array(G),O=new Float32Array(B,T);let C=0;for(let T=0;T<A;T++)for(let A=0;A<K;A++){const G=4*(A+T*K);f[C]=O[G],f[C+1]=O[G+1],f[C+2]=O[G+2],f[C+3]=L,C+=4}return f}return new Float32Array(B,T,G)}static _GetFloatAsHalfFloatRGBAArrayBuffer(K,A,T,G,B,L){const O=new Uint16Array(G),C=new Float32Array(B,T);let Q=0;for(let Y=0;Y<A;Y++)for(let A=0;A<K;A++)O[Q]=(0,f.k)(C[Q]),O[Q+1]=(0,f.k)(C[Q+1]),O[Q+2]=(0,f.k)(C[Q+2]),b.StoreLODInAlphaChannel?O[Q+3]=(0,f.k)(L):O[Q+3]=(0,f.k)(C[Q+3]),Q+=4;return O}static _GetFloatAsUIntRGBAArrayBuffer(K,A,T,B,L,f){const O=new Uint8Array(B),C=new Float32Array(L,T);let Q=0;for(let Y=0;Y<A;Y++)for(let A=0;A<K;A++){const T=4*(A+Y*K);O[Q]=255*(0,G.Clamp)(C[T]),O[Q+1]=255*(0,G.Clamp)(C[T+1]),O[Q+2]=255*(0,G.Clamp)(C[T+2]),b.StoreLODInAlphaChannel?O[Q+3]=f:O[Q+3]=255*(0,G.Clamp)(C[T+3]),Q+=4}return O}static _GetHalfFloatAsUIntRGBAArrayBuffer(K,A,T,B,L,O){const C=new Uint8Array(B),Q=new Uint16Array(L,T);let Y=0;for(let Z=0;Z<A;Z++)for(let A=0;A<K;A++){const T=4*(A+Z*K);C[Y]=255*(0,G.Clamp)((0,f.e)(Q[T])),C[Y+1]=255*(0,G.Clamp)((0,f.e)(Q[T+1])),C[Y+2]=255*(0,G.Clamp)((0,f.e)(Q[T+2])),b.StoreLODInAlphaChannel?C[Y+3]=O:C[Y+3]=255*(0,G.Clamp)((0,f.e)(Q[T+3])),Y+=4}return C}static _GetRGBAArrayBuffer(K,A,T,G,B,L,f,O,C){const Q=new Uint8Array(G),Y=new Uint8Array(B,T);let Z=0;for(let x=0;x<A;x++)for(let A=0;A<K;A++){const T=4*(A+x*K);Q[Z]=Y[T+L],Q[Z+1]=Y[T+f],Q[Z+2]=Y[T+O],Q[Z+3]=Y[T+C],Z+=4}return Q}static _ExtractLongWordOrder(K){return 0===K||255===K||-16777216===K?0:1+b._ExtractLongWordOrder(K>>8)}static _GetRGBArrayBuffer(K,A,T,G,B,L,f,O){const C=new Uint8Array(G),Q=new Uint8Array(B,T);let Y=0;for(let Z=0;Z<A;Z++)for(let A=0;A<K;A++){const T=3*(A+Z*K);C[Y]=Q[T+L],C[Y+1]=Q[T+f],C[Y+2]=Q[T+O],Y+=3}return C}static _GetLuminanceArrayBuffer(K,A,T,G,B){const L=new Uint8Array(G),f=new Uint8Array(B,T);let O=0;for(let C=0;C<A;C++)for(let A=0;A<K;A++){const T=A+C*K;L[O]=f[T],O++}return L}static UploadDDSLevels(K,A,T,G,f,C){let Q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,P=arguments.length>7?arguments[7]:void 0,F=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],d=null;G.sphericalPolynomial&&(d=[]);const N=!!K.getCaps().s3tc;A.generateMipMaps=f;const D=new Int32Array(T.buffer,T.byteOffset,31);let mK,U,z,g,S,l,u,c=0,n=0,H=1;if(542327876!==D[0])return void B.d.Error("Invalid magic number in DDS header");if(!G.isFourCC&&!G.isRGB&&!G.isLuminance)return void B.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(G.isCompressed&&!N)return void B.d.Error("Compressed textures are not supported on this platform.");let e=D[22];g=D[1]+4;let p=!1;if(G.isFourCC)switch(mK=D[21],mK){case Y:H=8,n=33777;break;case Z:H=16,n=33778;break;case x:H=16,n=33779;break;case 113:p=!0,e=64;break;case 116:p=!0,e=128;break;case J:{g+=20;let K=!1;switch(G.dxgiFormat){case 10:p=!0,e=64,K=!0;break;case 2:p=!0,e=128,K=!0;break;case 88:G.isRGB=!0,G.isFourCC=!1,e=32,K=!0}if(K)break}default:return void B.d.Error(["Unsupported FourCC code:",(r=mK,String.fromCharCode(255&r,r>>8&255,r>>16&255,r>>24&255))])}var r;const h=b._ExtractLongWordOrder(D[23]),k=b._ExtractLongWordOrder(D[24]),s=b._ExtractLongWordOrder(D[25]),j=b._ExtractLongWordOrder(D[26]);p&&(n=K._getRGBABufferInternalSizedFormat(G.textureType)),l=1,D[2]&O&&!1!==f&&(l=Math.max(1,D[7]));const R=P||0,v=K.getCaps();for(let B=R;B<C;B++){for(U=D[4],z=D[3],u=0;u<l;++u){if(-1===Q||Q===u){const L=-1===Q?u:0;if(!G.isCompressed&&G.isFourCC){A.format=5,c=U*z*4;let G=null;if(K._badOS||K._badDesktopOS||!v.textureHalfFloat&&!v.textureFloat)128===e?(G=b._GetFloatAsUIntRGBAArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,L),d&&0==L&&d.push(b._GetFloatRGBAArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,L))):64===e&&(G=b._GetHalfFloatAsUIntRGBAArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,L),d&&0==L&&d.push(b._GetHalfFloatAsFloatRGBAArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,L))),A.type=0;else{const K=v.textureFloat&&(F&&v.textureFloatLinearFiltering||!F),B=v.textureHalfFloat&&(F&&v.textureHalfFloatLinearFiltering||!F),f=(128===e||64===e&&!B)&&K?1:(64===e||128===e&&!K)&&B?2:0;let O,C=null;if(128===e)switch(f){case 1:O=b._GetFloatRGBAArrayBuffer,C=null;break;case 2:O=b._GetFloatAsHalfFloatRGBAArrayBuffer,C=b._GetFloatRGBAArrayBuffer;break;case 0:O=b._GetFloatAsUIntRGBAArrayBuffer,C=b._GetFloatRGBAArrayBuffer}else switch(f){case 1:O=b._GetHalfFloatAsFloatRGBAArrayBuffer,C=null;break;case 2:O=b._GetHalfFloatRGBAArrayBuffer,C=b._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:O=b._GetHalfFloatAsUIntRGBAArrayBuffer,C=b._GetHalfFloatAsFloatRGBAArrayBuffer}A.type=f,G=O(U,z,T.byteOffset+g,c,T.buffer,L),d&&0==L&&d.push(C?C(U,z,T.byteOffset+g,c,T.buffer,L):G)}G&&K._uploadDataToTextureDirectly(A,G,B,L)}else if(G.isRGB)A.type=0,24===e?(A.format=4,c=U*z*3,S=b._GetRGBArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,h,k,s),K._uploadDataToTextureDirectly(A,S,B,L)):(A.format=5,c=U*z*4,S=b._GetRGBAArrayBuffer(U,z,T.byteOffset+g,c,T.buffer,h,k,s,j),K._uploadDataToTextureDirectly(A,S,B,L));else if(G.isLuminance){const G=K._getUnpackAlignement(),f=U;c=Math.floor((U+G-1)/G)*G*(z-1)+f,S=b._GetLuminanceArrayBuffer(U,z,T.byteOffset+g,c,T.buffer),A.format=1,A.type=0,K._uploadDataToTextureDirectly(A,S,B,L)}else c=Math.max(4,U)/4*Math.max(4,z)/4*H,S=new Uint8Array(T.buffer,T.byteOffset+g,c),A.type=0,K._uploadCompressedDataToTextureDirectly(A,n,U,z,S,B,L)}g+=e?U*z*(e/8):c,U*=.5,z*=.5,U=Math.max(1,U),z=Math.max(1,z)}if(void 0!==P)break}d&&d.length>0?G.sphericalPolynomial=L.e.ConvertCubeMapToSphericalPolynomial({size:D[4],right:d[0],left:d[1],up:d[2],down:d[3],front:d[4],back:d[5],format:5,type:1,gammaSpace:!1}):G.sphericalPolynomial=void 0}}b.StoreLODInAlphaChannel=!1}}]);