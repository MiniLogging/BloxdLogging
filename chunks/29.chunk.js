"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[29],{14319:(L,U,x)=>{var mL=x(12521),p=x(12406),G=x(12448),F=x(12550),a=x(12479),o=x(12532);a.e.prototype._partialLoadFile=function(L,U,x,mL){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(L,(L=>{x[U]=L,x._internalCount++,6===x._internalCount&&mL(x)}),void 0,void 0,!0,((L,U)=>{p&&L&&p(L.status+" "+L.statusText,U)}))},a.e.prototype._cascadeLoadFiles=function(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const p=[];p._internalCount=0;for(let G=0;G<6;G++)this._partialLoadFile(x[G],G,p,U,mL)},a.e.prototype._cascadeLoadImgs=function(L,U,x,mL){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,G=arguments.length>5?arguments[5]:void 0;const F=[];F._internalCount=0;for(let a=0;a<6;a++)this._partialLoadImg(mL[a],a,F,L,U,x,p,G)},a.e.prototype._partialLoadImg=function(L,U,x,mL,p,a){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,A=arguments.length>7?arguments[7]:void 0;const r=(0,F.b)();(0,G.q)(L,(L=>{x[U]=L,x._internalCount++,mL&&mL.removePendingData(r),6===x._internalCount&&a&&a(p,x)}),((L,U)=>{mL&&mL.removePendingData(r),o&&o(L,U)}),mL?mL.offlineProvider:null,A),mL&&mL.addPendingData(r)},a.e.prototype.createCubeTextureBase=function(L,U,x,G){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,A=arguments.length>6?arguments[6]:void 0,r=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8],b=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,E=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,Y=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,S=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,V=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,H=arguments.length>14&&void 0!==arguments[14]&&arguments[14],Q=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const q=Y||new mL.d(this,7);q.isCube=!0,q.url=L,q.generateMipMaps=!G,q._lodGenerationScale=b,q._lodGenerationOffset=E,q._useSRGBBuffer=!!H&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!G),q!==Y&&(q.label=L.substring(0,60)),this._doNotHandleContextLost||(q._extension=r,q._files=x,q._buffer=Q);const f=L;this._transformTextureUrl&&!Y&&(L=this._transformTextureUrl(L));const v=r??function(L){const U=L.split("?")[0],x=U.lastIndexOf(".");return x>-1?U.substring(x).toLowerCase():""}(L),D=(0,o.d)(v),P=(L,U)=>{q.dispose(),a?a(L,U):L&&p.c.Warn(L)},d=(mL,a)=>{L===f?mL&&P(mL.status+" "+mL.statusText,a):(p.c.Warn(`Failed to load ${L}, falling back to the ${f}`),this.createCubeTextureBase(f,U,x,!!G,F,P,A,r,h,b,E,q,S,V,H,Q))};if(D)D.then((mL=>{const p=L=>{S&&S(q,L),mL.loadCubeData(L,q,h,F,((L,U)=>{P(L,U)}))};Q?p(Q):x&&6===x.length?mL.supportCascades?this._cascadeLoadFiles(U,(L=>p(L.map((L=>new Uint8Array(L))))),x,P):P("Textures type does not support cascades."):this._loadFile(L,(L=>p(new Uint8Array(L))),void 0,void 0,!0,d)}));else{if(!x||0===x.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(U,q,((L,U)=>{V&&V(L,U)}),x,P)}return this._internalTexturesCache.push(q),q}},13131:(L,U,x)=>{x.d(U,{c:()=>A});var mL=x(12589),p=x(12610),G=x(12773),F=x(12598),a=x(12637);class o{constructor(L,U,x,mL){this.name=L,this.worldAxisForNormal=U,this.worldAxisForFileX=x,this.worldAxisForFileY=mL}}class A{static ConvertCubeMapTextureToSphericalPolynomial(L){var U;if(!L.isCube)return null;null===(U=L.PL())||void 0===U||U.getEngine().flushFramebuffer();const x=L.getSize().width,mL=L.readPixels(0,void 0,void 0,!1),p=L.readPixels(1,void 0,void 0,!1);let G,F;L.isRenderTarget?(G=L.readPixels(3,void 0,void 0,!1),F=L.readPixels(2,void 0,void 0,!1)):(G=L.readPixels(2,void 0,void 0,!1),F=L.readPixels(3,void 0,void 0,!1));const a=L.readPixels(4,void 0,void 0,!1),o=L.readPixels(5,void 0,void 0,!1),A=L.gammaSpace;let r=0;return 1!=L.textureType&&2!=L.textureType||(r=1),new Promise((L=>{Promise.all([p,mL,G,F,a,o]).then((U=>{let[mL,p,G,F,a,o]=U;const h={size:x,right:p,left:mL,up:G,down:F,front:a,back:o,format:5,type:r,gammaSpace:A};L(this.ConvertCubeMapToSphericalPolynomial(h))}))}))}static _AreaElement(L,U){return Math.atan2(L*U,Math.sqrt(L*L+U*U+1))}static ConvertCubeMapToSphericalPolynomial(L){const U=new G.b;let x=0;const mL=2/L.size,o=mL,A=.5*mL,r=A-1;for(let G=0;G<6;G++){const h=this._FileFaces[G],b=L[h.name];let E=r;const Y=5===L.format?4:3;for(let G=0;G<L.size;G++){let S=r;for(let o=0;o<L.size;o++){const r=h.worldAxisForFileX.scale(S).add(h.worldAxisForFileY.scale(E)).add(h.worldAxisForNormal);r.normalize();const V=this._AreaElement(S-A,E-A)-this._AreaElement(S-A,E+A)-this._AreaElement(S+A,E-A)+this._AreaElement(S+A,E+A);let H=b[G*L.size*Y+o*Y+0],Q=b[G*L.size*Y+o*Y+1],q=b[G*L.size*Y+o*Y+2];isNaN(H)&&(H=0),isNaN(Q)&&(Q=0),isNaN(q)&&(q=0),0===L.type&&(H/=255,Q/=255,q/=255),L.gammaSpace&&(H=Math.pow((0,p.Clamp)(H),F.g),Q=Math.pow((0,p.Clamp)(Q),F.g),q=Math.pow((0,p.Clamp)(q),F.g));const f=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const L=Math.max(H,Q,q);if(L>f){const U=f/L;H*=U,Q*=U,q*=U}}else H=(0,p.Clamp)(H,0,f),Q=(0,p.Clamp)(Q,0,f),q=(0,p.Clamp)(q,0,f);const v=new a.QU(H,Q,q);U.addLight(r,v,V),x+=V,S+=mL}E+=o}}const h=6*(4*Math.PI)/6/x;return U.scaleInPlace(h),U.convertIncidentRadianceToIrradiance(),U.convertIrradianceToLambertianRadiance(),G.d.FromHarmonics(U)}}A._FileFaces=[new o("right",new mL.YU(1,0,0),new mL.YU(0,0,-1),new mL.YU(0,-1,0)),new o("left",new mL.YU(-1,0,0),new mL.YU(0,0,1),new mL.YU(0,-1,0)),new o("up",new mL.YU(0,1,0),new mL.YU(1,0,0),new mL.YU(0,0,1)),new o("down",new mL.YU(0,-1,0),new mL.YU(1,0,0),new mL.YU(0,0,-1)),new o("front",new mL.YU(0,0,1),new mL.YU(1,0,0),new mL.YU(0,-1,0)),new o("back",new mL.YU(0,0,-1),new mL.YU(-1,0,0),new mL.YU(0,-1,0))],A.MAX_HDRI_VALUE=4096,A.PRESERVE_CLAMPED_COLORS=!1},15063:(L,U,x)=>{x.d(U,{DDSTools:()=>Y});var mL=x(12610),p=x(12406),G=x(13131),F=x(12810);x(14319);const a=131072,o=131072;function A(L){return L.charCodeAt(0)+(L.charCodeAt(1)<<8)+(L.charCodeAt(2)<<16)+(L.charCodeAt(3)<<24)}const r=A("DXT1"),h=A("DXT3"),b=A("DXT5"),E=A("DX10");class Y{static GetDDSInfo(L){const U=new Int32Array(L.buffer,L.byteOffset,31),x=new Int32Array(L.buffer,L.byteOffset,35);let mL=1;U[2]&a&&(mL=Math.max(1,U[7]));const p=U[21],G=p===E?x[32]:0;let F=0;switch(p){case 113:F=2;break;case 116:F=1;break;case E:if(10===G){F=2;break}if(2===G){F=1;break}}return{width:U[4],height:U[3],mipmapCount:mL,isFourCC:4===(4&U[20]),isRGB:64===(64&U[20]),isLuminance:(U[20]&o)===o,isCube:512===(512&U[28]),isCompressed:p===r||p===h||p===b,dxgiFormat:G,textureType:F}}static _GetHalfFloatAsFloatRGBAArrayBuffer(L,U,x,mL,p,G){const a=new Float32Array(mL),o=new Uint16Array(p,x);let A=0;for(let r=0;r<U;r++)for(let U=0;U<L;U++){const x=4*(U+r*L);a[A]=(0,F.i)(o[x]),a[A+1]=(0,F.i)(o[x+1]),a[A+2]=(0,F.i)(o[x+2]),Y.StoreLODInAlphaChannel?a[A+3]=G:a[A+3]=(0,F.i)(o[x+3]),A+=4}return a}static _GetHalfFloatRGBAArrayBuffer(L,U,x,mL,p,G){if(Y.StoreLODInAlphaChannel){const a=new Uint16Array(mL),o=new Uint16Array(p,x);let A=0;for(let x=0;x<U;x++)for(let U=0;U<L;U++){const mL=4*(U+x*L);a[A]=o[mL],a[A+1]=o[mL+1],a[A+2]=o[mL+2],a[A+3]=(0,F.o)(G),A+=4}return a}return new Uint16Array(p,x,mL)}static _GetFloatRGBAArrayBuffer(L,U,x,mL,p,G){if(Y.StoreLODInAlphaChannel){const F=new Float32Array(mL),a=new Float32Array(p,x);let o=0;for(let x=0;x<U;x++)for(let U=0;U<L;U++){const mL=4*(U+x*L);F[o]=a[mL],F[o+1]=a[mL+1],F[o+2]=a[mL+2],F[o+3]=G,o+=4}return F}return new Float32Array(p,x,mL)}static _GetFloatAsHalfFloatRGBAArrayBuffer(L,U,x,mL,p,G){const a=new Uint16Array(mL),o=new Float32Array(p,x);let A=0;for(let r=0;r<U;r++)for(let U=0;U<L;U++)a[A]=(0,F.o)(o[A]),a[A+1]=(0,F.o)(o[A+1]),a[A+2]=(0,F.o)(o[A+2]),Y.StoreLODInAlphaChannel?a[A+3]=(0,F.o)(G):a[A+3]=(0,F.o)(o[A+3]),A+=4;return a}static _GetFloatAsUIntRGBAArrayBuffer(L,U,x,p,G,F){const a=new Uint8Array(p),o=new Float32Array(G,x);let A=0;for(let r=0;r<U;r++)for(let U=0;U<L;U++){const x=4*(U+r*L);a[A]=255*(0,mL.Clamp)(o[x]),a[A+1]=255*(0,mL.Clamp)(o[x+1]),a[A+2]=255*(0,mL.Clamp)(o[x+2]),Y.StoreLODInAlphaChannel?a[A+3]=F:a[A+3]=255*(0,mL.Clamp)(o[x+3]),A+=4}return a}static _GetHalfFloatAsUIntRGBAArrayBuffer(L,U,x,p,G,a){const o=new Uint8Array(p),A=new Uint16Array(G,x);let r=0;for(let h=0;h<U;h++)for(let U=0;U<L;U++){const x=4*(U+h*L);o[r]=255*(0,mL.Clamp)((0,F.i)(A[x])),o[r+1]=255*(0,mL.Clamp)((0,F.i)(A[x+1])),o[r+2]=255*(0,mL.Clamp)((0,F.i)(A[x+2])),Y.StoreLODInAlphaChannel?o[r+3]=a:o[r+3]=255*(0,mL.Clamp)((0,F.i)(A[x+3])),r+=4}return o}static _GetRGBAArrayBuffer(L,U,x,mL,p,G,F,a,o){const A=new Uint8Array(mL),r=new Uint8Array(p,x);let h=0;for(let b=0;b<U;b++)for(let U=0;U<L;U++){const x=4*(U+b*L);A[h]=r[x+G],A[h+1]=r[x+F],A[h+2]=r[x+a],A[h+3]=r[x+o],h+=4}return A}static _ExtractLongWordOrder(L){return 0===L||255===L||-16777216===L?0:1+Y._ExtractLongWordOrder(L>>8)}static _GetRGBArrayBuffer(L,U,x,mL,p,G,F,a){const o=new Uint8Array(mL),A=new Uint8Array(p,x);let r=0;for(let h=0;h<U;h++)for(let U=0;U<L;U++){const x=3*(U+h*L);o[r]=A[x+G],o[r+1]=A[x+F],o[r+2]=A[x+a],r+=3}return o}static _GetLuminanceArrayBuffer(L,U,x,mL,p){const G=new Uint8Array(mL),F=new Uint8Array(p,x);let a=0;for(let o=0;o<U;o++)for(let U=0;U<L;U++){const x=U+o*L;G[a]=F[x],a++}return G}static UploadDDSLevels(L,U,x,mL,F,o){let A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,S=arguments.length>7?arguments[7]:void 0,V=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],H=null;mL.sphericalPolynomial&&(H=[]);const Q=!!L.getCaps().s3tc;U.generateMipMaps=F;const q=new Int32Array(x.buffer,x.byteOffset,31);let f,v,D,P,d,K,l,i=0,X=0,t=1;if(542327876!==q[0])return void p.c.Error("Invalid magic number in DDS header");if(!mL.isFourCC&&!mL.isRGB&&!mL.isLuminance)return void p.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(mL.isCompressed&&!Q)return void p.c.Error("Compressed textures are not supported on this platform.");let y=q[22];P=q[1]+4;let n=!1;if(mL.isFourCC)switch(f=q[21],f){case r:t=8,X=33777;break;case h:t=16,X=33778;break;case b:t=16,X=33779;break;case 113:n=!0,y=64;break;case 116:n=!0,y=128;break;case E:{P+=20;let L=!1;switch(mL.dxgiFormat){case 10:n=!0,y=64,L=!0;break;case 2:n=!0,y=128,L=!0;break;case 88:mL.isRGB=!0,mL.isFourCC=!1,y=32,L=!0}if(L)break}default:return void p.c.Error(["Unsupported FourCC code:",(N=f,String.fromCharCode(255&N,N>>8&255,N>>16&255,N>>24&255))])}var N;const e=Y._ExtractLongWordOrder(q[23]),u=Y._ExtractLongWordOrder(q[24]),Z=Y._ExtractLongWordOrder(q[25]),g=Y._ExtractLongWordOrder(q[26]);n&&(X=L._getRGBABufferInternalSizedFormat(mL.textureType)),K=1,q[2]&a&&!1!==F&&(K=Math.max(1,q[7]));const z=S||0,M=L.getCaps();for(let p=z;p<o;p++){for(v=q[4],D=q[3],l=0;l<K;++l){if(-1===A||A===l){const G=-1===A?l:0;if(!mL.isCompressed&&mL.isFourCC){U.format=5,i=v*D*4;let mL=null;if(L._badOS||L._badDesktopOS||!M.textureHalfFloat&&!M.textureFloat)128===y?(mL=Y._GetFloatAsUIntRGBAArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,G),H&&0==G&&H.push(Y._GetFloatRGBAArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,G))):64===y&&(mL=Y._GetHalfFloatAsUIntRGBAArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,G),H&&0==G&&H.push(Y._GetHalfFloatAsFloatRGBAArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,G))),U.type=0;else{const L=M.textureFloat&&(V&&M.textureFloatLinearFiltering||!V),p=M.textureHalfFloat&&(V&&M.textureHalfFloatLinearFiltering||!V),F=(128===y||64===y&&!p)&&L?1:(64===y||128===y&&!L)&&p?2:0;let a,o=null;if(128===y)switch(F){case 1:a=Y._GetFloatRGBAArrayBuffer,o=null;break;case 2:a=Y._GetFloatAsHalfFloatRGBAArrayBuffer,o=Y._GetFloatRGBAArrayBuffer;break;case 0:a=Y._GetFloatAsUIntRGBAArrayBuffer,o=Y._GetFloatRGBAArrayBuffer}else switch(F){case 1:a=Y._GetHalfFloatAsFloatRGBAArrayBuffer,o=null;break;case 2:a=Y._GetHalfFloatRGBAArrayBuffer,o=Y._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:a=Y._GetHalfFloatAsUIntRGBAArrayBuffer,o=Y._GetHalfFloatAsFloatRGBAArrayBuffer}U.type=F,mL=a(v,D,x.byteOffset+P,i,x.buffer,G),H&&0==G&&H.push(o?o(v,D,x.byteOffset+P,i,x.buffer,G):mL)}mL&&L._uploadDataToTextureDirectly(U,mL,p,G)}else if(mL.isRGB)U.type=0,24===y?(U.format=4,i=v*D*3,d=Y._GetRGBArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,e,u,Z),L._uploadDataToTextureDirectly(U,d,p,G)):(U.format=5,i=v*D*4,d=Y._GetRGBAArrayBuffer(v,D,x.byteOffset+P,i,x.buffer,e,u,Z,g),L._uploadDataToTextureDirectly(U,d,p,G));else if(mL.isLuminance){const mL=L._getUnpackAlignement(),F=v;i=Math.floor((v+mL-1)/mL)*mL*(D-1)+F,d=Y._GetLuminanceArrayBuffer(v,D,x.byteOffset+P,i,x.buffer),U.format=1,U.type=0,L._uploadDataToTextureDirectly(U,d,p,G)}else i=Math.max(4,v)/4*Math.max(4,D)/4*t,d=new Uint8Array(x.buffer,x.byteOffset+P,i),U.type=0,L._uploadCompressedDataToTextureDirectly(U,X,v,D,d,p,G)}P+=y?v*D*(y/8):i,v*=.5,D*=.5,v=Math.max(1,v),D=Math.max(1,D)}if(void 0!==S)break}H&&H.length>0?mL.sphericalPolynomial=G.c.ConvertCubeMapToSphericalPolynomial({size:q[4],right:H[0],left:H[1],up:H[2],down:H[3],front:H[4],back:H[5],format:5,type:1,gammaSpace:!1}):mL.sphericalPolynomial=void 0}}Y.StoreLODInAlphaChannel=!1}}]);