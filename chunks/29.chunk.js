"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[29],{14133:(u,R,I)=>{var B=I(12415),U=I(12315),K=I(12348),C=I(12440),D=I(12377),s=I(12425);D.d.prototype._partialLoadFile=function(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(u,(u=>{I[R]=u,I._internalCount++,6===I._internalCount&&B(I)}),void 0,void 0,!0,((u,R)=>{U&&u&&U(u.status+" "+u.statusText,R)}))},D.d.prototype._cascadeLoadFiles=function(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const U=[];U._internalCount=0;for(let K=0;K<6;K++)this._partialLoadFile(I[K],K,U,R,B)},D.d.prototype._cascadeLoadImgs=function(u,R,I,B){let U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,K=arguments.length>5?arguments[5]:void 0;const C=[];C._internalCount=0;for(let D=0;D<6;D++)this._partialLoadImg(B[D],D,C,u,R,I,U,K)},D.d.prototype._partialLoadImg=function(u,R,I,B,U,D){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,t=arguments.length>7?arguments[7]:void 0;const G=(0,C.d)();(0,K.p)(u,(u=>{I[R]=u,I._internalCount++,B&&B.removePendingData(G),6===I._internalCount&&D&&D(U,I)}),((u,R)=>{B&&B.removePendingData(G),s&&s(u,R)}),B?B.offlineProvider:null,t),B&&B.addPendingData(G)},D.d.prototype.createCubeTextureBase=function(u,R,I,K){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,t=arguments.length>6?arguments[6]:void 0,G=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,S=arguments.length>8&&void 0!==arguments[8]&&arguments[8],b=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,r=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,P=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,X=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,E=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,z=arguments.length>14&&void 0!==arguments[14]&&arguments[14],f=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const T=P||new B.d(this,7);T.isCube=!0,T.url=u,T.generateMipMaps=!K,T._lodGenerationScale=b,T._lodGenerationOffset=r,T._useSRGBBuffer=!!z&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!K),T!==P&&(T.label=u.substring(0,60)),this._doNotHandleContextLost||(T._extension=G,T._files=I,T._buffer=f);const Q=u;this._transformTextureUrl&&!P&&(u=this._transformTextureUrl(u));const V=G??function(u){const R=u.split("?")[0],I=R.lastIndexOf(".");return I>-1?R.substring(I).toLowerCase():""}(u),q=(0,s.c)(V),e=(u,R)=>{T.dispose(),D?D(u,R):u&&U.b.Warn(u)},Y=(B,D)=>{u===Q?B&&e(B.status+" "+B.statusText,D):(U.b.Warn(`Failed to load ${u}, falling back to the ${Q}`),this.createCubeTextureBase(Q,R,I,!!K,C,e,t,G,S,b,r,T,X,E,z,f))};if(q)q.then((B=>{const U=u=>{X&&X(T,u),B.loadCubeData(u,T,S,C,((u,R)=>{e(u,R)}))};f?U(f):I&&6===I.length?B.supportCascades?this._cascadeLoadFiles(R,(u=>U(u.map((u=>new Uint8Array(u))))),I,e):e("Textures type does not support cascades."):this._loadFile(u,(u=>U(new Uint8Array(u))),void 0,void 0,!0,Y)}));else{if(!I||0===I.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(R,T,((u,R)=>{E&&E(u,R)}),I,e)}return this._internalTexturesCache.push(T),T}},12979:(u,R,I)=>{I.d(R,{d:()=>t});var B=I(12481),U=I(12491),K=I(12654),C=I(12485),D=I(12518);class s{constructor(u,R,I,B){this.name=u,this.worldAxisForNormal=R,this.worldAxisForFileX=I,this.worldAxisForFileY=B}}class t{static ConvertCubeMapTextureToSphericalPolynomial(u){var R;if(!u.isCube)return null;null===(R=u.eu())||void 0===R||R.getEngine().flushFramebuffer();const I=u.getSize().width,B=u.readPixels(0,void 0,void 0,!1),U=u.readPixels(1,void 0,void 0,!1);let K,C;u.isRenderTarget?(K=u.readPixels(3,void 0,void 0,!1),C=u.readPixels(2,void 0,void 0,!1)):(K=u.readPixels(2,void 0,void 0,!1),C=u.readPixels(3,void 0,void 0,!1));const D=u.readPixels(4,void 0,void 0,!1),s=u.readPixels(5,void 0,void 0,!1),t=u.gammaSpace;let G=0;return 1!=u.textureType&&2!=u.textureType||(G=1),new Promise((u=>{Promise.all([U,B,K,C,D,s]).then((R=>{let[B,U,K,C,D,s]=R;const S={size:I,right:U,left:B,up:K,down:C,front:D,back:s,format:5,type:G,gammaSpace:t};u(this.ConvertCubeMapToSphericalPolynomial(S))}))}))}static _AreaElement(u,R){return Math.atan2(u*R,Math.sqrt(u*u+R*R+1))}static ConvertCubeMapToSphericalPolynomial(u){const R=new K.d;let I=0;const B=2/u.size,s=B,t=.5*B,G=t-1;for(let K=0;K<6;K++){const S=this._FileFaces[K],b=u[S.name];let r=G;const P=5===u.format?4:3;for(let K=0;K<u.size;K++){let X=G;for(let s=0;s<u.size;s++){const G=S.worldAxisForFileX.scale(X).add(S.worldAxisForFileY.scale(r)).add(S.worldAxisForNormal);G.normalize();const E=this._AreaElement(X-t,r-t)-this._AreaElement(X-t,r+t)-this._AreaElement(X+t,r-t)+this._AreaElement(X+t,r+t);let z=b[K*u.size*P+s*P+0],f=b[K*u.size*P+s*P+1],T=b[K*u.size*P+s*P+2];isNaN(z)&&(z=0),isNaN(f)&&(f=0),isNaN(T)&&(T=0),0===u.type&&(z/=255,f/=255,T/=255),u.gammaSpace&&(z=Math.pow((0,U.Clamp)(z),C.l),f=Math.pow((0,U.Clamp)(f),C.l),T=Math.pow((0,U.Clamp)(T),C.l));const Q=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const u=Math.max(z,f,T);if(u>Q){const R=Q/u;z*=R,f*=R,T*=R}}else z=(0,U.Clamp)(z,0,Q),f=(0,U.Clamp)(f,0,Q),T=(0,U.Clamp)(T,0,Q);const V=new D.fR(z,f,T);R.addLight(G,V,E),I+=E,X+=B}r+=s}}const S=6*(4*Math.PI)/6/I;return R.scaleInPlace(S),R.convertIncidentRadianceToIrradiance(),R.convertIrradianceToLambertianRadiance(),K.g.FromHarmonics(R)}}t._FileFaces=[new s("right",new B.PR(1,0,0),new B.PR(0,0,-1),new B.PR(0,-1,0)),new s("left",new B.PR(-1,0,0),new B.PR(0,0,1),new B.PR(0,-1,0)),new s("up",new B.PR(0,1,0),new B.PR(1,0,0),new B.PR(0,0,1)),new s("down",new B.PR(0,-1,0),new B.PR(1,0,0),new B.PR(0,0,-1)),new s("front",new B.PR(0,0,1),new B.PR(1,0,0),new B.PR(0,-1,0)),new s("back",new B.PR(0,0,-1),new B.PR(-1,0,0),new B.PR(0,-1,0))],t.MAX_HDRI_VALUE=4096,t.PRESERVE_CLAMPED_COLORS=!1},14907:(u,R,I)=>{I.d(R,{DDSTools:()=>P});var B=I(12491),U=I(12315),K=I(12979),C=I(12693);I(14133);const D=131072,s=131072;function t(u){return u.charCodeAt(0)+(u.charCodeAt(1)<<8)+(u.charCodeAt(2)<<16)+(u.charCodeAt(3)<<24)}const G=t("DXT1"),S=t("DXT3"),b=t("DXT5"),r=t("DX10");class P{static GetDDSInfo(u){const R=new Int32Array(u.buffer,u.byteOffset,31),I=new Int32Array(u.buffer,u.byteOffset,35);let B=1;R[2]&D&&(B=Math.max(1,R[7]));const U=R[21],K=U===r?I[32]:0;let C=0;switch(U){case 113:C=2;break;case 116:C=1;break;case r:if(10===K){C=2;break}if(2===K){C=1;break}}return{width:R[4],height:R[3],mipmapCount:B,isFourCC:4===(4&R[20]),isRGB:64===(64&R[20]),isLuminance:(R[20]&s)===s,isCube:512===(512&R[28]),isCompressed:U===G||U===S||U===b,dxgiFormat:K,textureType:C}}static _GetHalfFloatAsFloatRGBAArrayBuffer(u,R,I,B,U,K){const D=new Float32Array(B),s=new Uint16Array(U,I);let t=0;for(let G=0;G<R;G++)for(let R=0;R<u;R++){const I=4*(R+G*u);D[t]=(0,C.f)(s[I]),D[t+1]=(0,C.f)(s[I+1]),D[t+2]=(0,C.f)(s[I+2]),P.StoreLODInAlphaChannel?D[t+3]=K:D[t+3]=(0,C.f)(s[I+3]),t+=4}return D}static _GetHalfFloatRGBAArrayBuffer(u,R,I,B,U,K){if(P.StoreLODInAlphaChannel){const D=new Uint16Array(B),s=new Uint16Array(U,I);let t=0;for(let I=0;I<R;I++)for(let R=0;R<u;R++){const B=4*(R+I*u);D[t]=s[B],D[t+1]=s[B+1],D[t+2]=s[B+2],D[t+3]=(0,C.n)(K),t+=4}return D}return new Uint16Array(U,I,B)}static _GetFloatRGBAArrayBuffer(u,R,I,B,U,K){if(P.StoreLODInAlphaChannel){const C=new Float32Array(B),D=new Float32Array(U,I);let s=0;for(let I=0;I<R;I++)for(let R=0;R<u;R++){const B=4*(R+I*u);C[s]=D[B],C[s+1]=D[B+1],C[s+2]=D[B+2],C[s+3]=K,s+=4}return C}return new Float32Array(U,I,B)}static _GetFloatAsHalfFloatRGBAArrayBuffer(u,R,I,B,U,K){const D=new Uint16Array(B),s=new Float32Array(U,I);let t=0;for(let G=0;G<R;G++)for(let R=0;R<u;R++)D[t]=(0,C.n)(s[t]),D[t+1]=(0,C.n)(s[t+1]),D[t+2]=(0,C.n)(s[t+2]),P.StoreLODInAlphaChannel?D[t+3]=(0,C.n)(K):D[t+3]=(0,C.n)(s[t+3]),t+=4;return D}static _GetFloatAsUIntRGBAArrayBuffer(u,R,I,U,K,C){const D=new Uint8Array(U),s=new Float32Array(K,I);let t=0;for(let G=0;G<R;G++)for(let R=0;R<u;R++){const I=4*(R+G*u);D[t]=255*(0,B.Clamp)(s[I]),D[t+1]=255*(0,B.Clamp)(s[I+1]),D[t+2]=255*(0,B.Clamp)(s[I+2]),P.StoreLODInAlphaChannel?D[t+3]=C:D[t+3]=255*(0,B.Clamp)(s[I+3]),t+=4}return D}static _GetHalfFloatAsUIntRGBAArrayBuffer(u,R,I,U,K,D){const s=new Uint8Array(U),t=new Uint16Array(K,I);let G=0;for(let S=0;S<R;S++)for(let R=0;R<u;R++){const I=4*(R+S*u);s[G]=255*(0,B.Clamp)((0,C.f)(t[I])),s[G+1]=255*(0,B.Clamp)((0,C.f)(t[I+1])),s[G+2]=255*(0,B.Clamp)((0,C.f)(t[I+2])),P.StoreLODInAlphaChannel?s[G+3]=D:s[G+3]=255*(0,B.Clamp)((0,C.f)(t[I+3])),G+=4}return s}static _GetRGBAArrayBuffer(u,R,I,B,U,K,C,D,s){const t=new Uint8Array(B),G=new Uint8Array(U,I);let S=0;for(let b=0;b<R;b++)for(let R=0;R<u;R++){const I=4*(R+b*u);t[S]=G[I+K],t[S+1]=G[I+C],t[S+2]=G[I+D],t[S+3]=G[I+s],S+=4}return t}static _ExtractLongWordOrder(u){return 0===u||255===u||-16777216===u?0:1+P._ExtractLongWordOrder(u>>8)}static _GetRGBArrayBuffer(u,R,I,B,U,K,C,D){const s=new Uint8Array(B),t=new Uint8Array(U,I);let G=0;for(let S=0;S<R;S++)for(let R=0;R<u;R++){const I=3*(R+S*u);s[G]=t[I+K],s[G+1]=t[I+C],s[G+2]=t[I+D],G+=3}return s}static _GetLuminanceArrayBuffer(u,R,I,B,U){const K=new Uint8Array(B),C=new Uint8Array(U,I);let D=0;for(let s=0;s<R;s++)for(let R=0;R<u;R++){const I=R+s*u;K[D]=C[I],D++}return K}static UploadDDSLevels(u,R,I,B,C,s){let t=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,X=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],z=null;B.sphericalPolynomial&&(z=[]);const f=!!u.getCaps().s3tc;R.generateMipMaps=C;const T=new Int32Array(I.buffer,I.byteOffset,31);let Q,V,q,e,Y,M,o,j=0,h=0,x=1;if(542327876!==T[0])return void U.b.Error("Invalid magic number in DDS header");if(!B.isFourCC&&!B.isRGB&&!B.isLuminance)return void U.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(B.isCompressed&&!f)return void U.b.Error("Compressed textures are not supported on this platform.");let g=T[22];e=T[1]+4;let v=!1;if(B.isFourCC)switch(Q=T[21],Q){case G:x=8,h=33777;break;case S:x=16,h=33778;break;case b:x=16,h=33779;break;case 113:v=!0,g=64;break;case 116:v=!0,g=128;break;case r:{e+=20;let u=!1;switch(B.dxgiFormat){case 10:v=!0,g=64,u=!0;break;case 2:v=!0,g=128,u=!0;break;case 88:B.isRGB=!0,B.isFourCC=!1,g=32,u=!0}if(u)break}default:return void U.b.Error(["Unsupported FourCC code:",(p=Q,String.fromCharCode(255&p,p>>8&255,p>>16&255,p>>24&255))])}var p;const l=P._ExtractLongWordOrder(T[23]),Z=P._ExtractLongWordOrder(T[24]),c=P._ExtractLongWordOrder(T[25]),k=P._ExtractLongWordOrder(T[26]);v&&(h=u._getRGBABufferInternalSizedFormat(B.textureType)),M=1,T[2]&D&&!1!==C&&(M=Math.max(1,T[7]));const w=X||0,i=u.getCaps();for(let U=w;U<s;U++){for(V=T[4],q=T[3],o=0;o<M;++o){if(-1===t||t===o){const K=-1===t?o:0;if(!B.isCompressed&&B.isFourCC){R.format=5,j=V*q*4;let B=null;if(u._badOS||u._badDesktopOS||!i.textureHalfFloat&&!i.textureFloat)128===g?(B=P._GetFloatAsUIntRGBAArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,K),z&&0==K&&z.push(P._GetFloatRGBAArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,K))):64===g&&(B=P._GetHalfFloatAsUIntRGBAArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,K),z&&0==K&&z.push(P._GetHalfFloatAsFloatRGBAArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,K))),R.type=0;else{const u=i.textureFloat&&(E&&i.textureFloatLinearFiltering||!E),U=i.textureHalfFloat&&(E&&i.textureHalfFloatLinearFiltering||!E),C=(128===g||64===g&&!U)&&u?1:(64===g||128===g&&!u)&&U?2:0;let D,s=null;if(128===g)switch(C){case 1:D=P._GetFloatRGBAArrayBuffer,s=null;break;case 2:D=P._GetFloatAsHalfFloatRGBAArrayBuffer,s=P._GetFloatRGBAArrayBuffer;break;case 0:D=P._GetFloatAsUIntRGBAArrayBuffer,s=P._GetFloatRGBAArrayBuffer}else switch(C){case 1:D=P._GetHalfFloatAsFloatRGBAArrayBuffer,s=null;break;case 2:D=P._GetHalfFloatRGBAArrayBuffer,s=P._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:D=P._GetHalfFloatAsUIntRGBAArrayBuffer,s=P._GetHalfFloatAsFloatRGBAArrayBuffer}R.type=C,B=D(V,q,I.byteOffset+e,j,I.buffer,K),z&&0==K&&z.push(s?s(V,q,I.byteOffset+e,j,I.buffer,K):B)}B&&u._uploadDataToTextureDirectly(R,B,U,K)}else if(B.isRGB)R.type=0,24===g?(R.format=4,j=V*q*3,Y=P._GetRGBArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,l,Z,c),u._uploadDataToTextureDirectly(R,Y,U,K)):(R.format=5,j=V*q*4,Y=P._GetRGBAArrayBuffer(V,q,I.byteOffset+e,j,I.buffer,l,Z,c,k),u._uploadDataToTextureDirectly(R,Y,U,K));else if(B.isLuminance){const B=u._getUnpackAlignement(),C=V;j=Math.floor((V+B-1)/B)*B*(q-1)+C,Y=P._GetLuminanceArrayBuffer(V,q,I.byteOffset+e,j,I.buffer),R.format=1,R.type=0,u._uploadDataToTextureDirectly(R,Y,U,K)}else j=Math.max(4,V)/4*Math.max(4,q)/4*x,Y=new Uint8Array(I.buffer,I.byteOffset+e,j),R.type=0,u._uploadCompressedDataToTextureDirectly(R,h,V,q,Y,U,K)}e+=g?V*q*(g/8):j,V*=.5,q*=.5,V=Math.max(1,V),q=Math.max(1,q)}if(void 0!==X)break}z&&z.length>0?B.sphericalPolynomial=K.d.ConvertCubeMapToSphericalPolynomial({size:T[4],right:z[0],left:z[1],up:z[2],down:z[3],front:z[4],back:z[5],format:5,type:1,gammaSpace:!1}):B.sphericalPolynomial=void 0}}P.StoreLODInAlphaChannel=!1}}]);