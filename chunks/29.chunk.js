"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[29],{13007:(H,O,S)=>{var t=S(11239),q=S(11151),p=S(11188),G=S(11266),U=S(11213),V=S(11246);U.b.prototype._partialLoadFile=function(H,O,S,t){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(H,(H=>{S[O]=H,S._internalCount++,6===S._internalCount&&t(S)}),void 0,void 0,!0,((H,O)=>{q&&H&&q(H.status+" "+H.statusText,O)}))},U.b.prototype._cascadeLoadFiles=function(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const q=[];q._internalCount=0;for(let p=0;p<6;p++)this._partialLoadFile(S[p],p,q,O,t)},U.b.prototype._cascadeLoadImgs=function(H,O,S,t){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,p=arguments.length>5?arguments[5]:void 0;const G=[];G._internalCount=0;for(let U=0;U<6;U++)this._partialLoadImg(t[U],U,G,H,O,S,q,p)},U.b.prototype._partialLoadImg=function(H,O,S,t,q,U){let V=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,w=arguments.length>7?arguments[7]:void 0;const o=(0,G.d)();(0,p.s)(H,(H=>{S[O]=H,S._internalCount++,t&&t.removePendingData(o),6===S._internalCount&&U&&U(q,S)}),((H,O)=>{t&&t.removePendingData(o),V&&V(H,O)}),t?t.offlineProvider:null,w),t&&t.addPendingData(o)},U.b.prototype.createCubeTextureBase=function(H,O,S,p){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,w=arguments.length>6?arguments[6]:void 0,o=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,h=arguments.length>8&&void 0!==arguments[8]&&arguments[8],a=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,j=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,e=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,X=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,E=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,y=arguments.length>14&&void 0!==arguments[14]&&arguments[14],T=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const K=e||new t.d(this,7);K.isCube=!0,K.url=H,K.generateMipMaps=!p,K._lodGenerationScale=a,K._lodGenerationOffset=j,K._useSRGBBuffer=!!y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!p),K!==e&&(K.label=H.substring(0,60)),this._doNotHandleContextLost||(K._extension=o,K._files=S,K._buffer=T);const b=H;this._transformTextureUrl&&!e&&(H=this._transformTextureUrl(H));const D=o??function(H){const O=H.split("?")[0],S=O.lastIndexOf(".");return S>-1?O.substring(S).toLowerCase():""}(H),F=(0,V.e)(D),Y=(H,O)=>{K.dispose(),U?U(H,O):H&&q.b.Warn(H)},l=(t,U)=>{H===b?t&&Y(t.status+" "+t.statusText,U):(q.b.Warn(`Failed to load ${H}, falling back to the ${b}`),this.createCubeTextureBase(b,O,S,!!p,G,Y,w,o,h,a,j,K,X,E,y,T))};if(F)F.then((t=>{const q=H=>{X&&X(K,H),t.loadCubeData(H,K,h,G,((H,O)=>{Y(H,O)}))};T?q(T):S&&6===S.length?t.supportCascades?this._cascadeLoadFiles(O,(H=>q(H.map((H=>new Uint8Array(H))))),S,Y):Y("Textures type does not support cascades."):this._loadFile(H,(H=>q(new Uint8Array(H))),void 0,void 0,!0,l)}));else{if(!S||0===S.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(O,K,((H,O)=>{E&&E(H,O)}),S,Y)}return this._internalTexturesCache.push(K),K}},11824:(H,O,S)=>{S.d(O,{d:()=>w});var t=S(11301),q=S(11317),p=S(11509),G=S(11307),U=S(11355);class V{constructor(H,O,S,t){this.name=H,this.worldAxisForNormal=O,this.worldAxisForFileX=S,this.worldAxisForFileY=t}}class w{static ConvertCubeMapTextureToSphericalPolynomial(H){var O;if(!H.isCube)return null;null===(O=H.YH())||void 0===O||O.getEngine().flushFramebuffer();const S=H.getSize().width,t=H.readPixels(0,void 0,void 0,!1),q=H.readPixels(1,void 0,void 0,!1);let p,G;H.isRenderTarget?(p=H.readPixels(3,void 0,void 0,!1),G=H.readPixels(2,void 0,void 0,!1)):(p=H.readPixels(2,void 0,void 0,!1),G=H.readPixels(3,void 0,void 0,!1));const U=H.readPixels(4,void 0,void 0,!1),V=H.readPixels(5,void 0,void 0,!1),w=H.gammaSpace;let o=0;return 1!=H.textureType&&2!=H.textureType||(o=1),new Promise((H=>{Promise.all([q,t,p,G,U,V]).then((O=>{let[t,q,p,G,U,V]=O;const h={size:S,right:q,left:t,up:p,down:G,front:U,back:V,format:5,type:o,gammaSpace:w};H(this.ConvertCubeMapToSphericalPolynomial(h))}))}))}static _AreaElement(H,O){return Math.atan2(H*O,Math.sqrt(H*H+O*O+1))}static ConvertCubeMapToSphericalPolynomial(H){const O=new p.d;let S=0;const t=2/H.size,V=t,w=.5*t,o=w-1;for(let p=0;p<6;p++){const h=this._FileFaces[p],a=H[h.name];let j=o;const e=5===H.format?4:3;for(let p=0;p<H.size;p++){let X=o;for(let V=0;V<H.size;V++){const o=h.worldAxisForFileX.scale(X).add(h.worldAxisForFileY.scale(j)).add(h.worldAxisForNormal);o.normalize();const E=this._AreaElement(X-w,j-w)-this._AreaElement(X-w,j+w)-this._AreaElement(X+w,j-w)+this._AreaElement(X+w,j+w);let y=a[p*H.size*e+V*e+0],T=a[p*H.size*e+V*e+1],K=a[p*H.size*e+V*e+2];isNaN(y)&&(y=0),isNaN(T)&&(T=0),isNaN(K)&&(K=0),0===H.type&&(y/=255,T/=255,K/=255),H.gammaSpace&&(y=Math.pow((0,q.Clamp)(y),G.i),T=Math.pow((0,q.Clamp)(T),G.i),K=Math.pow((0,q.Clamp)(K),G.i));const b=this.MAX_HDRI_VALUE;if(this.PRESERVE_CLAMPED_COLORS){const H=Math.max(y,T,K);if(H>b){const O=b/H;y*=O,T*=O,K*=O}}else y=(0,q.Clamp)(y,0,b),T=(0,q.Clamp)(T,0,b),K=(0,q.Clamp)(K,0,b);const D=new U.TO(y,T,K);O.addLight(o,D,E),S+=E,X+=t}j+=V}}const h=6*(4*Math.PI)/6/S;return O.scaleInPlace(h),O.convertIncidentRadianceToIrradiance(),O.convertIrradianceToLambertianRadiance(),p.h.FromHarmonics(O)}}w._FileFaces=[new V("right",new t.eO(1,0,0),new t.eO(0,0,-1),new t.eO(0,-1,0)),new V("left",new t.eO(-1,0,0),new t.eO(0,0,1),new t.eO(0,-1,0)),new V("up",new t.eO(0,1,0),new t.eO(1,0,0),new t.eO(0,0,1)),new V("down",new t.eO(0,-1,0),new t.eO(1,0,0),new t.eO(0,0,-1)),new V("front",new t.eO(0,0,1),new t.eO(1,0,0),new t.eO(0,-1,0)),new V("back",new t.eO(0,0,-1),new t.eO(-1,0,0),new t.eO(0,-1,0))],w.MAX_HDRI_VALUE=4096,w.PRESERVE_CLAMPED_COLORS=!1},13745:(H,O,S)=>{S.d(O,{DDSTools:()=>e});var t=S(11317),q=S(11151),p=S(11824),G=S(11534);S(13007);const U=131072,V=131072;function w(H){return H.charCodeAt(0)+(H.charCodeAt(1)<<8)+(H.charCodeAt(2)<<16)+(H.charCodeAt(3)<<24)}const o=w("DXT1"),h=w("DXT3"),a=w("DXT5"),j=w("DX10");class e{static GetDDSInfo(H){const O=new Int32Array(H.buffer,H.byteOffset,31),S=new Int32Array(H.buffer,H.byteOffset,35);let t=1;O[2]&U&&(t=Math.max(1,O[7]));const q=O[21],p=q===j?S[32]:0;let G=0;switch(q){case 113:G=2;break;case 116:G=1;break;case j:if(10===p){G=2;break}if(2===p){G=1;break}}return{width:O[4],height:O[3],mipmapCount:t,isFourCC:4===(4&O[20]),isRGB:64===(64&O[20]),isLuminance:(O[20]&V)===V,isCube:512===(512&O[28]),isCompressed:q===o||q===h||q===a,dxgiFormat:p,textureType:G}}static _GetHalfFloatAsFloatRGBAArrayBuffer(H,O,S,t,q,p){const U=new Float32Array(t),V=new Uint16Array(q,S);let w=0;for(let o=0;o<O;o++)for(let O=0;O<H;O++){const S=4*(O+o*H);U[w]=(0,G.h)(V[S]),U[w+1]=(0,G.h)(V[S+1]),U[w+2]=(0,G.h)(V[S+2]),e.StoreLODInAlphaChannel?U[w+3]=p:U[w+3]=(0,G.h)(V[S+3]),w+=4}return U}static _GetHalfFloatRGBAArrayBuffer(H,O,S,t,q,p){if(e.StoreLODInAlphaChannel){const U=new Uint16Array(t),V=new Uint16Array(q,S);let w=0;for(let S=0;S<O;S++)for(let O=0;O<H;O++){const t=4*(O+S*H);U[w]=V[t],U[w+1]=V[t+1],U[w+2]=V[t+2],U[w+3]=(0,G.n)(p),w+=4}return U}return new Uint16Array(q,S,t)}static _GetFloatRGBAArrayBuffer(H,O,S,t,q,p){if(e.StoreLODInAlphaChannel){const G=new Float32Array(t),U=new Float32Array(q,S);let V=0;for(let S=0;S<O;S++)for(let O=0;O<H;O++){const t=4*(O+S*H);G[V]=U[t],G[V+1]=U[t+1],G[V+2]=U[t+2],G[V+3]=p,V+=4}return G}return new Float32Array(q,S,t)}static _GetFloatAsHalfFloatRGBAArrayBuffer(H,O,S,t,q,p){const U=new Uint16Array(t),V=new Float32Array(q,S);let w=0;for(let o=0;o<O;o++)for(let O=0;O<H;O++)U[w]=(0,G.n)(V[w]),U[w+1]=(0,G.n)(V[w+1]),U[w+2]=(0,G.n)(V[w+2]),e.StoreLODInAlphaChannel?U[w+3]=(0,G.n)(p):U[w+3]=(0,G.n)(V[w+3]),w+=4;return U}static _GetFloatAsUIntRGBAArrayBuffer(H,O,S,q,p,G){const U=new Uint8Array(q),V=new Float32Array(p,S);let w=0;for(let o=0;o<O;o++)for(let O=0;O<H;O++){const S=4*(O+o*H);U[w]=255*(0,t.Clamp)(V[S]),U[w+1]=255*(0,t.Clamp)(V[S+1]),U[w+2]=255*(0,t.Clamp)(V[S+2]),e.StoreLODInAlphaChannel?U[w+3]=G:U[w+3]=255*(0,t.Clamp)(V[S+3]),w+=4}return U}static _GetHalfFloatAsUIntRGBAArrayBuffer(H,O,S,q,p,U){const V=new Uint8Array(q),w=new Uint16Array(p,S);let o=0;for(let h=0;h<O;h++)for(let O=0;O<H;O++){const S=4*(O+h*H);V[o]=255*(0,t.Clamp)((0,G.h)(w[S])),V[o+1]=255*(0,t.Clamp)((0,G.h)(w[S+1])),V[o+2]=255*(0,t.Clamp)((0,G.h)(w[S+2])),e.StoreLODInAlphaChannel?V[o+3]=U:V[o+3]=255*(0,t.Clamp)((0,G.h)(w[S+3])),o+=4}return V}static _GetRGBAArrayBuffer(H,O,S,t,q,p,G,U,V){const w=new Uint8Array(t),o=new Uint8Array(q,S);let h=0;for(let a=0;a<O;a++)for(let O=0;O<H;O++){const S=4*(O+a*H);w[h]=o[S+p],w[h+1]=o[S+G],w[h+2]=o[S+U],w[h+3]=o[S+V],h+=4}return w}static _ExtractLongWordOrder(H){return 0===H||255===H||-16777216===H?0:1+e._ExtractLongWordOrder(H>>8)}static _GetRGBArrayBuffer(H,O,S,t,q,p,G,U){const V=new Uint8Array(t),w=new Uint8Array(q,S);let o=0;for(let h=0;h<O;h++)for(let O=0;O<H;O++){const S=3*(O+h*H);V[o]=w[S+p],V[o+1]=w[S+G],V[o+2]=w[S+U],o+=3}return V}static _GetLuminanceArrayBuffer(H,O,S,t,q){const p=new Uint8Array(t),G=new Uint8Array(q,S);let U=0;for(let V=0;V<O;V++)for(let O=0;O<H;O++){const S=O+V*H;p[U]=G[S],U++}return p}static UploadDDSLevels(H,O,S,t,G,V){let w=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,X=arguments.length>7?arguments[7]:void 0,E=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],y=null;t.sphericalPolynomial&&(y=[]);const T=!!H.getCaps().s3tc;O.generateMipMaps=G;const K=new Int32Array(S.buffer,S.byteOffset,31);let b,D,F,Y,l,d,v,z=0,m=0,r=1;if(542327876!==K[0])return void q.b.Error("Invalid magic number in DDS header");if(!t.isFourCC&&!t.isRGB&&!t.isLuminance)return void q.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(t.isCompressed&&!T)return void q.b.Error("Compressed textures are not supported on this platform.");let W=K[22];Y=K[1]+4;let g=!1;if(t.isFourCC)switch(b=K[21],b){case o:r=8,m=33777;break;case h:r=16,m=33778;break;case a:r=16,m=33779;break;case 113:g=!0,W=64;break;case 116:g=!0,W=128;break;case j:{Y+=20;let H=!1;switch(t.dxgiFormat){case 10:g=!0,W=64,H=!0;break;case 2:g=!0,W=128,H=!0;break;case 88:t.isRGB=!0,t.isFourCC=!1,W=32,H=!0}if(H)break}default:return void q.b.Error(["Unsupported FourCC code:",(N=b,String.fromCharCode(255&N,N>>8&255,N>>16&255,N>>24&255))])}var N;const x=e._ExtractLongWordOrder(K[23]),k=e._ExtractLongWordOrder(K[24]),A=e._ExtractLongWordOrder(K[25]),u=e._ExtractLongWordOrder(K[26]);g&&(m=H._getRGBABufferInternalSizedFormat(t.textureType)),d=1,K[2]&U&&!1!==G&&(d=Math.max(1,K[7]));const J=X||0,P=H.getCaps();for(let q=J;q<V;q++){for(D=K[4],F=K[3],v=0;v<d;++v){if(-1===w||w===v){const p=-1===w?v:0;if(!t.isCompressed&&t.isFourCC){O.format=5,z=D*F*4;let t=null;if(H._badOS||H._badDesktopOS||!P.textureHalfFloat&&!P.textureFloat)128===W?(t=e._GetFloatAsUIntRGBAArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,p),y&&0==p&&y.push(e._GetFloatRGBAArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,p))):64===W&&(t=e._GetHalfFloatAsUIntRGBAArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,p),y&&0==p&&y.push(e._GetHalfFloatAsFloatRGBAArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,p))),O.type=0;else{const H=P.textureFloat&&(E&&P.textureFloatLinearFiltering||!E),q=P.textureHalfFloat&&(E&&P.textureHalfFloatLinearFiltering||!E),G=(128===W||64===W&&!q)&&H?1:(64===W||128===W&&!H)&&q?2:0;let U,V=null;if(128===W)switch(G){case 1:U=e._GetFloatRGBAArrayBuffer,V=null;break;case 2:U=e._GetFloatAsHalfFloatRGBAArrayBuffer,V=e._GetFloatRGBAArrayBuffer;break;case 0:U=e._GetFloatAsUIntRGBAArrayBuffer,V=e._GetFloatRGBAArrayBuffer}else switch(G){case 1:U=e._GetHalfFloatAsFloatRGBAArrayBuffer,V=null;break;case 2:U=e._GetHalfFloatRGBAArrayBuffer,V=e._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:U=e._GetHalfFloatAsUIntRGBAArrayBuffer,V=e._GetHalfFloatAsFloatRGBAArrayBuffer}O.type=G,t=U(D,F,S.byteOffset+Y,z,S.buffer,p),y&&0==p&&y.push(V?V(D,F,S.byteOffset+Y,z,S.buffer,p):t)}t&&H._uploadDataToTextureDirectly(O,t,q,p)}else if(t.isRGB)O.type=0,24===W?(O.format=4,z=D*F*3,l=e._GetRGBArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,x,k,A),H._uploadDataToTextureDirectly(O,l,q,p)):(O.format=5,z=D*F*4,l=e._GetRGBAArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer,x,k,A,u),H._uploadDataToTextureDirectly(O,l,q,p));else if(t.isLuminance){const t=H._getUnpackAlignement(),G=D;z=Math.floor((D+t-1)/t)*t*(F-1)+G,l=e._GetLuminanceArrayBuffer(D,F,S.byteOffset+Y,z,S.buffer),O.format=1,O.type=0,H._uploadDataToTextureDirectly(O,l,q,p)}else z=Math.max(4,D)/4*Math.max(4,F)/4*r,l=new Uint8Array(S.buffer,S.byteOffset+Y,z),O.type=0,H._uploadCompressedDataToTextureDirectly(O,m,D,F,l,q,p)}Y+=W?D*F*(W/8):z,D*=.5,F*=.5,D=Math.max(1,D),F=Math.max(1,F)}if(void 0!==X)break}y&&y.length>0?t.sphericalPolynomial=p.d.ConvertCubeMapToSphericalPolynomial({size:K[4],right:y[0],left:y[1],up:y[2],down:y[3],front:y[4],back:y[5],format:5,type:1,gammaSpace:!1}):t.sphericalPolynomial=void 0}}e.StoreLODInAlphaChannel=!1}}]);