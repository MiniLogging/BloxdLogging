"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[104],{14488:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphMultiGateBlock:()=>o});var C=Y(11134),q=Y(12939),m=Y(12917),L=Y(12908);class o extends q.d{constructor(P){super(P),this.config=P,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",m.f,new L.c(-1)),this.setNumberOfOutputSignals(null===P||void 0===P?void 0:P.outputSignalCount)}_getNextIndex(P){if(P.includes(!1)||this.config.isLoop&&P.fill(!1),this.config.isRandom){const f=P.map(((P,f)=>P?-1:f)).filter((P=>-1!==P));return f.length?f[Math.floor(Math.random()*f.length)]:-1}return P.indexOf(!1)}setNumberOfOutputSignals(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>P;){const P=this.outputSignals.pop();P&&(P.disconnectFromAll(),this._unregisterSignalOutput(P.name))}for(;this.outputSignals.length<P;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(P,f){if(P._hasExecutionVariable(this,"indexesUsed")||P._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),f===this.reset)return P._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new L.c(-1),P);const Y=P._getExecutionVariable(this,"indexesUsed",[]),C=this._getNextIndex(Y);C>-1&&(this.lastIndex.setValue(new L.c(C),P),Y[C]=!0,P._setExecutionVariable(this,"indexesUsed",Y),this.outputSignals[C]._activateSignal(P))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(P){super.serialize(P),P.config.outputSignalCount=this.config.outputSignalCount,P.config.isRandom=this.config.isRandom,P.config.loop=this.config.isLoop,P.config.startIndex=this.config.startIndex}}(0,C.d)("FlowGraphMultiGateBlock",o)}}]);