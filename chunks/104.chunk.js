"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[104],{14540:(o,H,n)=>{n.r(H),n.d(H,{FlowGraphMultiGateBlock:()=>Y});var E=n(11140),k=n(12951),g=n(12933),O=n(12929);class Y extends k.b{constructor(o){super(o),this.config=o,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",g.e,new O.c(-1)),this.setNumberOfOutputSignals(null===o||void 0===o?void 0:o.outputSignalCount)}_getNextIndex(o){if(o.includes(!1)||this.config.isLoop&&o.fill(!1),this.config.isRandom){const H=o.map(((o,H)=>o?-1:H)).filter((o=>-1!==o));return H.length?H[Math.floor(Math.random()*H.length)]:-1}return o.indexOf(!1)}setNumberOfOutputSignals(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>o;){const o=this.outputSignals.pop();o&&(o.disconnectFromAll(),this._unregisterSignalOutput(o.name))}for(;this.outputSignals.length<o;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(o,H){if(o._hasExecutionVariable(this,"indexesUsed")||o._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),H===this.reset)return o._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new O.c(-1),o);const n=o._getExecutionVariable(this,"indexesUsed",[]),E=this._getNextIndex(n);E>-1&&(this.lastIndex.setValue(new O.c(E),o),n[E]=!0,o._setExecutionVariable(this,"indexesUsed",n),this.outputSignals[E]._activateSignal(o))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(o){super.serialize(o),o.config.outputSignalCount=this.config.outputSignalCount,o.config.isRandom=this.config.isRandom,o.config.loop=this.config.isLoop,o.config.startIndex=this.config.startIndex}}(0,E.e)("FlowGraphMultiGateBlock",Y)}}]);