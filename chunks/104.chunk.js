"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[104],{14553:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphMultiGateBlock:()=>j});var u=F(11136),G=F(12968),f=F(12954),Y=F(12949);class j extends G.e{constructor(Z){super(Z),this.config=Z,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",f.g,new Y.d(-1)),this.setNumberOfOutputSignals(null===Z||void 0===Z?void 0:Z.outputSignalCount)}_getNextIndex(Z){if(Z.includes(!1)||this.config.isLoop&&Z.fill(!1),this.config.isRandom){const x=Z.map(((Z,x)=>Z?-1:x)).filter((Z=>-1!==Z));return x.length?x[Math.floor(Math.random()*x.length)]:-1}return Z.indexOf(!1)}setNumberOfOutputSignals(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>Z;){const Z=this.outputSignals.pop();Z&&(Z.disconnectFromAll(),this._unregisterSignalOutput(Z.name))}for(;this.outputSignals.length<Z;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(Z,x){if(Z._hasExecutionVariable(this,"indexesUsed")||Z._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),x===this.reset)return Z._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new Y.d(-1),Z);const F=Z._getExecutionVariable(this,"indexesUsed",[]),u=this._getNextIndex(F);u>-1&&(this.lastIndex.setValue(new Y.d(u),Z),F[u]=!0,Z._setExecutionVariable(this,"indexesUsed",F),this.outputSignals[u]._activateSignal(Z))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(Z){super.serialize(Z),Z.config.outputSignalCount=this.config.outputSignalCount,Z.config.isRandom=this.config.isRandom,Z.config.loop=this.config.isLoop,Z.config.startIndex=this.config.startIndex}}(0,u.g)("FlowGraphMultiGateBlock",j)}}]);