"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[104],{14490:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphMultiGateBlock:()=>L});var M=C(11149),x=C(12923),y=C(12901),f=C(12895);class L extends x.b{constructor(B){super(B),this.config=B,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",y.f,new f.b(-1)),this.setNumberOfOutputSignals(null===B||void 0===B?void 0:B.outputSignalCount)}_getNextIndex(B){if(B.includes(!1)||this.config.isLoop&&B.fill(!1),this.config.isRandom){const I=B.map(((B,I)=>B?-1:I)).filter((B=>-1!==B));return I.length?I[Math.floor(Math.random()*I.length)]:-1}return B.indexOf(!1)}setNumberOfOutputSignals(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>B;){const B=this.outputSignals.pop();B&&(B.disconnectFromAll(),this._unregisterSignalOutput(B.name))}for(;this.outputSignals.length<B;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(B,I){if(B._hasExecutionVariable(this,"indexesUsed")||B._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),I===this.reset)return B._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new f.b(-1),B);const C=B._getExecutionVariable(this,"indexesUsed",[]),M=this._getNextIndex(C);M>-1&&(this.lastIndex.setValue(new f.b(M),B),C[M]=!0,B._setExecutionVariable(this,"indexesUsed",C),this.outputSignals[M]._activateSignal(B))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(B){super.serialize(B),B.config.outputSignalCount=this.config.outputSignalCount,B.config.isRandom=this.config.isRandom,B.config.loop=this.config.isLoop,B.config.startIndex=this.config.startIndex}}(0,M.h)("FlowGraphMultiGateBlock",L)}}]);