"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2271:(v,d,Q)=>{Q.r(d),Q.d(d,{ReadExrDataAsync:()=>yv,_ExrTextureLoader:()=>uv});var n=Q(482),T=Q(664);const L=4,e=4,F=1,r=2,C=8,u=65536,y=u>>3,z=14,B=65537,X=1<<z,m=X-1,V=59,h=63,S=2+h-V;var A,f;!function(v){v[v.NO_COMPRESSION=0]="NO_COMPRESSION",v[v.RLE_COMPRESSION=1]="RLE_COMPRESSION",v[v.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",v[v.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",v[v.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",v[v.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(A||(A={})),function(v){v[v.INCREASING_Y=0]="INCREASING_Y",v[v.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const P=function(){const v=new ArrayBuffer(4),d=new Float32Array(v),Q=new Uint32Array(v),n=new Uint32Array(512),T=new Uint32Array(512);for(let r=0;r<256;++r){const v=r-127;v<-27?(n[r]=0,n[256|r]=32768,T[r]=24,T[256|r]=24):v<-14?(n[r]=1024>>-v-14,n[256|r]=1024>>-v-14|32768,T[r]=-v-1,T[256|r]=-v-1):v<=15?(n[r]=v+15<<10,n[256|r]=v+15<<10|32768,T[r]=13,T[256|r]=13):v<128?(n[r]=31744,n[256|r]=64512,T[r]=24,T[256|r]=24):(n[r]=31744,n[256|r]=64512,T[r]=13,T[256|r]=13)}const L=new Uint32Array(2048),e=new Uint32Array(64),F=new Uint32Array(64);for(let r=1;r<1024;++r){let v=r<<13,d=0;for(;0===(8388608&v);)v<<=1,d-=8388608;v&=-8388609,d+=947912704,L[r]=v|d}for(let r=1024;r<2048;++r)L[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)e[r]=r<<23;e[31]=1199570944,e[32]=2147483648;for(let r=33;r<63;++r)e[r]=2147483648+(r-32<<23);e[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(F[r]=1024);return{floatView:d,uint32View:Q,baseTable:n,shiftTable:T,mantissaTable:L,exponentTable:e,offsetTable:F}}();function O(v,d){const Q=new Uint8Array(v);let n=0;for(;0!=Q[d.value+n];)n+=1;const T=(new TextDecoder).decode(Q.slice(d.value,d.value+n));return d.value=d.value+n+1,T}function J(v,d){const Q=v.getInt32(d.value,!0);return d.value+=L,Q}function K(v,d){const Q=v.getUint32(d.value,!0);return d.value+=L,Q}function o(v,d){const Q=v.getUint8(d.value);return d.value+=F,Q}function g(v,d){const Q=v.getUint16(d.value,!0);return d.value+=r,Q}function R(v,d){const Q=v[d.value];return d.value+=F,Q}function M(v,d){let Q;return Q="getBigInt64"in DataView.prototype?Number(v.getBigInt64(d.value,!0)):v.getUint32(d.value+4,!0)+Number(v.getUint32(d.value,!0)<<32),d.value+=C,Q}function Y(v,d){const Q=v.getFloat32(d.value,!0);return d.value+=e,Q}function D(v,d){return function(v){const d=(31744&v)>>10,Q=1023&v;return(v>>15?-1:1)*(d?31===d?Q?NaN:1/0:Math.pow(2,d-15)*(1+Q/1024):Q/1024*6103515625e-14)}(g(v,d))}function i(v,d){return function(v){if(Math.abs(v)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");v=(0,T.Clamp)(v,-65504,65504),P.floatView[0]=v;const d=P.uint32View[0],Q=d>>23&511;return P.baseTable[Q]+((8388607&d)>>P.shiftTable[Q])}(Y(v,d))}function Z(v,d,Q,n){switch(Q){case"string":case"stringvector":case"iccProfile":return function(v,d,Q){const n=(new TextDecoder).decode(new Uint8Array(v).slice(d.value,d.value+Q));return d.value=d.value+Q,n}(v.buffer,d,n);case"chlist":return function(v,d,Q){const n=d.value,T=[];for(;d.value<n+Q-1;){const Q=O(v.buffer,d),n=J(v,d),L=o(v,d);d.value+=3;const e=J(v,d),F=J(v,d);T.push({name:Q,pixelType:n,pLinear:L,xSampling:e,ySampling:F})}return d.value+=1,T}(v,d,n);case"chromaticities":return function(v,d){return{redX:Y(v,d),redY:Y(v,d),greenX:Y(v,d),greenY:Y(v,d),blueX:Y(v,d),blueY:Y(v,d),whiteX:Y(v,d),whiteY:Y(v,d)}}(v,d);case"compression":return function(v,d){return o(v,d)}(v,d);case"box2i":return function(v,d){return{xMin:J(v,d),yMin:J(v,d),xMax:J(v,d),yMax:J(v,d)}}(v,d);case"lineOrder":return function(v,d){const Q=o(v,d);return f[Q]}(v,d);case"float":return Y(v,d);case"v2f":return function(v,d){return[Y(v,d),Y(v,d)]}(v,d);case"v3f":return function(v,d){return[Y(v,d),Y(v,d),Y(v,d)]}(v,d);case"int":return J(v,d);case"rational":return function(v,d){return[J(v,d),K(v,d)]}(v,d);case"timecode":return function(v,d){return[K(v,d),K(v,d)]}(v,d);case"preview":return d.value+=n,"skipped";default:return void(d.value+=n)}}function j(v){for(let d=1;d<v.length;d++){const Q=v[d-1]+v[d]-128;v[d]=Q}}function x(v,d){let Q=0,n=Math.floor((v.length+1)/2),T=0;const L=v.length-1;for(;!(T>L)&&(d[T++]=v[Q++],!(T>L));)d[T++]=v[n++]}const k=20000630;function t(v,d){if(v.getUint32(0,!0)!=k)throw new Error("Incorrect OpenEXR format");const Q=v.getUint8(4),T=v.getUint8(5),L={singleTile:!!(2&T),longName:!!(4&T),deepFormat:!!(8&T),multiPart:!!(16&T)};d.value=8;const e={};let F=!0;for(;F;){const Q=O(v.buffer,d);if(Q){const T=O(v.buffer,d),L=Z(v,d,T,K(v,d));void 0===L?n.d.Warn(`Unknown header attribute type ${T}'.`):e[Q]=L}else F=!1}if(0!=(-5&T))throw new Error("Unsupported file format");return{version:Q,spec:L,...e}}const p=32768,W=65535;function q(v,d,Q,n,T){for(;Q<v;)d=d<<8|R(n,T),Q+=8;return{l:d>>(Q-=v)&(1<<v)-1,c:d,lc:Q}}function b(v,d,Q,n){return{c:v=v<<8|R(Q,n),lc:d+=8}}function H(v,d,Q,n,T,L,e,F,r){if(v==d){if(n<8){const v=b(Q,n,T,L);Q=v.c,n=v.lc}let v=Q>>(n-=8);if(v=new Uint8Array([v])[0],F.value+v>r)return null;const d=e[F.value-1];for(;v-- >0;)e[F.value++]=d}else{if(!(F.value<r))return null;e[F.value++]=v}return{c:Q,lc:n}}const s=new Array(59);function a(v,d,Q,n,T,L){const e=d;let F=0,r=0;for(;n<=T;n++){if(e.value-d.value>Q)return;let C=q(6,F,r,v,e);const u=C.l;if(F=C.c,r=C.lc,L[n]=u,u==h){if(e.value-d.value>Q)throw new Error("Error in HufUnpackEncTable");C=q(8,F,r,v,e);let u=C.l+S;if(F=C.c,r=C.lc,n+u>T+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)L[n++]=0;n--}else if(u>=V){let v=u-V+2;if(n+v>T+1)throw new Error("Error in HufUnpackEncTable");for(;v--;)L[n++]=0;n--}}!function(v){for(let Q=0;Q<=58;++Q)s[Q]=0;for(let Q=0;Q<B;++Q)s[v[Q]]+=1;let d=0;for(let Q=58;Q>0;--Q){const v=d+s[Q]>>1;s[Q]=d,d=v}for(let Q=0;Q<B;++Q){const d=v[Q];d>0&&(v[Q]=d|s[d]++<<6)}}(L)}function I(v){return 63&v}function U(v){return v>>6}function c(v,d,Q,n,T,L){const e=Q.value,F=K(d,Q),r=K(d,Q);Q.value+=4;const C=K(d,Q);if(Q.value+=4,F<0||F>=B||r<0||r>=B)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(B),y=new Array(X);!function(v){for(let d=0;d<X;d++)v[d]={},v[d].len=0,v[d].lit=0,v[d].p=null}(y);if(a(v,Q,n-(Q.value-e),F,r,u),C>8*(n-(Q.value-e)))throw new Error("Wrong hufUncompress");!function(v,d,Q,n){for(;d<=Q;d++){const Q=U(v[d]),T=I(v[d]);if(Q>>T)throw new Error("Invalid table entry");if(T>z){const v=n[Q>>T-z];if(v.len)throw new Error("Invalid table entry");if(v.lit++,v.p){const d=v.p;v.p=new Array(v.lit);for(let Q=0;Q<v.lit-1;++Q)v.p[Q]=d[Q]}else v.p=new Array(1);v.p[v.lit-1]=d}else if(T){let v=0;for(let L=1<<z-T;L>0;L--){const L=n[(Q<<z-T)+v];if(L.len||L.p)throw new Error("Invalid table entry");L.len=T,L.lit=d,v++}}}}(u,F,r,y),function(v,d,Q,n,T,L,e,F,r){let C=0,u=0;const y=e,B=Math.trunc(n.value+(T+7)/8);for(;n.value<B;){let T=b(C,u,Q,n);for(C=T.c,u=T.lc;u>=z;){const e=d[C>>u-z&m];if(e.len){u-=e.len;const v=H(e.lit,L,C,u,Q,n,F,r,y);v&&(C=v.c,u=v.lc)}else{if(!e.p)throw new Error("hufDecode issues");let d;for(d=0;d<e.lit;d++){const z=I(v[e.p[d]]);for(;u<z&&n.value<B;)T=b(C,u,Q,n),C=T.c,u=T.lc;if(u>=z&&U(v[e.p[d]])==(C>>u-z&(1<<z)-1)){u-=z;const v=H(e.p[d],L,C,u,Q,n,F,r,y);v&&(C=v.c,u=v.lc);break}}if(d==e.lit)throw new Error("HufDecode issues")}}}const X=8-T&7;for(C>>=X,u-=X;u>0;){const v=d[C<<z-u&m];if(!v.len)throw new Error("HufDecode issues");{u-=v.len;const d=H(v.lit,L,C,u,Q,n,F,r,y);d&&(C=d.c,u=d.lc)}}}(u,y,v,Q,C,r,L,T,{value:0})}function w(v){return 65535&v}function G(v){const d=w(v);return d>32767?d-65536:d}function E(v,d){const Q=G(v),n=G(d),T=Q+(1&n)+(n>>1);return{a:T,b:T-n}}function N(v,d){const Q=w(v),n=w(d),T=Q-(n>>1)&W;return{a:n+T-p&W,b:T}}function l(v,d,Q,n,T,L,e){const F=e<16384,r=Q>T?T:Q;let C,u,y=1;for(;y<=r;)y<<=1;for(y>>=1,C=y,y>>=1;y>=1;){u=0;const e=u+L*(T-C),r=L*y,z=L*C,B=n*y,X=n*C;let m,V,h,S;for(;u<=e;u+=z){let T=u;const L=u+n*(Q-C);for(;T<=L;T+=X){const Q=T+B,n=T+r,L=n+B;if(F){let e=E(v[T+d],v[n+d]);m=e.a,h=e.b,e=E(v[Q+d],v[L+d]),V=e.a,S=e.b,e=E(m,V),v[T+d]=e.a,v[Q+d]=e.b,e=E(h,S),v[n+d]=e.a,v[L+d]=e.b}else{let e=N(v[T+d],v[n+d]);m=e.a,h=e.b,e=N(v[Q+d],v[L+d]),V=e.a,S=e.b,e=N(m,V),v[T+d]=e.a,v[Q+d]=e.b,e=N(h,S),v[n+d]=e.a,v[L+d]=e.b}}if(Q&y){const Q=T+r;let n;n=F?E(v[T+d],v[Q+d]):N(v[T+d],v[Q+d]),m=n.a,v[Q+d]=n.b,v[T+d]=m}}if(T&y){let T=u;const L=u+n*(Q-C);for(;T<=L;T+=X){const Q=T+B;let n;n=F?E(v[T+d],v[Q+d]):N(v[T+d],v[Q+d]),m=n.a,v[Q+d]=n.b,v[T+d]=m}}C=y,y>>=1}return u}function vv(v){return new DataView(v.array.buffer,v.offset.value,v.size)}function dv(v){const d=v.viewer.buffer.slice(v.offset.value,v.offset.value+v.size),Q=new Uint8Array(function(v){let d=v.byteLength;const Q=[];let n=0;const T=new DataView(v);for(;d>0;){const v=T.getInt8(n++);if(v<0){const L=-v;d-=L+1;for(let v=0;v<L;v++)Q.push(T.getUint8(n++))}else{const L=v;d-=2;const e=T.getUint8(n++);for(let v=0;v<L+1;v++)Q.push(e)}}return Q}(d)),n=new Uint8Array(Q.length);return j(Q),x(Q,n),new DataView(n.buffer)}function Qv(v){const d=v.array.slice(v.offset.value,v.offset.value+v.size),Q=fflate.unzlibSync(d),n=new Uint8Array(Q.length);return j(Q),x(Q,n),new DataView(n.buffer)}function nv(v){const d=v.array.slice(v.offset.value,v.offset.value+v.size),Q=fflate.unzlibSync(d),n=v.lines*v.channels*v.width,T=1==v.type?new Uint16Array(n):new Uint32Array(n);let L=0,e=0;const F=new Array(4);for(let r=0;r<v.lines;r++)for(let d=0;d<v.channels;d++){let d=0;switch(v.type){case 1:F[0]=L,F[1]=F[0]+v.width,L=F[1]+v.width;for(let n=0;n<v.width;++n){d+=Q[F[0]++]<<8|Q[F[1]++],T[e]=d,e++}break;case 2:F[0]=L,F[1]=F[0]+v.width,F[2]=F[1]+v.width,L=F[2]+v.width;for(let n=0;n<v.width;++n){d+=Q[F[0]++]<<24|Q[F[1]++]<<16|Q[F[2]++]<<8,T[e]=d,e++}}}return new DataView(T.buffer)}function Tv(v){const d=v.viewer,Q={value:v.offset.value},n=new Uint16Array(v.width*v.scanlineBlockSize*(v.channels*v.type)),T=new Uint8Array(y);let L=0;const e=new Array(v.channels);for(let r=0;r<v.channels;r++)e[r]={},e[r].start=L,e[r].end=e[r].start,e[r].nx=v.width,e[r].ny=v.lines,e[r].size=v.type,L+=e[r].nx*e[r].ny*e[r].size;const F=g(d,Q),C=g(d,Q);if(C>=y)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(F<=C)for(let r=0;r<C-F+1;r++)T[r+F]=o(d,Q);const z=new Uint16Array(u),B=function(v,d){let Q=0;for(let T=0;T<u;++T)(0==T||v[T>>3]&1<<(7&T))&&(d[Q++]=T);const n=Q-1;for(;Q<u;)d[Q++]=0;return n}(T,z),X=K(d,Q);c(v.array,d,Q,X,n,L);for(let r=0;r<v.channels;++r){const v=e[r];for(let d=0;d<e[r].size;++d)l(n,v.start+d,v.nx,v.size,v.ny,v.nx*v.size,B)}!function(v,d,Q){for(let n=0;n<Q;++n)d[n]=v[d[n]]}(z,n,L);let m=0;const V=new Uint8Array(n.buffer.byteLength);for(let u=0;u<v.lines;u++)for(let d=0;d<v.channels;d++){const v=e[d],Q=v.nx*v.size,T=new Uint8Array(n.buffer,v.end*r,Q*r);V.set(T,m),m+=Q*r,v.end+=Q}return new DataView(V.buffer)}var Lv,ev=Q(475);!function(v){v[v.Float=0]="Float",v[v.HalfFloat=1]="HalfFloat"}(Lv||(Lv={}));class Fv{}async function rv(v,d,Q,n){const T={size:0,viewer:d,array:new Uint8Array(d.buffer),offset:Q,width:v.dataWindow.xMax-v.dataWindow.xMin+1,height:v.dataWindow.yMax-v.dataWindow.yMin+1,channels:v.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(v.compression){case A.NO_COMPRESSION:T.lines=1,T.uncompress=vv;break;case A.RLE_COMPRESSION:T.lines=1,T.uncompress=dv;break;case A.ZIPS_COMPRESSION:T.lines=1,T.uncompress=Qv,await ev.e.LoadScriptAsync(Fv.FFLATEUrl);break;case A.ZIP_COMPRESSION:T.lines=16,T.uncompress=Qv,await ev.e.LoadScriptAsync(Fv.FFLATEUrl);break;case A.PIZ_COMPRESSION:T.lines=32,T.uncompress=Tv;break;case A.PXR24_COMPRESSION:T.lines=16,T.uncompress=nv,await ev.e.LoadScriptAsync(Fv.FFLATEUrl);break;default:throw new Error(A[v.compression]+" is unsupported")}T.scanlineBlockSize=T.lines;const L={};for(const e of v.channels)switch(e.name){case"R":case"G":case"B":case"A":case"Y":L[e.name]=!0,T.type=e.pixelType}let F=!1;if(L.R&&L.G&&L.B&&L.A)T.outputChannels=4,T.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G&&L.B)F=!0,T.outputChannels=4,T.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G)T.outputChannels=2,T.decodeChannels={R:0,G:1};else if(L.R)T.outputChannels=1,T.decodeChannels={R:0};else{if(!L.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");T.outputChannels=1,T.decodeChannels={Y:0}}if(1===T.type)switch(n){case Lv.Float:T.getter=D,T.inputSize=r;break;case Lv.HalfFloat:T.getter=g,T.inputSize=r}else{if(2!==T.type)throw new Error("Unsupported pixelType "+T.type+" for "+v.compression);switch(n){case Lv.Float:T.getter=Y,T.inputSize=e;break;case Lv.HalfFloat:T.getter=i,T.inputSize=e}}T.blockCount=T.height/T.scanlineBlockSize;for(let e=0;e<T.blockCount;e++)M(d,Q);const C=T.width*T.height*T.outputChannels;switch(n){case Lv.Float:T.byteArray=new Float32Array(C),T.textureType=1,F&&T.byteArray.fill(1,0,C);break;case Lv.HalfFloat:T.byteArray=new Uint16Array(C),T.textureType=2,F&&T.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+n)}let u=0;for(const e of v.channels)void 0!==T.decodeChannels[e.name]&&(T.channelLineOffsets[e.name]=u*T.width),u+=2*e.pixelType;return T.bytesPerLine=T.width*u,T.outLineWidth=T.width*T.outputChannels,"INCREASING_Y"===v.lineOrder?T.scanOrder=v=>v:T.scanOrder=v=>T.height-1-v,4==T.outputChannels?(T.format=5,T.linearSpace=!0):(T.format=6,T.linearSpace=!1),T}function Cv(v,d,Q,n){const T={value:0};for(let L=0;L<v.height/v.scanlineBlockSize;L++){const e=J(Q,n)-d.dataWindow.yMin;v.size=K(Q,n),v.lines=e+v.scanlineBlockSize>v.height?v.height-e:v.scanlineBlockSize;const F=v.size<v.lines*v.bytesPerLine&&v.uncompress?v.uncompress(v):vv(v);n.value+=v.size;for(let Q=0;Q<v.scanlineBlockSize;Q++){const n=L*v.scanlineBlockSize,e=Q+v.scanOrder(n);if(e>=v.height)continue;const r=Q*v.bytesPerLine,C=(v.height-1-e)*v.outLineWidth;for(let Q=0;Q<v.channels;Q++){const n=d.channels[Q].name,L=v.channelLineOffsets[n],e=v.decodeChannels[n];if(void 0!==e){T.value=r+L;for(let d=0;d<v.width;d++){const Q=C+d*v.outputChannels+e;v.byteArray&&(v.byteArray[Q]=v.getter(F,T))}}}}}}Fv.DefaultOutputType=Lv.HalfFloat,Fv.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class uv{constructor(){this.supportCascades=!1}loadCubeData(v,d,Q,n,T){throw".exr not supported in Cube."}loadData(v,d,Q){const T=new DataView(v.buffer),L={value:0},e=t(T,L);rv(e,T,L,Fv.DefaultOutputType).then((v=>{Cv(v,e,T,L);const n=e.dataWindow.xMax-e.dataWindow.xMin+1,F=e.dataWindow.yMax-e.dataWindow.yMin+1;Q(n,F,d.generateMipMaps,!1,(()=>{const Q=d.getEngine();d.format=e.format,d.type=v.textureType,d.invertY=!1,d._gammaSpace=!e.linearSpace,v.byteArray&&Q._uploadDataToTextureDirectly(d,v.byteArray,0,0,void 0,!0)}))})).catch((v=>{n.d.Error("Failed to load EXR texture: ",v)}))}}async function yv(v){const d=new DataView(v),Q={value:0},T=t(d,Q);try{const v=await rv(T,d,Q,Lv.Float);return Cv(v,T,d,Q),v.byteArray?{width:T.dataWindow.xMax-T.dataWindow.xMin+1,height:T.dataWindow.yMax-T.dataWindow.yMin+1,data:new Float32Array(v.byteArray)}:(n.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(L){n.d.Error("Failed to load EXR data: ",L)}return{width:0,height:0,data:null}}}}]);