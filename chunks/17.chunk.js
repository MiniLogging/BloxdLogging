"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[17],{11833:(M,p,b)=>{b.r(p),b.d(p,{ap:()=>F,Sb:()=>o,TmpColors:()=>W});var Q=b(11800),q=b(11757),B=b(11798),k=b(11806);function u(M){return Math.pow(M,B.l)}function T(M){return M<=.04045?.0773993808*M:Math.pow(.947867299*(M+.055),2.4)}function O(M){return Math.pow(M,B.i)}function H(M){return M<=.0031308?12.92*M:1.055*Math.pow(M,.41666)-.055}class F{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=M,this.g=p,this.b=b}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ap"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M}toArray(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[p]=this.r,M[p+1]=this.g,M[p+2]=this.b,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(M,p,this),this}toColor4(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new o(this.r,this.g,this.b,M)}Ob(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(M){return new F(this.r*M.r,this.g*M.g,this.b*M.b)}multiplyToRef(M,p){return p.r=this.r*M.r,p.g=this.g*M.g,p.b=this.b*M.b,p}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this}multiplyByFloats(M,p,b){return new F(this.r*M,this.g*p,this.b*b)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,p){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.r,M.g,M.b)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.r,M.g,M.b)}minimizeInPlaceFromFloats(M,p,b){return this.r=Math.min(M,this.r),this.g=Math.min(p,this.g),this.b=Math.min(b,this.b),this}maximizeInPlaceFromFloats(M,p,b){return this.r=Math.max(M,this.r),this.g=Math.max(p,this.g),this.b=Math.max(b,this.b),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b}equalsFloats(M,p,b){return this.equalsToFloats(M,p,b)}equalsToFloats(M,p,b){return this.r===M&&this.g===p&&this.b===b}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,k.WithinEpsilon)(this.r,M.r,p)&&(0,k.WithinEpsilon)(this.g,M.g,p)&&(0,k.WithinEpsilon)(this.b,M.b,p)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}scale(M){return new F(this.r*M,this.g*M,this.b*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this}scaleToRef(M,p){return p.r=this.r*M,p.g=this.g*M,p.b=this.b*M,p}scaleAndAddToRef(M,p){return p.r+=this.r*M,p.g+=this.g*M,p.b+=this.b*M,p}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,k.Clamp)(this.r,M,p),b.g=(0,k.Clamp)(this.g,M,p),b.b=(0,k.Clamp)(this.b,M,p),b}add(M){return new F(this.r+M.r,this.g+M.g,this.b+M.b)}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this}addInPlaceFromFloats(M,p,b){return this.r+=M,this.g+=p,this.b+=b,this}addToRef(M,p){return p.r=this.r+M.r,p.g=this.g+M.g,p.b=this.b+M.b,p}jp(M){return new F(this.r-M.r,this.g-M.g,this.b-M.b)}subtractToRef(M,p){return p.r=this.r-M.r,p.g=this.g-M.g,p.b=this.b-M.b,p}TF(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this}subtractFromFloats(M,p,b){return new F(this.r-M,this.g-p,this.b-b)}subtractFromFloatsToRef(M,p,b,Q){return Q.r=this.r-M,Q.g=this.g-p,Q.b=this.b-b,Q}clone(){return new F(this.r,this.g,this.b)}B(M){return this.r=M.r,this.g=M.g,this.b=M.b,this}Db(M,p,b){return this.r=M,this.g=p,this.b=b,this}set(M,p,b){return this.Db(M,p,b)}sb(M){return this.r=this.g=this.b=M,this}toHexString(){const M=Math.round(255*this.r),p=Math.round(255*this.g),b=Math.round(255*this.b);return"#"+(0,k.ToHex)(M)+(0,k.ToHex)(p)+(0,k.ToHex)(b)}fromHexString(M){return"#"!==M.substring(0,1)||7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new F)}toHSVToRef(M){const p=this.r,b=this.g,Q=this.b,q=Math.max(p,b,Q),B=Math.min(p,b,Q);let k=0,u=0;const T=q,O=q-B;return 0!==q&&(u=O/q),q!=B&&(q==p?(k=(b-Q)/O,b<Q&&(k+=6)):q==b?k=(Q-p)/O+2:q==Q&&(k=(p-b)/O+4),k*=60),M.r=k,M.g=u,M.b=T,M}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new F;return this.toLinearSpaceToRef(p,M),p}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=T(this.r),M.g=T(this.g),M.b=T(this.b)):(M.r=u(this.r),M.g=u(this.g),M.b=u(this.b)),this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new F;return this.toGammaSpaceToRef(p,M),p}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=H(this.r),M.g=H(this.g),M.b=H(this.b)):(M.r=O(this.r),M.g=O(this.g),M.b=O(this.b)),this}static HSVtoRGBToRef(M,p,b,Q){const q=b*p,B=M/60,k=q*(1-Math.abs(B%2-1));let u=0,T=0,O=0;B>=0&&B<=1?(u=q,T=k):B>=1&&B<=2?(u=k,T=q):B>=2&&B<=3?(T=q,O=k):B>=3&&B<=4?(T=k,O=q):B>=4&&B<=5?(u=k,O=q):B>=5&&B<=6&&(u=q,O=k);const H=b-q;return Q.r=u+H,Q.g=T+H,Q.b=O+H,Q}static FromHSV(M,p,b){const Q=new F(0,0,0);return F.HSVtoRGBToRef(M,p,b,Q),Q}static FromHexString(M){return new F(0,0,0).fromHexString(M)}static sp(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(M[p],M[p+1],M[p+2])}static FromArrayToRef(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=M[p],b.g=M[p+1],b.b=M[p+2]}static FromInts(M,p,b){return new F(M/255,p/255,b/255)}static Lerp(M,p,b){const Q=new F(0,0,0);return F.LerpToRef(M,p,b,Q),Q}static LerpToRef(M,p,b,Q){Q.r=M.r+(p.r-M.r)*b,Q.g=M.g+(p.g-M.g)*b,Q.b=M.b+(p.b-M.b)*b}static Hermite(M,p,b,Q,q){const B=q*q,k=q*B,u=2*k-3*B+1,T=-2*k+3*B,O=k-2*B+q,H=k-B,o=M.r*u+b.r*T+p.r*O+Q.r*H,W=M.g*u+b.g*T+p.g*O+Q.g*H,i=M.b*u+b.b*T+p.b*O+Q.b*H;return new F(o,W,i)}static Hermite1stDerivative(M,p,b,Q,q){const B=F.Black();return this.Hermite1stDerivativeToRef(M,p,b,Q,q,B),B}static Hermite1stDerivativeToRef(M,p,b,Q,q,B){const k=q*q;B.r=6*(k-q)*M.r+(3*k-4*q+1)*p.r+6*(-k+q)*b.r+(3*k-2*q)*Q.r,B.g=6*(k-q)*M.g+(3*k-4*q+1)*p.g+6*(-k+q)*b.g+(3*k-2*q)*Q.g,B.b=6*(k-q)*M.b+(3*k-4*q+1)*p.b+6*(-k+q)*b.b+(3*k-2*q)*Q.b}static Red(){return new F(1,0,0)}static Green(){return new F(0,1,0)}static Blue(){return new F(0,0,1)}static Black(){return new F(0,0,0)}static get BlackReadOnly(){return F._BlackReadOnly}static White(){return new F(1,1,1)}static Purple(){return new F(.5,0,.5)}static Magenta(){return new F(1,0,1)}static Yellow(){return new F(1,1,0)}static Gray(){return new F(.5,.5,.5)}static Teal(){return new F(0,1,1)}static Random(){return new F(Math.random(),Math.random(),Math.random())}}F._V8PerformanceHack=new F(.5,.5,.5),F._BlackReadOnly=F.Black(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class o{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=M,this.g=p,this.b=b,this.a=Q}Ob(){return[this.r,this.g,this.b,this.a]}toArray(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[p]=this.r,M[p+1]=this.g,M[p+2]=this.b,M[p+3]=this.a,this}oQ(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=M[p],this.g=M[p+1],this.b=M[p+2],this.a=M[p+3],this}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b&&this.a===M.a}add(M){return new o(this.r+M.r,this.g+M.g,this.b+M.b,this.a+M.a)}addToRef(M,p){return p.r=this.r+M.r,p.g=this.g+M.g,p.b=this.b+M.b,p.a=this.a+M.a,p}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this.a+=M.a,this}addInPlaceFromFloats(M,p,b,Q){return this.r+=M,this.g+=p,this.b+=b,this.a+=Q,this}jp(M){return new o(this.r-M.r,this.g-M.g,this.b-M.b,this.a-M.a)}subtractToRef(M,p){return p.r=this.r-M.r,p.g=this.g-M.g,p.b=this.b-M.b,p.a=this.a-M.a,p}TF(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this.a-=M.a,this}subtractFromFloats(M,p,b,Q){return new o(this.r-M,this.g-p,this.b-b,this.a-Q)}subtractFromFloatsToRef(M,p,b,Q,q){return q.r=this.r-M,q.g=this.g-p,q.b=this.b-b,q.a=this.a-Q,q}scale(M){return new o(this.r*M,this.g*M,this.b*M,this.a*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this.a*=M,this}scaleToRef(M,p){return p.r=this.r*M,p.g=this.g*M,p.b=this.b*M,p.a=this.a*M,p}scaleAndAddToRef(M,p){return p.r+=this.r*M,p.g+=this.g*M,p.b+=this.b*M,p.a+=this.a*M,p}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,k.Clamp)(this.r,M,p),b.g=(0,k.Clamp)(this.g,M,p),b.b=(0,k.Clamp)(this.b,M,p),b.a=(0,k.Clamp)(this.a,M,p),b}multiply(M){return new o(this.r*M.r,this.g*M.g,this.b*M.b,this.a*M.a)}multiplyToRef(M,p){return p.r=this.r*M.r,p.g=this.g*M.g,p.b=this.b*M.b,p.a=this.a*M.a,p}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this.a*=M.a,this}multiplyByFloats(M,p,b,Q){return new o(this.r*M,this.g*p,this.b*b,this.a*Q)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,p){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.r=Math.min(this.r,M.r),this.g=Math.min(this.g,M.g),this.b=Math.min(this.b,M.b),this.a=Math.min(this.a,M.a),this}maximizeInPlace(M){return this.r=Math.max(this.r,M.r),this.g=Math.max(this.g,M.g),this.b=Math.max(this.b,M.b),this.a=Math.max(this.a,M.a),this}minimizeInPlaceFromFloats(M,p,b,Q){return this.r=Math.min(M,this.r),this.g=Math.min(p,this.g),this.b=Math.min(b,this.b),this.a=Math.min(Q,this.a),this}maximizeInPlaceFromFloats(M,p,b,Q){return this.r=Math.max(M,this.r),this.g=Math.max(p,this.g),this.b=Math.max(b,this.b),this.a=Math.max(Q,this.a),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,k.WithinEpsilon)(this.r,M.r,p)&&(0,k.WithinEpsilon)(this.g,M.g,p)&&(0,k.WithinEpsilon)(this.b,M.b,p)&&(0,k.WithinEpsilon)(this.a,M.a,p)}equalsToFloats(M,p,b,Q){return this.r===M&&this.g===p&&this.b===b&&this.a===Q}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Sb"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M=397*M^255*this.a,M}clone(){return(new o).B(this)}B(M){return this.r=M.r,this.g=M.g,this.b=M.b,this.a=M.a,this}Db(M,p,b,Q){return this.r=M,this.g=p,this.b=b,this.a=Q,this}set(M,p,b,Q){return this.Db(M,p,b,Q)}sb(M){return this.r=this.g=this.b=this.a=M,this}toHexString(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=Math.round(255*this.r),b=Math.round(255*this.g),Q=Math.round(255*this.b);if(M)return"#"+(0,k.ToHex)(p)+(0,k.ToHex)(b)+(0,k.ToHex)(Q);const q=Math.round(255*this.a);return"#"+(0,k.ToHex)(p)+(0,k.ToHex)(b)+(0,k.ToHex)(Q)+(0,k.ToHex)(q)}fromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255,9===M.length&&(this.a=parseInt(M.substring(7,9),16)/255)),this}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new o;return this.toLinearSpaceToRef(p,M),p}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=T(this.r),M.g=T(this.g),M.b=T(this.b)):(M.r=u(this.r),M.g=u(this.g),M.b=u(this.b)),M.a=this.a,this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new o;return this.toGammaSpaceToRef(p,M),p}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=H(this.r),M.g=H(this.g),M.b=H(this.b)):(M.r=O(this.r),M.g=O(this.g),M.b=O(this.b)),M.a=this.a,this}static FromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length?new o(0,0,0,0):new o(0,0,0,1).fromHexString(M)}static Lerp(M,p,b){return o.LerpToRef(M,p,b,new o)}static LerpToRef(M,p,b,Q){return Q.r=M.r+(p.r-M.r)*b,Q.g=M.g+(p.g-M.g)*b,Q.b=M.b+(p.b-M.b)*b,Q.a=M.a+(p.a-M.a)*b,Q}static Hermite(M,p,b,Q,q){const B=q*q,k=q*B,u=2*k-3*B+1,T=-2*k+3*B,O=k-2*B+q,H=k-B,F=M.r*u+b.r*T+p.r*O+Q.r*H,W=M.g*u+b.g*T+p.g*O+Q.g*H,i=M.b*u+b.b*T+p.b*O+Q.b*H,A=M.a*u+b.a*T+p.a*O+Q.a*H;return new o(F,W,i,A)}static Hermite1stDerivative(M,p,b,Q,q){const B=new o;return this.Hermite1stDerivativeToRef(M,p,b,Q,q,B),B}static Hermite1stDerivativeToRef(M,p,b,Q,q,B){const k=q*q;B.r=6*(k-q)*M.r+(3*k-4*q+1)*p.r+6*(-k+q)*b.r+(3*k-2*q)*Q.r,B.g=6*(k-q)*M.g+(3*k-4*q+1)*p.g+6*(-k+q)*b.g+(3*k-2*q)*Q.g,B.b=6*(k-q)*M.b+(3*k-4*q+1)*p.b+6*(-k+q)*b.b+(3*k-2*q)*Q.b,B.a=6*(k-q)*M.a+(3*k-4*q+1)*p.a+6*(-k+q)*b.a+(3*k-2*q)*Q.a}static FromColor3(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new o(M.r,M.g,M.b,p)}static sp(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o(M[p],M[p+1],M[p+2],M[p+3])}static FromArrayToRef(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=M[p],b.g=M[p+1],b.b=M[p+2],b.a=M[p+3]}static FromInts(M,p,b,Q){return new o(M/255,p/255,b/255,Q/255)}static CheckColors4(M,p){if(M.length===3*p){const p=[];for(let b=0;b<M.length;b+=3){const Q=b/3*4;p[Q]=M[b],p[Q+1]=M[b+1],p[Q+2]=M[b+2],p[Q+3]=1}return p}return M}}o._V8PerformanceHack=new o(.5,.5,.5,.5),Object.defineProperties(o.prototype,{dimension:{value:[4]},rank:{value:1}});class W{}W.ap=(0,Q.e)(3,F.Black),W.Sb=(0,Q.e)(3,(()=>new o(0,0,0,0))),(0,q.g)("BABYLON.Color3",F),(0,q.g)("BABYLON.Color4",o)}}]);