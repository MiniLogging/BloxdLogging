"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[17],{12880:(Y,b,C)=>{C.r(b),C.d(b,{rC:()=>F,hb:()=>y,TmpColors:()=>S});var R=C(12846),q=C(12790),A=C(12837),E=C(12852);function B(Y){return Math.pow(Y,A.n)}function g(Y){return Y<=.04045?.0773993808*Y:Math.pow(.947867299*(Y+.055),2.4)}function r(Y){return Math.pow(Y,A.l)}function O(Y){return Y<=.0031308?12.92*Y:1.055*Math.pow(Y,.41666)-.055}class F{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=Y,this.g=b,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"rC"}getHashCode(){let Y=255*this.r|0;return Y=397*Y^255*this.g,Y=397*Y^255*this.b,Y}toArray(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[b]=this.r,Y[b+1]=this.g,Y[b+2]=this.b,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F.FromArrayToRef(Y,b,this),this}toColor4(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new y(this.r,this.g,this.b,Y)}cb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(Y){return new F(this.r*Y.r,this.g*Y.g,this.b*Y.b)}multiplyToRef(Y,b){return b.r=this.r*Y.r,b.g=this.g*Y.g,b.b=this.b*Y.b,b}multiplyInPlace(Y){return this.r*=Y.r,this.g*=Y.g,this.b*=Y.b,this}multiplyByFloats(Y,b,C){return new F(this.r*Y,this.g*b,this.b*C)}divide(Y){throw new ReferenceError("Can not divide a color")}divideToRef(Y,b){throw new ReferenceError("Can not divide a color")}divideInPlace(Y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y.r,Y.g,Y.b)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y.r,Y.g,Y.b)}minimizeInPlaceFromFloats(Y,b,C){return this.r=Math.min(Y,this.r),this.g=Math.min(b,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(Y,b,C){return this.r=Math.max(Y,this.r),this.g=Math.max(b,this.g),this.b=Math.max(C,this.b),this}floorToRef(Y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(Y){return Y&&this.r===Y.r&&this.g===Y.g&&this.b===Y.b}equalsFloats(Y,b,C){return this.equalsToFloats(Y,b,C)}equalsToFloats(Y,b,C){return this.r===Y&&this.g===b&&this.b===C}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.e;return(0,E.WithinEpsilon)(this.r,Y.r,b)&&(0,E.WithinEpsilon)(this.g,Y.g,b)&&(0,E.WithinEpsilon)(this.b,Y.b,b)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Y){throw new ReferenceError("Can not negate a color")}scale(Y){return new F(this.r*Y,this.g*Y,this.b*Y)}scaleInPlace(Y){return this.r*=Y,this.g*=Y,this.b*=Y,this}scaleToRef(Y,b){return b.r=this.r*Y,b.g=this.g*Y,b.b=this.b*Y,b}scaleAndAddToRef(Y,b){return b.r+=this.r*Y,b.g+=this.g*Y,b.b+=this.b*Y,b}clampToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,E.Clamp)(this.r,Y,b),C.g=(0,E.Clamp)(this.g,Y,b),C.b=(0,E.Clamp)(this.b,Y,b),C}add(Y){return new F(this.r+Y.r,this.g+Y.g,this.b+Y.b)}addInPlace(Y){return this.r+=Y.r,this.g+=Y.g,this.b+=Y.b,this}addInPlaceFromFloats(Y,b,C){return this.r+=Y,this.g+=b,this.b+=C,this}addToRef(Y,b){return b.r=this.r+Y.r,b.g=this.g+Y.g,b.b=this.b+Y.b,b}EC(Y){return new F(this.r-Y.r,this.g-Y.g,this.b-Y.b)}subtractToRef(Y,b){return b.r=this.r-Y.r,b.g=this.g-Y.g,b.b=this.b-Y.b,b}dF(Y){return this.r-=Y.r,this.g-=Y.g,this.b-=Y.b,this}subtractFromFloats(Y,b,C){return new F(this.r-Y,this.g-b,this.b-C)}subtractFromFloatsToRef(Y,b,C,R){return R.r=this.r-Y,R.g=this.g-b,R.b=this.b-C,R}clone(){return new F(this.r,this.g,this.b)}q(Y){return this.r=Y.r,this.g=Y.g,this.b=Y.b,this}Ub(Y,b,C){return this.r=Y,this.g=b,this.b=C,this}set(Y,b,C){return this.Ub(Y,b,C)}Gb(Y){return this.r=this.g=this.b=Y,this}toHexString(){const Y=Math.round(255*this.r),b=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,E.ToHex)(Y)+(0,E.ToHex)(b)+(0,E.ToHex)(C)}fromHexString(Y){return"#"!==Y.substring(0,1)||7!==Y.length||(this.r=parseInt(Y.substring(1,3),16)/255,this.g=parseInt(Y.substring(3,5),16)/255,this.b=parseInt(Y.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new F)}toHSVToRef(Y){const b=this.r,C=this.g,R=this.b,q=Math.max(b,C,R),A=Math.min(b,C,R);let E=0,B=0;const g=q,r=q-A;return 0!==q&&(B=r/q),q!=A&&(q==b?(E=(C-R)/r,C<R&&(E+=6)):q==C?E=(R-b)/r+2:q==R&&(E=(b-C)/r+4),E*=60),Y.r=E,Y.g=B,Y.b=g,Y}toLinearSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new F;return this.toLinearSpaceToRef(b,Y),b}toLinearSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=g(this.r),Y.g=g(this.g),Y.b=g(this.b)):(Y.r=B(this.r),Y.g=B(this.g),Y.b=B(this.b)),this}toGammaSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new F;return this.toGammaSpaceToRef(b,Y),b}toGammaSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=O(this.r),Y.g=O(this.g),Y.b=O(this.b)):(Y.r=r(this.r),Y.g=r(this.g),Y.b=r(this.b)),this}static HSVtoRGBToRef(Y,b,C,R){const q=C*b,A=Y/60,E=q*(1-Math.abs(A%2-1));let B=0,g=0,r=0;A>=0&&A<=1?(B=q,g=E):A>=1&&A<=2?(B=E,g=q):A>=2&&A<=3?(g=q,r=E):A>=3&&A<=4?(g=E,r=q):A>=4&&A<=5?(B=E,r=q):A>=5&&A<=6&&(B=q,r=E);const O=C-q;return R.r=B+O,R.g=g+O,R.b=r+O,R}static FromHSV(Y,b,C){const R=new F(0,0,0);return F.HSVtoRGBToRef(Y,b,C,R),R}static FromHexString(Y){return new F(0,0,0).fromHexString(Y)}static OC(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(Y[b],Y[b+1],Y[b+2])}static FromArrayToRef(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=Y[b],C.g=Y[b+1],C.b=Y[b+2]}static FromInts(Y,b,C){return new F(Y/255,b/255,C/255)}static Lerp(Y,b,C){const R=new F(0,0,0);return F.LerpToRef(Y,b,C,R),R}static LerpToRef(Y,b,C,R){R.r=Y.r+(b.r-Y.r)*C,R.g=Y.g+(b.g-Y.g)*C,R.b=Y.b+(b.b-Y.b)*C}static Hermite(Y,b,C,R,q){const A=q*q,E=q*A,B=2*E-3*A+1,g=-2*E+3*A,r=E-2*A+q,O=E-A,y=Y.r*B+C.r*g+b.r*r+R.r*O,S=Y.g*B+C.g*g+b.g*r+R.g*O,n=Y.b*B+C.b*g+b.b*r+R.b*O;return new F(y,S,n)}static Hermite1stDerivative(Y,b,C,R,q){const A=F.Black();return this.Hermite1stDerivativeToRef(Y,b,C,R,q,A),A}static Hermite1stDerivativeToRef(Y,b,C,R,q,A){const E=q*q;A.r=6*(E-q)*Y.r+(3*E-4*q+1)*b.r+6*(-E+q)*C.r+(3*E-2*q)*R.r,A.g=6*(E-q)*Y.g+(3*E-4*q+1)*b.g+6*(-E+q)*C.g+(3*E-2*q)*R.g,A.b=6*(E-q)*Y.b+(3*E-4*q+1)*b.b+6*(-E+q)*C.b+(3*E-2*q)*R.b}static Red(){return new F(1,0,0)}static Green(){return new F(0,1,0)}static Blue(){return new F(0,0,1)}static Black(){return new F(0,0,0)}static get BlackReadOnly(){return F._BlackReadOnly}static White(){return new F(1,1,1)}static Purple(){return new F(.5,0,.5)}static Magenta(){return new F(1,0,1)}static Yellow(){return new F(1,1,0)}static Gray(){return new F(.5,.5,.5)}static Teal(){return new F(0,1,1)}static Random(){return new F(Math.random(),Math.random(),Math.random())}}F._V8PerformanceHack=new F(.5,.5,.5),F._BlackReadOnly=F.Black(),Object.defineProperties(F.prototype,{dimension:{value:[3]},rank:{value:1}});class y{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=Y,this.g=b,this.b=C,this.a=R}cb(){return[this.r,this.g,this.b,this.a]}toArray(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[b]=this.r,Y[b+1]=this.g,Y[b+2]=this.b,Y[b+3]=this.a,this}ER(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=Y[b],this.g=Y[b+1],this.b=Y[b+2],this.a=Y[b+3],this}equals(Y){return Y&&this.r===Y.r&&this.g===Y.g&&this.b===Y.b&&this.a===Y.a}add(Y){return new y(this.r+Y.r,this.g+Y.g,this.b+Y.b,this.a+Y.a)}addToRef(Y,b){return b.r=this.r+Y.r,b.g=this.g+Y.g,b.b=this.b+Y.b,b.a=this.a+Y.a,b}addInPlace(Y){return this.r+=Y.r,this.g+=Y.g,this.b+=Y.b,this.a+=Y.a,this}addInPlaceFromFloats(Y,b,C,R){return this.r+=Y,this.g+=b,this.b+=C,this.a+=R,this}EC(Y){return new y(this.r-Y.r,this.g-Y.g,this.b-Y.b,this.a-Y.a)}subtractToRef(Y,b){return b.r=this.r-Y.r,b.g=this.g-Y.g,b.b=this.b-Y.b,b.a=this.a-Y.a,b}dF(Y){return this.r-=Y.r,this.g-=Y.g,this.b-=Y.b,this.a-=Y.a,this}subtractFromFloats(Y,b,C,R){return new y(this.r-Y,this.g-b,this.b-C,this.a-R)}subtractFromFloatsToRef(Y,b,C,R,q){return q.r=this.r-Y,q.g=this.g-b,q.b=this.b-C,q.a=this.a-R,q}scale(Y){return new y(this.r*Y,this.g*Y,this.b*Y,this.a*Y)}scaleInPlace(Y){return this.r*=Y,this.g*=Y,this.b*=Y,this.a*=Y,this}scaleToRef(Y,b){return b.r=this.r*Y,b.g=this.g*Y,b.b=this.b*Y,b.a=this.a*Y,b}scaleAndAddToRef(Y,b){return b.r+=this.r*Y,b.g+=this.g*Y,b.b+=this.b*Y,b.a+=this.a*Y,b}clampToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,E.Clamp)(this.r,Y,b),C.g=(0,E.Clamp)(this.g,Y,b),C.b=(0,E.Clamp)(this.b,Y,b),C.a=(0,E.Clamp)(this.a,Y,b),C}multiply(Y){return new y(this.r*Y.r,this.g*Y.g,this.b*Y.b,this.a*Y.a)}multiplyToRef(Y,b){return b.r=this.r*Y.r,b.g=this.g*Y.g,b.b=this.b*Y.b,b.a=this.a*Y.a,b}multiplyInPlace(Y){return this.r*=Y.r,this.g*=Y.g,this.b*=Y.b,this.a*=Y.a,this}multiplyByFloats(Y,b,C,R){return new y(this.r*Y,this.g*b,this.b*C,this.a*R)}divide(Y){throw new ReferenceError("Can not divide a color")}divideToRef(Y,b){throw new ReferenceError("Can not divide a color")}divideInPlace(Y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Y){return this.r=Math.min(this.r,Y.r),this.g=Math.min(this.g,Y.g),this.b=Math.min(this.b,Y.b),this.a=Math.min(this.a,Y.a),this}maximizeInPlace(Y){return this.r=Math.max(this.r,Y.r),this.g=Math.max(this.g,Y.g),this.b=Math.max(this.b,Y.b),this.a=Math.max(this.a,Y.a),this}minimizeInPlaceFromFloats(Y,b,C,R){return this.r=Math.min(Y,this.r),this.g=Math.min(b,this.g),this.b=Math.min(C,this.b),this.a=Math.min(R,this.a),this}maximizeInPlaceFromFloats(Y,b,C,R){return this.r=Math.max(Y,this.r),this.g=Math.max(b,this.g),this.b=Math.max(C,this.b),this.a=Math.max(R,this.a),this}floorToRef(Y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Y){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.e;return(0,E.WithinEpsilon)(this.r,Y.r,b)&&(0,E.WithinEpsilon)(this.g,Y.g,b)&&(0,E.WithinEpsilon)(this.b,Y.b,b)&&(0,E.WithinEpsilon)(this.a,Y.a,b)}equalsToFloats(Y,b,C,R){return this.r===Y&&this.g===b&&this.b===C&&this.a===R}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"hb"}getHashCode(){let Y=255*this.r|0;return Y=397*Y^255*this.g,Y=397*Y^255*this.b,Y=397*Y^255*this.a,Y}clone(){return(new y).q(this)}q(Y){return this.r=Y.r,this.g=Y.g,this.b=Y.b,this.a=Y.a,this}Ub(Y,b,C,R){return this.r=Y,this.g=b,this.b=C,this.a=R,this}set(Y,b,C,R){return this.Ub(Y,b,C,R)}Gb(Y){return this.r=this.g=this.b=this.a=Y,this}toHexString(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=Math.round(255*this.r),C=Math.round(255*this.g),R=Math.round(255*this.b);if(Y)return"#"+(0,E.ToHex)(b)+(0,E.ToHex)(C)+(0,E.ToHex)(R);const q=Math.round(255*this.a);return"#"+(0,E.ToHex)(b)+(0,E.ToHex)(C)+(0,E.ToHex)(R)+(0,E.ToHex)(q)}fromHexString(Y){return"#"!==Y.substring(0,1)||9!==Y.length&&7!==Y.length||(this.r=parseInt(Y.substring(1,3),16)/255,this.g=parseInt(Y.substring(3,5),16)/255,this.b=parseInt(Y.substring(5,7),16)/255,9===Y.length&&(this.a=parseInt(Y.substring(7,9),16)/255)),this}toLinearSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new y;return this.toLinearSpaceToRef(b,Y),b}toLinearSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=g(this.r),Y.g=g(this.g),Y.b=g(this.b)):(Y.r=B(this.r),Y.g=B(this.g),Y.b=B(this.b)),Y.a=this.a,this}toGammaSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new y;return this.toGammaSpaceToRef(b,Y),b}toGammaSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=O(this.r),Y.g=O(this.g),Y.b=O(this.b)):(Y.r=r(this.r),Y.g=r(this.g),Y.b=r(this.b)),Y.a=this.a,this}static FromHexString(Y){return"#"!==Y.substring(0,1)||9!==Y.length&&7!==Y.length?new y(0,0,0,0):new y(0,0,0,1).fromHexString(Y)}static Lerp(Y,b,C){return y.LerpToRef(Y,b,C,new y)}static LerpToRef(Y,b,C,R){return R.r=Y.r+(b.r-Y.r)*C,R.g=Y.g+(b.g-Y.g)*C,R.b=Y.b+(b.b-Y.b)*C,R.a=Y.a+(b.a-Y.a)*C,R}static Hermite(Y,b,C,R,q){const A=q*q,E=q*A,B=2*E-3*A+1,g=-2*E+3*A,r=E-2*A+q,O=E-A,F=Y.r*B+C.r*g+b.r*r+R.r*O,S=Y.g*B+C.g*g+b.g*r+R.g*O,n=Y.b*B+C.b*g+b.b*r+R.b*O,t=Y.a*B+C.a*g+b.a*r+R.a*O;return new y(F,S,n,t)}static Hermite1stDerivative(Y,b,C,R,q){const A=new y;return this.Hermite1stDerivativeToRef(Y,b,C,R,q,A),A}static Hermite1stDerivativeToRef(Y,b,C,R,q,A){const E=q*q;A.r=6*(E-q)*Y.r+(3*E-4*q+1)*b.r+6*(-E+q)*C.r+(3*E-2*q)*R.r,A.g=6*(E-q)*Y.g+(3*E-4*q+1)*b.g+6*(-E+q)*C.g+(3*E-2*q)*R.g,A.b=6*(E-q)*Y.b+(3*E-4*q+1)*b.b+6*(-E+q)*C.b+(3*E-2*q)*R.b,A.a=6*(E-q)*Y.a+(3*E-4*q+1)*b.a+6*(-E+q)*C.a+(3*E-2*q)*R.a}static FromColor3(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y(Y.r,Y.g,Y.b,b)}static OC(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(Y[b],Y[b+1],Y[b+2],Y[b+3])}static FromArrayToRef(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=Y[b],C.g=Y[b+1],C.b=Y[b+2],C.a=Y[b+3]}static FromInts(Y,b,C,R){return new y(Y/255,b/255,C/255,R/255)}static CheckColors4(Y,b){if(Y.length===3*b){const b=[];for(let C=0;C<Y.length;C+=3){const R=C/3*4;b[R]=Y[C],b[R+1]=Y[C+1],b[R+2]=Y[C+2],b[R+3]=1}return b}return Y}}y._V8PerformanceHack=new y(.5,.5,.5,.5),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class S{}S.rC=(0,R.e)(3,F.Black),S.hb=(0,R.e)(3,(()=>new y(0,0,0,0))),(0,q.g)("BABYLON.Color3",F),(0,q.g)("BABYLON.Color4",y)}}]);