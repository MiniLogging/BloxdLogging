"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[17],{12494:(Z,l,C)=>{C.r(l),C.d(l,{Sl:()=>E,Rb:()=>G,TmpColors:()=>a});var B=C(12456),x=C(12400),b=C(12451),K=C(12460);function f(Z){return Math.pow(Z,b.j)}function W(Z){return Z<=.04045?.0773993808*Z:Math.pow(.947867299*(Z+.055),2.4)}function J(Z){return Math.pow(Z,b.h)}function d(Z){return Z<=.0031308?12.92*Z:1.055*Math.pow(Z,.41666)-.055}class E{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=Z,this.g=l,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Sl"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z}toArray(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[l]=this.r,Z[l+1]=this.g,Z[l+2]=this.b,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(Z,l,this),this}toColor4(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new G(this.r,this.g,this.b,Z)}Yb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(Z){return new E(this.r*Z.r,this.g*Z.g,this.b*Z.b)}multiplyToRef(Z,l){return l.r=this.r*Z.r,l.g=this.g*Z.g,l.b=this.b*Z.b,l}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this}multiplyByFloats(Z,l,C){return new E(this.r*Z,this.g*l,this.b*C)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,l){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.r,Z.g,Z.b)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.r,Z.g,Z.b)}minimizeInPlaceFromFloats(Z,l,C){return this.r=Math.min(Z,this.r),this.g=Math.min(l,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(Z,l,C){return this.r=Math.max(Z,this.r),this.g=Math.max(l,this.g),this.b=Math.max(C,this.b),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b}equalsFloats(Z,l,C){return this.equalsToFloats(Z,l,C)}equalsToFloats(Z,l,C){return this.r===Z&&this.g===l&&this.b===C}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:b.e;return(0,K.WithinEpsilon)(this.r,Z.r,l)&&(0,K.WithinEpsilon)(this.g,Z.g,l)&&(0,K.WithinEpsilon)(this.b,Z.b,l)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}scale(Z){return new E(this.r*Z,this.g*Z,this.b*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this}scaleToRef(Z,l){return l.r=this.r*Z,l.g=this.g*Z,l.b=this.b*Z,l}scaleAndAddToRef(Z,l){return l.r+=this.r*Z,l.g+=this.g*Z,l.b+=this.b*Z,l}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,K.Clamp)(this.r,Z,l),C.g=(0,K.Clamp)(this.g,Z,l),C.b=(0,K.Clamp)(this.b,Z,l),C}add(Z){return new E(this.r+Z.r,this.g+Z.g,this.b+Z.b)}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this}addInPlaceFromFloats(Z,l,C){return this.r+=Z,this.g+=l,this.b+=C,this}addToRef(Z,l){return l.r=this.r+Z.r,l.g=this.g+Z.g,l.b=this.b+Z.b,l}zl(Z){return new E(this.r-Z.r,this.g-Z.g,this.b-Z.b)}subtractToRef(Z,l){return l.r=this.r-Z.r,l.g=this.g-Z.g,l.b=this.b-Z.b,l}JG(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this}subtractFromFloats(Z,l,C){return new E(this.r-Z,this.g-l,this.b-C)}subtractFromFloatsToRef(Z,l,C,B){return B.r=this.r-Z,B.g=this.g-l,B.b=this.b-C,B}clone(){return new E(this.r,this.g,this.b)}B(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this}rb(Z,l,C){return this.r=Z,this.g=l,this.b=C,this}set(Z,l,C){return this.rb(Z,l,C)}ob(Z){return this.r=this.g=this.b=Z,this}toHexString(){const Z=Math.round(255*this.r),l=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,K.ToHex)(Z)+(0,K.ToHex)(l)+(0,K.ToHex)(C)}fromHexString(Z){return"#"!==Z.substring(0,1)||7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new E)}toHSVToRef(Z){const l=this.r,C=this.g,B=this.b,x=Math.max(l,C,B),b=Math.min(l,C,B);let K=0,f=0;const W=x,J=x-b;return 0!==x&&(f=J/x),x!=b&&(x==l?(K=(C-B)/J,C<B&&(K+=6)):x==C?K=(B-l)/J+2:x==B&&(K=(l-C)/J+4),K*=60),Z.r=K,Z.g=f,Z.b=W,Z}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new E;return this.toLinearSpaceToRef(l,Z),l}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=W(this.r),Z.g=W(this.g),Z.b=W(this.b)):(Z.r=f(this.r),Z.g=f(this.g),Z.b=f(this.b)),this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new E;return this.toGammaSpaceToRef(l,Z),l}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)):(Z.r=J(this.r),Z.g=J(this.g),Z.b=J(this.b)),this}static HSVtoRGBToRef(Z,l,C,B){const x=C*l,b=Z/60,K=x*(1-Math.abs(b%2-1));let f=0,W=0,J=0;b>=0&&b<=1?(f=x,W=K):b>=1&&b<=2?(f=K,W=x):b>=2&&b<=3?(W=x,J=K):b>=3&&b<=4?(W=K,J=x):b>=4&&b<=5?(f=K,J=x):b>=5&&b<=6&&(f=x,J=K);const d=C-x;return B.r=f+d,B.g=W+d,B.b=J+d,B}static FromHSV(Z,l,C){const B=new E(0,0,0);return E.HSVtoRGBToRef(Z,l,C,B),B}static FromHexString(Z){return new E(0,0,0).fromHexString(Z)}static il(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(Z[l],Z[l+1],Z[l+2])}static FromArrayToRef(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=Z[l],C.g=Z[l+1],C.b=Z[l+2]}static FromInts(Z,l,C){return new E(Z/255,l/255,C/255)}static Lerp(Z,l,C){const B=new E(0,0,0);return E.LerpToRef(Z,l,C,B),B}static LerpToRef(Z,l,C,B){B.r=Z.r+(l.r-Z.r)*C,B.g=Z.g+(l.g-Z.g)*C,B.b=Z.b+(l.b-Z.b)*C}static Hermite(Z,l,C,B,x){const b=x*x,K=x*b,f=2*K-3*b+1,W=-2*K+3*b,J=K-2*b+x,d=K-b,G=Z.r*f+C.r*W+l.r*J+B.r*d,a=Z.g*f+C.g*W+l.g*J+B.g*d,q=Z.b*f+C.b*W+l.b*J+B.b*d;return new E(G,a,q)}static Hermite1stDerivative(Z,l,C,B,x){const b=E.Black();return this.Hermite1stDerivativeToRef(Z,l,C,B,x,b),b}static Hermite1stDerivativeToRef(Z,l,C,B,x,b){const K=x*x;b.r=6*(K-x)*Z.r+(3*K-4*x+1)*l.r+6*(-K+x)*C.r+(3*K-2*x)*B.r,b.g=6*(K-x)*Z.g+(3*K-4*x+1)*l.g+6*(-K+x)*C.g+(3*K-2*x)*B.g,b.b=6*(K-x)*Z.b+(3*K-4*x+1)*l.b+6*(-K+x)*C.b+(3*K-2*x)*B.b}static Red(){return new E(1,0,0)}static Green(){return new E(0,1,0)}static Blue(){return new E(0,0,1)}static Black(){return new E(0,0,0)}static get BlackReadOnly(){return E._BlackReadOnly}static White(){return new E(1,1,1)}static Purple(){return new E(.5,0,.5)}static Magenta(){return new E(1,0,1)}static Yellow(){return new E(1,1,0)}static Gray(){return new E(.5,.5,.5)}static Teal(){return new E(0,1,1)}static Random(){return new E(Math.random(),Math.random(),Math.random())}}E._V8PerformanceHack=new E(.5,.5,.5),E._BlackReadOnly=E.Black(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class G{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=Z,this.g=l,this.b=C,this.a=B}Yb(){return[this.r,this.g,this.b,this.a]}toArray(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[l]=this.r,Z[l+1]=this.g,Z[l+2]=this.b,Z[l+3]=this.a,this}aC(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=Z[l],this.g=Z[l+1],this.b=Z[l+2],this.a=Z[l+3],this}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b&&this.a===Z.a}add(Z){return new G(this.r+Z.r,this.g+Z.g,this.b+Z.b,this.a+Z.a)}addToRef(Z,l){return l.r=this.r+Z.r,l.g=this.g+Z.g,l.b=this.b+Z.b,l.a=this.a+Z.a,l}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this.a+=Z.a,this}addInPlaceFromFloats(Z,l,C,B){return this.r+=Z,this.g+=l,this.b+=C,this.a+=B,this}zl(Z){return new G(this.r-Z.r,this.g-Z.g,this.b-Z.b,this.a-Z.a)}subtractToRef(Z,l){return l.r=this.r-Z.r,l.g=this.g-Z.g,l.b=this.b-Z.b,l.a=this.a-Z.a,l}JG(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this.a-=Z.a,this}subtractFromFloats(Z,l,C,B){return new G(this.r-Z,this.g-l,this.b-C,this.a-B)}subtractFromFloatsToRef(Z,l,C,B,x){return x.r=this.r-Z,x.g=this.g-l,x.b=this.b-C,x.a=this.a-B,x}scale(Z){return new G(this.r*Z,this.g*Z,this.b*Z,this.a*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this.a*=Z,this}scaleToRef(Z,l){return l.r=this.r*Z,l.g=this.g*Z,l.b=this.b*Z,l.a=this.a*Z,l}scaleAndAddToRef(Z,l){return l.r+=this.r*Z,l.g+=this.g*Z,l.b+=this.b*Z,l.a+=this.a*Z,l}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,K.Clamp)(this.r,Z,l),C.g=(0,K.Clamp)(this.g,Z,l),C.b=(0,K.Clamp)(this.b,Z,l),C.a=(0,K.Clamp)(this.a,Z,l),C}multiply(Z){return new G(this.r*Z.r,this.g*Z.g,this.b*Z.b,this.a*Z.a)}multiplyToRef(Z,l){return l.r=this.r*Z.r,l.g=this.g*Z.g,l.b=this.b*Z.b,l.a=this.a*Z.a,l}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this.a*=Z.a,this}multiplyByFloats(Z,l,C,B){return new G(this.r*Z,this.g*l,this.b*C,this.a*B)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,l){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.r=Math.min(this.r,Z.r),this.g=Math.min(this.g,Z.g),this.b=Math.min(this.b,Z.b),this.a=Math.min(this.a,Z.a),this}maximizeInPlace(Z){return this.r=Math.max(this.r,Z.r),this.g=Math.max(this.g,Z.g),this.b=Math.max(this.b,Z.b),this.a=Math.max(this.a,Z.a),this}minimizeInPlaceFromFloats(Z,l,C,B){return this.r=Math.min(Z,this.r),this.g=Math.min(l,this.g),this.b=Math.min(C,this.b),this.a=Math.min(B,this.a),this}maximizeInPlaceFromFloats(Z,l,C,B){return this.r=Math.max(Z,this.r),this.g=Math.max(l,this.g),this.b=Math.max(C,this.b),this.a=Math.max(B,this.a),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:b.e;return(0,K.WithinEpsilon)(this.r,Z.r,l)&&(0,K.WithinEpsilon)(this.g,Z.g,l)&&(0,K.WithinEpsilon)(this.b,Z.b,l)&&(0,K.WithinEpsilon)(this.a,Z.a,l)}equalsToFloats(Z,l,C,B){return this.r===Z&&this.g===l&&this.b===C&&this.a===B}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Rb"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z=397*Z^255*this.a,Z}clone(){return(new G).B(this)}B(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this.a=Z.a,this}rb(Z,l,C,B){return this.r=Z,this.g=l,this.b=C,this.a=B,this}set(Z,l,C,B){return this.rb(Z,l,C,B)}ob(Z){return this.r=this.g=this.b=this.a=Z,this}toHexString(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=Math.round(255*this.r),C=Math.round(255*this.g),B=Math.round(255*this.b);if(Z)return"#"+(0,K.ToHex)(l)+(0,K.ToHex)(C)+(0,K.ToHex)(B);const x=Math.round(255*this.a);return"#"+(0,K.ToHex)(l)+(0,K.ToHex)(C)+(0,K.ToHex)(B)+(0,K.ToHex)(x)}fromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255,9===Z.length&&(this.a=parseInt(Z.substring(7,9),16)/255)),this}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new G;return this.toLinearSpaceToRef(l,Z),l}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=W(this.r),Z.g=W(this.g),Z.b=W(this.b)):(Z.r=f(this.r),Z.g=f(this.g),Z.b=f(this.b)),Z.a=this.a,this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new G;return this.toGammaSpaceToRef(l,Z),l}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)):(Z.r=J(this.r),Z.g=J(this.g),Z.b=J(this.b)),Z.a=this.a,this}static FromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length?new G(0,0,0,0):new G(0,0,0,1).fromHexString(Z)}static Lerp(Z,l,C){return G.LerpToRef(Z,l,C,new G)}static LerpToRef(Z,l,C,B){return B.r=Z.r+(l.r-Z.r)*C,B.g=Z.g+(l.g-Z.g)*C,B.b=Z.b+(l.b-Z.b)*C,B.a=Z.a+(l.a-Z.a)*C,B}static Hermite(Z,l,C,B,x){const b=x*x,K=x*b,f=2*K-3*b+1,W=-2*K+3*b,J=K-2*b+x,d=K-b,E=Z.r*f+C.r*W+l.r*J+B.r*d,a=Z.g*f+C.g*W+l.g*J+B.g*d,q=Z.b*f+C.b*W+l.b*J+B.b*d,z=Z.a*f+C.a*W+l.a*J+B.a*d;return new G(E,a,q,z)}static Hermite1stDerivative(Z,l,C,B,x){const b=new G;return this.Hermite1stDerivativeToRef(Z,l,C,B,x,b),b}static Hermite1stDerivativeToRef(Z,l,C,B,x,b){const K=x*x;b.r=6*(K-x)*Z.r+(3*K-4*x+1)*l.r+6*(-K+x)*C.r+(3*K-2*x)*B.r,b.g=6*(K-x)*Z.g+(3*K-4*x+1)*l.g+6*(-K+x)*C.g+(3*K-2*x)*B.g,b.b=6*(K-x)*Z.b+(3*K-4*x+1)*l.b+6*(-K+x)*C.b+(3*K-2*x)*B.b,b.a=6*(K-x)*Z.a+(3*K-4*x+1)*l.a+6*(-K+x)*C.a+(3*K-2*x)*B.a}static FromColor3(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G(Z.r,Z.g,Z.b,l)}static il(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(Z[l],Z[l+1],Z[l+2],Z[l+3])}static FromArrayToRef(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=Z[l],C.g=Z[l+1],C.b=Z[l+2],C.a=Z[l+3]}static FromInts(Z,l,C,B){return new G(Z/255,l/255,C/255,B/255)}static CheckColors4(Z,l){if(Z.length===3*l){const l=[];for(let C=0;C<Z.length;C+=3){const B=C/3*4;l[B]=Z[C],l[B+1]=Z[C+1],l[B+2]=Z[C+2],l[B+3]=1}return l}return Z}}G._V8PerformanceHack=new G(.5,.5,.5,.5),Object.defineProperties(G.prototype,{dimension:{value:[4]},rank:{value:1}});class a{}a.Sl=(0,B.b)(3,E.Black),a.Rb=(0,B.b)(3,(()=>new G(0,0,0,0))),(0,x.c)("BABYLON.Color3",E),(0,x.c)("BABYLON.Color4",G)}}]);