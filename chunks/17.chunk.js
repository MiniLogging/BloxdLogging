"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{11239:(B,I,C)=>{C.r(I),C.d(I,{SI:()=>R,Pf:()=>H,TmpColors:()=>F});var M=C(11204),x=C(11149),y=C(11197),f=C(11212);function L(B){return Math.pow(B,y.i)}function e(B){return B<=.04045?.0773993808*B:Math.pow(.947867299*(B+.055),2.4)}function g(B){return Math.pow(B,y.f)}function N(B){return B<=.0031308?12.92*B:1.055*Math.pow(B,.41666)-.055}class R{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=B,this.g=I,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"SI"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B}toArray(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[I]=this.r,B[I+1]=this.g,B[I+2]=this.b,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(B,I,this),this}toColor4(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new H(this.r,this.g,this.b,B)}Df(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(B){return new R(this.r*B.r,this.g*B.g,this.b*B.b)}multiplyToRef(B,I){return I.r=this.r*B.r,I.g=this.g*B.g,I.b=this.b*B.b,I}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this}multiplyByFloats(B,I,C){return new R(this.r*B,this.g*I,this.b*C)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,I){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.r,B.g,B.b)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.r,B.g,B.b)}minimizeInPlaceFromFloats(B,I,C){return this.r=Math.min(B,this.r),this.g=Math.min(I,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(B,I,C){return this.r=Math.max(B,this.r),this.g=Math.max(I,this.g),this.b=Math.max(C,this.b),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b}equalsFloats(B,I,C){return this.equalsToFloats(B,I,C)}equalsToFloats(B,I,C){return this.r===B&&this.g===I&&this.b===C}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:y.d;return(0,f.WithinEpsilon)(this.r,B.r,I)&&(0,f.WithinEpsilon)(this.g,B.g,I)&&(0,f.WithinEpsilon)(this.b,B.b,I)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}scale(B){return new R(this.r*B,this.g*B,this.b*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this}scaleToRef(B,I){return I.r=this.r*B,I.g=this.g*B,I.b=this.b*B,I}scaleAndAddToRef(B,I){return I.r+=this.r*B,I.g+=this.g*B,I.b+=this.b*B,I}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,f.Clamp)(this.r,B,I),C.g=(0,f.Clamp)(this.g,B,I),C.b=(0,f.Clamp)(this.b,B,I),C}add(B){return new R(this.r+B.r,this.g+B.g,this.b+B.b)}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this}addInPlaceFromFloats(B,I,C){return this.r+=B,this.g+=I,this.b+=C,this}addToRef(B,I){return I.r=this.r+B.r,I.g=this.g+B.g,I.b=this.b+B.b,I}FI(B){return new R(this.r-B.r,this.g-B.g,this.b-B.b)}subtractToRef(B,I){return I.r=this.r-B.r,I.g=this.g-B.g,I.b=this.b-B.b,I}cR(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this}subtractFromFloats(B,I,C){return new R(this.r-B,this.g-I,this.b-C)}subtractFromFloatsToRef(B,I,C,M){return M.r=this.r-B,M.g=this.g-I,M.b=this.b-C,M}clone(){return new R(this.r,this.g,this.b)}M(B){return this.r=B.r,this.g=B.g,this.b=B.b,this}vf(B,I,C){return this.r=B,this.g=I,this.b=C,this}set(B,I,C){return this.vf(B,I,C)}Tf(B){return this.r=this.g=this.b=B,this}toHexString(){const B=Math.round(255*this.r),I=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,f.ToHex)(B)+(0,f.ToHex)(I)+(0,f.ToHex)(C)}fromHexString(B){return"#"!==B.substring(0,1)||7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new R)}toHSVToRef(B){const I=this.r,C=this.g,M=this.b,x=Math.max(I,C,M),y=Math.min(I,C,M);let f=0,L=0;const e=x,g=x-y;return 0!==x&&(L=g/x),x!=y&&(x==I?(f=(C-M)/g,C<M&&(f+=6)):x==C?f=(M-I)/g+2:x==M&&(f=(I-C)/g+4),f*=60),B.r=f,B.g=L,B.b=e,B}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new R;return this.toLinearSpaceToRef(I,B),I}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=e(this.r),B.g=e(this.g),B.b=e(this.b)):(B.r=L(this.r),B.g=L(this.g),B.b=L(this.b)),this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new R;return this.toGammaSpaceToRef(I,B),I}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=N(this.r),B.g=N(this.g),B.b=N(this.b)):(B.r=g(this.r),B.g=g(this.g),B.b=g(this.b)),this}static HSVtoRGBToRef(B,I,C,M){const x=C*I,y=B/60,f=x*(1-Math.abs(y%2-1));let L=0,e=0,g=0;y>=0&&y<=1?(L=x,e=f):y>=1&&y<=2?(L=f,e=x):y>=2&&y<=3?(e=x,g=f):y>=3&&y<=4?(e=f,g=x):y>=4&&y<=5?(L=f,g=x):y>=5&&y<=6&&(L=x,g=f);const N=C-x;return M.r=L+N,M.g=e+N,M.b=g+N,M}static FromHSV(B,I,C){const M=new R(0,0,0);return R.HSVtoRGBToRef(B,I,C,M),M}static FromHexString(B){return new R(0,0,0).fromHexString(B)}static oI(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new R(B[I],B[I+1],B[I+2])}static FromArrayToRef(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=B[I],C.g=B[I+1],C.b=B[I+2]}static FromInts(B,I,C){return new R(B/255,I/255,C/255)}static Lerp(B,I,C){const M=new R(0,0,0);return R.LerpToRef(B,I,C,M),M}static LerpToRef(B,I,C,M){M.r=B.r+(I.r-B.r)*C,M.g=B.g+(I.g-B.g)*C,M.b=B.b+(I.b-B.b)*C}static Hermite(B,I,C,M,x){const y=x*x,f=x*y,L=2*f-3*y+1,e=-2*f+3*y,g=f-2*y+x,N=f-y,H=B.r*L+C.r*e+I.r*g+M.r*N,F=B.g*L+C.g*e+I.g*g+M.g*N,k=B.b*L+C.b*e+I.b*g+M.b*N;return new R(H,F,k)}static Hermite1stDerivative(B,I,C,M,x){const y=R.Black();return this.Hermite1stDerivativeToRef(B,I,C,M,x,y),y}static Hermite1stDerivativeToRef(B,I,C,M,x,y){const f=x*x;y.r=6*(f-x)*B.r+(3*f-4*x+1)*I.r+6*(-f+x)*C.r+(3*f-2*x)*M.r,y.g=6*(f-x)*B.g+(3*f-4*x+1)*I.g+6*(-f+x)*C.g+(3*f-2*x)*M.g,y.b=6*(f-x)*B.b+(3*f-4*x+1)*I.b+6*(-f+x)*C.b+(3*f-2*x)*M.b}static Red(){return new R(1,0,0)}static Green(){return new R(0,1,0)}static Blue(){return new R(0,0,1)}static Black(){return new R(0,0,0)}static get BlackReadOnly(){return R._BlackReadOnly}static White(){return new R(1,1,1)}static Purple(){return new R(.5,0,.5)}static Magenta(){return new R(1,0,1)}static Yellow(){return new R(1,1,0)}static Gray(){return new R(.5,.5,.5)}static Teal(){return new R(0,1,1)}static Random(){return new R(Math.random(),Math.random(),Math.random())}}R._V8PerformanceHack=new R(.5,.5,.5),R._BlackReadOnly=R.Black(),Object.defineProperties(R.prototype,{dimension:{value:[3]},rank:{value:1}});class H{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=B,this.g=I,this.b=C,this.a=M}Df(){return[this.r,this.g,this.b,this.a]}toArray(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[I]=this.r,B[I+1]=this.g,B[I+2]=this.b,B[I+3]=this.a,this}RC(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=B[I],this.g=B[I+1],this.b=B[I+2],this.a=B[I+3],this}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b&&this.a===B.a}add(B){return new H(this.r+B.r,this.g+B.g,this.b+B.b,this.a+B.a)}addToRef(B,I){return I.r=this.r+B.r,I.g=this.g+B.g,I.b=this.b+B.b,I.a=this.a+B.a,I}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this.a+=B.a,this}addInPlaceFromFloats(B,I,C,M){return this.r+=B,this.g+=I,this.b+=C,this.a+=M,this}FI(B){return new H(this.r-B.r,this.g-B.g,this.b-B.b,this.a-B.a)}subtractToRef(B,I){return I.r=this.r-B.r,I.g=this.g-B.g,I.b=this.b-B.b,I.a=this.a-B.a,I}cR(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this.a-=B.a,this}subtractFromFloats(B,I,C,M){return new H(this.r-B,this.g-I,this.b-C,this.a-M)}subtractFromFloatsToRef(B,I,C,M,x){return x.r=this.r-B,x.g=this.g-I,x.b=this.b-C,x.a=this.a-M,x}scale(B){return new H(this.r*B,this.g*B,this.b*B,this.a*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this.a*=B,this}scaleToRef(B,I){return I.r=this.r*B,I.g=this.g*B,I.b=this.b*B,I.a=this.a*B,I}scaleAndAddToRef(B,I){return I.r+=this.r*B,I.g+=this.g*B,I.b+=this.b*B,I.a+=this.a*B,I}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,f.Clamp)(this.r,B,I),C.g=(0,f.Clamp)(this.g,B,I),C.b=(0,f.Clamp)(this.b,B,I),C.a=(0,f.Clamp)(this.a,B,I),C}multiply(B){return new H(this.r*B.r,this.g*B.g,this.b*B.b,this.a*B.a)}multiplyToRef(B,I){return I.r=this.r*B.r,I.g=this.g*B.g,I.b=this.b*B.b,I.a=this.a*B.a,I}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this.a*=B.a,this}multiplyByFloats(B,I,C,M){return new H(this.r*B,this.g*I,this.b*C,this.a*M)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,I){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.r=Math.min(this.r,B.r),this.g=Math.min(this.g,B.g),this.b=Math.min(this.b,B.b),this.a=Math.min(this.a,B.a),this}maximizeInPlace(B){return this.r=Math.max(this.r,B.r),this.g=Math.max(this.g,B.g),this.b=Math.max(this.b,B.b),this.a=Math.max(this.a,B.a),this}minimizeInPlaceFromFloats(B,I,C,M){return this.r=Math.min(B,this.r),this.g=Math.min(I,this.g),this.b=Math.min(C,this.b),this.a=Math.min(M,this.a),this}maximizeInPlaceFromFloats(B,I,C,M){return this.r=Math.max(B,this.r),this.g=Math.max(I,this.g),this.b=Math.max(C,this.b),this.a=Math.max(M,this.a),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:y.d;return(0,f.WithinEpsilon)(this.r,B.r,I)&&(0,f.WithinEpsilon)(this.g,B.g,I)&&(0,f.WithinEpsilon)(this.b,B.b,I)&&(0,f.WithinEpsilon)(this.a,B.a,I)}equalsToFloats(B,I,C,M){return this.r===B&&this.g===I&&this.b===C&&this.a===M}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Pf"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B=397*B^255*this.a,B}clone(){return(new H).M(this)}M(B){return this.r=B.r,this.g=B.g,this.b=B.b,this.a=B.a,this}vf(B,I,C,M){return this.r=B,this.g=I,this.b=C,this.a=M,this}set(B,I,C,M){return this.vf(B,I,C,M)}Tf(B){return this.r=this.g=this.b=this.a=B,this}toHexString(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=Math.round(255*this.r),C=Math.round(255*this.g),M=Math.round(255*this.b);if(B)return"#"+(0,f.ToHex)(I)+(0,f.ToHex)(C)+(0,f.ToHex)(M);const x=Math.round(255*this.a);return"#"+(0,f.ToHex)(I)+(0,f.ToHex)(C)+(0,f.ToHex)(M)+(0,f.ToHex)(x)}fromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255,9===B.length&&(this.a=parseInt(B.substring(7,9),16)/255)),this}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new H;return this.toLinearSpaceToRef(I,B),I}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=e(this.r),B.g=e(this.g),B.b=e(this.b)):(B.r=L(this.r),B.g=L(this.g),B.b=L(this.b)),B.a=this.a,this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new H;return this.toGammaSpaceToRef(I,B),I}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=N(this.r),B.g=N(this.g),B.b=N(this.b)):(B.r=g(this.r),B.g=g(this.g),B.b=g(this.b)),B.a=this.a,this}static FromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length?new H(0,0,0,0):new H(0,0,0,1).fromHexString(B)}static Lerp(B,I,C){return H.LerpToRef(B,I,C,new H)}static LerpToRef(B,I,C,M){return M.r=B.r+(I.r-B.r)*C,M.g=B.g+(I.g-B.g)*C,M.b=B.b+(I.b-B.b)*C,M.a=B.a+(I.a-B.a)*C,M}static Hermite(B,I,C,M,x){const y=x*x,f=x*y,L=2*f-3*y+1,e=-2*f+3*y,g=f-2*y+x,N=f-y,R=B.r*L+C.r*e+I.r*g+M.r*N,F=B.g*L+C.g*e+I.g*g+M.g*N,k=B.b*L+C.b*e+I.b*g+M.b*N,q=B.a*L+C.a*e+I.a*g+M.a*N;return new H(R,F,k,q)}static Hermite1stDerivative(B,I,C,M,x){const y=new H;return this.Hermite1stDerivativeToRef(B,I,C,M,x,y),y}static Hermite1stDerivativeToRef(B,I,C,M,x,y){const f=x*x;y.r=6*(f-x)*B.r+(3*f-4*x+1)*I.r+6*(-f+x)*C.r+(3*f-2*x)*M.r,y.g=6*(f-x)*B.g+(3*f-4*x+1)*I.g+6*(-f+x)*C.g+(3*f-2*x)*M.g,y.b=6*(f-x)*B.b+(3*f-4*x+1)*I.b+6*(-f+x)*C.b+(3*f-2*x)*M.b,y.a=6*(f-x)*B.a+(3*f-4*x+1)*I.a+6*(-f+x)*C.a+(3*f-2*x)*M.a}static FromColor3(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H(B.r,B.g,B.b,I)}static oI(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(B[I],B[I+1],B[I+2],B[I+3])}static FromArrayToRef(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=B[I],C.g=B[I+1],C.b=B[I+2],C.a=B[I+3]}static FromInts(B,I,C,M){return new H(B/255,I/255,C/255,M/255)}static CheckColors4(B,I){if(B.length===3*I){const I=[];for(let C=0;C<B.length;C+=3){const M=C/3*4;I[M]=B[C],I[M+1]=B[C+1],I[M+2]=B[C+2],I[M+3]=1}return I}return B}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class F{}F.SI=(0,M.b)(3,R.Black),F.Pf=(0,M.b)(3,(()=>new H(0,0,0,0))),(0,x.h)("BABYLON.Color3",R),(0,x.h)("BABYLON.Color4",H)}}]);