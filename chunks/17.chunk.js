"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[17],{12170:(L,r,p)=>{p.r(r),p.d(r,{Wr:()=>E,Fz:()=>x,TmpColors:()=>w});var J=p(12149),i=p(12087),n=p(12140),j=p(12154);function z(L){return Math.pow(L,n.i)}function G(L){return L<=.04045?.0773993808*L:Math.pow(.947867299*(L+.055),2.4)}function C(L){return Math.pow(L,n.g)}function t(L){return L<=.0031308?12.92*L:1.055*Math.pow(L,.41666)-.055}class E{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=L,this.g=r,this.b=p}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Wr"}getHashCode(){let L=255*this.r|0;return L=397*L^255*this.g,L=397*L^255*this.b,L}toArray(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[r]=this.r,L[r+1]=this.g,L[r+2]=this.b,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(L,r,this),this}toColor4(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new x(this.r,this.g,this.b,L)}mz(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(L){return new E(this.r*L.r,this.g*L.g,this.b*L.b)}multiplyToRef(L,r){return r.r=this.r*L.r,r.g=this.g*L.g,r.b=this.b*L.b,r}multiplyInPlace(L){return this.r*=L.r,this.g*=L.g,this.b*=L.b,this}multiplyByFloats(L,r,p){return new E(this.r*L,this.g*r,this.b*p)}divide(L){throw new ReferenceError("Can not divide a color")}divideToRef(L,r){throw new ReferenceError("Can not divide a color")}divideInPlace(L){throw new ReferenceError("Can not divide a color")}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L.r,L.g,L.b)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L.r,L.g,L.b)}minimizeInPlaceFromFloats(L,r,p){return this.r=Math.min(L,this.r),this.g=Math.min(r,this.g),this.b=Math.min(p,this.b),this}maximizeInPlaceFromFloats(L,r,p){return this.r=Math.max(L,this.r),this.g=Math.max(r,this.g),this.b=Math.max(p,this.b),this}floorToRef(L){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(L){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(L){return L&&this.r===L.r&&this.g===L.g&&this.b===L.b}equalsFloats(L,r,p){return this.equalsToFloats(L,r,p)}equalsToFloats(L,r,p){return this.r===L&&this.g===r&&this.b===p}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.d;return(0,j.WithinEpsilon)(this.r,L.r,r)&&(0,j.WithinEpsilon)(this.g,L.g,r)&&(0,j.WithinEpsilon)(this.b,L.b,r)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(L){throw new ReferenceError("Can not negate a color")}scale(L){return new E(this.r*L,this.g*L,this.b*L)}scaleInPlace(L){return this.r*=L,this.g*=L,this.b*=L,this}scaleToRef(L,r){return r.r=this.r*L,r.g=this.g*L,r.b=this.b*L,r}scaleAndAddToRef(L,r){return r.r+=this.r*L,r.g+=this.g*L,r.b+=this.b*L,r}clampToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,p=arguments.length>2?arguments[2]:void 0;return p.r=(0,j.Clamp)(this.r,L,r),p.g=(0,j.Clamp)(this.g,L,r),p.b=(0,j.Clamp)(this.b,L,r),p}add(L){return new E(this.r+L.r,this.g+L.g,this.b+L.b)}addInPlace(L){return this.r+=L.r,this.g+=L.g,this.b+=L.b,this}addInPlaceFromFloats(L,r,p){return this.r+=L,this.g+=r,this.b+=p,this}addToRef(L,r){return r.r=this.r+L.r,r.g=this.g+L.g,r.b=this.b+L.b,r}Pr(L){return new E(this.r-L.r,this.g-L.g,this.b-L.b)}subtractToRef(L,r){return r.r=this.r-L.r,r.g=this.g-L.g,r.b=this.b-L.b,r}JE(L){return this.r-=L.r,this.g-=L.g,this.b-=L.b,this}subtractFromFloats(L,r,p){return new E(this.r-L,this.g-r,this.b-p)}subtractFromFloatsToRef(L,r,p,J){return J.r=this.r-L,J.g=this.g-r,J.b=this.b-p,J}clone(){return new E(this.r,this.g,this.b)}G(L){return this.r=L.r,this.g=L.g,this.b=L.b,this}Uz(L,r,p){return this.r=L,this.g=r,this.b=p,this}set(L,r,p){return this.Uz(L,r,p)}Bz(L){return this.r=this.g=this.b=L,this}toHexString(){const L=Math.round(255*this.r),r=Math.round(255*this.g),p=Math.round(255*this.b);return"#"+(0,j.ToHex)(L)+(0,j.ToHex)(r)+(0,j.ToHex)(p)}fromHexString(L){return"#"!==L.substring(0,1)||7!==L.length||(this.r=parseInt(L.substring(1,3),16)/255,this.g=parseInt(L.substring(3,5),16)/255,this.b=parseInt(L.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new E)}toHSVToRef(L){const r=this.r,p=this.g,J=this.b,i=Math.max(r,p,J),n=Math.min(r,p,J);let j=0,z=0;const G=i,C=i-n;return 0!==i&&(z=C/i),i!=n&&(i==r?(j=(p-J)/C,p<J&&(j+=6)):i==p?j=(J-r)/C+2:i==J&&(j=(r-p)/C+4),j*=60),L.r=j,L.g=z,L.b=G,L}toLinearSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new E;return this.toLinearSpaceToRef(r,L),r}toLinearSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=G(this.r),L.g=G(this.g),L.b=G(this.b)):(L.r=z(this.r),L.g=z(this.g),L.b=z(this.b)),this}toGammaSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new E;return this.toGammaSpaceToRef(r,L),r}toGammaSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=t(this.r),L.g=t(this.g),L.b=t(this.b)):(L.r=C(this.r),L.g=C(this.g),L.b=C(this.b)),this}static HSVtoRGBToRef(L,r,p,J){const i=p*r,n=L/60,j=i*(1-Math.abs(n%2-1));let z=0,G=0,C=0;n>=0&&n<=1?(z=i,G=j):n>=1&&n<=2?(z=j,G=i):n>=2&&n<=3?(G=i,C=j):n>=3&&n<=4?(G=j,C=i):n>=4&&n<=5?(z=j,C=i):n>=5&&n<=6&&(z=i,C=j);const t=p-i;return J.r=z+t,J.g=G+t,J.b=C+t,J}static FromHSV(L,r,p){const J=new E(0,0,0);return E.HSVtoRGBToRef(L,r,p,J),J}static FromHexString(L){return new E(0,0,0).fromHexString(L)}static Br(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(L[r],L[r+1],L[r+2])}static FromArrayToRef(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2?arguments[2]:void 0;p.r=L[r],p.g=L[r+1],p.b=L[r+2]}static FromInts(L,r,p){return new E(L/255,r/255,p/255)}static Lerp(L,r,p){const J=new E(0,0,0);return E.LerpToRef(L,r,p,J),J}static LerpToRef(L,r,p,J){J.r=L.r+(r.r-L.r)*p,J.g=L.g+(r.g-L.g)*p,J.b=L.b+(r.b-L.b)*p}static Hermite(L,r,p,J,i){const n=i*i,j=i*n,z=2*j-3*n+1,G=-2*j+3*n,C=j-2*n+i,t=j-n,x=L.r*z+p.r*G+r.r*C+J.r*t,w=L.g*z+p.g*G+r.g*C+J.g*t,g=L.b*z+p.b*G+r.b*C+J.b*t;return new E(x,w,g)}static Hermite1stDerivative(L,r,p,J,i){const n=E.Black();return this.Hermite1stDerivativeToRef(L,r,p,J,i,n),n}static Hermite1stDerivativeToRef(L,r,p,J,i,n){const j=i*i;n.r=6*(j-i)*L.r+(3*j-4*i+1)*r.r+6*(-j+i)*p.r+(3*j-2*i)*J.r,n.g=6*(j-i)*L.g+(3*j-4*i+1)*r.g+6*(-j+i)*p.g+(3*j-2*i)*J.g,n.b=6*(j-i)*L.b+(3*j-4*i+1)*r.b+6*(-j+i)*p.b+(3*j-2*i)*J.b}static Red(){return new E(1,0,0)}static Green(){return new E(0,1,0)}static Blue(){return new E(0,0,1)}static Black(){return new E(0,0,0)}static get BlackReadOnly(){return E._BlackReadOnly}static White(){return new E(1,1,1)}static Purple(){return new E(.5,0,.5)}static Magenta(){return new E(1,0,1)}static Yellow(){return new E(1,1,0)}static Gray(){return new E(.5,.5,.5)}static Teal(){return new E(0,1,1)}static Random(){return new E(Math.random(),Math.random(),Math.random())}}E._V8PerformanceHack=new E(.5,.5,.5),E._BlackReadOnly=E.Black(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class x{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=L,this.g=r,this.b=p,this.a=J}mz(){return[this.r,this.g,this.b,this.a]}toArray(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[r]=this.r,L[r+1]=this.g,L[r+2]=this.b,L[r+3]=this.a,this}hp(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=L[r],this.g=L[r+1],this.b=L[r+2],this.a=L[r+3],this}equals(L){return L&&this.r===L.r&&this.g===L.g&&this.b===L.b&&this.a===L.a}add(L){return new x(this.r+L.r,this.g+L.g,this.b+L.b,this.a+L.a)}addToRef(L,r){return r.r=this.r+L.r,r.g=this.g+L.g,r.b=this.b+L.b,r.a=this.a+L.a,r}addInPlace(L){return this.r+=L.r,this.g+=L.g,this.b+=L.b,this.a+=L.a,this}addInPlaceFromFloats(L,r,p,J){return this.r+=L,this.g+=r,this.b+=p,this.a+=J,this}Pr(L){return new x(this.r-L.r,this.g-L.g,this.b-L.b,this.a-L.a)}subtractToRef(L,r){return r.r=this.r-L.r,r.g=this.g-L.g,r.b=this.b-L.b,r.a=this.a-L.a,r}JE(L){return this.r-=L.r,this.g-=L.g,this.b-=L.b,this.a-=L.a,this}subtractFromFloats(L,r,p,J){return new x(this.r-L,this.g-r,this.b-p,this.a-J)}subtractFromFloatsToRef(L,r,p,J,i){return i.r=this.r-L,i.g=this.g-r,i.b=this.b-p,i.a=this.a-J,i}scale(L){return new x(this.r*L,this.g*L,this.b*L,this.a*L)}scaleInPlace(L){return this.r*=L,this.g*=L,this.b*=L,this.a*=L,this}scaleToRef(L,r){return r.r=this.r*L,r.g=this.g*L,r.b=this.b*L,r.a=this.a*L,r}scaleAndAddToRef(L,r){return r.r+=this.r*L,r.g+=this.g*L,r.b+=this.b*L,r.a+=this.a*L,r}clampToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,p=arguments.length>2?arguments[2]:void 0;return p.r=(0,j.Clamp)(this.r,L,r),p.g=(0,j.Clamp)(this.g,L,r),p.b=(0,j.Clamp)(this.b,L,r),p.a=(0,j.Clamp)(this.a,L,r),p}multiply(L){return new x(this.r*L.r,this.g*L.g,this.b*L.b,this.a*L.a)}multiplyToRef(L,r){return r.r=this.r*L.r,r.g=this.g*L.g,r.b=this.b*L.b,r.a=this.a*L.a,r}multiplyInPlace(L){return this.r*=L.r,this.g*=L.g,this.b*=L.b,this.a*=L.a,this}multiplyByFloats(L,r,p,J){return new x(this.r*L,this.g*r,this.b*p,this.a*J)}divide(L){throw new ReferenceError("Can not divide a color")}divideToRef(L,r){throw new ReferenceError("Can not divide a color")}divideInPlace(L){throw new ReferenceError("Can not divide a color")}minimizeInPlace(L){return this.r=Math.min(this.r,L.r),this.g=Math.min(this.g,L.g),this.b=Math.min(this.b,L.b),this.a=Math.min(this.a,L.a),this}maximizeInPlace(L){return this.r=Math.max(this.r,L.r),this.g=Math.max(this.g,L.g),this.b=Math.max(this.b,L.b),this.a=Math.max(this.a,L.a),this}minimizeInPlaceFromFloats(L,r,p,J){return this.r=Math.min(L,this.r),this.g=Math.min(r,this.g),this.b=Math.min(p,this.b),this.a=Math.min(J,this.a),this}maximizeInPlaceFromFloats(L,r,p,J){return this.r=Math.max(L,this.r),this.g=Math.max(r,this.g),this.b=Math.max(p,this.b),this.a=Math.max(J,this.a),this}floorToRef(L){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(L){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(L){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.d;return(0,j.WithinEpsilon)(this.r,L.r,r)&&(0,j.WithinEpsilon)(this.g,L.g,r)&&(0,j.WithinEpsilon)(this.b,L.b,r)&&(0,j.WithinEpsilon)(this.a,L.a,r)}equalsToFloats(L,r,p,J){return this.r===L&&this.g===r&&this.b===p&&this.a===J}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Fz"}getHashCode(){let L=255*this.r|0;return L=397*L^255*this.g,L=397*L^255*this.b,L=397*L^255*this.a,L}clone(){return(new x).G(this)}G(L){return this.r=L.r,this.g=L.g,this.b=L.b,this.a=L.a,this}Uz(L,r,p,J){return this.r=L,this.g=r,this.b=p,this.a=J,this}set(L,r,p,J){return this.Uz(L,r,p,J)}Bz(L){return this.r=this.g=this.b=this.a=L,this}toHexString(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=Math.round(255*this.r),p=Math.round(255*this.g),J=Math.round(255*this.b);if(L)return"#"+(0,j.ToHex)(r)+(0,j.ToHex)(p)+(0,j.ToHex)(J);const i=Math.round(255*this.a);return"#"+(0,j.ToHex)(r)+(0,j.ToHex)(p)+(0,j.ToHex)(J)+(0,j.ToHex)(i)}fromHexString(L){return"#"!==L.substring(0,1)||9!==L.length&&7!==L.length||(this.r=parseInt(L.substring(1,3),16)/255,this.g=parseInt(L.substring(3,5),16)/255,this.b=parseInt(L.substring(5,7),16)/255,9===L.length&&(this.a=parseInt(L.substring(7,9),16)/255)),this}toLinearSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new x;return this.toLinearSpaceToRef(r,L),r}toLinearSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=G(this.r),L.g=G(this.g),L.b=G(this.b)):(L.r=z(this.r),L.g=z(this.g),L.b=z(this.b)),L.a=this.a,this}toGammaSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new x;return this.toGammaSpaceToRef(r,L),r}toGammaSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=t(this.r),L.g=t(this.g),L.b=t(this.b)):(L.r=C(this.r),L.g=C(this.g),L.b=C(this.b)),L.a=this.a,this}static FromHexString(L){return"#"!==L.substring(0,1)||9!==L.length&&7!==L.length?new x(0,0,0,0):new x(0,0,0,1).fromHexString(L)}static Lerp(L,r,p){return x.LerpToRef(L,r,p,new x)}static LerpToRef(L,r,p,J){return J.r=L.r+(r.r-L.r)*p,J.g=L.g+(r.g-L.g)*p,J.b=L.b+(r.b-L.b)*p,J.a=L.a+(r.a-L.a)*p,J}static Hermite(L,r,p,J,i){const n=i*i,j=i*n,z=2*j-3*n+1,G=-2*j+3*n,C=j-2*n+i,t=j-n,E=L.r*z+p.r*G+r.r*C+J.r*t,w=L.g*z+p.g*G+r.g*C+J.g*t,g=L.b*z+p.b*G+r.b*C+J.b*t,b=L.a*z+p.a*G+r.a*C+J.a*t;return new x(E,w,g,b)}static Hermite1stDerivative(L,r,p,J,i){const n=new x;return this.Hermite1stDerivativeToRef(L,r,p,J,i,n),n}static Hermite1stDerivativeToRef(L,r,p,J,i,n){const j=i*i;n.r=6*(j-i)*L.r+(3*j-4*i+1)*r.r+6*(-j+i)*p.r+(3*j-2*i)*J.r,n.g=6*(j-i)*L.g+(3*j-4*i+1)*r.g+6*(-j+i)*p.g+(3*j-2*i)*J.g,n.b=6*(j-i)*L.b+(3*j-4*i+1)*r.b+6*(-j+i)*p.b+(3*j-2*i)*J.b,n.a=6*(j-i)*L.a+(3*j-4*i+1)*r.a+6*(-j+i)*p.a+(3*j-2*i)*J.a}static FromColor3(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x(L.r,L.g,L.b,r)}static Br(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(L[r],L[r+1],L[r+2],L[r+3])}static FromArrayToRef(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2?arguments[2]:void 0;p.r=L[r],p.g=L[r+1],p.b=L[r+2],p.a=L[r+3]}static FromInts(L,r,p,J){return new x(L/255,r/255,p/255,J/255)}static CheckColors4(L,r){if(L.length===3*r){const r=[];for(let p=0;p<L.length;p+=3){const J=p/3*4;r[J]=L[p],r[J+1]=L[p+1],r[J+2]=L[p+2],r[J+3]=1}return r}return L}}x._V8PerformanceHack=new x(.5,.5,.5,.5),Object.defineProperties(x.prototype,{dimension:{value:[4]},rank:{value:1}});class w{}w.Wr=(0,J.e)(3,E.Black),w.Fz=(0,J.e)(3,(()=>new x(0,0,0,0))),(0,i.e)("BABYLON.Color3",E),(0,i.e)("BABYLON.Color4",x)}}]);