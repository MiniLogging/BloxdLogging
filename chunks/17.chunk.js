"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[17],{11757:(w,o,H)=>{H.r(o),H.d(o,{ko:()=>y,ae:()=>z,TmpColors:()=>C});var h=H(11727),E=H(11666),e=H(11722),D=H(11729);function t(w){return Math.pow(w,e.g)}function X(w){return w<=.04045?.0773993808*w:Math.pow(.947867299*(w+.055),2.4)}function L(w){return Math.pow(w,e.e)}function A(w){return w<=.0031308?12.92*w:1.055*Math.pow(w,.41666)-.055}class y{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=w,this.g=o,this.b=H}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ko"}getHashCode(){let w=255*this.r|0;return w=397*w^255*this.g,w=397*w^255*this.b,w}toArray(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[o]=this.r,w[o+1]=this.g,w[o+2]=this.b,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(w,o,this),this}toColor4(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new z(this.r,this.g,this.b,w)}Ae(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(w){return new y(this.r*w.r,this.g*w.g,this.b*w.b)}multiplyToRef(w,o){return o.r=this.r*w.r,o.g=this.g*w.g,o.b=this.b*w.b,o}multiplyInPlace(w){return this.r*=w.r,this.g*=w.g,this.b*=w.b,this}multiplyByFloats(w,o,H){return new y(this.r*w,this.g*o,this.b*H)}divide(w){throw new ReferenceError("Can not divide a color")}divideToRef(w,o){throw new ReferenceError("Can not divide a color")}divideInPlace(w){throw new ReferenceError("Can not divide a color")}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w.r,w.g,w.b)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w.r,w.g,w.b)}minimizeInPlaceFromFloats(w,o,H){return this.r=Math.min(w,this.r),this.g=Math.min(o,this.g),this.b=Math.min(H,this.b),this}maximizeInPlaceFromFloats(w,o,H){return this.r=Math.max(w,this.r),this.g=Math.max(o,this.g),this.b=Math.max(H,this.b),this}floorToRef(w){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(w){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(w){return w&&this.r===w.r&&this.g===w.g&&this.b===w.b}equalsFloats(w,o,H){return this.equalsToFloats(w,o,H)}equalsToFloats(w,o,H){return this.r===w&&this.g===o&&this.b===H}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return(0,D.WithinEpsilon)(this.r,w.r,o)&&(0,D.WithinEpsilon)(this.g,w.g,o)&&(0,D.WithinEpsilon)(this.b,w.b,o)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(w){throw new ReferenceError("Can not negate a color")}scale(w){return new y(this.r*w,this.g*w,this.b*w)}scaleInPlace(w){return this.r*=w,this.g*=w,this.b*=w,this}scaleToRef(w,o){return o.r=this.r*w,o.g=this.g*w,o.b=this.b*w,o}scaleAndAddToRef(w,o){return o.r+=this.r*w,o.g+=this.g*w,o.b+=this.b*w,o}clampToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.r=(0,D.Clamp)(this.r,w,o),H.g=(0,D.Clamp)(this.g,w,o),H.b=(0,D.Clamp)(this.b,w,o),H}add(w){return new y(this.r+w.r,this.g+w.g,this.b+w.b)}addInPlace(w){return this.r+=w.r,this.g+=w.g,this.b+=w.b,this}addInPlaceFromFloats(w,o,H){return this.r+=w,this.g+=o,this.b+=H,this}addToRef(w,o){return o.r=this.r+w.r,o.g=this.g+w.g,o.b=this.b+w.b,o}so(w){return new y(this.r-w.r,this.g-w.g,this.b-w.b)}subtractToRef(w,o){return o.r=this.r-w.r,o.g=this.g-w.g,o.b=this.b-w.b,o}wy(w){return this.r-=w.r,this.g-=w.g,this.b-=w.b,this}subtractFromFloats(w,o,H){return new y(this.r-w,this.g-o,this.b-H)}subtractFromFloatsToRef(w,o,H,h){return h.r=this.r-w,h.g=this.g-o,h.b=this.b-H,h}clone(){return new y(this.r,this.g,this.b)}t(w){return this.r=w.r,this.g=w.g,this.b=w.b,this}We(w,o,H){return this.r=w,this.g=o,this.b=H,this}set(w,o,H){return this.We(w,o,H)}Ge(w){return this.r=this.g=this.b=w,this}toHexString(){const w=Math.round(255*this.r),o=Math.round(255*this.g),H=Math.round(255*this.b);return"#"+(0,D.ToHex)(w)+(0,D.ToHex)(o)+(0,D.ToHex)(H)}fromHexString(w){return"#"!==w.substring(0,1)||7!==w.length||(this.r=parseInt(w.substring(1,3),16)/255,this.g=parseInt(w.substring(3,5),16)/255,this.b=parseInt(w.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new y)}toHSVToRef(w){const o=this.r,H=this.g,h=this.b,E=Math.max(o,H,h),e=Math.min(o,H,h);let D=0,t=0;const X=E,L=E-e;return 0!==E&&(t=L/E),E!=e&&(E==o?(D=(H-h)/L,H<h&&(D+=6)):E==H?D=(h-o)/L+2:E==h&&(D=(o-H)/L+4),D*=60),w.r=D,w.g=t,w.b=X,w}toLinearSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new y;return this.toLinearSpaceToRef(o,w),o}toLinearSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=X(this.r),w.g=X(this.g),w.b=X(this.b)):(w.r=t(this.r),w.g=t(this.g),w.b=t(this.b)),this}toGammaSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new y;return this.toGammaSpaceToRef(o,w),o}toGammaSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=A(this.r),w.g=A(this.g),w.b=A(this.b)):(w.r=L(this.r),w.g=L(this.g),w.b=L(this.b)),this}static HSVtoRGBToRef(w,o,H,h){const E=H*o,e=w/60,D=E*(1-Math.abs(e%2-1));let t=0,X=0,L=0;e>=0&&e<=1?(t=E,X=D):e>=1&&e<=2?(t=D,X=E):e>=2&&e<=3?(X=E,L=D):e>=3&&e<=4?(X=D,L=E):e>=4&&e<=5?(t=D,L=E):e>=5&&e<=6&&(t=E,L=D);const A=H-E;return h.r=t+A,h.g=X+A,h.b=L+A,h}static FromHSV(w,o,H){const h=new y(0,0,0);return y.HSVtoRGBToRef(w,o,H,h),h}static FromHexString(w){return new y(0,0,0).fromHexString(w)}static Po(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(w[o],w[o+1],w[o+2])}static FromArrayToRef(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2?arguments[2]:void 0;H.r=w[o],H.g=w[o+1],H.b=w[o+2]}static FromInts(w,o,H){return new y(w/255,o/255,H/255)}static Lerp(w,o,H){const h=new y(0,0,0);return y.LerpToRef(w,o,H,h),h}static LerpToRef(w,o,H,h){h.r=w.r+(o.r-w.r)*H,h.g=w.g+(o.g-w.g)*H,h.b=w.b+(o.b-w.b)*H}static Hermite(w,o,H,h,E){const e=E*E,D=E*e,t=2*D-3*e+1,X=-2*D+3*e,L=D-2*e+E,A=D-e,z=w.r*t+H.r*X+o.r*L+h.r*A,C=w.g*t+H.g*X+o.g*L+h.g*A,Q=w.b*t+H.b*X+o.b*L+h.b*A;return new y(z,C,Q)}static Hermite1stDerivative(w,o,H,h,E){const e=y.Black();return this.Hermite1stDerivativeToRef(w,o,H,h,E,e),e}static Hermite1stDerivativeToRef(w,o,H,h,E,e){const D=E*E;e.r=6*(D-E)*w.r+(3*D-4*E+1)*o.r+6*(-D+E)*H.r+(3*D-2*E)*h.r,e.g=6*(D-E)*w.g+(3*D-4*E+1)*o.g+6*(-D+E)*H.g+(3*D-2*E)*h.g,e.b=6*(D-E)*w.b+(3*D-4*E+1)*o.b+6*(-D+E)*H.b+(3*D-2*E)*h.b}static Red(){return new y(1,0,0)}static Green(){return new y(0,1,0)}static Blue(){return new y(0,0,1)}static Black(){return new y(0,0,0)}static get BlackReadOnly(){return y._BlackReadOnly}static White(){return new y(1,1,1)}static Purple(){return new y(.5,0,.5)}static Magenta(){return new y(1,0,1)}static Yellow(){return new y(1,1,0)}static Gray(){return new y(.5,.5,.5)}static Teal(){return new y(0,1,1)}static Random(){return new y(Math.random(),Math.random(),Math.random())}}y._V8PerformanceHack=new y(.5,.5,.5),y._BlackReadOnly=y.Black(),Object.defineProperties(y.prototype,{dimension:{value:[3]},rank:{value:1}});class z{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=w,this.g=o,this.b=H,this.a=h}Ae(){return[this.r,this.g,this.b,this.a]}toArray(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[o]=this.r,w[o+1]=this.g,w[o+2]=this.b,w[o+3]=this.a,this}iH(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=w[o],this.g=w[o+1],this.b=w[o+2],this.a=w[o+3],this}equals(w){return w&&this.r===w.r&&this.g===w.g&&this.b===w.b&&this.a===w.a}add(w){return new z(this.r+w.r,this.g+w.g,this.b+w.b,this.a+w.a)}addToRef(w,o){return o.r=this.r+w.r,o.g=this.g+w.g,o.b=this.b+w.b,o.a=this.a+w.a,o}addInPlace(w){return this.r+=w.r,this.g+=w.g,this.b+=w.b,this.a+=w.a,this}addInPlaceFromFloats(w,o,H,h){return this.r+=w,this.g+=o,this.b+=H,this.a+=h,this}so(w){return new z(this.r-w.r,this.g-w.g,this.b-w.b,this.a-w.a)}subtractToRef(w,o){return o.r=this.r-w.r,o.g=this.g-w.g,o.b=this.b-w.b,o.a=this.a-w.a,o}wy(w){return this.r-=w.r,this.g-=w.g,this.b-=w.b,this.a-=w.a,this}subtractFromFloats(w,o,H,h){return new z(this.r-w,this.g-o,this.b-H,this.a-h)}subtractFromFloatsToRef(w,o,H,h,E){return E.r=this.r-w,E.g=this.g-o,E.b=this.b-H,E.a=this.a-h,E}scale(w){return new z(this.r*w,this.g*w,this.b*w,this.a*w)}scaleInPlace(w){return this.r*=w,this.g*=w,this.b*=w,this.a*=w,this}scaleToRef(w,o){return o.r=this.r*w,o.g=this.g*w,o.b=this.b*w,o.a=this.a*w,o}scaleAndAddToRef(w,o){return o.r+=this.r*w,o.g+=this.g*w,o.b+=this.b*w,o.a+=this.a*w,o}clampToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.r=(0,D.Clamp)(this.r,w,o),H.g=(0,D.Clamp)(this.g,w,o),H.b=(0,D.Clamp)(this.b,w,o),H.a=(0,D.Clamp)(this.a,w,o),H}multiply(w){return new z(this.r*w.r,this.g*w.g,this.b*w.b,this.a*w.a)}multiplyToRef(w,o){return o.r=this.r*w.r,o.g=this.g*w.g,o.b=this.b*w.b,o.a=this.a*w.a,o}multiplyInPlace(w){return this.r*=w.r,this.g*=w.g,this.b*=w.b,this.a*=w.a,this}multiplyByFloats(w,o,H,h){return new z(this.r*w,this.g*o,this.b*H,this.a*h)}divide(w){throw new ReferenceError("Can not divide a color")}divideToRef(w,o){throw new ReferenceError("Can not divide a color")}divideInPlace(w){throw new ReferenceError("Can not divide a color")}minimizeInPlace(w){return this.r=Math.min(this.r,w.r),this.g=Math.min(this.g,w.g),this.b=Math.min(this.b,w.b),this.a=Math.min(this.a,w.a),this}maximizeInPlace(w){return this.r=Math.max(this.r,w.r),this.g=Math.max(this.g,w.g),this.b=Math.max(this.b,w.b),this.a=Math.max(this.a,w.a),this}minimizeInPlaceFromFloats(w,o,H,h){return this.r=Math.min(w,this.r),this.g=Math.min(o,this.g),this.b=Math.min(H,this.b),this.a=Math.min(h,this.a),this}maximizeInPlaceFromFloats(w,o,H,h){return this.r=Math.max(w,this.r),this.g=Math.max(o,this.g),this.b=Math.max(H,this.b),this.a=Math.max(h,this.a),this}floorToRef(w){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(w){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(w){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.c;return(0,D.WithinEpsilon)(this.r,w.r,o)&&(0,D.WithinEpsilon)(this.g,w.g,o)&&(0,D.WithinEpsilon)(this.b,w.b,o)&&(0,D.WithinEpsilon)(this.a,w.a,o)}equalsToFloats(w,o,H,h){return this.r===w&&this.g===o&&this.b===H&&this.a===h}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ae"}getHashCode(){let w=255*this.r|0;return w=397*w^255*this.g,w=397*w^255*this.b,w=397*w^255*this.a,w}clone(){return(new z).t(this)}t(w){return this.r=w.r,this.g=w.g,this.b=w.b,this.a=w.a,this}We(w,o,H,h){return this.r=w,this.g=o,this.b=H,this.a=h,this}set(w,o,H,h){return this.We(w,o,H,h)}Ge(w){return this.r=this.g=this.b=this.a=w,this}toHexString(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=Math.round(255*this.r),H=Math.round(255*this.g),h=Math.round(255*this.b);if(w)return"#"+(0,D.ToHex)(o)+(0,D.ToHex)(H)+(0,D.ToHex)(h);const E=Math.round(255*this.a);return"#"+(0,D.ToHex)(o)+(0,D.ToHex)(H)+(0,D.ToHex)(h)+(0,D.ToHex)(E)}fromHexString(w){return"#"!==w.substring(0,1)||9!==w.length&&7!==w.length||(this.r=parseInt(w.substring(1,3),16)/255,this.g=parseInt(w.substring(3,5),16)/255,this.b=parseInt(w.substring(5,7),16)/255,9===w.length&&(this.a=parseInt(w.substring(7,9),16)/255)),this}toLinearSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new z;return this.toLinearSpaceToRef(o,w),o}toLinearSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=X(this.r),w.g=X(this.g),w.b=X(this.b)):(w.r=t(this.r),w.g=t(this.g),w.b=t(this.b)),w.a=this.a,this}toGammaSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const o=new z;return this.toGammaSpaceToRef(o,w),o}toGammaSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=A(this.r),w.g=A(this.g),w.b=A(this.b)):(w.r=L(this.r),w.g=L(this.g),w.b=L(this.b)),w.a=this.a,this}static FromHexString(w){return"#"!==w.substring(0,1)||9!==w.length&&7!==w.length?new z(0,0,0,0):new z(0,0,0,1).fromHexString(w)}static Lerp(w,o,H){return z.LerpToRef(w,o,H,new z)}static LerpToRef(w,o,H,h){return h.r=w.r+(o.r-w.r)*H,h.g=w.g+(o.g-w.g)*H,h.b=w.b+(o.b-w.b)*H,h.a=w.a+(o.a-w.a)*H,h}static Hermite(w,o,H,h,E){const e=E*E,D=E*e,t=2*D-3*e+1,X=-2*D+3*e,L=D-2*e+E,A=D-e,y=w.r*t+H.r*X+o.r*L+h.r*A,C=w.g*t+H.g*X+o.g*L+h.g*A,Q=w.b*t+H.b*X+o.b*L+h.b*A,M=w.a*t+H.a*X+o.a*L+h.a*A;return new z(y,C,Q,M)}static Hermite1stDerivative(w,o,H,h,E){const e=new z;return this.Hermite1stDerivativeToRef(w,o,H,h,E,e),e}static Hermite1stDerivativeToRef(w,o,H,h,E,e){const D=E*E;e.r=6*(D-E)*w.r+(3*D-4*E+1)*o.r+6*(-D+E)*H.r+(3*D-2*E)*h.r,e.g=6*(D-E)*w.g+(3*D-4*E+1)*o.g+6*(-D+E)*H.g+(3*D-2*E)*h.g,e.b=6*(D-E)*w.b+(3*D-4*E+1)*o.b+6*(-D+E)*H.b+(3*D-2*E)*h.b,e.a=6*(D-E)*w.a+(3*D-4*E+1)*o.a+6*(-D+E)*H.a+(3*D-2*E)*h.a}static FromColor3(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new z(w.r,w.g,w.b,o)}static Po(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(w[o],w[o+1],w[o+2],w[o+3])}static FromArrayToRef(w){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2?arguments[2]:void 0;H.r=w[o],H.g=w[o+1],H.b=w[o+2],H.a=w[o+3]}static FromInts(w,o,H,h){return new z(w/255,o/255,H/255,h/255)}static CheckColors4(w,o){if(w.length===3*o){const o=[];for(let H=0;H<w.length;H+=3){const h=H/3*4;o[h]=w[H],o[h+1]=w[H+1],o[h+2]=w[H+2],o[h+3]=1}return o}return w}}z._V8PerformanceHack=new z(.5,.5,.5,.5),Object.defineProperties(z.prototype,{dimension:{value:[4]},rank:{value:1}});class C{}C.ko=(0,h.c)(3,y.Black),C.ae=(0,h.c)(3,(()=>new z(0,0,0,0))),(0,E.g)("BABYLON.Color3",y),(0,E.g)("BABYLON.Color4",z)}}]);