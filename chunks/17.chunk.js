"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2520:(t,q,S)=>{S.r(q),S.d(q,{ReadExrDataAsync:()=>bt,_ExrTextureLoader:()=>Zt});var o=S(496),B=S(689);const z=4,L=4,r=1,e=2,C=8,Z=65536,b=Z>>3,O=14,i=65537,h=1<<O,l=h-1,I=59,a=63,v=2+a-I;var M,x;!function(t){t[t.NO_COMPRESSION=0]="NO_COMPRESSION",t[t.RLE_COMPRESSION=1]="RLE_COMPRESSION",t[t.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",t[t.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",t[t.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",t[t.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(M||(M={})),function(t){t[t.INCREASING_Y=0]="INCREASING_Y",t[t.DECREASING_Y=1]="DECREASING_Y"}(x||(x={}));const k=function(){const t=new ArrayBuffer(4),q=new Float32Array(t),S=new Uint32Array(t),o=new Uint32Array(512),B=new Uint32Array(512);for(let e=0;e<256;++e){const t=e-127;t<-27?(o[e]=0,o[256|e]=32768,B[e]=24,B[256|e]=24):t<-14?(o[e]=1024>>-t-14,o[256|e]=1024>>-t-14|32768,B[e]=-t-1,B[256|e]=-t-1):t<=15?(o[e]=t+15<<10,o[256|e]=t+15<<10|32768,B[e]=13,B[256|e]=13):t<128?(o[e]=31744,o[256|e]=64512,B[e]=24,B[256|e]=24):(o[e]=31744,o[256|e]=64512,B[e]=13,B[256|e]=13)}const z=new Uint32Array(2048),L=new Uint32Array(64),r=new Uint32Array(64);for(let e=1;e<1024;++e){let t=e<<13,q=0;for(;0===(8388608&t);)t<<=1,q-=8388608;t&=-8388609,q+=947912704,z[e]=t|q}for(let e=1024;e<2048;++e)z[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)L[e]=e<<23;L[31]=1199570944,L[32]=2147483648;for(let e=33;e<63;++e)L[e]=2147483648+(e-32<<23);L[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(r[e]=1024);return{floatView:q,uint32View:S,baseTable:o,shiftTable:B,mantissaTable:z,exponentTable:L,offsetTable:r}}();function V(t,q){const S=new Uint8Array(t);let o=0;for(;0!=S[q.value+o];)o+=1;const B=(new TextDecoder).decode(S.slice(q.value,q.value+o));return q.value=q.value+o+1,B}function J(t,q){const S=t.getInt32(q.value,!0);return q.value+=z,S}function U(t,q){const S=t.getUint32(q.value,!0);return q.value+=z,S}function H(t,q){const S=t.getUint8(q.value);return q.value+=r,S}function j(t,q){const S=t.getUint16(q.value,!0);return q.value+=e,S}function y(t,q){const S=t[q.value];return q.value+=r,S}function Q(t,q){let S;return S="getBigInt64"in DataView.prototype?Number(t.getBigInt64(q.value,!0)):t.getUint32(q.value+4,!0)+Number(t.getUint32(q.value,!0)<<32),q.value+=C,S}function K(t,q){const S=t.getFloat32(q.value,!0);return q.value+=L,S}function X(t,q){return function(t){const q=(31744&t)>>10,S=1023&t;return(t>>15?-1:1)*(q?31===q?S?NaN:1/0:Math.pow(2,q-15)*(1+S/1024):S/1024*6103515625e-14)}(j(t,q))}function G(t,q){return function(t){if(Math.abs(t)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");t=(0,B.Clamp)(t,-65504,65504),k.floatView[0]=t;const q=k.uint32View[0],S=q>>23&511;return k.baseTable[S]+((8388607&q)>>k.shiftTable[S])}(K(t,q))}function Y(t,q,S,o){switch(S){case"string":case"stringvector":case"iccProfile":return function(t,q,S){const o=(new TextDecoder).decode(new Uint8Array(t).slice(q.value,q.value+S));return q.value=q.value+S,o}(t.buffer,q,o);case"chlist":return function(t,q,S){const o=q.value,B=[];for(;q.value<o+S-1;){const S=V(t.buffer,q),o=J(t,q),z=H(t,q);q.value+=3;const L=J(t,q),r=J(t,q);B.push({name:S,pixelType:o,pLinear:z,xSampling:L,ySampling:r})}return q.value+=1,B}(t,q,o);case"chromaticities":return function(t,q){return{redX:K(t,q),redY:K(t,q),greenX:K(t,q),greenY:K(t,q),blueX:K(t,q),blueY:K(t,q),whiteX:K(t,q),whiteY:K(t,q)}}(t,q);case"compression":return function(t,q){return H(t,q)}(t,q);case"box2i":return function(t,q){return{xMin:J(t,q),yMin:J(t,q),xMax:J(t,q),yMax:J(t,q)}}(t,q);case"lineOrder":return function(t,q){const S=H(t,q);return x[S]}(t,q);case"float":return K(t,q);case"v2f":return function(t,q){return[K(t,q),K(t,q)]}(t,q);case"v3f":return function(t,q){return[K(t,q),K(t,q),K(t,q)]}(t,q);case"int":return J(t,q);case"rational":return function(t,q){return[J(t,q),U(t,q)]}(t,q);case"timecode":return function(t,q){return[U(t,q),U(t,q)]}(t,q);case"preview":return q.value+=o,"skipped";default:return void(q.value+=o)}}function n(t){for(let q=1;q<t.length;q++){const S=t[q-1]+t[q]-128;t[q]=S}}function u(t,q){let S=0,o=Math.floor((t.length+1)/2),B=0;const z=t.length-1;for(;!(B>z)&&(q[B++]=t[S++],!(B>z));)q[B++]=t[o++]}const W=20000630;function f(t,q){if(t.getUint32(0,!0)!=W)throw new Error("Incorrect OpenEXR format");const S=t.getUint8(4),B=t.getUint8(5),z={singleTile:!!(2&B),longName:!!(4&B),deepFormat:!!(8&B),multiPart:!!(16&B)};q.value=8;const L={};let r=!0;for(;r;){const S=V(t.buffer,q);if(S){const B=V(t.buffer,q),z=Y(t,q,B,U(t,q));void 0===z?o.c.Warn(`Unknown header attribute type ${B}'.`):L[S]=z}else r=!1}if(0!=(-5&B))throw new Error("Unsupported file format");return{version:S,spec:z,...L}}const D=32768,m=65535;function A(t,q,S,o,B){for(;S<t;)q=q<<8|y(o,B),S+=8;return{l:q>>(S-=t)&(1<<t)-1,c:q,lc:S}}function c(t,q,S,o){return{c:t=t<<8|y(S,o),lc:q+=8}}function s(t,q,S,o,B,z,L,r,e){if(t==q){if(o<8){const t=c(S,o,B,z);S=t.c,o=t.lc}let t=S>>(o-=8);if(t=new Uint8Array([t])[0],r.value+t>e)return null;const q=L[r.value-1];for(;t-- >0;)L[r.value++]=q}else{if(!(r.value<e))return null;L[r.value++]=t}return{c:S,lc:o}}const g=new Array(59);function N(t,q,S,o,B,z){const L=q;let r=0,e=0;for(;o<=B;o++){if(L.value-q.value>S)return;let C=A(6,r,e,t,L);const Z=C.l;if(r=C.c,e=C.lc,z[o]=Z,Z==a){if(L.value-q.value>S)throw new Error("Error in HufUnpackEncTable");C=A(8,r,e,t,L);let Z=C.l+v;if(r=C.c,e=C.lc,o+Z>B+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)z[o++]=0;o--}else if(Z>=I){let t=Z-I+2;if(o+t>B+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)z[o++]=0;o--}}!function(t){for(let S=0;S<=58;++S)g[S]=0;for(let S=0;S<i;++S)g[t[S]]+=1;let q=0;for(let S=58;S>0;--S){const t=q+g[S]>>1;g[S]=q,q=t}for(let S=0;S<i;++S){const q=t[S];q>0&&(t[S]=q|g[q]++<<6)}}(z)}function T(t){return 63&t}function w(t){return t>>6}function E(t,q,S,o,B,z){const L=S.value,r=U(q,S),e=U(q,S);S.value+=4;const C=U(q,S);if(S.value+=4,r<0||r>=i||e<0||e>=i)throw new Error("Wrong HUF_ENCSIZE");const Z=new Array(i),b=new Array(h);!function(t){for(let q=0;q<h;q++)t[q]={},t[q].len=0,t[q].lit=0,t[q].p=null}(b);if(N(t,S,o-(S.value-L),r,e,Z),C>8*(o-(S.value-L)))throw new Error("Wrong hufUncompress");!function(t,q,S,o){for(;q<=S;q++){const S=w(t[q]),B=T(t[q]);if(S>>B)throw new Error("Invalid table entry");if(B>O){const t=o[S>>B-O];if(t.len)throw new Error("Invalid table entry");if(t.lit++,t.p){const q=t.p;t.p=new Array(t.lit);for(let S=0;S<t.lit-1;++S)t.p[S]=q[S]}else t.p=new Array(1);t.p[t.lit-1]=q}else if(B){let t=0;for(let z=1<<O-B;z>0;z--){const z=o[(S<<O-B)+t];if(z.len||z.p)throw new Error("Invalid table entry");z.len=B,z.lit=q,t++}}}}(Z,r,e,b),function(t,q,S,o,B,z,L,r,e){let C=0,Z=0;const b=L,i=Math.trunc(o.value+(B+7)/8);for(;o.value<i;){let B=c(C,Z,S,o);for(C=B.c,Z=B.lc;Z>=O;){const L=q[C>>Z-O&l];if(L.len){Z-=L.len;const t=s(L.lit,z,C,Z,S,o,r,e,b);t&&(C=t.c,Z=t.lc)}else{if(!L.p)throw new Error("hufDecode issues");let q;for(q=0;q<L.lit;q++){const O=T(t[L.p[q]]);for(;Z<O&&o.value<i;)B=c(C,Z,S,o),C=B.c,Z=B.lc;if(Z>=O&&w(t[L.p[q]])==(C>>Z-O&(1<<O)-1)){Z-=O;const t=s(L.p[q],z,C,Z,S,o,r,e,b);t&&(C=t.c,Z=t.lc);break}}if(q==L.lit)throw new Error("HufDecode issues")}}}const h=8-B&7;for(C>>=h,Z-=h;Z>0;){const t=q[C<<O-Z&l];if(!t.len)throw new Error("HufDecode issues");{Z-=t.len;const q=s(t.lit,z,C,Z,S,o,r,e,b);q&&(C=q.c,Z=q.lc)}}}(Z,b,t,S,C,e,z,B,{value:0})}function p(t){return 65535&t}function P(t){const q=p(t);return q>32767?q-65536:q}function F(t,q){const S=P(t),o=P(q),B=S+(1&o)+(o>>1);return{a:B,b:B-o}}function d(t,q){const S=p(t),o=p(q),B=S-(o>>1)&m;return{a:o+B-D&m,b:B}}function R(t,q,S,o,B,z,L){const r=L<16384,e=S>B?B:S;let C,Z,b=1;for(;b<=e;)b<<=1;for(b>>=1,C=b,b>>=1;b>=1;){Z=0;const L=Z+z*(B-C),e=z*b,O=z*C,i=o*b,h=o*C;let l,I,a,v;for(;Z<=L;Z+=O){let B=Z;const z=Z+o*(S-C);for(;B<=z;B+=h){const S=B+i,o=B+e,z=o+i;if(r){let L=F(t[B+q],t[o+q]);l=L.a,a=L.b,L=F(t[S+q],t[z+q]),I=L.a,v=L.b,L=F(l,I),t[B+q]=L.a,t[S+q]=L.b,L=F(a,v),t[o+q]=L.a,t[z+q]=L.b}else{let L=d(t[B+q],t[o+q]);l=L.a,a=L.b,L=d(t[S+q],t[z+q]),I=L.a,v=L.b,L=d(l,I),t[B+q]=L.a,t[S+q]=L.b,L=d(a,v),t[o+q]=L.a,t[z+q]=L.b}}if(S&b){const S=B+e;let o;o=r?F(t[B+q],t[S+q]):d(t[B+q],t[S+q]),l=o.a,t[S+q]=o.b,t[B+q]=l}}if(B&b){let B=Z;const z=Z+o*(S-C);for(;B<=z;B+=h){const S=B+i;let o;o=r?F(t[B+q],t[S+q]):d(t[B+q],t[S+q]),l=o.a,t[S+q]=o.b,t[B+q]=l}}C=b,b>>=1}return Z}function tt(t){return new DataView(t.array.buffer,t.offset.value,t.size)}function qt(t){const q=t.viewer.buffer.slice(t.offset.value,t.offset.value+t.size),S=new Uint8Array(function(t){let q=t.byteLength;const S=[];let o=0;const B=new DataView(t);for(;q>0;){const t=B.getInt8(o++);if(t<0){const z=-t;q-=z+1;for(let t=0;t<z;t++)S.push(B.getUint8(o++))}else{const z=t;q-=2;const L=B.getUint8(o++);for(let t=0;t<z+1;t++)S.push(L)}}return S}(q)),o=new Uint8Array(S.length);return n(S),u(S,o),new DataView(o.buffer)}function St(t){const q=t.array.slice(t.offset.value,t.offset.value+t.size),S=fflate.unzlibSync(q),o=new Uint8Array(S.length);return n(S),u(S,o),new DataView(o.buffer)}function ot(t){const q=t.array.slice(t.offset.value,t.offset.value+t.size),S=fflate.unzlibSync(q),o=t.lines*t.channels*t.width,B=1==t.type?new Uint16Array(o):new Uint32Array(o);let z=0,L=0;const r=new Array(4);for(let e=0;e<t.lines;e++)for(let q=0;q<t.channels;q++){let q=0;switch(t.type){case 1:r[0]=z,r[1]=r[0]+t.width,z=r[1]+t.width;for(let o=0;o<t.width;++o){q+=S[r[0]++]<<8|S[r[1]++],B[L]=q,L++}break;case 2:r[0]=z,r[1]=r[0]+t.width,r[2]=r[1]+t.width,z=r[2]+t.width;for(let o=0;o<t.width;++o){q+=S[r[0]++]<<24|S[r[1]++]<<16|S[r[2]++]<<8,B[L]=q,L++}}}return new DataView(B.buffer)}function Bt(t){const q=t.viewer,S={value:t.offset.value},o=new Uint16Array(t.width*t.scanlineBlockSize*(t.channels*t.type)),B=new Uint8Array(b);let z=0;const L=new Array(t.channels);for(let e=0;e<t.channels;e++)L[e]={},L[e].start=z,L[e].end=L[e].start,L[e].nx=t.width,L[e].ny=t.lines,L[e].size=t.type,z+=L[e].nx*L[e].ny*L[e].size;const r=j(q,S),C=j(q,S);if(C>=b)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(r<=C)for(let e=0;e<C-r+1;e++)B[e+r]=H(q,S);const O=new Uint16Array(Z),i=function(t,q){let S=0;for(let B=0;B<Z;++B)(0==B||t[B>>3]&1<<(7&B))&&(q[S++]=B);const o=S-1;for(;S<Z;)q[S++]=0;return o}(B,O),h=U(q,S);E(t.array,q,S,h,o,z);for(let e=0;e<t.channels;++e){const t=L[e];for(let q=0;q<L[e].size;++q)R(o,t.start+q,t.nx,t.size,t.ny,t.nx*t.size,i)}!function(t,q,S){for(let o=0;o<S;++o)q[o]=t[q[o]]}(O,o,z);let l=0;const I=new Uint8Array(o.buffer.byteLength);for(let Z=0;Z<t.lines;Z++)for(let q=0;q<t.channels;q++){const t=L[q],S=t.nx*t.size,B=new Uint8Array(o.buffer,t.end*e,S*e);I.set(B,l),l+=S*e,t.end+=S}return new DataView(I.buffer)}var zt,Lt=S(490);!function(t){t[t.Float=0]="Float",t[t.HalfFloat=1]="HalfFloat"}(zt||(zt={}));class rt{}async function et(t,q,S,o){const B={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:S,width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,channels:t.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(t.compression){case M.NO_COMPRESSION:B.lines=1,B.uncompress=tt;break;case M.RLE_COMPRESSION:B.lines=1,B.uncompress=qt;break;case M.ZIPS_COMPRESSION:B.lines=1,B.uncompress=St,await Lt.f.LoadScriptAsync(rt.FFLATEUrl);break;case M.ZIP_COMPRESSION:B.lines=16,B.uncompress=St,await Lt.f.LoadScriptAsync(rt.FFLATEUrl);break;case M.PIZ_COMPRESSION:B.lines=32,B.uncompress=Bt;break;case M.PXR24_COMPRESSION:B.lines=16,B.uncompress=ot,await Lt.f.LoadScriptAsync(rt.FFLATEUrl);break;default:throw new Error(M[t.compression]+" is unsupported")}B.scanlineBlockSize=B.lines;const z={};for(const L of t.channels)switch(L.name){case"R":case"G":case"B":case"A":case"Y":z[L.name]=!0,B.type=L.pixelType}let r=!1;if(z.R&&z.G&&z.B&&z.A)B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(z.R&&z.G&&z.B)r=!0,B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(z.R&&z.G)B.outputChannels=2,B.decodeChannels={R:0,G:1};else if(z.R)B.outputChannels=1,B.decodeChannels={R:0};else{if(!z.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");B.outputChannels=1,B.decodeChannels={Y:0}}if(1===B.type)switch(o){case zt.Float:B.getter=X,B.inputSize=e;break;case zt.HalfFloat:B.getter=j,B.inputSize=e}else{if(2!==B.type)throw new Error("Unsupported pixelType "+B.type+" for "+t.compression);switch(o){case zt.Float:B.getter=K,B.inputSize=L;break;case zt.HalfFloat:B.getter=G,B.inputSize=L}}B.blockCount=B.height/B.scanlineBlockSize;for(let L=0;L<B.blockCount;L++)Q(q,S);const C=B.width*B.height*B.outputChannels;switch(o){case zt.Float:B.byteArray=new Float32Array(C),B.textureType=1,r&&B.byteArray.fill(1,0,C);break;case zt.HalfFloat:B.byteArray=new Uint16Array(C),B.textureType=2,r&&B.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+o)}let Z=0;for(const L of t.channels)void 0!==B.decodeChannels[L.name]&&(B.channelLineOffsets[L.name]=Z*B.width),Z+=2*L.pixelType;return B.bytesPerLine=B.width*Z,B.outLineWidth=B.width*B.outputChannels,"INCREASING_Y"===t.lineOrder?B.scanOrder=t=>t:B.scanOrder=t=>B.height-1-t,4==B.outputChannels?(B.format=5,B.linearSpace=!0):(B.format=6,B.linearSpace=!1),B}function Ct(t,q,S,o){const B={value:0};for(let z=0;z<t.height/t.scanlineBlockSize;z++){const L=J(S,o)-q.dataWindow.yMin;t.size=U(S,o),t.lines=L+t.scanlineBlockSize>t.height?t.height-L:t.scanlineBlockSize;const r=t.size<t.lines*t.bytesPerLine&&t.uncompress?t.uncompress(t):tt(t);o.value+=t.size;for(let S=0;S<t.scanlineBlockSize;S++){const o=z*t.scanlineBlockSize,L=S+t.scanOrder(o);if(L>=t.height)continue;const e=S*t.bytesPerLine,C=(t.height-1-L)*t.outLineWidth;for(let S=0;S<t.channels;S++){const o=q.channels[S].name,z=t.channelLineOffsets[o],L=t.decodeChannels[o];if(void 0!==L){B.value=e+z;for(let q=0;q<t.width;q++){const S=C+q*t.outputChannels+L;t.byteArray&&(t.byteArray[S]=t.getter(r,B))}}}}}}rt.DefaultOutputType=zt.HalfFloat,rt.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Zt{constructor(){this.supportCascades=!1}loadCubeData(t,q,S,o,B){throw".exr not supported in Cube."}loadData(t,q,S){const B=new DataView(t.buffer),z={value:0},L=f(B,z);et(L,B,z,rt.DefaultOutputType).then((t=>{Ct(t,L,B,z);const o=L.dataWindow.xMax-L.dataWindow.xMin+1,r=L.dataWindow.yMax-L.dataWindow.yMin+1;S(o,r,q.generateMipMaps,!1,(()=>{const S=q.getEngine();q.format=L.format,q.type=t.textureType,q.invertY=!1,q._gammaSpace=!L.linearSpace,t.byteArray&&S._uploadDataToTextureDirectly(q,t.byteArray,0,0,void 0,!0)}))})).catch((t=>{o.c.Error("Failed to load EXR texture: ",t)}))}}async function bt(t){const q=new DataView(t),S={value:0},B=f(q,S);try{const t=await et(B,q,S,zt.Float);return Ct(t,B,q,S),t.byteArray?{width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,data:new Float32Array(t.byteArray)}:(o.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(z){o.c.Error("Failed to load EXR data: ",z)}return{width:0,height:0,data:null}}}}]);