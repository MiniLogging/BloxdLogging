"use strict";(self.c2c3ycupenc=self.c2c3ycupenc||[]).push([[17],{11722:(c,r,D)=>{D.r(r),D.d(r,{Xr:()=>E,Xa:()=>m,TmpColors:()=>Y});var W=D(11694),B=D(11637),t=D(11687),u=D(11696);function a(c){return Math.pow(c,t.k)}function H(c){return c<=.04045?.0773993808*c:Math.pow(.947867299*(c+.055),2.4)}function x(c){return Math.pow(c,t.g)}function M(c){return c<=.0031308?12.92*c:1.055*Math.pow(c,.41666)-.055}class E{constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=c,this.g=r,this.b=D}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Xr"}getHashCode(){let c=255*this.r|0;return c=397*c^255*this.g,c=397*c^255*this.b,c}toArray(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c[r]=this.r,c[r+1]=this.g,c[r+2]=this.b,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E.FromArrayToRef(c,r,this),this}toColor4(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new m(this.r,this.g,this.b,c)}Ma(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(c){return new E(this.r*c.r,this.g*c.g,this.b*c.b)}multiplyToRef(c,r){return r.r=this.r*c.r,r.g=this.g*c.g,r.b=this.b*c.b,r}multiplyInPlace(c){return this.r*=c.r,this.g*=c.g,this.b*=c.b,this}multiplyByFloats(c,r,D){return new E(this.r*c,this.g*r,this.b*D)}divide(c){throw new ReferenceError("Can not divide a color")}divideToRef(c,r){throw new ReferenceError("Can not divide a color")}divideInPlace(c){throw new ReferenceError("Can not divide a color")}minimizeInPlace(c){return this.minimizeInPlaceFromFloats(c.r,c.g,c.b)}maximizeInPlace(c){return this.maximizeInPlaceFromFloats(c.r,c.g,c.b)}minimizeInPlaceFromFloats(c,r,D){return this.r=Math.min(c,this.r),this.g=Math.min(r,this.g),this.b=Math.min(D,this.b),this}maximizeInPlaceFromFloats(c,r,D){return this.r=Math.max(c,this.r),this.g=Math.max(r,this.g),this.b=Math.max(D,this.b),this}floorToRef(c){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(c){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(c){return c&&this.r===c.r&&this.g===c.g&&this.b===c.b}equalsFloats(c,r,D){return this.equalsToFloats(c,r,D)}equalsToFloats(c,r,D){return this.r===c&&this.g===r&&this.b===D}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return(0,u.WithinEpsilon)(this.r,c.r,r)&&(0,u.WithinEpsilon)(this.g,c.g,r)&&(0,u.WithinEpsilon)(this.b,c.b,r)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(c){throw new ReferenceError("Can not negate a color")}scale(c){return new E(this.r*c,this.g*c,this.b*c)}scaleInPlace(c){return this.r*=c,this.g*=c,this.b*=c,this}scaleToRef(c,r){return r.r=this.r*c,r.g=this.g*c,r.b=this.b*c,r}scaleAndAddToRef(c,r){return r.r+=this.r*c,r.g+=this.g*c,r.b+=this.b*c,r}clampToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.r=(0,u.Clamp)(this.r,c,r),D.g=(0,u.Clamp)(this.g,c,r),D.b=(0,u.Clamp)(this.b,c,r),D}add(c){return new E(this.r+c.r,this.g+c.g,this.b+c.b)}addInPlace(c){return this.r+=c.r,this.g+=c.g,this.b+=c.b,this}addInPlaceFromFloats(c,r,D){return this.r+=c,this.g+=r,this.b+=D,this}addToRef(c,r){return r.r=this.r+c.r,r.g=this.g+c.g,r.b=this.b+c.b,r}Jr(c){return new E(this.r-c.r,this.g-c.g,this.b-c.b)}subtractToRef(c,r){return r.r=this.r-c.r,r.g=this.g-c.g,r.b=this.b-c.b,r}BE(c){return this.r-=c.r,this.g-=c.g,this.b-=c.b,this}subtractFromFloats(c,r,D){return new E(this.r-c,this.g-r,this.b-D)}subtractFromFloatsToRef(c,r,D,W){return W.r=this.r-c,W.g=this.g-r,W.b=this.b-D,W}clone(){return new E(this.r,this.g,this.b)}t(c){return this.r=c.r,this.g=c.g,this.b=c.b,this}Ja(c,r,D){return this.r=c,this.g=r,this.b=D,this}set(c,r,D){return this.Ja(c,r,D)}ja(c){return this.r=this.g=this.b=c,this}toHexString(){const c=Math.round(255*this.r),r=Math.round(255*this.g),D=Math.round(255*this.b);return"#"+(0,u.ToHex)(c)+(0,u.ToHex)(r)+(0,u.ToHex)(D)}fromHexString(c){return"#"!==c.substring(0,1)||7!==c.length||(this.r=parseInt(c.substring(1,3),16)/255,this.g=parseInt(c.substring(3,5),16)/255,this.b=parseInt(c.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new E)}toHSVToRef(c){const r=this.r,D=this.g,W=this.b,B=Math.max(r,D,W),t=Math.min(r,D,W);let u=0,a=0;const H=B,x=B-t;return 0!==B&&(a=x/B),B!=t&&(B==r?(u=(D-W)/x,D<W&&(u+=6)):B==D?u=(W-r)/x+2:B==W&&(u=(r-D)/x+4),u*=60),c.r=u,c.g=a,c.b=H,c}toLinearSpace(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new E;return this.toLinearSpaceToRef(r,c),r}toLinearSpaceToRef(c){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(c.r=H(this.r),c.g=H(this.g),c.b=H(this.b)):(c.r=a(this.r),c.g=a(this.g),c.b=a(this.b)),this}toGammaSpace(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new E;return this.toGammaSpaceToRef(r,c),r}toGammaSpaceToRef(c){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(c.r=M(this.r),c.g=M(this.g),c.b=M(this.b)):(c.r=x(this.r),c.g=x(this.g),c.b=x(this.b)),this}static HSVtoRGBToRef(c,r,D,W){const B=D*r,t=c/60,u=B*(1-Math.abs(t%2-1));let a=0,H=0,x=0;t>=0&&t<=1?(a=B,H=u):t>=1&&t<=2?(a=u,H=B):t>=2&&t<=3?(H=B,x=u):t>=3&&t<=4?(H=u,x=B):t>=4&&t<=5?(a=u,x=B):t>=5&&t<=6&&(a=B,x=u);const M=D-B;return W.r=a+M,W.g=H+M,W.b=x+M,W}static FromHSV(c,r,D){const W=new E(0,0,0);return E.HSVtoRGBToRef(c,r,D,W),W}static FromHexString(c){return new E(0,0,0).fromHexString(c)}static er(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(c[r],c[r+1],c[r+2])}static FromArrayToRef(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2?arguments[2]:void 0;D.r=c[r],D.g=c[r+1],D.b=c[r+2]}static FromInts(c,r,D){return new E(c/255,r/255,D/255)}static Lerp(c,r,D){const W=new E(0,0,0);return E.LerpToRef(c,r,D,W),W}static LerpToRef(c,r,D,W){W.r=c.r+(r.r-c.r)*D,W.g=c.g+(r.g-c.g)*D,W.b=c.b+(r.b-c.b)*D}static Hermite(c,r,D,W,B){const t=B*B,u=B*t,a=2*u-3*t+1,H=-2*u+3*t,x=u-2*t+B,M=u-t,m=c.r*a+D.r*H+r.r*x+W.r*M,Y=c.g*a+D.g*H+r.g*x+W.g*M,v=c.b*a+D.b*H+r.b*x+W.b*M;return new E(m,Y,v)}static Hermite1stDerivative(c,r,D,W,B){const t=E.Black();return this.Hermite1stDerivativeToRef(c,r,D,W,B,t),t}static Hermite1stDerivativeToRef(c,r,D,W,B,t){const u=B*B;t.r=6*(u-B)*c.r+(3*u-4*B+1)*r.r+6*(-u+B)*D.r+(3*u-2*B)*W.r,t.g=6*(u-B)*c.g+(3*u-4*B+1)*r.g+6*(-u+B)*D.g+(3*u-2*B)*W.g,t.b=6*(u-B)*c.b+(3*u-4*B+1)*r.b+6*(-u+B)*D.b+(3*u-2*B)*W.b}static Red(){return new E(1,0,0)}static Green(){return new E(0,1,0)}static Blue(){return new E(0,0,1)}static Black(){return new E(0,0,0)}static get BlackReadOnly(){return E._BlackReadOnly}static White(){return new E(1,1,1)}static Purple(){return new E(.5,0,.5)}static Magenta(){return new E(1,0,1)}static Yellow(){return new E(1,1,0)}static Gray(){return new E(.5,.5,.5)}static Teal(){return new E(0,1,1)}static Random(){return new E(Math.random(),Math.random(),Math.random())}}E._V8PerformanceHack=new E(.5,.5,.5),E._BlackReadOnly=E.Black(),Object.defineProperties(E.prototype,{dimension:{value:[3]},rank:{value:1}});class m{constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,W=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=c,this.g=r,this.b=D,this.a=W}Ma(){return[this.r,this.g,this.b,this.a]}toArray(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c[r]=this.r,c[r+1]=this.g,c[r+2]=this.b,c[r+3]=this.a,this}jD(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=c[r],this.g=c[r+1],this.b=c[r+2],this.a=c[r+3],this}equals(c){return c&&this.r===c.r&&this.g===c.g&&this.b===c.b&&this.a===c.a}add(c){return new m(this.r+c.r,this.g+c.g,this.b+c.b,this.a+c.a)}addToRef(c,r){return r.r=this.r+c.r,r.g=this.g+c.g,r.b=this.b+c.b,r.a=this.a+c.a,r}addInPlace(c){return this.r+=c.r,this.g+=c.g,this.b+=c.b,this.a+=c.a,this}addInPlaceFromFloats(c,r,D,W){return this.r+=c,this.g+=r,this.b+=D,this.a+=W,this}Jr(c){return new m(this.r-c.r,this.g-c.g,this.b-c.b,this.a-c.a)}subtractToRef(c,r){return r.r=this.r-c.r,r.g=this.g-c.g,r.b=this.b-c.b,r.a=this.a-c.a,r}BE(c){return this.r-=c.r,this.g-=c.g,this.b-=c.b,this.a-=c.a,this}subtractFromFloats(c,r,D,W){return new m(this.r-c,this.g-r,this.b-D,this.a-W)}subtractFromFloatsToRef(c,r,D,W,B){return B.r=this.r-c,B.g=this.g-r,B.b=this.b-D,B.a=this.a-W,B}scale(c){return new m(this.r*c,this.g*c,this.b*c,this.a*c)}scaleInPlace(c){return this.r*=c,this.g*=c,this.b*=c,this.a*=c,this}scaleToRef(c,r){return r.r=this.r*c,r.g=this.g*c,r.b=this.b*c,r.a=this.a*c,r}scaleAndAddToRef(c,r){return r.r+=this.r*c,r.g+=this.g*c,r.b+=this.b*c,r.a+=this.a*c,r}clampToRef(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.r=(0,u.Clamp)(this.r,c,r),D.g=(0,u.Clamp)(this.g,c,r),D.b=(0,u.Clamp)(this.b,c,r),D.a=(0,u.Clamp)(this.a,c,r),D}multiply(c){return new m(this.r*c.r,this.g*c.g,this.b*c.b,this.a*c.a)}multiplyToRef(c,r){return r.r=this.r*c.r,r.g=this.g*c.g,r.b=this.b*c.b,r.a=this.a*c.a,r}multiplyInPlace(c){return this.r*=c.r,this.g*=c.g,this.b*=c.b,this.a*=c.a,this}multiplyByFloats(c,r,D,W){return new m(this.r*c,this.g*r,this.b*D,this.a*W)}divide(c){throw new ReferenceError("Can not divide a color")}divideToRef(c,r){throw new ReferenceError("Can not divide a color")}divideInPlace(c){throw new ReferenceError("Can not divide a color")}minimizeInPlace(c){return this.r=Math.min(this.r,c.r),this.g=Math.min(this.g,c.g),this.b=Math.min(this.b,c.b),this.a=Math.min(this.a,c.a),this}maximizeInPlace(c){return this.r=Math.max(this.r,c.r),this.g=Math.max(this.g,c.g),this.b=Math.max(this.b,c.b),this.a=Math.max(this.a,c.a),this}minimizeInPlaceFromFloats(c,r,D,W){return this.r=Math.min(c,this.r),this.g=Math.min(r,this.g),this.b=Math.min(D,this.b),this.a=Math.min(W,this.a),this}maximizeInPlaceFromFloats(c,r,D,W){return this.r=Math.max(c,this.r),this.g=Math.max(r,this.g),this.b=Math.max(D,this.b),this.a=Math.max(W,this.a),this}floorToRef(c){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(c){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(c){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return(0,u.WithinEpsilon)(this.r,c.r,r)&&(0,u.WithinEpsilon)(this.g,c.g,r)&&(0,u.WithinEpsilon)(this.b,c.b,r)&&(0,u.WithinEpsilon)(this.a,c.a,r)}equalsToFloats(c,r,D,W){return this.r===c&&this.g===r&&this.b===D&&this.a===W}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Xa"}getHashCode(){let c=255*this.r|0;return c=397*c^255*this.g,c=397*c^255*this.b,c=397*c^255*this.a,c}clone(){return(new m).t(this)}t(c){return this.r=c.r,this.g=c.g,this.b=c.b,this.a=c.a,this}Ja(c,r,D,W){return this.r=c,this.g=r,this.b=D,this.a=W,this}set(c,r,D,W){return this.Ja(c,r,D,W)}ja(c){return this.r=this.g=this.b=this.a=c,this}toHexString(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=Math.round(255*this.r),D=Math.round(255*this.g),W=Math.round(255*this.b);if(c)return"#"+(0,u.ToHex)(r)+(0,u.ToHex)(D)+(0,u.ToHex)(W);const B=Math.round(255*this.a);return"#"+(0,u.ToHex)(r)+(0,u.ToHex)(D)+(0,u.ToHex)(W)+(0,u.ToHex)(B)}fromHexString(c){return"#"!==c.substring(0,1)||9!==c.length&&7!==c.length||(this.r=parseInt(c.substring(1,3),16)/255,this.g=parseInt(c.substring(3,5),16)/255,this.b=parseInt(c.substring(5,7),16)/255,9===c.length&&(this.a=parseInt(c.substring(7,9),16)/255)),this}toLinearSpace(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new m;return this.toLinearSpaceToRef(r,c),r}toLinearSpaceToRef(c){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(c.r=H(this.r),c.g=H(this.g),c.b=H(this.b)):(c.r=a(this.r),c.g=a(this.g),c.b=a(this.b)),c.a=this.a,this}toGammaSpace(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const r=new m;return this.toGammaSpaceToRef(r,c),r}toGammaSpaceToRef(c){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(c.r=M(this.r),c.g=M(this.g),c.b=M(this.b)):(c.r=x(this.r),c.g=x(this.g),c.b=x(this.b)),c.a=this.a,this}static FromHexString(c){return"#"!==c.substring(0,1)||9!==c.length&&7!==c.length?new m(0,0,0,0):new m(0,0,0,1).fromHexString(c)}static Lerp(c,r,D){return m.LerpToRef(c,r,D,new m)}static LerpToRef(c,r,D,W){return W.r=c.r+(r.r-c.r)*D,W.g=c.g+(r.g-c.g)*D,W.b=c.b+(r.b-c.b)*D,W.a=c.a+(r.a-c.a)*D,W}static Hermite(c,r,D,W,B){const t=B*B,u=B*t,a=2*u-3*t+1,H=-2*u+3*t,x=u-2*t+B,M=u-t,E=c.r*a+D.r*H+r.r*x+W.r*M,Y=c.g*a+D.g*H+r.g*x+W.g*M,v=c.b*a+D.b*H+r.b*x+W.b*M,k=c.a*a+D.a*H+r.a*x+W.a*M;return new m(E,Y,v,k)}static Hermite1stDerivative(c,r,D,W,B){const t=new m;return this.Hermite1stDerivativeToRef(c,r,D,W,B,t),t}static Hermite1stDerivativeToRef(c,r,D,W,B,t){const u=B*B;t.r=6*(u-B)*c.r+(3*u-4*B+1)*r.r+6*(-u+B)*D.r+(3*u-2*B)*W.r,t.g=6*(u-B)*c.g+(3*u-4*B+1)*r.g+6*(-u+B)*D.g+(3*u-2*B)*W.g,t.b=6*(u-B)*c.b+(3*u-4*B+1)*r.b+6*(-u+B)*D.b+(3*u-2*B)*W.b,t.a=6*(u-B)*c.a+(3*u-4*B+1)*r.a+6*(-u+B)*D.a+(3*u-2*B)*W.a}static FromColor3(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new m(c.r,c.g,c.b,r)}static er(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new m(c[r],c[r+1],c[r+2],c[r+3])}static FromArrayToRef(c){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2?arguments[2]:void 0;D.r=c[r],D.g=c[r+1],D.b=c[r+2],D.a=c[r+3]}static FromInts(c,r,D,W){return new m(c/255,r/255,D/255,W/255)}static CheckColors4(c,r){if(c.length===3*r){const r=[];for(let D=0;D<c.length;D+=3){const W=D/3*4;r[W]=c[D],r[W+1]=c[D+1],r[W+2]=c[D+2],r[W+3]=1}return r}return c}}m._V8PerformanceHack=new m(.5,.5,.5,.5),Object.defineProperties(m.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{}Y.Xr=(0,W.d)(3,E.Black),Y.Xa=(0,W.d)(3,(()=>new m(0,0,0,0))),(0,B.e)("BABYLON.Color3",E),(0,B.e)("BABYLON.Color4",m)}}]);