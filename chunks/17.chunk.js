"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{11228:(P,f,Y)=>{Y.r(f),Y.d(f,{Df:()=>y,ro:()=>r,TmpColors:()=>i});var C=Y(11196),q=Y(11134),m=Y(11187),L=Y(11198);function o(P){return Math.pow(P,m.k)}function w(P){return P<=.04045?.0773993808*P:Math.pow(.947867299*(P+.055),2.4)}function d(P){return Math.pow(P,m.i)}function R(P){return P<=.0031308?12.92*P:1.055*Math.pow(P,.41666)-.055}class y{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=P,this.g=f,this.b=Y}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Df"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P}toArray(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[f]=this.r,P[f+1]=this.g,P[f+2]=this.b,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(P,f,this),this}toColor4(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new r(this.r,this.g,this.b,P)}If(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(P){return new y(this.r*P.r,this.g*P.g,this.b*P.b)}multiplyToRef(P,f){return f.r=this.r*P.r,f.g=this.g*P.g,f.b=this.b*P.b,f}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this}multiplyByFloats(P,f,Y){return new y(this.r*P,this.g*f,this.b*Y)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,f){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.r,P.g,P.b)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.r,P.g,P.b)}minimizeInPlaceFromFloats(P,f,Y){return this.r=Math.min(P,this.r),this.g=Math.min(f,this.g),this.b=Math.min(Y,this.b),this}maximizeInPlaceFromFloats(P,f,Y){return this.r=Math.max(P,this.r),this.g=Math.max(f,this.g),this.b=Math.max(Y,this.b),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b}equalsFloats(P,f,Y){return this.equalsToFloats(P,f,Y)}equalsToFloats(P,f,Y){return this.r===P&&this.g===f&&this.b===Y}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.c;return(0,L.WithinEpsilon)(this.r,P.r,f)&&(0,L.WithinEpsilon)(this.g,P.g,f)&&(0,L.WithinEpsilon)(this.b,P.b,f)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}scale(P){return new y(this.r*P,this.g*P,this.b*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this}scaleToRef(P,f){return f.r=this.r*P,f.g=this.g*P,f.b=this.b*P,f}scaleAndAddToRef(P,f){return f.r+=this.r*P,f.g+=this.g*P,f.b+=this.b*P,f}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0;return Y.r=(0,L.Clamp)(this.r,P,f),Y.g=(0,L.Clamp)(this.g,P,f),Y.b=(0,L.Clamp)(this.b,P,f),Y}add(P){return new y(this.r+P.r,this.g+P.g,this.b+P.b)}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this}addInPlaceFromFloats(P,f,Y){return this.r+=P,this.g+=f,this.b+=Y,this}addToRef(P,f){return f.r=this.r+P.r,f.g=this.g+P.g,f.b=this.b+P.b,f}nf(P){return new y(this.r-P.r,this.g-P.g,this.b-P.b)}subtractToRef(P,f){return f.r=this.r-P.r,f.g=this.g-P.g,f.b=this.b-P.b,f}Ly(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this}subtractFromFloats(P,f,Y){return new y(this.r-P,this.g-f,this.b-Y)}subtractFromFloatsToRef(P,f,Y,C){return C.r=this.r-P,C.g=this.g-f,C.b=this.b-Y,C}clone(){return new y(this.r,this.g,this.b)}q(P){return this.r=P.r,this.g=P.g,this.b=P.b,this}do(P,f,Y){return this.r=P,this.g=f,this.b=Y,this}set(P,f,Y){return this.do(P,f,Y)}yo(P){return this.r=this.g=this.b=P,this}toHexString(){const P=Math.round(255*this.r),f=Math.round(255*this.g),Y=Math.round(255*this.b);return"#"+(0,L.ToHex)(P)+(0,L.ToHex)(f)+(0,L.ToHex)(Y)}fromHexString(P){return"#"!==P.substring(0,1)||7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new y)}toHSVToRef(P){const f=this.r,Y=this.g,C=this.b,q=Math.max(f,Y,C),m=Math.min(f,Y,C);let L=0,o=0;const w=q,d=q-m;return 0!==q&&(o=d/q),q!=m&&(q==f?(L=(Y-C)/d,Y<C&&(L+=6)):q==Y?L=(C-f)/d+2:q==C&&(L=(f-Y)/d+4),L*=60),P.r=L,P.g=o,P.b=w,P}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new y;return this.toLinearSpaceToRef(f,P),f}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=w(this.r),P.g=w(this.g),P.b=w(this.b)):(P.r=o(this.r),P.g=o(this.g),P.b=o(this.b)),this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new y;return this.toGammaSpaceToRef(f,P),f}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=R(this.r),P.g=R(this.g),P.b=R(this.b)):(P.r=d(this.r),P.g=d(this.g),P.b=d(this.b)),this}static HSVtoRGBToRef(P,f,Y,C){const q=Y*f,m=P/60,L=q*(1-Math.abs(m%2-1));let o=0,w=0,d=0;m>=0&&m<=1?(o=q,w=L):m>=1&&m<=2?(o=L,w=q):m>=2&&m<=3?(w=q,d=L):m>=3&&m<=4?(w=L,d=q):m>=4&&m<=5?(o=L,d=q):m>=5&&m<=6&&(o=q,d=L);const R=Y-q;return C.r=o+R,C.g=w+R,C.b=d+R,C}static FromHSV(P,f,Y){const C=new y(0,0,0);return y.HSVtoRGBToRef(P,f,Y,C),C}static FromHexString(P){return new y(0,0,0).fromHexString(P)}static ef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(P[f],P[f+1],P[f+2])}static FromArrayToRef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2?arguments[2]:void 0;Y.r=P[f],Y.g=P[f+1],Y.b=P[f+2]}static FromInts(P,f,Y){return new y(P/255,f/255,Y/255)}static Lerp(P,f,Y){const C=new y(0,0,0);return y.LerpToRef(P,f,Y,C),C}static LerpToRef(P,f,Y,C){C.r=P.r+(f.r-P.r)*Y,C.g=P.g+(f.g-P.g)*Y,C.b=P.b+(f.b-P.b)*Y}static Hermite(P,f,Y,C,q){const m=q*q,L=q*m,o=2*L-3*m+1,w=-2*L+3*m,d=L-2*m+q,R=L-m,r=P.r*o+Y.r*w+f.r*d+C.r*R,i=P.g*o+Y.g*w+f.g*d+C.g*R,u=P.b*o+Y.b*w+f.b*d+C.b*R;return new y(r,i,u)}static Hermite1stDerivative(P,f,Y,C,q){const m=y.Black();return this.Hermite1stDerivativeToRef(P,f,Y,C,q,m),m}static Hermite1stDerivativeToRef(P,f,Y,C,q,m){const L=q*q;m.r=6*(L-q)*P.r+(3*L-4*q+1)*f.r+6*(-L+q)*Y.r+(3*L-2*q)*C.r,m.g=6*(L-q)*P.g+(3*L-4*q+1)*f.g+6*(-L+q)*Y.g+(3*L-2*q)*C.g,m.b=6*(L-q)*P.b+(3*L-4*q+1)*f.b+6*(-L+q)*Y.b+(3*L-2*q)*C.b}static Red(){return new y(1,0,0)}static Green(){return new y(0,1,0)}static Blue(){return new y(0,0,1)}static Black(){return new y(0,0,0)}static get BlackReadOnly(){return y._BlackReadOnly}static White(){return new y(1,1,1)}static Purple(){return new y(.5,0,.5)}static Magenta(){return new y(1,0,1)}static Yellow(){return new y(1,1,0)}static Gray(){return new y(.5,.5,.5)}static Teal(){return new y(0,1,1)}static Random(){return new y(Math.random(),Math.random(),Math.random())}}y._V8PerformanceHack=new y(.5,.5,.5),y._BlackReadOnly=y.Black(),Object.defineProperties(y.prototype,{dimension:{value:[3]},rank:{value:1}});class r{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=P,this.g=f,this.b=Y,this.a=C}If(){return[this.r,this.g,this.b,this.a]}toArray(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[f]=this.r,P[f+1]=this.g,P[f+2]=this.b,P[f+3]=this.a,this}jY(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=P[f],this.g=P[f+1],this.b=P[f+2],this.a=P[f+3],this}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b&&this.a===P.a}add(P){return new r(this.r+P.r,this.g+P.g,this.b+P.b,this.a+P.a)}addToRef(P,f){return f.r=this.r+P.r,f.g=this.g+P.g,f.b=this.b+P.b,f.a=this.a+P.a,f}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this.a+=P.a,this}addInPlaceFromFloats(P,f,Y,C){return this.r+=P,this.g+=f,this.b+=Y,this.a+=C,this}nf(P){return new r(this.r-P.r,this.g-P.g,this.b-P.b,this.a-P.a)}subtractToRef(P,f){return f.r=this.r-P.r,f.g=this.g-P.g,f.b=this.b-P.b,f.a=this.a-P.a,f}Ly(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this.a-=P.a,this}subtractFromFloats(P,f,Y,C){return new r(this.r-P,this.g-f,this.b-Y,this.a-C)}subtractFromFloatsToRef(P,f,Y,C,q){return q.r=this.r-P,q.g=this.g-f,q.b=this.b-Y,q.a=this.a-C,q}scale(P){return new r(this.r*P,this.g*P,this.b*P,this.a*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this.a*=P,this}scaleToRef(P,f){return f.r=this.r*P,f.g=this.g*P,f.b=this.b*P,f.a=this.a*P,f}scaleAndAddToRef(P,f){return f.r+=this.r*P,f.g+=this.g*P,f.b+=this.b*P,f.a+=this.a*P,f}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Y=arguments.length>2?arguments[2]:void 0;return Y.r=(0,L.Clamp)(this.r,P,f),Y.g=(0,L.Clamp)(this.g,P,f),Y.b=(0,L.Clamp)(this.b,P,f),Y.a=(0,L.Clamp)(this.a,P,f),Y}multiply(P){return new r(this.r*P.r,this.g*P.g,this.b*P.b,this.a*P.a)}multiplyToRef(P,f){return f.r=this.r*P.r,f.g=this.g*P.g,f.b=this.b*P.b,f.a=this.a*P.a,f}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this.a*=P.a,this}multiplyByFloats(P,f,Y,C){return new r(this.r*P,this.g*f,this.b*Y,this.a*C)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,f){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.r=Math.min(this.r,P.r),this.g=Math.min(this.g,P.g),this.b=Math.min(this.b,P.b),this.a=Math.min(this.a,P.a),this}maximizeInPlace(P){return this.r=Math.max(this.r,P.r),this.g=Math.max(this.g,P.g),this.b=Math.max(this.b,P.b),this.a=Math.max(this.a,P.a),this}minimizeInPlaceFromFloats(P,f,Y,C){return this.r=Math.min(P,this.r),this.g=Math.min(f,this.g),this.b=Math.min(Y,this.b),this.a=Math.min(C,this.a),this}maximizeInPlaceFromFloats(P,f,Y,C){return this.r=Math.max(P,this.r),this.g=Math.max(f,this.g),this.b=Math.max(Y,this.b),this.a=Math.max(C,this.a),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:m.c;return(0,L.WithinEpsilon)(this.r,P.r,f)&&(0,L.WithinEpsilon)(this.g,P.g,f)&&(0,L.WithinEpsilon)(this.b,P.b,f)&&(0,L.WithinEpsilon)(this.a,P.a,f)}equalsToFloats(P,f,Y,C){return this.r===P&&this.g===f&&this.b===Y&&this.a===C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ro"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P=397*P^255*this.a,P}clone(){return(new r).q(this)}q(P){return this.r=P.r,this.g=P.g,this.b=P.b,this.a=P.a,this}do(P,f,Y,C){return this.r=P,this.g=f,this.b=Y,this.a=C,this}set(P,f,Y,C){return this.do(P,f,Y,C)}yo(P){return this.r=this.g=this.b=this.a=P,this}toHexString(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=Math.round(255*this.r),Y=Math.round(255*this.g),C=Math.round(255*this.b);if(P)return"#"+(0,L.ToHex)(f)+(0,L.ToHex)(Y)+(0,L.ToHex)(C);const q=Math.round(255*this.a);return"#"+(0,L.ToHex)(f)+(0,L.ToHex)(Y)+(0,L.ToHex)(C)+(0,L.ToHex)(q)}fromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255,9===P.length&&(this.a=parseInt(P.substring(7,9),16)/255)),this}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new r;return this.toLinearSpaceToRef(f,P),f}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=w(this.r),P.g=w(this.g),P.b=w(this.b)):(P.r=o(this.r),P.g=o(this.g),P.b=o(this.b)),P.a=this.a,this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=new r;return this.toGammaSpaceToRef(f,P),f}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=R(this.r),P.g=R(this.g),P.b=R(this.b)):(P.r=d(this.r),P.g=d(this.g),P.b=d(this.b)),P.a=this.a,this}static FromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length?new r(0,0,0,0):new r(0,0,0,1).fromHexString(P)}static Lerp(P,f,Y){return r.LerpToRef(P,f,Y,new r)}static LerpToRef(P,f,Y,C){return C.r=P.r+(f.r-P.r)*Y,C.g=P.g+(f.g-P.g)*Y,C.b=P.b+(f.b-P.b)*Y,C.a=P.a+(f.a-P.a)*Y,C}static Hermite(P,f,Y,C,q){const m=q*q,L=q*m,o=2*L-3*m+1,w=-2*L+3*m,d=L-2*m+q,R=L-m,y=P.r*o+Y.r*w+f.r*d+C.r*R,i=P.g*o+Y.g*w+f.g*d+C.g*R,u=P.b*o+Y.b*w+f.b*d+C.b*R,g=P.a*o+Y.a*w+f.a*d+C.a*R;return new r(y,i,u,g)}static Hermite1stDerivative(P,f,Y,C,q){const m=new r;return this.Hermite1stDerivativeToRef(P,f,Y,C,q,m),m}static Hermite1stDerivativeToRef(P,f,Y,C,q,m){const L=q*q;m.r=6*(L-q)*P.r+(3*L-4*q+1)*f.r+6*(-L+q)*Y.r+(3*L-2*q)*C.r,m.g=6*(L-q)*P.g+(3*L-4*q+1)*f.g+6*(-L+q)*Y.g+(3*L-2*q)*C.g,m.b=6*(L-q)*P.b+(3*L-4*q+1)*f.b+6*(-L+q)*Y.b+(3*L-2*q)*C.b,m.a=6*(L-q)*P.a+(3*L-4*q+1)*f.a+6*(-L+q)*Y.a+(3*L-2*q)*C.a}static FromColor3(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r(P.r,P.g,P.b,f)}static ef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(P[f],P[f+1],P[f+2],P[f+3])}static FromArrayToRef(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2?arguments[2]:void 0;Y.r=P[f],Y.g=P[f+1],Y.b=P[f+2],Y.a=P[f+3]}static FromInts(P,f,Y,C){return new r(P/255,f/255,Y/255,C/255)}static CheckColors4(P,f){if(P.length===3*f){const f=[];for(let Y=0;Y<P.length;Y+=3){const C=Y/3*4;f[C]=P[Y],f[C+1]=P[Y+1],f[C+2]=P[Y+2],f[C+3]=1}return f}return P}}r._V8PerformanceHack=new r(.5,.5,.5,.5),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class i{}i.Df=(0,C.d)(3,y.Black),i.ro=(0,C.d)(3,(()=>new r(0,0,0,0))),(0,q.d)("BABYLON.Color3",y),(0,q.d)("BABYLON.Color4",r)}}]);