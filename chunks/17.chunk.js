"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[17],{11417:(B,E,v)=>{v.r(E),v.d(E,{gE:()=>y,gc:()=>Q,TmpColors:()=>P});var z=v(11385),o=v(11345),q=v(11382),c=v(11394);function S(B){return Math.pow(B,q.j)}function x(B){return B<=.04045?.0773993808*B:Math.pow(.947867299*(B+.055),2.4)}function D(B){return Math.pow(B,q.i)}function h(B){return B<=.0031308?12.92*B:1.055*Math.pow(B,.41666)-.055}class y{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=B,this.g=E,this.b=v}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"gE"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B}toArray(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[E]=this.r,B[E+1]=this.g,B[E+2]=this.b,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y.FromArrayToRef(B,E,this),this}toColor4(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new Q(this.r,this.g,this.b,B)}cc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(B){return new y(this.r*B.r,this.g*B.g,this.b*B.b)}multiplyToRef(B,E){return E.r=this.r*B.r,E.g=this.g*B.g,E.b=this.b*B.b,E}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this}multiplyByFloats(B,E,v){return new y(this.r*B,this.g*E,this.b*v)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,E){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.r,B.g,B.b)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.r,B.g,B.b)}minimizeInPlaceFromFloats(B,E,v){return this.r=Math.min(B,this.r),this.g=Math.min(E,this.g),this.b=Math.min(v,this.b),this}maximizeInPlaceFromFloats(B,E,v){return this.r=Math.max(B,this.r),this.g=Math.max(E,this.g),this.b=Math.max(v,this.b),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b}equalsFloats(B,E,v){return this.equalsToFloats(B,E,v)}equalsToFloats(B,E,v){return this.r===B&&this.g===E&&this.b===v}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.e;return(0,c.WithinEpsilon)(this.r,B.r,E)&&(0,c.WithinEpsilon)(this.g,B.g,E)&&(0,c.WithinEpsilon)(this.b,B.b,E)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}scale(B){return new y(this.r*B,this.g*B,this.b*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this}scaleToRef(B,E){return E.r=this.r*B,E.g=this.g*B,E.b=this.b*B,E}scaleAndAddToRef(B,E){return E.r+=this.r*B,E.g+=this.g*B,E.b+=this.b*B,E}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,v=arguments.length>2?arguments[2]:void 0;return v.r=(0,c.Clamp)(this.r,B,E),v.g=(0,c.Clamp)(this.g,B,E),v.b=(0,c.Clamp)(this.b,B,E),v}add(B){return new y(this.r+B.r,this.g+B.g,this.b+B.b)}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this}addInPlaceFromFloats(B,E,v){return this.r+=B,this.g+=E,this.b+=v,this}addToRef(B,E){return E.r=this.r+B.r,E.g=this.g+B.g,E.b=this.b+B.b,E}YE(B){return new y(this.r-B.r,this.g-B.g,this.b-B.b)}subtractToRef(B,E){return E.r=this.r-B.r,E.g=this.g-B.g,E.b=this.b-B.b,E}wy(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this}subtractFromFloats(B,E,v){return new y(this.r-B,this.g-E,this.b-v)}subtractFromFloatsToRef(B,E,v,z){return z.r=this.r-B,z.g=this.g-E,z.b=this.b-v,z}clone(){return new y(this.r,this.g,this.b)}S(B){return this.r=B.r,this.g=B.g,this.b=B.b,this}Yc(B,E,v){return this.r=B,this.g=E,this.b=v,this}set(B,E,v){return this.Yc(B,E,v)}mc(B){return this.r=this.g=this.b=B,this}toHexString(){const B=Math.round(255*this.r),E=Math.round(255*this.g),v=Math.round(255*this.b);return"#"+(0,c.ToHex)(B)+(0,c.ToHex)(E)+(0,c.ToHex)(v)}fromHexString(B){return"#"!==B.substring(0,1)||7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new y)}toHSVToRef(B){const E=this.r,v=this.g,z=this.b,o=Math.max(E,v,z),q=Math.min(E,v,z);let c=0,S=0;const x=o,D=o-q;return 0!==o&&(S=D/o),o!=q&&(o==E?(c=(v-z)/D,v<z&&(c+=6)):o==v?c=(z-E)/D+2:o==z&&(c=(E-v)/D+4),c*=60),B.r=c,B.g=S,B.b=x,B}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new y;return this.toLinearSpaceToRef(E,B),E}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=x(this.r),B.g=x(this.g),B.b=x(this.b)):(B.r=S(this.r),B.g=S(this.g),B.b=S(this.b)),this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new y;return this.toGammaSpaceToRef(E,B),E}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=h(this.r),B.g=h(this.g),B.b=h(this.b)):(B.r=D(this.r),B.g=D(this.g),B.b=D(this.b)),this}static HSVtoRGBToRef(B,E,v,z){const o=v*E,q=B/60,c=o*(1-Math.abs(q%2-1));let S=0,x=0,D=0;q>=0&&q<=1?(S=o,x=c):q>=1&&q<=2?(S=c,x=o):q>=2&&q<=3?(x=o,D=c):q>=3&&q<=4?(x=c,D=o):q>=4&&q<=5?(S=c,D=o):q>=5&&q<=6&&(S=o,D=c);const h=v-o;return z.r=S+h,z.g=x+h,z.b=D+h,z}static FromHSV(B,E,v){const z=new y(0,0,0);return y.HSVtoRGBToRef(B,E,v,z),z}static FromHexString(B){return new y(0,0,0).fromHexString(B)}static VE(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(B[E],B[E+1],B[E+2])}static FromArrayToRef(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2?arguments[2]:void 0;v.r=B[E],v.g=B[E+1],v.b=B[E+2]}static FromInts(B,E,v){return new y(B/255,E/255,v/255)}static Lerp(B,E,v){const z=new y(0,0,0);return y.LerpToRef(B,E,v,z),z}static LerpToRef(B,E,v,z){z.r=B.r+(E.r-B.r)*v,z.g=B.g+(E.g-B.g)*v,z.b=B.b+(E.b-B.b)*v}static Hermite(B,E,v,z,o){const q=o*o,c=o*q,S=2*c-3*q+1,x=-2*c+3*q,D=c-2*q+o,h=c-q,Q=B.r*S+v.r*x+E.r*D+z.r*h,P=B.g*S+v.g*x+E.g*D+z.g*h,G=B.b*S+v.b*x+E.b*D+z.b*h;return new y(Q,P,G)}static Hermite1stDerivative(B,E,v,z,o){const q=y.Black();return this.Hermite1stDerivativeToRef(B,E,v,z,o,q),q}static Hermite1stDerivativeToRef(B,E,v,z,o,q){const c=o*o;q.r=6*(c-o)*B.r+(3*c-4*o+1)*E.r+6*(-c+o)*v.r+(3*c-2*o)*z.r,q.g=6*(c-o)*B.g+(3*c-4*o+1)*E.g+6*(-c+o)*v.g+(3*c-2*o)*z.g,q.b=6*(c-o)*B.b+(3*c-4*o+1)*E.b+6*(-c+o)*v.b+(3*c-2*o)*z.b}static Red(){return new y(1,0,0)}static Green(){return new y(0,1,0)}static Blue(){return new y(0,0,1)}static Black(){return new y(0,0,0)}static get BlackReadOnly(){return y._BlackReadOnly}static White(){return new y(1,1,1)}static Purple(){return new y(.5,0,.5)}static Magenta(){return new y(1,0,1)}static Yellow(){return new y(1,1,0)}static Gray(){return new y(.5,.5,.5)}static Teal(){return new y(0,1,1)}static Random(){return new y(Math.random(),Math.random(),Math.random())}}y._V8PerformanceHack=new y(.5,.5,.5),y._BlackReadOnly=y.Black(),Object.defineProperties(y.prototype,{dimension:{value:[3]},rank:{value:1}});class Q{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=B,this.g=E,this.b=v,this.a=z}cc(){return[this.r,this.g,this.b,this.a]}toArray(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[E]=this.r,B[E+1]=this.g,B[E+2]=this.b,B[E+3]=this.a,this}Qv(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=B[E],this.g=B[E+1],this.b=B[E+2],this.a=B[E+3],this}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b&&this.a===B.a}add(B){return new Q(this.r+B.r,this.g+B.g,this.b+B.b,this.a+B.a)}addToRef(B,E){return E.r=this.r+B.r,E.g=this.g+B.g,E.b=this.b+B.b,E.a=this.a+B.a,E}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this.a+=B.a,this}addInPlaceFromFloats(B,E,v,z){return this.r+=B,this.g+=E,this.b+=v,this.a+=z,this}YE(B){return new Q(this.r-B.r,this.g-B.g,this.b-B.b,this.a-B.a)}subtractToRef(B,E){return E.r=this.r-B.r,E.g=this.g-B.g,E.b=this.b-B.b,E.a=this.a-B.a,E}wy(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this.a-=B.a,this}subtractFromFloats(B,E,v,z){return new Q(this.r-B,this.g-E,this.b-v,this.a-z)}subtractFromFloatsToRef(B,E,v,z,o){return o.r=this.r-B,o.g=this.g-E,o.b=this.b-v,o.a=this.a-z,o}scale(B){return new Q(this.r*B,this.g*B,this.b*B,this.a*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this.a*=B,this}scaleToRef(B,E){return E.r=this.r*B,E.g=this.g*B,E.b=this.b*B,E.a=this.a*B,E}scaleAndAddToRef(B,E){return E.r+=this.r*B,E.g+=this.g*B,E.b+=this.b*B,E.a+=this.a*B,E}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,v=arguments.length>2?arguments[2]:void 0;return v.r=(0,c.Clamp)(this.r,B,E),v.g=(0,c.Clamp)(this.g,B,E),v.b=(0,c.Clamp)(this.b,B,E),v.a=(0,c.Clamp)(this.a,B,E),v}multiply(B){return new Q(this.r*B.r,this.g*B.g,this.b*B.b,this.a*B.a)}multiplyToRef(B,E){return E.r=this.r*B.r,E.g=this.g*B.g,E.b=this.b*B.b,E.a=this.a*B.a,E}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this.a*=B.a,this}multiplyByFloats(B,E,v,z){return new Q(this.r*B,this.g*E,this.b*v,this.a*z)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,E){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.r=Math.min(this.r,B.r),this.g=Math.min(this.g,B.g),this.b=Math.min(this.b,B.b),this.a=Math.min(this.a,B.a),this}maximizeInPlace(B){return this.r=Math.max(this.r,B.r),this.g=Math.max(this.g,B.g),this.b=Math.max(this.b,B.b),this.a=Math.max(this.a,B.a),this}minimizeInPlaceFromFloats(B,E,v,z){return this.r=Math.min(B,this.r),this.g=Math.min(E,this.g),this.b=Math.min(v,this.b),this.a=Math.min(z,this.a),this}maximizeInPlaceFromFloats(B,E,v,z){return this.r=Math.max(B,this.r),this.g=Math.max(E,this.g),this.b=Math.max(v,this.b),this.a=Math.max(z,this.a),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.e;return(0,c.WithinEpsilon)(this.r,B.r,E)&&(0,c.WithinEpsilon)(this.g,B.g,E)&&(0,c.WithinEpsilon)(this.b,B.b,E)&&(0,c.WithinEpsilon)(this.a,B.a,E)}equalsToFloats(B,E,v,z){return this.r===B&&this.g===E&&this.b===v&&this.a===z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"gc"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B=397*B^255*this.a,B}clone(){return(new Q).S(this)}S(B){return this.r=B.r,this.g=B.g,this.b=B.b,this.a=B.a,this}Yc(B,E,v,z){return this.r=B,this.g=E,this.b=v,this.a=z,this}set(B,E,v,z){return this.Yc(B,E,v,z)}mc(B){return this.r=this.g=this.b=this.a=B,this}toHexString(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=Math.round(255*this.r),v=Math.round(255*this.g),z=Math.round(255*this.b);if(B)return"#"+(0,c.ToHex)(E)+(0,c.ToHex)(v)+(0,c.ToHex)(z);const o=Math.round(255*this.a);return"#"+(0,c.ToHex)(E)+(0,c.ToHex)(v)+(0,c.ToHex)(z)+(0,c.ToHex)(o)}fromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255,9===B.length&&(this.a=parseInt(B.substring(7,9),16)/255)),this}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new Q;return this.toLinearSpaceToRef(E,B),E}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=x(this.r),B.g=x(this.g),B.b=x(this.b)):(B.r=S(this.r),B.g=S(this.g),B.b=S(this.b)),B.a=this.a,this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new Q;return this.toGammaSpaceToRef(E,B),E}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=h(this.r),B.g=h(this.g),B.b=h(this.b)):(B.r=D(this.r),B.g=D(this.g),B.b=D(this.b)),B.a=this.a,this}static FromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length?new Q(0,0,0,0):new Q(0,0,0,1).fromHexString(B)}static Lerp(B,E,v){return Q.LerpToRef(B,E,v,new Q)}static LerpToRef(B,E,v,z){return z.r=B.r+(E.r-B.r)*v,z.g=B.g+(E.g-B.g)*v,z.b=B.b+(E.b-B.b)*v,z.a=B.a+(E.a-B.a)*v,z}static Hermite(B,E,v,z,o){const q=o*o,c=o*q,S=2*c-3*q+1,x=-2*c+3*q,D=c-2*q+o,h=c-q,y=B.r*S+v.r*x+E.r*D+z.r*h,P=B.g*S+v.g*x+E.g*D+z.g*h,G=B.b*S+v.b*x+E.b*D+z.b*h,Y=B.a*S+v.a*x+E.a*D+z.a*h;return new Q(y,P,G,Y)}static Hermite1stDerivative(B,E,v,z,o){const q=new Q;return this.Hermite1stDerivativeToRef(B,E,v,z,o,q),q}static Hermite1stDerivativeToRef(B,E,v,z,o,q){const c=o*o;q.r=6*(c-o)*B.r+(3*c-4*o+1)*E.r+6*(-c+o)*v.r+(3*c-2*o)*z.r,q.g=6*(c-o)*B.g+(3*c-4*o+1)*E.g+6*(-c+o)*v.g+(3*c-2*o)*z.g,q.b=6*(c-o)*B.b+(3*c-4*o+1)*E.b+6*(-c+o)*v.b+(3*c-2*o)*z.b,q.a=6*(c-o)*B.a+(3*c-4*o+1)*E.a+6*(-c+o)*v.a+(3*c-2*o)*z.a}static FromColor3(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q(B.r,B.g,B.b,E)}static VE(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(B[E],B[E+1],B[E+2],B[E+3])}static FromArrayToRef(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,v=arguments.length>2?arguments[2]:void 0;v.r=B[E],v.g=B[E+1],v.b=B[E+2],v.a=B[E+3]}static FromInts(B,E,v,z){return new Q(B/255,E/255,v/255,z/255)}static CheckColors4(B,E){if(B.length===3*E){const E=[];for(let v=0;v<B.length;v+=3){const z=v/3*4;E[z]=B[v],E[z+1]=B[v+1],E[z+2]=B[v+2],E[z+3]=1}return E}return B}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class P{}P.gE=(0,z.b)(3,y.Black),P.gc=(0,z.b)(3,(()=>new Q(0,0,0,0))),(0,o.f)("BABYLON.Color3",y),(0,o.f)("BABYLON.Color4",Q)}}]);