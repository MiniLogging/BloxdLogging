"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[17],{11262:(G,A,j)=>{j.r(A),j.d(A,{nA:()=>H,Xs:()=>F,TmpColors:()=>R});var u=j(11228),k=j(11181),B=j(11222),x=j(11237);function s(G){return Math.pow(G,B.j)}function O(G){return G<=.04045?.0773993808*G:Math.pow(.947867299*(G+.055),2.4)}function d(G){return Math.pow(G,B.h)}function h(G){return G<=.0031308?12.92*G:1.055*Math.pow(G,.41666)-.055}class H{constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=G,this.g=A,this.b=j}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"nA"}getHashCode(){let G=255*this.r|0;return G=397*G^255*this.g,G=397*G^255*this.b,G}toArray(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G[A]=this.r,G[A+1]=this.g,G[A+2]=this.b,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H.FromArrayToRef(G,A,this),this}toColor4(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new F(this.r,this.g,this.b,G)}hs(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(G){return new H(this.r*G.r,this.g*G.g,this.b*G.b)}multiplyToRef(G,A){return A.r=this.r*G.r,A.g=this.g*G.g,A.b=this.b*G.b,A}multiplyInPlace(G){return this.r*=G.r,this.g*=G.g,this.b*=G.b,this}multiplyByFloats(G,A,j){return new H(this.r*G,this.g*A,this.b*j)}divide(G){throw new ReferenceError("Can not divide a color")}divideToRef(G,A){throw new ReferenceError("Can not divide a color")}divideInPlace(G){throw new ReferenceError("Can not divide a color")}minimizeInPlace(G){return this.minimizeInPlaceFromFloats(G.r,G.g,G.b)}maximizeInPlace(G){return this.maximizeInPlaceFromFloats(G.r,G.g,G.b)}minimizeInPlaceFromFloats(G,A,j){return this.r=Math.min(G,this.r),this.g=Math.min(A,this.g),this.b=Math.min(j,this.b),this}maximizeInPlaceFromFloats(G,A,j){return this.r=Math.max(G,this.r),this.g=Math.max(A,this.g),this.b=Math.max(j,this.b),this}floorToRef(G){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(G){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(G){return G&&this.r===G.r&&this.g===G.g&&this.b===G.b}equalsFloats(G,A,j){return this.equalsToFloats(G,A,j)}equalsToFloats(G,A,j){return this.r===G&&this.g===A&&this.b===j}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,x.WithinEpsilon)(this.r,G.r,A)&&(0,x.WithinEpsilon)(this.g,G.g,A)&&(0,x.WithinEpsilon)(this.b,G.b,A)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(G){throw new ReferenceError("Can not negate a color")}scale(G){return new H(this.r*G,this.g*G,this.b*G)}scaleInPlace(G){return this.r*=G,this.g*=G,this.b*=G,this}scaleToRef(G,A){return A.r=this.r*G,A.g=this.g*G,A.b=this.b*G,A}scaleAndAddToRef(G,A){return A.r+=this.r*G,A.g+=this.g*G,A.b+=this.b*G,A}clampToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.r=(0,x.Clamp)(this.r,G,A),j.g=(0,x.Clamp)(this.g,G,A),j.b=(0,x.Clamp)(this.b,G,A),j}add(G){return new H(this.r+G.r,this.g+G.g,this.b+G.b)}addInPlace(G){return this.r+=G.r,this.g+=G.g,this.b+=G.b,this}addInPlaceFromFloats(G,A,j){return this.r+=G,this.g+=A,this.b+=j,this}addToRef(G,A){return A.r=this.r+G.r,A.g=this.g+G.g,A.b=this.b+G.b,A}CA(G){return new H(this.r-G.r,this.g-G.g,this.b-G.b)}subtractToRef(G,A){return A.r=this.r-G.r,A.g=this.g-G.g,A.b=this.b-G.b,A}LH(G){return this.r-=G.r,this.g-=G.g,this.b-=G.b,this}subtractFromFloats(G,A,j){return new H(this.r-G,this.g-A,this.b-j)}subtractFromFloatsToRef(G,A,j,u){return u.r=this.r-G,u.g=this.g-A,u.b=this.b-j,u}clone(){return new H(this.r,this.g,this.b)}B(G){return this.r=G.r,this.g=G.g,this.b=G.b,this}Ys(G,A,j){return this.r=G,this.g=A,this.b=j,this}set(G,A,j){return this.Ys(G,A,j)}Qs(G){return this.r=this.g=this.b=G,this}toHexString(){const G=Math.round(255*this.r),A=Math.round(255*this.g),j=Math.round(255*this.b);return"#"+(0,x.ToHex)(G)+(0,x.ToHex)(A)+(0,x.ToHex)(j)}fromHexString(G){return"#"!==G.substring(0,1)||7!==G.length||(this.r=parseInt(G.substring(1,3),16)/255,this.g=parseInt(G.substring(3,5),16)/255,this.b=parseInt(G.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new H)}toHSVToRef(G){const A=this.r,j=this.g,u=this.b,k=Math.max(A,j,u),B=Math.min(A,j,u);let x=0,s=0;const O=k,d=k-B;return 0!==k&&(s=d/k),k!=B&&(k==A?(x=(j-u)/d,j<u&&(x+=6)):k==j?x=(u-A)/d+2:k==u&&(x=(A-j)/d+4),x*=60),G.r=x,G.g=s,G.b=O,G}toLinearSpace(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new H;return this.toLinearSpaceToRef(A,G),A}toLinearSpaceToRef(G){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(G.r=O(this.r),G.g=O(this.g),G.b=O(this.b)):(G.r=s(this.r),G.g=s(this.g),G.b=s(this.b)),this}toGammaSpace(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new H;return this.toGammaSpaceToRef(A,G),A}toGammaSpaceToRef(G){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(G.r=h(this.r),G.g=h(this.g),G.b=h(this.b)):(G.r=d(this.r),G.g=d(this.g),G.b=d(this.b)),this}static HSVtoRGBToRef(G,A,j,u){const k=j*A,B=G/60,x=k*(1-Math.abs(B%2-1));let s=0,O=0,d=0;B>=0&&B<=1?(s=k,O=x):B>=1&&B<=2?(s=x,O=k):B>=2&&B<=3?(O=k,d=x):B>=3&&B<=4?(O=x,d=k):B>=4&&B<=5?(s=x,d=k):B>=5&&B<=6&&(s=k,d=x);const h=j-k;return u.r=s+h,u.g=O+h,u.b=d+h,u}static FromHSV(G,A,j){const u=new H(0,0,0);return H.HSVtoRGBToRef(G,A,j,u),u}static FromHexString(G){return new H(0,0,0).fromHexString(G)}static QA(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(G[A],G[A+1],G[A+2])}static FromArrayToRef(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2?arguments[2]:void 0;j.r=G[A],j.g=G[A+1],j.b=G[A+2]}static FromInts(G,A,j){return new H(G/255,A/255,j/255)}static Lerp(G,A,j){const u=new H(0,0,0);return H.LerpToRef(G,A,j,u),u}static LerpToRef(G,A,j,u){u.r=G.r+(A.r-G.r)*j,u.g=G.g+(A.g-G.g)*j,u.b=G.b+(A.b-G.b)*j}static Hermite(G,A,j,u,k){const B=k*k,x=k*B,s=2*x-3*B+1,O=-2*x+3*B,d=x-2*B+k,h=x-B,F=G.r*s+j.r*O+A.r*d+u.r*h,R=G.g*s+j.g*O+A.g*d+u.g*h,U=G.b*s+j.b*O+A.b*d+u.b*h;return new H(F,R,U)}static Hermite1stDerivative(G,A,j,u,k){const B=H.Black();return this.Hermite1stDerivativeToRef(G,A,j,u,k,B),B}static Hermite1stDerivativeToRef(G,A,j,u,k,B){const x=k*k;B.r=6*(x-k)*G.r+(3*x-4*k+1)*A.r+6*(-x+k)*j.r+(3*x-2*k)*u.r,B.g=6*(x-k)*G.g+(3*x-4*k+1)*A.g+6*(-x+k)*j.g+(3*x-2*k)*u.g,B.b=6*(x-k)*G.b+(3*x-4*k+1)*A.b+6*(-x+k)*j.b+(3*x-2*k)*u.b}static Red(){return new H(1,0,0)}static Green(){return new H(0,1,0)}static Blue(){return new H(0,0,1)}static Black(){return new H(0,0,0)}static get BlackReadOnly(){return H._BlackReadOnly}static White(){return new H(1,1,1)}static Purple(){return new H(.5,0,.5)}static Magenta(){return new H(1,0,1)}static Yellow(){return new H(1,1,0)}static Gray(){return new H(.5,.5,.5)}static Teal(){return new H(0,1,1)}static Random(){return new H(Math.random(),Math.random(),Math.random())}}H._V8PerformanceHack=new H(.5,.5,.5),H._BlackReadOnly=H.Black(),Object.defineProperties(H.prototype,{dimension:{value:[3]},rank:{value:1}});class F{constructor(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=G,this.g=A,this.b=j,this.a=u}hs(){return[this.r,this.g,this.b,this.a]}toArray(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G[A]=this.r,G[A+1]=this.g,G[A+2]=this.b,G[A+3]=this.a,this}Uj(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=G[A],this.g=G[A+1],this.b=G[A+2],this.a=G[A+3],this}equals(G){return G&&this.r===G.r&&this.g===G.g&&this.b===G.b&&this.a===G.a}add(G){return new F(this.r+G.r,this.g+G.g,this.b+G.b,this.a+G.a)}addToRef(G,A){return A.r=this.r+G.r,A.g=this.g+G.g,A.b=this.b+G.b,A.a=this.a+G.a,A}addInPlace(G){return this.r+=G.r,this.g+=G.g,this.b+=G.b,this.a+=G.a,this}addInPlaceFromFloats(G,A,j,u){return this.r+=G,this.g+=A,this.b+=j,this.a+=u,this}CA(G){return new F(this.r-G.r,this.g-G.g,this.b-G.b,this.a-G.a)}subtractToRef(G,A){return A.r=this.r-G.r,A.g=this.g-G.g,A.b=this.b-G.b,A.a=this.a-G.a,A}LH(G){return this.r-=G.r,this.g-=G.g,this.b-=G.b,this.a-=G.a,this}subtractFromFloats(G,A,j,u){return new F(this.r-G,this.g-A,this.b-j,this.a-u)}subtractFromFloatsToRef(G,A,j,u,k){return k.r=this.r-G,k.g=this.g-A,k.b=this.b-j,k.a=this.a-u,k}scale(G){return new F(this.r*G,this.g*G,this.b*G,this.a*G)}scaleInPlace(G){return this.r*=G,this.g*=G,this.b*=G,this.a*=G,this}scaleToRef(G,A){return A.r=this.r*G,A.g=this.g*G,A.b=this.b*G,A.a=this.a*G,A}scaleAndAddToRef(G,A){return A.r+=this.r*G,A.g+=this.g*G,A.b+=this.b*G,A.a+=this.a*G,A}clampToRef(){let G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.r=(0,x.Clamp)(this.r,G,A),j.g=(0,x.Clamp)(this.g,G,A),j.b=(0,x.Clamp)(this.b,G,A),j.a=(0,x.Clamp)(this.a,G,A),j}multiply(G){return new F(this.r*G.r,this.g*G.g,this.b*G.b,this.a*G.a)}multiplyToRef(G,A){return A.r=this.r*G.r,A.g=this.g*G.g,A.b=this.b*G.b,A.a=this.a*G.a,A}multiplyInPlace(G){return this.r*=G.r,this.g*=G.g,this.b*=G.b,this.a*=G.a,this}multiplyByFloats(G,A,j,u){return new F(this.r*G,this.g*A,this.b*j,this.a*u)}divide(G){throw new ReferenceError("Can not divide a color")}divideToRef(G,A){throw new ReferenceError("Can not divide a color")}divideInPlace(G){throw new ReferenceError("Can not divide a color")}minimizeInPlace(G){return this.r=Math.min(this.r,G.r),this.g=Math.min(this.g,G.g),this.b=Math.min(this.b,G.b),this.a=Math.min(this.a,G.a),this}maximizeInPlace(G){return this.r=Math.max(this.r,G.r),this.g=Math.max(this.g,G.g),this.b=Math.max(this.b,G.b),this.a=Math.max(this.a,G.a),this}minimizeInPlaceFromFloats(G,A,j,u){return this.r=Math.min(G,this.r),this.g=Math.min(A,this.g),this.b=Math.min(j,this.b),this.a=Math.min(u,this.a),this}maximizeInPlaceFromFloats(G,A,j,u){return this.r=Math.max(G,this.r),this.g=Math.max(A,this.g),this.b=Math.max(j,this.b),this.a=Math.max(u,this.a),this}floorToRef(G){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(G){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(G){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,x.WithinEpsilon)(this.r,G.r,A)&&(0,x.WithinEpsilon)(this.g,G.g,A)&&(0,x.WithinEpsilon)(this.b,G.b,A)&&(0,x.WithinEpsilon)(this.a,G.a,A)}equalsToFloats(G,A,j,u){return this.r===G&&this.g===A&&this.b===j&&this.a===u}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Xs"}getHashCode(){let G=255*this.r|0;return G=397*G^255*this.g,G=397*G^255*this.b,G=397*G^255*this.a,G}clone(){return(new F).B(this)}B(G){return this.r=G.r,this.g=G.g,this.b=G.b,this.a=G.a,this}Ys(G,A,j,u){return this.r=G,this.g=A,this.b=j,this.a=u,this}set(G,A,j,u){return this.Ys(G,A,j,u)}Qs(G){return this.r=this.g=this.b=this.a=G,this}toHexString(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=Math.round(255*this.r),j=Math.round(255*this.g),u=Math.round(255*this.b);if(G)return"#"+(0,x.ToHex)(A)+(0,x.ToHex)(j)+(0,x.ToHex)(u);const k=Math.round(255*this.a);return"#"+(0,x.ToHex)(A)+(0,x.ToHex)(j)+(0,x.ToHex)(u)+(0,x.ToHex)(k)}fromHexString(G){return"#"!==G.substring(0,1)||9!==G.length&&7!==G.length||(this.r=parseInt(G.substring(1,3),16)/255,this.g=parseInt(G.substring(3,5),16)/255,this.b=parseInt(G.substring(5,7),16)/255,9===G.length&&(this.a=parseInt(G.substring(7,9),16)/255)),this}toLinearSpace(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new F;return this.toLinearSpaceToRef(A,G),A}toLinearSpaceToRef(G){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(G.r=O(this.r),G.g=O(this.g),G.b=O(this.b)):(G.r=s(this.r),G.g=s(this.g),G.b=s(this.b)),G.a=this.a,this}toGammaSpace(){let G=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new F;return this.toGammaSpaceToRef(A,G),A}toGammaSpaceToRef(G){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(G.r=h(this.r),G.g=h(this.g),G.b=h(this.b)):(G.r=d(this.r),G.g=d(this.g),G.b=d(this.b)),G.a=this.a,this}static FromHexString(G){return"#"!==G.substring(0,1)||9!==G.length&&7!==G.length?new F(0,0,0,0):new F(0,0,0,1).fromHexString(G)}static Lerp(G,A,j){return F.LerpToRef(G,A,j,new F)}static LerpToRef(G,A,j,u){return u.r=G.r+(A.r-G.r)*j,u.g=G.g+(A.g-G.g)*j,u.b=G.b+(A.b-G.b)*j,u.a=G.a+(A.a-G.a)*j,u}static Hermite(G,A,j,u,k){const B=k*k,x=k*B,s=2*x-3*B+1,O=-2*x+3*B,d=x-2*B+k,h=x-B,H=G.r*s+j.r*O+A.r*d+u.r*h,R=G.g*s+j.g*O+A.g*d+u.g*h,U=G.b*s+j.b*O+A.b*d+u.b*h,S=G.a*s+j.a*O+A.a*d+u.a*h;return new F(H,R,U,S)}static Hermite1stDerivative(G,A,j,u,k){const B=new F;return this.Hermite1stDerivativeToRef(G,A,j,u,k,B),B}static Hermite1stDerivativeToRef(G,A,j,u,k,B){const x=k*k;B.r=6*(x-k)*G.r+(3*x-4*k+1)*A.r+6*(-x+k)*j.r+(3*x-2*k)*u.r,B.g=6*(x-k)*G.g+(3*x-4*k+1)*A.g+6*(-x+k)*j.g+(3*x-2*k)*u.g,B.b=6*(x-k)*G.b+(3*x-4*k+1)*A.b+6*(-x+k)*j.b+(3*x-2*k)*u.b,B.a=6*(x-k)*G.a+(3*x-4*k+1)*A.a+6*(-x+k)*j.a+(3*x-2*k)*u.a}static FromColor3(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F(G.r,G.g,G.b,A)}static QA(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(G[A],G[A+1],G[A+2],G[A+3])}static FromArrayToRef(G){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2?arguments[2]:void 0;j.r=G[A],j.g=G[A+1],j.b=G[A+2],j.a=G[A+3]}static FromInts(G,A,j,u){return new F(G/255,A/255,j/255,u/255)}static CheckColors4(G,A){if(G.length===3*A){const A=[];for(let j=0;j<G.length;j+=3){const u=j/3*4;A[u]=G[j],A[u+1]=G[j+1],A[u+2]=G[j+2],A[u+3]=1}return A}return G}}F._V8PerformanceHack=new F(.5,.5,.5,.5),Object.defineProperties(F.prototype,{dimension:{value:[4]},rank:{value:1}});class R{}R.nA=(0,u.e)(3,H.Black),R.Xs=(0,u.e)(3,(()=>new F(0,0,0,0))),(0,k.h)("BABYLON.Color3",H),(0,k.h)("BABYLON.Color4",F)}}]);