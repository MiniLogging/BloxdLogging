"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2610:(Q,X,C)=>{C.r(X),C.d(X,{ReadExrDataAsync:()=>LQ,_ExrTextureLoader:()=>UQ});var l=C(501),h=C(690);const M=4,f=4,O=1,m=2,W=8,U=65536,L=U>>3,w=14,i=65537,a=1<<w,F=a-1,s=59,z=63,x=2+z-s;var r,P;!function(Q){Q[Q.NO_COMPRESSION=0]="NO_COMPRESSION",Q[Q.RLE_COMPRESSION=1]="RLE_COMPRESSION",Q[Q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Q[Q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Q[Q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Q[Q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(r||(r={})),function(Q){Q[Q.INCREASING_Y=0]="INCREASING_Y",Q[Q.DECREASING_Y=1]="DECREASING_Y"}(P||(P={}));const j=function(){const Q=new ArrayBuffer(4),X=new Float32Array(Q),C=new Uint32Array(Q),l=new Uint32Array(512),h=new Uint32Array(512);for(let m=0;m<256;++m){const Q=m-127;Q<-27?(l[m]=0,l[256|m]=32768,h[m]=24,h[256|m]=24):Q<-14?(l[m]=1024>>-Q-14,l[256|m]=1024>>-Q-14|32768,h[m]=-Q-1,h[256|m]=-Q-1):Q<=15?(l[m]=Q+15<<10,l[256|m]=Q+15<<10|32768,h[m]=13,h[256|m]=13):Q<128?(l[m]=31744,l[256|m]=64512,h[m]=24,h[256|m]=24):(l[m]=31744,l[256|m]=64512,h[m]=13,h[256|m]=13)}const M=new Uint32Array(2048),f=new Uint32Array(64),O=new Uint32Array(64);for(let m=1;m<1024;++m){let Q=m<<13,X=0;for(;0===(8388608&Q);)Q<<=1,X-=8388608;Q&=-8388609,X+=947912704,M[m]=Q|X}for(let m=1024;m<2048;++m)M[m]=939524096+(m-1024<<13);for(let m=1;m<31;++m)f[m]=m<<23;f[31]=1199570944,f[32]=2147483648;for(let m=33;m<63;++m)f[m]=2147483648+(m-32<<23);f[63]=3347054592;for(let m=1;m<64;++m)32!==m&&(O[m]=1024);return{floatView:X,uint32View:C,baseTable:l,shiftTable:h,mantissaTable:M,exponentTable:f,offsetTable:O}}();function v(Q,X){const C=new Uint8Array(Q);let l=0;for(;0!=C[X.value+l];)l+=1;const h=(new TextDecoder).decode(C.slice(X.value,X.value+l));return X.value=X.value+l+1,h}function Z(Q,X){const C=Q.getInt32(X.value,!0);return X.value+=M,C}function g(Q,X){const C=Q.getUint32(X.value,!0);return X.value+=M,C}function S(Q,X){const C=Q.getUint8(X.value);return X.value+=O,C}function e(Q,X){const C=Q.getUint16(X.value,!0);return X.value+=m,C}function k(Q,X){const C=Q[X.value];return X.value+=O,C}function R(Q,X){let C;return C="getBigInt64"in DataView.prototype?Number(Q.getBigInt64(X.value,!0)):Q.getUint32(X.value+4,!0)+Number(Q.getUint32(X.value,!0)<<32),X.value+=W,C}function H(Q,X){const C=Q.getFloat32(X.value,!0);return X.value+=f,C}function o(Q,X){return function(Q){const X=(31744&Q)>>10,C=1023&Q;return(Q>>15?-1:1)*(X?31===X?C?NaN:1/0:Math.pow(2,X-15)*(1+C/1024):C/1024*6103515625e-14)}(e(Q,X))}function T(Q,X){return function(Q){if(Math.abs(Q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Q=(0,h.Clamp)(Q,-65504,65504),j.floatView[0]=Q;const X=j.uint32View[0],C=X>>23&511;return j.baseTable[C]+((8388607&X)>>j.shiftTable[C])}(H(Q,X))}function Y(Q,X,C,l){switch(C){case"string":case"stringvector":case"iccProfile":return function(Q,X,C){const l=(new TextDecoder).decode(new Uint8Array(Q).slice(X.value,X.value+C));return X.value=X.value+C,l}(Q.buffer,X,l);case"chlist":return function(Q,X,C){const l=X.value,h=[];for(;X.value<l+C-1;){const C=v(Q.buffer,X),l=Z(Q,X),M=S(Q,X);X.value+=3;const f=Z(Q,X),O=Z(Q,X);h.push({name:C,pixelType:l,pLinear:M,xSampling:f,ySampling:O})}return X.value+=1,h}(Q,X,l);case"chromaticities":return function(Q,X){return{redX:H(Q,X),redY:H(Q,X),greenX:H(Q,X),greenY:H(Q,X),blueX:H(Q,X),blueY:H(Q,X),whiteX:H(Q,X),whiteY:H(Q,X)}}(Q,X);case"compression":return function(Q,X){return S(Q,X)}(Q,X);case"box2i":return function(Q,X){return{xMin:Z(Q,X),yMin:Z(Q,X),xMax:Z(Q,X),yMax:Z(Q,X)}}(Q,X);case"lineOrder":return function(Q,X){const C=S(Q,X);return P[C]}(Q,X);case"float":return H(Q,X);case"v2f":return function(Q,X){return[H(Q,X),H(Q,X)]}(Q,X);case"v3f":return function(Q,X){return[H(Q,X),H(Q,X),H(Q,X)]}(Q,X);case"int":return Z(Q,X);case"rational":return function(Q,X){return[Z(Q,X),g(Q,X)]}(Q,X);case"timecode":return function(Q,X){return[g(Q,X),g(Q,X)]}(Q,X);case"preview":return X.value+=l,"skipped";default:return void(X.value+=l)}}function J(Q){for(let X=1;X<Q.length;X++){const C=Q[X-1]+Q[X]-128;Q[X]=C}}function K(Q,X){let C=0,l=Math.floor((Q.length+1)/2),h=0;const M=Q.length-1;for(;!(h>M)&&(X[h++]=Q[C++],!(h>M));)X[h++]=Q[l++]}const N=20000630;function q(Q,X){if(Q.getUint32(0,!0)!=N)throw new Error("Incorrect OpenEXR format");const C=Q.getUint8(4),h=Q.getUint8(5),M={singleTile:!!(2&h),longName:!!(4&h),deepFormat:!!(8&h),multiPart:!!(16&h)};X.value=8;const f={};let O=!0;for(;O;){const C=v(Q.buffer,X);if(C){const h=v(Q.buffer,X),M=Y(Q,X,h,g(Q,X));void 0===M?l.c.Warn(`Unknown header attribute type ${h}'.`):f[C]=M}else O=!1}if(0!=(-5&h))throw new Error("Unsupported file format");return{version:C,spec:M,...f}}const n=32768,c=65535;function E(Q,X,C,l,h){for(;C<Q;)X=X<<8|k(l,h),C+=8;return{l:X>>(C-=Q)&(1<<Q)-1,c:X,lc:C}}function B(Q,X,C,l){return{c:Q=Q<<8|k(C,l),lc:X+=8}}function G(Q,X,C,l,h,M,f,O,m){if(Q==X){if(l<8){const Q=B(C,l,h,M);C=Q.c,l=Q.lc}let Q=C>>(l-=8);if(Q=new Uint8Array([Q])[0],O.value+Q>m)return null;const X=f[O.value-1];for(;Q-- >0;)f[O.value++]=X}else{if(!(O.value<m))return null;f[O.value++]=Q}return{c:C,lc:l}}const b=new Array(59);function p(Q,X,C,l,h,M){const f=X;let O=0,m=0;for(;l<=h;l++){if(f.value-X.value>C)return;let W=E(6,O,m,Q,f);const U=W.l;if(O=W.c,m=W.lc,M[l]=U,U==z){if(f.value-X.value>C)throw new Error("Error in HufUnpackEncTable");W=E(8,O,m,Q,f);let U=W.l+x;if(O=W.c,m=W.lc,l+U>h+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)M[l++]=0;l--}else if(U>=s){let Q=U-s+2;if(l+Q>h+1)throw new Error("Error in HufUnpackEncTable");for(;Q--;)M[l++]=0;l--}}!function(Q){for(let C=0;C<=58;++C)b[C]=0;for(let C=0;C<i;++C)b[Q[C]]+=1;let X=0;for(let C=58;C>0;--C){const Q=X+b[C]>>1;b[C]=X,X=Q}for(let C=0;C<i;++C){const X=Q[C];X>0&&(Q[C]=X|b[X]++<<6)}}(M)}function I(Q){return 63&Q}function t(Q){return Q>>6}function y(Q,X,C,l,h,M){const f=C.value,O=g(X,C),m=g(X,C);C.value+=4;const W=g(X,C);if(C.value+=4,O<0||O>=i||m<0||m>=i)throw new Error("Wrong HUF_ENCSIZE");const U=new Array(i),L=new Array(a);!function(Q){for(let X=0;X<a;X++)Q[X]={},Q[X].len=0,Q[X].lit=0,Q[X].p=null}(L);if(p(Q,C,l-(C.value-f),O,m,U),W>8*(l-(C.value-f)))throw new Error("Wrong hufUncompress");!function(Q,X,C,l){for(;X<=C;X++){const C=t(Q[X]),h=I(Q[X]);if(C>>h)throw new Error("Invalid table entry");if(h>w){const Q=l[C>>h-w];if(Q.len)throw new Error("Invalid table entry");if(Q.lit++,Q.p){const X=Q.p;Q.p=new Array(Q.lit);for(let C=0;C<Q.lit-1;++C)Q.p[C]=X[C]}else Q.p=new Array(1);Q.p[Q.lit-1]=X}else if(h){let Q=0;for(let M=1<<w-h;M>0;M--){const M=l[(C<<w-h)+Q];if(M.len||M.p)throw new Error("Invalid table entry");M.len=h,M.lit=X,Q++}}}}(U,O,m,L),function(Q,X,C,l,h,M,f,O,m){let W=0,U=0;const L=f,i=Math.trunc(l.value+(h+7)/8);for(;l.value<i;){let h=B(W,U,C,l);for(W=h.c,U=h.lc;U>=w;){const f=X[W>>U-w&F];if(f.len){U-=f.len;const Q=G(f.lit,M,W,U,C,l,O,m,L);Q&&(W=Q.c,U=Q.lc)}else{if(!f.p)throw new Error("hufDecode issues");let X;for(X=0;X<f.lit;X++){const w=I(Q[f.p[X]]);for(;U<w&&l.value<i;)h=B(W,U,C,l),W=h.c,U=h.lc;if(U>=w&&t(Q[f.p[X]])==(W>>U-w&(1<<w)-1)){U-=w;const Q=G(f.p[X],M,W,U,C,l,O,m,L);Q&&(W=Q.c,U=Q.lc);break}}if(X==f.lit)throw new Error("HufDecode issues")}}}const a=8-h&7;for(W>>=a,U-=a;U>0;){const Q=X[W<<w-U&F];if(!Q.len)throw new Error("HufDecode issues");{U-=Q.len;const X=G(Q.lit,M,W,U,C,l,O,m,L);X&&(W=X.c,U=X.lc)}}}(U,L,Q,C,W,m,M,h,{value:0})}function A(Q){return 65535&Q}function D(Q){const X=A(Q);return X>32767?X-65536:X}function u(Q,X){const C=D(Q),l=D(X),h=C+(1&l)+(l>>1);return{a:h,b:h-l}}function V(Q,X){const C=A(Q),l=A(X),h=C-(l>>1)&c;return{a:l+h-n&c,b:h}}function d(Q,X,C,l,h,M,f){const O=f<16384,m=C>h?h:C;let W,U,L=1;for(;L<=m;)L<<=1;for(L>>=1,W=L,L>>=1;L>=1;){U=0;const f=U+M*(h-W),m=M*L,w=M*W,i=l*L,a=l*W;let F,s,z,x;for(;U<=f;U+=w){let h=U;const M=U+l*(C-W);for(;h<=M;h+=a){const C=h+i,l=h+m,M=l+i;if(O){let f=u(Q[h+X],Q[l+X]);F=f.a,z=f.b,f=u(Q[C+X],Q[M+X]),s=f.a,x=f.b,f=u(F,s),Q[h+X]=f.a,Q[C+X]=f.b,f=u(z,x),Q[l+X]=f.a,Q[M+X]=f.b}else{let f=V(Q[h+X],Q[l+X]);F=f.a,z=f.b,f=V(Q[C+X],Q[M+X]),s=f.a,x=f.b,f=V(F,s),Q[h+X]=f.a,Q[C+X]=f.b,f=V(z,x),Q[l+X]=f.a,Q[M+X]=f.b}}if(C&L){const C=h+m;let l;l=O?u(Q[h+X],Q[C+X]):V(Q[h+X],Q[C+X]),F=l.a,Q[C+X]=l.b,Q[h+X]=F}}if(h&L){let h=U;const M=U+l*(C-W);for(;h<=M;h+=a){const C=h+i;let l;l=O?u(Q[h+X],Q[C+X]):V(Q[h+X],Q[C+X]),F=l.a,Q[C+X]=l.b,Q[h+X]=F}}W=L,L>>=1}return U}function QQ(Q){return new DataView(Q.array.buffer,Q.offset.value,Q.size)}function XQ(Q){const X=Q.viewer.buffer.slice(Q.offset.value,Q.offset.value+Q.size),C=new Uint8Array(function(Q){let X=Q.byteLength;const C=[];let l=0;const h=new DataView(Q);for(;X>0;){const Q=h.getInt8(l++);if(Q<0){const M=-Q;X-=M+1;for(let Q=0;Q<M;Q++)C.push(h.getUint8(l++))}else{const M=Q;X-=2;const f=h.getUint8(l++);for(let Q=0;Q<M+1;Q++)C.push(f)}}return C}(X)),l=new Uint8Array(C.length);return J(C),K(C,l),new DataView(l.buffer)}function CQ(Q){const X=Q.array.slice(Q.offset.value,Q.offset.value+Q.size),C=fflate.unzlibSync(X),l=new Uint8Array(C.length);return J(C),K(C,l),new DataView(l.buffer)}function lQ(Q){const X=Q.array.slice(Q.offset.value,Q.offset.value+Q.size),C=fflate.unzlibSync(X),l=Q.lines*Q.channels*Q.width,h=1==Q.type?new Uint16Array(l):new Uint32Array(l);let M=0,f=0;const O=new Array(4);for(let m=0;m<Q.lines;m++)for(let X=0;X<Q.channels;X++){let X=0;switch(Q.type){case 1:O[0]=M,O[1]=O[0]+Q.width,M=O[1]+Q.width;for(let l=0;l<Q.width;++l){X+=C[O[0]++]<<8|C[O[1]++],h[f]=X,f++}break;case 2:O[0]=M,O[1]=O[0]+Q.width,O[2]=O[1]+Q.width,M=O[2]+Q.width;for(let l=0;l<Q.width;++l){X+=C[O[0]++]<<24|C[O[1]++]<<16|C[O[2]++]<<8,h[f]=X,f++}}}return new DataView(h.buffer)}function hQ(Q){const X=Q.viewer,C={value:Q.offset.value},l=new Uint16Array(Q.width*Q.scanlineBlockSize*(Q.channels*Q.type)),h=new Uint8Array(L);let M=0;const f=new Array(Q.channels);for(let m=0;m<Q.channels;m++)f[m]={},f[m].start=M,f[m].end=f[m].start,f[m].nx=Q.width,f[m].ny=Q.lines,f[m].size=Q.type,M+=f[m].nx*f[m].ny*f[m].size;const O=e(X,C),W=e(X,C);if(W>=L)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(O<=W)for(let m=0;m<W-O+1;m++)h[m+O]=S(X,C);const w=new Uint16Array(U),i=function(Q,X){let C=0;for(let h=0;h<U;++h)(0==h||Q[h>>3]&1<<(7&h))&&(X[C++]=h);const l=C-1;for(;C<U;)X[C++]=0;return l}(h,w),a=g(X,C);y(Q.array,X,C,a,l,M);for(let m=0;m<Q.channels;++m){const Q=f[m];for(let X=0;X<f[m].size;++X)d(l,Q.start+X,Q.nx,Q.size,Q.ny,Q.nx*Q.size,i)}!function(Q,X,C){for(let l=0;l<C;++l)X[l]=Q[X[l]]}(w,l,M);let F=0;const s=new Uint8Array(l.buffer.byteLength);for(let U=0;U<Q.lines;U++)for(let X=0;X<Q.channels;X++){const Q=f[X],C=Q.nx*Q.size,h=new Uint8Array(l.buffer,Q.end*m,C*m);s.set(h,F),F+=C*m,Q.end+=C}return new DataView(s.buffer)}var MQ,fQ=C(487);!function(Q){Q[Q.Float=0]="Float",Q[Q.HalfFloat=1]="HalfFloat"}(MQ||(MQ={}));class OQ{}async function mQ(Q,X,C,l){const h={size:0,viewer:X,array:new Uint8Array(X.buffer),offset:C,width:Q.dataWindow.xMax-Q.dataWindow.xMin+1,height:Q.dataWindow.yMax-Q.dataWindow.yMin+1,channels:Q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Q.compression){case r.NO_COMPRESSION:h.lines=1,h.uncompress=QQ;break;case r.RLE_COMPRESSION:h.lines=1,h.uncompress=XQ;break;case r.ZIPS_COMPRESSION:h.lines=1,h.uncompress=CQ,await fQ.i.LoadScriptAsync(OQ.FFLATEUrl);break;case r.ZIP_COMPRESSION:h.lines=16,h.uncompress=CQ,await fQ.i.LoadScriptAsync(OQ.FFLATEUrl);break;case r.PIZ_COMPRESSION:h.lines=32,h.uncompress=hQ;break;case r.PXR24_COMPRESSION:h.lines=16,h.uncompress=lQ,await fQ.i.LoadScriptAsync(OQ.FFLATEUrl);break;default:throw new Error(r[Q.compression]+" is unsupported")}h.scanlineBlockSize=h.lines;const M={};for(const f of Q.channels)switch(f.name){case"R":case"G":case"B":case"A":case"Y":M[f.name]=!0,h.type=f.pixelType}let O=!1;if(M.R&&M.G&&M.B&&M.A)h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else if(M.R&&M.G&&M.B)O=!0,h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else if(M.R&&M.G)h.outputChannels=2,h.decodeChannels={R:0,G:1};else if(M.R)h.outputChannels=1,h.decodeChannels={R:0};else{if(!M.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");h.outputChannels=1,h.decodeChannels={Y:0}}if(1===h.type)switch(l){case MQ.Float:h.getter=o,h.inputSize=m;break;case MQ.HalfFloat:h.getter=e,h.inputSize=m}else{if(2!==h.type)throw new Error("Unsupported pixelType "+h.type+" for "+Q.compression);switch(l){case MQ.Float:h.getter=H,h.inputSize=f;break;case MQ.HalfFloat:h.getter=T,h.inputSize=f}}h.blockCount=h.height/h.scanlineBlockSize;for(let f=0;f<h.blockCount;f++)R(X,C);const W=h.width*h.height*h.outputChannels;switch(l){case MQ.Float:h.byteArray=new Float32Array(W),h.textureType=1,O&&h.byteArray.fill(1,0,W);break;case MQ.HalfFloat:h.byteArray=new Uint16Array(W),h.textureType=2,O&&h.byteArray.fill(15360,0,W);break;default:throw new Error("Unsupported type: "+l)}let U=0;for(const f of Q.channels)void 0!==h.decodeChannels[f.name]&&(h.channelLineOffsets[f.name]=U*h.width),U+=2*f.pixelType;return h.bytesPerLine=h.width*U,h.outLineWidth=h.width*h.outputChannels,"INCREASING_Y"===Q.lineOrder?h.scanOrder=Q=>Q:h.scanOrder=Q=>h.height-1-Q,4==h.outputChannels?(h.format=5,h.linearSpace=!0):(h.format=6,h.linearSpace=!1),h}function WQ(Q,X,C,l){const h={value:0};for(let M=0;M<Q.height/Q.scanlineBlockSize;M++){const f=Z(C,l)-X.dataWindow.yMin;Q.size=g(C,l),Q.lines=f+Q.scanlineBlockSize>Q.height?Q.height-f:Q.scanlineBlockSize;const O=Q.size<Q.lines*Q.bytesPerLine&&Q.uncompress?Q.uncompress(Q):QQ(Q);l.value+=Q.size;for(let C=0;C<Q.scanlineBlockSize;C++){const l=M*Q.scanlineBlockSize,f=C+Q.scanOrder(l);if(f>=Q.height)continue;const m=C*Q.bytesPerLine,W=(Q.height-1-f)*Q.outLineWidth;for(let C=0;C<Q.channels;C++){const l=X.channels[C].name,M=Q.channelLineOffsets[l],f=Q.decodeChannels[l];if(void 0!==f){h.value=m+M;for(let X=0;X<Q.width;X++){const C=W+X*Q.outputChannels+f;Q.byteArray&&(Q.byteArray[C]=Q.getter(O,h))}}}}}}OQ.DefaultOutputType=MQ.HalfFloat,OQ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class UQ{constructor(){this.supportCascades=!1}loadCubeData(Q,X,C,l,h){throw".exr not supported in Cube."}loadData(Q,X,C){const h=new DataView(Q.buffer),M={value:0},f=q(h,M);mQ(f,h,M,OQ.DefaultOutputType).then((Q=>{WQ(Q,f,h,M);const l=f.dataWindow.xMax-f.dataWindow.xMin+1,O=f.dataWindow.yMax-f.dataWindow.yMin+1;C(l,O,X.generateMipMaps,!1,(()=>{const C=X.getEngine();X.format=f.format,X.type=Q.textureType,X.invertY=!1,X._gammaSpace=!f.linearSpace,Q.byteArray&&C._uploadDataToTextureDirectly(X,Q.byteArray,0,0,void 0,!0)}))})).catch((Q=>{l.c.Error("Failed to load EXR texture: ",Q)}))}}async function LQ(Q){const X=new DataView(Q),C={value:0},h=q(X,C);try{const Q=await mQ(h,X,C,MQ.Float);return WQ(Q,h,X,C),Q.byteArray?{width:h.dataWindow.xMax-h.dataWindow.xMin+1,height:h.dataWindow.yMax-h.dataWindow.yMin+1,data:new Float32Array(Q.byteArray)}:(l.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(M){l.c.Error("Failed to load EXR data: ",M)}return{width:0,height:0,data:null}}}}]);