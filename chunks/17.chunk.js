"use strict";(self.fjf2z1c8il8=self.fjf2z1c8il8||[]).push([[17],{12496:(g,i,a)=>{a.r(i),a.d(i,{Ri:()=>I,Hd:()=>j,TmpColors:()=>y});var n=a(12462),L=a(12415),d=a(12454),b=a(12466);function k(g){return Math.pow(g,d.l)}function e(g){return g<=.04045?.0773993808*g:Math.pow(.947867299*(g+.055),2.4)}function N(g){return Math.pow(g,d.i)}function F(g){return g<=.0031308?12.92*g:1.055*Math.pow(g,.41666)-.055}class I{constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=g,this.g=i,this.b=a}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Ri"}getHashCode(){let g=255*this.r|0;return g=397*g^255*this.g,g=397*g^255*this.b,g}toArray(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g[i]=this.r,g[i+1]=this.g,g[i+2]=this.b,this}ya(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(g,i,this),this}toColor4(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new j(this.r,this.g,this.b,g)}fd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(g){return new I(this.r*g.r,this.g*g.g,this.b*g.b)}multiplyToRef(g,i){return i.r=this.r*g.r,i.g=this.g*g.g,i.b=this.b*g.b,i}multiplyInPlace(g){return this.r*=g.r,this.g*=g.g,this.b*=g.b,this}multiplyByFloats(g,i,a){return new I(this.r*g,this.g*i,this.b*a)}divide(g){throw new ReferenceError("Can not divide a color")}divideToRef(g,i){throw new ReferenceError("Can not divide a color")}divideInPlace(g){throw new ReferenceError("Can not divide a color")}minimizeInPlace(g){return this.minimizeInPlaceFromFloats(g.r,g.g,g.b)}maximizeInPlace(g){return this.maximizeInPlaceFromFloats(g.r,g.g,g.b)}minimizeInPlaceFromFloats(g,i,a){return this.r=Math.min(g,this.r),this.g=Math.min(i,this.g),this.b=Math.min(a,this.b),this}maximizeInPlaceFromFloats(g,i,a){return this.r=Math.max(g,this.r),this.g=Math.max(i,this.g),this.b=Math.max(a,this.b),this}floorToRef(g){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(g){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(g){return g&&this.r===g.r&&this.g===g.g&&this.b===g.b}equalsFloats(g,i,a){return this.equalsToFloats(g,i,a)}equalsToFloats(g,i,a){return this.r===g&&this.g===i&&this.b===a}equalsWithEpsilon(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.b;return(0,b.WithinEpsilon)(this.r,g.r,i)&&(0,b.WithinEpsilon)(this.g,g.g,i)&&(0,b.WithinEpsilon)(this.b,g.b,i)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(g){throw new ReferenceError("Can not negate a color")}scale(g){return new I(this.r*g,this.g*g,this.b*g)}scaleInPlace(g){return this.r*=g,this.g*=g,this.b*=g,this}scaleToRef(g,i){return i.r=this.r*g,i.g=this.g*g,i.b=this.b*g,i}scaleAndAddToRef(g,i){return i.r+=this.r*g,i.g+=this.g*g,i.b+=this.b*g,i}clampToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2?arguments[2]:void 0;return a.r=(0,b.Clamp)(this.r,g,i),a.g=(0,b.Clamp)(this.g,g,i),a.b=(0,b.Clamp)(this.b,g,i),a}add(g){return new I(this.r+g.r,this.g+g.g,this.b+g.b)}addInPlace(g){return this.r+=g.r,this.g+=g.g,this.b+=g.b,this}addInPlaceFromFloats(g,i,a){return this.r+=g,this.g+=i,this.b+=a,this}addToRef(g,i){return i.r=this.r+g.r,i.g=this.g+g.g,i.b=this.b+g.b,i}ci(g){return new I(this.r-g.r,this.g-g.g,this.b-g.b)}subtractToRef(g,i){return i.r=this.r-g.r,i.g=this.g-g.g,i.b=this.b-g.b,i}ij(g){return this.r-=g.r,this.g-=g.g,this.b-=g.b,this}subtractFromFloats(g,i,a){return new I(this.r-g,this.g-i,this.b-a)}subtractFromFloatsToRef(g,i,a,n){return n.r=this.r-g,n.g=this.g-i,n.b=this.b-a,n}clone(){return new I(this.r,this.g,this.b)}I(g){return this.r=g.r,this.g=g.g,this.b=g.b,this}sd(g,i,a){return this.r=g,this.g=i,this.b=a,this}set(g,i,a){return this.sd(g,i,a)}Qd(g){return this.r=this.g=this.b=g,this}toHexString(){const g=Math.round(255*this.r),i=Math.round(255*this.g),a=Math.round(255*this.b);return"#"+(0,b.ToHex)(g)+(0,b.ToHex)(i)+(0,b.ToHex)(a)}fromHexString(g){return"#"!==g.substring(0,1)||7!==g.length||(this.r=parseInt(g.substring(1,3),16)/255,this.g=parseInt(g.substring(3,5),16)/255,this.b=parseInt(g.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new I)}toHSVToRef(g){const i=this.r,a=this.g,n=this.b,L=Math.max(i,a,n),d=Math.min(i,a,n);let b=0,k=0;const e=L,N=L-d;return 0!==L&&(k=N/L),L!=d&&(L==i?(b=(a-n)/N,a<n&&(b+=6)):L==a?b=(n-i)/N+2:L==n&&(b=(i-a)/N+4),b*=60),g.r=b,g.g=k,g.b=e,g}toLinearSpace(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=new I;return this.toLinearSpaceToRef(i,g),i}toLinearSpaceToRef(g){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(g.r=e(this.r),g.g=e(this.g),g.b=e(this.b)):(g.r=k(this.r),g.g=k(this.g),g.b=k(this.b)),this}toGammaSpace(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=new I;return this.toGammaSpaceToRef(i,g),i}toGammaSpaceToRef(g){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(g.r=F(this.r),g.g=F(this.g),g.b=F(this.b)):(g.r=N(this.r),g.g=N(this.g),g.b=N(this.b)),this}static HSVtoRGBToRef(g,i,a,n){const L=a*i,d=g/60,b=L*(1-Math.abs(d%2-1));let k=0,e=0,N=0;d>=0&&d<=1?(k=L,e=b):d>=1&&d<=2?(k=b,e=L):d>=2&&d<=3?(e=L,N=b):d>=3&&d<=4?(e=b,N=L):d>=4&&d<=5?(k=b,N=L):d>=5&&d<=6&&(k=L,N=b);const F=a-L;return n.r=k+F,n.g=e+F,n.b=N+F,n}static FromHSV(g,i,a){const n=new I(0,0,0);return I.HSVtoRGBToRef(g,i,a,n),n}static FromHexString(g){return new I(0,0,0).fromHexString(g)}static xi(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(g[i],g[i+1],g[i+2])}static FromArrayToRef(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2?arguments[2]:void 0;a.r=g[i],a.g=g[i+1],a.b=g[i+2]}static FromInts(g,i,a){return new I(g/255,i/255,a/255)}static Lerp(g,i,a){const n=new I(0,0,0);return I.LerpToRef(g,i,a,n),n}static LerpToRef(g,i,a,n){n.r=g.r+(i.r-g.r)*a,n.g=g.g+(i.g-g.g)*a,n.b=g.b+(i.b-g.b)*a}static Hermite(g,i,a,n,L){const d=L*L,b=L*d,k=2*b-3*d+1,e=-2*b+3*d,N=b-2*d+L,F=b-d,j=g.r*k+a.r*e+i.r*N+n.r*F,y=g.g*k+a.g*e+i.g*N+n.g*F,B=g.b*k+a.b*e+i.b*N+n.b*F;return new I(j,y,B)}static Hermite1stDerivative(g,i,a,n,L){const d=I.Black();return this.Hermite1stDerivativeToRef(g,i,a,n,L,d),d}static Hermite1stDerivativeToRef(g,i,a,n,L,d){const b=L*L;d.r=6*(b-L)*g.r+(3*b-4*L+1)*i.r+6*(-b+L)*a.r+(3*b-2*L)*n.r,d.g=6*(b-L)*g.g+(3*b-4*L+1)*i.g+6*(-b+L)*a.g+(3*b-2*L)*n.g,d.b=6*(b-L)*g.b+(3*b-4*L+1)*i.b+6*(-b+L)*a.b+(3*b-2*L)*n.b}static Red(){return new I(1,0,0)}static Green(){return new I(0,1,0)}static Blue(){return new I(0,0,1)}static Black(){return new I(0,0,0)}static get BlackReadOnly(){return I._BlackReadOnly}static White(){return new I(1,1,1)}static Purple(){return new I(.5,0,.5)}static Magenta(){return new I(1,0,1)}static Yellow(){return new I(1,1,0)}static Gray(){return new I(.5,.5,.5)}static Teal(){return new I(0,1,1)}static Random(){return new I(Math.random(),Math.random(),Math.random())}}I._V8PerformanceHack=new I(.5,.5,.5),I._BlackReadOnly=I.Black(),Object.defineProperties(I.prototype,{dimension:{value:[3]},rank:{value:1}});class j{constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=g,this.g=i,this.b=a,this.a=n}fd(){return[this.r,this.g,this.b,this.a]}toArray(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g[i]=this.r,g[i+1]=this.g,g[i+2]=this.b,g[i+3]=this.a,this}ya(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=g[i],this.g=g[i+1],this.b=g[i+2],this.a=g[i+3],this}equals(g){return g&&this.r===g.r&&this.g===g.g&&this.b===g.b&&this.a===g.a}add(g){return new j(this.r+g.r,this.g+g.g,this.b+g.b,this.a+g.a)}addToRef(g,i){return i.r=this.r+g.r,i.g=this.g+g.g,i.b=this.b+g.b,i.a=this.a+g.a,i}addInPlace(g){return this.r+=g.r,this.g+=g.g,this.b+=g.b,this.a+=g.a,this}addInPlaceFromFloats(g,i,a,n){return this.r+=g,this.g+=i,this.b+=a,this.a+=n,this}ci(g){return new j(this.r-g.r,this.g-g.g,this.b-g.b,this.a-g.a)}subtractToRef(g,i){return i.r=this.r-g.r,i.g=this.g-g.g,i.b=this.b-g.b,i.a=this.a-g.a,i}ij(g){return this.r-=g.r,this.g-=g.g,this.b-=g.b,this.a-=g.a,this}subtractFromFloats(g,i,a,n){return new j(this.r-g,this.g-i,this.b-a,this.a-n)}subtractFromFloatsToRef(g,i,a,n,L){return L.r=this.r-g,L.g=this.g-i,L.b=this.b-a,L.a=this.a-n,L}scale(g){return new j(this.r*g,this.g*g,this.b*g,this.a*g)}scaleInPlace(g){return this.r*=g,this.g*=g,this.b*=g,this.a*=g,this}scaleToRef(g,i){return i.r=this.r*g,i.g=this.g*g,i.b=this.b*g,i.a=this.a*g,i}scaleAndAddToRef(g,i){return i.r+=this.r*g,i.g+=this.g*g,i.b+=this.b*g,i.a+=this.a*g,i}clampToRef(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,a=arguments.length>2?arguments[2]:void 0;return a.r=(0,b.Clamp)(this.r,g,i),a.g=(0,b.Clamp)(this.g,g,i),a.b=(0,b.Clamp)(this.b,g,i),a.a=(0,b.Clamp)(this.a,g,i),a}multiply(g){return new j(this.r*g.r,this.g*g.g,this.b*g.b,this.a*g.a)}multiplyToRef(g,i){return i.r=this.r*g.r,i.g=this.g*g.g,i.b=this.b*g.b,i.a=this.a*g.a,i}multiplyInPlace(g){return this.r*=g.r,this.g*=g.g,this.b*=g.b,this.a*=g.a,this}multiplyByFloats(g,i,a,n){return new j(this.r*g,this.g*i,this.b*a,this.a*n)}divide(g){throw new ReferenceError("Can not divide a color")}divideToRef(g,i){throw new ReferenceError("Can not divide a color")}divideInPlace(g){throw new ReferenceError("Can not divide a color")}minimizeInPlace(g){return this.r=Math.min(this.r,g.r),this.g=Math.min(this.g,g.g),this.b=Math.min(this.b,g.b),this.a=Math.min(this.a,g.a),this}maximizeInPlace(g){return this.r=Math.max(this.r,g.r),this.g=Math.max(this.g,g.g),this.b=Math.max(this.b,g.b),this.a=Math.max(this.a,g.a),this}minimizeInPlaceFromFloats(g,i,a,n){return this.r=Math.min(g,this.r),this.g=Math.min(i,this.g),this.b=Math.min(a,this.b),this.a=Math.min(n,this.a),this}maximizeInPlaceFromFloats(g,i,a,n){return this.r=Math.max(g,this.r),this.g=Math.max(i,this.g),this.b=Math.max(a,this.b),this.a=Math.max(n,this.a),this}floorToRef(g){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(g){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(g){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.b;return(0,b.WithinEpsilon)(this.r,g.r,i)&&(0,b.WithinEpsilon)(this.g,g.g,i)&&(0,b.WithinEpsilon)(this.b,g.b,i)&&(0,b.WithinEpsilon)(this.a,g.a,i)}equalsToFloats(g,i,a,n){return this.r===g&&this.g===i&&this.b===a&&this.a===n}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Hd"}getHashCode(){let g=255*this.r|0;return g=397*g^255*this.g,g=397*g^255*this.b,g=397*g^255*this.a,g}clone(){return(new j).I(this)}I(g){return this.r=g.r,this.g=g.g,this.b=g.b,this.a=g.a,this}sd(g,i,a,n){return this.r=g,this.g=i,this.b=a,this.a=n,this}set(g,i,a,n){return this.sd(g,i,a,n)}Qd(g){return this.r=this.g=this.b=this.a=g,this}toHexString(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=Math.round(255*this.r),a=Math.round(255*this.g),n=Math.round(255*this.b);if(g)return"#"+(0,b.ToHex)(i)+(0,b.ToHex)(a)+(0,b.ToHex)(n);const L=Math.round(255*this.a);return"#"+(0,b.ToHex)(i)+(0,b.ToHex)(a)+(0,b.ToHex)(n)+(0,b.ToHex)(L)}fromHexString(g){return"#"!==g.substring(0,1)||9!==g.length&&7!==g.length||(this.r=parseInt(g.substring(1,3),16)/255,this.g=parseInt(g.substring(3,5),16)/255,this.b=parseInt(g.substring(5,7),16)/255,9===g.length&&(this.a=parseInt(g.substring(7,9),16)/255)),this}toLinearSpace(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=new j;return this.toLinearSpaceToRef(i,g),i}toLinearSpaceToRef(g){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(g.r=e(this.r),g.g=e(this.g),g.b=e(this.b)):(g.r=k(this.r),g.g=k(this.g),g.b=k(this.b)),g.a=this.a,this}toGammaSpace(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=new j;return this.toGammaSpaceToRef(i,g),i}toGammaSpaceToRef(g){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(g.r=F(this.r),g.g=F(this.g),g.b=F(this.b)):(g.r=N(this.r),g.g=N(this.g),g.b=N(this.b)),g.a=this.a,this}static FromHexString(g){return"#"!==g.substring(0,1)||9!==g.length&&7!==g.length?new j(0,0,0,0):new j(0,0,0,1).fromHexString(g)}static Lerp(g,i,a){return j.LerpToRef(g,i,a,new j)}static LerpToRef(g,i,a,n){return n.r=g.r+(i.r-g.r)*a,n.g=g.g+(i.g-g.g)*a,n.b=g.b+(i.b-g.b)*a,n.a=g.a+(i.a-g.a)*a,n}static Hermite(g,i,a,n,L){const d=L*L,b=L*d,k=2*b-3*d+1,e=-2*b+3*d,N=b-2*d+L,F=b-d,I=g.r*k+a.r*e+i.r*N+n.r*F,y=g.g*k+a.g*e+i.g*N+n.g*F,B=g.b*k+a.b*e+i.b*N+n.b*F,c=g.a*k+a.a*e+i.a*N+n.a*F;return new j(I,y,B,c)}static Hermite1stDerivative(g,i,a,n,L){const d=new j;return this.Hermite1stDerivativeToRef(g,i,a,n,L,d),d}static Hermite1stDerivativeToRef(g,i,a,n,L,d){const b=L*L;d.r=6*(b-L)*g.r+(3*b-4*L+1)*i.r+6*(-b+L)*a.r+(3*b-2*L)*n.r,d.g=6*(b-L)*g.g+(3*b-4*L+1)*i.g+6*(-b+L)*a.g+(3*b-2*L)*n.g,d.b=6*(b-L)*g.b+(3*b-4*L+1)*i.b+6*(-b+L)*a.b+(3*b-2*L)*n.b,d.a=6*(b-L)*g.a+(3*b-4*L+1)*i.a+6*(-b+L)*a.a+(3*b-2*L)*n.a}static FromColor3(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j(g.r,g.g,g.b,i)}static xi(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(g[i],g[i+1],g[i+2],g[i+3])}static FromArrayToRef(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=arguments.length>2?arguments[2]:void 0;a.r=g[i],a.g=g[i+1],a.b=g[i+2],a.a=g[i+3]}static FromInts(g,i,a,n){return new j(g/255,i/255,a/255,n/255)}static CheckColors4(g,i){if(g.length===3*i){const i=[];for(let a=0;a<g.length;a+=3){const n=a/3*4;i[n]=g[a],i[n+1]=g[a+1],i[n+2]=g[a+2],i[n+3]=1}return i}return g}}j._V8PerformanceHack=new j(.5,.5,.5,.5),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class y{}y.Ri=(0,n.d)(3,I.Black),y.Hd=(0,n.d)(3,(()=>new j(0,0,0,0))),(0,L.e)("BABYLON.Color3",I),(0,L.e)("BABYLON.Color4",j)}}]);