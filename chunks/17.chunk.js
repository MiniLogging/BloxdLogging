"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{11189:(h,V,i)=>{i.r(V),i.d(V,{LV:()=>v,vq:()=>s,TmpColors:()=>t});var S=i(11156),l=i(11091),Y=i(11147),g=i(11162);function q(h){return Math.pow(h,Y.j)}function B(h){return h<=.04045?.0773993808*h:Math.pow(.947867299*(h+.055),2.4)}function J(h){return Math.pow(h,Y.h)}function I(h){return h<=.0031308?12.92*h:1.055*Math.pow(h,.41666)-.055}class v{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=h,this.g=V,this.b=i}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"LV"}getHashCode(){let h=255*this.r|0;return h=397*h^255*this.g,h=397*h^255*this.b,h}toArray(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[V]=this.r,h[V+1]=this.g,h[V+2]=this.b,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return v.FromArrayToRef(h,V,this),this}toColor4(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new s(this.r,this.g,this.b,h)}Ng(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(h){return new v(this.r*h.r,this.g*h.g,this.b*h.b)}multiplyToRef(h,V){return V.r=this.r*h.r,V.g=this.g*h.g,V.b=this.b*h.b,V}multiplyInPlace(h){return this.r*=h.r,this.g*=h.g,this.b*=h.b,this}multiplyByFloats(h,V,i){return new v(this.r*h,this.g*V,this.b*i)}divide(h){throw new ReferenceError("Can not divide a color")}divideToRef(h,V){throw new ReferenceError("Can not divide a color")}divideInPlace(h){throw new ReferenceError("Can not divide a color")}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h.r,h.g,h.b)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h.r,h.g,h.b)}minimizeInPlaceFromFloats(h,V,i){return this.r=Math.min(h,this.r),this.g=Math.min(V,this.g),this.b=Math.min(i,this.b),this}maximizeInPlaceFromFloats(h,V,i){return this.r=Math.max(h,this.r),this.g=Math.max(V,this.g),this.b=Math.max(i,this.b),this}floorToRef(h){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(h){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(h){return h&&this.r===h.r&&this.g===h.g&&this.b===h.b}equalsFloats(h,V,i){return this.equalsToFloats(h,V,i)}equalsToFloats(h,V,i){return this.r===h&&this.g===V&&this.b===i}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.c;return(0,g.WithinEpsilon)(this.r,h.r,V)&&(0,g.WithinEpsilon)(this.g,h.g,V)&&(0,g.WithinEpsilon)(this.b,h.b,V)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(h){throw new ReferenceError("Can not negate a color")}scale(h){return new v(this.r*h,this.g*h,this.b*h)}scaleInPlace(h){return this.r*=h,this.g*=h,this.b*=h,this}scaleToRef(h,V){return V.r=this.r*h,V.g=this.g*h,V.b=this.b*h,V}scaleAndAddToRef(h,V){return V.r+=this.r*h,V.g+=this.g*h,V.b+=this.b*h,V}clampToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,g.Clamp)(this.r,h,V),i.g=(0,g.Clamp)(this.g,h,V),i.b=(0,g.Clamp)(this.b,h,V),i}add(h){return new v(this.r+h.r,this.g+h.g,this.b+h.b)}addInPlace(h){return this.r+=h.r,this.g+=h.g,this.b+=h.b,this}addInPlaceFromFloats(h,V,i){return this.r+=h,this.g+=V,this.b+=i,this}addToRef(h,V){return V.r=this.r+h.r,V.g=this.g+h.g,V.b=this.b+h.b,V}cV(h){return new v(this.r-h.r,this.g-h.g,this.b-h.b)}subtractToRef(h,V){return V.r=this.r-h.r,V.g=this.g-h.g,V.b=this.b-h.b,V}mI(h){return this.r-=h.r,this.g-=h.g,this.b-=h.b,this}subtractFromFloats(h,V,i){return new v(this.r-h,this.g-V,this.b-i)}subtractFromFloatsToRef(h,V,i,S){return S.r=this.r-h,S.g=this.g-V,S.b=this.b-i,S}clone(){return new v(this.r,this.g,this.b)}l(h){return this.r=h.r,this.g=h.g,this.b=h.b,this}qq(h,V,i){return this.r=h,this.g=V,this.b=i,this}set(h,V,i){return this.qq(h,V,i)}Iq(h){return this.r=this.g=this.b=h,this}toHexString(){const h=Math.round(255*this.r),V=Math.round(255*this.g),i=Math.round(255*this.b);return"#"+(0,g.ToHex)(h)+(0,g.ToHex)(V)+(0,g.ToHex)(i)}fromHexString(h){return"#"!==h.substring(0,1)||7!==h.length||(this.r=parseInt(h.substring(1,3),16)/255,this.g=parseInt(h.substring(3,5),16)/255,this.b=parseInt(h.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new v)}toHSVToRef(h){const V=this.r,i=this.g,S=this.b,l=Math.max(V,i,S),Y=Math.min(V,i,S);let g=0,q=0;const B=l,J=l-Y;return 0!==l&&(q=J/l),l!=Y&&(l==V?(g=(i-S)/J,i<S&&(g+=6)):l==i?g=(S-V)/J+2:l==S&&(g=(V-i)/J+4),g*=60),h.r=g,h.g=q,h.b=B,h}toLinearSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new v;return this.toLinearSpaceToRef(V,h),V}toLinearSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=B(this.r),h.g=B(this.g),h.b=B(this.b)):(h.r=q(this.r),h.g=q(this.g),h.b=q(this.b)),this}toGammaSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new v;return this.toGammaSpaceToRef(V,h),V}toGammaSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=I(this.r),h.g=I(this.g),h.b=I(this.b)):(h.r=J(this.r),h.g=J(this.g),h.b=J(this.b)),this}static HSVtoRGBToRef(h,V,i,S){const l=i*V,Y=h/60,g=l*(1-Math.abs(Y%2-1));let q=0,B=0,J=0;Y>=0&&Y<=1?(q=l,B=g):Y>=1&&Y<=2?(q=g,B=l):Y>=2&&Y<=3?(B=l,J=g):Y>=3&&Y<=4?(B=g,J=l):Y>=4&&Y<=5?(q=g,J=l):Y>=5&&Y<=6&&(q=l,J=g);const I=i-l;return S.r=q+I,S.g=B+I,S.b=J+I,S}static FromHSV(h,V,i){const S=new v(0,0,0);return v.HSVtoRGBToRef(h,V,i,S),S}static FromHexString(h){return new v(0,0,0).fromHexString(h)}static UV(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new v(h[V],h[V+1],h[V+2])}static FromArrayToRef(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=h[V],i.g=h[V+1],i.b=h[V+2]}static FromInts(h,V,i){return new v(h/255,V/255,i/255)}static Lerp(h,V,i){const S=new v(0,0,0);return v.LerpToRef(h,V,i,S),S}static LerpToRef(h,V,i,S){S.r=h.r+(V.r-h.r)*i,S.g=h.g+(V.g-h.g)*i,S.b=h.b+(V.b-h.b)*i}static Hermite(h,V,i,S,l){const Y=l*l,g=l*Y,q=2*g-3*Y+1,B=-2*g+3*Y,J=g-2*Y+l,I=g-Y,s=h.r*q+i.r*B+V.r*J+S.r*I,t=h.g*q+i.g*B+V.g*J+S.g*I,T=h.b*q+i.b*B+V.b*J+S.b*I;return new v(s,t,T)}static Hermite1stDerivative(h,V,i,S,l){const Y=v.Black();return this.Hermite1stDerivativeToRef(h,V,i,S,l,Y),Y}static Hermite1stDerivativeToRef(h,V,i,S,l,Y){const g=l*l;Y.r=6*(g-l)*h.r+(3*g-4*l+1)*V.r+6*(-g+l)*i.r+(3*g-2*l)*S.r,Y.g=6*(g-l)*h.g+(3*g-4*l+1)*V.g+6*(-g+l)*i.g+(3*g-2*l)*S.g,Y.b=6*(g-l)*h.b+(3*g-4*l+1)*V.b+6*(-g+l)*i.b+(3*g-2*l)*S.b}static Red(){return new v(1,0,0)}static Green(){return new v(0,1,0)}static Blue(){return new v(0,0,1)}static Black(){return new v(0,0,0)}static get BlackReadOnly(){return v._BlackReadOnly}static White(){return new v(1,1,1)}static Purple(){return new v(.5,0,.5)}static Magenta(){return new v(1,0,1)}static Yellow(){return new v(1,1,0)}static Gray(){return new v(.5,.5,.5)}static Teal(){return new v(0,1,1)}static Random(){return new v(Math.random(),Math.random(),Math.random())}}v._V8PerformanceHack=new v(.5,.5,.5),v._BlackReadOnly=v.Black(),Object.defineProperties(v.prototype,{dimension:{value:[3]},rank:{value:1}});class s{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=h,this.g=V,this.b=i,this.a=S}Ng(){return[this.r,this.g,this.b,this.a]}toArray(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[V]=this.r,h[V+1]=this.g,h[V+2]=this.b,h[V+3]=this.a,this}ei(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=h[V],this.g=h[V+1],this.b=h[V+2],this.a=h[V+3],this}equals(h){return h&&this.r===h.r&&this.g===h.g&&this.b===h.b&&this.a===h.a}add(h){return new s(this.r+h.r,this.g+h.g,this.b+h.b,this.a+h.a)}addToRef(h,V){return V.r=this.r+h.r,V.g=this.g+h.g,V.b=this.b+h.b,V.a=this.a+h.a,V}addInPlace(h){return this.r+=h.r,this.g+=h.g,this.b+=h.b,this.a+=h.a,this}addInPlaceFromFloats(h,V,i,S){return this.r+=h,this.g+=V,this.b+=i,this.a+=S,this}cV(h){return new s(this.r-h.r,this.g-h.g,this.b-h.b,this.a-h.a)}subtractToRef(h,V){return V.r=this.r-h.r,V.g=this.g-h.g,V.b=this.b-h.b,V.a=this.a-h.a,V}mI(h){return this.r-=h.r,this.g-=h.g,this.b-=h.b,this.a-=h.a,this}subtractFromFloats(h,V,i,S){return new s(this.r-h,this.g-V,this.b-i,this.a-S)}subtractFromFloatsToRef(h,V,i,S,l){return l.r=this.r-h,l.g=this.g-V,l.b=this.b-i,l.a=this.a-S,l}scale(h){return new s(this.r*h,this.g*h,this.b*h,this.a*h)}scaleInPlace(h){return this.r*=h,this.g*=h,this.b*=h,this.a*=h,this}scaleToRef(h,V){return V.r=this.r*h,V.g=this.g*h,V.b=this.b*h,V.a=this.a*h,V}scaleAndAddToRef(h,V){return V.r+=this.r*h,V.g+=this.g*h,V.b+=this.b*h,V.a+=this.a*h,V}clampToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,g.Clamp)(this.r,h,V),i.g=(0,g.Clamp)(this.g,h,V),i.b=(0,g.Clamp)(this.b,h,V),i.a=(0,g.Clamp)(this.a,h,V),i}multiply(h){return new s(this.r*h.r,this.g*h.g,this.b*h.b,this.a*h.a)}multiplyToRef(h,V){return V.r=this.r*h.r,V.g=this.g*h.g,V.b=this.b*h.b,V.a=this.a*h.a,V}multiplyInPlace(h){return this.r*=h.r,this.g*=h.g,this.b*=h.b,this.a*=h.a,this}multiplyByFloats(h,V,i,S){return new s(this.r*h,this.g*V,this.b*i,this.a*S)}divide(h){throw new ReferenceError("Can not divide a color")}divideToRef(h,V){throw new ReferenceError("Can not divide a color")}divideInPlace(h){throw new ReferenceError("Can not divide a color")}minimizeInPlace(h){return this.r=Math.min(this.r,h.r),this.g=Math.min(this.g,h.g),this.b=Math.min(this.b,h.b),this.a=Math.min(this.a,h.a),this}maximizeInPlace(h){return this.r=Math.max(this.r,h.r),this.g=Math.max(this.g,h.g),this.b=Math.max(this.b,h.b),this.a=Math.max(this.a,h.a),this}minimizeInPlaceFromFloats(h,V,i,S){return this.r=Math.min(h,this.r),this.g=Math.min(V,this.g),this.b=Math.min(i,this.b),this.a=Math.min(S,this.a),this}maximizeInPlaceFromFloats(h,V,i,S){return this.r=Math.max(h,this.r),this.g=Math.max(V,this.g),this.b=Math.max(i,this.b),this.a=Math.max(S,this.a),this}floorToRef(h){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(h){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(h){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.c;return(0,g.WithinEpsilon)(this.r,h.r,V)&&(0,g.WithinEpsilon)(this.g,h.g,V)&&(0,g.WithinEpsilon)(this.b,h.b,V)&&(0,g.WithinEpsilon)(this.a,h.a,V)}equalsToFloats(h,V,i,S){return this.r===h&&this.g===V&&this.b===i&&this.a===S}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"vq"}getHashCode(){let h=255*this.r|0;return h=397*h^255*this.g,h=397*h^255*this.b,h=397*h^255*this.a,h}clone(){return(new s).l(this)}l(h){return this.r=h.r,this.g=h.g,this.b=h.b,this.a=h.a,this}qq(h,V,i,S){return this.r=h,this.g=V,this.b=i,this.a=S,this}set(h,V,i,S){return this.qq(h,V,i,S)}Iq(h){return this.r=this.g=this.b=this.a=h,this}toHexString(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=Math.round(255*this.r),i=Math.round(255*this.g),S=Math.round(255*this.b);if(h)return"#"+(0,g.ToHex)(V)+(0,g.ToHex)(i)+(0,g.ToHex)(S);const l=Math.round(255*this.a);return"#"+(0,g.ToHex)(V)+(0,g.ToHex)(i)+(0,g.ToHex)(S)+(0,g.ToHex)(l)}fromHexString(h){return"#"!==h.substring(0,1)||9!==h.length&&7!==h.length||(this.r=parseInt(h.substring(1,3),16)/255,this.g=parseInt(h.substring(3,5),16)/255,this.b=parseInt(h.substring(5,7),16)/255,9===h.length&&(this.a=parseInt(h.substring(7,9),16)/255)),this}toLinearSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new s;return this.toLinearSpaceToRef(V,h),V}toLinearSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=B(this.r),h.g=B(this.g),h.b=B(this.b)):(h.r=q(this.r),h.g=q(this.g),h.b=q(this.b)),h.a=this.a,this}toGammaSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new s;return this.toGammaSpaceToRef(V,h),V}toGammaSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=I(this.r),h.g=I(this.g),h.b=I(this.b)):(h.r=J(this.r),h.g=J(this.g),h.b=J(this.b)),h.a=this.a,this}static FromHexString(h){return"#"!==h.substring(0,1)||9!==h.length&&7!==h.length?new s(0,0,0,0):new s(0,0,0,1).fromHexString(h)}static Lerp(h,V,i){return s.LerpToRef(h,V,i,new s)}static LerpToRef(h,V,i,S){return S.r=h.r+(V.r-h.r)*i,S.g=h.g+(V.g-h.g)*i,S.b=h.b+(V.b-h.b)*i,S.a=h.a+(V.a-h.a)*i,S}static Hermite(h,V,i,S,l){const Y=l*l,g=l*Y,q=2*g-3*Y+1,B=-2*g+3*Y,J=g-2*Y+l,I=g-Y,v=h.r*q+i.r*B+V.r*J+S.r*I,t=h.g*q+i.g*B+V.g*J+S.g*I,T=h.b*q+i.b*B+V.b*J+S.b*I,e=h.a*q+i.a*B+V.a*J+S.a*I;return new s(v,t,T,e)}static Hermite1stDerivative(h,V,i,S,l){const Y=new s;return this.Hermite1stDerivativeToRef(h,V,i,S,l,Y),Y}static Hermite1stDerivativeToRef(h,V,i,S,l,Y){const g=l*l;Y.r=6*(g-l)*h.r+(3*g-4*l+1)*V.r+6*(-g+l)*i.r+(3*g-2*l)*S.r,Y.g=6*(g-l)*h.g+(3*g-4*l+1)*V.g+6*(-g+l)*i.g+(3*g-2*l)*S.g,Y.b=6*(g-l)*h.b+(3*g-4*l+1)*V.b+6*(-g+l)*i.b+(3*g-2*l)*S.b,Y.a=6*(g-l)*h.a+(3*g-4*l+1)*V.a+6*(-g+l)*i.a+(3*g-2*l)*S.a}static FromColor3(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s(h.r,h.g,h.b,V)}static UV(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(h[V],h[V+1],h[V+2],h[V+3])}static FromArrayToRef(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=h[V],i.g=h[V+1],i.b=h[V+2],i.a=h[V+3]}static FromInts(h,V,i,S){return new s(h/255,V/255,i/255,S/255)}static CheckColors4(h,V){if(h.length===3*V){const V=[];for(let i=0;i<h.length;i+=3){const S=i/3*4;V[S]=h[i],V[S+1]=h[i+1],V[S+2]=h[i+2],V[S+3]=1}return V}return h}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class t{}t.LV=(0,S.c)(3,v.Black),t.vq=(0,S.c)(3,(()=>new s(0,0,0,0))),(0,l.f)("BABYLON.Color3",v),(0,l.f)("BABYLON.Color4",s)}}]);