"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[17],{12362:(y,S,I)=>{I.r(S),I.d(S,{DS:()=>K,vd:()=>G,TmpColors:()=>p});var V=I(12331),i=I(12282),A=I(12325),B=I(12338);function d(y){return Math.pow(y,A.h)}function F(y){return y<=.04045?.0773993808*y:Math.pow(.947867299*(y+.055),2.4)}function J(y){return Math.pow(y,A.g)}function u(y){return y<=.0031308?12.92*y:1.055*Math.pow(y,.41666)-.055}class K{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=y,this.g=S,this.b=I}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"DS"}getHashCode(){let y=255*this.r|0;return y=397*y^255*this.g,y=397*y^255*this.b,y}toArray(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[S]=this.r,y[S+1]=this.g,y[S+2]=this.b,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(y,S,this),this}toColor4(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new G(this.r,this.g,this.b,y)}Vd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(y){return new K(this.r*y.r,this.g*y.g,this.b*y.b)}multiplyToRef(y,S){return S.r=this.r*y.r,S.g=this.g*y.g,S.b=this.b*y.b,S}multiplyInPlace(y){return this.r*=y.r,this.g*=y.g,this.b*=y.b,this}multiplyByFloats(y,S,I){return new K(this.r*y,this.g*S,this.b*I)}divide(y){throw new ReferenceError("Can not divide a color")}divideToRef(y,S){throw new ReferenceError("Can not divide a color")}divideInPlace(y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y.r,y.g,y.b)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y.r,y.g,y.b)}minimizeInPlaceFromFloats(y,S,I){return this.r=Math.min(y,this.r),this.g=Math.min(S,this.g),this.b=Math.min(I,this.b),this}maximizeInPlaceFromFloats(y,S,I){return this.r=Math.max(y,this.r),this.g=Math.max(S,this.g),this.b=Math.max(I,this.b),this}floorToRef(y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(y){return y&&this.r===y.r&&this.g===y.g&&this.b===y.b}equalsFloats(y,S,I){return this.equalsToFloats(y,S,I)}equalsToFloats(y,S,I){return this.r===y&&this.g===S&&this.b===I}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return(0,B.WithinEpsilon)(this.r,y.r,S)&&(0,B.WithinEpsilon)(this.g,y.g,S)&&(0,B.WithinEpsilon)(this.b,y.b,S)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(y){throw new ReferenceError("Can not negate a color")}scale(y){return new K(this.r*y,this.g*y,this.b*y)}scaleInPlace(y){return this.r*=y,this.g*=y,this.b*=y,this}scaleToRef(y,S){return S.r=this.r*y,S.g=this.g*y,S.b=this.b*y,S}scaleAndAddToRef(y,S){return S.r+=this.r*y,S.g+=this.g*y,S.b+=this.b*y,S}clampToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.r=(0,B.Clamp)(this.r,y,S),I.g=(0,B.Clamp)(this.g,y,S),I.b=(0,B.Clamp)(this.b,y,S),I}add(y){return new K(this.r+y.r,this.g+y.g,this.b+y.b)}addInPlace(y){return this.r+=y.r,this.g+=y.g,this.b+=y.b,this}addInPlaceFromFloats(y,S,I){return this.r+=y,this.g+=S,this.b+=I,this}addToRef(y,S){return S.r=this.r+y.r,S.g=this.g+y.g,S.b=this.b+y.b,S}fS(y){return new K(this.r-y.r,this.g-y.g,this.b-y.b)}subtractToRef(y,S){return S.r=this.r-y.r,S.g=this.g-y.g,S.b=this.b-y.b,S}uK(y){return this.r-=y.r,this.g-=y.g,this.b-=y.b,this}subtractFromFloats(y,S,I){return new K(this.r-y,this.g-S,this.b-I)}subtractFromFloatsToRef(y,S,I,V){return V.r=this.r-y,V.g=this.g-S,V.b=this.b-I,V}clone(){return new K(this.r,this.g,this.b)}A(y){return this.r=y.r,this.g=y.g,this.b=y.b,this}od(y,S,I){return this.r=y,this.g=S,this.b=I,this}set(y,S,I){return this.od(y,S,I)}nd(y){return this.r=this.g=this.b=y,this}toHexString(){const y=Math.round(255*this.r),S=Math.round(255*this.g),I=Math.round(255*this.b);return"#"+(0,B.ToHex)(y)+(0,B.ToHex)(S)+(0,B.ToHex)(I)}fromHexString(y){return"#"!==y.substring(0,1)||7!==y.length||(this.r=parseInt(y.substring(1,3),16)/255,this.g=parseInt(y.substring(3,5),16)/255,this.b=parseInt(y.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new K)}toHSVToRef(y){const S=this.r,I=this.g,V=this.b,i=Math.max(S,I,V),A=Math.min(S,I,V);let B=0,d=0;const F=i,J=i-A;return 0!==i&&(d=J/i),i!=A&&(i==S?(B=(I-V)/J,I<V&&(B+=6)):i==I?B=(V-S)/J+2:i==V&&(B=(S-I)/J+4),B*=60),y.r=B,y.g=d,y.b=F,y}toLinearSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new K;return this.toLinearSpaceToRef(S,y),S}toLinearSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=F(this.r),y.g=F(this.g),y.b=F(this.b)):(y.r=d(this.r),y.g=d(this.g),y.b=d(this.b)),this}toGammaSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new K;return this.toGammaSpaceToRef(S,y),S}toGammaSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=u(this.r),y.g=u(this.g),y.b=u(this.b)):(y.r=J(this.r),y.g=J(this.g),y.b=J(this.b)),this}static HSVtoRGBToRef(y,S,I,V){const i=I*S,A=y/60,B=i*(1-Math.abs(A%2-1));let d=0,F=0,J=0;A>=0&&A<=1?(d=i,F=B):A>=1&&A<=2?(d=B,F=i):A>=2&&A<=3?(F=i,J=B):A>=3&&A<=4?(F=B,J=i):A>=4&&A<=5?(d=B,J=i):A>=5&&A<=6&&(d=i,J=B);const u=I-i;return V.r=d+u,V.g=F+u,V.b=J+u,V}static FromHSV(y,S,I){const V=new K(0,0,0);return K.HSVtoRGBToRef(y,S,I,V),V}static FromHexString(y){return new K(0,0,0).fromHexString(y)}static oS(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(y[S],y[S+1],y[S+2])}static FromArrayToRef(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2?arguments[2]:void 0;I.r=y[S],I.g=y[S+1],I.b=y[S+2]}static FromInts(y,S,I){return new K(y/255,S/255,I/255)}static Lerp(y,S,I){const V=new K(0,0,0);return K.LerpToRef(y,S,I,V),V}static LerpToRef(y,S,I,V){V.r=y.r+(S.r-y.r)*I,V.g=y.g+(S.g-y.g)*I,V.b=y.b+(S.b-y.b)*I}static Hermite(y,S,I,V,i){const A=i*i,B=i*A,d=2*B-3*A+1,F=-2*B+3*A,J=B-2*A+i,u=B-A,G=y.r*d+I.r*F+S.r*J+V.r*u,p=y.g*d+I.g*F+S.g*J+V.g*u,L=y.b*d+I.b*F+S.b*J+V.b*u;return new K(G,p,L)}static Hermite1stDerivative(y,S,I,V,i){const A=K.Black();return this.Hermite1stDerivativeToRef(y,S,I,V,i,A),A}static Hermite1stDerivativeToRef(y,S,I,V,i,A){const B=i*i;A.r=6*(B-i)*y.r+(3*B-4*i+1)*S.r+6*(-B+i)*I.r+(3*B-2*i)*V.r,A.g=6*(B-i)*y.g+(3*B-4*i+1)*S.g+6*(-B+i)*I.g+(3*B-2*i)*V.g,A.b=6*(B-i)*y.b+(3*B-4*i+1)*S.b+6*(-B+i)*I.b+(3*B-2*i)*V.b}static Red(){return new K(1,0,0)}static Green(){return new K(0,1,0)}static Blue(){return new K(0,0,1)}static Black(){return new K(0,0,0)}static get BlackReadOnly(){return K._BlackReadOnly}static White(){return new K(1,1,1)}static Purple(){return new K(.5,0,.5)}static Magenta(){return new K(1,0,1)}static Yellow(){return new K(1,1,0)}static Gray(){return new K(.5,.5,.5)}static Teal(){return new K(0,1,1)}static Random(){return new K(Math.random(),Math.random(),Math.random())}}K._V8PerformanceHack=new K(.5,.5,.5),K._BlackReadOnly=K.Black(),Object.defineProperties(K.prototype,{dimension:{value:[3]},rank:{value:1}});class G{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=y,this.g=S,this.b=I,this.a=V}Vd(){return[this.r,this.g,this.b,this.a]}toArray(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[S]=this.r,y[S+1]=this.g,y[S+2]=this.b,y[S+3]=this.a,this}sI(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=y[S],this.g=y[S+1],this.b=y[S+2],this.a=y[S+3],this}equals(y){return y&&this.r===y.r&&this.g===y.g&&this.b===y.b&&this.a===y.a}add(y){return new G(this.r+y.r,this.g+y.g,this.b+y.b,this.a+y.a)}addToRef(y,S){return S.r=this.r+y.r,S.g=this.g+y.g,S.b=this.b+y.b,S.a=this.a+y.a,S}addInPlace(y){return this.r+=y.r,this.g+=y.g,this.b+=y.b,this.a+=y.a,this}addInPlaceFromFloats(y,S,I,V){return this.r+=y,this.g+=S,this.b+=I,this.a+=V,this}fS(y){return new G(this.r-y.r,this.g-y.g,this.b-y.b,this.a-y.a)}subtractToRef(y,S){return S.r=this.r-y.r,S.g=this.g-y.g,S.b=this.b-y.b,S.a=this.a-y.a,S}uK(y){return this.r-=y.r,this.g-=y.g,this.b-=y.b,this.a-=y.a,this}subtractFromFloats(y,S,I,V){return new G(this.r-y,this.g-S,this.b-I,this.a-V)}subtractFromFloatsToRef(y,S,I,V,i){return i.r=this.r-y,i.g=this.g-S,i.b=this.b-I,i.a=this.a-V,i}scale(y){return new G(this.r*y,this.g*y,this.b*y,this.a*y)}scaleInPlace(y){return this.r*=y,this.g*=y,this.b*=y,this.a*=y,this}scaleToRef(y,S){return S.r=this.r*y,S.g=this.g*y,S.b=this.b*y,S.a=this.a*y,S}scaleAndAddToRef(y,S){return S.r+=this.r*y,S.g+=this.g*y,S.b+=this.b*y,S.a+=this.a*y,S}clampToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.r=(0,B.Clamp)(this.r,y,S),I.g=(0,B.Clamp)(this.g,y,S),I.b=(0,B.Clamp)(this.b,y,S),I.a=(0,B.Clamp)(this.a,y,S),I}multiply(y){return new G(this.r*y.r,this.g*y.g,this.b*y.b,this.a*y.a)}multiplyToRef(y,S){return S.r=this.r*y.r,S.g=this.g*y.g,S.b=this.b*y.b,S.a=this.a*y.a,S}multiplyInPlace(y){return this.r*=y.r,this.g*=y.g,this.b*=y.b,this.a*=y.a,this}multiplyByFloats(y,S,I,V){return new G(this.r*y,this.g*S,this.b*I,this.a*V)}divide(y){throw new ReferenceError("Can not divide a color")}divideToRef(y,S){throw new ReferenceError("Can not divide a color")}divideInPlace(y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(y){return this.r=Math.min(this.r,y.r),this.g=Math.min(this.g,y.g),this.b=Math.min(this.b,y.b),this.a=Math.min(this.a,y.a),this}maximizeInPlace(y){return this.r=Math.max(this.r,y.r),this.g=Math.max(this.g,y.g),this.b=Math.max(this.b,y.b),this.a=Math.max(this.a,y.a),this}minimizeInPlaceFromFloats(y,S,I,V){return this.r=Math.min(y,this.r),this.g=Math.min(S,this.g),this.b=Math.min(I,this.b),this.a=Math.min(V,this.a),this}maximizeInPlaceFromFloats(y,S,I,V){return this.r=Math.max(y,this.r),this.g=Math.max(S,this.g),this.b=Math.max(I,this.b),this.a=Math.max(V,this.a),this}floorToRef(y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(y){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:A.c;return(0,B.WithinEpsilon)(this.r,y.r,S)&&(0,B.WithinEpsilon)(this.g,y.g,S)&&(0,B.WithinEpsilon)(this.b,y.b,S)&&(0,B.WithinEpsilon)(this.a,y.a,S)}equalsToFloats(y,S,I,V){return this.r===y&&this.g===S&&this.b===I&&this.a===V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"vd"}getHashCode(){let y=255*this.r|0;return y=397*y^255*this.g,y=397*y^255*this.b,y=397*y^255*this.a,y}clone(){return(new G).A(this)}A(y){return this.r=y.r,this.g=y.g,this.b=y.b,this.a=y.a,this}od(y,S,I,V){return this.r=y,this.g=S,this.b=I,this.a=V,this}set(y,S,I,V){return this.od(y,S,I,V)}nd(y){return this.r=this.g=this.b=this.a=y,this}toHexString(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=Math.round(255*this.r),I=Math.round(255*this.g),V=Math.round(255*this.b);if(y)return"#"+(0,B.ToHex)(S)+(0,B.ToHex)(I)+(0,B.ToHex)(V);const i=Math.round(255*this.a);return"#"+(0,B.ToHex)(S)+(0,B.ToHex)(I)+(0,B.ToHex)(V)+(0,B.ToHex)(i)}fromHexString(y){return"#"!==y.substring(0,1)||9!==y.length&&7!==y.length||(this.r=parseInt(y.substring(1,3),16)/255,this.g=parseInt(y.substring(3,5),16)/255,this.b=parseInt(y.substring(5,7),16)/255,9===y.length&&(this.a=parseInt(y.substring(7,9),16)/255)),this}toLinearSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new G;return this.toLinearSpaceToRef(S,y),S}toLinearSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=F(this.r),y.g=F(this.g),y.b=F(this.b)):(y.r=d(this.r),y.g=d(this.g),y.b=d(this.b)),y.a=this.a,this}toGammaSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new G;return this.toGammaSpaceToRef(S,y),S}toGammaSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=u(this.r),y.g=u(this.g),y.b=u(this.b)):(y.r=J(this.r),y.g=J(this.g),y.b=J(this.b)),y.a=this.a,this}static FromHexString(y){return"#"!==y.substring(0,1)||9!==y.length&&7!==y.length?new G(0,0,0,0):new G(0,0,0,1).fromHexString(y)}static Lerp(y,S,I){return G.LerpToRef(y,S,I,new G)}static LerpToRef(y,S,I,V){return V.r=y.r+(S.r-y.r)*I,V.g=y.g+(S.g-y.g)*I,V.b=y.b+(S.b-y.b)*I,V.a=y.a+(S.a-y.a)*I,V}static Hermite(y,S,I,V,i){const A=i*i,B=i*A,d=2*B-3*A+1,F=-2*B+3*A,J=B-2*A+i,u=B-A,K=y.r*d+I.r*F+S.r*J+V.r*u,p=y.g*d+I.g*F+S.g*J+V.g*u,L=y.b*d+I.b*F+S.b*J+V.b*u,T=y.a*d+I.a*F+S.a*J+V.a*u;return new G(K,p,L,T)}static Hermite1stDerivative(y,S,I,V,i){const A=new G;return this.Hermite1stDerivativeToRef(y,S,I,V,i,A),A}static Hermite1stDerivativeToRef(y,S,I,V,i,A){const B=i*i;A.r=6*(B-i)*y.r+(3*B-4*i+1)*S.r+6*(-B+i)*I.r+(3*B-2*i)*V.r,A.g=6*(B-i)*y.g+(3*B-4*i+1)*S.g+6*(-B+i)*I.g+(3*B-2*i)*V.g,A.b=6*(B-i)*y.b+(3*B-4*i+1)*S.b+6*(-B+i)*I.b+(3*B-2*i)*V.b,A.a=6*(B-i)*y.a+(3*B-4*i+1)*S.a+6*(-B+i)*I.a+(3*B-2*i)*V.a}static FromColor3(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G(y.r,y.g,y.b,S)}static oS(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(y[S],y[S+1],y[S+2],y[S+3])}static FromArrayToRef(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2?arguments[2]:void 0;I.r=y[S],I.g=y[S+1],I.b=y[S+2],I.a=y[S+3]}static FromInts(y,S,I,V){return new G(y/255,S/255,I/255,V/255)}static CheckColors4(y,S){if(y.length===3*S){const S=[];for(let I=0;I<y.length;I+=3){const V=I/3*4;S[V]=y[I],S[V+1]=y[I+1],S[V+2]=y[I+2],S[V+3]=1}return S}return y}}G._V8PerformanceHack=new G(.5,.5,.5,.5),Object.defineProperties(G.prototype,{dimension:{value:[4]},rank:{value:1}});class p{}p.DS=(0,V.e)(3,K.Black),p.vd=(0,V.e)(3,(()=>new G(0,0,0,0))),(0,i.e)("BABYLON.Color3",K),(0,i.e)("BABYLON.Color4",G)}}]);