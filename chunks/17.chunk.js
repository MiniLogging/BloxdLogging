"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[17],{12547:(o,v,V)=>{V.r(v),V.d(v,{Lv:()=>x,sU:()=>f,TmpColors:()=>l});var g=V(12503),E=V(12449),I=V(12497),Q=V(12511);function U(o){return Math.pow(o,I.k)}function n(o){return o<=.04045?.0773993808*o:Math.pow(.947867299*(o+.055),2.4)}function O(o){return Math.pow(o,I.i)}function h(o){return o<=.0031308?12.92*o:1.055*Math.pow(o,.41666)-.055}class x{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=o,this.g=v,this.b=V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Lv"}getHashCode(){let o=255*this.r|0;return o=397*o^255*this.g,o=397*o^255*this.b,o}toArray(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[v]=this.r,o[v+1]=this.g,o[v+2]=this.b,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return x.FromArrayToRef(o,v,this),this}toColor4(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new f(this.r,this.g,this.b,o)}Dg(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(o){return new x(this.r*o.r,this.g*o.g,this.b*o.b)}multiplyToRef(o,v){return v.r=this.r*o.r,v.g=this.g*o.g,v.b=this.b*o.b,v}multiplyInPlace(o){return this.r*=o.r,this.g*=o.g,this.b*=o.b,this}multiplyByFloats(o,v,V){return new x(this.r*o,this.g*v,this.b*V)}divide(o){throw new ReferenceError("Can not divide a color")}divideToRef(o,v){throw new ReferenceError("Can not divide a color")}divideInPlace(o){throw new ReferenceError("Can not divide a color")}minimizeInPlace(o){return this.minimizeInPlaceFromFloats(o.r,o.g,o.b)}maximizeInPlace(o){return this.maximizeInPlaceFromFloats(o.r,o.g,o.b)}minimizeInPlaceFromFloats(o,v,V){return this.r=Math.min(o,this.r),this.g=Math.min(v,this.g),this.b=Math.min(V,this.b),this}maximizeInPlaceFromFloats(o,v,V){return this.r=Math.max(o,this.r),this.g=Math.max(v,this.g),this.b=Math.max(V,this.b),this}floorToRef(o){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(o){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(o){return o&&this.r===o.r&&this.g===o.g&&this.b===o.b}equalsFloats(o,v,V){return this.equalsToFloats(o,v,V)}equalsToFloats(o,v,V){return this.r===o&&this.g===v&&this.b===V}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.d;return(0,Q.WithinEpsilon)(this.r,o.r,v)&&(0,Q.WithinEpsilon)(this.g,o.g,v)&&(0,Q.WithinEpsilon)(this.b,o.b,v)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(o){throw new ReferenceError("Can not negate a color")}scale(o){return new x(this.r*o,this.g*o,this.b*o)}scaleInPlace(o){return this.r*=o,this.g*=o,this.b*=o,this}scaleToRef(o,v){return v.r=this.r*o,v.g=this.g*o,v.b=this.b*o,v}scaleAndAddToRef(o,v){return v.r+=this.r*o,v.g+=this.g*o,v.b+=this.b*o,v}clampToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,Q.Clamp)(this.r,o,v),V.g=(0,Q.Clamp)(this.g,o,v),V.b=(0,Q.Clamp)(this.b,o,v),V}add(o){return new x(this.r+o.r,this.g+o.g,this.b+o.b)}addInPlace(o){return this.r+=o.r,this.g+=o.g,this.b+=o.b,this}addInPlaceFromFloats(o,v,V){return this.r+=o,this.g+=v,this.b+=V,this}addToRef(o,v){return v.r=this.r+o.r,v.g=this.g+o.g,v.b=this.b+o.b,v}Rv(o){return new x(this.r-o.r,this.g-o.g,this.b-o.b)}subtractToRef(o,v){return v.r=this.r-o.r,v.g=this.g-o.g,v.b=this.b-o.b,v}Lx(o){return this.r-=o.r,this.g-=o.g,this.b-=o.b,this}subtractFromFloats(o,v,V){return new x(this.r-o,this.g-v,this.b-V)}subtractFromFloatsToRef(o,v,V,g){return g.r=this.r-o,g.g=this.g-v,g.b=this.b-V,g}clone(){return new x(this.r,this.g,this.b)}U(o){return this.r=o.r,this.g=o.g,this.b=o.b,this}RU(o,v,V){return this.r=o,this.g=v,this.b=V,this}set(o,v,V){return this.RU(o,v,V)}tU(o){return this.r=this.g=this.b=o,this}toHexString(){const o=Math.round(255*this.r),v=Math.round(255*this.g),V=Math.round(255*this.b);return"#"+(0,Q.ToHex)(o)+(0,Q.ToHex)(v)+(0,Q.ToHex)(V)}fromHexString(o){return"#"!==o.substring(0,1)||7!==o.length||(this.r=parseInt(o.substring(1,3),16)/255,this.g=parseInt(o.substring(3,5),16)/255,this.b=parseInt(o.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new x)}toHSVToRef(o){const v=this.r,V=this.g,g=this.b,E=Math.max(v,V,g),I=Math.min(v,V,g);let Q=0,U=0;const n=E,O=E-I;return 0!==E&&(U=O/E),E!=I&&(E==v?(Q=(V-g)/O,V<g&&(Q+=6)):E==V?Q=(g-v)/O+2:E==g&&(Q=(v-V)/O+4),Q*=60),o.r=Q,o.g=U,o.b=n,o}toLinearSpace(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new x;return this.toLinearSpaceToRef(v,o),v}toLinearSpaceToRef(o){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(o.r=n(this.r),o.g=n(this.g),o.b=n(this.b)):(o.r=U(this.r),o.g=U(this.g),o.b=U(this.b)),this}toGammaSpace(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new x;return this.toGammaSpaceToRef(v,o),v}toGammaSpaceToRef(o){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(o.r=h(this.r),o.g=h(this.g),o.b=h(this.b)):(o.r=O(this.r),o.g=O(this.g),o.b=O(this.b)),this}static HSVtoRGBToRef(o,v,V,g){const E=V*v,I=o/60,Q=E*(1-Math.abs(I%2-1));let U=0,n=0,O=0;I>=0&&I<=1?(U=E,n=Q):I>=1&&I<=2?(U=Q,n=E):I>=2&&I<=3?(n=E,O=Q):I>=3&&I<=4?(n=Q,O=E):I>=4&&I<=5?(U=Q,O=E):I>=5&&I<=6&&(U=E,O=Q);const h=V-E;return g.r=U+h,g.g=n+h,g.b=O+h,g}static FromHSV(o,v,V){const g=new x(0,0,0);return x.HSVtoRGBToRef(o,v,V,g),g}static FromHexString(o){return new x(0,0,0).fromHexString(o)}static bv(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(o[v],o[v+1],o[v+2])}static FromArrayToRef(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=o[v],V.g=o[v+1],V.b=o[v+2]}static FromInts(o,v,V){return new x(o/255,v/255,V/255)}static Lerp(o,v,V){const g=new x(0,0,0);return x.LerpToRef(o,v,V,g),g}static LerpToRef(o,v,V,g){g.r=o.r+(v.r-o.r)*V,g.g=o.g+(v.g-o.g)*V,g.b=o.b+(v.b-o.b)*V}static Hermite(o,v,V,g,E){const I=E*E,Q=E*I,U=2*Q-3*I+1,n=-2*Q+3*I,O=Q-2*I+E,h=Q-I,f=o.r*U+V.r*n+v.r*O+g.r*h,l=o.g*U+V.g*n+v.g*O+g.g*h,S=o.b*U+V.b*n+v.b*O+g.b*h;return new x(f,l,S)}static Hermite1stDerivative(o,v,V,g,E){const I=x.Black();return this.Hermite1stDerivativeToRef(o,v,V,g,E,I),I}static Hermite1stDerivativeToRef(o,v,V,g,E,I){const Q=E*E;I.r=6*(Q-E)*o.r+(3*Q-4*E+1)*v.r+6*(-Q+E)*V.r+(3*Q-2*E)*g.r,I.g=6*(Q-E)*o.g+(3*Q-4*E+1)*v.g+6*(-Q+E)*V.g+(3*Q-2*E)*g.g,I.b=6*(Q-E)*o.b+(3*Q-4*E+1)*v.b+6*(-Q+E)*V.b+(3*Q-2*E)*g.b}static Red(){return new x(1,0,0)}static Green(){return new x(0,1,0)}static Blue(){return new x(0,0,1)}static Black(){return new x(0,0,0)}static get BlackReadOnly(){return x._BlackReadOnly}static White(){return new x(1,1,1)}static Purple(){return new x(.5,0,.5)}static Magenta(){return new x(1,0,1)}static Yellow(){return new x(1,1,0)}static Gray(){return new x(.5,.5,.5)}static Teal(){return new x(0,1,1)}static Random(){return new x(Math.random(),Math.random(),Math.random())}}x._V8PerformanceHack=new x(.5,.5,.5),x._BlackReadOnly=x.Black(),Object.defineProperties(x.prototype,{dimension:{value:[3]},rank:{value:1}});class f{constructor(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=o,this.g=v,this.b=V,this.a=g}Dg(){return[this.r,this.g,this.b,this.a]}toArray(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o[v]=this.r,o[v+1]=this.g,o[v+2]=this.b,o[v+3]=this.a,this}RV(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=o[v],this.g=o[v+1],this.b=o[v+2],this.a=o[v+3],this}equals(o){return o&&this.r===o.r&&this.g===o.g&&this.b===o.b&&this.a===o.a}add(o){return new f(this.r+o.r,this.g+o.g,this.b+o.b,this.a+o.a)}addToRef(o,v){return v.r=this.r+o.r,v.g=this.g+o.g,v.b=this.b+o.b,v.a=this.a+o.a,v}addInPlace(o){return this.r+=o.r,this.g+=o.g,this.b+=o.b,this.a+=o.a,this}addInPlaceFromFloats(o,v,V,g){return this.r+=o,this.g+=v,this.b+=V,this.a+=g,this}Rv(o){return new f(this.r-o.r,this.g-o.g,this.b-o.b,this.a-o.a)}subtractToRef(o,v){return v.r=this.r-o.r,v.g=this.g-o.g,v.b=this.b-o.b,v.a=this.a-o.a,v}Lx(o){return this.r-=o.r,this.g-=o.g,this.b-=o.b,this.a-=o.a,this}subtractFromFloats(o,v,V,g){return new f(this.r-o,this.g-v,this.b-V,this.a-g)}subtractFromFloatsToRef(o,v,V,g,E){return E.r=this.r-o,E.g=this.g-v,E.b=this.b-V,E.a=this.a-g,E}scale(o){return new f(this.r*o,this.g*o,this.b*o,this.a*o)}scaleInPlace(o){return this.r*=o,this.g*=o,this.b*=o,this.a*=o,this}scaleToRef(o,v){return v.r=this.r*o,v.g=this.g*o,v.b=this.b*o,v.a=this.a*o,v}scaleAndAddToRef(o,v){return v.r+=this.r*o,v.g+=this.g*o,v.b+=this.b*o,v.a+=this.a*o,v}clampToRef(){let o=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,Q.Clamp)(this.r,o,v),V.g=(0,Q.Clamp)(this.g,o,v),V.b=(0,Q.Clamp)(this.b,o,v),V.a=(0,Q.Clamp)(this.a,o,v),V}multiply(o){return new f(this.r*o.r,this.g*o.g,this.b*o.b,this.a*o.a)}multiplyToRef(o,v){return v.r=this.r*o.r,v.g=this.g*o.g,v.b=this.b*o.b,v.a=this.a*o.a,v}multiplyInPlace(o){return this.r*=o.r,this.g*=o.g,this.b*=o.b,this.a*=o.a,this}multiplyByFloats(o,v,V,g){return new f(this.r*o,this.g*v,this.b*V,this.a*g)}divide(o){throw new ReferenceError("Can not divide a color")}divideToRef(o,v){throw new ReferenceError("Can not divide a color")}divideInPlace(o){throw new ReferenceError("Can not divide a color")}minimizeInPlace(o){return this.r=Math.min(this.r,o.r),this.g=Math.min(this.g,o.g),this.b=Math.min(this.b,o.b),this.a=Math.min(this.a,o.a),this}maximizeInPlace(o){return this.r=Math.max(this.r,o.r),this.g=Math.max(this.g,o.g),this.b=Math.max(this.b,o.b),this.a=Math.max(this.a,o.a),this}minimizeInPlaceFromFloats(o,v,V,g){return this.r=Math.min(o,this.r),this.g=Math.min(v,this.g),this.b=Math.min(V,this.b),this.a=Math.min(g,this.a),this}maximizeInPlaceFromFloats(o,v,V,g){return this.r=Math.max(o,this.r),this.g=Math.max(v,this.g),this.b=Math.max(V,this.b),this.a=Math.max(g,this.a),this}floorToRef(o){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(o){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(o){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.d;return(0,Q.WithinEpsilon)(this.r,o.r,v)&&(0,Q.WithinEpsilon)(this.g,o.g,v)&&(0,Q.WithinEpsilon)(this.b,o.b,v)&&(0,Q.WithinEpsilon)(this.a,o.a,v)}equalsToFloats(o,v,V,g){return this.r===o&&this.g===v&&this.b===V&&this.a===g}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"sU"}getHashCode(){let o=255*this.r|0;return o=397*o^255*this.g,o=397*o^255*this.b,o=397*o^255*this.a,o}clone(){return(new f).U(this)}U(o){return this.r=o.r,this.g=o.g,this.b=o.b,this.a=o.a,this}RU(o,v,V,g){return this.r=o,this.g=v,this.b=V,this.a=g,this}set(o,v,V,g){return this.RU(o,v,V,g)}tU(o){return this.r=this.g=this.b=this.a=o,this}toHexString(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=Math.round(255*this.r),V=Math.round(255*this.g),g=Math.round(255*this.b);if(o)return"#"+(0,Q.ToHex)(v)+(0,Q.ToHex)(V)+(0,Q.ToHex)(g);const E=Math.round(255*this.a);return"#"+(0,Q.ToHex)(v)+(0,Q.ToHex)(V)+(0,Q.ToHex)(g)+(0,Q.ToHex)(E)}fromHexString(o){return"#"!==o.substring(0,1)||9!==o.length&&7!==o.length||(this.r=parseInt(o.substring(1,3),16)/255,this.g=parseInt(o.substring(3,5),16)/255,this.b=parseInt(o.substring(5,7),16)/255,9===o.length&&(this.a=parseInt(o.substring(7,9),16)/255)),this}toLinearSpace(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new f;return this.toLinearSpaceToRef(v,o),v}toLinearSpaceToRef(o){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(o.r=n(this.r),o.g=n(this.g),o.b=n(this.b)):(o.r=U(this.r),o.g=U(this.g),o.b=U(this.b)),o.a=this.a,this}toGammaSpace(){let o=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new f;return this.toGammaSpaceToRef(v,o),v}toGammaSpaceToRef(o){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(o.r=h(this.r),o.g=h(this.g),o.b=h(this.b)):(o.r=O(this.r),o.g=O(this.g),o.b=O(this.b)),o.a=this.a,this}static FromHexString(o){return"#"!==o.substring(0,1)||9!==o.length&&7!==o.length?new f(0,0,0,0):new f(0,0,0,1).fromHexString(o)}static Lerp(o,v,V){return f.LerpToRef(o,v,V,new f)}static LerpToRef(o,v,V,g){return g.r=o.r+(v.r-o.r)*V,g.g=o.g+(v.g-o.g)*V,g.b=o.b+(v.b-o.b)*V,g.a=o.a+(v.a-o.a)*V,g}static Hermite(o,v,V,g,E){const I=E*E,Q=E*I,U=2*Q-3*I+1,n=-2*Q+3*I,O=Q-2*I+E,h=Q-I,x=o.r*U+V.r*n+v.r*O+g.r*h,l=o.g*U+V.g*n+v.g*O+g.g*h,S=o.b*U+V.b*n+v.b*O+g.b*h,T=o.a*U+V.a*n+v.a*O+g.a*h;return new f(x,l,S,T)}static Hermite1stDerivative(o,v,V,g,E){const I=new f;return this.Hermite1stDerivativeToRef(o,v,V,g,E,I),I}static Hermite1stDerivativeToRef(o,v,V,g,E,I){const Q=E*E;I.r=6*(Q-E)*o.r+(3*Q-4*E+1)*v.r+6*(-Q+E)*V.r+(3*Q-2*E)*g.r,I.g=6*(Q-E)*o.g+(3*Q-4*E+1)*v.g+6*(-Q+E)*V.g+(3*Q-2*E)*g.g,I.b=6*(Q-E)*o.b+(3*Q-4*E+1)*v.b+6*(-Q+E)*V.b+(3*Q-2*E)*g.b,I.a=6*(Q-E)*o.a+(3*Q-4*E+1)*v.a+6*(-Q+E)*V.a+(3*Q-2*E)*g.a}static FromColor3(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new f(o.r,o.g,o.b,v)}static bv(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new f(o[v],o[v+1],o[v+2],o[v+3])}static FromArrayToRef(o){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=o[v],V.g=o[v+1],V.b=o[v+2],V.a=o[v+3]}static FromInts(o,v,V,g){return new f(o/255,v/255,V/255,g/255)}static CheckColors4(o,v){if(o.length===3*v){const v=[];for(let V=0;V<o.length;V+=3){const g=V/3*4;v[g]=o[V],v[g+1]=o[V+1],v[g+2]=o[V+2],v[g+3]=1}return v}return o}}f._V8PerformanceHack=new f(.5,.5,.5,.5),Object.defineProperties(f.prototype,{dimension:{value:[4]},rank:{value:1}});class l{}l.Lv=(0,g.b)(3,x.Black),l.sU=(0,g.b)(3,(()=>new f(0,0,0,0))),(0,E.h)("BABYLON.Color3",x),(0,E.h)("BABYLON.Color4",f)}}]);