"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[17],{11879:(C,U,K)=>{K.r(U),K.d(U,{fU:()=>p,ve:()=>E,TmpColors:()=>u});var m=K(11844),O=K(11789),X=K(11835),A=K(11846);function e(C){return Math.pow(C,X.j)}function t(C){return C<=.04045?.0773993808*C:Math.pow(.947867299*(C+.055),2.4)}function z(C){return Math.pow(C,X.i)}function j(C){return C<=.0031308?12.92*C:1.055*Math.pow(C,.41666)-.055}class p{constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=C,this.g=U,this.b=K}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"fU"}getHashCode(){let C=255*this.r|0;return C=397*C^255*this.g,C=397*C^255*this.b,C}toArray(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C[U]=this.r,C[U+1]=this.g,C[U+2]=this.b,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(C,U,this),this}toColor4(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new E(this.r,this.g,this.b,C)}Oe(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(C){return new p(this.r*C.r,this.g*C.g,this.b*C.b)}multiplyToRef(C,U){return U.r=this.r*C.r,U.g=this.g*C.g,U.b=this.b*C.b,U}multiplyInPlace(C){return this.r*=C.r,this.g*=C.g,this.b*=C.b,this}multiplyByFloats(C,U,K){return new p(this.r*C,this.g*U,this.b*K)}divide(C){throw new ReferenceError("Can not divide a color")}divideToRef(C,U){throw new ReferenceError("Can not divide a color")}divideInPlace(C){throw new ReferenceError("Can not divide a color")}minimizeInPlace(C){return this.minimizeInPlaceFromFloats(C.r,C.g,C.b)}maximizeInPlace(C){return this.maximizeInPlaceFromFloats(C.r,C.g,C.b)}minimizeInPlaceFromFloats(C,U,K){return this.r=Math.min(C,this.r),this.g=Math.min(U,this.g),this.b=Math.min(K,this.b),this}maximizeInPlaceFromFloats(C,U,K){return this.r=Math.max(C,this.r),this.g=Math.max(U,this.g),this.b=Math.max(K,this.b),this}floorToRef(C){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(C){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(C){return C&&this.r===C.r&&this.g===C.g&&this.b===C.b}equalsFloats(C,U,K){return this.equalsToFloats(C,U,K)}equalsToFloats(C,U,K){return this.r===C&&this.g===U&&this.b===K}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:X.d;return(0,A.WithinEpsilon)(this.r,C.r,U)&&(0,A.WithinEpsilon)(this.g,C.g,U)&&(0,A.WithinEpsilon)(this.b,C.b,U)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(C){throw new ReferenceError("Can not negate a color")}scale(C){return new p(this.r*C,this.g*C,this.b*C)}scaleInPlace(C){return this.r*=C,this.g*=C,this.b*=C,this}scaleToRef(C,U){return U.r=this.r*C,U.g=this.g*C,U.b=this.b*C,U}scaleAndAddToRef(C,U){return U.r+=this.r*C,U.g+=this.g*C,U.b+=this.b*C,U}clampToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,K=arguments.length>2?arguments[2]:void 0;return K.r=(0,A.Clamp)(this.r,C,U),K.g=(0,A.Clamp)(this.g,C,U),K.b=(0,A.Clamp)(this.b,C,U),K}add(C){return new p(this.r+C.r,this.g+C.g,this.b+C.b)}addInPlace(C){return this.r+=C.r,this.g+=C.g,this.b+=C.b,this}addInPlaceFromFloats(C,U,K){return this.r+=C,this.g+=U,this.b+=K,this}addToRef(C,U){return U.r=this.r+C.r,U.g=this.g+C.g,U.b=this.b+C.b,U}vU(C){return new p(this.r-C.r,this.g-C.g,this.b-C.b)}subtractToRef(C,U){return U.r=this.r-C.r,U.g=this.g-C.g,U.b=this.b-C.b,U}zp(C){return this.r-=C.r,this.g-=C.g,this.b-=C.b,this}subtractFromFloats(C,U,K){return new p(this.r-C,this.g-U,this.b-K)}subtractFromFloatsToRef(C,U,K,m){return m.r=this.r-C,m.g=this.g-U,m.b=this.b-K,m}clone(){return new p(this.r,this.g,this.b)}m(C){return this.r=C.r,this.g=C.g,this.b=C.b,this}Ee(C,U,K){return this.r=C,this.g=U,this.b=K,this}set(C,U,K){return this.Ee(C,U,K)}be(C){return this.r=this.g=this.b=C,this}toHexString(){const C=Math.round(255*this.r),U=Math.round(255*this.g),K=Math.round(255*this.b);return"#"+(0,A.ToHex)(C)+(0,A.ToHex)(U)+(0,A.ToHex)(K)}fromHexString(C){return"#"!==C.substring(0,1)||7!==C.length||(this.r=parseInt(C.substring(1,3),16)/255,this.g=parseInt(C.substring(3,5),16)/255,this.b=parseInt(C.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new p)}toHSVToRef(C){const U=this.r,K=this.g,m=this.b,O=Math.max(U,K,m),X=Math.min(U,K,m);let A=0,e=0;const t=O,z=O-X;return 0!==O&&(e=z/O),O!=X&&(O==U?(A=(K-m)/z,K<m&&(A+=6)):O==K?A=(m-U)/z+2:O==m&&(A=(U-K)/z+4),A*=60),C.r=A,C.g=e,C.b=t,C}toLinearSpace(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new p;return this.toLinearSpaceToRef(U,C),U}toLinearSpaceToRef(C){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(C.r=t(this.r),C.g=t(this.g),C.b=t(this.b)):(C.r=e(this.r),C.g=e(this.g),C.b=e(this.b)),this}toGammaSpace(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new p;return this.toGammaSpaceToRef(U,C),U}toGammaSpaceToRef(C){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(C.r=j(this.r),C.g=j(this.g),C.b=j(this.b)):(C.r=z(this.r),C.g=z(this.g),C.b=z(this.b)),this}static HSVtoRGBToRef(C,U,K,m){const O=K*U,X=C/60,A=O*(1-Math.abs(X%2-1));let e=0,t=0,z=0;X>=0&&X<=1?(e=O,t=A):X>=1&&X<=2?(e=A,t=O):X>=2&&X<=3?(t=O,z=A):X>=3&&X<=4?(t=A,z=O):X>=4&&X<=5?(e=A,z=O):X>=5&&X<=6&&(e=O,z=A);const j=K-O;return m.r=e+j,m.g=t+j,m.b=z+j,m}static FromHSV(C,U,K){const m=new p(0,0,0);return p.HSVtoRGBToRef(C,U,K,m),m}static FromHexString(C){return new p(0,0,0).fromHexString(C)}static FU(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(C[U],C[U+1],C[U+2])}static FromArrayToRef(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2?arguments[2]:void 0;K.r=C[U],K.g=C[U+1],K.b=C[U+2]}static FromInts(C,U,K){return new p(C/255,U/255,K/255)}static Lerp(C,U,K){const m=new p(0,0,0);return p.LerpToRef(C,U,K,m),m}static LerpToRef(C,U,K,m){m.r=C.r+(U.r-C.r)*K,m.g=C.g+(U.g-C.g)*K,m.b=C.b+(U.b-C.b)*K}static Hermite(C,U,K,m,O){const X=O*O,A=O*X,e=2*A-3*X+1,t=-2*A+3*X,z=A-2*X+O,j=A-X,E=C.r*e+K.r*t+U.r*z+m.r*j,u=C.g*e+K.g*t+U.g*z+m.g*j,b=C.b*e+K.b*t+U.b*z+m.b*j;return new p(E,u,b)}static Hermite1stDerivative(C,U,K,m,O){const X=p.Black();return this.Hermite1stDerivativeToRef(C,U,K,m,O,X),X}static Hermite1stDerivativeToRef(C,U,K,m,O,X){const A=O*O;X.r=6*(A-O)*C.r+(3*A-4*O+1)*U.r+6*(-A+O)*K.r+(3*A-2*O)*m.r,X.g=6*(A-O)*C.g+(3*A-4*O+1)*U.g+6*(-A+O)*K.g+(3*A-2*O)*m.g,X.b=6*(A-O)*C.b+(3*A-4*O+1)*U.b+6*(-A+O)*K.b+(3*A-2*O)*m.b}static Red(){return new p(1,0,0)}static Green(){return new p(0,1,0)}static Blue(){return new p(0,0,1)}static Black(){return new p(0,0,0)}static get BlackReadOnly(){return p._BlackReadOnly}static White(){return new p(1,1,1)}static Purple(){return new p(.5,0,.5)}static Magenta(){return new p(1,0,1)}static Yellow(){return new p(1,1,0)}static Gray(){return new p(.5,.5,.5)}static Teal(){return new p(0,1,1)}static Random(){return new p(Math.random(),Math.random(),Math.random())}}p._V8PerformanceHack=new p(.5,.5,.5),p._BlackReadOnly=p.Black(),Object.defineProperties(p.prototype,{dimension:{value:[3]},rank:{value:1}});class E{constructor(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=C,this.g=U,this.b=K,this.a=m}Oe(){return[this.r,this.g,this.b,this.a]}toArray(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return C[U]=this.r,C[U+1]=this.g,C[U+2]=this.b,C[U+3]=this.a,this}uK(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=C[U],this.g=C[U+1],this.b=C[U+2],this.a=C[U+3],this}equals(C){return C&&this.r===C.r&&this.g===C.g&&this.b===C.b&&this.a===C.a}add(C){return new E(this.r+C.r,this.g+C.g,this.b+C.b,this.a+C.a)}addToRef(C,U){return U.r=this.r+C.r,U.g=this.g+C.g,U.b=this.b+C.b,U.a=this.a+C.a,U}addInPlace(C){return this.r+=C.r,this.g+=C.g,this.b+=C.b,this.a+=C.a,this}addInPlaceFromFloats(C,U,K,m){return this.r+=C,this.g+=U,this.b+=K,this.a+=m,this}vU(C){return new E(this.r-C.r,this.g-C.g,this.b-C.b,this.a-C.a)}subtractToRef(C,U){return U.r=this.r-C.r,U.g=this.g-C.g,U.b=this.b-C.b,U.a=this.a-C.a,U}zp(C){return this.r-=C.r,this.g-=C.g,this.b-=C.b,this.a-=C.a,this}subtractFromFloats(C,U,K,m){return new E(this.r-C,this.g-U,this.b-K,this.a-m)}subtractFromFloatsToRef(C,U,K,m,O){return O.r=this.r-C,O.g=this.g-U,O.b=this.b-K,O.a=this.a-m,O}scale(C){return new E(this.r*C,this.g*C,this.b*C,this.a*C)}scaleInPlace(C){return this.r*=C,this.g*=C,this.b*=C,this.a*=C,this}scaleToRef(C,U){return U.r=this.r*C,U.g=this.g*C,U.b=this.b*C,U.a=this.a*C,U}scaleAndAddToRef(C,U){return U.r+=this.r*C,U.g+=this.g*C,U.b+=this.b*C,U.a+=this.a*C,U}clampToRef(){let C=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,K=arguments.length>2?arguments[2]:void 0;return K.r=(0,A.Clamp)(this.r,C,U),K.g=(0,A.Clamp)(this.g,C,U),K.b=(0,A.Clamp)(this.b,C,U),K.a=(0,A.Clamp)(this.a,C,U),K}multiply(C){return new E(this.r*C.r,this.g*C.g,this.b*C.b,this.a*C.a)}multiplyToRef(C,U){return U.r=this.r*C.r,U.g=this.g*C.g,U.b=this.b*C.b,U.a=this.a*C.a,U}multiplyInPlace(C){return this.r*=C.r,this.g*=C.g,this.b*=C.b,this.a*=C.a,this}multiplyByFloats(C,U,K,m){return new E(this.r*C,this.g*U,this.b*K,this.a*m)}divide(C){throw new ReferenceError("Can not divide a color")}divideToRef(C,U){throw new ReferenceError("Can not divide a color")}divideInPlace(C){throw new ReferenceError("Can not divide a color")}minimizeInPlace(C){return this.r=Math.min(this.r,C.r),this.g=Math.min(this.g,C.g),this.b=Math.min(this.b,C.b),this.a=Math.min(this.a,C.a),this}maximizeInPlace(C){return this.r=Math.max(this.r,C.r),this.g=Math.max(this.g,C.g),this.b=Math.max(this.b,C.b),this.a=Math.max(this.a,C.a),this}minimizeInPlaceFromFloats(C,U,K,m){return this.r=Math.min(C,this.r),this.g=Math.min(U,this.g),this.b=Math.min(K,this.b),this.a=Math.min(m,this.a),this}maximizeInPlaceFromFloats(C,U,K,m){return this.r=Math.max(C,this.r),this.g=Math.max(U,this.g),this.b=Math.max(K,this.b),this.a=Math.max(m,this.a),this}floorToRef(C){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(C){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(C){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:X.d;return(0,A.WithinEpsilon)(this.r,C.r,U)&&(0,A.WithinEpsilon)(this.g,C.g,U)&&(0,A.WithinEpsilon)(this.b,C.b,U)&&(0,A.WithinEpsilon)(this.a,C.a,U)}equalsToFloats(C,U,K,m){return this.r===C&&this.g===U&&this.b===K&&this.a===m}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ve"}getHashCode(){let C=255*this.r|0;return C=397*C^255*this.g,C=397*C^255*this.b,C=397*C^255*this.a,C}clone(){return(new E).m(this)}m(C){return this.r=C.r,this.g=C.g,this.b=C.b,this.a=C.a,this}Ee(C,U,K,m){return this.r=C,this.g=U,this.b=K,this.a=m,this}set(C,U,K,m){return this.Ee(C,U,K,m)}be(C){return this.r=this.g=this.b=this.a=C,this}toHexString(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=Math.round(255*this.r),K=Math.round(255*this.g),m=Math.round(255*this.b);if(C)return"#"+(0,A.ToHex)(U)+(0,A.ToHex)(K)+(0,A.ToHex)(m);const O=Math.round(255*this.a);return"#"+(0,A.ToHex)(U)+(0,A.ToHex)(K)+(0,A.ToHex)(m)+(0,A.ToHex)(O)}fromHexString(C){return"#"!==C.substring(0,1)||9!==C.length&&7!==C.length||(this.r=parseInt(C.substring(1,3),16)/255,this.g=parseInt(C.substring(3,5),16)/255,this.b=parseInt(C.substring(5,7),16)/255,9===C.length&&(this.a=parseInt(C.substring(7,9),16)/255)),this}toLinearSpace(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new E;return this.toLinearSpaceToRef(U,C),U}toLinearSpaceToRef(C){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(C.r=t(this.r),C.g=t(this.g),C.b=t(this.b)):(C.r=e(this.r),C.g=e(this.g),C.b=e(this.b)),C.a=this.a,this}toGammaSpace(){let C=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new E;return this.toGammaSpaceToRef(U,C),U}toGammaSpaceToRef(C){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(C.r=j(this.r),C.g=j(this.g),C.b=j(this.b)):(C.r=z(this.r),C.g=z(this.g),C.b=z(this.b)),C.a=this.a,this}static FromHexString(C){return"#"!==C.substring(0,1)||9!==C.length&&7!==C.length?new E(0,0,0,0):new E(0,0,0,1).fromHexString(C)}static Lerp(C,U,K){return E.LerpToRef(C,U,K,new E)}static LerpToRef(C,U,K,m){return m.r=C.r+(U.r-C.r)*K,m.g=C.g+(U.g-C.g)*K,m.b=C.b+(U.b-C.b)*K,m.a=C.a+(U.a-C.a)*K,m}static Hermite(C,U,K,m,O){const X=O*O,A=O*X,e=2*A-3*X+1,t=-2*A+3*X,z=A-2*X+O,j=A-X,p=C.r*e+K.r*t+U.r*z+m.r*j,u=C.g*e+K.g*t+U.g*z+m.g*j,b=C.b*e+K.b*t+U.b*z+m.b*j,v=C.a*e+K.a*t+U.a*z+m.a*j;return new E(p,u,b,v)}static Hermite1stDerivative(C,U,K,m,O){const X=new E;return this.Hermite1stDerivativeToRef(C,U,K,m,O,X),X}static Hermite1stDerivativeToRef(C,U,K,m,O,X){const A=O*O;X.r=6*(A-O)*C.r+(3*A-4*O+1)*U.r+6*(-A+O)*K.r+(3*A-2*O)*m.r,X.g=6*(A-O)*C.g+(3*A-4*O+1)*U.g+6*(-A+O)*K.g+(3*A-2*O)*m.g,X.b=6*(A-O)*C.b+(3*A-4*O+1)*U.b+6*(-A+O)*K.b+(3*A-2*O)*m.b,X.a=6*(A-O)*C.a+(3*A-4*O+1)*U.a+6*(-A+O)*K.a+(3*A-2*O)*m.a}static FromColor3(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E(C.r,C.g,C.b,U)}static FU(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(C[U],C[U+1],C[U+2],C[U+3])}static FromArrayToRef(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2?arguments[2]:void 0;K.r=C[U],K.g=C[U+1],K.b=C[U+2],K.a=C[U+3]}static FromInts(C,U,K,m){return new E(C/255,U/255,K/255,m/255)}static CheckColors4(C,U){if(C.length===3*U){const U=[];for(let K=0;K<C.length;K+=3){const m=K/3*4;U[m]=C[K],U[m+1]=C[K+1],U[m+2]=C[K+2],U[m+3]=1}return U}return C}}E._V8PerformanceHack=new E(.5,.5,.5,.5),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class u{}u.fU=(0,m.e)(3,p.Black),u.ve=(0,m.e)(3,(()=>new E(0,0,0,0))),(0,O.h)("BABYLON.Color3",p),(0,O.h)("BABYLON.Color4",E)}}]);