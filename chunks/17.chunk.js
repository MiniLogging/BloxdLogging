"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[17],{11636:(U,X,b)=>{b.r(X),b.d(X,{NX:()=>R,eb:()=>n,TmpColors:()=>a});var F=b(11600),E=b(11551),w=b(11597),Q=b(11608);function z(U){return Math.pow(U,w.k)}function q(U){return U<=.04045?.0773993808*U:Math.pow(.947867299*(U+.055),2.4)}function p(U){return Math.pow(U,w.g)}function S(U){return U<=.0031308?12.92*U:1.055*Math.pow(U,.41666)-.055}class R{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=U,this.g=X,this.b=b}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"NX"}getHashCode(){let U=255*this.r|0;return U=397*U^255*this.g,U=397*U^255*this.b,U}toArray(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[X]=this.r,U[X+1]=this.g,U[X+2]=this.b,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R.FromArrayToRef(U,X,this),this}toColor4(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new n(this.r,this.g,this.b,U)}Jb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(U){return new R(this.r*U.r,this.g*U.g,this.b*U.b)}multiplyToRef(U,X){return X.r=this.r*U.r,X.g=this.g*U.g,X.b=this.b*U.b,X}multiplyInPlace(U){return this.r*=U.r,this.g*=U.g,this.b*=U.b,this}multiplyByFloats(U,X,b){return new R(this.r*U,this.g*X,this.b*b)}divide(U){throw new ReferenceError("Can not divide a color")}divideToRef(U,X){throw new ReferenceError("Can not divide a color")}divideInPlace(U){throw new ReferenceError("Can not divide a color")}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U.r,U.g,U.b)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U.r,U.g,U.b)}minimizeInPlaceFromFloats(U,X,b){return this.r=Math.min(U,this.r),this.g=Math.min(X,this.g),this.b=Math.min(b,this.b),this}maximizeInPlaceFromFloats(U,X,b){return this.r=Math.max(U,this.r),this.g=Math.max(X,this.g),this.b=Math.max(b,this.b),this}floorToRef(U){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(U){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(U){return U&&this.r===U.r&&this.g===U.g&&this.b===U.b}equalsFloats(U,X,b){return this.equalsToFloats(U,X,b)}equalsToFloats(U,X,b){return this.r===U&&this.g===X&&this.b===b}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return(0,Q.WithinEpsilon)(this.r,U.r,X)&&(0,Q.WithinEpsilon)(this.g,U.g,X)&&(0,Q.WithinEpsilon)(this.b,U.b,X)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(U){throw new ReferenceError("Can not negate a color")}scale(U){return new R(this.r*U,this.g*U,this.b*U)}scaleInPlace(U){return this.r*=U,this.g*=U,this.b*=U,this}scaleToRef(U,X){return X.r=this.r*U,X.g=this.g*U,X.b=this.b*U,X}scaleAndAddToRef(U,X){return X.r+=this.r*U,X.g+=this.g*U,X.b+=this.b*U,X}clampToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,Q.Clamp)(this.r,U,X),b.g=(0,Q.Clamp)(this.g,U,X),b.b=(0,Q.Clamp)(this.b,U,X),b}add(U){return new R(this.r+U.r,this.g+U.g,this.b+U.b)}addInPlace(U){return this.r+=U.r,this.g+=U.g,this.b+=U.b,this}addInPlaceFromFloats(U,X,b){return this.r+=U,this.g+=X,this.b+=b,this}addToRef(U,X){return X.r=this.r+U.r,X.g=this.g+U.g,X.b=this.b+U.b,X}mX(U){return new R(this.r-U.r,this.g-U.g,this.b-U.b)}subtractToRef(U,X){return X.r=this.r-U.r,X.g=this.g-U.g,X.b=this.b-U.b,X}pR(U){return this.r-=U.r,this.g-=U.g,this.b-=U.b,this}subtractFromFloats(U,X,b){return new R(this.r-U,this.g-X,this.b-b)}subtractFromFloatsToRef(U,X,b,F){return F.r=this.r-U,F.g=this.g-X,F.b=this.b-b,F}clone(){return new R(this.r,this.g,this.b)}q(U){return this.r=U.r,this.g=U.g,this.b=U.b,this}Pb(U,X,b){return this.r=U,this.g=X,this.b=b,this}set(U,X,b){return this.Pb(U,X,b)}jb(U){return this.r=this.g=this.b=U,this}toHexString(){const U=Math.round(255*this.r),X=Math.round(255*this.g),b=Math.round(255*this.b);return"#"+(0,Q.ToHex)(U)+(0,Q.ToHex)(X)+(0,Q.ToHex)(b)}fromHexString(U){return"#"!==U.substring(0,1)||7!==U.length||(this.r=parseInt(U.substring(1,3),16)/255,this.g=parseInt(U.substring(3,5),16)/255,this.b=parseInt(U.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new R)}toHSVToRef(U){const X=this.r,b=this.g,F=this.b,E=Math.max(X,b,F),w=Math.min(X,b,F);let Q=0,z=0;const q=E,p=E-w;return 0!==E&&(z=p/E),E!=w&&(E==X?(Q=(b-F)/p,b<F&&(Q+=6)):E==b?Q=(F-X)/p+2:E==F&&(Q=(X-b)/p+4),Q*=60),U.r=Q,U.g=z,U.b=q,U}toLinearSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new R;return this.toLinearSpaceToRef(X,U),X}toLinearSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=q(this.r),U.g=q(this.g),U.b=q(this.b)):(U.r=z(this.r),U.g=z(this.g),U.b=z(this.b)),this}toGammaSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new R;return this.toGammaSpaceToRef(X,U),X}toGammaSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=S(this.r),U.g=S(this.g),U.b=S(this.b)):(U.r=p(this.r),U.g=p(this.g),U.b=p(this.b)),this}static HSVtoRGBToRef(U,X,b,F){const E=b*X,w=U/60,Q=E*(1-Math.abs(w%2-1));let z=0,q=0,p=0;w>=0&&w<=1?(z=E,q=Q):w>=1&&w<=2?(z=Q,q=E):w>=2&&w<=3?(q=E,p=Q):w>=3&&w<=4?(q=Q,p=E):w>=4&&w<=5?(z=Q,p=E):w>=5&&w<=6&&(z=E,p=Q);const S=b-E;return F.r=z+S,F.g=q+S,F.b=p+S,F}static FromHSV(U,X,b){const F=new R(0,0,0);return R.HSVtoRGBToRef(U,X,b,F),F}static FromHexString(U){return new R(0,0,0).fromHexString(U)}static uX(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new R(U[X],U[X+1],U[X+2])}static FromArrayToRef(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=U[X],b.g=U[X+1],b.b=U[X+2]}static FromInts(U,X,b){return new R(U/255,X/255,b/255)}static Lerp(U,X,b){const F=new R(0,0,0);return R.LerpToRef(U,X,b,F),F}static LerpToRef(U,X,b,F){F.r=U.r+(X.r-U.r)*b,F.g=U.g+(X.g-U.g)*b,F.b=U.b+(X.b-U.b)*b}static Hermite(U,X,b,F,E){const w=E*E,Q=E*w,z=2*Q-3*w+1,q=-2*Q+3*w,p=Q-2*w+E,S=Q-w,n=U.r*z+b.r*q+X.r*p+F.r*S,a=U.g*z+b.g*q+X.g*p+F.g*S,J=U.b*z+b.b*q+X.b*p+F.b*S;return new R(n,a,J)}static Hermite1stDerivative(U,X,b,F,E){const w=R.Black();return this.Hermite1stDerivativeToRef(U,X,b,F,E,w),w}static Hermite1stDerivativeToRef(U,X,b,F,E,w){const Q=E*E;w.r=6*(Q-E)*U.r+(3*Q-4*E+1)*X.r+6*(-Q+E)*b.r+(3*Q-2*E)*F.r,w.g=6*(Q-E)*U.g+(3*Q-4*E+1)*X.g+6*(-Q+E)*b.g+(3*Q-2*E)*F.g,w.b=6*(Q-E)*U.b+(3*Q-4*E+1)*X.b+6*(-Q+E)*b.b+(3*Q-2*E)*F.b}static Red(){return new R(1,0,0)}static Green(){return new R(0,1,0)}static Blue(){return new R(0,0,1)}static Black(){return new R(0,0,0)}static get BlackReadOnly(){return R._BlackReadOnly}static White(){return new R(1,1,1)}static Purple(){return new R(.5,0,.5)}static Magenta(){return new R(1,0,1)}static Yellow(){return new R(1,1,0)}static Gray(){return new R(.5,.5,.5)}static Teal(){return new R(0,1,1)}static Random(){return new R(Math.random(),Math.random(),Math.random())}}R._V8PerformanceHack=new R(.5,.5,.5),R._BlackReadOnly=R.Black(),Object.defineProperties(R.prototype,{dimension:{value:[3]},rank:{value:1}});class n{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=U,this.g=X,this.b=b,this.a=F}Jb(){return[this.r,this.g,this.b,this.a]}toArray(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[X]=this.r,U[X+1]=this.g,U[X+2]=this.b,U[X+3]=this.a,this}qF(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=U[X],this.g=U[X+1],this.b=U[X+2],this.a=U[X+3],this}equals(U){return U&&this.r===U.r&&this.g===U.g&&this.b===U.b&&this.a===U.a}add(U){return new n(this.r+U.r,this.g+U.g,this.b+U.b,this.a+U.a)}addToRef(U,X){return X.r=this.r+U.r,X.g=this.g+U.g,X.b=this.b+U.b,X.a=this.a+U.a,X}addInPlace(U){return this.r+=U.r,this.g+=U.g,this.b+=U.b,this.a+=U.a,this}addInPlaceFromFloats(U,X,b,F){return this.r+=U,this.g+=X,this.b+=b,this.a+=F,this}mX(U){return new n(this.r-U.r,this.g-U.g,this.b-U.b,this.a-U.a)}subtractToRef(U,X){return X.r=this.r-U.r,X.g=this.g-U.g,X.b=this.b-U.b,X.a=this.a-U.a,X}pR(U){return this.r-=U.r,this.g-=U.g,this.b-=U.b,this.a-=U.a,this}subtractFromFloats(U,X,b,F){return new n(this.r-U,this.g-X,this.b-b,this.a-F)}subtractFromFloatsToRef(U,X,b,F,E){return E.r=this.r-U,E.g=this.g-X,E.b=this.b-b,E.a=this.a-F,E}scale(U){return new n(this.r*U,this.g*U,this.b*U,this.a*U)}scaleInPlace(U){return this.r*=U,this.g*=U,this.b*=U,this.a*=U,this}scaleToRef(U,X){return X.r=this.r*U,X.g=this.g*U,X.b=this.b*U,X.a=this.a*U,X}scaleAndAddToRef(U,X){return X.r+=this.r*U,X.g+=this.g*U,X.b+=this.b*U,X.a+=this.a*U,X}clampToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,Q.Clamp)(this.r,U,X),b.g=(0,Q.Clamp)(this.g,U,X),b.b=(0,Q.Clamp)(this.b,U,X),b.a=(0,Q.Clamp)(this.a,U,X),b}multiply(U){return new n(this.r*U.r,this.g*U.g,this.b*U.b,this.a*U.a)}multiplyToRef(U,X){return X.r=this.r*U.r,X.g=this.g*U.g,X.b=this.b*U.b,X.a=this.a*U.a,X}multiplyInPlace(U){return this.r*=U.r,this.g*=U.g,this.b*=U.b,this.a*=U.a,this}multiplyByFloats(U,X,b,F){return new n(this.r*U,this.g*X,this.b*b,this.a*F)}divide(U){throw new ReferenceError("Can not divide a color")}divideToRef(U,X){throw new ReferenceError("Can not divide a color")}divideInPlace(U){throw new ReferenceError("Can not divide a color")}minimizeInPlace(U){return this.r=Math.min(this.r,U.r),this.g=Math.min(this.g,U.g),this.b=Math.min(this.b,U.b),this.a=Math.min(this.a,U.a),this}maximizeInPlace(U){return this.r=Math.max(this.r,U.r),this.g=Math.max(this.g,U.g),this.b=Math.max(this.b,U.b),this.a=Math.max(this.a,U.a),this}minimizeInPlaceFromFloats(U,X,b,F){return this.r=Math.min(U,this.r),this.g=Math.min(X,this.g),this.b=Math.min(b,this.b),this.a=Math.min(F,this.a),this}maximizeInPlaceFromFloats(U,X,b,F){return this.r=Math.max(U,this.r),this.g=Math.max(X,this.g),this.b=Math.max(b,this.b),this.a=Math.max(F,this.a),this}floorToRef(U){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(U){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(U){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.d;return(0,Q.WithinEpsilon)(this.r,U.r,X)&&(0,Q.WithinEpsilon)(this.g,U.g,X)&&(0,Q.WithinEpsilon)(this.b,U.b,X)&&(0,Q.WithinEpsilon)(this.a,U.a,X)}equalsToFloats(U,X,b,F){return this.r===U&&this.g===X&&this.b===b&&this.a===F}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"eb"}getHashCode(){let U=255*this.r|0;return U=397*U^255*this.g,U=397*U^255*this.b,U=397*U^255*this.a,U}clone(){return(new n).q(this)}q(U){return this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a,this}Pb(U,X,b,F){return this.r=U,this.g=X,this.b=b,this.a=F,this}set(U,X,b,F){return this.Pb(U,X,b,F)}jb(U){return this.r=this.g=this.b=this.a=U,this}toHexString(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=Math.round(255*this.r),b=Math.round(255*this.g),F=Math.round(255*this.b);if(U)return"#"+(0,Q.ToHex)(X)+(0,Q.ToHex)(b)+(0,Q.ToHex)(F);const E=Math.round(255*this.a);return"#"+(0,Q.ToHex)(X)+(0,Q.ToHex)(b)+(0,Q.ToHex)(F)+(0,Q.ToHex)(E)}fromHexString(U){return"#"!==U.substring(0,1)||9!==U.length&&7!==U.length||(this.r=parseInt(U.substring(1,3),16)/255,this.g=parseInt(U.substring(3,5),16)/255,this.b=parseInt(U.substring(5,7),16)/255,9===U.length&&(this.a=parseInt(U.substring(7,9),16)/255)),this}toLinearSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new n;return this.toLinearSpaceToRef(X,U),X}toLinearSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=q(this.r),U.g=q(this.g),U.b=q(this.b)):(U.r=z(this.r),U.g=z(this.g),U.b=z(this.b)),U.a=this.a,this}toGammaSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new n;return this.toGammaSpaceToRef(X,U),X}toGammaSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=S(this.r),U.g=S(this.g),U.b=S(this.b)):(U.r=p(this.r),U.g=p(this.g),U.b=p(this.b)),U.a=this.a,this}static FromHexString(U){return"#"!==U.substring(0,1)||9!==U.length&&7!==U.length?new n(0,0,0,0):new n(0,0,0,1).fromHexString(U)}static Lerp(U,X,b){return n.LerpToRef(U,X,b,new n)}static LerpToRef(U,X,b,F){return F.r=U.r+(X.r-U.r)*b,F.g=U.g+(X.g-U.g)*b,F.b=U.b+(X.b-U.b)*b,F.a=U.a+(X.a-U.a)*b,F}static Hermite(U,X,b,F,E){const w=E*E,Q=E*w,z=2*Q-3*w+1,q=-2*Q+3*w,p=Q-2*w+E,S=Q-w,R=U.r*z+b.r*q+X.r*p+F.r*S,a=U.g*z+b.g*q+X.g*p+F.g*S,J=U.b*z+b.b*q+X.b*p+F.b*S,m=U.a*z+b.a*q+X.a*p+F.a*S;return new n(R,a,J,m)}static Hermite1stDerivative(U,X,b,F,E){const w=new n;return this.Hermite1stDerivativeToRef(U,X,b,F,E,w),w}static Hermite1stDerivativeToRef(U,X,b,F,E,w){const Q=E*E;w.r=6*(Q-E)*U.r+(3*Q-4*E+1)*X.r+6*(-Q+E)*b.r+(3*Q-2*E)*F.r,w.g=6*(Q-E)*U.g+(3*Q-4*E+1)*X.g+6*(-Q+E)*b.g+(3*Q-2*E)*F.g,w.b=6*(Q-E)*U.b+(3*Q-4*E+1)*X.b+6*(-Q+E)*b.b+(3*Q-2*E)*F.b,w.a=6*(Q-E)*U.a+(3*Q-4*E+1)*X.a+6*(-Q+E)*b.a+(3*Q-2*E)*F.a}static FromColor3(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new n(U.r,U.g,U.b,X)}static uX(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(U[X],U[X+1],U[X+2],U[X+3])}static FromArrayToRef(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=U[X],b.g=U[X+1],b.b=U[X+2],b.a=U[X+3]}static FromInts(U,X,b,F){return new n(U/255,X/255,b/255,F/255)}static CheckColors4(U,X){if(U.length===3*X){const X=[];for(let b=0;b<U.length;b+=3){const F=b/3*4;X[F]=U[b],X[F+1]=U[b+1],X[F+2]=U[b+2],X[F+3]=1}return X}return U}}n._V8PerformanceHack=new n(.5,.5,.5,.5),Object.defineProperties(n.prototype,{dimension:{value:[4]},rank:{value:1}});class a{}a.NX=(0,F.e)(3,R.Black),a.eb=(0,F.e)(3,(()=>new n(0,0,0,0))),(0,E.f)("BABYLON.Color3",R),(0,E.f)("BABYLON.Color4",n)}}]);