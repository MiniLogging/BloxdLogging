"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[17],{12636:(s,k,h)=>{h.r(k),h.d(k,{Bk:()=>S,jg:()=>a,TmpColors:()=>r});var A=h(12603),g=h(12543),ms=h(12598),i=h(12607);function K(s){return Math.pow(s,ms.j)}function H(s){return s<=.04045?.0773993808*s:Math.pow(.947867299*(s+.055),2.4)}function O(s){return Math.pow(s,ms.g)}function c(s){return s<=.0031308?12.92*s:1.055*Math.pow(s,.41666)-.055}class S{constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=s,this.g=k,this.b=h}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Bk"}getHashCode(){let s=255*this.r|0;return s=397*s^255*this.g,s=397*s^255*this.b,s}toArray(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s[k]=this.r,s[k+1]=this.g,s[k+2]=this.b,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(s,k,this),this}toColor4(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new a(this.r,this.g,this.b,s)}yh(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(s){return new S(this.r*s.r,this.g*s.g,this.b*s.b)}multiplyToRef(s,k){return k.r=this.r*s.r,k.g=this.g*s.g,k.b=this.b*s.b,k}multiplyInPlace(s){return this.r*=s.r,this.g*=s.g,this.b*=s.b,this}multiplyByFloats(s,k,h){return new S(this.r*s,this.g*k,this.b*h)}divide(s){throw new ReferenceError("Can not divide a color")}divideToRef(s,k){throw new ReferenceError("Can not divide a color")}divideInPlace(s){throw new ReferenceError("Can not divide a color")}minimizeInPlace(s){return this.minimizeInPlaceFromFloats(s.r,s.g,s.b)}maximizeInPlace(s){return this.maximizeInPlaceFromFloats(s.r,s.g,s.b)}minimizeInPlaceFromFloats(s,k,h){return this.r=Math.min(s,this.r),this.g=Math.min(k,this.g),this.b=Math.min(h,this.b),this}maximizeInPlaceFromFloats(s,k,h){return this.r=Math.max(s,this.r),this.g=Math.max(k,this.g),this.b=Math.max(h,this.b),this}floorToRef(s){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(s){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(s){return s&&this.r===s.r&&this.g===s.g&&this.b===s.b}equalsFloats(s,k,h){return this.equalsToFloats(s,k,h)}equalsToFloats(s,k,h){return this.r===s&&this.g===k&&this.b===h}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ms.c;return(0,i.WithinEpsilon)(this.r,s.r,k)&&(0,i.WithinEpsilon)(this.g,s.g,k)&&(0,i.WithinEpsilon)(this.b,s.b,k)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(s){throw new ReferenceError("Can not negate a color")}scale(s){return new S(this.r*s,this.g*s,this.b*s)}scaleInPlace(s){return this.r*=s,this.g*=s,this.b*=s,this}scaleToRef(s,k){return k.r=this.r*s,k.g=this.g*s,k.b=this.b*s,k}scaleAndAddToRef(s,k){return k.r+=this.r*s,k.g+=this.g*s,k.b+=this.b*s,k}clampToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,i.Clamp)(this.r,s,k),h.g=(0,i.Clamp)(this.g,s,k),h.b=(0,i.Clamp)(this.b,s,k),h}add(s){return new S(this.r+s.r,this.g+s.g,this.b+s.b)}addInPlace(s){return this.r+=s.r,this.g+=s.g,this.b+=s.b,this}addInPlaceFromFloats(s,k,h){return this.r+=s,this.g+=k,this.b+=h,this}addToRef(s,k){return k.r=this.r+s.r,k.g=this.g+s.g,k.b=this.b+s.b,k}Rk(s){return new S(this.r-s.r,this.g-s.g,this.b-s.b)}subtractToRef(s,k){return k.r=this.r-s.r,k.g=this.g-s.g,k.b=this.b-s.b,k}ka(s){return this.r-=s.r,this.g-=s.g,this.b-=s.b,this}subtractFromFloats(s,k,h){return new S(this.r-s,this.g-k,this.b-h)}subtractFromFloatsToRef(s,k,h,A){return A.r=this.r-s,A.g=this.g-k,A.b=this.b-h,A}clone(){return new S(this.r,this.g,this.b)}H(s){return this.r=s.r,this.g=s.g,this.b=s.b,this}cg(s,k,h){return this.r=s,this.g=k,this.b=h,this}set(s,k,h){return this.cg(s,k,h)}Eg(s){return this.r=this.g=this.b=s,this}toHexString(){const s=Math.round(255*this.r),k=Math.round(255*this.g),h=Math.round(255*this.b);return"#"+(0,i.ToHex)(s)+(0,i.ToHex)(k)+(0,i.ToHex)(h)}fromHexString(s){return"#"!==s.substring(0,1)||7!==s.length||(this.r=parseInt(s.substring(1,3),16)/255,this.g=parseInt(s.substring(3,5),16)/255,this.b=parseInt(s.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new S)}toHSVToRef(s){const k=this.r,h=this.g,A=this.b,g=Math.max(k,h,A),ms=Math.min(k,h,A);let i=0,K=0;const H=g,O=g-ms;return 0!==g&&(K=O/g),g!=ms&&(g==k?(i=(h-A)/O,h<A&&(i+=6)):g==h?i=(A-k)/O+2:g==A&&(i=(k-h)/O+4),i*=60),s.r=i,s.g=K,s.b=H,s}toLinearSpace(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=new S;return this.toLinearSpaceToRef(k,s),k}toLinearSpaceToRef(s){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(s.r=H(this.r),s.g=H(this.g),s.b=H(this.b)):(s.r=K(this.r),s.g=K(this.g),s.b=K(this.b)),this}toGammaSpace(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=new S;return this.toGammaSpaceToRef(k,s),k}toGammaSpaceToRef(s){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(s.r=c(this.r),s.g=c(this.g),s.b=c(this.b)):(s.r=O(this.r),s.g=O(this.g),s.b=O(this.b)),this}static HSVtoRGBToRef(s,k,h,A){const g=h*k,ms=s/60,i=g*(1-Math.abs(ms%2-1));let K=0,H=0,O=0;ms>=0&&ms<=1?(K=g,H=i):ms>=1&&ms<=2?(K=i,H=g):ms>=2&&ms<=3?(H=g,O=i):ms>=3&&ms<=4?(H=i,O=g):ms>=4&&ms<=5?(K=i,O=g):ms>=5&&ms<=6&&(K=g,O=i);const c=h-g;return A.r=K+c,A.g=H+c,A.b=O+c,A}static FromHSV(s,k,h){const A=new S(0,0,0);return S.HSVtoRGBToRef(s,k,h,A),A}static FromHexString(s){return new S(0,0,0).fromHexString(s)}static uk(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(s[k],s[k+1],s[k+2])}static FromArrayToRef(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=s[k],h.g=s[k+1],h.b=s[k+2]}static FromInts(s,k,h){return new S(s/255,k/255,h/255)}static Lerp(s,k,h){const A=new S(0,0,0);return S.LerpToRef(s,k,h,A),A}static LerpToRef(s,k,h,A){A.r=s.r+(k.r-s.r)*h,A.g=s.g+(k.g-s.g)*h,A.b=s.b+(k.b-s.b)*h}static Hermite(s,k,h,A,g){const ms=g*g,i=g*ms,K=2*i-3*ms+1,H=-2*i+3*ms,O=i-2*ms+g,c=i-ms,a=s.r*K+h.r*H+k.r*O+A.r*c,r=s.g*K+h.g*H+k.g*O+A.g*c,d=s.b*K+h.b*H+k.b*O+A.b*c;return new S(a,r,d)}static Hermite1stDerivative(s,k,h,A,g){const ms=S.Black();return this.Hermite1stDerivativeToRef(s,k,h,A,g,ms),ms}static Hermite1stDerivativeToRef(s,k,h,A,g,ms){const i=g*g;ms.r=6*(i-g)*s.r+(3*i-4*g+1)*k.r+6*(-i+g)*h.r+(3*i-2*g)*A.r,ms.g=6*(i-g)*s.g+(3*i-4*g+1)*k.g+6*(-i+g)*h.g+(3*i-2*g)*A.g,ms.b=6*(i-g)*s.b+(3*i-4*g+1)*k.b+6*(-i+g)*h.b+(3*i-2*g)*A.b}static Red(){return new S(1,0,0)}static Green(){return new S(0,1,0)}static Blue(){return new S(0,0,1)}static Black(){return new S(0,0,0)}static get BlackReadOnly(){return S._BlackReadOnly}static White(){return new S(1,1,1)}static Purple(){return new S(.5,0,.5)}static Magenta(){return new S(1,0,1)}static Yellow(){return new S(1,1,0)}static Gray(){return new S(.5,.5,.5)}static Teal(){return new S(0,1,1)}static Random(){return new S(Math.random(),Math.random(),Math.random())}}S._V8PerformanceHack=new S(.5,.5,.5),S._BlackReadOnly=S.Black(),Object.defineProperties(S.prototype,{dimension:{value:[3]},rank:{value:1}});class a{constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=s,this.g=k,this.b=h,this.a=A}yh(){return[this.r,this.g,this.b,this.a]}toArray(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return s[k]=this.r,s[k+1]=this.g,s[k+2]=this.b,s[k+3]=this.a,this}Nh(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=s[k],this.g=s[k+1],this.b=s[k+2],this.a=s[k+3],this}equals(s){return s&&this.r===s.r&&this.g===s.g&&this.b===s.b&&this.a===s.a}add(s){return new a(this.r+s.r,this.g+s.g,this.b+s.b,this.a+s.a)}addToRef(s,k){return k.r=this.r+s.r,k.g=this.g+s.g,k.b=this.b+s.b,k.a=this.a+s.a,k}addInPlace(s){return this.r+=s.r,this.g+=s.g,this.b+=s.b,this.a+=s.a,this}addInPlaceFromFloats(s,k,h,A){return this.r+=s,this.g+=k,this.b+=h,this.a+=A,this}Rk(s){return new a(this.r-s.r,this.g-s.g,this.b-s.b,this.a-s.a)}subtractToRef(s,k){return k.r=this.r-s.r,k.g=this.g-s.g,k.b=this.b-s.b,k.a=this.a-s.a,k}ka(s){return this.r-=s.r,this.g-=s.g,this.b-=s.b,this.a-=s.a,this}subtractFromFloats(s,k,h,A){return new a(this.r-s,this.g-k,this.b-h,this.a-A)}subtractFromFloatsToRef(s,k,h,A,g){return g.r=this.r-s,g.g=this.g-k,g.b=this.b-h,g.a=this.a-A,g}scale(s){return new a(this.r*s,this.g*s,this.b*s,this.a*s)}scaleInPlace(s){return this.r*=s,this.g*=s,this.b*=s,this.a*=s,this}scaleToRef(s,k){return k.r=this.r*s,k.g=this.g*s,k.b=this.b*s,k.a=this.a*s,k}scaleAndAddToRef(s,k){return k.r+=this.r*s,k.g+=this.g*s,k.b+=this.b*s,k.a+=this.a*s,k}clampToRef(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,i.Clamp)(this.r,s,k),h.g=(0,i.Clamp)(this.g,s,k),h.b=(0,i.Clamp)(this.b,s,k),h.a=(0,i.Clamp)(this.a,s,k),h}multiply(s){return new a(this.r*s.r,this.g*s.g,this.b*s.b,this.a*s.a)}multiplyToRef(s,k){return k.r=this.r*s.r,k.g=this.g*s.g,k.b=this.b*s.b,k.a=this.a*s.a,k}multiplyInPlace(s){return this.r*=s.r,this.g*=s.g,this.b*=s.b,this.a*=s.a,this}multiplyByFloats(s,k,h,A){return new a(this.r*s,this.g*k,this.b*h,this.a*A)}divide(s){throw new ReferenceError("Can not divide a color")}divideToRef(s,k){throw new ReferenceError("Can not divide a color")}divideInPlace(s){throw new ReferenceError("Can not divide a color")}minimizeInPlace(s){return this.r=Math.min(this.r,s.r),this.g=Math.min(this.g,s.g),this.b=Math.min(this.b,s.b),this.a=Math.min(this.a,s.a),this}maximizeInPlace(s){return this.r=Math.max(this.r,s.r),this.g=Math.max(this.g,s.g),this.b=Math.max(this.b,s.b),this.a=Math.max(this.a,s.a),this}minimizeInPlaceFromFloats(s,k,h,A){return this.r=Math.min(s,this.r),this.g=Math.min(k,this.g),this.b=Math.min(h,this.b),this.a=Math.min(A,this.a),this}maximizeInPlaceFromFloats(s,k,h,A){return this.r=Math.max(s,this.r),this.g=Math.max(k,this.g),this.b=Math.max(h,this.b),this.a=Math.max(A,this.a),this}floorToRef(s){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(s){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(s){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:ms.c;return(0,i.WithinEpsilon)(this.r,s.r,k)&&(0,i.WithinEpsilon)(this.g,s.g,k)&&(0,i.WithinEpsilon)(this.b,s.b,k)&&(0,i.WithinEpsilon)(this.a,s.a,k)}equalsToFloats(s,k,h,A){return this.r===s&&this.g===k&&this.b===h&&this.a===A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"jg"}getHashCode(){let s=255*this.r|0;return s=397*s^255*this.g,s=397*s^255*this.b,s=397*s^255*this.a,s}clone(){return(new a).H(this)}H(s){return this.r=s.r,this.g=s.g,this.b=s.b,this.a=s.a,this}cg(s,k,h,A){return this.r=s,this.g=k,this.b=h,this.a=A,this}set(s,k,h,A){return this.cg(s,k,h,A)}Eg(s){return this.r=this.g=this.b=this.a=s,this}toHexString(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=Math.round(255*this.r),h=Math.round(255*this.g),A=Math.round(255*this.b);if(s)return"#"+(0,i.ToHex)(k)+(0,i.ToHex)(h)+(0,i.ToHex)(A);const g=Math.round(255*this.a);return"#"+(0,i.ToHex)(k)+(0,i.ToHex)(h)+(0,i.ToHex)(A)+(0,i.ToHex)(g)}fromHexString(s){return"#"!==s.substring(0,1)||9!==s.length&&7!==s.length||(this.r=parseInt(s.substring(1,3),16)/255,this.g=parseInt(s.substring(3,5),16)/255,this.b=parseInt(s.substring(5,7),16)/255,9===s.length&&(this.a=parseInt(s.substring(7,9),16)/255)),this}toLinearSpace(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=new a;return this.toLinearSpaceToRef(k,s),k}toLinearSpaceToRef(s){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(s.r=H(this.r),s.g=H(this.g),s.b=H(this.b)):(s.r=K(this.r),s.g=K(this.g),s.b=K(this.b)),s.a=this.a,this}toGammaSpace(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=new a;return this.toGammaSpaceToRef(k,s),k}toGammaSpaceToRef(s){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(s.r=c(this.r),s.g=c(this.g),s.b=c(this.b)):(s.r=O(this.r),s.g=O(this.g),s.b=O(this.b)),s.a=this.a,this}static FromHexString(s){return"#"!==s.substring(0,1)||9!==s.length&&7!==s.length?new a(0,0,0,0):new a(0,0,0,1).fromHexString(s)}static Lerp(s,k,h){return a.LerpToRef(s,k,h,new a)}static LerpToRef(s,k,h,A){return A.r=s.r+(k.r-s.r)*h,A.g=s.g+(k.g-s.g)*h,A.b=s.b+(k.b-s.b)*h,A.a=s.a+(k.a-s.a)*h,A}static Hermite(s,k,h,A,g){const ms=g*g,i=g*ms,K=2*i-3*ms+1,H=-2*i+3*ms,O=i-2*ms+g,c=i-ms,S=s.r*K+h.r*H+k.r*O+A.r*c,r=s.g*K+h.g*H+k.g*O+A.g*c,d=s.b*K+h.b*H+k.b*O+A.b*c,E=s.a*K+h.a*H+k.a*O+A.a*c;return new a(S,r,d,E)}static Hermite1stDerivative(s,k,h,A,g){const ms=new a;return this.Hermite1stDerivativeToRef(s,k,h,A,g,ms),ms}static Hermite1stDerivativeToRef(s,k,h,A,g,ms){const i=g*g;ms.r=6*(i-g)*s.r+(3*i-4*g+1)*k.r+6*(-i+g)*h.r+(3*i-2*g)*A.r,ms.g=6*(i-g)*s.g+(3*i-4*g+1)*k.g+6*(-i+g)*h.g+(3*i-2*g)*A.g,ms.b=6*(i-g)*s.b+(3*i-4*g+1)*k.b+6*(-i+g)*h.b+(3*i-2*g)*A.b,ms.a=6*(i-g)*s.a+(3*i-4*g+1)*k.a+6*(-i+g)*h.a+(3*i-2*g)*A.a}static FromColor3(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a(s.r,s.g,s.b,k)}static uk(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(s[k],s[k+1],s[k+2],s[k+3])}static FromArrayToRef(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=s[k],h.g=s[k+1],h.b=s[k+2],h.a=s[k+3]}static FromInts(s,k,h,A){return new a(s/255,k/255,h/255,A/255)}static CheckColors4(s,k){if(s.length===3*k){const k=[];for(let h=0;h<s.length;h+=3){const A=h/3*4;k[A]=s[h],k[A+1]=s[h+1],k[A+2]=s[h+2],k[A+3]=1}return k}return s}}a._V8PerformanceHack=new a(.5,.5,.5,.5),Object.defineProperties(a.prototype,{dimension:{value:[4]},rank:{value:1}});class r{}r.Bk=(0,A.e)(3,S.Black),r.jg=(0,A.e)(3,(()=>new a(0,0,0,0))),(0,g.f)("BABYLON.Color3",S),(0,g.f)("BABYLON.Color4",a)}}]);