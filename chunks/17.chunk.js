"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2266:(c,b,A)=>{A.r(b),A.d(b,{ReadExrDataAsync:()=>Xc,_ExrTextureLoader:()=>Jc});var o=A(531),t=A(702);const n=4,h=4,s=1,L=2,C=8,J=65536,X=J>>3,R=14,N=65537,k=1<<R,E=k-1,V=59,y=63,j=2+y-V;var F,M;!function(c){c[c.NO_COMPRESSION=0]="NO_COMPRESSION",c[c.RLE_COMPRESSION=1]="RLE_COMPRESSION",c[c.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",c[c.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",c[c.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",c[c.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(F||(F={})),function(c){c[c.INCREASING_Y=0]="INCREASING_Y",c[c.DECREASING_Y=1]="DECREASING_Y"}(M||(M={}));const W=function(){const c=new ArrayBuffer(4),b=new Float32Array(c),A=new Uint32Array(c),o=new Uint32Array(512),t=new Uint32Array(512);for(let L=0;L<256;++L){const c=L-127;c<-27?(o[L]=0,o[256|L]=32768,t[L]=24,t[256|L]=24):c<-14?(o[L]=1024>>-c-14,o[256|L]=1024>>-c-14|32768,t[L]=-c-1,t[256|L]=-c-1):c<=15?(o[L]=c+15<<10,o[256|L]=c+15<<10|32768,t[L]=13,t[256|L]=13):c<128?(o[L]=31744,o[256|L]=64512,t[L]=24,t[256|L]=24):(o[L]=31744,o[256|L]=64512,t[L]=13,t[256|L]=13)}const n=new Uint32Array(2048),h=new Uint32Array(64),s=new Uint32Array(64);for(let L=1;L<1024;++L){let c=L<<13,b=0;for(;0===(8388608&c);)c<<=1,b-=8388608;c&=-8388609,b+=947912704,n[L]=c|b}for(let L=1024;L<2048;++L)n[L]=939524096+(L-1024<<13);for(let L=1;L<31;++L)h[L]=L<<23;h[31]=1199570944,h[32]=2147483648;for(let L=33;L<63;++L)h[L]=2147483648+(L-32<<23);h[63]=3347054592;for(let L=1;L<64;++L)32!==L&&(s[L]=1024);return{floatView:b,uint32View:A,baseTable:o,shiftTable:t,mantissaTable:n,exponentTable:h,offsetTable:s}}();function d(c,b){const A=new Uint8Array(c);let o=0;for(;0!=A[b.value+o];)o+=1;const t=(new TextDecoder).decode(A.slice(b.value,b.value+o));return b.value=b.value+o+1,t}function r(c,b){const A=c.getInt32(b.value,!0);return b.value+=n,A}function z(c,b){const A=c.getUint32(b.value,!0);return b.value+=n,A}function Y(c,b){const A=c.getUint8(b.value);return b.value+=s,A}function D(c,b){const A=c.getUint16(b.value,!0);return b.value+=L,A}function f(c,b){const A=c[b.value];return b.value+=s,A}function v(c,b){let A;return A="getBigInt64"in DataView.prototype?Number(c.getBigInt64(b.value,!0)):c.getUint32(b.value+4,!0)+Number(c.getUint32(b.value,!0)<<32),b.value+=C,A}function G(c,b){const A=c.getFloat32(b.value,!0);return b.value+=h,A}function P(c,b){return function(c){const b=(31744&c)>>10,A=1023&c;return(c>>15?-1:1)*(b?31===b?A?NaN:1/0:Math.pow(2,b-15)*(1+A/1024):A/1024*6103515625e-14)}(D(c,b))}function O(c,b){return function(c){if(Math.abs(c)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");c=(0,t.Clamp)(c,-65504,65504),W.floatView[0]=c;const b=W.uint32View[0],A=b>>23&511;return W.baseTable[A]+((8388607&b)>>W.shiftTable[A])}(G(c,b))}function p(c,b,A,o){switch(A){case"string":case"stringvector":case"iccProfile":return function(c,b,A){const o=(new TextDecoder).decode(new Uint8Array(c).slice(b.value,b.value+A));return b.value=b.value+A,o}(c.buffer,b,o);case"chlist":return function(c,b,A){const o=b.value,t=[];for(;b.value<o+A-1;){const A=d(c.buffer,b),o=r(c,b),n=Y(c,b);b.value+=3;const h=r(c,b),s=r(c,b);t.push({name:A,pixelType:o,pLinear:n,xSampling:h,ySampling:s})}return b.value+=1,t}(c,b,o);case"chromaticities":return function(c,b){return{redX:G(c,b),redY:G(c,b),greenX:G(c,b),greenY:G(c,b),blueX:G(c,b),blueY:G(c,b),whiteX:G(c,b),whiteY:G(c,b)}}(c,b);case"compression":return function(c,b){return Y(c,b)}(c,b);case"box2i":return function(c,b){return{xMin:r(c,b),yMin:r(c,b),xMax:r(c,b),yMax:r(c,b)}}(c,b);case"lineOrder":return function(c,b){const A=Y(c,b);return M[A]}(c,b);case"float":return G(c,b);case"v2f":return function(c,b){return[G(c,b),G(c,b)]}(c,b);case"v3f":return function(c,b){return[G(c,b),G(c,b),G(c,b)]}(c,b);case"int":return r(c,b);case"rational":return function(c,b){return[r(c,b),z(c,b)]}(c,b);case"timecode":return function(c,b){return[z(c,b),z(c,b)]}(c,b);case"preview":return b.value+=o,"skipped";default:return void(b.value+=o)}}function q(c){for(let b=1;b<c.length;b++){const A=c[b-1]+c[b]-128;c[b]=A}}function I(c,b){let A=0,o=Math.floor((c.length+1)/2),t=0;const n=c.length-1;for(;!(t>n)&&(b[t++]=c[A++],!(t>n));)b[t++]=c[o++]}const K=20000630;function Z(c,b){if(c.getUint32(0,!0)!=K)throw new Error("Incorrect OpenEXR format");const A=c.getUint8(4),t=c.getUint8(5),n={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};b.value=8;const h={};let s=!0;for(;s;){const A=d(c.buffer,b);if(A){const t=d(c.buffer,b),n=p(c,b,t,z(c,b));void 0===n?o.c.Warn(`Unknown header attribute type ${t}'.`):h[A]=n}else s=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:A,spec:n,...h}}const H=32768,S=65535;function B(c,b,A,o,t){for(;A<c;)b=b<<8|f(o,t),A+=8;return{l:b>>(A-=c)&(1<<c)-1,c:b,lc:A}}function Q(c,b,A,o){return{c:c=c<<8|f(A,o),lc:b+=8}}function a(c,b,A,o,t,n,h,s,L){if(c==b){if(o<8){const c=Q(A,o,t,n);A=c.c,o=c.lc}let c=A>>(o-=8);if(c=new Uint8Array([c])[0],s.value+c>L)return null;const b=h[s.value-1];for(;c-- >0;)h[s.value++]=b}else{if(!(s.value<L))return null;h[s.value++]=c}return{c:A,lc:o}}const l=new Array(59);function T(c,b,A,o,t,n){const h=b;let s=0,L=0;for(;o<=t;o++){if(h.value-b.value>A)return;let C=B(6,s,L,c,h);const J=C.l;if(s=C.c,L=C.lc,n[o]=J,J==y){if(h.value-b.value>A)throw new Error("Error in HufUnpackEncTable");C=B(8,s,L,c,h);let J=C.l+j;if(s=C.c,L=C.lc,o+J>t+1)throw new Error("Error in HufUnpackEncTable");for(;J--;)n[o++]=0;o--}else if(J>=V){let c=J-V+2;if(o+c>t+1)throw new Error("Error in HufUnpackEncTable");for(;c--;)n[o++]=0;o--}}!function(c){for(let A=0;A<=58;++A)l[A]=0;for(let A=0;A<N;++A)l[c[A]]+=1;let b=0;for(let A=58;A>0;--A){const c=b+l[A]>>1;l[A]=b,b=c}for(let A=0;A<N;++A){const b=c[A];b>0&&(c[A]=b|l[b]++<<6)}}(n)}function i(c){return 63&c}function g(c){return c>>6}function u(c,b,A,o,t,n){const h=A.value,s=z(b,A),L=z(b,A);A.value+=4;const C=z(b,A);if(A.value+=4,s<0||s>=N||L<0||L>=N)throw new Error("Wrong HUF_ENCSIZE");const J=new Array(N),X=new Array(k);!function(c){for(let b=0;b<k;b++)c[b]={},c[b].len=0,c[b].lit=0,c[b].p=null}(X);if(T(c,A,o-(A.value-h),s,L,J),C>8*(o-(A.value-h)))throw new Error("Wrong hufUncompress");!function(c,b,A,o){for(;b<=A;b++){const A=g(c[b]),t=i(c[b]);if(A>>t)throw new Error("Invalid table entry");if(t>R){const c=o[A>>t-R];if(c.len)throw new Error("Invalid table entry");if(c.lit++,c.p){const b=c.p;c.p=new Array(c.lit);for(let A=0;A<c.lit-1;++A)c.p[A]=b[A]}else c.p=new Array(1);c.p[c.lit-1]=b}else if(t){let c=0;for(let n=1<<R-t;n>0;n--){const n=o[(A<<R-t)+c];if(n.len||n.p)throw new Error("Invalid table entry");n.len=t,n.lit=b,c++}}}}(J,s,L,X),function(c,b,A,o,t,n,h,s,L){let C=0,J=0;const X=h,N=Math.trunc(o.value+(t+7)/8);for(;o.value<N;){let t=Q(C,J,A,o);for(C=t.c,J=t.lc;J>=R;){const h=b[C>>J-R&E];if(h.len){J-=h.len;const c=a(h.lit,n,C,J,A,o,s,L,X);c&&(C=c.c,J=c.lc)}else{if(!h.p)throw new Error("hufDecode issues");let b;for(b=0;b<h.lit;b++){const R=i(c[h.p[b]]);for(;J<R&&o.value<N;)t=Q(C,J,A,o),C=t.c,J=t.lc;if(J>=R&&g(c[h.p[b]])==(C>>J-R&(1<<R)-1)){J-=R;const c=a(h.p[b],n,C,J,A,o,s,L,X);c&&(C=c.c,J=c.lc);break}}if(b==h.lit)throw new Error("HufDecode issues")}}}const k=8-t&7;for(C>>=k,J-=k;J>0;){const c=b[C<<R-J&E];if(!c.len)throw new Error("HufDecode issues");{J-=c.len;const b=a(c.lit,n,C,J,A,o,s,L,X);b&&(C=b.c,J=b.lc)}}}(J,X,c,A,C,L,n,t,{value:0})}function e(c){return 65535&c}function x(c){const b=e(c);return b>32767?b-65536:b}function U(c,b){const A=x(c),o=x(b),t=A+(1&o)+(o>>1);return{a:t,b:t-o}}function w(c,b){const A=e(c),o=e(b),t=A-(o>>1)&S;return{a:o+t-H&S,b:t}}function m(c,b,A,o,t,n,h){const s=h<16384,L=A>t?t:A;let C,J,X=1;for(;X<=L;)X<<=1;for(X>>=1,C=X,X>>=1;X>=1;){J=0;const h=J+n*(t-C),L=n*X,R=n*C,N=o*X,k=o*C;let E,V,y,j;for(;J<=h;J+=R){let t=J;const n=J+o*(A-C);for(;t<=n;t+=k){const A=t+N,o=t+L,n=o+N;if(s){let h=U(c[t+b],c[o+b]);E=h.a,y=h.b,h=U(c[A+b],c[n+b]),V=h.a,j=h.b,h=U(E,V),c[t+b]=h.a,c[A+b]=h.b,h=U(y,j),c[o+b]=h.a,c[n+b]=h.b}else{let h=w(c[t+b],c[o+b]);E=h.a,y=h.b,h=w(c[A+b],c[n+b]),V=h.a,j=h.b,h=w(E,V),c[t+b]=h.a,c[A+b]=h.b,h=w(y,j),c[o+b]=h.a,c[n+b]=h.b}}if(A&X){const A=t+L;let o;o=s?U(c[t+b],c[A+b]):w(c[t+b],c[A+b]),E=o.a,c[A+b]=o.b,c[t+b]=E}}if(t&X){let t=J;const n=J+o*(A-C);for(;t<=n;t+=k){const A=t+N;let o;o=s?U(c[t+b],c[A+b]):w(c[t+b],c[A+b]),E=o.a,c[A+b]=o.b,c[t+b]=E}}C=X,X>>=1}return J}function cc(c){return new DataView(c.array.buffer,c.offset.value,c.size)}function bc(c){const b=c.viewer.buffer.slice(c.offset.value,c.offset.value+c.size),A=new Uint8Array(function(c){let b=c.byteLength;const A=[];let o=0;const t=new DataView(c);for(;b>0;){const c=t.getInt8(o++);if(c<0){const n=-c;b-=n+1;for(let c=0;c<n;c++)A.push(t.getUint8(o++))}else{const n=c;b-=2;const h=t.getUint8(o++);for(let c=0;c<n+1;c++)A.push(h)}}return A}(b)),o=new Uint8Array(A.length);return q(A),I(A,o),new DataView(o.buffer)}function Ac(c){const b=c.array.slice(c.offset.value,c.offset.value+c.size),A=fflate.unzlibSync(b),o=new Uint8Array(A.length);return q(A),I(A,o),new DataView(o.buffer)}function oc(c){const b=c.array.slice(c.offset.value,c.offset.value+c.size),A=fflate.unzlibSync(b),o=c.lines*c.channels*c.width,t=1==c.type?new Uint16Array(o):new Uint32Array(o);let n=0,h=0;const s=new Array(4);for(let L=0;L<c.lines;L++)for(let b=0;b<c.channels;b++){let b=0;switch(c.type){case 1:s[0]=n,s[1]=s[0]+c.width,n=s[1]+c.width;for(let o=0;o<c.width;++o){b+=A[s[0]++]<<8|A[s[1]++],t[h]=b,h++}break;case 2:s[0]=n,s[1]=s[0]+c.width,s[2]=s[1]+c.width,n=s[2]+c.width;for(let o=0;o<c.width;++o){b+=A[s[0]++]<<24|A[s[1]++]<<16|A[s[2]++]<<8,t[h]=b,h++}}}return new DataView(t.buffer)}function tc(c){const b=c.viewer,A={value:c.offset.value},o=new Uint16Array(c.width*c.scanlineBlockSize*(c.channels*c.type)),t=new Uint8Array(X);let n=0;const h=new Array(c.channels);for(let L=0;L<c.channels;L++)h[L]={},h[L].start=n,h[L].end=h[L].start,h[L].nx=c.width,h[L].ny=c.lines,h[L].size=c.type,n+=h[L].nx*h[L].ny*h[L].size;const s=D(b,A),C=D(b,A);if(C>=X)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(s<=C)for(let L=0;L<C-s+1;L++)t[L+s]=Y(b,A);const R=new Uint16Array(J),N=function(c,b){let A=0;for(let t=0;t<J;++t)(0==t||c[t>>3]&1<<(7&t))&&(b[A++]=t);const o=A-1;for(;A<J;)b[A++]=0;return o}(t,R),k=z(b,A);u(c.array,b,A,k,o,n);for(let L=0;L<c.channels;++L){const c=h[L];for(let b=0;b<h[L].size;++b)m(o,c.start+b,c.nx,c.size,c.ny,c.nx*c.size,N)}!function(c,b,A){for(let o=0;o<A;++o)b[o]=c[b[o]]}(R,o,n);let E=0;const V=new Uint8Array(o.buffer.byteLength);for(let J=0;J<c.lines;J++)for(let b=0;b<c.channels;b++){const c=h[b],A=c.nx*c.size,t=new Uint8Array(o.buffer,c.end*L,A*L);V.set(t,E),E+=A*L,c.end+=A}return new DataView(V.buffer)}var nc,hc=A(525);!function(c){c[c.Float=0]="Float",c[c.HalfFloat=1]="HalfFloat"}(nc||(nc={}));class sc{}async function Lc(c,b,A,o){const t={size:0,viewer:b,array:new Uint8Array(b.buffer),offset:A,width:c.dataWindow.xMax-c.dataWindow.xMin+1,height:c.dataWindow.yMax-c.dataWindow.yMin+1,channels:c.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(c.compression){case F.NO_COMPRESSION:t.lines=1,t.uncompress=cc;break;case F.RLE_COMPRESSION:t.lines=1,t.uncompress=bc;break;case F.ZIPS_COMPRESSION:t.lines=1,t.uncompress=Ac,await hc.d.LoadScriptAsync(sc.FFLATEUrl);break;case F.ZIP_COMPRESSION:t.lines=16,t.uncompress=Ac,await hc.d.LoadScriptAsync(sc.FFLATEUrl);break;case F.PIZ_COMPRESSION:t.lines=32,t.uncompress=tc;break;case F.PXR24_COMPRESSION:t.lines=16,t.uncompress=oc,await hc.d.LoadScriptAsync(sc.FFLATEUrl);break;default:throw new Error(F[c.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const n={};for(const h of c.channels)switch(h.name){case"R":case"G":case"B":case"A":case"Y":n[h.name]=!0,t.type=h.pixelType}let s=!1;if(n.R&&n.G&&n.B&&n.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G&&n.B)s=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(n.R)t.outputChannels=1,t.decodeChannels={R:0};else{if(!n.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(o){case nc.Float:t.getter=P,t.inputSize=L;break;case nc.HalfFloat:t.getter=D,t.inputSize=L}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+c.compression);switch(o){case nc.Float:t.getter=G,t.inputSize=h;break;case nc.HalfFloat:t.getter=O,t.inputSize=h}}t.blockCount=t.height/t.scanlineBlockSize;for(let h=0;h<t.blockCount;h++)v(b,A);const C=t.width*t.height*t.outputChannels;switch(o){case nc.Float:t.byteArray=new Float32Array(C),t.textureType=1,s&&t.byteArray.fill(1,0,C);break;case nc.HalfFloat:t.byteArray=new Uint16Array(C),t.textureType=2,s&&t.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+o)}let J=0;for(const h of c.channels)void 0!==t.decodeChannels[h.name]&&(t.channelLineOffsets[h.name]=J*t.width),J+=2*h.pixelType;return t.bytesPerLine=t.width*J,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===c.lineOrder?t.scanOrder=c=>c:t.scanOrder=c=>t.height-1-c,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function Cc(c,b,A,o){const t={value:0};for(let n=0;n<c.height/c.scanlineBlockSize;n++){const h=r(A,o)-b.dataWindow.yMin;c.size=z(A,o),c.lines=h+c.scanlineBlockSize>c.height?c.height-h:c.scanlineBlockSize;const s=c.size<c.lines*c.bytesPerLine&&c.uncompress?c.uncompress(c):cc(c);o.value+=c.size;for(let A=0;A<c.scanlineBlockSize;A++){const o=n*c.scanlineBlockSize,h=A+c.scanOrder(o);if(h>=c.height)continue;const L=A*c.bytesPerLine,C=(c.height-1-h)*c.outLineWidth;for(let A=0;A<c.channels;A++){const o=b.channels[A].name,n=c.channelLineOffsets[o],h=c.decodeChannels[o];if(void 0!==h){t.value=L+n;for(let b=0;b<c.width;b++){const A=C+b*c.outputChannels+h;c.byteArray&&(c.byteArray[A]=c.getter(s,t))}}}}}}sc.DefaultOutputType=nc.HalfFloat,sc.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Jc{constructor(){this.supportCascades=!1}loadCubeData(c,b,A,o,t){throw".exr not supported in Cube."}loadData(c,b,A){const t=new DataView(c.buffer),n={value:0},h=Z(t,n);Lc(h,t,n,sc.DefaultOutputType).then((c=>{Cc(c,h,t,n);const o=h.dataWindow.xMax-h.dataWindow.xMin+1,s=h.dataWindow.yMax-h.dataWindow.yMin+1;A(o,s,b.generateMipMaps,!1,(()=>{const A=b.getEngine();b.format=h.format,b.type=c.textureType,b.invertY=!1,b._gammaSpace=!h.linearSpace,c.byteArray&&A._uploadDataToTextureDirectly(b,c.byteArray,0,0,void 0,!0)}))})).catch((c=>{o.c.Error("Failed to load EXR texture: ",c)}))}}async function Xc(c){const b=new DataView(c),A={value:0},t=Z(b,A);try{const c=await Lc(t,b,A,nc.Float);return Cc(c,t,b,A),c.byteArray?{width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,data:new Float32Array(c.byteArray)}:(o.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(n){o.c.Error("Failed to load EXR data: ",n)}return{width:0,height:0,data:null}}}}]);