"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[17],{13020:(I,x,L)=>{L.r(x),L.d(x,{Tx:()=>Q,lB:()=>e,TmpColors:()=>g});var F=L(12996),X=L(12938),G=L(12989),Y=L(13001);function p(I){return Math.pow(I,G.m)}function B(I){return I<=.04045?.0773993808*I:Math.pow(.947867299*(I+.055),2.4)}function l(I){return Math.pow(I,G.l)}function W(I){return I<=.0031308?12.92*I:1.055*Math.pow(I,.41666)-.055}class Q{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=I,this.g=x,this.b=L}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Tx"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I}toArray(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[x]=this.r,I[x+1]=this.g,I[x+2]=this.b,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(I,x,this),this}toColor4(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new e(this.r,this.g,this.b,I)}Cp(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(I){return new Q(this.r*I.r,this.g*I.g,this.b*I.b)}multiplyToRef(I,x){return x.r=this.r*I.r,x.g=this.g*I.g,x.b=this.b*I.b,x}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this}multiplyByFloats(I,x,L){return new Q(this.r*I,this.g*x,this.b*L)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,x){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.r,I.g,I.b)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.r,I.g,I.b)}minimizeInPlaceFromFloats(I,x,L){return this.r=Math.min(I,this.r),this.g=Math.min(x,this.g),this.b=Math.min(L,this.b),this}maximizeInPlaceFromFloats(I,x,L){return this.r=Math.max(I,this.r),this.g=Math.max(x,this.g),this.b=Math.max(L,this.b),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b}equalsFloats(I,x,L){return this.equalsToFloats(I,x,L)}equalsToFloats(I,x,L){return this.r===I&&this.g===x&&this.b===L}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.e;return(0,Y.WithinEpsilon)(this.r,I.r,x)&&(0,Y.WithinEpsilon)(this.g,I.g,x)&&(0,Y.WithinEpsilon)(this.b,I.b,x)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}scale(I){return new Q(this.r*I,this.g*I,this.b*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this}scaleToRef(I,x){return x.r=this.r*I,x.g=this.g*I,x.b=this.b*I,x}scaleAndAddToRef(I,x){return x.r+=this.r*I,x.g+=this.g*I,x.b+=this.b*I,x}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,L=arguments.length>2?arguments[2]:void 0;return L.r=(0,Y.Clamp)(this.r,I,x),L.g=(0,Y.Clamp)(this.g,I,x),L.b=(0,Y.Clamp)(this.b,I,x),L}add(I){return new Q(this.r+I.r,this.g+I.g,this.b+I.b)}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this}addInPlaceFromFloats(I,x,L){return this.r+=I,this.g+=x,this.b+=L,this}addToRef(I,x){return x.r=this.r+I.r,x.g=this.g+I.g,x.b=this.b+I.b,x}Ux(I){return new Q(this.r-I.r,this.g-I.g,this.b-I.b)}subtractToRef(I,x){return x.r=this.r-I.r,x.g=this.g-I.g,x.b=this.b-I.b,x}aQ(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this}subtractFromFloats(I,x,L){return new Q(this.r-I,this.g-x,this.b-L)}subtractFromFloatsToRef(I,x,L,F){return F.r=this.r-I,F.g=this.g-x,F.b=this.b-L,F}clone(){return new Q(this.r,this.g,this.b)}X(I){return this.r=I.r,this.g=I.g,this.b=I.b,this}YB(I,x,L){return this.r=I,this.g=x,this.b=L,this}set(I,x,L){return this.YB(I,x,L)}BB(I){return this.r=this.g=this.b=I,this}toHexString(){const I=Math.round(255*this.r),x=Math.round(255*this.g),L=Math.round(255*this.b);return"#"+(0,Y.ToHex)(I)+(0,Y.ToHex)(x)+(0,Y.ToHex)(L)}fromHexString(I){return"#"!==I.substring(0,1)||7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new Q)}toHSVToRef(I){const x=this.r,L=this.g,F=this.b,X=Math.max(x,L,F),G=Math.min(x,L,F);let Y=0,p=0;const B=X,l=X-G;return 0!==X&&(p=l/X),X!=G&&(X==x?(Y=(L-F)/l,L<F&&(Y+=6)):X==L?Y=(F-x)/l+2:X==F&&(Y=(x-L)/l+4),Y*=60),I.r=Y,I.g=p,I.b=B,I}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new Q;return this.toLinearSpaceToRef(x,I),x}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=B(this.r),I.g=B(this.g),I.b=B(this.b)):(I.r=p(this.r),I.g=p(this.g),I.b=p(this.b)),this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new Q;return this.toGammaSpaceToRef(x,I),x}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=W(this.r),I.g=W(this.g),I.b=W(this.b)):(I.r=l(this.r),I.g=l(this.g),I.b=l(this.b)),this}static HSVtoRGBToRef(I,x,L,F){const X=L*x,G=I/60,Y=X*(1-Math.abs(G%2-1));let p=0,B=0,l=0;G>=0&&G<=1?(p=X,B=Y):G>=1&&G<=2?(p=Y,B=X):G>=2&&G<=3?(B=X,l=Y):G>=3&&G<=4?(B=Y,l=X):G>=4&&G<=5?(p=Y,l=X):G>=5&&G<=6&&(p=X,l=Y);const W=L-X;return F.r=p+W,F.g=B+W,F.b=l+W,F}static FromHSV(I,x,L){const F=new Q(0,0,0);return Q.HSVtoRGBToRef(I,x,L,F),F}static FromHexString(I){return new Q(0,0,0).fromHexString(I)}static tx(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(I[x],I[x+1],I[x+2])}static FromArrayToRef(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2?arguments[2]:void 0;L.r=I[x],L.g=I[x+1],L.b=I[x+2]}static FromInts(I,x,L){return new Q(I/255,x/255,L/255)}static Lerp(I,x,L){const F=new Q(0,0,0);return Q.LerpToRef(I,x,L,F),F}static LerpToRef(I,x,L,F){F.r=I.r+(x.r-I.r)*L,F.g=I.g+(x.g-I.g)*L,F.b=I.b+(x.b-I.b)*L}static Hermite(I,x,L,F,X){const G=X*X,Y=X*G,p=2*Y-3*G+1,B=-2*Y+3*G,l=Y-2*G+X,W=Y-G,e=I.r*p+L.r*B+x.r*l+F.r*W,g=I.g*p+L.g*B+x.g*l+F.g*W,v=I.b*p+L.b*B+x.b*l+F.b*W;return new Q(e,g,v)}static Hermite1stDerivative(I,x,L,F,X){const G=Q.Black();return this.Hermite1stDerivativeToRef(I,x,L,F,X,G),G}static Hermite1stDerivativeToRef(I,x,L,F,X,G){const Y=X*X;G.r=6*(Y-X)*I.r+(3*Y-4*X+1)*x.r+6*(-Y+X)*L.r+(3*Y-2*X)*F.r,G.g=6*(Y-X)*I.g+(3*Y-4*X+1)*x.g+6*(-Y+X)*L.g+(3*Y-2*X)*F.g,G.b=6*(Y-X)*I.b+(3*Y-4*X+1)*x.b+6*(-Y+X)*L.b+(3*Y-2*X)*F.b}static Red(){return new Q(1,0,0)}static Green(){return new Q(0,1,0)}static Blue(){return new Q(0,0,1)}static Black(){return new Q(0,0,0)}static get BlackReadOnly(){return Q._BlackReadOnly}static White(){return new Q(1,1,1)}static Purple(){return new Q(.5,0,.5)}static Magenta(){return new Q(1,0,1)}static Yellow(){return new Q(1,1,0)}static Gray(){return new Q(.5,.5,.5)}static Teal(){return new Q(0,1,1)}static Random(){return new Q(Math.random(),Math.random(),Math.random())}}Q._V8PerformanceHack=new Q(.5,.5,.5),Q._BlackReadOnly=Q.Black(),Object.defineProperties(Q.prototype,{dimension:{value:[3]},rank:{value:1}});class e{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=I,this.g=x,this.b=L,this.a=F}Cp(){return[this.r,this.g,this.b,this.a]}toArray(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[x]=this.r,I[x+1]=this.g,I[x+2]=this.b,I[x+3]=this.a,this}PL(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=I[x],this.g=I[x+1],this.b=I[x+2],this.a=I[x+3],this}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b&&this.a===I.a}add(I){return new e(this.r+I.r,this.g+I.g,this.b+I.b,this.a+I.a)}addToRef(I,x){return x.r=this.r+I.r,x.g=this.g+I.g,x.b=this.b+I.b,x.a=this.a+I.a,x}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this.a+=I.a,this}addInPlaceFromFloats(I,x,L,F){return this.r+=I,this.g+=x,this.b+=L,this.a+=F,this}Ux(I){return new e(this.r-I.r,this.g-I.g,this.b-I.b,this.a-I.a)}subtractToRef(I,x){return x.r=this.r-I.r,x.g=this.g-I.g,x.b=this.b-I.b,x.a=this.a-I.a,x}aQ(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this.a-=I.a,this}subtractFromFloats(I,x,L,F){return new e(this.r-I,this.g-x,this.b-L,this.a-F)}subtractFromFloatsToRef(I,x,L,F,X){return X.r=this.r-I,X.g=this.g-x,X.b=this.b-L,X.a=this.a-F,X}scale(I){return new e(this.r*I,this.g*I,this.b*I,this.a*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this.a*=I,this}scaleToRef(I,x){return x.r=this.r*I,x.g=this.g*I,x.b=this.b*I,x.a=this.a*I,x}scaleAndAddToRef(I,x){return x.r+=this.r*I,x.g+=this.g*I,x.b+=this.b*I,x.a+=this.a*I,x}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,L=arguments.length>2?arguments[2]:void 0;return L.r=(0,Y.Clamp)(this.r,I,x),L.g=(0,Y.Clamp)(this.g,I,x),L.b=(0,Y.Clamp)(this.b,I,x),L.a=(0,Y.Clamp)(this.a,I,x),L}multiply(I){return new e(this.r*I.r,this.g*I.g,this.b*I.b,this.a*I.a)}multiplyToRef(I,x){return x.r=this.r*I.r,x.g=this.g*I.g,x.b=this.b*I.b,x.a=this.a*I.a,x}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this.a*=I.a,this}multiplyByFloats(I,x,L,F){return new e(this.r*I,this.g*x,this.b*L,this.a*F)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,x){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.r=Math.min(this.r,I.r),this.g=Math.min(this.g,I.g),this.b=Math.min(this.b,I.b),this.a=Math.min(this.a,I.a),this}maximizeInPlace(I){return this.r=Math.max(this.r,I.r),this.g=Math.max(this.g,I.g),this.b=Math.max(this.b,I.b),this.a=Math.max(this.a,I.a),this}minimizeInPlaceFromFloats(I,x,L,F){return this.r=Math.min(I,this.r),this.g=Math.min(x,this.g),this.b=Math.min(L,this.b),this.a=Math.min(F,this.a),this}maximizeInPlaceFromFloats(I,x,L,F){return this.r=Math.max(I,this.r),this.g=Math.max(x,this.g),this.b=Math.max(L,this.b),this.a=Math.max(F,this.a),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.e;return(0,Y.WithinEpsilon)(this.r,I.r,x)&&(0,Y.WithinEpsilon)(this.g,I.g,x)&&(0,Y.WithinEpsilon)(this.b,I.b,x)&&(0,Y.WithinEpsilon)(this.a,I.a,x)}equalsToFloats(I,x,L,F){return this.r===I&&this.g===x&&this.b===L&&this.a===F}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"lB"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I=397*I^255*this.a,I}clone(){return(new e).X(this)}X(I){return this.r=I.r,this.g=I.g,this.b=I.b,this.a=I.a,this}YB(I,x,L,F){return this.r=I,this.g=x,this.b=L,this.a=F,this}set(I,x,L,F){return this.YB(I,x,L,F)}BB(I){return this.r=this.g=this.b=this.a=I,this}toHexString(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=Math.round(255*this.r),L=Math.round(255*this.g),F=Math.round(255*this.b);if(I)return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(L)+(0,Y.ToHex)(F);const X=Math.round(255*this.a);return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(L)+(0,Y.ToHex)(F)+(0,Y.ToHex)(X)}fromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255,9===I.length&&(this.a=parseInt(I.substring(7,9),16)/255)),this}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new e;return this.toLinearSpaceToRef(x,I),x}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=B(this.r),I.g=B(this.g),I.b=B(this.b)):(I.r=p(this.r),I.g=p(this.g),I.b=p(this.b)),I.a=this.a,this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new e;return this.toGammaSpaceToRef(x,I),x}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=W(this.r),I.g=W(this.g),I.b=W(this.b)):(I.r=l(this.r),I.g=l(this.g),I.b=l(this.b)),I.a=this.a,this}static FromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length?new e(0,0,0,0):new e(0,0,0,1).fromHexString(I)}static Lerp(I,x,L){return e.LerpToRef(I,x,L,new e)}static LerpToRef(I,x,L,F){return F.r=I.r+(x.r-I.r)*L,F.g=I.g+(x.g-I.g)*L,F.b=I.b+(x.b-I.b)*L,F.a=I.a+(x.a-I.a)*L,F}static Hermite(I,x,L,F,X){const G=X*X,Y=X*G,p=2*Y-3*G+1,B=-2*Y+3*G,l=Y-2*G+X,W=Y-G,Q=I.r*p+L.r*B+x.r*l+F.r*W,g=I.g*p+L.g*B+x.g*l+F.g*W,v=I.b*p+L.b*B+x.b*l+F.b*W,z=I.a*p+L.a*B+x.a*l+F.a*W;return new e(Q,g,v,z)}static Hermite1stDerivative(I,x,L,F,X){const G=new e;return this.Hermite1stDerivativeToRef(I,x,L,F,X,G),G}static Hermite1stDerivativeToRef(I,x,L,F,X,G){const Y=X*X;G.r=6*(Y-X)*I.r+(3*Y-4*X+1)*x.r+6*(-Y+X)*L.r+(3*Y-2*X)*F.r,G.g=6*(Y-X)*I.g+(3*Y-4*X+1)*x.g+6*(-Y+X)*L.g+(3*Y-2*X)*F.g,G.b=6*(Y-X)*I.b+(3*Y-4*X+1)*x.b+6*(-Y+X)*L.b+(3*Y-2*X)*F.b,G.a=6*(Y-X)*I.a+(3*Y-4*X+1)*x.a+6*(-Y+X)*L.a+(3*Y-2*X)*F.a}static FromColor3(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e(I.r,I.g,I.b,x)}static tx(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(I[x],I[x+1],I[x+2],I[x+3])}static FromArrayToRef(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2?arguments[2]:void 0;L.r=I[x],L.g=I[x+1],L.b=I[x+2],L.a=I[x+3]}static FromInts(I,x,L,F){return new e(I/255,x/255,L/255,F/255)}static CheckColors4(I,x){if(I.length===3*x){const x=[];for(let L=0;L<I.length;L+=3){const F=L/3*4;x[F]=I[L],x[F+1]=I[L+1],x[F+2]=I[L+2],x[F+3]=1}return x}return I}}e._V8PerformanceHack=new e(.5,.5,.5,.5),Object.defineProperties(e.prototype,{dimension:{value:[4]},rank:{value:1}});class g{}g.Tx=(0,F.c)(3,Q.Black),g.lB=(0,F.c)(3,(()=>new e(0,0,0,0))),(0,X.d)("BABYLON.Color3",Q),(0,X.d)("BABYLON.Color4",e)}}]);