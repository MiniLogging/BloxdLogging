"use strict";(self.hmihoa2fs98=self.hmihoa2fs98||[]).push([[17],{11725:(b,d,P)=>{P.r(d),P.d(d,{Nd:()=>Y,ci:()=>s,TmpColors:()=>E});var G=P(11691),W=P(11639),i=P(11688),q=P(11700);function C(b){return Math.pow(b,i.j)}function J(b){return b<=.04045?.0773993808*b:Math.pow(.947867299*(b+.055),2.4)}function L(b){return Math.pow(b,i.h)}function x(b){return b<=.0031308?12.92*b:1.055*Math.pow(b,.41666)-.055}class Y{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=b,this.g=d,this.b=P}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Nd"}getHashCode(){let b=255*this.r|0;return b=397*b^255*this.g,b=397*b^255*this.b,b}toArray(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[d]=this.r,b[d+1]=this.g,b[d+2]=this.b,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y.FromArrayToRef(b,d,this),this}toColor4(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new s(this.r,this.g,this.b,b)}jd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(b){return new Y(this.r*b.r,this.g*b.g,this.b*b.b)}multiplyToRef(b,d){return d.r=this.r*b.r,d.g=this.g*b.g,d.b=this.b*b.b,d}multiplyInPlace(b){return this.r*=b.r,this.g*=b.g,this.b*=b.b,this}multiplyByFloats(b,d,P){return new Y(this.r*b,this.g*d,this.b*P)}divide(b){throw new ReferenceError("Can not divide a color")}divideToRef(b,d){throw new ReferenceError("Can not divide a color")}divideInPlace(b){throw new ReferenceError("Can not divide a color")}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b.r,b.g,b.b)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b.r,b.g,b.b)}minimizeInPlaceFromFloats(b,d,P){return this.r=Math.min(b,this.r),this.g=Math.min(d,this.g),this.b=Math.min(P,this.b),this}maximizeInPlaceFromFloats(b,d,P){return this.r=Math.max(b,this.r),this.g=Math.max(d,this.g),this.b=Math.max(P,this.b),this}floorToRef(b){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(b){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(b){return b&&this.r===b.r&&this.g===b.g&&this.b===b.b}equalsFloats(b,d,P){return this.equalsToFloats(b,d,P)}equalsToFloats(b,d,P){return this.r===b&&this.g===d&&this.b===P}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.c;return(0,q.WithinEpsilon)(this.r,b.r,d)&&(0,q.WithinEpsilon)(this.g,b.g,d)&&(0,q.WithinEpsilon)(this.b,b.b,d)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(b){throw new ReferenceError("Can not negate a color")}scale(b){return new Y(this.r*b,this.g*b,this.b*b)}scaleInPlace(b){return this.r*=b,this.g*=b,this.b*=b,this}scaleToRef(b,d){return d.r=this.r*b,d.g=this.g*b,d.b=this.b*b,d}scaleAndAddToRef(b,d){return d.r+=this.r*b,d.g+=this.g*b,d.b+=this.b*b,d}clampToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,q.Clamp)(this.r,b,d),P.g=(0,q.Clamp)(this.g,b,d),P.b=(0,q.Clamp)(this.b,b,d),P}add(b){return new Y(this.r+b.r,this.g+b.g,this.b+b.b)}addInPlace(b){return this.r+=b.r,this.g+=b.g,this.b+=b.b,this}addInPlaceFromFloats(b,d,P){return this.r+=b,this.g+=d,this.b+=P,this}addToRef(b,d){return d.r=this.r+b.r,d.g=this.g+b.g,d.b=this.b+b.b,d}Rd(b){return new Y(this.r-b.r,this.g-b.g,this.b-b.b)}subtractToRef(b,d){return d.r=this.r-b.r,d.g=this.g-b.g,d.b=this.b-b.b,d}GY(b){return this.r-=b.r,this.g-=b.g,this.b-=b.b,this}subtractFromFloats(b,d,P){return new Y(this.r-b,this.g-d,this.b-P)}subtractFromFloatsToRef(b,d,P,G){return G.r=this.r-b,G.g=this.g-d,G.b=this.b-P,G}clone(){return new Y(this.r,this.g,this.b)}q(b){return this.r=b.r,this.g=b.g,this.b=b.b,this}Fd(b,d,P){return this.r=b,this.g=d,this.b=P,this}set(b,d,P){return this.Fd(b,d,P)}kd(b){return this.r=this.g=this.b=b,this}toHexString(){const b=Math.round(255*this.r),d=Math.round(255*this.g),P=Math.round(255*this.b);return"#"+(0,q.ToHex)(b)+(0,q.ToHex)(d)+(0,q.ToHex)(P)}fromHexString(b){return"#"!==b.substring(0,1)||7!==b.length||(this.r=parseInt(b.substring(1,3),16)/255,this.g=parseInt(b.substring(3,5),16)/255,this.b=parseInt(b.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new Y)}toHSVToRef(b){const d=this.r,P=this.g,G=this.b,W=Math.max(d,P,G),i=Math.min(d,P,G);let q=0,C=0;const J=W,L=W-i;return 0!==W&&(C=L/W),W!=i&&(W==d?(q=(P-G)/L,P<G&&(q+=6)):W==P?q=(G-d)/L+2:W==G&&(q=(d-P)/L+4),q*=60),b.r=q,b.g=C,b.b=J,b}toLinearSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new Y;return this.toLinearSpaceToRef(d,b),d}toLinearSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=J(this.r),b.g=J(this.g),b.b=J(this.b)):(b.r=C(this.r),b.g=C(this.g),b.b=C(this.b)),this}toGammaSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new Y;return this.toGammaSpaceToRef(d,b),d}toGammaSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=x(this.r),b.g=x(this.g),b.b=x(this.b)):(b.r=L(this.r),b.g=L(this.g),b.b=L(this.b)),this}static HSVtoRGBToRef(b,d,P,G){const W=P*d,i=b/60,q=W*(1-Math.abs(i%2-1));let C=0,J=0,L=0;i>=0&&i<=1?(C=W,J=q):i>=1&&i<=2?(C=q,J=W):i>=2&&i<=3?(J=W,L=q):i>=3&&i<=4?(J=q,L=W):i>=4&&i<=5?(C=q,L=W):i>=5&&i<=6&&(C=W,L=q);const x=P-W;return G.r=C+x,G.g=J+x,G.b=L+x,G}static FromHSV(b,d,P){const G=new Y(0,0,0);return Y.HSVtoRGBToRef(b,d,P,G),G}static FromHexString(b){return new Y(0,0,0).fromHexString(b)}static Od(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Y(b[d],b[d+1],b[d+2])}static FromArrayToRef(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=b[d],P.g=b[d+1],P.b=b[d+2]}static FromInts(b,d,P){return new Y(b/255,d/255,P/255)}static Lerp(b,d,P){const G=new Y(0,0,0);return Y.LerpToRef(b,d,P,G),G}static LerpToRef(b,d,P,G){G.r=b.r+(d.r-b.r)*P,G.g=b.g+(d.g-b.g)*P,G.b=b.b+(d.b-b.b)*P}static Hermite(b,d,P,G,W){const i=W*W,q=W*i,C=2*q-3*i+1,J=-2*q+3*i,L=q-2*i+W,x=q-i,s=b.r*C+P.r*J+d.r*L+G.r*x,E=b.g*C+P.g*J+d.g*L+G.g*x,w=b.b*C+P.b*J+d.b*L+G.b*x;return new Y(s,E,w)}static Hermite1stDerivative(b,d,P,G,W){const i=Y.Black();return this.Hermite1stDerivativeToRef(b,d,P,G,W,i),i}static Hermite1stDerivativeToRef(b,d,P,G,W,i){const q=W*W;i.r=6*(q-W)*b.r+(3*q-4*W+1)*d.r+6*(-q+W)*P.r+(3*q-2*W)*G.r,i.g=6*(q-W)*b.g+(3*q-4*W+1)*d.g+6*(-q+W)*P.g+(3*q-2*W)*G.g,i.b=6*(q-W)*b.b+(3*q-4*W+1)*d.b+6*(-q+W)*P.b+(3*q-2*W)*G.b}static Red(){return new Y(1,0,0)}static Green(){return new Y(0,1,0)}static Blue(){return new Y(0,0,1)}static Black(){return new Y(0,0,0)}static get BlackReadOnly(){return Y._BlackReadOnly}static White(){return new Y(1,1,1)}static Purple(){return new Y(.5,0,.5)}static Magenta(){return new Y(1,0,1)}static Yellow(){return new Y(1,1,0)}static Gray(){return new Y(.5,.5,.5)}static Teal(){return new Y(0,1,1)}static Random(){return new Y(Math.random(),Math.random(),Math.random())}}Y._V8PerformanceHack=new Y(.5,.5,.5),Y._BlackReadOnly=Y.Black(),Object.defineProperties(Y.prototype,{dimension:{value:[3]},rank:{value:1}});class s{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=b,this.g=d,this.b=P,this.a=G}jd(){return[this.r,this.g,this.b,this.a]}toArray(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[d]=this.r,b[d+1]=this.g,b[d+2]=this.b,b[d+3]=this.a,this}DP(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=b[d],this.g=b[d+1],this.b=b[d+2],this.a=b[d+3],this}equals(b){return b&&this.r===b.r&&this.g===b.g&&this.b===b.b&&this.a===b.a}add(b){return new s(this.r+b.r,this.g+b.g,this.b+b.b,this.a+b.a)}addToRef(b,d){return d.r=this.r+b.r,d.g=this.g+b.g,d.b=this.b+b.b,d.a=this.a+b.a,d}addInPlace(b){return this.r+=b.r,this.g+=b.g,this.b+=b.b,this.a+=b.a,this}addInPlaceFromFloats(b,d,P,G){return this.r+=b,this.g+=d,this.b+=P,this.a+=G,this}Rd(b){return new s(this.r-b.r,this.g-b.g,this.b-b.b,this.a-b.a)}subtractToRef(b,d){return d.r=this.r-b.r,d.g=this.g-b.g,d.b=this.b-b.b,d.a=this.a-b.a,d}GY(b){return this.r-=b.r,this.g-=b.g,this.b-=b.b,this.a-=b.a,this}subtractFromFloats(b,d,P,G){return new s(this.r-b,this.g-d,this.b-P,this.a-G)}subtractFromFloatsToRef(b,d,P,G,W){return W.r=this.r-b,W.g=this.g-d,W.b=this.b-P,W.a=this.a-G,W}scale(b){return new s(this.r*b,this.g*b,this.b*b,this.a*b)}scaleInPlace(b){return this.r*=b,this.g*=b,this.b*=b,this.a*=b,this}scaleToRef(b,d){return d.r=this.r*b,d.g=this.g*b,d.b=this.b*b,d.a=this.a*b,d}scaleAndAddToRef(b,d){return d.r+=this.r*b,d.g+=this.g*b,d.b+=this.b*b,d.a+=this.a*b,d}clampToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,q.Clamp)(this.r,b,d),P.g=(0,q.Clamp)(this.g,b,d),P.b=(0,q.Clamp)(this.b,b,d),P.a=(0,q.Clamp)(this.a,b,d),P}multiply(b){return new s(this.r*b.r,this.g*b.g,this.b*b.b,this.a*b.a)}multiplyToRef(b,d){return d.r=this.r*b.r,d.g=this.g*b.g,d.b=this.b*b.b,d.a=this.a*b.a,d}multiplyInPlace(b){return this.r*=b.r,this.g*=b.g,this.b*=b.b,this.a*=b.a,this}multiplyByFloats(b,d,P,G){return new s(this.r*b,this.g*d,this.b*P,this.a*G)}divide(b){throw new ReferenceError("Can not divide a color")}divideToRef(b,d){throw new ReferenceError("Can not divide a color")}divideInPlace(b){throw new ReferenceError("Can not divide a color")}minimizeInPlace(b){return this.r=Math.min(this.r,b.r),this.g=Math.min(this.g,b.g),this.b=Math.min(this.b,b.b),this.a=Math.min(this.a,b.a),this}maximizeInPlace(b){return this.r=Math.max(this.r,b.r),this.g=Math.max(this.g,b.g),this.b=Math.max(this.b,b.b),this.a=Math.max(this.a,b.a),this}minimizeInPlaceFromFloats(b,d,P,G){return this.r=Math.min(b,this.r),this.g=Math.min(d,this.g),this.b=Math.min(P,this.b),this.a=Math.min(G,this.a),this}maximizeInPlaceFromFloats(b,d,P,G){return this.r=Math.max(b,this.r),this.g=Math.max(d,this.g),this.b=Math.max(P,this.b),this.a=Math.max(G,this.a),this}floorToRef(b){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(b){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(b){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.c;return(0,q.WithinEpsilon)(this.r,b.r,d)&&(0,q.WithinEpsilon)(this.g,b.g,d)&&(0,q.WithinEpsilon)(this.b,b.b,d)&&(0,q.WithinEpsilon)(this.a,b.a,d)}equalsToFloats(b,d,P,G){return this.r===b&&this.g===d&&this.b===P&&this.a===G}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ci"}getHashCode(){let b=255*this.r|0;return b=397*b^255*this.g,b=397*b^255*this.b,b=397*b^255*this.a,b}clone(){return(new s).q(this)}q(b){return this.r=b.r,this.g=b.g,this.b=b.b,this.a=b.a,this}Fd(b,d,P,G){return this.r=b,this.g=d,this.b=P,this.a=G,this}set(b,d,P,G){return this.Fd(b,d,P,G)}kd(b){return this.r=this.g=this.b=this.a=b,this}toHexString(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=Math.round(255*this.r),P=Math.round(255*this.g),G=Math.round(255*this.b);if(b)return"#"+(0,q.ToHex)(d)+(0,q.ToHex)(P)+(0,q.ToHex)(G);const W=Math.round(255*this.a);return"#"+(0,q.ToHex)(d)+(0,q.ToHex)(P)+(0,q.ToHex)(G)+(0,q.ToHex)(W)}fromHexString(b){return"#"!==b.substring(0,1)||9!==b.length&&7!==b.length||(this.r=parseInt(b.substring(1,3),16)/255,this.g=parseInt(b.substring(3,5),16)/255,this.b=parseInt(b.substring(5,7),16)/255,9===b.length&&(this.a=parseInt(b.substring(7,9),16)/255)),this}toLinearSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new s;return this.toLinearSpaceToRef(d,b),d}toLinearSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=J(this.r),b.g=J(this.g),b.b=J(this.b)):(b.r=C(this.r),b.g=C(this.g),b.b=C(this.b)),b.a=this.a,this}toGammaSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new s;return this.toGammaSpaceToRef(d,b),d}toGammaSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=x(this.r),b.g=x(this.g),b.b=x(this.b)):(b.r=L(this.r),b.g=L(this.g),b.b=L(this.b)),b.a=this.a,this}static FromHexString(b){return"#"!==b.substring(0,1)||9!==b.length&&7!==b.length?new s(0,0,0,0):new s(0,0,0,1).fromHexString(b)}static Lerp(b,d,P){return s.LerpToRef(b,d,P,new s)}static LerpToRef(b,d,P,G){return G.r=b.r+(d.r-b.r)*P,G.g=b.g+(d.g-b.g)*P,G.b=b.b+(d.b-b.b)*P,G.a=b.a+(d.a-b.a)*P,G}static Hermite(b,d,P,G,W){const i=W*W,q=W*i,C=2*q-3*i+1,J=-2*q+3*i,L=q-2*i+W,x=q-i,Y=b.r*C+P.r*J+d.r*L+G.r*x,E=b.g*C+P.g*J+d.g*L+G.g*x,w=b.b*C+P.b*J+d.b*L+G.b*x,t=b.a*C+P.a*J+d.a*L+G.a*x;return new s(Y,E,w,t)}static Hermite1stDerivative(b,d,P,G,W){const i=new s;return this.Hermite1stDerivativeToRef(b,d,P,G,W,i),i}static Hermite1stDerivativeToRef(b,d,P,G,W,i){const q=W*W;i.r=6*(q-W)*b.r+(3*q-4*W+1)*d.r+6*(-q+W)*P.r+(3*q-2*W)*G.r,i.g=6*(q-W)*b.g+(3*q-4*W+1)*d.g+6*(-q+W)*P.g+(3*q-2*W)*G.g,i.b=6*(q-W)*b.b+(3*q-4*W+1)*d.b+6*(-q+W)*P.b+(3*q-2*W)*G.b,i.a=6*(q-W)*b.a+(3*q-4*W+1)*d.a+6*(-q+W)*P.a+(3*q-2*W)*G.a}static FromColor3(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s(b.r,b.g,b.b,d)}static Od(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(b[d],b[d+1],b[d+2],b[d+3])}static FromArrayToRef(b){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=b[d],P.g=b[d+1],P.b=b[d+2],P.a=b[d+3]}static FromInts(b,d,P,G){return new s(b/255,d/255,P/255,G/255)}static CheckColors4(b,d){if(b.length===3*d){const d=[];for(let P=0;P<b.length;P+=3){const G=P/3*4;d[G]=b[P],d[G+1]=b[P+1],d[G+2]=b[P+2],d[G+3]=1}return d}return b}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class E{}E.Nd=(0,G.b)(3,Y.Black),E.ci=(0,G.b)(3,(()=>new s(0,0,0,0))),(0,W.f)("BABYLON.Color3",Y),(0,W.f)("BABYLON.Color4",s)}}]);