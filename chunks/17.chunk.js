"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[17],{11165:(I,E,j)=>{j.r(E),j.d(E,{qE:()=>o,hh:()=>Z,TmpColors:()=>c});var e=j(11127),w=j(11073),z=j(11120),h=j(11136);function t(I){return Math.pow(I,z.l)}function U(I){return I<=.04045?.0773993808*I:Math.pow(.947867299*(I+.055),2.4)}function R(I){return Math.pow(I,z.h)}function P(I){return I<=.0031308?12.92*I:1.055*Math.pow(I,.41666)-.055}class o{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=I,this.g=E,this.b=j}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"qE"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I}toArray(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[E]=this.r,I[E+1]=this.g,I[E+2]=this.b,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(I,E,this),this}toColor4(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new Z(this.r,this.g,this.b,I)}re(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(I){return new o(this.r*I.r,this.g*I.g,this.b*I.b)}multiplyToRef(I,E){return E.r=this.r*I.r,E.g=this.g*I.g,E.b=this.b*I.b,E}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this}multiplyByFloats(I,E,j){return new o(this.r*I,this.g*E,this.b*j)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,E){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.r,I.g,I.b)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.r,I.g,I.b)}minimizeInPlaceFromFloats(I,E,j){return this.r=Math.min(I,this.r),this.g=Math.min(E,this.g),this.b=Math.min(j,this.b),this}maximizeInPlaceFromFloats(I,E,j){return this.r=Math.max(I,this.r),this.g=Math.max(E,this.g),this.b=Math.max(j,this.b),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b}equalsFloats(I,E,j){return this.equalsToFloats(I,E,j)}equalsToFloats(I,E,j){return this.r===I&&this.g===E&&this.b===j}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.b;return(0,h.WithinEpsilon)(this.r,I.r,E)&&(0,h.WithinEpsilon)(this.g,I.g,E)&&(0,h.WithinEpsilon)(this.b,I.b,E)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}scale(I){return new o(this.r*I,this.g*I,this.b*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this}scaleToRef(I,E){return E.r=this.r*I,E.g=this.g*I,E.b=this.b*I,E}scaleAndAddToRef(I,E){return E.r+=this.r*I,E.g+=this.g*I,E.b+=this.b*I,E}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.r=(0,h.Clamp)(this.r,I,E),j.g=(0,h.Clamp)(this.g,I,E),j.b=(0,h.Clamp)(this.b,I,E),j}add(I){return new o(this.r+I.r,this.g+I.g,this.b+I.b)}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this}addInPlaceFromFloats(I,E,j){return this.r+=I,this.g+=E,this.b+=j,this}addToRef(I,E){return E.r=this.r+I.r,E.g=this.g+I.g,E.b=this.b+I.b,E}FE(I){return new o(this.r-I.r,this.g-I.g,this.b-I.b)}subtractToRef(I,E){return E.r=this.r-I.r,E.g=this.g-I.g,E.b=this.b-I.b,E}Uo(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this}subtractFromFloats(I,E,j){return new o(this.r-I,this.g-E,this.b-j)}subtractFromFloatsToRef(I,E,j,e){return e.r=this.r-I,e.g=this.g-E,e.b=this.b-j,e}clone(){return new o(this.r,this.g,this.b)}U(I){return this.r=I.r,this.g=I.g,this.b=I.b,this}nz(I,E,j){return this.r=I,this.g=E,this.b=j,this}set(I,E,j){return this.nz(I,E,j)}mz(I){return this.r=this.g=this.b=I,this}toHexString(){const I=Math.round(255*this.r),E=Math.round(255*this.g),j=Math.round(255*this.b);return"#"+(0,h.ToHex)(I)+(0,h.ToHex)(E)+(0,h.ToHex)(j)}fromHexString(I){return"#"!==I.substring(0,1)||7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new o)}toHSVToRef(I){const E=this.r,j=this.g,e=this.b,w=Math.max(E,j,e),z=Math.min(E,j,e);let h=0,t=0;const U=w,R=w-z;return 0!==w&&(t=R/w),w!=z&&(w==E?(h=(j-e)/R,j<e&&(h+=6)):w==j?h=(e-E)/R+2:w==e&&(h=(E-j)/R+4),h*=60),I.r=h,I.g=t,I.b=U,I}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new o;return this.toLinearSpaceToRef(E,I),E}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=U(this.r),I.g=U(this.g),I.b=U(this.b)):(I.r=t(this.r),I.g=t(this.g),I.b=t(this.b)),this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new o;return this.toGammaSpaceToRef(E,I),E}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=P(this.r),I.g=P(this.g),I.b=P(this.b)):(I.r=R(this.r),I.g=R(this.g),I.b=R(this.b)),this}static HSVtoRGBToRef(I,E,j,e){const w=j*E,z=I/60,h=w*(1-Math.abs(z%2-1));let t=0,U=0,R=0;z>=0&&z<=1?(t=w,U=h):z>=1&&z<=2?(t=h,U=w):z>=2&&z<=3?(U=w,R=h):z>=3&&z<=4?(U=h,R=w):z>=4&&z<=5?(t=h,R=w):z>=5&&z<=6&&(t=w,R=h);const P=j-w;return e.r=t+P,e.g=U+P,e.b=R+P,e}static FromHSV(I,E,j){const e=new o(0,0,0);return o.HSVtoRGBToRef(I,E,j,e),e}static FromHexString(I){return new o(0,0,0).fromHexString(I)}static xE(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o(I[E],I[E+1],I[E+2])}static FromArrayToRef(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2?arguments[2]:void 0;j.r=I[E],j.g=I[E+1],j.b=I[E+2]}static FromInts(I,E,j){return new o(I/255,E/255,j/255)}static Lerp(I,E,j){const e=new o(0,0,0);return o.LerpToRef(I,E,j,e),e}static LerpToRef(I,E,j,e){e.r=I.r+(E.r-I.r)*j,e.g=I.g+(E.g-I.g)*j,e.b=I.b+(E.b-I.b)*j}static Hermite(I,E,j,e,w){const z=w*w,h=w*z,t=2*h-3*z+1,U=-2*h+3*z,R=h-2*z+w,P=h-z,Z=I.r*t+j.r*U+E.r*R+e.r*P,c=I.g*t+j.g*U+E.g*R+e.g*P,K=I.b*t+j.b*U+E.b*R+e.b*P;return new o(Z,c,K)}static Hermite1stDerivative(I,E,j,e,w){const z=o.Black();return this.Hermite1stDerivativeToRef(I,E,j,e,w,z),z}static Hermite1stDerivativeToRef(I,E,j,e,w,z){const h=w*w;z.r=6*(h-w)*I.r+(3*h-4*w+1)*E.r+6*(-h+w)*j.r+(3*h-2*w)*e.r,z.g=6*(h-w)*I.g+(3*h-4*w+1)*E.g+6*(-h+w)*j.g+(3*h-2*w)*e.g,z.b=6*(h-w)*I.b+(3*h-4*w+1)*E.b+6*(-h+w)*j.b+(3*h-2*w)*e.b}static Red(){return new o(1,0,0)}static Green(){return new o(0,1,0)}static Blue(){return new o(0,0,1)}static Black(){return new o(0,0,0)}static get BlackReadOnly(){return o._BlackReadOnly}static White(){return new o(1,1,1)}static Purple(){return new o(.5,0,.5)}static Magenta(){return new o(1,0,1)}static Yellow(){return new o(1,1,0)}static Gray(){return new o(.5,.5,.5)}static Teal(){return new o(0,1,1)}static Random(){return new o(Math.random(),Math.random(),Math.random())}}o._V8PerformanceHack=new o(.5,.5,.5),o._BlackReadOnly=o.Black(),Object.defineProperties(o.prototype,{dimension:{value:[3]},rank:{value:1}});class Z{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=I,this.g=E,this.b=j,this.a=e}re(){return[this.r,this.g,this.b,this.a]}toArray(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[E]=this.r,I[E+1]=this.g,I[E+2]=this.b,I[E+3]=this.a,this}Kj(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=I[E],this.g=I[E+1],this.b=I[E+2],this.a=I[E+3],this}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b&&this.a===I.a}add(I){return new Z(this.r+I.r,this.g+I.g,this.b+I.b,this.a+I.a)}addToRef(I,E){return E.r=this.r+I.r,E.g=this.g+I.g,E.b=this.b+I.b,E.a=this.a+I.a,E}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this.a+=I.a,this}addInPlaceFromFloats(I,E,j,e){return this.r+=I,this.g+=E,this.b+=j,this.a+=e,this}FE(I){return new Z(this.r-I.r,this.g-I.g,this.b-I.b,this.a-I.a)}subtractToRef(I,E){return E.r=this.r-I.r,E.g=this.g-I.g,E.b=this.b-I.b,E.a=this.a-I.a,E}Uo(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this.a-=I.a,this}subtractFromFloats(I,E,j,e){return new Z(this.r-I,this.g-E,this.b-j,this.a-e)}subtractFromFloatsToRef(I,E,j,e,w){return w.r=this.r-I,w.g=this.g-E,w.b=this.b-j,w.a=this.a-e,w}scale(I){return new Z(this.r*I,this.g*I,this.b*I,this.a*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this.a*=I,this}scaleToRef(I,E){return E.r=this.r*I,E.g=this.g*I,E.b=this.b*I,E.a=this.a*I,E}scaleAndAddToRef(I,E){return E.r+=this.r*I,E.g+=this.g*I,E.b+=this.b*I,E.a+=this.a*I,E}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,j=arguments.length>2?arguments[2]:void 0;return j.r=(0,h.Clamp)(this.r,I,E),j.g=(0,h.Clamp)(this.g,I,E),j.b=(0,h.Clamp)(this.b,I,E),j.a=(0,h.Clamp)(this.a,I,E),j}multiply(I){return new Z(this.r*I.r,this.g*I.g,this.b*I.b,this.a*I.a)}multiplyToRef(I,E){return E.r=this.r*I.r,E.g=this.g*I.g,E.b=this.b*I.b,E.a=this.a*I.a,E}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this.a*=I.a,this}multiplyByFloats(I,E,j,e){return new Z(this.r*I,this.g*E,this.b*j,this.a*e)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,E){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.r=Math.min(this.r,I.r),this.g=Math.min(this.g,I.g),this.b=Math.min(this.b,I.b),this.a=Math.min(this.a,I.a),this}maximizeInPlace(I){return this.r=Math.max(this.r,I.r),this.g=Math.max(this.g,I.g),this.b=Math.max(this.b,I.b),this.a=Math.max(this.a,I.a),this}minimizeInPlaceFromFloats(I,E,j,e){return this.r=Math.min(I,this.r),this.g=Math.min(E,this.g),this.b=Math.min(j,this.b),this.a=Math.min(e,this.a),this}maximizeInPlaceFromFloats(I,E,j,e){return this.r=Math.max(I,this.r),this.g=Math.max(E,this.g),this.b=Math.max(j,this.b),this.a=Math.max(e,this.a),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.b;return(0,h.WithinEpsilon)(this.r,I.r,E)&&(0,h.WithinEpsilon)(this.g,I.g,E)&&(0,h.WithinEpsilon)(this.b,I.b,E)&&(0,h.WithinEpsilon)(this.a,I.a,E)}equalsToFloats(I,E,j,e){return this.r===I&&this.g===E&&this.b===j&&this.a===e}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"hh"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I=397*I^255*this.a,I}clone(){return(new Z).U(this)}U(I){return this.r=I.r,this.g=I.g,this.b=I.b,this.a=I.a,this}nz(I,E,j,e){return this.r=I,this.g=E,this.b=j,this.a=e,this}set(I,E,j,e){return this.nz(I,E,j,e)}mz(I){return this.r=this.g=this.b=this.a=I,this}toHexString(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=Math.round(255*this.r),j=Math.round(255*this.g),e=Math.round(255*this.b);if(I)return"#"+(0,h.ToHex)(E)+(0,h.ToHex)(j)+(0,h.ToHex)(e);const w=Math.round(255*this.a);return"#"+(0,h.ToHex)(E)+(0,h.ToHex)(j)+(0,h.ToHex)(e)+(0,h.ToHex)(w)}fromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255,9===I.length&&(this.a=parseInt(I.substring(7,9),16)/255)),this}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new Z;return this.toLinearSpaceToRef(E,I),E}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=U(this.r),I.g=U(this.g),I.b=U(this.b)):(I.r=t(this.r),I.g=t(this.g),I.b=t(this.b)),I.a=this.a,this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new Z;return this.toGammaSpaceToRef(E,I),E}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=P(this.r),I.g=P(this.g),I.b=P(this.b)):(I.r=R(this.r),I.g=R(this.g),I.b=R(this.b)),I.a=this.a,this}static FromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length?new Z(0,0,0,0):new Z(0,0,0,1).fromHexString(I)}static Lerp(I,E,j){return Z.LerpToRef(I,E,j,new Z)}static LerpToRef(I,E,j,e){return e.r=I.r+(E.r-I.r)*j,e.g=I.g+(E.g-I.g)*j,e.b=I.b+(E.b-I.b)*j,e.a=I.a+(E.a-I.a)*j,e}static Hermite(I,E,j,e,w){const z=w*w,h=w*z,t=2*h-3*z+1,U=-2*h+3*z,R=h-2*z+w,P=h-z,o=I.r*t+j.r*U+E.r*R+e.r*P,c=I.g*t+j.g*U+E.g*R+e.g*P,K=I.b*t+j.b*U+E.b*R+e.b*P,L=I.a*t+j.a*U+E.a*R+e.a*P;return new Z(o,c,K,L)}static Hermite1stDerivative(I,E,j,e,w){const z=new Z;return this.Hermite1stDerivativeToRef(I,E,j,e,w,z),z}static Hermite1stDerivativeToRef(I,E,j,e,w,z){const h=w*w;z.r=6*(h-w)*I.r+(3*h-4*w+1)*E.r+6*(-h+w)*j.r+(3*h-2*w)*e.r,z.g=6*(h-w)*I.g+(3*h-4*w+1)*E.g+6*(-h+w)*j.g+(3*h-2*w)*e.g,z.b=6*(h-w)*I.b+(3*h-4*w+1)*E.b+6*(-h+w)*j.b+(3*h-2*w)*e.b,z.a=6*(h-w)*I.a+(3*h-4*w+1)*E.a+6*(-h+w)*j.a+(3*h-2*w)*e.a}static FromColor3(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z(I.r,I.g,I.b,E)}static xE(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(I[E],I[E+1],I[E+2],I[E+3])}static FromArrayToRef(I){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,j=arguments.length>2?arguments[2]:void 0;j.r=I[E],j.g=I[E+1],j.b=I[E+2],j.a=I[E+3]}static FromInts(I,E,j,e){return new Z(I/255,E/255,j/255,e/255)}static CheckColors4(I,E){if(I.length===3*E){const E=[];for(let j=0;j<I.length;j+=3){const e=j/3*4;E[e]=I[j],E[e+1]=I[j+1],E[e+2]=I[j+2],E[e+3]=1}return E}return I}}Z._V8PerformanceHack=new Z(.5,.5,.5,.5),Object.defineProperties(Z.prototype,{dimension:{value:[4]},rank:{value:1}});class c{}c.qE=(0,e.d)(3,o.Black),c.hh=(0,e.d)(3,(()=>new Z(0,0,0,0))),(0,w.h)("BABYLON.Color3",o),(0,w.h)("BABYLON.Color4",Z)}}]);