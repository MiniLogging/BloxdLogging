"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[17],{12967:(z,u,U)=>{U.r(u),U.d(u,{Tu:()=>d,wg:()=>mz,TmpColors:()=>Z});var J=U(12926),v=U(12875),f=U(12917),g=U(12935);function w(z){return Math.pow(z,f.l)}function P(z){return z<=.04045?.0773993808*z:Math.pow(.947867299*(z+.055),2.4)}function R(z){return Math.pow(z,f.i)}function S(z){return z<=.0031308?12.92*z:1.055*Math.pow(z,.41666)-.055}class d{constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=z,this.g=u,this.b=U}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Tu"}getHashCode(){let z=255*this.r|0;return z=397*z^255*this.g,z=397*z^255*this.b,z}toArray(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z[u]=this.r,z[u+1]=this.g,z[u+2]=this.b,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return d.FromArrayToRef(z,u,this),this}toColor4(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new mz(this.r,this.g,this.b,z)}jf(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(z){return new d(this.r*z.r,this.g*z.g,this.b*z.b)}multiplyToRef(z,u){return u.r=this.r*z.r,u.g=this.g*z.g,u.b=this.b*z.b,u}multiplyInPlace(z){return this.r*=z.r,this.g*=z.g,this.b*=z.b,this}multiplyByFloats(z,u,U){return new d(this.r*z,this.g*u,this.b*U)}divide(z){throw new ReferenceError("Can not divide a color")}divideToRef(z,u){throw new ReferenceError("Can not divide a color")}divideInPlace(z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(z){return this.minimizeInPlaceFromFloats(z.r,z.g,z.b)}maximizeInPlace(z){return this.maximizeInPlaceFromFloats(z.r,z.g,z.b)}minimizeInPlaceFromFloats(z,u,U){return this.r=Math.min(z,this.r),this.g=Math.min(u,this.g),this.b=Math.min(U,this.b),this}maximizeInPlaceFromFloats(z,u,U){return this.r=Math.max(z,this.r),this.g=Math.max(u,this.g),this.b=Math.max(U,this.b),this}floorToRef(z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(z){return z&&this.r===z.r&&this.g===z.g&&this.b===z.b}equalsFloats(z,u,U){return this.equalsToFloats(z,u,U)}equalsToFloats(z,u,U){return this.r===z&&this.g===u&&this.b===U}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.d;return(0,g.WithinEpsilon)(this.r,z.r,u)&&(0,g.WithinEpsilon)(this.g,z.g,u)&&(0,g.WithinEpsilon)(this.b,z.b,u)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(z){throw new ReferenceError("Can not negate a color")}scale(z){return new d(this.r*z,this.g*z,this.b*z)}scaleInPlace(z){return this.r*=z,this.g*=z,this.b*=z,this}scaleToRef(z,u){return u.r=this.r*z,u.g=this.g*z,u.b=this.b*z,u}scaleAndAddToRef(z,u){return u.r+=this.r*z,u.g+=this.g*z,u.b+=this.b*z,u}clampToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,U=arguments.length>2?arguments[2]:void 0;return U.r=(0,g.Clamp)(this.r,z,u),U.g=(0,g.Clamp)(this.g,z,u),U.b=(0,g.Clamp)(this.b,z,u),U}add(z){return new d(this.r+z.r,this.g+z.g,this.b+z.b)}addInPlace(z){return this.r+=z.r,this.g+=z.g,this.b+=z.b,this}addInPlaceFromFloats(z,u,U){return this.r+=z,this.g+=u,this.b+=U,this}addToRef(z,u){return u.r=this.r+z.r,u.g=this.g+z.g,u.b=this.b+z.b,u}Cu(z){return new d(this.r-z.r,this.g-z.g,this.b-z.b)}subtractToRef(z,u){return u.r=this.r-z.r,u.g=this.g-z.g,u.b=this.b-z.b,u}dm(z){return this.r-=z.r,this.g-=z.g,this.b-=z.b,this}subtractFromFloats(z,u,U){return new d(this.r-z,this.g-u,this.b-U)}subtractFromFloatsToRef(z,u,U,J){return J.r=this.r-z,J.g=this.g-u,J.b=this.b-U,J}clone(){return new d(this.r,this.g,this.b)}v(z){return this.r=z.r,this.g=z.g,this.b=z.b,this}zg(z,u,U){return this.r=z,this.g=u,this.b=U,this}set(z,u,U){return this.zg(z,u,U)}fg(z){return this.r=this.g=this.b=z,this}toHexString(){const z=Math.round(255*this.r),u=Math.round(255*this.g),U=Math.round(255*this.b);return"#"+(0,g.ToHex)(z)+(0,g.ToHex)(u)+(0,g.ToHex)(U)}fromHexString(z){return"#"!==z.substring(0,1)||7!==z.length||(this.r=parseInt(z.substring(1,3),16)/255,this.g=parseInt(z.substring(3,5),16)/255,this.b=parseInt(z.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new d)}toHSVToRef(z){const u=this.r,U=this.g,J=this.b,v=Math.max(u,U,J),f=Math.min(u,U,J);let g=0,w=0;const P=v,R=v-f;return 0!==v&&(w=R/v),v!=f&&(v==u?(g=(U-J)/R,U<J&&(g+=6)):v==U?g=(J-u)/R+2:v==J&&(g=(u-U)/R+4),g*=60),z.r=g,z.g=w,z.b=P,z}toLinearSpace(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new d;return this.toLinearSpaceToRef(u,z),u}toLinearSpaceToRef(z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(z.r=P(this.r),z.g=P(this.g),z.b=P(this.b)):(z.r=w(this.r),z.g=w(this.g),z.b=w(this.b)),this}toGammaSpace(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new d;return this.toGammaSpaceToRef(u,z),u}toGammaSpaceToRef(z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(z.r=S(this.r),z.g=S(this.g),z.b=S(this.b)):(z.r=R(this.r),z.g=R(this.g),z.b=R(this.b)),this}static HSVtoRGBToRef(z,u,U,J){const v=U*u,f=z/60,g=v*(1-Math.abs(f%2-1));let w=0,P=0,R=0;f>=0&&f<=1?(w=v,P=g):f>=1&&f<=2?(w=g,P=v):f>=2&&f<=3?(P=v,R=g):f>=3&&f<=4?(P=g,R=v):f>=4&&f<=5?(w=g,R=v):f>=5&&f<=6&&(w=v,R=g);const S=U-v;return J.r=w+S,J.g=P+S,J.b=R+S,J}static FromHSV(z,u,U){const J=new d(0,0,0);return d.HSVtoRGBToRef(z,u,U,J),J}static FromHexString(z){return new d(0,0,0).fromHexString(z)}static Xu(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(z[u],z[u+1],z[u+2])}static FromArrayToRef(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2?arguments[2]:void 0;U.r=z[u],U.g=z[u+1],U.b=z[u+2]}static FromInts(z,u,U){return new d(z/255,u/255,U/255)}static Lerp(z,u,U){const J=new d(0,0,0);return d.LerpToRef(z,u,U,J),J}static LerpToRef(z,u,U,J){J.r=z.r+(u.r-z.r)*U,J.g=z.g+(u.g-z.g)*U,J.b=z.b+(u.b-z.b)*U}static Hermite(z,u,U,J,v){const f=v*v,g=v*f,w=2*g-3*f+1,P=-2*g+3*f,R=g-2*f+v,S=g-f,mz=z.r*w+U.r*P+u.r*R+J.r*S,Z=z.g*w+U.g*P+u.g*R+J.g*S,A=z.b*w+U.b*P+u.b*R+J.b*S;return new d(mz,Z,A)}static Hermite1stDerivative(z,u,U,J,v){const f=d.Black();return this.Hermite1stDerivativeToRef(z,u,U,J,v,f),f}static Hermite1stDerivativeToRef(z,u,U,J,v,f){const g=v*v;f.r=6*(g-v)*z.r+(3*g-4*v+1)*u.r+6*(-g+v)*U.r+(3*g-2*v)*J.r,f.g=6*(g-v)*z.g+(3*g-4*v+1)*u.g+6*(-g+v)*U.g+(3*g-2*v)*J.g,f.b=6*(g-v)*z.b+(3*g-4*v+1)*u.b+6*(-g+v)*U.b+(3*g-2*v)*J.b}static Red(){return new d(1,0,0)}static Green(){return new d(0,1,0)}static Blue(){return new d(0,0,1)}static Black(){return new d(0,0,0)}static get BlackReadOnly(){return d._BlackReadOnly}static White(){return new d(1,1,1)}static Purple(){return new d(.5,0,.5)}static Magenta(){return new d(1,0,1)}static Yellow(){return new d(1,1,0)}static Gray(){return new d(.5,.5,.5)}static Teal(){return new d(0,1,1)}static Random(){return new d(Math.random(),Math.random(),Math.random())}}d._V8PerformanceHack=new d(.5,.5,.5),d._BlackReadOnly=d.Black(),Object.defineProperties(d.prototype,{dimension:{value:[3]},rank:{value:1}});class mz{constructor(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=z,this.g=u,this.b=U,this.a=J}jf(){return[this.r,this.g,this.b,this.a]}toArray(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z[u]=this.r,z[u+1]=this.g,z[u+2]=this.b,z[u+3]=this.a,this}CU(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=z[u],this.g=z[u+1],this.b=z[u+2],this.a=z[u+3],this}equals(z){return z&&this.r===z.r&&this.g===z.g&&this.b===z.b&&this.a===z.a}add(z){return new mz(this.r+z.r,this.g+z.g,this.b+z.b,this.a+z.a)}addToRef(z,u){return u.r=this.r+z.r,u.g=this.g+z.g,u.b=this.b+z.b,u.a=this.a+z.a,u}addInPlace(z){return this.r+=z.r,this.g+=z.g,this.b+=z.b,this.a+=z.a,this}addInPlaceFromFloats(z,u,U,J){return this.r+=z,this.g+=u,this.b+=U,this.a+=J,this}Cu(z){return new mz(this.r-z.r,this.g-z.g,this.b-z.b,this.a-z.a)}subtractToRef(z,u){return u.r=this.r-z.r,u.g=this.g-z.g,u.b=this.b-z.b,u.a=this.a-z.a,u}dm(z){return this.r-=z.r,this.g-=z.g,this.b-=z.b,this.a-=z.a,this}subtractFromFloats(z,u,U,J){return new mz(this.r-z,this.g-u,this.b-U,this.a-J)}subtractFromFloatsToRef(z,u,U,J,v){return v.r=this.r-z,v.g=this.g-u,v.b=this.b-U,v.a=this.a-J,v}scale(z){return new mz(this.r*z,this.g*z,this.b*z,this.a*z)}scaleInPlace(z){return this.r*=z,this.g*=z,this.b*=z,this.a*=z,this}scaleToRef(z,u){return u.r=this.r*z,u.g=this.g*z,u.b=this.b*z,u.a=this.a*z,u}scaleAndAddToRef(z,u){return u.r+=this.r*z,u.g+=this.g*z,u.b+=this.b*z,u.a+=this.a*z,u}clampToRef(){let z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,U=arguments.length>2?arguments[2]:void 0;return U.r=(0,g.Clamp)(this.r,z,u),U.g=(0,g.Clamp)(this.g,z,u),U.b=(0,g.Clamp)(this.b,z,u),U.a=(0,g.Clamp)(this.a,z,u),U}multiply(z){return new mz(this.r*z.r,this.g*z.g,this.b*z.b,this.a*z.a)}multiplyToRef(z,u){return u.r=this.r*z.r,u.g=this.g*z.g,u.b=this.b*z.b,u.a=this.a*z.a,u}multiplyInPlace(z){return this.r*=z.r,this.g*=z.g,this.b*=z.b,this.a*=z.a,this}multiplyByFloats(z,u,U,J){return new mz(this.r*z,this.g*u,this.b*U,this.a*J)}divide(z){throw new ReferenceError("Can not divide a color")}divideToRef(z,u){throw new ReferenceError("Can not divide a color")}divideInPlace(z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(z){return this.r=Math.min(this.r,z.r),this.g=Math.min(this.g,z.g),this.b=Math.min(this.b,z.b),this.a=Math.min(this.a,z.a),this}maximizeInPlace(z){return this.r=Math.max(this.r,z.r),this.g=Math.max(this.g,z.g),this.b=Math.max(this.b,z.b),this.a=Math.max(this.a,z.a),this}minimizeInPlaceFromFloats(z,u,U,J){return this.r=Math.min(z,this.r),this.g=Math.min(u,this.g),this.b=Math.min(U,this.b),this.a=Math.min(J,this.a),this}maximizeInPlaceFromFloats(z,u,U,J){return this.r=Math.max(z,this.r),this.g=Math.max(u,this.g),this.b=Math.max(U,this.b),this.a=Math.max(J,this.a),this}floorToRef(z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(z){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.d;return(0,g.WithinEpsilon)(this.r,z.r,u)&&(0,g.WithinEpsilon)(this.g,z.g,u)&&(0,g.WithinEpsilon)(this.b,z.b,u)&&(0,g.WithinEpsilon)(this.a,z.a,u)}equalsToFloats(z,u,U,J){return this.r===z&&this.g===u&&this.b===U&&this.a===J}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"wg"}getHashCode(){let z=255*this.r|0;return z=397*z^255*this.g,z=397*z^255*this.b,z=397*z^255*this.a,z}clone(){return(new mz).v(this)}v(z){return this.r=z.r,this.g=z.g,this.b=z.b,this.a=z.a,this}zg(z,u,U,J){return this.r=z,this.g=u,this.b=U,this.a=J,this}set(z,u,U,J){return this.zg(z,u,U,J)}fg(z){return this.r=this.g=this.b=this.a=z,this}toHexString(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=Math.round(255*this.r),U=Math.round(255*this.g),J=Math.round(255*this.b);if(z)return"#"+(0,g.ToHex)(u)+(0,g.ToHex)(U)+(0,g.ToHex)(J);const v=Math.round(255*this.a);return"#"+(0,g.ToHex)(u)+(0,g.ToHex)(U)+(0,g.ToHex)(J)+(0,g.ToHex)(v)}fromHexString(z){return"#"!==z.substring(0,1)||9!==z.length&&7!==z.length||(this.r=parseInt(z.substring(1,3),16)/255,this.g=parseInt(z.substring(3,5),16)/255,this.b=parseInt(z.substring(5,7),16)/255,9===z.length&&(this.a=parseInt(z.substring(7,9),16)/255)),this}toLinearSpace(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new mz;return this.toLinearSpaceToRef(u,z),u}toLinearSpaceToRef(z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(z.r=P(this.r),z.g=P(this.g),z.b=P(this.b)):(z.r=w(this.r),z.g=w(this.g),z.b=w(this.b)),z.a=this.a,this}toGammaSpace(){let z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new mz;return this.toGammaSpaceToRef(u,z),u}toGammaSpaceToRef(z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(z.r=S(this.r),z.g=S(this.g),z.b=S(this.b)):(z.r=R(this.r),z.g=R(this.g),z.b=R(this.b)),z.a=this.a,this}static FromHexString(z){return"#"!==z.substring(0,1)||9!==z.length&&7!==z.length?new mz(0,0,0,0):new mz(0,0,0,1).fromHexString(z)}static Lerp(z,u,U){return mz.LerpToRef(z,u,U,new mz)}static LerpToRef(z,u,U,J){return J.r=z.r+(u.r-z.r)*U,J.g=z.g+(u.g-z.g)*U,J.b=z.b+(u.b-z.b)*U,J.a=z.a+(u.a-z.a)*U,J}static Hermite(z,u,U,J,v){const f=v*v,g=v*f,w=2*g-3*f+1,P=-2*g+3*f,R=g-2*f+v,S=g-f,d=z.r*w+U.r*P+u.r*R+J.r*S,Z=z.g*w+U.g*P+u.g*R+J.g*S,A=z.b*w+U.b*P+u.b*R+J.b*S,E=z.a*w+U.a*P+u.a*R+J.a*S;return new mz(d,Z,A,E)}static Hermite1stDerivative(z,u,U,J,v){const f=new mz;return this.Hermite1stDerivativeToRef(z,u,U,J,v,f),f}static Hermite1stDerivativeToRef(z,u,U,J,v,f){const g=v*v;f.r=6*(g-v)*z.r+(3*g-4*v+1)*u.r+6*(-g+v)*U.r+(3*g-2*v)*J.r,f.g=6*(g-v)*z.g+(3*g-4*v+1)*u.g+6*(-g+v)*U.g+(3*g-2*v)*J.g,f.b=6*(g-v)*z.b+(3*g-4*v+1)*u.b+6*(-g+v)*U.b+(3*g-2*v)*J.b,f.a=6*(g-v)*z.a+(3*g-4*v+1)*u.a+6*(-g+v)*U.a+(3*g-2*v)*J.a}static FromColor3(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new mz(z.r,z.g,z.b,u)}static Xu(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new mz(z[u],z[u+1],z[u+2],z[u+3])}static FromArrayToRef(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2?arguments[2]:void 0;U.r=z[u],U.g=z[u+1],U.b=z[u+2],U.a=z[u+3]}static FromInts(z,u,U,J){return new mz(z/255,u/255,U/255,J/255)}static CheckColors4(z,u){if(z.length===3*u){const u=[];for(let U=0;U<z.length;U+=3){const J=U/3*4;u[J]=z[U],u[J+1]=z[U+1],u[J+2]=z[U+2],u[J+3]=1}return u}return z}}mz._V8PerformanceHack=new mz(.5,.5,.5,.5),Object.defineProperties(mz.prototype,{dimension:{value:[4]},rank:{value:1}});class Z{}Z.Tu=(0,J.e)(3,d.Black),Z.wg=(0,J.e)(3,(()=>new mz(0,0,0,0))),(0,v.f)("BABYLON.Color3",d),(0,v.f)("BABYLON.Color4",mz)}}]);