"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[17],{11764:(K,O,F)=>{F.r(O),F.d(O,{ZO:()=>t,kJ:()=>j,TmpColors:()=>X});var f=F(11729),r=F(11661),l=F(11721),q=F(11734);function J(K){return Math.pow(K,l.o)}function c(K){return K<=.04045?.0773993808*K:Math.pow(.947867299*(K+.055),2.4)}function E(K){return Math.pow(K,l.k)}function M(K){return K<=.0031308?12.92*K:1.055*Math.pow(K,.41666)-.055}class t{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=K,this.g=O,this.b=F}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ZO"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K}toArray(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[O]=this.r,K[O+1]=this.g,K[O+2]=this.b,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(K,O,this),this}toColor4(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new j(this.r,this.g,this.b,K)}hf(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(K){return new t(this.r*K.r,this.g*K.g,this.b*K.b)}multiplyToRef(K,O){return O.r=this.r*K.r,O.g=this.g*K.g,O.b=this.b*K.b,O}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this}multiplyByFloats(K,O,F){return new t(this.r*K,this.g*O,this.b*F)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,O){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.r,K.g,K.b)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.r,K.g,K.b)}minimizeInPlaceFromFloats(K,O,F){return this.r=Math.min(K,this.r),this.g=Math.min(O,this.g),this.b=Math.min(F,this.b),this}maximizeInPlaceFromFloats(K,O,F){return this.r=Math.max(K,this.r),this.g=Math.max(O,this.g),this.b=Math.max(F,this.b),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b}equalsFloats(K,O,F){return this.equalsToFloats(K,O,F)}equalsToFloats(K,O,F){return this.r===K&&this.g===O&&this.b===F}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.e;return(0,q.WithinEpsilon)(this.r,K.r,O)&&(0,q.WithinEpsilon)(this.g,K.g,O)&&(0,q.WithinEpsilon)(this.b,K.b,O)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}scale(K){return new t(this.r*K,this.g*K,this.b*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this}scaleToRef(K,O){return O.r=this.r*K,O.g=this.g*K,O.b=this.b*K,O}scaleAndAddToRef(K,O){return O.r+=this.r*K,O.g+=this.g*K,O.b+=this.b*K,O}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,q.Clamp)(this.r,K,O),F.g=(0,q.Clamp)(this.g,K,O),F.b=(0,q.Clamp)(this.b,K,O),F}add(K){return new t(this.r+K.r,this.g+K.g,this.b+K.b)}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this}addInPlaceFromFloats(K,O,F){return this.r+=K,this.g+=O,this.b+=F,this}addToRef(K,O){return O.r=this.r+K.r,O.g=this.g+K.g,O.b=this.b+K.b,O}oO(K){return new t(this.r-K.r,this.g-K.g,this.b-K.b)}subtractToRef(K,O){return O.r=this.r-K.r,O.g=this.g-K.g,O.b=this.b-K.b,O}Qt(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this}subtractFromFloats(K,O,F){return new t(this.r-K,this.g-O,this.b-F)}subtractFromFloatsToRef(K,O,F,f){return f.r=this.r-K,f.g=this.g-O,f.b=this.b-F,f}clone(){return new t(this.r,this.g,this.b)}l(K){return this.r=K.r,this.g=K.g,this.b=K.b,this}eq(K,O,F){return this.r=K,this.g=O,this.b=F,this}set(K,O,F){return this.eq(K,O,F)}oJ(K){return this.r=this.g=this.b=K,this}toHexString(){const K=Math.round(255*this.r),O=Math.round(255*this.g),F=Math.round(255*this.b);return"#"+(0,q.ToHex)(K)+(0,q.ToHex)(O)+(0,q.ToHex)(F)}fromHexString(K){return"#"!==K.substring(0,1)||7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new t)}toHSVToRef(K){const O=this.r,F=this.g,f=this.b,r=Math.max(O,F,f),l=Math.min(O,F,f);let q=0,J=0;const c=r,E=r-l;return 0!==r&&(J=E/r),r!=l&&(r==O?(q=(F-f)/E,F<f&&(q+=6)):r==F?q=(f-O)/E+2:r==f&&(q=(O-F)/E+4),q*=60),K.r=q,K.g=J,K.b=c,K}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new t;return this.toLinearSpaceToRef(O,K),O}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=c(this.r),K.g=c(this.g),K.b=c(this.b)):(K.r=J(this.r),K.g=J(this.g),K.b=J(this.b)),this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new t;return this.toGammaSpaceToRef(O,K),O}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=M(this.r),K.g=M(this.g),K.b=M(this.b)):(K.r=E(this.r),K.g=E(this.g),K.b=E(this.b)),this}static HSVtoRGBToRef(K,O,F,f){const r=F*O,l=K/60,q=r*(1-Math.abs(l%2-1));let J=0,c=0,E=0;l>=0&&l<=1?(J=r,c=q):l>=1&&l<=2?(J=q,c=r):l>=2&&l<=3?(c=r,E=q):l>=3&&l<=4?(c=q,E=r):l>=4&&l<=5?(J=q,E=r):l>=5&&l<=6&&(J=r,E=q);const M=F-r;return f.r=J+M,f.g=c+M,f.b=E+M,f}static FromHSV(K,O,F){const f=new t(0,0,0);return t.HSVtoRGBToRef(K,O,F,f),f}static FromHexString(K){return new t(0,0,0).fromHexString(K)}static LO(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(K[O],K[O+1],K[O+2])}static FromArrayToRef(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=K[O],F.g=K[O+1],F.b=K[O+2]}static FromInts(K,O,F){return new t(K/255,O/255,F/255)}static Lerp(K,O,F){const f=new t(0,0,0);return t.LerpToRef(K,O,F,f),f}static LerpToRef(K,O,F,f){f.r=K.r+(O.r-K.r)*F,f.g=K.g+(O.g-K.g)*F,f.b=K.b+(O.b-K.b)*F}static Hermite(K,O,F,f,r){const l=r*r,q=r*l,J=2*q-3*l+1,c=-2*q+3*l,E=q-2*l+r,M=q-l,j=K.r*J+F.r*c+O.r*E+f.r*M,X=K.g*J+F.g*c+O.g*E+f.g*M,u=K.b*J+F.b*c+O.b*E+f.b*M;return new t(j,X,u)}static Hermite1stDerivative(K,O,F,f,r){const l=t.Black();return this.Hermite1stDerivativeToRef(K,O,F,f,r,l),l}static Hermite1stDerivativeToRef(K,O,F,f,r,l){const q=r*r;l.r=6*(q-r)*K.r+(3*q-4*r+1)*O.r+6*(-q+r)*F.r+(3*q-2*r)*f.r,l.g=6*(q-r)*K.g+(3*q-4*r+1)*O.g+6*(-q+r)*F.g+(3*q-2*r)*f.g,l.b=6*(q-r)*K.b+(3*q-4*r+1)*O.b+6*(-q+r)*F.b+(3*q-2*r)*f.b}static Red(){return new t(1,0,0)}static Green(){return new t(0,1,0)}static Blue(){return new t(0,0,1)}static Black(){return new t(0,0,0)}static get BlackReadOnly(){return t._BlackReadOnly}static White(){return new t(1,1,1)}static Purple(){return new t(.5,0,.5)}static Magenta(){return new t(1,0,1)}static Yellow(){return new t(1,1,0)}static Gray(){return new t(.5,.5,.5)}static Teal(){return new t(0,1,1)}static Random(){return new t(Math.random(),Math.random(),Math.random())}}t._V8PerformanceHack=new t(.5,.5,.5),t._BlackReadOnly=t.Black(),Object.defineProperties(t.prototype,{dimension:{value:[3]},rank:{value:1}});class j{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=K,this.g=O,this.b=F,this.a=f}hf(){return[this.r,this.g,this.b,this.a]}toArray(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[O]=this.r,K[O+1]=this.g,K[O+2]=this.b,K[O+3]=this.a,this}uF(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=K[O],this.g=K[O+1],this.b=K[O+2],this.a=K[O+3],this}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b&&this.a===K.a}add(K){return new j(this.r+K.r,this.g+K.g,this.b+K.b,this.a+K.a)}addToRef(K,O){return O.r=this.r+K.r,O.g=this.g+K.g,O.b=this.b+K.b,O.a=this.a+K.a,O}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this.a+=K.a,this}addInPlaceFromFloats(K,O,F,f){return this.r+=K,this.g+=O,this.b+=F,this.a+=f,this}oO(K){return new j(this.r-K.r,this.g-K.g,this.b-K.b,this.a-K.a)}subtractToRef(K,O){return O.r=this.r-K.r,O.g=this.g-K.g,O.b=this.b-K.b,O.a=this.a-K.a,O}Qt(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this.a-=K.a,this}subtractFromFloats(K,O,F,f){return new j(this.r-K,this.g-O,this.b-F,this.a-f)}subtractFromFloatsToRef(K,O,F,f,r){return r.r=this.r-K,r.g=this.g-O,r.b=this.b-F,r.a=this.a-f,r}scale(K){return new j(this.r*K,this.g*K,this.b*K,this.a*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this.a*=K,this}scaleToRef(K,O){return O.r=this.r*K,O.g=this.g*K,O.b=this.b*K,O.a=this.a*K,O}scaleAndAddToRef(K,O){return O.r+=this.r*K,O.g+=this.g*K,O.b+=this.b*K,O.a+=this.a*K,O}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,q.Clamp)(this.r,K,O),F.g=(0,q.Clamp)(this.g,K,O),F.b=(0,q.Clamp)(this.b,K,O),F.a=(0,q.Clamp)(this.a,K,O),F}multiply(K){return new j(this.r*K.r,this.g*K.g,this.b*K.b,this.a*K.a)}multiplyToRef(K,O){return O.r=this.r*K.r,O.g=this.g*K.g,O.b=this.b*K.b,O.a=this.a*K.a,O}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this.a*=K.a,this}multiplyByFloats(K,O,F,f){return new j(this.r*K,this.g*O,this.b*F,this.a*f)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,O){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.r=Math.min(this.r,K.r),this.g=Math.min(this.g,K.g),this.b=Math.min(this.b,K.b),this.a=Math.min(this.a,K.a),this}maximizeInPlace(K){return this.r=Math.max(this.r,K.r),this.g=Math.max(this.g,K.g),this.b=Math.max(this.b,K.b),this.a=Math.max(this.a,K.a),this}minimizeInPlaceFromFloats(K,O,F,f){return this.r=Math.min(K,this.r),this.g=Math.min(O,this.g),this.b=Math.min(F,this.b),this.a=Math.min(f,this.a),this}maximizeInPlaceFromFloats(K,O,F,f){return this.r=Math.max(K,this.r),this.g=Math.max(O,this.g),this.b=Math.max(F,this.b),this.a=Math.max(f,this.a),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.e;return(0,q.WithinEpsilon)(this.r,K.r,O)&&(0,q.WithinEpsilon)(this.g,K.g,O)&&(0,q.WithinEpsilon)(this.b,K.b,O)&&(0,q.WithinEpsilon)(this.a,K.a,O)}equalsToFloats(K,O,F,f){return this.r===K&&this.g===O&&this.b===F&&this.a===f}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"kJ"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K=397*K^255*this.a,K}clone(){return(new j).l(this)}l(K){return this.r=K.r,this.g=K.g,this.b=K.b,this.a=K.a,this}eq(K,O,F,f){return this.r=K,this.g=O,this.b=F,this.a=f,this}set(K,O,F,f){return this.eq(K,O,F,f)}oJ(K){return this.r=this.g=this.b=this.a=K,this}toHexString(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=Math.round(255*this.r),F=Math.round(255*this.g),f=Math.round(255*this.b);if(K)return"#"+(0,q.ToHex)(O)+(0,q.ToHex)(F)+(0,q.ToHex)(f);const r=Math.round(255*this.a);return"#"+(0,q.ToHex)(O)+(0,q.ToHex)(F)+(0,q.ToHex)(f)+(0,q.ToHex)(r)}fromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255,9===K.length&&(this.a=parseInt(K.substring(7,9),16)/255)),this}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new j;return this.toLinearSpaceToRef(O,K),O}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=c(this.r),K.g=c(this.g),K.b=c(this.b)):(K.r=J(this.r),K.g=J(this.g),K.b=J(this.b)),K.a=this.a,this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new j;return this.toGammaSpaceToRef(O,K),O}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=M(this.r),K.g=M(this.g),K.b=M(this.b)):(K.r=E(this.r),K.g=E(this.g),K.b=E(this.b)),K.a=this.a,this}static FromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length?new j(0,0,0,0):new j(0,0,0,1).fromHexString(K)}static Lerp(K,O,F){return j.LerpToRef(K,O,F,new j)}static LerpToRef(K,O,F,f){return f.r=K.r+(O.r-K.r)*F,f.g=K.g+(O.g-K.g)*F,f.b=K.b+(O.b-K.b)*F,f.a=K.a+(O.a-K.a)*F,f}static Hermite(K,O,F,f,r){const l=r*r,q=r*l,J=2*q-3*l+1,c=-2*q+3*l,E=q-2*l+r,M=q-l,t=K.r*J+F.r*c+O.r*E+f.r*M,X=K.g*J+F.g*c+O.g*E+f.g*M,u=K.b*J+F.b*c+O.b*E+f.b*M,T=K.a*J+F.a*c+O.a*E+f.a*M;return new j(t,X,u,T)}static Hermite1stDerivative(K,O,F,f,r){const l=new j;return this.Hermite1stDerivativeToRef(K,O,F,f,r,l),l}static Hermite1stDerivativeToRef(K,O,F,f,r,l){const q=r*r;l.r=6*(q-r)*K.r+(3*q-4*r+1)*O.r+6*(-q+r)*F.r+(3*q-2*r)*f.r,l.g=6*(q-r)*K.g+(3*q-4*r+1)*O.g+6*(-q+r)*F.g+(3*q-2*r)*f.g,l.b=6*(q-r)*K.b+(3*q-4*r+1)*O.b+6*(-q+r)*F.b+(3*q-2*r)*f.b,l.a=6*(q-r)*K.a+(3*q-4*r+1)*O.a+6*(-q+r)*F.a+(3*q-2*r)*f.a}static FromColor3(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j(K.r,K.g,K.b,O)}static LO(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(K[O],K[O+1],K[O+2],K[O+3])}static FromArrayToRef(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=K[O],F.g=K[O+1],F.b=K[O+2],F.a=K[O+3]}static FromInts(K,O,F,f){return new j(K/255,O/255,F/255,f/255)}static CheckColors4(K,O){if(K.length===3*O){const O=[];for(let F=0;F<K.length;F+=3){const f=F/3*4;O[f]=K[F],O[f+1]=K[F+1],O[f+2]=K[F+2],O[f+3]=1}return O}return K}}j._V8PerformanceHack=new j(.5,.5,.5,.5),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class X{}X.ZO=(0,f.c)(3,t.Black),X.kJ=(0,f.c)(3,(()=>new j(0,0,0,0))),(0,r.g)("BABYLON.Color3",t),(0,r.g)("BABYLON.Color4",j)}}]);