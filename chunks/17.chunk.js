"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[17],{12789:(q,I,l)=>{l.r(I),l.d(I,{BI:()=>r,Dc:()=>x,TmpColors:()=>o});var w=l(12757),t=l(12711),O=l(12752),c=l(12761);function a(q){return Math.pow(q,O.m)}function F(q){return q<=.04045?.0773993808*q:Math.pow(.947867299*(q+.055),2.4)}function s(q){return Math.pow(q,O.i)}function Z(q){return q<=.0031308?12.92*q:1.055*Math.pow(q,.41666)-.055}class r{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=q,this.g=I,this.b=l}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"BI"}getHashCode(){let q=255*this.r|0;return q=397*q^255*this.g,q=397*q^255*this.b,q}toArray(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[I]=this.r,q[I+1]=this.g,q[I+2]=this.b,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return r.FromArrayToRef(q,I,this),this}toColor4(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new x(this.r,this.g,this.b,q)}Uc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(q){return new r(this.r*q.r,this.g*q.g,this.b*q.b)}multiplyToRef(q,I){return I.r=this.r*q.r,I.g=this.g*q.g,I.b=this.b*q.b,I}multiplyInPlace(q){return this.r*=q.r,this.g*=q.g,this.b*=q.b,this}multiplyByFloats(q,I,l){return new r(this.r*q,this.g*I,this.b*l)}divide(q){throw new ReferenceError("Can not divide a color")}divideToRef(q,I){throw new ReferenceError("Can not divide a color")}divideInPlace(q){throw new ReferenceError("Can not divide a color")}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q.r,q.g,q.b)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q.r,q.g,q.b)}minimizeInPlaceFromFloats(q,I,l){return this.r=Math.min(q,this.r),this.g=Math.min(I,this.g),this.b=Math.min(l,this.b),this}maximizeInPlaceFromFloats(q,I,l){return this.r=Math.max(q,this.r),this.g=Math.max(I,this.g),this.b=Math.max(l,this.b),this}floorToRef(q){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(q){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(q){return q&&this.r===q.r&&this.g===q.g&&this.b===q.b}equalsFloats(q,I,l){return this.equalsToFloats(q,I,l)}equalsToFloats(q,I,l){return this.r===q&&this.g===I&&this.b===l}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return(0,c.WithinEpsilon)(this.r,q.r,I)&&(0,c.WithinEpsilon)(this.g,q.g,I)&&(0,c.WithinEpsilon)(this.b,q.b,I)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(q){throw new ReferenceError("Can not negate a color")}scale(q){return new r(this.r*q,this.g*q,this.b*q)}scaleInPlace(q){return this.r*=q,this.g*=q,this.b*=q,this}scaleToRef(q,I){return I.r=this.r*q,I.g=this.g*q,I.b=this.b*q,I}scaleAndAddToRef(q,I){return I.r+=this.r*q,I.g+=this.g*q,I.b+=this.b*q,I}clampToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0;return l.r=(0,c.Clamp)(this.r,q,I),l.g=(0,c.Clamp)(this.g,q,I),l.b=(0,c.Clamp)(this.b,q,I),l}add(q){return new r(this.r+q.r,this.g+q.g,this.b+q.b)}addInPlace(q){return this.r+=q.r,this.g+=q.g,this.b+=q.b,this}addInPlaceFromFloats(q,I,l){return this.r+=q,this.g+=I,this.b+=l,this}addToRef(q,I){return I.r=this.r+q.r,I.g=this.g+q.g,I.b=this.b+q.b,I}TI(q){return new r(this.r-q.r,this.g-q.g,this.b-q.b)}subtractToRef(q,I){return I.r=this.r-q.r,I.g=this.g-q.g,I.b=this.b-q.b,I}Sr(q){return this.r-=q.r,this.g-=q.g,this.b-=q.b,this}subtractFromFloats(q,I,l){return new r(this.r-q,this.g-I,this.b-l)}subtractFromFloatsToRef(q,I,l,w){return w.r=this.r-q,w.g=this.g-I,w.b=this.b-l,w}clone(){return new r(this.r,this.g,this.b)}t(q){return this.r=q.r,this.g=q.g,this.b=q.b,this}gc(q,I,l){return this.r=q,this.g=I,this.b=l,this}set(q,I,l){return this.gc(q,I,l)}Kc(q){return this.r=this.g=this.b=q,this}toHexString(){const q=Math.round(255*this.r),I=Math.round(255*this.g),l=Math.round(255*this.b);return"#"+(0,c.ToHex)(q)+(0,c.ToHex)(I)+(0,c.ToHex)(l)}fromHexString(q){return"#"!==q.substring(0,1)||7!==q.length||(this.r=parseInt(q.substring(1,3),16)/255,this.g=parseInt(q.substring(3,5),16)/255,this.b=parseInt(q.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new r)}toHSVToRef(q){const I=this.r,l=this.g,w=this.b,t=Math.max(I,l,w),O=Math.min(I,l,w);let c=0,a=0;const F=t,s=t-O;return 0!==t&&(a=s/t),t!=O&&(t==I?(c=(l-w)/s,l<w&&(c+=6)):t==l?c=(w-I)/s+2:t==w&&(c=(I-l)/s+4),c*=60),q.r=c,q.g=a,q.b=F,q}toLinearSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new r;return this.toLinearSpaceToRef(I,q),I}toLinearSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=F(this.r),q.g=F(this.g),q.b=F(this.b)):(q.r=a(this.r),q.g=a(this.g),q.b=a(this.b)),this}toGammaSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new r;return this.toGammaSpaceToRef(I,q),I}toGammaSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=Z(this.r),q.g=Z(this.g),q.b=Z(this.b)):(q.r=s(this.r),q.g=s(this.g),q.b=s(this.b)),this}static HSVtoRGBToRef(q,I,l,w){const t=l*I,O=q/60,c=t*(1-Math.abs(O%2-1));let a=0,F=0,s=0;O>=0&&O<=1?(a=t,F=c):O>=1&&O<=2?(a=c,F=t):O>=2&&O<=3?(F=t,s=c):O>=3&&O<=4?(F=c,s=t):O>=4&&O<=5?(a=c,s=t):O>=5&&O<=6&&(a=t,s=c);const Z=l-t;return w.r=a+Z,w.g=F+Z,w.b=s+Z,w}static FromHSV(q,I,l){const w=new r(0,0,0);return r.HSVtoRGBToRef(q,I,l,w),w}static FromHexString(q){return new r(0,0,0).fromHexString(q)}static vI(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(q[I],q[I+1],q[I+2])}static FromArrayToRef(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2?arguments[2]:void 0;l.r=q[I],l.g=q[I+1],l.b=q[I+2]}static FromInts(q,I,l){return new r(q/255,I/255,l/255)}static Lerp(q,I,l){const w=new r(0,0,0);return r.LerpToRef(q,I,l,w),w}static LerpToRef(q,I,l,w){w.r=q.r+(I.r-q.r)*l,w.g=q.g+(I.g-q.g)*l,w.b=q.b+(I.b-q.b)*l}static Hermite(q,I,l,w,t){const O=t*t,c=t*O,a=2*c-3*O+1,F=-2*c+3*O,s=c-2*O+t,Z=c-O,x=q.r*a+l.r*F+I.r*s+w.r*Z,o=q.g*a+l.g*F+I.g*s+w.g*Z,d=q.b*a+l.b*F+I.b*s+w.b*Z;return new r(x,o,d)}static Hermite1stDerivative(q,I,l,w,t){const O=r.Black();return this.Hermite1stDerivativeToRef(q,I,l,w,t,O),O}static Hermite1stDerivativeToRef(q,I,l,w,t,O){const c=t*t;O.r=6*(c-t)*q.r+(3*c-4*t+1)*I.r+6*(-c+t)*l.r+(3*c-2*t)*w.r,O.g=6*(c-t)*q.g+(3*c-4*t+1)*I.g+6*(-c+t)*l.g+(3*c-2*t)*w.g,O.b=6*(c-t)*q.b+(3*c-4*t+1)*I.b+6*(-c+t)*l.b+(3*c-2*t)*w.b}static Red(){return new r(1,0,0)}static Green(){return new r(0,1,0)}static Blue(){return new r(0,0,1)}static Black(){return new r(0,0,0)}static get BlackReadOnly(){return r._BlackReadOnly}static White(){return new r(1,1,1)}static Purple(){return new r(.5,0,.5)}static Magenta(){return new r(1,0,1)}static Yellow(){return new r(1,1,0)}static Gray(){return new r(.5,.5,.5)}static Teal(){return new r(0,1,1)}static Random(){return new r(Math.random(),Math.random(),Math.random())}}r._V8PerformanceHack=new r(.5,.5,.5),r._BlackReadOnly=r.Black(),Object.defineProperties(r.prototype,{dimension:{value:[3]},rank:{value:1}});class x{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=q,this.g=I,this.b=l,this.a=w}Uc(){return[this.r,this.g,this.b,this.a]}toArray(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[I]=this.r,q[I+1]=this.g,q[I+2]=this.b,q[I+3]=this.a,this}dl(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=q[I],this.g=q[I+1],this.b=q[I+2],this.a=q[I+3],this}equals(q){return q&&this.r===q.r&&this.g===q.g&&this.b===q.b&&this.a===q.a}add(q){return new x(this.r+q.r,this.g+q.g,this.b+q.b,this.a+q.a)}addToRef(q,I){return I.r=this.r+q.r,I.g=this.g+q.g,I.b=this.b+q.b,I.a=this.a+q.a,I}addInPlace(q){return this.r+=q.r,this.g+=q.g,this.b+=q.b,this.a+=q.a,this}addInPlaceFromFloats(q,I,l,w){return this.r+=q,this.g+=I,this.b+=l,this.a+=w,this}TI(q){return new x(this.r-q.r,this.g-q.g,this.b-q.b,this.a-q.a)}subtractToRef(q,I){return I.r=this.r-q.r,I.g=this.g-q.g,I.b=this.b-q.b,I.a=this.a-q.a,I}Sr(q){return this.r-=q.r,this.g-=q.g,this.b-=q.b,this.a-=q.a,this}subtractFromFloats(q,I,l,w){return new x(this.r-q,this.g-I,this.b-l,this.a-w)}subtractFromFloatsToRef(q,I,l,w,t){return t.r=this.r-q,t.g=this.g-I,t.b=this.b-l,t.a=this.a-w,t}scale(q){return new x(this.r*q,this.g*q,this.b*q,this.a*q)}scaleInPlace(q){return this.r*=q,this.g*=q,this.b*=q,this.a*=q,this}scaleToRef(q,I){return I.r=this.r*q,I.g=this.g*q,I.b=this.b*q,I.a=this.a*q,I}scaleAndAddToRef(q,I){return I.r+=this.r*q,I.g+=this.g*q,I.b+=this.b*q,I.a+=this.a*q,I}clampToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,l=arguments.length>2?arguments[2]:void 0;return l.r=(0,c.Clamp)(this.r,q,I),l.g=(0,c.Clamp)(this.g,q,I),l.b=(0,c.Clamp)(this.b,q,I),l.a=(0,c.Clamp)(this.a,q,I),l}multiply(q){return new x(this.r*q.r,this.g*q.g,this.b*q.b,this.a*q.a)}multiplyToRef(q,I){return I.r=this.r*q.r,I.g=this.g*q.g,I.b=this.b*q.b,I.a=this.a*q.a,I}multiplyInPlace(q){return this.r*=q.r,this.g*=q.g,this.b*=q.b,this.a*=q.a,this}multiplyByFloats(q,I,l,w){return new x(this.r*q,this.g*I,this.b*l,this.a*w)}divide(q){throw new ReferenceError("Can not divide a color")}divideToRef(q,I){throw new ReferenceError("Can not divide a color")}divideInPlace(q){throw new ReferenceError("Can not divide a color")}minimizeInPlace(q){return this.r=Math.min(this.r,q.r),this.g=Math.min(this.g,q.g),this.b=Math.min(this.b,q.b),this.a=Math.min(this.a,q.a),this}maximizeInPlace(q){return this.r=Math.max(this.r,q.r),this.g=Math.max(this.g,q.g),this.b=Math.max(this.b,q.b),this.a=Math.max(this.a,q.a),this}minimizeInPlaceFromFloats(q,I,l,w){return this.r=Math.min(q,this.r),this.g=Math.min(I,this.g),this.b=Math.min(l,this.b),this.a=Math.min(w,this.a),this}maximizeInPlaceFromFloats(q,I,l,w){return this.r=Math.max(q,this.r),this.g=Math.max(I,this.g),this.b=Math.max(l,this.b),this.a=Math.max(w,this.a),this}floorToRef(q){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(q){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(q){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return(0,c.WithinEpsilon)(this.r,q.r,I)&&(0,c.WithinEpsilon)(this.g,q.g,I)&&(0,c.WithinEpsilon)(this.b,q.b,I)&&(0,c.WithinEpsilon)(this.a,q.a,I)}equalsToFloats(q,I,l,w){return this.r===q&&this.g===I&&this.b===l&&this.a===w}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Dc"}getHashCode(){let q=255*this.r|0;return q=397*q^255*this.g,q=397*q^255*this.b,q=397*q^255*this.a,q}clone(){return(new x).t(this)}t(q){return this.r=q.r,this.g=q.g,this.b=q.b,this.a=q.a,this}gc(q,I,l,w){return this.r=q,this.g=I,this.b=l,this.a=w,this}set(q,I,l,w){return this.gc(q,I,l,w)}Kc(q){return this.r=this.g=this.b=this.a=q,this}toHexString(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=Math.round(255*this.r),l=Math.round(255*this.g),w=Math.round(255*this.b);if(q)return"#"+(0,c.ToHex)(I)+(0,c.ToHex)(l)+(0,c.ToHex)(w);const t=Math.round(255*this.a);return"#"+(0,c.ToHex)(I)+(0,c.ToHex)(l)+(0,c.ToHex)(w)+(0,c.ToHex)(t)}fromHexString(q){return"#"!==q.substring(0,1)||9!==q.length&&7!==q.length||(this.r=parseInt(q.substring(1,3),16)/255,this.g=parseInt(q.substring(3,5),16)/255,this.b=parseInt(q.substring(5,7),16)/255,9===q.length&&(this.a=parseInt(q.substring(7,9),16)/255)),this}toLinearSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new x;return this.toLinearSpaceToRef(I,q),I}toLinearSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=F(this.r),q.g=F(this.g),q.b=F(this.b)):(q.r=a(this.r),q.g=a(this.g),q.b=a(this.b)),q.a=this.a,this}toGammaSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new x;return this.toGammaSpaceToRef(I,q),I}toGammaSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=Z(this.r),q.g=Z(this.g),q.b=Z(this.b)):(q.r=s(this.r),q.g=s(this.g),q.b=s(this.b)),q.a=this.a,this}static FromHexString(q){return"#"!==q.substring(0,1)||9!==q.length&&7!==q.length?new x(0,0,0,0):new x(0,0,0,1).fromHexString(q)}static Lerp(q,I,l){return x.LerpToRef(q,I,l,new x)}static LerpToRef(q,I,l,w){return w.r=q.r+(I.r-q.r)*l,w.g=q.g+(I.g-q.g)*l,w.b=q.b+(I.b-q.b)*l,w.a=q.a+(I.a-q.a)*l,w}static Hermite(q,I,l,w,t){const O=t*t,c=t*O,a=2*c-3*O+1,F=-2*c+3*O,s=c-2*O+t,Z=c-O,r=q.r*a+l.r*F+I.r*s+w.r*Z,o=q.g*a+l.g*F+I.g*s+w.g*Z,d=q.b*a+l.b*F+I.b*s+w.b*Z,T=q.a*a+l.a*F+I.a*s+w.a*Z;return new x(r,o,d,T)}static Hermite1stDerivative(q,I,l,w,t){const O=new x;return this.Hermite1stDerivativeToRef(q,I,l,w,t,O),O}static Hermite1stDerivativeToRef(q,I,l,w,t,O){const c=t*t;O.r=6*(c-t)*q.r+(3*c-4*t+1)*I.r+6*(-c+t)*l.r+(3*c-2*t)*w.r,O.g=6*(c-t)*q.g+(3*c-4*t+1)*I.g+6*(-c+t)*l.g+(3*c-2*t)*w.g,O.b=6*(c-t)*q.b+(3*c-4*t+1)*I.b+6*(-c+t)*l.b+(3*c-2*t)*w.b,O.a=6*(c-t)*q.a+(3*c-4*t+1)*I.a+6*(-c+t)*l.a+(3*c-2*t)*w.a}static FromColor3(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x(q.r,q.g,q.b,I)}static vI(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(q[I],q[I+1],q[I+2],q[I+3])}static FromArrayToRef(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2?arguments[2]:void 0;l.r=q[I],l.g=q[I+1],l.b=q[I+2],l.a=q[I+3]}static FromInts(q,I,l,w){return new x(q/255,I/255,l/255,w/255)}static CheckColors4(q,I){if(q.length===3*I){const I=[];for(let l=0;l<q.length;l+=3){const w=l/3*4;I[w]=q[l],I[w+1]=q[l+1],I[w+2]=q[l+2],I[w+3]=1}return I}return q}}x._V8PerformanceHack=new x(.5,.5,.5,.5),Object.defineProperties(x.prototype,{dimension:{value:[4]},rank:{value:1}});class o{}o.BI=(0,w.d)(3,r.Black),o.Dc=(0,w.d)(3,(()=>new x(0,0,0,0))),(0,t.e)("BABYLON.Color3",r),(0,t.e)("BABYLON.Color4",x)}}]);