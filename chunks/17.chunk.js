"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[17],{11425:(S,v,D)=>{D.r(v),D.d(v,{qv:()=>A,Ge:()=>w,TmpColors:()=>n});var z=D(11386),e=D(11329),N=D(11377),m=D(11393);function B(S){return Math.pow(S,N.m)}function g(S){return S<=.04045?.0773993808*S:Math.pow(.947867299*(S+.055),2.4)}function E(S){return Math.pow(S,N.i)}function h(S){return S<=.0031308?12.92*S:1.055*Math.pow(S,.41666)-.055}class A{constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=S,this.g=v,this.b=D}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"qv"}getHashCode(){let S=255*this.r|0;return S=397*S^255*this.g,S=397*S^255*this.b,S}toArray(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S[v]=this.r,S[v+1]=this.g,S[v+2]=this.b,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(S,v,this),this}toColor4(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new w(this.r,this.g,this.b,S)}Oe(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(S){return new A(this.r*S.r,this.g*S.g,this.b*S.b)}multiplyToRef(S,v){return v.r=this.r*S.r,v.g=this.g*S.g,v.b=this.b*S.b,v}multiplyInPlace(S){return this.r*=S.r,this.g*=S.g,this.b*=S.b,this}multiplyByFloats(S,v,D){return new A(this.r*S,this.g*v,this.b*D)}divide(S){throw new ReferenceError("Can not divide a color")}divideToRef(S,v){throw new ReferenceError("Can not divide a color")}divideInPlace(S){throw new ReferenceError("Can not divide a color")}minimizeInPlace(S){return this.minimizeInPlaceFromFloats(S.r,S.g,S.b)}maximizeInPlace(S){return this.maximizeInPlaceFromFloats(S.r,S.g,S.b)}minimizeInPlaceFromFloats(S,v,D){return this.r=Math.min(S,this.r),this.g=Math.min(v,this.g),this.b=Math.min(D,this.b),this}maximizeInPlaceFromFloats(S,v,D){return this.r=Math.max(S,this.r),this.g=Math.max(v,this.g),this.b=Math.max(D,this.b),this}floorToRef(S){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(S){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(S){return S&&this.r===S.r&&this.g===S.g&&this.b===S.b}equalsFloats(S,v,D){return this.equalsToFloats(S,v,D)}equalsToFloats(S,v,D){return this.r===S&&this.g===v&&this.b===D}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.e;return(0,m.WithinEpsilon)(this.r,S.r,v)&&(0,m.WithinEpsilon)(this.g,S.g,v)&&(0,m.WithinEpsilon)(this.b,S.b,v)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(S){throw new ReferenceError("Can not negate a color")}scale(S){return new A(this.r*S,this.g*S,this.b*S)}scaleInPlace(S){return this.r*=S,this.g*=S,this.b*=S,this}scaleToRef(S,v){return v.r=this.r*S,v.g=this.g*S,v.b=this.b*S,v}scaleAndAddToRef(S,v){return v.r+=this.r*S,v.g+=this.g*S,v.b+=this.b*S,v}clampToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.r=(0,m.Clamp)(this.r,S,v),D.g=(0,m.Clamp)(this.g,S,v),D.b=(0,m.Clamp)(this.b,S,v),D}add(S){return new A(this.r+S.r,this.g+S.g,this.b+S.b)}addInPlace(S){return this.r+=S.r,this.g+=S.g,this.b+=S.b,this}addInPlaceFromFloats(S,v,D){return this.r+=S,this.g+=v,this.b+=D,this}addToRef(S,v){return v.r=this.r+S.r,v.g=this.g+S.g,v.b=this.b+S.b,v}Ov(S){return new A(this.r-S.r,this.g-S.g,this.b-S.b)}subtractToRef(S,v){return v.r=this.r-S.r,v.g=this.g-S.g,v.b=this.b-S.b,v}tA(S){return this.r-=S.r,this.g-=S.g,this.b-=S.b,this}subtractFromFloats(S,v,D){return new A(this.r-S,this.g-v,this.b-D)}subtractFromFloatsToRef(S,v,D,z){return z.r=this.r-S,z.g=this.g-v,z.b=this.b-D,z}clone(){return new A(this.r,this.g,this.b)}N(S){return this.r=S.r,this.g=S.g,this.b=S.b,this}oe(S,v,D){return this.r=S,this.g=v,this.b=D,this}set(S,v,D){return this.oe(S,v,D)}Je(S){return this.r=this.g=this.b=S,this}toHexString(){const S=Math.round(255*this.r),v=Math.round(255*this.g),D=Math.round(255*this.b);return"#"+(0,m.ToHex)(S)+(0,m.ToHex)(v)+(0,m.ToHex)(D)}fromHexString(S){return"#"!==S.substring(0,1)||7!==S.length||(this.r=parseInt(S.substring(1,3),16)/255,this.g=parseInt(S.substring(3,5),16)/255,this.b=parseInt(S.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new A)}toHSVToRef(S){const v=this.r,D=this.g,z=this.b,e=Math.max(v,D,z),N=Math.min(v,D,z);let m=0,B=0;const g=e,E=e-N;return 0!==e&&(B=E/e),e!=N&&(e==v?(m=(D-z)/E,D<z&&(m+=6)):e==D?m=(z-v)/E+2:e==z&&(m=(v-D)/E+4),m*=60),S.r=m,S.g=B,S.b=g,S}toLinearSpace(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new A;return this.toLinearSpaceToRef(v,S),v}toLinearSpaceToRef(S){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(S.r=g(this.r),S.g=g(this.g),S.b=g(this.b)):(S.r=B(this.r),S.g=B(this.g),S.b=B(this.b)),this}toGammaSpace(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new A;return this.toGammaSpaceToRef(v,S),v}toGammaSpaceToRef(S){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(S.r=h(this.r),S.g=h(this.g),S.b=h(this.b)):(S.r=E(this.r),S.g=E(this.g),S.b=E(this.b)),this}static HSVtoRGBToRef(S,v,D,z){const e=D*v,N=S/60,m=e*(1-Math.abs(N%2-1));let B=0,g=0,E=0;N>=0&&N<=1?(B=e,g=m):N>=1&&N<=2?(B=m,g=e):N>=2&&N<=3?(g=e,E=m):N>=3&&N<=4?(g=m,E=e):N>=4&&N<=5?(B=m,E=e):N>=5&&N<=6&&(B=e,E=m);const h=D-e;return z.r=B+h,z.g=g+h,z.b=E+h,z}static FromHSV(S,v,D){const z=new A(0,0,0);return A.HSVtoRGBToRef(S,v,D,z),z}static FromHexString(S){return new A(0,0,0).fromHexString(S)}static uv(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(S[v],S[v+1],S[v+2])}static FromArrayToRef(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2?arguments[2]:void 0;D.r=S[v],D.g=S[v+1],D.b=S[v+2]}static FromInts(S,v,D){return new A(S/255,v/255,D/255)}static Lerp(S,v,D){const z=new A(0,0,0);return A.LerpToRef(S,v,D,z),z}static LerpToRef(S,v,D,z){z.r=S.r+(v.r-S.r)*D,z.g=S.g+(v.g-S.g)*D,z.b=S.b+(v.b-S.b)*D}static Hermite(S,v,D,z,e){const N=e*e,m=e*N,B=2*m-3*N+1,g=-2*m+3*N,E=m-2*N+e,h=m-N,w=S.r*B+D.r*g+v.r*E+z.r*h,n=S.g*B+D.g*g+v.g*E+z.g*h,R=S.b*B+D.b*g+v.b*E+z.b*h;return new A(w,n,R)}static Hermite1stDerivative(S,v,D,z,e){const N=A.Black();return this.Hermite1stDerivativeToRef(S,v,D,z,e,N),N}static Hermite1stDerivativeToRef(S,v,D,z,e,N){const m=e*e;N.r=6*(m-e)*S.r+(3*m-4*e+1)*v.r+6*(-m+e)*D.r+(3*m-2*e)*z.r,N.g=6*(m-e)*S.g+(3*m-4*e+1)*v.g+6*(-m+e)*D.g+(3*m-2*e)*z.g,N.b=6*(m-e)*S.b+(3*m-4*e+1)*v.b+6*(-m+e)*D.b+(3*m-2*e)*z.b}static Red(){return new A(1,0,0)}static Green(){return new A(0,1,0)}static Blue(){return new A(0,0,1)}static Black(){return new A(0,0,0)}static get BlackReadOnly(){return A._BlackReadOnly}static White(){return new A(1,1,1)}static Purple(){return new A(.5,0,.5)}static Magenta(){return new A(1,0,1)}static Yellow(){return new A(1,1,0)}static Gray(){return new A(.5,.5,.5)}static Teal(){return new A(0,1,1)}static Random(){return new A(Math.random(),Math.random(),Math.random())}}A._V8PerformanceHack=new A(.5,.5,.5),A._BlackReadOnly=A.Black(),Object.defineProperties(A.prototype,{dimension:{value:[3]},rank:{value:1}});class w{constructor(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=S,this.g=v,this.b=D,this.a=z}Oe(){return[this.r,this.g,this.b,this.a]}toArray(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S[v]=this.r,S[v+1]=this.g,S[v+2]=this.b,S[v+3]=this.a,this}RD(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=S[v],this.g=S[v+1],this.b=S[v+2],this.a=S[v+3],this}equals(S){return S&&this.r===S.r&&this.g===S.g&&this.b===S.b&&this.a===S.a}add(S){return new w(this.r+S.r,this.g+S.g,this.b+S.b,this.a+S.a)}addToRef(S,v){return v.r=this.r+S.r,v.g=this.g+S.g,v.b=this.b+S.b,v.a=this.a+S.a,v}addInPlace(S){return this.r+=S.r,this.g+=S.g,this.b+=S.b,this.a+=S.a,this}addInPlaceFromFloats(S,v,D,z){return this.r+=S,this.g+=v,this.b+=D,this.a+=z,this}Ov(S){return new w(this.r-S.r,this.g-S.g,this.b-S.b,this.a-S.a)}subtractToRef(S,v){return v.r=this.r-S.r,v.g=this.g-S.g,v.b=this.b-S.b,v.a=this.a-S.a,v}tA(S){return this.r-=S.r,this.g-=S.g,this.b-=S.b,this.a-=S.a,this}subtractFromFloats(S,v,D,z){return new w(this.r-S,this.g-v,this.b-D,this.a-z)}subtractFromFloatsToRef(S,v,D,z,e){return e.r=this.r-S,e.g=this.g-v,e.b=this.b-D,e.a=this.a-z,e}scale(S){return new w(this.r*S,this.g*S,this.b*S,this.a*S)}scaleInPlace(S){return this.r*=S,this.g*=S,this.b*=S,this.a*=S,this}scaleToRef(S,v){return v.r=this.r*S,v.g=this.g*S,v.b=this.b*S,v.a=this.a*S,v}scaleAndAddToRef(S,v){return v.r+=this.r*S,v.g+=this.g*S,v.b+=this.b*S,v.a+=this.a*S,v}clampToRef(){let S=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,D=arguments.length>2?arguments[2]:void 0;return D.r=(0,m.Clamp)(this.r,S,v),D.g=(0,m.Clamp)(this.g,S,v),D.b=(0,m.Clamp)(this.b,S,v),D.a=(0,m.Clamp)(this.a,S,v),D}multiply(S){return new w(this.r*S.r,this.g*S.g,this.b*S.b,this.a*S.a)}multiplyToRef(S,v){return v.r=this.r*S.r,v.g=this.g*S.g,v.b=this.b*S.b,v.a=this.a*S.a,v}multiplyInPlace(S){return this.r*=S.r,this.g*=S.g,this.b*=S.b,this.a*=S.a,this}multiplyByFloats(S,v,D,z){return new w(this.r*S,this.g*v,this.b*D,this.a*z)}divide(S){throw new ReferenceError("Can not divide a color")}divideToRef(S,v){throw new ReferenceError("Can not divide a color")}divideInPlace(S){throw new ReferenceError("Can not divide a color")}minimizeInPlace(S){return this.r=Math.min(this.r,S.r),this.g=Math.min(this.g,S.g),this.b=Math.min(this.b,S.b),this.a=Math.min(this.a,S.a),this}maximizeInPlace(S){return this.r=Math.max(this.r,S.r),this.g=Math.max(this.g,S.g),this.b=Math.max(this.b,S.b),this.a=Math.max(this.a,S.a),this}minimizeInPlaceFromFloats(S,v,D,z){return this.r=Math.min(S,this.r),this.g=Math.min(v,this.g),this.b=Math.min(D,this.b),this.a=Math.min(z,this.a),this}maximizeInPlaceFromFloats(S,v,D,z){return this.r=Math.max(S,this.r),this.g=Math.max(v,this.g),this.b=Math.max(D,this.b),this.a=Math.max(z,this.a),this}floorToRef(S){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(S){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(S){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.e;return(0,m.WithinEpsilon)(this.r,S.r,v)&&(0,m.WithinEpsilon)(this.g,S.g,v)&&(0,m.WithinEpsilon)(this.b,S.b,v)&&(0,m.WithinEpsilon)(this.a,S.a,v)}equalsToFloats(S,v,D,z){return this.r===S&&this.g===v&&this.b===D&&this.a===z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Ge"}getHashCode(){let S=255*this.r|0;return S=397*S^255*this.g,S=397*S^255*this.b,S=397*S^255*this.a,S}clone(){return(new w).N(this)}N(S){return this.r=S.r,this.g=S.g,this.b=S.b,this.a=S.a,this}oe(S,v,D,z){return this.r=S,this.g=v,this.b=D,this.a=z,this}set(S,v,D,z){return this.oe(S,v,D,z)}Je(S){return this.r=this.g=this.b=this.a=S,this}toHexString(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=Math.round(255*this.r),D=Math.round(255*this.g),z=Math.round(255*this.b);if(S)return"#"+(0,m.ToHex)(v)+(0,m.ToHex)(D)+(0,m.ToHex)(z);const e=Math.round(255*this.a);return"#"+(0,m.ToHex)(v)+(0,m.ToHex)(D)+(0,m.ToHex)(z)+(0,m.ToHex)(e)}fromHexString(S){return"#"!==S.substring(0,1)||9!==S.length&&7!==S.length||(this.r=parseInt(S.substring(1,3),16)/255,this.g=parseInt(S.substring(3,5),16)/255,this.b=parseInt(S.substring(5,7),16)/255,9===S.length&&(this.a=parseInt(S.substring(7,9),16)/255)),this}toLinearSpace(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new w;return this.toLinearSpaceToRef(v,S),v}toLinearSpaceToRef(S){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(S.r=g(this.r),S.g=g(this.g),S.b=g(this.b)):(S.r=B(this.r),S.g=B(this.g),S.b=B(this.b)),S.a=this.a,this}toGammaSpace(){let S=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new w;return this.toGammaSpaceToRef(v,S),v}toGammaSpaceToRef(S){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(S.r=h(this.r),S.g=h(this.g),S.b=h(this.b)):(S.r=E(this.r),S.g=E(this.g),S.b=E(this.b)),S.a=this.a,this}static FromHexString(S){return"#"!==S.substring(0,1)||9!==S.length&&7!==S.length?new w(0,0,0,0):new w(0,0,0,1).fromHexString(S)}static Lerp(S,v,D){return w.LerpToRef(S,v,D,new w)}static LerpToRef(S,v,D,z){return z.r=S.r+(v.r-S.r)*D,z.g=S.g+(v.g-S.g)*D,z.b=S.b+(v.b-S.b)*D,z.a=S.a+(v.a-S.a)*D,z}static Hermite(S,v,D,z,e){const N=e*e,m=e*N,B=2*m-3*N+1,g=-2*m+3*N,E=m-2*N+e,h=m-N,A=S.r*B+D.r*g+v.r*E+z.r*h,n=S.g*B+D.g*g+v.g*E+z.g*h,R=S.b*B+D.b*g+v.b*E+z.b*h,O=S.a*B+D.a*g+v.a*E+z.a*h;return new w(A,n,R,O)}static Hermite1stDerivative(S,v,D,z,e){const N=new w;return this.Hermite1stDerivativeToRef(S,v,D,z,e,N),N}static Hermite1stDerivativeToRef(S,v,D,z,e,N){const m=e*e;N.r=6*(m-e)*S.r+(3*m-4*e+1)*v.r+6*(-m+e)*D.r+(3*m-2*e)*z.r,N.g=6*(m-e)*S.g+(3*m-4*e+1)*v.g+6*(-m+e)*D.g+(3*m-2*e)*z.g,N.b=6*(m-e)*S.b+(3*m-4*e+1)*v.b+6*(-m+e)*D.b+(3*m-2*e)*z.b,N.a=6*(m-e)*S.a+(3*m-4*e+1)*v.a+6*(-m+e)*D.a+(3*m-2*e)*z.a}static FromColor3(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new w(S.r,S.g,S.b,v)}static uv(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new w(S[v],S[v+1],S[v+2],S[v+3])}static FromArrayToRef(S){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,D=arguments.length>2?arguments[2]:void 0;D.r=S[v],D.g=S[v+1],D.b=S[v+2],D.a=S[v+3]}static FromInts(S,v,D,z){return new w(S/255,v/255,D/255,z/255)}static CheckColors4(S,v){if(S.length===3*v){const v=[];for(let D=0;D<S.length;D+=3){const z=D/3*4;v[z]=S[D],v[z+1]=S[D+1],v[z+2]=S[D+2],v[z+3]=1}return v}return S}}w._V8PerformanceHack=new w(.5,.5,.5,.5),Object.defineProperties(w.prototype,{dimension:{value:[4]},rank:{value:1}});class n{}n.qv=(0,z.d)(3,A.Black),n.Ge=(0,z.d)(3,(()=>new w(0,0,0,0))),(0,e.f)("BABYLON.Color3",A),(0,e.f)("BABYLON.Color4",w)}}]);