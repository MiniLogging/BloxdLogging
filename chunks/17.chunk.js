"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{12715:(Y,j,X)=>{X.r(j),X.d(j,{_TGATextureLoader:()=>y});var u=X(10766);function K(Y){let j=0;return{id_length:Y[j++],colormap_type:Y[j++],image_type:Y[j++],colormap_index:Y[j++]|Y[j++]<<8,colormap_length:Y[j++]|Y[j++]<<8,colormap_size:Y[j++],origin:[Y[j++]|Y[j++]<<8,Y[j++]|Y[j++]<<8],width:Y[j++]|Y[j++]<<8,height:Y[j++]|Y[j++]<<8,pixel_size:Y[j++],flags:Y[j++]}}function U(Y,j){if(j.length<19)return void u.c.Error("Unable to load TGA file - Not enough data to contain header");let X=18;const U=K(j);if(U.id_length+X>j.length)return void u.c.Error("Unable to load TGA file - Not enough data");X+=U.id_length;let y,T=!1,E=!1,e=!1;switch(U.image_type){case 9:T=!0;case 1:E=!0;break;case 10:T=!0;case 2:break;case 11:T=!0;case 3:e=!0}const a=U.pixel_size>>3,N=U.width*U.height*a;let d,i,M,R,C,O,P;if(E&&(d=j.subarray(X,X+=U.colormap_length*(U.colormap_size>>3))),T){let Y,u,K;y=new Uint8Array(N);let U=0;const I=new Uint8Array(a);for(;X<N&&U<N;)if(Y=j[X++],u=1+(127&Y),128&Y){for(K=0;K<a;++K)I[K]=j[X++];for(K=0;K<u;++K)y.set(I,U+K*a);U+=a*u}else{for(u*=a,K=0;K<u;++K)y[U+K]=j[X++];U+=u}}else y=j.subarray(X,X+=E?U.width*U.height:N);switch((48&U.flags)>>4){default:case 2:i=0,R=1,P=U.width,M=0,C=1,O=U.height;break;case 0:i=0,R=1,P=U.width,M=U.height-1,C=-1,O=-1;break;case 3:i=U.width-1,R=-1,P=-1,M=0,C=1,O=U.height;break;case 1:i=U.width-1,R=-1,P=-1,M=U.height-1,C=-1,O=-1}const Q="_getImageData"+(e?"Grey":"")+U.pixel_size+"bits",W=I[Q](U,d,y,M,C,O,i,R,P);Y.getEngine()._uploadDataToTextureDirectly(Y,W)}const I={GetTGAHeader:K,UploadContent:U,_getImageData8bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=j,a=Y.width,N=Y.height;let d,i,M,R=0;const C=new Uint8Array(a*N*4);for(M=u;M!==U;M+=K)for(i=I;i!==T;i+=y,R++)d=E[R],C[4*(i+a*M)+3]=255,C[4*(i+a*M)+2]=e[3*d+0],C[4*(i+a*M)+1]=e[3*d+1],C[4*(i+a*M)+0]=e[3*d+2];return C},_getImageData16bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=Y.width,a=Y.height;let N,d,i,M=0;const R=new Uint8Array(e*a*4);for(i=u;i!==U;i+=K)for(d=I;d!==T;d+=y,M+=2){N=E[M+0]+(E[M+1]<<8);const Y=255*((31744&N)>>10)/31|0,j=255*((992&N)>>5)/31|0,X=255*(31&N)/31|0;R[4*(d+e*i)+0]=Y,R[4*(d+e*i)+1]=j,R[4*(d+e*i)+2]=X,R[4*(d+e*i)+3]=32768&N?0:255}return R},_getImageData24bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=Y.width,a=Y.height;let N,d,i=0;const M=new Uint8Array(e*a*4);for(d=u;d!==U;d+=K)for(N=I;N!==T;N+=y,i+=3)M[4*(N+e*d)+3]=255,M[4*(N+e*d)+2]=E[i+0],M[4*(N+e*d)+1]=E[i+1],M[4*(N+e*d)+0]=E[i+2];return M},_getImageData32bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=Y.width,a=Y.height;let N,d,i=0;const M=new Uint8Array(e*a*4);for(d=u;d!==U;d+=K)for(N=I;N!==T;N+=y,i+=4)M[4*(N+e*d)+2]=E[i+0],M[4*(N+e*d)+1]=E[i+1],M[4*(N+e*d)+0]=E[i+2],M[4*(N+e*d)+3]=E[i+3];return M},_getImageDataGrey8bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=Y.width,a=Y.height;let N,d,i,M=0;const R=new Uint8Array(e*a*4);for(i=u;i!==U;i+=K)for(d=I;d!==T;d+=y,M++)N=E[M],R[4*(d+e*i)+0]=N,R[4*(d+e*i)+1]=N,R[4*(d+e*i)+2]=N,R[4*(d+e*i)+3]=255;return R},_getImageDataGrey16bits:function(Y,j,X,u,K,U,I,y,T){const E=X,e=Y.width,a=Y.height;let N,d,i=0;const M=new Uint8Array(e*a*4);for(d=u;d!==U;d+=K)for(N=I;N!==T;N+=y,i+=2)M[4*(N+e*d)+0]=E[i+0],M[4*(N+e*d)+1]=E[i+0],M[4*(N+e*d)+2]=E[i+0],M[4*(N+e*d)+3]=E[i+1];return M}};class y{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Y,j,X){const u=new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength),I=K(u);X(I.width,I.height,j.generateMipMaps,!1,(()=>{U(j,u)}))}}}}]);