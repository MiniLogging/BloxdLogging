"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[17],{11167:(N,q,C)=>{C.r(q),C.d(q,{Oq:()=>t,md:()=>V,TmpColors:()=>Z});var d=C(11134),U=C(11076),W=C(11129),a=C(11142);function F(N){return Math.pow(N,W.m)}function w(N){return N<=.04045?.0773993808*N:Math.pow(.947867299*(N+.055),2.4)}function A(N){return Math.pow(N,W.l)}function n(N){return N<=.0031308?12.92*N:1.055*Math.pow(N,.41666)-.055}class t{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=N,this.g=q,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Oq"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N}toArray(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[q]=this.r,N[q+1]=this.g,N[q+2]=this.b,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.FromArrayToRef(N,q,this),this}toColor4(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new V(this.r,this.g,this.b,N)}zd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(N){return new t(this.r*N.r,this.g*N.g,this.b*N.b)}multiplyToRef(N,q){return q.r=this.r*N.r,q.g=this.g*N.g,q.b=this.b*N.b,q}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this}multiplyByFloats(N,q,C){return new t(this.r*N,this.g*q,this.b*C)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,q){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.r,N.g,N.b)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.r,N.g,N.b)}minimizeInPlaceFromFloats(N,q,C){return this.r=Math.min(N,this.r),this.g=Math.min(q,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(N,q,C){return this.r=Math.max(N,this.r),this.g=Math.max(q,this.g),this.b=Math.max(C,this.b),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b}equalsFloats(N,q,C){return this.equalsToFloats(N,q,C)}equalsToFloats(N,q,C){return this.r===N&&this.g===q&&this.b===C}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.e;return(0,a.WithinEpsilon)(this.r,N.r,q)&&(0,a.WithinEpsilon)(this.g,N.g,q)&&(0,a.WithinEpsilon)(this.b,N.b,q)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}scale(N){return new t(this.r*N,this.g*N,this.b*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this}scaleToRef(N,q){return q.r=this.r*N,q.g=this.g*N,q.b=this.b*N,q}scaleAndAddToRef(N,q){return q.r+=this.r*N,q.g+=this.g*N,q.b+=this.b*N,q}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,a.Clamp)(this.r,N,q),C.g=(0,a.Clamp)(this.g,N,q),C.b=(0,a.Clamp)(this.b,N,q),C}add(N){return new t(this.r+N.r,this.g+N.g,this.b+N.b)}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this}addInPlaceFromFloats(N,q,C){return this.r+=N,this.g+=q,this.b+=C,this}addToRef(N,q){return q.r=this.r+N.r,q.g=this.g+N.g,q.b=this.b+N.b,q}Qq(N){return new t(this.r-N.r,this.g-N.g,this.b-N.b)}subtractToRef(N,q){return q.r=this.r-N.r,q.g=this.g-N.g,q.b=this.b-N.b,q}Rn(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this}subtractFromFloats(N,q,C){return new t(this.r-N,this.g-q,this.b-C)}subtractFromFloatsToRef(N,q,C,d){return d.r=this.r-N,d.g=this.g-q,d.b=this.b-C,d}clone(){return new t(this.r,this.g,this.b)}U(N){return this.r=N.r,this.g=N.g,this.b=N.b,this}hd(N,q,C){return this.r=N,this.g=q,this.b=C,this}set(N,q,C){return this.hd(N,q,C)}Rd(N){return this.r=this.g=this.b=N,this}toHexString(){const N=Math.round(255*this.r),q=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,a.ToHex)(N)+(0,a.ToHex)(q)+(0,a.ToHex)(C)}fromHexString(N){return"#"!==N.substring(0,1)||7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new t)}toHSVToRef(N){const q=this.r,C=this.g,d=this.b,U=Math.max(q,C,d),W=Math.min(q,C,d);let a=0,F=0;const w=U,A=U-W;return 0!==U&&(F=A/U),U!=W&&(U==q?(a=(C-d)/A,C<d&&(a+=6)):U==C?a=(d-q)/A+2:U==d&&(a=(q-C)/A+4),a*=60),N.r=a,N.g=F,N.b=w,N}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new t;return this.toLinearSpaceToRef(q,N),q}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=w(this.r),N.g=w(this.g),N.b=w(this.b)):(N.r=F(this.r),N.g=F(this.g),N.b=F(this.b)),this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new t;return this.toGammaSpaceToRef(q,N),q}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=n(this.r),N.g=n(this.g),N.b=n(this.b)):(N.r=A(this.r),N.g=A(this.g),N.b=A(this.b)),this}static HSVtoRGBToRef(N,q,C,d){const U=C*q,W=N/60,a=U*(1-Math.abs(W%2-1));let F=0,w=0,A=0;W>=0&&W<=1?(F=U,w=a):W>=1&&W<=2?(F=a,w=U):W>=2&&W<=3?(w=U,A=a):W>=3&&W<=4?(w=a,A=U):W>=4&&W<=5?(F=a,A=U):W>=5&&W<=6&&(F=U,A=a);const n=C-U;return d.r=F+n,d.g=w+n,d.b=A+n,d}static FromHSV(N,q,C){const d=new t(0,0,0);return t.HSVtoRGBToRef(N,q,C,d),d}static FromHexString(N){return new t(0,0,0).fromHexString(N)}static Kq(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(N[q],N[q+1],N[q+2])}static FromArrayToRef(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=N[q],C.g=N[q+1],C.b=N[q+2]}static FromInts(N,q,C){return new t(N/255,q/255,C/255)}static Lerp(N,q,C){const d=new t(0,0,0);return t.LerpToRef(N,q,C,d),d}static LerpToRef(N,q,C,d){d.r=N.r+(q.r-N.r)*C,d.g=N.g+(q.g-N.g)*C,d.b=N.b+(q.b-N.b)*C}static Hermite(N,q,C,d,U){const W=U*U,a=U*W,F=2*a-3*W+1,w=-2*a+3*W,A=a-2*W+U,n=a-W,V=N.r*F+C.r*w+q.r*A+d.r*n,Z=N.g*F+C.g*w+q.g*A+d.g*n,J=N.b*F+C.b*w+q.b*A+d.b*n;return new t(V,Z,J)}static Hermite1stDerivative(N,q,C,d,U){const W=t.Black();return this.Hermite1stDerivativeToRef(N,q,C,d,U,W),W}static Hermite1stDerivativeToRef(N,q,C,d,U,W){const a=U*U;W.r=6*(a-U)*N.r+(3*a-4*U+1)*q.r+6*(-a+U)*C.r+(3*a-2*U)*d.r,W.g=6*(a-U)*N.g+(3*a-4*U+1)*q.g+6*(-a+U)*C.g+(3*a-2*U)*d.g,W.b=6*(a-U)*N.b+(3*a-4*U+1)*q.b+6*(-a+U)*C.b+(3*a-2*U)*d.b}static Red(){return new t(1,0,0)}static Green(){return new t(0,1,0)}static Blue(){return new t(0,0,1)}static Black(){return new t(0,0,0)}static get BlackReadOnly(){return t._BlackReadOnly}static White(){return new t(1,1,1)}static Purple(){return new t(.5,0,.5)}static Magenta(){return new t(1,0,1)}static Yellow(){return new t(1,1,0)}static Gray(){return new t(.5,.5,.5)}static Teal(){return new t(0,1,1)}static Random(){return new t(Math.random(),Math.random(),Math.random())}}t._V8PerformanceHack=new t(.5,.5,.5),t._BlackReadOnly=t.Black(),Object.defineProperties(t.prototype,{dimension:{value:[3]},rank:{value:1}});class V{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=N,this.g=q,this.b=C,this.a=d}zd(){return[this.r,this.g,this.b,this.a]}toArray(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[q]=this.r,N[q+1]=this.g,N[q+2]=this.b,N[q+3]=this.a,this}JC(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=N[q],this.g=N[q+1],this.b=N[q+2],this.a=N[q+3],this}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b&&this.a===N.a}add(N){return new V(this.r+N.r,this.g+N.g,this.b+N.b,this.a+N.a)}addToRef(N,q){return q.r=this.r+N.r,q.g=this.g+N.g,q.b=this.b+N.b,q.a=this.a+N.a,q}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this.a+=N.a,this}addInPlaceFromFloats(N,q,C,d){return this.r+=N,this.g+=q,this.b+=C,this.a+=d,this}Qq(N){return new V(this.r-N.r,this.g-N.g,this.b-N.b,this.a-N.a)}subtractToRef(N,q){return q.r=this.r-N.r,q.g=this.g-N.g,q.b=this.b-N.b,q.a=this.a-N.a,q}Rn(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this.a-=N.a,this}subtractFromFloats(N,q,C,d){return new V(this.r-N,this.g-q,this.b-C,this.a-d)}subtractFromFloatsToRef(N,q,C,d,U){return U.r=this.r-N,U.g=this.g-q,U.b=this.b-C,U.a=this.a-d,U}scale(N){return new V(this.r*N,this.g*N,this.b*N,this.a*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this.a*=N,this}scaleToRef(N,q){return q.r=this.r*N,q.g=this.g*N,q.b=this.b*N,q.a=this.a*N,q}scaleAndAddToRef(N,q){return q.r+=this.r*N,q.g+=this.g*N,q.b+=this.b*N,q.a+=this.a*N,q}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,a.Clamp)(this.r,N,q),C.g=(0,a.Clamp)(this.g,N,q),C.b=(0,a.Clamp)(this.b,N,q),C.a=(0,a.Clamp)(this.a,N,q),C}multiply(N){return new V(this.r*N.r,this.g*N.g,this.b*N.b,this.a*N.a)}multiplyToRef(N,q){return q.r=this.r*N.r,q.g=this.g*N.g,q.b=this.b*N.b,q.a=this.a*N.a,q}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this.a*=N.a,this}multiplyByFloats(N,q,C,d){return new V(this.r*N,this.g*q,this.b*C,this.a*d)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,q){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.r=Math.min(this.r,N.r),this.g=Math.min(this.g,N.g),this.b=Math.min(this.b,N.b),this.a=Math.min(this.a,N.a),this}maximizeInPlace(N){return this.r=Math.max(this.r,N.r),this.g=Math.max(this.g,N.g),this.b=Math.max(this.b,N.b),this.a=Math.max(this.a,N.a),this}minimizeInPlaceFromFloats(N,q,C,d){return this.r=Math.min(N,this.r),this.g=Math.min(q,this.g),this.b=Math.min(C,this.b),this.a=Math.min(d,this.a),this}maximizeInPlaceFromFloats(N,q,C,d){return this.r=Math.max(N,this.r),this.g=Math.max(q,this.g),this.b=Math.max(C,this.b),this.a=Math.max(d,this.a),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:W.e;return(0,a.WithinEpsilon)(this.r,N.r,q)&&(0,a.WithinEpsilon)(this.g,N.g,q)&&(0,a.WithinEpsilon)(this.b,N.b,q)&&(0,a.WithinEpsilon)(this.a,N.a,q)}equalsToFloats(N,q,C,d){return this.r===N&&this.g===q&&this.b===C&&this.a===d}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"md"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N=397*N^255*this.a,N}clone(){return(new V).U(this)}U(N){return this.r=N.r,this.g=N.g,this.b=N.b,this.a=N.a,this}hd(N,q,C,d){return this.r=N,this.g=q,this.b=C,this.a=d,this}set(N,q,C,d){return this.hd(N,q,C,d)}Rd(N){return this.r=this.g=this.b=this.a=N,this}toHexString(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=Math.round(255*this.r),C=Math.round(255*this.g),d=Math.round(255*this.b);if(N)return"#"+(0,a.ToHex)(q)+(0,a.ToHex)(C)+(0,a.ToHex)(d);const U=Math.round(255*this.a);return"#"+(0,a.ToHex)(q)+(0,a.ToHex)(C)+(0,a.ToHex)(d)+(0,a.ToHex)(U)}fromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255,9===N.length&&(this.a=parseInt(N.substring(7,9),16)/255)),this}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new V;return this.toLinearSpaceToRef(q,N),q}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=w(this.r),N.g=w(this.g),N.b=w(this.b)):(N.r=F(this.r),N.g=F(this.g),N.b=F(this.b)),N.a=this.a,this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new V;return this.toGammaSpaceToRef(q,N),q}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=n(this.r),N.g=n(this.g),N.b=n(this.b)):(N.r=A(this.r),N.g=A(this.g),N.b=A(this.b)),N.a=this.a,this}static FromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length?new V(0,0,0,0):new V(0,0,0,1).fromHexString(N)}static Lerp(N,q,C){return V.LerpToRef(N,q,C,new V)}static LerpToRef(N,q,C,d){return d.r=N.r+(q.r-N.r)*C,d.g=N.g+(q.g-N.g)*C,d.b=N.b+(q.b-N.b)*C,d.a=N.a+(q.a-N.a)*C,d}static Hermite(N,q,C,d,U){const W=U*U,a=U*W,F=2*a-3*W+1,w=-2*a+3*W,A=a-2*W+U,n=a-W,t=N.r*F+C.r*w+q.r*A+d.r*n,Z=N.g*F+C.g*w+q.g*A+d.g*n,J=N.b*F+C.b*w+q.b*A+d.b*n,Q=N.a*F+C.a*w+q.a*A+d.a*n;return new V(t,Z,J,Q)}static Hermite1stDerivative(N,q,C,d,U){const W=new V;return this.Hermite1stDerivativeToRef(N,q,C,d,U,W),W}static Hermite1stDerivativeToRef(N,q,C,d,U,W){const a=U*U;W.r=6*(a-U)*N.r+(3*a-4*U+1)*q.r+6*(-a+U)*C.r+(3*a-2*U)*d.r,W.g=6*(a-U)*N.g+(3*a-4*U+1)*q.g+6*(-a+U)*C.g+(3*a-2*U)*d.g,W.b=6*(a-U)*N.b+(3*a-4*U+1)*q.b+6*(-a+U)*C.b+(3*a-2*U)*d.b,W.a=6*(a-U)*N.a+(3*a-4*U+1)*q.a+6*(-a+U)*C.a+(3*a-2*U)*d.a}static FromColor3(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V(N.r,N.g,N.b,q)}static Kq(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(N[q],N[q+1],N[q+2],N[q+3])}static FromArrayToRef(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=N[q],C.g=N[q+1],C.b=N[q+2],C.a=N[q+3]}static FromInts(N,q,C,d){return new V(N/255,q/255,C/255,d/255)}static CheckColors4(N,q){if(N.length===3*q){const q=[];for(let C=0;C<N.length;C+=3){const d=C/3*4;q[d]=N[C],q[d+1]=N[C+1],q[d+2]=N[C+2],q[d+3]=1}return q}return N}}V._V8PerformanceHack=new V(.5,.5,.5,.5),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class Z{}Z.Oq=(0,d.d)(3,t.Black),Z.md=(0,d.d)(3,(()=>new V(0,0,0,0))),(0,U.h)("BABYLON.Color3",t),(0,U.h)("BABYLON.Color4",V)}}]);