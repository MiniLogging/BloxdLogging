"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{11150:(q,S,b)=>{b.d(S,{HS:()=>l,b:()=>y,e:()=>R});var z=b(11118),C=b(11058),v=b(11109),U=b(11121);function g(q){return Math.pow(q,v.j)}function r(q){return q<=.04045?.0773993808*q:Math.pow(.947867299*(q+.055),2.4)}function I(q){return Math.pow(q,v.h)}function V(q){return q<=.0031308?12.92*q:1.055*Math.pow(q,.41666)-.055}class l{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=q,this.g=S,this.b=b}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"HS"}getHashCode(){let q=255*this.r|0;return q=397*q^255*this.g,q=397*q^255*this.b,q}toArray(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[S]=this.r,q[S+1]=this.g,q[S+2]=this.b,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(q,S,this),this}toColor4(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new y(this.r,this.g,this.b,q)}Zb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(q){return new l(this.r*q.r,this.g*q.g,this.b*q.b)}multiplyToRef(q,S){return S.r=this.r*q.r,S.g=this.g*q.g,S.b=this.b*q.b,S}multiplyInPlace(q){return this.r*=q.r,this.g*=q.g,this.b*=q.b,this}multiplyByFloats(q,S,b){return new l(this.r*q,this.g*S,this.b*b)}divide(q){throw new ReferenceError("Can not divide a color")}divideToRef(q,S){throw new ReferenceError("Can not divide a color")}divideInPlace(q){throw new ReferenceError("Can not divide a color")}minimizeInPlace(q){return this.minimizeInPlaceFromFloats(q.r,q.g,q.b)}maximizeInPlace(q){return this.maximizeInPlaceFromFloats(q.r,q.g,q.b)}minimizeInPlaceFromFloats(q,S,b){return this.r=Math.min(q,this.r),this.g=Math.min(S,this.g),this.b=Math.min(b,this.b),this}maximizeInPlaceFromFloats(q,S,b){return this.r=Math.max(q,this.r),this.g=Math.max(S,this.g),this.b=Math.max(b,this.b),this}floorToRef(q){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(q){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(q){return q&&this.r===q.r&&this.g===q.g&&this.b===q.b}equalsFloats(q,S,b){return this.equalsToFloats(q,S,b)}equalsToFloats(q,S,b){return this.r===q&&this.g===S&&this.b===b}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.d;return(0,U.WithinEpsilon)(this.r,q.r,S)&&(0,U.WithinEpsilon)(this.g,q.g,S)&&(0,U.WithinEpsilon)(this.b,q.b,S)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(q){throw new ReferenceError("Can not negate a color")}scale(q){return new l(this.r*q,this.g*q,this.b*q)}scaleInPlace(q){return this.r*=q,this.g*=q,this.b*=q,this}scaleToRef(q,S){return S.r=this.r*q,S.g=this.g*q,S.b=this.b*q,S}scaleAndAddToRef(q,S){return S.r+=this.r*q,S.g+=this.g*q,S.b+=this.b*q,S}clampToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,U.Clamp)(this.r,q,S),b.g=(0,U.Clamp)(this.g,q,S),b.b=(0,U.Clamp)(this.b,q,S),b}add(q){return new l(this.r+q.r,this.g+q.g,this.b+q.b)}addInPlace(q){return this.r+=q.r,this.g+=q.g,this.b+=q.b,this}addInPlaceFromFloats(q,S,b){return this.r+=q,this.g+=S,this.b+=b,this}addToRef(q,S){return S.r=this.r+q.r,S.g=this.g+q.g,S.b=this.b+q.b,S}RS(q){return new l(this.r-q.r,this.g-q.g,this.b-q.b)}subtractToRef(q,S){return S.r=this.r-q.r,S.g=this.g-q.g,S.b=this.b-q.b,S}Ql(q){return this.r-=q.r,this.g-=q.g,this.b-=q.b,this}subtractFromFloats(q,S,b){return new l(this.r-q,this.g-S,this.b-b)}subtractFromFloatsToRef(q,S,b,z){return z.r=this.r-q,z.g=this.g-S,z.b=this.b-b,z}clone(){return new l(this.r,this.g,this.b)}v(q){return this.r=q.r,this.g=q.g,this.b=q.b,this}Bb(q,S,b){return this.r=q,this.g=S,this.b=b,this}set(q,S,b){return this.Bb(q,S,b)}fb(q){return this.r=this.g=this.b=q,this}toHexString(){const q=Math.round(255*this.r),S=Math.round(255*this.g),b=Math.round(255*this.b);return"#"+(0,U.ToHex)(q)+(0,U.ToHex)(S)+(0,U.ToHex)(b)}fromHexString(q){return"#"!==q.substring(0,1)||7!==q.length||(this.r=parseInt(q.substring(1,3),16)/255,this.g=parseInt(q.substring(3,5),16)/255,this.b=parseInt(q.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new l)}toHSVToRef(q){const S=this.r,b=this.g,z=this.b,C=Math.max(S,b,z),v=Math.min(S,b,z);let U=0,g=0;const r=C,I=C-v;return 0!==C&&(g=I/C),C!=v&&(C==S?(U=(b-z)/I,b<z&&(U+=6)):C==b?U=(z-S)/I+2:C==z&&(U=(S-b)/I+4),U*=60),q.r=U,q.g=g,q.b=r,q}toLinearSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new l;return this.toLinearSpaceToRef(S,q),S}toLinearSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=r(this.r),q.g=r(this.g),q.b=r(this.b)):(q.r=g(this.r),q.g=g(this.g),q.b=g(this.b)),this}toGammaSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new l;return this.toGammaSpaceToRef(S,q),S}toGammaSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=V(this.r),q.g=V(this.g),q.b=V(this.b)):(q.r=I(this.r),q.g=I(this.g),q.b=I(this.b)),this}static HSVtoRGBToRef(q,S,b,z){const C=b*S,v=q/60,U=C*(1-Math.abs(v%2-1));let g=0,r=0,I=0;v>=0&&v<=1?(g=C,r=U):v>=1&&v<=2?(g=U,r=C):v>=2&&v<=3?(r=C,I=U):v>=3&&v<=4?(r=U,I=C):v>=4&&v<=5?(g=U,I=C):v>=5&&v<=6&&(g=C,I=U);const V=b-C;return z.r=g+V,z.g=r+V,z.b=I+V,z}static FromHSV(q,S,b){const z=new l(0,0,0);return l.HSVtoRGBToRef(q,S,b,z),z}static FromHexString(q){return new l(0,0,0).fromHexString(q)}static Hb(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(q[S],q[S+1],q[S+2])}static FromArrayToRef(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=q[S],b.g=q[S+1],b.b=q[S+2]}static FromInts(q,S,b){return new l(q/255,S/255,b/255)}static Lerp(q,S,b){const z=new l(0,0,0);return l.LerpToRef(q,S,b,z),z}static LerpToRef(q,S,b,z){z.r=q.r+(S.r-q.r)*b,z.g=q.g+(S.g-q.g)*b,z.b=q.b+(S.b-q.b)*b}static Hermite(q,S,b,z,C){const v=C*C,U=C*v,g=2*U-3*v+1,r=-2*U+3*v,I=U-2*v+C,V=U-v,y=q.r*g+b.r*r+S.r*I+z.r*V,R=q.g*g+b.g*r+S.g*I+z.g*V,G=q.b*g+b.b*r+S.b*I+z.b*V;return new l(y,R,G)}static Hermite1stDerivative(q,S,b,z,C){const v=l.Black();return this.Hermite1stDerivativeToRef(q,S,b,z,C,v),v}static Hermite1stDerivativeToRef(q,S,b,z,C,v){const U=C*C;v.r=6*(U-C)*q.r+(3*U-4*C+1)*S.r+6*(-U+C)*b.r+(3*U-2*C)*z.r,v.g=6*(U-C)*q.g+(3*U-4*C+1)*S.g+6*(-U+C)*b.g+(3*U-2*C)*z.g,v.b=6*(U-C)*q.b+(3*U-4*C+1)*S.b+6*(-U+C)*b.b+(3*U-2*C)*z.b}static Red(){return new l(1,0,0)}static Green(){return new l(0,1,0)}static Blue(){return new l(0,0,1)}static Black(){return new l(0,0,0)}static get BlackReadOnly(){return l._BlackReadOnly}static White(){return new l(1,1,1)}static Purple(){return new l(.5,0,.5)}static Magenta(){return new l(1,0,1)}static Yellow(){return new l(1,1,0)}static Gray(){return new l(.5,.5,.5)}static Teal(){return new l(0,1,1)}static Random(){return new l(Math.random(),Math.random(),Math.random())}}l._V8PerformanceHack=new l(.5,.5,.5),l._BlackReadOnly=l.Black(),Object.defineProperties(l.prototype,{dimension:{value:[3]},rank:{value:1}});class y{constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=q,this.g=S,this.b=b,this.a=z}Zb(){return[this.r,this.g,this.b,this.a]}toArray(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q[S]=this.r,q[S+1]=this.g,q[S+2]=this.b,q[S+3]=this.a,this}Uz(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=q[S],this.g=q[S+1],this.b=q[S+2],this.a=q[S+3],this}equals(q){return q&&this.r===q.r&&this.g===q.g&&this.b===q.b&&this.a===q.a}add(q){return new y(this.r+q.r,this.g+q.g,this.b+q.b,this.a+q.a)}addToRef(q,S){return S.r=this.r+q.r,S.g=this.g+q.g,S.b=this.b+q.b,S.a=this.a+q.a,S}addInPlace(q){return this.r+=q.r,this.g+=q.g,this.b+=q.b,this.a+=q.a,this}addInPlaceFromFloats(q,S,b,z){return this.r+=q,this.g+=S,this.b+=b,this.a+=z,this}RS(q){return new y(this.r-q.r,this.g-q.g,this.b-q.b,this.a-q.a)}subtractToRef(q,S){return S.r=this.r-q.r,S.g=this.g-q.g,S.b=this.b-q.b,S.a=this.a-q.a,S}Ql(q){return this.r-=q.r,this.g-=q.g,this.b-=q.b,this.a-=q.a,this}subtractFromFloats(q,S,b,z){return new y(this.r-q,this.g-S,this.b-b,this.a-z)}subtractFromFloatsToRef(q,S,b,z,C){return C.r=this.r-q,C.g=this.g-S,C.b=this.b-b,C.a=this.a-z,C}scale(q){return new y(this.r*q,this.g*q,this.b*q,this.a*q)}scaleInPlace(q){return this.r*=q,this.g*=q,this.b*=q,this.a*=q,this}scaleToRef(q,S){return S.r=this.r*q,S.g=this.g*q,S.b=this.b*q,S.a=this.a*q,S}scaleAndAddToRef(q,S){return S.r+=this.r*q,S.g+=this.g*q,S.b+=this.b*q,S.a+=this.a*q,S}clampToRef(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,U.Clamp)(this.r,q,S),b.g=(0,U.Clamp)(this.g,q,S),b.b=(0,U.Clamp)(this.b,q,S),b.a=(0,U.Clamp)(this.a,q,S),b}multiply(q){return new y(this.r*q.r,this.g*q.g,this.b*q.b,this.a*q.a)}multiplyToRef(q,S){return S.r=this.r*q.r,S.g=this.g*q.g,S.b=this.b*q.b,S.a=this.a*q.a,S}multiplyInPlace(q){return this.r*=q.r,this.g*=q.g,this.b*=q.b,this.a*=q.a,this}multiplyByFloats(q,S,b,z){return new y(this.r*q,this.g*S,this.b*b,this.a*z)}divide(q){throw new ReferenceError("Can not divide a color")}divideToRef(q,S){throw new ReferenceError("Can not divide a color")}divideInPlace(q){throw new ReferenceError("Can not divide a color")}minimizeInPlace(q){return this.r=Math.min(this.r,q.r),this.g=Math.min(this.g,q.g),this.b=Math.min(this.b,q.b),this.a=Math.min(this.a,q.a),this}maximizeInPlace(q){return this.r=Math.max(this.r,q.r),this.g=Math.max(this.g,q.g),this.b=Math.max(this.b,q.b),this.a=Math.max(this.a,q.a),this}minimizeInPlaceFromFloats(q,S,b,z){return this.r=Math.min(q,this.r),this.g=Math.min(S,this.g),this.b=Math.min(b,this.b),this.a=Math.min(z,this.a),this}maximizeInPlaceFromFloats(q,S,b,z){return this.r=Math.max(q,this.r),this.g=Math.max(S,this.g),this.b=Math.max(b,this.b),this.a=Math.max(z,this.a),this}floorToRef(q){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(q){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(q){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:v.d;return(0,U.WithinEpsilon)(this.r,q.r,S)&&(0,U.WithinEpsilon)(this.g,q.g,S)&&(0,U.WithinEpsilon)(this.b,q.b,S)&&(0,U.WithinEpsilon)(this.a,q.a,S)}equalsToFloats(q,S,b,z){return this.r===q&&this.g===S&&this.b===b&&this.a===z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Jb"}getHashCode(){let q=255*this.r|0;return q=397*q^255*this.g,q=397*q^255*this.b,q=397*q^255*this.a,q}clone(){return(new y).v(this)}v(q){return this.r=q.r,this.g=q.g,this.b=q.b,this.a=q.a,this}Bb(q,S,b,z){return this.r=q,this.g=S,this.b=b,this.a=z,this}set(q,S,b,z){return this.Bb(q,S,b,z)}fb(q){return this.r=this.g=this.b=this.a=q,this}toHexString(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=Math.round(255*this.r),b=Math.round(255*this.g),z=Math.round(255*this.b);if(q)return"#"+(0,U.ToHex)(S)+(0,U.ToHex)(b)+(0,U.ToHex)(z);const C=Math.round(255*this.a);return"#"+(0,U.ToHex)(S)+(0,U.ToHex)(b)+(0,U.ToHex)(z)+(0,U.ToHex)(C)}fromHexString(q){return"#"!==q.substring(0,1)||9!==q.length&&7!==q.length||(this.r=parseInt(q.substring(1,3),16)/255,this.g=parseInt(q.substring(3,5),16)/255,this.b=parseInt(q.substring(5,7),16)/255,9===q.length&&(this.a=parseInt(q.substring(7,9),16)/255)),this}toLinearSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new y;return this.toLinearSpaceToRef(S,q),S}toLinearSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=r(this.r),q.g=r(this.g),q.b=r(this.b)):(q.r=g(this.r),q.g=g(this.g),q.b=g(this.b)),q.a=this.a,this}toGammaSpace(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new y;return this.toGammaSpaceToRef(S,q),S}toGammaSpaceToRef(q){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(q.r=V(this.r),q.g=V(this.g),q.b=V(this.b)):(q.r=I(this.r),q.g=I(this.g),q.b=I(this.b)),q.a=this.a,this}static FromHexString(q){return"#"!==q.substring(0,1)||9!==q.length&&7!==q.length?new y(0,0,0,0):new y(0,0,0,1).fromHexString(q)}static Lerp(q,S,b){return y.LerpToRef(q,S,b,new y)}static LerpToRef(q,S,b,z){return z.r=q.r+(S.r-q.r)*b,z.g=q.g+(S.g-q.g)*b,z.b=q.b+(S.b-q.b)*b,z.a=q.a+(S.a-q.a)*b,z}static Hermite(q,S,b,z,C){const v=C*C,U=C*v,g=2*U-3*v+1,r=-2*U+3*v,I=U-2*v+C,V=U-v,l=q.r*g+b.r*r+S.r*I+z.r*V,R=q.g*g+b.g*r+S.g*I+z.g*V,G=q.b*g+b.b*r+S.b*I+z.b*V,Z=q.a*g+b.a*r+S.a*I+z.a*V;return new y(l,R,G,Z)}static Hermite1stDerivative(q,S,b,z,C){const v=new y;return this.Hermite1stDerivativeToRef(q,S,b,z,C,v),v}static Hermite1stDerivativeToRef(q,S,b,z,C,v){const U=C*C;v.r=6*(U-C)*q.r+(3*U-4*C+1)*S.r+6*(-U+C)*b.r+(3*U-2*C)*z.r,v.g=6*(U-C)*q.g+(3*U-4*C+1)*S.g+6*(-U+C)*b.g+(3*U-2*C)*z.g,v.b=6*(U-C)*q.b+(3*U-4*C+1)*S.b+6*(-U+C)*b.b+(3*U-2*C)*z.b,v.a=6*(U-C)*q.a+(3*U-4*C+1)*S.a+6*(-U+C)*b.a+(3*U-2*C)*z.a}static FromColor3(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y(q.r,q.g,q.b,S)}static Hb(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(q[S],q[S+1],q[S+2],q[S+3])}static FromArrayToRef(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=q[S],b.g=q[S+1],b.b=q[S+2],b.a=q[S+3]}static FromInts(q,S,b,z){return new y(q/255,S/255,b/255,z/255)}static CheckColors4(q,S){if(q.length===3*S){const S=[];for(let b=0;b<q.length;b+=3){const z=b/3*4;S[z]=q[b],S[z+1]=q[b+1],S[z+2]=q[b+2],S[z+3]=1}return S}return q}}y._V8PerformanceHack=new y(.5,.5,.5,.5),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class R{}R.HS=(0,z.e)(3,l.Black),R.Jb=(0,z.e)(3,(()=>new y(0,0,0,0))),(0,C.f)("BABYLON.Color3",l),(0,C.f)("BABYLON.Color4",y)}}]);