"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[17],{11224:(R,J,B)=>{B.r(J),B.d(J,{SJ:()=>l,ar:()=>E,TmpColors:()=>O});var Q=B(11193),h=B(11142),y=B(11189),N=B(11201);function r(R){return Math.pow(R,y.i)}function q(R){return R<=.04045?.0773993808*R:Math.pow(.947867299*(R+.055),2.4)}function e(R){return Math.pow(R,y.f)}function D(R){return R<=.0031308?12.92*R:1.055*Math.pow(R,.41666)-.055}class l{constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=R,this.g=J,this.b=B}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"SJ"}getHashCode(){let R=255*this.r|0;return R=397*R^255*this.g,R=397*R^255*this.b,R}toArray(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R[J]=this.r,R[J+1]=this.g,R[J+2]=this.b,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(R,J,this),this}toColor4(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new E(this.r,this.g,this.b,R)}Ch(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(R){return new l(this.r*R.r,this.g*R.g,this.b*R.b)}multiplyToRef(R,J){return J.r=this.r*R.r,J.g=this.g*R.g,J.b=this.b*R.b,J}multiplyInPlace(R){return this.r*=R.r,this.g*=R.g,this.b*=R.b,this}multiplyByFloats(R,J,B){return new l(this.r*R,this.g*J,this.b*B)}divide(R){throw new ReferenceError("Can not divide a color")}divideToRef(R,J){throw new ReferenceError("Can not divide a color")}divideInPlace(R){throw new ReferenceError("Can not divide a color")}minimizeInPlace(R){return this.minimizeInPlaceFromFloats(R.r,R.g,R.b)}maximizeInPlace(R){return this.maximizeInPlaceFromFloats(R.r,R.g,R.b)}minimizeInPlaceFromFloats(R,J,B){return this.r=Math.min(R,this.r),this.g=Math.min(J,this.g),this.b=Math.min(B,this.b),this}maximizeInPlaceFromFloats(R,J,B){return this.r=Math.max(R,this.r),this.g=Math.max(J,this.g),this.b=Math.max(B,this.b),this}floorToRef(R){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(R){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(R){return R&&this.r===R.r&&this.g===R.g&&this.b===R.b}equalsFloats(R,J,B){return this.equalsToFloats(R,J,B)}equalsToFloats(R,J,B){return this.r===R&&this.g===J&&this.b===B}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:y.d;return(0,N.WithinEpsilon)(this.r,R.r,J)&&(0,N.WithinEpsilon)(this.g,R.g,J)&&(0,N.WithinEpsilon)(this.b,R.b,J)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(R){throw new ReferenceError("Can not negate a color")}scale(R){return new l(this.r*R,this.g*R,this.b*R)}scaleInPlace(R){return this.r*=R,this.g*=R,this.b*=R,this}scaleToRef(R,J){return J.r=this.r*R,J.g=this.g*R,J.b=this.b*R,J}scaleAndAddToRef(R,J){return J.r+=this.r*R,J.g+=this.g*R,J.b+=this.b*R,J}clampToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,B=arguments.length>2?arguments[2]:void 0;return B.r=(0,N.Clamp)(this.r,R,J),B.g=(0,N.Clamp)(this.g,R,J),B.b=(0,N.Clamp)(this.b,R,J),B}add(R){return new l(this.r+R.r,this.g+R.g,this.b+R.b)}addInPlace(R){return this.r+=R.r,this.g+=R.g,this.b+=R.b,this}addInPlaceFromFloats(R,J,B){return this.r+=R,this.g+=J,this.b+=B,this}addToRef(R,J){return J.r=this.r+R.r,J.g=this.g+R.g,J.b=this.b+R.b,J}PJ(R){return new l(this.r-R.r,this.g-R.g,this.b-R.b)}subtractToRef(R,J){return J.r=this.r-R.r,J.g=this.g-R.g,J.b=this.b-R.b,J}ul(R){return this.r-=R.r,this.g-=R.g,this.b-=R.b,this}subtractFromFloats(R,J,B){return new l(this.r-R,this.g-J,this.b-B)}subtractFromFloatsToRef(R,J,B,Q){return Q.r=this.r-R,Q.g=this.g-J,Q.b=this.b-B,Q}clone(){return new l(this.r,this.g,this.b)}h(R){return this.r=R.r,this.g=R.g,this.b=R.b,this}Ar(R,J,B){return this.r=R,this.g=J,this.b=B,this}set(R,J,B){return this.Ar(R,J,B)}Sr(R){return this.r=this.g=this.b=R,this}toHexString(){const R=Math.round(255*this.r),J=Math.round(255*this.g),B=Math.round(255*this.b);return"#"+(0,N.ToHex)(R)+(0,N.ToHex)(J)+(0,N.ToHex)(B)}fromHexString(R){return"#"!==R.substring(0,1)||7!==R.length||(this.r=parseInt(R.substring(1,3),16)/255,this.g=parseInt(R.substring(3,5),16)/255,this.b=parseInt(R.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new l)}toHSVToRef(R){const J=this.r,B=this.g,Q=this.b,h=Math.max(J,B,Q),y=Math.min(J,B,Q);let N=0,r=0;const q=h,e=h-y;return 0!==h&&(r=e/h),h!=y&&(h==J?(N=(B-Q)/e,B<Q&&(N+=6)):h==B?N=(Q-J)/e+2:h==Q&&(N=(J-B)/e+4),N*=60),R.r=N,R.g=r,R.b=q,R}toLinearSpace(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=new l;return this.toLinearSpaceToRef(J,R),J}toLinearSpaceToRef(R){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(R.r=q(this.r),R.g=q(this.g),R.b=q(this.b)):(R.r=r(this.r),R.g=r(this.g),R.b=r(this.b)),this}toGammaSpace(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=new l;return this.toGammaSpaceToRef(J,R),J}toGammaSpaceToRef(R){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(R.r=D(this.r),R.g=D(this.g),R.b=D(this.b)):(R.r=e(this.r),R.g=e(this.g),R.b=e(this.b)),this}static HSVtoRGBToRef(R,J,B,Q){const h=B*J,y=R/60,N=h*(1-Math.abs(y%2-1));let r=0,q=0,e=0;y>=0&&y<=1?(r=h,q=N):y>=1&&y<=2?(r=N,q=h):y>=2&&y<=3?(q=h,e=N):y>=3&&y<=4?(q=N,e=h):y>=4&&y<=5?(r=N,e=h):y>=5&&y<=6&&(r=h,e=N);const D=B-h;return Q.r=r+D,Q.g=q+D,Q.b=e+D,Q}static FromHSV(R,J,B){const Q=new l(0,0,0);return l.HSVtoRGBToRef(R,J,B,Q),Q}static FromHexString(R){return new l(0,0,0).fromHexString(R)}static fJ(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(R[J],R[J+1],R[J+2])}static FromArrayToRef(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2?arguments[2]:void 0;B.r=R[J],B.g=R[J+1],B.b=R[J+2]}static FromInts(R,J,B){return new l(R/255,J/255,B/255)}static Lerp(R,J,B){const Q=new l(0,0,0);return l.LerpToRef(R,J,B,Q),Q}static LerpToRef(R,J,B,Q){Q.r=R.r+(J.r-R.r)*B,Q.g=R.g+(J.g-R.g)*B,Q.b=R.b+(J.b-R.b)*B}static Hermite(R,J,B,Q,h){const y=h*h,N=h*y,r=2*N-3*y+1,q=-2*N+3*y,e=N-2*y+h,D=N-y,E=R.r*r+B.r*q+J.r*e+Q.r*D,O=R.g*r+B.g*q+J.g*e+Q.g*D,n=R.b*r+B.b*q+J.b*e+Q.b*D;return new l(E,O,n)}static Hermite1stDerivative(R,J,B,Q,h){const y=l.Black();return this.Hermite1stDerivativeToRef(R,J,B,Q,h,y),y}static Hermite1stDerivativeToRef(R,J,B,Q,h,y){const N=h*h;y.r=6*(N-h)*R.r+(3*N-4*h+1)*J.r+6*(-N+h)*B.r+(3*N-2*h)*Q.r,y.g=6*(N-h)*R.g+(3*N-4*h+1)*J.g+6*(-N+h)*B.g+(3*N-2*h)*Q.g,y.b=6*(N-h)*R.b+(3*N-4*h+1)*J.b+6*(-N+h)*B.b+(3*N-2*h)*Q.b}static Red(){return new l(1,0,0)}static Green(){return new l(0,1,0)}static Blue(){return new l(0,0,1)}static Black(){return new l(0,0,0)}static get BlackReadOnly(){return l._BlackReadOnly}static White(){return new l(1,1,1)}static Purple(){return new l(.5,0,.5)}static Magenta(){return new l(1,0,1)}static Yellow(){return new l(1,1,0)}static Gray(){return new l(.5,.5,.5)}static Teal(){return new l(0,1,1)}static Random(){return new l(Math.random(),Math.random(),Math.random())}}l._V8PerformanceHack=new l(.5,.5,.5),l._BlackReadOnly=l.Black(),Object.defineProperties(l.prototype,{dimension:{value:[3]},rank:{value:1}});class E{constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=R,this.g=J,this.b=B,this.a=Q}Ch(){return[this.r,this.g,this.b,this.a]}toArray(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return R[J]=this.r,R[J+1]=this.g,R[J+2]=this.b,R[J+3]=this.a,this}EB(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=R[J],this.g=R[J+1],this.b=R[J+2],this.a=R[J+3],this}equals(R){return R&&this.r===R.r&&this.g===R.g&&this.b===R.b&&this.a===R.a}add(R){return new E(this.r+R.r,this.g+R.g,this.b+R.b,this.a+R.a)}addToRef(R,J){return J.r=this.r+R.r,J.g=this.g+R.g,J.b=this.b+R.b,J.a=this.a+R.a,J}addInPlace(R){return this.r+=R.r,this.g+=R.g,this.b+=R.b,this.a+=R.a,this}addInPlaceFromFloats(R,J,B,Q){return this.r+=R,this.g+=J,this.b+=B,this.a+=Q,this}PJ(R){return new E(this.r-R.r,this.g-R.g,this.b-R.b,this.a-R.a)}subtractToRef(R,J){return J.r=this.r-R.r,J.g=this.g-R.g,J.b=this.b-R.b,J.a=this.a-R.a,J}ul(R){return this.r-=R.r,this.g-=R.g,this.b-=R.b,this.a-=R.a,this}subtractFromFloats(R,J,B,Q){return new E(this.r-R,this.g-J,this.b-B,this.a-Q)}subtractFromFloatsToRef(R,J,B,Q,h){return h.r=this.r-R,h.g=this.g-J,h.b=this.b-B,h.a=this.a-Q,h}scale(R){return new E(this.r*R,this.g*R,this.b*R,this.a*R)}scaleInPlace(R){return this.r*=R,this.g*=R,this.b*=R,this.a*=R,this}scaleToRef(R,J){return J.r=this.r*R,J.g=this.g*R,J.b=this.b*R,J.a=this.a*R,J}scaleAndAddToRef(R,J){return J.r+=this.r*R,J.g+=this.g*R,J.b+=this.b*R,J.a+=this.a*R,J}clampToRef(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,B=arguments.length>2?arguments[2]:void 0;return B.r=(0,N.Clamp)(this.r,R,J),B.g=(0,N.Clamp)(this.g,R,J),B.b=(0,N.Clamp)(this.b,R,J),B.a=(0,N.Clamp)(this.a,R,J),B}multiply(R){return new E(this.r*R.r,this.g*R.g,this.b*R.b,this.a*R.a)}multiplyToRef(R,J){return J.r=this.r*R.r,J.g=this.g*R.g,J.b=this.b*R.b,J.a=this.a*R.a,J}multiplyInPlace(R){return this.r*=R.r,this.g*=R.g,this.b*=R.b,this.a*=R.a,this}multiplyByFloats(R,J,B,Q){return new E(this.r*R,this.g*J,this.b*B,this.a*Q)}divide(R){throw new ReferenceError("Can not divide a color")}divideToRef(R,J){throw new ReferenceError("Can not divide a color")}divideInPlace(R){throw new ReferenceError("Can not divide a color")}minimizeInPlace(R){return this.r=Math.min(this.r,R.r),this.g=Math.min(this.g,R.g),this.b=Math.min(this.b,R.b),this.a=Math.min(this.a,R.a),this}maximizeInPlace(R){return this.r=Math.max(this.r,R.r),this.g=Math.max(this.g,R.g),this.b=Math.max(this.b,R.b),this.a=Math.max(this.a,R.a),this}minimizeInPlaceFromFloats(R,J,B,Q){return this.r=Math.min(R,this.r),this.g=Math.min(J,this.g),this.b=Math.min(B,this.b),this.a=Math.min(Q,this.a),this}maximizeInPlaceFromFloats(R,J,B,Q){return this.r=Math.max(R,this.r),this.g=Math.max(J,this.g),this.b=Math.max(B,this.b),this.a=Math.max(Q,this.a),this}floorToRef(R){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(R){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(R){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:y.d;return(0,N.WithinEpsilon)(this.r,R.r,J)&&(0,N.WithinEpsilon)(this.g,R.g,J)&&(0,N.WithinEpsilon)(this.b,R.b,J)&&(0,N.WithinEpsilon)(this.a,R.a,J)}equalsToFloats(R,J,B,Q){return this.r===R&&this.g===J&&this.b===B&&this.a===Q}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ar"}getHashCode(){let R=255*this.r|0;return R=397*R^255*this.g,R=397*R^255*this.b,R=397*R^255*this.a,R}clone(){return(new E).h(this)}h(R){return this.r=R.r,this.g=R.g,this.b=R.b,this.a=R.a,this}Ar(R,J,B,Q){return this.r=R,this.g=J,this.b=B,this.a=Q,this}set(R,J,B,Q){return this.Ar(R,J,B,Q)}Sr(R){return this.r=this.g=this.b=this.a=R,this}toHexString(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=Math.round(255*this.r),B=Math.round(255*this.g),Q=Math.round(255*this.b);if(R)return"#"+(0,N.ToHex)(J)+(0,N.ToHex)(B)+(0,N.ToHex)(Q);const h=Math.round(255*this.a);return"#"+(0,N.ToHex)(J)+(0,N.ToHex)(B)+(0,N.ToHex)(Q)+(0,N.ToHex)(h)}fromHexString(R){return"#"!==R.substring(0,1)||9!==R.length&&7!==R.length||(this.r=parseInt(R.substring(1,3),16)/255,this.g=parseInt(R.substring(3,5),16)/255,this.b=parseInt(R.substring(5,7),16)/255,9===R.length&&(this.a=parseInt(R.substring(7,9),16)/255)),this}toLinearSpace(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=new E;return this.toLinearSpaceToRef(J,R),J}toLinearSpaceToRef(R){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(R.r=q(this.r),R.g=q(this.g),R.b=q(this.b)):(R.r=r(this.r),R.g=r(this.g),R.b=r(this.b)),R.a=this.a,this}toGammaSpace(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const J=new E;return this.toGammaSpaceToRef(J,R),J}toGammaSpaceToRef(R){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(R.r=D(this.r),R.g=D(this.g),R.b=D(this.b)):(R.r=e(this.r),R.g=e(this.g),R.b=e(this.b)),R.a=this.a,this}static FromHexString(R){return"#"!==R.substring(0,1)||9!==R.length&&7!==R.length?new E(0,0,0,0):new E(0,0,0,1).fromHexString(R)}static Lerp(R,J,B){return E.LerpToRef(R,J,B,new E)}static LerpToRef(R,J,B,Q){return Q.r=R.r+(J.r-R.r)*B,Q.g=R.g+(J.g-R.g)*B,Q.b=R.b+(J.b-R.b)*B,Q.a=R.a+(J.a-R.a)*B,Q}static Hermite(R,J,B,Q,h){const y=h*h,N=h*y,r=2*N-3*y+1,q=-2*N+3*y,e=N-2*y+h,D=N-y,l=R.r*r+B.r*q+J.r*e+Q.r*D,O=R.g*r+B.g*q+J.g*e+Q.g*D,n=R.b*r+B.b*q+J.b*e+Q.b*D,P=R.a*r+B.a*q+J.a*e+Q.a*D;return new E(l,O,n,P)}static Hermite1stDerivative(R,J,B,Q,h){const y=new E;return this.Hermite1stDerivativeToRef(R,J,B,Q,h,y),y}static Hermite1stDerivativeToRef(R,J,B,Q,h,y){const N=h*h;y.r=6*(N-h)*R.r+(3*N-4*h+1)*J.r+6*(-N+h)*B.r+(3*N-2*h)*Q.r,y.g=6*(N-h)*R.g+(3*N-4*h+1)*J.g+6*(-N+h)*B.g+(3*N-2*h)*Q.g,y.b=6*(N-h)*R.b+(3*N-4*h+1)*J.b+6*(-N+h)*B.b+(3*N-2*h)*Q.b,y.a=6*(N-h)*R.a+(3*N-4*h+1)*J.a+6*(-N+h)*B.a+(3*N-2*h)*Q.a}static FromColor3(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new E(R.r,R.g,R.b,J)}static fJ(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new E(R[J],R[J+1],R[J+2],R[J+3])}static FromArrayToRef(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2?arguments[2]:void 0;B.r=R[J],B.g=R[J+1],B.b=R[J+2],B.a=R[J+3]}static FromInts(R,J,B,Q){return new E(R/255,J/255,B/255,Q/255)}static CheckColors4(R,J){if(R.length===3*J){const J=[];for(let B=0;B<R.length;B+=3){const Q=B/3*4;J[Q]=R[B],J[Q+1]=R[B+1],J[Q+2]=R[B+2],J[Q+3]=1}return J}return R}}E._V8PerformanceHack=new E(.5,.5,.5,.5),Object.defineProperties(E.prototype,{dimension:{value:[4]},rank:{value:1}});class O{}O.SJ=(0,Q.e)(3,l.Black),O.ar=(0,Q.e)(3,(()=>new E(0,0,0,0))),(0,h.h)("BABYLON.Color3",l),(0,h.h)("BABYLON.Color4",E)}}]);