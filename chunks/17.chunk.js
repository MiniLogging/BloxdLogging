"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[17],{12436:(a,O,i)=>{i.r(O),i.d(O,{mi:()=>e,Ab:()=>h,TmpColors:()=>j});var H=i(12403),b=i(12346),G=i(12397),q=i(12412);function Q(a){return Math.pow(a,G.i)}function k(a){return a<=.04045?.0773993808*a:Math.pow(.947867299*(a+.055),2.4)}function I(a){return Math.pow(a,G.g)}function P(a){return a<=.0031308?12.92*a:1.055*Math.pow(a,.41666)-.055}class e{constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=a,this.g=O,this.b=i}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"mi"}getHashCode(){let a=255*this.r|0;return a=397*a^255*this.g,a=397*a^255*this.b,a}toArray(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a[O]=this.r,a[O+1]=this.g,a[O+2]=this.b,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e.FromArrayToRef(a,O,this),this}toColor4(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new h(this.r,this.g,this.b,a)}Cb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(a){return new e(this.r*a.r,this.g*a.g,this.b*a.b)}multiplyToRef(a,O){return O.r=this.r*a.r,O.g=this.g*a.g,O.b=this.b*a.b,O}multiplyInPlace(a){return this.r*=a.r,this.g*=a.g,this.b*=a.b,this}multiplyByFloats(a,O,i){return new e(this.r*a,this.g*O,this.b*i)}divide(a){throw new ReferenceError("Can not divide a color")}divideToRef(a,O){throw new ReferenceError("Can not divide a color")}divideInPlace(a){throw new ReferenceError("Can not divide a color")}minimizeInPlace(a){return this.minimizeInPlaceFromFloats(a.r,a.g,a.b)}maximizeInPlace(a){return this.maximizeInPlaceFromFloats(a.r,a.g,a.b)}minimizeInPlaceFromFloats(a,O,i){return this.r=Math.min(a,this.r),this.g=Math.min(O,this.g),this.b=Math.min(i,this.b),this}maximizeInPlaceFromFloats(a,O,i){return this.r=Math.max(a,this.r),this.g=Math.max(O,this.g),this.b=Math.max(i,this.b),this}floorToRef(a){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(a){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b}equalsFloats(a,O,i){return this.equalsToFloats(a,O,i)}equalsToFloats(a,O,i){return this.r===a&&this.g===O&&this.b===i}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.e;return(0,q.WithinEpsilon)(this.r,a.r,O)&&(0,q.WithinEpsilon)(this.g,a.g,O)&&(0,q.WithinEpsilon)(this.b,a.b,O)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(a){throw new ReferenceError("Can not negate a color")}scale(a){return new e(this.r*a,this.g*a,this.b*a)}scaleInPlace(a){return this.r*=a,this.g*=a,this.b*=a,this}scaleToRef(a,O){return O.r=this.r*a,O.g=this.g*a,O.b=this.b*a,O}scaleAndAddToRef(a,O){return O.r+=this.r*a,O.g+=this.g*a,O.b+=this.b*a,O}clampToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,q.Clamp)(this.r,a,O),i.g=(0,q.Clamp)(this.g,a,O),i.b=(0,q.Clamp)(this.b,a,O),i}add(a){return new e(this.r+a.r,this.g+a.g,this.b+a.b)}addInPlace(a){return this.r+=a.r,this.g+=a.g,this.b+=a.b,this}addInPlaceFromFloats(a,O,i){return this.r+=a,this.g+=O,this.b+=i,this}addToRef(a,O){return O.r=this.r+a.r,O.g=this.g+a.g,O.b=this.b+a.b,O}FO(a){return new e(this.r-a.r,this.g-a.g,this.b-a.b)}subtractToRef(a,O){return O.r=this.r-a.r,O.g=this.g-a.g,O.b=this.b-a.b,O}ne(a){return this.r-=a.r,this.g-=a.g,this.b-=a.b,this}subtractFromFloats(a,O,i){return new e(this.r-a,this.g-O,this.b-i)}subtractFromFloatsToRef(a,O,i,H){return H.r=this.r-a,H.g=this.g-O,H.b=this.b-i,H}clone(){return new e(this.r,this.g,this.b)}q(a){return this.r=a.r,this.g=a.g,this.b=a.b,this}fb(a,O,i){return this.r=a,this.g=O,this.b=i,this}set(a,O,i){return this.fb(a,O,i)}Tb(a){return this.r=this.g=this.b=a,this}toHexString(){const a=Math.round(255*this.r),O=Math.round(255*this.g),i=Math.round(255*this.b);return"#"+(0,q.ToHex)(a)+(0,q.ToHex)(O)+(0,q.ToHex)(i)}fromHexString(a){return"#"!==a.substring(0,1)||7!==a.length||(this.r=parseInt(a.substring(1,3),16)/255,this.g=parseInt(a.substring(3,5),16)/255,this.b=parseInt(a.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new e)}toHSVToRef(a){const O=this.r,i=this.g,H=this.b,b=Math.max(O,i,H),G=Math.min(O,i,H);let q=0,Q=0;const k=b,I=b-G;return 0!==b&&(Q=I/b),b!=G&&(b==O?(q=(i-H)/I,i<H&&(q+=6)):b==i?q=(H-O)/I+2:b==H&&(q=(O-i)/I+4),q*=60),a.r=q,a.g=Q,a.b=k,a}toLinearSpace(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new e;return this.toLinearSpaceToRef(O,a),O}toLinearSpaceToRef(a){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(a.r=k(this.r),a.g=k(this.g),a.b=k(this.b)):(a.r=Q(this.r),a.g=Q(this.g),a.b=Q(this.b)),this}toGammaSpace(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new e;return this.toGammaSpaceToRef(O,a),O}toGammaSpaceToRef(a){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(a.r=P(this.r),a.g=P(this.g),a.b=P(this.b)):(a.r=I(this.r),a.g=I(this.g),a.b=I(this.b)),this}static HSVtoRGBToRef(a,O,i,H){const b=i*O,G=a/60,q=b*(1-Math.abs(G%2-1));let Q=0,k=0,I=0;G>=0&&G<=1?(Q=b,k=q):G>=1&&G<=2?(Q=q,k=b):G>=2&&G<=3?(k=b,I=q):G>=3&&G<=4?(k=q,I=b):G>=4&&G<=5?(Q=q,I=b):G>=5&&G<=6&&(Q=b,I=q);const P=i-b;return H.r=Q+P,H.g=k+P,H.b=I+P,H}static FromHSV(a,O,i){const H=new e(0,0,0);return e.HSVtoRGBToRef(a,O,i,H),H}static FromHexString(a){return new e(0,0,0).fromHexString(a)}static MO(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(a[O],a[O+1],a[O+2])}static FromArrayToRef(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=a[O],i.g=a[O+1],i.b=a[O+2]}static FromInts(a,O,i){return new e(a/255,O/255,i/255)}static Lerp(a,O,i){const H=new e(0,0,0);return e.LerpToRef(a,O,i,H),H}static LerpToRef(a,O,i,H){H.r=a.r+(O.r-a.r)*i,H.g=a.g+(O.g-a.g)*i,H.b=a.b+(O.b-a.b)*i}static Hermite(a,O,i,H,b){const G=b*b,q=b*G,Q=2*q-3*G+1,k=-2*q+3*G,I=q-2*G+b,P=q-G,h=a.r*Q+i.r*k+O.r*I+H.r*P,j=a.g*Q+i.g*k+O.g*I+H.g*P,Z=a.b*Q+i.b*k+O.b*I+H.b*P;return new e(h,j,Z)}static Hermite1stDerivative(a,O,i,H,b){const G=e.Black();return this.Hermite1stDerivativeToRef(a,O,i,H,b,G),G}static Hermite1stDerivativeToRef(a,O,i,H,b,G){const q=b*b;G.r=6*(q-b)*a.r+(3*q-4*b+1)*O.r+6*(-q+b)*i.r+(3*q-2*b)*H.r,G.g=6*(q-b)*a.g+(3*q-4*b+1)*O.g+6*(-q+b)*i.g+(3*q-2*b)*H.g,G.b=6*(q-b)*a.b+(3*q-4*b+1)*O.b+6*(-q+b)*i.b+(3*q-2*b)*H.b}static Red(){return new e(1,0,0)}static Green(){return new e(0,1,0)}static Blue(){return new e(0,0,1)}static Black(){return new e(0,0,0)}static get BlackReadOnly(){return e._BlackReadOnly}static White(){return new e(1,1,1)}static Purple(){return new e(.5,0,.5)}static Magenta(){return new e(1,0,1)}static Yellow(){return new e(1,1,0)}static Gray(){return new e(.5,.5,.5)}static Teal(){return new e(0,1,1)}static Random(){return new e(Math.random(),Math.random(),Math.random())}}e._V8PerformanceHack=new e(.5,.5,.5),e._BlackReadOnly=e.Black(),Object.defineProperties(e.prototype,{dimension:{value:[3]},rank:{value:1}});class h{constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=a,this.g=O,this.b=i,this.a=H}Cb(){return[this.r,this.g,this.b,this.a]}toArray(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return a[O]=this.r,a[O+1]=this.g,a[O+2]=this.b,a[O+3]=this.a,this}hi(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=a[O],this.g=a[O+1],this.b=a[O+2],this.a=a[O+3],this}equals(a){return a&&this.r===a.r&&this.g===a.g&&this.b===a.b&&this.a===a.a}add(a){return new h(this.r+a.r,this.g+a.g,this.b+a.b,this.a+a.a)}addToRef(a,O){return O.r=this.r+a.r,O.g=this.g+a.g,O.b=this.b+a.b,O.a=this.a+a.a,O}addInPlace(a){return this.r+=a.r,this.g+=a.g,this.b+=a.b,this.a+=a.a,this}addInPlaceFromFloats(a,O,i,H){return this.r+=a,this.g+=O,this.b+=i,this.a+=H,this}FO(a){return new h(this.r-a.r,this.g-a.g,this.b-a.b,this.a-a.a)}subtractToRef(a,O){return O.r=this.r-a.r,O.g=this.g-a.g,O.b=this.b-a.b,O.a=this.a-a.a,O}ne(a){return this.r-=a.r,this.g-=a.g,this.b-=a.b,this.a-=a.a,this}subtractFromFloats(a,O,i,H){return new h(this.r-a,this.g-O,this.b-i,this.a-H)}subtractFromFloatsToRef(a,O,i,H,b){return b.r=this.r-a,b.g=this.g-O,b.b=this.b-i,b.a=this.a-H,b}scale(a){return new h(this.r*a,this.g*a,this.b*a,this.a*a)}scaleInPlace(a){return this.r*=a,this.g*=a,this.b*=a,this.a*=a,this}scaleToRef(a,O){return O.r=this.r*a,O.g=this.g*a,O.b=this.b*a,O.a=this.a*a,O}scaleAndAddToRef(a,O){return O.r+=this.r*a,O.g+=this.g*a,O.b+=this.b*a,O.a+=this.a*a,O}clampToRef(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,q.Clamp)(this.r,a,O),i.g=(0,q.Clamp)(this.g,a,O),i.b=(0,q.Clamp)(this.b,a,O),i.a=(0,q.Clamp)(this.a,a,O),i}multiply(a){return new h(this.r*a.r,this.g*a.g,this.b*a.b,this.a*a.a)}multiplyToRef(a,O){return O.r=this.r*a.r,O.g=this.g*a.g,O.b=this.b*a.b,O.a=this.a*a.a,O}multiplyInPlace(a){return this.r*=a.r,this.g*=a.g,this.b*=a.b,this.a*=a.a,this}multiplyByFloats(a,O,i,H){return new h(this.r*a,this.g*O,this.b*i,this.a*H)}divide(a){throw new ReferenceError("Can not divide a color")}divideToRef(a,O){throw new ReferenceError("Can not divide a color")}divideInPlace(a){throw new ReferenceError("Can not divide a color")}minimizeInPlace(a){return this.r=Math.min(this.r,a.r),this.g=Math.min(this.g,a.g),this.b=Math.min(this.b,a.b),this.a=Math.min(this.a,a.a),this}maximizeInPlace(a){return this.r=Math.max(this.r,a.r),this.g=Math.max(this.g,a.g),this.b=Math.max(this.b,a.b),this.a=Math.max(this.a,a.a),this}minimizeInPlaceFromFloats(a,O,i,H){return this.r=Math.min(a,this.r),this.g=Math.min(O,this.g),this.b=Math.min(i,this.b),this.a=Math.min(H,this.a),this}maximizeInPlaceFromFloats(a,O,i,H){return this.r=Math.max(a,this.r),this.g=Math.max(O,this.g),this.b=Math.max(i,this.b),this.a=Math.max(H,this.a),this}floorToRef(a){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(a){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(a){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.e;return(0,q.WithinEpsilon)(this.r,a.r,O)&&(0,q.WithinEpsilon)(this.g,a.g,O)&&(0,q.WithinEpsilon)(this.b,a.b,O)&&(0,q.WithinEpsilon)(this.a,a.a,O)}equalsToFloats(a,O,i,H){return this.r===a&&this.g===O&&this.b===i&&this.a===H}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Ab"}getHashCode(){let a=255*this.r|0;return a=397*a^255*this.g,a=397*a^255*this.b,a=397*a^255*this.a,a}clone(){return(new h).q(this)}q(a){return this.r=a.r,this.g=a.g,this.b=a.b,this.a=a.a,this}fb(a,O,i,H){return this.r=a,this.g=O,this.b=i,this.a=H,this}set(a,O,i,H){return this.fb(a,O,i,H)}Tb(a){return this.r=this.g=this.b=this.a=a,this}toHexString(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=Math.round(255*this.r),i=Math.round(255*this.g),H=Math.round(255*this.b);if(a)return"#"+(0,q.ToHex)(O)+(0,q.ToHex)(i)+(0,q.ToHex)(H);const b=Math.round(255*this.a);return"#"+(0,q.ToHex)(O)+(0,q.ToHex)(i)+(0,q.ToHex)(H)+(0,q.ToHex)(b)}fromHexString(a){return"#"!==a.substring(0,1)||9!==a.length&&7!==a.length||(this.r=parseInt(a.substring(1,3),16)/255,this.g=parseInt(a.substring(3,5),16)/255,this.b=parseInt(a.substring(5,7),16)/255,9===a.length&&(this.a=parseInt(a.substring(7,9),16)/255)),this}toLinearSpace(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new h;return this.toLinearSpaceToRef(O,a),O}toLinearSpaceToRef(a){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(a.r=k(this.r),a.g=k(this.g),a.b=k(this.b)):(a.r=Q(this.r),a.g=Q(this.g),a.b=Q(this.b)),a.a=this.a,this}toGammaSpace(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new h;return this.toGammaSpaceToRef(O,a),O}toGammaSpaceToRef(a){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(a.r=P(this.r),a.g=P(this.g),a.b=P(this.b)):(a.r=I(this.r),a.g=I(this.g),a.b=I(this.b)),a.a=this.a,this}static FromHexString(a){return"#"!==a.substring(0,1)||9!==a.length&&7!==a.length?new h(0,0,0,0):new h(0,0,0,1).fromHexString(a)}static Lerp(a,O,i){return h.LerpToRef(a,O,i,new h)}static LerpToRef(a,O,i,H){return H.r=a.r+(O.r-a.r)*i,H.g=a.g+(O.g-a.g)*i,H.b=a.b+(O.b-a.b)*i,H.a=a.a+(O.a-a.a)*i,H}static Hermite(a,O,i,H,b){const G=b*b,q=b*G,Q=2*q-3*G+1,k=-2*q+3*G,I=q-2*G+b,P=q-G,e=a.r*Q+i.r*k+O.r*I+H.r*P,j=a.g*Q+i.g*k+O.g*I+H.g*P,Z=a.b*Q+i.b*k+O.b*I+H.b*P,F=a.a*Q+i.a*k+O.a*I+H.a*P;return new h(e,j,Z,F)}static Hermite1stDerivative(a,O,i,H,b){const G=new h;return this.Hermite1stDerivativeToRef(a,O,i,H,b,G),G}static Hermite1stDerivativeToRef(a,O,i,H,b,G){const q=b*b;G.r=6*(q-b)*a.r+(3*q-4*b+1)*O.r+6*(-q+b)*i.r+(3*q-2*b)*H.r,G.g=6*(q-b)*a.g+(3*q-4*b+1)*O.g+6*(-q+b)*i.g+(3*q-2*b)*H.g,G.b=6*(q-b)*a.b+(3*q-4*b+1)*O.b+6*(-q+b)*i.b+(3*q-2*b)*H.b,G.a=6*(q-b)*a.a+(3*q-4*b+1)*O.a+6*(-q+b)*i.a+(3*q-2*b)*H.a}static FromColor3(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new h(a.r,a.g,a.b,O)}static MO(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(a[O],a[O+1],a[O+2],a[O+3])}static FromArrayToRef(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=a[O],i.g=a[O+1],i.b=a[O+2],i.a=a[O+3]}static FromInts(a,O,i,H){return new h(a/255,O/255,i/255,H/255)}static CheckColors4(a,O){if(a.length===3*O){const O=[];for(let i=0;i<a.length;i+=3){const H=i/3*4;O[H]=a[i],O[H+1]=a[i+1],O[H+2]=a[i+2],O[H+3]=1}return O}return a}}h._V8PerformanceHack=new h(.5,.5,.5,.5),Object.defineProperties(h.prototype,{dimension:{value:[4]},rank:{value:1}});class j{}j.mi=(0,H.e)(3,e.Black),j.Ab=(0,H.e)(3,(()=>new h(0,0,0,0))),(0,b.h)("BABYLON.Color3",e),(0,b.h)("BABYLON.Color4",h)}}]);