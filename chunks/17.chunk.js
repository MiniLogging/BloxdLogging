"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[17],{12379:(E,U,g)=>{g.r(U),g.d(U,{VU:()=>P,hu:()=>F,TmpColors:()=>f});var N=g(12345),L=g(12292),D=g(12336),S=g(12353);function u(E){return Math.pow(E,D.i)}function s(E){return E<=.04045?.0773993808*E:Math.pow(.947867299*(E+.055),2.4)}function C(E){return Math.pow(E,D.f)}function B(E){return E<=.0031308?12.92*E:1.055*Math.pow(E,.41666)-.055}class P{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=E,this.g=U,this.b=g}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"VU"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E}toArray(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[U]=this.r,E[U+1]=this.g,E[U+2]=this.b,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(E,U,this),this}toColor4(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new F(this.r,this.g,this.b,E)}Og(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(E){return new P(this.r*E.r,this.g*E.g,this.b*E.b)}multiplyToRef(E,U){return U.r=this.r*E.r,U.g=this.g*E.g,U.b=this.b*E.b,U}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this}multiplyByFloats(E,U,g){return new P(this.r*E,this.g*U,this.b*g)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,U){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.r,E.g,E.b)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.r,E.g,E.b)}minimizeInPlaceFromFloats(E,U,g){return this.r=Math.min(E,this.r),this.g=Math.min(U,this.g),this.b=Math.min(g,this.b),this}maximizeInPlaceFromFloats(E,U,g){return this.r=Math.max(E,this.r),this.g=Math.max(U,this.g),this.b=Math.max(g,this.b),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b}equalsFloats(E,U,g){return this.equalsToFloats(E,U,g)}equalsToFloats(E,U,g){return this.r===E&&this.g===U&&this.b===g}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:D.c;return(0,S.WithinEpsilon)(this.r,E.r,U)&&(0,S.WithinEpsilon)(this.g,E.g,U)&&(0,S.WithinEpsilon)(this.b,E.b,U)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}scale(E){return new P(this.r*E,this.g*E,this.b*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this}scaleToRef(E,U){return U.r=this.r*E,U.g=this.g*E,U.b=this.b*E,U}scaleAndAddToRef(E,U){return U.r+=this.r*E,U.g+=this.g*E,U.b+=this.b*E,U}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,g=arguments.length>2?arguments[2]:void 0;return g.r=(0,S.Clamp)(this.r,E,U),g.g=(0,S.Clamp)(this.g,E,U),g.b=(0,S.Clamp)(this.b,E,U),g}add(E){return new P(this.r+E.r,this.g+E.g,this.b+E.b)}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this}addInPlaceFromFloats(E,U,g){return this.r+=E,this.g+=U,this.b+=g,this}addToRef(E,U){return U.r=this.r+E.r,U.g=this.g+E.g,U.b=this.b+E.b,U}IU(E){return new P(this.r-E.r,this.g-E.g,this.b-E.b)}subtractToRef(E,U){return U.r=this.r-E.r,U.g=this.g-E.g,U.b=this.b-E.b,U}iB(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this}subtractFromFloats(E,U,g){return new P(this.r-E,this.g-U,this.b-g)}subtractFromFloatsToRef(E,U,g,N){return N.r=this.r-E,N.g=this.g-U,N.b=this.b-g,N}clone(){return new P(this.r,this.g,this.b)}D(E){return this.r=E.r,this.g=E.g,this.b=E.b,this}du(E,U,g){return this.r=E,this.g=U,this.b=g,this}set(E,U,g){return this.du(E,U,g)}yu(E){return this.r=this.g=this.b=E,this}toHexString(){const E=Math.round(255*this.r),U=Math.round(255*this.g),g=Math.round(255*this.b);return"#"+(0,S.ToHex)(E)+(0,S.ToHex)(U)+(0,S.ToHex)(g)}fromHexString(E){return"#"!==E.substring(0,1)||7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new P)}toHSVToRef(E){const U=this.r,g=this.g,N=this.b,L=Math.max(U,g,N),D=Math.min(U,g,N);let S=0,u=0;const s=L,C=L-D;return 0!==L&&(u=C/L),L!=D&&(L==U?(S=(g-N)/C,g<N&&(S+=6)):L==g?S=(N-U)/C+2:L==N&&(S=(U-g)/C+4),S*=60),E.r=S,E.g=u,E.b=s,E}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new P;return this.toLinearSpaceToRef(U,E),U}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=s(this.r),E.g=s(this.g),E.b=s(this.b)):(E.r=u(this.r),E.g=u(this.g),E.b=u(this.b)),this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new P;return this.toGammaSpaceToRef(U,E),U}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=B(this.r),E.g=B(this.g),E.b=B(this.b)):(E.r=C(this.r),E.g=C(this.g),E.b=C(this.b)),this}static HSVtoRGBToRef(E,U,g,N){const L=g*U,D=E/60,S=L*(1-Math.abs(D%2-1));let u=0,s=0,C=0;D>=0&&D<=1?(u=L,s=S):D>=1&&D<=2?(u=S,s=L):D>=2&&D<=3?(s=L,C=S):D>=3&&D<=4?(s=S,C=L):D>=4&&D<=5?(u=S,C=L):D>=5&&D<=6&&(u=L,C=S);const B=g-L;return N.r=u+B,N.g=s+B,N.b=C+B,N}static FromHSV(E,U,g){const N=new P(0,0,0);return P.HSVtoRGBToRef(E,U,g,N),N}static FromHexString(E){return new P(0,0,0).fromHexString(E)}static eU(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(E[U],E[U+1],E[U+2])}static FromArrayToRef(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2?arguments[2]:void 0;g.r=E[U],g.g=E[U+1],g.b=E[U+2]}static FromInts(E,U,g){return new P(E/255,U/255,g/255)}static Lerp(E,U,g){const N=new P(0,0,0);return P.LerpToRef(E,U,g,N),N}static LerpToRef(E,U,g,N){N.r=E.r+(U.r-E.r)*g,N.g=E.g+(U.g-E.g)*g,N.b=E.b+(U.b-E.b)*g}static Hermite(E,U,g,N,L){const D=L*L,S=L*D,u=2*S-3*D+1,s=-2*S+3*D,C=S-2*D+L,B=S-D,F=E.r*u+g.r*s+U.r*C+N.r*B,f=E.g*u+g.g*s+U.g*C+N.g*B,d=E.b*u+g.b*s+U.b*C+N.b*B;return new P(F,f,d)}static Hermite1stDerivative(E,U,g,N,L){const D=P.Black();return this.Hermite1stDerivativeToRef(E,U,g,N,L,D),D}static Hermite1stDerivativeToRef(E,U,g,N,L,D){const S=L*L;D.r=6*(S-L)*E.r+(3*S-4*L+1)*U.r+6*(-S+L)*g.r+(3*S-2*L)*N.r,D.g=6*(S-L)*E.g+(3*S-4*L+1)*U.g+6*(-S+L)*g.g+(3*S-2*L)*N.g,D.b=6*(S-L)*E.b+(3*S-4*L+1)*U.b+6*(-S+L)*g.b+(3*S-2*L)*N.b}static Red(){return new P(1,0,0)}static Green(){return new P(0,1,0)}static Blue(){return new P(0,0,1)}static Black(){return new P(0,0,0)}static get BlackReadOnly(){return P._BlackReadOnly}static White(){return new P(1,1,1)}static Purple(){return new P(.5,0,.5)}static Magenta(){return new P(1,0,1)}static Yellow(){return new P(1,1,0)}static Gray(){return new P(.5,.5,.5)}static Teal(){return new P(0,1,1)}static Random(){return new P(Math.random(),Math.random(),Math.random())}}P._V8PerformanceHack=new P(.5,.5,.5),P._BlackReadOnly=P.Black(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class F{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=E,this.g=U,this.b=g,this.a=N}Og(){return[this.r,this.g,this.b,this.a]}toArray(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[U]=this.r,E[U+1]=this.g,E[U+2]=this.b,E[U+3]=this.a,this}Yg(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=E[U],this.g=E[U+1],this.b=E[U+2],this.a=E[U+3],this}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b&&this.a===E.a}add(E){return new F(this.r+E.r,this.g+E.g,this.b+E.b,this.a+E.a)}addToRef(E,U){return U.r=this.r+E.r,U.g=this.g+E.g,U.b=this.b+E.b,U.a=this.a+E.a,U}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this.a+=E.a,this}addInPlaceFromFloats(E,U,g,N){return this.r+=E,this.g+=U,this.b+=g,this.a+=N,this}IU(E){return new F(this.r-E.r,this.g-E.g,this.b-E.b,this.a-E.a)}subtractToRef(E,U){return U.r=this.r-E.r,U.g=this.g-E.g,U.b=this.b-E.b,U.a=this.a-E.a,U}iB(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this.a-=E.a,this}subtractFromFloats(E,U,g,N){return new F(this.r-E,this.g-U,this.b-g,this.a-N)}subtractFromFloatsToRef(E,U,g,N,L){return L.r=this.r-E,L.g=this.g-U,L.b=this.b-g,L.a=this.a-N,L}scale(E){return new F(this.r*E,this.g*E,this.b*E,this.a*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this.a*=E,this}scaleToRef(E,U){return U.r=this.r*E,U.g=this.g*E,U.b=this.b*E,U.a=this.a*E,U}scaleAndAddToRef(E,U){return U.r+=this.r*E,U.g+=this.g*E,U.b+=this.b*E,U.a+=this.a*E,U}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,g=arguments.length>2?arguments[2]:void 0;return g.r=(0,S.Clamp)(this.r,E,U),g.g=(0,S.Clamp)(this.g,E,U),g.b=(0,S.Clamp)(this.b,E,U),g.a=(0,S.Clamp)(this.a,E,U),g}multiply(E){return new F(this.r*E.r,this.g*E.g,this.b*E.b,this.a*E.a)}multiplyToRef(E,U){return U.r=this.r*E.r,U.g=this.g*E.g,U.b=this.b*E.b,U.a=this.a*E.a,U}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this.a*=E.a,this}multiplyByFloats(E,U,g,N){return new F(this.r*E,this.g*U,this.b*g,this.a*N)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,U){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.r=Math.min(this.r,E.r),this.g=Math.min(this.g,E.g),this.b=Math.min(this.b,E.b),this.a=Math.min(this.a,E.a),this}maximizeInPlace(E){return this.r=Math.max(this.r,E.r),this.g=Math.max(this.g,E.g),this.b=Math.max(this.b,E.b),this.a=Math.max(this.a,E.a),this}minimizeInPlaceFromFloats(E,U,g,N){return this.r=Math.min(E,this.r),this.g=Math.min(U,this.g),this.b=Math.min(g,this.b),this.a=Math.min(N,this.a),this}maximizeInPlaceFromFloats(E,U,g,N){return this.r=Math.max(E,this.r),this.g=Math.max(U,this.g),this.b=Math.max(g,this.b),this.a=Math.max(N,this.a),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:D.c;return(0,S.WithinEpsilon)(this.r,E.r,U)&&(0,S.WithinEpsilon)(this.g,E.g,U)&&(0,S.WithinEpsilon)(this.b,E.b,U)&&(0,S.WithinEpsilon)(this.a,E.a,U)}equalsToFloats(E,U,g,N){return this.r===E&&this.g===U&&this.b===g&&this.a===N}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"hu"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E=397*E^255*this.a,E}clone(){return(new F).D(this)}D(E){return this.r=E.r,this.g=E.g,this.b=E.b,this.a=E.a,this}du(E,U,g,N){return this.r=E,this.g=U,this.b=g,this.a=N,this}set(E,U,g,N){return this.du(E,U,g,N)}yu(E){return this.r=this.g=this.b=this.a=E,this}toHexString(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=Math.round(255*this.r),g=Math.round(255*this.g),N=Math.round(255*this.b);if(E)return"#"+(0,S.ToHex)(U)+(0,S.ToHex)(g)+(0,S.ToHex)(N);const L=Math.round(255*this.a);return"#"+(0,S.ToHex)(U)+(0,S.ToHex)(g)+(0,S.ToHex)(N)+(0,S.ToHex)(L)}fromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255,9===E.length&&(this.a=parseInt(E.substring(7,9),16)/255)),this}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new F;return this.toLinearSpaceToRef(U,E),U}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=s(this.r),E.g=s(this.g),E.b=s(this.b)):(E.r=u(this.r),E.g=u(this.g),E.b=u(this.b)),E.a=this.a,this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new F;return this.toGammaSpaceToRef(U,E),U}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=B(this.r),E.g=B(this.g),E.b=B(this.b)):(E.r=C(this.r),E.g=C(this.g),E.b=C(this.b)),E.a=this.a,this}static FromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length?new F(0,0,0,0):new F(0,0,0,1).fromHexString(E)}static Lerp(E,U,g){return F.LerpToRef(E,U,g,new F)}static LerpToRef(E,U,g,N){return N.r=E.r+(U.r-E.r)*g,N.g=E.g+(U.g-E.g)*g,N.b=E.b+(U.b-E.b)*g,N.a=E.a+(U.a-E.a)*g,N}static Hermite(E,U,g,N,L){const D=L*L,S=L*D,u=2*S-3*D+1,s=-2*S+3*D,C=S-2*D+L,B=S-D,P=E.r*u+g.r*s+U.r*C+N.r*B,f=E.g*u+g.g*s+U.g*C+N.g*B,d=E.b*u+g.b*s+U.b*C+N.b*B,I=E.a*u+g.a*s+U.a*C+N.a*B;return new F(P,f,d,I)}static Hermite1stDerivative(E,U,g,N,L){const D=new F;return this.Hermite1stDerivativeToRef(E,U,g,N,L,D),D}static Hermite1stDerivativeToRef(E,U,g,N,L,D){const S=L*L;D.r=6*(S-L)*E.r+(3*S-4*L+1)*U.r+6*(-S+L)*g.r+(3*S-2*L)*N.r,D.g=6*(S-L)*E.g+(3*S-4*L+1)*U.g+6*(-S+L)*g.g+(3*S-2*L)*N.g,D.b=6*(S-L)*E.b+(3*S-4*L+1)*U.b+6*(-S+L)*g.b+(3*S-2*L)*N.b,D.a=6*(S-L)*E.a+(3*S-4*L+1)*U.a+6*(-S+L)*g.a+(3*S-2*L)*N.a}static FromColor3(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new F(E.r,E.g,E.b,U)}static eU(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new F(E[U],E[U+1],E[U+2],E[U+3])}static FromArrayToRef(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2?arguments[2]:void 0;g.r=E[U],g.g=E[U+1],g.b=E[U+2],g.a=E[U+3]}static FromInts(E,U,g,N){return new F(E/255,U/255,g/255,N/255)}static CheckColors4(E,U){if(E.length===3*U){const U=[];for(let g=0;g<E.length;g+=3){const N=g/3*4;U[N]=E[g],U[N+1]=E[g+1],U[N+2]=E[g+2],U[N+3]=1}return U}return E}}F._V8PerformanceHack=new F(.5,.5,.5,.5),Object.defineProperties(F.prototype,{dimension:{value:[4]},rank:{value:1}});class f{}f.VU=(0,N.b)(3,P.Black),f.hu=(0,N.b)(3,(()=>new F(0,0,0,0))),(0,L.f)("BABYLON.Color3",P),(0,L.f)("BABYLON.Color4",F)}}]);