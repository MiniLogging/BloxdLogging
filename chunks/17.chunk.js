"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[17],{12637:(I,g,b)=>{b.r(g),b.d(g,{Eg:()=>D,Sb:()=>p,TmpColors:()=>x});var e=b(12604),c=b(12558),z=b(12597),M=b(12610);function J(I){return Math.pow(I,z.l)}function o(I){return I<=.04045?.0773993808*I:Math.pow(.947867299*(I+.055),2.4)}function n(I){return Math.pow(I,z.i)}function G(I){return I<=.0031308?12.92*I:1.055*Math.pow(I,.41666)-.055}class D{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=I,this.g=g,this.b=b}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Eg"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I}toArray(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[g]=this.r,I[g+1]=this.g,I[g+2]=this.b,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D.FromArrayToRef(I,g,this),this}toColor4(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new p(this.r,this.g,this.b,I)}bb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(I){return new D(this.r*I.r,this.g*I.g,this.b*I.b)}multiplyToRef(I,g){return g.r=this.r*I.r,g.g=this.g*I.g,g.b=this.b*I.b,g}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this}multiplyByFloats(I,g,b){return new D(this.r*I,this.g*g,this.b*b)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,g){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.r,I.g,I.b)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.r,I.g,I.b)}minimizeInPlaceFromFloats(I,g,b){return this.r=Math.min(I,this.r),this.g=Math.min(g,this.g),this.b=Math.min(b,this.b),this}maximizeInPlaceFromFloats(I,g,b){return this.r=Math.max(I,this.r),this.g=Math.max(g,this.g),this.b=Math.max(b,this.b),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b}equalsFloats(I,g,b){return this.equalsToFloats(I,g,b)}equalsToFloats(I,g,b){return this.r===I&&this.g===g&&this.b===b}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.b;return(0,M.WithinEpsilon)(this.r,I.r,g)&&(0,M.WithinEpsilon)(this.g,I.g,g)&&(0,M.WithinEpsilon)(this.b,I.b,g)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}scale(I){return new D(this.r*I,this.g*I,this.b*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this}scaleToRef(I,g){return g.r=this.r*I,g.g=this.g*I,g.b=this.b*I,g}scaleAndAddToRef(I,g){return g.r+=this.r*I,g.g+=this.g*I,g.b+=this.b*I,g}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,M.Clamp)(this.r,I,g),b.g=(0,M.Clamp)(this.g,I,g),b.b=(0,M.Clamp)(this.b,I,g),b}add(I){return new D(this.r+I.r,this.g+I.g,this.b+I.b)}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this}addInPlaceFromFloats(I,g,b){return this.r+=I,this.g+=g,this.b+=b,this}addToRef(I,g){return g.r=this.r+I.r,g.g=this.g+I.g,g.b=this.b+I.b,g}ag(I){return new D(this.r-I.r,this.g-I.g,this.b-I.b)}subtractToRef(I,g){return g.r=this.r-I.r,g.g=this.g-I.g,g.b=this.b-I.b,g}Op(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this}subtractFromFloats(I,g,b){return new D(this.r-I,this.g-g,this.b-b)}subtractFromFloatsToRef(I,g,b,e){return e.r=this.r-I,e.g=this.g-g,e.b=this.b-b,e}clone(){return new D(this.r,this.g,this.b)}G(I){return this.r=I.r,this.g=I.g,this.b=I.b,this}Db(I,g,b){return this.r=I,this.g=g,this.b=b,this}set(I,g,b){return this.Db(I,g,b)}kb(I){return this.r=this.g=this.b=I,this}toHexString(){const I=Math.round(255*this.r),g=Math.round(255*this.g),b=Math.round(255*this.b);return"#"+(0,M.ToHex)(I)+(0,M.ToHex)(g)+(0,M.ToHex)(b)}fromHexString(I){return"#"!==I.substring(0,1)||7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new D)}toHSVToRef(I){const g=this.r,b=this.g,e=this.b,c=Math.max(g,b,e),z=Math.min(g,b,e);let M=0,J=0;const o=c,n=c-z;return 0!==c&&(J=n/c),c!=z&&(c==g?(M=(b-e)/n,b<e&&(M+=6)):c==b?M=(e-g)/n+2:c==e&&(M=(g-b)/n+4),M*=60),I.r=M,I.g=J,I.b=o,I}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=new D;return this.toLinearSpaceToRef(g,I),g}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=o(this.r),I.g=o(this.g),I.b=o(this.b)):(I.r=J(this.r),I.g=J(this.g),I.b=J(this.b)),this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=new D;return this.toGammaSpaceToRef(g,I),g}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=G(this.r),I.g=G(this.g),I.b=G(this.b)):(I.r=n(this.r),I.g=n(this.g),I.b=n(this.b)),this}static HSVtoRGBToRef(I,g,b,e){const c=b*g,z=I/60,M=c*(1-Math.abs(z%2-1));let J=0,o=0,n=0;z>=0&&z<=1?(J=c,o=M):z>=1&&z<=2?(J=M,o=c):z>=2&&z<=3?(o=c,n=M):z>=3&&z<=4?(o=M,n=c):z>=4&&z<=5?(J=M,n=c):z>=5&&z<=6&&(J=c,n=M);const G=b-c;return e.r=J+G,e.g=o+G,e.b=n+G,e}static FromHSV(I,g,b){const e=new D(0,0,0);return D.HSVtoRGBToRef(I,g,b,e),e}static FromHexString(I){return new D(0,0,0).fromHexString(I)}static mb(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(I[g],I[g+1],I[g+2])}static FromArrayToRef(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=I[g],b.g=I[g+1],b.b=I[g+2]}static FromInts(I,g,b){return new D(I/255,g/255,b/255)}static Lerp(I,g,b){const e=new D(0,0,0);return D.LerpToRef(I,g,b,e),e}static LerpToRef(I,g,b,e){e.r=I.r+(g.r-I.r)*b,e.g=I.g+(g.g-I.g)*b,e.b=I.b+(g.b-I.b)*b}static Hermite(I,g,b,e,c){const z=c*c,M=c*z,J=2*M-3*z+1,o=-2*M+3*z,n=M-2*z+c,G=M-z,p=I.r*J+b.r*o+g.r*n+e.r*G,x=I.g*J+b.g*o+g.g*n+e.g*G,Z=I.b*J+b.b*o+g.b*n+e.b*G;return new D(p,x,Z)}static Hermite1stDerivative(I,g,b,e,c){const z=D.Black();return this.Hermite1stDerivativeToRef(I,g,b,e,c,z),z}static Hermite1stDerivativeToRef(I,g,b,e,c,z){const M=c*c;z.r=6*(M-c)*I.r+(3*M-4*c+1)*g.r+6*(-M+c)*b.r+(3*M-2*c)*e.r,z.g=6*(M-c)*I.g+(3*M-4*c+1)*g.g+6*(-M+c)*b.g+(3*M-2*c)*e.g,z.b=6*(M-c)*I.b+(3*M-4*c+1)*g.b+6*(-M+c)*b.b+(3*M-2*c)*e.b}static Red(){return new D(1,0,0)}static Green(){return new D(0,1,0)}static Blue(){return new D(0,0,1)}static Black(){return new D(0,0,0)}static get BlackReadOnly(){return D._BlackReadOnly}static White(){return new D(1,1,1)}static Purple(){return new D(.5,0,.5)}static Magenta(){return new D(1,0,1)}static Yellow(){return new D(1,1,0)}static Gray(){return new D(.5,.5,.5)}static Teal(){return new D(0,1,1)}static Random(){return new D(Math.random(),Math.random(),Math.random())}}D._V8PerformanceHack=new D(.5,.5,.5),D._BlackReadOnly=D.Black(),Object.defineProperties(D.prototype,{dimension:{value:[3]},rank:{value:1}});class p{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=I,this.g=g,this.b=b,this.a=e}bb(){return[this.r,this.g,this.b,this.a]}toArray(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[g]=this.r,I[g+1]=this.g,I[g+2]=this.b,I[g+3]=this.a,this}Le(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=I[g],this.g=I[g+1],this.b=I[g+2],this.a=I[g+3],this}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b&&this.a===I.a}add(I){return new p(this.r+I.r,this.g+I.g,this.b+I.b,this.a+I.a)}addToRef(I,g){return g.r=this.r+I.r,g.g=this.g+I.g,g.b=this.b+I.b,g.a=this.a+I.a,g}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this.a+=I.a,this}addInPlaceFromFloats(I,g,b,e){return this.r+=I,this.g+=g,this.b+=b,this.a+=e,this}ag(I){return new p(this.r-I.r,this.g-I.g,this.b-I.b,this.a-I.a)}subtractToRef(I,g){return g.r=this.r-I.r,g.g=this.g-I.g,g.b=this.b-I.b,g.a=this.a-I.a,g}Op(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this.a-=I.a,this}subtractFromFloats(I,g,b,e){return new p(this.r-I,this.g-g,this.b-b,this.a-e)}subtractFromFloatsToRef(I,g,b,e,c){return c.r=this.r-I,c.g=this.g-g,c.b=this.b-b,c.a=this.a-e,c}scale(I){return new p(this.r*I,this.g*I,this.b*I,this.a*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this.a*=I,this}scaleToRef(I,g){return g.r=this.r*I,g.g=this.g*I,g.b=this.b*I,g.a=this.a*I,g}scaleAndAddToRef(I,g){return g.r+=this.r*I,g.g+=this.g*I,g.b+=this.b*I,g.a+=this.a*I,g}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,b=arguments.length>2?arguments[2]:void 0;return b.r=(0,M.Clamp)(this.r,I,g),b.g=(0,M.Clamp)(this.g,I,g),b.b=(0,M.Clamp)(this.b,I,g),b.a=(0,M.Clamp)(this.a,I,g),b}multiply(I){return new p(this.r*I.r,this.g*I.g,this.b*I.b,this.a*I.a)}multiplyToRef(I,g){return g.r=this.r*I.r,g.g=this.g*I.g,g.b=this.b*I.b,g.a=this.a*I.a,g}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this.a*=I.a,this}multiplyByFloats(I,g,b,e){return new p(this.r*I,this.g*g,this.b*b,this.a*e)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,g){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.r=Math.min(this.r,I.r),this.g=Math.min(this.g,I.g),this.b=Math.min(this.b,I.b),this.a=Math.min(this.a,I.a),this}maximizeInPlace(I){return this.r=Math.max(this.r,I.r),this.g=Math.max(this.g,I.g),this.b=Math.max(this.b,I.b),this.a=Math.max(this.a,I.a),this}minimizeInPlaceFromFloats(I,g,b,e){return this.r=Math.min(I,this.r),this.g=Math.min(g,this.g),this.b=Math.min(b,this.b),this.a=Math.min(e,this.a),this}maximizeInPlaceFromFloats(I,g,b,e){return this.r=Math.max(I,this.r),this.g=Math.max(g,this.g),this.b=Math.max(b,this.b),this.a=Math.max(e,this.a),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:z.b;return(0,M.WithinEpsilon)(this.r,I.r,g)&&(0,M.WithinEpsilon)(this.g,I.g,g)&&(0,M.WithinEpsilon)(this.b,I.b,g)&&(0,M.WithinEpsilon)(this.a,I.a,g)}equalsToFloats(I,g,b,e){return this.r===I&&this.g===g&&this.b===b&&this.a===e}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Sb"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I=397*I^255*this.a,I}clone(){return(new p).G(this)}G(I){return this.r=I.r,this.g=I.g,this.b=I.b,this.a=I.a,this}Db(I,g,b,e){return this.r=I,this.g=g,this.b=b,this.a=e,this}set(I,g,b,e){return this.Db(I,g,b,e)}kb(I){return this.r=this.g=this.b=this.a=I,this}toHexString(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=Math.round(255*this.r),b=Math.round(255*this.g),e=Math.round(255*this.b);if(I)return"#"+(0,M.ToHex)(g)+(0,M.ToHex)(b)+(0,M.ToHex)(e);const c=Math.round(255*this.a);return"#"+(0,M.ToHex)(g)+(0,M.ToHex)(b)+(0,M.ToHex)(e)+(0,M.ToHex)(c)}fromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255,9===I.length&&(this.a=parseInt(I.substring(7,9),16)/255)),this}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=new p;return this.toLinearSpaceToRef(g,I),g}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=o(this.r),I.g=o(this.g),I.b=o(this.b)):(I.r=J(this.r),I.g=J(this.g),I.b=J(this.b)),I.a=this.a,this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const g=new p;return this.toGammaSpaceToRef(g,I),g}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=G(this.r),I.g=G(this.g),I.b=G(this.b)):(I.r=n(this.r),I.g=n(this.g),I.b=n(this.b)),I.a=this.a,this}static FromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length?new p(0,0,0,0):new p(0,0,0,1).fromHexString(I)}static Lerp(I,g,b){return p.LerpToRef(I,g,b,new p)}static LerpToRef(I,g,b,e){return e.r=I.r+(g.r-I.r)*b,e.g=I.g+(g.g-I.g)*b,e.b=I.b+(g.b-I.b)*b,e.a=I.a+(g.a-I.a)*b,e}static Hermite(I,g,b,e,c){const z=c*c,M=c*z,J=2*M-3*z+1,o=-2*M+3*z,n=M-2*z+c,G=M-z,D=I.r*J+b.r*o+g.r*n+e.r*G,x=I.g*J+b.g*o+g.g*n+e.g*G,Z=I.b*J+b.b*o+g.b*n+e.b*G,k=I.a*J+b.a*o+g.a*n+e.a*G;return new p(D,x,Z,k)}static Hermite1stDerivative(I,g,b,e,c){const z=new p;return this.Hermite1stDerivativeToRef(I,g,b,e,c,z),z}static Hermite1stDerivativeToRef(I,g,b,e,c,z){const M=c*c;z.r=6*(M-c)*I.r+(3*M-4*c+1)*g.r+6*(-M+c)*b.r+(3*M-2*c)*e.r,z.g=6*(M-c)*I.g+(3*M-4*c+1)*g.g+6*(-M+c)*b.g+(3*M-2*c)*e.g,z.b=6*(M-c)*I.b+(3*M-4*c+1)*g.b+6*(-M+c)*b.b+(3*M-2*c)*e.b,z.a=6*(M-c)*I.a+(3*M-4*c+1)*g.a+6*(-M+c)*b.a+(3*M-2*c)*e.a}static FromColor3(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new p(I.r,I.g,I.b,g)}static mb(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(I[g],I[g+1],I[g+2],I[g+3])}static FromArrayToRef(I){let g=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2?arguments[2]:void 0;b.r=I[g],b.g=I[g+1],b.b=I[g+2],b.a=I[g+3]}static FromInts(I,g,b,e){return new p(I/255,g/255,b/255,e/255)}static CheckColors4(I,g){if(I.length===3*g){const g=[];for(let b=0;b<I.length;b+=3){const e=b/3*4;g[e]=I[b],g[e+1]=I[b+1],g[e+2]=I[b+2],g[e+3]=1}return g}return I}}p._V8PerformanceHack=new p(.5,.5,.5,.5),Object.defineProperties(p.prototype,{dimension:{value:[4]},rank:{value:1}});class x{}x.Eg=(0,e.e)(3,D.Black),x.Sb=(0,e.e)(3,(()=>new p(0,0,0,0))),(0,c.g)("BABYLON.Color3",D),(0,c.g)("BABYLON.Color4",p)}}]);