"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[17],{11335:(n,y,H)=>{H.r(y),H.d(y,{Fy:()=>b,pi:()=>A,TmpColors:()=>U});var o=H(11300),G=H(11248),h=H(11297),k=H(11303);function i(n){return Math.pow(n,h.n)}function B(n){return n<=.04045?.0773993808*n:Math.pow(.947867299*(n+.055),2.4)}function V(n){return Math.pow(n,h.k)}function q(n){return n<=.0031308?12.92*n:1.055*Math.pow(n,.41666)-.055}class b{constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=n,this.g=y,this.b=H}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Fy"}getHashCode(){let n=255*this.r|0;return n=397*n^255*this.g,n=397*n^255*this.b,n}toArray(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[y]=this.r,n[y+1]=this.g,n[y+2]=this.b,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b.FromArrayToRef(n,y,this),this}toColor4(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new A(this.r,this.g,this.b,n)}Ui(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(n){return new b(this.r*n.r,this.g*n.g,this.b*n.b)}multiplyToRef(n,y){return y.r=this.r*n.r,y.g=this.g*n.g,y.b=this.b*n.b,y}multiplyInPlace(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this}multiplyByFloats(n,y,H){return new b(this.r*n,this.g*y,this.b*H)}divide(n){throw new ReferenceError("Can not divide a color")}divideToRef(n,y){throw new ReferenceError("Can not divide a color")}divideInPlace(n){throw new ReferenceError("Can not divide a color")}minimizeInPlace(n){return this.minimizeInPlaceFromFloats(n.r,n.g,n.b)}maximizeInPlace(n){return this.maximizeInPlaceFromFloats(n.r,n.g,n.b)}minimizeInPlaceFromFloats(n,y,H){return this.r=Math.min(n,this.r),this.g=Math.min(y,this.g),this.b=Math.min(H,this.b),this}maximizeInPlaceFromFloats(n,y,H){return this.r=Math.max(n,this.r),this.g=Math.max(y,this.g),this.b=Math.max(H,this.b),this}floorToRef(n){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(n){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(n){return n&&this.r===n.r&&this.g===n.g&&this.b===n.b}equalsFloats(n,y,H){return this.equalsToFloats(n,y,H)}equalsToFloats(n,y,H){return this.r===n&&this.g===y&&this.b===H}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.e;return(0,k.WithinEpsilon)(this.r,n.r,y)&&(0,k.WithinEpsilon)(this.g,n.g,y)&&(0,k.WithinEpsilon)(this.b,n.b,y)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(n){throw new ReferenceError("Can not negate a color")}scale(n){return new b(this.r*n,this.g*n,this.b*n)}scaleInPlace(n){return this.r*=n,this.g*=n,this.b*=n,this}scaleToRef(n,y){return y.r=this.r*n,y.g=this.g*n,y.b=this.b*n,y}scaleAndAddToRef(n,y){return y.r+=this.r*n,y.g+=this.g*n,y.b+=this.b*n,y}clampToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.r=(0,k.Clamp)(this.r,n,y),H.g=(0,k.Clamp)(this.g,n,y),H.b=(0,k.Clamp)(this.b,n,y),H}add(n){return new b(this.r+n.r,this.g+n.g,this.b+n.b)}addInPlace(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this}addInPlaceFromFloats(n,y,H){return this.r+=n,this.g+=y,this.b+=H,this}addToRef(n,y){return y.r=this.r+n.r,y.g=this.g+n.g,y.b=this.b+n.b,y}Qy(n){return new b(this.r-n.r,this.g-n.g,this.b-n.b)}subtractToRef(n,y){return y.r=this.r-n.r,y.g=this.g-n.g,y.b=this.b-n.b,y}kb(n){return this.r-=n.r,this.g-=n.g,this.b-=n.b,this}subtractFromFloats(n,y,H){return new b(this.r-n,this.g-y,this.b-H)}subtractFromFloatsToRef(n,y,H,o){return o.r=this.r-n,o.g=this.g-y,o.b=this.b-H,o}clone(){return new b(this.r,this.g,this.b)}B(n){return this.r=n.r,this.g=n.g,this.b=n.b,this}Mi(n,y,H){return this.r=n,this.g=y,this.b=H,this}set(n,y,H){return this.Mi(n,y,H)}ci(n){return this.r=this.g=this.b=n,this}toHexString(){const n=Math.round(255*this.r),y=Math.round(255*this.g),H=Math.round(255*this.b);return"#"+(0,k.ToHex)(n)+(0,k.ToHex)(y)+(0,k.ToHex)(H)}fromHexString(n){return"#"!==n.substring(0,1)||7!==n.length||(this.r=parseInt(n.substring(1,3),16)/255,this.g=parseInt(n.substring(3,5),16)/255,this.b=parseInt(n.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new b)}toHSVToRef(n){const y=this.r,H=this.g,o=this.b,G=Math.max(y,H,o),h=Math.min(y,H,o);let k=0,i=0;const B=G,V=G-h;return 0!==G&&(i=V/G),G!=h&&(G==y?(k=(H-o)/V,H<o&&(k+=6)):G==H?k=(o-y)/V+2:G==o&&(k=(y-H)/V+4),k*=60),n.r=k,n.g=i,n.b=B,n}toLinearSpace(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=new b;return this.toLinearSpaceToRef(y,n),y}toLinearSpaceToRef(n){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(n.r=B(this.r),n.g=B(this.g),n.b=B(this.b)):(n.r=i(this.r),n.g=i(this.g),n.b=i(this.b)),this}toGammaSpace(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=new b;return this.toGammaSpaceToRef(y,n),y}toGammaSpaceToRef(n){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(n.r=q(this.r),n.g=q(this.g),n.b=q(this.b)):(n.r=V(this.r),n.g=V(this.g),n.b=V(this.b)),this}static HSVtoRGBToRef(n,y,H,o){const G=H*y,h=n/60,k=G*(1-Math.abs(h%2-1));let i=0,B=0,V=0;h>=0&&h<=1?(i=G,B=k):h>=1&&h<=2?(i=k,B=G):h>=2&&h<=3?(B=G,V=k):h>=3&&h<=4?(B=k,V=G):h>=4&&h<=5?(i=k,V=G):h>=5&&h<=6&&(i=G,V=k);const q=H-G;return o.r=i+q,o.g=B+q,o.b=V+q,o}static FromHSV(n,y,H){const o=new b(0,0,0);return b.HSVtoRGBToRef(n,y,H,o),o}static FromHexString(n){return new b(0,0,0).fromHexString(n)}static gy(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(n[y],n[y+1],n[y+2])}static FromArrayToRef(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2?arguments[2]:void 0;H.r=n[y],H.g=n[y+1],H.b=n[y+2]}static FromInts(n,y,H){return new b(n/255,y/255,H/255)}static Lerp(n,y,H){const o=new b(0,0,0);return b.LerpToRef(n,y,H,o),o}static LerpToRef(n,y,H,o){o.r=n.r+(y.r-n.r)*H,o.g=n.g+(y.g-n.g)*H,o.b=n.b+(y.b-n.b)*H}static Hermite(n,y,H,o,G){const h=G*G,k=G*h,i=2*k-3*h+1,B=-2*k+3*h,V=k-2*h+G,q=k-h,A=n.r*i+H.r*B+y.r*V+o.r*q,U=n.g*i+H.g*B+y.g*V+o.g*q,T=n.b*i+H.b*B+y.b*V+o.b*q;return new b(A,U,T)}static Hermite1stDerivative(n,y,H,o,G){const h=b.Black();return this.Hermite1stDerivativeToRef(n,y,H,o,G,h),h}static Hermite1stDerivativeToRef(n,y,H,o,G,h){const k=G*G;h.r=6*(k-G)*n.r+(3*k-4*G+1)*y.r+6*(-k+G)*H.r+(3*k-2*G)*o.r,h.g=6*(k-G)*n.g+(3*k-4*G+1)*y.g+6*(-k+G)*H.g+(3*k-2*G)*o.g,h.b=6*(k-G)*n.b+(3*k-4*G+1)*y.b+6*(-k+G)*H.b+(3*k-2*G)*o.b}static Red(){return new b(1,0,0)}static Green(){return new b(0,1,0)}static Blue(){return new b(0,0,1)}static Black(){return new b(0,0,0)}static get BlackReadOnly(){return b._BlackReadOnly}static White(){return new b(1,1,1)}static Purple(){return new b(.5,0,.5)}static Magenta(){return new b(1,0,1)}static Yellow(){return new b(1,1,0)}static Gray(){return new b(.5,.5,.5)}static Teal(){return new b(0,1,1)}static Random(){return new b(Math.random(),Math.random(),Math.random())}}b._V8PerformanceHack=new b(.5,.5,.5),b._BlackReadOnly=b.Black(),Object.defineProperties(b.prototype,{dimension:{value:[3]},rank:{value:1}});class A{constructor(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=n,this.g=y,this.b=H,this.a=o}Ui(){return[this.r,this.g,this.b,this.a]}toArray(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n[y]=this.r,n[y+1]=this.g,n[y+2]=this.b,n[y+3]=this.a,this}vH(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=n[y],this.g=n[y+1],this.b=n[y+2],this.a=n[y+3],this}equals(n){return n&&this.r===n.r&&this.g===n.g&&this.b===n.b&&this.a===n.a}add(n){return new A(this.r+n.r,this.g+n.g,this.b+n.b,this.a+n.a)}addToRef(n,y){return y.r=this.r+n.r,y.g=this.g+n.g,y.b=this.b+n.b,y.a=this.a+n.a,y}addInPlace(n){return this.r+=n.r,this.g+=n.g,this.b+=n.b,this.a+=n.a,this}addInPlaceFromFloats(n,y,H,o){return this.r+=n,this.g+=y,this.b+=H,this.a+=o,this}Qy(n){return new A(this.r-n.r,this.g-n.g,this.b-n.b,this.a-n.a)}subtractToRef(n,y){return y.r=this.r-n.r,y.g=this.g-n.g,y.b=this.b-n.b,y.a=this.a-n.a,y}kb(n){return this.r-=n.r,this.g-=n.g,this.b-=n.b,this.a-=n.a,this}subtractFromFloats(n,y,H,o){return new A(this.r-n,this.g-y,this.b-H,this.a-o)}subtractFromFloatsToRef(n,y,H,o,G){return G.r=this.r-n,G.g=this.g-y,G.b=this.b-H,G.a=this.a-o,G}scale(n){return new A(this.r*n,this.g*n,this.b*n,this.a*n)}scaleInPlace(n){return this.r*=n,this.g*=n,this.b*=n,this.a*=n,this}scaleToRef(n,y){return y.r=this.r*n,y.g=this.g*n,y.b=this.b*n,y.a=this.a*n,y}scaleAndAddToRef(n,y){return y.r+=this.r*n,y.g+=this.g*n,y.b+=this.b*n,y.a+=this.a*n,y}clampToRef(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,H=arguments.length>2?arguments[2]:void 0;return H.r=(0,k.Clamp)(this.r,n,y),H.g=(0,k.Clamp)(this.g,n,y),H.b=(0,k.Clamp)(this.b,n,y),H.a=(0,k.Clamp)(this.a,n,y),H}multiply(n){return new A(this.r*n.r,this.g*n.g,this.b*n.b,this.a*n.a)}multiplyToRef(n,y){return y.r=this.r*n.r,y.g=this.g*n.g,y.b=this.b*n.b,y.a=this.a*n.a,y}multiplyInPlace(n){return this.r*=n.r,this.g*=n.g,this.b*=n.b,this.a*=n.a,this}multiplyByFloats(n,y,H,o){return new A(this.r*n,this.g*y,this.b*H,this.a*o)}divide(n){throw new ReferenceError("Can not divide a color")}divideToRef(n,y){throw new ReferenceError("Can not divide a color")}divideInPlace(n){throw new ReferenceError("Can not divide a color")}minimizeInPlace(n){return this.r=Math.min(this.r,n.r),this.g=Math.min(this.g,n.g),this.b=Math.min(this.b,n.b),this.a=Math.min(this.a,n.a),this}maximizeInPlace(n){return this.r=Math.max(this.r,n.r),this.g=Math.max(this.g,n.g),this.b=Math.max(this.b,n.b),this.a=Math.max(this.a,n.a),this}minimizeInPlaceFromFloats(n,y,H,o){return this.r=Math.min(n,this.r),this.g=Math.min(y,this.g),this.b=Math.min(H,this.b),this.a=Math.min(o,this.a),this}maximizeInPlaceFromFloats(n,y,H,o){return this.r=Math.max(n,this.r),this.g=Math.max(y,this.g),this.b=Math.max(H,this.b),this.a=Math.max(o,this.a),this}floorToRef(n){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(n){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(n){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.e;return(0,k.WithinEpsilon)(this.r,n.r,y)&&(0,k.WithinEpsilon)(this.g,n.g,y)&&(0,k.WithinEpsilon)(this.b,n.b,y)&&(0,k.WithinEpsilon)(this.a,n.a,y)}equalsToFloats(n,y,H,o){return this.r===n&&this.g===y&&this.b===H&&this.a===o}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"pi"}getHashCode(){let n=255*this.r|0;return n=397*n^255*this.g,n=397*n^255*this.b,n=397*n^255*this.a,n}clone(){return(new A).B(this)}B(n){return this.r=n.r,this.g=n.g,this.b=n.b,this.a=n.a,this}Mi(n,y,H,o){return this.r=n,this.g=y,this.b=H,this.a=o,this}set(n,y,H,o){return this.Mi(n,y,H,o)}ci(n){return this.r=this.g=this.b=this.a=n,this}toHexString(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=Math.round(255*this.r),H=Math.round(255*this.g),o=Math.round(255*this.b);if(n)return"#"+(0,k.ToHex)(y)+(0,k.ToHex)(H)+(0,k.ToHex)(o);const G=Math.round(255*this.a);return"#"+(0,k.ToHex)(y)+(0,k.ToHex)(H)+(0,k.ToHex)(o)+(0,k.ToHex)(G)}fromHexString(n){return"#"!==n.substring(0,1)||9!==n.length&&7!==n.length||(this.r=parseInt(n.substring(1,3),16)/255,this.g=parseInt(n.substring(3,5),16)/255,this.b=parseInt(n.substring(5,7),16)/255,9===n.length&&(this.a=parseInt(n.substring(7,9),16)/255)),this}toLinearSpace(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=new A;return this.toLinearSpaceToRef(y,n),y}toLinearSpaceToRef(n){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(n.r=B(this.r),n.g=B(this.g),n.b=B(this.b)):(n.r=i(this.r),n.g=i(this.g),n.b=i(this.b)),n.a=this.a,this}toGammaSpace(){let n=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const y=new A;return this.toGammaSpaceToRef(y,n),y}toGammaSpaceToRef(n){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(n.r=q(this.r),n.g=q(this.g),n.b=q(this.b)):(n.r=V(this.r),n.g=V(this.g),n.b=V(this.b)),n.a=this.a,this}static FromHexString(n){return"#"!==n.substring(0,1)||9!==n.length&&7!==n.length?new A(0,0,0,0):new A(0,0,0,1).fromHexString(n)}static Lerp(n,y,H){return A.LerpToRef(n,y,H,new A)}static LerpToRef(n,y,H,o){return o.r=n.r+(y.r-n.r)*H,o.g=n.g+(y.g-n.g)*H,o.b=n.b+(y.b-n.b)*H,o.a=n.a+(y.a-n.a)*H,o}static Hermite(n,y,H,o,G){const h=G*G,k=G*h,i=2*k-3*h+1,B=-2*k+3*h,V=k-2*h+G,q=k-h,b=n.r*i+H.r*B+y.r*V+o.r*q,U=n.g*i+H.g*B+y.g*V+o.g*q,T=n.b*i+H.b*B+y.b*V+o.b*q,W=n.a*i+H.a*B+y.a*V+o.a*q;return new A(b,U,T,W)}static Hermite1stDerivative(n,y,H,o,G){const h=new A;return this.Hermite1stDerivativeToRef(n,y,H,o,G,h),h}static Hermite1stDerivativeToRef(n,y,H,o,G,h){const k=G*G;h.r=6*(k-G)*n.r+(3*k-4*G+1)*y.r+6*(-k+G)*H.r+(3*k-2*G)*o.r,h.g=6*(k-G)*n.g+(3*k-4*G+1)*y.g+6*(-k+G)*H.g+(3*k-2*G)*o.g,h.b=6*(k-G)*n.b+(3*k-4*G+1)*y.b+6*(-k+G)*H.b+(3*k-2*G)*o.b,h.a=6*(k-G)*n.a+(3*k-4*G+1)*y.a+6*(-k+G)*H.a+(3*k-2*G)*o.a}static FromColor3(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A(n.r,n.g,n.b,y)}static gy(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(n[y],n[y+1],n[y+2],n[y+3])}static FromArrayToRef(n){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,H=arguments.length>2?arguments[2]:void 0;H.r=n[y],H.g=n[y+1],H.b=n[y+2],H.a=n[y+3]}static FromInts(n,y,H,o){return new A(n/255,y/255,H/255,o/255)}static CheckColors4(n,y){if(n.length===3*y){const y=[];for(let H=0;H<n.length;H+=3){const o=H/3*4;y[o]=n[H],y[o+1]=n[H+1],y[o+2]=n[H+2],y[o+3]=1}return y}return n}}A._V8PerformanceHack=new A(.5,.5,.5,.5),Object.defineProperties(A.prototype,{dimension:{value:[4]},rank:{value:1}});class U{}U.Fy=(0,o.c)(3,b.Black),U.pi=(0,o.c)(3,(()=>new A(0,0,0,0))),(0,G.h)("BABYLON.Color3",b),(0,G.h)("BABYLON.Color4",A)}}]);