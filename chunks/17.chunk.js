"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[17],{12518:(u,R,I)=>{I.r(R),I.d(R,{fR:()=>S,TD:()=>b,TmpColors:()=>r});var B=I(12487),U=I(12433),K=I(12485),C=I(12491);function D(u){return Math.pow(u,K.l)}function s(u){return u<=.04045?.0773993808*u:Math.pow(.947867299*(u+.055),2.4)}function t(u){return Math.pow(u,K.j)}function G(u){return u<=.0031308?12.92*u:1.055*Math.pow(u,.41666)-.055}class S{constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=u,this.g=R,this.b=I}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"fR"}getHashCode(){let u=255*this.r|0;return u=397*u^255*this.g,u=397*u^255*this.b,u}toArray(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u[R]=this.r,u[R+1]=this.g,u[R+2]=this.b,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(u,R,this),this}toColor4(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new b(this.r,this.g,this.b,u)}sD(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(u){return new S(this.r*u.r,this.g*u.g,this.b*u.b)}multiplyToRef(u,R){return R.r=this.r*u.r,R.g=this.g*u.g,R.b=this.b*u.b,R}multiplyInPlace(u){return this.r*=u.r,this.g*=u.g,this.b*=u.b,this}multiplyByFloats(u,R,I){return new S(this.r*u,this.g*R,this.b*I)}divide(u){throw new ReferenceError("Can not divide a color")}divideToRef(u,R){throw new ReferenceError("Can not divide a color")}divideInPlace(u){throw new ReferenceError("Can not divide a color")}minimizeInPlace(u){return this.minimizeInPlaceFromFloats(u.r,u.g,u.b)}maximizeInPlace(u){return this.maximizeInPlaceFromFloats(u.r,u.g,u.b)}minimizeInPlaceFromFloats(u,R,I){return this.r=Math.min(u,this.r),this.g=Math.min(R,this.g),this.b=Math.min(I,this.b),this}maximizeInPlaceFromFloats(u,R,I){return this.r=Math.max(u,this.r),this.g=Math.max(R,this.g),this.b=Math.max(I,this.b),this}floorToRef(u){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(u){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(u){return u&&this.r===u.r&&this.g===u.g&&this.b===u.b}equalsFloats(u,R,I){return this.equalsToFloats(u,R,I)}equalsToFloats(u,R,I){return this.r===u&&this.g===R&&this.b===I}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.c;return(0,C.WithinEpsilon)(this.r,u.r,R)&&(0,C.WithinEpsilon)(this.g,u.g,R)&&(0,C.WithinEpsilon)(this.b,u.b,R)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(u){throw new ReferenceError("Can not negate a color")}scale(u){return new S(this.r*u,this.g*u,this.b*u)}scaleInPlace(u){return this.r*=u,this.g*=u,this.b*=u,this}scaleToRef(u,R){return R.r=this.r*u,R.g=this.g*u,R.b=this.b*u,R}scaleAndAddToRef(u,R){return R.r+=this.r*u,R.g+=this.g*u,R.b+=this.b*u,R}clampToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.r=(0,C.Clamp)(this.r,u,R),I.g=(0,C.Clamp)(this.g,u,R),I.b=(0,C.Clamp)(this.b,u,R),I}add(u){return new S(this.r+u.r,this.g+u.g,this.b+u.b)}addInPlace(u){return this.r+=u.r,this.g+=u.g,this.b+=u.b,this}addInPlaceFromFloats(u,R,I){return this.r+=u,this.g+=R,this.b+=I,this}addToRef(u,R){return R.r=this.r+u.r,R.g=this.g+u.g,R.b=this.b+u.b,R}XR(u){return new S(this.r-u.r,this.g-u.g,this.b-u.b)}subtractToRef(u,R){return R.r=this.r-u.r,R.g=this.g-u.g,R.b=this.b-u.b,R}RS(u){return this.r-=u.r,this.g-=u.g,this.b-=u.b,this}subtractFromFloats(u,R,I){return new S(this.r-u,this.g-R,this.b-I)}subtractFromFloatsToRef(u,R,I,B){return B.r=this.r-u,B.g=this.g-R,B.b=this.b-I,B}clone(){return new S(this.r,this.g,this.b)}B(u){return this.r=u.r,this.g=u.g,this.b=u.b,this}ED(u,R,I){return this.r=u,this.g=R,this.b=I,this}set(u,R,I){return this.ED(u,R,I)}fD(u){return this.r=this.g=this.b=u,this}toHexString(){const u=Math.round(255*this.r),R=Math.round(255*this.g),I=Math.round(255*this.b);return"#"+(0,C.ToHex)(u)+(0,C.ToHex)(R)+(0,C.ToHex)(I)}fromHexString(u){return"#"!==u.substring(0,1)||7!==u.length||(this.r=parseInt(u.substring(1,3),16)/255,this.g=parseInt(u.substring(3,5),16)/255,this.b=parseInt(u.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new S)}toHSVToRef(u){const R=this.r,I=this.g,B=this.b,U=Math.max(R,I,B),K=Math.min(R,I,B);let C=0,D=0;const s=U,t=U-K;return 0!==U&&(D=t/U),U!=K&&(U==R?(C=(I-B)/t,I<B&&(C+=6)):U==I?C=(B-R)/t+2:U==B&&(C=(R-I)/t+4),C*=60),u.r=C,u.g=D,u.b=s,u}toLinearSpace(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new S;return this.toLinearSpaceToRef(R,u),R}toLinearSpaceToRef(u){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(u.r=s(this.r),u.g=s(this.g),u.b=s(this.b)):(u.r=D(this.r),u.g=D(this.g),u.b=D(this.b)),this}toGammaSpace(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new S;return this.toGammaSpaceToRef(R,u),R}toGammaSpaceToRef(u){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(u.r=G(this.r),u.g=G(this.g),u.b=G(this.b)):(u.r=t(this.r),u.g=t(this.g),u.b=t(this.b)),this}static HSVtoRGBToRef(u,R,I,B){const U=I*R,K=u/60,C=U*(1-Math.abs(K%2-1));let D=0,s=0,t=0;K>=0&&K<=1?(D=U,s=C):K>=1&&K<=2?(D=C,s=U):K>=2&&K<=3?(s=U,t=C):K>=3&&K<=4?(s=C,t=U):K>=4&&K<=5?(D=C,t=U):K>=5&&K<=6&&(D=U,t=C);const G=I-U;return B.r=D+G,B.g=s+G,B.b=t+G,B}static FromHSV(u,R,I){const B=new S(0,0,0);return S.HSVtoRGBToRef(u,R,I,B),B}static FromHexString(u){return new S(0,0,0).fromHexString(u)}static TR(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(u[R],u[R+1],u[R+2])}static FromArrayToRef(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2?arguments[2]:void 0;I.r=u[R],I.g=u[R+1],I.b=u[R+2]}static FromInts(u,R,I){return new S(u/255,R/255,I/255)}static Lerp(u,R,I){const B=new S(0,0,0);return S.LerpToRef(u,R,I,B),B}static LerpToRef(u,R,I,B){B.r=u.r+(R.r-u.r)*I,B.g=u.g+(R.g-u.g)*I,B.b=u.b+(R.b-u.b)*I}static Hermite(u,R,I,B,U){const K=U*U,C=U*K,D=2*C-3*K+1,s=-2*C+3*K,t=C-2*K+U,G=C-K,b=u.r*D+I.r*s+R.r*t+B.r*G,r=u.g*D+I.g*s+R.g*t+B.g*G,P=u.b*D+I.b*s+R.b*t+B.b*G;return new S(b,r,P)}static Hermite1stDerivative(u,R,I,B,U){const K=S.Black();return this.Hermite1stDerivativeToRef(u,R,I,B,U,K),K}static Hermite1stDerivativeToRef(u,R,I,B,U,K){const C=U*U;K.r=6*(C-U)*u.r+(3*C-4*U+1)*R.r+6*(-C+U)*I.r+(3*C-2*U)*B.r,K.g=6*(C-U)*u.g+(3*C-4*U+1)*R.g+6*(-C+U)*I.g+(3*C-2*U)*B.g,K.b=6*(C-U)*u.b+(3*C-4*U+1)*R.b+6*(-C+U)*I.b+(3*C-2*U)*B.b}static Red(){return new S(1,0,0)}static Green(){return new S(0,1,0)}static Blue(){return new S(0,0,1)}static Black(){return new S(0,0,0)}static get BlackReadOnly(){return S._BlackReadOnly}static White(){return new S(1,1,1)}static Purple(){return new S(.5,0,.5)}static Magenta(){return new S(1,0,1)}static Yellow(){return new S(1,1,0)}static Gray(){return new S(.5,.5,.5)}static Teal(){return new S(0,1,1)}static Random(){return new S(Math.random(),Math.random(),Math.random())}}S._V8PerformanceHack=new S(.5,.5,.5),S._BlackReadOnly=S.Black(),Object.defineProperties(S.prototype,{dimension:{value:[3]},rank:{value:1}});class b{constructor(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=u,this.g=R,this.b=I,this.a=B}sD(){return[this.r,this.g,this.b,this.a]}toArray(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u[R]=this.r,u[R+1]=this.g,u[R+2]=this.b,u[R+3]=this.a,this}bI(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=u[R],this.g=u[R+1],this.b=u[R+2],this.a=u[R+3],this}equals(u){return u&&this.r===u.r&&this.g===u.g&&this.b===u.b&&this.a===u.a}add(u){return new b(this.r+u.r,this.g+u.g,this.b+u.b,this.a+u.a)}addToRef(u,R){return R.r=this.r+u.r,R.g=this.g+u.g,R.b=this.b+u.b,R.a=this.a+u.a,R}addInPlace(u){return this.r+=u.r,this.g+=u.g,this.b+=u.b,this.a+=u.a,this}addInPlaceFromFloats(u,R,I,B){return this.r+=u,this.g+=R,this.b+=I,this.a+=B,this}XR(u){return new b(this.r-u.r,this.g-u.g,this.b-u.b,this.a-u.a)}subtractToRef(u,R){return R.r=this.r-u.r,R.g=this.g-u.g,R.b=this.b-u.b,R.a=this.a-u.a,R}RS(u){return this.r-=u.r,this.g-=u.g,this.b-=u.b,this.a-=u.a,this}subtractFromFloats(u,R,I,B){return new b(this.r-u,this.g-R,this.b-I,this.a-B)}subtractFromFloatsToRef(u,R,I,B,U){return U.r=this.r-u,U.g=this.g-R,U.b=this.b-I,U.a=this.a-B,U}scale(u){return new b(this.r*u,this.g*u,this.b*u,this.a*u)}scaleInPlace(u){return this.r*=u,this.g*=u,this.b*=u,this.a*=u,this}scaleToRef(u,R){return R.r=this.r*u,R.g=this.g*u,R.b=this.b*u,R.a=this.a*u,R}scaleAndAddToRef(u,R){return R.r+=this.r*u,R.g+=this.g*u,R.b+=this.b*u,R.a+=this.a*u,R}clampToRef(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,I=arguments.length>2?arguments[2]:void 0;return I.r=(0,C.Clamp)(this.r,u,R),I.g=(0,C.Clamp)(this.g,u,R),I.b=(0,C.Clamp)(this.b,u,R),I.a=(0,C.Clamp)(this.a,u,R),I}multiply(u){return new b(this.r*u.r,this.g*u.g,this.b*u.b,this.a*u.a)}multiplyToRef(u,R){return R.r=this.r*u.r,R.g=this.g*u.g,R.b=this.b*u.b,R.a=this.a*u.a,R}multiplyInPlace(u){return this.r*=u.r,this.g*=u.g,this.b*=u.b,this.a*=u.a,this}multiplyByFloats(u,R,I,B){return new b(this.r*u,this.g*R,this.b*I,this.a*B)}divide(u){throw new ReferenceError("Can not divide a color")}divideToRef(u,R){throw new ReferenceError("Can not divide a color")}divideInPlace(u){throw new ReferenceError("Can not divide a color")}minimizeInPlace(u){return this.r=Math.min(this.r,u.r),this.g=Math.min(this.g,u.g),this.b=Math.min(this.b,u.b),this.a=Math.min(this.a,u.a),this}maximizeInPlace(u){return this.r=Math.max(this.r,u.r),this.g=Math.max(this.g,u.g),this.b=Math.max(this.b,u.b),this.a=Math.max(this.a,u.a),this}minimizeInPlaceFromFloats(u,R,I,B){return this.r=Math.min(u,this.r),this.g=Math.min(R,this.g),this.b=Math.min(I,this.b),this.a=Math.min(B,this.a),this}maximizeInPlaceFromFloats(u,R,I,B){return this.r=Math.max(u,this.r),this.g=Math.max(R,this.g),this.b=Math.max(I,this.b),this.a=Math.max(B,this.a),this}floorToRef(u){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(u){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(u){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.c;return(0,C.WithinEpsilon)(this.r,u.r,R)&&(0,C.WithinEpsilon)(this.g,u.g,R)&&(0,C.WithinEpsilon)(this.b,u.b,R)&&(0,C.WithinEpsilon)(this.a,u.a,R)}equalsToFloats(u,R,I,B){return this.r===u&&this.g===R&&this.b===I&&this.a===B}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"TD"}getHashCode(){let u=255*this.r|0;return u=397*u^255*this.g,u=397*u^255*this.b,u=397*u^255*this.a,u}clone(){return(new b).B(this)}B(u){return this.r=u.r,this.g=u.g,this.b=u.b,this.a=u.a,this}ED(u,R,I,B){return this.r=u,this.g=R,this.b=I,this.a=B,this}set(u,R,I,B){return this.ED(u,R,I,B)}fD(u){return this.r=this.g=this.b=this.a=u,this}toHexString(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=Math.round(255*this.r),I=Math.round(255*this.g),B=Math.round(255*this.b);if(u)return"#"+(0,C.ToHex)(R)+(0,C.ToHex)(I)+(0,C.ToHex)(B);const U=Math.round(255*this.a);return"#"+(0,C.ToHex)(R)+(0,C.ToHex)(I)+(0,C.ToHex)(B)+(0,C.ToHex)(U)}fromHexString(u){return"#"!==u.substring(0,1)||9!==u.length&&7!==u.length||(this.r=parseInt(u.substring(1,3),16)/255,this.g=parseInt(u.substring(3,5),16)/255,this.b=parseInt(u.substring(5,7),16)/255,9===u.length&&(this.a=parseInt(u.substring(7,9),16)/255)),this}toLinearSpace(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new b;return this.toLinearSpaceToRef(R,u),R}toLinearSpaceToRef(u){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(u.r=s(this.r),u.g=s(this.g),u.b=s(this.b)):(u.r=D(this.r),u.g=D(this.g),u.b=D(this.b)),u.a=this.a,this}toGammaSpace(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const R=new b;return this.toGammaSpaceToRef(R,u),R}toGammaSpaceToRef(u){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(u.r=G(this.r),u.g=G(this.g),u.b=G(this.b)):(u.r=t(this.r),u.g=t(this.g),u.b=t(this.b)),u.a=this.a,this}static FromHexString(u){return"#"!==u.substring(0,1)||9!==u.length&&7!==u.length?new b(0,0,0,0):new b(0,0,0,1).fromHexString(u)}static Lerp(u,R,I){return b.LerpToRef(u,R,I,new b)}static LerpToRef(u,R,I,B){return B.r=u.r+(R.r-u.r)*I,B.g=u.g+(R.g-u.g)*I,B.b=u.b+(R.b-u.b)*I,B.a=u.a+(R.a-u.a)*I,B}static Hermite(u,R,I,B,U){const K=U*U,C=U*K,D=2*C-3*K+1,s=-2*C+3*K,t=C-2*K+U,G=C-K,S=u.r*D+I.r*s+R.r*t+B.r*G,r=u.g*D+I.g*s+R.g*t+B.g*G,P=u.b*D+I.b*s+R.b*t+B.b*G,X=u.a*D+I.a*s+R.a*t+B.a*G;return new b(S,r,P,X)}static Hermite1stDerivative(u,R,I,B,U){const K=new b;return this.Hermite1stDerivativeToRef(u,R,I,B,U,K),K}static Hermite1stDerivativeToRef(u,R,I,B,U,K){const C=U*U;K.r=6*(C-U)*u.r+(3*C-4*U+1)*R.r+6*(-C+U)*I.r+(3*C-2*U)*B.r,K.g=6*(C-U)*u.g+(3*C-4*U+1)*R.g+6*(-C+U)*I.g+(3*C-2*U)*B.g,K.b=6*(C-U)*u.b+(3*C-4*U+1)*R.b+6*(-C+U)*I.b+(3*C-2*U)*B.b,K.a=6*(C-U)*u.a+(3*C-4*U+1)*R.a+6*(-C+U)*I.a+(3*C-2*U)*B.a}static FromColor3(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b(u.r,u.g,u.b,R)}static TR(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(u[R],u[R+1],u[R+2],u[R+3])}static FromArrayToRef(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2?arguments[2]:void 0;I.r=u[R],I.g=u[R+1],I.b=u[R+2],I.a=u[R+3]}static FromInts(u,R,I,B){return new b(u/255,R/255,I/255,B/255)}static CheckColors4(u,R){if(u.length===3*R){const R=[];for(let I=0;I<u.length;I+=3){const B=I/3*4;R[B]=u[I],R[B+1]=u[I+1],R[B+2]=u[I+2],R[B+3]=1}return R}return u}}b._V8PerformanceHack=new b(.5,.5,.5,.5),Object.defineProperties(b.prototype,{dimension:{value:[4]},rank:{value:1}});class r{}r.fR=(0,B.d)(3,S.Black),r.TD=(0,B.d)(3,(()=>new b(0,0,0,0))),(0,U.e)("BABYLON.Color3",S),(0,U.e)("BABYLON.Color4",b)}}]);