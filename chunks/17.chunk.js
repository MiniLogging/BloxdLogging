"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[17],{11878:(b,X,P)=>{P.r(X),P.d(X,{yX:()=>O,Ba:()=>e,TmpColors:()=>Y});var Q=P(11841),S=P(11802),d=P(11836),N=P(11844);function a(b){return Math.pow(b,d.k)}function u(b){return b<=.04045?.0773993808*b:Math.pow(.947867299*(b+.055),2.4)}function w(b){return Math.pow(b,d.j)}function f(b){return b<=.0031308?12.92*b:1.055*Math.pow(b,.41666)-.055}class O{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=b,this.g=X,this.b=P}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"yX"}getHashCode(){let b=255*this.r|0;return b=397*b^255*this.g,b=397*b^255*this.b,b}toArray(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[X]=this.r,b[X+1]=this.g,b[X+2]=this.b,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(b,X,this),this}toColor4(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new e(this.r,this.g,this.b,b)}Zd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(b){return new O(this.r*b.r,this.g*b.g,this.b*b.b)}multiplyToRef(b,X){return X.r=this.r*b.r,X.g=this.g*b.g,X.b=this.b*b.b,X}multiplyInPlace(b){return this.r*=b.r,this.g*=b.g,this.b*=b.b,this}multiplyByFloats(b,X,P){return new O(this.r*b,this.g*X,this.b*P)}divide(b){throw new ReferenceError("Can not divide a color")}divideToRef(b,X){throw new ReferenceError("Can not divide a color")}divideInPlace(b){throw new ReferenceError("Can not divide a color")}minimizeInPlace(b){return this.minimizeInPlaceFromFloats(b.r,b.g,b.b)}maximizeInPlace(b){return this.maximizeInPlaceFromFloats(b.r,b.g,b.b)}minimizeInPlaceFromFloats(b,X,P){return this.r=Math.min(b,this.r),this.g=Math.min(X,this.g),this.b=Math.min(P,this.b),this}maximizeInPlaceFromFloats(b,X,P){return this.r=Math.max(b,this.r),this.g=Math.max(X,this.g),this.b=Math.max(P,this.b),this}floorToRef(b){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(b){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(b){return b&&this.r===b.r&&this.g===b.g&&this.b===b.b}equalsFloats(b,X,P){return this.equalsToFloats(b,X,P)}equalsToFloats(b,X,P){return this.r===b&&this.g===X&&this.b===P}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.c;return(0,N.WithinEpsilon)(this.r,b.r,X)&&(0,N.WithinEpsilon)(this.g,b.g,X)&&(0,N.WithinEpsilon)(this.b,b.b,X)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(b){throw new ReferenceError("Can not negate a color")}scale(b){return new O(this.r*b,this.g*b,this.b*b)}scaleInPlace(b){return this.r*=b,this.g*=b,this.b*=b,this}scaleToRef(b,X){return X.r=this.r*b,X.g=this.g*b,X.b=this.b*b,X}scaleAndAddToRef(b,X){return X.r+=this.r*b,X.g+=this.g*b,X.b+=this.b*b,X}clampToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,N.Clamp)(this.r,b,X),P.g=(0,N.Clamp)(this.g,b,X),P.b=(0,N.Clamp)(this.b,b,X),P}add(b){return new O(this.r+b.r,this.g+b.g,this.b+b.b)}addInPlace(b){return this.r+=b.r,this.g+=b.g,this.b+=b.b,this}addInPlaceFromFloats(b,X,P){return this.r+=b,this.g+=X,this.b+=P,this}addToRef(b,X){return X.r=this.r+b.r,X.g=this.g+b.g,X.b=this.b+b.b,X}BX(b){return new O(this.r-b.r,this.g-b.g,this.b-b.b)}subtractToRef(b,X){return X.r=this.r-b.r,X.g=this.g-b.g,X.b=this.b-b.b,X}fO(b){return this.r-=b.r,this.g-=b.g,this.b-=b.b,this}subtractFromFloats(b,X,P){return new O(this.r-b,this.g-X,this.b-P)}subtractFromFloatsToRef(b,X,P,Q){return Q.r=this.r-b,Q.g=this.g-X,Q.b=this.b-P,Q}clone(){return new O(this.r,this.g,this.b)}N(b){return this.r=b.r,this.g=b.g,this.b=b.b,this}sd(b,X,P){return this.r=b,this.g=X,this.b=P,this}set(b,X,P){return this.sd(b,X,P)}Gd(b){return this.r=this.g=this.b=b,this}toHexString(){const b=Math.round(255*this.r),X=Math.round(255*this.g),P=Math.round(255*this.b);return"#"+(0,N.ToHex)(b)+(0,N.ToHex)(X)+(0,N.ToHex)(P)}fromHexString(b){return"#"!==b.substring(0,1)||7!==b.length||(this.r=parseInt(b.substring(1,3),16)/255,this.g=parseInt(b.substring(3,5),16)/255,this.b=parseInt(b.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new O)}toHSVToRef(b){const X=this.r,P=this.g,Q=this.b,S=Math.max(X,P,Q),d=Math.min(X,P,Q);let N=0,a=0;const u=S,w=S-d;return 0!==S&&(a=w/S),S!=d&&(S==X?(N=(P-Q)/w,P<Q&&(N+=6)):S==P?N=(Q-X)/w+2:S==Q&&(N=(X-P)/w+4),N*=60),b.r=N,b.g=a,b.b=u,b}toLinearSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new O;return this.toLinearSpaceToRef(X,b),X}toLinearSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=u(this.r),b.g=u(this.g),b.b=u(this.b)):(b.r=a(this.r),b.g=a(this.g),b.b=a(this.b)),this}toGammaSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new O;return this.toGammaSpaceToRef(X,b),X}toGammaSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=f(this.r),b.g=f(this.g),b.b=f(this.b)):(b.r=w(this.r),b.g=w(this.g),b.b=w(this.b)),this}static HSVtoRGBToRef(b,X,P,Q){const S=P*X,d=b/60,N=S*(1-Math.abs(d%2-1));let a=0,u=0,w=0;d>=0&&d<=1?(a=S,u=N):d>=1&&d<=2?(a=N,u=S):d>=2&&d<=3?(u=S,w=N):d>=3&&d<=4?(u=N,w=S):d>=4&&d<=5?(a=N,w=S):d>=5&&d<=6&&(a=S,w=N);const f=P-S;return Q.r=a+f,Q.g=u+f,Q.b=w+f,Q}static FromHSV(b,X,P){const Q=new O(0,0,0);return O.HSVtoRGBToRef(b,X,P,Q),Q}static FromHexString(b){return new O(0,0,0).fromHexString(b)}static hX(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(b[X],b[X+1],b[X+2])}static FromArrayToRef(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=b[X],P.g=b[X+1],P.b=b[X+2]}static FromInts(b,X,P){return new O(b/255,X/255,P/255)}static Lerp(b,X,P){const Q=new O(0,0,0);return O.LerpToRef(b,X,P,Q),Q}static LerpToRef(b,X,P,Q){Q.r=b.r+(X.r-b.r)*P,Q.g=b.g+(X.g-b.g)*P,Q.b=b.b+(X.b-b.b)*P}static Hermite(b,X,P,Q,S){const d=S*S,N=S*d,a=2*N-3*d+1,u=-2*N+3*d,w=N-2*d+S,f=N-d,e=b.r*a+P.r*u+X.r*w+Q.r*f,Y=b.g*a+P.g*u+X.g*w+Q.g*f,D=b.b*a+P.b*u+X.b*w+Q.b*f;return new O(e,Y,D)}static Hermite1stDerivative(b,X,P,Q,S){const d=O.Black();return this.Hermite1stDerivativeToRef(b,X,P,Q,S,d),d}static Hermite1stDerivativeToRef(b,X,P,Q,S,d){const N=S*S;d.r=6*(N-S)*b.r+(3*N-4*S+1)*X.r+6*(-N+S)*P.r+(3*N-2*S)*Q.r,d.g=6*(N-S)*b.g+(3*N-4*S+1)*X.g+6*(-N+S)*P.g+(3*N-2*S)*Q.g,d.b=6*(N-S)*b.b+(3*N-4*S+1)*X.b+6*(-N+S)*P.b+(3*N-2*S)*Q.b}static Red(){return new O(1,0,0)}static Green(){return new O(0,1,0)}static Blue(){return new O(0,0,1)}static Black(){return new O(0,0,0)}static get BlackReadOnly(){return O._BlackReadOnly}static White(){return new O(1,1,1)}static Purple(){return new O(.5,0,.5)}static Magenta(){return new O(1,0,1)}static Yellow(){return new O(1,1,0)}static Gray(){return new O(.5,.5,.5)}static Teal(){return new O(0,1,1)}static Random(){return new O(Math.random(),Math.random(),Math.random())}}O._V8PerformanceHack=new O(.5,.5,.5),O._BlackReadOnly=O.Black(),Object.defineProperties(O.prototype,{dimension:{value:[3]},rank:{value:1}});class e{constructor(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=b,this.g=X,this.b=P,this.a=Q}Zd(){return[this.r,this.g,this.b,this.a]}toArray(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return b[X]=this.r,b[X+1]=this.g,b[X+2]=this.b,b[X+3]=this.a,this}tP(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=b[X],this.g=b[X+1],this.b=b[X+2],this.a=b[X+3],this}equals(b){return b&&this.r===b.r&&this.g===b.g&&this.b===b.b&&this.a===b.a}add(b){return new e(this.r+b.r,this.g+b.g,this.b+b.b,this.a+b.a)}addToRef(b,X){return X.r=this.r+b.r,X.g=this.g+b.g,X.b=this.b+b.b,X.a=this.a+b.a,X}addInPlace(b){return this.r+=b.r,this.g+=b.g,this.b+=b.b,this.a+=b.a,this}addInPlaceFromFloats(b,X,P,Q){return this.r+=b,this.g+=X,this.b+=P,this.a+=Q,this}BX(b){return new e(this.r-b.r,this.g-b.g,this.b-b.b,this.a-b.a)}subtractToRef(b,X){return X.r=this.r-b.r,X.g=this.g-b.g,X.b=this.b-b.b,X.a=this.a-b.a,X}fO(b){return this.r-=b.r,this.g-=b.g,this.b-=b.b,this.a-=b.a,this}subtractFromFloats(b,X,P,Q){return new e(this.r-b,this.g-X,this.b-P,this.a-Q)}subtractFromFloatsToRef(b,X,P,Q,S){return S.r=this.r-b,S.g=this.g-X,S.b=this.b-P,S.a=this.a-Q,S}scale(b){return new e(this.r*b,this.g*b,this.b*b,this.a*b)}scaleInPlace(b){return this.r*=b,this.g*=b,this.b*=b,this.a*=b,this}scaleToRef(b,X){return X.r=this.r*b,X.g=this.g*b,X.b=this.b*b,X.a=this.a*b,X}scaleAndAddToRef(b,X){return X.r+=this.r*b,X.g+=this.g*b,X.b+=this.b*b,X.a+=this.a*b,X}clampToRef(){let b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,N.Clamp)(this.r,b,X),P.g=(0,N.Clamp)(this.g,b,X),P.b=(0,N.Clamp)(this.b,b,X),P.a=(0,N.Clamp)(this.a,b,X),P}multiply(b){return new e(this.r*b.r,this.g*b.g,this.b*b.b,this.a*b.a)}multiplyToRef(b,X){return X.r=this.r*b.r,X.g=this.g*b.g,X.b=this.b*b.b,X.a=this.a*b.a,X}multiplyInPlace(b){return this.r*=b.r,this.g*=b.g,this.b*=b.b,this.a*=b.a,this}multiplyByFloats(b,X,P,Q){return new e(this.r*b,this.g*X,this.b*P,this.a*Q)}divide(b){throw new ReferenceError("Can not divide a color")}divideToRef(b,X){throw new ReferenceError("Can not divide a color")}divideInPlace(b){throw new ReferenceError("Can not divide a color")}minimizeInPlace(b){return this.r=Math.min(this.r,b.r),this.g=Math.min(this.g,b.g),this.b=Math.min(this.b,b.b),this.a=Math.min(this.a,b.a),this}maximizeInPlace(b){return this.r=Math.max(this.r,b.r),this.g=Math.max(this.g,b.g),this.b=Math.max(this.b,b.b),this.a=Math.max(this.a,b.a),this}minimizeInPlaceFromFloats(b,X,P,Q){return this.r=Math.min(b,this.r),this.g=Math.min(X,this.g),this.b=Math.min(P,this.b),this.a=Math.min(Q,this.a),this}maximizeInPlaceFromFloats(b,X,P,Q){return this.r=Math.max(b,this.r),this.g=Math.max(X,this.g),this.b=Math.max(P,this.b),this.a=Math.max(Q,this.a),this}floorToRef(b){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(b){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(b){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:d.c;return(0,N.WithinEpsilon)(this.r,b.r,X)&&(0,N.WithinEpsilon)(this.g,b.g,X)&&(0,N.WithinEpsilon)(this.b,b.b,X)&&(0,N.WithinEpsilon)(this.a,b.a,X)}equalsToFloats(b,X,P,Q){return this.r===b&&this.g===X&&this.b===P&&this.a===Q}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Ba"}getHashCode(){let b=255*this.r|0;return b=397*b^255*this.g,b=397*b^255*this.b,b=397*b^255*this.a,b}clone(){return(new e).N(this)}N(b){return this.r=b.r,this.g=b.g,this.b=b.b,this.a=b.a,this}sd(b,X,P,Q){return this.r=b,this.g=X,this.b=P,this.a=Q,this}set(b,X,P,Q){return this.sd(b,X,P,Q)}Gd(b){return this.r=this.g=this.b=this.a=b,this}toHexString(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=Math.round(255*this.r),P=Math.round(255*this.g),Q=Math.round(255*this.b);if(b)return"#"+(0,N.ToHex)(X)+(0,N.ToHex)(P)+(0,N.ToHex)(Q);const S=Math.round(255*this.a);return"#"+(0,N.ToHex)(X)+(0,N.ToHex)(P)+(0,N.ToHex)(Q)+(0,N.ToHex)(S)}fromHexString(b){return"#"!==b.substring(0,1)||9!==b.length&&7!==b.length||(this.r=parseInt(b.substring(1,3),16)/255,this.g=parseInt(b.substring(3,5),16)/255,this.b=parseInt(b.substring(5,7),16)/255,9===b.length&&(this.a=parseInt(b.substring(7,9),16)/255)),this}toLinearSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new e;return this.toLinearSpaceToRef(X,b),X}toLinearSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=u(this.r),b.g=u(this.g),b.b=u(this.b)):(b.r=a(this.r),b.g=a(this.g),b.b=a(this.b)),b.a=this.a,this}toGammaSpace(){let b=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new e;return this.toGammaSpaceToRef(X,b),X}toGammaSpaceToRef(b){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(b.r=f(this.r),b.g=f(this.g),b.b=f(this.b)):(b.r=w(this.r),b.g=w(this.g),b.b=w(this.b)),b.a=this.a,this}static FromHexString(b){return"#"!==b.substring(0,1)||9!==b.length&&7!==b.length?new e(0,0,0,0):new e(0,0,0,1).fromHexString(b)}static Lerp(b,X,P){return e.LerpToRef(b,X,P,new e)}static LerpToRef(b,X,P,Q){return Q.r=b.r+(X.r-b.r)*P,Q.g=b.g+(X.g-b.g)*P,Q.b=b.b+(X.b-b.b)*P,Q.a=b.a+(X.a-b.a)*P,Q}static Hermite(b,X,P,Q,S){const d=S*S,N=S*d,a=2*N-3*d+1,u=-2*N+3*d,w=N-2*d+S,f=N-d,O=b.r*a+P.r*u+X.r*w+Q.r*f,Y=b.g*a+P.g*u+X.g*w+Q.g*f,D=b.b*a+P.b*u+X.b*w+Q.b*f,E=b.a*a+P.a*u+X.a*w+Q.a*f;return new e(O,Y,D,E)}static Hermite1stDerivative(b,X,P,Q,S){const d=new e;return this.Hermite1stDerivativeToRef(b,X,P,Q,S,d),d}static Hermite1stDerivativeToRef(b,X,P,Q,S,d){const N=S*S;d.r=6*(N-S)*b.r+(3*N-4*S+1)*X.r+6*(-N+S)*P.r+(3*N-2*S)*Q.r,d.g=6*(N-S)*b.g+(3*N-4*S+1)*X.g+6*(-N+S)*P.g+(3*N-2*S)*Q.g,d.b=6*(N-S)*b.b+(3*N-4*S+1)*X.b+6*(-N+S)*P.b+(3*N-2*S)*Q.b,d.a=6*(N-S)*b.a+(3*N-4*S+1)*X.a+6*(-N+S)*P.a+(3*N-2*S)*Q.a}static FromColor3(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e(b.r,b.g,b.b,X)}static hX(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(b[X],b[X+1],b[X+2],b[X+3])}static FromArrayToRef(b){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=b[X],P.g=b[X+1],P.b=b[X+2],P.a=b[X+3]}static FromInts(b,X,P,Q){return new e(b/255,X/255,P/255,Q/255)}static CheckColors4(b,X){if(b.length===3*X){const X=[];for(let P=0;P<b.length;P+=3){const Q=P/3*4;X[Q]=b[P],X[Q+1]=b[P+1],X[Q+2]=b[P+2],X[Q+3]=1}return X}return b}}e._V8PerformanceHack=new e(.5,.5,.5,.5),Object.defineProperties(e.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{}Y.yX=(0,Q.b)(3,O.Black),Y.Ba=(0,Q.b)(3,(()=>new e(0,0,0,0))),(0,S.h)("BABYLON.Color3",O),(0,S.h)("BABYLON.Color4",e)}}]);