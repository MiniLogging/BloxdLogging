"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[17],{12307:(I,O,C)=>{C.r(O),C.d(O,{WO:()=>Q,TS:()=>s,TmpColors:()=>Z});var j=C(12276),K=C(12226),i=C(12274),y=C(12282);function S(I){return Math.pow(I,i.j)}function U(I){return I<=.04045?.0773993808*I:Math.pow(.947867299*(I+.055),2.4)}function p(I){return Math.pow(I,i.i)}function N(I){return I<=.0031308?12.92*I:1.055*Math.pow(I,.41666)-.055}class Q{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=I,this.g=O,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"WO"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I}toArray(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[O]=this.r,I[O+1]=this.g,I[O+2]=this.b,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(I,O,this),this}toColor4(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new s(this.r,this.g,this.b,I)}qS(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(I){return new Q(this.r*I.r,this.g*I.g,this.b*I.b)}multiplyToRef(I,O){return O.r=this.r*I.r,O.g=this.g*I.g,O.b=this.b*I.b,O}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this}multiplyByFloats(I,O,C){return new Q(this.r*I,this.g*O,this.b*C)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,O){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.minimizeInPlaceFromFloats(I.r,I.g,I.b)}maximizeInPlace(I){return this.maximizeInPlaceFromFloats(I.r,I.g,I.b)}minimizeInPlaceFromFloats(I,O,C){return this.r=Math.min(I,this.r),this.g=Math.min(O,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(I,O,C){return this.r=Math.max(I,this.r),this.g=Math.max(O,this.g),this.b=Math.max(C,this.b),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b}equalsFloats(I,O,C){return this.equalsToFloats(I,O,C)}equalsToFloats(I,O,C){return this.r===I&&this.g===O&&this.b===C}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.d;return(0,y.WithinEpsilon)(this.r,I.r,O)&&(0,y.WithinEpsilon)(this.g,I.g,O)&&(0,y.WithinEpsilon)(this.b,I.b,O)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}scale(I){return new Q(this.r*I,this.g*I,this.b*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this}scaleToRef(I,O){return O.r=this.r*I,O.g=this.g*I,O.b=this.b*I,O}scaleAndAddToRef(I,O){return O.r+=this.r*I,O.g+=this.g*I,O.b+=this.b*I,O}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,y.Clamp)(this.r,I,O),C.g=(0,y.Clamp)(this.g,I,O),C.b=(0,y.Clamp)(this.b,I,O),C}add(I){return new Q(this.r+I.r,this.g+I.g,this.b+I.b)}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this}addInPlaceFromFloats(I,O,C){return this.r+=I,this.g+=O,this.b+=C,this}addToRef(I,O){return O.r=this.r+I.r,O.g=this.g+I.g,O.b=this.b+I.b,O}EO(I){return new Q(this.r-I.r,this.g-I.g,this.b-I.b)}subtractToRef(I,O){return O.r=this.r-I.r,O.g=this.g-I.g,O.b=this.b-I.b,O}OQ(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this}subtractFromFloats(I,O,C){return new Q(this.r-I,this.g-O,this.b-C)}subtractFromFloatsToRef(I,O,C,j){return j.r=this.r-I,j.g=this.g-O,j.b=this.b-C,j}clone(){return new Q(this.r,this.g,this.b)}K(I){return this.r=I.r,this.g=I.g,this.b=I.b,this}cS(I,O,C){return this.r=I,this.g=O,this.b=C,this}set(I,O,C){return this.cS(I,O,C)}XS(I){return this.r=this.g=this.b=I,this}toHexString(){const I=Math.round(255*this.r),O=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,y.ToHex)(I)+(0,y.ToHex)(O)+(0,y.ToHex)(C)}fromHexString(I){return"#"!==I.substring(0,1)||7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new Q)}toHSVToRef(I){const O=this.r,C=this.g,j=this.b,K=Math.max(O,C,j),i=Math.min(O,C,j);let y=0,S=0;const U=K,p=K-i;return 0!==K&&(S=p/K),K!=i&&(K==O?(y=(C-j)/p,C<j&&(y+=6)):K==C?y=(j-O)/p+2:K==j&&(y=(O-C)/p+4),y*=60),I.r=y,I.g=S,I.b=U,I}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new Q;return this.toLinearSpaceToRef(O,I),O}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=U(this.r),I.g=U(this.g),I.b=U(this.b)):(I.r=S(this.r),I.g=S(this.g),I.b=S(this.b)),this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new Q;return this.toGammaSpaceToRef(O,I),O}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=N(this.r),I.g=N(this.g),I.b=N(this.b)):(I.r=p(this.r),I.g=p(this.g),I.b=p(this.b)),this}static HSVtoRGBToRef(I,O,C,j){const K=C*O,i=I/60,y=K*(1-Math.abs(i%2-1));let S=0,U=0,p=0;i>=0&&i<=1?(S=K,U=y):i>=1&&i<=2?(S=y,U=K):i>=2&&i<=3?(U=K,p=y):i>=3&&i<=4?(U=y,p=K):i>=4&&i<=5?(S=y,p=K):i>=5&&i<=6&&(S=K,p=y);const N=C-K;return j.r=S+N,j.g=U+N,j.b=p+N,j}static FromHSV(I,O,C){const j=new Q(0,0,0);return Q.HSVtoRGBToRef(I,O,C,j),j}static FromHexString(I){return new Q(0,0,0).fromHexString(I)}static YO(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(I[O],I[O+1],I[O+2])}static FromArrayToRef(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=I[O],C.g=I[O+1],C.b=I[O+2]}static FromInts(I,O,C){return new Q(I/255,O/255,C/255)}static Lerp(I,O,C){const j=new Q(0,0,0);return Q.LerpToRef(I,O,C,j),j}static LerpToRef(I,O,C,j){j.r=I.r+(O.r-I.r)*C,j.g=I.g+(O.g-I.g)*C,j.b=I.b+(O.b-I.b)*C}static Hermite(I,O,C,j,K){const i=K*K,y=K*i,S=2*y-3*i+1,U=-2*y+3*i,p=y-2*i+K,N=y-i,s=I.r*S+C.r*U+O.r*p+j.r*N,Z=I.g*S+C.g*U+O.g*p+j.g*N,q=I.b*S+C.b*U+O.b*p+j.b*N;return new Q(s,Z,q)}static Hermite1stDerivative(I,O,C,j,K){const i=Q.Black();return this.Hermite1stDerivativeToRef(I,O,C,j,K,i),i}static Hermite1stDerivativeToRef(I,O,C,j,K,i){const y=K*K;i.r=6*(y-K)*I.r+(3*y-4*K+1)*O.r+6*(-y+K)*C.r+(3*y-2*K)*j.r,i.g=6*(y-K)*I.g+(3*y-4*K+1)*O.g+6*(-y+K)*C.g+(3*y-2*K)*j.g,i.b=6*(y-K)*I.b+(3*y-4*K+1)*O.b+6*(-y+K)*C.b+(3*y-2*K)*j.b}static Red(){return new Q(1,0,0)}static Green(){return new Q(0,1,0)}static Blue(){return new Q(0,0,1)}static Black(){return new Q(0,0,0)}static get BlackReadOnly(){return Q._BlackReadOnly}static White(){return new Q(1,1,1)}static Purple(){return new Q(.5,0,.5)}static Magenta(){return new Q(1,0,1)}static Yellow(){return new Q(1,1,0)}static Gray(){return new Q(.5,.5,.5)}static Teal(){return new Q(0,1,1)}static Random(){return new Q(Math.random(),Math.random(),Math.random())}}Q._V8PerformanceHack=new Q(.5,.5,.5),Q._BlackReadOnly=Q.Black(),Object.defineProperties(Q.prototype,{dimension:{value:[3]},rank:{value:1}});class s{constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=I,this.g=O,this.b=C,this.a=j}qS(){return[this.r,this.g,this.b,this.a]}toArray(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I[O]=this.r,I[O+1]=this.g,I[O+2]=this.b,I[O+3]=this.a,this}qC(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=I[O],this.g=I[O+1],this.b=I[O+2],this.a=I[O+3],this}equals(I){return I&&this.r===I.r&&this.g===I.g&&this.b===I.b&&this.a===I.a}add(I){return new s(this.r+I.r,this.g+I.g,this.b+I.b,this.a+I.a)}addToRef(I,O){return O.r=this.r+I.r,O.g=this.g+I.g,O.b=this.b+I.b,O.a=this.a+I.a,O}addInPlace(I){return this.r+=I.r,this.g+=I.g,this.b+=I.b,this.a+=I.a,this}addInPlaceFromFloats(I,O,C,j){return this.r+=I,this.g+=O,this.b+=C,this.a+=j,this}EO(I){return new s(this.r-I.r,this.g-I.g,this.b-I.b,this.a-I.a)}subtractToRef(I,O){return O.r=this.r-I.r,O.g=this.g-I.g,O.b=this.b-I.b,O.a=this.a-I.a,O}OQ(I){return this.r-=I.r,this.g-=I.g,this.b-=I.b,this.a-=I.a,this}subtractFromFloats(I,O,C,j){return new s(this.r-I,this.g-O,this.b-C,this.a-j)}subtractFromFloatsToRef(I,O,C,j,K){return K.r=this.r-I,K.g=this.g-O,K.b=this.b-C,K.a=this.a-j,K}scale(I){return new s(this.r*I,this.g*I,this.b*I,this.a*I)}scaleInPlace(I){return this.r*=I,this.g*=I,this.b*=I,this.a*=I,this}scaleToRef(I,O){return O.r=this.r*I,O.g=this.g*I,O.b=this.b*I,O.a=this.a*I,O}scaleAndAddToRef(I,O){return O.r+=this.r*I,O.g+=this.g*I,O.b+=this.b*I,O.a+=this.a*I,O}clampToRef(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,y.Clamp)(this.r,I,O),C.g=(0,y.Clamp)(this.g,I,O),C.b=(0,y.Clamp)(this.b,I,O),C.a=(0,y.Clamp)(this.a,I,O),C}multiply(I){return new s(this.r*I.r,this.g*I.g,this.b*I.b,this.a*I.a)}multiplyToRef(I,O){return O.r=this.r*I.r,O.g=this.g*I.g,O.b=this.b*I.b,O.a=this.a*I.a,O}multiplyInPlace(I){return this.r*=I.r,this.g*=I.g,this.b*=I.b,this.a*=I.a,this}multiplyByFloats(I,O,C,j){return new s(this.r*I,this.g*O,this.b*C,this.a*j)}divide(I){throw new ReferenceError("Can not divide a color")}divideToRef(I,O){throw new ReferenceError("Can not divide a color")}divideInPlace(I){throw new ReferenceError("Can not divide a color")}minimizeInPlace(I){return this.r=Math.min(this.r,I.r),this.g=Math.min(this.g,I.g),this.b=Math.min(this.b,I.b),this.a=Math.min(this.a,I.a),this}maximizeInPlace(I){return this.r=Math.max(this.r,I.r),this.g=Math.max(this.g,I.g),this.b=Math.max(this.b,I.b),this.a=Math.max(this.a,I.a),this}minimizeInPlaceFromFloats(I,O,C,j){return this.r=Math.min(I,this.r),this.g=Math.min(O,this.g),this.b=Math.min(C,this.b),this.a=Math.min(j,this.a),this}maximizeInPlaceFromFloats(I,O,C,j){return this.r=Math.max(I,this.r),this.g=Math.max(O,this.g),this.b=Math.max(C,this.b),this.a=Math.max(j,this.a),this}floorToRef(I){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(I){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(I){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.d;return(0,y.WithinEpsilon)(this.r,I.r,O)&&(0,y.WithinEpsilon)(this.g,I.g,O)&&(0,y.WithinEpsilon)(this.b,I.b,O)&&(0,y.WithinEpsilon)(this.a,I.a,O)}equalsToFloats(I,O,C,j){return this.r===I&&this.g===O&&this.b===C&&this.a===j}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"TS"}getHashCode(){let I=255*this.r|0;return I=397*I^255*this.g,I=397*I^255*this.b,I=397*I^255*this.a,I}clone(){return(new s).K(this)}K(I){return this.r=I.r,this.g=I.g,this.b=I.b,this.a=I.a,this}cS(I,O,C,j){return this.r=I,this.g=O,this.b=C,this.a=j,this}set(I,O,C,j){return this.cS(I,O,C,j)}XS(I){return this.r=this.g=this.b=this.a=I,this}toHexString(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=Math.round(255*this.r),C=Math.round(255*this.g),j=Math.round(255*this.b);if(I)return"#"+(0,y.ToHex)(O)+(0,y.ToHex)(C)+(0,y.ToHex)(j);const K=Math.round(255*this.a);return"#"+(0,y.ToHex)(O)+(0,y.ToHex)(C)+(0,y.ToHex)(j)+(0,y.ToHex)(K)}fromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length||(this.r=parseInt(I.substring(1,3),16)/255,this.g=parseInt(I.substring(3,5),16)/255,this.b=parseInt(I.substring(5,7),16)/255,9===I.length&&(this.a=parseInt(I.substring(7,9),16)/255)),this}toLinearSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new s;return this.toLinearSpaceToRef(O,I),O}toLinearSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=U(this.r),I.g=U(this.g),I.b=U(this.b)):(I.r=S(this.r),I.g=S(this.g),I.b=S(this.b)),I.a=this.a,this}toGammaSpace(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new s;return this.toGammaSpaceToRef(O,I),O}toGammaSpaceToRef(I){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(I.r=N(this.r),I.g=N(this.g),I.b=N(this.b)):(I.r=p(this.r),I.g=p(this.g),I.b=p(this.b)),I.a=this.a,this}static FromHexString(I){return"#"!==I.substring(0,1)||9!==I.length&&7!==I.length?new s(0,0,0,0):new s(0,0,0,1).fromHexString(I)}static Lerp(I,O,C){return s.LerpToRef(I,O,C,new s)}static LerpToRef(I,O,C,j){return j.r=I.r+(O.r-I.r)*C,j.g=I.g+(O.g-I.g)*C,j.b=I.b+(O.b-I.b)*C,j.a=I.a+(O.a-I.a)*C,j}static Hermite(I,O,C,j,K){const i=K*K,y=K*i,S=2*y-3*i+1,U=-2*y+3*i,p=y-2*i+K,N=y-i,Q=I.r*S+C.r*U+O.r*p+j.r*N,Z=I.g*S+C.g*U+O.g*p+j.g*N,q=I.b*S+C.b*U+O.b*p+j.b*N,mI=I.a*S+C.a*U+O.a*p+j.a*N;return new s(Q,Z,q,mI)}static Hermite1stDerivative(I,O,C,j,K){const i=new s;return this.Hermite1stDerivativeToRef(I,O,C,j,K,i),i}static Hermite1stDerivativeToRef(I,O,C,j,K,i){const y=K*K;i.r=6*(y-K)*I.r+(3*y-4*K+1)*O.r+6*(-y+K)*C.r+(3*y-2*K)*j.r,i.g=6*(y-K)*I.g+(3*y-4*K+1)*O.g+6*(-y+K)*C.g+(3*y-2*K)*j.g,i.b=6*(y-K)*I.b+(3*y-4*K+1)*O.b+6*(-y+K)*C.b+(3*y-2*K)*j.b,i.a=6*(y-K)*I.a+(3*y-4*K+1)*O.a+6*(-y+K)*C.a+(3*y-2*K)*j.a}static FromColor3(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s(I.r,I.g,I.b,O)}static YO(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(I[O],I[O+1],I[O+2],I[O+3])}static FromArrayToRef(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=I[O],C.g=I[O+1],C.b=I[O+2],C.a=I[O+3]}static FromInts(I,O,C,j){return new s(I/255,O/255,C/255,j/255)}static CheckColors4(I,O){if(I.length===3*O){const O=[];for(let C=0;C<I.length;C+=3){const j=C/3*4;O[j]=I[C],O[j+1]=I[C+1],O[j+2]=I[C+2],O[j+3]=1}return O}return I}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class Z{}Z.WO=(0,j.e)(3,Q.Black),Z.TS=(0,j.e)(3,(()=>new s(0,0,0,0))),(0,K.e)("BABYLON.Color3",Q),(0,K.e)("BABYLON.Color4",s)}}]);