"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[17],{11348:(k,Q,i)=>{i.r(Q),i.d(Q,{cQ:()=>G,Fo:()=>H,TmpColors:()=>e});var Z=i(11307),U=i(11253),C=i(11304),B=i(11311);function o(k){return Math.pow(k,C.m)}function m(k){return k<=.04045?.0773993808*k:Math.pow(.947867299*(k+.055),2.4)}function O(k){return Math.pow(k,C.j)}function J(k){return k<=.0031308?12.92*k:1.055*Math.pow(k,.41666)-.055}class G{constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=k,this.g=Q,this.b=i}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"cQ"}getHashCode(){let k=255*this.r|0;return k=397*k^255*this.g,k=397*k^255*this.b,k}toArray(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[Q]=this.r,k[Q+1]=this.g,k[Q+2]=this.b,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(k,Q,this),this}toColor4(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new H(this.r,this.g,this.b,k)}Zo(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(k){return new G(this.r*k.r,this.g*k.g,this.b*k.b)}multiplyToRef(k,Q){return Q.r=this.r*k.r,Q.g=this.g*k.g,Q.b=this.b*k.b,Q}multiplyInPlace(k){return this.r*=k.r,this.g*=k.g,this.b*=k.b,this}multiplyByFloats(k,Q,i){return new G(this.r*k,this.g*Q,this.b*i)}divide(k){throw new ReferenceError("Can not divide a color")}divideToRef(k,Q){throw new ReferenceError("Can not divide a color")}divideInPlace(k){throw new ReferenceError("Can not divide a color")}minimizeInPlace(k){return this.minimizeInPlaceFromFloats(k.r,k.g,k.b)}maximizeInPlace(k){return this.maximizeInPlaceFromFloats(k.r,k.g,k.b)}minimizeInPlaceFromFloats(k,Q,i){return this.r=Math.min(k,this.r),this.g=Math.min(Q,this.g),this.b=Math.min(i,this.b),this}maximizeInPlaceFromFloats(k,Q,i){return this.r=Math.max(k,this.r),this.g=Math.max(Q,this.g),this.b=Math.max(i,this.b),this}floorToRef(k){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(k){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(k){return k&&this.r===k.r&&this.g===k.g&&this.b===k.b}equalsFloats(k,Q,i){return this.equalsToFloats(k,Q,i)}equalsToFloats(k,Q,i){return this.r===k&&this.g===Q&&this.b===i}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.e;return(0,B.WithinEpsilon)(this.r,k.r,Q)&&(0,B.WithinEpsilon)(this.g,k.g,Q)&&(0,B.WithinEpsilon)(this.b,k.b,Q)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(k){throw new ReferenceError("Can not negate a color")}scale(k){return new G(this.r*k,this.g*k,this.b*k)}scaleInPlace(k){return this.r*=k,this.g*=k,this.b*=k,this}scaleToRef(k,Q){return Q.r=this.r*k,Q.g=this.g*k,Q.b=this.b*k,Q}scaleAndAddToRef(k,Q){return Q.r+=this.r*k,Q.g+=this.g*k,Q.b+=this.b*k,Q}clampToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,B.Clamp)(this.r,k,Q),i.g=(0,B.Clamp)(this.g,k,Q),i.b=(0,B.Clamp)(this.b,k,Q),i}add(k){return new G(this.r+k.r,this.g+k.g,this.b+k.b)}addInPlace(k){return this.r+=k.r,this.g+=k.g,this.b+=k.b,this}addInPlaceFromFloats(k,Q,i){return this.r+=k,this.g+=Q,this.b+=i,this}addToRef(k,Q){return Q.r=this.r+k.r,Q.g=this.g+k.g,Q.b=this.b+k.b,Q}EQ(k){return new G(this.r-k.r,this.g-k.g,this.b-k.b)}subtractToRef(k,Q){return Q.r=this.r-k.r,Q.g=this.g-k.g,Q.b=this.b-k.b,Q}tJ(k){return this.r-=k.r,this.g-=k.g,this.b-=k.b,this}subtractFromFloats(k,Q,i){return new G(this.r-k,this.g-Q,this.b-i)}subtractFromFloatsToRef(k,Q,i,Z){return Z.r=this.r-k,Z.g=this.g-Q,Z.b=this.b-i,Z}clone(){return new G(this.r,this.g,this.b)}B(k){return this.r=k.r,this.g=k.g,this.b=k.b,this}Go(k,Q,i){return this.r=k,this.g=Q,this.b=i,this}set(k,Q,i){return this.Go(k,Q,i)}eo(k){return this.r=this.g=this.b=k,this}toHexString(){const k=Math.round(255*this.r),Q=Math.round(255*this.g),i=Math.round(255*this.b);return"#"+(0,B.ToHex)(k)+(0,B.ToHex)(Q)+(0,B.ToHex)(i)}fromHexString(k){return"#"!==k.substring(0,1)||7!==k.length||(this.r=parseInt(k.substring(1,3),16)/255,this.g=parseInt(k.substring(3,5),16)/255,this.b=parseInt(k.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new G)}toHSVToRef(k){const Q=this.r,i=this.g,Z=this.b,U=Math.max(Q,i,Z),C=Math.min(Q,i,Z);let B=0,o=0;const m=U,O=U-C;return 0!==U&&(o=O/U),U!=C&&(U==Q?(B=(i-Z)/O,i<Z&&(B+=6)):U==i?B=(Z-Q)/O+2:U==Z&&(B=(Q-i)/O+4),B*=60),k.r=B,k.g=o,k.b=m,k}toLinearSpace(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=new G;return this.toLinearSpaceToRef(Q,k),Q}toLinearSpaceToRef(k){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(k.r=m(this.r),k.g=m(this.g),k.b=m(this.b)):(k.r=o(this.r),k.g=o(this.g),k.b=o(this.b)),this}toGammaSpace(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=new G;return this.toGammaSpaceToRef(Q,k),Q}toGammaSpaceToRef(k){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(k.r=J(this.r),k.g=J(this.g),k.b=J(this.b)):(k.r=O(this.r),k.g=O(this.g),k.b=O(this.b)),this}static HSVtoRGBToRef(k,Q,i,Z){const U=i*Q,C=k/60,B=U*(1-Math.abs(C%2-1));let o=0,m=0,O=0;C>=0&&C<=1?(o=U,m=B):C>=1&&C<=2?(o=B,m=U):C>=2&&C<=3?(m=U,O=B):C>=3&&C<=4?(m=B,O=U):C>=4&&C<=5?(o=B,O=U):C>=5&&C<=6&&(o=U,O=B);const J=i-U;return Z.r=o+J,Z.g=m+J,Z.b=O+J,Z}static FromHSV(k,Q,i){const Z=new G(0,0,0);return G.HSVtoRGBToRef(k,Q,i,Z),Z}static FromHexString(k){return new G(0,0,0).fromHexString(k)}static fQ(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(k[Q],k[Q+1],k[Q+2])}static FromArrayToRef(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=k[Q],i.g=k[Q+1],i.b=k[Q+2]}static FromInts(k,Q,i){return new G(k/255,Q/255,i/255)}static Lerp(k,Q,i){const Z=new G(0,0,0);return G.LerpToRef(k,Q,i,Z),Z}static LerpToRef(k,Q,i,Z){Z.r=k.r+(Q.r-k.r)*i,Z.g=k.g+(Q.g-k.g)*i,Z.b=k.b+(Q.b-k.b)*i}static Hermite(k,Q,i,Z,U){const C=U*U,B=U*C,o=2*B-3*C+1,m=-2*B+3*C,O=B-2*C+U,J=B-C,H=k.r*o+i.r*m+Q.r*O+Z.r*J,e=k.g*o+i.g*m+Q.g*O+Z.g*J,F=k.b*o+i.b*m+Q.b*O+Z.b*J;return new G(H,e,F)}static Hermite1stDerivative(k,Q,i,Z,U){const C=G.Black();return this.Hermite1stDerivativeToRef(k,Q,i,Z,U,C),C}static Hermite1stDerivativeToRef(k,Q,i,Z,U,C){const B=U*U;C.r=6*(B-U)*k.r+(3*B-4*U+1)*Q.r+6*(-B+U)*i.r+(3*B-2*U)*Z.r,C.g=6*(B-U)*k.g+(3*B-4*U+1)*Q.g+6*(-B+U)*i.g+(3*B-2*U)*Z.g,C.b=6*(B-U)*k.b+(3*B-4*U+1)*Q.b+6*(-B+U)*i.b+(3*B-2*U)*Z.b}static Red(){return new G(1,0,0)}static Green(){return new G(0,1,0)}static Blue(){return new G(0,0,1)}static Black(){return new G(0,0,0)}static get BlackReadOnly(){return G._BlackReadOnly}static White(){return new G(1,1,1)}static Purple(){return new G(.5,0,.5)}static Magenta(){return new G(1,0,1)}static Yellow(){return new G(1,1,0)}static Gray(){return new G(.5,.5,.5)}static Teal(){return new G(0,1,1)}static Random(){return new G(Math.random(),Math.random(),Math.random())}}G._V8PerformanceHack=new G(.5,.5,.5),G._BlackReadOnly=G.Black(),Object.defineProperties(G.prototype,{dimension:{value:[3]},rank:{value:1}});class H{constructor(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=k,this.g=Q,this.b=i,this.a=Z}Zo(){return[this.r,this.g,this.b,this.a]}toArray(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return k[Q]=this.r,k[Q+1]=this.g,k[Q+2]=this.b,k[Q+3]=this.a,this}Ei(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=k[Q],this.g=k[Q+1],this.b=k[Q+2],this.a=k[Q+3],this}equals(k){return k&&this.r===k.r&&this.g===k.g&&this.b===k.b&&this.a===k.a}add(k){return new H(this.r+k.r,this.g+k.g,this.b+k.b,this.a+k.a)}addToRef(k,Q){return Q.r=this.r+k.r,Q.g=this.g+k.g,Q.b=this.b+k.b,Q.a=this.a+k.a,Q}addInPlace(k){return this.r+=k.r,this.g+=k.g,this.b+=k.b,this.a+=k.a,this}addInPlaceFromFloats(k,Q,i,Z){return this.r+=k,this.g+=Q,this.b+=i,this.a+=Z,this}EQ(k){return new H(this.r-k.r,this.g-k.g,this.b-k.b,this.a-k.a)}subtractToRef(k,Q){return Q.r=this.r-k.r,Q.g=this.g-k.g,Q.b=this.b-k.b,Q.a=this.a-k.a,Q}tJ(k){return this.r-=k.r,this.g-=k.g,this.b-=k.b,this.a-=k.a,this}subtractFromFloats(k,Q,i,Z){return new H(this.r-k,this.g-Q,this.b-i,this.a-Z)}subtractFromFloatsToRef(k,Q,i,Z,U){return U.r=this.r-k,U.g=this.g-Q,U.b=this.b-i,U.a=this.a-Z,U}scale(k){return new H(this.r*k,this.g*k,this.b*k,this.a*k)}scaleInPlace(k){return this.r*=k,this.g*=k,this.b*=k,this.a*=k,this}scaleToRef(k,Q){return Q.r=this.r*k,Q.g=this.g*k,Q.b=this.b*k,Q.a=this.a*k,Q}scaleAndAddToRef(k,Q){return Q.r+=this.r*k,Q.g+=this.g*k,Q.b+=this.b*k,Q.a+=this.a*k,Q}clampToRef(){let k=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,i=arguments.length>2?arguments[2]:void 0;return i.r=(0,B.Clamp)(this.r,k,Q),i.g=(0,B.Clamp)(this.g,k,Q),i.b=(0,B.Clamp)(this.b,k,Q),i.a=(0,B.Clamp)(this.a,k,Q),i}multiply(k){return new H(this.r*k.r,this.g*k.g,this.b*k.b,this.a*k.a)}multiplyToRef(k,Q){return Q.r=this.r*k.r,Q.g=this.g*k.g,Q.b=this.b*k.b,Q.a=this.a*k.a,Q}multiplyInPlace(k){return this.r*=k.r,this.g*=k.g,this.b*=k.b,this.a*=k.a,this}multiplyByFloats(k,Q,i,Z){return new H(this.r*k,this.g*Q,this.b*i,this.a*Z)}divide(k){throw new ReferenceError("Can not divide a color")}divideToRef(k,Q){throw new ReferenceError("Can not divide a color")}divideInPlace(k){throw new ReferenceError("Can not divide a color")}minimizeInPlace(k){return this.r=Math.min(this.r,k.r),this.g=Math.min(this.g,k.g),this.b=Math.min(this.b,k.b),this.a=Math.min(this.a,k.a),this}maximizeInPlace(k){return this.r=Math.max(this.r,k.r),this.g=Math.max(this.g,k.g),this.b=Math.max(this.b,k.b),this.a=Math.max(this.a,k.a),this}minimizeInPlaceFromFloats(k,Q,i,Z){return this.r=Math.min(k,this.r),this.g=Math.min(Q,this.g),this.b=Math.min(i,this.b),this.a=Math.min(Z,this.a),this}maximizeInPlaceFromFloats(k,Q,i,Z){return this.r=Math.max(k,this.r),this.g=Math.max(Q,this.g),this.b=Math.max(i,this.b),this.a=Math.max(Z,this.a),this}floorToRef(k){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(k){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(k){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.e;return(0,B.WithinEpsilon)(this.r,k.r,Q)&&(0,B.WithinEpsilon)(this.g,k.g,Q)&&(0,B.WithinEpsilon)(this.b,k.b,Q)&&(0,B.WithinEpsilon)(this.a,k.a,Q)}equalsToFloats(k,Q,i,Z){return this.r===k&&this.g===Q&&this.b===i&&this.a===Z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Fo"}getHashCode(){let k=255*this.r|0;return k=397*k^255*this.g,k=397*k^255*this.b,k=397*k^255*this.a,k}clone(){return(new H).B(this)}B(k){return this.r=k.r,this.g=k.g,this.b=k.b,this.a=k.a,this}Go(k,Q,i,Z){return this.r=k,this.g=Q,this.b=i,this.a=Z,this}set(k,Q,i,Z){return this.Go(k,Q,i,Z)}eo(k){return this.r=this.g=this.b=this.a=k,this}toHexString(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=Math.round(255*this.r),i=Math.round(255*this.g),Z=Math.round(255*this.b);if(k)return"#"+(0,B.ToHex)(Q)+(0,B.ToHex)(i)+(0,B.ToHex)(Z);const U=Math.round(255*this.a);return"#"+(0,B.ToHex)(Q)+(0,B.ToHex)(i)+(0,B.ToHex)(Z)+(0,B.ToHex)(U)}fromHexString(k){return"#"!==k.substring(0,1)||9!==k.length&&7!==k.length||(this.r=parseInt(k.substring(1,3),16)/255,this.g=parseInt(k.substring(3,5),16)/255,this.b=parseInt(k.substring(5,7),16)/255,9===k.length&&(this.a=parseInt(k.substring(7,9),16)/255)),this}toLinearSpace(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=new H;return this.toLinearSpaceToRef(Q,k),Q}toLinearSpaceToRef(k){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(k.r=m(this.r),k.g=m(this.g),k.b=m(this.b)):(k.r=o(this.r),k.g=o(this.g),k.b=o(this.b)),k.a=this.a,this}toGammaSpace(){let k=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Q=new H;return this.toGammaSpaceToRef(Q,k),Q}toGammaSpaceToRef(k){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(k.r=J(this.r),k.g=J(this.g),k.b=J(this.b)):(k.r=O(this.r),k.g=O(this.g),k.b=O(this.b)),k.a=this.a,this}static FromHexString(k){return"#"!==k.substring(0,1)||9!==k.length&&7!==k.length?new H(0,0,0,0):new H(0,0,0,1).fromHexString(k)}static Lerp(k,Q,i){return H.LerpToRef(k,Q,i,new H)}static LerpToRef(k,Q,i,Z){return Z.r=k.r+(Q.r-k.r)*i,Z.g=k.g+(Q.g-k.g)*i,Z.b=k.b+(Q.b-k.b)*i,Z.a=k.a+(Q.a-k.a)*i,Z}static Hermite(k,Q,i,Z,U){const C=U*U,B=U*C,o=2*B-3*C+1,m=-2*B+3*C,O=B-2*C+U,J=B-C,G=k.r*o+i.r*m+Q.r*O+Z.r*J,e=k.g*o+i.g*m+Q.g*O+Z.g*J,F=k.b*o+i.b*m+Q.b*O+Z.b*J,z=k.a*o+i.a*m+Q.a*O+Z.a*J;return new H(G,e,F,z)}static Hermite1stDerivative(k,Q,i,Z,U){const C=new H;return this.Hermite1stDerivativeToRef(k,Q,i,Z,U,C),C}static Hermite1stDerivativeToRef(k,Q,i,Z,U,C){const B=U*U;C.r=6*(B-U)*k.r+(3*B-4*U+1)*Q.r+6*(-B+U)*i.r+(3*B-2*U)*Z.r,C.g=6*(B-U)*k.g+(3*B-4*U+1)*Q.g+6*(-B+U)*i.g+(3*B-2*U)*Z.g,C.b=6*(B-U)*k.b+(3*B-4*U+1)*Q.b+6*(-B+U)*i.b+(3*B-2*U)*Z.b,C.a=6*(B-U)*k.a+(3*B-4*U+1)*Q.a+6*(-B+U)*i.a+(3*B-2*U)*Z.a}static FromColor3(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H(k.r,k.g,k.b,Q)}static fQ(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(k[Q],k[Q+1],k[Q+2],k[Q+3])}static FromArrayToRef(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2?arguments[2]:void 0;i.r=k[Q],i.g=k[Q+1],i.b=k[Q+2],i.a=k[Q+3]}static FromInts(k,Q,i,Z){return new H(k/255,Q/255,i/255,Z/255)}static CheckColors4(k,Q){if(k.length===3*Q){const Q=[];for(let i=0;i<k.length;i+=3){const Z=i/3*4;Q[Z]=k[i],Q[Z+1]=k[i+1],Q[Z+2]=k[i+2],Q[Z+3]=1}return Q}return k}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class e{}e.cQ=(0,Z.c)(3,G.Black),e.Fo=(0,Z.c)(3,(()=>new H(0,0,0,0))),(0,U.e)("BABYLON.Color3",G),(0,U.e)("BABYLON.Color4",H)}}]);