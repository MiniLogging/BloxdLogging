"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[17],{12375:(y,c,A)=>{A.r(c),A.d(c,{dc:()=>o,ip:()=>O,TmpColors:()=>L});var l=A(12337),w=A(12283),N=A(12330),p=A(12340);function W(y){return Math.pow(y,N.j)}function h(y){return y<=.04045?.0773993808*y:Math.pow(.947867299*(y+.055),2.4)}function I(y){return Math.pow(y,N.g)}function q(y){return y<=.0031308?12.92*y:1.055*Math.pow(y,.41666)-.055}class o{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=y,this.g=c,this.b=A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"dc"}getHashCode(){let y=255*this.r|0;return y=397*y^255*this.g,y=397*y^255*this.b,y}toArray(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[c]=this.r,y[c+1]=this.g,y[c+2]=this.b,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return o.FromArrayToRef(y,c,this),this}toColor4(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new O(this.r,this.g,this.b,y)}fc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(y){return new o(this.r*y.r,this.g*y.g,this.b*y.b)}multiplyToRef(y,c){return c.r=this.r*y.r,c.g=this.g*y.g,c.b=this.b*y.b,c}multiplyInPlace(y){return this.r*=y.r,this.g*=y.g,this.b*=y.b,this}multiplyByFloats(y,c,A){return new o(this.r*y,this.g*c,this.b*A)}divide(y){throw new ReferenceError("Can not divide a color")}divideToRef(y,c){throw new ReferenceError("Can not divide a color")}divideInPlace(y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(y){return this.minimizeInPlaceFromFloats(y.r,y.g,y.b)}maximizeInPlace(y){return this.maximizeInPlaceFromFloats(y.r,y.g,y.b)}minimizeInPlaceFromFloats(y,c,A){return this.r=Math.min(y,this.r),this.g=Math.min(c,this.g),this.b=Math.min(A,this.b),this}maximizeInPlaceFromFloats(y,c,A){return this.r=Math.max(y,this.r),this.g=Math.max(c,this.g),this.b=Math.max(A,this.b),this}floorToRef(y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(y){return y&&this.r===y.r&&this.g===y.g&&this.b===y.b}equalsFloats(y,c,A){return this.equalsToFloats(y,c,A)}equalsToFloats(y,c,A){return this.r===y&&this.g===c&&this.b===A}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.b;return(0,p.WithinEpsilon)(this.r,y.r,c)&&(0,p.WithinEpsilon)(this.g,y.g,c)&&(0,p.WithinEpsilon)(this.b,y.b,c)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(y){throw new ReferenceError("Can not negate a color")}scale(y){return new o(this.r*y,this.g*y,this.b*y)}scaleInPlace(y){return this.r*=y,this.g*=y,this.b*=y,this}scaleToRef(y,c){return c.r=this.r*y,c.g=this.g*y,c.b=this.b*y,c}scaleAndAddToRef(y,c){return c.r+=this.r*y,c.g+=this.g*y,c.b+=this.b*y,c}clampToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.r=(0,p.Clamp)(this.r,y,c),A.g=(0,p.Clamp)(this.g,y,c),A.b=(0,p.Clamp)(this.b,y,c),A}add(y){return new o(this.r+y.r,this.g+y.g,this.b+y.b)}addInPlace(y){return this.r+=y.r,this.g+=y.g,this.b+=y.b,this}addInPlaceFromFloats(y,c,A){return this.r+=y,this.g+=c,this.b+=A,this}addToRef(y,c){return c.r=this.r+y.r,c.g=this.g+y.g,c.b=this.b+y.b,c}xc(y){return new o(this.r-y.r,this.g-y.g,this.b-y.b)}subtractToRef(y,c){return c.r=this.r-y.r,c.g=this.g-y.g,c.b=this.b-y.b,c}uo(y){return this.r-=y.r,this.g-=y.g,this.b-=y.b,this}subtractFromFloats(y,c,A){return new o(this.r-y,this.g-c,this.b-A)}subtractFromFloatsToRef(y,c,A,l){return l.r=this.r-y,l.g=this.g-c,l.b=this.b-A,l}clone(){return new o(this.r,this.g,this.b)}p(y){return this.r=y.r,this.g=y.g,this.b=y.b,this}Ec(y,c,A){return this.r=y,this.g=c,this.b=A,this}set(y,c,A){return this.Ec(y,c,A)}vc(y){return this.r=this.g=this.b=y,this}toHexString(){const y=Math.round(255*this.r),c=Math.round(255*this.g),A=Math.round(255*this.b);return"#"+(0,p.ToHex)(y)+(0,p.ToHex)(c)+(0,p.ToHex)(A)}fromHexString(y){return"#"!==y.substring(0,1)||7!==y.length||(this.r=parseInt(y.substring(1,3),16)/255,this.g=parseInt(y.substring(3,5),16)/255,this.b=parseInt(y.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new o)}toHSVToRef(y){const c=this.r,A=this.g,l=this.b,w=Math.max(c,A,l),N=Math.min(c,A,l);let p=0,W=0;const h=w,I=w-N;return 0!==w&&(W=I/w),w!=N&&(w==c?(p=(A-l)/I,A<l&&(p+=6)):w==A?p=(l-c)/I+2:w==l&&(p=(c-A)/I+4),p*=60),y.r=p,y.g=W,y.b=h,y}toLinearSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new o;return this.toLinearSpaceToRef(c,y),c}toLinearSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=h(this.r),y.g=h(this.g),y.b=h(this.b)):(y.r=W(this.r),y.g=W(this.g),y.b=W(this.b)),this}toGammaSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new o;return this.toGammaSpaceToRef(c,y),c}toGammaSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=q(this.r),y.g=q(this.g),y.b=q(this.b)):(y.r=I(this.r),y.g=I(this.g),y.b=I(this.b)),this}static HSVtoRGBToRef(y,c,A,l){const w=A*c,N=y/60,p=w*(1-Math.abs(N%2-1));let W=0,h=0,I=0;N>=0&&N<=1?(W=w,h=p):N>=1&&N<=2?(W=p,h=w):N>=2&&N<=3?(h=w,I=p):N>=3&&N<=4?(h=p,I=w):N>=4&&N<=5?(W=p,I=w):N>=5&&N<=6&&(W=w,I=p);const q=A-w;return l.r=W+q,l.g=h+q,l.b=I+q,l}static FromHSV(y,c,A){const l=new o(0,0,0);return o.HSVtoRGBToRef(y,c,A,l),l}static FromHexString(y){return new o(0,0,0).fromHexString(y)}static yA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new o(y[c],y[c+1],y[c+2])}static FromArrayToRef(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2?arguments[2]:void 0;A.r=y[c],A.g=y[c+1],A.b=y[c+2]}static FromInts(y,c,A){return new o(y/255,c/255,A/255)}static Lerp(y,c,A){const l=new o(0,0,0);return o.LerpToRef(y,c,A,l),l}static LerpToRef(y,c,A,l){l.r=y.r+(c.r-y.r)*A,l.g=y.g+(c.g-y.g)*A,l.b=y.b+(c.b-y.b)*A}static Hermite(y,c,A,l,w){const N=w*w,p=w*N,W=2*p-3*N+1,h=-2*p+3*N,I=p-2*N+w,q=p-N,O=y.r*W+A.r*h+c.r*I+l.r*q,L=y.g*W+A.g*h+c.g*I+l.g*q,i=y.b*W+A.b*h+c.b*I+l.b*q;return new o(O,L,i)}static Hermite1stDerivative(y,c,A,l,w){const N=o.Black();return this.Hermite1stDerivativeToRef(y,c,A,l,w,N),N}static Hermite1stDerivativeToRef(y,c,A,l,w,N){const p=w*w;N.r=6*(p-w)*y.r+(3*p-4*w+1)*c.r+6*(-p+w)*A.r+(3*p-2*w)*l.r,N.g=6*(p-w)*y.g+(3*p-4*w+1)*c.g+6*(-p+w)*A.g+(3*p-2*w)*l.g,N.b=6*(p-w)*y.b+(3*p-4*w+1)*c.b+6*(-p+w)*A.b+(3*p-2*w)*l.b}static Red(){return new o(1,0,0)}static Green(){return new o(0,1,0)}static Blue(){return new o(0,0,1)}static Black(){return new o(0,0,0)}static get BlackReadOnly(){return o._BlackReadOnly}static White(){return new o(1,1,1)}static Purple(){return new o(.5,0,.5)}static Magenta(){return new o(1,0,1)}static Yellow(){return new o(1,1,0)}static Gray(){return new o(.5,.5,.5)}static Teal(){return new o(0,1,1)}static Random(){return new o(Math.random(),Math.random(),Math.random())}}o._V8PerformanceHack=new o(.5,.5,.5),o._BlackReadOnly=o.Black(),Object.defineProperties(o.prototype,{dimension:{value:[3]},rank:{value:1}});class O{constructor(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=y,this.g=c,this.b=A,this.a=l}fc(){return[this.r,this.g,this.b,this.a]}toArray(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return y[c]=this.r,y[c+1]=this.g,y[c+2]=this.b,y[c+3]=this.a,this}nA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=y[c],this.g=y[c+1],this.b=y[c+2],this.a=y[c+3],this}equals(y){return y&&this.r===y.r&&this.g===y.g&&this.b===y.b&&this.a===y.a}add(y){return new O(this.r+y.r,this.g+y.g,this.b+y.b,this.a+y.a)}addToRef(y,c){return c.r=this.r+y.r,c.g=this.g+y.g,c.b=this.b+y.b,c.a=this.a+y.a,c}addInPlace(y){return this.r+=y.r,this.g+=y.g,this.b+=y.b,this.a+=y.a,this}addInPlaceFromFloats(y,c,A,l){return this.r+=y,this.g+=c,this.b+=A,this.a+=l,this}xc(y){return new O(this.r-y.r,this.g-y.g,this.b-y.b,this.a-y.a)}subtractToRef(y,c){return c.r=this.r-y.r,c.g=this.g-y.g,c.b=this.b-y.b,c.a=this.a-y.a,c}uo(y){return this.r-=y.r,this.g-=y.g,this.b-=y.b,this.a-=y.a,this}subtractFromFloats(y,c,A,l){return new O(this.r-y,this.g-c,this.b-A,this.a-l)}subtractFromFloatsToRef(y,c,A,l,w){return w.r=this.r-y,w.g=this.g-c,w.b=this.b-A,w.a=this.a-l,w}scale(y){return new O(this.r*y,this.g*y,this.b*y,this.a*y)}scaleInPlace(y){return this.r*=y,this.g*=y,this.b*=y,this.a*=y,this}scaleToRef(y,c){return c.r=this.r*y,c.g=this.g*y,c.b=this.b*y,c.a=this.a*y,c}scaleAndAddToRef(y,c){return c.r+=this.r*y,c.g+=this.g*y,c.b+=this.b*y,c.a+=this.a*y,c}clampToRef(){let y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.r=(0,p.Clamp)(this.r,y,c),A.g=(0,p.Clamp)(this.g,y,c),A.b=(0,p.Clamp)(this.b,y,c),A.a=(0,p.Clamp)(this.a,y,c),A}multiply(y){return new O(this.r*y.r,this.g*y.g,this.b*y.b,this.a*y.a)}multiplyToRef(y,c){return c.r=this.r*y.r,c.g=this.g*y.g,c.b=this.b*y.b,c.a=this.a*y.a,c}multiplyInPlace(y){return this.r*=y.r,this.g*=y.g,this.b*=y.b,this.a*=y.a,this}multiplyByFloats(y,c,A,l){return new O(this.r*y,this.g*c,this.b*A,this.a*l)}divide(y){throw new ReferenceError("Can not divide a color")}divideToRef(y,c){throw new ReferenceError("Can not divide a color")}divideInPlace(y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(y){return this.r=Math.min(this.r,y.r),this.g=Math.min(this.g,y.g),this.b=Math.min(this.b,y.b),this.a=Math.min(this.a,y.a),this}maximizeInPlace(y){return this.r=Math.max(this.r,y.r),this.g=Math.max(this.g,y.g),this.b=Math.max(this.b,y.b),this.a=Math.max(this.a,y.a),this}minimizeInPlaceFromFloats(y,c,A,l){return this.r=Math.min(y,this.r),this.g=Math.min(c,this.g),this.b=Math.min(A,this.b),this.a=Math.min(l,this.a),this}maximizeInPlaceFromFloats(y,c,A,l){return this.r=Math.max(y,this.r),this.g=Math.max(c,this.g),this.b=Math.max(A,this.b),this.a=Math.max(l,this.a),this}floorToRef(y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(y){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.b;return(0,p.WithinEpsilon)(this.r,y.r,c)&&(0,p.WithinEpsilon)(this.g,y.g,c)&&(0,p.WithinEpsilon)(this.b,y.b,c)&&(0,p.WithinEpsilon)(this.a,y.a,c)}equalsToFloats(y,c,A,l){return this.r===y&&this.g===c&&this.b===A&&this.a===l}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ip"}getHashCode(){let y=255*this.r|0;return y=397*y^255*this.g,y=397*y^255*this.b,y=397*y^255*this.a,y}clone(){return(new O).p(this)}p(y){return this.r=y.r,this.g=y.g,this.b=y.b,this.a=y.a,this}Ec(y,c,A,l){return this.r=y,this.g=c,this.b=A,this.a=l,this}set(y,c,A,l){return this.Ec(y,c,A,l)}vc(y){return this.r=this.g=this.b=this.a=y,this}toHexString(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=Math.round(255*this.r),A=Math.round(255*this.g),l=Math.round(255*this.b);if(y)return"#"+(0,p.ToHex)(c)+(0,p.ToHex)(A)+(0,p.ToHex)(l);const w=Math.round(255*this.a);return"#"+(0,p.ToHex)(c)+(0,p.ToHex)(A)+(0,p.ToHex)(l)+(0,p.ToHex)(w)}fromHexString(y){return"#"!==y.substring(0,1)||9!==y.length&&7!==y.length||(this.r=parseInt(y.substring(1,3),16)/255,this.g=parseInt(y.substring(3,5),16)/255,this.b=parseInt(y.substring(5,7),16)/255,9===y.length&&(this.a=parseInt(y.substring(7,9),16)/255)),this}toLinearSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new O;return this.toLinearSpaceToRef(c,y),c}toLinearSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=h(this.r),y.g=h(this.g),y.b=h(this.b)):(y.r=W(this.r),y.g=W(this.g),y.b=W(this.b)),y.a=this.a,this}toGammaSpace(){let y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new O;return this.toGammaSpaceToRef(c,y),c}toGammaSpaceToRef(y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(y.r=q(this.r),y.g=q(this.g),y.b=q(this.b)):(y.r=I(this.r),y.g=I(this.g),y.b=I(this.b)),y.a=this.a,this}static FromHexString(y){return"#"!==y.substring(0,1)||9!==y.length&&7!==y.length?new O(0,0,0,0):new O(0,0,0,1).fromHexString(y)}static Lerp(y,c,A){return O.LerpToRef(y,c,A,new O)}static LerpToRef(y,c,A,l){return l.r=y.r+(c.r-y.r)*A,l.g=y.g+(c.g-y.g)*A,l.b=y.b+(c.b-y.b)*A,l.a=y.a+(c.a-y.a)*A,l}static Hermite(y,c,A,l,w){const N=w*w,p=w*N,W=2*p-3*N+1,h=-2*p+3*N,I=p-2*N+w,q=p-N,o=y.r*W+A.r*h+c.r*I+l.r*q,L=y.g*W+A.g*h+c.g*I+l.g*q,i=y.b*W+A.b*h+c.b*I+l.b*q,H=y.a*W+A.a*h+c.a*I+l.a*q;return new O(o,L,i,H)}static Hermite1stDerivative(y,c,A,l,w){const N=new O;return this.Hermite1stDerivativeToRef(y,c,A,l,w,N),N}static Hermite1stDerivativeToRef(y,c,A,l,w,N){const p=w*w;N.r=6*(p-w)*y.r+(3*p-4*w+1)*c.r+6*(-p+w)*A.r+(3*p-2*w)*l.r,N.g=6*(p-w)*y.g+(3*p-4*w+1)*c.g+6*(-p+w)*A.g+(3*p-2*w)*l.g,N.b=6*(p-w)*y.b+(3*p-4*w+1)*c.b+6*(-p+w)*A.b+(3*p-2*w)*l.b,N.a=6*(p-w)*y.a+(3*p-4*w+1)*c.a+6*(-p+w)*A.a+(3*p-2*w)*l.a}static FromColor3(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new O(y.r,y.g,y.b,c)}static yA(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(y[c],y[c+1],y[c+2],y[c+3])}static FromArrayToRef(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2?arguments[2]:void 0;A.r=y[c],A.g=y[c+1],A.b=y[c+2],A.a=y[c+3]}static FromInts(y,c,A,l){return new O(y/255,c/255,A/255,l/255)}static CheckColors4(y,c){if(y.length===3*c){const c=[];for(let A=0;A<y.length;A+=3){const l=A/3*4;c[l]=y[A],c[l+1]=y[A+1],c[l+2]=y[A+2],c[l+3]=1}return c}return y}}O._V8PerformanceHack=new O(.5,.5,.5,.5),Object.defineProperties(O.prototype,{dimension:{value:[4]},rank:{value:1}});class L{}L.dc=(0,l.d)(3,o.Black),L.ip=(0,l.d)(3,(()=>new O(0,0,0,0))),(0,w.f)("BABYLON.Color3",o),(0,w.f)("BABYLON.Color4",O)}}]);