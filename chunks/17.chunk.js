"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[17],{11781:(Z,h,V)=>{V.r(h),V.d(h,{Ih:()=>N,nd:()=>D,TmpColors:()=>k});var v=V(11739),A=V(11691),H=V(11737),K=V(11748);function d(Z){return Math.pow(Z,H.k)}function a(Z){return Z<=.04045?.0773993808*Z:Math.pow(.947867299*(Z+.055),2.4)}function n(Z){return Math.pow(Z,H.j)}function x(Z){return Z<=.0031308?12.92*Z:1.055*Math.pow(Z,.41666)-.055}class N{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=Z,this.g=h,this.b=V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Ih"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z}toArray(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[h]=this.r,Z[h+1]=this.g,Z[h+2]=this.b,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N.FromArrayToRef(Z,h,this),this}toColor4(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new D(this.r,this.g,this.b,Z)}mh(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(Z){return new N(this.r*Z.r,this.g*Z.g,this.b*Z.b)}multiplyToRef(Z,h){return h.r=this.r*Z.r,h.g=this.g*Z.g,h.b=this.b*Z.b,h}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this}multiplyByFloats(Z,h,V){return new N(this.r*Z,this.g*h,this.b*V)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,h){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.r,Z.g,Z.b)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.r,Z.g,Z.b)}minimizeInPlaceFromFloats(Z,h,V){return this.r=Math.min(Z,this.r),this.g=Math.min(h,this.g),this.b=Math.min(V,this.b),this}maximizeInPlaceFromFloats(Z,h,V){return this.r=Math.max(Z,this.r),this.g=Math.max(h,this.g),this.b=Math.max(V,this.b),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b}equalsFloats(Z,h,V){return this.equalsToFloats(Z,h,V)}equalsToFloats(Z,h,V){return this.r===Z&&this.g===h&&this.b===V}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return(0,K.WithinEpsilon)(this.r,Z.r,h)&&(0,K.WithinEpsilon)(this.g,Z.g,h)&&(0,K.WithinEpsilon)(this.b,Z.b,h)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}scale(Z){return new N(this.r*Z,this.g*Z,this.b*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this}scaleToRef(Z,h){return h.r=this.r*Z,h.g=this.g*Z,h.b=this.b*Z,h}scaleAndAddToRef(Z,h){return h.r+=this.r*Z,h.g+=this.g*Z,h.b+=this.b*Z,h}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,K.Clamp)(this.r,Z,h),V.g=(0,K.Clamp)(this.g,Z,h),V.b=(0,K.Clamp)(this.b,Z,h),V}add(Z){return new N(this.r+Z.r,this.g+Z.g,this.b+Z.b)}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this}addInPlaceFromFloats(Z,h,V){return this.r+=Z,this.g+=h,this.b+=V,this}addToRef(Z,h){return h.r=this.r+Z.r,h.g=this.g+Z.g,h.b=this.b+Z.b,h}rh(Z){return new N(this.r-Z.r,this.g-Z.g,this.b-Z.b)}subtractToRef(Z,h){return h.r=this.r-Z.r,h.g=this.g-Z.g,h.b=this.b-Z.b,h}EN(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this}subtractFromFloats(Z,h,V){return new N(this.r-Z,this.g-h,this.b-V)}subtractFromFloatsToRef(Z,h,V,v){return v.r=this.r-Z,v.g=this.g-h,v.b=this.b-V,v}clone(){return new N(this.r,this.g,this.b)}v(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this}IV(Z,h,V){return this.r=Z,this.g=h,this.b=V,this}set(Z,h,V){return this.IV(Z,h,V)}vd(Z){return this.r=this.g=this.b=Z,this}toHexString(){const Z=Math.round(255*this.r),h=Math.round(255*this.g),V=Math.round(255*this.b);return"#"+(0,K.ToHex)(Z)+(0,K.ToHex)(h)+(0,K.ToHex)(V)}fromHexString(Z){return"#"!==Z.substring(0,1)||7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new N)}toHSVToRef(Z){const h=this.r,V=this.g,v=this.b,A=Math.max(h,V,v),H=Math.min(h,V,v);let K=0,d=0;const a=A,n=A-H;return 0!==A&&(d=n/A),A!=H&&(A==h?(K=(V-v)/n,V<v&&(K+=6)):A==V?K=(v-h)/n+2:A==v&&(K=(h-V)/n+4),K*=60),Z.r=K,Z.g=d,Z.b=a,Z}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new N;return this.toLinearSpaceToRef(h,Z),h}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=a(this.r),Z.g=a(this.g),Z.b=a(this.b)):(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)),this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new N;return this.toGammaSpaceToRef(h,Z),h}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=x(this.r),Z.g=x(this.g),Z.b=x(this.b)):(Z.r=n(this.r),Z.g=n(this.g),Z.b=n(this.b)),this}static HSVtoRGBToRef(Z,h,V,v){const A=V*h,H=Z/60,K=A*(1-Math.abs(H%2-1));let d=0,a=0,n=0;H>=0&&H<=1?(d=A,a=K):H>=1&&H<=2?(d=K,a=A):H>=2&&H<=3?(a=A,n=K):H>=3&&H<=4?(a=K,n=A):H>=4&&H<=5?(d=K,n=A):H>=5&&H<=6&&(d=A,n=K);const x=V-A;return v.r=d+x,v.g=a+x,v.b=n+x,v}static FromHSV(Z,h,V){const v=new N(0,0,0);return N.HSVtoRGBToRef(Z,h,V,v),v}static FromHexString(Z){return new N(0,0,0).fromHexString(Z)}static eh(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new N(Z[h],Z[h+1],Z[h+2])}static FromArrayToRef(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=Z[h],V.g=Z[h+1],V.b=Z[h+2]}static FromInts(Z,h,V){return new N(Z/255,h/255,V/255)}static Lerp(Z,h,V){const v=new N(0,0,0);return N.LerpToRef(Z,h,V,v),v}static LerpToRef(Z,h,V,v){v.r=Z.r+(h.r-Z.r)*V,v.g=Z.g+(h.g-Z.g)*V,v.b=Z.b+(h.b-Z.b)*V}static Hermite(Z,h,V,v,A){const H=A*A,K=A*H,d=2*K-3*H+1,a=-2*K+3*H,n=K-2*H+A,x=K-H,D=Z.r*d+V.r*a+h.r*n+v.r*x,k=Z.g*d+V.g*a+h.g*n+v.g*x,u=Z.b*d+V.b*a+h.b*n+v.b*x;return new N(D,k,u)}static Hermite1stDerivative(Z,h,V,v,A){const H=N.Black();return this.Hermite1stDerivativeToRef(Z,h,V,v,A,H),H}static Hermite1stDerivativeToRef(Z,h,V,v,A,H){const K=A*A;H.r=6*(K-A)*Z.r+(3*K-4*A+1)*h.r+6*(-K+A)*V.r+(3*K-2*A)*v.r,H.g=6*(K-A)*Z.g+(3*K-4*A+1)*h.g+6*(-K+A)*V.g+(3*K-2*A)*v.g,H.b=6*(K-A)*Z.b+(3*K-4*A+1)*h.b+6*(-K+A)*V.b+(3*K-2*A)*v.b}static Red(){return new N(1,0,0)}static Green(){return new N(0,1,0)}static Blue(){return new N(0,0,1)}static Black(){return new N(0,0,0)}static get BlackReadOnly(){return N._BlackReadOnly}static White(){return new N(1,1,1)}static Purple(){return new N(.5,0,.5)}static Magenta(){return new N(1,0,1)}static Yellow(){return new N(1,1,0)}static Gray(){return new N(.5,.5,.5)}static Teal(){return new N(0,1,1)}static Random(){return new N(Math.random(),Math.random(),Math.random())}}N._V8PerformanceHack=new N(.5,.5,.5),N._BlackReadOnly=N.Black(),Object.defineProperties(N.prototype,{dimension:{value:[3]},rank:{value:1}});class D{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=Z,this.g=h,this.b=V,this.a=v}mh(){return[this.r,this.g,this.b,this.a]}toArray(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[h]=this.r,Z[h+1]=this.g,Z[h+2]=this.b,Z[h+3]=this.a,this}QV(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=Z[h],this.g=Z[h+1],this.b=Z[h+2],this.a=Z[h+3],this}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b&&this.a===Z.a}add(Z){return new D(this.r+Z.r,this.g+Z.g,this.b+Z.b,this.a+Z.a)}addToRef(Z,h){return h.r=this.r+Z.r,h.g=this.g+Z.g,h.b=this.b+Z.b,h.a=this.a+Z.a,h}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this.a+=Z.a,this}addInPlaceFromFloats(Z,h,V,v){return this.r+=Z,this.g+=h,this.b+=V,this.a+=v,this}rh(Z){return new D(this.r-Z.r,this.g-Z.g,this.b-Z.b,this.a-Z.a)}subtractToRef(Z,h){return h.r=this.r-Z.r,h.g=this.g-Z.g,h.b=this.b-Z.b,h.a=this.a-Z.a,h}EN(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this.a-=Z.a,this}subtractFromFloats(Z,h,V,v){return new D(this.r-Z,this.g-h,this.b-V,this.a-v)}subtractFromFloatsToRef(Z,h,V,v,A){return A.r=this.r-Z,A.g=this.g-h,A.b=this.b-V,A.a=this.a-v,A}scale(Z){return new D(this.r*Z,this.g*Z,this.b*Z,this.a*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this.a*=Z,this}scaleToRef(Z,h){return h.r=this.r*Z,h.g=this.g*Z,h.b=this.b*Z,h.a=this.a*Z,h}scaleAndAddToRef(Z,h){return h.r+=this.r*Z,h.g+=this.g*Z,h.b+=this.b*Z,h.a+=this.a*Z,h}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,K.Clamp)(this.r,Z,h),V.g=(0,K.Clamp)(this.g,Z,h),V.b=(0,K.Clamp)(this.b,Z,h),V.a=(0,K.Clamp)(this.a,Z,h),V}multiply(Z){return new D(this.r*Z.r,this.g*Z.g,this.b*Z.b,this.a*Z.a)}multiplyToRef(Z,h){return h.r=this.r*Z.r,h.g=this.g*Z.g,h.b=this.b*Z.b,h.a=this.a*Z.a,h}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this.a*=Z.a,this}multiplyByFloats(Z,h,V,v){return new D(this.r*Z,this.g*h,this.b*V,this.a*v)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,h){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.r=Math.min(this.r,Z.r),this.g=Math.min(this.g,Z.g),this.b=Math.min(this.b,Z.b),this.a=Math.min(this.a,Z.a),this}maximizeInPlace(Z){return this.r=Math.max(this.r,Z.r),this.g=Math.max(this.g,Z.g),this.b=Math.max(this.b,Z.b),this.a=Math.max(this.a,Z.a),this}minimizeInPlaceFromFloats(Z,h,V,v){return this.r=Math.min(Z,this.r),this.g=Math.min(h,this.g),this.b=Math.min(V,this.b),this.a=Math.min(v,this.a),this}maximizeInPlaceFromFloats(Z,h,V,v){return this.r=Math.max(Z,this.r),this.g=Math.max(h,this.g),this.b=Math.max(V,this.b),this.a=Math.max(v,this.a),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:H.c;return(0,K.WithinEpsilon)(this.r,Z.r,h)&&(0,K.WithinEpsilon)(this.g,Z.g,h)&&(0,K.WithinEpsilon)(this.b,Z.b,h)&&(0,K.WithinEpsilon)(this.a,Z.a,h)}equalsToFloats(Z,h,V,v){return this.r===Z&&this.g===h&&this.b===V&&this.a===v}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"nd"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z=397*Z^255*this.a,Z}clone(){return(new D).v(this)}v(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this.a=Z.a,this}IV(Z,h,V,v){return this.r=Z,this.g=h,this.b=V,this.a=v,this}set(Z,h,V,v){return this.IV(Z,h,V,v)}vd(Z){return this.r=this.g=this.b=this.a=Z,this}toHexString(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=Math.round(255*this.r),V=Math.round(255*this.g),v=Math.round(255*this.b);if(Z)return"#"+(0,K.ToHex)(h)+(0,K.ToHex)(V)+(0,K.ToHex)(v);const A=Math.round(255*this.a);return"#"+(0,K.ToHex)(h)+(0,K.ToHex)(V)+(0,K.ToHex)(v)+(0,K.ToHex)(A)}fromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255,9===Z.length&&(this.a=parseInt(Z.substring(7,9),16)/255)),this}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new D;return this.toLinearSpaceToRef(h,Z),h}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=a(this.r),Z.g=a(this.g),Z.b=a(this.b)):(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)),Z.a=this.a,this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new D;return this.toGammaSpaceToRef(h,Z),h}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=x(this.r),Z.g=x(this.g),Z.b=x(this.b)):(Z.r=n(this.r),Z.g=n(this.g),Z.b=n(this.b)),Z.a=this.a,this}static FromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length?new D(0,0,0,0):new D(0,0,0,1).fromHexString(Z)}static Lerp(Z,h,V){return D.LerpToRef(Z,h,V,new D)}static LerpToRef(Z,h,V,v){return v.r=Z.r+(h.r-Z.r)*V,v.g=Z.g+(h.g-Z.g)*V,v.b=Z.b+(h.b-Z.b)*V,v.a=Z.a+(h.a-Z.a)*V,v}static Hermite(Z,h,V,v,A){const H=A*A,K=A*H,d=2*K-3*H+1,a=-2*K+3*H,n=K-2*H+A,x=K-H,N=Z.r*d+V.r*a+h.r*n+v.r*x,k=Z.g*d+V.g*a+h.g*n+v.g*x,u=Z.b*d+V.b*a+h.b*n+v.b*x,F=Z.a*d+V.a*a+h.a*n+v.a*x;return new D(N,k,u,F)}static Hermite1stDerivative(Z,h,V,v,A){const H=new D;return this.Hermite1stDerivativeToRef(Z,h,V,v,A,H),H}static Hermite1stDerivativeToRef(Z,h,V,v,A,H){const K=A*A;H.r=6*(K-A)*Z.r+(3*K-4*A+1)*h.r+6*(-K+A)*V.r+(3*K-2*A)*v.r,H.g=6*(K-A)*Z.g+(3*K-4*A+1)*h.g+6*(-K+A)*V.g+(3*K-2*A)*v.g,H.b=6*(K-A)*Z.b+(3*K-4*A+1)*h.b+6*(-K+A)*V.b+(3*K-2*A)*v.b,H.a=6*(K-A)*Z.a+(3*K-4*A+1)*h.a+6*(-K+A)*V.a+(3*K-2*A)*v.a}static FromColor3(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D(Z.r,Z.g,Z.b,h)}static eh(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(Z[h],Z[h+1],Z[h+2],Z[h+3])}static FromArrayToRef(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=Z[h],V.g=Z[h+1],V.b=Z[h+2],V.a=Z[h+3]}static FromInts(Z,h,V,v){return new D(Z/255,h/255,V/255,v/255)}static CheckColors4(Z,h){if(Z.length===3*h){const h=[];for(let V=0;V<Z.length;V+=3){const v=V/3*4;h[v]=Z[V],h[v+1]=Z[V+1],h[v+2]=Z[V+2],h[v+3]=1}return h}return Z}}D._V8PerformanceHack=new D(.5,.5,.5,.5),Object.defineProperties(D.prototype,{dimension:{value:[4]},rank:{value:1}});class k{}k.Ih=(0,v.d)(3,N.Black),k.nd=(0,v.d)(3,(()=>new D(0,0,0,0))),(0,A.i)("BABYLON.Color3",N),(0,A.i)("BABYLON.Color4",D)}}]);