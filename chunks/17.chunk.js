"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[17],{11387:(m,S,h)=>{h.r(S),h.d(S,{RS:()=>I,Bb:()=>Z,TmpColors:()=>C});var l=h(11356),M=h(11293),O=h(11350),u=h(11359);function b(m){return Math.pow(m,O.h)}function q(m){return m<=.04045?.0773993808*m:Math.pow(.947867299*(m+.055),2.4)}function Y(m){return Math.pow(m,O.g)}function V(m){return m<=.0031308?12.92*m:1.055*Math.pow(m,.41666)-.055}class I{constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=m,this.g=S,this.b=h}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"RS"}getHashCode(){let m=255*this.r|0;return m=397*m^255*this.g,m=397*m^255*this.b,m}toArray(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m[S]=this.r,m[S+1]=this.g,m[S+2]=this.b,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return I.FromArrayToRef(m,S,this),this}toColor4(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new Z(this.r,this.g,this.b,m)}DM(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(m){return new I(this.r*m.r,this.g*m.g,this.b*m.b)}multiplyToRef(m,S){return S.r=this.r*m.r,S.g=this.g*m.g,S.b=this.b*m.b,S}multiplyInPlace(m){return this.r*=m.r,this.g*=m.g,this.b*=m.b,this}multiplyByFloats(m,S,h){return new I(this.r*m,this.g*S,this.b*h)}divide(m){throw new ReferenceError("Can not divide a color")}divideToRef(m,S){throw new ReferenceError("Can not divide a color")}divideInPlace(m){throw new ReferenceError("Can not divide a color")}minimizeInPlace(m){return this.minimizeInPlaceFromFloats(m.r,m.g,m.b)}maximizeInPlace(m){return this.maximizeInPlaceFromFloats(m.r,m.g,m.b)}minimizeInPlaceFromFloats(m,S,h){return this.r=Math.min(m,this.r),this.g=Math.min(S,this.g),this.b=Math.min(h,this.b),this}maximizeInPlaceFromFloats(m,S,h){return this.r=Math.max(m,this.r),this.g=Math.max(S,this.g),this.b=Math.max(h,this.b),this}floorToRef(m){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(m){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(m){return m&&this.r===m.r&&this.g===m.g&&this.b===m.b}equalsFloats(m,S,h){return this.equalsToFloats(m,S,h)}equalsToFloats(m,S,h){return this.r===m&&this.g===S&&this.b===h}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return(0,u.WithinEpsilon)(this.r,m.r,S)&&(0,u.WithinEpsilon)(this.g,m.g,S)&&(0,u.WithinEpsilon)(this.b,m.b,S)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(m){throw new ReferenceError("Can not negate a color")}scale(m){return new I(this.r*m,this.g*m,this.b*m)}scaleInPlace(m){return this.r*=m,this.g*=m,this.b*=m,this}scaleToRef(m,S){return S.r=this.r*m,S.g=this.g*m,S.b=this.b*m,S}scaleAndAddToRef(m,S){return S.r+=this.r*m,S.g+=this.g*m,S.b+=this.b*m,S}clampToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,u.Clamp)(this.r,m,S),h.g=(0,u.Clamp)(this.g,m,S),h.b=(0,u.Clamp)(this.b,m,S),h}add(m){return new I(this.r+m.r,this.g+m.g,this.b+m.b)}addInPlace(m){return this.r+=m.r,this.g+=m.g,this.b+=m.b,this}addInPlaceFromFloats(m,S,h){return this.r+=m,this.g+=S,this.b+=h,this}addToRef(m,S){return S.r=this.r+m.r,S.g=this.g+m.g,S.b=this.b+m.b,S}LS(m){return new I(this.r-m.r,this.g-m.g,this.b-m.b)}subtractToRef(m,S){return S.r=this.r-m.r,S.g=this.g-m.g,S.b=this.b-m.b,S}yI(m){return this.r-=m.r,this.g-=m.g,this.b-=m.b,this}subtractFromFloats(m,S,h){return new I(this.r-m,this.g-S,this.b-h)}subtractFromFloatsToRef(m,S,h,l){return l.r=this.r-m,l.g=this.g-S,l.b=this.b-h,l}clone(){return new I(this.r,this.g,this.b)}l(m){return this.r=m.r,this.g=m.g,this.b=m.b,this}Yb(m,S,h){return this.r=m,this.g=S,this.b=h,this}set(m,S,h){return this.Yb(m,S,h)}Zb(m){return this.r=this.g=this.b=m,this}toHexString(){const m=Math.round(255*this.r),S=Math.round(255*this.g),h=Math.round(255*this.b);return"#"+(0,u.ToHex)(m)+(0,u.ToHex)(S)+(0,u.ToHex)(h)}fromHexString(m){return"#"!==m.substring(0,1)||7!==m.length||(this.r=parseInt(m.substring(1,3),16)/255,this.g=parseInt(m.substring(3,5),16)/255,this.b=parseInt(m.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new I)}toHSVToRef(m){const S=this.r,h=this.g,l=this.b,M=Math.max(S,h,l),O=Math.min(S,h,l);let u=0,b=0;const q=M,Y=M-O;return 0!==M&&(b=Y/M),M!=O&&(M==S?(u=(h-l)/Y,h<l&&(u+=6)):M==h?u=(l-S)/Y+2:M==l&&(u=(S-h)/Y+4),u*=60),m.r=u,m.g=b,m.b=q,m}toLinearSpace(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new I;return this.toLinearSpaceToRef(S,m),S}toLinearSpaceToRef(m){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(m.r=q(this.r),m.g=q(this.g),m.b=q(this.b)):(m.r=b(this.r),m.g=b(this.g),m.b=b(this.b)),this}toGammaSpace(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new I;return this.toGammaSpaceToRef(S,m),S}toGammaSpaceToRef(m){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(m.r=V(this.r),m.g=V(this.g),m.b=V(this.b)):(m.r=Y(this.r),m.g=Y(this.g),m.b=Y(this.b)),this}static HSVtoRGBToRef(m,S,h,l){const M=h*S,O=m/60,u=M*(1-Math.abs(O%2-1));let b=0,q=0,Y=0;O>=0&&O<=1?(b=M,q=u):O>=1&&O<=2?(b=u,q=M):O>=2&&O<=3?(q=M,Y=u):O>=3&&O<=4?(q=u,Y=M):O>=4&&O<=5?(b=u,Y=M):O>=5&&O<=6&&(b=M,Y=u);const V=h-M;return l.r=b+V,l.g=q+V,l.b=Y+V,l}static FromHSV(m,S,h){const l=new I(0,0,0);return I.HSVtoRGBToRef(m,S,h,l),l}static FromHexString(m){return new I(0,0,0).fromHexString(m)}static yS(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new I(m[S],m[S+1],m[S+2])}static FromArrayToRef(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=m[S],h.g=m[S+1],h.b=m[S+2]}static FromInts(m,S,h){return new I(m/255,S/255,h/255)}static Lerp(m,S,h){const l=new I(0,0,0);return I.LerpToRef(m,S,h,l),l}static LerpToRef(m,S,h,l){l.r=m.r+(S.r-m.r)*h,l.g=m.g+(S.g-m.g)*h,l.b=m.b+(S.b-m.b)*h}static Hermite(m,S,h,l,M){const O=M*M,u=M*O,b=2*u-3*O+1,q=-2*u+3*O,Y=u-2*O+M,V=u-O,Z=m.r*b+h.r*q+S.r*Y+l.r*V,C=m.g*b+h.g*q+S.g*Y+l.g*V,B=m.b*b+h.b*q+S.b*Y+l.b*V;return new I(Z,C,B)}static Hermite1stDerivative(m,S,h,l,M){const O=I.Black();return this.Hermite1stDerivativeToRef(m,S,h,l,M,O),O}static Hermite1stDerivativeToRef(m,S,h,l,M,O){const u=M*M;O.r=6*(u-M)*m.r+(3*u-4*M+1)*S.r+6*(-u+M)*h.r+(3*u-2*M)*l.r,O.g=6*(u-M)*m.g+(3*u-4*M+1)*S.g+6*(-u+M)*h.g+(3*u-2*M)*l.g,O.b=6*(u-M)*m.b+(3*u-4*M+1)*S.b+6*(-u+M)*h.b+(3*u-2*M)*l.b}static Red(){return new I(1,0,0)}static Green(){return new I(0,1,0)}static Blue(){return new I(0,0,1)}static Black(){return new I(0,0,0)}static get BlackReadOnly(){return I._BlackReadOnly}static White(){return new I(1,1,1)}static Purple(){return new I(.5,0,.5)}static Magenta(){return new I(1,0,1)}static Yellow(){return new I(1,1,0)}static Gray(){return new I(.5,.5,.5)}static Teal(){return new I(0,1,1)}static Random(){return new I(Math.random(),Math.random(),Math.random())}}I._V8PerformanceHack=new I(.5,.5,.5),I._BlackReadOnly=I.Black(),Object.defineProperties(I.prototype,{dimension:{value:[3]},rank:{value:1}});class Z{constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=m,this.g=S,this.b=h,this.a=l}DM(){return[this.r,this.g,this.b,this.a]}toArray(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return m[S]=this.r,m[S+1]=this.g,m[S+2]=this.b,m[S+3]=this.a,this}yh(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=m[S],this.g=m[S+1],this.b=m[S+2],this.a=m[S+3],this}equals(m){return m&&this.r===m.r&&this.g===m.g&&this.b===m.b&&this.a===m.a}add(m){return new Z(this.r+m.r,this.g+m.g,this.b+m.b,this.a+m.a)}addToRef(m,S){return S.r=this.r+m.r,S.g=this.g+m.g,S.b=this.b+m.b,S.a=this.a+m.a,S}addInPlace(m){return this.r+=m.r,this.g+=m.g,this.b+=m.b,this.a+=m.a,this}addInPlaceFromFloats(m,S,h,l){return this.r+=m,this.g+=S,this.b+=h,this.a+=l,this}LS(m){return new Z(this.r-m.r,this.g-m.g,this.b-m.b,this.a-m.a)}subtractToRef(m,S){return S.r=this.r-m.r,S.g=this.g-m.g,S.b=this.b-m.b,S.a=this.a-m.a,S}yI(m){return this.r-=m.r,this.g-=m.g,this.b-=m.b,this.a-=m.a,this}subtractFromFloats(m,S,h,l){return new Z(this.r-m,this.g-S,this.b-h,this.a-l)}subtractFromFloatsToRef(m,S,h,l,M){return M.r=this.r-m,M.g=this.g-S,M.b=this.b-h,M.a=this.a-l,M}scale(m){return new Z(this.r*m,this.g*m,this.b*m,this.a*m)}scaleInPlace(m){return this.r*=m,this.g*=m,this.b*=m,this.a*=m,this}scaleToRef(m,S){return S.r=this.r*m,S.g=this.g*m,S.b=this.b*m,S.a=this.a*m,S}scaleAndAddToRef(m,S){return S.r+=this.r*m,S.g+=this.g*m,S.b+=this.b*m,S.a+=this.a*m,S}clampToRef(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,u.Clamp)(this.r,m,S),h.g=(0,u.Clamp)(this.g,m,S),h.b=(0,u.Clamp)(this.b,m,S),h.a=(0,u.Clamp)(this.a,m,S),h}multiply(m){return new Z(this.r*m.r,this.g*m.g,this.b*m.b,this.a*m.a)}multiplyToRef(m,S){return S.r=this.r*m.r,S.g=this.g*m.g,S.b=this.b*m.b,S.a=this.a*m.a,S}multiplyInPlace(m){return this.r*=m.r,this.g*=m.g,this.b*=m.b,this.a*=m.a,this}multiplyByFloats(m,S,h,l){return new Z(this.r*m,this.g*S,this.b*h,this.a*l)}divide(m){throw new ReferenceError("Can not divide a color")}divideToRef(m,S){throw new ReferenceError("Can not divide a color")}divideInPlace(m){throw new ReferenceError("Can not divide a color")}minimizeInPlace(m){return this.r=Math.min(this.r,m.r),this.g=Math.min(this.g,m.g),this.b=Math.min(this.b,m.b),this.a=Math.min(this.a,m.a),this}maximizeInPlace(m){return this.r=Math.max(this.r,m.r),this.g=Math.max(this.g,m.g),this.b=Math.max(this.b,m.b),this.a=Math.max(this.a,m.a),this}minimizeInPlaceFromFloats(m,S,h,l){return this.r=Math.min(m,this.r),this.g=Math.min(S,this.g),this.b=Math.min(h,this.b),this.a=Math.min(l,this.a),this}maximizeInPlaceFromFloats(m,S,h,l){return this.r=Math.max(m,this.r),this.g=Math.max(S,this.g),this.b=Math.max(h,this.b),this.a=Math.max(l,this.a),this}floorToRef(m){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(m){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(m){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:O.d;return(0,u.WithinEpsilon)(this.r,m.r,S)&&(0,u.WithinEpsilon)(this.g,m.g,S)&&(0,u.WithinEpsilon)(this.b,m.b,S)&&(0,u.WithinEpsilon)(this.a,m.a,S)}equalsToFloats(m,S,h,l){return this.r===m&&this.g===S&&this.b===h&&this.a===l}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Bb"}getHashCode(){let m=255*this.r|0;return m=397*m^255*this.g,m=397*m^255*this.b,m=397*m^255*this.a,m}clone(){return(new Z).l(this)}l(m){return this.r=m.r,this.g=m.g,this.b=m.b,this.a=m.a,this}Yb(m,S,h,l){return this.r=m,this.g=S,this.b=h,this.a=l,this}set(m,S,h,l){return this.Yb(m,S,h,l)}Zb(m){return this.r=this.g=this.b=this.a=m,this}toHexString(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=Math.round(255*this.r),h=Math.round(255*this.g),l=Math.round(255*this.b);if(m)return"#"+(0,u.ToHex)(S)+(0,u.ToHex)(h)+(0,u.ToHex)(l);const M=Math.round(255*this.a);return"#"+(0,u.ToHex)(S)+(0,u.ToHex)(h)+(0,u.ToHex)(l)+(0,u.ToHex)(M)}fromHexString(m){return"#"!==m.substring(0,1)||9!==m.length&&7!==m.length||(this.r=parseInt(m.substring(1,3),16)/255,this.g=parseInt(m.substring(3,5),16)/255,this.b=parseInt(m.substring(5,7),16)/255,9===m.length&&(this.a=parseInt(m.substring(7,9),16)/255)),this}toLinearSpace(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new Z;return this.toLinearSpaceToRef(S,m),S}toLinearSpaceToRef(m){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(m.r=q(this.r),m.g=q(this.g),m.b=q(this.b)):(m.r=b(this.r),m.g=b(this.g),m.b=b(this.b)),m.a=this.a,this}toGammaSpace(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new Z;return this.toGammaSpaceToRef(S,m),S}toGammaSpaceToRef(m){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(m.r=V(this.r),m.g=V(this.g),m.b=V(this.b)):(m.r=Y(this.r),m.g=Y(this.g),m.b=Y(this.b)),m.a=this.a,this}static FromHexString(m){return"#"!==m.substring(0,1)||9!==m.length&&7!==m.length?new Z(0,0,0,0):new Z(0,0,0,1).fromHexString(m)}static Lerp(m,S,h){return Z.LerpToRef(m,S,h,new Z)}static LerpToRef(m,S,h,l){return l.r=m.r+(S.r-m.r)*h,l.g=m.g+(S.g-m.g)*h,l.b=m.b+(S.b-m.b)*h,l.a=m.a+(S.a-m.a)*h,l}static Hermite(m,S,h,l,M){const O=M*M,u=M*O,b=2*u-3*O+1,q=-2*u+3*O,Y=u-2*O+M,V=u-O,I=m.r*b+h.r*q+S.r*Y+l.r*V,C=m.g*b+h.g*q+S.g*Y+l.g*V,B=m.b*b+h.b*q+S.b*Y+l.b*V,D=m.a*b+h.a*q+S.a*Y+l.a*V;return new Z(I,C,B,D)}static Hermite1stDerivative(m,S,h,l,M){const O=new Z;return this.Hermite1stDerivativeToRef(m,S,h,l,M,O),O}static Hermite1stDerivativeToRef(m,S,h,l,M,O){const u=M*M;O.r=6*(u-M)*m.r+(3*u-4*M+1)*S.r+6*(-u+M)*h.r+(3*u-2*M)*l.r,O.g=6*(u-M)*m.g+(3*u-4*M+1)*S.g+6*(-u+M)*h.g+(3*u-2*M)*l.g,O.b=6*(u-M)*m.b+(3*u-4*M+1)*S.b+6*(-u+M)*h.b+(3*u-2*M)*l.b,O.a=6*(u-M)*m.a+(3*u-4*M+1)*S.a+6*(-u+M)*h.a+(3*u-2*M)*l.a}static FromColor3(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Z(m.r,m.g,m.b,S)}static yS(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(m[S],m[S+1],m[S+2],m[S+3])}static FromArrayToRef(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=m[S],h.g=m[S+1],h.b=m[S+2],h.a=m[S+3]}static FromInts(m,S,h,l){return new Z(m/255,S/255,h/255,l/255)}static CheckColors4(m,S){if(m.length===3*S){const S=[];for(let h=0;h<m.length;h+=3){const l=h/3*4;S[l]=m[h],S[l+1]=m[h+1],S[l+2]=m[h+2],S[l+3]=1}return S}return m}}Z._V8PerformanceHack=new Z(.5,.5,.5,.5),Object.defineProperties(Z.prototype,{dimension:{value:[4]},rank:{value:1}});class C{}C.RS=(0,l.e)(3,I.Black),C.Bb=(0,l.e)(3,(()=>new Z(0,0,0,0))),(0,M.e)("BABYLON.Color3",I),(0,M.e)("BABYLON.Color4",Z)}}]);