"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[17],{11359:(F,b,Q)=>{Q.r(b),Q.d(b,{GQ:()=>K,sb:()=>e,TmpColors:()=>N});var C=Q(11320),z=Q(11265),t=Q(11318),g=Q(11329);function W(F){return Math.pow(F,t.j)}function Z(F){return F<=.04045?.0773993808*F:Math.pow(.947867299*(F+.055),2.4)}function q(F){return Math.pow(F,t.f)}function G(F){return F<=.0031308?12.92*F:1.055*Math.pow(F,.41666)-.055}class K{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=F,this.g=b,this.b=Q}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"GQ"}getHashCode(){let F=255*this.r|0;return F=397*F^255*this.g,F=397*F^255*this.b,F}toArray(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[b]=this.r,F[b+1]=this.g,F[b+2]=this.b,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(F,b,this),this}toColor4(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new e(this.r,this.g,this.b,F)}Lb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(F){return new K(this.r*F.r,this.g*F.g,this.b*F.b)}multiplyToRef(F,b){return b.r=this.r*F.r,b.g=this.g*F.g,b.b=this.b*F.b,b}multiplyInPlace(F){return this.r*=F.r,this.g*=F.g,this.b*=F.b,this}multiplyByFloats(F,b,Q){return new K(this.r*F,this.g*b,this.b*Q)}divide(F){throw new ReferenceError("Can not divide a color")}divideToRef(F,b){throw new ReferenceError("Can not divide a color")}divideInPlace(F){throw new ReferenceError("Can not divide a color")}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F.r,F.g,F.b)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F.r,F.g,F.b)}minimizeInPlaceFromFloats(F,b,Q){return this.r=Math.min(F,this.r),this.g=Math.min(b,this.g),this.b=Math.min(Q,this.b),this}maximizeInPlaceFromFloats(F,b,Q){return this.r=Math.max(F,this.r),this.g=Math.max(b,this.g),this.b=Math.max(Q,this.b),this}floorToRef(F){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(F){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(F){return F&&this.r===F.r&&this.g===F.g&&this.b===F.b}equalsFloats(F,b,Q){return this.equalsToFloats(F,b,Q)}equalsToFloats(F,b,Q){return this.r===F&&this.g===b&&this.b===Q}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return(0,g.WithinEpsilon)(this.r,F.r,b)&&(0,g.WithinEpsilon)(this.g,F.g,b)&&(0,g.WithinEpsilon)(this.b,F.b,b)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(F){throw new ReferenceError("Can not negate a color")}scale(F){return new K(this.r*F,this.g*F,this.b*F)}scaleInPlace(F){return this.r*=F,this.g*=F,this.b*=F,this}scaleToRef(F,b){return b.r=this.r*F,b.g=this.g*F,b.b=this.b*F,b}scaleAndAddToRef(F,b){return b.r+=this.r*F,b.g+=this.g*F,b.b+=this.b*F,b}clampToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0;return Q.r=(0,g.Clamp)(this.r,F,b),Q.g=(0,g.Clamp)(this.g,F,b),Q.b=(0,g.Clamp)(this.b,F,b),Q}add(F){return new K(this.r+F.r,this.g+F.g,this.b+F.b)}addInPlace(F){return this.r+=F.r,this.g+=F.g,this.b+=F.b,this}addInPlaceFromFloats(F,b,Q){return this.r+=F,this.g+=b,this.b+=Q,this}addToRef(F,b){return b.r=this.r+F.r,b.g=this.g+F.g,b.b=this.b+F.b,b}WQ(F){return new K(this.r-F.r,this.g-F.g,this.b-F.b)}subtractToRef(F,b){return b.r=this.r-F.r,b.g=this.g-F.g,b.b=this.b-F.b,b}PK(F){return this.r-=F.r,this.g-=F.g,this.b-=F.b,this}subtractFromFloats(F,b,Q){return new K(this.r-F,this.g-b,this.b-Q)}subtractFromFloatsToRef(F,b,Q,C){return C.r=this.r-F,C.g=this.g-b,C.b=this.b-Q,C}clone(){return new K(this.r,this.g,this.b)}W(F){return this.r=F.r,this.g=F.g,this.b=F.b,this}jb(F,b,Q){return this.r=F,this.g=b,this.b=Q,this}set(F,b,Q){return this.jb(F,b,Q)}Yb(F){return this.r=this.g=this.b=F,this}toHexString(){const F=Math.round(255*this.r),b=Math.round(255*this.g),Q=Math.round(255*this.b);return"#"+(0,g.ToHex)(F)+(0,g.ToHex)(b)+(0,g.ToHex)(Q)}fromHexString(F){return"#"!==F.substring(0,1)||7!==F.length||(this.r=parseInt(F.substring(1,3),16)/255,this.g=parseInt(F.substring(3,5),16)/255,this.b=parseInt(F.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new K)}toHSVToRef(F){const b=this.r,Q=this.g,C=this.b,z=Math.max(b,Q,C),t=Math.min(b,Q,C);let g=0,W=0;const Z=z,q=z-t;return 0!==z&&(W=q/z),z!=t&&(z==b?(g=(Q-C)/q,Q<C&&(g+=6)):z==Q?g=(C-b)/q+2:z==C&&(g=(b-Q)/q+4),g*=60),F.r=g,F.g=W,F.b=Z,F}toLinearSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new K;return this.toLinearSpaceToRef(b,F),b}toLinearSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=Z(this.r),F.g=Z(this.g),F.b=Z(this.b)):(F.r=W(this.r),F.g=W(this.g),F.b=W(this.b)),this}toGammaSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new K;return this.toGammaSpaceToRef(b,F),b}toGammaSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=G(this.r),F.g=G(this.g),F.b=G(this.b)):(F.r=q(this.r),F.g=q(this.g),F.b=q(this.b)),this}static HSVtoRGBToRef(F,b,Q,C){const z=Q*b,t=F/60,g=z*(1-Math.abs(t%2-1));let W=0,Z=0,q=0;t>=0&&t<=1?(W=z,Z=g):t>=1&&t<=2?(W=g,Z=z):t>=2&&t<=3?(Z=z,q=g):t>=3&&t<=4?(Z=g,q=z):t>=4&&t<=5?(W=g,q=z):t>=5&&t<=6&&(W=z,q=g);const G=Q-z;return C.r=W+G,C.g=Z+G,C.b=q+G,C}static FromHSV(F,b,Q){const C=new K(0,0,0);return K.HSVtoRGBToRef(F,b,Q,C),C}static FromHexString(F){return new K(0,0,0).fromHexString(F)}static KQ(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(F[b],F[b+1],F[b+2])}static FromArrayToRef(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2?arguments[2]:void 0;Q.r=F[b],Q.g=F[b+1],Q.b=F[b+2]}static FromInts(F,b,Q){return new K(F/255,b/255,Q/255)}static Lerp(F,b,Q){const C=new K(0,0,0);return K.LerpToRef(F,b,Q,C),C}static LerpToRef(F,b,Q,C){C.r=F.r+(b.r-F.r)*Q,C.g=F.g+(b.g-F.g)*Q,C.b=F.b+(b.b-F.b)*Q}static Hermite(F,b,Q,C,z){const t=z*z,g=z*t,W=2*g-3*t+1,Z=-2*g+3*t,q=g-2*t+z,G=g-t,e=F.r*W+Q.r*Z+b.r*q+C.r*G,N=F.g*W+Q.g*Z+b.g*q+C.g*G,y=F.b*W+Q.b*Z+b.b*q+C.b*G;return new K(e,N,y)}static Hermite1stDerivative(F,b,Q,C,z){const t=K.Black();return this.Hermite1stDerivativeToRef(F,b,Q,C,z,t),t}static Hermite1stDerivativeToRef(F,b,Q,C,z,t){const g=z*z;t.r=6*(g-z)*F.r+(3*g-4*z+1)*b.r+6*(-g+z)*Q.r+(3*g-2*z)*C.r,t.g=6*(g-z)*F.g+(3*g-4*z+1)*b.g+6*(-g+z)*Q.g+(3*g-2*z)*C.g,t.b=6*(g-z)*F.b+(3*g-4*z+1)*b.b+6*(-g+z)*Q.b+(3*g-2*z)*C.b}static Red(){return new K(1,0,0)}static Green(){return new K(0,1,0)}static Blue(){return new K(0,0,1)}static Black(){return new K(0,0,0)}static get BlackReadOnly(){return K._BlackReadOnly}static White(){return new K(1,1,1)}static Purple(){return new K(.5,0,.5)}static Magenta(){return new K(1,0,1)}static Yellow(){return new K(1,1,0)}static Gray(){return new K(.5,.5,.5)}static Teal(){return new K(0,1,1)}static Random(){return new K(Math.random(),Math.random(),Math.random())}}K._V8PerformanceHack=new K(.5,.5,.5),K._BlackReadOnly=K.Black(),Object.defineProperties(K.prototype,{dimension:{value:[3]},rank:{value:1}});class e{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=F,this.g=b,this.b=Q,this.a=C}Lb(){return[this.r,this.g,this.b,this.a]}toArray(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[b]=this.r,F[b+1]=this.g,F[b+2]=this.b,F[b+3]=this.a,this}tC(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=F[b],this.g=F[b+1],this.b=F[b+2],this.a=F[b+3],this}equals(F){return F&&this.r===F.r&&this.g===F.g&&this.b===F.b&&this.a===F.a}add(F){return new e(this.r+F.r,this.g+F.g,this.b+F.b,this.a+F.a)}addToRef(F,b){return b.r=this.r+F.r,b.g=this.g+F.g,b.b=this.b+F.b,b.a=this.a+F.a,b}addInPlace(F){return this.r+=F.r,this.g+=F.g,this.b+=F.b,this.a+=F.a,this}addInPlaceFromFloats(F,b,Q,C){return this.r+=F,this.g+=b,this.b+=Q,this.a+=C,this}WQ(F){return new e(this.r-F.r,this.g-F.g,this.b-F.b,this.a-F.a)}subtractToRef(F,b){return b.r=this.r-F.r,b.g=this.g-F.g,b.b=this.b-F.b,b.a=this.a-F.a,b}PK(F){return this.r-=F.r,this.g-=F.g,this.b-=F.b,this.a-=F.a,this}subtractFromFloats(F,b,Q,C){return new e(this.r-F,this.g-b,this.b-Q,this.a-C)}subtractFromFloatsToRef(F,b,Q,C,z){return z.r=this.r-F,z.g=this.g-b,z.b=this.b-Q,z.a=this.a-C,z}scale(F){return new e(this.r*F,this.g*F,this.b*F,this.a*F)}scaleInPlace(F){return this.r*=F,this.g*=F,this.b*=F,this.a*=F,this}scaleToRef(F,b){return b.r=this.r*F,b.g=this.g*F,b.b=this.b*F,b.a=this.a*F,b}scaleAndAddToRef(F,b){return b.r+=this.r*F,b.g+=this.g*F,b.b+=this.b*F,b.a+=this.a*F,b}clampToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Q=arguments.length>2?arguments[2]:void 0;return Q.r=(0,g.Clamp)(this.r,F,b),Q.g=(0,g.Clamp)(this.g,F,b),Q.b=(0,g.Clamp)(this.b,F,b),Q.a=(0,g.Clamp)(this.a,F,b),Q}multiply(F){return new e(this.r*F.r,this.g*F.g,this.b*F.b,this.a*F.a)}multiplyToRef(F,b){return b.r=this.r*F.r,b.g=this.g*F.g,b.b=this.b*F.b,b.a=this.a*F.a,b}multiplyInPlace(F){return this.r*=F.r,this.g*=F.g,this.b*=F.b,this.a*=F.a,this}multiplyByFloats(F,b,Q,C){return new e(this.r*F,this.g*b,this.b*Q,this.a*C)}divide(F){throw new ReferenceError("Can not divide a color")}divideToRef(F,b){throw new ReferenceError("Can not divide a color")}divideInPlace(F){throw new ReferenceError("Can not divide a color")}minimizeInPlace(F){return this.r=Math.min(this.r,F.r),this.g=Math.min(this.g,F.g),this.b=Math.min(this.b,F.b),this.a=Math.min(this.a,F.a),this}maximizeInPlace(F){return this.r=Math.max(this.r,F.r),this.g=Math.max(this.g,F.g),this.b=Math.max(this.b,F.b),this.a=Math.max(this.a,F.a),this}minimizeInPlaceFromFloats(F,b,Q,C){return this.r=Math.min(F,this.r),this.g=Math.min(b,this.g),this.b=Math.min(Q,this.b),this.a=Math.min(C,this.a),this}maximizeInPlaceFromFloats(F,b,Q,C){return this.r=Math.max(F,this.r),this.g=Math.max(b,this.g),this.b=Math.max(Q,this.b),this.a=Math.max(C,this.a),this}floorToRef(F){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(F){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(F){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:t.c;return(0,g.WithinEpsilon)(this.r,F.r,b)&&(0,g.WithinEpsilon)(this.g,F.g,b)&&(0,g.WithinEpsilon)(this.b,F.b,b)&&(0,g.WithinEpsilon)(this.a,F.a,b)}equalsToFloats(F,b,Q,C){return this.r===F&&this.g===b&&this.b===Q&&this.a===C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"sb"}getHashCode(){let F=255*this.r|0;return F=397*F^255*this.g,F=397*F^255*this.b,F=397*F^255*this.a,F}clone(){return(new e).W(this)}W(F){return this.r=F.r,this.g=F.g,this.b=F.b,this.a=F.a,this}jb(F,b,Q,C){return this.r=F,this.g=b,this.b=Q,this.a=C,this}set(F,b,Q,C){return this.jb(F,b,Q,C)}Yb(F){return this.r=this.g=this.b=this.a=F,this}toHexString(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=Math.round(255*this.r),Q=Math.round(255*this.g),C=Math.round(255*this.b);if(F)return"#"+(0,g.ToHex)(b)+(0,g.ToHex)(Q)+(0,g.ToHex)(C);const z=Math.round(255*this.a);return"#"+(0,g.ToHex)(b)+(0,g.ToHex)(Q)+(0,g.ToHex)(C)+(0,g.ToHex)(z)}fromHexString(F){return"#"!==F.substring(0,1)||9!==F.length&&7!==F.length||(this.r=parseInt(F.substring(1,3),16)/255,this.g=parseInt(F.substring(3,5),16)/255,this.b=parseInt(F.substring(5,7),16)/255,9===F.length&&(this.a=parseInt(F.substring(7,9),16)/255)),this}toLinearSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new e;return this.toLinearSpaceToRef(b,F),b}toLinearSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=Z(this.r),F.g=Z(this.g),F.b=Z(this.b)):(F.r=W(this.r),F.g=W(this.g),F.b=W(this.b)),F.a=this.a,this}toGammaSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new e;return this.toGammaSpaceToRef(b,F),b}toGammaSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=G(this.r),F.g=G(this.g),F.b=G(this.b)):(F.r=q(this.r),F.g=q(this.g),F.b=q(this.b)),F.a=this.a,this}static FromHexString(F){return"#"!==F.substring(0,1)||9!==F.length&&7!==F.length?new e(0,0,0,0):new e(0,0,0,1).fromHexString(F)}static Lerp(F,b,Q){return e.LerpToRef(F,b,Q,new e)}static LerpToRef(F,b,Q,C){return C.r=F.r+(b.r-F.r)*Q,C.g=F.g+(b.g-F.g)*Q,C.b=F.b+(b.b-F.b)*Q,C.a=F.a+(b.a-F.a)*Q,C}static Hermite(F,b,Q,C,z){const t=z*z,g=z*t,W=2*g-3*t+1,Z=-2*g+3*t,q=g-2*t+z,G=g-t,K=F.r*W+Q.r*Z+b.r*q+C.r*G,N=F.g*W+Q.g*Z+b.g*q+C.g*G,y=F.b*W+Q.b*Z+b.b*q+C.b*G,E=F.a*W+Q.a*Z+b.a*q+C.a*G;return new e(K,N,y,E)}static Hermite1stDerivative(F,b,Q,C,z){const t=new e;return this.Hermite1stDerivativeToRef(F,b,Q,C,z,t),t}static Hermite1stDerivativeToRef(F,b,Q,C,z,t){const g=z*z;t.r=6*(g-z)*F.r+(3*g-4*z+1)*b.r+6*(-g+z)*Q.r+(3*g-2*z)*C.r,t.g=6*(g-z)*F.g+(3*g-4*z+1)*b.g+6*(-g+z)*Q.g+(3*g-2*z)*C.g,t.b=6*(g-z)*F.b+(3*g-4*z+1)*b.b+6*(-g+z)*Q.b+(3*g-2*z)*C.b,t.a=6*(g-z)*F.a+(3*g-4*z+1)*b.a+6*(-g+z)*Q.a+(3*g-2*z)*C.a}static FromColor3(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new e(F.r,F.g,F.b,b)}static KQ(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(F[b],F[b+1],F[b+2],F[b+3])}static FromArrayToRef(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2?arguments[2]:void 0;Q.r=F[b],Q.g=F[b+1],Q.b=F[b+2],Q.a=F[b+3]}static FromInts(F,b,Q,C){return new e(F/255,b/255,Q/255,C/255)}static CheckColors4(F,b){if(F.length===3*b){const b=[];for(let Q=0;Q<F.length;Q+=3){const C=Q/3*4;b[C]=F[Q],b[C+1]=F[Q+1],b[C+2]=F[Q+2],b[C+3]=1}return b}return F}}e._V8PerformanceHack=new e(.5,.5,.5,.5),Object.defineProperties(e.prototype,{dimension:{value:[4]},rank:{value:1}});class N{}N.GQ=(0,C.b)(3,K.Black),N.sb=(0,C.b)(3,(()=>new e(0,0,0,0))),(0,z.g)("BABYLON.Color3",K),(0,z.g)("BABYLON.Color4",e)}}]);