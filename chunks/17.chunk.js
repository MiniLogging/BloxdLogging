"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[17],{12406:(M,Z,P)=>{P.r(Z),P.d(Z,{uZ:()=>O,Ic:()=>H,TmpColors:()=>j});var x=P(12379),c=P(12317),w=P(12377),v=P(12387);function G(M){return Math.pow(M,w.g)}function mM(M){return M<=.04045?.0773993808*M:Math.pow(.947867299*(M+.055),2.4)}function K(M){return Math.pow(M,w.f)}function d(M){return M<=.0031308?12.92*M:1.055*Math.pow(M,.41666)-.055}class O{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=M,this.g=Z,this.b=P}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"uZ"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M}toArray(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[Z]=this.r,M[Z+1]=this.g,M[Z+2]=this.b,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(M,Z,this),this}toColor4(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new H(this.r,this.g,this.b,M)}nc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(M){return new O(this.r*M.r,this.g*M.g,this.b*M.b)}multiplyToRef(M,Z){return Z.r=this.r*M.r,Z.g=this.g*M.g,Z.b=this.b*M.b,Z}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this}multiplyByFloats(M,Z,P){return new O(this.r*M,this.g*Z,this.b*P)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,Z){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.r,M.g,M.b)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.r,M.g,M.b)}minimizeInPlaceFromFloats(M,Z,P){return this.r=Math.min(M,this.r),this.g=Math.min(Z,this.g),this.b=Math.min(P,this.b),this}maximizeInPlaceFromFloats(M,Z,P){return this.r=Math.max(M,this.r),this.g=Math.max(Z,this.g),this.b=Math.max(P,this.b),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b}equalsFloats(M,Z,P){return this.equalsToFloats(M,Z,P)}equalsToFloats(M,Z,P){return this.r===M&&this.g===Z&&this.b===P}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.c;return(0,v.WithinEpsilon)(this.r,M.r,Z)&&(0,v.WithinEpsilon)(this.g,M.g,Z)&&(0,v.WithinEpsilon)(this.b,M.b,Z)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}scale(M){return new O(this.r*M,this.g*M,this.b*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this}scaleToRef(M,Z){return Z.r=this.r*M,Z.g=this.g*M,Z.b=this.b*M,Z}scaleAndAddToRef(M,Z){return Z.r+=this.r*M,Z.g+=this.g*M,Z.b+=this.b*M,Z}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,v.Clamp)(this.r,M,Z),P.g=(0,v.Clamp)(this.g,M,Z),P.b=(0,v.Clamp)(this.b,M,Z),P}add(M){return new O(this.r+M.r,this.g+M.g,this.b+M.b)}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this}addInPlaceFromFloats(M,Z,P){return this.r+=M,this.g+=Z,this.b+=P,this}addToRef(M,Z){return Z.r=this.r+M.r,Z.g=this.g+M.g,Z.b=this.b+M.b,Z}UZ(M){return new O(this.r-M.r,this.g-M.g,this.b-M.b)}subtractToRef(M,Z){return Z.r=this.r-M.r,Z.g=this.g-M.g,Z.b=this.b-M.b,Z}MH(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this}subtractFromFloats(M,Z,P){return new O(this.r-M,this.g-Z,this.b-P)}subtractFromFloatsToRef(M,Z,P,x){return x.r=this.r-M,x.g=this.g-Z,x.b=this.b-P,x}clone(){return new O(this.r,this.g,this.b)}v(M){return this.r=M.r,this.g=M.g,this.b=M.b,this}lc(M,Z,P){return this.r=M,this.g=Z,this.b=P,this}set(M,Z,P){return this.lc(M,Z,P)}Qc(M){return this.r=this.g=this.b=M,this}toHexString(){const M=Math.round(255*this.r),Z=Math.round(255*this.g),P=Math.round(255*this.b);return"#"+(0,v.ToHex)(M)+(0,v.ToHex)(Z)+(0,v.ToHex)(P)}fromHexString(M){return"#"!==M.substring(0,1)||7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new O)}toHSVToRef(M){const Z=this.r,P=this.g,x=this.b,c=Math.max(Z,P,x),w=Math.min(Z,P,x);let v=0,G=0;const mM=c,K=c-w;return 0!==c&&(G=K/c),c!=w&&(c==Z?(v=(P-x)/K,P<x&&(v+=6)):c==P?v=(x-Z)/K+2:c==x&&(v=(Z-P)/K+4),v*=60),M.r=v,M.g=G,M.b=mM,M}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new O;return this.toLinearSpaceToRef(Z,M),Z}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=mM(this.r),M.g=mM(this.g),M.b=mM(this.b)):(M.r=G(this.r),M.g=G(this.g),M.b=G(this.b)),this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new O;return this.toGammaSpaceToRef(Z,M),Z}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=d(this.r),M.g=d(this.g),M.b=d(this.b)):(M.r=K(this.r),M.g=K(this.g),M.b=K(this.b)),this}static HSVtoRGBToRef(M,Z,P,x){const c=P*Z,w=M/60,v=c*(1-Math.abs(w%2-1));let G=0,mM=0,K=0;w>=0&&w<=1?(G=c,mM=v):w>=1&&w<=2?(G=v,mM=c):w>=2&&w<=3?(mM=c,K=v):w>=3&&w<=4?(mM=v,K=c):w>=4&&w<=5?(G=v,K=c):w>=5&&w<=6&&(G=c,K=v);const d=P-c;return x.r=G+d,x.g=mM+d,x.b=K+d,x}static FromHSV(M,Z,P){const x=new O(0,0,0);return O.HSVtoRGBToRef(M,Z,P,x),x}static FromHexString(M){return new O(0,0,0).fromHexString(M)}static NZ(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(M[Z],M[Z+1],M[Z+2])}static FromArrayToRef(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=M[Z],P.g=M[Z+1],P.b=M[Z+2]}static FromInts(M,Z,P){return new O(M/255,Z/255,P/255)}static Lerp(M,Z,P){const x=new O(0,0,0);return O.LerpToRef(M,Z,P,x),x}static LerpToRef(M,Z,P,x){x.r=M.r+(Z.r-M.r)*P,x.g=M.g+(Z.g-M.g)*P,x.b=M.b+(Z.b-M.b)*P}static Hermite(M,Z,P,x,c){const w=c*c,v=c*w,G=2*v-3*w+1,mM=-2*v+3*w,K=v-2*w+c,d=v-w,H=M.r*G+P.r*mM+Z.r*K+x.r*d,j=M.g*G+P.g*mM+Z.g*K+x.g*d,B=M.b*G+P.b*mM+Z.b*K+x.b*d;return new O(H,j,B)}static Hermite1stDerivative(M,Z,P,x,c){const w=O.Black();return this.Hermite1stDerivativeToRef(M,Z,P,x,c,w),w}static Hermite1stDerivativeToRef(M,Z,P,x,c,w){const v=c*c;w.r=6*(v-c)*M.r+(3*v-4*c+1)*Z.r+6*(-v+c)*P.r+(3*v-2*c)*x.r,w.g=6*(v-c)*M.g+(3*v-4*c+1)*Z.g+6*(-v+c)*P.g+(3*v-2*c)*x.g,w.b=6*(v-c)*M.b+(3*v-4*c+1)*Z.b+6*(-v+c)*P.b+(3*v-2*c)*x.b}static Red(){return new O(1,0,0)}static Green(){return new O(0,1,0)}static Blue(){return new O(0,0,1)}static Black(){return new O(0,0,0)}static get BlackReadOnly(){return O._BlackReadOnly}static White(){return new O(1,1,1)}static Purple(){return new O(.5,0,.5)}static Magenta(){return new O(1,0,1)}static Yellow(){return new O(1,1,0)}static Gray(){return new O(.5,.5,.5)}static Teal(){return new O(0,1,1)}static Random(){return new O(Math.random(),Math.random(),Math.random())}}O._V8PerformanceHack=new O(.5,.5,.5),O._BlackReadOnly=O.Black(),Object.defineProperties(O.prototype,{dimension:{value:[3]},rank:{value:1}});class H{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=M,this.g=Z,this.b=P,this.a=x}nc(){return[this.r,this.g,this.b,this.a]}toArray(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[Z]=this.r,M[Z+1]=this.g,M[Z+2]=this.b,M[Z+3]=this.a,this}jP(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=M[Z],this.g=M[Z+1],this.b=M[Z+2],this.a=M[Z+3],this}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b&&this.a===M.a}add(M){return new H(this.r+M.r,this.g+M.g,this.b+M.b,this.a+M.a)}addToRef(M,Z){return Z.r=this.r+M.r,Z.g=this.g+M.g,Z.b=this.b+M.b,Z.a=this.a+M.a,Z}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this.a+=M.a,this}addInPlaceFromFloats(M,Z,P,x){return this.r+=M,this.g+=Z,this.b+=P,this.a+=x,this}UZ(M){return new H(this.r-M.r,this.g-M.g,this.b-M.b,this.a-M.a)}subtractToRef(M,Z){return Z.r=this.r-M.r,Z.g=this.g-M.g,Z.b=this.b-M.b,Z.a=this.a-M.a,Z}MH(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this.a-=M.a,this}subtractFromFloats(M,Z,P,x){return new H(this.r-M,this.g-Z,this.b-P,this.a-x)}subtractFromFloatsToRef(M,Z,P,x,c){return c.r=this.r-M,c.g=this.g-Z,c.b=this.b-P,c.a=this.a-x,c}scale(M){return new H(this.r*M,this.g*M,this.b*M,this.a*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this.a*=M,this}scaleToRef(M,Z){return Z.r=this.r*M,Z.g=this.g*M,Z.b=this.b*M,Z.a=this.a*M,Z}scaleAndAddToRef(M,Z){return Z.r+=this.r*M,Z.g+=this.g*M,Z.b+=this.b*M,Z.a+=this.a*M,Z}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,P=arguments.length>2?arguments[2]:void 0;return P.r=(0,v.Clamp)(this.r,M,Z),P.g=(0,v.Clamp)(this.g,M,Z),P.b=(0,v.Clamp)(this.b,M,Z),P.a=(0,v.Clamp)(this.a,M,Z),P}multiply(M){return new H(this.r*M.r,this.g*M.g,this.b*M.b,this.a*M.a)}multiplyToRef(M,Z){return Z.r=this.r*M.r,Z.g=this.g*M.g,Z.b=this.b*M.b,Z.a=this.a*M.a,Z}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this.a*=M.a,this}multiplyByFloats(M,Z,P,x){return new H(this.r*M,this.g*Z,this.b*P,this.a*x)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,Z){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.r=Math.min(this.r,M.r),this.g=Math.min(this.g,M.g),this.b=Math.min(this.b,M.b),this.a=Math.min(this.a,M.a),this}maximizeInPlace(M){return this.r=Math.max(this.r,M.r),this.g=Math.max(this.g,M.g),this.b=Math.max(this.b,M.b),this.a=Math.max(this.a,M.a),this}minimizeInPlaceFromFloats(M,Z,P,x){return this.r=Math.min(M,this.r),this.g=Math.min(Z,this.g),this.b=Math.min(P,this.b),this.a=Math.min(x,this.a),this}maximizeInPlaceFromFloats(M,Z,P,x){return this.r=Math.max(M,this.r),this.g=Math.max(Z,this.g),this.b=Math.max(P,this.b),this.a=Math.max(x,this.a),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:w.c;return(0,v.WithinEpsilon)(this.r,M.r,Z)&&(0,v.WithinEpsilon)(this.g,M.g,Z)&&(0,v.WithinEpsilon)(this.b,M.b,Z)&&(0,v.WithinEpsilon)(this.a,M.a,Z)}equalsToFloats(M,Z,P,x){return this.r===M&&this.g===Z&&this.b===P&&this.a===x}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Ic"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M=397*M^255*this.a,M}clone(){return(new H).v(this)}v(M){return this.r=M.r,this.g=M.g,this.b=M.b,this.a=M.a,this}lc(M,Z,P,x){return this.r=M,this.g=Z,this.b=P,this.a=x,this}set(M,Z,P,x){return this.lc(M,Z,P,x)}Qc(M){return this.r=this.g=this.b=this.a=M,this}toHexString(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=Math.round(255*this.r),P=Math.round(255*this.g),x=Math.round(255*this.b);if(M)return"#"+(0,v.ToHex)(Z)+(0,v.ToHex)(P)+(0,v.ToHex)(x);const c=Math.round(255*this.a);return"#"+(0,v.ToHex)(Z)+(0,v.ToHex)(P)+(0,v.ToHex)(x)+(0,v.ToHex)(c)}fromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255,9===M.length&&(this.a=parseInt(M.substring(7,9),16)/255)),this}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new H;return this.toLinearSpaceToRef(Z,M),Z}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=mM(this.r),M.g=mM(this.g),M.b=mM(this.b)):(M.r=G(this.r),M.g=G(this.g),M.b=G(this.b)),M.a=this.a,this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const Z=new H;return this.toGammaSpaceToRef(Z,M),Z}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=d(this.r),M.g=d(this.g),M.b=d(this.b)):(M.r=K(this.r),M.g=K(this.g),M.b=K(this.b)),M.a=this.a,this}static FromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length?new H(0,0,0,0):new H(0,0,0,1).fromHexString(M)}static Lerp(M,Z,P){return H.LerpToRef(M,Z,P,new H)}static LerpToRef(M,Z,P,x){return x.r=M.r+(Z.r-M.r)*P,x.g=M.g+(Z.g-M.g)*P,x.b=M.b+(Z.b-M.b)*P,x.a=M.a+(Z.a-M.a)*P,x}static Hermite(M,Z,P,x,c){const w=c*c,v=c*w,G=2*v-3*w+1,mM=-2*v+3*w,K=v-2*w+c,d=v-w,O=M.r*G+P.r*mM+Z.r*K+x.r*d,j=M.g*G+P.g*mM+Z.g*K+x.g*d,B=M.b*G+P.b*mM+Z.b*K+x.b*d,U=M.a*G+P.a*mM+Z.a*K+x.a*d;return new H(O,j,B,U)}static Hermite1stDerivative(M,Z,P,x,c){const w=new H;return this.Hermite1stDerivativeToRef(M,Z,P,x,c,w),w}static Hermite1stDerivativeToRef(M,Z,P,x,c,w){const v=c*c;w.r=6*(v-c)*M.r+(3*v-4*c+1)*Z.r+6*(-v+c)*P.r+(3*v-2*c)*x.r,w.g=6*(v-c)*M.g+(3*v-4*c+1)*Z.g+6*(-v+c)*P.g+(3*v-2*c)*x.g,w.b=6*(v-c)*M.b+(3*v-4*c+1)*Z.b+6*(-v+c)*P.b+(3*v-2*c)*x.b,w.a=6*(v-c)*M.a+(3*v-4*c+1)*Z.a+6*(-v+c)*P.a+(3*v-2*c)*x.a}static FromColor3(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new H(M.r,M.g,M.b,Z)}static NZ(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new H(M[Z],M[Z+1],M[Z+2],M[Z+3])}static FromArrayToRef(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2?arguments[2]:void 0;P.r=M[Z],P.g=M[Z+1],P.b=M[Z+2],P.a=M[Z+3]}static FromInts(M,Z,P,x){return new H(M/255,Z/255,P/255,x/255)}static CheckColors4(M,Z){if(M.length===3*Z){const Z=[];for(let P=0;P<M.length;P+=3){const x=P/3*4;Z[x]=M[P],Z[x+1]=M[P+1],Z[x+2]=M[P+2],Z[x+3]=1}return Z}return M}}H._V8PerformanceHack=new H(.5,.5,.5,.5),Object.defineProperties(H.prototype,{dimension:{value:[4]},rank:{value:1}});class j{}j.uZ=(0,x.c)(3,O.Black),j.Ic=(0,x.c)(3,(()=>new H(0,0,0,0))),(0,c.g)("BABYLON.Color3",O),(0,c.g)("BABYLON.Color4",H)}}]);