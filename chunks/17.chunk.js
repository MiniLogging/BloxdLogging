"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[17],{12743:(K,A,T)=>{T.r(A),T.d(A,{DA:()=>Z,oO:()=>x,TmpColors:()=>J});var G=T(12714),B=T(12651),L=T(12706),f=T(12716);function O(K){return Math.pow(K,L.k)}function C(K){return K<=.04045?.0773993808*K:Math.pow(.947867299*(K+.055),2.4)}function Q(K){return Math.pow(K,L.h)}function Y(K){return K<=.0031308?12.92*K:1.055*Math.pow(K,.41666)-.055}class Z{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=K,this.g=A,this.b=T}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"DA"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K}toArray(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[A]=this.r,K[A+1]=this.g,K[A+2]=this.b,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z.FromArrayToRef(K,A,this),this}toColor4(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new x(this.r,this.g,this.b,K)}kf(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(K){return new Z(this.r*K.r,this.g*K.g,this.b*K.b)}multiplyToRef(K,A){return A.r=this.r*K.r,A.g=this.g*K.g,A.b=this.b*K.b,A}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this}multiplyByFloats(K,A,T){return new Z(this.r*K,this.g*A,this.b*T)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,A){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.r,K.g,K.b)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.r,K.g,K.b)}minimizeInPlaceFromFloats(K,A,T){return this.r=Math.min(K,this.r),this.g=Math.min(A,this.g),this.b=Math.min(T,this.b),this}maximizeInPlaceFromFloats(K,A,T){return this.r=Math.max(K,this.r),this.g=Math.max(A,this.g),this.b=Math.max(T,this.b),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b}equalsFloats(K,A,T){return this.equalsToFloats(K,A,T)}equalsToFloats(K,A,T){return this.r===K&&this.g===A&&this.b===T}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.c;return(0,f.WithinEpsilon)(this.r,K.r,A)&&(0,f.WithinEpsilon)(this.g,K.g,A)&&(0,f.WithinEpsilon)(this.b,K.b,A)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}scale(K){return new Z(this.r*K,this.g*K,this.b*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this}scaleToRef(K,A){return A.r=this.r*K,A.g=this.g*K,A.b=this.b*K,A}scaleAndAddToRef(K,A){return A.r+=this.r*K,A.g+=this.g*K,A.b+=this.b*K,A}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,f.Clamp)(this.r,K,A),T.g=(0,f.Clamp)(this.g,K,A),T.b=(0,f.Clamp)(this.b,K,A),T}add(K){return new Z(this.r+K.r,this.g+K.g,this.b+K.b)}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this}addInPlaceFromFloats(K,A,T){return this.r+=K,this.g+=A,this.b+=T,this}addToRef(K,A){return A.r=this.r+K.r,A.g=this.g+K.g,A.b=this.b+K.b,A}FA(K){return new Z(this.r-K.r,this.g-K.g,this.b-K.b)}subtractToRef(K,A){return A.r=this.r-K.r,A.g=this.g-K.g,A.b=this.b-K.b,A}DZ(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this}subtractFromFloats(K,A,T){return new Z(this.r-K,this.g-A,this.b-T)}subtractFromFloatsToRef(K,A,T,G){return G.r=this.r-K,G.g=this.g-A,G.b=this.b-T,G}clone(){return new Z(this.r,this.g,this.b)}G(K){return this.r=K.r,this.g=K.g,this.b=K.b,this}RO(K,A,T){return this.r=K,this.g=A,this.b=T,this}set(K,A,T){return this.RO(K,A,T)}IO(K){return this.r=this.g=this.b=K,this}toHexString(){const K=Math.round(255*this.r),A=Math.round(255*this.g),T=Math.round(255*this.b);return"#"+(0,f.ToHex)(K)+(0,f.ToHex)(A)+(0,f.ToHex)(T)}fromHexString(K){return"#"!==K.substring(0,1)||7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new Z)}toHSVToRef(K){const A=this.r,T=this.g,G=this.b,B=Math.max(A,T,G),L=Math.min(A,T,G);let f=0,O=0;const C=B,Q=B-L;return 0!==B&&(O=Q/B),B!=L&&(B==A?(f=(T-G)/Q,T<G&&(f+=6)):B==T?f=(G-A)/Q+2:B==G&&(f=(A-T)/Q+4),f*=60),K.r=f,K.g=O,K.b=C,K}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new Z;return this.toLinearSpaceToRef(A,K),A}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=C(this.r),K.g=C(this.g),K.b=C(this.b)):(K.r=O(this.r),K.g=O(this.g),K.b=O(this.b)),this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new Z;return this.toGammaSpaceToRef(A,K),A}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=Y(this.r),K.g=Y(this.g),K.b=Y(this.b)):(K.r=Q(this.r),K.g=Q(this.g),K.b=Q(this.b)),this}static HSVtoRGBToRef(K,A,T,G){const B=T*A,L=K/60,f=B*(1-Math.abs(L%2-1));let O=0,C=0,Q=0;L>=0&&L<=1?(O=B,C=f):L>=1&&L<=2?(O=f,C=B):L>=2&&L<=3?(C=B,Q=f):L>=3&&L<=4?(C=f,Q=B):L>=4&&L<=5?(O=f,Q=B):L>=5&&L<=6&&(O=B,Q=f);const Y=T-B;return G.r=O+Y,G.g=C+Y,G.b=Q+Y,G}static FromHSV(K,A,T){const G=new Z(0,0,0);return Z.HSVtoRGBToRef(K,A,T,G),G}static FromHexString(K){return new Z(0,0,0).fromHexString(K)}static mT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Z(K[A],K[A+1],K[A+2])}static FromArrayToRef(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=K[A],T.g=K[A+1],T.b=K[A+2]}static FromInts(K,A,T){return new Z(K/255,A/255,T/255)}static Lerp(K,A,T){const G=new Z(0,0,0);return Z.LerpToRef(K,A,T,G),G}static LerpToRef(K,A,T,G){G.r=K.r+(A.r-K.r)*T,G.g=K.g+(A.g-K.g)*T,G.b=K.b+(A.b-K.b)*T}static Hermite(K,A,T,G,B){const L=B*B,f=B*L,O=2*f-3*L+1,C=-2*f+3*L,Q=f-2*L+B,Y=f-L,x=K.r*O+T.r*C+A.r*Q+G.r*Y,J=K.g*O+T.g*C+A.g*Q+G.g*Y,b=K.b*O+T.b*C+A.b*Q+G.b*Y;return new Z(x,J,b)}static Hermite1stDerivative(K,A,T,G,B){const L=Z.Black();return this.Hermite1stDerivativeToRef(K,A,T,G,B,L),L}static Hermite1stDerivativeToRef(K,A,T,G,B,L){const f=B*B;L.r=6*(f-B)*K.r+(3*f-4*B+1)*A.r+6*(-f+B)*T.r+(3*f-2*B)*G.r,L.g=6*(f-B)*K.g+(3*f-4*B+1)*A.g+6*(-f+B)*T.g+(3*f-2*B)*G.g,L.b=6*(f-B)*K.b+(3*f-4*B+1)*A.b+6*(-f+B)*T.b+(3*f-2*B)*G.b}static Red(){return new Z(1,0,0)}static Green(){return new Z(0,1,0)}static Blue(){return new Z(0,0,1)}static Black(){return new Z(0,0,0)}static get BlackReadOnly(){return Z._BlackReadOnly}static White(){return new Z(1,1,1)}static Purple(){return new Z(.5,0,.5)}static Magenta(){return new Z(1,0,1)}static Yellow(){return new Z(1,1,0)}static Gray(){return new Z(.5,.5,.5)}static Teal(){return new Z(0,1,1)}static Random(){return new Z(Math.random(),Math.random(),Math.random())}}Z._V8PerformanceHack=new Z(.5,.5,.5),Z._BlackReadOnly=Z.Black(),Object.defineProperties(Z.prototype,{dimension:{value:[3]},rank:{value:1}});class x{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=K,this.g=A,this.b=T,this.a=G}kf(){return[this.r,this.g,this.b,this.a]}toArray(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[A]=this.r,K[A+1]=this.g,K[A+2]=this.b,K[A+3]=this.a,this}bT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=K[A],this.g=K[A+1],this.b=K[A+2],this.a=K[A+3],this}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b&&this.a===K.a}add(K){return new x(this.r+K.r,this.g+K.g,this.b+K.b,this.a+K.a)}addToRef(K,A){return A.r=this.r+K.r,A.g=this.g+K.g,A.b=this.b+K.b,A.a=this.a+K.a,A}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this.a+=K.a,this}addInPlaceFromFloats(K,A,T,G){return this.r+=K,this.g+=A,this.b+=T,this.a+=G,this}FA(K){return new x(this.r-K.r,this.g-K.g,this.b-K.b,this.a-K.a)}subtractToRef(K,A){return A.r=this.r-K.r,A.g=this.g-K.g,A.b=this.b-K.b,A.a=this.a-K.a,A}DZ(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this.a-=K.a,this}subtractFromFloats(K,A,T,G){return new x(this.r-K,this.g-A,this.b-T,this.a-G)}subtractFromFloatsToRef(K,A,T,G,B){return B.r=this.r-K,B.g=this.g-A,B.b=this.b-T,B.a=this.a-G,B}scale(K){return new x(this.r*K,this.g*K,this.b*K,this.a*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this.a*=K,this}scaleToRef(K,A){return A.r=this.r*K,A.g=this.g*K,A.b=this.b*K,A.a=this.a*K,A}scaleAndAddToRef(K,A){return A.r+=this.r*K,A.g+=this.g*K,A.b+=this.b*K,A.a+=this.a*K,A}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,f.Clamp)(this.r,K,A),T.g=(0,f.Clamp)(this.g,K,A),T.b=(0,f.Clamp)(this.b,K,A),T.a=(0,f.Clamp)(this.a,K,A),T}multiply(K){return new x(this.r*K.r,this.g*K.g,this.b*K.b,this.a*K.a)}multiplyToRef(K,A){return A.r=this.r*K.r,A.g=this.g*K.g,A.b=this.b*K.b,A.a=this.a*K.a,A}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this.a*=K.a,this}multiplyByFloats(K,A,T,G){return new x(this.r*K,this.g*A,this.b*T,this.a*G)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,A){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.r=Math.min(this.r,K.r),this.g=Math.min(this.g,K.g),this.b=Math.min(this.b,K.b),this.a=Math.min(this.a,K.a),this}maximizeInPlace(K){return this.r=Math.max(this.r,K.r),this.g=Math.max(this.g,K.g),this.b=Math.max(this.b,K.b),this.a=Math.max(this.a,K.a),this}minimizeInPlaceFromFloats(K,A,T,G){return this.r=Math.min(K,this.r),this.g=Math.min(A,this.g),this.b=Math.min(T,this.b),this.a=Math.min(G,this.a),this}maximizeInPlaceFromFloats(K,A,T,G){return this.r=Math.max(K,this.r),this.g=Math.max(A,this.g),this.b=Math.max(T,this.b),this.a=Math.max(G,this.a),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:L.c;return(0,f.WithinEpsilon)(this.r,K.r,A)&&(0,f.WithinEpsilon)(this.g,K.g,A)&&(0,f.WithinEpsilon)(this.b,K.b,A)&&(0,f.WithinEpsilon)(this.a,K.a,A)}equalsToFloats(K,A,T,G){return this.r===K&&this.g===A&&this.b===T&&this.a===G}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"oO"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K=397*K^255*this.a,K}clone(){return(new x).G(this)}G(K){return this.r=K.r,this.g=K.g,this.b=K.b,this.a=K.a,this}RO(K,A,T,G){return this.r=K,this.g=A,this.b=T,this.a=G,this}set(K,A,T,G){return this.RO(K,A,T,G)}IO(K){return this.r=this.g=this.b=this.a=K,this}toHexString(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=Math.round(255*this.r),T=Math.round(255*this.g),G=Math.round(255*this.b);if(K)return"#"+(0,f.ToHex)(A)+(0,f.ToHex)(T)+(0,f.ToHex)(G);const B=Math.round(255*this.a);return"#"+(0,f.ToHex)(A)+(0,f.ToHex)(T)+(0,f.ToHex)(G)+(0,f.ToHex)(B)}fromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255,9===K.length&&(this.a=parseInt(K.substring(7,9),16)/255)),this}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new x;return this.toLinearSpaceToRef(A,K),A}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=C(this.r),K.g=C(this.g),K.b=C(this.b)):(K.r=O(this.r),K.g=O(this.g),K.b=O(this.b)),K.a=this.a,this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new x;return this.toGammaSpaceToRef(A,K),A}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=Y(this.r),K.g=Y(this.g),K.b=Y(this.b)):(K.r=Q(this.r),K.g=Q(this.g),K.b=Q(this.b)),K.a=this.a,this}static FromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length?new x(0,0,0,0):new x(0,0,0,1).fromHexString(K)}static Lerp(K,A,T){return x.LerpToRef(K,A,T,new x)}static LerpToRef(K,A,T,G){return G.r=K.r+(A.r-K.r)*T,G.g=K.g+(A.g-K.g)*T,G.b=K.b+(A.b-K.b)*T,G.a=K.a+(A.a-K.a)*T,G}static Hermite(K,A,T,G,B){const L=B*B,f=B*L,O=2*f-3*L+1,C=-2*f+3*L,Q=f-2*L+B,Y=f-L,Z=K.r*O+T.r*C+A.r*Q+G.r*Y,J=K.g*O+T.g*C+A.g*Q+G.g*Y,b=K.b*O+T.b*C+A.b*Q+G.b*Y,P=K.a*O+T.a*C+A.a*Q+G.a*Y;return new x(Z,J,b,P)}static Hermite1stDerivative(K,A,T,G,B){const L=new x;return this.Hermite1stDerivativeToRef(K,A,T,G,B,L),L}static Hermite1stDerivativeToRef(K,A,T,G,B,L){const f=B*B;L.r=6*(f-B)*K.r+(3*f-4*B+1)*A.r+6*(-f+B)*T.r+(3*f-2*B)*G.r,L.g=6*(f-B)*K.g+(3*f-4*B+1)*A.g+6*(-f+B)*T.g+(3*f-2*B)*G.g,L.b=6*(f-B)*K.b+(3*f-4*B+1)*A.b+6*(-f+B)*T.b+(3*f-2*B)*G.b,L.a=6*(f-B)*K.a+(3*f-4*B+1)*A.a+6*(-f+B)*T.a+(3*f-2*B)*G.a}static FromColor3(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new x(K.r,K.g,K.b,A)}static mT(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new x(K[A],K[A+1],K[A+2],K[A+3])}static FromArrayToRef(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=K[A],T.g=K[A+1],T.b=K[A+2],T.a=K[A+3]}static FromInts(K,A,T,G){return new x(K/255,A/255,T/255,G/255)}static CheckColors4(K,A){if(K.length===3*A){const A=[];for(let T=0;T<K.length;T+=3){const G=T/3*4;A[G]=K[T],A[G+1]=K[T+1],A[G+2]=K[T+2],A[G+3]=1}return A}return K}}x._V8PerformanceHack=new x(.5,.5,.5,.5),Object.defineProperties(x.prototype,{dimension:{value:[4]},rank:{value:1}});class J{}J.DA=(0,G.b)(3,Z.Black),J.oO=(0,G.b)(3,(()=>new x(0,0,0,0))),(0,B.c)("BABYLON.Color3",Z),(0,B.c)("BABYLON.Color4",x)}}]);