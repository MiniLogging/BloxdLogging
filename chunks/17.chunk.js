"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{11230:(Z,x,F)=>{F.r(x),F.d(x,{Lx:()=>c,kj:()=>s,TmpColors:()=>J});var u=F(11192),G=F(11136),f=F(11188),Y=F(11194);function j(Z){return Math.pow(Z,f.l)}function d(Z){return Z<=.04045?.0773993808*Z:Math.pow(.947867299*(Z+.055),2.4)}function t(Z){return Math.pow(Z,f.j)}function o(Z){return Z<=.0031308?12.92*Z:1.055*Math.pow(Z,.41666)-.055}class c{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=Z,this.g=x,this.b=F}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Lx"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z}toArray(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[x]=this.r,Z[x+1]=this.g,Z[x+2]=this.b,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return c.FromArrayToRef(Z,x,this),this}toColor4(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new s(this.r,this.g,this.b,Z)}Wf(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(Z){return new c(this.r*Z.r,this.g*Z.g,this.b*Z.b)}multiplyToRef(Z,x){return x.r=this.r*Z.r,x.g=this.g*Z.g,x.b=this.b*Z.b,x}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this}multiplyByFloats(Z,x,F){return new c(this.r*Z,this.g*x,this.b*F)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,x){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.minimizeInPlaceFromFloats(Z.r,Z.g,Z.b)}maximizeInPlace(Z){return this.maximizeInPlaceFromFloats(Z.r,Z.g,Z.b)}minimizeInPlaceFromFloats(Z,x,F){return this.r=Math.min(Z,this.r),this.g=Math.min(x,this.g),this.b=Math.min(F,this.b),this}maximizeInPlaceFromFloats(Z,x,F){return this.r=Math.max(Z,this.r),this.g=Math.max(x,this.g),this.b=Math.max(F,this.b),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b}equalsFloats(Z,x,F){return this.equalsToFloats(Z,x,F)}equalsToFloats(Z,x,F){return this.r===Z&&this.g===x&&this.b===F}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return(0,Y.WithinEpsilon)(this.r,Z.r,x)&&(0,Y.WithinEpsilon)(this.g,Z.g,x)&&(0,Y.WithinEpsilon)(this.b,Z.b,x)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}scale(Z){return new c(this.r*Z,this.g*Z,this.b*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this}scaleToRef(Z,x){return x.r=this.r*Z,x.g=this.g*Z,x.b=this.b*Z,x}scaleAndAddToRef(Z,x){return x.r+=this.r*Z,x.g+=this.g*Z,x.b+=this.b*Z,x}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,Y.Clamp)(this.r,Z,x),F.g=(0,Y.Clamp)(this.g,Z,x),F.b=(0,Y.Clamp)(this.b,Z,x),F}add(Z){return new c(this.r+Z.r,this.g+Z.g,this.b+Z.b)}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this}addInPlaceFromFloats(Z,x,F){return this.r+=Z,this.g+=x,this.b+=F,this}addToRef(Z,x){return x.r=this.r+Z.r,x.g=this.g+Z.g,x.b=this.b+Z.b,x}Mx(Z){return new c(this.r-Z.r,this.g-Z.g,this.b-Z.b)}subtractToRef(Z,x){return x.r=this.r-Z.r,x.g=this.g-Z.g,x.b=this.b-Z.b,x}Dc(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this}subtractFromFloats(Z,x,F){return new c(this.r-Z,this.g-x,this.b-F)}subtractFromFloatsToRef(Z,x,F,u){return u.r=this.r-Z,u.g=this.g-x,u.b=this.b-F,u}clone(){return new c(this.r,this.g,this.b)}G(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this}Jj(Z,x,F){return this.r=Z,this.g=x,this.b=F,this}set(Z,x,F){return this.Jj(Z,x,F)}Uj(Z){return this.r=this.g=this.b=Z,this}toHexString(){const Z=Math.round(255*this.r),x=Math.round(255*this.g),F=Math.round(255*this.b);return"#"+(0,Y.ToHex)(Z)+(0,Y.ToHex)(x)+(0,Y.ToHex)(F)}fromHexString(Z){return"#"!==Z.substring(0,1)||7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new c)}toHSVToRef(Z){const x=this.r,F=this.g,u=this.b,G=Math.max(x,F,u),f=Math.min(x,F,u);let Y=0,j=0;const d=G,t=G-f;return 0!==G&&(j=t/G),G!=f&&(G==x?(Y=(F-u)/t,F<u&&(Y+=6)):G==F?Y=(u-x)/t+2:G==u&&(Y=(x-F)/t+4),Y*=60),Z.r=Y,Z.g=j,Z.b=d,Z}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new c;return this.toLinearSpaceToRef(x,Z),x}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)):(Z.r=j(this.r),Z.g=j(this.g),Z.b=j(this.b)),this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new c;return this.toGammaSpaceToRef(x,Z),x}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=o(this.r),Z.g=o(this.g),Z.b=o(this.b)):(Z.r=t(this.r),Z.g=t(this.g),Z.b=t(this.b)),this}static HSVtoRGBToRef(Z,x,F,u){const G=F*x,f=Z/60,Y=G*(1-Math.abs(f%2-1));let j=0,d=0,t=0;f>=0&&f<=1?(j=G,d=Y):f>=1&&f<=2?(j=Y,d=G):f>=2&&f<=3?(d=G,t=Y):f>=3&&f<=4?(d=Y,t=G):f>=4&&f<=5?(j=Y,t=G):f>=5&&f<=6&&(j=G,t=Y);const o=F-G;return u.r=j+o,u.g=d+o,u.b=t+o,u}static FromHSV(Z,x,F){const u=new c(0,0,0);return c.HSVtoRGBToRef(Z,x,F,u),u}static FromHexString(Z){return new c(0,0,0).fromHexString(Z)}static Hx(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new c(Z[x],Z[x+1],Z[x+2])}static FromArrayToRef(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=Z[x],F.g=Z[x+1],F.b=Z[x+2]}static FromInts(Z,x,F){return new c(Z/255,x/255,F/255)}static Lerp(Z,x,F){const u=new c(0,0,0);return c.LerpToRef(Z,x,F,u),u}static LerpToRef(Z,x,F,u){u.r=Z.r+(x.r-Z.r)*F,u.g=Z.g+(x.g-Z.g)*F,u.b=Z.b+(x.b-Z.b)*F}static Hermite(Z,x,F,u,G){const f=G*G,Y=G*f,j=2*Y-3*f+1,d=-2*Y+3*f,t=Y-2*f+G,o=Y-f,s=Z.r*j+F.r*d+x.r*t+u.r*o,J=Z.g*j+F.g*d+x.g*t+u.g*o,p=Z.b*j+F.b*d+x.b*t+u.b*o;return new c(s,J,p)}static Hermite1stDerivative(Z,x,F,u,G){const f=c.Black();return this.Hermite1stDerivativeToRef(Z,x,F,u,G,f),f}static Hermite1stDerivativeToRef(Z,x,F,u,G,f){const Y=G*G;f.r=6*(Y-G)*Z.r+(3*Y-4*G+1)*x.r+6*(-Y+G)*F.r+(3*Y-2*G)*u.r,f.g=6*(Y-G)*Z.g+(3*Y-4*G+1)*x.g+6*(-Y+G)*F.g+(3*Y-2*G)*u.g,f.b=6*(Y-G)*Z.b+(3*Y-4*G+1)*x.b+6*(-Y+G)*F.b+(3*Y-2*G)*u.b}static Red(){return new c(1,0,0)}static Green(){return new c(0,1,0)}static Blue(){return new c(0,0,1)}static Black(){return new c(0,0,0)}static get BlackReadOnly(){return c._BlackReadOnly}static White(){return new c(1,1,1)}static Purple(){return new c(.5,0,.5)}static Magenta(){return new c(1,0,1)}static Yellow(){return new c(1,1,0)}static Gray(){return new c(.5,.5,.5)}static Teal(){return new c(0,1,1)}static Random(){return new c(Math.random(),Math.random(),Math.random())}}c._V8PerformanceHack=new c(.5,.5,.5),c._BlackReadOnly=c.Black(),Object.defineProperties(c.prototype,{dimension:{value:[3]},rank:{value:1}});class s{constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=Z,this.g=x,this.b=F,this.a=u}Wf(){return[this.r,this.g,this.b,this.a]}toArray(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Z[x]=this.r,Z[x+1]=this.g,Z[x+2]=this.b,Z[x+3]=this.a,this}mF(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=Z[x],this.g=Z[x+1],this.b=Z[x+2],this.a=Z[x+3],this}equals(Z){return Z&&this.r===Z.r&&this.g===Z.g&&this.b===Z.b&&this.a===Z.a}add(Z){return new s(this.r+Z.r,this.g+Z.g,this.b+Z.b,this.a+Z.a)}addToRef(Z,x){return x.r=this.r+Z.r,x.g=this.g+Z.g,x.b=this.b+Z.b,x.a=this.a+Z.a,x}addInPlace(Z){return this.r+=Z.r,this.g+=Z.g,this.b+=Z.b,this.a+=Z.a,this}addInPlaceFromFloats(Z,x,F,u){return this.r+=Z,this.g+=x,this.b+=F,this.a+=u,this}Mx(Z){return new s(this.r-Z.r,this.g-Z.g,this.b-Z.b,this.a-Z.a)}subtractToRef(Z,x){return x.r=this.r-Z.r,x.g=this.g-Z.g,x.b=this.b-Z.b,x.a=this.a-Z.a,x}Dc(Z){return this.r-=Z.r,this.g-=Z.g,this.b-=Z.b,this.a-=Z.a,this}subtractFromFloats(Z,x,F,u){return new s(this.r-Z,this.g-x,this.b-F,this.a-u)}subtractFromFloatsToRef(Z,x,F,u,G){return G.r=this.r-Z,G.g=this.g-x,G.b=this.b-F,G.a=this.a-u,G}scale(Z){return new s(this.r*Z,this.g*Z,this.b*Z,this.a*Z)}scaleInPlace(Z){return this.r*=Z,this.g*=Z,this.b*=Z,this.a*=Z,this}scaleToRef(Z,x){return x.r=this.r*Z,x.g=this.g*Z,x.b=this.b*Z,x.a=this.a*Z,x}scaleAndAddToRef(Z,x){return x.r+=this.r*Z,x.g+=this.g*Z,x.b+=this.b*Z,x.a+=this.a*Z,x}clampToRef(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,Y.Clamp)(this.r,Z,x),F.g=(0,Y.Clamp)(this.g,Z,x),F.b=(0,Y.Clamp)(this.b,Z,x),F.a=(0,Y.Clamp)(this.a,Z,x),F}multiply(Z){return new s(this.r*Z.r,this.g*Z.g,this.b*Z.b,this.a*Z.a)}multiplyToRef(Z,x){return x.r=this.r*Z.r,x.g=this.g*Z.g,x.b=this.b*Z.b,x.a=this.a*Z.a,x}multiplyInPlace(Z){return this.r*=Z.r,this.g*=Z.g,this.b*=Z.b,this.a*=Z.a,this}multiplyByFloats(Z,x,F,u){return new s(this.r*Z,this.g*x,this.b*F,this.a*u)}divide(Z){throw new ReferenceError("Can not divide a color")}divideToRef(Z,x){throw new ReferenceError("Can not divide a color")}divideInPlace(Z){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Z){return this.r=Math.min(this.r,Z.r),this.g=Math.min(this.g,Z.g),this.b=Math.min(this.b,Z.b),this.a=Math.min(this.a,Z.a),this}maximizeInPlace(Z){return this.r=Math.max(this.r,Z.r),this.g=Math.max(this.g,Z.g),this.b=Math.max(this.b,Z.b),this.a=Math.max(this.a,Z.a),this}minimizeInPlaceFromFloats(Z,x,F,u){return this.r=Math.min(Z,this.r),this.g=Math.min(x,this.g),this.b=Math.min(F,this.b),this.a=Math.min(u,this.a),this}maximizeInPlaceFromFloats(Z,x,F,u){return this.r=Math.max(Z,this.r),this.g=Math.max(x,this.g),this.b=Math.max(F,this.b),this.a=Math.max(u,this.a),this}floorToRef(Z){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Z){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Z){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:f.e;return(0,Y.WithinEpsilon)(this.r,Z.r,x)&&(0,Y.WithinEpsilon)(this.g,Z.g,x)&&(0,Y.WithinEpsilon)(this.b,Z.b,x)&&(0,Y.WithinEpsilon)(this.a,Z.a,x)}equalsToFloats(Z,x,F,u){return this.r===Z&&this.g===x&&this.b===F&&this.a===u}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"kj"}getHashCode(){let Z=255*this.r|0;return Z=397*Z^255*this.g,Z=397*Z^255*this.b,Z=397*Z^255*this.a,Z}clone(){return(new s).G(this)}G(Z){return this.r=Z.r,this.g=Z.g,this.b=Z.b,this.a=Z.a,this}Jj(Z,x,F,u){return this.r=Z,this.g=x,this.b=F,this.a=u,this}set(Z,x,F,u){return this.Jj(Z,x,F,u)}Uj(Z){return this.r=this.g=this.b=this.a=Z,this}toHexString(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=Math.round(255*this.r),F=Math.round(255*this.g),u=Math.round(255*this.b);if(Z)return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(F)+(0,Y.ToHex)(u);const G=Math.round(255*this.a);return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(F)+(0,Y.ToHex)(u)+(0,Y.ToHex)(G)}fromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length||(this.r=parseInt(Z.substring(1,3),16)/255,this.g=parseInt(Z.substring(3,5),16)/255,this.b=parseInt(Z.substring(5,7),16)/255,9===Z.length&&(this.a=parseInt(Z.substring(7,9),16)/255)),this}toLinearSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new s;return this.toLinearSpaceToRef(x,Z),x}toLinearSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=d(this.r),Z.g=d(this.g),Z.b=d(this.b)):(Z.r=j(this.r),Z.g=j(this.g),Z.b=j(this.b)),Z.a=this.a,this}toGammaSpace(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new s;return this.toGammaSpaceToRef(x,Z),x}toGammaSpaceToRef(Z){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Z.r=o(this.r),Z.g=o(this.g),Z.b=o(this.b)):(Z.r=t(this.r),Z.g=t(this.g),Z.b=t(this.b)),Z.a=this.a,this}static FromHexString(Z){return"#"!==Z.substring(0,1)||9!==Z.length&&7!==Z.length?new s(0,0,0,0):new s(0,0,0,1).fromHexString(Z)}static Lerp(Z,x,F){return s.LerpToRef(Z,x,F,new s)}static LerpToRef(Z,x,F,u){return u.r=Z.r+(x.r-Z.r)*F,u.g=Z.g+(x.g-Z.g)*F,u.b=Z.b+(x.b-Z.b)*F,u.a=Z.a+(x.a-Z.a)*F,u}static Hermite(Z,x,F,u,G){const f=G*G,Y=G*f,j=2*Y-3*f+1,d=-2*Y+3*f,t=Y-2*f+G,o=Y-f,c=Z.r*j+F.r*d+x.r*t+u.r*o,J=Z.g*j+F.g*d+x.g*t+u.g*o,p=Z.b*j+F.b*d+x.b*t+u.b*o,U=Z.a*j+F.a*d+x.a*t+u.a*o;return new s(c,J,p,U)}static Hermite1stDerivative(Z,x,F,u,G){const f=new s;return this.Hermite1stDerivativeToRef(Z,x,F,u,G,f),f}static Hermite1stDerivativeToRef(Z,x,F,u,G,f){const Y=G*G;f.r=6*(Y-G)*Z.r+(3*Y-4*G+1)*x.r+6*(-Y+G)*F.r+(3*Y-2*G)*u.r,f.g=6*(Y-G)*Z.g+(3*Y-4*G+1)*x.g+6*(-Y+G)*F.g+(3*Y-2*G)*u.g,f.b=6*(Y-G)*Z.b+(3*Y-4*G+1)*x.b+6*(-Y+G)*F.b+(3*Y-2*G)*u.b,f.a=6*(Y-G)*Z.a+(3*Y-4*G+1)*x.a+6*(-Y+G)*F.a+(3*Y-2*G)*u.a}static FromColor3(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new s(Z.r,Z.g,Z.b,x)}static Hx(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new s(Z[x],Z[x+1],Z[x+2],Z[x+3])}static FromArrayToRef(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=Z[x],F.g=Z[x+1],F.b=Z[x+2],F.a=Z[x+3]}static FromInts(Z,x,F,u){return new s(Z/255,x/255,F/255,u/255)}static CheckColors4(Z,x){if(Z.length===3*x){const x=[];for(let F=0;F<Z.length;F+=3){const u=F/3*4;x[u]=Z[F],x[u+1]=Z[F+1],x[u+2]=Z[F+2],x[u+3]=1}return x}return Z}}s._V8PerformanceHack=new s(.5,.5,.5,.5),Object.defineProperties(s.prototype,{dimension:{value:[4]},rank:{value:1}});class J{}J.Lx=(0,u.b)(3,c.Black),J.kj=(0,u.b)(3,(()=>new s(0,0,0,0))),(0,G.g)("BABYLON.Color3",c),(0,G.g)("BABYLON.Color4",s)}}]);