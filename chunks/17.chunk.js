"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[17],{11472:(f,v,Z)=>{Z.r(v),Z.d(v,{Mv:()=>u,he:()=>W,TmpColors:()=>a});var V=Z(11437),h=Z(11372),J=Z(11428),l=Z(11440);function e(f){return Math.pow(f,J.h)}function C(f){return f<=.04045?.0773993808*f:Math.pow(.947867299*(f+.055),2.4)}function H(f){return Math.pow(f,J.g)}function O(f){return f<=.0031308?12.92*f:1.055*Math.pow(f,.41666)-.055}class u{constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=f,this.g=v,this.b=Z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Mv"}getHashCode(){let f=255*this.r|0;return f=397*f^255*this.g,f=397*f^255*this.b,f}toArray(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f[v]=this.r,f[v+1]=this.g,f[v+2]=this.b,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(f,v,this),this}toColor4(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new W(this.r,this.g,this.b,f)}Ph(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(f){return new u(this.r*f.r,this.g*f.g,this.b*f.b)}multiplyToRef(f,v){return v.r=this.r*f.r,v.g=this.g*f.g,v.b=this.b*f.b,v}multiplyInPlace(f){return this.r*=f.r,this.g*=f.g,this.b*=f.b,this}multiplyByFloats(f,v,Z){return new u(this.r*f,this.g*v,this.b*Z)}divide(f){throw new ReferenceError("Can not divide a color")}divideToRef(f,v){throw new ReferenceError("Can not divide a color")}divideInPlace(f){throw new ReferenceError("Can not divide a color")}minimizeInPlace(f){return this.minimizeInPlaceFromFloats(f.r,f.g,f.b)}maximizeInPlace(f){return this.maximizeInPlaceFromFloats(f.r,f.g,f.b)}minimizeInPlaceFromFloats(f,v,Z){return this.r=Math.min(f,this.r),this.g=Math.min(v,this.g),this.b=Math.min(Z,this.b),this}maximizeInPlaceFromFloats(f,v,Z){return this.r=Math.max(f,this.r),this.g=Math.max(v,this.g),this.b=Math.max(Z,this.b),this}floorToRef(f){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(f){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(f){return f&&this.r===f.r&&this.g===f.g&&this.b===f.b}equalsFloats(f,v,Z){return this.equalsToFloats(f,v,Z)}equalsToFloats(f,v,Z){return this.r===f&&this.g===v&&this.b===Z}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.c;return(0,l.WithinEpsilon)(this.r,f.r,v)&&(0,l.WithinEpsilon)(this.g,f.g,v)&&(0,l.WithinEpsilon)(this.b,f.b,v)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(f){throw new ReferenceError("Can not negate a color")}scale(f){return new u(this.r*f,this.g*f,this.b*f)}scaleInPlace(f){return this.r*=f,this.g*=f,this.b*=f,this}scaleToRef(f,v){return v.r=this.r*f,v.g=this.g*f,v.b=this.b*f,v}scaleAndAddToRef(f,v){return v.r+=this.r*f,v.g+=this.g*f,v.b+=this.b*f,v}clampToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Z=arguments.length>2?arguments[2]:void 0;return Z.r=(0,l.Clamp)(this.r,f,v),Z.g=(0,l.Clamp)(this.g,f,v),Z.b=(0,l.Clamp)(this.b,f,v),Z}add(f){return new u(this.r+f.r,this.g+f.g,this.b+f.b)}addInPlace(f){return this.r+=f.r,this.g+=f.g,this.b+=f.b,this}addInPlaceFromFloats(f,v,Z){return this.r+=f,this.g+=v,this.b+=Z,this}addToRef(f,v){return v.r=this.r+f.r,v.g=this.g+f.g,v.b=this.b+f.b,v}Fv(f){return new u(this.r-f.r,this.g-f.g,this.b-f.b)}subtractToRef(f,v){return v.r=this.r-f.r,v.g=this.g-f.g,v.b=this.b-f.b,v}hu(f){return this.r-=f.r,this.g-=f.g,this.b-=f.b,this}subtractFromFloats(f,v,Z){return new u(this.r-f,this.g-v,this.b-Z)}subtractFromFloatsToRef(f,v,Z,V){return V.r=this.r-f,V.g=this.g-v,V.b=this.b-Z,V}clone(){return new u(this.r,this.g,this.b)}h(f){return this.r=f.r,this.g=f.g,this.b=f.b,this}fe(f,v,Z){return this.r=f,this.g=v,this.b=Z,this}set(f,v,Z){return this.fe(f,v,Z)}Ve(f){return this.r=this.g=this.b=f,this}toHexString(){const f=Math.round(255*this.r),v=Math.round(255*this.g),Z=Math.round(255*this.b);return"#"+(0,l.ToHex)(f)+(0,l.ToHex)(v)+(0,l.ToHex)(Z)}fromHexString(f){return"#"!==f.substring(0,1)||7!==f.length||(this.r=parseInt(f.substring(1,3),16)/255,this.g=parseInt(f.substring(3,5),16)/255,this.b=parseInt(f.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new u)}toHSVToRef(f){const v=this.r,Z=this.g,V=this.b,h=Math.max(v,Z,V),J=Math.min(v,Z,V);let l=0,e=0;const C=h,H=h-J;return 0!==h&&(e=H/h),h!=J&&(h==v?(l=(Z-V)/H,Z<V&&(l+=6)):h==Z?l=(V-v)/H+2:h==V&&(l=(v-Z)/H+4),l*=60),f.r=l,f.g=e,f.b=C,f}toLinearSpace(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new u;return this.toLinearSpaceToRef(v,f),v}toLinearSpaceToRef(f){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(f.r=C(this.r),f.g=C(this.g),f.b=C(this.b)):(f.r=e(this.r),f.g=e(this.g),f.b=e(this.b)),this}toGammaSpace(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new u;return this.toGammaSpaceToRef(v,f),v}toGammaSpaceToRef(f){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(f.r=O(this.r),f.g=O(this.g),f.b=O(this.b)):(f.r=H(this.r),f.g=H(this.g),f.b=H(this.b)),this}static HSVtoRGBToRef(f,v,Z,V){const h=Z*v,J=f/60,l=h*(1-Math.abs(J%2-1));let e=0,C=0,H=0;J>=0&&J<=1?(e=h,C=l):J>=1&&J<=2?(e=l,C=h):J>=2&&J<=3?(C=h,H=l):J>=3&&J<=4?(C=l,H=h):J>=4&&J<=5?(e=l,H=h):J>=5&&J<=6&&(e=h,H=l);const O=Z-h;return V.r=e+O,V.g=C+O,V.b=H+O,V}static FromHSV(f,v,Z){const V=new u(0,0,0);return u.HSVtoRGBToRef(f,v,Z,V),V}static FromHexString(f){return new u(0,0,0).fromHexString(f)}static Av(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(f[v],f[v+1],f[v+2])}static FromArrayToRef(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2?arguments[2]:void 0;Z.r=f[v],Z.g=f[v+1],Z.b=f[v+2]}static FromInts(f,v,Z){return new u(f/255,v/255,Z/255)}static Lerp(f,v,Z){const V=new u(0,0,0);return u.LerpToRef(f,v,Z,V),V}static LerpToRef(f,v,Z,V){V.r=f.r+(v.r-f.r)*Z,V.g=f.g+(v.g-f.g)*Z,V.b=f.b+(v.b-f.b)*Z}static Hermite(f,v,Z,V,h){const J=h*h,l=h*J,e=2*l-3*J+1,C=-2*l+3*J,H=l-2*J+h,O=l-J,W=f.r*e+Z.r*C+v.r*H+V.r*O,a=f.g*e+Z.g*C+v.g*H+V.g*O,b=f.b*e+Z.b*C+v.b*H+V.b*O;return new u(W,a,b)}static Hermite1stDerivative(f,v,Z,V,h){const J=u.Black();return this.Hermite1stDerivativeToRef(f,v,Z,V,h,J),J}static Hermite1stDerivativeToRef(f,v,Z,V,h,J){const l=h*h;J.r=6*(l-h)*f.r+(3*l-4*h+1)*v.r+6*(-l+h)*Z.r+(3*l-2*h)*V.r,J.g=6*(l-h)*f.g+(3*l-4*h+1)*v.g+6*(-l+h)*Z.g+(3*l-2*h)*V.g,J.b=6*(l-h)*f.b+(3*l-4*h+1)*v.b+6*(-l+h)*Z.b+(3*l-2*h)*V.b}static Red(){return new u(1,0,0)}static Green(){return new u(0,1,0)}static Blue(){return new u(0,0,1)}static Black(){return new u(0,0,0)}static get BlackReadOnly(){return u._BlackReadOnly}static White(){return new u(1,1,1)}static Purple(){return new u(.5,0,.5)}static Magenta(){return new u(1,0,1)}static Yellow(){return new u(1,1,0)}static Gray(){return new u(.5,.5,.5)}static Teal(){return new u(0,1,1)}static Random(){return new u(Math.random(),Math.random(),Math.random())}}u._V8PerformanceHack=new u(.5,.5,.5),u._BlackReadOnly=u.Black(),Object.defineProperties(u.prototype,{dimension:{value:[3]},rank:{value:1}});class W{constructor(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=f,this.g=v,this.b=Z,this.a=V}Ph(){return[this.r,this.g,this.b,this.a]}toArray(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return f[v]=this.r,f[v+1]=this.g,f[v+2]=this.b,f[v+3]=this.a,this}bZ(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=f[v],this.g=f[v+1],this.b=f[v+2],this.a=f[v+3],this}equals(f){return f&&this.r===f.r&&this.g===f.g&&this.b===f.b&&this.a===f.a}add(f){return new W(this.r+f.r,this.g+f.g,this.b+f.b,this.a+f.a)}addToRef(f,v){return v.r=this.r+f.r,v.g=this.g+f.g,v.b=this.b+f.b,v.a=this.a+f.a,v}addInPlace(f){return this.r+=f.r,this.g+=f.g,this.b+=f.b,this.a+=f.a,this}addInPlaceFromFloats(f,v,Z,V){return this.r+=f,this.g+=v,this.b+=Z,this.a+=V,this}Fv(f){return new W(this.r-f.r,this.g-f.g,this.b-f.b,this.a-f.a)}subtractToRef(f,v){return v.r=this.r-f.r,v.g=this.g-f.g,v.b=this.b-f.b,v.a=this.a-f.a,v}hu(f){return this.r-=f.r,this.g-=f.g,this.b-=f.b,this.a-=f.a,this}subtractFromFloats(f,v,Z,V){return new W(this.r-f,this.g-v,this.b-Z,this.a-V)}subtractFromFloatsToRef(f,v,Z,V,h){return h.r=this.r-f,h.g=this.g-v,h.b=this.b-Z,h.a=this.a-V,h}scale(f){return new W(this.r*f,this.g*f,this.b*f,this.a*f)}scaleInPlace(f){return this.r*=f,this.g*=f,this.b*=f,this.a*=f,this}scaleToRef(f,v){return v.r=this.r*f,v.g=this.g*f,v.b=this.b*f,v.a=this.a*f,v}scaleAndAddToRef(f,v){return v.r+=this.r*f,v.g+=this.g*f,v.b+=this.b*f,v.a+=this.a*f,v}clampToRef(){let f=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,Z=arguments.length>2?arguments[2]:void 0;return Z.r=(0,l.Clamp)(this.r,f,v),Z.g=(0,l.Clamp)(this.g,f,v),Z.b=(0,l.Clamp)(this.b,f,v),Z.a=(0,l.Clamp)(this.a,f,v),Z}multiply(f){return new W(this.r*f.r,this.g*f.g,this.b*f.b,this.a*f.a)}multiplyToRef(f,v){return v.r=this.r*f.r,v.g=this.g*f.g,v.b=this.b*f.b,v.a=this.a*f.a,v}multiplyInPlace(f){return this.r*=f.r,this.g*=f.g,this.b*=f.b,this.a*=f.a,this}multiplyByFloats(f,v,Z,V){return new W(this.r*f,this.g*v,this.b*Z,this.a*V)}divide(f){throw new ReferenceError("Can not divide a color")}divideToRef(f,v){throw new ReferenceError("Can not divide a color")}divideInPlace(f){throw new ReferenceError("Can not divide a color")}minimizeInPlace(f){return this.r=Math.min(this.r,f.r),this.g=Math.min(this.g,f.g),this.b=Math.min(this.b,f.b),this.a=Math.min(this.a,f.a),this}maximizeInPlace(f){return this.r=Math.max(this.r,f.r),this.g=Math.max(this.g,f.g),this.b=Math.max(this.b,f.b),this.a=Math.max(this.a,f.a),this}minimizeInPlaceFromFloats(f,v,Z,V){return this.r=Math.min(f,this.r),this.g=Math.min(v,this.g),this.b=Math.min(Z,this.b),this.a=Math.min(V,this.a),this}maximizeInPlaceFromFloats(f,v,Z,V){return this.r=Math.max(f,this.r),this.g=Math.max(v,this.g),this.b=Math.max(Z,this.b),this.a=Math.max(V,this.a),this}floorToRef(f){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(f){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(f){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:J.c;return(0,l.WithinEpsilon)(this.r,f.r,v)&&(0,l.WithinEpsilon)(this.g,f.g,v)&&(0,l.WithinEpsilon)(this.b,f.b,v)&&(0,l.WithinEpsilon)(this.a,f.a,v)}equalsToFloats(f,v,Z,V){return this.r===f&&this.g===v&&this.b===Z&&this.a===V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"he"}getHashCode(){let f=255*this.r|0;return f=397*f^255*this.g,f=397*f^255*this.b,f=397*f^255*this.a,f}clone(){return(new W).h(this)}h(f){return this.r=f.r,this.g=f.g,this.b=f.b,this.a=f.a,this}fe(f,v,Z,V){return this.r=f,this.g=v,this.b=Z,this.a=V,this}set(f,v,Z,V){return this.fe(f,v,Z,V)}Ve(f){return this.r=this.g=this.b=this.a=f,this}toHexString(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=Math.round(255*this.r),Z=Math.round(255*this.g),V=Math.round(255*this.b);if(f)return"#"+(0,l.ToHex)(v)+(0,l.ToHex)(Z)+(0,l.ToHex)(V);const h=Math.round(255*this.a);return"#"+(0,l.ToHex)(v)+(0,l.ToHex)(Z)+(0,l.ToHex)(V)+(0,l.ToHex)(h)}fromHexString(f){return"#"!==f.substring(0,1)||9!==f.length&&7!==f.length||(this.r=parseInt(f.substring(1,3),16)/255,this.g=parseInt(f.substring(3,5),16)/255,this.b=parseInt(f.substring(5,7),16)/255,9===f.length&&(this.a=parseInt(f.substring(7,9),16)/255)),this}toLinearSpace(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new W;return this.toLinearSpaceToRef(v,f),v}toLinearSpaceToRef(f){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(f.r=C(this.r),f.g=C(this.g),f.b=C(this.b)):(f.r=e(this.r),f.g=e(this.g),f.b=e(this.b)),f.a=this.a,this}toGammaSpace(){let f=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const v=new W;return this.toGammaSpaceToRef(v,f),v}toGammaSpaceToRef(f){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(f.r=O(this.r),f.g=O(this.g),f.b=O(this.b)):(f.r=H(this.r),f.g=H(this.g),f.b=H(this.b)),f.a=this.a,this}static FromHexString(f){return"#"!==f.substring(0,1)||9!==f.length&&7!==f.length?new W(0,0,0,0):new W(0,0,0,1).fromHexString(f)}static Lerp(f,v,Z){return W.LerpToRef(f,v,Z,new W)}static LerpToRef(f,v,Z,V){return V.r=f.r+(v.r-f.r)*Z,V.g=f.g+(v.g-f.g)*Z,V.b=f.b+(v.b-f.b)*Z,V.a=f.a+(v.a-f.a)*Z,V}static Hermite(f,v,Z,V,h){const J=h*h,l=h*J,e=2*l-3*J+1,C=-2*l+3*J,H=l-2*J+h,O=l-J,u=f.r*e+Z.r*C+v.r*H+V.r*O,a=f.g*e+Z.g*C+v.g*H+V.g*O,b=f.b*e+Z.b*C+v.b*H+V.b*O,X=f.a*e+Z.a*C+v.a*H+V.a*O;return new W(u,a,b,X)}static Hermite1stDerivative(f,v,Z,V,h){const J=new W;return this.Hermite1stDerivativeToRef(f,v,Z,V,h,J),J}static Hermite1stDerivativeToRef(f,v,Z,V,h,J){const l=h*h;J.r=6*(l-h)*f.r+(3*l-4*h+1)*v.r+6*(-l+h)*Z.r+(3*l-2*h)*V.r,J.g=6*(l-h)*f.g+(3*l-4*h+1)*v.g+6*(-l+h)*Z.g+(3*l-2*h)*V.g,J.b=6*(l-h)*f.b+(3*l-4*h+1)*v.b+6*(-l+h)*Z.b+(3*l-2*h)*V.b,J.a=6*(l-h)*f.a+(3*l-4*h+1)*v.a+6*(-l+h)*Z.a+(3*l-2*h)*V.a}static FromColor3(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new W(f.r,f.g,f.b,v)}static Av(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new W(f[v],f[v+1],f[v+2],f[v+3])}static FromArrayToRef(f){let v=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Z=arguments.length>2?arguments[2]:void 0;Z.r=f[v],Z.g=f[v+1],Z.b=f[v+2],Z.a=f[v+3]}static FromInts(f,v,Z,V){return new W(f/255,v/255,Z/255,V/255)}static CheckColors4(f,v){if(f.length===3*v){const v=[];for(let Z=0;Z<f.length;Z+=3){const V=Z/3*4;v[V]=f[Z],v[V+1]=f[Z+1],v[V+2]=f[Z+2],v[V+3]=1}return v}return f}}W._V8PerformanceHack=new W(.5,.5,.5,.5),Object.defineProperties(W.prototype,{dimension:{value:[4]},rank:{value:1}});class a{}a.Mv=(0,V.c)(3,u.Black),a.he=(0,V.c)(3,(()=>new W(0,0,0,0))),(0,h.h)("BABYLON.Color3",u),(0,h.h)("BABYLON.Color4",W)}}]);