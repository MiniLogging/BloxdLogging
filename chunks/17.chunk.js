"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[17],{12870:(D,h,o)=>{o.r(h),o.d(h,{mo:()=>K,yg:()=>Q,TmpColors:()=>v});var H=o(12836),g=o(12793),j=o(12833),M=o(12842);function R(D){return Math.pow(D,j.l)}function t(D){return D<=.04045?.0773993808*D:Math.pow(.947867299*(D+.055),2.4)}function S(D){return Math.pow(D,j.j)}function k(D){return D<=.0031308?12.92*D:1.055*Math.pow(D,.41666)-.055}class K{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=D,this.g=h,this.b=o}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"mo"}getHashCode(){let D=255*this.r|0;return D=397*D^255*this.g,D=397*D^255*this.b,D}toArray(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[h]=this.r,D[h+1]=this.g,D[h+2]=this.b,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K.FromArrayToRef(D,h,this),this}toColor4(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new Q(this.r,this.g,this.b,D)}Fh(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(D){return new K(this.r*D.r,this.g*D.g,this.b*D.b)}multiplyToRef(D,h){return h.r=this.r*D.r,h.g=this.g*D.g,h.b=this.b*D.b,h}multiplyInPlace(D){return this.r*=D.r,this.g*=D.g,this.b*=D.b,this}multiplyByFloats(D,h,o){return new K(this.r*D,this.g*h,this.b*o)}divide(D){throw new ReferenceError("Can not divide a color")}divideToRef(D,h){throw new ReferenceError("Can not divide a color")}divideInPlace(D){throw new ReferenceError("Can not divide a color")}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D.r,D.g,D.b)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D.r,D.g,D.b)}minimizeInPlaceFromFloats(D,h,o){return this.r=Math.min(D,this.r),this.g=Math.min(h,this.g),this.b=Math.min(o,this.b),this}maximizeInPlaceFromFloats(D,h,o){return this.r=Math.max(D,this.r),this.g=Math.max(h,this.g),this.b=Math.max(o,this.b),this}floorToRef(D){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(D){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(D){return D&&this.r===D.r&&this.g===D.g&&this.b===D.b}equalsFloats(D,h,o){return this.equalsToFloats(D,h,o)}equalsToFloats(D,h,o){return this.r===D&&this.g===h&&this.b===o}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return(0,M.WithinEpsilon)(this.r,D.r,h)&&(0,M.WithinEpsilon)(this.g,D.g,h)&&(0,M.WithinEpsilon)(this.b,D.b,h)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(D){throw new ReferenceError("Can not negate a color")}scale(D){return new K(this.r*D,this.g*D,this.b*D)}scaleInPlace(D){return this.r*=D,this.g*=D,this.b*=D,this}scaleToRef(D,h){return h.r=this.r*D,h.g=this.g*D,h.b=this.b*D,h}scaleAndAddToRef(D,h){return h.r+=this.r*D,h.g+=this.g*D,h.b+=this.b*D,h}clampToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0;return o.r=(0,M.Clamp)(this.r,D,h),o.g=(0,M.Clamp)(this.g,D,h),o.b=(0,M.Clamp)(this.b,D,h),o}add(D){return new K(this.r+D.r,this.g+D.g,this.b+D.b)}addInPlace(D){return this.r+=D.r,this.g+=D.g,this.b+=D.b,this}addInPlaceFromFloats(D,h,o){return this.r+=D,this.g+=h,this.b+=o,this}addToRef(D,h){return h.r=this.r+D.r,h.g=this.g+D.g,h.b=this.b+D.b,h}Nh(D){return new K(this.r-D.r,this.g-D.g,this.b-D.b)}subtractToRef(D,h){return h.r=this.r-D.r,h.g=this.g-D.g,h.b=this.b-D.b,h}zK(D){return this.r-=D.r,this.g-=D.g,this.b-=D.b,this}subtractFromFloats(D,h,o){return new K(this.r-D,this.g-h,this.b-o)}subtractFromFloatsToRef(D,h,o,H){return H.r=this.r-D,H.g=this.g-h,H.b=this.b-o,H}clone(){return new K(this.r,this.g,this.b)}M(D){return this.r=D.r,this.g=D.g,this.b=D.b,this}Qg(D,h,o){return this.r=D,this.g=h,this.b=o,this}set(D,h,o){return this.Qg(D,h,o)}qg(D){return this.r=this.g=this.b=D,this}toHexString(){const D=Math.round(255*this.r),h=Math.round(255*this.g),o=Math.round(255*this.b);return"#"+(0,M.ToHex)(D)+(0,M.ToHex)(h)+(0,M.ToHex)(o)}fromHexString(D){return"#"!==D.substring(0,1)||7!==D.length||(this.r=parseInt(D.substring(1,3),16)/255,this.g=parseInt(D.substring(3,5),16)/255,this.b=parseInt(D.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new K)}toHSVToRef(D){const h=this.r,o=this.g,H=this.b,g=Math.max(h,o,H),j=Math.min(h,o,H);let M=0,R=0;const t=g,S=g-j;return 0!==g&&(R=S/g),g!=j&&(g==h?(M=(o-H)/S,o<H&&(M+=6)):g==o?M=(H-h)/S+2:g==H&&(M=(h-o)/S+4),M*=60),D.r=M,D.g=R,D.b=t,D}toLinearSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new K;return this.toLinearSpaceToRef(h,D),h}toLinearSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=t(this.r),D.g=t(this.g),D.b=t(this.b)):(D.r=R(this.r),D.g=R(this.g),D.b=R(this.b)),this}toGammaSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new K;return this.toGammaSpaceToRef(h,D),h}toGammaSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=k(this.r),D.g=k(this.g),D.b=k(this.b)):(D.r=S(this.r),D.g=S(this.g),D.b=S(this.b)),this}static HSVtoRGBToRef(D,h,o,H){const g=o*h,j=D/60,M=g*(1-Math.abs(j%2-1));let R=0,t=0,S=0;j>=0&&j<=1?(R=g,t=M):j>=1&&j<=2?(R=M,t=g):j>=2&&j<=3?(t=g,S=M):j>=3&&j<=4?(t=M,S=g):j>=4&&j<=5?(R=M,S=g):j>=5&&j<=6&&(R=g,S=M);const k=o-g;return H.r=R+k,H.g=t+k,H.b=S+k,H}static FromHSV(D,h,o){const H=new K(0,0,0);return K.HSVtoRGBToRef(D,h,o,H),H}static FromHexString(D){return new K(0,0,0).fromHexString(D)}static Ih(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(D[h],D[h+1],D[h+2])}static FromArrayToRef(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2?arguments[2]:void 0;o.r=D[h],o.g=D[h+1],o.b=D[h+2]}static FromInts(D,h,o){return new K(D/255,h/255,o/255)}static Lerp(D,h,o){const H=new K(0,0,0);return K.LerpToRef(D,h,o,H),H}static LerpToRef(D,h,o,H){H.r=D.r+(h.r-D.r)*o,H.g=D.g+(h.g-D.g)*o,H.b=D.b+(h.b-D.b)*o}static Hermite(D,h,o,H,g){const j=g*g,M=g*j,R=2*M-3*j+1,t=-2*M+3*j,S=M-2*j+g,k=M-j,Q=D.r*R+o.r*t+h.r*S+H.r*k,v=D.g*R+o.g*t+h.g*S+H.g*k,r=D.b*R+o.b*t+h.b*S+H.b*k;return new K(Q,v,r)}static Hermite1stDerivative(D,h,o,H,g){const j=K.Black();return this.Hermite1stDerivativeToRef(D,h,o,H,g,j),j}static Hermite1stDerivativeToRef(D,h,o,H,g,j){const M=g*g;j.r=6*(M-g)*D.r+(3*M-4*g+1)*h.r+6*(-M+g)*o.r+(3*M-2*g)*H.r,j.g=6*(M-g)*D.g+(3*M-4*g+1)*h.g+6*(-M+g)*o.g+(3*M-2*g)*H.g,j.b=6*(M-g)*D.b+(3*M-4*g+1)*h.b+6*(-M+g)*o.b+(3*M-2*g)*H.b}static Red(){return new K(1,0,0)}static Green(){return new K(0,1,0)}static Blue(){return new K(0,0,1)}static Black(){return new K(0,0,0)}static get BlackReadOnly(){return K._BlackReadOnly}static White(){return new K(1,1,1)}static Purple(){return new K(.5,0,.5)}static Magenta(){return new K(1,0,1)}static Yellow(){return new K(1,1,0)}static Gray(){return new K(.5,.5,.5)}static Teal(){return new K(0,1,1)}static Random(){return new K(Math.random(),Math.random(),Math.random())}}K._V8PerformanceHack=new K(.5,.5,.5),K._BlackReadOnly=K.Black(),Object.defineProperties(K.prototype,{dimension:{value:[3]},rank:{value:1}});class Q{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=D,this.g=h,this.b=o,this.a=H}Fh(){return[this.r,this.g,this.b,this.a]}toArray(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[h]=this.r,D[h+1]=this.g,D[h+2]=this.b,D[h+3]=this.a,this}lo(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=D[h],this.g=D[h+1],this.b=D[h+2],this.a=D[h+3],this}equals(D){return D&&this.r===D.r&&this.g===D.g&&this.b===D.b&&this.a===D.a}add(D){return new Q(this.r+D.r,this.g+D.g,this.b+D.b,this.a+D.a)}addToRef(D,h){return h.r=this.r+D.r,h.g=this.g+D.g,h.b=this.b+D.b,h.a=this.a+D.a,h}addInPlace(D){return this.r+=D.r,this.g+=D.g,this.b+=D.b,this.a+=D.a,this}addInPlaceFromFloats(D,h,o,H){return this.r+=D,this.g+=h,this.b+=o,this.a+=H,this}Nh(D){return new Q(this.r-D.r,this.g-D.g,this.b-D.b,this.a-D.a)}subtractToRef(D,h){return h.r=this.r-D.r,h.g=this.g-D.g,h.b=this.b-D.b,h.a=this.a-D.a,h}zK(D){return this.r-=D.r,this.g-=D.g,this.b-=D.b,this.a-=D.a,this}subtractFromFloats(D,h,o,H){return new Q(this.r-D,this.g-h,this.b-o,this.a-H)}subtractFromFloatsToRef(D,h,o,H,g){return g.r=this.r-D,g.g=this.g-h,g.b=this.b-o,g.a=this.a-H,g}scale(D){return new Q(this.r*D,this.g*D,this.b*D,this.a*D)}scaleInPlace(D){return this.r*=D,this.g*=D,this.b*=D,this.a*=D,this}scaleToRef(D,h){return h.r=this.r*D,h.g=this.g*D,h.b=this.b*D,h.a=this.a*D,h}scaleAndAddToRef(D,h){return h.r+=this.r*D,h.g+=this.g*D,h.b+=this.b*D,h.a+=this.a*D,h}clampToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,o=arguments.length>2?arguments[2]:void 0;return o.r=(0,M.Clamp)(this.r,D,h),o.g=(0,M.Clamp)(this.g,D,h),o.b=(0,M.Clamp)(this.b,D,h),o.a=(0,M.Clamp)(this.a,D,h),o}multiply(D){return new Q(this.r*D.r,this.g*D.g,this.b*D.b,this.a*D.a)}multiplyToRef(D,h){return h.r=this.r*D.r,h.g=this.g*D.g,h.b=this.b*D.b,h.a=this.a*D.a,h}multiplyInPlace(D){return this.r*=D.r,this.g*=D.g,this.b*=D.b,this.a*=D.a,this}multiplyByFloats(D,h,o,H){return new Q(this.r*D,this.g*h,this.b*o,this.a*H)}divide(D){throw new ReferenceError("Can not divide a color")}divideToRef(D,h){throw new ReferenceError("Can not divide a color")}divideInPlace(D){throw new ReferenceError("Can not divide a color")}minimizeInPlace(D){return this.r=Math.min(this.r,D.r),this.g=Math.min(this.g,D.g),this.b=Math.min(this.b,D.b),this.a=Math.min(this.a,D.a),this}maximizeInPlace(D){return this.r=Math.max(this.r,D.r),this.g=Math.max(this.g,D.g),this.b=Math.max(this.b,D.b),this.a=Math.max(this.a,D.a),this}minimizeInPlaceFromFloats(D,h,o,H){return this.r=Math.min(D,this.r),this.g=Math.min(h,this.g),this.b=Math.min(o,this.b),this.a=Math.min(H,this.a),this}maximizeInPlaceFromFloats(D,h,o,H){return this.r=Math.max(D,this.r),this.g=Math.max(h,this.g),this.b=Math.max(o,this.b),this.a=Math.max(H,this.a),this}floorToRef(D){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(D){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(D){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:j.d;return(0,M.WithinEpsilon)(this.r,D.r,h)&&(0,M.WithinEpsilon)(this.g,D.g,h)&&(0,M.WithinEpsilon)(this.b,D.b,h)&&(0,M.WithinEpsilon)(this.a,D.a,h)}equalsToFloats(D,h,o,H){return this.r===D&&this.g===h&&this.b===o&&this.a===H}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"yg"}getHashCode(){let D=255*this.r|0;return D=397*D^255*this.g,D=397*D^255*this.b,D=397*D^255*this.a,D}clone(){return(new Q).M(this)}M(D){return this.r=D.r,this.g=D.g,this.b=D.b,this.a=D.a,this}Qg(D,h,o,H){return this.r=D,this.g=h,this.b=o,this.a=H,this}set(D,h,o,H){return this.Qg(D,h,o,H)}qg(D){return this.r=this.g=this.b=this.a=D,this}toHexString(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=Math.round(255*this.r),o=Math.round(255*this.g),H=Math.round(255*this.b);if(D)return"#"+(0,M.ToHex)(h)+(0,M.ToHex)(o)+(0,M.ToHex)(H);const g=Math.round(255*this.a);return"#"+(0,M.ToHex)(h)+(0,M.ToHex)(o)+(0,M.ToHex)(H)+(0,M.ToHex)(g)}fromHexString(D){return"#"!==D.substring(0,1)||9!==D.length&&7!==D.length||(this.r=parseInt(D.substring(1,3),16)/255,this.g=parseInt(D.substring(3,5),16)/255,this.b=parseInt(D.substring(5,7),16)/255,9===D.length&&(this.a=parseInt(D.substring(7,9),16)/255)),this}toLinearSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new Q;return this.toLinearSpaceToRef(h,D),h}toLinearSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=t(this.r),D.g=t(this.g),D.b=t(this.b)):(D.r=R(this.r),D.g=R(this.g),D.b=R(this.b)),D.a=this.a,this}toGammaSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new Q;return this.toGammaSpaceToRef(h,D),h}toGammaSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=k(this.r),D.g=k(this.g),D.b=k(this.b)):(D.r=S(this.r),D.g=S(this.g),D.b=S(this.b)),D.a=this.a,this}static FromHexString(D){return"#"!==D.substring(0,1)||9!==D.length&&7!==D.length?new Q(0,0,0,0):new Q(0,0,0,1).fromHexString(D)}static Lerp(D,h,o){return Q.LerpToRef(D,h,o,new Q)}static LerpToRef(D,h,o,H){return H.r=D.r+(h.r-D.r)*o,H.g=D.g+(h.g-D.g)*o,H.b=D.b+(h.b-D.b)*o,H.a=D.a+(h.a-D.a)*o,H}static Hermite(D,h,o,H,g){const j=g*g,M=g*j,R=2*M-3*j+1,t=-2*M+3*j,S=M-2*j+g,k=M-j,K=D.r*R+o.r*t+h.r*S+H.r*k,v=D.g*R+o.g*t+h.g*S+H.g*k,r=D.b*R+o.b*t+h.b*S+H.b*k,B=D.a*R+o.a*t+h.a*S+H.a*k;return new Q(K,v,r,B)}static Hermite1stDerivative(D,h,o,H,g){const j=new Q;return this.Hermite1stDerivativeToRef(D,h,o,H,g,j),j}static Hermite1stDerivativeToRef(D,h,o,H,g,j){const M=g*g;j.r=6*(M-g)*D.r+(3*M-4*g+1)*h.r+6*(-M+g)*o.r+(3*M-2*g)*H.r,j.g=6*(M-g)*D.g+(3*M-4*g+1)*h.g+6*(-M+g)*o.g+(3*M-2*g)*H.g,j.b=6*(M-g)*D.b+(3*M-4*g+1)*h.b+6*(-M+g)*o.b+(3*M-2*g)*H.b,j.a=6*(M-g)*D.a+(3*M-4*g+1)*h.a+6*(-M+g)*o.a+(3*M-2*g)*H.a}static FromColor3(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new Q(D.r,D.g,D.b,h)}static Ih(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(D[h],D[h+1],D[h+2],D[h+3])}static FromArrayToRef(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2?arguments[2]:void 0;o.r=D[h],o.g=D[h+1],o.b=D[h+2],o.a=D[h+3]}static FromInts(D,h,o,H){return new Q(D/255,h/255,o/255,H/255)}static CheckColors4(D,h){if(D.length===3*h){const h=[];for(let o=0;o<D.length;o+=3){const H=o/3*4;h[H]=D[o],h[H+1]=D[o+1],h[H+2]=D[o+2],h[H+3]=1}return h}return D}}Q._V8PerformanceHack=new Q(.5,.5,.5,.5),Object.defineProperties(Q.prototype,{dimension:{value:[4]},rank:{value:1}});class v{}v.mo=(0,H.b)(3,K.Black),v.yg=(0,H.b)(3,(()=>new Q(0,0,0,0))),(0,g.g)("BABYLON.Color3",K),(0,g.g)("BABYLON.Color4",Q)}}]);