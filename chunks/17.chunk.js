"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[17],{12442:(t,U,y)=>{y.r(U),y.d(U,{bU:()=>L,HX:()=>h,TmpColors:()=>Q});var I=y(12399),r=y(12338),Y=y(12392),mt=y(12404);function X(t){return Math.pow(t,Y.g)}function P(t){return t<=.04045?.0773993808*t:Math.pow(.947867299*(t+.055),2.4)}function G(t){return Math.pow(t,Y.d)}function M(t){return t<=.0031308?12.92*t:1.055*Math.pow(t,.41666)-.055}class L{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=t,this.g=U,this.b=y}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"bU"}getHashCode(){let t=255*this.r|0;return t=397*t^255*this.g,t=397*t^255*this.b,t}toArray(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[U]=this.r,t[U+1]=this.g,t[U+2]=this.b,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L.FromArrayToRef(t,U,this),this}toColor4(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new h(this.r,this.g,this.b,t)}bX(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(t){return new L(this.r*t.r,this.g*t.g,this.b*t.b)}multiplyToRef(t,U){return U.r=this.r*t.r,U.g=this.g*t.g,U.b=this.b*t.b,U}multiplyInPlace(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this}multiplyByFloats(t,U,y){return new L(this.r*t,this.g*U,this.b*y)}divide(t){throw new ReferenceError("Can not divide a color")}divideToRef(t,U){throw new ReferenceError("Can not divide a color")}divideInPlace(t){throw new ReferenceError("Can not divide a color")}minimizeInPlace(t){return this.minimizeInPlaceFromFloats(t.r,t.g,t.b)}maximizeInPlace(t){return this.maximizeInPlaceFromFloats(t.r,t.g,t.b)}minimizeInPlaceFromFloats(t,U,y){return this.r=Math.min(t,this.r),this.g=Math.min(U,this.g),this.b=Math.min(y,this.b),this}maximizeInPlaceFromFloats(t,U,y){return this.r=Math.max(t,this.r),this.g=Math.max(U,this.g),this.b=Math.max(y,this.b),this}floorToRef(t){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(t){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(t){return t&&this.r===t.r&&this.g===t.g&&this.b===t.b}equalsFloats(t,U,y){return this.equalsToFloats(t,U,y)}equalsToFloats(t,U,y){return this.r===t&&this.g===U&&this.b===y}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.b;return(0,mt.WithinEpsilon)(this.r,t.r,U)&&(0,mt.WithinEpsilon)(this.g,t.g,U)&&(0,mt.WithinEpsilon)(this.b,t.b,U)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(t){throw new ReferenceError("Can not negate a color")}scale(t){return new L(this.r*t,this.g*t,this.b*t)}scaleInPlace(t){return this.r*=t,this.g*=t,this.b*=t,this}scaleToRef(t,U){return U.r=this.r*t,U.g=this.g*t,U.b=this.b*t,U}scaleAndAddToRef(t,U){return U.r+=this.r*t,U.g+=this.g*t,U.b+=this.b*t,U}clampToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,y=arguments.length>2?arguments[2]:void 0;return y.r=(0,mt.Clamp)(this.r,t,U),y.g=(0,mt.Clamp)(this.g,t,U),y.b=(0,mt.Clamp)(this.b,t,U),y}add(t){return new L(this.r+t.r,this.g+t.g,this.b+t.b)}addInPlace(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this}addInPlaceFromFloats(t,U,y){return this.r+=t,this.g+=U,this.b+=y,this}addToRef(t,U){return U.r=this.r+t.r,U.g=this.g+t.g,U.b=this.b+t.b,U}lU(t){return new L(this.r-t.r,this.g-t.g,this.b-t.b)}subtractToRef(t,U){return U.r=this.r-t.r,U.g=this.g-t.g,U.b=this.b-t.b,U}GL(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this}subtractFromFloats(t,U,y){return new L(this.r-t,this.g-U,this.b-y)}subtractFromFloatsToRef(t,U,y,I){return I.r=this.r-t,I.g=this.g-U,I.b=this.b-y,I}clone(){return new L(this.r,this.g,this.b)}Y(t){return this.r=t.r,this.g=t.g,this.b=t.b,this}aX(t,U,y){return this.r=t,this.g=U,this.b=y,this}set(t,U,y){return this.aX(t,U,y)}qX(t){return this.r=this.g=this.b=t,this}toHexString(){const t=Math.round(255*this.r),U=Math.round(255*this.g),y=Math.round(255*this.b);return"#"+(0,mt.ToHex)(t)+(0,mt.ToHex)(U)+(0,mt.ToHex)(y)}fromHexString(t){return"#"!==t.substring(0,1)||7!==t.length||(this.r=parseInt(t.substring(1,3),16)/255,this.g=parseInt(t.substring(3,5),16)/255,this.b=parseInt(t.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new L)}toHSVToRef(t){const U=this.r,y=this.g,I=this.b,r=Math.max(U,y,I),Y=Math.min(U,y,I);let mt=0,X=0;const P=r,G=r-Y;return 0!==r&&(X=G/r),r!=Y&&(r==U?(mt=(y-I)/G,y<I&&(mt+=6)):r==y?mt=(I-U)/G+2:r==I&&(mt=(U-y)/G+4),mt*=60),t.r=mt,t.g=X,t.b=P,t}toLinearSpace(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new L;return this.toLinearSpaceToRef(U,t),U}toLinearSpaceToRef(t){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(t.r=P(this.r),t.g=P(this.g),t.b=P(this.b)):(t.r=X(this.r),t.g=X(this.g),t.b=X(this.b)),this}toGammaSpace(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new L;return this.toGammaSpaceToRef(U,t),U}toGammaSpaceToRef(t){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(t.r=M(this.r),t.g=M(this.g),t.b=M(this.b)):(t.r=G(this.r),t.g=G(this.g),t.b=G(this.b)),this}static HSVtoRGBToRef(t,U,y,I){const r=y*U,Y=t/60,mt=r*(1-Math.abs(Y%2-1));let X=0,P=0,G=0;Y>=0&&Y<=1?(X=r,P=mt):Y>=1&&Y<=2?(X=mt,P=r):Y>=2&&Y<=3?(P=r,G=mt):Y>=3&&Y<=4?(P=mt,G=r):Y>=4&&Y<=5?(X=mt,G=r):Y>=5&&Y<=6&&(X=r,G=mt);const M=y-r;return I.r=X+M,I.g=P+M,I.b=G+M,I}static FromHSV(t,U,y){const I=new L(0,0,0);return L.HSVtoRGBToRef(t,U,y,I),I}static FromHexString(t){return new L(0,0,0).fromHexString(t)}static pU(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new L(t[U],t[U+1],t[U+2])}static FromArrayToRef(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2?arguments[2]:void 0;y.r=t[U],y.g=t[U+1],y.b=t[U+2]}static FromInts(t,U,y){return new L(t/255,U/255,y/255)}static Lerp(t,U,y){const I=new L(0,0,0);return L.LerpToRef(t,U,y,I),I}static LerpToRef(t,U,y,I){I.r=t.r+(U.r-t.r)*y,I.g=t.g+(U.g-t.g)*y,I.b=t.b+(U.b-t.b)*y}static Hermite(t,U,y,I,r){const Y=r*r,mt=r*Y,X=2*mt-3*Y+1,P=-2*mt+3*Y,G=mt-2*Y+r,M=mt-Y,h=t.r*X+y.r*P+U.r*G+I.r*M,Q=t.g*X+y.g*P+U.g*G+I.g*M,F=t.b*X+y.b*P+U.b*G+I.b*M;return new L(h,Q,F)}static Hermite1stDerivative(t,U,y,I,r){const Y=L.Black();return this.Hermite1stDerivativeToRef(t,U,y,I,r,Y),Y}static Hermite1stDerivativeToRef(t,U,y,I,r,Y){const mt=r*r;Y.r=6*(mt-r)*t.r+(3*mt-4*r+1)*U.r+6*(-mt+r)*y.r+(3*mt-2*r)*I.r,Y.g=6*(mt-r)*t.g+(3*mt-4*r+1)*U.g+6*(-mt+r)*y.g+(3*mt-2*r)*I.g,Y.b=6*(mt-r)*t.b+(3*mt-4*r+1)*U.b+6*(-mt+r)*y.b+(3*mt-2*r)*I.b}static Red(){return new L(1,0,0)}static Green(){return new L(0,1,0)}static Blue(){return new L(0,0,1)}static Black(){return new L(0,0,0)}static get BlackReadOnly(){return L._BlackReadOnly}static White(){return new L(1,1,1)}static Purple(){return new L(.5,0,.5)}static Magenta(){return new L(1,0,1)}static Yellow(){return new L(1,1,0)}static Gray(){return new L(.5,.5,.5)}static Teal(){return new L(0,1,1)}static Random(){return new L(Math.random(),Math.random(),Math.random())}}L._V8PerformanceHack=new L(.5,.5,.5),L._BlackReadOnly=L.Black(),Object.defineProperties(L.prototype,{dimension:{value:[3]},rank:{value:1}});class h{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=t,this.g=U,this.b=y,this.a=I}bX(){return[this.r,this.g,this.b,this.a]}toArray(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t[U]=this.r,t[U+1]=this.g,t[U+2]=this.b,t[U+3]=this.a,this}Dy(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=t[U],this.g=t[U+1],this.b=t[U+2],this.a=t[U+3],this}equals(t){return t&&this.r===t.r&&this.g===t.g&&this.b===t.b&&this.a===t.a}add(t){return new h(this.r+t.r,this.g+t.g,this.b+t.b,this.a+t.a)}addToRef(t,U){return U.r=this.r+t.r,U.g=this.g+t.g,U.b=this.b+t.b,U.a=this.a+t.a,U}addInPlace(t){return this.r+=t.r,this.g+=t.g,this.b+=t.b,this.a+=t.a,this}addInPlaceFromFloats(t,U,y,I){return this.r+=t,this.g+=U,this.b+=y,this.a+=I,this}lU(t){return new h(this.r-t.r,this.g-t.g,this.b-t.b,this.a-t.a)}subtractToRef(t,U){return U.r=this.r-t.r,U.g=this.g-t.g,U.b=this.b-t.b,U.a=this.a-t.a,U}GL(t){return this.r-=t.r,this.g-=t.g,this.b-=t.b,this.a-=t.a,this}subtractFromFloats(t,U,y,I){return new h(this.r-t,this.g-U,this.b-y,this.a-I)}subtractFromFloatsToRef(t,U,y,I,r){return r.r=this.r-t,r.g=this.g-U,r.b=this.b-y,r.a=this.a-I,r}scale(t){return new h(this.r*t,this.g*t,this.b*t,this.a*t)}scaleInPlace(t){return this.r*=t,this.g*=t,this.b*=t,this.a*=t,this}scaleToRef(t,U){return U.r=this.r*t,U.g=this.g*t,U.b=this.b*t,U.a=this.a*t,U}scaleAndAddToRef(t,U){return U.r+=this.r*t,U.g+=this.g*t,U.b+=this.b*t,U.a+=this.a*t,U}clampToRef(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,y=arguments.length>2?arguments[2]:void 0;return y.r=(0,mt.Clamp)(this.r,t,U),y.g=(0,mt.Clamp)(this.g,t,U),y.b=(0,mt.Clamp)(this.b,t,U),y.a=(0,mt.Clamp)(this.a,t,U),y}multiply(t){return new h(this.r*t.r,this.g*t.g,this.b*t.b,this.a*t.a)}multiplyToRef(t,U){return U.r=this.r*t.r,U.g=this.g*t.g,U.b=this.b*t.b,U.a=this.a*t.a,U}multiplyInPlace(t){return this.r*=t.r,this.g*=t.g,this.b*=t.b,this.a*=t.a,this}multiplyByFloats(t,U,y,I){return new h(this.r*t,this.g*U,this.b*y,this.a*I)}divide(t){throw new ReferenceError("Can not divide a color")}divideToRef(t,U){throw new ReferenceError("Can not divide a color")}divideInPlace(t){throw new ReferenceError("Can not divide a color")}minimizeInPlace(t){return this.r=Math.min(this.r,t.r),this.g=Math.min(this.g,t.g),this.b=Math.min(this.b,t.b),this.a=Math.min(this.a,t.a),this}maximizeInPlace(t){return this.r=Math.max(this.r,t.r),this.g=Math.max(this.g,t.g),this.b=Math.max(this.b,t.b),this.a=Math.max(this.a,t.a),this}minimizeInPlaceFromFloats(t,U,y,I){return this.r=Math.min(t,this.r),this.g=Math.min(U,this.g),this.b=Math.min(y,this.b),this.a=Math.min(I,this.a),this}maximizeInPlaceFromFloats(t,U,y,I){return this.r=Math.max(t,this.r),this.g=Math.max(U,this.g),this.b=Math.max(y,this.b),this.a=Math.max(I,this.a),this}floorToRef(t){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(t){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(t){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Y.b;return(0,mt.WithinEpsilon)(this.r,t.r,U)&&(0,mt.WithinEpsilon)(this.g,t.g,U)&&(0,mt.WithinEpsilon)(this.b,t.b,U)&&(0,mt.WithinEpsilon)(this.a,t.a,U)}equalsToFloats(t,U,y,I){return this.r===t&&this.g===U&&this.b===y&&this.a===I}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"HX"}getHashCode(){let t=255*this.r|0;return t=397*t^255*this.g,t=397*t^255*this.b,t=397*t^255*this.a,t}clone(){return(new h).Y(this)}Y(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}aX(t,U,y,I){return this.r=t,this.g=U,this.b=y,this.a=I,this}set(t,U,y,I){return this.aX(t,U,y,I)}qX(t){return this.r=this.g=this.b=this.a=t,this}toHexString(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=Math.round(255*this.r),y=Math.round(255*this.g),I=Math.round(255*this.b);if(t)return"#"+(0,mt.ToHex)(U)+(0,mt.ToHex)(y)+(0,mt.ToHex)(I);const r=Math.round(255*this.a);return"#"+(0,mt.ToHex)(U)+(0,mt.ToHex)(y)+(0,mt.ToHex)(I)+(0,mt.ToHex)(r)}fromHexString(t){return"#"!==t.substring(0,1)||9!==t.length&&7!==t.length||(this.r=parseInt(t.substring(1,3),16)/255,this.g=parseInt(t.substring(3,5),16)/255,this.b=parseInt(t.substring(5,7),16)/255,9===t.length&&(this.a=parseInt(t.substring(7,9),16)/255)),this}toLinearSpace(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new h;return this.toLinearSpaceToRef(U,t),U}toLinearSpaceToRef(t){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(t.r=P(this.r),t.g=P(this.g),t.b=P(this.b)):(t.r=X(this.r),t.g=X(this.g),t.b=X(this.b)),t.a=this.a,this}toGammaSpace(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new h;return this.toGammaSpaceToRef(U,t),U}toGammaSpaceToRef(t){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(t.r=M(this.r),t.g=M(this.g),t.b=M(this.b)):(t.r=G(this.r),t.g=G(this.g),t.b=G(this.b)),t.a=this.a,this}static FromHexString(t){return"#"!==t.substring(0,1)||9!==t.length&&7!==t.length?new h(0,0,0,0):new h(0,0,0,1).fromHexString(t)}static Lerp(t,U,y){return h.LerpToRef(t,U,y,new h)}static LerpToRef(t,U,y,I){return I.r=t.r+(U.r-t.r)*y,I.g=t.g+(U.g-t.g)*y,I.b=t.b+(U.b-t.b)*y,I.a=t.a+(U.a-t.a)*y,I}static Hermite(t,U,y,I,r){const Y=r*r,mt=r*Y,X=2*mt-3*Y+1,P=-2*mt+3*Y,G=mt-2*Y+r,M=mt-Y,L=t.r*X+y.r*P+U.r*G+I.r*M,Q=t.g*X+y.g*P+U.g*G+I.g*M,F=t.b*X+y.b*P+U.b*G+I.b*M,E=t.a*X+y.a*P+U.a*G+I.a*M;return new h(L,Q,F,E)}static Hermite1stDerivative(t,U,y,I,r){const Y=new h;return this.Hermite1stDerivativeToRef(t,U,y,I,r,Y),Y}static Hermite1stDerivativeToRef(t,U,y,I,r,Y){const mt=r*r;Y.r=6*(mt-r)*t.r+(3*mt-4*r+1)*U.r+6*(-mt+r)*y.r+(3*mt-2*r)*I.r,Y.g=6*(mt-r)*t.g+(3*mt-4*r+1)*U.g+6*(-mt+r)*y.g+(3*mt-2*r)*I.g,Y.b=6*(mt-r)*t.b+(3*mt-4*r+1)*U.b+6*(-mt+r)*y.b+(3*mt-2*r)*I.b,Y.a=6*(mt-r)*t.a+(3*mt-4*r+1)*U.a+6*(-mt+r)*y.a+(3*mt-2*r)*I.a}static FromColor3(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new h(t.r,t.g,t.b,U)}static pU(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(t[U],t[U+1],t[U+2],t[U+3])}static FromArrayToRef(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2?arguments[2]:void 0;y.r=t[U],y.g=t[U+1],y.b=t[U+2],y.a=t[U+3]}static FromInts(t,U,y,I){return new h(t/255,U/255,y/255,I/255)}static CheckColors4(t,U){if(t.length===3*U){const U=[];for(let y=0;y<t.length;y+=3){const I=y/3*4;U[I]=t[y],U[I+1]=t[y+1],U[I+2]=t[y+2],U[I+3]=1}return U}return t}}h._V8PerformanceHack=new h(.5,.5,.5,.5),Object.defineProperties(h.prototype,{dimension:{value:[4]},rank:{value:1}});class Q{}Q.bU=(0,I.d)(3,L.Black),Q.HX=(0,I.d)(3,(()=>new h(0,0,0,0))),(0,r.f)("BABYLON.Color3",L),(0,r.f)("BABYLON.Color4",h)}}]);