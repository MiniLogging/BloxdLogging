"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[17],{12437:(E,H,d)=>{d.r(H),d.d(H,{DH:()=>M,gg:()=>V,TmpColors:()=>C});var n=d(12399),Z=d(12344),I=d(12391),g=d(12406);function l(E){return Math.pow(E,I.n)}function r(E){return E<=.04045?.0773993808*E:Math.pow(.947867299*(E+.055),2.4)}function t(E){return Math.pow(E,I.j)}function S(E){return E<=.0031308?12.92*E:1.055*Math.pow(E,.41666)-.055}class M{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=E,this.g=H,this.b=d}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"DH"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E}toArray(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[H]=this.r,E[H+1]=this.g,E[H+2]=this.b,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(E,H,this),this}toColor4(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new V(this.r,this.g,this.b,E)}kd(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(E){return new M(this.r*E.r,this.g*E.g,this.b*E.b)}multiplyToRef(E,H){return H.r=this.r*E.r,H.g=this.g*E.g,H.b=this.b*E.b,H}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this}multiplyByFloats(E,H,d){return new M(this.r*E,this.g*H,this.b*d)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,H){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.r,E.g,E.b)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.r,E.g,E.b)}minimizeInPlaceFromFloats(E,H,d){return this.r=Math.min(E,this.r),this.g=Math.min(H,this.g),this.b=Math.min(d,this.b),this}maximizeInPlaceFromFloats(E,H,d){return this.r=Math.max(E,this.r),this.g=Math.max(H,this.g),this.b=Math.max(d,this.b),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b}equalsFloats(E,H,d){return this.equalsToFloats(E,H,d)}equalsToFloats(E,H,d){return this.r===E&&this.g===H&&this.b===d}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.c;return(0,g.WithinEpsilon)(this.r,E.r,H)&&(0,g.WithinEpsilon)(this.g,E.g,H)&&(0,g.WithinEpsilon)(this.b,E.b,H)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}scale(E){return new M(this.r*E,this.g*E,this.b*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this}scaleToRef(E,H){return H.r=this.r*E,H.g=this.g*E,H.b=this.b*E,H}scaleAndAddToRef(E,H){return H.r+=this.r*E,H.g+=this.g*E,H.b+=this.b*E,H}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0;return d.r=(0,g.Clamp)(this.r,E,H),d.g=(0,g.Clamp)(this.g,E,H),d.b=(0,g.Clamp)(this.b,E,H),d}add(E){return new M(this.r+E.r,this.g+E.g,this.b+E.b)}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this}addInPlaceFromFloats(E,H,d){return this.r+=E,this.g+=H,this.b+=d,this}addToRef(E,H){return H.r=this.r+E.r,H.g=this.g+E.g,H.b=this.b+E.b,H}RH(E){return new M(this.r-E.r,this.g-E.g,this.b-E.b)}subtractToRef(E,H){return H.r=this.r-E.r,H.g=this.g-E.g,H.b=this.b-E.b,H}MM(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this}subtractFromFloats(E,H,d){return new M(this.r-E,this.g-H,this.b-d)}subtractFromFloatsToRef(E,H,d,n){return n.r=this.r-E,n.g=this.g-H,n.b=this.b-d,n}clone(){return new M(this.r,this.g,this.b)}l(E){return this.r=E.r,this.g=E.g,this.b=E.b,this}en(E,H,d){return this.r=E,this.g=H,this.b=d,this}set(E,H,d){return this.en(E,H,d)}ng(E){return this.r=this.g=this.b=E,this}toHexString(){const E=Math.round(255*this.r),H=Math.round(255*this.g),d=Math.round(255*this.b);return"#"+(0,g.ToHex)(E)+(0,g.ToHex)(H)+(0,g.ToHex)(d)}fromHexString(E){return"#"!==E.substring(0,1)||7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new M)}toHSVToRef(E){const H=this.r,d=this.g,n=this.b,Z=Math.max(H,d,n),I=Math.min(H,d,n);let g=0,l=0;const r=Z,t=Z-I;return 0!==Z&&(l=t/Z),Z!=I&&(Z==H?(g=(d-n)/t,d<n&&(g+=6)):Z==d?g=(n-H)/t+2:Z==n&&(g=(H-d)/t+4),g*=60),E.r=g,E.g=l,E.b=r,E}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new M;return this.toLinearSpaceToRef(H,E),H}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=r(this.r),E.g=r(this.g),E.b=r(this.b)):(E.r=l(this.r),E.g=l(this.g),E.b=l(this.b)),this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new M;return this.toGammaSpaceToRef(H,E),H}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=S(this.r),E.g=S(this.g),E.b=S(this.b)):(E.r=t(this.r),E.g=t(this.g),E.b=t(this.b)),this}static HSVtoRGBToRef(E,H,d,n){const Z=d*H,I=E/60,g=Z*(1-Math.abs(I%2-1));let l=0,r=0,t=0;I>=0&&I<=1?(l=Z,r=g):I>=1&&I<=2?(l=g,r=Z):I>=2&&I<=3?(r=Z,t=g):I>=3&&I<=4?(r=g,t=Z):I>=4&&I<=5?(l=g,t=Z):I>=5&&I<=6&&(l=Z,t=g);const S=d-Z;return n.r=l+S,n.g=r+S,n.b=t+S,n}static FromHSV(E,H,d){const n=new M(0,0,0);return M.HSVtoRGBToRef(E,H,d,n),n}static FromHexString(E){return new M(0,0,0).fromHexString(E)}static eH(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new M(E[H],E[H+1],E[H+2])}static FromArrayToRef(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2?arguments[2]:void 0;d.r=E[H],d.g=E[H+1],d.b=E[H+2]}static FromInts(E,H,d){return new M(E/255,H/255,d/255)}static Lerp(E,H,d){const n=new M(0,0,0);return M.LerpToRef(E,H,d,n),n}static LerpToRef(E,H,d,n){n.r=E.r+(H.r-E.r)*d,n.g=E.g+(H.g-E.g)*d,n.b=E.b+(H.b-E.b)*d}static Hermite(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=2*g-3*I+1,r=-2*g+3*I,t=g-2*I+Z,S=g-I,V=E.r*l+d.r*r+H.r*t+n.r*S,C=E.g*l+d.g*r+H.g*t+n.g*S,w=E.b*l+d.b*r+H.b*t+n.b*S;return new M(V,C,w)}static Hermite1stDerivative(E,H,d,n,Z){const I=M.Black();return this.Hermite1stDerivativeToRef(E,H,d,n,Z,I),I}static Hermite1stDerivativeToRef(E,H,d,n,Z,I){const g=Z*Z;I.r=6*(g-Z)*E.r+(3*g-4*Z+1)*H.r+6*(-g+Z)*d.r+(3*g-2*Z)*n.r,I.g=6*(g-Z)*E.g+(3*g-4*Z+1)*H.g+6*(-g+Z)*d.g+(3*g-2*Z)*n.g,I.b=6*(g-Z)*E.b+(3*g-4*Z+1)*H.b+6*(-g+Z)*d.b+(3*g-2*Z)*n.b}static Red(){return new M(1,0,0)}static Green(){return new M(0,1,0)}static Blue(){return new M(0,0,1)}static Black(){return new M(0,0,0)}static get BlackReadOnly(){return M._BlackReadOnly}static White(){return new M(1,1,1)}static Purple(){return new M(.5,0,.5)}static Magenta(){return new M(1,0,1)}static Yellow(){return new M(1,1,0)}static Gray(){return new M(.5,.5,.5)}static Teal(){return new M(0,1,1)}static Random(){return new M(Math.random(),Math.random(),Math.random())}}M._V8PerformanceHack=new M(.5,.5,.5),M._BlackReadOnly=M.Black(),Object.defineProperties(M.prototype,{dimension:{value:[3]},rank:{value:1}});class V{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=E,this.g=H,this.b=d,this.a=n}kd(){return[this.r,this.g,this.b,this.a]}toArray(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[H]=this.r,E[H+1]=this.g,E[H+2]=this.b,E[H+3]=this.a,this}Xd(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=E[H],this.g=E[H+1],this.b=E[H+2],this.a=E[H+3],this}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b&&this.a===E.a}add(E){return new V(this.r+E.r,this.g+E.g,this.b+E.b,this.a+E.a)}addToRef(E,H){return H.r=this.r+E.r,H.g=this.g+E.g,H.b=this.b+E.b,H.a=this.a+E.a,H}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this.a+=E.a,this}addInPlaceFromFloats(E,H,d,n){return this.r+=E,this.g+=H,this.b+=d,this.a+=n,this}RH(E){return new V(this.r-E.r,this.g-E.g,this.b-E.b,this.a-E.a)}subtractToRef(E,H){return H.r=this.r-E.r,H.g=this.g-E.g,H.b=this.b-E.b,H.a=this.a-E.a,H}MM(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this.a-=E.a,this}subtractFromFloats(E,H,d,n){return new V(this.r-E,this.g-H,this.b-d,this.a-n)}subtractFromFloatsToRef(E,H,d,n,Z){return Z.r=this.r-E,Z.g=this.g-H,Z.b=this.b-d,Z.a=this.a-n,Z}scale(E){return new V(this.r*E,this.g*E,this.b*E,this.a*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this.a*=E,this}scaleToRef(E,H){return H.r=this.r*E,H.g=this.g*E,H.b=this.b*E,H.a=this.a*E,H}scaleAndAddToRef(E,H){return H.r+=this.r*E,H.g+=this.g*E,H.b+=this.b*E,H.a+=this.a*E,H}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,d=arguments.length>2?arguments[2]:void 0;return d.r=(0,g.Clamp)(this.r,E,H),d.g=(0,g.Clamp)(this.g,E,H),d.b=(0,g.Clamp)(this.b,E,H),d.a=(0,g.Clamp)(this.a,E,H),d}multiply(E){return new V(this.r*E.r,this.g*E.g,this.b*E.b,this.a*E.a)}multiplyToRef(E,H){return H.r=this.r*E.r,H.g=this.g*E.g,H.b=this.b*E.b,H.a=this.a*E.a,H}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this.a*=E.a,this}multiplyByFloats(E,H,d,n){return new V(this.r*E,this.g*H,this.b*d,this.a*n)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,H){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.r=Math.min(this.r,E.r),this.g=Math.min(this.g,E.g),this.b=Math.min(this.b,E.b),this.a=Math.min(this.a,E.a),this}maximizeInPlace(E){return this.r=Math.max(this.r,E.r),this.g=Math.max(this.g,E.g),this.b=Math.max(this.b,E.b),this.a=Math.max(this.a,E.a),this}minimizeInPlaceFromFloats(E,H,d,n){return this.r=Math.min(E,this.r),this.g=Math.min(H,this.g),this.b=Math.min(d,this.b),this.a=Math.min(n,this.a),this}maximizeInPlaceFromFloats(E,H,d,n){return this.r=Math.max(E,this.r),this.g=Math.max(H,this.g),this.b=Math.max(d,this.b),this.a=Math.max(n,this.a),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:I.c;return(0,g.WithinEpsilon)(this.r,E.r,H)&&(0,g.WithinEpsilon)(this.g,E.g,H)&&(0,g.WithinEpsilon)(this.b,E.b,H)&&(0,g.WithinEpsilon)(this.a,E.a,H)}equalsToFloats(E,H,d,n){return this.r===E&&this.g===H&&this.b===d&&this.a===n}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"gg"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E=397*E^255*this.a,E}clone(){return(new V).l(this)}l(E){return this.r=E.r,this.g=E.g,this.b=E.b,this.a=E.a,this}en(E,H,d,n){return this.r=E,this.g=H,this.b=d,this.a=n,this}set(E,H,d,n){return this.en(E,H,d,n)}ng(E){return this.r=this.g=this.b=this.a=E,this}toHexString(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=Math.round(255*this.r),d=Math.round(255*this.g),n=Math.round(255*this.b);if(E)return"#"+(0,g.ToHex)(H)+(0,g.ToHex)(d)+(0,g.ToHex)(n);const Z=Math.round(255*this.a);return"#"+(0,g.ToHex)(H)+(0,g.ToHex)(d)+(0,g.ToHex)(n)+(0,g.ToHex)(Z)}fromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255,9===E.length&&(this.a=parseInt(E.substring(7,9),16)/255)),this}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new V;return this.toLinearSpaceToRef(H,E),H}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=r(this.r),E.g=r(this.g),E.b=r(this.b)):(E.r=l(this.r),E.g=l(this.g),E.b=l(this.b)),E.a=this.a,this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new V;return this.toGammaSpaceToRef(H,E),H}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=S(this.r),E.g=S(this.g),E.b=S(this.b)):(E.r=t(this.r),E.g=t(this.g),E.b=t(this.b)),E.a=this.a,this}static FromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length?new V(0,0,0,0):new V(0,0,0,1).fromHexString(E)}static Lerp(E,H,d){return V.LerpToRef(E,H,d,new V)}static LerpToRef(E,H,d,n){return n.r=E.r+(H.r-E.r)*d,n.g=E.g+(H.g-E.g)*d,n.b=E.b+(H.b-E.b)*d,n.a=E.a+(H.a-E.a)*d,n}static Hermite(E,H,d,n,Z){const I=Z*Z,g=Z*I,l=2*g-3*I+1,r=-2*g+3*I,t=g-2*I+Z,S=g-I,M=E.r*l+d.r*r+H.r*t+n.r*S,C=E.g*l+d.g*r+H.g*t+n.g*S,w=E.b*l+d.b*r+H.b*t+n.b*S,R=E.a*l+d.a*r+H.a*t+n.a*S;return new V(M,C,w,R)}static Hermite1stDerivative(E,H,d,n,Z){const I=new V;return this.Hermite1stDerivativeToRef(E,H,d,n,Z,I),I}static Hermite1stDerivativeToRef(E,H,d,n,Z,I){const g=Z*Z;I.r=6*(g-Z)*E.r+(3*g-4*Z+1)*H.r+6*(-g+Z)*d.r+(3*g-2*Z)*n.r,I.g=6*(g-Z)*E.g+(3*g-4*Z+1)*H.g+6*(-g+Z)*d.g+(3*g-2*Z)*n.g,I.b=6*(g-Z)*E.b+(3*g-4*Z+1)*H.b+6*(-g+Z)*d.b+(3*g-2*Z)*n.b,I.a=6*(g-Z)*E.a+(3*g-4*Z+1)*H.a+6*(-g+Z)*d.a+(3*g-2*Z)*n.a}static FromColor3(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V(E.r,E.g,E.b,H)}static eH(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(E[H],E[H+1],E[H+2],E[H+3])}static FromArrayToRef(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2?arguments[2]:void 0;d.r=E[H],d.g=E[H+1],d.b=E[H+2],d.a=E[H+3]}static FromInts(E,H,d,n){return new V(E/255,H/255,d/255,n/255)}static CheckColors4(E,H){if(E.length===3*H){const H=[];for(let d=0;d<E.length;d+=3){const n=d/3*4;H[n]=E[d],H[n+1]=E[d+1],H[n+2]=E[d+2],H[n+3]=1}return H}return E}}V._V8PerformanceHack=new V(.5,.5,.5,.5),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class C{}C.DH=(0,n.e)(3,M.Black),C.gg=(0,n.e)(3,(()=>new V(0,0,0,0))),(0,Z.e)("BABYLON.Color3",M),(0,Z.e)("BABYLON.Color4",V)}}]);