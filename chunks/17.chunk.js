"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[17],{11276:(V,I,A)=>{A.r(I),A.d(I,{oI:()=>P,GH:()=>J,TmpColors:()=>G});var B=A(11240),F=A(11189),E=A(11237),Y=A(11249);function H(V){return Math.pow(V,E.j)}function c(V){return V<=.04045?.0773993808*V:Math.pow(.947867299*(V+.055),2.4)}function b(V){return Math.pow(V,E.h)}function X(V){return V<=.0031308?12.92*V:1.055*Math.pow(V,.41666)-.055}class P{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=V,this.g=I,this.b=A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"oI"}getHashCode(){let V=255*this.r|0;return V=397*V^255*this.g,V=397*V^255*this.b,V}toArray(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[I]=this.r,V[I+1]=this.g,V[I+2]=this.b,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P.FromArrayToRef(V,I,this),this}toColor4(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new J(this.r,this.g,this.b,V)}AH(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(V){return new P(this.r*V.r,this.g*V.g,this.b*V.b)}multiplyToRef(V,I){return I.r=this.r*V.r,I.g=this.g*V.g,I.b=this.b*V.b,I}multiplyInPlace(V){return this.r*=V.r,this.g*=V.g,this.b*=V.b,this}multiplyByFloats(V,I,A){return new P(this.r*V,this.g*I,this.b*A)}divide(V){throw new ReferenceError("Can not divide a color")}divideToRef(V,I){throw new ReferenceError("Can not divide a color")}divideInPlace(V){throw new ReferenceError("Can not divide a color")}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V.r,V.g,V.b)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V.r,V.g,V.b)}minimizeInPlaceFromFloats(V,I,A){return this.r=Math.min(V,this.r),this.g=Math.min(I,this.g),this.b=Math.min(A,this.b),this}maximizeInPlaceFromFloats(V,I,A){return this.r=Math.max(V,this.r),this.g=Math.max(I,this.g),this.b=Math.max(A,this.b),this}floorToRef(V){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(V){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(V){return V&&this.r===V.r&&this.g===V.g&&this.b===V.b}equalsFloats(V,I,A){return this.equalsToFloats(V,I,A)}equalsToFloats(V,I,A){return this.r===V&&this.g===I&&this.b===A}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.d;return(0,Y.WithinEpsilon)(this.r,V.r,I)&&(0,Y.WithinEpsilon)(this.g,V.g,I)&&(0,Y.WithinEpsilon)(this.b,V.b,I)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(V){throw new ReferenceError("Can not negate a color")}scale(V){return new P(this.r*V,this.g*V,this.b*V)}scaleInPlace(V){return this.r*=V,this.g*=V,this.b*=V,this}scaleToRef(V,I){return I.r=this.r*V,I.g=this.g*V,I.b=this.b*V,I}scaleAndAddToRef(V,I){return I.r+=this.r*V,I.g+=this.g*V,I.b+=this.b*V,I}clampToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.r=(0,Y.Clamp)(this.r,V,I),A.g=(0,Y.Clamp)(this.g,V,I),A.b=(0,Y.Clamp)(this.b,V,I),A}add(V){return new P(this.r+V.r,this.g+V.g,this.b+V.b)}addInPlace(V){return this.r+=V.r,this.g+=V.g,this.b+=V.b,this}addInPlaceFromFloats(V,I,A){return this.r+=V,this.g+=I,this.b+=A,this}addToRef(V,I){return I.r=this.r+V.r,I.g=this.g+V.g,I.b=this.b+V.b,I}uI(V){return new P(this.r-V.r,this.g-V.g,this.b-V.b)}subtractToRef(V,I){return I.r=this.r-V.r,I.g=this.g-V.g,I.b=this.b-V.b,I}wJ(V){return this.r-=V.r,this.g-=V.g,this.b-=V.b,this}subtractFromFloats(V,I,A){return new P(this.r-V,this.g-I,this.b-A)}subtractFromFloatsToRef(V,I,A,B){return B.r=this.r-V,B.g=this.g-I,B.b=this.b-A,B}clone(){return new P(this.r,this.g,this.b)}B(V){return this.r=V.r,this.g=V.g,this.b=V.b,this}XH(V,I,A){return this.r=V,this.g=I,this.b=A,this}set(V,I,A){return this.XH(V,I,A)}JH(V){return this.r=this.g=this.b=V,this}toHexString(){const V=Math.round(255*this.r),I=Math.round(255*this.g),A=Math.round(255*this.b);return"#"+(0,Y.ToHex)(V)+(0,Y.ToHex)(I)+(0,Y.ToHex)(A)}fromHexString(V){return"#"!==V.substring(0,1)||7!==V.length||(this.r=parseInt(V.substring(1,3),16)/255,this.g=parseInt(V.substring(3,5),16)/255,this.b=parseInt(V.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new P)}toHSVToRef(V){const I=this.r,A=this.g,B=this.b,F=Math.max(I,A,B),E=Math.min(I,A,B);let Y=0,H=0;const c=F,b=F-E;return 0!==F&&(H=b/F),F!=E&&(F==I?(Y=(A-B)/b,A<B&&(Y+=6)):F==A?Y=(B-I)/b+2:F==B&&(Y=(I-A)/b+4),Y*=60),V.r=Y,V.g=H,V.b=c,V}toLinearSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new P;return this.toLinearSpaceToRef(I,V),I}toLinearSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=c(this.r),V.g=c(this.g),V.b=c(this.b)):(V.r=H(this.r),V.g=H(this.g),V.b=H(this.b)),this}toGammaSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new P;return this.toGammaSpaceToRef(I,V),I}toGammaSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=X(this.r),V.g=X(this.g),V.b=X(this.b)):(V.r=b(this.r),V.g=b(this.g),V.b=b(this.b)),this}static HSVtoRGBToRef(V,I,A,B){const F=A*I,E=V/60,Y=F*(1-Math.abs(E%2-1));let H=0,c=0,b=0;E>=0&&E<=1?(H=F,c=Y):E>=1&&E<=2?(H=Y,c=F):E>=2&&E<=3?(c=F,b=Y):E>=3&&E<=4?(c=Y,b=F):E>=4&&E<=5?(H=Y,b=F):E>=5&&E<=6&&(H=F,b=Y);const X=A-F;return B.r=H+X,B.g=c+X,B.b=b+X,B}static FromHSV(V,I,A){const B=new P(0,0,0);return P.HSVtoRGBToRef(V,I,A,B),B}static FromHexString(V){return new P(0,0,0).fromHexString(V)}static LI(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(V[I],V[I+1],V[I+2])}static FromArrayToRef(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2?arguments[2]:void 0;A.r=V[I],A.g=V[I+1],A.b=V[I+2]}static FromInts(V,I,A){return new P(V/255,I/255,A/255)}static Lerp(V,I,A){const B=new P(0,0,0);return P.LerpToRef(V,I,A,B),B}static LerpToRef(V,I,A,B){B.r=V.r+(I.r-V.r)*A,B.g=V.g+(I.g-V.g)*A,B.b=V.b+(I.b-V.b)*A}static Hermite(V,I,A,B,F){const E=F*F,Y=F*E,H=2*Y-3*E+1,c=-2*Y+3*E,b=Y-2*E+F,X=Y-E,J=V.r*H+A.r*c+I.r*b+B.r*X,G=V.g*H+A.g*c+I.g*b+B.g*X,w=V.b*H+A.b*c+I.b*b+B.b*X;return new P(J,G,w)}static Hermite1stDerivative(V,I,A,B,F){const E=P.Black();return this.Hermite1stDerivativeToRef(V,I,A,B,F,E),E}static Hermite1stDerivativeToRef(V,I,A,B,F,E){const Y=F*F;E.r=6*(Y-F)*V.r+(3*Y-4*F+1)*I.r+6*(-Y+F)*A.r+(3*Y-2*F)*B.r,E.g=6*(Y-F)*V.g+(3*Y-4*F+1)*I.g+6*(-Y+F)*A.g+(3*Y-2*F)*B.g,E.b=6*(Y-F)*V.b+(3*Y-4*F+1)*I.b+6*(-Y+F)*A.b+(3*Y-2*F)*B.b}static Red(){return new P(1,0,0)}static Green(){return new P(0,1,0)}static Blue(){return new P(0,0,1)}static Black(){return new P(0,0,0)}static get BlackReadOnly(){return P._BlackReadOnly}static White(){return new P(1,1,1)}static Purple(){return new P(.5,0,.5)}static Magenta(){return new P(1,0,1)}static Yellow(){return new P(1,1,0)}static Gray(){return new P(.5,.5,.5)}static Teal(){return new P(0,1,1)}static Random(){return new P(Math.random(),Math.random(),Math.random())}}P._V8PerformanceHack=new P(.5,.5,.5),P._BlackReadOnly=P.Black(),Object.defineProperties(P.prototype,{dimension:{value:[3]},rank:{value:1}});class J{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=V,this.g=I,this.b=A,this.a=B}AH(){return[this.r,this.g,this.b,this.a]}toArray(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[I]=this.r,V[I+1]=this.g,V[I+2]=this.b,V[I+3]=this.a,this}GA(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=V[I],this.g=V[I+1],this.b=V[I+2],this.a=V[I+3],this}equals(V){return V&&this.r===V.r&&this.g===V.g&&this.b===V.b&&this.a===V.a}add(V){return new J(this.r+V.r,this.g+V.g,this.b+V.b,this.a+V.a)}addToRef(V,I){return I.r=this.r+V.r,I.g=this.g+V.g,I.b=this.b+V.b,I.a=this.a+V.a,I}addInPlace(V){return this.r+=V.r,this.g+=V.g,this.b+=V.b,this.a+=V.a,this}addInPlaceFromFloats(V,I,A,B){return this.r+=V,this.g+=I,this.b+=A,this.a+=B,this}uI(V){return new J(this.r-V.r,this.g-V.g,this.b-V.b,this.a-V.a)}subtractToRef(V,I){return I.r=this.r-V.r,I.g=this.g-V.g,I.b=this.b-V.b,I.a=this.a-V.a,I}wJ(V){return this.r-=V.r,this.g-=V.g,this.b-=V.b,this.a-=V.a,this}subtractFromFloats(V,I,A,B){return new J(this.r-V,this.g-I,this.b-A,this.a-B)}subtractFromFloatsToRef(V,I,A,B,F){return F.r=this.r-V,F.g=this.g-I,F.b=this.b-A,F.a=this.a-B,F}scale(V){return new J(this.r*V,this.g*V,this.b*V,this.a*V)}scaleInPlace(V){return this.r*=V,this.g*=V,this.b*=V,this.a*=V,this}scaleToRef(V,I){return I.r=this.r*V,I.g=this.g*V,I.b=this.b*V,I.a=this.a*V,I}scaleAndAddToRef(V,I){return I.r+=this.r*V,I.g+=this.g*V,I.b+=this.b*V,I.a+=this.a*V,I}clampToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0;return A.r=(0,Y.Clamp)(this.r,V,I),A.g=(0,Y.Clamp)(this.g,V,I),A.b=(0,Y.Clamp)(this.b,V,I),A.a=(0,Y.Clamp)(this.a,V,I),A}multiply(V){return new J(this.r*V.r,this.g*V.g,this.b*V.b,this.a*V.a)}multiplyToRef(V,I){return I.r=this.r*V.r,I.g=this.g*V.g,I.b=this.b*V.b,I.a=this.a*V.a,I}multiplyInPlace(V){return this.r*=V.r,this.g*=V.g,this.b*=V.b,this.a*=V.a,this}multiplyByFloats(V,I,A,B){return new J(this.r*V,this.g*I,this.b*A,this.a*B)}divide(V){throw new ReferenceError("Can not divide a color")}divideToRef(V,I){throw new ReferenceError("Can not divide a color")}divideInPlace(V){throw new ReferenceError("Can not divide a color")}minimizeInPlace(V){return this.r=Math.min(this.r,V.r),this.g=Math.min(this.g,V.g),this.b=Math.min(this.b,V.b),this.a=Math.min(this.a,V.a),this}maximizeInPlace(V){return this.r=Math.max(this.r,V.r),this.g=Math.max(this.g,V.g),this.b=Math.max(this.b,V.b),this.a=Math.max(this.a,V.a),this}minimizeInPlaceFromFloats(V,I,A,B){return this.r=Math.min(V,this.r),this.g=Math.min(I,this.g),this.b=Math.min(A,this.b),this.a=Math.min(B,this.a),this}maximizeInPlaceFromFloats(V,I,A,B){return this.r=Math.max(V,this.r),this.g=Math.max(I,this.g),this.b=Math.max(A,this.b),this.a=Math.max(B,this.a),this}floorToRef(V){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(V){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(V){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:E.d;return(0,Y.WithinEpsilon)(this.r,V.r,I)&&(0,Y.WithinEpsilon)(this.g,V.g,I)&&(0,Y.WithinEpsilon)(this.b,V.b,I)&&(0,Y.WithinEpsilon)(this.a,V.a,I)}equalsToFloats(V,I,A,B){return this.r===V&&this.g===I&&this.b===A&&this.a===B}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"GH"}getHashCode(){let V=255*this.r|0;return V=397*V^255*this.g,V=397*V^255*this.b,V=397*V^255*this.a,V}clone(){return(new J).B(this)}B(V){return this.r=V.r,this.g=V.g,this.b=V.b,this.a=V.a,this}XH(V,I,A,B){return this.r=V,this.g=I,this.b=A,this.a=B,this}set(V,I,A,B){return this.XH(V,I,A,B)}JH(V){return this.r=this.g=this.b=this.a=V,this}toHexString(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=Math.round(255*this.r),A=Math.round(255*this.g),B=Math.round(255*this.b);if(V)return"#"+(0,Y.ToHex)(I)+(0,Y.ToHex)(A)+(0,Y.ToHex)(B);const F=Math.round(255*this.a);return"#"+(0,Y.ToHex)(I)+(0,Y.ToHex)(A)+(0,Y.ToHex)(B)+(0,Y.ToHex)(F)}fromHexString(V){return"#"!==V.substring(0,1)||9!==V.length&&7!==V.length||(this.r=parseInt(V.substring(1,3),16)/255,this.g=parseInt(V.substring(3,5),16)/255,this.b=parseInt(V.substring(5,7),16)/255,9===V.length&&(this.a=parseInt(V.substring(7,9),16)/255)),this}toLinearSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new J;return this.toLinearSpaceToRef(I,V),I}toLinearSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=c(this.r),V.g=c(this.g),V.b=c(this.b)):(V.r=H(this.r),V.g=H(this.g),V.b=H(this.b)),V.a=this.a,this}toGammaSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new J;return this.toGammaSpaceToRef(I,V),I}toGammaSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=X(this.r),V.g=X(this.g),V.b=X(this.b)):(V.r=b(this.r),V.g=b(this.g),V.b=b(this.b)),V.a=this.a,this}static FromHexString(V){return"#"!==V.substring(0,1)||9!==V.length&&7!==V.length?new J(0,0,0,0):new J(0,0,0,1).fromHexString(V)}static Lerp(V,I,A){return J.LerpToRef(V,I,A,new J)}static LerpToRef(V,I,A,B){return B.r=V.r+(I.r-V.r)*A,B.g=V.g+(I.g-V.g)*A,B.b=V.b+(I.b-V.b)*A,B.a=V.a+(I.a-V.a)*A,B}static Hermite(V,I,A,B,F){const E=F*F,Y=F*E,H=2*Y-3*E+1,c=-2*Y+3*E,b=Y-2*E+F,X=Y-E,P=V.r*H+A.r*c+I.r*b+B.r*X,G=V.g*H+A.g*c+I.g*b+B.g*X,w=V.b*H+A.b*c+I.b*b+B.b*X,t=V.a*H+A.a*c+I.a*b+B.a*X;return new J(P,G,w,t)}static Hermite1stDerivative(V,I,A,B,F){const E=new J;return this.Hermite1stDerivativeToRef(V,I,A,B,F,E),E}static Hermite1stDerivativeToRef(V,I,A,B,F,E){const Y=F*F;E.r=6*(Y-F)*V.r+(3*Y-4*F+1)*I.r+6*(-Y+F)*A.r+(3*Y-2*F)*B.r,E.g=6*(Y-F)*V.g+(3*Y-4*F+1)*I.g+6*(-Y+F)*A.g+(3*Y-2*F)*B.g,E.b=6*(Y-F)*V.b+(3*Y-4*F+1)*I.b+6*(-Y+F)*A.b+(3*Y-2*F)*B.b,E.a=6*(Y-F)*V.a+(3*Y-4*F+1)*I.a+6*(-Y+F)*A.a+(3*Y-2*F)*B.a}static FromColor3(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new J(V.r,V.g,V.b,I)}static LI(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new J(V[I],V[I+1],V[I+2],V[I+3])}static FromArrayToRef(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2?arguments[2]:void 0;A.r=V[I],A.g=V[I+1],A.b=V[I+2],A.a=V[I+3]}static FromInts(V,I,A,B){return new J(V/255,I/255,A/255,B/255)}static CheckColors4(V,I){if(V.length===3*I){const I=[];for(let A=0;A<V.length;A+=3){const B=A/3*4;I[B]=V[A],I[B+1]=V[A+1],I[B+2]=V[A+2],I[B+3]=1}return I}return V}}J._V8PerformanceHack=new J(.5,.5,.5,.5),Object.defineProperties(J.prototype,{dimension:{value:[4]},rank:{value:1}});class G{}G.oI=(0,B.b)(3,P.Black),G.GH=(0,B.b)(3,(()=>new J(0,0,0,0))),(0,F.e)("BABYLON.Color3",P),(0,F.e)("BABYLON.Color4",J)}}]);