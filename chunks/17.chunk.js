"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[17],{12637:(L,U,x)=>{x.r(U),x.d(U,{QU:()=>h,ia:()=>b,TmpColors:()=>E});var mL=x(12602),p=x(12547),G=x(12598),F=x(12610);function a(L){return Math.pow(L,G.g)}function o(L){return L<=.04045?.0773993808*L:Math.pow(.947867299*(L+.055),2.4)}function A(L){return Math.pow(L,G.f)}function r(L){return L<=.0031308?12.92*L:1.055*Math.pow(L,.41666)-.055}class h{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=L,this.g=U,this.b=x}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"QU"}getHashCode(){let L=255*this.r|0;return L=397*L^255*this.g,L=397*L^255*this.b,L}toArray(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[U]=this.r,L[U+1]=this.g,L[U+2]=this.b,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(L,U,this),this}toColor4(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new b(this.r,this.g,this.b,L)}Va(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(L){return new h(this.r*L.r,this.g*L.g,this.b*L.b)}multiplyToRef(L,U){return U.r=this.r*L.r,U.g=this.g*L.g,U.b=this.b*L.b,U}multiplyInPlace(L){return this.r*=L.r,this.g*=L.g,this.b*=L.b,this}multiplyByFloats(L,U,x){return new h(this.r*L,this.g*U,this.b*x)}divide(L){throw new ReferenceError("Can not divide a color")}divideToRef(L,U){throw new ReferenceError("Can not divide a color")}divideInPlace(L){throw new ReferenceError("Can not divide a color")}minimizeInPlace(L){return this.minimizeInPlaceFromFloats(L.r,L.g,L.b)}maximizeInPlace(L){return this.maximizeInPlaceFromFloats(L.r,L.g,L.b)}minimizeInPlaceFromFloats(L,U,x){return this.r=Math.min(L,this.r),this.g=Math.min(U,this.g),this.b=Math.min(x,this.b),this}maximizeInPlaceFromFloats(L,U,x){return this.r=Math.max(L,this.r),this.g=Math.max(U,this.g),this.b=Math.max(x,this.b),this}floorToRef(L){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(L){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(L){return L&&this.r===L.r&&this.g===L.g&&this.b===L.b}equalsFloats(L,U,x){return this.equalsToFloats(L,U,x)}equalsToFloats(L,U,x){return this.r===L&&this.g===U&&this.b===x}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return(0,F.WithinEpsilon)(this.r,L.r,U)&&(0,F.WithinEpsilon)(this.g,L.g,U)&&(0,F.WithinEpsilon)(this.b,L.b,U)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(L){throw new ReferenceError("Can not negate a color")}scale(L){return new h(this.r*L,this.g*L,this.b*L)}scaleInPlace(L){return this.r*=L,this.g*=L,this.b*=L,this}scaleToRef(L,U){return U.r=this.r*L,U.g=this.g*L,U.b=this.b*L,U}scaleAndAddToRef(L,U){return U.r+=this.r*L,U.g+=this.g*L,U.b+=this.b*L,U}clampToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,x=arguments.length>2?arguments[2]:void 0;return x.r=(0,F.Clamp)(this.r,L,U),x.g=(0,F.Clamp)(this.g,L,U),x.b=(0,F.Clamp)(this.b,L,U),x}add(L){return new h(this.r+L.r,this.g+L.g,this.b+L.b)}addInPlace(L){return this.r+=L.r,this.g+=L.g,this.b+=L.b,this}addInPlaceFromFloats(L,U,x){return this.r+=L,this.g+=U,this.b+=x,this}addToRef(L,U){return U.r=this.r+L.r,U.g=this.g+L.g,U.b=this.b+L.b,U}SU(L){return new h(this.r-L.r,this.g-L.g,this.b-L.b)}subtractToRef(L,U){return U.r=this.r-L.r,U.g=this.g-L.g,U.b=this.b-L.b,U}dh(L){return this.r-=L.r,this.g-=L.g,this.b-=L.b,this}subtractFromFloats(L,U,x){return new h(this.r-L,this.g-U,this.b-x)}subtractFromFloatsToRef(L,U,x,mL){return mL.r=this.r-L,mL.g=this.g-U,mL.b=this.b-x,mL}clone(){return new h(this.r,this.g,this.b)}p(L){return this.r=L.r,this.g=L.g,this.b=L.b,this}da(L,U,x){return this.r=L,this.g=U,this.b=x,this}set(L,U,x){return this.da(L,U,x)}la(L){return this.r=this.g=this.b=L,this}toHexString(){const L=Math.round(255*this.r),U=Math.round(255*this.g),x=Math.round(255*this.b);return"#"+(0,F.ToHex)(L)+(0,F.ToHex)(U)+(0,F.ToHex)(x)}fromHexString(L){return"#"!==L.substring(0,1)||7!==L.length||(this.r=parseInt(L.substring(1,3),16)/255,this.g=parseInt(L.substring(3,5),16)/255,this.b=parseInt(L.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new h)}toHSVToRef(L){const U=this.r,x=this.g,mL=this.b,p=Math.max(U,x,mL),G=Math.min(U,x,mL);let F=0,a=0;const o=p,A=p-G;return 0!==p&&(a=A/p),p!=G&&(p==U?(F=(x-mL)/A,x<mL&&(F+=6)):p==x?F=(mL-U)/A+2:p==mL&&(F=(U-x)/A+4),F*=60),L.r=F,L.g=a,L.b=o,L}toLinearSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new h;return this.toLinearSpaceToRef(U,L),U}toLinearSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=o(this.r),L.g=o(this.g),L.b=o(this.b)):(L.r=a(this.r),L.g=a(this.g),L.b=a(this.b)),this}toGammaSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new h;return this.toGammaSpaceToRef(U,L),U}toGammaSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=r(this.r),L.g=r(this.g),L.b=r(this.b)):(L.r=A(this.r),L.g=A(this.g),L.b=A(this.b)),this}static HSVtoRGBToRef(L,U,x,mL){const p=x*U,G=L/60,F=p*(1-Math.abs(G%2-1));let a=0,o=0,A=0;G>=0&&G<=1?(a=p,o=F):G>=1&&G<=2?(a=F,o=p):G>=2&&G<=3?(o=p,A=F):G>=3&&G<=4?(o=F,A=p):G>=4&&G<=5?(a=F,A=p):G>=5&&G<=6&&(a=p,A=F);const r=x-p;return mL.r=a+r,mL.g=o+r,mL.b=A+r,mL}static FromHSV(L,U,x){const mL=new h(0,0,0);return h.HSVtoRGBToRef(L,U,x,mL),mL}static FromHexString(L){return new h(0,0,0).fromHexString(L)}static qU(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(L[U],L[U+1],L[U+2])}static FromArrayToRef(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2?arguments[2]:void 0;x.r=L[U],x.g=L[U+1],x.b=L[U+2]}static FromInts(L,U,x){return new h(L/255,U/255,x/255)}static Lerp(L,U,x){const mL=new h(0,0,0);return h.LerpToRef(L,U,x,mL),mL}static LerpToRef(L,U,x,mL){mL.r=L.r+(U.r-L.r)*x,mL.g=L.g+(U.g-L.g)*x,mL.b=L.b+(U.b-L.b)*x}static Hermite(L,U,x,mL,p){const G=p*p,F=p*G,a=2*F-3*G+1,o=-2*F+3*G,A=F-2*G+p,r=F-G,b=L.r*a+x.r*o+U.r*A+mL.r*r,E=L.g*a+x.g*o+U.g*A+mL.g*r,Y=L.b*a+x.b*o+U.b*A+mL.b*r;return new h(b,E,Y)}static Hermite1stDerivative(L,U,x,mL,p){const G=h.Black();return this.Hermite1stDerivativeToRef(L,U,x,mL,p,G),G}static Hermite1stDerivativeToRef(L,U,x,mL,p,G){const F=p*p;G.r=6*(F-p)*L.r+(3*F-4*p+1)*U.r+6*(-F+p)*x.r+(3*F-2*p)*mL.r,G.g=6*(F-p)*L.g+(3*F-4*p+1)*U.g+6*(-F+p)*x.g+(3*F-2*p)*mL.g,G.b=6*(F-p)*L.b+(3*F-4*p+1)*U.b+6*(-F+p)*x.b+(3*F-2*p)*mL.b}static Red(){return new h(1,0,0)}static Green(){return new h(0,1,0)}static Blue(){return new h(0,0,1)}static Black(){return new h(0,0,0)}static get BlackReadOnly(){return h._BlackReadOnly}static White(){return new h(1,1,1)}static Purple(){return new h(.5,0,.5)}static Magenta(){return new h(1,0,1)}static Yellow(){return new h(1,1,0)}static Gray(){return new h(.5,.5,.5)}static Teal(){return new h(0,1,1)}static Random(){return new h(Math.random(),Math.random(),Math.random())}}h._V8PerformanceHack=new h(.5,.5,.5),h._BlackReadOnly=h.Black(),Object.defineProperties(h.prototype,{dimension:{value:[3]},rank:{value:1}});class b{constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=L,this.g=U,this.b=x,this.a=mL}Va(){return[this.r,this.g,this.b,this.a]}toArray(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return L[U]=this.r,L[U+1]=this.g,L[U+2]=this.b,L[U+3]=this.a,this}Vx(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=L[U],this.g=L[U+1],this.b=L[U+2],this.a=L[U+3],this}equals(L){return L&&this.r===L.r&&this.g===L.g&&this.b===L.b&&this.a===L.a}add(L){return new b(this.r+L.r,this.g+L.g,this.b+L.b,this.a+L.a)}addToRef(L,U){return U.r=this.r+L.r,U.g=this.g+L.g,U.b=this.b+L.b,U.a=this.a+L.a,U}addInPlace(L){return this.r+=L.r,this.g+=L.g,this.b+=L.b,this.a+=L.a,this}addInPlaceFromFloats(L,U,x,mL){return this.r+=L,this.g+=U,this.b+=x,this.a+=mL,this}SU(L){return new b(this.r-L.r,this.g-L.g,this.b-L.b,this.a-L.a)}subtractToRef(L,U){return U.r=this.r-L.r,U.g=this.g-L.g,U.b=this.b-L.b,U.a=this.a-L.a,U}dh(L){return this.r-=L.r,this.g-=L.g,this.b-=L.b,this.a-=L.a,this}subtractFromFloats(L,U,x,mL){return new b(this.r-L,this.g-U,this.b-x,this.a-mL)}subtractFromFloatsToRef(L,U,x,mL,p){return p.r=this.r-L,p.g=this.g-U,p.b=this.b-x,p.a=this.a-mL,p}scale(L){return new b(this.r*L,this.g*L,this.b*L,this.a*L)}scaleInPlace(L){return this.r*=L,this.g*=L,this.b*=L,this.a*=L,this}scaleToRef(L,U){return U.r=this.r*L,U.g=this.g*L,U.b=this.b*L,U.a=this.a*L,U}scaleAndAddToRef(L,U){return U.r+=this.r*L,U.g+=this.g*L,U.b+=this.b*L,U.a+=this.a*L,U}clampToRef(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,x=arguments.length>2?arguments[2]:void 0;return x.r=(0,F.Clamp)(this.r,L,U),x.g=(0,F.Clamp)(this.g,L,U),x.b=(0,F.Clamp)(this.b,L,U),x.a=(0,F.Clamp)(this.a,L,U),x}multiply(L){return new b(this.r*L.r,this.g*L.g,this.b*L.b,this.a*L.a)}multiplyToRef(L,U){return U.r=this.r*L.r,U.g=this.g*L.g,U.b=this.b*L.b,U.a=this.a*L.a,U}multiplyInPlace(L){return this.r*=L.r,this.g*=L.g,this.b*=L.b,this.a*=L.a,this}multiplyByFloats(L,U,x,mL){return new b(this.r*L,this.g*U,this.b*x,this.a*mL)}divide(L){throw new ReferenceError("Can not divide a color")}divideToRef(L,U){throw new ReferenceError("Can not divide a color")}divideInPlace(L){throw new ReferenceError("Can not divide a color")}minimizeInPlace(L){return this.r=Math.min(this.r,L.r),this.g=Math.min(this.g,L.g),this.b=Math.min(this.b,L.b),this.a=Math.min(this.a,L.a),this}maximizeInPlace(L){return this.r=Math.max(this.r,L.r),this.g=Math.max(this.g,L.g),this.b=Math.max(this.b,L.b),this.a=Math.max(this.a,L.a),this}minimizeInPlaceFromFloats(L,U,x,mL){return this.r=Math.min(L,this.r),this.g=Math.min(U,this.g),this.b=Math.min(x,this.b),this.a=Math.min(mL,this.a),this}maximizeInPlaceFromFloats(L,U,x,mL){return this.r=Math.max(L,this.r),this.g=Math.max(U,this.g),this.b=Math.max(x,this.b),this.a=Math.max(mL,this.a),this}floorToRef(L){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(L){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(L){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:G.c;return(0,F.WithinEpsilon)(this.r,L.r,U)&&(0,F.WithinEpsilon)(this.g,L.g,U)&&(0,F.WithinEpsilon)(this.b,L.b,U)&&(0,F.WithinEpsilon)(this.a,L.a,U)}equalsToFloats(L,U,x,mL){return this.r===L&&this.g===U&&this.b===x&&this.a===mL}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ia"}getHashCode(){let L=255*this.r|0;return L=397*L^255*this.g,L=397*L^255*this.b,L=397*L^255*this.a,L}clone(){return(new b).p(this)}p(L){return this.r=L.r,this.g=L.g,this.b=L.b,this.a=L.a,this}da(L,U,x,mL){return this.r=L,this.g=U,this.b=x,this.a=mL,this}set(L,U,x,mL){return this.da(L,U,x,mL)}la(L){return this.r=this.g=this.b=this.a=L,this}toHexString(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=Math.round(255*this.r),x=Math.round(255*this.g),mL=Math.round(255*this.b);if(L)return"#"+(0,F.ToHex)(U)+(0,F.ToHex)(x)+(0,F.ToHex)(mL);const p=Math.round(255*this.a);return"#"+(0,F.ToHex)(U)+(0,F.ToHex)(x)+(0,F.ToHex)(mL)+(0,F.ToHex)(p)}fromHexString(L){return"#"!==L.substring(0,1)||9!==L.length&&7!==L.length||(this.r=parseInt(L.substring(1,3),16)/255,this.g=parseInt(L.substring(3,5),16)/255,this.b=parseInt(L.substring(5,7),16)/255,9===L.length&&(this.a=parseInt(L.substring(7,9),16)/255)),this}toLinearSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new b;return this.toLinearSpaceToRef(U,L),U}toLinearSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=o(this.r),L.g=o(this.g),L.b=o(this.b)):(L.r=a(this.r),L.g=a(this.g),L.b=a(this.b)),L.a=this.a,this}toGammaSpace(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new b;return this.toGammaSpaceToRef(U,L),U}toGammaSpaceToRef(L){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(L.r=r(this.r),L.g=r(this.g),L.b=r(this.b)):(L.r=A(this.r),L.g=A(this.g),L.b=A(this.b)),L.a=this.a,this}static FromHexString(L){return"#"!==L.substring(0,1)||9!==L.length&&7!==L.length?new b(0,0,0,0):new b(0,0,0,1).fromHexString(L)}static Lerp(L,U,x){return b.LerpToRef(L,U,x,new b)}static LerpToRef(L,U,x,mL){return mL.r=L.r+(U.r-L.r)*x,mL.g=L.g+(U.g-L.g)*x,mL.b=L.b+(U.b-L.b)*x,mL.a=L.a+(U.a-L.a)*x,mL}static Hermite(L,U,x,mL,p){const G=p*p,F=p*G,a=2*F-3*G+1,o=-2*F+3*G,A=F-2*G+p,r=F-G,h=L.r*a+x.r*o+U.r*A+mL.r*r,E=L.g*a+x.g*o+U.g*A+mL.g*r,Y=L.b*a+x.b*o+U.b*A+mL.b*r,S=L.a*a+x.a*o+U.a*A+mL.a*r;return new b(h,E,Y,S)}static Hermite1stDerivative(L,U,x,mL,p){const G=new b;return this.Hermite1stDerivativeToRef(L,U,x,mL,p,G),G}static Hermite1stDerivativeToRef(L,U,x,mL,p,G){const F=p*p;G.r=6*(F-p)*L.r+(3*F-4*p+1)*U.r+6*(-F+p)*x.r+(3*F-2*p)*mL.r,G.g=6*(F-p)*L.g+(3*F-4*p+1)*U.g+6*(-F+p)*x.g+(3*F-2*p)*mL.g,G.b=6*(F-p)*L.b+(3*F-4*p+1)*U.b+6*(-F+p)*x.b+(3*F-2*p)*mL.b,G.a=6*(F-p)*L.a+(3*F-4*p+1)*U.a+6*(-F+p)*x.a+(3*F-2*p)*mL.a}static FromColor3(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b(L.r,L.g,L.b,U)}static qU(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(L[U],L[U+1],L[U+2],L[U+3])}static FromArrayToRef(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2?arguments[2]:void 0;x.r=L[U],x.g=L[U+1],x.b=L[U+2],x.a=L[U+3]}static FromInts(L,U,x,mL){return new b(L/255,U/255,x/255,mL/255)}static CheckColors4(L,U){if(L.length===3*U){const U=[];for(let x=0;x<L.length;x+=3){const mL=x/3*4;U[mL]=L[x],U[mL+1]=L[x+1],U[mL+2]=L[x+2],U[mL+3]=1}return U}return L}}b._V8PerformanceHack=new b(.5,.5,.5,.5),Object.defineProperties(b.prototype,{dimension:{value:[4]},rank:{value:1}});class E{}E.QU=(0,mL.e)(3,h.Black),E.ia=(0,mL.e)(3,(()=>new b(0,0,0,0))),(0,p.d)("BABYLON.Color3",h),(0,p.d)("BABYLON.Color4",b)}}]);