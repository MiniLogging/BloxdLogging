"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2276:(U,W,l)=>{l.r(W),l.d(W,{ReadExrDataAsync:()=>yU,_ExrTextureLoader:()=>qU});var M=l(512),t=l(722);const L=4,p=4,B=1,k=2,A=8,q=65536,y=q>>3,j=14,s=65537,w=1<<j,K=w-1,r=59,m=63,f=2+m-r;var g,E;!function(U){U[U.NO_COMPRESSION=0]="NO_COMPRESSION",U[U.RLE_COMPRESSION=1]="RLE_COMPRESSION",U[U.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",U[U.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",U[U.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",U[U.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(g||(g={})),function(U){U[U.INCREASING_Y=0]="INCREASING_Y",U[U.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const Z=function(){const U=new ArrayBuffer(4),W=new Float32Array(U),l=new Uint32Array(U),M=new Uint32Array(512),t=new Uint32Array(512);for(let k=0;k<256;++k){const U=k-127;U<-27?(M[k]=0,M[256|k]=32768,t[k]=24,t[256|k]=24):U<-14?(M[k]=1024>>-U-14,M[256|k]=1024>>-U-14|32768,t[k]=-U-1,t[256|k]=-U-1):U<=15?(M[k]=U+15<<10,M[256|k]=U+15<<10|32768,t[k]=13,t[256|k]=13):U<128?(M[k]=31744,M[256|k]=64512,t[k]=24,t[256|k]=24):(M[k]=31744,M[256|k]=64512,t[k]=13,t[256|k]=13)}const L=new Uint32Array(2048),p=new Uint32Array(64),B=new Uint32Array(64);for(let k=1;k<1024;++k){let U=k<<13,W=0;for(;0===(8388608&U);)U<<=1,W-=8388608;U&=-8388609,W+=947912704,L[k]=U|W}for(let k=1024;k<2048;++k)L[k]=939524096+(k-1024<<13);for(let k=1;k<31;++k)p[k]=k<<23;p[31]=1199570944,p[32]=2147483648;for(let k=33;k<63;++k)p[k]=2147483648+(k-32<<23);p[63]=3347054592;for(let k=1;k<64;++k)32!==k&&(B[k]=1024);return{floatView:W,uint32View:l,baseTable:M,shiftTable:t,mantissaTable:L,exponentTable:p,offsetTable:B}}();function N(U,W){const l=new Uint8Array(U);let M=0;for(;0!=l[W.value+M];)M+=1;const t=(new TextDecoder).decode(l.slice(W.value,W.value+M));return W.value=W.value+M+1,t}function D(U,W){const l=U.getInt32(W.value,!0);return W.value+=L,l}function o(U,W){const l=U.getUint32(W.value,!0);return W.value+=L,l}function i(U,W){const l=U.getUint8(W.value);return W.value+=B,l}function O(U,W){const l=U.getUint16(W.value,!0);return W.value+=k,l}function e(U,W){const l=U[W.value];return W.value+=B,l}function d(U,W){let l;return l="getBigInt64"in DataView.prototype?Number(U.getBigInt64(W.value,!0)):U.getUint32(W.value+4,!0)+Number(U.getUint32(W.value,!0)<<32),W.value+=A,l}function H(U,W){const l=U.getFloat32(W.value,!0);return W.value+=p,l}function V(U,W){return function(U){const W=(31744&U)>>10,l=1023&U;return(U>>15?-1:1)*(W?31===W?l?NaN:1/0:Math.pow(2,W-15)*(1+l/1024):l/1024*6103515625e-14)}(O(U,W))}function n(U,W){return function(U){if(Math.abs(U)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");U=(0,t.Clamp)(U,-65504,65504),Z.floatView[0]=U;const W=Z.uint32View[0],l=W>>23&511;return Z.baseTable[l]+((8388607&W)>>Z.shiftTable[l])}(H(U,W))}function x(U,W,l,M){switch(l){case"string":case"stringvector":case"iccProfile":return function(U,W,l){const M=(new TextDecoder).decode(new Uint8Array(U).slice(W.value,W.value+l));return W.value=W.value+l,M}(U.buffer,W,M);case"chlist":return function(U,W,l){const M=W.value,t=[];for(;W.value<M+l-1;){const l=N(U.buffer,W),M=D(U,W),L=i(U,W);W.value+=3;const p=D(U,W),B=D(U,W);t.push({name:l,pixelType:M,pLinear:L,xSampling:p,ySampling:B})}return W.value+=1,t}(U,W,M);case"chromaticities":return function(U,W){return{redX:H(U,W),redY:H(U,W),greenX:H(U,W),greenY:H(U,W),blueX:H(U,W),blueY:H(U,W),whiteX:H(U,W),whiteY:H(U,W)}}(U,W);case"compression":return function(U,W){return i(U,W)}(U,W);case"box2i":return function(U,W){return{xMin:D(U,W),yMin:D(U,W),xMax:D(U,W),yMax:D(U,W)}}(U,W);case"lineOrder":return function(U,W){const l=i(U,W);return E[l]}(U,W);case"float":return H(U,W);case"v2f":return function(U,W){return[H(U,W),H(U,W)]}(U,W);case"v3f":return function(U,W){return[H(U,W),H(U,W),H(U,W)]}(U,W);case"int":return D(U,W);case"rational":return function(U,W){return[D(U,W),o(U,W)]}(U,W);case"timecode":return function(U,W){return[o(U,W),o(U,W)]}(U,W);case"preview":return W.value+=M,"skipped";default:return void(W.value+=M)}}function I(U){for(let W=1;W<U.length;W++){const l=U[W-1]+U[W]-128;U[W]=l}}function R(U,W){let l=0,M=Math.floor((U.length+1)/2),t=0;const L=U.length-1;for(;!(t>L)&&(W[t++]=U[l++],!(t>L));)W[t++]=U[M++]}const F=20000630;function v(U,W){if(U.getUint32(0,!0)!=F)throw new Error("Incorrect OpenEXR format");const l=U.getUint8(4),t=U.getUint8(5),L={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};W.value=8;const p={};let B=!0;for(;B;){const l=N(U.buffer,W);if(l){const t=N(U.buffer,W),L=x(U,W,t,o(U,W));void 0===L?M.b.Warn(`Unknown header attribute type ${t}'.`):p[l]=L}else B=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:l,spec:L,...p}}const J=32768,Q=65535;function G(U,W,l,M,t){for(;l<U;)W=W<<8|e(M,t),l+=8;return{l:W>>(l-=U)&(1<<U)-1,c:W,lc:l}}function u(U,W,l,M){return{c:U=U<<8|e(l,M),lc:W+=8}}function b(U,W,l,M,t,L,p,B,k){if(U==W){if(M<8){const U=u(l,M,t,L);l=U.c,M=U.lc}let U=l>>(M-=8);if(U=new Uint8Array([U])[0],B.value+U>k)return null;const W=p[B.value-1];for(;U-- >0;)p[B.value++]=W}else{if(!(B.value<k))return null;p[B.value++]=U}return{c:l,lc:M}}const C=new Array(59);function P(U,W,l,M,t,L){const p=W;let B=0,k=0;for(;M<=t;M++){if(p.value-W.value>l)return;let A=G(6,B,k,U,p);const q=A.l;if(B=A.c,k=A.lc,L[M]=q,q==m){if(p.value-W.value>l)throw new Error("Error in HufUnpackEncTable");A=G(8,B,k,U,p);let q=A.l+f;if(B=A.c,k=A.lc,M+q>t+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)L[M++]=0;M--}else if(q>=r){let U=q-r+2;if(M+U>t+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)L[M++]=0;M--}}!function(U){for(let l=0;l<=58;++l)C[l]=0;for(let l=0;l<s;++l)C[U[l]]+=1;let W=0;for(let l=58;l>0;--l){const U=W+C[l]>>1;C[l]=W,W=U}for(let l=0;l<s;++l){const W=U[l];W>0&&(U[l]=W|C[W]++<<6)}}(L)}function S(U){return 63&U}function c(U){return U>>6}function h(U,W,l,M,t,L){const p=l.value,B=o(W,l),k=o(W,l);l.value+=4;const A=o(W,l);if(l.value+=4,B<0||B>=s||k<0||k>=s)throw new Error("Wrong HUF_ENCSIZE");const q=new Array(s),y=new Array(w);!function(U){for(let W=0;W<w;W++)U[W]={},U[W].len=0,U[W].lit=0,U[W].p=null}(y);if(P(U,l,M-(l.value-p),B,k,q),A>8*(M-(l.value-p)))throw new Error("Wrong hufUncompress");!function(U,W,l,M){for(;W<=l;W++){const l=c(U[W]),t=S(U[W]);if(l>>t)throw new Error("Invalid table entry");if(t>j){const U=M[l>>t-j];if(U.len)throw new Error("Invalid table entry");if(U.lit++,U.p){const W=U.p;U.p=new Array(U.lit);for(let l=0;l<U.lit-1;++l)U.p[l]=W[l]}else U.p=new Array(1);U.p[U.lit-1]=W}else if(t){let U=0;for(let L=1<<j-t;L>0;L--){const L=M[(l<<j-t)+U];if(L.len||L.p)throw new Error("Invalid table entry");L.len=t,L.lit=W,U++}}}}(q,B,k,y),function(U,W,l,M,t,L,p,B,k){let A=0,q=0;const y=p,s=Math.trunc(M.value+(t+7)/8);for(;M.value<s;){let t=u(A,q,l,M);for(A=t.c,q=t.lc;q>=j;){const p=W[A>>q-j&K];if(p.len){q-=p.len;const U=b(p.lit,L,A,q,l,M,B,k,y);U&&(A=U.c,q=U.lc)}else{if(!p.p)throw new Error("hufDecode issues");let W;for(W=0;W<p.lit;W++){const j=S(U[p.p[W]]);for(;q<j&&M.value<s;)t=u(A,q,l,M),A=t.c,q=t.lc;if(q>=j&&c(U[p.p[W]])==(A>>q-j&(1<<j)-1)){q-=j;const U=b(p.p[W],L,A,q,l,M,B,k,y);U&&(A=U.c,q=U.lc);break}}if(W==p.lit)throw new Error("HufDecode issues")}}}const w=8-t&7;for(A>>=w,q-=w;q>0;){const U=W[A<<j-q&K];if(!U.len)throw new Error("HufDecode issues");{q-=U.len;const W=b(U.lit,L,A,q,l,M,B,k,y);W&&(A=W.c,q=W.lc)}}}(q,y,U,l,A,k,L,t,{value:0})}function z(U){return 65535&U}function a(U){const W=z(U);return W>32767?W-65536:W}function Y(U,W){const l=a(U),M=a(W),t=l+(1&M)+(M>>1);return{a:t,b:t-M}}function X(U,W){const l=z(U),M=z(W),t=l-(M>>1)&Q;return{a:M+t-J&Q,b:t}}function T(U,W,l,M,t,L,p){const B=p<16384,k=l>t?t:l;let A,q,y=1;for(;y<=k;)y<<=1;for(y>>=1,A=y,y>>=1;y>=1;){q=0;const p=q+L*(t-A),k=L*y,j=L*A,s=M*y,w=M*A;let K,r,m,f;for(;q<=p;q+=j){let t=q;const L=q+M*(l-A);for(;t<=L;t+=w){const l=t+s,M=t+k,L=M+s;if(B){let p=Y(U[t+W],U[M+W]);K=p.a,m=p.b,p=Y(U[l+W],U[L+W]),r=p.a,f=p.b,p=Y(K,r),U[t+W]=p.a,U[l+W]=p.b,p=Y(m,f),U[M+W]=p.a,U[L+W]=p.b}else{let p=X(U[t+W],U[M+W]);K=p.a,m=p.b,p=X(U[l+W],U[L+W]),r=p.a,f=p.b,p=X(K,r),U[t+W]=p.a,U[l+W]=p.b,p=X(m,f),U[M+W]=p.a,U[L+W]=p.b}}if(l&y){const l=t+k;let M;M=B?Y(U[t+W],U[l+W]):X(U[t+W],U[l+W]),K=M.a,U[l+W]=M.b,U[t+W]=K}}if(t&y){let t=q;const L=q+M*(l-A);for(;t<=L;t+=w){const l=t+s;let M;M=B?Y(U[t+W],U[l+W]):X(U[t+W],U[l+W]),K=M.a,U[l+W]=M.b,U[t+W]=K}}A=y,y>>=1}return q}function UU(U){return new DataView(U.array.buffer,U.offset.value,U.size)}function WU(U){const W=U.viewer.buffer.slice(U.offset.value,U.offset.value+U.size),l=new Uint8Array(function(U){let W=U.byteLength;const l=[];let M=0;const t=new DataView(U);for(;W>0;){const U=t.getInt8(M++);if(U<0){const L=-U;W-=L+1;for(let U=0;U<L;U++)l.push(t.getUint8(M++))}else{const L=U;W-=2;const p=t.getUint8(M++);for(let U=0;U<L+1;U++)l.push(p)}}return l}(W)),M=new Uint8Array(l.length);return I(l),R(l,M),new DataView(M.buffer)}function lU(U){const W=U.array.slice(U.offset.value,U.offset.value+U.size),l=fflate.unzlibSync(W),M=new Uint8Array(l.length);return I(l),R(l,M),new DataView(M.buffer)}function MU(U){const W=U.array.slice(U.offset.value,U.offset.value+U.size),l=fflate.unzlibSync(W),M=U.lines*U.channels*U.width,t=1==U.type?new Uint16Array(M):new Uint32Array(M);let L=0,p=0;const B=new Array(4);for(let k=0;k<U.lines;k++)for(let W=0;W<U.channels;W++){let W=0;switch(U.type){case 1:B[0]=L,B[1]=B[0]+U.width,L=B[1]+U.width;for(let M=0;M<U.width;++M){W+=l[B[0]++]<<8|l[B[1]++],t[p]=W,p++}break;case 2:B[0]=L,B[1]=B[0]+U.width,B[2]=B[1]+U.width,L=B[2]+U.width;for(let M=0;M<U.width;++M){W+=l[B[0]++]<<24|l[B[1]++]<<16|l[B[2]++]<<8,t[p]=W,p++}}}return new DataView(t.buffer)}function tU(U){const W=U.viewer,l={value:U.offset.value},M=new Uint16Array(U.width*U.scanlineBlockSize*(U.channels*U.type)),t=new Uint8Array(y);let L=0;const p=new Array(U.channels);for(let k=0;k<U.channels;k++)p[k]={},p[k].start=L,p[k].end=p[k].start,p[k].nx=U.width,p[k].ny=U.lines,p[k].size=U.type,L+=p[k].nx*p[k].ny*p[k].size;const B=O(W,l),A=O(W,l);if(A>=y)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(B<=A)for(let k=0;k<A-B+1;k++)t[k+B]=i(W,l);const j=new Uint16Array(q),s=function(U,W){let l=0;for(let t=0;t<q;++t)(0==t||U[t>>3]&1<<(7&t))&&(W[l++]=t);const M=l-1;for(;l<q;)W[l++]=0;return M}(t,j),w=o(W,l);h(U.array,W,l,w,M,L);for(let k=0;k<U.channels;++k){const U=p[k];for(let W=0;W<p[k].size;++W)T(M,U.start+W,U.nx,U.size,U.ny,U.nx*U.size,s)}!function(U,W,l){for(let M=0;M<l;++M)W[M]=U[W[M]]}(j,M,L);let K=0;const r=new Uint8Array(M.buffer.byteLength);for(let q=0;q<U.lines;q++)for(let W=0;W<U.channels;W++){const U=p[W],l=U.nx*U.size,t=new Uint8Array(M.buffer,U.end*k,l*k);r.set(t,K),K+=l*k,U.end+=l}return new DataView(r.buffer)}var LU,pU=l(503);!function(U){U[U.Float=0]="Float",U[U.HalfFloat=1]="HalfFloat"}(LU||(LU={}));class BU{}async function kU(U,W,l,M){const t={size:0,viewer:W,array:new Uint8Array(W.buffer),offset:l,width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,channels:U.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(U.compression){case g.NO_COMPRESSION:t.lines=1,t.uncompress=UU;break;case g.RLE_COMPRESSION:t.lines=1,t.uncompress=WU;break;case g.ZIPS_COMPRESSION:t.lines=1,t.uncompress=lU,await pU.h.LoadScriptAsync(BU.FFLATEUrl);break;case g.ZIP_COMPRESSION:t.lines=16,t.uncompress=lU,await pU.h.LoadScriptAsync(BU.FFLATEUrl);break;case g.PIZ_COMPRESSION:t.lines=32,t.uncompress=tU;break;case g.PXR24_COMPRESSION:t.lines=16,t.uncompress=MU,await pU.h.LoadScriptAsync(BU.FFLATEUrl);break;default:throw new Error(g[U.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const L={};for(const p of U.channels)switch(p.name){case"R":case"G":case"B":case"A":case"Y":L[p.name]=!0,t.type=p.pixelType}let B=!1;if(L.R&&L.G&&L.B&&L.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G&&L.B)B=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(L.R)t.outputChannels=1,t.decodeChannels={R:0};else{if(!L.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(M){case LU.Float:t.getter=V,t.inputSize=k;break;case LU.HalfFloat:t.getter=O,t.inputSize=k}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+U.compression);switch(M){case LU.Float:t.getter=H,t.inputSize=p;break;case LU.HalfFloat:t.getter=n,t.inputSize=p}}t.blockCount=t.height/t.scanlineBlockSize;for(let p=0;p<t.blockCount;p++)d(W,l);const A=t.width*t.height*t.outputChannels;switch(M){case LU.Float:t.byteArray=new Float32Array(A),t.textureType=1,B&&t.byteArray.fill(1,0,A);break;case LU.HalfFloat:t.byteArray=new Uint16Array(A),t.textureType=2,B&&t.byteArray.fill(15360,0,A);break;default:throw new Error("Unsupported type: "+M)}let q=0;for(const p of U.channels)void 0!==t.decodeChannels[p.name]&&(t.channelLineOffsets[p.name]=q*t.width),q+=2*p.pixelType;return t.bytesPerLine=t.width*q,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===U.lineOrder?t.scanOrder=U=>U:t.scanOrder=U=>t.height-1-U,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function AU(U,W,l,M){const t={value:0};for(let L=0;L<U.height/U.scanlineBlockSize;L++){const p=D(l,M)-W.dataWindow.yMin;U.size=o(l,M),U.lines=p+U.scanlineBlockSize>U.height?U.height-p:U.scanlineBlockSize;const B=U.size<U.lines*U.bytesPerLine&&U.uncompress?U.uncompress(U):UU(U);M.value+=U.size;for(let l=0;l<U.scanlineBlockSize;l++){const M=L*U.scanlineBlockSize,p=l+U.scanOrder(M);if(p>=U.height)continue;const k=l*U.bytesPerLine,A=(U.height-1-p)*U.outLineWidth;for(let l=0;l<U.channels;l++){const M=W.channels[l].name,L=U.channelLineOffsets[M],p=U.decodeChannels[M];if(void 0!==p){t.value=k+L;for(let W=0;W<U.width;W++){const l=A+W*U.outputChannels+p;U.byteArray&&(U.byteArray[l]=U.getter(B,t))}}}}}}BU.DefaultOutputType=LU.HalfFloat,BU.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class qU{constructor(){this.supportCascades=!1}loadCubeData(U,W,l,M,t){throw".exr not supported in Cube."}loadData(U,W,l){const t=new DataView(U.buffer),L={value:0},p=v(t,L);kU(p,t,L,BU.DefaultOutputType).then((U=>{AU(U,p,t,L);const M=p.dataWindow.xMax-p.dataWindow.xMin+1,B=p.dataWindow.yMax-p.dataWindow.yMin+1;l(M,B,W.generateMipMaps,!1,(()=>{const l=W.getEngine();W.format=p.format,W.type=U.textureType,W.invertY=!1,W._gammaSpace=!p.linearSpace,U.byteArray&&l._uploadDataToTextureDirectly(W,U.byteArray,0,0,void 0,!0)}))})).catch((U=>{M.b.Error("Failed to load EXR texture: ",U)}))}}async function yU(U){const W=new DataView(U),l={value:0},t=v(W,l);try{const U=await kU(t,W,l,LU.Float);return AU(U,t,W,l),U.byteArray?{width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,data:new Float32Array(U.byteArray)}:(M.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(L){M.b.Error("Failed to load EXR data: ",L)}return{width:0,height:0,data:null}}}}]);