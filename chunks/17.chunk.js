"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[17],{12421:(N,p,T)=>{T.r(p),T.d(p,{wp:()=>M,LX:()=>b,TmpColors:()=>l});var A=T(12384),a=T(12331),C=T(12376),U=T(12390);function X(N){return Math.pow(N,C.k)}function y(N){return N<=.04045?.0773993808*N:Math.pow(.947867299*(N+.055),2.4)}function e(N){return Math.pow(N,C.h)}function H(N){return N<=.0031308?12.92*N:1.055*Math.pow(N,.41666)-.055}class M{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=N,this.g=p,this.b=T}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"wp"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N}toArray(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[p]=this.r,N[p+1]=this.g,N[p+2]=this.b,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M.FromArrayToRef(N,p,this),this}toColor4(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new b(this.r,this.g,this.b,N)}UX(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(N){return new M(this.r*N.r,this.g*N.g,this.b*N.b)}multiplyToRef(N,p){return p.r=this.r*N.r,p.g=this.g*N.g,p.b=this.b*N.b,p}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this}multiplyByFloats(N,p,T){return new M(this.r*N,this.g*p,this.b*T)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,p){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.r,N.g,N.b)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.r,N.g,N.b)}minimizeInPlaceFromFloats(N,p,T){return this.r=Math.min(N,this.r),this.g=Math.min(p,this.g),this.b=Math.min(T,this.b),this}maximizeInPlaceFromFloats(N,p,T){return this.r=Math.max(N,this.r),this.g=Math.max(p,this.g),this.b=Math.max(T,this.b),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b}equalsFloats(N,p,T){return this.equalsToFloats(N,p,T)}equalsToFloats(N,p,T){return this.r===N&&this.g===p&&this.b===T}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.b;return(0,U.WithinEpsilon)(this.r,N.r,p)&&(0,U.WithinEpsilon)(this.g,N.g,p)&&(0,U.WithinEpsilon)(this.b,N.b,p)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}scale(N){return new M(this.r*N,this.g*N,this.b*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this}scaleToRef(N,p){return p.r=this.r*N,p.g=this.g*N,p.b=this.b*N,p}scaleAndAddToRef(N,p){return p.r+=this.r*N,p.g+=this.g*N,p.b+=this.b*N,p}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,U.Clamp)(this.r,N,p),T.g=(0,U.Clamp)(this.g,N,p),T.b=(0,U.Clamp)(this.b,N,p),T}add(N){return new M(this.r+N.r,this.g+N.g,this.b+N.b)}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this}addInPlaceFromFloats(N,p,T){return this.r+=N,this.g+=p,this.b+=T,this}addToRef(N,p){return p.r=this.r+N.r,p.g=this.g+N.g,p.b=this.b+N.b,p}Ip(N){return new M(this.r-N.r,this.g-N.g,this.b-N.b)}subtractToRef(N,p){return p.r=this.r-N.r,p.g=this.g-N.g,p.b=this.b-N.b,p}iM(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this}subtractFromFloats(N,p,T){return new M(this.r-N,this.g-p,this.b-T)}subtractFromFloatsToRef(N,p,T,A){return A.r=this.r-N,A.g=this.g-p,A.b=this.b-T,A}clone(){return new M(this.r,this.g,this.b)}A(N){return this.r=N.r,this.g=N.g,this.b=N.b,this}kX(N,p,T){return this.r=N,this.g=p,this.b=T,this}set(N,p,T){return this.kX(N,p,T)}IX(N){return this.r=this.g=this.b=N,this}toHexString(){const N=Math.round(255*this.r),p=Math.round(255*this.g),T=Math.round(255*this.b);return"#"+(0,U.ToHex)(N)+(0,U.ToHex)(p)+(0,U.ToHex)(T)}fromHexString(N){return"#"!==N.substring(0,1)||7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new M)}toHSVToRef(N){const p=this.r,T=this.g,A=this.b,a=Math.max(p,T,A),C=Math.min(p,T,A);let U=0,X=0;const y=a,e=a-C;return 0!==a&&(X=e/a),a!=C&&(a==p?(U=(T-A)/e,T<A&&(U+=6)):a==T?U=(A-p)/e+2:a==A&&(U=(p-T)/e+4),U*=60),N.r=U,N.g=X,N.b=y,N}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new M;return this.toLinearSpaceToRef(p,N),p}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=y(this.r),N.g=y(this.g),N.b=y(this.b)):(N.r=X(this.r),N.g=X(this.g),N.b=X(this.b)),this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new M;return this.toGammaSpaceToRef(p,N),p}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=H(this.r),N.g=H(this.g),N.b=H(this.b)):(N.r=e(this.r),N.g=e(this.g),N.b=e(this.b)),this}static HSVtoRGBToRef(N,p,T,A){const a=T*p,C=N/60,U=a*(1-Math.abs(C%2-1));let X=0,y=0,e=0;C>=0&&C<=1?(X=a,y=U):C>=1&&C<=2?(X=U,y=a):C>=2&&C<=3?(y=a,e=U):C>=3&&C<=4?(y=U,e=a):C>=4&&C<=5?(X=U,e=a):C>=5&&C<=6&&(X=a,e=U);const H=T-a;return A.r=X+H,A.g=y+H,A.b=e+H,A}static FromHSV(N,p,T){const A=new M(0,0,0);return M.HSVtoRGBToRef(N,p,T,A),A}static FromHexString(N){return new M(0,0,0).fromHexString(N)}static gp(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new M(N[p],N[p+1],N[p+2])}static FromArrayToRef(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=N[p],T.g=N[p+1],T.b=N[p+2]}static FromInts(N,p,T){return new M(N/255,p/255,T/255)}static Lerp(N,p,T){const A=new M(0,0,0);return M.LerpToRef(N,p,T,A),A}static LerpToRef(N,p,T,A){A.r=N.r+(p.r-N.r)*T,A.g=N.g+(p.g-N.g)*T,A.b=N.b+(p.b-N.b)*T}static Hermite(N,p,T,A,a){const C=a*a,U=a*C,X=2*U-3*C+1,y=-2*U+3*C,e=U-2*C+a,H=U-C,b=N.r*X+T.r*y+p.r*e+A.r*H,l=N.g*X+T.g*y+p.g*e+A.g*H,k=N.b*X+T.b*y+p.b*e+A.b*H;return new M(b,l,k)}static Hermite1stDerivative(N,p,T,A,a){const C=M.Black();return this.Hermite1stDerivativeToRef(N,p,T,A,a,C),C}static Hermite1stDerivativeToRef(N,p,T,A,a,C){const U=a*a;C.r=6*(U-a)*N.r+(3*U-4*a+1)*p.r+6*(-U+a)*T.r+(3*U-2*a)*A.r,C.g=6*(U-a)*N.g+(3*U-4*a+1)*p.g+6*(-U+a)*T.g+(3*U-2*a)*A.g,C.b=6*(U-a)*N.b+(3*U-4*a+1)*p.b+6*(-U+a)*T.b+(3*U-2*a)*A.b}static Red(){return new M(1,0,0)}static Green(){return new M(0,1,0)}static Blue(){return new M(0,0,1)}static Black(){return new M(0,0,0)}static get BlackReadOnly(){return M._BlackReadOnly}static White(){return new M(1,1,1)}static Purple(){return new M(.5,0,.5)}static Magenta(){return new M(1,0,1)}static Yellow(){return new M(1,1,0)}static Gray(){return new M(.5,.5,.5)}static Teal(){return new M(0,1,1)}static Random(){return new M(Math.random(),Math.random(),Math.random())}}M._V8PerformanceHack=new M(.5,.5,.5),M._BlackReadOnly=M.Black(),Object.defineProperties(M.prototype,{dimension:{value:[3]},rank:{value:1}});class b{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=N,this.g=p,this.b=T,this.a=A}UX(){return[this.r,this.g,this.b,this.a]}toArray(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[p]=this.r,N[p+1]=this.g,N[p+2]=this.b,N[p+3]=this.a,this}IT(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=N[p],this.g=N[p+1],this.b=N[p+2],this.a=N[p+3],this}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b&&this.a===N.a}add(N){return new b(this.r+N.r,this.g+N.g,this.b+N.b,this.a+N.a)}addToRef(N,p){return p.r=this.r+N.r,p.g=this.g+N.g,p.b=this.b+N.b,p.a=this.a+N.a,p}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this.a+=N.a,this}addInPlaceFromFloats(N,p,T,A){return this.r+=N,this.g+=p,this.b+=T,this.a+=A,this}Ip(N){return new b(this.r-N.r,this.g-N.g,this.b-N.b,this.a-N.a)}subtractToRef(N,p){return p.r=this.r-N.r,p.g=this.g-N.g,p.b=this.b-N.b,p.a=this.a-N.a,p}iM(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this.a-=N.a,this}subtractFromFloats(N,p,T,A){return new b(this.r-N,this.g-p,this.b-T,this.a-A)}subtractFromFloatsToRef(N,p,T,A,a){return a.r=this.r-N,a.g=this.g-p,a.b=this.b-T,a.a=this.a-A,a}scale(N){return new b(this.r*N,this.g*N,this.b*N,this.a*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this.a*=N,this}scaleToRef(N,p){return p.r=this.r*N,p.g=this.g*N,p.b=this.b*N,p.a=this.a*N,p}scaleAndAddToRef(N,p){return p.r+=this.r*N,p.g+=this.g*N,p.b+=this.b*N,p.a+=this.a*N,p}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,U.Clamp)(this.r,N,p),T.g=(0,U.Clamp)(this.g,N,p),T.b=(0,U.Clamp)(this.b,N,p),T.a=(0,U.Clamp)(this.a,N,p),T}multiply(N){return new b(this.r*N.r,this.g*N.g,this.b*N.b,this.a*N.a)}multiplyToRef(N,p){return p.r=this.r*N.r,p.g=this.g*N.g,p.b=this.b*N.b,p.a=this.a*N.a,p}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this.a*=N.a,this}multiplyByFloats(N,p,T,A){return new b(this.r*N,this.g*p,this.b*T,this.a*A)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,p){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.r=Math.min(this.r,N.r),this.g=Math.min(this.g,N.g),this.b=Math.min(this.b,N.b),this.a=Math.min(this.a,N.a),this}maximizeInPlace(N){return this.r=Math.max(this.r,N.r),this.g=Math.max(this.g,N.g),this.b=Math.max(this.b,N.b),this.a=Math.max(this.a,N.a),this}minimizeInPlaceFromFloats(N,p,T,A){return this.r=Math.min(N,this.r),this.g=Math.min(p,this.g),this.b=Math.min(T,this.b),this.a=Math.min(A,this.a),this}maximizeInPlaceFromFloats(N,p,T,A){return this.r=Math.max(N,this.r),this.g=Math.max(p,this.g),this.b=Math.max(T,this.b),this.a=Math.max(A,this.a),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.b;return(0,U.WithinEpsilon)(this.r,N.r,p)&&(0,U.WithinEpsilon)(this.g,N.g,p)&&(0,U.WithinEpsilon)(this.b,N.b,p)&&(0,U.WithinEpsilon)(this.a,N.a,p)}equalsToFloats(N,p,T,A){return this.r===N&&this.g===p&&this.b===T&&this.a===A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"LX"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N=397*N^255*this.a,N}clone(){return(new b).A(this)}A(N){return this.r=N.r,this.g=N.g,this.b=N.b,this.a=N.a,this}kX(N,p,T,A){return this.r=N,this.g=p,this.b=T,this.a=A,this}set(N,p,T,A){return this.kX(N,p,T,A)}IX(N){return this.r=this.g=this.b=this.a=N,this}toHexString(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=Math.round(255*this.r),T=Math.round(255*this.g),A=Math.round(255*this.b);if(N)return"#"+(0,U.ToHex)(p)+(0,U.ToHex)(T)+(0,U.ToHex)(A);const a=Math.round(255*this.a);return"#"+(0,U.ToHex)(p)+(0,U.ToHex)(T)+(0,U.ToHex)(A)+(0,U.ToHex)(a)}fromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255,9===N.length&&(this.a=parseInt(N.substring(7,9),16)/255)),this}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new b;return this.toLinearSpaceToRef(p,N),p}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=y(this.r),N.g=y(this.g),N.b=y(this.b)):(N.r=X(this.r),N.g=X(this.g),N.b=X(this.b)),N.a=this.a,this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const p=new b;return this.toGammaSpaceToRef(p,N),p}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=H(this.r),N.g=H(this.g),N.b=H(this.b)):(N.r=e(this.r),N.g=e(this.g),N.b=e(this.b)),N.a=this.a,this}static FromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length?new b(0,0,0,0):new b(0,0,0,1).fromHexString(N)}static Lerp(N,p,T){return b.LerpToRef(N,p,T,new b)}static LerpToRef(N,p,T,A){return A.r=N.r+(p.r-N.r)*T,A.g=N.g+(p.g-N.g)*T,A.b=N.b+(p.b-N.b)*T,A.a=N.a+(p.a-N.a)*T,A}static Hermite(N,p,T,A,a){const C=a*a,U=a*C,X=2*U-3*C+1,y=-2*U+3*C,e=U-2*C+a,H=U-C,M=N.r*X+T.r*y+p.r*e+A.r*H,l=N.g*X+T.g*y+p.g*e+A.g*H,k=N.b*X+T.b*y+p.b*e+A.b*H,x=N.a*X+T.a*y+p.a*e+A.a*H;return new b(M,l,k,x)}static Hermite1stDerivative(N,p,T,A,a){const C=new b;return this.Hermite1stDerivativeToRef(N,p,T,A,a,C),C}static Hermite1stDerivativeToRef(N,p,T,A,a,C){const U=a*a;C.r=6*(U-a)*N.r+(3*U-4*a+1)*p.r+6*(-U+a)*T.r+(3*U-2*a)*A.r,C.g=6*(U-a)*N.g+(3*U-4*a+1)*p.g+6*(-U+a)*T.g+(3*U-2*a)*A.g,C.b=6*(U-a)*N.b+(3*U-4*a+1)*p.b+6*(-U+a)*T.b+(3*U-2*a)*A.b,C.a=6*(U-a)*N.a+(3*U-4*a+1)*p.a+6*(-U+a)*T.a+(3*U-2*a)*A.a}static FromColor3(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new b(N.r,N.g,N.b,p)}static gp(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new b(N[p],N[p+1],N[p+2],N[p+3])}static FromArrayToRef(N){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=N[p],T.g=N[p+1],T.b=N[p+2],T.a=N[p+3]}static FromInts(N,p,T,A){return new b(N/255,p/255,T/255,A/255)}static CheckColors4(N,p){if(N.length===3*p){const p=[];for(let T=0;T<N.length;T+=3){const A=T/3*4;p[A]=N[T],p[A+1]=N[T+1],p[A+2]=N[T+2],p[A+3]=1}return p}return N}}b._V8PerformanceHack=new b(.5,.5,.5,.5),Object.defineProperties(b.prototype,{dimension:{value:[4]},rank:{value:1}});class l{}l.wp=(0,A.e)(3,M.Black),l.LX=(0,A.e)(3,(()=>new b(0,0,0,0))),(0,a.d)("BABYLON.Color3",M),(0,a.d)("BABYLON.Color4",b)}}]);