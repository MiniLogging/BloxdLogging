"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[17],{12426:(N,U,V)=>{V.r(U),V.d(U,{rU:()=>p,Yi:()=>k,TmpColors:()=>B});var A=V(12392),t=V(12344),n=V(12389),q=V(12395);function i(N){return Math.pow(N,n.n)}function z(N){return N<=.04045?.0773993808*N:Math.pow(.947867299*(N+.055),2.4)}function S(N){return Math.pow(N,n.j)}function E(N){return N<=.0031308?12.92*N:1.055*Math.pow(N,.41666)-.055}class p{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=N,this.g=U,this.b=V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"rU"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N}toArray(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[U]=this.r,N[U+1]=this.g,N[U+2]=this.b,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return p.FromArrayToRef(N,U,this),this}toColor4(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new k(this.r,this.g,this.b,N)}pi(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(N){return new p(this.r*N.r,this.g*N.g,this.b*N.b)}multiplyToRef(N,U){return U.r=this.r*N.r,U.g=this.g*N.g,U.b=this.b*N.b,U}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this}multiplyByFloats(N,U,V){return new p(this.r*N,this.g*U,this.b*V)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,U){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.minimizeInPlaceFromFloats(N.r,N.g,N.b)}maximizeInPlace(N){return this.maximizeInPlaceFromFloats(N.r,N.g,N.b)}minimizeInPlaceFromFloats(N,U,V){return this.r=Math.min(N,this.r),this.g=Math.min(U,this.g),this.b=Math.min(V,this.b),this}maximizeInPlaceFromFloats(N,U,V){return this.r=Math.max(N,this.r),this.g=Math.max(U,this.g),this.b=Math.max(V,this.b),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b}equalsFloats(N,U,V){return this.equalsToFloats(N,U,V)}equalsToFloats(N,U,V){return this.r===N&&this.g===U&&this.b===V}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.d;return(0,q.WithinEpsilon)(this.r,N.r,U)&&(0,q.WithinEpsilon)(this.g,N.g,U)&&(0,q.WithinEpsilon)(this.b,N.b,U)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}scale(N){return new p(this.r*N,this.g*N,this.b*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this}scaleToRef(N,U){return U.r=this.r*N,U.g=this.g*N,U.b=this.b*N,U}scaleAndAddToRef(N,U){return U.r+=this.r*N,U.g+=this.g*N,U.b+=this.b*N,U}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,q.Clamp)(this.r,N,U),V.g=(0,q.Clamp)(this.g,N,U),V.b=(0,q.Clamp)(this.b,N,U),V}add(N){return new p(this.r+N.r,this.g+N.g,this.b+N.b)}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this}addInPlaceFromFloats(N,U,V){return this.r+=N,this.g+=U,this.b+=V,this}addToRef(N,U){return U.r=this.r+N.r,U.g=this.g+N.g,U.b=this.b+N.b,U}xU(N){return new p(this.r-N.r,this.g-N.g,this.b-N.b)}subtractToRef(N,U){return U.r=this.r-N.r,U.g=this.g-N.g,U.b=this.b-N.b,U}Vp(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this}subtractFromFloats(N,U,V){return new p(this.r-N,this.g-U,this.b-V)}subtractFromFloatsToRef(N,U,V,A){return A.r=this.r-N,A.g=this.g-U,A.b=this.b-V,A}clone(){return new p(this.r,this.g,this.b)}A(N){return this.r=N.r,this.g=N.g,this.b=N.b,this}hi(N,U,V){return this.r=N,this.g=U,this.b=V,this}set(N,U,V){return this.hi(N,U,V)}Hi(N){return this.r=this.g=this.b=N,this}toHexString(){const N=Math.round(255*this.r),U=Math.round(255*this.g),V=Math.round(255*this.b);return"#"+(0,q.ToHex)(N)+(0,q.ToHex)(U)+(0,q.ToHex)(V)}fromHexString(N){return"#"!==N.substring(0,1)||7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new p)}toHSVToRef(N){const U=this.r,V=this.g,A=this.b,t=Math.max(U,V,A),n=Math.min(U,V,A);let q=0,i=0;const z=t,S=t-n;return 0!==t&&(i=S/t),t!=n&&(t==U?(q=(V-A)/S,V<A&&(q+=6)):t==V?q=(A-U)/S+2:t==A&&(q=(U-V)/S+4),q*=60),N.r=q,N.g=i,N.b=z,N}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new p;return this.toLinearSpaceToRef(U,N),U}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=z(this.r),N.g=z(this.g),N.b=z(this.b)):(N.r=i(this.r),N.g=i(this.g),N.b=i(this.b)),this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new p;return this.toGammaSpaceToRef(U,N),U}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=E(this.r),N.g=E(this.g),N.b=E(this.b)):(N.r=S(this.r),N.g=S(this.g),N.b=S(this.b)),this}static HSVtoRGBToRef(N,U,V,A){const t=V*U,n=N/60,q=t*(1-Math.abs(n%2-1));let i=0,z=0,S=0;n>=0&&n<=1?(i=t,z=q):n>=1&&n<=2?(i=q,z=t):n>=2&&n<=3?(z=t,S=q):n>=3&&n<=4?(z=q,S=t):n>=4&&n<=5?(i=q,S=t):n>=5&&n<=6&&(i=t,S=q);const E=V-t;return A.r=i+E,A.g=z+E,A.b=S+E,A}static FromHSV(N,U,V){const A=new p(0,0,0);return p.HSVtoRGBToRef(N,U,V,A),A}static FromHexString(N){return new p(0,0,0).fromHexString(N)}static vU(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new p(N[U],N[U+1],N[U+2])}static FromArrayToRef(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=N[U],V.g=N[U+1],V.b=N[U+2]}static FromInts(N,U,V){return new p(N/255,U/255,V/255)}static Lerp(N,U,V){const A=new p(0,0,0);return p.LerpToRef(N,U,V,A),A}static LerpToRef(N,U,V,A){A.r=N.r+(U.r-N.r)*V,A.g=N.g+(U.g-N.g)*V,A.b=N.b+(U.b-N.b)*V}static Hermite(N,U,V,A,t){const n=t*t,q=t*n,i=2*q-3*n+1,z=-2*q+3*n,S=q-2*n+t,E=q-n,k=N.r*i+V.r*z+U.r*S+A.r*E,B=N.g*i+V.g*z+U.g*S+A.g*E,C=N.b*i+V.b*z+U.b*S+A.b*E;return new p(k,B,C)}static Hermite1stDerivative(N,U,V,A,t){const n=p.Black();return this.Hermite1stDerivativeToRef(N,U,V,A,t,n),n}static Hermite1stDerivativeToRef(N,U,V,A,t,n){const q=t*t;n.r=6*(q-t)*N.r+(3*q-4*t+1)*U.r+6*(-q+t)*V.r+(3*q-2*t)*A.r,n.g=6*(q-t)*N.g+(3*q-4*t+1)*U.g+6*(-q+t)*V.g+(3*q-2*t)*A.g,n.b=6*(q-t)*N.b+(3*q-4*t+1)*U.b+6*(-q+t)*V.b+(3*q-2*t)*A.b}static Red(){return new p(1,0,0)}static Green(){return new p(0,1,0)}static Blue(){return new p(0,0,1)}static Black(){return new p(0,0,0)}static get BlackReadOnly(){return p._BlackReadOnly}static White(){return new p(1,1,1)}static Purple(){return new p(.5,0,.5)}static Magenta(){return new p(1,0,1)}static Yellow(){return new p(1,1,0)}static Gray(){return new p(.5,.5,.5)}static Teal(){return new p(0,1,1)}static Random(){return new p(Math.random(),Math.random(),Math.random())}}p._V8PerformanceHack=new p(.5,.5,.5),p._BlackReadOnly=p.Black(),Object.defineProperties(p.prototype,{dimension:{value:[3]},rank:{value:1}});class k{constructor(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=N,this.g=U,this.b=V,this.a=A}pi(){return[this.r,this.g,this.b,this.a]}toArray(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return N[U]=this.r,N[U+1]=this.g,N[U+2]=this.b,N[U+3]=this.a,this}BV(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=N[U],this.g=N[U+1],this.b=N[U+2],this.a=N[U+3],this}equals(N){return N&&this.r===N.r&&this.g===N.g&&this.b===N.b&&this.a===N.a}add(N){return new k(this.r+N.r,this.g+N.g,this.b+N.b,this.a+N.a)}addToRef(N,U){return U.r=this.r+N.r,U.g=this.g+N.g,U.b=this.b+N.b,U.a=this.a+N.a,U}addInPlace(N){return this.r+=N.r,this.g+=N.g,this.b+=N.b,this.a+=N.a,this}addInPlaceFromFloats(N,U,V,A){return this.r+=N,this.g+=U,this.b+=V,this.a+=A,this}xU(N){return new k(this.r-N.r,this.g-N.g,this.b-N.b,this.a-N.a)}subtractToRef(N,U){return U.r=this.r-N.r,U.g=this.g-N.g,U.b=this.b-N.b,U.a=this.a-N.a,U}Vp(N){return this.r-=N.r,this.g-=N.g,this.b-=N.b,this.a-=N.a,this}subtractFromFloats(N,U,V,A){return new k(this.r-N,this.g-U,this.b-V,this.a-A)}subtractFromFloatsToRef(N,U,V,A,t){return t.r=this.r-N,t.g=this.g-U,t.b=this.b-V,t.a=this.a-A,t}scale(N){return new k(this.r*N,this.g*N,this.b*N,this.a*N)}scaleInPlace(N){return this.r*=N,this.g*=N,this.b*=N,this.a*=N,this}scaleToRef(N,U){return U.r=this.r*N,U.g=this.g*N,U.b=this.b*N,U.a=this.a*N,U}scaleAndAddToRef(N,U){return U.r+=this.r*N,U.g+=this.g*N,U.b+=this.b*N,U.a+=this.a*N,U}clampToRef(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0;return V.r=(0,q.Clamp)(this.r,N,U),V.g=(0,q.Clamp)(this.g,N,U),V.b=(0,q.Clamp)(this.b,N,U),V.a=(0,q.Clamp)(this.a,N,U),V}multiply(N){return new k(this.r*N.r,this.g*N.g,this.b*N.b,this.a*N.a)}multiplyToRef(N,U){return U.r=this.r*N.r,U.g=this.g*N.g,U.b=this.b*N.b,U.a=this.a*N.a,U}multiplyInPlace(N){return this.r*=N.r,this.g*=N.g,this.b*=N.b,this.a*=N.a,this}multiplyByFloats(N,U,V,A){return new k(this.r*N,this.g*U,this.b*V,this.a*A)}divide(N){throw new ReferenceError("Can not divide a color")}divideToRef(N,U){throw new ReferenceError("Can not divide a color")}divideInPlace(N){throw new ReferenceError("Can not divide a color")}minimizeInPlace(N){return this.r=Math.min(this.r,N.r),this.g=Math.min(this.g,N.g),this.b=Math.min(this.b,N.b),this.a=Math.min(this.a,N.a),this}maximizeInPlace(N){return this.r=Math.max(this.r,N.r),this.g=Math.max(this.g,N.g),this.b=Math.max(this.b,N.b),this.a=Math.max(this.a,N.a),this}minimizeInPlaceFromFloats(N,U,V,A){return this.r=Math.min(N,this.r),this.g=Math.min(U,this.g),this.b=Math.min(V,this.b),this.a=Math.min(A,this.a),this}maximizeInPlaceFromFloats(N,U,V,A){return this.r=Math.max(N,this.r),this.g=Math.max(U,this.g),this.b=Math.max(V,this.b),this.a=Math.max(A,this.a),this}floorToRef(N){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(N){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(N){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.d;return(0,q.WithinEpsilon)(this.r,N.r,U)&&(0,q.WithinEpsilon)(this.g,N.g,U)&&(0,q.WithinEpsilon)(this.b,N.b,U)&&(0,q.WithinEpsilon)(this.a,N.a,U)}equalsToFloats(N,U,V,A){return this.r===N&&this.g===U&&this.b===V&&this.a===A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Yi"}getHashCode(){let N=255*this.r|0;return N=397*N^255*this.g,N=397*N^255*this.b,N=397*N^255*this.a,N}clone(){return(new k).A(this)}A(N){return this.r=N.r,this.g=N.g,this.b=N.b,this.a=N.a,this}hi(N,U,V,A){return this.r=N,this.g=U,this.b=V,this.a=A,this}set(N,U,V,A){return this.hi(N,U,V,A)}Hi(N){return this.r=this.g=this.b=this.a=N,this}toHexString(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=Math.round(255*this.r),V=Math.round(255*this.g),A=Math.round(255*this.b);if(N)return"#"+(0,q.ToHex)(U)+(0,q.ToHex)(V)+(0,q.ToHex)(A);const t=Math.round(255*this.a);return"#"+(0,q.ToHex)(U)+(0,q.ToHex)(V)+(0,q.ToHex)(A)+(0,q.ToHex)(t)}fromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length||(this.r=parseInt(N.substring(1,3),16)/255,this.g=parseInt(N.substring(3,5),16)/255,this.b=parseInt(N.substring(5,7),16)/255,9===N.length&&(this.a=parseInt(N.substring(7,9),16)/255)),this}toLinearSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new k;return this.toLinearSpaceToRef(U,N),U}toLinearSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=z(this.r),N.g=z(this.g),N.b=z(this.b)):(N.r=i(this.r),N.g=i(this.g),N.b=i(this.b)),N.a=this.a,this}toGammaSpace(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new k;return this.toGammaSpaceToRef(U,N),U}toGammaSpaceToRef(N){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(N.r=E(this.r),N.g=E(this.g),N.b=E(this.b)):(N.r=S(this.r),N.g=S(this.g),N.b=S(this.b)),N.a=this.a,this}static FromHexString(N){return"#"!==N.substring(0,1)||9!==N.length&&7!==N.length?new k(0,0,0,0):new k(0,0,0,1).fromHexString(N)}static Lerp(N,U,V){return k.LerpToRef(N,U,V,new k)}static LerpToRef(N,U,V,A){return A.r=N.r+(U.r-N.r)*V,A.g=N.g+(U.g-N.g)*V,A.b=N.b+(U.b-N.b)*V,A.a=N.a+(U.a-N.a)*V,A}static Hermite(N,U,V,A,t){const n=t*t,q=t*n,i=2*q-3*n+1,z=-2*q+3*n,S=q-2*n+t,E=q-n,p=N.r*i+V.r*z+U.r*S+A.r*E,B=N.g*i+V.g*z+U.g*S+A.g*E,C=N.b*i+V.b*z+U.b*S+A.b*E,x=N.a*i+V.a*z+U.a*S+A.a*E;return new k(p,B,C,x)}static Hermite1stDerivative(N,U,V,A,t){const n=new k;return this.Hermite1stDerivativeToRef(N,U,V,A,t,n),n}static Hermite1stDerivativeToRef(N,U,V,A,t,n){const q=t*t;n.r=6*(q-t)*N.r+(3*q-4*t+1)*U.r+6*(-q+t)*V.r+(3*q-2*t)*A.r,n.g=6*(q-t)*N.g+(3*q-4*t+1)*U.g+6*(-q+t)*V.g+(3*q-2*t)*A.g,n.b=6*(q-t)*N.b+(3*q-4*t+1)*U.b+6*(-q+t)*V.b+(3*q-2*t)*A.b,n.a=6*(q-t)*N.a+(3*q-4*t+1)*U.a+6*(-q+t)*V.a+(3*q-2*t)*A.a}static FromColor3(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k(N.r,N.g,N.b,U)}static vU(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(N[U],N[U+1],N[U+2],N[U+3])}static FromArrayToRef(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2?arguments[2]:void 0;V.r=N[U],V.g=N[U+1],V.b=N[U+2],V.a=N[U+3]}static FromInts(N,U,V,A){return new k(N/255,U/255,V/255,A/255)}static CheckColors4(N,U){if(N.length===3*U){const U=[];for(let V=0;V<N.length;V+=3){const A=V/3*4;U[A]=N[V],U[A+1]=N[V+1],U[A+2]=N[V+2],U[A+3]=1}return U}return N}}k._V8PerformanceHack=new k(.5,.5,.5,.5),Object.defineProperties(k.prototype,{dimension:{value:[4]},rank:{value:1}});class B{}B.rU=(0,A.b)(3,p.Black),B.Yi=(0,A.b)(3,(()=>new k(0,0,0,0))),(0,t.e)("BABYLON.Color3",p),(0,t.e)("BABYLON.Color4",k)}}]);