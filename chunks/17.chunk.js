"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[17],{12456:(P,a,R)=>{R.r(a),R.d(a,{Wa:()=>l,tj:()=>V,TmpColors:()=>f});var S=R(12423),A=R(12376),Z=R(12418),p=R(12430);function j(P){return Math.pow(P,Z.m)}function U(P){return P<=.04045?.0773993808*P:Math.pow(.947867299*(P+.055),2.4)}function Q(P){return Math.pow(P,Z.i)}function h(P){return P<=.0031308?12.92*P:1.055*Math.pow(P,.41666)-.055}class l{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=P,this.g=a,this.b=R}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Wa"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P}toArray(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[a]=this.r,P[a+1]=this.g,P[a+2]=this.b,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l.FromArrayToRef(P,a,this),this}toColor4(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new V(this.r,this.g,this.b,P)}pj(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(P){return new l(this.r*P.r,this.g*P.g,this.b*P.b)}multiplyToRef(P,a){return a.r=this.r*P.r,a.g=this.g*P.g,a.b=this.b*P.b,a}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this}multiplyByFloats(P,a,R){return new l(this.r*P,this.g*a,this.b*R)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,a){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.r,P.g,P.b)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.r,P.g,P.b)}minimizeInPlaceFromFloats(P,a,R){return this.r=Math.min(P,this.r),this.g=Math.min(a,this.g),this.b=Math.min(R,this.b),this}maximizeInPlaceFromFloats(P,a,R){return this.r=Math.max(P,this.r),this.g=Math.max(a,this.g),this.b=Math.max(R,this.b),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b}equalsFloats(P,a,R){return this.equalsToFloats(P,a,R)}equalsToFloats(P,a,R){return this.r===P&&this.g===a&&this.b===R}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.c;return(0,p.WithinEpsilon)(this.r,P.r,a)&&(0,p.WithinEpsilon)(this.g,P.g,a)&&(0,p.WithinEpsilon)(this.b,P.b,a)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}scale(P){return new l(this.r*P,this.g*P,this.b*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this}scaleToRef(P,a){return a.r=this.r*P,a.g=this.g*P,a.b=this.b*P,a}scaleAndAddToRef(P,a){return a.r+=this.r*P,a.g+=this.g*P,a.b+=this.b*P,a}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,R=arguments.length>2?arguments[2]:void 0;return R.r=(0,p.Clamp)(this.r,P,a),R.g=(0,p.Clamp)(this.g,P,a),R.b=(0,p.Clamp)(this.b,P,a),R}add(P){return new l(this.r+P.r,this.g+P.g,this.b+P.b)}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this}addInPlaceFromFloats(P,a,R){return this.r+=P,this.g+=a,this.b+=R,this}addToRef(P,a){return a.r=this.r+P.r,a.g=this.g+P.g,a.b=this.b+P.b,a}qa(P){return new l(this.r-P.r,this.g-P.g,this.b-P.b)}subtractToRef(P,a){return a.r=this.r-P.r,a.g=this.g-P.g,a.b=this.b-P.b,a}Ul(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this}subtractFromFloats(P,a,R){return new l(this.r-P,this.g-a,this.b-R)}subtractFromFloatsToRef(P,a,R,S){return S.r=this.r-P,S.g=this.g-a,S.b=this.b-R,S}clone(){return new l(this.r,this.g,this.b)}A(P){return this.r=P.r,this.g=P.g,this.b=P.b,this}Oj(P,a,R){return this.r=P,this.g=a,this.b=R,this}set(P,a,R){return this.Oj(P,a,R)}yj(P){return this.r=this.g=this.b=P,this}toHexString(){const P=Math.round(255*this.r),a=Math.round(255*this.g),R=Math.round(255*this.b);return"#"+(0,p.ToHex)(P)+(0,p.ToHex)(a)+(0,p.ToHex)(R)}fromHexString(P){return"#"!==P.substring(0,1)||7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new l)}toHSVToRef(P){const a=this.r,R=this.g,S=this.b,A=Math.max(a,R,S),Z=Math.min(a,R,S);let p=0,j=0;const U=A,Q=A-Z;return 0!==A&&(j=Q/A),A!=Z&&(A==a?(p=(R-S)/Q,R<S&&(p+=6)):A==R?p=(S-a)/Q+2:A==S&&(p=(a-R)/Q+4),p*=60),P.r=p,P.g=j,P.b=U,P}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new l;return this.toLinearSpaceToRef(a,P),a}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=U(this.r),P.g=U(this.g),P.b=U(this.b)):(P.r=j(this.r),P.g=j(this.g),P.b=j(this.b)),this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new l;return this.toGammaSpaceToRef(a,P),a}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=h(this.r),P.g=h(this.g),P.b=h(this.b)):(P.r=Q(this.r),P.g=Q(this.g),P.b=Q(this.b)),this}static HSVtoRGBToRef(P,a,R,S){const A=R*a,Z=P/60,p=A*(1-Math.abs(Z%2-1));let j=0,U=0,Q=0;Z>=0&&Z<=1?(j=A,U=p):Z>=1&&Z<=2?(j=p,U=A):Z>=2&&Z<=3?(U=A,Q=p):Z>=3&&Z<=4?(U=p,Q=A):Z>=4&&Z<=5?(j=p,Q=A):Z>=5&&Z<=6&&(j=A,Q=p);const h=R-A;return S.r=j+h,S.g=U+h,S.b=Q+h,S}static FromHSV(P,a,R){const S=new l(0,0,0);return l.HSVtoRGBToRef(P,a,R,S),S}static FromHexString(P){return new l(0,0,0).fromHexString(P)}static ka(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new l(P[a],P[a+1],P[a+2])}static FromArrayToRef(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2?arguments[2]:void 0;R.r=P[a],R.g=P[a+1],R.b=P[a+2]}static FromInts(P,a,R){return new l(P/255,a/255,R/255)}static Lerp(P,a,R){const S=new l(0,0,0);return l.LerpToRef(P,a,R,S),S}static LerpToRef(P,a,R,S){S.r=P.r+(a.r-P.r)*R,S.g=P.g+(a.g-P.g)*R,S.b=P.b+(a.b-P.b)*R}static Hermite(P,a,R,S,A){const Z=A*A,p=A*Z,j=2*p-3*Z+1,U=-2*p+3*Z,Q=p-2*Z+A,h=p-Z,V=P.r*j+R.r*U+a.r*Q+S.r*h,f=P.g*j+R.g*U+a.g*Q+S.g*h,O=P.b*j+R.b*U+a.b*Q+S.b*h;return new l(V,f,O)}static Hermite1stDerivative(P,a,R,S,A){const Z=l.Black();return this.Hermite1stDerivativeToRef(P,a,R,S,A,Z),Z}static Hermite1stDerivativeToRef(P,a,R,S,A,Z){const p=A*A;Z.r=6*(p-A)*P.r+(3*p-4*A+1)*a.r+6*(-p+A)*R.r+(3*p-2*A)*S.r,Z.g=6*(p-A)*P.g+(3*p-4*A+1)*a.g+6*(-p+A)*R.g+(3*p-2*A)*S.g,Z.b=6*(p-A)*P.b+(3*p-4*A+1)*a.b+6*(-p+A)*R.b+(3*p-2*A)*S.b}static Red(){return new l(1,0,0)}static Green(){return new l(0,1,0)}static Blue(){return new l(0,0,1)}static Black(){return new l(0,0,0)}static get BlackReadOnly(){return l._BlackReadOnly}static White(){return new l(1,1,1)}static Purple(){return new l(.5,0,.5)}static Magenta(){return new l(1,0,1)}static Yellow(){return new l(1,1,0)}static Gray(){return new l(.5,.5,.5)}static Teal(){return new l(0,1,1)}static Random(){return new l(Math.random(),Math.random(),Math.random())}}l._V8PerformanceHack=new l(.5,.5,.5),l._BlackReadOnly=l.Black(),Object.defineProperties(l.prototype,{dimension:{value:[3]},rank:{value:1}});class V{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=P,this.g=a,this.b=R,this.a=S}pj(){return[this.r,this.g,this.b,this.a]}toArray(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[a]=this.r,P[a+1]=this.g,P[a+2]=this.b,P[a+3]=this.a,this}fR(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=P[a],this.g=P[a+1],this.b=P[a+2],this.a=P[a+3],this}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b&&this.a===P.a}add(P){return new V(this.r+P.r,this.g+P.g,this.b+P.b,this.a+P.a)}addToRef(P,a){return a.r=this.r+P.r,a.g=this.g+P.g,a.b=this.b+P.b,a.a=this.a+P.a,a}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this.a+=P.a,this}addInPlaceFromFloats(P,a,R,S){return this.r+=P,this.g+=a,this.b+=R,this.a+=S,this}qa(P){return new V(this.r-P.r,this.g-P.g,this.b-P.b,this.a-P.a)}subtractToRef(P,a){return a.r=this.r-P.r,a.g=this.g-P.g,a.b=this.b-P.b,a.a=this.a-P.a,a}Ul(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this.a-=P.a,this}subtractFromFloats(P,a,R,S){return new V(this.r-P,this.g-a,this.b-R,this.a-S)}subtractFromFloatsToRef(P,a,R,S,A){return A.r=this.r-P,A.g=this.g-a,A.b=this.b-R,A.a=this.a-S,A}scale(P){return new V(this.r*P,this.g*P,this.b*P,this.a*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this.a*=P,this}scaleToRef(P,a){return a.r=this.r*P,a.g=this.g*P,a.b=this.b*P,a.a=this.a*P,a}scaleAndAddToRef(P,a){return a.r+=this.r*P,a.g+=this.g*P,a.b+=this.b*P,a.a+=this.a*P,a}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,R=arguments.length>2?arguments[2]:void 0;return R.r=(0,p.Clamp)(this.r,P,a),R.g=(0,p.Clamp)(this.g,P,a),R.b=(0,p.Clamp)(this.b,P,a),R.a=(0,p.Clamp)(this.a,P,a),R}multiply(P){return new V(this.r*P.r,this.g*P.g,this.b*P.b,this.a*P.a)}multiplyToRef(P,a){return a.r=this.r*P.r,a.g=this.g*P.g,a.b=this.b*P.b,a.a=this.a*P.a,a}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this.a*=P.a,this}multiplyByFloats(P,a,R,S){return new V(this.r*P,this.g*a,this.b*R,this.a*S)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,a){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.r=Math.min(this.r,P.r),this.g=Math.min(this.g,P.g),this.b=Math.min(this.b,P.b),this.a=Math.min(this.a,P.a),this}maximizeInPlace(P){return this.r=Math.max(this.r,P.r),this.g=Math.max(this.g,P.g),this.b=Math.max(this.b,P.b),this.a=Math.max(this.a,P.a),this}minimizeInPlaceFromFloats(P,a,R,S){return this.r=Math.min(P,this.r),this.g=Math.min(a,this.g),this.b=Math.min(R,this.b),this.a=Math.min(S,this.a),this}maximizeInPlaceFromFloats(P,a,R,S){return this.r=Math.max(P,this.r),this.g=Math.max(a,this.g),this.b=Math.max(R,this.b),this.a=Math.max(S,this.a),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Z.c;return(0,p.WithinEpsilon)(this.r,P.r,a)&&(0,p.WithinEpsilon)(this.g,P.g,a)&&(0,p.WithinEpsilon)(this.b,P.b,a)&&(0,p.WithinEpsilon)(this.a,P.a,a)}equalsToFloats(P,a,R,S){return this.r===P&&this.g===a&&this.b===R&&this.a===S}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"tj"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P=397*P^255*this.a,P}clone(){return(new V).A(this)}A(P){return this.r=P.r,this.g=P.g,this.b=P.b,this.a=P.a,this}Oj(P,a,R,S){return this.r=P,this.g=a,this.b=R,this.a=S,this}set(P,a,R,S){return this.Oj(P,a,R,S)}yj(P){return this.r=this.g=this.b=this.a=P,this}toHexString(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=Math.round(255*this.r),R=Math.round(255*this.g),S=Math.round(255*this.b);if(P)return"#"+(0,p.ToHex)(a)+(0,p.ToHex)(R)+(0,p.ToHex)(S);const A=Math.round(255*this.a);return"#"+(0,p.ToHex)(a)+(0,p.ToHex)(R)+(0,p.ToHex)(S)+(0,p.ToHex)(A)}fromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255,9===P.length&&(this.a=parseInt(P.substring(7,9),16)/255)),this}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new V;return this.toLinearSpaceToRef(a,P),a}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=U(this.r),P.g=U(this.g),P.b=U(this.b)):(P.r=j(this.r),P.g=j(this.g),P.b=j(this.b)),P.a=this.a,this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new V;return this.toGammaSpaceToRef(a,P),a}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=h(this.r),P.g=h(this.g),P.b=h(this.b)):(P.r=Q(this.r),P.g=Q(this.g),P.b=Q(this.b)),P.a=this.a,this}static FromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length?new V(0,0,0,0):new V(0,0,0,1).fromHexString(P)}static Lerp(P,a,R){return V.LerpToRef(P,a,R,new V)}static LerpToRef(P,a,R,S){return S.r=P.r+(a.r-P.r)*R,S.g=P.g+(a.g-P.g)*R,S.b=P.b+(a.b-P.b)*R,S.a=P.a+(a.a-P.a)*R,S}static Hermite(P,a,R,S,A){const Z=A*A,p=A*Z,j=2*p-3*Z+1,U=-2*p+3*Z,Q=p-2*Z+A,h=p-Z,l=P.r*j+R.r*U+a.r*Q+S.r*h,f=P.g*j+R.g*U+a.g*Q+S.g*h,O=P.b*j+R.b*U+a.b*Q+S.b*h,q=P.a*j+R.a*U+a.a*Q+S.a*h;return new V(l,f,O,q)}static Hermite1stDerivative(P,a,R,S,A){const Z=new V;return this.Hermite1stDerivativeToRef(P,a,R,S,A,Z),Z}static Hermite1stDerivativeToRef(P,a,R,S,A,Z){const p=A*A;Z.r=6*(p-A)*P.r+(3*p-4*A+1)*a.r+6*(-p+A)*R.r+(3*p-2*A)*S.r,Z.g=6*(p-A)*P.g+(3*p-4*A+1)*a.g+6*(-p+A)*R.g+(3*p-2*A)*S.g,Z.b=6*(p-A)*P.b+(3*p-4*A+1)*a.b+6*(-p+A)*R.b+(3*p-2*A)*S.b,Z.a=6*(p-A)*P.a+(3*p-4*A+1)*a.a+6*(-p+A)*R.a+(3*p-2*A)*S.a}static FromColor3(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new V(P.r,P.g,P.b,a)}static ka(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new V(P[a],P[a+1],P[a+2],P[a+3])}static FromArrayToRef(P){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,R=arguments.length>2?arguments[2]:void 0;R.r=P[a],R.g=P[a+1],R.b=P[a+2],R.a=P[a+3]}static FromInts(P,a,R,S){return new V(P/255,a/255,R/255,S/255)}static CheckColors4(P,a){if(P.length===3*a){const a=[];for(let R=0;R<P.length;R+=3){const S=R/3*4;a[S]=P[R],a[S+1]=P[R+1],a[S+2]=P[R+2],a[S+3]=1}return a}return P}}V._V8PerformanceHack=new V(.5,.5,.5,.5),Object.defineProperties(V.prototype,{dimension:{value:[4]},rank:{value:1}});class f{}f.Wa=(0,S.e)(3,l.Black),f.tj=(0,S.e)(3,(()=>new V(0,0,0,0))),(0,A.d)("BABYLON.Color3",l),(0,A.d)("BABYLON.Color4",V)}}]);