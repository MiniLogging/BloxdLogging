"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[17],{12379:(H,u,J)=>{J.r(u),J.d(u,{ku:()=>G,Mg:()=>P,TmpColors:()=>mH});var O=J(12345),U=J(12304),h=J(12343),w=J(12349);function g(H){return Math.pow(H,h.n)}function B(H){return H<=.04045?.0773993808*H:Math.pow(.947867299*(H+.055),2.4)}function b(H){return Math.pow(H,h.k)}function d(H){return H<=.0031308?12.92*H:1.055*Math.pow(H,.41666)-.055}class G{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=H,this.g=u,this.b=J}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ku"}getHashCode(){let H=255*this.r|0;return H=397*H^255*this.g,H=397*H^255*this.b,H}toArray(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[u]=this.r,H[u+1]=this.g,H[u+2]=this.b,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return G.FromArrayToRef(H,u,this),this}toColor4(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new P(this.r,this.g,this.b,H)}Hg(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(H){return new G(this.r*H.r,this.g*H.g,this.b*H.b)}multiplyToRef(H,u){return u.r=this.r*H.r,u.g=this.g*H.g,u.b=this.b*H.b,u}multiplyInPlace(H){return this.r*=H.r,this.g*=H.g,this.b*=H.b,this}multiplyByFloats(H,u,J){return new G(this.r*H,this.g*u,this.b*J)}divide(H){throw new ReferenceError("Can not divide a color")}divideToRef(H,u){throw new ReferenceError("Can not divide a color")}divideInPlace(H){throw new ReferenceError("Can not divide a color")}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H.r,H.g,H.b)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H.r,H.g,H.b)}minimizeInPlaceFromFloats(H,u,J){return this.r=Math.min(H,this.r),this.g=Math.min(u,this.g),this.b=Math.min(J,this.b),this}maximizeInPlaceFromFloats(H,u,J){return this.r=Math.max(H,this.r),this.g=Math.max(u,this.g),this.b=Math.max(J,this.b),this}floorToRef(H){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(H){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(H){return H&&this.r===H.r&&this.g===H.g&&this.b===H.b}equalsFloats(H,u,J){return this.equalsToFloats(H,u,J)}equalsToFloats(H,u,J){return this.r===H&&this.g===u&&this.b===J}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return(0,w.WithinEpsilon)(this.r,H.r,u)&&(0,w.WithinEpsilon)(this.g,H.g,u)&&(0,w.WithinEpsilon)(this.b,H.b,u)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(H){throw new ReferenceError("Can not negate a color")}scale(H){return new G(this.r*H,this.g*H,this.b*H)}scaleInPlace(H){return this.r*=H,this.g*=H,this.b*=H,this}scaleToRef(H,u){return u.r=this.r*H,u.g=this.g*H,u.b=this.b*H,u}scaleAndAddToRef(H,u){return u.r+=this.r*H,u.g+=this.g*H,u.b+=this.b*H,u}clampToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,J=arguments.length>2?arguments[2]:void 0;return J.r=(0,w.Clamp)(this.r,H,u),J.g=(0,w.Clamp)(this.g,H,u),J.b=(0,w.Clamp)(this.b,H,u),J}add(H){return new G(this.r+H.r,this.g+H.g,this.b+H.b)}addInPlace(H){return this.r+=H.r,this.g+=H.g,this.b+=H.b,this}addInPlaceFromFloats(H,u,J){return this.r+=H,this.g+=u,this.b+=J,this}addToRef(H,u){return u.r=this.r+H.r,u.g=this.g+H.g,u.b=this.b+H.b,u}ru(H){return new G(this.r-H.r,this.g-H.g,this.b-H.b)}subtractToRef(H,u){return u.r=this.r-H.r,u.g=this.g-H.g,u.b=this.b-H.b,u}jP(H){return this.r-=H.r,this.g-=H.g,this.b-=H.b,this}subtractFromFloats(H,u,J){return new G(this.r-H,this.g-u,this.b-J)}subtractFromFloatsToRef(H,u,J,O){return O.r=this.r-H,O.g=this.g-u,O.b=this.b-J,O}clone(){return new G(this.r,this.g,this.b)}O(H){return this.r=H.r,this.g=H.g,this.b=H.b,this}kg(H,u,J){return this.r=H,this.g=u,this.b=J,this}set(H,u,J){return this.kg(H,u,J)}jg(H){return this.r=this.g=this.b=H,this}toHexString(){const H=Math.round(255*this.r),u=Math.round(255*this.g),J=Math.round(255*this.b);return"#"+(0,w.ToHex)(H)+(0,w.ToHex)(u)+(0,w.ToHex)(J)}fromHexString(H){return"#"!==H.substring(0,1)||7!==H.length||(this.r=parseInt(H.substring(1,3),16)/255,this.g=parseInt(H.substring(3,5),16)/255,this.b=parseInt(H.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new G)}toHSVToRef(H){const u=this.r,J=this.g,O=this.b,U=Math.max(u,J,O),h=Math.min(u,J,O);let w=0,g=0;const B=U,b=U-h;return 0!==U&&(g=b/U),U!=h&&(U==u?(w=(J-O)/b,J<O&&(w+=6)):U==J?w=(O-u)/b+2:U==O&&(w=(u-J)/b+4),w*=60),H.r=w,H.g=g,H.b=B,H}toLinearSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new G;return this.toLinearSpaceToRef(u,H),u}toLinearSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=B(this.r),H.g=B(this.g),H.b=B(this.b)):(H.r=g(this.r),H.g=g(this.g),H.b=g(this.b)),this}toGammaSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new G;return this.toGammaSpaceToRef(u,H),u}toGammaSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=d(this.r),H.g=d(this.g),H.b=d(this.b)):(H.r=b(this.r),H.g=b(this.g),H.b=b(this.b)),this}static HSVtoRGBToRef(H,u,J,O){const U=J*u,h=H/60,w=U*(1-Math.abs(h%2-1));let g=0,B=0,b=0;h>=0&&h<=1?(g=U,B=w):h>=1&&h<=2?(g=w,B=U):h>=2&&h<=3?(B=U,b=w):h>=3&&h<=4?(B=w,b=U):h>=4&&h<=5?(g=w,b=U):h>=5&&h<=6&&(g=U,b=w);const d=J-U;return O.r=g+d,O.g=B+d,O.b=b+d,O}static FromHSV(H,u,J){const O=new G(0,0,0);return G.HSVtoRGBToRef(H,u,J,O),O}static FromHexString(H){return new G(0,0,0).fromHexString(H)}static Cu(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(H[u],H[u+1],H[u+2])}static FromArrayToRef(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2?arguments[2]:void 0;J.r=H[u],J.g=H[u+1],J.b=H[u+2]}static FromInts(H,u,J){return new G(H/255,u/255,J/255)}static Lerp(H,u,J){const O=new G(0,0,0);return G.LerpToRef(H,u,J,O),O}static LerpToRef(H,u,J,O){O.r=H.r+(u.r-H.r)*J,O.g=H.g+(u.g-H.g)*J,O.b=H.b+(u.b-H.b)*J}static Hermite(H,u,J,O,U){const h=U*U,w=U*h,g=2*w-3*h+1,B=-2*w+3*h,b=w-2*h+U,d=w-h,P=H.r*g+J.r*B+u.r*b+O.r*d,mH=H.g*g+J.g*B+u.g*b+O.g*d,l=H.b*g+J.b*B+u.b*b+O.b*d;return new G(P,mH,l)}static Hermite1stDerivative(H,u,J,O,U){const h=G.Black();return this.Hermite1stDerivativeToRef(H,u,J,O,U,h),h}static Hermite1stDerivativeToRef(H,u,J,O,U,h){const w=U*U;h.r=6*(w-U)*H.r+(3*w-4*U+1)*u.r+6*(-w+U)*J.r+(3*w-2*U)*O.r,h.g=6*(w-U)*H.g+(3*w-4*U+1)*u.g+6*(-w+U)*J.g+(3*w-2*U)*O.g,h.b=6*(w-U)*H.b+(3*w-4*U+1)*u.b+6*(-w+U)*J.b+(3*w-2*U)*O.b}static Red(){return new G(1,0,0)}static Green(){return new G(0,1,0)}static Blue(){return new G(0,0,1)}static Black(){return new G(0,0,0)}static get BlackReadOnly(){return G._BlackReadOnly}static White(){return new G(1,1,1)}static Purple(){return new G(.5,0,.5)}static Magenta(){return new G(1,0,1)}static Yellow(){return new G(1,1,0)}static Gray(){return new G(.5,.5,.5)}static Teal(){return new G(0,1,1)}static Random(){return new G(Math.random(),Math.random(),Math.random())}}G._V8PerformanceHack=new G(.5,.5,.5),G._BlackReadOnly=G.Black(),Object.defineProperties(G.prototype,{dimension:{value:[3]},rank:{value:1}});class P{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=H,this.g=u,this.b=J,this.a=O}Hg(){return[this.r,this.g,this.b,this.a]}toArray(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[u]=this.r,H[u+1]=this.g,H[u+2]=this.b,H[u+3]=this.a,this}mO(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=H[u],this.g=H[u+1],this.b=H[u+2],this.a=H[u+3],this}equals(H){return H&&this.r===H.r&&this.g===H.g&&this.b===H.b&&this.a===H.a}add(H){return new P(this.r+H.r,this.g+H.g,this.b+H.b,this.a+H.a)}addToRef(H,u){return u.r=this.r+H.r,u.g=this.g+H.g,u.b=this.b+H.b,u.a=this.a+H.a,u}addInPlace(H){return this.r+=H.r,this.g+=H.g,this.b+=H.b,this.a+=H.a,this}addInPlaceFromFloats(H,u,J,O){return this.r+=H,this.g+=u,this.b+=J,this.a+=O,this}ru(H){return new P(this.r-H.r,this.g-H.g,this.b-H.b,this.a-H.a)}subtractToRef(H,u){return u.r=this.r-H.r,u.g=this.g-H.g,u.b=this.b-H.b,u.a=this.a-H.a,u}jP(H){return this.r-=H.r,this.g-=H.g,this.b-=H.b,this.a-=H.a,this}subtractFromFloats(H,u,J,O){return new P(this.r-H,this.g-u,this.b-J,this.a-O)}subtractFromFloatsToRef(H,u,J,O,U){return U.r=this.r-H,U.g=this.g-u,U.b=this.b-J,U.a=this.a-O,U}scale(H){return new P(this.r*H,this.g*H,this.b*H,this.a*H)}scaleInPlace(H){return this.r*=H,this.g*=H,this.b*=H,this.a*=H,this}scaleToRef(H,u){return u.r=this.r*H,u.g=this.g*H,u.b=this.b*H,u.a=this.a*H,u}scaleAndAddToRef(H,u){return u.r+=this.r*H,u.g+=this.g*H,u.b+=this.b*H,u.a+=this.a*H,u}clampToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,J=arguments.length>2?arguments[2]:void 0;return J.r=(0,w.Clamp)(this.r,H,u),J.g=(0,w.Clamp)(this.g,H,u),J.b=(0,w.Clamp)(this.b,H,u),J.a=(0,w.Clamp)(this.a,H,u),J}multiply(H){return new P(this.r*H.r,this.g*H.g,this.b*H.b,this.a*H.a)}multiplyToRef(H,u){return u.r=this.r*H.r,u.g=this.g*H.g,u.b=this.b*H.b,u.a=this.a*H.a,u}multiplyInPlace(H){return this.r*=H.r,this.g*=H.g,this.b*=H.b,this.a*=H.a,this}multiplyByFloats(H,u,J,O){return new P(this.r*H,this.g*u,this.b*J,this.a*O)}divide(H){throw new ReferenceError("Can not divide a color")}divideToRef(H,u){throw new ReferenceError("Can not divide a color")}divideInPlace(H){throw new ReferenceError("Can not divide a color")}minimizeInPlace(H){return this.r=Math.min(this.r,H.r),this.g=Math.min(this.g,H.g),this.b=Math.min(this.b,H.b),this.a=Math.min(this.a,H.a),this}maximizeInPlace(H){return this.r=Math.max(this.r,H.r),this.g=Math.max(this.g,H.g),this.b=Math.max(this.b,H.b),this.a=Math.max(this.a,H.a),this}minimizeInPlaceFromFloats(H,u,J,O){return this.r=Math.min(H,this.r),this.g=Math.min(u,this.g),this.b=Math.min(J,this.b),this.a=Math.min(O,this.a),this}maximizeInPlaceFromFloats(H,u,J,O){return this.r=Math.max(H,this.r),this.g=Math.max(u,this.g),this.b=Math.max(J,this.b),this.a=Math.max(O,this.a),this}floorToRef(H){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(H){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(H){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:h.d;return(0,w.WithinEpsilon)(this.r,H.r,u)&&(0,w.WithinEpsilon)(this.g,H.g,u)&&(0,w.WithinEpsilon)(this.b,H.b,u)&&(0,w.WithinEpsilon)(this.a,H.a,u)}equalsToFloats(H,u,J,O){return this.r===H&&this.g===u&&this.b===J&&this.a===O}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Mg"}getHashCode(){let H=255*this.r|0;return H=397*H^255*this.g,H=397*H^255*this.b,H=397*H^255*this.a,H}clone(){return(new P).O(this)}O(H){return this.r=H.r,this.g=H.g,this.b=H.b,this.a=H.a,this}kg(H,u,J,O){return this.r=H,this.g=u,this.b=J,this.a=O,this}set(H,u,J,O){return this.kg(H,u,J,O)}jg(H){return this.r=this.g=this.b=this.a=H,this}toHexString(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=Math.round(255*this.r),J=Math.round(255*this.g),O=Math.round(255*this.b);if(H)return"#"+(0,w.ToHex)(u)+(0,w.ToHex)(J)+(0,w.ToHex)(O);const U=Math.round(255*this.a);return"#"+(0,w.ToHex)(u)+(0,w.ToHex)(J)+(0,w.ToHex)(O)+(0,w.ToHex)(U)}fromHexString(H){return"#"!==H.substring(0,1)||9!==H.length&&7!==H.length||(this.r=parseInt(H.substring(1,3),16)/255,this.g=parseInt(H.substring(3,5),16)/255,this.b=parseInt(H.substring(5,7),16)/255,9===H.length&&(this.a=parseInt(H.substring(7,9),16)/255)),this}toLinearSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new P;return this.toLinearSpaceToRef(u,H),u}toLinearSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=B(this.r),H.g=B(this.g),H.b=B(this.b)):(H.r=g(this.r),H.g=g(this.g),H.b=g(this.b)),H.a=this.a,this}toGammaSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new P;return this.toGammaSpaceToRef(u,H),u}toGammaSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=d(this.r),H.g=d(this.g),H.b=d(this.b)):(H.r=b(this.r),H.g=b(this.g),H.b=b(this.b)),H.a=this.a,this}static FromHexString(H){return"#"!==H.substring(0,1)||9!==H.length&&7!==H.length?new P(0,0,0,0):new P(0,0,0,1).fromHexString(H)}static Lerp(H,u,J){return P.LerpToRef(H,u,J,new P)}static LerpToRef(H,u,J,O){return O.r=H.r+(u.r-H.r)*J,O.g=H.g+(u.g-H.g)*J,O.b=H.b+(u.b-H.b)*J,O.a=H.a+(u.a-H.a)*J,O}static Hermite(H,u,J,O,U){const h=U*U,w=U*h,g=2*w-3*h+1,B=-2*w+3*h,b=w-2*h+U,d=w-h,G=H.r*g+J.r*B+u.r*b+O.r*d,mH=H.g*g+J.g*B+u.g*b+O.g*d,l=H.b*g+J.b*B+u.b*b+O.b*d,r=H.a*g+J.a*B+u.a*b+O.a*d;return new P(G,mH,l,r)}static Hermite1stDerivative(H,u,J,O,U){const h=new P;return this.Hermite1stDerivativeToRef(H,u,J,O,U,h),h}static Hermite1stDerivativeToRef(H,u,J,O,U,h){const w=U*U;h.r=6*(w-U)*H.r+(3*w-4*U+1)*u.r+6*(-w+U)*J.r+(3*w-2*U)*O.r,h.g=6*(w-U)*H.g+(3*w-4*U+1)*u.g+6*(-w+U)*J.g+(3*w-2*U)*O.g,h.b=6*(w-U)*H.b+(3*w-4*U+1)*u.b+6*(-w+U)*J.b+(3*w-2*U)*O.b,h.a=6*(w-U)*H.a+(3*w-4*U+1)*u.a+6*(-w+U)*J.a+(3*w-2*U)*O.a}static FromColor3(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new P(H.r,H.g,H.b,u)}static Cu(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new P(H[u],H[u+1],H[u+2],H[u+3])}static FromArrayToRef(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2?arguments[2]:void 0;J.r=H[u],J.g=H[u+1],J.b=H[u+2],J.a=H[u+3]}static FromInts(H,u,J,O){return new P(H/255,u/255,J/255,O/255)}static CheckColors4(H,u){if(H.length===3*u){const u=[];for(let J=0;J<H.length;J+=3){const O=J/3*4;u[O]=H[J],u[O+1]=H[J+1],u[O+2]=H[J+2],u[O+3]=1}return u}return H}}P._V8PerformanceHack=new P(.5,.5,.5,.5),Object.defineProperties(P.prototype,{dimension:{value:[4]},rank:{value:1}});class mH{}mH.ku=(0,O.b)(3,G.Black),mH.Mg=(0,O.b)(3,(()=>new P(0,0,0,0))),(0,U.f)("BABYLON.Color3",G),(0,U.f)("BABYLON.Color4",P)}}]);