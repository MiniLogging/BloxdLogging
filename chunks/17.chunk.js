"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2534:(R,x,H)=>{H.r(x),H.d(x,{ReadExrDataAsync:()=>nR,_ExrTextureLoader:()=>VR});var k=H(493),c=H(681);const t=4,A=4,D=1,U=2,J=8,V=65536,n=V>>3,g=14,I=65537,i=1<<g,q=i-1,S=59,L=63,b=2+L-S;var C,F;!function(R){R[R.NO_COMPRESSION=0]="NO_COMPRESSION",R[R.RLE_COMPRESSION=1]="RLE_COMPRESSION",R[R.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",R[R.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",R[R.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",R[R.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(R){R[R.INCREASING_Y=0]="INCREASING_Y",R[R.DECREASING_Y=1]="DECREASING_Y"}(F||(F={}));const d=function(){const R=new ArrayBuffer(4),x=new Float32Array(R),H=new Uint32Array(R),k=new Uint32Array(512),c=new Uint32Array(512);for(let U=0;U<256;++U){const R=U-127;R<-27?(k[U]=0,k[256|U]=32768,c[U]=24,c[256|U]=24):R<-14?(k[U]=1024>>-R-14,k[256|U]=1024>>-R-14|32768,c[U]=-R-1,c[256|U]=-R-1):R<=15?(k[U]=R+15<<10,k[256|U]=R+15<<10|32768,c[U]=13,c[256|U]=13):R<128?(k[U]=31744,k[256|U]=64512,c[U]=24,c[256|U]=24):(k[U]=31744,k[256|U]=64512,c[U]=13,c[256|U]=13)}const t=new Uint32Array(2048),A=new Uint32Array(64),D=new Uint32Array(64);for(let U=1;U<1024;++U){let R=U<<13,x=0;for(;0===(8388608&R);)R<<=1,x-=8388608;R&=-8388609,x+=947912704,t[U]=R|x}for(let U=1024;U<2048;++U)t[U]=939524096+(U-1024<<13);for(let U=1;U<31;++U)A[U]=U<<23;A[31]=1199570944,A[32]=2147483648;for(let U=33;U<63;++U)A[U]=2147483648+(U-32<<23);A[63]=3347054592;for(let U=1;U<64;++U)32!==U&&(D[U]=1024);return{floatView:x,uint32View:H,baseTable:k,shiftTable:c,mantissaTable:t,exponentTable:A,offsetTable:D}}();function P(R,x){const H=new Uint8Array(R);let k=0;for(;0!=H[x.value+k];)k+=1;const c=(new TextDecoder).decode(H.slice(x.value,x.value+k));return x.value=x.value+k+1,c}function a(R,x){const H=R.getInt32(x.value,!0);return x.value+=t,H}function X(R,x){const H=R.getUint32(x.value,!0);return x.value+=t,H}function M(R,x){const H=R.getUint8(x.value);return x.value+=D,H}function B(R,x){const H=R.getUint16(x.value,!0);return x.value+=U,H}function o(R,x){const H=R[x.value];return x.value+=D,H}function Z(R,x){let H;return H="getBigInt64"in DataView.prototype?Number(R.getBigInt64(x.value,!0)):R.getUint32(x.value+4,!0)+Number(R.getUint32(x.value,!0)<<32),x.value+=J,H}function y(R,x){const H=R.getFloat32(x.value,!0);return x.value+=A,H}function s(R,x){return function(R){const x=(31744&R)>>10,H=1023&R;return(R>>15?-1:1)*(x?31===x?H?NaN:1/0:Math.pow(2,x-15)*(1+H/1024):H/1024*6103515625e-14)}(B(R,x))}function E(R,x){return function(R){if(Math.abs(R)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");R=(0,c.Clamp)(R,-65504,65504),d.floatView[0]=R;const x=d.uint32View[0],H=x>>23&511;return d.baseTable[H]+((8388607&x)>>d.shiftTable[H])}(y(R,x))}function w(R,x,H,k){switch(H){case"string":case"stringvector":case"iccProfile":return function(R,x,H){const k=(new TextDecoder).decode(new Uint8Array(R).slice(x.value,x.value+H));return x.value=x.value+H,k}(R.buffer,x,k);case"chlist":return function(R,x,H){const k=x.value,c=[];for(;x.value<k+H-1;){const H=P(R.buffer,x),k=a(R,x),t=M(R,x);x.value+=3;const A=a(R,x),D=a(R,x);c.push({name:H,pixelType:k,pLinear:t,xSampling:A,ySampling:D})}return x.value+=1,c}(R,x,k);case"chromaticities":return function(R,x){return{redX:y(R,x),redY:y(R,x),greenX:y(R,x),greenY:y(R,x),blueX:y(R,x),blueY:y(R,x),whiteX:y(R,x),whiteY:y(R,x)}}(R,x);case"compression":return function(R,x){return M(R,x)}(R,x);case"box2i":return function(R,x){return{xMin:a(R,x),yMin:a(R,x),xMax:a(R,x),yMax:a(R,x)}}(R,x);case"lineOrder":return function(R,x){const H=M(R,x);return F[H]}(R,x);case"float":return y(R,x);case"v2f":return function(R,x){return[y(R,x),y(R,x)]}(R,x);case"v3f":return function(R,x){return[y(R,x),y(R,x),y(R,x)]}(R,x);case"int":return a(R,x);case"rational":return function(R,x){return[a(R,x),X(R,x)]}(R,x);case"timecode":return function(R,x){return[X(R,x),X(R,x)]}(R,x);case"preview":return x.value+=k,"skipped";default:return void(x.value+=k)}}function h(R){for(let x=1;x<R.length;x++){const H=R[x-1]+R[x]-128;R[x]=H}}function f(R,x){let H=0,k=Math.floor((R.length+1)/2),c=0;const t=R.length-1;for(;!(c>t)&&(x[c++]=R[H++],!(c>t));)x[c++]=R[k++]}const N=20000630;function W(R,x){if(R.getUint32(0,!0)!=N)throw new Error("Incorrect OpenEXR format");const H=R.getUint8(4),c=R.getUint8(5),t={singleTile:!!(2&c),longName:!!(4&c),deepFormat:!!(8&c),multiPart:!!(16&c)};x.value=8;const A={};let D=!0;for(;D;){const H=P(R.buffer,x);if(H){const c=P(R.buffer,x),t=w(R,x,c,X(R,x));void 0===t?k.c.Warn(`Unknown header attribute type ${c}'.`):A[H]=t}else D=!1}if(0!=(-5&c))throw new Error("Unsupported file format");return{version:H,spec:t,...A}}const K=32768,Q=65535;function G(R,x,H,k,c){for(;H<R;)x=x<<8|o(k,c),H+=8;return{l:x>>(H-=R)&(1<<R)-1,c:x,lc:H}}function T(R,x,H,k){return{c:R=R<<8|o(H,k),lc:x+=8}}function v(R,x,H,k,c,t,A,D,U){if(R==x){if(k<8){const R=T(H,k,c,t);H=R.c,k=R.lc}let R=H>>(k-=8);if(R=new Uint8Array([R])[0],D.value+R>U)return null;const x=A[D.value-1];for(;R-- >0;)A[D.value++]=x}else{if(!(D.value<U))return null;A[D.value++]=R}return{c:H,lc:k}}const p=new Array(59);function r(R,x,H,k,c,t){const A=x;let D=0,U=0;for(;k<=c;k++){if(A.value-x.value>H)return;let J=G(6,D,U,R,A);const V=J.l;if(D=J.c,U=J.lc,t[k]=V,V==L){if(A.value-x.value>H)throw new Error("Error in HufUnpackEncTable");J=G(8,D,U,R,A);let V=J.l+b;if(D=J.c,U=J.lc,k+V>c+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)t[k++]=0;k--}else if(V>=S){let R=V-S+2;if(k+R>c+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)t[k++]=0;k--}}!function(R){for(let H=0;H<=58;++H)p[H]=0;for(let H=0;H<I;++H)p[R[H]]+=1;let x=0;for(let H=58;H>0;--H){const R=x+p[H]>>1;p[H]=x,x=R}for(let H=0;H<I;++H){const x=R[H];x>0&&(R[H]=x|p[x]++<<6)}}(t)}function z(R){return 63&R}function j(R){return R>>6}function m(R,x,H,k,c,t){const A=H.value,D=X(x,H),U=X(x,H);H.value+=4;const J=X(x,H);if(H.value+=4,D<0||D>=I||U<0||U>=I)throw new Error("Wrong HUF_ENCSIZE");const V=new Array(I),n=new Array(i);!function(R){for(let x=0;x<i;x++)R[x]={},R[x].len=0,R[x].lit=0,R[x].p=null}(n);if(r(R,H,k-(H.value-A),D,U,V),J>8*(k-(H.value-A)))throw new Error("Wrong hufUncompress");!function(R,x,H,k){for(;x<=H;x++){const H=j(R[x]),c=z(R[x]);if(H>>c)throw new Error("Invalid table entry");if(c>g){const R=k[H>>c-g];if(R.len)throw new Error("Invalid table entry");if(R.lit++,R.p){const x=R.p;R.p=new Array(R.lit);for(let H=0;H<R.lit-1;++H)R.p[H]=x[H]}else R.p=new Array(1);R.p[R.lit-1]=x}else if(c){let R=0;for(let t=1<<g-c;t>0;t--){const t=k[(H<<g-c)+R];if(t.len||t.p)throw new Error("Invalid table entry");t.len=c,t.lit=x,R++}}}}(V,D,U,n),function(R,x,H,k,c,t,A,D,U){let J=0,V=0;const n=A,I=Math.trunc(k.value+(c+7)/8);for(;k.value<I;){let c=T(J,V,H,k);for(J=c.c,V=c.lc;V>=g;){const A=x[J>>V-g&q];if(A.len){V-=A.len;const R=v(A.lit,t,J,V,H,k,D,U,n);R&&(J=R.c,V=R.lc)}else{if(!A.p)throw new Error("hufDecode issues");let x;for(x=0;x<A.lit;x++){const g=z(R[A.p[x]]);for(;V<g&&k.value<I;)c=T(J,V,H,k),J=c.c,V=c.lc;if(V>=g&&j(R[A.p[x]])==(J>>V-g&(1<<g)-1)){V-=g;const R=v(A.p[x],t,J,V,H,k,D,U,n);R&&(J=R.c,V=R.lc);break}}if(x==A.lit)throw new Error("HufDecode issues")}}}const i=8-c&7;for(J>>=i,V-=i;V>0;){const R=x[J<<g-V&q];if(!R.len)throw new Error("HufDecode issues");{V-=R.len;const x=v(R.lit,t,J,V,H,k,D,U,n);x&&(J=x.c,V=x.lc)}}}(V,n,R,H,J,U,t,c,{value:0})}function O(R){return 65535&R}function l(R){const x=O(R);return x>32767?x-65536:x}function e(R,x){const H=l(R),k=l(x),c=H+(1&k)+(k>>1);return{a:c,b:c-k}}function u(R,x){const H=O(R),k=O(x),c=H-(k>>1)&Q;return{a:k+c-K&Q,b:c}}function Y(R,x,H,k,c,t,A){const D=A<16384,U=H>c?c:H;let J,V,n=1;for(;n<=U;)n<<=1;for(n>>=1,J=n,n>>=1;n>=1;){V=0;const A=V+t*(c-J),U=t*n,g=t*J,I=k*n,i=k*J;let q,S,L,b;for(;V<=A;V+=g){let c=V;const t=V+k*(H-J);for(;c<=t;c+=i){const H=c+I,k=c+U,t=k+I;if(D){let A=e(R[c+x],R[k+x]);q=A.a,L=A.b,A=e(R[H+x],R[t+x]),S=A.a,b=A.b,A=e(q,S),R[c+x]=A.a,R[H+x]=A.b,A=e(L,b),R[k+x]=A.a,R[t+x]=A.b}else{let A=u(R[c+x],R[k+x]);q=A.a,L=A.b,A=u(R[H+x],R[t+x]),S=A.a,b=A.b,A=u(q,S),R[c+x]=A.a,R[H+x]=A.b,A=u(L,b),R[k+x]=A.a,R[t+x]=A.b}}if(H&n){const H=c+U;let k;k=D?e(R[c+x],R[H+x]):u(R[c+x],R[H+x]),q=k.a,R[H+x]=k.b,R[c+x]=q}}if(c&n){let c=V;const t=V+k*(H-J);for(;c<=t;c+=i){const H=c+I;let k;k=D?e(R[c+x],R[H+x]):u(R[c+x],R[H+x]),q=k.a,R[H+x]=k.b,R[c+x]=q}}J=n,n>>=1}return V}function RR(R){return new DataView(R.array.buffer,R.offset.value,R.size)}function xR(R){const x=R.viewer.buffer.slice(R.offset.value,R.offset.value+R.size),H=new Uint8Array(function(R){let x=R.byteLength;const H=[];let k=0;const c=new DataView(R);for(;x>0;){const R=c.getInt8(k++);if(R<0){const t=-R;x-=t+1;for(let R=0;R<t;R++)H.push(c.getUint8(k++))}else{const t=R;x-=2;const A=c.getUint8(k++);for(let R=0;R<t+1;R++)H.push(A)}}return H}(x)),k=new Uint8Array(H.length);return h(H),f(H,k),new DataView(k.buffer)}function HR(R){const x=R.array.slice(R.offset.value,R.offset.value+R.size),H=fflate.unzlibSync(x),k=new Uint8Array(H.length);return h(H),f(H,k),new DataView(k.buffer)}function kR(R){const x=R.array.slice(R.offset.value,R.offset.value+R.size),H=fflate.unzlibSync(x),k=R.lines*R.channels*R.width,c=1==R.type?new Uint16Array(k):new Uint32Array(k);let t=0,A=0;const D=new Array(4);for(let U=0;U<R.lines;U++)for(let x=0;x<R.channels;x++){let x=0;switch(R.type){case 1:D[0]=t,D[1]=D[0]+R.width,t=D[1]+R.width;for(let k=0;k<R.width;++k){x+=H[D[0]++]<<8|H[D[1]++],c[A]=x,A++}break;case 2:D[0]=t,D[1]=D[0]+R.width,D[2]=D[1]+R.width,t=D[2]+R.width;for(let k=0;k<R.width;++k){x+=H[D[0]++]<<24|H[D[1]++]<<16|H[D[2]++]<<8,c[A]=x,A++}}}return new DataView(c.buffer)}function cR(R){const x=R.viewer,H={value:R.offset.value},k=new Uint16Array(R.width*R.scanlineBlockSize*(R.channels*R.type)),c=new Uint8Array(n);let t=0;const A=new Array(R.channels);for(let U=0;U<R.channels;U++)A[U]={},A[U].start=t,A[U].end=A[U].start,A[U].nx=R.width,A[U].ny=R.lines,A[U].size=R.type,t+=A[U].nx*A[U].ny*A[U].size;const D=B(x,H),J=B(x,H);if(J>=n)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(D<=J)for(let U=0;U<J-D+1;U++)c[U+D]=M(x,H);const g=new Uint16Array(V),I=function(R,x){let H=0;for(let c=0;c<V;++c)(0==c||R[c>>3]&1<<(7&c))&&(x[H++]=c);const k=H-1;for(;H<V;)x[H++]=0;return k}(c,g),i=X(x,H);m(R.array,x,H,i,k,t);for(let U=0;U<R.channels;++U){const R=A[U];for(let x=0;x<A[U].size;++x)Y(k,R.start+x,R.nx,R.size,R.ny,R.nx*R.size,I)}!function(R,x,H){for(let k=0;k<H;++k)x[k]=R[x[k]]}(g,k,t);let q=0;const S=new Uint8Array(k.buffer.byteLength);for(let V=0;V<R.lines;V++)for(let x=0;x<R.channels;x++){const R=A[x],H=R.nx*R.size,c=new Uint8Array(k.buffer,R.end*U,H*U);S.set(c,q),q+=H*U,R.end+=H}return new DataView(S.buffer)}var tR,AR=H(485);!function(R){R[R.Float=0]="Float",R[R.HalfFloat=1]="HalfFloat"}(tR||(tR={}));class DR{}async function UR(R,x,H,k){const c={size:0,viewer:x,array:new Uint8Array(x.buffer),offset:H,width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,channels:R.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(R.compression){case C.NO_COMPRESSION:c.lines=1,c.uncompress=RR;break;case C.RLE_COMPRESSION:c.lines=1,c.uncompress=xR;break;case C.ZIPS_COMPRESSION:c.lines=1,c.uncompress=HR,await AR.e.LoadScriptAsync(DR.FFLATEUrl);break;case C.ZIP_COMPRESSION:c.lines=16,c.uncompress=HR,await AR.e.LoadScriptAsync(DR.FFLATEUrl);break;case C.PIZ_COMPRESSION:c.lines=32,c.uncompress=cR;break;case C.PXR24_COMPRESSION:c.lines=16,c.uncompress=kR,await AR.e.LoadScriptAsync(DR.FFLATEUrl);break;default:throw new Error(C[R.compression]+" is unsupported")}c.scanlineBlockSize=c.lines;const t={};for(const A of R.channels)switch(A.name){case"R":case"G":case"B":case"A":case"Y":t[A.name]=!0,c.type=A.pixelType}let D=!1;if(t.R&&t.G&&t.B&&t.A)c.outputChannels=4,c.decodeChannels={R:0,G:1,B:2,A:3};else if(t.R&&t.G&&t.B)D=!0,c.outputChannels=4,c.decodeChannels={R:0,G:1,B:2,A:3};else if(t.R&&t.G)c.outputChannels=2,c.decodeChannels={R:0,G:1};else if(t.R)c.outputChannels=1,c.decodeChannels={R:0};else{if(!t.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");c.outputChannels=1,c.decodeChannels={Y:0}}if(1===c.type)switch(k){case tR.Float:c.getter=s,c.inputSize=U;break;case tR.HalfFloat:c.getter=B,c.inputSize=U}else{if(2!==c.type)throw new Error("Unsupported pixelType "+c.type+" for "+R.compression);switch(k){case tR.Float:c.getter=y,c.inputSize=A;break;case tR.HalfFloat:c.getter=E,c.inputSize=A}}c.blockCount=c.height/c.scanlineBlockSize;for(let A=0;A<c.blockCount;A++)Z(x,H);const J=c.width*c.height*c.outputChannels;switch(k){case tR.Float:c.byteArray=new Float32Array(J),c.textureType=1,D&&c.byteArray.fill(1,0,J);break;case tR.HalfFloat:c.byteArray=new Uint16Array(J),c.textureType=2,D&&c.byteArray.fill(15360,0,J);break;default:throw new Error("Unsupported type: "+k)}let V=0;for(const A of R.channels)void 0!==c.decodeChannels[A.name]&&(c.channelLineOffsets[A.name]=V*c.width),V+=2*A.pixelType;return c.bytesPerLine=c.width*V,c.outLineWidth=c.width*c.outputChannels,"INCREASING_Y"===R.lineOrder?c.scanOrder=R=>R:c.scanOrder=R=>c.height-1-R,4==c.outputChannels?(c.format=5,c.linearSpace=!0):(c.format=6,c.linearSpace=!1),c}function JR(R,x,H,k){const c={value:0};for(let t=0;t<R.height/R.scanlineBlockSize;t++){const A=a(H,k)-x.dataWindow.yMin;R.size=X(H,k),R.lines=A+R.scanlineBlockSize>R.height?R.height-A:R.scanlineBlockSize;const D=R.size<R.lines*R.bytesPerLine&&R.uncompress?R.uncompress(R):RR(R);k.value+=R.size;for(let H=0;H<R.scanlineBlockSize;H++){const k=t*R.scanlineBlockSize,A=H+R.scanOrder(k);if(A>=R.height)continue;const U=H*R.bytesPerLine,J=(R.height-1-A)*R.outLineWidth;for(let H=0;H<R.channels;H++){const k=x.channels[H].name,t=R.channelLineOffsets[k],A=R.decodeChannels[k];if(void 0!==A){c.value=U+t;for(let x=0;x<R.width;x++){const H=J+x*R.outputChannels+A;R.byteArray&&(R.byteArray[H]=R.getter(D,c))}}}}}}DR.DefaultOutputType=tR.HalfFloat,DR.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class VR{constructor(){this.supportCascades=!1}loadCubeData(R,x,H,k,c){throw".exr not supported in Cube."}loadData(R,x,H){const c=new DataView(R.buffer),t={value:0},A=W(c,t);UR(A,c,t,DR.DefaultOutputType).then((R=>{JR(R,A,c,t);const k=A.dataWindow.xMax-A.dataWindow.xMin+1,D=A.dataWindow.yMax-A.dataWindow.yMin+1;H(k,D,x.generateMipMaps,!1,(()=>{const H=x.getEngine();x.format=A.format,x.type=R.textureType,x.invertY=!1,x._gammaSpace=!A.linearSpace,R.byteArray&&H._uploadDataToTextureDirectly(x,R.byteArray,0,0,void 0,!0)}))})).catch((R=>{k.c.Error("Failed to load EXR texture: ",R)}))}}async function nR(R){const x=new DataView(R),H={value:0},c=W(x,H);try{const R=await UR(c,x,H,tR.Float);return JR(R,c,x,H),R.byteArray?{width:c.dataWindow.xMax-c.dataWindow.xMin+1,height:c.dataWindow.yMax-c.dataWindow.yMin+1,data:new Float32Array(R.byteArray)}:(k.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(t){k.c.Error("Failed to load EXR data: ",t)}return{width:0,height:0,data:null}}}}]);