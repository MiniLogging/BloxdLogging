"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2224:(L,j,P)=>{P.r(j),P.d(j,{ReadExrDataAsync:()=>gL,_ExrTextureLoader:()=>SL});var A=P(490),R=P(670);const o=4,Y=4,u=1,a=2,D=8,S=65536,g=S>>3,V=14,N=65537,C=1<<V,b=C-1,f=59,h=63,K=2+h-f;var v,q;!function(L){L[L.NO_COMPRESSION=0]="NO_COMPRESSION",L[L.RLE_COMPRESSION=1]="RLE_COMPRESSION",L[L.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",L[L.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",L[L.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",L[L.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(v||(v={})),function(L){L[L.INCREASING_Y=0]="INCREASING_Y",L[L.DECREASING_Y=1]="DECREASING_Y"}(q||(q={}));const y=function(){const L=new ArrayBuffer(4),j=new Float32Array(L),P=new Uint32Array(L),A=new Uint32Array(512),R=new Uint32Array(512);for(let a=0;a<256;++a){const L=a-127;L<-27?(A[a]=0,A[256|a]=32768,R[a]=24,R[256|a]=24):L<-14?(A[a]=1024>>-L-14,A[256|a]=1024>>-L-14|32768,R[a]=-L-1,R[256|a]=-L-1):L<=15?(A[a]=L+15<<10,A[256|a]=L+15<<10|32768,R[a]=13,R[256|a]=13):L<128?(A[a]=31744,A[256|a]=64512,R[a]=24,R[256|a]=24):(A[a]=31744,A[256|a]=64512,R[a]=13,R[256|a]=13)}const o=new Uint32Array(2048),Y=new Uint32Array(64),u=new Uint32Array(64);for(let a=1;a<1024;++a){let L=a<<13,j=0;for(;0===(8388608&L);)L<<=1,j-=8388608;L&=-8388609,j+=947912704,o[a]=L|j}for(let a=1024;a<2048;++a)o[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)Y[a]=a<<23;Y[31]=1199570944,Y[32]=2147483648;for(let a=33;a<63;++a)Y[a]=2147483648+(a-32<<23);Y[63]=3347054592;for(let a=1;a<64;++a)32!==a&&(u[a]=1024);return{floatView:j,uint32View:P,baseTable:A,shiftTable:R,mantissaTable:o,exponentTable:Y,offsetTable:u}}();function T(L,j){const P=new Uint8Array(L);let A=0;for(;0!=P[j.value+A];)A+=1;const R=(new TextDecoder).decode(P.slice(j.value,j.value+A));return j.value=j.value+A+1,R}function G(L,j){const P=L.getInt32(j.value,!0);return j.value+=o,P}function M(L,j){const P=L.getUint32(j.value,!0);return j.value+=o,P}function Q(L,j){const P=L.getUint8(j.value);return j.value+=u,P}function l(L,j){const P=L.getUint16(j.value,!0);return j.value+=a,P}function w(L,j){const P=L[j.value];return j.value+=u,P}function d(L,j){let P;return P="getBigInt64"in DataView.prototype?Number(L.getBigInt64(j.value,!0)):L.getUint32(j.value+4,!0)+Number(L.getUint32(j.value,!0)<<32),j.value+=D,P}function c(L,j){const P=L.getFloat32(j.value,!0);return j.value+=Y,P}function E(L,j){return function(L){const j=(31744&L)>>10,P=1023&L;return(L>>15?-1:1)*(j?31===j?P?NaN:1/0:Math.pow(2,j-15)*(1+P/1024):P/1024*6103515625e-14)}(l(L,j))}function U(L,j){return function(L){if(Math.abs(L)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");L=(0,R.Clamp)(L,-65504,65504),y.floatView[0]=L;const j=y.uint32View[0],P=j>>23&511;return y.baseTable[P]+((8388607&j)>>y.shiftTable[P])}(c(L,j))}function t(L,j,P,A){switch(P){case"string":case"stringvector":case"iccProfile":return function(L,j,P){const A=(new TextDecoder).decode(new Uint8Array(L).slice(j.value,j.value+P));return j.value=j.value+P,A}(L.buffer,j,A);case"chlist":return function(L,j,P){const A=j.value,R=[];for(;j.value<A+P-1;){const P=T(L.buffer,j),A=G(L,j),o=Q(L,j);j.value+=3;const Y=G(L,j),u=G(L,j);R.push({name:P,pixelType:A,pLinear:o,xSampling:Y,ySampling:u})}return j.value+=1,R}(L,j,A);case"chromaticities":return function(L,j){return{redX:c(L,j),redY:c(L,j),greenX:c(L,j),greenY:c(L,j),blueX:c(L,j),blueY:c(L,j),whiteX:c(L,j),whiteY:c(L,j)}}(L,j);case"compression":return function(L,j){return Q(L,j)}(L,j);case"box2i":return function(L,j){return{xMin:G(L,j),yMin:G(L,j),xMax:G(L,j),yMax:G(L,j)}}(L,j);case"lineOrder":return function(L,j){const P=Q(L,j);return q[P]}(L,j);case"float":return c(L,j);case"v2f":return function(L,j){return[c(L,j),c(L,j)]}(L,j);case"v3f":return function(L,j){return[c(L,j),c(L,j),c(L,j)]}(L,j);case"int":return G(L,j);case"rational":return function(L,j){return[G(L,j),M(L,j)]}(L,j);case"timecode":return function(L,j){return[M(L,j),M(L,j)]}(L,j);case"preview":return j.value+=A,"skipped";default:return void(j.value+=A)}}function B(L){for(let j=1;j<L.length;j++){const P=L[j-1]+L[j]-128;L[j]=P}}function F(L,j){let P=0,A=Math.floor((L.length+1)/2),R=0;const o=L.length-1;for(;!(R>o)&&(j[R++]=L[P++],!(R>o));)j[R++]=L[A++]}const X=20000630;function H(L,j){if(L.getUint32(0,!0)!=X)throw new Error("Incorrect OpenEXR format");const P=L.getUint8(4),R=L.getUint8(5),o={singleTile:!!(2&R),longName:!!(4&R),deepFormat:!!(8&R),multiPart:!!(16&R)};j.value=8;const Y={};let u=!0;for(;u;){const P=T(L.buffer,j);if(P){const R=T(L.buffer,j),o=t(L,j,R,M(L,j));void 0===o?A.e.Warn(`Unknown header attribute type ${R}'.`):Y[P]=o}else u=!1}if(0!=(-5&R))throw new Error("Unsupported file format");return{version:P,spec:o,...Y}}const W=32768,e=65535;function s(L,j,P,A,R){for(;P<L;)j=j<<8|w(A,R),P+=8;return{l:j>>(P-=L)&(1<<L)-1,c:j,lc:P}}function m(L,j,P,A){return{c:L=L<<8|w(P,A),lc:j+=8}}function x(L,j,P,A,R,o,Y,u,a){if(L==j){if(A<8){const L=m(P,A,R,o);P=L.c,A=L.lc}let L=P>>(A-=8);if(L=new Uint8Array([L])[0],u.value+L>a)return null;const j=Y[u.value-1];for(;L-- >0;)Y[u.value++]=j}else{if(!(u.value<a))return null;Y[u.value++]=L}return{c:P,lc:A}}const k=new Array(59);function I(L,j,P,A,R,o){const Y=j;let u=0,a=0;for(;A<=R;A++){if(Y.value-j.value>P)return;let D=s(6,u,a,L,Y);const S=D.l;if(u=D.c,a=D.lc,o[A]=S,S==h){if(Y.value-j.value>P)throw new Error("Error in HufUnpackEncTable");D=s(8,u,a,L,Y);let S=D.l+K;if(u=D.c,a=D.lc,A+S>R+1)throw new Error("Error in HufUnpackEncTable");for(;S--;)o[A++]=0;A--}else if(S>=f){let L=S-f+2;if(A+L>R+1)throw new Error("Error in HufUnpackEncTable");for(;L--;)o[A++]=0;A--}}!function(L){for(let P=0;P<=58;++P)k[P]=0;for(let P=0;P<N;++P)k[L[P]]+=1;let j=0;for(let P=58;P>0;--P){const L=j+k[P]>>1;k[P]=j,j=L}for(let P=0;P<N;++P){const j=L[P];j>0&&(L[P]=j|k[j]++<<6)}}(o)}function z(L){return 63&L}function p(L){return L>>6}function n(L,j,P,A,R,o){const Y=P.value,u=M(j,P),a=M(j,P);P.value+=4;const D=M(j,P);if(P.value+=4,u<0||u>=N||a<0||a>=N)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(N),g=new Array(C);!function(L){for(let j=0;j<C;j++)L[j]={},L[j].len=0,L[j].lit=0,L[j].p=null}(g);if(I(L,P,A-(P.value-Y),u,a,S),D>8*(A-(P.value-Y)))throw new Error("Wrong hufUncompress");!function(L,j,P,A){for(;j<=P;j++){const P=p(L[j]),R=z(L[j]);if(P>>R)throw new Error("Invalid table entry");if(R>V){const L=A[P>>R-V];if(L.len)throw new Error("Invalid table entry");if(L.lit++,L.p){const j=L.p;L.p=new Array(L.lit);for(let P=0;P<L.lit-1;++P)L.p[P]=j[P]}else L.p=new Array(1);L.p[L.lit-1]=j}else if(R){let L=0;for(let o=1<<V-R;o>0;o--){const o=A[(P<<V-R)+L];if(o.len||o.p)throw new Error("Invalid table entry");o.len=R,o.lit=j,L++}}}}(S,u,a,g),function(L,j,P,A,R,o,Y,u,a){let D=0,S=0;const g=Y,N=Math.trunc(A.value+(R+7)/8);for(;A.value<N;){let R=m(D,S,P,A);for(D=R.c,S=R.lc;S>=V;){const Y=j[D>>S-V&b];if(Y.len){S-=Y.len;const L=x(Y.lit,o,D,S,P,A,u,a,g);L&&(D=L.c,S=L.lc)}else{if(!Y.p)throw new Error("hufDecode issues");let j;for(j=0;j<Y.lit;j++){const V=z(L[Y.p[j]]);for(;S<V&&A.value<N;)R=m(D,S,P,A),D=R.c,S=R.lc;if(S>=V&&p(L[Y.p[j]])==(D>>S-V&(1<<V)-1)){S-=V;const L=x(Y.p[j],o,D,S,P,A,u,a,g);L&&(D=L.c,S=L.lc);break}}if(j==Y.lit)throw new Error("HufDecode issues")}}}const C=8-R&7;for(D>>=C,S-=C;S>0;){const L=j[D<<V-S&b];if(!L.len)throw new Error("HufDecode issues");{S-=L.len;const j=x(L.lit,o,D,S,P,A,u,a,g);j&&(D=j.c,S=j.lc)}}}(S,g,L,P,D,a,o,R,{value:0})}function Z(L){return 65535&L}function O(L){const j=Z(L);return j>32767?j-65536:j}function i(L,j){const P=O(L),A=O(j),R=P+(1&A)+(A>>1);return{a:R,b:R-A}}function J(L,j){const P=Z(L),A=Z(j),R=P-(A>>1)&e;return{a:A+R-W&e,b:R}}function r(L,j,P,A,R,o,Y){const u=Y<16384,a=P>R?R:P;let D,S,g=1;for(;g<=a;)g<<=1;for(g>>=1,D=g,g>>=1;g>=1;){S=0;const Y=S+o*(R-D),a=o*g,V=o*D,N=A*g,C=A*D;let b,f,h,K;for(;S<=Y;S+=V){let R=S;const o=S+A*(P-D);for(;R<=o;R+=C){const P=R+N,A=R+a,o=A+N;if(u){let Y=i(L[R+j],L[A+j]);b=Y.a,h=Y.b,Y=i(L[P+j],L[o+j]),f=Y.a,K=Y.b,Y=i(b,f),L[R+j]=Y.a,L[P+j]=Y.b,Y=i(h,K),L[A+j]=Y.a,L[o+j]=Y.b}else{let Y=J(L[R+j],L[A+j]);b=Y.a,h=Y.b,Y=J(L[P+j],L[o+j]),f=Y.a,K=Y.b,Y=J(b,f),L[R+j]=Y.a,L[P+j]=Y.b,Y=J(h,K),L[A+j]=Y.a,L[o+j]=Y.b}}if(P&g){const P=R+a;let A;A=u?i(L[R+j],L[P+j]):J(L[R+j],L[P+j]),b=A.a,L[P+j]=A.b,L[R+j]=b}}if(R&g){let R=S;const o=S+A*(P-D);for(;R<=o;R+=C){const P=R+N;let A;A=u?i(L[R+j],L[P+j]):J(L[R+j],L[P+j]),b=A.a,L[P+j]=A.b,L[R+j]=b}}D=g,g>>=1}return S}function LL(L){return new DataView(L.array.buffer,L.offset.value,L.size)}function jL(L){const j=L.viewer.buffer.slice(L.offset.value,L.offset.value+L.size),P=new Uint8Array(function(L){let j=L.byteLength;const P=[];let A=0;const R=new DataView(L);for(;j>0;){const L=R.getInt8(A++);if(L<0){const o=-L;j-=o+1;for(let L=0;L<o;L++)P.push(R.getUint8(A++))}else{const o=L;j-=2;const Y=R.getUint8(A++);for(let L=0;L<o+1;L++)P.push(Y)}}return P}(j)),A=new Uint8Array(P.length);return B(P),F(P,A),new DataView(A.buffer)}function PL(L){const j=L.array.slice(L.offset.value,L.offset.value+L.size),P=fflate.unzlibSync(j),A=new Uint8Array(P.length);return B(P),F(P,A),new DataView(A.buffer)}function AL(L){const j=L.array.slice(L.offset.value,L.offset.value+L.size),P=fflate.unzlibSync(j),A=L.lines*L.channels*L.width,R=1==L.type?new Uint16Array(A):new Uint32Array(A);let o=0,Y=0;const u=new Array(4);for(let a=0;a<L.lines;a++)for(let j=0;j<L.channels;j++){let j=0;switch(L.type){case 1:u[0]=o,u[1]=u[0]+L.width,o=u[1]+L.width;for(let A=0;A<L.width;++A){j+=P[u[0]++]<<8|P[u[1]++],R[Y]=j,Y++}break;case 2:u[0]=o,u[1]=u[0]+L.width,u[2]=u[1]+L.width,o=u[2]+L.width;for(let A=0;A<L.width;++A){j+=P[u[0]++]<<24|P[u[1]++]<<16|P[u[2]++]<<8,R[Y]=j,Y++}}}return new DataView(R.buffer)}function RL(L){const j=L.viewer,P={value:L.offset.value},A=new Uint16Array(L.width*L.scanlineBlockSize*(L.channels*L.type)),R=new Uint8Array(g);let o=0;const Y=new Array(L.channels);for(let a=0;a<L.channels;a++)Y[a]={},Y[a].start=o,Y[a].end=Y[a].start,Y[a].nx=L.width,Y[a].ny=L.lines,Y[a].size=L.type,o+=Y[a].nx*Y[a].ny*Y[a].size;const u=l(j,P),D=l(j,P);if(D>=g)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(u<=D)for(let a=0;a<D-u+1;a++)R[a+u]=Q(j,P);const V=new Uint16Array(S),N=function(L,j){let P=0;for(let R=0;R<S;++R)(0==R||L[R>>3]&1<<(7&R))&&(j[P++]=R);const A=P-1;for(;P<S;)j[P++]=0;return A}(R,V),C=M(j,P);n(L.array,j,P,C,A,o);for(let a=0;a<L.channels;++a){const L=Y[a];for(let j=0;j<Y[a].size;++j)r(A,L.start+j,L.nx,L.size,L.ny,L.nx*L.size,N)}!function(L,j,P){for(let A=0;A<P;++A)j[A]=L[j[A]]}(V,A,o);let b=0;const f=new Uint8Array(A.buffer.byteLength);for(let S=0;S<L.lines;S++)for(let j=0;j<L.channels;j++){const L=Y[j],P=L.nx*L.size,R=new Uint8Array(A.buffer,L.end*a,P*a);f.set(R,b),b+=P*a,L.end+=P}return new DataView(f.buffer)}var oL,YL=P(475);!function(L){L[L.Float=0]="Float",L[L.HalfFloat=1]="HalfFloat"}(oL||(oL={}));class uL{}async function aL(L,j,P,A){const R={size:0,viewer:j,array:new Uint8Array(j.buffer),offset:P,width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,channels:L.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(L.compression){case v.NO_COMPRESSION:R.lines=1,R.uncompress=LL;break;case v.RLE_COMPRESSION:R.lines=1,R.uncompress=jL;break;case v.ZIPS_COMPRESSION:R.lines=1,R.uncompress=PL,await YL.d.LoadScriptAsync(uL.FFLATEUrl);break;case v.ZIP_COMPRESSION:R.lines=16,R.uncompress=PL,await YL.d.LoadScriptAsync(uL.FFLATEUrl);break;case v.PIZ_COMPRESSION:R.lines=32,R.uncompress=RL;break;case v.PXR24_COMPRESSION:R.lines=16,R.uncompress=AL,await YL.d.LoadScriptAsync(uL.FFLATEUrl);break;default:throw new Error(v[L.compression]+" is unsupported")}R.scanlineBlockSize=R.lines;const o={};for(const Y of L.channels)switch(Y.name){case"R":case"G":case"B":case"A":case"Y":o[Y.name]=!0,R.type=Y.pixelType}let u=!1;if(o.R&&o.G&&o.B&&o.A)R.outputChannels=4,R.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G&&o.B)u=!0,R.outputChannels=4,R.decodeChannels={R:0,G:1,B:2,A:3};else if(o.R&&o.G)R.outputChannels=2,R.decodeChannels={R:0,G:1};else if(o.R)R.outputChannels=1,R.decodeChannels={R:0};else{if(!o.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");R.outputChannels=1,R.decodeChannels={Y:0}}if(1===R.type)switch(A){case oL.Float:R.getter=E,R.inputSize=a;break;case oL.HalfFloat:R.getter=l,R.inputSize=a}else{if(2!==R.type)throw new Error("Unsupported pixelType "+R.type+" for "+L.compression);switch(A){case oL.Float:R.getter=c,R.inputSize=Y;break;case oL.HalfFloat:R.getter=U,R.inputSize=Y}}R.blockCount=R.height/R.scanlineBlockSize;for(let Y=0;Y<R.blockCount;Y++)d(j,P);const D=R.width*R.height*R.outputChannels;switch(A){case oL.Float:R.byteArray=new Float32Array(D),R.textureType=1,u&&R.byteArray.fill(1,0,D);break;case oL.HalfFloat:R.byteArray=new Uint16Array(D),R.textureType=2,u&&R.byteArray.fill(15360,0,D);break;default:throw new Error("Unsupported type: "+A)}let S=0;for(const Y of L.channels)void 0!==R.decodeChannels[Y.name]&&(R.channelLineOffsets[Y.name]=S*R.width),S+=2*Y.pixelType;return R.bytesPerLine=R.width*S,R.outLineWidth=R.width*R.outputChannels,"INCREASING_Y"===L.lineOrder?R.scanOrder=L=>L:R.scanOrder=L=>R.height-1-L,4==R.outputChannels?(R.format=5,R.linearSpace=!0):(R.format=6,R.linearSpace=!1),R}function DL(L,j,P,A){const R={value:0};for(let o=0;o<L.height/L.scanlineBlockSize;o++){const Y=G(P,A)-j.dataWindow.yMin;L.size=M(P,A),L.lines=Y+L.scanlineBlockSize>L.height?L.height-Y:L.scanlineBlockSize;const u=L.size<L.lines*L.bytesPerLine&&L.uncompress?L.uncompress(L):LL(L);A.value+=L.size;for(let P=0;P<L.scanlineBlockSize;P++){const A=o*L.scanlineBlockSize,Y=P+L.scanOrder(A);if(Y>=L.height)continue;const a=P*L.bytesPerLine,D=(L.height-1-Y)*L.outLineWidth;for(let P=0;P<L.channels;P++){const A=j.channels[P].name,o=L.channelLineOffsets[A],Y=L.decodeChannels[A];if(void 0!==Y){R.value=a+o;for(let j=0;j<L.width;j++){const P=D+j*L.outputChannels+Y;L.byteArray&&(L.byteArray[P]=L.getter(u,R))}}}}}}uL.DefaultOutputType=oL.HalfFloat,uL.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class SL{constructor(){this.supportCascades=!1}loadCubeData(L,j,P,A,R){throw".exr not supported in Cube."}loadData(L,j,P){const R=new DataView(L.buffer),o={value:0},Y=H(R,o);aL(Y,R,o,uL.DefaultOutputType).then((L=>{DL(L,Y,R,o);const A=Y.dataWindow.xMax-Y.dataWindow.xMin+1,u=Y.dataWindow.yMax-Y.dataWindow.yMin+1;P(A,u,j.generateMipMaps,!1,(()=>{const P=j.getEngine();j.format=Y.format,j.type=L.textureType,j.invertY=!1,j._gammaSpace=!Y.linearSpace,L.byteArray&&P._uploadDataToTextureDirectly(j,L.byteArray,0,0,void 0,!0)}))})).catch((L=>{A.e.Error("Failed to load EXR texture: ",L)}))}}async function gL(L){const j=new DataView(L),P={value:0},R=H(j,P);try{const L=await aL(R,j,P,oL.Float);return DL(L,R,j,P),L.byteArray?{width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,data:new Float32Array(L.byteArray)}:(A.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(o){A.e.Error("Failed to load EXR data: ",o)}return{width:0,height:0,data:null}}}}]);