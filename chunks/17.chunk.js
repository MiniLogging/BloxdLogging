"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[17],{11183:(P,e,n)=>{n.r(e),n.d(e,{Ne:()=>q,wm:()=>A,TmpColors:()=>F});var H=n(11143),S=n(11096),p=n(11140),k=n(11148);function m(P){return Math.pow(P,p.i)}function t(P){return P<=.04045?.0773993808*P:Math.pow(.947867299*(P+.055),2.4)}function C(P){return Math.pow(P,p.h)}function R(P){return P<=.0031308?12.92*P:1.055*Math.pow(P,.41666)-.055}class q{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=P,this.g=e,this.b=n}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Ne"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P}toArray(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[e]=this.r,P[e+1]=this.g,P[e+2]=this.b,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(P,e,this),this}toColor4(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new A(this.r,this.g,this.b,P)}fe(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(P){return new q(this.r*P.r,this.g*P.g,this.b*P.b)}multiplyToRef(P,e){return e.r=this.r*P.r,e.g=this.g*P.g,e.b=this.b*P.b,e}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this}multiplyByFloats(P,e,n){return new q(this.r*P,this.g*e,this.b*n)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,e){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.minimizeInPlaceFromFloats(P.r,P.g,P.b)}maximizeInPlace(P){return this.maximizeInPlaceFromFloats(P.r,P.g,P.b)}minimizeInPlaceFromFloats(P,e,n){return this.r=Math.min(P,this.r),this.g=Math.min(e,this.g),this.b=Math.min(n,this.b),this}maximizeInPlaceFromFloats(P,e,n){return this.r=Math.max(P,this.r),this.g=Math.max(e,this.g),this.b=Math.max(n,this.b),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b}equalsFloats(P,e,n){return this.equalsToFloats(P,e,n)}equalsToFloats(P,e,n){return this.r===P&&this.g===e&&this.b===n}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.c;return(0,k.WithinEpsilon)(this.r,P.r,e)&&(0,k.WithinEpsilon)(this.g,P.g,e)&&(0,k.WithinEpsilon)(this.b,P.b,e)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}scale(P){return new q(this.r*P,this.g*P,this.b*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this}scaleToRef(P,e){return e.r=this.r*P,e.g=this.g*P,e.b=this.b*P,e}scaleAndAddToRef(P,e){return e.r+=this.r*P,e.g+=this.g*P,e.b+=this.b*P,e}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0;return n.r=(0,k.Clamp)(this.r,P,e),n.g=(0,k.Clamp)(this.g,P,e),n.b=(0,k.Clamp)(this.b,P,e),n}add(P){return new q(this.r+P.r,this.g+P.g,this.b+P.b)}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this}addInPlaceFromFloats(P,e,n){return this.r+=P,this.g+=e,this.b+=n,this}addToRef(P,e){return e.r=this.r+P.r,e.g=this.g+P.g,e.b=this.b+P.b,e}be(P){return new q(this.r-P.r,this.g-P.g,this.b-P.b)}subtractToRef(P,e){return e.r=this.r-P.r,e.g=this.g-P.g,e.b=this.b-P.b,e}MR(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this}subtractFromFloats(P,e,n){return new q(this.r-P,this.g-e,this.b-n)}subtractFromFloatsToRef(P,e,n,H){return H.r=this.r-P,H.g=this.g-e,H.b=this.b-n,H}clone(){return new q(this.r,this.g,this.b)}p(P){return this.r=P.r,this.g=P.g,this.b=P.b,this}dp(P,e,n){return this.r=P,this.g=e,this.b=n,this}set(P,e,n){return this.dp(P,e,n)}zm(P){return this.r=this.g=this.b=P,this}toHexString(){const P=Math.round(255*this.r),e=Math.round(255*this.g),n=Math.round(255*this.b);return"#"+(0,k.ToHex)(P)+(0,k.ToHex)(e)+(0,k.ToHex)(n)}fromHexString(P){return"#"!==P.substring(0,1)||7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new q)}toHSVToRef(P){const e=this.r,n=this.g,H=this.b,S=Math.max(e,n,H),p=Math.min(e,n,H);let k=0,m=0;const t=S,C=S-p;return 0!==S&&(m=C/S),S!=p&&(S==e?(k=(n-H)/C,n<H&&(k+=6)):S==n?k=(H-e)/C+2:S==H&&(k=(e-n)/C+4),k*=60),P.r=k,P.g=m,P.b=t,P}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=new q;return this.toLinearSpaceToRef(e,P),e}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=t(this.r),P.g=t(this.g),P.b=t(this.b)):(P.r=m(this.r),P.g=m(this.g),P.b=m(this.b)),this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=new q;return this.toGammaSpaceToRef(e,P),e}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=R(this.r),P.g=R(this.g),P.b=R(this.b)):(P.r=C(this.r),P.g=C(this.g),P.b=C(this.b)),this}static HSVtoRGBToRef(P,e,n,H){const S=n*e,p=P/60,k=S*(1-Math.abs(p%2-1));let m=0,t=0,C=0;p>=0&&p<=1?(m=S,t=k):p>=1&&p<=2?(m=k,t=S):p>=2&&p<=3?(t=S,C=k):p>=3&&p<=4?(t=k,C=S):p>=4&&p<=5?(m=k,C=S):p>=5&&p<=6&&(m=S,C=k);const R=n-S;return H.r=m+R,H.g=t+R,H.b=C+R,H}static FromHSV(P,e,n){const H=new q(0,0,0);return q.HSVtoRGBToRef(P,e,n,H),H}static FromHexString(P){return new q(0,0,0).fromHexString(P)}static Qe(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(P[e],P[e+1],P[e+2])}static FromArrayToRef(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2?arguments[2]:void 0;n.r=P[e],n.g=P[e+1],n.b=P[e+2]}static FromInts(P,e,n){return new q(P/255,e/255,n/255)}static Lerp(P,e,n){const H=new q(0,0,0);return q.LerpToRef(P,e,n,H),H}static LerpToRef(P,e,n,H){H.r=P.r+(e.r-P.r)*n,H.g=P.g+(e.g-P.g)*n,H.b=P.b+(e.b-P.b)*n}static Hermite(P,e,n,H,S){const p=S*S,k=S*p,m=2*k-3*p+1,t=-2*k+3*p,C=k-2*p+S,R=k-p,A=P.r*m+n.r*t+e.r*C+H.r*R,F=P.g*m+n.g*t+e.g*C+H.g*R,Y=P.b*m+n.b*t+e.b*C+H.b*R;return new q(A,F,Y)}static Hermite1stDerivative(P,e,n,H,S){const p=q.Black();return this.Hermite1stDerivativeToRef(P,e,n,H,S,p),p}static Hermite1stDerivativeToRef(P,e,n,H,S,p){const k=S*S;p.r=6*(k-S)*P.r+(3*k-4*S+1)*e.r+6*(-k+S)*n.r+(3*k-2*S)*H.r,p.g=6*(k-S)*P.g+(3*k-4*S+1)*e.g+6*(-k+S)*n.g+(3*k-2*S)*H.g,p.b=6*(k-S)*P.b+(3*k-4*S+1)*e.b+6*(-k+S)*n.b+(3*k-2*S)*H.b}static Red(){return new q(1,0,0)}static Green(){return new q(0,1,0)}static Blue(){return new q(0,0,1)}static Black(){return new q(0,0,0)}static get BlackReadOnly(){return q._BlackReadOnly}static White(){return new q(1,1,1)}static Purple(){return new q(.5,0,.5)}static Magenta(){return new q(1,0,1)}static Yellow(){return new q(1,1,0)}static Gray(){return new q(.5,.5,.5)}static Teal(){return new q(0,1,1)}static Random(){return new q(Math.random(),Math.random(),Math.random())}}q._V8PerformanceHack=new q(.5,.5,.5),q._BlackReadOnly=q.Black(),Object.defineProperties(q.prototype,{dimension:{value:[3]},rank:{value:1}});class A{constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=P,this.g=e,this.b=n,this.a=H}fe(){return[this.r,this.g,this.b,this.a]}toArray(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return P[e]=this.r,P[e+1]=this.g,P[e+2]=this.b,P[e+3]=this.a,this}yn(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=P[e],this.g=P[e+1],this.b=P[e+2],this.a=P[e+3],this}equals(P){return P&&this.r===P.r&&this.g===P.g&&this.b===P.b&&this.a===P.a}add(P){return new A(this.r+P.r,this.g+P.g,this.b+P.b,this.a+P.a)}addToRef(P,e){return e.r=this.r+P.r,e.g=this.g+P.g,e.b=this.b+P.b,e.a=this.a+P.a,e}addInPlace(P){return this.r+=P.r,this.g+=P.g,this.b+=P.b,this.a+=P.a,this}addInPlaceFromFloats(P,e,n,H){return this.r+=P,this.g+=e,this.b+=n,this.a+=H,this}be(P){return new A(this.r-P.r,this.g-P.g,this.b-P.b,this.a-P.a)}subtractToRef(P,e){return e.r=this.r-P.r,e.g=this.g-P.g,e.b=this.b-P.b,e.a=this.a-P.a,e}MR(P){return this.r-=P.r,this.g-=P.g,this.b-=P.b,this.a-=P.a,this}subtractFromFloats(P,e,n,H){return new A(this.r-P,this.g-e,this.b-n,this.a-H)}subtractFromFloatsToRef(P,e,n,H,S){return S.r=this.r-P,S.g=this.g-e,S.b=this.b-n,S.a=this.a-H,S}scale(P){return new A(this.r*P,this.g*P,this.b*P,this.a*P)}scaleInPlace(P){return this.r*=P,this.g*=P,this.b*=P,this.a*=P,this}scaleToRef(P,e){return e.r=this.r*P,e.g=this.g*P,e.b=this.b*P,e.a=this.a*P,e}scaleAndAddToRef(P,e){return e.r+=this.r*P,e.g+=this.g*P,e.b+=this.b*P,e.a+=this.a*P,e}clampToRef(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0;return n.r=(0,k.Clamp)(this.r,P,e),n.g=(0,k.Clamp)(this.g,P,e),n.b=(0,k.Clamp)(this.b,P,e),n.a=(0,k.Clamp)(this.a,P,e),n}multiply(P){return new A(this.r*P.r,this.g*P.g,this.b*P.b,this.a*P.a)}multiplyToRef(P,e){return e.r=this.r*P.r,e.g=this.g*P.g,e.b=this.b*P.b,e.a=this.a*P.a,e}multiplyInPlace(P){return this.r*=P.r,this.g*=P.g,this.b*=P.b,this.a*=P.a,this}multiplyByFloats(P,e,n,H){return new A(this.r*P,this.g*e,this.b*n,this.a*H)}divide(P){throw new ReferenceError("Can not divide a color")}divideToRef(P,e){throw new ReferenceError("Can not divide a color")}divideInPlace(P){throw new ReferenceError("Can not divide a color")}minimizeInPlace(P){return this.r=Math.min(this.r,P.r),this.g=Math.min(this.g,P.g),this.b=Math.min(this.b,P.b),this.a=Math.min(this.a,P.a),this}maximizeInPlace(P){return this.r=Math.max(this.r,P.r),this.g=Math.max(this.g,P.g),this.b=Math.max(this.b,P.b),this.a=Math.max(this.a,P.a),this}minimizeInPlaceFromFloats(P,e,n,H){return this.r=Math.min(P,this.r),this.g=Math.min(e,this.g),this.b=Math.min(n,this.b),this.a=Math.min(H,this.a),this}maximizeInPlaceFromFloats(P,e,n,H){return this.r=Math.max(P,this.r),this.g=Math.max(e,this.g),this.b=Math.max(n,this.b),this.a=Math.max(H,this.a),this}floorToRef(P){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(P){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(P){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.c;return(0,k.WithinEpsilon)(this.r,P.r,e)&&(0,k.WithinEpsilon)(this.g,P.g,e)&&(0,k.WithinEpsilon)(this.b,P.b,e)&&(0,k.WithinEpsilon)(this.a,P.a,e)}equalsToFloats(P,e,n,H){return this.r===P&&this.g===e&&this.b===n&&this.a===H}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"wm"}getHashCode(){let P=255*this.r|0;return P=397*P^255*this.g,P=397*P^255*this.b,P=397*P^255*this.a,P}clone(){return(new A).p(this)}p(P){return this.r=P.r,this.g=P.g,this.b=P.b,this.a=P.a,this}dp(P,e,n,H){return this.r=P,this.g=e,this.b=n,this.a=H,this}set(P,e,n,H){return this.dp(P,e,n,H)}zm(P){return this.r=this.g=this.b=this.a=P,this}toHexString(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=Math.round(255*this.r),n=Math.round(255*this.g),H=Math.round(255*this.b);if(P)return"#"+(0,k.ToHex)(e)+(0,k.ToHex)(n)+(0,k.ToHex)(H);const S=Math.round(255*this.a);return"#"+(0,k.ToHex)(e)+(0,k.ToHex)(n)+(0,k.ToHex)(H)+(0,k.ToHex)(S)}fromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length||(this.r=parseInt(P.substring(1,3),16)/255,this.g=parseInt(P.substring(3,5),16)/255,this.b=parseInt(P.substring(5,7),16)/255,9===P.length&&(this.a=parseInt(P.substring(7,9),16)/255)),this}toLinearSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=new A;return this.toLinearSpaceToRef(e,P),e}toLinearSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=t(this.r),P.g=t(this.g),P.b=t(this.b)):(P.r=m(this.r),P.g=m(this.g),P.b=m(this.b)),P.a=this.a,this}toGammaSpace(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=new A;return this.toGammaSpaceToRef(e,P),e}toGammaSpaceToRef(P){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(P.r=R(this.r),P.g=R(this.g),P.b=R(this.b)):(P.r=C(this.r),P.g=C(this.g),P.b=C(this.b)),P.a=this.a,this}static FromHexString(P){return"#"!==P.substring(0,1)||9!==P.length&&7!==P.length?new A(0,0,0,0):new A(0,0,0,1).fromHexString(P)}static Lerp(P,e,n){return A.LerpToRef(P,e,n,new A)}static LerpToRef(P,e,n,H){return H.r=P.r+(e.r-P.r)*n,H.g=P.g+(e.g-P.g)*n,H.b=P.b+(e.b-P.b)*n,H.a=P.a+(e.a-P.a)*n,H}static Hermite(P,e,n,H,S){const p=S*S,k=S*p,m=2*k-3*p+1,t=-2*k+3*p,C=k-2*p+S,R=k-p,q=P.r*m+n.r*t+e.r*C+H.r*R,F=P.g*m+n.g*t+e.g*C+H.g*R,Y=P.b*m+n.b*t+e.b*C+H.b*R,j=P.a*m+n.a*t+e.a*C+H.a*R;return new A(q,F,Y,j)}static Hermite1stDerivative(P,e,n,H,S){const p=new A;return this.Hermite1stDerivativeToRef(P,e,n,H,S,p),p}static Hermite1stDerivativeToRef(P,e,n,H,S,p){const k=S*S;p.r=6*(k-S)*P.r+(3*k-4*S+1)*e.r+6*(-k+S)*n.r+(3*k-2*S)*H.r,p.g=6*(k-S)*P.g+(3*k-4*S+1)*e.g+6*(-k+S)*n.g+(3*k-2*S)*H.g,p.b=6*(k-S)*P.b+(3*k-4*S+1)*e.b+6*(-k+S)*n.b+(3*k-2*S)*H.b,p.a=6*(k-S)*P.a+(3*k-4*S+1)*e.a+6*(-k+S)*n.a+(3*k-2*S)*H.a}static FromColor3(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new A(P.r,P.g,P.b,e)}static Qe(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(P[e],P[e+1],P[e+2],P[e+3])}static FromArrayToRef(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2?arguments[2]:void 0;n.r=P[e],n.g=P[e+1],n.b=P[e+2],n.a=P[e+3]}static FromInts(P,e,n,H){return new A(P/255,e/255,n/255,H/255)}static CheckColors4(P,e){if(P.length===3*e){const e=[];for(let n=0;n<P.length;n+=3){const H=n/3*4;e[H]=P[n],e[H+1]=P[n+1],e[H+2]=P[n+2],e[H+3]=1}return e}return P}}A._V8PerformanceHack=new A(.5,.5,.5,.5),Object.defineProperties(A.prototype,{dimension:{value:[4]},rank:{value:1}});class F{}F.Ne=(0,H.e)(3,q.Black),F.wm=(0,H.e)(3,(()=>new A(0,0,0,0))),(0,S.h)("BABYLON.Color3",q),(0,S.h)("BABYLON.Color4",A)}}]);