"use strict";(self.v2pspxy442l=self.v2pspxy442l||[]).push([[17],{12479:(l,a,N)=>{N.r(a),N.d(a,{Ca:()=>n,Qc:()=>y,TmpColors:()=>H});var U=N(12457),c=N(12394),K=N(12452),Z=N(12461);function w(l){return Math.pow(l,K.k)}function S(l){return l<=.04045?.0773993808*l:Math.pow(.947867299*(l+.055),2.4)}function T(l){return Math.pow(l,K.i)}function J(l){return l<=.0031308?12.92*l:1.055*Math.pow(l,.41666)-.055}class n{constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=l,this.g=a,this.b=N}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Ca"}getHashCode(){let l=255*this.r|0;return l=397*l^255*this.g,l=397*l^255*this.b,l}toArray(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l[a]=this.r,l[a+1]=this.g,l[a+2]=this.b,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(l,a,this),this}toColor4(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new y(this.r,this.g,this.b,l)}Bc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(l){return new n(this.r*l.r,this.g*l.g,this.b*l.b)}multiplyToRef(l,a){return a.r=this.r*l.r,a.g=this.g*l.g,a.b=this.b*l.b,a}multiplyInPlace(l){return this.r*=l.r,this.g*=l.g,this.b*=l.b,this}multiplyByFloats(l,a,N){return new n(this.r*l,this.g*a,this.b*N)}divide(l){throw new ReferenceError("Can not divide a color")}divideToRef(l,a){throw new ReferenceError("Can not divide a color")}divideInPlace(l){throw new ReferenceError("Can not divide a color")}minimizeInPlace(l){return this.minimizeInPlaceFromFloats(l.r,l.g,l.b)}maximizeInPlace(l){return this.maximizeInPlaceFromFloats(l.r,l.g,l.b)}minimizeInPlaceFromFloats(l,a,N){return this.r=Math.min(l,this.r),this.g=Math.min(a,this.g),this.b=Math.min(N,this.b),this}maximizeInPlaceFromFloats(l,a,N){return this.r=Math.max(l,this.r),this.g=Math.max(a,this.g),this.b=Math.max(N,this.b),this}floorToRef(l){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(l){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(l){return l&&this.r===l.r&&this.g===l.g&&this.b===l.b}equalsFloats(l,a,N){return this.equalsToFloats(l,a,N)}equalsToFloats(l,a,N){return this.r===l&&this.g===a&&this.b===N}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.d;return(0,Z.WithinEpsilon)(this.r,l.r,a)&&(0,Z.WithinEpsilon)(this.g,l.g,a)&&(0,Z.WithinEpsilon)(this.b,l.b,a)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(l){throw new ReferenceError("Can not negate a color")}scale(l){return new n(this.r*l,this.g*l,this.b*l)}scaleInPlace(l){return this.r*=l,this.g*=l,this.b*=l,this}scaleToRef(l,a){return a.r=this.r*l,a.g=this.g*l,a.b=this.b*l,a}scaleAndAddToRef(l,a){return a.r+=this.r*l,a.g+=this.g*l,a.b+=this.b*l,a}clampToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,N=arguments.length>2?arguments[2]:void 0;return N.r=(0,Z.Clamp)(this.r,l,a),N.g=(0,Z.Clamp)(this.g,l,a),N.b=(0,Z.Clamp)(this.b,l,a),N}add(l){return new n(this.r+l.r,this.g+l.g,this.b+l.b)}addInPlace(l){return this.r+=l.r,this.g+=l.g,this.b+=l.b,this}addInPlaceFromFloats(l,a,N){return this.r+=l,this.g+=a,this.b+=N,this}addToRef(l,a){return a.r=this.r+l.r,a.g=this.g+l.g,a.b=this.b+l.b,a}Wa(l){return new n(this.r-l.r,this.g-l.g,this.b-l.b)}subtractToRef(l,a){return a.r=this.r-l.r,a.g=this.g-l.g,a.b=this.b-l.b,a}wn(l){return this.r-=l.r,this.g-=l.g,this.b-=l.b,this}subtractFromFloats(l,a,N){return new n(this.r-l,this.g-a,this.b-N)}subtractFromFloatsToRef(l,a,N,U){return U.r=this.r-l,U.g=this.g-a,U.b=this.b-N,U}clone(){return new n(this.r,this.g,this.b)}K(l){return this.r=l.r,this.g=l.g,this.b=l.b,this}tc(l,a,N){return this.r=l,this.g=a,this.b=N,this}set(l,a,N){return this.tc(l,a,N)}hc(l){return this.r=this.g=this.b=l,this}toHexString(){const l=Math.round(255*this.r),a=Math.round(255*this.g),N=Math.round(255*this.b);return"#"+(0,Z.ToHex)(l)+(0,Z.ToHex)(a)+(0,Z.ToHex)(N)}fromHexString(l){return"#"!==l.substring(0,1)||7!==l.length||(this.r=parseInt(l.substring(1,3),16)/255,this.g=parseInt(l.substring(3,5),16)/255,this.b=parseInt(l.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new n)}toHSVToRef(l){const a=this.r,N=this.g,U=this.b,c=Math.max(a,N,U),K=Math.min(a,N,U);let Z=0,w=0;const S=c,T=c-K;return 0!==c&&(w=T/c),c!=K&&(c==a?(Z=(N-U)/T,N<U&&(Z+=6)):c==N?Z=(U-a)/T+2:c==U&&(Z=(a-N)/T+4),Z*=60),l.r=Z,l.g=w,l.b=S,l}toLinearSpace(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new n;return this.toLinearSpaceToRef(a,l),a}toLinearSpaceToRef(l){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(l.r=S(this.r),l.g=S(this.g),l.b=S(this.b)):(l.r=w(this.r),l.g=w(this.g),l.b=w(this.b)),this}toGammaSpace(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new n;return this.toGammaSpaceToRef(a,l),a}toGammaSpaceToRef(l){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(l.r=J(this.r),l.g=J(this.g),l.b=J(this.b)):(l.r=T(this.r),l.g=T(this.g),l.b=T(this.b)),this}static HSVtoRGBToRef(l,a,N,U){const c=N*a,K=l/60,Z=c*(1-Math.abs(K%2-1));let w=0,S=0,T=0;K>=0&&K<=1?(w=c,S=Z):K>=1&&K<=2?(w=Z,S=c):K>=2&&K<=3?(S=c,T=Z):K>=3&&K<=4?(S=Z,T=c):K>=4&&K<=5?(w=Z,T=c):K>=5&&K<=6&&(w=c,T=Z);const J=N-c;return U.r=w+J,U.g=S+J,U.b=T+J,U}static FromHSV(l,a,N){const U=new n(0,0,0);return n.HSVtoRGBToRef(l,a,N,U),U}static FromHexString(l){return new n(0,0,0).fromHexString(l)}static Ma(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(l[a],l[a+1],l[a+2])}static FromArrayToRef(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2?arguments[2]:void 0;N.r=l[a],N.g=l[a+1],N.b=l[a+2]}static FromInts(l,a,N){return new n(l/255,a/255,N/255)}static Lerp(l,a,N){const U=new n(0,0,0);return n.LerpToRef(l,a,N,U),U}static LerpToRef(l,a,N,U){U.r=l.r+(a.r-l.r)*N,U.g=l.g+(a.g-l.g)*N,U.b=l.b+(a.b-l.b)*N}static Hermite(l,a,N,U,c){const K=c*c,Z=c*K,w=2*Z-3*K+1,S=-2*Z+3*K,T=Z-2*K+c,J=Z-K,y=l.r*w+N.r*S+a.r*T+U.r*J,H=l.g*w+N.g*S+a.g*T+U.g*J,u=l.b*w+N.b*S+a.b*T+U.b*J;return new n(y,H,u)}static Hermite1stDerivative(l,a,N,U,c){const K=n.Black();return this.Hermite1stDerivativeToRef(l,a,N,U,c,K),K}static Hermite1stDerivativeToRef(l,a,N,U,c,K){const Z=c*c;K.r=6*(Z-c)*l.r+(3*Z-4*c+1)*a.r+6*(-Z+c)*N.r+(3*Z-2*c)*U.r,K.g=6*(Z-c)*l.g+(3*Z-4*c+1)*a.g+6*(-Z+c)*N.g+(3*Z-2*c)*U.g,K.b=6*(Z-c)*l.b+(3*Z-4*c+1)*a.b+6*(-Z+c)*N.b+(3*Z-2*c)*U.b}static Red(){return new n(1,0,0)}static Green(){return new n(0,1,0)}static Blue(){return new n(0,0,1)}static Black(){return new n(0,0,0)}static get BlackReadOnly(){return n._BlackReadOnly}static White(){return new n(1,1,1)}static Purple(){return new n(.5,0,.5)}static Magenta(){return new n(1,0,1)}static Yellow(){return new n(1,1,0)}static Gray(){return new n(.5,.5,.5)}static Teal(){return new n(0,1,1)}static Random(){return new n(Math.random(),Math.random(),Math.random())}}n._V8PerformanceHack=new n(.5,.5,.5),n._BlackReadOnly=n.Black(),Object.defineProperties(n.prototype,{dimension:{value:[3]},rank:{value:1}});class y{constructor(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=l,this.g=a,this.b=N,this.a=U}Bc(){return[this.r,this.g,this.b,this.a]}toArray(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return l[a]=this.r,l[a+1]=this.g,l[a+2]=this.b,l[a+3]=this.a,this}yN(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=l[a],this.g=l[a+1],this.b=l[a+2],this.a=l[a+3],this}equals(l){return l&&this.r===l.r&&this.g===l.g&&this.b===l.b&&this.a===l.a}add(l){return new y(this.r+l.r,this.g+l.g,this.b+l.b,this.a+l.a)}addToRef(l,a){return a.r=this.r+l.r,a.g=this.g+l.g,a.b=this.b+l.b,a.a=this.a+l.a,a}addInPlace(l){return this.r+=l.r,this.g+=l.g,this.b+=l.b,this.a+=l.a,this}addInPlaceFromFloats(l,a,N,U){return this.r+=l,this.g+=a,this.b+=N,this.a+=U,this}Wa(l){return new y(this.r-l.r,this.g-l.g,this.b-l.b,this.a-l.a)}subtractToRef(l,a){return a.r=this.r-l.r,a.g=this.g-l.g,a.b=this.b-l.b,a.a=this.a-l.a,a}wn(l){return this.r-=l.r,this.g-=l.g,this.b-=l.b,this.a-=l.a,this}subtractFromFloats(l,a,N,U){return new y(this.r-l,this.g-a,this.b-N,this.a-U)}subtractFromFloatsToRef(l,a,N,U,c){return c.r=this.r-l,c.g=this.g-a,c.b=this.b-N,c.a=this.a-U,c}scale(l){return new y(this.r*l,this.g*l,this.b*l,this.a*l)}scaleInPlace(l){return this.r*=l,this.g*=l,this.b*=l,this.a*=l,this}scaleToRef(l,a){return a.r=this.r*l,a.g=this.g*l,a.b=this.b*l,a.a=this.a*l,a}scaleAndAddToRef(l,a){return a.r+=this.r*l,a.g+=this.g*l,a.b+=this.b*l,a.a+=this.a*l,a}clampToRef(){let l=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,N=arguments.length>2?arguments[2]:void 0;return N.r=(0,Z.Clamp)(this.r,l,a),N.g=(0,Z.Clamp)(this.g,l,a),N.b=(0,Z.Clamp)(this.b,l,a),N.a=(0,Z.Clamp)(this.a,l,a),N}multiply(l){return new y(this.r*l.r,this.g*l.g,this.b*l.b,this.a*l.a)}multiplyToRef(l,a){return a.r=this.r*l.r,a.g=this.g*l.g,a.b=this.b*l.b,a.a=this.a*l.a,a}multiplyInPlace(l){return this.r*=l.r,this.g*=l.g,this.b*=l.b,this.a*=l.a,this}multiplyByFloats(l,a,N,U){return new y(this.r*l,this.g*a,this.b*N,this.a*U)}divide(l){throw new ReferenceError("Can not divide a color")}divideToRef(l,a){throw new ReferenceError("Can not divide a color")}divideInPlace(l){throw new ReferenceError("Can not divide a color")}minimizeInPlace(l){return this.r=Math.min(this.r,l.r),this.g=Math.min(this.g,l.g),this.b=Math.min(this.b,l.b),this.a=Math.min(this.a,l.a),this}maximizeInPlace(l){return this.r=Math.max(this.r,l.r),this.g=Math.max(this.g,l.g),this.b=Math.max(this.b,l.b),this.a=Math.max(this.a,l.a),this}minimizeInPlaceFromFloats(l,a,N,U){return this.r=Math.min(l,this.r),this.g=Math.min(a,this.g),this.b=Math.min(N,this.b),this.a=Math.min(U,this.a),this}maximizeInPlaceFromFloats(l,a,N,U){return this.r=Math.max(l,this.r),this.g=Math.max(a,this.g),this.b=Math.max(N,this.b),this.a=Math.max(U,this.a),this}floorToRef(l){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(l){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(l){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:K.d;return(0,Z.WithinEpsilon)(this.r,l.r,a)&&(0,Z.WithinEpsilon)(this.g,l.g,a)&&(0,Z.WithinEpsilon)(this.b,l.b,a)&&(0,Z.WithinEpsilon)(this.a,l.a,a)}equalsToFloats(l,a,N,U){return this.r===l&&this.g===a&&this.b===N&&this.a===U}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Qc"}getHashCode(){let l=255*this.r|0;return l=397*l^255*this.g,l=397*l^255*this.b,l=397*l^255*this.a,l}clone(){return(new y).K(this)}K(l){return this.r=l.r,this.g=l.g,this.b=l.b,this.a=l.a,this}tc(l,a,N,U){return this.r=l,this.g=a,this.b=N,this.a=U,this}set(l,a,N,U){return this.tc(l,a,N,U)}hc(l){return this.r=this.g=this.b=this.a=l,this}toHexString(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=Math.round(255*this.r),N=Math.round(255*this.g),U=Math.round(255*this.b);if(l)return"#"+(0,Z.ToHex)(a)+(0,Z.ToHex)(N)+(0,Z.ToHex)(U);const c=Math.round(255*this.a);return"#"+(0,Z.ToHex)(a)+(0,Z.ToHex)(N)+(0,Z.ToHex)(U)+(0,Z.ToHex)(c)}fromHexString(l){return"#"!==l.substring(0,1)||9!==l.length&&7!==l.length||(this.r=parseInt(l.substring(1,3),16)/255,this.g=parseInt(l.substring(3,5),16)/255,this.b=parseInt(l.substring(5,7),16)/255,9===l.length&&(this.a=parseInt(l.substring(7,9),16)/255)),this}toLinearSpace(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new y;return this.toLinearSpaceToRef(a,l),a}toLinearSpaceToRef(l){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(l.r=S(this.r),l.g=S(this.g),l.b=S(this.b)):(l.r=w(this.r),l.g=w(this.g),l.b=w(this.b)),l.a=this.a,this}toGammaSpace(){let l=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const a=new y;return this.toGammaSpaceToRef(a,l),a}toGammaSpaceToRef(l){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(l.r=J(this.r),l.g=J(this.g),l.b=J(this.b)):(l.r=T(this.r),l.g=T(this.g),l.b=T(this.b)),l.a=this.a,this}static FromHexString(l){return"#"!==l.substring(0,1)||9!==l.length&&7!==l.length?new y(0,0,0,0):new y(0,0,0,1).fromHexString(l)}static Lerp(l,a,N){return y.LerpToRef(l,a,N,new y)}static LerpToRef(l,a,N,U){return U.r=l.r+(a.r-l.r)*N,U.g=l.g+(a.g-l.g)*N,U.b=l.b+(a.b-l.b)*N,U.a=l.a+(a.a-l.a)*N,U}static Hermite(l,a,N,U,c){const K=c*c,Z=c*K,w=2*Z-3*K+1,S=-2*Z+3*K,T=Z-2*K+c,J=Z-K,n=l.r*w+N.r*S+a.r*T+U.r*J,H=l.g*w+N.g*S+a.g*T+U.g*J,u=l.b*w+N.b*S+a.b*T+U.b*J,W=l.a*w+N.a*S+a.a*T+U.a*J;return new y(n,H,u,W)}static Hermite1stDerivative(l,a,N,U,c){const K=new y;return this.Hermite1stDerivativeToRef(l,a,N,U,c,K),K}static Hermite1stDerivativeToRef(l,a,N,U,c,K){const Z=c*c;K.r=6*(Z-c)*l.r+(3*Z-4*c+1)*a.r+6*(-Z+c)*N.r+(3*Z-2*c)*U.r,K.g=6*(Z-c)*l.g+(3*Z-4*c+1)*a.g+6*(-Z+c)*N.g+(3*Z-2*c)*U.g,K.b=6*(Z-c)*l.b+(3*Z-4*c+1)*a.b+6*(-Z+c)*N.b+(3*Z-2*c)*U.b,K.a=6*(Z-c)*l.a+(3*Z-4*c+1)*a.a+6*(-Z+c)*N.a+(3*Z-2*c)*U.a}static FromColor3(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new y(l.r,l.g,l.b,a)}static Ma(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new y(l[a],l[a+1],l[a+2],l[a+3])}static FromArrayToRef(l){let a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,N=arguments.length>2?arguments[2]:void 0;N.r=l[a],N.g=l[a+1],N.b=l[a+2],N.a=l[a+3]}static FromInts(l,a,N,U){return new y(l/255,a/255,N/255,U/255)}static CheckColors4(l,a){if(l.length===3*a){const a=[];for(let N=0;N<l.length;N+=3){const U=N/3*4;a[U]=l[N],a[U+1]=l[N+1],a[U+2]=l[N+2],a[U+3]=1}return a}return l}}y._V8PerformanceHack=new y(.5,.5,.5,.5),Object.defineProperties(y.prototype,{dimension:{value:[4]},rank:{value:1}});class H{}H.Ca=(0,U.b)(3,n.Black),H.Qc=(0,U.b)(3,(()=>new y(0,0,0,0))),(0,c.g)("BABYLON.Color3",n),(0,c.g)("BABYLON.Color4",y)}}]);