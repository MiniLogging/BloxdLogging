"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[17],{12453:(V,h,mV)=>{mV.r(h),mV.d(h,{Jh:()=>n,Gk:()=>q,TmpColors:()=>x});var t=mV(12433),L=mV(12388),N=mV(12425),A=mV(12435);function k(V){return Math.pow(V,N.j)}function C(V){return V<=.04045?.0773993808*V:Math.pow(.947867299*(V+.055),2.4)}function K(V){return Math.pow(V,N.g)}function o(V){return V<=.0031308?12.92*V:1.055*Math.pow(V,.41666)-.055}class n{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=V,this.g=h,this.b=mV}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Jh"}getHashCode(){let V=255*this.r|0;return V=397*V^255*this.g,V=397*V^255*this.b,V}toArray(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[h]=this.r,V[h+1]=this.g,V[h+2]=this.b,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return n.FromArrayToRef(V,h,this),this}toColor4(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new q(this.r,this.g,this.b,V)}sk(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(V){return new n(this.r*V.r,this.g*V.g,this.b*V.b)}multiplyToRef(V,h){return h.r=this.r*V.r,h.g=this.g*V.g,h.b=this.b*V.b,h}multiplyInPlace(V){return this.r*=V.r,this.g*=V.g,this.b*=V.b,this}multiplyByFloats(V,h,mV){return new n(this.r*V,this.g*h,this.b*mV)}divide(V){throw new ReferenceError("Can not divide a color")}divideToRef(V,h){throw new ReferenceError("Can not divide a color")}divideInPlace(V){throw new ReferenceError("Can not divide a color")}minimizeInPlace(V){return this.minimizeInPlaceFromFloats(V.r,V.g,V.b)}maximizeInPlace(V){return this.maximizeInPlaceFromFloats(V.r,V.g,V.b)}minimizeInPlaceFromFloats(V,h,mV){return this.r=Math.min(V,this.r),this.g=Math.min(h,this.g),this.b=Math.min(mV,this.b),this}maximizeInPlaceFromFloats(V,h,mV){return this.r=Math.max(V,this.r),this.g=Math.max(h,this.g),this.b=Math.max(mV,this.b),this}floorToRef(V){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(V){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(V){return V&&this.r===V.r&&this.g===V.g&&this.b===V.b}equalsFloats(V,h,mV){return this.equalsToFloats(V,h,mV)}equalsToFloats(V,h,mV){return this.r===V&&this.g===h&&this.b===mV}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return(0,A.WithinEpsilon)(this.r,V.r,h)&&(0,A.WithinEpsilon)(this.g,V.g,h)&&(0,A.WithinEpsilon)(this.b,V.b,h)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(V){throw new ReferenceError("Can not negate a color")}scale(V){return new n(this.r*V,this.g*V,this.b*V)}scaleInPlace(V){return this.r*=V,this.g*=V,this.b*=V,this}scaleToRef(V,h){return h.r=this.r*V,h.g=this.g*V,h.b=this.b*V,h}scaleAndAddToRef(V,h){return h.r+=this.r*V,h.g+=this.g*V,h.b+=this.b*V,h}clampToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,mV=arguments.length>2?arguments[2]:void 0;return mV.r=(0,A.Clamp)(this.r,V,h),mV.g=(0,A.Clamp)(this.g,V,h),mV.b=(0,A.Clamp)(this.b,V,h),mV}add(V){return new n(this.r+V.r,this.g+V.g,this.b+V.b)}addInPlace(V){return this.r+=V.r,this.g+=V.g,this.b+=V.b,this}addInPlaceFromFloats(V,h,mV){return this.r+=V,this.g+=h,this.b+=mV,this}addToRef(V,h){return h.r=this.r+V.r,h.g=this.g+V.g,h.b=this.b+V.b,h}Mh(V){return new n(this.r-V.r,this.g-V.g,this.b-V.b)}subtractToRef(V,h){return h.r=this.r-V.r,h.g=this.g-V.g,h.b=this.b-V.b,h}An(V){return this.r-=V.r,this.g-=V.g,this.b-=V.b,this}subtractFromFloats(V,h,mV){return new n(this.r-V,this.g-h,this.b-mV)}subtractFromFloatsToRef(V,h,mV,t){return t.r=this.r-V,t.g=this.g-h,t.b=this.b-mV,t}clone(){return new n(this.r,this.g,this.b)}t(V){return this.r=V.r,this.g=V.g,this.b=V.b,this}Hk(V,h,mV){return this.r=V,this.g=h,this.b=mV,this}set(V,h,mV){return this.Hk(V,h,mV)}lk(V){return this.r=this.g=this.b=V,this}toHexString(){const V=Math.round(255*this.r),h=Math.round(255*this.g),mV=Math.round(255*this.b);return"#"+(0,A.ToHex)(V)+(0,A.ToHex)(h)+(0,A.ToHex)(mV)}fromHexString(V){return"#"!==V.substring(0,1)||7!==V.length||(this.r=parseInt(V.substring(1,3),16)/255,this.g=parseInt(V.substring(3,5),16)/255,this.b=parseInt(V.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new n)}toHSVToRef(V){const h=this.r,mV=this.g,t=this.b,L=Math.max(h,mV,t),N=Math.min(h,mV,t);let A=0,k=0;const C=L,K=L-N;return 0!==L&&(k=K/L),L!=N&&(L==h?(A=(mV-t)/K,mV<t&&(A+=6)):L==mV?A=(t-h)/K+2:L==t&&(A=(h-mV)/K+4),A*=60),V.r=A,V.g=k,V.b=C,V}toLinearSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new n;return this.toLinearSpaceToRef(h,V),h}toLinearSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=C(this.r),V.g=C(this.g),V.b=C(this.b)):(V.r=k(this.r),V.g=k(this.g),V.b=k(this.b)),this}toGammaSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new n;return this.toGammaSpaceToRef(h,V),h}toGammaSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=o(this.r),V.g=o(this.g),V.b=o(this.b)):(V.r=K(this.r),V.g=K(this.g),V.b=K(this.b)),this}static HSVtoRGBToRef(V,h,mV,t){const L=mV*h,N=V/60,A=L*(1-Math.abs(N%2-1));let k=0,C=0,K=0;N>=0&&N<=1?(k=L,C=A):N>=1&&N<=2?(k=A,C=L):N>=2&&N<=3?(C=L,K=A):N>=3&&N<=4?(C=A,K=L):N>=4&&N<=5?(k=A,K=L):N>=5&&N<=6&&(k=L,K=A);const o=mV-L;return t.r=k+o,t.g=C+o,t.b=K+o,t}static FromHSV(V,h,mV){const t=new n(0,0,0);return n.HSVtoRGBToRef(V,h,mV,t),t}static FromHexString(V){return new n(0,0,0).fromHexString(V)}static Dh(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new n(V[h],V[h+1],V[h+2])}static FromArrayToRef(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2?arguments[2]:void 0;mV.r=V[h],mV.g=V[h+1],mV.b=V[h+2]}static FromInts(V,h,mV){return new n(V/255,h/255,mV/255)}static Lerp(V,h,mV){const t=new n(0,0,0);return n.LerpToRef(V,h,mV,t),t}static LerpToRef(V,h,mV,t){t.r=V.r+(h.r-V.r)*mV,t.g=V.g+(h.g-V.g)*mV,t.b=V.b+(h.b-V.b)*mV}static Hermite(V,h,mV,t,L){const N=L*L,A=L*N,k=2*A-3*N+1,C=-2*A+3*N,K=A-2*N+L,o=A-N,q=V.r*k+mV.r*C+h.r*K+t.r*o,x=V.g*k+mV.g*C+h.g*K+t.g*o,R=V.b*k+mV.b*C+h.b*K+t.b*o;return new n(q,x,R)}static Hermite1stDerivative(V,h,mV,t,L){const N=n.Black();return this.Hermite1stDerivativeToRef(V,h,mV,t,L,N),N}static Hermite1stDerivativeToRef(V,h,mV,t,L,N){const A=L*L;N.r=6*(A-L)*V.r+(3*A-4*L+1)*h.r+6*(-A+L)*mV.r+(3*A-2*L)*t.r,N.g=6*(A-L)*V.g+(3*A-4*L+1)*h.g+6*(-A+L)*mV.g+(3*A-2*L)*t.g,N.b=6*(A-L)*V.b+(3*A-4*L+1)*h.b+6*(-A+L)*mV.b+(3*A-2*L)*t.b}static Red(){return new n(1,0,0)}static Green(){return new n(0,1,0)}static Blue(){return new n(0,0,1)}static Black(){return new n(0,0,0)}static get BlackReadOnly(){return n._BlackReadOnly}static White(){return new n(1,1,1)}static Purple(){return new n(.5,0,.5)}static Magenta(){return new n(1,0,1)}static Yellow(){return new n(1,1,0)}static Gray(){return new n(.5,.5,.5)}static Teal(){return new n(0,1,1)}static Random(){return new n(Math.random(),Math.random(),Math.random())}}n._V8PerformanceHack=new n(.5,.5,.5),n._BlackReadOnly=n.Black(),Object.defineProperties(n.prototype,{dimension:{value:[3]},rank:{value:1}});class q{constructor(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=V,this.g=h,this.b=mV,this.a=t}sk(){return[this.r,this.g,this.b,this.a]}toArray(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return V[h]=this.r,V[h+1]=this.g,V[h+2]=this.b,V[h+3]=this.a,this}Dm(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=V[h],this.g=V[h+1],this.b=V[h+2],this.a=V[h+3],this}equals(V){return V&&this.r===V.r&&this.g===V.g&&this.b===V.b&&this.a===V.a}add(V){return new q(this.r+V.r,this.g+V.g,this.b+V.b,this.a+V.a)}addToRef(V,h){return h.r=this.r+V.r,h.g=this.g+V.g,h.b=this.b+V.b,h.a=this.a+V.a,h}addInPlace(V){return this.r+=V.r,this.g+=V.g,this.b+=V.b,this.a+=V.a,this}addInPlaceFromFloats(V,h,mV,t){return this.r+=V,this.g+=h,this.b+=mV,this.a+=t,this}Mh(V){return new q(this.r-V.r,this.g-V.g,this.b-V.b,this.a-V.a)}subtractToRef(V,h){return h.r=this.r-V.r,h.g=this.g-V.g,h.b=this.b-V.b,h.a=this.a-V.a,h}An(V){return this.r-=V.r,this.g-=V.g,this.b-=V.b,this.a-=V.a,this}subtractFromFloats(V,h,mV,t){return new q(this.r-V,this.g-h,this.b-mV,this.a-t)}subtractFromFloatsToRef(V,h,mV,t,L){return L.r=this.r-V,L.g=this.g-h,L.b=this.b-mV,L.a=this.a-t,L}scale(V){return new q(this.r*V,this.g*V,this.b*V,this.a*V)}scaleInPlace(V){return this.r*=V,this.g*=V,this.b*=V,this.a*=V,this}scaleToRef(V,h){return h.r=this.r*V,h.g=this.g*V,h.b=this.b*V,h.a=this.a*V,h}scaleAndAddToRef(V,h){return h.r+=this.r*V,h.g+=this.g*V,h.b+=this.b*V,h.a+=this.a*V,h}clampToRef(){let V=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,mV=arguments.length>2?arguments[2]:void 0;return mV.r=(0,A.Clamp)(this.r,V,h),mV.g=(0,A.Clamp)(this.g,V,h),mV.b=(0,A.Clamp)(this.b,V,h),mV.a=(0,A.Clamp)(this.a,V,h),mV}multiply(V){return new q(this.r*V.r,this.g*V.g,this.b*V.b,this.a*V.a)}multiplyToRef(V,h){return h.r=this.r*V.r,h.g=this.g*V.g,h.b=this.b*V.b,h.a=this.a*V.a,h}multiplyInPlace(V){return this.r*=V.r,this.g*=V.g,this.b*=V.b,this.a*=V.a,this}multiplyByFloats(V,h,mV,t){return new q(this.r*V,this.g*h,this.b*mV,this.a*t)}divide(V){throw new ReferenceError("Can not divide a color")}divideToRef(V,h){throw new ReferenceError("Can not divide a color")}divideInPlace(V){throw new ReferenceError("Can not divide a color")}minimizeInPlace(V){return this.r=Math.min(this.r,V.r),this.g=Math.min(this.g,V.g),this.b=Math.min(this.b,V.b),this.a=Math.min(this.a,V.a),this}maximizeInPlace(V){return this.r=Math.max(this.r,V.r),this.g=Math.max(this.g,V.g),this.b=Math.max(this.b,V.b),this.a=Math.max(this.a,V.a),this}minimizeInPlaceFromFloats(V,h,mV,t){return this.r=Math.min(V,this.r),this.g=Math.min(h,this.g),this.b=Math.min(mV,this.b),this.a=Math.min(t,this.a),this}maximizeInPlaceFromFloats(V,h,mV,t){return this.r=Math.max(V,this.r),this.g=Math.max(h,this.g),this.b=Math.max(mV,this.b),this.a=Math.max(t,this.a),this}floorToRef(V){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(V){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(V){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.c;return(0,A.WithinEpsilon)(this.r,V.r,h)&&(0,A.WithinEpsilon)(this.g,V.g,h)&&(0,A.WithinEpsilon)(this.b,V.b,h)&&(0,A.WithinEpsilon)(this.a,V.a,h)}equalsToFloats(V,h,mV,t){return this.r===V&&this.g===h&&this.b===mV&&this.a===t}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Gk"}getHashCode(){let V=255*this.r|0;return V=397*V^255*this.g,V=397*V^255*this.b,V=397*V^255*this.a,V}clone(){return(new q).t(this)}t(V){return this.r=V.r,this.g=V.g,this.b=V.b,this.a=V.a,this}Hk(V,h,mV,t){return this.r=V,this.g=h,this.b=mV,this.a=t,this}set(V,h,mV,t){return this.Hk(V,h,mV,t)}lk(V){return this.r=this.g=this.b=this.a=V,this}toHexString(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=Math.round(255*this.r),mV=Math.round(255*this.g),t=Math.round(255*this.b);if(V)return"#"+(0,A.ToHex)(h)+(0,A.ToHex)(mV)+(0,A.ToHex)(t);const L=Math.round(255*this.a);return"#"+(0,A.ToHex)(h)+(0,A.ToHex)(mV)+(0,A.ToHex)(t)+(0,A.ToHex)(L)}fromHexString(V){return"#"!==V.substring(0,1)||9!==V.length&&7!==V.length||(this.r=parseInt(V.substring(1,3),16)/255,this.g=parseInt(V.substring(3,5),16)/255,this.b=parseInt(V.substring(5,7),16)/255,9===V.length&&(this.a=parseInt(V.substring(7,9),16)/255)),this}toLinearSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new q;return this.toLinearSpaceToRef(h,V),h}toLinearSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=C(this.r),V.g=C(this.g),V.b=C(this.b)):(V.r=k(this.r),V.g=k(this.g),V.b=k(this.b)),V.a=this.a,this}toGammaSpace(){let V=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new q;return this.toGammaSpaceToRef(h,V),h}toGammaSpaceToRef(V){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(V.r=o(this.r),V.g=o(this.g),V.b=o(this.b)):(V.r=K(this.r),V.g=K(this.g),V.b=K(this.b)),V.a=this.a,this}static FromHexString(V){return"#"!==V.substring(0,1)||9!==V.length&&7!==V.length?new q(0,0,0,0):new q(0,0,0,1).fromHexString(V)}static Lerp(V,h,mV){return q.LerpToRef(V,h,mV,new q)}static LerpToRef(V,h,mV,t){return t.r=V.r+(h.r-V.r)*mV,t.g=V.g+(h.g-V.g)*mV,t.b=V.b+(h.b-V.b)*mV,t.a=V.a+(h.a-V.a)*mV,t}static Hermite(V,h,mV,t,L){const N=L*L,A=L*N,k=2*A-3*N+1,C=-2*A+3*N,K=A-2*N+L,o=A-N,n=V.r*k+mV.r*C+h.r*K+t.r*o,x=V.g*k+mV.g*C+h.g*K+t.g*o,R=V.b*k+mV.b*C+h.b*K+t.b*o,d=V.a*k+mV.a*C+h.a*K+t.a*o;return new q(n,x,R,d)}static Hermite1stDerivative(V,h,mV,t,L){const N=new q;return this.Hermite1stDerivativeToRef(V,h,mV,t,L,N),N}static Hermite1stDerivativeToRef(V,h,mV,t,L,N){const A=L*L;N.r=6*(A-L)*V.r+(3*A-4*L+1)*h.r+6*(-A+L)*mV.r+(3*A-2*L)*t.r,N.g=6*(A-L)*V.g+(3*A-4*L+1)*h.g+6*(-A+L)*mV.g+(3*A-2*L)*t.g,N.b=6*(A-L)*V.b+(3*A-4*L+1)*h.b+6*(-A+L)*mV.b+(3*A-2*L)*t.b,N.a=6*(A-L)*V.a+(3*A-4*L+1)*h.a+6*(-A+L)*mV.a+(3*A-2*L)*t.a}static FromColor3(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new q(V.r,V.g,V.b,h)}static Dh(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(V[h],V[h+1],V[h+2],V[h+3])}static FromArrayToRef(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2?arguments[2]:void 0;mV.r=V[h],mV.g=V[h+1],mV.b=V[h+2],mV.a=V[h+3]}static FromInts(V,h,mV,t){return new q(V/255,h/255,mV/255,t/255)}static CheckColors4(V,h){if(V.length===3*h){const h=[];for(let mV=0;mV<V.length;mV+=3){const t=mV/3*4;h[t]=V[mV],h[t+1]=V[mV+1],h[t+2]=V[mV+2],h[t+3]=1}return h}return V}}q._V8PerformanceHack=new q(.5,.5,.5,.5),Object.defineProperties(q.prototype,{dimension:{value:[4]},rank:{value:1}});class x{}x.Jh=(0,t.c)(3,n.Black),x.Gk=(0,t.c)(3,(()=>new q(0,0,0,0))),(0,L.i)("BABYLON.Color3",n),(0,L.i)("BABYLON.Color4",q)}}]);