"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[17],{11355:(H,O,S)=>{S.r(O),S.d(O,{TO:()=>h,EU:()=>a,TmpColors:()=>j});var t=S(11310),q=S(11262),p=S(11307),G=S(11317);function U(H){return Math.pow(H,p.i)}function V(H){return H<=.04045?.0773993808*H:Math.pow(.947867299*(H+.055),2.4)}function w(H){return Math.pow(H,p.h)}function o(H){return H<=.0031308?12.92*H:1.055*Math.pow(H,.41666)-.055}class h{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=H,this.g=O,this.b=S}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"TO"}getHashCode(){let H=255*this.r|0;return H=397*H^255*this.g,H=397*H^255*this.b,H}toArray(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[O]=this.r,H[O+1]=this.g,H[O+2]=this.b,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(H,O,this),this}toColor4(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new a(this.r,this.g,this.b,H)}pU(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(H){return new h(this.r*H.r,this.g*H.g,this.b*H.b)}multiplyToRef(H,O){return O.r=this.r*H.r,O.g=this.g*H.g,O.b=this.b*H.b,O}multiplyInPlace(H){return this.r*=H.r,this.g*=H.g,this.b*=H.b,this}multiplyByFloats(H,O,S){return new h(this.r*H,this.g*O,this.b*S)}divide(H){throw new ReferenceError("Can not divide a color")}divideToRef(H,O){throw new ReferenceError("Can not divide a color")}divideInPlace(H){throw new ReferenceError("Can not divide a color")}minimizeInPlace(H){return this.minimizeInPlaceFromFloats(H.r,H.g,H.b)}maximizeInPlace(H){return this.maximizeInPlaceFromFloats(H.r,H.g,H.b)}minimizeInPlaceFromFloats(H,O,S){return this.r=Math.min(H,this.r),this.g=Math.min(O,this.g),this.b=Math.min(S,this.b),this}maximizeInPlaceFromFloats(H,O,S){return this.r=Math.max(H,this.r),this.g=Math.max(O,this.g),this.b=Math.max(S,this.b),this}floorToRef(H){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(H){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(H){return H&&this.r===H.r&&this.g===H.g&&this.b===H.b}equalsFloats(H,O,S){return this.equalsToFloats(H,O,S)}equalsToFloats(H,O,S){return this.r===H&&this.g===O&&this.b===S}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.e;return(0,G.WithinEpsilon)(this.r,H.r,O)&&(0,G.WithinEpsilon)(this.g,H.g,O)&&(0,G.WithinEpsilon)(this.b,H.b,O)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(H){throw new ReferenceError("Can not negate a color")}scale(H){return new h(this.r*H,this.g*H,this.b*H)}scaleInPlace(H){return this.r*=H,this.g*=H,this.b*=H,this}scaleToRef(H,O){return O.r=this.r*H,O.g=this.g*H,O.b=this.b*H,O}scaleAndAddToRef(H,O){return O.r+=this.r*H,O.g+=this.g*H,O.b+=this.b*H,O}clampToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,S=arguments.length>2?arguments[2]:void 0;return S.r=(0,G.Clamp)(this.r,H,O),S.g=(0,G.Clamp)(this.g,H,O),S.b=(0,G.Clamp)(this.b,H,O),S}add(H){return new h(this.r+H.r,this.g+H.g,this.b+H.b)}addInPlace(H){return this.r+=H.r,this.g+=H.g,this.b+=H.b,this}addInPlaceFromFloats(H,O,S){return this.r+=H,this.g+=O,this.b+=S,this}addToRef(H,O){return O.r=this.r+H.r,O.g=this.g+H.g,O.b=this.b+H.b,O}XO(H){return new h(this.r-H.r,this.g-H.g,this.b-H.b)}subtractToRef(H,O){return O.r=this.r-H.r,O.g=this.g-H.g,O.b=this.b-H.b,O}Mo(H){return this.r-=H.r,this.g-=H.g,this.b-=H.b,this}subtractFromFloats(H,O,S){return new h(this.r-H,this.g-O,this.b-S)}subtractFromFloatsToRef(H,O,S,t){return t.r=this.r-H,t.g=this.g-O,t.b=this.b-S,t}clone(){return new h(this.r,this.g,this.b)}t(H){return this.r=H.r,this.g=H.g,this.b=H.b,this}jU(H,O,S){return this.r=H,this.g=O,this.b=S,this}set(H,O,S){return this.jU(H,O,S)}XU(H){return this.r=this.g=this.b=H,this}toHexString(){const H=Math.round(255*this.r),O=Math.round(255*this.g),S=Math.round(255*this.b);return"#"+(0,G.ToHex)(H)+(0,G.ToHex)(O)+(0,G.ToHex)(S)}fromHexString(H){return"#"!==H.substring(0,1)||7!==H.length||(this.r=parseInt(H.substring(1,3),16)/255,this.g=parseInt(H.substring(3,5),16)/255,this.b=parseInt(H.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new h)}toHSVToRef(H){const O=this.r,S=this.g,t=this.b,q=Math.max(O,S,t),p=Math.min(O,S,t);let G=0,U=0;const V=q,w=q-p;return 0!==q&&(U=w/q),q!=p&&(q==O?(G=(S-t)/w,S<t&&(G+=6)):q==S?G=(t-O)/w+2:q==t&&(G=(O-S)/w+4),G*=60),H.r=G,H.g=U,H.b=V,H}toLinearSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new h;return this.toLinearSpaceToRef(O,H),O}toLinearSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=V(this.r),H.g=V(this.g),H.b=V(this.b)):(H.r=U(this.r),H.g=U(this.g),H.b=U(this.b)),this}toGammaSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new h;return this.toGammaSpaceToRef(O,H),O}toGammaSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=o(this.r),H.g=o(this.g),H.b=o(this.b)):(H.r=w(this.r),H.g=w(this.g),H.b=w(this.b)),this}static HSVtoRGBToRef(H,O,S,t){const q=S*O,p=H/60,G=q*(1-Math.abs(p%2-1));let U=0,V=0,w=0;p>=0&&p<=1?(U=q,V=G):p>=1&&p<=2?(U=G,V=q):p>=2&&p<=3?(V=q,w=G):p>=3&&p<=4?(V=G,w=q):p>=4&&p<=5?(U=G,w=q):p>=5&&p<=6&&(U=q,w=G);const o=S-q;return t.r=U+o,t.g=V+o,t.b=w+o,t}static FromHSV(H,O,S){const t=new h(0,0,0);return h.HSVtoRGBToRef(H,O,S,t),t}static FromHexString(H){return new h(0,0,0).fromHexString(H)}static KO(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(H[O],H[O+1],H[O+2])}static FromArrayToRef(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2?arguments[2]:void 0;S.r=H[O],S.g=H[O+1],S.b=H[O+2]}static FromInts(H,O,S){return new h(H/255,O/255,S/255)}static Lerp(H,O,S){const t=new h(0,0,0);return h.LerpToRef(H,O,S,t),t}static LerpToRef(H,O,S,t){t.r=H.r+(O.r-H.r)*S,t.g=H.g+(O.g-H.g)*S,t.b=H.b+(O.b-H.b)*S}static Hermite(H,O,S,t,q){const p=q*q,G=q*p,U=2*G-3*p+1,V=-2*G+3*p,w=G-2*p+q,o=G-p,a=H.r*U+S.r*V+O.r*w+t.r*o,j=H.g*U+S.g*V+O.g*w+t.g*o,e=H.b*U+S.b*V+O.b*w+t.b*o;return new h(a,j,e)}static Hermite1stDerivative(H,O,S,t,q){const p=h.Black();return this.Hermite1stDerivativeToRef(H,O,S,t,q,p),p}static Hermite1stDerivativeToRef(H,O,S,t,q,p){const G=q*q;p.r=6*(G-q)*H.r+(3*G-4*q+1)*O.r+6*(-G+q)*S.r+(3*G-2*q)*t.r,p.g=6*(G-q)*H.g+(3*G-4*q+1)*O.g+6*(-G+q)*S.g+(3*G-2*q)*t.g,p.b=6*(G-q)*H.b+(3*G-4*q+1)*O.b+6*(-G+q)*S.b+(3*G-2*q)*t.b}static Red(){return new h(1,0,0)}static Green(){return new h(0,1,0)}static Blue(){return new h(0,0,1)}static Black(){return new h(0,0,0)}static get BlackReadOnly(){return h._BlackReadOnly}static White(){return new h(1,1,1)}static Purple(){return new h(.5,0,.5)}static Magenta(){return new h(1,0,1)}static Yellow(){return new h(1,1,0)}static Gray(){return new h(.5,.5,.5)}static Teal(){return new h(0,1,1)}static Random(){return new h(Math.random(),Math.random(),Math.random())}}h._V8PerformanceHack=new h(.5,.5,.5),h._BlackReadOnly=h.Black(),Object.defineProperties(h.prototype,{dimension:{value:[3]},rank:{value:1}});class a{constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=H,this.g=O,this.b=S,this.a=t}pU(){return[this.r,this.g,this.b,this.a]}toArray(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return H[O]=this.r,H[O+1]=this.g,H[O+2]=this.b,H[O+3]=this.a,this}jS(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=H[O],this.g=H[O+1],this.b=H[O+2],this.a=H[O+3],this}equals(H){return H&&this.r===H.r&&this.g===H.g&&this.b===H.b&&this.a===H.a}add(H){return new a(this.r+H.r,this.g+H.g,this.b+H.b,this.a+H.a)}addToRef(H,O){return O.r=this.r+H.r,O.g=this.g+H.g,O.b=this.b+H.b,O.a=this.a+H.a,O}addInPlace(H){return this.r+=H.r,this.g+=H.g,this.b+=H.b,this.a+=H.a,this}addInPlaceFromFloats(H,O,S,t){return this.r+=H,this.g+=O,this.b+=S,this.a+=t,this}XO(H){return new a(this.r-H.r,this.g-H.g,this.b-H.b,this.a-H.a)}subtractToRef(H,O){return O.r=this.r-H.r,O.g=this.g-H.g,O.b=this.b-H.b,O.a=this.a-H.a,O}Mo(H){return this.r-=H.r,this.g-=H.g,this.b-=H.b,this.a-=H.a,this}subtractFromFloats(H,O,S,t){return new a(this.r-H,this.g-O,this.b-S,this.a-t)}subtractFromFloatsToRef(H,O,S,t,q){return q.r=this.r-H,q.g=this.g-O,q.b=this.b-S,q.a=this.a-t,q}scale(H){return new a(this.r*H,this.g*H,this.b*H,this.a*H)}scaleInPlace(H){return this.r*=H,this.g*=H,this.b*=H,this.a*=H,this}scaleToRef(H,O){return O.r=this.r*H,O.g=this.g*H,O.b=this.b*H,O.a=this.a*H,O}scaleAndAddToRef(H,O){return O.r+=this.r*H,O.g+=this.g*H,O.b+=this.b*H,O.a+=this.a*H,O}clampToRef(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,S=arguments.length>2?arguments[2]:void 0;return S.r=(0,G.Clamp)(this.r,H,O),S.g=(0,G.Clamp)(this.g,H,O),S.b=(0,G.Clamp)(this.b,H,O),S.a=(0,G.Clamp)(this.a,H,O),S}multiply(H){return new a(this.r*H.r,this.g*H.g,this.b*H.b,this.a*H.a)}multiplyToRef(H,O){return O.r=this.r*H.r,O.g=this.g*H.g,O.b=this.b*H.b,O.a=this.a*H.a,O}multiplyInPlace(H){return this.r*=H.r,this.g*=H.g,this.b*=H.b,this.a*=H.a,this}multiplyByFloats(H,O,S,t){return new a(this.r*H,this.g*O,this.b*S,this.a*t)}divide(H){throw new ReferenceError("Can not divide a color")}divideToRef(H,O){throw new ReferenceError("Can not divide a color")}divideInPlace(H){throw new ReferenceError("Can not divide a color")}minimizeInPlace(H){return this.r=Math.min(this.r,H.r),this.g=Math.min(this.g,H.g),this.b=Math.min(this.b,H.b),this.a=Math.min(this.a,H.a),this}maximizeInPlace(H){return this.r=Math.max(this.r,H.r),this.g=Math.max(this.g,H.g),this.b=Math.max(this.b,H.b),this.a=Math.max(this.a,H.a),this}minimizeInPlaceFromFloats(H,O,S,t){return this.r=Math.min(H,this.r),this.g=Math.min(O,this.g),this.b=Math.min(S,this.b),this.a=Math.min(t,this.a),this}maximizeInPlaceFromFloats(H,O,S,t){return this.r=Math.max(H,this.r),this.g=Math.max(O,this.g),this.b=Math.max(S,this.b),this.a=Math.max(t,this.a),this}floorToRef(H){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(H){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(H){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.e;return(0,G.WithinEpsilon)(this.r,H.r,O)&&(0,G.WithinEpsilon)(this.g,H.g,O)&&(0,G.WithinEpsilon)(this.b,H.b,O)&&(0,G.WithinEpsilon)(this.a,H.a,O)}equalsToFloats(H,O,S,t){return this.r===H&&this.g===O&&this.b===S&&this.a===t}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"EU"}getHashCode(){let H=255*this.r|0;return H=397*H^255*this.g,H=397*H^255*this.b,H=397*H^255*this.a,H}clone(){return(new a).t(this)}t(H){return this.r=H.r,this.g=H.g,this.b=H.b,this.a=H.a,this}jU(H,O,S,t){return this.r=H,this.g=O,this.b=S,this.a=t,this}set(H,O,S,t){return this.jU(H,O,S,t)}XU(H){return this.r=this.g=this.b=this.a=H,this}toHexString(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=Math.round(255*this.r),S=Math.round(255*this.g),t=Math.round(255*this.b);if(H)return"#"+(0,G.ToHex)(O)+(0,G.ToHex)(S)+(0,G.ToHex)(t);const q=Math.round(255*this.a);return"#"+(0,G.ToHex)(O)+(0,G.ToHex)(S)+(0,G.ToHex)(t)+(0,G.ToHex)(q)}fromHexString(H){return"#"!==H.substring(0,1)||9!==H.length&&7!==H.length||(this.r=parseInt(H.substring(1,3),16)/255,this.g=parseInt(H.substring(3,5),16)/255,this.b=parseInt(H.substring(5,7),16)/255,9===H.length&&(this.a=parseInt(H.substring(7,9),16)/255)),this}toLinearSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new a;return this.toLinearSpaceToRef(O,H),O}toLinearSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=V(this.r),H.g=V(this.g),H.b=V(this.b)):(H.r=U(this.r),H.g=U(this.g),H.b=U(this.b)),H.a=this.a,this}toGammaSpace(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new a;return this.toGammaSpaceToRef(O,H),O}toGammaSpaceToRef(H){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(H.r=o(this.r),H.g=o(this.g),H.b=o(this.b)):(H.r=w(this.r),H.g=w(this.g),H.b=w(this.b)),H.a=this.a,this}static FromHexString(H){return"#"!==H.substring(0,1)||9!==H.length&&7!==H.length?new a(0,0,0,0):new a(0,0,0,1).fromHexString(H)}static Lerp(H,O,S){return a.LerpToRef(H,O,S,new a)}static LerpToRef(H,O,S,t){return t.r=H.r+(O.r-H.r)*S,t.g=H.g+(O.g-H.g)*S,t.b=H.b+(O.b-H.b)*S,t.a=H.a+(O.a-H.a)*S,t}static Hermite(H,O,S,t,q){const p=q*q,G=q*p,U=2*G-3*p+1,V=-2*G+3*p,w=G-2*p+q,o=G-p,h=H.r*U+S.r*V+O.r*w+t.r*o,j=H.g*U+S.g*V+O.g*w+t.g*o,e=H.b*U+S.b*V+O.b*w+t.b*o,X=H.a*U+S.a*V+O.a*w+t.a*o;return new a(h,j,e,X)}static Hermite1stDerivative(H,O,S,t,q){const p=new a;return this.Hermite1stDerivativeToRef(H,O,S,t,q,p),p}static Hermite1stDerivativeToRef(H,O,S,t,q,p){const G=q*q;p.r=6*(G-q)*H.r+(3*G-4*q+1)*O.r+6*(-G+q)*S.r+(3*G-2*q)*t.r,p.g=6*(G-q)*H.g+(3*G-4*q+1)*O.g+6*(-G+q)*S.g+(3*G-2*q)*t.g,p.b=6*(G-q)*H.b+(3*G-4*q+1)*O.b+6*(-G+q)*S.b+(3*G-2*q)*t.b,p.a=6*(G-q)*H.a+(3*G-4*q+1)*O.a+6*(-G+q)*S.a+(3*G-2*q)*t.a}static FromColor3(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new a(H.r,H.g,H.b,O)}static KO(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new a(H[O],H[O+1],H[O+2],H[O+3])}static FromArrayToRef(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2?arguments[2]:void 0;S.r=H[O],S.g=H[O+1],S.b=H[O+2],S.a=H[O+3]}static FromInts(H,O,S,t){return new a(H/255,O/255,S/255,t/255)}static CheckColors4(H,O){if(H.length===3*O){const O=[];for(let S=0;S<H.length;S+=3){const t=S/3*4;O[t]=H[S],O[t+1]=H[S+1],O[t+2]=H[S+2],O[t+3]=1}return O}return H}}a._V8PerformanceHack=new a(.5,.5,.5,.5),Object.defineProperties(a.prototype,{dimension:{value:[4]},rank:{value:1}});class j{}j.TO=(0,t.d)(3,h.Black),j.EU=(0,t.d)(3,(()=>new a(0,0,0,0))),(0,q.g)("BABYLON.Color3",h),(0,q.g)("BABYLON.Color4",a)}}]);