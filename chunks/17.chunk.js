"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[17],{11329:(K,H,M)=>{M.r(H),M.d(H,{CH:()=>z,Ch:()=>G,TmpColors:()=>a});var q=M(11301),w=M(11242),u=M(11297),y=M(11307);function h(K){return Math.pow(K,u.l)}function W(K){return K<=.04045?.0773993808*K:Math.pow(.947867299*(K+.055),2.4)}function I(K){return Math.pow(K,u.h)}function f(K){return K<=.0031308?12.92*K:1.055*Math.pow(K,.41666)-.055}class z{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=K,this.g=H,this.b=M}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"CH"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K}toArray(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[H]=this.r,K[H+1]=this.g,K[H+2]=this.b,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return z.FromArrayToRef(K,H,this),this}toColor4(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new G(this.r,this.g,this.b,K)}hh(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(K){return new z(this.r*K.r,this.g*K.g,this.b*K.b)}multiplyToRef(K,H){return H.r=this.r*K.r,H.g=this.g*K.g,H.b=this.b*K.b,H}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this}multiplyByFloats(K,H,M){return new z(this.r*K,this.g*H,this.b*M)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,H){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.minimizeInPlaceFromFloats(K.r,K.g,K.b)}maximizeInPlace(K){return this.maximizeInPlaceFromFloats(K.r,K.g,K.b)}minimizeInPlaceFromFloats(K,H,M){return this.r=Math.min(K,this.r),this.g=Math.min(H,this.g),this.b=Math.min(M,this.b),this}maximizeInPlaceFromFloats(K,H,M){return this.r=Math.max(K,this.r),this.g=Math.max(H,this.g),this.b=Math.max(M,this.b),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b}equalsFloats(K,H,M){return this.equalsToFloats(K,H,M)}equalsToFloats(K,H,M){return this.r===K&&this.g===H&&this.b===M}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return(0,y.WithinEpsilon)(this.r,K.r,H)&&(0,y.WithinEpsilon)(this.g,K.g,H)&&(0,y.WithinEpsilon)(this.b,K.b,H)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}scale(K){return new z(this.r*K,this.g*K,this.b*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this}scaleToRef(K,H){return H.r=this.r*K,H.g=this.g*K,H.b=this.b*K,H}scaleAndAddToRef(K,H){return H.r+=this.r*K,H.g+=this.g*K,H.b+=this.b*K,H}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,M=arguments.length>2?arguments[2]:void 0;return M.r=(0,y.Clamp)(this.r,K,H),M.g=(0,y.Clamp)(this.g,K,H),M.b=(0,y.Clamp)(this.b,K,H),M}add(K){return new z(this.r+K.r,this.g+K.g,this.b+K.b)}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this}addInPlaceFromFloats(K,H,M){return this.r+=K,this.g+=H,this.b+=M,this}addToRef(K,H){return H.r=this.r+K.r,H.g=this.g+K.g,H.b=this.b+K.b,H}LH(K){return new z(this.r-K.r,this.g-K.g,this.b-K.b)}subtractToRef(K,H){return H.r=this.r-K.r,H.g=this.g-K.g,H.b=this.b-K.b,H}Zz(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this}subtractFromFloats(K,H,M){return new z(this.r-K,this.g-H,this.b-M)}subtractFromFloatsToRef(K,H,M,q){return q.r=this.r-K,q.g=this.g-H,q.b=this.b-M,q}clone(){return new z(this.r,this.g,this.b)}q(K){return this.r=K.r,this.g=K.g,this.b=K.b,this}Lh(K,H,M){return this.r=K,this.g=H,this.b=M,this}set(K,H,M){return this.Lh(K,H,M)}Bh(K){return this.r=this.g=this.b=K,this}toHexString(){const K=Math.round(255*this.r),H=Math.round(255*this.g),M=Math.round(255*this.b);return"#"+(0,y.ToHex)(K)+(0,y.ToHex)(H)+(0,y.ToHex)(M)}fromHexString(K){return"#"!==K.substring(0,1)||7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new z)}toHSVToRef(K){const H=this.r,M=this.g,q=this.b,w=Math.max(H,M,q),u=Math.min(H,M,q);let y=0,h=0;const W=w,I=w-u;return 0!==w&&(h=I/w),w!=u&&(w==H?(y=(M-q)/I,M<q&&(y+=6)):w==M?y=(q-H)/I+2:w==q&&(y=(H-M)/I+4),y*=60),K.r=y,K.g=h,K.b=W,K}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new z;return this.toLinearSpaceToRef(H,K),H}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=W(this.r),K.g=W(this.g),K.b=W(this.b)):(K.r=h(this.r),K.g=h(this.g),K.b=h(this.b)),this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new z;return this.toGammaSpaceToRef(H,K),H}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=f(this.r),K.g=f(this.g),K.b=f(this.b)):(K.r=I(this.r),K.g=I(this.g),K.b=I(this.b)),this}static HSVtoRGBToRef(K,H,M,q){const w=M*H,u=K/60,y=w*(1-Math.abs(u%2-1));let h=0,W=0,I=0;u>=0&&u<=1?(h=w,W=y):u>=1&&u<=2?(h=y,W=w):u>=2&&u<=3?(W=w,I=y):u>=3&&u<=4?(W=y,I=w):u>=4&&u<=5?(h=y,I=w):u>=5&&u<=6&&(h=w,I=y);const f=M-w;return q.r=h+f,q.g=W+f,q.b=I+f,q}static FromHSV(K,H,M){const q=new z(0,0,0);return z.HSVtoRGBToRef(K,H,M,q),q}static FromHexString(K){return new z(0,0,0).fromHexString(K)}static iH(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new z(K[H],K[H+1],K[H+2])}static FromArrayToRef(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2?arguments[2]:void 0;M.r=K[H],M.g=K[H+1],M.b=K[H+2]}static FromInts(K,H,M){return new z(K/255,H/255,M/255)}static Lerp(K,H,M){const q=new z(0,0,0);return z.LerpToRef(K,H,M,q),q}static LerpToRef(K,H,M,q){q.r=K.r+(H.r-K.r)*M,q.g=K.g+(H.g-K.g)*M,q.b=K.b+(H.b-K.b)*M}static Hermite(K,H,M,q,w){const u=w*w,y=w*u,h=2*y-3*u+1,W=-2*y+3*u,I=y-2*u+w,f=y-u,G=K.r*h+M.r*W+H.r*I+q.r*f,a=K.g*h+M.g*W+H.g*I+q.g*f,v=K.b*h+M.b*W+H.b*I+q.b*f;return new z(G,a,v)}static Hermite1stDerivative(K,H,M,q,w){const u=z.Black();return this.Hermite1stDerivativeToRef(K,H,M,q,w,u),u}static Hermite1stDerivativeToRef(K,H,M,q,w,u){const y=w*w;u.r=6*(y-w)*K.r+(3*y-4*w+1)*H.r+6*(-y+w)*M.r+(3*y-2*w)*q.r,u.g=6*(y-w)*K.g+(3*y-4*w+1)*H.g+6*(-y+w)*M.g+(3*y-2*w)*q.g,u.b=6*(y-w)*K.b+(3*y-4*w+1)*H.b+6*(-y+w)*M.b+(3*y-2*w)*q.b}static Red(){return new z(1,0,0)}static Green(){return new z(0,1,0)}static Blue(){return new z(0,0,1)}static Black(){return new z(0,0,0)}static get BlackReadOnly(){return z._BlackReadOnly}static White(){return new z(1,1,1)}static Purple(){return new z(.5,0,.5)}static Magenta(){return new z(1,0,1)}static Yellow(){return new z(1,1,0)}static Gray(){return new z(.5,.5,.5)}static Teal(){return new z(0,1,1)}static Random(){return new z(Math.random(),Math.random(),Math.random())}}z._V8PerformanceHack=new z(.5,.5,.5),z._BlackReadOnly=z.Black(),Object.defineProperties(z.prototype,{dimension:{value:[3]},rank:{value:1}});class G{constructor(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=K,this.g=H,this.b=M,this.a=q}hh(){return[this.r,this.g,this.b,this.a]}toArray(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return K[H]=this.r,K[H+1]=this.g,K[H+2]=this.b,K[H+3]=this.a,this}aM(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=K[H],this.g=K[H+1],this.b=K[H+2],this.a=K[H+3],this}equals(K){return K&&this.r===K.r&&this.g===K.g&&this.b===K.b&&this.a===K.a}add(K){return new G(this.r+K.r,this.g+K.g,this.b+K.b,this.a+K.a)}addToRef(K,H){return H.r=this.r+K.r,H.g=this.g+K.g,H.b=this.b+K.b,H.a=this.a+K.a,H}addInPlace(K){return this.r+=K.r,this.g+=K.g,this.b+=K.b,this.a+=K.a,this}addInPlaceFromFloats(K,H,M,q){return this.r+=K,this.g+=H,this.b+=M,this.a+=q,this}LH(K){return new G(this.r-K.r,this.g-K.g,this.b-K.b,this.a-K.a)}subtractToRef(K,H){return H.r=this.r-K.r,H.g=this.g-K.g,H.b=this.b-K.b,H.a=this.a-K.a,H}Zz(K){return this.r-=K.r,this.g-=K.g,this.b-=K.b,this.a-=K.a,this}subtractFromFloats(K,H,M,q){return new G(this.r-K,this.g-H,this.b-M,this.a-q)}subtractFromFloatsToRef(K,H,M,q,w){return w.r=this.r-K,w.g=this.g-H,w.b=this.b-M,w.a=this.a-q,w}scale(K){return new G(this.r*K,this.g*K,this.b*K,this.a*K)}scaleInPlace(K){return this.r*=K,this.g*=K,this.b*=K,this.a*=K,this}scaleToRef(K,H){return H.r=this.r*K,H.g=this.g*K,H.b=this.b*K,H.a=this.a*K,H}scaleAndAddToRef(K,H){return H.r+=this.r*K,H.g+=this.g*K,H.b+=this.b*K,H.a+=this.a*K,H}clampToRef(){let K=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,M=arguments.length>2?arguments[2]:void 0;return M.r=(0,y.Clamp)(this.r,K,H),M.g=(0,y.Clamp)(this.g,K,H),M.b=(0,y.Clamp)(this.b,K,H),M.a=(0,y.Clamp)(this.a,K,H),M}multiply(K){return new G(this.r*K.r,this.g*K.g,this.b*K.b,this.a*K.a)}multiplyToRef(K,H){return H.r=this.r*K.r,H.g=this.g*K.g,H.b=this.b*K.b,H.a=this.a*K.a,H}multiplyInPlace(K){return this.r*=K.r,this.g*=K.g,this.b*=K.b,this.a*=K.a,this}multiplyByFloats(K,H,M,q){return new G(this.r*K,this.g*H,this.b*M,this.a*q)}divide(K){throw new ReferenceError("Can not divide a color")}divideToRef(K,H){throw new ReferenceError("Can not divide a color")}divideInPlace(K){throw new ReferenceError("Can not divide a color")}minimizeInPlace(K){return this.r=Math.min(this.r,K.r),this.g=Math.min(this.g,K.g),this.b=Math.min(this.b,K.b),this.a=Math.min(this.a,K.a),this}maximizeInPlace(K){return this.r=Math.max(this.r,K.r),this.g=Math.max(this.g,K.g),this.b=Math.max(this.b,K.b),this.a=Math.max(this.a,K.a),this}minimizeInPlaceFromFloats(K,H,M,q){return this.r=Math.min(K,this.r),this.g=Math.min(H,this.g),this.b=Math.min(M,this.b),this.a=Math.min(q,this.a),this}maximizeInPlaceFromFloats(K,H,M,q){return this.r=Math.max(K,this.r),this.g=Math.max(H,this.g),this.b=Math.max(M,this.b),this.a=Math.max(q,this.a),this}floorToRef(K){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(K){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(K){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:u.d;return(0,y.WithinEpsilon)(this.r,K.r,H)&&(0,y.WithinEpsilon)(this.g,K.g,H)&&(0,y.WithinEpsilon)(this.b,K.b,H)&&(0,y.WithinEpsilon)(this.a,K.a,H)}equalsToFloats(K,H,M,q){return this.r===K&&this.g===H&&this.b===M&&this.a===q}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Ch"}getHashCode(){let K=255*this.r|0;return K=397*K^255*this.g,K=397*K^255*this.b,K=397*K^255*this.a,K}clone(){return(new G).q(this)}q(K){return this.r=K.r,this.g=K.g,this.b=K.b,this.a=K.a,this}Lh(K,H,M,q){return this.r=K,this.g=H,this.b=M,this.a=q,this}set(K,H,M,q){return this.Lh(K,H,M,q)}Bh(K){return this.r=this.g=this.b=this.a=K,this}toHexString(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=Math.round(255*this.r),M=Math.round(255*this.g),q=Math.round(255*this.b);if(K)return"#"+(0,y.ToHex)(H)+(0,y.ToHex)(M)+(0,y.ToHex)(q);const w=Math.round(255*this.a);return"#"+(0,y.ToHex)(H)+(0,y.ToHex)(M)+(0,y.ToHex)(q)+(0,y.ToHex)(w)}fromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length||(this.r=parseInt(K.substring(1,3),16)/255,this.g=parseInt(K.substring(3,5),16)/255,this.b=parseInt(K.substring(5,7),16)/255,9===K.length&&(this.a=parseInt(K.substring(7,9),16)/255)),this}toLinearSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new G;return this.toLinearSpaceToRef(H,K),H}toLinearSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=W(this.r),K.g=W(this.g),K.b=W(this.b)):(K.r=h(this.r),K.g=h(this.g),K.b=h(this.b)),K.a=this.a,this}toGammaSpace(){let K=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const H=new G;return this.toGammaSpaceToRef(H,K),H}toGammaSpaceToRef(K){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(K.r=f(this.r),K.g=f(this.g),K.b=f(this.b)):(K.r=I(this.r),K.g=I(this.g),K.b=I(this.b)),K.a=this.a,this}static FromHexString(K){return"#"!==K.substring(0,1)||9!==K.length&&7!==K.length?new G(0,0,0,0):new G(0,0,0,1).fromHexString(K)}static Lerp(K,H,M){return G.LerpToRef(K,H,M,new G)}static LerpToRef(K,H,M,q){return q.r=K.r+(H.r-K.r)*M,q.g=K.g+(H.g-K.g)*M,q.b=K.b+(H.b-K.b)*M,q.a=K.a+(H.a-K.a)*M,q}static Hermite(K,H,M,q,w){const u=w*w,y=w*u,h=2*y-3*u+1,W=-2*y+3*u,I=y-2*u+w,f=y-u,z=K.r*h+M.r*W+H.r*I+q.r*f,a=K.g*h+M.g*W+H.g*I+q.g*f,v=K.b*h+M.b*W+H.b*I+q.b*f,O=K.a*h+M.a*W+H.a*I+q.a*f;return new G(z,a,v,O)}static Hermite1stDerivative(K,H,M,q,w){const u=new G;return this.Hermite1stDerivativeToRef(K,H,M,q,w,u),u}static Hermite1stDerivativeToRef(K,H,M,q,w,u){const y=w*w;u.r=6*(y-w)*K.r+(3*y-4*w+1)*H.r+6*(-y+w)*M.r+(3*y-2*w)*q.r,u.g=6*(y-w)*K.g+(3*y-4*w+1)*H.g+6*(-y+w)*M.g+(3*y-2*w)*q.g,u.b=6*(y-w)*K.b+(3*y-4*w+1)*H.b+6*(-y+w)*M.b+(3*y-2*w)*q.b,u.a=6*(y-w)*K.a+(3*y-4*w+1)*H.a+6*(-y+w)*M.a+(3*y-2*w)*q.a}static FromColor3(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new G(K.r,K.g,K.b,H)}static iH(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new G(K[H],K[H+1],K[H+2],K[H+3])}static FromArrayToRef(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2?arguments[2]:void 0;M.r=K[H],M.g=K[H+1],M.b=K[H+2],M.a=K[H+3]}static FromInts(K,H,M,q){return new G(K/255,H/255,M/255,q/255)}static CheckColors4(K,H){if(K.length===3*H){const H=[];for(let M=0;M<K.length;M+=3){const q=M/3*4;H[q]=K[M],H[q+1]=K[M+1],H[q+2]=K[M+2],H[q+3]=1}return H}return K}}G._V8PerformanceHack=new G(.5,.5,.5,.5),Object.defineProperties(G.prototype,{dimension:{value:[4]},rank:{value:1}});class a{}a.CH=(0,q.d)(3,z.Black),a.Ch=(0,q.d)(3,(()=>new G(0,0,0,0))),(0,w.f)("BABYLON.Color3",z),(0,w.f)("BABYLON.Color4",G)}}]);