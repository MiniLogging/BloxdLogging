"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[17],{13023:(B,u,F)=>{F.r(u),F.d(u,{Xu:()=>Q,gR:()=>t,TmpColors:()=>v});var Z=F(12985),V=F(12949),p=F(12982),G=F(12994);function R(B){return Math.pow(B,p.m)}function e(B){return B<=.04045?.0773993808*B:Math.pow(.947867299*(B+.055),2.4)}function s(B){return Math.pow(B,p.i)}function Y(B){return B<=.0031308?12.92*B:1.055*Math.pow(B,.41666)-.055}class Q{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=B,this.g=u,this.b=F}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Xu"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B}toArray(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[u]=this.r,B[u+1]=this.g,B[u+2]=this.b,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Q.FromArrayToRef(B,u,this),this}toColor4(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new t(this.r,this.g,this.b,B)}DR(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(B){return new Q(this.r*B.r,this.g*B.g,this.b*B.b)}multiplyToRef(B,u){return u.r=this.r*B.r,u.g=this.g*B.g,u.b=this.b*B.b,u}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this}multiplyByFloats(B,u,F){return new Q(this.r*B,this.g*u,this.b*F)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,u){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.minimizeInPlaceFromFloats(B.r,B.g,B.b)}maximizeInPlace(B){return this.maximizeInPlaceFromFloats(B.r,B.g,B.b)}minimizeInPlaceFromFloats(B,u,F){return this.r=Math.min(B,this.r),this.g=Math.min(u,this.g),this.b=Math.min(F,this.b),this}maximizeInPlaceFromFloats(B,u,F){return this.r=Math.max(B,this.r),this.g=Math.max(u,this.g),this.b=Math.max(F,this.b),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b}equalsFloats(B,u,F){return this.equalsToFloats(B,u,F)}equalsToFloats(B,u,F){return this.r===B&&this.g===u&&this.b===F}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.e;return(0,G.WithinEpsilon)(this.r,B.r,u)&&(0,G.WithinEpsilon)(this.g,B.g,u)&&(0,G.WithinEpsilon)(this.b,B.b,u)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}scale(B){return new Q(this.r*B,this.g*B,this.b*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this}scaleToRef(B,u){return u.r=this.r*B,u.g=this.g*B,u.b=this.b*B,u}scaleAndAddToRef(B,u){return u.r+=this.r*B,u.g+=this.g*B,u.b+=this.b*B,u}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,G.Clamp)(this.r,B,u),F.g=(0,G.Clamp)(this.g,B,u),F.b=(0,G.Clamp)(this.b,B,u),F}add(B){return new Q(this.r+B.r,this.g+B.g,this.b+B.b)}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this}addInPlaceFromFloats(B,u,F){return this.r+=B,this.g+=u,this.b+=F,this}addToRef(B,u){return u.r=this.r+B.r,u.g=this.g+B.g,u.b=this.b+B.b,u}Lu(B){return new Q(this.r-B.r,this.g-B.g,this.b-B.b)}subtractToRef(B,u){return u.r=this.r-B.r,u.g=this.g-B.g,u.b=this.b-B.b,u}yQ(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this}subtractFromFloats(B,u,F){return new Q(this.r-B,this.g-u,this.b-F)}subtractFromFloatsToRef(B,u,F,Z){return Z.r=this.r-B,Z.g=this.g-u,Z.b=this.b-F,Z}clone(){return new Q(this.r,this.g,this.b)}Z(B){return this.r=B.r,this.g=B.g,this.b=B.b,this}UR(B,u,F){return this.r=B,this.g=u,this.b=F,this}set(B,u,F){return this.UR(B,u,F)}OR(B){return this.r=this.g=this.b=B,this}toHexString(){const B=Math.round(255*this.r),u=Math.round(255*this.g),F=Math.round(255*this.b);return"#"+(0,G.ToHex)(B)+(0,G.ToHex)(u)+(0,G.ToHex)(F)}fromHexString(B){return"#"!==B.substring(0,1)||7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new Q)}toHSVToRef(B){const u=this.r,F=this.g,Z=this.b,V=Math.max(u,F,Z),p=Math.min(u,F,Z);let G=0,R=0;const e=V,s=V-p;return 0!==V&&(R=s/V),V!=p&&(V==u?(G=(F-Z)/s,F<Z&&(G+=6)):V==F?G=(Z-u)/s+2:V==Z&&(G=(u-F)/s+4),G*=60),B.r=G,B.g=R,B.b=e,B}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new Q;return this.toLinearSpaceToRef(u,B),u}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=e(this.r),B.g=e(this.g),B.b=e(this.b)):(B.r=R(this.r),B.g=R(this.g),B.b=R(this.b)),this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new Q;return this.toGammaSpaceToRef(u,B),u}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=Y(this.r),B.g=Y(this.g),B.b=Y(this.b)):(B.r=s(this.r),B.g=s(this.g),B.b=s(this.b)),this}static HSVtoRGBToRef(B,u,F,Z){const V=F*u,p=B/60,G=V*(1-Math.abs(p%2-1));let R=0,e=0,s=0;p>=0&&p<=1?(R=V,e=G):p>=1&&p<=2?(R=G,e=V):p>=2&&p<=3?(e=V,s=G):p>=3&&p<=4?(e=G,s=V):p>=4&&p<=5?(R=G,s=V):p>=5&&p<=6&&(R=V,s=G);const Y=F-V;return Z.r=R+Y,Z.g=e+Y,Z.b=s+Y,Z}static FromHSV(B,u,F){const Z=new Q(0,0,0);return Q.HSVtoRGBToRef(B,u,F,Z),Z}static FromHexString(B){return new Q(0,0,0).fromHexString(B)}static fu(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new Q(B[u],B[u+1],B[u+2])}static FromArrayToRef(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=B[u],F.g=B[u+1],F.b=B[u+2]}static FromInts(B,u,F){return new Q(B/255,u/255,F/255)}static Lerp(B,u,F){const Z=new Q(0,0,0);return Q.LerpToRef(B,u,F,Z),Z}static LerpToRef(B,u,F,Z){Z.r=B.r+(u.r-B.r)*F,Z.g=B.g+(u.g-B.g)*F,Z.b=B.b+(u.b-B.b)*F}static Hermite(B,u,F,Z,V){const p=V*V,G=V*p,R=2*G-3*p+1,e=-2*G+3*p,s=G-2*p+V,Y=G-p,t=B.r*R+F.r*e+u.r*s+Z.r*Y,v=B.g*R+F.g*e+u.g*s+Z.g*Y,D=B.b*R+F.b*e+u.b*s+Z.b*Y;return new Q(t,v,D)}static Hermite1stDerivative(B,u,F,Z,V){const p=Q.Black();return this.Hermite1stDerivativeToRef(B,u,F,Z,V,p),p}static Hermite1stDerivativeToRef(B,u,F,Z,V,p){const G=V*V;p.r=6*(G-V)*B.r+(3*G-4*V+1)*u.r+6*(-G+V)*F.r+(3*G-2*V)*Z.r,p.g=6*(G-V)*B.g+(3*G-4*V+1)*u.g+6*(-G+V)*F.g+(3*G-2*V)*Z.g,p.b=6*(G-V)*B.b+(3*G-4*V+1)*u.b+6*(-G+V)*F.b+(3*G-2*V)*Z.b}static Red(){return new Q(1,0,0)}static Green(){return new Q(0,1,0)}static Blue(){return new Q(0,0,1)}static Black(){return new Q(0,0,0)}static get BlackReadOnly(){return Q._BlackReadOnly}static White(){return new Q(1,1,1)}static Purple(){return new Q(.5,0,.5)}static Magenta(){return new Q(1,0,1)}static Yellow(){return new Q(1,1,0)}static Gray(){return new Q(.5,.5,.5)}static Teal(){return new Q(0,1,1)}static Random(){return new Q(Math.random(),Math.random(),Math.random())}}Q._V8PerformanceHack=new Q(.5,.5,.5),Q._BlackReadOnly=Q.Black(),Object.defineProperties(Q.prototype,{dimension:{value:[3]},rank:{value:1}});class t{constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=B,this.g=u,this.b=F,this.a=Z}DR(){return[this.r,this.g,this.b,this.a]}toArray(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return B[u]=this.r,B[u+1]=this.g,B[u+2]=this.b,B[u+3]=this.a,this}vF(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=B[u],this.g=B[u+1],this.b=B[u+2],this.a=B[u+3],this}equals(B){return B&&this.r===B.r&&this.g===B.g&&this.b===B.b&&this.a===B.a}add(B){return new t(this.r+B.r,this.g+B.g,this.b+B.b,this.a+B.a)}addToRef(B,u){return u.r=this.r+B.r,u.g=this.g+B.g,u.b=this.b+B.b,u.a=this.a+B.a,u}addInPlace(B){return this.r+=B.r,this.g+=B.g,this.b+=B.b,this.a+=B.a,this}addInPlaceFromFloats(B,u,F,Z){return this.r+=B,this.g+=u,this.b+=F,this.a+=Z,this}Lu(B){return new t(this.r-B.r,this.g-B.g,this.b-B.b,this.a-B.a)}subtractToRef(B,u){return u.r=this.r-B.r,u.g=this.g-B.g,u.b=this.b-B.b,u.a=this.a-B.a,u}yQ(B){return this.r-=B.r,this.g-=B.g,this.b-=B.b,this.a-=B.a,this}subtractFromFloats(B,u,F,Z){return new t(this.r-B,this.g-u,this.b-F,this.a-Z)}subtractFromFloatsToRef(B,u,F,Z,V){return V.r=this.r-B,V.g=this.g-u,V.b=this.b-F,V.a=this.a-Z,V}scale(B){return new t(this.r*B,this.g*B,this.b*B,this.a*B)}scaleInPlace(B){return this.r*=B,this.g*=B,this.b*=B,this.a*=B,this}scaleToRef(B,u){return u.r=this.r*B,u.g=this.g*B,u.b=this.b*B,u.a=this.a*B,u}scaleAndAddToRef(B,u){return u.r+=this.r*B,u.g+=this.g*B,u.b+=this.b*B,u.a+=this.a*B,u}clampToRef(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,F=arguments.length>2?arguments[2]:void 0;return F.r=(0,G.Clamp)(this.r,B,u),F.g=(0,G.Clamp)(this.g,B,u),F.b=(0,G.Clamp)(this.b,B,u),F.a=(0,G.Clamp)(this.a,B,u),F}multiply(B){return new t(this.r*B.r,this.g*B.g,this.b*B.b,this.a*B.a)}multiplyToRef(B,u){return u.r=this.r*B.r,u.g=this.g*B.g,u.b=this.b*B.b,u.a=this.a*B.a,u}multiplyInPlace(B){return this.r*=B.r,this.g*=B.g,this.b*=B.b,this.a*=B.a,this}multiplyByFloats(B,u,F,Z){return new t(this.r*B,this.g*u,this.b*F,this.a*Z)}divide(B){throw new ReferenceError("Can not divide a color")}divideToRef(B,u){throw new ReferenceError("Can not divide a color")}divideInPlace(B){throw new ReferenceError("Can not divide a color")}minimizeInPlace(B){return this.r=Math.min(this.r,B.r),this.g=Math.min(this.g,B.g),this.b=Math.min(this.b,B.b),this.a=Math.min(this.a,B.a),this}maximizeInPlace(B){return this.r=Math.max(this.r,B.r),this.g=Math.max(this.g,B.g),this.b=Math.max(this.b,B.b),this.a=Math.max(this.a,B.a),this}minimizeInPlaceFromFloats(B,u,F,Z){return this.r=Math.min(B,this.r),this.g=Math.min(u,this.g),this.b=Math.min(F,this.b),this.a=Math.min(Z,this.a),this}maximizeInPlaceFromFloats(B,u,F,Z){return this.r=Math.max(B,this.r),this.g=Math.max(u,this.g),this.b=Math.max(F,this.b),this.a=Math.max(Z,this.a),this}floorToRef(B){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(B){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(B){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:p.e;return(0,G.WithinEpsilon)(this.r,B.r,u)&&(0,G.WithinEpsilon)(this.g,B.g,u)&&(0,G.WithinEpsilon)(this.b,B.b,u)&&(0,G.WithinEpsilon)(this.a,B.a,u)}equalsToFloats(B,u,F,Z){return this.r===B&&this.g===u&&this.b===F&&this.a===Z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"gR"}getHashCode(){let B=255*this.r|0;return B=397*B^255*this.g,B=397*B^255*this.b,B=397*B^255*this.a,B}clone(){return(new t).Z(this)}Z(B){return this.r=B.r,this.g=B.g,this.b=B.b,this.a=B.a,this}UR(B,u,F,Z){return this.r=B,this.g=u,this.b=F,this.a=Z,this}set(B,u,F,Z){return this.UR(B,u,F,Z)}OR(B){return this.r=this.g=this.b=this.a=B,this}toHexString(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=Math.round(255*this.r),F=Math.round(255*this.g),Z=Math.round(255*this.b);if(B)return"#"+(0,G.ToHex)(u)+(0,G.ToHex)(F)+(0,G.ToHex)(Z);const V=Math.round(255*this.a);return"#"+(0,G.ToHex)(u)+(0,G.ToHex)(F)+(0,G.ToHex)(Z)+(0,G.ToHex)(V)}fromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length||(this.r=parseInt(B.substring(1,3),16)/255,this.g=parseInt(B.substring(3,5),16)/255,this.b=parseInt(B.substring(5,7),16)/255,9===B.length&&(this.a=parseInt(B.substring(7,9),16)/255)),this}toLinearSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new t;return this.toLinearSpaceToRef(u,B),u}toLinearSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=e(this.r),B.g=e(this.g),B.b=e(this.b)):(B.r=R(this.r),B.g=R(this.g),B.b=R(this.b)),B.a=this.a,this}toGammaSpace(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const u=new t;return this.toGammaSpaceToRef(u,B),u}toGammaSpaceToRef(B){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(B.r=Y(this.r),B.g=Y(this.g),B.b=Y(this.b)):(B.r=s(this.r),B.g=s(this.g),B.b=s(this.b)),B.a=this.a,this}static FromHexString(B){return"#"!==B.substring(0,1)||9!==B.length&&7!==B.length?new t(0,0,0,0):new t(0,0,0,1).fromHexString(B)}static Lerp(B,u,F){return t.LerpToRef(B,u,F,new t)}static LerpToRef(B,u,F,Z){return Z.r=B.r+(u.r-B.r)*F,Z.g=B.g+(u.g-B.g)*F,Z.b=B.b+(u.b-B.b)*F,Z.a=B.a+(u.a-B.a)*F,Z}static Hermite(B,u,F,Z,V){const p=V*V,G=V*p,R=2*G-3*p+1,e=-2*G+3*p,s=G-2*p+V,Y=G-p,Q=B.r*R+F.r*e+u.r*s+Z.r*Y,v=B.g*R+F.g*e+u.g*s+Z.g*Y,D=B.b*R+F.b*e+u.b*s+Z.b*Y,L=B.a*R+F.a*e+u.a*s+Z.a*Y;return new t(Q,v,D,L)}static Hermite1stDerivative(B,u,F,Z,V){const p=new t;return this.Hermite1stDerivativeToRef(B,u,F,Z,V,p),p}static Hermite1stDerivativeToRef(B,u,F,Z,V,p){const G=V*V;p.r=6*(G-V)*B.r+(3*G-4*V+1)*u.r+6*(-G+V)*F.r+(3*G-2*V)*Z.r,p.g=6*(G-V)*B.g+(3*G-4*V+1)*u.g+6*(-G+V)*F.g+(3*G-2*V)*Z.g,p.b=6*(G-V)*B.b+(3*G-4*V+1)*u.b+6*(-G+V)*F.b+(3*G-2*V)*Z.b,p.a=6*(G-V)*B.a+(3*G-4*V+1)*u.a+6*(-G+V)*F.a+(3*G-2*V)*Z.a}static FromColor3(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new t(B.r,B.g,B.b,u)}static fu(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new t(B[u],B[u+1],B[u+2],B[u+3])}static FromArrayToRef(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2?arguments[2]:void 0;F.r=B[u],F.g=B[u+1],F.b=B[u+2],F.a=B[u+3]}static FromInts(B,u,F,Z){return new t(B/255,u/255,F/255,Z/255)}static CheckColors4(B,u){if(B.length===3*u){const u=[];for(let F=0;F<B.length;F+=3){const Z=F/3*4;u[Z]=B[F],u[Z+1]=B[F+1],u[Z+2]=B[F+2],u[Z+3]=1}return u}return B}}t._V8PerformanceHack=new t(.5,.5,.5,.5),Object.defineProperties(t.prototype,{dimension:{value:[4]},rank:{value:1}});class v{}v.Xu=(0,Z.e)(3,Q.Black),v.gR=(0,Z.e)(3,(()=>new t(0,0,0,0))),(0,V.f)("BABYLON.Color3",Q),(0,V.f)("BABYLON.Color4",t)}}]);