"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[17],{11690:(F,P,f)=>{f.r(P),f.d(P,{BP:()=>u,qc:()=>T,TmpColors:()=>Y});var c=f(11655),N=f(11587),q=f(11648),H=f(11664);function A(F){return Math.pow(F,q.l)}function o(F){return F<=.04045?.0773993808*F:Math.pow(.947867299*(F+.055),2.4)}function j(F){return Math.pow(F,q.j)}function i(F){return F<=.0031308?12.92*F:1.055*Math.pow(F,.41666)-.055}class u{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=F,this.g=P,this.b=f}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"BP"}getHashCode(){let F=255*this.r|0;return F=397*F^255*this.g,F=397*F^255*this.b,F}toArray(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[P]=this.r,F[P+1]=this.g,F[P+2]=this.b,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return u.FromArrayToRef(F,P,this),this}toColor4(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new T(this.r,this.g,this.b,F)}pf(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(F){return new u(this.r*F.r,this.g*F.g,this.b*F.b)}multiplyToRef(F,P){return P.r=this.r*F.r,P.g=this.g*F.g,P.b=this.b*F.b,P}multiplyInPlace(F){return this.r*=F.r,this.g*=F.g,this.b*=F.b,this}multiplyByFloats(F,P,f){return new u(this.r*F,this.g*P,this.b*f)}divide(F){throw new ReferenceError("Can not divide a color")}divideToRef(F,P){throw new ReferenceError("Can not divide a color")}divideInPlace(F){throw new ReferenceError("Can not divide a color")}minimizeInPlace(F){return this.minimizeInPlaceFromFloats(F.r,F.g,F.b)}maximizeInPlace(F){return this.maximizeInPlaceFromFloats(F.r,F.g,F.b)}minimizeInPlaceFromFloats(F,P,f){return this.r=Math.min(F,this.r),this.g=Math.min(P,this.g),this.b=Math.min(f,this.b),this}maximizeInPlaceFromFloats(F,P,f){return this.r=Math.max(F,this.r),this.g=Math.max(P,this.g),this.b=Math.max(f,this.b),this}floorToRef(F){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(F){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(F){return F&&this.r===F.r&&this.g===F.g&&this.b===F.b}equalsFloats(F,P,f){return this.equalsToFloats(F,P,f)}equalsToFloats(F,P,f){return this.r===F&&this.g===P&&this.b===f}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.e;return(0,H.WithinEpsilon)(this.r,F.r,P)&&(0,H.WithinEpsilon)(this.g,F.g,P)&&(0,H.WithinEpsilon)(this.b,F.b,P)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(F){throw new ReferenceError("Can not negate a color")}scale(F){return new u(this.r*F,this.g*F,this.b*F)}scaleInPlace(F){return this.r*=F,this.g*=F,this.b*=F,this}scaleToRef(F,P){return P.r=this.r*F,P.g=this.g*F,P.b=this.b*F,P}scaleAndAddToRef(F,P){return P.r+=this.r*F,P.g+=this.g*F,P.b+=this.b*F,P}clampToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,f=arguments.length>2?arguments[2]:void 0;return f.r=(0,H.Clamp)(this.r,F,P),f.g=(0,H.Clamp)(this.g,F,P),f.b=(0,H.Clamp)(this.b,F,P),f}add(F){return new u(this.r+F.r,this.g+F.g,this.b+F.b)}addInPlace(F){return this.r+=F.r,this.g+=F.g,this.b+=F.b,this}addInPlaceFromFloats(F,P,f){return this.r+=F,this.g+=P,this.b+=f,this}addToRef(F,P){return P.r=this.r+F.r,P.g=this.g+F.g,P.b=this.b+F.b,P}CP(F){return new u(this.r-F.r,this.g-F.g,this.b-F.b)}subtractToRef(F,P){return P.r=this.r-F.r,P.g=this.g-F.g,P.b=this.b-F.b,P}Ou(F){return this.r-=F.r,this.g-=F.g,this.b-=F.b,this}subtractFromFloats(F,P,f){return new u(this.r-F,this.g-P,this.b-f)}subtractFromFloatsToRef(F,P,f,c){return c.r=this.r-F,c.g=this.g-P,c.b=this.b-f,c}clone(){return new u(this.r,this.g,this.b)}q(F){return this.r=F.r,this.g=F.g,this.b=F.b,this}fc(F,P,f){return this.r=F,this.g=P,this.b=f,this}set(F,P,f){return this.fc(F,P,f)}Nc(F){return this.r=this.g=this.b=F,this}toHexString(){const F=Math.round(255*this.r),P=Math.round(255*this.g),f=Math.round(255*this.b);return"#"+(0,H.ToHex)(F)+(0,H.ToHex)(P)+(0,H.ToHex)(f)}fromHexString(F){return"#"!==F.substring(0,1)||7!==F.length||(this.r=parseInt(F.substring(1,3),16)/255,this.g=parseInt(F.substring(3,5),16)/255,this.b=parseInt(F.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new u)}toHSVToRef(F){const P=this.r,f=this.g,c=this.b,N=Math.max(P,f,c),q=Math.min(P,f,c);let H=0,A=0;const o=N,j=N-q;return 0!==N&&(A=j/N),N!=q&&(N==P?(H=(f-c)/j,f<c&&(H+=6)):N==f?H=(c-P)/j+2:N==c&&(H=(P-f)/j+4),H*=60),F.r=H,F.g=A,F.b=o,F}toLinearSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=new u;return this.toLinearSpaceToRef(P,F),P}toLinearSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=o(this.r),F.g=o(this.g),F.b=o(this.b)):(F.r=A(this.r),F.g=A(this.g),F.b=A(this.b)),this}toGammaSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=new u;return this.toGammaSpaceToRef(P,F),P}toGammaSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=i(this.r),F.g=i(this.g),F.b=i(this.b)):(F.r=j(this.r),F.g=j(this.g),F.b=j(this.b)),this}static HSVtoRGBToRef(F,P,f,c){const N=f*P,q=F/60,H=N*(1-Math.abs(q%2-1));let A=0,o=0,j=0;q>=0&&q<=1?(A=N,o=H):q>=1&&q<=2?(A=H,o=N):q>=2&&q<=3?(o=N,j=H):q>=3&&q<=4?(o=H,j=N):q>=4&&q<=5?(A=H,j=N):q>=5&&q<=6&&(A=N,j=H);const i=f-N;return c.r=A+i,c.g=o+i,c.b=j+i,c}static FromHSV(F,P,f){const c=new u(0,0,0);return u.HSVtoRGBToRef(F,P,f,c),c}static FromHexString(F){return new u(0,0,0).fromHexString(F)}static zP(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(F[P],F[P+1],F[P+2])}static FromArrayToRef(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2?arguments[2]:void 0;f.r=F[P],f.g=F[P+1],f.b=F[P+2]}static FromInts(F,P,f){return new u(F/255,P/255,f/255)}static Lerp(F,P,f){const c=new u(0,0,0);return u.LerpToRef(F,P,f,c),c}static LerpToRef(F,P,f,c){c.r=F.r+(P.r-F.r)*f,c.g=F.g+(P.g-F.g)*f,c.b=F.b+(P.b-F.b)*f}static Hermite(F,P,f,c,N){const q=N*N,H=N*q,A=2*H-3*q+1,o=-2*H+3*q,j=H-2*q+N,i=H-q,T=F.r*A+f.r*o+P.r*j+c.r*i,Y=F.g*A+f.g*o+P.g*j+c.g*i,t=F.b*A+f.b*o+P.b*j+c.b*i;return new u(T,Y,t)}static Hermite1stDerivative(F,P,f,c,N){const q=u.Black();return this.Hermite1stDerivativeToRef(F,P,f,c,N,q),q}static Hermite1stDerivativeToRef(F,P,f,c,N,q){const H=N*N;q.r=6*(H-N)*F.r+(3*H-4*N+1)*P.r+6*(-H+N)*f.r+(3*H-2*N)*c.r,q.g=6*(H-N)*F.g+(3*H-4*N+1)*P.g+6*(-H+N)*f.g+(3*H-2*N)*c.g,q.b=6*(H-N)*F.b+(3*H-4*N+1)*P.b+6*(-H+N)*f.b+(3*H-2*N)*c.b}static Red(){return new u(1,0,0)}static Green(){return new u(0,1,0)}static Blue(){return new u(0,0,1)}static Black(){return new u(0,0,0)}static get BlackReadOnly(){return u._BlackReadOnly}static White(){return new u(1,1,1)}static Purple(){return new u(.5,0,.5)}static Magenta(){return new u(1,0,1)}static Yellow(){return new u(1,1,0)}static Gray(){return new u(.5,.5,.5)}static Teal(){return new u(0,1,1)}static Random(){return new u(Math.random(),Math.random(),Math.random())}}u._V8PerformanceHack=new u(.5,.5,.5),u._BlackReadOnly=u.Black(),Object.defineProperties(u.prototype,{dimension:{value:[3]},rank:{value:1}});class T{constructor(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=F,this.g=P,this.b=f,this.a=c}pf(){return[this.r,this.g,this.b,this.a]}toArray(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return F[P]=this.r,F[P+1]=this.g,F[P+2]=this.b,F[P+3]=this.a,this}Zf(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=F[P],this.g=F[P+1],this.b=F[P+2],this.a=F[P+3],this}equals(F){return F&&this.r===F.r&&this.g===F.g&&this.b===F.b&&this.a===F.a}add(F){return new T(this.r+F.r,this.g+F.g,this.b+F.b,this.a+F.a)}addToRef(F,P){return P.r=this.r+F.r,P.g=this.g+F.g,P.b=this.b+F.b,P.a=this.a+F.a,P}addInPlace(F){return this.r+=F.r,this.g+=F.g,this.b+=F.b,this.a+=F.a,this}addInPlaceFromFloats(F,P,f,c){return this.r+=F,this.g+=P,this.b+=f,this.a+=c,this}CP(F){return new T(this.r-F.r,this.g-F.g,this.b-F.b,this.a-F.a)}subtractToRef(F,P){return P.r=this.r-F.r,P.g=this.g-F.g,P.b=this.b-F.b,P.a=this.a-F.a,P}Ou(F){return this.r-=F.r,this.g-=F.g,this.b-=F.b,this.a-=F.a,this}subtractFromFloats(F,P,f,c){return new T(this.r-F,this.g-P,this.b-f,this.a-c)}subtractFromFloatsToRef(F,P,f,c,N){return N.r=this.r-F,N.g=this.g-P,N.b=this.b-f,N.a=this.a-c,N}scale(F){return new T(this.r*F,this.g*F,this.b*F,this.a*F)}scaleInPlace(F){return this.r*=F,this.g*=F,this.b*=F,this.a*=F,this}scaleToRef(F,P){return P.r=this.r*F,P.g=this.g*F,P.b=this.b*F,P.a=this.a*F,P}scaleAndAddToRef(F,P){return P.r+=this.r*F,P.g+=this.g*F,P.b+=this.b*F,P.a+=this.a*F,P}clampToRef(){let F=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,f=arguments.length>2?arguments[2]:void 0;return f.r=(0,H.Clamp)(this.r,F,P),f.g=(0,H.Clamp)(this.g,F,P),f.b=(0,H.Clamp)(this.b,F,P),f.a=(0,H.Clamp)(this.a,F,P),f}multiply(F){return new T(this.r*F.r,this.g*F.g,this.b*F.b,this.a*F.a)}multiplyToRef(F,P){return P.r=this.r*F.r,P.g=this.g*F.g,P.b=this.b*F.b,P.a=this.a*F.a,P}multiplyInPlace(F){return this.r*=F.r,this.g*=F.g,this.b*=F.b,this.a*=F.a,this}multiplyByFloats(F,P,f,c){return new T(this.r*F,this.g*P,this.b*f,this.a*c)}divide(F){throw new ReferenceError("Can not divide a color")}divideToRef(F,P){throw new ReferenceError("Can not divide a color")}divideInPlace(F){throw new ReferenceError("Can not divide a color")}minimizeInPlace(F){return this.r=Math.min(this.r,F.r),this.g=Math.min(this.g,F.g),this.b=Math.min(this.b,F.b),this.a=Math.min(this.a,F.a),this}maximizeInPlace(F){return this.r=Math.max(this.r,F.r),this.g=Math.max(this.g,F.g),this.b=Math.max(this.b,F.b),this.a=Math.max(this.a,F.a),this}minimizeInPlaceFromFloats(F,P,f,c){return this.r=Math.min(F,this.r),this.g=Math.min(P,this.g),this.b=Math.min(f,this.b),this.a=Math.min(c,this.a),this}maximizeInPlaceFromFloats(F,P,f,c){return this.r=Math.max(F,this.r),this.g=Math.max(P,this.g),this.b=Math.max(f,this.b),this.a=Math.max(c,this.a),this}floorToRef(F){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(F){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(F){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:q.e;return(0,H.WithinEpsilon)(this.r,F.r,P)&&(0,H.WithinEpsilon)(this.g,F.g,P)&&(0,H.WithinEpsilon)(this.b,F.b,P)&&(0,H.WithinEpsilon)(this.a,F.a,P)}equalsToFloats(F,P,f,c){return this.r===F&&this.g===P&&this.b===f&&this.a===c}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"qc"}getHashCode(){let F=255*this.r|0;return F=397*F^255*this.g,F=397*F^255*this.b,F=397*F^255*this.a,F}clone(){return(new T).q(this)}q(F){return this.r=F.r,this.g=F.g,this.b=F.b,this.a=F.a,this}fc(F,P,f,c){return this.r=F,this.g=P,this.b=f,this.a=c,this}set(F,P,f,c){return this.fc(F,P,f,c)}Nc(F){return this.r=this.g=this.b=this.a=F,this}toHexString(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=Math.round(255*this.r),f=Math.round(255*this.g),c=Math.round(255*this.b);if(F)return"#"+(0,H.ToHex)(P)+(0,H.ToHex)(f)+(0,H.ToHex)(c);const N=Math.round(255*this.a);return"#"+(0,H.ToHex)(P)+(0,H.ToHex)(f)+(0,H.ToHex)(c)+(0,H.ToHex)(N)}fromHexString(F){return"#"!==F.substring(0,1)||9!==F.length&&7!==F.length||(this.r=parseInt(F.substring(1,3),16)/255,this.g=parseInt(F.substring(3,5),16)/255,this.b=parseInt(F.substring(5,7),16)/255,9===F.length&&(this.a=parseInt(F.substring(7,9),16)/255)),this}toLinearSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=new T;return this.toLinearSpaceToRef(P,F),P}toLinearSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=o(this.r),F.g=o(this.g),F.b=o(this.b)):(F.r=A(this.r),F.g=A(this.g),F.b=A(this.b)),F.a=this.a,this}toGammaSpace(){let F=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const P=new T;return this.toGammaSpaceToRef(P,F),P}toGammaSpaceToRef(F){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(F.r=i(this.r),F.g=i(this.g),F.b=i(this.b)):(F.r=j(this.r),F.g=j(this.g),F.b=j(this.b)),F.a=this.a,this}static FromHexString(F){return"#"!==F.substring(0,1)||9!==F.length&&7!==F.length?new T(0,0,0,0):new T(0,0,0,1).fromHexString(F)}static Lerp(F,P,f){return T.LerpToRef(F,P,f,new T)}static LerpToRef(F,P,f,c){return c.r=F.r+(P.r-F.r)*f,c.g=F.g+(P.g-F.g)*f,c.b=F.b+(P.b-F.b)*f,c.a=F.a+(P.a-F.a)*f,c}static Hermite(F,P,f,c,N){const q=N*N,H=N*q,A=2*H-3*q+1,o=-2*H+3*q,j=H-2*q+N,i=H-q,u=F.r*A+f.r*o+P.r*j+c.r*i,Y=F.g*A+f.g*o+P.g*j+c.g*i,t=F.b*A+f.b*o+P.b*j+c.b*i,C=F.a*A+f.a*o+P.a*j+c.a*i;return new T(u,Y,t,C)}static Hermite1stDerivative(F,P,f,c,N){const q=new T;return this.Hermite1stDerivativeToRef(F,P,f,c,N,q),q}static Hermite1stDerivativeToRef(F,P,f,c,N,q){const H=N*N;q.r=6*(H-N)*F.r+(3*H-4*N+1)*P.r+6*(-H+N)*f.r+(3*H-2*N)*c.r,q.g=6*(H-N)*F.g+(3*H-4*N+1)*P.g+6*(-H+N)*f.g+(3*H-2*N)*c.g,q.b=6*(H-N)*F.b+(3*H-4*N+1)*P.b+6*(-H+N)*f.b+(3*H-2*N)*c.b,q.a=6*(H-N)*F.a+(3*H-4*N+1)*P.a+6*(-H+N)*f.a+(3*H-2*N)*c.a}static FromColor3(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T(F.r,F.g,F.b,P)}static zP(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(F[P],F[P+1],F[P+2],F[P+3])}static FromArrayToRef(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2?arguments[2]:void 0;f.r=F[P],f.g=F[P+1],f.b=F[P+2],f.a=F[P+3]}static FromInts(F,P,f,c){return new T(F/255,P/255,f/255,c/255)}static CheckColors4(F,P){if(F.length===3*P){const P=[];for(let f=0;f<F.length;f+=3){const c=f/3*4;P[c]=F[f],P[c+1]=F[f+1],P[c+2]=F[f+2],P[c+3]=1}return P}return F}}T._V8PerformanceHack=new T(.5,.5,.5,.5),Object.defineProperties(T.prototype,{dimension:{value:[4]},rank:{value:1}});class Y{}Y.BP=(0,c.e)(3,u.Black),Y.qc=(0,c.e)(3,(()=>new T(0,0,0,0))),(0,N.f)("BABYLON.Color3",u),(0,N.f)("BABYLON.Color4",T)}}]);