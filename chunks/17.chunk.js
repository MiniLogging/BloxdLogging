"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[17],{12812:(h,d,T)=>{T.r(d),T.d(d,{ed:()=>S,ln:()=>r,TmpColors:()=>c});var Y=T(12779),y=T(12714),C=T(12772),n=T(12787);function X(h){return Math.pow(h,C.l)}function F(h){return h<=.04045?.0773993808*h:Math.pow(.947867299*(h+.055),2.4)}function U(h){return Math.pow(h,C.j)}function Z(h){return h<=.0031308?12.92*h:1.055*Math.pow(h,.41666)-.055}class S{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=h,this.g=d,this.b=T}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ed"}getHashCode(){let h=255*this.r|0;return h=397*h^255*this.g,h=397*h^255*this.b,h}toArray(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[d]=this.r,h[d+1]=this.g,h[d+2]=this.b,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return S.FromArrayToRef(h,d,this),this}toColor4(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new r(this.r,this.g,this.b,h)}ad(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(h){return new S(this.r*h.r,this.g*h.g,this.b*h.b)}multiplyToRef(h,d){return d.r=this.r*h.r,d.g=this.g*h.g,d.b=this.b*h.b,d}multiplyInPlace(h){return this.r*=h.r,this.g*=h.g,this.b*=h.b,this}multiplyByFloats(h,d,T){return new S(this.r*h,this.g*d,this.b*T)}divide(h){throw new ReferenceError("Can not divide a color")}divideToRef(h,d){throw new ReferenceError("Can not divide a color")}divideInPlace(h){throw new ReferenceError("Can not divide a color")}minimizeInPlace(h){return this.minimizeInPlaceFromFloats(h.r,h.g,h.b)}maximizeInPlace(h){return this.maximizeInPlaceFromFloats(h.r,h.g,h.b)}minimizeInPlaceFromFloats(h,d,T){return this.r=Math.min(h,this.r),this.g=Math.min(d,this.g),this.b=Math.min(T,this.b),this}maximizeInPlaceFromFloats(h,d,T){return this.r=Math.max(h,this.r),this.g=Math.max(d,this.g),this.b=Math.max(T,this.b),this}floorToRef(h){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(h){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(h){return h&&this.r===h.r&&this.g===h.g&&this.b===h.b}equalsFloats(h,d,T){return this.equalsToFloats(h,d,T)}equalsToFloats(h,d,T){return this.r===h&&this.g===d&&this.b===T}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return(0,n.WithinEpsilon)(this.r,h.r,d)&&(0,n.WithinEpsilon)(this.g,h.g,d)&&(0,n.WithinEpsilon)(this.b,h.b,d)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(h){throw new ReferenceError("Can not negate a color")}scale(h){return new S(this.r*h,this.g*h,this.b*h)}scaleInPlace(h){return this.r*=h,this.g*=h,this.b*=h,this}scaleToRef(h,d){return d.r=this.r*h,d.g=this.g*h,d.b=this.b*h,d}scaleAndAddToRef(h,d){return d.r+=this.r*h,d.g+=this.g*h,d.b+=this.b*h,d}clampToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,n.Clamp)(this.r,h,d),T.g=(0,n.Clamp)(this.g,h,d),T.b=(0,n.Clamp)(this.b,h,d),T}add(h){return new S(this.r+h.r,this.g+h.g,this.b+h.b)}addInPlace(h){return this.r+=h.r,this.g+=h.g,this.b+=h.b,this}addInPlaceFromFloats(h,d,T){return this.r+=h,this.g+=d,this.b+=T,this}addToRef(h,d){return d.r=this.r+h.r,d.g=this.g+h.g,d.b=this.b+h.b,d}Nd(h){return new S(this.r-h.r,this.g-h.g,this.b-h.b)}subtractToRef(h,d){return d.r=this.r-h.r,d.g=this.g-h.g,d.b=this.b-h.b,d}rS(h){return this.r-=h.r,this.g-=h.g,this.b-=h.b,this}subtractFromFloats(h,d,T){return new S(this.r-h,this.g-d,this.b-T)}subtractFromFloatsToRef(h,d,T,Y){return Y.r=this.r-h,Y.g=this.g-d,Y.b=this.b-T,Y}clone(){return new S(this.r,this.g,this.b)}C(h){return this.r=h.r,this.g=h.g,this.b=h.b,this}ny(h,d,T){return this.r=h,this.g=d,this.b=T,this}set(h,d,T){return this.ny(h,d,T)}XC(h){return this.r=this.g=this.b=h,this}toHexString(){const h=Math.round(255*this.r),d=Math.round(255*this.g),T=Math.round(255*this.b);return"#"+(0,n.ToHex)(h)+(0,n.ToHex)(d)+(0,n.ToHex)(T)}fromHexString(h){return"#"!==h.substring(0,1)||7!==h.length||(this.r=parseInt(h.substring(1,3),16)/255,this.g=parseInt(h.substring(3,5),16)/255,this.b=parseInt(h.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new S)}toHSVToRef(h){const d=this.r,T=this.g,Y=this.b,y=Math.max(d,T,Y),C=Math.min(d,T,Y);let n=0,X=0;const F=y,U=y-C;return 0!==y&&(X=U/y),y!=C&&(y==d?(n=(T-Y)/U,T<Y&&(n+=6)):y==T?n=(Y-d)/U+2:y==Y&&(n=(d-T)/U+4),n*=60),h.r=n,h.g=X,h.b=F,h}toLinearSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new S;return this.toLinearSpaceToRef(d,h),d}toLinearSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=F(this.r),h.g=F(this.g),h.b=F(this.b)):(h.r=X(this.r),h.g=X(this.g),h.b=X(this.b)),this}toGammaSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new S;return this.toGammaSpaceToRef(d,h),d}toGammaSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=Z(this.r),h.g=Z(this.g),h.b=Z(this.b)):(h.r=U(this.r),h.g=U(this.g),h.b=U(this.b)),this}static HSVtoRGBToRef(h,d,T,Y){const y=T*d,C=h/60,n=y*(1-Math.abs(C%2-1));let X=0,F=0,U=0;C>=0&&C<=1?(X=y,F=n):C>=1&&C<=2?(X=n,F=y):C>=2&&C<=3?(F=y,U=n):C>=3&&C<=4?(F=n,U=y):C>=4&&C<=5?(X=n,U=y):C>=5&&C<=6&&(X=y,U=n);const Z=T-y;return Y.r=X+Z,Y.g=F+Z,Y.b=U+Z,Y}static FromHSV(h,d,T){const Y=new S(0,0,0);return S.HSVtoRGBToRef(h,d,T,Y),Y}static FromHexString(h){return new S(0,0,0).fromHexString(h)}static Bd(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new S(h[d],h[d+1],h[d+2])}static FromArrayToRef(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=h[d],T.g=h[d+1],T.b=h[d+2]}static FromInts(h,d,T){return new S(h/255,d/255,T/255)}static Lerp(h,d,T){const Y=new S(0,0,0);return S.LerpToRef(h,d,T,Y),Y}static LerpToRef(h,d,T,Y){Y.r=h.r+(d.r-h.r)*T,Y.g=h.g+(d.g-h.g)*T,Y.b=h.b+(d.b-h.b)*T}static Hermite(h,d,T,Y,y){const C=y*y,n=y*C,X=2*n-3*C+1,F=-2*n+3*C,U=n-2*C+y,Z=n-C,r=h.r*X+T.r*F+d.r*U+Y.r*Z,c=h.g*X+T.g*F+d.g*U+Y.g*Z,O=h.b*X+T.b*F+d.b*U+Y.b*Z;return new S(r,c,O)}static Hermite1stDerivative(h,d,T,Y,y){const C=S.Black();return this.Hermite1stDerivativeToRef(h,d,T,Y,y,C),C}static Hermite1stDerivativeToRef(h,d,T,Y,y,C){const n=y*y;C.r=6*(n-y)*h.r+(3*n-4*y+1)*d.r+6*(-n+y)*T.r+(3*n-2*y)*Y.r,C.g=6*(n-y)*h.g+(3*n-4*y+1)*d.g+6*(-n+y)*T.g+(3*n-2*y)*Y.g,C.b=6*(n-y)*h.b+(3*n-4*y+1)*d.b+6*(-n+y)*T.b+(3*n-2*y)*Y.b}static Red(){return new S(1,0,0)}static Green(){return new S(0,1,0)}static Blue(){return new S(0,0,1)}static Black(){return new S(0,0,0)}static get BlackReadOnly(){return S._BlackReadOnly}static White(){return new S(1,1,1)}static Purple(){return new S(.5,0,.5)}static Magenta(){return new S(1,0,1)}static Yellow(){return new S(1,1,0)}static Gray(){return new S(.5,.5,.5)}static Teal(){return new S(0,1,1)}static Random(){return new S(Math.random(),Math.random(),Math.random())}}S._V8PerformanceHack=new S(.5,.5,.5),S._BlackReadOnly=S.Black(),Object.defineProperties(S.prototype,{dimension:{value:[3]},rank:{value:1}});class r{constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=h,this.g=d,this.b=T,this.a=Y}ad(){return[this.r,this.g,this.b,this.a]}toArray(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h[d]=this.r,h[d+1]=this.g,h[d+2]=this.b,h[d+3]=this.a,this}vT(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=h[d],this.g=h[d+1],this.b=h[d+2],this.a=h[d+3],this}equals(h){return h&&this.r===h.r&&this.g===h.g&&this.b===h.b&&this.a===h.a}add(h){return new r(this.r+h.r,this.g+h.g,this.b+h.b,this.a+h.a)}addToRef(h,d){return d.r=this.r+h.r,d.g=this.g+h.g,d.b=this.b+h.b,d.a=this.a+h.a,d}addInPlace(h){return this.r+=h.r,this.g+=h.g,this.b+=h.b,this.a+=h.a,this}addInPlaceFromFloats(h,d,T,Y){return this.r+=h,this.g+=d,this.b+=T,this.a+=Y,this}Nd(h){return new r(this.r-h.r,this.g-h.g,this.b-h.b,this.a-h.a)}subtractToRef(h,d){return d.r=this.r-h.r,d.g=this.g-h.g,d.b=this.b-h.b,d.a=this.a-h.a,d}rS(h){return this.r-=h.r,this.g-=h.g,this.b-=h.b,this.a-=h.a,this}subtractFromFloats(h,d,T,Y){return new r(this.r-h,this.g-d,this.b-T,this.a-Y)}subtractFromFloatsToRef(h,d,T,Y,y){return y.r=this.r-h,y.g=this.g-d,y.b=this.b-T,y.a=this.a-Y,y}scale(h){return new r(this.r*h,this.g*h,this.b*h,this.a*h)}scaleInPlace(h){return this.r*=h,this.g*=h,this.b*=h,this.a*=h,this}scaleToRef(h,d){return d.r=this.r*h,d.g=this.g*h,d.b=this.b*h,d.a=this.a*h,d}scaleAndAddToRef(h,d){return d.r+=this.r*h,d.g+=this.g*h,d.b+=this.b*h,d.a+=this.a*h,d}clampToRef(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,T=arguments.length>2?arguments[2]:void 0;return T.r=(0,n.Clamp)(this.r,h,d),T.g=(0,n.Clamp)(this.g,h,d),T.b=(0,n.Clamp)(this.b,h,d),T.a=(0,n.Clamp)(this.a,h,d),T}multiply(h){return new r(this.r*h.r,this.g*h.g,this.b*h.b,this.a*h.a)}multiplyToRef(h,d){return d.r=this.r*h.r,d.g=this.g*h.g,d.b=this.b*h.b,d.a=this.a*h.a,d}multiplyInPlace(h){return this.r*=h.r,this.g*=h.g,this.b*=h.b,this.a*=h.a,this}multiplyByFloats(h,d,T,Y){return new r(this.r*h,this.g*d,this.b*T,this.a*Y)}divide(h){throw new ReferenceError("Can not divide a color")}divideToRef(h,d){throw new ReferenceError("Can not divide a color")}divideInPlace(h){throw new ReferenceError("Can not divide a color")}minimizeInPlace(h){return this.r=Math.min(this.r,h.r),this.g=Math.min(this.g,h.g),this.b=Math.min(this.b,h.b),this.a=Math.min(this.a,h.a),this}maximizeInPlace(h){return this.r=Math.max(this.r,h.r),this.g=Math.max(this.g,h.g),this.b=Math.max(this.b,h.b),this.a=Math.max(this.a,h.a),this}minimizeInPlaceFromFloats(h,d,T,Y){return this.r=Math.min(h,this.r),this.g=Math.min(d,this.g),this.b=Math.min(T,this.b),this.a=Math.min(Y,this.a),this}maximizeInPlaceFromFloats(h,d,T,Y){return this.r=Math.max(h,this.r),this.g=Math.max(d,this.g),this.b=Math.max(T,this.b),this.a=Math.max(Y,this.a),this}floorToRef(h){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(h){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(h){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:C.d;return(0,n.WithinEpsilon)(this.r,h.r,d)&&(0,n.WithinEpsilon)(this.g,h.g,d)&&(0,n.WithinEpsilon)(this.b,h.b,d)&&(0,n.WithinEpsilon)(this.a,h.a,d)}equalsToFloats(h,d,T,Y){return this.r===h&&this.g===d&&this.b===T&&this.a===Y}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"ln"}getHashCode(){let h=255*this.r|0;return h=397*h^255*this.g,h=397*h^255*this.b,h=397*h^255*this.a,h}clone(){return(new r).C(this)}C(h){return this.r=h.r,this.g=h.g,this.b=h.b,this.a=h.a,this}ny(h,d,T,Y){return this.r=h,this.g=d,this.b=T,this.a=Y,this}set(h,d,T,Y){return this.ny(h,d,T,Y)}XC(h){return this.r=this.g=this.b=this.a=h,this}toHexString(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=Math.round(255*this.r),T=Math.round(255*this.g),Y=Math.round(255*this.b);if(h)return"#"+(0,n.ToHex)(d)+(0,n.ToHex)(T)+(0,n.ToHex)(Y);const y=Math.round(255*this.a);return"#"+(0,n.ToHex)(d)+(0,n.ToHex)(T)+(0,n.ToHex)(Y)+(0,n.ToHex)(y)}fromHexString(h){return"#"!==h.substring(0,1)||9!==h.length&&7!==h.length||(this.r=parseInt(h.substring(1,3),16)/255,this.g=parseInt(h.substring(3,5),16)/255,this.b=parseInt(h.substring(5,7),16)/255,9===h.length&&(this.a=parseInt(h.substring(7,9),16)/255)),this}toLinearSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new r;return this.toLinearSpaceToRef(d,h),d}toLinearSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=F(this.r),h.g=F(this.g),h.b=F(this.b)):(h.r=X(this.r),h.g=X(this.g),h.b=X(this.b)),h.a=this.a,this}toGammaSpace(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new r;return this.toGammaSpaceToRef(d,h),d}toGammaSpaceToRef(h){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(h.r=Z(this.r),h.g=Z(this.g),h.b=Z(this.b)):(h.r=U(this.r),h.g=U(this.g),h.b=U(this.b)),h.a=this.a,this}static FromHexString(h){return"#"!==h.substring(0,1)||9!==h.length&&7!==h.length?new r(0,0,0,0):new r(0,0,0,1).fromHexString(h)}static Lerp(h,d,T){return r.LerpToRef(h,d,T,new r)}static LerpToRef(h,d,T,Y){return Y.r=h.r+(d.r-h.r)*T,Y.g=h.g+(d.g-h.g)*T,Y.b=h.b+(d.b-h.b)*T,Y.a=h.a+(d.a-h.a)*T,Y}static Hermite(h,d,T,Y,y){const C=y*y,n=y*C,X=2*n-3*C+1,F=-2*n+3*C,U=n-2*C+y,Z=n-C,S=h.r*X+T.r*F+d.r*U+Y.r*Z,c=h.g*X+T.g*F+d.g*U+Y.g*Z,O=h.b*X+T.b*F+d.b*U+Y.b*Z,f=h.a*X+T.a*F+d.a*U+Y.a*Z;return new r(S,c,O,f)}static Hermite1stDerivative(h,d,T,Y,y){const C=new r;return this.Hermite1stDerivativeToRef(h,d,T,Y,y,C),C}static Hermite1stDerivativeToRef(h,d,T,Y,y,C){const n=y*y;C.r=6*(n-y)*h.r+(3*n-4*y+1)*d.r+6*(-n+y)*T.r+(3*n-2*y)*Y.r,C.g=6*(n-y)*h.g+(3*n-4*y+1)*d.g+6*(-n+y)*T.g+(3*n-2*y)*Y.g,C.b=6*(n-y)*h.b+(3*n-4*y+1)*d.b+6*(-n+y)*T.b+(3*n-2*y)*Y.b,C.a=6*(n-y)*h.a+(3*n-4*y+1)*d.a+6*(-n+y)*T.a+(3*n-2*y)*Y.a}static FromColor3(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new r(h.r,h.g,h.b,d)}static Bd(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new r(h[d],h[d+1],h[d+2],h[d+3])}static FromArrayToRef(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2?arguments[2]:void 0;T.r=h[d],T.g=h[d+1],T.b=h[d+2],T.a=h[d+3]}static FromInts(h,d,T,Y){return new r(h/255,d/255,T/255,Y/255)}static CheckColors4(h,d){if(h.length===3*d){const d=[];for(let T=0;T<h.length;T+=3){const Y=T/3*4;d[Y]=h[T],d[Y+1]=h[T+1],d[Y+2]=h[T+2],d[Y+3]=1}return d}return h}}r._V8PerformanceHack=new r(.5,.5,.5,.5),Object.defineProperties(r.prototype,{dimension:{value:[4]},rank:{value:1}});class c{}c.ed=(0,Y.e)(3,S.Black),c.ln=(0,Y.e)(3,(()=>new r(0,0,0,0))),(0,y.e)("BABYLON.Color3",S),(0,y.e)("BABYLON.Color4",r)}}]);