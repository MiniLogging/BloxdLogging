"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[17],{12920:(Y,c,h)=>{h.r(c),h.d(c,{ph:()=>q,vc:()=>k,TmpColors:()=>M});var C=h(12877),E=h(12825),N=h(12874),Q=h(12883);function b(Y){return Math.pow(Y,N.l)}function H(Y){return Y<=.04045?.0773993808*Y:Math.pow(.947867299*(Y+.055),2.4)}function w(Y){return Math.pow(Y,N.k)}function W(Y){return Y<=.0031308?12.92*Y:1.055*Math.pow(Y,.41666)-.055}class q{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=Y,this.g=c,this.b=h}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"ph"}getHashCode(){let Y=255*this.r|0;return Y=397*Y^255*this.g,Y=397*Y^255*this.b,Y}toArray(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[c]=this.r,Y[c+1]=this.g,Y[c+2]=this.b,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return q.FromArrayToRef(Y,c,this),this}toColor4(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new k(this.r,this.g,this.b,Y)}Xc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(Y){return new q(this.r*Y.r,this.g*Y.g,this.b*Y.b)}multiplyToRef(Y,c){return c.r=this.r*Y.r,c.g=this.g*Y.g,c.b=this.b*Y.b,c}multiplyInPlace(Y){return this.r*=Y.r,this.g*=Y.g,this.b*=Y.b,this}multiplyByFloats(Y,c,h){return new q(this.r*Y,this.g*c,this.b*h)}divide(Y){throw new ReferenceError("Can not divide a color")}divideToRef(Y,c){throw new ReferenceError("Can not divide a color")}divideInPlace(Y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Y){return this.minimizeInPlaceFromFloats(Y.r,Y.g,Y.b)}maximizeInPlace(Y){return this.maximizeInPlaceFromFloats(Y.r,Y.g,Y.b)}minimizeInPlaceFromFloats(Y,c,h){return this.r=Math.min(Y,this.r),this.g=Math.min(c,this.g),this.b=Math.min(h,this.b),this}maximizeInPlaceFromFloats(Y,c,h){return this.r=Math.max(Y,this.r),this.g=Math.max(c,this.g),this.b=Math.max(h,this.b),this}floorToRef(Y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(Y){return Y&&this.r===Y.r&&this.g===Y.g&&this.b===Y.b}equalsFloats(Y,c,h){return this.equalsToFloats(Y,c,h)}equalsToFloats(Y,c,h){return this.r===Y&&this.g===c&&this.b===h}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return(0,Q.WithinEpsilon)(this.r,Y.r,c)&&(0,Q.WithinEpsilon)(this.g,Y.g,c)&&(0,Q.WithinEpsilon)(this.b,Y.b,c)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Y){throw new ReferenceError("Can not negate a color")}scale(Y){return new q(this.r*Y,this.g*Y,this.b*Y)}scaleInPlace(Y){return this.r*=Y,this.g*=Y,this.b*=Y,this}scaleToRef(Y,c){return c.r=this.r*Y,c.g=this.g*Y,c.b=this.b*Y,c}scaleAndAddToRef(Y,c){return c.r+=this.r*Y,c.g+=this.g*Y,c.b+=this.b*Y,c}clampToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,Q.Clamp)(this.r,Y,c),h.g=(0,Q.Clamp)(this.g,Y,c),h.b=(0,Q.Clamp)(this.b,Y,c),h}add(Y){return new q(this.r+Y.r,this.g+Y.g,this.b+Y.b)}addInPlace(Y){return this.r+=Y.r,this.g+=Y.g,this.b+=Y.b,this}addInPlaceFromFloats(Y,c,h){return this.r+=Y,this.g+=c,this.b+=h,this}addToRef(Y,c){return c.r=this.r+Y.r,c.g=this.g+Y.g,c.b=this.b+Y.b,c}Hh(Y){return new q(this.r-Y.r,this.g-Y.g,this.b-Y.b)}subtractToRef(Y,c){return c.r=this.r-Y.r,c.g=this.g-Y.g,c.b=this.b-Y.b,c}Lk(Y){return this.r-=Y.r,this.g-=Y.g,this.b-=Y.b,this}subtractFromFloats(Y,c,h){return new q(this.r-Y,this.g-c,this.b-h)}subtractFromFloatsToRef(Y,c,h,C){return C.r=this.r-Y,C.g=this.g-c,C.b=this.b-h,C}clone(){return new q(this.r,this.g,this.b)}N(Y){return this.r=Y.r,this.g=Y.g,this.b=Y.b,this}Vc(Y,c,h){return this.r=Y,this.g=c,this.b=h,this}set(Y,c,h){return this.Vc(Y,c,h)}nc(Y){return this.r=this.g=this.b=Y,this}toHexString(){const Y=Math.round(255*this.r),c=Math.round(255*this.g),h=Math.round(255*this.b);return"#"+(0,Q.ToHex)(Y)+(0,Q.ToHex)(c)+(0,Q.ToHex)(h)}fromHexString(Y){return"#"!==Y.substring(0,1)||7!==Y.length||(this.r=parseInt(Y.substring(1,3),16)/255,this.g=parseInt(Y.substring(3,5),16)/255,this.b=parseInt(Y.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new q)}toHSVToRef(Y){const c=this.r,h=this.g,C=this.b,E=Math.max(c,h,C),N=Math.min(c,h,C);let Q=0,b=0;const H=E,w=E-N;return 0!==E&&(b=w/E),E!=N&&(E==c?(Q=(h-C)/w,h<C&&(Q+=6)):E==h?Q=(C-c)/w+2:E==C&&(Q=(c-h)/w+4),Q*=60),Y.r=Q,Y.g=b,Y.b=H,Y}toLinearSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new q;return this.toLinearSpaceToRef(c,Y),c}toLinearSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=H(this.r),Y.g=H(this.g),Y.b=H(this.b)):(Y.r=b(this.r),Y.g=b(this.g),Y.b=b(this.b)),this}toGammaSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new q;return this.toGammaSpaceToRef(c,Y),c}toGammaSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=W(this.r),Y.g=W(this.g),Y.b=W(this.b)):(Y.r=w(this.r),Y.g=w(this.g),Y.b=w(this.b)),this}static HSVtoRGBToRef(Y,c,h,C){const E=h*c,N=Y/60,Q=E*(1-Math.abs(N%2-1));let b=0,H=0,w=0;N>=0&&N<=1?(b=E,H=Q):N>=1&&N<=2?(b=Q,H=E):N>=2&&N<=3?(H=E,w=Q):N>=3&&N<=4?(H=Q,w=E):N>=4&&N<=5?(b=Q,w=E):N>=5&&N<=6&&(b=E,w=Q);const W=h-E;return C.r=b+W,C.g=H+W,C.b=w+W,C}static FromHSV(Y,c,h){const C=new q(0,0,0);return q.HSVtoRGBToRef(Y,c,h,C),C}static FromHexString(Y){return new q(0,0,0).fromHexString(Y)}static dh(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new q(Y[c],Y[c+1],Y[c+2])}static FromArrayToRef(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=Y[c],h.g=Y[c+1],h.b=Y[c+2]}static FromInts(Y,c,h){return new q(Y/255,c/255,h/255)}static Lerp(Y,c,h){const C=new q(0,0,0);return q.LerpToRef(Y,c,h,C),C}static LerpToRef(Y,c,h,C){C.r=Y.r+(c.r-Y.r)*h,C.g=Y.g+(c.g-Y.g)*h,C.b=Y.b+(c.b-Y.b)*h}static Hermite(Y,c,h,C,E){const N=E*E,Q=E*N,b=2*Q-3*N+1,H=-2*Q+3*N,w=Q-2*N+E,W=Q-N,k=Y.r*b+h.r*H+c.r*w+C.r*W,M=Y.g*b+h.g*H+c.g*w+C.g*W,p=Y.b*b+h.b*H+c.b*w+C.b*W;return new q(k,M,p)}static Hermite1stDerivative(Y,c,h,C,E){const N=q.Black();return this.Hermite1stDerivativeToRef(Y,c,h,C,E,N),N}static Hermite1stDerivativeToRef(Y,c,h,C,E,N){const Q=E*E;N.r=6*(Q-E)*Y.r+(3*Q-4*E+1)*c.r+6*(-Q+E)*h.r+(3*Q-2*E)*C.r,N.g=6*(Q-E)*Y.g+(3*Q-4*E+1)*c.g+6*(-Q+E)*h.g+(3*Q-2*E)*C.g,N.b=6*(Q-E)*Y.b+(3*Q-4*E+1)*c.b+6*(-Q+E)*h.b+(3*Q-2*E)*C.b}static Red(){return new q(1,0,0)}static Green(){return new q(0,1,0)}static Blue(){return new q(0,0,1)}static Black(){return new q(0,0,0)}static get BlackReadOnly(){return q._BlackReadOnly}static White(){return new q(1,1,1)}static Purple(){return new q(.5,0,.5)}static Magenta(){return new q(1,0,1)}static Yellow(){return new q(1,1,0)}static Gray(){return new q(.5,.5,.5)}static Teal(){return new q(0,1,1)}static Random(){return new q(Math.random(),Math.random(),Math.random())}}q._V8PerformanceHack=new q(.5,.5,.5),q._BlackReadOnly=q.Black(),Object.defineProperties(q.prototype,{dimension:{value:[3]},rank:{value:1}});class k{constructor(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=Y,this.g=c,this.b=h,this.a=C}Xc(){return[this.r,this.g,this.b,this.a]}toArray(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return Y[c]=this.r,Y[c+1]=this.g,Y[c+2]=this.b,Y[c+3]=this.a,this}IC(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=Y[c],this.g=Y[c+1],this.b=Y[c+2],this.a=Y[c+3],this}equals(Y){return Y&&this.r===Y.r&&this.g===Y.g&&this.b===Y.b&&this.a===Y.a}add(Y){return new k(this.r+Y.r,this.g+Y.g,this.b+Y.b,this.a+Y.a)}addToRef(Y,c){return c.r=this.r+Y.r,c.g=this.g+Y.g,c.b=this.b+Y.b,c.a=this.a+Y.a,c}addInPlace(Y){return this.r+=Y.r,this.g+=Y.g,this.b+=Y.b,this.a+=Y.a,this}addInPlaceFromFloats(Y,c,h,C){return this.r+=Y,this.g+=c,this.b+=h,this.a+=C,this}Hh(Y){return new k(this.r-Y.r,this.g-Y.g,this.b-Y.b,this.a-Y.a)}subtractToRef(Y,c){return c.r=this.r-Y.r,c.g=this.g-Y.g,c.b=this.b-Y.b,c.a=this.a-Y.a,c}Lk(Y){return this.r-=Y.r,this.g-=Y.g,this.b-=Y.b,this.a-=Y.a,this}subtractFromFloats(Y,c,h,C){return new k(this.r-Y,this.g-c,this.b-h,this.a-C)}subtractFromFloatsToRef(Y,c,h,C,E){return E.r=this.r-Y,E.g=this.g-c,E.b=this.b-h,E.a=this.a-C,E}scale(Y){return new k(this.r*Y,this.g*Y,this.b*Y,this.a*Y)}scaleInPlace(Y){return this.r*=Y,this.g*=Y,this.b*=Y,this.a*=Y,this}scaleToRef(Y,c){return c.r=this.r*Y,c.g=this.g*Y,c.b=this.b*Y,c.a=this.a*Y,c}scaleAndAddToRef(Y,c){return c.r+=this.r*Y,c.g+=this.g*Y,c.b+=this.b*Y,c.a+=this.a*Y,c}clampToRef(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0;return h.r=(0,Q.Clamp)(this.r,Y,c),h.g=(0,Q.Clamp)(this.g,Y,c),h.b=(0,Q.Clamp)(this.b,Y,c),h.a=(0,Q.Clamp)(this.a,Y,c),h}multiply(Y){return new k(this.r*Y.r,this.g*Y.g,this.b*Y.b,this.a*Y.a)}multiplyToRef(Y,c){return c.r=this.r*Y.r,c.g=this.g*Y.g,c.b=this.b*Y.b,c.a=this.a*Y.a,c}multiplyInPlace(Y){return this.r*=Y.r,this.g*=Y.g,this.b*=Y.b,this.a*=Y.a,this}multiplyByFloats(Y,c,h,C){return new k(this.r*Y,this.g*c,this.b*h,this.a*C)}divide(Y){throw new ReferenceError("Can not divide a color")}divideToRef(Y,c){throw new ReferenceError("Can not divide a color")}divideInPlace(Y){throw new ReferenceError("Can not divide a color")}minimizeInPlace(Y){return this.r=Math.min(this.r,Y.r),this.g=Math.min(this.g,Y.g),this.b=Math.min(this.b,Y.b),this.a=Math.min(this.a,Y.a),this}maximizeInPlace(Y){return this.r=Math.max(this.r,Y.r),this.g=Math.max(this.g,Y.g),this.b=Math.max(this.b,Y.b),this.a=Math.max(this.a,Y.a),this}minimizeInPlaceFromFloats(Y,c,h,C){return this.r=Math.min(Y,this.r),this.g=Math.min(c,this.g),this.b=Math.min(h,this.b),this.a=Math.min(C,this.a),this}maximizeInPlaceFromFloats(Y,c,h,C){return this.r=Math.max(Y,this.r),this.g=Math.max(c,this.g),this.b=Math.max(h,this.b),this.a=Math.max(C,this.a),this}floorToRef(Y){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(Y){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(Y){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:N.d;return(0,Q.WithinEpsilon)(this.r,Y.r,c)&&(0,Q.WithinEpsilon)(this.g,Y.g,c)&&(0,Q.WithinEpsilon)(this.b,Y.b,c)&&(0,Q.WithinEpsilon)(this.a,Y.a,c)}equalsToFloats(Y,c,h,C){return this.r===Y&&this.g===c&&this.b===h&&this.a===C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"vc"}getHashCode(){let Y=255*this.r|0;return Y=397*Y^255*this.g,Y=397*Y^255*this.b,Y=397*Y^255*this.a,Y}clone(){return(new k).N(this)}N(Y){return this.r=Y.r,this.g=Y.g,this.b=Y.b,this.a=Y.a,this}Vc(Y,c,h,C){return this.r=Y,this.g=c,this.b=h,this.a=C,this}set(Y,c,h,C){return this.Vc(Y,c,h,C)}nc(Y){return this.r=this.g=this.b=this.a=Y,this}toHexString(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=Math.round(255*this.r),h=Math.round(255*this.g),C=Math.round(255*this.b);if(Y)return"#"+(0,Q.ToHex)(c)+(0,Q.ToHex)(h)+(0,Q.ToHex)(C);const E=Math.round(255*this.a);return"#"+(0,Q.ToHex)(c)+(0,Q.ToHex)(h)+(0,Q.ToHex)(C)+(0,Q.ToHex)(E)}fromHexString(Y){return"#"!==Y.substring(0,1)||9!==Y.length&&7!==Y.length||(this.r=parseInt(Y.substring(1,3),16)/255,this.g=parseInt(Y.substring(3,5),16)/255,this.b=parseInt(Y.substring(5,7),16)/255,9===Y.length&&(this.a=parseInt(Y.substring(7,9),16)/255)),this}toLinearSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new k;return this.toLinearSpaceToRef(c,Y),c}toLinearSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=H(this.r),Y.g=H(this.g),Y.b=H(this.b)):(Y.r=b(this.r),Y.g=b(this.g),Y.b=b(this.b)),Y.a=this.a,this}toGammaSpace(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new k;return this.toGammaSpaceToRef(c,Y),c}toGammaSpaceToRef(Y){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(Y.r=W(this.r),Y.g=W(this.g),Y.b=W(this.b)):(Y.r=w(this.r),Y.g=w(this.g),Y.b=w(this.b)),Y.a=this.a,this}static FromHexString(Y){return"#"!==Y.substring(0,1)||9!==Y.length&&7!==Y.length?new k(0,0,0,0):new k(0,0,0,1).fromHexString(Y)}static Lerp(Y,c,h){return k.LerpToRef(Y,c,h,new k)}static LerpToRef(Y,c,h,C){return C.r=Y.r+(c.r-Y.r)*h,C.g=Y.g+(c.g-Y.g)*h,C.b=Y.b+(c.b-Y.b)*h,C.a=Y.a+(c.a-Y.a)*h,C}static Hermite(Y,c,h,C,E){const N=E*E,Q=E*N,b=2*Q-3*N+1,H=-2*Q+3*N,w=Q-2*N+E,W=Q-N,q=Y.r*b+h.r*H+c.r*w+C.r*W,M=Y.g*b+h.g*H+c.g*w+C.g*W,p=Y.b*b+h.b*H+c.b*w+C.b*W,P=Y.a*b+h.a*H+c.a*w+C.a*W;return new k(q,M,p,P)}static Hermite1stDerivative(Y,c,h,C,E){const N=new k;return this.Hermite1stDerivativeToRef(Y,c,h,C,E,N),N}static Hermite1stDerivativeToRef(Y,c,h,C,E,N){const Q=E*E;N.r=6*(Q-E)*Y.r+(3*Q-4*E+1)*c.r+6*(-Q+E)*h.r+(3*Q-2*E)*C.r,N.g=6*(Q-E)*Y.g+(3*Q-4*E+1)*c.g+6*(-Q+E)*h.g+(3*Q-2*E)*C.g,N.b=6*(Q-E)*Y.b+(3*Q-4*E+1)*c.b+6*(-Q+E)*h.b+(3*Q-2*E)*C.b,N.a=6*(Q-E)*Y.a+(3*Q-4*E+1)*c.a+6*(-Q+E)*h.a+(3*Q-2*E)*C.a}static FromColor3(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new k(Y.r,Y.g,Y.b,c)}static dh(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new k(Y[c],Y[c+1],Y[c+2],Y[c+3])}static FromArrayToRef(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2?arguments[2]:void 0;h.r=Y[c],h.g=Y[c+1],h.b=Y[c+2],h.a=Y[c+3]}static FromInts(Y,c,h,C){return new k(Y/255,c/255,h/255,C/255)}static CheckColors4(Y,c){if(Y.length===3*c){const c=[];for(let h=0;h<Y.length;h+=3){const C=h/3*4;c[C]=Y[h],c[C+1]=Y[h+1],c[C+2]=Y[h+2],c[C+3]=1}return c}return Y}}k._V8PerformanceHack=new k(.5,.5,.5,.5),Object.defineProperties(k.prototype,{dimension:{value:[4]},rank:{value:1}});class M{}M.ph=(0,C.b)(3,q.Black),M.vc=(0,C.b)(3,(()=>new k(0,0,0,0))),(0,E.e)("BABYLON.Color3",q),(0,E.e)("BABYLON.Color4",k)}}]);