"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[17],{12286:(i,x,e)=>{e.r(x),e.d(x,{MJ:()=>A,lJ:()=>K,TmpColors:()=>L});var j=e(12259),E=e(12204),a=e(12253),Y=e(12264);function J(i){return Math.pow(i,a.m)}function u(i){return i<=.04045?.0773993808*i:Math.pow(.947867299*(i+.055),2.4)}function b(i){return Math.pow(i,a.l)}function g(i){return i<=.0031308?12.92*i:1.055*Math.pow(i,.41666)-.055}class A{constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=i,this.g=x,this.b=e}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"MJ"}getHashCode(){let i=255*this.r|0;return i=397*i^255*this.g,i=397*i^255*this.b,i}toArray(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i[x]=this.r,i[x+1]=this.g,i[x+2]=this.b,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return A.FromArrayToRef(i,x,this),this}toColor4(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new K(this.r,this.g,this.b,i)}de(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(i){return new A(this.r*i.r,this.g*i.g,this.b*i.b)}multiplyToRef(i,x){return x.r=this.r*i.r,x.g=this.g*i.g,x.b=this.b*i.b,x}multiplyInPlace(i){return this.r*=i.r,this.g*=i.g,this.b*=i.b,this}multiplyByFloats(i,x,e){return new A(this.r*i,this.g*x,this.b*e)}divide(i){throw new ReferenceError("Can not divide a color")}divideToRef(i,x){throw new ReferenceError("Can not divide a color")}divideInPlace(i){throw new ReferenceError("Can not divide a color")}minimizeInPlace(i){return this.minimizeInPlaceFromFloats(i.r,i.g,i.b)}maximizeInPlace(i){return this.maximizeInPlaceFromFloats(i.r,i.g,i.b)}minimizeInPlaceFromFloats(i,x,e){return this.r=Math.min(i,this.r),this.g=Math.min(x,this.g),this.b=Math.min(e,this.b),this}maximizeInPlaceFromFloats(i,x,e){return this.r=Math.max(i,this.r),this.g=Math.max(x,this.g),this.b=Math.max(e,this.b),this}floorToRef(i){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(i){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(i){return i&&this.r===i.r&&this.g===i.g&&this.b===i.b}equalsFloats(i,x,e){return this.equalsToFloats(i,x,e)}equalsToFloats(i,x,e){return this.r===i&&this.g===x&&this.b===e}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a.e;return(0,Y.WithinEpsilon)(this.r,i.r,x)&&(0,Y.WithinEpsilon)(this.g,i.g,x)&&(0,Y.WithinEpsilon)(this.b,i.b,x)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(i){throw new ReferenceError("Can not negate a color")}scale(i){return new A(this.r*i,this.g*i,this.b*i)}scaleInPlace(i){return this.r*=i,this.g*=i,this.b*=i,this}scaleToRef(i,x){return x.r=this.r*i,x.g=this.g*i,x.b=this.b*i,x}scaleAndAddToRef(i,x){return x.r+=this.r*i,x.g+=this.g*i,x.b+=this.b*i,x}clampToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,e=arguments.length>2?arguments[2]:void 0;return e.r=(0,Y.Clamp)(this.r,i,x),e.g=(0,Y.Clamp)(this.g,i,x),e.b=(0,Y.Clamp)(this.b,i,x),e}add(i){return new A(this.r+i.r,this.g+i.g,this.b+i.b)}addInPlace(i){return this.r+=i.r,this.g+=i.g,this.b+=i.b,this}addInPlaceFromFloats(i,x,e){return this.r+=i,this.g+=x,this.b+=e,this}addToRef(i,x){return x.r=this.r+i.r,x.g=this.g+i.g,x.b=this.b+i.b,x}Cx(i){return new A(this.r-i.r,this.g-i.g,this.b-i.b)}subtractToRef(i,x){return x.r=this.r-i.r,x.g=this.g-i.g,x.b=this.b-i.b,x}jK(i){return this.r-=i.r,this.g-=i.g,this.b-=i.b,this}subtractFromFloats(i,x,e){return new A(this.r-i,this.g-x,this.b-e)}subtractFromFloatsToRef(i,x,e,j){return j.r=this.r-i,j.g=this.g-x,j.b=this.b-e,j}clone(){return new A(this.r,this.g,this.b)}A(i){return this.r=i.r,this.g=i.g,this.b=i.b,this}fJ(i,x,e){return this.r=i,this.g=x,this.b=e,this}set(i,x,e){return this.fJ(i,x,e)}OJ(i){return this.r=this.g=this.b=i,this}toHexString(){const i=Math.round(255*this.r),x=Math.round(255*this.g),e=Math.round(255*this.b);return"#"+(0,Y.ToHex)(i)+(0,Y.ToHex)(x)+(0,Y.ToHex)(e)}fromHexString(i){return"#"!==i.substring(0,1)||7!==i.length||(this.r=parseInt(i.substring(1,3),16)/255,this.g=parseInt(i.substring(3,5),16)/255,this.b=parseInt(i.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new A)}toHSVToRef(i){const x=this.r,e=this.g,j=this.b,E=Math.max(x,e,j),a=Math.min(x,e,j);let Y=0,J=0;const u=E,b=E-a;return 0!==E&&(J=b/E),E!=a&&(E==x?(Y=(e-j)/b,e<j&&(Y+=6)):E==e?Y=(j-x)/b+2:E==j&&(Y=(x-e)/b+4),Y*=60),i.r=Y,i.g=J,i.b=u,i}toLinearSpace(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new A;return this.toLinearSpaceToRef(x,i),x}toLinearSpaceToRef(i){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(i.r=u(this.r),i.g=u(this.g),i.b=u(this.b)):(i.r=J(this.r),i.g=J(this.g),i.b=J(this.b)),this}toGammaSpace(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new A;return this.toGammaSpaceToRef(x,i),x}toGammaSpaceToRef(i){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(i.r=g(this.r),i.g=g(this.g),i.b=g(this.b)):(i.r=b(this.r),i.g=b(this.g),i.b=b(this.b)),this}static HSVtoRGBToRef(i,x,e,j){const E=e*x,a=i/60,Y=E*(1-Math.abs(a%2-1));let J=0,u=0,b=0;a>=0&&a<=1?(J=E,u=Y):a>=1&&a<=2?(J=Y,u=E):a>=2&&a<=3?(u=E,b=Y):a>=3&&a<=4?(u=Y,b=E):a>=4&&a<=5?(J=Y,b=E):a>=5&&a<=6&&(J=E,b=Y);const g=e-E;return j.r=J+g,j.g=u+g,j.b=b+g,j}static FromHSV(i,x,e){const j=new A(0,0,0);return A.HSVtoRGBToRef(i,x,e,j),j}static FromHexString(i){return new A(0,0,0).fromHexString(i)}static zJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new A(i[x],i[x+1],i[x+2])}static FromArrayToRef(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2?arguments[2]:void 0;e.r=i[x],e.g=i[x+1],e.b=i[x+2]}static FromInts(i,x,e){return new A(i/255,x/255,e/255)}static Lerp(i,x,e){const j=new A(0,0,0);return A.LerpToRef(i,x,e,j),j}static LerpToRef(i,x,e,j){j.r=i.r+(x.r-i.r)*e,j.g=i.g+(x.g-i.g)*e,j.b=i.b+(x.b-i.b)*e}static Hermite(i,x,e,j,E){const a=E*E,Y=E*a,J=2*Y-3*a+1,u=-2*Y+3*a,b=Y-2*a+E,g=Y-a,K=i.r*J+e.r*u+x.r*b+j.r*g,L=i.g*J+e.g*u+x.g*b+j.g*g,o=i.b*J+e.b*u+x.b*b+j.b*g;return new A(K,L,o)}static Hermite1stDerivative(i,x,e,j,E){const a=A.Black();return this.Hermite1stDerivativeToRef(i,x,e,j,E,a),a}static Hermite1stDerivativeToRef(i,x,e,j,E,a){const Y=E*E;a.r=6*(Y-E)*i.r+(3*Y-4*E+1)*x.r+6*(-Y+E)*e.r+(3*Y-2*E)*j.r,a.g=6*(Y-E)*i.g+(3*Y-4*E+1)*x.g+6*(-Y+E)*e.g+(3*Y-2*E)*j.g,a.b=6*(Y-E)*i.b+(3*Y-4*E+1)*x.b+6*(-Y+E)*e.b+(3*Y-2*E)*j.b}static Red(){return new A(1,0,0)}static Green(){return new A(0,1,0)}static Blue(){return new A(0,0,1)}static Black(){return new A(0,0,0)}static get BlackReadOnly(){return A._BlackReadOnly}static White(){return new A(1,1,1)}static Purple(){return new A(.5,0,.5)}static Magenta(){return new A(1,0,1)}static Yellow(){return new A(1,1,0)}static Gray(){return new A(.5,.5,.5)}static Teal(){return new A(0,1,1)}static Random(){return new A(Math.random(),Math.random(),Math.random())}}A._V8PerformanceHack=new A(.5,.5,.5),A._BlackReadOnly=A.Black(),Object.defineProperties(A.prototype,{dimension:{value:[3]},rank:{value:1}});class K{constructor(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=i,this.g=x,this.b=e,this.a=j}de(){return[this.r,this.g,this.b,this.a]}toArray(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return i[x]=this.r,i[x+1]=this.g,i[x+2]=this.b,i[x+3]=this.a,this}AJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=i[x],this.g=i[x+1],this.b=i[x+2],this.a=i[x+3],this}equals(i){return i&&this.r===i.r&&this.g===i.g&&this.b===i.b&&this.a===i.a}add(i){return new K(this.r+i.r,this.g+i.g,this.b+i.b,this.a+i.a)}addToRef(i,x){return x.r=this.r+i.r,x.g=this.g+i.g,x.b=this.b+i.b,x.a=this.a+i.a,x}addInPlace(i){return this.r+=i.r,this.g+=i.g,this.b+=i.b,this.a+=i.a,this}addInPlaceFromFloats(i,x,e,j){return this.r+=i,this.g+=x,this.b+=e,this.a+=j,this}Cx(i){return new K(this.r-i.r,this.g-i.g,this.b-i.b,this.a-i.a)}subtractToRef(i,x){return x.r=this.r-i.r,x.g=this.g-i.g,x.b=this.b-i.b,x.a=this.a-i.a,x}jK(i){return this.r-=i.r,this.g-=i.g,this.b-=i.b,this.a-=i.a,this}subtractFromFloats(i,x,e,j){return new K(this.r-i,this.g-x,this.b-e,this.a-j)}subtractFromFloatsToRef(i,x,e,j,E){return E.r=this.r-i,E.g=this.g-x,E.b=this.b-e,E.a=this.a-j,E}scale(i){return new K(this.r*i,this.g*i,this.b*i,this.a*i)}scaleInPlace(i){return this.r*=i,this.g*=i,this.b*=i,this.a*=i,this}scaleToRef(i,x){return x.r=this.r*i,x.g=this.g*i,x.b=this.b*i,x.a=this.a*i,x}scaleAndAddToRef(i,x){return x.r+=this.r*i,x.g+=this.g*i,x.b+=this.b*i,x.a+=this.a*i,x}clampToRef(){let i=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,e=arguments.length>2?arguments[2]:void 0;return e.r=(0,Y.Clamp)(this.r,i,x),e.g=(0,Y.Clamp)(this.g,i,x),e.b=(0,Y.Clamp)(this.b,i,x),e.a=(0,Y.Clamp)(this.a,i,x),e}multiply(i){return new K(this.r*i.r,this.g*i.g,this.b*i.b,this.a*i.a)}multiplyToRef(i,x){return x.r=this.r*i.r,x.g=this.g*i.g,x.b=this.b*i.b,x.a=this.a*i.a,x}multiplyInPlace(i){return this.r*=i.r,this.g*=i.g,this.b*=i.b,this.a*=i.a,this}multiplyByFloats(i,x,e,j){return new K(this.r*i,this.g*x,this.b*e,this.a*j)}divide(i){throw new ReferenceError("Can not divide a color")}divideToRef(i,x){throw new ReferenceError("Can not divide a color")}divideInPlace(i){throw new ReferenceError("Can not divide a color")}minimizeInPlace(i){return this.r=Math.min(this.r,i.r),this.g=Math.min(this.g,i.g),this.b=Math.min(this.b,i.b),this.a=Math.min(this.a,i.a),this}maximizeInPlace(i){return this.r=Math.max(this.r,i.r),this.g=Math.max(this.g,i.g),this.b=Math.max(this.b,i.b),this.a=Math.max(this.a,i.a),this}minimizeInPlaceFromFloats(i,x,e,j){return this.r=Math.min(i,this.r),this.g=Math.min(x,this.g),this.b=Math.min(e,this.b),this.a=Math.min(j,this.a),this}maximizeInPlaceFromFloats(i,x,e,j){return this.r=Math.max(i,this.r),this.g=Math.max(x,this.g),this.b=Math.max(e,this.b),this.a=Math.max(j,this.a),this}floorToRef(i){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(i){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(i){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:a.e;return(0,Y.WithinEpsilon)(this.r,i.r,x)&&(0,Y.WithinEpsilon)(this.g,i.g,x)&&(0,Y.WithinEpsilon)(this.b,i.b,x)&&(0,Y.WithinEpsilon)(this.a,i.a,x)}equalsToFloats(i,x,e,j){return this.r===i&&this.g===x&&this.b===e&&this.a===j}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"lJ"}getHashCode(){let i=255*this.r|0;return i=397*i^255*this.g,i=397*i^255*this.b,i=397*i^255*this.a,i}clone(){return(new K).A(this)}A(i){return this.r=i.r,this.g=i.g,this.b=i.b,this.a=i.a,this}fJ(i,x,e,j){return this.r=i,this.g=x,this.b=e,this.a=j,this}set(i,x,e,j){return this.fJ(i,x,e,j)}OJ(i){return this.r=this.g=this.b=this.a=i,this}toHexString(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=Math.round(255*this.r),e=Math.round(255*this.g),j=Math.round(255*this.b);if(i)return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(e)+(0,Y.ToHex)(j);const E=Math.round(255*this.a);return"#"+(0,Y.ToHex)(x)+(0,Y.ToHex)(e)+(0,Y.ToHex)(j)+(0,Y.ToHex)(E)}fromHexString(i){return"#"!==i.substring(0,1)||9!==i.length&&7!==i.length||(this.r=parseInt(i.substring(1,3),16)/255,this.g=parseInt(i.substring(3,5),16)/255,this.b=parseInt(i.substring(5,7),16)/255,9===i.length&&(this.a=parseInt(i.substring(7,9),16)/255)),this}toLinearSpace(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new K;return this.toLinearSpaceToRef(x,i),x}toLinearSpaceToRef(i){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(i.r=u(this.r),i.g=u(this.g),i.b=u(this.b)):(i.r=J(this.r),i.g=J(this.g),i.b=J(this.b)),i.a=this.a,this}toGammaSpace(){let i=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new K;return this.toGammaSpaceToRef(x,i),x}toGammaSpaceToRef(i){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(i.r=g(this.r),i.g=g(this.g),i.b=g(this.b)):(i.r=b(this.r),i.g=b(this.g),i.b=b(this.b)),i.a=this.a,this}static FromHexString(i){return"#"!==i.substring(0,1)||9!==i.length&&7!==i.length?new K(0,0,0,0):new K(0,0,0,1).fromHexString(i)}static Lerp(i,x,e){return K.LerpToRef(i,x,e,new K)}static LerpToRef(i,x,e,j){return j.r=i.r+(x.r-i.r)*e,j.g=i.g+(x.g-i.g)*e,j.b=i.b+(x.b-i.b)*e,j.a=i.a+(x.a-i.a)*e,j}static Hermite(i,x,e,j,E){const a=E*E,Y=E*a,J=2*Y-3*a+1,u=-2*Y+3*a,b=Y-2*a+E,g=Y-a,A=i.r*J+e.r*u+x.r*b+j.r*g,L=i.g*J+e.g*u+x.g*b+j.g*g,o=i.b*J+e.b*u+x.b*b+j.b*g,M=i.a*J+e.a*u+x.a*b+j.a*g;return new K(A,L,o,M)}static Hermite1stDerivative(i,x,e,j,E){const a=new K;return this.Hermite1stDerivativeToRef(i,x,e,j,E,a),a}static Hermite1stDerivativeToRef(i,x,e,j,E,a){const Y=E*E;a.r=6*(Y-E)*i.r+(3*Y-4*E+1)*x.r+6*(-Y+E)*e.r+(3*Y-2*E)*j.r,a.g=6*(Y-E)*i.g+(3*Y-4*E+1)*x.g+6*(-Y+E)*e.g+(3*Y-2*E)*j.g,a.b=6*(Y-E)*i.b+(3*Y-4*E+1)*x.b+6*(-Y+E)*e.b+(3*Y-2*E)*j.b,a.a=6*(Y-E)*i.a+(3*Y-4*E+1)*x.a+6*(-Y+E)*e.a+(3*Y-2*E)*j.a}static FromColor3(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new K(i.r,i.g,i.b,x)}static zJ(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new K(i[x],i[x+1],i[x+2],i[x+3])}static FromArrayToRef(i){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,e=arguments.length>2?arguments[2]:void 0;e.r=i[x],e.g=i[x+1],e.b=i[x+2],e.a=i[x+3]}static FromInts(i,x,e,j){return new K(i/255,x/255,e/255,j/255)}static CheckColors4(i,x){if(i.length===3*x){const x=[];for(let e=0;e<i.length;e+=3){const j=e/3*4;x[j]=i[e],x[j+1]=i[e+1],x[j+2]=i[e+2],x[j+3]=1}return x}return i}}K._V8PerformanceHack=new K(.5,.5,.5,.5),Object.defineProperties(K.prototype,{dimension:{value:[4]},rank:{value:1}});class L{}L.MJ=(0,j.d)(3,A.Black),L.lJ=(0,j.d)(3,(()=>new K(0,0,0,0))),(0,E.f)("BABYLON.Color3",A),(0,E.f)("BABYLON.Color4",K)}}]);