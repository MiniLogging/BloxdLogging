"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[17],{13010:(M,A,O)=>{O.r(A),O.d(A,{bA:()=>e,Cc:()=>T,TmpColors:()=>J});var S=O(12977),z=O(12919),Q=O(12974),X=O(12980);function c(M){return Math.pow(M,Q.n)}function j(M){return M<=.04045?.0773993808*M:Math.pow(.947867299*(M+.055),2.4)}function B(M){return Math.pow(M,Q.k)}function g(M){return M<=.0031308?12.92*M:1.055*Math.pow(M,.41666)-.055}class e{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=M,this.g=A,this.b=O}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"bA"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M}toArray(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[A]=this.r,M[A+1]=this.g,M[A+2]=this.b,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return e.FromArrayToRef(M,A,this),this}toColor4(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new T(this.r,this.g,this.b,M)}gc(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(M){return new e(this.r*M.r,this.g*M.g,this.b*M.b)}multiplyToRef(M,A){return A.r=this.r*M.r,A.g=this.g*M.g,A.b=this.b*M.b,A}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this}multiplyByFloats(M,A,O){return new e(this.r*M,this.g*A,this.b*O)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,A){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.minimizeInPlaceFromFloats(M.r,M.g,M.b)}maximizeInPlace(M){return this.maximizeInPlaceFromFloats(M.r,M.g,M.b)}minimizeInPlaceFromFloats(M,A,O){return this.r=Math.min(M,this.r),this.g=Math.min(A,this.g),this.b=Math.min(O,this.b),this}maximizeInPlaceFromFloats(M,A,O){return this.r=Math.max(M,this.r),this.g=Math.max(A,this.g),this.b=Math.max(O,this.b),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b}equalsFloats(M,A,O){return this.equalsToFloats(M,A,O)}equalsToFloats(M,A,O){return this.r===M&&this.g===A&&this.b===O}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.e;return(0,X.WithinEpsilon)(this.r,M.r,A)&&(0,X.WithinEpsilon)(this.g,M.g,A)&&(0,X.WithinEpsilon)(this.b,M.b,A)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}scale(M){return new e(this.r*M,this.g*M,this.b*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this}scaleToRef(M,A){return A.r=this.r*M,A.g=this.g*M,A.b=this.b*M,A}scaleAndAddToRef(M,A){return A.r+=this.r*M,A.g+=this.g*M,A.b+=this.b*M,A}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,O=arguments.length>2?arguments[2]:void 0;return O.r=(0,X.Clamp)(this.r,M,A),O.g=(0,X.Clamp)(this.g,M,A),O.b=(0,X.Clamp)(this.b,M,A),O}add(M){return new e(this.r+M.r,this.g+M.g,this.b+M.b)}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this}addInPlaceFromFloats(M,A,O){return this.r+=M,this.g+=A,this.b+=O,this}addToRef(M,A){return A.r=this.r+M.r,A.g=this.g+M.g,A.b=this.b+M.b,A}dA(M){return new e(this.r-M.r,this.g-M.g,this.b-M.b)}subtractToRef(M,A){return A.r=this.r-M.r,A.g=this.g-M.g,A.b=this.b-M.b,A}KT(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this}subtractFromFloats(M,A,O){return new e(this.r-M,this.g-A,this.b-O)}subtractFromFloatsToRef(M,A,O,S){return S.r=this.r-M,S.g=this.g-A,S.b=this.b-O,S}clone(){return new e(this.r,this.g,this.b)}S(M){return this.r=M.r,this.g=M.g,this.b=M.b,this}Yc(M,A,O){return this.r=M,this.g=A,this.b=O,this}set(M,A,O){return this.Yc(M,A,O)}Hc(M){return this.r=this.g=this.b=M,this}toHexString(){const M=Math.round(255*this.r),A=Math.round(255*this.g),O=Math.round(255*this.b);return"#"+(0,X.ToHex)(M)+(0,X.ToHex)(A)+(0,X.ToHex)(O)}fromHexString(M){return"#"!==M.substring(0,1)||7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new e)}toHSVToRef(M){const A=this.r,O=this.g,S=this.b,z=Math.max(A,O,S),Q=Math.min(A,O,S);let X=0,c=0;const j=z,B=z-Q;return 0!==z&&(c=B/z),z!=Q&&(z==A?(X=(O-S)/B,O<S&&(X+=6)):z==O?X=(S-A)/B+2:z==S&&(X=(A-O)/B+4),X*=60),M.r=X,M.g=c,M.b=j,M}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new e;return this.toLinearSpaceToRef(A,M),A}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=j(this.r),M.g=j(this.g),M.b=j(this.b)):(M.r=c(this.r),M.g=c(this.g),M.b=c(this.b)),this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new e;return this.toGammaSpaceToRef(A,M),A}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=g(this.r),M.g=g(this.g),M.b=g(this.b)):(M.r=B(this.r),M.g=B(this.g),M.b=B(this.b)),this}static HSVtoRGBToRef(M,A,O,S){const z=O*A,Q=M/60,X=z*(1-Math.abs(Q%2-1));let c=0,j=0,B=0;Q>=0&&Q<=1?(c=z,j=X):Q>=1&&Q<=2?(c=X,j=z):Q>=2&&Q<=3?(j=z,B=X):Q>=3&&Q<=4?(j=X,B=z):Q>=4&&Q<=5?(c=X,B=z):Q>=5&&Q<=6&&(c=z,B=X);const g=O-z;return S.r=c+g,S.g=j+g,S.b=B+g,S}static FromHSV(M,A,O){const S=new e(0,0,0);return e.HSVtoRGBToRef(M,A,O,S),S}static FromHexString(M){return new e(0,0,0).fromHexString(M)}static sA(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new e(M[A],M[A+1],M[A+2])}static FromArrayToRef(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2?arguments[2]:void 0;O.r=M[A],O.g=M[A+1],O.b=M[A+2]}static FromInts(M,A,O){return new e(M/255,A/255,O/255)}static Lerp(M,A,O){const S=new e(0,0,0);return e.LerpToRef(M,A,O,S),S}static LerpToRef(M,A,O,S){S.r=M.r+(A.r-M.r)*O,S.g=M.g+(A.g-M.g)*O,S.b=M.b+(A.b-M.b)*O}static Hermite(M,A,O,S,z){const Q=z*z,X=z*Q,c=2*X-3*Q+1,j=-2*X+3*Q,B=X-2*Q+z,g=X-Q,T=M.r*c+O.r*j+A.r*B+S.r*g,J=M.g*c+O.g*j+A.g*B+S.g*g,K=M.b*c+O.b*j+A.b*B+S.b*g;return new e(T,J,K)}static Hermite1stDerivative(M,A,O,S,z){const Q=e.Black();return this.Hermite1stDerivativeToRef(M,A,O,S,z,Q),Q}static Hermite1stDerivativeToRef(M,A,O,S,z,Q){const X=z*z;Q.r=6*(X-z)*M.r+(3*X-4*z+1)*A.r+6*(-X+z)*O.r+(3*X-2*z)*S.r,Q.g=6*(X-z)*M.g+(3*X-4*z+1)*A.g+6*(-X+z)*O.g+(3*X-2*z)*S.g,Q.b=6*(X-z)*M.b+(3*X-4*z+1)*A.b+6*(-X+z)*O.b+(3*X-2*z)*S.b}static Red(){return new e(1,0,0)}static Green(){return new e(0,1,0)}static Blue(){return new e(0,0,1)}static Black(){return new e(0,0,0)}static get BlackReadOnly(){return e._BlackReadOnly}static White(){return new e(1,1,1)}static Purple(){return new e(.5,0,.5)}static Magenta(){return new e(1,0,1)}static Yellow(){return new e(1,1,0)}static Gray(){return new e(.5,.5,.5)}static Teal(){return new e(0,1,1)}static Random(){return new e(Math.random(),Math.random(),Math.random())}}e._V8PerformanceHack=new e(.5,.5,.5),e._BlackReadOnly=e.Black(),Object.defineProperties(e.prototype,{dimension:{value:[3]},rank:{value:1}});class T{constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=M,this.g=A,this.b=O,this.a=S}gc(){return[this.r,this.g,this.b,this.a]}toArray(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return M[A]=this.r,M[A+1]=this.g,M[A+2]=this.b,M[A+3]=this.a,this}GO(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=M[A],this.g=M[A+1],this.b=M[A+2],this.a=M[A+3],this}equals(M){return M&&this.r===M.r&&this.g===M.g&&this.b===M.b&&this.a===M.a}add(M){return new T(this.r+M.r,this.g+M.g,this.b+M.b,this.a+M.a)}addToRef(M,A){return A.r=this.r+M.r,A.g=this.g+M.g,A.b=this.b+M.b,A.a=this.a+M.a,A}addInPlace(M){return this.r+=M.r,this.g+=M.g,this.b+=M.b,this.a+=M.a,this}addInPlaceFromFloats(M,A,O,S){return this.r+=M,this.g+=A,this.b+=O,this.a+=S,this}dA(M){return new T(this.r-M.r,this.g-M.g,this.b-M.b,this.a-M.a)}subtractToRef(M,A){return A.r=this.r-M.r,A.g=this.g-M.g,A.b=this.b-M.b,A.a=this.a-M.a,A}KT(M){return this.r-=M.r,this.g-=M.g,this.b-=M.b,this.a-=M.a,this}subtractFromFloats(M,A,O,S){return new T(this.r-M,this.g-A,this.b-O,this.a-S)}subtractFromFloatsToRef(M,A,O,S,z){return z.r=this.r-M,z.g=this.g-A,z.b=this.b-O,z.a=this.a-S,z}scale(M){return new T(this.r*M,this.g*M,this.b*M,this.a*M)}scaleInPlace(M){return this.r*=M,this.g*=M,this.b*=M,this.a*=M,this}scaleToRef(M,A){return A.r=this.r*M,A.g=this.g*M,A.b=this.b*M,A.a=this.a*M,A}scaleAndAddToRef(M,A){return A.r+=this.r*M,A.g+=this.g*M,A.b+=this.b*M,A.a+=this.a*M,A}clampToRef(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,O=arguments.length>2?arguments[2]:void 0;return O.r=(0,X.Clamp)(this.r,M,A),O.g=(0,X.Clamp)(this.g,M,A),O.b=(0,X.Clamp)(this.b,M,A),O.a=(0,X.Clamp)(this.a,M,A),O}multiply(M){return new T(this.r*M.r,this.g*M.g,this.b*M.b,this.a*M.a)}multiplyToRef(M,A){return A.r=this.r*M.r,A.g=this.g*M.g,A.b=this.b*M.b,A.a=this.a*M.a,A}multiplyInPlace(M){return this.r*=M.r,this.g*=M.g,this.b*=M.b,this.a*=M.a,this}multiplyByFloats(M,A,O,S){return new T(this.r*M,this.g*A,this.b*O,this.a*S)}divide(M){throw new ReferenceError("Can not divide a color")}divideToRef(M,A){throw new ReferenceError("Can not divide a color")}divideInPlace(M){throw new ReferenceError("Can not divide a color")}minimizeInPlace(M){return this.r=Math.min(this.r,M.r),this.g=Math.min(this.g,M.g),this.b=Math.min(this.b,M.b),this.a=Math.min(this.a,M.a),this}maximizeInPlace(M){return this.r=Math.max(this.r,M.r),this.g=Math.max(this.g,M.g),this.b=Math.max(this.b,M.b),this.a=Math.max(this.a,M.a),this}minimizeInPlaceFromFloats(M,A,O,S){return this.r=Math.min(M,this.r),this.g=Math.min(A,this.g),this.b=Math.min(O,this.b),this.a=Math.min(S,this.a),this}maximizeInPlaceFromFloats(M,A,O,S){return this.r=Math.max(M,this.r),this.g=Math.max(A,this.g),this.b=Math.max(O,this.b),this.a=Math.max(S,this.a),this}floorToRef(M){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(M){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(M){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:Q.e;return(0,X.WithinEpsilon)(this.r,M.r,A)&&(0,X.WithinEpsilon)(this.g,M.g,A)&&(0,X.WithinEpsilon)(this.b,M.b,A)&&(0,X.WithinEpsilon)(this.a,M.a,A)}equalsToFloats(M,A,O,S){return this.r===M&&this.g===A&&this.b===O&&this.a===S}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Cc"}getHashCode(){let M=255*this.r|0;return M=397*M^255*this.g,M=397*M^255*this.b,M=397*M^255*this.a,M}clone(){return(new T).S(this)}S(M){return this.r=M.r,this.g=M.g,this.b=M.b,this.a=M.a,this}Yc(M,A,O,S){return this.r=M,this.g=A,this.b=O,this.a=S,this}set(M,A,O,S){return this.Yc(M,A,O,S)}Hc(M){return this.r=this.g=this.b=this.a=M,this}toHexString(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=Math.round(255*this.r),O=Math.round(255*this.g),S=Math.round(255*this.b);if(M)return"#"+(0,X.ToHex)(A)+(0,X.ToHex)(O)+(0,X.ToHex)(S);const z=Math.round(255*this.a);return"#"+(0,X.ToHex)(A)+(0,X.ToHex)(O)+(0,X.ToHex)(S)+(0,X.ToHex)(z)}fromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length||(this.r=parseInt(M.substring(1,3),16)/255,this.g=parseInt(M.substring(3,5),16)/255,this.b=parseInt(M.substring(5,7),16)/255,9===M.length&&(this.a=parseInt(M.substring(7,9),16)/255)),this}toLinearSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new T;return this.toLinearSpaceToRef(A,M),A}toLinearSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=j(this.r),M.g=j(this.g),M.b=j(this.b)):(M.r=c(this.r),M.g=c(this.g),M.b=c(this.b)),M.a=this.a,this}toGammaSpace(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new T;return this.toGammaSpaceToRef(A,M),A}toGammaSpaceToRef(M){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(M.r=g(this.r),M.g=g(this.g),M.b=g(this.b)):(M.r=B(this.r),M.g=B(this.g),M.b=B(this.b)),M.a=this.a,this}static FromHexString(M){return"#"!==M.substring(0,1)||9!==M.length&&7!==M.length?new T(0,0,0,0):new T(0,0,0,1).fromHexString(M)}static Lerp(M,A,O){return T.LerpToRef(M,A,O,new T)}static LerpToRef(M,A,O,S){return S.r=M.r+(A.r-M.r)*O,S.g=M.g+(A.g-M.g)*O,S.b=M.b+(A.b-M.b)*O,S.a=M.a+(A.a-M.a)*O,S}static Hermite(M,A,O,S,z){const Q=z*z,X=z*Q,c=2*X-3*Q+1,j=-2*X+3*Q,B=X-2*Q+z,g=X-Q,e=M.r*c+O.r*j+A.r*B+S.r*g,J=M.g*c+O.g*j+A.g*B+S.g*g,K=M.b*c+O.b*j+A.b*B+S.b*g,G=M.a*c+O.a*j+A.a*B+S.a*g;return new T(e,J,K,G)}static Hermite1stDerivative(M,A,O,S,z){const Q=new T;return this.Hermite1stDerivativeToRef(M,A,O,S,z,Q),Q}static Hermite1stDerivativeToRef(M,A,O,S,z,Q){const X=z*z;Q.r=6*(X-z)*M.r+(3*X-4*z+1)*A.r+6*(-X+z)*O.r+(3*X-2*z)*S.r,Q.g=6*(X-z)*M.g+(3*X-4*z+1)*A.g+6*(-X+z)*O.g+(3*X-2*z)*S.g,Q.b=6*(X-z)*M.b+(3*X-4*z+1)*A.b+6*(-X+z)*O.b+(3*X-2*z)*S.b,Q.a=6*(X-z)*M.a+(3*X-4*z+1)*A.a+6*(-X+z)*O.a+(3*X-2*z)*S.a}static FromColor3(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new T(M.r,M.g,M.b,A)}static sA(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(M[A],M[A+1],M[A+2],M[A+3])}static FromArrayToRef(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2?arguments[2]:void 0;O.r=M[A],O.g=M[A+1],O.b=M[A+2],O.a=M[A+3]}static FromInts(M,A,O,S){return new T(M/255,A/255,O/255,S/255)}static CheckColors4(M,A){if(M.length===3*A){const A=[];for(let O=0;O<M.length;O+=3){const S=O/3*4;A[S]=M[O],A[S+1]=M[O+1],A[S+2]=M[O+2],A[S+3]=1}return A}return M}}T._V8PerformanceHack=new T(.5,.5,.5,.5),Object.defineProperties(T.prototype,{dimension:{value:[4]},rank:{value:1}});class J{}J.bA=(0,S.b)(3,e.Black),J.Cc=(0,S.b)(3,(()=>new T(0,0,0,0))),(0,z.g)("BABYLON.Color3",e),(0,z.g)("BABYLON.Color4",T)}}]);