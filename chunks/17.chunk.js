"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[17],{2503:(Z,U,n)=>{n.r(U),n.d(U,{ReadExrDataAsync:()=>FZ,_ExrTextureLoader:()=>dZ});var i=n(513),B=n(718);const l=4,H=4,V=1,G=2,R=8,d=65536,F=d>>3,y=14,S=65537,q=1<<y,c=q-1,s=59,z=63,O=2+z-s;var E,t;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(E||(E={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(t||(t={}));const p=function(){const Z=new ArrayBuffer(4),U=new Float32Array(Z),n=new Uint32Array(Z),i=new Uint32Array(512),B=new Uint32Array(512);for(let G=0;G<256;++G){const Z=G-127;Z<-27?(i[G]=0,i[256|G]=32768,B[G]=24,B[256|G]=24):Z<-14?(i[G]=1024>>-Z-14,i[256|G]=1024>>-Z-14|32768,B[G]=-Z-1,B[256|G]=-Z-1):Z<=15?(i[G]=Z+15<<10,i[256|G]=Z+15<<10|32768,B[G]=13,B[256|G]=13):Z<128?(i[G]=31744,i[256|G]=64512,B[G]=24,B[256|G]=24):(i[G]=31744,i[256|G]=64512,B[G]=13,B[256|G]=13)}const l=new Uint32Array(2048),H=new Uint32Array(64),V=new Uint32Array(64);for(let G=1;G<1024;++G){let Z=G<<13,U=0;for(;0===(8388608&Z);)Z<<=1,U-=8388608;Z&=-8388609,U+=947912704,l[G]=Z|U}for(let G=1024;G<2048;++G)l[G]=939524096+(G-1024<<13);for(let G=1;G<31;++G)H[G]=G<<23;H[31]=1199570944,H[32]=2147483648;for(let G=33;G<63;++G)H[G]=2147483648+(G-32<<23);H[63]=3347054592;for(let G=1;G<64;++G)32!==G&&(V[G]=1024);return{floatView:U,uint32View:n,baseTable:i,shiftTable:B,mantissaTable:l,exponentTable:H,offsetTable:V}}();function K(Z,U){const n=new Uint8Array(Z);let i=0;for(;0!=n[U.value+i];)i+=1;const B=(new TextDecoder).decode(n.slice(U.value,U.value+i));return U.value=U.value+i+1,B}function C(Z,U){const n=Z.getInt32(U.value,!0);return U.value+=l,n}function D(Z,U){const n=Z.getUint32(U.value,!0);return U.value+=l,n}function u(Z,U){const n=Z.getUint8(U.value);return U.value+=V,n}function j(Z,U){const n=Z.getUint16(U.value,!0);return U.value+=G,n}function v(Z,U){const n=Z[U.value];return U.value+=V,n}function X(Z,U){let n;return n="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(U.value,!0)):Z.getUint32(U.value+4,!0)+Number(Z.getUint32(U.value,!0)<<32),U.value+=R,n}function h(Z,U){const n=Z.getFloat32(U.value,!0);return U.value+=H,n}function P(Z,U){return function(Z){const U=(31744&Z)>>10,n=1023&Z;return(Z>>15?-1:1)*(U?31===U?n?NaN:1/0:Math.pow(2,U-15)*(1+n/1024):n/1024*6103515625e-14)}(j(Z,U))}function T(Z,U){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,B.Clamp)(Z,-65504,65504),p.floatView[0]=Z;const U=p.uint32View[0],n=U>>23&511;return p.baseTable[n]+((8388607&U)>>p.shiftTable[n])}(h(Z,U))}function x(Z,U,n,i){switch(n){case"string":case"stringvector":case"iccProfile":return function(Z,U,n){const i=(new TextDecoder).decode(new Uint8Array(Z).slice(U.value,U.value+n));return U.value=U.value+n,i}(Z.buffer,U,i);case"chlist":return function(Z,U,n){const i=U.value,B=[];for(;U.value<i+n-1;){const n=K(Z.buffer,U),i=C(Z,U),l=u(Z,U);U.value+=3;const H=C(Z,U),V=C(Z,U);B.push({name:n,pixelType:i,pLinear:l,xSampling:H,ySampling:V})}return U.value+=1,B}(Z,U,i);case"chromaticities":return function(Z,U){return{redX:h(Z,U),redY:h(Z,U),greenX:h(Z,U),greenY:h(Z,U),blueX:h(Z,U),blueY:h(Z,U),whiteX:h(Z,U),whiteY:h(Z,U)}}(Z,U);case"compression":return function(Z,U){return u(Z,U)}(Z,U);case"box2i":return function(Z,U){return{xMin:C(Z,U),yMin:C(Z,U),xMax:C(Z,U),yMax:C(Z,U)}}(Z,U);case"lineOrder":return function(Z,U){const n=u(Z,U);return t[n]}(Z,U);case"float":return h(Z,U);case"v2f":return function(Z,U){return[h(Z,U),h(Z,U)]}(Z,U);case"v3f":return function(Z,U){return[h(Z,U),h(Z,U),h(Z,U)]}(Z,U);case"int":return C(Z,U);case"rational":return function(Z,U){return[C(Z,U),D(Z,U)]}(Z,U);case"timecode":return function(Z,U){return[D(Z,U),D(Z,U)]}(Z,U);case"preview":return U.value+=i,"skipped";default:return void(U.value+=i)}}function w(Z){for(let U=1;U<Z.length;U++){const n=Z[U-1]+Z[U]-128;Z[U]=n}}function o(Z,U){let n=0,i=Math.floor((Z.length+1)/2),B=0;const l=Z.length-1;for(;!(B>l)&&(U[B++]=Z[n++],!(B>l));)U[B++]=Z[i++]}const N=20000630;function J(Z,U){if(Z.getUint32(0,!0)!=N)throw new Error("Incorrect OpenEXR format");const n=Z.getUint8(4),B=Z.getUint8(5),l={singleTile:!!(2&B),longName:!!(4&B),deepFormat:!!(8&B),multiPart:!!(16&B)};U.value=8;const H={};let V=!0;for(;V;){const n=K(Z.buffer,U);if(n){const B=K(Z.buffer,U),l=x(Z,U,B,D(Z,U));void 0===l?i.c.Warn(`Unknown header attribute type ${B}'.`):H[n]=l}else V=!1}if(0!=(-5&B))throw new Error("Unsupported file format");return{version:n,spec:l,...H}}const W=32768,a=65535;function M(Z,U,n,i,B){for(;n<Z;)U=U<<8|v(i,B),n+=8;return{l:U>>(n-=Z)&(1<<Z)-1,c:U,lc:n}}function m(Z,U,n,i){return{c:Z=Z<<8|v(n,i),lc:U+=8}}function A(Z,U,n,i,B,l,H,V,G){if(Z==U){if(i<8){const Z=m(n,i,B,l);n=Z.c,i=Z.lc}let Z=n>>(i-=8);if(Z=new Uint8Array([Z])[0],V.value+Z>G)return null;const U=H[V.value-1];for(;Z-- >0;)H[V.value++]=U}else{if(!(V.value<G))return null;H[V.value++]=Z}return{c:n,lc:i}}const Y=new Array(59);function Q(Z,U,n,i,B,l){const H=U;let V=0,G=0;for(;i<=B;i++){if(H.value-U.value>n)return;let R=M(6,V,G,Z,H);const d=R.l;if(V=R.c,G=R.lc,l[i]=d,d==z){if(H.value-U.value>n)throw new Error("Error in HufUnpackEncTable");R=M(8,V,G,Z,H);let d=R.l+O;if(V=R.c,G=R.lc,i+d>B+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)l[i++]=0;i--}else if(d>=s){let Z=d-s+2;if(i+Z>B+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)l[i++]=0;i--}}!function(Z){for(let n=0;n<=58;++n)Y[n]=0;for(let n=0;n<S;++n)Y[Z[n]]+=1;let U=0;for(let n=58;n>0;--n){const Z=U+Y[n]>>1;Y[n]=U,U=Z}for(let n=0;n<S;++n){const U=Z[n];U>0&&(Z[n]=U|Y[U]++<<6)}}(l)}function L(Z){return 63&Z}function k(Z){return Z>>6}function I(Z,U,n,i,B,l){const H=n.value,V=D(U,n),G=D(U,n);n.value+=4;const R=D(U,n);if(n.value+=4,V<0||V>=S||G<0||G>=S)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(S),F=new Array(q);!function(Z){for(let U=0;U<q;U++)Z[U]={},Z[U].len=0,Z[U].lit=0,Z[U].p=null}(F);if(Q(Z,n,i-(n.value-H),V,G,d),R>8*(i-(n.value-H)))throw new Error("Wrong hufUncompress");!function(Z,U,n,i){for(;U<=n;U++){const n=k(Z[U]),B=L(Z[U]);if(n>>B)throw new Error("Invalid table entry");if(B>y){const Z=i[n>>B-y];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const U=Z.p;Z.p=new Array(Z.lit);for(let n=0;n<Z.lit-1;++n)Z.p[n]=U[n]}else Z.p=new Array(1);Z.p[Z.lit-1]=U}else if(B){let Z=0;for(let l=1<<y-B;l>0;l--){const l=i[(n<<y-B)+Z];if(l.len||l.p)throw new Error("Invalid table entry");l.len=B,l.lit=U,Z++}}}}(d,V,G,F),function(Z,U,n,i,B,l,H,V,G){let R=0,d=0;const F=H,S=Math.trunc(i.value+(B+7)/8);for(;i.value<S;){let B=m(R,d,n,i);for(R=B.c,d=B.lc;d>=y;){const H=U[R>>d-y&c];if(H.len){d-=H.len;const Z=A(H.lit,l,R,d,n,i,V,G,F);Z&&(R=Z.c,d=Z.lc)}else{if(!H.p)throw new Error("hufDecode issues");let U;for(U=0;U<H.lit;U++){const y=L(Z[H.p[U]]);for(;d<y&&i.value<S;)B=m(R,d,n,i),R=B.c,d=B.lc;if(d>=y&&k(Z[H.p[U]])==(R>>d-y&(1<<y)-1)){d-=y;const Z=A(H.p[U],l,R,d,n,i,V,G,F);Z&&(R=Z.c,d=Z.lc);break}}if(U==H.lit)throw new Error("HufDecode issues")}}}const q=8-B&7;for(R>>=q,d-=q;d>0;){const Z=U[R<<y-d&c];if(!Z.len)throw new Error("HufDecode issues");{d-=Z.len;const U=A(Z.lit,l,R,d,n,i,V,G,F);U&&(R=U.c,d=U.lc)}}}(d,F,Z,n,R,G,l,B,{value:0})}function e(Z){return 65535&Z}function g(Z){const U=e(Z);return U>32767?U-65536:U}function b(Z,U){const n=g(Z),i=g(U),B=n+(1&i)+(i>>1);return{a:B,b:B-i}}function r(Z,U){const n=e(Z),i=e(U),B=n-(i>>1)&a;return{a:i+B-W&a,b:B}}function f(Z,U,n,i,B,l,H){const V=H<16384,G=n>B?B:n;let R,d,F=1;for(;F<=G;)F<<=1;for(F>>=1,R=F,F>>=1;F>=1;){d=0;const H=d+l*(B-R),G=l*F,y=l*R,S=i*F,q=i*R;let c,s,z,O;for(;d<=H;d+=y){let B=d;const l=d+i*(n-R);for(;B<=l;B+=q){const n=B+S,i=B+G,l=i+S;if(V){let H=b(Z[B+U],Z[i+U]);c=H.a,z=H.b,H=b(Z[n+U],Z[l+U]),s=H.a,O=H.b,H=b(c,s),Z[B+U]=H.a,Z[n+U]=H.b,H=b(z,O),Z[i+U]=H.a,Z[l+U]=H.b}else{let H=r(Z[B+U],Z[i+U]);c=H.a,z=H.b,H=r(Z[n+U],Z[l+U]),s=H.a,O=H.b,H=r(c,s),Z[B+U]=H.a,Z[n+U]=H.b,H=r(z,O),Z[i+U]=H.a,Z[l+U]=H.b}}if(n&F){const n=B+G;let i;i=V?b(Z[B+U],Z[n+U]):r(Z[B+U],Z[n+U]),c=i.a,Z[n+U]=i.b,Z[B+U]=c}}if(B&F){let B=d;const l=d+i*(n-R);for(;B<=l;B+=q){const n=B+S;let i;i=V?b(Z[B+U],Z[n+U]):r(Z[B+U],Z[n+U]),c=i.a,Z[n+U]=i.b,Z[B+U]=c}}R=F,F>>=1}return d}function ZZ(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function UZ(Z){const U=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),n=new Uint8Array(function(Z){let U=Z.byteLength;const n=[];let i=0;const B=new DataView(Z);for(;U>0;){const Z=B.getInt8(i++);if(Z<0){const l=-Z;U-=l+1;for(let Z=0;Z<l;Z++)n.push(B.getUint8(i++))}else{const l=Z;U-=2;const H=B.getUint8(i++);for(let Z=0;Z<l+1;Z++)n.push(H)}}return n}(U)),i=new Uint8Array(n.length);return w(n),o(n,i),new DataView(i.buffer)}function nZ(Z){const U=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),n=fflate.unzlibSync(U),i=new Uint8Array(n.length);return w(n),o(n,i),new DataView(i.buffer)}function iZ(Z){const U=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),n=fflate.unzlibSync(U),i=Z.lines*Z.channels*Z.width,B=1==Z.type?new Uint16Array(i):new Uint32Array(i);let l=0,H=0;const V=new Array(4);for(let G=0;G<Z.lines;G++)for(let U=0;U<Z.channels;U++){let U=0;switch(Z.type){case 1:V[0]=l,V[1]=V[0]+Z.width,l=V[1]+Z.width;for(let i=0;i<Z.width;++i){U+=n[V[0]++]<<8|n[V[1]++],B[H]=U,H++}break;case 2:V[0]=l,V[1]=V[0]+Z.width,V[2]=V[1]+Z.width,l=V[2]+Z.width;for(let i=0;i<Z.width;++i){U+=n[V[0]++]<<24|n[V[1]++]<<16|n[V[2]++]<<8,B[H]=U,H++}}}return new DataView(B.buffer)}function BZ(Z){const U=Z.viewer,n={value:Z.offset.value},i=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),B=new Uint8Array(F);let l=0;const H=new Array(Z.channels);for(let G=0;G<Z.channels;G++)H[G]={},H[G].start=l,H[G].end=H[G].start,H[G].nx=Z.width,H[G].ny=Z.lines,H[G].size=Z.type,l+=H[G].nx*H[G].ny*H[G].size;const V=j(U,n),R=j(U,n);if(R>=F)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(V<=R)for(let G=0;G<R-V+1;G++)B[G+V]=u(U,n);const y=new Uint16Array(d),S=function(Z,U){let n=0;for(let B=0;B<d;++B)(0==B||Z[B>>3]&1<<(7&B))&&(U[n++]=B);const i=n-1;for(;n<d;)U[n++]=0;return i}(B,y),q=D(U,n);I(Z.array,U,n,q,i,l);for(let G=0;G<Z.channels;++G){const Z=H[G];for(let U=0;U<H[G].size;++U)f(i,Z.start+U,Z.nx,Z.size,Z.ny,Z.nx*Z.size,S)}!function(Z,U,n){for(let i=0;i<n;++i)U[i]=Z[U[i]]}(y,i,l);let c=0;const s=new Uint8Array(i.buffer.byteLength);for(let d=0;d<Z.lines;d++)for(let U=0;U<Z.channels;U++){const Z=H[U],n=Z.nx*Z.size,B=new Uint8Array(i.buffer,Z.end*G,n*G);s.set(B,c),c+=n*G,Z.end+=n}return new DataView(s.buffer)}var lZ,HZ=n(498);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(lZ||(lZ={}));class VZ{}async function GZ(Z,U,n,i){const B={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:n,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case E.NO_COMPRESSION:B.lines=1,B.uncompress=ZZ;break;case E.RLE_COMPRESSION:B.lines=1,B.uncompress=UZ;break;case E.ZIPS_COMPRESSION:B.lines=1,B.uncompress=nZ,await HZ.e.LoadScriptAsync(VZ.FFLATEUrl);break;case E.ZIP_COMPRESSION:B.lines=16,B.uncompress=nZ,await HZ.e.LoadScriptAsync(VZ.FFLATEUrl);break;case E.PIZ_COMPRESSION:B.lines=32,B.uncompress=BZ;break;case E.PXR24_COMPRESSION:B.lines=16,B.uncompress=iZ,await HZ.e.LoadScriptAsync(VZ.FFLATEUrl);break;default:throw new Error(E[Z.compression]+" is unsupported")}B.scanlineBlockSize=B.lines;const l={};for(const H of Z.channels)switch(H.name){case"R":case"G":case"B":case"A":case"Y":l[H.name]=!0,B.type=H.pixelType}let V=!1;if(l.R&&l.G&&l.B&&l.A)B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G&&l.B)V=!0,B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G)B.outputChannels=2,B.decodeChannels={R:0,G:1};else if(l.R)B.outputChannels=1,B.decodeChannels={R:0};else{if(!l.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");B.outputChannels=1,B.decodeChannels={Y:0}}if(1===B.type)switch(i){case lZ.Float:B.getter=P,B.inputSize=G;break;case lZ.HalfFloat:B.getter=j,B.inputSize=G}else{if(2!==B.type)throw new Error("Unsupported pixelType "+B.type+" for "+Z.compression);switch(i){case lZ.Float:B.getter=h,B.inputSize=H;break;case lZ.HalfFloat:B.getter=T,B.inputSize=H}}B.blockCount=B.height/B.scanlineBlockSize;for(let H=0;H<B.blockCount;H++)X(U,n);const R=B.width*B.height*B.outputChannels;switch(i){case lZ.Float:B.byteArray=new Float32Array(R),B.textureType=1,V&&B.byteArray.fill(1,0,R);break;case lZ.HalfFloat:B.byteArray=new Uint16Array(R),B.textureType=2,V&&B.byteArray.fill(15360,0,R);break;default:throw new Error("Unsupported type: "+i)}let d=0;for(const H of Z.channels)void 0!==B.decodeChannels[H.name]&&(B.channelLineOffsets[H.name]=d*B.width),d+=2*H.pixelType;return B.bytesPerLine=B.width*d,B.outLineWidth=B.width*B.outputChannels,"INCREASING_Y"===Z.lineOrder?B.scanOrder=Z=>Z:B.scanOrder=Z=>B.height-1-Z,4==B.outputChannels?(B.format=5,B.linearSpace=!0):(B.format=6,B.linearSpace=!1),B}function RZ(Z,U,n,i){const B={value:0};for(let l=0;l<Z.height/Z.scanlineBlockSize;l++){const H=C(n,i)-U.dataWindow.yMin;Z.size=D(n,i),Z.lines=H+Z.scanlineBlockSize>Z.height?Z.height-H:Z.scanlineBlockSize;const V=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):ZZ(Z);i.value+=Z.size;for(let n=0;n<Z.scanlineBlockSize;n++){const i=l*Z.scanlineBlockSize,H=n+Z.scanOrder(i);if(H>=Z.height)continue;const G=n*Z.bytesPerLine,R=(Z.height-1-H)*Z.outLineWidth;for(let n=0;n<Z.channels;n++){const i=U.channels[n].name,l=Z.channelLineOffsets[i],H=Z.decodeChannels[i];if(void 0!==H){B.value=G+l;for(let U=0;U<Z.width;U++){const n=R+U*Z.outputChannels+H;Z.byteArray&&(Z.byteArray[n]=Z.getter(V,B))}}}}}}VZ.DefaultOutputType=lZ.HalfFloat,VZ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dZ{constructor(){this.supportCascades=!1}loadCubeData(Z,U,n,i,B){throw".exr not supported in Cube."}loadData(Z,U,n){const B=new DataView(Z.buffer),l={value:0},H=J(B,l);GZ(H,B,l,VZ.DefaultOutputType).then((Z=>{RZ(Z,H,B,l);const i=H.dataWindow.xMax-H.dataWindow.xMin+1,V=H.dataWindow.yMax-H.dataWindow.yMin+1;n(i,V,U.generateMipMaps,!1,(()=>{const n=U.getEngine();U.format=H.format,U.type=Z.textureType,U.invertY=!1,U._gammaSpace=!H.linearSpace,Z.byteArray&&n._uploadDataToTextureDirectly(U,Z.byteArray,0,0,void 0,!0)}))})).catch((Z=>{i.c.Error("Failed to load EXR texture: ",Z)}))}}async function FZ(Z){const U=new DataView(Z),n={value:0},B=J(U,n);try{const Z=await GZ(B,U,n,lZ.Float);return RZ(Z,B,U,n),Z.byteArray?{width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,data:new Float32Array(Z.byteArray)}:(i.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(l){i.c.Error("Failed to load EXR data: ",l)}return{width:0,height:0,data:null}}}}]);