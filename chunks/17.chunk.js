"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[17],{11755:(D,l,G)=>{G.r(l),G.d(l,{hl:()=>g,Wb:()=>j,TmpColors:()=>e});var V=G(11721),N=G(11667),M=G(11713),b=G(11728);function X(D){return Math.pow(D,M.k)}function t(D){return D<=.04045?.0773993808*D:Math.pow(.947867299*(D+.055),2.4)}function R(D){return Math.pow(D,M.g)}function n(D){return D<=.0031308?12.92*D:1.055*Math.pow(D,.41666)-.055}class g{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=D,this.g=l,this.b=G}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"hl"}getHashCode(){let D=255*this.r|0;return D=397*D^255*this.g,D=397*D^255*this.b,D}toArray(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[l]=this.r,D[l+1]=this.g,D[l+2]=this.b,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return g.FromArrayToRef(D,l,this),this}toColor4(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new j(this.r,this.g,this.b,D)}gb(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(D){return new g(this.r*D.r,this.g*D.g,this.b*D.b)}multiplyToRef(D,l){return l.r=this.r*D.r,l.g=this.g*D.g,l.b=this.b*D.b,l}multiplyInPlace(D){return this.r*=D.r,this.g*=D.g,this.b*=D.b,this}multiplyByFloats(D,l,G){return new g(this.r*D,this.g*l,this.b*G)}divide(D){throw new ReferenceError("Can not divide a color")}divideToRef(D,l){throw new ReferenceError("Can not divide a color")}divideInPlace(D){throw new ReferenceError("Can not divide a color")}minimizeInPlace(D){return this.minimizeInPlaceFromFloats(D.r,D.g,D.b)}maximizeInPlace(D){return this.maximizeInPlaceFromFloats(D.r,D.g,D.b)}minimizeInPlaceFromFloats(D,l,G){return this.r=Math.min(D,this.r),this.g=Math.min(l,this.g),this.b=Math.min(G,this.b),this}maximizeInPlaceFromFloats(D,l,G){return this.r=Math.max(D,this.r),this.g=Math.max(l,this.g),this.b=Math.max(G,this.b),this}floorToRef(D){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(D){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(D){return D&&this.r===D.r&&this.g===D.g&&this.b===D.b}equalsFloats(D,l,G){return this.equalsToFloats(D,l,G)}equalsToFloats(D,l,G){return this.r===D&&this.g===l&&this.b===G}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.b;return(0,b.WithinEpsilon)(this.r,D.r,l)&&(0,b.WithinEpsilon)(this.g,D.g,l)&&(0,b.WithinEpsilon)(this.b,D.b,l)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(D){throw new ReferenceError("Can not negate a color")}scale(D){return new g(this.r*D,this.g*D,this.b*D)}scaleInPlace(D){return this.r*=D,this.g*=D,this.b*=D,this}scaleToRef(D,l){return l.r=this.r*D,l.g=this.g*D,l.b=this.b*D,l}scaleAndAddToRef(D,l){return l.r+=this.r*D,l.g+=this.g*D,l.b+=this.b*D,l}clampToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.r=(0,b.Clamp)(this.r,D,l),G.g=(0,b.Clamp)(this.g,D,l),G.b=(0,b.Clamp)(this.b,D,l),G}add(D){return new g(this.r+D.r,this.g+D.g,this.b+D.b)}addInPlace(D){return this.r+=D.r,this.g+=D.g,this.b+=D.b,this}addInPlaceFromFloats(D,l,G){return this.r+=D,this.g+=l,this.b+=G,this}addToRef(D,l){return l.r=this.r+D.r,l.g=this.g+D.g,l.b=this.b+D.b,l}Fl(D){return new g(this.r-D.r,this.g-D.g,this.b-D.b)}subtractToRef(D,l){return l.r=this.r-D.r,l.g=this.g-D.g,l.b=this.b-D.b,l}Kg(D){return this.r-=D.r,this.g-=D.g,this.b-=D.b,this}subtractFromFloats(D,l,G){return new g(this.r-D,this.g-l,this.b-G)}subtractFromFloatsToRef(D,l,G,V){return V.r=this.r-D,V.g=this.g-l,V.b=this.b-G,V}clone(){return new g(this.r,this.g,this.b)}V(D){return this.r=D.r,this.g=D.g,this.b=D.b,this}Lb(D,l,G){return this.r=D,this.g=l,this.b=G,this}set(D,l,G){return this.Lb(D,l,G)}Ib(D){return this.r=this.g=this.b=D,this}toHexString(){const D=Math.round(255*this.r),l=Math.round(255*this.g),G=Math.round(255*this.b);return"#"+(0,b.ToHex)(D)+(0,b.ToHex)(l)+(0,b.ToHex)(G)}fromHexString(D){return"#"!==D.substring(0,1)||7!==D.length||(this.r=parseInt(D.substring(1,3),16)/255,this.g=parseInt(D.substring(3,5),16)/255,this.b=parseInt(D.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new g)}toHSVToRef(D){const l=this.r,G=this.g,V=this.b,N=Math.max(l,G,V),M=Math.min(l,G,V);let b=0,X=0;const t=N,R=N-M;return 0!==N&&(X=R/N),N!=M&&(N==l?(b=(G-V)/R,G<V&&(b+=6)):N==G?b=(V-l)/R+2:N==V&&(b=(l-G)/R+4),b*=60),D.r=b,D.g=X,D.b=t,D}toLinearSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new g;return this.toLinearSpaceToRef(l,D),l}toLinearSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=t(this.r),D.g=t(this.g),D.b=t(this.b)):(D.r=X(this.r),D.g=X(this.g),D.b=X(this.b)),this}toGammaSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new g;return this.toGammaSpaceToRef(l,D),l}toGammaSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=n(this.r),D.g=n(this.g),D.b=n(this.b)):(D.r=R(this.r),D.g=R(this.g),D.b=R(this.b)),this}static HSVtoRGBToRef(D,l,G,V){const N=G*l,M=D/60,b=N*(1-Math.abs(M%2-1));let X=0,t=0,R=0;M>=0&&M<=1?(X=N,t=b):M>=1&&M<=2?(X=b,t=N):M>=2&&M<=3?(t=N,R=b):M>=3&&M<=4?(t=b,R=N):M>=4&&M<=5?(X=b,R=N):M>=5&&M<=6&&(X=N,R=b);const n=G-N;return V.r=X+n,V.g=t+n,V.b=R+n,V}static FromHSV(D,l,G){const V=new g(0,0,0);return g.HSVtoRGBToRef(D,l,G,V),V}static FromHexString(D){return new g(0,0,0).fromHexString(D)}static xl(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new g(D[l],D[l+1],D[l+2])}static FromArrayToRef(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2?arguments[2]:void 0;G.r=D[l],G.g=D[l+1],G.b=D[l+2]}static FromInts(D,l,G){return new g(D/255,l/255,G/255)}static Lerp(D,l,G){const V=new g(0,0,0);return g.LerpToRef(D,l,G,V),V}static LerpToRef(D,l,G,V){V.r=D.r+(l.r-D.r)*G,V.g=D.g+(l.g-D.g)*G,V.b=D.b+(l.b-D.b)*G}static Hermite(D,l,G,V,N){const M=N*N,b=N*M,X=2*b-3*M+1,t=-2*b+3*M,R=b-2*M+N,n=b-M,j=D.r*X+G.r*t+l.r*R+V.r*n,e=D.g*X+G.g*t+l.g*R+V.g*n,K=D.b*X+G.b*t+l.b*R+V.b*n;return new g(j,e,K)}static Hermite1stDerivative(D,l,G,V,N){const M=g.Black();return this.Hermite1stDerivativeToRef(D,l,G,V,N,M),M}static Hermite1stDerivativeToRef(D,l,G,V,N,M){const b=N*N;M.r=6*(b-N)*D.r+(3*b-4*N+1)*l.r+6*(-b+N)*G.r+(3*b-2*N)*V.r,M.g=6*(b-N)*D.g+(3*b-4*N+1)*l.g+6*(-b+N)*G.g+(3*b-2*N)*V.g,M.b=6*(b-N)*D.b+(3*b-4*N+1)*l.b+6*(-b+N)*G.b+(3*b-2*N)*V.b}static Red(){return new g(1,0,0)}static Green(){return new g(0,1,0)}static Blue(){return new g(0,0,1)}static Black(){return new g(0,0,0)}static get BlackReadOnly(){return g._BlackReadOnly}static White(){return new g(1,1,1)}static Purple(){return new g(.5,0,.5)}static Magenta(){return new g(1,0,1)}static Yellow(){return new g(1,1,0)}static Gray(){return new g(.5,.5,.5)}static Teal(){return new g(0,1,1)}static Random(){return new g(Math.random(),Math.random(),Math.random())}}g._V8PerformanceHack=new g(.5,.5,.5),g._BlackReadOnly=g.Black(),Object.defineProperties(g.prototype,{dimension:{value:[3]},rank:{value:1}});class j{constructor(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=D,this.g=l,this.b=G,this.a=V}gb(){return[this.r,this.g,this.b,this.a]}toArray(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return D[l]=this.r,D[l+1]=this.g,D[l+2]=this.b,D[l+3]=this.a,this}KG(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=D[l],this.g=D[l+1],this.b=D[l+2],this.a=D[l+3],this}equals(D){return D&&this.r===D.r&&this.g===D.g&&this.b===D.b&&this.a===D.a}add(D){return new j(this.r+D.r,this.g+D.g,this.b+D.b,this.a+D.a)}addToRef(D,l){return l.r=this.r+D.r,l.g=this.g+D.g,l.b=this.b+D.b,l.a=this.a+D.a,l}addInPlace(D){return this.r+=D.r,this.g+=D.g,this.b+=D.b,this.a+=D.a,this}addInPlaceFromFloats(D,l,G,V){return this.r+=D,this.g+=l,this.b+=G,this.a+=V,this}Fl(D){return new j(this.r-D.r,this.g-D.g,this.b-D.b,this.a-D.a)}subtractToRef(D,l){return l.r=this.r-D.r,l.g=this.g-D.g,l.b=this.b-D.b,l.a=this.a-D.a,l}Kg(D){return this.r-=D.r,this.g-=D.g,this.b-=D.b,this.a-=D.a,this}subtractFromFloats(D,l,G,V){return new j(this.r-D,this.g-l,this.b-G,this.a-V)}subtractFromFloatsToRef(D,l,G,V,N){return N.r=this.r-D,N.g=this.g-l,N.b=this.b-G,N.a=this.a-V,N}scale(D){return new j(this.r*D,this.g*D,this.b*D,this.a*D)}scaleInPlace(D){return this.r*=D,this.g*=D,this.b*=D,this.a*=D,this}scaleToRef(D,l){return l.r=this.r*D,l.g=this.g*D,l.b=this.b*D,l.a=this.a*D,l}scaleAndAddToRef(D,l){return l.r+=this.r*D,l.g+=this.g*D,l.b+=this.b*D,l.a+=this.a*D,l}clampToRef(){let D=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.r=(0,b.Clamp)(this.r,D,l),G.g=(0,b.Clamp)(this.g,D,l),G.b=(0,b.Clamp)(this.b,D,l),G.a=(0,b.Clamp)(this.a,D,l),G}multiply(D){return new j(this.r*D.r,this.g*D.g,this.b*D.b,this.a*D.a)}multiplyToRef(D,l){return l.r=this.r*D.r,l.g=this.g*D.g,l.b=this.b*D.b,l.a=this.a*D.a,l}multiplyInPlace(D){return this.r*=D.r,this.g*=D.g,this.b*=D.b,this.a*=D.a,this}multiplyByFloats(D,l,G,V){return new j(this.r*D,this.g*l,this.b*G,this.a*V)}divide(D){throw new ReferenceError("Can not divide a color")}divideToRef(D,l){throw new ReferenceError("Can not divide a color")}divideInPlace(D){throw new ReferenceError("Can not divide a color")}minimizeInPlace(D){return this.r=Math.min(this.r,D.r),this.g=Math.min(this.g,D.g),this.b=Math.min(this.b,D.b),this.a=Math.min(this.a,D.a),this}maximizeInPlace(D){return this.r=Math.max(this.r,D.r),this.g=Math.max(this.g,D.g),this.b=Math.max(this.b,D.b),this.a=Math.max(this.a,D.a),this}minimizeInPlaceFromFloats(D,l,G,V){return this.r=Math.min(D,this.r),this.g=Math.min(l,this.g),this.b=Math.min(G,this.b),this.a=Math.min(V,this.a),this}maximizeInPlaceFromFloats(D,l,G,V){return this.r=Math.max(D,this.r),this.g=Math.max(l,this.g),this.b=Math.max(G,this.b),this.a=Math.max(V,this.a),this}floorToRef(D){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(D){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(D){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:M.b;return(0,b.WithinEpsilon)(this.r,D.r,l)&&(0,b.WithinEpsilon)(this.g,D.g,l)&&(0,b.WithinEpsilon)(this.b,D.b,l)&&(0,b.WithinEpsilon)(this.a,D.a,l)}equalsToFloats(D,l,G,V){return this.r===D&&this.g===l&&this.b===G&&this.a===V}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Wb"}getHashCode(){let D=255*this.r|0;return D=397*D^255*this.g,D=397*D^255*this.b,D=397*D^255*this.a,D}clone(){return(new j).V(this)}V(D){return this.r=D.r,this.g=D.g,this.b=D.b,this.a=D.a,this}Lb(D,l,G,V){return this.r=D,this.g=l,this.b=G,this.a=V,this}set(D,l,G,V){return this.Lb(D,l,G,V)}Ib(D){return this.r=this.g=this.b=this.a=D,this}toHexString(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=Math.round(255*this.r),G=Math.round(255*this.g),V=Math.round(255*this.b);if(D)return"#"+(0,b.ToHex)(l)+(0,b.ToHex)(G)+(0,b.ToHex)(V);const N=Math.round(255*this.a);return"#"+(0,b.ToHex)(l)+(0,b.ToHex)(G)+(0,b.ToHex)(V)+(0,b.ToHex)(N)}fromHexString(D){return"#"!==D.substring(0,1)||9!==D.length&&7!==D.length||(this.r=parseInt(D.substring(1,3),16)/255,this.g=parseInt(D.substring(3,5),16)/255,this.b=parseInt(D.substring(5,7),16)/255,9===D.length&&(this.a=parseInt(D.substring(7,9),16)/255)),this}toLinearSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new j;return this.toLinearSpaceToRef(l,D),l}toLinearSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=t(this.r),D.g=t(this.g),D.b=t(this.b)):(D.r=X(this.r),D.g=X(this.g),D.b=X(this.b)),D.a=this.a,this}toGammaSpace(){let D=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new j;return this.toGammaSpaceToRef(l,D),l}toGammaSpaceToRef(D){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(D.r=n(this.r),D.g=n(this.g),D.b=n(this.b)):(D.r=R(this.r),D.g=R(this.g),D.b=R(this.b)),D.a=this.a,this}static FromHexString(D){return"#"!==D.substring(0,1)||9!==D.length&&7!==D.length?new j(0,0,0,0):new j(0,0,0,1).fromHexString(D)}static Lerp(D,l,G){return j.LerpToRef(D,l,G,new j)}static LerpToRef(D,l,G,V){return V.r=D.r+(l.r-D.r)*G,V.g=D.g+(l.g-D.g)*G,V.b=D.b+(l.b-D.b)*G,V.a=D.a+(l.a-D.a)*G,V}static Hermite(D,l,G,V,N){const M=N*N,b=N*M,X=2*b-3*M+1,t=-2*b+3*M,R=b-2*M+N,n=b-M,g=D.r*X+G.r*t+l.r*R+V.r*n,e=D.g*X+G.g*t+l.g*R+V.g*n,K=D.b*X+G.b*t+l.b*R+V.b*n,F=D.a*X+G.a*t+l.a*R+V.a*n;return new j(g,e,K,F)}static Hermite1stDerivative(D,l,G,V,N){const M=new j;return this.Hermite1stDerivativeToRef(D,l,G,V,N,M),M}static Hermite1stDerivativeToRef(D,l,G,V,N,M){const b=N*N;M.r=6*(b-N)*D.r+(3*b-4*N+1)*l.r+6*(-b+N)*G.r+(3*b-2*N)*V.r,M.g=6*(b-N)*D.g+(3*b-4*N+1)*l.g+6*(-b+N)*G.g+(3*b-2*N)*V.g,M.b=6*(b-N)*D.b+(3*b-4*N+1)*l.b+6*(-b+N)*G.b+(3*b-2*N)*V.b,M.a=6*(b-N)*D.a+(3*b-4*N+1)*l.a+6*(-b+N)*G.a+(3*b-2*N)*V.a}static FromColor3(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new j(D.r,D.g,D.b,l)}static xl(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new j(D[l],D[l+1],D[l+2],D[l+3])}static FromArrayToRef(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2?arguments[2]:void 0;G.r=D[l],G.g=D[l+1],G.b=D[l+2],G.a=D[l+3]}static FromInts(D,l,G,V){return new j(D/255,l/255,G/255,V/255)}static CheckColors4(D,l){if(D.length===3*l){const l=[];for(let G=0;G<D.length;G+=3){const V=G/3*4;l[V]=D[G],l[V+1]=D[G+1],l[V+2]=D[G+2],l[V+3]=1}return l}return D}}j._V8PerformanceHack=new j(.5,.5,.5,.5),Object.defineProperties(j.prototype,{dimension:{value:[4]},rank:{value:1}});class e{}e.hl=(0,V.b)(3,g.Black),e.Wb=(0,V.b)(3,(()=>new j(0,0,0,0))),(0,N.c)("BABYLON.Color3",g),(0,N.c)("BABYLON.Color4",j)}}]);