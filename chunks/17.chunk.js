"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[17],{11856:(E,t,z)=>{z.r(t),z.d(t,{Dt:()=>h,Lp:()=>d,TmpColors:()=>y});var A=z(11826),X=z(11766),R=z(11817),u=z(11834);function p(E){return Math.pow(E,R.j)}function C(E){return E<=.04045?.0773993808*E:Math.pow(.947867299*(E+.055),2.4)}function Z(E){return Math.pow(E,R.g)}function H(E){return E<=.0031308?12.92*E:1.055*Math.pow(E,.41666)-.055}class h{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=E,this.g=t,this.b=z}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Dt"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E}toArray(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[t]=this.r,E[t+1]=this.g,E[t+2]=this.b,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return h.FromArrayToRef(E,t,this),this}toColor4(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new d(this.r,this.g,this.b,E)}upE(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(E){return new h(this.r*E.r,this.g*E.g,this.b*E.b)}multiplyToRef(E,t){return t.r=this.r*E.r,t.g=this.g*E.g,t.b=this.b*E.b,t}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this}multiplyByFloats(E,t,z){return new h(this.r*E,this.g*t,this.b*z)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,t){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.minimizeInPlaceFromFloats(E.r,E.g,E.b)}maximizeInPlace(E){return this.maximizeInPlaceFromFloats(E.r,E.g,E.b)}minimizeInPlaceFromFloats(E,t,z){return this.r=Math.min(E,this.r),this.g=Math.min(t,this.g),this.b=Math.min(z,this.b),this}maximizeInPlaceFromFloats(E,t,z){return this.r=Math.max(E,this.r),this.g=Math.max(t,this.g),this.b=Math.max(z,this.b),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b}equalsFloats(E,t,z){return this.equalsToFloats(E,t,z)}equalsToFloats(E,t,z){return this.r===E&&this.g===t&&this.b===z}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return(0,u.WithinEpsilon)(this.r,E.r,t)&&(0,u.WithinEpsilon)(this.g,E.g,t)&&(0,u.WithinEpsilon)(this.b,E.b,t)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}scale(E){return new h(this.r*E,this.g*E,this.b*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this}scaleToRef(E,t){return t.r=this.r*E,t.g=this.g*E,t.b=this.b*E,t}scaleAndAddToRef(E,t){return t.r+=this.r*E,t.g+=this.g*E,t.b+=this.b*E,t}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,z=arguments.length>2?arguments[2]:void 0;return z.r=(0,u.Clamp)(this.r,E,t),z.g=(0,u.Clamp)(this.g,E,t),z.b=(0,u.Clamp)(this.b,E,t),z}add(E){return new h(this.r+E.r,this.g+E.g,this.b+E.b)}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this}addInPlaceFromFloats(E,t,z){return this.r+=E,this.g+=t,this.b+=z,this}addToRef(E,t){return t.r=this.r+E.r,t.g=this.g+E.g,t.b=this.b+E.b,t}Wt(E){return new h(this.r-E.r,this.g-E.g,this.b-E.b)}subtractToRef(E,t){return t.r=this.r-E.r,t.g=this.g-E.g,t.b=this.b-E.b,t}kH(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this}subtractFromFloats(E,t,z){return new h(this.r-E,this.g-t,this.b-z)}subtractFromFloatsToRef(E,t,z,A){return A.r=this.r-E,A.g=this.g-t,A.b=this.b-z,A}clone(){return new h(this.r,this.g,this.b)}R(E){return this.r=E.r,this.g=E.g,this.b=E.b,this}Op(E,t,z){return this.r=E,this.g=t,this.b=z,this}set(E,t,z){return this.Op(E,t,z)}ap(E){return this.r=this.g=this.b=E,this}toHexString(){const E=Math.round(255*this.r),t=Math.round(255*this.g),z=Math.round(255*this.b);return"#"+(0,u.ToHex)(E)+(0,u.ToHex)(t)+(0,u.ToHex)(z)}fromHexString(E){return"#"!==E.substring(0,1)||7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new h)}toHSVToRef(E){const t=this.r,z=this.g,A=this.b,X=Math.max(t,z,A),R=Math.min(t,z,A);let u=0,p=0;const C=X,Z=X-R;return 0!==X&&(p=Z/X),X!=R&&(X==t?(u=(z-A)/Z,z<A&&(u+=6)):X==z?u=(A-t)/Z+2:X==A&&(u=(t-z)/Z+4),u*=60),E.r=u,E.g=p,E.b=C,E}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=new h;return this.toLinearSpaceToRef(t,E),t}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=C(this.r),E.g=C(this.g),E.b=C(this.b)):(E.r=p(this.r),E.g=p(this.g),E.b=p(this.b)),this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=new h;return this.toGammaSpaceToRef(t,E),t}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=H(this.r),E.g=H(this.g),E.b=H(this.b)):(E.r=Z(this.r),E.g=Z(this.g),E.b=Z(this.b)),this}static HSVtoRGBToRef(E,t,z,A){const X=z*t,R=E/60,u=X*(1-Math.abs(R%2-1));let p=0,C=0,Z=0;R>=0&&R<=1?(p=X,C=u):R>=1&&R<=2?(p=u,C=X):R>=2&&R<=3?(C=X,Z=u):R>=3&&R<=4?(C=u,Z=X):R>=4&&R<=5?(p=u,Z=X):R>=5&&R<=6&&(p=X,Z=u);const H=z-X;return A.r=p+H,A.g=C+H,A.b=Z+H,A}static FromHSV(E,t,z){const A=new h(0,0,0);return h.HSVtoRGBToRef(E,t,z,A),A}static FromHexString(E){return new h(0,0,0).fromHexString(E)}static St(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new h(E[t],E[t+1],E[t+2])}static FromArrayToRef(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2?arguments[2]:void 0;z.r=E[t],z.g=E[t+1],z.b=E[t+2]}static FromInts(E,t,z){return new h(E/255,t/255,z/255)}static Lerp(E,t,z){const A=new h(0,0,0);return h.LerpToRef(E,t,z,A),A}static LerpToRef(E,t,z,A){A.r=E.r+(t.r-E.r)*z,A.g=E.g+(t.g-E.g)*z,A.b=E.b+(t.b-E.b)*z}static Hermite(E,t,z,A,X){const R=X*X,u=X*R,p=2*u-3*R+1,C=-2*u+3*R,Z=u-2*R+X,H=u-R,d=E.r*p+z.r*C+t.r*Z+A.r*H,y=E.g*p+z.g*C+t.g*Z+A.g*H,O=E.b*p+z.b*C+t.b*Z+A.b*H;return new h(d,y,O)}static Hermite1stDerivative(E,t,z,A,X){const R=h.Black();return this.Hermite1stDerivativeToRef(E,t,z,A,X,R),R}static Hermite1stDerivativeToRef(E,t,z,A,X,R){const u=X*X;R.r=6*(u-X)*E.r+(3*u-4*X+1)*t.r+6*(-u+X)*z.r+(3*u-2*X)*A.r,R.g=6*(u-X)*E.g+(3*u-4*X+1)*t.g+6*(-u+X)*z.g+(3*u-2*X)*A.g,R.b=6*(u-X)*E.b+(3*u-4*X+1)*t.b+6*(-u+X)*z.b+(3*u-2*X)*A.b}static Red(){return new h(1,0,0)}static Green(){return new h(0,1,0)}static Blue(){return new h(0,0,1)}static Black(){return new h(0,0,0)}static get BlackReadOnly(){return h._BlackReadOnly}static White(){return new h(1,1,1)}static Purple(){return new h(.5,0,.5)}static Magenta(){return new h(1,0,1)}static Yellow(){return new h(1,1,0)}static Gray(){return new h(.5,.5,.5)}static Teal(){return new h(0,1,1)}static Random(){return new h(Math.random(),Math.random(),Math.random())}}h._V8PerformanceHack=new h(.5,.5,.5),h._BlackReadOnly=h.Black(),Object.defineProperties(h.prototype,{dimension:{value:[3]},rank:{value:1}});class d{constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=E,this.g=t,this.b=z,this.a=A}upE(){return[this.r,this.g,this.b,this.a]}toArray(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return E[t]=this.r,E[t+1]=this.g,E[t+2]=this.b,E[t+3]=this.a,this}Dz(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=E[t],this.g=E[t+1],this.b=E[t+2],this.a=E[t+3],this}equals(E){return E&&this.r===E.r&&this.g===E.g&&this.b===E.b&&this.a===E.a}add(E){return new d(this.r+E.r,this.g+E.g,this.b+E.b,this.a+E.a)}addToRef(E,t){return t.r=this.r+E.r,t.g=this.g+E.g,t.b=this.b+E.b,t.a=this.a+E.a,t}addInPlace(E){return this.r+=E.r,this.g+=E.g,this.b+=E.b,this.a+=E.a,this}addInPlaceFromFloats(E,t,z,A){return this.r+=E,this.g+=t,this.b+=z,this.a+=A,this}Wt(E){return new d(this.r-E.r,this.g-E.g,this.b-E.b,this.a-E.a)}subtractToRef(E,t){return t.r=this.r-E.r,t.g=this.g-E.g,t.b=this.b-E.b,t.a=this.a-E.a,t}kH(E){return this.r-=E.r,this.g-=E.g,this.b-=E.b,this.a-=E.a,this}subtractFromFloats(E,t,z,A){return new d(this.r-E,this.g-t,this.b-z,this.a-A)}subtractFromFloatsToRef(E,t,z,A,X){return X.r=this.r-E,X.g=this.g-t,X.b=this.b-z,X.a=this.a-A,X}scale(E){return new d(this.r*E,this.g*E,this.b*E,this.a*E)}scaleInPlace(E){return this.r*=E,this.g*=E,this.b*=E,this.a*=E,this}scaleToRef(E,t){return t.r=this.r*E,t.g=this.g*E,t.b=this.b*E,t.a=this.a*E,t}scaleAndAddToRef(E,t){return t.r+=this.r*E,t.g+=this.g*E,t.b+=this.b*E,t.a+=this.a*E,t}clampToRef(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,z=arguments.length>2?arguments[2]:void 0;return z.r=(0,u.Clamp)(this.r,E,t),z.g=(0,u.Clamp)(this.g,E,t),z.b=(0,u.Clamp)(this.b,E,t),z.a=(0,u.Clamp)(this.a,E,t),z}multiply(E){return new d(this.r*E.r,this.g*E.g,this.b*E.b,this.a*E.a)}multiplyToRef(E,t){return t.r=this.r*E.r,t.g=this.g*E.g,t.b=this.b*E.b,t.a=this.a*E.a,t}multiplyInPlace(E){return this.r*=E.r,this.g*=E.g,this.b*=E.b,this.a*=E.a,this}multiplyByFloats(E,t,z,A){return new d(this.r*E,this.g*t,this.b*z,this.a*A)}divide(E){throw new ReferenceError("Can not divide a color")}divideToRef(E,t){throw new ReferenceError("Can not divide a color")}divideInPlace(E){throw new ReferenceError("Can not divide a color")}minimizeInPlace(E){return this.r=Math.min(this.r,E.r),this.g=Math.min(this.g,E.g),this.b=Math.min(this.b,E.b),this.a=Math.min(this.a,E.a),this}maximizeInPlace(E){return this.r=Math.max(this.r,E.r),this.g=Math.max(this.g,E.g),this.b=Math.max(this.b,E.b),this.a=Math.max(this.a,E.a),this}minimizeInPlaceFromFloats(E,t,z,A){return this.r=Math.min(E,this.r),this.g=Math.min(t,this.g),this.b=Math.min(z,this.b),this.a=Math.min(A,this.a),this}maximizeInPlaceFromFloats(E,t,z,A){return this.r=Math.max(E,this.r),this.g=Math.max(t,this.g),this.b=Math.max(z,this.b),this.a=Math.max(A,this.a),this}floorToRef(E){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(E){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(E){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:R.c;return(0,u.WithinEpsilon)(this.r,E.r,t)&&(0,u.WithinEpsilon)(this.g,E.g,t)&&(0,u.WithinEpsilon)(this.b,E.b,t)&&(0,u.WithinEpsilon)(this.a,E.a,t)}equalsToFloats(E,t,z,A){return this.r===E&&this.g===t&&this.b===z&&this.a===A}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Lp"}getHashCode(){let E=255*this.r|0;return E=397*E^255*this.g,E=397*E^255*this.b,E=397*E^255*this.a,E}clone(){return(new d).R(this)}R(E){return this.r=E.r,this.g=E.g,this.b=E.b,this.a=E.a,this}Op(E,t,z,A){return this.r=E,this.g=t,this.b=z,this.a=A,this}set(E,t,z,A){return this.Op(E,t,z,A)}ap(E){return this.r=this.g=this.b=this.a=E,this}toHexString(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=Math.round(255*this.r),z=Math.round(255*this.g),A=Math.round(255*this.b);if(E)return"#"+(0,u.ToHex)(t)+(0,u.ToHex)(z)+(0,u.ToHex)(A);const X=Math.round(255*this.a);return"#"+(0,u.ToHex)(t)+(0,u.ToHex)(z)+(0,u.ToHex)(A)+(0,u.ToHex)(X)}fromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length||(this.r=parseInt(E.substring(1,3),16)/255,this.g=parseInt(E.substring(3,5),16)/255,this.b=parseInt(E.substring(5,7),16)/255,9===E.length&&(this.a=parseInt(E.substring(7,9),16)/255)),this}toLinearSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=new d;return this.toLinearSpaceToRef(t,E),t}toLinearSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=C(this.r),E.g=C(this.g),E.b=C(this.b)):(E.r=p(this.r),E.g=p(this.g),E.b=p(this.b)),E.a=this.a,this}toGammaSpace(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=new d;return this.toGammaSpaceToRef(t,E),t}toGammaSpaceToRef(E){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(E.r=H(this.r),E.g=H(this.g),E.b=H(this.b)):(E.r=Z(this.r),E.g=Z(this.g),E.b=Z(this.b)),E.a=this.a,this}static FromHexString(E){return"#"!==E.substring(0,1)||9!==E.length&&7!==E.length?new d(0,0,0,0):new d(0,0,0,1).fromHexString(E)}static Lerp(E,t,z){return d.LerpToRef(E,t,z,new d)}static LerpToRef(E,t,z,A){return A.r=E.r+(t.r-E.r)*z,A.g=E.g+(t.g-E.g)*z,A.b=E.b+(t.b-E.b)*z,A.a=E.a+(t.a-E.a)*z,A}static Hermite(E,t,z,A,X){const R=X*X,u=X*R,p=2*u-3*R+1,C=-2*u+3*R,Z=u-2*R+X,H=u-R,h=E.r*p+z.r*C+t.r*Z+A.r*H,y=E.g*p+z.g*C+t.g*Z+A.g*H,O=E.b*p+z.b*C+t.b*Z+A.b*H,c=E.a*p+z.a*C+t.a*Z+A.a*H;return new d(h,y,O,c)}static Hermite1stDerivative(E,t,z,A,X){const R=new d;return this.Hermite1stDerivativeToRef(E,t,z,A,X,R),R}static Hermite1stDerivativeToRef(E,t,z,A,X,R){const u=X*X;R.r=6*(u-X)*E.r+(3*u-4*X+1)*t.r+6*(-u+X)*z.r+(3*u-2*X)*A.r,R.g=6*(u-X)*E.g+(3*u-4*X+1)*t.g+6*(-u+X)*z.g+(3*u-2*X)*A.g,R.b=6*(u-X)*E.b+(3*u-4*X+1)*t.b+6*(-u+X)*z.b+(3*u-2*X)*A.b,R.a=6*(u-X)*E.a+(3*u-4*X+1)*t.a+6*(-u+X)*z.a+(3*u-2*X)*A.a}static FromColor3(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new d(E.r,E.g,E.b,t)}static St(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new d(E[t],E[t+1],E[t+2],E[t+3])}static FromArrayToRef(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,z=arguments.length>2?arguments[2]:void 0;z.r=E[t],z.g=E[t+1],z.b=E[t+2],z.a=E[t+3]}static FromInts(E,t,z,A){return new d(E/255,t/255,z/255,A/255)}static CheckColors4(E,t){if(E.length===3*t){const t=[];for(let z=0;z<E.length;z+=3){const A=z/3*4;t[A]=E[z],t[A+1]=E[z+1],t[A+2]=E[z+2],t[A+3]=1}return t}return E}}d._V8PerformanceHack=new d(.5,.5,.5,.5),Object.defineProperties(d.prototype,{dimension:{value:[4]},rank:{value:1}});class y{}y.Dt=(0,A.c)(3,h.Black),y.Lp=(0,A.c)(3,(()=>new d(0,0,0,0))),(0,X.f)("BABYLON.Color3",h),(0,X.f)("BABYLON.Color4",d)}}]);