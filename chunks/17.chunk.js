"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[17],{11716:(w,E,G)=>{G.r(E),G.d(E,{dE:()=>O,Tx:()=>u,TmpColors:()=>V});var P=G(11684),h=G(11646),B=G(11681),y=G(11689);function x(w){return Math.pow(w,B.l)}function U(w){return w<=.04045?.0773993808*w:Math.pow(.947867299*(w+.055),2.4)}function l(w){return Math.pow(w,B.h)}function i(w){return w<=.0031308?12.92*w:1.055*Math.pow(w,.41666)-.055}class O{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=w,this.g=E,this.b=G}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"dE"}getHashCode(){let w=255*this.r|0;return w=397*w^255*this.g,w=397*w^255*this.b,w}toArray(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[E]=this.r,w[E+1]=this.g,w[E+2]=this.b,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return O.FromArrayToRef(w,E,this),this}toColor4(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new u(this.r,this.g,this.b,w)}Lh(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(w){return new O(this.r*w.r,this.g*w.g,this.b*w.b)}multiplyToRef(w,E){return E.r=this.r*w.r,E.g=this.g*w.g,E.b=this.b*w.b,E}multiplyInPlace(w){return this.r*=w.r,this.g*=w.g,this.b*=w.b,this}multiplyByFloats(w,E,G){return new O(this.r*w,this.g*E,this.b*G)}divide(w){throw new ReferenceError("Can not divide a color")}divideToRef(w,E){throw new ReferenceError("Can not divide a color")}divideInPlace(w){throw new ReferenceError("Can not divide a color")}minimizeInPlace(w){return this.minimizeInPlaceFromFloats(w.r,w.g,w.b)}maximizeInPlace(w){return this.maximizeInPlaceFromFloats(w.r,w.g,w.b)}minimizeInPlaceFromFloats(w,E,G){return this.r=Math.min(w,this.r),this.g=Math.min(E,this.g),this.b=Math.min(G,this.b),this}maximizeInPlaceFromFloats(w,E,G){return this.r=Math.max(w,this.r),this.g=Math.max(E,this.g),this.b=Math.max(G,this.b),this}floorToRef(w){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(w){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(w){return w&&this.r===w.r&&this.g===w.g&&this.b===w.b}equalsFloats(w,E,G){return this.equalsToFloats(w,E,G)}equalsToFloats(w,E,G){return this.r===w&&this.g===E&&this.b===G}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,y.WithinEpsilon)(this.r,w.r,E)&&(0,y.WithinEpsilon)(this.g,w.g,E)&&(0,y.WithinEpsilon)(this.b,w.b,E)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(w){throw new ReferenceError("Can not negate a color")}scale(w){return new O(this.r*w,this.g*w,this.b*w)}scaleInPlace(w){return this.r*=w,this.g*=w,this.b*=w,this}scaleToRef(w,E){return E.r=this.r*w,E.g=this.g*w,E.b=this.b*w,E}scaleAndAddToRef(w,E){return E.r+=this.r*w,E.g+=this.g*w,E.b+=this.b*w,E}clampToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.r=(0,y.Clamp)(this.r,w,E),G.g=(0,y.Clamp)(this.g,w,E),G.b=(0,y.Clamp)(this.b,w,E),G}add(w){return new O(this.r+w.r,this.g+w.g,this.b+w.b)}addInPlace(w){return this.r+=w.r,this.g+=w.g,this.b+=w.b,this}addInPlaceFromFloats(w,E,G){return this.r+=w,this.g+=E,this.b+=G,this}addToRef(w,E){return E.r=this.r+w.r,E.g=this.g+w.g,E.b=this.b+w.b,E}cE(w){return new O(this.r-w.r,this.g-w.g,this.b-w.b)}subtractToRef(w,E){return E.r=this.r-w.r,E.g=this.g-w.g,E.b=this.b-w.b,E}xO(w){return this.r-=w.r,this.g-=w.g,this.b-=w.b,this}subtractFromFloats(w,E,G){return new O(this.r-w,this.g-E,this.b-G)}subtractFromFloatsToRef(w,E,G,P){return P.r=this.r-w,P.g=this.g-E,P.b=this.b-G,P}clone(){return new O(this.r,this.g,this.b)}B(w){return this.r=w.r,this.g=w.g,this.b=w.b,this}tx(w,E,G){return this.r=w,this.g=E,this.b=G,this}set(w,E,G){return this.tx(w,E,G)}Wx(w){return this.r=this.g=this.b=w,this}toHexString(){const w=Math.round(255*this.r),E=Math.round(255*this.g),G=Math.round(255*this.b);return"#"+(0,y.ToHex)(w)+(0,y.ToHex)(E)+(0,y.ToHex)(G)}fromHexString(w){return"#"!==w.substring(0,1)||7!==w.length||(this.r=parseInt(w.substring(1,3),16)/255,this.g=parseInt(w.substring(3,5),16)/255,this.b=parseInt(w.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new O)}toHSVToRef(w){const E=this.r,G=this.g,P=this.b,h=Math.max(E,G,P),B=Math.min(E,G,P);let y=0,x=0;const U=h,l=h-B;return 0!==h&&(x=l/h),h!=B&&(h==E?(y=(G-P)/l,G<P&&(y+=6)):h==G?y=(P-E)/l+2:h==P&&(y=(E-G)/l+4),y*=60),w.r=y,w.g=x,w.b=U,w}toLinearSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new O;return this.toLinearSpaceToRef(E,w),E}toLinearSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=U(this.r),w.g=U(this.g),w.b=U(this.b)):(w.r=x(this.r),w.g=x(this.g),w.b=x(this.b)),this}toGammaSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new O;return this.toGammaSpaceToRef(E,w),E}toGammaSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=i(this.r),w.g=i(this.g),w.b=i(this.b)):(w.r=l(this.r),w.g=l(this.g),w.b=l(this.b)),this}static HSVtoRGBToRef(w,E,G,P){const h=G*E,B=w/60,y=h*(1-Math.abs(B%2-1));let x=0,U=0,l=0;B>=0&&B<=1?(x=h,U=y):B>=1&&B<=2?(x=y,U=h):B>=2&&B<=3?(U=h,l=y):B>=3&&B<=4?(U=y,l=h):B>=4&&B<=5?(x=y,l=h):B>=5&&B<=6&&(x=h,l=y);const i=G-h;return P.r=x+i,P.g=U+i,P.b=l+i,P}static FromHSV(w,E,G){const P=new O(0,0,0);return O.HSVtoRGBToRef(w,E,G,P),P}static FromHexString(w){return new O(0,0,0).fromHexString(w)}static KE(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new O(w[E],w[E+1],w[E+2])}static FromArrayToRef(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2?arguments[2]:void 0;G.r=w[E],G.g=w[E+1],G.b=w[E+2]}static FromInts(w,E,G){return new O(w/255,E/255,G/255)}static Lerp(w,E,G){const P=new O(0,0,0);return O.LerpToRef(w,E,G,P),P}static LerpToRef(w,E,G,P){P.r=w.r+(E.r-w.r)*G,P.g=w.g+(E.g-w.g)*G,P.b=w.b+(E.b-w.b)*G}static Hermite(w,E,G,P,h){const B=h*h,y=h*B,x=2*y-3*B+1,U=-2*y+3*B,l=y-2*B+h,i=y-B,u=w.r*x+G.r*U+E.r*l+P.r*i,V=w.g*x+G.g*U+E.g*l+P.g*i,a=w.b*x+G.b*U+E.b*l+P.b*i;return new O(u,V,a)}static Hermite1stDerivative(w,E,G,P,h){const B=O.Black();return this.Hermite1stDerivativeToRef(w,E,G,P,h,B),B}static Hermite1stDerivativeToRef(w,E,G,P,h,B){const y=h*h;B.r=6*(y-h)*w.r+(3*y-4*h+1)*E.r+6*(-y+h)*G.r+(3*y-2*h)*P.r,B.g=6*(y-h)*w.g+(3*y-4*h+1)*E.g+6*(-y+h)*G.g+(3*y-2*h)*P.g,B.b=6*(y-h)*w.b+(3*y-4*h+1)*E.b+6*(-y+h)*G.b+(3*y-2*h)*P.b}static Red(){return new O(1,0,0)}static Green(){return new O(0,1,0)}static Blue(){return new O(0,0,1)}static Black(){return new O(0,0,0)}static get BlackReadOnly(){return O._BlackReadOnly}static White(){return new O(1,1,1)}static Purple(){return new O(.5,0,.5)}static Magenta(){return new O(1,0,1)}static Yellow(){return new O(1,1,0)}static Gray(){return new O(.5,.5,.5)}static Teal(){return new O(0,1,1)}static Random(){return new O(Math.random(),Math.random(),Math.random())}}O._V8PerformanceHack=new O(.5,.5,.5),O._BlackReadOnly=O.Black(),Object.defineProperties(O.prototype,{dimension:{value:[3]},rank:{value:1}});class u{constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=w,this.g=E,this.b=G,this.a=P}Lh(){return[this.r,this.g,this.b,this.a]}toArray(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return w[E]=this.r,w[E+1]=this.g,w[E+2]=this.b,w[E+3]=this.a,this}VG(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=w[E],this.g=w[E+1],this.b=w[E+2],this.a=w[E+3],this}equals(w){return w&&this.r===w.r&&this.g===w.g&&this.b===w.b&&this.a===w.a}add(w){return new u(this.r+w.r,this.g+w.g,this.b+w.b,this.a+w.a)}addToRef(w,E){return E.r=this.r+w.r,E.g=this.g+w.g,E.b=this.b+w.b,E.a=this.a+w.a,E}addInPlace(w){return this.r+=w.r,this.g+=w.g,this.b+=w.b,this.a+=w.a,this}addInPlaceFromFloats(w,E,G,P){return this.r+=w,this.g+=E,this.b+=G,this.a+=P,this}cE(w){return new u(this.r-w.r,this.g-w.g,this.b-w.b,this.a-w.a)}subtractToRef(w,E){return E.r=this.r-w.r,E.g=this.g-w.g,E.b=this.b-w.b,E.a=this.a-w.a,E}xO(w){return this.r-=w.r,this.g-=w.g,this.b-=w.b,this.a-=w.a,this}subtractFromFloats(w,E,G,P){return new u(this.r-w,this.g-E,this.b-G,this.a-P)}subtractFromFloatsToRef(w,E,G,P,h){return h.r=this.r-w,h.g=this.g-E,h.b=this.b-G,h.a=this.a-P,h}scale(w){return new u(this.r*w,this.g*w,this.b*w,this.a*w)}scaleInPlace(w){return this.r*=w,this.g*=w,this.b*=w,this.a*=w,this}scaleToRef(w,E){return E.r=this.r*w,E.g=this.g*w,E.b=this.b*w,E.a=this.a*w,E}scaleAndAddToRef(w,E){return E.r+=this.r*w,E.g+=this.g*w,E.b+=this.b*w,E.a+=this.a*w,E}clampToRef(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,G=arguments.length>2?arguments[2]:void 0;return G.r=(0,y.Clamp)(this.r,w,E),G.g=(0,y.Clamp)(this.g,w,E),G.b=(0,y.Clamp)(this.b,w,E),G.a=(0,y.Clamp)(this.a,w,E),G}multiply(w){return new u(this.r*w.r,this.g*w.g,this.b*w.b,this.a*w.a)}multiplyToRef(w,E){return E.r=this.r*w.r,E.g=this.g*w.g,E.b=this.b*w.b,E.a=this.a*w.a,E}multiplyInPlace(w){return this.r*=w.r,this.g*=w.g,this.b*=w.b,this.a*=w.a,this}multiplyByFloats(w,E,G,P){return new u(this.r*w,this.g*E,this.b*G,this.a*P)}divide(w){throw new ReferenceError("Can not divide a color")}divideToRef(w,E){throw new ReferenceError("Can not divide a color")}divideInPlace(w){throw new ReferenceError("Can not divide a color")}minimizeInPlace(w){return this.r=Math.min(this.r,w.r),this.g=Math.min(this.g,w.g),this.b=Math.min(this.b,w.b),this.a=Math.min(this.a,w.a),this}maximizeInPlace(w){return this.r=Math.max(this.r,w.r),this.g=Math.max(this.g,w.g),this.b=Math.max(this.b,w.b),this.a=Math.max(this.a,w.a),this}minimizeInPlaceFromFloats(w,E,G,P){return this.r=Math.min(w,this.r),this.g=Math.min(E,this.g),this.b=Math.min(G,this.b),this.a=Math.min(P,this.a),this}maximizeInPlaceFromFloats(w,E,G,P){return this.r=Math.max(w,this.r),this.g=Math.max(E,this.g),this.b=Math.max(G,this.b),this.a=Math.max(P,this.a),this}floorToRef(w){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(w){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(w){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:B.d;return(0,y.WithinEpsilon)(this.r,w.r,E)&&(0,y.WithinEpsilon)(this.g,w.g,E)&&(0,y.WithinEpsilon)(this.b,w.b,E)&&(0,y.WithinEpsilon)(this.a,w.a,E)}equalsToFloats(w,E,G,P){return this.r===w&&this.g===E&&this.b===G&&this.a===P}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Tx"}getHashCode(){let w=255*this.r|0;return w=397*w^255*this.g,w=397*w^255*this.b,w=397*w^255*this.a,w}clone(){return(new u).B(this)}B(w){return this.r=w.r,this.g=w.g,this.b=w.b,this.a=w.a,this}tx(w,E,G,P){return this.r=w,this.g=E,this.b=G,this.a=P,this}set(w,E,G,P){return this.tx(w,E,G,P)}Wx(w){return this.r=this.g=this.b=this.a=w,this}toHexString(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=Math.round(255*this.r),G=Math.round(255*this.g),P=Math.round(255*this.b);if(w)return"#"+(0,y.ToHex)(E)+(0,y.ToHex)(G)+(0,y.ToHex)(P);const h=Math.round(255*this.a);return"#"+(0,y.ToHex)(E)+(0,y.ToHex)(G)+(0,y.ToHex)(P)+(0,y.ToHex)(h)}fromHexString(w){return"#"!==w.substring(0,1)||9!==w.length&&7!==w.length||(this.r=parseInt(w.substring(1,3),16)/255,this.g=parseInt(w.substring(3,5),16)/255,this.b=parseInt(w.substring(5,7),16)/255,9===w.length&&(this.a=parseInt(w.substring(7,9),16)/255)),this}toLinearSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new u;return this.toLinearSpaceToRef(E,w),E}toLinearSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=U(this.r),w.g=U(this.g),w.b=U(this.b)):(w.r=x(this.r),w.g=x(this.g),w.b=x(this.b)),w.a=this.a,this}toGammaSpace(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new u;return this.toGammaSpaceToRef(E,w),E}toGammaSpaceToRef(w){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(w.r=i(this.r),w.g=i(this.g),w.b=i(this.b)):(w.r=l(this.r),w.g=l(this.g),w.b=l(this.b)),w.a=this.a,this}static FromHexString(w){return"#"!==w.substring(0,1)||9!==w.length&&7!==w.length?new u(0,0,0,0):new u(0,0,0,1).fromHexString(w)}static Lerp(w,E,G){return u.LerpToRef(w,E,G,new u)}static LerpToRef(w,E,G,P){return P.r=w.r+(E.r-w.r)*G,P.g=w.g+(E.g-w.g)*G,P.b=w.b+(E.b-w.b)*G,P.a=w.a+(E.a-w.a)*G,P}static Hermite(w,E,G,P,h){const B=h*h,y=h*B,x=2*y-3*B+1,U=-2*y+3*B,l=y-2*B+h,i=y-B,O=w.r*x+G.r*U+E.r*l+P.r*i,V=w.g*x+G.g*U+E.g*l+P.g*i,a=w.b*x+G.b*U+E.b*l+P.b*i,Q=w.a*x+G.a*U+E.a*l+P.a*i;return new u(O,V,a,Q)}static Hermite1stDerivative(w,E,G,P,h){const B=new u;return this.Hermite1stDerivativeToRef(w,E,G,P,h,B),B}static Hermite1stDerivativeToRef(w,E,G,P,h,B){const y=h*h;B.r=6*(y-h)*w.r+(3*y-4*h+1)*E.r+6*(-y+h)*G.r+(3*y-2*h)*P.r,B.g=6*(y-h)*w.g+(3*y-4*h+1)*E.g+6*(-y+h)*G.g+(3*y-2*h)*P.g,B.b=6*(y-h)*w.b+(3*y-4*h+1)*E.b+6*(-y+h)*G.b+(3*y-2*h)*P.b,B.a=6*(y-h)*w.a+(3*y-4*h+1)*E.a+6*(-y+h)*G.a+(3*y-2*h)*P.a}static FromColor3(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new u(w.r,w.g,w.b,E)}static KE(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new u(w[E],w[E+1],w[E+2],w[E+3])}static FromArrayToRef(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2?arguments[2]:void 0;G.r=w[E],G.g=w[E+1],G.b=w[E+2],G.a=w[E+3]}static FromInts(w,E,G,P){return new u(w/255,E/255,G/255,P/255)}static CheckColors4(w,E){if(w.length===3*E){const E=[];for(let G=0;G<w.length;G+=3){const P=G/3*4;E[P]=w[G],E[P+1]=w[G+1],E[P+2]=w[G+2],E[P+3]=1}return E}return w}}u._V8PerformanceHack=new u(.5,.5,.5,.5),Object.defineProperties(u.prototype,{dimension:{value:[4]},rank:{value:1}});class V{}V.dE=(0,P.d)(3,O.Black),V.Tx=(0,P.d)(3,(()=>new u(0,0,0,0))),(0,h.g)("BABYLON.Color3",O),(0,h.g)("BABYLON.Color4",u)}}]);