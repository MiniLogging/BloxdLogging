"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[17],{12934:(U,G,C)=>{C.r(G),C.d(G,{hG:()=>T,JE:()=>D,TmpColors:()=>y});var L=C(12907),X=C(12850),l=C(12898),t=C(12911);function E(U){return Math.pow(U,l.l)}function K(U){return U<=.04045?.0773993808*U:Math.pow(.947867299*(U+.055),2.4)}function P(U){return Math.pow(U,l.k)}function O(U){return U<=.0031308?12.92*U:1.055*Math.pow(U,.41666)-.055}class T{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;this.r=U,this.g=G,this.b=C}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"hG"}getHashCode(){let U=255*this.r|0;return U=397*U^255*this.g,U=397*U^255*this.b,U}toArray(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[G]=this.r,U[G+1]=this.g,U[G+2]=this.b,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return T.FromArrayToRef(U,G,this),this}toColor4(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;return new D(this.r,this.g,this.b,U)}sE(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+.59*this.g+.11*this.b}multiply(U){return new T(this.r*U.r,this.g*U.g,this.b*U.b)}multiplyToRef(U,G){return G.r=this.r*U.r,G.g=this.g*U.g,G.b=this.b*U.b,G}multiplyInPlace(U){return this.r*=U.r,this.g*=U.g,this.b*=U.b,this}multiplyByFloats(U,G,C){return new T(this.r*U,this.g*G,this.b*C)}divide(U){throw new ReferenceError("Can not divide a color")}divideToRef(U,G){throw new ReferenceError("Can not divide a color")}divideInPlace(U){throw new ReferenceError("Can not divide a color")}minimizeInPlace(U){return this.minimizeInPlaceFromFloats(U.r,U.g,U.b)}maximizeInPlace(U){return this.maximizeInPlaceFromFloats(U.r,U.g,U.b)}minimizeInPlaceFromFloats(U,G,C){return this.r=Math.min(U,this.r),this.g=Math.min(G,this.g),this.b=Math.min(C,this.b),this}maximizeInPlaceFromFloats(U,G,C){return this.r=Math.max(U,this.r),this.g=Math.max(G,this.g),this.b=Math.max(C,this.b),this}floorToRef(U){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(U){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}equals(U){return U&&this.r===U.r&&this.g===U.g&&this.b===U.b}equalsFloats(U,G,C){return this.equalsToFloats(U,G,C)}equalsToFloats(U,G,C){return this.r===U&&this.g===G&&this.b===C}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return(0,t.WithinEpsilon)(this.r,U.r,G)&&(0,t.WithinEpsilon)(this.g,U.g,G)&&(0,t.WithinEpsilon)(this.b,U.b,G)}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(U){throw new ReferenceError("Can not negate a color")}scale(U){return new T(this.r*U,this.g*U,this.b*U)}scaleInPlace(U){return this.r*=U,this.g*=U,this.b*=U,this}scaleToRef(U,G){return G.r=this.r*U,G.g=this.g*U,G.b=this.b*U,G}scaleAndAddToRef(U,G){return G.r+=this.r*U,G.g+=this.g*U,G.b+=this.b*U,G}clampToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,t.Clamp)(this.r,U,G),C.g=(0,t.Clamp)(this.g,U,G),C.b=(0,t.Clamp)(this.b,U,G),C}add(U){return new T(this.r+U.r,this.g+U.g,this.b+U.b)}addInPlace(U){return this.r+=U.r,this.g+=U.g,this.b+=U.b,this}addInPlaceFromFloats(U,G,C){return this.r+=U,this.g+=G,this.b+=C,this}addToRef(U,G){return G.r=this.r+U.r,G.g=this.g+U.g,G.b=this.b+U.b,G}IG(U){return new T(this.r-U.r,this.g-U.g,this.b-U.b)}subtractToRef(U,G){return G.r=this.r-U.r,G.g=this.g-U.g,G.b=this.b-U.b,G}uT(U){return this.r-=U.r,this.g-=U.g,this.b-=U.b,this}subtractFromFloats(U,G,C){return new T(this.r-U,this.g-G,this.b-C)}subtractFromFloatsToRef(U,G,C,L){return L.r=this.r-U,L.g=this.g-G,L.b=this.b-C,L}clone(){return new T(this.r,this.g,this.b)}L(U){return this.r=U.r,this.g=U.g,this.b=U.b,this}WE(U,G,C){return this.r=U,this.g=G,this.b=C,this}set(U,G,C){return this.WE(U,G,C)}rE(U){return this.r=this.g=this.b=U,this}toHexString(){const U=Math.round(255*this.r),G=Math.round(255*this.g),C=Math.round(255*this.b);return"#"+(0,t.ToHex)(U)+(0,t.ToHex)(G)+(0,t.ToHex)(C)}fromHexString(U){return"#"!==U.substring(0,1)||7!==U.length||(this.r=parseInt(U.substring(1,3),16)/255,this.g=parseInt(U.substring(3,5),16)/255,this.b=parseInt(U.substring(5,7),16)/255),this}toHSV(){return this.toHSVToRef(new T)}toHSVToRef(U){const G=this.r,C=this.g,L=this.b,X=Math.max(G,C,L),l=Math.min(G,C,L);let t=0,E=0;const K=X,P=X-l;return 0!==X&&(E=P/X),X!=l&&(X==G?(t=(C-L)/P,C<L&&(t+=6)):X==C?t=(L-G)/P+2:X==L&&(t=(G-C)/P+4),t*=60),U.r=t,U.g=E,U.b=K,U}toLinearSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=new T;return this.toLinearSpaceToRef(G,U),G}toLinearSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=K(this.r),U.g=K(this.g),U.b=K(this.b)):(U.r=E(this.r),U.g=E(this.g),U.b=E(this.b)),this}toGammaSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=new T;return this.toGammaSpaceToRef(G,U),G}toGammaSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=O(this.r),U.g=O(this.g),U.b=O(this.b)):(U.r=P(this.r),U.g=P(this.g),U.b=P(this.b)),this}static HSVtoRGBToRef(U,G,C,L){const X=C*G,l=U/60,t=X*(1-Math.abs(l%2-1));let E=0,K=0,P=0;l>=0&&l<=1?(E=X,K=t):l>=1&&l<=2?(E=t,K=X):l>=2&&l<=3?(K=X,P=t):l>=3&&l<=4?(K=t,P=X):l>=4&&l<=5?(E=t,P=X):l>=5&&l<=6&&(E=X,P=t);const O=C-X;return L.r=E+O,L.g=K+O,L.b=P+O,L}static FromHSV(U,G,C){const L=new T(0,0,0);return T.HSVtoRGBToRef(U,G,C,L),L}static FromHexString(U){return new T(0,0,0).fromHexString(U)}static NG(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new T(U[G],U[G+1],U[G+2])}static FromArrayToRef(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=U[G],C.g=U[G+1],C.b=U[G+2]}static FromInts(U,G,C){return new T(U/255,G/255,C/255)}static Lerp(U,G,C){const L=new T(0,0,0);return T.LerpToRef(U,G,C,L),L}static LerpToRef(U,G,C,L){L.r=U.r+(G.r-U.r)*C,L.g=U.g+(G.g-U.g)*C,L.b=U.b+(G.b-U.b)*C}static Hermite(U,G,C,L,X){const l=X*X,t=X*l,E=2*t-3*l+1,K=-2*t+3*l,P=t-2*l+X,O=t-l,D=U.r*E+C.r*K+G.r*P+L.r*O,y=U.g*E+C.g*K+G.g*P+L.g*O,V=U.b*E+C.b*K+G.b*P+L.b*O;return new T(D,y,V)}static Hermite1stDerivative(U,G,C,L,X){const l=T.Black();return this.Hermite1stDerivativeToRef(U,G,C,L,X,l),l}static Hermite1stDerivativeToRef(U,G,C,L,X,l){const t=X*X;l.r=6*(t-X)*U.r+(3*t-4*X+1)*G.r+6*(-t+X)*C.r+(3*t-2*X)*L.r,l.g=6*(t-X)*U.g+(3*t-4*X+1)*G.g+6*(-t+X)*C.g+(3*t-2*X)*L.g,l.b=6*(t-X)*U.b+(3*t-4*X+1)*G.b+6*(-t+X)*C.b+(3*t-2*X)*L.b}static Red(){return new T(1,0,0)}static Green(){return new T(0,1,0)}static Blue(){return new T(0,0,1)}static Black(){return new T(0,0,0)}static get BlackReadOnly(){return T._BlackReadOnly}static White(){return new T(1,1,1)}static Purple(){return new T(.5,0,.5)}static Magenta(){return new T(1,0,1)}static Yellow(){return new T(1,1,0)}static Gray(){return new T(.5,.5,.5)}static Teal(){return new T(0,1,1)}static Random(){return new T(Math.random(),Math.random(),Math.random())}}T._V8PerformanceHack=new T(.5,.5,.5),T._BlackReadOnly=T.Black(),Object.defineProperties(T.prototype,{dimension:{value:[3]},rank:{value:1}});class D{constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1;this.r=U,this.g=G,this.b=C,this.a=L}sE(){return[this.r,this.g,this.b,this.a]}toArray(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return U[G]=this.r,U[G+1]=this.g,U[G+2]=this.b,U[G+3]=this.a,this}xC(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this.r=U[G],this.g=U[G+1],this.b=U[G+2],this.a=U[G+3],this}equals(U){return U&&this.r===U.r&&this.g===U.g&&this.b===U.b&&this.a===U.a}add(U){return new D(this.r+U.r,this.g+U.g,this.b+U.b,this.a+U.a)}addToRef(U,G){return G.r=this.r+U.r,G.g=this.g+U.g,G.b=this.b+U.b,G.a=this.a+U.a,G}addInPlace(U){return this.r+=U.r,this.g+=U.g,this.b+=U.b,this.a+=U.a,this}addInPlaceFromFloats(U,G,C,L){return this.r+=U,this.g+=G,this.b+=C,this.a+=L,this}IG(U){return new D(this.r-U.r,this.g-U.g,this.b-U.b,this.a-U.a)}subtractToRef(U,G){return G.r=this.r-U.r,G.g=this.g-U.g,G.b=this.b-U.b,G.a=this.a-U.a,G}uT(U){return this.r-=U.r,this.g-=U.g,this.b-=U.b,this.a-=U.a,this}subtractFromFloats(U,G,C,L){return new D(this.r-U,this.g-G,this.b-C,this.a-L)}subtractFromFloatsToRef(U,G,C,L,X){return X.r=this.r-U,X.g=this.g-G,X.b=this.b-C,X.a=this.a-L,X}scale(U){return new D(this.r*U,this.g*U,this.b*U,this.a*U)}scaleInPlace(U){return this.r*=U,this.g*=U,this.b*=U,this.a*=U,this}scaleToRef(U,G){return G.r=this.r*U,G.g=this.g*U,G.b=this.b*U,G.a=this.a*U,G}scaleAndAddToRef(U,G){return G.r+=this.r*U,G.g+=this.g*U,G.b+=this.b*U,G.a+=this.a*U,G}clampToRef(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0;return C.r=(0,t.Clamp)(this.r,U,G),C.g=(0,t.Clamp)(this.g,U,G),C.b=(0,t.Clamp)(this.b,U,G),C.a=(0,t.Clamp)(this.a,U,G),C}multiply(U){return new D(this.r*U.r,this.g*U.g,this.b*U.b,this.a*U.a)}multiplyToRef(U,G){return G.r=this.r*U.r,G.g=this.g*U.g,G.b=this.b*U.b,G.a=this.a*U.a,G}multiplyInPlace(U){return this.r*=U.r,this.g*=U.g,this.b*=U.b,this.a*=U.a,this}multiplyByFloats(U,G,C,L){return new D(this.r*U,this.g*G,this.b*C,this.a*L)}divide(U){throw new ReferenceError("Can not divide a color")}divideToRef(U,G){throw new ReferenceError("Can not divide a color")}divideInPlace(U){throw new ReferenceError("Can not divide a color")}minimizeInPlace(U){return this.r=Math.min(this.r,U.r),this.g=Math.min(this.g,U.g),this.b=Math.min(this.b,U.b),this.a=Math.min(this.a,U.a),this}maximizeInPlace(U){return this.r=Math.max(this.r,U.r),this.g=Math.max(this.g,U.g),this.b=Math.max(this.b,U.b),this.a=Math.max(this.a,U.a),this}minimizeInPlaceFromFloats(U,G,C,L){return this.r=Math.min(U,this.r),this.g=Math.min(G,this.g),this.b=Math.min(C,this.b),this.a=Math.min(L,this.a),this}maximizeInPlaceFromFloats(U,G,C,L){return this.r=Math.max(U,this.r),this.g=Math.max(G,this.g),this.b=Math.max(C,this.b),this.a=Math.max(L,this.a),this}floorToRef(U){throw new ReferenceError("Can not floor a color")}floor(){throw new ReferenceError("Can not floor a color")}fractToRef(U){throw new ReferenceError("Can not fract a color")}fract(){throw new ReferenceError("Can not fract a color")}negate(){throw new ReferenceError("Can not negate a color")}negateInPlace(){throw new ReferenceError("Can not negate a color")}negateToRef(U){throw new ReferenceError("Can not negate a color")}equalsWithEpsilon(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:l.d;return(0,t.WithinEpsilon)(this.r,U.r,G)&&(0,t.WithinEpsilon)(this.g,U.g,G)&&(0,t.WithinEpsilon)(this.b,U.b,G)&&(0,t.WithinEpsilon)(this.a,U.a,G)}equalsToFloats(U,G,C,L){return this.r===U&&this.g===G&&this.b===C&&this.a===L}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"JE"}getHashCode(){let U=255*this.r|0;return U=397*U^255*this.g,U=397*U^255*this.b,U=397*U^255*this.a,U}clone(){return(new D).L(this)}L(U){return this.r=U.r,this.g=U.g,this.b=U.b,this.a=U.a,this}WE(U,G,C,L){return this.r=U,this.g=G,this.b=C,this.a=L,this}set(U,G,C,L){return this.WE(U,G,C,L)}rE(U){return this.r=this.g=this.b=this.a=U,this}toHexString(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=Math.round(255*this.r),C=Math.round(255*this.g),L=Math.round(255*this.b);if(U)return"#"+(0,t.ToHex)(G)+(0,t.ToHex)(C)+(0,t.ToHex)(L);const X=Math.round(255*this.a);return"#"+(0,t.ToHex)(G)+(0,t.ToHex)(C)+(0,t.ToHex)(L)+(0,t.ToHex)(X)}fromHexString(U){return"#"!==U.substring(0,1)||9!==U.length&&7!==U.length||(this.r=parseInt(U.substring(1,3),16)/255,this.g=parseInt(U.substring(3,5),16)/255,this.b=parseInt(U.substring(5,7),16)/255,9===U.length&&(this.a=parseInt(U.substring(7,9),16)/255)),this}toLinearSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=new D;return this.toLinearSpaceToRef(G,U),G}toLinearSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=K(this.r),U.g=K(this.g),U.b=K(this.b)):(U.r=E(this.r),U.g=E(this.g),U.b=E(this.b)),U.a=this.a,this}toGammaSpace(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const G=new D;return this.toGammaSpaceToRef(G,U),G}toGammaSpaceToRef(U){return arguments.length>1&&void 0!==arguments[1]&&arguments[1]?(U.r=O(this.r),U.g=O(this.g),U.b=O(this.b)):(U.r=P(this.r),U.g=P(this.g),U.b=P(this.b)),U.a=this.a,this}static FromHexString(U){return"#"!==U.substring(0,1)||9!==U.length&&7!==U.length?new D(0,0,0,0):new D(0,0,0,1).fromHexString(U)}static Lerp(U,G,C){return D.LerpToRef(U,G,C,new D)}static LerpToRef(U,G,C,L){return L.r=U.r+(G.r-U.r)*C,L.g=U.g+(G.g-U.g)*C,L.b=U.b+(G.b-U.b)*C,L.a=U.a+(G.a-U.a)*C,L}static Hermite(U,G,C,L,X){const l=X*X,t=X*l,E=2*t-3*l+1,K=-2*t+3*l,P=t-2*l+X,O=t-l,T=U.r*E+C.r*K+G.r*P+L.r*O,y=U.g*E+C.g*K+G.g*P+L.g*O,V=U.b*E+C.b*K+G.b*P+L.b*O,p=U.a*E+C.a*K+G.a*P+L.a*O;return new D(T,y,V,p)}static Hermite1stDerivative(U,G,C,L,X){const l=new D;return this.Hermite1stDerivativeToRef(U,G,C,L,X,l),l}static Hermite1stDerivativeToRef(U,G,C,L,X,l){const t=X*X;l.r=6*(t-X)*U.r+(3*t-4*X+1)*G.r+6*(-t+X)*C.r+(3*t-2*X)*L.r,l.g=6*(t-X)*U.g+(3*t-4*X+1)*G.g+6*(-t+X)*C.g+(3*t-2*X)*L.g,l.b=6*(t-X)*U.b+(3*t-4*X+1)*G.b+6*(-t+X)*C.b+(3*t-2*X)*L.b,l.a=6*(t-X)*U.a+(3*t-4*X+1)*G.a+6*(-t+X)*C.a+(3*t-2*X)*L.a}static FromColor3(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return new D(U.r,U.g,U.b,G)}static NG(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return new D(U[G],U[G+1],U[G+2],U[G+3])}static FromArrayToRef(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2?arguments[2]:void 0;C.r=U[G],C.g=U[G+1],C.b=U[G+2],C.a=U[G+3]}static FromInts(U,G,C,L){return new D(U/255,G/255,C/255,L/255)}static CheckColors4(U,G){if(U.length===3*G){const G=[];for(let C=0;C<U.length;C+=3){const L=C/3*4;G[L]=U[C],G[L+1]=U[C+1],G[L+2]=U[C+2],G[L+3]=1}return G}return U}}D._V8PerformanceHack=new D(.5,.5,.5,.5),Object.defineProperties(D.prototype,{dimension:{value:[4]},rank:{value:1}});class y{}y.hG=(0,L.e)(3,T.Black),y.JE=(0,L.e)(3,(()=>new D(0,0,0,0))),(0,X.e)("BABYLON.Color3",T),(0,X.e)("BABYLON.Color4",D)}}]);