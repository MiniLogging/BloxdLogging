"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2494:(k,M,F)=>{F.r(M),F.d(M,{_HDRTextureLoader:()=>d});var l=F(682);class t{static ConvertPanoramaToCubemap(k,M,F,l){let t=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!k)throw"ConvertPanoramaToCubemap: input cannot be null";if(k.length!=M*F*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(l,this.FACE_FRONT,k,M,F,t),back:this.CreateCubemapTexture(l,this.FACE_BACK,k,M,F,t),left:this.CreateCubemapTexture(l,this.FACE_LEFT,k,M,F,t),right:this.CreateCubemapTexture(l,this.FACE_RIGHT,k,M,F,t),up:this.CreateCubemapTexture(l,this.FACE_UP,k,M,F,t),down:this.CreateCubemapTexture(l,this.FACE_DOWN,k,M,F,t),size:l,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(k,M,F,l,t){let g=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const B=new ArrayBuffer(k*k*4*3),G=new Float32Array(B),A=g?Math.max(1,Math.round(l/4/k)):1,N=1/A,d=N*N,L=M[1].fe(M[0]).scale(N/k),U=M[3].fe(M[2]).scale(N/k),O=1/k;let w=0;for(let Z=0;Z<k;Z++)for(let g=0;g<A;g++){let g=M[0],B=M[2];for(let M=0;M<k;M++)for(let N=0;N<A;N++){const A=B.fe(g).scale(w).add(g);A.normalize();const N=this.CalcProjectionSpherical(A,F,l,t);G[Z*k*3+3*M+0]+=N.r*d,G[Z*k*3+3*M+1]+=N.g*d,G[Z*k*3+3*M+2]+=N.b*d,g=g.add(L),B=B.add(U)}w+=O*N}return G}static CalcProjectionSpherical(k,M,F,l){let t=Math.atan2(k.z,k.x);const g=Math.acos(k.y);for(;t<-Math.PI;)t+=2*Math.PI;for(;t>Math.PI;)t-=2*Math.PI;let B=t/Math.PI;const G=g/Math.PI;B=.5*B+.5;let A=Math.round(B*F);A<0?A=0:A>=F&&(A=F-1);let N=Math.round(G*l);N<0?N=0:N>=l&&(N=l-1);const d=l-N-1;return{r:M[d*F*3+3*A+0],g:M[d*F*3+3*A+1],b:M[d*F*3+3*A+2]}}}function g(k,M,F,l,t,g){t>0?(t=function(k,M){return M>1023?k*Math.pow(2,1023)*Math.pow(2,M-1023):M<-1074?k*Math.pow(2,-1074)*Math.pow(2,M+1074):k*Math.pow(2,M)}(1,t-136),k[g+0]=M*t,k[g+1]=F*t,k[g+2]=l*t):(k[g+0]=0,k[g+1]=0,k[g+2]=0)}function B(k,M){let F="",l="";for(let t=M;t<k.length-M&&(l=String.fromCharCode(k[t]),"\n"!=l);t++)F+=l;return F}function G(k){let M=0,F=0,l=B(k,0);if("#"!=l[0]||"?"!=l[1])throw"Bad HDR Format.";let t=!1,g=!1,G=0;do{G+=l.length+1,l=B(k,G),"FORMAT=32-bit_rle_rgbe"==l?g=!0:0==l.length&&(t=!0)}while(!t);if(!g)throw"HDR Bad header format, unsupported FORMAT";G+=l.length+1,l=B(k,G);const A=/^-Y (.*) \+X (.*)$/g.exec(l);if(!A||A.length<3)throw"HDR Bad header format, no size";if(F=parseInt(A[2]),M=parseInt(A[1]),F<8||F>32767)throw"HDR Bad header format, unsupported size";return G+=l.length+1,{height:M,width:F,dataPosition:G}}function A(k,M){return function(k,M){let F=M.height;const l=M.width;let t,B,G,A,d,L=M.dataPosition,U=0,O=0,w=0;const Z=new ArrayBuffer(4*l),R=new Uint8Array(Z),y=new ArrayBuffer(M.width*M.height*4*3),m=new Float32Array(y);for(;F>0;){if(t=k[L++],B=k[L++],G=k[L++],A=k[L++],2!=t||2!=B||128&G||M.width<8||M.width>32767)return N(k,M);if((G<<8|A)!=l)throw"HDR Bad header format, wrong scan line width";for(U=0,w=0;w<4;w++)for(O=(w+1)*l;U<O;)if(t=k[L++],B=k[L++],t>128){if(d=t-128,0==d||d>O-U)throw"HDR Bad Format, bad scanline data (run)";for(;d-- >0;)R[U++]=B}else{if(d=t,0==d||d>O-U)throw"HDR Bad Format, bad scanline data (non-run)";if(R[U++]=B,--d>0)for(let M=0;M<d;M++)R[U++]=k[L++]}for(w=0;w<l;w++)t=R[w],B=R[w+l],G=R[w+2*l],A=R[w+3*l],g(m,t,B,G,A,(M.height-F)*l*3+3*w);F--}return m}(k,M)}function N(k,M){let F=M.height;const l=M.width;let t,B,G,A,N,d=M.dataPosition;const L=new ArrayBuffer(M.width*M.height*4*3),U=new Float32Array(L);for(;F>0;){for(N=0;N<M.width;N++)t=k[d++],B=k[d++],G=k[d++],A=k[d++],g(U,t,B,G,A,(M.height-F)*l*3+3*N);F--}return U}t.FACE_LEFT=[new l.m(-1,-1,-1),new l.m(1,-1,-1),new l.m(-1,1,-1),new l.m(1,1,-1)],t.FACE_RIGHT=[new l.m(1,-1,1),new l.m(-1,-1,1),new l.m(1,1,1),new l.m(-1,1,1)],t.FACE_FRONT=[new l.m(1,-1,-1),new l.m(1,-1,1),new l.m(1,1,-1),new l.m(1,1,1)],t.FACE_BACK=[new l.m(-1,-1,1),new l.m(-1,-1,-1),new l.m(-1,1,1),new l.m(-1,1,-1)],t.FACE_DOWN=[new l.m(1,1,-1),new l.m(1,1,1),new l.m(-1,1,-1),new l.m(-1,1,1)],t.FACE_UP=[new l.m(-1,-1,-1),new l.m(-1,-1,1),new l.m(1,-1,-1),new l.m(1,-1,1)];class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(k,M,F){const l=new Uint8Array(k.buffer,k.byteOffset,k.byteLength),t=G(l),g=A(l,t),B=t.width*t.height,N=new Float32Array(4*B);for(let G=0;G<B;G+=1)N[4*G]=g[3*G],N[4*G+1]=g[3*G+1],N[4*G+2]=g[3*G+2],N[4*G+3]=1;F(t.width,t.height,M.generateMipMaps,!1,(()=>{const k=M.getEngine();M.type=1,M.format=5,M._gammaSpace=!1,k._uploadDataToTextureDirectly(M,N)}))}}}}]);