"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2141:(L,j,P)=>{P.d(j,{d:()=>C,h:()=>K,k:()=>G,m:()=>M});var A=P(475),R=P(656),o=P(670),Y=P(1990),u=P(589),a=P(2034),D=(P(2149),P(2056)),S=P(490);P(2199),P(2201),P(2203);const g="image/png",V=2,N=[134,22,135,150,246,214,150,54];function C(L){const j=new DataView(L.buffer,L.byteOffset,L.byteLength);let P=0;for(let Y=0;Y<N.length;Y++)if(j.getUint8(P++)!==N[Y])return S.e.Error("Not a babylon environment map"),null;let A="",R=0;for(;R=j.getUint8(P++);)A+=String.fromCharCode(R);let o=JSON.parse(A);return o=b(o),o.binaryDataPosition=P,o.ij&&(o.ij.lodGenerationScale=o.ij.lodGenerationScale||.8),o}function b(L){if(L.version>V)throw new Error(`Unsupported babylon environment map version "${L.version}". Latest supported version is "${V}".`);return 2===L.version?L:L={...L,version:2,imageType:g}}function f(L,j){const P=(j=b(j)).ij;let A=Math.log2(j.width);if(A=Math.round(A)+1,P.mipmaps.length!==6*A)throw new Error(`Unsupported specular mipmaps number "${P.mipmaps.length}"`);const R=new Array(A);for(let o=0;o<A;o++){R[o]=new Array(6);for(let A=0;A<6;A++){const Y=P.mipmaps[6*o+A];R[o][A]=new Uint8Array(L.buffer,L.byteOffset+j.binaryDataPosition+Y.position,Y.length)}}return R}function h(L,j){var P;j=b(j);const A=new Array(6),R=null===(P=j.irradiance)||void 0===P?void 0:P.irradianceTexture;if(R){if(6!==R.faces.length)throw new Error(`Incorrect irradiance texture faces number "${R.faces.length}"`);for(let P=0;P<6;P++){const o=R.faces[P];A[P]=new Uint8Array(L.buffer,L.byteOffset+j.binaryDataPosition+o.position,o.length)}}return A}function K(L,j,P){var A;const o=(P=b(P)).ij;if(!o)return Promise.resolve([]);L._lodGenerationScale=o.lodGenerationScale;const Y=[],u=f(j,P);Y.push(q(L,u,P.imageType));const a=null===(A=P.irradiance)||void 0===A?void 0:A.irradianceTexture;if(a){var D,S;const A=h(j,P);let o=null;null!==(D=P.irradiance)&&void 0!==D&&null!==(S=D.irradianceTexture)&&void 0!==S&&S.dominantDirection&&(o=R.r.ri(P.irradiance.irradianceTexture.dominantDirection)),Y.push(y(L,A,a.size,P.imageType,o))}return Promise.all(Y)}async function v(L,j,P,A,R,o,Y,u,a,D,S){return await new Promise(((g,V)=>{if(P){const P=j.createTexture(null,!0,!0,null,1,null,(L=>{V(L)}),L);null===A||void 0===A||A.onEffectCreatedObservable.addOnce((u=>{u.executeWhenCompiled((()=>{A.externalTextureSamplerBinding=!0,A.onApply=A=>{A._bindTexture("textureSampler",P),A.setFloat2("scale",1,j._features.needsInvertingBitmap&&L instanceof ImageBitmap?-1:1)},j.scenes.length&&(j.scenes[0].postProcessManager.directRender([A],D,!0,o,Y),j.restoreDefaultFramebuffer(),P.dispose(),URL.revokeObjectURL(R),g())}))}))}else{if(j._uploadImageToTexture(S,L,o,Y),u){const P=a[Y];P&&j._uploadImageToTexture(P._texture,L,o,0)}g()}}))}async function q(L,j){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:g;const A=L.getEngine();L.format=5,L.type=0,L.generateMipMaps=!0,L._cachedAnisotropicFilteringLevel=null,A.updateTextureSamplingMode(3,L),await T(L,j,!0,P),L.isReady=!0}async function y(L,j,P){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g,R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=L.getEngine(),Y=new u.c(o,5),D=new a.c(o,Y);L._irradianceTexture=D,D._dominantDirection=R,Y.isCube=!0,Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,Y.generateMipMaps=!0,Y.width=P,Y.height=P,o.updateTextureSamplingMode(3,Y),await T(Y,[j],!1,A),o.generateMipMapsForCubemap(Y),Y.isReady=!0}async function T(L,j,R){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g;if(!A.d.IsExponentOfTwo(L.width))throw new Error("Texture size must be a power of two");const S=(0,o.ILog2)(L.width)+1,V=L.getEngine();let N=!1,C=!1,b=null,f=null,h=null;const K=V.getCaps();K.textureLOD?V._features.supportRenderAndCopyToLodForFloatTextures?K.textureHalfFloatRender&&K.textureHalfFloatLinearFiltering?(N=!0,L.type=2):K.textureFloatRender&&K.textureFloatLinearFiltering&&(N=!0,L.type=1):N=!1:(N=!1,C=R);let q=0;if(N)V.isWebGPU?(q=1,await P.e(36).then(P.bind(P,13085))):await P.e(29).then(P.bind(P,13089)),b=new D.d("rgbdDecode","rgbdDecode",null,null,1,null,3,V,!1,void 0,L.type,void 0,null,!1,void 0,q),L._isRGBD=!1,L.invertY=!1,f=V.createRenderTargetCubeTexture(L.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:L.type,format:5});else if(L._isRGBD=!0,L.invertY=!0,C){const j=3;h={};const P=L._lodGenerationScale,A=L._lodGenerationOffset;for(let R=0;R<j;R++){const o=(S-1)*P+A,Y=A+(o-A)*(1-R/(j-1)),D=Math.round(Math.min(Math.max(Y,0),o)),g=new u.c(V,2);g.isCube=!0,g.invertY=!0,g.generateMipMaps=!1,V.updateTextureSamplingMode(2,g);const N=new a.c(null);switch(N._isCube=!0,N._texture=g,h[D]=N,R){case 0:L._lodTextureLow=N;break;case 1:L._lodTextureMid=N;break;case 2:L._lodTextureHigh=N}}}const y=[];for(let P=0;P<j.length;P++)for(let A=0;A<6;A++){const R=j[P][A],o=new Blob([R],{type:Y}),u=URL.createObjectURL(o);let a;if(V._features.forceBitmapOverHTMLImageElement)a=V.createImageBitmap(o,{premultiplyAlpha:"none"}).then((async j=>await v(j,V,N,b,u,A,P,C,h,f,L)));else{const j=new Image;j.src=u,a=new Promise(((R,o)=>{j.onload=()=>{v(j,V,N,b,u,A,P,C,h,f,L).then((()=>R())).catch((L=>{o(L)}))},j.onerror=L=>{o(L)}}))}y.push(a)}if(await Promise.all(y),j.length<S){let P;const A=Math.pow(2,S-1-j.length),R=A*A*4;switch(L.type){case 0:P=new Uint8Array(R);break;case 2:P=new Uint16Array(R);break;case 1:P=new Float32Array(R)}for(let o=j.length;o<S;o++)for(let j=0;j<6;j++){var T;V._uploadArrayBufferViewToTexture((null===(T=f)||void 0===T?void 0:T.texture)||L,P,j,o)}}if(f){const j=L._irradianceTexture;L._irradianceTexture=null,V._releaseTexture(L),f._swapAndDie(L),L._irradianceTexture=j}b&&b.dispose(),C&&(L._lodTextureHigh&&L._lodTextureHigh._texture&&(L._lodTextureHigh._texture.isReady=!0),L._lodTextureMid&&L._lodTextureMid._texture&&(L._lodTextureMid._texture.isReady=!0),L._lodTextureLow&&L._lodTextureLow._texture&&(L._lodTextureLow._texture.isReady=!0))}function G(L,j){const P=(j=b(j)).irradiance;if(!P)return;const A=new Y.g;R.r.FromArrayToRef(P.x,0,A.x),R.r.FromArrayToRef(P.y,0,A.y),R.r.FromArrayToRef(P.z,0,A.z),R.r.FromArrayToRef(P.xx,0,A.xx),R.r.FromArrayToRef(P.yy,0,A.yy),R.r.FromArrayToRef(P.zz,0,A.zz),R.r.FromArrayToRef(P.yz,0,A.yz),R.r.FromArrayToRef(P.zx,0,A.zx),R.r.FromArrayToRef(P.xy,0,A.xy),L._sphericalPolynomial=A}function M(L,j,P,A,R){const o=q(L.getEngine().createRawCubeTexture(null,L.width,L.format,L.type,L.generateMipMaps,L.invertY,L.samplingMode,L._compression),j).then((()=>L));return L.onRebuildCallback=L=>({proxy:o,isReady:!0,isAsync:!0}),L._source=13,L._bufferViewArrayArray=j,L._lodGenerationScale=A,L._lodGenerationOffset=R,L._sphericalPolynomial=P,q(L,j).then((()=>(L.isReady=!0,L)))}}}]);