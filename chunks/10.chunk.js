"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2189:(B,o,e)=>{e.r(o),e.d(o,{_HDRTextureLoader:()=>O});var k=e(690);class d{static ConvertPanoramaToCubemap(B,o,e,k){let d=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!B)throw"ConvertPanoramaToCubemap: input cannot be null";if(B.length!=o*e*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(k,this.FACE_FRONT,B,o,e,d),back:this.CreateCubemapTexture(k,this.FACE_BACK,B,o,e,d),left:this.CreateCubemapTexture(k,this.FACE_LEFT,B,o,e,d),right:this.CreateCubemapTexture(k,this.FACE_RIGHT,B,o,e,d),up:this.CreateCubemapTexture(k,this.FACE_UP,B,o,e,d),down:this.CreateCubemapTexture(k,this.FACE_DOWN,B,o,e,d),size:k,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(B,o,e,k,d){let f=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const J=new ArrayBuffer(B*B*4*3),Z=new Float32Array(J),t=f?Math.max(1,Math.round(k/4/B)):1,h=1/t,O=h*h,K=o[1].Ag(o[0]).scale(h/B),w=o[3].Ag(o[2]).scale(h/B),u=1/B;let L=0;for(let H=0;H<B;H++)for(let f=0;f<t;f++){let f=o[0],J=o[2];for(let o=0;o<B;o++)for(let h=0;h<t;h++){const t=J.Ag(f).scale(L).add(f);t.normalize();const h=this.CalcProjectionSpherical(t,e,k,d);Z[H*B*3+3*o+0]+=h.r*O,Z[H*B*3+3*o+1]+=h.g*O,Z[H*B*3+3*o+2]+=h.b*O,f=f.add(K),J=J.add(w)}L+=u*h}return Z}static CalcProjectionSpherical(B,o,e,k){let d=Math.atan2(B.z,B.x);const f=Math.acos(B.y);for(;d<-Math.PI;)d+=2*Math.PI;for(;d>Math.PI;)d-=2*Math.PI;let J=d/Math.PI;const Z=f/Math.PI;J=.5*J+.5;let t=Math.round(J*e);t<0?t=0:t>=e&&(t=e-1);let h=Math.round(Z*k);h<0?h=0:h>=k&&(h=k-1);const O=k-h-1;return{r:o[O*e*3+3*t+0],g:o[O*e*3+3*t+1],b:o[O*e*3+3*t+2]}}}function f(B,o,e,k,d,f){d>0?(d=function(B,o){return o>1023?B*Math.pow(2,1023)*Math.pow(2,o-1023):o<-1074?B*Math.pow(2,-1074)*Math.pow(2,o+1074):B*Math.pow(2,o)}(1,d-136),B[f+0]=o*d,B[f+1]=e*d,B[f+2]=k*d):(B[f+0]=0,B[f+1]=0,B[f+2]=0)}function J(B,o){let e="",k="";for(let d=o;d<B.length-o&&(k=String.fromCharCode(B[d]),"\n"!=k);d++)e+=k;return e}function Z(B){let o=0,e=0,k=J(B,0);if("#"!=k[0]||"?"!=k[1])throw"Bad HDR Format.";let d=!1,f=!1,Z=0;do{Z+=k.length+1,k=J(B,Z),"FORMAT=32-bit_rle_rgbe"==k?f=!0:0==k.length&&(d=!0)}while(!d);if(!f)throw"HDR Bad header format, unsupported FORMAT";Z+=k.length+1,k=J(B,Z);const t=/^-Y (.*) \+X (.*)$/g.exec(k);if(!t||t.length<3)throw"HDR Bad header format, no size";if(e=parseInt(t[2]),o=parseInt(t[1]),e<8||e>32767)throw"HDR Bad header format, unsupported size";return Z+=k.length+1,{height:o,width:e,dataPosition:Z}}function t(B,o){return function(B,o){let e=o.height;const k=o.width;let d,J,Z,t,O,K=o.dataPosition,w=0,u=0,L=0;const H=new ArrayBuffer(4*k),n=new Uint8Array(H),W=new ArrayBuffer(o.width*o.height*4*3),R=new Float32Array(W);for(;e>0;){if(d=B[K++],J=B[K++],Z=B[K++],t=B[K++],2!=d||2!=J||128&Z||o.width<8||o.width>32767)return h(B,o);if((Z<<8|t)!=k)throw"HDR Bad header format, wrong scan line width";for(w=0,L=0;L<4;L++)for(u=(L+1)*k;w<u;)if(d=B[K++],J=B[K++],d>128){if(O=d-128,0==O||O>u-w)throw"HDR Bad Format, bad scanline data (run)";for(;O-- >0;)n[w++]=J}else{if(O=d,0==O||O>u-w)throw"HDR Bad Format, bad scanline data (non-run)";if(n[w++]=J,--O>0)for(let o=0;o<O;o++)n[w++]=B[K++]}for(L=0;L<k;L++)d=n[L],J=n[L+k],Z=n[L+2*k],t=n[L+3*k],f(R,d,J,Z,t,(o.height-e)*k*3+3*L);e--}return R}(B,o)}function h(B,o){let e=o.height;const k=o.width;let d,J,Z,t,h,O=o.dataPosition;const K=new ArrayBuffer(o.width*o.height*4*3),w=new Float32Array(K);for(;e>0;){for(h=0;h<o.width;h++)d=B[O++],J=B[O++],Z=B[O++],t=B[O++],f(w,d,J,Z,t,(o.height-e)*k*3+3*h);e--}return w}d.FACE_LEFT=[new k.o(-1,-1,-1),new k.o(1,-1,-1),new k.o(-1,1,-1),new k.o(1,1,-1)],d.FACE_RIGHT=[new k.o(1,-1,1),new k.o(-1,-1,1),new k.o(1,1,1),new k.o(-1,1,1)],d.FACE_FRONT=[new k.o(1,-1,-1),new k.o(1,-1,1),new k.o(1,1,-1),new k.o(1,1,1)],d.FACE_BACK=[new k.o(-1,-1,1),new k.o(-1,-1,-1),new k.o(-1,1,1),new k.o(-1,1,-1)],d.FACE_DOWN=[new k.o(1,1,-1),new k.o(1,1,1),new k.o(-1,1,-1),new k.o(-1,1,1)],d.FACE_UP=[new k.o(-1,-1,-1),new k.o(-1,-1,1),new k.o(1,-1,-1),new k.o(1,-1,1)];class O{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(B,o,e){const k=new Uint8Array(B.buffer,B.byteOffset,B.byteLength),d=Z(k),f=t(k,d),J=d.width*d.height,h=new Float32Array(4*J);for(let Z=0;Z<J;Z+=1)h[4*Z]=f[3*Z],h[4*Z+1]=f[3*Z+1],h[4*Z+2]=f[3*Z+2],h[4*Z+3]=1;e(d.width,d.height,o.generateMipMaps,!1,(()=>{const B=o.getEngine();o.type=1,o.format=5,o._gammaSpace=!1,B._uploadDataToTextureDirectly(o,h)}))}}}}]);