"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2441:(a,x,Q)=>{Q.r(x),Q.d(x,{_HDRTextureLoader:()=>W});var s=Q(679);class h{static ConvertPanoramaToCubemap(a,x,Q,s){let h=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!a)throw"ConvertPanoramaToCubemap: input cannot be null";if(a.length!=x*Q*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(s,this.FACE_FRONT,a,x,Q,h),back:this.CreateCubemapTexture(s,this.FACE_BACK,a,x,Q,h),left:this.CreateCubemapTexture(s,this.FACE_LEFT,a,x,Q,h),right:this.CreateCubemapTexture(s,this.FACE_RIGHT,a,x,Q,h),up:this.CreateCubemapTexture(s,this.FACE_UP,a,x,Q,h),down:this.CreateCubemapTexture(s,this.FACE_DOWN,a,x,Q,h),size:s,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(a,x,Q,s,h){let D=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const N=new ArrayBuffer(a*a*4*3),C=new Float32Array(N),R=D?Math.max(1,Math.round(s/4/a)):1,U=1/R,W=U*U,v=x[1].Ag(x[0]).scale(U/a),e=x[3].Ag(x[2]).scale(U/a),p=1/a;let j=0;for(let H=0;H<a;H++)for(let D=0;D<R;D++){let D=x[0],N=x[2];for(let x=0;x<a;x++)for(let U=0;U<R;U++){const R=N.Ag(D).scale(j).add(D);R.normalize();const U=this.CalcProjectionSpherical(R,Q,s,h);C[H*a*3+3*x+0]+=U.r*W,C[H*a*3+3*x+1]+=U.g*W,C[H*a*3+3*x+2]+=U.b*W,D=D.add(v),N=N.add(e)}j+=p*U}return C}static CalcProjectionSpherical(a,x,Q,s){let h=Math.atan2(a.z,a.x);const D=Math.acos(a.y);for(;h<-Math.PI;)h+=2*Math.PI;for(;h>Math.PI;)h-=2*Math.PI;let N=h/Math.PI;const C=D/Math.PI;N=.5*N+.5;let R=Math.round(N*Q);R<0?R=0:R>=Q&&(R=Q-1);let U=Math.round(C*s);U<0?U=0:U>=s&&(U=s-1);const W=s-U-1;return{r:x[W*Q*3+3*R+0],g:x[W*Q*3+3*R+1],b:x[W*Q*3+3*R+2]}}}function D(a,x,Q,s,h,D){h>0?(h=function(a,x){return x>1023?a*Math.pow(2,1023)*Math.pow(2,x-1023):x<-1074?a*Math.pow(2,-1074)*Math.pow(2,x+1074):a*Math.pow(2,x)}(1,h-136),a[D+0]=x*h,a[D+1]=Q*h,a[D+2]=s*h):(a[D+0]=0,a[D+1]=0,a[D+2]=0)}function N(a,x){let Q="",s="";for(let h=x;h<a.length-x&&(s=String.fromCharCode(a[h]),"\n"!=s);h++)Q+=s;return Q}function C(a){let x=0,Q=0,s=N(a,0);if("#"!=s[0]||"?"!=s[1])throw"Bad HDR Format.";let h=!1,D=!1,C=0;do{C+=s.length+1,s=N(a,C),"FORMAT=32-bit_rle_rgbe"==s?D=!0:0==s.length&&(h=!0)}while(!h);if(!D)throw"HDR Bad header format, unsupported FORMAT";C+=s.length+1,s=N(a,C);const R=/^-Y (.*) \+X (.*)$/g.exec(s);if(!R||R.length<3)throw"HDR Bad header format, no size";if(Q=parseInt(R[2]),x=parseInt(R[1]),Q<8||Q>32767)throw"HDR Bad header format, unsupported size";return C+=s.length+1,{height:x,width:Q,dataPosition:C}}function R(a,x){return function(a,x){let Q=x.height;const s=x.width;let h,N,C,R,W,v=x.dataPosition,e=0,p=0,j=0;const H=new ArrayBuffer(4*s),d=new Uint8Array(H),i=new ArrayBuffer(x.width*x.height*4*3),Z=new Float32Array(i);for(;Q>0;){if(h=a[v++],N=a[v++],C=a[v++],R=a[v++],2!=h||2!=N||128&C||x.width<8||x.width>32767)return U(a,x);if((C<<8|R)!=s)throw"HDR Bad header format, wrong scan line width";for(e=0,j=0;j<4;j++)for(p=(j+1)*s;e<p;)if(h=a[v++],N=a[v++],h>128){if(W=h-128,0==W||W>p-e)throw"HDR Bad Format, bad scanline data (run)";for(;W-- >0;)d[e++]=N}else{if(W=h,0==W||W>p-e)throw"HDR Bad Format, bad scanline data (non-run)";if(d[e++]=N,--W>0)for(let x=0;x<W;x++)d[e++]=a[v++]}for(j=0;j<s;j++)h=d[j],N=d[j+s],C=d[j+2*s],R=d[j+3*s],D(Z,h,N,C,R,(x.height-Q)*s*3+3*j);Q--}return Z}(a,x)}function U(a,x){let Q=x.height;const s=x.width;let h,N,C,R,U,W=x.dataPosition;const v=new ArrayBuffer(x.width*x.height*4*3),e=new Float32Array(v);for(;Q>0;){for(U=0;U<x.width;U++)h=a[W++],N=a[W++],C=a[W++],R=a[W++],D(e,h,N,C,R,(x.height-Q)*s*3+3*U);Q--}return e}h.FACE_LEFT=[new s.o(-1,-1,-1),new s.o(1,-1,-1),new s.o(-1,1,-1),new s.o(1,1,-1)],h.FACE_RIGHT=[new s.o(1,-1,1),new s.o(-1,-1,1),new s.o(1,1,1),new s.o(-1,1,1)],h.FACE_FRONT=[new s.o(1,-1,-1),new s.o(1,-1,1),new s.o(1,1,-1),new s.o(1,1,1)],h.FACE_BACK=[new s.o(-1,-1,1),new s.o(-1,-1,-1),new s.o(-1,1,1),new s.o(-1,1,-1)],h.FACE_DOWN=[new s.o(1,1,-1),new s.o(1,1,1),new s.o(-1,1,-1),new s.o(-1,1,1)],h.FACE_UP=[new s.o(-1,-1,-1),new s.o(-1,-1,1),new s.o(1,-1,-1),new s.o(1,-1,1)];class W{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(a,x,Q){const s=new Uint8Array(a.buffer,a.byteOffset,a.byteLength),h=C(s),D=R(s,h),N=h.width*h.height,U=new Float32Array(4*N);for(let C=0;C<N;C+=1)U[4*C]=D[3*C],U[4*C+1]=D[3*C+1],U[4*C+2]=D[3*C+2],U[4*C+3]=1;Q(h.width,h.height,x.generateMipMaps,!1,(()=>{const a=x.getEngine();x.type=1,x.format=5,x._gammaSpace=!1,a._uploadDataToTextureDirectly(x,U)}))}}}}]);