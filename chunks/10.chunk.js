"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2465:(f,z,w)=>{w.r(z),w.d(z,{_HDRTextureLoader:()=>h});var S=w(720);class C{static ConvertPanoramaToCubemap(f,z,w,S){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!f)throw"ConvertPanoramaToCubemap: input cannot be null";if(f.length!=z*w*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(S,this.FACE_FRONT,f,z,w,C),back:this.CreateCubemapTexture(S,this.FACE_BACK,f,z,w,C),left:this.CreateCubemapTexture(S,this.FACE_LEFT,f,z,w,C),right:this.CreateCubemapTexture(S,this.FACE_RIGHT,f,z,w,C),up:this.CreateCubemapTexture(S,this.FACE_UP,f,z,w,C),down:this.CreateCubemapTexture(S,this.FACE_DOWN,f,z,w,C),size:S,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(f,z,w,S,C){let E=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const F=new ArrayBuffer(f*f*4*3),J=new Float32Array(F),x=E?Math.max(1,Math.round(S/4/f)):1,u=1/x,h=u*u,X=z[1].te(z[0]).scale(u/f),K=z[3].te(z[2]).scale(u/f),c=1/f;let y=0;for(let e=0;e<f;e++)for(let E=0;E<x;E++){let E=z[0],F=z[2];for(let z=0;z<f;z++)for(let u=0;u<x;u++){const x=F.te(E).scale(y).add(E);x.normalize();const u=this.CalcProjectionSpherical(x,w,S,C);J[e*f*3+3*z+0]+=u.r*h,J[e*f*3+3*z+1]+=u.g*h,J[e*f*3+3*z+2]+=u.b*h,E=E.add(X),F=F.add(K)}y+=c*u}return J}static CalcProjectionSpherical(f,z,w,S){let C=Math.atan2(f.z,f.x);const E=Math.acos(f.y);for(;C<-Math.PI;)C+=2*Math.PI;for(;C>Math.PI;)C-=2*Math.PI;let F=C/Math.PI;const J=E/Math.PI;F=.5*F+.5;let x=Math.round(F*w);x<0?x=0:x>=w&&(x=w-1);let u=Math.round(J*S);u<0?u=0:u>=S&&(u=S-1);const h=S-u-1;return{r:z[h*w*3+3*x+0],g:z[h*w*3+3*x+1],b:z[h*w*3+3*x+2]}}}function E(f,z,w,S,C,E){C>0?(C=function(f,z){return z>1023?f*Math.pow(2,1023)*Math.pow(2,z-1023):z<-1074?f*Math.pow(2,-1074)*Math.pow(2,z+1074):f*Math.pow(2,z)}(1,C-136),f[E+0]=z*C,f[E+1]=w*C,f[E+2]=S*C):(f[E+0]=0,f[E+1]=0,f[E+2]=0)}function F(f,z){let w="",S="";for(let C=z;C<f.length-z&&(S=String.fromCharCode(f[C]),"\n"!=S);C++)w+=S;return w}function J(f){let z=0,w=0,S=F(f,0);if("#"!=S[0]||"?"!=S[1])throw"Bad HDR Format.";let C=!1,E=!1,J=0;do{J+=S.length+1,S=F(f,J),"FORMAT=32-bit_rle_rgbe"==S?E=!0:0==S.length&&(C=!0)}while(!C);if(!E)throw"HDR Bad header format, unsupported FORMAT";J+=S.length+1,S=F(f,J);const x=/^-Y (.*) \+X (.*)$/g.exec(S);if(!x||x.length<3)throw"HDR Bad header format, no size";if(w=parseInt(x[2]),z=parseInt(x[1]),w<8||w>32767)throw"HDR Bad header format, unsupported size";return J+=S.length+1,{height:z,width:w,dataPosition:J}}function x(f,z){return function(f,z){let w=z.height;const S=z.width;let C,F,J,x,h,X=z.dataPosition,K=0,c=0,y=0;const e=new ArrayBuffer(4*S),O=new Uint8Array(e),d=new ArrayBuffer(z.width*z.height*4*3),B=new Float32Array(d);for(;w>0;){if(C=f[X++],F=f[X++],J=f[X++],x=f[X++],2!=C||2!=F||128&J||z.width<8||z.width>32767)return u(f,z);if((J<<8|x)!=S)throw"HDR Bad header format, wrong scan line width";for(K=0,y=0;y<4;y++)for(c=(y+1)*S;K<c;)if(C=f[X++],F=f[X++],C>128){if(h=C-128,0==h||h>c-K)throw"HDR Bad Format, bad scanline data (run)";for(;h-- >0;)O[K++]=F}else{if(h=C,0==h||h>c-K)throw"HDR Bad Format, bad scanline data (non-run)";if(O[K++]=F,--h>0)for(let z=0;z<h;z++)O[K++]=f[X++]}for(y=0;y<S;y++)C=O[y],F=O[y+S],J=O[y+2*S],x=O[y+3*S],E(B,C,F,J,x,(z.height-w)*S*3+3*y);w--}return B}(f,z)}function u(f,z){let w=z.height;const S=z.width;let C,F,J,x,u,h=z.dataPosition;const X=new ArrayBuffer(z.width*z.height*4*3),K=new Float32Array(X);for(;w>0;){for(u=0;u<z.width;u++)C=f[h++],F=f[h++],J=f[h++],x=f[h++],E(K,C,F,J,x,(z.height-w)*S*3+3*u);w--}return K}C.FACE_LEFT=[new S.n(-1,-1,-1),new S.n(1,-1,-1),new S.n(-1,1,-1),new S.n(1,1,-1)],C.FACE_RIGHT=[new S.n(1,-1,1),new S.n(-1,-1,1),new S.n(1,1,1),new S.n(-1,1,1)],C.FACE_FRONT=[new S.n(1,-1,-1),new S.n(1,-1,1),new S.n(1,1,-1),new S.n(1,1,1)],C.FACE_BACK=[new S.n(-1,-1,1),new S.n(-1,-1,-1),new S.n(-1,1,1),new S.n(-1,1,-1)],C.FACE_DOWN=[new S.n(1,1,-1),new S.n(1,1,1),new S.n(-1,1,-1),new S.n(-1,1,1)],C.FACE_UP=[new S.n(-1,-1,-1),new S.n(-1,-1,1),new S.n(1,-1,-1),new S.n(1,-1,1)];class h{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(f,z,w){const S=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),C=J(S),E=x(S,C),F=C.width*C.height,u=new Float32Array(4*F);for(let J=0;J<F;J+=1)u[4*J]=E[3*J],u[4*J+1]=E[3*J+1],u[4*J+2]=E[3*J+2],u[4*J+3]=1;w(C.width,C.height,z.generateMipMaps,!1,(()=>{const f=z.getEngine();z.type=1,z.format=5,z._gammaSpace=!1,f._uploadDataToTextureDirectly(z,u)}))}}}}]);