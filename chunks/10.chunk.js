"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2170:(j,H,s)=>{s.r(H),s.d(H,{_HDRTextureLoader:()=>U});var i=s(693);class B{static ConvertPanoramaToCubemap(j,H,s,i){let B=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!j)throw"ConvertPanoramaToCubemap: input cannot be null";if(j.length!=H*s*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(i,this.FACE_FRONT,j,H,s,B),back:this.CreateCubemapTexture(i,this.FACE_BACK,j,H,s,B),left:this.CreateCubemapTexture(i,this.FACE_LEFT,j,H,s,B),right:this.CreateCubemapTexture(i,this.FACE_RIGHT,j,H,s,B),up:this.CreateCubemapTexture(i,this.FACE_UP,j,H,s,B),down:this.CreateCubemapTexture(i,this.FACE_DOWN,j,H,s,B),size:i,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(j,H,s,i,B){let e=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const k=new ArrayBuffer(j*j*4*3),V=new Float32Array(k),C=e?Math.max(1,Math.round(i/4/j)):1,L=1/C,U=L*L,x=H[1].de(H[0]).scale(L/j),p=H[3].de(H[2]).scale(L/j),a=1/j;let E=0;for(let r=0;r<j;r++)for(let e=0;e<C;e++){let e=H[0],k=H[2];for(let H=0;H<j;H++)for(let L=0;L<C;L++){const C=k.de(e).scale(E).add(e);C.normalize();const L=this.CalcProjectionSpherical(C,s,i,B);V[r*j*3+3*H+0]+=L.r*U,V[r*j*3+3*H+1]+=L.g*U,V[r*j*3+3*H+2]+=L.b*U,e=e.add(x),k=k.add(p)}E+=a*L}return V}static CalcProjectionSpherical(j,H,s,i){let B=Math.atan2(j.z,j.x);const e=Math.acos(j.y);for(;B<-Math.PI;)B+=2*Math.PI;for(;B>Math.PI;)B-=2*Math.PI;let k=B/Math.PI;const V=e/Math.PI;k=.5*k+.5;let C=Math.round(k*s);C<0?C=0:C>=s&&(C=s-1);let L=Math.round(V*i);L<0?L=0:L>=i&&(L=i-1);const U=i-L-1;return{r:H[U*s*3+3*C+0],g:H[U*s*3+3*C+1],b:H[U*s*3+3*C+2]}}}function e(j,H,s,i,B,e){B>0?(B=function(j,H){return H>1023?j*Math.pow(2,1023)*Math.pow(2,H-1023):H<-1074?j*Math.pow(2,-1074)*Math.pow(2,H+1074):j*Math.pow(2,H)}(1,B-136),j[e+0]=H*B,j[e+1]=s*B,j[e+2]=i*B):(j[e+0]=0,j[e+1]=0,j[e+2]=0)}function k(j,H){let s="",i="";for(let B=H;B<j.length-H&&(i=String.fromCharCode(j[B]),"\n"!=i);B++)s+=i;return s}function V(j){let H=0,s=0,i=k(j,0);if("#"!=i[0]||"?"!=i[1])throw"Bad HDR Format.";let B=!1,e=!1,V=0;do{V+=i.length+1,i=k(j,V),"FORMAT=32-bit_rle_rgbe"==i?e=!0:0==i.length&&(B=!0)}while(!B);if(!e)throw"HDR Bad header format, unsupported FORMAT";V+=i.length+1,i=k(j,V);const C=/^-Y (.*) \+X (.*)$/g.exec(i);if(!C||C.length<3)throw"HDR Bad header format, no size";if(s=parseInt(C[2]),H=parseInt(C[1]),s<8||s>32767)throw"HDR Bad header format, unsupported size";return V+=i.length+1,{height:H,width:s,dataPosition:V}}function C(j,H){return function(j,H){let s=H.height;const i=H.width;let B,k,V,C,U,x=H.dataPosition,p=0,a=0,E=0;const r=new ArrayBuffer(4*i),q=new Uint8Array(r),J=new ArrayBuffer(H.width*H.height*4*3),h=new Float32Array(J);for(;s>0;){if(B=j[x++],k=j[x++],V=j[x++],C=j[x++],2!=B||2!=k||128&V||H.width<8||H.width>32767)return L(j,H);if((V<<8|C)!=i)throw"HDR Bad header format, wrong scan line width";for(p=0,E=0;E<4;E++)for(a=(E+1)*i;p<a;)if(B=j[x++],k=j[x++],B>128){if(U=B-128,0==U||U>a-p)throw"HDR Bad Format, bad scanline data (run)";for(;U-- >0;)q[p++]=k}else{if(U=B,0==U||U>a-p)throw"HDR Bad Format, bad scanline data (non-run)";if(q[p++]=k,--U>0)for(let H=0;H<U;H++)q[p++]=j[x++]}for(E=0;E<i;E++)B=q[E],k=q[E+i],V=q[E+2*i],C=q[E+3*i],e(h,B,k,V,C,(H.height-s)*i*3+3*E);s--}return h}(j,H)}function L(j,H){let s=H.height;const i=H.width;let B,k,V,C,L,U=H.dataPosition;const x=new ArrayBuffer(H.width*H.height*4*3),p=new Float32Array(x);for(;s>0;){for(L=0;L<H.width;L++)B=j[U++],k=j[U++],V=j[U++],C=j[U++],e(p,B,k,V,C,(H.height-s)*i*3+3*L);s--}return p}B.FACE_LEFT=[new i.p(-1,-1,-1),new i.p(1,-1,-1),new i.p(-1,1,-1),new i.p(1,1,-1)],B.FACE_RIGHT=[new i.p(1,-1,1),new i.p(-1,-1,1),new i.p(1,1,1),new i.p(-1,1,1)],B.FACE_FRONT=[new i.p(1,-1,-1),new i.p(1,-1,1),new i.p(1,1,-1),new i.p(1,1,1)],B.FACE_BACK=[new i.p(-1,-1,1),new i.p(-1,-1,-1),new i.p(-1,1,1),new i.p(-1,1,-1)],B.FACE_DOWN=[new i.p(1,1,-1),new i.p(1,1,1),new i.p(-1,1,-1),new i.p(-1,1,1)],B.FACE_UP=[new i.p(-1,-1,-1),new i.p(-1,-1,1),new i.p(1,-1,-1),new i.p(1,-1,1)];class U{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(j,H,s){const i=new Uint8Array(j.buffer,j.byteOffset,j.byteLength),B=V(i),e=C(i,B),k=B.width*B.height,L=new Float32Array(4*k);for(let V=0;V<k;V+=1)L[4*V]=e[3*V],L[4*V+1]=e[3*V+1],L[4*V+2]=e[3*V+2],L[4*V+3]=1;s(B.width,B.height,H.generateMipMaps,!1,(()=>{const j=H.getEngine();H.type=1,H.format=5,H._gammaSpace=!1,j._uploadDataToTextureDirectly(H,L)}))}}}}]);