"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2162:(v,d,Q)=>{Q.d(d,{c:()=>X,g:()=>S,i:()=>J,m:()=>K});var n=Q(475),T=Q(651),L=Q(664),e=Q(2007),F=Q(573),r=Q(2045),C=(Q(2167),Q(2059)),u=Q(482);Q(2231),Q(2237),Q(2242);const y="image/png",z=2,B=[134,22,135,150,246,214,150,54];function X(v){const d=new DataView(v.buffer,v.byteOffset,v.byteLength);let Q=0;for(let e=0;e<B.length;e++)if(d.getUint8(Q++)!==B[e])return u.d.Error("Not a babylon environment map"),null;let n="",T=0;for(;T=d.getUint8(Q++);)n+=String.fromCharCode(T);let L=JSON.parse(n);return L=m(L),L.binaryDataPosition=Q,L.uk&&(L.uk.lodGenerationScale=L.uk.lodGenerationScale||.8),L}function m(v){if(v.version>z)throw new Error(`Unsupported babylon environment map version "${v.version}". Latest supported version is "${z}".`);return 2===v.version?v:v={...v,version:2,imageType:y}}function V(v,d){const Q=(d=m(d)).uk;let n=Math.log2(d.width);if(n=Math.round(n)+1,Q.mipmaps.length!==6*n)throw new Error(`Unsupported specular mipmaps number "${Q.mipmaps.length}"`);const T=new Array(n);for(let L=0;L<n;L++){T[L]=new Array(6);for(let n=0;n<6;n++){const e=Q.mipmaps[6*L+n];T[L][n]=new Uint8Array(v.buffer,v.byteOffset+d.binaryDataPosition+e.position,e.length)}}return T}function h(v,d){var Q;d=m(d);const n=new Array(6),T=null===(Q=d.irradiance)||void 0===Q?void 0:Q.irradianceTexture;if(T){if(6!==T.faces.length)throw new Error(`Incorrect irradiance texture faces number "${T.faces.length}"`);for(let Q=0;Q<6;Q++){const L=T.faces[Q];n[Q]=new Uint8Array(v.buffer,v.byteOffset+d.binaryDataPosition+L.position,L.length)}}return n}function S(v,d,Q){var n;const L=(Q=m(Q)).uk;if(!L)return Promise.resolve([]);v._lodGenerationScale=L.lodGenerationScale;const e=[],F=V(d,Q);e.push(f(v,F,Q.imageType));const r=null===(n=Q.irradiance)||void 0===n?void 0:n.irradianceTexture;if(r){var C,u;const n=h(d,Q);let L=null;null!==(C=Q.irradiance)&&void 0!==C&&null!==(u=C.irradianceTexture)&&void 0!==u&&u.dominantDirection&&(L=T.j.dk(Q.irradiance.irradianceTexture.dominantDirection)),e.push(P(v,n,r.size,Q.imageType,L))}return Promise.all(e)}async function A(v,d,Q,n,T,L,e,F,r,C,u){return await new Promise(((y,z)=>{if(Q){const Q=d.createTexture(null,!0,!0,null,1,null,(v=>{z(v)}),v);null===n||void 0===n||n.onEffectCreatedObservable.addOnce((F=>{F.executeWhenCompiled((()=>{n.externalTextureSamplerBinding=!0,n.onApply=n=>{n._bindTexture("textureSampler",Q),n.setFloat2("scale",1,d._features.needsInvertingBitmap&&v instanceof ImageBitmap?-1:1)},d.scenes.length&&(d.scenes[0].postProcessManager.directRender([n],C,!0,L,e),d.restoreDefaultFramebuffer(),Q.dispose(),URL.revokeObjectURL(T),y())}))}))}else{if(d._uploadImageToTexture(u,v,L,e),F){const Q=r[e];Q&&d._uploadImageToTexture(Q._texture,v,L,0)}y()}}))}async function f(v,d){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:y;const n=v.getEngine();v.format=5,v.type=0,v.generateMipMaps=!0,v._cachedAnisotropicFilteringLevel=null,n.updateTextureSamplingMode(3,v),await O(v,d,!0,Q),v.isReady=!0}async function P(v,d,Q){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y,T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const L=v.getEngine(),e=new F.b(L,5),C=new r.e(L,e);v._irradianceTexture=C,C._dominantDirection=T,e.isCube=!0,e.format=5,e.type=0,e.generateMipMaps=!0,e._cachedAnisotropicFilteringLevel=null,e.generateMipMaps=!0,e.width=Q,e.height=Q,L.updateTextureSamplingMode(3,e),await O(e,[d],!1,n),L.generateMipMapsForCubemap(e),e.isReady=!0}async function O(v,d,T){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y;if(!n.e.IsExponentOfTwo(v.width))throw new Error("Texture size must be a power of two");const u=(0,L.ILog2)(v.width)+1,z=v.getEngine();let B=!1,X=!1,m=null,V=null,h=null;const S=z.getCaps();S.textureLOD?z._features.supportRenderAndCopyToLodForFloatTextures?S.textureHalfFloatRender&&S.textureHalfFloatLinearFiltering?(B=!0,v.type=2):S.textureFloatRender&&S.textureFloatLinearFiltering&&(B=!0,v.type=1):B=!1:(B=!1,X=T);let f=0;if(B)z.isWebGPU?(f=1,await Q.e(36).then(Q.bind(Q,13521))):await Q.e(29).then(Q.bind(Q,13529)),m=new C.c("rgbdDecode","rgbdDecode",null,null,1,null,3,z,!1,void 0,v.type,void 0,null,!1,void 0,f),v._isRGBD=!1,v.invertY=!1,V=z.createRenderTargetCubeTexture(v.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:v.type,format:5});else if(v._isRGBD=!0,v.invertY=!0,X){const d=3;h={};const Q=v._lodGenerationScale,n=v._lodGenerationOffset;for(let T=0;T<d;T++){const L=(u-1)*Q+n,e=n+(L-n)*(1-T/(d-1)),C=Math.round(Math.min(Math.max(e,0),L)),y=new F.b(z,2);y.isCube=!0,y.invertY=!0,y.generateMipMaps=!1,z.updateTextureSamplingMode(2,y);const B=new r.e(null);switch(B._isCube=!0,B._texture=y,h[C]=B,T){case 0:v._lodTextureLow=B;break;case 1:v._lodTextureMid=B;break;case 2:v._lodTextureHigh=B}}}const P=[];for(let Q=0;Q<d.length;Q++)for(let n=0;n<6;n++){const T=d[Q][n],L=new Blob([T],{type:e}),F=URL.createObjectURL(L);let r;if(z._features.forceBitmapOverHTMLImageElement)r=z.createImageBitmap(L,{premultiplyAlpha:"none"}).then((async d=>await A(d,z,B,m,F,n,Q,X,h,V,v)));else{const d=new Image;d.src=F,r=new Promise(((T,L)=>{d.onload=()=>{A(d,z,B,m,F,n,Q,X,h,V,v).then((()=>T())).catch((v=>{L(v)}))},d.onerror=v=>{L(v)}}))}P.push(r)}if(await Promise.all(P),d.length<u){let Q;const n=Math.pow(2,u-1-d.length),T=n*n*4;switch(v.type){case 0:Q=new Uint8Array(T);break;case 2:Q=new Uint16Array(T);break;case 1:Q=new Float32Array(T)}for(let L=d.length;L<u;L++)for(let d=0;d<6;d++){var O;z._uploadArrayBufferViewToTexture((null===(O=V)||void 0===O?void 0:O.texture)||v,Q,d,L)}}if(V){const d=v._irradianceTexture;v._irradianceTexture=null,z._releaseTexture(v),V._swapAndDie(v),v._irradianceTexture=d}m&&m.dispose(),X&&(v._lodTextureHigh&&v._lodTextureHigh._texture&&(v._lodTextureHigh._texture.isReady=!0),v._lodTextureMid&&v._lodTextureMid._texture&&(v._lodTextureMid._texture.isReady=!0),v._lodTextureLow&&v._lodTextureLow._texture&&(v._lodTextureLow._texture.isReady=!0))}function J(v,d){const Q=(d=m(d)).irradiance;if(!Q)return;const n=new e.e;T.j.FromArrayToRef(Q.x,0,n.x),T.j.FromArrayToRef(Q.y,0,n.y),T.j.FromArrayToRef(Q.z,0,n.z),T.j.FromArrayToRef(Q.xx,0,n.xx),T.j.FromArrayToRef(Q.yy,0,n.yy),T.j.FromArrayToRef(Q.zz,0,n.zz),T.j.FromArrayToRef(Q.yz,0,n.yz),T.j.FromArrayToRef(Q.zx,0,n.zx),T.j.FromArrayToRef(Q.xy,0,n.xy),v._sphericalPolynomial=n}function K(v,d,Q,n,T){const L=f(v.getEngine().createRawCubeTexture(null,v.width,v.format,v.type,v.generateMipMaps,v.invertY,v.samplingMode,v._compression),d).then((()=>v));return v.onRebuildCallback=v=>({proxy:L,isReady:!0,isAsync:!0}),v._source=13,v._bufferViewArrayArray=d,v._lodGenerationScale=n,v._lodGenerationOffset=T,v._sphericalPolynomial=Q,f(v,d).then((()=>(v.isReady=!0,v)))}}}]);