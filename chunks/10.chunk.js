"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2227:(Y,d,t)=>{t.r(d),t.d(d,{_HDRTextureLoader:()=>f});var x=t(686);class C{static ConvertPanoramaToCubemap(Y,d,t,x){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!Y)throw"ConvertPanoramaToCubemap: input cannot be null";if(Y.length!=d*t*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(x,this.FACE_FRONT,Y,d,t,C),back:this.CreateCubemapTexture(x,this.FACE_BACK,Y,d,t,C),left:this.CreateCubemapTexture(x,this.FACE_LEFT,Y,d,t,C),right:this.CreateCubemapTexture(x,this.FACE_RIGHT,Y,d,t,C),up:this.CreateCubemapTexture(x,this.FACE_UP,Y,d,t,C),down:this.CreateCubemapTexture(x,this.FACE_DOWN,Y,d,t,C),size:x,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(Y,d,t,x,C){let U=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const y=new ArrayBuffer(Y*Y*4*3),B=new Float32Array(y),W=U?Math.max(1,Math.round(x/4/Y)):1,o=1/W,f=o*o,F=d[1].ae(d[0]).scale(o/Y),D=d[3].ae(d[2]).scale(o/Y),b=1/Y;let m=0;for(let M=0;M<Y;M++)for(let U=0;U<W;U++){let U=d[0],y=d[2];for(let d=0;d<Y;d++)for(let o=0;o<W;o++){const W=y.ae(U).scale(m).add(U);W.normalize();const o=this.CalcProjectionSpherical(W,t,x,C);B[M*Y*3+3*d+0]+=o.r*f,B[M*Y*3+3*d+1]+=o.g*f,B[M*Y*3+3*d+2]+=o.b*f,U=U.add(F),y=y.add(D)}m+=b*o}return B}static CalcProjectionSpherical(Y,d,t,x){let C=Math.atan2(Y.z,Y.x);const U=Math.acos(Y.y);for(;C<-Math.PI;)C+=2*Math.PI;for(;C>Math.PI;)C-=2*Math.PI;let y=C/Math.PI;const B=U/Math.PI;y=.5*y+.5;let W=Math.round(y*t);W<0?W=0:W>=t&&(W=t-1);let o=Math.round(B*x);o<0?o=0:o>=x&&(o=x-1);const f=x-o-1;return{r:d[f*t*3+3*W+0],g:d[f*t*3+3*W+1],b:d[f*t*3+3*W+2]}}}function U(Y,d,t,x,C,U){C>0?(C=function(Y,d){return d>1023?Y*Math.pow(2,1023)*Math.pow(2,d-1023):d<-1074?Y*Math.pow(2,-1074)*Math.pow(2,d+1074):Y*Math.pow(2,d)}(1,C-136),Y[U+0]=d*C,Y[U+1]=t*C,Y[U+2]=x*C):(Y[U+0]=0,Y[U+1]=0,Y[U+2]=0)}function y(Y,d){let t="",x="";for(let C=d;C<Y.length-d&&(x=String.fromCharCode(Y[C]),"\n"!=x);C++)t+=x;return t}function B(Y){let d=0,t=0,x=y(Y,0);if("#"!=x[0]||"?"!=x[1])throw"Bad HDR Format.";let C=!1,U=!1,B=0;do{B+=x.length+1,x=y(Y,B),"FORMAT=32-bit_rle_rgbe"==x?U=!0:0==x.length&&(C=!0)}while(!C);if(!U)throw"HDR Bad header format, unsupported FORMAT";B+=x.length+1,x=y(Y,B);const W=/^-Y (.*) \+X (.*)$/g.exec(x);if(!W||W.length<3)throw"HDR Bad header format, no size";if(t=parseInt(W[2]),d=parseInt(W[1]),t<8||t>32767)throw"HDR Bad header format, unsupported size";return B+=x.length+1,{height:d,width:t,dataPosition:B}}function W(Y,d){return function(Y,d){let t=d.height;const x=d.width;let C,y,B,W,f,F=d.dataPosition,D=0,b=0,m=0;const M=new ArrayBuffer(4*x),J=new Uint8Array(M),g=new ArrayBuffer(d.width*d.height*4*3),T=new Float32Array(g);for(;t>0;){if(C=Y[F++],y=Y[F++],B=Y[F++],W=Y[F++],2!=C||2!=y||128&B||d.width<8||d.width>32767)return o(Y,d);if((B<<8|W)!=x)throw"HDR Bad header format, wrong scan line width";for(D=0,m=0;m<4;m++)for(b=(m+1)*x;D<b;)if(C=Y[F++],y=Y[F++],C>128){if(f=C-128,0==f||f>b-D)throw"HDR Bad Format, bad scanline data (run)";for(;f-- >0;)J[D++]=y}else{if(f=C,0==f||f>b-D)throw"HDR Bad Format, bad scanline data (non-run)";if(J[D++]=y,--f>0)for(let d=0;d<f;d++)J[D++]=Y[F++]}for(m=0;m<x;m++)C=J[m],y=J[m+x],B=J[m+2*x],W=J[m+3*x],U(T,C,y,B,W,(d.height-t)*x*3+3*m);t--}return T}(Y,d)}function o(Y,d){let t=d.height;const x=d.width;let C,y,B,W,o,f=d.dataPosition;const F=new ArrayBuffer(d.width*d.height*4*3),D=new Float32Array(F);for(;t>0;){for(o=0;o<d.width;o++)C=Y[f++],y=Y[f++],B=Y[f++],W=Y[f++],U(D,C,y,B,W,(d.height-t)*x*3+3*o);t--}return D}C.FACE_LEFT=[new x.k(-1,-1,-1),new x.k(1,-1,-1),new x.k(-1,1,-1),new x.k(1,1,-1)],C.FACE_RIGHT=[new x.k(1,-1,1),new x.k(-1,-1,1),new x.k(1,1,1),new x.k(-1,1,1)],C.FACE_FRONT=[new x.k(1,-1,-1),new x.k(1,-1,1),new x.k(1,1,-1),new x.k(1,1,1)],C.FACE_BACK=[new x.k(-1,-1,1),new x.k(-1,-1,-1),new x.k(-1,1,1),new x.k(-1,1,-1)],C.FACE_DOWN=[new x.k(1,1,-1),new x.k(1,1,1),new x.k(-1,1,-1),new x.k(-1,1,1)],C.FACE_UP=[new x.k(-1,-1,-1),new x.k(-1,-1,1),new x.k(1,-1,-1),new x.k(1,-1,1)];class f{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Y,d,t){const x=new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength),C=B(x),U=W(x,C),y=C.width*C.height,o=new Float32Array(4*y);for(let B=0;B<y;B+=1)o[4*B]=U[3*B],o[4*B+1]=U[3*B+1],o[4*B+2]=U[3*B+2],o[4*B+3]=1;t(C.width,C.height,d.generateMipMaps,!1,(()=>{const Y=d.getEngine();d.type=1,d.format=5,d._gammaSpace=!1,Y._uploadDataToTextureDirectly(d,o)}))}}}}]);