"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{2445:(K,Y,l)=>{l.r(Y),l.d(Y,{_HDRTextureLoader:()=>m});var v=l(675);class U{static ConvertPanoramaToCubemap(K,Y,l,v){let U=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!K)throw"ConvertPanoramaToCubemap: input cannot be null";if(K.length!=Y*l*3)throw"ConvertPanoramaToCubemap: input size is wrong";return{front:this.CreateCubemapTexture(v,this.FACE_FRONT,K,Y,l,U),back:this.CreateCubemapTexture(v,this.FACE_BACK,K,Y,l,U),left:this.CreateCubemapTexture(v,this.FACE_LEFT,K,Y,l,U),right:this.CreateCubemapTexture(v,this.FACE_RIGHT,K,Y,l,U),up:this.CreateCubemapTexture(v,this.FACE_UP,K,Y,l,U),down:this.CreateCubemapTexture(v,this.FACE_DOWN,K,Y,l,U),size:v,type:1,format:4,gammaSpace:!1}}static CreateCubemapTexture(K,Y,l,v,U){let d=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const A=new ArrayBuffer(K*K*4*3),c=new Float32Array(A),t=d?Math.max(1,Math.round(v/4/K)):1,Z=1/t,m=Z*Z,V=Y[1].Lg(Y[0]).scale(Z/K),M=Y[3].Lg(Y[2]).scale(Z/K),u=1/K;let o=0;for(let W=0;W<K;W++)for(let d=0;d<t;d++){let d=Y[0],A=Y[2];for(let Y=0;Y<K;Y++)for(let Z=0;Z<t;Z++){const t=A.Lg(d).scale(o).add(d);t.normalize();const Z=this.CalcProjectionSpherical(t,l,v,U);c[W*K*3+3*Y+0]+=Z.r*m,c[W*K*3+3*Y+1]+=Z.g*m,c[W*K*3+3*Y+2]+=Z.b*m,d=d.add(V),A=A.add(M)}o+=u*Z}return c}static CalcProjectionSpherical(K,Y,l,v){let U=Math.atan2(K.z,K.x);const d=Math.acos(K.y);for(;U<-Math.PI;)U+=2*Math.PI;for(;U>Math.PI;)U-=2*Math.PI;let A=U/Math.PI;const c=d/Math.PI;A=.5*A+.5;let t=Math.round(A*l);t<0?t=0:t>=l&&(t=l-1);let Z=Math.round(c*v);Z<0?Z=0:Z>=v&&(Z=v-1);const m=v-Z-1;return{r:Y[m*l*3+3*t+0],g:Y[m*l*3+3*t+1],b:Y[m*l*3+3*t+2]}}}function d(K,Y,l,v,U,d){U>0?(U=function(K,Y){return Y>1023?K*Math.pow(2,1023)*Math.pow(2,Y-1023):Y<-1074?K*Math.pow(2,-1074)*Math.pow(2,Y+1074):K*Math.pow(2,Y)}(1,U-136),K[d+0]=Y*U,K[d+1]=l*U,K[d+2]=v*U):(K[d+0]=0,K[d+1]=0,K[d+2]=0)}function A(K,Y){let l="",v="";for(let U=Y;U<K.length-Y&&(v=String.fromCharCode(K[U]),"\n"!=v);U++)l+=v;return l}function c(K){let Y=0,l=0,v=A(K,0);if("#"!=v[0]||"?"!=v[1])throw"Bad HDR Format.";let U=!1,d=!1,c=0;do{c+=v.length+1,v=A(K,c),"FORMAT=32-bit_rle_rgbe"==v?d=!0:0==v.length&&(U=!0)}while(!U);if(!d)throw"HDR Bad header format, unsupported FORMAT";c+=v.length+1,v=A(K,c);const t=/^-Y (.*) \+X (.*)$/g.exec(v);if(!t||t.length<3)throw"HDR Bad header format, no size";if(l=parseInt(t[2]),Y=parseInt(t[1]),l<8||l>32767)throw"HDR Bad header format, unsupported size";return c+=v.length+1,{height:Y,width:l,dataPosition:c}}function t(K,Y){return function(K,Y){let l=Y.height;const v=Y.width;let U,A,c,t,m,V=Y.dataPosition,M=0,u=0,o=0;const W=new ArrayBuffer(4*v),g=new Uint8Array(W),J=new ArrayBuffer(Y.width*Y.height*4*3),n=new Float32Array(J);for(;l>0;){if(U=K[V++],A=K[V++],c=K[V++],t=K[V++],2!=U||2!=A||128&c||Y.width<8||Y.width>32767)return Z(K,Y);if((c<<8|t)!=v)throw"HDR Bad header format, wrong scan line width";for(M=0,o=0;o<4;o++)for(u=(o+1)*v;M<u;)if(U=K[V++],A=K[V++],U>128){if(m=U-128,0==m||m>u-M)throw"HDR Bad Format, bad scanline data (run)";for(;m-- >0;)g[M++]=A}else{if(m=U,0==m||m>u-M)throw"HDR Bad Format, bad scanline data (non-run)";if(g[M++]=A,--m>0)for(let Y=0;Y<m;Y++)g[M++]=K[V++]}for(o=0;o<v;o++)U=g[o],A=g[o+v],c=g[o+2*v],t=g[o+3*v],d(n,U,A,c,t,(Y.height-l)*v*3+3*o);l--}return n}(K,Y)}function Z(K,Y){let l=Y.height;const v=Y.width;let U,A,c,t,Z,m=Y.dataPosition;const V=new ArrayBuffer(Y.width*Y.height*4*3),M=new Float32Array(V);for(;l>0;){for(Z=0;Z<Y.width;Z++)U=K[m++],A=K[m++],c=K[m++],t=K[m++],d(M,U,A,c,t,(Y.height-l)*v*3+3*Z);l--}return M}U.FACE_LEFT=[new v.o(-1,-1,-1),new v.o(1,-1,-1),new v.o(-1,1,-1),new v.o(1,1,-1)],U.FACE_RIGHT=[new v.o(1,-1,1),new v.o(-1,-1,1),new v.o(1,1,1),new v.o(-1,1,1)],U.FACE_FRONT=[new v.o(1,-1,-1),new v.o(1,-1,1),new v.o(1,1,-1),new v.o(1,1,1)],U.FACE_BACK=[new v.o(-1,-1,1),new v.o(-1,-1,-1),new v.o(-1,1,1),new v.o(-1,1,-1)],U.FACE_DOWN=[new v.o(1,1,-1),new v.o(1,1,1),new v.o(-1,1,-1),new v.o(-1,1,1)],U.FACE_UP=[new v.o(-1,-1,-1),new v.o(-1,-1,1),new v.o(1,-1,-1),new v.o(1,-1,1)];class m{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(K,Y,l){const v=new Uint8Array(K.buffer,K.byteOffset,K.byteLength),U=c(v),d=t(v,U),A=U.width*U.height,Z=new Float32Array(4*A);for(let c=0;c<A;c+=1)Z[4*c]=d[3*c],Z[4*c+1]=d[3*c+1],Z[4*c+2]=d[3*c+2],Z[4*c+3]=1;l(U.width,U.height,Y.generateMipMaps,!1,(()=>{const K=Y.getEngine();Y.type=1,Y.format=5,Y._gammaSpace=!1,K._uploadDataToTextureDirectly(Y,Z)}))}}}}]);