"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[10],{11052:(P,f,Y)=>{Y.d(f,{e:()=>q});var C=Y(11018);class q{static get LastCreatedEngine(){return 0===this.Instances.length?null:this.Instances[this.Instances.length-1]}static get LastCreatedScene(){return this._LastCreatedScene}}q.Instances=[],q.OnEnginesDisposedObservable=new C.e,q._LastCreatedScene=null,q.UseFallbackTexture=!0,q.FallbackTexture=""},11112:(P,f,Y)=>{Y.d(f,{b:()=>C});class C{static SetMatrixPrecision(P){if(C.MatrixTrackPrecisionChange=!1,P&&!C.MatrixUse64Bits&&C.MatrixTrackedMatrices)for(let f=0;f<C.MatrixTrackedMatrices.length;++f){const P=C.MatrixTrackedMatrices[f],Y=P.cf;P.cf=new Array(16);for(let f=0;f<16;++f)P.cf[f]=Y[f]}C.MatrixUse64Bits=P,C.MatrixCurrentType=C.MatrixUse64Bits?Array:Float32Array,C.MatrixTrackedMatrices=null}}C.MatrixUse64Bits=!1,C.MatrixTrackPrecisionChange=!0,C.MatrixCurrentType=Float32Array,C.MatrixTrackedMatrices=[]},11018:(P,f,Y)=>{Y.d(f,{e:()=>L});const C="undefined"!==typeof WeakRef;class q{constructor(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Y=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0;this.initialize(P,f,Y,C)}initialize(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Y=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0;return this.mask=P,this.skipNextObservers=f,this.target=Y,this.currentTarget=C,this}}class m{constructor(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.callback=P,this.mask=f,this.scope=Y,this._willBeUnregistered=!1,this.unregisterOnNextCall=!1,this._remove=null}remove(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this._remove&&this._remove(P)}}class L{static FromPromise(P,f){const Y=new L;return P.then((P=>{Y.notifyObservers(P)})).catch((P=>{if(!f)throw P;f.notifyObservers(P)})),Y}get observers(){return this._observers}constructor(P){let f=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.notifyIfTriggered=f,this._observers=new Array,this._numObserversMarkedAsDeleted=0,this._hasNotified=!1,this._eventState=new q(0),P&&(this._onObserverAdded=P)}add(P){let f=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Y=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(!P)return null;const q=new m(P,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null);q.unregisterOnNextCall=Y,f?this._observers.unshift(q):this._observers.push(q),this._onObserverAdded&&this._onObserverAdded(q),this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(q,this._lastNotifiedValue);const L=C?new WeakRef(this):{deref:()=>this};return q._remove=function(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const f=L.deref();f&&(P?f.remove(q):f._remove(q))},q}addOnce(P){return this.add(P,void 0,void 0,void 0,!0)}remove(P){if(!P)return!1;P._remove=null;return-1!==this._observers.indexOf(P)&&(this._deferUnregister(P),!0)}removeCallback(P,f){for(let Y=0;Y<this._observers.length;Y++){const C=this._observers[Y];if(!C._willBeUnregistered&&(C.callback===P&&(!f||f===C.scope)))return this._deferUnregister(C),!0}return!1}_deferUnregister(P){P._willBeUnregistered||(this._numObserversMarkedAsDeleted++,P.unregisterOnNextCall=!1,P._willBeUnregistered=!0,setTimeout((()=>{this._remove(P)}),0))}_remove(P){let f=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];if(!P)return!1;const Y=this._observers.indexOf(P);return-1!==Y&&(f&&this._numObserversMarkedAsDeleted--,this._observers.splice(Y,1),!0)}makeObserverTopPriority(P){this._remove(P,!1),this._observers.unshift(P)}makeObserverBottomPriority(P){this._remove(P,!1),this._observers.push(P)}notifyObservers(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,Y=arguments.length>2?arguments[2]:void 0,C=arguments.length>3?arguments[3]:void 0,q=arguments.length>4?arguments[4]:void 0;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=P),!this._observers.length)return!0;const m=this._eventState;m.mask=f,m.target=Y,m.currentTarget=C,m.skipNextObservers=!1,m.lastReturnValue=P,m.userInfo=q;for(const L of this._observers)if(!L._willBeUnregistered&&(L.mask&f&&(L.unregisterOnNextCall&&this._deferUnregister(L),L.scope?m.lastReturnValue=L.callback.apply(L.scope,[P,m]):m.lastReturnValue=L.callback(P,m)),m.skipNextObservers))return!1;return!0}notifyObserver(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=f),P._willBeUnregistered)return;const C=this._eventState;C.mask=Y,C.skipNextObservers=!1,P.unregisterOnNextCall&&this._deferUnregister(P),P.callback(f,C)}hasObservers(){return this._observers.length-this._numObserversMarkedAsDeleted>0}clear(){for(;this._observers.length;){const P=this._observers.pop();P&&(P._remove=null)}this._onObserverAdded=null,this._numObserversMarkedAsDeleted=0,this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1,this._lastNotifiedValue=void 0}clone(){const P=new L;return P._observers=this._observers.slice(0),P}hasSpecificMask(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1;for(const f of this._observers)if(f.mask&P||f.mask===P)return!0;return!1}}},11134:(P,f,Y)=>{Y.d(f,{c:()=>m,d:()=>q});const C={};function q(P,f){C[P]=f}function m(P){return C[P]}}}]);