"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[89],{14377:(V,I,A)=>{A.r(I),A.d(I,{FlowGraphAngleBetweenBlock:()=>e,FlowGraphAxisAngleFromQuaternionBlock:()=>Q,FlowGraphConjugateBlock:()=>s,FlowGraphCrossBlock:()=>W,FlowGraphDotBlock:()=>u,FlowGraphLengthBlock:()=>w,FlowGraphNormalizeBlock:()=>t,FlowGraphQuaternionFromAxisAngleBlock:()=>S,FlowGraphQuaternionFromDirectionsBlock:()=>h,FlowGraphRotate2DBlock:()=>g,FlowGraphRotate3DBlock:()=>o,FlowGraphTransformBlock:()=>z,FlowGraphTransformCoordinatesBlock:()=>m});var B=A(12979),F=A(12954),E=A(11189),Y=A(14360),H=A(14373),c=A(11231),b=A(12989),X=A(12637);const P="cachedOperationAxis",J="cachedOperationAngle",G="cachedExecutionId";class w extends H.e{constructor(V){super(F.e,F.v,(V=>this._polymorphicLength(V)),"FlowGraphLengthBlock",V)}_polymorphicLength(V){switch((0,b.n)(V)){case"Vector2":case"tI":case"Vector4":case"Quaternion":return V.length();default:throw new Error(`Cannot compute length of value ${V}`)}}}(0,E.e)("FlowGraphLengthBlock",w);class t extends H.e{constructor(V){super(F.e,F.e,(V=>this._polymorphicNormalize(V)),"FlowGraphNormalizeBlock",V)}_polymorphicNormalize(V){var I;let A;switch((0,b.n)(V)){case"Vector2":case"tI":case"Vector4":case"Quaternion":if(A=V.normalizeToNew(),null!==(I=this.config)&&void 0!==I&&I.nanOnZeroLength){0===V.length()&&A.JH(NaN)}return A;default:throw new Error(`Cannot normalize value ${V}`)}}}(0,E.e)("FlowGraphNormalizeBlock",t);class u extends Y.d{constructor(V){super(F.e,F.e,F.v,((V,I)=>this._polymorphicDot(V,I)),"FlowGraphDotBlock",V)}_polymorphicDot(V,I){switch((0,b.n)(V)){case"Vector2":case"tI":case"Vector4":case"Quaternion":return V.dot(I);default:throw new Error(`Cannot get dot product of ${V} and ${I}`)}}}(0,E.e)("FlowGraphDotBlock",u);class W extends Y.d{constructor(V){super(F.H,F.H,F.H,((V,I)=>c.tI.Cross(V,I)),"FlowGraphCrossBlock",V)}}(0,E.e)("FlowGraphCrossBlock",W);class g extends Y.d{constructor(V){super(F.D,F.v,F.D,((V,I)=>V.rotate(I)),"FlowGraphRotate2DBlock",V)}}(0,E.e)("FlowGraphRotate2DBlock",g);class o extends Y.d{constructor(V){super(F.H,F.x,F.H,((V,I)=>V.applyRotationQuaternion(I)),"FlowGraphRotate3DBlock",V)}}function L(V,I){switch((0,b.n)(V)){case"Vector2":case"tI":return I.transformVector(V);case"Vector4":return new c.Vector4(V.x*I.m[0]+V.y*I.m[1]+V.z*I.m[2]+V.w*I.m[3],V.x*I.m[4]+V.y*I.m[5]+V.z*I.m[6]+V.w*I.m[7],V.x*I.m[8]+V.y*I.m[9]+V.z*I.m[10]+V.w*I.m[11],V.x*I.m[12]+V.y*I.m[13]+V.z*I.m[14]+V.w*I.m[15]);default:throw new Error(`Cannot transform value ${V}`)}}(0,E.e)("FlowGraphRotate3DBlock",o);class z extends Y.d{constructor(V){const I=(null===V||void 0===V?void 0:V.vectorType)||"tI",A="Vector2"===I?"Matrix2D":"tI"===I?"Matrix3D":"Matrix";super((0,F.P)(I),(0,F.P)(A),(0,F.P)(I),L,"FlowGraphTransformVectorBlock",V)}}(0,E.e)("FlowGraphTransformVectorBlock",z);class m extends Y.d{constructor(V){super(F.H,F.m,F.H,((V,I)=>c.tI.TransformCoordinates(V,I)),"FlowGraphTransformCoordinatesBlock",V)}}(0,E.e)("FlowGraphTransformCoordinatesBlock",m);class s extends H.e{constructor(V){super(F.x,F.x,(V=>V.conjugate()),"FlowGraphConjugateBlock",V)}}(0,E.e)("FlowGraphConjugateBlock",s);class e extends Y.d{constructor(V){super(F.x,F.x,F.v,((V,I)=>(0,X.b)(V,I)),"FlowGraphAngleBetweenBlock",V)}}(0,E.e)("FlowGraphAngleBetweenBlock",e);class S extends Y.d{constructor(V){super(F.H,F.v,F.x,((V,I)=>c.Quaternion.RotationAxis(V,I)),"FlowGraphQuaternionFromAxisAngleBlock",V)}}(0,E.e)("FlowGraphQuaternionFromAxisAngleBlock",S);class Q extends B.d{constructor(V){super(V),this.a=this.registerDataInput("a",F.x),this.axis=this.registerDataOutput("axis",F.H),this.angle=this.registerDataOutput("angle",F.v),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(V){const I=V._getExecutionVariable(this,G,-1),A=V._getExecutionVariable(this,P,null),B=V._getExecutionVariable(this,J,null);if(void 0!==A&&null!==A&&void 0!==B&&null!==B&&I===V.executionId)this.axis.setValue(A,V),this.angle.setValue(B,V);else try{const{axis:I,angle:A}=this.a.getValue(V).toAxisAngle();V._setExecutionVariable(this,P,I),V._setExecutionVariable(this,J,A),V._setExecutionVariable(this,G,V.executionId),this.axis.setValue(I,V),this.angle.setValue(A,V),this.isValid.setValue(!0,V)}catch(F){this.isValid.setValue(!1,V)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,E.e)("FlowGraphAxisAngleFromQuaternionBlock",Q);class h extends Y.d{constructor(V){super(F.H,F.H,F.x,((V,I)=>(0,X.c)(V,I)),"FlowGraphQuaternionFromDirectionsBlock",V)}}},14360:(V,I,A)=>{A.d(I,{d:()=>F});var B=A(14369);class F extends B.d{constructor(V,I,A,B,F,E){super(A,E),this._operation=B,this._className=F,this.a=this.registerDataInput("a",V),this.b=this.registerDataInput("b",I)}_doOperation(V){const I=this.a.getValue(V),A=this.b.getValue(V);return this._operation(I,A)}getClassName(){return this._className}}},14369:(V,I,A)=>{A.d(I,{d:()=>H});var B=A(12979),F=A(12954);const E="cachedOperationValue",Y="cachedExecutionId";class H extends B.d{constructor(V,I){super(I),this.value=this.registerDataOutput("value",V),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(V){const I=V._getExecutionVariable(this,Y,-1),A=V._getExecutionVariable(this,E,null);if(void 0!==A&&null!==A&&I===V.executionId)this.isValid.setValue(!0,V),this.value.setValue(A,V);else try{const I=this._doOperation(V);if(void 0===I||null===I)return void this.isValid.setValue(!1,V);V._setExecutionVariable(this,E,I),V._setExecutionVariable(this,Y,V.executionId),this.value.setValue(I,V),this.isValid.setValue(!0,V)}catch(B){this.isValid.setValue(!1,V)}}}},14373:(V,I,A)=>{A.d(I,{e:()=>F});var B=A(14369);class F extends B.d{constructor(V,I,A,B,F){super(I,F),this._operation=A,this._className=B,this.a=this.registerDataInput("a",V)}_doOperation(V){return this._operation(this.a.getValue(V))}getClassName(){return this._className}}}}]);