"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[89],{14582:(f,v,Z)=>{Z.r(v),Z.d(v,{FlowGraphAngleBetweenBlock:()=>y,FlowGraphAxisAngleFromQuaternionBlock:()=>i,FlowGraphConjugateBlock:()=>Y,FlowGraphCrossBlock:()=>U,FlowGraphDotBlock:()=>F,FlowGraphLengthBlock:()=>b,FlowGraphNormalizeBlock:()=>X,FlowGraphQuaternionFromAxisAngleBlock:()=>N,FlowGraphQuaternionFromDirectionsBlock:()=>I,FlowGraphRotate2DBlock:()=>K,FlowGraphRotate3DBlock:()=>M,FlowGraphTransformBlock:()=>s,FlowGraphTransformCoordinatesBlock:()=>z});var V=Z(13149),h=Z(13123),J=Z(11372),l=Z(14568),e=Z(14576),C=Z(11421),H=Z(13163),O=Z(12804);const u="cachedOperationAxis",W="cachedOperationAngle",a="cachedExecutionId";class b extends e.b{constructor(f){super(h.d,h.v,(f=>this._polymorphicLength(f)),"FlowGraphLengthBlock",f)}_polymorphicLength(f){switch((0,H.j)(f)){case"Vector2":case"Xv":case"Vector4":case"Quaternion":return f.length();default:throw new Error(`Cannot compute length of value ${f}`)}}}(0,J.h)("FlowGraphLengthBlock",b);class X extends e.b{constructor(f){super(h.d,h.d,(f=>this._polymorphicNormalize(f)),"FlowGraphNormalizeBlock",f)}_polymorphicNormalize(f){var v;let Z;switch((0,H.j)(f)){case"Vector2":case"Xv":case"Vector4":case"Quaternion":if(Z=f.normalizeToNew(),null!==(v=this.config)&&void 0!==v&&v.nanOnZeroLength){0===f.length()&&Z.Ve(NaN)}return Z;default:throw new Error(`Cannot normalize value ${f}`)}}}(0,J.h)("FlowGraphNormalizeBlock",X);class F extends l.c{constructor(f){super(h.d,h.d,h.v,((f,v)=>this._polymorphicDot(f,v)),"FlowGraphDotBlock",f)}_polymorphicDot(f,v){switch((0,H.j)(f)){case"Vector2":case"Xv":case"Vector4":case"Quaternion":return f.dot(v);default:throw new Error(`Cannot get dot product of ${f} and ${v}`)}}}(0,J.h)("FlowGraphDotBlock",F);class U extends l.c{constructor(f){super(h.J,h.J,h.J,((f,v)=>C.Xv.Cross(f,v)),"FlowGraphCrossBlock",f)}}(0,J.h)("FlowGraphCrossBlock",U);class K extends l.c{constructor(f){super(h.F,h.v,h.F,((f,v)=>f.rotate(v)),"FlowGraphRotate2DBlock",f)}}(0,J.h)("FlowGraphRotate2DBlock",K);class M extends l.c{constructor(f){super(h.J,h.x,h.J,((f,v)=>f.applyRotationQuaternion(v)),"FlowGraphRotate3DBlock",f)}}function A(f,v){switch((0,H.j)(f)){case"Vector2":case"Xv":return v.transformVector(f);case"Vector4":return new C.Vector4(f.x*v.m[0]+f.y*v.m[1]+f.z*v.m[2]+f.w*v.m[3],f.x*v.m[4]+f.y*v.m[5]+f.z*v.m[6]+f.w*v.m[7],f.x*v.m[8]+f.y*v.m[9]+f.z*v.m[10]+f.w*v.m[11],f.x*v.m[12]+f.y*v.m[13]+f.z*v.m[14]+f.w*v.m[15]);default:throw new Error(`Cannot transform value ${f}`)}}(0,J.h)("FlowGraphRotate3DBlock",M);class s extends l.c{constructor(f){const v=(null===f||void 0===f?void 0:f.vectorType)||"Xv",Z="Vector2"===v?"Matrix2D":"Xv"===v?"Matrix3D":"Matrix";super((0,h.S)(v),(0,h.S)(Z),(0,h.S)(v),A,"FlowGraphTransformVectorBlock",f)}}(0,J.h)("FlowGraphTransformVectorBlock",s);class z extends l.c{constructor(f){super(h.J,h.o,h.J,((f,v)=>C.Xv.TransformCoordinates(f,v)),"FlowGraphTransformCoordinatesBlock",f)}}(0,J.h)("FlowGraphTransformCoordinatesBlock",z);class Y extends e.b{constructor(f){super(h.x,h.x,(f=>f.conjugate()),"FlowGraphConjugateBlock",f)}}(0,J.h)("FlowGraphConjugateBlock",Y);class y extends l.c{constructor(f){super(h.x,h.x,h.v,((f,v)=>(0,O.c)(f,v)),"FlowGraphAngleBetweenBlock",f)}}(0,J.h)("FlowGraphAngleBetweenBlock",y);class N extends l.c{constructor(f){super(h.J,h.v,h.x,((f,v)=>C.Quaternion.RotationAxis(f,v)),"FlowGraphQuaternionFromAxisAngleBlock",f)}}(0,J.h)("FlowGraphQuaternionFromAxisAngleBlock",N);class i extends V.c{constructor(f){super(f),this.a=this.registerDataInput("a",h.x),this.axis=this.registerDataOutput("axis",h.J),this.angle=this.registerDataOutput("angle",h.v),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(f){const v=f._getExecutionVariable(this,a,-1),Z=f._getExecutionVariable(this,u,null),V=f._getExecutionVariable(this,W,null);if(void 0!==Z&&null!==Z&&void 0!==V&&null!==V&&v===f.executionId)this.axis.setValue(Z,f),this.angle.setValue(V,f);else try{const{axis:v,angle:Z}=this.a.getValue(f).toAxisAngle();f._setExecutionVariable(this,u,v),f._setExecutionVariable(this,W,Z),f._setExecutionVariable(this,a,f.executionId),this.axis.setValue(v,f),this.angle.setValue(Z,f),this.isValid.setValue(!0,f)}catch(h){this.isValid.setValue(!1,f)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,J.h)("FlowGraphAxisAngleFromQuaternionBlock",i);class I extends l.c{constructor(f){super(h.J,h.J,h.x,((f,v)=>(0,O.f)(f,v)),"FlowGraphQuaternionFromDirectionsBlock",f)}}},14568:(f,v,Z)=>{Z.d(v,{c:()=>h});var V=Z(14573);class h extends V.b{constructor(f,v,Z,V,h,J){super(Z,J),this._operation=V,this._className=h,this.a=this.registerDataInput("a",f),this.b=this.registerDataInput("b",v)}_doOperation(f){const v=this.a.getValue(f),Z=this.b.getValue(f);return this._operation(v,Z)}getClassName(){return this._className}}},14573:(f,v,Z)=>{Z.d(v,{b:()=>e});var V=Z(13149),h=Z(13123);const J="cachedOperationValue",l="cachedExecutionId";class e extends V.c{constructor(f,v){super(v),this.value=this.registerDataOutput("value",f),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(f){const v=f._getExecutionVariable(this,l,-1),Z=f._getExecutionVariable(this,J,null);if(void 0!==Z&&null!==Z&&v===f.executionId)this.isValid.setValue(!0,f),this.value.setValue(Z,f);else try{const v=this._doOperation(f);if(void 0===v||null===v)return void this.isValid.setValue(!1,f);f._setExecutionVariable(this,J,v),f._setExecutionVariable(this,l,f.executionId),this.value.setValue(v,f),this.isValid.setValue(!0,f)}catch(V){this.isValid.setValue(!1,f)}}}},14576:(f,v,Z)=>{Z.d(v,{b:()=>h});var V=Z(14573);class h extends V.b{constructor(f,v,Z,V,h){super(v,h),this._operation=Z,this._className=V,this.a=this.registerDataInput("a",f)}_doOperation(f){return this._operation(this.a.getValue(f))}getClassName(){return this._className}}}}]);