"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14418:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphAngleBetweenBlock:()=>A,FlowGraphAxisAngleFromQuaternionBlock:()=>J,FlowGraphConjugateBlock:()=>r,FlowGraphCrossBlock:()=>o,FlowGraphDotBlock:()=>S,FlowGraphLengthBlock:()=>k,FlowGraphNormalizeBlock:()=>q,FlowGraphQuaternionFromAxisAngleBlock:()=>D,FlowGraphQuaternionFromDirectionsBlock:()=>i,FlowGraphRotate2DBlock:()=>U,FlowGraphRotate3DBlock:()=>G,FlowGraphTransformBlock:()=>c,FlowGraphTransformCoordinatesBlock:()=>t});var M=C(12927),x=C(12901),y=C(11149),f=C(14404),L=C(14415),e=C(11194),g=C(12939),N=C(12564);const R="cachedOperationAxis",H="cachedOperationAngle",F="cachedExecutionId";class k extends L.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicLength(B)),"FlowGraphLengthBlock",B)}_polymorphicLength(B){switch((0,g.n)(B)){case"Vector2":case"HI":case"Vector4":case"Quaternion":return B.length();default:throw new Error(`Cannot compute length of value ${B}`)}}}(0,y.h)("FlowGraphLengthBlock",k);class q extends L.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicNormalize(B)),"FlowGraphNormalizeBlock",B)}_polymorphicNormalize(B){var I;let C;switch((0,g.n)(B)){case"Vector2":case"HI":case"Vector4":case"Quaternion":if(C=B.normalizeToNew(),null!==(I=this.config)&&void 0!==I&&I.nanOnZeroLength){0===B.length()&&C.Tf(NaN)}return C;default:throw new Error(`Cannot normalize value ${B}`)}}}(0,y.h)("FlowGraphNormalizeBlock",q);class S extends f.d{constructor(B){super(x.b,x.b,x.m,((B,I)=>this._polymorphicDot(B,I)),"FlowGraphDotBlock",B)}_polymorphicDot(B,I){switch((0,g.n)(B)){case"Vector2":case"HI":case"Vector4":case"Quaternion":return B.dot(I);default:throw new Error(`Cannot get dot product of ${B} and ${I}`)}}}(0,y.h)("FlowGraphDotBlock",S);class o extends f.d{constructor(B){super(x.x,x.x,x.x,((B,I)=>e.HI.Cross(B,I)),"FlowGraphCrossBlock",B)}}(0,y.h)("FlowGraphCrossBlock",o);class U extends f.d{constructor(B){super(x.w,x.m,x.w,((B,I)=>B.rotate(I)),"FlowGraphRotate2DBlock",B)}}(0,y.h)("FlowGraphRotate2DBlock",U);class G extends f.d{constructor(B){super(x.x,x.p,x.x,((B,I)=>B.applyRotationQuaternion(I)),"FlowGraphRotate3DBlock",B)}}function V(B,I){switch((0,g.n)(B)){case"Vector2":case"HI":return I.transformVector(B);case"Vector4":return new e.Vector4(B.x*I.m[0]+B.y*I.m[1]+B.z*I.m[2]+B.w*I.m[3],B.x*I.m[4]+B.y*I.m[5]+B.z*I.m[6]+B.w*I.m[7],B.x*I.m[8]+B.y*I.m[9]+B.z*I.m[10]+B.w*I.m[11],B.x*I.m[12]+B.y*I.m[13]+B.z*I.m[14]+B.w*I.m[15]);default:throw new Error(`Cannot transform value ${B}`)}}(0,y.h)("FlowGraphRotate3DBlock",G);class c extends f.d{constructor(B){const I=(null===B||void 0===B?void 0:B.vectorType)||"HI",C="Vector2"===I?"Matrix2D":"HI"===I?"Matrix3D":"Matrix";super((0,x.H)(I),(0,x.H)(C),(0,x.H)(I),V,"FlowGraphTransformVectorBlock",B)}}(0,y.h)("FlowGraphTransformVectorBlock",c);class t extends f.d{constructor(B){super(x.x,x.g,x.x,((B,I)=>e.HI.TransformCoordinates(B,I)),"FlowGraphTransformCoordinatesBlock",B)}}(0,y.h)("FlowGraphTransformCoordinatesBlock",t);class r extends L.e{constructor(B){super(x.p,x.p,(B=>B.conjugate()),"FlowGraphConjugateBlock",B)}}(0,y.h)("FlowGraphConjugateBlock",r);class A extends f.d{constructor(B){super(x.p,x.p,x.m,((B,I)=>(0,N.c)(B,I)),"FlowGraphAngleBetweenBlock",B)}}(0,y.h)("FlowGraphAngleBetweenBlock",A);class D extends f.d{constructor(B){super(x.x,x.m,x.p,((B,I)=>e.Quaternion.RotationAxis(B,I)),"FlowGraphQuaternionFromAxisAngleBlock",B)}}(0,y.h)("FlowGraphQuaternionFromAxisAngleBlock",D);class J extends M.e{constructor(B){super(B),this.a=this.registerDataInput("a",x.p),this.axis=this.registerDataOutput("axis",x.x),this.angle=this.registerDataOutput("angle",x.m),this.isValid=this.registerDataOutput("isValid",x.e)}_updateOutputs(B){const I=B._getExecutionVariable(this,F,-1),C=B._getExecutionVariable(this,R,null),M=B._getExecutionVariable(this,H,null);if(void 0!==C&&null!==C&&void 0!==M&&null!==M&&I===B.executionId)this.axis.setValue(C,B),this.angle.setValue(M,B);else try{const{axis:I,angle:C}=this.a.getValue(B).toAxisAngle();B._setExecutionVariable(this,R,I),B._setExecutionVariable(this,H,C),B._setExecutionVariable(this,F,B.executionId),this.axis.setValue(I,B),this.angle.setValue(C,B),this.isValid.setValue(!0,B)}catch(x){this.isValid.setValue(!1,B)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,y.h)("FlowGraphAxisAngleFromQuaternionBlock",J);class i extends f.d{constructor(B){super(x.x,x.x,x.p,((B,I)=>(0,N.d)(B,I)),"FlowGraphQuaternionFromDirectionsBlock",B)}}},14404:(B,I,C)=>{C.d(I,{d:()=>x});var M=C(14408);class x extends M.b{constructor(B,I,C,M,x,y){super(C,y),this._operation=M,this._className=x,this.a=this.registerDataInput("a",B),this.b=this.registerDataInput("b",I)}_doOperation(B){const I=this.a.getValue(B),C=this.b.getValue(B);return this._operation(I,C)}getClassName(){return this._className}}},14408:(B,I,C)=>{C.d(I,{b:()=>L});var M=C(12927),x=C(12901);const y="cachedOperationValue",f="cachedExecutionId";class L extends M.e{constructor(B,I){super(I),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",x.e)}_updateOutputs(B){const I=B._getExecutionVariable(this,f,-1),C=B._getExecutionVariable(this,y,null);if(void 0!==C&&null!==C&&I===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(C,B);else try{const I=this._doOperation(B);if(void 0===I||null===I)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,y,I),B._setExecutionVariable(this,f,B.executionId),this.value.setValue(I,B),this.isValid.setValue(!0,B)}catch(M){this.isValid.setValue(!1,B)}}}},14415:(B,I,C)=>{C.d(I,{e:()=>x});var M=C(14408);class x extends M.b{constructor(B,I,C,M,x){super(I,x),this._operation=C,this._className=M,this.a=this.registerDataInput("a",B)}_doOperation(B){return this._operation(this.a.getValue(B))}getClassName(){return this._className}}}}]);