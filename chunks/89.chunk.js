"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[89],{14396:(R,J,B)=>{B.r(J),B.d(J,{FlowGraphAngleBetweenBlock:()=>V,FlowGraphAxisAngleFromQuaternionBlock:()=>H,FlowGraphConjugateBlock:()=>I,FlowGraphCrossBlock:()=>u,FlowGraphDotBlock:()=>A,FlowGraphLengthBlock:()=>n,FlowGraphNormalizeBlock:()=>P,FlowGraphQuaternionFromAxisAngleBlock:()=>M,FlowGraphQuaternionFromDirectionsBlock:()=>d,FlowGraphRotate2DBlock:()=>S,FlowGraphRotate3DBlock:()=>f,FlowGraphTransformBlock:()=>s,FlowGraphTransformCoordinatesBlock:()=>x});var Q=B(12922),h=B(12894),y=B(11142),N=B(14384),r=B(14394),q=B(11186),e=B(12934),D=B(12571);const l="cachedOperationAxis",E="cachedOperationAngle",O="cachedExecutionId";class n extends r.d{constructor(R){super(h.e,h.t,(R=>this._polymorphicLength(R)),"FlowGraphLengthBlock",R)}_polymorphicLength(R){switch((0,e.i)(R)){case"Vector2":case"nJ":case"Vector4":case"Quaternion":return R.length();default:throw new Error(`Cannot compute length of value ${R}`)}}}(0,y.h)("FlowGraphLengthBlock",n);class P extends r.d{constructor(R){super(h.e,h.e,(R=>this._polymorphicNormalize(R)),"FlowGraphNormalizeBlock",R)}_polymorphicNormalize(R){var J;let B;switch((0,e.i)(R)){case"Vector2":case"nJ":case"Vector4":case"Quaternion":if(B=R.normalizeToNew(),null!==(J=this.config)&&void 0!==J&&J.nanOnZeroLength){0===R.length()&&B.Sr(NaN)}return B;default:throw new Error(`Cannot normalize value ${R}`)}}}(0,y.h)("FlowGraphNormalizeBlock",P);class A extends N.b{constructor(R){super(h.e,h.e,h.t,((R,J)=>this._polymorphicDot(R,J)),"FlowGraphDotBlock",R)}_polymorphicDot(R,J){switch((0,e.i)(R)){case"Vector2":case"nJ":case"Vector4":case"Quaternion":return R.dot(J);default:throw new Error(`Cannot get dot product of ${R} and ${J}`)}}}(0,y.h)("FlowGraphDotBlock",A);class u extends N.b{constructor(R){super(h.D,h.D,h.D,((R,J)=>q.nJ.Cross(R,J)),"FlowGraphCrossBlock",R)}}(0,y.h)("FlowGraphCrossBlock",u);class S extends N.b{constructor(R){super(h.z,h.t,h.z,((R,J)=>R.rotate(J)),"FlowGraphRotate2DBlock",R)}}(0,y.h)("FlowGraphRotate2DBlock",S);class f extends N.b{constructor(R){super(h.D,h.w,h.D,((R,J)=>R.applyRotationQuaternion(J)),"FlowGraphRotate3DBlock",R)}}function a(R,J){switch((0,e.i)(R)){case"Vector2":case"nJ":return J.transformVector(R);case"Vector4":return new q.Vector4(R.x*J.m[0]+R.y*J.m[1]+R.z*J.m[2]+R.w*J.m[3],R.x*J.m[4]+R.y*J.m[5]+R.z*J.m[6]+R.w*J.m[7],R.x*J.m[8]+R.y*J.m[9]+R.z*J.m[10]+R.w*J.m[11],R.x*J.m[12]+R.y*J.m[13]+R.z*J.m[14]+R.w*J.m[15]);default:throw new Error(`Cannot transform value ${R}`)}}(0,y.h)("FlowGraphRotate3DBlock",f);class s extends N.b{constructor(R){const J=(null===R||void 0===R?void 0:R.vectorType)||"nJ",B="Vector2"===J?"Matrix2D":"nJ"===J?"Matrix3D":"Matrix";super((0,h.O)(J),(0,h.O)(B),(0,h.O)(J),a,"FlowGraphTransformVectorBlock",R)}}(0,y.h)("FlowGraphTransformVectorBlock",s);class x extends N.b{constructor(R){super(h.D,h.l,h.D,((R,J)=>q.nJ.TransformCoordinates(R,J)),"FlowGraphTransformCoordinatesBlock",R)}}(0,y.h)("FlowGraphTransformCoordinatesBlock",x);class I extends r.d{constructor(R){super(h.w,h.w,(R=>R.conjugate()),"FlowGraphConjugateBlock",R)}}(0,y.h)("FlowGraphConjugateBlock",I);class V extends N.b{constructor(R){super(h.w,h.w,h.t,((R,J)=>(0,D.d)(R,J)),"FlowGraphAngleBetweenBlock",R)}}(0,y.h)("FlowGraphAngleBetweenBlock",V);class M extends N.b{constructor(R){super(h.D,h.t,h.w,((R,J)=>q.Quaternion.RotationAxis(R,J)),"FlowGraphQuaternionFromAxisAngleBlock",R)}}(0,y.h)("FlowGraphQuaternionFromAxisAngleBlock",M);class H extends Q.c{constructor(R){super(R),this.a=this.registerDataInput("a",h.w),this.axis=this.registerDataOutput("axis",h.D),this.angle=this.registerDataOutput("angle",h.t),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(R){const J=R._getExecutionVariable(this,O,-1),B=R._getExecutionVariable(this,l,null),Q=R._getExecutionVariable(this,E,null);if(void 0!==B&&null!==B&&void 0!==Q&&null!==Q&&J===R.executionId)this.axis.setValue(B,R),this.angle.setValue(Q,R);else try{const{axis:J,angle:B}=this.a.getValue(R).toAxisAngle();R._setExecutionVariable(this,l,J),R._setExecutionVariable(this,E,B),R._setExecutionVariable(this,O,R.executionId),this.axis.setValue(J,R),this.angle.setValue(B,R),this.isValid.setValue(!0,R)}catch(h){this.isValid.setValue(!1,R)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,y.h)("FlowGraphAxisAngleFromQuaternionBlock",H);class d extends N.b{constructor(R){super(h.D,h.D,h.w,((R,J)=>(0,D.g)(R,J)),"FlowGraphQuaternionFromDirectionsBlock",R)}}},14384:(R,J,B)=>{B.d(J,{b:()=>h});var Q=B(14390);class h extends Q.d{constructor(R,J,B,Q,h,y){super(B,y),this._operation=Q,this._className=h,this.a=this.registerDataInput("a",R),this.b=this.registerDataInput("b",J)}_doOperation(R){const J=this.a.getValue(R),B=this.b.getValue(R);return this._operation(J,B)}getClassName(){return this._className}}},14390:(R,J,B)=>{B.d(J,{d:()=>r});var Q=B(12922),h=B(12894);const y="cachedOperationValue",N="cachedExecutionId";class r extends Q.c{constructor(R,J){super(J),this.value=this.registerDataOutput("value",R),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(R){const J=R._getExecutionVariable(this,N,-1),B=R._getExecutionVariable(this,y,null);if(void 0!==B&&null!==B&&J===R.executionId)this.isValid.setValue(!0,R),this.value.setValue(B,R);else try{const J=this._doOperation(R);if(void 0===J||null===J)return void this.isValid.setValue(!1,R);R._setExecutionVariable(this,y,J),R._setExecutionVariable(this,N,R.executionId),this.value.setValue(J,R),this.isValid.setValue(!0,R)}catch(Q){this.isValid.setValue(!1,R)}}}},14394:(R,J,B)=>{B.d(J,{d:()=>h});var Q=B(14390);class h extends Q.d{constructor(R,J,B,Q,h){super(J,h),this._operation=B,this._className=Q,this.a=this.registerDataInput("a",R)}_doOperation(R){return this._operation(this.a.getValue(R))}getClassName(){return this._className}}}}]);