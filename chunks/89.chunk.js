"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[89],{15008:(M,p,b)=>{b.r(p),b.d(p,{FlowGraphAngleBetweenBlock:()=>y,FlowGraphAxisAngleFromQuaternionBlock:()=>P,FlowGraphConjugateBlock:()=>R,FlowGraphCrossBlock:()=>K,FlowGraphDotBlock:()=>j,FlowGraphLengthBlock:()=>i,FlowGraphNormalizeBlock:()=>A,FlowGraphQuaternionFromAxisAngleBlock:()=>x,FlowGraphQuaternionFromDirectionsBlock:()=>L,FlowGraphRotate2DBlock:()=>D,FlowGraphRotate3DBlock:()=>a,FlowGraphTransformBlock:()=>S,FlowGraphTransformCoordinatesBlock:()=>f});var Q=b(13492),q=b(13477),B=b(11757),k=b(14987),u=b(15001),T=b(11796),O=b(13507),H=b(13157);const F="cachedOperationAxis",o="cachedOperationAngle",W="cachedExecutionId";class i extends u.b{constructor(M){super(q.c,q.q,(M=>this._polymorphicLength(M)),"FlowGraphLengthBlock",M)}_polymorphicLength(M){switch((0,O.m)(M)){case"Vector2":case"Ap":case"Vector4":case"Quaternion":return M.length();default:throw new Error(`Cannot compute length of value ${M}`)}}}(0,B.g)("FlowGraphLengthBlock",i);class A extends u.b{constructor(M){super(q.c,q.c,(M=>this._polymorphicNormalize(M)),"FlowGraphNormalizeBlock",M)}_polymorphicNormalize(M){var p;let b;switch((0,O.m)(M)){case"Vector2":case"Ap":case"Vector4":case"Quaternion":if(b=M.normalizeToNew(),null!==(p=this.config)&&void 0!==p&&p.nanOnZeroLength){0===M.length()&&b.sb(NaN)}return b;default:throw new Error(`Cannot normalize value ${M}`)}}}(0,B.g)("FlowGraphNormalizeBlock",A);class j extends k.c{constructor(M){super(q.c,q.c,q.q,((M,p)=>this._polymorphicDot(M,p)),"FlowGraphDotBlock",M)}_polymorphicDot(M,p){switch((0,O.m)(M)){case"Vector2":case"Ap":case"Vector4":case"Quaternion":return M.dot(p);default:throw new Error(`Cannot get dot product of ${M} and ${p}`)}}}(0,B.g)("FlowGraphDotBlock",j);class K extends k.c{constructor(M){super(q.C,q.C,q.C,((M,p)=>T.Ap.Cross(M,p)),"FlowGraphCrossBlock",M)}}(0,B.g)("FlowGraphCrossBlock",K);class D extends k.c{constructor(M){super(q.B,q.q,q.B,((M,p)=>M.rotate(p)),"FlowGraphRotate2DBlock",M)}}(0,B.g)("FlowGraphRotate2DBlock",D);class a extends k.c{constructor(M){super(q.C,q.t,q.C,((M,p)=>M.applyRotationQuaternion(p)),"FlowGraphRotate3DBlock",M)}}function s(M,p){switch((0,O.m)(M)){case"Vector2":case"Ap":return p.transformVector(M);case"Vector4":return new T.Vector4(M.x*p.m[0]+M.y*p.m[1]+M.z*p.m[2]+M.w*p.m[3],M.x*p.m[4]+M.y*p.m[5]+M.z*p.m[6]+M.w*p.m[7],M.x*p.m[8]+M.y*p.m[9]+M.z*p.m[10]+M.w*p.m[11],M.x*p.m[12]+M.y*p.m[13]+M.z*p.m[14]+M.w*p.m[15]);default:throw new Error(`Cannot transform value ${M}`)}}(0,B.g)("FlowGraphRotate3DBlock",a);class S extends k.c{constructor(M){const p=(null===M||void 0===M?void 0:M.vectorType)||"Ap",b="Vector2"===p?"Matrix2D":"Ap"===p?"Matrix3D":"Matrix";super((0,q.P)(p),(0,q.P)(b),(0,q.P)(p),s,"FlowGraphTransformVectorBlock",M)}}(0,B.g)("FlowGraphTransformVectorBlock",S);class f extends k.c{constructor(M){super(q.C,q.g,q.C,((M,p)=>T.Ap.TransformCoordinates(M,p)),"FlowGraphTransformCoordinatesBlock",M)}}(0,B.g)("FlowGraphTransformCoordinatesBlock",f);class R extends u.b{constructor(M){super(q.t,q.t,(M=>M.conjugate()),"FlowGraphConjugateBlock",M)}}(0,B.g)("FlowGraphConjugateBlock",R);class y extends k.c{constructor(M){super(q.t,q.t,q.q,((M,p)=>(0,H.d)(M,p)),"FlowGraphAngleBetweenBlock",M)}}(0,B.g)("FlowGraphAngleBetweenBlock",y);class x extends k.c{constructor(M){super(q.C,q.q,q.t,((M,p)=>T.Quaternion.RotationAxis(M,p)),"FlowGraphQuaternionFromAxisAngleBlock",M)}}(0,B.g)("FlowGraphQuaternionFromAxisAngleBlock",x);class P extends Q.b{constructor(M){super(M),this.a=this.registerDataInput("a",q.t),this.axis=this.registerDataOutput("axis",q.C),this.angle=this.registerDataOutput("angle",q.q),this.isValid=this.registerDataOutput("isValid",q.d)}_updateOutputs(M){const p=M._getExecutionVariable(this,W,-1),b=M._getExecutionVariable(this,F,null),Q=M._getExecutionVariable(this,o,null);if(void 0!==b&&null!==b&&void 0!==Q&&null!==Q&&p===M.executionId)this.axis.setValue(b,M),this.angle.setValue(Q,M);else try{const{axis:p,angle:b}=this.a.getValue(M).toAxisAngle();M._setExecutionVariable(this,F,p),M._setExecutionVariable(this,o,b),M._setExecutionVariable(this,W,M.executionId),this.axis.setValue(p,M),this.angle.setValue(b,M),this.isValid.setValue(!0,M)}catch(q){this.isValid.setValue(!1,M)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,B.g)("FlowGraphAxisAngleFromQuaternionBlock",P);class L extends k.c{constructor(M){super(q.C,q.C,q.t,((M,p)=>(0,H.e)(M,p)),"FlowGraphQuaternionFromDirectionsBlock",M)}}},14987:(M,p,b)=>{b.d(p,{c:()=>q});var Q=b(14995);class q extends Q.d{constructor(M,p,b,Q,q,B){super(b,B),this._operation=Q,this._className=q,this.a=this.registerDataInput("a",M),this.b=this.registerDataInput("b",p)}_doOperation(M){const p=this.a.getValue(M),b=this.b.getValue(M);return this._operation(p,b)}getClassName(){return this._className}}},14995:(M,p,b)=>{b.d(p,{d:()=>u});var Q=b(13492),q=b(13477);const B="cachedOperationValue",k="cachedExecutionId";class u extends Q.b{constructor(M,p){super(p),this.value=this.registerDataOutput("value",M),this.isValid=this.registerDataOutput("isValid",q.d)}_updateOutputs(M){const p=M._getExecutionVariable(this,k,-1),b=M._getExecutionVariable(this,B,null);if(void 0!==b&&null!==b&&p===M.executionId)this.isValid.setValue(!0,M),this.value.setValue(b,M);else try{const p=this._doOperation(M);if(void 0===p||null===p)return void this.isValid.setValue(!1,M);M._setExecutionVariable(this,B,p),M._setExecutionVariable(this,k,M.executionId),this.value.setValue(p,M),this.isValid.setValue(!0,M)}catch(Q){this.isValid.setValue(!1,M)}}}},15001:(M,p,b)=>{b.d(p,{b:()=>q});var Q=b(14995);class q extends Q.d{constructor(M,p,b,Q,q){super(p,q),this._operation=b,this._className=Q,this.a=this.registerDataInput("a",M)}_doOperation(M){return this._operation(this.a.getValue(M))}getClassName(){return this._className}}}}]);