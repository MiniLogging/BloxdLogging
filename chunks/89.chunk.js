"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[89],{15557:(y,S,I)=>{I.r(S),I.d(S,{FlowGraphAngleBetweenBlock:()=>o,FlowGraphAxisAngleFromQuaternionBlock:()=>z,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>j,FlowGraphDotBlock:()=>l,FlowGraphLengthBlock:()=>L,FlowGraphNormalizeBlock:()=>T,FlowGraphQuaternionFromAxisAngleBlock:()=>E,FlowGraphQuaternionFromDirectionsBlock:()=>r,FlowGraphRotate2DBlock:()=>s,FlowGraphRotate3DBlock:()=>O,FlowGraphTransformBlock:()=>my,FlowGraphTransformCoordinatesBlock:()=>C});var V=I(14058),i=I(14033),A=I(12282),B=I(15535),d=I(15549),F=I(12321),J=I(14064),u=I(13729);const K="cachedOperationAxis",G="cachedOperationAngle",p="cachedExecutionId";class L extends d.e{constructor(y){super(i.c,i.t,(y=>this._polymorphicLength(y)),"FlowGraphLengthBlock",y)}_polymorphicLength(y){switch((0,J.j)(y)){case"Vector2":case"OS":case"Vector4":case"Quaternion":return y.length();default:throw new Error(`Cannot compute length of value ${y}`)}}}(0,A.e)("FlowGraphLengthBlock",L);class T extends d.e{constructor(y){super(i.c,i.c,(y=>this._polymorphicNormalize(y)),"FlowGraphNormalizeBlock",y)}_polymorphicNormalize(y){var S;let I;switch((0,J.j)(y)){case"Vector2":case"OS":case"Vector4":case"Quaternion":if(I=y.normalizeToNew(),null!==(S=this.config)&&void 0!==S&&S.nanOnZeroLength){0===y.length()&&I.nd(NaN)}return I;default:throw new Error(`Cannot normalize value ${y}`)}}}(0,A.e)("FlowGraphNormalizeBlock",T);class l extends B.e{constructor(y){super(i.c,i.c,i.t,((y,S)=>this._polymorphicDot(y,S)),"FlowGraphDotBlock",y)}_polymorphicDot(y,S){switch((0,J.j)(y)){case"Vector2":case"OS":case"Vector4":case"Quaternion":return y.dot(S);default:throw new Error(`Cannot get dot product of ${y} and ${S}`)}}}(0,A.e)("FlowGraphDotBlock",l);class j extends B.e{constructor(y){super(i.C,i.C,i.C,((y,S)=>F.OS.Cross(y,S)),"FlowGraphCrossBlock",y)}}(0,A.e)("FlowGraphCrossBlock",j);class s extends B.e{constructor(y){super(i.B,i.t,i.B,((y,S)=>y.rotate(S)),"FlowGraphRotate2DBlock",y)}}(0,A.e)("FlowGraphRotate2DBlock",s);class O extends B.e{constructor(y){super(i.C,i.x,i.C,((y,S)=>y.applyRotationQuaternion(S)),"FlowGraphRotate3DBlock",y)}}function f(y,S){switch((0,J.j)(y)){case"Vector2":case"OS":return S.transformVector(y);case"Vector4":return new F.Vector4(y.x*S.m[0]+y.y*S.m[1]+y.z*S.m[2]+y.w*S.m[3],y.x*S.m[4]+y.y*S.m[5]+y.z*S.m[6]+y.w*S.m[7],y.x*S.m[8]+y.y*S.m[9]+y.z*S.m[10]+y.w*S.m[11],y.x*S.m[12]+y.y*S.m[13]+y.z*S.m[14]+y.w*S.m[15]);default:throw new Error(`Cannot transform value ${y}`)}}(0,A.e)("FlowGraphRotate3DBlock",O);class my extends B.e{constructor(y){const S=(null===y||void 0===y?void 0:y.vectorType)||"OS",I="Vector2"===S?"Matrix2D":"OS"===S?"Matrix3D":"Matrix";super((0,i.I)(S),(0,i.I)(I),(0,i.I)(S),f,"FlowGraphTransformVectorBlock",y)}}(0,A.e)("FlowGraphTransformVectorBlock",my);class C extends B.e{constructor(y){super(i.C,i.k,i.C,((y,S)=>F.OS.TransformCoordinates(y,S)),"FlowGraphTransformCoordinatesBlock",y)}}(0,A.e)("FlowGraphTransformCoordinatesBlock",C);class D extends d.e{constructor(y){super(i.x,i.x,(y=>y.conjugate()),"FlowGraphConjugateBlock",y)}}(0,A.e)("FlowGraphConjugateBlock",D);class o extends B.e{constructor(y){super(i.x,i.x,i.t,((y,S)=>(0,u.c)(y,S)),"FlowGraphAngleBetweenBlock",y)}}(0,A.e)("FlowGraphAngleBetweenBlock",o);class E extends B.e{constructor(y){super(i.C,i.t,i.x,((y,S)=>F.Quaternion.RotationAxis(y,S)),"FlowGraphQuaternionFromAxisAngleBlock",y)}}(0,A.e)("FlowGraphQuaternionFromAxisAngleBlock",E);class z extends V.d{constructor(y){super(y),this.a=this.registerDataInput("a",i.x),this.axis=this.registerDataOutput("axis",i.C),this.angle=this.registerDataOutput("angle",i.t),this.isValid=this.registerDataOutput("isValid",i.f)}_updateOutputs(y){const S=y._getExecutionVariable(this,p,-1),I=y._getExecutionVariable(this,K,null),V=y._getExecutionVariable(this,G,null);if(void 0!==I&&null!==I&&void 0!==V&&null!==V&&S===y.executionId)this.axis.setValue(I,y),this.angle.setValue(V,y);else try{const{axis:S,angle:I}=this.a.getValue(y).toAxisAngle();y._setExecutionVariable(this,K,S),y._setExecutionVariable(this,G,I),y._setExecutionVariable(this,p,y.executionId),this.axis.setValue(S,y),this.angle.setValue(I,y),this.isValid.setValue(!0,y)}catch(i){this.isValid.setValue(!1,y)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,A.e)("FlowGraphAxisAngleFromQuaternionBlock",z);class r extends B.e{constructor(y){super(i.C,i.C,i.x,((y,S)=>(0,u.g)(y,S)),"FlowGraphQuaternionFromDirectionsBlock",y)}}},15535:(y,S,I)=>{I.d(S,{e:()=>i});var V=I(15540);class i extends V.e{constructor(y,S,I,V,i,A){super(I,A),this._operation=V,this._className=i,this.a=this.registerDataInput("a",y),this.b=this.registerDataInput("b",S)}_doOperation(y){const S=this.a.getValue(y),I=this.b.getValue(y);return this._operation(S,I)}getClassName(){return this._className}}},15540:(y,S,I)=>{I.d(S,{e:()=>d});var V=I(14058),i=I(14033);const A="cachedOperationValue",B="cachedExecutionId";class d extends V.d{constructor(y,S){super(S),this.value=this.registerDataOutput("value",y),this.isValid=this.registerDataOutput("isValid",i.f)}_updateOutputs(y){const S=y._getExecutionVariable(this,B,-1),I=y._getExecutionVariable(this,A,null);if(void 0!==I&&null!==I&&S===y.executionId)this.isValid.setValue(!0,y),this.value.setValue(I,y);else try{const S=this._doOperation(y);if(void 0===S||null===S)return void this.isValid.setValue(!1,y);y._setExecutionVariable(this,A,S),y._setExecutionVariable(this,B,y.executionId),this.value.setValue(S,y),this.isValid.setValue(!0,y)}catch(V){this.isValid.setValue(!1,y)}}}},15549:(y,S,I)=>{I.d(S,{e:()=>i});var V=I(15540);class i extends V.e{constructor(y,S,I,V,i){super(S,i),this._operation=I,this._className=V,this.a=this.registerDataInput("a",y)}_doOperation(y){return this._operation(this.a.getValue(y))}getClassName(){return this._className}}}}]);