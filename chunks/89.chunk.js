"use strict";(self.ksd6jhs1yr=self.ksd6jhs1yr||[]).push([[89],{15624:(C,c,d)=>{d.r(c),d.d(c,{FlowGraphAngleBetweenBlock:()=>r,FlowGraphAxisAngleFromQuaternionBlock:()=>K,FlowGraphConjugateBlock:()=>N,FlowGraphCrossBlock:()=>B,FlowGraphDotBlock:()=>q,FlowGraphLengthBlock:()=>A,FlowGraphNormalizeBlock:()=>u,FlowGraphQuaternionFromAxisAngleBlock:()=>M,FlowGraphQuaternionFromDirectionsBlock:()=>i,FlowGraphRotate2DBlock:()=>t,FlowGraphRotate3DBlock:()=>e,FlowGraphTransformBlock:()=>W,FlowGraphTransformCoordinatesBlock:()=>E});var b=d(14158),X=d(14126),P=d(12345),V=d(15608),R=d(15618),p=d(12403),j=d(14169),g=d(13823);const k="cachedOperationAxis",Z="cachedOperationAngle",U="cachedExecutionId";class A extends R.c{constructor(C){super(X.b,X.q,(C=>this._polymorphicLength(C)),"FlowGraphLengthBlock",C)}_polymorphicLength(C){switch((0,j.h)(C)){case"Vector2":case"dd":case"Vector4":case"Quaternion":return C.length();default:throw new Error(`Cannot compute length of value ${C}`)}}}(0,P.e)("FlowGraphLengthBlock",A);class u extends R.c{constructor(C){super(X.b,X.b,(C=>this._polymorphicNormalize(C)),"FlowGraphNormalizeBlock",C)}_polymorphicNormalize(C){var c;let d;switch((0,j.h)(C)){case"Vector2":case"dd":case"Vector4":case"Quaternion":if(d=C.normalizeToNew(),null!==(c=this.config)&&void 0!==c&&c.nanOnZeroLength){0===C.length()&&d.Hc(NaN)}return d;default:throw new Error(`Cannot normalize value ${C}`)}}}(0,P.e)("FlowGraphNormalizeBlock",u);class q extends V.d{constructor(C){super(X.b,X.b,X.q,((C,c)=>this._polymorphicDot(C,c)),"FlowGraphDotBlock",C)}_polymorphicDot(C,c){switch((0,j.h)(C)){case"Vector2":case"dd":case"Vector4":case"Quaternion":return C.dot(c);default:throw new Error(`Cannot get dot product of ${C} and ${c}`)}}}(0,P.e)("FlowGraphDotBlock",q);class B extends V.d{constructor(C){super(X.w,X.w,X.w,((C,c)=>p.dd.Cross(C,c)),"FlowGraphCrossBlock",C)}}(0,P.e)("FlowGraphCrossBlock",B);class t extends V.d{constructor(C){super(X.v,X.q,X.v,((C,c)=>C.rotate(c)),"FlowGraphRotate2DBlock",C)}}(0,P.e)("FlowGraphRotate2DBlock",t);class e extends V.d{constructor(C){super(X.w,X.r,X.w,((C,c)=>C.applyRotationQuaternion(c)),"FlowGraphRotate3DBlock",C)}}function n(C,c){switch((0,j.h)(C)){case"Vector2":case"dd":return c.transformVector(C);case"Vector4":return new p.Vector4(C.x*c.m[0]+C.y*c.m[1]+C.z*c.m[2]+C.w*c.m[3],C.x*c.m[4]+C.y*c.m[5]+C.z*c.m[6]+C.w*c.m[7],C.x*c.m[8]+C.y*c.m[9]+C.z*c.m[10]+C.w*c.m[11],C.x*c.m[12]+C.y*c.m[13]+C.z*c.m[14]+C.w*c.m[15]);default:throw new Error(`Cannot transform value ${C}`)}}(0,P.e)("FlowGraphRotate3DBlock",e);class W extends V.d{constructor(C){const c=(null===C||void 0===C?void 0:C.vectorType)||"dd",d="Vector2"===c?"Matrix2D":"dd"===c?"Matrix3D":"Matrix";super((0,X.H)(c),(0,X.H)(d),(0,X.H)(c),n,"FlowGraphTransformVectorBlock",C)}}(0,P.e)("FlowGraphTransformVectorBlock",W);class E extends V.d{constructor(C){super(X.w,X.l,X.w,((C,c)=>p.dd.TransformCoordinates(C,c)),"FlowGraphTransformCoordinatesBlock",C)}}(0,P.e)("FlowGraphTransformCoordinatesBlock",E);class N extends R.c{constructor(C){super(X.r,X.r,(C=>C.conjugate()),"FlowGraphConjugateBlock",C)}}(0,P.e)("FlowGraphConjugateBlock",N);class r extends V.d{constructor(C){super(X.r,X.r,X.q,((C,c)=>(0,g.d)(C,c)),"FlowGraphAngleBetweenBlock",C)}}(0,P.e)("FlowGraphAngleBetweenBlock",r);class M extends V.d{constructor(C){super(X.w,X.q,X.r,((C,c)=>p.Quaternion.RotationAxis(C,c)),"FlowGraphQuaternionFromAxisAngleBlock",C)}}(0,P.e)("FlowGraphQuaternionFromAxisAngleBlock",M);class K extends b.e{constructor(C){super(C),this.a=this.registerDataInput("a",X.r),this.axis=this.registerDataOutput("axis",X.w),this.angle=this.registerDataOutput("angle",X.q),this.isValid=this.registerDataOutput("isValid",X.e)}_updateOutputs(C){const c=C._getExecutionVariable(this,U,-1),d=C._getExecutionVariable(this,k,null),b=C._getExecutionVariable(this,Z,null);if(void 0!==d&&null!==d&&void 0!==b&&null!==b&&c===C.executionId)this.axis.setValue(d,C),this.angle.setValue(b,C);else try{const{axis:c,angle:d}=this.a.getValue(C).toAxisAngle();C._setExecutionVariable(this,k,c),C._setExecutionVariable(this,Z,d),C._setExecutionVariable(this,U,C.executionId),this.axis.setValue(c,C),this.angle.setValue(d,C),this.isValid.setValue(!0,C)}catch(X){this.isValid.setValue(!1,C)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,P.e)("FlowGraphAxisAngleFromQuaternionBlock",K);class i extends V.d{constructor(C){super(X.w,X.w,X.r,((C,c)=>(0,g.e)(C,c)),"FlowGraphQuaternionFromDirectionsBlock",C)}}},15608:(C,c,d)=>{d.d(c,{d:()=>X});var b=d(15611);class X extends b.e{constructor(C,c,d,b,X,P){super(d,P),this._operation=b,this._className=X,this.a=this.registerDataInput("a",C),this.b=this.registerDataInput("b",c)}_doOperation(C){const c=this.a.getValue(C),d=this.b.getValue(C);return this._operation(c,d)}getClassName(){return this._className}}},15611:(C,c,d)=>{d.d(c,{e:()=>R});var b=d(14158),X=d(14126);const P="cachedOperationValue",V="cachedExecutionId";class R extends b.e{constructor(C,c){super(c),this.value=this.registerDataOutput("value",C),this.isValid=this.registerDataOutput("isValid",X.e)}_updateOutputs(C){const c=C._getExecutionVariable(this,V,-1),d=C._getExecutionVariable(this,P,null);if(void 0!==d&&null!==d&&c===C.executionId)this.isValid.setValue(!0,C),this.value.setValue(d,C);else try{const c=this._doOperation(C);if(void 0===c||null===c)return void this.isValid.setValue(!1,C);C._setExecutionVariable(this,P,c),C._setExecutionVariable(this,V,C.executionId),this.value.setValue(c,C),this.isValid.setValue(!0,C)}catch(b){this.isValid.setValue(!1,C)}}}},15618:(C,c,d)=>{d.d(c,{c:()=>X});var b=d(15611);class X extends b.e{constructor(C,c,d,b,X){super(c,X),this._operation=d,this._className=b,this.a=this.registerDataInput("a",C)}_doOperation(C){return this._operation(this.a.getValue(C))}getClassName(){return this._className}}}}]);