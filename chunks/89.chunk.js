"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[89],{16014:(q,I,l)=>{l.r(I),l.d(I,{FlowGraphAngleBetweenBlock:()=>e,FlowGraphAxisAngleFromQuaternionBlock:()=>S,FlowGraphConjugateBlock:()=>W,FlowGraphCrossBlock:()=>U,FlowGraphDotBlock:()=>V,FlowGraphLengthBlock:()=>d,FlowGraphNormalizeBlock:()=>T,FlowGraphQuaternionFromAxisAngleBlock:()=>i,FlowGraphQuaternionFromDirectionsBlock:()=>g,FlowGraphRotate2DBlock:()=>B,FlowGraphRotate3DBlock:()=>v,FlowGraphTransformBlock:()=>C,FlowGraphTransformCoordinatesBlock:()=>R});var w=l(14457),t=l(14441),O=l(12711),c=l(16001),a=l(16010),F=l(12747),s=l(14473),Z=l(14130);const r="cachedOperationAxis",x="cachedOperationAngle",o="cachedExecutionId";class d extends a.d{constructor(q){super(t.e,t.v,(q=>this._polymorphicLength(q)),"FlowGraphLengthBlock",q)}_polymorphicLength(q){switch((0,s.n)(q)){case"Vector2":case"dI":case"Vector4":case"Quaternion":return q.length();default:throw new Error(`Cannot compute length of value ${q}`)}}}(0,O.e)("FlowGraphLengthBlock",d);class T extends a.d{constructor(q){super(t.e,t.e,(q=>this._polymorphicNormalize(q)),"FlowGraphNormalizeBlock",q)}_polymorphicNormalize(q){var I;let l;switch((0,s.n)(q)){case"Vector2":case"dI":case"Vector4":case"Quaternion":if(l=q.normalizeToNew(),null!==(I=this.config)&&void 0!==I&&I.nanOnZeroLength){0===q.length()&&l.Kc(NaN)}return l;default:throw new Error(`Cannot normalize value ${q}`)}}}(0,O.e)("FlowGraphNormalizeBlock",T);class V extends c.e{constructor(q){super(t.e,t.e,t.v,((q,I)=>this._polymorphicDot(q,I)),"FlowGraphDotBlock",q)}_polymorphicDot(q,I){switch((0,s.n)(q)){case"Vector2":case"dI":case"Vector4":case"Quaternion":return q.dot(I);default:throw new Error(`Cannot get dot product of ${q} and ${I}`)}}}(0,O.e)("FlowGraphDotBlock",V);class U extends c.e{constructor(q){super(t.F,t.F,t.F,((q,I)=>F.dI.Cross(q,I)),"FlowGraphCrossBlock",q)}}(0,O.e)("FlowGraphCrossBlock",U);class B extends c.e{constructor(q){super(t.E,t.v,t.E,((q,I)=>q.rotate(I)),"FlowGraphRotate2DBlock",q)}}(0,O.e)("FlowGraphRotate2DBlock",B);class v extends c.e{constructor(q){super(t.F,t.w,t.F,((q,I)=>q.applyRotationQuaternion(I)),"FlowGraphRotate3DBlock",q)}}function k(q,I){switch((0,s.n)(q)){case"Vector2":case"dI":return I.transformVector(q);case"Vector4":return new F.Vector4(q.x*I.m[0]+q.y*I.m[1]+q.z*I.m[2]+q.w*I.m[3],q.x*I.m[4]+q.y*I.m[5]+q.z*I.m[6]+q.w*I.m[7],q.x*I.m[8]+q.y*I.m[9]+q.z*I.m[10]+q.w*I.m[11],q.x*I.m[12]+q.y*I.m[13]+q.z*I.m[14]+q.w*I.m[15]);default:throw new Error(`Cannot transform value ${q}`)}}(0,O.e)("FlowGraphRotate3DBlock",v);class C extends c.e{constructor(q){const I=(null===q||void 0===q?void 0:q.vectorType)||"dI",l="Vector2"===I?"Matrix2D":"dI"===I?"Matrix3D":"Matrix";super((0,t.P)(I),(0,t.P)(l),(0,t.P)(I),k,"FlowGraphTransformVectorBlock",q)}}(0,O.e)("FlowGraphTransformVectorBlock",C);class R extends c.e{constructor(q){super(t.F,t.m,t.F,((q,I)=>F.dI.TransformCoordinates(q,I)),"FlowGraphTransformCoordinatesBlock",q)}}(0,O.e)("FlowGraphTransformCoordinatesBlock",R);class W extends a.d{constructor(q){super(t.w,t.w,(q=>q.conjugate()),"FlowGraphConjugateBlock",q)}}(0,O.e)("FlowGraphConjugateBlock",W);class e extends c.e{constructor(q){super(t.w,t.w,t.v,((q,I)=>(0,Z.c)(q,I)),"FlowGraphAngleBetweenBlock",q)}}(0,O.e)("FlowGraphAngleBetweenBlock",e);class i extends c.e{constructor(q){super(t.F,t.v,t.w,((q,I)=>F.Quaternion.RotationAxis(q,I)),"FlowGraphQuaternionFromAxisAngleBlock",q)}}(0,O.e)("FlowGraphQuaternionFromAxisAngleBlock",i);class S extends w.c{constructor(q){super(q),this.a=this.registerDataInput("a",t.w),this.axis=this.registerDataOutput("axis",t.F),this.angle=this.registerDataOutput("angle",t.v),this.isValid=this.registerDataOutput("isValid",t.g)}_updateOutputs(q){const I=q._getExecutionVariable(this,o,-1),l=q._getExecutionVariable(this,r,null),w=q._getExecutionVariable(this,x,null);if(void 0!==l&&null!==l&&void 0!==w&&null!==w&&I===q.executionId)this.axis.setValue(l,q),this.angle.setValue(w,q);else try{const{axis:I,angle:l}=this.a.getValue(q).toAxisAngle();q._setExecutionVariable(this,r,I),q._setExecutionVariable(this,x,l),q._setExecutionVariable(this,o,q.executionId),this.axis.setValue(I,q),this.angle.setValue(l,q),this.isValid.setValue(!0,q)}catch(t){this.isValid.setValue(!1,q)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,O.e)("FlowGraphAxisAngleFromQuaternionBlock",S);class g extends c.e{constructor(q){super(t.F,t.F,t.w,((q,I)=>(0,Z.e)(q,I)),"FlowGraphQuaternionFromDirectionsBlock",q)}}},16001:(q,I,l)=>{l.d(I,{e:()=>t});var w=l(16008);class t extends w.d{constructor(q,I,l,w,t,O){super(l,O),this._operation=w,this._className=t,this.a=this.registerDataInput("a",q),this.b=this.registerDataInput("b",I)}_doOperation(q){const I=this.a.getValue(q),l=this.b.getValue(q);return this._operation(I,l)}getClassName(){return this._className}}},16008:(q,I,l)=>{l.d(I,{d:()=>a});var w=l(14457),t=l(14441);const O="cachedOperationValue",c="cachedExecutionId";class a extends w.c{constructor(q,I){super(I),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",t.g)}_updateOutputs(q){const I=q._getExecutionVariable(this,c,-1),l=q._getExecutionVariable(this,O,null);if(void 0!==l&&null!==l&&I===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(l,q);else try{const I=this._doOperation(q);if(void 0===I||null===I)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,O,I),q._setExecutionVariable(this,c,q.executionId),this.value.setValue(I,q),this.isValid.setValue(!0,q)}catch(w){this.isValid.setValue(!1,q)}}}},16010:(q,I,l)=>{l.d(I,{d:()=>t});var w=l(16008);class t extends w.d{constructor(q,I,l,w,t){super(I,t),this._operation=l,this._className=w,this.a=this.registerDataInput("a",q)}_doOperation(q){return this._operation(this.a.getValue(q))}getClassName(){return this._className}}}}]);