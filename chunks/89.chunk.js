"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[89],{16169:(h,R,l)=>{l.r(R),l.d(R,{FlowGraphAngleBetweenBlock:()=>O,FlowGraphAxisAngleFromQuaternionBlock:()=>v,FlowGraphConjugateBlock:()=>p,FlowGraphCrossBlock:()=>t,FlowGraphDotBlock:()=>s,FlowGraphLengthBlock:()=>Q,FlowGraphNormalizeBlock:()=>Y,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>b,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>x,FlowGraphTransformCoordinatesBlock:()=>G});var j=l(14620),a=l(14597),D=l(12852),U=l(16157),F=l(16166),w=l(12900),mh=l(14629),u=l(14295);const c="cachedOperationAxis",J="cachedOperationAngle",q="cachedExecutionId";class Q extends F.d{constructor(h){super(a.c,a.r,(h=>this._polymorphicLength(h)),"FlowGraphLengthBlock",h)}_polymorphicLength(h){switch((0,mh.k)(h)){case"Vector2":case"tR":case"Vector4":case"Quaternion":return h.length();default:throw new Error(`Cannot compute length of value ${h}`)}}}(0,D.f)("FlowGraphLengthBlock",Q);class Y extends F.d{constructor(h){super(a.c,a.c,(h=>this._polymorphicNormalize(h)),"FlowGraphNormalizeBlock",h)}_polymorphicNormalize(h){var R;let l;switch((0,mh.k)(h)){case"Vector2":case"tR":case"Vector4":case"Quaternion":if(l=h.normalizeToNew(),null!==(R=this.config)&&void 0!==R&&R.nanOnZeroLength){0===h.length()&&l.vF(NaN)}return l;default:throw new Error(`Cannot normalize value ${h}`)}}}(0,D.f)("FlowGraphNormalizeBlock",Y);class s extends U.d{constructor(h){super(a.c,a.c,a.r,((h,R)=>this._polymorphicDot(h,R)),"FlowGraphDotBlock",h)}_polymorphicDot(h,R){switch((0,mh.k)(h)){case"Vector2":case"tR":case"Vector4":case"Quaternion":return h.dot(R);default:throw new Error(`Cannot get dot product of ${h} and ${R}`)}}}(0,D.f)("FlowGraphDotBlock",s);class t extends U.d{constructor(h){super(a.D,a.D,a.D,((h,R)=>w.tR.Cross(h,R)),"FlowGraphCrossBlock",h)}}(0,D.f)("FlowGraphCrossBlock",t);class f extends U.d{constructor(h){super(a.z,a.r,a.z,((h,R)=>h.rotate(R)),"FlowGraphRotate2DBlock",h)}}(0,D.f)("FlowGraphRotate2DBlock",f);class T extends U.d{constructor(h){super(a.D,a.s,a.D,((h,R)=>h.applyRotationQuaternion(R)),"FlowGraphRotate3DBlock",h)}}function E(h,R){switch((0,mh.k)(h)){case"Vector2":case"tR":return R.transformVector(h);case"Vector4":return new w.Vector4(h.x*R.m[0]+h.y*R.m[1]+h.z*R.m[2]+h.w*R.m[3],h.x*R.m[4]+h.y*R.m[5]+h.z*R.m[6]+h.w*R.m[7],h.x*R.m[8]+h.y*R.m[9]+h.z*R.m[10]+h.w*R.m[11],h.x*R.m[12]+h.y*R.m[13]+h.z*R.m[14]+h.w*R.m[15]);default:throw new Error(`Cannot transform value ${h}`)}}(0,D.f)("FlowGraphRotate3DBlock",T);class x extends U.d{constructor(h){const R=(null===h||void 0===h?void 0:h.vectorType)||"tR",l="Vector2"===R?"Matrix2D":"tR"===R?"Matrix3D":"Matrix";super((0,a.L)(R),(0,a.L)(l),(0,a.L)(R),E,"FlowGraphTransformVectorBlock",h)}}(0,D.f)("FlowGraphTransformVectorBlock",x);class G extends U.d{constructor(h){super(a.D,a.j,a.D,((h,R)=>w.tR.TransformCoordinates(h,R)),"FlowGraphTransformCoordinatesBlock",h)}}(0,D.f)("FlowGraphTransformCoordinatesBlock",G);class p extends F.d{constructor(h){super(a.s,a.s,(h=>h.conjugate()),"FlowGraphConjugateBlock",h)}}(0,D.f)("FlowGraphConjugateBlock",p);class O extends U.d{constructor(h){super(a.s,a.s,a.r,((h,R)=>(0,u.c)(h,R)),"FlowGraphAngleBetweenBlock",h)}}(0,D.f)("FlowGraphAngleBetweenBlock",O);class y extends U.d{constructor(h){super(a.D,a.r,a.s,((h,R)=>w.Quaternion.RotationAxis(h,R)),"FlowGraphQuaternionFromAxisAngleBlock",h)}}(0,D.f)("FlowGraphQuaternionFromAxisAngleBlock",y);class v extends j.e{constructor(h){super(h),this.a=this.registerDataInput("a",a.s),this.axis=this.registerDataOutput("axis",a.D),this.angle=this.registerDataOutput("angle",a.r),this.isValid=this.registerDataOutput("isValid",a.g)}_updateOutputs(h){const R=h._getExecutionVariable(this,q,-1),l=h._getExecutionVariable(this,c,null),j=h._getExecutionVariable(this,J,null);if(void 0!==l&&null!==l&&void 0!==j&&null!==j&&R===h.executionId)this.axis.setValue(l,h),this.angle.setValue(j,h);else try{const{axis:R,angle:l}=this.a.getValue(h).toAxisAngle();h._setExecutionVariable(this,c,R),h._setExecutionVariable(this,J,l),h._setExecutionVariable(this,q,h.executionId),this.axis.setValue(R,h),this.angle.setValue(l,h),this.isValid.setValue(!0,h)}catch(a){this.isValid.setValue(!1,h)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,D.f)("FlowGraphAxisAngleFromQuaternionBlock",v);class b extends U.d{constructor(h){super(a.D,a.D,a.s,((h,R)=>(0,u.g)(h,R)),"FlowGraphQuaternionFromDirectionsBlock",h)}}},16157:(h,R,l)=>{l.d(R,{d:()=>a});var j=l(16163);class a extends j.d{constructor(h,R,l,j,a,D){super(l,D),this._operation=j,this._className=a,this.a=this.registerDataInput("a",h),this.b=this.registerDataInput("b",R)}_doOperation(h){const R=this.a.getValue(h),l=this.b.getValue(h);return this._operation(R,l)}getClassName(){return this._className}}},16163:(h,R,l)=>{l.d(R,{d:()=>F});var j=l(14620),a=l(14597);const D="cachedOperationValue",U="cachedExecutionId";class F extends j.e{constructor(h,R){super(R),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",a.g)}_updateOutputs(h){const R=h._getExecutionVariable(this,U,-1),l=h._getExecutionVariable(this,D,null);if(void 0!==l&&null!==l&&R===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(l,h);else try{const R=this._doOperation(h);if(void 0===R||null===R)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,D,R),h._setExecutionVariable(this,U,h.executionId),this.value.setValue(R,h),this.isValid.setValue(!0,h)}catch(j){this.isValid.setValue(!1,h)}}}},16166:(h,R,l)=>{l.d(R,{d:()=>a});var j=l(16163);class a extends j.d{constructor(h,R,l,j,a){super(R,a),this._operation=l,this._className=j,this.a=this.registerDataInput("a",h)}_doOperation(h){return this._operation(this.a.getValue(h))}getClassName(){return this._className}}}}]);