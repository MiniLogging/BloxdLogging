"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[89],{14474:(G,A,j)=>{j.r(A),j.d(A,{FlowGraphAngleBetweenBlock:()=>g,FlowGraphAxisAngleFromQuaternionBlock:()=>E,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>t,FlowGraphDotBlock:()=>C,FlowGraphLengthBlock:()=>U,FlowGraphNormalizeBlock:()=>S,FlowGraphQuaternionFromAxisAngleBlock:()=>c,FlowGraphQuaternionFromDirectionsBlock:()=>r,FlowGraphRotate2DBlock:()=>Y,FlowGraphRotate3DBlock:()=>n,FlowGraphTransformBlock:()=>X,FlowGraphTransformCoordinatesBlock:()=>I});var u=j(12905),k=j(12880),B=j(11181),x=j(14459),s=j(14471),O=j(11218),d=j(12916),h=j(12562);const H="cachedOperationAxis",F="cachedOperationAngle",R="cachedExecutionId";class U extends s.b{constructor(G){super(k.c,k.s,(G=>this._polymorphicLength(G)),"FlowGraphLengthBlock",G)}_polymorphicLength(G){switch((0,d.l)(G)){case"Vector2":case"SA":case"Vector4":case"Quaternion":return G.length();default:throw new Error(`Cannot compute length of value ${G}`)}}}(0,B.h)("FlowGraphLengthBlock",U);class S extends s.b{constructor(G){super(k.c,k.c,(G=>this._polymorphicNormalize(G)),"FlowGraphNormalizeBlock",G)}_polymorphicNormalize(G){var A;let j;switch((0,d.l)(G)){case"Vector2":case"SA":case"Vector4":case"Quaternion":if(j=G.normalizeToNew(),null!==(A=this.config)&&void 0!==A&&A.nanOnZeroLength){0===G.length()&&j.Qs(NaN)}return j;default:throw new Error(`Cannot normalize value ${G}`)}}}(0,B.h)("FlowGraphNormalizeBlock",S);class C extends x.c{constructor(G){super(k.c,k.c,k.s,((G,A)=>this._polymorphicDot(G,A)),"FlowGraphDotBlock",G)}_polymorphicDot(G,A){switch((0,d.l)(G)){case"Vector2":case"SA":case"Vector4":case"Quaternion":return G.dot(A);default:throw new Error(`Cannot get dot product of ${G} and ${A}`)}}}(0,B.h)("FlowGraphDotBlock",C);class t extends x.c{constructor(G){super(k.C,k.C,k.C,((G,A)=>O.SA.Cross(G,A)),"FlowGraphCrossBlock",G)}}(0,B.h)("FlowGraphCrossBlock",t);class Y extends x.c{constructor(G){super(k.z,k.s,k.z,((G,A)=>G.rotate(A)),"FlowGraphRotate2DBlock",G)}}(0,B.h)("FlowGraphRotate2DBlock",Y);class n extends x.c{constructor(G){super(k.C,k.u,k.C,((G,A)=>G.applyRotationQuaternion(A)),"FlowGraphRotate3DBlock",G)}}function Q(G,A){switch((0,d.l)(G)){case"Vector2":case"SA":return A.transformVector(G);case"Vector4":return new O.Vector4(G.x*A.m[0]+G.y*A.m[1]+G.z*A.m[2]+G.w*A.m[3],G.x*A.m[4]+G.y*A.m[5]+G.z*A.m[6]+G.w*A.m[7],G.x*A.m[8]+G.y*A.m[9]+G.z*A.m[10]+G.w*A.m[11],G.x*A.m[12]+G.y*A.m[13]+G.z*A.m[14]+G.w*A.m[15]);default:throw new Error(`Cannot transform value ${G}`)}}(0,B.h)("FlowGraphRotate3DBlock",n);class X extends x.c{constructor(G){const A=(null===G||void 0===G?void 0:G.vectorType)||"SA",j="Vector2"===A?"Matrix2D":"SA"===A?"Matrix3D":"Matrix";super((0,k.L)(A),(0,k.L)(j),(0,k.L)(A),Q,"FlowGraphTransformVectorBlock",G)}}(0,B.h)("FlowGraphTransformVectorBlock",X);class I extends x.c{constructor(G){super(k.C,k.j,k.C,((G,A)=>O.SA.TransformCoordinates(G,A)),"FlowGraphTransformCoordinatesBlock",G)}}(0,B.h)("FlowGraphTransformCoordinatesBlock",I);class D extends s.b{constructor(G){super(k.u,k.u,(G=>G.conjugate()),"FlowGraphConjugateBlock",G)}}(0,B.h)("FlowGraphConjugateBlock",D);class g extends x.c{constructor(G){super(k.u,k.u,k.s,((G,A)=>(0,h.e)(G,A)),"FlowGraphAngleBetweenBlock",G)}}(0,B.h)("FlowGraphAngleBetweenBlock",g);class c extends x.c{constructor(G){super(k.C,k.s,k.u,((G,A)=>O.Quaternion.RotationAxis(G,A)),"FlowGraphQuaternionFromAxisAngleBlock",G)}}(0,B.h)("FlowGraphQuaternionFromAxisAngleBlock",c);class E extends u.c{constructor(G){super(G),this.a=this.registerDataInput("a",k.u),this.axis=this.registerDataOutput("axis",k.C),this.angle=this.registerDataOutput("angle",k.s),this.isValid=this.registerDataOutput("isValid",k.e)}_updateOutputs(G){const A=G._getExecutionVariable(this,R,-1),j=G._getExecutionVariable(this,H,null),u=G._getExecutionVariable(this,F,null);if(void 0!==j&&null!==j&&void 0!==u&&null!==u&&A===G.executionId)this.axis.setValue(j,G),this.angle.setValue(u,G);else try{const{axis:A,angle:j}=this.a.getValue(G).toAxisAngle();G._setExecutionVariable(this,H,A),G._setExecutionVariable(this,F,j),G._setExecutionVariable(this,R,G.executionId),this.axis.setValue(A,G),this.angle.setValue(j,G),this.isValid.setValue(!0,G)}catch(k){this.isValid.setValue(!1,G)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,B.h)("FlowGraphAxisAngleFromQuaternionBlock",E);class r extends x.c{constructor(G){super(k.C,k.C,k.u,((G,A)=>(0,h.f)(G,A)),"FlowGraphQuaternionFromDirectionsBlock",G)}}},14459:(G,A,j)=>{j.d(A,{c:()=>k});var u=j(14465);class k extends u.c{constructor(G,A,j,u,k,B){super(j,B),this._operation=u,this._className=k,this.a=this.registerDataInput("a",G),this.b=this.registerDataInput("b",A)}_doOperation(G){const A=this.a.getValue(G),j=this.b.getValue(G);return this._operation(A,j)}getClassName(){return this._className}}},14465:(G,A,j)=>{j.d(A,{c:()=>s});var u=j(12905),k=j(12880);const B="cachedOperationValue",x="cachedExecutionId";class s extends u.c{constructor(G,A){super(A),this.value=this.registerDataOutput("value",G),this.isValid=this.registerDataOutput("isValid",k.e)}_updateOutputs(G){const A=G._getExecutionVariable(this,x,-1),j=G._getExecutionVariable(this,B,null);if(void 0!==j&&null!==j&&A===G.executionId)this.isValid.setValue(!0,G),this.value.setValue(j,G);else try{const A=this._doOperation(G);if(void 0===A||null===A)return void this.isValid.setValue(!1,G);G._setExecutionVariable(this,B,A),G._setExecutionVariable(this,x,G.executionId),this.value.setValue(A,G),this.isValid.setValue(!0,G)}catch(u){this.isValid.setValue(!1,G)}}}},14471:(G,A,j)=>{j.d(A,{b:()=>k});var u=j(14465);class k extends u.c{constructor(G,A,j,u,k){super(A,k),this._operation=j,this._className=u,this.a=this.registerDataInput("a",G)}_doOperation(G){return this._operation(this.a.getValue(G))}getClassName(){return this._className}}}}]);