"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[89],{14785:(w,E,G)=>{G.r(E),G.d(E,{FlowGraphAngleBetweenBlock:()=>T,FlowGraphAxisAngleFromQuaternionBlock:()=>j,FlowGraphConjugateBlock:()=>W,FlowGraphCrossBlock:()=>Z,FlowGraphDotBlock:()=>c,FlowGraphLengthBlock:()=>a,FlowGraphNormalizeBlock:()=>Q,FlowGraphQuaternionFromAxisAngleBlock:()=>I,FlowGraphQuaternionFromDirectionsBlock:()=>g,FlowGraphRotate2DBlock:()=>J,FlowGraphRotate3DBlock:()=>d,FlowGraphTransformBlock:()=>t,FlowGraphTransformCoordinatesBlock:()=>q});var P=G(13298),h=G(13281),B=G(11646),y=G(14769),x=G(14780),U=G(11679),l=G(13306),i=G(12985);const O="cachedOperationAxis",u="cachedOperationAngle",V="cachedExecutionId";class a extends x.d{constructor(w){super(h.c,h.r,(w=>this._polymorphicLength(w)),"FlowGraphLengthBlock",w)}_polymorphicLength(w){switch((0,l.l)(w)){case"Vector2":case"QE":case"Vector4":case"Quaternion":return w.length();default:throw new Error(`Cannot compute length of value ${w}`)}}}(0,B.g)("FlowGraphLengthBlock",a);class Q extends x.d{constructor(w){super(h.c,h.c,(w=>this._polymorphicNormalize(w)),"FlowGraphNormalizeBlock",w)}_polymorphicNormalize(w){var E;let G;switch((0,l.l)(w)){case"Vector2":case"QE":case"Vector4":case"Quaternion":if(G=w.normalizeToNew(),null!==(E=this.config)&&void 0!==E&&E.nanOnZeroLength){0===w.length()&&G.Wx(NaN)}return G;default:throw new Error(`Cannot normalize value ${w}`)}}}(0,B.g)("FlowGraphNormalizeBlock",Q);class c extends y.c{constructor(w){super(h.c,h.c,h.r,((w,E)=>this._polymorphicDot(w,E)),"FlowGraphDotBlock",w)}_polymorphicDot(w,E){switch((0,l.l)(w)){case"Vector2":case"QE":case"Vector4":case"Quaternion":return w.dot(E);default:throw new Error(`Cannot get dot product of ${w} and ${E}`)}}}(0,B.g)("FlowGraphDotBlock",c);class Z extends y.c{constructor(w){super(h.z,h.z,h.z,((w,E)=>U.QE.Cross(w,E)),"FlowGraphCrossBlock",w)}}(0,B.g)("FlowGraphCrossBlock",Z);class J extends y.c{constructor(w){super(h.x,h.r,h.x,((w,E)=>w.rotate(E)),"FlowGraphRotate2DBlock",w)}}(0,B.g)("FlowGraphRotate2DBlock",J);class d extends y.c{constructor(w){super(h.z,h.t,h.z,((w,E)=>w.applyRotationQuaternion(E)),"FlowGraphRotate3DBlock",w)}}function K(w,E){switch((0,l.l)(w)){case"Vector2":case"QE":return E.transformVector(w);case"Vector4":return new U.Vector4(w.x*E.m[0]+w.y*E.m[1]+w.z*E.m[2]+w.w*E.m[3],w.x*E.m[4]+w.y*E.m[5]+w.z*E.m[6]+w.w*E.m[7],w.x*E.m[8]+w.y*E.m[9]+w.z*E.m[10]+w.w*E.m[11],w.x*E.m[12]+w.y*E.m[13]+w.z*E.m[14]+w.w*E.m[15]);default:throw new Error(`Cannot transform value ${w}`)}}(0,B.g)("FlowGraphRotate3DBlock",d);class t extends y.c{constructor(w){const E=(null===w||void 0===w?void 0:w.vectorType)||"QE",G="Vector2"===E?"Matrix2D":"QE"===E?"Matrix3D":"Matrix";super((0,h.K)(E),(0,h.K)(G),(0,h.K)(E),K,"FlowGraphTransformVectorBlock",w)}}(0,B.g)("FlowGraphTransformVectorBlock",t);class q extends y.c{constructor(w){super(h.z,h.j,h.z,((w,E)=>U.QE.TransformCoordinates(w,E)),"FlowGraphTransformCoordinatesBlock",w)}}(0,B.g)("FlowGraphTransformCoordinatesBlock",q);class W extends x.d{constructor(w){super(h.t,h.t,(w=>w.conjugate()),"FlowGraphConjugateBlock",w)}}(0,B.g)("FlowGraphConjugateBlock",W);class T extends y.c{constructor(w){super(h.t,h.t,h.r,((w,E)=>(0,i.d)(w,E)),"FlowGraphAngleBetweenBlock",w)}}(0,B.g)("FlowGraphAngleBetweenBlock",T);class I extends y.c{constructor(w){super(h.z,h.r,h.t,((w,E)=>U.Quaternion.RotationAxis(w,E)),"FlowGraphQuaternionFromAxisAngleBlock",w)}}(0,B.g)("FlowGraphQuaternionFromAxisAngleBlock",I);class j extends P.d{constructor(w){super(w),this.a=this.registerDataInput("a",h.t),this.axis=this.registerDataOutput("axis",h.z),this.angle=this.registerDataOutput("angle",h.r),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(w){const E=w._getExecutionVariable(this,V,-1),G=w._getExecutionVariable(this,O,null),P=w._getExecutionVariable(this,u,null);if(void 0!==G&&null!==G&&void 0!==P&&null!==P&&E===w.executionId)this.axis.setValue(G,w),this.angle.setValue(P,w);else try{const{axis:E,angle:G}=this.a.getValue(w).toAxisAngle();w._setExecutionVariable(this,O,E),w._setExecutionVariable(this,u,G),w._setExecutionVariable(this,V,w.executionId),this.axis.setValue(E,w),this.angle.setValue(G,w),this.isValid.setValue(!0,w)}catch(h){this.isValid.setValue(!1,w)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,B.g)("FlowGraphAxisAngleFromQuaternionBlock",j);class g extends y.c{constructor(w){super(h.z,h.z,h.t,((w,E)=>(0,i.g)(w,E)),"FlowGraphQuaternionFromDirectionsBlock",w)}}},14769:(w,E,G)=>{G.d(E,{c:()=>h});var P=G(14776);class h extends P.e{constructor(w,E,G,P,h,B){super(G,B),this._operation=P,this._className=h,this.a=this.registerDataInput("a",w),this.b=this.registerDataInput("b",E)}_doOperation(w){const E=this.a.getValue(w),G=this.b.getValue(w);return this._operation(E,G)}getClassName(){return this._className}}},14776:(w,E,G)=>{G.d(E,{e:()=>x});var P=G(13298),h=G(13281);const B="cachedOperationValue",y="cachedExecutionId";class x extends P.d{constructor(w,E){super(E),this.value=this.registerDataOutput("value",w),this.isValid=this.registerDataOutput("isValid",h.g)}_updateOutputs(w){const E=w._getExecutionVariable(this,y,-1),G=w._getExecutionVariable(this,B,null);if(void 0!==G&&null!==G&&E===w.executionId)this.isValid.setValue(!0,w),this.value.setValue(G,w);else try{const E=this._doOperation(w);if(void 0===E||null===E)return void this.isValid.setValue(!1,w);w._setExecutionVariable(this,B,E),w._setExecutionVariable(this,y,w.executionId),this.value.setValue(E,w),this.isValid.setValue(!0,w)}catch(P){this.isValid.setValue(!1,w)}}}},14780:(w,E,G)=>{G.d(E,{d:()=>h});var P=G(14776);class h extends P.e{constructor(w,E,G,P,h){super(E,h),this._operation=G,this._className=P,this.a=this.registerDataInput("a",w)}_doOperation(w){return this._operation(this.a.getValue(w))}getClassName(){return this._className}}}}]);