"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[89],{15002:(C,U,K)=>{K.r(U),K.d(U,{FlowGraphAngleBetweenBlock:()=>T,FlowGraphAxisAngleFromQuaternionBlock:()=>a,FlowGraphConjugateBlock:()=>d,FlowGraphCrossBlock:()=>V,FlowGraphDotBlock:()=>Q,FlowGraphLengthBlock:()=>b,FlowGraphNormalizeBlock:()=>v,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>r,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>F,FlowGraphTransformBlock:()=>P,FlowGraphTransformCoordinatesBlock:()=>H});var m=K(13539),O=K(13514),X=K(11789),A=K(14986),e=K(14994),t=K(11827),z=K(13552),j=K(13187);const p="cachedOperationAxis",E="cachedOperationAngle",u="cachedExecutionId";class b extends e.d{constructor(C){super(O.c,O.w,(C=>this._polymorphicLength(C)),"FlowGraphLengthBlock",C)}_polymorphicLength(C){switch((0,z.k)(C)){case"Vector2":case"bU":case"Vector4":case"Quaternion":return C.length();default:throw new Error(`Cannot compute length of value ${C}`)}}}(0,X.h)("FlowGraphLengthBlock",b);class v extends e.d{constructor(C){super(O.c,O.c,(C=>this._polymorphicNormalize(C)),"FlowGraphNormalizeBlock",C)}_polymorphicNormalize(C){var U;let K;switch((0,z.k)(C)){case"Vector2":case"bU":case"Vector4":case"Quaternion":if(K=C.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===C.length()&&K.be(NaN)}return K;default:throw new Error(`Cannot normalize value ${C}`)}}}(0,X.h)("FlowGraphNormalizeBlock",v);class Q extends A.b{constructor(C){super(O.c,O.c,O.w,((C,U)=>this._polymorphicDot(C,U)),"FlowGraphDotBlock",C)}_polymorphicDot(C,U){switch((0,z.k)(C)){case"Vector2":case"bU":case"Vector4":case"Quaternion":return C.dot(U);default:throw new Error(`Cannot get dot product of ${C} and ${U}`)}}}(0,X.h)("FlowGraphDotBlock",Q);class V extends A.b{constructor(C){super(O.E,O.E,O.E,((C,U)=>t.bU.Cross(C,U)),"FlowGraphCrossBlock",C)}}(0,X.h)("FlowGraphCrossBlock",V);class f extends A.b{constructor(C){super(O.A,O.w,O.A,((C,U)=>C.rotate(U)),"FlowGraphRotate2DBlock",C)}}(0,X.h)("FlowGraphRotate2DBlock",f);class F extends A.b{constructor(C){super(O.E,O.x,O.E,((C,U)=>C.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",C)}}function Z(C,U){switch((0,z.k)(C)){case"Vector2":case"bU":return U.transformVector(C);case"Vector4":return new t.Vector4(C.x*U.m[0]+C.y*U.m[1]+C.z*U.m[2]+C.w*U.m[3],C.x*U.m[4]+C.y*U.m[5]+C.z*U.m[6]+C.w*U.m[7],C.x*U.m[8]+C.y*U.m[9]+C.z*U.m[10]+C.w*U.m[11],C.x*U.m[12]+C.y*U.m[13]+C.z*U.m[14]+C.w*U.m[15]);default:throw new Error(`Cannot transform value ${C}`)}}(0,X.h)("FlowGraphRotate3DBlock",F);class P extends A.b{constructor(C){const U=(null===C||void 0===C?void 0:C.vectorType)||"bU",K="Vector2"===U?"Matrix2D":"bU"===U?"Matrix3D":"Matrix";super((0,O.M)(U),(0,O.M)(K),(0,O.M)(U),Z,"FlowGraphTransformVectorBlock",C)}}(0,X.h)("FlowGraphTransformVectorBlock",P);class H extends A.b{constructor(C){super(O.E,O.m,O.E,((C,U)=>t.bU.TransformCoordinates(C,U)),"FlowGraphTransformCoordinatesBlock",C)}}(0,X.h)("FlowGraphTransformCoordinatesBlock",H);class d extends e.d{constructor(C){super(O.x,O.x,(C=>C.conjugate()),"FlowGraphConjugateBlock",C)}}(0,X.h)("FlowGraphConjugateBlock",d);class T extends A.b{constructor(C){super(O.x,O.x,O.w,((C,U)=>(0,j.b)(C,U)),"FlowGraphAngleBetweenBlock",C)}}(0,X.h)("FlowGraphAngleBetweenBlock",T);class y extends A.b{constructor(C){super(O.E,O.w,O.x,((C,U)=>t.Quaternion.RotationAxis(C,U)),"FlowGraphQuaternionFromAxisAngleBlock",C)}}(0,X.h)("FlowGraphQuaternionFromAxisAngleBlock",y);class a extends m.e{constructor(C){super(C),this.a=this.registerDataInput("a",O.x),this.axis=this.registerDataOutput("axis",O.E),this.angle=this.registerDataOutput("angle",O.w),this.isValid=this.registerDataOutput("isValid",O.f)}_updateOutputs(C){const U=C._getExecutionVariable(this,u,-1),K=C._getExecutionVariable(this,p,null),m=C._getExecutionVariable(this,E,null);if(void 0!==K&&null!==K&&void 0!==m&&null!==m&&U===C.executionId)this.axis.setValue(K,C),this.angle.setValue(m,C);else try{const{axis:U,angle:K}=this.a.getValue(C).toAxisAngle();C._setExecutionVariable(this,p,U),C._setExecutionVariable(this,E,K),C._setExecutionVariable(this,u,C.executionId),this.axis.setValue(U,C),this.angle.setValue(K,C),this.isValid.setValue(!0,C)}catch(O){this.isValid.setValue(!1,C)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,X.h)("FlowGraphAxisAngleFromQuaternionBlock",a);class r extends A.b{constructor(C){super(O.E,O.E,O.x,((C,U)=>(0,j.d)(C,U)),"FlowGraphQuaternionFromDirectionsBlock",C)}}},14986:(C,U,K)=>{K.d(U,{b:()=>O});var m=K(14989);class O extends m.b{constructor(C,U,K,m,O,X){super(K,X),this._operation=m,this._className=O,this.a=this.registerDataInput("a",C),this.b=this.registerDataInput("b",U)}_doOperation(C){const U=this.a.getValue(C),K=this.b.getValue(C);return this._operation(U,K)}getClassName(){return this._className}}},14989:(C,U,K)=>{K.d(U,{b:()=>e});var m=K(13539),O=K(13514);const X="cachedOperationValue",A="cachedExecutionId";class e extends m.e{constructor(C,U){super(U),this.value=this.registerDataOutput("value",C),this.isValid=this.registerDataOutput("isValid",O.f)}_updateOutputs(C){const U=C._getExecutionVariable(this,A,-1),K=C._getExecutionVariable(this,X,null);if(void 0!==K&&null!==K&&U===C.executionId)this.isValid.setValue(!0,C),this.value.setValue(K,C);else try{const U=this._doOperation(C);if(void 0===U||null===U)return void this.isValid.setValue(!1,C);C._setExecutionVariable(this,X,U),C._setExecutionVariable(this,A,C.executionId),this.value.setValue(U,C),this.isValid.setValue(!0,C)}catch(m){this.isValid.setValue(!1,C)}}}},14994:(C,U,K)=>{K.d(U,{d:()=>O});var m=K(14989);class O extends m.b{constructor(C,U,K,m,O){super(U,O),this._operation=K,this._className=m,this.a=this.registerDataInput("a",C)}_doOperation(C){return this._operation(this.a.getValue(C))}getClassName(){return this._className}}}}]);