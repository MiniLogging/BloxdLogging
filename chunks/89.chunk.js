"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[89],{16087:(I,x,L)=>{L.r(x),L.d(x,{FlowGraphAngleBetweenBlock:()=>f,FlowGraphAxisAngleFromQuaternionBlock:()=>n,FlowGraphConjugateBlock:()=>t,FlowGraphCrossBlock:()=>s,FlowGraphDotBlock:()=>H,FlowGraphLengthBlock:()=>v,FlowGraphNormalizeBlock:()=>z,FlowGraphQuaternionFromAxisAngleBlock:()=>R,FlowGraphQuaternionFromDirectionsBlock:()=>P,FlowGraphRotate2DBlock:()=>U,FlowGraphRotate3DBlock:()=>q,FlowGraphTransformBlock:()=>T,FlowGraphTransformCoordinatesBlock:()=>Z});var F=L(14514),X=L(14498),G=L(12938),Y=L(16075),p=L(16084),B=L(12983),l=L(14522),W=L(14193);const Q="cachedOperationAxis",e="cachedOperationAngle",g="cachedExecutionId";class v extends p.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicLength(I)),"FlowGraphLengthBlock",I)}_polymorphicLength(I){switch((0,l.m)(I)){case"Vector2":case"sx":case"Vector4":case"Quaternion":return I.length();default:throw new Error(`Cannot compute length of value ${I}`)}}}(0,G.d)("FlowGraphLengthBlock",v);class z extends p.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicNormalize(I)),"FlowGraphNormalizeBlock",I)}_polymorphicNormalize(I){var x;let L;switch((0,l.m)(I)){case"Vector2":case"sx":case"Vector4":case"Quaternion":if(L=I.normalizeToNew(),null!==(x=this.config)&&void 0!==x&&x.nanOnZeroLength){0===I.length()&&L.BB(NaN)}return L;default:throw new Error(`Cannot normalize value ${I}`)}}}(0,G.d)("FlowGraphNormalizeBlock",z);class H extends Y.c{constructor(I){super(X.e,X.e,X.x,((I,x)=>this._polymorphicDot(I,x)),"FlowGraphDotBlock",I)}_polymorphicDot(I,x){switch((0,l.m)(I)){case"Vector2":case"sx":case"Vector4":case"Quaternion":return I.dot(x);default:throw new Error(`Cannot get dot product of ${I} and ${x}`)}}}(0,G.d)("FlowGraphDotBlock",H);class s extends Y.c{constructor(I){super(X.K,X.K,X.K,((I,x)=>B.sx.Cross(I,x)),"FlowGraphCrossBlock",I)}}(0,G.d)("FlowGraphCrossBlock",s);class U extends Y.c{constructor(I){super(X.H,X.x,X.H,((I,x)=>I.rotate(x)),"FlowGraphRotate2DBlock",I)}}(0,G.d)("FlowGraphRotate2DBlock",U);class q extends Y.c{constructor(I){super(X.K,X.B,X.K,((I,x)=>I.applyRotationQuaternion(x)),"FlowGraphRotate3DBlock",I)}}function y(I,x){switch((0,l.m)(I)){case"Vector2":case"sx":return x.transformVector(I);case"Vector4":return new B.Vector4(I.x*x.m[0]+I.y*x.m[1]+I.z*x.m[2]+I.w*x.m[3],I.x*x.m[4]+I.y*x.m[5]+I.z*x.m[6]+I.w*x.m[7],I.x*x.m[8]+I.y*x.m[9]+I.z*x.m[10]+I.w*x.m[11],I.x*x.m[12]+I.y*x.m[13]+I.z*x.m[14]+I.w*x.m[15]);default:throw new Error(`Cannot transform value ${I}`)}}(0,G.d)("FlowGraphRotate3DBlock",q);class T extends Y.c{constructor(I){const x=(null===I||void 0===I?void 0:I.vectorType)||"sx",L="Vector2"===x?"Matrix2D":"sx"===x?"Matrix3D":"Matrix";super((0,X.S)(x),(0,X.S)(L),(0,X.S)(x),y,"FlowGraphTransformVectorBlock",I)}}(0,G.d)("FlowGraphTransformVectorBlock",T);class Z extends Y.c{constructor(I){super(X.K,X.p,X.K,((I,x)=>B.sx.TransformCoordinates(I,x)),"FlowGraphTransformCoordinatesBlock",I)}}(0,G.d)("FlowGraphTransformCoordinatesBlock",Z);class t extends p.c{constructor(I){super(X.B,X.B,(I=>I.conjugate()),"FlowGraphConjugateBlock",I)}}(0,G.d)("FlowGraphConjugateBlock",t);class f extends Y.c{constructor(I){super(X.B,X.B,X.x,((I,x)=>(0,W.e)(I,x)),"FlowGraphAngleBetweenBlock",I)}}(0,G.d)("FlowGraphAngleBetweenBlock",f);class R extends Y.c{constructor(I){super(X.K,X.x,X.B,((I,x)=>B.Quaternion.RotationAxis(I,x)),"FlowGraphQuaternionFromAxisAngleBlock",I)}}(0,G.d)("FlowGraphQuaternionFromAxisAngleBlock",R);class n extends F.e{constructor(I){super(I),this.a=this.registerDataInput("a",X.B),this.axis=this.registerDataOutput("axis",X.K),this.angle=this.registerDataOutput("angle",X.x),this.isValid=this.registerDataOutput("isValid",X.i)}_updateOutputs(I){const x=I._getExecutionVariable(this,g,-1),L=I._getExecutionVariable(this,Q,null),F=I._getExecutionVariable(this,e,null);if(void 0!==L&&null!==L&&void 0!==F&&null!==F&&x===I.executionId)this.axis.setValue(L,I),this.angle.setValue(F,I);else try{const{axis:x,angle:L}=this.a.getValue(I).toAxisAngle();I._setExecutionVariable(this,Q,x),I._setExecutionVariable(this,e,L),I._setExecutionVariable(this,g,I.executionId),this.axis.setValue(x,I),this.angle.setValue(L,I),this.isValid.setValue(!0,I)}catch(X){this.isValid.setValue(!1,I)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,G.d)("FlowGraphAxisAngleFromQuaternionBlock",n);class P extends Y.c{constructor(I){super(X.K,X.K,X.B,((I,x)=>(0,W.g)(I,x)),"FlowGraphQuaternionFromDirectionsBlock",I)}}},16075:(I,x,L)=>{L.d(x,{c:()=>X});var F=L(16077);class X extends F.c{constructor(I,x,L,F,X,G){super(L,G),this._operation=F,this._className=X,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",x)}_doOperation(I){const x=this.a.getValue(I),L=this.b.getValue(I);return this._operation(x,L)}getClassName(){return this._className}}},16077:(I,x,L)=>{L.d(x,{c:()=>p});var F=L(14514),X=L(14498);const G="cachedOperationValue",Y="cachedExecutionId";class p extends F.e{constructor(I,x){super(x),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",X.i)}_updateOutputs(I){const x=I._getExecutionVariable(this,Y,-1),L=I._getExecutionVariable(this,G,null);if(void 0!==L&&null!==L&&x===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(L,I);else try{const x=this._doOperation(I);if(void 0===x||null===x)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,G,x),I._setExecutionVariable(this,Y,I.executionId),this.value.setValue(x,I),this.isValid.setValue(!0,I)}catch(F){this.isValid.setValue(!1,I)}}}},16084:(I,x,L)=>{L.d(x,{c:()=>X});var F=L(16077);class X extends F.c{constructor(I,x,L,F,X){super(x,X),this._operation=L,this._className=F,this.a=this.registerDataInput("a",I)}_doOperation(I){return this._operation(this.a.getValue(I))}getClassName(){return this._className}}}}]);