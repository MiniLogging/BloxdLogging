"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[89],{15605:(N,U,V)=>{V.r(U),V.d(U,{FlowGraphAngleBetweenBlock:()=>W,FlowGraphAxisAngleFromQuaternionBlock:()=>M,FlowGraphConjugateBlock:()=>Y,FlowGraphCrossBlock:()=>d,FlowGraphDotBlock:()=>J,FlowGraphLengthBlock:()=>C,FlowGraphNormalizeBlock:()=>x,FlowGraphQuaternionFromAxisAngleBlock:()=>s,FlowGraphQuaternionFromDirectionsBlock:()=>a,FlowGraphRotate2DBlock:()=>r,FlowGraphRotate3DBlock:()=>v,FlowGraphTransformBlock:()=>c,FlowGraphTransformCoordinatesBlock:()=>H});var A=V(14058),t=V(14036),n=V(12344),q=V(15587),i=V(15599),z=V(12383),S=V(14069),E=V(13743);const p="cachedOperationAxis",k="cachedOperationAngle",B="cachedExecutionId";class C extends i.e{constructor(N){super(t.b,t.p,(N=>this._polymorphicLength(N)),"FlowGraphLengthBlock",N)}_polymorphicLength(N){switch((0,S.m)(N)){case"Vector2":case"CU":case"Vector4":case"Quaternion":return N.length();default:throw new Error(`Cannot compute length of value ${N}`)}}}(0,n.e)("FlowGraphLengthBlock",C);class x extends i.e{constructor(N){super(t.b,t.b,(N=>this._polymorphicNormalize(N)),"FlowGraphNormalizeBlock",N)}_polymorphicNormalize(N){var U;let V;switch((0,S.m)(N)){case"Vector2":case"CU":case"Vector4":case"Quaternion":if(V=N.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===N.length()&&V.Hi(NaN)}return V;default:throw new Error(`Cannot normalize value ${N}`)}}}(0,n.e)("FlowGraphNormalizeBlock",x);class J extends q.b{constructor(N){super(t.b,t.b,t.p,((N,U)=>this._polymorphicDot(N,U)),"FlowGraphDotBlock",N)}_polymorphicDot(N,U){switch((0,S.m)(N)){case"Vector2":case"CU":case"Vector4":case"Quaternion":return N.dot(U);default:throw new Error(`Cannot get dot product of ${N} and ${U}`)}}}(0,n.e)("FlowGraphDotBlock",J);class d extends q.b{constructor(N){super(t.y,t.y,t.y,((N,U)=>z.CU.Cross(N,U)),"FlowGraphCrossBlock",N)}}(0,n.e)("FlowGraphCrossBlock",d);class r extends q.b{constructor(N){super(t.w,t.p,t.w,((N,U)=>N.rotate(U)),"FlowGraphRotate2DBlock",N)}}(0,n.e)("FlowGraphRotate2DBlock",r);class v extends q.b{constructor(N){super(t.y,t.q,t.y,((N,U)=>N.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",N)}}function h(N,U){switch((0,S.m)(N)){case"Vector2":case"CU":return U.transformVector(N);case"Vector4":return new z.Vector4(N.x*U.m[0]+N.y*U.m[1]+N.z*U.m[2]+N.w*U.m[3],N.x*U.m[4]+N.y*U.m[5]+N.z*U.m[6]+N.w*U.m[7],N.x*U.m[8]+N.y*U.m[9]+N.z*U.m[10]+N.w*U.m[11],N.x*U.m[12]+N.y*U.m[13]+N.z*U.m[14]+N.w*U.m[15]);default:throw new Error(`Cannot transform value ${N}`)}}(0,n.e)("FlowGraphRotate3DBlock",v);class c extends q.b{constructor(N){const U=(null===N||void 0===N?void 0:N.vectorType)||"CU",V="Vector2"===U?"Matrix2D":"CU"===U?"Matrix3D":"Matrix";super((0,t.F)(U),(0,t.F)(V),(0,t.F)(U),h,"FlowGraphTransformVectorBlock",N)}}(0,n.e)("FlowGraphTransformVectorBlock",c);class H extends q.b{constructor(N){super(t.y,t.i,t.y,((N,U)=>z.CU.TransformCoordinates(N,U)),"FlowGraphTransformCoordinatesBlock",N)}}(0,n.e)("FlowGraphTransformCoordinatesBlock",H);class Y extends i.e{constructor(N){super(t.q,t.q,(N=>N.conjugate()),"FlowGraphConjugateBlock",N)}}(0,n.e)("FlowGraphConjugateBlock",Y);class W extends q.b{constructor(N){super(t.q,t.q,t.p,((N,U)=>(0,E.d)(N,U)),"FlowGraphAngleBetweenBlock",N)}}(0,n.e)("FlowGraphAngleBetweenBlock",W);class s extends q.b{constructor(N){super(t.y,t.p,t.q,((N,U)=>z.Quaternion.RotationAxis(N,U)),"FlowGraphQuaternionFromAxisAngleBlock",N)}}(0,n.e)("FlowGraphQuaternionFromAxisAngleBlock",s);class M extends A.c{constructor(N){super(N),this.a=this.registerDataInput("a",t.q),this.axis=this.registerDataOutput("axis",t.y),this.angle=this.registerDataOutput("angle",t.p),this.isValid=this.registerDataOutput("isValid",t.d)}_updateOutputs(N){const U=N._getExecutionVariable(this,B,-1),V=N._getExecutionVariable(this,p,null),A=N._getExecutionVariable(this,k,null);if(void 0!==V&&null!==V&&void 0!==A&&null!==A&&U===N.executionId)this.axis.setValue(V,N),this.angle.setValue(A,N);else try{const{axis:U,angle:V}=this.a.getValue(N).toAxisAngle();N._setExecutionVariable(this,p,U),N._setExecutionVariable(this,k,V),N._setExecutionVariable(this,B,N.executionId),this.axis.setValue(U,N),this.angle.setValue(V,N),this.isValid.setValue(!0,N)}catch(t){this.isValid.setValue(!1,N)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,n.e)("FlowGraphAxisAngleFromQuaternionBlock",M);class a extends q.b{constructor(N){super(t.y,t.y,t.q,((N,U)=>(0,E.g)(N,U)),"FlowGraphQuaternionFromDirectionsBlock",N)}}},15587:(N,U,V)=>{V.d(U,{b:()=>t});var A=V(15590);class t extends A.c{constructor(N,U,V,A,t,n){super(V,n),this._operation=A,this._className=t,this.a=this.registerDataInput("a",N),this.b=this.registerDataInput("b",U)}_doOperation(N){const U=this.a.getValue(N),V=this.b.getValue(N);return this._operation(U,V)}getClassName(){return this._className}}},15590:(N,U,V)=>{V.d(U,{c:()=>i});var A=V(14058),t=V(14036);const n="cachedOperationValue",q="cachedExecutionId";class i extends A.c{constructor(N,U){super(U),this.value=this.registerDataOutput("value",N),this.isValid=this.registerDataOutput("isValid",t.d)}_updateOutputs(N){const U=N._getExecutionVariable(this,q,-1),V=N._getExecutionVariable(this,n,null);if(void 0!==V&&null!==V&&U===N.executionId)this.isValid.setValue(!0,N),this.value.setValue(V,N);else try{const U=this._doOperation(N);if(void 0===U||null===U)return void this.isValid.setValue(!1,N);N._setExecutionVariable(this,n,U),N._setExecutionVariable(this,q,N.executionId),this.value.setValue(U,N),this.isValid.setValue(!0,N)}catch(A){this.isValid.setValue(!1,N)}}}},15599:(N,U,V)=>{V.d(U,{e:()=>t});var A=V(15590);class t extends A.c{constructor(N,U,V,A,t){super(U,t),this._operation=V,this._className=A,this.a=this.registerDataInput("a",N)}_doOperation(N){return this._operation(this.a.getValue(N))}getClassName(){return this._className}}}}]);