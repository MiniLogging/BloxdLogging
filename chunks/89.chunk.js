"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[89],{16024:(p,b,M)=>{M.r(b),M.d(b,{FlowGraphAngleBetweenBlock:()=>e,FlowGraphAxisAngleFromQuaternionBlock:()=>I,FlowGraphConjugateBlock:()=>u,FlowGraphCrossBlock:()=>f,FlowGraphDotBlock:()=>g,FlowGraphLengthBlock:()=>c,FlowGraphNormalizeBlock:()=>J,FlowGraphQuaternionFromAxisAngleBlock:()=>d,FlowGraphQuaternionFromDirectionsBlock:()=>G,FlowGraphRotate2DBlock:()=>Y,FlowGraphRotate3DBlock:()=>a,FlowGraphTransformBlock:()=>l,FlowGraphTransformCoordinatesBlock:()=>L});var h=M(14341),Q=M(14316),mp=M(12730),y=M(16001),P=M(16015),w=M(12777),t=M(14351),z=M(14008);const x="cachedOperationAxis",S="cachedOperationAngle",X="cachedExecutionId";class c extends P.c{constructor(p){super(Q.e,Q.t,(p=>this._polymorphicLength(p)),"FlowGraphLengthBlock",p)}_polymorphicLength(p){switch((0,t.n)(p)){case"Vector2":case"QM":case"Vector4":case"Quaternion":return p.length();default:throw new Error(`Cannot compute length of value ${p}`)}}}(0,mp.c)("FlowGraphLengthBlock",c);class J extends P.c{constructor(p){super(Q.e,Q.e,(p=>this._polymorphicNormalize(p)),"FlowGraphNormalizeBlock",p)}_polymorphicNormalize(p){var b;let M;switch((0,t.n)(p)){case"Vector2":case"QM":case"Vector4":case"Quaternion":if(M=p.normalizeToNew(),null!==(b=this.config)&&void 0!==b&&b.nanOnZeroLength){0===p.length()&&M.Tb(NaN)}return M;default:throw new Error(`Cannot normalize value ${p}`)}}}(0,mp.c)("FlowGraphNormalizeBlock",J);class g extends y.e{constructor(p){super(Q.e,Q.e,Q.t,((p,b)=>this._polymorphicDot(p,b)),"FlowGraphDotBlock",p)}_polymorphicDot(p,b){switch((0,t.n)(p)){case"Vector2":case"QM":case"Vector4":case"Quaternion":return p.dot(b);default:throw new Error(`Cannot get dot product of ${p} and ${b}`)}}}(0,mp.c)("FlowGraphDotBlock",g);class f extends y.e{constructor(p){super(Q.z,Q.z,Q.z,((p,b)=>w.QM.Cross(p,b)),"FlowGraphCrossBlock",p)}}(0,mp.c)("FlowGraphCrossBlock",f);class Y extends y.e{constructor(p){super(Q.y,Q.t,Q.y,((p,b)=>p.rotate(b)),"FlowGraphRotate2DBlock",p)}}(0,mp.c)("FlowGraphRotate2DBlock",Y);class a extends y.e{constructor(p){super(Q.z,Q.v,Q.z,((p,b)=>p.applyRotationQuaternion(b)),"FlowGraphRotate3DBlock",p)}}function o(p,b){switch((0,t.n)(p)){case"Vector2":case"QM":return b.transformVector(p);case"Vector4":return new w.Vector4(p.x*b.m[0]+p.y*b.m[1]+p.z*b.m[2]+p.w*b.m[3],p.x*b.m[4]+p.y*b.m[5]+p.z*b.m[6]+p.w*b.m[7],p.x*b.m[8]+p.y*b.m[9]+p.z*b.m[10]+p.w*b.m[11],p.x*b.m[12]+p.y*b.m[13]+p.z*b.m[14]+p.w*b.m[15]);default:throw new Error(`Cannot transform value ${p}`)}}(0,mp.c)("FlowGraphRotate3DBlock",a);class l extends y.e{constructor(p){const b=(null===p||void 0===p?void 0:p.vectorType)||"QM",M="Vector2"===b?"Matrix2D":"QM"===b?"Matrix3D":"Matrix";super((0,Q.L)(b),(0,Q.L)(M),(0,Q.L)(b),o,"FlowGraphTransformVectorBlock",p)}}(0,mp.c)("FlowGraphTransformVectorBlock",l);class L extends y.e{constructor(p){super(Q.z,Q.l,Q.z,((p,b)=>w.QM.TransformCoordinates(p,b)),"FlowGraphTransformCoordinatesBlock",p)}}(0,mp.c)("FlowGraphTransformCoordinatesBlock",L);class u extends P.c{constructor(p){super(Q.v,Q.v,(p=>p.conjugate()),"FlowGraphConjugateBlock",p)}}(0,mp.c)("FlowGraphConjugateBlock",u);class e extends y.e{constructor(p){super(Q.v,Q.v,Q.t,((p,b)=>(0,z.d)(p,b)),"FlowGraphAngleBetweenBlock",p)}}(0,mp.c)("FlowGraphAngleBetweenBlock",e);class d extends y.e{constructor(p){super(Q.z,Q.t,Q.v,((p,b)=>w.Quaternion.RotationAxis(p,b)),"FlowGraphQuaternionFromAxisAngleBlock",p)}}(0,mp.c)("FlowGraphQuaternionFromAxisAngleBlock",d);class I extends h.d{constructor(p){super(p),this.a=this.registerDataInput("a",Q.v),this.axis=this.registerDataOutput("axis",Q.z),this.angle=this.registerDataOutput("angle",Q.t),this.isValid=this.registerDataOutput("isValid",Q.g)}_updateOutputs(p){const b=p._getExecutionVariable(this,X,-1),M=p._getExecutionVariable(this,x,null),h=p._getExecutionVariable(this,S,null);if(void 0!==M&&null!==M&&void 0!==h&&null!==h&&b===p.executionId)this.axis.setValue(M,p),this.angle.setValue(h,p);else try{const{axis:b,angle:M}=this.a.getValue(p).toAxisAngle();p._setExecutionVariable(this,x,b),p._setExecutionVariable(this,S,M),p._setExecutionVariable(this,X,p.executionId),this.axis.setValue(b,p),this.angle.setValue(M,p),this.isValid.setValue(!0,p)}catch(Q){this.isValid.setValue(!1,p)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,mp.c)("FlowGraphAxisAngleFromQuaternionBlock",I);class G extends y.e{constructor(p){super(Q.z,Q.z,Q.v,((p,b)=>(0,z.f)(p,b)),"FlowGraphQuaternionFromDirectionsBlock",p)}}},16001:(p,b,M)=>{M.d(b,{e:()=>Q});var h=M(16006);class Q extends h.e{constructor(p,b,M,h,Q,mp){super(M,mp),this._operation=h,this._className=Q,this.a=this.registerDataInput("a",p),this.b=this.registerDataInput("b",b)}_doOperation(p){const b=this.a.getValue(p),M=this.b.getValue(p);return this._operation(b,M)}getClassName(){return this._className}}},16006:(p,b,M)=>{M.d(b,{e:()=>P});var h=M(14341),Q=M(14316);const mp="cachedOperationValue",y="cachedExecutionId";class P extends h.d{constructor(p,b){super(b),this.value=this.registerDataOutput("value",p),this.isValid=this.registerDataOutput("isValid",Q.g)}_updateOutputs(p){const b=p._getExecutionVariable(this,y,-1),M=p._getExecutionVariable(this,mp,null);if(void 0!==M&&null!==M&&b===p.executionId)this.isValid.setValue(!0,p),this.value.setValue(M,p);else try{const b=this._doOperation(p);if(void 0===b||null===b)return void this.isValid.setValue(!1,p);p._setExecutionVariable(this,mp,b),p._setExecutionVariable(this,y,p.executionId),this.value.setValue(b,p),this.isValid.setValue(!0,p)}catch(h){this.isValid.setValue(!1,p)}}}},16015:(p,b,M)=>{M.d(b,{c:()=>Q});var h=M(16006);class Q extends h.e{constructor(p,b,M,h,Q){super(b,Q),this._operation=M,this._className=h,this.a=this.registerDataInput("a",p)}_doOperation(p){return this._operation(this.a.getValue(p))}getClassName(){return this._className}}}}]);