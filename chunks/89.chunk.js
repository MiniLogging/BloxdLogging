"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[89],{14499:(K,H,M)=>{M.r(H),M.d(H,{FlowGraphAngleBetweenBlock:()=>s,FlowGraphAxisAngleFromQuaternionBlock:()=>V,FlowGraphConjugateBlock:()=>l,FlowGraphCrossBlock:()=>S,FlowGraphDotBlock:()=>L,FlowGraphLengthBlock:()=>v,FlowGraphNormalizeBlock:()=>O,FlowGraphQuaternionFromAxisAngleBlock:()=>D,FlowGraphQuaternionFromDirectionsBlock:()=>n,FlowGraphRotate2DBlock:()=>B,FlowGraphRotate3DBlock:()=>C,FlowGraphTransformBlock:()=>Z,FlowGraphTransformCoordinatesBlock:()=>E});var q=M(13021),w=M(13004),u=M(11242),y=M(14480),h=M(14492),W=M(11290),I=M(13030),f=M(12693);const z="cachedOperationAxis",G="cachedOperationAngle",a="cachedExecutionId";class v extends h.b{constructor(K){super(w.d,w.x,(K=>this._polymorphicLength(K)),"FlowGraphLengthBlock",K)}_polymorphicLength(K){switch((0,I.m)(K)){case"Vector2":case"OH":case"Vector4":case"Quaternion":return K.length();default:throw new Error(`Cannot compute length of value ${K}`)}}}(0,u.f)("FlowGraphLengthBlock",v);class O extends h.b{constructor(K){super(w.d,w.d,(K=>this._polymorphicNormalize(K)),"FlowGraphNormalizeBlock",K)}_polymorphicNormalize(K){var H;let M;switch((0,I.m)(K)){case"Vector2":case"OH":case"Vector4":case"Quaternion":if(M=K.normalizeToNew(),null!==(H=this.config)&&void 0!==H&&H.nanOnZeroLength){0===K.length()&&M.Bh(NaN)}return M;default:throw new Error(`Cannot normalize value ${K}`)}}}(0,u.f)("FlowGraphNormalizeBlock",O);class L extends y.d{constructor(K){super(w.d,w.d,w.x,((K,H)=>this._polymorphicDot(K,H)),"FlowGraphDotBlock",K)}_polymorphicDot(K,H){switch((0,I.m)(K)){case"Vector2":case"OH":case"Vector4":case"Quaternion":return K.dot(H);default:throw new Error(`Cannot get dot product of ${K} and ${H}`)}}}(0,u.f)("FlowGraphDotBlock",L);class S extends y.d{constructor(K){super(w.F,w.F,w.F,((K,H)=>W.OH.Cross(K,H)),"FlowGraphCrossBlock",K)}}(0,u.f)("FlowGraphCrossBlock",S);class B extends y.d{constructor(K){super(w.E,w.x,w.E,((K,H)=>K.rotate(H)),"FlowGraphRotate2DBlock",K)}}(0,u.f)("FlowGraphRotate2DBlock",B);class C extends y.d{constructor(K){super(w.F,w.y,w.F,((K,H)=>K.applyRotationQuaternion(H)),"FlowGraphRotate3DBlock",K)}}function i(K,H){switch((0,I.m)(K)){case"Vector2":case"OH":return H.transformVector(K);case"Vector4":return new W.Vector4(K.x*H.m[0]+K.y*H.m[1]+K.z*H.m[2]+K.w*H.m[3],K.x*H.m[4]+K.y*H.m[5]+K.z*H.m[6]+K.w*H.m[7],K.x*H.m[8]+K.y*H.m[9]+K.z*H.m[10]+K.w*H.m[11],K.x*H.m[12]+K.y*H.m[13]+K.z*H.m[14]+K.w*H.m[15]);default:throw new Error(`Cannot transform value ${K}`)}}(0,u.f)("FlowGraphRotate3DBlock",C);class Z extends y.d{constructor(K){const H=(null===K||void 0===K?void 0:K.vectorType)||"OH",M="Vector2"===H?"Matrix2D":"OH"===H?"Matrix3D":"Matrix";super((0,w.L)(H),(0,w.L)(M),(0,w.L)(H),i,"FlowGraphTransformVectorBlock",K)}}(0,u.f)("FlowGraphTransformVectorBlock",Z);class E extends y.d{constructor(K){super(w.F,w.o,w.F,((K,H)=>W.OH.TransformCoordinates(K,H)),"FlowGraphTransformCoordinatesBlock",K)}}(0,u.f)("FlowGraphTransformCoordinatesBlock",E);class l extends h.b{constructor(K){super(w.y,w.y,(K=>K.conjugate()),"FlowGraphConjugateBlock",K)}}(0,u.f)("FlowGraphConjugateBlock",l);class s extends y.d{constructor(K){super(w.y,w.y,w.x,((K,H)=>(0,f.e)(K,H)),"FlowGraphAngleBetweenBlock",K)}}(0,u.f)("FlowGraphAngleBetweenBlock",s);class D extends y.d{constructor(K){super(w.F,w.x,w.y,((K,H)=>W.Quaternion.RotationAxis(K,H)),"FlowGraphQuaternionFromAxisAngleBlock",K)}}(0,u.f)("FlowGraphQuaternionFromAxisAngleBlock",D);class V extends q.b{constructor(K){super(K),this.a=this.registerDataInput("a",w.y),this.axis=this.registerDataOutput("axis",w.F),this.angle=this.registerDataOutput("angle",w.x),this.isValid=this.registerDataOutput("isValid",w.h)}_updateOutputs(K){const H=K._getExecutionVariable(this,a,-1),M=K._getExecutionVariable(this,z,null),q=K._getExecutionVariable(this,G,null);if(void 0!==M&&null!==M&&void 0!==q&&null!==q&&H===K.executionId)this.axis.setValue(M,K),this.angle.setValue(q,K);else try{const{axis:H,angle:M}=this.a.getValue(K).toAxisAngle();K._setExecutionVariable(this,z,H),K._setExecutionVariable(this,G,M),K._setExecutionVariable(this,a,K.executionId),this.axis.setValue(H,K),this.angle.setValue(M,K),this.isValid.setValue(!0,K)}catch(w){this.isValid.setValue(!1,K)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,u.f)("FlowGraphAxisAngleFromQuaternionBlock",V);class n extends y.d{constructor(K){super(w.F,w.F,w.y,((K,H)=>(0,f.h)(K,H)),"FlowGraphQuaternionFromDirectionsBlock",K)}}},14480:(K,H,M)=>{M.d(H,{d:()=>w});var q=M(14485);class w extends q.b{constructor(K,H,M,q,w,u){super(M,u),this._operation=q,this._className=w,this.a=this.registerDataInput("a",K),this.b=this.registerDataInput("b",H)}_doOperation(K){const H=this.a.getValue(K),M=this.b.getValue(K);return this._operation(H,M)}getClassName(){return this._className}}},14485:(K,H,M)=>{M.d(H,{b:()=>h});var q=M(13021),w=M(13004);const u="cachedOperationValue",y="cachedExecutionId";class h extends q.b{constructor(K,H){super(H),this.value=this.registerDataOutput("value",K),this.isValid=this.registerDataOutput("isValid",w.h)}_updateOutputs(K){const H=K._getExecutionVariable(this,y,-1),M=K._getExecutionVariable(this,u,null);if(void 0!==M&&null!==M&&H===K.executionId)this.isValid.setValue(!0,K),this.value.setValue(M,K);else try{const H=this._doOperation(K);if(void 0===H||null===H)return void this.isValid.setValue(!1,K);K._setExecutionVariable(this,u,H),K._setExecutionVariable(this,y,K.executionId),this.value.setValue(H,K),this.isValid.setValue(!0,K)}catch(q){this.isValid.setValue(!1,K)}}}},14492:(K,H,M)=>{M.d(H,{b:()=>w});var q=M(14485);class w extends q.b{constructor(K,H,M,q,w){super(H,w),this._operation=M,this._className=q,this.a=this.registerDataInput("a",K)}_doOperation(K){return this._operation(this.a.getValue(K))}getClassName(){return this._className}}}}]);