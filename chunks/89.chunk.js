"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14422:(P,f,Y)=>{Y.r(f),Y.d(f,{FlowGraphAngleBetweenBlock:()=>c,FlowGraphAxisAngleFromQuaternionBlock:()=>U,FlowGraphConjugateBlock:()=>v,FlowGraphCrossBlock:()=>K,FlowGraphDotBlock:()=>S,FlowGraphLengthBlock:()=>u,FlowGraphNormalizeBlock:()=>g,FlowGraphQuaternionFromAxisAngleBlock:()=>T,FlowGraphQuaternionFromDirectionsBlock:()=>D,FlowGraphRotate2DBlock:()=>M,FlowGraphRotate3DBlock:()=>V,FlowGraphTransformBlock:()=>n,FlowGraphTransformCoordinatesBlock:()=>l});var C=Y(12947),q=Y(12917),m=Y(11134),L=Y(14408),o=Y(14414),w=Y(11179),d=Y(12960),R=Y(12603);const y="cachedOperationAxis",r="cachedOperationAngle",i="cachedExecutionId";class u extends o.d{constructor(P){super(q.d,q.o,(P=>this._polymorphicLength(P)),"FlowGraphLengthBlock",P)}_polymorphicLength(P){switch((0,d.j)(P)){case"Vector2":case"Of":case"Vector4":case"Quaternion":return P.length();default:throw new Error(`Cannot compute length of value ${P}`)}}}(0,m.d)("FlowGraphLengthBlock",u);class g extends o.d{constructor(P){super(q.d,q.d,(P=>this._polymorphicNormalize(P)),"FlowGraphNormalizeBlock",P)}_polymorphicNormalize(P){var f;let Y;switch((0,d.j)(P)){case"Vector2":case"Of":case"Vector4":case"Quaternion":if(Y=P.normalizeToNew(),null!==(f=this.config)&&void 0!==f&&f.nanOnZeroLength){0===P.length()&&Y.yo(NaN)}return Y;default:throw new Error(`Cannot normalize value ${P}`)}}}(0,m.d)("FlowGraphNormalizeBlock",g);class S extends L.b{constructor(P){super(q.d,q.d,q.o,((P,f)=>this._polymorphicDot(P,f)),"FlowGraphDotBlock",P)}_polymorphicDot(P,f){switch((0,d.j)(P)){case"Vector2":case"Of":case"Vector4":case"Quaternion":return P.dot(f);default:throw new Error(`Cannot get dot product of ${P} and ${f}`)}}}(0,m.d)("FlowGraphDotBlock",S);class K extends L.b{constructor(P){super(q.v,q.v,q.v,((P,f)=>w.Of.Cross(P,f)),"FlowGraphCrossBlock",P)}}(0,m.d)("FlowGraphCrossBlock",K);class M extends L.b{constructor(P){super(q.u,q.o,q.u,((P,f)=>P.rotate(f)),"FlowGraphRotate2DBlock",P)}}(0,m.d)("FlowGraphRotate2DBlock",M);class V extends L.b{constructor(P){super(q.v,q.q,q.v,((P,f)=>P.applyRotationQuaternion(f)),"FlowGraphRotate3DBlock",P)}}function O(P,f){switch((0,d.j)(P)){case"Vector2":case"Of":return f.transformVector(P);case"Vector4":return new w.Vector4(P.x*f.m[0]+P.y*f.m[1]+P.z*f.m[2]+P.w*f.m[3],P.x*f.m[4]+P.y*f.m[5]+P.z*f.m[6]+P.w*f.m[7],P.x*f.m[8]+P.y*f.m[9]+P.z*f.m[10]+P.w*f.m[11],P.x*f.m[12]+P.y*f.m[13]+P.z*f.m[14]+P.w*f.m[15]);default:throw new Error(`Cannot transform value ${P}`)}}(0,m.d)("FlowGraphRotate3DBlock",V);class n extends L.b{constructor(P){const f=(null===P||void 0===P?void 0:P.vectorType)||"Of",Y="Vector2"===f?"Matrix2D":"Of"===f?"Matrix3D":"Matrix";super((0,q.D)(f),(0,q.D)(Y),(0,q.D)(f),O,"FlowGraphTransformVectorBlock",P)}}(0,m.d)("FlowGraphTransformVectorBlock",n);class l extends L.b{constructor(P){super(q.v,q.h,q.v,((P,f)=>w.Of.TransformCoordinates(P,f)),"FlowGraphTransformCoordinatesBlock",P)}}(0,m.d)("FlowGraphTransformCoordinatesBlock",l);class v extends o.d{constructor(P){super(q.q,q.q,(P=>P.conjugate()),"FlowGraphConjugateBlock",P)}}(0,m.d)("FlowGraphConjugateBlock",v);class c extends L.b{constructor(P){super(q.q,q.q,q.o,((P,f)=>(0,R.c)(P,f)),"FlowGraphAngleBetweenBlock",P)}}(0,m.d)("FlowGraphAngleBetweenBlock",c);class T extends L.b{constructor(P){super(q.v,q.o,q.q,((P,f)=>w.Quaternion.RotationAxis(P,f)),"FlowGraphQuaternionFromAxisAngleBlock",P)}}(0,m.d)("FlowGraphQuaternionFromAxisAngleBlock",T);class U extends C.b{constructor(P){super(P),this.a=this.registerDataInput("a",q.q),this.axis=this.registerDataOutput("axis",q.v),this.angle=this.registerDataOutput("angle",q.o),this.isValid=this.registerDataOutput("isValid",q.e)}_updateOutputs(P){const f=P._getExecutionVariable(this,i,-1),Y=P._getExecutionVariable(this,y,null),C=P._getExecutionVariable(this,r,null);if(void 0!==Y&&null!==Y&&void 0!==C&&null!==C&&f===P.executionId)this.axis.setValue(Y,P),this.angle.setValue(C,P);else try{const{axis:f,angle:Y}=this.a.getValue(P).toAxisAngle();P._setExecutionVariable(this,y,f),P._setExecutionVariable(this,r,Y),P._setExecutionVariable(this,i,P.executionId),this.axis.setValue(f,P),this.angle.setValue(Y,P),this.isValid.setValue(!0,P)}catch(q){this.isValid.setValue(!1,P)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,m.d)("FlowGraphAxisAngleFromQuaternionBlock",U);class D extends L.b{constructor(P){super(q.v,q.v,q.q,((P,f)=>(0,R.g)(P,f)),"FlowGraphQuaternionFromDirectionsBlock",P)}}},14408:(P,f,Y)=>{Y.d(f,{b:()=>q});var C=Y(14410);class q extends C.c{constructor(P,f,Y,C,q,m){super(Y,m),this._operation=C,this._className=q,this.a=this.registerDataInput("a",P),this.b=this.registerDataInput("b",f)}_doOperation(P){const f=this.a.getValue(P),Y=this.b.getValue(P);return this._operation(f,Y)}getClassName(){return this._className}}},14410:(P,f,Y)=>{Y.d(f,{c:()=>o});var C=Y(12947),q=Y(12917);const m="cachedOperationValue",L="cachedExecutionId";class o extends C.b{constructor(P,f){super(f),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",q.e)}_updateOutputs(P){const f=P._getExecutionVariable(this,L,-1),Y=P._getExecutionVariable(this,m,null);if(void 0!==Y&&null!==Y&&f===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(Y,P);else try{const f=this._doOperation(P);if(void 0===f||null===f)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,m,f),P._setExecutionVariable(this,L,P.executionId),this.value.setValue(f,P),this.isValid.setValue(!0,P)}catch(C){this.isValid.setValue(!1,P)}}}},14414:(P,f,Y)=>{Y.d(f,{d:()=>q});var C=Y(14410);class q extends C.c{constructor(P,f,Y,C,q){super(f,q),this._operation=Y,this._className=C,this.a=this.registerDataInput("a",P)}_doOperation(P){return this._operation(this.a.getValue(P))}getClassName(){return this._className}}}}]);