"use strict";(self["3nlrbof8msu"]=self["3nlrbof8msu"]||[]).push([[89],{15970:(t,b,Z)=>{Z.r(b),Z.d(b,{FlowGraphAngleBetweenBlock:()=>O,FlowGraphAxisAngleFromQuaternionBlock:()=>e,FlowGraphConjugateBlock:()=>o,FlowGraphCrossBlock:()=>u,FlowGraphDotBlock:()=>k,FlowGraphLengthBlock:()=>T,FlowGraphNormalizeBlock:()=>a,FlowGraphQuaternionFromAxisAngleBlock:()=>p,FlowGraphQuaternionFromDirectionsBlock:()=>W,FlowGraphRotate2DBlock:()=>l,FlowGraphRotate3DBlock:()=>U,FlowGraphTransformBlock:()=>c,FlowGraphTransformCoordinatesBlock:()=>H});var J=Z(14432),S=Z(14405),P=Z(12688),v=Z(15952),h=Z(15962),C=Z(12735),Y=Z(14449),g=Z(14088);const I="cachedOperationAxis",r="cachedOperationAngle",M="cachedExecutionId";class T extends h.c{constructor(t){super(S.c,S.q,(t=>this._polymorphicLength(t)),"FlowGraphLengthBlock",t)}_polymorphicLength(t){switch((0,Y.g)(t)){case"Vector2":case"JZ":case"Vector4":case"Quaternion":return t.length();default:throw new Error(`Cannot compute length of value ${t}`)}}}(0,P.f)("FlowGraphLengthBlock",T);class a extends h.c{constructor(t){super(S.c,S.c,(t=>this._polymorphicNormalize(t)),"FlowGraphNormalizeBlock",t)}_polymorphicNormalize(t){var b;let Z;switch((0,Y.g)(t)){case"Vector2":case"JZ":case"Vector4":case"Quaternion":if(Z=t.normalizeToNew(),null!==(b=this.config)&&void 0!==b&&b.nanOnZeroLength){0===t.length()&&Z.Lb(NaN)}return Z;default:throw new Error(`Cannot normalize value ${t}`)}}}(0,P.f)("FlowGraphNormalizeBlock",a);class k extends v.d{constructor(t){super(S.c,S.c,S.q,((t,b)=>this._polymorphicDot(t,b)),"FlowGraphDotBlock",t)}_polymorphicDot(t,b){switch((0,Y.g)(t)){case"Vector2":case"JZ":case"Vector4":case"Quaternion":return t.dot(b);default:throw new Error(`Cannot get dot product of ${t} and ${b}`)}}}(0,P.f)("FlowGraphDotBlock",k);class u extends v.d{constructor(t){super(S.D,S.D,S.D,((t,b)=>C.JZ.Cross(t,b)),"FlowGraphCrossBlock",t)}}(0,P.f)("FlowGraphCrossBlock",u);class l extends v.d{constructor(t){super(S.A,S.q,S.A,((t,b)=>t.rotate(b)),"FlowGraphRotate2DBlock",t)}}(0,P.f)("FlowGraphRotate2DBlock",l);class U extends v.d{constructor(t){super(S.D,S.u,S.D,((t,b)=>t.applyRotationQuaternion(b)),"FlowGraphRotate3DBlock",t)}}function E(t,b){switch((0,Y.g)(t)){case"Vector2":case"JZ":return b.transformVector(t);case"Vector4":return new C.Vector4(t.x*b.m[0]+t.y*b.m[1]+t.z*b.m[2]+t.w*b.m[3],t.x*b.m[4]+t.y*b.m[5]+t.z*b.m[6]+t.w*b.m[7],t.x*b.m[8]+t.y*b.m[9]+t.z*b.m[10]+t.w*b.m[11],t.x*b.m[12]+t.y*b.m[13]+t.z*b.m[14]+t.w*b.m[15]);default:throw new Error(`Cannot transform value ${t}`)}}(0,P.f)("FlowGraphRotate3DBlock",U);class c extends v.d{constructor(t){const b=(null===t||void 0===t?void 0:t.vectorType)||"JZ",Z="Vector2"===b?"Matrix2D":"JZ"===b?"Matrix3D":"Matrix";super((0,S.O)(b),(0,S.O)(Z),(0,S.O)(b),E,"FlowGraphTransformVectorBlock",t)}}(0,P.f)("FlowGraphTransformVectorBlock",c);class H extends v.d{constructor(t){super(S.D,S.k,S.D,((t,b)=>C.JZ.TransformCoordinates(t,b)),"FlowGraphTransformCoordinatesBlock",t)}}(0,P.f)("FlowGraphTransformCoordinatesBlock",H);class o extends h.c{constructor(t){super(S.u,S.u,(t=>t.conjugate()),"FlowGraphConjugateBlock",t)}}(0,P.f)("FlowGraphConjugateBlock",o);class O extends v.d{constructor(t){super(S.u,S.u,S.q,((t,b)=>(0,g.b)(t,b)),"FlowGraphAngleBetweenBlock",t)}}(0,P.f)("FlowGraphAngleBetweenBlock",O);class p extends v.d{constructor(t){super(S.D,S.q,S.u,((t,b)=>C.Quaternion.RotationAxis(t,b)),"FlowGraphQuaternionFromAxisAngleBlock",t)}}(0,P.f)("FlowGraphQuaternionFromAxisAngleBlock",p);class e extends J.e{constructor(t){super(t),this.a=this.registerDataInput("a",S.u),this.axis=this.registerDataOutput("axis",S.D),this.angle=this.registerDataOutput("angle",S.q),this.isValid=this.registerDataOutput("isValid",S.f)}_updateOutputs(t){const b=t._getExecutionVariable(this,M,-1),Z=t._getExecutionVariable(this,I,null),J=t._getExecutionVariable(this,r,null);if(void 0!==Z&&null!==Z&&void 0!==J&&null!==J&&b===t.executionId)this.axis.setValue(Z,t),this.angle.setValue(J,t);else try{const{axis:b,angle:Z}=this.a.getValue(t).toAxisAngle();t._setExecutionVariable(this,I,b),t._setExecutionVariable(this,r,Z),t._setExecutionVariable(this,M,t.executionId),this.axis.setValue(b,t),this.angle.setValue(Z,t),this.isValid.setValue(!0,t)}catch(S){this.isValid.setValue(!1,t)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,P.f)("FlowGraphAxisAngleFromQuaternionBlock",e);class W extends v.d{constructor(t){super(S.D,S.D,S.u,((t,b)=>(0,g.c)(t,b)),"FlowGraphQuaternionFromDirectionsBlock",t)}}},15952:(t,b,Z)=>{Z.d(b,{d:()=>S});var J=Z(15959);class S extends J.d{constructor(t,b,Z,J,S,P){super(Z,P),this._operation=J,this._className=S,this.a=this.registerDataInput("a",t),this.b=this.registerDataInput("b",b)}_doOperation(t){const b=this.a.getValue(t),Z=this.b.getValue(t);return this._operation(b,Z)}getClassName(){return this._className}}},15959:(t,b,Z)=>{Z.d(b,{d:()=>h});var J=Z(14432),S=Z(14405);const P="cachedOperationValue",v="cachedExecutionId";class h extends J.e{constructor(t,b){super(b),this.value=this.registerDataOutput("value",t),this.isValid=this.registerDataOutput("isValid",S.f)}_updateOutputs(t){const b=t._getExecutionVariable(this,v,-1),Z=t._getExecutionVariable(this,P,null);if(void 0!==Z&&null!==Z&&b===t.executionId)this.isValid.setValue(!0,t),this.value.setValue(Z,t);else try{const b=this._doOperation(t);if(void 0===b||null===b)return void this.isValid.setValue(!1,t);t._setExecutionVariable(this,P,b),t._setExecutionVariable(this,v,t.executionId),this.value.setValue(b,t),this.isValid.setValue(!0,t)}catch(J){this.isValid.setValue(!1,t)}}}},15962:(t,b,Z)=>{Z.d(b,{c:()=>S});var J=Z(15959);class S extends J.d{constructor(t,b,Z,J,S){super(b,S),this._operation=Z,this._className=J,this.a=this.registerDataInput("a",t)}_doOperation(t){return this._operation(this.a.getValue(t))}getClassName(){return this._className}}}}]);