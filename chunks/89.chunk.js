"use strict";(self.ex92n20nlz8=self.ex92n20nlz8||[]).push([[89],{15780:(I,g,b)=>{b.r(g),b.d(g,{FlowGraphAngleBetweenBlock:()=>mI,FlowGraphAxisAngleFromQuaternionBlock:()=>F,FlowGraphConjugateBlock:()=>E,FlowGraphCrossBlock:()=>f,FlowGraphDotBlock:()=>S,FlowGraphLengthBlock:()=>Z,FlowGraphNormalizeBlock:()=>k,FlowGraphQuaternionFromAxisAngleBlock:()=>s,FlowGraphQuaternionFromDirectionsBlock:()=>Y,FlowGraphRotate2DBlock:()=>V,FlowGraphRotate3DBlock:()=>a,FlowGraphTransformBlock:()=>X,FlowGraphTransformCoordinatesBlock:()=>R});var e=b(14295),c=b(14282),z=b(12558),M=b(15771),J=b(15778),o=b(12590),n=b(14302),G=b(13968);const D="cachedOperationAxis",p="cachedOperationAngle",x="cachedExecutionId";class Z extends J.b{constructor(I){super(c.c,c.t,(I=>this._polymorphicLength(I)),"FlowGraphLengthBlock",I)}_polymorphicLength(I){switch((0,n.j)(I)){case"Vector2":case"Vg":case"Vector4":case"Quaternion":return I.length();default:throw new Error(`Cannot compute length of value ${I}`)}}}(0,z.g)("FlowGraphLengthBlock",Z);class k extends J.b{constructor(I){super(c.c,c.c,(I=>this._polymorphicNormalize(I)),"FlowGraphNormalizeBlock",I)}_polymorphicNormalize(I){var g;let b;switch((0,n.j)(I)){case"Vector2":case"Vg":case"Vector4":case"Quaternion":if(b=I.normalizeToNew(),null!==(g=this.config)&&void 0!==g&&g.nanOnZeroLength){0===I.length()&&b.kb(NaN)}return b;default:throw new Error(`Cannot normalize value ${I}`)}}}(0,z.g)("FlowGraphNormalizeBlock",k);class S extends M.d{constructor(I){super(c.c,c.c,c.t,((I,g)=>this._polymorphicDot(I,g)),"FlowGraphDotBlock",I)}_polymorphicDot(I,g){switch((0,n.j)(I)){case"Vector2":case"Vg":case"Vector4":case"Quaternion":return I.dot(g);default:throw new Error(`Cannot get dot product of ${I} and ${g}`)}}}(0,z.g)("FlowGraphDotBlock",S);class f extends M.d{constructor(I){super(c.C,c.C,c.C,((I,g)=>o.Vg.Cross(I,g)),"FlowGraphCrossBlock",I)}}(0,z.g)("FlowGraphCrossBlock",f);class V extends M.d{constructor(I){super(c.A,c.t,c.A,((I,g)=>I.rotate(g)),"FlowGraphRotate2DBlock",I)}}(0,z.g)("FlowGraphRotate2DBlock",V);class a extends M.d{constructor(I){super(c.C,c.u,c.C,((I,g)=>I.applyRotationQuaternion(g)),"FlowGraphRotate3DBlock",I)}}function v(I,g){switch((0,n.j)(I)){case"Vector2":case"Vg":return g.transformVector(I);case"Vector4":return new o.Vector4(I.x*g.m[0]+I.y*g.m[1]+I.z*g.m[2]+I.w*g.m[3],I.x*g.m[4]+I.y*g.m[5]+I.z*g.m[6]+I.w*g.m[7],I.x*g.m[8]+I.y*g.m[9]+I.z*g.m[10]+I.w*g.m[11],I.x*g.m[12]+I.y*g.m[13]+I.z*g.m[14]+I.w*g.m[15]);default:throw new Error(`Cannot transform value ${I}`)}}(0,z.g)("FlowGraphRotate3DBlock",a);class X extends M.d{constructor(I){const g=(null===I||void 0===I?void 0:I.vectorType)||"Vg",b="Vector2"===g?"Matrix2D":"Vg"===g?"Matrix3D":"Matrix";super((0,c.I)(g),(0,c.I)(b),(0,c.I)(g),v,"FlowGraphTransformVectorBlock",I)}}(0,z.g)("FlowGraphTransformVectorBlock",X);class R extends M.d{constructor(I){super(c.C,c.l,c.C,((I,g)=>o.Vg.TransformCoordinates(I,g)),"FlowGraphTransformCoordinatesBlock",I)}}(0,z.g)("FlowGraphTransformCoordinatesBlock",R);class E extends J.b{constructor(I){super(c.u,c.u,(I=>I.conjugate()),"FlowGraphConjugateBlock",I)}}(0,z.g)("FlowGraphConjugateBlock",E);class mI extends M.d{constructor(I){super(c.u,c.u,c.t,((I,g)=>(0,G.d)(I,g)),"FlowGraphAngleBetweenBlock",I)}}(0,z.g)("FlowGraphAngleBetweenBlock",mI);class s extends M.d{constructor(I){super(c.C,c.t,c.u,((I,g)=>o.Quaternion.RotationAxis(I,g)),"FlowGraphQuaternionFromAxisAngleBlock",I)}}(0,z.g)("FlowGraphQuaternionFromAxisAngleBlock",s);class F extends e.d{constructor(I){super(I),this.a=this.registerDataInput("a",c.u),this.axis=this.registerDataOutput("axis",c.C),this.angle=this.registerDataOutput("angle",c.t),this.isValid=this.registerDataOutput("isValid",c.g)}_updateOutputs(I){const g=I._getExecutionVariable(this,x,-1),b=I._getExecutionVariable(this,D,null),e=I._getExecutionVariable(this,p,null);if(void 0!==b&&null!==b&&void 0!==e&&null!==e&&g===I.executionId)this.axis.setValue(b,I),this.angle.setValue(e,I);else try{const{axis:g,angle:b}=this.a.getValue(I).toAxisAngle();I._setExecutionVariable(this,D,g),I._setExecutionVariable(this,p,b),I._setExecutionVariable(this,x,I.executionId),this.axis.setValue(g,I),this.angle.setValue(b,I),this.isValid.setValue(!0,I)}catch(c){this.isValid.setValue(!1,I)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,z.g)("FlowGraphAxisAngleFromQuaternionBlock",F);class Y extends M.d{constructor(I){super(c.C,c.C,c.u,((I,g)=>(0,G.g)(I,g)),"FlowGraphQuaternionFromDirectionsBlock",I)}}},15771:(I,g,b)=>{b.d(g,{d:()=>c});var e=b(15776);class c extends e.d{constructor(I,g,b,e,c,z){super(b,z),this._operation=e,this._className=c,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",g)}_doOperation(I){const g=this.a.getValue(I),b=this.b.getValue(I);return this._operation(g,b)}getClassName(){return this._className}}},15776:(I,g,b)=>{b.d(g,{d:()=>J});var e=b(14295),c=b(14282);const z="cachedOperationValue",M="cachedExecutionId";class J extends e.d{constructor(I,g){super(g),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",c.g)}_updateOutputs(I){const g=I._getExecutionVariable(this,M,-1),b=I._getExecutionVariable(this,z,null);if(void 0!==b&&null!==b&&g===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(b,I);else try{const g=this._doOperation(I);if(void 0===g||null===g)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,z,g),I._setExecutionVariable(this,M,I.executionId),this.value.setValue(g,I),this.isValid.setValue(!0,I)}catch(e){this.isValid.setValue(!1,I)}}}},15778:(I,g,b)=>{b.d(g,{b:()=>c});var e=b(15776);class c extends e.d{constructor(I,g,b,e,c){super(g,c),this._operation=b,this._className=e,this.a=this.registerDataInput("a",I)}_doOperation(I){return this._operation(this.a.getValue(I))}getClassName(){return this._className}}}}]);