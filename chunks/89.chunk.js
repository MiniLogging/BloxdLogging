"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[89],{16263:(B,u,F)=>{F.r(u),F.d(u,{FlowGraphAngleBetweenBlock:()=>O,FlowGraphAxisAngleFromQuaternionBlock:()=>J,FlowGraphConjugateBlock:()=>y,FlowGraphCrossBlock:()=>W,FlowGraphDotBlock:()=>q,FlowGraphLengthBlock:()=>D,FlowGraphNormalizeBlock:()=>L,FlowGraphQuaternionFromAxisAngleBlock:()=>g,FlowGraphQuaternionFromDirectionsBlock:()=>a,FlowGraphRotate2DBlock:()=>X,FlowGraphRotate3DBlock:()=>f,FlowGraphTransformBlock:()=>x,FlowGraphTransformCoordinatesBlock:()=>U});var Z=F(14720),V=F(14701),p=F(12949),G=F(16241),R=F(16255),e=F(12979),s=F(14725),Y=F(14354);const Q="cachedOperationAxis",t="cachedOperationAngle",v="cachedExecutionId";class D extends R.d{constructor(B){super(V.c,V.u,(B=>this._polymorphicLength(B)),"FlowGraphLengthBlock",B)}_polymorphicLength(B){switch((0,s.h)(B)){case"Vector2":case"Du":case"Vector4":case"Quaternion":return B.length();default:throw new Error(`Cannot compute length of value ${B}`)}}}(0,p.f)("FlowGraphLengthBlock",D);class L extends R.d{constructor(B){super(V.c,V.c,(B=>this._polymorphicNormalize(B)),"FlowGraphNormalizeBlock",B)}_polymorphicNormalize(B){var u;let F;switch((0,s.h)(B)){case"Vector2":case"Du":case"Vector4":case"Quaternion":if(F=B.normalizeToNew(),null!==(u=this.config)&&void 0!==u&&u.nanOnZeroLength){0===B.length()&&F.OR(NaN)}return F;default:throw new Error(`Cannot normalize value ${B}`)}}}(0,p.f)("FlowGraphNormalizeBlock",L);class q extends G.c{constructor(B){super(V.c,V.c,V.u,((B,u)=>this._polymorphicDot(B,u)),"FlowGraphDotBlock",B)}_polymorphicDot(B,u){switch((0,s.h)(B)){case"Vector2":case"Du":case"Vector4":case"Quaternion":return B.dot(u);default:throw new Error(`Cannot get dot product of ${B} and ${u}`)}}}(0,p.f)("FlowGraphDotBlock",q);class W extends G.c{constructor(B){super(V.E,V.E,V.E,((B,u)=>e.Du.Cross(B,u)),"FlowGraphCrossBlock",B)}}(0,p.f)("FlowGraphCrossBlock",W);class X extends G.c{constructor(B){super(V.D,V.u,V.D,((B,u)=>B.rotate(u)),"FlowGraphRotate2DBlock",B)}}(0,p.f)("FlowGraphRotate2DBlock",X);class f extends G.c{constructor(B){super(V.E,V.y,V.E,((B,u)=>B.applyRotationQuaternion(u)),"FlowGraphRotate3DBlock",B)}}function C(B,u){switch((0,s.h)(B)){case"Vector2":case"Du":return u.transformVector(B);case"Vector4":return new e.Vector4(B.x*u.m[0]+B.y*u.m[1]+B.z*u.m[2]+B.w*u.m[3],B.x*u.m[4]+B.y*u.m[5]+B.z*u.m[6]+B.w*u.m[7],B.x*u.m[8]+B.y*u.m[9]+B.z*u.m[10]+B.w*u.m[11],B.x*u.m[12]+B.y*u.m[13]+B.z*u.m[14]+B.w*u.m[15]);default:throw new Error(`Cannot transform value ${B}`)}}(0,p.f)("FlowGraphRotate3DBlock",f);class x extends G.c{constructor(B){const u=(null===B||void 0===B?void 0:B.vectorType)||"Du",F="Vector2"===u?"Matrix2D":"Du"===u?"Matrix3D":"Matrix";super((0,V.M)(u),(0,V.M)(F),(0,V.M)(u),C,"FlowGraphTransformVectorBlock",B)}}(0,p.f)("FlowGraphTransformVectorBlock",x);class U extends G.c{constructor(B){super(V.E,V.i,V.E,((B,u)=>e.Du.TransformCoordinates(B,u)),"FlowGraphTransformCoordinatesBlock",B)}}(0,p.f)("FlowGraphTransformCoordinatesBlock",U);class y extends R.d{constructor(B){super(V.y,V.y,(B=>B.conjugate()),"FlowGraphConjugateBlock",B)}}(0,p.f)("FlowGraphConjugateBlock",y);class O extends G.c{constructor(B){super(V.y,V.y,V.u,((B,u)=>(0,Y.b)(B,u)),"FlowGraphAngleBetweenBlock",B)}}(0,p.f)("FlowGraphAngleBetweenBlock",O);class g extends G.c{constructor(B){super(V.E,V.u,V.y,((B,u)=>e.Quaternion.RotationAxis(B,u)),"FlowGraphQuaternionFromAxisAngleBlock",B)}}(0,p.f)("FlowGraphQuaternionFromAxisAngleBlock",g);class J extends Z.e{constructor(B){super(B),this.a=this.registerDataInput("a",V.y),this.axis=this.registerDataOutput("axis",V.E),this.angle=this.registerDataOutput("angle",V.u),this.isValid=this.registerDataOutput("isValid",V.f)}_updateOutputs(B){const u=B._getExecutionVariable(this,v,-1),F=B._getExecutionVariable(this,Q,null),Z=B._getExecutionVariable(this,t,null);if(void 0!==F&&null!==F&&void 0!==Z&&null!==Z&&u===B.executionId)this.axis.setValue(F,B),this.angle.setValue(Z,B);else try{const{axis:u,angle:F}=this.a.getValue(B).toAxisAngle();B._setExecutionVariable(this,Q,u),B._setExecutionVariable(this,t,F),B._setExecutionVariable(this,v,B.executionId),this.axis.setValue(u,B),this.angle.setValue(F,B),this.isValid.setValue(!0,B)}catch(V){this.isValid.setValue(!1,B)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,p.f)("FlowGraphAxisAngleFromQuaternionBlock",J);class a extends G.c{constructor(B){super(V.E,V.E,V.y,((B,u)=>(0,Y.d)(B,u)),"FlowGraphQuaternionFromDirectionsBlock",B)}}},16241:(B,u,F)=>{F.d(u,{c:()=>V});var Z=F(16250);class V extends Z.c{constructor(B,u,F,Z,V,p){super(F,p),this._operation=Z,this._className=V,this.a=this.registerDataInput("a",B),this.b=this.registerDataInput("b",u)}_doOperation(B){const u=this.a.getValue(B),F=this.b.getValue(B);return this._operation(u,F)}getClassName(){return this._className}}},16250:(B,u,F)=>{F.d(u,{c:()=>R});var Z=F(14720),V=F(14701);const p="cachedOperationValue",G="cachedExecutionId";class R extends Z.e{constructor(B,u){super(u),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",V.f)}_updateOutputs(B){const u=B._getExecutionVariable(this,G,-1),F=B._getExecutionVariable(this,p,null);if(void 0!==F&&null!==F&&u===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(F,B);else try{const u=this._doOperation(B);if(void 0===u||null===u)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,p,u),B._setExecutionVariable(this,G,B.executionId),this.value.setValue(u,B),this.isValid.setValue(!0,B)}catch(Z){this.isValid.setValue(!1,B)}}}},16255:(B,u,F)=>{F.d(u,{d:()=>V});var Z=F(16250);class V extends Z.c{constructor(B,u,F,Z,V){super(u,V),this._operation=F,this._className=Z,this.a=this.registerDataInput("a",B)}_doOperation(B){return this._operation(this.a.getValue(B))}getClassName(){return this._className}}}}]);