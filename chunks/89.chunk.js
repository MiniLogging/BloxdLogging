"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14397:(h,V,i)=>{i.r(V),i.d(V,{FlowGraphAngleBetweenBlock:()=>O,FlowGraphAxisAngleFromQuaternionBlock:()=>M,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>c,FlowGraphDotBlock:()=>n,FlowGraphLengthBlock:()=>T,FlowGraphNormalizeBlock:()=>e,FlowGraphQuaternionFromAxisAngleBlock:()=>o,FlowGraphQuaternionFromDirectionsBlock:()=>F,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>P,FlowGraphTransformBlock:()=>U,FlowGraphTransformCoordinatesBlock:()=>X});var S=i(12827),l=i(12805),Y=i(11091),g=i(14373),q=i(14389),B=i(11138),J=i(12841),I=i(12493);const v="cachedOperationAxis",s="cachedOperationAngle",t="cachedExecutionId";class T extends q.b{constructor(h){super(l.c,l.u,(h=>this._polymorphicLength(h)),"FlowGraphLengthBlock",h)}_polymorphicLength(h){switch((0,J.h)(h)){case"Vector2":case"nV":case"Vector4":case"Quaternion":return h.length();default:throw new Error(`Cannot compute length of value ${h}`)}}}(0,Y.f)("FlowGraphLengthBlock",T);class e extends q.b{constructor(h){super(l.c,l.c,(h=>this._polymorphicNormalize(h)),"FlowGraphNormalizeBlock",h)}_polymorphicNormalize(h){var V;let i;switch((0,J.h)(h)){case"Vector2":case"nV":case"Vector4":case"Quaternion":if(i=h.normalizeToNew(),null!==(V=this.config)&&void 0!==V&&V.nanOnZeroLength){0===h.length()&&i.Iq(NaN)}return i;default:throw new Error(`Cannot normalize value ${h}`)}}}(0,Y.f)("FlowGraphNormalizeBlock",e);class n extends g.d{constructor(h){super(l.c,l.c,l.u,((h,V)=>this._polymorphicDot(h,V)),"FlowGraphDotBlock",h)}_polymorphicDot(h,V){switch((0,J.h)(h)){case"Vector2":case"nV":case"Vector4":case"Quaternion":return h.dot(V);default:throw new Error(`Cannot get dot product of ${h} and ${V}`)}}}(0,Y.f)("FlowGraphDotBlock",n);class c extends g.d{constructor(h){super(l.F,l.F,l.F,((h,V)=>B.nV.Cross(h,V)),"FlowGraphCrossBlock",h)}}(0,Y.f)("FlowGraphCrossBlock",c);class f extends g.d{constructor(h){super(l.C,l.u,l.C,((h,V)=>h.rotate(V)),"FlowGraphRotate2DBlock",h)}}(0,Y.f)("FlowGraphRotate2DBlock",f);class P extends g.d{constructor(h){super(l.F,l.y,l.F,((h,V)=>h.applyRotationQuaternion(V)),"FlowGraphRotate3DBlock",h)}}function L(h,V){switch((0,J.h)(h)){case"Vector2":case"nV":return V.transformVector(h);case"Vector4":return new B.Vector4(h.x*V.m[0]+h.y*V.m[1]+h.z*V.m[2]+h.w*V.m[3],h.x*V.m[4]+h.y*V.m[5]+h.z*V.m[6]+h.w*V.m[7],h.x*V.m[8]+h.y*V.m[9]+h.z*V.m[10]+h.w*V.m[11],h.x*V.m[12]+h.y*V.m[13]+h.z*V.m[14]+h.w*V.m[15]);default:throw new Error(`Cannot transform value ${h}`)}}(0,Y.f)("FlowGraphRotate3DBlock",P);class U extends g.d{constructor(h){const V=(null===h||void 0===h?void 0:h.vectorType)||"nV",i="Vector2"===V?"Matrix2D":"nV"===V?"Matrix3D":"Matrix";super((0,l.M)(V),(0,l.M)(i),(0,l.M)(V),L,"FlowGraphTransformVectorBlock",h)}}(0,Y.f)("FlowGraphTransformVectorBlock",U);class X extends g.d{constructor(h){super(l.F,l.m,l.F,((h,V)=>B.nV.TransformCoordinates(h,V)),"FlowGraphTransformCoordinatesBlock",h)}}(0,Y.f)("FlowGraphTransformCoordinatesBlock",X);class D extends q.b{constructor(h){super(l.y,l.y,(h=>h.conjugate()),"FlowGraphConjugateBlock",h)}}(0,Y.f)("FlowGraphConjugateBlock",D);class O extends g.d{constructor(h){super(l.y,l.y,l.u,((h,V)=>(0,I.b)(h,V)),"FlowGraphAngleBetweenBlock",h)}}(0,Y.f)("FlowGraphAngleBetweenBlock",O);class o extends g.d{constructor(h){super(l.F,l.u,l.y,((h,V)=>B.Quaternion.RotationAxis(h,V)),"FlowGraphQuaternionFromAxisAngleBlock",h)}}(0,Y.f)("FlowGraphQuaternionFromAxisAngleBlock",o);class M extends S.c{constructor(h){super(h),this.a=this.registerDataInput("a",l.y),this.axis=this.registerDataOutput("axis",l.F),this.angle=this.registerDataOutput("angle",l.u),this.isValid=this.registerDataOutput("isValid",l.f)}_updateOutputs(h){const V=h._getExecutionVariable(this,t,-1),i=h._getExecutionVariable(this,v,null),S=h._getExecutionVariable(this,s,null);if(void 0!==i&&null!==i&&void 0!==S&&null!==S&&V===h.executionId)this.axis.setValue(i,h),this.angle.setValue(S,h);else try{const{axis:V,angle:i}=this.a.getValue(h).toAxisAngle();h._setExecutionVariable(this,v,V),h._setExecutionVariable(this,s,i),h._setExecutionVariable(this,t,h.executionId),this.axis.setValue(V,h),this.angle.setValue(i,h),this.isValid.setValue(!0,h)}catch(l){this.isValid.setValue(!1,h)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,Y.f)("FlowGraphAxisAngleFromQuaternionBlock",M);class F extends g.d{constructor(h){super(l.F,l.F,l.y,((h,V)=>(0,I.d)(h,V)),"FlowGraphQuaternionFromDirectionsBlock",h)}}},14373:(h,V,i)=>{i.d(V,{d:()=>l});var S=i(14382);class l extends S.d{constructor(h,V,i,S,l,Y){super(i,Y),this._operation=S,this._className=l,this.a=this.registerDataInput("a",h),this.b=this.registerDataInput("b",V)}_doOperation(h){const V=this.a.getValue(h),i=this.b.getValue(h);return this._operation(V,i)}getClassName(){return this._className}}},14382:(h,V,i)=>{i.d(V,{d:()=>q});var S=i(12827),l=i(12805);const Y="cachedOperationValue",g="cachedExecutionId";class q extends S.c{constructor(h,V){super(V),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",l.f)}_updateOutputs(h){const V=h._getExecutionVariable(this,g,-1),i=h._getExecutionVariable(this,Y,null);if(void 0!==i&&null!==i&&V===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(i,h);else try{const V=this._doOperation(h);if(void 0===V||null===V)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,Y,V),h._setExecutionVariable(this,g,h.executionId),this.value.setValue(V,h),this.isValid.setValue(!0,h)}catch(S){this.isValid.setValue(!1,h)}}}},14389:(h,V,i)=>{i.d(V,{b:()=>l});var S=i(14382);class l extends S.d{constructor(h,V,i,S,l){super(V,l),this._operation=i,this._className=S,this.a=this.registerDataInput("a",h)}_doOperation(h){return this._operation(this.a.getValue(h))}getClassName(){return this._className}}}}]);