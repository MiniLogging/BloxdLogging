"use strict";(self.kdlk57exiqh=self.kdlk57exiqh||[]).push([[89],{15383:(i,x,e)=>{e.r(x),e.d(x,{FlowGraphAngleBetweenBlock:()=>O,FlowGraphAxisAngleFromQuaternionBlock:()=>Z,FlowGraphConjugateBlock:()=>w,FlowGraphCrossBlock:()=>T,FlowGraphDotBlock:()=>z,FlowGraphLengthBlock:()=>o,FlowGraphNormalizeBlock:()=>M,FlowGraphQuaternionFromAxisAngleBlock:()=>l,FlowGraphQuaternionFromDirectionsBlock:()=>B,FlowGraphRotate2DBlock:()=>Q,FlowGraphRotate3DBlock:()=>t,FlowGraphTransformBlock:()=>S,FlowGraphTransformCoordinatesBlock:()=>f});var j=e(13900),E=e(13874),a=e(12204),Y=e(15364),J=e(15375),u=e(12250),b=e(13912),g=e(13576);const A="cachedOperationAxis",K="cachedOperationAngle",L="cachedExecutionId";class o extends J.e{constructor(i){super(E.c,E.q,(i=>this._polymorphicLength(i)),"FlowGraphLengthBlock",i)}_polymorphicLength(i){switch((0,b.l)(i)){case"Vector2":case"KJ":case"Vector4":case"Quaternion":return i.length();default:throw new Error(`Cannot compute length of value ${i}`)}}}(0,a.f)("FlowGraphLengthBlock",o);class M extends J.e{constructor(i){super(E.c,E.c,(i=>this._polymorphicNormalize(i)),"FlowGraphNormalizeBlock",i)}_polymorphicNormalize(i){var x;let e;switch((0,b.l)(i)){case"Vector2":case"KJ":case"Vector4":case"Quaternion":if(e=i.normalizeToNew(),null!==(x=this.config)&&void 0!==x&&x.nanOnZeroLength){0===i.length()&&e.OJ(NaN)}return e;default:throw new Error(`Cannot normalize value ${i}`)}}}(0,a.f)("FlowGraphNormalizeBlock",M);class z extends Y.d{constructor(i){super(E.c,E.c,E.q,((i,x)=>this._polymorphicDot(i,x)),"FlowGraphDotBlock",i)}_polymorphicDot(i,x){switch((0,b.l)(i)){case"Vector2":case"KJ":case"Vector4":case"Quaternion":return i.dot(x);default:throw new Error(`Cannot get dot product of ${i} and ${x}`)}}}(0,a.f)("FlowGraphDotBlock",z);class T extends Y.d{constructor(i){super(E.E,E.E,E.E,((i,x)=>u.KJ.Cross(i,x)),"FlowGraphCrossBlock",i)}}(0,a.f)("FlowGraphCrossBlock",T);class Q extends Y.d{constructor(i){super(E.A,E.q,E.A,((i,x)=>i.rotate(x)),"FlowGraphRotate2DBlock",i)}}(0,a.f)("FlowGraphRotate2DBlock",Q);class t extends Y.d{constructor(i){super(E.E,E.s,E.E,((i,x)=>i.applyRotationQuaternion(x)),"FlowGraphRotate3DBlock",i)}}function V(i,x){switch((0,b.l)(i)){case"Vector2":case"KJ":return x.transformVector(i);case"Vector4":return new u.Vector4(i.x*x.m[0]+i.y*x.m[1]+i.z*x.m[2]+i.w*x.m[3],i.x*x.m[4]+i.y*x.m[5]+i.z*x.m[6]+i.w*x.m[7],i.x*x.m[8]+i.y*x.m[9]+i.z*x.m[10]+i.w*x.m[11],i.x*x.m[12]+i.y*x.m[13]+i.z*x.m[14]+i.w*x.m[15]);default:throw new Error(`Cannot transform value ${i}`)}}(0,a.f)("FlowGraphRotate3DBlock",t);class S extends Y.d{constructor(i){const x=(null===i||void 0===i?void 0:i.vectorType)||"KJ",e="Vector2"===x?"Matrix2D":"KJ"===x?"Matrix3D":"Matrix";super((0,E.N)(x),(0,E.N)(e),(0,E.N)(x),V,"FlowGraphTransformVectorBlock",i)}}(0,a.f)("FlowGraphTransformVectorBlock",S);class f extends Y.d{constructor(i){super(E.E,E.i,E.E,((i,x)=>u.KJ.TransformCoordinates(i,x)),"FlowGraphTransformCoordinatesBlock",i)}}(0,a.f)("FlowGraphTransformCoordinatesBlock",f);class w extends J.e{constructor(i){super(E.s,E.s,(i=>i.conjugate()),"FlowGraphConjugateBlock",i)}}(0,a.f)("FlowGraphConjugateBlock",w);class O extends Y.d{constructor(i){super(E.s,E.s,E.q,((i,x)=>(0,g.e)(i,x)),"FlowGraphAngleBetweenBlock",i)}}(0,a.f)("FlowGraphAngleBetweenBlock",O);class l extends Y.d{constructor(i){super(E.E,E.q,E.s,((i,x)=>u.Quaternion.RotationAxis(i,x)),"FlowGraphQuaternionFromAxisAngleBlock",i)}}(0,a.f)("FlowGraphQuaternionFromAxisAngleBlock",l);class Z extends j.e{constructor(i){super(i),this.a=this.registerDataInput("a",E.s),this.axis=this.registerDataOutput("axis",E.E),this.angle=this.registerDataOutput("angle",E.q),this.isValid=this.registerDataOutput("isValid",E.g)}_updateOutputs(i){const x=i._getExecutionVariable(this,L,-1),e=i._getExecutionVariable(this,A,null),j=i._getExecutionVariable(this,K,null);if(void 0!==e&&null!==e&&void 0!==j&&null!==j&&x===i.executionId)this.axis.setValue(e,i),this.angle.setValue(j,i);else try{const{axis:x,angle:e}=this.a.getValue(i).toAxisAngle();i._setExecutionVariable(this,A,x),i._setExecutionVariable(this,K,e),i._setExecutionVariable(this,L,i.executionId),this.axis.setValue(x,i),this.angle.setValue(e,i),this.isValid.setValue(!0,i)}catch(E){this.isValid.setValue(!1,i)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,a.f)("FlowGraphAxisAngleFromQuaternionBlock",Z);class B extends Y.d{constructor(i){super(E.E,E.E,E.s,((i,x)=>(0,g.f)(i,x)),"FlowGraphQuaternionFromDirectionsBlock",i)}}},15364:(i,x,e)=>{e.d(x,{d:()=>E});var j=e(15373);class E extends j.c{constructor(i,x,e,j,E,a){super(e,a),this._operation=j,this._className=E,this.a=this.registerDataInput("a",i),this.b=this.registerDataInput("b",x)}_doOperation(i){const x=this.a.getValue(i),e=this.b.getValue(i);return this._operation(x,e)}getClassName(){return this._className}}},15373:(i,x,e)=>{e.d(x,{c:()=>J});var j=e(13900),E=e(13874);const a="cachedOperationValue",Y="cachedExecutionId";class J extends j.e{constructor(i,x){super(x),this.value=this.registerDataOutput("value",i),this.isValid=this.registerDataOutput("isValid",E.g)}_updateOutputs(i){const x=i._getExecutionVariable(this,Y,-1),e=i._getExecutionVariable(this,a,null);if(void 0!==e&&null!==e&&x===i.executionId)this.isValid.setValue(!0,i),this.value.setValue(e,i);else try{const x=this._doOperation(i);if(void 0===x||null===x)return void this.isValid.setValue(!1,i);i._setExecutionVariable(this,a,x),i._setExecutionVariable(this,Y,i.executionId),this.value.setValue(x,i),this.isValid.setValue(!0,i)}catch(j){this.isValid.setValue(!1,i)}}}},15375:(i,x,e)=>{e.d(x,{e:()=>E});var j=e(15373);class E extends j.c{constructor(i,x,e,j,E){super(x,E),this._operation=e,this._className=j,this.a=this.registerDataInput("a",i)}_doOperation(i){return this._operation(this.a.getValue(i))}getClassName(){return this._className}}}}]);