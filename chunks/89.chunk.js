"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[89],{14296:(P,e,n)=>{n.r(e),n.d(e,{FlowGraphAngleBetweenBlock:()=>l,FlowGraphAxisAngleFromQuaternionBlock:()=>T,FlowGraphConjugateBlock:()=>B,FlowGraphCrossBlock:()=>w,FlowGraphDotBlock:()=>z,FlowGraphLengthBlock:()=>Y,FlowGraphNormalizeBlock:()=>j,FlowGraphQuaternionFromAxisAngleBlock:()=>b,FlowGraphQuaternionFromDirectionsBlock:()=>d,FlowGraphRotate2DBlock:()=>J,FlowGraphRotate3DBlock:()=>I,FlowGraphTransformBlock:()=>V,FlowGraphTransformCoordinatesBlock:()=>i});var H=n(12841),S=n(12819),p=n(11096),k=n(14283),m=n(14293),t=n(11133),C=n(12850),R=n(12516);const q="cachedOperationAxis",A="cachedOperationAngle",F="cachedExecutionId";class Y extends m.b{constructor(P){super(S.b,S.r,(P=>this._polymorphicLength(P)),"FlowGraphLengthBlock",P)}_polymorphicLength(P){switch((0,C.j)(P)){case"Vector2":case"Ie":case"Vector4":case"Quaternion":return P.length();default:throw new Error(`Cannot compute length of value ${P}`)}}}(0,p.h)("FlowGraphLengthBlock",Y);class j extends m.b{constructor(P){super(S.b,S.b,(P=>this._polymorphicNormalize(P)),"FlowGraphNormalizeBlock",P)}_polymorphicNormalize(P){var e;let n;switch((0,C.j)(P)){case"Vector2":case"Ie":case"Vector4":case"Quaternion":if(n=P.normalizeToNew(),null!==(e=this.config)&&void 0!==e&&e.nanOnZeroLength){0===P.length()&&n.zm(NaN)}return n;default:throw new Error(`Cannot normalize value ${P}`)}}}(0,p.h)("FlowGraphNormalizeBlock",j);class z extends k.e{constructor(P){super(S.b,S.b,S.r,((P,e)=>this._polymorphicDot(P,e)),"FlowGraphDotBlock",P)}_polymorphicDot(P,e){switch((0,C.j)(P)){case"Vector2":case"Ie":case"Vector4":case"Quaternion":return P.dot(e);default:throw new Error(`Cannot get dot product of ${P} and ${e}`)}}}(0,p.h)("FlowGraphDotBlock",z);class w extends k.e{constructor(P){super(S.B,S.B,S.B,((P,e)=>t.Ie.Cross(P,e)),"FlowGraphCrossBlock",P)}}(0,p.h)("FlowGraphCrossBlock",w);class J extends k.e{constructor(P){super(S.x,S.r,S.x,((P,e)=>P.rotate(e)),"FlowGraphRotate2DBlock",P)}}(0,p.h)("FlowGraphRotate2DBlock",J);class I extends k.e{constructor(P){super(S.B,S.s,S.B,((P,e)=>P.applyRotationQuaternion(e)),"FlowGraphRotate3DBlock",P)}}function O(P,e){switch((0,C.j)(P)){case"Vector2":case"Ie":return e.transformVector(P);case"Vector4":return new t.Vector4(P.x*e.m[0]+P.y*e.m[1]+P.z*e.m[2]+P.w*e.m[3],P.x*e.m[4]+P.y*e.m[5]+P.z*e.m[6]+P.w*e.m[7],P.x*e.m[8]+P.y*e.m[9]+P.z*e.m[10]+P.w*e.m[11],P.x*e.m[12]+P.y*e.m[13]+P.z*e.m[14]+P.w*e.m[15]);default:throw new Error(`Cannot transform value ${P}`)}}(0,p.h)("FlowGraphRotate3DBlock",I);class V extends k.e{constructor(P){const e=(null===P||void 0===P?void 0:P.vectorType)||"Ie",n="Vector2"===e?"Matrix2D":"Ie"===e?"Matrix3D":"Matrix";super((0,S.M)(e),(0,S.M)(n),(0,S.M)(e),O,"FlowGraphTransformVectorBlock",P)}}(0,p.h)("FlowGraphTransformVectorBlock",V);class i extends k.e{constructor(P){super(S.B,S.h,S.B,((P,e)=>t.Ie.TransformCoordinates(P,e)),"FlowGraphTransformCoordinatesBlock",P)}}(0,p.h)("FlowGraphTransformCoordinatesBlock",i);class B extends m.b{constructor(P){super(S.s,S.s,(P=>P.conjugate()),"FlowGraphConjugateBlock",P)}}(0,p.h)("FlowGraphConjugateBlock",B);class l extends k.e{constructor(P){super(S.s,S.s,S.r,((P,e)=>(0,R.d)(P,e)),"FlowGraphAngleBetweenBlock",P)}}(0,p.h)("FlowGraphAngleBetweenBlock",l);class b extends k.e{constructor(P){super(S.B,S.r,S.s,((P,e)=>t.Quaternion.RotationAxis(P,e)),"FlowGraphQuaternionFromAxisAngleBlock",P)}}(0,p.h)("FlowGraphQuaternionFromAxisAngleBlock",b);class T extends H.c{constructor(P){super(P),this.a=this.registerDataInput("a",S.s),this.axis=this.registerDataOutput("axis",S.B),this.angle=this.registerDataOutput("angle",S.r),this.isValid=this.registerDataOutput("isValid",S.d)}_updateOutputs(P){const e=P._getExecutionVariable(this,F,-1),n=P._getExecutionVariable(this,q,null),H=P._getExecutionVariable(this,A,null);if(void 0!==n&&null!==n&&void 0!==H&&null!==H&&e===P.executionId)this.axis.setValue(n,P),this.angle.setValue(H,P);else try{const{axis:e,angle:n}=this.a.getValue(P).toAxisAngle();P._setExecutionVariable(this,q,e),P._setExecutionVariable(this,A,n),P._setExecutionVariable(this,F,P.executionId),this.axis.setValue(e,P),this.angle.setValue(n,P),this.isValid.setValue(!0,P)}catch(S){this.isValid.setValue(!1,P)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,p.h)("FlowGraphAxisAngleFromQuaternionBlock",T);class d extends k.e{constructor(P){super(S.B,S.B,S.s,((P,e)=>(0,R.f)(P,e)),"FlowGraphQuaternionFromDirectionsBlock",P)}}},14283:(P,e,n)=>{n.d(e,{e:()=>S});var H=n(14286);class S extends H.c{constructor(P,e,n,H,S,p){super(n,p),this._operation=H,this._className=S,this.a=this.registerDataInput("a",P),this.b=this.registerDataInput("b",e)}_doOperation(P){const e=this.a.getValue(P),n=this.b.getValue(P);return this._operation(e,n)}getClassName(){return this._className}}},14286:(P,e,n)=>{n.d(e,{c:()=>m});var H=n(12841),S=n(12819);const p="cachedOperationValue",k="cachedExecutionId";class m extends H.c{constructor(P,e){super(e),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",S.d)}_updateOutputs(P){const e=P._getExecutionVariable(this,k,-1),n=P._getExecutionVariable(this,p,null);if(void 0!==n&&null!==n&&e===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(n,P);else try{const e=this._doOperation(P);if(void 0===e||null===e)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,p,e),P._setExecutionVariable(this,k,P.executionId),this.value.setValue(e,P),this.isValid.setValue(!0,P)}catch(H){this.isValid.setValue(!1,P)}}}},14293:(P,e,n)=>{n.d(e,{b:()=>S});var H=n(14286);class S extends H.c{constructor(P,e,n,H,S){super(e,S),this._operation=n,this._className=H,this.a=this.registerDataInput("a",P)}_doOperation(P){return this._operation(this.a.getValue(P))}getClassName(){return this._className}}}}]);