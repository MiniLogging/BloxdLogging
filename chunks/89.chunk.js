"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[89],{15406:(t,U,y)=>{y.r(U),y.d(U,{FlowGraphAngleBetweenBlock:()=>f,FlowGraphAxisAngleFromQuaternionBlock:()=>N,FlowGraphConjugateBlock:()=>c,FlowGraphCrossBlock:()=>D,FlowGraphDotBlock:()=>w,FlowGraphLengthBlock:()=>F,FlowGraphNormalizeBlock:()=>E,FlowGraphQuaternionFromAxisAngleBlock:()=>S,FlowGraphQuaternionFromDirectionsBlock:()=>j,FlowGraphRotate2DBlock:()=>l,FlowGraphRotate3DBlock:()=>g,FlowGraphTransformBlock:()=>b,FlowGraphTransformCoordinatesBlock:()=>p});var I=y(13865),r=y(13845),Y=y(12338),mt=y(15390),X=y(15398),P=y(12386),G=y(13879),M=y(13547);const L="cachedOperationAxis",h="cachedOperationAngle",Q="cachedExecutionId";class F extends X.c{constructor(t){super(r.e,r.w,(t=>this._polymorphicLength(t)),"FlowGraphLengthBlock",t)}_polymorphicLength(t){switch((0,G.n)(t)){case"Vector2":case"DU":case"Vector4":case"Quaternion":return t.length();default:throw new Error(`Cannot compute length of value ${t}`)}}}(0,Y.f)("FlowGraphLengthBlock",F);class E extends X.c{constructor(t){super(r.e,r.e,(t=>this._polymorphicNormalize(t)),"FlowGraphNormalizeBlock",t)}_polymorphicNormalize(t){var U;let y;switch((0,G.n)(t)){case"Vector2":case"DU":case"Vector4":case"Quaternion":if(y=t.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===t.length()&&y.qX(NaN)}return y;default:throw new Error(`Cannot normalize value ${t}`)}}}(0,Y.f)("FlowGraphNormalizeBlock",E);class w extends mt.e{constructor(t){super(r.e,r.e,r.w,((t,U)=>this._polymorphicDot(t,U)),"FlowGraphDotBlock",t)}_polymorphicDot(t,U){switch((0,G.n)(t)){case"Vector2":case"DU":case"Vector4":case"Quaternion":return t.dot(U);default:throw new Error(`Cannot get dot product of ${t} and ${U}`)}}}(0,Y.f)("FlowGraphDotBlock",w);class D extends mt.e{constructor(t){super(r.H,r.H,r.H,((t,U)=>P.DU.Cross(t,U)),"FlowGraphCrossBlock",t)}}(0,Y.f)("FlowGraphCrossBlock",D);class l extends mt.e{constructor(t){super(r.D,r.w,r.D,((t,U)=>t.rotate(U)),"FlowGraphRotate2DBlock",t)}}(0,Y.f)("FlowGraphRotate2DBlock",l);class g extends mt.e{constructor(t){super(r.H,r.y,r.H,((t,U)=>t.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",t)}}function B(t,U){switch((0,G.n)(t)){case"Vector2":case"DU":return U.transformVector(t);case"Vector4":return new P.Vector4(t.x*U.m[0]+t.y*U.m[1]+t.z*U.m[2]+t.w*U.m[3],t.x*U.m[4]+t.y*U.m[5]+t.z*U.m[6]+t.w*U.m[7],t.x*U.m[8]+t.y*U.m[9]+t.z*U.m[10]+t.w*U.m[11],t.x*U.m[12]+t.y*U.m[13]+t.z*U.m[14]+t.w*U.m[15]);default:throw new Error(`Cannot transform value ${t}`)}}(0,Y.f)("FlowGraphRotate3DBlock",g);class b extends mt.e{constructor(t){const U=(null===t||void 0===t?void 0:t.vectorType)||"DU",y="Vector2"===U?"Matrix2D":"DU"===U?"Matrix3D":"Matrix";super((0,r.S)(U),(0,r.S)(y),(0,r.S)(U),B,"FlowGraphTransformVectorBlock",t)}}(0,Y.f)("FlowGraphTransformVectorBlock",b);class p extends mt.e{constructor(t){super(r.H,r.m,r.H,((t,U)=>P.DU.TransformCoordinates(t,U)),"FlowGraphTransformCoordinatesBlock",t)}}(0,Y.f)("FlowGraphTransformCoordinatesBlock",p);class c extends X.c{constructor(t){super(r.y,r.y,(t=>t.conjugate()),"FlowGraphConjugateBlock",t)}}(0,Y.f)("FlowGraphConjugateBlock",c);class f extends mt.e{constructor(t){super(r.y,r.y,r.w,((t,U)=>(0,M.c)(t,U)),"FlowGraphAngleBetweenBlock",t)}}(0,Y.f)("FlowGraphAngleBetweenBlock",f);class S extends mt.e{constructor(t){super(r.H,r.w,r.y,((t,U)=>P.Quaternion.RotationAxis(t,U)),"FlowGraphQuaternionFromAxisAngleBlock",t)}}(0,Y.f)("FlowGraphQuaternionFromAxisAngleBlock",S);class N extends I.c{constructor(t){super(t),this.a=this.registerDataInput("a",r.y),this.axis=this.registerDataOutput("axis",r.H),this.angle=this.registerDataOutput("angle",r.w),this.isValid=this.registerDataOutput("isValid",r.i)}_updateOutputs(t){const U=t._getExecutionVariable(this,Q,-1),y=t._getExecutionVariable(this,L,null),I=t._getExecutionVariable(this,h,null);if(void 0!==y&&null!==y&&void 0!==I&&null!==I&&U===t.executionId)this.axis.setValue(y,t),this.angle.setValue(I,t);else try{const{axis:U,angle:y}=this.a.getValue(t).toAxisAngle();t._setExecutionVariable(this,L,U),t._setExecutionVariable(this,h,y),t._setExecutionVariable(this,Q,t.executionId),this.axis.setValue(U,t),this.angle.setValue(y,t),this.isValid.setValue(!0,t)}catch(r){this.isValid.setValue(!1,t)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,Y.f)("FlowGraphAxisAngleFromQuaternionBlock",N);class j extends mt.e{constructor(t){super(r.H,r.H,r.y,((t,U)=>(0,M.e)(t,U)),"FlowGraphQuaternionFromDirectionsBlock",t)}}},15390:(t,U,y)=>{y.d(U,{e:()=>r});var I=y(15392);class r extends I.d{constructor(t,U,y,I,r,Y){super(y,Y),this._operation=I,this._className=r,this.a=this.registerDataInput("a",t),this.b=this.registerDataInput("b",U)}_doOperation(t){const U=this.a.getValue(t),y=this.b.getValue(t);return this._operation(U,y)}getClassName(){return this._className}}},15392:(t,U,y)=>{y.d(U,{d:()=>X});var I=y(13865),r=y(13845);const Y="cachedOperationValue",mt="cachedExecutionId";class X extends I.c{constructor(t,U){super(U),this.value=this.registerDataOutput("value",t),this.isValid=this.registerDataOutput("isValid",r.i)}_updateOutputs(t){const U=t._getExecutionVariable(this,mt,-1),y=t._getExecutionVariable(this,Y,null);if(void 0!==y&&null!==y&&U===t.executionId)this.isValid.setValue(!0,t),this.value.setValue(y,t);else try{const U=this._doOperation(t);if(void 0===U||null===U)return void this.isValid.setValue(!1,t);t._setExecutionVariable(this,Y,U),t._setExecutionVariable(this,mt,t.executionId),this.value.setValue(U,t),this.isValid.setValue(!0,t)}catch(I){this.isValid.setValue(!1,t)}}}},15398:(t,U,y)=>{y.d(U,{c:()=>r});var I=y(15392);class r extends I.d{constructor(t,U,y,I,r){super(U,r),this._operation=y,this._className=I,this.a=this.registerDataInput("a",t)}_doOperation(t){return this._operation(this.a.getValue(t))}getClassName(){return this._className}}}}]);