"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[89],{14654:(S,v,D)=>{D.r(v),D.d(v,{FlowGraphAngleBetweenBlock:()=>W,FlowGraphAxisAngleFromQuaternionBlock:()=>b,FlowGraphConjugateBlock:()=>x,FlowGraphCrossBlock:()=>K,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>R,FlowGraphNormalizeBlock:()=>O,FlowGraphQuaternionFromAxisAngleBlock:()=>p,FlowGraphQuaternionFromDirectionsBlock:()=>k,FlowGraphRotate2DBlock:()=>q,FlowGraphRotate3DBlock:()=>u,FlowGraphTransformBlock:()=>r,FlowGraphTransformCoordinatesBlock:()=>d});var z=D(13123),e=D(13108),N=D(11329),m=D(14644),B=D(14651),g=D(11371),E=D(13139),h=D(12796);const A="cachedOperationAxis",w="cachedOperationAngle",n="cachedExecutionId";class R extends B.e{constructor(S){super(e.d,e.q,(S=>this._polymorphicLength(S)),"FlowGraphLengthBlock",S)}_polymorphicLength(S){switch((0,E.k)(S)){case"Vector2":case"Rv":case"Vector4":case"Quaternion":return S.length();default:throw new Error(`Cannot compute length of value ${S}`)}}}(0,N.f)("FlowGraphLengthBlock",R);class O extends B.e{constructor(S){super(e.d,e.d,(S=>this._polymorphicNormalize(S)),"FlowGraphNormalizeBlock",S)}_polymorphicNormalize(S){var v;let D;switch((0,E.k)(S)){case"Vector2":case"Rv":case"Vector4":case"Quaternion":if(D=S.normalizeToNew(),null!==(v=this.config)&&void 0!==v&&v.nanOnZeroLength){0===S.length()&&D.Je(NaN)}return D;default:throw new Error(`Cannot normalize value ${S}`)}}}(0,N.f)("FlowGraphNormalizeBlock",O);class I extends m.d{constructor(S){super(e.d,e.d,e.q,((S,v)=>this._polymorphicDot(S,v)),"FlowGraphDotBlock",S)}_polymorphicDot(S,v){switch((0,E.k)(S)){case"Vector2":case"Rv":case"Vector4":case"Quaternion":return S.dot(v);default:throw new Error(`Cannot get dot product of ${S} and ${v}`)}}}(0,N.f)("FlowGraphDotBlock",I);class K extends m.d{constructor(S){super(e.E,e.E,e.E,((S,v)=>g.Rv.Cross(S,v)),"FlowGraphCrossBlock",S)}}(0,N.f)("FlowGraphCrossBlock",K);class q extends m.d{constructor(S){super(e.A,e.q,e.A,((S,v)=>S.rotate(v)),"FlowGraphRotate2DBlock",S)}}(0,N.f)("FlowGraphRotate2DBlock",q);class u extends m.d{constructor(S){super(e.E,e.u,e.E,((S,v)=>S.applyRotationQuaternion(v)),"FlowGraphRotate3DBlock",S)}}function s(S,v){switch((0,E.k)(S)){case"Vector2":case"Rv":return v.transformVector(S);case"Vector4":return new g.Vector4(S.x*v.m[0]+S.y*v.m[1]+S.z*v.m[2]+S.w*v.m[3],S.x*v.m[4]+S.y*v.m[5]+S.z*v.m[6]+S.w*v.m[7],S.x*v.m[8]+S.y*v.m[9]+S.z*v.m[10]+S.w*v.m[11],S.x*v.m[12]+S.y*v.m[13]+S.z*v.m[14]+S.w*v.m[15]);default:throw new Error(`Cannot transform value ${S}`)}}(0,N.f)("FlowGraphRotate3DBlock",u);class r extends m.d{constructor(S){const v=(null===S||void 0===S?void 0:S.vectorType)||"Rv",D="Vector2"===v?"Matrix2D":"Rv"===v?"Matrix3D":"Matrix";super((0,e.L)(v),(0,e.L)(D),(0,e.L)(v),s,"FlowGraphTransformVectorBlock",S)}}(0,N.f)("FlowGraphTransformVectorBlock",r);class d extends m.d{constructor(S){super(e.E,e.m,e.E,((S,v)=>g.Rv.TransformCoordinates(S,v)),"FlowGraphTransformCoordinatesBlock",S)}}(0,N.f)("FlowGraphTransformCoordinatesBlock",d);class x extends B.e{constructor(S){super(e.u,e.u,(S=>S.conjugate()),"FlowGraphConjugateBlock",S)}}(0,N.f)("FlowGraphConjugateBlock",x);class W extends m.d{constructor(S){super(e.u,e.u,e.q,((S,v)=>(0,h.e)(S,v)),"FlowGraphAngleBetweenBlock",S)}}(0,N.f)("FlowGraphAngleBetweenBlock",W);class p extends m.d{constructor(S){super(e.E,e.q,e.u,((S,v)=>g.Quaternion.RotationAxis(S,v)),"FlowGraphQuaternionFromAxisAngleBlock",S)}}(0,N.f)("FlowGraphQuaternionFromAxisAngleBlock",p);class b extends z.d{constructor(S){super(S),this.a=this.registerDataInput("a",e.u),this.axis=this.registerDataOutput("axis",e.E),this.angle=this.registerDataOutput("angle",e.q),this.isValid=this.registerDataOutput("isValid",e.e)}_updateOutputs(S){const v=S._getExecutionVariable(this,n,-1),D=S._getExecutionVariable(this,A,null),z=S._getExecutionVariable(this,w,null);if(void 0!==D&&null!==D&&void 0!==z&&null!==z&&v===S.executionId)this.axis.setValue(D,S),this.angle.setValue(z,S);else try{const{axis:v,angle:D}=this.a.getValue(S).toAxisAngle();S._setExecutionVariable(this,A,v),S._setExecutionVariable(this,w,D),S._setExecutionVariable(this,n,S.executionId),this.axis.setValue(v,S),this.angle.setValue(D,S),this.isValid.setValue(!0,S)}catch(e){this.isValid.setValue(!1,S)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,N.f)("FlowGraphAxisAngleFromQuaternionBlock",b);class k extends m.d{constructor(S){super(e.E,e.E,e.u,((S,v)=>(0,h.g)(S,v)),"FlowGraphQuaternionFromDirectionsBlock",S)}}},14644:(S,v,D)=>{D.d(v,{d:()=>e});var z=D(14647);class e extends z.e{constructor(S,v,D,z,e,N){super(D,N),this._operation=z,this._className=e,this.a=this.registerDataInput("a",S),this.b=this.registerDataInput("b",v)}_doOperation(S){const v=this.a.getValue(S),D=this.b.getValue(S);return this._operation(v,D)}getClassName(){return this._className}}},14647:(S,v,D)=>{D.d(v,{e:()=>B});var z=D(13123),e=D(13108);const N="cachedOperationValue",m="cachedExecutionId";class B extends z.d{constructor(S,v){super(v),this.value=this.registerDataOutput("value",S),this.isValid=this.registerDataOutput("isValid",e.e)}_updateOutputs(S){const v=S._getExecutionVariable(this,m,-1),D=S._getExecutionVariable(this,N,null);if(void 0!==D&&null!==D&&v===S.executionId)this.isValid.setValue(!0,S),this.value.setValue(D,S);else try{const v=this._doOperation(S);if(void 0===v||null===v)return void this.isValid.setValue(!1,S);S._setExecutionVariable(this,N,v),S._setExecutionVariable(this,m,S.executionId),this.value.setValue(v,S),this.isValid.setValue(!0,S)}catch(z){this.isValid.setValue(!1,S)}}}},14651:(S,v,D)=>{D.d(v,{e:()=>e});var z=D(14647);class e extends z.e{constructor(S,v,D,z,e){super(v,e),this._operation=D,this._className=z,this.a=this.registerDataInput("a",S)}_doOperation(S){return this._operation(this.a.getValue(S))}getClassName(){return this._className}}}}]);