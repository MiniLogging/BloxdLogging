"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[89],{15884:(r,O,W)=>{W.r(O),W.d(O,{FlowGraphAngleBetweenBlock:()=>D,FlowGraphAxisAngleFromQuaternionBlock:()=>z,FlowGraphConjugateBlock:()=>N,FlowGraphCrossBlock:()=>e,FlowGraphDotBlock:()=>b,FlowGraphLengthBlock:()=>U,FlowGraphNormalizeBlock:()=>P,FlowGraphQuaternionFromAxisAngleBlock:()=>p,FlowGraphQuaternionFromDirectionsBlock:()=>L,FlowGraphRotate2DBlock:()=>Y,FlowGraphRotate3DBlock:()=>G,FlowGraphTransformBlock:()=>S,FlowGraphTransformCoordinatesBlock:()=>o});var q=W(14297),Q=W(14274),C=W(12560),T=W(15870),h=W(15878),J=W(12591),mr=W(14308),d=W(13970);const v="cachedOperationAxis",g="cachedOperationAngle",K="cachedExecutionId";class U extends h.c{constructor(r){super(Q.c,Q.r,(r=>this._polymorphicLength(r)),"FlowGraphLengthBlock",r)}_polymorphicLength(r){switch((0,mr.l)(r)){case"Vector2":case"eO":case"Vector4":case"Quaternion":return r.length();default:throw new Error(`Cannot compute length of value ${r}`)}}}(0,C.e)("FlowGraphLengthBlock",U);class P extends h.c{constructor(r){super(Q.c,Q.c,(r=>this._polymorphicNormalize(r)),"FlowGraphNormalizeBlock",r)}_polymorphicNormalize(r){var O;let W;switch((0,mr.l)(r)){case"Vector2":case"eO":case"Vector4":case"Quaternion":if(W=r.normalizeToNew(),null!==(O=this.config)&&void 0!==O&&O.nanOnZeroLength){0===r.length()&&W.Mh(NaN)}return W;default:throw new Error(`Cannot normalize value ${r}`)}}}(0,C.e)("FlowGraphNormalizeBlock",P);class b extends T.c{constructor(r){super(Q.c,Q.c,Q.r,((r,O)=>this._polymorphicDot(r,O)),"FlowGraphDotBlock",r)}_polymorphicDot(r,O){switch((0,mr.l)(r)){case"Vector2":case"eO":case"Vector4":case"Quaternion":return r.dot(O);default:throw new Error(`Cannot get dot product of ${r} and ${O}`)}}}(0,C.e)("FlowGraphDotBlock",b);class e extends T.c{constructor(r){super(Q.z,Q.z,Q.z,((r,O)=>J.eO.Cross(r,O)),"FlowGraphCrossBlock",r)}}(0,C.e)("FlowGraphCrossBlock",e);class Y extends T.c{constructor(r){super(Q.x,Q.r,Q.x,((r,O)=>r.rotate(O)),"FlowGraphRotate2DBlock",r)}}(0,C.e)("FlowGraphRotate2DBlock",Y);class G extends T.c{constructor(r){super(Q.z,Q.u,Q.z,((r,O)=>r.applyRotationQuaternion(O)),"FlowGraphRotate3DBlock",r)}}function X(r,O){switch((0,mr.l)(r)){case"Vector2":case"eO":return O.transformVector(r);case"Vector4":return new J.Vector4(r.x*O.m[0]+r.y*O.m[1]+r.z*O.m[2]+r.w*O.m[3],r.x*O.m[4]+r.y*O.m[5]+r.z*O.m[6]+r.w*O.m[7],r.x*O.m[8]+r.y*O.m[9]+r.z*O.m[10]+r.w*O.m[11],r.x*O.m[12]+r.y*O.m[13]+r.z*O.m[14]+r.w*O.m[15]);default:throw new Error(`Cannot transform value ${r}`)}}(0,C.e)("FlowGraphRotate3DBlock",G);class S extends T.c{constructor(r){const O=(null===r||void 0===r?void 0:r.vectorType)||"eO",W="Vector2"===O?"Matrix2D":"eO"===O?"Matrix3D":"Matrix";super((0,Q.K)(O),(0,Q.K)(W),(0,Q.K)(O),X,"FlowGraphTransformVectorBlock",r)}}(0,C.e)("FlowGraphTransformVectorBlock",S);class o extends T.c{constructor(r){super(Q.z,Q.i,Q.z,((r,O)=>J.eO.TransformCoordinates(r,O)),"FlowGraphTransformCoordinatesBlock",r)}}(0,C.e)("FlowGraphTransformCoordinatesBlock",o);class N extends h.c{constructor(r){super(Q.u,Q.u,(r=>r.conjugate()),"FlowGraphConjugateBlock",r)}}(0,C.e)("FlowGraphConjugateBlock",N);class D extends T.c{constructor(r){super(Q.u,Q.u,Q.r,((r,O)=>(0,d.b)(r,O)),"FlowGraphAngleBetweenBlock",r)}}(0,C.e)("FlowGraphAngleBetweenBlock",D);class p extends T.c{constructor(r){super(Q.z,Q.r,Q.u,((r,O)=>J.Quaternion.RotationAxis(r,O)),"FlowGraphQuaternionFromAxisAngleBlock",r)}}(0,C.e)("FlowGraphQuaternionFromAxisAngleBlock",p);class z extends q.d{constructor(r){super(r),this.a=this.registerDataInput("a",Q.u),this.axis=this.registerDataOutput("axis",Q.z),this.angle=this.registerDataOutput("angle",Q.r),this.isValid=this.registerDataOutput("isValid",Q.d)}_updateOutputs(r){const O=r._getExecutionVariable(this,K,-1),W=r._getExecutionVariable(this,v,null),q=r._getExecutionVariable(this,g,null);if(void 0!==W&&null!==W&&void 0!==q&&null!==q&&O===r.executionId)this.axis.setValue(W,r),this.angle.setValue(q,r);else try{const{axis:O,angle:W}=this.a.getValue(r).toAxisAngle();r._setExecutionVariable(this,v,O),r._setExecutionVariable(this,g,W),r._setExecutionVariable(this,K,r.executionId),this.axis.setValue(O,r),this.angle.setValue(W,r),this.isValid.setValue(!0,r)}catch(Q){this.isValid.setValue(!1,r)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,C.e)("FlowGraphAxisAngleFromQuaternionBlock",z);class L extends T.c{constructor(r){super(Q.z,Q.z,Q.u,((r,O)=>(0,d.e)(r,O)),"FlowGraphQuaternionFromDirectionsBlock",r)}}},15870:(r,O,W)=>{W.d(O,{c:()=>Q});var q=W(15876);class Q extends q.c{constructor(r,O,W,q,Q,C){super(W,C),this._operation=q,this._className=Q,this.a=this.registerDataInput("a",r),this.b=this.registerDataInput("b",O)}_doOperation(r){const O=this.a.getValue(r),W=this.b.getValue(r);return this._operation(O,W)}getClassName(){return this._className}}},15876:(r,O,W)=>{W.d(O,{c:()=>h});var q=W(14297),Q=W(14274);const C="cachedOperationValue",T="cachedExecutionId";class h extends q.d{constructor(r,O){super(O),this.value=this.registerDataOutput("value",r),this.isValid=this.registerDataOutput("isValid",Q.d)}_updateOutputs(r){const O=r._getExecutionVariable(this,T,-1),W=r._getExecutionVariable(this,C,null);if(void 0!==W&&null!==W&&O===r.executionId)this.isValid.setValue(!0,r),this.value.setValue(W,r);else try{const O=this._doOperation(r);if(void 0===O||null===O)return void this.isValid.setValue(!1,r);r._setExecutionVariable(this,C,O),r._setExecutionVariable(this,T,r.executionId),this.value.setValue(O,r),this.isValid.setValue(!0,r)}catch(q){this.isValid.setValue(!1,r)}}}},15878:(r,O,W)=>{W.d(O,{c:()=>Q});var q=W(15876);class Q extends q.c{constructor(r,O,W,q,Q){super(O,Q),this._operation=W,this._className=q,this.a=this.registerDataInput("a",r)}_doOperation(r){return this._operation(this.a.getValue(r))}getClassName(){return this._className}}}}]);