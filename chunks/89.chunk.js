"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[89],{15524:(H,u,J)=>{J.r(u),J.d(u,{FlowGraphAngleBetweenBlock:()=>Y,FlowGraphAxisAngleFromQuaternionBlock:()=>s,FlowGraphConjugateBlock:()=>Z,FlowGraphCrossBlock:()=>a,FlowGraphDotBlock:()=>p,FlowGraphLengthBlock:()=>l,FlowGraphNormalizeBlock:()=>r,FlowGraphQuaternionFromAxisAngleBlock:()=>F,FlowGraphQuaternionFromDirectionsBlock:()=>A,FlowGraphRotate2DBlock:()=>k,FlowGraphRotate3DBlock:()=>C,FlowGraphTransformBlock:()=>M,FlowGraphTransformCoordinatesBlock:()=>L});var O=J(14041),U=J(14018),h=J(12304),w=J(15506),g=J(15519),B=J(12338),b=J(14049),d=J(13720);const G="cachedOperationAxis",P="cachedOperationAngle",mH="cachedExecutionId";class l extends g.c{constructor(H){super(U.d,U.z,(H=>this._polymorphicLength(H)),"FlowGraphLengthBlock",H)}_polymorphicLength(H){switch((0,b.i)(H)){case"Vector2":case"lu":case"Vector4":case"Quaternion":return H.length();default:throw new Error(`Cannot compute length of value ${H}`)}}}(0,h.f)("FlowGraphLengthBlock",l);class r extends g.c{constructor(H){super(U.d,U.d,(H=>this._polymorphicNormalize(H)),"FlowGraphNormalizeBlock",H)}_polymorphicNormalize(H){var u;let J;switch((0,b.i)(H)){case"Vector2":case"lu":case"Vector4":case"Quaternion":if(J=H.normalizeToNew(),null!==(u=this.config)&&void 0!==u&&u.nanOnZeroLength){0===H.length()&&J.jg(NaN)}return J;default:throw new Error(`Cannot normalize value ${H}`)}}}(0,h.f)("FlowGraphNormalizeBlock",r);class p extends w.b{constructor(H){super(U.d,U.d,U.z,((H,u)=>this._polymorphicDot(H,u)),"FlowGraphDotBlock",H)}_polymorphicDot(H,u){switch((0,b.i)(H)){case"Vector2":case"lu":case"Vector4":case"Quaternion":return H.dot(u);default:throw new Error(`Cannot get dot product of ${H} and ${u}`)}}}(0,h.f)("FlowGraphDotBlock",p);class a extends w.b{constructor(H){super(U.N,U.N,U.N,((H,u)=>B.lu.Cross(H,u)),"FlowGraphCrossBlock",H)}}(0,h.f)("FlowGraphCrossBlock",a);class k extends w.b{constructor(H){super(U.J,U.z,U.J,((H,u)=>H.rotate(u)),"FlowGraphRotate2DBlock",H)}}(0,h.f)("FlowGraphRotate2DBlock",k);class C extends w.b{constructor(H){super(U.N,U.D,U.N,((H,u)=>H.applyRotationQuaternion(u)),"FlowGraphRotate3DBlock",H)}}function j(H,u){switch((0,b.i)(H)){case"Vector2":case"lu":return u.transformVector(H);case"Vector4":return new B.Vector4(H.x*u.m[0]+H.y*u.m[1]+H.z*u.m[2]+H.w*u.m[3],H.x*u.m[4]+H.y*u.m[5]+H.z*u.m[6]+H.w*u.m[7],H.x*u.m[8]+H.y*u.m[9]+H.z*u.m[10]+H.w*u.m[11],H.x*u.m[12]+H.y*u.m[13]+H.z*u.m[14]+H.w*u.m[15]);default:throw new Error(`Cannot transform value ${H}`)}}(0,h.f)("FlowGraphRotate3DBlock",C);class M extends w.b{constructor(H){const u=(null===H||void 0===H?void 0:H.vectorType)||"lu",J="Vector2"===u?"Matrix2D":"lu"===u?"Matrix3D":"Matrix";super((0,U.X)(u),(0,U.X)(J),(0,U.X)(u),j,"FlowGraphTransformVectorBlock",H)}}(0,h.f)("FlowGraphTransformVectorBlock",M);class L extends w.b{constructor(H){super(U.N,U.n,U.N,((H,u)=>B.lu.TransformCoordinates(H,u)),"FlowGraphTransformCoordinatesBlock",H)}}(0,h.f)("FlowGraphTransformCoordinatesBlock",L);class Z extends g.c{constructor(H){super(U.D,U.D,(H=>H.conjugate()),"FlowGraphConjugateBlock",H)}}(0,h.f)("FlowGraphConjugateBlock",Z);class Y extends w.b{constructor(H){super(U.D,U.D,U.z,((H,u)=>(0,d.b)(H,u)),"FlowGraphAngleBetweenBlock",H)}}(0,h.f)("FlowGraphAngleBetweenBlock",Y);class F extends w.b{constructor(H){super(U.N,U.z,U.D,((H,u)=>B.Quaternion.RotationAxis(H,u)),"FlowGraphQuaternionFromAxisAngleBlock",H)}}(0,h.f)("FlowGraphQuaternionFromAxisAngleBlock",F);class s extends O.b{constructor(H){super(H),this.a=this.registerDataInput("a",U.D),this.axis=this.registerDataOutput("axis",U.N),this.angle=this.registerDataOutput("angle",U.z),this.isValid=this.registerDataOutput("isValid",U.f)}_updateOutputs(H){const u=H._getExecutionVariable(this,mH,-1),J=H._getExecutionVariable(this,G,null),O=H._getExecutionVariable(this,P,null);if(void 0!==J&&null!==J&&void 0!==O&&null!==O&&u===H.executionId)this.axis.setValue(J,H),this.angle.setValue(O,H);else try{const{axis:u,angle:J}=this.a.getValue(H).toAxisAngle();H._setExecutionVariable(this,G,u),H._setExecutionVariable(this,P,J),H._setExecutionVariable(this,mH,H.executionId),this.axis.setValue(u,H),this.angle.setValue(J,H),this.isValid.setValue(!0,H)}catch(U){this.isValid.setValue(!1,H)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,h.f)("FlowGraphAxisAngleFromQuaternionBlock",s);class A extends w.b{constructor(H){super(U.N,U.N,U.D,((H,u)=>(0,d.e)(H,u)),"FlowGraphQuaternionFromDirectionsBlock",H)}}},15506:(H,u,J)=>{J.d(u,{b:()=>U});var O=J(15515);class U extends O.b{constructor(H,u,J,O,U,h){super(J,h),this._operation=O,this._className=U,this.a=this.registerDataInput("a",H),this.b=this.registerDataInput("b",u)}_doOperation(H){const u=this.a.getValue(H),J=this.b.getValue(H);return this._operation(u,J)}getClassName(){return this._className}}},15515:(H,u,J)=>{J.d(u,{b:()=>g});var O=J(14041),U=J(14018);const h="cachedOperationValue",w="cachedExecutionId";class g extends O.b{constructor(H,u){super(u),this.value=this.registerDataOutput("value",H),this.isValid=this.registerDataOutput("isValid",U.f)}_updateOutputs(H){const u=H._getExecutionVariable(this,w,-1),J=H._getExecutionVariable(this,h,null);if(void 0!==J&&null!==J&&u===H.executionId)this.isValid.setValue(!0,H),this.value.setValue(J,H);else try{const u=this._doOperation(H);if(void 0===u||null===u)return void this.isValid.setValue(!1,H);H._setExecutionVariable(this,h,u),H._setExecutionVariable(this,w,H.executionId),this.value.setValue(u,H),this.isValid.setValue(!0,H)}catch(O){this.isValid.setValue(!1,H)}}}},15519:(H,u,J)=>{J.d(u,{c:()=>U});var O=J(15515);class U extends O.b{constructor(H,u,J,O,U){super(u,U),this._operation=J,this._className=O,this.a=this.registerDataInput("a",H)}_doOperation(H){return this._operation(this.a.getValue(H))}getClassName(){return this._className}}}}]);