"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[89],{15627:(V,h,mV)=>{mV.r(h),mV.d(h,{FlowGraphAngleBetweenBlock:()=>H,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>M,FlowGraphDotBlock:()=>s,FlowGraphLengthBlock:()=>R,FlowGraphNormalizeBlock:()=>d,FlowGraphQuaternionFromAxisAngleBlock:()=>j,FlowGraphQuaternionFromDirectionsBlock:()=>G,FlowGraphRotate2DBlock:()=>c,FlowGraphRotate3DBlock:()=>z,FlowGraphTransformBlock:()=>J,FlowGraphTransformCoordinatesBlock:()=>v});var t=mV(14123),L=mV(14109),N=mV(12388),A=mV(15609),k=mV(15618),C=mV(12422),K=mV(14135),o=mV(13816);const n="cachedOperationAxis",q="cachedOperationAngle",x="cachedExecutionId";class R extends k.d{constructor(V){super(L.e,L.r,(V=>this._polymorphicLength(V)),"FlowGraphLengthBlock",V)}_polymorphicLength(V){switch((0,K.k)(V)){case"Vector2":case"sh":case"Vector4":case"Quaternion":return V.length();default:throw new Error(`Cannot compute length of value ${V}`)}}}(0,N.i)("FlowGraphLengthBlock",R);class d extends k.d{constructor(V){super(L.e,L.e,(V=>this._polymorphicNormalize(V)),"FlowGraphNormalizeBlock",V)}_polymorphicNormalize(V){var h;let mV;switch((0,K.k)(V)){case"Vector2":case"sh":case"Vector4":case"Quaternion":if(mV=V.normalizeToNew(),null!==(h=this.config)&&void 0!==h&&h.nanOnZeroLength){0===V.length()&&mV.lk(NaN)}return mV;default:throw new Error(`Cannot normalize value ${V}`)}}}(0,N.i)("FlowGraphNormalizeBlock",d);class s extends A.d{constructor(V){super(L.e,L.e,L.r,((V,h)=>this._polymorphicDot(V,h)),"FlowGraphDotBlock",V)}_polymorphicDot(V,h){switch((0,K.k)(V)){case"Vector2":case"sh":case"Vector4":case"Quaternion":return V.dot(h);default:throw new Error(`Cannot get dot product of ${V} and ${h}`)}}}(0,N.i)("FlowGraphDotBlock",s);class M extends A.d{constructor(V){super(L.z,L.z,L.z,((V,h)=>C.sh.Cross(V,h)),"FlowGraphCrossBlock",V)}}(0,N.i)("FlowGraphCrossBlock",M);class c extends A.d{constructor(V){super(L.x,L.r,L.x,((V,h)=>V.rotate(h)),"FlowGraphRotate2DBlock",V)}}(0,N.i)("FlowGraphRotate2DBlock",c);class z extends A.d{constructor(V){super(L.z,L.v,L.z,((V,h)=>V.applyRotationQuaternion(h)),"FlowGraphRotate3DBlock",V)}}function Q(V,h){switch((0,K.k)(V)){case"Vector2":case"sh":return h.transformVector(V);case"Vector4":return new C.Vector4(V.x*h.m[0]+V.y*h.m[1]+V.z*h.m[2]+V.w*h.m[3],V.x*h.m[4]+V.y*h.m[5]+V.z*h.m[6]+V.w*h.m[7],V.x*h.m[8]+V.y*h.m[9]+V.z*h.m[10]+V.w*h.m[11],V.x*h.m[12]+V.y*h.m[13]+V.z*h.m[14]+V.w*h.m[15]);default:throw new Error(`Cannot transform value ${V}`)}}(0,N.i)("FlowGraphRotate3DBlock",z);class J extends A.d{constructor(V){const h=(null===V||void 0===V?void 0:V.vectorType)||"sh",mV="Vector2"===h?"Matrix2D":"sh"===h?"Matrix3D":"Matrix";super((0,L.I)(h),(0,L.I)(mV),(0,L.I)(h),Q,"FlowGraphTransformVectorBlock",V)}}(0,N.i)("FlowGraphTransformVectorBlock",J);class v extends A.d{constructor(V){super(L.z,L.l,L.z,((V,h)=>C.sh.TransformCoordinates(V,h)),"FlowGraphTransformCoordinatesBlock",V)}}(0,N.i)("FlowGraphTransformCoordinatesBlock",v);class D extends k.d{constructor(V){super(L.v,L.v,(V=>V.conjugate()),"FlowGraphConjugateBlock",V)}}(0,N.i)("FlowGraphConjugateBlock",D);class H extends A.d{constructor(V){super(L.v,L.v,L.r,((V,h)=>(0,o.e)(V,h)),"FlowGraphAngleBetweenBlock",V)}}(0,N.i)("FlowGraphAngleBetweenBlock",H);class j extends A.d{constructor(V){super(L.z,L.r,L.v,((V,h)=>C.Quaternion.RotationAxis(V,h)),"FlowGraphQuaternionFromAxisAngleBlock",V)}}(0,N.i)("FlowGraphQuaternionFromAxisAngleBlock",j);class l extends t.e{constructor(V){super(V),this.a=this.registerDataInput("a",L.v),this.axis=this.registerDataOutput("axis",L.z),this.angle=this.registerDataOutput("angle",L.r),this.isValid=this.registerDataOutput("isValid",L.h)}_updateOutputs(V){const h=V._getExecutionVariable(this,x,-1),mV=V._getExecutionVariable(this,n,null),t=V._getExecutionVariable(this,q,null);if(void 0!==mV&&null!==mV&&void 0!==t&&null!==t&&h===V.executionId)this.axis.setValue(mV,V),this.angle.setValue(t,V);else try{const{axis:h,angle:mV}=this.a.getValue(V).toAxisAngle();V._setExecutionVariable(this,n,h),V._setExecutionVariable(this,q,mV),V._setExecutionVariable(this,x,V.executionId),this.axis.setValue(h,V),this.angle.setValue(mV,V),this.isValid.setValue(!0,V)}catch(L){this.isValid.setValue(!1,V)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,N.i)("FlowGraphAxisAngleFromQuaternionBlock",l);class G extends A.d{constructor(V){super(L.z,L.z,L.v,((V,h)=>(0,o.i)(V,h)),"FlowGraphQuaternionFromDirectionsBlock",V)}}},15609:(V,h,mV)=>{mV.d(h,{d:()=>L});var t=mV(15611);class L extends t.b{constructor(V,h,mV,t,L,N){super(mV,N),this._operation=t,this._className=L,this.a=this.registerDataInput("a",V),this.b=this.registerDataInput("b",h)}_doOperation(V){const h=this.a.getValue(V),mV=this.b.getValue(V);return this._operation(h,mV)}getClassName(){return this._className}}},15611:(V,h,mV)=>{mV.d(h,{b:()=>k});var t=mV(14123),L=mV(14109);const N="cachedOperationValue",A="cachedExecutionId";class k extends t.e{constructor(V,h){super(h),this.value=this.registerDataOutput("value",V),this.isValid=this.registerDataOutput("isValid",L.h)}_updateOutputs(V){const h=V._getExecutionVariable(this,A,-1),mV=V._getExecutionVariable(this,N,null);if(void 0!==mV&&null!==mV&&h===V.executionId)this.isValid.setValue(!0,V),this.value.setValue(mV,V);else try{const h=this._doOperation(V);if(void 0===h||null===h)return void this.isValid.setValue(!1,V);V._setExecutionVariable(this,N,h),V._setExecutionVariable(this,A,V.executionId),this.value.setValue(h,V),this.isValid.setValue(!0,V)}catch(t){this.isValid.setValue(!1,V)}}}},15618:(V,h,mV)=>{mV.d(h,{d:()=>L});var t=mV(15611);class L extends t.b{constructor(V,h,mV,t,L){super(h,L),this._operation=mV,this._className=t,this.a=this.registerDataInput("a",V)}_doOperation(V){return this._operation(this.a.getValue(V))}getClassName(){return this._className}}}}]);