"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[89],{14597:(B,E,v)=>{v.r(E),v.d(E,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>I,FlowGraphConjugateBlock:()=>r,FlowGraphCrossBlock:()=>m,FlowGraphDotBlock:()=>a,FlowGraphLengthBlock:()=>G,FlowGraphNormalizeBlock:()=>Y,FlowGraphQuaternionFromAxisAngleBlock:()=>u,FlowGraphQuaternionFromDirectionsBlock:()=>K,FlowGraphRotate2DBlock:()=>g,FlowGraphRotate3DBlock:()=>V,FlowGraphTransformBlock:()=>N,FlowGraphTransformCoordinatesBlock:()=>X});var z=v(13121),o=v(13102),q=v(11345),c=v(14579),S=v(14595),x=v(11380),D=v(13133),h=v(12785);const y="cachedOperationAxis",Q="cachedOperationAngle",P="cachedExecutionId";class G extends S.d{constructor(B){super(o.c,o.v,(B=>this._polymorphicLength(B)),"FlowGraphLengthBlock",B)}_polymorphicLength(B){switch((0,D.m)(B)){case"Vector2":case"GE":case"Vector4":case"Quaternion":return B.length();default:throw new Error(`Cannot compute length of value ${B}`)}}}(0,q.f)("FlowGraphLengthBlock",G);class Y extends S.d{constructor(B){super(o.c,o.c,(B=>this._polymorphicNormalize(B)),"FlowGraphNormalizeBlock",B)}_polymorphicNormalize(B){var E;let v;switch((0,D.m)(B)){case"Vector2":case"GE":case"Vector4":case"Quaternion":if(v=B.normalizeToNew(),null!==(E=this.config)&&void 0!==E&&E.nanOnZeroLength){0===B.length()&&v.mc(NaN)}return v;default:throw new Error(`Cannot normalize value ${B}`)}}}(0,q.f)("FlowGraphNormalizeBlock",Y);class a extends c.c{constructor(B){super(o.c,o.c,o.v,((B,E)=>this._polymorphicDot(B,E)),"FlowGraphDotBlock",B)}_polymorphicDot(B,E){switch((0,D.m)(B)){case"Vector2":case"GE":case"Vector4":case"Quaternion":return B.dot(E);default:throw new Error(`Cannot get dot product of ${B} and ${E}`)}}}(0,q.f)("FlowGraphDotBlock",a);class m extends c.c{constructor(B){super(o.G,o.G,o.G,((B,E)=>x.GE.Cross(B,E)),"FlowGraphCrossBlock",B)}}(0,q.f)("FlowGraphCrossBlock",m);class g extends c.c{constructor(B){super(o.C,o.v,o.C,((B,E)=>B.rotate(E)),"FlowGraphRotate2DBlock",B)}}(0,q.f)("FlowGraphRotate2DBlock",g);class V extends c.c{constructor(B){super(o.G,o.y,o.G,((B,E)=>B.applyRotationQuaternion(E)),"FlowGraphRotate3DBlock",B)}}function T(B,E){switch((0,D.m)(B)){case"Vector2":case"GE":return E.transformVector(B);case"Vector4":return new x.Vector4(B.x*E.m[0]+B.y*E.m[1]+B.z*E.m[2]+B.w*E.m[3],B.x*E.m[4]+B.y*E.m[5]+B.z*E.m[6]+B.w*E.m[7],B.x*E.m[8]+B.y*E.m[9]+B.z*E.m[10]+B.w*E.m[11],B.x*E.m[12]+B.y*E.m[13]+B.z*E.m[14]+B.w*E.m[15]);default:throw new Error(`Cannot transform value ${B}`)}}(0,q.f)("FlowGraphRotate3DBlock",V);class N extends c.c{constructor(B){const E=(null===B||void 0===B?void 0:B.vectorType)||"GE",v="Vector2"===E?"Matrix2D":"GE"===E?"Matrix3D":"Matrix";super((0,o.Q)(E),(0,o.Q)(v),(0,o.Q)(E),T,"FlowGraphTransformVectorBlock",B)}}(0,q.f)("FlowGraphTransformVectorBlock",N);class X extends c.c{constructor(B){super(o.G,o.k,o.G,((B,E)=>x.GE.TransformCoordinates(B,E)),"FlowGraphTransformCoordinatesBlock",B)}}(0,q.f)("FlowGraphTransformCoordinatesBlock",X);class r extends S.d{constructor(B){super(o.y,o.y,(B=>B.conjugate()),"FlowGraphConjugateBlock",B)}}(0,q.f)("FlowGraphConjugateBlock",r);class i extends c.c{constructor(B){super(o.y,o.y,o.v,((B,E)=>(0,h.d)(B,E)),"FlowGraphAngleBetweenBlock",B)}}(0,q.f)("FlowGraphAngleBetweenBlock",i);class u extends c.c{constructor(B){super(o.G,o.v,o.y,((B,E)=>x.Quaternion.RotationAxis(B,E)),"FlowGraphQuaternionFromAxisAngleBlock",B)}}(0,q.f)("FlowGraphQuaternionFromAxisAngleBlock",u);class I extends z.c{constructor(B){super(B),this.a=this.registerDataInput("a",o.y),this.axis=this.registerDataOutput("axis",o.G),this.angle=this.registerDataOutput("angle",o.v),this.isValid=this.registerDataOutput("isValid",o.f)}_updateOutputs(B){const E=B._getExecutionVariable(this,P,-1),v=B._getExecutionVariable(this,y,null),z=B._getExecutionVariable(this,Q,null);if(void 0!==v&&null!==v&&void 0!==z&&null!==z&&E===B.executionId)this.axis.setValue(v,B),this.angle.setValue(z,B);else try{const{axis:E,angle:v}=this.a.getValue(B).toAxisAngle();B._setExecutionVariable(this,y,E),B._setExecutionVariable(this,Q,v),B._setExecutionVariable(this,P,B.executionId),this.axis.setValue(E,B),this.angle.setValue(v,B),this.isValid.setValue(!0,B)}catch(o){this.isValid.setValue(!1,B)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,q.f)("FlowGraphAxisAngleFromQuaternionBlock",I);class K extends c.c{constructor(B){super(o.G,o.G,o.y,((B,E)=>(0,h.f)(B,E)),"FlowGraphQuaternionFromDirectionsBlock",B)}}},14579:(B,E,v)=>{v.d(E,{c:()=>o});var z=v(14588);class o extends z.b{constructor(B,E,v,z,o,q){super(v,q),this._operation=z,this._className=o,this.a=this.registerDataInput("a",B),this.b=this.registerDataInput("b",E)}_doOperation(B){const E=this.a.getValue(B),v=this.b.getValue(B);return this._operation(E,v)}getClassName(){return this._className}}},14588:(B,E,v)=>{v.d(E,{b:()=>S});var z=v(13121),o=v(13102);const q="cachedOperationValue",c="cachedExecutionId";class S extends z.c{constructor(B,E){super(E),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",o.f)}_updateOutputs(B){const E=B._getExecutionVariable(this,c,-1),v=B._getExecutionVariable(this,q,null);if(void 0!==v&&null!==v&&E===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(v,B);else try{const E=this._doOperation(B);if(void 0===E||null===E)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,q,E),B._setExecutionVariable(this,c,B.executionId),this.value.setValue(E,B),this.isValid.setValue(!0,B)}catch(z){this.isValid.setValue(!1,B)}}}},14595:(B,E,v)=>{v.d(E,{d:()=>o});var z=v(14588);class o extends z.b{constructor(B,E,v,z,o){super(E,o),this._operation=v,this._className=z,this.a=this.registerDataInput("a",B)}_doOperation(B){return this._operation(this.a.getValue(B))}getClassName(){return this._className}}}}]);