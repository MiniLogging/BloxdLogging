"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[89],{15894:(K,A,T)=>{T.r(A),T.d(A,{FlowGraphAngleBetweenBlock:()=>S,FlowGraphAxisAngleFromQuaternionBlock:()=>u,FlowGraphConjugateBlock:()=>g,FlowGraphCrossBlock:()=>d,FlowGraphDotBlock:()=>F,FlowGraphLengthBlock:()=>b,FlowGraphNormalizeBlock:()=>P,FlowGraphQuaternionFromAxisAngleBlock:()=>l,FlowGraphQuaternionFromDirectionsBlock:()=>c,FlowGraphRotate2DBlock:()=>N,FlowGraphRotate3DBlock:()=>D,FlowGraphTransformBlock:()=>U,FlowGraphTransformCoordinatesBlock:()=>z});var G=T(14262),B=T(14237),L=T(12651),f=T(15880),O=T(15888),C=T(12700),Q=T(14278),Y=T(13942);const Z="cachedOperationAxis",x="cachedOperationAngle",J="cachedExecutionId";class b extends O.e{constructor(K){super(B.b,B.q,(K=>this._polymorphicLength(K)),"FlowGraphLengthBlock",K)}_polymorphicLength(K){switch((0,Q.i)(K)){case"Vector2":case"PA":case"Vector4":case"Quaternion":return K.length();default:throw new Error(`Cannot compute length of value ${K}`)}}}(0,L.c)("FlowGraphLengthBlock",b);class P extends O.e{constructor(K){super(B.b,B.b,(K=>this._polymorphicNormalize(K)),"FlowGraphNormalizeBlock",K)}_polymorphicNormalize(K){var A;let T;switch((0,Q.i)(K)){case"Vector2":case"PA":case"Vector4":case"Quaternion":if(T=K.normalizeToNew(),null!==(A=this.config)&&void 0!==A&&A.nanOnZeroLength){0===K.length()&&T.IO(NaN)}return T;default:throw new Error(`Cannot normalize value ${K}`)}}}(0,L.c)("FlowGraphNormalizeBlock",P);class F extends f.d{constructor(K){super(B.b,B.b,B.q,((K,A)=>this._polymorphicDot(K,A)),"FlowGraphDotBlock",K)}_polymorphicDot(K,A){switch((0,Q.i)(K)){case"Vector2":case"PA":case"Vector4":case"Quaternion":return K.dot(A);default:throw new Error(`Cannot get dot product of ${K} and ${A}`)}}}(0,L.c)("FlowGraphDotBlock",F);class d extends f.d{constructor(K){super(B.C,B.C,B.C,((K,A)=>C.PA.Cross(K,A)),"FlowGraphCrossBlock",K)}}(0,L.c)("FlowGraphCrossBlock",d);class N extends f.d{constructor(K){super(B.z,B.q,B.z,((K,A)=>K.rotate(A)),"FlowGraphRotate2DBlock",K)}}(0,L.c)("FlowGraphRotate2DBlock",N);class D extends f.d{constructor(K){super(B.C,B.t,B.C,((K,A)=>K.applyRotationQuaternion(A)),"FlowGraphRotate3DBlock",K)}}function mK(K,A){switch((0,Q.i)(K)){case"Vector2":case"PA":return A.transformVector(K);case"Vector4":return new C.Vector4(K.x*A.m[0]+K.y*A.m[1]+K.z*A.m[2]+K.w*A.m[3],K.x*A.m[4]+K.y*A.m[5]+K.z*A.m[6]+K.w*A.m[7],K.x*A.m[8]+K.y*A.m[9]+K.z*A.m[10]+K.w*A.m[11],K.x*A.m[12]+K.y*A.m[13]+K.z*A.m[14]+K.w*A.m[15]);default:throw new Error(`Cannot transform value ${K}`)}}(0,L.c)("FlowGraphRotate3DBlock",D);class U extends f.d{constructor(K){const A=(null===K||void 0===K?void 0:K.vectorType)||"PA",T="Vector2"===A?"Matrix2D":"PA"===A?"Matrix3D":"Matrix";super((0,B.O)(A),(0,B.O)(T),(0,B.O)(A),mK,"FlowGraphTransformVectorBlock",K)}}(0,L.c)("FlowGraphTransformVectorBlock",U);class z extends f.d{constructor(K){super(B.C,B.h,B.C,((K,A)=>C.PA.TransformCoordinates(K,A)),"FlowGraphTransformCoordinatesBlock",K)}}(0,L.c)("FlowGraphTransformCoordinatesBlock",z);class g extends O.e{constructor(K){super(B.t,B.t,(K=>K.conjugate()),"FlowGraphConjugateBlock",K)}}(0,L.c)("FlowGraphConjugateBlock",g);class S extends f.d{constructor(K){super(B.t,B.t,B.q,((K,A)=>(0,Y.d)(K,A)),"FlowGraphAngleBetweenBlock",K)}}(0,L.c)("FlowGraphAngleBetweenBlock",S);class l extends f.d{constructor(K){super(B.C,B.q,B.t,((K,A)=>C.Quaternion.RotationAxis(K,A)),"FlowGraphQuaternionFromAxisAngleBlock",K)}}(0,L.c)("FlowGraphQuaternionFromAxisAngleBlock",l);class u extends G.e{constructor(K){super(K),this.a=this.registerDataInput("a",B.t),this.axis=this.registerDataOutput("axis",B.C),this.angle=this.registerDataOutput("angle",B.q),this.isValid=this.registerDataOutput("isValid",B.d)}_updateOutputs(K){const A=K._getExecutionVariable(this,J,-1),T=K._getExecutionVariable(this,Z,null),G=K._getExecutionVariable(this,x,null);if(void 0!==T&&null!==T&&void 0!==G&&null!==G&&A===K.executionId)this.axis.setValue(T,K),this.angle.setValue(G,K);else try{const{axis:A,angle:T}=this.a.getValue(K).toAxisAngle();K._setExecutionVariable(this,Z,A),K._setExecutionVariable(this,x,T),K._setExecutionVariable(this,J,K.executionId),this.axis.setValue(A,K),this.angle.setValue(T,K),this.isValid.setValue(!0,K)}catch(B){this.isValid.setValue(!1,K)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,L.c)("FlowGraphAxisAngleFromQuaternionBlock",u);class c extends f.d{constructor(K){super(B.C,B.C,B.t,((K,A)=>(0,Y.f)(K,A)),"FlowGraphQuaternionFromDirectionsBlock",K)}}},15880:(K,A,T)=>{T.d(A,{d:()=>B});var G=T(15884);class B extends G.b{constructor(K,A,T,G,B,L){super(T,L),this._operation=G,this._className=B,this.a=this.registerDataInput("a",K),this.b=this.registerDataInput("b",A)}_doOperation(K){const A=this.a.getValue(K),T=this.b.getValue(K);return this._operation(A,T)}getClassName(){return this._className}}},15884:(K,A,T)=>{T.d(A,{b:()=>O});var G=T(14262),B=T(14237);const L="cachedOperationValue",f="cachedExecutionId";class O extends G.e{constructor(K,A){super(A),this.value=this.registerDataOutput("value",K),this.isValid=this.registerDataOutput("isValid",B.d)}_updateOutputs(K){const A=K._getExecutionVariable(this,f,-1),T=K._getExecutionVariable(this,L,null);if(void 0!==T&&null!==T&&A===K.executionId)this.isValid.setValue(!0,K),this.value.setValue(T,K);else try{const A=this._doOperation(K);if(void 0===A||null===A)return void this.isValid.setValue(!1,K);K._setExecutionVariable(this,L,A),K._setExecutionVariable(this,f,K.executionId),this.value.setValue(A,K),this.isValid.setValue(!0,K)}catch(G){this.isValid.setValue(!1,K)}}}},15888:(K,A,T)=>{T.d(A,{e:()=>B});var G=T(15884);class B extends G.b{constructor(K,A,T,G,B){super(A,B),this._operation=T,this._className=G,this.a=this.registerDataInput("a",K)}_doOperation(K){return this._operation(this.a.getValue(K))}getClassName(){return this._className}}}}]);