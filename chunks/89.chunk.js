"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[89],{14366:(I,E,j)=>{j.r(E),j.d(E,{FlowGraphAngleBetweenBlock:()=>G,FlowGraphAxisAngleFromQuaternionBlock:()=>d,FlowGraphConjugateBlock:()=>Q,FlowGraphCrossBlock:()=>C,FlowGraphDotBlock:()=>F,FlowGraphLengthBlock:()=>K,FlowGraphNormalizeBlock:()=>L,FlowGraphQuaternionFromAxisAngleBlock:()=>y,FlowGraphQuaternionFromDirectionsBlock:()=>a,FlowGraphRotate2DBlock:()=>X,FlowGraphRotate3DBlock:()=>q,FlowGraphTransformBlock:()=>u,FlowGraphTransformCoordinatesBlock:()=>b});var e=j(12834),w=j(12819),z=j(11073),h=j(14345),t=j(14358),U=j(11117),R=j(12843),P=j(12509);const o="cachedOperationAxis",Z="cachedOperationAngle",c="cachedExecutionId";class K extends t.b{constructor(I){super(w.e,w.t,(I=>this._polymorphicLength(I)),"FlowGraphLengthBlock",I)}_polymorphicLength(I){switch((0,R.j)(I)){case"Vector2":case"LE":case"Vector4":case"Quaternion":return I.length();default:throw new Error(`Cannot compute length of value ${I}`)}}}(0,z.h)("FlowGraphLengthBlock",K);class L extends t.b{constructor(I){super(w.e,w.e,(I=>this._polymorphicNormalize(I)),"FlowGraphNormalizeBlock",I)}_polymorphicNormalize(I){var E;let j;switch((0,R.j)(I)){case"Vector2":case"LE":case"Vector4":case"Quaternion":if(j=I.normalizeToNew(),null!==(E=this.config)&&void 0!==E&&E.nanOnZeroLength){0===I.length()&&j.mz(NaN)}return j;default:throw new Error(`Cannot normalize value ${I}`)}}}(0,z.h)("FlowGraphNormalizeBlock",L);class F extends h.d{constructor(I){super(w.e,w.e,w.t,((I,E)=>this._polymorphicDot(I,E)),"FlowGraphDotBlock",I)}_polymorphicDot(I,E){switch((0,R.j)(I)){case"Vector2":case"LE":case"Vector4":case"Quaternion":return I.dot(E);default:throw new Error(`Cannot get dot product of ${I} and ${E}`)}}}(0,z.h)("FlowGraphDotBlock",F);class C extends h.d{constructor(I){super(w.E,w.E,w.E,((I,E)=>U.LE.Cross(I,E)),"FlowGraphCrossBlock",I)}}(0,z.h)("FlowGraphCrossBlock",C);class X extends h.d{constructor(I){super(w.B,w.t,w.B,((I,E)=>I.rotate(E)),"FlowGraphRotate2DBlock",I)}}(0,z.h)("FlowGraphRotate2DBlock",X);class q extends h.d{constructor(I){super(w.E,w.w,w.E,((I,E)=>I.applyRotationQuaternion(E)),"FlowGraphRotate3DBlock",I)}}function x(I,E){switch((0,R.j)(I)){case"Vector2":case"LE":return E.transformVector(I);case"Vector4":return new U.Vector4(I.x*E.m[0]+I.y*E.m[1]+I.z*E.m[2]+I.w*E.m[3],I.x*E.m[4]+I.y*E.m[5]+I.z*E.m[6]+I.w*E.m[7],I.x*E.m[8]+I.y*E.m[9]+I.z*E.m[10]+I.w*E.m[11],I.x*E.m[12]+I.y*E.m[13]+I.z*E.m[14]+I.w*E.m[15]);default:throw new Error(`Cannot transform value ${I}`)}}(0,z.h)("FlowGraphRotate3DBlock",q);class u extends h.d{constructor(I){const E=(null===I||void 0===I?void 0:I.vectorType)||"LE",j="Vector2"===E?"Matrix2D":"LE"===E?"Matrix3D":"Matrix";super((0,w.N)(E),(0,w.N)(j),(0,w.N)(E),x,"FlowGraphTransformVectorBlock",I)}}(0,z.h)("FlowGraphTransformVectorBlock",u);class b extends h.d{constructor(I){super(w.E,w.j,w.E,((I,E)=>U.LE.TransformCoordinates(I,E)),"FlowGraphTransformCoordinatesBlock",I)}}(0,z.h)("FlowGraphTransformCoordinatesBlock",b);class Q extends t.b{constructor(I){super(w.w,w.w,(I=>I.conjugate()),"FlowGraphConjugateBlock",I)}}(0,z.h)("FlowGraphConjugateBlock",Q);class G extends h.d{constructor(I){super(w.w,w.w,w.t,((I,E)=>(0,P.b)(I,E)),"FlowGraphAngleBetweenBlock",I)}}(0,z.h)("FlowGraphAngleBetweenBlock",G);class y extends h.d{constructor(I){super(w.E,w.t,w.w,((I,E)=>U.Quaternion.RotationAxis(I,E)),"FlowGraphQuaternionFromAxisAngleBlock",I)}}(0,z.h)("FlowGraphQuaternionFromAxisAngleBlock",y);class d extends e.e{constructor(I){super(I),this.a=this.registerDataInput("a",w.w),this.axis=this.registerDataOutput("axis",w.E),this.angle=this.registerDataOutput("angle",w.t),this.isValid=this.registerDataOutput("isValid",w.g)}_updateOutputs(I){const E=I._getExecutionVariable(this,c,-1),j=I._getExecutionVariable(this,o,null),e=I._getExecutionVariable(this,Z,null);if(void 0!==j&&null!==j&&void 0!==e&&null!==e&&E===I.executionId)this.axis.setValue(j,I),this.angle.setValue(e,I);else try{const{axis:E,angle:j}=this.a.getValue(I).toAxisAngle();I._setExecutionVariable(this,o,E),I._setExecutionVariable(this,Z,j),I._setExecutionVariable(this,c,I.executionId),this.axis.setValue(E,I),this.angle.setValue(j,I),this.isValid.setValue(!0,I)}catch(w){this.isValid.setValue(!1,I)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,z.h)("FlowGraphAxisAngleFromQuaternionBlock",d);class a extends h.d{constructor(I){super(w.E,w.E,w.w,((I,E)=>(0,P.e)(I,E)),"FlowGraphQuaternionFromDirectionsBlock",I)}}},14345:(I,E,j)=>{j.d(E,{d:()=>w});var e=j(14351);class w extends e.d{constructor(I,E,j,e,w,z){super(j,z),this._operation=e,this._className=w,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",E)}_doOperation(I){const E=this.a.getValue(I),j=this.b.getValue(I);return this._operation(E,j)}getClassName(){return this._className}}},14351:(I,E,j)=>{j.d(E,{d:()=>t});var e=j(12834),w=j(12819);const z="cachedOperationValue",h="cachedExecutionId";class t extends e.e{constructor(I,E){super(E),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",w.g)}_updateOutputs(I){const E=I._getExecutionVariable(this,h,-1),j=I._getExecutionVariable(this,z,null);if(void 0!==j&&null!==j&&E===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(j,I);else try{const E=this._doOperation(I);if(void 0===E||null===E)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,z,E),I._setExecutionVariable(this,h,I.executionId),this.value.setValue(E,I),this.isValid.setValue(!0,I)}catch(e){this.isValid.setValue(!1,I)}}}},14358:(I,E,j)=>{j.d(E,{b:()=>w});var e=j(14351);class w extends e.d{constructor(I,E,j,e,w){super(E,w),this._operation=j,this._className=e,this.a=this.registerDataInput("a",I)}_doOperation(I){return this._operation(this.a.getValue(I))}getClassName(){return this._className}}}}]);