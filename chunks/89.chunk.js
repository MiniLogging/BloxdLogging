"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[89],{16206:(Y,c,h)=>{h.r(c),h.d(c,{FlowGraphAngleBetweenBlock:()=>a,FlowGraphAxisAngleFromQuaternionBlock:()=>K,FlowGraphConjugateBlock:()=>Z,FlowGraphCrossBlock:()=>d,FlowGraphDotBlock:()=>y,FlowGraphLengthBlock:()=>p,FlowGraphNormalizeBlock:()=>P,FlowGraphQuaternionFromAxisAngleBlock:()=>G,FlowGraphQuaternionFromDirectionsBlock:()=>I,FlowGraphRotate2DBlock:()=>D,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>r,FlowGraphTransformCoordinatesBlock:()=>X});var C=h(14482),E=h(14459),N=h(12825),Q=h(16197),b=h(16204),H=h(12869),w=h(14493),W=h(14131);const q="cachedOperationAxis",k="cachedOperationAngle",M="cachedExecutionId";class p extends b.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicLength(Y)),"FlowGraphLengthBlock",Y)}_polymorphicLength(Y){switch((0,w.h)(Y)){case"Vector2":case"bh":case"Vector4":case"Quaternion":return Y.length();default:throw new Error(`Cannot compute length of value ${Y}`)}}}(0,N.e)("FlowGraphLengthBlock",p);class P extends b.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicNormalize(Y)),"FlowGraphNormalizeBlock",Y)}_polymorphicNormalize(Y){var c;let h;switch((0,w.h)(Y)){case"Vector2":case"bh":case"Vector4":case"Quaternion":if(h=Y.normalizeToNew(),null!==(c=this.config)&&void 0!==c&&c.nanOnZeroLength){0===Y.length()&&h.nc(NaN)}return h;default:throw new Error(`Cannot normalize value ${Y}`)}}}(0,N.e)("FlowGraphNormalizeBlock",P);class y extends Q.c{constructor(Y){super(E.c,E.c,E.n,((Y,c)=>this._polymorphicDot(Y,c)),"FlowGraphDotBlock",Y)}_polymorphicDot(Y,c){switch((0,w.h)(Y)){case"Vector2":case"bh":case"Vector4":case"Quaternion":return Y.dot(c);default:throw new Error(`Cannot get dot product of ${Y} and ${c}`)}}}(0,N.e)("FlowGraphDotBlock",y);class d extends Q.c{constructor(Y){super(E.x,E.x,E.x,((Y,c)=>H.bh.Cross(Y,c)),"FlowGraphCrossBlock",Y)}}(0,N.e)("FlowGraphCrossBlock",d);class D extends Q.c{constructor(Y){super(E.v,E.n,E.v,((Y,c)=>Y.rotate(c)),"FlowGraphRotate2DBlock",Y)}}(0,N.e)("FlowGraphRotate2DBlock",D);class T extends Q.c{constructor(Y){super(E.x,E.r,E.x,((Y,c)=>Y.applyRotationQuaternion(c)),"FlowGraphRotate3DBlock",Y)}}function e(Y,c){switch((0,w.h)(Y)){case"Vector2":case"bh":return c.transformVector(Y);case"Vector4":return new H.Vector4(Y.x*c.m[0]+Y.y*c.m[1]+Y.z*c.m[2]+Y.w*c.m[3],Y.x*c.m[4]+Y.y*c.m[5]+Y.z*c.m[6]+Y.w*c.m[7],Y.x*c.m[8]+Y.y*c.m[9]+Y.z*c.m[10]+Y.w*c.m[11],Y.x*c.m[12]+Y.y*c.m[13]+Y.z*c.m[14]+Y.w*c.m[15]);default:throw new Error(`Cannot transform value ${Y}`)}}(0,N.e)("FlowGraphRotate3DBlock",T);class r extends Q.c{constructor(Y){const c=(null===Y||void 0===Y?void 0:Y.vectorType)||"bh",h="Vector2"===c?"Matrix2D":"bh"===c?"Matrix3D":"Matrix";super((0,E.H)(c),(0,E.H)(h),(0,E.H)(c),e,"FlowGraphTransformVectorBlock",Y)}}(0,N.e)("FlowGraphTransformVectorBlock",r);class X extends Q.c{constructor(Y){super(E.x,E.i,E.x,((Y,c)=>H.bh.TransformCoordinates(Y,c)),"FlowGraphTransformCoordinatesBlock",Y)}}(0,N.e)("FlowGraphTransformCoordinatesBlock",X);class Z extends b.e{constructor(Y){super(E.r,E.r,(Y=>Y.conjugate()),"FlowGraphConjugateBlock",Y)}}(0,N.e)("FlowGraphConjugateBlock",Z);class a extends Q.c{constructor(Y){super(E.r,E.r,E.n,((Y,c)=>(0,W.b)(Y,c)),"FlowGraphAngleBetweenBlock",Y)}}(0,N.e)("FlowGraphAngleBetweenBlock",a);class G extends Q.c{constructor(Y){super(E.x,E.n,E.r,((Y,c)=>H.Quaternion.RotationAxis(Y,c)),"FlowGraphQuaternionFromAxisAngleBlock",Y)}}(0,N.e)("FlowGraphQuaternionFromAxisAngleBlock",G);class K extends C.b{constructor(Y){super(Y),this.a=this.registerDataInput("a",E.r),this.axis=this.registerDataOutput("axis",E.x),this.angle=this.registerDataOutput("angle",E.n),this.isValid=this.registerDataOutput("isValid",E.d)}_updateOutputs(Y){const c=Y._getExecutionVariable(this,M,-1),h=Y._getExecutionVariable(this,q,null),C=Y._getExecutionVariable(this,k,null);if(void 0!==h&&null!==h&&void 0!==C&&null!==C&&c===Y.executionId)this.axis.setValue(h,Y),this.angle.setValue(C,Y);else try{const{axis:c,angle:h}=this.a.getValue(Y).toAxisAngle();Y._setExecutionVariable(this,q,c),Y._setExecutionVariable(this,k,h),Y._setExecutionVariable(this,M,Y.executionId),this.axis.setValue(c,Y),this.angle.setValue(h,Y),this.isValid.setValue(!0,Y)}catch(E){this.isValid.setValue(!1,Y)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,N.e)("FlowGraphAxisAngleFromQuaternionBlock",K);class I extends Q.c{constructor(Y){super(E.x,E.x,E.r,((Y,c)=>(0,W.f)(Y,c)),"FlowGraphQuaternionFromDirectionsBlock",Y)}}},16197:(Y,c,h)=>{h.d(c,{c:()=>E});var C=h(16201);class E extends C.d{constructor(Y,c,h,C,E,N){super(h,N),this._operation=C,this._className=E,this.a=this.registerDataInput("a",Y),this.b=this.registerDataInput("b",c)}_doOperation(Y){const c=this.a.getValue(Y),h=this.b.getValue(Y);return this._operation(c,h)}getClassName(){return this._className}}},16201:(Y,c,h)=>{h.d(c,{d:()=>b});var C=h(14482),E=h(14459);const N="cachedOperationValue",Q="cachedExecutionId";class b extends C.b{constructor(Y,c){super(c),this.value=this.registerDataOutput("value",Y),this.isValid=this.registerDataOutput("isValid",E.d)}_updateOutputs(Y){const c=Y._getExecutionVariable(this,Q,-1),h=Y._getExecutionVariable(this,N,null);if(void 0!==h&&null!==h&&c===Y.executionId)this.isValid.setValue(!0,Y),this.value.setValue(h,Y);else try{const c=this._doOperation(Y);if(void 0===c||null===c)return void this.isValid.setValue(!1,Y);Y._setExecutionVariable(this,N,c),Y._setExecutionVariable(this,Q,Y.executionId),this.value.setValue(c,Y),this.isValid.setValue(!0,Y)}catch(C){this.isValid.setValue(!1,Y)}}}},16204:(Y,c,h)=>{h.d(c,{e:()=>E});var C=h(16201);class E extends C.d{constructor(Y,c,h,C,E){super(c,E),this._operation=h,this._className=C,this.a=this.registerDataInput("a",Y)}_doOperation(Y){return this._operation(this.a.getValue(Y))}getClassName(){return this._className}}}}]);