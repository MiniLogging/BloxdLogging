"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[89],{14527:(H,O,S)=>{S.r(O),S.d(O,{FlowGraphAngleBetweenBlock:()=>l,FlowGraphAxisAngleFromQuaternionBlock:()=>v,FlowGraphConjugateBlock:()=>Y,FlowGraphCrossBlock:()=>y,FlowGraphDotBlock:()=>E,FlowGraphLengthBlock:()=>e,FlowGraphNormalizeBlock:()=>X,FlowGraphQuaternionFromAxisAngleBlock:()=>d,FlowGraphQuaternionFromDirectionsBlock:()=>z,FlowGraphRotate2DBlock:()=>T,FlowGraphRotate3DBlock:()=>K,FlowGraphTransformBlock:()=>D,FlowGraphTransformCoordinatesBlock:()=>F});var t=S(13063),q=S(13035),p=S(11262),G=S(14515),U=S(14523),V=S(11301),w=S(13077),o=S(12732);const h="cachedOperationAxis",a="cachedOperationAngle",j="cachedExecutionId";class e extends U.b{constructor(H){super(q.e,q.t,(H=>this._polymorphicLength(H)),"FlowGraphLengthBlock",H)}_polymorphicLength(H){switch((0,w.j)(H)){case"Vector2":case"eO":case"Vector4":case"Quaternion":return H.length();default:throw new Error(`Cannot compute length of value ${H}`)}}}(0,p.g)("FlowGraphLengthBlock",e);class X extends U.b{constructor(H){super(q.e,q.e,(H=>this._polymorphicNormalize(H)),"FlowGraphNormalizeBlock",H)}_polymorphicNormalize(H){var O;let S;switch((0,w.j)(H)){case"Vector2":case"eO":case"Vector4":case"Quaternion":if(S=H.normalizeToNew(),null!==(O=this.config)&&void 0!==O&&O.nanOnZeroLength){0===H.length()&&S.XU(NaN)}return S;default:throw new Error(`Cannot normalize value ${H}`)}}}(0,p.g)("FlowGraphNormalizeBlock",X);class E extends G.b{constructor(H){super(q.e,q.e,q.t,((H,O)=>this._polymorphicDot(H,O)),"FlowGraphDotBlock",H)}_polymorphicDot(H,O){switch((0,w.j)(H)){case"Vector2":case"eO":case"Vector4":case"Quaternion":return H.dot(O);default:throw new Error(`Cannot get dot product of ${H} and ${O}`)}}}(0,p.g)("FlowGraphDotBlock",E);class y extends G.b{constructor(H){super(q.D,q.D,q.D,((H,O)=>V.eO.Cross(H,O)),"FlowGraphCrossBlock",H)}}(0,p.g)("FlowGraphCrossBlock",y);class T extends G.b{constructor(H){super(q.A,q.t,q.A,((H,O)=>H.rotate(O)),"FlowGraphRotate2DBlock",H)}}(0,p.g)("FlowGraphRotate2DBlock",T);class K extends G.b{constructor(H){super(q.D,q.v,q.D,((H,O)=>H.applyRotationQuaternion(O)),"FlowGraphRotate3DBlock",H)}}function b(H,O){switch((0,w.j)(H)){case"Vector2":case"eO":return O.transformVector(H);case"Vector4":return new V.Vector4(H.x*O.m[0]+H.y*O.m[1]+H.z*O.m[2]+H.w*O.m[3],H.x*O.m[4]+H.y*O.m[5]+H.z*O.m[6]+H.w*O.m[7],H.x*O.m[8]+H.y*O.m[9]+H.z*O.m[10]+H.w*O.m[11],H.x*O.m[12]+H.y*O.m[13]+H.z*O.m[14]+H.w*O.m[15]);default:throw new Error(`Cannot transform value ${H}`)}}(0,p.g)("FlowGraphRotate3DBlock",K);class D extends G.b{constructor(H){const O=(null===H||void 0===H?void 0:H.vectorType)||"eO",S="Vector2"===O?"Matrix2D":"eO"===O?"Matrix3D":"Matrix";super((0,q.Q)(O),(0,q.Q)(S),(0,q.Q)(O),b,"FlowGraphTransformVectorBlock",H)}}(0,p.g)("FlowGraphTransformVectorBlock",D);class F extends G.b{constructor(H){super(q.D,q.p,q.D,((H,O)=>V.eO.TransformCoordinates(H,O)),"FlowGraphTransformCoordinatesBlock",H)}}(0,p.g)("FlowGraphTransformCoordinatesBlock",F);class Y extends U.b{constructor(H){super(q.v,q.v,(H=>H.conjugate()),"FlowGraphConjugateBlock",H)}}(0,p.g)("FlowGraphConjugateBlock",Y);class l extends G.b{constructor(H){super(q.v,q.v,q.t,((H,O)=>(0,o.c)(H,O)),"FlowGraphAngleBetweenBlock",H)}}(0,p.g)("FlowGraphAngleBetweenBlock",l);class d extends G.b{constructor(H){super(q.D,q.t,q.v,((H,O)=>V.Quaternion.RotationAxis(H,O)),"FlowGraphQuaternionFromAxisAngleBlock",H)}}(0,p.g)("FlowGraphQuaternionFromAxisAngleBlock",d);class v extends t.c{constructor(H){super(H),this.a=this.registerDataInput("a",q.v),this.axis=this.registerDataOutput("axis",q.D),this.angle=this.registerDataOutput("angle",q.t),this.isValid=this.registerDataOutput("isValid",q.i)}_updateOutputs(H){const O=H._getExecutionVariable(this,j,-1),S=H._getExecutionVariable(this,h,null),t=H._getExecutionVariable(this,a,null);if(void 0!==S&&null!==S&&void 0!==t&&null!==t&&O===H.executionId)this.axis.setValue(S,H),this.angle.setValue(t,H);else try{const{axis:O,angle:S}=this.a.getValue(H).toAxisAngle();H._setExecutionVariable(this,h,O),H._setExecutionVariable(this,a,S),H._setExecutionVariable(this,j,H.executionId),this.axis.setValue(O,H),this.angle.setValue(S,H),this.isValid.setValue(!0,H)}catch(q){this.isValid.setValue(!1,H)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,p.g)("FlowGraphAxisAngleFromQuaternionBlock",v);class z extends G.b{constructor(H){super(q.D,q.D,q.v,((H,O)=>(0,o.f)(H,O)),"FlowGraphQuaternionFromDirectionsBlock",H)}}},14515:(H,O,S)=>{S.d(O,{b:()=>q});var t=S(14517);class q extends t.e{constructor(H,O,S,t,q,p){super(S,p),this._operation=t,this._className=q,this.a=this.registerDataInput("a",H),this.b=this.registerDataInput("b",O)}_doOperation(H){const O=this.a.getValue(H),S=this.b.getValue(H);return this._operation(O,S)}getClassName(){return this._className}}},14517:(H,O,S)=>{S.d(O,{e:()=>U});var t=S(13063),q=S(13035);const p="cachedOperationValue",G="cachedExecutionId";class U extends t.c{constructor(H,O){super(O),this.value=this.registerDataOutput("value",H),this.isValid=this.registerDataOutput("isValid",q.i)}_updateOutputs(H){const O=H._getExecutionVariable(this,G,-1),S=H._getExecutionVariable(this,p,null);if(void 0!==S&&null!==S&&O===H.executionId)this.isValid.setValue(!0,H),this.value.setValue(S,H);else try{const O=this._doOperation(H);if(void 0===O||null===O)return void this.isValid.setValue(!1,H);H._setExecutionVariable(this,p,O),H._setExecutionVariable(this,G,H.executionId),this.value.setValue(O,H),this.isValid.setValue(!0,H)}catch(t){this.isValid.setValue(!1,H)}}}},14523:(H,O,S)=>{S.d(O,{b:()=>q});var t=S(14517);class q extends t.e{constructor(H,O,S,t,q){super(O,q),this._operation=S,this._className=t,this.a=this.registerDataInput("a",H)}_doOperation(H){return this._operation(this.a.getValue(H))}getClassName(){return this._className}}}}]);