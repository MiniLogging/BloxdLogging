"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[89],{15618:(M,Z,P)=>{P.r(Z),P.d(Z,{FlowGraphAngleBetweenBlock:()=>l,FlowGraphAxisAngleFromQuaternionBlock:()=>Q,FlowGraphConjugateBlock:()=>D,FlowGraphCrossBlock:()=>L,FlowGraphDotBlock:()=>n,FlowGraphLengthBlock:()=>B,FlowGraphNormalizeBlock:()=>U,FlowGraphQuaternionFromAxisAngleBlock:()=>h,FlowGraphQuaternionFromDirectionsBlock:()=>I,FlowGraphRotate2DBlock:()=>u,FlowGraphRotate3DBlock:()=>N,FlowGraphTransformBlock:()=>t,FlowGraphTransformCoordinatesBlock:()=>F});var x=P(14093),c=P(14073),w=P(12317),v=P(15602),G=P(15612),mM=P(12373),K=P(14105),d=P(13759);const O="cachedOperationAxis",H="cachedOperationAngle",j="cachedExecutionId";class B extends G.d{constructor(M){super(c.e,c.u,(M=>this._polymorphicLength(M)),"FlowGraphLengthBlock",M)}_polymorphicLength(M){switch((0,K.l)(M)){case"Vector2":case"BZ":case"Vector4":case"Quaternion":return M.length();default:throw new Error(`Cannot compute length of value ${M}`)}}}(0,w.g)("FlowGraphLengthBlock",B);class U extends G.d{constructor(M){super(c.e,c.e,(M=>this._polymorphicNormalize(M)),"FlowGraphNormalizeBlock",M)}_polymorphicNormalize(M){var Z;let P;switch((0,K.l)(M)){case"Vector2":case"BZ":case"Vector4":case"Quaternion":if(P=M.normalizeToNew(),null!==(Z=this.config)&&void 0!==Z&&Z.nanOnZeroLength){0===M.length()&&P.Qc(NaN)}return P;default:throw new Error(`Cannot normalize value ${M}`)}}}(0,w.g)("FlowGraphNormalizeBlock",U);class n extends v.c{constructor(M){super(c.e,c.e,c.u,((M,Z)=>this._polymorphicDot(M,Z)),"FlowGraphDotBlock",M)}_polymorphicDot(M,Z){switch((0,K.l)(M)){case"Vector2":case"BZ":case"Vector4":case"Quaternion":return M.dot(Z);default:throw new Error(`Cannot get dot product of ${M} and ${Z}`)}}}(0,w.g)("FlowGraphDotBlock",n);class L extends v.c{constructor(M){super(c.H,c.H,c.H,((M,Z)=>mM.BZ.Cross(M,Z)),"FlowGraphCrossBlock",M)}}(0,w.g)("FlowGraphCrossBlock",L);class u extends v.c{constructor(M){super(c.F,c.u,c.F,((M,Z)=>M.rotate(Z)),"FlowGraphRotate2DBlock",M)}}(0,w.g)("FlowGraphRotate2DBlock",u);class N extends v.c{constructor(M){super(c.H,c.x,c.H,((M,Z)=>M.applyRotationQuaternion(Z)),"FlowGraphRotate3DBlock",M)}}function J(M,Z){switch((0,K.l)(M)){case"Vector2":case"BZ":return Z.transformVector(M);case"Vector4":return new mM.Vector4(M.x*Z.m[0]+M.y*Z.m[1]+M.z*Z.m[2]+M.w*Z.m[3],M.x*Z.m[4]+M.y*Z.m[5]+M.z*Z.m[6]+M.w*Z.m[7],M.x*Z.m[8]+M.y*Z.m[9]+M.z*Z.m[10]+M.w*Z.m[11],M.x*Z.m[12]+M.y*Z.m[13]+M.z*Z.m[14]+M.w*Z.m[15]);default:throw new Error(`Cannot transform value ${M}`)}}(0,w.g)("FlowGraphRotate3DBlock",N);class t extends v.c{constructor(M){const Z=(null===M||void 0===M?void 0:M.vectorType)||"BZ",P="Vector2"===Z?"Matrix2D":"BZ"===Z?"Matrix3D":"Matrix";super((0,c.R)(Z),(0,c.R)(P),(0,c.R)(Z),J,"FlowGraphTransformVectorBlock",M)}}(0,w.g)("FlowGraphTransformVectorBlock",t);class F extends v.c{constructor(M){super(c.H,c.m,c.H,((M,Z)=>mM.BZ.TransformCoordinates(M,Z)),"FlowGraphTransformCoordinatesBlock",M)}}(0,w.g)("FlowGraphTransformCoordinatesBlock",F);class D extends G.d{constructor(M){super(c.x,c.x,(M=>M.conjugate()),"FlowGraphConjugateBlock",M)}}(0,w.g)("FlowGraphConjugateBlock",D);class l extends v.c{constructor(M){super(c.x,c.x,c.u,((M,Z)=>(0,d.d)(M,Z)),"FlowGraphAngleBetweenBlock",M)}}(0,w.g)("FlowGraphAngleBetweenBlock",l);class h extends v.c{constructor(M){super(c.H,c.u,c.x,((M,Z)=>mM.Quaternion.RotationAxis(M,Z)),"FlowGraphQuaternionFromAxisAngleBlock",M)}}(0,w.g)("FlowGraphQuaternionFromAxisAngleBlock",h);class Q extends x.c{constructor(M){super(M),this.a=this.registerDataInput("a",c.x),this.axis=this.registerDataOutput("axis",c.H),this.angle=this.registerDataOutput("angle",c.u),this.isValid=this.registerDataOutput("isValid",c.g)}_updateOutputs(M){const Z=M._getExecutionVariable(this,j,-1),P=M._getExecutionVariable(this,O,null),x=M._getExecutionVariable(this,H,null);if(void 0!==P&&null!==P&&void 0!==x&&null!==x&&Z===M.executionId)this.axis.setValue(P,M),this.angle.setValue(x,M);else try{const{axis:Z,angle:P}=this.a.getValue(M).toAxisAngle();M._setExecutionVariable(this,O,Z),M._setExecutionVariable(this,H,P),M._setExecutionVariable(this,j,M.executionId),this.axis.setValue(Z,M),this.angle.setValue(P,M),this.isValid.setValue(!0,M)}catch(c){this.isValid.setValue(!1,M)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,w.g)("FlowGraphAxisAngleFromQuaternionBlock",Q);class I extends v.c{constructor(M){super(c.H,c.H,c.x,((M,Z)=>(0,d.h)(M,Z)),"FlowGraphQuaternionFromDirectionsBlock",M)}}},15602:(M,Z,P)=>{P.d(Z,{c:()=>c});var x=P(15610);class c extends x.e{constructor(M,Z,P,x,c,w){super(P,w),this._operation=x,this._className=c,this.a=this.registerDataInput("a",M),this.b=this.registerDataInput("b",Z)}_doOperation(M){const Z=this.a.getValue(M),P=this.b.getValue(M);return this._operation(Z,P)}getClassName(){return this._className}}},15610:(M,Z,P)=>{P.d(Z,{e:()=>G});var x=P(14093),c=P(14073);const w="cachedOperationValue",v="cachedExecutionId";class G extends x.c{constructor(M,Z){super(Z),this.value=this.registerDataOutput("value",M),this.isValid=this.registerDataOutput("isValid",c.g)}_updateOutputs(M){const Z=M._getExecutionVariable(this,v,-1),P=M._getExecutionVariable(this,w,null);if(void 0!==P&&null!==P&&Z===M.executionId)this.isValid.setValue(!0,M),this.value.setValue(P,M);else try{const Z=this._doOperation(M);if(void 0===Z||null===Z)return void this.isValid.setValue(!1,M);M._setExecutionVariable(this,w,Z),M._setExecutionVariable(this,v,M.executionId),this.value.setValue(Z,M),this.isValid.setValue(!0,M)}catch(x){this.isValid.setValue(!1,M)}}}},15612:(M,Z,P)=>{P.d(Z,{d:()=>c});var x=P(15610);class c extends x.e{constructor(M,Z,P,x,c){super(Z,c),this._operation=P,this._className=x,this.a=this.registerDataInput("a",M)}_doOperation(M){return this._operation(this.a.getValue(M))}getClassName(){return this._className}}}}]);