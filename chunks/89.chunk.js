"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[89],{15887:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphAngleBetweenBlock:()=>d,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>P,FlowGraphCrossBlock:()=>H,FlowGraphDotBlock:()=>V,FlowGraphLengthBlock:()=>Y,FlowGraphNormalizeBlock:()=>S,FlowGraphQuaternionFromAxisAngleBlock:()=>K,FlowGraphQuaternionFromDirectionsBlock:()=>i,FlowGraphRotate2DBlock:()=>Q,FlowGraphRotate3DBlock:()=>q,FlowGraphTransformBlock:()=>v,FlowGraphTransformCoordinatesBlock:()=>D});var mL=x(14371),p=x(14348),G=x(12547),F=x(15874),a=x(15881),o=x(12589),A=x(14379),r=x(14030);const h="cachedOperationAxis",b="cachedOperationAngle",E="cachedExecutionId";class Y extends a.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicLength(L)),"FlowGraphLengthBlock",L)}_polymorphicLength(L){switch((0,A.l)(L)){case"Vector2":case"YU":case"Vector4":case"Quaternion":return L.length();default:throw new Error(`Cannot compute length of value ${L}`)}}}(0,G.d)("FlowGraphLengthBlock",Y);class S extends a.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicNormalize(L)),"FlowGraphNormalizeBlock",L)}_polymorphicNormalize(L){var U;let x;switch((0,A.l)(L)){case"Vector2":case"YU":case"Vector4":case"Quaternion":if(x=L.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===L.length()&&x.la(NaN)}return x;default:throw new Error(`Cannot normalize value ${L}`)}}}(0,G.d)("FlowGraphNormalizeBlock",S);class V extends F.c{constructor(L){super(p.c,p.c,p.u,((L,U)=>this._polymorphicDot(L,U)),"FlowGraphDotBlock",L)}_polymorphicDot(L,U){switch((0,A.l)(L)){case"Vector2":case"YU":case"Vector4":case"Quaternion":return L.dot(U);default:throw new Error(`Cannot get dot product of ${L} and ${U}`)}}}(0,G.d)("FlowGraphDotBlock",V);class H extends F.c{constructor(L){super(p.B,p.B,p.B,((L,U)=>o.YU.Cross(L,U)),"FlowGraphCrossBlock",L)}}(0,G.d)("FlowGraphCrossBlock",H);class Q extends F.c{constructor(L){super(p.A,p.u,p.A,((L,U)=>L.rotate(U)),"FlowGraphRotate2DBlock",L)}}(0,G.d)("FlowGraphRotate2DBlock",Q);class q extends F.c{constructor(L){super(p.B,p.x,p.B,((L,U)=>L.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",L)}}function f(L,U){switch((0,A.l)(L)){case"Vector2":case"YU":return U.transformVector(L);case"Vector4":return new o.Vector4(L.x*U.m[0]+L.y*U.m[1]+L.z*U.m[2]+L.w*U.m[3],L.x*U.m[4]+L.y*U.m[5]+L.z*U.m[6]+L.w*U.m[7],L.x*U.m[8]+L.y*U.m[9]+L.z*U.m[10]+L.w*U.m[11],L.x*U.m[12]+L.y*U.m[13]+L.z*U.m[14]+L.w*U.m[15]);default:throw new Error(`Cannot transform value ${L}`)}}(0,G.d)("FlowGraphRotate3DBlock",q);class v extends F.c{constructor(L){const U=(null===L||void 0===L?void 0:L.vectorType)||"YU",x="Vector2"===U?"Matrix2D":"YU"===U?"Matrix3D":"Matrix";super((0,p.I)(U),(0,p.I)(x),(0,p.I)(U),f,"FlowGraphTransformVectorBlock",L)}}(0,G.d)("FlowGraphTransformVectorBlock",v);class D extends F.c{constructor(L){super(p.B,p.m,p.B,((L,U)=>o.YU.TransformCoordinates(L,U)),"FlowGraphTransformCoordinatesBlock",L)}}(0,G.d)("FlowGraphTransformCoordinatesBlock",D);class P extends a.d{constructor(L){super(p.x,p.x,(L=>L.conjugate()),"FlowGraphConjugateBlock",L)}}(0,G.d)("FlowGraphConjugateBlock",P);class d extends F.c{constructor(L){super(p.x,p.x,p.u,((L,U)=>(0,r.b)(L,U)),"FlowGraphAngleBetweenBlock",L)}}(0,G.d)("FlowGraphAngleBetweenBlock",d);class K extends F.c{constructor(L){super(p.B,p.u,p.x,((L,U)=>o.Quaternion.RotationAxis(L,U)),"FlowGraphQuaternionFromAxisAngleBlock",L)}}(0,G.d)("FlowGraphQuaternionFromAxisAngleBlock",K);class l extends mL.e{constructor(L){super(L),this.a=this.registerDataInput("a",p.x),this.axis=this.registerDataOutput("axis",p.B),this.angle=this.registerDataOutput("angle",p.u),this.isValid=this.registerDataOutput("isValid",p.e)}_updateOutputs(L){const U=L._getExecutionVariable(this,E,-1),x=L._getExecutionVariable(this,h,null),mL=L._getExecutionVariable(this,b,null);if(void 0!==x&&null!==x&&void 0!==mL&&null!==mL&&U===L.executionId)this.axis.setValue(x,L),this.angle.setValue(mL,L);else try{const{axis:U,angle:x}=this.a.getValue(L).toAxisAngle();L._setExecutionVariable(this,h,U),L._setExecutionVariable(this,b,x),L._setExecutionVariable(this,E,L.executionId),this.axis.setValue(U,L),this.angle.setValue(x,L),this.isValid.setValue(!0,L)}catch(p){this.isValid.setValue(!1,L)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,G.d)("FlowGraphAxisAngleFromQuaternionBlock",l);class i extends F.c{constructor(L){super(p.B,p.B,p.x,((L,U)=>(0,r.c)(L,U)),"FlowGraphQuaternionFromDirectionsBlock",L)}}},15874:(L,U,x)=>{x.d(U,{c:()=>p});var mL=x(15876);class p extends mL.e{constructor(L,U,x,mL,p,G){super(x,G),this._operation=mL,this._className=p,this.a=this.registerDataInput("a",L),this.b=this.registerDataInput("b",U)}_doOperation(L){const U=this.a.getValue(L),x=this.b.getValue(L);return this._operation(U,x)}getClassName(){return this._className}}},15876:(L,U,x)=>{x.d(U,{e:()=>a});var mL=x(14371),p=x(14348);const G="cachedOperationValue",F="cachedExecutionId";class a extends mL.e{constructor(L,U){super(U),this.value=this.registerDataOutput("value",L),this.isValid=this.registerDataOutput("isValid",p.e)}_updateOutputs(L){const U=L._getExecutionVariable(this,F,-1),x=L._getExecutionVariable(this,G,null);if(void 0!==x&&null!==x&&U===L.executionId)this.isValid.setValue(!0,L),this.value.setValue(x,L);else try{const U=this._doOperation(L);if(void 0===U||null===U)return void this.isValid.setValue(!1,L);L._setExecutionVariable(this,G,U),L._setExecutionVariable(this,F,L.executionId),this.value.setValue(U,L),this.isValid.setValue(!0,L)}catch(mL){this.isValid.setValue(!1,L)}}}},15881:(L,U,x)=>{x.d(U,{d:()=>p});var mL=x(15876);class p extends mL.e{constructor(L,U,x,mL,p){super(U,p),this._operation=x,this._className=mL,this.a=this.registerDataInput("a",L)}_doOperation(L){return this._operation(this.a.getValue(L))}getClassName(){return this._className}}}}]);