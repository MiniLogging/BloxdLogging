"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[89],{14415:(k,h,o)=>{o.r(h),o.d(h,{FlowGraphAngleBetweenBlock:()=>i,FlowGraphAxisAngleFromQuaternionBlock:()=>R,FlowGraphConjugateBlock:()=>V,FlowGraphCrossBlock:()=>f,FlowGraphDotBlock:()=>W,FlowGraphLengthBlock:()=>X,FlowGraphNormalizeBlock:()=>c,FlowGraphQuaternionFromAxisAngleBlock:()=>F,FlowGraphQuaternionFromDirectionsBlock:()=>s,FlowGraphRotate2DBlock:()=>M,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>d,FlowGraphTransformCoordinatesBlock:()=>b});var x=o(12961),I=o(12936),q=o(11199),Y=o(14405),J=o(14412),G=o(11239),l=o(12972),A=o(12642);const K="cachedOperationAxis",a="cachedOperationAngle",N="cachedExecutionId";class X extends J.c{constructor(k){super(I.d,I.o,(k=>this._polymorphicLength(k)),"FlowGraphLengthBlock",k)}_polymorphicLength(k){switch((0,l.m)(k)){case"Vector2":case"Vh":case"Vector4":case"Quaternion":return k.length();default:throw new Error(`Cannot compute length of value ${k}`)}}}(0,q.g)("FlowGraphLengthBlock",X);class c extends J.c{constructor(k){super(I.d,I.d,(k=>this._polymorphicNormalize(k)),"FlowGraphNormalizeBlock",k)}_polymorphicNormalize(k){var h;let o;switch((0,l.m)(k)){case"Vector2":case"Vh":case"Vector4":case"Quaternion":if(o=k.normalizeToNew(),null!==(h=this.config)&&void 0!==h&&h.nanOnZeroLength){0===k.length()&&o.FJ(NaN)}return o;default:throw new Error(`Cannot normalize value ${k}`)}}}(0,q.g)("FlowGraphNormalizeBlock",c);class W extends Y.b{constructor(k){super(I.d,I.d,I.o,((k,h)=>this._polymorphicDot(k,h)),"FlowGraphDotBlock",k)}_polymorphicDot(k,h){switch((0,l.m)(k)){case"Vector2":case"Vh":case"Vector4":case"Quaternion":return k.dot(h);default:throw new Error(`Cannot get dot product of ${k} and ${h}`)}}}(0,q.g)("FlowGraphDotBlock",W);class f extends Y.b{constructor(k){super(I.w,I.w,I.w,((k,h)=>G.Vh.Cross(k,h)),"FlowGraphCrossBlock",k)}}(0,q.g)("FlowGraphCrossBlock",f);class M extends Y.b{constructor(k){super(I.u,I.o,I.u,((k,h)=>k.rotate(h)),"FlowGraphRotate2DBlock",k)}}(0,q.g)("FlowGraphRotate2DBlock",M);class T extends Y.b{constructor(k){super(I.w,I.q,I.w,((k,h)=>k.applyRotationQuaternion(h)),"FlowGraphRotate3DBlock",k)}}function j(k,h){switch((0,l.m)(k)){case"Vector2":case"Vh":return h.transformVector(k);case"Vector4":return new G.Vector4(k.x*h.m[0]+k.y*h.m[1]+k.z*h.m[2]+k.w*h.m[3],k.x*h.m[4]+k.y*h.m[5]+k.z*h.m[6]+k.w*h.m[7],k.x*h.m[8]+k.y*h.m[9]+k.z*h.m[10]+k.w*h.m[11],k.x*h.m[12]+k.y*h.m[13]+k.z*h.m[14]+k.w*h.m[15]);default:throw new Error(`Cannot transform value ${k}`)}}(0,q.g)("FlowGraphRotate3DBlock",T);class d extends Y.b{constructor(k){const h=(null===k||void 0===k?void 0:k.vectorType)||"Vh",o="Vector2"===h?"Matrix2D":"Vh"===h?"Matrix3D":"Matrix";super((0,I.D)(h),(0,I.D)(o),(0,I.D)(h),j,"FlowGraphTransformVectorBlock",k)}}(0,q.g)("FlowGraphTransformVectorBlock",d);class b extends Y.b{constructor(k){super(I.w,I.k,I.w,((k,h)=>G.Vh.TransformCoordinates(k,h)),"FlowGraphTransformCoordinatesBlock",k)}}(0,q.g)("FlowGraphTransformCoordinatesBlock",b);class V extends J.c{constructor(k){super(I.q,I.q,(k=>k.conjugate()),"FlowGraphConjugateBlock",k)}}(0,q.g)("FlowGraphConjugateBlock",V);class i extends Y.b{constructor(k){super(I.q,I.q,I.o,((k,h)=>(0,A.e)(k,h)),"FlowGraphAngleBetweenBlock",k)}}(0,q.g)("FlowGraphAngleBetweenBlock",i);class F extends Y.b{constructor(k){super(I.w,I.o,I.q,((k,h)=>G.Quaternion.RotationAxis(k,h)),"FlowGraphQuaternionFromAxisAngleBlock",k)}}(0,q.g)("FlowGraphQuaternionFromAxisAngleBlock",F);class R extends x.b{constructor(k){super(k),this.a=this.registerDataInput("a",I.q),this.axis=this.registerDataOutput("axis",I.w),this.angle=this.registerDataOutput("angle",I.o),this.isValid=this.registerDataOutput("isValid",I.h)}_updateOutputs(k){const h=k._getExecutionVariable(this,N,-1),o=k._getExecutionVariable(this,K,null),x=k._getExecutionVariable(this,a,null);if(void 0!==o&&null!==o&&void 0!==x&&null!==x&&h===k.executionId)this.axis.setValue(o,k),this.angle.setValue(x,k);else try{const{axis:h,angle:o}=this.a.getValue(k).toAxisAngle();k._setExecutionVariable(this,K,h),k._setExecutionVariable(this,a,o),k._setExecutionVariable(this,N,k.executionId),this.axis.setValue(h,k),this.angle.setValue(o,k),this.isValid.setValue(!0,k)}catch(I){this.isValid.setValue(!1,k)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,q.g)("FlowGraphAxisAngleFromQuaternionBlock",R);class s extends Y.b{constructor(k){super(I.w,I.w,I.q,((k,h)=>(0,A.i)(k,h)),"FlowGraphQuaternionFromDirectionsBlock",k)}}},14405:(k,h,o)=>{o.d(h,{b:()=>I});var x=o(14409);class I extends x.c{constructor(k,h,o,x,I,q){super(o,q),this._operation=x,this._className=I,this.a=this.registerDataInput("a",k),this.b=this.registerDataInput("b",h)}_doOperation(k){const h=this.a.getValue(k),o=this.b.getValue(k);return this._operation(h,o)}getClassName(){return this._className}}},14409:(k,h,o)=>{o.d(h,{c:()=>J});var x=o(12961),I=o(12936);const q="cachedOperationValue",Y="cachedExecutionId";class J extends x.b{constructor(k,h){super(h),this.value=this.registerDataOutput("value",k),this.isValid=this.registerDataOutput("isValid",I.h)}_updateOutputs(k){const h=k._getExecutionVariable(this,Y,-1),o=k._getExecutionVariable(this,q,null);if(void 0!==o&&null!==o&&h===k.executionId)this.isValid.setValue(!0,k),this.value.setValue(o,k);else try{const h=this._doOperation(k);if(void 0===h||null===h)return void this.isValid.setValue(!1,k);k._setExecutionVariable(this,q,h),k._setExecutionVariable(this,Y,k.executionId),this.value.setValue(h,k),this.isValid.setValue(!0,k)}catch(x){this.isValid.setValue(!1,k)}}}},14412:(k,h,o)=>{o.d(h,{c:()=>I});var x=o(14409);class I extends x.c{constructor(k,h,o,x,I){super(h,I),this._operation=o,this._className=x,this.a=this.registerDataInput("a",k)}_doOperation(k){return this._operation(this.a.getValue(k))}getClassName(){return this._className}}}}]);