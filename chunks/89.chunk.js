"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[89],{15621:(E,H,d)=>{d.r(H),d.d(H,{FlowGraphAngleBetweenBlock:()=>P,FlowGraphAxisAngleFromQuaternionBlock:()=>X,FlowGraphConjugateBlock:()=>f,FlowGraphCrossBlock:()=>L,FlowGraphDotBlock:()=>Q,FlowGraphLengthBlock:()=>w,FlowGraphNormalizeBlock:()=>R,FlowGraphQuaternionFromAxisAngleBlock:()=>j,FlowGraphQuaternionFromDirectionsBlock:()=>W,FlowGraphRotate2DBlock:()=>D,FlowGraphRotate3DBlock:()=>e,FlowGraphTransformBlock:()=>i,FlowGraphTransformCoordinatesBlock:()=>p});var n=d(14125),Z=d(14103),I=d(12344),g=d(15601),l=d(15618),r=d(12384),t=d(14132),S=d(13792);const M="cachedOperationAxis",V="cachedOperationAngle",C="cachedExecutionId";class w extends l.c{constructor(E){super(Z.e,Z.r,(E=>this._polymorphicLength(E)),"FlowGraphLengthBlock",E)}_polymorphicLength(E){switch((0,t.g)(E)){case"Vector2":case"wH":case"Vector4":case"Quaternion":return E.length();default:throw new Error(`Cannot compute length of value ${E}`)}}}(0,I.e)("FlowGraphLengthBlock",w);class R extends l.c{constructor(E){super(Z.e,Z.e,(E=>this._polymorphicNormalize(E)),"FlowGraphNormalizeBlock",E)}_polymorphicNormalize(E){var H;let d;switch((0,t.g)(E)){case"Vector2":case"wH":case"Vector4":case"Quaternion":if(d=E.normalizeToNew(),null!==(H=this.config)&&void 0!==H&&H.nanOnZeroLength){0===E.length()&&d.ng(NaN)}return d;default:throw new Error(`Cannot normalize value ${E}`)}}}(0,I.e)("FlowGraphNormalizeBlock",R);class Q extends g.e{constructor(E){super(Z.e,Z.e,Z.r,((E,H)=>this._polymorphicDot(E,H)),"FlowGraphDotBlock",E)}_polymorphicDot(E,H){switch((0,t.g)(E)){case"Vector2":case"wH":case"Vector4":case"Quaternion":return E.dot(H);default:throw new Error(`Cannot get dot product of ${E} and ${H}`)}}}(0,I.e)("FlowGraphDotBlock",Q);class L extends g.e{constructor(E){super(Z.E,Z.E,Z.E,((E,H)=>r.wH.Cross(E,H)),"FlowGraphCrossBlock",E)}}(0,I.e)("FlowGraphCrossBlock",L);class D extends g.e{constructor(E){super(Z.B,Z.r,Z.B,((E,H)=>E.rotate(H)),"FlowGraphRotate2DBlock",E)}}(0,I.e)("FlowGraphRotate2DBlock",D);class e extends g.e{constructor(E){super(Z.E,Z.v,Z.E,((E,H)=>E.applyRotationQuaternion(H)),"FlowGraphRotate3DBlock",E)}}function s(E,H){switch((0,t.g)(E)){case"Vector2":case"wH":return H.transformVector(E);case"Vector4":return new r.Vector4(E.x*H.m[0]+E.y*H.m[1]+E.z*H.m[2]+E.w*H.m[3],E.x*H.m[4]+E.y*H.m[5]+E.z*H.m[6]+E.w*H.m[7],E.x*H.m[8]+E.y*H.m[9]+E.z*H.m[10]+E.w*H.m[11],E.x*H.m[12]+E.y*H.m[13]+E.z*H.m[14]+E.w*H.m[15]);default:throw new Error(`Cannot transform value ${E}`)}}(0,I.e)("FlowGraphRotate3DBlock",e);class i extends g.e{constructor(E){const H=(null===E||void 0===E?void 0:E.vectorType)||"wH",d="Vector2"===H?"Matrix2D":"wH"===H?"Matrix3D":"Matrix";super((0,Z.M)(H),(0,Z.M)(d),(0,Z.M)(H),s,"FlowGraphTransformVectorBlock",E)}}(0,I.e)("FlowGraphTransformVectorBlock",i);class p extends g.e{constructor(E){super(Z.E,Z.m,Z.E,((E,H)=>r.wH.TransformCoordinates(E,H)),"FlowGraphTransformCoordinatesBlock",E)}}(0,I.e)("FlowGraphTransformCoordinatesBlock",p);class f extends l.c{constructor(E){super(Z.v,Z.v,(E=>E.conjugate()),"FlowGraphConjugateBlock",E)}}(0,I.e)("FlowGraphConjugateBlock",f);class P extends g.e{constructor(E){super(Z.v,Z.v,Z.r,((E,H)=>(0,S.c)(E,H)),"FlowGraphAngleBetweenBlock",E)}}(0,I.e)("FlowGraphAngleBetweenBlock",P);class j extends g.e{constructor(E){super(Z.E,Z.r,Z.v,((E,H)=>r.Quaternion.RotationAxis(E,H)),"FlowGraphQuaternionFromAxisAngleBlock",E)}}(0,I.e)("FlowGraphQuaternionFromAxisAngleBlock",j);class X extends n.c{constructor(E){super(E),this.a=this.registerDataInput("a",Z.v),this.axis=this.registerDataOutput("axis",Z.E),this.angle=this.registerDataOutput("angle",Z.r),this.isValid=this.registerDataOutput("isValid",Z.h)}_updateOutputs(E){const H=E._getExecutionVariable(this,C,-1),d=E._getExecutionVariable(this,M,null),n=E._getExecutionVariable(this,V,null);if(void 0!==d&&null!==d&&void 0!==n&&null!==n&&H===E.executionId)this.axis.setValue(d,E),this.angle.setValue(n,E);else try{const{axis:H,angle:d}=this.a.getValue(E).toAxisAngle();E._setExecutionVariable(this,M,H),E._setExecutionVariable(this,V,d),E._setExecutionVariable(this,C,E.executionId),this.axis.setValue(H,E),this.angle.setValue(d,E),this.isValid.setValue(!0,E)}catch(Z){this.isValid.setValue(!1,E)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,I.e)("FlowGraphAxisAngleFromQuaternionBlock",X);class W extends g.e{constructor(E){super(Z.E,Z.E,Z.v,((E,H)=>(0,S.d)(E,H)),"FlowGraphQuaternionFromDirectionsBlock",E)}}},15601:(E,H,d)=>{d.d(H,{e:()=>Z});var n=d(15610);class Z extends n.e{constructor(E,H,d,n,Z,I){super(d,I),this._operation=n,this._className=Z,this.a=this.registerDataInput("a",E),this.b=this.registerDataInput("b",H)}_doOperation(E){const H=this.a.getValue(E),d=this.b.getValue(E);return this._operation(H,d)}getClassName(){return this._className}}},15610:(E,H,d)=>{d.d(H,{e:()=>l});var n=d(14125),Z=d(14103);const I="cachedOperationValue",g="cachedExecutionId";class l extends n.c{constructor(E,H){super(H),this.value=this.registerDataOutput("value",E),this.isValid=this.registerDataOutput("isValid",Z.h)}_updateOutputs(E){const H=E._getExecutionVariable(this,g,-1),d=E._getExecutionVariable(this,I,null);if(void 0!==d&&null!==d&&H===E.executionId)this.isValid.setValue(!0,E),this.value.setValue(d,E);else try{const H=this._doOperation(E);if(void 0===H||null===H)return void this.isValid.setValue(!1,E);E._setExecutionVariable(this,I,H),E._setExecutionVariable(this,g,E.executionId),this.value.setValue(H,E),this.isValid.setValue(!0,E)}catch(n){this.isValid.setValue(!1,E)}}}},15618:(E,H,d)=>{d.d(H,{c:()=>Z});var n=d(15610);class Z extends n.e{constructor(E,H,d,n,Z){super(H,Z),this._operation=d,this._className=n,this.a=this.registerDataInput("a",E)}_doOperation(E){return this._operation(this.a.getValue(E))}getClassName(){return this._className}}}}]);