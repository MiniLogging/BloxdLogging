"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[89],{14634:(m,S,h)=>{h.r(S),h.d(S,{FlowGraphAngleBetweenBlock:()=>s,FlowGraphAxisAngleFromQuaternionBlock:()=>T,FlowGraphConjugateBlock:()=>o,FlowGraphCrossBlock:()=>n,FlowGraphDotBlock:()=>E,FlowGraphLengthBlock:()=>B,FlowGraphNormalizeBlock:()=>D,FlowGraphQuaternionFromAxisAngleBlock:()=>v,FlowGraphQuaternionFromDirectionsBlock:()=>X,FlowGraphRotate2DBlock:()=>L,FlowGraphRotate3DBlock:()=>U,FlowGraphTransformBlock:()=>R,FlowGraphTransformCoordinatesBlock:()=>y});var l=h(13074),M=h(13060),O=h(11293),u=h(14618),b=h(14629),q=h(11347),Y=h(13090),V=h(12740);const I="cachedOperationAxis",Z="cachedOperationAngle",C="cachedExecutionId";class B extends b.b{constructor(m){super(M.b,M.p,(m=>this._polymorphicLength(m)),"FlowGraphLengthBlock",m)}_polymorphicLength(m){switch((0,Y.k)(m)){case"Vector2":case"nS":case"Vector4":case"Quaternion":return m.length();default:throw new Error(`Cannot compute length of value ${m}`)}}}(0,O.e)("FlowGraphLengthBlock",B);class D extends b.b{constructor(m){super(M.b,M.b,(m=>this._polymorphicNormalize(m)),"FlowGraphNormalizeBlock",m)}_polymorphicNormalize(m){var S;let h;switch((0,Y.k)(m)){case"Vector2":case"nS":case"Vector4":case"Quaternion":if(h=m.normalizeToNew(),null!==(S=this.config)&&void 0!==S&&S.nanOnZeroLength){0===m.length()&&h.Zb(NaN)}return h;default:throw new Error(`Cannot normalize value ${m}`)}}}(0,O.e)("FlowGraphNormalizeBlock",D);class E extends u.c{constructor(m){super(M.b,M.b,M.p,((m,S)=>this._polymorphicDot(m,S)),"FlowGraphDotBlock",m)}_polymorphicDot(m,S){switch((0,Y.k)(m)){case"Vector2":case"nS":case"Vector4":case"Quaternion":return m.dot(S);default:throw new Error(`Cannot get dot product of ${m} and ${S}`)}}}(0,O.e)("FlowGraphDotBlock",E);class n extends u.c{constructor(m){super(M.y,M.y,M.y,((m,S)=>q.nS.Cross(m,S)),"FlowGraphCrossBlock",m)}}(0,O.e)("FlowGraphCrossBlock",n);class L extends u.c{constructor(m){super(M.x,M.p,M.x,((m,S)=>m.rotate(S)),"FlowGraphRotate2DBlock",m)}}(0,O.e)("FlowGraphRotate2DBlock",L);class U extends u.c{constructor(m){super(M.y,M.t,M.y,((m,S)=>m.applyRotationQuaternion(S)),"FlowGraphRotate3DBlock",m)}}function H(m,S){switch((0,Y.k)(m)){case"Vector2":case"nS":return S.transformVector(m);case"Vector4":return new q.Vector4(m.x*S.m[0]+m.y*S.m[1]+m.z*S.m[2]+m.w*S.m[3],m.x*S.m[4]+m.y*S.m[5]+m.z*S.m[6]+m.w*S.m[7],m.x*S.m[8]+m.y*S.m[9]+m.z*S.m[10]+m.w*S.m[11],m.x*S.m[12]+m.y*S.m[13]+m.z*S.m[14]+m.w*S.m[15]);default:throw new Error(`Cannot transform value ${m}`)}}(0,O.e)("FlowGraphRotate3DBlock",U);class R extends u.c{constructor(m){const S=(null===m||void 0===m?void 0:m.vectorType)||"nS",h="Vector2"===S?"Matrix2D":"nS"===S?"Matrix3D":"Matrix";super((0,M.J)(S),(0,M.J)(h),(0,M.J)(S),H,"FlowGraphTransformVectorBlock",m)}}(0,O.e)("FlowGraphTransformVectorBlock",R);class y extends u.c{constructor(m){super(M.y,M.j,M.y,((m,S)=>q.nS.TransformCoordinates(m,S)),"FlowGraphTransformCoordinatesBlock",m)}}(0,O.e)("FlowGraphTransformCoordinatesBlock",y);class o extends b.b{constructor(m){super(M.t,M.t,(m=>m.conjugate()),"FlowGraphConjugateBlock",m)}}(0,O.e)("FlowGraphConjugateBlock",o);class s extends u.c{constructor(m){super(M.t,M.t,M.p,((m,S)=>(0,V.d)(m,S)),"FlowGraphAngleBetweenBlock",m)}}(0,O.e)("FlowGraphAngleBetweenBlock",s);class v extends u.c{constructor(m){super(M.y,M.p,M.t,((m,S)=>q.Quaternion.RotationAxis(m,S)),"FlowGraphQuaternionFromAxisAngleBlock",m)}}(0,O.e)("FlowGraphQuaternionFromAxisAngleBlock",v);class T extends l.d{constructor(m){super(m),this.a=this.registerDataInput("a",M.t),this.axis=this.registerDataOutput("axis",M.y),this.angle=this.registerDataOutput("angle",M.p),this.isValid=this.registerDataOutput("isValid",M.e)}_updateOutputs(m){const S=m._getExecutionVariable(this,C,-1),h=m._getExecutionVariable(this,I,null),l=m._getExecutionVariable(this,Z,null);if(void 0!==h&&null!==h&&void 0!==l&&null!==l&&S===m.executionId)this.axis.setValue(h,m),this.angle.setValue(l,m);else try{const{axis:S,angle:h}=this.a.getValue(m).toAxisAngle();m._setExecutionVariable(this,I,S),m._setExecutionVariable(this,Z,h),m._setExecutionVariable(this,C,m.executionId),this.axis.setValue(S,m),this.angle.setValue(h,m),this.isValid.setValue(!0,m)}catch(M){this.isValid.setValue(!1,m)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,O.e)("FlowGraphAxisAngleFromQuaternionBlock",T);class X extends u.c{constructor(m){super(M.y,M.y,M.t,((m,S)=>(0,V.h)(m,S)),"FlowGraphQuaternionFromDirectionsBlock",m)}}},14618:(m,S,h)=>{h.d(S,{c:()=>M});var l=h(14620);class M extends l.d{constructor(m,S,h,l,M,O){super(h,O),this._operation=l,this._className=M,this.a=this.registerDataInput("a",m),this.b=this.registerDataInput("b",S)}_doOperation(m){const S=this.a.getValue(m),h=this.b.getValue(m);return this._operation(S,h)}getClassName(){return this._className}}},14620:(m,S,h)=>{h.d(S,{d:()=>b});var l=h(13074),M=h(13060);const O="cachedOperationValue",u="cachedExecutionId";class b extends l.d{constructor(m,S){super(S),this.value=this.registerDataOutput("value",m),this.isValid=this.registerDataOutput("isValid",M.e)}_updateOutputs(m){const S=m._getExecutionVariable(this,u,-1),h=m._getExecutionVariable(this,O,null);if(void 0!==h&&null!==h&&S===m.executionId)this.isValid.setValue(!0,m),this.value.setValue(h,m);else try{const S=this._doOperation(m);if(void 0===S||null===S)return void this.isValid.setValue(!1,m);m._setExecutionVariable(this,O,S),m._setExecutionVariable(this,u,m.executionId),this.value.setValue(S,m),this.isValid.setValue(!0,m)}catch(l){this.isValid.setValue(!1,m)}}}},14629:(m,S,h)=>{h.d(S,{b:()=>M});var l=h(14620);class M extends l.d{constructor(m,S,h,l,M){super(S,M),this._operation=h,this._className=l,this.a=this.registerDataInput("a",m)}_doOperation(m){return this._operation(this.a.getValue(m))}getClassName(){return this._className}}}}]);