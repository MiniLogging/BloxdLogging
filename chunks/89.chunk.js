"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[89],{15525:(y,c,A)=>{A.r(c),A.d(c,{FlowGraphAngleBetweenBlock:()=>my,FlowGraphAxisAngleFromQuaternionBlock:()=>z,FlowGraphConjugateBlock:()=>K,FlowGraphCrossBlock:()=>D,FlowGraphDotBlock:()=>P,FlowGraphLengthBlock:()=>i,FlowGraphNormalizeBlock:()=>H,FlowGraphQuaternionFromAxisAngleBlock:()=>T,FlowGraphQuaternionFromDirectionsBlock:()=>S,FlowGraphRotate2DBlock:()=>t,FlowGraphRotate3DBlock:()=>s,FlowGraphTransformBlock:()=>X,FlowGraphTransformCoordinatesBlock:()=>C});var l=A(14010),w=A(13993),N=A(12283),p=A(15500),W=A(15516),h=A(12325),I=A(14021),q=A(13661);const o="cachedOperationAxis",O="cachedOperationAngle",L="cachedExecutionId";class i extends W.b{constructor(y){super(w.e,w.s,(y=>this._polymorphicLength(y)),"FlowGraphLengthBlock",y)}_polymorphicLength(y){switch((0,I.g)(y)){case"Vector2":case"gc":case"Vector4":case"Quaternion":return y.length();default:throw new Error(`Cannot compute length of value ${y}`)}}}(0,N.f)("FlowGraphLengthBlock",i);class H extends W.b{constructor(y){super(w.e,w.e,(y=>this._polymorphicNormalize(y)),"FlowGraphNormalizeBlock",y)}_polymorphicNormalize(y){var c;let A;switch((0,I.g)(y)){case"Vector2":case"gc":case"Vector4":case"Quaternion":if(A=y.normalizeToNew(),null!==(c=this.config)&&void 0!==c&&c.nanOnZeroLength){0===y.length()&&A.vc(NaN)}return A;default:throw new Error(`Cannot normalize value ${y}`)}}}(0,N.f)("FlowGraphNormalizeBlock",H);class P extends p.c{constructor(y){super(w.e,w.e,w.s,((y,c)=>this._polymorphicDot(y,c)),"FlowGraphDotBlock",y)}_polymorphicDot(y,c){switch((0,I.g)(y)){case"Vector2":case"gc":case"Vector4":case"Quaternion":return y.dot(c);default:throw new Error(`Cannot get dot product of ${y} and ${c}`)}}}(0,N.f)("FlowGraphDotBlock",P);class D extends p.c{constructor(y){super(w.H,w.H,w.H,((y,c)=>h.gc.Cross(y,c)),"FlowGraphCrossBlock",y)}}(0,N.f)("FlowGraphCrossBlock",D);class t extends p.c{constructor(y){super(w.E,w.s,w.E,((y,c)=>y.rotate(c)),"FlowGraphRotate2DBlock",y)}}(0,N.f)("FlowGraphRotate2DBlock",t);class s extends p.c{constructor(y){super(w.H,w.w,w.H,((y,c)=>y.applyRotationQuaternion(c)),"FlowGraphRotate3DBlock",y)}}function B(y,c){switch((0,I.g)(y)){case"Vector2":case"gc":return c.transformVector(y);case"Vector4":return new h.Vector4(y.x*c.m[0]+y.y*c.m[1]+y.z*c.m[2]+y.w*c.m[3],y.x*c.m[4]+y.y*c.m[5]+y.z*c.m[6]+y.w*c.m[7],y.x*c.m[8]+y.y*c.m[9]+y.z*c.m[10]+y.w*c.m[11],y.x*c.m[12]+y.y*c.m[13]+y.z*c.m[14]+y.w*c.m[15]);default:throw new Error(`Cannot transform value ${y}`)}}(0,N.f)("FlowGraphRotate3DBlock",s);class X extends p.c{constructor(y){const c=(null===y||void 0===y?void 0:y.vectorType)||"gc",A="Vector2"===c?"Matrix2D":"gc"===c?"Matrix3D":"Matrix";super((0,w.S)(c),(0,w.S)(A),(0,w.S)(c),B,"FlowGraphTransformVectorBlock",y)}}(0,N.f)("FlowGraphTransformVectorBlock",X);class C extends p.c{constructor(y){super(w.H,w.m,w.H,((y,c)=>h.gc.TransformCoordinates(y,c)),"FlowGraphTransformCoordinatesBlock",y)}}(0,N.f)("FlowGraphTransformCoordinatesBlock",C);class K extends W.b{constructor(y){super(w.w,w.w,(y=>y.conjugate()),"FlowGraphConjugateBlock",y)}}(0,N.f)("FlowGraphConjugateBlock",K);class my extends p.c{constructor(y){super(w.w,w.w,w.s,((y,c)=>(0,q.d)(y,c)),"FlowGraphAngleBetweenBlock",y)}}(0,N.f)("FlowGraphAngleBetweenBlock",my);class T extends p.c{constructor(y){super(w.H,w.s,w.w,((y,c)=>h.Quaternion.RotationAxis(y,c)),"FlowGraphQuaternionFromAxisAngleBlock",y)}}(0,N.f)("FlowGraphQuaternionFromAxisAngleBlock",T);class z extends l.e{constructor(y){super(y),this.a=this.registerDataInput("a",w.w),this.axis=this.registerDataOutput("axis",w.H),this.angle=this.registerDataOutput("angle",w.s),this.isValid=this.registerDataOutput("isValid",w.f)}_updateOutputs(y){const c=y._getExecutionVariable(this,L,-1),A=y._getExecutionVariable(this,o,null),l=y._getExecutionVariable(this,O,null);if(void 0!==A&&null!==A&&void 0!==l&&null!==l&&c===y.executionId)this.axis.setValue(A,y),this.angle.setValue(l,y);else try{const{axis:c,angle:A}=this.a.getValue(y).toAxisAngle();y._setExecutionVariable(this,o,c),y._setExecutionVariable(this,O,A),y._setExecutionVariable(this,L,y.executionId),this.axis.setValue(c,y),this.angle.setValue(A,y),this.isValid.setValue(!0,y)}catch(w){this.isValid.setValue(!1,y)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,N.f)("FlowGraphAxisAngleFromQuaternionBlock",z);class S extends p.c{constructor(y){super(w.H,w.H,w.w,((y,c)=>(0,q.h)(y,c)),"FlowGraphQuaternionFromDirectionsBlock",y)}}},15500:(y,c,A)=>{A.d(c,{c:()=>w});var l=A(15507);class w extends l.d{constructor(y,c,A,l,w,N){super(A,N),this._operation=l,this._className=w,this.a=this.registerDataInput("a",y),this.b=this.registerDataInput("b",c)}_doOperation(y){const c=this.a.getValue(y),A=this.b.getValue(y);return this._operation(c,A)}getClassName(){return this._className}}},15507:(y,c,A)=>{A.d(c,{d:()=>W});var l=A(14010),w=A(13993);const N="cachedOperationValue",p="cachedExecutionId";class W extends l.e{constructor(y,c){super(c),this.value=this.registerDataOutput("value",y),this.isValid=this.registerDataOutput("isValid",w.f)}_updateOutputs(y){const c=y._getExecutionVariable(this,p,-1),A=y._getExecutionVariable(this,N,null);if(void 0!==A&&null!==A&&c===y.executionId)this.isValid.setValue(!0,y),this.value.setValue(A,y);else try{const c=this._doOperation(y);if(void 0===c||null===c)return void this.isValid.setValue(!1,y);y._setExecutionVariable(this,N,c),y._setExecutionVariable(this,p,y.executionId),this.value.setValue(c,y),this.isValid.setValue(!0,y)}catch(l){this.isValid.setValue(!1,y)}}}},15516:(y,c,A)=>{A.d(c,{b:()=>w});var l=A(15507);class w extends l.d{constructor(y,c,A,l,w){super(c,w),this._operation=A,this._className=l,this.a=this.registerDataInput("a",y)}_doOperation(y){return this._operation(this.a.getValue(y))}getClassName(){return this._className}}}}]);