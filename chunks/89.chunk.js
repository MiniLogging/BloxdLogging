"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[89],{14855:(F,P,f)=>{f.r(P),f.d(P,{FlowGraphAngleBetweenBlock:()=>d,FlowGraphAxisAngleFromQuaternionBlock:()=>V,FlowGraphConjugateBlock:()=>O,FlowGraphCrossBlock:()=>J,FlowGraphDotBlock:()=>L,FlowGraphLengthBlock:()=>t,FlowGraphNormalizeBlock:()=>C,FlowGraphQuaternionFromAxisAngleBlock:()=>M,FlowGraphQuaternionFromDirectionsBlock:()=>Q,FlowGraphRotate2DBlock:()=>B,FlowGraphRotate3DBlock:()=>z,FlowGraphTransformBlock:()=>R,FlowGraphTransformCoordinatesBlock:()=>y});var c=f(13287),N=f(13265),q=f(11587),H=f(14841),A=f(14848),o=f(11639),j=f(13296),i=f(12978);const u="cachedOperationAxis",T="cachedOperationAngle",Y="cachedExecutionId";class t extends A.e{constructor(F){super(N.c,N.o,(F=>this._polymorphicLength(F)),"FlowGraphLengthBlock",F)}_polymorphicLength(F){switch((0,j.i)(F)){case"Vector2":case"tP":case"Vector4":case"Quaternion":return F.length();default:throw new Error(`Cannot compute length of value ${F}`)}}}(0,q.f)("FlowGraphLengthBlock",t);class C extends A.e{constructor(F){super(N.c,N.c,(F=>this._polymorphicNormalize(F)),"FlowGraphNormalizeBlock",F)}_polymorphicNormalize(F){var P;let f;switch((0,j.i)(F)){case"Vector2":case"tP":case"Vector4":case"Quaternion":if(f=F.normalizeToNew(),null!==(P=this.config)&&void 0!==P&&P.nanOnZeroLength){0===F.length()&&f.Nc(NaN)}return f;default:throw new Error(`Cannot normalize value ${F}`)}}}(0,q.f)("FlowGraphNormalizeBlock",C);class L extends H.d{constructor(F){super(N.c,N.c,N.o,((F,P)=>this._polymorphicDot(F,P)),"FlowGraphDotBlock",F)}_polymorphicDot(F,P){switch((0,j.i)(F)){case"Vector2":case"tP":case"Vector4":case"Quaternion":return F.dot(P);default:throw new Error(`Cannot get dot product of ${F} and ${P}`)}}}(0,q.f)("FlowGraphDotBlock",L);class J extends H.d{constructor(F){super(N.w,N.w,N.w,((F,P)=>o.tP.Cross(F,P)),"FlowGraphCrossBlock",F)}}(0,q.f)("FlowGraphCrossBlock",J);class B extends H.d{constructor(F){super(N.v,N.o,N.v,((F,P)=>F.rotate(P)),"FlowGraphRotate2DBlock",F)}}(0,q.f)("FlowGraphRotate2DBlock",B);class z extends H.d{constructor(F){super(N.w,N.p,N.w,((F,P)=>F.applyRotationQuaternion(P)),"FlowGraphRotate3DBlock",F)}}function Z(F,P){switch((0,j.i)(F)){case"Vector2":case"tP":return P.transformVector(F);case"Vector4":return new o.Vector4(F.x*P.m[0]+F.y*P.m[1]+F.z*P.m[2]+F.w*P.m[3],F.x*P.m[4]+F.y*P.m[5]+F.z*P.m[6]+F.w*P.m[7],F.x*P.m[8]+F.y*P.m[9]+F.z*P.m[10]+F.w*P.m[11],F.x*P.m[12]+F.y*P.m[13]+F.z*P.m[14]+F.w*P.m[15]);default:throw new Error(`Cannot transform value ${F}`)}}(0,q.f)("FlowGraphRotate3DBlock",z);class R extends H.d{constructor(F){const P=(null===F||void 0===F?void 0:F.vectorType)||"tP",f="Vector2"===P?"Matrix2D":"tP"===P?"Matrix3D":"Matrix";super((0,N.F)(P),(0,N.F)(f),(0,N.F)(P),Z,"FlowGraphTransformVectorBlock",F)}}(0,q.f)("FlowGraphTransformVectorBlock",R);class y extends H.d{constructor(F){super(N.w,N.j,N.w,((F,P)=>o.tP.TransformCoordinates(F,P)),"FlowGraphTransformCoordinatesBlock",F)}}(0,q.f)("FlowGraphTransformCoordinatesBlock",y);class O extends A.e{constructor(F){super(N.p,N.p,(F=>F.conjugate()),"FlowGraphConjugateBlock",F)}}(0,q.f)("FlowGraphConjugateBlock",O);class d extends H.d{constructor(F){super(N.p,N.p,N.o,((F,P)=>(0,i.e)(F,P)),"FlowGraphAngleBetweenBlock",F)}}(0,q.f)("FlowGraphAngleBetweenBlock",d);class M extends H.d{constructor(F){super(N.w,N.o,N.p,((F,P)=>o.Quaternion.RotationAxis(F,P)),"FlowGraphQuaternionFromAxisAngleBlock",F)}}(0,q.f)("FlowGraphQuaternionFromAxisAngleBlock",M);class V extends c.c{constructor(F){super(F),this.a=this.registerDataInput("a",N.p),this.axis=this.registerDataOutput("axis",N.w),this.angle=this.registerDataOutput("angle",N.o),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(F){const P=F._getExecutionVariable(this,Y,-1),f=F._getExecutionVariable(this,u,null),c=F._getExecutionVariable(this,T,null);if(void 0!==f&&null!==f&&void 0!==c&&null!==c&&P===F.executionId)this.axis.setValue(f,F),this.angle.setValue(c,F);else try{const{axis:P,angle:f}=this.a.getValue(F).toAxisAngle();F._setExecutionVariable(this,u,P),F._setExecutionVariable(this,T,f),F._setExecutionVariable(this,Y,F.executionId),this.axis.setValue(P,F),this.angle.setValue(f,F),this.isValid.setValue(!0,F)}catch(N){this.isValid.setValue(!1,F)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,q.f)("FlowGraphAxisAngleFromQuaternionBlock",V);class Q extends H.d{constructor(F){super(N.w,N.w,N.p,((F,P)=>(0,i.f)(F,P)),"FlowGraphQuaternionFromDirectionsBlock",F)}}},14841:(F,P,f)=>{f.d(P,{d:()=>N});var c=f(14843);class N extends c.c{constructor(F,P,f,c,N,q){super(f,q),this._operation=c,this._className=N,this.a=this.registerDataInput("a",F),this.b=this.registerDataInput("b",P)}_doOperation(F){const P=this.a.getValue(F),f=this.b.getValue(F);return this._operation(P,f)}getClassName(){return this._className}}},14843:(F,P,f)=>{f.d(P,{c:()=>A});var c=f(13287),N=f(13265);const q="cachedOperationValue",H="cachedExecutionId";class A extends c.c{constructor(F,P){super(P),this.value=this.registerDataOutput("value",F),this.isValid=this.registerDataOutput("isValid",N.g)}_updateOutputs(F){const P=F._getExecutionVariable(this,H,-1),f=F._getExecutionVariable(this,q,null);if(void 0!==f&&null!==f&&P===F.executionId)this.isValid.setValue(!0,F),this.value.setValue(f,F);else try{const P=this._doOperation(F);if(void 0===P||null===P)return void this.isValid.setValue(!1,F);F._setExecutionVariable(this,q,P),F._setExecutionVariable(this,H,F.executionId),this.value.setValue(P,F),this.isValid.setValue(!0,F)}catch(c){this.isValid.setValue(!1,F)}}}},14848:(F,P,f)=>{f.d(P,{e:()=>N});var c=f(14843);class N extends c.c{constructor(F,P,f,c,N){super(P,N),this._operation=f,this._className=c,this.a=this.registerDataInput("a",F)}_doOperation(F){return this._operation(this.a.getValue(F))}getClassName(){return this._className}}}}]);