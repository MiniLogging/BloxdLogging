"use strict";(self.u4k1rqylno=self.u4k1rqylno||[]).push([[89],{14906:(e,E,H)=>{H.r(E),H.d(E,{FlowGraphAngleBetweenBlock:()=>w,FlowGraphAxisAngleFromQuaternionBlock:()=>p,FlowGraphConjugateBlock:()=>f,FlowGraphCrossBlock:()=>S,FlowGraphDotBlock:()=>h,FlowGraphLengthBlock:()=>j,FlowGraphNormalizeBlock:()=>F,FlowGraphQuaternionFromAxisAngleBlock:()=>s,FlowGraphQuaternionFromDirectionsBlock:()=>o,FlowGraphRotate2DBlock:()=>X,FlowGraphRotate3DBlock:()=>a,FlowGraphTransformBlock:()=>r,FlowGraphTransformCoordinatesBlock:()=>Y});var N=H(13441),u=H(13415),z=H(11690),P=H(14889),M=H(14898),D=H(11738),A=H(13457),C=H(13117);const i="cachedOperationAxis",V="cachedOperationAngle",U="cachedExecutionId";class j extends M.b{constructor(e){super(u.b,u.t,(e=>this._polymorphicLength(e)),"FlowGraphLengthBlock",e)}_polymorphicLength(e){switch((0,A.l)(e)){case"Vector2":case"jE":case"Vector4":case"Quaternion":return e.length();default:throw new Error(`Cannot compute length of value ${e}`)}}}(0,z.g)("FlowGraphLengthBlock",j);class F extends M.b{constructor(e){super(u.b,u.b,(e=>this._polymorphicNormalize(e)),"FlowGraphNormalizeBlock",e)}_polymorphicNormalize(e){var E;let H;switch((0,A.l)(e)){case"Vector2":case"jE":case"Vector4":case"Quaternion":if(H=e.normalizeToNew(),null!==(E=this.config)&&void 0!==E&&E.nanOnZeroLength){0===e.length()&&H.jM(NaN)}return H;default:throw new Error(`Cannot normalize value ${e}`)}}}(0,z.g)("FlowGraphNormalizeBlock",F);class h extends P.b{constructor(e){super(u.b,u.b,u.t,((e,E)=>this._polymorphicDot(e,E)),"FlowGraphDotBlock",e)}_polymorphicDot(e,E){switch((0,A.l)(e)){case"Vector2":case"jE":case"Vector4":case"Quaternion":return e.dot(E);default:throw new Error(`Cannot get dot product of ${e} and ${E}`)}}}(0,z.g)("FlowGraphDotBlock",h);class S extends P.b{constructor(e){super(u.E,u.E,u.E,((e,E)=>D.jE.Cross(e,E)),"FlowGraphCrossBlock",e)}}(0,z.g)("FlowGraphCrossBlock",S);class X extends P.b{constructor(e){super(u.D,u.t,u.D,((e,E)=>e.rotate(E)),"FlowGraphRotate2DBlock",e)}}(0,z.g)("FlowGraphRotate2DBlock",X);class a extends P.b{constructor(e){super(u.E,u.x,u.E,((e,E)=>e.applyRotationQuaternion(E)),"FlowGraphRotate3DBlock",e)}}function W(e,E){switch((0,A.l)(e)){case"Vector2":case"jE":return E.transformVector(e);case"Vector4":return new D.Vector4(e.x*E.m[0]+e.y*E.m[1]+e.z*E.m[2]+e.w*E.m[3],e.x*E.m[4]+e.y*E.m[5]+e.z*E.m[6]+e.w*E.m[7],e.x*E.m[8]+e.y*E.m[9]+e.z*E.m[10]+e.w*E.m[11],e.x*E.m[12]+e.y*E.m[13]+e.z*E.m[14]+e.w*E.m[15]);default:throw new Error(`Cannot transform value ${e}`)}}(0,z.g)("FlowGraphRotate3DBlock",a);class r extends P.b{constructor(e){const E=(null===e||void 0===e?void 0:e.vectorType)||"jE",H="Vector2"===E?"Matrix2D":"jE"===E?"Matrix3D":"Matrix";super((0,u.N)(E),(0,u.N)(H),(0,u.N)(E),W,"FlowGraphTransformVectorBlock",e)}}(0,z.g)("FlowGraphTransformVectorBlock",r);class Y extends P.b{constructor(e){super(u.E,u.l,u.E,((e,E)=>D.jE.TransformCoordinates(e,E)),"FlowGraphTransformCoordinatesBlock",e)}}(0,z.g)("FlowGraphTransformCoordinatesBlock",Y);class f extends M.b{constructor(e){super(u.x,u.x,(e=>e.conjugate()),"FlowGraphConjugateBlock",e)}}(0,z.g)("FlowGraphConjugateBlock",f);class w extends P.b{constructor(e){super(u.x,u.x,u.t,((e,E)=>(0,C.d)(e,E)),"FlowGraphAngleBetweenBlock",e)}}(0,z.g)("FlowGraphAngleBetweenBlock",w);class s extends P.b{constructor(e){super(u.E,u.t,u.x,((e,E)=>D.Quaternion.RotationAxis(e,E)),"FlowGraphQuaternionFromAxisAngleBlock",e)}}(0,z.g)("FlowGraphQuaternionFromAxisAngleBlock",s);class p extends N.b{constructor(e){super(e),this.a=this.registerDataInput("a",u.x),this.axis=this.registerDataOutput("axis",u.E),this.angle=this.registerDataOutput("angle",u.t),this.isValid=this.registerDataOutput("isValid",u.f)}_updateOutputs(e){const E=e._getExecutionVariable(this,U,-1),H=e._getExecutionVariable(this,i,null),N=e._getExecutionVariable(this,V,null);if(void 0!==H&&null!==H&&void 0!==N&&null!==N&&E===e.executionId)this.axis.setValue(H,e),this.angle.setValue(N,e);else try{const{axis:E,angle:H}=this.a.getValue(e).toAxisAngle();e._setExecutionVariable(this,i,E),e._setExecutionVariable(this,V,H),e._setExecutionVariable(this,U,e.executionId),this.axis.setValue(E,e),this.angle.setValue(H,e),this.isValid.setValue(!0,e)}catch(u){this.isValid.setValue(!1,e)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,z.g)("FlowGraphAxisAngleFromQuaternionBlock",p);class o extends P.b{constructor(e){super(u.E,u.E,u.x,((e,E)=>(0,C.e)(e,E)),"FlowGraphQuaternionFromDirectionsBlock",e)}}},14889:(e,E,H)=>{H.d(E,{b:()=>u});var N=H(14894);class u extends N.c{constructor(e,E,H,N,u,z){super(H,z),this._operation=N,this._className=u,this.a=this.registerDataInput("a",e),this.b=this.registerDataInput("b",E)}_doOperation(e){const E=this.a.getValue(e),H=this.b.getValue(e);return this._operation(E,H)}getClassName(){return this._className}}},14894:(e,E,H)=>{H.d(E,{c:()=>M});var N=H(13441),u=H(13415);const z="cachedOperationValue",P="cachedExecutionId";class M extends N.b{constructor(e,E){super(E),this.value=this.registerDataOutput("value",e),this.isValid=this.registerDataOutput("isValid",u.f)}_updateOutputs(e){const E=e._getExecutionVariable(this,P,-1),H=e._getExecutionVariable(this,z,null);if(void 0!==H&&null!==H&&E===e.executionId)this.isValid.setValue(!0,e),this.value.setValue(H,e);else try{const E=this._doOperation(e);if(void 0===E||null===E)return void this.isValid.setValue(!1,e);e._setExecutionVariable(this,z,E),e._setExecutionVariable(this,P,e.executionId),this.value.setValue(E,e),this.isValid.setValue(!0,e)}catch(N){this.isValid.setValue(!1,e)}}}},14898:(e,E,H)=>{H.d(E,{b:()=>u});var N=H(14894);class u extends N.c{constructor(e,E,H,N,u){super(E,u),this._operation=H,this._className=N,this.a=this.registerDataInput("a",e)}_doOperation(e){return this._operation(this.a.getValue(e))}getClassName(){return this._className}}}}]);