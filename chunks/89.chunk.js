"use strict";(self.n4ygn1cq9vg=self.n4ygn1cq9vg||[]).push([[89],{15681:(e,d,v)=>{v.r(d),v.d(d,{FlowGraphAngleBetweenBlock:()=>x,FlowGraphAxisAngleFromQuaternionBlock:()=>me,FlowGraphConjugateBlock:()=>A,FlowGraphCrossBlock:()=>D,FlowGraphDotBlock:()=>U,FlowGraphLengthBlock:()=>w,FlowGraphNormalizeBlock:()=>G,FlowGraphQuaternionFromAxisAngleBlock:()=>i,FlowGraphQuaternionFromDirectionsBlock:()=>r,FlowGraphRotate2DBlock:()=>C,FlowGraphRotate3DBlock:()=>q,FlowGraphTransformBlock:()=>l,FlowGraphTransformCoordinatesBlock:()=>n});var P=v(14195),p=v(14181),L=v(12381),B=v(15661),X=v(15678),z=v(12420),W=v(14208),V=v(13870);const k="cachedOperationAxis",g="cachedOperationAngle",F="cachedExecutionId";class w extends X.d{constructor(e){super(p.b,p.n,(e=>this._polymorphicLength(e)),"FlowGraphLengthBlock",e)}_polymorphicLength(e){switch((0,W.h)(e)){case"Vector2":case"mv":case"Vector4":case"Quaternion":return e.length();default:throw new Error(`Cannot compute length of value ${e}`)}}}(0,L.h)("FlowGraphLengthBlock",w);class G extends X.d{constructor(e){super(p.b,p.b,(e=>this._polymorphicNormalize(e)),"FlowGraphNormalizeBlock",e)}_polymorphicNormalize(e){var d;let v;switch((0,W.h)(e)){case"Vector2":case"mv":case"Vector4":case"Quaternion":if(v=e.normalizeToNew(),null!==(d=this.config)&&void 0!==d&&d.nanOnZeroLength){0===e.length()&&v.dp(NaN)}return v;default:throw new Error(`Cannot normalize value ${e}`)}}}(0,L.h)("FlowGraphNormalizeBlock",G);class U extends B.e{constructor(e){super(p.b,p.b,p.n,((e,d)=>this._polymorphicDot(e,d)),"FlowGraphDotBlock",e)}_polymorphicDot(e,d){switch((0,W.h)(e)){case"Vector2":case"mv":case"Vector4":case"Quaternion":return e.dot(d);default:throw new Error(`Cannot get dot product of ${e} and ${d}`)}}}(0,L.h)("FlowGraphDotBlock",U);class D extends B.e{constructor(e){super(p.x,p.x,p.x,((e,d)=>z.mv.Cross(e,d)),"FlowGraphCrossBlock",e)}}(0,L.h)("FlowGraphCrossBlock",D);class C extends B.e{constructor(e){super(p.t,p.n,p.t,((e,d)=>e.rotate(d)),"FlowGraphRotate2DBlock",e)}}(0,L.h)("FlowGraphRotate2DBlock",C);class q extends B.e{constructor(e){super(p.x,p.p,p.x,((e,d)=>e.applyRotationQuaternion(d)),"FlowGraphRotate3DBlock",e)}}function h(e,d){switch((0,W.h)(e)){case"Vector2":case"mv":return d.transformVector(e);case"Vector4":return new z.Vector4(e.x*d.m[0]+e.y*d.m[1]+e.z*d.m[2]+e.w*d.m[3],e.x*d.m[4]+e.y*d.m[5]+e.z*d.m[6]+e.w*d.m[7],e.x*d.m[8]+e.y*d.m[9]+e.z*d.m[10]+e.w*d.m[11],e.x*d.m[12]+e.y*d.m[13]+e.z*d.m[14]+e.w*d.m[15]);default:throw new Error(`Cannot transform value ${e}`)}}(0,L.h)("FlowGraphRotate3DBlock",q);class l extends B.e{constructor(e){const d=(null===e||void 0===e?void 0:e.vectorType)||"mv",v="Vector2"===d?"Matrix2D":"mv"===d?"Matrix3D":"Matrix";super((0,p.F)(d),(0,p.F)(v),(0,p.F)(d),h,"FlowGraphTransformVectorBlock",e)}}(0,L.h)("FlowGraphTransformVectorBlock",l);class n extends B.e{constructor(e){super(p.x,p.g,p.x,((e,d)=>z.mv.TransformCoordinates(e,d)),"FlowGraphTransformCoordinatesBlock",e)}}(0,L.h)("FlowGraphTransformCoordinatesBlock",n);class A extends X.d{constructor(e){super(p.p,p.p,(e=>e.conjugate()),"FlowGraphConjugateBlock",e)}}(0,L.h)("FlowGraphConjugateBlock",A);class x extends B.e{constructor(e){super(p.p,p.p,p.n,((e,d)=>(0,V.d)(e,d)),"FlowGraphAngleBetweenBlock",e)}}(0,L.h)("FlowGraphAngleBetweenBlock",x);class i extends B.e{constructor(e){super(p.x,p.n,p.p,((e,d)=>z.Quaternion.RotationAxis(e,d)),"FlowGraphQuaternionFromAxisAngleBlock",e)}}(0,L.h)("FlowGraphQuaternionFromAxisAngleBlock",i);class me extends P.e{constructor(e){super(e),this.a=this.registerDataInput("a",p.p),this.axis=this.registerDataOutput("axis",p.x),this.angle=this.registerDataOutput("angle",p.n),this.isValid=this.registerDataOutput("isValid",p.d)}_updateOutputs(e){const d=e._getExecutionVariable(this,F,-1),v=e._getExecutionVariable(this,k,null),P=e._getExecutionVariable(this,g,null);if(void 0!==v&&null!==v&&void 0!==P&&null!==P&&d===e.executionId)this.axis.setValue(v,e),this.angle.setValue(P,e);else try{const{axis:d,angle:v}=this.a.getValue(e).toAxisAngle();e._setExecutionVariable(this,k,d),e._setExecutionVariable(this,g,v),e._setExecutionVariable(this,F,e.executionId),this.axis.setValue(d,e),this.angle.setValue(v,e),this.isValid.setValue(!0,e)}catch(p){this.isValid.setValue(!1,e)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,L.h)("FlowGraphAxisAngleFromQuaternionBlock",me);class r extends B.e{constructor(e){super(p.x,p.x,p.p,((e,d)=>(0,V.f)(e,d)),"FlowGraphQuaternionFromDirectionsBlock",e)}}},15661:(e,d,v)=>{v.d(d,{e:()=>p});var P=v(15670);class p extends P.c{constructor(e,d,v,P,p,L){super(v,L),this._operation=P,this._className=p,this.a=this.registerDataInput("a",e),this.b=this.registerDataInput("b",d)}_doOperation(e){const d=this.a.getValue(e),v=this.b.getValue(e);return this._operation(d,v)}getClassName(){return this._className}}},15670:(e,d,v)=>{v.d(d,{c:()=>X});var P=v(14195),p=v(14181);const L="cachedOperationValue",B="cachedExecutionId";class X extends P.e{constructor(e,d){super(d),this.value=this.registerDataOutput("value",e),this.isValid=this.registerDataOutput("isValid",p.d)}_updateOutputs(e){const d=e._getExecutionVariable(this,B,-1),v=e._getExecutionVariable(this,L,null);if(void 0!==v&&null!==v&&d===e.executionId)this.isValid.setValue(!0,e),this.value.setValue(v,e);else try{const d=this._doOperation(e);if(void 0===d||null===d)return void this.isValid.setValue(!1,e);e._setExecutionVariable(this,L,d),e._setExecutionVariable(this,B,e.executionId),this.value.setValue(d,e),this.isValid.setValue(!0,e)}catch(P){this.isValid.setValue(!1,e)}}}},15678:(e,d,v)=>{v.d(d,{d:()=>p});var P=v(15670);class p extends P.c{constructor(e,d,v,P,p){super(d,p),this._operation=v,this._className=P,this.a=this.registerDataInput("a",e)}_doOperation(e){return this._operation(this.a.getValue(e))}getClassName(){return this._className}}}}]);