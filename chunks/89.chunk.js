"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[89],{15604:(E,U,g)=>{g.r(U),g.d(U,{FlowGraphAngleBetweenBlock:()=>G,FlowGraphAxisAngleFromQuaternionBlock:()=>T,FlowGraphConjugateBlock:()=>t,FlowGraphCrossBlock:()=>h,FlowGraphDotBlock:()=>y,FlowGraphLengthBlock:()=>d,FlowGraphNormalizeBlock:()=>I,FlowGraphQuaternionFromAxisAngleBlock:()=>b,FlowGraphQuaternionFromDirectionsBlock:()=>v,FlowGraphRotate2DBlock:()=>V,FlowGraphRotate3DBlock:()=>e,FlowGraphTransformBlock:()=>l,FlowGraphTransformCoordinatesBlock:()=>Y});var N=g(14077),L=g(14058),D=g(12292),S=g(15587),u=g(15598),s=g(12334),C=g(14084),B=g(13722);const P="cachedOperationAxis",F="cachedOperationAngle",f="cachedExecutionId";class d extends u.d{constructor(E){super(L.e,L.t,(E=>this._polymorphicLength(E)),"FlowGraphLengthBlock",E)}_polymorphicLength(E){switch((0,C.p)(E)){case"Vector2":case"dU":case"Vector4":case"Quaternion":return E.length();default:throw new Error(`Cannot compute length of value ${E}`)}}}(0,D.f)("FlowGraphLengthBlock",d);class I extends u.d{constructor(E){super(L.e,L.e,(E=>this._polymorphicNormalize(E)),"FlowGraphNormalizeBlock",E)}_polymorphicNormalize(E){var U;let g;switch((0,C.p)(E)){case"Vector2":case"dU":case"Vector4":case"Quaternion":if(g=E.normalizeToNew(),null!==(U=this.config)&&void 0!==U&&U.nanOnZeroLength){0===E.length()&&g.yu(NaN)}return g;default:throw new Error(`Cannot normalize value ${E}`)}}}(0,D.f)("FlowGraphNormalizeBlock",I);class y extends S.b{constructor(E){super(L.e,L.e,L.t,((E,U)=>this._polymorphicDot(E,U)),"FlowGraphDotBlock",E)}_polymorphicDot(E,U){switch((0,C.p)(E)){case"Vector2":case"dU":case"Vector4":case"Quaternion":return E.dot(U);default:throw new Error(`Cannot get dot product of ${E} and ${U}`)}}}(0,D.f)("FlowGraphDotBlock",y);class h extends S.b{constructor(E){super(L.D,L.D,L.D,((E,U)=>s.dU.Cross(E,U)),"FlowGraphCrossBlock",E)}}(0,D.f)("FlowGraphCrossBlock",h);class V extends S.b{constructor(E){super(L.C,L.t,L.C,((E,U)=>E.rotate(U)),"FlowGraphRotate2DBlock",E)}}(0,D.f)("FlowGraphRotate2DBlock",V);class e extends S.b{constructor(E){super(L.D,L.w,L.D,((E,U)=>E.applyRotationQuaternion(U)),"FlowGraphRotate3DBlock",E)}}function x(E,U){switch((0,C.p)(E)){case"Vector2":case"dU":return U.transformVector(E);case"Vector4":return new s.Vector4(E.x*U.m[0]+E.y*U.m[1]+E.z*U.m[2]+E.w*U.m[3],E.x*U.m[4]+E.y*U.m[5]+E.z*U.m[6]+E.w*U.m[7],E.x*U.m[8]+E.y*U.m[9]+E.z*U.m[10]+E.w*U.m[11],E.x*U.m[12]+E.y*U.m[13]+E.z*U.m[14]+E.w*U.m[15]);default:throw new Error(`Cannot transform value ${E}`)}}(0,D.f)("FlowGraphRotate3DBlock",e);class l extends S.b{constructor(E){const U=(null===E||void 0===E?void 0:E.vectorType)||"dU",g="Vector2"===U?"Matrix2D":"dU"===U?"Matrix3D":"Matrix";super((0,L.L)(U),(0,L.L)(g),(0,L.L)(U),x,"FlowGraphTransformVectorBlock",E)}}(0,D.f)("FlowGraphTransformVectorBlock",l);class Y extends S.b{constructor(E){super(L.D,L.k,L.D,((E,U)=>s.dU.TransformCoordinates(E,U)),"FlowGraphTransformCoordinatesBlock",E)}}(0,D.f)("FlowGraphTransformCoordinatesBlock",Y);class t extends u.d{constructor(E){super(L.w,L.w,(E=>E.conjugate()),"FlowGraphConjugateBlock",E)}}(0,D.f)("FlowGraphConjugateBlock",t);class G extends S.b{constructor(E){super(L.w,L.w,L.t,((E,U)=>(0,B.c)(E,U)),"FlowGraphAngleBetweenBlock",E)}}(0,D.f)("FlowGraphAngleBetweenBlock",G);class b extends S.b{constructor(E){super(L.D,L.t,L.w,((E,U)=>s.Quaternion.RotationAxis(E,U)),"FlowGraphQuaternionFromAxisAngleBlock",E)}}(0,D.f)("FlowGraphQuaternionFromAxisAngleBlock",b);class T extends N.b{constructor(E){super(E),this.a=this.registerDataInput("a",L.w),this.axis=this.registerDataOutput("axis",L.D),this.angle=this.registerDataOutput("angle",L.t),this.isValid=this.registerDataOutput("isValid",L.g)}_updateOutputs(E){const U=E._getExecutionVariable(this,f,-1),g=E._getExecutionVariable(this,P,null),N=E._getExecutionVariable(this,F,null);if(void 0!==g&&null!==g&&void 0!==N&&null!==N&&U===E.executionId)this.axis.setValue(g,E),this.angle.setValue(N,E);else try{const{axis:U,angle:g}=this.a.getValue(E).toAxisAngle();E._setExecutionVariable(this,P,U),E._setExecutionVariable(this,F,g),E._setExecutionVariable(this,f,E.executionId),this.axis.setValue(U,E),this.angle.setValue(g,E),this.isValid.setValue(!0,E)}catch(L){this.isValid.setValue(!1,E)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,D.f)("FlowGraphAxisAngleFromQuaternionBlock",T);class v extends S.b{constructor(E){super(L.D,L.D,L.w,((E,U)=>(0,B.d)(E,U)),"FlowGraphQuaternionFromDirectionsBlock",E)}}},15587:(E,U,g)=>{g.d(U,{b:()=>L});var N=g(15596);class L extends N.b{constructor(E,U,g,N,L,D){super(g,D),this._operation=N,this._className=L,this.a=this.registerDataInput("a",E),this.b=this.registerDataInput("b",U)}_doOperation(E){const U=this.a.getValue(E),g=this.b.getValue(E);return this._operation(U,g)}getClassName(){return this._className}}},15596:(E,U,g)=>{g.d(U,{b:()=>u});var N=g(14077),L=g(14058);const D="cachedOperationValue",S="cachedExecutionId";class u extends N.b{constructor(E,U){super(U),this.value=this.registerDataOutput("value",E),this.isValid=this.registerDataOutput("isValid",L.g)}_updateOutputs(E){const U=E._getExecutionVariable(this,S,-1),g=E._getExecutionVariable(this,D,null);if(void 0!==g&&null!==g&&U===E.executionId)this.isValid.setValue(!0,E),this.value.setValue(g,E);else try{const U=this._doOperation(E);if(void 0===U||null===U)return void this.isValid.setValue(!1,E);E._setExecutionVariable(this,D,U),E._setExecutionVariable(this,S,E.executionId),this.value.setValue(U,E),this.isValid.setValue(!0,E)}catch(N){this.isValid.setValue(!1,E)}}}},15598:(E,U,g)=>{g.d(U,{d:()=>L});var N=g(15596);class L extends N.b{constructor(E,U,g,N,L){super(U,L),this._operation=g,this._className=N,this.a=this.registerDataInput("a",E)}_doOperation(E){return this._operation(this.a.getValue(E))}getClassName(){return this._className}}}}]);