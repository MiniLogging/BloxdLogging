"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[89],{15879:(s,k,h)=>{h.r(k),h.d(k,{FlowGraphAngleBetweenBlock:()=>Q,FlowGraphAxisAngleFromQuaternionBlock:()=>I,FlowGraphConjugateBlock:()=>G,FlowGraphCrossBlock:()=>P,FlowGraphDotBlock:()=>j,FlowGraphLengthBlock:()=>d,FlowGraphNormalizeBlock:()=>E,FlowGraphQuaternionFromAxisAngleBlock:()=>p,FlowGraphQuaternionFromDirectionsBlock:()=>N,FlowGraphRotate2DBlock:()=>R,FlowGraphRotate3DBlock:()=>D,FlowGraphTransformBlock:()=>B,FlowGraphTransformCoordinatesBlock:()=>u});var A=h(14325),g=h(14315),ms=h(12543),i=h(15863),K=h(15876),H=h(12590),O=h(14338),c=h(13990);const S="cachedOperationAxis",a="cachedOperationAngle",r="cachedExecutionId";class d extends K.b{constructor(s){super(g.c,g.m,(s=>this._polymorphicLength(s)),"FlowGraphLengthBlock",s)}_polymorphicLength(s){switch((0,O.k)(s)){case"Vector2":case"Pk":case"Vector4":case"Quaternion":return s.length();default:throw new Error(`Cannot compute length of value ${s}`)}}}(0,ms.f)("FlowGraphLengthBlock",d);class E extends K.b{constructor(s){super(g.c,g.c,(s=>this._polymorphicNormalize(s)),"FlowGraphNormalizeBlock",s)}_polymorphicNormalize(s){var k;let h;switch((0,O.k)(s)){case"Vector2":case"Pk":case"Vector4":case"Quaternion":if(h=s.normalizeToNew(),null!==(k=this.config)&&void 0!==k&&k.nanOnZeroLength){0===s.length()&&h.Eg(NaN)}return h;default:throw new Error(`Cannot normalize value ${s}`)}}}(0,ms.f)("FlowGraphNormalizeBlock",E);class j extends i.c{constructor(s){super(g.c,g.c,g.m,((s,k)=>this._polymorphicDot(s,k)),"FlowGraphDotBlock",s)}_polymorphicDot(s,k){switch((0,O.k)(s)){case"Vector2":case"Pk":case"Vector4":case"Quaternion":return s.dot(k);default:throw new Error(`Cannot get dot product of ${s} and ${k}`)}}}(0,ms.f)("FlowGraphDotBlock",j);class P extends i.c{constructor(s){super(g.x,g.x,g.x,((s,k)=>H.Pk.Cross(s,k)),"FlowGraphCrossBlock",s)}}(0,ms.f)("FlowGraphCrossBlock",P);class R extends i.c{constructor(s){super(g.t,g.m,g.t,((s,k)=>s.rotate(k)),"FlowGraphRotate2DBlock",s)}}(0,ms.f)("FlowGraphRotate2DBlock",R);class D extends i.c{constructor(s){super(g.x,g.q,g.x,((s,k)=>s.applyRotationQuaternion(k)),"FlowGraphRotate3DBlock",s)}}function w(s,k){switch((0,O.k)(s)){case"Vector2":case"Pk":return k.transformVector(s);case"Vector4":return new H.Vector4(s.x*k.m[0]+s.y*k.m[1]+s.z*k.m[2]+s.w*k.m[3],s.x*k.m[4]+s.y*k.m[5]+s.z*k.m[6]+s.w*k.m[7],s.x*k.m[8]+s.y*k.m[9]+s.z*k.m[10]+s.w*k.m[11],s.x*k.m[12]+s.y*k.m[13]+s.z*k.m[14]+s.w*k.m[15]);default:throw new Error(`Cannot transform value ${s}`)}}(0,ms.f)("FlowGraphRotate3DBlock",D);class B extends i.c{constructor(s){const k=(null===s||void 0===s?void 0:s.vectorType)||"Pk",h="Vector2"===k?"Matrix2D":"Pk"===k?"Matrix3D":"Matrix";super((0,g.G)(k),(0,g.G)(h),(0,g.G)(k),w,"FlowGraphTransformVectorBlock",s)}}(0,ms.f)("FlowGraphTransformVectorBlock",B);class u extends i.c{constructor(s){super(g.x,g.f,g.x,((s,k)=>H.Pk.TransformCoordinates(s,k)),"FlowGraphTransformCoordinatesBlock",s)}}(0,ms.f)("FlowGraphTransformCoordinatesBlock",u);class G extends K.b{constructor(s){super(g.q,g.q,(s=>s.conjugate()),"FlowGraphConjugateBlock",s)}}(0,ms.f)("FlowGraphConjugateBlock",G);class Q extends i.c{constructor(s){super(g.q,g.q,g.m,((s,k)=>(0,c.b)(s,k)),"FlowGraphAngleBetweenBlock",s)}}(0,ms.f)("FlowGraphAngleBetweenBlock",Q);class p extends i.c{constructor(s){super(g.x,g.m,g.q,((s,k)=>H.Quaternion.RotationAxis(s,k)),"FlowGraphQuaternionFromAxisAngleBlock",s)}}(0,ms.f)("FlowGraphQuaternionFromAxisAngleBlock",p);class I extends A.e{constructor(s){super(s),this.a=this.registerDataInput("a",g.q),this.axis=this.registerDataOutput("axis",g.x),this.angle=this.registerDataOutput("angle",g.m),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(s){const k=s._getExecutionVariable(this,r,-1),h=s._getExecutionVariable(this,S,null),A=s._getExecutionVariable(this,a,null);if(void 0!==h&&null!==h&&void 0!==A&&null!==A&&k===s.executionId)this.axis.setValue(h,s),this.angle.setValue(A,s);else try{const{axis:k,angle:h}=this.a.getValue(s).toAxisAngle();s._setExecutionVariable(this,S,k),s._setExecutionVariable(this,a,h),s._setExecutionVariable(this,r,s.executionId),this.axis.setValue(k,s),this.angle.setValue(h,s),this.isValid.setValue(!0,s)}catch(g){this.isValid.setValue(!1,s)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,ms.f)("FlowGraphAxisAngleFromQuaternionBlock",I);class N extends i.c{constructor(s){super(g.x,g.x,g.q,((s,k)=>(0,c.c)(s,k)),"FlowGraphQuaternionFromDirectionsBlock",s)}}},15863:(s,k,h)=>{h.d(k,{c:()=>g});var A=h(15871);class g extends A.e{constructor(s,k,h,A,g,ms){super(h,ms),this._operation=A,this._className=g,this.a=this.registerDataInput("a",s),this.b=this.registerDataInput("b",k)}_doOperation(s){const k=this.a.getValue(s),h=this.b.getValue(s);return this._operation(k,h)}getClassName(){return this._className}}},15871:(s,k,h)=>{h.d(k,{e:()=>K});var A=h(14325),g=h(14315);const ms="cachedOperationValue",i="cachedExecutionId";class K extends A.e{constructor(s,k){super(k),this.value=this.registerDataOutput("value",s),this.isValid=this.registerDataOutput("isValid",g.d)}_updateOutputs(s){const k=s._getExecutionVariable(this,i,-1),h=s._getExecutionVariable(this,ms,null);if(void 0!==h&&null!==h&&k===s.executionId)this.isValid.setValue(!0,s),this.value.setValue(h,s);else try{const k=this._doOperation(s);if(void 0===k||null===k)return void this.isValid.setValue(!1,s);s._setExecutionVariable(this,ms,k),s._setExecutionVariable(this,i,s.executionId),this.value.setValue(k,s),this.isValid.setValue(!0,s)}catch(A){this.isValid.setValue(!1,s)}}}},15876:(s,k,h)=>{h.d(k,{b:()=>g});var A=h(15871);class g extends A.e{constructor(s,k,h,A,g){super(k,g),this._operation=h,this._className=A,this.a=this.registerDataInput("a",s)}_doOperation(s){return this._operation(this.a.getValue(s))}getClassName(){return this._className}}}}]);