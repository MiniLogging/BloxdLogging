"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[89],{15921:(D,h,o)=>{o.r(h),o.d(h,{FlowGraphAngleBetweenBlock:()=>N,FlowGraphAxisAngleFromQuaternionBlock:()=>O,FlowGraphConjugateBlock:()=>G,FlowGraphCrossBlock:()=>U,FlowGraphDotBlock:()=>s,FlowGraphLengthBlock:()=>r,FlowGraphNormalizeBlock:()=>B,FlowGraphQuaternionFromAxisAngleBlock:()=>J,FlowGraphQuaternionFromDirectionsBlock:()=>E,FlowGraphRotate2DBlock:()=>q,FlowGraphRotate3DBlock:()=>c,FlowGraphTransformBlock:()=>b,FlowGraphTransformCoordinatesBlock:()=>i});var H=o(14386),g=o(14362),j=o(12793),M=o(15901),R=o(15918),t=o(12831),S=o(14402),k=o(14065);const K="cachedOperationAxis",Q="cachedOperationAngle",v="cachedExecutionId";class r extends R.c{constructor(D){super(g.c,g.q,(D=>this._polymorphicLength(D)),"FlowGraphLengthBlock",D)}_polymorphicLength(D){switch((0,S.l)(D)){case"Vector2":case"Gh":case"Vector4":case"Quaternion":return D.length();default:throw new Error(`Cannot compute length of value ${D}`)}}}(0,j.g)("FlowGraphLengthBlock",r);class B extends R.c{constructor(D){super(g.c,g.c,(D=>this._polymorphicNormalize(D)),"FlowGraphNormalizeBlock",D)}_polymorphicNormalize(D){var h;let o;switch((0,S.l)(D)){case"Vector2":case"Gh":case"Vector4":case"Quaternion":if(o=D.normalizeToNew(),null!==(h=this.config)&&void 0!==h&&h.nanOnZeroLength){0===D.length()&&o.qg(NaN)}return o;default:throw new Error(`Cannot normalize value ${D}`)}}}(0,j.g)("FlowGraphNormalizeBlock",B);class s extends M.c{constructor(D){super(g.c,g.c,g.q,((D,h)=>this._polymorphicDot(D,h)),"FlowGraphDotBlock",D)}_polymorphicDot(D,h){switch((0,S.l)(D)){case"Vector2":case"Gh":case"Vector4":case"Quaternion":return D.dot(h);default:throw new Error(`Cannot get dot product of ${D} and ${h}`)}}}(0,j.g)("FlowGraphDotBlock",s);class U extends M.c{constructor(D){super(g.w,g.w,g.w,((D,h)=>t.Gh.Cross(D,h)),"FlowGraphCrossBlock",D)}}(0,j.g)("FlowGraphCrossBlock",U);class q extends M.c{constructor(D){super(g.t,g.q,g.t,((D,h)=>D.rotate(h)),"FlowGraphRotate2DBlock",D)}}(0,j.g)("FlowGraphRotate2DBlock",q);class c extends M.c{constructor(D){super(g.w,g.r,g.w,((D,h)=>D.applyRotationQuaternion(h)),"FlowGraphRotate3DBlock",D)}}function y(D,h){switch((0,S.l)(D)){case"Vector2":case"Gh":return h.transformVector(D);case"Vector4":return new t.Vector4(D.x*h.m[0]+D.y*h.m[1]+D.z*h.m[2]+D.w*h.m[3],D.x*h.m[4]+D.y*h.m[5]+D.z*h.m[6]+D.w*h.m[7],D.x*h.m[8]+D.y*h.m[9]+D.z*h.m[10]+D.w*h.m[11],D.x*h.m[12]+D.y*h.m[13]+D.z*h.m[14]+D.w*h.m[15]);default:throw new Error(`Cannot transform value ${D}`)}}(0,j.g)("FlowGraphRotate3DBlock",c);class b extends M.c{constructor(D){const h=(null===D||void 0===D?void 0:D.vectorType)||"Gh",o="Vector2"===h?"Matrix2D":"Gh"===h?"Matrix3D":"Matrix";super((0,g.D)(h),(0,g.D)(o),(0,g.D)(h),y,"FlowGraphTransformVectorBlock",D)}}(0,j.g)("FlowGraphTransformVectorBlock",b);class i extends M.c{constructor(D){super(g.w,g.l,g.w,((D,h)=>t.Gh.TransformCoordinates(D,h)),"FlowGraphTransformCoordinatesBlock",D)}}(0,j.g)("FlowGraphTransformCoordinatesBlock",i);class G extends R.c{constructor(D){super(g.r,g.r,(D=>D.conjugate()),"FlowGraphConjugateBlock",D)}}(0,j.g)("FlowGraphConjugateBlock",G);class N extends M.c{constructor(D){super(g.r,g.r,g.q,((D,h)=>(0,k.e)(D,h)),"FlowGraphAngleBetweenBlock",D)}}(0,j.g)("FlowGraphAngleBetweenBlock",N);class J extends M.c{constructor(D){super(g.w,g.q,g.r,((D,h)=>t.Quaternion.RotationAxis(D,h)),"FlowGraphQuaternionFromAxisAngleBlock",D)}}(0,j.g)("FlowGraphQuaternionFromAxisAngleBlock",J);class O extends H.e{constructor(D){super(D),this.a=this.registerDataInput("a",g.r),this.axis=this.registerDataOutput("axis",g.w),this.angle=this.registerDataOutput("angle",g.q),this.isValid=this.registerDataOutput("isValid",g.f)}_updateOutputs(D){const h=D._getExecutionVariable(this,v,-1),o=D._getExecutionVariable(this,K,null),H=D._getExecutionVariable(this,Q,null);if(void 0!==o&&null!==o&&void 0!==H&&null!==H&&h===D.executionId)this.axis.setValue(o,D),this.angle.setValue(H,D);else try{const{axis:h,angle:o}=this.a.getValue(D).toAxisAngle();D._setExecutionVariable(this,K,h),D._setExecutionVariable(this,Q,o),D._setExecutionVariable(this,v,D.executionId),this.axis.setValue(h,D),this.angle.setValue(o,D),this.isValid.setValue(!0,D)}catch(g){this.isValid.setValue(!1,D)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,j.g)("FlowGraphAxisAngleFromQuaternionBlock",O);class E extends M.c{constructor(D){super(g.w,g.w,g.r,((D,h)=>(0,k.g)(D,h)),"FlowGraphQuaternionFromDirectionsBlock",D)}}},15901:(D,h,o)=>{o.d(h,{c:()=>g});var H=o(15909);class g extends H.b{constructor(D,h,o,H,g,j){super(o,j),this._operation=H,this._className=g,this.a=this.registerDataInput("a",D),this.b=this.registerDataInput("b",h)}_doOperation(D){const h=this.a.getValue(D),o=this.b.getValue(D);return this._operation(h,o)}getClassName(){return this._className}}},15909:(D,h,o)=>{o.d(h,{b:()=>R});var H=o(14386),g=o(14362);const j="cachedOperationValue",M="cachedExecutionId";class R extends H.e{constructor(D,h){super(h),this.value=this.registerDataOutput("value",D),this.isValid=this.registerDataOutput("isValid",g.f)}_updateOutputs(D){const h=D._getExecutionVariable(this,M,-1),o=D._getExecutionVariable(this,j,null);if(void 0!==o&&null!==o&&h===D.executionId)this.isValid.setValue(!0,D),this.value.setValue(o,D);else try{const h=this._doOperation(D);if(void 0===h||null===h)return void this.isValid.setValue(!1,D);D._setExecutionVariable(this,j,h),D._setExecutionVariable(this,M,D.executionId),this.value.setValue(h,D),this.isValid.setValue(!0,D)}catch(H){this.isValid.setValue(!1,D)}}}},15918:(D,h,o)=>{o.d(h,{c:()=>g});var H=o(15909);class g extends H.b{constructor(D,h,o,H,g){super(h,g),this._operation=o,this._className=H,this.a=this.registerDataInput("a",D)}_doOperation(D){return this._operation(this.a.getValue(D))}getClassName(){return this._className}}}}]);