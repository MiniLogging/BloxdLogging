"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14344:(g,w,q)=>{q.r(w),q.d(w,{FlowGraphAngleBetweenBlock:()=>a,FlowGraphAxisAngleFromQuaternionBlock:()=>C,FlowGraphConjugateBlock:()=>N,FlowGraphCrossBlock:()=>J,FlowGraphDotBlock:()=>l,FlowGraphLengthBlock:()=>L,FlowGraphNormalizeBlock:()=>A,FlowGraphQuaternionFromAxisAngleBlock:()=>H,FlowGraphQuaternionFromDirectionsBlock:()=>c,FlowGraphRotate2DBlock:()=>x,FlowGraphRotate3DBlock:()=>G,FlowGraphTransformBlock:()=>D,FlowGraphTransformCoordinatesBlock:()=>U});var R=q(12863),o=q(12836),r=q(11128),S=q(14324),i=q(14337),T=q(11180),z=q(12872),t=q(12514);const m="cachedOperationAxis",e="cachedOperationAngle",y="cachedExecutionId";class L extends i.c{constructor(g){super(o.d,o.w,(g=>this._polymorphicLength(g)),"FlowGraphLengthBlock",g)}_polymorphicLength(g){switch((0,z.i)(g)){case"Vector2":case"ew":case"Vector4":case"Quaternion":return g.length();default:throw new Error(`Cannot compute length of value ${g}`)}}}(0,r.g)("FlowGraphLengthBlock",L);class A extends i.c{constructor(g){super(o.d,o.d,(g=>this._polymorphicNormalize(g)),"FlowGraphNormalizeBlock",g)}_polymorphicNormalize(g){var w;let q;switch((0,z.i)(g)){case"Vector2":case"ew":case"Vector4":case"Quaternion":if(q=g.normalizeToNew(),null!==(w=this.config)&&void 0!==w&&w.nanOnZeroLength){0===g.length()&&q.yi(NaN)}return q;default:throw new Error(`Cannot normalize value ${g}`)}}}(0,r.g)("FlowGraphNormalizeBlock",A);class l extends S.b{constructor(g){super(o.d,o.d,o.w,((g,w)=>this._polymorphicDot(g,w)),"FlowGraphDotBlock",g)}_polymorphicDot(g,w){switch((0,z.i)(g)){case"Vector2":case"ew":case"Vector4":case"Quaternion":return g.dot(w);default:throw new Error(`Cannot get dot product of ${g} and ${w}`)}}}(0,r.g)("FlowGraphDotBlock",l);class J extends S.b{constructor(g){super(o.H,o.H,o.H,((g,w)=>T.ew.Cross(g,w)),"FlowGraphCrossBlock",g)}}(0,r.g)("FlowGraphCrossBlock",J);class x extends S.b{constructor(g){super(o.G,o.w,o.G,((g,w)=>g.rotate(w)),"FlowGraphRotate2DBlock",g)}}(0,r.g)("FlowGraphRotate2DBlock",x);class G extends S.b{constructor(g){super(o.H,o.z,o.H,((g,w)=>g.applyRotationQuaternion(w)),"FlowGraphRotate3DBlock",g)}}function d(g,w){switch((0,z.i)(g)){case"Vector2":case"ew":return w.transformVector(g);case"Vector4":return new T.Vector4(g.x*w.m[0]+g.y*w.m[1]+g.z*w.m[2]+g.w*w.m[3],g.x*w.m[4]+g.y*w.m[5]+g.z*w.m[6]+g.w*w.m[7],g.x*w.m[8]+g.y*w.m[9]+g.z*w.m[10]+g.w*w.m[11],g.x*w.m[12]+g.y*w.m[13]+g.z*w.m[14]+g.w*w.m[15]);default:throw new Error(`Cannot transform value ${g}`)}}(0,r.g)("FlowGraphRotate3DBlock",G);class D extends S.b{constructor(g){const w=(null===g||void 0===g?void 0:g.vectorType)||"ew",q="Vector2"===w?"Matrix2D":"ew"===w?"Matrix3D":"Matrix";super((0,o.S)(w),(0,o.S)(q),(0,o.S)(w),d,"FlowGraphTransformVectorBlock",g)}}(0,r.g)("FlowGraphTransformVectorBlock",D);class U extends S.b{constructor(g){super(o.H,o.o,o.H,((g,w)=>T.ew.TransformCoordinates(g,w)),"FlowGraphTransformCoordinatesBlock",g)}}(0,r.g)("FlowGraphTransformCoordinatesBlock",U);class N extends i.c{constructor(g){super(o.z,o.z,(g=>g.conjugate()),"FlowGraphConjugateBlock",g)}}(0,r.g)("FlowGraphConjugateBlock",N);class a extends S.b{constructor(g){super(o.z,o.z,o.w,((g,w)=>(0,t.c)(g,w)),"FlowGraphAngleBetweenBlock",g)}}(0,r.g)("FlowGraphAngleBetweenBlock",a);class H extends S.b{constructor(g){super(o.H,o.w,o.z,((g,w)=>T.Quaternion.RotationAxis(g,w)),"FlowGraphQuaternionFromAxisAngleBlock",g)}}(0,r.g)("FlowGraphQuaternionFromAxisAngleBlock",H);class C extends R.e{constructor(g){super(g),this.a=this.registerDataInput("a",o.z),this.axis=this.registerDataOutput("axis",o.H),this.angle=this.registerDataOutput("angle",o.w),this.isValid=this.registerDataOutput("isValid",o.h)}_updateOutputs(g){const w=g._getExecutionVariable(this,y,-1),q=g._getExecutionVariable(this,m,null),R=g._getExecutionVariable(this,e,null);if(void 0!==q&&null!==q&&void 0!==R&&null!==R&&w===g.executionId)this.axis.setValue(q,g),this.angle.setValue(R,g);else try{const{axis:w,angle:q}=this.a.getValue(g).toAxisAngle();g._setExecutionVariable(this,m,w),g._setExecutionVariable(this,e,q),g._setExecutionVariable(this,y,g.executionId),this.axis.setValue(w,g),this.angle.setValue(q,g),this.isValid.setValue(!0,g)}catch(o){this.isValid.setValue(!1,g)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,r.g)("FlowGraphAxisAngleFromQuaternionBlock",C);class c extends S.b{constructor(g){super(o.H,o.H,o.z,((g,w)=>(0,t.e)(g,w)),"FlowGraphQuaternionFromDirectionsBlock",g)}}},14324:(g,w,q)=>{q.d(w,{b:()=>o});var R=q(14333);class o extends R.d{constructor(g,w,q,R,o,r){super(q,r),this._operation=R,this._className=o,this.a=this.registerDataInput("a",g),this.b=this.registerDataInput("b",w)}_doOperation(g){const w=this.a.getValue(g),q=this.b.getValue(g);return this._operation(w,q)}getClassName(){return this._className}}},14333:(g,w,q)=>{q.d(w,{d:()=>i});var R=q(12863),o=q(12836);const r="cachedOperationValue",S="cachedExecutionId";class i extends R.e{constructor(g,w){super(w),this.value=this.registerDataOutput("value",g),this.isValid=this.registerDataOutput("isValid",o.h)}_updateOutputs(g){const w=g._getExecutionVariable(this,S,-1),q=g._getExecutionVariable(this,r,null);if(void 0!==q&&null!==q&&w===g.executionId)this.isValid.setValue(!0,g),this.value.setValue(q,g);else try{const w=this._doOperation(g);if(void 0===w||null===w)return void this.isValid.setValue(!1,g);g._setExecutionVariable(this,r,w),g._setExecutionVariable(this,S,g.executionId),this.value.setValue(w,g),this.isValid.setValue(!0,g)}catch(R){this.isValid.setValue(!1,g)}}}},14337:(g,w,q)=>{q.d(w,{c:()=>o});var R=q(14333);class o extends R.d{constructor(g,w,q,R,o){super(w,o),this._operation=q,this._className=R,this.a=this.registerDataInput("a",g)}_doOperation(g){return this._operation(this.a.getValue(g))}getClassName(){return this._className}}}}]);