"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[89],{15861:(M,A,O)=>{O.r(A),O.d(A,{FlowGraphAngleBetweenBlock:()=>C,FlowGraphAxisAngleFromQuaternionBlock:()=>D,FlowGraphConjugateBlock:()=>H,FlowGraphCrossBlock:()=>w,FlowGraphDotBlock:()=>d,FlowGraphLengthBlock:()=>K,FlowGraphNormalizeBlock:()=>G,FlowGraphQuaternionFromAxisAngleBlock:()=>f,FlowGraphQuaternionFromDirectionsBlock:()=>F,FlowGraphRotate2DBlock:()=>I,FlowGraphRotate3DBlock:()=>b,FlowGraphTransformBlock:()=>Y,FlowGraphTransformCoordinatesBlock:()=>E});var S=O(14255),z=O(14238),Q=O(12919),X=O(15842),c=O(15858),j=O(12970),B=O(14273),g=O(13949);const e="cachedOperationAxis",T="cachedOperationAngle",J="cachedExecutionId";class K extends c.e{constructor(M){super(z.b,z.t,(M=>this._polymorphicLength(M)),"FlowGraphLengthBlock",M)}_polymorphicLength(M){switch((0,B.g)(M)){case"Vector2":case"GA":case"Vector4":case"Quaternion":return M.length();default:throw new Error("Cannot compute length of value ".concat(M))}}}(0,Q.g)("FlowGraphLengthBlock",K);class G extends c.e{constructor(M){super(z.b,z.b,(M=>this._polymorphicNormalize(M)),"FlowGraphNormalizeBlock",M)}_polymorphicNormalize(M){var A;let O;switch((0,B.g)(M)){case"Vector2":case"GA":case"Vector4":case"Quaternion":if(O=M.normalizeToNew(),null!==(A=this.config)&&void 0!==A&&A.nanOnZeroLength){0===M.length()&&O.Hc(NaN)}return O;default:throw new Error("Cannot normalize value ".concat(M))}}}(0,Q.g)("FlowGraphNormalizeBlock",G);class d extends X.b{constructor(M){super(z.b,z.b,z.t,((M,A)=>this._polymorphicDot(M,A)),"FlowGraphDotBlock",M)}_polymorphicDot(M,A){switch((0,B.g)(M)){case"Vector2":case"GA":case"Vector4":case"Quaternion":return M.dot(A);default:throw new Error("Cannot get dot product of ".concat(M," and ").concat(A))}}}(0,Q.g)("FlowGraphDotBlock",d);class w extends X.b{constructor(M){super(z.D,z.D,z.D,((M,A)=>j.GA.Cross(M,A)),"FlowGraphCrossBlock",M)}}(0,Q.g)("FlowGraphCrossBlock",w);class I extends X.b{constructor(M){super(z.z,z.t,z.z,((M,A)=>M.rotate(A)),"FlowGraphRotate2DBlock",M)}}(0,Q.g)("FlowGraphRotate2DBlock",I);class b extends X.b{constructor(M){super(z.D,z.v,z.D,((M,A)=>M.applyRotationQuaternion(A)),"FlowGraphRotate3DBlock",M)}}function s(M,A){switch((0,B.g)(M)){case"Vector2":case"GA":return A.transformVector(M);case"Vector4":return new j.Vector4(M.x*A.m[0]+M.y*A.m[1]+M.z*A.m[2]+M.w*A.m[3],M.x*A.m[4]+M.y*A.m[5]+M.z*A.m[6]+M.w*A.m[7],M.x*A.m[8]+M.y*A.m[9]+M.z*A.m[10]+M.w*A.m[11],M.x*A.m[12]+M.y*A.m[13]+M.z*A.m[14]+M.w*A.m[15]);default:throw new Error("Cannot transform value ".concat(M))}}(0,Q.g)("FlowGraphRotate3DBlock",b);class Y extends X.b{constructor(M){const A=(null===M||void 0===M?void 0:M.vectorType)||"GA",O="Vector2"===A?"Matrix2D":"GA"===A?"Matrix3D":"Matrix";super((0,z.P)(A),(0,z.P)(O),(0,z.P)(A),s,"FlowGraphTransformVectorBlock",M)}}(0,Q.g)("FlowGraphTransformVectorBlock",Y);class E extends X.b{constructor(M){super(z.D,z.k,z.D,((M,A)=>j.GA.TransformCoordinates(M,A)),"FlowGraphTransformCoordinatesBlock",M)}}(0,Q.g)("FlowGraphTransformCoordinatesBlock",E);class H extends c.e{constructor(M){super(z.v,z.v,(M=>M.conjugate()),"FlowGraphConjugateBlock",M)}}(0,Q.g)("FlowGraphConjugateBlock",H);class C extends X.b{constructor(M){super(z.v,z.v,z.t,((M,A)=>(0,g.e)(M,A)),"FlowGraphAngleBetweenBlock",M)}}(0,Q.g)("FlowGraphAngleBetweenBlock",C);class f extends X.b{constructor(M){super(z.D,z.t,z.v,((M,A)=>j.Quaternion.RotationAxis(M,A)),"FlowGraphQuaternionFromAxisAngleBlock",M)}}(0,Q.g)("FlowGraphQuaternionFromAxisAngleBlock",f);class D extends S.c{constructor(M){super(M),this.a=this.registerDataInput("a",z.v),this.axis=this.registerDataOutput("axis",z.D),this.angle=this.registerDataOutput("angle",z.t),this.isValid=this.registerDataOutput("isValid",z.f)}_updateOutputs(M){const A=M._getExecutionVariable(this,J,-1),O=M._getExecutionVariable(this,e,null),S=M._getExecutionVariable(this,T,null);if(void 0!==O&&null!==O&&void 0!==S&&null!==S&&A===M.executionId)this.axis.setValue(O,M),this.angle.setValue(S,M);else try{const{axis:A,angle:O}=this.a.getValue(M).toAxisAngle();M._setExecutionVariable(this,e,A),M._setExecutionVariable(this,T,O),M._setExecutionVariable(this,J,M.executionId),this.axis.setValue(A,M),this.angle.setValue(O,M),this.isValid.setValue(!0,M)}catch(z){this.isValid.setValue(!1,M)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,Q.g)("FlowGraphAxisAngleFromQuaternionBlock",D);class F extends X.b{constructor(M){super(z.D,z.D,z.v,((M,A)=>(0,g.f)(M,A)),"FlowGraphQuaternionFromDirectionsBlock",M)}}},15842:(M,A,O)=>{O.d(A,{b:()=>z});var S=O(15851);class z extends S.c{constructor(M,A,O,S,z,Q){super(O,Q),this._operation=S,this._className=z,this.a=this.registerDataInput("a",M),this.b=this.registerDataInput("b",A)}_doOperation(M){const A=this.a.getValue(M),O=this.b.getValue(M);return this._operation(A,O)}getClassName(){return this._className}}},15851:(M,A,O)=>{O.d(A,{c:()=>c});var S=O(14255),z=O(14238);const Q="cachedOperationValue",X="cachedExecutionId";class c extends S.c{constructor(M,A){super(A),this.value=this.registerDataOutput("value",M),this.isValid=this.registerDataOutput("isValid",z.f)}_updateOutputs(M){const A=M._getExecutionVariable(this,X,-1),O=M._getExecutionVariable(this,Q,null);if(void 0!==O&&null!==O&&A===M.executionId)this.isValid.setValue(!0,M),this.value.setValue(O,M);else try{const A=this._doOperation(M);if(void 0===A||null===A)return void this.isValid.setValue(!1,M);M._setExecutionVariable(this,Q,A),M._setExecutionVariable(this,X,M.executionId),this.value.setValue(A,M),this.isValid.setValue(!0,M)}catch(S){this.isValid.setValue(!1,M)}}}},15858:(M,A,O)=>{O.d(A,{e:()=>z});var S=O(15851);class z extends S.c{constructor(M,A,O,S,z){super(A,z),this._operation=O,this._className=S,this.a=this.registerDataInput("a",M)}_doOperation(M){return this._operation(this.a.getValue(M))}getClassName(){return this._className}}}}]);