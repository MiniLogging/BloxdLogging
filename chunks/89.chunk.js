"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[89],{16077:(h,d,T)=>{T.r(d),T.d(d,{FlowGraphAngleBetweenBlock:()=>E,FlowGraphAxisAngleFromQuaternionBlock:()=>x,FlowGraphConjugateBlock:()=>s,FlowGraphCrossBlock:()=>W,FlowGraphDotBlock:()=>J,FlowGraphLengthBlock:()=>O,FlowGraphNormalizeBlock:()=>f,FlowGraphQuaternionFromAxisAngleBlock:()=>z,FlowGraphQuaternionFromDirectionsBlock:()=>g,FlowGraphRotate2DBlock:()=>L,FlowGraphRotate3DBlock:()=>D,FlowGraphTransformBlock:()=>i,FlowGraphTransformCoordinatesBlock:()=>w});var Y=T(14548),y=T(14528),C=T(12714),n=T(16060),X=T(16069),F=T(12765),U=T(14563),Z=T(14221);const S="cachedOperationAxis",r="cachedOperationAngle",c="cachedExecutionId";class O extends X.c{constructor(h){super(y.b,y.s,(h=>this._polymorphicLength(h)),"FlowGraphLengthBlock",h)}_polymorphicLength(h){switch((0,U.h)(h)){case"Vector2":case"pd":case"Vector4":case"Quaternion":return h.length();default:throw new Error(`Cannot compute length of value ${h}`)}}}(0,C.e)("FlowGraphLengthBlock",O);class f extends X.c{constructor(h){super(y.b,y.b,(h=>this._polymorphicNormalize(h)),"FlowGraphNormalizeBlock",h)}_polymorphicNormalize(h){var d;let T;switch((0,U.h)(h)){case"Vector2":case"pd":case"Vector4":case"Quaternion":if(T=h.normalizeToNew(),null!==(d=this.config)&&void 0!==d&&d.nanOnZeroLength){0===h.length()&&T.XC(NaN)}return T;default:throw new Error(`Cannot normalize value ${h}`)}}}(0,C.e)("FlowGraphNormalizeBlock",f);class J extends n.e{constructor(h){super(y.b,y.b,y.s,((h,d)=>this._polymorphicDot(h,d)),"FlowGraphDotBlock",h)}_polymorphicDot(h,d){switch((0,U.h)(h)){case"Vector2":case"pd":case"Vector4":case"Quaternion":return h.dot(d);default:throw new Error(`Cannot get dot product of ${h} and ${d}`)}}}(0,C.e)("FlowGraphDotBlock",J);class W extends n.e{constructor(h){super(y.A,y.A,y.A,((h,d)=>F.pd.Cross(h,d)),"FlowGraphCrossBlock",h)}}(0,C.e)("FlowGraphCrossBlock",W);class L extends n.e{constructor(h){super(y.y,y.s,y.y,((h,d)=>h.rotate(d)),"FlowGraphRotate2DBlock",h)}}(0,C.e)("FlowGraphRotate2DBlock",L);class D extends n.e{constructor(h){super(y.A,y.t,y.A,((h,d)=>h.applyRotationQuaternion(d)),"FlowGraphRotate3DBlock",h)}}function V(h,d){switch((0,U.h)(h)){case"Vector2":case"pd":return d.transformVector(h);case"Vector4":return new F.Vector4(h.x*d.m[0]+h.y*d.m[1]+h.z*d.m[2]+h.w*d.m[3],h.x*d.m[4]+h.y*d.m[5]+h.z*d.m[6]+h.w*d.m[7],h.x*d.m[8]+h.y*d.m[9]+h.z*d.m[10]+h.w*d.m[11],h.x*d.m[12]+h.y*d.m[13]+h.z*d.m[14]+h.w*d.m[15]);default:throw new Error(`Cannot transform value ${h}`)}}(0,C.e)("FlowGraphRotate3DBlock",D);class i extends n.e{constructor(h){const d=(null===h||void 0===h?void 0:h.vectorType)||"pd",T="Vector2"===d?"Matrix2D":"pd"===d?"Matrix3D":"Matrix";super((0,y.K)(d),(0,y.K)(T),(0,y.K)(d),V,"FlowGraphTransformVectorBlock",h)}}(0,C.e)("FlowGraphTransformVectorBlock",i);class w extends n.e{constructor(h){super(y.A,y.l,y.A,((h,d)=>F.pd.TransformCoordinates(h,d)),"FlowGraphTransformCoordinatesBlock",h)}}(0,C.e)("FlowGraphTransformCoordinatesBlock",w);class s extends X.c{constructor(h){super(y.t,y.t,(h=>h.conjugate()),"FlowGraphConjugateBlock",h)}}(0,C.e)("FlowGraphConjugateBlock",s);class E extends n.e{constructor(h){super(y.t,y.t,y.s,((h,d)=>(0,Z.d)(h,d)),"FlowGraphAngleBetweenBlock",h)}}(0,C.e)("FlowGraphAngleBetweenBlock",E);class z extends n.e{constructor(h){super(y.A,y.s,y.t,((h,d)=>F.Quaternion.RotationAxis(h,d)),"FlowGraphQuaternionFromAxisAngleBlock",h)}}(0,C.e)("FlowGraphQuaternionFromAxisAngleBlock",z);class x extends Y.e{constructor(h){super(h),this.a=this.registerDataInput("a",y.t),this.axis=this.registerDataOutput("axis",y.A),this.angle=this.registerDataOutput("angle",y.s),this.isValid=this.registerDataOutput("isValid",y.e)}_updateOutputs(h){const d=h._getExecutionVariable(this,c,-1),T=h._getExecutionVariable(this,S,null),Y=h._getExecutionVariable(this,r,null);if(void 0!==T&&null!==T&&void 0!==Y&&null!==Y&&d===h.executionId)this.axis.setValue(T,h),this.angle.setValue(Y,h);else try{const{axis:d,angle:T}=this.a.getValue(h).toAxisAngle();h._setExecutionVariable(this,S,d),h._setExecutionVariable(this,r,T),h._setExecutionVariable(this,c,h.executionId),this.axis.setValue(d,h),this.angle.setValue(T,h),this.isValid.setValue(!0,h)}catch(y){this.isValid.setValue(!1,h)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,C.e)("FlowGraphAxisAngleFromQuaternionBlock",x);class g extends n.e{constructor(h){super(y.A,y.A,y.t,((h,d)=>(0,Z.g)(h,d)),"FlowGraphQuaternionFromDirectionsBlock",h)}}},16060:(h,d,T)=>{T.d(d,{e:()=>y});var Y=T(16064);class y extends Y.c{constructor(h,d,T,Y,y,C){super(T,C),this._operation=Y,this._className=y,this.a=this.registerDataInput("a",h),this.b=this.registerDataInput("b",d)}_doOperation(h){const d=this.a.getValue(h),T=this.b.getValue(h);return this._operation(d,T)}getClassName(){return this._className}}},16064:(h,d,T)=>{T.d(d,{c:()=>X});var Y=T(14548),y=T(14528);const C="cachedOperationValue",n="cachedExecutionId";class X extends Y.e{constructor(h,d){super(d),this.value=this.registerDataOutput("value",h),this.isValid=this.registerDataOutput("isValid",y.e)}_updateOutputs(h){const d=h._getExecutionVariable(this,n,-1),T=h._getExecutionVariable(this,C,null);if(void 0!==T&&null!==T&&d===h.executionId)this.isValid.setValue(!0,h),this.value.setValue(T,h);else try{const d=this._doOperation(h);if(void 0===d||null===d)return void this.isValid.setValue(!1,h);h._setExecutionVariable(this,C,d),h._setExecutionVariable(this,n,h.executionId),this.value.setValue(d,h),this.isValid.setValue(!0,h)}catch(Y){this.isValid.setValue(!1,h)}}}},16069:(h,d,T)=>{T.d(d,{c:()=>y});var Y=T(16064);class y extends Y.c{constructor(h,d,T,Y,y){super(d,y),this._operation=T,this._className=Y,this.a=this.registerDataInput("a",h)}_doOperation(h){return this._operation(this.a.getValue(h))}getClassName(){return this._className}}}}]);