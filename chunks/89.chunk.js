"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[89],{16118:(Y,b,C)=>{C.r(b),C.d(b,{FlowGraphAngleBetweenBlock:()=>c,FlowGraphAxisAngleFromQuaternionBlock:()=>X,FlowGraphConjugateBlock:()=>u,FlowGraphCrossBlock:()=>w,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>n,FlowGraphNormalizeBlock:()=>t,FlowGraphQuaternionFromAxisAngleBlock:()=>l,FlowGraphQuaternionFromDirectionsBlock:()=>j,FlowGraphRotate2DBlock:()=>Q,FlowGraphRotate3DBlock:()=>N,FlowGraphTransformBlock:()=>mY,FlowGraphTransformCoordinatesBlock:()=>L});var R=C(14437),q=C(14424),A=C(12790),E=C(16103),B=C(16116),g=C(12831),r=C(14448),O=C(14094);const F="cachedOperationAxis",y="cachedOperationAngle",S="cachedExecutionId";class n extends B.e{constructor(Y){super(q.b,q.q,(Y=>this._polymorphicLength(Y)),"FlowGraphLengthBlock",Y)}_polymorphicLength(Y){switch((0,r.f)(Y)){case"Vector2":case"AC":case"Vector4":case"Quaternion":return Y.length();default:throw new Error(`Cannot compute length of value ${Y}`)}}}(0,A.g)("FlowGraphLengthBlock",n);class t extends B.e{constructor(Y){super(q.b,q.b,(Y=>this._polymorphicNormalize(Y)),"FlowGraphNormalizeBlock",Y)}_polymorphicNormalize(Y){var b;let C;switch((0,r.f)(Y)){case"Vector2":case"AC":case"Vector4":case"Quaternion":if(C=Y.normalizeToNew(),null!==(b=this.config)&&void 0!==b&&b.nanOnZeroLength){0===Y.length()&&C.Gb(NaN)}return C;default:throw new Error(`Cannot normalize value ${Y}`)}}}(0,A.g)("FlowGraphNormalizeBlock",t);class I extends E.e{constructor(Y){super(q.b,q.b,q.q,((Y,b)=>this._polymorphicDot(Y,b)),"FlowGraphDotBlock",Y)}_polymorphicDot(Y,b){switch((0,r.f)(Y)){case"Vector2":case"AC":case"Vector4":case"Quaternion":return Y.dot(b);default:throw new Error(`Cannot get dot product of ${Y} and ${b}`)}}}(0,A.g)("FlowGraphDotBlock",I);class w extends E.e{constructor(Y){super(q.A,q.A,q.A,((Y,b)=>g.AC.Cross(Y,b)),"FlowGraphCrossBlock",Y)}}(0,A.g)("FlowGraphCrossBlock",w);class Q extends E.e{constructor(Y){super(q.x,q.q,q.x,((Y,b)=>Y.rotate(b)),"FlowGraphRotate2DBlock",Y)}}(0,A.g)("FlowGraphRotate2DBlock",Q);class N extends E.e{constructor(Y){super(q.A,q.t,q.A,((Y,b)=>Y.applyRotationQuaternion(b)),"FlowGraphRotate3DBlock",Y)}}function p(Y,b){switch((0,r.f)(Y)){case"Vector2":case"AC":return b.transformVector(Y);case"Vector4":return new g.Vector4(Y.x*b.m[0]+Y.y*b.m[1]+Y.z*b.m[2]+Y.w*b.m[3],Y.x*b.m[4]+Y.y*b.m[5]+Y.z*b.m[6]+Y.w*b.m[7],Y.x*b.m[8]+Y.y*b.m[9]+Y.z*b.m[10]+Y.w*b.m[11],Y.x*b.m[12]+Y.y*b.m[13]+Y.z*b.m[14]+Y.w*b.m[15]);default:throw new Error(`Cannot transform value ${Y}`)}}(0,A.g)("FlowGraphRotate3DBlock",N);class mY extends E.e{constructor(Y){const b=(null===Y||void 0===Y?void 0:Y.vectorType)||"AC",C="Vector2"===b?"Matrix2D":"AC"===b?"Matrix3D":"Matrix";super((0,q.J)(b),(0,q.J)(C),(0,q.J)(b),p,"FlowGraphTransformVectorBlock",Y)}}(0,A.g)("FlowGraphTransformVectorBlock",mY);class L extends E.e{constructor(Y){super(q.A,q.j,q.A,((Y,b)=>g.AC.TransformCoordinates(Y,b)),"FlowGraphTransformCoordinatesBlock",Y)}}(0,A.g)("FlowGraphTransformCoordinatesBlock",L);class u extends B.e{constructor(Y){super(q.t,q.t,(Y=>Y.conjugate()),"FlowGraphConjugateBlock",Y)}}(0,A.g)("FlowGraphConjugateBlock",u);class c extends E.e{constructor(Y){super(q.t,q.t,q.q,((Y,b)=>(0,O.e)(Y,b)),"FlowGraphAngleBetweenBlock",Y)}}(0,A.g)("FlowGraphAngleBetweenBlock",c);class l extends E.e{constructor(Y){super(q.A,q.q,q.t,((Y,b)=>g.Quaternion.RotationAxis(Y,b)),"FlowGraphQuaternionFromAxisAngleBlock",Y)}}(0,A.g)("FlowGraphQuaternionFromAxisAngleBlock",l);class X extends R.e{constructor(Y){super(Y),this.a=this.registerDataInput("a",q.t),this.axis=this.registerDataOutput("axis",q.A),this.angle=this.registerDataOutput("angle",q.q),this.isValid=this.registerDataOutput("isValid",q.f)}_updateOutputs(Y){const b=Y._getExecutionVariable(this,S,-1),C=Y._getExecutionVariable(this,F,null),R=Y._getExecutionVariable(this,y,null);if(void 0!==C&&null!==C&&void 0!==R&&null!==R&&b===Y.executionId)this.axis.setValue(C,Y),this.angle.setValue(R,Y);else try{const{axis:b,angle:C}=this.a.getValue(Y).toAxisAngle();Y._setExecutionVariable(this,F,b),Y._setExecutionVariable(this,y,C),Y._setExecutionVariable(this,S,Y.executionId),this.axis.setValue(b,Y),this.angle.setValue(C,Y),this.isValid.setValue(!0,Y)}catch(q){this.isValid.setValue(!1,Y)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,A.g)("FlowGraphAxisAngleFromQuaternionBlock",X);class j extends E.e{constructor(Y){super(q.A,q.A,q.t,((Y,b)=>(0,O.h)(Y,b)),"FlowGraphQuaternionFromDirectionsBlock",Y)}}},16103:(Y,b,C)=>{C.d(b,{e:()=>q});var R=C(16111);class q extends R.d{constructor(Y,b,C,R,q,A){super(C,A),this._operation=R,this._className=q,this.a=this.registerDataInput("a",Y),this.b=this.registerDataInput("b",b)}_doOperation(Y){const b=this.a.getValue(Y),C=this.b.getValue(Y);return this._operation(b,C)}getClassName(){return this._className}}},16111:(Y,b,C)=>{C.d(b,{d:()=>B});var R=C(14437),q=C(14424);const A="cachedOperationValue",E="cachedExecutionId";class B extends R.e{constructor(Y,b){super(b),this.value=this.registerDataOutput("value",Y),this.isValid=this.registerDataOutput("isValid",q.f)}_updateOutputs(Y){const b=Y._getExecutionVariable(this,E,-1),C=Y._getExecutionVariable(this,A,null);if(void 0!==C&&null!==C&&b===Y.executionId)this.isValid.setValue(!0,Y),this.value.setValue(C,Y);else try{const b=this._doOperation(Y);if(void 0===b||null===b)return void this.isValid.setValue(!1,Y);Y._setExecutionVariable(this,A,b),Y._setExecutionVariable(this,E,Y.executionId),this.value.setValue(b,Y),this.isValid.setValue(!0,Y)}catch(R){this.isValid.setValue(!1,Y)}}}},16116:(Y,b,C)=>{C.d(b,{e:()=>q});var R=C(16111);class q extends R.d{constructor(Y,b,C,R,q){super(b,q),this._operation=C,this._className=R,this.a=this.registerDataInput("a",Y)}_doOperation(Y){return this._operation(this.a.getValue(Y))}getClassName(){return this._className}}}}]);