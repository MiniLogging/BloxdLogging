"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[89],{15734:(o,v,V)=>{V.r(v),V.d(v,{FlowGraphAngleBetweenBlock:()=>mo,FlowGraphAxisAngleFromQuaternionBlock:()=>F,FlowGraphConjugateBlock:()=>u,FlowGraphCrossBlock:()=>R,FlowGraphDotBlock:()=>c,FlowGraphLengthBlock:()=>S,FlowGraphNormalizeBlock:()=>T,FlowGraphQuaternionFromAxisAngleBlock:()=>a,FlowGraphQuaternionFromDirectionsBlock:()=>i,FlowGraphRotate2DBlock:()=>j,FlowGraphRotate3DBlock:()=>t,FlowGraphTransformBlock:()=>L,FlowGraphTransformCoordinatesBlock:()=>b});var g=V(14259),E=V(14241),I=V(12449),Q=V(15723),U=V(15732),n=V(12488),O=V(14267),h=V(13948);const x="cachedOperationAxis",f="cachedOperationAngle",l="cachedExecutionId";class S extends U.b{constructor(o){super(E.e,E.t,(o=>this._polymorphicLength(o)),"FlowGraphLengthBlock",o)}_polymorphicLength(o){switch((0,O.i)(o)){case"Vector2":case"cv":case"Vector4":case"Quaternion":return o.length();default:throw new Error(`Cannot compute length of value ${o}`)}}}(0,I.h)("FlowGraphLengthBlock",S);class T extends U.b{constructor(o){super(E.e,E.e,(o=>this._polymorphicNormalize(o)),"FlowGraphNormalizeBlock",o)}_polymorphicNormalize(o){var v;let V;switch((0,O.i)(o)){case"Vector2":case"cv":case"Vector4":case"Quaternion":if(V=o.normalizeToNew(),null!==(v=this.config)&&void 0!==v&&v.nanOnZeroLength){0===o.length()&&V.tU(NaN)}return V;default:throw new Error(`Cannot normalize value ${o}`)}}}(0,I.h)("FlowGraphNormalizeBlock",T);class c extends Q.b{constructor(o){super(E.e,E.e,E.t,((o,v)=>this._polymorphicDot(o,v)),"FlowGraphDotBlock",o)}_polymorphicDot(o,v){switch((0,O.i)(o)){case"Vector2":case"cv":case"Vector4":case"Quaternion":return o.dot(v);default:throw new Error(`Cannot get dot product of ${o} and ${v}`)}}}(0,I.h)("FlowGraphDotBlock",c);class R extends Q.b{constructor(o){super(E.C,E.C,E.C,((o,v)=>n.cv.Cross(o,v)),"FlowGraphCrossBlock",o)}}(0,I.h)("FlowGraphCrossBlock",R);class j extends Q.b{constructor(o){super(E.z,E.t,E.z,((o,v)=>o.rotate(v)),"FlowGraphRotate2DBlock",o)}}(0,I.h)("FlowGraphRotate2DBlock",j);class t extends Q.b{constructor(o){super(E.C,E.u,E.C,((o,v)=>o.applyRotationQuaternion(v)),"FlowGraphRotate3DBlock",o)}}function s(o,v){switch((0,O.i)(o)){case"Vector2":case"cv":return v.transformVector(o);case"Vector4":return new n.Vector4(o.x*v.m[0]+o.y*v.m[1]+o.z*v.m[2]+o.w*v.m[3],o.x*v.m[4]+o.y*v.m[5]+o.z*v.m[6]+o.w*v.m[7],o.x*v.m[8]+o.y*v.m[9]+o.z*v.m[10]+o.w*v.m[11],o.x*v.m[12]+o.y*v.m[13]+o.z*v.m[14]+o.w*v.m[15]);default:throw new Error(`Cannot transform value ${o}`)}}(0,I.h)("FlowGraphRotate3DBlock",t);class L extends Q.b{constructor(o){const v=(null===o||void 0===o?void 0:o.vectorType)||"cv",V="Vector2"===v?"Matrix2D":"cv"===v?"Matrix3D":"Matrix";super((0,E.M)(v),(0,E.M)(V),(0,E.M)(v),s,"FlowGraphTransformVectorBlock",o)}}(0,I.h)("FlowGraphTransformVectorBlock",L);class b extends Q.b{constructor(o){super(E.C,E.k,E.C,((o,v)=>n.cv.TransformCoordinates(o,v)),"FlowGraphTransformCoordinatesBlock",o)}}(0,I.h)("FlowGraphTransformCoordinatesBlock",b);class u extends U.b{constructor(o){super(E.u,E.u,(o=>o.conjugate()),"FlowGraphConjugateBlock",o)}}(0,I.h)("FlowGraphConjugateBlock",u);class mo extends Q.b{constructor(o){super(E.u,E.u,E.t,((o,v)=>(0,h.e)(o,v)),"FlowGraphAngleBetweenBlock",o)}}(0,I.h)("FlowGraphAngleBetweenBlock",mo);class a extends Q.b{constructor(o){super(E.C,E.t,E.u,((o,v)=>n.Quaternion.RotationAxis(o,v)),"FlowGraphQuaternionFromAxisAngleBlock",o)}}(0,I.h)("FlowGraphQuaternionFromAxisAngleBlock",a);class F extends g.b{constructor(o){super(o),this.a=this.registerDataInput("a",E.u),this.axis=this.registerDataOutput("axis",E.C),this.angle=this.registerDataOutput("angle",E.t),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(o){const v=o._getExecutionVariable(this,l,-1),V=o._getExecutionVariable(this,x,null),g=o._getExecutionVariable(this,f,null);if(void 0!==V&&null!==V&&void 0!==g&&null!==g&&v===o.executionId)this.axis.setValue(V,o),this.angle.setValue(g,o);else try{const{axis:v,angle:V}=this.a.getValue(o).toAxisAngle();o._setExecutionVariable(this,x,v),o._setExecutionVariable(this,f,V),o._setExecutionVariable(this,l,o.executionId),this.axis.setValue(v,o),this.angle.setValue(V,o),this.isValid.setValue(!0,o)}catch(E){this.isValid.setValue(!1,o)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,I.h)("FlowGraphAxisAngleFromQuaternionBlock",F);class i extends Q.b{constructor(o){super(E.C,E.C,E.u,((o,v)=>(0,h.i)(o,v)),"FlowGraphQuaternionFromDirectionsBlock",o)}}},15723:(o,v,V)=>{V.d(v,{b:()=>E});var g=V(15726);class E extends g.b{constructor(o,v,V,g,E,I){super(V,I),this._operation=g,this._className=E,this.a=this.registerDataInput("a",o),this.b=this.registerDataInput("b",v)}_doOperation(o){const v=this.a.getValue(o),V=this.b.getValue(o);return this._operation(v,V)}getClassName(){return this._className}}},15726:(o,v,V)=>{V.d(v,{b:()=>U});var g=V(14259),E=V(14241);const I="cachedOperationValue",Q="cachedExecutionId";class U extends g.b{constructor(o,v){super(v),this.value=this.registerDataOutput("value",o),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(o){const v=o._getExecutionVariable(this,Q,-1),V=o._getExecutionVariable(this,I,null);if(void 0!==V&&null!==V&&v===o.executionId)this.isValid.setValue(!0,o),this.value.setValue(V,o);else try{const v=this._doOperation(o);if(void 0===v||null===v)return void this.isValid.setValue(!1,o);o._setExecutionVariable(this,I,v),o._setExecutionVariable(this,Q,o.executionId),this.value.setValue(v,o),this.isValid.setValue(!0,o)}catch(g){this.isValid.setValue(!1,o)}}}},15732:(o,v,V)=>{V.d(v,{b:()=>E});var g=V(15726);class E extends g.b{constructor(o,v,V,g,E){super(v,E),this._operation=V,this._className=g,this.a=this.registerDataInput("a",o)}_doOperation(o){return this._operation(this.a.getValue(o))}getClassName(){return this._className}}}}]);