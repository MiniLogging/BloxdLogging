"use strict";(self.h66iwo8dvgq=self.h66iwo8dvgq||[]).push([[89],{15222:(b,X,P)=>{P.r(X),P.d(X,{FlowGraphAngleBetweenBlock:()=>v,FlowGraphAxisAngleFromQuaternionBlock:()=>o,FlowGraphConjugateBlock:()=>Z,FlowGraphCrossBlock:()=>B,FlowGraphDotBlock:()=>t,FlowGraphLengthBlock:()=>D,FlowGraphNormalizeBlock:()=>E,FlowGraphQuaternionFromAxisAngleBlock:()=>A,FlowGraphQuaternionFromDirectionsBlock:()=>K,FlowGraphRotate2DBlock:()=>W,FlowGraphRotate3DBlock:()=>n,FlowGraphTransformBlock:()=>h,FlowGraphTransformCoordinatesBlock:()=>L});var Q=P(13647),S=P(13631),d=P(11802),N=P(15202),a=P(15213),u=P(11834),w=P(13659),f=P(13326);const O="cachedOperationAxis",e="cachedOperationAngle",Y="cachedExecutionId";class D extends a.d{constructor(b){super(S.e,S.t,(b=>this._polymorphicLength(b)),"FlowGraphLengthBlock",b)}_polymorphicLength(b){switch((0,w.i)(b)){case"Vector2":case"tX":case"Vector4":case"Quaternion":return b.length();default:throw new Error(`Cannot compute length of value ${b}`)}}}(0,d.h)("FlowGraphLengthBlock",D);class E extends a.d{constructor(b){super(S.e,S.e,(b=>this._polymorphicNormalize(b)),"FlowGraphNormalizeBlock",b)}_polymorphicNormalize(b){var X;let P;switch((0,w.i)(b)){case"Vector2":case"tX":case"Vector4":case"Quaternion":if(P=b.normalizeToNew(),null!==(X=this.config)&&void 0!==X&&X.nanOnZeroLength){0===b.length()&&P.Gd(NaN)}return P;default:throw new Error(`Cannot normalize value ${b}`)}}}(0,d.h)("FlowGraphNormalizeBlock",E);class t extends N.b{constructor(b){super(S.e,S.e,S.t,((b,X)=>this._polymorphicDot(b,X)),"FlowGraphDotBlock",b)}_polymorphicDot(b,X){switch((0,w.i)(b)){case"Vector2":case"tX":case"Vector4":case"Quaternion":return b.dot(X);default:throw new Error(`Cannot get dot product of ${b} and ${X}`)}}}(0,d.h)("FlowGraphDotBlock",t);class B extends N.b{constructor(b){super(S.B,S.B,S.B,((b,X)=>u.tX.Cross(b,X)),"FlowGraphCrossBlock",b)}}(0,d.h)("FlowGraphCrossBlock",B);class W extends N.b{constructor(b){super(S.y,S.t,S.y,((b,X)=>b.rotate(X)),"FlowGraphRotate2DBlock",b)}}(0,d.h)("FlowGraphRotate2DBlock",W);class n extends N.b{constructor(b){super(S.B,S.u,S.B,((b,X)=>b.applyRotationQuaternion(X)),"FlowGraphRotate3DBlock",b)}}function y(b,X){switch((0,w.i)(b)){case"Vector2":case"tX":return X.transformVector(b);case"Vector4":return new u.Vector4(b.x*X.m[0]+b.y*X.m[1]+b.z*X.m[2]+b.w*X.m[3],b.x*X.m[4]+b.y*X.m[5]+b.z*X.m[6]+b.w*X.m[7],b.x*X.m[8]+b.y*X.m[9]+b.z*X.m[10]+b.w*X.m[11],b.x*X.m[12]+b.y*X.m[13]+b.z*X.m[14]+b.w*X.m[15]);default:throw new Error(`Cannot transform value ${b}`)}}(0,d.h)("FlowGraphRotate3DBlock",n);class h extends N.b{constructor(b){const X=(null===b||void 0===b?void 0:b.vectorType)||"tX",P="Vector2"===X?"Matrix2D":"tX"===X?"Matrix3D":"Matrix";super((0,S.H)(X),(0,S.H)(P),(0,S.H)(X),y,"FlowGraphTransformVectorBlock",b)}}(0,d.h)("FlowGraphTransformVectorBlock",h);class L extends N.b{constructor(b){super(S.B,S.k,S.B,((b,X)=>u.tX.TransformCoordinates(b,X)),"FlowGraphTransformCoordinatesBlock",b)}}(0,d.h)("FlowGraphTransformCoordinatesBlock",L);class Z extends a.d{constructor(b){super(S.u,S.u,(b=>b.conjugate()),"FlowGraphConjugateBlock",b)}}(0,d.h)("FlowGraphConjugateBlock",Z);class v extends N.b{constructor(b){super(S.u,S.u,S.t,((b,X)=>(0,f.b)(b,X)),"FlowGraphAngleBetweenBlock",b)}}(0,d.h)("FlowGraphAngleBetweenBlock",v);class A extends N.b{constructor(b){super(S.B,S.t,S.u,((b,X)=>u.Quaternion.RotationAxis(b,X)),"FlowGraphQuaternionFromAxisAngleBlock",b)}}(0,d.h)("FlowGraphQuaternionFromAxisAngleBlock",A);class o extends Q.c{constructor(b){super(b),this.a=this.registerDataInput("a",S.u),this.axis=this.registerDataOutput("axis",S.B),this.angle=this.registerDataOutput("angle",S.t),this.isValid=this.registerDataOutput("isValid",S.h)}_updateOutputs(b){const X=b._getExecutionVariable(this,Y,-1),P=b._getExecutionVariable(this,O,null),Q=b._getExecutionVariable(this,e,null);if(void 0!==P&&null!==P&&void 0!==Q&&null!==Q&&X===b.executionId)this.axis.setValue(P,b),this.angle.setValue(Q,b);else try{const{axis:X,angle:P}=this.a.getValue(b).toAxisAngle();b._setExecutionVariable(this,O,X),b._setExecutionVariable(this,e,P),b._setExecutionVariable(this,Y,b.executionId),this.axis.setValue(X,b),this.angle.setValue(P,b),this.isValid.setValue(!0,b)}catch(S){this.isValid.setValue(!1,b)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,d.h)("FlowGraphAxisAngleFromQuaternionBlock",o);class K extends N.b{constructor(b){super(S.B,S.B,S.u,((b,X)=>(0,f.c)(b,X)),"FlowGraphQuaternionFromDirectionsBlock",b)}}},15202:(b,X,P)=>{P.d(X,{b:()=>S});var Q=P(15207);class S extends Q.d{constructor(b,X,P,Q,S,d){super(P,d),this._operation=Q,this._className=S,this.a=this.registerDataInput("a",b),this.b=this.registerDataInput("b",X)}_doOperation(b){const X=this.a.getValue(b),P=this.b.getValue(b);return this._operation(X,P)}getClassName(){return this._className}}},15207:(b,X,P)=>{P.d(X,{d:()=>a});var Q=P(13647),S=P(13631);const d="cachedOperationValue",N="cachedExecutionId";class a extends Q.c{constructor(b,X){super(X),this.value=this.registerDataOutput("value",b),this.isValid=this.registerDataOutput("isValid",S.h)}_updateOutputs(b){const X=b._getExecutionVariable(this,N,-1),P=b._getExecutionVariable(this,d,null);if(void 0!==P&&null!==P&&X===b.executionId)this.isValid.setValue(!0,b),this.value.setValue(P,b);else try{const X=this._doOperation(b);if(void 0===X||null===X)return void this.isValid.setValue(!1,b);b._setExecutionVariable(this,d,X),b._setExecutionVariable(this,N,b.executionId),this.value.setValue(X,b),this.isValid.setValue(!0,b)}catch(Q){this.isValid.setValue(!1,b)}}}},15213:(b,X,P)=>{P.d(X,{d:()=>S});var Q=P(15207);class S extends Q.d{constructor(b,X,P,Q,S){super(X,S),this._operation=P,this._className=Q,this.a=this.registerDataInput("a",b)}_doOperation(b){return this._operation(this.a.getValue(b))}getClassName(){return this._className}}}}]);