"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14483:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphAngleBetweenBlock:()=>y,FlowGraphAxisAngleFromQuaternionBlock:()=>R,FlowGraphConjugateBlock:()=>K,FlowGraphCrossBlock:()=>M,FlowGraphDotBlock:()=>k,FlowGraphLengthBlock:()=>p,FlowGraphNormalizeBlock:()=>U,FlowGraphQuaternionFromAxisAngleBlock:()=>q,FlowGraphQuaternionFromDirectionsBlock:()=>B,FlowGraphRotate2DBlock:()=>m,FlowGraphRotate3DBlock:()=>C,FlowGraphTransformBlock:()=>H,FlowGraphTransformCoordinatesBlock:()=>S});var u=F(12977),G=F(12954),f=F(11136),Y=F(14469),j=F(14478),d=F(11179),t=F(12990),o=F(12643);const c="cachedOperationAxis",s="cachedOperationAngle",J="cachedExecutionId";class p extends j.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicLength(Z)),"FlowGraphLengthBlock",Z)}_polymorphicLength(Z){switch((0,t.o)(Z)){case"Vector2":case"kx":case"Vector4":case"Quaternion":return Z.length();default:throw new Error(`Cannot compute length of value ${Z}`)}}}(0,f.g)("FlowGraphLengthBlock",p);class U extends j.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicNormalize(Z)),"FlowGraphNormalizeBlock",Z)}_polymorphicNormalize(Z){var x;let F;switch((0,t.o)(Z)){case"Vector2":case"kx":case"Vector4":case"Quaternion":if(F=Z.normalizeToNew(),null!==(x=this.config)&&void 0!==x&&x.nanOnZeroLength){0===Z.length()&&F.Uj(NaN)}return F;default:throw new Error(`Cannot normalize value ${Z}`)}}}(0,f.g)("FlowGraphNormalizeBlock",U);class k extends Y.c{constructor(Z){super(G.d,G.d,G.u,((Z,x)=>this._polymorphicDot(Z,x)),"FlowGraphDotBlock",Z)}_polymorphicDot(Z,x){switch((0,t.o)(Z)){case"Vector2":case"kx":case"Vector4":case"Quaternion":return Z.dot(x);default:throw new Error(`Cannot get dot product of ${Z} and ${x}`)}}}(0,f.g)("FlowGraphDotBlock",k);class M extends Y.c{constructor(Z){super(G.D,G.D,G.D,((Z,x)=>d.kx.Cross(Z,x)),"FlowGraphCrossBlock",Z)}}(0,f.g)("FlowGraphCrossBlock",M);class m extends Y.c{constructor(Z){super(G.C,G.u,G.C,((Z,x)=>Z.rotate(x)),"FlowGraphRotate2DBlock",Z)}}(0,f.g)("FlowGraphRotate2DBlock",m);class C extends Y.c{constructor(Z){super(G.D,G.v,G.D,((Z,x)=>Z.applyRotationQuaternion(x)),"FlowGraphRotate3DBlock",Z)}}function L(Z,x){switch((0,t.o)(Z)){case"Vector2":case"kx":return x.transformVector(Z);case"Vector4":return new d.Vector4(Z.x*x.m[0]+Z.y*x.m[1]+Z.z*x.m[2]+Z.w*x.m[3],Z.x*x.m[4]+Z.y*x.m[5]+Z.z*x.m[6]+Z.w*x.m[7],Z.x*x.m[8]+Z.y*x.m[9]+Z.z*x.m[10]+Z.w*x.m[11],Z.x*x.m[12]+Z.y*x.m[13]+Z.z*x.m[14]+Z.w*x.m[15]);default:throw new Error(`Cannot transform value ${Z}`)}}(0,f.g)("FlowGraphRotate3DBlock",C);class H extends Y.c{constructor(Z){const x=(null===Z||void 0===Z?void 0:Z.vectorType)||"kx",F="Vector2"===x?"Matrix2D":"kx"===x?"Matrix3D":"Matrix";super((0,G.Q)(x),(0,G.Q)(F),(0,G.Q)(x),L,"FlowGraphTransformVectorBlock",Z)}}(0,f.g)("FlowGraphTransformVectorBlock",H);class S extends Y.c{constructor(Z){super(G.D,G.k,G.D,((Z,x)=>d.kx.TransformCoordinates(Z,x)),"FlowGraphTransformCoordinatesBlock",Z)}}(0,f.g)("FlowGraphTransformCoordinatesBlock",S);class K extends j.d{constructor(Z){super(G.v,G.v,(Z=>Z.conjugate()),"FlowGraphConjugateBlock",Z)}}(0,f.g)("FlowGraphConjugateBlock",K);class y extends Y.c{constructor(Z){super(G.v,G.v,G.u,((Z,x)=>(0,o.c)(Z,x)),"FlowGraphAngleBetweenBlock",Z)}}(0,f.g)("FlowGraphAngleBetweenBlock",y);class q extends Y.c{constructor(Z){super(G.D,G.u,G.v,((Z,x)=>d.Quaternion.RotationAxis(Z,x)),"FlowGraphQuaternionFromAxisAngleBlock",Z)}}(0,f.g)("FlowGraphQuaternionFromAxisAngleBlock",q);class R extends u.e{constructor(Z){super(Z),this.a=this.registerDataInput("a",G.v),this.axis=this.registerDataOutput("axis",G.D),this.angle=this.registerDataOutput("angle",G.u),this.isValid=this.registerDataOutput("isValid",G.f)}_updateOutputs(Z){const x=Z._getExecutionVariable(this,J,-1),F=Z._getExecutionVariable(this,c,null),u=Z._getExecutionVariable(this,s,null);if(void 0!==F&&null!==F&&void 0!==u&&null!==u&&x===Z.executionId)this.axis.setValue(F,Z),this.angle.setValue(u,Z);else try{const{axis:x,angle:F}=this.a.getValue(Z).toAxisAngle();Z._setExecutionVariable(this,c,x),Z._setExecutionVariable(this,s,F),Z._setExecutionVariable(this,J,Z.executionId),this.axis.setValue(x,Z),this.angle.setValue(F,Z),this.isValid.setValue(!0,Z)}catch(G){this.isValid.setValue(!1,Z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,f.g)("FlowGraphAxisAngleFromQuaternionBlock",R);class B extends Y.c{constructor(Z){super(G.D,G.D,G.v,((Z,x)=>(0,o.e)(Z,x)),"FlowGraphQuaternionFromDirectionsBlock",Z)}}},14469:(Z,x,F)=>{F.d(x,{c:()=>G});var u=F(14476);class G extends u.c{constructor(Z,x,F,u,G,f){super(F,f),this._operation=u,this._className=G,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",x)}_doOperation(Z){const x=this.a.getValue(Z),F=this.b.getValue(Z);return this._operation(x,F)}getClassName(){return this._className}}},14476:(Z,x,F)=>{F.d(x,{c:()=>j});var u=F(12977),G=F(12954);const f="cachedOperationValue",Y="cachedExecutionId";class j extends u.e{constructor(Z,x){super(x),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",G.f)}_updateOutputs(Z){const x=Z._getExecutionVariable(this,Y,-1),F=Z._getExecutionVariable(this,f,null);if(void 0!==F&&null!==F&&x===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(F,Z);else try{const x=this._doOperation(Z);if(void 0===x||null===x)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,f,x),Z._setExecutionVariable(this,Y,Z.executionId),this.value.setValue(x,Z),this.isValid.setValue(!0,Z)}catch(u){this.isValid.setValue(!1,Z)}}}},14478:(Z,x,F)=>{F.d(x,{d:()=>G});var u=F(14476);class G extends u.c{constructor(Z,x,F,u,G){super(x,G),this._operation=F,this._className=u,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);