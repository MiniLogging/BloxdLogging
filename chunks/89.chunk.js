"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[89],{15701:(u,R,I)=>{I.r(R),I.d(R,{FlowGraphAngleBetweenBlock:()=>Y,FlowGraphAxisAngleFromQuaternionBlock:()=>o,FlowGraphConjugateBlock:()=>e,FlowGraphCrossBlock:()=>z,FlowGraphDotBlock:()=>E,FlowGraphLengthBlock:()=>P,FlowGraphNormalizeBlock:()=>X,FlowGraphQuaternionFromAxisAngleBlock:()=>M,FlowGraphQuaternionFromDirectionsBlock:()=>j,FlowGraphRotate2DBlock:()=>f,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>V,FlowGraphTransformCoordinatesBlock:()=>q});var B=I(14181),U=I(14160),K=I(12433),C=I(15687),D=I(15698),s=I(12481),t=I(14199),G=I(13855);const S="cachedOperationAxis",b="cachedOperationAngle",r="cachedExecutionId";class P extends D.e{constructor(u){super(U.c,U.u,(u=>this._polymorphicLength(u)),"FlowGraphLengthBlock",u)}_polymorphicLength(u){switch((0,t.k)(u)){case"Vector2":case"PR":case"Vector4":case"Quaternion":return u.length();default:throw new Error(`Cannot compute length of value ${u}`)}}}(0,K.e)("FlowGraphLengthBlock",P);class X extends D.e{constructor(u){super(U.c,U.c,(u=>this._polymorphicNormalize(u)),"FlowGraphNormalizeBlock",u)}_polymorphicNormalize(u){var R;let I;switch((0,t.k)(u)){case"Vector2":case"PR":case"Vector4":case"Quaternion":if(I=u.normalizeToNew(),null!==(R=this.config)&&void 0!==R&&R.nanOnZeroLength){0===u.length()&&I.fD(NaN)}return I;default:throw new Error(`Cannot normalize value ${u}`)}}}(0,K.e)("FlowGraphNormalizeBlock",X);class E extends C.b{constructor(u){super(U.c,U.c,U.u,((u,R)=>this._polymorphicDot(u,R)),"FlowGraphDotBlock",u)}_polymorphicDot(u,R){switch((0,t.k)(u)){case"Vector2":case"PR":case"Vector4":case"Quaternion":return u.dot(R);default:throw new Error(`Cannot get dot product of ${u} and ${R}`)}}}(0,K.e)("FlowGraphDotBlock",E);class z extends C.b{constructor(u){super(U.B,U.B,U.B,((u,R)=>s.PR.Cross(u,R)),"FlowGraphCrossBlock",u)}}(0,K.e)("FlowGraphCrossBlock",z);class f extends C.b{constructor(u){super(U.A,U.u,U.A,((u,R)=>u.rotate(R)),"FlowGraphRotate2DBlock",u)}}(0,K.e)("FlowGraphRotate2DBlock",f);class T extends C.b{constructor(u){super(U.B,U.w,U.B,((u,R)=>u.applyRotationQuaternion(R)),"FlowGraphRotate3DBlock",u)}}function Q(u,R){switch((0,t.k)(u)){case"Vector2":case"PR":return R.transformVector(u);case"Vector4":return new s.Vector4(u.x*R.m[0]+u.y*R.m[1]+u.z*R.m[2]+u.w*R.m[3],u.x*R.m[4]+u.y*R.m[5]+u.z*R.m[6]+u.w*R.m[7],u.x*R.m[8]+u.y*R.m[9]+u.z*R.m[10]+u.w*R.m[11],u.x*R.m[12]+u.y*R.m[13]+u.z*R.m[14]+u.w*R.m[15]);default:throw new Error(`Cannot transform value ${u}`)}}(0,K.e)("FlowGraphRotate3DBlock",T);class V extends C.b{constructor(u){const R=(null===u||void 0===u?void 0:u.vectorType)||"PR",I="Vector2"===R?"Matrix2D":"PR"===R?"Matrix3D":"Matrix";super((0,U.N)(R),(0,U.N)(I),(0,U.N)(R),Q,"FlowGraphTransformVectorBlock",u)}}(0,K.e)("FlowGraphTransformVectorBlock",V);class q extends C.b{constructor(u){super(U.B,U.m,U.B,((u,R)=>s.PR.TransformCoordinates(u,R)),"FlowGraphTransformCoordinatesBlock",u)}}(0,K.e)("FlowGraphTransformCoordinatesBlock",q);class e extends D.e{constructor(u){super(U.w,U.w,(u=>u.conjugate()),"FlowGraphConjugateBlock",u)}}(0,K.e)("FlowGraphConjugateBlock",e);class Y extends C.b{constructor(u){super(U.w,U.w,U.u,((u,R)=>(0,G.e)(u,R)),"FlowGraphAngleBetweenBlock",u)}}(0,K.e)("FlowGraphAngleBetweenBlock",Y);class M extends C.b{constructor(u){super(U.B,U.u,U.w,((u,R)=>s.Quaternion.RotationAxis(u,R)),"FlowGraphQuaternionFromAxisAngleBlock",u)}}(0,K.e)("FlowGraphQuaternionFromAxisAngleBlock",M);class o extends B.d{constructor(u){super(u),this.a=this.registerDataInput("a",U.w),this.axis=this.registerDataOutput("axis",U.B),this.angle=this.registerDataOutput("angle",U.u),this.isValid=this.registerDataOutput("isValid",U.g)}_updateOutputs(u){const R=u._getExecutionVariable(this,r,-1),I=u._getExecutionVariable(this,S,null),B=u._getExecutionVariable(this,b,null);if(void 0!==I&&null!==I&&void 0!==B&&null!==B&&R===u.executionId)this.axis.setValue(I,u),this.angle.setValue(B,u);else try{const{axis:R,angle:I}=this.a.getValue(u).toAxisAngle();u._setExecutionVariable(this,S,R),u._setExecutionVariable(this,b,I),u._setExecutionVariable(this,r,u.executionId),this.axis.setValue(R,u),this.angle.setValue(I,u),this.isValid.setValue(!0,u)}catch(U){this.isValid.setValue(!1,u)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,K.e)("FlowGraphAxisAngleFromQuaternionBlock",o);class j extends C.b{constructor(u){super(U.B,U.B,U.w,((u,R)=>(0,G.h)(u,R)),"FlowGraphQuaternionFromDirectionsBlock",u)}}},15687:(u,R,I)=>{I.d(R,{b:()=>U});var B=I(15694);class U extends B.e{constructor(u,R,I,B,U,K){super(I,K),this._operation=B,this._className=U,this.a=this.registerDataInput("a",u),this.b=this.registerDataInput("b",R)}_doOperation(u){const R=this.a.getValue(u),I=this.b.getValue(u);return this._operation(R,I)}getClassName(){return this._className}}},15694:(u,R,I)=>{I.d(R,{e:()=>D});var B=I(14181),U=I(14160);const K="cachedOperationValue",C="cachedExecutionId";class D extends B.d{constructor(u,R){super(R),this.value=this.registerDataOutput("value",u),this.isValid=this.registerDataOutput("isValid",U.g)}_updateOutputs(u){const R=u._getExecutionVariable(this,C,-1),I=u._getExecutionVariable(this,K,null);if(void 0!==I&&null!==I&&R===u.executionId)this.isValid.setValue(!0,u),this.value.setValue(I,u);else try{const R=this._doOperation(u);if(void 0===R||null===R)return void this.isValid.setValue(!1,u);u._setExecutionVariable(this,K,R),u._setExecutionVariable(this,C,u.executionId),this.value.setValue(R,u),this.isValid.setValue(!0,u)}catch(B){this.isValid.setValue(!1,u)}}}},15698:(u,R,I)=>{I.d(R,{e:()=>U});var B=I(15694);class U extends B.e{constructor(u,R,I,B,U){super(R,U),this._operation=I,this._className=B,this.a=this.registerDataInput("a",u)}_doOperation(u){return this._operation(this.a.getValue(u))}getClassName(){return this._className}}}}]);