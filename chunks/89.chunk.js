"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[89],{14346:(N,q,C)=>{C.r(q),C.d(q,{FlowGraphAngleBetweenBlock:()=>T,FlowGraphAxisAngleFromQuaternionBlock:()=>p,FlowGraphConjugateBlock:()=>l,FlowGraphCrossBlock:()=>r,FlowGraphDotBlock:()=>v,FlowGraphLengthBlock:()=>J,FlowGraphNormalizeBlock:()=>Q,FlowGraphQuaternionFromAxisAngleBlock:()=>z,FlowGraphQuaternionFromDirectionsBlock:()=>s,FlowGraphRotate2DBlock:()=>O,FlowGraphRotate3DBlock:()=>K,FlowGraphTransformBlock:()=>I,FlowGraphTransformCoordinatesBlock:()=>j});var d=C(12856),U=C(12831),W=C(11076),a=C(14327),F=C(14340),w=C(11122),A=C(12863),n=C(12515);const t="cachedOperationAxis",V="cachedOperationAngle",Z="cachedExecutionId";class J extends F.b{constructor(N){super(U.b,U.r,(N=>this._polymorphicLength(N)),"FlowGraphLengthBlock",N)}_polymorphicLength(N){switch((0,A.m)(N)){case"Vector2":case"Jq":case"Vector4":case"Quaternion":return N.length();default:throw new Error(`Cannot compute length of value ${N}`)}}}(0,W.h)("FlowGraphLengthBlock",J);class Q extends F.b{constructor(N){super(U.b,U.b,(N=>this._polymorphicNormalize(N)),"FlowGraphNormalizeBlock",N)}_polymorphicNormalize(N){var q;let C;switch((0,A.m)(N)){case"Vector2":case"Jq":case"Vector4":case"Quaternion":if(C=N.normalizeToNew(),null!==(q=this.config)&&void 0!==q&&q.nanOnZeroLength){0===N.length()&&C.Rd(NaN)}return C;default:throw new Error(`Cannot normalize value ${N}`)}}}(0,W.h)("FlowGraphNormalizeBlock",Q);class v extends a.c{constructor(N){super(U.b,U.b,U.r,((N,q)=>this._polymorphicDot(N,q)),"FlowGraphDotBlock",N)}_polymorphicDot(N,q){switch((0,A.m)(N)){case"Vector2":case"Jq":case"Vector4":case"Quaternion":return N.dot(q);default:throw new Error(`Cannot get dot product of ${N} and ${q}`)}}}(0,W.h)("FlowGraphDotBlock",v);class r extends a.c{constructor(N){super(U.A,U.A,U.A,((N,q)=>w.Jq.Cross(N,q)),"FlowGraphCrossBlock",N)}}(0,W.h)("FlowGraphCrossBlock",r);class O extends a.c{constructor(N){super(U.z,U.r,U.z,((N,q)=>N.rotate(q)),"FlowGraphRotate2DBlock",N)}}(0,W.h)("FlowGraphRotate2DBlock",O);class K extends a.c{constructor(N){super(U.A,U.v,U.A,((N,q)=>N.applyRotationQuaternion(q)),"FlowGraphRotate3DBlock",N)}}function i(N,q){switch((0,A.m)(N)){case"Vector2":case"Jq":return q.transformVector(N);case"Vector4":return new w.Vector4(N.x*q.m[0]+N.y*q.m[1]+N.z*q.m[2]+N.w*q.m[3],N.x*q.m[4]+N.y*q.m[5]+N.z*q.m[6]+N.w*q.m[7],N.x*q.m[8]+N.y*q.m[9]+N.z*q.m[10]+N.w*q.m[11],N.x*q.m[12]+N.y*q.m[13]+N.z*q.m[14]+N.w*q.m[15]);default:throw new Error(`Cannot transform value ${N}`)}}(0,W.h)("FlowGraphRotate3DBlock",K);class I extends a.c{constructor(N){const q=(null===N||void 0===N?void 0:N.vectorType)||"Jq",C="Vector2"===q?"Matrix2D":"Jq"===q?"Matrix3D":"Matrix";super((0,U.O)(q),(0,U.O)(C),(0,U.O)(q),i,"FlowGraphTransformVectorBlock",N)}}(0,W.h)("FlowGraphTransformVectorBlock",I);class j extends a.c{constructor(N){super(U.A,U.h,U.A,((N,q)=>w.Jq.TransformCoordinates(N,q)),"FlowGraphTransformCoordinatesBlock",N)}}(0,W.h)("FlowGraphTransformCoordinatesBlock",j);class l extends F.b{constructor(N){super(U.v,U.v,(N=>N.conjugate()),"FlowGraphConjugateBlock",N)}}(0,W.h)("FlowGraphConjugateBlock",l);class T extends a.c{constructor(N){super(U.v,U.v,U.r,((N,q)=>(0,n.c)(N,q)),"FlowGraphAngleBetweenBlock",N)}}(0,W.h)("FlowGraphAngleBetweenBlock",T);class z extends a.c{constructor(N){super(U.A,U.r,U.v,((N,q)=>w.Quaternion.RotationAxis(N,q)),"FlowGraphQuaternionFromAxisAngleBlock",N)}}(0,W.h)("FlowGraphQuaternionFromAxisAngleBlock",z);class p extends d.d{constructor(N){super(N),this.a=this.registerDataInput("a",U.v),this.axis=this.registerDataOutput("axis",U.A),this.angle=this.registerDataOutput("angle",U.r),this.isValid=this.registerDataOutput("isValid",U.e)}_updateOutputs(N){const q=N._getExecutionVariable(this,Z,-1),C=N._getExecutionVariable(this,t,null),d=N._getExecutionVariable(this,V,null);if(void 0!==C&&null!==C&&void 0!==d&&null!==d&&q===N.executionId)this.axis.setValue(C,N),this.angle.setValue(d,N);else try{const{axis:q,angle:C}=this.a.getValue(N).toAxisAngle();N._setExecutionVariable(this,t,q),N._setExecutionVariable(this,V,C),N._setExecutionVariable(this,Z,N.executionId),this.axis.setValue(q,N),this.angle.setValue(C,N),this.isValid.setValue(!0,N)}catch(U){this.isValid.setValue(!1,N)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,W.h)("FlowGraphAxisAngleFromQuaternionBlock",p);class s extends a.c{constructor(N){super(U.A,U.A,U.v,((N,q)=>(0,n.g)(N,q)),"FlowGraphQuaternionFromDirectionsBlock",N)}}},14327:(N,q,C)=>{C.d(q,{c:()=>U});var d=C(14333);class U extends d.e{constructor(N,q,C,d,U,W){super(C,W),this._operation=d,this._className=U,this.a=this.registerDataInput("a",N),this.b=this.registerDataInput("b",q)}_doOperation(N){const q=this.a.getValue(N),C=this.b.getValue(N);return this._operation(q,C)}getClassName(){return this._className}}},14333:(N,q,C)=>{C.d(q,{e:()=>F});var d=C(12856),U=C(12831);const W="cachedOperationValue",a="cachedExecutionId";class F extends d.d{constructor(N,q){super(q),this.value=this.registerDataOutput("value",N),this.isValid=this.registerDataOutput("isValid",U.e)}_updateOutputs(N){const q=N._getExecutionVariable(this,a,-1),C=N._getExecutionVariable(this,W,null);if(void 0!==C&&null!==C&&q===N.executionId)this.isValid.setValue(!0,N),this.value.setValue(C,N);else try{const q=this._doOperation(N);if(void 0===q||null===q)return void this.isValid.setValue(!1,N);N._setExecutionVariable(this,W,q),N._setExecutionVariable(this,a,N.executionId),this.value.setValue(q,N),this.isValid.setValue(!0,N)}catch(d){this.isValid.setValue(!1,N)}}}},14340:(N,q,C)=>{C.d(q,{b:()=>U});var d=C(14333);class U extends d.e{constructor(N,q,C,d,U){super(q,U),this._operation=C,this._className=d,this.a=this.registerDataInput("a",N)}_doOperation(N){return this._operation(this.a.getValue(N))}getClassName(){return this._className}}}}]);