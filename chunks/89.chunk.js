"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[89],{15379:(I,O,C)=>{C.r(O),C.d(O,{FlowGraphAngleBetweenBlock:()=>X,FlowGraphAxisAngleFromQuaternionBlock:()=>H,FlowGraphConjugateBlock:()=>n,FlowGraphCrossBlock:()=>h,FlowGraphDotBlock:()=>E,FlowGraphLengthBlock:()=>q,FlowGraphNormalizeBlock:()=>mI,FlowGraphQuaternionFromAxisAngleBlock:()=>T,FlowGraphQuaternionFromDirectionsBlock:()=>b,FlowGraphRotate2DBlock:()=>r,FlowGraphRotate3DBlock:()=>W,FlowGraphTransformBlock:()=>o,FlowGraphTransformCoordinatesBlock:()=>c});var j=C(13906),K=C(13886),i=C(12226),y=C(15361),S=C(15376),U=C(12272),p=C(13922),N=C(13552);const Q="cachedOperationAxis",s="cachedOperationAngle",Z="cachedExecutionId";class q extends S.c{constructor(I){super(K.d,K.u,(I=>this._polymorphicLength(I)),"FlowGraphLengthBlock",I)}_polymorphicLength(I){switch((0,p.m)(I)){case"Vector2":case"mC":case"Vector4":case"Quaternion":return I.length();default:throw new Error(`Cannot compute length of value ${I}`)}}}(0,i.e)("FlowGraphLengthBlock",q);class mI extends S.c{constructor(I){super(K.d,K.d,(I=>this._polymorphicNormalize(I)),"FlowGraphNormalizeBlock",I)}_polymorphicNormalize(I){var O;let C;switch((0,p.m)(I)){case"Vector2":case"mC":case"Vector4":case"Quaternion":if(C=I.normalizeToNew(),null!==(O=this.config)&&void 0!==O&&O.nanOnZeroLength){0===I.length()&&C.XS(NaN)}return C;default:throw new Error(`Cannot normalize value ${I}`)}}}(0,i.e)("FlowGraphNormalizeBlock",mI);class E extends y.b{constructor(I){super(K.d,K.d,K.u,((I,O)=>this._polymorphicDot(I,O)),"FlowGraphDotBlock",I)}_polymorphicDot(I,O){switch((0,p.m)(I)){case"Vector2":case"mC":case"Vector4":case"Quaternion":return I.dot(O);default:throw new Error(`Cannot get dot product of ${I} and ${O}`)}}}(0,i.e)("FlowGraphDotBlock",E);class h extends y.b{constructor(I){super(K.E,K.E,K.E,((I,O)=>U.mC.Cross(I,O)),"FlowGraphCrossBlock",I)}}(0,i.e)("FlowGraphCrossBlock",h);class r extends y.b{constructor(I){super(K.A,K.u,K.A,((I,O)=>I.rotate(O)),"FlowGraphRotate2DBlock",I)}}(0,i.e)("FlowGraphRotate2DBlock",r);class W extends y.b{constructor(I){super(K.E,K.x,K.E,((I,O)=>I.applyRotationQuaternion(O)),"FlowGraphRotate3DBlock",I)}}function Y(I,O){switch((0,p.m)(I)){case"Vector2":case"mC":return O.transformVector(I);case"Vector4":return new U.Vector4(I.x*O.m[0]+I.y*O.m[1]+I.z*O.m[2]+I.w*O.m[3],I.x*O.m[4]+I.y*O.m[5]+I.z*O.m[6]+I.w*O.m[7],I.x*O.m[8]+I.y*O.m[9]+I.z*O.m[10]+I.w*O.m[11],I.x*O.m[12]+I.y*O.m[13]+I.z*O.m[14]+I.w*O.m[15]);default:throw new Error(`Cannot transform value ${I}`)}}(0,i.e)("FlowGraphRotate3DBlock",W);class o extends y.b{constructor(I){const O=(null===I||void 0===I?void 0:I.vectorType)||"mC",C="Vector2"===O?"Matrix2D":"mC"===O?"Matrix3D":"Matrix";super((0,K.O)(O),(0,K.O)(C),(0,K.O)(O),Y,"FlowGraphTransformVectorBlock",I)}}(0,i.e)("FlowGraphTransformVectorBlock",o);class c extends y.b{constructor(I){super(K.E,K.i,K.E,((I,O)=>U.mC.TransformCoordinates(I,O)),"FlowGraphTransformCoordinatesBlock",I)}}(0,i.e)("FlowGraphTransformCoordinatesBlock",c);class n extends S.c{constructor(I){super(K.x,K.x,(I=>I.conjugate()),"FlowGraphConjugateBlock",I)}}(0,i.e)("FlowGraphConjugateBlock",n);class X extends y.b{constructor(I){super(K.x,K.x,K.u,((I,O)=>(0,N.b)(I,O)),"FlowGraphAngleBetweenBlock",I)}}(0,i.e)("FlowGraphAngleBetweenBlock",X);class T extends y.b{constructor(I){super(K.E,K.u,K.x,((I,O)=>U.Quaternion.RotationAxis(I,O)),"FlowGraphQuaternionFromAxisAngleBlock",I)}}(0,i.e)("FlowGraphQuaternionFromAxisAngleBlock",T);class H extends j.d{constructor(I){super(I),this.a=this.registerDataInput("a",K.x),this.axis=this.registerDataOutput("axis",K.E),this.angle=this.registerDataOutput("angle",K.u),this.isValid=this.registerDataOutput("isValid",K.g)}_updateOutputs(I){const O=I._getExecutionVariable(this,Z,-1),C=I._getExecutionVariable(this,Q,null),j=I._getExecutionVariable(this,s,null);if(void 0!==C&&null!==C&&void 0!==j&&null!==j&&O===I.executionId)this.axis.setValue(C,I),this.angle.setValue(j,I);else try{const{axis:O,angle:C}=this.a.getValue(I).toAxisAngle();I._setExecutionVariable(this,Q,O),I._setExecutionVariable(this,s,C),I._setExecutionVariable(this,Z,I.executionId),this.axis.setValue(O,I),this.angle.setValue(C,I),this.isValid.setValue(!0,I)}catch(K){this.isValid.setValue(!1,I)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,i.e)("FlowGraphAxisAngleFromQuaternionBlock",H);class b extends y.b{constructor(I){super(K.E,K.E,K.x,((I,O)=>(0,N.c)(I,O)),"FlowGraphQuaternionFromDirectionsBlock",I)}}},15361:(I,O,C)=>{C.d(O,{b:()=>K});var j=C(15369);class K extends j.e{constructor(I,O,C,j,K,i){super(C,i),this._operation=j,this._className=K,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",O)}_doOperation(I){const O=this.a.getValue(I),C=this.b.getValue(I);return this._operation(O,C)}getClassName(){return this._className}}},15369:(I,O,C)=>{C.d(O,{e:()=>S});var j=C(13906),K=C(13886);const i="cachedOperationValue",y="cachedExecutionId";class S extends j.d{constructor(I,O){super(O),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",K.g)}_updateOutputs(I){const O=I._getExecutionVariable(this,y,-1),C=I._getExecutionVariable(this,i,null);if(void 0!==C&&null!==C&&O===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(C,I);else try{const O=this._doOperation(I);if(void 0===O||null===O)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,i,O),I._setExecutionVariable(this,y,I.executionId),this.value.setValue(O,I),this.isValid.setValue(!0,I)}catch(j){this.isValid.setValue(!1,I)}}}},15376:(I,O,C)=>{C.d(O,{c:()=>K});var j=C(15369);class K extends j.e{constructor(I,O,C,j,K){super(O,K),this._operation=C,this._className=j,this.a=this.registerDataInput("a",I)}_doOperation(I){return this._operation(this.a.getValue(I))}getClassName(){return this._className}}}}]);