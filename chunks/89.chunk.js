"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[89],{14549:(k,Q,i)=>{i.r(Q),i.d(Q,{FlowGraphAngleBetweenBlock:()=>s,FlowGraphAxisAngleFromQuaternionBlock:()=>a,FlowGraphConjugateBlock:()=>L,FlowGraphCrossBlock:()=>l,FlowGraphDotBlock:()=>E,FlowGraphLengthBlock:()=>F,FlowGraphNormalizeBlock:()=>z,FlowGraphQuaternionFromAxisAngleBlock:()=>u,FlowGraphQuaternionFromDirectionsBlock:()=>j,FlowGraphRotate2DBlock:()=>h,FlowGraphRotate3DBlock:()=>c,FlowGraphTransformBlock:()=>Y,FlowGraphTransformCoordinatesBlock:()=>y});var Z=i(13084),U=i(13064),C=i(11253),B=i(14533),o=i(14543),m=i(11298),O=i(13096),J=i(12741);const G="cachedOperationAxis",H="cachedOperationAngle",e="cachedExecutionId";class F extends o.b{constructor(k){super(U.b,U.o,(k=>this._polymorphicLength(k)),"FlowGraphLengthBlock",k)}_polymorphicLength(k){switch((0,O.n)(k)){case"Vector2":case"zQ":case"Vector4":case"Quaternion":return k.length();default:throw new Error(`Cannot compute length of value ${k}`)}}}(0,C.e)("FlowGraphLengthBlock",F);class z extends o.b{constructor(k){super(U.b,U.b,(k=>this._polymorphicNormalize(k)),"FlowGraphNormalizeBlock",k)}_polymorphicNormalize(k){var Q;let i;switch((0,O.n)(k)){case"Vector2":case"zQ":case"Vector4":case"Quaternion":if(i=k.normalizeToNew(),null!==(Q=this.config)&&void 0!==Q&&Q.nanOnZeroLength){0===k.length()&&i.eo(NaN)}return i;default:throw new Error(`Cannot normalize value ${k}`)}}}(0,C.e)("FlowGraphNormalizeBlock",z);class E extends B.c{constructor(k){super(U.b,U.b,U.o,((k,Q)=>this._polymorphicDot(k,Q)),"FlowGraphDotBlock",k)}_polymorphicDot(k,Q){switch((0,O.n)(k)){case"Vector2":case"zQ":case"Vector4":case"Quaternion":return k.dot(Q);default:throw new Error(`Cannot get dot product of ${k} and ${Q}`)}}}(0,C.e)("FlowGraphDotBlock",E);class l extends B.c{constructor(k){super(U.C,U.C,U.C,((k,Q)=>m.zQ.Cross(k,Q)),"FlowGraphCrossBlock",k)}}(0,C.e)("FlowGraphCrossBlock",l);class h extends B.c{constructor(k){super(U.y,U.o,U.y,((k,Q)=>k.rotate(Q)),"FlowGraphRotate2DBlock",k)}}(0,C.e)("FlowGraphRotate2DBlock",h);class c extends B.c{constructor(k){super(U.C,U.s,U.C,((k,Q)=>k.applyRotationQuaternion(Q)),"FlowGraphRotate3DBlock",k)}}function f(k,Q){switch((0,O.n)(k)){case"Vector2":case"zQ":return Q.transformVector(k);case"Vector4":return new m.Vector4(k.x*Q.m[0]+k.y*Q.m[1]+k.z*Q.m[2]+k.w*Q.m[3],k.x*Q.m[4]+k.y*Q.m[5]+k.z*Q.m[6]+k.w*Q.m[7],k.x*Q.m[8]+k.y*Q.m[9]+k.z*Q.m[10]+k.w*Q.m[11],k.x*Q.m[12]+k.y*Q.m[13]+k.z*Q.m[14]+k.w*Q.m[15]);default:throw new Error(`Cannot transform value ${k}`)}}(0,C.e)("FlowGraphRotate3DBlock",c);class Y extends B.c{constructor(k){const Q=(null===k||void 0===k?void 0:k.vectorType)||"zQ",i="Vector2"===Q?"Matrix2D":"zQ"===Q?"Matrix3D":"Matrix";super((0,U.N)(Q),(0,U.N)(i),(0,U.N)(Q),f,"FlowGraphTransformVectorBlock",k)}}(0,C.e)("FlowGraphTransformVectorBlock",Y);class y extends B.c{constructor(k){super(U.C,U.j,U.C,((k,Q)=>m.zQ.TransformCoordinates(k,Q)),"FlowGraphTransformCoordinatesBlock",k)}}(0,C.e)("FlowGraphTransformCoordinatesBlock",y);class L extends o.b{constructor(k){super(U.s,U.s,(k=>k.conjugate()),"FlowGraphConjugateBlock",k)}}(0,C.e)("FlowGraphConjugateBlock",L);class s extends B.c{constructor(k){super(U.s,U.s,U.o,((k,Q)=>(0,J.e)(k,Q)),"FlowGraphAngleBetweenBlock",k)}}(0,C.e)("FlowGraphAngleBetweenBlock",s);class u extends B.c{constructor(k){super(U.C,U.o,U.s,((k,Q)=>m.Quaternion.RotationAxis(k,Q)),"FlowGraphQuaternionFromAxisAngleBlock",k)}}(0,C.e)("FlowGraphQuaternionFromAxisAngleBlock",u);class a extends Z.e{constructor(k){super(k),this.a=this.registerDataInput("a",U.s),this.axis=this.registerDataOutput("axis",U.C),this.angle=this.registerDataOutput("angle",U.o),this.isValid=this.registerDataOutput("isValid",U.f)}_updateOutputs(k){const Q=k._getExecutionVariable(this,e,-1),i=k._getExecutionVariable(this,G,null),Z=k._getExecutionVariable(this,H,null);if(void 0!==i&&null!==i&&void 0!==Z&&null!==Z&&Q===k.executionId)this.axis.setValue(i,k),this.angle.setValue(Z,k);else try{const{axis:Q,angle:i}=this.a.getValue(k).toAxisAngle();k._setExecutionVariable(this,G,Q),k._setExecutionVariable(this,H,i),k._setExecutionVariable(this,e,k.executionId),this.axis.setValue(Q,k),this.angle.setValue(i,k),this.isValid.setValue(!0,k)}catch(U){this.isValid.setValue(!1,k)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,C.e)("FlowGraphAxisAngleFromQuaternionBlock",a);class j extends B.c{constructor(k){super(U.C,U.C,U.s,((k,Q)=>(0,J.f)(k,Q)),"FlowGraphQuaternionFromDirectionsBlock",k)}}},14533:(k,Q,i)=>{i.d(Q,{c:()=>U});var Z=i(14536);class U extends Z.e{constructor(k,Q,i,Z,U,C){super(i,C),this._operation=Z,this._className=U,this.a=this.registerDataInput("a",k),this.b=this.registerDataInput("b",Q)}_doOperation(k){const Q=this.a.getValue(k),i=this.b.getValue(k);return this._operation(Q,i)}getClassName(){return this._className}}},14536:(k,Q,i)=>{i.d(Q,{e:()=>o});var Z=i(13084),U=i(13064);const C="cachedOperationValue",B="cachedExecutionId";class o extends Z.e{constructor(k,Q){super(Q),this.value=this.registerDataOutput("value",k),this.isValid=this.registerDataOutput("isValid",U.f)}_updateOutputs(k){const Q=k._getExecutionVariable(this,B,-1),i=k._getExecutionVariable(this,C,null);if(void 0!==i&&null!==i&&Q===k.executionId)this.isValid.setValue(!0,k),this.value.setValue(i,k);else try{const Q=this._doOperation(k);if(void 0===Q||null===Q)return void this.isValid.setValue(!1,k);k._setExecutionVariable(this,C,Q),k._setExecutionVariable(this,B,k.executionId),this.value.setValue(Q,k),this.isValid.setValue(!0,k)}catch(Z){this.isValid.setValue(!1,k)}}}},14543:(k,Q,i)=>{i.d(Q,{b:()=>U});var Z=i(14536);class U extends Z.e{constructor(k,Q,i,Z,U){super(Q,U),this._operation=i,this._className=Z,this.a=this.registerDataInput("a",k)}_doOperation(k){return this._operation(this.a.getValue(k))}getClassName(){return this._className}}}}]);