"use strict";(self.vfdo5lmva5i=self.vfdo5lmva5i||[]).push([[89],{15064:(w,o,H)=>{H.r(o),H.d(o,{FlowGraphAngleBetweenBlock:()=>T,FlowGraphAxisAngleFromQuaternionBlock:()=>c,FlowGraphConjugateBlock:()=>O,FlowGraphCrossBlock:()=>s,FlowGraphDotBlock:()=>i,FlowGraphLengthBlock:()=>Q,FlowGraphNormalizeBlock:()=>M,FlowGraphQuaternionFromAxisAngleBlock:()=>S,FlowGraphQuaternionFromDirectionsBlock:()=>W,FlowGraphRotate2DBlock:()=>V,FlowGraphRotate3DBlock:()=>r,FlowGraphTransformBlock:()=>P,FlowGraphTransformCoordinatesBlock:()=>l});var h=H(13475),E=H(13455),e=H(11666),D=H(15043),t=H(15059),X=H(11720),L=H(13486),A=H(13121);const y="cachedOperationAxis",z="cachedOperationAngle",C="cachedExecutionId";class Q extends t.d{constructor(w){super(E.e,E.p,(w=>this._polymorphicLength(w)),"FlowGraphLengthBlock",w)}_polymorphicLength(w){switch((0,L.i)(w)){case"Vector2":case"io":case"Vector4":case"Quaternion":return w.length();default:throw new Error(`Cannot compute length of value ${w}`)}}}(0,e.g)("FlowGraphLengthBlock",Q);class M extends t.d{constructor(w){super(E.e,E.e,(w=>this._polymorphicNormalize(w)),"FlowGraphNormalizeBlock",w)}_polymorphicNormalize(w){var o;let H;switch((0,L.i)(w)){case"Vector2":case"io":case"Vector4":case"Quaternion":if(H=w.normalizeToNew(),null!==(o=this.config)&&void 0!==o&&o.nanOnZeroLength){0===w.length()&&H.Ge(NaN)}return H;default:throw new Error(`Cannot normalize value ${w}`)}}}(0,e.g)("FlowGraphNormalizeBlock",M);class i extends D.b{constructor(w){super(E.e,E.e,E.p,((w,o)=>this._polymorphicDot(w,o)),"FlowGraphDotBlock",w)}_polymorphicDot(w,o){switch((0,L.i)(w)){case"Vector2":case"io":case"Vector4":case"Quaternion":return w.dot(o);default:throw new Error(`Cannot get dot product of ${w} and ${o}`)}}}(0,e.g)("FlowGraphDotBlock",i);class s extends D.b{constructor(w){super(E.y,E.y,E.y,((w,o)=>X.io.Cross(w,o)),"FlowGraphCrossBlock",w)}}(0,e.g)("FlowGraphCrossBlock",s);class V extends D.b{constructor(w){super(E.x,E.p,E.x,((w,o)=>w.rotate(o)),"FlowGraphRotate2DBlock",w)}}(0,e.g)("FlowGraphRotate2DBlock",V);class r extends D.b{constructor(w){super(E.y,E.q,E.y,((w,o)=>w.applyRotationQuaternion(o)),"FlowGraphRotate3DBlock",w)}}function k(w,o){switch((0,L.i)(w)){case"Vector2":case"io":return o.transformVector(w);case"Vector4":return new X.Vector4(w.x*o.m[0]+w.y*o.m[1]+w.z*o.m[2]+w.w*o.m[3],w.x*o.m[4]+w.y*o.m[5]+w.z*o.m[6]+w.w*o.m[7],w.x*o.m[8]+w.y*o.m[9]+w.z*o.m[10]+w.w*o.m[11],w.x*o.m[12]+w.y*o.m[13]+w.z*o.m[14]+w.w*o.m[15]);default:throw new Error(`Cannot transform value ${w}`)}}(0,e.g)("FlowGraphRotate3DBlock",r);class P extends D.b{constructor(w){const o=(null===w||void 0===w?void 0:w.vectorType)||"io",H="Vector2"===o?"Matrix2D":"io"===o?"Matrix3D":"Matrix";super((0,E.F)(o),(0,E.F)(H),(0,E.F)(o),k,"FlowGraphTransformVectorBlock",w)}}(0,e.g)("FlowGraphTransformVectorBlock",P);class l extends D.b{constructor(w){super(E.y,E.k,E.y,((w,o)=>X.io.TransformCoordinates(w,o)),"FlowGraphTransformCoordinatesBlock",w)}}(0,e.g)("FlowGraphTransformCoordinatesBlock",l);class O extends t.d{constructor(w){super(E.q,E.q,(w=>w.conjugate()),"FlowGraphConjugateBlock",w)}}(0,e.g)("FlowGraphConjugateBlock",O);class T extends D.b{constructor(w){super(E.q,E.q,E.p,((w,o)=>(0,A.d)(w,o)),"FlowGraphAngleBetweenBlock",w)}}(0,e.g)("FlowGraphAngleBetweenBlock",T);class S extends D.b{constructor(w){super(E.y,E.p,E.q,((w,o)=>X.Quaternion.RotationAxis(w,o)),"FlowGraphQuaternionFromAxisAngleBlock",w)}}(0,e.g)("FlowGraphQuaternionFromAxisAngleBlock",S);class c extends h.c{constructor(w){super(w),this.a=this.registerDataInput("a",E.q),this.axis=this.registerDataOutput("axis",E.y),this.angle=this.registerDataOutput("angle",E.p),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(w){const o=w._getExecutionVariable(this,C,-1),H=w._getExecutionVariable(this,y,null),h=w._getExecutionVariable(this,z,null);if(void 0!==H&&null!==H&&void 0!==h&&null!==h&&o===w.executionId)this.axis.setValue(H,w),this.angle.setValue(h,w);else try{const{axis:o,angle:H}=this.a.getValue(w).toAxisAngle();w._setExecutionVariable(this,y,o),w._setExecutionVariable(this,z,H),w._setExecutionVariable(this,C,w.executionId),this.axis.setValue(o,w),this.angle.setValue(H,w),this.isValid.setValue(!0,w)}catch(E){this.isValid.setValue(!1,w)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,e.g)("FlowGraphAxisAngleFromQuaternionBlock",c);class W extends D.b{constructor(w){super(E.y,E.y,E.q,((w,o)=>(0,A.f)(w,o)),"FlowGraphQuaternionFromDirectionsBlock",w)}}},15043:(w,o,H)=>{H.d(o,{b:()=>E});var h=H(15051);class E extends h.c{constructor(w,o,H,h,E,e){super(H,e),this._operation=h,this._className=E,this.a=this.registerDataInput("a",w),this.b=this.registerDataInput("b",o)}_doOperation(w){const o=this.a.getValue(w),H=this.b.getValue(w);return this._operation(o,H)}getClassName(){return this._className}}},15051:(w,o,H)=>{H.d(o,{c:()=>t});var h=H(13475),E=H(13455);const e="cachedOperationValue",D="cachedExecutionId";class t extends h.c{constructor(w,o){super(o),this.value=this.registerDataOutput("value",w),this.isValid=this.registerDataOutput("isValid",E.f)}_updateOutputs(w){const o=w._getExecutionVariable(this,D,-1),H=w._getExecutionVariable(this,e,null);if(void 0!==H&&null!==H&&o===w.executionId)this.isValid.setValue(!0,w),this.value.setValue(H,w);else try{const o=this._doOperation(w);if(void 0===o||null===o)return void this.isValid.setValue(!1,w);w._setExecutionVariable(this,e,o),w._setExecutionVariable(this,D,w.executionId),this.value.setValue(o,w),this.isValid.setValue(!0,w)}catch(h){this.isValid.setValue(!1,w)}}}},15059:(w,o,H)=>{H.d(o,{d:()=>E});var h=H(15051);class E extends h.c{constructor(w,o,H,h,E){super(o,E),this._operation=H,this._className=h,this.a=this.registerDataInput("a",w)}_doOperation(w){return this._operation(this.a.getValue(w))}getClassName(){return this._className}}}}]);