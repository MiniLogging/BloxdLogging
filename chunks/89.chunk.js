"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[89],{15553:(N,p,T)=>{T.r(p),T.d(p,{FlowGraphAngleBetweenBlock:()=>F,FlowGraphAxisAngleFromQuaternionBlock:()=>W,FlowGraphConjugateBlock:()=>K,FlowGraphCrossBlock:()=>L,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>k,FlowGraphNormalizeBlock:()=>x,FlowGraphQuaternionFromAxisAngleBlock:()=>v,FlowGraphQuaternionFromDirectionsBlock:()=>z,FlowGraphRotate2DBlock:()=>n,FlowGraphRotate3DBlock:()=>w,FlowGraphTransformBlock:()=>P,FlowGraphTransformCoordinatesBlock:()=>i});var A=T(14108),a=T(14082),C=T(12331),U=T(15532),X=T(15550),y=T(12371),e=T(14120),H=T(13779);const M="cachedOperationAxis",b="cachedOperationAngle",l="cachedExecutionId";class k extends X.e{constructor(N){super(a.d,a.r,(N=>this._polymorphicLength(N)),"FlowGraphLengthBlock",N)}_polymorphicLength(N){switch((0,e.n)(N)){case"Vector2":case"xp":case"Vector4":case"Quaternion":return N.length();default:throw new Error(`Cannot compute length of value ${N}`)}}}(0,C.d)("FlowGraphLengthBlock",k);class x extends X.e{constructor(N){super(a.d,a.d,(N=>this._polymorphicNormalize(N)),"FlowGraphNormalizeBlock",N)}_polymorphicNormalize(N){var p;let T;switch((0,e.n)(N)){case"Vector2":case"xp":case"Vector4":case"Quaternion":if(T=N.normalizeToNew(),null!==(p=this.config)&&void 0!==p&&p.nanOnZeroLength){0===N.length()&&T.IX(NaN)}return T;default:throw new Error(`Cannot normalize value ${N}`)}}}(0,C.d)("FlowGraphNormalizeBlock",x);class I extends U.b{constructor(N){super(a.d,a.d,a.r,((N,p)=>this._polymorphicDot(N,p)),"FlowGraphDotBlock",N)}_polymorphicDot(N,p){switch((0,e.n)(N)){case"Vector2":case"xp":case"Vector4":case"Quaternion":return N.dot(p);default:throw new Error(`Cannot get dot product of ${N} and ${p}`)}}}(0,C.d)("FlowGraphDotBlock",I);class L extends U.b{constructor(N){super(a.D,a.D,a.D,((N,p)=>y.xp.Cross(N,p)),"FlowGraphCrossBlock",N)}}(0,C.d)("FlowGraphCrossBlock",L);class n extends U.b{constructor(N){super(a.A,a.r,a.A,((N,p)=>N.rotate(p)),"FlowGraphRotate2DBlock",N)}}(0,C.d)("FlowGraphRotate2DBlock",n);class w extends U.b{constructor(N){super(a.D,a.v,a.D,((N,p)=>N.applyRotationQuaternion(p)),"FlowGraphRotate3DBlock",N)}}function g(N,p){switch((0,e.n)(N)){case"Vector2":case"xp":return p.transformVector(N);case"Vector4":return new y.Vector4(N.x*p.m[0]+N.y*p.m[1]+N.z*p.m[2]+N.w*p.m[3],N.x*p.m[4]+N.y*p.m[5]+N.z*p.m[6]+N.w*p.m[7],N.x*p.m[8]+N.y*p.m[9]+N.z*p.m[10]+N.w*p.m[11],N.x*p.m[12]+N.y*p.m[13]+N.z*p.m[14]+N.w*p.m[15]);default:throw new Error(`Cannot transform value ${N}`)}}(0,C.d)("FlowGraphRotate3DBlock",w);class P extends U.b{constructor(N){const p=(null===N||void 0===N?void 0:N.vectorType)||"xp",T="Vector2"===p?"Matrix2D":"xp"===p?"Matrix3D":"Matrix";super((0,a.K)(p),(0,a.K)(T),(0,a.K)(p),g,"FlowGraphTransformVectorBlock",N)}}(0,C.d)("FlowGraphTransformVectorBlock",P);class i extends U.b{constructor(N){super(a.D,a.i,a.D,((N,p)=>y.xp.TransformCoordinates(N,p)),"FlowGraphTransformCoordinatesBlock",N)}}(0,C.d)("FlowGraphTransformCoordinatesBlock",i);class K extends X.e{constructor(N){super(a.v,a.v,(N=>N.conjugate()),"FlowGraphConjugateBlock",N)}}(0,C.d)("FlowGraphConjugateBlock",K);class F extends U.b{constructor(N){super(a.v,a.v,a.r,((N,p)=>(0,H.b)(N,p)),"FlowGraphAngleBetweenBlock",N)}}(0,C.d)("FlowGraphAngleBetweenBlock",F);class v extends U.b{constructor(N){super(a.D,a.r,a.v,((N,p)=>y.Quaternion.RotationAxis(N,p)),"FlowGraphQuaternionFromAxisAngleBlock",N)}}(0,C.d)("FlowGraphQuaternionFromAxisAngleBlock",v);class W extends A.c{constructor(N){super(N),this.a=this.registerDataInput("a",a.v),this.axis=this.registerDataOutput("axis",a.D),this.angle=this.registerDataOutput("angle",a.r),this.isValid=this.registerDataOutput("isValid",a.g)}_updateOutputs(N){const p=N._getExecutionVariable(this,l,-1),T=N._getExecutionVariable(this,M,null),A=N._getExecutionVariable(this,b,null);if(void 0!==T&&null!==T&&void 0!==A&&null!==A&&p===N.executionId)this.axis.setValue(T,N),this.angle.setValue(A,N);else try{const{axis:p,angle:T}=this.a.getValue(N).toAxisAngle();N._setExecutionVariable(this,M,p),N._setExecutionVariable(this,b,T),N._setExecutionVariable(this,l,N.executionId),this.axis.setValue(p,N),this.angle.setValue(T,N),this.isValid.setValue(!0,N)}catch(a){this.isValid.setValue(!1,N)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,C.d)("FlowGraphAxisAngleFromQuaternionBlock",W);class z extends U.b{constructor(N){super(a.D,a.D,a.v,((N,p)=>(0,H.d)(N,p)),"FlowGraphQuaternionFromDirectionsBlock",N)}}},15532:(N,p,T)=>{T.d(p,{b:()=>a});var A=T(15541);class a extends A.d{constructor(N,p,T,A,a,C){super(T,C),this._operation=A,this._className=a,this.a=this.registerDataInput("a",N),this.b=this.registerDataInput("b",p)}_doOperation(N){const p=this.a.getValue(N),T=this.b.getValue(N);return this._operation(p,T)}getClassName(){return this._className}}},15541:(N,p,T)=>{T.d(p,{d:()=>X});var A=T(14108),a=T(14082);const C="cachedOperationValue",U="cachedExecutionId";class X extends A.c{constructor(N,p){super(p),this.value=this.registerDataOutput("value",N),this.isValid=this.registerDataOutput("isValid",a.g)}_updateOutputs(N){const p=N._getExecutionVariable(this,U,-1),T=N._getExecutionVariable(this,C,null);if(void 0!==T&&null!==T&&p===N.executionId)this.isValid.setValue(!0,N),this.value.setValue(T,N);else try{const p=this._doOperation(N);if(void 0===p||null===p)return void this.isValid.setValue(!1,N);N._setExecutionVariable(this,C,p),N._setExecutionVariable(this,U,N.executionId),this.value.setValue(p,N),this.isValid.setValue(!0,N)}catch(A){this.isValid.setValue(!1,N)}}}},15550:(N,p,T)=>{T.d(p,{e:()=>a});var A=T(15541);class a extends A.d{constructor(N,p,T,A,a){super(p,a),this._operation=T,this._className=A,this.a=this.registerDataInput("a",N)}_doOperation(N){return this._operation(this.a.getValue(N))}getClassName(){return this._className}}}}]);