"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[89],{15030:(Z,h,V)=>{V.r(h),V.d(h,{FlowGraphAngleBetweenBlock:()=>l,FlowGraphAxisAngleFromQuaternionBlock:()=>S,FlowGraphConjugateBlock:()=>C,FlowGraphCrossBlock:()=>o,FlowGraphDotBlock:()=>b,FlowGraphLengthBlock:()=>u,FlowGraphNormalizeBlock:()=>F,FlowGraphQuaternionFromAxisAngleBlock:()=>B,FlowGraphQuaternionFromDirectionsBlock:()=>r,FlowGraphRotate2DBlock:()=>q,FlowGraphRotate3DBlock:()=>X,FlowGraphTransformBlock:()=>j,FlowGraphTransformCoordinatesBlock:()=>P});var v=V(13480),A=V(13459),H=V(11691),K=V(15012),d=V(15024),a=V(11729),n=V(13491),x=V(13144);const N="cachedOperationAxis",D="cachedOperationAngle",k="cachedExecutionId";class u extends d.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicLength(Z)),"FlowGraphLengthBlock",Z)}_polymorphicLength(Z){switch((0,n.l)(Z)){case"Vector2":case"Ch":case"Vector4":case"Quaternion":return Z.length();default:throw new Error(`Cannot compute length of value ${Z}`)}}}(0,H.i)("FlowGraphLengthBlock",u);class F extends d.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicNormalize(Z)),"FlowGraphNormalizeBlock",Z)}_polymorphicNormalize(Z){var h;let V;switch((0,n.l)(Z)){case"Vector2":case"Ch":case"Vector4":case"Quaternion":if(V=Z.normalizeToNew(),null!==(h=this.config)&&void 0!==h&&h.nanOnZeroLength){0===Z.length()&&V.vd(NaN)}return V;default:throw new Error(`Cannot normalize value ${Z}`)}}}(0,H.i)("FlowGraphNormalizeBlock",F);class b extends K.d{constructor(Z){super(A.c,A.c,A.t,((Z,h)=>this._polymorphicDot(Z,h)),"FlowGraphDotBlock",Z)}_polymorphicDot(Z,h){switch((0,n.l)(Z)){case"Vector2":case"Ch":case"Vector4":case"Quaternion":return Z.dot(h);default:throw new Error(`Cannot get dot product of ${Z} and ${h}`)}}}(0,H.i)("FlowGraphDotBlock",b);class o extends K.d{constructor(Z){super(A.G,A.G,A.G,((Z,h)=>a.Ch.Cross(Z,h)),"FlowGraphCrossBlock",Z)}}(0,H.i)("FlowGraphCrossBlock",o);class q extends K.d{constructor(Z){super(A.C,A.t,A.C,((Z,h)=>Z.rotate(h)),"FlowGraphRotate2DBlock",Z)}}(0,H.i)("FlowGraphRotate2DBlock",q);class X extends K.d{constructor(Z){super(A.G,A.x,A.G,((Z,h)=>Z.applyRotationQuaternion(h)),"FlowGraphRotate3DBlock",Z)}}function E(Z,h){switch((0,n.l)(Z)){case"Vector2":case"Ch":return h.transformVector(Z);case"Vector4":return new a.Vector4(Z.x*h.m[0]+Z.y*h.m[1]+Z.z*h.m[2]+Z.w*h.m[3],Z.x*h.m[4]+Z.y*h.m[5]+Z.z*h.m[6]+Z.w*h.m[7],Z.x*h.m[8]+Z.y*h.m[9]+Z.z*h.m[10]+Z.w*h.m[11],Z.x*h.m[12]+Z.y*h.m[13]+Z.z*h.m[14]+Z.w*h.m[15]);default:throw new Error(`Cannot transform value ${Z}`)}}(0,H.i)("FlowGraphRotate3DBlock",X);class j extends K.d{constructor(Z){const h=(null===Z||void 0===Z?void 0:Z.vectorType)||"Ch",V="Vector2"===h?"Matrix2D":"Ch"===h?"Matrix3D":"Matrix";super((0,A.S)(h),(0,A.S)(V),(0,A.S)(h),E,"FlowGraphTransformVectorBlock",Z)}}(0,H.i)("FlowGraphTransformVectorBlock",j);class P extends K.d{constructor(Z){super(A.G,A.k,A.G,((Z,h)=>a.Ch.TransformCoordinates(Z,h)),"FlowGraphTransformCoordinatesBlock",Z)}}(0,H.i)("FlowGraphTransformCoordinatesBlock",P);class C extends d.e{constructor(Z){super(A.x,A.x,(Z=>Z.conjugate()),"FlowGraphConjugateBlock",Z)}}(0,H.i)("FlowGraphConjugateBlock",C);class l extends K.d{constructor(Z){super(A.x,A.x,A.t,((Z,h)=>(0,x.c)(Z,h)),"FlowGraphAngleBetweenBlock",Z)}}(0,H.i)("FlowGraphAngleBetweenBlock",l);class B extends K.d{constructor(Z){super(A.G,A.t,A.x,((Z,h)=>a.Quaternion.RotationAxis(Z,h)),"FlowGraphQuaternionFromAxisAngleBlock",Z)}}(0,H.i)("FlowGraphQuaternionFromAxisAngleBlock",B);class S extends v.d{constructor(Z){super(Z),this.a=this.registerDataInput("a",A.x),this.axis=this.registerDataOutput("axis",A.G),this.angle=this.registerDataOutput("angle",A.t),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(Z){const h=Z._getExecutionVariable(this,k,-1),V=Z._getExecutionVariable(this,N,null),v=Z._getExecutionVariable(this,D,null);if(void 0!==V&&null!==V&&void 0!==v&&null!==v&&h===Z.executionId)this.axis.setValue(V,Z),this.angle.setValue(v,Z);else try{const{axis:h,angle:V}=this.a.getValue(Z).toAxisAngle();Z._setExecutionVariable(this,N,h),Z._setExecutionVariable(this,D,V),Z._setExecutionVariable(this,k,Z.executionId),this.axis.setValue(h,Z),this.angle.setValue(V,Z),this.isValid.setValue(!0,Z)}catch(A){this.isValid.setValue(!1,Z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,H.i)("FlowGraphAxisAngleFromQuaternionBlock",S);class r extends K.d{constructor(Z){super(A.G,A.G,A.x,((Z,h)=>(0,x.d)(Z,h)),"FlowGraphQuaternionFromDirectionsBlock",Z)}}},15012:(Z,h,V)=>{V.d(h,{d:()=>A});var v=V(15015);class A extends v.c{constructor(Z,h,V,v,A,H){super(V,H),this._operation=v,this._className=A,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",h)}_doOperation(Z){const h=this.a.getValue(Z),V=this.b.getValue(Z);return this._operation(h,V)}getClassName(){return this._className}}},15015:(Z,h,V)=>{V.d(h,{c:()=>d});var v=V(13480),A=V(13459);const H="cachedOperationValue",K="cachedExecutionId";class d extends v.d{constructor(Z,h){super(h),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(Z){const h=Z._getExecutionVariable(this,K,-1),V=Z._getExecutionVariable(this,H,null);if(void 0!==V&&null!==V&&h===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(V,Z);else try{const h=this._doOperation(Z);if(void 0===h||null===h)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,H,h),Z._setExecutionVariable(this,K,Z.executionId),this.value.setValue(h,Z),this.isValid.setValue(!0,Z)}catch(v){this.isValid.setValue(!1,Z)}}}},15024:(Z,h,V)=>{V.d(h,{e:()=>A});var v=V(15015);class A extends v.c{constructor(Z,h,V,v,A){super(h,A),this._operation=V,this._className=v,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);