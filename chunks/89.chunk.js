"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[89],{15680:(U,G,C)=>{C.r(G),C.d(G,{FlowGraphAngleBetweenBlock:()=>S,FlowGraphAxisAngleFromQuaternionBlock:()=>u,FlowGraphConjugateBlock:()=>w,FlowGraphCrossBlock:()=>H,FlowGraphDotBlock:()=>I,FlowGraphLengthBlock:()=>V,FlowGraphNormalizeBlock:()=>p,FlowGraphQuaternionFromAxisAngleBlock:()=>v,FlowGraphQuaternionFromDirectionsBlock:()=>d,FlowGraphRotate2DBlock:()=>x,FlowGraphRotate3DBlock:()=>h,FlowGraphTransformBlock:()=>b,FlowGraphTransformCoordinatesBlock:()=>o});var L=C(14154),X=C(14134),l=C(12850),t=C(15666),E=C(15674),K=C(12896),P=C(14166),O=C(13845);const T="cachedOperationAxis",D="cachedOperationAngle",y="cachedExecutionId";class V extends E.b{constructor(U){super(X.c,X.y,(U=>this._polymorphicLength(U)),"FlowGraphLengthBlock",U)}_polymorphicLength(U){switch((0,P.g)(U)){case"Vector2":case"pG":case"Vector4":case"Quaternion":return U.length();default:throw new Error("Cannot compute length of value ".concat(U))}}}(0,l.e)("FlowGraphLengthBlock",V);class p extends E.b{constructor(U){super(X.c,X.c,(U=>this._polymorphicNormalize(U)),"FlowGraphNormalizeBlock",U)}_polymorphicNormalize(U){var G;let C;switch((0,P.g)(U)){case"Vector2":case"pG":case"Vector4":case"Quaternion":if(C=U.normalizeToNew(),null!==(G=this.config)&&void 0!==G&&G.nanOnZeroLength){0===U.length()&&C.rE(NaN)}return C;default:throw new Error("Cannot normalize value ".concat(U))}}}(0,l.e)("FlowGraphNormalizeBlock",p);class I extends t.d{constructor(U){super(X.c,X.c,X.y,((U,G)=>this._polymorphicDot(U,G)),"FlowGraphDotBlock",U)}_polymorphicDot(U,G){switch((0,P.g)(U)){case"Vector2":case"pG":case"Vector4":case"Quaternion":return U.dot(G);default:throw new Error("Cannot get dot product of ".concat(U," and ").concat(G))}}}(0,l.e)("FlowGraphDotBlock",I);class H extends t.d{constructor(U){super(X.J,X.J,X.J,((U,G)=>K.pG.Cross(U,G)),"FlowGraphCrossBlock",U)}}(0,l.e)("FlowGraphCrossBlock",H);class x extends t.d{constructor(U){super(X.H,X.y,X.H,((U,G)=>U.rotate(G)),"FlowGraphRotate2DBlock",U)}}(0,l.e)("FlowGraphRotate2DBlock",x);class h extends t.d{constructor(U){super(X.J,X.C,X.J,((U,G)=>U.applyRotationQuaternion(G)),"FlowGraphRotate3DBlock",U)}}function N(U,G){switch((0,P.g)(U)){case"Vector2":case"pG":return G.transformVector(U);case"Vector4":return new K.Vector4(U.x*G.m[0]+U.y*G.m[1]+U.z*G.m[2]+U.w*G.m[3],U.x*G.m[4]+U.y*G.m[5]+U.z*G.m[6]+U.w*G.m[7],U.x*G.m[8]+U.y*G.m[9]+U.z*G.m[10]+U.w*G.m[11],U.x*G.m[12]+U.y*G.m[13]+U.z*G.m[14]+U.w*G.m[15]);default:throw new Error("Cannot transform value ".concat(U))}}(0,l.e)("FlowGraphRotate3DBlock",h);class b extends t.d{constructor(U){const G=(null===U||void 0===U?void 0:U.vectorType)||"pG",C="Vector2"===G?"Matrix2D":"pG"===G?"Matrix3D":"Matrix";super((0,X.V)(G),(0,X.V)(C),(0,X.V)(G),N,"FlowGraphTransformVectorBlock",U)}}(0,l.e)("FlowGraphTransformVectorBlock",b);class o extends t.d{constructor(U){super(X.J,X.o,X.J,((U,G)=>K.pG.TransformCoordinates(U,G)),"FlowGraphTransformCoordinatesBlock",U)}}(0,l.e)("FlowGraphTransformCoordinatesBlock",o);class w extends E.b{constructor(U){super(X.C,X.C,(U=>U.conjugate()),"FlowGraphConjugateBlock",U)}}(0,l.e)("FlowGraphConjugateBlock",w);class S extends t.d{constructor(U){super(X.C,X.C,X.y,((U,G)=>(0,O.b)(U,G)),"FlowGraphAngleBetweenBlock",U)}}(0,l.e)("FlowGraphAngleBetweenBlock",S);class v extends t.d{constructor(U){super(X.J,X.y,X.C,((U,G)=>K.Quaternion.RotationAxis(U,G)),"FlowGraphQuaternionFromAxisAngleBlock",U)}}(0,l.e)("FlowGraphQuaternionFromAxisAngleBlock",v);class u extends L.b{constructor(U){super(U),this.a=this.registerDataInput("a",X.C),this.axis=this.registerDataOutput("axis",X.J),this.angle=this.registerDataOutput("angle",X.y),this.isValid=this.registerDataOutput("isValid",X.g)}_updateOutputs(U){const G=U._getExecutionVariable(this,y,-1),C=U._getExecutionVariable(this,T,null),L=U._getExecutionVariable(this,D,null);if(void 0!==C&&null!==C&&void 0!==L&&null!==L&&G===U.executionId)this.axis.setValue(C,U),this.angle.setValue(L,U);else try{const{axis:G,angle:C}=this.a.getValue(U).toAxisAngle();U._setExecutionVariable(this,T,G),U._setExecutionVariable(this,D,C),U._setExecutionVariable(this,y,U.executionId),this.axis.setValue(G,U),this.angle.setValue(C,U),this.isValid.setValue(!0,U)}catch(X){this.isValid.setValue(!1,U)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,l.e)("FlowGraphAxisAngleFromQuaternionBlock",u);class d extends t.d{constructor(U){super(X.J,X.J,X.C,((U,G)=>(0,O.c)(U,G)),"FlowGraphQuaternionFromDirectionsBlock",U)}}},15666:(U,G,C)=>{C.d(G,{d:()=>X});var L=C(15668);class X extends L.c{constructor(U,G,C,L,X,l){super(C,l),this._operation=L,this._className=X,this.a=this.registerDataInput("a",U),this.b=this.registerDataInput("b",G)}_doOperation(U){const G=this.a.getValue(U),C=this.b.getValue(U);return this._operation(G,C)}getClassName(){return this._className}}},15668:(U,G,C)=>{C.d(G,{c:()=>E});var L=C(14154),X=C(14134);const l="cachedOperationValue",t="cachedExecutionId";class E extends L.b{constructor(U,G){super(G),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",X.g)}_updateOutputs(U){const G=U._getExecutionVariable(this,t,-1),C=U._getExecutionVariable(this,l,null);if(void 0!==C&&null!==C&&G===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(C,U);else try{const G=this._doOperation(U);if(void 0===G||null===G)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,l,G),U._setExecutionVariable(this,t,U.executionId),this.value.setValue(G,U),this.isValid.setValue(!0,U)}catch(L){this.isValid.setValue(!1,U)}}}},15674:(U,G,C)=>{C.d(G,{b:()=>X});var L=C(15668);class X extends L.c{constructor(U,G,C,L,X){super(G,X),this._operation=C,this._className=L,this.a=this.registerDataInput("a",U)}_doOperation(U){return this._operation(this.a.getValue(U))}getClassName(){return this._className}}}}]);