"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[89],{14484:(F,b,Q)=>{Q.r(b),Q.d(b,{FlowGraphAngleBetweenBlock:()=>p,FlowGraphAxisAngleFromQuaternionBlock:()=>P,FlowGraphConjugateBlock:()=>R,FlowGraphCrossBlock:()=>X,FlowGraphDotBlock:()=>c,FlowGraphLengthBlock:()=>y,FlowGraphNormalizeBlock:()=>E,FlowGraphQuaternionFromAxisAngleBlock:()=>D,FlowGraphQuaternionFromDirectionsBlock:()=>n,FlowGraphRotate2DBlock:()=>L,FlowGraphRotate3DBlock:()=>i,FlowGraphTransformBlock:()=>k,FlowGraphTransformCoordinatesBlock:()=>m});var C=Q(12972),z=Q(12951),t=Q(11265),g=Q(14467),W=Q(14476),Z=Q(11309),q=Q(12985),G=Q(12659);const K="cachedOperationAxis",e="cachedOperationAngle",N="cachedExecutionId";class y extends W.d{constructor(F){super(z.b,z.m,(F=>this._polymorphicLength(F)),"FlowGraphLengthBlock",F)}_polymorphicLength(F){switch((0,q.j)(F)){case"Vector2":case"gQ":case"Vector4":case"Quaternion":return F.length();default:throw new Error(`Cannot compute length of value ${F}`)}}}(0,t.g)("FlowGraphLengthBlock",y);class E extends W.d{constructor(F){super(z.b,z.b,(F=>this._polymorphicNormalize(F)),"FlowGraphNormalizeBlock",F)}_polymorphicNormalize(F){var b;let Q;switch((0,q.j)(F)){case"Vector2":case"gQ":case"Vector4":case"Quaternion":if(Q=F.normalizeToNew(),null!==(b=this.config)&&void 0!==b&&b.nanOnZeroLength){0===F.length()&&Q.Yb(NaN)}return Q;default:throw new Error(`Cannot normalize value ${F}`)}}}(0,t.g)("FlowGraphNormalizeBlock",E);class c extends g.e{constructor(F){super(z.b,z.b,z.m,((F,b)=>this._polymorphicDot(F,b)),"FlowGraphDotBlock",F)}_polymorphicDot(F,b){switch((0,q.j)(F)){case"Vector2":case"gQ":case"Vector4":case"Quaternion":return F.dot(b);default:throw new Error(`Cannot get dot product of ${F} and ${b}`)}}}(0,t.g)("FlowGraphDotBlock",c);class X extends g.e{constructor(F){super(z.t,z.t,z.t,((F,b)=>Z.gQ.Cross(F,b)),"FlowGraphCrossBlock",F)}}(0,t.g)("FlowGraphCrossBlock",X);class L extends g.e{constructor(F){super(z.r,z.m,z.r,((F,b)=>F.rotate(b)),"FlowGraphRotate2DBlock",F)}}(0,t.g)("FlowGraphRotate2DBlock",L);class i extends g.e{constructor(F){super(z.t,z.n,z.t,((F,b)=>F.applyRotationQuaternion(b)),"FlowGraphRotate3DBlock",F)}}function f(F,b){switch((0,q.j)(F)){case"Vector2":case"gQ":return b.transformVector(F);case"Vector4":return new Z.Vector4(F.x*b.m[0]+F.y*b.m[1]+F.z*b.m[2]+F.w*b.m[3],F.x*b.m[4]+F.y*b.m[5]+F.z*b.m[6]+F.w*b.m[7],F.x*b.m[8]+F.y*b.m[9]+F.z*b.m[10]+F.w*b.m[11],F.x*b.m[12]+F.y*b.m[13]+F.z*b.m[14]+F.w*b.m[15]);default:throw new Error(`Cannot transform value ${F}`)}}(0,t.g)("FlowGraphRotate3DBlock",i);class k extends g.e{constructor(F){const b=(null===F||void 0===F?void 0:F.vectorType)||"gQ",Q="Vector2"===b?"Matrix2D":"gQ"===b?"Matrix3D":"Matrix";super((0,z.F)(b),(0,z.F)(Q),(0,z.F)(b),f,"FlowGraphTransformVectorBlock",F)}}(0,t.g)("FlowGraphTransformVectorBlock",k);class m extends g.e{constructor(F){super(z.t,z.j,z.t,((F,b)=>Z.gQ.TransformCoordinates(F,b)),"FlowGraphTransformCoordinatesBlock",F)}}(0,t.g)("FlowGraphTransformCoordinatesBlock",m);class R extends W.d{constructor(F){super(z.n,z.n,(F=>F.conjugate()),"FlowGraphConjugateBlock",F)}}(0,t.g)("FlowGraphConjugateBlock",R);class p extends g.e{constructor(F){super(z.n,z.n,z.m,((F,b)=>(0,G.d)(F,b)),"FlowGraphAngleBetweenBlock",F)}}(0,t.g)("FlowGraphAngleBetweenBlock",p);class D extends g.e{constructor(F){super(z.t,z.m,z.n,((F,b)=>Z.Quaternion.RotationAxis(F,b)),"FlowGraphQuaternionFromAxisAngleBlock",F)}}(0,t.g)("FlowGraphQuaternionFromAxisAngleBlock",D);class P extends C.b{constructor(F){super(F),this.a=this.registerDataInput("a",z.n),this.axis=this.registerDataOutput("axis",z.t),this.angle=this.registerDataOutput("angle",z.m),this.isValid=this.registerDataOutput("isValid",z.e)}_updateOutputs(F){const b=F._getExecutionVariable(this,N,-1),Q=F._getExecutionVariable(this,K,null),C=F._getExecutionVariable(this,e,null);if(void 0!==Q&&null!==Q&&void 0!==C&&null!==C&&b===F.executionId)this.axis.setValue(Q,F),this.angle.setValue(C,F);else try{const{axis:b,angle:Q}=this.a.getValue(F).toAxisAngle();F._setExecutionVariable(this,K,b),F._setExecutionVariable(this,e,Q),F._setExecutionVariable(this,N,F.executionId),this.axis.setValue(b,F),this.angle.setValue(Q,F),this.isValid.setValue(!0,F)}catch(z){this.isValid.setValue(!1,F)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,t.g)("FlowGraphAxisAngleFromQuaternionBlock",P);class n extends g.e{constructor(F){super(z.t,z.t,z.n,((F,b)=>(0,G.h)(F,b)),"FlowGraphQuaternionFromDirectionsBlock",F)}}},14467:(F,b,Q)=>{Q.d(b,{e:()=>z});var C=Q(14472);class z extends C.b{constructor(F,b,Q,C,z,t){super(Q,t),this._operation=C,this._className=z,this.a=this.registerDataInput("a",F),this.b=this.registerDataInput("b",b)}_doOperation(F){const b=this.a.getValue(F),Q=this.b.getValue(F);return this._operation(b,Q)}getClassName(){return this._className}}},14472:(F,b,Q)=>{Q.d(b,{b:()=>W});var C=Q(12972),z=Q(12951);const t="cachedOperationValue",g="cachedExecutionId";class W extends C.b{constructor(F,b){super(b),this.value=this.registerDataOutput("value",F),this.isValid=this.registerDataOutput("isValid",z.e)}_updateOutputs(F){const b=F._getExecutionVariable(this,g,-1),Q=F._getExecutionVariable(this,t,null);if(void 0!==Q&&null!==Q&&b===F.executionId)this.isValid.setValue(!0,F),this.value.setValue(Q,F);else try{const b=this._doOperation(F);if(void 0===b||null===b)return void this.isValid.setValue(!1,F);F._setExecutionVariable(this,t,b),F._setExecutionVariable(this,g,F.executionId),this.value.setValue(b,F),this.isValid.setValue(!0,F)}catch(C){this.isValid.setValue(!1,F)}}}},14476:(F,b,Q)=>{Q.d(b,{d:()=>z});var C=Q(14472);class z extends C.b{constructor(F,b,Q,C,z){super(b,z),this._operation=Q,this._className=C,this.a=this.registerDataInput("a",F)}_doOperation(F){return this._operation(this.a.getValue(F))}getClassName(){return this._className}}}}]);