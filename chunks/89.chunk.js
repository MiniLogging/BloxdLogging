"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[89],{14845:(U,X,b)=>{b.r(X),b.d(X,{FlowGraphAngleBetweenBlock:()=>j,FlowGraphAxisAngleFromQuaternionBlock:()=>l,FlowGraphConjugateBlock:()=>f,FlowGraphCrossBlock:()=>I,FlowGraphDotBlock:()=>x,FlowGraphLengthBlock:()=>J,FlowGraphNormalizeBlock:()=>m,FlowGraphQuaternionFromAxisAngleBlock:()=>e,FlowGraphQuaternionFromDirectionsBlock:()=>d,FlowGraphRotate2DBlock:()=>O,FlowGraphRotate3DBlock:()=>N,FlowGraphTransformBlock:()=>i,FlowGraphTransformCoordinatesBlock:()=>P});var F=b(13308),E=b(13281),w=b(11551),Q=b(14828),z=b(14838),q=b(11593),p=b(13315),S=b(12976);const R="cachedOperationAxis",n="cachedOperationAngle",a="cachedExecutionId";class J extends z.b{constructor(U){super(E.b,E.s,(U=>this._polymorphicLength(U)),"FlowGraphLengthBlock",U)}_polymorphicLength(U){switch((0,p.j)(U)){case"Vector2":case"JX":case"Vector4":case"Quaternion":return U.length();default:throw new Error(`Cannot compute length of value ${U}`)}}}(0,w.f)("FlowGraphLengthBlock",J);class m extends z.b{constructor(U){super(E.b,E.b,(U=>this._polymorphicNormalize(U)),"FlowGraphNormalizeBlock",U)}_polymorphicNormalize(U){var X;let b;switch((0,p.j)(U)){case"Vector2":case"JX":case"Vector4":case"Quaternion":if(b=U.normalizeToNew(),null!==(X=this.config)&&void 0!==X&&X.nanOnZeroLength){0===U.length()&&b.jb(NaN)}return b;default:throw new Error(`Cannot normalize value ${U}`)}}}(0,w.f)("FlowGraphNormalizeBlock",m);class x extends Q.d{constructor(U){super(E.b,E.b,E.s,((U,X)=>this._polymorphicDot(U,X)),"FlowGraphDotBlock",U)}_polymorphicDot(U,X){switch((0,p.j)(U)){case"Vector2":case"JX":case"Vector4":case"Quaternion":return U.dot(X);default:throw new Error(`Cannot get dot product of ${U} and ${X}`)}}}(0,w.f)("FlowGraphDotBlock",x);class I extends Q.d{constructor(U){super(E.C,E.C,E.C,((U,X)=>q.JX.Cross(U,X)),"FlowGraphCrossBlock",U)}}(0,w.f)("FlowGraphCrossBlock",I);class O extends Q.d{constructor(U){super(E.A,E.s,E.A,((U,X)=>U.rotate(X)),"FlowGraphRotate2DBlock",U)}}(0,w.f)("FlowGraphRotate2DBlock",O);class N extends Q.d{constructor(U){super(E.C,E.w,E.C,((U,X)=>U.applyRotationQuaternion(X)),"FlowGraphRotate3DBlock",U)}}function u(U,X){switch((0,p.j)(U)){case"Vector2":case"JX":return X.transformVector(U);case"Vector4":return new q.Vector4(U.x*X.m[0]+U.y*X.m[1]+U.z*X.m[2]+U.w*X.m[3],U.x*X.m[4]+U.y*X.m[5]+U.z*X.m[6]+U.w*X.m[7],U.x*X.m[8]+U.y*X.m[9]+U.z*X.m[10]+U.w*X.m[11],U.x*X.m[12]+U.y*X.m[13]+U.z*X.m[14]+U.w*X.m[15]);default:throw new Error(`Cannot transform value ${U}`)}}(0,w.f)("FlowGraphRotate3DBlock",N);class i extends Q.d{constructor(U){const X=(null===U||void 0===U?void 0:U.vectorType)||"JX",b="Vector2"===X?"Matrix2D":"JX"===X?"Matrix3D":"Matrix";super((0,E.L)(X),(0,E.L)(b),(0,E.L)(X),u,"FlowGraphTransformVectorBlock",U)}}(0,w.f)("FlowGraphTransformVectorBlock",i);class P extends Q.d{constructor(U){super(E.C,E.l,E.C,((U,X)=>q.JX.TransformCoordinates(U,X)),"FlowGraphTransformCoordinatesBlock",U)}}(0,w.f)("FlowGraphTransformCoordinatesBlock",P);class f extends z.b{constructor(U){super(E.w,E.w,(U=>U.conjugate()),"FlowGraphConjugateBlock",U)}}(0,w.f)("FlowGraphConjugateBlock",f);class j extends Q.d{constructor(U){super(E.w,E.w,E.s,((U,X)=>(0,S.b)(U,X)),"FlowGraphAngleBetweenBlock",U)}}(0,w.f)("FlowGraphAngleBetweenBlock",j);class e extends Q.d{constructor(U){super(E.C,E.s,E.w,((U,X)=>q.Quaternion.RotationAxis(U,X)),"FlowGraphQuaternionFromAxisAngleBlock",U)}}(0,w.f)("FlowGraphQuaternionFromAxisAngleBlock",e);class l extends F.d{constructor(U){super(U),this.a=this.registerDataInput("a",E.w),this.axis=this.registerDataOutput("axis",E.C),this.angle=this.registerDataOutput("angle",E.s),this.isValid=this.registerDataOutput("isValid",E.e)}_updateOutputs(U){const X=U._getExecutionVariable(this,a,-1),b=U._getExecutionVariable(this,R,null),F=U._getExecutionVariable(this,n,null);if(void 0!==b&&null!==b&&void 0!==F&&null!==F&&X===U.executionId)this.axis.setValue(b,U),this.angle.setValue(F,U);else try{const{axis:X,angle:b}=this.a.getValue(U).toAxisAngle();U._setExecutionVariable(this,R,X),U._setExecutionVariable(this,n,b),U._setExecutionVariable(this,a,U.executionId),this.axis.setValue(X,U),this.angle.setValue(b,U),this.isValid.setValue(!0,U)}catch(E){this.isValid.setValue(!1,U)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,w.f)("FlowGraphAxisAngleFromQuaternionBlock",l);class d extends Q.d{constructor(U){super(E.C,E.C,E.w,((U,X)=>(0,S.c)(U,X)),"FlowGraphQuaternionFromDirectionsBlock",U)}}},14828:(U,X,b)=>{b.d(X,{d:()=>E});var F=b(14831);class E extends F.e{constructor(U,X,b,F,E,w){super(b,w),this._operation=F,this._className=E,this.a=this.registerDataInput("a",U),this.b=this.registerDataInput("b",X)}_doOperation(U){const X=this.a.getValue(U),b=this.b.getValue(U);return this._operation(X,b)}getClassName(){return this._className}}},14831:(U,X,b)=>{b.d(X,{e:()=>z});var F=b(13308),E=b(13281);const w="cachedOperationValue",Q="cachedExecutionId";class z extends F.d{constructor(U,X){super(X),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",E.e)}_updateOutputs(U){const X=U._getExecutionVariable(this,Q,-1),b=U._getExecutionVariable(this,w,null);if(void 0!==b&&null!==b&&X===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(b,U);else try{const X=this._doOperation(U);if(void 0===X||null===X)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,w,X),U._setExecutionVariable(this,Q,U.executionId),this.value.setValue(X,U),this.isValid.setValue(!0,U)}catch(F){this.isValid.setValue(!1,U)}}}},14838:(U,X,b)=>{b.d(X,{b:()=>E});var F=b(14831);class E extends F.e{constructor(U,X,b,F,E){super(X,E),this._operation=b,this._className=F,this.a=this.registerDataInput("a",U)}_doOperation(U){return this._operation(this.a.getValue(U))}getClassName(){return this._className}}}}]);