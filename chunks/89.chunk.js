"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[89],{14988:(E,t,z)=>{z.r(t),z.d(t,{FlowGraphAngleBetweenBlock:()=>l,FlowGraphAxisAngleFromQuaternionBlock:()=>K,FlowGraphConjugateBlock:()=>S,FlowGraphCrossBlock:()=>L,FlowGraphDotBlock:()=>a,FlowGraphLengthBlock:()=>O,FlowGraphNormalizeBlock:()=>c,FlowGraphQuaternionFromAxisAngleBlock:()=>f,FlowGraphQuaternionFromDirectionsBlock:()=>F,FlowGraphRotate2DBlock:()=>mE,FlowGraphRotate3DBlock:()=>W,FlowGraphTransformBlock:()=>e,FlowGraphTransformCoordinatesBlock:()=>D});var A=z(13480),X=z(13458),R=z(11766),u=z(14970),p=z(14980),C=z(11812),Z=z(13494),H=z(13173);const h="cachedOperationAxis",d="cachedOperationAngle",y="cachedExecutionId";class O extends p.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicLength(E)),"FlowGraphLengthBlock",E)}_polymorphicLength(E){switch((0,Z.m)(E)){case"Vector2":case"Lt":case"Vector4":case"Quaternion":return E.length();default:throw new Error(`Cannot compute length of value ${E}`)}}}(0,R.f)("FlowGraphLengthBlock",O);class c extends p.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicNormalize(E)),"FlowGraphNormalizeBlock",E)}_polymorphicNormalize(E){var t;let z;switch((0,Z.m)(E)){case"Vector2":case"Lt":case"Vector4":case"Quaternion":if(z=E.normalizeToNew(),null!==(t=this.config)&&void 0!==t&&t.nanOnZeroLength){0===E.length()&&z.ap(NaN)}return z;default:throw new Error(`Cannot normalize value ${E}`)}}}(0,R.f)("FlowGraphNormalizeBlock",c);class a extends u.b{constructor(E){super(X.c,X.c,X.p,((E,t)=>this._polymorphicDot(E,t)),"FlowGraphDotBlock",E)}_polymorphicDot(E,t){switch((0,Z.m)(E)){case"Vector2":case"Lt":case"Vector4":case"Quaternion":return E.dot(t);default:throw new Error(`Cannot get dot product of ${E} and ${t}`)}}}(0,R.f)("FlowGraphDotBlock",a);class L extends u.b{constructor(E){super(X.x,X.x,X.x,((E,t)=>C.Lt.Cross(E,t)),"FlowGraphCrossBlock",E)}}(0,R.f)("FlowGraphCrossBlock",L);class mE extends u.b{constructor(E){super(X.v,X.p,X.v,((E,t)=>E.rotate(t)),"FlowGraphRotate2DBlock",E)}}(0,R.f)("FlowGraphRotate2DBlock",mE);class W extends u.b{constructor(E){super(X.x,X.q,X.x,((E,t)=>E.applyRotationQuaternion(t)),"FlowGraphRotate3DBlock",E)}}function I(E,t){switch((0,Z.m)(E)){case"Vector2":case"Lt":return t.transformVector(E);case"Vector4":return new C.Vector4(E.x*t.m[0]+E.y*t.m[1]+E.z*t.m[2]+E.w*t.m[3],E.x*t.m[4]+E.y*t.m[5]+E.z*t.m[6]+E.w*t.m[7],E.x*t.m[8]+E.y*t.m[9]+E.z*t.m[10]+E.w*t.m[11],E.x*t.m[12]+E.y*t.m[13]+E.z*t.m[14]+E.w*t.m[15]);default:throw new Error(`Cannot transform value ${E}`)}}(0,R.f)("FlowGraphRotate3DBlock",W);class e extends u.b{constructor(E){const t=(null===E||void 0===E?void 0:E.vectorType)||"Lt",z="Vector2"===t?"Matrix2D":"Lt"===t?"Matrix3D":"Matrix";super((0,X.J)(t),(0,X.J)(z),(0,X.J)(t),I,"FlowGraphTransformVectorBlock",E)}}(0,R.f)("FlowGraphTransformVectorBlock",e);class D extends u.b{constructor(E){super(X.x,X.i,X.x,((E,t)=>C.Lt.TransformCoordinates(E,t)),"FlowGraphTransformCoordinatesBlock",E)}}(0,R.f)("FlowGraphTransformCoordinatesBlock",D);class S extends p.c{constructor(E){super(X.q,X.q,(E=>E.conjugate()),"FlowGraphConjugateBlock",E)}}(0,R.f)("FlowGraphConjugateBlock",S);class l extends u.b{constructor(E){super(X.q,X.q,X.p,((E,t)=>(0,H.e)(E,t)),"FlowGraphAngleBetweenBlock",E)}}(0,R.f)("FlowGraphAngleBetweenBlock",l);class f extends u.b{constructor(E){super(X.x,X.p,X.q,((E,t)=>C.Quaternion.RotationAxis(E,t)),"FlowGraphQuaternionFromAxisAngleBlock",E)}}(0,R.f)("FlowGraphQuaternionFromAxisAngleBlock",f);class K extends A.c{constructor(E){super(E),this.a=this.registerDataInput("a",X.q),this.axis=this.registerDataOutput("axis",X.x),this.angle=this.registerDataOutput("angle",X.p),this.isValid=this.registerDataOutput("isValid",X.d)}_updateOutputs(E){const t=E._getExecutionVariable(this,y,-1),z=E._getExecutionVariable(this,h,null),A=E._getExecutionVariable(this,d,null);if(void 0!==z&&null!==z&&void 0!==A&&null!==A&&t===E.executionId)this.axis.setValue(z,E),this.angle.setValue(A,E);else try{const{axis:t,angle:z}=this.a.getValue(E).toAxisAngle();E._setExecutionVariable(this,h,t),E._setExecutionVariable(this,d,z),E._setExecutionVariable(this,y,E.executionId),this.axis.setValue(t,E),this.angle.setValue(z,E),this.isValid.setValue(!0,E)}catch(X){this.isValid.setValue(!1,E)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,R.f)("FlowGraphAxisAngleFromQuaternionBlock",K);class F extends u.b{constructor(E){super(X.x,X.x,X.q,((E,t)=>(0,H.i)(E,t)),"FlowGraphQuaternionFromDirectionsBlock",E)}}},14970:(E,t,z)=>{z.d(t,{b:()=>X});var A=z(14978);class X extends A.b{constructor(E,t,z,A,X,R){super(z,R),this._operation=A,this._className=X,this.a=this.registerDataInput("a",E),this.b=this.registerDataInput("b",t)}_doOperation(E){const t=this.a.getValue(E),z=this.b.getValue(E);return this._operation(t,z)}getClassName(){return this._className}}},14978:(E,t,z)=>{z.d(t,{b:()=>p});var A=z(13480),X=z(13458);const R="cachedOperationValue",u="cachedExecutionId";class p extends A.c{constructor(E,t){super(t),this.value=this.registerDataOutput("value",E),this.isValid=this.registerDataOutput("isValid",X.d)}_updateOutputs(E){const t=E._getExecutionVariable(this,u,-1),z=E._getExecutionVariable(this,R,null);if(void 0!==z&&null!==z&&t===E.executionId)this.isValid.setValue(!0,E),this.value.setValue(z,E);else try{const t=this._doOperation(E);if(void 0===t||null===t)return void this.isValid.setValue(!1,E);E._setExecutionVariable(this,R,t),E._setExecutionVariable(this,u,E.executionId),this.value.setValue(t,E),this.isValid.setValue(!0,E)}catch(A){this.isValid.setValue(!1,E)}}}},14980:(E,t,z)=>{z.d(t,{c:()=>X});var A=z(14978);class X extends A.b{constructor(E,t,z,A,X){super(t,X),this._operation=z,this._className=A,this.a=this.registerDataInput("a",E)}_doOperation(E){return this._operation(this.a.getValue(E))}getClassName(){return this._className}}}}]);