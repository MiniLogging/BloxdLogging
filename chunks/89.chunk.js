"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[89],{14365:(q,S,b)=>{b.r(S),b.d(S,{FlowGraphAngleBetweenBlock:()=>B,FlowGraphAxisAngleFromQuaternionBlock:()=>f,FlowGraphConjugateBlock:()=>T,FlowGraphCrossBlock:()=>Q,FlowGraphDotBlock:()=>H,FlowGraphLengthBlock:()=>G,FlowGraphNormalizeBlock:()=>Z,FlowGraphQuaternionFromAxisAngleBlock:()=>t,FlowGraphQuaternionFromDirectionsBlock:()=>m,FlowGraphRotate2DBlock:()=>k,FlowGraphRotate3DBlock:()=>W,FlowGraphTransformBlock:()=>u,FlowGraphTransformCoordinatesBlock:()=>X});var z=b(12852),C=b(12839),v=b(11058),U=b(14345),g=b(14361),r=b(11103),I=b(12856),V=b(12504);const l="cachedOperationAxis",y="cachedOperationAngle",R="cachedExecutionId";class G extends g.e{constructor(q){super(C.d,C.o,(q=>this._polymorphicLength(q)),"FlowGraphLengthBlock",q)}_polymorphicLength(q){switch((0,I.i)(q)){case"Vector2":case"yS":case"Vector4":case"Quaternion":return q.length();default:throw new Error(`Cannot compute length of value ${q}`)}}}(0,v.f)("FlowGraphLengthBlock",G);class Z extends g.e{constructor(q){super(C.d,C.d,(q=>this._polymorphicNormalize(q)),"FlowGraphNormalizeBlock",q)}_polymorphicNormalize(q){var S;let b;switch((0,I.i)(q)){case"Vector2":case"yS":case"Vector4":case"Quaternion":if(b=q.normalizeToNew(),null!==(S=this.config)&&void 0!==S&&S.nanOnZeroLength){0===q.length()&&b.fb(NaN)}return b;default:throw new Error(`Cannot normalize value ${q}`)}}}(0,v.f)("FlowGraphNormalizeBlock",Z);class H extends U.c{constructor(q){super(C.d,C.d,C.o,((q,S)=>this._polymorphicDot(q,S)),"FlowGraphDotBlock",q)}_polymorphicDot(q,S){switch((0,I.i)(q)){case"Vector2":case"yS":case"Vector4":case"Quaternion":return q.dot(S);default:throw new Error(`Cannot get dot product of ${q} and ${S}`)}}}(0,v.f)("FlowGraphDotBlock",H);class Q extends U.c{constructor(q){super(C.A,C.A,C.A,((q,S)=>r.yS.Cross(q,S)),"FlowGraphCrossBlock",q)}}(0,v.f)("FlowGraphCrossBlock",Q);class k extends U.c{constructor(q){super(C.y,C.o,C.y,((q,S)=>q.rotate(S)),"FlowGraphRotate2DBlock",q)}}(0,v.f)("FlowGraphRotate2DBlock",k);class W extends U.c{constructor(q){super(C.A,C.r,C.A,((q,S)=>q.applyRotationQuaternion(S)),"FlowGraphRotate3DBlock",q)}}function N(q,S){switch((0,I.i)(q)){case"Vector2":case"yS":return S.transformVector(q);case"Vector4":return new r.Vector4(q.x*S.m[0]+q.y*S.m[1]+q.z*S.m[2]+q.w*S.m[3],q.x*S.m[4]+q.y*S.m[5]+q.z*S.m[6]+q.w*S.m[7],q.x*S.m[8]+q.y*S.m[9]+q.z*S.m[10]+q.w*S.m[11],q.x*S.m[12]+q.y*S.m[13]+q.z*S.m[14]+q.w*S.m[15]);default:throw new Error(`Cannot transform value ${q}`)}}(0,v.f)("FlowGraphRotate3DBlock",W);class u extends U.c{constructor(q){const S=(null===q||void 0===q?void 0:q.vectorType)||"yS",b="Vector2"===S?"Matrix2D":"yS"===S?"Matrix3D":"Matrix";super((0,C.J)(S),(0,C.J)(b),(0,C.J)(S),N,"FlowGraphTransformVectorBlock",q)}}(0,v.f)("FlowGraphTransformVectorBlock",u);class X extends U.c{constructor(q){super(C.A,C.i,C.A,((q,S)=>r.yS.TransformCoordinates(q,S)),"FlowGraphTransformCoordinatesBlock",q)}}(0,v.f)("FlowGraphTransformCoordinatesBlock",X);class T extends g.e{constructor(q){super(C.r,C.r,(q=>q.conjugate()),"FlowGraphConjugateBlock",q)}}(0,v.f)("FlowGraphConjugateBlock",T);class B extends U.c{constructor(q){super(C.r,C.r,C.o,((q,S)=>(0,V.e)(q,S)),"FlowGraphAngleBetweenBlock",q)}}(0,v.f)("FlowGraphAngleBetweenBlock",B);class t extends U.c{constructor(q){super(C.A,C.o,C.r,((q,S)=>r.Quaternion.RotationAxis(q,S)),"FlowGraphQuaternionFromAxisAngleBlock",q)}}(0,v.f)("FlowGraphQuaternionFromAxisAngleBlock",t);class f extends z.c{constructor(q){super(q),this.a=this.registerDataInput("a",C.r),this.axis=this.registerDataOutput("axis",C.A),this.angle=this.registerDataOutput("angle",C.o),this.isValid=this.registerDataOutput("isValid",C.f)}_updateOutputs(q){const S=q._getExecutionVariable(this,R,-1),b=q._getExecutionVariable(this,l,null),z=q._getExecutionVariable(this,y,null);if(void 0!==b&&null!==b&&void 0!==z&&null!==z&&S===q.executionId)this.axis.setValue(b,q),this.angle.setValue(z,q);else try{const{axis:S,angle:b}=this.a.getValue(q).toAxisAngle();q._setExecutionVariable(this,l,S),q._setExecutionVariable(this,y,b),q._setExecutionVariable(this,R,q.executionId),this.axis.setValue(S,q),this.angle.setValue(b,q),this.isValid.setValue(!0,q)}catch(C){this.isValid.setValue(!1,q)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,v.f)("FlowGraphAxisAngleFromQuaternionBlock",f);class m extends U.c{constructor(q){super(C.A,C.A,C.r,((q,S)=>(0,V.g)(q,S)),"FlowGraphQuaternionFromDirectionsBlock",q)}}},14345:(q,S,b)=>{b.d(S,{c:()=>C});var z=b(14353);class C extends z.d{constructor(q,S,b,z,C,v){super(b,v),this._operation=z,this._className=C,this.a=this.registerDataInput("a",q),this.b=this.registerDataInput("b",S)}_doOperation(q){const S=this.a.getValue(q),b=this.b.getValue(q);return this._operation(S,b)}getClassName(){return this._className}}},14353:(q,S,b)=>{b.d(S,{d:()=>g});var z=b(12852),C=b(12839);const v="cachedOperationValue",U="cachedExecutionId";class g extends z.c{constructor(q,S){super(S),this.value=this.registerDataOutput("value",q),this.isValid=this.registerDataOutput("isValid",C.f)}_updateOutputs(q){const S=q._getExecutionVariable(this,U,-1),b=q._getExecutionVariable(this,v,null);if(void 0!==b&&null!==b&&S===q.executionId)this.isValid.setValue(!0,q),this.value.setValue(b,q);else try{const S=this._doOperation(q);if(void 0===S||null===S)return void this.isValid.setValue(!1,q);q._setExecutionVariable(this,v,S),q._setExecutionVariable(this,U,q.executionId),this.value.setValue(S,q),this.isValid.setValue(!0,q)}catch(z){this.isValid.setValue(!1,q)}}}},14361:(q,S,b)=>{b.d(S,{e:()=>C});var z=b(14353);class C extends z.d{constructor(q,S,b,z,C){super(S,C),this._operation=b,this._className=z,this.a=this.registerDataInput("a",q)}_doOperation(q){return this._operation(this.a.getValue(q))}getClassName(){return this._className}}}}]);