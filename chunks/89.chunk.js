"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[89],{15736:(z,u,U)=>{U.r(u),U.d(u,{FlowGraphAngleBetweenBlock:()=>L,FlowGraphAxisAngleFromQuaternionBlock:()=>x,FlowGraphConjugateBlock:()=>V,FlowGraphCrossBlock:()=>r,FlowGraphDotBlock:()=>C,FlowGraphLengthBlock:()=>A,FlowGraphNormalizeBlock:()=>E,FlowGraphQuaternionFromAxisAngleBlock:()=>O,FlowGraphQuaternionFromDirectionsBlock:()=>Q,FlowGraphRotate2DBlock:()=>M,FlowGraphRotate3DBlock:()=>T,FlowGraphTransformBlock:()=>h,FlowGraphTransformCoordinatesBlock:()=>t});var J=U(14218),v=U(14196),f=U(12875),g=U(15722),w=U(15728),P=U(12914),R=U(14233),S=U(13869);const d="cachedOperationAxis",mz="cachedOperationAngle",Z="cachedExecutionId";class A extends w.b{constructor(z){super(v.e,v.x,(z=>this._polymorphicLength(z)),"FlowGraphLengthBlock",z)}_polymorphicLength(z){switch((0,R.k)(z)){case"Vector2":case"Eu":case"Vector4":case"Quaternion":return z.length();default:throw new Error("Cannot compute length of value ".concat(z))}}}(0,f.f)("FlowGraphLengthBlock",A);class E extends w.b{constructor(z){super(v.e,v.e,(z=>this._polymorphicNormalize(z)),"FlowGraphNormalizeBlock",z)}_polymorphicNormalize(z){var u;let U;switch((0,R.k)(z)){case"Vector2":case"Eu":case"Vector4":case"Quaternion":if(U=z.normalizeToNew(),null!==(u=this.config)&&void 0!==u&&u.nanOnZeroLength){0===z.length()&&U.fg(NaN)}return U;default:throw new Error("Cannot normalize value ".concat(z))}}}(0,f.f)("FlowGraphNormalizeBlock",E);class C extends g.d{constructor(z){super(v.e,v.e,v.x,((z,u)=>this._polymorphicDot(z,u)),"FlowGraphDotBlock",z)}_polymorphicDot(z,u){switch((0,R.k)(z)){case"Vector2":case"Eu":case"Vector4":case"Quaternion":return z.dot(u);default:throw new Error("Cannot get dot product of ".concat(z," and ").concat(u))}}}(0,f.f)("FlowGraphDotBlock",C);class r extends g.d{constructor(z){super(v.F,v.F,v.F,((z,u)=>P.Eu.Cross(z,u)),"FlowGraphCrossBlock",z)}}(0,f.f)("FlowGraphCrossBlock",r);class M extends g.d{constructor(z){super(v.D,v.x,v.D,((z,u)=>z.rotate(u)),"FlowGraphRotate2DBlock",z)}}(0,f.f)("FlowGraphRotate2DBlock",M);class T extends g.d{constructor(z){super(v.F,v.A,v.F,((z,u)=>z.applyRotationQuaternion(u)),"FlowGraphRotate3DBlock",z)}}function X(z,u){switch((0,R.k)(z)){case"Vector2":case"Eu":return u.transformVector(z);case"Vector4":return new P.Vector4(z.x*u.m[0]+z.y*u.m[1]+z.z*u.m[2]+z.w*u.m[3],z.x*u.m[4]+z.y*u.m[5]+z.z*u.m[6]+z.w*u.m[7],z.x*u.m[8]+z.y*u.m[9]+z.z*u.m[10]+z.w*u.m[11],z.x*u.m[12]+z.y*u.m[13]+z.z*u.m[14]+z.w*u.m[15]);default:throw new Error("Cannot transform value ".concat(z))}}(0,f.f)("FlowGraphRotate3DBlock",T);class h extends g.d{constructor(z){const u=(null===z||void 0===z?void 0:z.vectorType)||"Eu",U="Vector2"===u?"Matrix2D":"Eu"===u?"Matrix3D":"Matrix";super((0,v.R)(u),(0,v.R)(U),(0,v.R)(u),X,"FlowGraphTransformVectorBlock",z)}}(0,f.f)("FlowGraphTransformVectorBlock",h);class t extends g.d{constructor(z){super(v.F,v.n,v.F,((z,u)=>P.Eu.TransformCoordinates(z,u)),"FlowGraphTransformCoordinatesBlock",z)}}(0,f.f)("FlowGraphTransformCoordinatesBlock",t);class V extends w.b{constructor(z){super(v.A,v.A,(z=>z.conjugate()),"FlowGraphConjugateBlock",z)}}(0,f.f)("FlowGraphConjugateBlock",V);class L extends g.d{constructor(z){super(v.A,v.A,v.x,((z,u)=>(0,S.d)(z,u)),"FlowGraphAngleBetweenBlock",z)}}(0,f.f)("FlowGraphAngleBetweenBlock",L);class O extends g.d{constructor(z){super(v.F,v.x,v.A,((z,u)=>P.Quaternion.RotationAxis(z,u)),"FlowGraphQuaternionFromAxisAngleBlock",z)}}(0,f.f)("FlowGraphQuaternionFromAxisAngleBlock",O);class x extends J.b{constructor(z){super(z),this.a=this.registerDataInput("a",v.A),this.axis=this.registerDataOutput("axis",v.F),this.angle=this.registerDataOutput("angle",v.x),this.isValid=this.registerDataOutput("isValid",v.h)}_updateOutputs(z){const u=z._getExecutionVariable(this,Z,-1),U=z._getExecutionVariable(this,d,null),J=z._getExecutionVariable(this,mz,null);if(void 0!==U&&null!==U&&void 0!==J&&null!==J&&u===z.executionId)this.axis.setValue(U,z),this.angle.setValue(J,z);else try{const{axis:u,angle:U}=this.a.getValue(z).toAxisAngle();z._setExecutionVariable(this,d,u),z._setExecutionVariable(this,mz,U),z._setExecutionVariable(this,Z,z.executionId),this.axis.setValue(u,z),this.angle.setValue(U,z),this.isValid.setValue(!0,z)}catch(v){this.isValid.setValue(!1,z)}}getClassName(){return"FlowGraphAxisAngleFromQuaternionBlock"}}(0,f.f)("FlowGraphAxisAngleFromQuaternionBlock",x);class Q extends g.d{constructor(z){super(v.F,v.F,v.A,((z,u)=>(0,S.g)(z,u)),"FlowGraphQuaternionFromDirectionsBlock",z)}}},15722:(z,u,U)=>{U.d(u,{d:()=>v});var J=U(15724);class v extends J.c{constructor(z,u,U,J,v,f){super(U,f),this._operation=J,this._className=v,this.a=this.registerDataInput("a",z),this.b=this.registerDataInput("b",u)}_doOperation(z){const u=this.a.getValue(z),U=this.b.getValue(z);return this._operation(u,U)}getClassName(){return this._className}}},15724:(z,u,U)=>{U.d(u,{c:()=>w});var J=U(14218),v=U(14196);const f="cachedOperationValue",g="cachedExecutionId";class w extends J.b{constructor(z,u){super(u),this.value=this.registerDataOutput("value",z),this.isValid=this.registerDataOutput("isValid",v.h)}_updateOutputs(z){const u=z._getExecutionVariable(this,g,-1),U=z._getExecutionVariable(this,f,null);if(void 0!==U&&null!==U&&u===z.executionId)this.isValid.setValue(!0,z),this.value.setValue(U,z);else try{const u=this._doOperation(z);if(void 0===u||null===u)return void this.isValid.setValue(!1,z);z._setExecutionVariable(this,f,u),z._setExecutionVariable(this,g,z.executionId),this.value.setValue(u,z),this.isValid.setValue(!0,z)}catch(J){this.isValid.setValue(!1,z)}}}},15728:(z,u,U)=>{U.d(u,{b:()=>v});var J=U(15724);class v extends J.c{constructor(z,u,U,J,v){super(u,v),this._operation=U,this._className=J,this.a=this.registerDataInput("a",z)}_doOperation(z){return this._operation(this.a.getValue(z))}getClassName(){return this._className}}}}]);