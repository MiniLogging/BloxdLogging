"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10093:(V,H,t)=>{t.r(H),t.d(H,{_BasisTextureLoader:()=>Q});var I,Z=t(1145),h=t(915),f=t(1075);function m(){const V=0,H=1,t=2,I=3,Z=6,h=8,f=9,m=10,K=14;let E=null;function d(V,H,t,I,Z){const h=V.getImageTranscodedSizeInBytes(H,t,I);let f=new Uint8Array(h);if(!V.transcodeImage(f,H,t,I,1,0))return null;if(Z){f=function(V,H,t,I){const Z=new Uint16Array(4),h=new Uint16Array(t*I),f=t/4,m=I/4;for(let K=0;K<m;K++)for(let I=0;I<f;I++){const m=H+8*(K*f+I);Z[0]=V[m]|V[m+1]<<8,Z[1]=V[m+2]|V[m+3]<<8,Z[2]=(2*(31&Z[0])+1*(31&Z[1]))/3|(2*(2016&Z[0])+1*(2016&Z[1]))/3&2016|(2*(63488&Z[0])+1*(63488&Z[1]))/3&63488,Z[3]=(2*(31&Z[1])+1*(31&Z[0]))/3|(2*(2016&Z[1])+1*(2016&Z[0]))/3&2016|(2*(63488&Z[1])+1*(63488&Z[0]))/3&63488;for(let H=0;H<4;H++){const f=V[m+4+H];let E=(4*K+H)*t+4*I;h[E++]=Z[3&f],h[E++]=Z[f>>2&3],h[E++]=Z[f>>4&3],h[E++]=Z[f>>6&3]}}return h}(f,0,V.getImageWidth(H,t)+3&-4,V.getImageHeight(H,t)+3&-4)}return f}onmessage=a=>{if("init"===a.data.action){if(a.data.url)try{importScripts(a.data.url)}catch(J){postMessage({action:"error",error:J})}E||(E=BASIS({wasmBinary:a.data.wasmBinary})),null!==E&&E.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===a.data.action){const E=a.data.config,J=a.data.imageData,O=new BASIS.BasisFile(J),C=function(V){const H=V.getHasAlpha(),t=V.getNumImages(),I=[];for(let Z=0;Z<t;Z++){const H={levels:[]},t=V.getNumLevels(Z);for(let I=0;I<t;I++){const t={width:V.getImageWidth(Z,I),height:V.getImageHeight(Z,I)};H.levels.push(t)}I.push(H)}return{dd:H,images:I}}(O);let S=a.data.ignoreSupportedFormats?null:function(E,d){let a=null;E.supportedCompressionFormats&&(a=E.supportedCompressionFormats.astc?m:E.supportedCompressionFormats.bc7?Z:E.supportedCompressionFormats.s3tc?d.dd?I:t:E.supportedCompressionFormats.pvrtc?d.dd?f:h:E.supportedCompressionFormats.etc2?H:E.supportedCompressionFormats.etc1?V:K);return a}(a.data.config,C),v=!1;null===S&&(v=!0,S=C.dd?I:t);let Q=!0;O.startTranscoding()||(Q=!1);const e=[];for(let V=0;V<C.images.length&&Q;V++){const H=C.images[V];if(void 0===E.loadSingleImage||E.loadSingleImage===V){let t=H.levels.length;!1===E.loadMipmapLevels&&(t=1);for(let I=0;I<t;I++){const t=H.levels[I],Z=d(O,V,I,S,v);if(!Z){Q=!1;break}t.transcodedPixels=Z,e.push(t.transcodedPixels.buffer)}}}O.close(),O.delete(),v&&(S=-1),Q?postMessage({action:"transcode",success:Q,id:a.data.id,fileInfo:C,format:S},e):postMessage({action:"transcode",success:Q,id:a.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(I||(I={}));const K={JSModuleURL:`${Z.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${Z.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let E=null,d=null,a=0;const J=()=>(E||(E=new Promise(((V,H)=>{d?V(d):Z.f.LoadFileAsync(Z.f.GetBabylonScriptURL(K.WasmModuleURL)).then((t=>{if("function"!==typeof URL)return H("Basis transcoder requires an environment with a URL constructor");const I=URL.createObjectURL(new Blob([`(${m})()`],{type:"application/javascript"}));d=new Worker(I),function(V,H,t){return new Promise(((I,h)=>{const f=H=>{"init"===H.data.action?(V.removeEventListener("message",f),I(V)):"error"===H.data.action&&h(H.data.error||"error initializing worker")};V.addEventListener("message",f),V.postMessage({action:"init",url:t?Z.f.GetBabylonScriptURL(t):void 0,wasmBinary:H},[H])}))}(d,t,K.JSModuleURL).then(V,H)})).catch(H)}))),E),O=(V,H)=>{const t=V instanceof ArrayBuffer?new Uint8Array(V):V;return new Promise(((V,I)=>{J().then((()=>{const Z=a++,h=H=>{"transcode"===H.data.action&&H.data.id===Z&&(d.removeEventListener("message",h),H.data.success?V(H.data):I("Transcode is not supported on this device"))};d.addEventListener("message",h);const f=new Uint8Array(t.byteLength);f.set(new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),d.postMessage({action:"transcode",id:Z,imageData:f,config:H,ignoreSupportedFormats:false},[f.buffer])}),(V=>{I(V)}))}))},C=(V,H)=>{var t;let I=null===(t=H._gl)||void 0===t?void 0:t.TEXTURE_2D;var Z;V.isCube&&(I=null===(Z=H._gl)||void 0===Z?void 0:Z.TEXTURE_CUBE_MAP);H._bindTextureDirectly(I,V,!0)},S=(V,H)=>{const t=V.getEngine();for(let m=0;m<H.fileInfo.images.length;m++){const K=H.fileInfo.images[m].levels[0];if(V._invertVScale=V.invertY,-1===H.format||H.format===I.cTFRGB565)if(V.type=10,V.format=4,!t._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0)V._invertVScale=!V.invertY,V.width=K.width+3&-4,V.height=K.height+3&-4,V.samplingMode=2,C(V,t),t._uploadDataToTextureDirectly(V,new Uint16Array(K.transcodedPixels.buffer),m,0,4,!0);else{const H=new f.e(t,2);V._invertVScale=V.invertY,H.type=10,H.format=4,H.width=K.width+3&-4,H.height=K.height+3&-4,C(H,t),t._uploadDataToTextureDirectly(H,new Uint16Array(K.transcodedPixels.buffer),m,0,4,!0),t._rescaleTexture(H,V,t.scenes[0],t._getInternalFormat(4),(()=>{t._releaseTexture(H),C(V,t)}))}else{V.width=K.width,V.height=K.height,V.generateMipMaps=H.fileInfo.images[m].levels.length>1;const I=v.GetInternalFormatFromBasisFormat(H.format,t);V.format=I,C(V,t),H.fileInfo.images[m].levels.forEach(((H,Z)=>{t._uploadCompressedDataToTextureDirectly(V,I,H.width,H.height,H.transcodedPixels,m,Z)})),!t._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(Z.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=h.d.CLAMP_ADDRESSMODE,V._cachedWrapV=h.d.CLAMP_ADDRESSMODE)}}},v={JSModuleURL:K.JSModuleURL,WasmModuleURL:K.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,H)=>{let t;switch(V){case I.cTFETC1:t=36196;break;case I.cTFBC1:t=33776;break;case I.cTFBC4:t=33779;break;case I.cTFASTC_4x4:t=37808;break;case I.cTFETC2:t=37496;break;case I.cTFBC7:t=36492}if(void 0===t)throw"The chosen Basis transcoder format is not currently supported";return t},TranscodeAsync:O,LoadTextureFromTranscodeResult:S};Object.defineProperty(v,"JSModuleURL",{get:function(){return K.JSModuleURL},set:function(V){K.JSModuleURL=V}}),Object.defineProperty(v,"WasmModuleURL",{get:function(){return K.WasmModuleURL},set:function(V){K.WasmModuleURL=V}});class Q{constructor(){this.supportCascades=!1}loadCubeData(V,H,t,I,h){if(Array.isArray(V))return;const f=H.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!f.etc1,s3tc:!!f.s3tc,pvrtc:!!f.pvrtc,etc2:!!f.etc2,astc:!!f.astc,bc7:!!f.bptc}};O(V,m).then((V=>{const t=V.fileInfo.images[0].levels.length>1&&H.generateMipMaps;S(H,V),H.getEngine()._setCubeMapTextureParams(H,t),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),I&&I()})).catch((V=>{Z.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),H.isReady=!0,h&&h(V)}))}loadData(V,H,t){const I=H.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!I.etc1,s3tc:!!I.s3tc,pvrtc:!!I.pvrtc,etc2:!!I.etc2,astc:!!I.astc,bc7:!!I.bptc}};O(V,h).then((V=>{const I=V.fileInfo.images[0].levels[0],Z=V.fileInfo.images[0].levels.length>1&&H.generateMipMaps;t(I.width,I.height,Z,-1!==V.format,(()=>{S(H,V)}))})).catch((V=>{Z.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.f.Warn(`Failed to transcode Basis file: ${V}`),t(0,0,!1,!1,(()=>{}),!0)}))}}}}]);