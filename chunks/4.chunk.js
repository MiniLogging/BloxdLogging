"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{11053:(f,H,Q)=>{Q.r(H),Q.d(H,{_BasisTextureLoader:()=>S});var a,d=Q(1220),s=Q(973),n=Q(1142);function e(){const f=0,H=1,Q=2,a=3,d=6,s=8,n=9,e=10,c=14;let J=null;function u(f,H,Q,a,d){const s=f.getImageTranscodedSizeInBytes(H,Q,a);let n=new Uint8Array(s);if(!f.transcodeImage(n,H,Q,a,1,0))return null;if(d){n=function(f,H,Q,a){const d=new Uint16Array(4),s=new Uint16Array(Q*a),n=Q/4,e=a/4;for(let c=0;c<e;c++)for(let a=0;a<n;a++){const e=H+8*(c*n+a);d[0]=f[e]|f[e+1]<<8,d[1]=f[e+2]|f[e+3]<<8,d[2]=(2*(31&d[0])+1*(31&d[1]))/3|(2*(2016&d[0])+1*(2016&d[1]))/3&2016|(2*(63488&d[0])+1*(63488&d[1]))/3&63488,d[3]=(2*(31&d[1])+1*(31&d[0]))/3|(2*(2016&d[1])+1*(2016&d[0]))/3&2016|(2*(63488&d[1])+1*(63488&d[0]))/3&63488;for(let H=0;H<4;H++){const n=f[e+4+H];let J=(4*c+H)*Q+4*a;s[J++]=d[3&n],s[J++]=d[n>>2&3],s[J++]=d[n>>4&3],s[J++]=d[n>>6&3]}}return s}(n,0,f.getImageWidth(H,Q)+3&-4,f.getImageHeight(H,Q)+3&-4)}return n}onmessage=Y=>{if("init"===Y.data.action){if(Y.data.url)try{importScripts(Y.data.url)}catch(k){postMessage({action:"error",error:k})}J||(J=BASIS({wasmBinary:Y.data.wasmBinary})),null!==J&&J.then((f=>{BASIS=f,f.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Y.data.action){const J=Y.data.config,k=Y.data.imageData,X=new BASIS.BasisFile(k),F=function(f){const H=f.getHasAlpha(),Q=f.getNumImages(),a=[];for(let d=0;d<Q;d++){const H={levels:[]},Q=f.getNumLevels(d);for(let a=0;a<Q;a++){const Q={width:f.getImageWidth(d,a),height:f.getImageHeight(d,a)};H.levels.push(Q)}a.push(H)}return{ld:H,images:a}}(X);let r=Y.data.ignoreSupportedFormats?null:function(J,u){let Y=null;J.supportedCompressionFormats&&(Y=J.supportedCompressionFormats.astc?e:J.supportedCompressionFormats.bc7?d:J.supportedCompressionFormats.s3tc?u.ld?a:Q:J.supportedCompressionFormats.pvrtc?u.ld?n:s:J.supportedCompressionFormats.etc2?H:J.supportedCompressionFormats.etc1?f:c);return Y}(Y.data.config,F),v=!1;null===r&&(v=!0,r=F.ld?a:Q);let S=!0;X.startTranscoding()||(S=!1);const M=[];for(let f=0;f<F.images.length&&S;f++){const H=F.images[f];if(void 0===J.loadSingleImage||J.loadSingleImage===f){let Q=H.levels.length;!1===J.loadMipmapLevels&&(Q=1);for(let a=0;a<Q;a++){const Q=H.levels[a],d=u(X,f,a,r,v);if(!d){S=!1;break}Q.transcodedPixels=d,M.push(Q.transcodedPixels.buffer)}}}X.close(),X.delete(),v&&(r=-1),S?postMessage({action:"transcode",success:S,id:Y.data.id,fileInfo:F,format:r},M):postMessage({action:"transcode",success:S,id:Y.data.id})}}}!function(f){f[f.cTFETC1=0]="cTFETC1",f[f.cTFETC2=1]="cTFETC2",f[f.cTFBC1=2]="cTFBC1",f[f.cTFBC3=3]="cTFBC3",f[f.cTFBC4=4]="cTFBC4",f[f.cTFBC5=5]="cTFBC5",f[f.cTFBC7=6]="cTFBC7",f[f.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",f[f.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",f[f.cTFASTC_4x4=10]="cTFASTC_4x4",f[f.cTFATC_RGB=11]="cTFATC_RGB",f[f.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",f[f.cTFRGBA32=13]="cTFRGBA32",f[f.cTFRGB565=14]="cTFRGB565",f[f.cTFBGR565=15]="cTFBGR565",f[f.cTFRGBA4444=16]="cTFRGBA4444",f[f.cTFFXT1_RGB=17]="cTFFXT1_RGB",f[f.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",f[f.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",f[f.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",f[f.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(a||(a={}));const c={JSModuleURL:`${d.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${d.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,u=null,Y=0;const k=()=>(J||(J=new Promise(((f,H)=>{u?f(u):d.e.LoadFileAsync(d.e.GetBabylonScriptURL(c.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return H("Basis transcoder requires an environment with a URL constructor");const a=URL.createObjectURL(new Blob([`(${e})()`],{type:"application/javascript"}));u=new Worker(a),function(f,H,Q){return new Promise(((a,s)=>{const n=H=>{"init"===H.data.action?(f.removeEventListener("message",n),a(f)):"error"===H.data.action&&s(H.data.error||"error initializing worker")};f.addEventListener("message",n),f.postMessage({action:"init",url:Q?d.e.GetBabylonScriptURL(Q):void 0,wasmBinary:H},[H])}))}(u,Q,c.JSModuleURL).then(f,H)})).catch(H)}))),J),X=(f,H)=>{const Q=f instanceof ArrayBuffer?new Uint8Array(f):f;return new Promise(((f,a)=>{k().then((()=>{const d=Y++,s=H=>{"transcode"===H.data.action&&H.data.id===d&&(u.removeEventListener("message",s),H.data.success?f(H.data):a("Transcode is not supported on this device"))};u.addEventListener("message",s);const n=new Uint8Array(Q.byteLength);n.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),u.postMessage({action:"transcode",id:d,imageData:n,config:H,ignoreSupportedFormats:false},[n.buffer])}),(f=>{a(f)}))}))},F=(f,H)=>{var Q;let a=null===(Q=H._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var d;f.isCube&&(a=null===(d=H._gl)||void 0===d?void 0:d.TEXTURE_CUBE_MAP);H._bindTextureDirectly(a,f,!0)},r=(f,H)=>{const Q=f.getEngine();for(let e=0;e<H.fileInfo.images.length;e++){const c=H.fileInfo.images[e].levels[0];if(f._invertVScale=f.invertY,-1===H.format||H.format===a.cTFRGB565)if(f.type=10,f.format=4,!Q._features.basisNeedsPOT||Math.log2(c.width)%1===0&&Math.log2(c.height)%1===0)f._invertVScale=!f.invertY,f.width=c.width+3&-4,f.height=c.height+3&-4,f.samplingMode=2,F(f,Q),Q._uploadDataToTextureDirectly(f,new Uint16Array(c.transcodedPixels.buffer),e,0,4,!0);else{const H=new n.b(Q,2);f._invertVScale=f.invertY,H.type=10,H.format=4,H.width=c.width+3&-4,H.height=c.height+3&-4,F(H,Q),Q._uploadDataToTextureDirectly(H,new Uint16Array(c.transcodedPixels.buffer),e,0,4,!0),Q._rescaleTexture(H,f,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(H),F(f,Q)}))}else{f.width=c.width,f.height=c.height,f.generateMipMaps=H.fileInfo.images[e].levels.length>1;const a=v.GetInternalFormatFromBasisFormat(H.format,Q);f.format=a,F(f,Q),H.fileInfo.images[e].levels.forEach(((H,d)=>{Q._uploadCompressedDataToTextureDirectly(f,a,H.width,H.height,H.transcodedPixels,e,d)})),!Q._features.basisNeedsPOT||Math.log2(f.width)%1===0&&Math.log2(f.height)%1===0||(d.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),f._cachedWrapU=s.e.CLAMP_ADDRESSMODE,f._cachedWrapV=s.e.CLAMP_ADDRESSMODE)}}},v={JSModuleURL:c.JSModuleURL,WasmModuleURL:c.WasmModuleURL,GetInternalFormatFromBasisFormat:(f,H)=>{let Q;switch(f){case a.cTFETC1:Q=36196;break;case a.cTFBC1:Q=33776;break;case a.cTFBC4:Q=33779;break;case a.cTFASTC_4x4:Q=37808;break;case a.cTFETC2:Q=37496;break;case a.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:X,LoadTextureFromTranscodeResult:r};Object.defineProperty(v,"JSModuleURL",{get:function(){return c.JSModuleURL},set:function(f){c.JSModuleURL=f}}),Object.defineProperty(v,"WasmModuleURL",{get:function(){return c.WasmModuleURL},set:function(f){c.WasmModuleURL=f}});class S{constructor(){this.supportCascades=!1}loadCubeData(f,H,Q,a,s){if(Array.isArray(f))return;const n=H.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!n.etc1,s3tc:!!n.s3tc,pvrtc:!!n.pvrtc,etc2:!!n.etc2,astc:!!n.astc,bc7:!!n.bptc}};X(f,e).then((f=>{const Q=f.fileInfo.images[0].levels.length>1&&H.generateMipMaps;r(H,f),H.getEngine()._setCubeMapTextureParams(H,Q),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),a&&a()})).catch((f=>{d.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),H.isReady=!0,s&&s(f)}))}loadData(f,H,Q){const a=H.getEngine().getCaps(),s={supportedCompressionFormats:{etc1:!!a.etc1,s3tc:!!a.s3tc,pvrtc:!!a.pvrtc,etc2:!!a.etc2,astc:!!a.astc,bc7:!!a.bptc}};X(f,s).then((f=>{const a=f.fileInfo.images[0].levels[0],d=f.fileInfo.images[0].levels.length>1&&H.generateMipMaps;Q(a.width,a.height,d,-1!==f.format,(()=>{r(H,f)}))})).catch((f=>{d.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.e.Warn(`Failed to transcode Basis file: ${f}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);