"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10907:(D,j,W)=>{W.r(j),W.d(j,{_BasisTextureLoader:()=>U});var Q,C=W(1207),k=W(936),M=W(1129);function O(){const D=0,j=1,W=2,Q=3,C=6,k=8,M=9,O=10,E=14;let f=null;function F(D,j,W,Q,C){const k=D.getImageTranscodedSizeInBytes(j,W,Q);let M=new Uint8Array(k);if(!D.transcodeImage(M,j,W,Q,1,0))return null;if(C){M=function(D,j,W,Q){const C=new Uint16Array(4),k=new Uint16Array(W*Q),M=W/4,O=Q/4;for(let E=0;E<O;E++)for(let Q=0;Q<M;Q++){const O=j+8*(E*M+Q);C[0]=D[O]|D[O+1]<<8,C[1]=D[O+2]|D[O+3]<<8,C[2]=(2*(31&C[0])+1*(31&C[1]))/3|(2*(2016&C[0])+1*(2016&C[1]))/3&2016|(2*(63488&C[0])+1*(63488&C[1]))/3&63488,C[3]=(2*(31&C[1])+1*(31&C[0]))/3|(2*(2016&C[1])+1*(2016&C[0]))/3&2016|(2*(63488&C[1])+1*(63488&C[0]))/3&63488;for(let j=0;j<4;j++){const M=D[O+4+j];let f=(4*E+j)*W+4*Q;k[f++]=C[3&M],k[f++]=C[M>>2&3],k[f++]=C[M>>4&3],k[f++]=C[M>>6&3]}}return k}(M,0,D.getImageWidth(j,W)+3&-4,D.getImageHeight(j,W)+3&-4)}return M}onmessage=Z=>{if("init"===Z.data.action){if(Z.data.url)try{importScripts(Z.data.url)}catch(P){postMessage({action:"error",error:P})}f||(f=BASIS({wasmBinary:Z.data.wasmBinary})),null!==f&&f.then((D=>{BASIS=D,D.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Z.data.action){const f=Z.data.config,P=Z.data.imageData,X=new BASIS.BasisFile(P),x=function(D){const j=D.getHasAlpha(),W=D.getNumImages(),Q=[];for(let C=0;C<W;C++){const j={levels:[]},W=D.getNumLevels(C);for(let Q=0;Q<W;Q++){const W={width:D.getImageWidth(C,Q),height:D.getImageHeight(C,Q)};j.levels.push(W)}Q.push(j)}return{td:j,images:Q}}(X);let R=Z.data.ignoreSupportedFormats?null:function(f,F){let Z=null;f.supportedCompressionFormats&&(Z=f.supportedCompressionFormats.astc?O:f.supportedCompressionFormats.bc7?C:f.supportedCompressionFormats.s3tc?F.td?Q:W:f.supportedCompressionFormats.pvrtc?F.td?M:k:f.supportedCompressionFormats.etc2?j:f.supportedCompressionFormats.etc1?D:E);return Z}(Z.data.config,x),V=!1;null===R&&(V=!0,R=x.td?Q:W);let U=!0;X.startTranscoding()||(U=!1);const g=[];for(let D=0;D<x.images.length&&U;D++){const j=x.images[D];if(void 0===f.loadSingleImage||f.loadSingleImage===D){let W=j.levels.length;!1===f.loadMipmapLevels&&(W=1);for(let Q=0;Q<W;Q++){const W=j.levels[Q],C=F(X,D,Q,R,V);if(!C){U=!1;break}W.transcodedPixels=C,g.push(W.transcodedPixels.buffer)}}}X.close(),X.delete(),V&&(R=-1),U?postMessage({action:"transcode",success:U,id:Z.data.id,fileInfo:x,format:R},g):postMessage({action:"transcode",success:U,id:Z.data.id})}}}!function(D){D[D.cTFETC1=0]="cTFETC1",D[D.cTFETC2=1]="cTFETC2",D[D.cTFBC1=2]="cTFBC1",D[D.cTFBC3=3]="cTFBC3",D[D.cTFBC4=4]="cTFBC4",D[D.cTFBC5=5]="cTFBC5",D[D.cTFBC7=6]="cTFBC7",D[D.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",D[D.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",D[D.cTFASTC_4x4=10]="cTFASTC_4x4",D[D.cTFATC_RGB=11]="cTFATC_RGB",D[D.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",D[D.cTFRGBA32=13]="cTFRGBA32",D[D.cTFRGB565=14]="cTFRGB565",D[D.cTFBGR565=15]="cTFBGR565",D[D.cTFRGBA4444=16]="cTFRGBA4444",D[D.cTFFXT1_RGB=17]="cTFFXT1_RGB",D[D.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",D[D.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",D[D.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",D[D.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Q||(Q={}));const E={JSModuleURL:`${C.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${C.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let f=null,F=null,Z=0;const P=()=>(f||(f=new Promise(((D,j)=>{F?D(F):C.f.LoadFileAsync(C.f.GetBabylonScriptURL(E.WasmModuleURL)).then((W=>{if("function"!==typeof URL)return j("Basis transcoder requires an environment with a URL constructor");const Q=URL.createObjectURL(new Blob([`(${O})()`],{type:"application/javascript"}));F=new Worker(Q),function(D,j,W){return new Promise(((Q,k)=>{const M=j=>{"init"===j.data.action?(D.removeEventListener("message",M),Q(D)):"error"===j.data.action&&k(j.data.error||"error initializing worker")};D.addEventListener("message",M),D.postMessage({action:"init",url:W?C.f.GetBabylonScriptURL(W):void 0,wasmBinary:j},[j])}))}(F,W,E.JSModuleURL).then(D,j)})).catch(j)}))),f),X=(D,j)=>{const W=D instanceof ArrayBuffer?new Uint8Array(D):D;return new Promise(((D,Q)=>{P().then((()=>{const C=Z++,k=j=>{"transcode"===j.data.action&&j.data.id===C&&(F.removeEventListener("message",k),j.data.success?D(j.data):Q("Transcode is not supported on this device"))};F.addEventListener("message",k);const M=new Uint8Array(W.byteLength);M.set(new Uint8Array(W.buffer,W.byteOffset,W.byteLength)),F.postMessage({action:"transcode",id:C,imageData:M,config:j,ignoreSupportedFormats:false},[M.buffer])}),(D=>{Q(D)}))}))},x=(D,j)=>{var W;let Q=null===(W=j._gl)||void 0===W?void 0:W.TEXTURE_2D;var C;D.isCube&&(Q=null===(C=j._gl)||void 0===C?void 0:C.TEXTURE_CUBE_MAP);j._bindTextureDirectly(Q,D,!0)},R=(D,j)=>{const W=D.getEngine();for(let O=0;O<j.fileInfo.images.length;O++){const E=j.fileInfo.images[O].levels[0];if(D._invertVScale=D.invertY,-1===j.format||j.format===Q.cTFRGB565)if(D.type=10,D.format=4,!W._features.basisNeedsPOT||Math.log2(E.width)%1===0&&Math.log2(E.height)%1===0)D._invertVScale=!D.invertY,D.width=E.width+3&-4,D.height=E.height+3&-4,D.samplingMode=2,x(D,W),W._uploadDataToTextureDirectly(D,new Uint16Array(E.transcodedPixels.buffer),O,0,4,!0);else{const j=new M.d(W,2);D._invertVScale=D.invertY,j.type=10,j.format=4,j.width=E.width+3&-4,j.height=E.height+3&-4,x(j,W),W._uploadDataToTextureDirectly(j,new Uint16Array(E.transcodedPixels.buffer),O,0,4,!0),W._rescaleTexture(j,D,W.scenes[0],W._getInternalFormat(4),(()=>{W._releaseTexture(j),x(D,W)}))}else{D.width=E.width,D.height=E.height,D.generateMipMaps=j.fileInfo.images[O].levels.length>1;const Q=V.GetInternalFormatFromBasisFormat(j.format,W);D.format=Q,x(D,W),j.fileInfo.images[O].levels.forEach(((j,C)=>{W._uploadCompressedDataToTextureDirectly(D,Q,j.width,j.height,j.transcodedPixels,O,C)})),!W._features.basisNeedsPOT||Math.log2(D.width)%1===0&&Math.log2(D.height)%1===0||(C.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),D._cachedWrapU=k.e.CLAMP_ADDRESSMODE,D._cachedWrapV=k.e.CLAMP_ADDRESSMODE)}}},V={JSModuleURL:E.JSModuleURL,WasmModuleURL:E.WasmModuleURL,GetInternalFormatFromBasisFormat:(D,j)=>{let W;switch(D){case Q.cTFETC1:W=36196;break;case Q.cTFBC1:W=33776;break;case Q.cTFBC4:W=33779;break;case Q.cTFASTC_4x4:W=37808;break;case Q.cTFETC2:W=37496;break;case Q.cTFBC7:W=36492}if(void 0===W)throw"The chosen Basis transcoder format is not currently supported";return W},TranscodeAsync:X,LoadTextureFromTranscodeResult:R};Object.defineProperty(V,"JSModuleURL",{get:function(){return E.JSModuleURL},set:function(D){E.JSModuleURL=D}}),Object.defineProperty(V,"WasmModuleURL",{get:function(){return E.WasmModuleURL},set:function(D){E.WasmModuleURL=D}});class U{constructor(){this.supportCascades=!1}loadCubeData(D,j,W,Q,k){if(Array.isArray(D))return;const M=j.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!M.etc1,s3tc:!!M.s3tc,pvrtc:!!M.pvrtc,etc2:!!M.etc2,astc:!!M.astc,bc7:!!M.bptc}};X(D,O).then((D=>{const W=D.fileInfo.images[0].levels.length>1&&j.generateMipMaps;R(j,D),j.getEngine()._setCubeMapTextureParams(j,W),j.isReady=!0,j.onLoadedObservable.notifyObservers(j),j.onLoadedObservable.clear(),Q&&Q()})).catch((D=>{C.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),j.isReady=!0,k&&k(D)}))}loadData(D,j,W){const Q=j.getEngine().getCaps(),k={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};X(D,k).then((D=>{const Q=D.fileInfo.images[0].levels[0],C=D.fileInfo.images[0].levels.length>1&&j.generateMipMaps;W(Q.width,Q.height,C,-1!==D.format,(()=>{R(j,D)}))})).catch((D=>{C.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),C.f.Warn(`Failed to transcode Basis file: ${D}`),W(0,0,!1,!1,(()=>{}),!0)}))}}}}]);