"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10847:(Q,z,I)=>{I.r(z),I.d(z,{_BasisTextureLoader:()=>n});var P,w=I(1180),T=I(947),A=I(1105);function e(){const Q=0,z=1,I=2,P=3,w=6,T=8,A=9,e=10,m=14;let f=null;function j(Q,z,I,P,w){const T=Q.getImageTranscodedSizeInBytes(z,I,P);let A=new Uint8Array(T);if(!Q.transcodeImage(A,z,I,P,1,0))return null;if(w){A=function(Q,z,I,P){const w=new Uint16Array(4),T=new Uint16Array(I*P),A=I/4,e=P/4;for(let m=0;m<e;m++)for(let P=0;P<A;P++){const e=z+8*(m*A+P);w[0]=Q[e]|Q[e+1]<<8,w[1]=Q[e+2]|Q[e+3]<<8,w[2]=(2*(31&w[0])+1*(31&w[1]))/3|(2*(2016&w[0])+1*(2016&w[1]))/3&2016|(2*(63488&w[0])+1*(63488&w[1]))/3&63488,w[3]=(2*(31&w[1])+1*(31&w[0]))/3|(2*(2016&w[1])+1*(2016&w[0]))/3&2016|(2*(63488&w[1])+1*(63488&w[0]))/3&63488;for(let z=0;z<4;z++){const A=Q[e+4+z];let f=(4*m+z)*I+4*P;T[f++]=w[3&A],T[f++]=w[A>>2&3],T[f++]=w[A>>4&3],T[f++]=w[A>>6&3]}}return T}(A,0,Q.getImageWidth(z,I)+3&-4,Q.getImageHeight(z,I)+3&-4)}return A}onmessage=D=>{if("init"===D.data.action){if(D.data.url)try{importScripts(D.data.url)}catch(k){postMessage({action:"error",error:k})}f||(f=BASIS({wasmBinary:D.data.wasmBinary})),null!==f&&f.then((Q=>{BASIS=Q,Q.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===D.data.action){const f=D.data.config,k=D.data.imageData,s=new BASIS.BasisFile(k),J=function(Q){const z=Q.getHasAlpha(),I=Q.getNumImages(),P=[];for(let w=0;w<I;w++){const z={levels:[]},I=Q.getNumLevels(w);for(let P=0;P<I;P++){const I={width:Q.getImageWidth(w,P),height:Q.getImageHeight(w,P)};z.levels.push(I)}P.push(z)}return{jd:z,images:P}}(s);let l=D.data.ignoreSupportedFormats?null:function(f,j){let D=null;f.supportedCompressionFormats&&(D=f.supportedCompressionFormats.astc?e:f.supportedCompressionFormats.bc7?w:f.supportedCompressionFormats.s3tc?j.jd?P:I:f.supportedCompressionFormats.pvrtc?j.jd?A:T:f.supportedCompressionFormats.etc2?z:f.supportedCompressionFormats.etc1?Q:m);return D}(D.data.config,J),X=!1;null===l&&(X=!0,l=J.jd?P:I);let n=!0;s.startTranscoding()||(n=!1);const d=[];for(let Q=0;Q<J.images.length&&n;Q++){const z=J.images[Q];if(void 0===f.loadSingleImage||f.loadSingleImage===Q){let I=z.levels.length;!1===f.loadMipmapLevels&&(I=1);for(let P=0;P<I;P++){const I=z.levels[P],w=j(s,Q,P,l,X);if(!w){n=!1;break}I.transcodedPixels=w,d.push(I.transcodedPixels.buffer)}}}s.close(),s.delete(),X&&(l=-1),n?postMessage({action:"transcode",success:n,id:D.data.id,fileInfo:J,format:l},d):postMessage({action:"transcode",success:n,id:D.data.id})}}}!function(Q){Q[Q.cTFETC1=0]="cTFETC1",Q[Q.cTFETC2=1]="cTFETC2",Q[Q.cTFBC1=2]="cTFBC1",Q[Q.cTFBC3=3]="cTFBC3",Q[Q.cTFBC4=4]="cTFBC4",Q[Q.cTFBC5=5]="cTFBC5",Q[Q.cTFBC7=6]="cTFBC7",Q[Q.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Q[Q.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Q[Q.cTFASTC_4x4=10]="cTFASTC_4x4",Q[Q.cTFATC_RGB=11]="cTFATC_RGB",Q[Q.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Q[Q.cTFRGBA32=13]="cTFRGBA32",Q[Q.cTFRGB565=14]="cTFRGB565",Q[Q.cTFBGR565=15]="cTFBGR565",Q[Q.cTFRGBA4444=16]="cTFRGBA4444",Q[Q.cTFFXT1_RGB=17]="cTFFXT1_RGB",Q[Q.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Q[Q.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Q[Q.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Q[Q.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(P||(P={}));const m={JSModuleURL:`${w.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${w.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let f=null,j=null,D=0;const k=()=>(f||(f=new Promise(((Q,z)=>{j?Q(j):w.h.LoadFileAsync(w.h.GetBabylonScriptURL(m.WasmModuleURL)).then((I=>{if("function"!==typeof URL)return z("Basis transcoder requires an environment with a URL constructor");const P=URL.createObjectURL(new Blob([`(${e})()`],{type:"application/javascript"}));j=new Worker(P),function(Q,z,I){return new Promise(((P,T)=>{const A=z=>{"init"===z.data.action?(Q.removeEventListener("message",A),P(Q)):"error"===z.data.action&&T(z.data.error||"error initializing worker")};Q.addEventListener("message",A),Q.postMessage({action:"init",url:I?w.h.GetBabylonScriptURL(I):void 0,wasmBinary:z},[z])}))}(j,I,m.JSModuleURL).then(Q,z)})).catch(z)}))),f),s=(Q,z)=>{const I=Q instanceof ArrayBuffer?new Uint8Array(Q):Q;return new Promise(((Q,P)=>{k().then((()=>{const w=D++,T=z=>{"transcode"===z.data.action&&z.data.id===w&&(j.removeEventListener("message",T),z.data.success?Q(z.data):P("Transcode is not supported on this device"))};j.addEventListener("message",T);const A=new Uint8Array(I.byteLength);A.set(new Uint8Array(I.buffer,I.byteOffset,I.byteLength)),j.postMessage({action:"transcode",id:w,imageData:A,config:z,ignoreSupportedFormats:false},[A.buffer])}),(Q=>{P(Q)}))}))},J=(Q,z)=>{var I;let P=null===(I=z._gl)||void 0===I?void 0:I.TEXTURE_2D;var w;Q.isCube&&(P=null===(w=z._gl)||void 0===w?void 0:w.TEXTURE_CUBE_MAP);z._bindTextureDirectly(P,Q,!0)},l=(Q,z)=>{const I=Q.getEngine();for(let e=0;e<z.fileInfo.images.length;e++){const m=z.fileInfo.images[e].levels[0];if(Q._invertVScale=Q.invertY,-1===z.format||z.format===P.cTFRGB565)if(Q.type=10,Q.format=4,!I._features.basisNeedsPOT||Math.log2(m.width)%1===0&&Math.log2(m.height)%1===0)Q._invertVScale=!Q.invertY,Q.width=m.width+3&-4,Q.height=m.height+3&-4,Q.samplingMode=2,J(Q,I),I._uploadDataToTextureDirectly(Q,new Uint16Array(m.transcodedPixels.buffer),e,0,4,!0);else{const z=new A.e(I,2);Q._invertVScale=Q.invertY,z.type=10,z.format=4,z.width=m.width+3&-4,z.height=m.height+3&-4,J(z,I),I._uploadDataToTextureDirectly(z,new Uint16Array(m.transcodedPixels.buffer),e,0,4,!0),I._rescaleTexture(z,Q,I.scenes[0],I._getInternalFormat(4),(()=>{I._releaseTexture(z),J(Q,I)}))}else{Q.width=m.width,Q.height=m.height,Q.generateMipMaps=z.fileInfo.images[e].levels.length>1;const P=X.GetInternalFormatFromBasisFormat(z.format,I);Q.format=P,J(Q,I),z.fileInfo.images[e].levels.forEach(((z,w)=>{I._uploadCompressedDataToTextureDirectly(Q,P,z.width,z.height,z.transcodedPixels,e,w)})),!I._features.basisNeedsPOT||Math.log2(Q.width)%1===0&&Math.log2(Q.height)%1===0||(w.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Q._cachedWrapU=T.b.CLAMP_ADDRESSMODE,Q._cachedWrapV=T.b.CLAMP_ADDRESSMODE)}}},X={JSModuleURL:m.JSModuleURL,WasmModuleURL:m.WasmModuleURL,GetInternalFormatFromBasisFormat:(Q,z)=>{let I;switch(Q){case P.cTFETC1:I=36196;break;case P.cTFBC1:I=33776;break;case P.cTFBC4:I=33779;break;case P.cTFASTC_4x4:I=37808;break;case P.cTFETC2:I=37496;break;case P.cTFBC7:I=36492}if(void 0===I)throw"The chosen Basis transcoder format is not currently supported";return I},TranscodeAsync:s,LoadTextureFromTranscodeResult:l};Object.defineProperty(X,"JSModuleURL",{get:function(){return m.JSModuleURL},set:function(Q){m.JSModuleURL=Q}}),Object.defineProperty(X,"WasmModuleURL",{get:function(){return m.WasmModuleURL},set:function(Q){m.WasmModuleURL=Q}});class n{constructor(){this.supportCascades=!1}loadCubeData(Q,z,I,P,T){if(Array.isArray(Q))return;const A=z.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};s(Q,e).then((Q=>{const I=Q.fileInfo.images[0].levels.length>1&&z.generateMipMaps;l(z,Q),z.getEngine()._setCubeMapTextureParams(z,I),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),P&&P()})).catch((Q=>{w.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.isReady=!0,T&&T(Q)}))}loadData(Q,z,I){const P=z.getEngine().getCaps(),T={supportedCompressionFormats:{etc1:!!P.etc1,s3tc:!!P.s3tc,pvrtc:!!P.pvrtc,etc2:!!P.etc2,astc:!!P.astc,bc7:!!P.bptc}};s(Q,T).then((Q=>{const P=Q.fileInfo.images[0].levels[0],w=Q.fileInfo.images[0].levels.length>1&&z.generateMipMaps;I(P.width,P.height,w,-1!==Q.format,(()=>{l(z,Q)}))})).catch((Q=>{w.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),w.h.Warn(`Failed to transcode Basis file: ${Q}`),I(0,0,!1,!1,(()=>{}),!0)}))}}}}]);