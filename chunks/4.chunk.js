"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10657:(t,b,Y)=>{Y.r(b),Y.d(b,{_BasisTextureLoader:()=>B});var o,x=Y(1265),F=Y(990),r=Y(1199);function R(){const t=0,b=1,Y=2,o=3,x=6,F=8,r=9,R=10,d=14;let E=null;function U(t,b,Y,o,x){const F=t.getImageTranscodedSizeInBytes(b,Y,o);let r=new Uint8Array(F);if(!t.transcodeImage(r,b,Y,o,1,0))return null;if(x){r=function(t,b,Y,o){const x=new Uint16Array(4),F=new Uint16Array(Y*o),r=Y/4,R=o/4;for(let d=0;d<R;d++)for(let o=0;o<r;o++){const R=b+8*(d*r+o);x[0]=t[R]|t[R+1]<<8,x[1]=t[R+2]|t[R+3]<<8,x[2]=(2*(31&x[0])+1*(31&x[1]))/3|(2*(2016&x[0])+1*(2016&x[1]))/3&2016|(2*(63488&x[0])+1*(63488&x[1]))/3&63488,x[3]=(2*(31&x[1])+1*(31&x[0]))/3|(2*(2016&x[1])+1*(2016&x[0]))/3&2016|(2*(63488&x[1])+1*(63488&x[0]))/3&63488;for(let b=0;b<4;b++){const r=t[R+4+b];let E=(4*d+b)*Y+4*o;F[E++]=x[3&r],F[E++]=x[r>>2&3],F[E++]=x[r>>4&3],F[E++]=x[r>>6&3]}}return F}(r,0,t.getImageWidth(b,Y)+3&-4,t.getImageHeight(b,Y)+3&-4)}return r}onmessage=C=>{if("init"===C.data.action){if(C.data.url)try{importScripts(C.data.url)}catch(p){postMessage({action:"error",error:p})}E||(E=BASIS({wasmBinary:C.data.wasmBinary})),null!==E&&E.then((t=>{BASIS=t,t.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===C.data.action){const E=C.data.config,p=C.data.imageData,W=new BASIS.BasisFile(p),T=function(t){const b=t.getHasAlpha(),Y=t.getNumImages(),o=[];for(let x=0;x<Y;x++){const b={levels:[]},Y=t.getNumLevels(x);for(let o=0;o<Y;o++){const Y={width:t.getImageWidth(x,o),height:t.getImageHeight(x,o)};b.levels.push(Y)}o.push(b)}return{Cc:b,images:o}}(W);let y=C.data.ignoreSupportedFormats?null:function(E,U){let C=null;E.supportedCompressionFormats&&(C=E.supportedCompressionFormats.astc?R:E.supportedCompressionFormats.bc7?x:E.supportedCompressionFormats.s3tc?U.Cc?o:Y:E.supportedCompressionFormats.pvrtc?U.Cc?r:F:E.supportedCompressionFormats.etc2?b:E.supportedCompressionFormats.etc1?t:d);return C}(C.data.config,T),v=!1;null===y&&(v=!0,y=T.Cc?o:Y);let B=!0;W.startTranscoding()||(B=!1);const J=[];for(let t=0;t<T.images.length&&B;t++){const b=T.images[t];if(void 0===E.loadSingleImage||E.loadSingleImage===t){let Y=b.levels.length;!1===E.loadMipmapLevels&&(Y=1);for(let o=0;o<Y;o++){const Y=b.levels[o],x=U(W,t,o,y,v);if(!x){B=!1;break}Y.transcodedPixels=x,J.push(Y.transcodedPixels.buffer)}}}W.close(),W.delete(),v&&(y=-1),B?postMessage({action:"transcode",success:B,id:C.data.id,fileInfo:T,format:y},J):postMessage({action:"transcode",success:B,id:C.data.id})}}}!function(t){t[t.cTFETC1=0]="cTFETC1",t[t.cTFETC2=1]="cTFETC2",t[t.cTFBC1=2]="cTFBC1",t[t.cTFBC3=3]="cTFBC3",t[t.cTFBC4=4]="cTFBC4",t[t.cTFBC5=5]="cTFBC5",t[t.cTFBC7=6]="cTFBC7",t[t.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",t[t.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",t[t.cTFASTC_4x4=10]="cTFASTC_4x4",t[t.cTFATC_RGB=11]="cTFATC_RGB",t[t.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",t[t.cTFRGBA32=13]="cTFRGBA32",t[t.cTFRGB565=14]="cTFRGB565",t[t.cTFBGR565=15]="cTFBGR565",t[t.cTFRGBA4444=16]="cTFRGBA4444",t[t.cTFFXT1_RGB=17]="cTFFXT1_RGB",t[t.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",t[t.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",t[t.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",t[t.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(o||(o={}));const d={JSModuleURL:`${x.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${x.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let E=null,U=null,C=0;const p=()=>(E||(E=new Promise(((t,b)=>{U?t(U):x.f.LoadFileAsync(x.f.GetBabylonScriptURL(d.WasmModuleURL)).then((Y=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const o=URL.createObjectURL(new Blob([`(${R})()`],{type:"application/javascript"}));U=new Worker(o),function(t,b,Y){return new Promise(((o,F)=>{const r=b=>{"init"===b.data.action?(t.removeEventListener("message",r),o(t)):"error"===b.data.action&&F(b.data.error||"error initializing worker")};t.addEventListener("message",r),t.postMessage({action:"init",url:Y?x.f.GetBabylonScriptURL(Y):void 0,wasmBinary:b},[b])}))}(U,Y,d.JSModuleURL).then(t,b)})).catch(b)}))),E),W=(t,b)=>{const Y=t instanceof ArrayBuffer?new Uint8Array(t):t;return new Promise(((t,o)=>{p().then((()=>{const x=C++,F=b=>{"transcode"===b.data.action&&b.data.id===x&&(U.removeEventListener("message",F),b.data.success?t(b.data):o("Transcode is not supported on this device"))};U.addEventListener("message",F);const r=new Uint8Array(Y.byteLength);r.set(new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength)),U.postMessage({action:"transcode",id:x,imageData:r,config:b,ignoreSupportedFormats:false},[r.buffer])}),(t=>{o(t)}))}))},T=(t,b)=>{var Y;let o=null===(Y=b._gl)||void 0===Y?void 0:Y.TEXTURE_2D;var x;t.isCube&&(o=null===(x=b._gl)||void 0===x?void 0:x.TEXTURE_CUBE_MAP);b._bindTextureDirectly(o,t,!0)},y=(t,b)=>{const Y=t.getEngine();for(let R=0;R<b.fileInfo.images.length;R++){const d=b.fileInfo.images[R].levels[0];if(t._invertVScale=t.invertY,-1===b.format||b.format===o.cTFRGB565)if(t.type=10,t.format=4,!Y._features.basisNeedsPOT||Math.log2(d.width)%1===0&&Math.log2(d.height)%1===0)t._invertVScale=!t.invertY,t.width=d.width+3&-4,t.height=d.height+3&-4,t.samplingMode=2,T(t,Y),Y._uploadDataToTextureDirectly(t,new Uint16Array(d.transcodedPixels.buffer),R,0,4,!0);else{const b=new r.e(Y,2);t._invertVScale=t.invertY,b.type=10,b.format=4,b.width=d.width+3&-4,b.height=d.height+3&-4,T(b,Y),Y._uploadDataToTextureDirectly(b,new Uint16Array(d.transcodedPixels.buffer),R,0,4,!0),Y._rescaleTexture(b,t,Y.scenes[0],Y._getInternalFormat(4),(()=>{Y._releaseTexture(b),T(t,Y)}))}else{t.width=d.width,t.height=d.height,t.generateMipMaps=b.fileInfo.images[R].levels.length>1;const o=v.GetInternalFormatFromBasisFormat(b.format,Y);t.format=o,T(t,Y),b.fileInfo.images[R].levels.forEach(((b,x)=>{Y._uploadCompressedDataToTextureDirectly(t,o,b.width,b.height,b.transcodedPixels,R,x)})),!Y._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0||(x.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),t._cachedWrapU=F.b.CLAMP_ADDRESSMODE,t._cachedWrapV=F.b.CLAMP_ADDRESSMODE)}}},v={JSModuleURL:d.JSModuleURL,WasmModuleURL:d.WasmModuleURL,GetInternalFormatFromBasisFormat:(t,b)=>{let Y;switch(t){case o.cTFETC1:Y=36196;break;case o.cTFBC1:Y=33776;break;case o.cTFBC4:Y=33779;break;case o.cTFASTC_4x4:Y=37808;break;case o.cTFETC2:Y=37496;break;case o.cTFBC7:Y=36492}if(void 0===Y)throw"The chosen Basis transcoder format is not currently supported";return Y},TranscodeAsync:W,LoadTextureFromTranscodeResult:y};Object.defineProperty(v,"JSModuleURL",{get:function(){return d.JSModuleURL},set:function(t){d.JSModuleURL=t}}),Object.defineProperty(v,"WasmModuleURL",{get:function(){return d.WasmModuleURL},set:function(t){d.WasmModuleURL=t}});class B{constructor(){this.supportCascades=!1}loadCubeData(t,b,Y,o,F){if(Array.isArray(t))return;const r=b.getEngine().getCaps(),R={supportedCompressionFormats:{etc1:!!r.etc1,s3tc:!!r.s3tc,pvrtc:!!r.pvrtc,etc2:!!r.etc2,astc:!!r.astc,bc7:!!r.bptc}};W(t,R).then((t=>{const Y=t.fileInfo.images[0].levels.length>1&&b.generateMipMaps;y(b,t),b.getEngine()._setCubeMapTextureParams(b,Y),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),o&&o()})).catch((t=>{x.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,F&&F(t)}))}loadData(t,b,Y){const o=b.getEngine().getCaps(),F={supportedCompressionFormats:{etc1:!!o.etc1,s3tc:!!o.s3tc,pvrtc:!!o.pvrtc,etc2:!!o.etc2,astc:!!o.astc,bc7:!!o.bptc}};W(t,F).then((t=>{const o=t.fileInfo.images[0].levels[0],x=t.fileInfo.images[0].levels.length>1&&b.generateMipMaps;Y(o.width,o.height,x,-1!==t.format,(()=>{y(b,t)}))})).catch((t=>{x.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.f.Warn(`Failed to transcode Basis file: ${t}`),Y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);