"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10666:(j,S,h)=>{h.r(S),h.d(S,{_BasisTextureLoader:()=>v});var m,I=h(1166),d=h(942),U=h(1091);function f(){const j=0,S=1,h=2,m=3,I=6,d=8,U=9,f=10,r=14;let a=null;function M(j,S,h,m,I){const d=j.getImageTranscodedSizeInBytes(S,h,m);let U=new Uint8Array(d);if(!j.transcodeImage(U,S,h,m,1,0))return null;if(I){U=function(j,S,h,m){const I=new Uint16Array(4),d=new Uint16Array(h*m),U=h/4,f=m/4;for(let r=0;r<f;r++)for(let m=0;m<U;m++){const f=S+8*(r*U+m);I[0]=j[f]|j[f+1]<<8,I[1]=j[f+2]|j[f+3]<<8,I[2]=(2*(31&I[0])+1*(31&I[1]))/3|(2*(2016&I[0])+1*(2016&I[1]))/3&2016|(2*(63488&I[0])+1*(63488&I[1]))/3&63488,I[3]=(2*(31&I[1])+1*(31&I[0]))/3|(2*(2016&I[1])+1*(2016&I[0]))/3&2016|(2*(63488&I[1])+1*(63488&I[0]))/3&63488;for(let S=0;S<4;S++){const U=j[f+4+S];let a=(4*r+S)*h+4*m;d[a++]=I[3&U],d[a++]=I[U>>2&3],d[a++]=I[U>>4&3],d[a++]=I[U>>6&3]}}return d}(U,0,j.getImageWidth(S,h)+3&-4,j.getImageHeight(S,h)+3&-4)}return U}onmessage=O=>{if("init"===O.data.action){if(O.data.url)try{importScripts(O.data.url)}catch(p){postMessage({action:"error",error:p})}a||(a=BASIS({wasmBinary:O.data.wasmBinary})),null!==a&&a.then((j=>{BASIS=j,j.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===O.data.action){const a=O.data.config,p=O.data.imageData,e=new BASIS.BasisFile(p),w=function(j){const S=j.getHasAlpha(),h=j.getNumImages(),m=[];for(let I=0;I<h;I++){const S={levels:[]},h=j.getNumLevels(I);for(let m=0;m<h;m++){const h={width:j.getImageWidth(I,m),height:j.getImageHeight(I,m)};S.levels.push(h)}m.push(S)}return{$c:S,images:m}}(e);let l=O.data.ignoreSupportedFormats?null:function(a,M){let O=null;a.supportedCompressionFormats&&(O=a.supportedCompressionFormats.astc?f:a.supportedCompressionFormats.bc7?I:a.supportedCompressionFormats.s3tc?M.$c?m:h:a.supportedCompressionFormats.pvrtc?M.$c?U:d:a.supportedCompressionFormats.etc2?S:a.supportedCompressionFormats.etc1?j:r);return O}(O.data.config,w),P=!1;null===l&&(P=!0,l=w.$c?m:h);let v=!0;e.startTranscoding()||(v=!1);const o=[];for(let j=0;j<w.images.length&&v;j++){const S=w.images[j];if(void 0===a.loadSingleImage||a.loadSingleImage===j){let h=S.levels.length;!1===a.loadMipmapLevels&&(h=1);for(let m=0;m<h;m++){const h=S.levels[m],I=M(e,j,m,l,P);if(!I){v=!1;break}h.transcodedPixels=I,o.push(h.transcodedPixels.buffer)}}}e.close(),e.delete(),P&&(l=-1),v?postMessage({action:"transcode",success:v,id:O.data.id,fileInfo:w,format:l},o):postMessage({action:"transcode",success:v,id:O.data.id})}}}!function(j){j[j.cTFETC1=0]="cTFETC1",j[j.cTFETC2=1]="cTFETC2",j[j.cTFBC1=2]="cTFBC1",j[j.cTFBC3=3]="cTFBC3",j[j.cTFBC4=4]="cTFBC4",j[j.cTFBC5=5]="cTFBC5",j[j.cTFBC7=6]="cTFBC7",j[j.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",j[j.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",j[j.cTFASTC_4x4=10]="cTFASTC_4x4",j[j.cTFATC_RGB=11]="cTFATC_RGB",j[j.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",j[j.cTFRGBA32=13]="cTFRGBA32",j[j.cTFRGB565=14]="cTFRGB565",j[j.cTFBGR565=15]="cTFBGR565",j[j.cTFRGBA4444=16]="cTFRGBA4444",j[j.cTFFXT1_RGB=17]="cTFFXT1_RGB",j[j.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",j[j.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",j[j.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",j[j.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(m||(m={}));const r={JSModuleURL:`${I.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${I.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let a=null,M=null,O=0;const p=()=>(a||(a=new Promise(((j,S)=>{M?j(M):I.e.LoadFileAsync(I.e.GetBabylonScriptURL(r.WasmModuleURL)).then((h=>{if("function"!==typeof URL)return S("Basis transcoder requires an environment with a URL constructor");const m=URL.createObjectURL(new Blob([`(${f})()`],{type:"application/javascript"}));M=new Worker(m),function(j,S,h){return new Promise(((m,d)=>{const U=S=>{"init"===S.data.action?(j.removeEventListener("message",U),m(j)):"error"===S.data.action&&d(S.data.error||"error initializing worker")};j.addEventListener("message",U),j.postMessage({action:"init",url:h?I.e.GetBabylonScriptURL(h):void 0,wasmBinary:S},[S])}))}(M,h,r.JSModuleURL).then(j,S)})).catch(S)}))),a),e=(j,S)=>{const h=j instanceof ArrayBuffer?new Uint8Array(j):j;return new Promise(((j,m)=>{p().then((()=>{const I=O++,d=S=>{"transcode"===S.data.action&&S.data.id===I&&(M.removeEventListener("message",d),S.data.success?j(S.data):m("Transcode is not supported on this device"))};M.addEventListener("message",d);const U=new Uint8Array(h.byteLength);U.set(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),M.postMessage({action:"transcode",id:I,imageData:U,config:S,ignoreSupportedFormats:false},[U.buffer])}),(j=>{m(j)}))}))},w=(j,S)=>{var h;let m=null===(h=S._gl)||void 0===h?void 0:h.TEXTURE_2D;var I;j.isCube&&(m=null===(I=S._gl)||void 0===I?void 0:I.TEXTURE_CUBE_MAP);S._bindTextureDirectly(m,j,!0)},l=(j,S)=>{const h=j.getEngine();for(let f=0;f<S.fileInfo.images.length;f++){const r=S.fileInfo.images[f].levels[0];if(j._invertVScale=j.invertY,-1===S.format||S.format===m.cTFRGB565)if(j.type=10,j.format=4,!h._features.basisNeedsPOT||Math.log2(r.width)%1===0&&Math.log2(r.height)%1===0)j._invertVScale=!j.invertY,j.width=r.width+3&-4,j.height=r.height+3&-4,j.samplingMode=2,w(j,h),h._uploadDataToTextureDirectly(j,new Uint16Array(r.transcodedPixels.buffer),f,0,4,!0);else{const S=new U.b(h,2);j._invertVScale=j.invertY,S.type=10,S.format=4,S.width=r.width+3&-4,S.height=r.height+3&-4,w(S,h),h._uploadDataToTextureDirectly(S,new Uint16Array(r.transcodedPixels.buffer),f,0,4,!0),h._rescaleTexture(S,j,h.scenes[0],h._getInternalFormat(4),(()=>{h._releaseTexture(S),w(j,h)}))}else{j.width=r.width,j.height=r.height,j.generateMipMaps=S.fileInfo.images[f].levels.length>1;const m=P.GetInternalFormatFromBasisFormat(S.format,h);j.format=m,w(j,h),S.fileInfo.images[f].levels.forEach(((S,I)=>{h._uploadCompressedDataToTextureDirectly(j,m,S.width,S.height,S.transcodedPixels,f,I)})),!h._features.basisNeedsPOT||Math.log2(j.width)%1===0&&Math.log2(j.height)%1===0||(I.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),j._cachedWrapU=d.b.CLAMP_ADDRESSMODE,j._cachedWrapV=d.b.CLAMP_ADDRESSMODE)}}},P={JSModuleURL:r.JSModuleURL,WasmModuleURL:r.WasmModuleURL,GetInternalFormatFromBasisFormat:(j,S)=>{let h;switch(j){case m.cTFETC1:h=36196;break;case m.cTFBC1:h=33776;break;case m.cTFBC4:h=33779;break;case m.cTFASTC_4x4:h=37808;break;case m.cTFETC2:h=37496;break;case m.cTFBC7:h=36492}if(void 0===h)throw"The chosen Basis transcoder format is not currently supported";return h},TranscodeAsync:e,LoadTextureFromTranscodeResult:l};Object.defineProperty(P,"JSModuleURL",{get:function(){return r.JSModuleURL},set:function(j){r.JSModuleURL=j}}),Object.defineProperty(P,"WasmModuleURL",{get:function(){return r.WasmModuleURL},set:function(j){r.WasmModuleURL=j}});class v{constructor(){this.supportCascades=!1}loadCubeData(j,S,h,m,d){if(Array.isArray(j))return;const U=S.getEngine().getCaps(),f={supportedCompressionFormats:{etc1:!!U.etc1,s3tc:!!U.s3tc,pvrtc:!!U.pvrtc,etc2:!!U.etc2,astc:!!U.astc,bc7:!!U.bptc}};e(j,f).then((j=>{const h=j.fileInfo.images[0].levels.length>1&&S.generateMipMaps;l(S,j),S.getEngine()._setCubeMapTextureParams(S,h),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),m&&m()})).catch((j=>{I.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.isReady=!0,d&&d(j)}))}loadData(j,S,h){const m=S.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};e(j,d).then((j=>{const m=j.fileInfo.images[0].levels[0],I=j.fileInfo.images[0].levels.length>1&&S.generateMipMaps;h(m.width,m.height,I,-1!==j.format,(()=>{l(S,j)}))})).catch((j=>{I.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.e.Warn(`Failed to transcode Basis file: ${j}`),h(0,0,!1,!1,(()=>{}),!0)}))}}}}]);