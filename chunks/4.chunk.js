"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10361:(d,m,g)=>{g.r(m),g.d(m,{_BasisTextureLoader:()=>O});var V,u=g(1190),D=g(978),j=g(1135);function z(){const d=0,m=1,g=2,V=3,u=6,D=8,j=9,z=10,s=14;let U=null;function X(d,m,g,V,u){const D=d.getImageTranscodedSizeInBytes(m,g,V);let j=new Uint8Array(D);if(!d.transcodeImage(j,m,g,V,1,0))return null;if(u){j=function(d,m,g,V){const u=new Uint16Array(4),D=new Uint16Array(g*V),j=g/4,z=V/4;for(let s=0;s<z;s++)for(let V=0;V<j;V++){const z=m+8*(s*j+V);u[0]=d[z]|d[z+1]<<8,u[1]=d[z+2]|d[z+3]<<8,u[2]=(2*(31&u[0])+1*(31&u[1]))/3|(2*(2016&u[0])+1*(2016&u[1]))/3&2016|(2*(63488&u[0])+1*(63488&u[1]))/3&63488,u[3]=(2*(31&u[1])+1*(31&u[0]))/3|(2*(2016&u[1])+1*(2016&u[0]))/3&2016|(2*(63488&u[1])+1*(63488&u[0]))/3&63488;for(let m=0;m<4;m++){const j=d[z+4+m];let U=(4*s+m)*g+4*V;D[U++]=u[3&j],D[U++]=u[j>>2&3],D[U++]=u[j>>4&3],D[U++]=u[j>>6&3]}}return D}(j,0,d.getImageWidth(m,g)+3&-4,d.getImageHeight(m,g)+3&-4)}return j}onmessage=Y=>{if("init"===Y.data.action){if(Y.data.url)try{importScripts(Y.data.url)}catch(Q){postMessage({action:"error",error:Q})}U||(U=BASIS({wasmBinary:Y.data.wasmBinary})),null!==U&&U.then((d=>{BASIS=d,d.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Y.data.action){const U=Y.data.config,Q=Y.data.imageData,B=new BASIS.BasisFile(Q),i=function(d){const m=d.getHasAlpha(),g=d.getNumImages(),V=[];for(let u=0;u<g;u++){const m={levels:[]},g=d.getNumLevels(u);for(let V=0;V<g;V++){const g={width:d.getImageWidth(u,V),height:d.getImageHeight(u,V)};m.levels.push(g)}V.push(m)}return{qc:m,images:V}}(B);let C=Y.data.ignoreSupportedFormats?null:function(U,X){let Y=null;U.supportedCompressionFormats&&(Y=U.supportedCompressionFormats.astc?z:U.supportedCompressionFormats.bc7?u:U.supportedCompressionFormats.s3tc?X.qc?V:g:U.supportedCompressionFormats.pvrtc?X.qc?j:D:U.supportedCompressionFormats.etc2?m:U.supportedCompressionFormats.etc1?d:s);return Y}(Y.data.config,i),L=!1;null===C&&(L=!0,C=i.qc?V:g);let O=!0;B.startTranscoding()||(O=!1);const R=[];for(let d=0;d<i.images.length&&O;d++){const m=i.images[d];if(void 0===U.loadSingleImage||U.loadSingleImage===d){let g=m.levels.length;!1===U.loadMipmapLevels&&(g=1);for(let V=0;V<g;V++){const g=m.levels[V],u=X(B,d,V,C,L);if(!u){O=!1;break}g.transcodedPixels=u,R.push(g.transcodedPixels.buffer)}}}B.close(),B.delete(),L&&(C=-1),O?postMessage({action:"transcode",success:O,id:Y.data.id,fileInfo:i,format:C},R):postMessage({action:"transcode",success:O,id:Y.data.id})}}}!function(d){d[d.cTFETC1=0]="cTFETC1",d[d.cTFETC2=1]="cTFETC2",d[d.cTFBC1=2]="cTFBC1",d[d.cTFBC3=3]="cTFBC3",d[d.cTFBC4=4]="cTFBC4",d[d.cTFBC5=5]="cTFBC5",d[d.cTFBC7=6]="cTFBC7",d[d.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",d[d.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",d[d.cTFASTC_4x4=10]="cTFASTC_4x4",d[d.cTFATC_RGB=11]="cTFATC_RGB",d[d.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",d[d.cTFRGBA32=13]="cTFRGBA32",d[d.cTFRGB565=14]="cTFRGB565",d[d.cTFBGR565=15]="cTFBGR565",d[d.cTFRGBA4444=16]="cTFRGBA4444",d[d.cTFFXT1_RGB=17]="cTFFXT1_RGB",d[d.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",d[d.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",d[d.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",d[d.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(V||(V={}));const s={JSModuleURL:`${u.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${u.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let U=null,X=null,Y=0;const Q=()=>(U||(U=new Promise(((d,m)=>{X?d(X):u.f.LoadFileAsync(u.f.GetBabylonScriptURL(s.WasmModuleURL)).then((g=>{if("function"!==typeof URL)return m("Basis transcoder requires an environment with a URL constructor");const V=URL.createObjectURL(new Blob([`(${z})()`],{type:"application/javascript"}));X=new Worker(V),function(d,m,g){return new Promise(((V,D)=>{const j=m=>{"init"===m.data.action?(d.removeEventListener("message",j),V(d)):"error"===m.data.action&&D(m.data.error||"error initializing worker")};d.addEventListener("message",j),d.postMessage({action:"init",url:g?u.f.GetBabylonScriptURL(g):void 0,wasmBinary:m},[m])}))}(X,g,s.JSModuleURL).then(d,m)})).catch(m)}))),U),B=(d,m)=>{const g=d instanceof ArrayBuffer?new Uint8Array(d):d;return new Promise(((d,V)=>{Q().then((()=>{const u=Y++,D=m=>{"transcode"===m.data.action&&m.data.id===u&&(X.removeEventListener("message",D),m.data.success?d(m.data):V("Transcode is not supported on this device"))};X.addEventListener("message",D);const j=new Uint8Array(g.byteLength);j.set(new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),X.postMessage({action:"transcode",id:u,imageData:j,config:m,ignoreSupportedFormats:false},[j.buffer])}),(d=>{V(d)}))}))},i=(d,m)=>{var g;let V=null===(g=m._gl)||void 0===g?void 0:g.TEXTURE_2D;var u;d.isCube&&(V=null===(u=m._gl)||void 0===u?void 0:u.TEXTURE_CUBE_MAP);m._bindTextureDirectly(V,d,!0)},C=(d,m)=>{const g=d.getEngine();for(let z=0;z<m.fileInfo.images.length;z++){const s=m.fileInfo.images[z].levels[0];if(d._invertVScale=d.invertY,-1===m.format||m.format===V.cTFRGB565)if(d.type=10,d.format=4,!g._features.basisNeedsPOT||Math.log2(s.width)%1===0&&Math.log2(s.height)%1===0)d._invertVScale=!d.invertY,d.width=s.width+3&-4,d.height=s.height+3&-4,d.samplingMode=2,i(d,g),g._uploadDataToTextureDirectly(d,new Uint16Array(s.transcodedPixels.buffer),z,0,4,!0);else{const m=new j.d(g,2);d._invertVScale=d.invertY,m.type=10,m.format=4,m.width=s.width+3&-4,m.height=s.height+3&-4,i(m,g),g._uploadDataToTextureDirectly(m,new Uint16Array(s.transcodedPixels.buffer),z,0,4,!0),g._rescaleTexture(m,d,g.scenes[0],g._getInternalFormat(4),(()=>{g._releaseTexture(m),i(d,g)}))}else{d.width=s.width,d.height=s.height,d.generateMipMaps=m.fileInfo.images[z].levels.length>1;const V=L.GetInternalFormatFromBasisFormat(m.format,g);d.format=V,i(d,g),m.fileInfo.images[z].levels.forEach(((m,u)=>{g._uploadCompressedDataToTextureDirectly(d,V,m.width,m.height,m.transcodedPixels,z,u)})),!g._features.basisNeedsPOT||Math.log2(d.width)%1===0&&Math.log2(d.height)%1===0||(u.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),d._cachedWrapU=D.e.CLAMP_ADDRESSMODE,d._cachedWrapV=D.e.CLAMP_ADDRESSMODE)}}},L={JSModuleURL:s.JSModuleURL,WasmModuleURL:s.WasmModuleURL,GetInternalFormatFromBasisFormat:(d,m)=>{let g;switch(d){case V.cTFETC1:g=36196;break;case V.cTFBC1:g=33776;break;case V.cTFBC4:g=33779;break;case V.cTFASTC_4x4:g=37808;break;case V.cTFETC2:g=37496;break;case V.cTFBC7:g=36492}if(void 0===g)throw"The chosen Basis transcoder format is not currently supported";return g},TranscodeAsync:B,LoadTextureFromTranscodeResult:C};Object.defineProperty(L,"JSModuleURL",{get:function(){return s.JSModuleURL},set:function(d){s.JSModuleURL=d}}),Object.defineProperty(L,"WasmModuleURL",{get:function(){return s.WasmModuleURL},set:function(d){s.WasmModuleURL=d}});class O{constructor(){this.supportCascades=!1}loadCubeData(d,m,g,V,D){if(Array.isArray(d))return;const j=m.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!j.etc1,s3tc:!!j.s3tc,pvrtc:!!j.pvrtc,etc2:!!j.etc2,astc:!!j.astc,bc7:!!j.bptc}};B(d,z).then((d=>{const g=d.fileInfo.images[0].levels.length>1&&m.generateMipMaps;C(m,d),m.getEngine()._setCubeMapTextureParams(m,g),m.isReady=!0,m.onLoadedObservable.notifyObservers(m),m.onLoadedObservable.clear(),V&&V()})).catch((d=>{u.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),m.isReady=!0,D&&D(d)}))}loadData(d,m,g){const V=m.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};B(d,D).then((d=>{const V=d.fileInfo.images[0].levels[0],u=d.fileInfo.images[0].levels.length>1&&m.generateMipMaps;g(V.width,V.height,u,-1!==d.format,(()=>{C(m,d)}))})).catch((d=>{u.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),u.f.Warn(`Failed to transcode Basis file: ${d}`),g(0,0,!1,!1,(()=>{}),!0)}))}}}}]);