"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10229:(B,q,C)=>{C.r(q),C.d(q,{_BasisTextureLoader:()=>U});var v,m=C(1161),O=C(926),S=C(1089);function D(){const B=0,q=1,C=2,v=3,m=6,O=8,S=9,D=10,R=14;let T=null;function l(B,q,C,v,m){const O=B.getImageTranscodedSizeInBytes(q,C,v);let S=new Uint8Array(O);if(!B.transcodeImage(S,q,C,v,1,0))return null;if(m){S=function(B,q,C,v){const m=new Uint16Array(4),O=new Uint16Array(C*v),S=C/4,D=v/4;for(let R=0;R<D;R++)for(let v=0;v<S;v++){const D=q+8*(R*S+v);m[0]=B[D]|B[D+1]<<8,m[1]=B[D+2]|B[D+3]<<8,m[2]=(2*(31&m[0])+1*(31&m[1]))/3|(2*(2016&m[0])+1*(2016&m[1]))/3&2016|(2*(63488&m[0])+1*(63488&m[1]))/3&63488,m[3]=(2*(31&m[1])+1*(31&m[0]))/3|(2*(2016&m[1])+1*(2016&m[0]))/3&2016|(2*(63488&m[1])+1*(63488&m[0]))/3&63488;for(let q=0;q<4;q++){const S=B[D+4+q];let T=(4*R+q)*C+4*v;O[T++]=m[3&S],O[T++]=m[S>>2&3],O[T++]=m[S>>4&3],O[T++]=m[S>>6&3]}}return O}(S,0,B.getImageWidth(q,C)+3&-4,B.getImageHeight(q,C)+3&-4)}return S}onmessage=z=>{if("init"===z.data.action){if(z.data.url)try{importScripts(z.data.url)}catch(W){postMessage({action:"error",error:W})}T||(T=BASIS({wasmBinary:z.data.wasmBinary})),null!==T&&T.then((B=>{BASIS=B,B.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===z.data.action){const T=z.data.config,W=z.data.imageData,Z=new BASIS.BasisFile(W),G=function(B){const q=B.getHasAlpha(),C=B.getNumImages(),v=[];for(let m=0;m<C;m++){const q={levels:[]},C=B.getNumLevels(m);for(let v=0;v<C;v++){const C={width:B.getImageWidth(m,v),height:B.getImageHeight(m,v)};q.levels.push(C)}v.push(q)}return{ad:q,images:v}}(Z);let y=z.data.ignoreSupportedFormats?null:function(T,l){let z=null;T.supportedCompressionFormats&&(z=T.supportedCompressionFormats.astc?D:T.supportedCompressionFormats.bc7?m:T.supportedCompressionFormats.s3tc?l.ad?v:C:T.supportedCompressionFormats.pvrtc?l.ad?S:O:T.supportedCompressionFormats.etc2?q:T.supportedCompressionFormats.etc1?B:R);return z}(z.data.config,G),e=!1;null===y&&(e=!0,y=G.ad?v:C);let U=!0;Z.startTranscoding()||(U=!1);const s=[];for(let B=0;B<G.images.length&&U;B++){const q=G.images[B];if(void 0===T.loadSingleImage||T.loadSingleImage===B){let C=q.levels.length;!1===T.loadMipmapLevels&&(C=1);for(let v=0;v<C;v++){const C=q.levels[v],m=l(Z,B,v,y,e);if(!m){U=!1;break}C.transcodedPixels=m,s.push(C.transcodedPixels.buffer)}}}Z.close(),Z.delete(),e&&(y=-1),U?postMessage({action:"transcode",success:U,id:z.data.id,fileInfo:G,format:y},s):postMessage({action:"transcode",success:U,id:z.data.id})}}}!function(B){B[B.cTFETC1=0]="cTFETC1",B[B.cTFETC2=1]="cTFETC2",B[B.cTFBC1=2]="cTFBC1",B[B.cTFBC3=3]="cTFBC3",B[B.cTFBC4=4]="cTFBC4",B[B.cTFBC5=5]="cTFBC5",B[B.cTFBC7=6]="cTFBC7",B[B.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",B[B.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",B[B.cTFASTC_4x4=10]="cTFASTC_4x4",B[B.cTFATC_RGB=11]="cTFATC_RGB",B[B.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",B[B.cTFRGBA32=13]="cTFRGBA32",B[B.cTFRGB565=14]="cTFRGB565",B[B.cTFBGR565=15]="cTFBGR565",B[B.cTFRGBA4444=16]="cTFRGBA4444",B[B.cTFFXT1_RGB=17]="cTFFXT1_RGB",B[B.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",B[B.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",B[B.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",B[B.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(v||(v={}));const R={JSModuleURL:`${m.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${m.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let T=null,l=null,z=0;const W=()=>(T||(T=new Promise(((B,q)=>{l?B(l):m.f.LoadFileAsync(m.f.GetBabylonScriptURL(R.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const v=URL.createObjectURL(new Blob([`(${D})()`],{type:"application/javascript"}));l=new Worker(v),function(B,q,C){return new Promise(((v,O)=>{const S=q=>{"init"===q.data.action?(B.removeEventListener("message",S),v(B)):"error"===q.data.action&&O(q.data.error||"error initializing worker")};B.addEventListener("message",S),B.postMessage({action:"init",url:C?m.f.GetBabylonScriptURL(C):void 0,wasmBinary:q},[q])}))}(l,C,R.JSModuleURL).then(B,q)})).catch(q)}))),T),Z=(B,q)=>{const C=B instanceof ArrayBuffer?new Uint8Array(B):B;return new Promise(((B,v)=>{W().then((()=>{const m=z++,O=q=>{"transcode"===q.data.action&&q.data.id===m&&(l.removeEventListener("message",O),q.data.success?B(q.data):v("Transcode is not supported on this device"))};l.addEventListener("message",O);const S=new Uint8Array(C.byteLength);S.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),l.postMessage({action:"transcode",id:m,imageData:S,config:q,ignoreSupportedFormats:false},[S.buffer])}),(B=>{v(B)}))}))},G=(B,q)=>{var C;let v=null===(C=q._gl)||void 0===C?void 0:C.TEXTURE_2D;var m;B.isCube&&(v=null===(m=q._gl)||void 0===m?void 0:m.TEXTURE_CUBE_MAP);q._bindTextureDirectly(v,B,!0)},y=(B,q)=>{const C=B.getEngine();for(let D=0;D<q.fileInfo.images.length;D++){const R=q.fileInfo.images[D].levels[0];if(B._invertVScale=B.invertY,-1===q.format||q.format===v.cTFRGB565)if(B.type=10,B.format=4,!C._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0)B._invertVScale=!B.invertY,B.width=R.width+3&-4,B.height=R.height+3&-4,B.samplingMode=2,G(B,C),C._uploadDataToTextureDirectly(B,new Uint16Array(R.transcodedPixels.buffer),D,0,4,!0);else{const q=new S.e(C,2);B._invertVScale=B.invertY,q.type=10,q.format=4,q.width=R.width+3&-4,q.height=R.height+3&-4,G(q,C),C._uploadDataToTextureDirectly(q,new Uint16Array(R.transcodedPixels.buffer),D,0,4,!0),C._rescaleTexture(q,B,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(q),G(B,C)}))}else{B.width=R.width,B.height=R.height,B.generateMipMaps=q.fileInfo.images[D].levels.length>1;const v=e.GetInternalFormatFromBasisFormat(q.format,C);B.format=v,G(B,C),q.fileInfo.images[D].levels.forEach(((q,m)=>{C._uploadCompressedDataToTextureDirectly(B,v,q.width,q.height,q.transcodedPixels,D,m)})),!C._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0||(m.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),B._cachedWrapU=O.c.CLAMP_ADDRESSMODE,B._cachedWrapV=O.c.CLAMP_ADDRESSMODE)}}},e={JSModuleURL:R.JSModuleURL,WasmModuleURL:R.WasmModuleURL,GetInternalFormatFromBasisFormat:(B,q)=>{let C;switch(B){case v.cTFETC1:C=36196;break;case v.cTFBC1:C=33776;break;case v.cTFBC4:C=33779;break;case v.cTFASTC_4x4:C=37808;break;case v.cTFETC2:C=37496;break;case v.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:Z,LoadTextureFromTranscodeResult:y};Object.defineProperty(e,"JSModuleURL",{get:function(){return R.JSModuleURL},set:function(B){R.JSModuleURL=B}}),Object.defineProperty(e,"WasmModuleURL",{get:function(){return R.WasmModuleURL},set:function(B){R.WasmModuleURL=B}});class U{constructor(){this.supportCascades=!1}loadCubeData(B,q,C,v,O){if(Array.isArray(B))return;const S=q.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};Z(B,D).then((B=>{const C=B.fileInfo.images[0].levels.length>1&&q.generateMipMaps;y(q,B),q.getEngine()._setCubeMapTextureParams(q,C),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),v&&v()})).catch((B=>{m.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,O&&O(B)}))}loadData(B,q,C){const v=q.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};Z(B,O).then((B=>{const v=B.fileInfo.images[0].levels[0],m=B.fileInfo.images[0].levels.length>1&&q.generateMipMaps;C(v.width,v.height,m,-1!==B.format,(()=>{y(q,B)}))})).catch((B=>{m.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),m.f.Warn(`Failed to transcode Basis file: ${B}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);