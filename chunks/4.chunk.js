"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10943:(I,S,d)=>{d.r(S),d.d(S,{_BasisTextureLoader:()=>G});var N,O=d(1216),g=d(992),T=d(1137);function q(){const I=0,S=1,d=2,N=3,O=6,g=8,T=9,q=10,a=14;let f=null;function Y(I,S,d,N,O){const g=I.getImageTranscodedSizeInBytes(S,d,N);let T=new Uint8Array(g);if(!I.transcodeImage(T,S,d,N,1,0))return null;if(O){T=function(I,S,d,N){const O=new Uint16Array(4),g=new Uint16Array(d*N),T=d/4,q=N/4;for(let a=0;a<q;a++)for(let N=0;N<T;N++){const q=S+8*(a*T+N);O[0]=I[q]|I[q+1]<<8,O[1]=I[q+2]|I[q+3]<<8,O[2]=(2*(31&O[0])+1*(31&O[1]))/3|(2*(2016&O[0])+1*(2016&O[1]))/3&2016|(2*(63488&O[0])+1*(63488&O[1]))/3&63488,O[3]=(2*(31&O[1])+1*(31&O[0]))/3|(2*(2016&O[1])+1*(2016&O[0]))/3&2016|(2*(63488&O[1])+1*(63488&O[0]))/3&63488;for(let S=0;S<4;S++){const T=I[q+4+S];let f=(4*a+S)*d+4*N;g[f++]=O[3&T],g[f++]=O[T>>2&3],g[f++]=O[T>>4&3],g[f++]=O[T>>6&3]}}return g}(T,0,I.getImageWidth(S,d)+3&-4,I.getImageHeight(S,d)+3&-4)}return T}onmessage=p=>{if("init"===p.data.action){if(p.data.url)try{importScripts(p.data.url)}catch(E){postMessage({action:"error",error:E})}f||(f=BASIS({wasmBinary:p.data.wasmBinary})),null!==f&&f.then((I=>{BASIS=I,I.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===p.data.action){const f=p.data.config,E=p.data.imageData,o=new BASIS.BasisFile(E),k=function(I){const S=I.getHasAlpha(),d=I.getNumImages(),N=[];for(let O=0;O<d;O++){const S={levels:[]},d=I.getNumLevels(O);for(let N=0;N<d;N++){const d={width:I.getImageWidth(O,N),height:I.getImageHeight(O,N)};S.levels.push(d)}N.push(S)}return{kd:S,images:N}}(o);let U=p.data.ignoreSupportedFormats?null:function(f,Y){let p=null;f.supportedCompressionFormats&&(p=f.supportedCompressionFormats.astc?q:f.supportedCompressionFormats.bc7?O:f.supportedCompressionFormats.s3tc?Y.kd?N:d:f.supportedCompressionFormats.pvrtc?Y.kd?T:g:f.supportedCompressionFormats.etc2?S:f.supportedCompressionFormats.etc1?I:a);return p}(p.data.config,k),i=!1;null===U&&(i=!0,U=k.kd?N:d);let G=!0;o.startTranscoding()||(G=!1);const t=[];for(let I=0;I<k.images.length&&G;I++){const S=k.images[I];if(void 0===f.loadSingleImage||f.loadSingleImage===I){let d=S.levels.length;!1===f.loadMipmapLevels&&(d=1);for(let N=0;N<d;N++){const d=S.levels[N],O=Y(o,I,N,U,i);if(!O){G=!1;break}d.transcodedPixels=O,t.push(d.transcodedPixels.buffer)}}}o.close(),o.delete(),i&&(U=-1),G?postMessage({action:"transcode",success:G,id:p.data.id,fileInfo:k,format:U},t):postMessage({action:"transcode",success:G,id:p.data.id})}}}!function(I){I[I.cTFETC1=0]="cTFETC1",I[I.cTFETC2=1]="cTFETC2",I[I.cTFBC1=2]="cTFBC1",I[I.cTFBC3=3]="cTFBC3",I[I.cTFBC4=4]="cTFBC4",I[I.cTFBC5=5]="cTFBC5",I[I.cTFBC7=6]="cTFBC7",I[I.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",I[I.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",I[I.cTFASTC_4x4=10]="cTFASTC_4x4",I[I.cTFATC_RGB=11]="cTFATC_RGB",I[I.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",I[I.cTFRGBA32=13]="cTFRGBA32",I[I.cTFRGB565=14]="cTFRGB565",I[I.cTFBGR565=15]="cTFBGR565",I[I.cTFRGBA4444=16]="cTFRGBA4444",I[I.cTFFXT1_RGB=17]="cTFFXT1_RGB",I[I.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",I[I.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",I[I.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",I[I.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(N||(N={}));const a={JSModuleURL:`${O.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${O.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let f=null,Y=null,p=0;const E=()=>(f||(f=new Promise(((I,S)=>{Y?I(Y):O.d.LoadFileAsync(O.d.GetBabylonScriptURL(a.WasmModuleURL)).then((d=>{if("function"!==typeof URL)return S("Basis transcoder requires an environment with a URL constructor");const N=URL.createObjectURL(new Blob([`(${q})()`],{type:"application/javascript"}));Y=new Worker(N),function(I,S,d){return new Promise(((N,g)=>{const T=S=>{"init"===S.data.action?(I.removeEventListener("message",T),N(I)):"error"===S.data.action&&g(S.data.error||"error initializing worker")};I.addEventListener("message",T),I.postMessage({action:"init",url:d?O.d.GetBabylonScriptURL(d):void 0,wasmBinary:S},[S])}))}(Y,d,a.JSModuleURL).then(I,S)})).catch(S)}))),f),o=(I,S)=>{const d=I instanceof ArrayBuffer?new Uint8Array(I):I;return new Promise(((I,N)=>{E().then((()=>{const O=p++,g=S=>{"transcode"===S.data.action&&S.data.id===O&&(Y.removeEventListener("message",g),S.data.success?I(S.data):N("Transcode is not supported on this device"))};Y.addEventListener("message",g);const T=new Uint8Array(d.byteLength);T.set(new Uint8Array(d.buffer,d.byteOffset,d.byteLength)),Y.postMessage({action:"transcode",id:O,imageData:T,config:S,ignoreSupportedFormats:false},[T.buffer])}),(I=>{N(I)}))}))},k=(I,S)=>{var d;let N=null===(d=S._gl)||void 0===d?void 0:d.TEXTURE_2D;var O;I.isCube&&(N=null===(O=S._gl)||void 0===O?void 0:O.TEXTURE_CUBE_MAP);S._bindTextureDirectly(N,I,!0)},U=(I,S)=>{const d=I.getEngine();for(let q=0;q<S.fileInfo.images.length;q++){const a=S.fileInfo.images[q].levels[0];if(I._invertVScale=I.invertY,-1===S.format||S.format===N.cTFRGB565)if(I.type=10,I.format=4,!d._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0)I._invertVScale=!I.invertY,I.width=a.width+3&-4,I.height=a.height+3&-4,I.samplingMode=2,k(I,d),d._uploadDataToTextureDirectly(I,new Uint16Array(a.transcodedPixels.buffer),q,0,4,!0);else{const S=new T.e(d,2);I._invertVScale=I.invertY,S.type=10,S.format=4,S.width=a.width+3&-4,S.height=a.height+3&-4,k(S,d),d._uploadDataToTextureDirectly(S,new Uint16Array(a.transcodedPixels.buffer),q,0,4,!0),d._rescaleTexture(S,I,d.scenes[0],d._getInternalFormat(4),(()=>{d._releaseTexture(S),k(I,d)}))}else{I.width=a.width,I.height=a.height,I.generateMipMaps=S.fileInfo.images[q].levels.length>1;const N=i.GetInternalFormatFromBasisFormat(S.format,d);I.format=N,k(I,d),S.fileInfo.images[q].levels.forEach(((S,O)=>{d._uploadCompressedDataToTextureDirectly(I,N,S.width,S.height,S.transcodedPixels,q,O)})),!d._features.basisNeedsPOT||Math.log2(I.width)%1===0&&Math.log2(I.height)%1===0||(O.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),I._cachedWrapU=g.c.CLAMP_ADDRESSMODE,I._cachedWrapV=g.c.CLAMP_ADDRESSMODE)}}},i={JSModuleURL:a.JSModuleURL,WasmModuleURL:a.WasmModuleURL,GetInternalFormatFromBasisFormat:(I,S)=>{let d;switch(I){case N.cTFETC1:d=36196;break;case N.cTFBC1:d=33776;break;case N.cTFBC4:d=33779;break;case N.cTFASTC_4x4:d=37808;break;case N.cTFETC2:d=37496;break;case N.cTFBC7:d=36492}if(void 0===d)throw"The chosen Basis transcoder format is not currently supported";return d},TranscodeAsync:o,LoadTextureFromTranscodeResult:U};Object.defineProperty(i,"JSModuleURL",{get:function(){return a.JSModuleURL},set:function(I){a.JSModuleURL=I}}),Object.defineProperty(i,"WasmModuleURL",{get:function(){return a.WasmModuleURL},set:function(I){a.WasmModuleURL=I}});class G{constructor(){this.supportCascades=!1}loadCubeData(I,S,d,N,g){if(Array.isArray(I))return;const T=S.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};o(I,q).then((I=>{const d=I.fileInfo.images[0].levels.length>1&&S.generateMipMaps;U(S,I),S.getEngine()._setCubeMapTextureParams(S,d),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),N&&N()})).catch((I=>{O.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.isReady=!0,g&&g(I)}))}loadData(I,S,d){const N=S.getEngine().getCaps(),g={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};o(I,g).then((I=>{const N=I.fileInfo.images[0].levels[0],O=I.fileInfo.images[0].levels.length>1&&S.generateMipMaps;d(N.width,N.height,O,-1!==I.format,(()=>{U(S,I)}))})).catch((I=>{O.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.d.Warn(`Failed to transcode Basis file: ${I}`),d(0,0,!1,!1,(()=>{}),!0)}))}}}}]);