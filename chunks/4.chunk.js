"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10605:(p,O,E)=>{E.r(O),E.d(O,{_BasisTextureLoader:()=>H});var e,x=E(1177),F=E(969),q=E(1104);function a(){const p=0,O=1,E=2,e=3,x=6,F=8,q=9,a=10,Y=14;let B=null;function s(p,O,E,e,x){const F=p.getImageTranscodedSizeInBytes(O,E,e);let q=new Uint8Array(F);if(!p.transcodeImage(q,O,E,e,1,0))return null;if(x){q=function(p,O,E,e){const x=new Uint16Array(4),F=new Uint16Array(E*e),q=E/4,a=e/4;for(let Y=0;Y<a;Y++)for(let e=0;e<q;e++){const a=O+8*(Y*q+e);x[0]=p[a]|p[a+1]<<8,x[1]=p[a+2]|p[a+3]<<8,x[2]=(2*(31&x[0])+1*(31&x[1]))/3|(2*(2016&x[0])+1*(2016&x[1]))/3&2016|(2*(63488&x[0])+1*(63488&x[1]))/3&63488,x[3]=(2*(31&x[1])+1*(31&x[0]))/3|(2*(2016&x[1])+1*(2016&x[0]))/3&2016|(2*(63488&x[1])+1*(63488&x[0]))/3&63488;for(let O=0;O<4;O++){const q=p[a+4+O];let B=(4*Y+O)*E+4*e;F[B++]=x[3&q],F[B++]=x[q>>2&3],F[B++]=x[q>>4&3],F[B++]=x[q>>6&3]}}return F}(q,0,p.getImageWidth(O,E)+3&-4,p.getImageHeight(O,E)+3&-4)}return q}onmessage=D=>{if("init"===D.data.action){if(D.data.url)try{importScripts(D.data.url)}catch(Z){postMessage({action:"error",error:Z})}B||(B=BASIS({wasmBinary:D.data.wasmBinary})),null!==B&&B.then((p=>{BASIS=p,p.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===D.data.action){const B=D.data.config,Z=D.data.imageData,m=new BASIS.BasisFile(Z),h=function(p){const O=p.getHasAlpha(),E=p.getNumImages(),e=[];for(let x=0;x<E;x++){const O={levels:[]},E=p.getNumLevels(x);for(let e=0;e<E;e++){const E={width:p.getImageWidth(x,e),height:p.getImageHeight(x,e)};O.levels.push(E)}e.push(O)}return{yd:O,images:e}}(m);let T=D.data.ignoreSupportedFormats?null:function(B,s){let D=null;B.supportedCompressionFormats&&(D=B.supportedCompressionFormats.astc?a:B.supportedCompressionFormats.bc7?x:B.supportedCompressionFormats.s3tc?s.yd?e:E:B.supportedCompressionFormats.pvrtc?s.yd?q:F:B.supportedCompressionFormats.etc2?O:B.supportedCompressionFormats.etc1?p:Y);return D}(D.data.config,h),A=!1;null===T&&(A=!0,T=h.yd?e:E);let H=!0;m.startTranscoding()||(H=!1);const t=[];for(let p=0;p<h.images.length&&H;p++){const O=h.images[p];if(void 0===B.loadSingleImage||B.loadSingleImage===p){let E=O.levels.length;!1===B.loadMipmapLevels&&(E=1);for(let e=0;e<E;e++){const E=O.levels[e],x=s(m,p,e,T,A);if(!x){H=!1;break}E.transcodedPixels=x,t.push(E.transcodedPixels.buffer)}}}m.close(),m.delete(),A&&(T=-1),H?postMessage({action:"transcode",success:H,id:D.data.id,fileInfo:h,format:T},t):postMessage({action:"transcode",success:H,id:D.data.id})}}}!function(p){p[p.cTFETC1=0]="cTFETC1",p[p.cTFETC2=1]="cTFETC2",p[p.cTFBC1=2]="cTFBC1",p[p.cTFBC3=3]="cTFBC3",p[p.cTFBC4=4]="cTFBC4",p[p.cTFBC5=5]="cTFBC5",p[p.cTFBC7=6]="cTFBC7",p[p.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",p[p.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",p[p.cTFASTC_4x4=10]="cTFASTC_4x4",p[p.cTFATC_RGB=11]="cTFATC_RGB",p[p.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",p[p.cTFRGBA32=13]="cTFRGBA32",p[p.cTFRGB565=14]="cTFRGB565",p[p.cTFBGR565=15]="cTFBGR565",p[p.cTFRGBA4444=16]="cTFRGBA4444",p[p.cTFFXT1_RGB=17]="cTFFXT1_RGB",p[p.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",p[p.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",p[p.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",p[p.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(e||(e={}));const Y={JSModuleURL:`${x.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${x.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let B=null,s=null,D=0;const Z=()=>(B||(B=new Promise(((p,O)=>{s?p(s):x.d.LoadFileAsync(x.d.GetBabylonScriptURL(Y.WasmModuleURL)).then((E=>{if("function"!==typeof URL)return O("Basis transcoder requires an environment with a URL constructor");const e=URL.createObjectURL(new Blob([`(${a})()`],{type:"application/javascript"}));s=new Worker(e),function(p,O,E){return new Promise(((e,F)=>{const q=O=>{"init"===O.data.action?(p.removeEventListener("message",q),e(p)):"error"===O.data.action&&F(O.data.error||"error initializing worker")};p.addEventListener("message",q),p.postMessage({action:"init",url:E?x.d.GetBabylonScriptURL(E):void 0,wasmBinary:O},[O])}))}(s,E,Y.JSModuleURL).then(p,O)})).catch(O)}))),B),m=(p,O)=>{const E=p instanceof ArrayBuffer?new Uint8Array(p):p;return new Promise(((p,e)=>{Z().then((()=>{const x=D++,F=O=>{"transcode"===O.data.action&&O.data.id===x&&(s.removeEventListener("message",F),O.data.success?p(O.data):e("Transcode is not supported on this device"))};s.addEventListener("message",F);const q=new Uint8Array(E.byteLength);q.set(new Uint8Array(E.buffer,E.byteOffset,E.byteLength)),s.postMessage({action:"transcode",id:x,imageData:q,config:O,ignoreSupportedFormats:false},[q.buffer])}),(p=>{e(p)}))}))},h=(p,O)=>{var E;let e=null===(E=O._gl)||void 0===E?void 0:E.TEXTURE_2D;var x;p.isCube&&(e=null===(x=O._gl)||void 0===x?void 0:x.TEXTURE_CUBE_MAP);O._bindTextureDirectly(e,p,!0)},T=(p,O)=>{const E=p.getEngine();for(let a=0;a<O.fileInfo.images.length;a++){const Y=O.fileInfo.images[a].levels[0];if(p._invertVScale=p.invertY,-1===O.format||O.format===e.cTFRGB565)if(p.type=10,p.format=4,!E._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0)p._invertVScale=!p.invertY,p.width=Y.width+3&-4,p.height=Y.height+3&-4,p.samplingMode=2,h(p,E),E._uploadDataToTextureDirectly(p,new Uint16Array(Y.transcodedPixels.buffer),a,0,4,!0);else{const O=new q.d(E,2);p._invertVScale=p.invertY,O.type=10,O.format=4,O.width=Y.width+3&-4,O.height=Y.height+3&-4,h(O,E),E._uploadDataToTextureDirectly(O,new Uint16Array(Y.transcodedPixels.buffer),a,0,4,!0),E._rescaleTexture(O,p,E.scenes[0],E._getInternalFormat(4),(()=>{E._releaseTexture(O),h(p,E)}))}else{p.width=Y.width,p.height=Y.height,p.generateMipMaps=O.fileInfo.images[a].levels.length>1;const e=A.GetInternalFormatFromBasisFormat(O.format,E);p.format=e,h(p,E),O.fileInfo.images[a].levels.forEach(((O,x)=>{E._uploadCompressedDataToTextureDirectly(p,e,O.width,O.height,O.transcodedPixels,a,x)})),!E._features.basisNeedsPOT||Math.log2(p.width)%1===0&&Math.log2(p.height)%1===0||(x.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),p._cachedWrapU=F.b.CLAMP_ADDRESSMODE,p._cachedWrapV=F.b.CLAMP_ADDRESSMODE)}}},A={JSModuleURL:Y.JSModuleURL,WasmModuleURL:Y.WasmModuleURL,GetInternalFormatFromBasisFormat:(p,O)=>{let E;switch(p){case e.cTFETC1:E=36196;break;case e.cTFBC1:E=33776;break;case e.cTFBC4:E=33779;break;case e.cTFASTC_4x4:E=37808;break;case e.cTFETC2:E=37496;break;case e.cTFBC7:E=36492}if(void 0===E)throw"The chosen Basis transcoder format is not currently supported";return E},TranscodeAsync:m,LoadTextureFromTranscodeResult:T};Object.defineProperty(A,"JSModuleURL",{get:function(){return Y.JSModuleURL},set:function(p){Y.JSModuleURL=p}}),Object.defineProperty(A,"WasmModuleURL",{get:function(){return Y.WasmModuleURL},set:function(p){Y.WasmModuleURL=p}});class H{constructor(){this.supportCascades=!1}loadCubeData(p,O,E,e,F){if(Array.isArray(p))return;const q=O.getEngine().getCaps(),a={supportedCompressionFormats:{etc1:!!q.etc1,s3tc:!!q.s3tc,pvrtc:!!q.pvrtc,etc2:!!q.etc2,astc:!!q.astc,bc7:!!q.bptc}};m(p,a).then((p=>{const E=p.fileInfo.images[0].levels.length>1&&O.generateMipMaps;T(O,p),O.getEngine()._setCubeMapTextureParams(O,E),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),e&&e()})).catch((p=>{x.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.isReady=!0,F&&F(p)}))}loadData(p,O,E){const e=O.getEngine().getCaps(),F={supportedCompressionFormats:{etc1:!!e.etc1,s3tc:!!e.s3tc,pvrtc:!!e.pvrtc,etc2:!!e.etc2,astc:!!e.astc,bc7:!!e.bptc}};m(p,F).then((p=>{const e=p.fileInfo.images[0].levels[0],x=p.fileInfo.images[0].levels.length>1&&O.generateMipMaps;E(e.width,e.height,x,-1!==p.format,(()=>{T(O,p)}))})).catch((p=>{x.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.d.Warn(`Failed to transcode Basis file: ${p}`),E(0,0,!1,!1,(()=>{}),!0)}))}}}}]);