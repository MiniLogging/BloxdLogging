"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10127:(I,k,i)=>{i.r(k),i.d(k,{_BasisTextureLoader:()=>n});var d,u=i(1179),H=i(951),Y=i(1123);function x(){const I=0,k=1,i=2,d=3,u=6,H=8,Y=9,x=10,j=14;let l=null;function g(I,k,i,d,u){const H=I.getImageTranscodedSizeInBytes(k,i,d);let Y=new Uint8Array(H);if(!I.transcodeImage(Y,k,i,d,1,0))return null;if(u){Y=function(I,k,i,d){const u=new Uint16Array(4),H=new Uint16Array(i*d),Y=i/4,x=d/4;for(let j=0;j<x;j++)for(let d=0;d<Y;d++){const x=k+8*(j*Y+d);u[0]=I[x]|I[x+1]<<8,u[1]=I[x+2]|I[x+3]<<8,u[2]=(2*(31&u[0])+1*(31&u[1]))/3|(2*(2016&u[0])+1*(2016&u[1]))/3&2016|(2*(63488&u[0])+1*(63488&u[1]))/3&63488,u[3]=(2*(31&u[1])+1*(31&u[0]))/3|(2*(2016&u[1])+1*(2016&u[0]))/3&2016|(2*(63488&u[1])+1*(63488&u[0]))/3&63488;for(let k=0;k<4;k++){const Y=I[x+4+k];let l=(4*j+k)*i+4*d;H[l++]=u[3&Y],H[l++]=u[Y>>2&3],H[l++]=u[Y>>4&3],H[l++]=u[Y>>6&3]}}return H}(Y,0,I.getImageWidth(k,i)+3&-4,I.getImageHeight(k,i)+3&-4)}return Y}onmessage=P=>{if("init"===P.data.action){if(P.data.url)try{importScripts(P.data.url)}catch(J){postMessage({action:"error",error:J})}l||(l=BASIS({wasmBinary:P.data.wasmBinary})),null!==l&&l.then((I=>{BASIS=I,I.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===P.data.action){const l=P.data.config,J=P.data.imageData,L=new BASIS.BasisFile(J),s=function(I){const k=I.getHasAlpha(),i=I.getNumImages(),d=[];for(let u=0;u<i;u++){const k={levels:[]},i=I.getNumLevels(u);for(let d=0;d<i;d++){const i={width:I.getImageWidth(u,d),height:I.getImageHeight(u,d)};k.levels.push(i)}d.push(k)}return{Vc:k,images:d}}(L);let h=P.data.ignoreSupportedFormats?null:function(l,g){let P=null;l.supportedCompressionFormats&&(P=l.supportedCompressionFormats.astc?x:l.supportedCompressionFormats.bc7?u:l.supportedCompressionFormats.s3tc?g.Vc?d:i:l.supportedCompressionFormats.pvrtc?g.Vc?Y:H:l.supportedCompressionFormats.etc2?k:l.supportedCompressionFormats.etc1?I:j);return P}(P.data.config,s),Z=!1;null===h&&(Z=!0,h=s.Vc?d:i);let n=!0;L.startTranscoding()||(n=!1);const B=[];for(let I=0;I<s.images.length&&n;I++){const k=s.images[I];if(void 0===l.loadSingleImage||l.loadSingleImage===I){let i=k.levels.length;!1===l.loadMipmapLevels&&(i=1);for(let d=0;d<i;d++){const i=k.levels[d],u=g(L,I,d,h,Z);if(!u){n=!1;break}i.transcodedPixels=u,B.push(i.transcodedPixels.buffer)}}}L.close(),L.delete(),Z&&(h=-1),n?postMessage({action:"transcode",success:n,id:P.data.id,fileInfo:s,format:h},B):postMessage({action:"transcode",success:n,id:P.data.id})}}}!function(I){I[I.cTFETC1=0]="cTFETC1",I[I.cTFETC2=1]="cTFETC2",I[I.cTFBC1=2]="cTFBC1",I[I.cTFBC3=3]="cTFBC3",I[I.cTFBC4=4]="cTFBC4",I[I.cTFBC5=5]="cTFBC5",I[I.cTFBC7=6]="cTFBC7",I[I.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",I[I.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",I[I.cTFASTC_4x4=10]="cTFASTC_4x4",I[I.cTFATC_RGB=11]="cTFATC_RGB",I[I.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",I[I.cTFRGBA32=13]="cTFRGBA32",I[I.cTFRGB565=14]="cTFRGB565",I[I.cTFBGR565=15]="cTFBGR565",I[I.cTFRGBA4444=16]="cTFRGBA4444",I[I.cTFFXT1_RGB=17]="cTFFXT1_RGB",I[I.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",I[I.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",I[I.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",I[I.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(d||(d={}));const j={JSModuleURL:`${u.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${u.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let l=null,g=null,P=0;const J=()=>(l||(l=new Promise(((I,k)=>{g?I(g):u.d.LoadFileAsync(u.d.GetBabylonScriptURL(j.WasmModuleURL)).then((i=>{if("function"!==typeof URL)return k("Basis transcoder requires an environment with a URL constructor");const d=URL.createObjectURL(new Blob([`(${x})()`],{type:"application/javascript"}));g=new Worker(d),function(I,k,i){return new Promise(((d,H)=>{const Y=k=>{"init"===k.data.action?(I.removeEventListener("message",Y),d(I)):"error"===k.data.action&&H(k.data.error||"error initializing worker")};I.addEventListener("message",Y),I.postMessage({action:"init",url:i?u.d.GetBabylonScriptURL(i):void 0,wasmBinary:k},[k])}))}(g,i,j.JSModuleURL).then(I,k)})).catch(k)}))),l),L=(I,k)=>{const i=I instanceof ArrayBuffer?new Uint8Array(I):I;return new Promise(((I,d)=>{J().then((()=>{const u=P++,H=k=>{"transcode"===k.data.action&&k.data.id===u&&(g.removeEventListener("message",H),k.data.success?I(k.data):d("Transcode is not supported on this device"))};g.addEventListener("message",H);const Y=new Uint8Array(i.byteLength);Y.set(new Uint8Array(i.buffer,i.byteOffset,i.byteLength)),g.postMessage({action:"transcode",id:u,imageData:Y,config:k,ignoreSupportedFormats:false},[Y.buffer])}),(I=>{d(I)}))}))},s=(I,k)=>{var i;let d=null===(i=k._gl)||void 0===i?void 0:i.TEXTURE_2D;var u;I.isCube&&(d=null===(u=k._gl)||void 0===u?void 0:u.TEXTURE_CUBE_MAP);k._bindTextureDirectly(d,I,!0)},h=(I,k)=>{const i=I.getEngine();for(let x=0;x<k.fileInfo.images.length;x++){const j=k.fileInfo.images[x].levels[0];if(I._invertVScale=I.invertY,-1===k.format||k.format===d.cTFRGB565)if(I.type=10,I.format=4,!i._features.basisNeedsPOT||Math.log2(j.width)%1===0&&Math.log2(j.height)%1===0)I._invertVScale=!I.invertY,I.width=j.width+3&-4,I.height=j.height+3&-4,I.samplingMode=2,s(I,i),i._uploadDataToTextureDirectly(I,new Uint16Array(j.transcodedPixels.buffer),x,0,4,!0);else{const k=new Y.c(i,2);I._invertVScale=I.invertY,k.type=10,k.format=4,k.width=j.width+3&-4,k.height=j.height+3&-4,s(k,i),i._uploadDataToTextureDirectly(k,new Uint16Array(j.transcodedPixels.buffer),x,0,4,!0),i._rescaleTexture(k,I,i.scenes[0],i._getInternalFormat(4),(()=>{i._releaseTexture(k),s(I,i)}))}else{I.width=j.width,I.height=j.height,I.generateMipMaps=k.fileInfo.images[x].levels.length>1;const d=Z.GetInternalFormatFromBasisFormat(k.format,i);I.format=d,s(I,i),k.fileInfo.images[x].levels.forEach(((k,u)=>{i._uploadCompressedDataToTextureDirectly(I,d,k.width,k.height,k.transcodedPixels,x,u)})),!i._features.basisNeedsPOT||Math.log2(I.width)%1===0&&Math.log2(I.height)%1===0||(u.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),I._cachedWrapU=H.c.CLAMP_ADDRESSMODE,I._cachedWrapV=H.c.CLAMP_ADDRESSMODE)}}},Z={JSModuleURL:j.JSModuleURL,WasmModuleURL:j.WasmModuleURL,GetInternalFormatFromBasisFormat:(I,k)=>{let i;switch(I){case d.cTFETC1:i=36196;break;case d.cTFBC1:i=33776;break;case d.cTFBC4:i=33779;break;case d.cTFASTC_4x4:i=37808;break;case d.cTFETC2:i=37496;break;case d.cTFBC7:i=36492}if(void 0===i)throw"The chosen Basis transcoder format is not currently supported";return i},TranscodeAsync:L,LoadTextureFromTranscodeResult:h};Object.defineProperty(Z,"JSModuleURL",{get:function(){return j.JSModuleURL},set:function(I){j.JSModuleURL=I}}),Object.defineProperty(Z,"WasmModuleURL",{get:function(){return j.WasmModuleURL},set:function(I){j.WasmModuleURL=I}});class n{constructor(){this.supportCascades=!1}loadCubeData(I,k,i,d,H){if(Array.isArray(I))return;const Y=k.getEngine().getCaps(),x={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};L(I,x).then((I=>{const i=I.fileInfo.images[0].levels.length>1&&k.generateMipMaps;h(k,I),k.getEngine()._setCubeMapTextureParams(k,i),k.isReady=!0,k.onLoadedObservable.notifyObservers(k),k.onLoadedObservable.clear(),d&&d()})).catch((I=>{u.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.isReady=!0,H&&H(I)}))}loadData(I,k,i){const d=k.getEngine().getCaps(),H={supportedCompressionFormats:{etc1:!!d.etc1,s3tc:!!d.s3tc,pvrtc:!!d.pvrtc,etc2:!!d.etc2,astc:!!d.astc,bc7:!!d.bptc}};L(I,H).then((I=>{const d=I.fileInfo.images[0].levels[0],u=I.fileInfo.images[0].levels.length>1&&k.generateMipMaps;i(d.width,d.height,u,-1!==I.format,(()=>{h(k,I)}))})).catch((I=>{u.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),u.d.Warn(`Failed to transcode Basis file: ${I}`),i(0,0,!1,!1,(()=>{}),!0)}))}}}}]);