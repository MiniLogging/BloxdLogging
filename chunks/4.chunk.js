"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10954:(T,z,X)=>{X.r(z),X.d(z,{_BasisTextureLoader:()=>s});var b,F=X(1166),A=X(949),u=X(1102);function y(){const T=0,z=1,X=2,b=3,F=6,A=8,u=9,y=10,E=14;let v=null;function k(T,z,X,b,F){const A=T.getImageTranscodedSizeInBytes(z,X,b);let u=new Uint8Array(A);if(!T.transcodeImage(u,z,X,b,1,0))return null;if(F){u=function(T,z,X,b){const F=new Uint16Array(4),A=new Uint16Array(X*b),u=X/4,y=b/4;for(let E=0;E<y;E++)for(let b=0;b<u;b++){const y=z+8*(E*u+b);F[0]=T[y]|T[y+1]<<8,F[1]=T[y+2]|T[y+3]<<8,F[2]=(2*(31&F[0])+1*(31&F[1]))/3|(2*(2016&F[0])+1*(2016&F[1]))/3&2016|(2*(63488&F[0])+1*(63488&F[1]))/3&63488,F[3]=(2*(31&F[1])+1*(31&F[0]))/3|(2*(2016&F[1])+1*(2016&F[0]))/3&2016|(2*(63488&F[1])+1*(63488&F[0]))/3&63488;for(let z=0;z<4;z++){const u=T[y+4+z];let v=(4*E+z)*X+4*b;A[v++]=F[3&u],A[v++]=F[u>>2&3],A[v++]=F[u>>4&3],A[v++]=F[u>>6&3]}}return A}(u,0,T.getImageWidth(z,X)+3&-4,T.getImageHeight(z,X)+3&-4)}return u}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(D){postMessage({action:"error",error:D})}v||(v=BASIS({wasmBinary:L.data.wasmBinary})),null!==v&&v.then((T=>{BASIS=T,T.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const v=L.data.config,D=L.data.imageData,c=new BASIS.BasisFile(D),p=function(T){const z=T.getHasAlpha(),X=T.getNumImages(),b=[];for(let F=0;F<X;F++){const z={levels:[]},X=T.getNumLevels(F);for(let b=0;b<X;b++){const X={width:T.getImageWidth(F,b),height:T.getImageHeight(F,b)};z.levels.push(X)}b.push(z)}return{ld:z,images:b}}(c);let H=L.data.ignoreSupportedFormats?null:function(v,k){let L=null;v.supportedCompressionFormats&&(L=v.supportedCompressionFormats.astc?y:v.supportedCompressionFormats.bc7?F:v.supportedCompressionFormats.s3tc?k.ld?b:X:v.supportedCompressionFormats.pvrtc?k.ld?u:A:v.supportedCompressionFormats.etc2?z:v.supportedCompressionFormats.etc1?T:E);return L}(L.data.config,p),U=!1;null===H&&(U=!0,H=p.ld?b:X);let s=!0;c.startTranscoding()||(s=!1);const x=[];for(let T=0;T<p.images.length&&s;T++){const z=p.images[T];if(void 0===v.loadSingleImage||v.loadSingleImage===T){let X=z.levels.length;!1===v.loadMipmapLevels&&(X=1);for(let b=0;b<X;b++){const X=z.levels[b],F=k(c,T,b,H,U);if(!F){s=!1;break}X.transcodedPixels=F,x.push(X.transcodedPixels.buffer)}}}c.close(),c.delete(),U&&(H=-1),s?postMessage({action:"transcode",success:s,id:L.data.id,fileInfo:p,format:H},x):postMessage({action:"transcode",success:s,id:L.data.id})}}}!function(T){T[T.cTFETC1=0]="cTFETC1",T[T.cTFETC2=1]="cTFETC2",T[T.cTFBC1=2]="cTFBC1",T[T.cTFBC3=3]="cTFBC3",T[T.cTFBC4=4]="cTFBC4",T[T.cTFBC5=5]="cTFBC5",T[T.cTFBC7=6]="cTFBC7",T[T.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",T[T.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",T[T.cTFASTC_4x4=10]="cTFASTC_4x4",T[T.cTFATC_RGB=11]="cTFATC_RGB",T[T.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",T[T.cTFRGBA32=13]="cTFRGBA32",T[T.cTFRGB565=14]="cTFRGB565",T[T.cTFBGR565=15]="cTFBGR565",T[T.cTFRGBA4444=16]="cTFRGBA4444",T[T.cTFFXT1_RGB=17]="cTFFXT1_RGB",T[T.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",T[T.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",T[T.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",T[T.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(b||(b={}));const E={JSModuleURL:`${F.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${F.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let v=null,k=null,L=0;const D=()=>(v||(v=new Promise(((T,z)=>{k?T(k):F.g.LoadFileAsync(F.g.GetBabylonScriptURL(E.WasmModuleURL)).then((X=>{if("function"!==typeof URL)return z("Basis transcoder requires an environment with a URL constructor");const b=URL.createObjectURL(new Blob([`(${y})()`],{type:"application/javascript"}));k=new Worker(b),function(T,z,X){return new Promise(((b,A)=>{const u=z=>{"init"===z.data.action?(T.removeEventListener("message",u),b(T)):"error"===z.data.action&&A(z.data.error||"error initializing worker")};T.addEventListener("message",u),T.postMessage({action:"init",url:X?F.g.GetBabylonScriptURL(X):void 0,wasmBinary:z},[z])}))}(k,X,E.JSModuleURL).then(T,z)})).catch(z)}))),v),c=(T,z)=>{const X=T instanceof ArrayBuffer?new Uint8Array(T):T;return new Promise(((T,b)=>{D().then((()=>{const F=L++,A=z=>{"transcode"===z.data.action&&z.data.id===F&&(k.removeEventListener("message",A),z.data.success?T(z.data):b("Transcode is not supported on this device"))};k.addEventListener("message",A);const u=new Uint8Array(X.byteLength);u.set(new Uint8Array(X.buffer,X.byteOffset,X.byteLength)),k.postMessage({action:"transcode",id:F,imageData:u,config:z,ignoreSupportedFormats:false},[u.buffer])}),(T=>{b(T)}))}))},p=(T,z)=>{var X;let b=null===(X=z._gl)||void 0===X?void 0:X.TEXTURE_2D;var F;T.isCube&&(b=null===(F=z._gl)||void 0===F?void 0:F.TEXTURE_CUBE_MAP);z._bindTextureDirectly(b,T,!0)},H=(T,z)=>{const X=T.getEngine();for(let y=0;y<z.fileInfo.images.length;y++){const E=z.fileInfo.images[y].levels[0];if(T._invertVScale=T.invertY,-1===z.format||z.format===b.cTFRGB565)if(T.type=10,T.format=4,!X._features.basisNeedsPOT||Math.log2(E.width)%1===0&&Math.log2(E.height)%1===0)T._invertVScale=!T.invertY,T.width=E.width+3&-4,T.height=E.height+3&-4,T.samplingMode=2,p(T,X),X._uploadDataToTextureDirectly(T,new Uint16Array(E.transcodedPixels.buffer),y,0,4,!0);else{const z=new u.b(X,2);T._invertVScale=T.invertY,z.type=10,z.format=4,z.width=E.width+3&-4,z.height=E.height+3&-4,p(z,X),X._uploadDataToTextureDirectly(z,new Uint16Array(E.transcodedPixels.buffer),y,0,4,!0),X._rescaleTexture(z,T,X.scenes[0],X._getInternalFormat(4),(()=>{X._releaseTexture(z),p(T,X)}))}else{T.width=E.width,T.height=E.height,T.generateMipMaps=z.fileInfo.images[y].levels.length>1;const b=U.GetInternalFormatFromBasisFormat(z.format,X);T.format=b,p(T,X),z.fileInfo.images[y].levels.forEach(((z,F)=>{X._uploadCompressedDataToTextureDirectly(T,b,z.width,z.height,z.transcodedPixels,y,F)})),!X._features.basisNeedsPOT||Math.log2(T.width)%1===0&&Math.log2(T.height)%1===0||(F.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),T._cachedWrapU=A.c.CLAMP_ADDRESSMODE,T._cachedWrapV=A.c.CLAMP_ADDRESSMODE)}}},U={JSModuleURL:E.JSModuleURL,WasmModuleURL:E.WasmModuleURL,GetInternalFormatFromBasisFormat:(T,z)=>{let X;switch(T){case b.cTFETC1:X=36196;break;case b.cTFBC1:X=33776;break;case b.cTFBC4:X=33779;break;case b.cTFASTC_4x4:X=37808;break;case b.cTFETC2:X=37496;break;case b.cTFBC7:X=36492}if(void 0===X)throw"The chosen Basis transcoder format is not currently supported";return X},TranscodeAsync:c,LoadTextureFromTranscodeResult:H};Object.defineProperty(U,"JSModuleURL",{get:function(){return E.JSModuleURL},set:function(T){E.JSModuleURL=T}}),Object.defineProperty(U,"WasmModuleURL",{get:function(){return E.WasmModuleURL},set:function(T){E.WasmModuleURL=T}});class s{constructor(){this.supportCascades=!1}loadCubeData(T,z,X,b,A){if(Array.isArray(T))return;const u=z.getEngine().getCaps(),y={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};c(T,y).then((T=>{const X=T.fileInfo.images[0].levels.length>1&&z.generateMipMaps;H(z,T),z.getEngine()._setCubeMapTextureParams(z,X),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),b&&b()})).catch((T=>{F.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.isReady=!0,A&&A(T)}))}loadData(T,z,X){const b=z.getEngine().getCaps(),A={supportedCompressionFormats:{etc1:!!b.etc1,s3tc:!!b.s3tc,pvrtc:!!b.pvrtc,etc2:!!b.etc2,astc:!!b.astc,bc7:!!b.bptc}};c(T,A).then((T=>{const b=T.fileInfo.images[0].levels[0],F=T.fileInfo.images[0].levels.length>1&&z.generateMipMaps;X(b.width,b.height,F,-1!==T.format,(()=>{H(z,T)}))})).catch((T=>{F.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),F.g.Warn(`Failed to transcode Basis file: ${T}`),X(0,0,!1,!1,(()=>{}),!0)}))}}}}]);