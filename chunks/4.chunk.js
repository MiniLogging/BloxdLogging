"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10236:(N,Z,d)=>{d.r(Z),d.d(Z,{_BasisTextureLoader:()=>U});var X,I=d(1133),m=d(938),z=d(1080);function w(){const N=0,Z=1,d=2,X=3,I=6,m=8,z=9,w=10,S=14;let e=null;function j(N,Z,d,X,I){const m=N.getImageTranscodedSizeInBytes(Z,d,X);let z=new Uint8Array(m);if(!N.transcodeImage(z,Z,d,X,1,0))return null;if(I){z=function(N,Z,d,X){const I=new Uint16Array(4),m=new Uint16Array(d*X),z=d/4,w=X/4;for(let S=0;S<w;S++)for(let X=0;X<z;X++){const w=Z+8*(S*z+X);I[0]=N[w]|N[w+1]<<8,I[1]=N[w+2]|N[w+3]<<8,I[2]=(2*(31&I[0])+1*(31&I[1]))/3|(2*(2016&I[0])+1*(2016&I[1]))/3&2016|(2*(63488&I[0])+1*(63488&I[1]))/3&63488,I[3]=(2*(31&I[1])+1*(31&I[0]))/3|(2*(2016&I[1])+1*(2016&I[0]))/3&2016|(2*(63488&I[1])+1*(63488&I[0]))/3&63488;for(let Z=0;Z<4;Z++){const z=N[w+4+Z];let e=(4*S+Z)*d+4*X;m[e++]=I[3&z],m[e++]=I[z>>2&3],m[e++]=I[z>>4&3],m[e++]=I[z>>6&3]}}return m}(z,0,N.getImageWidth(Z,d)+3&-4,N.getImageHeight(Z,d)+3&-4)}return z}onmessage=B=>{if("init"===B.data.action){if(B.data.url)try{importScripts(B.data.url)}catch(D){postMessage({action:"error",error:D})}e||(e=BASIS({wasmBinary:B.data.wasmBinary})),null!==e&&e.then((N=>{BASIS=N,N.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===B.data.action){const e=B.data.config,D=B.data.imageData,v=new BASIS.BasisFile(D),T=function(N){const Z=N.getHasAlpha(),d=N.getNumImages(),X=[];for(let I=0;I<d;I++){const Z={levels:[]},d=N.getNumLevels(I);for(let X=0;X<d;X++){const d={width:N.getImageWidth(I,X),height:N.getImageHeight(I,X)};Z.levels.push(d)}X.push(Z)}return{Wc:Z,images:X}}(v);let k=B.data.ignoreSupportedFormats?null:function(e,j){let B=null;e.supportedCompressionFormats&&(B=e.supportedCompressionFormats.astc?w:e.supportedCompressionFormats.bc7?I:e.supportedCompressionFormats.s3tc?j.Wc?X:d:e.supportedCompressionFormats.pvrtc?j.Wc?z:m:e.supportedCompressionFormats.etc2?Z:e.supportedCompressionFormats.etc1?N:S);return B}(B.data.config,T),h=!1;null===k&&(h=!0,k=T.Wc?X:d);let U=!0;v.startTranscoding()||(U=!1);const C=[];for(let N=0;N<T.images.length&&U;N++){const Z=T.images[N];if(void 0===e.loadSingleImage||e.loadSingleImage===N){let d=Z.levels.length;!1===e.loadMipmapLevels&&(d=1);for(let X=0;X<d;X++){const d=Z.levels[X],I=j(v,N,X,k,h);if(!I){U=!1;break}d.transcodedPixels=I,C.push(d.transcodedPixels.buffer)}}}v.close(),v.delete(),h&&(k=-1),U?postMessage({action:"transcode",success:U,id:B.data.id,fileInfo:T,format:k},C):postMessage({action:"transcode",success:U,id:B.data.id})}}}!function(N){N[N.cTFETC1=0]="cTFETC1",N[N.cTFETC2=1]="cTFETC2",N[N.cTFBC1=2]="cTFBC1",N[N.cTFBC3=3]="cTFBC3",N[N.cTFBC4=4]="cTFBC4",N[N.cTFBC5=5]="cTFBC5",N[N.cTFBC7=6]="cTFBC7",N[N.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",N[N.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",N[N.cTFASTC_4x4=10]="cTFASTC_4x4",N[N.cTFATC_RGB=11]="cTFATC_RGB",N[N.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",N[N.cTFRGBA32=13]="cTFRGBA32",N[N.cTFRGB565=14]="cTFRGB565",N[N.cTFBGR565=15]="cTFBGR565",N[N.cTFRGBA4444=16]="cTFRGBA4444",N[N.cTFFXT1_RGB=17]="cTFFXT1_RGB",N[N.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",N[N.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",N[N.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",N[N.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(X||(X={}));const S={JSModuleURL:`${I.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${I.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let e=null,j=null,B=0;const D=()=>(e||(e=new Promise(((N,Z)=>{j?N(j):I.g.LoadFileAsync(I.g.GetBabylonScriptURL(S.WasmModuleURL)).then((d=>{if("function"!==typeof URL)return Z("Basis transcoder requires an environment with a URL constructor");const X=URL.createObjectURL(new Blob([`(${w})()`],{type:"application/javascript"}));j=new Worker(X),function(N,Z,d){return new Promise(((X,m)=>{const z=Z=>{"init"===Z.data.action?(N.removeEventListener("message",z),X(N)):"error"===Z.data.action&&m(Z.data.error||"error initializing worker")};N.addEventListener("message",z),N.postMessage({action:"init",url:d?I.g.GetBabylonScriptURL(d):void 0,wasmBinary:Z},[Z])}))}(j,d,S.JSModuleURL).then(N,Z)})).catch(Z)}))),e),v=(N,Z)=>{const d=N instanceof ArrayBuffer?new Uint8Array(N):N;return new Promise(((N,X)=>{D().then((()=>{const I=B++,m=Z=>{"transcode"===Z.data.action&&Z.data.id===I&&(j.removeEventListener("message",m),Z.data.success?N(Z.data):X("Transcode is not supported on this device"))};j.addEventListener("message",m);const z=new Uint8Array(d.byteLength);z.set(new Uint8Array(d.buffer,d.byteOffset,d.byteLength)),j.postMessage({action:"transcode",id:I,imageData:z,config:Z,ignoreSupportedFormats:false},[z.buffer])}),(N=>{X(N)}))}))},T=(N,Z)=>{var d;let X=null===(d=Z._gl)||void 0===d?void 0:d.TEXTURE_2D;var I;N.isCube&&(X=null===(I=Z._gl)||void 0===I?void 0:I.TEXTURE_CUBE_MAP);Z._bindTextureDirectly(X,N,!0)},k=(N,Z)=>{const d=N.getEngine();for(let w=0;w<Z.fileInfo.images.length;w++){const S=Z.fileInfo.images[w].levels[0];if(N._invertVScale=N.invertY,-1===Z.format||Z.format===X.cTFRGB565)if(N.type=10,N.format=4,!d._features.basisNeedsPOT||Math.log2(S.width)%1===0&&Math.log2(S.height)%1===0)N._invertVScale=!N.invertY,N.width=S.width+3&-4,N.height=S.height+3&-4,N.samplingMode=2,T(N,d),d._uploadDataToTextureDirectly(N,new Uint16Array(S.transcodedPixels.buffer),w,0,4,!0);else{const Z=new z.d(d,2);N._invertVScale=N.invertY,Z.type=10,Z.format=4,Z.width=S.width+3&-4,Z.height=S.height+3&-4,T(Z,d),d._uploadDataToTextureDirectly(Z,new Uint16Array(S.transcodedPixels.buffer),w,0,4,!0),d._rescaleTexture(Z,N,d.scenes[0],d._getInternalFormat(4),(()=>{d._releaseTexture(Z),T(N,d)}))}else{N.width=S.width,N.height=S.height,N.generateMipMaps=Z.fileInfo.images[w].levels.length>1;const X=h.GetInternalFormatFromBasisFormat(Z.format,d);N.format=X,T(N,d),Z.fileInfo.images[w].levels.forEach(((Z,I)=>{d._uploadCompressedDataToTextureDirectly(N,X,Z.width,Z.height,Z.transcodedPixels,w,I)})),!d._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0||(I.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),N._cachedWrapU=m.c.CLAMP_ADDRESSMODE,N._cachedWrapV=m.c.CLAMP_ADDRESSMODE)}}},h={JSModuleURL:S.JSModuleURL,WasmModuleURL:S.WasmModuleURL,GetInternalFormatFromBasisFormat:(N,Z)=>{let d;switch(N){case X.cTFETC1:d=36196;break;case X.cTFBC1:d=33776;break;case X.cTFBC4:d=33779;break;case X.cTFASTC_4x4:d=37808;break;case X.cTFETC2:d=37496;break;case X.cTFBC7:d=36492}if(void 0===d)throw"The chosen Basis transcoder format is not currently supported";return d},TranscodeAsync:v,LoadTextureFromTranscodeResult:k};Object.defineProperty(h,"JSModuleURL",{get:function(){return S.JSModuleURL},set:function(N){S.JSModuleURL=N}}),Object.defineProperty(h,"WasmModuleURL",{get:function(){return S.WasmModuleURL},set:function(N){S.WasmModuleURL=N}});class U{constructor(){this.supportCascades=!1}loadCubeData(N,Z,d,X,m){if(Array.isArray(N))return;const z=Z.getEngine().getCaps(),w={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};v(N,w).then((N=>{const d=N.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;k(Z,N),Z.getEngine()._setCubeMapTextureParams(Z,d),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),X&&X()})).catch((N=>{I.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.isReady=!0,m&&m(N)}))}loadData(N,Z,d){const X=Z.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};v(N,m).then((N=>{const X=N.fileInfo.images[0].levels[0],I=N.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;d(X.width,X.height,I,-1!==N.format,(()=>{k(Z,N)}))})).catch((N=>{I.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.g.Warn(`Failed to transcode Basis file: ${N}`),d(0,0,!1,!1,(()=>{}),!0)}))}}}}]);