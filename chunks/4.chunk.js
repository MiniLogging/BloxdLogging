"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10421:(U,b,e)=>{e.r(b),e.d(b,{_BasisTextureLoader:()=>A});var K,p=e(1147),m=e(918),i=e(1082);function D(){const U=0,b=1,e=2,K=3,p=6,m=8,i=9,D=10,S=14;let u=null;function r(U,b,e,K,p){const m=U.getImageTranscodedSizeInBytes(b,e,K);let i=new Uint8Array(m);if(!U.transcodeImage(i,b,e,K,1,0))return null;if(p){i=function(U,b,e,K){const p=new Uint16Array(4),m=new Uint16Array(e*K),i=e/4,D=K/4;for(let S=0;S<D;S++)for(let K=0;K<i;K++){const D=b+8*(S*i+K);p[0]=U[D]|U[D+1]<<8,p[1]=U[D+2]|U[D+3]<<8,p[2]=(2*(31&p[0])+1*(31&p[1]))/3|(2*(2016&p[0])+1*(2016&p[1]))/3&2016|(2*(63488&p[0])+1*(63488&p[1]))/3&63488,p[3]=(2*(31&p[1])+1*(31&p[0]))/3|(2*(2016&p[1])+1*(2016&p[0]))/3&2016|(2*(63488&p[1])+1*(63488&p[0]))/3&63488;for(let b=0;b<4;b++){const i=U[D+4+b];let u=(4*S+b)*e+4*K;m[u++]=p[3&i],m[u++]=p[i>>2&3],m[u++]=p[i>>4&3],m[u++]=p[i>>6&3]}}return m}(i,0,U.getImageWidth(b,e)+3&-4,U.getImageHeight(b,e)+3&-4)}return i}onmessage=W=>{if("init"===W.data.action){if(W.data.url)try{importScripts(W.data.url)}catch(f){postMessage({action:"error",error:f})}u||(u=BASIS({wasmBinary:W.data.wasmBinary})),null!==u&&u.then((U=>{BASIS=U,U.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===W.data.action){const u=W.data.config,f=W.data.imageData,l=new BASIS.BasisFile(f),P=function(U){const b=U.getHasAlpha(),e=U.getNumImages(),K=[];for(let p=0;p<e;p++){const b={levels:[]},e=U.getNumLevels(p);for(let K=0;K<e;K++){const e={width:U.getImageWidth(p,K),height:U.getImageHeight(p,K)};b.levels.push(e)}K.push(b)}return{ad:b,images:K}}(l);let G=W.data.ignoreSupportedFormats?null:function(u,r){let W=null;u.supportedCompressionFormats&&(W=u.supportedCompressionFormats.astc?D:u.supportedCompressionFormats.bc7?p:u.supportedCompressionFormats.s3tc?r.ad?K:e:u.supportedCompressionFormats.pvrtc?r.ad?i:m:u.supportedCompressionFormats.etc2?b:u.supportedCompressionFormats.etc1?U:S);return W}(W.data.config,P),E=!1;null===G&&(E=!0,G=P.ad?K:e);let A=!0;l.startTranscoding()||(A=!1);const Y=[];for(let U=0;U<P.images.length&&A;U++){const b=P.images[U];if(void 0===u.loadSingleImage||u.loadSingleImage===U){let e=b.levels.length;!1===u.loadMipmapLevels&&(e=1);for(let K=0;K<e;K++){const e=b.levels[K],p=r(l,U,K,G,E);if(!p){A=!1;break}e.transcodedPixels=p,Y.push(e.transcodedPixels.buffer)}}}l.close(),l.delete(),E&&(G=-1),A?postMessage({action:"transcode",success:A,id:W.data.id,fileInfo:P,format:G},Y):postMessage({action:"transcode",success:A,id:W.data.id})}}}!function(U){U[U.cTFETC1=0]="cTFETC1",U[U.cTFETC2=1]="cTFETC2",U[U.cTFBC1=2]="cTFBC1",U[U.cTFBC3=3]="cTFBC3",U[U.cTFBC4=4]="cTFBC4",U[U.cTFBC5=5]="cTFBC5",U[U.cTFBC7=6]="cTFBC7",U[U.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",U[U.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",U[U.cTFASTC_4x4=10]="cTFASTC_4x4",U[U.cTFATC_RGB=11]="cTFATC_RGB",U[U.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",U[U.cTFRGBA32=13]="cTFRGBA32",U[U.cTFRGB565=14]="cTFRGB565",U[U.cTFBGR565=15]="cTFBGR565",U[U.cTFRGBA4444=16]="cTFRGBA4444",U[U.cTFFXT1_RGB=17]="cTFFXT1_RGB",U[U.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",U[U.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",U[U.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",U[U.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(K||(K={}));const S={JSModuleURL:`${p.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${p.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let u=null,r=null,W=0;const f=()=>(u||(u=new Promise(((U,b)=>{r?U(r):p.g.LoadFileAsync(p.g.GetBabylonScriptURL(S.WasmModuleURL)).then((e=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const K=URL.createObjectURL(new Blob([`(${D})()`],{type:"application/javascript"}));r=new Worker(K),function(U,b,e){return new Promise(((K,m)=>{const i=b=>{"init"===b.data.action?(U.removeEventListener("message",i),K(U)):"error"===b.data.action&&m(b.data.error||"error initializing worker")};U.addEventListener("message",i),U.postMessage({action:"init",url:e?p.g.GetBabylonScriptURL(e):void 0,wasmBinary:b},[b])}))}(r,e,S.JSModuleURL).then(U,b)})).catch(b)}))),u),l=(U,b)=>{const e=U instanceof ArrayBuffer?new Uint8Array(U):U;return new Promise(((U,K)=>{f().then((()=>{const p=W++,m=b=>{"transcode"===b.data.action&&b.data.id===p&&(r.removeEventListener("message",m),b.data.success?U(b.data):K("Transcode is not supported on this device"))};r.addEventListener("message",m);const i=new Uint8Array(e.byteLength);i.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),r.postMessage({action:"transcode",id:p,imageData:i,config:b,ignoreSupportedFormats:false},[i.buffer])}),(U=>{K(U)}))}))},P=(U,b)=>{var e;let K=null===(e=b._gl)||void 0===e?void 0:e.TEXTURE_2D;var p;U.isCube&&(K=null===(p=b._gl)||void 0===p?void 0:p.TEXTURE_CUBE_MAP);b._bindTextureDirectly(K,U,!0)},G=(U,b)=>{const e=U.getEngine();for(let D=0;D<b.fileInfo.images.length;D++){const S=b.fileInfo.images[D].levels[0];if(U._invertVScale=U.invertY,-1===b.format||b.format===K.cTFRGB565)if(U.type=10,U.format=4,!e._features.basisNeedsPOT||Math.log2(S.width)%1===0&&Math.log2(S.height)%1===0)U._invertVScale=!U.invertY,U.width=S.width+3&-4,U.height=S.height+3&-4,U.samplingMode=2,P(U,e),e._uploadDataToTextureDirectly(U,new Uint16Array(S.transcodedPixels.buffer),D,0,4,!0);else{const b=new i.c(e,2);U._invertVScale=U.invertY,b.type=10,b.format=4,b.width=S.width+3&-4,b.height=S.height+3&-4,P(b,e),e._uploadDataToTextureDirectly(b,new Uint16Array(S.transcodedPixels.buffer),D,0,4,!0),e._rescaleTexture(b,U,e.scenes[0],e._getInternalFormat(4),(()=>{e._releaseTexture(b),P(U,e)}))}else{U.width=S.width,U.height=S.height,U.generateMipMaps=b.fileInfo.images[D].levels.length>1;const K=E.GetInternalFormatFromBasisFormat(b.format,e);U.format=K,P(U,e),b.fileInfo.images[D].levels.forEach(((b,p)=>{e._uploadCompressedDataToTextureDirectly(U,K,b.width,b.height,b.transcodedPixels,D,p)})),!e._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0||(p.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),U._cachedWrapU=m.b.CLAMP_ADDRESSMODE,U._cachedWrapV=m.b.CLAMP_ADDRESSMODE)}}},E={JSModuleURL:S.JSModuleURL,WasmModuleURL:S.WasmModuleURL,GetInternalFormatFromBasisFormat:(U,b)=>{let e;switch(U){case K.cTFETC1:e=36196;break;case K.cTFBC1:e=33776;break;case K.cTFBC4:e=33779;break;case K.cTFASTC_4x4:e=37808;break;case K.cTFETC2:e=37496;break;case K.cTFBC7:e=36492}if(void 0===e)throw"The chosen Basis transcoder format is not currently supported";return e},TranscodeAsync:l,LoadTextureFromTranscodeResult:G};Object.defineProperty(E,"JSModuleURL",{get:function(){return S.JSModuleURL},set:function(U){S.JSModuleURL=U}}),Object.defineProperty(E,"WasmModuleURL",{get:function(){return S.WasmModuleURL},set:function(U){S.WasmModuleURL=U}});class A{constructor(){this.supportCascades=!1}loadCubeData(U,b,e,K,m){if(Array.isArray(U))return;const i=b.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!i.etc1,s3tc:!!i.s3tc,pvrtc:!!i.pvrtc,etc2:!!i.etc2,astc:!!i.astc,bc7:!!i.bptc}};l(U,D).then((U=>{const e=U.fileInfo.images[0].levels.length>1&&b.generateMipMaps;G(b,U),b.getEngine()._setCubeMapTextureParams(b,e),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),K&&K()})).catch((U=>{p.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,m&&m(U)}))}loadData(U,b,e){const K=b.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!K.etc1,s3tc:!!K.s3tc,pvrtc:!!K.pvrtc,etc2:!!K.etc2,astc:!!K.astc,bc7:!!K.bptc}};l(U,m).then((U=>{const K=U.fileInfo.images[0].levels[0],p=U.fileInfo.images[0].levels.length>1&&b.generateMipMaps;e(K.width,K.height,p,-1!==U.format,(()=>{G(b,U)}))})).catch((U=>{p.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.g.Warn(`Failed to transcode Basis file: ${U}`),e(0,0,!1,!1,(()=>{}),!0)}))}}}}]);