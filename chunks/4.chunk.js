"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10701:(O,q,s)=>{s.r(q),s.d(q,{_BasisTextureLoader:()=>W});var Z,D=s(1183),B=s(968),P=s(1114);function y(){const O=0,q=1,s=2,Z=3,D=6,B=8,P=9,y=10,o=14;let w=null;function h(O,q,s,Z,D){const B=O.getImageTranscodedSizeInBytes(q,s,Z);let P=new Uint8Array(B);if(!O.transcodeImage(P,q,s,Z,1,0))return null;if(D){P=function(O,q,s,Z){const D=new Uint16Array(4),B=new Uint16Array(s*Z),P=s/4,y=Z/4;for(let o=0;o<y;o++)for(let Z=0;Z<P;Z++){const y=q+8*(o*P+Z);D[0]=O[y]|O[y+1]<<8,D[1]=O[y+2]|O[y+3]<<8,D[2]=(2*(31&D[0])+1*(31&D[1]))/3|(2*(2016&D[0])+1*(2016&D[1]))/3&2016|(2*(63488&D[0])+1*(63488&D[1]))/3&63488,D[3]=(2*(31&D[1])+1*(31&D[0]))/3|(2*(2016&D[1])+1*(2016&D[0]))/3&2016|(2*(63488&D[1])+1*(63488&D[0]))/3&63488;for(let q=0;q<4;q++){const P=O[y+4+q];let w=(4*o+q)*s+4*Z;B[w++]=D[3&P],B[w++]=D[P>>2&3],B[w++]=D[P>>4&3],B[w++]=D[P>>6&3]}}return B}(P,0,O.getImageWidth(q,s)+3&-4,O.getImageHeight(q,s)+3&-4)}return P}onmessage=n=>{if("init"===n.data.action){if(n.data.url)try{importScripts(n.data.url)}catch(r){postMessage({action:"error",error:r})}w||(w=BASIS({wasmBinary:n.data.wasmBinary})),null!==w&&w.then((O=>{BASIS=O,O.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===n.data.action){const w=n.data.config,r=n.data.imageData,j=new BASIS.BasisFile(r),f=function(O){const q=O.getHasAlpha(),s=O.getNumImages(),Z=[];for(let D=0;D<s;D++){const q={levels:[]},s=O.getNumLevels(D);for(let Z=0;Z<s;Z++){const s={width:O.getImageWidth(D,Z),height:O.getImageHeight(D,Z)};q.levels.push(s)}Z.push(q)}return{fd:q,images:Z}}(j);let u=n.data.ignoreSupportedFormats?null:function(w,h){let n=null;w.supportedCompressionFormats&&(n=w.supportedCompressionFormats.astc?y:w.supportedCompressionFormats.bc7?D:w.supportedCompressionFormats.s3tc?h.fd?Z:s:w.supportedCompressionFormats.pvrtc?h.fd?P:B:w.supportedCompressionFormats.etc2?q:w.supportedCompressionFormats.etc1?O:o);return n}(n.data.config,f),c=!1;null===u&&(c=!0,u=f.fd?Z:s);let W=!0;j.startTranscoding()||(W=!1);const m=[];for(let O=0;O<f.images.length&&W;O++){const q=f.images[O];if(void 0===w.loadSingleImage||w.loadSingleImage===O){let s=q.levels.length;!1===w.loadMipmapLevels&&(s=1);for(let Z=0;Z<s;Z++){const s=q.levels[Z],D=h(j,O,Z,u,c);if(!D){W=!1;break}s.transcodedPixels=D,m.push(s.transcodedPixels.buffer)}}}j.close(),j.delete(),c&&(u=-1),W?postMessage({action:"transcode",success:W,id:n.data.id,fileInfo:f,format:u},m):postMessage({action:"transcode",success:W,id:n.data.id})}}}!function(O){O[O.cTFETC1=0]="cTFETC1",O[O.cTFETC2=1]="cTFETC2",O[O.cTFBC1=2]="cTFBC1",O[O.cTFBC3=3]="cTFBC3",O[O.cTFBC4=4]="cTFBC4",O[O.cTFBC5=5]="cTFBC5",O[O.cTFBC7=6]="cTFBC7",O[O.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",O[O.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",O[O.cTFASTC_4x4=10]="cTFASTC_4x4",O[O.cTFATC_RGB=11]="cTFATC_RGB",O[O.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",O[O.cTFRGBA32=13]="cTFRGBA32",O[O.cTFRGB565=14]="cTFRGB565",O[O.cTFBGR565=15]="cTFBGR565",O[O.cTFRGBA4444=16]="cTFRGBA4444",O[O.cTFFXT1_RGB=17]="cTFFXT1_RGB",O[O.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",O[O.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",O[O.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",O[O.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Z||(Z={}));const o={JSModuleURL:`${D.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${D.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let w=null,h=null,n=0;const r=()=>(w||(w=new Promise(((O,q)=>{h?O(h):D.f.LoadFileAsync(D.f.GetBabylonScriptURL(o.WasmModuleURL)).then((s=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const Z=URL.createObjectURL(new Blob([`(${y})()`],{type:"application/javascript"}));h=new Worker(Z),function(O,q,s){return new Promise(((Z,B)=>{const P=q=>{"init"===q.data.action?(O.removeEventListener("message",P),Z(O)):"error"===q.data.action&&B(q.data.error||"error initializing worker")};O.addEventListener("message",P),O.postMessage({action:"init",url:s?D.f.GetBabylonScriptURL(s):void 0,wasmBinary:q},[q])}))}(h,s,o.JSModuleURL).then(O,q)})).catch(q)}))),w),j=(O,q)=>{const s=O instanceof ArrayBuffer?new Uint8Array(O):O;return new Promise(((O,Z)=>{r().then((()=>{const D=n++,B=q=>{"transcode"===q.data.action&&q.data.id===D&&(h.removeEventListener("message",B),q.data.success?O(q.data):Z("Transcode is not supported on this device"))};h.addEventListener("message",B);const P=new Uint8Array(s.byteLength);P.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength)),h.postMessage({action:"transcode",id:D,imageData:P,config:q,ignoreSupportedFormats:false},[P.buffer])}),(O=>{Z(O)}))}))},f=(O,q)=>{var s;let Z=null===(s=q._gl)||void 0===s?void 0:s.TEXTURE_2D;var D;O.isCube&&(Z=null===(D=q._gl)||void 0===D?void 0:D.TEXTURE_CUBE_MAP);q._bindTextureDirectly(Z,O,!0)},u=(O,q)=>{const s=O.getEngine();for(let y=0;y<q.fileInfo.images.length;y++){const o=q.fileInfo.images[y].levels[0];if(O._invertVScale=O.invertY,-1===q.format||q.format===Z.cTFRGB565)if(O.type=10,O.format=4,!s._features.basisNeedsPOT||Math.log2(o.width)%1===0&&Math.log2(o.height)%1===0)O._invertVScale=!O.invertY,O.width=o.width+3&-4,O.height=o.height+3&-4,O.samplingMode=2,f(O,s),s._uploadDataToTextureDirectly(O,new Uint16Array(o.transcodedPixels.buffer),y,0,4,!0);else{const q=new P.d(s,2);O._invertVScale=O.invertY,q.type=10,q.format=4,q.width=o.width+3&-4,q.height=o.height+3&-4,f(q,s),s._uploadDataToTextureDirectly(q,new Uint16Array(o.transcodedPixels.buffer),y,0,4,!0),s._rescaleTexture(q,O,s.scenes[0],s._getInternalFormat(4),(()=>{s._releaseTexture(q),f(O,s)}))}else{O.width=o.width,O.height=o.height,O.generateMipMaps=q.fileInfo.images[y].levels.length>1;const Z=c.GetInternalFormatFromBasisFormat(q.format,s);O.format=Z,f(O,s),q.fileInfo.images[y].levels.forEach(((q,D)=>{s._uploadCompressedDataToTextureDirectly(O,Z,q.width,q.height,q.transcodedPixels,y,D)})),!s._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0||(D.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),O._cachedWrapU=B.c.CLAMP_ADDRESSMODE,O._cachedWrapV=B.c.CLAMP_ADDRESSMODE)}}},c={JSModuleURL:o.JSModuleURL,WasmModuleURL:o.WasmModuleURL,GetInternalFormatFromBasisFormat:(O,q)=>{let s;switch(O){case Z.cTFETC1:s=36196;break;case Z.cTFBC1:s=33776;break;case Z.cTFBC4:s=33779;break;case Z.cTFASTC_4x4:s=37808;break;case Z.cTFETC2:s=37496;break;case Z.cTFBC7:s=36492}if(void 0===s)throw"The chosen Basis transcoder format is not currently supported";return s},TranscodeAsync:j,LoadTextureFromTranscodeResult:u};Object.defineProperty(c,"JSModuleURL",{get:function(){return o.JSModuleURL},set:function(O){o.JSModuleURL=O}}),Object.defineProperty(c,"WasmModuleURL",{get:function(){return o.WasmModuleURL},set:function(O){o.WasmModuleURL=O}});class W{constructor(){this.supportCascades=!1}loadCubeData(O,q,s,Z,B){if(Array.isArray(O))return;const P=q.getEngine().getCaps(),y={supportedCompressionFormats:{etc1:!!P.etc1,s3tc:!!P.s3tc,pvrtc:!!P.pvrtc,etc2:!!P.etc2,astc:!!P.astc,bc7:!!P.bptc}};j(O,y).then((O=>{const s=O.fileInfo.images[0].levels.length>1&&q.generateMipMaps;u(q,O),q.getEngine()._setCubeMapTextureParams(q,s),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),Z&&Z()})).catch((O=>{D.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,B&&B(O)}))}loadData(O,q,s){const Z=q.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!Z.etc1,s3tc:!!Z.s3tc,pvrtc:!!Z.pvrtc,etc2:!!Z.etc2,astc:!!Z.astc,bc7:!!Z.bptc}};j(O,B).then((O=>{const Z=O.fileInfo.images[0].levels[0],D=O.fileInfo.images[0].levels.length>1&&q.generateMipMaps;s(Z.width,Z.height,D,-1!==O.format,(()=>{u(q,O)}))})).catch((O=>{D.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),D.f.Warn(`Failed to transcode Basis file: ${O}`),s(0,0,!1,!1,(()=>{}),!0)}))}}}}]);