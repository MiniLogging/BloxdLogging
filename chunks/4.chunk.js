"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10833:(v,T,X)=>{X.r(T),X.d(T,{_BasisTextureLoader:()=>k});var O,u=X(1217),B=X(978),m=X(1140);function A(){const v=0,T=1,X=2,O=3,u=6,B=8,m=9,A=10,x=14;let f=null;function M(v,T,X,O,u){const B=v.getImageTranscodedSizeInBytes(T,X,O);let m=new Uint8Array(B);if(!v.transcodeImage(m,T,X,O,1,0))return null;if(u){m=function(v,T,X,O){const u=new Uint16Array(4),B=new Uint16Array(X*O),m=X/4,A=O/4;for(let x=0;x<A;x++)for(let O=0;O<m;O++){const A=T+8*(x*m+O);u[0]=v[A]|v[A+1]<<8,u[1]=v[A+2]|v[A+3]<<8,u[2]=(2*(31&u[0])+1*(31&u[1]))/3|(2*(2016&u[0])+1*(2016&u[1]))/3&2016|(2*(63488&u[0])+1*(63488&u[1]))/3&63488,u[3]=(2*(31&u[1])+1*(31&u[0]))/3|(2*(2016&u[1])+1*(2016&u[0]))/3&2016|(2*(63488&u[1])+1*(63488&u[0]))/3&63488;for(let T=0;T<4;T++){const m=v[A+4+T];let f=(4*x+T)*X+4*O;B[f++]=u[3&m],B[f++]=u[m>>2&3],B[f++]=u[m>>4&3],B[f++]=u[m>>6&3]}}return B}(m,0,v.getImageWidth(T,X)+3&-4,v.getImageHeight(T,X)+3&-4)}return m}onmessage=H=>{if("init"===H.data.action){if(H.data.url)try{importScripts(H.data.url)}catch(n){postMessage({action:"error",error:n})}f||(f=BASIS({wasmBinary:H.data.wasmBinary})),null!==f&&f.then((v=>{BASIS=v,v.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===H.data.action){const f=H.data.config,n=H.data.imageData,V=new BASIS.BasisFile(n),D=function(v){const T=v.getHasAlpha(),X=v.getNumImages(),O=[];for(let u=0;u<X;u++){const T={levels:[]},X=v.getNumLevels(u);for(let O=0;O<X;O++){const X={width:v.getImageWidth(u,O),height:v.getImageHeight(u,O)};T.levels.push(X)}O.push(T)}return{yd:T,images:O}}(V);let s=H.data.ignoreSupportedFormats?null:function(f,M){let H=null;f.supportedCompressionFormats&&(H=f.supportedCompressionFormats.astc?A:f.supportedCompressionFormats.bc7?u:f.supportedCompressionFormats.s3tc?M.yd?O:X:f.supportedCompressionFormats.pvrtc?M.yd?m:B:f.supportedCompressionFormats.etc2?T:f.supportedCompressionFormats.etc1?v:x);return H}(H.data.config,D),F=!1;null===s&&(F=!0,s=D.yd?O:X);let k=!0;V.startTranscoding()||(k=!1);const b=[];for(let v=0;v<D.images.length&&k;v++){const T=D.images[v];if(void 0===f.loadSingleImage||f.loadSingleImage===v){let X=T.levels.length;!1===f.loadMipmapLevels&&(X=1);for(let O=0;O<X;O++){const X=T.levels[O],u=M(V,v,O,s,F);if(!u){k=!1;break}X.transcodedPixels=u,b.push(X.transcodedPixels.buffer)}}}V.close(),V.delete(),F&&(s=-1),k?postMessage({action:"transcode",success:k,id:H.data.id,fileInfo:D,format:s},b):postMessage({action:"transcode",success:k,id:H.data.id})}}}!function(v){v[v.cTFETC1=0]="cTFETC1",v[v.cTFETC2=1]="cTFETC2",v[v.cTFBC1=2]="cTFBC1",v[v.cTFBC3=3]="cTFBC3",v[v.cTFBC4=4]="cTFBC4",v[v.cTFBC5=5]="cTFBC5",v[v.cTFBC7=6]="cTFBC7",v[v.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",v[v.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",v[v.cTFASTC_4x4=10]="cTFASTC_4x4",v[v.cTFATC_RGB=11]="cTFATC_RGB",v[v.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",v[v.cTFRGBA32=13]="cTFRGBA32",v[v.cTFRGB565=14]="cTFRGB565",v[v.cTFBGR565=15]="cTFBGR565",v[v.cTFRGBA4444=16]="cTFRGBA4444",v[v.cTFFXT1_RGB=17]="cTFFXT1_RGB",v[v.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",v[v.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",v[v.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",v[v.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(O||(O={}));const x={JSModuleURL:`${u.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${u.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let f=null,M=null,H=0;const n=()=>(f||(f=new Promise(((v,T)=>{M?v(M):u.c.LoadFileAsync(u.c.GetBabylonScriptURL(x.WasmModuleURL)).then((X=>{if("function"!==typeof URL)return T("Basis transcoder requires an environment with a URL constructor");const O=URL.createObjectURL(new Blob([`(${A})()`],{type:"application/javascript"}));M=new Worker(O),function(v,T,X){return new Promise(((O,B)=>{const m=T=>{"init"===T.data.action?(v.removeEventListener("message",m),O(v)):"error"===T.data.action&&B(T.data.error||"error initializing worker")};v.addEventListener("message",m),v.postMessage({action:"init",url:X?u.c.GetBabylonScriptURL(X):void 0,wasmBinary:T},[T])}))}(M,X,x.JSModuleURL).then(v,T)})).catch(T)}))),f),V=(v,T)=>{const X=v instanceof ArrayBuffer?new Uint8Array(v):v;return new Promise(((v,O)=>{n().then((()=>{const u=H++,B=T=>{"transcode"===T.data.action&&T.data.id===u&&(M.removeEventListener("message",B),T.data.success?v(T.data):O("Transcode is not supported on this device"))};M.addEventListener("message",B);const m=new Uint8Array(X.byteLength);m.set(new Uint8Array(X.buffer,X.byteOffset,X.byteLength)),M.postMessage({action:"transcode",id:u,imageData:m,config:T,ignoreSupportedFormats:false},[m.buffer])}),(v=>{O(v)}))}))},D=(v,T)=>{var X;let O=null===(X=T._gl)||void 0===X?void 0:X.TEXTURE_2D;var u;v.isCube&&(O=null===(u=T._gl)||void 0===u?void 0:u.TEXTURE_CUBE_MAP);T._bindTextureDirectly(O,v,!0)},s=(v,T)=>{const X=v.getEngine();for(let A=0;A<T.fileInfo.images.length;A++){const x=T.fileInfo.images[A].levels[0];if(v._invertVScale=v.invertY,-1===T.format||T.format===O.cTFRGB565)if(v.type=10,v.format=4,!X._features.basisNeedsPOT||Math.log2(x.width)%1===0&&Math.log2(x.height)%1===0)v._invertVScale=!v.invertY,v.width=x.width+3&-4,v.height=x.height+3&-4,v.samplingMode=2,D(v,X),X._uploadDataToTextureDirectly(v,new Uint16Array(x.transcodedPixels.buffer),A,0,4,!0);else{const T=new m.d(X,2);v._invertVScale=v.invertY,T.type=10,T.format=4,T.width=x.width+3&-4,T.height=x.height+3&-4,D(T,X),X._uploadDataToTextureDirectly(T,new Uint16Array(x.transcodedPixels.buffer),A,0,4,!0),X._rescaleTexture(T,v,X.scenes[0],X._getInternalFormat(4),(()=>{X._releaseTexture(T),D(v,X)}))}else{v.width=x.width,v.height=x.height,v.generateMipMaps=T.fileInfo.images[A].levels.length>1;const O=F.GetInternalFormatFromBasisFormat(T.format,X);v.format=O,D(v,X),T.fileInfo.images[A].levels.forEach(((T,u)=>{X._uploadCompressedDataToTextureDirectly(v,O,T.width,T.height,T.transcodedPixels,A,u)})),!X._features.basisNeedsPOT||Math.log2(v.width)%1===0&&Math.log2(v.height)%1===0||(u.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),v._cachedWrapU=B.e.CLAMP_ADDRESSMODE,v._cachedWrapV=B.e.CLAMP_ADDRESSMODE)}}},F={JSModuleURL:x.JSModuleURL,WasmModuleURL:x.WasmModuleURL,GetInternalFormatFromBasisFormat:(v,T)=>{let X;switch(v){case O.cTFETC1:X=36196;break;case O.cTFBC1:X=33776;break;case O.cTFBC4:X=33779;break;case O.cTFASTC_4x4:X=37808;break;case O.cTFETC2:X=37496;break;case O.cTFBC7:X=36492}if(void 0===X)throw"The chosen Basis transcoder format is not currently supported";return X},TranscodeAsync:V,LoadTextureFromTranscodeResult:s};Object.defineProperty(F,"JSModuleURL",{get:function(){return x.JSModuleURL},set:function(v){x.JSModuleURL=v}}),Object.defineProperty(F,"WasmModuleURL",{get:function(){return x.WasmModuleURL},set:function(v){x.WasmModuleURL=v}});class k{constructor(){this.supportCascades=!1}loadCubeData(v,T,X,O,B){if(Array.isArray(v))return;const m=T.getEngine().getCaps(),A={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};V(v,A).then((v=>{const X=v.fileInfo.images[0].levels.length>1&&T.generateMipMaps;s(T,v),T.getEngine()._setCubeMapTextureParams(T,X),T.isReady=!0,T.onLoadedObservable.notifyObservers(T),T.onLoadedObservable.clear(),O&&O()})).catch((v=>{u.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.isReady=!0,B&&B(v)}))}loadData(v,T,X){const O=T.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!O.etc1,s3tc:!!O.s3tc,pvrtc:!!O.pvrtc,etc2:!!O.etc2,astc:!!O.astc,bc7:!!O.bptc}};V(v,B).then((v=>{const O=v.fileInfo.images[0].levels[0],u=v.fileInfo.images[0].levels.length>1&&T.generateMipMaps;X(O.width,O.height,u,-1!==v.format,(()=>{s(T,v)}))})).catch((v=>{u.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),u.c.Warn(`Failed to transcode Basis file: ${v}`),X(0,0,!1,!1,(()=>{}),!0)}))}}}}]);