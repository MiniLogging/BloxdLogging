"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10923:(o,i,p)=>{p.r(i),p.d(i,{_BasisTextureLoader:()=>F});var b,k=p(1175),u=p(954),j=p(1108);function z(){const o=0,i=1,p=2,b=3,k=6,u=8,j=9,z=10,g=14;let J=null;function a(o,i,p,b,k){const u=o.getImageTranscodedSizeInBytes(i,p,b);let j=new Uint8Array(u);if(!o.transcodeImage(j,i,p,b,1,0))return null;if(k){j=function(o,i,p,b){const k=new Uint16Array(4),u=new Uint16Array(p*b),j=p/4,z=b/4;for(let g=0;g<z;g++)for(let b=0;b<j;b++){const z=i+8*(g*j+b);k[0]=o[z]|o[z+1]<<8,k[1]=o[z+2]|o[z+3]<<8,k[2]=(2*(31&k[0])+1*(31&k[1]))/3|(2*(2016&k[0])+1*(2016&k[1]))/3&2016|(2*(63488&k[0])+1*(63488&k[1]))/3&63488,k[3]=(2*(31&k[1])+1*(31&k[0]))/3|(2*(2016&k[1])+1*(2016&k[0]))/3&2016|(2*(63488&k[1])+1*(63488&k[0]))/3&63488;for(let i=0;i<4;i++){const j=o[z+4+i];let J=(4*g+i)*p+4*b;u[J++]=k[3&j],u[J++]=k[j>>2&3],u[J++]=k[j>>4&3],u[J++]=k[j>>6&3]}}return u}(j,0,o.getImageWidth(i,p)+3&-4,o.getImageHeight(i,p)+3&-4)}return j}onmessage=G=>{if("init"===G.data.action){if(G.data.url)try{importScripts(G.data.url)}catch(O){postMessage({action:"error",error:O})}J||(J=BASIS({wasmBinary:G.data.wasmBinary})),null!==J&&J.then((o=>{BASIS=o,o.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===G.data.action){const J=G.data.config,O=G.data.imageData,C=new BASIS.BasisFile(O),l=function(o){const i=o.getHasAlpha(),p=o.getNumImages(),b=[];for(let k=0;k<p;k++){const i={levels:[]},p=o.getNumLevels(k);for(let b=0;b<p;b++){const p={width:o.getImageWidth(k,b),height:o.getImageHeight(k,b)};i.levels.push(p)}b.push(i)}return{ud:i,images:b}}(C);let R=G.data.ignoreSupportedFormats?null:function(J,a){let G=null;J.supportedCompressionFormats&&(G=J.supportedCompressionFormats.astc?z:J.supportedCompressionFormats.bc7?k:J.supportedCompressionFormats.s3tc?a.ud?b:p:J.supportedCompressionFormats.pvrtc?a.ud?j:u:J.supportedCompressionFormats.etc2?i:J.supportedCompressionFormats.etc1?o:g);return G}(G.data.config,l),E=!1;null===R&&(E=!0,R=l.ud?b:p);let F=!0;C.startTranscoding()||(F=!1);const e=[];for(let o=0;o<l.images.length&&F;o++){const i=l.images[o];if(void 0===J.loadSingleImage||J.loadSingleImage===o){let p=i.levels.length;!1===J.loadMipmapLevels&&(p=1);for(let b=0;b<p;b++){const p=i.levels[b],k=a(C,o,b,R,E);if(!k){F=!1;break}p.transcodedPixels=k,e.push(p.transcodedPixels.buffer)}}}C.close(),C.delete(),E&&(R=-1),F?postMessage({action:"transcode",success:F,id:G.data.id,fileInfo:l,format:R},e):postMessage({action:"transcode",success:F,id:G.data.id})}}}!function(o){o[o.cTFETC1=0]="cTFETC1",o[o.cTFETC2=1]="cTFETC2",o[o.cTFBC1=2]="cTFBC1",o[o.cTFBC3=3]="cTFBC3",o[o.cTFBC4=4]="cTFBC4",o[o.cTFBC5=5]="cTFBC5",o[o.cTFBC7=6]="cTFBC7",o[o.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",o[o.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",o[o.cTFASTC_4x4=10]="cTFASTC_4x4",o[o.cTFATC_RGB=11]="cTFATC_RGB",o[o.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",o[o.cTFRGBA32=13]="cTFRGBA32",o[o.cTFRGB565=14]="cTFRGB565",o[o.cTFBGR565=15]="cTFBGR565",o[o.cTFRGBA4444=16]="cTFRGBA4444",o[o.cTFFXT1_RGB=17]="cTFFXT1_RGB",o[o.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",o[o.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",o[o.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",o[o.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(b||(b={}));const g={JSModuleURL:`${k.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${k.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,a=null,G=0;const O=()=>(J||(J=new Promise(((o,i)=>{a?o(a):k.h.LoadFileAsync(k.h.GetBabylonScriptURL(g.WasmModuleURL)).then((p=>{if("function"!==typeof URL)return i("Basis transcoder requires an environment with a URL constructor");const b=URL.createObjectURL(new Blob([`(${z})()`],{type:"application/javascript"}));a=new Worker(b),function(o,i,p){return new Promise(((b,u)=>{const j=i=>{"init"===i.data.action?(o.removeEventListener("message",j),b(o)):"error"===i.data.action&&u(i.data.error||"error initializing worker")};o.addEventListener("message",j),o.postMessage({action:"init",url:p?k.h.GetBabylonScriptURL(p):void 0,wasmBinary:i},[i])}))}(a,p,g.JSModuleURL).then(o,i)})).catch(i)}))),J),C=(o,i)=>{const p=o instanceof ArrayBuffer?new Uint8Array(o):o;return new Promise(((o,b)=>{O().then((()=>{const k=G++,u=i=>{"transcode"===i.data.action&&i.data.id===k&&(a.removeEventListener("message",u),i.data.success?o(i.data):b("Transcode is not supported on this device"))};a.addEventListener("message",u);const j=new Uint8Array(p.byteLength);j.set(new Uint8Array(p.buffer,p.byteOffset,p.byteLength)),a.postMessage({action:"transcode",id:k,imageData:j,config:i,ignoreSupportedFormats:false},[j.buffer])}),(o=>{b(o)}))}))},l=(o,i)=>{var p;let b=null===(p=i._gl)||void 0===p?void 0:p.TEXTURE_2D;var k;o.isCube&&(b=null===(k=i._gl)||void 0===k?void 0:k.TEXTURE_CUBE_MAP);i._bindTextureDirectly(b,o,!0)},R=(o,i)=>{const p=o.getEngine();for(let z=0;z<i.fileInfo.images.length;z++){const g=i.fileInfo.images[z].levels[0];if(o._invertVScale=o.invertY,-1===i.format||i.format===b.cTFRGB565)if(o.type=10,o.format=4,!p._features.basisNeedsPOT||Math.log2(g.width)%1===0&&Math.log2(g.height)%1===0)o._invertVScale=!o.invertY,o.width=g.width+3&-4,o.height=g.height+3&-4,o.samplingMode=2,l(o,p),p._uploadDataToTextureDirectly(o,new Uint16Array(g.transcodedPixels.buffer),z,0,4,!0);else{const i=new j.e(p,2);o._invertVScale=o.invertY,i.type=10,i.format=4,i.width=g.width+3&-4,i.height=g.height+3&-4,l(i,p),p._uploadDataToTextureDirectly(i,new Uint16Array(g.transcodedPixels.buffer),z,0,4,!0),p._rescaleTexture(i,o,p.scenes[0],p._getInternalFormat(4),(()=>{p._releaseTexture(i),l(o,p)}))}else{o.width=g.width,o.height=g.height,o.generateMipMaps=i.fileInfo.images[z].levels.length>1;const b=E.GetInternalFormatFromBasisFormat(i.format,p);o.format=b,l(o,p),i.fileInfo.images[z].levels.forEach(((i,k)=>{p._uploadCompressedDataToTextureDirectly(o,b,i.width,i.height,i.transcodedPixels,z,k)})),!p._features.basisNeedsPOT||Math.log2(o.width)%1===0&&Math.log2(o.height)%1===0||(k.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),o._cachedWrapU=u.c.CLAMP_ADDRESSMODE,o._cachedWrapV=u.c.CLAMP_ADDRESSMODE)}}},E={JSModuleURL:g.JSModuleURL,WasmModuleURL:g.WasmModuleURL,GetInternalFormatFromBasisFormat:(o,i)=>{let p;switch(o){case b.cTFETC1:p=36196;break;case b.cTFBC1:p=33776;break;case b.cTFBC4:p=33779;break;case b.cTFASTC_4x4:p=37808;break;case b.cTFETC2:p=37496;break;case b.cTFBC7:p=36492}if(void 0===p)throw"The chosen Basis transcoder format is not currently supported";return p},TranscodeAsync:C,LoadTextureFromTranscodeResult:R};Object.defineProperty(E,"JSModuleURL",{get:function(){return g.JSModuleURL},set:function(o){g.JSModuleURL=o}}),Object.defineProperty(E,"WasmModuleURL",{get:function(){return g.WasmModuleURL},set:function(o){g.WasmModuleURL=o}});class F{constructor(){this.supportCascades=!1}loadCubeData(o,i,p,b,u){if(Array.isArray(o))return;const j=i.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!j.etc1,s3tc:!!j.s3tc,pvrtc:!!j.pvrtc,etc2:!!j.etc2,astc:!!j.astc,bc7:!!j.bptc}};C(o,z).then((o=>{const p=o.fileInfo.images[0].levels.length>1&&i.generateMipMaps;R(i,o),i.getEngine()._setCubeMapTextureParams(i,p),i.isReady=!0,i.onLoadedObservable.notifyObservers(i),i.onLoadedObservable.clear(),b&&b()})).catch((o=>{k.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.isReady=!0,u&&u(o)}))}loadData(o,i,p){const b=i.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!b.etc1,s3tc:!!b.s3tc,pvrtc:!!b.pvrtc,etc2:!!b.etc2,astc:!!b.astc,bc7:!!b.bptc}};C(o,u).then((o=>{const b=o.fileInfo.images[0].levels[0],k=o.fileInfo.images[0].levels.length>1&&i.generateMipMaps;p(b.width,b.height,k,-1!==o.format,(()=>{R(i,o)}))})).catch((o=>{k.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.h.Warn(`Failed to transcode Basis file: ${o}`),p(0,0,!1,!1,(()=>{}),!0)}))}}}}]);