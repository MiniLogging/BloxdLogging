"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{11104:(L,i,P)=>{P.r(i),P.d(i,{_BasisTextureLoader:()=>H});var D,V=P(1217),M=P(967),a=P(1146);function w(){const L=0,i=1,P=2,D=3,V=6,M=8,a=9,w=10,O=14;let U=null;function C(L,i,P,D,V){const M=L.getImageTranscodedSizeInBytes(i,P,D);let a=new Uint8Array(M);if(!L.transcodeImage(a,i,P,D,1,0))return null;if(V){a=function(L,i,P,D){const V=new Uint16Array(4),M=new Uint16Array(P*D),a=P/4,w=D/4;for(let O=0;O<w;O++)for(let D=0;D<a;D++){const w=i+8*(O*a+D);V[0]=L[w]|L[w+1]<<8,V[1]=L[w+2]|L[w+3]<<8,V[2]=(2*(31&V[0])+1*(31&V[1]))/3|(2*(2016&V[0])+1*(2016&V[1]))/3&2016|(2*(63488&V[0])+1*(63488&V[1]))/3&63488,V[3]=(2*(31&V[1])+1*(31&V[0]))/3|(2*(2016&V[1])+1*(2016&V[0]))/3&2016|(2*(63488&V[1])+1*(63488&V[0]))/3&63488;for(let i=0;i<4;i++){const a=L[w+4+i];let U=(4*O+i)*P+4*D;M[U++]=V[3&a],M[U++]=V[a>>2&3],M[U++]=V[a>>4&3],M[U++]=V[a>>6&3]}}return M}(a,0,L.getImageWidth(i,P)+3&-4,L.getImageHeight(i,P)+3&-4)}return a}onmessage=T=>{if("init"===T.data.action){if(T.data.url)try{importScripts(T.data.url)}catch(c){postMessage({action:"error",error:c})}U||(U=BASIS({wasmBinary:T.data.wasmBinary})),null!==U&&U.then((L=>{BASIS=L,L.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===T.data.action){const U=T.data.config,c=T.data.imageData,r=new BASIS.BasisFile(c),F=function(L){const i=L.getHasAlpha(),P=L.getNumImages(),D=[];for(let V=0;V<P;V++){const i={levels:[]},P=L.getNumLevels(V);for(let D=0;D<P;D++){const P={width:L.getImageWidth(V,D),height:L.getImageHeight(V,D)};i.levels.push(P)}D.push(i)}return{rc:i,images:D}}(r);let S=T.data.ignoreSupportedFormats?null:function(U,C){let T=null;U.supportedCompressionFormats&&(T=U.supportedCompressionFormats.astc?w:U.supportedCompressionFormats.bc7?V:U.supportedCompressionFormats.s3tc?C.rc?D:P:U.supportedCompressionFormats.pvrtc?C.rc?a:M:U.supportedCompressionFormats.etc2?i:U.supportedCompressionFormats.etc1?L:O);return T}(T.data.config,F),q=!1;null===S&&(q=!0,S=F.rc?D:P);let H=!0;r.startTranscoding()||(H=!1);const j=[];for(let L=0;L<F.images.length&&H;L++){const i=F.images[L];if(void 0===U.loadSingleImage||U.loadSingleImage===L){let P=i.levels.length;!1===U.loadMipmapLevels&&(P=1);for(let D=0;D<P;D++){const P=i.levels[D],V=C(r,L,D,S,q);if(!V){H=!1;break}P.transcodedPixels=V,j.push(P.transcodedPixels.buffer)}}}r.close(),r.delete(),q&&(S=-1),H?postMessage({action:"transcode",success:H,id:T.data.id,fileInfo:F,format:S},j):postMessage({action:"transcode",success:H,id:T.data.id})}}}!function(L){L[L.cTFETC1=0]="cTFETC1",L[L.cTFETC2=1]="cTFETC2",L[L.cTFBC1=2]="cTFBC1",L[L.cTFBC3=3]="cTFBC3",L[L.cTFBC4=4]="cTFBC4",L[L.cTFBC5=5]="cTFBC5",L[L.cTFBC7=6]="cTFBC7",L[L.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",L[L.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",L[L.cTFASTC_4x4=10]="cTFASTC_4x4",L[L.cTFATC_RGB=11]="cTFATC_RGB",L[L.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",L[L.cTFRGBA32=13]="cTFRGBA32",L[L.cTFRGB565=14]="cTFRGB565",L[L.cTFBGR565=15]="cTFBGR565",L[L.cTFRGBA4444=16]="cTFRGBA4444",L[L.cTFFXT1_RGB=17]="cTFFXT1_RGB",L[L.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",L[L.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",L[L.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",L[L.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(D||(D={}));const O={JSModuleURL:`${V.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${V.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let U=null,C=null,T=0;const c=()=>(U||(U=new Promise(((L,i)=>{C?L(C):V.g.LoadFileAsync(V.g.GetBabylonScriptURL(O.WasmModuleURL)).then((P=>{if("function"!==typeof URL)return i("Basis transcoder requires an environment with a URL constructor");const D=URL.createObjectURL(new Blob([`(${w})()`],{type:"application/javascript"}));C=new Worker(D),function(L,i,P){return new Promise(((D,M)=>{const a=i=>{"init"===i.data.action?(L.removeEventListener("message",a),D(L)):"error"===i.data.action&&M(i.data.error||"error initializing worker")};L.addEventListener("message",a),L.postMessage({action:"init",url:P?V.g.GetBabylonScriptURL(P):void 0,wasmBinary:i},[i])}))}(C,P,O.JSModuleURL).then(L,i)})).catch(i)}))),U),r=(L,i)=>{const P=L instanceof ArrayBuffer?new Uint8Array(L):L;return new Promise(((L,D)=>{c().then((()=>{const V=T++,M=i=>{"transcode"===i.data.action&&i.data.id===V&&(C.removeEventListener("message",M),i.data.success?L(i.data):D("Transcode is not supported on this device"))};C.addEventListener("message",M);const a=new Uint8Array(P.byteLength);a.set(new Uint8Array(P.buffer,P.byteOffset,P.byteLength)),C.postMessage({action:"transcode",id:V,imageData:a,config:i,ignoreSupportedFormats:false},[a.buffer])}),(L=>{D(L)}))}))},F=(L,i)=>{var P;let D=null===(P=i._gl)||void 0===P?void 0:P.TEXTURE_2D;var V;L.isCube&&(D=null===(V=i._gl)||void 0===V?void 0:V.TEXTURE_CUBE_MAP);i._bindTextureDirectly(D,L,!0)},S=(L,i)=>{const P=L.getEngine();for(let w=0;w<i.fileInfo.images.length;w++){const O=i.fileInfo.images[w].levels[0];if(L._invertVScale=L.invertY,-1===i.format||i.format===D.cTFRGB565)if(L.type=10,L.format=4,!P._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0)L._invertVScale=!L.invertY,L.width=O.width+3&-4,L.height=O.height+3&-4,L.samplingMode=2,F(L,P),P._uploadDataToTextureDirectly(L,new Uint16Array(O.transcodedPixels.buffer),w,0,4,!0);else{const i=new a.c(P,2);L._invertVScale=L.invertY,i.type=10,i.format=4,i.width=O.width+3&-4,i.height=O.height+3&-4,F(i,P),P._uploadDataToTextureDirectly(i,new Uint16Array(O.transcodedPixels.buffer),w,0,4,!0),P._rescaleTexture(i,L,P.scenes[0],P._getInternalFormat(4),(()=>{P._releaseTexture(i),F(L,P)}))}else{L.width=O.width,L.height=O.height,L.generateMipMaps=i.fileInfo.images[w].levels.length>1;const D=q.GetInternalFormatFromBasisFormat(i.format,P);L.format=D,F(L,P),i.fileInfo.images[w].levels.forEach(((i,V)=>{P._uploadCompressedDataToTextureDirectly(L,D,i.width,i.height,i.transcodedPixels,w,V)})),!P._features.basisNeedsPOT||Math.log2(L.width)%1===0&&Math.log2(L.height)%1===0||(V.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),L._cachedWrapU=M.c.CLAMP_ADDRESSMODE,L._cachedWrapV=M.c.CLAMP_ADDRESSMODE)}}},q={JSModuleURL:O.JSModuleURL,WasmModuleURL:O.WasmModuleURL,GetInternalFormatFromBasisFormat:(L,i)=>{let P;switch(L){case D.cTFETC1:P=36196;break;case D.cTFBC1:P=33776;break;case D.cTFBC4:P=33779;break;case D.cTFASTC_4x4:P=37808;break;case D.cTFETC2:P=37496;break;case D.cTFBC7:P=36492}if(void 0===P)throw"The chosen Basis transcoder format is not currently supported";return P},TranscodeAsync:r,LoadTextureFromTranscodeResult:S};Object.defineProperty(q,"JSModuleURL",{get:function(){return O.JSModuleURL},set:function(L){O.JSModuleURL=L}}),Object.defineProperty(q,"WasmModuleURL",{get:function(){return O.WasmModuleURL},set:function(L){O.WasmModuleURL=L}});class H{constructor(){this.supportCascades=!1}loadCubeData(L,i,P,D,M){if(Array.isArray(L))return;const a=i.getEngine().getCaps(),w={supportedCompressionFormats:{etc1:!!a.etc1,s3tc:!!a.s3tc,pvrtc:!!a.pvrtc,etc2:!!a.etc2,astc:!!a.astc,bc7:!!a.bptc}};r(L,w).then((L=>{const P=L.fileInfo.images[0].levels.length>1&&i.generateMipMaps;S(i,L),i.getEngine()._setCubeMapTextureParams(i,P),i.isReady=!0,i.onLoadedObservable.notifyObservers(i),i.onLoadedObservable.clear(),D&&D()})).catch((L=>{V.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.isReady=!0,M&&M(L)}))}loadData(L,i,P){const D=i.getEngine().getCaps(),M={supportedCompressionFormats:{etc1:!!D.etc1,s3tc:!!D.s3tc,pvrtc:!!D.pvrtc,etc2:!!D.etc2,astc:!!D.astc,bc7:!!D.bptc}};r(L,M).then((L=>{const D=L.fileInfo.images[0].levels[0],V=L.fileInfo.images[0].levels.length>1&&i.generateMipMaps;P(D.width,D.height,V,-1!==L.format,(()=>{S(i,L)}))})).catch((L=>{V.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),V.g.Warn(`Failed to transcode Basis file: ${L}`),P(0,0,!1,!1,(()=>{}),!0)}))}}}}]);