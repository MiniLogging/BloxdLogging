"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10238:(f,Q,H)=>{H.r(Q),H.d(Q,{_BasisTextureLoader:()=>n});var X,i=H(1203),S=H(974),x=H(1133);function K(){const f=0,Q=1,H=2,X=3,i=6,S=8,x=9,K=10,Z=14;let B=null;function N(f,Q,H,X,i){const S=f.getImageTranscodedSizeInBytes(Q,H,X);let x=new Uint8Array(S);if(!f.transcodeImage(x,Q,H,X,1,0))return null;if(i){x=function(f,Q,H,X){const i=new Uint16Array(4),S=new Uint16Array(H*X),x=H/4,K=X/4;for(let Z=0;Z<K;Z++)for(let X=0;X<x;X++){const K=Q+8*(Z*x+X);i[0]=f[K]|f[K+1]<<8,i[1]=f[K+2]|f[K+3]<<8,i[2]=(2*(31&i[0])+1*(31&i[1]))/3|(2*(2016&i[0])+1*(2016&i[1]))/3&2016|(2*(63488&i[0])+1*(63488&i[1]))/3&63488,i[3]=(2*(31&i[1])+1*(31&i[0]))/3|(2*(2016&i[1])+1*(2016&i[0]))/3&2016|(2*(63488&i[1])+1*(63488&i[0]))/3&63488;for(let Q=0;Q<4;Q++){const x=f[K+4+Q];let B=(4*Z+Q)*H+4*X;S[B++]=i[3&x],S[B++]=i[x>>2&3],S[B++]=i[x>>4&3],S[B++]=i[x>>6&3]}}return S}(x,0,f.getImageWidth(Q,H)+3&-4,f.getImageHeight(Q,H)+3&-4)}return x}onmessage=J=>{if("init"===J.data.action){if(J.data.url)try{importScripts(J.data.url)}catch(g){postMessage({action:"error",error:g})}B||(B=BASIS({wasmBinary:J.data.wasmBinary})),null!==B&&B.then((f=>{BASIS=f,f.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===J.data.action){const B=J.data.config,g=J.data.imageData,z=new BASIS.BasisFile(g),v=function(f){const Q=f.getHasAlpha(),H=f.getNumImages(),X=[];for(let i=0;i<H;i++){const Q={levels:[]},H=f.getNumLevels(i);for(let X=0;X<H;X++){const H={width:f.getImageWidth(i,X),height:f.getImageHeight(i,X)};Q.levels.push(H)}X.push(Q)}return{qc:Q,images:X}}(z);let Y=J.data.ignoreSupportedFormats?null:function(B,N){let J=null;B.supportedCompressionFormats&&(J=B.supportedCompressionFormats.astc?K:B.supportedCompressionFormats.bc7?i:B.supportedCompressionFormats.s3tc?N.qc?X:H:B.supportedCompressionFormats.pvrtc?N.qc?x:S:B.supportedCompressionFormats.etc2?Q:B.supportedCompressionFormats.etc1?f:Z);return J}(J.data.config,v),O=!1;null===Y&&(O=!0,Y=v.qc?X:H);let n=!0;z.startTranscoding()||(n=!1);const e=[];for(let f=0;f<v.images.length&&n;f++){const Q=v.images[f];if(void 0===B.loadSingleImage||B.loadSingleImage===f){let H=Q.levels.length;!1===B.loadMipmapLevels&&(H=1);for(let X=0;X<H;X++){const H=Q.levels[X],i=N(z,f,X,Y,O);if(!i){n=!1;break}H.transcodedPixels=i,e.push(H.transcodedPixels.buffer)}}}z.close(),z.delete(),O&&(Y=-1),n?postMessage({action:"transcode",success:n,id:J.data.id,fileInfo:v,format:Y},e):postMessage({action:"transcode",success:n,id:J.data.id})}}}!function(f){f[f.cTFETC1=0]="cTFETC1",f[f.cTFETC2=1]="cTFETC2",f[f.cTFBC1=2]="cTFBC1",f[f.cTFBC3=3]="cTFBC3",f[f.cTFBC4=4]="cTFBC4",f[f.cTFBC5=5]="cTFBC5",f[f.cTFBC7=6]="cTFBC7",f[f.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",f[f.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",f[f.cTFASTC_4x4=10]="cTFASTC_4x4",f[f.cTFATC_RGB=11]="cTFATC_RGB",f[f.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",f[f.cTFRGBA32=13]="cTFRGBA32",f[f.cTFRGB565=14]="cTFRGB565",f[f.cTFBGR565=15]="cTFBGR565",f[f.cTFRGBA4444=16]="cTFRGBA4444",f[f.cTFFXT1_RGB=17]="cTFFXT1_RGB",f[f.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",f[f.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",f[f.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",f[f.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(X||(X={}));const Z={JSModuleURL:`${i.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${i.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let B=null,N=null,J=0;const g=()=>(B||(B=new Promise(((f,Q)=>{N?f(N):i.g.LoadFileAsync(i.g.GetBabylonScriptURL(Z.WasmModuleURL)).then((H=>{if("function"!==typeof URL)return Q("Basis transcoder requires an environment with a URL constructor");const X=URL.createObjectURL(new Blob([`(${K})()`],{type:"application/javascript"}));N=new Worker(X),function(f,Q,H){return new Promise(((X,S)=>{const x=Q=>{"init"===Q.data.action?(f.removeEventListener("message",x),X(f)):"error"===Q.data.action&&S(Q.data.error||"error initializing worker")};f.addEventListener("message",x),f.postMessage({action:"init",url:H?i.g.GetBabylonScriptURL(H):void 0,wasmBinary:Q},[Q])}))}(N,H,Z.JSModuleURL).then(f,Q)})).catch(Q)}))),B),z=(f,Q)=>{const H=f instanceof ArrayBuffer?new Uint8Array(f):f;return new Promise(((f,X)=>{g().then((()=>{const i=J++,S=Q=>{"transcode"===Q.data.action&&Q.data.id===i&&(N.removeEventListener("message",S),Q.data.success?f(Q.data):X("Transcode is not supported on this device"))};N.addEventListener("message",S);const x=new Uint8Array(H.byteLength);x.set(new Uint8Array(H.buffer,H.byteOffset,H.byteLength)),N.postMessage({action:"transcode",id:i,imageData:x,config:Q,ignoreSupportedFormats:false},[x.buffer])}),(f=>{X(f)}))}))},v=(f,Q)=>{var H;let X=null===(H=Q._gl)||void 0===H?void 0:H.TEXTURE_2D;var i;f.isCube&&(X=null===(i=Q._gl)||void 0===i?void 0:i.TEXTURE_CUBE_MAP);Q._bindTextureDirectly(X,f,!0)},Y=(f,Q)=>{const H=f.getEngine();for(let K=0;K<Q.fileInfo.images.length;K++){const Z=Q.fileInfo.images[K].levels[0];if(f._invertVScale=f.invertY,-1===Q.format||Q.format===X.cTFRGB565)if(f.type=10,f.format=4,!H._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0)f._invertVScale=!f.invertY,f.width=Z.width+3&-4,f.height=Z.height+3&-4,f.samplingMode=2,v(f,H),H._uploadDataToTextureDirectly(f,new Uint16Array(Z.transcodedPixels.buffer),K,0,4,!0);else{const Q=new x.c(H,2);f._invertVScale=f.invertY,Q.type=10,Q.format=4,Q.width=Z.width+3&-4,Q.height=Z.height+3&-4,v(Q,H),H._uploadDataToTextureDirectly(Q,new Uint16Array(Z.transcodedPixels.buffer),K,0,4,!0),H._rescaleTexture(Q,f,H.scenes[0],H._getInternalFormat(4),(()=>{H._releaseTexture(Q),v(f,H)}))}else{f.width=Z.width,f.height=Z.height,f.generateMipMaps=Q.fileInfo.images[K].levels.length>1;const X=O.GetInternalFormatFromBasisFormat(Q.format,H);f.format=X,v(f,H),Q.fileInfo.images[K].levels.forEach(((Q,i)=>{H._uploadCompressedDataToTextureDirectly(f,X,Q.width,Q.height,Q.transcodedPixels,K,i)})),!H._features.basisNeedsPOT||Math.log2(f.width)%1===0&&Math.log2(f.height)%1===0||(i.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),f._cachedWrapU=S.b.CLAMP_ADDRESSMODE,f._cachedWrapV=S.b.CLAMP_ADDRESSMODE)}}},O={JSModuleURL:Z.JSModuleURL,WasmModuleURL:Z.WasmModuleURL,GetInternalFormatFromBasisFormat:(f,Q)=>{let H;switch(f){case X.cTFETC1:H=36196;break;case X.cTFBC1:H=33776;break;case X.cTFBC4:H=33779;break;case X.cTFASTC_4x4:H=37808;break;case X.cTFETC2:H=37496;break;case X.cTFBC7:H=36492}if(void 0===H)throw"The chosen Basis transcoder format is not currently supported";return H},TranscodeAsync:z,LoadTextureFromTranscodeResult:Y};Object.defineProperty(O,"JSModuleURL",{get:function(){return Z.JSModuleURL},set:function(f){Z.JSModuleURL=f}}),Object.defineProperty(O,"WasmModuleURL",{get:function(){return Z.WasmModuleURL},set:function(f){Z.WasmModuleURL=f}});class n{constructor(){this.supportCascades=!1}loadCubeData(f,Q,H,X,S){if(Array.isArray(f))return;const x=Q.getEngine().getCaps(),K={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};z(f,K).then((f=>{const H=f.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;Y(Q,f),Q.getEngine()._setCubeMapTextureParams(Q,H),Q.isReady=!0,Q.onLoadedObservable.notifyObservers(Q),Q.onLoadedObservable.clear(),X&&X()})).catch((f=>{i.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Q.isReady=!0,S&&S(f)}))}loadData(f,Q,H){const X=Q.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};z(f,S).then((f=>{const X=f.fileInfo.images[0].levels[0],i=f.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;H(X.width,X.height,i,-1!==f.format,(()=>{Y(Q,f)}))})).catch((f=>{i.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.g.Warn(`Failed to transcode Basis file: ${f}`),H(0,0,!1,!1,(()=>{}),!0)}))}}}}]);