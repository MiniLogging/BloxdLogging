"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10303:(r,L,M)=>{M.r(L),M.d(L,{_BasisTextureLoader:()=>W});var S,T=M(1120),C=M(918),y=M(1060);function s(){const r=0,L=1,M=2,S=3,T=6,C=8,y=9,s=10,v=14;let u=null;function J(r,L,M,S,T){const C=r.getImageTranscodedSizeInBytes(L,M,S);let y=new Uint8Array(C);if(!r.transcodeImage(y,L,M,S,1,0))return null;if(T){y=function(r,L,M,S){const T=new Uint16Array(4),C=new Uint16Array(M*S),y=M/4,s=S/4;for(let v=0;v<s;v++)for(let S=0;S<y;S++){const s=L+8*(v*y+S);T[0]=r[s]|r[s+1]<<8,T[1]=r[s+2]|r[s+3]<<8,T[2]=(2*(31&T[0])+1*(31&T[1]))/3|(2*(2016&T[0])+1*(2016&T[1]))/3&2016|(2*(63488&T[0])+1*(63488&T[1]))/3&63488,T[3]=(2*(31&T[1])+1*(31&T[0]))/3|(2*(2016&T[1])+1*(2016&T[0]))/3&2016|(2*(63488&T[1])+1*(63488&T[0]))/3&63488;for(let L=0;L<4;L++){const y=r[s+4+L];let u=(4*v+L)*M+4*S;C[u++]=T[3&y],C[u++]=T[y>>2&3],C[u++]=T[y>>4&3],C[u++]=T[y>>6&3]}}return C}(y,0,r.getImageWidth(L,M)+3&-4,r.getImageHeight(L,M)+3&-4)}return y}onmessage=f=>{if("init"===f.data.action){if(f.data.url)try{importScripts(f.data.url)}catch(t){postMessage({action:"error",error:t})}u||(u=BASIS({wasmBinary:f.data.wasmBinary})),null!==u&&u.then((r=>{BASIS=r,r.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===f.data.action){const u=f.data.config,t=f.data.imageData,o=new BASIS.BasisFile(t),h=function(r){const L=r.getHasAlpha(),M=r.getNumImages(),S=[];for(let T=0;T<M;T++){const L={levels:[]},M=r.getNumLevels(T);for(let S=0;S<M;S++){const M={width:r.getImageWidth(T,S),height:r.getImageHeight(T,S)};L.levels.push(M)}S.push(L)}return{Xc:L,images:S}}(o);let U=f.data.ignoreSupportedFormats?null:function(u,J){let f=null;u.supportedCompressionFormats&&(f=u.supportedCompressionFormats.astc?s:u.supportedCompressionFormats.bc7?T:u.supportedCompressionFormats.s3tc?J.Xc?S:M:u.supportedCompressionFormats.pvrtc?J.Xc?y:C:u.supportedCompressionFormats.etc2?L:u.supportedCompressionFormats.etc1?r:v);return f}(f.data.config,h),G=!1;null===U&&(G=!0,U=h.Xc?S:M);let W=!0;o.startTranscoding()||(W=!1);const l=[];for(let r=0;r<h.images.length&&W;r++){const L=h.images[r];if(void 0===u.loadSingleImage||u.loadSingleImage===r){let M=L.levels.length;!1===u.loadMipmapLevels&&(M=1);for(let S=0;S<M;S++){const M=L.levels[S],T=J(o,r,S,U,G);if(!T){W=!1;break}M.transcodedPixels=T,l.push(M.transcodedPixels.buffer)}}}o.close(),o.delete(),G&&(U=-1),W?postMessage({action:"transcode",success:W,id:f.data.id,fileInfo:h,format:U},l):postMessage({action:"transcode",success:W,id:f.data.id})}}}!function(r){r[r.cTFETC1=0]="cTFETC1",r[r.cTFETC2=1]="cTFETC2",r[r.cTFBC1=2]="cTFBC1",r[r.cTFBC3=3]="cTFBC3",r[r.cTFBC4=4]="cTFBC4",r[r.cTFBC5=5]="cTFBC5",r[r.cTFBC7=6]="cTFBC7",r[r.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",r[r.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",r[r.cTFASTC_4x4=10]="cTFASTC_4x4",r[r.cTFATC_RGB=11]="cTFATC_RGB",r[r.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",r[r.cTFRGBA32=13]="cTFRGBA32",r[r.cTFRGB565=14]="cTFRGB565",r[r.cTFBGR565=15]="cTFBGR565",r[r.cTFRGBA4444=16]="cTFRGBA4444",r[r.cTFFXT1_RGB=17]="cTFFXT1_RGB",r[r.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",r[r.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",r[r.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",r[r.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(S||(S={}));const v={JSModuleURL:`${T.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${T.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let u=null,J=null,f=0;const t=()=>(u||(u=new Promise(((r,L)=>{J?r(J):T.g.LoadFileAsync(T.g.GetBabylonScriptURL(v.WasmModuleURL)).then((M=>{if("function"!==typeof URL)return L("Basis transcoder requires an environment with a URL constructor");const S=URL.createObjectURL(new Blob([`(${s})()`],{type:"application/javascript"}));J=new Worker(S),function(r,L,M){return new Promise(((S,C)=>{const y=L=>{"init"===L.data.action?(r.removeEventListener("message",y),S(r)):"error"===L.data.action&&C(L.data.error||"error initializing worker")};r.addEventListener("message",y),r.postMessage({action:"init",url:M?T.g.GetBabylonScriptURL(M):void 0,wasmBinary:L},[L])}))}(J,M,v.JSModuleURL).then(r,L)})).catch(L)}))),u),o=(r,L)=>{const M=r instanceof ArrayBuffer?new Uint8Array(r):r;return new Promise(((r,S)=>{t().then((()=>{const T=f++,C=L=>{"transcode"===L.data.action&&L.data.id===T&&(J.removeEventListener("message",C),L.data.success?r(L.data):S("Transcode is not supported on this device"))};J.addEventListener("message",C);const y=new Uint8Array(M.byteLength);y.set(new Uint8Array(M.buffer,M.byteOffset,M.byteLength)),J.postMessage({action:"transcode",id:T,imageData:y,config:L,ignoreSupportedFormats:false},[y.buffer])}),(r=>{S(r)}))}))},h=(r,L)=>{var M;let S=null===(M=L._gl)||void 0===M?void 0:M.TEXTURE_2D;var T;r.isCube&&(S=null===(T=L._gl)||void 0===T?void 0:T.TEXTURE_CUBE_MAP);L._bindTextureDirectly(S,r,!0)},U=(r,L)=>{const M=r.getEngine();for(let s=0;s<L.fileInfo.images.length;s++){const v=L.fileInfo.images[s].levels[0];if(r._invertVScale=r.invertY,-1===L.format||L.format===S.cTFRGB565)if(r.type=10,r.format=4,!M._features.basisNeedsPOT||Math.log2(v.width)%1===0&&Math.log2(v.height)%1===0)r._invertVScale=!r.invertY,r.width=v.width+3&-4,r.height=v.height+3&-4,r.samplingMode=2,h(r,M),M._uploadDataToTextureDirectly(r,new Uint16Array(v.transcodedPixels.buffer),s,0,4,!0);else{const L=new y.b(M,2);r._invertVScale=r.invertY,L.type=10,L.format=4,L.width=v.width+3&-4,L.height=v.height+3&-4,h(L,M),M._uploadDataToTextureDirectly(L,new Uint16Array(v.transcodedPixels.buffer),s,0,4,!0),M._rescaleTexture(L,r,M.scenes[0],M._getInternalFormat(4),(()=>{M._releaseTexture(L),h(r,M)}))}else{r.width=v.width,r.height=v.height,r.generateMipMaps=L.fileInfo.images[s].levels.length>1;const S=G.GetInternalFormatFromBasisFormat(L.format,M);r.format=S,h(r,M),L.fileInfo.images[s].levels.forEach(((L,T)=>{M._uploadCompressedDataToTextureDirectly(r,S,L.width,L.height,L.transcodedPixels,s,T)})),!M._features.basisNeedsPOT||Math.log2(r.width)%1===0&&Math.log2(r.height)%1===0||(T.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),r._cachedWrapU=C.c.CLAMP_ADDRESSMODE,r._cachedWrapV=C.c.CLAMP_ADDRESSMODE)}}},G={JSModuleURL:v.JSModuleURL,WasmModuleURL:v.WasmModuleURL,GetInternalFormatFromBasisFormat:(r,L)=>{let M;switch(r){case S.cTFETC1:M=36196;break;case S.cTFBC1:M=33776;break;case S.cTFBC4:M=33779;break;case S.cTFASTC_4x4:M=37808;break;case S.cTFETC2:M=37496;break;case S.cTFBC7:M=36492}if(void 0===M)throw"The chosen Basis transcoder format is not currently supported";return M},TranscodeAsync:o,LoadTextureFromTranscodeResult:U};Object.defineProperty(G,"JSModuleURL",{get:function(){return v.JSModuleURL},set:function(r){v.JSModuleURL=r}}),Object.defineProperty(G,"WasmModuleURL",{get:function(){return v.WasmModuleURL},set:function(r){v.WasmModuleURL=r}});class W{constructor(){this.supportCascades=!1}loadCubeData(r,L,M,S,C){if(Array.isArray(r))return;const y=L.getEngine().getCaps(),s={supportedCompressionFormats:{etc1:!!y.etc1,s3tc:!!y.s3tc,pvrtc:!!y.pvrtc,etc2:!!y.etc2,astc:!!y.astc,bc7:!!y.bptc}};o(r,s).then((r=>{const M=r.fileInfo.images[0].levels.length>1&&L.generateMipMaps;U(L,r),L.getEngine()._setCubeMapTextureParams(L,M),L.isReady=!0,L.onLoadedObservable.notifyObservers(L),L.onLoadedObservable.clear(),S&&S()})).catch((r=>{T.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),L.isReady=!0,C&&C(r)}))}loadData(r,L,M){const S=L.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};o(r,C).then((r=>{const S=r.fileInfo.images[0].levels[0],T=r.fileInfo.images[0].levels.length>1&&L.generateMipMaps;M(S.width,S.height,T,-1!==r.format,(()=>{U(L,r)}))})).catch((r=>{T.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.g.Warn(`Failed to transcode Basis file: ${r}`),M(0,0,!1,!1,(()=>{}),!0)}))}}}}]);