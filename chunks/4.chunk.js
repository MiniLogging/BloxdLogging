"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10394:(A,I,y)=>{y.r(I),y.d(I,{_BasisTextureLoader:()=>x});var X,F=y(1213),M=y(989),g=y(1139);function d(){const A=0,I=1,y=2,X=3,F=6,M=8,g=9,d=10,V=14;let k=null;function U(A,I,y,X,F){const M=A.getImageTranscodedSizeInBytes(I,y,X);let g=new Uint8Array(M);if(!A.transcodeImage(g,I,y,X,1,0))return null;if(F){g=function(A,I,y,X){const F=new Uint16Array(4),M=new Uint16Array(y*X),g=y/4,d=X/4;for(let V=0;V<d;V++)for(let X=0;X<g;X++){const d=I+8*(V*g+X);F[0]=A[d]|A[d+1]<<8,F[1]=A[d+2]|A[d+3]<<8,F[2]=(2*(31&F[0])+1*(31&F[1]))/3|(2*(2016&F[0])+1*(2016&F[1]))/3&2016|(2*(63488&F[0])+1*(63488&F[1]))/3&63488,F[3]=(2*(31&F[1])+1*(31&F[0]))/3|(2*(2016&F[1])+1*(2016&F[0]))/3&2016|(2*(63488&F[1])+1*(63488&F[0]))/3&63488;for(let I=0;I<4;I++){const g=A[d+4+I];let k=(4*V+I)*y+4*X;M[k++]=F[3&g],M[k++]=F[g>>2&3],M[k++]=F[g>>4&3],M[k++]=F[g>>6&3]}}return M}(g,0,A.getImageWidth(I,y)+3&-4,A.getImageHeight(I,y)+3&-4)}return g}onmessage=P=>{if("init"===P.data.action){if(P.data.url)try{importScripts(P.data.url)}catch(f){postMessage({action:"error",error:f})}k||(k=BASIS({wasmBinary:P.data.wasmBinary})),null!==k&&k.then((A=>{BASIS=A,A.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===P.data.action){const k=P.data.config,f=P.data.imageData,z=new BASIS.BasisFile(f),l=function(A){const I=A.getHasAlpha(),y=A.getNumImages(),X=[];for(let F=0;F<y;F++){const I={levels:[]},y=A.getNumLevels(F);for(let X=0;X<y;X++){const y={width:A.getImageWidth(F,X),height:A.getImageHeight(F,X)};I.levels.push(y)}X.push(I)}return{od:I,images:X}}(z);let u=P.data.ignoreSupportedFormats?null:function(k,U){let P=null;k.supportedCompressionFormats&&(P=k.supportedCompressionFormats.astc?d:k.supportedCompressionFormats.bc7?F:k.supportedCompressionFormats.s3tc?U.od?X:y:k.supportedCompressionFormats.pvrtc?U.od?g:M:k.supportedCompressionFormats.etc2?I:k.supportedCompressionFormats.etc1?A:V);return P}(P.data.config,l),K=!1;null===u&&(K=!0,u=l.od?X:y);let x=!0;z.startTranscoding()||(x=!1);const t=[];for(let A=0;A<l.images.length&&x;A++){const I=l.images[A];if(void 0===k.loadSingleImage||k.loadSingleImage===A){let y=I.levels.length;!1===k.loadMipmapLevels&&(y=1);for(let X=0;X<y;X++){const y=I.levels[X],F=U(z,A,X,u,K);if(!F){x=!1;break}y.transcodedPixels=F,t.push(y.transcodedPixels.buffer)}}}z.close(),z.delete(),K&&(u=-1),x?postMessage({action:"transcode",success:x,id:P.data.id,fileInfo:l,format:u},t):postMessage({action:"transcode",success:x,id:P.data.id})}}}!function(A){A[A.cTFETC1=0]="cTFETC1",A[A.cTFETC2=1]="cTFETC2",A[A.cTFBC1=2]="cTFBC1",A[A.cTFBC3=3]="cTFBC3",A[A.cTFBC4=4]="cTFBC4",A[A.cTFBC5=5]="cTFBC5",A[A.cTFBC7=6]="cTFBC7",A[A.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",A[A.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",A[A.cTFASTC_4x4=10]="cTFASTC_4x4",A[A.cTFATC_RGB=11]="cTFATC_RGB",A[A.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",A[A.cTFRGBA32=13]="cTFRGBA32",A[A.cTFRGB565=14]="cTFRGB565",A[A.cTFBGR565=15]="cTFBGR565",A[A.cTFRGBA4444=16]="cTFRGBA4444",A[A.cTFFXT1_RGB=17]="cTFFXT1_RGB",A[A.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",A[A.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",A[A.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",A[A.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(X||(X={}));const V={JSModuleURL:`${F.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${F.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let k=null,U=null,P=0;const f=()=>(k||(k=new Promise(((A,I)=>{U?A(U):F.e.LoadFileAsync(F.e.GetBabylonScriptURL(V.WasmModuleURL)).then((y=>{if("function"!==typeof URL)return I("Basis transcoder requires an environment with a URL constructor");const X=URL.createObjectURL(new Blob([`(${d})()`],{type:"application/javascript"}));U=new Worker(X),function(A,I,y){return new Promise(((X,M)=>{const g=I=>{"init"===I.data.action?(A.removeEventListener("message",g),X(A)):"error"===I.data.action&&M(I.data.error||"error initializing worker")};A.addEventListener("message",g),A.postMessage({action:"init",url:y?F.e.GetBabylonScriptURL(y):void 0,wasmBinary:I},[I])}))}(U,y,V.JSModuleURL).then(A,I)})).catch(I)}))),k),z=(A,I)=>{const y=A instanceof ArrayBuffer?new Uint8Array(A):A;return new Promise(((A,X)=>{f().then((()=>{const F=P++,M=I=>{"transcode"===I.data.action&&I.data.id===F&&(U.removeEventListener("message",M),I.data.success?A(I.data):X("Transcode is not supported on this device"))};U.addEventListener("message",M);const g=new Uint8Array(y.byteLength);g.set(new Uint8Array(y.buffer,y.byteOffset,y.byteLength)),U.postMessage({action:"transcode",id:F,imageData:g,config:I,ignoreSupportedFormats:false},[g.buffer])}),(A=>{X(A)}))}))},l=(A,I)=>{var y;let X=null===(y=I._gl)||void 0===y?void 0:y.TEXTURE_2D;var F;A.isCube&&(X=null===(F=I._gl)||void 0===F?void 0:F.TEXTURE_CUBE_MAP);I._bindTextureDirectly(X,A,!0)},u=(A,I)=>{const y=A.getEngine();for(let d=0;d<I.fileInfo.images.length;d++){const V=I.fileInfo.images[d].levels[0];if(A._invertVScale=A.invertY,-1===I.format||I.format===X.cTFRGB565)if(A.type=10,A.format=4,!y._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0)A._invertVScale=!A.invertY,A.width=V.width+3&-4,A.height=V.height+3&-4,A.samplingMode=2,l(A,y),y._uploadDataToTextureDirectly(A,new Uint16Array(V.transcodedPixels.buffer),d,0,4,!0);else{const I=new g.b(y,2);A._invertVScale=A.invertY,I.type=10,I.format=4,I.width=V.width+3&-4,I.height=V.height+3&-4,l(I,y),y._uploadDataToTextureDirectly(I,new Uint16Array(V.transcodedPixels.buffer),d,0,4,!0),y._rescaleTexture(I,A,y.scenes[0],y._getInternalFormat(4),(()=>{y._releaseTexture(I),l(A,y)}))}else{A.width=V.width,A.height=V.height,A.generateMipMaps=I.fileInfo.images[d].levels.length>1;const X=K.GetInternalFormatFromBasisFormat(I.format,y);A.format=X,l(A,y),I.fileInfo.images[d].levels.forEach(((I,F)=>{y._uploadCompressedDataToTextureDirectly(A,X,I.width,I.height,I.transcodedPixels,d,F)})),!y._features.basisNeedsPOT||Math.log2(A.width)%1===0&&Math.log2(A.height)%1===0||(F.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),A._cachedWrapU=M.d.CLAMP_ADDRESSMODE,A._cachedWrapV=M.d.CLAMP_ADDRESSMODE)}}},K={JSModuleURL:V.JSModuleURL,WasmModuleURL:V.WasmModuleURL,GetInternalFormatFromBasisFormat:(A,I)=>{let y;switch(A){case X.cTFETC1:y=36196;break;case X.cTFBC1:y=33776;break;case X.cTFBC4:y=33779;break;case X.cTFASTC_4x4:y=37808;break;case X.cTFETC2:y=37496;break;case X.cTFBC7:y=36492}if(void 0===y)throw"The chosen Basis transcoder format is not currently supported";return y},TranscodeAsync:z,LoadTextureFromTranscodeResult:u};Object.defineProperty(K,"JSModuleURL",{get:function(){return V.JSModuleURL},set:function(A){V.JSModuleURL=A}}),Object.defineProperty(K,"WasmModuleURL",{get:function(){return V.WasmModuleURL},set:function(A){V.WasmModuleURL=A}});class x{constructor(){this.supportCascades=!1}loadCubeData(A,I,y,X,M){if(Array.isArray(A))return;const g=I.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};z(A,d).then((A=>{const y=A.fileInfo.images[0].levels.length>1&&I.generateMipMaps;u(I,A),I.getEngine()._setCubeMapTextureParams(I,y),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),X&&X()})).catch((A=>{F.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.isReady=!0,M&&M(A)}))}loadData(A,I,y){const X=I.getEngine().getCaps(),M={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};z(A,M).then((A=>{const X=A.fileInfo.images[0].levels[0],F=A.fileInfo.images[0].levels.length>1&&I.generateMipMaps;y(X.width,X.height,F,-1!==A.format,(()=>{u(I,A)}))})).catch((A=>{F.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),F.e.Warn(`Failed to transcode Basis file: ${A}`),y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);