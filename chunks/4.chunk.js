"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{11238:(x,Z,l)=>{l.r(Z),l.d(Z,{_BasisTextureLoader:()=>v});var t,L=l(1274),z=l(1018),A=l(1206);function P(){const x=0,Z=1,l=2,t=3,L=6,z=8,A=9,P=10,C=14;let j=null;function V(x,Z,l,t,L){const z=x.getImageTranscodedSizeInBytes(Z,l,t);let A=new Uint8Array(z);if(!x.transcodeImage(A,Z,l,t,1,0))return null;if(L){A=function(x,Z,l,t){const L=new Uint16Array(4),z=new Uint16Array(l*t),A=l/4,P=t/4;for(let C=0;C<P;C++)for(let t=0;t<A;t++){const P=Z+8*(C*A+t);L[0]=x[P]|x[P+1]<<8,L[1]=x[P+2]|x[P+3]<<8,L[2]=(2*(31&L[0])+1*(31&L[1]))/3|(2*(2016&L[0])+1*(2016&L[1]))/3&2016|(2*(63488&L[0])+1*(63488&L[1]))/3&63488,L[3]=(2*(31&L[1])+1*(31&L[0]))/3|(2*(2016&L[1])+1*(2016&L[0]))/3&2016|(2*(63488&L[1])+1*(63488&L[0]))/3&63488;for(let Z=0;Z<4;Z++){const A=x[P+4+Z];let j=(4*C+Z)*l+4*t;z[j++]=L[3&A],z[j++]=L[A>>2&3],z[j++]=L[A>>4&3],z[j++]=L[A>>6&3]}}return z}(A,0,x.getImageWidth(Z,l)+3&-4,x.getImageHeight(Z,l)+3&-4)}return A}onmessage=Q=>{if("init"===Q.data.action){if(Q.data.url)try{importScripts(Q.data.url)}catch(c){postMessage({action:"error",error:c})}j||(j=BASIS({wasmBinary:Q.data.wasmBinary})),null!==j&&j.then((x=>{BASIS=x,x.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Q.data.action){const j=Q.data.config,c=Q.data.imageData,a=new BASIS.BasisFile(c),I=function(x){const Z=x.getHasAlpha(),l=x.getNumImages(),t=[];for(let L=0;L<l;L++){const Z={levels:[]},l=x.getNumLevels(L);for(let t=0;t<l;t++){const l={width:x.getImageWidth(L,t),height:x.getImageHeight(L,t)};Z.levels.push(l)}t.push(Z)}return{mc:Z,images:t}}(a);let u=Q.data.ignoreSupportedFormats?null:function(j,V){let Q=null;j.supportedCompressionFormats&&(Q=j.supportedCompressionFormats.astc?P:j.supportedCompressionFormats.bc7?L:j.supportedCompressionFormats.s3tc?V.mc?t:l:j.supportedCompressionFormats.pvrtc?V.mc?A:z:j.supportedCompressionFormats.etc2?Z:j.supportedCompressionFormats.etc1?x:C);return Q}(Q.data.config,I),n=!1;null===u&&(n=!0,u=I.mc?t:l);let v=!0;a.startTranscoding()||(v=!1);const X=[];for(let x=0;x<I.images.length&&v;x++){const Z=I.images[x];if(void 0===j.loadSingleImage||j.loadSingleImage===x){let l=Z.levels.length;!1===j.loadMipmapLevels&&(l=1);for(let t=0;t<l;t++){const l=Z.levels[t],L=V(a,x,t,u,n);if(!L){v=!1;break}l.transcodedPixels=L,X.push(l.transcodedPixels.buffer)}}}a.close(),a.delete(),n&&(u=-1),v?postMessage({action:"transcode",success:v,id:Q.data.id,fileInfo:I,format:u},X):postMessage({action:"transcode",success:v,id:Q.data.id})}}}!function(x){x[x.cTFETC1=0]="cTFETC1",x[x.cTFETC2=1]="cTFETC2",x[x.cTFBC1=2]="cTFBC1",x[x.cTFBC3=3]="cTFBC3",x[x.cTFBC4=4]="cTFBC4",x[x.cTFBC5=5]="cTFBC5",x[x.cTFBC7=6]="cTFBC7",x[x.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",x[x.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",x[x.cTFASTC_4x4=10]="cTFASTC_4x4",x[x.cTFATC_RGB=11]="cTFATC_RGB",x[x.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",x[x.cTFRGBA32=13]="cTFRGBA32",x[x.cTFRGB565=14]="cTFRGB565",x[x.cTFBGR565=15]="cTFBGR565",x[x.cTFRGBA4444=16]="cTFRGBA4444",x[x.cTFFXT1_RGB=17]="cTFFXT1_RGB",x[x.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",x[x.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",x[x.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",x[x.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(t||(t={}));const C={JSModuleURL:`${L.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${L.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let j=null,V=null,Q=0;const c=()=>(j||(j=new Promise(((x,Z)=>{V?x(V):L.f.LoadFileAsync(L.f.GetBabylonScriptURL(C.WasmModuleURL)).then((l=>{if("function"!==typeof URL)return Z("Basis transcoder requires an environment with a URL constructor");const t=URL.createObjectURL(new Blob([`(${P})()`],{type:"application/javascript"}));V=new Worker(t),function(x,Z,l){return new Promise(((t,z)=>{const A=Z=>{"init"===Z.data.action?(x.removeEventListener("message",A),t(x)):"error"===Z.data.action&&z(Z.data.error||"error initializing worker")};x.addEventListener("message",A),x.postMessage({action:"init",url:l?L.f.GetBabylonScriptURL(l):void 0,wasmBinary:Z},[Z])}))}(V,l,C.JSModuleURL).then(x,Z)})).catch(Z)}))),j),a=(x,Z)=>{const l=x instanceof ArrayBuffer?new Uint8Array(x):x;return new Promise(((x,t)=>{c().then((()=>{const L=Q++,z=Z=>{"transcode"===Z.data.action&&Z.data.id===L&&(V.removeEventListener("message",z),Z.data.success?x(Z.data):t("Transcode is not supported on this device"))};V.addEventListener("message",z);const A=new Uint8Array(l.byteLength);A.set(new Uint8Array(l.buffer,l.byteOffset,l.byteLength)),V.postMessage({action:"transcode",id:L,imageData:A,config:Z,ignoreSupportedFormats:false},[A.buffer])}),(x=>{t(x)}))}))},I=(x,Z)=>{var l;let t=null===(l=Z._gl)||void 0===l?void 0:l.TEXTURE_2D;var L;x.isCube&&(t=null===(L=Z._gl)||void 0===L?void 0:L.TEXTURE_CUBE_MAP);Z._bindTextureDirectly(t,x,!0)},u=(x,Z)=>{const l=x.getEngine();for(let P=0;P<Z.fileInfo.images.length;P++){const C=Z.fileInfo.images[P].levels[0];if(x._invertVScale=x.invertY,-1===Z.format||Z.format===t.cTFRGB565)if(x.type=10,x.format=4,!l._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)x._invertVScale=!x.invertY,x.width=C.width+3&-4,x.height=C.height+3&-4,x.samplingMode=2,I(x,l),l._uploadDataToTextureDirectly(x,new Uint16Array(C.transcodedPixels.buffer),P,0,4,!0);else{const Z=new A.b(l,2);x._invertVScale=x.invertY,Z.type=10,Z.format=4,Z.width=C.width+3&-4,Z.height=C.height+3&-4,I(Z,l),l._uploadDataToTextureDirectly(Z,new Uint16Array(C.transcodedPixels.buffer),P,0,4,!0),l._rescaleTexture(Z,x,l.scenes[0],l._getInternalFormat(4),(()=>{l._releaseTexture(Z),I(x,l)}))}else{x.width=C.width,x.height=C.height,x.generateMipMaps=Z.fileInfo.images[P].levels.length>1;const t=n.GetInternalFormatFromBasisFormat(Z.format,l);x.format=t,I(x,l),Z.fileInfo.images[P].levels.forEach(((Z,L)=>{l._uploadCompressedDataToTextureDirectly(x,t,Z.width,Z.height,Z.transcodedPixels,P,L)})),!l._features.basisNeedsPOT||Math.log2(x.width)%1===0&&Math.log2(x.height)%1===0||(L.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),x._cachedWrapU=z.b.CLAMP_ADDRESSMODE,x._cachedWrapV=z.b.CLAMP_ADDRESSMODE)}}},n={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(x,Z)=>{let l;switch(x){case t.cTFETC1:l=36196;break;case t.cTFBC1:l=33776;break;case t.cTFBC4:l=33779;break;case t.cTFASTC_4x4:l=37808;break;case t.cTFETC2:l=37496;break;case t.cTFBC7:l=36492}if(void 0===l)throw"The chosen Basis transcoder format is not currently supported";return l},TranscodeAsync:a,LoadTextureFromTranscodeResult:u};Object.defineProperty(n,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(x){C.JSModuleURL=x}}),Object.defineProperty(n,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(x){C.WasmModuleURL=x}});class v{constructor(){this.supportCascades=!1}loadCubeData(x,Z,l,t,z){if(Array.isArray(x))return;const A=Z.getEngine().getCaps(),P={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};a(x,P).then((x=>{const l=x.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;u(Z,x),Z.getEngine()._setCubeMapTextureParams(Z,l),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),t&&t()})).catch((x=>{L.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.isReady=!0,z&&z(x)}))}loadData(x,Z,l){const t=Z.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!t.etc1,s3tc:!!t.s3tc,pvrtc:!!t.pvrtc,etc2:!!t.etc2,astc:!!t.astc,bc7:!!t.bptc}};a(x,z).then((x=>{const t=x.fileInfo.images[0].levels[0],L=x.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;l(t.width,t.height,L,-1!==x.format,(()=>{u(Z,x)}))})).catch((x=>{L.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),L.f.Warn(`Failed to transcode Basis file: ${x}`),l(0,0,!1,!1,(()=>{}),!0)}))}}}}]);