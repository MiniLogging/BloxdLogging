"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10886:(F,e,a)=>{a.r(e),a.d(e,{_BasisTextureLoader:()=>b});var k,h=a(1220),z=a(980),x=a(1144);function t(){const F=0,e=1,a=2,k=3,h=6,z=8,x=9,t=10,H=14;let p=null;function y(F,e,a,k,h){const z=F.getImageTranscodedSizeInBytes(e,a,k);let x=new Uint8Array(z);if(!F.transcodeImage(x,e,a,k,1,0))return null;if(h){x=function(F,e,a,k){const h=new Uint16Array(4),z=new Uint16Array(a*k),x=a/4,t=k/4;for(let H=0;H<t;H++)for(let k=0;k<x;k++){const t=e+8*(H*x+k);h[0]=F[t]|F[t+1]<<8,h[1]=F[t+2]|F[t+3]<<8,h[2]=(2*(31&h[0])+1*(31&h[1]))/3|(2*(2016&h[0])+1*(2016&h[1]))/3&2016|(2*(63488&h[0])+1*(63488&h[1]))/3&63488,h[3]=(2*(31&h[1])+1*(31&h[0]))/3|(2*(2016&h[1])+1*(2016&h[0]))/3&2016|(2*(63488&h[1])+1*(63488&h[0]))/3&63488;for(let e=0;e<4;e++){const x=F[t+4+e];let p=(4*H+e)*a+4*k;z[p++]=h[3&x],z[p++]=h[x>>2&3],z[p++]=h[x>>4&3],z[p++]=h[x>>6&3]}}return z}(x,0,F.getImageWidth(e,a)+3&-4,F.getImageHeight(e,a)+3&-4)}return x}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(s){postMessage({action:"error",error:s})}p||(p=BASIS({wasmBinary:L.data.wasmBinary})),null!==p&&p.then((F=>{BASIS=F,F.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const p=L.data.config,s=L.data.imageData,Z=new BASIS.BasisFile(s),A=function(F){const e=F.getHasAlpha(),a=F.getNumImages(),k=[];for(let h=0;h<a;h++){const e={levels:[]},a=F.getNumLevels(h);for(let k=0;k<a;k++){const a={width:F.getImageWidth(h,k),height:F.getImageHeight(h,k)};e.levels.push(a)}k.push(e)}return{jd:e,images:k}}(Z);let w=L.data.ignoreSupportedFormats?null:function(p,y){let L=null;p.supportedCompressionFormats&&(L=p.supportedCompressionFormats.astc?t:p.supportedCompressionFormats.bc7?h:p.supportedCompressionFormats.s3tc?y.jd?k:a:p.supportedCompressionFormats.pvrtc?y.jd?x:z:p.supportedCompressionFormats.etc2?e:p.supportedCompressionFormats.etc1?F:H);return L}(L.data.config,A),I=!1;null===w&&(I=!0,w=A.jd?k:a);let b=!0;Z.startTranscoding()||(b=!1);const u=[];for(let F=0;F<A.images.length&&b;F++){const e=A.images[F];if(void 0===p.loadSingleImage||p.loadSingleImage===F){let a=e.levels.length;!1===p.loadMipmapLevels&&(a=1);for(let k=0;k<a;k++){const a=e.levels[k],h=y(Z,F,k,w,I);if(!h){b=!1;break}a.transcodedPixels=h,u.push(a.transcodedPixels.buffer)}}}Z.close(),Z.delete(),I&&(w=-1),b?postMessage({action:"transcode",success:b,id:L.data.id,fileInfo:A,format:w},u):postMessage({action:"transcode",success:b,id:L.data.id})}}}!function(F){F[F.cTFETC1=0]="cTFETC1",F[F.cTFETC2=1]="cTFETC2",F[F.cTFBC1=2]="cTFBC1",F[F.cTFBC3=3]="cTFBC3",F[F.cTFBC4=4]="cTFBC4",F[F.cTFBC5=5]="cTFBC5",F[F.cTFBC7=6]="cTFBC7",F[F.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",F[F.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",F[F.cTFASTC_4x4=10]="cTFASTC_4x4",F[F.cTFATC_RGB=11]="cTFATC_RGB",F[F.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",F[F.cTFRGBA32=13]="cTFRGBA32",F[F.cTFRGB565=14]="cTFRGB565",F[F.cTFBGR565=15]="cTFBGR565",F[F.cTFRGBA4444=16]="cTFRGBA4444",F[F.cTFFXT1_RGB=17]="cTFFXT1_RGB",F[F.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",F[F.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",F[F.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",F[F.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(k||(k={}));const H={JSModuleURL:`${h.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${h.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let p=null,y=null,L=0;const s=()=>(p||(p=new Promise(((F,e)=>{y?F(y):h.c.LoadFileAsync(h.c.GetBabylonScriptURL(H.WasmModuleURL)).then((a=>{if("function"!==typeof URL)return e("Basis transcoder requires an environment with a URL constructor");const k=URL.createObjectURL(new Blob([`(${t})()`],{type:"application/javascript"}));y=new Worker(k),function(F,e,a){return new Promise(((k,z)=>{const x=e=>{"init"===e.data.action?(F.removeEventListener("message",x),k(F)):"error"===e.data.action&&z(e.data.error||"error initializing worker")};F.addEventListener("message",x),F.postMessage({action:"init",url:a?h.c.GetBabylonScriptURL(a):void 0,wasmBinary:e},[e])}))}(y,a,H.JSModuleURL).then(F,e)})).catch(e)}))),p),Z=(F,e)=>{const a=F instanceof ArrayBuffer?new Uint8Array(F):F;return new Promise(((F,k)=>{s().then((()=>{const h=L++,z=e=>{"transcode"===e.data.action&&e.data.id===h&&(y.removeEventListener("message",z),e.data.success?F(e.data):k("Transcode is not supported on this device"))};y.addEventListener("message",z);const x=new Uint8Array(a.byteLength);x.set(new Uint8Array(a.buffer,a.byteOffset,a.byteLength)),y.postMessage({action:"transcode",id:h,imageData:x,config:e,ignoreSupportedFormats:false},[x.buffer])}),(F=>{k(F)}))}))},A=(F,e)=>{var a;let k=null===(a=e._gl)||void 0===a?void 0:a.TEXTURE_2D;var h;F.isCube&&(k=null===(h=e._gl)||void 0===h?void 0:h.TEXTURE_CUBE_MAP);e._bindTextureDirectly(k,F,!0)},w=(F,e)=>{const a=F.getEngine();for(let t=0;t<e.fileInfo.images.length;t++){const H=e.fileInfo.images[t].levels[0];if(F._invertVScale=F.invertY,-1===e.format||e.format===k.cTFRGB565)if(F.type=10,F.format=4,!a._features.basisNeedsPOT||Math.log2(H.width)%1===0&&Math.log2(H.height)%1===0)F._invertVScale=!F.invertY,F.width=H.width+3&-4,F.height=H.height+3&-4,F.samplingMode=2,A(F,a),a._uploadDataToTextureDirectly(F,new Uint16Array(H.transcodedPixels.buffer),t,0,4,!0);else{const e=new x.b(a,2);F._invertVScale=F.invertY,e.type=10,e.format=4,e.width=H.width+3&-4,e.height=H.height+3&-4,A(e,a),a._uploadDataToTextureDirectly(e,new Uint16Array(H.transcodedPixels.buffer),t,0,4,!0),a._rescaleTexture(e,F,a.scenes[0],a._getInternalFormat(4),(()=>{a._releaseTexture(e),A(F,a)}))}else{F.width=H.width,F.height=H.height,F.generateMipMaps=e.fileInfo.images[t].levels.length>1;const k=I.GetInternalFormatFromBasisFormat(e.format,a);F.format=k,A(F,a),e.fileInfo.images[t].levels.forEach(((e,h)=>{a._uploadCompressedDataToTextureDirectly(F,k,e.width,e.height,e.transcodedPixels,t,h)})),!a._features.basisNeedsPOT||Math.log2(F.width)%1===0&&Math.log2(F.height)%1===0||(h.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),F._cachedWrapU=z.e.CLAMP_ADDRESSMODE,F._cachedWrapV=z.e.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:H.JSModuleURL,WasmModuleURL:H.WasmModuleURL,GetInternalFormatFromBasisFormat:(F,e)=>{let a;switch(F){case k.cTFETC1:a=36196;break;case k.cTFBC1:a=33776;break;case k.cTFBC4:a=33779;break;case k.cTFASTC_4x4:a=37808;break;case k.cTFETC2:a=37496;break;case k.cTFBC7:a=36492}if(void 0===a)throw"The chosen Basis transcoder format is not currently supported";return a},TranscodeAsync:Z,LoadTextureFromTranscodeResult:w};Object.defineProperty(I,"JSModuleURL",{get:function(){return H.JSModuleURL},set:function(F){H.JSModuleURL=F}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return H.WasmModuleURL},set:function(F){H.WasmModuleURL=F}});class b{constructor(){this.supportCascades=!1}loadCubeData(F,e,a,k,z){if(Array.isArray(F))return;const x=e.getEngine().getCaps(),t={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};Z(F,t).then((F=>{const a=F.fileInfo.images[0].levels.length>1&&e.generateMipMaps;w(e,F),e.getEngine()._setCubeMapTextureParams(e,a),e.isReady=!0,e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),k&&k()})).catch((F=>{h.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),e.isReady=!0,z&&z(F)}))}loadData(F,e,a){const k=e.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};Z(F,z).then((F=>{const k=F.fileInfo.images[0].levels[0],h=F.fileInfo.images[0].levels.length>1&&e.generateMipMaps;a(k.width,k.height,h,-1!==F.format,(()=>{w(e,F)}))})).catch((F=>{h.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.c.Warn(`Failed to transcode Basis file: ${F}`),a(0,0,!1,!1,(()=>{}),!0)}))}}}}]);