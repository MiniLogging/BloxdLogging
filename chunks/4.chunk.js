"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10654:(C,M,x)=>{x.r(M),x.d(M,{_BasisTextureLoader:()=>L});var f,T=x(1192),z=x(945),s=x(1121);function S(){const C=0,M=1,x=2,f=3,T=6,z=8,s=9,S=10,m=14;let Q=null;function V(C,M,x,f,T){const z=C.getImageTranscodedSizeInBytes(M,x,f);let s=new Uint8Array(z);if(!C.transcodeImage(s,M,x,f,1,0))return null;if(T){s=function(C,M,x,f){const T=new Uint16Array(4),z=new Uint16Array(x*f),s=x/4,S=f/4;for(let m=0;m<S;m++)for(let f=0;f<s;f++){const S=M+8*(m*s+f);T[0]=C[S]|C[S+1]<<8,T[1]=C[S+2]|C[S+3]<<8,T[2]=(2*(31&T[0])+1*(31&T[1]))/3|(2*(2016&T[0])+1*(2016&T[1]))/3&2016|(2*(63488&T[0])+1*(63488&T[1]))/3&63488,T[3]=(2*(31&T[1])+1*(31&T[0]))/3|(2*(2016&T[1])+1*(2016&T[0]))/3&2016|(2*(63488&T[1])+1*(63488&T[0]))/3&63488;for(let M=0;M<4;M++){const s=C[S+4+M];let Q=(4*m+M)*x+4*f;z[Q++]=T[3&s],z[Q++]=T[s>>2&3],z[Q++]=T[s>>4&3],z[Q++]=T[s>>6&3]}}return z}(s,0,C.getImageWidth(M,x)+3&-4,C.getImageHeight(M,x)+3&-4)}return s}onmessage=y=>{if("init"===y.data.action){if(y.data.url)try{importScripts(y.data.url)}catch(U){postMessage({action:"error",error:U})}Q||(Q=BASIS({wasmBinary:y.data.wasmBinary})),null!==Q&&Q.then((C=>{BASIS=C,C.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===y.data.action){const Q=y.data.config,U=y.data.imageData,O=new BASIS.BasisFile(U),d=function(C){const M=C.getHasAlpha(),x=C.getNumImages(),f=[];for(let T=0;T<x;T++){const M={levels:[]},x=C.getNumLevels(T);for(let f=0;f<x;f++){const x={width:C.getImageWidth(T,f),height:C.getImageHeight(T,f)};M.levels.push(x)}f.push(M)}return{rd:M,images:f}}(O);let D=y.data.ignoreSupportedFormats?null:function(Q,V){let y=null;Q.supportedCompressionFormats&&(y=Q.supportedCompressionFormats.astc?S:Q.supportedCompressionFormats.bc7?T:Q.supportedCompressionFormats.s3tc?V.rd?f:x:Q.supportedCompressionFormats.pvrtc?V.rd?s:z:Q.supportedCompressionFormats.etc2?M:Q.supportedCompressionFormats.etc1?C:m);return y}(y.data.config,d),o=!1;null===D&&(o=!0,D=d.rd?f:x);let L=!0;O.startTranscoding()||(L=!1);const t=[];for(let C=0;C<d.images.length&&L;C++){const M=d.images[C];if(void 0===Q.loadSingleImage||Q.loadSingleImage===C){let x=M.levels.length;!1===Q.loadMipmapLevels&&(x=1);for(let f=0;f<x;f++){const x=M.levels[f],T=V(O,C,f,D,o);if(!T){L=!1;break}x.transcodedPixels=T,t.push(x.transcodedPixels.buffer)}}}O.close(),O.delete(),o&&(D=-1),L?postMessage({action:"transcode",success:L,id:y.data.id,fileInfo:d,format:D},t):postMessage({action:"transcode",success:L,id:y.data.id})}}}!function(C){C[C.cTFETC1=0]="cTFETC1",C[C.cTFETC2=1]="cTFETC2",C[C.cTFBC1=2]="cTFBC1",C[C.cTFBC3=3]="cTFBC3",C[C.cTFBC4=4]="cTFBC4",C[C.cTFBC5=5]="cTFBC5",C[C.cTFBC7=6]="cTFBC7",C[C.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",C[C.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",C[C.cTFASTC_4x4=10]="cTFASTC_4x4",C[C.cTFATC_RGB=11]="cTFATC_RGB",C[C.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",C[C.cTFRGBA32=13]="cTFRGBA32",C[C.cTFRGB565=14]="cTFRGB565",C[C.cTFBGR565=15]="cTFBGR565",C[C.cTFRGBA4444=16]="cTFRGBA4444",C[C.cTFFXT1_RGB=17]="cTFFXT1_RGB",C[C.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",C[C.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",C[C.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",C[C.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(f||(f={}));const m={JSModuleURL:`${T.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${T.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Q=null,V=null,y=0;const U=()=>(Q||(Q=new Promise(((C,M)=>{V?C(V):T.i.LoadFileAsync(T.i.GetBabylonScriptURL(m.WasmModuleURL)).then((x=>{if("function"!==typeof URL)return M("Basis transcoder requires an environment with a URL constructor");const f=URL.createObjectURL(new Blob([`(${S})()`],{type:"application/javascript"}));V=new Worker(f),function(C,M,x){return new Promise(((f,z)=>{const s=M=>{"init"===M.data.action?(C.removeEventListener("message",s),f(C)):"error"===M.data.action&&z(M.data.error||"error initializing worker")};C.addEventListener("message",s),C.postMessage({action:"init",url:x?T.i.GetBabylonScriptURL(x):void 0,wasmBinary:M},[M])}))}(V,x,m.JSModuleURL).then(C,M)})).catch(M)}))),Q),O=(C,M)=>{const x=C instanceof ArrayBuffer?new Uint8Array(C):C;return new Promise(((C,f)=>{U().then((()=>{const T=y++,z=M=>{"transcode"===M.data.action&&M.data.id===T&&(V.removeEventListener("message",z),M.data.success?C(M.data):f("Transcode is not supported on this device"))};V.addEventListener("message",z);const s=new Uint8Array(x.byteLength);s.set(new Uint8Array(x.buffer,x.byteOffset,x.byteLength)),V.postMessage({action:"transcode",id:T,imageData:s,config:M,ignoreSupportedFormats:false},[s.buffer])}),(C=>{f(C)}))}))},d=(C,M)=>{var x;let f=null===(x=M._gl)||void 0===x?void 0:x.TEXTURE_2D;var T;C.isCube&&(f=null===(T=M._gl)||void 0===T?void 0:T.TEXTURE_CUBE_MAP);M._bindTextureDirectly(f,C,!0)},D=(C,M)=>{const x=C.getEngine();for(let S=0;S<M.fileInfo.images.length;S++){const m=M.fileInfo.images[S].levels[0];if(C._invertVScale=C.invertY,-1===M.format||M.format===f.cTFRGB565)if(C.type=10,C.format=4,!x._features.basisNeedsPOT||Math.log2(m.width)%1===0&&Math.log2(m.height)%1===0)C._invertVScale=!C.invertY,C.width=m.width+3&-4,C.height=m.height+3&-4,C.samplingMode=2,d(C,x),x._uploadDataToTextureDirectly(C,new Uint16Array(m.transcodedPixels.buffer),S,0,4,!0);else{const M=new s.c(x,2);C._invertVScale=C.invertY,M.type=10,M.format=4,M.width=m.width+3&-4,M.height=m.height+3&-4,d(M,x),x._uploadDataToTextureDirectly(M,new Uint16Array(m.transcodedPixels.buffer),S,0,4,!0),x._rescaleTexture(M,C,x.scenes[0],x._getInternalFormat(4),(()=>{x._releaseTexture(M),d(C,x)}))}else{C.width=m.width,C.height=m.height,C.generateMipMaps=M.fileInfo.images[S].levels.length>1;const f=o.GetInternalFormatFromBasisFormat(M.format,x);C.format=f,d(C,x),M.fileInfo.images[S].levels.forEach(((M,T)=>{x._uploadCompressedDataToTextureDirectly(C,f,M.width,M.height,M.transcodedPixels,S,T)})),!x._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0||(T.i.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),C._cachedWrapU=z.b.CLAMP_ADDRESSMODE,C._cachedWrapV=z.b.CLAMP_ADDRESSMODE)}}},o={JSModuleURL:m.JSModuleURL,WasmModuleURL:m.WasmModuleURL,GetInternalFormatFromBasisFormat:(C,M)=>{let x;switch(C){case f.cTFETC1:x=36196;break;case f.cTFBC1:x=33776;break;case f.cTFBC4:x=33779;break;case f.cTFASTC_4x4:x=37808;break;case f.cTFETC2:x=37496;break;case f.cTFBC7:x=36492}if(void 0===x)throw"The chosen Basis transcoder format is not currently supported";return x},TranscodeAsync:O,LoadTextureFromTranscodeResult:D};Object.defineProperty(o,"JSModuleURL",{get:function(){return m.JSModuleURL},set:function(C){m.JSModuleURL=C}}),Object.defineProperty(o,"WasmModuleURL",{get:function(){return m.WasmModuleURL},set:function(C){m.WasmModuleURL=C}});class L{constructor(){this.supportCascades=!1}loadCubeData(C,M,x,f,z){if(Array.isArray(C))return;const s=M.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!s.etc1,s3tc:!!s.s3tc,pvrtc:!!s.pvrtc,etc2:!!s.etc2,astc:!!s.astc,bc7:!!s.bptc}};O(C,S).then((C=>{const x=C.fileInfo.images[0].levels.length>1&&M.generateMipMaps;D(M,C),M.getEngine()._setCubeMapTextureParams(M,x),M.isReady=!0,M.onLoadedObservable.notifyObservers(M),M.onLoadedObservable.clear(),f&&f()})).catch((C=>{T.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),M.isReady=!0,z&&z(C)}))}loadData(C,M,x){const f=M.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!f.etc1,s3tc:!!f.s3tc,pvrtc:!!f.pvrtc,etc2:!!f.etc2,astc:!!f.astc,bc7:!!f.bptc}};O(C,z).then((C=>{const f=C.fileInfo.images[0].levels[0],T=C.fileInfo.images[0].levels.length>1&&M.generateMipMaps;x(f.width,f.height,T,-1!==C.format,(()=>{D(M,C)}))})).catch((C=>{T.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),T.i.Warn(`Failed to transcode Basis file: ${C}`),x(0,0,!1,!1,(()=>{}),!0)}))}}}}]);