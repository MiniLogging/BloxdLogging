"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10208:(q,X,Q)=>{Q.r(X),Q.d(X,{_BasisTextureLoader:()=>e});var y,x=Q(1215),u=Q(972),H=Q(1143);function b(){const q=0,X=1,Q=2,y=3,x=6,u=8,H=9,b=10,D=14;let a=null;function R(q,X,Q,y,x){const u=q.getImageTranscodedSizeInBytes(X,Q,y);let H=new Uint8Array(u);if(!q.transcodeImage(H,X,Q,y,1,0))return null;if(x){H=function(q,X,Q,y){const x=new Uint16Array(4),u=new Uint16Array(Q*y),H=Q/4,b=y/4;for(let D=0;D<b;D++)for(let y=0;y<H;y++){const b=X+8*(D*H+y);x[0]=q[b]|q[b+1]<<8,x[1]=q[b+2]|q[b+3]<<8,x[2]=(2*(31&x[0])+1*(31&x[1]))/3|(2*(2016&x[0])+1*(2016&x[1]))/3&2016|(2*(63488&x[0])+1*(63488&x[1]))/3&63488,x[3]=(2*(31&x[1])+1*(31&x[0]))/3|(2*(2016&x[1])+1*(2016&x[0]))/3&2016|(2*(63488&x[1])+1*(63488&x[0]))/3&63488;for(let X=0;X<4;X++){const H=q[b+4+X];let a=(4*D+X)*Q+4*y;u[a++]=x[3&H],u[a++]=x[H>>2&3],u[a++]=x[H>>4&3],u[a++]=x[H>>6&3]}}return u}(H,0,q.getImageWidth(X,Q)+3&-4,q.getImageHeight(X,Q)+3&-4)}return H}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(f){postMessage({action:"error",error:f})}a||(a=BASIS({wasmBinary:L.data.wasmBinary})),null!==a&&a.then((q=>{BASIS=q,q.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const a=L.data.config,f=L.data.imageData,k=new BASIS.BasisFile(f),j=function(q){const X=q.getHasAlpha(),Q=q.getNumImages(),y=[];for(let x=0;x<Q;x++){const X={levels:[]},Q=q.getNumLevels(x);for(let y=0;y<Q;y++){const Q={width:q.getImageWidth(x,y),height:q.getImageHeight(x,y)};X.levels.push(Q)}y.push(X)}return{fc:X,images:y}}(k);let I=L.data.ignoreSupportedFormats?null:function(a,R){let L=null;a.supportedCompressionFormats&&(L=a.supportedCompressionFormats.astc?b:a.supportedCompressionFormats.bc7?x:a.supportedCompressionFormats.s3tc?R.fc?y:Q:a.supportedCompressionFormats.pvrtc?R.fc?H:u:a.supportedCompressionFormats.etc2?X:a.supportedCompressionFormats.etc1?q:D);return L}(L.data.config,j),d=!1;null===I&&(d=!0,I=j.fc?y:Q);let e=!0;k.startTranscoding()||(e=!1);const i=[];for(let q=0;q<j.images.length&&e;q++){const X=j.images[q];if(void 0===a.loadSingleImage||a.loadSingleImage===q){let Q=X.levels.length;!1===a.loadMipmapLevels&&(Q=1);for(let y=0;y<Q;y++){const Q=X.levels[y],x=R(k,q,y,I,d);if(!x){e=!1;break}Q.transcodedPixels=x,i.push(Q.transcodedPixels.buffer)}}}k.close(),k.delete(),d&&(I=-1),e?postMessage({action:"transcode",success:e,id:L.data.id,fileInfo:j,format:I},i):postMessage({action:"transcode",success:e,id:L.data.id})}}}!function(q){q[q.cTFETC1=0]="cTFETC1",q[q.cTFETC2=1]="cTFETC2",q[q.cTFBC1=2]="cTFBC1",q[q.cTFBC3=3]="cTFBC3",q[q.cTFBC4=4]="cTFBC4",q[q.cTFBC5=5]="cTFBC5",q[q.cTFBC7=6]="cTFBC7",q[q.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",q[q.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",q[q.cTFASTC_4x4=10]="cTFASTC_4x4",q[q.cTFATC_RGB=11]="cTFATC_RGB",q[q.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",q[q.cTFRGBA32=13]="cTFRGBA32",q[q.cTFRGB565=14]="cTFRGB565",q[q.cTFBGR565=15]="cTFBGR565",q[q.cTFRGBA4444=16]="cTFRGBA4444",q[q.cTFFXT1_RGB=17]="cTFFXT1_RGB",q[q.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",q[q.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",q[q.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",q[q.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(y||(y={}));const D={JSModuleURL:`${x.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${x.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let a=null,R=null,L=0;const f=()=>(a||(a=new Promise(((q,X)=>{R?q(R):x.f.LoadFileAsync(x.f.GetBabylonScriptURL(D.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return X("Basis transcoder requires an environment with a URL constructor");const y=URL.createObjectURL(new Blob([`(${b})()`],{type:"application/javascript"}));R=new Worker(y),function(q,X,Q){return new Promise(((y,u)=>{const H=X=>{"init"===X.data.action?(q.removeEventListener("message",H),y(q)):"error"===X.data.action&&u(X.data.error||"error initializing worker")};q.addEventListener("message",H),q.postMessage({action:"init",url:Q?x.f.GetBabylonScriptURL(Q):void 0,wasmBinary:X},[X])}))}(R,Q,D.JSModuleURL).then(q,X)})).catch(X)}))),a),k=(q,X)=>{const Q=q instanceof ArrayBuffer?new Uint8Array(q):q;return new Promise(((q,y)=>{f().then((()=>{const x=L++,u=X=>{"transcode"===X.data.action&&X.data.id===x&&(R.removeEventListener("message",u),X.data.success?q(X.data):y("Transcode is not supported on this device"))};R.addEventListener("message",u);const H=new Uint8Array(Q.byteLength);H.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),R.postMessage({action:"transcode",id:x,imageData:H,config:X,ignoreSupportedFormats:false},[H.buffer])}),(q=>{y(q)}))}))},j=(q,X)=>{var Q;let y=null===(Q=X._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var x;q.isCube&&(y=null===(x=X._gl)||void 0===x?void 0:x.TEXTURE_CUBE_MAP);X._bindTextureDirectly(y,q,!0)},I=(q,X)=>{const Q=q.getEngine();for(let b=0;b<X.fileInfo.images.length;b++){const D=X.fileInfo.images[b].levels[0];if(q._invertVScale=q.invertY,-1===X.format||X.format===y.cTFRGB565)if(q.type=10,q.format=4,!Q._features.basisNeedsPOT||Math.log2(D.width)%1===0&&Math.log2(D.height)%1===0)q._invertVScale=!q.invertY,q.width=D.width+3&-4,q.height=D.height+3&-4,q.samplingMode=2,j(q,Q),Q._uploadDataToTextureDirectly(q,new Uint16Array(D.transcodedPixels.buffer),b,0,4,!0);else{const X=new H.c(Q,2);q._invertVScale=q.invertY,X.type=10,X.format=4,X.width=D.width+3&-4,X.height=D.height+3&-4,j(X,Q),Q._uploadDataToTextureDirectly(X,new Uint16Array(D.transcodedPixels.buffer),b,0,4,!0),Q._rescaleTexture(X,q,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(X),j(q,Q)}))}else{q.width=D.width,q.height=D.height,q.generateMipMaps=X.fileInfo.images[b].levels.length>1;const y=d.GetInternalFormatFromBasisFormat(X.format,Q);q.format=y,j(q,Q),X.fileInfo.images[b].levels.forEach(((X,x)=>{Q._uploadCompressedDataToTextureDirectly(q,y,X.width,X.height,X.transcodedPixels,b,x)})),!Q._features.basisNeedsPOT||Math.log2(q.width)%1===0&&Math.log2(q.height)%1===0||(x.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),q._cachedWrapU=u.d.CLAMP_ADDRESSMODE,q._cachedWrapV=u.d.CLAMP_ADDRESSMODE)}}},d={JSModuleURL:D.JSModuleURL,WasmModuleURL:D.WasmModuleURL,GetInternalFormatFromBasisFormat:(q,X)=>{let Q;switch(q){case y.cTFETC1:Q=36196;break;case y.cTFBC1:Q=33776;break;case y.cTFBC4:Q=33779;break;case y.cTFASTC_4x4:Q=37808;break;case y.cTFETC2:Q=37496;break;case y.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:k,LoadTextureFromTranscodeResult:I};Object.defineProperty(d,"JSModuleURL",{get:function(){return D.JSModuleURL},set:function(q){D.JSModuleURL=q}}),Object.defineProperty(d,"WasmModuleURL",{get:function(){return D.WasmModuleURL},set:function(q){D.WasmModuleURL=q}});class e{constructor(){this.supportCascades=!1}loadCubeData(q,X,Q,y,u){if(Array.isArray(q))return;const H=X.getEngine().getCaps(),b={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};k(q,b).then((q=>{const Q=q.fileInfo.images[0].levels.length>1&&X.generateMipMaps;I(X,q),X.getEngine()._setCubeMapTextureParams(X,Q),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),y&&y()})).catch((q=>{x.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.isReady=!0,u&&u(q)}))}loadData(q,X,Q){const y=X.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!y.etc1,s3tc:!!y.s3tc,pvrtc:!!y.pvrtc,etc2:!!y.etc2,astc:!!y.astc,bc7:!!y.bptc}};k(q,u).then((q=>{const y=q.fileInfo.images[0].levels[0],x=q.fileInfo.images[0].levels.length>1&&X.generateMipMaps;Q(y.width,y.height,x,-1!==q.format,(()=>{I(X,q)}))})).catch((q=>{x.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.f.Warn(`Failed to transcode Basis file: ${q}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);