"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10034:(a,i,K)=>{K.r(i),K.d(i,{_BasisTextureLoader:()=>B});var j,N=K(1225),E=K(987),v=K(1154);function e(){const a=0,i=1,K=2,j=3,N=6,E=8,v=9,e=10,Y=14;let H=null;function f(a,i,K,j,N){const E=a.getImageTranscodedSizeInBytes(i,K,j);let v=new Uint8Array(E);if(!a.transcodeImage(v,i,K,j,1,0))return null;if(N){v=function(a,i,K,j){const N=new Uint16Array(4),E=new Uint16Array(K*j),v=K/4,e=j/4;for(let Y=0;Y<e;Y++)for(let j=0;j<v;j++){const e=i+8*(Y*v+j);N[0]=a[e]|a[e+1]<<8,N[1]=a[e+2]|a[e+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let i=0;i<4;i++){const v=a[e+4+i];let H=(4*Y+i)*K+4*j;E[H++]=N[3&v],E[H++]=N[v>>2&3],E[H++]=N[v>>4&3],E[H++]=N[v>>6&3]}}return E}(v,0,a.getImageWidth(i,K)+3&-4,a.getImageHeight(i,K)+3&-4)}return v}onmessage=o=>{if("init"===o.data.action){if(o.data.url)try{importScripts(o.data.url)}catch(U){postMessage({action:"error",error:U})}H||(H=BASIS({wasmBinary:o.data.wasmBinary})),null!==H&&H.then((a=>{BASIS=a,a.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===o.data.action){const H=o.data.config,U=o.data.imageData,q=new BASIS.BasisFile(U),u=function(a){const i=a.getHasAlpha(),K=a.getNumImages(),j=[];for(let N=0;N<K;N++){const i={levels:[]},K=a.getNumLevels(N);for(let j=0;j<K;j++){const K={width:a.getImageWidth(N,j),height:a.getImageHeight(N,j)};i.levels.push(K)}j.push(i)}return{Wc:i,images:j}}(q);let g=o.data.ignoreSupportedFormats?null:function(H,f){let o=null;H.supportedCompressionFormats&&(o=H.supportedCompressionFormats.astc?e:H.supportedCompressionFormats.bc7?N:H.supportedCompressionFormats.s3tc?f.Wc?j:K:H.supportedCompressionFormats.pvrtc?f.Wc?v:E:H.supportedCompressionFormats.etc2?i:H.supportedCompressionFormats.etc1?a:Y);return o}(o.data.config,u),s=!1;null===g&&(s=!0,g=u.Wc?j:K);let B=!0;q.startTranscoding()||(B=!1);const h=[];for(let a=0;a<u.images.length&&B;a++){const i=u.images[a];if(void 0===H.loadSingleImage||H.loadSingleImage===a){let K=i.levels.length;!1===H.loadMipmapLevels&&(K=1);for(let j=0;j<K;j++){const K=i.levels[j],N=f(q,a,j,g,s);if(!N){B=!1;break}K.transcodedPixels=N,h.push(K.transcodedPixels.buffer)}}}q.close(),q.delete(),s&&(g=-1),B?postMessage({action:"transcode",success:B,id:o.data.id,fileInfo:u,format:g},h):postMessage({action:"transcode",success:B,id:o.data.id})}}}!function(a){a[a.cTFETC1=0]="cTFETC1",a[a.cTFETC2=1]="cTFETC2",a[a.cTFBC1=2]="cTFBC1",a[a.cTFBC3=3]="cTFBC3",a[a.cTFBC4=4]="cTFBC4",a[a.cTFBC5=5]="cTFBC5",a[a.cTFBC7=6]="cTFBC7",a[a.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",a[a.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",a[a.cTFASTC_4x4=10]="cTFASTC_4x4",a[a.cTFATC_RGB=11]="cTFATC_RGB",a[a.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",a[a.cTFRGBA32=13]="cTFRGBA32",a[a.cTFRGB565=14]="cTFRGB565",a[a.cTFBGR565=15]="cTFBGR565",a[a.cTFRGBA4444=16]="cTFRGBA4444",a[a.cTFFXT1_RGB=17]="cTFFXT1_RGB",a[a.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",a[a.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",a[a.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",a[a.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(j||(j={}));const Y={JSModuleURL:`${N.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let H=null,f=null,o=0;const U=()=>(H||(H=new Promise(((a,i)=>{f?a(f):N.e.LoadFileAsync(N.e.GetBabylonScriptURL(Y.WasmModuleURL)).then((K=>{if("function"!==typeof URL)return i("Basis transcoder requires an environment with a URL constructor");const j=URL.createObjectURL(new Blob([`(${e})()`],{type:"application/javascript"}));f=new Worker(j),function(a,i,K){return new Promise(((j,E)=>{const v=i=>{"init"===i.data.action?(a.removeEventListener("message",v),j(a)):"error"===i.data.action&&E(i.data.error||"error initializing worker")};a.addEventListener("message",v),a.postMessage({action:"init",url:K?N.e.GetBabylonScriptURL(K):void 0,wasmBinary:i},[i])}))}(f,K,Y.JSModuleURL).then(a,i)})).catch(i)}))),H),q=(a,i)=>{const K=a instanceof ArrayBuffer?new Uint8Array(a):a;return new Promise(((a,j)=>{U().then((()=>{const N=o++,E=i=>{"transcode"===i.data.action&&i.data.id===N&&(f.removeEventListener("message",E),i.data.success?a(i.data):j("Transcode is not supported on this device"))};f.addEventListener("message",E);const v=new Uint8Array(K.byteLength);v.set(new Uint8Array(K.buffer,K.byteOffset,K.byteLength)),f.postMessage({action:"transcode",id:N,imageData:v,config:i,ignoreSupportedFormats:false},[v.buffer])}),(a=>{j(a)}))}))},u=(a,i)=>{var K;let j=null===(K=i._gl)||void 0===K?void 0:K.TEXTURE_2D;var N;a.isCube&&(j=null===(N=i._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);i._bindTextureDirectly(j,a,!0)},g=(a,i)=>{const K=a.getEngine();for(let e=0;e<i.fileInfo.images.length;e++){const Y=i.fileInfo.images[e].levels[0];if(a._invertVScale=a.invertY,-1===i.format||i.format===j.cTFRGB565)if(a.type=10,a.format=4,!K._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0)a._invertVScale=!a.invertY,a.width=Y.width+3&-4,a.height=Y.height+3&-4,a.samplingMode=2,u(a,K),K._uploadDataToTextureDirectly(a,new Uint16Array(Y.transcodedPixels.buffer),e,0,4,!0);else{const i=new v.d(K,2);a._invertVScale=a.invertY,i.type=10,i.format=4,i.width=Y.width+3&-4,i.height=Y.height+3&-4,u(i,K),K._uploadDataToTextureDirectly(i,new Uint16Array(Y.transcodedPixels.buffer),e,0,4,!0),K._rescaleTexture(i,a,K.scenes[0],K._getInternalFormat(4),(()=>{K._releaseTexture(i),u(a,K)}))}else{a.width=Y.width,a.height=Y.height,a.generateMipMaps=i.fileInfo.images[e].levels.length>1;const j=s.GetInternalFormatFromBasisFormat(i.format,K);a.format=j,u(a,K),i.fileInfo.images[e].levels.forEach(((i,N)=>{K._uploadCompressedDataToTextureDirectly(a,j,i.width,i.height,i.transcodedPixels,e,N)})),!K._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0||(N.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),a._cachedWrapU=E.b.CLAMP_ADDRESSMODE,a._cachedWrapV=E.b.CLAMP_ADDRESSMODE)}}},s={JSModuleURL:Y.JSModuleURL,WasmModuleURL:Y.WasmModuleURL,GetInternalFormatFromBasisFormat:(a,i)=>{let K;switch(a){case j.cTFETC1:K=36196;break;case j.cTFBC1:K=33776;break;case j.cTFBC4:K=33779;break;case j.cTFASTC_4x4:K=37808;break;case j.cTFETC2:K=37496;break;case j.cTFBC7:K=36492}if(void 0===K)throw"The chosen Basis transcoder format is not currently supported";return K},TranscodeAsync:q,LoadTextureFromTranscodeResult:g};Object.defineProperty(s,"JSModuleURL",{get:function(){return Y.JSModuleURL},set:function(a){Y.JSModuleURL=a}}),Object.defineProperty(s,"WasmModuleURL",{get:function(){return Y.WasmModuleURL},set:function(a){Y.WasmModuleURL=a}});class B{constructor(){this.supportCascades=!1}loadCubeData(a,i,K,j,E){if(Array.isArray(a))return;const v=i.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};q(a,e).then((a=>{const K=a.fileInfo.images[0].levels.length>1&&i.generateMipMaps;g(i,a),i.getEngine()._setCubeMapTextureParams(i,K),i.isReady=!0,i.onLoadedObservable.notifyObservers(i),i.onLoadedObservable.clear(),j&&j()})).catch((a=>{N.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.isReady=!0,E&&E(a)}))}loadData(a,i,K){const j=i.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!j.etc1,s3tc:!!j.s3tc,pvrtc:!!j.pvrtc,etc2:!!j.etc2,astc:!!j.astc,bc7:!!j.bptc}};q(a,E).then((a=>{const j=a.fileInfo.images[0].levels[0],N=a.fileInfo.images[0].levels.length>1&&i.generateMipMaps;K(j.width,j.height,N,-1!==a.format,(()=>{g(i,a)}))})).catch((a=>{N.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.e.Warn(`Failed to transcode Basis file: ${a}`),K(0,0,!1,!1,(()=>{}),!0)}))}}}}]);