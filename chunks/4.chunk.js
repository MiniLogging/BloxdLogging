"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10183:(b,G,i)=>{i.r(G),i.d(G,{_BasisTextureLoader:()=>u});var g,c=i(1224),V=i(980),z=i(1155);function E(){const b=0,G=1,i=2,g=3,c=6,V=8,z=9,E=10,Z=14;let Y=null;function J(b,G,i,g,c){const V=b.getImageTranscodedSizeInBytes(G,i,g);let z=new Uint8Array(V);if(!b.transcodeImage(z,G,i,g,1,0))return null;if(c){z=function(b,G,i,g){const c=new Uint16Array(4),V=new Uint16Array(i*g),z=i/4,E=g/4;for(let Z=0;Z<E;Z++)for(let g=0;g<z;g++){const E=G+8*(Z*z+g);c[0]=b[E]|b[E+1]<<8,c[1]=b[E+2]|b[E+3]<<8,c[2]=(2*(31&c[0])+1*(31&c[1]))/3|(2*(2016&c[0])+1*(2016&c[1]))/3&2016|(2*(63488&c[0])+1*(63488&c[1]))/3&63488,c[3]=(2*(31&c[1])+1*(31&c[0]))/3|(2*(2016&c[1])+1*(2016&c[0]))/3&2016|(2*(63488&c[1])+1*(63488&c[0]))/3&63488;for(let G=0;G<4;G++){const z=b[E+4+G];let Y=(4*Z+G)*i+4*g;V[Y++]=c[3&z],V[Y++]=c[z>>2&3],V[Y++]=c[z>>4&3],V[Y++]=c[z>>6&3]}}return V}(z,0,b.getImageWidth(G,i)+3&-4,b.getImageHeight(G,i)+3&-4)}return z}onmessage=q=>{if("init"===q.data.action){if(q.data.url)try{importScripts(q.data.url)}catch(o){postMessage({action:"error",error:o})}Y||(Y=BASIS({wasmBinary:q.data.wasmBinary})),null!==Y&&Y.then((b=>{BASIS=b,b.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===q.data.action){const Y=q.data.config,o=q.data.imageData,s=new BASIS.BasisFile(o),F=function(b){const G=b.getHasAlpha(),i=b.getNumImages(),g=[];for(let c=0;c<i;c++){const G={levels:[]},i=b.getNumLevels(c);for(let g=0;g<i;g++){const i={width:b.getImageWidth(c,g),height:b.getImageHeight(c,g)};G.levels.push(i)}g.push(G)}return{rc:G,images:g}}(s);let l=q.data.ignoreSupportedFormats?null:function(Y,J){let q=null;Y.supportedCompressionFormats&&(q=Y.supportedCompressionFormats.astc?E:Y.supportedCompressionFormats.bc7?c:Y.supportedCompressionFormats.s3tc?J.rc?g:i:Y.supportedCompressionFormats.pvrtc?J.rc?z:V:Y.supportedCompressionFormats.etc2?G:Y.supportedCompressionFormats.etc1?b:Z);return q}(q.data.config,F),v=!1;null===l&&(v=!0,l=F.rc?g:i);let u=!0;s.startTranscoding()||(u=!1);const W=[];for(let b=0;b<F.images.length&&u;b++){const G=F.images[b];if(void 0===Y.loadSingleImage||Y.loadSingleImage===b){let i=G.levels.length;!1===Y.loadMipmapLevels&&(i=1);for(let g=0;g<i;g++){const i=G.levels[g],c=J(s,b,g,l,v);if(!c){u=!1;break}i.transcodedPixels=c,W.push(i.transcodedPixels.buffer)}}}s.close(),s.delete(),v&&(l=-1),u?postMessage({action:"transcode",success:u,id:q.data.id,fileInfo:F,format:l},W):postMessage({action:"transcode",success:u,id:q.data.id})}}}!function(b){b[b.cTFETC1=0]="cTFETC1",b[b.cTFETC2=1]="cTFETC2",b[b.cTFBC1=2]="cTFBC1",b[b.cTFBC3=3]="cTFBC3",b[b.cTFBC4=4]="cTFBC4",b[b.cTFBC5=5]="cTFBC5",b[b.cTFBC7=6]="cTFBC7",b[b.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",b[b.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",b[b.cTFASTC_4x4=10]="cTFASTC_4x4",b[b.cTFATC_RGB=11]="cTFATC_RGB",b[b.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",b[b.cTFRGBA32=13]="cTFRGBA32",b[b.cTFRGB565=14]="cTFRGB565",b[b.cTFBGR565=15]="cTFBGR565",b[b.cTFRGBA4444=16]="cTFRGBA4444",b[b.cTFFXT1_RGB=17]="cTFFXT1_RGB",b[b.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",b[b.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",b[b.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",b[b.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(g||(g={}));const Z={JSModuleURL:`${c.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${c.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Y=null,J=null,q=0;const o=()=>(Y||(Y=new Promise(((b,G)=>{J?b(J):c.g.LoadFileAsync(c.g.GetBabylonScriptURL(Z.WasmModuleURL)).then((i=>{if("function"!==typeof URL)return G("Basis transcoder requires an environment with a URL constructor");const g=URL.createObjectURL(new Blob([`(${E})()`],{type:"application/javascript"}));J=new Worker(g),function(b,G,i){return new Promise(((g,V)=>{const z=G=>{"init"===G.data.action?(b.removeEventListener("message",z),g(b)):"error"===G.data.action&&V(G.data.error||"error initializing worker")};b.addEventListener("message",z),b.postMessage({action:"init",url:i?c.g.GetBabylonScriptURL(i):void 0,wasmBinary:G},[G])}))}(J,i,Z.JSModuleURL).then(b,G)})).catch(G)}))),Y),s=(b,G)=>{const i=b instanceof ArrayBuffer?new Uint8Array(b):b;return new Promise(((b,g)=>{o().then((()=>{const c=q++,V=G=>{"transcode"===G.data.action&&G.data.id===c&&(J.removeEventListener("message",V),G.data.success?b(G.data):g("Transcode is not supported on this device"))};J.addEventListener("message",V);const z=new Uint8Array(i.byteLength);z.set(new Uint8Array(i.buffer,i.byteOffset,i.byteLength)),J.postMessage({action:"transcode",id:c,imageData:z,config:G,ignoreSupportedFormats:false},[z.buffer])}),(b=>{g(b)}))}))},F=(b,G)=>{var i;let g=null===(i=G._gl)||void 0===i?void 0:i.TEXTURE_2D;var c;b.isCube&&(g=null===(c=G._gl)||void 0===c?void 0:c.TEXTURE_CUBE_MAP);G._bindTextureDirectly(g,b,!0)},l=(b,G)=>{const i=b.getEngine();for(let E=0;E<G.fileInfo.images.length;E++){const Z=G.fileInfo.images[E].levels[0];if(b._invertVScale=b.invertY,-1===G.format||G.format===g.cTFRGB565)if(b.type=10,b.format=4,!i._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0)b._invertVScale=!b.invertY,b.width=Z.width+3&-4,b.height=Z.height+3&-4,b.samplingMode=2,F(b,i),i._uploadDataToTextureDirectly(b,new Uint16Array(Z.transcodedPixels.buffer),E,0,4,!0);else{const G=new z.d(i,2);b._invertVScale=b.invertY,G.type=10,G.format=4,G.width=Z.width+3&-4,G.height=Z.height+3&-4,F(G,i),i._uploadDataToTextureDirectly(G,new Uint16Array(Z.transcodedPixels.buffer),E,0,4,!0),i._rescaleTexture(G,b,i.scenes[0],i._getInternalFormat(4),(()=>{i._releaseTexture(G),F(b,i)}))}else{b.width=Z.width,b.height=Z.height,b.generateMipMaps=G.fileInfo.images[E].levels.length>1;const g=v.GetInternalFormatFromBasisFormat(G.format,i);b.format=g,F(b,i),G.fileInfo.images[E].levels.forEach(((G,c)=>{i._uploadCompressedDataToTextureDirectly(b,g,G.width,G.height,G.transcodedPixels,E,c)})),!i._features.basisNeedsPOT||Math.log2(b.width)%1===0&&Math.log2(b.height)%1===0||(c.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),b._cachedWrapU=V.d.CLAMP_ADDRESSMODE,b._cachedWrapV=V.d.CLAMP_ADDRESSMODE)}}},v={JSModuleURL:Z.JSModuleURL,WasmModuleURL:Z.WasmModuleURL,GetInternalFormatFromBasisFormat:(b,G)=>{let i;switch(b){case g.cTFETC1:i=36196;break;case g.cTFBC1:i=33776;break;case g.cTFBC4:i=33779;break;case g.cTFASTC_4x4:i=37808;break;case g.cTFETC2:i=37496;break;case g.cTFBC7:i=36492}if(void 0===i)throw"The chosen Basis transcoder format is not currently supported";return i},TranscodeAsync:s,LoadTextureFromTranscodeResult:l};Object.defineProperty(v,"JSModuleURL",{get:function(){return Z.JSModuleURL},set:function(b){Z.JSModuleURL=b}}),Object.defineProperty(v,"WasmModuleURL",{get:function(){return Z.WasmModuleURL},set:function(b){Z.WasmModuleURL=b}});class u{constructor(){this.supportCascades=!1}loadCubeData(b,G,i,g,V){if(Array.isArray(b))return;const z=G.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};s(b,E).then((b=>{const i=b.fileInfo.images[0].levels.length>1&&G.generateMipMaps;l(G,b),G.getEngine()._setCubeMapTextureParams(G,i),G.isReady=!0,G.onLoadedObservable.notifyObservers(G),G.onLoadedObservable.clear(),g&&g()})).catch((b=>{c.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),G.isReady=!0,V&&V(b)}))}loadData(b,G,i){const g=G.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};s(b,V).then((b=>{const g=b.fileInfo.images[0].levels[0],c=b.fileInfo.images[0].levels.length>1&&G.generateMipMaps;i(g.width,g.height,c,-1!==b.format,(()=>{l(G,b)}))})).catch((b=>{c.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.g.Warn(`Failed to transcode Basis file: ${b}`),i(0,0,!1,!1,(()=>{}),!0)}))}}}}]);