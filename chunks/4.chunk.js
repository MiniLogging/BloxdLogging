"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10484:(M,E,b)=>{b.r(E),b.d(E,{_BasisTextureLoader:()=>c});var x,k=b(1176),a=b(942),g=b(1104);function n(){const M=0,E=1,b=2,x=3,k=6,a=8,g=9,n=10,J=14;let u=null;function T(M,E,b,x,k){const a=M.getImageTranscodedSizeInBytes(E,b,x);let g=new Uint8Array(a);if(!M.transcodeImage(g,E,b,x,1,0))return null;if(k){g=function(M,E,b,x){const k=new Uint16Array(4),a=new Uint16Array(b*x),g=b/4,n=x/4;for(let J=0;J<n;J++)for(let x=0;x<g;x++){const n=E+8*(J*g+x);k[0]=M[n]|M[n+1]<<8,k[1]=M[n+2]|M[n+3]<<8,k[2]=(2*(31&k[0])+1*(31&k[1]))/3|(2*(2016&k[0])+1*(2016&k[1]))/3&2016|(2*(63488&k[0])+1*(63488&k[1]))/3&63488,k[3]=(2*(31&k[1])+1*(31&k[0]))/3|(2*(2016&k[1])+1*(2016&k[0]))/3&2016|(2*(63488&k[1])+1*(63488&k[0]))/3&63488;for(let E=0;E<4;E++){const g=M[n+4+E];let u=(4*J+E)*b+4*x;a[u++]=k[3&g],a[u++]=k[g>>2&3],a[u++]=k[g>>4&3],a[u++]=k[g>>6&3]}}return a}(g,0,M.getImageWidth(E,b)+3&-4,M.getImageHeight(E,b)+3&-4)}return g}onmessage=V=>{if("init"===V.data.action){if(V.data.url)try{importScripts(V.data.url)}catch(I){postMessage({action:"error",error:I})}u||(u=BASIS({wasmBinary:V.data.wasmBinary})),null!==u&&u.then((M=>{BASIS=M,M.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===V.data.action){const u=V.data.config,I=V.data.imageData,t=new BASIS.BasisFile(I),y=function(M){const E=M.getHasAlpha(),b=M.getNumImages(),x=[];for(let k=0;k<b;k++){const E={levels:[]},b=M.getNumLevels(k);for(let x=0;x<b;x++){const b={width:M.getImageWidth(k,x),height:M.getImageHeight(k,x)};E.levels.push(b)}x.push(E)}return{bc:E,images:x}}(t);let B=V.data.ignoreSupportedFormats?null:function(u,T){let V=null;u.supportedCompressionFormats&&(V=u.supportedCompressionFormats.astc?n:u.supportedCompressionFormats.bc7?k:u.supportedCompressionFormats.s3tc?T.bc?x:b:u.supportedCompressionFormats.pvrtc?T.bc?g:a:u.supportedCompressionFormats.etc2?E:u.supportedCompressionFormats.etc1?M:J);return V}(V.data.config,y),r=!1;null===B&&(r=!0,B=y.bc?x:b);let c=!0;t.startTranscoding()||(c=!1);const C=[];for(let M=0;M<y.images.length&&c;M++){const E=y.images[M];if(void 0===u.loadSingleImage||u.loadSingleImage===M){let b=E.levels.length;!1===u.loadMipmapLevels&&(b=1);for(let x=0;x<b;x++){const b=E.levels[x],k=T(t,M,x,B,r);if(!k){c=!1;break}b.transcodedPixels=k,C.push(b.transcodedPixels.buffer)}}}t.close(),t.delete(),r&&(B=-1),c?postMessage({action:"transcode",success:c,id:V.data.id,fileInfo:y,format:B},C):postMessage({action:"transcode",success:c,id:V.data.id})}}}!function(M){M[M.cTFETC1=0]="cTFETC1",M[M.cTFETC2=1]="cTFETC2",M[M.cTFBC1=2]="cTFBC1",M[M.cTFBC3=3]="cTFBC3",M[M.cTFBC4=4]="cTFBC4",M[M.cTFBC5=5]="cTFBC5",M[M.cTFBC7=6]="cTFBC7",M[M.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",M[M.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",M[M.cTFASTC_4x4=10]="cTFASTC_4x4",M[M.cTFATC_RGB=11]="cTFATC_RGB",M[M.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",M[M.cTFRGBA32=13]="cTFRGBA32",M[M.cTFRGB565=14]="cTFRGB565",M[M.cTFBGR565=15]="cTFBGR565",M[M.cTFRGBA4444=16]="cTFRGBA4444",M[M.cTFFXT1_RGB=17]="cTFFXT1_RGB",M[M.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",M[M.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",M[M.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",M[M.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(x||(x={}));const J={JSModuleURL:`${k.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${k.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let u=null,T=null,V=0;const I=()=>(u||(u=new Promise(((M,E)=>{T?M(T):k.e.LoadFileAsync(k.e.GetBabylonScriptURL(J.WasmModuleURL)).then((b=>{if("function"!==typeof URL)return E("Basis transcoder requires an environment with a URL constructor");const x=URL.createObjectURL(new Blob([`(${n})()`],{type:"application/javascript"}));T=new Worker(x),function(M,E,b){return new Promise(((x,a)=>{const g=E=>{"init"===E.data.action?(M.removeEventListener("message",g),x(M)):"error"===E.data.action&&a(E.data.error||"error initializing worker")};M.addEventListener("message",g),M.postMessage({action:"init",url:b?k.e.GetBabylonScriptURL(b):void 0,wasmBinary:E},[E])}))}(T,b,J.JSModuleURL).then(M,E)})).catch(E)}))),u),t=(M,E)=>{const b=M instanceof ArrayBuffer?new Uint8Array(M):M;return new Promise(((M,x)=>{I().then((()=>{const k=V++,a=E=>{"transcode"===E.data.action&&E.data.id===k&&(T.removeEventListener("message",a),E.data.success?M(E.data):x("Transcode is not supported on this device"))};T.addEventListener("message",a);const g=new Uint8Array(b.byteLength);g.set(new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),T.postMessage({action:"transcode",id:k,imageData:g,config:E,ignoreSupportedFormats:false},[g.buffer])}),(M=>{x(M)}))}))},y=(M,E)=>{var b;let x=null===(b=E._gl)||void 0===b?void 0:b.TEXTURE_2D;var k;M.isCube&&(x=null===(k=E._gl)||void 0===k?void 0:k.TEXTURE_CUBE_MAP);E._bindTextureDirectly(x,M,!0)},B=(M,E)=>{const b=M.getEngine();for(let n=0;n<E.fileInfo.images.length;n++){const J=E.fileInfo.images[n].levels[0];if(M._invertVScale=M.invertY,-1===E.format||E.format===x.cTFRGB565)if(M.type=10,M.format=4,!b._features.basisNeedsPOT||Math.log2(J.width)%1===0&&Math.log2(J.height)%1===0)M._invertVScale=!M.invertY,M.width=J.width+3&-4,M.height=J.height+3&-4,M.samplingMode=2,y(M,b),b._uploadDataToTextureDirectly(M,new Uint16Array(J.transcodedPixels.buffer),n,0,4,!0);else{const E=new g.c(b,2);M._invertVScale=M.invertY,E.type=10,E.format=4,E.width=J.width+3&-4,E.height=J.height+3&-4,y(E,b),b._uploadDataToTextureDirectly(E,new Uint16Array(J.transcodedPixels.buffer),n,0,4,!0),b._rescaleTexture(E,M,b.scenes[0],b._getInternalFormat(4),(()=>{b._releaseTexture(E),y(M,b)}))}else{M.width=J.width,M.height=J.height,M.generateMipMaps=E.fileInfo.images[n].levels.length>1;const x=r.GetInternalFormatFromBasisFormat(E.format,b);M.format=x,y(M,b),E.fileInfo.images[n].levels.forEach(((E,k)=>{b._uploadCompressedDataToTextureDirectly(M,x,E.width,E.height,E.transcodedPixels,n,k)})),!b._features.basisNeedsPOT||Math.log2(M.width)%1===0&&Math.log2(M.height)%1===0||(k.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),M._cachedWrapU=a.e.CLAMP_ADDRESSMODE,M._cachedWrapV=a.e.CLAMP_ADDRESSMODE)}}},r={JSModuleURL:J.JSModuleURL,WasmModuleURL:J.WasmModuleURL,GetInternalFormatFromBasisFormat:(M,E)=>{let b;switch(M){case x.cTFETC1:b=36196;break;case x.cTFBC1:b=33776;break;case x.cTFBC4:b=33779;break;case x.cTFASTC_4x4:b=37808;break;case x.cTFETC2:b=37496;break;case x.cTFBC7:b=36492}if(void 0===b)throw"The chosen Basis transcoder format is not currently supported";return b},TranscodeAsync:t,LoadTextureFromTranscodeResult:B};Object.defineProperty(r,"JSModuleURL",{get:function(){return J.JSModuleURL},set:function(M){J.JSModuleURL=M}}),Object.defineProperty(r,"WasmModuleURL",{get:function(){return J.WasmModuleURL},set:function(M){J.WasmModuleURL=M}});class c{constructor(){this.supportCascades=!1}loadCubeData(M,E,b,x,a){if(Array.isArray(M))return;const g=E.getEngine().getCaps(),n={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};t(M,n).then((M=>{const b=M.fileInfo.images[0].levels.length>1&&E.generateMipMaps;B(E,M),E.getEngine()._setCubeMapTextureParams(E,b),E.isReady=!0,E.onLoadedObservable.notifyObservers(E),E.onLoadedObservable.clear(),x&&x()})).catch((M=>{k.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),E.isReady=!0,a&&a(M)}))}loadData(M,E,b){const x=E.getEngine().getCaps(),a={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};t(M,a).then((M=>{const x=M.fileInfo.images[0].levels[0],k=M.fileInfo.images[0].levels.length>1&&E.generateMipMaps;b(x.width,x.height,k,-1!==M.format,(()=>{B(E,M)}))})).catch((M=>{k.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.e.Warn(`Failed to transcode Basis file: ${M}`),b(0,0,!1,!1,(()=>{}),!0)}))}}}}]);