"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10306:(G,D,N)=>{N.r(D),N.d(D,{_BasisTextureLoader:()=>y});var T,o=N(1223),Z=N(978),n=N(1157);function C(){const G=0,D=1,N=2,T=3,o=6,Z=8,n=9,C=10,P=14;let r=null;function v(G,D,N,T,o){const Z=G.getImageTranscodedSizeInBytes(D,N,T);let n=new Uint8Array(Z);if(!G.transcodeImage(n,D,N,T,1,0))return null;if(o){n=function(G,D,N,T){const o=new Uint16Array(4),Z=new Uint16Array(N*T),n=N/4,C=T/4;for(let P=0;P<C;P++)for(let T=0;T<n;T++){const C=D+8*(P*n+T);o[0]=G[C]|G[C+1]<<8,o[1]=G[C+2]|G[C+3]<<8,o[2]=(2*(31&o[0])+1*(31&o[1]))/3|(2*(2016&o[0])+1*(2016&o[1]))/3&2016|(2*(63488&o[0])+1*(63488&o[1]))/3&63488,o[3]=(2*(31&o[1])+1*(31&o[0]))/3|(2*(2016&o[1])+1*(2016&o[0]))/3&2016|(2*(63488&o[1])+1*(63488&o[0]))/3&63488;for(let D=0;D<4;D++){const n=G[C+4+D];let r=(4*P+D)*N+4*T;Z[r++]=o[3&n],Z[r++]=o[n>>2&3],Z[r++]=o[n>>4&3],Z[r++]=o[n>>6&3]}}return Z}(n,0,G.getImageWidth(D,N)+3&-4,G.getImageHeight(D,N)+3&-4)}return n}onmessage=q=>{if("init"===q.data.action){if(q.data.url)try{importScripts(q.data.url)}catch(g){postMessage({action:"error",error:g})}r||(r=BASIS({wasmBinary:q.data.wasmBinary})),null!==r&&r.then((G=>{BASIS=G,G.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===q.data.action){const r=q.data.config,g=q.data.imageData,X=new BASIS.BasisFile(g),W=function(G){const D=G.getHasAlpha(),N=G.getNumImages(),T=[];for(let o=0;o<N;o++){const D={levels:[]},N=G.getNumLevels(o);for(let T=0;T<N;T++){const N={width:G.getImageWidth(o,T),height:G.getImageHeight(o,T)};D.levels.push(N)}T.push(D)}return{jd:D,images:T}}(X);let j=q.data.ignoreSupportedFormats?null:function(r,v){let q=null;r.supportedCompressionFormats&&(q=r.supportedCompressionFormats.astc?C:r.supportedCompressionFormats.bc7?o:r.supportedCompressionFormats.s3tc?v.jd?T:N:r.supportedCompressionFormats.pvrtc?v.jd?n:Z:r.supportedCompressionFormats.etc2?D:r.supportedCompressionFormats.etc1?G:P);return q}(q.data.config,W),Y=!1;null===j&&(Y=!0,j=W.jd?T:N);let y=!0;X.startTranscoding()||(y=!1);const h=[];for(let G=0;G<W.images.length&&y;G++){const D=W.images[G];if(void 0===r.loadSingleImage||r.loadSingleImage===G){let N=D.levels.length;!1===r.loadMipmapLevels&&(N=1);for(let T=0;T<N;T++){const N=D.levels[T],o=v(X,G,T,j,Y);if(!o){y=!1;break}N.transcodedPixels=o,h.push(N.transcodedPixels.buffer)}}}X.close(),X.delete(),Y&&(j=-1),y?postMessage({action:"transcode",success:y,id:q.data.id,fileInfo:W,format:j},h):postMessage({action:"transcode",success:y,id:q.data.id})}}}!function(G){G[G.cTFETC1=0]="cTFETC1",G[G.cTFETC2=1]="cTFETC2",G[G.cTFBC1=2]="cTFBC1",G[G.cTFBC3=3]="cTFBC3",G[G.cTFBC4=4]="cTFBC4",G[G.cTFBC5=5]="cTFBC5",G[G.cTFBC7=6]="cTFBC7",G[G.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",G[G.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",G[G.cTFASTC_4x4=10]="cTFASTC_4x4",G[G.cTFATC_RGB=11]="cTFATC_RGB",G[G.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",G[G.cTFRGBA32=13]="cTFRGBA32",G[G.cTFRGB565=14]="cTFRGB565",G[G.cTFBGR565=15]="cTFBGR565",G[G.cTFRGBA4444=16]="cTFRGBA4444",G[G.cTFFXT1_RGB=17]="cTFFXT1_RGB",G[G.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",G[G.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",G[G.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",G[G.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(T||(T={}));const P={JSModuleURL:`${o.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${o.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let r=null,v=null,q=0;const g=()=>(r||(r=new Promise(((G,D)=>{v?G(v):o.f.LoadFileAsync(o.f.GetBabylonScriptURL(P.WasmModuleURL)).then((N=>{if("function"!==typeof URL)return D("Basis transcoder requires an environment with a URL constructor");const T=URL.createObjectURL(new Blob([`(${C})()`],{type:"application/javascript"}));v=new Worker(T),function(G,D,N){return new Promise(((T,Z)=>{const n=D=>{"init"===D.data.action?(G.removeEventListener("message",n),T(G)):"error"===D.data.action&&Z(D.data.error||"error initializing worker")};G.addEventListener("message",n),G.postMessage({action:"init",url:N?o.f.GetBabylonScriptURL(N):void 0,wasmBinary:D},[D])}))}(v,N,P.JSModuleURL).then(G,D)})).catch(D)}))),r),X=(G,D)=>{const N=G instanceof ArrayBuffer?new Uint8Array(G):G;return new Promise(((G,T)=>{g().then((()=>{const o=q++,Z=D=>{"transcode"===D.data.action&&D.data.id===o&&(v.removeEventListener("message",Z),D.data.success?G(D.data):T("Transcode is not supported on this device"))};v.addEventListener("message",Z);const n=new Uint8Array(N.byteLength);n.set(new Uint8Array(N.buffer,N.byteOffset,N.byteLength)),v.postMessage({action:"transcode",id:o,imageData:n,config:D,ignoreSupportedFormats:false},[n.buffer])}),(G=>{T(G)}))}))},W=(G,D)=>{var N;let T=null===(N=D._gl)||void 0===N?void 0:N.TEXTURE_2D;var o;G.isCube&&(T=null===(o=D._gl)||void 0===o?void 0:o.TEXTURE_CUBE_MAP);D._bindTextureDirectly(T,G,!0)},j=(G,D)=>{const N=G.getEngine();for(let C=0;C<D.fileInfo.images.length;C++){const P=D.fileInfo.images[C].levels[0];if(G._invertVScale=G.invertY,-1===D.format||D.format===T.cTFRGB565)if(G.type=10,G.format=4,!N._features.basisNeedsPOT||Math.log2(P.width)%1===0&&Math.log2(P.height)%1===0)G._invertVScale=!G.invertY,G.width=P.width+3&-4,G.height=P.height+3&-4,G.samplingMode=2,W(G,N),N._uploadDataToTextureDirectly(G,new Uint16Array(P.transcodedPixels.buffer),C,0,4,!0);else{const D=new n.d(N,2);G._invertVScale=G.invertY,D.type=10,D.format=4,D.width=P.width+3&-4,D.height=P.height+3&-4,W(D,N),N._uploadDataToTextureDirectly(D,new Uint16Array(P.transcodedPixels.buffer),C,0,4,!0),N._rescaleTexture(D,G,N.scenes[0],N._getInternalFormat(4),(()=>{N._releaseTexture(D),W(G,N)}))}else{G.width=P.width,G.height=P.height,G.generateMipMaps=D.fileInfo.images[C].levels.length>1;const T=Y.GetInternalFormatFromBasisFormat(D.format,N);G.format=T,W(G,N),D.fileInfo.images[C].levels.forEach(((D,o)=>{N._uploadCompressedDataToTextureDirectly(G,T,D.width,D.height,D.transcodedPixels,C,o)})),!N._features.basisNeedsPOT||Math.log2(G.width)%1===0&&Math.log2(G.height)%1===0||(o.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),G._cachedWrapU=Z.e.CLAMP_ADDRESSMODE,G._cachedWrapV=Z.e.CLAMP_ADDRESSMODE)}}},Y={JSModuleURL:P.JSModuleURL,WasmModuleURL:P.WasmModuleURL,GetInternalFormatFromBasisFormat:(G,D)=>{let N;switch(G){case T.cTFETC1:N=36196;break;case T.cTFBC1:N=33776;break;case T.cTFBC4:N=33779;break;case T.cTFASTC_4x4:N=37808;break;case T.cTFETC2:N=37496;break;case T.cTFBC7:N=36492}if(void 0===N)throw"The chosen Basis transcoder format is not currently supported";return N},TranscodeAsync:X,LoadTextureFromTranscodeResult:j};Object.defineProperty(Y,"JSModuleURL",{get:function(){return P.JSModuleURL},set:function(G){P.JSModuleURL=G}}),Object.defineProperty(Y,"WasmModuleURL",{get:function(){return P.WasmModuleURL},set:function(G){P.WasmModuleURL=G}});class y{constructor(){this.supportCascades=!1}loadCubeData(G,D,N,T,Z){if(Array.isArray(G))return;const n=D.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!n.etc1,s3tc:!!n.s3tc,pvrtc:!!n.pvrtc,etc2:!!n.etc2,astc:!!n.astc,bc7:!!n.bptc}};X(G,C).then((G=>{const N=G.fileInfo.images[0].levels.length>1&&D.generateMipMaps;j(D,G),D.getEngine()._setCubeMapTextureParams(D,N),D.isReady=!0,D.onLoadedObservable.notifyObservers(D),D.onLoadedObservable.clear(),T&&T()})).catch((G=>{o.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),D.isReady=!0,Z&&Z(G)}))}loadData(G,D,N){const T=D.getEngine().getCaps(),Z={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};X(G,Z).then((G=>{const T=G.fileInfo.images[0].levels[0],o=G.fileInfo.images[0].levels.length>1&&D.generateMipMaps;N(T.width,T.height,o,-1!==G.format,(()=>{j(D,G)}))})).catch((G=>{o.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),o.f.Warn(`Failed to transcode Basis file: ${G}`),N(0,0,!1,!1,(()=>{}),!0)}))}}}}]);