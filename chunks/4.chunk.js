"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10259:(L,J,o)=>{o.r(J),o.d(J,{_BasisTextureLoader:()=>O});var g,V=o(1193),q=o(954),I=o(1122);function b(){const L=0,J=1,o=2,g=3,V=6,q=8,I=9,b=10,D=14;let Z=null;function C(L,J,o,g,V){const q=L.getImageTranscodedSizeInBytes(J,o,g);let I=new Uint8Array(q);if(!L.transcodeImage(I,J,o,g,1,0))return null;if(V){I=function(L,J,o,g){const V=new Uint16Array(4),q=new Uint16Array(o*g),I=o/4,b=g/4;for(let D=0;D<b;D++)for(let g=0;g<I;g++){const b=J+8*(D*I+g);V[0]=L[b]|L[b+1]<<8,V[1]=L[b+2]|L[b+3]<<8,V[2]=(2*(31&V[0])+1*(31&V[1]))/3|(2*(2016&V[0])+1*(2016&V[1]))/3&2016|(2*(63488&V[0])+1*(63488&V[1]))/3&63488,V[3]=(2*(31&V[1])+1*(31&V[0]))/3|(2*(2016&V[1])+1*(2016&V[0]))/3&2016|(2*(63488&V[1])+1*(63488&V[0]))/3&63488;for(let J=0;J<4;J++){const I=L[b+4+J];let Z=(4*D+J)*o+4*g;q[Z++]=V[3&I],q[Z++]=V[I>>2&3],q[Z++]=V[I>>4&3],q[Z++]=V[I>>6&3]}}return q}(I,0,L.getImageWidth(J,o)+3&-4,L.getImageHeight(J,o)+3&-4)}return I}onmessage=v=>{if("init"===v.data.action){if(v.data.url)try{importScripts(v.data.url)}catch(U){postMessage({action:"error",error:U})}Z||(Z=BASIS({wasmBinary:v.data.wasmBinary})),null!==Z&&Z.then((L=>{BASIS=L,L.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===v.data.action){const Z=v.data.config,U=v.data.imageData,k=new BASIS.BasisFile(U),H=function(L){const J=L.getHasAlpha(),o=L.getNumImages(),g=[];for(let V=0;V<o;V++){const J={levels:[]},o=L.getNumLevels(V);for(let g=0;g<o;g++){const o={width:L.getImageWidth(V,g),height:L.getImageHeight(V,g)};J.levels.push(o)}g.push(J)}return{$b:J,images:g}}(k);let e=v.data.ignoreSupportedFormats?null:function(Z,C){let v=null;Z.supportedCompressionFormats&&(v=Z.supportedCompressionFormats.astc?b:Z.supportedCompressionFormats.bc7?V:Z.supportedCompressionFormats.s3tc?C.$b?g:o:Z.supportedCompressionFormats.pvrtc?C.$b?I:q:Z.supportedCompressionFormats.etc2?J:Z.supportedCompressionFormats.etc1?L:D);return v}(v.data.config,H),T=!1;null===e&&(T=!0,e=H.$b?g:o);let O=!0;k.startTranscoding()||(O=!1);const l=[];for(let L=0;L<H.images.length&&O;L++){const J=H.images[L];if(void 0===Z.loadSingleImage||Z.loadSingleImage===L){let o=J.levels.length;!1===Z.loadMipmapLevels&&(o=1);for(let g=0;g<o;g++){const o=J.levels[g],V=C(k,L,g,e,T);if(!V){O=!1;break}o.transcodedPixels=V,l.push(o.transcodedPixels.buffer)}}}k.close(),k.delete(),T&&(e=-1),O?postMessage({action:"transcode",success:O,id:v.data.id,fileInfo:H,format:e},l):postMessage({action:"transcode",success:O,id:v.data.id})}}}!function(L){L[L.cTFETC1=0]="cTFETC1",L[L.cTFETC2=1]="cTFETC2",L[L.cTFBC1=2]="cTFBC1",L[L.cTFBC3=3]="cTFBC3",L[L.cTFBC4=4]="cTFBC4",L[L.cTFBC5=5]="cTFBC5",L[L.cTFBC7=6]="cTFBC7",L[L.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",L[L.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",L[L.cTFASTC_4x4=10]="cTFASTC_4x4",L[L.cTFATC_RGB=11]="cTFATC_RGB",L[L.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",L[L.cTFRGBA32=13]="cTFRGBA32",L[L.cTFRGB565=14]="cTFRGB565",L[L.cTFBGR565=15]="cTFBGR565",L[L.cTFRGBA4444=16]="cTFRGBA4444",L[L.cTFFXT1_RGB=17]="cTFFXT1_RGB",L[L.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",L[L.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",L[L.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",L[L.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(g||(g={}));const D={JSModuleURL:`${V.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${V.c._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Z=null,C=null,v=0;const U=()=>(Z||(Z=new Promise(((L,J)=>{C?L(C):V.c.LoadFileAsync(V.c.GetBabylonScriptURL(D.WasmModuleURL)).then((o=>{if("function"!==typeof URL)return J("Basis transcoder requires an environment with a URL constructor");const g=URL.createObjectURL(new Blob([`(${b})()`],{type:"application/javascript"}));C=new Worker(g),function(L,J,o){return new Promise(((g,q)=>{const I=J=>{"init"===J.data.action?(L.removeEventListener("message",I),g(L)):"error"===J.data.action&&q(J.data.error||"error initializing worker")};L.addEventListener("message",I),L.postMessage({action:"init",url:o?V.c.GetBabylonScriptURL(o):void 0,wasmBinary:J},[J])}))}(C,o,D.JSModuleURL).then(L,J)})).catch(J)}))),Z),k=(L,J)=>{const o=L instanceof ArrayBuffer?new Uint8Array(L):L;return new Promise(((L,g)=>{U().then((()=>{const V=v++,q=J=>{"transcode"===J.data.action&&J.data.id===V&&(C.removeEventListener("message",q),J.data.success?L(J.data):g("Transcode is not supported on this device"))};C.addEventListener("message",q);const I=new Uint8Array(o.byteLength);I.set(new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),C.postMessage({action:"transcode",id:V,imageData:I,config:J,ignoreSupportedFormats:false},[I.buffer])}),(L=>{g(L)}))}))},H=(L,J)=>{var o;let g=null===(o=J._gl)||void 0===o?void 0:o.TEXTURE_2D;var V;L.isCube&&(g=null===(V=J._gl)||void 0===V?void 0:V.TEXTURE_CUBE_MAP);J._bindTextureDirectly(g,L,!0)},e=(L,J)=>{const o=L.getEngine();for(let b=0;b<J.fileInfo.images.length;b++){const D=J.fileInfo.images[b].levels[0];if(L._invertVScale=L.invertY,-1===J.format||J.format===g.cTFRGB565)if(L.type=10,L.format=4,!o._features.basisNeedsPOT||Math.log2(D.width)%1===0&&Math.log2(D.height)%1===0)L._invertVScale=!L.invertY,L.width=D.width+3&-4,L.height=D.height+3&-4,L.samplingMode=2,H(L,o),o._uploadDataToTextureDirectly(L,new Uint16Array(D.transcodedPixels.buffer),b,0,4,!0);else{const J=new I.e(o,2);L._invertVScale=L.invertY,J.type=10,J.format=4,J.width=D.width+3&-4,J.height=D.height+3&-4,H(J,o),o._uploadDataToTextureDirectly(J,new Uint16Array(D.transcodedPixels.buffer),b,0,4,!0),o._rescaleTexture(J,L,o.scenes[0],o._getInternalFormat(4),(()=>{o._releaseTexture(J),H(L,o)}))}else{L.width=D.width,L.height=D.height,L.generateMipMaps=J.fileInfo.images[b].levels.length>1;const g=T.GetInternalFormatFromBasisFormat(J.format,o);L.format=g,H(L,o),J.fileInfo.images[b].levels.forEach(((J,V)=>{o._uploadCompressedDataToTextureDirectly(L,g,J.width,J.height,J.transcodedPixels,b,V)})),!o._features.basisNeedsPOT||Math.log2(L.width)%1===0&&Math.log2(L.height)%1===0||(V.c.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),L._cachedWrapU=q.d.CLAMP_ADDRESSMODE,L._cachedWrapV=q.d.CLAMP_ADDRESSMODE)}}},T={JSModuleURL:D.JSModuleURL,WasmModuleURL:D.WasmModuleURL,GetInternalFormatFromBasisFormat:(L,J)=>{let o;switch(L){case g.cTFETC1:o=36196;break;case g.cTFBC1:o=33776;break;case g.cTFBC4:o=33779;break;case g.cTFASTC_4x4:o=37808;break;case g.cTFETC2:o=37496;break;case g.cTFBC7:o=36492}if(void 0===o)throw"The chosen Basis transcoder format is not currently supported";return o},TranscodeAsync:k,LoadTextureFromTranscodeResult:e};Object.defineProperty(T,"JSModuleURL",{get:function(){return D.JSModuleURL},set:function(L){D.JSModuleURL=L}}),Object.defineProperty(T,"WasmModuleURL",{get:function(){return D.WasmModuleURL},set:function(L){D.WasmModuleURL=L}});class O{constructor(){this.supportCascades=!1}loadCubeData(L,J,o,g,q){if(Array.isArray(L))return;const I=J.getEngine().getCaps(),b={supportedCompressionFormats:{etc1:!!I.etc1,s3tc:!!I.s3tc,pvrtc:!!I.pvrtc,etc2:!!I.etc2,astc:!!I.astc,bc7:!!I.bptc}};k(L,b).then((L=>{const o=L.fileInfo.images[0].levels.length>1&&J.generateMipMaps;e(J,L),J.getEngine()._setCubeMapTextureParams(J,o),J.isReady=!0,J.onLoadedObservable.notifyObservers(J),J.onLoadedObservable.clear(),g&&g()})).catch((L=>{V.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),J.isReady=!0,q&&q(L)}))}loadData(L,J,o){const g=J.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};k(L,q).then((L=>{const g=L.fileInfo.images[0].levels[0],V=L.fileInfo.images[0].levels.length>1&&J.generateMipMaps;o(g.width,g.height,V,-1!==L.format,(()=>{e(J,L)}))})).catch((L=>{V.c.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),V.c.Warn(`Failed to transcode Basis file: ${L}`),o(0,0,!1,!1,(()=>{}),!0)}))}}}}]);