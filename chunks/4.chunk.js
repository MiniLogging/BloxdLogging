"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10333:(R,N,q)=>{q.r(N),q.d(N,{_BasisTextureLoader:()=>C});var w,u=q(1177),M=q(933),v=q(1104);function G(){const R=0,N=1,q=2,w=3,u=6,M=8,v=9,G=10,J=14;let y=null;function a(R,N,q,w,u){const M=R.getImageTranscodedSizeInBytes(N,q,w);let v=new Uint8Array(M);if(!R.transcodeImage(v,N,q,w,1,0))return null;if(u){v=function(R,N,q,w){const u=new Uint16Array(4),M=new Uint16Array(q*w),v=q/4,G=w/4;for(let J=0;J<G;J++)for(let w=0;w<v;w++){const G=N+8*(J*v+w);u[0]=R[G]|R[G+1]<<8,u[1]=R[G+2]|R[G+3]<<8,u[2]=(2*(31&u[0])+1*(31&u[1]))/3|(2*(2016&u[0])+1*(2016&u[1]))/3&2016|(2*(63488&u[0])+1*(63488&u[1]))/3&63488,u[3]=(2*(31&u[1])+1*(31&u[0]))/3|(2*(2016&u[1])+1*(2016&u[0]))/3&2016|(2*(63488&u[1])+1*(63488&u[0]))/3&63488;for(let N=0;N<4;N++){const v=R[G+4+N];let y=(4*J+N)*q+4*w;M[y++]=u[3&v],M[y++]=u[v>>2&3],M[y++]=u[v>>4&3],M[y++]=u[v>>6&3]}}return M}(v,0,R.getImageWidth(N,q)+3&-4,R.getImageHeight(N,q)+3&-4)}return v}onmessage=j=>{if("init"===j.data.action){if(j.data.url)try{importScripts(j.data.url)}catch(F){postMessage({action:"error",error:F})}y||(y=BASIS({wasmBinary:j.data.wasmBinary})),null!==y&&y.then((R=>{BASIS=R,R.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===j.data.action){const y=j.data.config,F=j.data.imageData,S=new BASIS.BasisFile(F),H=function(R){const N=R.getHasAlpha(),q=R.getNumImages(),w=[];for(let u=0;u<q;u++){const N={levels:[]},q=R.getNumLevels(u);for(let w=0;w<q;w++){const q={width:R.getImageWidth(u,w),height:R.getImageHeight(u,w)};N.levels.push(q)}w.push(N)}return{ac:N,images:w}}(S);let W=j.data.ignoreSupportedFormats?null:function(y,a){let j=null;y.supportedCompressionFormats&&(j=y.supportedCompressionFormats.astc?G:y.supportedCompressionFormats.bc7?u:y.supportedCompressionFormats.s3tc?a.ac?w:q:y.supportedCompressionFormats.pvrtc?a.ac?v:M:y.supportedCompressionFormats.etc2?N:y.supportedCompressionFormats.etc1?R:J);return j}(j.data.config,H),k=!1;null===W&&(k=!0,W=H.ac?w:q);let C=!0;S.startTranscoding()||(C=!1);const e=[];for(let R=0;R<H.images.length&&C;R++){const N=H.images[R];if(void 0===y.loadSingleImage||y.loadSingleImage===R){let q=N.levels.length;!1===y.loadMipmapLevels&&(q=1);for(let w=0;w<q;w++){const q=N.levels[w],u=a(S,R,w,W,k);if(!u){C=!1;break}q.transcodedPixels=u,e.push(q.transcodedPixels.buffer)}}}S.close(),S.delete(),k&&(W=-1),C?postMessage({action:"transcode",success:C,id:j.data.id,fileInfo:H,format:W},e):postMessage({action:"transcode",success:C,id:j.data.id})}}}!function(R){R[R.cTFETC1=0]="cTFETC1",R[R.cTFETC2=1]="cTFETC2",R[R.cTFBC1=2]="cTFBC1",R[R.cTFBC3=3]="cTFBC3",R[R.cTFBC4=4]="cTFBC4",R[R.cTFBC5=5]="cTFBC5",R[R.cTFBC7=6]="cTFBC7",R[R.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",R[R.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",R[R.cTFASTC_4x4=10]="cTFASTC_4x4",R[R.cTFATC_RGB=11]="cTFATC_RGB",R[R.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",R[R.cTFRGBA32=13]="cTFRGBA32",R[R.cTFRGB565=14]="cTFRGB565",R[R.cTFBGR565=15]="cTFBGR565",R[R.cTFRGBA4444=16]="cTFRGBA4444",R[R.cTFFXT1_RGB=17]="cTFFXT1_RGB",R[R.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",R[R.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",R[R.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",R[R.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(w||(w={}));const J={JSModuleURL:`${u.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${u.i._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let y=null,a=null,j=0;const F=()=>(y||(y=new Promise(((R,N)=>{a?R(a):u.i.LoadFileAsync(u.i.GetBabylonScriptURL(J.WasmModuleURL)).then((q=>{if("function"!==typeof URL)return N("Basis transcoder requires an environment with a URL constructor");const w=URL.createObjectURL(new Blob([`(${G})()`],{type:"application/javascript"}));a=new Worker(w),function(R,N,q){return new Promise(((w,M)=>{const v=N=>{"init"===N.data.action?(R.removeEventListener("message",v),w(R)):"error"===N.data.action&&M(N.data.error||"error initializing worker")};R.addEventListener("message",v),R.postMessage({action:"init",url:q?u.i.GetBabylonScriptURL(q):void 0,wasmBinary:N},[N])}))}(a,q,J.JSModuleURL).then(R,N)})).catch(N)}))),y),S=(R,N)=>{const q=R instanceof ArrayBuffer?new Uint8Array(R):R;return new Promise(((R,w)=>{F().then((()=>{const u=j++,M=N=>{"transcode"===N.data.action&&N.data.id===u&&(a.removeEventListener("message",M),N.data.success?R(N.data):w("Transcode is not supported on this device"))};a.addEventListener("message",M);const v=new Uint8Array(q.byteLength);v.set(new Uint8Array(q.buffer,q.byteOffset,q.byteLength)),a.postMessage({action:"transcode",id:u,imageData:v,config:N,ignoreSupportedFormats:false},[v.buffer])}),(R=>{w(R)}))}))},H=(R,N)=>{var q;let w=null===(q=N._gl)||void 0===q?void 0:q.TEXTURE_2D;var u;R.isCube&&(w=null===(u=N._gl)||void 0===u?void 0:u.TEXTURE_CUBE_MAP);N._bindTextureDirectly(w,R,!0)},W=(R,N)=>{const q=R.getEngine();for(let G=0;G<N.fileInfo.images.length;G++){const J=N.fileInfo.images[G].levels[0];if(R._invertVScale=R.invertY,-1===N.format||N.format===w.cTFRGB565)if(R.type=10,R.format=4,!q._features.basisNeedsPOT||Math.log2(J.width)%1===0&&Math.log2(J.height)%1===0)R._invertVScale=!R.invertY,R.width=J.width+3&-4,R.height=J.height+3&-4,R.samplingMode=2,H(R,q),q._uploadDataToTextureDirectly(R,new Uint16Array(J.transcodedPixels.buffer),G,0,4,!0);else{const N=new v.d(q,2);R._invertVScale=R.invertY,N.type=10,N.format=4,N.width=J.width+3&-4,N.height=J.height+3&-4,H(N,q),q._uploadDataToTextureDirectly(N,new Uint16Array(J.transcodedPixels.buffer),G,0,4,!0),q._rescaleTexture(N,R,q.scenes[0],q._getInternalFormat(4),(()=>{q._releaseTexture(N),H(R,q)}))}else{R.width=J.width,R.height=J.height,R.generateMipMaps=N.fileInfo.images[G].levels.length>1;const w=k.GetInternalFormatFromBasisFormat(N.format,q);R.format=w,H(R,q),N.fileInfo.images[G].levels.forEach(((N,u)=>{q._uploadCompressedDataToTextureDirectly(R,w,N.width,N.height,N.transcodedPixels,G,u)})),!q._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0||(u.i.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),R._cachedWrapU=M.e.CLAMP_ADDRESSMODE,R._cachedWrapV=M.e.CLAMP_ADDRESSMODE)}}},k={JSModuleURL:J.JSModuleURL,WasmModuleURL:J.WasmModuleURL,GetInternalFormatFromBasisFormat:(R,N)=>{let q;switch(R){case w.cTFETC1:q=36196;break;case w.cTFBC1:q=33776;break;case w.cTFBC4:q=33779;break;case w.cTFASTC_4x4:q=37808;break;case w.cTFETC2:q=37496;break;case w.cTFBC7:q=36492}if(void 0===q)throw"The chosen Basis transcoder format is not currently supported";return q},TranscodeAsync:S,LoadTextureFromTranscodeResult:W};Object.defineProperty(k,"JSModuleURL",{get:function(){return J.JSModuleURL},set:function(R){J.JSModuleURL=R}}),Object.defineProperty(k,"WasmModuleURL",{get:function(){return J.WasmModuleURL},set:function(R){J.WasmModuleURL=R}});class C{constructor(){this.supportCascades=!1}loadCubeData(R,N,q,w,M){if(Array.isArray(R))return;const v=N.getEngine().getCaps(),G={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};S(R,G).then((R=>{const q=R.fileInfo.images[0].levels.length>1&&N.generateMipMaps;W(N,R),N.getEngine()._setCubeMapTextureParams(N,q),N.isReady=!0,N.onLoadedObservable.notifyObservers(N),N.onLoadedObservable.clear(),w&&w()})).catch((R=>{u.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.isReady=!0,M&&M(R)}))}loadData(R,N,q){const w=N.getEngine().getCaps(),M={supportedCompressionFormats:{etc1:!!w.etc1,s3tc:!!w.s3tc,pvrtc:!!w.pvrtc,etc2:!!w.etc2,astc:!!w.astc,bc7:!!w.bptc}};S(R,M).then((R=>{const w=R.fileInfo.images[0].levels[0],u=R.fileInfo.images[0].levels.length>1&&N.generateMipMaps;q(w.width,w.height,u,-1!==R.format,(()=>{W(N,R)}))})).catch((R=>{u.i.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),u.i.Warn(`Failed to transcode Basis file: ${R}`),q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);