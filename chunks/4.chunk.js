"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[4],{10682:(V,n,O)=>{O.r(n),O.d(n,{_BasisTextureLoader:()=>X});var H,g=O(1244),f=O(998),x=O(1164);function c(){const V=0,n=1,O=2,H=3,g=6,f=8,x=9,c=10,e=14;let U=null;function M(V,n,O,H,g){const f=V.getImageTranscodedSizeInBytes(n,O,H);let x=new Uint8Array(f);if(!V.transcodeImage(x,n,O,H,1,0))return null;if(g){x=function(V,n,O,H){const g=new Uint16Array(4),f=new Uint16Array(O*H),x=O/4,c=H/4;for(let e=0;e<c;e++)for(let H=0;H<x;H++){const c=n+8*(e*x+H);g[0]=V[c]|V[c+1]<<8,g[1]=V[c+2]|V[c+3]<<8,g[2]=(2*(31&g[0])+1*(31&g[1]))/3|(2*(2016&g[0])+1*(2016&g[1]))/3&2016|(2*(63488&g[0])+1*(63488&g[1]))/3&63488,g[3]=(2*(31&g[1])+1*(31&g[0]))/3|(2*(2016&g[1])+1*(2016&g[0]))/3&2016|(2*(63488&g[1])+1*(63488&g[0]))/3&63488;for(let n=0;n<4;n++){const x=V[c+4+n];let U=(4*e+n)*O+4*H;f[U++]=g[3&x],f[U++]=g[x>>2&3],f[U++]=g[x>>4&3],f[U++]=g[x>>6&3]}}return f}(x,0,V.getImageWidth(n,O)+3&-4,V.getImageHeight(n,O)+3&-4)}return x}onmessage=p=>{if("init"===p.data.action){if(p.data.url)try{importScripts(p.data.url)}catch(j){postMessage({action:"error",error:j})}U||(U=BASIS({wasmBinary:p.data.wasmBinary})),null!==U&&U.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===p.data.action){const U=p.data.config,j=p.data.imageData,i=new BASIS.BasisFile(j),A=function(V){const n=V.getHasAlpha(),O=V.getNumImages(),H=[];for(let g=0;g<O;g++){const n={levels:[]},O=V.getNumLevels(g);for(let H=0;H<O;H++){const O={width:V.getImageWidth(g,H),height:V.getImageHeight(g,H)};n.levels.push(O)}H.push(n)}return{Ac:n,images:H}}(i);let S=p.data.ignoreSupportedFormats?null:function(U,M){let p=null;U.supportedCompressionFormats&&(p=U.supportedCompressionFormats.astc?c:U.supportedCompressionFormats.bc7?g:U.supportedCompressionFormats.s3tc?M.Ac?H:O:U.supportedCompressionFormats.pvrtc?M.Ac?x:f:U.supportedCompressionFormats.etc2?n:U.supportedCompressionFormats.etc1?V:e);return p}(p.data.config,A),B=!1;null===S&&(B=!0,S=A.Ac?H:O);let X=!0;i.startTranscoding()||(X=!1);const a=[];for(let V=0;V<A.images.length&&X;V++){const n=A.images[V];if(void 0===U.loadSingleImage||U.loadSingleImage===V){let O=n.levels.length;!1===U.loadMipmapLevels&&(O=1);for(let H=0;H<O;H++){const O=n.levels[H],g=M(i,V,H,S,B);if(!g){X=!1;break}O.transcodedPixels=g,a.push(O.transcodedPixels.buffer)}}}i.close(),i.delete(),B&&(S=-1),X?postMessage({action:"transcode",success:X,id:p.data.id,fileInfo:A,format:S},a):postMessage({action:"transcode",success:X,id:p.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(H||(H={}));const e={JSModuleURL:`${g.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${g.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let U=null,M=null,p=0;const j=()=>(U||(U=new Promise(((V,n)=>{M?V(M):g.f.LoadFileAsync(g.f.GetBabylonScriptURL(e.WasmModuleURL)).then((O=>{if("function"!==typeof URL)return n("Basis transcoder requires an environment with a URL constructor");const H=URL.createObjectURL(new Blob([`(${c})()`],{type:"application/javascript"}));M=new Worker(H),function(V,n,O){return new Promise(((H,f)=>{const x=n=>{"init"===n.data.action?(V.removeEventListener("message",x),H(V)):"error"===n.data.action&&f(n.data.error||"error initializing worker")};V.addEventListener("message",x),V.postMessage({action:"init",url:O?g.f.GetBabylonScriptURL(O):void 0,wasmBinary:n},[n])}))}(M,O,e.JSModuleURL).then(V,n)})).catch(n)}))),U),i=(V,n)=>{const O=V instanceof ArrayBuffer?new Uint8Array(V):V;return new Promise(((V,H)=>{j().then((()=>{const g=p++,f=n=>{"transcode"===n.data.action&&n.data.id===g&&(M.removeEventListener("message",f),n.data.success?V(n.data):H("Transcode is not supported on this device"))};M.addEventListener("message",f);const x=new Uint8Array(O.byteLength);x.set(new Uint8Array(O.buffer,O.byteOffset,O.byteLength)),M.postMessage({action:"transcode",id:g,imageData:x,config:n,ignoreSupportedFormats:false},[x.buffer])}),(V=>{H(V)}))}))},A=(V,n)=>{var O;let H=null===(O=n._gl)||void 0===O?void 0:O.TEXTURE_2D;var g;V.isCube&&(H=null===(g=n._gl)||void 0===g?void 0:g.TEXTURE_CUBE_MAP);n._bindTextureDirectly(H,V,!0)},S=(V,n)=>{const O=V.getEngine();for(let c=0;c<n.fileInfo.images.length;c++){const e=n.fileInfo.images[c].levels[0];if(V._invertVScale=V.invertY,-1===n.format||n.format===H.cTFRGB565)if(V.type=10,V.format=4,!O._features.basisNeedsPOT||Math.log2(e.width)%1===0&&Math.log2(e.height)%1===0)V._invertVScale=!V.invertY,V.width=e.width+3&-4,V.height=e.height+3&-4,V.samplingMode=2,A(V,O),O._uploadDataToTextureDirectly(V,new Uint16Array(e.transcodedPixels.buffer),c,0,4,!0);else{const n=new x.e(O,2);V._invertVScale=V.invertY,n.type=10,n.format=4,n.width=e.width+3&-4,n.height=e.height+3&-4,A(n,O),O._uploadDataToTextureDirectly(n,new Uint16Array(e.transcodedPixels.buffer),c,0,4,!0),O._rescaleTexture(n,V,O.scenes[0],O._getInternalFormat(4),(()=>{O._releaseTexture(n),A(V,O)}))}else{V.width=e.width,V.height=e.height,V.generateMipMaps=n.fileInfo.images[c].levels.length>1;const H=B.GetInternalFormatFromBasisFormat(n.format,O);V.format=H,A(V,O),n.fileInfo.images[c].levels.forEach(((n,g)=>{O._uploadCompressedDataToTextureDirectly(V,H,n.width,n.height,n.transcodedPixels,c,g)})),!O._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(g.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=f.d.CLAMP_ADDRESSMODE,V._cachedWrapV=f.d.CLAMP_ADDRESSMODE)}}},B={JSModuleURL:e.JSModuleURL,WasmModuleURL:e.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,n)=>{let O;switch(V){case H.cTFETC1:O=36196;break;case H.cTFBC1:O=33776;break;case H.cTFBC4:O=33779;break;case H.cTFASTC_4x4:O=37808;break;case H.cTFETC2:O=37496;break;case H.cTFBC7:O=36492}if(void 0===O)throw"The chosen Basis transcoder format is not currently supported";return O},TranscodeAsync:i,LoadTextureFromTranscodeResult:S};Object.defineProperty(B,"JSModuleURL",{get:function(){return e.JSModuleURL},set:function(V){e.JSModuleURL=V}}),Object.defineProperty(B,"WasmModuleURL",{get:function(){return e.WasmModuleURL},set:function(V){e.WasmModuleURL=V}});class X{constructor(){this.supportCascades=!1}loadCubeData(V,n,O,H,f){if(Array.isArray(V))return;const x=n.getEngine().getCaps(),c={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};i(V,c).then((V=>{const O=V.fileInfo.images[0].levels.length>1&&n.generateMipMaps;S(n,V),n.getEngine()._setCubeMapTextureParams(n,O),n.isReady=!0,n.onLoadedObservable.notifyObservers(n),n.onLoadedObservable.clear(),H&&H()})).catch((V=>{g.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),n.isReady=!0,f&&f(V)}))}loadData(V,n,O){const H=n.getEngine().getCaps(),f={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};i(V,f).then((V=>{const H=V.fileInfo.images[0].levels[0],g=V.fileInfo.images[0].levels.length>1&&n.generateMipMaps;O(H.width,H.height,g,-1!==V.format,(()=>{S(n,V)}))})).catch((V=>{g.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),g.f.Warn(`Failed to transcode Basis file: ${V}`),O(0,0,!1,!1,(()=>{}),!0)}))}}}}]);