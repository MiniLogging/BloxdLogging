"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6,7],{10700:(V,n,O)=>{var H=O(1551),g=O(1059);g.b.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)},Object.defineProperty(g.b.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=H.d.ConvertCubeMapTextureToSphericalPolynomial(this),null===this._texture._sphericalPolynomialPromise?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then((V=>{this._texture._sphericalPolynomial=V,this._texture._sphericalPolynomialComputed=!0}))),null}return null},set:function(V){this._texture&&(this._texture._sphericalPolynomial=V)},enumerable:!0,configurable:!0})},10702:(V,n,O)=>{O.r(n),O.d(n,{Dispose:()=>j,DumpData:()=>p,DumpDataAsync:()=>M,DumpFramebuffer:()=>U,DumpTools:()=>i});var H=O(1568),g=O(1244),f=O(1056),x=O(1047);let c,e=null;async function U(V,n,O,H){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",f=arguments.length>5?arguments[5]:void 0,x=arguments.length>6?arguments[6]:void 0;const c=await O.readPixels(0,0,V,n);p(V,n,new Uint8Array(c.buffer),H,g,f,!0,void 0,x)}function M(V,n,O){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",g=arguments.length>4?arguments[4]:void 0,f=arguments.length>5&&void 0!==arguments[5]&&arguments[5],x=arguments.length>6&&void 0!==arguments[6]&&arguments[6],c=arguments.length>7?arguments[7]:void 0;return new Promise((e=>{p(V,n,O,(V=>e(V)),H,g,f,x,c)}))}function p(V,n,U,M){let p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",i=arguments.length>5?arguments[5]:void 0,A=arguments.length>6&&void 0!==arguments[6]&&arguments[6],S=arguments.length>7&&void 0!==arguments[7]&&arguments[7],B=arguments.length>8?arguments[8]:void 0;(async function(){return e||(e=new Promise(((V,n)=>{let g,f=null;const e={Be:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(O.bind(O,1461)).then((U=>{let{ThinEngine:M}=U;try{g=new OffscreenCanvas(100,100),f=new M(g,!1,e)}catch(i){g=document.createElement("canvas"),f=new M(g,!1,e)}x.b.Instances.pop(),x.b.OnEnginesDisposedObservable.add((V=>{f&&V!==f&&!f.u&&0===x.b.Instances.length&&j()})),f.getCaps().parallelShaderCompile=void 0;const p=new H.d(f);O.e(32).then(O.bind(O,11411)).then((O=>{let{passPixelShader:x}=O;if(!f)return void n("Engine is not defined");const e=new H.e({Od:f,name:x.name,fragmentShader:x.shader,samplerNames:["textureSampler"]});c={canvas:g,Od:f,renderer:p,wrapper:e},V(c)}))})).catch(n)}))),await e})().then((O=>{if(O.Od.setSize(V,n,!0),U instanceof Float32Array){const V=new Uint8Array(U.length);let n=U.length;for(;n--;){const O=U[n];V[n]=Math.round(255*(0,f.b)(O))}U=V}const H=O.Od.createRawTexture(U,V,n,5,!1,!A,1);O.renderer.setViewport(),O.renderer.applyEffectWrapper(O.wrapper),O.wrapper.effect._bindTexture("textureSampler",H),O.renderer.draw(),S?g.f.ToBlob(O.canvas,(V=>{const n=new FileReader;n.onload=V=>{const n=V.target.result;M&&M(n)},n.readAsArrayBuffer(V)}),p,B):g.f.EncodeScreenshotCanvasData(O.canvas,M,p,i,B),H.dispose()}))}function j(){var V;c?(c.wrapper.dispose(),c.renderer.dispose(),c.Od.dispose()):null===(V=e)||void 0===V||V.then((V=>{V.wrapper.dispose(),V.renderer.dispose(),V.Od.dispose()}));e=null,c=null}const i={DumpData:p,DumpDataAsync:M,DumpFramebuffer:U,Dispose:j};g.f.DumpData=p,g.f.DumpDataAsync=M,g.f.DumpFramebuffer=U},10693:(V,n,O)=>{O.d(n,{d:()=>A,e:()=>X,i:()=>G,k:()=>W});var H=O(1244),g=O(1023),f=O(1056),x=O(1511),c=O(1164),e=O(1059),U=(O(1242),O(1564)),M=O(1118);O(10695),O(10700),O(10702);const p="image/png",j=2,i=[134,22,135,150,246,214,150,54];function A(V){const n=new DataView(V.buffer,V.byteOffset,V.byteLength);let O=0;for(let x=0;x<i.length;x++)if(n.getUint8(O++)!==i[x])return M.b.Error("Not a babylon environment map"),null;let H="",g=0;for(;g=n.getUint8(O++);)H+=String.fromCharCode(g);let f=JSON.parse(H);return f=S(f),f.We&&(f.We.specularDataPosition=O,f.We.lodGenerationScale=f.We.lodGenerationScale||.8),f}function S(V){if(V.version>j)throw new Error(`Unsupported babylon environment map version "${V.version}". Latest supported version is "${j}".`);return 2===V.version?V:V={...V,version:2,imageType:p}}function B(V,n){const O=(n=S(n)).We;let H=Math.log2(n.width);if(H=Math.round(H)+1,O.mipmaps.length!==6*H)throw new Error(`Unsupported specular mipmaps number "${O.mipmaps.length}"`);const g=new Array(H);for(let f=0;f<H;f++){g[f]=new Array(6);for(let n=0;n<6;n++){const H=O.mipmaps[6*f+n];g[f][n]=new Uint8Array(V.buffer,V.byteOffset+O.specularDataPosition+H.position,H.length)}}return g}function X(V,n,O){const H=(O=S(O)).We;if(!H)return Promise.resolve();V._lodGenerationScale=H.lodGenerationScale;return q(V,B(n,O),O.imageType)}function a(V,n,O,H,g,f,x,c,e,U,M){return new Promise(((p,j)=>{if(O){const O=n.createTexture(null,!0,!0,null,1,null,(V=>{j(V)}),V);null===H||void 0===H||H.onEffectCreatedObservable.addOnce((c=>{c.executeWhenCompiled((()=>{H.externalTextureSamplerBinding=!0,H.onApply=H=>{H._bindTexture("textureSampler",O),H.setFloat2("scale",1,n._features.needsInvertingBitmap&&V instanceof ImageBitmap?-1:1)},n.scenes.length&&(n.scenes[0].postProcessManager.directRender([H],U,!0,f,x),n.restoreDefaultFramebuffer(),O.dispose(),URL.revokeObjectURL(g),p())}))}))}else{if(n._uploadImageToTexture(M,V,f,x),c){const O=e[x];O&&n._uploadImageToTexture(O._texture,V,f,0)}p()}}))}async function q(V,n){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:p;if(!H.f.IsExponentOfTwo(V.width))throw new Error("Texture size must be a power of two");const x=(0,f.g)(V.width)+1,M=V.getEngine();let j=!1,i=!1,A=null,S=null,B=null;const X=M.getCaps();V.format=5,V.type=0,V.generateMipMaps=!0,V._cachedAnisotropicFilteringLevel=null,M.updateTextureSamplingMode(3,V),X.textureLOD?M._features.supportRenderAndCopyToLodForFloatTextures?X.textureHalfFloatRender&&X.textureHalfFloatLinearFiltering?(j=!0,V.type=2):X.textureFloatRender&&X.textureFloatLinearFiltering&&(j=!0,V.type=1):j=!1:(j=!1,i=!0,B={});let q=0;if(j)M.isWebGPU?(q=1,await O.e(17).then(O.bind(O,13044))):await O.e(24).then(O.bind(O,13053)),A=new U.c("rgbdDecode","rgbdDecode",null,null,1,null,3,M,!1,void 0,V.type,void 0,null,!1,void 0,q),V._isRGBD=!1,V.invertY=!1,S=M.createRenderTargetCubeTexture(V.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:V.type,format:5});else if(V._isRGBD=!0,V.invertY=!0,i){const n=3,O=V._lodGenerationScale,H=V._lodGenerationOffset;for(let g=0;g<n;g++){const f=(x-1)*O+H,U=H+(f-H)*(1-g/(n-1)),p=Math.round(Math.min(Math.max(U,0),f)),j=new c.e(M,2);j.isCube=!0,j.invertY=!0,j.generateMipMaps=!1,M.updateTextureSamplingMode(2,j);const i=new e.b(null);switch(i._isCube=!0,i._texture=j,B[p]=i,g){case 0:V._lodTextureLow=i;break;case 1:V._lodTextureMid=i;break;case 2:V._lodTextureHigh=i}}}const G=[];for(let O=0;O<n.length;O++)for(let H=0;H<6;H++){const f=n[O][H],x=new Blob([f],{type:g}),c=URL.createObjectURL(x);let e;if(M._features.forceBitmapOverHTMLImageElement)e=M.createImageBitmap(x,{premultiplyAlpha:"none"}).then((n=>a(n,M,j,A,c,H,O,i,B,S,V)));else{const n=new Image;n.src=c,e=new Promise(((g,f)=>{n.onload=()=>{a(n,M,j,A,c,H,O,i,B,S,V).then((()=>g())).catch((V=>{f(V)}))},n.onerror=V=>{f(V)}}))}G.push(e)}if(n.length<x){let O;const H=Math.pow(2,x-1-n.length),g=H*H*4;switch(V.type){case 0:O=new Uint8Array(g);break;case 2:O=new Uint16Array(g);break;case 1:O=new Float32Array(g)}for(let f=n.length;f<x;f++)for(let n=0;n<6;n++)M._uploadArrayBufferViewToTexture(V,O,n,f)}return Promise.all(G).then((()=>{S&&(M._releaseTexture(V),S._swapAndDie(V)),A&&A.dispose(),i&&(V._lodTextureHigh&&V._lodTextureHigh._texture&&(V._lodTextureHigh._texture.isReady=!0),V._lodTextureMid&&V._lodTextureMid._texture&&(V._lodTextureMid._texture.isReady=!0),V._lodTextureLow&&V._lodTextureLow._texture&&(V._lodTextureLow._texture.isReady=!0))}))}function G(V,n){const O=(n=S(n)).irradiance;if(!O)return;const H=new x.h;g.j.FromArrayToRef(O.x,0,H.x),g.j.FromArrayToRef(O.y,0,H.y),g.j.FromArrayToRef(O.z,0,H.z),g.j.FromArrayToRef(O.xx,0,H.xx),g.j.FromArrayToRef(O.yy,0,H.yy),g.j.FromArrayToRef(O.zz,0,H.zz),g.j.FromArrayToRef(O.yz,0,H.yz),g.j.FromArrayToRef(O.zx,0,H.zx),g.j.FromArrayToRef(O.xy,0,H.xy),V._sphericalPolynomial=H}function W(V,n,O,H,g){const f=q(V.getEngine().createRawCubeTexture(null,V.width,V.format,V.type,V.generateMipMaps,V.invertY,V.samplingMode,V._compression),n).then((()=>V));return V.onRebuildCallback=V=>({proxy:f,isReady:!0,isAsync:!0}),V._source=13,V._bufferViewArrayArray=n,V._lodGenerationScale=H,V._lodGenerationOffset=g,V._sphericalPolynomial=O,q(V,n).then((()=>(V.isReady=!0,V)))}},10695:(V,n,O)=>{O.d(n,{c:()=>f});var H=O(1564),g=O(1554);class f{static ExpandRGBDTexture(V){const n=V._texture;if(!n||!V.isRGBD)return;const g=n.getEngine(),f=g.getCaps(),x=n.isReady;let c=!1;f.textureHalfFloatRender&&f.textureHalfFloatLinearFiltering?(c=!0,n.type=2):f.textureFloatRender&&f.textureFloatLinearFiltering&&(c=!0,n.type=1),c&&(n.isReady=!1,n._isRGBD=!1,n.invertY=!1);const e=async()=>{const f=g.isWebGPU,x=f?1:0;n.isReady=!1,f?await Promise.all([O.e(17).then(O.bind(O,13044)),O.e(18).then(O.bind(O,13056))]):await Promise.all([O.e(24).then(O.bind(O,13053)),O.e(25).then(O.bind(O,13065))]);const c=new H.c("rgbdDecode","rgbdDecode",null,null,1,null,3,g,!1,void 0,n.type,void 0,null,!1,void 0,x);c.externalTextureSamplerBinding=!0;const e=g.createRenderTargetTexture(n.width,{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:n.samplingMode,type:n.type,format:5});c.onEffectCreatedObservable.addOnce((O=>{O.executeWhenCompiled((()=>{c.onApply=V=>{V._bindTexture("textureSampler",n),V.setFloat2("scale",1,1)},V.va().postProcessManager.directRender([c],e,!0),g.restoreDefaultFramebuffer(),g._releaseTexture(n),c&&c.dispose(),e._swapAndDie(n),n.isReady=!0}))}))};c&&(x?e():V.onLoadObservable.addOnce(e))}static EncodeTextureToRGBD(V,n){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,g.e)("rgbdEncode",V,n,O,1,5)}}}}]);