"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2421:(k,M,F)=>{F.r(M),F.d(M,{_BasisTextureLoader:()=>y});var l,t=F(480),g=F(2361),B=F(588);function G(){const k=0,M=1,F=2,l=3,t=6,g=8,B=9,G=10,A=14;let N=null;function d(k,M,F,l,t){const g=k.getImageTranscodedSizeInBytes(M,F,l);let B=new Uint8Array(g);if(!k.transcodeImage(B,M,F,l,1,0))return null;if(t){B=function(k,M,F,l){const t=new Uint16Array(4),g=new Uint16Array(F*l),B=F/4,G=l/4;for(let A=0;A<G;A++)for(let l=0;l<B;l++){const G=M+8*(A*B+l);t[0]=k[G]|k[G+1]<<8,t[1]=k[G+2]|k[G+3]<<8,t[2]=(2*(31&t[0])+1*(31&t[1]))/3|(2*(2016&t[0])+1*(2016&t[1]))/3&2016|(2*(63488&t[0])+1*(63488&t[1]))/3&63488,t[3]=(2*(31&t[1])+1*(31&t[0]))/3|(2*(2016&t[1])+1*(2016&t[0]))/3&2016|(2*(63488&t[1])+1*(63488&t[0]))/3&63488;for(let M=0;M<4;M++){const B=k[G+4+M];let N=(4*A+M)*F+4*l;g[N++]=t[3&B],g[N++]=t[B>>2&3],g[N++]=t[B>>4&3],g[N++]=t[B>>6&3]}}return g}(B,0,k.getImageWidth(M,F)+3&-4,k.getImageHeight(M,F)+3&-4)}return B}onmessage=L=>{if("init"===L.data.action){if(L.data.url)try{importScripts(L.data.url)}catch(U){postMessage({action:"error",error:U})}N||(N=BASIS({wasmBinary:L.data.wasmBinary})),null!==N&&N.then((k=>{BASIS=k,k.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===L.data.action){const N=L.data.config,U=L.data.imageData,O=new BASIS.BasisFile(U),w=function(k){const M=k.getHasAlpha(),F=k.getNumImages(),l=[];for(let t=0;t<F;t++){const M={levels:[]},F=k.getNumLevels(t);for(let l=0;l<F;l++){const F={width:k.getImageWidth(t,l),height:k.getImageHeight(t,l)};M.levels.push(F)}l.push(M)}return{yi:M,images:l}}(O);let Z=L.data.ignoreSupportedFormats?null:function(N,d){let L=null;N.supportedCompressionFormats&&(L=N.supportedCompressionFormats.astc?G:N.supportedCompressionFormats.bc7?t:N.supportedCompressionFormats.s3tc?d.yi?l:F:N.supportedCompressionFormats.pvrtc?d.yi?B:g:N.supportedCompressionFormats.etc2?M:N.supportedCompressionFormats.etc1?k:A);return L}(L.data.config,w),R=!1;null===Z&&(R=!0,Z=w.yi?l:F);let y=!0;O.startTranscoding()||(y=!1);const m=[];for(let k=0;k<w.images.length&&y;k++){const M=w.images[k];if(void 0===N.loadSingleImage||N.loadSingleImage===k){let F=M.levels.length;!1===N.loadMipmapLevels&&(F=1);for(let l=0;l<F;l++){const F=M.levels[l],t=d(O,k,l,Z,R);if(!t){y=!1;break}F.transcodedPixels=t,m.push(F.transcodedPixels.buffer)}}}O.close(),O.delete(),R&&(Z=-1),y?postMessage({action:"transcode",success:y,id:L.data.id,fileInfo:w,format:Z},m):postMessage({action:"transcode",success:y,id:L.data.id})}}}!function(k){k[k.cTFETC1=0]="cTFETC1",k[k.cTFETC2=1]="cTFETC2",k[k.cTFBC1=2]="cTFBC1",k[k.cTFBC3=3]="cTFBC3",k[k.cTFBC4=4]="cTFBC4",k[k.cTFBC5=5]="cTFBC5",k[k.cTFBC7=6]="cTFBC7",k[k.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",k[k.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",k[k.cTFASTC_4x4=10]="cTFASTC_4x4",k[k.cTFATC_RGB=11]="cTFATC_RGB",k[k.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",k[k.cTFRGBA32=13]="cTFRGBA32",k[k.cTFRGB565=14]="cTFRGB565",k[k.cTFBGR565=15]="cTFBGR565",k[k.cTFRGBA4444=16]="cTFRGBA4444",k[k.cTFFXT1_RGB=17]="cTFFXT1_RGB",k[k.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",k[k.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",k[k.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",k[k.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(l||(l={}));const A={JSModuleURL:`${t.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${t.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let N=null,d=null,L=0;const U=()=>(N||(N=new Promise(((k,M)=>{d?k(d):t.f.LoadFileAsync(t.f.GetBabylonScriptURL(A.WasmModuleURL)).then((F=>{if("function"!==typeof URL)return M("Basis transcoder requires an environment with a URL constructor");const l=URL.createObjectURL(new Blob([`(${G})()`],{type:"application/javascript"}));d=new Worker(l),function(k,M,F){return new Promise(((l,g)=>{const B=M=>{"init"===M.data.action?(k.removeEventListener("message",B),l(k)):"error"===M.data.action&&g(M.data.error||"error initializing worker")};k.addEventListener("message",B),k.postMessage({action:"init",url:F?t.f.GetBabylonScriptURL(F):void 0,wasmBinary:M},[M])}))}(d,F,A.JSModuleURL).then(k,M)})).catch(M)}))),N),O=(k,M)=>{const F=k instanceof ArrayBuffer?new Uint8Array(k):k;return new Promise(((k,l)=>{U().then((()=>{const t=L++,g=M=>{"transcode"===M.data.action&&M.data.id===t&&(d.removeEventListener("message",g),M.data.success?k(M.data):l("Transcode is not supported on this device"))};d.addEventListener("message",g);const B=new Uint8Array(F.byteLength);B.set(new Uint8Array(F.buffer,F.byteOffset,F.byteLength)),d.postMessage({action:"transcode",id:t,imageData:B,config:M,ignoreSupportedFormats:false},[B.buffer])}),(k=>{l(k)}))}))},w=(k,M)=>{var F;let l=null===(F=M._gl)||void 0===F?void 0:F.TEXTURE_2D;var t;k.isCube&&(l=null===(t=M._gl)||void 0===t?void 0:t.TEXTURE_CUBE_MAP);M._bindTextureDirectly(l,k,!0)},Z=(k,M)=>{const F=k.getEngine();for(let G=0;G<M.fileInfo.images.length;G++){const A=M.fileInfo.images[G].levels[0];if(k._invertVScale=k.invertY,-1===M.format||M.format===l.cTFRGB565)if(k.type=10,k.format=4,!F._features.basisNeedsPOT||Math.log2(A.width)%1===0&&Math.log2(A.height)%1===0)k._invertVScale=!k.invertY,k.width=A.width+3&-4,k.height=A.height+3&-4,k.samplingMode=2,w(k,F),F._uploadDataToTextureDirectly(k,new Uint16Array(A.transcodedPixels.buffer),G,0,4,!0);else{const M=new B.c(F,2);k._invertVScale=k.invertY,M.type=10,M.format=4,M.width=A.width+3&-4,M.height=A.height+3&-4,w(M,F),F._uploadDataToTextureDirectly(M,new Uint16Array(A.transcodedPixels.buffer),G,0,4,!0),F._rescaleTexture(M,k,F.scenes[0],F._getInternalFormat(4),(()=>{F._releaseTexture(M),w(k,F)}))}else{k.width=A.width,k.height=A.height,k.generateMipMaps=M.fileInfo.images[G].levels.length>1;const l=R.GetInternalFormatFromBasisFormat(M.format,F);k.format=l,w(k,F),M.fileInfo.images[G].levels.forEach(((M,t)=>{F._uploadCompressedDataToTextureDirectly(k,l,M.width,M.height,M.transcodedPixels,G,t)})),!F._features.basisNeedsPOT||Math.log2(k.width)%1===0&&Math.log2(k.height)%1===0||(t.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),k._cachedWrapU=g.d.CLAMP_ADDRESSMODE,k._cachedWrapV=g.d.CLAMP_ADDRESSMODE)}}},R={JSModuleURL:A.JSModuleURL,WasmModuleURL:A.WasmModuleURL,GetInternalFormatFromBasisFormat:(k,M)=>{let F;switch(k){case l.cTFETC1:F=36196;break;case l.cTFBC1:F=33776;break;case l.cTFBC4:F=33779;break;case l.cTFASTC_4x4:F=37808;break;case l.cTFETC2:F=37496;break;case l.cTFBC7:F=36492}if(void 0===F)throw"The chosen Basis transcoder format is not currently supported";return F},TranscodeAsync:O,LoadTextureFromTranscodeResult:Z};Object.defineProperty(R,"JSModuleURL",{get:function(){return A.JSModuleURL},set:function(k){A.JSModuleURL=k}}),Object.defineProperty(R,"WasmModuleURL",{get:function(){return A.WasmModuleURL},set:function(k){A.WasmModuleURL=k}});class y{constructor(){this.supportCascades=!1}loadCubeData(k,M,F,l,g){if(Array.isArray(k))return;const B=M.getEngine().getCaps(),G={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};O(k,G).then((k=>{const F=k.fileInfo.images[0].levels.length>1&&M.generateMipMaps;Z(M,k),M.getEngine()._setCubeMapTextureParams(M,F),M.isReady=!0,M.onLoadedObservable.notifyObservers(M),M.onLoadedObservable.clear(),l&&l()})).catch((k=>{t.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),M.isReady=!0,g&&g(k)}))}loadData(k,M,F){const l=M.getEngine().getCaps(),g={supportedCompressionFormats:{etc1:!!l.etc1,s3tc:!!l.s3tc,pvrtc:!!l.pvrtc,etc2:!!l.etc2,astc:!!l.astc,bc7:!!l.bptc}};O(k,g).then((k=>{const l=k.fileInfo.images[0].levels[0],t=k.fileInfo.images[0].levels.length>1&&M.generateMipMaps;F(l.width,l.height,t,-1!==k.format,(()=>{Z(M,k)}))})).catch((k=>{t.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),t.f.Warn(`Failed to transcode Basis file: ${k}`),F(0,0,!1,!1,(()=>{}),!0)}))}}}}]);