"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2365:(f,z,w)=>{w.r(z),w.d(z,{_BasisTextureLoader:()=>d});var S,C=w(535),E=w(2321),F=w(650);function J(){const f=0,z=1,w=2,S=3,C=6,E=8,F=9,J=10,x=14;let u=null;function h(f,z,w,S,C){const E=f.getImageTranscodedSizeInBytes(z,w,S);let F=new Uint8Array(E);if(!f.transcodeImage(F,z,w,S,1,0))return null;if(C){F=function(f,z,w,S){const C=new Uint16Array(4),E=new Uint16Array(w*S),F=w/4,J=S/4;for(let x=0;x<J;x++)for(let S=0;S<F;S++){const J=z+8*(x*F+S);C[0]=f[J]|f[J+1]<<8,C[1]=f[J+2]|f[J+3]<<8,C[2]=(2*(31&C[0])+1*(31&C[1]))/3|(2*(2016&C[0])+1*(2016&C[1]))/3&2016|(2*(63488&C[0])+1*(63488&C[1]))/3&63488,C[3]=(2*(31&C[1])+1*(31&C[0]))/3|(2*(2016&C[1])+1*(2016&C[0]))/3&2016|(2*(63488&C[1])+1*(63488&C[0]))/3&63488;for(let z=0;z<4;z++){const F=f[J+4+z];let u=(4*x+z)*w+4*S;E[u++]=C[3&F],E[u++]=C[F>>2&3],E[u++]=C[F>>4&3],E[u++]=C[F>>6&3]}}return E}(F,0,f.getImageWidth(z,w)+3&-4,f.getImageHeight(z,w)+3&-4)}return F}onmessage=X=>{if("init"===X.data.action){if(X.data.url)try{importScripts(X.data.url)}catch(K){postMessage({action:"error",error:K})}u||(u=BASIS({wasmBinary:X.data.wasmBinary})),null!==u&&u.then((f=>{BASIS=f,f.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===X.data.action){const u=X.data.config,K=X.data.imageData,c=new BASIS.BasisFile(K),y=function(f){const z=f.getHasAlpha(),w=f.getNumImages(),S=[];for(let C=0;C<w;C++){const z={levels:[]},w=f.getNumLevels(C);for(let S=0;S<w;S++){const w={width:f.getImageWidth(C,S),height:f.getImageHeight(C,S)};z.levels.push(w)}S.push(z)}return{xi:z,images:S}}(c);let e=X.data.ignoreSupportedFormats?null:function(u,h){let X=null;u.supportedCompressionFormats&&(X=u.supportedCompressionFormats.astc?J:u.supportedCompressionFormats.bc7?C:u.supportedCompressionFormats.s3tc?h.xi?S:w:u.supportedCompressionFormats.pvrtc?h.xi?F:E:u.supportedCompressionFormats.etc2?z:u.supportedCompressionFormats.etc1?f:x);return X}(X.data.config,y),O=!1;null===e&&(O=!0,e=y.xi?S:w);let d=!0;c.startTranscoding()||(d=!1);const B=[];for(let f=0;f<y.images.length&&d;f++){const z=y.images[f];if(void 0===u.loadSingleImage||u.loadSingleImage===f){let w=z.levels.length;!1===u.loadMipmapLevels&&(w=1);for(let S=0;S<w;S++){const w=z.levels[S],C=h(c,f,S,e,O);if(!C){d=!1;break}w.transcodedPixels=C,B.push(w.transcodedPixels.buffer)}}}c.close(),c.delete(),O&&(e=-1),d?postMessage({action:"transcode",success:d,id:X.data.id,fileInfo:y,format:e},B):postMessage({action:"transcode",success:d,id:X.data.id})}}}!function(f){f[f.cTFETC1=0]="cTFETC1",f[f.cTFETC2=1]="cTFETC2",f[f.cTFBC1=2]="cTFBC1",f[f.cTFBC3=3]="cTFBC3",f[f.cTFBC4=4]="cTFBC4",f[f.cTFBC5=5]="cTFBC5",f[f.cTFBC7=6]="cTFBC7",f[f.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",f[f.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",f[f.cTFASTC_4x4=10]="cTFASTC_4x4",f[f.cTFATC_RGB=11]="cTFATC_RGB",f[f.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",f[f.cTFRGBA32=13]="cTFRGBA32",f[f.cTFRGB565=14]="cTFRGB565",f[f.cTFBGR565=15]="cTFBGR565",f[f.cTFRGBA4444=16]="cTFRGBA4444",f[f.cTFFXT1_RGB=17]="cTFFXT1_RGB",f[f.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",f[f.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",f[f.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",f[f.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(S||(S={}));const x={JSModuleURL:`${C.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${C.h._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let u=null,h=null,X=0;const K=()=>(u||(u=new Promise(((f,z)=>{h?f(h):C.h.LoadFileAsync(C.h.GetBabylonScriptURL(x.WasmModuleURL)).then((w=>{if("function"!==typeof URL)return z("Basis transcoder requires an environment with a URL constructor");const S=URL.createObjectURL(new Blob([`(${J})()`],{type:"application/javascript"}));h=new Worker(S),function(f,z,w){return new Promise(((S,E)=>{const F=z=>{"init"===z.data.action?(f.removeEventListener("message",F),S(f)):"error"===z.data.action&&E(z.data.error||"error initializing worker")};f.addEventListener("message",F),f.postMessage({action:"init",url:w?C.h.GetBabylonScriptURL(w):void 0,wasmBinary:z},[z])}))}(h,w,x.JSModuleURL).then(f,z)})).catch(z)}))),u),c=(f,z)=>{const w=f instanceof ArrayBuffer?new Uint8Array(f):f;return new Promise(((f,S)=>{K().then((()=>{const C=X++,E=z=>{"transcode"===z.data.action&&z.data.id===C&&(h.removeEventListener("message",E),z.data.success?f(z.data):S("Transcode is not supported on this device"))};h.addEventListener("message",E);const F=new Uint8Array(w.byteLength);F.set(new Uint8Array(w.buffer,w.byteOffset,w.byteLength)),h.postMessage({action:"transcode",id:C,imageData:F,config:z,ignoreSupportedFormats:false},[F.buffer])}),(f=>{S(f)}))}))},y=(f,z)=>{var w;let S=null===(w=z._gl)||void 0===w?void 0:w.TEXTURE_2D;var C;f.isCube&&(S=null===(C=z._gl)||void 0===C?void 0:C.TEXTURE_CUBE_MAP);z._bindTextureDirectly(S,f,!0)},e=(f,z)=>{const w=f.getEngine();for(let J=0;J<z.fileInfo.images.length;J++){const x=z.fileInfo.images[J].levels[0];if(f._invertVScale=f.invertY,-1===z.format||z.format===S.cTFRGB565)if(f.type=10,f.format=4,!w._features.basisNeedsPOT||Math.log2(x.width)%1===0&&Math.log2(x.height)%1===0)f._invertVScale=!f.invertY,f.width=x.width+3&-4,f.height=x.height+3&-4,f.samplingMode=2,y(f,w),w._uploadDataToTextureDirectly(f,new Uint16Array(x.transcodedPixels.buffer),J,0,4,!0);else{const z=new F.e(w,2);f._invertVScale=f.invertY,z.type=10,z.format=4,z.width=x.width+3&-4,z.height=x.height+3&-4,y(z,w),w._uploadDataToTextureDirectly(z,new Uint16Array(x.transcodedPixels.buffer),J,0,4,!0),w._rescaleTexture(z,f,w.scenes[0],w._getInternalFormat(4),(()=>{w._releaseTexture(z),y(f,w)}))}else{f.width=x.width,f.height=x.height,f.generateMipMaps=z.fileInfo.images[J].levels.length>1;const S=O.GetInternalFormatFromBasisFormat(z.format,w);f.format=S,y(f,w),z.fileInfo.images[J].levels.forEach(((z,C)=>{w._uploadCompressedDataToTextureDirectly(f,S,z.width,z.height,z.transcodedPixels,J,C)})),!w._features.basisNeedsPOT||Math.log2(f.width)%1===0&&Math.log2(f.height)%1===0||(C.h.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),f._cachedWrapU=E.b.CLAMP_ADDRESSMODE,f._cachedWrapV=E.b.CLAMP_ADDRESSMODE)}}},O={JSModuleURL:x.JSModuleURL,WasmModuleURL:x.WasmModuleURL,GetInternalFormatFromBasisFormat:(f,z)=>{let w;switch(f){case S.cTFETC1:w=36196;break;case S.cTFBC1:w=33776;break;case S.cTFBC4:w=33779;break;case S.cTFASTC_4x4:w=37808;break;case S.cTFETC2:w=37496;break;case S.cTFBC7:w=36492}if(void 0===w)throw"The chosen Basis transcoder format is not currently supported";return w},TranscodeAsync:c,LoadTextureFromTranscodeResult:e};Object.defineProperty(O,"JSModuleURL",{get:function(){return x.JSModuleURL},set:function(f){x.JSModuleURL=f}}),Object.defineProperty(O,"WasmModuleURL",{get:function(){return x.WasmModuleURL},set:function(f){x.WasmModuleURL=f}});class d{constructor(){this.supportCascades=!1}loadCubeData(f,z,w,S,E){if(Array.isArray(f))return;const F=z.getEngine().getCaps(),J={supportedCompressionFormats:{etc1:!!F.etc1,s3tc:!!F.s3tc,pvrtc:!!F.pvrtc,etc2:!!F.etc2,astc:!!F.astc,bc7:!!F.bptc}};c(f,J).then((f=>{const w=f.fileInfo.images[0].levels.length>1&&z.generateMipMaps;e(z,f),z.getEngine()._setCubeMapTextureParams(z,w),z.isReady=!0,z.onLoadedObservable.notifyObservers(z),z.onLoadedObservable.clear(),S&&S()})).catch((f=>{C.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.isReady=!0,E&&E(f)}))}loadData(f,z,w){const S=z.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};c(f,E).then((f=>{const S=f.fileInfo.images[0].levels[0],C=f.fileInfo.images[0].levels.length>1&&z.generateMipMaps;w(S.width,S.height,C,-1!==f.format,(()=>{e(z,f)}))})).catch((f=>{C.h.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),C.h.Warn(`Failed to transcode Basis file: ${f}`),w(0,0,!1,!1,(()=>{}),!0)}))}}}}]);