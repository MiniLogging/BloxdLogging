"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2092:(B,o,e)=>{e.r(o),e.d(o,{_BasisTextureLoader:()=>W});var k,d=e(499),f=e(2033),J=e(610);function Z(){const B=0,o=1,e=2,k=3,d=6,f=8,J=9,Z=10,t=14;let h=null;function O(B,o,e,k,d){const f=B.getImageTranscodedSizeInBytes(o,e,k);let J=new Uint8Array(f);if(!B.transcodeImage(J,o,e,k,1,0))return null;if(d){J=function(B,o,e,k){const d=new Uint16Array(4),f=new Uint16Array(e*k),J=e/4,Z=k/4;for(let t=0;t<Z;t++)for(let k=0;k<J;k++){const Z=o+8*(t*J+k);d[0]=B[Z]|B[Z+1]<<8,d[1]=B[Z+2]|B[Z+3]<<8,d[2]=(2*(31&d[0])+1*(31&d[1]))/3|(2*(2016&d[0])+1*(2016&d[1]))/3&2016|(2*(63488&d[0])+1*(63488&d[1]))/3&63488,d[3]=(2*(31&d[1])+1*(31&d[0]))/3|(2*(2016&d[1])+1*(2016&d[0]))/3&2016|(2*(63488&d[1])+1*(63488&d[0]))/3&63488;for(let o=0;o<4;o++){const J=B[Z+4+o];let h=(4*t+o)*e+4*k;f[h++]=d[3&J],f[h++]=d[J>>2&3],f[h++]=d[J>>4&3],f[h++]=d[J>>6&3]}}return f}(J,0,B.getImageWidth(o,e)+3&-4,B.getImageHeight(o,e)+3&-4)}return J}onmessage=K=>{if("init"===K.data.action){if(K.data.url)try{importScripts(K.data.url)}catch(w){postMessage({action:"error",error:w})}h||(h=BASIS({wasmBinary:K.data.wasmBinary})),null!==h&&h.then((B=>{BASIS=B,B.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===K.data.action){const h=K.data.config,w=K.data.imageData,u=new BASIS.BasisFile(w),L=function(B){const o=B.getHasAlpha(),e=B.getNumImages(),k=[];for(let d=0;d<e;d++){const o={levels:[]},e=B.getNumLevels(d);for(let k=0;k<e;k++){const e={width:B.getImageWidth(d,k),height:B.getImageHeight(d,k)};o.levels.push(e)}k.push(o)}return{zj:o,images:k}}(u);let H=K.data.ignoreSupportedFormats?null:function(h,O){let K=null;h.supportedCompressionFormats&&(K=h.supportedCompressionFormats.astc?Z:h.supportedCompressionFormats.bc7?d:h.supportedCompressionFormats.s3tc?O.zj?k:e:h.supportedCompressionFormats.pvrtc?O.zj?J:f:h.supportedCompressionFormats.etc2?o:h.supportedCompressionFormats.etc1?B:t);return K}(K.data.config,L),n=!1;null===H&&(n=!0,H=L.zj?k:e);let W=!0;u.startTranscoding()||(W=!1);const R=[];for(let B=0;B<L.images.length&&W;B++){const o=L.images[B];if(void 0===h.loadSingleImage||h.loadSingleImage===B){let e=o.levels.length;!1===h.loadMipmapLevels&&(e=1);for(let k=0;k<e;k++){const e=o.levels[k],d=O(u,B,k,H,n);if(!d){W=!1;break}e.transcodedPixels=d,R.push(e.transcodedPixels.buffer)}}}u.close(),u.delete(),n&&(H=-1),W?postMessage({action:"transcode",success:W,id:K.data.id,fileInfo:L,format:H},R):postMessage({action:"transcode",success:W,id:K.data.id})}}}!function(B){B[B.cTFETC1=0]="cTFETC1",B[B.cTFETC2=1]="cTFETC2",B[B.cTFBC1=2]="cTFBC1",B[B.cTFBC3=3]="cTFBC3",B[B.cTFBC4=4]="cTFBC4",B[B.cTFBC5=5]="cTFBC5",B[B.cTFBC7=6]="cTFBC7",B[B.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",B[B.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",B[B.cTFASTC_4x4=10]="cTFASTC_4x4",B[B.cTFATC_RGB=11]="cTFATC_RGB",B[B.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",B[B.cTFRGBA32=13]="cTFRGBA32",B[B.cTFRGB565=14]="cTFRGB565",B[B.cTFBGR565=15]="cTFBGR565",B[B.cTFRGBA4444=16]="cTFRGBA4444",B[B.cTFFXT1_RGB=17]="cTFFXT1_RGB",B[B.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",B[B.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",B[B.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",B[B.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(k||(k={}));const t={JSModuleURL:`${d.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${d.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let h=null,O=null,K=0;const w=()=>(h||(h=new Promise(((B,o)=>{O?B(O):d.d.LoadFileAsync(d.d.GetBabylonScriptURL(t.WasmModuleURL)).then((e=>{if("function"!==typeof URL)return o("Basis transcoder requires an environment with a URL constructor");const k=URL.createObjectURL(new Blob([`(${Z})()`],{type:"application/javascript"}));O=new Worker(k),function(B,o,e){return new Promise(((k,f)=>{const J=o=>{"init"===o.data.action?(B.removeEventListener("message",J),k(B)):"error"===o.data.action&&f(o.data.error||"error initializing worker")};B.addEventListener("message",J),B.postMessage({action:"init",url:e?d.d.GetBabylonScriptURL(e):void 0,wasmBinary:o},[o])}))}(O,e,t.JSModuleURL).then(B,o)})).catch(o)}))),h),u=(B,o)=>{const e=B instanceof ArrayBuffer?new Uint8Array(B):B;return new Promise(((B,k)=>{w().then((()=>{const d=K++,f=o=>{"transcode"===o.data.action&&o.data.id===d&&(O.removeEventListener("message",f),o.data.success?B(o.data):k("Transcode is not supported on this device"))};O.addEventListener("message",f);const J=new Uint8Array(e.byteLength);J.set(new Uint8Array(e.buffer,e.byteOffset,e.byteLength)),O.postMessage({action:"transcode",id:d,imageData:J,config:o,ignoreSupportedFormats:false},[J.buffer])}),(B=>{k(B)}))}))},L=(B,o)=>{var e;let k=null===(e=o._gl)||void 0===e?void 0:e.TEXTURE_2D;var d;B.isCube&&(k=null===(d=o._gl)||void 0===d?void 0:d.TEXTURE_CUBE_MAP);o._bindTextureDirectly(k,B,!0)},H=(B,o)=>{const e=B.getEngine();for(let Z=0;Z<o.fileInfo.images.length;Z++){const t=o.fileInfo.images[Z].levels[0];if(B._invertVScale=B.invertY,-1===o.format||o.format===k.cTFRGB565)if(B.type=10,B.format=4,!e._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)B._invertVScale=!B.invertY,B.width=t.width+3&-4,B.height=t.height+3&-4,B.samplingMode=2,L(B,e),e._uploadDataToTextureDirectly(B,new Uint16Array(t.transcodedPixels.buffer),Z,0,4,!0);else{const o=new J.e(e,2);B._invertVScale=B.invertY,o.type=10,o.format=4,o.width=t.width+3&-4,o.height=t.height+3&-4,L(o,e),e._uploadDataToTextureDirectly(o,new Uint16Array(t.transcodedPixels.buffer),Z,0,4,!0),e._rescaleTexture(o,B,e.scenes[0],e._getInternalFormat(4),(()=>{e._releaseTexture(o),L(B,e)}))}else{B.width=t.width,B.height=t.height,B.generateMipMaps=o.fileInfo.images[Z].levels.length>1;const k=n.GetInternalFormatFromBasisFormat(o.format,e);B.format=k,L(B,e),o.fileInfo.images[Z].levels.forEach(((o,d)=>{e._uploadCompressedDataToTextureDirectly(B,k,o.width,o.height,o.transcodedPixels,Z,d)})),!e._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0||(d.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),B._cachedWrapU=f.d.CLAMP_ADDRESSMODE,B._cachedWrapV=f.d.CLAMP_ADDRESSMODE)}}},n={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(B,o)=>{let e;switch(B){case k.cTFETC1:e=36196;break;case k.cTFBC1:e=33776;break;case k.cTFBC4:e=33779;break;case k.cTFASTC_4x4:e=37808;break;case k.cTFETC2:e=37496;break;case k.cTFBC7:e=36492}if(void 0===e)throw"The chosen Basis transcoder format is not currently supported";return e},TranscodeAsync:u,LoadTextureFromTranscodeResult:H};Object.defineProperty(n,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(B){t.JSModuleURL=B}}),Object.defineProperty(n,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(B){t.WasmModuleURL=B}});class W{constructor(){this.supportCascades=!1}loadCubeData(B,o,e,k,f){if(Array.isArray(B))return;const J=o.getEngine().getCaps(),Z={supportedCompressionFormats:{etc1:!!J.etc1,s3tc:!!J.s3tc,pvrtc:!!J.pvrtc,etc2:!!J.etc2,astc:!!J.astc,bc7:!!J.bptc}};u(B,Z).then((B=>{const e=B.fileInfo.images[0].levels.length>1&&o.generateMipMaps;H(o,B),o.getEngine()._setCubeMapTextureParams(o,e),o.isReady=!0,o.onLoadedObservable.notifyObservers(o),o.onLoadedObservable.clear(),k&&k()})).catch((B=>{d.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),o.isReady=!0,f&&f(B)}))}loadData(B,o,e){const k=o.getEngine().getCaps(),f={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};u(B,f).then((B=>{const k=B.fileInfo.images[0].levels[0],d=B.fileInfo.images[0].levels.length>1&&o.generateMipMaps;e(k.width,k.height,d,-1!==B.format,(()=>{H(o,B)}))})).catch((B=>{d.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.d.Warn(`Failed to transcode Basis file: ${B}`),e(0,0,!1,!1,(()=>{}),!0)}))}}}}]);