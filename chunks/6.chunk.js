"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2349:(K,Y,l)=>{l.r(Y),l.d(Y,{_BasisTextureLoader:()=>J});var v,U=l(475),d=l(2299),A=l(594);function c(){const K=0,Y=1,l=2,v=3,U=6,d=8,A=9,c=10,t=14;let Z=null;function m(K,Y,l,v,U){const d=K.getImageTranscodedSizeInBytes(Y,l,v);let A=new Uint8Array(d);if(!K.transcodeImage(A,Y,l,v,1,0))return null;if(U){A=function(K,Y,l,v){const U=new Uint16Array(4),d=new Uint16Array(l*v),A=l/4,c=v/4;for(let t=0;t<c;t++)for(let v=0;v<A;v++){const c=Y+8*(t*A+v);U[0]=K[c]|K[c+1]<<8,U[1]=K[c+2]|K[c+3]<<8,U[2]=(2*(31&U[0])+1*(31&U[1]))/3|(2*(2016&U[0])+1*(2016&U[1]))/3&2016|(2*(63488&U[0])+1*(63488&U[1]))/3&63488,U[3]=(2*(31&U[1])+1*(31&U[0]))/3|(2*(2016&U[1])+1*(2016&U[0]))/3&2016|(2*(63488&U[1])+1*(63488&U[0]))/3&63488;for(let Y=0;Y<4;Y++){const A=K[c+4+Y];let Z=(4*t+Y)*l+4*v;d[Z++]=U[3&A],d[Z++]=U[A>>2&3],d[Z++]=U[A>>4&3],d[Z++]=U[A>>6&3]}}return d}(A,0,K.getImageWidth(Y,l)+3&-4,K.getImageHeight(Y,l)+3&-4)}return A}onmessage=V=>{if("init"===V.data.action){if(V.data.url)try{importScripts(V.data.url)}catch(M){postMessage({action:"error",error:M})}Z||(Z=BASIS({wasmBinary:V.data.wasmBinary})),null!==Z&&Z.then((K=>{BASIS=K,K.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===V.data.action){const Z=V.data.config,M=V.data.imageData,u=new BASIS.BasisFile(M),o=function(K){const Y=K.getHasAlpha(),l=K.getNumImages(),v=[];for(let U=0;U<l;U++){const Y={levels:[]},l=K.getNumLevels(U);for(let v=0;v<l;v++){const l={width:K.getImageWidth(U,v),height:K.getImageHeight(U,v)};Y.levels.push(l)}v.push(Y)}return{Cj:Y,images:v}}(u);let W=V.data.ignoreSupportedFormats?null:function(Z,m){let V=null;Z.supportedCompressionFormats&&(V=Z.supportedCompressionFormats.astc?c:Z.supportedCompressionFormats.bc7?U:Z.supportedCompressionFormats.s3tc?m.Cj?v:l:Z.supportedCompressionFormats.pvrtc?m.Cj?A:d:Z.supportedCompressionFormats.etc2?Y:Z.supportedCompressionFormats.etc1?K:t);return V}(V.data.config,o),g=!1;null===W&&(g=!0,W=o.Cj?v:l);let J=!0;u.startTranscoding()||(J=!1);const n=[];for(let K=0;K<o.images.length&&J;K++){const Y=o.images[K];if(void 0===Z.loadSingleImage||Z.loadSingleImage===K){let l=Y.levels.length;!1===Z.loadMipmapLevels&&(l=1);for(let v=0;v<l;v++){const l=Y.levels[v],U=m(u,K,v,W,g);if(!U){J=!1;break}l.transcodedPixels=U,n.push(l.transcodedPixels.buffer)}}}u.close(),u.delete(),g&&(W=-1),J?postMessage({action:"transcode",success:J,id:V.data.id,fileInfo:o,format:W},n):postMessage({action:"transcode",success:J,id:V.data.id})}}}!function(K){K[K.cTFETC1=0]="cTFETC1",K[K.cTFETC2=1]="cTFETC2",K[K.cTFBC1=2]="cTFBC1",K[K.cTFBC3=3]="cTFBC3",K[K.cTFBC4=4]="cTFBC4",K[K.cTFBC5=5]="cTFBC5",K[K.cTFBC7=6]="cTFBC7",K[K.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",K[K.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",K[K.cTFASTC_4x4=10]="cTFASTC_4x4",K[K.cTFATC_RGB=11]="cTFATC_RGB",K[K.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",K[K.cTFRGBA32=13]="cTFRGBA32",K[K.cTFRGB565=14]="cTFRGB565",K[K.cTFBGR565=15]="cTFBGR565",K[K.cTFRGBA4444=16]="cTFRGBA4444",K[K.cTFFXT1_RGB=17]="cTFFXT1_RGB",K[K.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",K[K.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",K[K.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",K[K.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(v||(v={}));const t={JSModuleURL:`${U.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${U.d._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Z=null,m=null,V=0;const M=()=>(Z||(Z=new Promise(((K,Y)=>{m?K(m):U.d.LoadFileAsync(U.d.GetBabylonScriptURL(t.WasmModuleURL)).then((l=>{if("function"!==typeof URL)return Y("Basis transcoder requires an environment with a URL constructor");const v=URL.createObjectURL(new Blob([`(${c})()`],{type:"application/javascript"}));m=new Worker(v),function(K,Y,l){return new Promise(((v,d)=>{const A=Y=>{"init"===Y.data.action?(K.removeEventListener("message",A),v(K)):"error"===Y.data.action&&d(Y.data.error||"error initializing worker")};K.addEventListener("message",A),K.postMessage({action:"init",url:l?U.d.GetBabylonScriptURL(l):void 0,wasmBinary:Y},[Y])}))}(m,l,t.JSModuleURL).then(K,Y)})).catch(Y)}))),Z),u=(K,Y)=>{const l=K instanceof ArrayBuffer?new Uint8Array(K):K;return new Promise(((K,v)=>{M().then((()=>{const U=V++,d=Y=>{"transcode"===Y.data.action&&Y.data.id===U&&(m.removeEventListener("message",d),Y.data.success?K(Y.data):v("Transcode is not supported on this device"))};m.addEventListener("message",d);const A=new Uint8Array(l.byteLength);A.set(new Uint8Array(l.buffer,l.byteOffset,l.byteLength)),m.postMessage({action:"transcode",id:U,imageData:A,config:Y,ignoreSupportedFormats:false},[A.buffer])}),(K=>{v(K)}))}))},o=(K,Y)=>{var l;let v=null===(l=Y._gl)||void 0===l?void 0:l.TEXTURE_2D;var U;K.isCube&&(v=null===(U=Y._gl)||void 0===U?void 0:U.TEXTURE_CUBE_MAP);Y._bindTextureDirectly(v,K,!0)},W=(K,Y)=>{const l=K.getEngine();for(let c=0;c<Y.fileInfo.images.length;c++){const t=Y.fileInfo.images[c].levels[0];if(K._invertVScale=K.invertY,-1===Y.format||Y.format===v.cTFRGB565)if(K.type=10,K.format=4,!l._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)K._invertVScale=!K.invertY,K.width=t.width+3&-4,K.height=t.height+3&-4,K.samplingMode=2,o(K,l),l._uploadDataToTextureDirectly(K,new Uint16Array(t.transcodedPixels.buffer),c,0,4,!0);else{const Y=new A.e(l,2);K._invertVScale=K.invertY,Y.type=10,Y.format=4,Y.width=t.width+3&-4,Y.height=t.height+3&-4,o(Y,l),l._uploadDataToTextureDirectly(Y,new Uint16Array(t.transcodedPixels.buffer),c,0,4,!0),l._rescaleTexture(Y,K,l.scenes[0],l._getInternalFormat(4),(()=>{l._releaseTexture(Y),o(K,l)}))}else{K.width=t.width,K.height=t.height,K.generateMipMaps=Y.fileInfo.images[c].levels.length>1;const v=g.GetInternalFormatFromBasisFormat(Y.format,l);K.format=v,o(K,l),Y.fileInfo.images[c].levels.forEach(((Y,U)=>{l._uploadCompressedDataToTextureDirectly(K,v,Y.width,Y.height,Y.transcodedPixels,c,U)})),!l._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0||(U.d.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),K._cachedWrapU=d.c.CLAMP_ADDRESSMODE,K._cachedWrapV=d.c.CLAMP_ADDRESSMODE)}}},g={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(K,Y)=>{let l;switch(K){case v.cTFETC1:l=36196;break;case v.cTFBC1:l=33776;break;case v.cTFBC4:l=33779;break;case v.cTFASTC_4x4:l=37808;break;case v.cTFETC2:l=37496;break;case v.cTFBC7:l=36492}if(void 0===l)throw"The chosen Basis transcoder format is not currently supported";return l},TranscodeAsync:u,LoadTextureFromTranscodeResult:W};Object.defineProperty(g,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(K){t.JSModuleURL=K}}),Object.defineProperty(g,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(K){t.WasmModuleURL=K}});class J{constructor(){this.supportCascades=!1}loadCubeData(K,Y,l,v,d){if(Array.isArray(K))return;const A=Y.getEngine().getCaps(),c={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};u(K,c).then((K=>{const l=K.fileInfo.images[0].levels.length>1&&Y.generateMipMaps;W(Y,K),Y.getEngine()._setCubeMapTextureParams(Y,l),Y.isReady=!0,Y.onLoadedObservable.notifyObservers(Y),Y.onLoadedObservable.clear(),v&&v()})).catch((K=>{U.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Y.isReady=!0,d&&d(K)}))}loadData(K,Y,l){const v=Y.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};u(K,d).then((K=>{const v=K.fileInfo.images[0].levels[0],U=K.fileInfo.images[0].levels.length>1&&Y.generateMipMaps;l(v.width,v.height,U,-1!==K.format,(()=>{W(Y,K)}))})).catch((K=>{U.d.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.d.Warn(`Failed to transcode Basis file: ${K}`),l(0,0,!1,!1,(()=>{}),!0)}))}}}}]);