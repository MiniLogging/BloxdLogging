"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2127:(Y,d,t)=>{t.r(d),t.d(d,{_BasisTextureLoader:()=>g});var x,C=t(521),U=t(2077),y=t(609);function B(){const Y=0,d=1,t=2,x=3,C=6,U=8,y=9,B=10,W=14;let o=null;function f(Y,d,t,x,C){const U=Y.getImageTranscodedSizeInBytes(d,t,x);let y=new Uint8Array(U);if(!Y.transcodeImage(y,d,t,x,1,0))return null;if(C){y=function(Y,d,t,x){const C=new Uint16Array(4),U=new Uint16Array(t*x),y=t/4,B=x/4;for(let W=0;W<B;W++)for(let x=0;x<y;x++){const B=d+8*(W*y+x);C[0]=Y[B]|Y[B+1]<<8,C[1]=Y[B+2]|Y[B+3]<<8,C[2]=(2*(31&C[0])+1*(31&C[1]))/3|(2*(2016&C[0])+1*(2016&C[1]))/3&2016|(2*(63488&C[0])+1*(63488&C[1]))/3&63488,C[3]=(2*(31&C[1])+1*(31&C[0]))/3|(2*(2016&C[1])+1*(2016&C[0]))/3&2016|(2*(63488&C[1])+1*(63488&C[0]))/3&63488;for(let d=0;d<4;d++){const y=Y[B+4+d];let o=(4*W+d)*t+4*x;U[o++]=C[3&y],U[o++]=C[y>>2&3],U[o++]=C[y>>4&3],U[o++]=C[y>>6&3]}}return U}(y,0,Y.getImageWidth(d,t)+3&-4,Y.getImageHeight(d,t)+3&-4)}return y}onmessage=F=>{if("init"===F.data.action){if(F.data.url)try{importScripts(F.data.url)}catch(D){postMessage({action:"error",error:D})}o||(o=BASIS({wasmBinary:F.data.wasmBinary})),null!==o&&o.then((Y=>{BASIS=Y,Y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===F.data.action){const o=F.data.config,D=F.data.imageData,b=new BASIS.BasisFile(D),m=function(Y){const d=Y.getHasAlpha(),t=Y.getNumImages(),x=[];for(let C=0;C<t;C++){const d={levels:[]},t=Y.getNumLevels(C);for(let x=0;x<t;x++){const t={width:Y.getImageWidth(C,x),height:Y.getImageHeight(C,x)};d.levels.push(t)}x.push(d)}return{wi:d,images:x}}(b);let M=F.data.ignoreSupportedFormats?null:function(o,f){let F=null;o.supportedCompressionFormats&&(F=o.supportedCompressionFormats.astc?B:o.supportedCompressionFormats.bc7?C:o.supportedCompressionFormats.s3tc?f.wi?x:t:o.supportedCompressionFormats.pvrtc?f.wi?y:U:o.supportedCompressionFormats.etc2?d:o.supportedCompressionFormats.etc1?Y:W);return F}(F.data.config,m),J=!1;null===M&&(J=!0,M=m.wi?x:t);let g=!0;b.startTranscoding()||(g=!1);const T=[];for(let Y=0;Y<m.images.length&&g;Y++){const d=m.images[Y];if(void 0===o.loadSingleImage||o.loadSingleImage===Y){let t=d.levels.length;!1===o.loadMipmapLevels&&(t=1);for(let x=0;x<t;x++){const t=d.levels[x],C=f(b,Y,x,M,J);if(!C){g=!1;break}t.transcodedPixels=C,T.push(t.transcodedPixels.buffer)}}}b.close(),b.delete(),J&&(M=-1),g?postMessage({action:"transcode",success:g,id:F.data.id,fileInfo:m,format:M},T):postMessage({action:"transcode",success:g,id:F.data.id})}}}!function(Y){Y[Y.cTFETC1=0]="cTFETC1",Y[Y.cTFETC2=1]="cTFETC2",Y[Y.cTFBC1=2]="cTFBC1",Y[Y.cTFBC3=3]="cTFBC3",Y[Y.cTFBC4=4]="cTFBC4",Y[Y.cTFBC5=5]="cTFBC5",Y[Y.cTFBC7=6]="cTFBC7",Y[Y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Y[Y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Y[Y.cTFASTC_4x4=10]="cTFASTC_4x4",Y[Y.cTFATC_RGB=11]="cTFATC_RGB",Y[Y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Y[Y.cTFRGBA32=13]="cTFRGBA32",Y[Y.cTFRGB565=14]="cTFRGB565",Y[Y.cTFBGR565=15]="cTFBGR565",Y[Y.cTFRGBA4444=16]="cTFRGBA4444",Y[Y.cTFFXT1_RGB=17]="cTFFXT1_RGB",Y[Y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Y[Y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Y[Y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Y[Y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(x||(x={}));const W={JSModuleURL:`${C.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${C.e._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let o=null,f=null,F=0;const D=()=>(o||(o=new Promise(((Y,d)=>{f?Y(f):C.e.LoadFileAsync(C.e.GetBabylonScriptURL(W.WasmModuleURL)).then((t=>{if("function"!==typeof URL)return d("Basis transcoder requires an environment with a URL constructor");const x=URL.createObjectURL(new Blob([`(${B})()`],{type:"application/javascript"}));f=new Worker(x),function(Y,d,t){return new Promise(((x,U)=>{const y=d=>{"init"===d.data.action?(Y.removeEventListener("message",y),x(Y)):"error"===d.data.action&&U(d.data.error||"error initializing worker")};Y.addEventListener("message",y),Y.postMessage({action:"init",url:t?C.e.GetBabylonScriptURL(t):void 0,wasmBinary:d},[d])}))}(f,t,W.JSModuleURL).then(Y,d)})).catch(d)}))),o),b=(Y,d)=>{const t=Y instanceof ArrayBuffer?new Uint8Array(Y):Y;return new Promise(((Y,x)=>{D().then((()=>{const C=F++,U=d=>{"transcode"===d.data.action&&d.data.id===C&&(f.removeEventListener("message",U),d.data.success?Y(d.data):x("Transcode is not supported on this device"))};f.addEventListener("message",U);const y=new Uint8Array(t.byteLength);y.set(new Uint8Array(t.buffer,t.byteOffset,t.byteLength)),f.postMessage({action:"transcode",id:C,imageData:y,config:d,ignoreSupportedFormats:false},[y.buffer])}),(Y=>{x(Y)}))}))},m=(Y,d)=>{var t;let x=null===(t=d._gl)||void 0===t?void 0:t.TEXTURE_2D;var C;Y.isCube&&(x=null===(C=d._gl)||void 0===C?void 0:C.TEXTURE_CUBE_MAP);d._bindTextureDirectly(x,Y,!0)},M=(Y,d)=>{const t=Y.getEngine();for(let B=0;B<d.fileInfo.images.length;B++){const W=d.fileInfo.images[B].levels[0];if(Y._invertVScale=Y.invertY,-1===d.format||d.format===x.cTFRGB565)if(Y.type=10,Y.format=4,!t._features.basisNeedsPOT||Math.log2(W.width)%1===0&&Math.log2(W.height)%1===0)Y._invertVScale=!Y.invertY,Y.width=W.width+3&-4,Y.height=W.height+3&-4,Y.samplingMode=2,m(Y,t),t._uploadDataToTextureDirectly(Y,new Uint16Array(W.transcodedPixels.buffer),B,0,4,!0);else{const d=new y.c(t,2);Y._invertVScale=Y.invertY,d.type=10,d.format=4,d.width=W.width+3&-4,d.height=W.height+3&-4,m(d,t),t._uploadDataToTextureDirectly(d,new Uint16Array(W.transcodedPixels.buffer),B,0,4,!0),t._rescaleTexture(d,Y,t.scenes[0],t._getInternalFormat(4),(()=>{t._releaseTexture(d),m(Y,t)}))}else{Y.width=W.width,Y.height=W.height,Y.generateMipMaps=d.fileInfo.images[B].levels.length>1;const x=J.GetInternalFormatFromBasisFormat(d.format,t);Y.format=x,m(Y,t),d.fileInfo.images[B].levels.forEach(((d,C)=>{t._uploadCompressedDataToTextureDirectly(Y,x,d.width,d.height,d.transcodedPixels,B,C)})),!t._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0||(C.e.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Y._cachedWrapU=U.d.CLAMP_ADDRESSMODE,Y._cachedWrapV=U.d.CLAMP_ADDRESSMODE)}}},J={JSModuleURL:W.JSModuleURL,WasmModuleURL:W.WasmModuleURL,GetInternalFormatFromBasisFormat:(Y,d)=>{let t;switch(Y){case x.cTFETC1:t=36196;break;case x.cTFBC1:t=33776;break;case x.cTFBC4:t=33779;break;case x.cTFASTC_4x4:t=37808;break;case x.cTFETC2:t=37496;break;case x.cTFBC7:t=36492}if(void 0===t)throw"The chosen Basis transcoder format is not currently supported";return t},TranscodeAsync:b,LoadTextureFromTranscodeResult:M};Object.defineProperty(J,"JSModuleURL",{get:function(){return W.JSModuleURL},set:function(Y){W.JSModuleURL=Y}}),Object.defineProperty(J,"WasmModuleURL",{get:function(){return W.WasmModuleURL},set:function(Y){W.WasmModuleURL=Y}});class g{constructor(){this.supportCascades=!1}loadCubeData(Y,d,t,x,U){if(Array.isArray(Y))return;const y=d.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!y.etc1,s3tc:!!y.s3tc,pvrtc:!!y.pvrtc,etc2:!!y.etc2,astc:!!y.astc,bc7:!!y.bptc}};b(Y,B).then((Y=>{const t=Y.fileInfo.images[0].levels.length>1&&d.generateMipMaps;M(d,Y),d.getEngine()._setCubeMapTextureParams(d,t),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),x&&x()})).catch((Y=>{C.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.isReady=!0,U&&U(Y)}))}loadData(Y,d,t){const x=d.getEngine().getCaps(),U={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};b(Y,U).then((Y=>{const x=Y.fileInfo.images[0].levels[0],C=Y.fileInfo.images[0].levels.length>1&&d.generateMipMaps;t(x.width,x.height,C,-1!==Y.format,(()=>{M(d,Y)}))})).catch((Y=>{C.e.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),C.e.Warn(`Failed to transcode Basis file: ${Y}`),t(0,0,!1,!1,(()=>{}),!0)}))}}}}]);