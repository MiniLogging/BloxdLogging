"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6,7],{10237:(q,X,Q)=>{var y=Q(1516),x=Q(1039);x.c.prototype.forceSphericalPolynomialsRecompute=function(){this._texture&&(this._texture._sphericalPolynomial=null,this._texture._sphericalPolynomialPromise=null,this._texture._sphericalPolynomialComputed=!1)},Object.defineProperty(x.c.prototype,"sphericalPolynomial",{get:function(){if(this._texture){if(this._texture._sphericalPolynomial||this._texture._sphericalPolynomialComputed)return this._texture._sphericalPolynomial;if(this._texture.isReady)return this._texture._sphericalPolynomialPromise||(this._texture._sphericalPolynomialPromise=y.e.ConvertCubeMapTextureToSphericalPolynomial(this),null===this._texture._sphericalPolynomialPromise?this._texture._sphericalPolynomialComputed=!0:this._texture._sphericalPolynomialPromise.then((q=>{this._texture._sphericalPolynomial=q,this._texture._sphericalPolynomialComputed=!0}))),null}return null},set:function(q){this._texture&&(this._texture._sphericalPolynomial=q)},enumerable:!0,configurable:!0})},10244:(q,X,Q)=>{Q.r(X),Q.d(X,{Dispose:()=>f,DumpData:()=>L,DumpDataAsync:()=>R,DumpFramebuffer:()=>a,DumpTools:()=>k});var y=Q(1542),x=Q(1215),u=Q(1032),H=Q(1028);let b,D=null;async function a(q,X,Q,y){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",u=arguments.length>5?arguments[5]:void 0,H=arguments.length>6?arguments[6]:void 0;const b=await Q.readPixels(0,0,q,X);L(q,X,new Uint8Array(b.buffer),y,x,u,!0,void 0,H)}function R(q,X,Q){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"image/png",x=arguments.length>4?arguments[4]:void 0,u=arguments.length>5&&void 0!==arguments[5]&&arguments[5],H=arguments.length>6&&void 0!==arguments[6]&&arguments[6],b=arguments.length>7?arguments[7]:void 0;return new Promise((D=>{L(q,X,Q,(q=>D(q)),y,x,u,H,b)}))}function L(q,X,a,R){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"image/png",k=arguments.length>5?arguments[5]:void 0,j=arguments.length>6&&void 0!==arguments[6]&&arguments[6],I=arguments.length>7&&void 0!==arguments[7]&&arguments[7],d=arguments.length>8?arguments[8]:void 0;(async function(){return D||(D=new Promise(((q,X)=>{let x,u=null;const D={fe:!0,depth:!1,stencil:!1,alpha:!0,premultipliedAlpha:!1,antialias:!1,failIfMajorPerformanceCaveat:!1};Promise.resolve().then(Q.bind(Q,1435)).then((a=>{let{ThinEngine:R}=a;try{x=new OffscreenCanvas(100,100),u=new R(x,!1,D)}catch(k){x=document.createElement("canvas"),u=new R(x,!1,D)}H.c.Instances.pop(),H.c.OnEnginesDisposedObservable.add((q=>{u&&q!==u&&!u.u&&0===H.c.Instances.length&&f()})),u.getCaps().parallelShaderCompile=void 0;const L=new y.b(u);Q.e(32).then(Q.bind(Q,10927)).then((Q=>{let{passPixelShader:H}=Q;if(!u)return void X("Engine is not defined");const D=new y.f({od:u,name:H.name,fragmentShader:H.shader,samplerNames:["textureSampler"]});b={canvas:x,od:u,renderer:L,wrapper:D},q(b)}))})).catch(X)}))),await D})().then((Q=>{if(Q.od.setSize(q,X,!0),a instanceof Float32Array){const q=new Uint8Array(a.length);let X=a.length;for(;X--;){const Q=a[X];q[X]=Math.round(255*(0,u.d)(Q))}a=q}const y=Q.od.createRawTexture(a,q,X,5,!1,!j,1);Q.renderer.setViewport(),Q.renderer.applyEffectWrapper(Q.wrapper),Q.wrapper.effect._bindTexture("textureSampler",y),Q.renderer.draw(),I?x.f.ToBlob(Q.canvas,(q=>{const X=new FileReader;X.onload=q=>{const X=q.target.result;R&&R(X)},X.readAsArrayBuffer(q)}),L,d):x.f.EncodeScreenshotCanvasData(Q.canvas,R,L,k,d),y.dispose()}))}function f(){var q;b?(b.wrapper.dispose(),b.renderer.dispose(),b.od.dispose()):null===(q=D)||void 0===q||q.then((q=>{q.wrapper.dispose(),q.renderer.dispose(),q.od.dispose()}));D=null,b=null}const k={DumpData:L,DumpDataAsync:R,DumpFramebuffer:a,Dispose:f};x.f.DumpData=L,x.f.DumpDataAsync=R,x.f.DumpFramebuffer=a},10223:(q,X,Q)=>{Q.d(X,{e:()=>j,h:()=>e,i:()=>B,j:()=>w});var y=Q(1215),x=Q(1002),u=Q(1032),H=Q(1485),b=Q(1143),D=Q(1039),a=(Q(1206),Q(1534)),R=Q(1099);Q(10230),Q(10237),Q(10244);const L="image/png",f=2,k=[134,22,135,150,246,214,150,54];function j(q){const X=new DataView(q.buffer,q.byteOffset,q.byteLength);let Q=0;for(let H=0;H<k.length;H++)if(X.getUint8(Q++)!==k[H])return R.b.Error("Not a babylon environment map"),null;let y="",x=0;for(;x=X.getUint8(Q++);)y+=String.fromCharCode(x);let u=JSON.parse(y);return u=I(u),u.Ce&&(u.Ce.specularDataPosition=Q,u.Ce.lodGenerationScale=u.Ce.lodGenerationScale||.8),u}function I(q){if(q.version>f)throw new Error(`Unsupported babylon environment map version "${q.version}". Latest supported version is "${f}".`);return 2===q.version?q:q={...q,version:2,imageType:L}}function d(q,X){const Q=(X=I(X)).Ce;let y=Math.log2(X.width);if(y=Math.round(y)+1,Q.mipmaps.length!==6*y)throw new Error(`Unsupported specular mipmaps number "${Q.mipmaps.length}"`);const x=new Array(y);for(let u=0;u<y;u++){x[u]=new Array(6);for(let X=0;X<6;X++){const y=Q.mipmaps[6*u+X];x[u][X]=new Uint8Array(q.buffer,q.byteOffset+Q.specularDataPosition+y.position,y.length)}}return x}function e(q,X,Q){const y=(Q=I(Q)).Ce;if(!y)return Promise.resolve();q._lodGenerationScale=y.lodGenerationScale;return A(q,d(X,Q),Q.imageType)}function i(q,X,Q,y,x,u,H,b,D,a,R){return new Promise(((L,f)=>{if(Q){const Q=X.createTexture(null,!0,!0,null,1,null,(q=>{f(q)}),q);null===y||void 0===y||y.onEffectCreatedObservable.addOnce((b=>{b.executeWhenCompiled((()=>{y.externalTextureSamplerBinding=!0,y.onApply=y=>{y._bindTexture("textureSampler",Q),y.setFloat2("scale",1,X._features.needsInvertingBitmap&&q instanceof ImageBitmap?-1:1)},X.scenes.length&&(X.scenes[0].postProcessManager.directRender([y],a,!0,u,H),X.restoreDefaultFramebuffer(),Q.dispose(),URL.revokeObjectURL(x),L())}))}))}else{if(X._uploadImageToTexture(R,q,u,H),b){const Q=D[H];Q&&X._uploadImageToTexture(Q._texture,q,u,0)}L()}}))}async function A(q,X){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:L;if(!y.f.IsExponentOfTwo(q.width))throw new Error("Texture size must be a power of two");const H=(0,u.l)(q.width)+1,R=q.getEngine();let f=!1,k=!1,j=null,I=null,d=null;const e=R.getCaps();q.format=5,q.type=0,q.generateMipMaps=!0,q._cachedAnisotropicFilteringLevel=null,R.updateTextureSamplingMode(3,q),e.textureLOD?R._features.supportRenderAndCopyToLodForFloatTextures?e.textureHalfFloatRender&&e.textureHalfFloatLinearFiltering?(f=!0,q.type=2):e.textureFloatRender&&e.textureFloatLinearFiltering&&(f=!0,q.type=1):f=!1:(f=!1,k=!0,d={});let A=0;if(f)R.isWebGPU?(A=1,await Q.e(17).then(Q.bind(Q,12515))):await Q.e(24).then(Q.bind(Q,12517)),j=new a.e("rgbdDecode","rgbdDecode",null,null,1,null,3,R,!1,void 0,q.type,void 0,null,!1,void 0,A),q._isRGBD=!1,q.invertY=!1,I=R.createRenderTargetCubeTexture(q.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:q.type,format:5});else if(q._isRGBD=!0,q.invertY=!0,k){const X=3,Q=q._lodGenerationScale,y=q._lodGenerationOffset;for(let x=0;x<X;x++){const u=(H-1)*Q+y,a=y+(u-y)*(1-x/(X-1)),L=Math.round(Math.min(Math.max(a,0),u)),f=new b.c(R,2);f.isCube=!0,f.invertY=!0,f.generateMipMaps=!1,R.updateTextureSamplingMode(2,f);const k=new D.c(null);switch(k._isCube=!0,k._texture=f,d[L]=k,x){case 0:q._lodTextureLow=k;break;case 1:q._lodTextureMid=k;break;case 2:q._lodTextureHigh=k}}}const B=[];for(let Q=0;Q<X.length;Q++)for(let y=0;y<6;y++){const u=X[Q][y],H=new Blob([u],{type:x}),b=URL.createObjectURL(H);let D;if(R._features.forceBitmapOverHTMLImageElement)D=R.createImageBitmap(H,{premultiplyAlpha:"none"}).then((X=>i(X,R,f,j,b,y,Q,k,d,I,q)));else{const X=new Image;X.src=b,D=new Promise(((x,u)=>{X.onload=()=>{i(X,R,f,j,b,y,Q,k,d,I,q).then((()=>x())).catch((q=>{u(q)}))},X.onerror=q=>{u(q)}}))}B.push(D)}if(X.length<H){let Q;const y=Math.pow(2,H-1-X.length),x=y*y*4;switch(q.type){case 0:Q=new Uint8Array(x);break;case 2:Q=new Uint16Array(x);break;case 1:Q=new Float32Array(x)}for(let u=X.length;u<H;u++)for(let X=0;X<6;X++)R._uploadArrayBufferViewToTexture(q,Q,X,u)}return Promise.all(B).then((()=>{I&&(R._releaseTexture(q),I._swapAndDie(q)),j&&j.dispose(),k&&(q._lodTextureHigh&&q._lodTextureHigh._texture&&(q._lodTextureHigh._texture.isReady=!0),q._lodTextureMid&&q._lodTextureMid._texture&&(q._lodTextureMid._texture.isReady=!0),q._lodTextureLow&&q._lodTextureLow._texture&&(q._lodTextureLow._texture.isReady=!0))}))}function B(q,X){const Q=(X=I(X)).irradiance;if(!Q)return;const y=new H.d;x.n.FromArrayToRef(Q.x,0,y.x),x.n.FromArrayToRef(Q.y,0,y.y),x.n.FromArrayToRef(Q.z,0,y.z),x.n.FromArrayToRef(Q.xx,0,y.xx),x.n.FromArrayToRef(Q.yy,0,y.yy),x.n.FromArrayToRef(Q.zz,0,y.zz),x.n.FromArrayToRef(Q.yz,0,y.yz),x.n.FromArrayToRef(Q.zx,0,y.zx),x.n.FromArrayToRef(Q.xy,0,y.xy),q._sphericalPolynomial=y}function w(q,X,Q,y,x){const u=A(q.getEngine().createRawCubeTexture(null,q.width,q.format,q.type,q.generateMipMaps,q.invertY,q.samplingMode,q._compression),X).then((()=>q));return q.onRebuildCallback=q=>({proxy:u,isReady:!0,isAsync:!0}),q._source=13,q._bufferViewArrayArray=X,q._lodGenerationScale=y,q._lodGenerationOffset=x,q._sphericalPolynomial=Q,A(q,X).then((()=>(q.isReady=!0,q)))}},10230:(q,X,Q)=>{Q.d(X,{b:()=>u});var y=Q(1534),x=Q(1518);class u{static ExpandRGBDTexture(q){const X=q._texture;if(!X||!q.isRGBD)return;const x=X.getEngine(),u=x.getCaps(),H=X.isReady;let b=!1;u.textureHalfFloatRender&&u.textureHalfFloatLinearFiltering?(b=!0,X.type=2):u.textureFloatRender&&u.textureFloatLinearFiltering&&(b=!0,X.type=1),b&&(X.isReady=!1,X._isRGBD=!1,X.invertY=!1);const D=async()=>{const u=x.isWebGPU,H=u?1:0;X.isReady=!1,u?await Promise.all([Q.e(17).then(Q.bind(Q,12515)),Q.e(18).then(Q.bind(Q,12522))]):await Promise.all([Q.e(24).then(Q.bind(Q,12517)),Q.e(25).then(Q.bind(Q,12528))]);const b=new y.e("rgbdDecode","rgbdDecode",null,null,1,null,3,x,!1,void 0,X.type,void 0,null,!1,void 0,H);b.externalTextureSamplerBinding=!0;const D=x.createRenderTargetTexture(X.width,{generateDepthBuffer:!1,generateMipMaps:!1,generateStencilBuffer:!1,samplingMode:X.samplingMode,type:X.type,format:5});b.onEffectCreatedObservable.addOnce((Q=>{Q.executeWhenCompiled((()=>{b.onApply=q=>{q._bindTexture("textureSampler",X),q.setFloat2("scale",1,1)},q.va().postProcessManager.directRender([b],D,!0),x.restoreDefaultFramebuffer(),x._releaseTexture(X),b&&b.dispose(),D._swapAndDie(X),X.isReady=!0}))}))};b&&(H?D():q.onLoadObservable.addOnce(D))}static EncodeTextureToRGBD(q,X){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return(0,x.c)("rgbdEncode",q,X,Q,1,5)}}}}]);