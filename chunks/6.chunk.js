"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2356:(a,x,Q)=>{Q.r(x),Q.d(x,{_BasisTextureLoader:()=>i});var s,h=Q(496),D=Q(2315),N=Q(594);function C(){const a=0,x=1,Q=2,s=3,h=6,D=8,N=9,C=10,R=14;let U=null;function W(a,x,Q,s,h){const D=a.getImageTranscodedSizeInBytes(x,Q,s);let N=new Uint8Array(D);if(!a.transcodeImage(N,x,Q,s,1,0))return null;if(h){N=function(a,x,Q,s){const h=new Uint16Array(4),D=new Uint16Array(Q*s),N=Q/4,C=s/4;for(let R=0;R<C;R++)for(let s=0;s<N;s++){const C=x+8*(R*N+s);h[0]=a[C]|a[C+1]<<8,h[1]=a[C+2]|a[C+3]<<8,h[2]=(2*(31&h[0])+1*(31&h[1]))/3|(2*(2016&h[0])+1*(2016&h[1]))/3&2016|(2*(63488&h[0])+1*(63488&h[1]))/3&63488,h[3]=(2*(31&h[1])+1*(31&h[0]))/3|(2*(2016&h[1])+1*(2016&h[0]))/3&2016|(2*(63488&h[1])+1*(63488&h[0]))/3&63488;for(let x=0;x<4;x++){const N=a[C+4+x];let U=(4*R+x)*Q+4*s;D[U++]=h[3&N],D[U++]=h[N>>2&3],D[U++]=h[N>>4&3],D[U++]=h[N>>6&3]}}return D}(N,0,a.getImageWidth(x,Q)+3&-4,a.getImageHeight(x,Q)+3&-4)}return N}onmessage=v=>{if("init"===v.data.action){if(v.data.url)try{importScripts(v.data.url)}catch(e){postMessage({action:"error",error:e})}U||(U=BASIS({wasmBinary:v.data.wasmBinary})),null!==U&&U.then((a=>{BASIS=a,a.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===v.data.action){const U=v.data.config,e=v.data.imageData,p=new BASIS.BasisFile(e),j=function(a){const x=a.getHasAlpha(),Q=a.getNumImages(),s=[];for(let h=0;h<Q;h++){const x={levels:[]},Q=a.getNumLevels(h);for(let s=0;s<Q;s++){const Q={width:a.getImageWidth(h,s),height:a.getImageHeight(h,s)};x.levels.push(Q)}s.push(x)}return{Aj:x,images:s}}(p);let H=v.data.ignoreSupportedFormats?null:function(U,W){let v=null;U.supportedCompressionFormats&&(v=U.supportedCompressionFormats.astc?C:U.supportedCompressionFormats.bc7?h:U.supportedCompressionFormats.s3tc?W.Aj?s:Q:U.supportedCompressionFormats.pvrtc?W.Aj?N:D:U.supportedCompressionFormats.etc2?x:U.supportedCompressionFormats.etc1?a:R);return v}(v.data.config,j),d=!1;null===H&&(d=!0,H=j.Aj?s:Q);let i=!0;p.startTranscoding()||(i=!1);const Z=[];for(let a=0;a<j.images.length&&i;a++){const x=j.images[a];if(void 0===U.loadSingleImage||U.loadSingleImage===a){let Q=x.levels.length;!1===U.loadMipmapLevels&&(Q=1);for(let s=0;s<Q;s++){const Q=x.levels[s],h=W(p,a,s,H,d);if(!h){i=!1;break}Q.transcodedPixels=h,Z.push(Q.transcodedPixels.buffer)}}}p.close(),p.delete(),d&&(H=-1),i?postMessage({action:"transcode",success:i,id:v.data.id,fileInfo:j,format:H},Z):postMessage({action:"transcode",success:i,id:v.data.id})}}}!function(a){a[a.cTFETC1=0]="cTFETC1",a[a.cTFETC2=1]="cTFETC2",a[a.cTFBC1=2]="cTFBC1",a[a.cTFBC3=3]="cTFBC3",a[a.cTFBC4=4]="cTFBC4",a[a.cTFBC5=5]="cTFBC5",a[a.cTFBC7=6]="cTFBC7",a[a.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",a[a.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",a[a.cTFASTC_4x4=10]="cTFASTC_4x4",a[a.cTFATC_RGB=11]="cTFATC_RGB",a[a.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",a[a.cTFRGBA32=13]="cTFRGBA32",a[a.cTFRGB565=14]="cTFRGB565",a[a.cTFBGR565=15]="cTFBGR565",a[a.cTFRGBA4444=16]="cTFRGBA4444",a[a.cTFFXT1_RGB=17]="cTFFXT1_RGB",a[a.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",a[a.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",a[a.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",a[a.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(s||(s={}));const R={JSModuleURL:`${h.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${h.g._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let U=null,W=null,v=0;const e=()=>(U||(U=new Promise(((a,x)=>{W?a(W):h.g.LoadFileAsync(h.g.GetBabylonScriptURL(R.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return x("Basis transcoder requires an environment with a URL constructor");const s=URL.createObjectURL(new Blob([`(${C})()`],{type:"application/javascript"}));W=new Worker(s),function(a,x,Q){return new Promise(((s,D)=>{const N=x=>{"init"===x.data.action?(a.removeEventListener("message",N),s(a)):"error"===x.data.action&&D(x.data.error||"error initializing worker")};a.addEventListener("message",N),a.postMessage({action:"init",url:Q?h.g.GetBabylonScriptURL(Q):void 0,wasmBinary:x},[x])}))}(W,Q,R.JSModuleURL).then(a,x)})).catch(x)}))),U),p=(a,x)=>{const Q=a instanceof ArrayBuffer?new Uint8Array(a):a;return new Promise(((a,s)=>{e().then((()=>{const h=v++,D=x=>{"transcode"===x.data.action&&x.data.id===h&&(W.removeEventListener("message",D),x.data.success?a(x.data):s("Transcode is not supported on this device"))};W.addEventListener("message",D);const N=new Uint8Array(Q.byteLength);N.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),W.postMessage({action:"transcode",id:h,imageData:N,config:x,ignoreSupportedFormats:false},[N.buffer])}),(a=>{s(a)}))}))},j=(a,x)=>{var Q;let s=null===(Q=x._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var h;a.isCube&&(s=null===(h=x._gl)||void 0===h?void 0:h.TEXTURE_CUBE_MAP);x._bindTextureDirectly(s,a,!0)},H=(a,x)=>{const Q=a.getEngine();for(let C=0;C<x.fileInfo.images.length;C++){const R=x.fileInfo.images[C].levels[0];if(a._invertVScale=a.invertY,-1===x.format||x.format===s.cTFRGB565)if(a.type=10,a.format=4,!Q._features.basisNeedsPOT||Math.log2(R.width)%1===0&&Math.log2(R.height)%1===0)a._invertVScale=!a.invertY,a.width=R.width+3&-4,a.height=R.height+3&-4,a.samplingMode=2,j(a,Q),Q._uploadDataToTextureDirectly(a,new Uint16Array(R.transcodedPixels.buffer),C,0,4,!0);else{const x=new N.c(Q,2);a._invertVScale=a.invertY,x.type=10,x.format=4,x.width=R.width+3&-4,x.height=R.height+3&-4,j(x,Q),Q._uploadDataToTextureDirectly(x,new Uint16Array(R.transcodedPixels.buffer),C,0,4,!0),Q._rescaleTexture(x,a,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(x),j(a,Q)}))}else{a.width=R.width,a.height=R.height,a.generateMipMaps=x.fileInfo.images[C].levels.length>1;const s=d.GetInternalFormatFromBasisFormat(x.format,Q);a.format=s,j(a,Q),x.fileInfo.images[C].levels.forEach(((x,h)=>{Q._uploadCompressedDataToTextureDirectly(a,s,x.width,x.height,x.transcodedPixels,C,h)})),!Q._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0||(h.g.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),a._cachedWrapU=D.e.CLAMP_ADDRESSMODE,a._cachedWrapV=D.e.CLAMP_ADDRESSMODE)}}},d={JSModuleURL:R.JSModuleURL,WasmModuleURL:R.WasmModuleURL,GetInternalFormatFromBasisFormat:(a,x)=>{let Q;switch(a){case s.cTFETC1:Q=36196;break;case s.cTFBC1:Q=33776;break;case s.cTFBC4:Q=33779;break;case s.cTFASTC_4x4:Q=37808;break;case s.cTFETC2:Q=37496;break;case s.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:p,LoadTextureFromTranscodeResult:H};Object.defineProperty(d,"JSModuleURL",{get:function(){return R.JSModuleURL},set:function(a){R.JSModuleURL=a}}),Object.defineProperty(d,"WasmModuleURL",{get:function(){return R.WasmModuleURL},set:function(a){R.WasmModuleURL=a}});class i{constructor(){this.supportCascades=!1}loadCubeData(a,x,Q,s,D){if(Array.isArray(a))return;const N=x.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};p(a,C).then((a=>{const Q=a.fileInfo.images[0].levels.length>1&&x.generateMipMaps;H(x,a),x.getEngine()._setCubeMapTextureParams(x,Q),x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),s&&s()})).catch((a=>{h.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.isReady=!0,D&&D(a)}))}loadData(a,x,Q){const s=x.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!s.etc1,s3tc:!!s.s3tc,pvrtc:!!s.pvrtc,etc2:!!s.etc2,astc:!!s.astc,bc7:!!s.bptc}};p(a,D).then((a=>{const s=a.fileInfo.images[0].levels[0],h=a.fileInfo.images[0].levels.length>1&&x.generateMipMaps;Q(s.width,s.height,h,-1!==a.format,(()=>{H(x,a)}))})).catch((a=>{h.g.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.g.Warn(`Failed to transcode Basis file: ${a}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);