"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2508:(Q,X,C)=>{var l=C(594),h=C(501),M=C(526),f=C(627),O=C(554),m=C(608);O.e.prototype._partialLoadFile=function(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(Q,(Q=>{C[X]=Q,C._internalCount++,6===C._internalCount&&l(C)}),void 0,void 0,!0,((Q,X)=>{h&&Q&&h(Q.status+" "+Q.statusText,X)}))},O.e.prototype._cascadeLoadFiles=function(Q,X,C){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const h=[];h._internalCount=0;for(let M=0;M<6;M++)this._partialLoadFile(C[M],M,h,X,l)},O.e.prototype._cascadeLoadImgs=function(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,M=arguments.length>5?arguments[5]:void 0;const f=[];f._internalCount=0;for(let O=0;O<6;O++)this._partialLoadImg(l[O],O,f,Q,X,C,h,M)},O.e.prototype._partialLoadImg=function(Q,X,C,l,h,O){let m=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,W=arguments.length>7?arguments[7]:void 0;const U=(0,f.d)();(0,M.s)(Q,(Q=>{C[X]=Q,C._internalCount++,l&&l.removePendingData(U),6===C._internalCount&&O&&O(h,C)}),((Q,X)=>{l&&l.removePendingData(U),m&&m(Q,X)}),l?l.offlineProvider:null,W),l&&l.addPendingData(U)},O.e.prototype.createCubeTextureBase=function(Q,X,C,M){let f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,W=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,L=arguments.length>8&&void 0!==arguments[8]&&arguments[8],w=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,i=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,a=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,F=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,s=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,z=arguments.length>14&&void 0!==arguments[14]&&arguments[14],x=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const r=a||new l.d(this,7);r.isCube=!0,r.url=Q,r.generateMipMaps=!M,r._lodGenerationScale=w,r._lodGenerationOffset=i,r._useSRGBBuffer=!!z&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!M),r!==a&&(r.label=Q.substring(0,60)),this._doNotHandleContextLost||(r._extension=U,r._files=C,r._buffer=x);const P=Q;this._transformTextureUrl&&!a&&(Q=this._transformTextureUrl(Q));const j=U??function(Q){const X=Q.split("?")[0],C=X.lastIndexOf(".");return C>-1?X.substring(C).toLowerCase():""}(Q),v=(0,m.e)(j),Z=(Q,X)=>{r.dispose(),O?O(Q,X):Q&&h.c.Warn(Q)},g=(l,O)=>{Q===P?l&&Z(l.status+" "+l.statusText,O):(h.c.Warn(`Failed to load ${Q}, falling back to the ${P}`),this.createCubeTextureBase(P,X,C,!!M,f,Z,W,U,L,w,i,r,F,s,z,x))};if(v)v.then((l=>{const h=Q=>{F&&F(r,Q),l.loadCubeData(Q,r,L,f,((Q,X)=>{Z(Q,X)}))};x?h(x):C&&6===C.length?l.supportCascades?this._cascadeLoadFiles(X,(Q=>h(Q.map((Q=>new Uint8Array(Q))))),C,Z):Z("Textures type does not support cascades."):this._loadFile(Q,(Q=>h(new Uint8Array(Q))),void 0,void 0,!0,g)}));else{if(!C||0===C.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(X,r,((Q,X)=>{s&&s(Q,X)}),C,Z)}return this._internalTexturesCache.push(r),r}},2380:(Q,X,C)=>{C.d(X,{DDSTools:()=>a});var l=C(690),h=C(501),M=C(2388),f=C(2394);C(2508);const O=131072,m=131072;function W(Q){return Q.charCodeAt(0)+(Q.charCodeAt(1)<<8)+(Q.charCodeAt(2)<<16)+(Q.charCodeAt(3)<<24)}const U=W("DXT1"),L=W("DXT3"),w=W("DXT5"),i=W("DX10");class a{static GetDDSInfo(Q){const X=new Int32Array(Q.buffer,Q.byteOffset,31),C=new Int32Array(Q.buffer,Q.byteOffset,35);let l=1;X[2]&O&&(l=Math.max(1,X[7]));const h=X[21],M=h===i?C[32]:0;let f=0;switch(h){case 113:f=2;break;case 116:f=1;break;case i:if(10===M){f=2;break}if(2===M){f=1;break}}return{width:X[4],height:X[3],mipmapCount:l,isFourCC:4===(4&X[20]),isRGB:64===(64&X[20]),isLuminance:(X[20]&m)===m,isCube:512===(512&X[28]),isCompressed:h===U||h===L||h===w,dxgiFormat:M,textureType:f}}static _GetHalfFloatAsFloatRGBAArrayBuffer(Q,X,C,l,h,M){const O=new Float32Array(l),m=new Uint16Array(h,C);let W=0;for(let U=0;U<X;U++)for(let X=0;X<Q;X++){const C=4*(X+U*Q);O[W]=(0,f.e)(m[C]),O[W+1]=(0,f.e)(m[C+1]),O[W+2]=(0,f.e)(m[C+2]),a.StoreLODInAlphaChannel?O[W+3]=M:O[W+3]=(0,f.e)(m[C+3]),W+=4}return O}static _GetHalfFloatRGBAArrayBuffer(Q,X,C,l,h,M){if(a.StoreLODInAlphaChannel){const O=new Uint16Array(l),m=new Uint16Array(h,C);let W=0;for(let C=0;C<X;C++)for(let X=0;X<Q;X++){const l=4*(X+C*Q);O[W]=m[l],O[W+1]=m[l+1],O[W+2]=m[l+2],O[W+3]=(0,f.l)(M),W+=4}return O}return new Uint16Array(h,C,l)}static _GetFloatRGBAArrayBuffer(Q,X,C,l,h,M){if(a.StoreLODInAlphaChannel){const f=new Float32Array(l),O=new Float32Array(h,C);let m=0;for(let C=0;C<X;C++)for(let X=0;X<Q;X++){const l=4*(X+C*Q);f[m]=O[l],f[m+1]=O[l+1],f[m+2]=O[l+2],f[m+3]=M,m+=4}return f}return new Float32Array(h,C,l)}static _GetFloatAsHalfFloatRGBAArrayBuffer(Q,X,C,l,h,M){const O=new Uint16Array(l),m=new Float32Array(h,C);let W=0;for(let U=0;U<X;U++)for(let X=0;X<Q;X++)O[W]=(0,f.l)(m[W]),O[W+1]=(0,f.l)(m[W+1]),O[W+2]=(0,f.l)(m[W+2]),a.StoreLODInAlphaChannel?O[W+3]=(0,f.l)(M):O[W+3]=(0,f.l)(m[W+3]),W+=4;return O}static _GetFloatAsUIntRGBAArrayBuffer(Q,X,C,h,M,f){const O=new Uint8Array(h),m=new Float32Array(M,C);let W=0;for(let U=0;U<X;U++)for(let X=0;X<Q;X++){const C=4*(X+U*Q);O[W]=255*(0,l.Clamp)(m[C]),O[W+1]=255*(0,l.Clamp)(m[C+1]),O[W+2]=255*(0,l.Clamp)(m[C+2]),a.StoreLODInAlphaChannel?O[W+3]=f:O[W+3]=255*(0,l.Clamp)(m[C+3]),W+=4}return O}static _GetHalfFloatAsUIntRGBAArrayBuffer(Q,X,C,h,M,O){const m=new Uint8Array(h),W=new Uint16Array(M,C);let U=0;for(let L=0;L<X;L++)for(let X=0;X<Q;X++){const C=4*(X+L*Q);m[U]=255*(0,l.Clamp)((0,f.e)(W[C])),m[U+1]=255*(0,l.Clamp)((0,f.e)(W[C+1])),m[U+2]=255*(0,l.Clamp)((0,f.e)(W[C+2])),a.StoreLODInAlphaChannel?m[U+3]=O:m[U+3]=255*(0,l.Clamp)((0,f.e)(W[C+3])),U+=4}return m}static _GetRGBAArrayBuffer(Q,X,C,l,h,M,f,O,m){const W=new Uint8Array(l),U=new Uint8Array(h,C);let L=0;for(let w=0;w<X;w++)for(let X=0;X<Q;X++){const C=4*(X+w*Q);W[L]=U[C+M],W[L+1]=U[C+f],W[L+2]=U[C+O],W[L+3]=U[C+m],L+=4}return W}static _ExtractLongWordOrder(Q){return 0===Q||255===Q||-16777216===Q?0:1+a._ExtractLongWordOrder(Q>>8)}static _GetRGBArrayBuffer(Q,X,C,l,h,M,f,O){const m=new Uint8Array(l),W=new Uint8Array(h,C);let U=0;for(let L=0;L<X;L++)for(let X=0;X<Q;X++){const C=3*(X+L*Q);m[U]=W[C+M],m[U+1]=W[C+f],m[U+2]=W[C+O],U+=3}return m}static _GetLuminanceArrayBuffer(Q,X,C,l,h){const M=new Uint8Array(l),f=new Uint8Array(h,C);let O=0;for(let m=0;m<X;m++)for(let X=0;X<Q;X++){const C=X+m*Q;M[O]=f[C],O++}return M}static UploadDDSLevels(Q,X,C,l,f,m){let W=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,F=arguments.length>7?arguments[7]:void 0,s=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],z=null;l.sphericalPolynomial&&(z=[]);const x=!!Q.getCaps().s3tc;X.generateMipMaps=f;const r=new Int32Array(C.buffer,C.byteOffset,31);let P,j,v,Z,g,S,e,k=0,R=0,H=1;if(542327876!==r[0])return void h.c.Error("Invalid magic number in DDS header");if(!l.isFourCC&&!l.isRGB&&!l.isLuminance)return void h.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(l.isCompressed&&!x)return void h.c.Error("Compressed textures are not supported on this platform.");let o=r[22];Z=r[1]+4;let T=!1;if(l.isFourCC)switch(P=r[21],P){case U:H=8,R=33777;break;case L:H=16,R=33778;break;case w:H=16,R=33779;break;case 113:T=!0,o=64;break;case 116:T=!0,o=128;break;case i:{Z+=20;let Q=!1;switch(l.dxgiFormat){case 10:T=!0,o=64,Q=!0;break;case 2:T=!0,o=128,Q=!0;break;case 88:l.isRGB=!0,l.isFourCC=!1,o=32,Q=!0}if(Q)break}default:return void h.c.Error(["Unsupported FourCC code:",(Y=P,String.fromCharCode(255&Y,Y>>8&255,Y>>16&255,Y>>24&255))])}var Y;const J=a._ExtractLongWordOrder(r[23]),K=a._ExtractLongWordOrder(r[24]),N=a._ExtractLongWordOrder(r[25]),q=a._ExtractLongWordOrder(r[26]);T&&(R=Q._getRGBABufferInternalSizedFormat(l.textureType)),S=1,r[2]&O&&!1!==f&&(S=Math.max(1,r[7]));const n=F||0,c=Q.getCaps();for(let h=n;h<m;h++){for(j=r[4],v=r[3],e=0;e<S;++e){if(-1===W||W===e){const M=-1===W?e:0;if(!l.isCompressed&&l.isFourCC){X.format=5,k=j*v*4;let l=null;if(Q._badOS||Q._badDesktopOS||!c.textureHalfFloat&&!c.textureFloat)128===o?(l=a._GetFloatAsUIntRGBAArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,M),z&&0==M&&z.push(a._GetFloatRGBAArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,M))):64===o&&(l=a._GetHalfFloatAsUIntRGBAArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,M),z&&0==M&&z.push(a._GetHalfFloatAsFloatRGBAArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,M))),X.type=0;else{const Q=c.textureFloat&&(s&&c.textureFloatLinearFiltering||!s),h=c.textureHalfFloat&&(s&&c.textureHalfFloatLinearFiltering||!s),f=(128===o||64===o&&!h)&&Q?1:(64===o||128===o&&!Q)&&h?2:0;let O,m=null;if(128===o)switch(f){case 1:O=a._GetFloatRGBAArrayBuffer,m=null;break;case 2:O=a._GetFloatAsHalfFloatRGBAArrayBuffer,m=a._GetFloatRGBAArrayBuffer;break;case 0:O=a._GetFloatAsUIntRGBAArrayBuffer,m=a._GetFloatRGBAArrayBuffer}else switch(f){case 1:O=a._GetHalfFloatAsFloatRGBAArrayBuffer,m=null;break;case 2:O=a._GetHalfFloatRGBAArrayBuffer,m=a._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:O=a._GetHalfFloatAsUIntRGBAArrayBuffer,m=a._GetHalfFloatAsFloatRGBAArrayBuffer}X.type=f,l=O(j,v,C.byteOffset+Z,k,C.buffer,M),z&&0==M&&z.push(m?m(j,v,C.byteOffset+Z,k,C.buffer,M):l)}l&&Q._uploadDataToTextureDirectly(X,l,h,M)}else if(l.isRGB)X.type=0,24===o?(X.format=4,k=j*v*3,g=a._GetRGBArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,J,K,N),Q._uploadDataToTextureDirectly(X,g,h,M)):(X.format=5,k=j*v*4,g=a._GetRGBAArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer,J,K,N,q),Q._uploadDataToTextureDirectly(X,g,h,M));else if(l.isLuminance){const l=Q._getUnpackAlignement(),f=j;k=Math.floor((j+l-1)/l)*l*(v-1)+f,g=a._GetLuminanceArrayBuffer(j,v,C.byteOffset+Z,k,C.buffer),X.format=1,X.type=0,Q._uploadDataToTextureDirectly(X,g,h,M)}else k=Math.max(4,j)/4*Math.max(4,v)/4*H,g=new Uint8Array(C.buffer,C.byteOffset+Z,k),X.type=0,Q._uploadCompressedDataToTextureDirectly(X,R,j,v,g,h,M)}Z+=o?j*v*(o/8):k,j*=.5,v*=.5,j=Math.max(1,j),v=Math.max(1,v)}if(void 0!==F)break}z&&z.length>0?l.sphericalPolynomial=M.e.ConvertCubeMapToSphericalPolynomial({size:r[4],right:z[0],left:z[1],up:z[2],down:z[3],front:z[4],back:z[5],format:5,type:1,gammaSpace:!1}):l.sphericalPolynomial=void 0}}a.StoreLODInAlphaChannel=!1}}]);