"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2081:(j,H,s)=>{s.r(H),s.d(H,{_BasisTextureLoader:()=>J});var i,B=s(504),e=s(2030),k=s(616);function V(){const j=0,H=1,s=2,i=3,B=6,e=8,k=9,V=10,C=14;let L=null;function U(j,H,s,i,B){const e=j.getImageTranscodedSizeInBytes(H,s,i);let k=new Uint8Array(e);if(!j.transcodeImage(k,H,s,i,1,0))return null;if(B){k=function(j,H,s,i){const B=new Uint16Array(4),e=new Uint16Array(s*i),k=s/4,V=i/4;for(let C=0;C<V;C++)for(let i=0;i<k;i++){const V=H+8*(C*k+i);B[0]=j[V]|j[V+1]<<8,B[1]=j[V+2]|j[V+3]<<8,B[2]=(2*(31&B[0])+1*(31&B[1]))/3|(2*(2016&B[0])+1*(2016&B[1]))/3&2016|(2*(63488&B[0])+1*(63488&B[1]))/3&63488,B[3]=(2*(31&B[1])+1*(31&B[0]))/3|(2*(2016&B[1])+1*(2016&B[0]))/3&2016|(2*(63488&B[1])+1*(63488&B[0]))/3&63488;for(let H=0;H<4;H++){const k=j[V+4+H];let L=(4*C+H)*s+4*i;e[L++]=B[3&k],e[L++]=B[k>>2&3],e[L++]=B[k>>4&3],e[L++]=B[k>>6&3]}}return e}(k,0,j.getImageWidth(H,s)+3&-4,j.getImageHeight(H,s)+3&-4)}return k}onmessage=x=>{if("init"===x.data.action){if(x.data.url)try{importScripts(x.data.url)}catch(p){postMessage({action:"error",error:p})}L||(L=BASIS({wasmBinary:x.data.wasmBinary})),null!==L&&L.then((j=>{BASIS=j,j.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===x.data.action){const L=x.data.config,p=x.data.imageData,a=new BASIS.BasisFile(p),E=function(j){const H=j.getHasAlpha(),s=j.getNumImages(),i=[];for(let B=0;B<s;B++){const H={levels:[]},s=j.getNumLevels(B);for(let i=0;i<s;i++){const s={width:j.getImageWidth(B,i),height:j.getImageHeight(B,i)};H.levels.push(s)}i.push(H)}return{qi:H,images:i}}(a);let r=x.data.ignoreSupportedFormats?null:function(L,U){let x=null;L.supportedCompressionFormats&&(x=L.supportedCompressionFormats.astc?V:L.supportedCompressionFormats.bc7?B:L.supportedCompressionFormats.s3tc?U.qi?i:s:L.supportedCompressionFormats.pvrtc?U.qi?k:e:L.supportedCompressionFormats.etc2?H:L.supportedCompressionFormats.etc1?j:C);return x}(x.data.config,E),q=!1;null===r&&(q=!0,r=E.qi?i:s);let J=!0;a.startTranscoding()||(J=!1);const h=[];for(let j=0;j<E.images.length&&J;j++){const H=E.images[j];if(void 0===L.loadSingleImage||L.loadSingleImage===j){let s=H.levels.length;!1===L.loadMipmapLevels&&(s=1);for(let i=0;i<s;i++){const s=H.levels[i],B=U(a,j,i,r,q);if(!B){J=!1;break}s.transcodedPixels=B,h.push(s.transcodedPixels.buffer)}}}a.close(),a.delete(),q&&(r=-1),J?postMessage({action:"transcode",success:J,id:x.data.id,fileInfo:E,format:r},h):postMessage({action:"transcode",success:J,id:x.data.id})}}}!function(j){j[j.cTFETC1=0]="cTFETC1",j[j.cTFETC2=1]="cTFETC2",j[j.cTFBC1=2]="cTFBC1",j[j.cTFBC3=3]="cTFBC3",j[j.cTFBC4=4]="cTFBC4",j[j.cTFBC5=5]="cTFBC5",j[j.cTFBC7=6]="cTFBC7",j[j.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",j[j.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",j[j.cTFASTC_4x4=10]="cTFASTC_4x4",j[j.cTFATC_RGB=11]="cTFATC_RGB",j[j.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",j[j.cTFRGBA32=13]="cTFRGBA32",j[j.cTFRGB565=14]="cTFRGB565",j[j.cTFBGR565=15]="cTFBGR565",j[j.cTFRGBA4444=16]="cTFRGBA4444",j[j.cTFFXT1_RGB=17]="cTFFXT1_RGB",j[j.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",j[j.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",j[j.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",j[j.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(i||(i={}));const C={JSModuleURL:`${B.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${B.f._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let L=null,U=null,x=0;const p=()=>(L||(L=new Promise(((j,H)=>{U?j(U):B.f.LoadFileAsync(B.f.GetBabylonScriptURL(C.WasmModuleURL)).then((s=>{if("function"!==typeof URL)return H("Basis transcoder requires an environment with a URL constructor");const i=URL.createObjectURL(new Blob([`(${V})()`],{type:"application/javascript"}));U=new Worker(i),function(j,H,s){return new Promise(((i,e)=>{const k=H=>{"init"===H.data.action?(j.removeEventListener("message",k),i(j)):"error"===H.data.action&&e(H.data.error||"error initializing worker")};j.addEventListener("message",k),j.postMessage({action:"init",url:s?B.f.GetBabylonScriptURL(s):void 0,wasmBinary:H},[H])}))}(U,s,C.JSModuleURL).then(j,H)})).catch(H)}))),L),a=(j,H)=>{const s=j instanceof ArrayBuffer?new Uint8Array(j):j;return new Promise(((j,i)=>{p().then((()=>{const B=x++,e=H=>{"transcode"===H.data.action&&H.data.id===B&&(U.removeEventListener("message",e),H.data.success?j(H.data):i("Transcode is not supported on this device"))};U.addEventListener("message",e);const k=new Uint8Array(s.byteLength);k.set(new Uint8Array(s.buffer,s.byteOffset,s.byteLength)),U.postMessage({action:"transcode",id:B,imageData:k,config:H,ignoreSupportedFormats:false},[k.buffer])}),(j=>{i(j)}))}))},E=(j,H)=>{var s;let i=null===(s=H._gl)||void 0===s?void 0:s.TEXTURE_2D;var B;j.isCube&&(i=null===(B=H._gl)||void 0===B?void 0:B.TEXTURE_CUBE_MAP);H._bindTextureDirectly(i,j,!0)},r=(j,H)=>{const s=j.getEngine();for(let V=0;V<H.fileInfo.images.length;V++){const C=H.fileInfo.images[V].levels[0];if(j._invertVScale=j.invertY,-1===H.format||H.format===i.cTFRGB565)if(j.type=10,j.format=4,!s._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)j._invertVScale=!j.invertY,j.width=C.width+3&-4,j.height=C.height+3&-4,j.samplingMode=2,E(j,s),s._uploadDataToTextureDirectly(j,new Uint16Array(C.transcodedPixels.buffer),V,0,4,!0);else{const H=new k.e(s,2);j._invertVScale=j.invertY,H.type=10,H.format=4,H.width=C.width+3&-4,H.height=C.height+3&-4,E(H,s),s._uploadDataToTextureDirectly(H,new Uint16Array(C.transcodedPixels.buffer),V,0,4,!0),s._rescaleTexture(H,j,s.scenes[0],s._getInternalFormat(4),(()=>{s._releaseTexture(H),E(j,s)}))}else{j.width=C.width,j.height=C.height,j.generateMipMaps=H.fileInfo.images[V].levels.length>1;const i=q.GetInternalFormatFromBasisFormat(H.format,s);j.format=i,E(j,s),H.fileInfo.images[V].levels.forEach(((H,B)=>{s._uploadCompressedDataToTextureDirectly(j,i,H.width,H.height,H.transcodedPixels,V,B)})),!s._features.basisNeedsPOT||Math.log2(j.width)%1===0&&Math.log2(j.height)%1===0||(B.f.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),j._cachedWrapU=e.b.CLAMP_ADDRESSMODE,j._cachedWrapV=e.b.CLAMP_ADDRESSMODE)}}},q={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(j,H)=>{let s;switch(j){case i.cTFETC1:s=36196;break;case i.cTFBC1:s=33776;break;case i.cTFBC4:s=33779;break;case i.cTFASTC_4x4:s=37808;break;case i.cTFETC2:s=37496;break;case i.cTFBC7:s=36492}if(void 0===s)throw"The chosen Basis transcoder format is not currently supported";return s},TranscodeAsync:a,LoadTextureFromTranscodeResult:r};Object.defineProperty(q,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(j){C.JSModuleURL=j}}),Object.defineProperty(q,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(j){C.WasmModuleURL=j}});class J{constructor(){this.supportCascades=!1}loadCubeData(j,H,s,i,e){if(Array.isArray(j))return;const k=H.getEngine().getCaps(),V={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};a(j,V).then((j=>{const s=j.fileInfo.images[0].levels.length>1&&H.generateMipMaps;r(H,j),H.getEngine()._setCubeMapTextureParams(H,s),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),i&&i()})).catch((j=>{B.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),H.isReady=!0,e&&e(j)}))}loadData(j,H,s){const i=H.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!i.etc1,s3tc:!!i.s3tc,pvrtc:!!i.pvrtc,etc2:!!i.etc2,astc:!!i.astc,bc7:!!i.bptc}};a(j,e).then((j=>{const i=j.fileInfo.images[0].levels[0],B=j.fileInfo.images[0].levels.length>1&&H.generateMipMaps;s(i.width,i.height,B,-1!==j.format,(()=>{r(H,j)}))})).catch((j=>{B.f.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),B.f.Warn(`Failed to transcode Basis file: ${j}`),s(0,0,!1,!1,(()=>{}),!0)}))}}}}]);