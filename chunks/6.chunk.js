"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[6],{2419:(R,x,H)=>{var k=H(590),c=H(493),t=H(517),A=H(612),D=H(555),U=H(598);D.d.prototype._partialLoadFile=function(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(R,(R=>{H[x]=R,H._internalCount++,6===H._internalCount&&k(H)}),void 0,void 0,!0,((R,x)=>{c&&R&&c(R.status+" "+R.statusText,x)}))},D.d.prototype._cascadeLoadFiles=function(R,x,H){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const c=[];c._internalCount=0;for(let t=0;t<6;t++)this._partialLoadFile(H[t],t,c,x,k)},D.d.prototype._cascadeLoadImgs=function(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,t=arguments.length>5?arguments[5]:void 0;const A=[];A._internalCount=0;for(let D=0;D<6;D++)this._partialLoadImg(k[D],D,A,R,x,H,c,t)},D.d.prototype._partialLoadImg=function(R,x,H,k,c,D){let U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,J=arguments.length>7?arguments[7]:void 0;const V=(0,A.e)();(0,t.u)(R,(R=>{H[x]=R,H._internalCount++,k&&k.removePendingData(V),6===H._internalCount&&D&&D(c,H)}),((R,x)=>{k&&k.removePendingData(V),U&&U(R,x)}),k?k.offlineProvider:null,J),k&&k.addPendingData(V)},D.d.prototype.createCubeTextureBase=function(R,x,H,t){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,D=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,J=arguments.length>6?arguments[6]:void 0,V=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,n=arguments.length>8&&void 0!==arguments[8]&&arguments[8],g=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,I=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,i=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,q=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,S=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,L=arguments.length>14&&void 0!==arguments[14]&&arguments[14],b=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const C=i||new k.b(this,7);C.isCube=!0,C.url=R,C.generateMipMaps=!t,C._lodGenerationScale=g,C._lodGenerationOffset=I,C._useSRGBBuffer=!!L&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!t),C!==i&&(C.label=R.substring(0,60)),this._doNotHandleContextLost||(C._extension=V,C._files=H,C._buffer=b);const F=R;this._transformTextureUrl&&!i&&(R=this._transformTextureUrl(R));const d=V??function(R){const x=R.split("?")[0],H=x.lastIndexOf(".");return H>-1?x.substring(H).toLowerCase():""}(R),P=(0,U.d)(d),a=(R,x)=>{C.dispose(),D?D(R,x):R&&c.c.Warn(R)},X=(k,D)=>{R===F?k&&a(k.status+" "+k.statusText,D):(c.c.Warn(`Failed to load ${R}, falling back to the ${F}`),this.createCubeTextureBase(F,x,H,!!t,A,a,J,V,n,g,I,C,q,S,L,b))};if(P)P.then((k=>{const c=R=>{q&&q(C,R),k.loadCubeData(R,C,n,A,((R,x)=>{a(R,x)}))};b?c(b):H&&6===H.length?k.supportCascades?this._cascadeLoadFiles(x,(R=>c(R.map((R=>new Uint8Array(R))))),H,a):a("Textures type does not support cascades."):this._loadFile(R,(R=>c(new Uint8Array(R))),void 0,void 0,!0,X)}));else{if(!H||0===H.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(x,C,((R,x)=>{S&&S(R,x)}),H,a)}return this._internalTexturesCache.push(C),C}},2294:(R,x,H)=>{H.d(x,{DDSTools:()=>i});var k=H(681),c=H(493),t=H(2297),A=H(2306);H(2419);const D=131072,U=131072;function J(R){return R.charCodeAt(0)+(R.charCodeAt(1)<<8)+(R.charCodeAt(2)<<16)+(R.charCodeAt(3)<<24)}const V=J("DXT1"),n=J("DXT3"),g=J("DXT5"),I=J("DX10");class i{static GetDDSInfo(R){const x=new Int32Array(R.buffer,R.byteOffset,31),H=new Int32Array(R.buffer,R.byteOffset,35);let k=1;x[2]&D&&(k=Math.max(1,x[7]));const c=x[21],t=c===I?H[32]:0;let A=0;switch(c){case 113:A=2;break;case 116:A=1;break;case I:if(10===t){A=2;break}if(2===t){A=1;break}}return{width:x[4],height:x[3],mipmapCount:k,isFourCC:4===(4&x[20]),isRGB:64===(64&x[20]),isLuminance:(x[20]&U)===U,isCube:512===(512&x[28]),isCompressed:c===V||c===n||c===g,dxgiFormat:t,textureType:A}}static _GetHalfFloatAsFloatRGBAArrayBuffer(R,x,H,k,c,t){const D=new Float32Array(k),U=new Uint16Array(c,H);let J=0;for(let V=0;V<x;V++)for(let x=0;x<R;x++){const H=4*(x+V*R);D[J]=(0,A.e)(U[H]),D[J+1]=(0,A.e)(U[H+1]),D[J+2]=(0,A.e)(U[H+2]),i.StoreLODInAlphaChannel?D[J+3]=t:D[J+3]=(0,A.e)(U[H+3]),J+=4}return D}static _GetHalfFloatRGBAArrayBuffer(R,x,H,k,c,t){if(i.StoreLODInAlphaChannel){const D=new Uint16Array(k),U=new Uint16Array(c,H);let J=0;for(let H=0;H<x;H++)for(let x=0;x<R;x++){const k=4*(x+H*R);D[J]=U[k],D[J+1]=U[k+1],D[J+2]=U[k+2],D[J+3]=(0,A.n)(t),J+=4}return D}return new Uint16Array(c,H,k)}static _GetFloatRGBAArrayBuffer(R,x,H,k,c,t){if(i.StoreLODInAlphaChannel){const A=new Float32Array(k),D=new Float32Array(c,H);let U=0;for(let H=0;H<x;H++)for(let x=0;x<R;x++){const k=4*(x+H*R);A[U]=D[k],A[U+1]=D[k+1],A[U+2]=D[k+2],A[U+3]=t,U+=4}return A}return new Float32Array(c,H,k)}static _GetFloatAsHalfFloatRGBAArrayBuffer(R,x,H,k,c,t){const D=new Uint16Array(k),U=new Float32Array(c,H);let J=0;for(let V=0;V<x;V++)for(let x=0;x<R;x++)D[J]=(0,A.n)(U[J]),D[J+1]=(0,A.n)(U[J+1]),D[J+2]=(0,A.n)(U[J+2]),i.StoreLODInAlphaChannel?D[J+3]=(0,A.n)(t):D[J+3]=(0,A.n)(U[J+3]),J+=4;return D}static _GetFloatAsUIntRGBAArrayBuffer(R,x,H,c,t,A){const D=new Uint8Array(c),U=new Float32Array(t,H);let J=0;for(let V=0;V<x;V++)for(let x=0;x<R;x++){const H=4*(x+V*R);D[J]=255*(0,k.Clamp)(U[H]),D[J+1]=255*(0,k.Clamp)(U[H+1]),D[J+2]=255*(0,k.Clamp)(U[H+2]),i.StoreLODInAlphaChannel?D[J+3]=A:D[J+3]=255*(0,k.Clamp)(U[H+3]),J+=4}return D}static _GetHalfFloatAsUIntRGBAArrayBuffer(R,x,H,c,t,D){const U=new Uint8Array(c),J=new Uint16Array(t,H);let V=0;for(let n=0;n<x;n++)for(let x=0;x<R;x++){const H=4*(x+n*R);U[V]=255*(0,k.Clamp)((0,A.e)(J[H])),U[V+1]=255*(0,k.Clamp)((0,A.e)(J[H+1])),U[V+2]=255*(0,k.Clamp)((0,A.e)(J[H+2])),i.StoreLODInAlphaChannel?U[V+3]=D:U[V+3]=255*(0,k.Clamp)((0,A.e)(J[H+3])),V+=4}return U}static _GetRGBAArrayBuffer(R,x,H,k,c,t,A,D,U){const J=new Uint8Array(k),V=new Uint8Array(c,H);let n=0;for(let g=0;g<x;g++)for(let x=0;x<R;x++){const H=4*(x+g*R);J[n]=V[H+t],J[n+1]=V[H+A],J[n+2]=V[H+D],J[n+3]=V[H+U],n+=4}return J}static _ExtractLongWordOrder(R){return 0===R||255===R||-16777216===R?0:1+i._ExtractLongWordOrder(R>>8)}static _GetRGBArrayBuffer(R,x,H,k,c,t,A,D){const U=new Uint8Array(k),J=new Uint8Array(c,H);let V=0;for(let n=0;n<x;n++)for(let x=0;x<R;x++){const H=3*(x+n*R);U[V]=J[H+t],U[V+1]=J[H+A],U[V+2]=J[H+D],V+=3}return U}static _GetLuminanceArrayBuffer(R,x,H,k,c){const t=new Uint8Array(k),A=new Uint8Array(c,H);let D=0;for(let U=0;U<x;U++)for(let x=0;x<R;x++){const H=x+U*R;t[D]=A[H],D++}return t}static UploadDDSLevels(R,x,H,k,A,U){let J=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,q=arguments.length>7?arguments[7]:void 0,S=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],L=null;k.sphericalPolynomial&&(L=[]);const b=!!R.getCaps().s3tc;x.generateMipMaps=A;const C=new Int32Array(H.buffer,H.byteOffset,31);let F,d,P,a,X,M,B,o=0,Z=0,y=1;if(542327876!==C[0])return void c.c.Error("Invalid magic number in DDS header");if(!k.isFourCC&&!k.isRGB&&!k.isLuminance)return void c.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(k.isCompressed&&!b)return void c.c.Error("Compressed textures are not supported on this platform.");let s=C[22];a=C[1]+4;let E=!1;if(k.isFourCC)switch(F=C[21],F){case V:y=8,Z=33777;break;case n:y=16,Z=33778;break;case g:y=16,Z=33779;break;case 113:E=!0,s=64;break;case 116:E=!0,s=128;break;case I:{a+=20;let R=!1;switch(k.dxgiFormat){case 10:E=!0,s=64,R=!0;break;case 2:E=!0,s=128,R=!0;break;case 88:k.isRGB=!0,k.isFourCC=!1,s=32,R=!0}if(R)break}default:return void c.c.Error(["Unsupported FourCC code:",(w=F,String.fromCharCode(255&w,w>>8&255,w>>16&255,w>>24&255))])}var w;const h=i._ExtractLongWordOrder(C[23]),f=i._ExtractLongWordOrder(C[24]),N=i._ExtractLongWordOrder(C[25]),W=i._ExtractLongWordOrder(C[26]);E&&(Z=R._getRGBABufferInternalSizedFormat(k.textureType)),M=1,C[2]&D&&!1!==A&&(M=Math.max(1,C[7]));const K=q||0,Q=R.getCaps();for(let c=K;c<U;c++){for(d=C[4],P=C[3],B=0;B<M;++B){if(-1===J||J===B){const t=-1===J?B:0;if(!k.isCompressed&&k.isFourCC){x.format=5,o=d*P*4;let k=null;if(R._badOS||R._badDesktopOS||!Q.textureHalfFloat&&!Q.textureFloat)128===s?(k=i._GetFloatAsUIntRGBAArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,t),L&&0==t&&L.push(i._GetFloatRGBAArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,t))):64===s&&(k=i._GetHalfFloatAsUIntRGBAArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,t),L&&0==t&&L.push(i._GetHalfFloatAsFloatRGBAArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,t))),x.type=0;else{const R=Q.textureFloat&&(S&&Q.textureFloatLinearFiltering||!S),c=Q.textureHalfFloat&&(S&&Q.textureHalfFloatLinearFiltering||!S),A=(128===s||64===s&&!c)&&R?1:(64===s||128===s&&!R)&&c?2:0;let D,U=null;if(128===s)switch(A){case 1:D=i._GetFloatRGBAArrayBuffer,U=null;break;case 2:D=i._GetFloatAsHalfFloatRGBAArrayBuffer,U=i._GetFloatRGBAArrayBuffer;break;case 0:D=i._GetFloatAsUIntRGBAArrayBuffer,U=i._GetFloatRGBAArrayBuffer}else switch(A){case 1:D=i._GetHalfFloatAsFloatRGBAArrayBuffer,U=null;break;case 2:D=i._GetHalfFloatRGBAArrayBuffer,U=i._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:D=i._GetHalfFloatAsUIntRGBAArrayBuffer,U=i._GetHalfFloatAsFloatRGBAArrayBuffer}x.type=A,k=D(d,P,H.byteOffset+a,o,H.buffer,t),L&&0==t&&L.push(U?U(d,P,H.byteOffset+a,o,H.buffer,t):k)}k&&R._uploadDataToTextureDirectly(x,k,c,t)}else if(k.isRGB)x.type=0,24===s?(x.format=4,o=d*P*3,X=i._GetRGBArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,h,f,N),R._uploadDataToTextureDirectly(x,X,c,t)):(x.format=5,o=d*P*4,X=i._GetRGBAArrayBuffer(d,P,H.byteOffset+a,o,H.buffer,h,f,N,W),R._uploadDataToTextureDirectly(x,X,c,t));else if(k.isLuminance){const k=R._getUnpackAlignement(),A=d;o=Math.floor((d+k-1)/k)*k*(P-1)+A,X=i._GetLuminanceArrayBuffer(d,P,H.byteOffset+a,o,H.buffer),x.format=1,x.type=0,R._uploadDataToTextureDirectly(x,X,c,t)}else o=Math.max(4,d)/4*Math.max(4,P)/4*y,X=new Uint8Array(H.buffer,H.byteOffset+a,o),x.type=0,R._uploadCompressedDataToTextureDirectly(x,Z,d,P,X,c,t)}a+=s?d*P*(s/8):o,d*=.5,P*=.5,d=Math.max(1,d),P=Math.max(1,P)}if(void 0!==q)break}L&&L.length>0?k.sphericalPolynomial=t.e.ConvertCubeMapToSphericalPolynomial({size:C[4],right:L[0],left:L[1],up:L[2],down:L[3],front:L[4],back:L[5],format:5,type:1,gammaSpace:!1}):k.sphericalPolynomial=void 0}}i.StoreLODInAlphaChannel=!1}}]);