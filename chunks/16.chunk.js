"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2570:(U,M,b)=>{function a(U){return Math.floor(U/8)}function A(U){return 1<<U%8}b.d(M,{OptimizeIndices:()=>W});class H{constructor(U){this.size=U,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(U){if(U>=this.size)throw new RangeError("Bit index out of range");const M=a(U),b=A(U);return 0!==(this._byteArray[M]&b)}set(U,M){if(U>=this.size)throw new RangeError("Bit index out of range");const b=a(U),H=A(U);M?this._byteArray[b]|=H:this._byteArray[b]&=~H}}function W(U){const M=[],b=U.length/3;for(let H=0;H<b;H++)M.push([U[3*H],U[3*H+1],U[3*H+2]]);const a=new Map;for(let H=0;H<M.length;H++){const U=M[H];for(const M of U){let U=a.get(M);U||a.set(M,U=[]),U.push(H)}}const A=new H(b),W=[],y=U=>{const b=[U];for(;b.length>0;){const U=b.pop();if(!A.get(U)){A.set(U,!0),W.push(M[U]);for(const H of M[U]){const U=a.get(H);if(!U)return;for(const M of U)A.get(M)||b.push(M)}}}};for(let H=0;H<b;H++)A.get(H)||y(H);let O=0;for(const H of W)U[O++]=H[0],U[O++]=H[1],U[O++]=H[2]}}}]);