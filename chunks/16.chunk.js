"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[16],{14193:(M,p,b)=>{b.r(p),b.d(p,{ReadExrDataAsync:()=>FM,_ExrTextureLoader:()=>HM});var Q=b(11637),q=b(11806);const B=4,k=4,u=1,T=2,O=8,H=65536,F=H>>3,o=14,W=65537,i=1<<o,A=i-1,j=59,K=63,D=2+K-j;var a,s;!function(M){M[M.NO_COMPRESSION=0]="NO_COMPRESSION",M[M.RLE_COMPRESSION=1]="RLE_COMPRESSION",M[M.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",M[M.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",M[M.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",M[M.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(M){M[M.INCREASING_Y=0]="INCREASING_Y",M[M.DECREASING_Y=1]="DECREASING_Y"}(s||(s={}));const S=function(){const M=new ArrayBuffer(4),p=new Float32Array(M),b=new Uint32Array(M),Q=new Uint32Array(512),q=new Uint32Array(512);for(let T=0;T<256;++T){const M=T-127;M<-27?(Q[T]=0,Q[256|T]=32768,q[T]=24,q[256|T]=24):M<-14?(Q[T]=1024>>-M-14,Q[256|T]=1024>>-M-14|32768,q[T]=-M-1,q[256|T]=-M-1):M<=15?(Q[T]=M+15<<10,Q[256|T]=M+15<<10|32768,q[T]=13,q[256|T]=13):M<128?(Q[T]=31744,Q[256|T]=64512,q[T]=24,q[256|T]=24):(Q[T]=31744,Q[256|T]=64512,q[T]=13,q[256|T]=13)}const B=new Uint32Array(2048),k=new Uint32Array(64),u=new Uint32Array(64);for(let T=1;T<1024;++T){let M=T<<13,p=0;for(;0===(8388608&M);)M<<=1,p-=8388608;M&=-8388609,p+=947912704,B[T]=M|p}for(let T=1024;T<2048;++T)B[T]=939524096+(T-1024<<13);for(let T=1;T<31;++T)k[T]=T<<23;k[31]=1199570944,k[32]=2147483648;for(let T=33;T<63;++T)k[T]=2147483648+(T-32<<23);k[63]=3347054592;for(let T=1;T<64;++T)32!==T&&(u[T]=1024);return{floatView:p,uint32View:b,baseTable:Q,shiftTable:q,mantissaTable:B,exponentTable:k,offsetTable:u}}();function f(M,p){const b=new Uint8Array(M);let Q=0;for(;0!=b[p.value+Q];)Q+=1;const q=(new TextDecoder).decode(b.slice(p.value,p.value+Q));return p.value=p.value+Q+1,q}function R(M,p){const b=M.getInt32(p.value,!0);return p.value+=B,b}function y(M,p){const b=M.getUint32(p.value,!0);return p.value+=B,b}function x(M,p){const b=M.getUint8(p.value);return p.value+=u,b}function P(M,p){const b=M.getUint16(p.value,!0);return p.value+=T,b}function L(M,p){const b=M[p.value];return p.value+=u,b}function N(M,p){let b;return b="getBigInt64"in DataView.prototype?Number(M.getBigInt64(p.value,!0)):M.getUint32(p.value+4,!0)+Number(M.getUint32(p.value,!0)<<32),p.value+=O,b}function r(M,p){const b=M.getFloat32(p.value,!0);return p.value+=k,b}function Y(M,p){return function(M){const p=(31744&M)>>10,b=1023&M;return(M>>15?-1:1)*(p?31===p?b?NaN:1/0:Math.pow(2,p-15)*(1+b/1024):b/1024*6103515625e-14)}(P(M,p))}function w(M,p){return function(M){if(Math.abs(M)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");M=(0,q.Clamp)(M,-65504,65504),S.floatView[0]=M;const p=S.uint32View[0],b=p>>23&511;return S.baseTable[b]+((8388607&p)>>S.shiftTable[b])}(r(M,p))}function E(M,p,b,Q){switch(b){case"string":case"stringvector":case"iccProfile":return function(M,p,b){const Q=(new TextDecoder).decode(new Uint8Array(M).slice(p.value,p.value+b));return p.value=p.value+b,Q}(M.buffer,p,Q);case"chlist":return function(M,p,b){const Q=p.value,q=[];for(;p.value<Q+b-1;){const b=f(M.buffer,p),Q=R(M,p),B=x(M,p);p.value+=3;const k=R(M,p),u=R(M,p);q.push({name:b,pixelType:Q,pLinear:B,xSampling:k,ySampling:u})}return p.value+=1,q}(M,p,Q);case"chromaticities":return function(M,p){return{redX:r(M,p),redY:r(M,p),greenX:r(M,p),greenY:r(M,p),blueX:r(M,p),blueY:r(M,p),whiteX:r(M,p),whiteY:r(M,p)}}(M,p);case"compression":return function(M,p){return x(M,p)}(M,p);case"box2i":return function(M,p){return{xMin:R(M,p),yMin:R(M,p),xMax:R(M,p),yMax:R(M,p)}}(M,p);case"lineOrder":return function(M,p){const b=x(M,p);return s[b]}(M,p);case"float":return r(M,p);case"v2f":return function(M,p){return[r(M,p),r(M,p)]}(M,p);case"v3f":return function(M,p){return[r(M,p),r(M,p),r(M,p)]}(M,p);case"int":return R(M,p);case"rational":return function(M,p){return[R(M,p),y(M,p)]}(M,p);case"timecode":return function(M,p){return[y(M,p),y(M,p)]}(M,p);case"preview":return p.value+=Q,"skipped";default:return void(p.value+=Q)}}function n(M){for(let p=1;p<M.length;p++){const b=M[p-1]+M[p]-128;M[p]=b}}function g(M,p){let b=0,Q=Math.floor((M.length+1)/2),q=0;const B=M.length-1;for(;!(q>B)&&(p[q++]=M[b++],!(q>B));)p[q++]=M[Q++]}const U=20000630;function c(M,p){if(M.getUint32(0,!0)!=U)throw new Error("Incorrect OpenEXR format");const b=M.getUint8(4),q=M.getUint8(5),B={singleTile:!!(2&q),longName:!!(4&q),deepFormat:!!(8&q),multiPart:!!(16&q)};p.value=8;const k={};let u=!0;for(;u;){const b=f(M.buffer,p);if(b){const q=f(M.buffer,p),B=E(M,p,q,y(M,p));void 0===B?Q.c.Warn(`Unknown header attribute type ${q}'.`):k[b]=B}else u=!1}if(0!=(-5&q))throw new Error("Unsupported file format");return{version:b,spec:B,...k}}const d=32768,V=65535;function h(M,p,b,Q,q){for(;b<M;)p=p<<8|L(Q,q),b+=8;return{l:p>>(b-=M)&(1<<M)-1,c:p,lc:b}}function I(M,p,b,Q){return{c:M=M<<8|L(b,Q),lc:p+=8}}function Z(M,p,b,Q,q,B,k,u,T){if(M==p){if(Q<8){const M=I(b,Q,q,B);b=M.c,Q=M.lc}let M=b>>(Q-=8);if(M=new Uint8Array([M])[0],u.value+M>T)return null;const p=k[u.value-1];for(;M-- >0;)k[u.value++]=p}else{if(!(u.value<T))return null;k[u.value++]=M}return{c:b,lc:Q}}const J=new Array(59);function v(M,p,b,Q,q,B){const k=p;let u=0,T=0;for(;Q<=q;Q++){if(k.value-p.value>b)return;let O=h(6,u,T,M,k);const H=O.l;if(u=O.c,T=O.lc,B[Q]=H,H==K){if(k.value-p.value>b)throw new Error("Error in HufUnpackEncTable");O=h(8,u,T,M,k);let H=O.l+D;if(u=O.c,T=O.lc,Q+H>q+1)throw new Error("Error in HufUnpackEncTable");for(;H--;)B[Q++]=0;Q--}else if(H>=j){let M=H-j+2;if(Q+M>q+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)B[Q++]=0;Q--}}!function(M){for(let b=0;b<=58;++b)J[b]=0;for(let b=0;b<W;++b)J[M[b]]+=1;let p=0;for(let b=58;b>0;--b){const M=p+J[b]>>1;J[b]=p,p=M}for(let b=0;b<W;++b){const p=M[b];p>0&&(M[b]=p|J[p]++<<6)}}(B)}function z(M){return 63&M}function t(M){return M>>6}function e(M,p,b,Q,q,B){const k=b.value,u=y(p,b),T=y(p,b);b.value+=4;const O=y(p,b);if(b.value+=4,u<0||u>=W||T<0||T>=W)throw new Error("Wrong HUF_ENCSIZE");const H=new Array(W),F=new Array(i);!function(M){for(let p=0;p<i;p++)M[p]={},M[p].len=0,M[p].lit=0,M[p].p=null}(F);if(v(M,b,Q-(b.value-k),u,T,H),O>8*(Q-(b.value-k)))throw new Error("Wrong hufUncompress");!function(M,p,b,Q){for(;p<=b;p++){const b=t(M[p]),q=z(M[p]);if(b>>q)throw new Error("Invalid table entry");if(q>o){const M=Q[b>>q-o];if(M.len)throw new Error("Invalid table entry");if(M.lit++,M.p){const p=M.p;M.p=new Array(M.lit);for(let b=0;b<M.lit-1;++b)M.p[b]=p[b]}else M.p=new Array(1);M.p[M.lit-1]=p}else if(q){let M=0;for(let B=1<<o-q;B>0;B--){const B=Q[(b<<o-q)+M];if(B.len||B.p)throw new Error("Invalid table entry");B.len=q,B.lit=p,M++}}}}(H,u,T,F),function(M,p,b,Q,q,B,k,u,T){let O=0,H=0;const F=k,W=Math.trunc(Q.value+(q+7)/8);for(;Q.value<W;){let q=I(O,H,b,Q);for(O=q.c,H=q.lc;H>=o;){const k=p[O>>H-o&A];if(k.len){H-=k.len;const M=Z(k.lit,B,O,H,b,Q,u,T,F);M&&(O=M.c,H=M.lc)}else{if(!k.p)throw new Error("hufDecode issues");let p;for(p=0;p<k.lit;p++){const o=z(M[k.p[p]]);for(;H<o&&Q.value<W;)q=I(O,H,b,Q),O=q.c,H=q.lc;if(H>=o&&t(M[k.p[p]])==(O>>H-o&(1<<o)-1)){H-=o;const M=Z(k.p[p],B,O,H,b,Q,u,T,F);M&&(O=M.c,H=M.lc);break}}if(p==k.lit)throw new Error("HufDecode issues")}}}const i=8-q&7;for(O>>=i,H-=i;H>0;){const M=p[O<<o-H&A];if(!M.len)throw new Error("HufDecode issues");{H-=M.len;const p=Z(M.lit,B,O,H,b,Q,u,T,F);p&&(O=p.c,H=p.lc)}}}(H,F,M,b,O,T,B,q,{value:0})}function G(M){return 65535&M}function mM(M){const p=G(M);return p>32767?p-65536:p}function C(M,p){const b=mM(M),Q=mM(p),q=b+(1&Q)+(Q>>1);return{a:q,b:q-Q}}function X(M,p){const b=G(M),Q=G(p),q=b-(Q>>1)&V;return{a:Q+q-d&V,b:q}}function l(M,p,b,Q,q,B,k){const u=k<16384,T=b>q?q:b;let O,H,F=1;for(;F<=T;)F<<=1;for(F>>=1,O=F,F>>=1;F>=1;){H=0;const k=H+B*(q-O),T=B*F,o=B*O,W=Q*F,i=Q*O;let A,j,K,D;for(;H<=k;H+=o){let q=H;const B=H+Q*(b-O);for(;q<=B;q+=i){const b=q+W,Q=q+T,B=Q+W;if(u){let k=C(M[q+p],M[Q+p]);A=k.a,K=k.b,k=C(M[b+p],M[B+p]),j=k.a,D=k.b,k=C(A,j),M[q+p]=k.a,M[b+p]=k.b,k=C(K,D),M[Q+p]=k.a,M[B+p]=k.b}else{let k=X(M[q+p],M[Q+p]);A=k.a,K=k.b,k=X(M[b+p],M[B+p]),j=k.a,D=k.b,k=X(A,j),M[q+p]=k.a,M[b+p]=k.b,k=X(K,D),M[Q+p]=k.a,M[B+p]=k.b}}if(b&F){const b=q+T;let Q;Q=u?C(M[q+p],M[b+p]):X(M[q+p],M[b+p]),A=Q.a,M[b+p]=Q.b,M[q+p]=A}}if(q&F){let q=H;const B=H+Q*(b-O);for(;q<=B;q+=i){const b=q+W;let Q;Q=u?C(M[q+p],M[b+p]):X(M[q+p],M[b+p]),A=Q.a,M[b+p]=Q.b,M[q+p]=A}}O=F,F>>=1}return H}function MM(M){return new DataView(M.array.buffer,M.offset.value,M.size)}function pM(M){const p=M.viewer.buffer.slice(M.offset.value,M.offset.value+M.size),b=new Uint8Array(function(M){let p=M.byteLength;const b=[];let Q=0;const q=new DataView(M);for(;p>0;){const M=q.getInt8(Q++);if(M<0){const B=-M;p-=B+1;for(let M=0;M<B;M++)b.push(q.getUint8(Q++))}else{const B=M;p-=2;const k=q.getUint8(Q++);for(let M=0;M<B+1;M++)b.push(k)}}return b}(p)),Q=new Uint8Array(b.length);return n(b),g(b,Q),new DataView(Q.buffer)}function bM(M){const p=M.array.slice(M.offset.value,M.offset.value+M.size),b=fflate.unzlibSync(p),Q=new Uint8Array(b.length);return n(b),g(b,Q),new DataView(Q.buffer)}function QM(M){const p=M.array.slice(M.offset.value,M.offset.value+M.size),b=fflate.unzlibSync(p),Q=M.lines*M.channels*M.width,q=1==M.type?new Uint16Array(Q):new Uint32Array(Q);let B=0,k=0;const u=new Array(4);for(let T=0;T<M.lines;T++)for(let p=0;p<M.channels;p++){let p=0;switch(M.type){case 1:u[0]=B,u[1]=u[0]+M.width,B=u[1]+M.width;for(let Q=0;Q<M.width;++Q){p+=b[u[0]++]<<8|b[u[1]++],q[k]=p,k++}break;case 2:u[0]=B,u[1]=u[0]+M.width,u[2]=u[1]+M.width,B=u[2]+M.width;for(let Q=0;Q<M.width;++Q){p+=b[u[0]++]<<24|b[u[1]++]<<16|b[u[2]++]<<8,q[k]=p,k++}}}return new DataView(q.buffer)}function qM(M){const p=M.viewer,b={value:M.offset.value},Q=new Uint16Array(M.width*M.scanlineBlockSize*(M.channels*M.type)),q=new Uint8Array(F);let B=0;const k=new Array(M.channels);for(let T=0;T<M.channels;T++)k[T]={},k[T].start=B,k[T].end=k[T].start,k[T].nx=M.width,k[T].ny=M.lines,k[T].size=M.type,B+=k[T].nx*k[T].ny*k[T].size;const u=P(p,b),O=P(p,b);if(O>=F)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(u<=O)for(let T=0;T<O-u+1;T++)q[T+u]=x(p,b);const o=new Uint16Array(H),W=function(M,p){let b=0;for(let q=0;q<H;++q)(0==q||M[q>>3]&1<<(7&q))&&(p[b++]=q);const Q=b-1;for(;b<H;)p[b++]=0;return Q}(q,o),i=y(p,b);e(M.array,p,b,i,Q,B);for(let T=0;T<M.channels;++T){const M=k[T];for(let p=0;p<k[T].size;++p)l(Q,M.start+p,M.nx,M.size,M.ny,M.nx*M.size,W)}!function(M,p,b){for(let Q=0;Q<b;++Q)p[Q]=M[p[Q]]}(o,Q,B);let A=0;const j=new Uint8Array(Q.buffer.byteLength);for(let H=0;H<M.lines;H++)for(let p=0;p<M.channels;p++){const M=k[p],b=M.nx*M.size,q=new Uint8Array(Q.buffer,M.end*T,b*T);j.set(q,A),A+=b*T,M.end+=b}return new DataView(j.buffer)}var BM,kM=b(11621);!function(M){M[M.Float=0]="Float",M[M.HalfFloat=1]="HalfFloat"}(BM||(BM={}));class uM{}async function TM(M,p,b,Q){const q={size:0,viewer:p,array:new Uint8Array(p.buffer),offset:b,width:M.dataWindow.xMax-M.dataWindow.xMin+1,height:M.dataWindow.yMax-M.dataWindow.yMin+1,channels:M.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(M.compression){case a.NO_COMPRESSION:q.lines=1,q.uncompress=MM;break;case a.RLE_COMPRESSION:q.lines=1,q.uncompress=pM;break;case a.ZIPS_COMPRESSION:q.lines=1,q.uncompress=bM,await kM.Tools.LoadScriptAsync(uM.FFLATEUrl);break;case a.ZIP_COMPRESSION:q.lines=16,q.uncompress=bM,await kM.Tools.LoadScriptAsync(uM.FFLATEUrl);break;case a.PIZ_COMPRESSION:q.lines=32,q.uncompress=qM;break;case a.PXR24_COMPRESSION:q.lines=16,q.uncompress=QM,await kM.Tools.LoadScriptAsync(uM.FFLATEUrl);break;default:throw new Error(a[M.compression]+" is unsupported")}q.scanlineBlockSize=q.lines;const B={};for(const k of M.channels)switch(k.name){case"R":case"G":case"B":case"A":case"Y":B[k.name]=!0,q.type=k.pixelType}let u=!1;if(B.R&&B.G&&B.B&&B.A)q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(B.R&&B.G&&B.B)u=!0,q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(B.R&&B.G)q.outputChannels=2,q.decodeChannels={R:0,G:1};else if(B.R)q.outputChannels=1,q.decodeChannels={R:0};else{if(!B.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");q.outputChannels=1,q.decodeChannels={Y:0}}if(1===q.type)switch(Q){case BM.Float:q.getter=Y,q.inputSize=T;break;case BM.HalfFloat:q.getter=P,q.inputSize=T}else{if(2!==q.type)throw new Error("Unsupported pixelType "+q.type+" for "+M.compression);switch(Q){case BM.Float:q.getter=r,q.inputSize=k;break;case BM.HalfFloat:q.getter=w,q.inputSize=k}}q.blockCount=q.height/q.scanlineBlockSize;for(let k=0;k<q.blockCount;k++)N(p,b);const O=q.width*q.height*q.outputChannels;switch(Q){case BM.Float:q.byteArray=new Float32Array(O),q.textureType=1,u&&q.byteArray.fill(1,0,O);break;case BM.HalfFloat:q.byteArray=new Uint16Array(O),q.textureType=2,u&&q.byteArray.fill(15360,0,O);break;default:throw new Error("Unsupported type: "+Q)}let H=0;for(const k of M.channels)void 0!==q.decodeChannels[k.name]&&(q.channelLineOffsets[k.name]=H*q.width),H+=2*k.pixelType;return q.bytesPerLine=q.width*H,q.outLineWidth=q.width*q.outputChannels,"INCREASING_Y"===M.lineOrder?q.scanOrder=M=>M:q.scanOrder=M=>q.height-1-M,4==q.outputChannels?(q.format=5,q.linearSpace=!0):(q.format=6,q.linearSpace=!1),q}function OM(M,p,b,Q){const q={value:0};for(let B=0;B<M.height/M.scanlineBlockSize;B++){const k=R(b,Q)-p.dataWindow.yMin;M.size=y(b,Q),M.lines=k+M.scanlineBlockSize>M.height?M.height-k:M.scanlineBlockSize;const u=M.size<M.lines*M.bytesPerLine&&M.uncompress?M.uncompress(M):MM(M);Q.value+=M.size;for(let b=0;b<M.scanlineBlockSize;b++){const Q=B*M.scanlineBlockSize,k=b+M.scanOrder(Q);if(k>=M.height)continue;const T=b*M.bytesPerLine,O=(M.height-1-k)*M.outLineWidth;for(let b=0;b<M.channels;b++){const Q=p.channels[b].name,B=M.channelLineOffsets[Q],k=M.decodeChannels[Q];if(void 0!==k){q.value=T+B;for(let p=0;p<M.width;p++){const b=O+p*M.outputChannels+k;M.byteArray&&(M.byteArray[b]=M.getter(u,q))}}}}}}uM.DefaultOutputType=BM.HalfFloat,uM.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class HM{constructor(){this.supportCascades=!1}loadCubeData(M,p,b,Q,q){throw".exr not supported in Cube."}loadData(M,p,b){const q=new DataView(M.buffer),B={value:0},k=c(q,B);TM(k,q,B,uM.DefaultOutputType).then((M=>{OM(M,k,q,B);const Q=k.dataWindow.xMax-k.dataWindow.xMin+1,u=k.dataWindow.yMax-k.dataWindow.yMin+1;b(Q,u,p.generateMipMaps,!1,(()=>{const b=p.getEngine();p.format=k.format,p.type=M.textureType,p.invertY=!1,p._gammaSpace=!k.linearSpace,M.byteArray&&b._uploadDataToTextureDirectly(p,M.byteArray,0,0,void 0,!0)}))})).catch((M=>{Q.c.Error("Failed to load EXR texture: ",M)}))}}async function FM(M){const p=new DataView(M),b={value:0},q=c(p,b);try{const M=await TM(q,p,b,BM.Float);return OM(M,q,p,b),M.byteArray?{width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,data:new Float32Array(M.byteArray)}:(Q.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(B){Q.c.Error("Failed to load EXR data: ",B)}return{width:0,height:0,data:null}}},11806:(M,p,b)=>{function Q(M){return parseInt(M.toString().replace(/\W/g,""))}function q(M,p){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-p)<=b}function B(M,p,b){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<p-Q||M>b+Q}function k(M,p){return M===p?M:Math.random()*(p-M)+M}function u(M,p,b){return M+(p-M)*b}function T(M,p,b){let Q=j(p-M,360);return Q>180&&(Q-=360),M+Q*o(b)}function O(M,p,b){let Q=0;return Q=M!=p?o((b-M)/(p-M)):0,Q}function H(M,p,b,Q,q){const B=q*q,k=q*B;return M*(2*k-3*B+1)+b*(-2*k+3*B)+p*(k-2*B+q)+Q*(k-B)}function F(M,p,b,Q,q){const B=q*q;return 6*(B-q)*M+(3*B-4*q+1)*p+6*(-B+q)*b+(3*B-2*q)*Q}function o(M){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(p,M))}function W(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function i(M){const p=M.toString(16);return M<=15?("0"+p).toUpperCase():p.toUpperCase()}function A(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let p=0;if(M<1){for(;M<1;)p++,M*=2;p=-p}else if(M>1)for(;M>1;)p++,M=Math.floor(M/2);return p}function j(M,p){return M-Math.floor(M/p)*p}function K(M,p,b){return(M-p)/(b-p)}function D(M,p,b){return M*(b-p)+p}function a(M,p){let b=j(p-M,360);return b>180&&(b-=360),b}function s(M,p){const b=j(M,2*p);return p-Math.abs(b-p)}function S(M,p,b){let Q=o(b);return Q=-2*Q*Q*Q+3*Q*Q,p*Q+M*(1-Q)}function f(M,p,b){let Q=0;return Q=Math.abs(p-M)<=b?p:M+Math.sign(p-M)*b,Q}function R(M,p,b){const Q=a(M,p);let q=0;return q=-b<Q&&Q<b?p:f(M,p=M+Q,b),q}function y(M,p,b){return(M-p)/(b-p)}function x(M,p,b){return(b-p)*M+p}function P(M,p){const b=M%p;return 0===b?p:P(p,b)}b.r(p),b.d(p,{Clamp:()=>o,DeltaAngle:()=>a,Denormalize:()=>D,ExtractAsInt:()=>Q,Hermite:()=>H,Hermite1stDerivative:()=>F,HighestCommonFactor:()=>P,ILog2:()=>A,InverseLerp:()=>O,Lerp:()=>u,LerpAngle:()=>T,MoveTowards:()=>f,MoveTowardsAngle:()=>R,Normalize:()=>K,NormalizeRadians:()=>W,OutsideRange:()=>B,PercentToRange:()=>x,PingPong:()=>s,RandomRange:()=>k,RangeToPercent:()=>y,Repeat:()=>j,SmoothStep:()=>S,ToHex:()=>i,WithinEpsilon:()=>q})}}]);