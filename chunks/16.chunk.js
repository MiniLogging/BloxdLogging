"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13564:(h,V,i)=>{i.r(V),i.d(V,{ReadExrDataAsync:()=>vh,_ExrTextureLoader:()=>Ih});var S=i(10967),l=i(11162);const Y=4,g=4,q=1,B=2,J=8,I=65536,v=I>>3,s=14,t=65537,T=1<<s,e=T-1,n=59,c=63,f=2+c-n;var P,L;!function(h){h[h.NO_COMPRESSION=0]="NO_COMPRESSION",h[h.RLE_COMPRESSION=1]="RLE_COMPRESSION",h[h.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",h[h.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",h[h.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",h[h.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(P||(P={})),function(h){h[h.INCREASING_Y=0]="INCREASING_Y",h[h.DECREASING_Y=1]="DECREASING_Y"}(L||(L={}));const U=function(){const h=new ArrayBuffer(4),V=new Float32Array(h),i=new Uint32Array(h),S=new Uint32Array(512),l=new Uint32Array(512);for(let B=0;B<256;++B){const h=B-127;h<-27?(S[B]=0,S[256|B]=32768,l[B]=24,l[256|B]=24):h<-14?(S[B]=1024>>-h-14,S[256|B]=1024>>-h-14|32768,l[B]=-h-1,l[256|B]=-h-1):h<=15?(S[B]=h+15<<10,S[256|B]=h+15<<10|32768,l[B]=13,l[256|B]=13):h<128?(S[B]=31744,S[256|B]=64512,l[B]=24,l[256|B]=24):(S[B]=31744,S[256|B]=64512,l[B]=13,l[256|B]=13)}const Y=new Uint32Array(2048),g=new Uint32Array(64),q=new Uint32Array(64);for(let B=1;B<1024;++B){let h=B<<13,V=0;for(;0===(8388608&h);)h<<=1,V-=8388608;h&=-8388609,V+=947912704,Y[B]=h|V}for(let B=1024;B<2048;++B)Y[B]=939524096+(B-1024<<13);for(let B=1;B<31;++B)g[B]=B<<23;g[31]=1199570944,g[32]=2147483648;for(let B=33;B<63;++B)g[B]=2147483648+(B-32<<23);g[63]=3347054592;for(let B=1;B<64;++B)32!==B&&(q[B]=1024);return{floatView:V,uint32View:i,baseTable:S,shiftTable:l,mantissaTable:Y,exponentTable:g,offsetTable:q}}();function X(h,V){const i=new Uint8Array(h);let S=0;for(;0!=i[V.value+S];)S+=1;const l=(new TextDecoder).decode(i.slice(V.value,V.value+S));return V.value=V.value+S+1,l}function D(h,V){const i=h.getInt32(V.value,!0);return V.value+=Y,i}function O(h,V){const i=h.getUint32(V.value,!0);return V.value+=Y,i}function o(h,V){const i=h.getUint8(V.value);return V.value+=q,i}function M(h,V){const i=h.getUint16(V.value,!0);return V.value+=B,i}function F(h,V){const i=h[V.value];return V.value+=q,i}function E(h,V){let i;return i="getBigInt64"in DataView.prototype?Number(h.getBigInt64(V.value,!0)):h.getUint32(V.value+4,!0)+Number(h.getUint32(V.value,!0)<<32),V.value+=J,i}function H(h,V){const i=h.getFloat32(V.value,!0);return V.value+=g,i}function j(h,V){return function(h){const V=(31744&h)>>10,i=1023&h;return(h>>15?-1:1)*(V?31===V?i?NaN:1/0:Math.pow(2,V-15)*(1+i/1024):i/1024*6103515625e-14)}(M(h,V))}function m(h,V){return function(h){if(Math.abs(h)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");h=(0,l.Clamp)(h,-65504,65504),U.floatView[0]=h;const V=U.uint32View[0],i=V>>23&511;return U.baseTable[i]+((8388607&V)>>U.shiftTable[i])}(H(h,V))}function G(h,V,i,S){switch(i){case"string":case"stringvector":case"iccProfile":return function(h,V,i){const S=(new TextDecoder).decode(new Uint8Array(h).slice(V.value,V.value+i));return V.value=V.value+i,S}(h.buffer,V,S);case"chlist":return function(h,V,i){const S=V.value,l=[];for(;V.value<S+i-1;){const i=X(h.buffer,V),S=D(h,V),Y=o(h,V);V.value+=3;const g=D(h,V),q=D(h,V);l.push({name:i,pixelType:S,pLinear:Y,xSampling:g,ySampling:q})}return V.value+=1,l}(h,V,S);case"chromaticities":return function(h,V){return{redX:H(h,V),redY:H(h,V),greenX:H(h,V),greenY:H(h,V),blueX:H(h,V),blueY:H(h,V),whiteX:H(h,V),whiteY:H(h,V)}}(h,V);case"compression":return function(h,V){return o(h,V)}(h,V);case"box2i":return function(h,V){return{xMin:D(h,V),yMin:D(h,V),xMax:D(h,V),yMax:D(h,V)}}(h,V);case"lineOrder":return function(h,V){const i=o(h,V);return L[i]}(h,V);case"float":return H(h,V);case"v2f":return function(h,V){return[H(h,V),H(h,V)]}(h,V);case"v3f":return function(h,V){return[H(h,V),H(h,V),H(h,V)]}(h,V);case"int":return D(h,V);case"rational":return function(h,V){return[D(h,V),O(h,V)]}(h,V);case"timecode":return function(h,V){return[O(h,V),O(h,V)]}(h,V);case"preview":return V.value+=S,"skipped";default:return void(V.value+=S)}}function w(h){for(let V=1;V<h.length;V++){const i=h[V-1]+h[V]-128;h[V]=i}}function N(h,V){let i=0,S=Math.floor((h.length+1)/2),l=0;const Y=h.length-1;for(;!(l>Y)&&(V[l++]=h[i++],!(l>Y));)V[l++]=h[S++]}const r=20000630;function k(h,V){if(h.getUint32(0,!0)!=r)throw new Error("Incorrect OpenEXR format");const i=h.getUint8(4),l=h.getUint8(5),Y={singleTile:!!(2&l),longName:!!(4&l),deepFormat:!!(8&l),multiPart:!!(16&l)};V.value=8;const g={};let q=!0;for(;q;){const i=X(h.buffer,V);if(i){const l=X(h.buffer,V),Y=G(h,V,l,O(h,V));void 0===Y?S.d.Warn(`Unknown header attribute type ${l}'.`):g[i]=Y}else q=!1}if(0!=(-5&l))throw new Error("Unsupported file format");return{version:i,spec:Y,...g}}const R=32768,Z=65535;function z(h,V,i,S,l){for(;i<h;)V=V<<8|F(S,l),i+=8;return{l:V>>(i-=h)&(1<<h)-1,c:V,lc:i}}function d(h,V,i,S){return{c:h=h<<8|F(i,S),lc:V+=8}}function x(h,V,i,S,l,Y,g,q,B){if(h==V){if(S<8){const h=d(i,S,l,Y);i=h.c,S=h.lc}let h=i>>(S-=8);if(h=new Uint8Array([h])[0],q.value+h>B)return null;const V=g[q.value-1];for(;h-- >0;)g[q.value++]=V}else{if(!(q.value<B))return null;g[q.value++]=h}return{c:i,lc:S}}const y=new Array(59);function Q(h,V,i,S,l,Y){const g=V;let q=0,B=0;for(;S<=l;S++){if(g.value-V.value>i)return;let J=z(6,q,B,h,g);const I=J.l;if(q=J.c,B=J.lc,Y[S]=I,I==c){if(g.value-V.value>i)throw new Error("Error in HufUnpackEncTable");J=z(8,q,B,h,g);let I=J.l+f;if(q=J.c,B=J.lc,S+I>l+1)throw new Error("Error in HufUnpackEncTable");for(;I--;)Y[S++]=0;S--}else if(I>=n){let h=I-n+2;if(S+h>l+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)Y[S++]=0;S--}}!function(h){for(let i=0;i<=58;++i)y[i]=0;for(let i=0;i<t;++i)y[h[i]]+=1;let V=0;for(let i=58;i>0;--i){const h=V+y[i]>>1;y[i]=V,V=h}for(let i=0;i<t;++i){const V=h[i];V>0&&(h[i]=V|y[V]++<<6)}}(Y)}function A(h){return 63&h}function b(h){return h>>6}function C(h,V,i,S,l,Y){const g=i.value,q=O(V,i),B=O(V,i);i.value+=4;const J=O(V,i);if(i.value+=4,q<0||q>=t||B<0||B>=t)throw new Error("Wrong HUF_ENCSIZE");const I=new Array(t),v=new Array(T);!function(h){for(let V=0;V<T;V++)h[V]={},h[V].len=0,h[V].lit=0,h[V].p=null}(v);if(Q(h,i,S-(i.value-g),q,B,I),J>8*(S-(i.value-g)))throw new Error("Wrong hufUncompress");!function(h,V,i,S){for(;V<=i;V++){const i=b(h[V]),l=A(h[V]);if(i>>l)throw new Error("Invalid table entry");if(l>s){const h=S[i>>l-s];if(h.len)throw new Error("Invalid table entry");if(h.lit++,h.p){const V=h.p;h.p=new Array(h.lit);for(let i=0;i<h.lit-1;++i)h.p[i]=V[i]}else h.p=new Array(1);h.p[h.lit-1]=V}else if(l){let h=0;for(let Y=1<<s-l;Y>0;Y--){const Y=S[(i<<s-l)+h];if(Y.len||Y.p)throw new Error("Invalid table entry");Y.len=l,Y.lit=V,h++}}}}(I,q,B,v),function(h,V,i,S,l,Y,g,q,B){let J=0,I=0;const v=g,t=Math.trunc(S.value+(l+7)/8);for(;S.value<t;){let l=d(J,I,i,S);for(J=l.c,I=l.lc;I>=s;){const g=V[J>>I-s&e];if(g.len){I-=g.len;const h=x(g.lit,Y,J,I,i,S,q,B,v);h&&(J=h.c,I=h.lc)}else{if(!g.p)throw new Error("hufDecode issues");let V;for(V=0;V<g.lit;V++){const s=A(h[g.p[V]]);for(;I<s&&S.value<t;)l=d(J,I,i,S),J=l.c,I=l.lc;if(I>=s&&b(h[g.p[V]])==(J>>I-s&(1<<s)-1)){I-=s;const h=x(g.p[V],Y,J,I,i,S,q,B,v);h&&(J=h.c,I=h.lc);break}}if(V==g.lit)throw new Error("HufDecode issues")}}}const T=8-l&7;for(J>>=T,I-=T;I>0;){const h=V[J<<s-I&e];if(!h.len)throw new Error("HufDecode issues");{I-=h.len;const V=x(h.lit,Y,J,I,i,S,q,B,v);V&&(J=V.c,I=V.lc)}}}(I,v,h,i,J,B,Y,l,{value:0})}function u(h){return 65535&h}function p(h){const V=u(h);return V>32767?V-65536:V}function W(h,V){const i=p(h),S=p(V),l=i+(1&S)+(S>>1);return{a:l,b:l-S}}function a(h,V){const i=u(h),S=u(V),l=i-(S>>1)&Z;return{a:S+l-R&Z,b:l}}function K(h,V,i,S,l,Y,g){const q=g<16384,B=i>l?l:i;let J,I,v=1;for(;v<=B;)v<<=1;for(v>>=1,J=v,v>>=1;v>=1;){I=0;const g=I+Y*(l-J),B=Y*v,s=Y*J,t=S*v,T=S*J;let e,n,c,f;for(;I<=g;I+=s){let l=I;const Y=I+S*(i-J);for(;l<=Y;l+=T){const i=l+t,S=l+B,Y=S+t;if(q){let g=W(h[l+V],h[S+V]);e=g.a,c=g.b,g=W(h[i+V],h[Y+V]),n=g.a,f=g.b,g=W(e,n),h[l+V]=g.a,h[i+V]=g.b,g=W(c,f),h[S+V]=g.a,h[Y+V]=g.b}else{let g=a(h[l+V],h[S+V]);e=g.a,c=g.b,g=a(h[i+V],h[Y+V]),n=g.a,f=g.b,g=a(e,n),h[l+V]=g.a,h[i+V]=g.b,g=a(c,f),h[S+V]=g.a,h[Y+V]=g.b}}if(i&v){const i=l+B;let S;S=q?W(h[l+V],h[i+V]):a(h[l+V],h[i+V]),e=S.a,h[i+V]=S.b,h[l+V]=e}}if(l&v){let l=I;const Y=I+S*(i-J);for(;l<=Y;l+=T){const i=l+t;let S;S=q?W(h[l+V],h[i+V]):a(h[l+V],h[i+V]),e=S.a,h[i+V]=S.b,h[l+V]=e}}J=v,v>>=1}return I}function hh(h){return new DataView(h.array.buffer,h.offset.value,h.size)}function Vh(h){const V=h.viewer.buffer.slice(h.offset.value,h.offset.value+h.size),i=new Uint8Array(function(h){let V=h.byteLength;const i=[];let S=0;const l=new DataView(h);for(;V>0;){const h=l.getInt8(S++);if(h<0){const Y=-h;V-=Y+1;for(let h=0;h<Y;h++)i.push(l.getUint8(S++))}else{const Y=h;V-=2;const g=l.getUint8(S++);for(let h=0;h<Y+1;h++)i.push(g)}}return i}(V)),S=new Uint8Array(i.length);return w(i),N(i,S),new DataView(S.buffer)}function ih(h){const V=h.array.slice(h.offset.value,h.offset.value+h.size),i=fflate.unzlibSync(V),S=new Uint8Array(i.length);return w(i),N(i,S),new DataView(S.buffer)}function Sh(h){const V=h.array.slice(h.offset.value,h.offset.value+h.size),i=fflate.unzlibSync(V),S=h.lines*h.channels*h.width,l=1==h.type?new Uint16Array(S):new Uint32Array(S);let Y=0,g=0;const q=new Array(4);for(let B=0;B<h.lines;B++)for(let V=0;V<h.channels;V++){let V=0;switch(h.type){case 1:q[0]=Y,q[1]=q[0]+h.width,Y=q[1]+h.width;for(let S=0;S<h.width;++S){V+=i[q[0]++]<<8|i[q[1]++],l[g]=V,g++}break;case 2:q[0]=Y,q[1]=q[0]+h.width,q[2]=q[1]+h.width,Y=q[2]+h.width;for(let S=0;S<h.width;++S){V+=i[q[0]++]<<24|i[q[1]++]<<16|i[q[2]++]<<8,l[g]=V,g++}}}return new DataView(l.buffer)}function lh(h){const V=h.viewer,i={value:h.offset.value},S=new Uint16Array(h.width*h.scanlineBlockSize*(h.channels*h.type)),l=new Uint8Array(v);let Y=0;const g=new Array(h.channels);for(let B=0;B<h.channels;B++)g[B]={},g[B].start=Y,g[B].end=g[B].start,g[B].nx=h.width,g[B].ny=h.lines,g[B].size=h.type,Y+=g[B].nx*g[B].ny*g[B].size;const q=M(V,i),J=M(V,i);if(J>=v)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(q<=J)for(let B=0;B<J-q+1;B++)l[B+q]=o(V,i);const s=new Uint16Array(I),t=function(h,V){let i=0;for(let l=0;l<I;++l)(0==l||h[l>>3]&1<<(7&l))&&(V[i++]=l);const S=i-1;for(;i<I;)V[i++]=0;return S}(l,s),T=O(V,i);C(h.array,V,i,T,S,Y);for(let B=0;B<h.channels;++B){const h=g[B];for(let V=0;V<g[B].size;++V)K(S,h.start+V,h.nx,h.size,h.ny,h.nx*h.size,t)}!function(h,V,i){for(let S=0;S<i;++S)V[S]=h[V[S]]}(s,S,Y);let e=0;const n=new Uint8Array(S.buffer.byteLength);for(let I=0;I<h.lines;I++)for(let V=0;V<h.channels;V++){const h=g[V],i=h.nx*h.size,l=new Uint8Array(S.buffer,h.end*B,i*B);n.set(l,e),e+=i*B,h.end+=i}return new DataView(n.buffer)}var Yh,gh=i(10952);!function(h){h[h.Float=0]="Float",h[h.HalfFloat=1]="HalfFloat"}(Yh||(Yh={}));class qh{}async function Bh(h,V,i,S){const l={size:0,viewer:V,array:new Uint8Array(V.buffer),offset:i,width:h.dataWindow.xMax-h.dataWindow.xMin+1,height:h.dataWindow.yMax-h.dataWindow.yMin+1,channels:h.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(h.compression){case P.NO_COMPRESSION:l.lines=1,l.uncompress=hh;break;case P.RLE_COMPRESSION:l.lines=1,l.uncompress=Vh;break;case P.ZIPS_COMPRESSION:l.lines=1,l.uncompress=ih,await gh.Tools.LoadScriptAsync(qh.FFLATEUrl);break;case P.ZIP_COMPRESSION:l.lines=16,l.uncompress=ih,await gh.Tools.LoadScriptAsync(qh.FFLATEUrl);break;case P.PIZ_COMPRESSION:l.lines=32,l.uncompress=lh;break;case P.PXR24_COMPRESSION:l.lines=16,l.uncompress=Sh,await gh.Tools.LoadScriptAsync(qh.FFLATEUrl);break;default:throw new Error(P[h.compression]+" is unsupported")}l.scanlineBlockSize=l.lines;const Y={};for(const g of h.channels)switch(g.name){case"R":case"G":case"B":case"A":case"Y":Y[g.name]=!0,l.type=g.pixelType}let q=!1;if(Y.R&&Y.G&&Y.B&&Y.A)l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(Y.R&&Y.G&&Y.B)q=!0,l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(Y.R&&Y.G)l.outputChannels=2,l.decodeChannels={R:0,G:1};else if(Y.R)l.outputChannels=1,l.decodeChannels={R:0};else{if(!Y.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");l.outputChannels=1,l.decodeChannels={Y:0}}if(1===l.type)switch(S){case Yh.Float:l.getter=j,l.inputSize=B;break;case Yh.HalfFloat:l.getter=M,l.inputSize=B}else{if(2!==l.type)throw new Error("Unsupported pixelType "+l.type+" for "+h.compression);switch(S){case Yh.Float:l.getter=H,l.inputSize=g;break;case Yh.HalfFloat:l.getter=m,l.inputSize=g}}l.blockCount=l.height/l.scanlineBlockSize;for(let g=0;g<l.blockCount;g++)E(V,i);const J=l.width*l.height*l.outputChannels;switch(S){case Yh.Float:l.byteArray=new Float32Array(J),l.textureType=1,q&&l.byteArray.fill(1,0,J);break;case Yh.HalfFloat:l.byteArray=new Uint16Array(J),l.textureType=2,q&&l.byteArray.fill(15360,0,J);break;default:throw new Error("Unsupported type: "+S)}let I=0;for(const g of h.channels)void 0!==l.decodeChannels[g.name]&&(l.channelLineOffsets[g.name]=I*l.width),I+=2*g.pixelType;return l.bytesPerLine=l.width*I,l.outLineWidth=l.width*l.outputChannels,"INCREASING_Y"===h.lineOrder?l.scanOrder=h=>h:l.scanOrder=h=>l.height-1-h,4==l.outputChannels?(l.format=5,l.linearSpace=!0):(l.format=6,l.linearSpace=!1),l}function Jh(h,V,i,S){const l={value:0};for(let Y=0;Y<h.height/h.scanlineBlockSize;Y++){const g=D(i,S)-V.dataWindow.yMin;h.size=O(i,S),h.lines=g+h.scanlineBlockSize>h.height?h.height-g:h.scanlineBlockSize;const q=h.size<h.lines*h.bytesPerLine&&h.uncompress?h.uncompress(h):hh(h);S.value+=h.size;for(let i=0;i<h.scanlineBlockSize;i++){const S=Y*h.scanlineBlockSize,g=i+h.scanOrder(S);if(g>=h.height)continue;const B=i*h.bytesPerLine,J=(h.height-1-g)*h.outLineWidth;for(let i=0;i<h.channels;i++){const S=V.channels[i].name,Y=h.channelLineOffsets[S],g=h.decodeChannels[S];if(void 0!==g){l.value=B+Y;for(let V=0;V<h.width;V++){const i=J+V*h.outputChannels+g;h.byteArray&&(h.byteArray[i]=h.getter(q,l))}}}}}}qh.DefaultOutputType=Yh.HalfFloat,qh.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Ih{constructor(){this.supportCascades=!1}loadCubeData(h,V,i,S,l){throw".exr not supported in Cube."}loadData(h,V,i){const l=new DataView(h.buffer),Y={value:0},g=k(l,Y);Bh(g,l,Y,qh.DefaultOutputType).then((h=>{Jh(h,g,l,Y);const S=g.dataWindow.xMax-g.dataWindow.xMin+1,q=g.dataWindow.yMax-g.dataWindow.yMin+1;i(S,q,V.generateMipMaps,!1,(()=>{const i=V.getEngine();V.format=g.format,V.type=h.textureType,V.invertY=!1,V._gammaSpace=!g.linearSpace,h.byteArray&&i._uploadDataToTextureDirectly(V,h.byteArray,0,0,void 0,!0)}))})).catch((h=>{S.d.Error("Failed to load EXR texture: ",h)}))}}async function vh(h){const V=new DataView(h),i={value:0},l=k(V,i);try{const h=await Bh(l,V,i,Yh.Float);return Jh(h,l,V,i),h.byteArray?{width:l.dataWindow.xMax-l.dataWindow.xMin+1,height:l.dataWindow.yMax-l.dataWindow.yMin+1,data:new Float32Array(h.byteArray)}:(S.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Y){S.d.Error("Failed to load EXR data: ",Y)}return{width:0,height:0,data:null}}},11162:(h,V,i)=>{function S(h){return parseInt(h.toString().replace(/\W/g,""))}function l(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-V)<=i}function Y(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<V-S||h>i+S}function g(h,V){return h===V?h:Math.random()*(V-h)+h}function q(h,V,i){return h+(V-h)*i}function B(h,V,i){let S=n(V-h,360);return S>180&&(S-=360),h+S*s(i)}function J(h,V,i){let S=0;return S=h!=V?s((i-h)/(V-h)):0,S}function I(h,V,i,S,l){const Y=l*l,g=l*Y;return h*(2*g-3*Y+1)+i*(-2*g+3*Y)+V*(g-2*Y+l)+S*(g-Y)}function v(h,V,i,S,l){const Y=l*l;return 6*(Y-l)*h+(3*Y-4*l+1)*V+6*(-Y+l)*i+(3*Y-2*l)*S}function s(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(V,h))}function t(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function T(h){const V=h.toString(16);return h<=15?("0"+V).toUpperCase():V.toUpperCase()}function e(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let V=0;if(h<1){for(;h<1;)V++,h*=2;V=-V}else if(h>1)for(;h>1;)V++,h=Math.floor(h/2);return V}function n(h,V){return h-Math.floor(h/V)*V}function c(h,V,i){return(h-V)/(i-V)}function f(h,V,i){return h*(i-V)+V}function P(h,V){let i=n(V-h,360);return i>180&&(i-=360),i}function L(h,V){const i=n(h,2*V);return V-Math.abs(i-V)}function U(h,V,i){let S=s(i);return S=-2*S*S*S+3*S*S,V*S+h*(1-S)}function X(h,V,i){let S=0;return S=Math.abs(V-h)<=i?V:h+Math.sign(V-h)*i,S}function D(h,V,i){const S=P(h,V);let l=0;return l=-i<S&&S<i?V:X(h,V=h+S,i),l}function O(h,V,i){return(h-V)/(i-V)}function o(h,V,i){return(i-V)*h+V}function M(h,V){const i=h%V;return 0===i?V:M(V,i)}i.r(V),i.d(V,{Clamp:()=>s,DeltaAngle:()=>P,Denormalize:()=>f,ExtractAsInt:()=>S,Hermite:()=>I,Hermite1stDerivative:()=>v,HighestCommonFactor:()=>M,ILog2:()=>e,InverseLerp:()=>J,Lerp:()=>q,LerpAngle:()=>B,MoveTowards:()=>X,MoveTowardsAngle:()=>D,Normalize:()=>c,NormalizeRadians:()=>t,OutsideRange:()=>Y,PercentToRange:()=>o,PingPong:()=>L,RandomRange:()=>g,RangeToPercent:()=>O,Repeat:()=>n,SmoothStep:()=>U,ToHex:()=>T,WithinEpsilon:()=>l})}}]);