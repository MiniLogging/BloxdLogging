"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[16],{14654:(I,O,C)=>{C.r(O),C.d(O,{ReadExrDataAsync:()=>QI,_ExrTextureLoader:()=>NI});var j=C(12103),K=C(12282);const i=4,y=4,S=1,U=2,p=8,N=65536,Q=N>>3,s=14,Z=65537,q=1<<s,mI=q-1,E=59,h=63,r=2+h-E;var W,Y;!function(I){I[I.NO_COMPRESSION=0]="NO_COMPRESSION",I[I.RLE_COMPRESSION=1]="RLE_COMPRESSION",I[I.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",I[I.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",I[I.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",I[I.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(W||(W={})),function(I){I[I.INCREASING_Y=0]="INCREASING_Y",I[I.DECREASING_Y=1]="DECREASING_Y"}(Y||(Y={}));const o=function(){const I=new ArrayBuffer(4),O=new Float32Array(I),C=new Uint32Array(I),j=new Uint32Array(512),K=new Uint32Array(512);for(let U=0;U<256;++U){const I=U-127;I<-27?(j[U]=0,j[256|U]=32768,K[U]=24,K[256|U]=24):I<-14?(j[U]=1024>>-I-14,j[256|U]=1024>>-I-14|32768,K[U]=-I-1,K[256|U]=-I-1):I<=15?(j[U]=I+15<<10,j[256|U]=I+15<<10|32768,K[U]=13,K[256|U]=13):I<128?(j[U]=31744,j[256|U]=64512,K[U]=24,K[256|U]=24):(j[U]=31744,j[256|U]=64512,K[U]=13,K[256|U]=13)}const i=new Uint32Array(2048),y=new Uint32Array(64),S=new Uint32Array(64);for(let U=1;U<1024;++U){let I=U<<13,O=0;for(;0===(8388608&I);)I<<=1,O-=8388608;I&=-8388609,O+=947912704,i[U]=I|O}for(let U=1024;U<2048;++U)i[U]=939524096+(U-1024<<13);for(let U=1;U<31;++U)y[U]=U<<23;y[31]=1199570944,y[32]=2147483648;for(let U=33;U<63;++U)y[U]=2147483648+(U-32<<23);y[63]=3347054592;for(let U=1;U<64;++U)32!==U&&(S[U]=1024);return{floatView:O,uint32View:C,baseTable:j,shiftTable:K,mantissaTable:i,exponentTable:y,offsetTable:S}}();function c(I,O){const C=new Uint8Array(I);let j=0;for(;0!=C[O.value+j];)j+=1;const K=(new TextDecoder).decode(C.slice(O.value,O.value+j));return O.value=O.value+j+1,K}function n(I,O){const C=I.getInt32(O.value,!0);return O.value+=i,C}function X(I,O){const C=I.getUint32(O.value,!0);return O.value+=i,C}function T(I,O){const C=I.getUint8(O.value);return O.value+=S,C}function H(I,O){const C=I.getUint16(O.value,!0);return O.value+=U,C}function b(I,O){const C=I[O.value];return O.value+=S,C}function a(I,O){let C;return C="getBigInt64"in DataView.prototype?Number(I.getBigInt64(O.value,!0)):I.getUint32(O.value+4,!0)+Number(I.getUint32(O.value,!0)<<32),O.value+=p,C}function M(I,O){const C=I.getFloat32(O.value,!0);return O.value+=y,C}function u(I,O){return function(I){const O=(31744&I)>>10,C=1023&I;return(I>>15?-1:1)*(O?31===O?C?NaN:1/0:Math.pow(2,O-15)*(1+C/1024):C/1024*6103515625e-14)}(H(I,O))}function J(I,O){return function(I){if(Math.abs(I)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");I=(0,K.Clamp)(I,-65504,65504),o.floatView[0]=I;const O=o.uint32View[0],C=O>>23&511;return o.baseTable[C]+((8388607&O)>>o.shiftTable[C])}(M(I,O))}function f(I,O,C,j){switch(C){case"string":case"stringvector":case"iccProfile":return function(I,O,C){const j=(new TextDecoder).decode(new Uint8Array(I).slice(O.value,O.value+C));return O.value=O.value+C,j}(I.buffer,O,j);case"chlist":return function(I,O,C){const j=O.value,K=[];for(;O.value<j+C-1;){const C=c(I.buffer,O),j=n(I,O),i=T(I,O);O.value+=3;const y=n(I,O),S=n(I,O);K.push({name:C,pixelType:j,pLinear:i,xSampling:y,ySampling:S})}return O.value+=1,K}(I,O,j);case"chromaticities":return function(I,O){return{redX:M(I,O),redY:M(I,O),greenX:M(I,O),greenY:M(I,O),blueX:M(I,O),blueY:M(I,O),whiteX:M(I,O),whiteY:M(I,O)}}(I,O);case"compression":return function(I,O){return T(I,O)}(I,O);case"box2i":return function(I,O){return{xMin:n(I,O),yMin:n(I,O),xMax:n(I,O),yMax:n(I,O)}}(I,O);case"lineOrder":return function(I,O){const C=T(I,O);return Y[C]}(I,O);case"float":return M(I,O);case"v2f":return function(I,O){return[M(I,O),M(I,O)]}(I,O);case"v3f":return function(I,O){return[M(I,O),M(I,O),M(I,O)]}(I,O);case"int":return n(I,O);case"rational":return function(I,O){return[n(I,O),X(I,O)]}(I,O);case"timecode":return function(I,O){return[X(I,O),X(I,O)]}(I,O);case"preview":return O.value+=j,"skipped";default:return void(O.value+=j)}}function l(I){for(let O=1;O<I.length;O++){const C=I[O-1]+I[O]-128;I[O]=C}}function x(I,O){let C=0,j=Math.floor((I.length+1)/2),K=0;const i=I.length-1;for(;!(K>i)&&(O[K++]=I[C++],!(K>i));)O[K++]=I[j++]}const D=20000630;function t(I,O){if(I.getUint32(0,!0)!=D)throw new Error("Incorrect OpenEXR format");const C=I.getUint8(4),K=I.getUint8(5),i={singleTile:!!(2&K),longName:!!(4&K),deepFormat:!!(8&K),multiPart:!!(16&K)};O.value=8;const y={};let S=!0;for(;S;){const C=c(I.buffer,O);if(C){const K=c(I.buffer,O),i=f(I,O,K,X(I,O));void 0===i?j.c.Warn(`Unknown header attribute type ${K}'.`):y[C]=i}else S=!1}if(0!=(-5&K))throw new Error("Unsupported file format");return{version:C,spec:i,...y}}const d=32768,w=65535;function g(I,O,C,j,K){for(;C<I;)O=O<<8|b(j,K),C+=8;return{l:O>>(C-=I)&(1<<I)-1,c:O,lc:C}}function V(I,O,C,j){return{c:I=I<<8|b(C,j),lc:O+=8}}function e(I,O,C,j,K,i,y,S,U){if(I==O){if(j<8){const I=V(C,j,K,i);C=I.c,j=I.lc}let I=C>>(j-=8);if(I=new Uint8Array([I])[0],S.value+I>U)return null;const O=y[S.value-1];for(;I-- >0;)y[S.value++]=O}else{if(!(S.value<U))return null;y[S.value++]=I}return{c:C,lc:j}}const L=new Array(59);function z(I,O,C,j,K,i){const y=O;let S=0,U=0;for(;j<=K;j++){if(y.value-O.value>C)return;let p=g(6,S,U,I,y);const N=p.l;if(S=p.c,U=p.lc,i[j]=N,N==h){if(y.value-O.value>C)throw new Error("Error in HufUnpackEncTable");p=g(8,S,U,I,y);let N=p.l+r;if(S=p.c,U=p.lc,j+N>K+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)i[j++]=0;j--}else if(N>=E){let I=N-E+2;if(j+I>K+1)throw new Error("Error in HufUnpackEncTable");for(;I--;)i[j++]=0;j--}}!function(I){for(let C=0;C<=58;++C)L[C]=0;for(let C=0;C<Z;++C)L[I[C]]+=1;let O=0;for(let C=58;C>0;--C){const I=O+L[C]>>1;L[C]=O,O=I}for(let C=0;C<Z;++C){const O=I[C];O>0&&(I[C]=O|L[O]++<<6)}}(i)}function k(I){return 63&I}function A(I){return I>>6}function P(I,O,C,j,K,i){const y=C.value,S=X(O,C),U=X(O,C);C.value+=4;const p=X(O,C);if(C.value+=4,S<0||S>=Z||U<0||U>=Z)throw new Error("Wrong HUF_ENCSIZE");const N=new Array(Z),Q=new Array(q);!function(I){for(let O=0;O<q;O++)I[O]={},I[O].len=0,I[O].lit=0,I[O].p=null}(Q);if(z(I,C,j-(C.value-y),S,U,N),p>8*(j-(C.value-y)))throw new Error("Wrong hufUncompress");!function(I,O,C,j){for(;O<=C;O++){const C=A(I[O]),K=k(I[O]);if(C>>K)throw new Error("Invalid table entry");if(K>s){const I=j[C>>K-s];if(I.len)throw new Error("Invalid table entry");if(I.lit++,I.p){const O=I.p;I.p=new Array(I.lit);for(let C=0;C<I.lit-1;++C)I.p[C]=O[C]}else I.p=new Array(1);I.p[I.lit-1]=O}else if(K){let I=0;for(let i=1<<s-K;i>0;i--){const i=j[(C<<s-K)+I];if(i.len||i.p)throw new Error("Invalid table entry");i.len=K,i.lit=O,I++}}}}(N,S,U,Q),function(I,O,C,j,K,i,y,S,U){let p=0,N=0;const Q=y,Z=Math.trunc(j.value+(K+7)/8);for(;j.value<Z;){let K=V(p,N,C,j);for(p=K.c,N=K.lc;N>=s;){const y=O[p>>N-s&mI];if(y.len){N-=y.len;const I=e(y.lit,i,p,N,C,j,S,U,Q);I&&(p=I.c,N=I.lc)}else{if(!y.p)throw new Error("hufDecode issues");let O;for(O=0;O<y.lit;O++){const s=k(I[y.p[O]]);for(;N<s&&j.value<Z;)K=V(p,N,C,j),p=K.c,N=K.lc;if(N>=s&&A(I[y.p[O]])==(p>>N-s&(1<<s)-1)){N-=s;const I=e(y.p[O],i,p,N,C,j,S,U,Q);I&&(p=I.c,N=I.lc);break}}if(O==y.lit)throw new Error("HufDecode issues")}}}const q=8-K&7;for(p>>=q,N-=q;N>0;){const I=O[p<<s-N&mI];if(!I.len)throw new Error("HufDecode issues");{N-=I.len;const O=e(I.lit,i,p,N,C,j,S,U,Q);O&&(p=O.c,N=O.lc)}}}(N,Q,I,C,p,U,i,K,{value:0})}function v(I){return 65535&I}function B(I){const O=v(I);return O>32767?O-65536:O}function F(I,O){const C=B(I),j=B(O),K=C+(1&j)+(j>>1);return{a:K,b:K-j}}function R(I,O){const C=v(I),j=v(O),K=C-(j>>1)&w;return{a:j+K-d&w,b:K}}function G(I,O,C,j,K,i,y){const S=y<16384,U=C>K?K:C;let p,N,Q=1;for(;Q<=U;)Q<<=1;for(Q>>=1,p=Q,Q>>=1;Q>=1;){N=0;const y=N+i*(K-p),U=i*Q,s=i*p,Z=j*Q,q=j*p;let mI,E,h,r;for(;N<=y;N+=s){let K=N;const i=N+j*(C-p);for(;K<=i;K+=q){const C=K+Z,j=K+U,i=j+Z;if(S){let y=F(I[K+O],I[j+O]);mI=y.a,h=y.b,y=F(I[C+O],I[i+O]),E=y.a,r=y.b,y=F(mI,E),I[K+O]=y.a,I[C+O]=y.b,y=F(h,r),I[j+O]=y.a,I[i+O]=y.b}else{let y=R(I[K+O],I[j+O]);mI=y.a,h=y.b,y=R(I[C+O],I[i+O]),E=y.a,r=y.b,y=R(mI,E),I[K+O]=y.a,I[C+O]=y.b,y=R(h,r),I[j+O]=y.a,I[i+O]=y.b}}if(C&Q){const C=K+U;let j;j=S?F(I[K+O],I[C+O]):R(I[K+O],I[C+O]),mI=j.a,I[C+O]=j.b,I[K+O]=mI}}if(K&Q){let K=N;const i=N+j*(C-p);for(;K<=i;K+=q){const C=K+Z;let j;j=S?F(I[K+O],I[C+O]):R(I[K+O],I[C+O]),mI=j.a,I[C+O]=j.b,I[K+O]=mI}}p=Q,Q>>=1}return N}function II(I){return new DataView(I.array.buffer,I.offset.value,I.size)}function OI(I){const O=I.viewer.buffer.slice(I.offset.value,I.offset.value+I.size),C=new Uint8Array(function(I){let O=I.byteLength;const C=[];let j=0;const K=new DataView(I);for(;O>0;){const I=K.getInt8(j++);if(I<0){const i=-I;O-=i+1;for(let I=0;I<i;I++)C.push(K.getUint8(j++))}else{const i=I;O-=2;const y=K.getUint8(j++);for(let I=0;I<i+1;I++)C.push(y)}}return C}(O)),j=new Uint8Array(C.length);return l(C),x(C,j),new DataView(j.buffer)}function CI(I){const O=I.array.slice(I.offset.value,I.offset.value+I.size),C=fflate.unzlibSync(O),j=new Uint8Array(C.length);return l(C),x(C,j),new DataView(j.buffer)}function jI(I){const O=I.array.slice(I.offset.value,I.offset.value+I.size),C=fflate.unzlibSync(O),j=I.lines*I.channels*I.width,K=1==I.type?new Uint16Array(j):new Uint32Array(j);let i=0,y=0;const S=new Array(4);for(let U=0;U<I.lines;U++)for(let O=0;O<I.channels;O++){let O=0;switch(I.type){case 1:S[0]=i,S[1]=S[0]+I.width,i=S[1]+I.width;for(let j=0;j<I.width;++j){O+=C[S[0]++]<<8|C[S[1]++],K[y]=O,y++}break;case 2:S[0]=i,S[1]=S[0]+I.width,S[2]=S[1]+I.width,i=S[2]+I.width;for(let j=0;j<I.width;++j){O+=C[S[0]++]<<24|C[S[1]++]<<16|C[S[2]++]<<8,K[y]=O,y++}}}return new DataView(K.buffer)}function KI(I){const O=I.viewer,C={value:I.offset.value},j=new Uint16Array(I.width*I.scanlineBlockSize*(I.channels*I.type)),K=new Uint8Array(Q);let i=0;const y=new Array(I.channels);for(let U=0;U<I.channels;U++)y[U]={},y[U].start=i,y[U].end=y[U].start,y[U].nx=I.width,y[U].ny=I.lines,y[U].size=I.type,i+=y[U].nx*y[U].ny*y[U].size;const S=H(O,C),p=H(O,C);if(p>=Q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(S<=p)for(let U=0;U<p-S+1;U++)K[U+S]=T(O,C);const s=new Uint16Array(N),Z=function(I,O){let C=0;for(let K=0;K<N;++K)(0==K||I[K>>3]&1<<(7&K))&&(O[C++]=K);const j=C-1;for(;C<N;)O[C++]=0;return j}(K,s),q=X(O,C);P(I.array,O,C,q,j,i);for(let U=0;U<I.channels;++U){const I=y[U];for(let O=0;O<y[U].size;++O)G(j,I.start+O,I.nx,I.size,I.ny,I.nx*I.size,Z)}!function(I,O,C){for(let j=0;j<C;++j)O[j]=I[O[j]]}(s,j,i);let mI=0;const E=new Uint8Array(j.buffer.byteLength);for(let N=0;N<I.lines;N++)for(let O=0;O<I.channels;O++){const I=y[O],C=I.nx*I.size,K=new Uint8Array(j.buffer,I.end*U,C*U);E.set(K,mI),mI+=C*U,I.end+=C}return new DataView(E.buffer)}var iI,yI=C(12083);!function(I){I[I.Float=0]="Float",I[I.HalfFloat=1]="HalfFloat"}(iI||(iI={}));class SI{}async function UI(I,O,C,j){const K={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:C,width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,channels:I.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(I.compression){case W.NO_COMPRESSION:K.lines=1,K.uncompress=II;break;case W.RLE_COMPRESSION:K.lines=1,K.uncompress=OI;break;case W.ZIPS_COMPRESSION:K.lines=1,K.uncompress=CI,await yI.Tools.LoadScriptAsync(SI.FFLATEUrl);break;case W.ZIP_COMPRESSION:K.lines=16,K.uncompress=CI,await yI.Tools.LoadScriptAsync(SI.FFLATEUrl);break;case W.PIZ_COMPRESSION:K.lines=32,K.uncompress=KI;break;case W.PXR24_COMPRESSION:K.lines=16,K.uncompress=jI,await yI.Tools.LoadScriptAsync(SI.FFLATEUrl);break;default:throw new Error(W[I.compression]+" is unsupported")}K.scanlineBlockSize=K.lines;const i={};for(const y of I.channels)switch(y.name){case"R":case"G":case"B":case"A":case"Y":i[y.name]=!0,K.type=y.pixelType}let S=!1;if(i.R&&i.G&&i.B&&i.A)K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G&&i.B)S=!0,K.outputChannels=4,K.decodeChannels={R:0,G:1,B:2,A:3};else if(i.R&&i.G)K.outputChannels=2,K.decodeChannels={R:0,G:1};else if(i.R)K.outputChannels=1,K.decodeChannels={R:0};else{if(!i.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");K.outputChannels=1,K.decodeChannels={Y:0}}if(1===K.type)switch(j){case iI.Float:K.getter=u,K.inputSize=U;break;case iI.HalfFloat:K.getter=H,K.inputSize=U}else{if(2!==K.type)throw new Error("Unsupported pixelType "+K.type+" for "+I.compression);switch(j){case iI.Float:K.getter=M,K.inputSize=y;break;case iI.HalfFloat:K.getter=J,K.inputSize=y}}K.blockCount=K.height/K.scanlineBlockSize;for(let y=0;y<K.blockCount;y++)a(O,C);const p=K.width*K.height*K.outputChannels;switch(j){case iI.Float:K.byteArray=new Float32Array(p),K.textureType=1,S&&K.byteArray.fill(1,0,p);break;case iI.HalfFloat:K.byteArray=new Uint16Array(p),K.textureType=2,S&&K.byteArray.fill(15360,0,p);break;default:throw new Error("Unsupported type: "+j)}let N=0;for(const y of I.channels)void 0!==K.decodeChannels[y.name]&&(K.channelLineOffsets[y.name]=N*K.width),N+=2*y.pixelType;return K.bytesPerLine=K.width*N,K.outLineWidth=K.width*K.outputChannels,"INCREASING_Y"===I.lineOrder?K.scanOrder=I=>I:K.scanOrder=I=>K.height-1-I,4==K.outputChannels?(K.format=5,K.linearSpace=!0):(K.format=6,K.linearSpace=!1),K}function pI(I,O,C,j){const K={value:0};for(let i=0;i<I.height/I.scanlineBlockSize;i++){const y=n(C,j)-O.dataWindow.yMin;I.size=X(C,j),I.lines=y+I.scanlineBlockSize>I.height?I.height-y:I.scanlineBlockSize;const S=I.size<I.lines*I.bytesPerLine&&I.uncompress?I.uncompress(I):II(I);j.value+=I.size;for(let C=0;C<I.scanlineBlockSize;C++){const j=i*I.scanlineBlockSize,y=C+I.scanOrder(j);if(y>=I.height)continue;const U=C*I.bytesPerLine,p=(I.height-1-y)*I.outLineWidth;for(let C=0;C<I.channels;C++){const j=O.channels[C].name,i=I.channelLineOffsets[j],y=I.decodeChannels[j];if(void 0!==y){K.value=U+i;for(let O=0;O<I.width;O++){const C=p+O*I.outputChannels+y;I.byteArray&&(I.byteArray[C]=I.getter(S,K))}}}}}}SI.DefaultOutputType=iI.HalfFloat,SI.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class NI{constructor(){this.supportCascades=!1}loadCubeData(I,O,C,j,K){throw".exr not supported in Cube."}loadData(I,O,C){const K=new DataView(I.buffer),i={value:0},y=t(K,i);UI(y,K,i,SI.DefaultOutputType).then((I=>{pI(I,y,K,i);const j=y.dataWindow.xMax-y.dataWindow.xMin+1,S=y.dataWindow.yMax-y.dataWindow.yMin+1;C(j,S,O.generateMipMaps,!1,(()=>{const C=O.getEngine();O.format=y.format,O.type=I.textureType,O.invertY=!1,O._gammaSpace=!y.linearSpace,I.byteArray&&C._uploadDataToTextureDirectly(O,I.byteArray,0,0,void 0,!0)}))})).catch((I=>{j.c.Error("Failed to load EXR texture: ",I)}))}}async function QI(I){const O=new DataView(I),C={value:0},K=t(O,C);try{const I=await UI(K,O,C,iI.Float);return pI(I,K,O,C),I.byteArray?{width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,data:new Float32Array(I.byteArray)}:(j.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(i){j.c.Error("Failed to load EXR data: ",i)}return{width:0,height:0,data:null}}},12282:(I,O,C)=>{function j(I){return parseInt(I.toString().replace(/\W/g,""))}function K(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-O)<=C}function i(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<O-j||I>C+j}function y(I,O){return I===O?I:Math.random()*(O-I)+I}function S(I,O,C){return I+(O-I)*C}function U(I,O,C){let j=E(O-I,360);return j>180&&(j-=360),I+j*s(C)}function p(I,O,C){let j=0;return j=I!=O?s((C-I)/(O-I)):0,j}function N(I,O,C,j,K){const i=K*K,y=K*i;return I*(2*y-3*i+1)+C*(-2*y+3*i)+O*(y-2*i+K)+j*(y-i)}function Q(I,O,C,j,K){const i=K*K;return 6*(i-K)*I+(3*i-4*K+1)*O+6*(-i+K)*C+(3*i-2*K)*j}function s(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(O,I))}function Z(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function q(I){const O=I.toString(16);return I<=15?("0"+O).toUpperCase():O.toUpperCase()}function mI(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let O=0;if(I<1){for(;I<1;)O++,I*=2;O=-O}else if(I>1)for(;I>1;)O++,I=Math.floor(I/2);return O}function E(I,O){return I-Math.floor(I/O)*O}function h(I,O,C){return(I-O)/(C-O)}function r(I,O,C){return I*(C-O)+O}function W(I,O){let C=E(O-I,360);return C>180&&(C-=360),C}function Y(I,O){const C=E(I,2*O);return O-Math.abs(C-O)}function o(I,O,C){let j=s(C);return j=-2*j*j*j+3*j*j,O*j+I*(1-j)}function c(I,O,C){let j=0;return j=Math.abs(O-I)<=C?O:I+Math.sign(O-I)*C,j}function n(I,O,C){const j=W(I,O);let K=0;return K=-C<j&&j<C?O:c(I,O=I+j,C),K}function X(I,O,C){return(I-O)/(C-O)}function T(I,O,C){return(C-O)*I+O}function H(I,O){const C=I%O;return 0===C?O:H(O,C)}C.r(O),C.d(O,{Clamp:()=>s,DeltaAngle:()=>W,Denormalize:()=>r,ExtractAsInt:()=>j,Hermite:()=>N,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>H,ILog2:()=>mI,InverseLerp:()=>p,Lerp:()=>S,LerpAngle:()=>U,MoveTowards:()=>c,MoveTowardsAngle:()=>n,Normalize:()=>h,NormalizeRadians:()=>Z,OutsideRange:()=>i,PercentToRange:()=>T,PingPong:()=>Y,RandomRange:()=>y,RangeToPercent:()=>X,Repeat:()=>E,SmoothStep:()=>o,ToHex:()=>q,WithinEpsilon:()=>K})}}]);