"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13712:(o,H,n)=>{n.r(H),n.d(H,{ReadExrDataAsync:()=>co,_ExrTextureLoader:()=>Go});var E=n(11038),k=n(11205);const g=4,O=4,Y=1,y=2,S=8,G=65536,c=G>>3,A=14,l=65537,x=1<<A,z=x-1,V=59,J=63,N=2+J-V;var h,Q;!function(o){o[o.NO_COMPRESSION=0]="NO_COMPRESSION",o[o.RLE_COMPRESSION=1]="RLE_COMPRESSION",o[o.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",o[o.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",o[o.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",o[o.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(h||(h={})),function(o){o[o.INCREASING_Y=0]="INCREASING_Y",o[o.DECREASING_Y=1]="DECREASING_Y"}(Q||(Q={}));const p=function(){const o=new ArrayBuffer(4),H=new Float32Array(o),n=new Uint32Array(o),E=new Uint32Array(512),k=new Uint32Array(512);for(let y=0;y<256;++y){const o=y-127;o<-27?(E[y]=0,E[256|y]=32768,k[y]=24,k[256|y]=24):o<-14?(E[y]=1024>>-o-14,E[256|y]=1024>>-o-14|32768,k[y]=-o-1,k[256|y]=-o-1):o<=15?(E[y]=o+15<<10,E[256|y]=o+15<<10|32768,k[y]=13,k[256|y]=13):o<128?(E[y]=31744,E[256|y]=64512,k[y]=24,k[256|y]=24):(E[y]=31744,E[256|y]=64512,k[y]=13,k[256|y]=13)}const g=new Uint32Array(2048),O=new Uint32Array(64),Y=new Uint32Array(64);for(let y=1;y<1024;++y){let o=y<<13,H=0;for(;0===(8388608&o);)o<<=1,H-=8388608;o&=-8388609,H+=947912704,g[y]=o|H}for(let y=1024;y<2048;++y)g[y]=939524096+(y-1024<<13);for(let y=1;y<31;++y)O[y]=y<<23;O[31]=1199570944,O[32]=2147483648;for(let y=33;y<63;++y)O[y]=2147483648+(y-32<<23);O[63]=3347054592;for(let y=1;y<64;++y)32!==y&&(Y[y]=1024);return{floatView:H,uint32View:n,baseTable:E,shiftTable:k,mantissaTable:g,exponentTable:O,offsetTable:Y}}();function j(o,H){const n=new Uint8Array(o);let E=0;for(;0!=n[H.value+E];)E+=1;const k=(new TextDecoder).decode(n.slice(H.value,H.value+E));return H.value=H.value+E+1,k}function m(o,H){const n=o.getInt32(H.value,!0);return H.value+=g,n}function P(o,H){const n=o.getUint32(H.value,!0);return H.value+=g,n}function b(o,H){const n=o.getUint8(H.value);return H.value+=Y,n}function e(o,H){const n=o.getUint16(H.value,!0);return H.value+=y,n}function Z(o,H){const n=o[H.value];return H.value+=Y,n}function M(o,H){let n;return n="getBigInt64"in DataView.prototype?Number(o.getBigInt64(H.value,!0)):o.getUint32(H.value+4,!0)+Number(o.getUint32(H.value,!0)<<32),H.value+=S,n}function K(o,H){const n=o.getFloat32(H.value,!0);return H.value+=O,n}function f(o,H){return function(o){const H=(31744&o)>>10,n=1023&o;return(o>>15?-1:1)*(H?31===H?n?NaN:1/0:Math.pow(2,H-15)*(1+n/1024):n/1024*6103515625e-14)}(e(o,H))}function B(o,H){return function(o){if(Math.abs(o)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");o=(0,k.Clamp)(o,-65504,65504),p.floatView[0]=o;const H=p.uint32View[0],n=H>>23&511;return p.baseTable[n]+((8388607&H)>>p.shiftTable[n])}(K(o,H))}function q(o,H,n,E){switch(n){case"string":case"stringvector":case"iccProfile":return function(o,H,n){const E=(new TextDecoder).decode(new Uint8Array(o).slice(H.value,H.value+n));return H.value=H.value+n,E}(o.buffer,H,E);case"chlist":return function(o,H,n){const E=H.value,k=[];for(;H.value<E+n-1;){const n=j(o.buffer,H),E=m(o,H),g=b(o,H);H.value+=3;const O=m(o,H),Y=m(o,H);k.push({name:n,pixelType:E,pLinear:g,xSampling:O,ySampling:Y})}return H.value+=1,k}(o,H,E);case"chromaticities":return function(o,H){return{redX:K(o,H),redY:K(o,H),greenX:K(o,H),greenY:K(o,H),blueX:K(o,H),blueY:K(o,H),whiteX:K(o,H),whiteY:K(o,H)}}(o,H);case"compression":return function(o,H){return b(o,H)}(o,H);case"box2i":return function(o,H){return{xMin:m(o,H),yMin:m(o,H),xMax:m(o,H),yMax:m(o,H)}}(o,H);case"lineOrder":return function(o,H){const n=b(o,H);return Q[n]}(o,H);case"float":return K(o,H);case"v2f":return function(o,H){return[K(o,H),K(o,H)]}(o,H);case"v3f":return function(o,H){return[K(o,H),K(o,H),K(o,H)]}(o,H);case"int":return m(o,H);case"rational":return function(o,H){return[m(o,H),P(o,H)]}(o,H);case"timecode":return function(o,H){return[P(o,H),P(o,H)]}(o,H);case"preview":return H.value+=E,"skipped";default:return void(H.value+=E)}}function D(o){for(let H=1;H<o.length;H++){const n=o[H-1]+o[H]-128;o[H]=n}}function T(o,H){let n=0,E=Math.floor((o.length+1)/2),k=0;const g=o.length-1;for(;!(k>g)&&(H[k++]=o[n++],!(k>g));)H[k++]=o[E++]}const a=20000630;function F(o,H){if(o.getUint32(0,!0)!=a)throw new Error("Incorrect OpenEXR format");const n=o.getUint8(4),k=o.getUint8(5),g={singleTile:!!(2&k),longName:!!(4&k),deepFormat:!!(8&k),multiPart:!!(16&k)};H.value=8;const O={};let Y=!0;for(;Y;){const n=j(o.buffer,H);if(n){const k=j(o.buffer,H),g=q(o,H,k,P(o,H));void 0===g?E.d.Warn(`Unknown header attribute type ${k}'.`):O[n]=g}else Y=!1}if(0!=(-5&k))throw new Error("Unsupported file format");return{version:n,spec:g,...O}}const C=32768,t=65535;function X(o,H,n,E,k){for(;n<o;)H=H<<8|Z(E,k),n+=8;return{l:H>>(n-=o)&(1<<o)-1,c:H,lc:n}}function s(o,H,n,E){return{c:o=o<<8|Z(n,E),lc:H+=8}}function U(o,H,n,E,k,g,O,Y,y){if(o==H){if(E<8){const o=s(n,E,k,g);n=o.c,E=o.lc}let o=n>>(E-=8);if(o=new Uint8Array([o])[0],Y.value+o>y)return null;const H=O[Y.value-1];for(;o-- >0;)O[Y.value++]=H}else{if(!(Y.value<y))return null;O[Y.value++]=o}return{c:n,lc:E}}const I=new Array(59);function v(o,H,n,E,k,g){const O=H;let Y=0,y=0;for(;E<=k;E++){if(O.value-H.value>n)return;let S=X(6,Y,y,o,O);const G=S.l;if(Y=S.c,y=S.lc,g[E]=G,G==J){if(O.value-H.value>n)throw new Error("Error in HufUnpackEncTable");S=X(8,Y,y,o,O);let G=S.l+N;if(Y=S.c,y=S.lc,E+G>k+1)throw new Error("Error in HufUnpackEncTable");for(;G--;)g[E++]=0;E--}else if(G>=V){let o=G-V+2;if(E+o>k+1)throw new Error("Error in HufUnpackEncTable");for(;o--;)g[E++]=0;E--}}!function(o){for(let n=0;n<=58;++n)I[n]=0;for(let n=0;n<l;++n)I[o[n]]+=1;let H=0;for(let n=58;n>0;--n){const o=H+I[n]>>1;I[n]=H,H=o}for(let n=0;n<l;++n){const H=o[n];H>0&&(o[n]=H|I[H]++<<6)}}(g)}function w(o){return 63&o}function r(o){return o>>6}function u(o,H,n,E,k,g){const O=n.value,Y=P(H,n),y=P(H,n);n.value+=4;const S=P(H,n);if(n.value+=4,Y<0||Y>=l||y<0||y>=l)throw new Error("Wrong HUF_ENCSIZE");const G=new Array(l),c=new Array(x);!function(o){for(let H=0;H<x;H++)o[H]={},o[H].len=0,o[H].lit=0,o[H].p=null}(c);if(v(o,n,E-(n.value-O),Y,y,G),S>8*(E-(n.value-O)))throw new Error("Wrong hufUncompress");!function(o,H,n,E){for(;H<=n;H++){const n=r(o[H]),k=w(o[H]);if(n>>k)throw new Error("Invalid table entry");if(k>A){const o=E[n>>k-A];if(o.len)throw new Error("Invalid table entry");if(o.lit++,o.p){const H=o.p;o.p=new Array(o.lit);for(let n=0;n<o.lit-1;++n)o.p[n]=H[n]}else o.p=new Array(1);o.p[o.lit-1]=H}else if(k){let o=0;for(let g=1<<A-k;g>0;g--){const g=E[(n<<A-k)+o];if(g.len||g.p)throw new Error("Invalid table entry");g.len=k,g.lit=H,o++}}}}(G,Y,y,c),function(o,H,n,E,k,g,O,Y,y){let S=0,G=0;const c=O,l=Math.trunc(E.value+(k+7)/8);for(;E.value<l;){let k=s(S,G,n,E);for(S=k.c,G=k.lc;G>=A;){const O=H[S>>G-A&z];if(O.len){G-=O.len;const o=U(O.lit,g,S,G,n,E,Y,y,c);o&&(S=o.c,G=o.lc)}else{if(!O.p)throw new Error("hufDecode issues");let H;for(H=0;H<O.lit;H++){const A=w(o[O.p[H]]);for(;G<A&&E.value<l;)k=s(S,G,n,E),S=k.c,G=k.lc;if(G>=A&&r(o[O.p[H]])==(S>>G-A&(1<<A)-1)){G-=A;const o=U(O.p[H],g,S,G,n,E,Y,y,c);o&&(S=o.c,G=o.lc);break}}if(H==O.lit)throw new Error("HufDecode issues")}}}const x=8-k&7;for(S>>=x,G-=x;G>0;){const o=H[S<<A-G&z];if(!o.len)throw new Error("HufDecode issues");{G-=o.len;const H=U(o.lit,g,S,G,n,E,Y,y,c);H&&(S=H.c,G=H.lc)}}}(G,c,o,n,S,y,g,k,{value:0})}function d(o){return 65535&o}function R(o){const H=d(o);return H>32767?H-65536:H}function W(o,H){const n=R(o),E=R(H),k=n+(1&E)+(E>>1);return{a:k,b:k-E}}function i(o,H){const n=d(o),E=d(H),k=n-(E>>1)&t;return{a:E+k-C&t,b:k}}function L(o,H,n,E,k,g,O){const Y=O<16384,y=n>k?k:n;let S,G,c=1;for(;c<=y;)c<<=1;for(c>>=1,S=c,c>>=1;c>=1;){G=0;const O=G+g*(k-S),y=g*c,A=g*S,l=E*c,x=E*S;let z,V,J,N;for(;G<=O;G+=A){let k=G;const g=G+E*(n-S);for(;k<=g;k+=x){const n=k+l,E=k+y,g=E+l;if(Y){let O=W(o[k+H],o[E+H]);z=O.a,J=O.b,O=W(o[n+H],o[g+H]),V=O.a,N=O.b,O=W(z,V),o[k+H]=O.a,o[n+H]=O.b,O=W(J,N),o[E+H]=O.a,o[g+H]=O.b}else{let O=i(o[k+H],o[E+H]);z=O.a,J=O.b,O=i(o[n+H],o[g+H]),V=O.a,N=O.b,O=i(z,V),o[k+H]=O.a,o[n+H]=O.b,O=i(J,N),o[E+H]=O.a,o[g+H]=O.b}}if(n&c){const n=k+y;let E;E=Y?W(o[k+H],o[n+H]):i(o[k+H],o[n+H]),z=E.a,o[n+H]=E.b,o[k+H]=z}}if(k&c){let k=G;const g=G+E*(n-S);for(;k<=g;k+=x){const n=k+l;let E;E=Y?W(o[k+H],o[n+H]):i(o[k+H],o[n+H]),z=E.a,o[n+H]=E.b,o[k+H]=z}}S=c,c>>=1}return G}function oo(o){return new DataView(o.array.buffer,o.offset.value,o.size)}function Ho(o){const H=o.viewer.buffer.slice(o.offset.value,o.offset.value+o.size),n=new Uint8Array(function(o){let H=o.byteLength;const n=[];let E=0;const k=new DataView(o);for(;H>0;){const o=k.getInt8(E++);if(o<0){const g=-o;H-=g+1;for(let o=0;o<g;o++)n.push(k.getUint8(E++))}else{const g=o;H-=2;const O=k.getUint8(E++);for(let o=0;o<g+1;o++)n.push(O)}}return n}(H)),E=new Uint8Array(n.length);return D(n),T(n,E),new DataView(E.buffer)}function no(o){const H=o.array.slice(o.offset.value,o.offset.value+o.size),n=fflate.unzlibSync(H),E=new Uint8Array(n.length);return D(n),T(n,E),new DataView(E.buffer)}function Eo(o){const H=o.array.slice(o.offset.value,o.offset.value+o.size),n=fflate.unzlibSync(H),E=o.lines*o.channels*o.width,k=1==o.type?new Uint16Array(E):new Uint32Array(E);let g=0,O=0;const Y=new Array(4);for(let y=0;y<o.lines;y++)for(let H=0;H<o.channels;H++){let H=0;switch(o.type){case 1:Y[0]=g,Y[1]=Y[0]+o.width,g=Y[1]+o.width;for(let E=0;E<o.width;++E){H+=n[Y[0]++]<<8|n[Y[1]++],k[O]=H,O++}break;case 2:Y[0]=g,Y[1]=Y[0]+o.width,Y[2]=Y[1]+o.width,g=Y[2]+o.width;for(let E=0;E<o.width;++E){H+=n[Y[0]++]<<24|n[Y[1]++]<<16|n[Y[2]++]<<8,k[O]=H,O++}}}return new DataView(k.buffer)}function ko(o){const H=o.viewer,n={value:o.offset.value},E=new Uint16Array(o.width*o.scanlineBlockSize*(o.channels*o.type)),k=new Uint8Array(c);let g=0;const O=new Array(o.channels);for(let y=0;y<o.channels;y++)O[y]={},O[y].start=g,O[y].end=O[y].start,O[y].nx=o.width,O[y].ny=o.lines,O[y].size=o.type,g+=O[y].nx*O[y].ny*O[y].size;const Y=e(H,n),S=e(H,n);if(S>=c)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Y<=S)for(let y=0;y<S-Y+1;y++)k[y+Y]=b(H,n);const A=new Uint16Array(G),l=function(o,H){let n=0;for(let k=0;k<G;++k)(0==k||o[k>>3]&1<<(7&k))&&(H[n++]=k);const E=n-1;for(;n<G;)H[n++]=0;return E}(k,A),x=P(H,n);u(o.array,H,n,x,E,g);for(let y=0;y<o.channels;++y){const o=O[y];for(let H=0;H<O[y].size;++H)L(E,o.start+H,o.nx,o.size,o.ny,o.nx*o.size,l)}!function(o,H,n){for(let E=0;E<n;++E)H[E]=o[H[E]]}(A,E,g);let z=0;const V=new Uint8Array(E.buffer.byteLength);for(let G=0;G<o.lines;G++)for(let H=0;H<o.channels;H++){const o=O[H],n=o.nx*o.size,k=new Uint8Array(E.buffer,o.end*y,n*y);V.set(k,z),z+=n*y,o.end+=n}return new DataView(V.buffer)}var go,Oo=n(11024);!function(o){o[o.Float=0]="Float",o[o.HalfFloat=1]="HalfFloat"}(go||(go={}));class Yo{}async function yo(o,H,n,E){const k={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:n,width:o.dataWindow.xMax-o.dataWindow.xMin+1,height:o.dataWindow.yMax-o.dataWindow.yMin+1,channels:o.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(o.compression){case h.NO_COMPRESSION:k.lines=1,k.uncompress=oo;break;case h.RLE_COMPRESSION:k.lines=1,k.uncompress=Ho;break;case h.ZIPS_COMPRESSION:k.lines=1,k.uncompress=no,await Oo.Tools.LoadScriptAsync(Yo.FFLATEUrl);break;case h.ZIP_COMPRESSION:k.lines=16,k.uncompress=no,await Oo.Tools.LoadScriptAsync(Yo.FFLATEUrl);break;case h.PIZ_COMPRESSION:k.lines=32,k.uncompress=ko;break;case h.PXR24_COMPRESSION:k.lines=16,k.uncompress=Eo,await Oo.Tools.LoadScriptAsync(Yo.FFLATEUrl);break;default:throw new Error(h[o.compression]+" is unsupported")}k.scanlineBlockSize=k.lines;const g={};for(const O of o.channels)switch(O.name){case"R":case"G":case"B":case"A":case"Y":g[O.name]=!0,k.type=O.pixelType}let Y=!1;if(g.R&&g.G&&g.B&&g.A)k.outputChannels=4,k.decodeChannels={R:0,G:1,B:2,A:3};else if(g.R&&g.G&&g.B)Y=!0,k.outputChannels=4,k.decodeChannels={R:0,G:1,B:2,A:3};else if(g.R&&g.G)k.outputChannels=2,k.decodeChannels={R:0,G:1};else if(g.R)k.outputChannels=1,k.decodeChannels={R:0};else{if(!g.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");k.outputChannels=1,k.decodeChannels={Y:0}}if(1===k.type)switch(E){case go.Float:k.getter=f,k.inputSize=y;break;case go.HalfFloat:k.getter=e,k.inputSize=y}else{if(2!==k.type)throw new Error("Unsupported pixelType "+k.type+" for "+o.compression);switch(E){case go.Float:k.getter=K,k.inputSize=O;break;case go.HalfFloat:k.getter=B,k.inputSize=O}}k.blockCount=k.height/k.scanlineBlockSize;for(let O=0;O<k.blockCount;O++)M(H,n);const S=k.width*k.height*k.outputChannels;switch(E){case go.Float:k.byteArray=new Float32Array(S),k.textureType=1,Y&&k.byteArray.fill(1,0,S);break;case go.HalfFloat:k.byteArray=new Uint16Array(S),k.textureType=2,Y&&k.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+E)}let G=0;for(const O of o.channels)void 0!==k.decodeChannels[O.name]&&(k.channelLineOffsets[O.name]=G*k.width),G+=2*O.pixelType;return k.bytesPerLine=k.width*G,k.outLineWidth=k.width*k.outputChannels,"INCREASING_Y"===o.lineOrder?k.scanOrder=o=>o:k.scanOrder=o=>k.height-1-o,4==k.outputChannels?(k.format=5,k.linearSpace=!0):(k.format=6,k.linearSpace=!1),k}function So(o,H,n,E){const k={value:0};for(let g=0;g<o.height/o.scanlineBlockSize;g++){const O=m(n,E)-H.dataWindow.yMin;o.size=P(n,E),o.lines=O+o.scanlineBlockSize>o.height?o.height-O:o.scanlineBlockSize;const Y=o.size<o.lines*o.bytesPerLine&&o.uncompress?o.uncompress(o):oo(o);E.value+=o.size;for(let n=0;n<o.scanlineBlockSize;n++){const E=g*o.scanlineBlockSize,O=n+o.scanOrder(E);if(O>=o.height)continue;const y=n*o.bytesPerLine,S=(o.height-1-O)*o.outLineWidth;for(let n=0;n<o.channels;n++){const E=H.channels[n].name,g=o.channelLineOffsets[E],O=o.decodeChannels[E];if(void 0!==O){k.value=y+g;for(let H=0;H<o.width;H++){const n=S+H*o.outputChannels+O;o.byteArray&&(o.byteArray[n]=o.getter(Y,k))}}}}}}Yo.DefaultOutputType=go.HalfFloat,Yo.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Go{constructor(){this.supportCascades=!1}loadCubeData(o,H,n,E,k){throw".exr not supported in Cube."}loadData(o,H,n){const k=new DataView(o.buffer),g={value:0},O=F(k,g);yo(O,k,g,Yo.DefaultOutputType).then((o=>{So(o,O,k,g);const E=O.dataWindow.xMax-O.dataWindow.xMin+1,Y=O.dataWindow.yMax-O.dataWindow.yMin+1;n(E,Y,H.generateMipMaps,!1,(()=>{const n=H.getEngine();H.format=O.format,H.type=o.textureType,H.invertY=!1,H._gammaSpace=!O.linearSpace,o.byteArray&&n._uploadDataToTextureDirectly(H,o.byteArray,0,0,void 0,!0)}))})).catch((o=>{E.d.Error("Failed to load EXR texture: ",o)}))}}async function co(o){const H=new DataView(o),n={value:0},k=F(H,n);try{const o=await yo(k,H,n,go.Float);return So(o,k,H,n),o.byteArray?{width:k.dataWindow.xMax-k.dataWindow.xMin+1,height:k.dataWindow.yMax-k.dataWindow.yMin+1,data:new Float32Array(o.byteArray)}:(E.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(g){E.d.Error("Failed to load EXR data: ",g)}return{width:0,height:0,data:null}}},11205:(o,H,n)=>{function E(o){return parseInt(o.toString().replace(/\W/g,""))}function k(o,H){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(o-H)<=n}function g(o,H,n){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return o<H-E||o>n+E}function O(o,H){return o===H?o:Math.random()*(H-o)+o}function Y(o,H,n){return o+(H-o)*n}function y(o,H,n){let E=V(H-o,360);return E>180&&(E-=360),o+E*A(n)}function S(o,H,n){let E=0;return E=o!=H?A((n-o)/(H-o)):0,E}function G(o,H,n,E,k){const g=k*k,O=k*g;return o*(2*O-3*g+1)+n*(-2*O+3*g)+H*(O-2*g+k)+E*(O-g)}function c(o,H,n,E,k){const g=k*k;return 6*(g-k)*o+(3*g-4*k+1)*H+6*(-g+k)*n+(3*g-2*k)*E}function A(o){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(n,Math.max(H,o))}function l(o){return o-=2*Math.PI*Math.floor((o+Math.PI)/(2*Math.PI))}function x(o){const H=o.toString(16);return o<=15?("0"+H).toUpperCase():H.toUpperCase()}function z(o){if(Math.log2)return Math.floor(Math.log2(o));if(o<0)return NaN;if(0===o)return-1/0;let H=0;if(o<1){for(;o<1;)H++,o*=2;H=-H}else if(o>1)for(;o>1;)H++,o=Math.floor(o/2);return H}function V(o,H){return o-Math.floor(o/H)*H}function J(o,H,n){return(o-H)/(n-H)}function N(o,H,n){return o*(n-H)+H}function h(o,H){let n=V(H-o,360);return n>180&&(n-=360),n}function Q(o,H){const n=V(o,2*H);return H-Math.abs(n-H)}function p(o,H,n){let E=A(n);return E=-2*E*E*E+3*E*E,H*E+o*(1-E)}function j(o,H,n){let E=0;return E=Math.abs(H-o)<=n?H:o+Math.sign(H-o)*n,E}function m(o,H,n){const E=h(o,H);let k=0;return k=-n<E&&E<n?H:j(o,H=o+E,n),k}function P(o,H,n){return(o-H)/(n-H)}function b(o,H,n){return(n-H)*o+H}function e(o,H){const n=o%H;return 0===n?H:e(H,n)}n.r(H),n.d(H,{Clamp:()=>A,DeltaAngle:()=>h,Denormalize:()=>N,ExtractAsInt:()=>E,Hermite:()=>G,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>e,ILog2:()=>z,InverseLerp:()=>S,Lerp:()=>Y,LerpAngle:()=>y,MoveTowards:()=>j,MoveTowardsAngle:()=>m,Normalize:()=>J,NormalizeRadians:()=>l,OutsideRange:()=>g,PercentToRange:()=>b,PingPong:()=>Q,RandomRange:()=>O,RangeToPercent:()=>P,Repeat:()=>V,SmoothStep:()=>p,ToHex:()=>x,WithinEpsilon:()=>k})}}]);