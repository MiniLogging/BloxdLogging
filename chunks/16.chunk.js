"use strict";(self.vb3rpbgyozo=self.vb3rpbgyozo||[]).push([[16],{15217:(q,I,l)=>{l.r(I),l.d(I,{ReadExrDataAsync:()=>rq,_ExrTextureLoader:()=>Zq});var w=l(12591),t=l(12761);const O=4,c=4,a=1,F=2,s=8,Z=65536,r=Z>>3,x=14,o=65537,d=1<<x,T=d-1,V=59,U=63,B=2+U-V;var v,k;!function(q){q[q.NO_COMPRESSION=0]="NO_COMPRESSION",q[q.RLE_COMPRESSION=1]="RLE_COMPRESSION",q[q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",q[q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",q[q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",q[q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(v||(v={})),function(q){q[q.INCREASING_Y=0]="INCREASING_Y",q[q.DECREASING_Y=1]="DECREASING_Y"}(k||(k={}));const C=function(){const q=new ArrayBuffer(4),I=new Float32Array(q),l=new Uint32Array(q),w=new Uint32Array(512),t=new Uint32Array(512);for(let F=0;F<256;++F){const q=F-127;q<-27?(w[F]=0,w[256|F]=32768,t[F]=24,t[256|F]=24):q<-14?(w[F]=1024>>-q-14,w[256|F]=1024>>-q-14|32768,t[F]=-q-1,t[256|F]=-q-1):q<=15?(w[F]=q+15<<10,w[256|F]=q+15<<10|32768,t[F]=13,t[256|F]=13):q<128?(w[F]=31744,w[256|F]=64512,t[F]=24,t[256|F]=24):(w[F]=31744,w[256|F]=64512,t[F]=13,t[256|F]=13)}const O=new Uint32Array(2048),c=new Uint32Array(64),a=new Uint32Array(64);for(let F=1;F<1024;++F){let q=F<<13,I=0;for(;0===(8388608&q);)q<<=1,I-=8388608;q&=-8388609,I+=947912704,O[F]=q|I}for(let F=1024;F<2048;++F)O[F]=939524096+(F-1024<<13);for(let F=1;F<31;++F)c[F]=F<<23;c[31]=1199570944,c[32]=2147483648;for(let F=33;F<63;++F)c[F]=2147483648+(F-32<<23);c[63]=3347054592;for(let F=1;F<64;++F)32!==F&&(a[F]=1024);return{floatView:I,uint32View:l,baseTable:w,shiftTable:t,mantissaTable:O,exponentTable:c,offsetTable:a}}();function R(q,I){const l=new Uint8Array(q);let w=0;for(;0!=l[I.value+w];)w+=1;const t=(new TextDecoder).decode(l.slice(I.value,I.value+w));return I.value=I.value+w+1,t}function W(q,I){const l=q.getInt32(I.value,!0);return I.value+=O,l}function e(q,I){const l=q.getUint32(I.value,!0);return I.value+=O,l}function i(q,I){const l=q.getUint8(I.value);return I.value+=a,l}function S(q,I){const l=q.getUint16(I.value,!0);return I.value+=F,l}function g(q,I){const l=q[I.value];return I.value+=a,l}function p(q,I){let l;return l="getBigInt64"in DataView.prototype?Number(q.getBigInt64(I.value,!0)):q.getUint32(I.value+4,!0)+Number(q.getUint32(I.value,!0)<<32),I.value+=s,l}function X(q,I){const l=q.getFloat32(I.value,!0);return I.value+=c,l}function K(q,I){return function(q){const I=(31744&q)>>10,l=1023&q;return(q>>15?-1:1)*(I?31===I?l?NaN:1/0:Math.pow(2,I-15)*(1+l/1024):l/1024*6103515625e-14)}(S(q,I))}function D(q,I){return function(q){if(Math.abs(q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");q=(0,t.Clamp)(q,-65504,65504),C.floatView[0]=q;const I=C.uint32View[0],l=I>>23&511;return C.baseTable[l]+((8388607&I)>>C.shiftTable[l])}(X(q,I))}function M(q,I,l,w){switch(l){case"string":case"stringvector":case"iccProfile":return function(q,I,l){const w=(new TextDecoder).decode(new Uint8Array(q).slice(I.value,I.value+l));return I.value=I.value+l,w}(q.buffer,I,w);case"chlist":return function(q,I,l){const w=I.value,t=[];for(;I.value<w+l-1;){const l=R(q.buffer,I),w=W(q,I),O=i(q,I);I.value+=3;const c=W(q,I),a=W(q,I);t.push({name:l,pixelType:w,pLinear:O,xSampling:c,ySampling:a})}return I.value+=1,t}(q,I,w);case"chromaticities":return function(q,I){return{redX:X(q,I),redY:X(q,I),greenX:X(q,I),greenY:X(q,I),blueX:X(q,I),blueY:X(q,I),whiteX:X(q,I),whiteY:X(q,I)}}(q,I);case"compression":return function(q,I){return i(q,I)}(q,I);case"box2i":return function(q,I){return{xMin:W(q,I),yMin:W(q,I),xMax:W(q,I),yMax:W(q,I)}}(q,I);case"lineOrder":return function(q,I){const l=i(q,I);return k[l]}(q,I);case"float":return X(q,I);case"v2f":return function(q,I){return[X(q,I),X(q,I)]}(q,I);case"v3f":return function(q,I){return[X(q,I),X(q,I),X(q,I)]}(q,I);case"int":return W(q,I);case"rational":return function(q,I){return[W(q,I),e(q,I)]}(q,I);case"timecode":return function(q,I){return[e(q,I),e(q,I)]}(q,I);case"preview":return I.value+=w,"skipped";default:return void(I.value+=w)}}function n(q){for(let I=1;I<q.length;I++){const l=q[I-1]+q[I]-128;q[I]=l}}function f(q,I){let l=0,w=Math.floor((q.length+1)/2),t=0;const O=q.length-1;for(;!(t>O)&&(I[t++]=q[l++],!(t>O));)I[t++]=q[w++]}const L=20000630;function E(q,I){if(q.getUint32(0,!0)!=L)throw new Error("Incorrect OpenEXR format");const l=q.getUint8(4),t=q.getUint8(5),O={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};I.value=8;const c={};let a=!0;for(;a;){const l=R(q.buffer,I);if(l){const t=R(q.buffer,I),O=M(q,I,t,e(q,I));void 0===O?w.b.Warn(`Unknown header attribute type ${t}'.`):c[l]=O}else a=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:l,spec:O,...c}}const j=32768,h=65535;function u(q,I,l,w,t){for(;l<q;)I=I<<8|g(w,t),l+=8;return{l:I>>(l-=q)&(1<<q)-1,c:I,lc:l}}function P(q,I,l,w){return{c:q=q<<8|g(l,w),lc:I+=8}}function mq(q,I,l,w,t,O,c,a,F){if(q==I){if(w<8){const q=P(l,w,t,O);l=q.c,w=q.lc}let q=l>>(w-=8);if(q=new Uint8Array([q])[0],a.value+q>F)return null;const I=c[a.value-1];for(;q-- >0;)c[a.value++]=I}else{if(!(a.value<F))return null;c[a.value++]=q}return{c:l,lc:w}}const Y=new Array(59);function y(q,I,l,w,t,O){const c=I;let a=0,F=0;for(;w<=t;w++){if(c.value-I.value>l)return;let s=u(6,a,F,q,c);const Z=s.l;if(a=s.c,F=s.lc,O[w]=Z,Z==U){if(c.value-I.value>l)throw new Error("Error in HufUnpackEncTable");s=u(8,a,F,q,c);let Z=s.l+B;if(a=s.c,F=s.lc,w+Z>t+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)O[w++]=0;w--}else if(Z>=V){let q=Z-V+2;if(w+q>t+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)O[w++]=0;w--}}!function(q){for(let l=0;l<=58;++l)Y[l]=0;for(let l=0;l<o;++l)Y[q[l]]+=1;let I=0;for(let l=58;l>0;--l){const q=I+Y[l]>>1;Y[l]=I,I=q}for(let l=0;l<o;++l){const I=q[l];I>0&&(q[l]=I|Y[I]++<<6)}}(O)}function G(q){return 63&q}function N(q){return q>>6}function J(q,I,l,w,t,O){const c=l.value,a=e(I,l),F=e(I,l);l.value+=4;const s=e(I,l);if(l.value+=4,a<0||a>=o||F<0||F>=o)throw new Error("Wrong HUF_ENCSIZE");const Z=new Array(o),r=new Array(d);!function(q){for(let I=0;I<d;I++)q[I]={},q[I].len=0,q[I].lit=0,q[I].p=null}(r);if(y(q,l,w-(l.value-c),a,F,Z),s>8*(w-(l.value-c)))throw new Error("Wrong hufUncompress");!function(q,I,l,w){for(;I<=l;I++){const l=N(q[I]),t=G(q[I]);if(l>>t)throw new Error("Invalid table entry");if(t>x){const q=w[l>>t-x];if(q.len)throw new Error("Invalid table entry");if(q.lit++,q.p){const I=q.p;q.p=new Array(q.lit);for(let l=0;l<q.lit-1;++l)q.p[l]=I[l]}else q.p=new Array(1);q.p[q.lit-1]=I}else if(t){let q=0;for(let O=1<<x-t;O>0;O--){const O=w[(l<<x-t)+q];if(O.len||O.p)throw new Error("Invalid table entry");O.len=t,O.lit=I,q++}}}}(Z,a,F,r),function(q,I,l,w,t,O,c,a,F){let s=0,Z=0;const r=c,o=Math.trunc(w.value+(t+7)/8);for(;w.value<o;){let t=P(s,Z,l,w);for(s=t.c,Z=t.lc;Z>=x;){const c=I[s>>Z-x&T];if(c.len){Z-=c.len;const q=mq(c.lit,O,s,Z,l,w,a,F,r);q&&(s=q.c,Z=q.lc)}else{if(!c.p)throw new Error("hufDecode issues");let I;for(I=0;I<c.lit;I++){const x=G(q[c.p[I]]);for(;Z<x&&w.value<o;)t=P(s,Z,l,w),s=t.c,Z=t.lc;if(Z>=x&&N(q[c.p[I]])==(s>>Z-x&(1<<x)-1)){Z-=x;const q=mq(c.p[I],O,s,Z,l,w,a,F,r);q&&(s=q.c,Z=q.lc);break}}if(I==c.lit)throw new Error("HufDecode issues")}}}const d=8-t&7;for(s>>=d,Z-=d;Z>0;){const q=I[s<<x-Z&T];if(!q.len)throw new Error("HufDecode issues");{Z-=q.len;const I=mq(q.lit,O,s,Z,l,w,a,F,r);I&&(s=I.c,Z=I.lc)}}}(Z,r,q,l,s,F,O,t,{value:0})}function z(q){return 65535&q}function H(q){const I=z(q);return I>32767?I-65536:I}function A(q,I){const l=H(q),w=H(I),t=l+(1&w)+(w>>1);return{a:t,b:t-w}}function Q(q,I){const l=z(q),w=z(I),t=l-(w>>1)&h;return{a:w+t-j&h,b:t}}function b(q,I,l,w,t,O,c){const a=c<16384,F=l>t?t:l;let s,Z,r=1;for(;r<=F;)r<<=1;for(r>>=1,s=r,r>>=1;r>=1;){Z=0;const c=Z+O*(t-s),F=O*r,x=O*s,o=w*r,d=w*s;let T,V,U,B;for(;Z<=c;Z+=x){let t=Z;const O=Z+w*(l-s);for(;t<=O;t+=d){const l=t+o,w=t+F,O=w+o;if(a){let c=A(q[t+I],q[w+I]);T=c.a,U=c.b,c=A(q[l+I],q[O+I]),V=c.a,B=c.b,c=A(T,V),q[t+I]=c.a,q[l+I]=c.b,c=A(U,B),q[w+I]=c.a,q[O+I]=c.b}else{let c=Q(q[t+I],q[w+I]);T=c.a,U=c.b,c=Q(q[l+I],q[O+I]),V=c.a,B=c.b,c=Q(T,V),q[t+I]=c.a,q[l+I]=c.b,c=Q(U,B),q[w+I]=c.a,q[O+I]=c.b}}if(l&r){const l=t+F;let w;w=a?A(q[t+I],q[l+I]):Q(q[t+I],q[l+I]),T=w.a,q[l+I]=w.b,q[t+I]=T}}if(t&r){let t=Z;const O=Z+w*(l-s);for(;t<=O;t+=d){const l=t+o;let w;w=a?A(q[t+I],q[l+I]):Q(q[t+I],q[l+I]),T=w.a,q[l+I]=w.b,q[t+I]=T}}s=r,r>>=1}return Z}function qq(q){return new DataView(q.array.buffer,q.offset.value,q.size)}function Iq(q){const I=q.viewer.buffer.slice(q.offset.value,q.offset.value+q.size),l=new Uint8Array(function(q){let I=q.byteLength;const l=[];let w=0;const t=new DataView(q);for(;I>0;){const q=t.getInt8(w++);if(q<0){const O=-q;I-=O+1;for(let q=0;q<O;q++)l.push(t.getUint8(w++))}else{const O=q;I-=2;const c=t.getUint8(w++);for(let q=0;q<O+1;q++)l.push(c)}}return l}(I)),w=new Uint8Array(l.length);return n(l),f(l,w),new DataView(w.buffer)}function lq(q){const I=q.array.slice(q.offset.value,q.offset.value+q.size),l=fflate.unzlibSync(I),w=new Uint8Array(l.length);return n(l),f(l,w),new DataView(w.buffer)}function wq(q){const I=q.array.slice(q.offset.value,q.offset.value+q.size),l=fflate.unzlibSync(I),w=q.lines*q.channels*q.width,t=1==q.type?new Uint16Array(w):new Uint32Array(w);let O=0,c=0;const a=new Array(4);for(let F=0;F<q.lines;F++)for(let I=0;I<q.channels;I++){let I=0;switch(q.type){case 1:a[0]=O,a[1]=a[0]+q.width,O=a[1]+q.width;for(let w=0;w<q.width;++w){I+=l[a[0]++]<<8|l[a[1]++],t[c]=I,c++}break;case 2:a[0]=O,a[1]=a[0]+q.width,a[2]=a[1]+q.width,O=a[2]+q.width;for(let w=0;w<q.width;++w){I+=l[a[0]++]<<24|l[a[1]++]<<16|l[a[2]++]<<8,t[c]=I,c++}}}return new DataView(t.buffer)}function tq(q){const I=q.viewer,l={value:q.offset.value},w=new Uint16Array(q.width*q.scanlineBlockSize*(q.channels*q.type)),t=new Uint8Array(r);let O=0;const c=new Array(q.channels);for(let F=0;F<q.channels;F++)c[F]={},c[F].start=O,c[F].end=c[F].start,c[F].nx=q.width,c[F].ny=q.lines,c[F].size=q.type,O+=c[F].nx*c[F].ny*c[F].size;const a=S(I,l),s=S(I,l);if(s>=r)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=s)for(let F=0;F<s-a+1;F++)t[F+a]=i(I,l);const x=new Uint16Array(Z),o=function(q,I){let l=0;for(let t=0;t<Z;++t)(0==t||q[t>>3]&1<<(7&t))&&(I[l++]=t);const w=l-1;for(;l<Z;)I[l++]=0;return w}(t,x),d=e(I,l);J(q.array,I,l,d,w,O);for(let F=0;F<q.channels;++F){const q=c[F];for(let I=0;I<c[F].size;++I)b(w,q.start+I,q.nx,q.size,q.ny,q.nx*q.size,o)}!function(q,I,l){for(let w=0;w<l;++w)I[w]=q[I[w]]}(x,w,O);let T=0;const V=new Uint8Array(w.buffer.byteLength);for(let Z=0;Z<q.lines;Z++)for(let I=0;I<q.channels;I++){const q=c[I],l=q.nx*q.size,t=new Uint8Array(w.buffer,q.end*F,l*F);V.set(t,T),T+=l*F,q.end+=l}return new DataView(V.buffer)}var Oq,cq=l(12564);!function(q){q[q.Float=0]="Float",q[q.HalfFloat=1]="HalfFloat"}(Oq||(Oq={}));class aq{}async function Fq(q,I,l,w){const t={size:0,viewer:I,array:new Uint8Array(I.buffer),offset:l,width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,channels:q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(q.compression){case v.NO_COMPRESSION:t.lines=1,t.uncompress=qq;break;case v.RLE_COMPRESSION:t.lines=1,t.uncompress=Iq;break;case v.ZIPS_COMPRESSION:t.lines=1,t.uncompress=lq,await cq.Tools.LoadScriptAsync(aq.FFLATEUrl);break;case v.ZIP_COMPRESSION:t.lines=16,t.uncompress=lq,await cq.Tools.LoadScriptAsync(aq.FFLATEUrl);break;case v.PIZ_COMPRESSION:t.lines=32,t.uncompress=tq;break;case v.PXR24_COMPRESSION:t.lines=16,t.uncompress=wq,await cq.Tools.LoadScriptAsync(aq.FFLATEUrl);break;default:throw new Error(v[q.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const O={};for(const c of q.channels)switch(c.name){case"R":case"G":case"B":case"A":case"Y":O[c.name]=!0,t.type=c.pixelType}let a=!1;if(O.R&&O.G&&O.B&&O.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(O.R&&O.G&&O.B)a=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(O.R&&O.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(O.R)t.outputChannels=1,t.decodeChannels={R:0};else{if(!O.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(w){case Oq.Float:t.getter=K,t.inputSize=F;break;case Oq.HalfFloat:t.getter=S,t.inputSize=F}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+q.compression);switch(w){case Oq.Float:t.getter=X,t.inputSize=c;break;case Oq.HalfFloat:t.getter=D,t.inputSize=c}}t.blockCount=t.height/t.scanlineBlockSize;for(let c=0;c<t.blockCount;c++)p(I,l);const s=t.width*t.height*t.outputChannels;switch(w){case Oq.Float:t.byteArray=new Float32Array(s),t.textureType=1,a&&t.byteArray.fill(1,0,s);break;case Oq.HalfFloat:t.byteArray=new Uint16Array(s),t.textureType=2,a&&t.byteArray.fill(15360,0,s);break;default:throw new Error("Unsupported type: "+w)}let Z=0;for(const c of q.channels)void 0!==t.decodeChannels[c.name]&&(t.channelLineOffsets[c.name]=Z*t.width),Z+=2*c.pixelType;return t.bytesPerLine=t.width*Z,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===q.lineOrder?t.scanOrder=q=>q:t.scanOrder=q=>t.height-1-q,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function sq(q,I,l,w){const t={value:0};for(let O=0;O<q.height/q.scanlineBlockSize;O++){const c=W(l,w)-I.dataWindow.yMin;q.size=e(l,w),q.lines=c+q.scanlineBlockSize>q.height?q.height-c:q.scanlineBlockSize;const a=q.size<q.lines*q.bytesPerLine&&q.uncompress?q.uncompress(q):qq(q);w.value+=q.size;for(let l=0;l<q.scanlineBlockSize;l++){const w=O*q.scanlineBlockSize,c=l+q.scanOrder(w);if(c>=q.height)continue;const F=l*q.bytesPerLine,s=(q.height-1-c)*q.outLineWidth;for(let l=0;l<q.channels;l++){const w=I.channels[l].name,O=q.channelLineOffsets[w],c=q.decodeChannels[w];if(void 0!==c){t.value=F+O;for(let I=0;I<q.width;I++){const l=s+I*q.outputChannels+c;q.byteArray&&(q.byteArray[l]=q.getter(a,t))}}}}}}aq.DefaultOutputType=Oq.HalfFloat,aq.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Zq{constructor(){this.supportCascades=!1}loadCubeData(q,I,l,w,t){throw".exr not supported in Cube."}loadData(q,I,l){const t=new DataView(q.buffer),O={value:0},c=E(t,O);Fq(c,t,O,aq.DefaultOutputType).then((q=>{sq(q,c,t,O);const w=c.dataWindow.xMax-c.dataWindow.xMin+1,a=c.dataWindow.yMax-c.dataWindow.yMin+1;l(w,a,I.generateMipMaps,!1,(()=>{const l=I.getEngine();I.format=c.format,I.type=q.textureType,I.invertY=!1,I._gammaSpace=!c.linearSpace,q.byteArray&&l._uploadDataToTextureDirectly(I,q.byteArray,0,0,void 0,!0)}))})).catch((q=>{w.b.Error("Failed to load EXR texture: ",q)}))}}async function rq(q){const I=new DataView(q),l={value:0},t=E(I,l);try{const q=await Fq(t,I,l,Oq.Float);return sq(q,t,I,l),q.byteArray?{width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,data:new Float32Array(q.byteArray)}:(w.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(O){w.b.Error("Failed to load EXR data: ",O)}return{width:0,height:0,data:null}}},12761:(q,I,l)=>{function w(q){return parseInt(q.toString().replace(/\W/g,""))}function t(q,I){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(q-I)<=l}function O(q,I,l){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return q<I-w||q>l+w}function c(q,I){return q===I?q:Math.random()*(I-q)+q}function a(q,I,l){return q+(I-q)*l}function F(q,I,l){let w=V(I-q,360);return w>180&&(w-=360),q+w*x(l)}function s(q,I,l){let w=0;return w=q!=I?x((l-q)/(I-q)):0,w}function Z(q,I,l,w,t){const O=t*t,c=t*O;return q*(2*c-3*O+1)+l*(-2*c+3*O)+I*(c-2*O+t)+w*(c-O)}function r(q,I,l,w,t){const O=t*t;return 6*(O-t)*q+(3*O-4*t+1)*I+6*(-O+t)*l+(3*O-2*t)*w}function x(q){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(l,Math.max(I,q))}function o(q){return q-=2*Math.PI*Math.floor((q+Math.PI)/(2*Math.PI))}function d(q){const I=q.toString(16);return q<=15?("0"+I).toUpperCase():I.toUpperCase()}function T(q){if(Math.log2)return Math.floor(Math.log2(q));if(q<0)return NaN;if(0===q)return-1/0;let I=0;if(q<1){for(;q<1;)I++,q*=2;I=-I}else if(q>1)for(;q>1;)I++,q=Math.floor(q/2);return I}function V(q,I){return q-Math.floor(q/I)*I}function U(q,I,l){return(q-I)/(l-I)}function B(q,I,l){return q*(l-I)+I}function v(q,I){let l=V(I-q,360);return l>180&&(l-=360),l}function k(q,I){const l=V(q,2*I);return I-Math.abs(l-I)}function C(q,I,l){let w=x(l);return w=-2*w*w*w+3*w*w,I*w+q*(1-w)}function R(q,I,l){let w=0;return w=Math.abs(I-q)<=l?I:q+Math.sign(I-q)*l,w}function W(q,I,l){const w=v(q,I);let t=0;return t=-l<w&&w<l?I:R(q,I=q+w,l),t}function e(q,I,l){return(q-I)/(l-I)}function i(q,I,l){return(l-I)*q+I}function S(q,I){const l=q%I;return 0===l?I:S(I,l)}l.r(I),l.d(I,{Clamp:()=>x,DeltaAngle:()=>v,Denormalize:()=>B,ExtractAsInt:()=>w,Hermite:()=>Z,Hermite1stDerivative:()=>r,HighestCommonFactor:()=>S,ILog2:()=>T,InverseLerp:()=>s,Lerp:()=>a,LerpAngle:()=>F,MoveTowards:()=>R,MoveTowardsAngle:()=>W,Normalize:()=>U,NormalizeRadians:()=>o,OutsideRange:()=>O,PercentToRange:()=>i,PingPong:()=>k,RandomRange:()=>c,RangeToPercent:()=>e,Repeat:()=>V,SmoothStep:()=>C,ToHex:()=>d,WithinEpsilon:()=>t})}}]);