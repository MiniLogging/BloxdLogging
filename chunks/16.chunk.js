"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[16],{15025:(z,u,U)=>{U.r(u),U.d(u,{ReadExrDataAsync:()=>mu,_ExrTextureLoader:()=>dz});var J=U(21),v=U(12760),f=U(12935);const g=4,w=4,P=1,R=2,S=8,d=65536,mz=d>>3,Z=14,A=65537,E=1<<Z,C=E-1,r=59,M=63,T=2+M-r;var X,h;!function(z){z[z.NO_COMPRESSION=0]="NO_COMPRESSION",z[z.RLE_COMPRESSION=1]="RLE_COMPRESSION",z[z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",z[z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",z[z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",z[z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(X||(X={})),function(z){z[z.INCREASING_Y=0]="INCREASING_Y",z[z.DECREASING_Y=1]="DECREASING_Y"}(h||(h={}));const t=function(){const z=new ArrayBuffer(4),u=new Float32Array(z),U=new Uint32Array(z),J=new Uint32Array(512),v=new Uint32Array(512);for(let P=0;P<256;++P){const z=P-127;z<-27?(J[P]=0,J[256|P]=32768,v[P]=24,v[256|P]=24):z<-14?(J[P]=1024>>-z-14,J[256|P]=1024>>-z-14|32768,v[P]=-z-1,v[256|P]=-z-1):z<=15?(J[P]=z+15<<10,J[256|P]=z+15<<10|32768,v[P]=13,v[256|P]=13):z<128?(J[P]=31744,J[256|P]=64512,v[P]=24,v[256|P]=24):(J[P]=31744,J[256|P]=64512,v[P]=13,v[256|P]=13)}const f=new Uint32Array(2048),g=new Uint32Array(64),w=new Uint32Array(64);for(let P=1;P<1024;++P){let z=P<<13,u=0;for(;0===(8388608&z);)z<<=1,u-=8388608;z&=-8388609,u+=947912704,f[P]=z|u}for(let P=1024;P<2048;++P)f[P]=939524096+(P-1024<<13);for(let P=1;P<31;++P)g[P]=P<<23;g[31]=1199570944,g[32]=2147483648;for(let P=33;P<63;++P)g[P]=2147483648+(P-32<<23);g[63]=3347054592;for(let P=1;P<64;++P)32!==P&&(w[P]=1024);return{floatView:u,uint32View:U,baseTable:J,shiftTable:v,mantissaTable:f,exponentTable:g,offsetTable:w}}();function V(z,u){const U=new Uint8Array(z);let J=0;for(;0!=U[u.value+J];)J+=1;const v=(new TextDecoder).decode(U.slice(u.value,u.value+J));return u.value=u.value+J+1,v}function L(z,u){const U=z.getInt32(u.value,!0);return u.value+=g,U}function O(z,u){const U=z.getUint32(u.value,!0);return u.value+=g,U}function x(z,u){const U=z.getUint8(u.value);return u.value+=P,U}function Q(z,u){const U=z.getUint16(u.value,!0);return u.value+=R,U}function K(z,u){const U=z[u.value];return u.value+=P,U}function Y(z,u){let U;return U="getBigInt64"in DataView.prototype?Number(z.getBigInt64(u.value,!0)):z.getUint32(u.value+4,!0)+Number(z.getUint32(u.value,!0)<<32),u.value+=S,U}function p(z,u){const U=z.getFloat32(u.value,!0);return u.value+=w,U}function N(z,u){return function(z){const u=(31744&z)>>10,U=1023&z;return(z>>15?-1:1)*(u?31===u?U?NaN:1/0:Math.pow(2,u-15)*(1+U/1024):U/1024*6103515625e-14)}(Q(z,u))}function D(z,u){return function(z){if(Math.abs(z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");z=(0,f.Clamp)(z,-65504,65504),t.floatView[0]=z;const u=t.uint32View[0],U=u>>23&511;return t.baseTable[U]+((8388607&u)>>t.shiftTable[U])}(p(z,u))}function c(z,u,U,J){switch(U){case"string":case"stringvector":case"iccProfile":return function(z,u,U){const J=(new TextDecoder).decode(new Uint8Array(z).slice(u.value,u.value+U));return u.value=u.value+U,J}(z.buffer,u,J);case"chlist":return function(z,u,U){const J=u.value,v=[];for(;u.value<J+U-1;){const U=V(z.buffer,u),J=L(z,u),f=x(z,u);u.value+=3;const g=L(z,u),w=L(z,u);v.push({name:U,pixelType:J,pLinear:f,xSampling:g,ySampling:w})}return u.value+=1,v}(z,u,J);case"chromaticities":return function(z,u){return{redX:p(z,u),redY:p(z,u),greenX:p(z,u),greenY:p(z,u),blueX:p(z,u),blueY:p(z,u),whiteX:p(z,u),whiteY:p(z,u)}}(z,u);case"compression":return function(z,u){return x(z,u)}(z,u);case"box2i":return function(z,u){return{xMin:L(z,u),yMin:L(z,u),xMax:L(z,u),yMax:L(z,u)}}(z,u);case"lineOrder":return function(z,u){const U=x(z,u);return h[U]}(z,u);case"float":return p(z,u);case"v2f":return function(z,u){return[p(z,u),p(z,u)]}(z,u);case"v3f":return function(z,u){return[p(z,u),p(z,u),p(z,u)]}(z,u);case"int":return L(z,u);case"rational":return function(z,u){return[L(z,u),O(z,u)]}(z,u);case"timecode":return function(z,u){return[O(z,u),O(z,u)]}(z,u);case"preview":return u.value+=J,"skipped";default:return void(u.value+=J)}}function W(z){for(let u=1;u<z.length;u++){const U=z[u-1]+z[u]-128;z[u]=U}}function j(z,u){let U=0,J=Math.floor((z.length+1)/2),v=0;const f=z.length-1;for(;!(v>f)&&(u[v++]=z[U++],!(v>f));)u[v++]=z[J++]}const I=20000630;function F(z,u){if(z.getUint32(0,!0)!=I)throw new Error("Incorrect OpenEXR format");const U=z.getUint8(4),f=z.getUint8(5),g={singleTile:!!(2&f),longName:!!(4&f),deepFormat:!!(8&f),multiPart:!!(16&f)};u.value=8;const w={};let P=!0;for(;P;){const U=V(z.buffer,u);if(U){const J=V(z.buffer,u),f=c(z,u,J,O(z,u));void 0===f?v.d.Warn("Unknown header attribute type ".concat(J,"'.")):w[U]=f}else P=!1}if(0!=(-5&f))throw new Error("Unsupported file format");return(0,J.e)({version:U,spec:g},w)}const b=32768,k=65535;function B(z,u,U,J,v){for(;U<z;)u=u<<8|K(J,v),U+=8;return{l:u>>(U-=z)&(1<<z)-1,c:u,lc:U}}function y(z,u,U,J){return{c:z=z<<8|K(U,J),lc:u+=8}}function H(z,u,U,J,v,f,g,w,P){if(z==u){if(J<8){const z=y(U,J,v,f);U=z.c,J=z.lc}let z=U>>(J-=8);if(z=new Uint8Array([z])[0],w.value+z>P)return null;const u=g[w.value-1];for(;z-- >0;)g[w.value++]=u}else{if(!(w.value<P))return null;g[w.value++]=z}return{c:U,lc:J}}const G=new Array(59);function a(z,u,U,J,v,f){const g=u;let w=0,P=0;for(;J<=v;J++){if(g.value-u.value>U)return;let R=B(6,w,P,z,g);const S=R.l;if(w=R.c,P=R.lc,f[J]=S,S==M){if(g.value-u.value>U)throw new Error("Error in HufUnpackEncTable");R=B(8,w,P,z,g);let S=R.l+T;if(w=R.c,P=R.lc,J+S>v+1)throw new Error("Error in HufUnpackEncTable");for(;S--;)f[J++]=0;J--}else if(S>=r){let z=S-r+2;if(J+z>v+1)throw new Error("Error in HufUnpackEncTable");for(;z--;)f[J++]=0;J--}}!function(z){for(let U=0;U<=58;++U)G[U]=0;for(let U=0;U<A;++U)G[z[U]]+=1;let u=0;for(let U=58;U>0;--U){const z=u+G[U]>>1;G[U]=u,u=z}for(let U=0;U<A;++U){const u=z[U];u>0&&(z[U]=u|G[u]++<<6)}}(f)}function i(z){return 63&z}function n(z){return z>>6}function q(z,u,U,J,v,f){const g=U.value,w=O(u,U),P=O(u,U);U.value+=4;const R=O(u,U);if(U.value+=4,w<0||w>=A||P<0||P>=A)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(A),d=new Array(E);!function(z){for(let u=0;u<E;u++)z[u]={},z[u].len=0,z[u].lit=0,z[u].p=null}(d);if(a(z,U,J-(U.value-g),w,P,S),R>8*(J-(U.value-g)))throw new Error("Wrong hufUncompress");!function(z,u,U,J){for(;u<=U;u++){const U=n(z[u]),v=i(z[u]);if(U>>v)throw new Error("Invalid table entry");if(v>Z){const z=J[U>>v-Z];if(z.len)throw new Error("Invalid table entry");if(z.lit++,z.p){const u=z.p;z.p=new Array(z.lit);for(let U=0;U<z.lit-1;++U)z.p[U]=u[U]}else z.p=new Array(1);z.p[z.lit-1]=u}else if(v){let z=0;for(let f=1<<Z-v;f>0;f--){const f=J[(U<<Z-v)+z];if(f.len||f.p)throw new Error("Invalid table entry");f.len=v,f.lit=u,z++}}}}(S,w,P,d),function(z,u,U,J,v,f,g,w,P){let R=0,S=0;const d=g,mz=Math.trunc(J.value+(v+7)/8);for(;J.value<mz;){let v=y(R,S,U,J);for(R=v.c,S=v.lc;S>=Z;){const g=u[R>>S-Z&C];if(g.len){S-=g.len;const z=H(g.lit,f,R,S,U,J,w,P,d);z&&(R=z.c,S=z.lc)}else{if(!g.p)throw new Error("hufDecode issues");let u;for(u=0;u<g.lit;u++){const Z=i(z[g.p[u]]);for(;S<Z&&J.value<mz;)v=y(R,S,U,J),R=v.c,S=v.lc;if(S>=Z&&n(z[g.p[u]])==(R>>S-Z&(1<<Z)-1)){S-=Z;const z=H(g.p[u],f,R,S,U,J,w,P,d);z&&(R=z.c,S=z.lc);break}}if(u==g.lit)throw new Error("HufDecode issues")}}}const A=8-v&7;for(R>>=A,S-=A;S>0;){const z=u[R<<Z-S&C];if(!z.len)throw new Error("HufDecode issues");{S-=z.len;const u=H(z.lit,f,R,S,U,J,w,P,d);u&&(R=u.c,S=u.lc)}}}(S,d,z,U,R,P,f,v,{value:0})}function o(z){return 65535&z}function s(z){const u=o(z);return u>32767?u-65536:u}function l(z,u){const U=s(z),J=s(u),v=U+(1&J)+(J>>1);return{a:v,b:v-J}}function e(z,u){const U=o(z),J=o(u),v=U-(J>>1)&k;return{a:J+v-b&k,b:v}}function zz(z,u,U,J,v,f,g){const w=g<16384,P=U>v?v:U;let R,S,d=1;for(;d<=P;)d<<=1;for(d>>=1,R=d,d>>=1;d>=1;){S=0;const g=S+f*(v-R),P=f*d,mz=f*R,Z=J*d,A=J*R;let E,C,r,M;for(;S<=g;S+=mz){let v=S;const f=S+J*(U-R);for(;v<=f;v+=A){const U=v+Z,J=v+P,f=J+Z;if(w){let g=l(z[v+u],z[J+u]);E=g.a,r=g.b,g=l(z[U+u],z[f+u]),C=g.a,M=g.b,g=l(E,C),z[v+u]=g.a,z[U+u]=g.b,g=l(r,M),z[J+u]=g.a,z[f+u]=g.b}else{let g=e(z[v+u],z[J+u]);E=g.a,r=g.b,g=e(z[U+u],z[f+u]),C=g.a,M=g.b,g=e(E,C),z[v+u]=g.a,z[U+u]=g.b,g=e(r,M),z[J+u]=g.a,z[f+u]=g.b}}if(U&d){const U=v+P;let J;J=w?l(z[v+u],z[U+u]):e(z[v+u],z[U+u]),E=J.a,z[U+u]=J.b,z[v+u]=E}}if(v&d){let v=S;const f=S+J*(U-R);for(;v<=f;v+=A){const U=v+Z;let J;J=w?l(z[v+u],z[U+u]):e(z[v+u],z[U+u]),E=J.a,z[U+u]=J.b,z[v+u]=E}}R=d,d>>=1}return S}function uz(z){return new DataView(z.array.buffer,z.offset.value,z.size)}function Uz(z){const u=z.viewer.buffer.slice(z.offset.value,z.offset.value+z.size),U=new Uint8Array(function(z){let u=z.byteLength;const U=[];let J=0;const v=new DataView(z);for(;u>0;){const z=v.getInt8(J++);if(z<0){const f=-z;u-=f+1;for(let z=0;z<f;z++)U.push(v.getUint8(J++))}else{const f=z;u-=2;const g=v.getUint8(J++);for(let z=0;z<f+1;z++)U.push(g)}}return U}(u)),J=new Uint8Array(U.length);return W(U),j(U,J),new DataView(J.buffer)}function Jz(z){const u=z.array.slice(z.offset.value,z.offset.value+z.size),U=fflate.unzlibSync(u),J=new Uint8Array(U.length);return W(U),j(U,J),new DataView(J.buffer)}function vz(z){const u=z.array.slice(z.offset.value,z.offset.value+z.size),U=fflate.unzlibSync(u),J=z.lines*z.channels*z.width,v=1==z.type?new Uint16Array(J):new Uint32Array(J);let f=0,g=0;const w=new Array(4);for(let P=0;P<z.lines;P++)for(let u=0;u<z.channels;u++){let u=0;switch(z.type){case 1:w[0]=f,w[1]=w[0]+z.width,f=w[1]+z.width;for(let J=0;J<z.width;++J){u+=U[w[0]++]<<8|U[w[1]++],v[g]=u,g++}break;case 2:w[0]=f,w[1]=w[0]+z.width,w[2]=w[1]+z.width,f=w[2]+z.width;for(let J=0;J<z.width;++J){u+=U[w[0]++]<<24|U[w[1]++]<<16|U[w[2]++]<<8,v[g]=u,g++}}}return new DataView(v.buffer)}function fz(z){const u=z.viewer,U={value:z.offset.value},J=new Uint16Array(z.width*z.scanlineBlockSize*(z.channels*z.type)),v=new Uint8Array(mz);let f=0;const g=new Array(z.channels);for(let R=0;R<z.channels;R++)g[R]={},g[R].start=f,g[R].end=g[R].start,g[R].nx=z.width,g[R].ny=z.lines,g[R].size=z.type,f+=g[R].nx*g[R].ny*g[R].size;const w=Q(u,U),P=Q(u,U);if(P>=mz)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(w<=P)for(let R=0;R<P-w+1;R++)v[R+w]=x(u,U);const S=new Uint16Array(d),Z=function(z,u){let U=0;for(let v=0;v<d;++v)(0==v||z[v>>3]&1<<(7&v))&&(u[U++]=v);const J=U-1;for(;U<d;)u[U++]=0;return J}(v,S),A=O(u,U);q(z.array,u,U,A,J,f);for(let R=0;R<z.channels;++R){const z=g[R];for(let u=0;u<g[R].size;++u)zz(J,z.start+u,z.nx,z.size,z.ny,z.nx*z.size,Z)}!function(z,u,U){for(let J=0;J<U;++J)u[J]=z[u[J]]}(S,J,f);let E=0;const C=new Uint8Array(J.buffer.byteLength);for(let d=0;d<z.lines;d++)for(let u=0;u<z.channels;u++){const z=g[u],U=z.nx*z.size,v=new Uint8Array(J.buffer,z.end*R,U*R);C.set(v,E),E+=U*R,z.end+=U}return new DataView(C.buffer)}var gz,wz=U(12748);!function(z){z[z.Float=0]="Float",z[z.HalfFloat=1]="HalfFloat"}(gz||(gz={}));class Pz{}async function Rz(z,u,U,J){const v={size:0,viewer:u,array:new Uint8Array(u.buffer),offset:U,width:z.dataWindow.xMax-z.dataWindow.xMin+1,height:z.dataWindow.yMax-z.dataWindow.yMin+1,channels:z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(z.compression){case X.NO_COMPRESSION:v.lines=1,v.uncompress=uz;break;case X.RLE_COMPRESSION:v.lines=1,v.uncompress=Uz;break;case X.ZIPS_COMPRESSION:v.lines=1,v.uncompress=Jz,await wz.Tools.LoadScriptAsync(Pz.FFLATEUrl);break;case X.ZIP_COMPRESSION:v.lines=16,v.uncompress=Jz,await wz.Tools.LoadScriptAsync(Pz.FFLATEUrl);break;case X.PIZ_COMPRESSION:v.lines=32,v.uncompress=fz;break;case X.PXR24_COMPRESSION:v.lines=16,v.uncompress=vz,await wz.Tools.LoadScriptAsync(Pz.FFLATEUrl);break;default:throw new Error(X[z.compression]+" is unsupported")}v.scanlineBlockSize=v.lines;const f={};for(const w of z.channels)switch(w.name){case"R":case"G":case"B":case"A":case"Y":f[w.name]=!0,v.type=w.pixelType}let g=!1;if(f.R&&f.G&&f.B&&f.A)v.outputChannels=4,v.decodeChannels={R:0,G:1,B:2,A:3};else if(f.R&&f.G&&f.B)g=!0,v.outputChannels=4,v.decodeChannels={R:0,G:1,B:2,A:3};else if(f.R&&f.G)v.outputChannels=2,v.decodeChannels={R:0,G:1};else if(f.R)v.outputChannels=1,v.decodeChannels={R:0};else{if(!f.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");v.outputChannels=1,v.decodeChannels={Y:0}}if(1===v.type)switch(J){case gz.Float:v.getter=N,v.inputSize=R;break;case gz.HalfFloat:v.getter=Q,v.inputSize=R}else{if(2!==v.type)throw new Error("Unsupported pixelType "+v.type+" for "+z.compression);switch(J){case gz.Float:v.getter=p,v.inputSize=w;break;case gz.HalfFloat:v.getter=D,v.inputSize=w}}v.blockCount=v.height/v.scanlineBlockSize;for(let w=0;w<v.blockCount;w++)Y(u,U);const P=v.width*v.height*v.outputChannels;switch(J){case gz.Float:v.byteArray=new Float32Array(P),v.textureType=1,g&&v.byteArray.fill(1,0,P);break;case gz.HalfFloat:v.byteArray=new Uint16Array(P),v.textureType=2,g&&v.byteArray.fill(15360,0,P);break;default:throw new Error("Unsupported type: "+J)}let S=0;for(const w of z.channels)void 0!==v.decodeChannels[w.name]&&(v.channelLineOffsets[w.name]=S*v.width),S+=2*w.pixelType;return v.bytesPerLine=v.width*S,v.outLineWidth=v.width*v.outputChannels,"INCREASING_Y"===z.lineOrder?v.scanOrder=z=>z:v.scanOrder=z=>v.height-1-z,4==v.outputChannels?(v.format=5,v.linearSpace=!0):(v.format=6,v.linearSpace=!1),v}function Sz(z,u,U,J){const v={value:0};for(let f=0;f<z.height/z.scanlineBlockSize;f++){const g=L(U,J)-u.dataWindow.yMin;z.size=O(U,J),z.lines=g+z.scanlineBlockSize>z.height?z.height-g:z.scanlineBlockSize;const w=z.size<z.lines*z.bytesPerLine&&z.uncompress?z.uncompress(z):uz(z);J.value+=z.size;for(let U=0;U<z.scanlineBlockSize;U++){const J=f*z.scanlineBlockSize,g=U+z.scanOrder(J);if(g>=z.height)continue;const P=U*z.bytesPerLine,R=(z.height-1-g)*z.outLineWidth;for(let U=0;U<z.channels;U++){const J=u.channels[U].name,f=z.channelLineOffsets[J],g=z.decodeChannels[J];if(void 0!==g){v.value=P+f;for(let u=0;u<z.width;u++){const U=R+u*z.outputChannels+g;z.byteArray&&(z.byteArray[U]=z.getter(w,v))}}}}}}Pz.DefaultOutputType=gz.HalfFloat,Pz.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dz{constructor(){this.supportCascades=!1}loadCubeData(z,u,U,J,v){throw".exr not supported in Cube."}loadData(z,u,U){const J=new DataView(z.buffer),f={value:0},g=F(J,f);Rz(g,J,f,Pz.DefaultOutputType).then((z=>{Sz(z,g,J,f);const v=g.dataWindow.xMax-g.dataWindow.xMin+1,w=g.dataWindow.yMax-g.dataWindow.yMin+1;U(v,w,u.generateMipMaps,!1,(()=>{const U=u.getEngine();u.format=g.format,u.type=z.textureType,u.invertY=!1,u._gammaSpace=!g.linearSpace,z.byteArray&&U._uploadDataToTextureDirectly(u,z.byteArray,0,0,void 0,!0)}))})).catch((z=>{v.d.Error("Failed to load EXR texture: ",z)}))}}async function mu(z){const u=new DataView(z),U={value:0},J=F(u,U);try{const z=await Rz(J,u,U,gz.Float);return Sz(z,J,u,U),z.byteArray?{width:J.dataWindow.xMax-J.dataWindow.xMin+1,height:J.dataWindow.yMax-J.dataWindow.yMin+1,data:new Float32Array(z.byteArray)}:(v.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(f){v.d.Error("Failed to load EXR data: ",f)}return{width:0,height:0,data:null}}},12935:(z,u,U)=>{function J(z){return parseInt(z.toString().replace(/\W/g,""))}function v(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(z-u)<=U}function f(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return z<u-J||z>U+J}function g(z,u){return z===u?z:Math.random()*(u-z)+z}function w(z,u,U){return z+(u-z)*U}function P(z,u,U){let J=C(u-z,360);return J>180&&(J-=360),z+J*mz(U)}function R(z,u,U){let J=0;return J=z!=u?mz((U-z)/(u-z)):0,J}function S(z,u,U,J,v){const f=v*v,g=v*f;return z*(2*g-3*f+1)+U*(-2*g+3*f)+u*(g-2*f+v)+J*(g-f)}function d(z,u,U,J,v){const f=v*v;return 6*(f-v)*z+(3*f-4*v+1)*u+6*(-f+v)*U+(3*f-2*v)*J}function mz(z){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(U,Math.max(u,z))}function Z(z){return z-=2*Math.PI*Math.floor((z+Math.PI)/(2*Math.PI))}function A(z){const u=z.toString(16);return z<=15?("0"+u).toUpperCase():u.toUpperCase()}function E(z){if(Math.log2)return Math.floor(Math.log2(z));if(z<0)return NaN;if(0===z)return-1/0;let u=0;if(z<1){for(;z<1;)u++,z*=2;u=-u}else if(z>1)for(;z>1;)u++,z=Math.floor(z/2);return u}function C(z,u){return z-Math.floor(z/u)*u}function r(z,u,U){return(z-u)/(U-u)}function M(z,u,U){return z*(U-u)+u}function T(z,u){let U=C(u-z,360);return U>180&&(U-=360),U}function X(z,u){const U=C(z,2*u);return u-Math.abs(U-u)}function h(z,u,U){let J=mz(U);return J=-2*J*J*J+3*J*J,u*J+z*(1-J)}function t(z,u,U){let J=0;return J=Math.abs(u-z)<=U?u:z+Math.sign(u-z)*U,J}function V(z,u,U){const J=T(z,u);let v=0;return v=-U<J&&J<U?u:t(z,u=z+J,U),v}function L(z,u,U){return(z-u)/(U-u)}function O(z,u,U){return(U-u)*z+u}function x(z,u){const U=z%u;return 0===U?u:x(u,U)}U.r(u),U.d(u,{Clamp:()=>mz,DeltaAngle:()=>T,Denormalize:()=>M,ExtractAsInt:()=>J,Hermite:()=>S,Hermite1stDerivative:()=>d,HighestCommonFactor:()=>x,ILog2:()=>E,InverseLerp:()=>R,Lerp:()=>w,LerpAngle:()=>P,MoveTowards:()=>t,MoveTowardsAngle:()=>V,Normalize:()=>r,NormalizeRadians:()=>Z,OutsideRange:()=>f,PercentToRange:()=>O,PingPong:()=>X,RandomRange:()=>g,RangeToPercent:()=>L,Repeat:()=>C,SmoothStep:()=>h,ToHex:()=>A,WithinEpsilon:()=>v})}}]);