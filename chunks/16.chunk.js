"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[16],{15066:(s,k,h)=>{h.r(k),h.d(k,{ReadExrDataAsync:()=>Ss,_ExrTextureLoader:()=>cs});var A=h(12422),g=h(12607);const ms=4,i=4,K=1,H=2,O=8,c=65536,S=c>>3,a=14,r=65537,d=1<<a,E=d-1,j=59,P=63,R=2+P-j;var D,w;!function(s){s[s.NO_COMPRESSION=0]="NO_COMPRESSION",s[s.RLE_COMPRESSION=1]="RLE_COMPRESSION",s[s.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",s[s.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",s[s.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",s[s.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(D||(D={})),function(s){s[s.INCREASING_Y=0]="INCREASING_Y",s[s.DECREASING_Y=1]="DECREASING_Y"}(w||(w={}));const B=function(){const s=new ArrayBuffer(4),k=new Float32Array(s),h=new Uint32Array(s),A=new Uint32Array(512),g=new Uint32Array(512);for(let H=0;H<256;++H){const s=H-127;s<-27?(A[H]=0,A[256|H]=32768,g[H]=24,g[256|H]=24):s<-14?(A[H]=1024>>-s-14,A[256|H]=1024>>-s-14|32768,g[H]=-s-1,g[256|H]=-s-1):s<=15?(A[H]=s+15<<10,A[256|H]=s+15<<10|32768,g[H]=13,g[256|H]=13):s<128?(A[H]=31744,A[256|H]=64512,g[H]=24,g[256|H]=24):(A[H]=31744,A[256|H]=64512,g[H]=13,g[256|H]=13)}const ms=new Uint32Array(2048),i=new Uint32Array(64),K=new Uint32Array(64);for(let H=1;H<1024;++H){let s=H<<13,k=0;for(;0===(8388608&s);)s<<=1,k-=8388608;s&=-8388609,k+=947912704,ms[H]=s|k}for(let H=1024;H<2048;++H)ms[H]=939524096+(H-1024<<13);for(let H=1;H<31;++H)i[H]=H<<23;i[31]=1199570944,i[32]=2147483648;for(let H=33;H<63;++H)i[H]=2147483648+(H-32<<23);i[63]=3347054592;for(let H=1;H<64;++H)32!==H&&(K[H]=1024);return{floatView:k,uint32View:h,baseTable:A,shiftTable:g,mantissaTable:ms,exponentTable:i,offsetTable:K}}();function u(s,k){const h=new Uint8Array(s);let A=0;for(;0!=h[k.value+A];)A+=1;const g=(new TextDecoder).decode(h.slice(k.value,k.value+A));return k.value=k.value+A+1,g}function G(s,k){const h=s.getInt32(k.value,!0);return k.value+=ms,h}function Q(s,k){const h=s.getUint32(k.value,!0);return k.value+=ms,h}function p(s,k){const h=s.getUint8(k.value);return k.value+=K,h}function I(s,k){const h=s.getUint16(k.value,!0);return k.value+=H,h}function N(s,k){const h=s[k.value];return k.value+=K,h}function b(s,k){let h;return h="getBigInt64"in DataView.prototype?Number(s.getBigInt64(k.value,!0)):s.getUint32(k.value+4,!0)+Number(s.getUint32(k.value,!0)<<32),k.value+=O,h}function t(s,k){const h=s.getFloat32(k.value,!0);return k.value+=i,h}function z(s,k){return function(s){const k=(31744&s)>>10,h=1023&s;return(s>>15?-1:1)*(k?31===k?h?NaN:1/0:Math.pow(2,k-15)*(1+h/1024):h/1024*6103515625e-14)}(I(s,k))}function C(s,k){return function(s){if(Math.abs(s)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");s=(0,g.Clamp)(s,-65504,65504),B.floatView[0]=s;const k=B.uint32View[0],h=k>>23&511;return B.baseTable[h]+((8388607&k)>>B.shiftTable[h])}(t(s,k))}function v(s,k,h,A){switch(h){case"string":case"stringvector":case"iccProfile":return function(s,k,h){const A=(new TextDecoder).decode(new Uint8Array(s).slice(k.value,k.value+h));return k.value=k.value+h,A}(s.buffer,k,A);case"chlist":return function(s,k,h){const A=k.value,g=[];for(;k.value<A+h-1;){const h=u(s.buffer,k),A=G(s,k),ms=p(s,k);k.value+=3;const i=G(s,k),K=G(s,k);g.push({name:h,pixelType:A,pLinear:ms,xSampling:i,ySampling:K})}return k.value+=1,g}(s,k,A);case"chromaticities":return function(s,k){return{redX:t(s,k),redY:t(s,k),greenX:t(s,k),greenY:t(s,k),blueX:t(s,k),blueY:t(s,k),whiteX:t(s,k),whiteY:t(s,k)}}(s,k);case"compression":return function(s,k){return p(s,k)}(s,k);case"box2i":return function(s,k){return{xMin:G(s,k),yMin:G(s,k),xMax:G(s,k),yMax:G(s,k)}}(s,k);case"lineOrder":return function(s,k){const h=p(s,k);return w[h]}(s,k);case"float":return t(s,k);case"v2f":return function(s,k){return[t(s,k),t(s,k)]}(s,k);case"v3f":return function(s,k){return[t(s,k),t(s,k),t(s,k)]}(s,k);case"int":return G(s,k);case"rational":return function(s,k){return[G(s,k),Q(s,k)]}(s,k);case"timecode":return function(s,k){return[Q(s,k),Q(s,k)]}(s,k);case"preview":return k.value+=A,"skipped";default:return void(k.value+=A)}}function Y(s){for(let k=1;k<s.length;k++){const h=s[k-1]+s[k]-128;s[k]=h}}function n(s,k){let h=0,A=Math.floor((s.length+1)/2),g=0;const ms=s.length-1;for(;!(g>ms)&&(k[g++]=s[h++],!(g>ms));)k[g++]=s[A++]}const T=20000630;function U(s,k){if(s.getUint32(0,!0)!=T)throw new Error("Incorrect OpenEXR format");const h=s.getUint8(4),g=s.getUint8(5),ms={singleTile:!!(2&g),longName:!!(4&g),deepFormat:!!(8&g),multiPart:!!(16&g)};k.value=8;const i={};let K=!0;for(;K;){const h=u(s.buffer,k);if(h){const g=u(s.buffer,k),ms=v(s,k,g,Q(s,k));void 0===ms?A.c.Warn(`Unknown header attribute type ${g}'.`):i[h]=ms}else K=!1}if(0!=(-5&g))throw new Error("Unsupported file format");return{version:h,spec:ms,...i}}const q=32768,M=65535;function V(s,k,h,A,g){for(;h<s;)k=k<<8|N(A,g),h+=8;return{l:k>>(h-=s)&(1<<s)-1,c:k,lc:h}}function X(s,k,h,A){return{c:s=s<<8|N(h,A),lc:k+=8}}function L(s,k,h,A,g,ms,i,K,H){if(s==k){if(A<8){const s=X(h,A,g,ms);h=s.c,A=s.lc}let s=h>>(A-=8);if(s=new Uint8Array([s])[0],K.value+s>H)return null;const k=i[K.value-1];for(;s-- >0;)i[K.value++]=k}else{if(!(K.value<H))return null;i[K.value++]=s}return{c:h,lc:A}}const Z=new Array(59);function x(s,k,h,A,g,ms){const i=k;let K=0,H=0;for(;A<=g;A++){if(i.value-k.value>h)return;let O=V(6,K,H,s,i);const c=O.l;if(K=O.c,H=O.lc,ms[A]=c,c==P){if(i.value-k.value>h)throw new Error("Error in HufUnpackEncTable");O=V(8,K,H,s,i);let c=O.l+R;if(K=O.c,H=O.lc,A+c>g+1)throw new Error("Error in HufUnpackEncTable");for(;c--;)ms[A++]=0;A--}else if(c>=j){let s=c-j+2;if(A+s>g+1)throw new Error("Error in HufUnpackEncTable");for(;s--;)ms[A++]=0;A--}}!function(s){for(let h=0;h<=58;++h)Z[h]=0;for(let h=0;h<r;++h)Z[s[h]]+=1;let k=0;for(let h=58;h>0;--h){const s=k+Z[h]>>1;Z[h]=k,k=s}for(let h=0;h<r;++h){const k=s[h];k>0&&(s[h]=k|Z[k]++<<6)}}(ms)}function y(s){return 63&s}function W(s){return s>>6}function J(s,k,h,A,g,ms){const i=h.value,K=Q(k,h),H=Q(k,h);h.value+=4;const O=Q(k,h);if(h.value+=4,K<0||K>=r||H<0||H>=r)throw new Error("Wrong HUF_ENCSIZE");const c=new Array(r),S=new Array(d);!function(s){for(let k=0;k<d;k++)s[k]={},s[k].len=0,s[k].lit=0,s[k].p=null}(S);if(x(s,h,A-(h.value-i),K,H,c),O>8*(A-(h.value-i)))throw new Error("Wrong hufUncompress");!function(s,k,h,A){for(;k<=h;k++){const h=W(s[k]),g=y(s[k]);if(h>>g)throw new Error("Invalid table entry");if(g>a){const s=A[h>>g-a];if(s.len)throw new Error("Invalid table entry");if(s.lit++,s.p){const k=s.p;s.p=new Array(s.lit);for(let h=0;h<s.lit-1;++h)s.p[h]=k[h]}else s.p=new Array(1);s.p[s.lit-1]=k}else if(g){let s=0;for(let ms=1<<a-g;ms>0;ms--){const ms=A[(h<<a-g)+s];if(ms.len||ms.p)throw new Error("Invalid table entry");ms.len=g,ms.lit=k,s++}}}}(c,K,H,S),function(s,k,h,A,g,ms,i,K,H){let O=0,c=0;const S=i,r=Math.trunc(A.value+(g+7)/8);for(;A.value<r;){let g=X(O,c,h,A);for(O=g.c,c=g.lc;c>=a;){const i=k[O>>c-a&E];if(i.len){c-=i.len;const s=L(i.lit,ms,O,c,h,A,K,H,S);s&&(O=s.c,c=s.lc)}else{if(!i.p)throw new Error("hufDecode issues");let k;for(k=0;k<i.lit;k++){const a=y(s[i.p[k]]);for(;c<a&&A.value<r;)g=X(O,c,h,A),O=g.c,c=g.lc;if(c>=a&&W(s[i.p[k]])==(O>>c-a&(1<<a)-1)){c-=a;const s=L(i.p[k],ms,O,c,h,A,K,H,S);s&&(O=s.c,c=s.lc);break}}if(k==i.lit)throw new Error("HufDecode issues")}}}const d=8-g&7;for(O>>=d,c-=d;c>0;){const s=k[O<<a-c&E];if(!s.len)throw new Error("HufDecode issues");{c-=s.len;const k=L(s.lit,ms,O,c,h,A,K,H,S);k&&(O=k.c,c=k.lc)}}}(c,S,s,h,O,H,ms,g,{value:0})}function F(s){return 65535&s}function o(s){const k=F(s);return k>32767?k-65536:k}function l(s,k){const h=o(s),A=o(k),g=h+(1&A)+(A>>1);return{a:g,b:g-A}}function f(s,k){const h=F(s),A=F(k),g=h-(A>>1)&M;return{a:A+g-q&M,b:g}}function e(s,k,h,A,g,ms,i){const K=i<16384,H=h>g?g:h;let O,c,S=1;for(;S<=H;)S<<=1;for(S>>=1,O=S,S>>=1;S>=1;){c=0;const i=c+ms*(g-O),H=ms*S,a=ms*O,r=A*S,d=A*O;let E,j,P,R;for(;c<=i;c+=a){let g=c;const ms=c+A*(h-O);for(;g<=ms;g+=d){const h=g+r,A=g+H,ms=A+r;if(K){let i=l(s[g+k],s[A+k]);E=i.a,P=i.b,i=l(s[h+k],s[ms+k]),j=i.a,R=i.b,i=l(E,j),s[g+k]=i.a,s[h+k]=i.b,i=l(P,R),s[A+k]=i.a,s[ms+k]=i.b}else{let i=f(s[g+k],s[A+k]);E=i.a,P=i.b,i=f(s[h+k],s[ms+k]),j=i.a,R=i.b,i=f(E,j),s[g+k]=i.a,s[h+k]=i.b,i=f(P,R),s[A+k]=i.a,s[ms+k]=i.b}}if(h&S){const h=g+H;let A;A=K?l(s[g+k],s[h+k]):f(s[g+k],s[h+k]),E=A.a,s[h+k]=A.b,s[g+k]=E}}if(g&S){let g=c;const ms=c+A*(h-O);for(;g<=ms;g+=d){const h=g+r;let A;A=K?l(s[g+k],s[h+k]):f(s[g+k],s[h+k]),E=A.a,s[h+k]=A.b,s[g+k]=E}}O=S,S>>=1}return c}function ss(s){return new DataView(s.array.buffer,s.offset.value,s.size)}function ks(s){const k=s.viewer.buffer.slice(s.offset.value,s.offset.value+s.size),h=new Uint8Array(function(s){let k=s.byteLength;const h=[];let A=0;const g=new DataView(s);for(;k>0;){const s=g.getInt8(A++);if(s<0){const ms=-s;k-=ms+1;for(let s=0;s<ms;s++)h.push(g.getUint8(A++))}else{const ms=s;k-=2;const i=g.getUint8(A++);for(let s=0;s<ms+1;s++)h.push(i)}}return h}(k)),A=new Uint8Array(h.length);return Y(h),n(h,A),new DataView(A.buffer)}function hs(s){const k=s.array.slice(s.offset.value,s.offset.value+s.size),h=fflate.unzlibSync(k),A=new Uint8Array(h.length);return Y(h),n(h,A),new DataView(A.buffer)}function As(s){const k=s.array.slice(s.offset.value,s.offset.value+s.size),h=fflate.unzlibSync(k),A=s.lines*s.channels*s.width,g=1==s.type?new Uint16Array(A):new Uint32Array(A);let ms=0,i=0;const K=new Array(4);for(let H=0;H<s.lines;H++)for(let k=0;k<s.channels;k++){let k=0;switch(s.type){case 1:K[0]=ms,K[1]=K[0]+s.width,ms=K[1]+s.width;for(let A=0;A<s.width;++A){k+=h[K[0]++]<<8|h[K[1]++],g[i]=k,i++}break;case 2:K[0]=ms,K[1]=K[0]+s.width,K[2]=K[1]+s.width,ms=K[2]+s.width;for(let A=0;A<s.width;++A){k+=h[K[0]++]<<24|h[K[1]++]<<16|h[K[2]++]<<8,g[i]=k,i++}}}return new DataView(g.buffer)}function gs(s){const k=s.viewer,h={value:s.offset.value},A=new Uint16Array(s.width*s.scanlineBlockSize*(s.channels*s.type)),g=new Uint8Array(S);let ms=0;const i=new Array(s.channels);for(let H=0;H<s.channels;H++)i[H]={},i[H].start=ms,i[H].end=i[H].start,i[H].nx=s.width,i[H].ny=s.lines,i[H].size=s.type,ms+=i[H].nx*i[H].ny*i[H].size;const K=I(k,h),O=I(k,h);if(O>=S)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(K<=O)for(let H=0;H<O-K+1;H++)g[H+K]=p(k,h);const a=new Uint16Array(c),r=function(s,k){let h=0;for(let g=0;g<c;++g)(0==g||s[g>>3]&1<<(7&g))&&(k[h++]=g);const A=h-1;for(;h<c;)k[h++]=0;return A}(g,a),d=Q(k,h);J(s.array,k,h,d,A,ms);for(let H=0;H<s.channels;++H){const s=i[H];for(let k=0;k<i[H].size;++k)e(A,s.start+k,s.nx,s.size,s.ny,s.nx*s.size,r)}!function(s,k,h){for(let A=0;A<h;++A)k[A]=s[k[A]]}(a,A,ms);let E=0;const j=new Uint8Array(A.buffer.byteLength);for(let c=0;c<s.lines;c++)for(let k=0;k<s.channels;k++){const s=i[k],h=s.nx*s.size,g=new Uint8Array(A.buffer,s.end*H,h*H);j.set(g,E),E+=h*H,s.end+=h}return new DataView(j.buffer)}var mk,is=h(12402);!function(s){s[s.Float=0]="Float",s[s.HalfFloat=1]="HalfFloat"}(mk||(mk={}));class Ks{}async function Hs(s,k,h,A){const g={size:0,viewer:k,array:new Uint8Array(k.buffer),offset:h,width:s.dataWindow.xMax-s.dataWindow.xMin+1,height:s.dataWindow.yMax-s.dataWindow.yMin+1,channels:s.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(s.compression){case D.NO_COMPRESSION:g.lines=1,g.uncompress=ss;break;case D.RLE_COMPRESSION:g.lines=1,g.uncompress=ks;break;case D.ZIPS_COMPRESSION:g.lines=1,g.uncompress=hs,await is.Tools.LoadScriptAsync(Ks.FFLATEUrl);break;case D.ZIP_COMPRESSION:g.lines=16,g.uncompress=hs,await is.Tools.LoadScriptAsync(Ks.FFLATEUrl);break;case D.PIZ_COMPRESSION:g.lines=32,g.uncompress=gs;break;case D.PXR24_COMPRESSION:g.lines=16,g.uncompress=As,await is.Tools.LoadScriptAsync(Ks.FFLATEUrl);break;default:throw new Error(D[s.compression]+" is unsupported")}g.scanlineBlockSize=g.lines;const ms={};for(const i of s.channels)switch(i.name){case"R":case"G":case"B":case"A":case"Y":ms[i.name]=!0,g.type=i.pixelType}let K=!1;if(ms.R&&ms.G&&ms.B&&ms.A)g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(ms.R&&ms.G&&ms.B)K=!0,g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(ms.R&&ms.G)g.outputChannels=2,g.decodeChannels={R:0,G:1};else if(ms.R)g.outputChannels=1,g.decodeChannels={R:0};else{if(!ms.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");g.outputChannels=1,g.decodeChannels={Y:0}}if(1===g.type)switch(A){case mk.Float:g.getter=z,g.inputSize=H;break;case mk.HalfFloat:g.getter=I,g.inputSize=H}else{if(2!==g.type)throw new Error("Unsupported pixelType "+g.type+" for "+s.compression);switch(A){case mk.Float:g.getter=t,g.inputSize=i;break;case mk.HalfFloat:g.getter=C,g.inputSize=i}}g.blockCount=g.height/g.scanlineBlockSize;for(let i=0;i<g.blockCount;i++)b(k,h);const O=g.width*g.height*g.outputChannels;switch(A){case mk.Float:g.byteArray=new Float32Array(O),g.textureType=1,K&&g.byteArray.fill(1,0,O);break;case mk.HalfFloat:g.byteArray=new Uint16Array(O),g.textureType=2,K&&g.byteArray.fill(15360,0,O);break;default:throw new Error("Unsupported type: "+A)}let c=0;for(const i of s.channels)void 0!==g.decodeChannels[i.name]&&(g.channelLineOffsets[i.name]=c*g.width),c+=2*i.pixelType;return g.bytesPerLine=g.width*c,g.outLineWidth=g.width*g.outputChannels,"INCREASING_Y"===s.lineOrder?g.scanOrder=s=>s:g.scanOrder=s=>g.height-1-s,4==g.outputChannels?(g.format=5,g.linearSpace=!0):(g.format=6,g.linearSpace=!1),g}function Os(s,k,h,A){const g={value:0};for(let ms=0;ms<s.height/s.scanlineBlockSize;ms++){const i=G(h,A)-k.dataWindow.yMin;s.size=Q(h,A),s.lines=i+s.scanlineBlockSize>s.height?s.height-i:s.scanlineBlockSize;const K=s.size<s.lines*s.bytesPerLine&&s.uncompress?s.uncompress(s):ss(s);A.value+=s.size;for(let h=0;h<s.scanlineBlockSize;h++){const A=ms*s.scanlineBlockSize,i=h+s.scanOrder(A);if(i>=s.height)continue;const H=h*s.bytesPerLine,O=(s.height-1-i)*s.outLineWidth;for(let h=0;h<s.channels;h++){const A=k.channels[h].name,ms=s.channelLineOffsets[A],i=s.decodeChannels[A];if(void 0!==i){g.value=H+ms;for(let k=0;k<s.width;k++){const h=O+k*s.outputChannels+i;s.byteArray&&(s.byteArray[h]=s.getter(K,g))}}}}}}Ks.DefaultOutputType=mk.HalfFloat,Ks.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class cs{constructor(){this.supportCascades=!1}loadCubeData(s,k,h,A,g){throw".exr not supported in Cube."}loadData(s,k,h){const g=new DataView(s.buffer),ms={value:0},i=U(g,ms);Hs(i,g,ms,Ks.DefaultOutputType).then((s=>{Os(s,i,g,ms);const A=i.dataWindow.xMax-i.dataWindow.xMin+1,K=i.dataWindow.yMax-i.dataWindow.yMin+1;h(A,K,k.generateMipMaps,!1,(()=>{const h=k.getEngine();k.format=i.format,k.type=s.textureType,k.invertY=!1,k._gammaSpace=!i.linearSpace,s.byteArray&&h._uploadDataToTextureDirectly(k,s.byteArray,0,0,void 0,!0)}))})).catch((s=>{A.c.Error("Failed to load EXR texture: ",s)}))}}async function Ss(s){const k=new DataView(s),h={value:0},g=U(k,h);try{const s=await Hs(g,k,h,mk.Float);return Os(s,g,k,h),s.byteArray?{width:g.dataWindow.xMax-g.dataWindow.xMin+1,height:g.dataWindow.yMax-g.dataWindow.yMin+1,data:new Float32Array(s.byteArray)}:(A.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(ms){A.c.Error("Failed to load EXR data: ",ms)}return{width:0,height:0,data:null}}},12607:(s,k,h)=>{function A(s){return parseInt(s.toString().replace(/\W/g,""))}function g(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(s-k)<=h}function ms(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return s<k-A||s>h+A}function i(s,k){return s===k?s:Math.random()*(k-s)+s}function K(s,k,h){return s+(k-s)*h}function H(s,k,h){let A=j(k-s,360);return A>180&&(A-=360),s+A*a(h)}function O(s,k,h){let A=0;return A=s!=k?a((h-s)/(k-s)):0,A}function c(s,k,h,A,g){const ms=g*g,i=g*ms;return s*(2*i-3*ms+1)+h*(-2*i+3*ms)+k*(i-2*ms+g)+A*(i-ms)}function S(s,k,h,A,g){const ms=g*g;return 6*(ms-g)*s+(3*ms-4*g+1)*k+6*(-ms+g)*h+(3*ms-2*g)*A}function a(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(k,s))}function r(s){return s-=2*Math.PI*Math.floor((s+Math.PI)/(2*Math.PI))}function d(s){const k=s.toString(16);return s<=15?("0"+k).toUpperCase():k.toUpperCase()}function E(s){if(Math.log2)return Math.floor(Math.log2(s));if(s<0)return NaN;if(0===s)return-1/0;let k=0;if(s<1){for(;s<1;)k++,s*=2;k=-k}else if(s>1)for(;s>1;)k++,s=Math.floor(s/2);return k}function j(s,k){return s-Math.floor(s/k)*k}function P(s,k,h){return(s-k)/(h-k)}function R(s,k,h){return s*(h-k)+k}function D(s,k){let h=j(k-s,360);return h>180&&(h-=360),h}function w(s,k){const h=j(s,2*k);return k-Math.abs(h-k)}function B(s,k,h){let A=a(h);return A=-2*A*A*A+3*A*A,k*A+s*(1-A)}function u(s,k,h){let A=0;return A=Math.abs(k-s)<=h?k:s+Math.sign(k-s)*h,A}function G(s,k,h){const A=D(s,k);let g=0;return g=-h<A&&A<h?k:u(s,k=s+A,h),g}function Q(s,k,h){return(s-k)/(h-k)}function p(s,k,h){return(h-k)*s+k}function I(s,k){const h=s%k;return 0===h?k:I(k,h)}h.r(k),h.d(k,{Clamp:()=>a,DeltaAngle:()=>D,Denormalize:()=>R,ExtractAsInt:()=>A,Hermite:()=>c,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>I,ILog2:()=>E,InverseLerp:()=>O,Lerp:()=>K,LerpAngle:()=>H,MoveTowards:()=>u,MoveTowardsAngle:()=>G,Normalize:()=>P,NormalizeRadians:()=>r,OutsideRange:()=>ms,PercentToRange:()=>p,PingPong:()=>w,RandomRange:()=>i,RangeToPercent:()=>Q,Repeat:()=>j,SmoothStep:()=>B,ToHex:()=>d,WithinEpsilon:()=>g})}}]);