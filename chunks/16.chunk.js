"use strict";(self["9x1utqq1axc"]=self["9x1utqq1axc"]||[]).push([[16],{14797:(y,c,A)=>{A.r(c),A.d(c,{ReadExrDataAsync:()=>oy,_ExrTextureLoader:()=>qy});var l=A(12161),w=A(12340);const N=4,p=4,W=1,h=2,I=8,q=65536,o=q>>3,O=14,L=65537,i=1<<O,H=i-1,P=59,D=63,t=2+D-P;var s,B;!function(y){y[y.NO_COMPRESSION=0]="NO_COMPRESSION",y[y.RLE_COMPRESSION=1]="RLE_COMPRESSION",y[y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",y[y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",y[y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",y[y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(s||(s={})),function(y){y[y.INCREASING_Y=0]="INCREASING_Y",y[y.DECREASING_Y=1]="DECREASING_Y"}(B||(B={}));const X=function(){const y=new ArrayBuffer(4),c=new Float32Array(y),A=new Uint32Array(y),l=new Uint32Array(512),w=new Uint32Array(512);for(let h=0;h<256;++h){const y=h-127;y<-27?(l[h]=0,l[256|h]=32768,w[h]=24,w[256|h]=24):y<-14?(l[h]=1024>>-y-14,l[256|h]=1024>>-y-14|32768,w[h]=-y-1,w[256|h]=-y-1):y<=15?(l[h]=y+15<<10,l[256|h]=y+15<<10|32768,w[h]=13,w[256|h]=13):y<128?(l[h]=31744,l[256|h]=64512,w[h]=24,w[256|h]=24):(l[h]=31744,l[256|h]=64512,w[h]=13,w[256|h]=13)}const N=new Uint32Array(2048),p=new Uint32Array(64),W=new Uint32Array(64);for(let h=1;h<1024;++h){let y=h<<13,c=0;for(;0===(8388608&y);)y<<=1,c-=8388608;y&=-8388609,c+=947912704,N[h]=y|c}for(let h=1024;h<2048;++h)N[h]=939524096+(h-1024<<13);for(let h=1;h<31;++h)p[h]=h<<23;p[31]=1199570944,p[32]=2147483648;for(let h=33;h<63;++h)p[h]=2147483648+(h-32<<23);p[63]=3347054592;for(let h=1;h<64;++h)32!==h&&(W[h]=1024);return{floatView:c,uint32View:A,baseTable:l,shiftTable:w,mantissaTable:N,exponentTable:p,offsetTable:W}}();function C(y,c){const A=new Uint8Array(y);let l=0;for(;0!=A[c.value+l];)l+=1;const w=(new TextDecoder).decode(A.slice(c.value,c.value+l));return c.value=c.value+l+1,w}function K(y,c){const A=y.getInt32(c.value,!0);return c.value+=N,A}function my(y,c){const A=y.getUint32(c.value,!0);return c.value+=N,A}function T(y,c){const A=y.getUint8(c.value);return c.value+=W,A}function z(y,c){const A=y.getUint16(c.value,!0);return c.value+=h,A}function S(y,c){const A=y[c.value];return c.value+=W,A}function M(y,c){let A;return A="getBigInt64"in DataView.prototype?Number(y.getBigInt64(c.value,!0)):y.getUint32(c.value+4,!0)+Number(y.getUint32(c.value,!0)<<32),c.value+=I,A}function k(y,c){const A=y.getFloat32(c.value,!0);return c.value+=p,A}function a(y,c){return function(y){const c=(31744&y)>>10,A=1023&y;return(y>>15?-1:1)*(c?31===c?A?NaN:1/0:Math.pow(2,c-15)*(1+A/1024):A/1024*6103515625e-14)}(z(y,c))}function u(y,c){return function(y){if(Math.abs(y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");y=(0,w.Clamp)(y,-65504,65504),X.floatView[0]=y;const c=X.uint32View[0],A=c>>23&511;return X.baseTable[A]+((8388607&c)>>X.shiftTable[A])}(k(y,c))}function G(y,c,A,l){switch(A){case"string":case"stringvector":case"iccProfile":return function(y,c,A){const l=(new TextDecoder).decode(new Uint8Array(y).slice(c.value,c.value+A));return c.value=c.value+A,l}(y.buffer,c,l);case"chlist":return function(y,c,A){const l=c.value,w=[];for(;c.value<l+A-1;){const A=C(y.buffer,c),l=K(y,c),N=T(y,c);c.value+=3;const p=K(y,c),W=K(y,c);w.push({name:A,pixelType:l,pLinear:N,xSampling:p,ySampling:W})}return c.value+=1,w}(y,c,l);case"chromaticities":return function(y,c){return{redX:k(y,c),redY:k(y,c),greenX:k(y,c),greenY:k(y,c),blueX:k(y,c),blueY:k(y,c),whiteX:k(y,c),whiteY:k(y,c)}}(y,c);case"compression":return function(y,c){return T(y,c)}(y,c);case"box2i":return function(y,c){return{xMin:K(y,c),yMin:K(y,c),xMax:K(y,c),yMax:K(y,c)}}(y,c);case"lineOrder":return function(y,c){const A=T(y,c);return B[A]}(y,c);case"float":return k(y,c);case"v2f":return function(y,c){return[k(y,c),k(y,c)]}(y,c);case"v3f":return function(y,c){return[k(y,c),k(y,c),k(y,c)]}(y,c);case"int":return K(y,c);case"rational":return function(y,c){return[K(y,c),my(y,c)]}(y,c);case"timecode":return function(y,c){return[my(y,c),my(y,c)]}(y,c);case"preview":return c.value+=l,"skipped";default:return void(c.value+=l)}}function j(y){for(let c=1;c<y.length;c++){const A=y[c-1]+y[c]-128;y[c]=A}}function f(y,c){let A=0,l=Math.floor((y.length+1)/2),w=0;const N=y.length-1;for(;!(w>N)&&(c[w++]=y[A++],!(w>N));)c[w++]=y[l++]}const V=20000630;function J(y,c){if(y.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const A=y.getUint8(4),w=y.getUint8(5),N={singleTile:!!(2&w),longName:!!(4&w),deepFormat:!!(8&w),multiPart:!!(16&w)};c.value=8;const p={};let W=!0;for(;W;){const A=C(y.buffer,c);if(A){const w=C(y.buffer,c),N=G(y,c,w,my(y,c));void 0===N?l.c.Warn(`Unknown header attribute type ${w}'.`):p[A]=N}else W=!1}if(0!=(-5&w))throw new Error("Unsupported file format");return{version:A,spec:N,...p}}const U=32768,e=65535;function Q(y,c,A,l,w){for(;A<y;)c=c<<8|S(l,w),A+=8;return{l:c>>(A-=y)&(1<<y)-1,c:c,lc:A}}function Y(y,c,A,l){return{c:y=y<<8|S(A,l),lc:c+=8}}function g(y,c,A,l,w,N,p,W,h){if(y==c){if(l<8){const y=Y(A,l,w,N);A=y.c,l=y.lc}let y=A>>(l-=8);if(y=new Uint8Array([y])[0],W.value+y>h)return null;const c=p[W.value-1];for(;y-- >0;)p[W.value++]=c}else{if(!(W.value<h))return null;p[W.value++]=y}return{c:A,lc:l}}const x=new Array(59);function F(y,c,A,l,w,N){const p=c;let W=0,h=0;for(;l<=w;l++){if(p.value-c.value>A)return;let I=Q(6,W,h,y,p);const q=I.l;if(W=I.c,h=I.lc,N[l]=q,q==D){if(p.value-c.value>A)throw new Error("Error in HufUnpackEncTable");I=Q(8,W,h,y,p);let q=I.l+t;if(W=I.c,h=I.lc,l+q>w+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)N[l++]=0;l--}else if(q>=P){let y=q-P+2;if(l+y>w+1)throw new Error("Error in HufUnpackEncTable");for(;y--;)N[l++]=0;l--}}!function(y){for(let A=0;A<=58;++A)x[A]=0;for(let A=0;A<L;++A)x[y[A]]+=1;let c=0;for(let A=58;A>0;--A){const y=c+x[A]>>1;x[A]=c,c=y}for(let A=0;A<L;++A){const c=y[A];c>0&&(y[A]=c|x[c]++<<6)}}(N)}function R(y){return 63&y}function r(y){return y>>6}function n(y,c,A,l,w,N){const p=A.value,W=my(c,A),h=my(c,A);A.value+=4;const I=my(c,A);if(A.value+=4,W<0||W>=L||h<0||h>=L)throw new Error("Wrong HUF_ENCSIZE");const q=new Array(L),o=new Array(i);!function(y){for(let c=0;c<i;c++)y[c]={},y[c].len=0,y[c].lit=0,y[c].p=null}(o);if(F(y,A,l-(A.value-p),W,h,q),I>8*(l-(A.value-p)))throw new Error("Wrong hufUncompress");!function(y,c,A,l){for(;c<=A;c++){const A=r(y[c]),w=R(y[c]);if(A>>w)throw new Error("Invalid table entry");if(w>O){const y=l[A>>w-O];if(y.len)throw new Error("Invalid table entry");if(y.lit++,y.p){const c=y.p;y.p=new Array(y.lit);for(let A=0;A<y.lit-1;++A)y.p[A]=c[A]}else y.p=new Array(1);y.p[y.lit-1]=c}else if(w){let y=0;for(let N=1<<O-w;N>0;N--){const N=l[(A<<O-w)+y];if(N.len||N.p)throw new Error("Invalid table entry");N.len=w,N.lit=c,y++}}}}(q,W,h,o),function(y,c,A,l,w,N,p,W,h){let I=0,q=0;const o=p,L=Math.trunc(l.value+(w+7)/8);for(;l.value<L;){let w=Y(I,q,A,l);for(I=w.c,q=w.lc;q>=O;){const p=c[I>>q-O&H];if(p.len){q-=p.len;const y=g(p.lit,N,I,q,A,l,W,h,o);y&&(I=y.c,q=y.lc)}else{if(!p.p)throw new Error("hufDecode issues");let c;for(c=0;c<p.lit;c++){const O=R(y[p.p[c]]);for(;q<O&&l.value<L;)w=Y(I,q,A,l),I=w.c,q=w.lc;if(q>=O&&r(y[p.p[c]])==(I>>q-O&(1<<O)-1)){q-=O;const y=g(p.p[c],N,I,q,A,l,W,h,o);y&&(I=y.c,q=y.lc);break}}if(c==p.lit)throw new Error("HufDecode issues")}}}const i=8-w&7;for(I>>=i,q-=i;q>0;){const y=c[I<<O-q&H];if(!y.len)throw new Error("HufDecode issues");{q-=y.len;const c=g(y.lit,N,I,q,A,l,W,h,o);c&&(I=c.c,q=c.lc)}}}(q,o,y,A,I,h,N,w,{value:0})}function E(y){return 65535&y}function b(y){const c=E(y);return c>32767?c-65536:c}function Z(y,c){const A=b(y),l=b(c),w=A+(1&l)+(l>>1);return{a:w,b:w-l}}function v(y,c){const A=E(y),l=E(c),w=A-(l>>1)&e;return{a:l+w-U&e,b:w}}function d(y,c,A,l,w,N,p){const W=p<16384,h=A>w?w:A;let I,q,o=1;for(;o<=h;)o<<=1;for(o>>=1,I=o,o>>=1;o>=1;){q=0;const p=q+N*(w-I),h=N*o,O=N*I,L=l*o,i=l*I;let H,P,D,t;for(;q<=p;q+=O){let w=q;const N=q+l*(A-I);for(;w<=N;w+=i){const A=w+L,l=w+h,N=l+L;if(W){let p=Z(y[w+c],y[l+c]);H=p.a,D=p.b,p=Z(y[A+c],y[N+c]),P=p.a,t=p.b,p=Z(H,P),y[w+c]=p.a,y[A+c]=p.b,p=Z(D,t),y[l+c]=p.a,y[N+c]=p.b}else{let p=v(y[w+c],y[l+c]);H=p.a,D=p.b,p=v(y[A+c],y[N+c]),P=p.a,t=p.b,p=v(H,P),y[w+c]=p.a,y[A+c]=p.b,p=v(D,t),y[l+c]=p.a,y[N+c]=p.b}}if(A&o){const A=w+h;let l;l=W?Z(y[w+c],y[A+c]):v(y[w+c],y[A+c]),H=l.a,y[A+c]=l.b,y[w+c]=H}}if(w&o){let w=q;const N=q+l*(A-I);for(;w<=N;w+=i){const A=w+L;let l;l=W?Z(y[w+c],y[A+c]):v(y[w+c],y[A+c]),H=l.a,y[A+c]=l.b,y[w+c]=H}}I=o,o>>=1}return q}function yy(y){return new DataView(y.array.buffer,y.offset.value,y.size)}function cy(y){const c=y.viewer.buffer.slice(y.offset.value,y.offset.value+y.size),A=new Uint8Array(function(y){let c=y.byteLength;const A=[];let l=0;const w=new DataView(y);for(;c>0;){const y=w.getInt8(l++);if(y<0){const N=-y;c-=N+1;for(let y=0;y<N;y++)A.push(w.getUint8(l++))}else{const N=y;c-=2;const p=w.getUint8(l++);for(let y=0;y<N+1;y++)A.push(p)}}return A}(c)),l=new Uint8Array(A.length);return j(A),f(A,l),new DataView(l.buffer)}function Ay(y){const c=y.array.slice(y.offset.value,y.offset.value+y.size),A=fflate.unzlibSync(c),l=new Uint8Array(A.length);return j(A),f(A,l),new DataView(l.buffer)}function ly(y){const c=y.array.slice(y.offset.value,y.offset.value+y.size),A=fflate.unzlibSync(c),l=y.lines*y.channels*y.width,w=1==y.type?new Uint16Array(l):new Uint32Array(l);let N=0,p=0;const W=new Array(4);for(let h=0;h<y.lines;h++)for(let c=0;c<y.channels;c++){let c=0;switch(y.type){case 1:W[0]=N,W[1]=W[0]+y.width,N=W[1]+y.width;for(let l=0;l<y.width;++l){c+=A[W[0]++]<<8|A[W[1]++],w[p]=c,p++}break;case 2:W[0]=N,W[1]=W[0]+y.width,W[2]=W[1]+y.width,N=W[2]+y.width;for(let l=0;l<y.width;++l){c+=A[W[0]++]<<24|A[W[1]++]<<16|A[W[2]++]<<8,w[p]=c,p++}}}return new DataView(w.buffer)}function wy(y){const c=y.viewer,A={value:y.offset.value},l=new Uint16Array(y.width*y.scanlineBlockSize*(y.channels*y.type)),w=new Uint8Array(o);let N=0;const p=new Array(y.channels);for(let h=0;h<y.channels;h++)p[h]={},p[h].start=N,p[h].end=p[h].start,p[h].nx=y.width,p[h].ny=y.lines,p[h].size=y.type,N+=p[h].nx*p[h].ny*p[h].size;const W=z(c,A),I=z(c,A);if(I>=o)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(W<=I)for(let h=0;h<I-W+1;h++)w[h+W]=T(c,A);const O=new Uint16Array(q),L=function(y,c){let A=0;for(let w=0;w<q;++w)(0==w||y[w>>3]&1<<(7&w))&&(c[A++]=w);const l=A-1;for(;A<q;)c[A++]=0;return l}(w,O),i=my(c,A);n(y.array,c,A,i,l,N);for(let h=0;h<y.channels;++h){const y=p[h];for(let c=0;c<p[h].size;++c)d(l,y.start+c,y.nx,y.size,y.ny,y.nx*y.size,L)}!function(y,c,A){for(let l=0;l<A;++l)c[l]=y[c[l]]}(O,l,N);let H=0;const P=new Uint8Array(l.buffer.byteLength);for(let q=0;q<y.lines;q++)for(let c=0;c<y.channels;c++){const y=p[c],A=y.nx*y.size,w=new Uint8Array(l.buffer,y.end*h,A*h);P.set(w,H),H+=A*h,y.end+=A}return new DataView(P.buffer)}var Ny,py=A(12144);!function(y){y[y.Float=0]="Float",y[y.HalfFloat=1]="HalfFloat"}(Ny||(Ny={}));class Wy{}async function hy(y,c,A,l){const w={size:0,viewer:c,array:new Uint8Array(c.buffer),offset:A,width:y.dataWindow.xMax-y.dataWindow.xMin+1,height:y.dataWindow.yMax-y.dataWindow.yMin+1,channels:y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(y.compression){case s.NO_COMPRESSION:w.lines=1,w.uncompress=yy;break;case s.RLE_COMPRESSION:w.lines=1,w.uncompress=cy;break;case s.ZIPS_COMPRESSION:w.lines=1,w.uncompress=Ay,await py.Tools.LoadScriptAsync(Wy.FFLATEUrl);break;case s.ZIP_COMPRESSION:w.lines=16,w.uncompress=Ay,await py.Tools.LoadScriptAsync(Wy.FFLATEUrl);break;case s.PIZ_COMPRESSION:w.lines=32,w.uncompress=wy;break;case s.PXR24_COMPRESSION:w.lines=16,w.uncompress=ly,await py.Tools.LoadScriptAsync(Wy.FFLATEUrl);break;default:throw new Error(s[y.compression]+" is unsupported")}w.scanlineBlockSize=w.lines;const N={};for(const p of y.channels)switch(p.name){case"R":case"G":case"B":case"A":case"Y":N[p.name]=!0,w.type=p.pixelType}let W=!1;if(N.R&&N.G&&N.B&&N.A)w.outputChannels=4,w.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G&&N.B)W=!0,w.outputChannels=4,w.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G)w.outputChannels=2,w.decodeChannels={R:0,G:1};else if(N.R)w.outputChannels=1,w.decodeChannels={R:0};else{if(!N.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");w.outputChannels=1,w.decodeChannels={Y:0}}if(1===w.type)switch(l){case Ny.Float:w.getter=a,w.inputSize=h;break;case Ny.HalfFloat:w.getter=z,w.inputSize=h}else{if(2!==w.type)throw new Error("Unsupported pixelType "+w.type+" for "+y.compression);switch(l){case Ny.Float:w.getter=k,w.inputSize=p;break;case Ny.HalfFloat:w.getter=u,w.inputSize=p}}w.blockCount=w.height/w.scanlineBlockSize;for(let p=0;p<w.blockCount;p++)M(c,A);const I=w.width*w.height*w.outputChannels;switch(l){case Ny.Float:w.byteArray=new Float32Array(I),w.textureType=1,W&&w.byteArray.fill(1,0,I);break;case Ny.HalfFloat:w.byteArray=new Uint16Array(I),w.textureType=2,W&&w.byteArray.fill(15360,0,I);break;default:throw new Error("Unsupported type: "+l)}let q=0;for(const p of y.channels)void 0!==w.decodeChannels[p.name]&&(w.channelLineOffsets[p.name]=q*w.width),q+=2*p.pixelType;return w.bytesPerLine=w.width*q,w.outLineWidth=w.width*w.outputChannels,"INCREASING_Y"===y.lineOrder?w.scanOrder=y=>y:w.scanOrder=y=>w.height-1-y,4==w.outputChannels?(w.format=5,w.linearSpace=!0):(w.format=6,w.linearSpace=!1),w}function Iy(y,c,A,l){const w={value:0};for(let N=0;N<y.height/y.scanlineBlockSize;N++){const p=K(A,l)-c.dataWindow.yMin;y.size=my(A,l),y.lines=p+y.scanlineBlockSize>y.height?y.height-p:y.scanlineBlockSize;const W=y.size<y.lines*y.bytesPerLine&&y.uncompress?y.uncompress(y):yy(y);l.value+=y.size;for(let A=0;A<y.scanlineBlockSize;A++){const l=N*y.scanlineBlockSize,p=A+y.scanOrder(l);if(p>=y.height)continue;const h=A*y.bytesPerLine,I=(y.height-1-p)*y.outLineWidth;for(let A=0;A<y.channels;A++){const l=c.channels[A].name,N=y.channelLineOffsets[l],p=y.decodeChannels[l];if(void 0!==p){w.value=h+N;for(let c=0;c<y.width;c++){const A=I+c*y.outputChannels+p;y.byteArray&&(y.byteArray[A]=y.getter(W,w))}}}}}}Wy.DefaultOutputType=Ny.HalfFloat,Wy.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class qy{constructor(){this.supportCascades=!1}loadCubeData(y,c,A,l,w){throw".exr not supported in Cube."}loadData(y,c,A){const w=new DataView(y.buffer),N={value:0},p=J(w,N);hy(p,w,N,Wy.DefaultOutputType).then((y=>{Iy(y,p,w,N);const l=p.dataWindow.xMax-p.dataWindow.xMin+1,W=p.dataWindow.yMax-p.dataWindow.yMin+1;A(l,W,c.generateMipMaps,!1,(()=>{const A=c.getEngine();c.format=p.format,c.type=y.textureType,c.invertY=!1,c._gammaSpace=!p.linearSpace,y.byteArray&&A._uploadDataToTextureDirectly(c,y.byteArray,0,0,void 0,!0)}))})).catch((y=>{l.c.Error("Failed to load EXR texture: ",y)}))}}async function oy(y){const c=new DataView(y),A={value:0},w=J(c,A);try{const y=await hy(w,c,A,Ny.Float);return Iy(y,w,c,A),y.byteArray?{width:w.dataWindow.xMax-w.dataWindow.xMin+1,height:w.dataWindow.yMax-w.dataWindow.yMin+1,data:new Float32Array(y.byteArray)}:(l.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(N){l.c.Error("Failed to load EXR data: ",N)}return{width:0,height:0,data:null}}},12340:(y,c,A)=>{function l(y){return parseInt(y.toString().replace(/\W/g,""))}function w(y,c){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(y-c)<=A}function N(y,c,A){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return y<c-l||y>A+l}function p(y,c){return y===c?y:Math.random()*(c-y)+y}function W(y,c,A){return y+(c-y)*A}function h(y,c,A){let l=P(c-y,360);return l>180&&(l-=360),y+l*O(A)}function I(y,c,A){let l=0;return l=y!=c?O((A-y)/(c-y)):0,l}function q(y,c,A,l,w){const N=w*w,p=w*N;return y*(2*p-3*N+1)+A*(-2*p+3*N)+c*(p-2*N+w)+l*(p-N)}function o(y,c,A,l,w){const N=w*w;return 6*(N-w)*y+(3*N-4*w+1)*c+6*(-N+w)*A+(3*N-2*w)*l}function O(y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(A,Math.max(c,y))}function L(y){return y-=2*Math.PI*Math.floor((y+Math.PI)/(2*Math.PI))}function i(y){const c=y.toString(16);return y<=15?("0"+c).toUpperCase():c.toUpperCase()}function H(y){if(Math.log2)return Math.floor(Math.log2(y));if(y<0)return NaN;if(0===y)return-1/0;let c=0;if(y<1){for(;y<1;)c++,y*=2;c=-c}else if(y>1)for(;y>1;)c++,y=Math.floor(y/2);return c}function P(y,c){return y-Math.floor(y/c)*c}function D(y,c,A){return(y-c)/(A-c)}function t(y,c,A){return y*(A-c)+c}function s(y,c){let A=P(c-y,360);return A>180&&(A-=360),A}function B(y,c){const A=P(y,2*c);return c-Math.abs(A-c)}function X(y,c,A){let l=O(A);return l=-2*l*l*l+3*l*l,c*l+y*(1-l)}function C(y,c,A){let l=0;return l=Math.abs(c-y)<=A?c:y+Math.sign(c-y)*A,l}function K(y,c,A){const l=s(y,c);let w=0;return w=-A<l&&l<A?c:C(y,c=y+l,A),w}function my(y,c,A){return(y-c)/(A-c)}function T(y,c,A){return(A-c)*y+c}function z(y,c){const A=y%c;return 0===A?c:z(c,A)}A.r(c),A.d(c,{Clamp:()=>O,DeltaAngle:()=>s,Denormalize:()=>t,ExtractAsInt:()=>l,Hermite:()=>q,Hermite1stDerivative:()=>o,HighestCommonFactor:()=>z,ILog2:()=>H,InverseLerp:()=>I,Lerp:()=>W,LerpAngle:()=>h,MoveTowards:()=>C,MoveTowardsAngle:()=>K,Normalize:()=>D,NormalizeRadians:()=>L,OutsideRange:()=>N,PercentToRange:()=>T,PingPong:()=>B,RandomRange:()=>p,RangeToPercent:()=>my,Repeat:()=>P,SmoothStep:()=>X,ToHex:()=>i,WithinEpsilon:()=>w})}}]);