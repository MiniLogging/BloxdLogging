"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13693:(P,f,Y)=>{Y.r(f),Y.d(f,{ReadExrDataAsync:()=>yP,_ExrTextureLoader:()=>RP});var C=Y(11025),q=Y(11198);const m=4,L=4,o=1,w=2,d=8,R=65536,y=R>>3,r=14,i=65537,u=1<<r,g=u-1,S=59,K=63,M=2+K-S;var V,O;!function(P){P[P.NO_COMPRESSION=0]="NO_COMPRESSION",P[P.RLE_COMPRESSION=1]="RLE_COMPRESSION",P[P.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",P[P.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",P[P.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",P[P.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(V||(V={})),function(P){P[P.INCREASING_Y=0]="INCREASING_Y",P[P.DECREASING_Y=1]="DECREASING_Y"}(O||(O={}));const n=function(){const P=new ArrayBuffer(4),f=new Float32Array(P),Y=new Uint32Array(P),C=new Uint32Array(512),q=new Uint32Array(512);for(let w=0;w<256;++w){const P=w-127;P<-27?(C[w]=0,C[256|w]=32768,q[w]=24,q[256|w]=24):P<-14?(C[w]=1024>>-P-14,C[256|w]=1024>>-P-14|32768,q[w]=-P-1,q[256|w]=-P-1):P<=15?(C[w]=P+15<<10,C[256|w]=P+15<<10|32768,q[w]=13,q[256|w]=13):P<128?(C[w]=31744,C[256|w]=64512,q[w]=24,q[256|w]=24):(C[w]=31744,C[256|w]=64512,q[w]=13,q[256|w]=13)}const m=new Uint32Array(2048),L=new Uint32Array(64),o=new Uint32Array(64);for(let w=1;w<1024;++w){let P=w<<13,f=0;for(;0===(8388608&P);)P<<=1,f-=8388608;P&=-8388609,f+=947912704,m[w]=P|f}for(let w=1024;w<2048;++w)m[w]=939524096+(w-1024<<13);for(let w=1;w<31;++w)L[w]=w<<23;L[31]=1199570944,L[32]=2147483648;for(let w=33;w<63;++w)L[w]=2147483648+(w-32<<23);L[63]=3347054592;for(let w=1;w<64;++w)32!==w&&(o[w]=1024);return{floatView:f,uint32View:Y,baseTable:C,shiftTable:q,mantissaTable:m,exponentTable:L,offsetTable:o}}();function l(P,f){const Y=new Uint8Array(P);let C=0;for(;0!=Y[f.value+C];)C+=1;const q=(new TextDecoder).decode(Y.slice(f.value,f.value+C));return f.value=f.value+C+1,q}function v(P,f){const Y=P.getInt32(f.value,!0);return f.value+=m,Y}function c(P,f){const Y=P.getUint32(f.value,!0);return f.value+=m,Y}function T(P,f){const Y=P.getUint8(f.value);return f.value+=o,Y}function U(P,f){const Y=P.getUint16(f.value,!0);return f.value+=w,Y}function D(P,f){const Y=P[f.value];return f.value+=o,Y}function j(P,f){let Y;return Y="getBigInt64"in DataView.prototype?Number(P.getBigInt64(f.value,!0)):P.getUint32(f.value+4,!0)+Number(P.getUint32(f.value,!0)<<32),f.value+=d,Y}function e(P,f){const Y=P.getFloat32(f.value,!0);return f.value+=L,Y}function s(P,f){return function(P){const f=(31744&P)>>10,Y=1023&P;return(P>>15?-1:1)*(f?31===f?Y?NaN:1/0:Math.pow(2,f-15)*(1+Y/1024):Y/1024*6103515625e-14)}(U(P,f))}function a(P,f){return function(P){if(Math.abs(P)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");P=(0,q.Clamp)(P,-65504,65504),n.floatView[0]=P;const f=n.uint32View[0],Y=f>>23&511;return n.baseTable[Y]+((8388607&f)>>n.shiftTable[Y])}(e(P,f))}function Q(P,f,Y,C){switch(Y){case"string":case"stringvector":case"iccProfile":return function(P,f,Y){const C=(new TextDecoder).decode(new Uint8Array(P).slice(f.value,f.value+Y));return f.value=f.value+Y,C}(P.buffer,f,C);case"chlist":return function(P,f,Y){const C=f.value,q=[];for(;f.value<C+Y-1;){const Y=l(P.buffer,f),C=v(P,f),m=T(P,f);f.value+=3;const L=v(P,f),o=v(P,f);q.push({name:Y,pixelType:C,pLinear:m,xSampling:L,ySampling:o})}return f.value+=1,q}(P,f,C);case"chromaticities":return function(P,f){return{redX:e(P,f),redY:e(P,f),greenX:e(P,f),greenY:e(P,f),blueX:e(P,f),blueY:e(P,f),whiteX:e(P,f),whiteY:e(P,f)}}(P,f);case"compression":return function(P,f){return T(P,f)}(P,f);case"box2i":return function(P,f){return{xMin:v(P,f),yMin:v(P,f),xMax:v(P,f),yMax:v(P,f)}}(P,f);case"lineOrder":return function(P,f){const Y=T(P,f);return O[Y]}(P,f);case"float":return e(P,f);case"v2f":return function(P,f){return[e(P,f),e(P,f)]}(P,f);case"v3f":return function(P,f){return[e(P,f),e(P,f),e(P,f)]}(P,f);case"int":return v(P,f);case"rational":return function(P,f){return[v(P,f),c(P,f)]}(P,f);case"timecode":return function(P,f){return[c(P,f),c(P,f)]}(P,f);case"preview":return f.value+=C,"skipped";default:return void(f.value+=C)}}function J(P){for(let f=1;f<P.length;f++){const Y=P[f-1]+P[f]-128;P[f]=Y}}function N(P,f){let Y=0,C=Math.floor((P.length+1)/2),q=0;const m=P.length-1;for(;!(q>m)&&(f[q++]=P[Y++],!(q>m));)f[q++]=P[C++]}const I=20000630;function X(P,f){if(P.getUint32(0,!0)!=I)throw new Error("Incorrect OpenEXR format");const Y=P.getUint8(4),q=P.getUint8(5),m={singleTile:!!(2&q),longName:!!(4&q),deepFormat:!!(8&q),multiPart:!!(16&q)};f.value=8;const L={};let o=!0;for(;o;){const Y=l(P.buffer,f);if(Y){const q=l(P.buffer,f),m=Q(P,f,q,c(P,f));void 0===m?C.e.Warn(`Unknown header attribute type ${q}'.`):L[Y]=m}else o=!1}if(0!=(-5&q))throw new Error("Unsupported file format");return{version:Y,spec:m,...L}}const x=32768,k=65535;function Z(P,f,Y,C,q){for(;Y<P;)f=f<<8|D(C,q),Y+=8;return{l:f>>(Y-=P)&(1<<P)-1,c:f,lc:Y}}function A(P,f,Y,C){return{c:P=P<<8|D(Y,C),lc:f+=8}}function E(P,f,Y,C,q,m,L,o,w){if(P==f){if(C<8){const P=A(Y,C,q,m);Y=P.c,C=P.lc}let P=Y>>(C-=8);if(P=new Uint8Array([P])[0],o.value+P>w)return null;const f=L[o.value-1];for(;P-- >0;)L[o.value++]=f}else{if(!(o.value<w))return null;L[o.value++]=P}return{c:Y,lc:C}}const t=new Array(59);function G(P,f,Y,C,q,m){const L=f;let o=0,w=0;for(;C<=q;C++){if(L.value-f.value>Y)return;let d=Z(6,o,w,P,L);const R=d.l;if(o=d.c,w=d.lc,m[C]=R,R==K){if(L.value-f.value>Y)throw new Error("Error in HufUnpackEncTable");d=Z(8,o,w,P,L);let R=d.l+M;if(o=d.c,w=d.lc,C+R>q+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)m[C++]=0;C--}else if(R>=S){let P=R-S+2;if(C+P>q+1)throw new Error("Error in HufUnpackEncTable");for(;P--;)m[C++]=0;C--}}!function(P){for(let Y=0;Y<=58;++Y)t[Y]=0;for(let Y=0;Y<i;++Y)t[P[Y]]+=1;let f=0;for(let Y=58;Y>0;--Y){const P=f+t[Y]>>1;t[Y]=f,f=P}for(let Y=0;Y<i;++Y){const f=P[Y];f>0&&(P[Y]=f|t[f]++<<6)}}(m)}function z(P){return 63&P}function B(P){return P>>6}function b(P,f,Y,C,q,m){const L=Y.value,o=c(f,Y),w=c(f,Y);Y.value+=4;const d=c(f,Y);if(Y.value+=4,o<0||o>=i||w<0||w>=i)throw new Error("Wrong HUF_ENCSIZE");const R=new Array(i),y=new Array(u);!function(P){for(let f=0;f<u;f++)P[f]={},P[f].len=0,P[f].lit=0,P[f].p=null}(y);if(G(P,Y,C-(Y.value-L),o,w,R),d>8*(C-(Y.value-L)))throw new Error("Wrong hufUncompress");!function(P,f,Y,C){for(;f<=Y;f++){const Y=B(P[f]),q=z(P[f]);if(Y>>q)throw new Error("Invalid table entry");if(q>r){const P=C[Y>>q-r];if(P.len)throw new Error("Invalid table entry");if(P.lit++,P.p){const f=P.p;P.p=new Array(P.lit);for(let Y=0;Y<P.lit-1;++Y)P.p[Y]=f[Y]}else P.p=new Array(1);P.p[P.lit-1]=f}else if(q){let P=0;for(let m=1<<r-q;m>0;m--){const m=C[(Y<<r-q)+P];if(m.len||m.p)throw new Error("Invalid table entry");m.len=q,m.lit=f,P++}}}}(R,o,w,y),function(P,f,Y,C,q,m,L,o,w){let d=0,R=0;const y=L,i=Math.trunc(C.value+(q+7)/8);for(;C.value<i;){let q=A(d,R,Y,C);for(d=q.c,R=q.lc;R>=r;){const L=f[d>>R-r&g];if(L.len){R-=L.len;const P=E(L.lit,m,d,R,Y,C,o,w,y);P&&(d=P.c,R=P.lc)}else{if(!L.p)throw new Error("hufDecode issues");let f;for(f=0;f<L.lit;f++){const r=z(P[L.p[f]]);for(;R<r&&C.value<i;)q=A(d,R,Y,C),d=q.c,R=q.lc;if(R>=r&&B(P[L.p[f]])==(d>>R-r&(1<<r)-1)){R-=r;const P=E(L.p[f],m,d,R,Y,C,o,w,y);P&&(d=P.c,R=P.lc);break}}if(f==L.lit)throw new Error("HufDecode issues")}}}const u=8-q&7;for(d>>=u,R-=u;R>0;){const P=f[d<<r-R&g];if(!P.len)throw new Error("HufDecode issues");{R-=P.len;const f=E(P.lit,m,d,R,Y,C,o,w,y);f&&(d=f.c,R=f.lc)}}}(R,y,P,Y,d,w,m,q,{value:0})}function H(P){return 65535&P}function W(P){const f=H(P);return f>32767?f-65536:f}function p(P,f){const Y=W(P),C=W(f),q=Y+(1&C)+(C>>1);return{a:q,b:q-C}}function h(P,f){const Y=H(P),C=H(f),q=Y-(C>>1)&k;return{a:C+q-x&k,b:q}}function F(P,f,Y,C,q,m,L){const o=L<16384,w=Y>q?q:Y;let d,R,y=1;for(;y<=w;)y<<=1;for(y>>=1,d=y,y>>=1;y>=1;){R=0;const L=R+m*(q-d),w=m*y,r=m*d,i=C*y,u=C*d;let g,S,K,M;for(;R<=L;R+=r){let q=R;const m=R+C*(Y-d);for(;q<=m;q+=u){const Y=q+i,C=q+w,m=C+i;if(o){let L=p(P[q+f],P[C+f]);g=L.a,K=L.b,L=p(P[Y+f],P[m+f]),S=L.a,M=L.b,L=p(g,S),P[q+f]=L.a,P[Y+f]=L.b,L=p(K,M),P[C+f]=L.a,P[m+f]=L.b}else{let L=h(P[q+f],P[C+f]);g=L.a,K=L.b,L=h(P[Y+f],P[m+f]),S=L.a,M=L.b,L=h(g,S),P[q+f]=L.a,P[Y+f]=L.b,L=h(K,M),P[C+f]=L.a,P[m+f]=L.b}}if(Y&y){const Y=q+w;let C;C=o?p(P[q+f],P[Y+f]):h(P[q+f],P[Y+f]),g=C.a,P[Y+f]=C.b,P[q+f]=g}}if(q&y){let q=R;const m=R+C*(Y-d);for(;q<=m;q+=u){const Y=q+i;let C;C=o?p(P[q+f],P[Y+f]):h(P[q+f],P[Y+f]),g=C.a,P[Y+f]=C.b,P[q+f]=g}}d=y,y>>=1}return R}function PP(P){return new DataView(P.array.buffer,P.offset.value,P.size)}function fP(P){const f=P.viewer.buffer.slice(P.offset.value,P.offset.value+P.size),Y=new Uint8Array(function(P){let f=P.byteLength;const Y=[];let C=0;const q=new DataView(P);for(;f>0;){const P=q.getInt8(C++);if(P<0){const m=-P;f-=m+1;for(let P=0;P<m;P++)Y.push(q.getUint8(C++))}else{const m=P;f-=2;const L=q.getUint8(C++);for(let P=0;P<m+1;P++)Y.push(L)}}return Y}(f)),C=new Uint8Array(Y.length);return J(Y),N(Y,C),new DataView(C.buffer)}function YP(P){const f=P.array.slice(P.offset.value,P.offset.value+P.size),Y=fflate.unzlibSync(f),C=new Uint8Array(Y.length);return J(Y),N(Y,C),new DataView(C.buffer)}function CP(P){const f=P.array.slice(P.offset.value,P.offset.value+P.size),Y=fflate.unzlibSync(f),C=P.lines*P.channels*P.width,q=1==P.type?new Uint16Array(C):new Uint32Array(C);let m=0,L=0;const o=new Array(4);for(let w=0;w<P.lines;w++)for(let f=0;f<P.channels;f++){let f=0;switch(P.type){case 1:o[0]=m,o[1]=o[0]+P.width,m=o[1]+P.width;for(let C=0;C<P.width;++C){f+=Y[o[0]++]<<8|Y[o[1]++],q[L]=f,L++}break;case 2:o[0]=m,o[1]=o[0]+P.width,o[2]=o[1]+P.width,m=o[2]+P.width;for(let C=0;C<P.width;++C){f+=Y[o[0]++]<<24|Y[o[1]++]<<16|Y[o[2]++]<<8,q[L]=f,L++}}}return new DataView(q.buffer)}function qP(P){const f=P.viewer,Y={value:P.offset.value},C=new Uint16Array(P.width*P.scanlineBlockSize*(P.channels*P.type)),q=new Uint8Array(y);let m=0;const L=new Array(P.channels);for(let w=0;w<P.channels;w++)L[w]={},L[w].start=m,L[w].end=L[w].start,L[w].nx=P.width,L[w].ny=P.lines,L[w].size=P.type,m+=L[w].nx*L[w].ny*L[w].size;const o=U(f,Y),d=U(f,Y);if(d>=y)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=d)for(let w=0;w<d-o+1;w++)q[w+o]=T(f,Y);const r=new Uint16Array(R),i=function(P,f){let Y=0;for(let q=0;q<R;++q)(0==q||P[q>>3]&1<<(7&q))&&(f[Y++]=q);const C=Y-1;for(;Y<R;)f[Y++]=0;return C}(q,r),u=c(f,Y);b(P.array,f,Y,u,C,m);for(let w=0;w<P.channels;++w){const P=L[w];for(let f=0;f<L[w].size;++f)F(C,P.start+f,P.nx,P.size,P.ny,P.nx*P.size,i)}!function(P,f,Y){for(let C=0;C<Y;++C)f[C]=P[f[C]]}(r,C,m);let g=0;const S=new Uint8Array(C.buffer.byteLength);for(let R=0;R<P.lines;R++)for(let f=0;f<P.channels;f++){const P=L[f],Y=P.nx*P.size,q=new Uint8Array(C.buffer,P.end*w,Y*w);S.set(q,g),g+=Y*w,P.end+=Y}return new DataView(S.buffer)}var mP,LP=Y(11014);!function(P){P[P.Float=0]="Float",P[P.HalfFloat=1]="HalfFloat"}(mP||(mP={}));class oP{}async function wP(P,f,Y,C){const q={size:0,viewer:f,array:new Uint8Array(f.buffer),offset:Y,width:P.dataWindow.xMax-P.dataWindow.xMin+1,height:P.dataWindow.yMax-P.dataWindow.yMin+1,channels:P.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(P.compression){case V.NO_COMPRESSION:q.lines=1,q.uncompress=PP;break;case V.RLE_COMPRESSION:q.lines=1,q.uncompress=fP;break;case V.ZIPS_COMPRESSION:q.lines=1,q.uncompress=YP,await LP.Tools.LoadScriptAsync(oP.FFLATEUrl);break;case V.ZIP_COMPRESSION:q.lines=16,q.uncompress=YP,await LP.Tools.LoadScriptAsync(oP.FFLATEUrl);break;case V.PIZ_COMPRESSION:q.lines=32,q.uncompress=qP;break;case V.PXR24_COMPRESSION:q.lines=16,q.uncompress=CP,await LP.Tools.LoadScriptAsync(oP.FFLATEUrl);break;default:throw new Error(V[P.compression]+" is unsupported")}q.scanlineBlockSize=q.lines;const m={};for(const L of P.channels)switch(L.name){case"R":case"G":case"B":case"A":case"Y":m[L.name]=!0,q.type=L.pixelType}let o=!1;if(m.R&&m.G&&m.B&&m.A)q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(m.R&&m.G&&m.B)o=!0,q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(m.R&&m.G)q.outputChannels=2,q.decodeChannels={R:0,G:1};else if(m.R)q.outputChannels=1,q.decodeChannels={R:0};else{if(!m.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");q.outputChannels=1,q.decodeChannels={Y:0}}if(1===q.type)switch(C){case mP.Float:q.getter=s,q.inputSize=w;break;case mP.HalfFloat:q.getter=U,q.inputSize=w}else{if(2!==q.type)throw new Error("Unsupported pixelType "+q.type+" for "+P.compression);switch(C){case mP.Float:q.getter=e,q.inputSize=L;break;case mP.HalfFloat:q.getter=a,q.inputSize=L}}q.blockCount=q.height/q.scanlineBlockSize;for(let L=0;L<q.blockCount;L++)j(f,Y);const d=q.width*q.height*q.outputChannels;switch(C){case mP.Float:q.byteArray=new Float32Array(d),q.textureType=1,o&&q.byteArray.fill(1,0,d);break;case mP.HalfFloat:q.byteArray=new Uint16Array(d),q.textureType=2,o&&q.byteArray.fill(15360,0,d);break;default:throw new Error("Unsupported type: "+C)}let R=0;for(const L of P.channels)void 0!==q.decodeChannels[L.name]&&(q.channelLineOffsets[L.name]=R*q.width),R+=2*L.pixelType;return q.bytesPerLine=q.width*R,q.outLineWidth=q.width*q.outputChannels,"INCREASING_Y"===P.lineOrder?q.scanOrder=P=>P:q.scanOrder=P=>q.height-1-P,4==q.outputChannels?(q.format=5,q.linearSpace=!0):(q.format=6,q.linearSpace=!1),q}function dP(P,f,Y,C){const q={value:0};for(let m=0;m<P.height/P.scanlineBlockSize;m++){const L=v(Y,C)-f.dataWindow.yMin;P.size=c(Y,C),P.lines=L+P.scanlineBlockSize>P.height?P.height-L:P.scanlineBlockSize;const o=P.size<P.lines*P.bytesPerLine&&P.uncompress?P.uncompress(P):PP(P);C.value+=P.size;for(let Y=0;Y<P.scanlineBlockSize;Y++){const C=m*P.scanlineBlockSize,L=Y+P.scanOrder(C);if(L>=P.height)continue;const w=Y*P.bytesPerLine,d=(P.height-1-L)*P.outLineWidth;for(let Y=0;Y<P.channels;Y++){const C=f.channels[Y].name,m=P.channelLineOffsets[C],L=P.decodeChannels[C];if(void 0!==L){q.value=w+m;for(let f=0;f<P.width;f++){const Y=d+f*P.outputChannels+L;P.byteArray&&(P.byteArray[Y]=P.getter(o,q))}}}}}}oP.DefaultOutputType=mP.HalfFloat,oP.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class RP{constructor(){this.supportCascades=!1}loadCubeData(P,f,Y,C,q){throw".exr not supported in Cube."}loadData(P,f,Y){const q=new DataView(P.buffer),m={value:0},L=X(q,m);wP(L,q,m,oP.DefaultOutputType).then((P=>{dP(P,L,q,m);const C=L.dataWindow.xMax-L.dataWindow.xMin+1,o=L.dataWindow.yMax-L.dataWindow.yMin+1;Y(C,o,f.generateMipMaps,!1,(()=>{const Y=f.getEngine();f.format=L.format,f.type=P.textureType,f.invertY=!1,f._gammaSpace=!L.linearSpace,P.byteArray&&Y._uploadDataToTextureDirectly(f,P.byteArray,0,0,void 0,!0)}))})).catch((P=>{C.e.Error("Failed to load EXR texture: ",P)}))}}async function yP(P){const f=new DataView(P),Y={value:0},q=X(f,Y);try{const P=await wP(q,f,Y,mP.Float);return dP(P,q,f,Y),P.byteArray?{width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,data:new Float32Array(P.byteArray)}:(C.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(m){C.e.Error("Failed to load EXR data: ",m)}return{width:0,height:0,data:null}}},11198:(P,f,Y)=>{function C(P){return parseInt(P.toString().replace(/\W/g,""))}function q(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-f)<=Y}function m(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<f-C||P>Y+C}function L(P,f){return P===f?P:Math.random()*(f-P)+P}function o(P,f,Y){return P+(f-P)*Y}function w(P,f,Y){let C=S(f-P,360);return C>180&&(C-=360),P+C*r(Y)}function d(P,f,Y){let C=0;return C=P!=f?r((Y-P)/(f-P)):0,C}function R(P,f,Y,C,q){const m=q*q,L=q*m;return P*(2*L-3*m+1)+Y*(-2*L+3*m)+f*(L-2*m+q)+C*(L-m)}function y(P,f,Y,C,q){const m=q*q;return 6*(m-q)*P+(3*m-4*q+1)*f+6*(-m+q)*Y+(3*m-2*q)*C}function r(P){let f=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Y,Math.max(f,P))}function i(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function u(P){const f=P.toString(16);return P<=15?("0"+f).toUpperCase():f.toUpperCase()}function g(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let f=0;if(P<1){for(;P<1;)f++,P*=2;f=-f}else if(P>1)for(;P>1;)f++,P=Math.floor(P/2);return f}function S(P,f){return P-Math.floor(P/f)*f}function K(P,f,Y){return(P-f)/(Y-f)}function M(P,f,Y){return P*(Y-f)+f}function V(P,f){let Y=S(f-P,360);return Y>180&&(Y-=360),Y}function O(P,f){const Y=S(P,2*f);return f-Math.abs(Y-f)}function n(P,f,Y){let C=r(Y);return C=-2*C*C*C+3*C*C,f*C+P*(1-C)}function l(P,f,Y){let C=0;return C=Math.abs(f-P)<=Y?f:P+Math.sign(f-P)*Y,C}function v(P,f,Y){const C=V(P,f);let q=0;return q=-Y<C&&C<Y?f:l(P,f=P+C,Y),q}function c(P,f,Y){return(P-f)/(Y-f)}function T(P,f,Y){return(Y-f)*P+f}function U(P,f){const Y=P%f;return 0===Y?f:U(f,Y)}Y.r(f),Y.d(f,{Clamp:()=>r,DeltaAngle:()=>V,Denormalize:()=>M,ExtractAsInt:()=>C,Hermite:()=>R,Hermite1stDerivative:()=>y,HighestCommonFactor:()=>U,ILog2:()=>g,InverseLerp:()=>d,Lerp:()=>o,LerpAngle:()=>w,MoveTowards:()=>l,MoveTowardsAngle:()=>v,Normalize:()=>K,NormalizeRadians:()=>i,OutsideRange:()=>m,PercentToRange:()=>T,PingPong:()=>O,RandomRange:()=>L,RangeToPercent:()=>c,Repeat:()=>S,SmoothStep:()=>n,ToHex:()=>u,WithinEpsilon:()=>q})}}]);