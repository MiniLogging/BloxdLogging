"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[16],{13747:(K,H,M)=>{M.r(H),M.d(H,{ReadExrDataAsync:()=>zK,_ExrTextureLoader:()=>fK});var q=M(11112),w=M(11307);const u=4,y=4,h=1,W=2,I=8,f=65536,z=f>>3,G=14,a=65537,v=1<<G,O=v-1,L=59,S=63,B=2+S-L;var C,i;!function(K){K[K.NO_COMPRESSION=0]="NO_COMPRESSION",K[K.RLE_COMPRESSION=1]="RLE_COMPRESSION",K[K.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",K[K.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",K[K.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",K[K.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(K){K[K.INCREASING_Y=0]="INCREASING_Y",K[K.DECREASING_Y=1]="DECREASING_Y"}(i||(i={}));const Z=function(){const K=new ArrayBuffer(4),H=new Float32Array(K),M=new Uint32Array(K),q=new Uint32Array(512),w=new Uint32Array(512);for(let W=0;W<256;++W){const K=W-127;K<-27?(q[W]=0,q[256|W]=32768,w[W]=24,w[256|W]=24):K<-14?(q[W]=1024>>-K-14,q[256|W]=1024>>-K-14|32768,w[W]=-K-1,w[256|W]=-K-1):K<=15?(q[W]=K+15<<10,q[256|W]=K+15<<10|32768,w[W]=13,w[256|W]=13):K<128?(q[W]=31744,q[256|W]=64512,w[W]=24,w[256|W]=24):(q[W]=31744,q[256|W]=64512,w[W]=13,w[256|W]=13)}const u=new Uint32Array(2048),y=new Uint32Array(64),h=new Uint32Array(64);for(let W=1;W<1024;++W){let K=W<<13,H=0;for(;0===(8388608&K);)K<<=1,H-=8388608;K&=-8388609,H+=947912704,u[W]=K|H}for(let W=1024;W<2048;++W)u[W]=939524096+(W-1024<<13);for(let W=1;W<31;++W)y[W]=W<<23;y[31]=1199570944,y[32]=2147483648;for(let W=33;W<63;++W)y[W]=2147483648+(W-32<<23);y[63]=3347054592;for(let W=1;W<64;++W)32!==W&&(h[W]=1024);return{floatView:H,uint32View:M,baseTable:q,shiftTable:w,mantissaTable:u,exponentTable:y,offsetTable:h}}();function E(K,H){const M=new Uint8Array(K);let q=0;for(;0!=M[H.value+q];)q+=1;const w=(new TextDecoder).decode(M.slice(H.value,H.value+q));return H.value=H.value+q+1,w}function l(K,H){const M=K.getInt32(H.value,!0);return H.value+=u,M}function s(K,H){const M=K.getUint32(H.value,!0);return H.value+=u,M}function D(K,H){const M=K.getUint8(H.value);return H.value+=h,M}function V(K,H){const M=K.getUint16(H.value,!0);return H.value+=W,M}function n(K,H){const M=K[H.value];return H.value+=h,M}function c(K,H){let M;return M="getBigInt64"in DataView.prototype?Number(K.getBigInt64(H.value,!0)):K.getUint32(H.value+4,!0)+Number(K.getUint32(H.value,!0)<<32),H.value+=I,M}function k(K,H){const M=K.getFloat32(H.value,!0);return H.value+=y,M}function T(K,H){return function(K){const H=(31744&K)>>10,M=1023&K;return(K>>15?-1:1)*(H?31===H?M?NaN:1/0:Math.pow(2,H-15)*(1+M/1024):M/1024*6103515625e-14)}(V(K,H))}function d(K,H){return function(K){if(Math.abs(K)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");K=(0,w.Clamp)(K,-65504,65504),Z.floatView[0]=K;const H=Z.uint32View[0],M=H>>23&511;return Z.baseTable[M]+((8388607&H)>>Z.shiftTable[M])}(k(K,H))}function x(K,H,M,q){switch(M){case"string":case"stringvector":case"iccProfile":return function(K,H,M){const q=(new TextDecoder).decode(new Uint8Array(K).slice(H.value,H.value+M));return H.value=H.value+M,q}(K.buffer,H,q);case"chlist":return function(K,H,M){const q=H.value,w=[];for(;H.value<q+M-1;){const M=E(K.buffer,H),q=l(K,H),u=D(K,H);H.value+=3;const y=l(K,H),h=l(K,H);w.push({name:M,pixelType:q,pLinear:u,xSampling:y,ySampling:h})}return H.value+=1,w}(K,H,q);case"chromaticities":return function(K,H){return{redX:k(K,H),redY:k(K,H),greenX:k(K,H),greenY:k(K,H),blueX:k(K,H),blueY:k(K,H),whiteX:k(K,H),whiteY:k(K,H)}}(K,H);case"compression":return function(K,H){return D(K,H)}(K,H);case"box2i":return function(K,H){return{xMin:l(K,H),yMin:l(K,H),xMax:l(K,H),yMax:l(K,H)}}(K,H);case"lineOrder":return function(K,H){const M=D(K,H);return i[M]}(K,H);case"float":return k(K,H);case"v2f":return function(K,H){return[k(K,H),k(K,H)]}(K,H);case"v3f":return function(K,H){return[k(K,H),k(K,H),k(K,H)]}(K,H);case"int":return l(K,H);case"rational":return function(K,H){return[l(K,H),s(K,H)]}(K,H);case"timecode":return function(K,H){return[s(K,H),s(K,H)]}(K,H);case"preview":return H.value+=q,"skipped";default:return void(H.value+=q)}}function Q(K){for(let H=1;H<K.length;H++){const M=K[H-1]+K[H]-128;K[H]=M}}function J(K,H){let M=0,q=Math.floor((K.length+1)/2),w=0;const u=K.length-1;for(;!(w>u)&&(H[w++]=K[M++],!(w>u));)H[w++]=K[q++]}const N=20000630;function p(K,H){if(K.getUint32(0,!0)!=N)throw new Error("Incorrect OpenEXR format");const M=K.getUint8(4),w=K.getUint8(5),u={singleTile:!!(2&w),longName:!!(4&w),deepFormat:!!(8&w),multiPart:!!(16&w)};H.value=8;const y={};let h=!0;for(;h;){const M=E(K.buffer,H);if(M){const w=E(K.buffer,H),u=x(K,H,w,s(K,H));void 0===u?q.e.Warn(`Unknown header attribute type ${w}'.`):y[M]=u}else h=!1}if(0!=(-5&w))throw new Error("Unsupported file format");return{version:M,spec:u,...y}}const o=32768,R=65535;function t(K,H,M,q,w){for(;M<K;)H=H<<8|n(q,w),M+=8;return{l:H>>(M-=K)&(1<<K)-1,c:H,lc:M}}function U(K,H,M,q){return{c:K=K<<8|n(M,q),lc:H+=8}}function j(K,H,M,q,w,u,y,h,W){if(K==H){if(q<8){const K=U(M,q,w,u);M=K.c,q=K.lc}let K=M>>(q-=8);if(K=new Uint8Array([K])[0],h.value+K>W)return null;const H=y[h.value-1];for(;K-- >0;)y[h.value++]=H}else{if(!(h.value<W))return null;y[h.value++]=K}return{c:M,lc:q}}const m=new Array(59);function F(K,H,M,q,w,u){const y=H;let h=0,W=0;for(;q<=w;q++){if(y.value-H.value>M)return;let I=t(6,h,W,K,y);const f=I.l;if(h=I.c,W=I.lc,u[q]=f,f==S){if(y.value-H.value>M)throw new Error("Error in HufUnpackEncTable");I=t(8,h,W,K,y);let f=I.l+B;if(h=I.c,W=I.lc,q+f>w+1)throw new Error("Error in HufUnpackEncTable");for(;f--;)u[q++]=0;q--}else if(f>=L){let K=f-L+2;if(q+K>w+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)u[q++]=0;q--}}!function(K){for(let M=0;M<=58;++M)m[M]=0;for(let M=0;M<a;++M)m[K[M]]+=1;let H=0;for(let M=58;M>0;--M){const K=H+m[M]>>1;m[M]=H,H=K}for(let M=0;M<a;++M){const H=K[M];H>0&&(K[M]=H|m[H]++<<6)}}(u)}function Y(K){return 63&K}function r(K){return K>>6}function e(K,H,M,q,w,u){const y=M.value,h=s(H,M),W=s(H,M);M.value+=4;const I=s(H,M);if(M.value+=4,h<0||h>=a||W<0||W>=a)throw new Error("Wrong HUF_ENCSIZE");const f=new Array(a),z=new Array(v);!function(K){for(let H=0;H<v;H++)K[H]={},K[H].len=0,K[H].lit=0,K[H].p=null}(z);if(F(K,M,q-(M.value-y),h,W,f),I>8*(q-(M.value-y)))throw new Error("Wrong hufUncompress");!function(K,H,M,q){for(;H<=M;H++){const M=r(K[H]),w=Y(K[H]);if(M>>w)throw new Error("Invalid table entry");if(w>G){const K=q[M>>w-G];if(K.len)throw new Error("Invalid table entry");if(K.lit++,K.p){const H=K.p;K.p=new Array(K.lit);for(let M=0;M<K.lit-1;++M)K.p[M]=H[M]}else K.p=new Array(1);K.p[K.lit-1]=H}else if(w){let K=0;for(let u=1<<G-w;u>0;u--){const u=q[(M<<G-w)+K];if(u.len||u.p)throw new Error("Invalid table entry");u.len=w,u.lit=H,K++}}}}(f,h,W,z),function(K,H,M,q,w,u,y,h,W){let I=0,f=0;const z=y,a=Math.trunc(q.value+(w+7)/8);for(;q.value<a;){let w=U(I,f,M,q);for(I=w.c,f=w.lc;f>=G;){const y=H[I>>f-G&O];if(y.len){f-=y.len;const K=j(y.lit,u,I,f,M,q,h,W,z);K&&(I=K.c,f=K.lc)}else{if(!y.p)throw new Error("hufDecode issues");let H;for(H=0;H<y.lit;H++){const G=Y(K[y.p[H]]);for(;f<G&&q.value<a;)w=U(I,f,M,q),I=w.c,f=w.lc;if(f>=G&&r(K[y.p[H]])==(I>>f-G&(1<<G)-1)){f-=G;const K=j(y.p[H],u,I,f,M,q,h,W,z);K&&(I=K.c,f=K.lc);break}}if(H==y.lit)throw new Error("HufDecode issues")}}}const v=8-w&7;for(I>>=v,f-=v;f>0;){const K=H[I<<G-f&O];if(!K.len)throw new Error("HufDecode issues");{f-=K.len;const H=j(K.lit,u,I,f,M,q,h,W,z);H&&(I=H.c,f=H.lc)}}}(f,z,K,M,I,W,u,w,{value:0})}function b(K){return 65535&K}function P(K){const H=b(K);return H>32767?H-65536:H}function g(K,H){const M=P(K),q=P(H),w=M+(1&q)+(q>>1);return{a:w,b:w-q}}function X(K,H){const M=b(K),q=b(H),w=M-(q>>1)&R;return{a:q+w-o&R,b:w}}function A(K,H,M,q,w,u,y){const h=y<16384,W=M>w?w:M;let I,f,z=1;for(;z<=W;)z<<=1;for(z>>=1,I=z,z>>=1;z>=1;){f=0;const y=f+u*(w-I),W=u*z,G=u*I,a=q*z,v=q*I;let O,L,S,B;for(;f<=y;f+=G){let w=f;const u=f+q*(M-I);for(;w<=u;w+=v){const M=w+a,q=w+W,u=q+a;if(h){let y=g(K[w+H],K[q+H]);O=y.a,S=y.b,y=g(K[M+H],K[u+H]),L=y.a,B=y.b,y=g(O,L),K[w+H]=y.a,K[M+H]=y.b,y=g(S,B),K[q+H]=y.a,K[u+H]=y.b}else{let y=X(K[w+H],K[q+H]);O=y.a,S=y.b,y=X(K[M+H],K[u+H]),L=y.a,B=y.b,y=X(O,L),K[w+H]=y.a,K[M+H]=y.b,y=X(S,B),K[q+H]=y.a,K[u+H]=y.b}}if(M&z){const M=w+W;let q;q=h?g(K[w+H],K[M+H]):X(K[w+H],K[M+H]),O=q.a,K[M+H]=q.b,K[w+H]=O}}if(w&z){let w=f;const u=f+q*(M-I);for(;w<=u;w+=v){const M=w+a;let q;q=h?g(K[w+H],K[M+H]):X(K[w+H],K[M+H]),O=q.a,K[M+H]=q.b,K[w+H]=O}}I=z,z>>=1}return f}function KK(K){return new DataView(K.array.buffer,K.offset.value,K.size)}function HK(K){const H=K.viewer.buffer.slice(K.offset.value,K.offset.value+K.size),M=new Uint8Array(function(K){let H=K.byteLength;const M=[];let q=0;const w=new DataView(K);for(;H>0;){const K=w.getInt8(q++);if(K<0){const u=-K;H-=u+1;for(let K=0;K<u;K++)M.push(w.getUint8(q++))}else{const u=K;H-=2;const y=w.getUint8(q++);for(let K=0;K<u+1;K++)M.push(y)}}return M}(H)),q=new Uint8Array(M.length);return Q(M),J(M,q),new DataView(q.buffer)}function MK(K){const H=K.array.slice(K.offset.value,K.offset.value+K.size),M=fflate.unzlibSync(H),q=new Uint8Array(M.length);return Q(M),J(M,q),new DataView(q.buffer)}function qK(K){const H=K.array.slice(K.offset.value,K.offset.value+K.size),M=fflate.unzlibSync(H),q=K.lines*K.channels*K.width,w=1==K.type?new Uint16Array(q):new Uint32Array(q);let u=0,y=0;const h=new Array(4);for(let W=0;W<K.lines;W++)for(let H=0;H<K.channels;H++){let H=0;switch(K.type){case 1:h[0]=u,h[1]=h[0]+K.width,u=h[1]+K.width;for(let q=0;q<K.width;++q){H+=M[h[0]++]<<8|M[h[1]++],w[y]=H,y++}break;case 2:h[0]=u,h[1]=h[0]+K.width,h[2]=h[1]+K.width,u=h[2]+K.width;for(let q=0;q<K.width;++q){H+=M[h[0]++]<<24|M[h[1]++]<<16|M[h[2]++]<<8,w[y]=H,y++}}}return new DataView(w.buffer)}function wK(K){const H=K.viewer,M={value:K.offset.value},q=new Uint16Array(K.width*K.scanlineBlockSize*(K.channels*K.type)),w=new Uint8Array(z);let u=0;const y=new Array(K.channels);for(let W=0;W<K.channels;W++)y[W]={},y[W].start=u,y[W].end=y[W].start,y[W].nx=K.width,y[W].ny=K.lines,y[W].size=K.type,u+=y[W].nx*y[W].ny*y[W].size;const h=V(H,M),I=V(H,M);if(I>=z)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(h<=I)for(let W=0;W<I-h+1;W++)w[W+h]=D(H,M);const G=new Uint16Array(f),a=function(K,H){let M=0;for(let w=0;w<f;++w)(0==w||K[w>>3]&1<<(7&w))&&(H[M++]=w);const q=M-1;for(;M<f;)H[M++]=0;return q}(w,G),v=s(H,M);e(K.array,H,M,v,q,u);for(let W=0;W<K.channels;++W){const K=y[W];for(let H=0;H<y[W].size;++H)A(q,K.start+H,K.nx,K.size,K.ny,K.nx*K.size,a)}!function(K,H,M){for(let q=0;q<M;++q)H[q]=K[H[q]]}(G,q,u);let O=0;const L=new Uint8Array(q.buffer.byteLength);for(let f=0;f<K.lines;f++)for(let H=0;H<K.channels;H++){const K=y[H],M=K.nx*K.size,w=new Uint8Array(q.buffer,K.end*W,M*W);L.set(w,O),O+=M*W,K.end+=M}return new DataView(L.buffer)}var uK,yK=M(11100);!function(K){K[K.Float=0]="Float",K[K.HalfFloat=1]="HalfFloat"}(uK||(uK={}));class hK{}async function WK(K,H,M,q){const w={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:M,width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,channels:K.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(K.compression){case C.NO_COMPRESSION:w.lines=1,w.uncompress=KK;break;case C.RLE_COMPRESSION:w.lines=1,w.uncompress=HK;break;case C.ZIPS_COMPRESSION:w.lines=1,w.uncompress=MK,await yK.Tools.LoadScriptAsync(hK.FFLATEUrl);break;case C.ZIP_COMPRESSION:w.lines=16,w.uncompress=MK,await yK.Tools.LoadScriptAsync(hK.FFLATEUrl);break;case C.PIZ_COMPRESSION:w.lines=32,w.uncompress=wK;break;case C.PXR24_COMPRESSION:w.lines=16,w.uncompress=qK,await yK.Tools.LoadScriptAsync(hK.FFLATEUrl);break;default:throw new Error(C[K.compression]+" is unsupported")}w.scanlineBlockSize=w.lines;const u={};for(const y of K.channels)switch(y.name){case"R":case"G":case"B":case"A":case"Y":u[y.name]=!0,w.type=y.pixelType}let h=!1;if(u.R&&u.G&&u.B&&u.A)w.outputChannels=4,w.decodeChannels={R:0,G:1,B:2,A:3};else if(u.R&&u.G&&u.B)h=!0,w.outputChannels=4,w.decodeChannels={R:0,G:1,B:2,A:3};else if(u.R&&u.G)w.outputChannels=2,w.decodeChannels={R:0,G:1};else if(u.R)w.outputChannels=1,w.decodeChannels={R:0};else{if(!u.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");w.outputChannels=1,w.decodeChannels={Y:0}}if(1===w.type)switch(q){case uK.Float:w.getter=T,w.inputSize=W;break;case uK.HalfFloat:w.getter=V,w.inputSize=W}else{if(2!==w.type)throw new Error("Unsupported pixelType "+w.type+" for "+K.compression);switch(q){case uK.Float:w.getter=k,w.inputSize=y;break;case uK.HalfFloat:w.getter=d,w.inputSize=y}}w.blockCount=w.height/w.scanlineBlockSize;for(let y=0;y<w.blockCount;y++)c(H,M);const I=w.width*w.height*w.outputChannels;switch(q){case uK.Float:w.byteArray=new Float32Array(I),w.textureType=1,h&&w.byteArray.fill(1,0,I);break;case uK.HalfFloat:w.byteArray=new Uint16Array(I),w.textureType=2,h&&w.byteArray.fill(15360,0,I);break;default:throw new Error("Unsupported type: "+q)}let f=0;for(const y of K.channels)void 0!==w.decodeChannels[y.name]&&(w.channelLineOffsets[y.name]=f*w.width),f+=2*y.pixelType;return w.bytesPerLine=w.width*f,w.outLineWidth=w.width*w.outputChannels,"INCREASING_Y"===K.lineOrder?w.scanOrder=K=>K:w.scanOrder=K=>w.height-1-K,4==w.outputChannels?(w.format=5,w.linearSpace=!0):(w.format=6,w.linearSpace=!1),w}function IK(K,H,M,q){const w={value:0};for(let u=0;u<K.height/K.scanlineBlockSize;u++){const y=l(M,q)-H.dataWindow.yMin;K.size=s(M,q),K.lines=y+K.scanlineBlockSize>K.height?K.height-y:K.scanlineBlockSize;const h=K.size<K.lines*K.bytesPerLine&&K.uncompress?K.uncompress(K):KK(K);q.value+=K.size;for(let M=0;M<K.scanlineBlockSize;M++){const q=u*K.scanlineBlockSize,y=M+K.scanOrder(q);if(y>=K.height)continue;const W=M*K.bytesPerLine,I=(K.height-1-y)*K.outLineWidth;for(let M=0;M<K.channels;M++){const q=H.channels[M].name,u=K.channelLineOffsets[q],y=K.decodeChannels[q];if(void 0!==y){w.value=W+u;for(let H=0;H<K.width;H++){const M=I+H*K.outputChannels+y;K.byteArray&&(K.byteArray[M]=K.getter(h,w))}}}}}}hK.DefaultOutputType=uK.HalfFloat,hK.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class fK{constructor(){this.supportCascades=!1}loadCubeData(K,H,M,q,w){throw".exr not supported in Cube."}loadData(K,H,M){const w=new DataView(K.buffer),u={value:0},y=p(w,u);WK(y,w,u,hK.DefaultOutputType).then((K=>{IK(K,y,w,u);const q=y.dataWindow.xMax-y.dataWindow.xMin+1,h=y.dataWindow.yMax-y.dataWindow.yMin+1;M(q,h,H.generateMipMaps,!1,(()=>{const M=H.getEngine();H.format=y.format,H.type=K.textureType,H.invertY=!1,H._gammaSpace=!y.linearSpace,K.byteArray&&M._uploadDataToTextureDirectly(H,K.byteArray,0,0,void 0,!0)}))})).catch((K=>{q.e.Error("Failed to load EXR texture: ",K)}))}}async function zK(K){const H=new DataView(K),M={value:0},w=p(H,M);try{const K=await WK(w,H,M,uK.Float);return IK(K,w,H,M),K.byteArray?{width:w.dataWindow.xMax-w.dataWindow.xMin+1,height:w.dataWindow.yMax-w.dataWindow.yMin+1,data:new Float32Array(K.byteArray)}:(q.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(u){q.e.Error("Failed to load EXR data: ",u)}return{width:0,height:0,data:null}}},11307:(K,H,M)=>{function q(K){return parseInt(K.toString().replace(/\W/g,""))}function w(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-H)<=M}function u(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<H-q||K>M+q}function y(K,H){return K===H?K:Math.random()*(H-K)+K}function h(K,H,M){return K+(H-K)*M}function W(K,H,M){let q=L(H-K,360);return q>180&&(q-=360),K+q*G(M)}function I(K,H,M){let q=0;return q=K!=H?G((M-K)/(H-K)):0,q}function f(K,H,M,q,w){const u=w*w,y=w*u;return K*(2*y-3*u+1)+M*(-2*y+3*u)+H*(y-2*u+w)+q*(y-u)}function z(K,H,M,q,w){const u=w*w;return 6*(u-w)*K+(3*u-4*w+1)*H+6*(-u+w)*M+(3*u-2*w)*q}function G(K){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(M,Math.max(H,K))}function a(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function v(K){const H=K.toString(16);return K<=15?("0"+H).toUpperCase():H.toUpperCase()}function O(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let H=0;if(K<1){for(;K<1;)H++,K*=2;H=-H}else if(K>1)for(;K>1;)H++,K=Math.floor(K/2);return H}function L(K,H){return K-Math.floor(K/H)*H}function S(K,H,M){return(K-H)/(M-H)}function B(K,H,M){return K*(M-H)+H}function C(K,H){let M=L(H-K,360);return M>180&&(M-=360),M}function i(K,H){const M=L(K,2*H);return H-Math.abs(M-H)}function Z(K,H,M){let q=G(M);return q=-2*q*q*q+3*q*q,H*q+K*(1-q)}function E(K,H,M){let q=0;return q=Math.abs(H-K)<=M?H:K+Math.sign(H-K)*M,q}function l(K,H,M){const q=C(K,H);let w=0;return w=-M<q&&q<M?H:E(K,H=K+q,M),w}function s(K,H,M){return(K-H)/(M-H)}function D(K,H,M){return(M-H)*K+H}function V(K,H){const M=K%H;return 0===M?H:V(H,M)}M.r(H),M.d(H,{Clamp:()=>G,DeltaAngle:()=>C,Denormalize:()=>B,ExtractAsInt:()=>q,Hermite:()=>f,Hermite1stDerivative:()=>z,HighestCommonFactor:()=>V,ILog2:()=>O,InverseLerp:()=>I,Lerp:()=>h,LerpAngle:()=>W,MoveTowards:()=>E,MoveTowardsAngle:()=>l,Normalize:()=>S,NormalizeRadians:()=>a,OutsideRange:()=>u,PercentToRange:()=>D,PingPong:()=>i,RandomRange:()=>y,RangeToPercent:()=>s,Repeat:()=>L,SmoothStep:()=>Z,ToHex:()=>v,WithinEpsilon:()=>w})}}]);