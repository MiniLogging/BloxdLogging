"use strict";(self["2fwzcez286e"]=self["2fwzcez286e"]||[]).push([[16],{15505:(B,u,F)=>{F.r(u),F.d(u,{ReadExrDataAsync:()=>QB,_ExrTextureLoader:()=>YB});var Z=F(12822),V=F(12994);const p=4,G=4,R=1,e=2,s=8,Y=65536,Q=Y>>3,t=14,v=65537,D=1<<t,L=D-1,q=59,W=63,X=2+W-q;var f,C;!function(B){B[B.NO_COMPRESSION=0]="NO_COMPRESSION",B[B.RLE_COMPRESSION=1]="RLE_COMPRESSION",B[B.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",B[B.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",B[B.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",B[B.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(f||(f={})),function(B){B[B.INCREASING_Y=0]="INCREASING_Y",B[B.DECREASING_Y=1]="DECREASING_Y"}(C||(C={}));const x=function(){const B=new ArrayBuffer(4),u=new Float32Array(B),F=new Uint32Array(B),Z=new Uint32Array(512),V=new Uint32Array(512);for(let e=0;e<256;++e){const B=e-127;B<-27?(Z[e]=0,Z[256|e]=32768,V[e]=24,V[256|e]=24):B<-14?(Z[e]=1024>>-B-14,Z[256|e]=1024>>-B-14|32768,V[e]=-B-1,V[256|e]=-B-1):B<=15?(Z[e]=B+15<<10,Z[256|e]=B+15<<10|32768,V[e]=13,V[256|e]=13):B<128?(Z[e]=31744,Z[256|e]=64512,V[e]=24,V[256|e]=24):(Z[e]=31744,Z[256|e]=64512,V[e]=13,V[256|e]=13)}const p=new Uint32Array(2048),G=new Uint32Array(64),R=new Uint32Array(64);for(let e=1;e<1024;++e){let B=e<<13,u=0;for(;0===(8388608&B);)B<<=1,u-=8388608;B&=-8388609,u+=947912704,p[e]=B|u}for(let e=1024;e<2048;++e)p[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)G[e]=e<<23;G[31]=1199570944,G[32]=2147483648;for(let e=33;e<63;++e)G[e]=2147483648+(e-32<<23);G[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(R[e]=1024);return{floatView:u,uint32View:F,baseTable:Z,shiftTable:V,mantissaTable:p,exponentTable:G,offsetTable:R}}();function U(B,u){const F=new Uint8Array(B);let Z=0;for(;0!=F[u.value+Z];)Z+=1;const V=(new TextDecoder).decode(F.slice(u.value,u.value+Z));return u.value=u.value+Z+1,V}function y(B,u){const F=B.getInt32(u.value,!0);return u.value+=p,F}function O(B,u){const F=B.getUint32(u.value,!0);return u.value+=p,F}function g(B,u){const F=B.getUint8(u.value);return u.value+=R,F}function J(B,u){const F=B.getUint16(u.value,!0);return u.value+=e,F}function a(B,u){const F=B[u.value];return u.value+=R,F}function T(B,u){let F;return F="getBigInt64"in DataView.prototype?Number(B.getBigInt64(u.value,!0)):B.getUint32(u.value+4,!0)+Number(B.getUint32(u.value,!0)<<32),u.value+=s,F}function z(B,u){const F=B.getFloat32(u.value,!0);return u.value+=G,F}function M(B,u){return function(B){const u=(31744&B)>>10,F=1023&B;return(B>>15?-1:1)*(u?31===u?F?NaN:1/0:Math.pow(2,u-15)*(1+F/1024):F/1024*6103515625e-14)}(J(B,u))}function j(B,u){return function(B){if(Math.abs(B)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");B=(0,V.Clamp)(B,-65504,65504),x.floatView[0]=B;const u=x.uint32View[0],F=u>>23&511;return x.baseTable[F]+((8388607&u)>>x.shiftTable[F])}(z(B,u))}function o(B,u,F,Z){switch(F){case"string":case"stringvector":case"iccProfile":return function(B,u,F){const Z=(new TextDecoder).decode(new Uint8Array(B).slice(u.value,u.value+F));return u.value=u.value+F,Z}(B.buffer,u,Z);case"chlist":return function(B,u,F){const Z=u.value,V=[];for(;u.value<Z+F-1;){const F=U(B.buffer,u),Z=y(B,u),p=g(B,u);u.value+=3;const G=y(B,u),R=y(B,u);V.push({name:F,pixelType:Z,pLinear:p,xSampling:G,ySampling:R})}return u.value+=1,V}(B,u,Z);case"chromaticities":return function(B,u){return{redX:z(B,u),redY:z(B,u),greenX:z(B,u),greenY:z(B,u),blueX:z(B,u),blueY:z(B,u),whiteX:z(B,u),whiteY:z(B,u)}}(B,u);case"compression":return function(B,u){return g(B,u)}(B,u);case"box2i":return function(B,u){return{xMin:y(B,u),yMin:y(B,u),xMax:y(B,u),yMax:y(B,u)}}(B,u);case"lineOrder":return function(B,u){const F=g(B,u);return C[F]}(B,u);case"float":return z(B,u);case"v2f":return function(B,u){return[z(B,u),z(B,u)]}(B,u);case"v3f":return function(B,u){return[z(B,u),z(B,u),z(B,u)]}(B,u);case"int":return y(B,u);case"rational":return function(B,u){return[y(B,u),O(B,u)]}(B,u);case"timecode":return function(B,u){return[O(B,u),O(B,u)]}(B,u);case"preview":return u.value+=Z,"skipped";default:return void(u.value+=Z)}}function I(B){for(let u=1;u<B.length;u++){const F=B[u-1]+B[u]-128;B[u]=F}}function mB(B,u){let F=0,Z=Math.floor((B.length+1)/2),V=0;const p=B.length-1;for(;!(V>p)&&(u[V++]=B[F++],!(V>p));)u[V++]=B[Z++]}const E=20000630;function w(B,u){if(B.getUint32(0,!0)!=E)throw new Error("Incorrect OpenEXR format");const F=B.getUint8(4),V=B.getUint8(5),p={singleTile:!!(2&V),longName:!!(4&V),deepFormat:!!(8&V),multiPart:!!(16&V)};u.value=8;const G={};let R=!0;for(;R;){const F=U(B.buffer,u);if(F){const V=U(B.buffer,u),p=o(B,u,V,O(B,u));void 0===p?Z.d.Warn(`Unknown header attribute type ${V}'.`):G[F]=p}else R=!1}if(0!=(-5&V))throw new Error("Unsupported file format");return{version:F,spec:p,...G}}const H=32768,n=65535;function d(B,u,F,Z,V){for(;F<B;)u=u<<8|a(Z,V),F+=8;return{l:u>>(F-=B)&(1<<B)-1,c:u,lc:F}}function l(B,u,F,Z){return{c:B=B<<8|a(F,Z),lc:u+=8}}function P(B,u,F,Z,V,p,G,R,e){if(B==u){if(Z<8){const B=l(F,Z,V,p);F=B.c,Z=B.lc}let B=F>>(Z-=8);if(B=new Uint8Array([B])[0],R.value+B>e)return null;const u=G[R.value-1];for(;B-- >0;)G[R.value++]=u}else{if(!(R.value<e))return null;G[R.value++]=B}return{c:F,lc:Z}}const c=new Array(59);function h(B,u,F,Z,V,p){const G=u;let R=0,e=0;for(;Z<=V;Z++){if(G.value-u.value>F)return;let s=d(6,R,e,B,G);const Y=s.l;if(R=s.c,e=s.lc,p[Z]=Y,Y==W){if(G.value-u.value>F)throw new Error("Error in HufUnpackEncTable");s=d(8,R,e,B,G);let Y=s.l+X;if(R=s.c,e=s.lc,Z+Y>V+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)p[Z++]=0;Z--}else if(Y>=q){let B=Y-q+2;if(Z+B>V+1)throw new Error("Error in HufUnpackEncTable");for(;B--;)p[Z++]=0;Z--}}!function(B){for(let F=0;F<=58;++F)c[F]=0;for(let F=0;F<v;++F)c[B[F]]+=1;let u=0;for(let F=58;F>0;--F){const B=u+c[F]>>1;c[F]=u,u=B}for(let F=0;F<v;++F){const u=B[F];u>0&&(B[F]=u|c[u]++<<6)}}(p)}function i(B){return 63&B}function r(B){return B>>6}function K(B,u,F,Z,V,p){const G=F.value,R=O(u,F),e=O(u,F);F.value+=4;const s=O(u,F);if(F.value+=4,R<0||R>=v||e<0||e>=v)throw new Error("Wrong HUF_ENCSIZE");const Y=new Array(v),Q=new Array(D);!function(B){for(let u=0;u<D;u++)B[u]={},B[u].len=0,B[u].lit=0,B[u].p=null}(Q);if(h(B,F,Z-(F.value-G),R,e,Y),s>8*(Z-(F.value-G)))throw new Error("Wrong hufUncompress");!function(B,u,F,Z){for(;u<=F;u++){const F=r(B[u]),V=i(B[u]);if(F>>V)throw new Error("Invalid table entry");if(V>t){const B=Z[F>>V-t];if(B.len)throw new Error("Invalid table entry");if(B.lit++,B.p){const u=B.p;B.p=new Array(B.lit);for(let F=0;F<B.lit-1;++F)B.p[F]=u[F]}else B.p=new Array(1);B.p[B.lit-1]=u}else if(V){let B=0;for(let p=1<<t-V;p>0;p--){const p=Z[(F<<t-V)+B];if(p.len||p.p)throw new Error("Invalid table entry");p.len=V,p.lit=u,B++}}}}(Y,R,e,Q),function(B,u,F,Z,V,p,G,R,e){let s=0,Y=0;const Q=G,v=Math.trunc(Z.value+(V+7)/8);for(;Z.value<v;){let V=l(s,Y,F,Z);for(s=V.c,Y=V.lc;Y>=t;){const G=u[s>>Y-t&L];if(G.len){Y-=G.len;const B=P(G.lit,p,s,Y,F,Z,R,e,Q);B&&(s=B.c,Y=B.lc)}else{if(!G.p)throw new Error("hufDecode issues");let u;for(u=0;u<G.lit;u++){const t=i(B[G.p[u]]);for(;Y<t&&Z.value<v;)V=l(s,Y,F,Z),s=V.c,Y=V.lc;if(Y>=t&&r(B[G.p[u]])==(s>>Y-t&(1<<t)-1)){Y-=t;const B=P(G.p[u],p,s,Y,F,Z,R,e,Q);B&&(s=B.c,Y=B.lc);break}}if(u==G.lit)throw new Error("HufDecode issues")}}}const D=8-V&7;for(s>>=D,Y-=D;Y>0;){const B=u[s<<t-Y&L];if(!B.len)throw new Error("HufDecode issues");{Y-=B.len;const u=P(B.lit,p,s,Y,F,Z,R,e,Q);u&&(s=u.c,Y=u.lc)}}}(Y,Q,B,F,s,e,p,V,{value:0})}function N(B){return 65535&B}function A(B){const u=N(B);return u>32767?u-65536:u}function b(B,u){const F=A(B),Z=A(u),V=F+(1&Z)+(Z>>1);return{a:V,b:V-Z}}function k(B,u){const F=N(B),Z=N(u),V=F-(Z>>1)&n;return{a:Z+V-H&n,b:V}}function S(B,u,F,Z,V,p,G){const R=G<16384,e=F>V?V:F;let s,Y,Q=1;for(;Q<=e;)Q<<=1;for(Q>>=1,s=Q,Q>>=1;Q>=1;){Y=0;const G=Y+p*(V-s),e=p*Q,t=p*s,v=Z*Q,D=Z*s;let L,q,W,X;for(;Y<=G;Y+=t){let V=Y;const p=Y+Z*(F-s);for(;V<=p;V+=D){const F=V+v,Z=V+e,p=Z+v;if(R){let G=b(B[V+u],B[Z+u]);L=G.a,W=G.b,G=b(B[F+u],B[p+u]),q=G.a,X=G.b,G=b(L,q),B[V+u]=G.a,B[F+u]=G.b,G=b(W,X),B[Z+u]=G.a,B[p+u]=G.b}else{let G=k(B[V+u],B[Z+u]);L=G.a,W=G.b,G=k(B[F+u],B[p+u]),q=G.a,X=G.b,G=k(L,q),B[V+u]=G.a,B[F+u]=G.b,G=k(W,X),B[Z+u]=G.a,B[p+u]=G.b}}if(F&Q){const F=V+e;let Z;Z=R?b(B[V+u],B[F+u]):k(B[V+u],B[F+u]),L=Z.a,B[F+u]=Z.b,B[V+u]=L}}if(V&Q){let V=Y;const p=Y+Z*(F-s);for(;V<=p;V+=D){const F=V+v;let Z;Z=R?b(B[V+u],B[F+u]):k(B[V+u],B[F+u]),L=Z.a,B[F+u]=Z.b,B[V+u]=L}}s=Q,Q>>=1}return Y}function BB(B){return new DataView(B.array.buffer,B.offset.value,B.size)}function uB(B){const u=B.viewer.buffer.slice(B.offset.value,B.offset.value+B.size),F=new Uint8Array(function(B){let u=B.byteLength;const F=[];let Z=0;const V=new DataView(B);for(;u>0;){const B=V.getInt8(Z++);if(B<0){const p=-B;u-=p+1;for(let B=0;B<p;B++)F.push(V.getUint8(Z++))}else{const p=B;u-=2;const G=V.getUint8(Z++);for(let B=0;B<p+1;B++)F.push(G)}}return F}(u)),Z=new Uint8Array(F.length);return I(F),mB(F,Z),new DataView(Z.buffer)}function FB(B){const u=B.array.slice(B.offset.value,B.offset.value+B.size),F=fflate.unzlibSync(u),Z=new Uint8Array(F.length);return I(F),mB(F,Z),new DataView(Z.buffer)}function ZB(B){const u=B.array.slice(B.offset.value,B.offset.value+B.size),F=fflate.unzlibSync(u),Z=B.lines*B.channels*B.width,V=1==B.type?new Uint16Array(Z):new Uint32Array(Z);let p=0,G=0;const R=new Array(4);for(let e=0;e<B.lines;e++)for(let u=0;u<B.channels;u++){let u=0;switch(B.type){case 1:R[0]=p,R[1]=R[0]+B.width,p=R[1]+B.width;for(let Z=0;Z<B.width;++Z){u+=F[R[0]++]<<8|F[R[1]++],V[G]=u,G++}break;case 2:R[0]=p,R[1]=R[0]+B.width,R[2]=R[1]+B.width,p=R[2]+B.width;for(let Z=0;Z<B.width;++Z){u+=F[R[0]++]<<24|F[R[1]++]<<16|F[R[2]++]<<8,V[G]=u,G++}}}return new DataView(V.buffer)}function VB(B){const u=B.viewer,F={value:B.offset.value},Z=new Uint16Array(B.width*B.scanlineBlockSize*(B.channels*B.type)),V=new Uint8Array(Q);let p=0;const G=new Array(B.channels);for(let e=0;e<B.channels;e++)G[e]={},G[e].start=p,G[e].end=G[e].start,G[e].nx=B.width,G[e].ny=B.lines,G[e].size=B.type,p+=G[e].nx*G[e].ny*G[e].size;const R=J(u,F),s=J(u,F);if(s>=Q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(R<=s)for(let e=0;e<s-R+1;e++)V[e+R]=g(u,F);const t=new Uint16Array(Y),v=function(B,u){let F=0;for(let V=0;V<Y;++V)(0==V||B[V>>3]&1<<(7&V))&&(u[F++]=V);const Z=F-1;for(;F<Y;)u[F++]=0;return Z}(V,t),D=O(u,F);K(B.array,u,F,D,Z,p);for(let e=0;e<B.channels;++e){const B=G[e];for(let u=0;u<G[e].size;++u)S(Z,B.start+u,B.nx,B.size,B.ny,B.nx*B.size,v)}!function(B,u,F){for(let Z=0;Z<F;++Z)u[Z]=B[u[Z]]}(t,Z,p);let L=0;const q=new Uint8Array(Z.buffer.byteLength);for(let Y=0;Y<B.lines;Y++)for(let u=0;u<B.channels;u++){const B=G[u],F=B.nx*B.size,V=new Uint8Array(Z.buffer,B.end*e,F*e);q.set(V,L),L+=F*e,B.end+=F}return new DataView(q.buffer)}var pB,GB=F(12802);!function(B){B[B.Float=0]="Float",B[B.HalfFloat=1]="HalfFloat"}(pB||(pB={}));class RB{}async function eB(B,u,F,Z){const V={size:0,viewer:u,array:new Uint8Array(u.buffer),offset:F,width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,channels:B.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(B.compression){case f.NO_COMPRESSION:V.lines=1,V.uncompress=BB;break;case f.RLE_COMPRESSION:V.lines=1,V.uncompress=uB;break;case f.ZIPS_COMPRESSION:V.lines=1,V.uncompress=FB,await GB.Tools.LoadScriptAsync(RB.FFLATEUrl);break;case f.ZIP_COMPRESSION:V.lines=16,V.uncompress=FB,await GB.Tools.LoadScriptAsync(RB.FFLATEUrl);break;case f.PIZ_COMPRESSION:V.lines=32,V.uncompress=VB;break;case f.PXR24_COMPRESSION:V.lines=16,V.uncompress=ZB,await GB.Tools.LoadScriptAsync(RB.FFLATEUrl);break;default:throw new Error(f[B.compression]+" is unsupported")}V.scanlineBlockSize=V.lines;const p={};for(const G of B.channels)switch(G.name){case"R":case"G":case"B":case"A":case"Y":p[G.name]=!0,V.type=G.pixelType}let R=!1;if(p.R&&p.G&&p.B&&p.A)V.outputChannels=4,V.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G&&p.B)R=!0,V.outputChannels=4,V.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G)V.outputChannels=2,V.decodeChannels={R:0,G:1};else if(p.R)V.outputChannels=1,V.decodeChannels={R:0};else{if(!p.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");V.outputChannels=1,V.decodeChannels={Y:0}}if(1===V.type)switch(Z){case pB.Float:V.getter=M,V.inputSize=e;break;case pB.HalfFloat:V.getter=J,V.inputSize=e}else{if(2!==V.type)throw new Error("Unsupported pixelType "+V.type+" for "+B.compression);switch(Z){case pB.Float:V.getter=z,V.inputSize=G;break;case pB.HalfFloat:V.getter=j,V.inputSize=G}}V.blockCount=V.height/V.scanlineBlockSize;for(let G=0;G<V.blockCount;G++)T(u,F);const s=V.width*V.height*V.outputChannels;switch(Z){case pB.Float:V.byteArray=new Float32Array(s),V.textureType=1,R&&V.byteArray.fill(1,0,s);break;case pB.HalfFloat:V.byteArray=new Uint16Array(s),V.textureType=2,R&&V.byteArray.fill(15360,0,s);break;default:throw new Error("Unsupported type: "+Z)}let Y=0;for(const G of B.channels)void 0!==V.decodeChannels[G.name]&&(V.channelLineOffsets[G.name]=Y*V.width),Y+=2*G.pixelType;return V.bytesPerLine=V.width*Y,V.outLineWidth=V.width*V.outputChannels,"INCREASING_Y"===B.lineOrder?V.scanOrder=B=>B:V.scanOrder=B=>V.height-1-B,4==V.outputChannels?(V.format=5,V.linearSpace=!0):(V.format=6,V.linearSpace=!1),V}function sB(B,u,F,Z){const V={value:0};for(let p=0;p<B.height/B.scanlineBlockSize;p++){const G=y(F,Z)-u.dataWindow.yMin;B.size=O(F,Z),B.lines=G+B.scanlineBlockSize>B.height?B.height-G:B.scanlineBlockSize;const R=B.size<B.lines*B.bytesPerLine&&B.uncompress?B.uncompress(B):BB(B);Z.value+=B.size;for(let F=0;F<B.scanlineBlockSize;F++){const Z=p*B.scanlineBlockSize,G=F+B.scanOrder(Z);if(G>=B.height)continue;const e=F*B.bytesPerLine,s=(B.height-1-G)*B.outLineWidth;for(let F=0;F<B.channels;F++){const Z=u.channels[F].name,p=B.channelLineOffsets[Z],G=B.decodeChannels[Z];if(void 0!==G){V.value=e+p;for(let u=0;u<B.width;u++){const F=s+u*B.outputChannels+G;B.byteArray&&(B.byteArray[F]=B.getter(R,V))}}}}}}RB.DefaultOutputType=pB.HalfFloat,RB.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class YB{constructor(){this.supportCascades=!1}loadCubeData(B,u,F,Z,V){throw".exr not supported in Cube."}loadData(B,u,F){const V=new DataView(B.buffer),p={value:0},G=w(V,p);eB(G,V,p,RB.DefaultOutputType).then((B=>{sB(B,G,V,p);const Z=G.dataWindow.xMax-G.dataWindow.xMin+1,R=G.dataWindow.yMax-G.dataWindow.yMin+1;F(Z,R,u.generateMipMaps,!1,(()=>{const F=u.getEngine();u.format=G.format,u.type=B.textureType,u.invertY=!1,u._gammaSpace=!G.linearSpace,B.byteArray&&F._uploadDataToTextureDirectly(u,B.byteArray,0,0,void 0,!0)}))})).catch((B=>{Z.d.Error("Failed to load EXR texture: ",B)}))}}async function QB(B){const u=new DataView(B),F={value:0},V=w(u,F);try{const B=await eB(V,u,F,pB.Float);return sB(B,V,u,F),B.byteArray?{width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,data:new Float32Array(B.byteArray)}:(Z.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(p){Z.d.Error("Failed to load EXR data: ",p)}return{width:0,height:0,data:null}}},12994:(B,u,F)=>{function Z(B){return parseInt(B.toString().replace(/\W/g,""))}function V(B,u){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(B-u)<=F}function p(B,u,F){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return B<u-Z||B>F+Z}function G(B,u){return B===u?B:Math.random()*(u-B)+B}function R(B,u,F){return B+(u-B)*F}function e(B,u,F){let Z=q(u-B,360);return Z>180&&(Z-=360),B+Z*t(F)}function s(B,u,F){let Z=0;return Z=B!=u?t((F-B)/(u-B)):0,Z}function Y(B,u,F,Z,V){const p=V*V,G=V*p;return B*(2*G-3*p+1)+F*(-2*G+3*p)+u*(G-2*p+V)+Z*(G-p)}function Q(B,u,F,Z,V){const p=V*V;return 6*(p-V)*B+(3*p-4*V+1)*u+6*(-p+V)*F+(3*p-2*V)*Z}function t(B){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(u,B))}function v(B){return B-=2*Math.PI*Math.floor((B+Math.PI)/(2*Math.PI))}function D(B){const u=B.toString(16);return B<=15?("0"+u).toUpperCase():u.toUpperCase()}function L(B){if(Math.log2)return Math.floor(Math.log2(B));if(B<0)return NaN;if(0===B)return-1/0;let u=0;if(B<1){for(;B<1;)u++,B*=2;u=-u}else if(B>1)for(;B>1;)u++,B=Math.floor(B/2);return u}function q(B,u){return B-Math.floor(B/u)*u}function W(B,u,F){return(B-u)/(F-u)}function X(B,u,F){return B*(F-u)+u}function f(B,u){let F=q(u-B,360);return F>180&&(F-=360),F}function C(B,u){const F=q(B,2*u);return u-Math.abs(F-u)}function x(B,u,F){let Z=t(F);return Z=-2*Z*Z*Z+3*Z*Z,u*Z+B*(1-Z)}function U(B,u,F){let Z=0;return Z=Math.abs(u-B)<=F?u:B+Math.sign(u-B)*F,Z}function y(B,u,F){const Z=f(B,u);let V=0;return V=-F<Z&&Z<F?u:U(B,u=B+Z,F),V}function O(B,u,F){return(B-u)/(F-u)}function g(B,u,F){return(F-u)*B+u}function J(B,u){const F=B%u;return 0===F?u:J(u,F)}F.r(u),F.d(u,{Clamp:()=>t,DeltaAngle:()=>f,Denormalize:()=>X,ExtractAsInt:()=>Z,Hermite:()=>Y,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>J,ILog2:()=>L,InverseLerp:()=>s,Lerp:()=>R,LerpAngle:()=>e,MoveTowards:()=>U,MoveTowardsAngle:()=>y,Normalize:()=>W,NormalizeRadians:()=>v,OutsideRange:()=>p,PercentToRange:()=>g,PingPong:()=>C,RandomRange:()=>G,RangeToPercent:()=>O,Repeat:()=>q,SmoothStep:()=>x,ToHex:()=>D,WithinEpsilon:()=>V})}}]);