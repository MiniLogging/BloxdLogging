"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[16],{14777:(H,u,J)=>{J.r(u),J.d(u,{ReadExrDataAsync:()=>GH,_ExrTextureLoader:()=>dH});var O=J(12185),U=J(12349);const h=4,w=4,g=1,B=2,b=8,d=65536,G=d>>3,P=14,mH=65537,l=1<<P,r=l-1,p=59,a=63,k=2+a-p;var C,j;!function(H){H[H.NO_COMPRESSION=0]="NO_COMPRESSION",H[H.RLE_COMPRESSION=1]="RLE_COMPRESSION",H[H.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",H[H.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",H[H.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",H[H.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(H){H[H.INCREASING_Y=0]="INCREASING_Y",H[H.DECREASING_Y=1]="DECREASING_Y"}(j||(j={}));const M=function(){const H=new ArrayBuffer(4),u=new Float32Array(H),J=new Uint32Array(H),O=new Uint32Array(512),U=new Uint32Array(512);for(let B=0;B<256;++B){const H=B-127;H<-27?(O[B]=0,O[256|B]=32768,U[B]=24,U[256|B]=24):H<-14?(O[B]=1024>>-H-14,O[256|B]=1024>>-H-14|32768,U[B]=-H-1,U[256|B]=-H-1):H<=15?(O[B]=H+15<<10,O[256|B]=H+15<<10|32768,U[B]=13,U[256|B]=13):H<128?(O[B]=31744,O[256|B]=64512,U[B]=24,U[256|B]=24):(O[B]=31744,O[256|B]=64512,U[B]=13,U[256|B]=13)}const h=new Uint32Array(2048),w=new Uint32Array(64),g=new Uint32Array(64);for(let B=1;B<1024;++B){let H=B<<13,u=0;for(;0===(8388608&H);)H<<=1,u-=8388608;H&=-8388609,u+=947912704,h[B]=H|u}for(let B=1024;B<2048;++B)h[B]=939524096+(B-1024<<13);for(let B=1;B<31;++B)w[B]=B<<23;w[31]=1199570944,w[32]=2147483648;for(let B=33;B<63;++B)w[B]=2147483648+(B-32<<23);w[63]=3347054592;for(let B=1;B<64;++B)32!==B&&(g[B]=1024);return{floatView:u,uint32View:J,baseTable:O,shiftTable:U,mantissaTable:h,exponentTable:w,offsetTable:g}}();function L(H,u){const J=new Uint8Array(H);let O=0;for(;0!=J[u.value+O];)O+=1;const U=(new TextDecoder).decode(J.slice(u.value,u.value+O));return u.value=u.value+O+1,U}function Z(H,u){const J=H.getInt32(u.value,!0);return u.value+=h,J}function Y(H,u){const J=H.getUint32(u.value,!0);return u.value+=h,J}function F(H,u){const J=H.getUint8(u.value);return u.value+=g,J}function s(H,u){const J=H.getUint16(u.value,!0);return u.value+=B,J}function A(H,u){const J=H[u.value];return u.value+=g,J}function t(H,u){let J;return J="getBigInt64"in DataView.prototype?Number(H.getBigInt64(u.value,!0)):H.getUint32(u.value+4,!0)+Number(H.getUint32(u.value,!0)<<32),u.value+=b,J}function e(H,u){const J=H.getFloat32(u.value,!0);return u.value+=w,J}function c(H,u){return function(H){const u=(31744&H)>>10,J=1023&H;return(H>>15?-1:1)*(u?31===u?J?NaN:1/0:Math.pow(2,u-15)*(1+J/1024):J/1024*6103515625e-14)}(s(H,u))}function n(H,u){return function(H){if(Math.abs(H)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");H=(0,U.Clamp)(H,-65504,65504),M.floatView[0]=H;const u=M.uint32View[0],J=u>>23&511;return M.baseTable[J]+((8388607&u)>>M.shiftTable[J])}(e(H,u))}function V(H,u,J,O){switch(J){case"string":case"stringvector":case"iccProfile":return function(H,u,J){const O=(new TextDecoder).decode(new Uint8Array(H).slice(u.value,u.value+J));return u.value=u.value+J,O}(H.buffer,u,O);case"chlist":return function(H,u,J){const O=u.value,U=[];for(;u.value<O+J-1;){const J=L(H.buffer,u),O=Z(H,u),h=F(H,u);u.value+=3;const w=Z(H,u),g=Z(H,u);U.push({name:J,pixelType:O,pLinear:h,xSampling:w,ySampling:g})}return u.value+=1,U}(H,u,O);case"chromaticities":return function(H,u){return{redX:e(H,u),redY:e(H,u),greenX:e(H,u),greenY:e(H,u),blueX:e(H,u),blueY:e(H,u),whiteX:e(H,u),whiteY:e(H,u)}}(H,u);case"compression":return function(H,u){return F(H,u)}(H,u);case"box2i":return function(H,u){return{xMin:Z(H,u),yMin:Z(H,u),xMax:Z(H,u),yMax:Z(H,u)}}(H,u);case"lineOrder":return function(H,u){const J=F(H,u);return j[J]}(H,u);case"float":return e(H,u);case"v2f":return function(H,u){return[e(H,u),e(H,u)]}(H,u);case"v3f":return function(H,u){return[e(H,u),e(H,u),e(H,u)]}(H,u);case"int":return Z(H,u);case"rational":return function(H,u){return[Z(H,u),Y(H,u)]}(H,u);case"timecode":return function(H,u){return[Y(H,u),Y(H,u)]}(H,u);case"preview":return u.value+=O,"skipped";default:return void(u.value+=O)}}function T(H){for(let u=1;u<H.length;u++){const J=H[u-1]+H[u]-128;H[u]=J}}function R(H,u){let J=0,O=Math.floor((H.length+1)/2),U=0;const h=H.length-1;for(;!(U>h)&&(u[U++]=H[J++],!(U>h));)u[U++]=H[O++]}const X=20000630;function W(H,u){if(H.getUint32(0,!0)!=X)throw new Error("Incorrect OpenEXR format");const J=H.getUint8(4),U=H.getUint8(5),h={singleTile:!!(2&U),longName:!!(4&U),deepFormat:!!(8&U),multiPart:!!(16&U)};u.value=8;const w={};let g=!0;for(;g;){const J=L(H.buffer,u);if(J){const U=L(H.buffer,u),h=V(H,u,U,Y(H,u));void 0===h?O.b.Warn(`Unknown header attribute type ${U}'.`):w[J]=h}else g=!1}if(0!=(-5&U))throw new Error("Unsupported file format");return{version:J,spec:h,...w}}const f=32768,i=65535;function S(H,u,J,O,U){for(;J<H;)u=u<<8|A(O,U),J+=8;return{l:u>>(J-=H)&(1<<H)-1,c:u,lc:J}}function v(H,u,J,O){return{c:H=H<<8|A(J,O),lc:u+=8}}function I(H,u,J,O,U,h,w,g,B){if(H==u){if(O<8){const H=v(J,O,U,h);J=H.c,O=H.lc}let H=J>>(O-=8);if(H=new Uint8Array([H])[0],g.value+H>B)return null;const u=w[g.value-1];for(;H-- >0;)w[g.value++]=u}else{if(!(g.value<B))return null;w[g.value++]=H}return{c:J,lc:O}}const D=new Array(59);function o(H,u,J,O,U,h){const w=u;let g=0,B=0;for(;O<=U;O++){if(w.value-u.value>J)return;let b=S(6,g,B,H,w);const d=b.l;if(g=b.c,B=b.lc,h[O]=d,d==a){if(w.value-u.value>J)throw new Error("Error in HufUnpackEncTable");b=S(8,g,B,H,w);let d=b.l+k;if(g=b.c,B=b.lc,O+d>U+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)h[O++]=0;O--}else if(d>=p){let H=d-p+2;if(O+H>U+1)throw new Error("Error in HufUnpackEncTable");for(;H--;)h[O++]=0;O--}}!function(H){for(let J=0;J<=58;++J)D[J]=0;for(let J=0;J<mH;++J)D[H[J]]+=1;let u=0;for(let J=58;J>0;--J){const H=u+D[J]>>1;D[J]=u,u=H}for(let J=0;J<mH;++J){const u=H[J];u>0&&(H[J]=u|D[u]++<<6)}}(h)}function y(H){return 63&H}function x(H){return H>>6}function z(H,u,J,O,U,h){const w=J.value,g=Y(u,J),B=Y(u,J);J.value+=4;const b=Y(u,J);if(J.value+=4,g<0||g>=mH||B<0||B>=mH)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(mH),G=new Array(l);!function(H){for(let u=0;u<l;u++)H[u]={},H[u].len=0,H[u].lit=0,H[u].p=null}(G);if(o(H,J,O-(J.value-w),g,B,d),b>8*(O-(J.value-w)))throw new Error("Wrong hufUncompress");!function(H,u,J,O){for(;u<=J;u++){const J=x(H[u]),U=y(H[u]);if(J>>U)throw new Error("Invalid table entry");if(U>P){const H=O[J>>U-P];if(H.len)throw new Error("Invalid table entry");if(H.lit++,H.p){const u=H.p;H.p=new Array(H.lit);for(let J=0;J<H.lit-1;++J)H.p[J]=u[J]}else H.p=new Array(1);H.p[H.lit-1]=u}else if(U){let H=0;for(let h=1<<P-U;h>0;h--){const h=O[(J<<P-U)+H];if(h.len||h.p)throw new Error("Invalid table entry");h.len=U,h.lit=u,H++}}}}(d,g,B,G),function(H,u,J,O,U,h,w,g,B){let b=0,d=0;const G=w,mH=Math.trunc(O.value+(U+7)/8);for(;O.value<mH;){let U=v(b,d,J,O);for(b=U.c,d=U.lc;d>=P;){const w=u[b>>d-P&r];if(w.len){d-=w.len;const H=I(w.lit,h,b,d,J,O,g,B,G);H&&(b=H.c,d=H.lc)}else{if(!w.p)throw new Error("hufDecode issues");let u;for(u=0;u<w.lit;u++){const P=y(H[w.p[u]]);for(;d<P&&O.value<mH;)U=v(b,d,J,O),b=U.c,d=U.lc;if(d>=P&&x(H[w.p[u]])==(b>>d-P&(1<<P)-1)){d-=P;const H=I(w.p[u],h,b,d,J,O,g,B,G);H&&(b=H.c,d=H.lc);break}}if(u==w.lit)throw new Error("HufDecode issues")}}}const l=8-U&7;for(b>>=l,d-=l;d>0;){const H=u[b<<P-d&r];if(!H.len)throw new Error("HufDecode issues");{d-=H.len;const u=I(H.lit,h,b,d,J,O,g,B,G);u&&(b=u.c,d=u.lc)}}}(d,G,H,J,b,B,h,U,{value:0})}function K(H){return 65535&H}function N(H){const u=K(H);return u>32767?u-65536:u}function q(H,u){const J=N(H),O=N(u),U=J+(1&O)+(O>>1);return{a:U,b:U-O}}function E(H,u){const J=K(H),O=K(u),U=J-(O>>1)&i;return{a:O+U-f&i,b:U}}function Q(H,u,J,O,U,h,w){const g=w<16384,B=J>U?U:J;let b,d,G=1;for(;G<=B;)G<<=1;for(G>>=1,b=G,G>>=1;G>=1;){d=0;const w=d+h*(U-b),B=h*G,P=h*b,mH=O*G,l=O*b;let r,p,a,k;for(;d<=w;d+=P){let U=d;const h=d+O*(J-b);for(;U<=h;U+=l){const J=U+mH,O=U+B,h=O+mH;if(g){let w=q(H[U+u],H[O+u]);r=w.a,a=w.b,w=q(H[J+u],H[h+u]),p=w.a,k=w.b,w=q(r,p),H[U+u]=w.a,H[J+u]=w.b,w=q(a,k),H[O+u]=w.a,H[h+u]=w.b}else{let w=E(H[U+u],H[O+u]);r=w.a,a=w.b,w=E(H[J+u],H[h+u]),p=w.a,k=w.b,w=E(r,p),H[U+u]=w.a,H[J+u]=w.b,w=E(a,k),H[O+u]=w.a,H[h+u]=w.b}}if(J&G){const J=U+B;let O;O=g?q(H[U+u],H[J+u]):E(H[U+u],H[J+u]),r=O.a,H[J+u]=O.b,H[U+u]=r}}if(U&G){let U=d;const h=d+O*(J-b);for(;U<=h;U+=l){const J=U+mH;let O;O=g?q(H[U+u],H[J+u]):E(H[U+u],H[J+u]),r=O.a,H[J+u]=O.b,H[U+u]=r}}b=G,G>>=1}return d}function HH(H){return new DataView(H.array.buffer,H.offset.value,H.size)}function uH(H){const u=H.viewer.buffer.slice(H.offset.value,H.offset.value+H.size),J=new Uint8Array(function(H){let u=H.byteLength;const J=[];let O=0;const U=new DataView(H);for(;u>0;){const H=U.getInt8(O++);if(H<0){const h=-H;u-=h+1;for(let H=0;H<h;H++)J.push(U.getUint8(O++))}else{const h=H;u-=2;const w=U.getUint8(O++);for(let H=0;H<h+1;H++)J.push(w)}}return J}(u)),O=new Uint8Array(J.length);return T(J),R(J,O),new DataView(O.buffer)}function JH(H){const u=H.array.slice(H.offset.value,H.offset.value+H.size),J=fflate.unzlibSync(u),O=new Uint8Array(J.length);return T(J),R(J,O),new DataView(O.buffer)}function OH(H){const u=H.array.slice(H.offset.value,H.offset.value+H.size),J=fflate.unzlibSync(u),O=H.lines*H.channels*H.width,U=1==H.type?new Uint16Array(O):new Uint32Array(O);let h=0,w=0;const g=new Array(4);for(let B=0;B<H.lines;B++)for(let u=0;u<H.channels;u++){let u=0;switch(H.type){case 1:g[0]=h,g[1]=g[0]+H.width,h=g[1]+H.width;for(let O=0;O<H.width;++O){u+=J[g[0]++]<<8|J[g[1]++],U[w]=u,w++}break;case 2:g[0]=h,g[1]=g[0]+H.width,g[2]=g[1]+H.width,h=g[2]+H.width;for(let O=0;O<H.width;++O){u+=J[g[0]++]<<24|J[g[1]++]<<16|J[g[2]++]<<8,U[w]=u,w++}}}return new DataView(U.buffer)}function UH(H){const u=H.viewer,J={value:H.offset.value},O=new Uint16Array(H.width*H.scanlineBlockSize*(H.channels*H.type)),U=new Uint8Array(G);let h=0;const w=new Array(H.channels);for(let B=0;B<H.channels;B++)w[B]={},w[B].start=h,w[B].end=w[B].start,w[B].nx=H.width,w[B].ny=H.lines,w[B].size=H.type,h+=w[B].nx*w[B].ny*w[B].size;const g=s(u,J),b=s(u,J);if(b>=G)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(g<=b)for(let B=0;B<b-g+1;B++)U[B+g]=F(u,J);const P=new Uint16Array(d),mH=function(H,u){let J=0;for(let U=0;U<d;++U)(0==U||H[U>>3]&1<<(7&U))&&(u[J++]=U);const O=J-1;for(;J<d;)u[J++]=0;return O}(U,P),l=Y(u,J);z(H.array,u,J,l,O,h);for(let B=0;B<H.channels;++B){const H=w[B];for(let u=0;u<w[B].size;++u)Q(O,H.start+u,H.nx,H.size,H.ny,H.nx*H.size,mH)}!function(H,u,J){for(let O=0;O<J;++O)u[O]=H[u[O]]}(P,O,h);let r=0;const p=new Uint8Array(O.buffer.byteLength);for(let d=0;d<H.lines;d++)for(let u=0;u<H.channels;u++){const H=w[u],J=H.nx*H.size,U=new Uint8Array(O.buffer,H.end*B,J*B);p.set(U,r),r+=J*B,H.end+=J}return new DataView(p.buffer)}var hH,wH=J(12171);!function(H){H[H.Float=0]="Float",H[H.HalfFloat=1]="HalfFloat"}(hH||(hH={}));class gH{}async function BH(H,u,J,O){const U={size:0,viewer:u,array:new Uint8Array(u.buffer),offset:J,width:H.dataWindow.xMax-H.dataWindow.xMin+1,height:H.dataWindow.yMax-H.dataWindow.yMin+1,channels:H.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(H.compression){case C.NO_COMPRESSION:U.lines=1,U.uncompress=HH;break;case C.RLE_COMPRESSION:U.lines=1,U.uncompress=uH;break;case C.ZIPS_COMPRESSION:U.lines=1,U.uncompress=JH,await wH.Tools.LoadScriptAsync(gH.FFLATEUrl);break;case C.ZIP_COMPRESSION:U.lines=16,U.uncompress=JH,await wH.Tools.LoadScriptAsync(gH.FFLATEUrl);break;case C.PIZ_COMPRESSION:U.lines=32,U.uncompress=UH;break;case C.PXR24_COMPRESSION:U.lines=16,U.uncompress=OH,await wH.Tools.LoadScriptAsync(gH.FFLATEUrl);break;default:throw new Error(C[H.compression]+" is unsupported")}U.scanlineBlockSize=U.lines;const h={};for(const w of H.channels)switch(w.name){case"R":case"G":case"B":case"A":case"Y":h[w.name]=!0,U.type=w.pixelType}let g=!1;if(h.R&&h.G&&h.B&&h.A)U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(h.R&&h.G&&h.B)g=!0,U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(h.R&&h.G)U.outputChannels=2,U.decodeChannels={R:0,G:1};else if(h.R)U.outputChannels=1,U.decodeChannels={R:0};else{if(!h.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");U.outputChannels=1,U.decodeChannels={Y:0}}if(1===U.type)switch(O){case hH.Float:U.getter=c,U.inputSize=B;break;case hH.HalfFloat:U.getter=s,U.inputSize=B}else{if(2!==U.type)throw new Error("Unsupported pixelType "+U.type+" for "+H.compression);switch(O){case hH.Float:U.getter=e,U.inputSize=w;break;case hH.HalfFloat:U.getter=n,U.inputSize=w}}U.blockCount=U.height/U.scanlineBlockSize;for(let w=0;w<U.blockCount;w++)t(u,J);const b=U.width*U.height*U.outputChannels;switch(O){case hH.Float:U.byteArray=new Float32Array(b),U.textureType=1,g&&U.byteArray.fill(1,0,b);break;case hH.HalfFloat:U.byteArray=new Uint16Array(b),U.textureType=2,g&&U.byteArray.fill(15360,0,b);break;default:throw new Error("Unsupported type: "+O)}let d=0;for(const w of H.channels)void 0!==U.decodeChannels[w.name]&&(U.channelLineOffsets[w.name]=d*U.width),d+=2*w.pixelType;return U.bytesPerLine=U.width*d,U.outLineWidth=U.width*U.outputChannels,"INCREASING_Y"===H.lineOrder?U.scanOrder=H=>H:U.scanOrder=H=>U.height-1-H,4==U.outputChannels?(U.format=5,U.linearSpace=!0):(U.format=6,U.linearSpace=!1),U}function bH(H,u,J,O){const U={value:0};for(let h=0;h<H.height/H.scanlineBlockSize;h++){const w=Z(J,O)-u.dataWindow.yMin;H.size=Y(J,O),H.lines=w+H.scanlineBlockSize>H.height?H.height-w:H.scanlineBlockSize;const g=H.size<H.lines*H.bytesPerLine&&H.uncompress?H.uncompress(H):HH(H);O.value+=H.size;for(let J=0;J<H.scanlineBlockSize;J++){const O=h*H.scanlineBlockSize,w=J+H.scanOrder(O);if(w>=H.height)continue;const B=J*H.bytesPerLine,b=(H.height-1-w)*H.outLineWidth;for(let J=0;J<H.channels;J++){const O=u.channels[J].name,h=H.channelLineOffsets[O],w=H.decodeChannels[O];if(void 0!==w){U.value=B+h;for(let u=0;u<H.width;u++){const J=b+u*H.outputChannels+w;H.byteArray&&(H.byteArray[J]=H.getter(g,U))}}}}}}gH.DefaultOutputType=hH.HalfFloat,gH.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dH{constructor(){this.supportCascades=!1}loadCubeData(H,u,J,O,U){throw".exr not supported in Cube."}loadData(H,u,J){const U=new DataView(H.buffer),h={value:0},w=W(U,h);BH(w,U,h,gH.DefaultOutputType).then((H=>{bH(H,w,U,h);const O=w.dataWindow.xMax-w.dataWindow.xMin+1,g=w.dataWindow.yMax-w.dataWindow.yMin+1;J(O,g,u.generateMipMaps,!1,(()=>{const J=u.getEngine();u.format=w.format,u.type=H.textureType,u.invertY=!1,u._gammaSpace=!w.linearSpace,H.byteArray&&J._uploadDataToTextureDirectly(u,H.byteArray,0,0,void 0,!0)}))})).catch((H=>{O.b.Error("Failed to load EXR texture: ",H)}))}}async function GH(H){const u=new DataView(H),J={value:0},U=W(u,J);try{const H=await BH(U,u,J,hH.Float);return bH(H,U,u,J),H.byteArray?{width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,data:new Float32Array(H.byteArray)}:(O.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(h){O.b.Error("Failed to load EXR data: ",h)}return{width:0,height:0,data:null}}},12349:(H,u,J)=>{function O(H){return parseInt(H.toString().replace(/\W/g,""))}function U(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(H-u)<=J}function h(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return H<u-O||H>J+O}function w(H,u){return H===u?H:Math.random()*(u-H)+H}function g(H,u,J){return H+(u-H)*J}function B(H,u,J){let O=p(u-H,360);return O>180&&(O-=360),H+O*P(J)}function b(H,u,J){let O=0;return O=H!=u?P((J-H)/(u-H)):0,O}function d(H,u,J,O,U){const h=U*U,w=U*h;return H*(2*w-3*h+1)+J*(-2*w+3*h)+u*(w-2*h+U)+O*(w-h)}function G(H,u,J,O,U){const h=U*U;return 6*(h-U)*H+(3*h-4*U+1)*u+6*(-h+U)*J+(3*h-2*U)*O}function P(H){let u=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(J,Math.max(u,H))}function mH(H){return H-=2*Math.PI*Math.floor((H+Math.PI)/(2*Math.PI))}function l(H){const u=H.toString(16);return H<=15?("0"+u).toUpperCase():u.toUpperCase()}function r(H){if(Math.log2)return Math.floor(Math.log2(H));if(H<0)return NaN;if(0===H)return-1/0;let u=0;if(H<1){for(;H<1;)u++,H*=2;u=-u}else if(H>1)for(;H>1;)u++,H=Math.floor(H/2);return u}function p(H,u){return H-Math.floor(H/u)*u}function a(H,u,J){return(H-u)/(J-u)}function k(H,u,J){return H*(J-u)+u}function C(H,u){let J=p(u-H,360);return J>180&&(J-=360),J}function j(H,u){const J=p(H,2*u);return u-Math.abs(J-u)}function M(H,u,J){let O=P(J);return O=-2*O*O*O+3*O*O,u*O+H*(1-O)}function L(H,u,J){let O=0;return O=Math.abs(u-H)<=J?u:H+Math.sign(u-H)*J,O}function Z(H,u,J){const O=C(H,u);let U=0;return U=-J<O&&O<J?u:L(H,u=H+O,J),U}function Y(H,u,J){return(H-u)/(J-u)}function F(H,u,J){return(J-u)*H+u}function s(H,u){const J=H%u;return 0===J?u:s(u,J)}J.r(u),J.d(u,{Clamp:()=>P,DeltaAngle:()=>C,Denormalize:()=>k,ExtractAsInt:()=>O,Hermite:()=>d,Hermite1stDerivative:()=>G,HighestCommonFactor:()=>s,ILog2:()=>r,InverseLerp:()=>b,Lerp:()=>g,LerpAngle:()=>B,MoveTowards:()=>L,MoveTowardsAngle:()=>Z,Normalize:()=>a,NormalizeRadians:()=>mH,OutsideRange:()=>h,PercentToRange:()=>F,PingPong:()=>j,RandomRange:()=>w,RangeToPercent:()=>Y,Repeat:()=>p,SmoothStep:()=>M,ToHex:()=>l,WithinEpsilon:()=>U})}}]);