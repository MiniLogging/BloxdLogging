"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[16],{14934:(U,G,C)=>{C.r(G),C.d(G,{ReadExrDataAsync:()=>DU,_ExrTextureLoader:()=>TU});var L=C(26),X=C(12731),l=C(12911);const t=4,E=4,K=1,P=2,O=8,T=65536,D=T>>3,y=14,V=65537,p=1<<y,I=p-1,H=59,x=63,h=2+x-H;var N,b;!function(U){U[U.NO_COMPRESSION=0]="NO_COMPRESSION",U[U.RLE_COMPRESSION=1]="RLE_COMPRESSION",U[U.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",U[U.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",U[U.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",U[U.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(N||(N={})),function(U){U[U.INCREASING_Y=0]="INCREASING_Y",U[U.DECREASING_Y=1]="DECREASING_Y"}(b||(b={}));const o=function(){const U=new ArrayBuffer(4),G=new Float32Array(U),C=new Uint32Array(U),L=new Uint32Array(512),X=new Uint32Array(512);for(let K=0;K<256;++K){const U=K-127;U<-27?(L[K]=0,L[256|K]=32768,X[K]=24,X[256|K]=24):U<-14?(L[K]=1024>>-U-14,L[256|K]=1024>>-U-14|32768,X[K]=-U-1,X[256|K]=-U-1):U<=15?(L[K]=U+15<<10,L[256|K]=U+15<<10|32768,X[K]=13,X[256|K]=13):U<128?(L[K]=31744,L[256|K]=64512,X[K]=24,X[256|K]=24):(L[K]=31744,L[256|K]=64512,X[K]=13,X[256|K]=13)}const l=new Uint32Array(2048),t=new Uint32Array(64),E=new Uint32Array(64);for(let K=1;K<1024;++K){let U=K<<13,G=0;for(;0===(8388608&U);)U<<=1,G-=8388608;U&=-8388609,G+=947912704,l[K]=U|G}for(let K=1024;K<2048;++K)l[K]=939524096+(K-1024<<13);for(let K=1;K<31;++K)t[K]=K<<23;t[31]=1199570944,t[32]=2147483648;for(let K=33;K<63;++K)t[K]=2147483648+(K-32<<23);t[63]=3347054592;for(let K=1;K<64;++K)32!==K&&(E[K]=1024);return{floatView:G,uint32View:C,baseTable:L,shiftTable:X,mantissaTable:l,exponentTable:t,offsetTable:E}}();function w(U,G){const C=new Uint8Array(U);let L=0;for(;0!=C[G.value+L];)L+=1;const X=(new TextDecoder).decode(C.slice(G.value,G.value+L));return G.value=G.value+L+1,X}function S(U,G){const C=U.getInt32(G.value,!0);return G.value+=t,C}function v(U,G){const C=U.getUint32(G.value,!0);return G.value+=t,C}function u(U,G){const C=U.getUint8(G.value);return G.value+=K,C}function d(U,G){const C=U.getUint16(G.value,!0);return G.value+=P,C}function g(U,G){const C=U[G.value];return G.value+=K,C}function Z(U,G){let C;return C="getBigInt64"in DataView.prototype?Number(U.getBigInt64(G.value,!0)):U.getUint32(G.value+4,!0)+Number(U.getUint32(G.value,!0)<<32),G.value+=O,C}function F(U,G){const C=U.getFloat32(G.value,!0);return G.value+=E,C}function q(U,G){return function(U){const G=(31744&U)>>10,C=1023&U;return(U>>15?-1:1)*(G?31===G?C?NaN:1/0:Math.pow(2,G-15)*(1+C/1024):C/1024*6103515625e-14)}(d(U,G))}function a(U,G){return function(U){if(Math.abs(U)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");U=(0,l.Clamp)(U,-65504,65504),o.floatView[0]=U;const G=o.uint32View[0],C=G>>23&511;return o.baseTable[C]+((8388607&G)>>o.shiftTable[C])}(F(U,G))}function k(U,G,C,L){switch(C){case"string":case"stringvector":case"iccProfile":return function(U,G,C){const L=(new TextDecoder).decode(new Uint8Array(U).slice(G.value,G.value+C));return G.value=G.value+C,L}(U.buffer,G,L);case"chlist":return function(U,G,C){const L=G.value,X=[];for(;G.value<L+C-1;){const C=w(U.buffer,G),L=S(U,G),l=u(U,G);G.value+=3;const t=S(U,G),E=S(U,G);X.push({name:C,pixelType:L,pLinear:l,xSampling:t,ySampling:E})}return G.value+=1,X}(U,G,L);case"chromaticities":return function(U,G){return{redX:F(U,G),redY:F(U,G),greenX:F(U,G),greenY:F(U,G),blueX:F(U,G),blueY:F(U,G),whiteX:F(U,G),whiteY:F(U,G)}}(U,G);case"compression":return function(U,G){return u(U,G)}(U,G);case"box2i":return function(U,G){return{xMin:S(U,G),yMin:S(U,G),xMax:S(U,G),yMax:S(U,G)}}(U,G);case"lineOrder":return function(U,G){const C=u(U,G);return b[C]}(U,G);case"float":return F(U,G);case"v2f":return function(U,G){return[F(U,G),F(U,G)]}(U,G);case"v3f":return function(U,G){return[F(U,G),F(U,G),F(U,G)]}(U,G);case"int":return S(U,G);case"rational":return function(U,G){return[S(U,G),v(U,G)]}(U,G);case"timecode":return function(U,G){return[v(U,G),v(U,G)]}(U,G);case"preview":return G.value+=L,"skipped";default:return void(G.value+=L)}}function n(U){for(let G=1;G<U.length;G++){const C=U[G-1]+U[G]-128;U[G]=C}}function Q(U,G){let C=0,L=Math.floor((U.length+1)/2),X=0;const l=U.length-1;for(;!(X>l)&&(G[X++]=U[C++],!(X>l));)G[X++]=U[L++]}const mU=20000630;function B(U,G){if(U.getUint32(0,!0)!=mU)throw new Error("Incorrect OpenEXR format");const C=U.getUint8(4),l=U.getUint8(5),t={singleTile:!!(2&l),longName:!!(4&l),deepFormat:!!(8&l),multiPart:!!(16&l)};G.value=8;const E={};let K=!0;for(;K;){const C=w(U.buffer,G);if(C){const L=w(U.buffer,G),l=k(U,G,L,v(U,G));void 0===l?X.d.Warn("Unknown header attribute type ".concat(L,"'.")):E[C]=l}else K=!1}if(0!=(-5&l))throw new Error("Unsupported file format");return(0,L.b)({version:C,spec:t},E)}const M=32768,z=65535;function s(U,G,C,L,X){for(;C<U;)G=G<<8|g(L,X),C+=8;return{l:G>>(C-=U)&(1<<U)-1,c:G,lc:C}}function j(U,G,C,L){return{c:U=U<<8|g(C,L),lc:G+=8}}function A(U,G,C,L,X,l,t,E,K){if(U==G){if(L<8){const U=j(C,L,X,l);C=U.c,L=U.lc}let U=C>>(L-=8);if(U=new Uint8Array([U])[0],E.value+U>K)return null;const G=t[E.value-1];for(;U-- >0;)t[E.value++]=G}else{if(!(E.value<K))return null;t[E.value++]=U}return{c:C,lc:L}}const Y=new Array(59);function e(U,G,C,L,X,l){const t=G;let E=0,K=0;for(;L<=X;L++){if(t.value-G.value>C)return;let P=s(6,E,K,U,t);const O=P.l;if(E=P.c,K=P.lc,l[L]=O,O==x){if(t.value-G.value>C)throw new Error("Error in HufUnpackEncTable");P=s(8,E,K,U,t);let O=P.l+h;if(E=P.c,K=P.lc,L+O>X+1)throw new Error("Error in HufUnpackEncTable");for(;O--;)l[L++]=0;L--}else if(O>=H){let U=O-H+2;if(L+U>X+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)l[L++]=0;L--}}!function(U){for(let C=0;C<=58;++C)Y[C]=0;for(let C=0;C<V;++C)Y[U[C]]+=1;let G=0;for(let C=58;C>0;--C){const U=G+Y[C]>>1;Y[C]=G,G=U}for(let C=0;C<V;++C){const G=U[C];G>0&&(U[C]=G|Y[G]++<<6)}}(l)}function i(U){return 63&U}function c(U){return U>>6}function R(U,G,C,L,X,l){const t=C.value,E=v(G,C),K=v(G,C);C.value+=4;const P=v(G,C);if(C.value+=4,E<0||E>=V||K<0||K>=V)throw new Error("Wrong HUF_ENCSIZE");const O=new Array(V),T=new Array(p);!function(U){for(let G=0;G<p;G++)U[G]={},U[G].len=0,U[G].lit=0,U[G].p=null}(T);if(e(U,C,L-(C.value-t),E,K,O),P>8*(L-(C.value-t)))throw new Error("Wrong hufUncompress");!function(U,G,C,L){for(;G<=C;G++){const C=c(U[G]),X=i(U[G]);if(C>>X)throw new Error("Invalid table entry");if(X>y){const U=L[C>>X-y];if(U.len)throw new Error("Invalid table entry");if(U.lit++,U.p){const G=U.p;U.p=new Array(U.lit);for(let C=0;C<U.lit-1;++C)U.p[C]=G[C]}else U.p=new Array(1);U.p[U.lit-1]=G}else if(X){let U=0;for(let l=1<<y-X;l>0;l--){const l=L[(C<<y-X)+U];if(l.len||l.p)throw new Error("Invalid table entry");l.len=X,l.lit=G,U++}}}}(O,E,K,T),function(U,G,C,L,X,l,t,E,K){let P=0,O=0;const T=t,D=Math.trunc(L.value+(X+7)/8);for(;L.value<D;){let X=j(P,O,C,L);for(P=X.c,O=X.lc;O>=y;){const t=G[P>>O-y&I];if(t.len){O-=t.len;const U=A(t.lit,l,P,O,C,L,E,K,T);U&&(P=U.c,O=U.lc)}else{if(!t.p)throw new Error("hufDecode issues");let G;for(G=0;G<t.lit;G++){const y=i(U[t.p[G]]);for(;O<y&&L.value<D;)X=j(P,O,C,L),P=X.c,O=X.lc;if(O>=y&&c(U[t.p[G]])==(P>>O-y&(1<<y)-1)){O-=y;const U=A(t.p[G],l,P,O,C,L,E,K,T);U&&(P=U.c,O=U.lc);break}}if(G==t.lit)throw new Error("HufDecode issues")}}}const V=8-X&7;for(P>>=V,O-=V;O>0;){const U=G[P<<y-O&I];if(!U.len)throw new Error("HufDecode issues");{O-=U.len;const G=A(U.lit,l,P,O,C,L,E,K,T);G&&(P=G.c,O=G.lc)}}}(O,T,U,C,P,K,l,X,{value:0})}function W(U){return 65535&U}function f(U){const G=W(U);return G>32767?G-65536:G}function r(U,G){const C=f(U),L=f(G),X=C+(1&L)+(L>>1);return{a:X,b:X-L}}function J(U,G){const C=W(U),L=W(G),X=C-(L>>1)&z;return{a:L+X-M&z,b:X}}function UU(U,G,C,L,X,l,t){const E=t<16384,K=C>X?X:C;let P,O,T=1;for(;T<=K;)T<<=1;for(T>>=1,P=T,T>>=1;T>=1;){O=0;const t=O+l*(X-P),K=l*T,D=l*P,y=L*T,V=L*P;let p,I,H,x;for(;O<=t;O+=D){let X=O;const l=O+L*(C-P);for(;X<=l;X+=V){const C=X+y,L=X+K,l=L+y;if(E){let t=r(U[X+G],U[L+G]);p=t.a,H=t.b,t=r(U[C+G],U[l+G]),I=t.a,x=t.b,t=r(p,I),U[X+G]=t.a,U[C+G]=t.b,t=r(H,x),U[L+G]=t.a,U[l+G]=t.b}else{let t=J(U[X+G],U[L+G]);p=t.a,H=t.b,t=J(U[C+G],U[l+G]),I=t.a,x=t.b,t=J(p,I),U[X+G]=t.a,U[C+G]=t.b,t=J(H,x),U[L+G]=t.a,U[l+G]=t.b}}if(C&T){const C=X+K;let L;L=E?r(U[X+G],U[C+G]):J(U[X+G],U[C+G]),p=L.a,U[C+G]=L.b,U[X+G]=p}}if(X&T){let X=O;const l=O+L*(C-P);for(;X<=l;X+=V){const C=X+y;let L;L=E?r(U[X+G],U[C+G]):J(U[X+G],U[C+G]),p=L.a,U[C+G]=L.b,U[X+G]=p}}P=T,T>>=1}return O}function GU(U){return new DataView(U.array.buffer,U.offset.value,U.size)}function CU(U){const G=U.viewer.buffer.slice(U.offset.value,U.offset.value+U.size),C=new Uint8Array(function(U){let G=U.byteLength;const C=[];let L=0;const X=new DataView(U);for(;G>0;){const U=X.getInt8(L++);if(U<0){const l=-U;G-=l+1;for(let U=0;U<l;U++)C.push(X.getUint8(L++))}else{const l=U;G-=2;const t=X.getUint8(L++);for(let U=0;U<l+1;U++)C.push(t)}}return C}(G)),L=new Uint8Array(C.length);return n(C),Q(C,L),new DataView(L.buffer)}function LU(U){const G=U.array.slice(U.offset.value,U.offset.value+U.size),C=fflate.unzlibSync(G),L=new Uint8Array(C.length);return n(C),Q(C,L),new DataView(L.buffer)}function XU(U){const G=U.array.slice(U.offset.value,U.offset.value+U.size),C=fflate.unzlibSync(G),L=U.lines*U.channels*U.width,X=1==U.type?new Uint16Array(L):new Uint32Array(L);let l=0,t=0;const E=new Array(4);for(let K=0;K<U.lines;K++)for(let G=0;G<U.channels;G++){let G=0;switch(U.type){case 1:E[0]=l,E[1]=E[0]+U.width,l=E[1]+U.width;for(let L=0;L<U.width;++L){G+=C[E[0]++]<<8|C[E[1]++],X[t]=G,t++}break;case 2:E[0]=l,E[1]=E[0]+U.width,E[2]=E[1]+U.width,l=E[2]+U.width;for(let L=0;L<U.width;++L){G+=C[E[0]++]<<24|C[E[1]++]<<16|C[E[2]++]<<8,X[t]=G,t++}}}return new DataView(X.buffer)}function lU(U){const G=U.viewer,C={value:U.offset.value},L=new Uint16Array(U.width*U.scanlineBlockSize*(U.channels*U.type)),X=new Uint8Array(D);let l=0;const t=new Array(U.channels);for(let P=0;P<U.channels;P++)t[P]={},t[P].start=l,t[P].end=t[P].start,t[P].nx=U.width,t[P].ny=U.lines,t[P].size=U.type,l+=t[P].nx*t[P].ny*t[P].size;const E=d(G,C),K=d(G,C);if(K>=D)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(E<=K)for(let P=0;P<K-E+1;P++)X[P+E]=u(G,C);const O=new Uint16Array(T),y=function(U,G){let C=0;for(let X=0;X<T;++X)(0==X||U[X>>3]&1<<(7&X))&&(G[C++]=X);const L=C-1;for(;C<T;)G[C++]=0;return L}(X,O),V=v(G,C);R(U.array,G,C,V,L,l);for(let P=0;P<U.channels;++P){const U=t[P];for(let G=0;G<t[P].size;++G)UU(L,U.start+G,U.nx,U.size,U.ny,U.nx*U.size,y)}!function(U,G,C){for(let L=0;L<C;++L)G[L]=U[G[L]]}(O,L,l);let p=0;const I=new Uint8Array(L.buffer.byteLength);for(let T=0;T<U.lines;T++)for(let G=0;G<U.channels;G++){const U=t[G],C=U.nx*U.size,X=new Uint8Array(L.buffer,U.end*P,C*P);I.set(X,p),p+=C*P,U.end+=C}return new DataView(I.buffer)}var tU,EU=C(12718);!function(U){U[U.Float=0]="Float",U[U.HalfFloat=1]="HalfFloat"}(tU||(tU={}));class KU{}async function PU(U,G,C,L){const X={size:0,viewer:G,array:new Uint8Array(G.buffer),offset:C,width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,channels:U.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(U.compression){case N.NO_COMPRESSION:X.lines=1,X.uncompress=GU;break;case N.RLE_COMPRESSION:X.lines=1,X.uncompress=CU;break;case N.ZIPS_COMPRESSION:X.lines=1,X.uncompress=LU,await EU.Tools.LoadScriptAsync(KU.FFLATEUrl);break;case N.ZIP_COMPRESSION:X.lines=16,X.uncompress=LU,await EU.Tools.LoadScriptAsync(KU.FFLATEUrl);break;case N.PIZ_COMPRESSION:X.lines=32,X.uncompress=lU;break;case N.PXR24_COMPRESSION:X.lines=16,X.uncompress=XU,await EU.Tools.LoadScriptAsync(KU.FFLATEUrl);break;default:throw new Error(N[U.compression]+" is unsupported")}X.scanlineBlockSize=X.lines;const l={};for(const E of U.channels)switch(E.name){case"R":case"G":case"B":case"A":case"Y":l[E.name]=!0,X.type=E.pixelType}let t=!1;if(l.R&&l.G&&l.B&&l.A)X.outputChannels=4,X.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G&&l.B)t=!0,X.outputChannels=4,X.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G)X.outputChannels=2,X.decodeChannels={R:0,G:1};else if(l.R)X.outputChannels=1,X.decodeChannels={R:0};else{if(!l.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");X.outputChannels=1,X.decodeChannels={Y:0}}if(1===X.type)switch(L){case tU.Float:X.getter=q,X.inputSize=P;break;case tU.HalfFloat:X.getter=d,X.inputSize=P}else{if(2!==X.type)throw new Error("Unsupported pixelType "+X.type+" for "+U.compression);switch(L){case tU.Float:X.getter=F,X.inputSize=E;break;case tU.HalfFloat:X.getter=a,X.inputSize=E}}X.blockCount=X.height/X.scanlineBlockSize;for(let E=0;E<X.blockCount;E++)Z(G,C);const K=X.width*X.height*X.outputChannels;switch(L){case tU.Float:X.byteArray=new Float32Array(K),X.textureType=1,t&&X.byteArray.fill(1,0,K);break;case tU.HalfFloat:X.byteArray=new Uint16Array(K),X.textureType=2,t&&X.byteArray.fill(15360,0,K);break;default:throw new Error("Unsupported type: "+L)}let O=0;for(const E of U.channels)void 0!==X.decodeChannels[E.name]&&(X.channelLineOffsets[E.name]=O*X.width),O+=2*E.pixelType;return X.bytesPerLine=X.width*O,X.outLineWidth=X.width*X.outputChannels,"INCREASING_Y"===U.lineOrder?X.scanOrder=U=>U:X.scanOrder=U=>X.height-1-U,4==X.outputChannels?(X.format=5,X.linearSpace=!0):(X.format=6,X.linearSpace=!1),X}function OU(U,G,C,L){const X={value:0};for(let l=0;l<U.height/U.scanlineBlockSize;l++){const t=S(C,L)-G.dataWindow.yMin;U.size=v(C,L),U.lines=t+U.scanlineBlockSize>U.height?U.height-t:U.scanlineBlockSize;const E=U.size<U.lines*U.bytesPerLine&&U.uncompress?U.uncompress(U):GU(U);L.value+=U.size;for(let C=0;C<U.scanlineBlockSize;C++){const L=l*U.scanlineBlockSize,t=C+U.scanOrder(L);if(t>=U.height)continue;const K=C*U.bytesPerLine,P=(U.height-1-t)*U.outLineWidth;for(let C=0;C<U.channels;C++){const L=G.channels[C].name,l=U.channelLineOffsets[L],t=U.decodeChannels[L];if(void 0!==t){X.value=K+l;for(let G=0;G<U.width;G++){const C=P+G*U.outputChannels+t;U.byteArray&&(U.byteArray[C]=U.getter(E,X))}}}}}}KU.DefaultOutputType=tU.HalfFloat,KU.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class TU{constructor(){this.supportCascades=!1}loadCubeData(U,G,C,L,X){throw".exr not supported in Cube."}loadData(U,G,C){const L=new DataView(U.buffer),l={value:0},t=B(L,l);PU(t,L,l,KU.DefaultOutputType).then((U=>{OU(U,t,L,l);const X=t.dataWindow.xMax-t.dataWindow.xMin+1,E=t.dataWindow.yMax-t.dataWindow.yMin+1;C(X,E,G.generateMipMaps,!1,(()=>{const C=G.getEngine();G.format=t.format,G.type=U.textureType,G.invertY=!1,G._gammaSpace=!t.linearSpace,U.byteArray&&C._uploadDataToTextureDirectly(G,U.byteArray,0,0,void 0,!0)}))})).catch((U=>{X.d.Error("Failed to load EXR texture: ",U)}))}}async function DU(U){const G=new DataView(U),C={value:0},L=B(G,C);try{const U=await PU(L,G,C,tU.Float);return OU(U,L,G,C),U.byteArray?{width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,data:new Float32Array(U.byteArray)}:(X.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(l){X.d.Error("Failed to load EXR data: ",l)}return{width:0,height:0,data:null}}},12911:(U,G,C)=>{function L(U){return parseInt(U.toString().replace(/\W/g,""))}function X(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(U-G)<=C}function l(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return U<G-L||U>C+L}function t(U,G){return U===G?U:Math.random()*(G-U)+U}function E(U,G,C){return U+(G-U)*C}function K(U,G,C){let L=I(G-U,360);return L>180&&(L-=360),U+L*D(C)}function P(U,G,C){let L=0;return L=U!=G?D((C-U)/(G-U)):0,L}function O(U,G,C,L,X){const l=X*X,t=X*l;return U*(2*t-3*l+1)+C*(-2*t+3*l)+G*(t-2*l+X)+L*(t-l)}function T(U,G,C,L,X){const l=X*X;return 6*(l-X)*U+(3*l-4*X+1)*G+6*(-l+X)*C+(3*l-2*X)*L}function D(U){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(G,U))}function y(U){return U-=2*Math.PI*Math.floor((U+Math.PI)/(2*Math.PI))}function V(U){const G=U.toString(16);return U<=15?("0"+G).toUpperCase():G.toUpperCase()}function p(U){if(Math.log2)return Math.floor(Math.log2(U));if(U<0)return NaN;if(0===U)return-1/0;let G=0;if(U<1){for(;U<1;)G++,U*=2;G=-G}else if(U>1)for(;U>1;)G++,U=Math.floor(U/2);return G}function I(U,G){return U-Math.floor(U/G)*G}function H(U,G,C){return(U-G)/(C-G)}function x(U,G,C){return U*(C-G)+G}function h(U,G){let C=I(G-U,360);return C>180&&(C-=360),C}function N(U,G){const C=I(U,2*G);return G-Math.abs(C-G)}function b(U,G,C){let L=D(C);return L=-2*L*L*L+3*L*L,G*L+U*(1-L)}function o(U,G,C){let L=0;return L=Math.abs(G-U)<=C?G:U+Math.sign(G-U)*C,L}function w(U,G,C){const L=h(U,G);let X=0;return X=-C<L&&L<C?G:o(U,G=U+L,C),X}function S(U,G,C){return(U-G)/(C-G)}function v(U,G,C){return(C-G)*U+G}function u(U,G){const C=U%G;return 0===C?G:u(G,C)}C.r(G),C.d(G,{Clamp:()=>D,DeltaAngle:()=>h,Denormalize:()=>x,ExtractAsInt:()=>L,Hermite:()=>O,Hermite1stDerivative:()=>T,HighestCommonFactor:()=>u,ILog2:()=>p,InverseLerp:()=>P,Lerp:()=>E,LerpAngle:()=>K,MoveTowards:()=>o,MoveTowardsAngle:()=>w,Normalize:()=>H,NormalizeRadians:()=>y,OutsideRange:()=>l,PercentToRange:()=>v,PingPong:()=>N,RandomRange:()=>t,RangeToPercent:()=>S,Repeat:()=>I,SmoothStep:()=>b,ToHex:()=>V,WithinEpsilon:()=>X})}}]);