"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[16],{14062:(U,X,b)=>{b.r(X),b.d(X,{ReadExrDataAsync:()=>RU,_ExrTextureLoader:()=>SU});var F=b(11408),E=b(11608);const w=4,Q=4,z=1,q=2,p=8,S=65536,R=S>>3,n=14,a=65537,J=1<<n,m=J-1,x=59,I=63,O=2+I-x;var N,u;!function(U){U[U.NO_COMPRESSION=0]="NO_COMPRESSION",U[U.RLE_COMPRESSION=1]="RLE_COMPRESSION",U[U.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",U[U.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",U[U.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",U[U.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(N||(N={})),function(U){U[U.INCREASING_Y=0]="INCREASING_Y",U[U.DECREASING_Y=1]="DECREASING_Y"}(u||(u={}));const i=function(){const U=new ArrayBuffer(4),X=new Float32Array(U),b=new Uint32Array(U),F=new Uint32Array(512),E=new Uint32Array(512);for(let q=0;q<256;++q){const U=q-127;U<-27?(F[q]=0,F[256|q]=32768,E[q]=24,E[256|q]=24):U<-14?(F[q]=1024>>-U-14,F[256|q]=1024>>-U-14|32768,E[q]=-U-1,E[256|q]=-U-1):U<=15?(F[q]=U+15<<10,F[256|q]=U+15<<10|32768,E[q]=13,E[256|q]=13):U<128?(F[q]=31744,F[256|q]=64512,E[q]=24,E[256|q]=24):(F[q]=31744,F[256|q]=64512,E[q]=13,E[256|q]=13)}const w=new Uint32Array(2048),Q=new Uint32Array(64),z=new Uint32Array(64);for(let q=1;q<1024;++q){let U=q<<13,X=0;for(;0===(8388608&U);)U<<=1,X-=8388608;U&=-8388609,X+=947912704,w[q]=U|X}for(let q=1024;q<2048;++q)w[q]=939524096+(q-1024<<13);for(let q=1;q<31;++q)Q[q]=q<<23;Q[31]=1199570944,Q[32]=2147483648;for(let q=33;q<63;++q)Q[q]=2147483648+(q-32<<23);Q[63]=3347054592;for(let q=1;q<64;++q)32!==q&&(z[q]=1024);return{floatView:X,uint32View:b,baseTable:F,shiftTable:E,mantissaTable:w,exponentTable:Q,offsetTable:z}}();function P(U,X){const b=new Uint8Array(U);let F=0;for(;0!=b[X.value+F];)F+=1;const E=(new TextDecoder).decode(b.slice(X.value,X.value+F));return X.value=X.value+F+1,E}function f(U,X){const b=U.getInt32(X.value,!0);return X.value+=w,b}function j(U,X){const b=U.getUint32(X.value,!0);return X.value+=w,b}function e(U,X){const b=U.getUint8(X.value);return X.value+=z,b}function l(U,X){const b=U.getUint16(X.value,!0);return X.value+=q,b}function d(U,X){const b=U[X.value];return X.value+=z,b}function k(U,X){let b;return b="getBigInt64"in DataView.prototype?Number(U.getBigInt64(X.value,!0)):U.getUint32(X.value+4,!0)+Number(U.getUint32(X.value,!0)<<32),X.value+=p,b}function v(U,X){const b=U.getFloat32(X.value,!0);return X.value+=Q,b}function A(U,X){return function(U){const X=(31744&U)>>10,b=1023&U;return(U>>15?-1:1)*(X?31===X?b?NaN:1/0:Math.pow(2,X-15)*(1+b/1024):b/1024*6103515625e-14)}(l(U,X))}function s(U,X){return function(U){if(Math.abs(U)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");U=(0,E.Clamp)(U,-65504,65504),i.floatView[0]=U;const X=i.uint32View[0],b=X>>23&511;return i.baseTable[b]+((8388607&X)>>i.shiftTable[b])}(v(U,X))}function h(U,X,b,F){switch(b){case"string":case"stringvector":case"iccProfile":return function(U,X,b){const F=(new TextDecoder).decode(new Uint8Array(U).slice(X.value,X.value+b));return X.value=X.value+b,F}(U.buffer,X,F);case"chlist":return function(U,X,b){const F=X.value,E=[];for(;X.value<F+b-1;){const b=P(U.buffer,X),F=f(U,X),w=e(U,X);X.value+=3;const Q=f(U,X),z=f(U,X);E.push({name:b,pixelType:F,pLinear:w,xSampling:Q,ySampling:z})}return X.value+=1,E}(U,X,F);case"chromaticities":return function(U,X){return{redX:v(U,X),redY:v(U,X),greenX:v(U,X),greenY:v(U,X),blueX:v(U,X),blueY:v(U,X),whiteX:v(U,X),whiteY:v(U,X)}}(U,X);case"compression":return function(U,X){return e(U,X)}(U,X);case"box2i":return function(U,X){return{xMin:f(U,X),yMin:f(U,X),xMax:f(U,X),yMax:f(U,X)}}(U,X);case"lineOrder":return function(U,X){const b=e(U,X);return u[b]}(U,X);case"float":return v(U,X);case"v2f":return function(U,X){return[v(U,X),v(U,X)]}(U,X);case"v3f":return function(U,X){return[v(U,X),v(U,X),v(U,X)]}(U,X);case"int":return f(U,X);case"rational":return function(U,X){return[f(U,X),j(U,X)]}(U,X);case"timecode":return function(U,X){return[j(U,X),j(U,X)]}(U,X);case"preview":return X.value+=F,"skipped";default:return void(X.value+=F)}}function B(U){for(let X=1;X<U.length;X++){const b=U[X-1]+U[X]-128;U[X]=b}}function o(U,X){let b=0,F=Math.floor((U.length+1)/2),E=0;const w=U.length-1;for(;!(E>w)&&(X[E++]=U[b++],!(E>w));)X[E++]=U[F++]}const y=20000630;function t(U,X){if(U.getUint32(0,!0)!=y)throw new Error("Incorrect OpenEXR format");const b=U.getUint8(4),E=U.getUint8(5),w={singleTile:!!(2&E),longName:!!(4&E),deepFormat:!!(8&E),multiPart:!!(16&E)};X.value=8;const Q={};let z=!0;for(;z;){const b=P(U.buffer,X);if(b){const E=P(U.buffer,X),w=h(U,X,E,j(U,X));void 0===w?F.e.Warn(`Unknown header attribute type ${E}'.`):Q[b]=w}else z=!1}if(0!=(-5&E))throw new Error("Unsupported file format");return{version:b,spec:w,...Q}}const W=32768,Y=65535;function K(U,X,b,F,E){for(;b<U;)X=X<<8|d(F,E),b+=8;return{l:X>>(b-=U)&(1<<U)-1,c:X,lc:b}}function V(U,X,b,F){return{c:U=U<<8|d(b,F),lc:X+=8}}function g(U,X,b,F,E,w,Q,z,q){if(U==X){if(F<8){const U=V(b,F,E,w);b=U.c,F=U.lc}let U=b>>(F-=8);if(U=new Uint8Array([U])[0],z.value+U>q)return null;const X=Q[z.value-1];for(;U-- >0;)Q[z.value++]=X}else{if(!(z.value<q))return null;Q[z.value++]=U}return{c:b,lc:F}}const L=new Array(59);function D(U,X,b,F,E,w){const Q=X;let z=0,q=0;for(;F<=E;F++){if(Q.value-X.value>b)return;let p=K(6,z,q,U,Q);const S=p.l;if(z=p.c,q=p.lc,w[F]=S,S==I){if(Q.value-X.value>b)throw new Error("Error in HufUnpackEncTable");p=K(8,z,q,U,Q);let S=p.l+O;if(z=p.c,q=p.lc,F+S>E+1)throw new Error("Error in HufUnpackEncTable");for(;S--;)w[F++]=0;F--}else if(S>=x){let U=S-x+2;if(F+U>E+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)w[F++]=0;F--}}!function(U){for(let b=0;b<=58;++b)L[b]=0;for(let b=0;b<a;++b)L[U[b]]+=1;let X=0;for(let b=58;b>0;--b){const U=X+L[b]>>1;L[b]=X,X=U}for(let b=0;b<a;++b){const X=U[b];X>0&&(U[b]=X|L[X]++<<6)}}(w)}function G(U){return 63&U}function Z(U){return U>>6}function c(U,X,b,F,E,w){const Q=b.value,z=j(X,b),q=j(X,b);b.value+=4;const p=j(X,b);if(b.value+=4,z<0||z>=a||q<0||q>=a)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(a),R=new Array(J);!function(U){for(let X=0;X<J;X++)U[X]={},U[X].len=0,U[X].lit=0,U[X].p=null}(R);if(D(U,b,F-(b.value-Q),z,q,S),p>8*(F-(b.value-Q)))throw new Error("Wrong hufUncompress");!function(U,X,b,F){for(;X<=b;X++){const b=Z(U[X]),E=G(U[X]);if(b>>E)throw new Error("Invalid table entry");if(E>n){const U=F[b>>E-n];if(U.len)throw new Error("Invalid table entry");if(U.lit++,U.p){const X=U.p;U.p=new Array(U.lit);for(let b=0;b<U.lit-1;++b)U.p[b]=X[b]}else U.p=new Array(1);U.p[U.lit-1]=X}else if(E){let U=0;for(let w=1<<n-E;w>0;w--){const w=F[(b<<n-E)+U];if(w.len||w.p)throw new Error("Invalid table entry");w.len=E,w.lit=X,U++}}}}(S,z,q,R),function(U,X,b,F,E,w,Q,z,q){let p=0,S=0;const R=Q,a=Math.trunc(F.value+(E+7)/8);for(;F.value<a;){let E=V(p,S,b,F);for(p=E.c,S=E.lc;S>=n;){const Q=X[p>>S-n&m];if(Q.len){S-=Q.len;const U=g(Q.lit,w,p,S,b,F,z,q,R);U&&(p=U.c,S=U.lc)}else{if(!Q.p)throw new Error("hufDecode issues");let X;for(X=0;X<Q.lit;X++){const n=G(U[Q.p[X]]);for(;S<n&&F.value<a;)E=V(p,S,b,F),p=E.c,S=E.lc;if(S>=n&&Z(U[Q.p[X]])==(p>>S-n&(1<<n)-1)){S-=n;const U=g(Q.p[X],w,p,S,b,F,z,q,R);U&&(p=U.c,S=U.lc);break}}if(X==Q.lit)throw new Error("HufDecode issues")}}}const J=8-E&7;for(p>>=J,S-=J;S>0;){const U=X[p<<n-S&m];if(!U.len)throw new Error("HufDecode issues");{S-=U.len;const X=g(U.lit,w,p,S,b,F,z,q,R);X&&(p=X.c,S=X.lc)}}}(S,R,U,b,p,q,w,E,{value:0})}function r(U){return 65535&U}function M(U){const X=r(U);return X>32767?X-65536:X}function H(U,X){const b=M(U),F=M(X),E=b+(1&F)+(F>>1);return{a:E,b:E-F}}function T(U,X){const b=r(U),F=r(X),E=b-(F>>1)&Y;return{a:F+E-W&Y,b:E}}function C(U,X,b,F,E,w,Q){const z=Q<16384,q=b>E?E:b;let p,S,R=1;for(;R<=q;)R<<=1;for(R>>=1,p=R,R>>=1;R>=1;){S=0;const Q=S+w*(E-p),q=w*R,n=w*p,a=F*R,J=F*p;let m,x,I,O;for(;S<=Q;S+=n){let E=S;const w=S+F*(b-p);for(;E<=w;E+=J){const b=E+a,F=E+q,w=F+a;if(z){let Q=H(U[E+X],U[F+X]);m=Q.a,I=Q.b,Q=H(U[b+X],U[w+X]),x=Q.a,O=Q.b,Q=H(m,x),U[E+X]=Q.a,U[b+X]=Q.b,Q=H(I,O),U[F+X]=Q.a,U[w+X]=Q.b}else{let Q=T(U[E+X],U[F+X]);m=Q.a,I=Q.b,Q=T(U[b+X],U[w+X]),x=Q.a,O=Q.b,Q=T(m,x),U[E+X]=Q.a,U[b+X]=Q.b,Q=T(I,O),U[F+X]=Q.a,U[w+X]=Q.b}}if(b&R){const b=E+q;let F;F=z?H(U[E+X],U[b+X]):T(U[E+X],U[b+X]),m=F.a,U[b+X]=F.b,U[E+X]=m}}if(E&R){let E=S;const w=S+F*(b-p);for(;E<=w;E+=J){const b=E+a;let F;F=z?H(U[E+X],U[b+X]):T(U[E+X],U[b+X]),m=F.a,U[b+X]=F.b,U[E+X]=m}}p=R,R>>=1}return S}function UU(U){return new DataView(U.array.buffer,U.offset.value,U.size)}function XU(U){const X=U.viewer.buffer.slice(U.offset.value,U.offset.value+U.size),b=new Uint8Array(function(U){let X=U.byteLength;const b=[];let F=0;const E=new DataView(U);for(;X>0;){const U=E.getInt8(F++);if(U<0){const w=-U;X-=w+1;for(let U=0;U<w;U++)b.push(E.getUint8(F++))}else{const w=U;X-=2;const Q=E.getUint8(F++);for(let U=0;U<w+1;U++)b.push(Q)}}return b}(X)),F=new Uint8Array(b.length);return B(b),o(b,F),new DataView(F.buffer)}function bU(U){const X=U.array.slice(U.offset.value,U.offset.value+U.size),b=fflate.unzlibSync(X),F=new Uint8Array(b.length);return B(b),o(b,F),new DataView(F.buffer)}function FU(U){const X=U.array.slice(U.offset.value,U.offset.value+U.size),b=fflate.unzlibSync(X),F=U.lines*U.channels*U.width,E=1==U.type?new Uint16Array(F):new Uint32Array(F);let w=0,Q=0;const z=new Array(4);for(let q=0;q<U.lines;q++)for(let X=0;X<U.channels;X++){let X=0;switch(U.type){case 1:z[0]=w,z[1]=z[0]+U.width,w=z[1]+U.width;for(let F=0;F<U.width;++F){X+=b[z[0]++]<<8|b[z[1]++],E[Q]=X,Q++}break;case 2:z[0]=w,z[1]=z[0]+U.width,z[2]=z[1]+U.width,w=z[2]+U.width;for(let F=0;F<U.width;++F){X+=b[z[0]++]<<24|b[z[1]++]<<16|b[z[2]++]<<8,E[Q]=X,Q++}}}return new DataView(E.buffer)}function EU(U){const X=U.viewer,b={value:U.offset.value},F=new Uint16Array(U.width*U.scanlineBlockSize*(U.channels*U.type)),E=new Uint8Array(R);let w=0;const Q=new Array(U.channels);for(let q=0;q<U.channels;q++)Q[q]={},Q[q].start=w,Q[q].end=Q[q].start,Q[q].nx=U.width,Q[q].ny=U.lines,Q[q].size=U.type,w+=Q[q].nx*Q[q].ny*Q[q].size;const z=l(X,b),p=l(X,b);if(p>=R)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(z<=p)for(let q=0;q<p-z+1;q++)E[q+z]=e(X,b);const n=new Uint16Array(S),a=function(U,X){let b=0;for(let E=0;E<S;++E)(0==E||U[E>>3]&1<<(7&E))&&(X[b++]=E);const F=b-1;for(;b<S;)X[b++]=0;return F}(E,n),J=j(X,b);c(U.array,X,b,J,F,w);for(let q=0;q<U.channels;++q){const U=Q[q];for(let X=0;X<Q[q].size;++X)C(F,U.start+X,U.nx,U.size,U.ny,U.nx*U.size,a)}!function(U,X,b){for(let F=0;F<b;++F)X[F]=U[X[F]]}(n,F,w);let m=0;const x=new Uint8Array(F.buffer.byteLength);for(let S=0;S<U.lines;S++)for(let X=0;X<U.channels;X++){const U=Q[X],b=U.nx*U.size,E=new Uint8Array(F.buffer,U.end*q,b*q);x.set(E,m),m+=b*q,U.end+=b}return new DataView(x.buffer)}var wU,QU=b(11385);!function(U){U[U.Float=0]="Float",U[U.HalfFloat=1]="HalfFloat"}(wU||(wU={}));class zU{}async function qU(U,X,b,F){const E={size:0,viewer:X,array:new Uint8Array(X.buffer),offset:b,width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,channels:U.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(U.compression){case N.NO_COMPRESSION:E.lines=1,E.uncompress=UU;break;case N.RLE_COMPRESSION:E.lines=1,E.uncompress=XU;break;case N.ZIPS_COMPRESSION:E.lines=1,E.uncompress=bU,await QU.Tools.LoadScriptAsync(zU.FFLATEUrl);break;case N.ZIP_COMPRESSION:E.lines=16,E.uncompress=bU,await QU.Tools.LoadScriptAsync(zU.FFLATEUrl);break;case N.PIZ_COMPRESSION:E.lines=32,E.uncompress=EU;break;case N.PXR24_COMPRESSION:E.lines=16,E.uncompress=FU,await QU.Tools.LoadScriptAsync(zU.FFLATEUrl);break;default:throw new Error(N[U.compression]+" is unsupported")}E.scanlineBlockSize=E.lines;const w={};for(const Q of U.channels)switch(Q.name){case"R":case"G":case"B":case"A":case"Y":w[Q.name]=!0,E.type=Q.pixelType}let z=!1;if(w.R&&w.G&&w.B&&w.A)E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(w.R&&w.G&&w.B)z=!0,E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(w.R&&w.G)E.outputChannels=2,E.decodeChannels={R:0,G:1};else if(w.R)E.outputChannels=1,E.decodeChannels={R:0};else{if(!w.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");E.outputChannels=1,E.decodeChannels={Y:0}}if(1===E.type)switch(F){case wU.Float:E.getter=A,E.inputSize=q;break;case wU.HalfFloat:E.getter=l,E.inputSize=q}else{if(2!==E.type)throw new Error("Unsupported pixelType "+E.type+" for "+U.compression);switch(F){case wU.Float:E.getter=v,E.inputSize=Q;break;case wU.HalfFloat:E.getter=s,E.inputSize=Q}}E.blockCount=E.height/E.scanlineBlockSize;for(let Q=0;Q<E.blockCount;Q++)k(X,b);const p=E.width*E.height*E.outputChannels;switch(F){case wU.Float:E.byteArray=new Float32Array(p),E.textureType=1,z&&E.byteArray.fill(1,0,p);break;case wU.HalfFloat:E.byteArray=new Uint16Array(p),E.textureType=2,z&&E.byteArray.fill(15360,0,p);break;default:throw new Error("Unsupported type: "+F)}let S=0;for(const Q of U.channels)void 0!==E.decodeChannels[Q.name]&&(E.channelLineOffsets[Q.name]=S*E.width),S+=2*Q.pixelType;return E.bytesPerLine=E.width*S,E.outLineWidth=E.width*E.outputChannels,"INCREASING_Y"===U.lineOrder?E.scanOrder=U=>U:E.scanOrder=U=>E.height-1-U,4==E.outputChannels?(E.format=5,E.linearSpace=!0):(E.format=6,E.linearSpace=!1),E}function pU(U,X,b,F){const E={value:0};for(let w=0;w<U.height/U.scanlineBlockSize;w++){const Q=f(b,F)-X.dataWindow.yMin;U.size=j(b,F),U.lines=Q+U.scanlineBlockSize>U.height?U.height-Q:U.scanlineBlockSize;const z=U.size<U.lines*U.bytesPerLine&&U.uncompress?U.uncompress(U):UU(U);F.value+=U.size;for(let b=0;b<U.scanlineBlockSize;b++){const F=w*U.scanlineBlockSize,Q=b+U.scanOrder(F);if(Q>=U.height)continue;const q=b*U.bytesPerLine,p=(U.height-1-Q)*U.outLineWidth;for(let b=0;b<U.channels;b++){const F=X.channels[b].name,w=U.channelLineOffsets[F],Q=U.decodeChannels[F];if(void 0!==Q){E.value=q+w;for(let X=0;X<U.width;X++){const b=p+X*U.outputChannels+Q;U.byteArray&&(U.byteArray[b]=U.getter(z,E))}}}}}}zU.DefaultOutputType=wU.HalfFloat,zU.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class SU{constructor(){this.supportCascades=!1}loadCubeData(U,X,b,F,E){throw".exr not supported in Cube."}loadData(U,X,b){const E=new DataView(U.buffer),w={value:0},Q=t(E,w);qU(Q,E,w,zU.DefaultOutputType).then((U=>{pU(U,Q,E,w);const F=Q.dataWindow.xMax-Q.dataWindow.xMin+1,z=Q.dataWindow.yMax-Q.dataWindow.yMin+1;b(F,z,X.generateMipMaps,!1,(()=>{const b=X.getEngine();X.format=Q.format,X.type=U.textureType,X.invertY=!1,X._gammaSpace=!Q.linearSpace,U.byteArray&&b._uploadDataToTextureDirectly(X,U.byteArray,0,0,void 0,!0)}))})).catch((U=>{F.e.Error("Failed to load EXR texture: ",U)}))}}async function RU(U){const X=new DataView(U),b={value:0},E=t(X,b);try{const U=await qU(E,X,b,wU.Float);return pU(U,E,X,b),U.byteArray?{width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,data:new Float32Array(U.byteArray)}:(F.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(w){F.e.Error("Failed to load EXR data: ",w)}return{width:0,height:0,data:null}}},11608:(U,X,b)=>{function F(U){return parseInt(U.toString().replace(/\W/g,""))}function E(U,X){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(U-X)<=b}function w(U,X,b){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return U<X-F||U>b+F}function Q(U,X){return U===X?U:Math.random()*(X-U)+U}function z(U,X,b){return U+(X-U)*b}function q(U,X,b){let F=x(X-U,360);return F>180&&(F-=360),U+F*n(b)}function p(U,X,b){let F=0;return F=U!=X?n((b-U)/(X-U)):0,F}function S(U,X,b,F,E){const w=E*E,Q=E*w;return U*(2*Q-3*w+1)+b*(-2*Q+3*w)+X*(Q-2*w+E)+F*(Q-w)}function R(U,X,b,F,E){const w=E*E;return 6*(w-E)*U+(3*w-4*E+1)*X+6*(-w+E)*b+(3*w-2*E)*F}function n(U){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(X,U))}function a(U){return U-=2*Math.PI*Math.floor((U+Math.PI)/(2*Math.PI))}function J(U){const X=U.toString(16);return U<=15?("0"+X).toUpperCase():X.toUpperCase()}function m(U){if(Math.log2)return Math.floor(Math.log2(U));if(U<0)return NaN;if(0===U)return-1/0;let X=0;if(U<1){for(;U<1;)X++,U*=2;X=-X}else if(U>1)for(;U>1;)X++,U=Math.floor(U/2);return X}function x(U,X){return U-Math.floor(U/X)*X}function I(U,X,b){return(U-X)/(b-X)}function O(U,X,b){return U*(b-X)+X}function N(U,X){let b=x(X-U,360);return b>180&&(b-=360),b}function u(U,X){const b=x(U,2*X);return X-Math.abs(b-X)}function i(U,X,b){let F=n(b);return F=-2*F*F*F+3*F*F,X*F+U*(1-F)}function P(U,X,b){let F=0;return F=Math.abs(X-U)<=b?X:U+Math.sign(X-U)*b,F}function f(U,X,b){const F=N(U,X);let E=0;return E=-b<F&&F<b?X:P(U,X=U+F,b),E}function j(U,X,b){return(U-X)/(b-X)}function e(U,X,b){return(b-X)*U+X}function l(U,X){const b=U%X;return 0===b?X:l(X,b)}b.r(X),b.d(X,{Clamp:()=>n,DeltaAngle:()=>N,Denormalize:()=>O,ExtractAsInt:()=>F,Hermite:()=>S,Hermite1stDerivative:()=>R,HighestCommonFactor:()=>l,ILog2:()=>m,InverseLerp:()=>p,Lerp:()=>z,LerpAngle:()=>q,MoveTowards:()=>P,MoveTowardsAngle:()=>f,Normalize:()=>I,NormalizeRadians:()=>a,OutsideRange:()=>w,PercentToRange:()=>e,PingPong:()=>u,RandomRange:()=>Q,RangeToPercent:()=>j,Repeat:()=>x,SmoothStep:()=>i,ToHex:()=>J,WithinEpsilon:()=>E})}}]);