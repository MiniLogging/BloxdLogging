"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[16],{14936:(u,R,I)=>{I.r(R),I.d(R,{ReadExrDataAsync:()=>Su,_ExrTextureLoader:()=>Gu});var B=I(12315),U=I(12491);const K=4,C=4,D=1,s=2,t=8,G=65536,S=G>>3,b=14,r=65537,P=1<<b,X=P-1,E=59,z=63,f=2+z-E;var T,Q;!function(u){u[u.NO_COMPRESSION=0]="NO_COMPRESSION",u[u.RLE_COMPRESSION=1]="RLE_COMPRESSION",u[u.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",u[u.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",u[u.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",u[u.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(u){u[u.INCREASING_Y=0]="INCREASING_Y",u[u.DECREASING_Y=1]="DECREASING_Y"}(Q||(Q={}));const V=function(){const u=new ArrayBuffer(4),R=new Float32Array(u),I=new Uint32Array(u),B=new Uint32Array(512),U=new Uint32Array(512);for(let s=0;s<256;++s){const u=s-127;u<-27?(B[s]=0,B[256|s]=32768,U[s]=24,U[256|s]=24):u<-14?(B[s]=1024>>-u-14,B[256|s]=1024>>-u-14|32768,U[s]=-u-1,U[256|s]=-u-1):u<=15?(B[s]=u+15<<10,B[256|s]=u+15<<10|32768,U[s]=13,U[256|s]=13):u<128?(B[s]=31744,B[256|s]=64512,U[s]=24,U[256|s]=24):(B[s]=31744,B[256|s]=64512,U[s]=13,U[256|s]=13)}const K=new Uint32Array(2048),C=new Uint32Array(64),D=new Uint32Array(64);for(let s=1;s<1024;++s){let u=s<<13,R=0;for(;0===(8388608&u);)u<<=1,R-=8388608;u&=-8388609,R+=947912704,K[s]=u|R}for(let s=1024;s<2048;++s)K[s]=939524096+(s-1024<<13);for(let s=1;s<31;++s)C[s]=s<<23;C[31]=1199570944,C[32]=2147483648;for(let s=33;s<63;++s)C[s]=2147483648+(s-32<<23);C[63]=3347054592;for(let s=1;s<64;++s)32!==s&&(D[s]=1024);return{floatView:R,uint32View:I,baseTable:B,shiftTable:U,mantissaTable:K,exponentTable:C,offsetTable:D}}();function q(u,R){const I=new Uint8Array(u);let B=0;for(;0!=I[R.value+B];)B+=1;const U=(new TextDecoder).decode(I.slice(R.value,R.value+B));return R.value=R.value+B+1,U}function e(u,R){const I=u.getInt32(R.value,!0);return R.value+=K,I}function Y(u,R){const I=u.getUint32(R.value,!0);return R.value+=K,I}function M(u,R){const I=u.getUint8(R.value);return R.value+=D,I}function o(u,R){const I=u.getUint16(R.value,!0);return R.value+=s,I}function j(u,R){const I=u[R.value];return R.value+=D,I}function h(u,R){let I;return I="getBigInt64"in DataView.prototype?Number(u.getBigInt64(R.value,!0)):u.getUint32(R.value+4,!0)+Number(u.getUint32(R.value,!0)<<32),R.value+=t,I}function x(u,R){const I=u.getFloat32(R.value,!0);return R.value+=C,I}function g(u,R){return function(u){const R=(31744&u)>>10,I=1023&u;return(u>>15?-1:1)*(R?31===R?I?NaN:1/0:Math.pow(2,R-15)*(1+I/1024):I/1024*6103515625e-14)}(o(u,R))}function v(u,R){return function(u){if(Math.abs(u)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");u=(0,U.Clamp)(u,-65504,65504),V.floatView[0]=u;const R=V.uint32View[0],I=R>>23&511;return V.baseTable[I]+((8388607&R)>>V.shiftTable[I])}(x(u,R))}function p(u,R,I,B){switch(I){case"string":case"stringvector":case"iccProfile":return function(u,R,I){const B=(new TextDecoder).decode(new Uint8Array(u).slice(R.value,R.value+I));return R.value=R.value+I,B}(u.buffer,R,B);case"chlist":return function(u,R,I){const B=R.value,U=[];for(;R.value<B+I-1;){const I=q(u.buffer,R),B=e(u,R),K=M(u,R);R.value+=3;const C=e(u,R),D=e(u,R);U.push({name:I,pixelType:B,pLinear:K,xSampling:C,ySampling:D})}return R.value+=1,U}(u,R,B);case"chromaticities":return function(u,R){return{redX:x(u,R),redY:x(u,R),greenX:x(u,R),greenY:x(u,R),blueX:x(u,R),blueY:x(u,R),whiteX:x(u,R),whiteY:x(u,R)}}(u,R);case"compression":return function(u,R){return M(u,R)}(u,R);case"box2i":return function(u,R){return{xMin:e(u,R),yMin:e(u,R),xMax:e(u,R),yMax:e(u,R)}}(u,R);case"lineOrder":return function(u,R){const I=M(u,R);return Q[I]}(u,R);case"float":return x(u,R);case"v2f":return function(u,R){return[x(u,R),x(u,R)]}(u,R);case"v3f":return function(u,R){return[x(u,R),x(u,R),x(u,R)]}(u,R);case"int":return e(u,R);case"rational":return function(u,R){return[e(u,R),Y(u,R)]}(u,R);case"timecode":return function(u,R){return[Y(u,R),Y(u,R)]}(u,R);case"preview":return R.value+=B,"skipped";default:return void(R.value+=B)}}function l(u){for(let R=1;R<u.length;R++){const I=u[R-1]+u[R]-128;u[R]=I}}function Z(u,R){let I=0,B=Math.floor((u.length+1)/2),U=0;const K=u.length-1;for(;!(U>K)&&(R[U++]=u[I++],!(U>K));)R[U++]=u[B++]}const c=20000630;function k(u,R){if(u.getUint32(0,!0)!=c)throw new Error("Incorrect OpenEXR format");const I=u.getUint8(4),U=u.getUint8(5),K={singleTile:!!(2&U),longName:!!(4&U),deepFormat:!!(8&U),multiPart:!!(16&U)};R.value=8;const C={};let D=!0;for(;D;){const I=q(u.buffer,R);if(I){const U=q(u.buffer,R),K=p(u,R,U,Y(u,R));void 0===K?B.b.Warn(`Unknown header attribute type ${U}'.`):C[I]=K}else D=!1}if(0!=(-5&U))throw new Error("Unsupported file format");return{version:I,spec:K,...C}}const w=32768,i=65535;function W(u,R,I,B,U){for(;I<u;)R=R<<8|j(B,U),I+=8;return{l:R>>(I-=u)&(1<<u)-1,c:R,lc:I}}function a(u,R,I,B){return{c:u=u<<8|j(I,B),lc:R+=8}}function A(u,R,I,B,U,K,C,D,s){if(u==R){if(B<8){const u=a(I,B,U,K);I=u.c,B=u.lc}let u=I>>(B-=8);if(u=new Uint8Array([u])[0],D.value+u>s)return null;const R=C[D.value-1];for(;u-- >0;)C[D.value++]=R}else{if(!(D.value<s))return null;C[D.value++]=u}return{c:I,lc:B}}const O=new Array(59);function N(u,R,I,B,U,K){const C=R;let D=0,s=0;for(;B<=U;B++){if(C.value-R.value>I)return;let t=W(6,D,s,u,C);const G=t.l;if(D=t.c,s=t.lc,K[B]=G,G==z){if(C.value-R.value>I)throw new Error("Error in HufUnpackEncTable");t=W(8,D,s,u,C);let G=t.l+f;if(D=t.c,s=t.lc,B+G>U+1)throw new Error("Error in HufUnpackEncTable");for(;G--;)K[B++]=0;B--}else if(G>=E){let u=G-E+2;if(B+u>U+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)K[B++]=0;B--}}!function(u){for(let I=0;I<=58;++I)O[I]=0;for(let I=0;I<r;++I)O[u[I]]+=1;let R=0;for(let I=58;I>0;--I){const u=R+O[I]>>1;O[I]=R,R=u}for(let I=0;I<r;++I){const R=u[I];R>0&&(u[I]=R|O[R]++<<6)}}(K)}function J(u){return 63&u}function mu(u){return u>>6}function L(u,R,I,B,U,K){const C=I.value,D=Y(R,I),s=Y(R,I);I.value+=4;const t=Y(R,I);if(I.value+=4,D<0||D>=r||s<0||s>=r)throw new Error("Wrong HUF_ENCSIZE");const G=new Array(r),S=new Array(P);!function(u){for(let R=0;R<P;R++)u[R]={},u[R].len=0,u[R].lit=0,u[R].p=null}(S);if(N(u,I,B-(I.value-C),D,s,G),t>8*(B-(I.value-C)))throw new Error("Wrong hufUncompress");!function(u,R,I,B){for(;R<=I;R++){const I=mu(u[R]),U=J(u[R]);if(I>>U)throw new Error("Invalid table entry");if(U>b){const u=B[I>>U-b];if(u.len)throw new Error("Invalid table entry");if(u.lit++,u.p){const R=u.p;u.p=new Array(u.lit);for(let I=0;I<u.lit-1;++I)u.p[I]=R[I]}else u.p=new Array(1);u.p[u.lit-1]=R}else if(U){let u=0;for(let K=1<<b-U;K>0;K--){const K=B[(I<<b-U)+u];if(K.len||K.p)throw new Error("Invalid table entry");K.len=U,K.lit=R,u++}}}}(G,D,s,S),function(u,R,I,B,U,K,C,D,s){let t=0,G=0;const S=C,r=Math.trunc(B.value+(U+7)/8);for(;B.value<r;){let U=a(t,G,I,B);for(t=U.c,G=U.lc;G>=b;){const C=R[t>>G-b&X];if(C.len){G-=C.len;const u=A(C.lit,K,t,G,I,B,D,s,S);u&&(t=u.c,G=u.lc)}else{if(!C.p)throw new Error("hufDecode issues");let R;for(R=0;R<C.lit;R++){const b=J(u[C.p[R]]);for(;G<b&&B.value<r;)U=a(t,G,I,B),t=U.c,G=U.lc;if(G>=b&&mu(u[C.p[R]])==(t>>G-b&(1<<b)-1)){G-=b;const u=A(C.p[R],K,t,G,I,B,D,s,S);u&&(t=u.c,G=u.lc);break}}if(R==C.lit)throw new Error("HufDecode issues")}}}const P=8-U&7;for(t>>=P,G-=P;G>0;){const u=R[t<<b-G&X];if(!u.len)throw new Error("HufDecode issues");{G-=u.len;const R=A(u.lit,K,t,G,I,B,D,s,S);R&&(t=R.c,G=R.lc)}}}(G,S,u,I,t,s,K,U,{value:0})}function H(u){return 65535&u}function y(u){const R=H(u);return R>32767?R-65536:R}function F(u,R){const I=y(u),B=y(R),U=I+(1&B)+(B>>1);return{a:U,b:U-B}}function n(u,R){const I=H(u),B=H(R),U=I-(B>>1)&i;return{a:B+U-w&i,b:U}}function d(u,R,I,B,U,K,C){const D=C<16384,s=I>U?U:I;let t,G,S=1;for(;S<=s;)S<<=1;for(S>>=1,t=S,S>>=1;S>=1;){G=0;const C=G+K*(U-t),s=K*S,b=K*t,r=B*S,P=B*t;let X,E,z,f;for(;G<=C;G+=b){let U=G;const K=G+B*(I-t);for(;U<=K;U+=P){const I=U+r,B=U+s,K=B+r;if(D){let C=F(u[U+R],u[B+R]);X=C.a,z=C.b,C=F(u[I+R],u[K+R]),E=C.a,f=C.b,C=F(X,E),u[U+R]=C.a,u[I+R]=C.b,C=F(z,f),u[B+R]=C.a,u[K+R]=C.b}else{let C=n(u[U+R],u[B+R]);X=C.a,z=C.b,C=n(u[I+R],u[K+R]),E=C.a,f=C.b,C=n(X,E),u[U+R]=C.a,u[I+R]=C.b,C=n(z,f),u[B+R]=C.a,u[K+R]=C.b}}if(I&S){const I=U+s;let B;B=D?F(u[U+R],u[I+R]):n(u[U+R],u[I+R]),X=B.a,u[I+R]=B.b,u[U+R]=X}}if(U&S){let U=G;const K=G+B*(I-t);for(;U<=K;U+=P){const I=U+r;let B;B=D?F(u[U+R],u[I+R]):n(u[U+R],u[I+R]),X=B.a,u[I+R]=B.b,u[U+R]=X}}t=S,S>>=1}return G}function uu(u){return new DataView(u.array.buffer,u.offset.value,u.size)}function Ru(u){const R=u.viewer.buffer.slice(u.offset.value,u.offset.value+u.size),I=new Uint8Array(function(u){let R=u.byteLength;const I=[];let B=0;const U=new DataView(u);for(;R>0;){const u=U.getInt8(B++);if(u<0){const K=-u;R-=K+1;for(let u=0;u<K;u++)I.push(U.getUint8(B++))}else{const K=u;R-=2;const C=U.getUint8(B++);for(let u=0;u<K+1;u++)I.push(C)}}return I}(R)),B=new Uint8Array(I.length);return l(I),Z(I,B),new DataView(B.buffer)}function Iu(u){const R=u.array.slice(u.offset.value,u.offset.value+u.size),I=fflate.unzlibSync(R),B=new Uint8Array(I.length);return l(I),Z(I,B),new DataView(B.buffer)}function Bu(u){const R=u.array.slice(u.offset.value,u.offset.value+u.size),I=fflate.unzlibSync(R),B=u.lines*u.channels*u.width,U=1==u.type?new Uint16Array(B):new Uint32Array(B);let K=0,C=0;const D=new Array(4);for(let s=0;s<u.lines;s++)for(let R=0;R<u.channels;R++){let R=0;switch(u.type){case 1:D[0]=K,D[1]=D[0]+u.width,K=D[1]+u.width;for(let B=0;B<u.width;++B){R+=I[D[0]++]<<8|I[D[1]++],U[C]=R,C++}break;case 2:D[0]=K,D[1]=D[0]+u.width,D[2]=D[1]+u.width,K=D[2]+u.width;for(let B=0;B<u.width;++B){R+=I[D[0]++]<<24|I[D[1]++]<<16|I[D[2]++]<<8,U[C]=R,C++}}}return new DataView(U.buffer)}function Uu(u){const R=u.viewer,I={value:u.offset.value},B=new Uint16Array(u.width*u.scanlineBlockSize*(u.channels*u.type)),U=new Uint8Array(S);let K=0;const C=new Array(u.channels);for(let s=0;s<u.channels;s++)C[s]={},C[s].start=K,C[s].end=C[s].start,C[s].nx=u.width,C[s].ny=u.lines,C[s].size=u.type,K+=C[s].nx*C[s].ny*C[s].size;const D=o(R,I),t=o(R,I);if(t>=S)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(D<=t)for(let s=0;s<t-D+1;s++)U[s+D]=M(R,I);const b=new Uint16Array(G),r=function(u,R){let I=0;for(let U=0;U<G;++U)(0==U||u[U>>3]&1<<(7&U))&&(R[I++]=U);const B=I-1;for(;I<G;)R[I++]=0;return B}(U,b),P=Y(R,I);L(u.array,R,I,P,B,K);for(let s=0;s<u.channels;++s){const u=C[s];for(let R=0;R<C[s].size;++R)d(B,u.start+R,u.nx,u.size,u.ny,u.nx*u.size,r)}!function(u,R,I){for(let B=0;B<I;++B)R[B]=u[R[B]]}(b,B,K);let X=0;const E=new Uint8Array(B.buffer.byteLength);for(let G=0;G<u.lines;G++)for(let R=0;R<u.channels;R++){const u=C[R],I=u.nx*u.size,U=new Uint8Array(B.buffer,u.end*s,I*s);E.set(U,X),X+=I*s,u.end+=I}return new DataView(E.buffer)}var Ku,Cu=I(12294);!function(u){u[u.Float=0]="Float",u[u.HalfFloat=1]="HalfFloat"}(Ku||(Ku={}));class Du{}async function su(u,R,I,B){const U={size:0,viewer:R,array:new Uint8Array(R.buffer),offset:I,width:u.dataWindow.xMax-u.dataWindow.xMin+1,height:u.dataWindow.yMax-u.dataWindow.yMin+1,channels:u.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(u.compression){case T.NO_COMPRESSION:U.lines=1,U.uncompress=uu;break;case T.RLE_COMPRESSION:U.lines=1,U.uncompress=Ru;break;case T.ZIPS_COMPRESSION:U.lines=1,U.uncompress=Iu,await Cu.Tools.LoadScriptAsync(Du.FFLATEUrl);break;case T.ZIP_COMPRESSION:U.lines=16,U.uncompress=Iu,await Cu.Tools.LoadScriptAsync(Du.FFLATEUrl);break;case T.PIZ_COMPRESSION:U.lines=32,U.uncompress=Uu;break;case T.PXR24_COMPRESSION:U.lines=16,U.uncompress=Bu,await Cu.Tools.LoadScriptAsync(Du.FFLATEUrl);break;default:throw new Error(T[u.compression]+" is unsupported")}U.scanlineBlockSize=U.lines;const K={};for(const C of u.channels)switch(C.name){case"R":case"G":case"B":case"A":case"Y":K[C.name]=!0,U.type=C.pixelType}let D=!1;if(K.R&&K.G&&K.B&&K.A)U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(K.R&&K.G&&K.B)D=!0,U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(K.R&&K.G)U.outputChannels=2,U.decodeChannels={R:0,G:1};else if(K.R)U.outputChannels=1,U.decodeChannels={R:0};else{if(!K.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");U.outputChannels=1,U.decodeChannels={Y:0}}if(1===U.type)switch(B){case Ku.Float:U.getter=g,U.inputSize=s;break;case Ku.HalfFloat:U.getter=o,U.inputSize=s}else{if(2!==U.type)throw new Error("Unsupported pixelType "+U.type+" for "+u.compression);switch(B){case Ku.Float:U.getter=x,U.inputSize=C;break;case Ku.HalfFloat:U.getter=v,U.inputSize=C}}U.blockCount=U.height/U.scanlineBlockSize;for(let C=0;C<U.blockCount;C++)h(R,I);const t=U.width*U.height*U.outputChannels;switch(B){case Ku.Float:U.byteArray=new Float32Array(t),U.textureType=1,D&&U.byteArray.fill(1,0,t);break;case Ku.HalfFloat:U.byteArray=new Uint16Array(t),U.textureType=2,D&&U.byteArray.fill(15360,0,t);break;default:throw new Error("Unsupported type: "+B)}let G=0;for(const C of u.channels)void 0!==U.decodeChannels[C.name]&&(U.channelLineOffsets[C.name]=G*U.width),G+=2*C.pixelType;return U.bytesPerLine=U.width*G,U.outLineWidth=U.width*U.outputChannels,"INCREASING_Y"===u.lineOrder?U.scanOrder=u=>u:U.scanOrder=u=>U.height-1-u,4==U.outputChannels?(U.format=5,U.linearSpace=!0):(U.format=6,U.linearSpace=!1),U}function tu(u,R,I,B){const U={value:0};for(let K=0;K<u.height/u.scanlineBlockSize;K++){const C=e(I,B)-R.dataWindow.yMin;u.size=Y(I,B),u.lines=C+u.scanlineBlockSize>u.height?u.height-C:u.scanlineBlockSize;const D=u.size<u.lines*u.bytesPerLine&&u.uncompress?u.uncompress(u):uu(u);B.value+=u.size;for(let I=0;I<u.scanlineBlockSize;I++){const B=K*u.scanlineBlockSize,C=I+u.scanOrder(B);if(C>=u.height)continue;const s=I*u.bytesPerLine,t=(u.height-1-C)*u.outLineWidth;for(let I=0;I<u.channels;I++){const B=R.channels[I].name,K=u.channelLineOffsets[B],C=u.decodeChannels[B];if(void 0!==C){U.value=s+K;for(let R=0;R<u.width;R++){const I=t+R*u.outputChannels+C;u.byteArray&&(u.byteArray[I]=u.getter(D,U))}}}}}}Du.DefaultOutputType=Ku.HalfFloat,Du.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Gu{constructor(){this.supportCascades=!1}loadCubeData(u,R,I,B,U){throw".exr not supported in Cube."}loadData(u,R,I){const U=new DataView(u.buffer),K={value:0},C=k(U,K);su(C,U,K,Du.DefaultOutputType).then((u=>{tu(u,C,U,K);const B=C.dataWindow.xMax-C.dataWindow.xMin+1,D=C.dataWindow.yMax-C.dataWindow.yMin+1;I(B,D,R.generateMipMaps,!1,(()=>{const I=R.getEngine();R.format=C.format,R.type=u.textureType,R.invertY=!1,R._gammaSpace=!C.linearSpace,u.byteArray&&I._uploadDataToTextureDirectly(R,u.byteArray,0,0,void 0,!0)}))})).catch((u=>{B.b.Error("Failed to load EXR texture: ",u)}))}}async function Su(u){const R=new DataView(u),I={value:0},U=k(R,I);try{const u=await su(U,R,I,Ku.Float);return tu(u,U,R,I),u.byteArray?{width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,data:new Float32Array(u.byteArray)}:(B.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(K){B.b.Error("Failed to load EXR data: ",K)}return{width:0,height:0,data:null}}},12491:(u,R,I)=>{function B(u){return parseInt(u.toString().replace(/\W/g,""))}function U(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(u-R)<=I}function K(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return u<R-B||u>I+B}function C(u,R){return u===R?u:Math.random()*(R-u)+u}function D(u,R,I){return u+(R-u)*I}function s(u,R,I){let B=E(R-u,360);return B>180&&(B-=360),u+B*b(I)}function t(u,R,I){let B=0;return B=u!=R?b((I-u)/(R-u)):0,B}function G(u,R,I,B,U){const K=U*U,C=U*K;return u*(2*C-3*K+1)+I*(-2*C+3*K)+R*(C-2*K+U)+B*(C-K)}function S(u,R,I,B,U){const K=U*U;return 6*(K-U)*u+(3*K-4*U+1)*R+6*(-K+U)*I+(3*K-2*U)*B}function b(u){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(I,Math.max(R,u))}function r(u){return u-=2*Math.PI*Math.floor((u+Math.PI)/(2*Math.PI))}function P(u){const R=u.toString(16);return u<=15?("0"+R).toUpperCase():R.toUpperCase()}function X(u){if(Math.log2)return Math.floor(Math.log2(u));if(u<0)return NaN;if(0===u)return-1/0;let R=0;if(u<1){for(;u<1;)R++,u*=2;R=-R}else if(u>1)for(;u>1;)R++,u=Math.floor(u/2);return R}function E(u,R){return u-Math.floor(u/R)*R}function z(u,R,I){return(u-R)/(I-R)}function f(u,R,I){return u*(I-R)+R}function T(u,R){let I=E(R-u,360);return I>180&&(I-=360),I}function Q(u,R){const I=E(u,2*R);return R-Math.abs(I-R)}function V(u,R,I){let B=b(I);return B=-2*B*B*B+3*B*B,R*B+u*(1-B)}function q(u,R,I){let B=0;return B=Math.abs(R-u)<=I?R:u+Math.sign(R-u)*I,B}function e(u,R,I){const B=T(u,R);let U=0;return U=-I<B&&B<I?R:q(u,R=u+B,I),U}function Y(u,R,I){return(u-R)/(I-R)}function M(u,R,I){return(I-R)*u+R}function o(u,R){const I=u%R;return 0===I?R:o(R,I)}I.r(R),I.d(R,{Clamp:()=>b,DeltaAngle:()=>T,Denormalize:()=>f,ExtractAsInt:()=>B,Hermite:()=>G,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>o,ILog2:()=>X,InverseLerp:()=>t,Lerp:()=>D,LerpAngle:()=>s,MoveTowards:()=>q,MoveTowardsAngle:()=>e,Normalize:()=>z,NormalizeRadians:()=>r,OutsideRange:()=>K,PercentToRange:()=>M,PingPong:()=>Q,RandomRange:()=>C,RangeToPercent:()=>Y,Repeat:()=>E,SmoothStep:()=>V,ToHex:()=>P,WithinEpsilon:()=>U})}}]);