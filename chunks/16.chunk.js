"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[16],{15359:(I,x,L)=>{L.r(x),L.d(x,{ReadExrDataAsync:()=>QI,_ExrTextureLoader:()=>WI});var F=L(12809),X=L(13001);const G=4,Y=4,p=1,B=2,l=8,W=65536,Q=W>>3,e=14,g=65537,v=1<<e,z=v-1,H=59,s=63,U=2+s-H;var q,y;!function(I){I[I.NO_COMPRESSION=0]="NO_COMPRESSION",I[I.RLE_COMPRESSION=1]="RLE_COMPRESSION",I[I.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",I[I.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",I[I.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",I[I.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(q||(q={})),function(I){I[I.INCREASING_Y=0]="INCREASING_Y",I[I.DECREASING_Y=1]="DECREASING_Y"}(y||(y={}));const T=function(){const I=new ArrayBuffer(4),x=new Float32Array(I),L=new Uint32Array(I),F=new Uint32Array(512),X=new Uint32Array(512);for(let B=0;B<256;++B){const I=B-127;I<-27?(F[B]=0,F[256|B]=32768,X[B]=24,X[256|B]=24):I<-14?(F[B]=1024>>-I-14,F[256|B]=1024>>-I-14|32768,X[B]=-I-1,X[256|B]=-I-1):I<=15?(F[B]=I+15<<10,F[256|B]=I+15<<10|32768,X[B]=13,X[256|B]=13):I<128?(F[B]=31744,F[256|B]=64512,X[B]=24,X[256|B]=24):(F[B]=31744,F[256|B]=64512,X[B]=13,X[256|B]=13)}const G=new Uint32Array(2048),Y=new Uint32Array(64),p=new Uint32Array(64);for(let B=1;B<1024;++B){let I=B<<13,x=0;for(;0===(8388608&I);)I<<=1,x-=8388608;I&=-8388609,x+=947912704,G[B]=I|x}for(let B=1024;B<2048;++B)G[B]=939524096+(B-1024<<13);for(let B=1;B<31;++B)Y[B]=B<<23;Y[31]=1199570944,Y[32]=2147483648;for(let B=33;B<63;++B)Y[B]=2147483648+(B-32<<23);Y[63]=3347054592;for(let B=1;B<64;++B)32!==B&&(p[B]=1024);return{floatView:x,uint32View:L,baseTable:F,shiftTable:X,mantissaTable:G,exponentTable:Y,offsetTable:p}}();function Z(I,x){const L=new Uint8Array(I);let F=0;for(;0!=L[x.value+F];)F+=1;const X=(new TextDecoder).decode(L.slice(x.value,x.value+F));return x.value=x.value+F+1,X}function t(I,x){const L=I.getInt32(x.value,!0);return x.value+=G,L}function f(I,x){const L=I.getUint32(x.value,!0);return x.value+=G,L}function R(I,x){const L=I.getUint8(x.value);return x.value+=p,L}function n(I,x){const L=I.getUint16(x.value,!0);return x.value+=B,L}function P(I,x){const L=I[x.value];return x.value+=p,L}function d(I,x){let L;return L="getBigInt64"in DataView.prototype?Number(I.getBigInt64(x.value,!0)):I.getUint32(x.value+4,!0)+Number(I.getUint32(x.value,!0)<<32),x.value+=l,L}function M(I,x){const L=I.getFloat32(x.value,!0);return x.value+=Y,L}function K(I,x){return function(I){const x=(31744&I)>>10,L=1023&I;return(I>>15?-1:1)*(x?31===x?L?NaN:1/0:Math.pow(2,x-15)*(1+L/1024):L/1024*6103515625e-14)}(n(I,x))}function u(I,x){return function(I){if(Math.abs(I)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");I=(0,X.Clamp)(I,-65504,65504),T.floatView[0]=I;const x=T.uint32View[0],L=x>>23&511;return T.baseTable[L]+((8388607&x)>>T.shiftTable[L])}(M(I,x))}function A(I,x,L,F){switch(L){case"string":case"stringvector":case"iccProfile":return function(I,x,L){const F=(new TextDecoder).decode(new Uint8Array(I).slice(x.value,x.value+L));return x.value=x.value+L,F}(I.buffer,x,F);case"chlist":return function(I,x,L){const F=x.value,X=[];for(;x.value<F+L-1;){const L=Z(I.buffer,x),F=t(I,x),G=R(I,x);x.value+=3;const Y=t(I,x),p=t(I,x);X.push({name:L,pixelType:F,pLinear:G,xSampling:Y,ySampling:p})}return x.value+=1,X}(I,x,F);case"chromaticities":return function(I,x){return{redX:M(I,x),redY:M(I,x),greenX:M(I,x),greenY:M(I,x),blueX:M(I,x),blueY:M(I,x),whiteX:M(I,x),whiteY:M(I,x)}}(I,x);case"compression":return function(I,x){return R(I,x)}(I,x);case"box2i":return function(I,x){return{xMin:t(I,x),yMin:t(I,x),xMax:t(I,x),yMax:t(I,x)}}(I,x);case"lineOrder":return function(I,x){const L=R(I,x);return y[L]}(I,x);case"float":return M(I,x);case"v2f":return function(I,x){return[M(I,x),M(I,x)]}(I,x);case"v3f":return function(I,x){return[M(I,x),M(I,x),M(I,x)]}(I,x);case"int":return t(I,x);case"rational":return function(I,x){return[t(I,x),f(I,x)]}(I,x);case"timecode":return function(I,x){return[f(I,x),f(I,x)]}(I,x);case"preview":return x.value+=F,"skipped";default:return void(x.value+=F)}}function mI(I){for(let x=1;x<I.length;x++){const L=I[x-1]+I[x]-128;I[x]=L}}function O(I,x){let L=0,F=Math.floor((I.length+1)/2),X=0;const G=I.length-1;for(;!(X>G)&&(x[X++]=I[L++],!(X>G));)x[X++]=I[F++]}const w=20000630;function k(I,x){if(I.getUint32(0,!0)!=w)throw new Error("Incorrect OpenEXR format");const L=I.getUint8(4),X=I.getUint8(5),G={singleTile:!!(2&X),longName:!!(4&X),deepFormat:!!(8&X),multiPart:!!(16&X)};x.value=8;const Y={};let p=!0;for(;p;){const L=Z(I.buffer,x);if(L){const X=Z(I.buffer,x),G=A(I,x,X,f(I,x));void 0===G?F.c.Warn(`Unknown header attribute type ${X}'.`):Y[L]=G}else p=!1}if(0!=(-5&X))throw new Error("Unsupported file format");return{version:L,spec:G,...Y}}const a=32768,D=65535;function r(I,x,L,F,X){for(;L<I;)x=x<<8|P(F,X),L+=8;return{l:x>>(L-=I)&(1<<I)-1,c:x,lc:L}}function N(I,x,L,F){return{c:I=I<<8|P(L,F),lc:x+=8}}function S(I,x,L,F,X,G,Y,p,B){if(I==x){if(F<8){const I=N(L,F,X,G);L=I.c,F=I.lc}let I=L>>(F-=8);if(I=new Uint8Array([I])[0],p.value+I>B)return null;const x=Y[p.value-1];for(;I-- >0;)Y[p.value++]=x}else{if(!(p.value<B))return null;Y[p.value++]=I}return{c:L,lc:F}}const c=new Array(59);function o(I,x,L,F,X,G){const Y=x;let p=0,B=0;for(;F<=X;F++){if(Y.value-x.value>L)return;let l=r(6,p,B,I,Y);const W=l.l;if(p=l.c,B=l.lc,G[F]=W,W==s){if(Y.value-x.value>L)throw new Error("Error in HufUnpackEncTable");l=r(8,p,B,I,Y);let W=l.l+U;if(p=l.c,B=l.lc,F+W>X+1)throw new Error("Error in HufUnpackEncTable");for(;W--;)G[F++]=0;F--}else if(W>=H){let I=W-H+2;if(F+I>X+1)throw new Error("Error in HufUnpackEncTable");for(;I--;)G[F++]=0;F--}}!function(I){for(let L=0;L<=58;++L)c[L]=0;for(let L=0;L<g;++L)c[I[L]]+=1;let x=0;for(let L=58;L>0;--L){const I=x+c[L]>>1;c[L]=x,x=I}for(let L=0;L<g;++L){const x=I[L];x>0&&(I[L]=x|c[x]++<<6)}}(G)}function J(I){return 63&I}function h(I){return I>>6}function E(I,x,L,F,X,G){const Y=L.value,p=f(x,L),B=f(x,L);L.value+=4;const l=f(x,L);if(L.value+=4,p<0||p>=g||B<0||B>=g)throw new Error("Wrong HUF_ENCSIZE");const W=new Array(g),Q=new Array(v);!function(I){for(let x=0;x<v;x++)I[x]={},I[x].len=0,I[x].lit=0,I[x].p=null}(Q);if(o(I,L,F-(L.value-Y),p,B,W),l>8*(F-(L.value-Y)))throw new Error("Wrong hufUncompress");!function(I,x,L,F){for(;x<=L;x++){const L=h(I[x]),X=J(I[x]);if(L>>X)throw new Error("Invalid table entry");if(X>e){const I=F[L>>X-e];if(I.len)throw new Error("Invalid table entry");if(I.lit++,I.p){const x=I.p;I.p=new Array(I.lit);for(let L=0;L<I.lit-1;++L)I.p[L]=x[L]}else I.p=new Array(1);I.p[I.lit-1]=x}else if(X){let I=0;for(let G=1<<e-X;G>0;G--){const G=F[(L<<e-X)+I];if(G.len||G.p)throw new Error("Invalid table entry");G.len=X,G.lit=x,I++}}}}(W,p,B,Q),function(I,x,L,F,X,G,Y,p,B){let l=0,W=0;const Q=Y,g=Math.trunc(F.value+(X+7)/8);for(;F.value<g;){let X=N(l,W,L,F);for(l=X.c,W=X.lc;W>=e;){const Y=x[l>>W-e&z];if(Y.len){W-=Y.len;const I=S(Y.lit,G,l,W,L,F,p,B,Q);I&&(l=I.c,W=I.lc)}else{if(!Y.p)throw new Error("hufDecode issues");let x;for(x=0;x<Y.lit;x++){const e=J(I[Y.p[x]]);for(;W<e&&F.value<g;)X=N(l,W,L,F),l=X.c,W=X.lc;if(W>=e&&h(I[Y.p[x]])==(l>>W-e&(1<<e)-1)){W-=e;const I=S(Y.p[x],G,l,W,L,F,p,B,Q);I&&(l=I.c,W=I.lc);break}}if(x==Y.lit)throw new Error("HufDecode issues")}}}const v=8-X&7;for(l>>=v,W-=v;W>0;){const I=x[l<<e-W&z];if(!I.len)throw new Error("HufDecode issues");{W-=I.len;const x=S(I.lit,G,l,W,L,F,p,B,Q);x&&(l=x.c,W=x.lc)}}}(W,Q,I,L,l,B,G,X,{value:0})}function i(I){return 65535&I}function V(I){const x=i(I);return x>32767?x-65536:x}function j(I,x){const L=V(I),F=V(x),X=L+(1&F)+(F>>1);return{a:X,b:X-F}}function C(I,x){const L=i(I),F=i(x),X=L-(F>>1)&D;return{a:F+X-a&D,b:X}}function b(I,x,L,F,X,G,Y){const p=Y<16384,B=L>X?X:L;let l,W,Q=1;for(;Q<=B;)Q<<=1;for(Q>>=1,l=Q,Q>>=1;Q>=1;){W=0;const Y=W+G*(X-l),B=G*Q,e=G*l,g=F*Q,v=F*l;let z,H,s,U;for(;W<=Y;W+=e){let X=W;const G=W+F*(L-l);for(;X<=G;X+=v){const L=X+g,F=X+B,G=F+g;if(p){let Y=j(I[X+x],I[F+x]);z=Y.a,s=Y.b,Y=j(I[L+x],I[G+x]),H=Y.a,U=Y.b,Y=j(z,H),I[X+x]=Y.a,I[L+x]=Y.b,Y=j(s,U),I[F+x]=Y.a,I[G+x]=Y.b}else{let Y=C(I[X+x],I[F+x]);z=Y.a,s=Y.b,Y=C(I[L+x],I[G+x]),H=Y.a,U=Y.b,Y=C(z,H),I[X+x]=Y.a,I[L+x]=Y.b,Y=C(s,U),I[F+x]=Y.a,I[G+x]=Y.b}}if(L&Q){const L=X+B;let F;F=p?j(I[X+x],I[L+x]):C(I[X+x],I[L+x]),z=F.a,I[L+x]=F.b,I[X+x]=z}}if(X&Q){let X=W;const G=W+F*(L-l);for(;X<=G;X+=v){const L=X+g;let F;F=p?j(I[X+x],I[L+x]):C(I[X+x],I[L+x]),z=F.a,I[L+x]=F.b,I[X+x]=z}}l=Q,Q>>=1}return W}function II(I){return new DataView(I.array.buffer,I.offset.value,I.size)}function xI(I){const x=I.viewer.buffer.slice(I.offset.value,I.offset.value+I.size),L=new Uint8Array(function(I){let x=I.byteLength;const L=[];let F=0;const X=new DataView(I);for(;x>0;){const I=X.getInt8(F++);if(I<0){const G=-I;x-=G+1;for(let I=0;I<G;I++)L.push(X.getUint8(F++))}else{const G=I;x-=2;const Y=X.getUint8(F++);for(let I=0;I<G+1;I++)L.push(Y)}}return L}(x)),F=new Uint8Array(L.length);return mI(L),O(L,F),new DataView(F.buffer)}function LI(I){const x=I.array.slice(I.offset.value,I.offset.value+I.size),L=fflate.unzlibSync(x),F=new Uint8Array(L.length);return mI(L),O(L,F),new DataView(F.buffer)}function FI(I){const x=I.array.slice(I.offset.value,I.offset.value+I.size),L=fflate.unzlibSync(x),F=I.lines*I.channels*I.width,X=1==I.type?new Uint16Array(F):new Uint32Array(F);let G=0,Y=0;const p=new Array(4);for(let B=0;B<I.lines;B++)for(let x=0;x<I.channels;x++){let x=0;switch(I.type){case 1:p[0]=G,p[1]=p[0]+I.width,G=p[1]+I.width;for(let F=0;F<I.width;++F){x+=L[p[0]++]<<8|L[p[1]++],X[Y]=x,Y++}break;case 2:p[0]=G,p[1]=p[0]+I.width,p[2]=p[1]+I.width,G=p[2]+I.width;for(let F=0;F<I.width;++F){x+=L[p[0]++]<<24|L[p[1]++]<<16|L[p[2]++]<<8,X[Y]=x,Y++}}}return new DataView(X.buffer)}function XI(I){const x=I.viewer,L={value:I.offset.value},F=new Uint16Array(I.width*I.scanlineBlockSize*(I.channels*I.type)),X=new Uint8Array(Q);let G=0;const Y=new Array(I.channels);for(let B=0;B<I.channels;B++)Y[B]={},Y[B].start=G,Y[B].end=Y[B].start,Y[B].nx=I.width,Y[B].ny=I.lines,Y[B].size=I.type,G+=Y[B].nx*Y[B].ny*Y[B].size;const p=n(x,L),l=n(x,L);if(l>=Q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(p<=l)for(let B=0;B<l-p+1;B++)X[B+p]=R(x,L);const e=new Uint16Array(W),g=function(I,x){let L=0;for(let X=0;X<W;++X)(0==X||I[X>>3]&1<<(7&X))&&(x[L++]=X);const F=L-1;for(;L<W;)x[L++]=0;return F}(X,e),v=f(x,L);E(I.array,x,L,v,F,G);for(let B=0;B<I.channels;++B){const I=Y[B];for(let x=0;x<Y[B].size;++x)b(F,I.start+x,I.nx,I.size,I.ny,I.nx*I.size,g)}!function(I,x,L){for(let F=0;F<L;++F)x[F]=I[x[F]]}(e,F,G);let z=0;const H=new Uint8Array(F.buffer.byteLength);for(let W=0;W<I.lines;W++)for(let x=0;x<I.channels;x++){const I=Y[x],L=I.nx*I.size,X=new Uint8Array(F.buffer,I.end*B,L*B);H.set(X,z),z+=L*B,I.end+=L}return new DataView(H.buffer)}var GI,YI=L(12791);!function(I){I[I.Float=0]="Float",I[I.HalfFloat=1]="HalfFloat"}(GI||(GI={}));class pI{}async function BI(I,x,L,F){const X={size:0,viewer:x,array:new Uint8Array(x.buffer),offset:L,width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,channels:I.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(I.compression){case q.NO_COMPRESSION:X.lines=1,X.uncompress=II;break;case q.RLE_COMPRESSION:X.lines=1,X.uncompress=xI;break;case q.ZIPS_COMPRESSION:X.lines=1,X.uncompress=LI,await YI.Tools.LoadScriptAsync(pI.FFLATEUrl);break;case q.ZIP_COMPRESSION:X.lines=16,X.uncompress=LI,await YI.Tools.LoadScriptAsync(pI.FFLATEUrl);break;case q.PIZ_COMPRESSION:X.lines=32,X.uncompress=XI;break;case q.PXR24_COMPRESSION:X.lines=16,X.uncompress=FI,await YI.Tools.LoadScriptAsync(pI.FFLATEUrl);break;default:throw new Error(q[I.compression]+" is unsupported")}X.scanlineBlockSize=X.lines;const G={};for(const Y of I.channels)switch(Y.name){case"R":case"G":case"B":case"A":case"Y":G[Y.name]=!0,X.type=Y.pixelType}let p=!1;if(G.R&&G.G&&G.B&&G.A)X.outputChannels=4,X.decodeChannels={R:0,G:1,B:2,A:3};else if(G.R&&G.G&&G.B)p=!0,X.outputChannels=4,X.decodeChannels={R:0,G:1,B:2,A:3};else if(G.R&&G.G)X.outputChannels=2,X.decodeChannels={R:0,G:1};else if(G.R)X.outputChannels=1,X.decodeChannels={R:0};else{if(!G.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");X.outputChannels=1,X.decodeChannels={Y:0}}if(1===X.type)switch(F){case GI.Float:X.getter=K,X.inputSize=B;break;case GI.HalfFloat:X.getter=n,X.inputSize=B}else{if(2!==X.type)throw new Error("Unsupported pixelType "+X.type+" for "+I.compression);switch(F){case GI.Float:X.getter=M,X.inputSize=Y;break;case GI.HalfFloat:X.getter=u,X.inputSize=Y}}X.blockCount=X.height/X.scanlineBlockSize;for(let Y=0;Y<X.blockCount;Y++)d(x,L);const l=X.width*X.height*X.outputChannels;switch(F){case GI.Float:X.byteArray=new Float32Array(l),X.textureType=1,p&&X.byteArray.fill(1,0,l);break;case GI.HalfFloat:X.byteArray=new Uint16Array(l),X.textureType=2,p&&X.byteArray.fill(15360,0,l);break;default:throw new Error("Unsupported type: "+F)}let W=0;for(const Y of I.channels)void 0!==X.decodeChannels[Y.name]&&(X.channelLineOffsets[Y.name]=W*X.width),W+=2*Y.pixelType;return X.bytesPerLine=X.width*W,X.outLineWidth=X.width*X.outputChannels,"INCREASING_Y"===I.lineOrder?X.scanOrder=I=>I:X.scanOrder=I=>X.height-1-I,4==X.outputChannels?(X.format=5,X.linearSpace=!0):(X.format=6,X.linearSpace=!1),X}function lI(I,x,L,F){const X={value:0};for(let G=0;G<I.height/I.scanlineBlockSize;G++){const Y=t(L,F)-x.dataWindow.yMin;I.size=f(L,F),I.lines=Y+I.scanlineBlockSize>I.height?I.height-Y:I.scanlineBlockSize;const p=I.size<I.lines*I.bytesPerLine&&I.uncompress?I.uncompress(I):II(I);F.value+=I.size;for(let L=0;L<I.scanlineBlockSize;L++){const F=G*I.scanlineBlockSize,Y=L+I.scanOrder(F);if(Y>=I.height)continue;const B=L*I.bytesPerLine,l=(I.height-1-Y)*I.outLineWidth;for(let L=0;L<I.channels;L++){const F=x.channels[L].name,G=I.channelLineOffsets[F],Y=I.decodeChannels[F];if(void 0!==Y){X.value=B+G;for(let x=0;x<I.width;x++){const L=l+x*I.outputChannels+Y;I.byteArray&&(I.byteArray[L]=I.getter(p,X))}}}}}}pI.DefaultOutputType=GI.HalfFloat,pI.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class WI{constructor(){this.supportCascades=!1}loadCubeData(I,x,L,F,X){throw".exr not supported in Cube."}loadData(I,x,L){const X=new DataView(I.buffer),G={value:0},Y=k(X,G);BI(Y,X,G,pI.DefaultOutputType).then((I=>{lI(I,Y,X,G);const F=Y.dataWindow.xMax-Y.dataWindow.xMin+1,p=Y.dataWindow.yMax-Y.dataWindow.yMin+1;L(F,p,x.generateMipMaps,!1,(()=>{const L=x.getEngine();x.format=Y.format,x.type=I.textureType,x.invertY=!1,x._gammaSpace=!Y.linearSpace,I.byteArray&&L._uploadDataToTextureDirectly(x,I.byteArray,0,0,void 0,!0)}))})).catch((I=>{F.c.Error("Failed to load EXR texture: ",I)}))}}async function QI(I){const x=new DataView(I),L={value:0},X=k(x,L);try{const I=await BI(X,x,L,GI.Float);return lI(I,X,x,L),I.byteArray?{width:X.dataWindow.xMax-X.dataWindow.xMin+1,height:X.dataWindow.yMax-X.dataWindow.yMin+1,data:new Float32Array(I.byteArray)}:(F.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(G){F.c.Error("Failed to load EXR data: ",G)}return{width:0,height:0,data:null}}},13001:(I,x,L)=>{function F(I){return parseInt(I.toString().replace(/\W/g,""))}function X(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(I-x)<=L}function G(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return I<x-F||I>L+F}function Y(I,x){return I===x?I:Math.random()*(x-I)+I}function p(I,x,L){return I+(x-I)*L}function B(I,x,L){let F=H(x-I,360);return F>180&&(F-=360),I+F*e(L)}function l(I,x,L){let F=0;return F=I!=x?e((L-I)/(x-I)):0,F}function W(I,x,L,F,X){const G=X*X,Y=X*G;return I*(2*Y-3*G+1)+L*(-2*Y+3*G)+x*(Y-2*G+X)+F*(Y-G)}function Q(I,x,L,F,X){const G=X*X;return 6*(G-X)*I+(3*G-4*X+1)*x+6*(-G+X)*L+(3*G-2*X)*F}function e(I){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(L,Math.max(x,I))}function g(I){return I-=2*Math.PI*Math.floor((I+Math.PI)/(2*Math.PI))}function v(I){const x=I.toString(16);return I<=15?("0"+x).toUpperCase():x.toUpperCase()}function z(I){if(Math.log2)return Math.floor(Math.log2(I));if(I<0)return NaN;if(0===I)return-1/0;let x=0;if(I<1){for(;I<1;)x++,I*=2;x=-x}else if(I>1)for(;I>1;)x++,I=Math.floor(I/2);return x}function H(I,x){return I-Math.floor(I/x)*x}function s(I,x,L){return(I-x)/(L-x)}function U(I,x,L){return I*(L-x)+x}function q(I,x){let L=H(x-I,360);return L>180&&(L-=360),L}function y(I,x){const L=H(I,2*x);return x-Math.abs(L-x)}function T(I,x,L){let F=e(L);return F=-2*F*F*F+3*F*F,x*F+I*(1-F)}function Z(I,x,L){let F=0;return F=Math.abs(x-I)<=L?x:I+Math.sign(x-I)*L,F}function t(I,x,L){const F=q(I,x);let X=0;return X=-L<F&&F<L?x:Z(I,x=I+F,L),X}function f(I,x,L){return(I-x)/(L-x)}function R(I,x,L){return(L-x)*I+x}function n(I,x){const L=I%x;return 0===L?x:n(x,L)}L.r(x),L.d(x,{Clamp:()=>e,DeltaAngle:()=>q,Denormalize:()=>U,ExtractAsInt:()=>F,Hermite:()=>W,Hermite1stDerivative:()=>Q,HighestCommonFactor:()=>n,ILog2:()=>z,InverseLerp:()=>l,Lerp:()=>p,LerpAngle:()=>B,MoveTowards:()=>Z,MoveTowardsAngle:()=>t,Normalize:()=>s,NormalizeRadians:()=>g,OutsideRange:()=>G,PercentToRange:()=>R,PingPong:()=>y,RandomRange:()=>Y,RangeToPercent:()=>f,Repeat:()=>H,SmoothStep:()=>T,ToHex:()=>v,WithinEpsilon:()=>X})}}]);