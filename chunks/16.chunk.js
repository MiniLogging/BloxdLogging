"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[16],{14847:(V,h,mV)=>{mV.r(h),mV.d(h,{ReadExrDataAsync:()=>nV,_ExrTextureLoader:()=>oV});var t=mV(12264),L=mV(12435);const N=4,A=4,k=1,C=2,K=8,o=65536,n=o>>3,q=14,x=65537,R=1<<q,d=R-1,s=59,M=63,c=2+M-s;var z,Q;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(z||(z={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(Q||(Q={}));const J=function(){const V=new ArrayBuffer(4),h=new Float32Array(V),mV=new Uint32Array(V),t=new Uint32Array(512),L=new Uint32Array(512);for(let C=0;C<256;++C){const V=C-127;V<-27?(t[C]=0,t[256|C]=32768,L[C]=24,L[256|C]=24):V<-14?(t[C]=1024>>-V-14,t[256|C]=1024>>-V-14|32768,L[C]=-V-1,L[256|C]=-V-1):V<=15?(t[C]=V+15<<10,t[256|C]=V+15<<10|32768,L[C]=13,L[256|C]=13):V<128?(t[C]=31744,t[256|C]=64512,L[C]=24,L[256|C]=24):(t[C]=31744,t[256|C]=64512,L[C]=13,L[256|C]=13)}const N=new Uint32Array(2048),A=new Uint32Array(64),k=new Uint32Array(64);for(let C=1;C<1024;++C){let V=C<<13,h=0;for(;0===(8388608&V);)V<<=1,h-=8388608;V&=-8388609,h+=947912704,N[C]=V|h}for(let C=1024;C<2048;++C)N[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)A[C]=C<<23;A[31]=1199570944,A[32]=2147483648;for(let C=33;C<63;++C)A[C]=2147483648+(C-32<<23);A[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(k[C]=1024);return{floatView:h,uint32View:mV,baseTable:t,shiftTable:L,mantissaTable:N,exponentTable:A,offsetTable:k}}();function v(V,h){const mV=new Uint8Array(V);let t=0;for(;0!=mV[h.value+t];)t+=1;const L=(new TextDecoder).decode(mV.slice(h.value,h.value+t));return h.value=h.value+t+1,L}function D(V,h){const mV=V.getInt32(h.value,!0);return h.value+=N,mV}function H(V,h){const mV=V.getUint32(h.value,!0);return h.value+=N,mV}function j(V,h){const mV=V.getUint8(h.value);return h.value+=k,mV}function l(V,h){const mV=V.getUint16(h.value,!0);return h.value+=C,mV}function G(V,h){const mV=V[h.value];return h.value+=k,mV}function y(V,h){let mV;return mV="getBigInt64"in DataView.prototype?Number(V.getBigInt64(h.value,!0)):V.getUint32(h.value+4,!0)+Number(V.getUint32(h.value,!0)<<32),h.value+=K,mV}function O(V,h){const mV=V.getFloat32(h.value,!0);return h.value+=A,mV}function I(V,h){return function(V){const h=(31744&V)>>10,mV=1023&V;return(V>>15?-1:1)*(h?31===h?mV?NaN:1/0:Math.pow(2,h-15)*(1+mV/1024):mV/1024*6103515625e-14)}(l(V,h))}function r(V,h){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,L.Clamp)(V,-65504,65504),J.floatView[0]=V;const h=J.uint32View[0],mV=h>>23&511;return J.baseTable[mV]+((8388607&h)>>J.shiftTable[mV])}(O(V,h))}function T(V,h,mV,t){switch(mV){case"string":case"stringvector":case"iccProfile":return function(V,h,mV){const t=(new TextDecoder).decode(new Uint8Array(V).slice(h.value,h.value+mV));return h.value=h.value+mV,t}(V.buffer,h,t);case"chlist":return function(V,h,mV){const t=h.value,L=[];for(;h.value<t+mV-1;){const mV=v(V.buffer,h),t=D(V,h),N=j(V,h);h.value+=3;const A=D(V,h),k=D(V,h);L.push({name:mV,pixelType:t,pLinear:N,xSampling:A,ySampling:k})}return h.value+=1,L}(V,h,t);case"chromaticities":return function(V,h){return{redX:O(V,h),redY:O(V,h),greenX:O(V,h),greenY:O(V,h),blueX:O(V,h),blueY:O(V,h),whiteX:O(V,h),whiteY:O(V,h)}}(V,h);case"compression":return function(V,h){return j(V,h)}(V,h);case"box2i":return function(V,h){return{xMin:D(V,h),yMin:D(V,h),xMax:D(V,h),yMax:D(V,h)}}(V,h);case"lineOrder":return function(V,h){const mV=j(V,h);return Q[mV]}(V,h);case"float":return O(V,h);case"v2f":return function(V,h){return[O(V,h),O(V,h)]}(V,h);case"v3f":return function(V,h){return[O(V,h),O(V,h),O(V,h)]}(V,h);case"int":return D(V,h);case"rational":return function(V,h){return[D(V,h),H(V,h)]}(V,h);case"timecode":return function(V,h){return[H(V,h),H(V,h)]}(V,h);case"preview":return h.value+=t,"skipped";default:return void(h.value+=t)}}function F(V){for(let h=1;h<V.length;h++){const mV=V[h-1]+V[h]-128;V[h]=mV}}function p(V,h){let mV=0,t=Math.floor((V.length+1)/2),L=0;const N=V.length-1;for(;!(L>N)&&(h[L++]=V[mV++],!(L>N));)h[L++]=V[t++]}const Z=20000630;function f(V,h){if(V.getUint32(0,!0)!=Z)throw new Error("Incorrect OpenEXR format");const mV=V.getUint8(4),L=V.getUint8(5),N={singleTile:!!(2&L),longName:!!(4&L),deepFormat:!!(8&L),multiPart:!!(16&L)};h.value=8;const A={};let k=!0;for(;k;){const mV=v(V.buffer,h);if(mV){const L=v(V.buffer,h),N=T(V,h,L,H(V,h));void 0===N?t.e.Warn(`Unknown header attribute type ${L}'.`):A[mV]=N}else k=!1}if(0!=(-5&L))throw new Error("Unsupported file format");return{version:mV,spec:N,...A}}const S=32768,Y=65535;function w(V,h,mV,t,L){for(;mV<V;)h=h<<8|G(t,L),mV+=8;return{l:h>>(mV-=V)&(1<<V)-1,c:h,lc:mV}}function E(V,h,mV,t){return{c:V=V<<8|G(mV,t),lc:h+=8}}function g(V,h,mV,t,L,N,A,k,C){if(V==h){if(t<8){const V=E(mV,t,L,N);mV=V.c,t=V.lc}let V=mV>>(t-=8);if(V=new Uint8Array([V])[0],k.value+V>C)return null;const h=A[k.value-1];for(;V-- >0;)A[k.value++]=h}else{if(!(k.value<C))return null;A[k.value++]=V}return{c:mV,lc:t}}const i=new Array(59);function b(V,h,mV,t,L,N){const A=h;let k=0,C=0;for(;t<=L;t++){if(A.value-h.value>mV)return;let K=w(6,k,C,V,A);const o=K.l;if(k=K.c,C=K.lc,N[t]=o,o==M){if(A.value-h.value>mV)throw new Error("Error in HufUnpackEncTable");K=w(8,k,C,V,A);let o=K.l+c;if(k=K.c,C=K.lc,t+o>L+1)throw new Error("Error in HufUnpackEncTable");for(;o--;)N[t++]=0;t--}else if(o>=s){let V=o-s+2;if(t+V>L+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)N[t++]=0;t--}}!function(V){for(let mV=0;mV<=58;++mV)i[mV]=0;for(let mV=0;mV<x;++mV)i[V[mV]]+=1;let h=0;for(let mV=58;mV>0;--mV){const V=h+i[mV]>>1;i[mV]=h,h=V}for(let mV=0;mV<x;++mV){const h=V[mV];h>0&&(V[mV]=h|i[h]++<<6)}}(N)}function P(V){return 63&V}function U(V){return V>>6}function u(V,h,mV,t,L,N){const A=mV.value,k=H(h,mV),C=H(h,mV);mV.value+=4;const K=H(h,mV);if(mV.value+=4,k<0||k>=x||C<0||C>=x)throw new Error("Wrong HUF_ENCSIZE");const o=new Array(x),n=new Array(R);!function(V){for(let h=0;h<R;h++)V[h]={},V[h].len=0,V[h].lit=0,V[h].p=null}(n);if(b(V,mV,t-(mV.value-A),k,C,o),K>8*(t-(mV.value-A)))throw new Error("Wrong hufUncompress");!function(V,h,mV,t){for(;h<=mV;h++){const mV=U(V[h]),L=P(V[h]);if(mV>>L)throw new Error("Invalid table entry");if(L>q){const V=t[mV>>L-q];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const h=V.p;V.p=new Array(V.lit);for(let mV=0;mV<V.lit-1;++mV)V.p[mV]=h[mV]}else V.p=new Array(1);V.p[V.lit-1]=h}else if(L){let V=0;for(let N=1<<q-L;N>0;N--){const N=t[(mV<<q-L)+V];if(N.len||N.p)throw new Error("Invalid table entry");N.len=L,N.lit=h,V++}}}}(o,k,C,n),function(V,h,mV,t,L,N,A,k,C){let K=0,o=0;const n=A,x=Math.trunc(t.value+(L+7)/8);for(;t.value<x;){let L=E(K,o,mV,t);for(K=L.c,o=L.lc;o>=q;){const A=h[K>>o-q&d];if(A.len){o-=A.len;const V=g(A.lit,N,K,o,mV,t,k,C,n);V&&(K=V.c,o=V.lc)}else{if(!A.p)throw new Error("hufDecode issues");let h;for(h=0;h<A.lit;h++){const q=P(V[A.p[h]]);for(;o<q&&t.value<x;)L=E(K,o,mV,t),K=L.c,o=L.lc;if(o>=q&&U(V[A.p[h]])==(K>>o-q&(1<<q)-1)){o-=q;const V=g(A.p[h],N,K,o,mV,t,k,C,n);V&&(K=V.c,o=V.lc);break}}if(h==A.lit)throw new Error("HufDecode issues")}}}const R=8-L&7;for(K>>=R,o-=R;o>0;){const V=h[K<<q-o&d];if(!V.len)throw new Error("HufDecode issues");{o-=V.len;const h=g(V.lit,N,K,o,mV,t,k,C,n);h&&(K=h.c,o=h.lc)}}}(o,n,V,mV,K,C,N,L,{value:0})}function e(V){return 65535&V}function W(V){const h=e(V);return h>32767?h-65536:h}function X(V,h){const mV=W(V),t=W(h),L=mV+(1&t)+(t>>1);return{a:L,b:L-t}}function a(V,h){const mV=e(V),t=e(h),L=mV-(t>>1)&Y;return{a:t+L-S&Y,b:L}}function B(V,h,mV,t,L,N,A){const k=A<16384,C=mV>L?L:mV;let K,o,n=1;for(;n<=C;)n<<=1;for(n>>=1,K=n,n>>=1;n>=1;){o=0;const A=o+N*(L-K),C=N*n,q=N*K,x=t*n,R=t*K;let d,s,M,c;for(;o<=A;o+=q){let L=o;const N=o+t*(mV-K);for(;L<=N;L+=R){const mV=L+x,t=L+C,N=t+x;if(k){let A=X(V[L+h],V[t+h]);d=A.a,M=A.b,A=X(V[mV+h],V[N+h]),s=A.a,c=A.b,A=X(d,s),V[L+h]=A.a,V[mV+h]=A.b,A=X(M,c),V[t+h]=A.a,V[N+h]=A.b}else{let A=a(V[L+h],V[t+h]);d=A.a,M=A.b,A=a(V[mV+h],V[N+h]),s=A.a,c=A.b,A=a(d,s),V[L+h]=A.a,V[mV+h]=A.b,A=a(M,c),V[t+h]=A.a,V[N+h]=A.b}}if(mV&n){const mV=L+C;let t;t=k?X(V[L+h],V[mV+h]):a(V[L+h],V[mV+h]),d=t.a,V[mV+h]=t.b,V[L+h]=d}}if(L&n){let L=o;const N=o+t*(mV-K);for(;L<=N;L+=R){const mV=L+x;let t;t=k?X(V[L+h],V[mV+h]):a(V[L+h],V[mV+h]),d=t.a,V[mV+h]=t.b,V[L+h]=d}}K=n,n>>=1}return o}function VV(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function hV(V){const h=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),mV=new Uint8Array(function(V){let h=V.byteLength;const mV=[];let t=0;const L=new DataView(V);for(;h>0;){const V=L.getInt8(t++);if(V<0){const N=-V;h-=N+1;for(let V=0;V<N;V++)mV.push(L.getUint8(t++))}else{const N=V;h-=2;const A=L.getUint8(t++);for(let V=0;V<N+1;V++)mV.push(A)}}return mV}(h)),t=new Uint8Array(mV.length);return F(mV),p(mV,t),new DataView(t.buffer)}function mh(V){const h=V.array.slice(V.offset.value,V.offset.value+V.size),mV=fflate.unzlibSync(h),t=new Uint8Array(mV.length);return F(mV),p(mV,t),new DataView(t.buffer)}function tV(V){const h=V.array.slice(V.offset.value,V.offset.value+V.size),mV=fflate.unzlibSync(h),t=V.lines*V.channels*V.width,L=1==V.type?new Uint16Array(t):new Uint32Array(t);let N=0,A=0;const k=new Array(4);for(let C=0;C<V.lines;C++)for(let h=0;h<V.channels;h++){let h=0;switch(V.type){case 1:k[0]=N,k[1]=k[0]+V.width,N=k[1]+V.width;for(let t=0;t<V.width;++t){h+=mV[k[0]++]<<8|mV[k[1]++],L[A]=h,A++}break;case 2:k[0]=N,k[1]=k[0]+V.width,k[2]=k[1]+V.width,N=k[2]+V.width;for(let t=0;t<V.width;++t){h+=mV[k[0]++]<<24|mV[k[1]++]<<16|mV[k[2]++]<<8,L[A]=h,A++}}}return new DataView(L.buffer)}function LV(V){const h=V.viewer,mV={value:V.offset.value},t=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),L=new Uint8Array(n);let N=0;const A=new Array(V.channels);for(let C=0;C<V.channels;C++)A[C]={},A[C].start=N,A[C].end=A[C].start,A[C].nx=V.width,A[C].ny=V.lines,A[C].size=V.type,N+=A[C].nx*A[C].ny*A[C].size;const k=l(h,mV),K=l(h,mV);if(K>=n)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(k<=K)for(let C=0;C<K-k+1;C++)L[C+k]=j(h,mV);const q=new Uint16Array(o),x=function(V,h){let mV=0;for(let L=0;L<o;++L)(0==L||V[L>>3]&1<<(7&L))&&(h[mV++]=L);const t=mV-1;for(;mV<o;)h[mV++]=0;return t}(L,q),R=H(h,mV);u(V.array,h,mV,R,t,N);for(let C=0;C<V.channels;++C){const V=A[C];for(let h=0;h<A[C].size;++h)B(t,V.start+h,V.nx,V.size,V.ny,V.nx*V.size,x)}!function(V,h,mV){for(let t=0;t<mV;++t)h[t]=V[h[t]]}(q,t,N);let d=0;const s=new Uint8Array(t.buffer.byteLength);for(let o=0;o<V.lines;o++)for(let h=0;h<V.channels;h++){const V=A[h],mV=V.nx*V.size,L=new Uint8Array(t.buffer,V.end*C,mV*C);s.set(L,d),d+=mV*C,V.end+=mV}return new DataView(s.buffer)}var NV,AV=mV(12253);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(NV||(NV={}));class kV{}async function CV(V,h,mV,t){const L={size:0,viewer:h,array:new Uint8Array(h.buffer),offset:mV,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case z.NO_COMPRESSION:L.lines=1,L.uncompress=VV;break;case z.RLE_COMPRESSION:L.lines=1,L.uncompress=hV;break;case z.ZIPS_COMPRESSION:L.lines=1,L.uncompress=mh,await AV.Tools.LoadScriptAsync(kV.FFLATEUrl);break;case z.ZIP_COMPRESSION:L.lines=16,L.uncompress=mh,await AV.Tools.LoadScriptAsync(kV.FFLATEUrl);break;case z.PIZ_COMPRESSION:L.lines=32,L.uncompress=LV;break;case z.PXR24_COMPRESSION:L.lines=16,L.uncompress=tV,await AV.Tools.LoadScriptAsync(kV.FFLATEUrl);break;default:throw new Error(z[V.compression]+" is unsupported")}L.scanlineBlockSize=L.lines;const N={};for(const A of V.channels)switch(A.name){case"R":case"G":case"B":case"A":case"Y":N[A.name]=!0,L.type=A.pixelType}let k=!1;if(N.R&&N.G&&N.B&&N.A)L.outputChannels=4,L.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G&&N.B)k=!0,L.outputChannels=4,L.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G)L.outputChannels=2,L.decodeChannels={R:0,G:1};else if(N.R)L.outputChannels=1,L.decodeChannels={R:0};else{if(!N.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");L.outputChannels=1,L.decodeChannels={Y:0}}if(1===L.type)switch(t){case NV.Float:L.getter=I,L.inputSize=C;break;case NV.HalfFloat:L.getter=l,L.inputSize=C}else{if(2!==L.type)throw new Error("Unsupported pixelType "+L.type+" for "+V.compression);switch(t){case NV.Float:L.getter=O,L.inputSize=A;break;case NV.HalfFloat:L.getter=r,L.inputSize=A}}L.blockCount=L.height/L.scanlineBlockSize;for(let A=0;A<L.blockCount;A++)y(h,mV);const K=L.width*L.height*L.outputChannels;switch(t){case NV.Float:L.byteArray=new Float32Array(K),L.textureType=1,k&&L.byteArray.fill(1,0,K);break;case NV.HalfFloat:L.byteArray=new Uint16Array(K),L.textureType=2,k&&L.byteArray.fill(15360,0,K);break;default:throw new Error("Unsupported type: "+t)}let o=0;for(const A of V.channels)void 0!==L.decodeChannels[A.name]&&(L.channelLineOffsets[A.name]=o*L.width),o+=2*A.pixelType;return L.bytesPerLine=L.width*o,L.outLineWidth=L.width*L.outputChannels,"INCREASING_Y"===V.lineOrder?L.scanOrder=V=>V:L.scanOrder=V=>L.height-1-V,4==L.outputChannels?(L.format=5,L.linearSpace=!0):(L.format=6,L.linearSpace=!1),L}function KV(V,h,mV,t){const L={value:0};for(let N=0;N<V.height/V.scanlineBlockSize;N++){const A=D(mV,t)-h.dataWindow.yMin;V.size=H(mV,t),V.lines=A+V.scanlineBlockSize>V.height?V.height-A:V.scanlineBlockSize;const k=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):VV(V);t.value+=V.size;for(let mV=0;mV<V.scanlineBlockSize;mV++){const t=N*V.scanlineBlockSize,A=mV+V.scanOrder(t);if(A>=V.height)continue;const C=mV*V.bytesPerLine,K=(V.height-1-A)*V.outLineWidth;for(let mV=0;mV<V.channels;mV++){const t=h.channels[mV].name,N=V.channelLineOffsets[t],A=V.decodeChannels[t];if(void 0!==A){L.value=C+N;for(let h=0;h<V.width;h++){const mV=K+h*V.outputChannels+A;V.byteArray&&(V.byteArray[mV]=V.getter(k,L))}}}}}}kV.DefaultOutputType=NV.HalfFloat,kV.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class oV{constructor(){this.supportCascades=!1}loadCubeData(V,h,mV,t,L){throw".exr not supported in Cube."}loadData(V,h,mV){const L=new DataView(V.buffer),N={value:0},A=f(L,N);CV(A,L,N,kV.DefaultOutputType).then((V=>{KV(V,A,L,N);const t=A.dataWindow.xMax-A.dataWindow.xMin+1,k=A.dataWindow.yMax-A.dataWindow.yMin+1;mV(t,k,h.generateMipMaps,!1,(()=>{const mV=h.getEngine();h.format=A.format,h.type=V.textureType,h.invertY=!1,h._gammaSpace=!A.linearSpace,V.byteArray&&mV._uploadDataToTextureDirectly(h,V.byteArray,0,0,void 0,!0)}))})).catch((V=>{t.e.Error("Failed to load EXR texture: ",V)}))}}async function nV(V){const h=new DataView(V),mV={value:0},L=f(h,mV);try{const V=await CV(L,h,mV,NV.Float);return KV(V,L,h,mV),V.byteArray?{width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,data:new Float32Array(V.byteArray)}:(t.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(N){t.e.Error("Failed to load EXR data: ",N)}return{width:0,height:0,data:null}}},12435:(V,h,mV)=>{function t(V){return parseInt(V.toString().replace(/\W/g,""))}function L(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(V-h)<=mV}function N(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return V<h-t||V>mV+t}function A(V,h){return V===h?V:Math.random()*(h-V)+V}function k(V,h,mV){return V+(h-V)*mV}function C(V,h,mV){let t=s(h-V,360);return t>180&&(t-=360),V+t*q(mV)}function K(V,h,mV){let t=0;return t=V!=h?q((mV-V)/(h-V)):0,t}function o(V,h,mV,t,L){const N=L*L,A=L*N;return V*(2*A-3*N+1)+mV*(-2*A+3*N)+h*(A-2*N+L)+t*(A-N)}function n(V,h,mV,t,L){const N=L*L;return 6*(N-L)*V+(3*N-4*L+1)*h+6*(-N+L)*mV+(3*N-2*L)*t}function q(V){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(mV,Math.max(h,V))}function x(V){return V-=2*Math.PI*Math.floor((V+Math.PI)/(2*Math.PI))}function R(V){const h=V.toString(16);return V<=15?("0"+h).toUpperCase():h.toUpperCase()}function d(V){if(Math.log2)return Math.floor(Math.log2(V));if(V<0)return NaN;if(0===V)return-1/0;let h=0;if(V<1){for(;V<1;)h++,V*=2;h=-h}else if(V>1)for(;V>1;)h++,V=Math.floor(V/2);return h}function s(V,h){return V-Math.floor(V/h)*h}function M(V,h,mV){return(V-h)/(mV-h)}function c(V,h,mV){return V*(mV-h)+h}function z(V,h){let mV=s(h-V,360);return mV>180&&(mV-=360),mV}function Q(V,h){const mV=s(V,2*h);return h-Math.abs(mV-h)}function J(V,h,mV){let t=q(mV);return t=-2*t*t*t+3*t*t,h*t+V*(1-t)}function v(V,h,mV){let t=0;return t=Math.abs(h-V)<=mV?h:V+Math.sign(h-V)*mV,t}function D(V,h,mV){const t=z(V,h);let L=0;return L=-mV<t&&t<mV?h:v(V,h=V+t,mV),L}function H(V,h,mV){return(V-h)/(mV-h)}function j(V,h,mV){return(mV-h)*V+h}function l(V,h){const mV=V%h;return 0===mV?h:l(h,mV)}mV.r(h),mV.d(h,{Clamp:()=>q,DeltaAngle:()=>z,Denormalize:()=>c,ExtractAsInt:()=>t,Hermite:()=>o,Hermite1stDerivative:()=>n,HighestCommonFactor:()=>l,ILog2:()=>d,InverseLerp:()=>K,Lerp:()=>k,LerpAngle:()=>C,MoveTowards:()=>v,MoveTowardsAngle:()=>D,Normalize:()=>M,NormalizeRadians:()=>x,OutsideRange:()=>N,PercentToRange:()=>j,PingPong:()=>Q,RandomRange:()=>A,RangeToPercent:()=>H,Repeat:()=>s,SmoothStep:()=>J,ToHex:()=>R,WithinEpsilon:()=>L})}}]);