"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[16],{14609:(Z,l,C)=>{C.r(l),C.d(l,{ReadExrDataAsync:()=>EZ,_ExrTextureLoader:()=>dZ});var B=C(12263),x=C(12460);const b=4,K=4,f=1,W=2,J=8,d=65536,E=d>>3,G=14,a=65537,q=1<<G,z=q-1,Y=59,P=63,S=2+P-Y;var i,s;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(i||(i={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(s||(s={}));const F=function(){const Z=new ArrayBuffer(4),l=new Float32Array(Z),C=new Uint32Array(Z),B=new Uint32Array(512),x=new Uint32Array(512);for(let W=0;W<256;++W){const Z=W-127;Z<-27?(B[W]=0,B[256|W]=32768,x[W]=24,x[256|W]=24):Z<-14?(B[W]=1024>>-Z-14,B[256|W]=1024>>-Z-14|32768,x[W]=-Z-1,x[256|W]=-Z-1):Z<=15?(B[W]=Z+15<<10,B[256|W]=Z+15<<10|32768,x[W]=13,x[256|W]=13):Z<128?(B[W]=31744,B[256|W]=64512,x[W]=24,x[256|W]=24):(B[W]=31744,B[256|W]=64512,x[W]=13,x[256|W]=13)}const b=new Uint32Array(2048),K=new Uint32Array(64),f=new Uint32Array(64);for(let W=1;W<1024;++W){let Z=W<<13,l=0;for(;0===(8388608&Z);)Z<<=1,l-=8388608;Z&=-8388609,l+=947912704,b[W]=Z|l}for(let W=1024;W<2048;++W)b[W]=939524096+(W-1024<<13);for(let W=1;W<31;++W)K[W]=W<<23;K[31]=1199570944,K[32]=2147483648;for(let W=33;W<63;++W)K[W]=2147483648+(W-32<<23);K[63]=3347054592;for(let W=1;W<64;++W)32!==W&&(f[W]=1024);return{floatView:l,uint32View:C,baseTable:B,shiftTable:x,mantissaTable:b,exponentTable:K,offsetTable:f}}();function n(Z,l){const C=new Uint8Array(Z);let B=0;for(;0!=C[l.value+B];)B+=1;const x=(new TextDecoder).decode(C.slice(l.value,l.value+B));return l.value=l.value+B+1,x}function c(Z,l){const C=Z.getInt32(l.value,!0);return l.value+=b,C}function U(Z,l){const C=Z.getUint32(l.value,!0);return l.value+=b,C}function t(Z,l){const C=Z.getUint8(l.value);return l.value+=f,C}function r(Z,l){const C=Z.getUint16(l.value,!0);return l.value+=W,C}function e(Z,l){const C=Z[l.value];return l.value+=f,C}function o(Z,l){let C;return C="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(l.value,!0)):Z.getUint32(l.value+4,!0)+Number(Z.getUint32(l.value,!0)<<32),l.value+=J,C}function v(Z,l){const C=Z.getFloat32(l.value,!0);return l.value+=K,C}function R(Z,l){return function(Z){const l=(31744&Z)>>10,C=1023&Z;return(Z>>15?-1:1)*(l?31===l?C?NaN:1/0:Math.pow(2,l-15)*(1+C/1024):C/1024*6103515625e-14)}(r(Z,l))}function k(Z,l){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,x.Clamp)(Z,-65504,65504),F.floatView[0]=Z;const l=F.uint32View[0],C=l>>23&511;return F.baseTable[C]+((8388607&l)>>F.shiftTable[C])}(v(Z,l))}function V(Z,l,C,B){switch(C){case"string":case"stringvector":case"iccProfile":return function(Z,l,C){const B=(new TextDecoder).decode(new Uint8Array(Z).slice(l.value,l.value+C));return l.value=l.value+C,B}(Z.buffer,l,B);case"chlist":return function(Z,l,C){const B=l.value,x=[];for(;l.value<B+C-1;){const C=n(Z.buffer,l),B=c(Z,l),b=t(Z,l);l.value+=3;const K=c(Z,l),f=c(Z,l);x.push({name:C,pixelType:B,pLinear:b,xSampling:K,ySampling:f})}return l.value+=1,x}(Z,l,B);case"chromaticities":return function(Z,l){return{redX:v(Z,l),redY:v(Z,l),greenX:v(Z,l),greenY:v(Z,l),blueX:v(Z,l),blueY:v(Z,l),whiteX:v(Z,l),whiteY:v(Z,l)}}(Z,l);case"compression":return function(Z,l){return t(Z,l)}(Z,l);case"box2i":return function(Z,l){return{xMin:c(Z,l),yMin:c(Z,l),xMax:c(Z,l),yMax:c(Z,l)}}(Z,l);case"lineOrder":return function(Z,l){const C=t(Z,l);return s[C]}(Z,l);case"float":return v(Z,l);case"v2f":return function(Z,l){return[v(Z,l),v(Z,l)]}(Z,l);case"v3f":return function(Z,l){return[v(Z,l),v(Z,l),v(Z,l)]}(Z,l);case"int":return c(Z,l);case"rational":return function(Z,l){return[c(Z,l),U(Z,l)]}(Z,l);case"timecode":return function(Z,l){return[U(Z,l),U(Z,l)]}(Z,l);case"preview":return l.value+=B,"skipped";default:return void(l.value+=B)}}function g(Z){for(let l=1;l<Z.length;l++){const C=Z[l-1]+Z[l]-128;Z[l]=C}}function j(Z,l){let C=0,B=Math.floor((Z.length+1)/2),x=0;const b=Z.length-1;for(;!(x>b)&&(l[x++]=Z[C++],!(x>b));)l[x++]=Z[B++]}const M=20000630;function I(Z,l){if(Z.getUint32(0,!0)!=M)throw new Error("Incorrect OpenEXR format");const C=Z.getUint8(4),x=Z.getUint8(5),b={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};l.value=8;const K={};let f=!0;for(;f;){const C=n(Z.buffer,l);if(C){const x=n(Z.buffer,l),b=V(Z,l,x,U(Z,l));void 0===b?B.e.Warn(`Unknown header attribute type ${x}'.`):K[C]=b}else f=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:C,spec:b,...K}}const w=32768,O=65535;function D(Z,l,C,B,x){for(;C<Z;)l=l<<8|e(B,x),C+=8;return{l:l>>(C-=Z)&(1<<Z)-1,c:l,lc:C}}function y(Z,l,C,B){return{c:Z=Z<<8|e(C,B),lc:l+=8}}function X(Z,l,C,B,x,b,K,f,W){if(Z==l){if(B<8){const Z=y(C,B,x,b);C=Z.c,B=Z.lc}let Z=C>>(B-=8);if(Z=new Uint8Array([Z])[0],f.value+Z>W)return null;const l=K[f.value-1];for(;Z-- >0;)K[f.value++]=l}else{if(!(f.value<W))return null;K[f.value++]=Z}return{c:C,lc:B}}const T=new Array(59);function u(Z,l,C,B,x,b){const K=l;let f=0,W=0;for(;B<=x;B++){if(K.value-l.value>C)return;let J=D(6,f,W,Z,K);const d=J.l;if(f=J.c,W=J.lc,b[B]=d,d==P){if(K.value-l.value>C)throw new Error("Error in HufUnpackEncTable");J=D(8,f,W,Z,K);let d=J.l+S;if(f=J.c,W=J.lc,B+d>x+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)b[B++]=0;B--}else if(d>=Y){let Z=d-Y+2;if(B+Z>x+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)b[B++]=0;B--}}!function(Z){for(let C=0;C<=58;++C)T[C]=0;for(let C=0;C<a;++C)T[Z[C]]+=1;let l=0;for(let C=58;C>0;--C){const Z=l+T[C]>>1;T[C]=l,l=Z}for(let C=0;C<a;++C){const l=Z[C];l>0&&(Z[C]=l|T[l]++<<6)}}(b)}function H(Z){return 63&Z}function Q(Z){return Z>>6}function h(Z,l,C,B,x,b){const K=C.value,f=U(l,C),W=U(l,C);C.value+=4;const J=U(l,C);if(C.value+=4,f<0||f>=a||W<0||W>=a)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(a),E=new Array(q);!function(Z){for(let l=0;l<q;l++)Z[l]={},Z[l].len=0,Z[l].lit=0,Z[l].p=null}(E);if(u(Z,C,B-(C.value-K),f,W,d),J>8*(B-(C.value-K)))throw new Error("Wrong hufUncompress");!function(Z,l,C,B){for(;l<=C;l++){const C=Q(Z[l]),x=H(Z[l]);if(C>>x)throw new Error("Invalid table entry");if(x>G){const Z=B[C>>x-G];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const l=Z.p;Z.p=new Array(Z.lit);for(let C=0;C<Z.lit-1;++C)Z.p[C]=l[C]}else Z.p=new Array(1);Z.p[Z.lit-1]=l}else if(x){let Z=0;for(let b=1<<G-x;b>0;b--){const b=B[(C<<G-x)+Z];if(b.len||b.p)throw new Error("Invalid table entry");b.len=x,b.lit=l,Z++}}}}(d,f,W,E),function(Z,l,C,B,x,b,K,f,W){let J=0,d=0;const E=K,a=Math.trunc(B.value+(x+7)/8);for(;B.value<a;){let x=y(J,d,C,B);for(J=x.c,d=x.lc;d>=G;){const K=l[J>>d-G&z];if(K.len){d-=K.len;const Z=X(K.lit,b,J,d,C,B,f,W,E);Z&&(J=Z.c,d=Z.lc)}else{if(!K.p)throw new Error("hufDecode issues");let l;for(l=0;l<K.lit;l++){const G=H(Z[K.p[l]]);for(;d<G&&B.value<a;)x=y(J,d,C,B),J=x.c,d=x.lc;if(d>=G&&Q(Z[K.p[l]])==(J>>d-G&(1<<G)-1)){d-=G;const Z=X(K.p[l],b,J,d,C,B,f,W,E);Z&&(J=Z.c,d=Z.lc);break}}if(l==K.lit)throw new Error("HufDecode issues")}}}const q=8-x&7;for(J>>=q,d-=q;d>0;){const Z=l[J<<G-d&z];if(!Z.len)throw new Error("HufDecode issues");{d-=Z.len;const l=X(Z.lit,b,J,d,C,B,f,W,E);l&&(J=l.c,d=l.lc)}}}(d,E,Z,C,J,W,b,x,{value:0})}function A(Z){return 65535&Z}function L(Z){const l=A(Z);return l>32767?l-65536:l}function p(Z,l){const C=L(Z),B=L(l),x=C+(1&B)+(B>>1);return{a:x,b:x-B}}function N(Z,l){const C=A(Z),B=A(l),x=C-(B>>1)&O;return{a:B+x-w&O,b:x}}function mZ(Z,l,C,B,x,b,K){const f=K<16384,W=C>x?x:C;let J,d,E=1;for(;E<=W;)E<<=1;for(E>>=1,J=E,E>>=1;E>=1;){d=0;const K=d+b*(x-J),W=b*E,G=b*J,a=B*E,q=B*J;let z,Y,P,S;for(;d<=K;d+=G){let x=d;const b=d+B*(C-J);for(;x<=b;x+=q){const C=x+a,B=x+W,b=B+a;if(f){let K=p(Z[x+l],Z[B+l]);z=K.a,P=K.b,K=p(Z[C+l],Z[b+l]),Y=K.a,S=K.b,K=p(z,Y),Z[x+l]=K.a,Z[C+l]=K.b,K=p(P,S),Z[B+l]=K.a,Z[b+l]=K.b}else{let K=N(Z[x+l],Z[B+l]);z=K.a,P=K.b,K=N(Z[C+l],Z[b+l]),Y=K.a,S=K.b,K=N(z,Y),Z[x+l]=K.a,Z[C+l]=K.b,K=N(P,S),Z[B+l]=K.a,Z[b+l]=K.b}}if(C&E){const C=x+W;let B;B=f?p(Z[x+l],Z[C+l]):N(Z[x+l],Z[C+l]),z=B.a,Z[C+l]=B.b,Z[x+l]=z}}if(x&E){let x=d;const b=d+B*(C-J);for(;x<=b;x+=q){const C=x+a;let B;B=f?p(Z[x+l],Z[C+l]):N(Z[x+l],Z[C+l]),z=B.a,Z[C+l]=B.b,Z[x+l]=z}}J=E,E>>=1}return d}function ZZ(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function lZ(Z){const l=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),C=new Uint8Array(function(Z){let l=Z.byteLength;const C=[];let B=0;const x=new DataView(Z);for(;l>0;){const Z=x.getInt8(B++);if(Z<0){const b=-Z;l-=b+1;for(let Z=0;Z<b;Z++)C.push(x.getUint8(B++))}else{const b=Z;l-=2;const K=x.getUint8(B++);for(let Z=0;Z<b+1;Z++)C.push(K)}}return C}(l)),B=new Uint8Array(C.length);return g(C),j(C,B),new DataView(B.buffer)}function CZ(Z){const l=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),C=fflate.unzlibSync(l),B=new Uint8Array(C.length);return g(C),j(C,B),new DataView(B.buffer)}function BZ(Z){const l=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),C=fflate.unzlibSync(l),B=Z.lines*Z.channels*Z.width,x=1==Z.type?new Uint16Array(B):new Uint32Array(B);let b=0,K=0;const f=new Array(4);for(let W=0;W<Z.lines;W++)for(let l=0;l<Z.channels;l++){let l=0;switch(Z.type){case 1:f[0]=b,f[1]=f[0]+Z.width,b=f[1]+Z.width;for(let B=0;B<Z.width;++B){l+=C[f[0]++]<<8|C[f[1]++],x[K]=l,K++}break;case 2:f[0]=b,f[1]=f[0]+Z.width,f[2]=f[1]+Z.width,b=f[2]+Z.width;for(let B=0;B<Z.width;++B){l+=C[f[0]++]<<24|C[f[1]++]<<16|C[f[2]++]<<8,x[K]=l,K++}}}return new DataView(x.buffer)}function xZ(Z){const l=Z.viewer,C={value:Z.offset.value},B=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),x=new Uint8Array(E);let b=0;const K=new Array(Z.channels);for(let W=0;W<Z.channels;W++)K[W]={},K[W].start=b,K[W].end=K[W].start,K[W].nx=Z.width,K[W].ny=Z.lines,K[W].size=Z.type,b+=K[W].nx*K[W].ny*K[W].size;const f=r(l,C),J=r(l,C);if(J>=E)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(f<=J)for(let W=0;W<J-f+1;W++)x[W+f]=t(l,C);const G=new Uint16Array(d),a=function(Z,l){let C=0;for(let x=0;x<d;++x)(0==x||Z[x>>3]&1<<(7&x))&&(l[C++]=x);const B=C-1;for(;C<d;)l[C++]=0;return B}(x,G),q=U(l,C);h(Z.array,l,C,q,B,b);for(let W=0;W<Z.channels;++W){const Z=K[W];for(let l=0;l<K[W].size;++l)mZ(B,Z.start+l,Z.nx,Z.size,Z.ny,Z.nx*Z.size,a)}!function(Z,l,C){for(let B=0;B<C;++B)l[B]=Z[l[B]]}(G,B,b);let z=0;const Y=new Uint8Array(B.buffer.byteLength);for(let d=0;d<Z.lines;d++)for(let l=0;l<Z.channels;l++){const Z=K[l],C=Z.nx*Z.size,x=new Uint8Array(B.buffer,Z.end*W,C*W);Y.set(x,z),z+=C*W,Z.end+=C}return new DataView(Y.buffer)}var bZ,KZ=C(12248);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(bZ||(bZ={}));class fZ{}async function WZ(Z,l,C,B){const x={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:C,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case i.NO_COMPRESSION:x.lines=1,x.uncompress=ZZ;break;case i.RLE_COMPRESSION:x.lines=1,x.uncompress=lZ;break;case i.ZIPS_COMPRESSION:x.lines=1,x.uncompress=CZ,await KZ.Tools.LoadScriptAsync(fZ.FFLATEUrl);break;case i.ZIP_COMPRESSION:x.lines=16,x.uncompress=CZ,await KZ.Tools.LoadScriptAsync(fZ.FFLATEUrl);break;case i.PIZ_COMPRESSION:x.lines=32,x.uncompress=xZ;break;case i.PXR24_COMPRESSION:x.lines=16,x.uncompress=BZ,await KZ.Tools.LoadScriptAsync(fZ.FFLATEUrl);break;default:throw new Error(i[Z.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const b={};for(const K of Z.channels)switch(K.name){case"R":case"G":case"B":case"A":case"Y":b[K.name]=!0,x.type=K.pixelType}let f=!1;if(b.R&&b.G&&b.B&&b.A)x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else if(b.R&&b.G&&b.B)f=!0,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else if(b.R&&b.G)x.outputChannels=2,x.decodeChannels={R:0,G:1};else if(b.R)x.outputChannels=1,x.decodeChannels={R:0};else{if(!b.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(B){case bZ.Float:x.getter=R,x.inputSize=W;break;case bZ.HalfFloat:x.getter=r,x.inputSize=W}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+Z.compression);switch(B){case bZ.Float:x.getter=v,x.inputSize=K;break;case bZ.HalfFloat:x.getter=k,x.inputSize=K}}x.blockCount=x.height/x.scanlineBlockSize;for(let K=0;K<x.blockCount;K++)o(l,C);const J=x.width*x.height*x.outputChannels;switch(B){case bZ.Float:x.byteArray=new Float32Array(J),x.textureType=1,f&&x.byteArray.fill(1,0,J);break;case bZ.HalfFloat:x.byteArray=new Uint16Array(J),x.textureType=2,f&&x.byteArray.fill(15360,0,J);break;default:throw new Error("Unsupported type: "+B)}let d=0;for(const K of Z.channels)void 0!==x.decodeChannels[K.name]&&(x.channelLineOffsets[K.name]=d*x.width),d+=2*K.pixelType;return x.bytesPerLine=x.width*d,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===Z.lineOrder?x.scanOrder=Z=>Z:x.scanOrder=Z=>x.height-1-Z,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}function JZ(Z,l,C,B){const x={value:0};for(let b=0;b<Z.height/Z.scanlineBlockSize;b++){const K=c(C,B)-l.dataWindow.yMin;Z.size=U(C,B),Z.lines=K+Z.scanlineBlockSize>Z.height?Z.height-K:Z.scanlineBlockSize;const f=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):ZZ(Z);B.value+=Z.size;for(let C=0;C<Z.scanlineBlockSize;C++){const B=b*Z.scanlineBlockSize,K=C+Z.scanOrder(B);if(K>=Z.height)continue;const W=C*Z.bytesPerLine,J=(Z.height-1-K)*Z.outLineWidth;for(let C=0;C<Z.channels;C++){const B=l.channels[C].name,b=Z.channelLineOffsets[B],K=Z.decodeChannels[B];if(void 0!==K){x.value=W+b;for(let l=0;l<Z.width;l++){const C=J+l*Z.outputChannels+K;Z.byteArray&&(Z.byteArray[C]=Z.getter(f,x))}}}}}}fZ.DefaultOutputType=bZ.HalfFloat,fZ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dZ{constructor(){this.supportCascades=!1}loadCubeData(Z,l,C,B,x){throw".exr not supported in Cube."}loadData(Z,l,C){const x=new DataView(Z.buffer),b={value:0},K=I(x,b);WZ(K,x,b,fZ.DefaultOutputType).then((Z=>{JZ(Z,K,x,b);const B=K.dataWindow.xMax-K.dataWindow.xMin+1,f=K.dataWindow.yMax-K.dataWindow.yMin+1;C(B,f,l.generateMipMaps,!1,(()=>{const C=l.getEngine();l.format=K.format,l.type=Z.textureType,l.invertY=!1,l._gammaSpace=!K.linearSpace,Z.byteArray&&C._uploadDataToTextureDirectly(l,Z.byteArray,0,0,void 0,!0)}))})).catch((Z=>{B.e.Error("Failed to load EXR texture: ",Z)}))}}async function EZ(Z){const l=new DataView(Z),C={value:0},x=I(l,C);try{const Z=await WZ(x,l,C,bZ.Float);return JZ(Z,x,l,C),Z.byteArray?{width:x.dataWindow.xMax-x.dataWindow.xMin+1,height:x.dataWindow.yMax-x.dataWindow.yMin+1,data:new Float32Array(Z.byteArray)}:(B.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(b){B.e.Error("Failed to load EXR data: ",b)}return{width:0,height:0,data:null}}},12460:(Z,l,C)=>{function B(Z){return parseInt(Z.toString().replace(/\W/g,""))}function x(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-l)<=C}function b(Z,l,C){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<l-B||Z>C+B}function K(Z,l){return Z===l?Z:Math.random()*(l-Z)+Z}function f(Z,l,C){return Z+(l-Z)*C}function W(Z,l,C){let B=Y(l-Z,360);return B>180&&(B-=360),Z+B*G(C)}function J(Z,l,C){let B=0;return B=Z!=l?G((C-Z)/(l-Z)):0,B}function d(Z,l,C,B,x){const b=x*x,K=x*b;return Z*(2*K-3*b+1)+C*(-2*K+3*b)+l*(K-2*b+x)+B*(K-b)}function E(Z,l,C,B,x){const b=x*x;return 6*(b-x)*Z+(3*b-4*x+1)*l+6*(-b+x)*C+(3*b-2*x)*B}function G(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(l,Z))}function a(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function q(Z){const l=Z.toString(16);return Z<=15?("0"+l).toUpperCase():l.toUpperCase()}function z(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let l=0;if(Z<1){for(;Z<1;)l++,Z*=2;l=-l}else if(Z>1)for(;Z>1;)l++,Z=Math.floor(Z/2);return l}function Y(Z,l){return Z-Math.floor(Z/l)*l}function P(Z,l,C){return(Z-l)/(C-l)}function S(Z,l,C){return Z*(C-l)+l}function i(Z,l){let C=Y(l-Z,360);return C>180&&(C-=360),C}function s(Z,l){const C=Y(Z,2*l);return l-Math.abs(C-l)}function F(Z,l,C){let B=G(C);return B=-2*B*B*B+3*B*B,l*B+Z*(1-B)}function n(Z,l,C){let B=0;return B=Math.abs(l-Z)<=C?l:Z+Math.sign(l-Z)*C,B}function c(Z,l,C){const B=i(Z,l);let x=0;return x=-C<B&&B<C?l:n(Z,l=Z+B,C),x}function U(Z,l,C){return(Z-l)/(C-l)}function t(Z,l,C){return(C-l)*Z+l}function r(Z,l){const C=Z%l;return 0===C?l:r(l,C)}C.r(l),C.d(l,{Clamp:()=>G,DeltaAngle:()=>i,Denormalize:()=>S,ExtractAsInt:()=>B,Hermite:()=>d,Hermite1stDerivative:()=>E,HighestCommonFactor:()=>r,ILog2:()=>z,InverseLerp:()=>J,Lerp:()=>f,LerpAngle:()=>W,MoveTowards:()=>n,MoveTowardsAngle:()=>c,Normalize:()=>P,NormalizeRadians:()=>a,OutsideRange:()=>b,PercentToRange:()=>t,PingPong:()=>s,RandomRange:()=>K,RangeToPercent:()=>U,Repeat:()=>Y,SmoothStep:()=>F,ToHex:()=>q,WithinEpsilon:()=>x})}}]);