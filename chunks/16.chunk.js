"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[16],{15397:(Y,b,C)=>{C.r(b),C.d(b,{ReadExrDataAsync:()=>FY,_ExrTextureLoader:()=>OY});var R=C(12669),q=C(12852);const A=4,E=4,B=1,g=2,r=8,O=65536,F=O>>3,y=14,S=65537,n=1<<y,t=n-1,I=59,w=63,Q=2+w-I;var N,p;!function(Y){Y[Y.NO_COMPRESSION=0]="NO_COMPRESSION",Y[Y.RLE_COMPRESSION=1]="RLE_COMPRESSION",Y[Y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Y[Y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Y[Y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Y[Y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(N||(N={})),function(Y){Y[Y.INCREASING_Y=0]="INCREASING_Y",Y[Y.DECREASING_Y=1]="DECREASING_Y"}(p||(p={}));const mY=function(){const Y=new ArrayBuffer(4),b=new Float32Array(Y),C=new Uint32Array(Y),R=new Uint32Array(512),q=new Uint32Array(512);for(let g=0;g<256;++g){const Y=g-127;Y<-27?(R[g]=0,R[256|g]=32768,q[g]=24,q[256|g]=24):Y<-14?(R[g]=1024>>-Y-14,R[256|g]=1024>>-Y-14|32768,q[g]=-Y-1,q[256|g]=-Y-1):Y<=15?(R[g]=Y+15<<10,R[256|g]=Y+15<<10|32768,q[g]=13,q[256|g]=13):Y<128?(R[g]=31744,R[256|g]=64512,q[g]=24,q[256|g]=24):(R[g]=31744,R[256|g]=64512,q[g]=13,q[256|g]=13)}const A=new Uint32Array(2048),E=new Uint32Array(64),B=new Uint32Array(64);for(let g=1;g<1024;++g){let Y=g<<13,b=0;for(;0===(8388608&Y);)Y<<=1,b-=8388608;Y&=-8388609,b+=947912704,A[g]=Y|b}for(let g=1024;g<2048;++g)A[g]=939524096+(g-1024<<13);for(let g=1;g<31;++g)E[g]=g<<23;E[31]=1199570944,E[32]=2147483648;for(let g=33;g<63;++g)E[g]=2147483648+(g-32<<23);E[63]=3347054592;for(let g=1;g<64;++g)32!==g&&(B[g]=1024);return{floatView:b,uint32View:C,baseTable:R,shiftTable:q,mantissaTable:A,exponentTable:E,offsetTable:B}}();function L(Y,b){const C=new Uint8Array(Y);let R=0;for(;0!=C[b.value+R];)R+=1;const q=(new TextDecoder).decode(C.slice(b.value,b.value+R));return b.value=b.value+R+1,q}function u(Y,b){const C=Y.getInt32(b.value,!0);return b.value+=A,C}function c(Y,b){const C=Y.getUint32(b.value,!0);return b.value+=A,C}function l(Y,b){const C=Y.getUint8(b.value);return b.value+=B,C}function X(Y,b){const C=Y.getUint16(b.value,!0);return b.value+=g,C}function j(Y,b){const C=Y[b.value];return b.value+=B,C}function T(Y,b){let C;return C="getBigInt64"in DataView.prototype?Number(Y.getBigInt64(b.value,!0)):Y.getUint32(b.value+4,!0)+Number(Y.getUint32(b.value,!0)<<32),b.value+=r,C}function P(Y,b){const C=Y.getFloat32(b.value,!0);return b.value+=E,C}function v(Y,b){return function(Y){const b=(31744&Y)>>10,C=1023&Y;return(Y>>15?-1:1)*(b?31===b?C?NaN:1/0:Math.pow(2,b-15)*(1+C/1024):C/1024*6103515625e-14)}(X(Y,b))}function z(Y,b){return function(Y){if(Math.abs(Y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Y=(0,q.Clamp)(Y,-65504,65504),mY.floatView[0]=Y;const b=mY.uint32View[0],C=b>>23&511;return mY.baseTable[C]+((8388607&b)>>mY.shiftTable[C])}(P(Y,b))}function J(Y,b,C,R){switch(C){case"string":case"stringvector":case"iccProfile":return function(Y,b,C){const R=(new TextDecoder).decode(new Uint8Array(Y).slice(b.value,b.value+C));return b.value=b.value+C,R}(Y.buffer,b,R);case"chlist":return function(Y,b,C){const R=b.value,q=[];for(;b.value<R+C-1;){const C=L(Y.buffer,b),R=u(Y,b),A=l(Y,b);b.value+=3;const E=u(Y,b),B=u(Y,b);q.push({name:C,pixelType:R,pLinear:A,xSampling:E,ySampling:B})}return b.value+=1,q}(Y,b,R);case"chromaticities":return function(Y,b){return{redX:P(Y,b),redY:P(Y,b),greenX:P(Y,b),greenY:P(Y,b),blueX:P(Y,b),blueY:P(Y,b),whiteX:P(Y,b),whiteY:P(Y,b)}}(Y,b);case"compression":return function(Y,b){return l(Y,b)}(Y,b);case"box2i":return function(Y,b){return{xMin:u(Y,b),yMin:u(Y,b),xMax:u(Y,b),yMax:u(Y,b)}}(Y,b);case"lineOrder":return function(Y,b){const C=l(Y,b);return p[C]}(Y,b);case"float":return P(Y,b);case"v2f":return function(Y,b){return[P(Y,b),P(Y,b)]}(Y,b);case"v3f":return function(Y,b){return[P(Y,b),P(Y,b),P(Y,b)]}(Y,b);case"int":return u(Y,b);case"rational":return function(Y,b){return[u(Y,b),c(Y,b)]}(Y,b);case"timecode":return function(Y,b){return[c(Y,b),c(Y,b)]}(Y,b);case"preview":return b.value+=R,"skipped";default:return void(b.value+=R)}}function U(Y){for(let b=1;b<Y.length;b++){const C=Y[b-1]+Y[b]-128;Y[b]=C}}function o(Y,b){let C=0,R=Math.floor((Y.length+1)/2),q=0;const A=Y.length-1;for(;!(q>A)&&(b[q++]=Y[C++],!(q>A));)b[q++]=Y[R++]}const G=20000630;function h(Y,b){if(Y.getUint32(0,!0)!=G)throw new Error("Incorrect OpenEXR format");const C=Y.getUint8(4),q=Y.getUint8(5),A={singleTile:!!(2&q),longName:!!(4&q),deepFormat:!!(8&q),multiPart:!!(16&q)};b.value=8;const E={};let B=!0;for(;B;){const C=L(Y.buffer,b);if(C){const q=L(Y.buffer,b),A=J(Y,b,q,c(Y,b));void 0===A?R.e.Warn(`Unknown header attribute type ${q}'.`):E[C]=A}else B=!1}if(0!=(-5&q))throw new Error("Unsupported file format");return{version:C,spec:A,...E}}const e=32768,H=65535;function i(Y,b,C,R,q){for(;C<Y;)b=b<<8|j(R,q),C+=8;return{l:b>>(C-=Y)&(1<<Y)-1,c:b,lc:C}}function W(Y,b,C,R){return{c:Y=Y<<8|j(C,R),lc:b+=8}}function s(Y,b,C,R,q,A,E,B,g){if(Y==b){if(R<8){const Y=W(C,R,q,A);C=Y.c,R=Y.lc}let Y=C>>(R-=8);if(Y=new Uint8Array([Y])[0],B.value+Y>g)return null;const b=E[B.value-1];for(;Y-- >0;)E[B.value++]=b}else{if(!(B.value<g))return null;E[B.value++]=Y}return{c:C,lc:R}}const D=new Array(59);function d(Y,b,C,R,q,A){const E=b;let B=0,g=0;for(;R<=q;R++){if(E.value-b.value>C)return;let r=i(6,B,g,Y,E);const O=r.l;if(B=r.c,g=r.lc,A[R]=O,O==w){if(E.value-b.value>C)throw new Error("Error in HufUnpackEncTable");r=i(8,B,g,Y,E);let O=r.l+Q;if(B=r.c,g=r.lc,R+O>q+1)throw new Error("Error in HufUnpackEncTable");for(;O--;)A[R++]=0;R--}else if(O>=I){let Y=O-I+2;if(R+Y>q+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)A[R++]=0;R--}}!function(Y){for(let C=0;C<=58;++C)D[C]=0;for(let C=0;C<S;++C)D[Y[C]]+=1;let b=0;for(let C=58;C>0;--C){const Y=b+D[C]>>1;D[C]=b,b=Y}for(let C=0;C<S;++C){const b=Y[C];b>0&&(Y[C]=b|D[b]++<<6)}}(A)}function V(Y){return 63&Y}function k(Y){return Y>>6}function x(Y,b,C,R,q,A){const E=C.value,B=c(b,C),g=c(b,C);C.value+=4;const r=c(b,C);if(C.value+=4,B<0||B>=S||g<0||g>=S)throw new Error("Wrong HUF_ENCSIZE");const O=new Array(S),F=new Array(n);!function(Y){for(let b=0;b<n;b++)Y[b]={},Y[b].len=0,Y[b].lit=0,Y[b].p=null}(F);if(d(Y,C,R-(C.value-E),B,g,O),r>8*(R-(C.value-E)))throw new Error("Wrong hufUncompress");!function(Y,b,C,R){for(;b<=C;b++){const C=k(Y[b]),q=V(Y[b]);if(C>>q)throw new Error("Invalid table entry");if(q>y){const Y=R[C>>q-y];if(Y.len)throw new Error("Invalid table entry");if(Y.lit++,Y.p){const b=Y.p;Y.p=new Array(Y.lit);for(let C=0;C<Y.lit-1;++C)Y.p[C]=b[C]}else Y.p=new Array(1);Y.p[Y.lit-1]=b}else if(q){let Y=0;for(let A=1<<y-q;A>0;A--){const A=R[(C<<y-q)+Y];if(A.len||A.p)throw new Error("Invalid table entry");A.len=q,A.lit=b,Y++}}}}(O,B,g,F),function(Y,b,C,R,q,A,E,B,g){let r=0,O=0;const F=E,S=Math.trunc(R.value+(q+7)/8);for(;R.value<S;){let q=W(r,O,C,R);for(r=q.c,O=q.lc;O>=y;){const E=b[r>>O-y&t];if(E.len){O-=E.len;const Y=s(E.lit,A,r,O,C,R,B,g,F);Y&&(r=Y.c,O=Y.lc)}else{if(!E.p)throw new Error("hufDecode issues");let b;for(b=0;b<E.lit;b++){const y=V(Y[E.p[b]]);for(;O<y&&R.value<S;)q=W(r,O,C,R),r=q.c,O=q.lc;if(O>=y&&k(Y[E.p[b]])==(r>>O-y&(1<<y)-1)){O-=y;const Y=s(E.p[b],A,r,O,C,R,B,g,F);Y&&(r=Y.c,O=Y.lc);break}}if(b==E.lit)throw new Error("HufDecode issues")}}}const n=8-q&7;for(r>>=n,O-=n;O>0;){const Y=b[r<<y-O&t];if(!Y.len)throw new Error("HufDecode issues");{O-=Y.len;const b=s(Y.lit,A,r,O,C,R,B,g,F);b&&(r=b.c,O=b.lc)}}}(O,F,Y,C,r,g,A,q,{value:0})}function a(Y){return 65535&Y}function M(Y){const b=a(Y);return b>32767?b-65536:b}function K(Y,b){const C=M(Y),R=M(b),q=C+(1&R)+(R>>1);return{a:q,b:q-R}}function f(Y,b){const C=a(Y),R=a(b),q=C-(R>>1)&H;return{a:R+q-e&H,b:q}}function Z(Y,b,C,R,q,A,E){const B=E<16384,g=C>q?q:C;let r,O,F=1;for(;F<=g;)F<<=1;for(F>>=1,r=F,F>>=1;F>=1;){O=0;const E=O+A*(q-r),g=A*F,y=A*r,S=R*F,n=R*r;let t,I,w,Q;for(;O<=E;O+=y){let q=O;const A=O+R*(C-r);for(;q<=A;q+=n){const C=q+S,R=q+g,A=R+S;if(B){let E=K(Y[q+b],Y[R+b]);t=E.a,w=E.b,E=K(Y[C+b],Y[A+b]),I=E.a,Q=E.b,E=K(t,I),Y[q+b]=E.a,Y[C+b]=E.b,E=K(w,Q),Y[R+b]=E.a,Y[A+b]=E.b}else{let E=f(Y[q+b],Y[R+b]);t=E.a,w=E.b,E=f(Y[C+b],Y[A+b]),I=E.a,Q=E.b,E=f(t,I),Y[q+b]=E.a,Y[C+b]=E.b,E=f(w,Q),Y[R+b]=E.a,Y[A+b]=E.b}}if(C&F){const C=q+g;let R;R=B?K(Y[q+b],Y[C+b]):f(Y[q+b],Y[C+b]),t=R.a,Y[C+b]=R.b,Y[q+b]=t}}if(q&F){let q=O;const A=O+R*(C-r);for(;q<=A;q+=n){const C=q+S;let R;R=B?K(Y[q+b],Y[C+b]):f(Y[q+b],Y[C+b]),t=R.a,Y[C+b]=R.b,Y[q+b]=t}}r=F,F>>=1}return O}function YY(Y){return new DataView(Y.array.buffer,Y.offset.value,Y.size)}function bY(Y){const b=Y.viewer.buffer.slice(Y.offset.value,Y.offset.value+Y.size),C=new Uint8Array(function(Y){let b=Y.byteLength;const C=[];let R=0;const q=new DataView(Y);for(;b>0;){const Y=q.getInt8(R++);if(Y<0){const A=-Y;b-=A+1;for(let Y=0;Y<A;Y++)C.push(q.getUint8(R++))}else{const A=Y;b-=2;const E=q.getUint8(R++);for(let Y=0;Y<A+1;Y++)C.push(E)}}return C}(b)),R=new Uint8Array(C.length);return U(C),o(C,R),new DataView(R.buffer)}function CY(Y){const b=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),C=fflate.unzlibSync(b),R=new Uint8Array(C.length);return U(C),o(C,R),new DataView(R.buffer)}function RY(Y){const b=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),C=fflate.unzlibSync(b),R=Y.lines*Y.channels*Y.width,q=1==Y.type?new Uint16Array(R):new Uint32Array(R);let A=0,E=0;const B=new Array(4);for(let g=0;g<Y.lines;g++)for(let b=0;b<Y.channels;b++){let b=0;switch(Y.type){case 1:B[0]=A,B[1]=B[0]+Y.width,A=B[1]+Y.width;for(let R=0;R<Y.width;++R){b+=C[B[0]++]<<8|C[B[1]++],q[E]=b,E++}break;case 2:B[0]=A,B[1]=B[0]+Y.width,B[2]=B[1]+Y.width,A=B[2]+Y.width;for(let R=0;R<Y.width;++R){b+=C[B[0]++]<<24|C[B[1]++]<<16|C[B[2]++]<<8,q[E]=b,E++}}}return new DataView(q.buffer)}function qY(Y){const b=Y.viewer,C={value:Y.offset.value},R=new Uint16Array(Y.width*Y.scanlineBlockSize*(Y.channels*Y.type)),q=new Uint8Array(F);let A=0;const E=new Array(Y.channels);for(let g=0;g<Y.channels;g++)E[g]={},E[g].start=A,E[g].end=E[g].start,E[g].nx=Y.width,E[g].ny=Y.lines,E[g].size=Y.type,A+=E[g].nx*E[g].ny*E[g].size;const B=X(b,C),r=X(b,C);if(r>=F)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(B<=r)for(let g=0;g<r-B+1;g++)q[g+B]=l(b,C);const y=new Uint16Array(O),S=function(Y,b){let C=0;for(let q=0;q<O;++q)(0==q||Y[q>>3]&1<<(7&q))&&(b[C++]=q);const R=C-1;for(;C<O;)b[C++]=0;return R}(q,y),n=c(b,C);x(Y.array,b,C,n,R,A);for(let g=0;g<Y.channels;++g){const Y=E[g];for(let b=0;b<E[g].size;++b)Z(R,Y.start+b,Y.nx,Y.size,Y.ny,Y.nx*Y.size,S)}!function(Y,b,C){for(let R=0;R<C;++R)b[R]=Y[b[R]]}(y,R,A);let t=0;const I=new Uint8Array(R.buffer.byteLength);for(let O=0;O<Y.lines;O++)for(let b=0;b<Y.channels;b++){const Y=E[b],C=Y.nx*Y.size,q=new Uint8Array(R.buffer,Y.end*g,C*g);I.set(q,t),t+=C*g,Y.end+=C}return new DataView(I.buffer)}var AY,EY=C(12645);!function(Y){Y[Y.Float=0]="Float",Y[Y.HalfFloat=1]="HalfFloat"}(AY||(AY={}));class BY{}async function gY(Y,b,C,R){const q={size:0,viewer:b,array:new Uint8Array(b.buffer),offset:C,width:Y.dataWindow.xMax-Y.dataWindow.xMin+1,height:Y.dataWindow.yMax-Y.dataWindow.yMin+1,channels:Y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Y.compression){case N.NO_COMPRESSION:q.lines=1,q.uncompress=YY;break;case N.RLE_COMPRESSION:q.lines=1,q.uncompress=bY;break;case N.ZIPS_COMPRESSION:q.lines=1,q.uncompress=CY,await EY.Tools.LoadScriptAsync(BY.FFLATEUrl);break;case N.ZIP_COMPRESSION:q.lines=16,q.uncompress=CY,await EY.Tools.LoadScriptAsync(BY.FFLATEUrl);break;case N.PIZ_COMPRESSION:q.lines=32,q.uncompress=qY;break;case N.PXR24_COMPRESSION:q.lines=16,q.uncompress=RY,await EY.Tools.LoadScriptAsync(BY.FFLATEUrl);break;default:throw new Error(N[Y.compression]+" is unsupported")}q.scanlineBlockSize=q.lines;const A={};for(const E of Y.channels)switch(E.name){case"R":case"G":case"B":case"A":case"Y":A[E.name]=!0,q.type=E.pixelType}let B=!1;if(A.R&&A.G&&A.B&&A.A)q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(A.R&&A.G&&A.B)B=!0,q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(A.R&&A.G)q.outputChannels=2,q.decodeChannels={R:0,G:1};else if(A.R)q.outputChannels=1,q.decodeChannels={R:0};else{if(!A.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");q.outputChannels=1,q.decodeChannels={Y:0}}if(1===q.type)switch(R){case AY.Float:q.getter=v,q.inputSize=g;break;case AY.HalfFloat:q.getter=X,q.inputSize=g}else{if(2!==q.type)throw new Error("Unsupported pixelType "+q.type+" for "+Y.compression);switch(R){case AY.Float:q.getter=P,q.inputSize=E;break;case AY.HalfFloat:q.getter=z,q.inputSize=E}}q.blockCount=q.height/q.scanlineBlockSize;for(let E=0;E<q.blockCount;E++)T(b,C);const r=q.width*q.height*q.outputChannels;switch(R){case AY.Float:q.byteArray=new Float32Array(r),q.textureType=1,B&&q.byteArray.fill(1,0,r);break;case AY.HalfFloat:q.byteArray=new Uint16Array(r),q.textureType=2,B&&q.byteArray.fill(15360,0,r);break;default:throw new Error("Unsupported type: "+R)}let O=0;for(const E of Y.channels)void 0!==q.decodeChannels[E.name]&&(q.channelLineOffsets[E.name]=O*q.width),O+=2*E.pixelType;return q.bytesPerLine=q.width*O,q.outLineWidth=q.width*q.outputChannels,"INCREASING_Y"===Y.lineOrder?q.scanOrder=Y=>Y:q.scanOrder=Y=>q.height-1-Y,4==q.outputChannels?(q.format=5,q.linearSpace=!0):(q.format=6,q.linearSpace=!1),q}function rY(Y,b,C,R){const q={value:0};for(let A=0;A<Y.height/Y.scanlineBlockSize;A++){const E=u(C,R)-b.dataWindow.yMin;Y.size=c(C,R),Y.lines=E+Y.scanlineBlockSize>Y.height?Y.height-E:Y.scanlineBlockSize;const B=Y.size<Y.lines*Y.bytesPerLine&&Y.uncompress?Y.uncompress(Y):YY(Y);R.value+=Y.size;for(let C=0;C<Y.scanlineBlockSize;C++){const R=A*Y.scanlineBlockSize,E=C+Y.scanOrder(R);if(E>=Y.height)continue;const g=C*Y.bytesPerLine,r=(Y.height-1-E)*Y.outLineWidth;for(let C=0;C<Y.channels;C++){const R=b.channels[C].name,A=Y.channelLineOffsets[R],E=Y.decodeChannels[R];if(void 0!==E){q.value=g+A;for(let b=0;b<Y.width;b++){const C=r+b*Y.outputChannels+E;Y.byteArray&&(Y.byteArray[C]=Y.getter(B,q))}}}}}}BY.DefaultOutputType=AY.HalfFloat,BY.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class OY{constructor(){this.supportCascades=!1}loadCubeData(Y,b,C,R,q){throw".exr not supported in Cube."}loadData(Y,b,C){const q=new DataView(Y.buffer),A={value:0},E=h(q,A);gY(E,q,A,BY.DefaultOutputType).then((Y=>{rY(Y,E,q,A);const R=E.dataWindow.xMax-E.dataWindow.xMin+1,B=E.dataWindow.yMax-E.dataWindow.yMin+1;C(R,B,b.generateMipMaps,!1,(()=>{const C=b.getEngine();b.format=E.format,b.type=Y.textureType,b.invertY=!1,b._gammaSpace=!E.linearSpace,Y.byteArray&&C._uploadDataToTextureDirectly(b,Y.byteArray,0,0,void 0,!0)}))})).catch((Y=>{R.e.Error("Failed to load EXR texture: ",Y)}))}}async function FY(Y){const b=new DataView(Y),C={value:0},q=h(b,C);try{const Y=await gY(q,b,C,AY.Float);return rY(Y,q,b,C),Y.byteArray?{width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,data:new Float32Array(Y.byteArray)}:(R.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(A){R.e.Error("Failed to load EXR data: ",A)}return{width:0,height:0,data:null}}},12852:(Y,b,C)=>{function R(Y){return parseInt(Y.toString().replace(/\W/g,""))}function q(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Y-b)<=C}function A(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Y<b-R||Y>C+R}function E(Y,b){return Y===b?Y:Math.random()*(b-Y)+Y}function B(Y,b,C){return Y+(b-Y)*C}function g(Y,b,C){let R=I(b-Y,360);return R>180&&(R-=360),Y+R*y(C)}function r(Y,b,C){let R=0;return R=Y!=b?y((C-Y)/(b-Y)):0,R}function O(Y,b,C,R,q){const A=q*q,E=q*A;return Y*(2*E-3*A+1)+C*(-2*E+3*A)+b*(E-2*A+q)+R*(E-A)}function F(Y,b,C,R,q){const A=q*q;return 6*(A-q)*Y+(3*A-4*q+1)*b+6*(-A+q)*C+(3*A-2*q)*R}function y(Y){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(b,Y))}function S(Y){return Y-=2*Math.PI*Math.floor((Y+Math.PI)/(2*Math.PI))}function n(Y){const b=Y.toString(16);return Y<=15?("0"+b).toUpperCase():b.toUpperCase()}function t(Y){if(Math.log2)return Math.floor(Math.log2(Y));if(Y<0)return NaN;if(0===Y)return-1/0;let b=0;if(Y<1){for(;Y<1;)b++,Y*=2;b=-b}else if(Y>1)for(;Y>1;)b++,Y=Math.floor(Y/2);return b}function I(Y,b){return Y-Math.floor(Y/b)*b}function w(Y,b,C){return(Y-b)/(C-b)}function Q(Y,b,C){return Y*(C-b)+b}function N(Y,b){let C=I(b-Y,360);return C>180&&(C-=360),C}function p(Y,b){const C=I(Y,2*b);return b-Math.abs(C-b)}function mY(Y,b,C){let R=y(C);return R=-2*R*R*R+3*R*R,b*R+Y*(1-R)}function L(Y,b,C){let R=0;return R=Math.abs(b-Y)<=C?b:Y+Math.sign(b-Y)*C,R}function u(Y,b,C){const R=N(Y,b);let q=0;return q=-C<R&&R<C?b:L(Y,b=Y+R,C),q}function c(Y,b,C){return(Y-b)/(C-b)}function l(Y,b,C){return(C-b)*Y+b}function X(Y,b){const C=Y%b;return 0===C?b:X(b,C)}C.r(b),C.d(b,{Clamp:()=>y,DeltaAngle:()=>N,Denormalize:()=>Q,ExtractAsInt:()=>R,Hermite:()=>O,Hermite1stDerivative:()=>F,HighestCommonFactor:()=>X,ILog2:()=>t,InverseLerp:()=>r,Lerp:()=>B,LerpAngle:()=>g,MoveTowards:()=>L,MoveTowardsAngle:()=>u,Normalize:()=>w,NormalizeRadians:()=>S,OutsideRange:()=>A,PercentToRange:()=>l,PingPong:()=>p,RandomRange:()=>E,RangeToPercent:()=>c,Repeat:()=>I,SmoothStep:()=>mY,ToHex:()=>n,WithinEpsilon:()=>q})}}]);