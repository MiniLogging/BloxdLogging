"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[16],{14806:(y,S,I)=>{I.r(S),I.d(S,{ReadExrDataAsync:()=>Ky,_ExrTextureLoader:()=>uy});var V=I(12151),i=I(12338);const A=4,B=4,d=1,F=2,J=8,u=65536,K=u>>3,G=14,p=65537,L=1<<G,T=L-1,l=59,j=63,s=2+j-l;var O,f;!function(y){y[y.NO_COMPRESSION=0]="NO_COMPRESSION",y[y.RLE_COMPRESSION=1]="RLE_COMPRESSION",y[y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",y[y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",y[y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",y[y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(O||(O={})),function(y){y[y.INCREASING_Y=0]="INCREASING_Y",y[y.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const my=function(){const y=new ArrayBuffer(4),S=new Float32Array(y),I=new Uint32Array(y),V=new Uint32Array(512),i=new Uint32Array(512);for(let F=0;F<256;++F){const y=F-127;y<-27?(V[F]=0,V[256|F]=32768,i[F]=24,i[256|F]=24):y<-14?(V[F]=1024>>-y-14,V[256|F]=1024>>-y-14|32768,i[F]=-y-1,i[256|F]=-y-1):y<=15?(V[F]=y+15<<10,V[256|F]=y+15<<10|32768,i[F]=13,i[256|F]=13):y<128?(V[F]=31744,V[256|F]=64512,i[F]=24,i[256|F]=24):(V[F]=31744,V[256|F]=64512,i[F]=13,i[256|F]=13)}const A=new Uint32Array(2048),B=new Uint32Array(64),d=new Uint32Array(64);for(let F=1;F<1024;++F){let y=F<<13,S=0;for(;0===(8388608&y);)y<<=1,S-=8388608;y&=-8388609,S+=947912704,A[F]=y|S}for(let F=1024;F<2048;++F)A[F]=939524096+(F-1024<<13);for(let F=1;F<31;++F)B[F]=F<<23;B[31]=1199570944,B[32]=2147483648;for(let F=33;F<63;++F)B[F]=2147483648+(F-32<<23);B[63]=3347054592;for(let F=1;F<64;++F)32!==F&&(d[F]=1024);return{floatView:S,uint32View:I,baseTable:V,shiftTable:i,mantissaTable:A,exponentTable:B,offsetTable:d}}();function C(y,S){const I=new Uint8Array(y);let V=0;for(;0!=I[S.value+V];)V+=1;const i=(new TextDecoder).decode(I.slice(S.value,S.value+V));return S.value=S.value+V+1,i}function D(y,S){const I=y.getInt32(S.value,!0);return S.value+=A,I}function o(y,S){const I=y.getUint32(S.value,!0);return S.value+=A,I}function E(y,S){const I=y.getUint8(S.value);return S.value+=d,I}function z(y,S){const I=y.getUint16(S.value,!0);return S.value+=F,I}function r(y,S){const I=y[S.value];return S.value+=d,I}function h(y,S){let I;return I="getBigInt64"in DataView.prototype?Number(y.getBigInt64(S.value,!0)):y.getUint32(S.value+4,!0)+Number(y.getUint32(S.value,!0)<<32),S.value+=J,I}function n(y,S){const I=y.getFloat32(S.value,!0);return S.value+=B,I}function v(y,S){return function(y){const S=(31744&y)>>10,I=1023&y;return(y>>15?-1:1)*(S?31===S?I?NaN:1/0:Math.pow(2,S-15)*(1+I/1024):I/1024*6103515625e-14)}(z(y,S))}function P(y,S){return function(y){if(Math.abs(y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");y=(0,i.Clamp)(y,-65504,65504),my.floatView[0]=y;const S=my.uint32View[0],I=S>>23&511;return my.baseTable[I]+((8388607&S)>>my.shiftTable[I])}(n(y,S))}function q(y,S,I,V){switch(I){case"string":case"stringvector":case"iccProfile":return function(y,S,I){const V=(new TextDecoder).decode(new Uint8Array(y).slice(S.value,S.value+I));return S.value=S.value+I,V}(y.buffer,S,V);case"chlist":return function(y,S,I){const V=S.value,i=[];for(;S.value<V+I-1;){const I=C(y.buffer,S),V=D(y,S),A=E(y,S);S.value+=3;const B=D(y,S),d=D(y,S);i.push({name:I,pixelType:V,pLinear:A,xSampling:B,ySampling:d})}return S.value+=1,i}(y,S,V);case"chromaticities":return function(y,S){return{redX:n(y,S),redY:n(y,S),greenX:n(y,S),greenY:n(y,S),blueX:n(y,S),blueY:n(y,S),whiteX:n(y,S),whiteY:n(y,S)}}(y,S);case"compression":return function(y,S){return E(y,S)}(y,S);case"box2i":return function(y,S){return{xMin:D(y,S),yMin:D(y,S),xMax:D(y,S),yMax:D(y,S)}}(y,S);case"lineOrder":return function(y,S){const I=E(y,S);return f[I]}(y,S);case"float":return n(y,S);case"v2f":return function(y,S){return[n(y,S),n(y,S)]}(y,S);case"v3f":return function(y,S){return[n(y,S),n(y,S),n(y,S)]}(y,S);case"int":return D(y,S);case"rational":return function(y,S){return[D(y,S),o(y,S)]}(y,S);case"timecode":return function(y,S){return[o(y,S),o(y,S)]}(y,S);case"preview":return S.value+=V,"skipped";default:return void(S.value+=V)}}function g(y){for(let S=1;S<y.length;S++){const I=y[S-1]+y[S]-128;y[S]=I}}function k(y,S){let I=0,V=Math.floor((y.length+1)/2),i=0;const A=y.length-1;for(;!(i>A)&&(S[i++]=y[I++],!(i>A));)S[i++]=y[V++]}const R=20000630;function b(y,S){if(y.getUint32(0,!0)!=R)throw new Error("Incorrect OpenEXR format");const I=y.getUint8(4),i=y.getUint8(5),A={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)};S.value=8;const B={};let d=!0;for(;d;){const I=C(y.buffer,S);if(I){const i=C(y.buffer,S),A=q(y,S,i,o(y,S));void 0===A?V.b.Warn(`Unknown header attribute type ${i}'.`):B[I]=A}else d=!1}if(0!=(-5&i))throw new Error("Unsupported file format");return{version:I,spec:A,...B}}const U=32768,W=65535;function a(y,S,I,V,i){for(;I<y;)S=S<<8|r(V,i),I+=8;return{l:S>>(I-=y)&(1<<y)-1,c:S,lc:I}}function e(y,S,I,V){return{c:y=y<<8|r(I,V),lc:S+=8}}function x(y,S,I,V,i,A,B,d,F){if(y==S){if(V<8){const y=e(I,V,i,A);I=y.c,V=y.lc}let y=I>>(V-=8);if(y=new Uint8Array([y])[0],d.value+y>F)return null;const S=B[d.value-1];for(;y-- >0;)B[d.value++]=S}else{if(!(d.value<F))return null;B[d.value++]=y}return{c:I,lc:V}}const Q=new Array(59);function c(y,S,I,V,i,A){const B=S;let d=0,F=0;for(;V<=i;V++){if(B.value-S.value>I)return;let J=a(6,d,F,y,B);const u=J.l;if(d=J.c,F=J.lc,A[V]=u,u==j){if(B.value-S.value>I)throw new Error("Error in HufUnpackEncTable");J=a(8,d,F,y,B);let u=J.l+s;if(d=J.c,F=J.lc,V+u>i+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)A[V++]=0;V--}else if(u>=l){let y=u-l+2;if(V+y>i+1)throw new Error("Error in HufUnpackEncTable");for(;y--;)A[V++]=0;V--}}!function(y){for(let I=0;I<=58;++I)Q[I]=0;for(let I=0;I<p;++I)Q[y[I]]+=1;let S=0;for(let I=58;I>0;--I){const y=S+Q[I]>>1;Q[I]=S,S=y}for(let I=0;I<p;++I){const S=y[I];S>0&&(y[I]=S|Q[S]++<<6)}}(A)}function X(y){return 63&y}function M(y){return y>>6}function t(y,S,I,V,i,A){const B=I.value,d=o(S,I),F=o(S,I);I.value+=4;const J=o(S,I);if(I.value+=4,d<0||d>=p||F<0||F>=p)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(p),K=new Array(L);!function(y){for(let S=0;S<L;S++)y[S]={},y[S].len=0,y[S].lit=0,y[S].p=null}(K);if(c(y,I,V-(I.value-B),d,F,u),J>8*(V-(I.value-B)))throw new Error("Wrong hufUncompress");!function(y,S,I,V){for(;S<=I;S++){const I=M(y[S]),i=X(y[S]);if(I>>i)throw new Error("Invalid table entry");if(i>G){const y=V[I>>i-G];if(y.len)throw new Error("Invalid table entry");if(y.lit++,y.p){const S=y.p;y.p=new Array(y.lit);for(let I=0;I<y.lit-1;++I)y.p[I]=S[I]}else y.p=new Array(1);y.p[y.lit-1]=S}else if(i){let y=0;for(let A=1<<G-i;A>0;A--){const A=V[(I<<G-i)+y];if(A.len||A.p)throw new Error("Invalid table entry");A.len=i,A.lit=S,y++}}}}(u,d,F,K),function(y,S,I,V,i,A,B,d,F){let J=0,u=0;const K=B,p=Math.trunc(V.value+(i+7)/8);for(;V.value<p;){let i=e(J,u,I,V);for(J=i.c,u=i.lc;u>=G;){const B=S[J>>u-G&T];if(B.len){u-=B.len;const y=x(B.lit,A,J,u,I,V,d,F,K);y&&(J=y.c,u=y.lc)}else{if(!B.p)throw new Error("hufDecode issues");let S;for(S=0;S<B.lit;S++){const G=X(y[B.p[S]]);for(;u<G&&V.value<p;)i=e(J,u,I,V),J=i.c,u=i.lc;if(u>=G&&M(y[B.p[S]])==(J>>u-G&(1<<G)-1)){u-=G;const y=x(B.p[S],A,J,u,I,V,d,F,K);y&&(J=y.c,u=y.lc);break}}if(S==B.lit)throw new Error("HufDecode issues")}}}const L=8-i&7;for(J>>=L,u-=L;u>0;){const y=S[J<<G-u&T];if(!y.len)throw new Error("HufDecode issues");{u-=y.len;const S=x(y.lit,A,J,u,I,V,d,F,K);S&&(J=S.c,u=S.lc)}}}(u,K,y,I,J,F,A,i,{value:0})}function N(y){return 65535&y}function Y(y){const S=N(y);return S>32767?S-65536:S}function H(y,S){const I=Y(y),V=Y(S),i=I+(1&V)+(V>>1);return{a:i,b:i-V}}function Z(y,S){const I=N(y),V=N(S),i=I-(V>>1)&W;return{a:V+i-U&W,b:i}}function w(y,S,I,V,i,A,B){const d=B<16384,F=I>i?i:I;let J,u,K=1;for(;K<=F;)K<<=1;for(K>>=1,J=K,K>>=1;K>=1;){u=0;const B=u+A*(i-J),F=A*K,G=A*J,p=V*K,L=V*J;let T,l,j,s;for(;u<=B;u+=G){let i=u;const A=u+V*(I-J);for(;i<=A;i+=L){const I=i+p,V=i+F,A=V+p;if(d){let B=H(y[i+S],y[V+S]);T=B.a,j=B.b,B=H(y[I+S],y[A+S]),l=B.a,s=B.b,B=H(T,l),y[i+S]=B.a,y[I+S]=B.b,B=H(j,s),y[V+S]=B.a,y[A+S]=B.b}else{let B=Z(y[i+S],y[V+S]);T=B.a,j=B.b,B=Z(y[I+S],y[A+S]),l=B.a,s=B.b,B=Z(T,l),y[i+S]=B.a,y[I+S]=B.b,B=Z(j,s),y[V+S]=B.a,y[A+S]=B.b}}if(I&K){const I=i+F;let V;V=d?H(y[i+S],y[I+S]):Z(y[i+S],y[I+S]),T=V.a,y[I+S]=V.b,y[i+S]=T}}if(i&K){let i=u;const A=u+V*(I-J);for(;i<=A;i+=L){const I=i+p;let V;V=d?H(y[i+S],y[I+S]):Z(y[i+S],y[I+S]),T=V.a,y[I+S]=V.b,y[i+S]=T}}J=K,K>>=1}return u}function yy(y){return new DataView(y.array.buffer,y.offset.value,y.size)}function Sy(y){const S=y.viewer.buffer.slice(y.offset.value,y.offset.value+y.size),I=new Uint8Array(function(y){let S=y.byteLength;const I=[];let V=0;const i=new DataView(y);for(;S>0;){const y=i.getInt8(V++);if(y<0){const A=-y;S-=A+1;for(let y=0;y<A;y++)I.push(i.getUint8(V++))}else{const A=y;S-=2;const B=i.getUint8(V++);for(let y=0;y<A+1;y++)I.push(B)}}return I}(S)),V=new Uint8Array(I.length);return g(I),k(I,V),new DataView(V.buffer)}function Iy(y){const S=y.array.slice(y.offset.value,y.offset.value+y.size),I=fflate.unzlibSync(S),V=new Uint8Array(I.length);return g(I),k(I,V),new DataView(V.buffer)}function Vy(y){const S=y.array.slice(y.offset.value,y.offset.value+y.size),I=fflate.unzlibSync(S),V=y.lines*y.channels*y.width,i=1==y.type?new Uint16Array(V):new Uint32Array(V);let A=0,B=0;const d=new Array(4);for(let F=0;F<y.lines;F++)for(let S=0;S<y.channels;S++){let S=0;switch(y.type){case 1:d[0]=A,d[1]=d[0]+y.width,A=d[1]+y.width;for(let V=0;V<y.width;++V){S+=I[d[0]++]<<8|I[d[1]++],i[B]=S,B++}break;case 2:d[0]=A,d[1]=d[0]+y.width,d[2]=d[1]+y.width,A=d[2]+y.width;for(let V=0;V<y.width;++V){S+=I[d[0]++]<<24|I[d[1]++]<<16|I[d[2]++]<<8,i[B]=S,B++}}}return new DataView(i.buffer)}function iy(y){const S=y.viewer,I={value:y.offset.value},V=new Uint16Array(y.width*y.scanlineBlockSize*(y.channels*y.type)),i=new Uint8Array(K);let A=0;const B=new Array(y.channels);for(let F=0;F<y.channels;F++)B[F]={},B[F].start=A,B[F].end=B[F].start,B[F].nx=y.width,B[F].ny=y.lines,B[F].size=y.type,A+=B[F].nx*B[F].ny*B[F].size;const d=z(S,I),J=z(S,I);if(J>=K)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(d<=J)for(let F=0;F<J-d+1;F++)i[F+d]=E(S,I);const G=new Uint16Array(u),p=function(y,S){let I=0;for(let i=0;i<u;++i)(0==i||y[i>>3]&1<<(7&i))&&(S[I++]=i);const V=I-1;for(;I<u;)S[I++]=0;return V}(i,G),L=o(S,I);t(y.array,S,I,L,V,A);for(let F=0;F<y.channels;++F){const y=B[F];for(let S=0;S<B[F].size;++S)w(V,y.start+S,y.nx,y.size,y.ny,y.nx*y.size,p)}!function(y,S,I){for(let V=0;V<I;++V)S[V]=y[S[V]]}(G,V,A);let T=0;const l=new Uint8Array(V.buffer.byteLength);for(let u=0;u<y.lines;u++)for(let S=0;S<y.channels;S++){const y=B[S],I=y.nx*y.size,i=new Uint8Array(V.buffer,y.end*F,I*F);l.set(i,T),T+=I*F,y.end+=I}return new DataView(l.buffer)}var Ay,By=I(12128);!function(y){y[y.Float=0]="Float",y[y.HalfFloat=1]="HalfFloat"}(Ay||(Ay={}));class dy{}async function Fy(y,S,I,V){const i={size:0,viewer:S,array:new Uint8Array(S.buffer),offset:I,width:y.dataWindow.xMax-y.dataWindow.xMin+1,height:y.dataWindow.yMax-y.dataWindow.yMin+1,channels:y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(y.compression){case O.NO_COMPRESSION:i.lines=1,i.uncompress=yy;break;case O.RLE_COMPRESSION:i.lines=1,i.uncompress=Sy;break;case O.ZIPS_COMPRESSION:i.lines=1,i.uncompress=Iy,await By.Tools.LoadScriptAsync(dy.FFLATEUrl);break;case O.ZIP_COMPRESSION:i.lines=16,i.uncompress=Iy,await By.Tools.LoadScriptAsync(dy.FFLATEUrl);break;case O.PIZ_COMPRESSION:i.lines=32,i.uncompress=iy;break;case O.PXR24_COMPRESSION:i.lines=16,i.uncompress=Vy,await By.Tools.LoadScriptAsync(dy.FFLATEUrl);break;default:throw new Error(O[y.compression]+" is unsupported")}i.scanlineBlockSize=i.lines;const A={};for(const B of y.channels)switch(B.name){case"R":case"G":case"B":case"A":case"Y":A[B.name]=!0,i.type=B.pixelType}let d=!1;if(A.R&&A.G&&A.B&&A.A)i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else if(A.R&&A.G&&A.B)d=!0,i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else if(A.R&&A.G)i.outputChannels=2,i.decodeChannels={R:0,G:1};else if(A.R)i.outputChannels=1,i.decodeChannels={R:0};else{if(!A.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");i.outputChannels=1,i.decodeChannels={Y:0}}if(1===i.type)switch(V){case Ay.Float:i.getter=v,i.inputSize=F;break;case Ay.HalfFloat:i.getter=z,i.inputSize=F}else{if(2!==i.type)throw new Error("Unsupported pixelType "+i.type+" for "+y.compression);switch(V){case Ay.Float:i.getter=n,i.inputSize=B;break;case Ay.HalfFloat:i.getter=P,i.inputSize=B}}i.blockCount=i.height/i.scanlineBlockSize;for(let B=0;B<i.blockCount;B++)h(S,I);const J=i.width*i.height*i.outputChannels;switch(V){case Ay.Float:i.byteArray=new Float32Array(J),i.textureType=1,d&&i.byteArray.fill(1,0,J);break;case Ay.HalfFloat:i.byteArray=new Uint16Array(J),i.textureType=2,d&&i.byteArray.fill(15360,0,J);break;default:throw new Error("Unsupported type: "+V)}let u=0;for(const B of y.channels)void 0!==i.decodeChannels[B.name]&&(i.channelLineOffsets[B.name]=u*i.width),u+=2*B.pixelType;return i.bytesPerLine=i.width*u,i.outLineWidth=i.width*i.outputChannels,"INCREASING_Y"===y.lineOrder?i.scanOrder=y=>y:i.scanOrder=y=>i.height-1-y,4==i.outputChannels?(i.format=5,i.linearSpace=!0):(i.format=6,i.linearSpace=!1),i}function Jy(y,S,I,V){const i={value:0};for(let A=0;A<y.height/y.scanlineBlockSize;A++){const B=D(I,V)-S.dataWindow.yMin;y.size=o(I,V),y.lines=B+y.scanlineBlockSize>y.height?y.height-B:y.scanlineBlockSize;const d=y.size<y.lines*y.bytesPerLine&&y.uncompress?y.uncompress(y):yy(y);V.value+=y.size;for(let I=0;I<y.scanlineBlockSize;I++){const V=A*y.scanlineBlockSize,B=I+y.scanOrder(V);if(B>=y.height)continue;const F=I*y.bytesPerLine,J=(y.height-1-B)*y.outLineWidth;for(let I=0;I<y.channels;I++){const V=S.channels[I].name,A=y.channelLineOffsets[V],B=y.decodeChannels[V];if(void 0!==B){i.value=F+A;for(let S=0;S<y.width;S++){const I=J+S*y.outputChannels+B;y.byteArray&&(y.byteArray[I]=y.getter(d,i))}}}}}}dy.DefaultOutputType=Ay.HalfFloat,dy.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class uy{constructor(){this.supportCascades=!1}loadCubeData(y,S,I,V,i){throw".exr not supported in Cube."}loadData(y,S,I){const i=new DataView(y.buffer),A={value:0},B=b(i,A);Fy(B,i,A,dy.DefaultOutputType).then((y=>{Jy(y,B,i,A);const V=B.dataWindow.xMax-B.dataWindow.xMin+1,d=B.dataWindow.yMax-B.dataWindow.yMin+1;I(V,d,S.generateMipMaps,!1,(()=>{const I=S.getEngine();S.format=B.format,S.type=y.textureType,S.invertY=!1,S._gammaSpace=!B.linearSpace,y.byteArray&&I._uploadDataToTextureDirectly(S,y.byteArray,0,0,void 0,!0)}))})).catch((y=>{V.b.Error("Failed to load EXR texture: ",y)}))}}async function Ky(y){const S=new DataView(y),I={value:0},i=b(S,I);try{const y=await Fy(i,S,I,Ay.Float);return Jy(y,i,S,I),y.byteArray?{width:i.dataWindow.xMax-i.dataWindow.xMin+1,height:i.dataWindow.yMax-i.dataWindow.yMin+1,data:new Float32Array(y.byteArray)}:(V.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(A){V.b.Error("Failed to load EXR data: ",A)}return{width:0,height:0,data:null}}},12338:(y,S,I)=>{function V(y){return parseInt(y.toString().replace(/\W/g,""))}function i(y,S){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(y-S)<=I}function A(y,S,I){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return y<S-V||y>I+V}function B(y,S){return y===S?y:Math.random()*(S-y)+y}function d(y,S,I){return y+(S-y)*I}function F(y,S,I){let V=l(S-y,360);return V>180&&(V-=360),y+V*G(I)}function J(y,S,I){let V=0;return V=y!=S?G((I-y)/(S-y)):0,V}function u(y,S,I,V,i){const A=i*i,B=i*A;return y*(2*B-3*A+1)+I*(-2*B+3*A)+S*(B-2*A+i)+V*(B-A)}function K(y,S,I,V,i){const A=i*i;return 6*(A-i)*y+(3*A-4*i+1)*S+6*(-A+i)*I+(3*A-2*i)*V}function G(y){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(I,Math.max(S,y))}function p(y){return y-=2*Math.PI*Math.floor((y+Math.PI)/(2*Math.PI))}function L(y){const S=y.toString(16);return y<=15?("0"+S).toUpperCase():S.toUpperCase()}function T(y){if(Math.log2)return Math.floor(Math.log2(y));if(y<0)return NaN;if(0===y)return-1/0;let S=0;if(y<1){for(;y<1;)S++,y*=2;S=-S}else if(y>1)for(;y>1;)S++,y=Math.floor(y/2);return S}function l(y,S){return y-Math.floor(y/S)*S}function j(y,S,I){return(y-S)/(I-S)}function s(y,S,I){return y*(I-S)+S}function O(y,S){let I=l(S-y,360);return I>180&&(I-=360),I}function f(y,S){const I=l(y,2*S);return S-Math.abs(I-S)}function my(y,S,I){let V=G(I);return V=-2*V*V*V+3*V*V,S*V+y*(1-V)}function C(y,S,I){let V=0;return V=Math.abs(S-y)<=I?S:y+Math.sign(S-y)*I,V}function D(y,S,I){const V=O(y,S);let i=0;return i=-I<V&&V<I?S:C(y,S=y+V,I),i}function o(y,S,I){return(y-S)/(I-S)}function E(y,S,I){return(I-S)*y+S}function z(y,S){const I=y%S;return 0===I?S:z(S,I)}I.r(S),I.d(S,{Clamp:()=>G,DeltaAngle:()=>O,Denormalize:()=>s,ExtractAsInt:()=>V,Hermite:()=>u,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>z,ILog2:()=>T,InverseLerp:()=>J,Lerp:()=>d,LerpAngle:()=>F,MoveTowards:()=>C,MoveTowardsAngle:()=>D,Normalize:()=>j,NormalizeRadians:()=>p,OutsideRange:()=>A,PercentToRange:()=>E,PingPong:()=>f,RandomRange:()=>B,RangeToPercent:()=>o,Repeat:()=>l,SmoothStep:()=>my,ToHex:()=>L,WithinEpsilon:()=>i})}}]);