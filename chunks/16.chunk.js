"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13588:(q,S,b)=>{b.r(S),b.d(S,{ReadExrDataAsync:()=>lq,_ExrTextureLoader:()=>Vq});var z=b(10943),C=b(11121);const v=4,U=4,g=1,r=2,I=8,V=65536,l=V>>3,y=14,R=65537,G=1<<y,Z=G-1,H=59,Q=63,k=2+Q-H;var W,N;!function(q){q[q.NO_COMPRESSION=0]="NO_COMPRESSION",q[q.RLE_COMPRESSION=1]="RLE_COMPRESSION",q[q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",q[q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",q[q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",q[q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(W||(W={})),function(q){q[q.INCREASING_Y=0]="INCREASING_Y",q[q.DECREASING_Y=1]="DECREASING_Y"}(N||(N={}));const u=function(){const q=new ArrayBuffer(4),S=new Float32Array(q),b=new Uint32Array(q),z=new Uint32Array(512),C=new Uint32Array(512);for(let r=0;r<256;++r){const q=r-127;q<-27?(z[r]=0,z[256|r]=32768,C[r]=24,C[256|r]=24):q<-14?(z[r]=1024>>-q-14,z[256|r]=1024>>-q-14|32768,C[r]=-q-1,C[256|r]=-q-1):q<=15?(z[r]=q+15<<10,z[256|r]=q+15<<10|32768,C[r]=13,C[256|r]=13):q<128?(z[r]=31744,z[256|r]=64512,C[r]=24,C[256|r]=24):(z[r]=31744,z[256|r]=64512,C[r]=13,C[256|r]=13)}const v=new Uint32Array(2048),U=new Uint32Array(64),g=new Uint32Array(64);for(let r=1;r<1024;++r){let q=r<<13,S=0;for(;0===(8388608&q);)q<<=1,S-=8388608;q&=-8388609,S+=947912704,v[r]=q|S}for(let r=1024;r<2048;++r)v[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)U[r]=r<<23;U[31]=1199570944,U[32]=2147483648;for(let r=33;r<63;++r)U[r]=2147483648+(r-32<<23);U[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(g[r]=1024);return{floatView:S,uint32View:b,baseTable:z,shiftTable:C,mantissaTable:v,exponentTable:U,offsetTable:g}}();function X(q,S){const b=new Uint8Array(q);let z=0;for(;0!=b[S.value+z];)z+=1;const C=(new TextDecoder).decode(b.slice(S.value,S.value+z));return S.value=S.value+z+1,C}function T(q,S){const b=q.getInt32(S.value,!0);return S.value+=v,b}function B(q,S){const b=q.getUint32(S.value,!0);return S.value+=v,b}function t(q,S){const b=q.getUint8(S.value);return S.value+=g,b}function f(q,S){const b=q.getUint16(S.value,!0);return S.value+=r,b}function m(q,S){const b=q[S.value];return S.value+=g,b}function E(q,S){let b;return b="getBigInt64"in DataView.prototype?Number(q.getBigInt64(S.value,!0)):q.getUint32(S.value+4,!0)+Number(q.getUint32(S.value,!0)<<32),S.value+=I,b}function e(q,S){const b=q.getFloat32(S.value,!0);return S.value+=U,b}function i(q,S){return function(q){const S=(31744&q)>>10,b=1023&q;return(q>>15?-1:1)*(S?31===S?b?NaN:1/0:Math.pow(2,S-15)*(1+b/1024):b/1024*6103515625e-14)}(f(q,S))}function J(q,S){return function(q){if(Math.abs(q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");q=(0,C.Clamp)(q,-65504,65504),u.floatView[0]=q;const S=u.uint32View[0],b=S>>23&511;return u.baseTable[b]+((8388607&S)>>u.shiftTable[b])}(e(q,S))}function L(q,S,b,z){switch(b){case"string":case"stringvector":case"iccProfile":return function(q,S,b){const z=(new TextDecoder).decode(new Uint8Array(q).slice(S.value,S.value+b));return S.value=S.value+b,z}(q.buffer,S,z);case"chlist":return function(q,S,b){const z=S.value,C=[];for(;S.value<z+b-1;){const b=X(q.buffer,S),z=T(q,S),v=t(q,S);S.value+=3;const U=T(q,S),g=T(q,S);C.push({name:b,pixelType:z,pLinear:v,xSampling:U,ySampling:g})}return S.value+=1,C}(q,S,z);case"chromaticities":return function(q,S){return{redX:e(q,S),redY:e(q,S),greenX:e(q,S),greenY:e(q,S),blueX:e(q,S),blueY:e(q,S),whiteX:e(q,S),whiteY:e(q,S)}}(q,S);case"compression":return function(q,S){return t(q,S)}(q,S);case"box2i":return function(q,S){return{xMin:T(q,S),yMin:T(q,S),xMax:T(q,S),yMax:T(q,S)}}(q,S);case"lineOrder":return function(q,S){const b=t(q,S);return N[b]}(q,S);case"float":return e(q,S);case"v2f":return function(q,S){return[e(q,S),e(q,S)]}(q,S);case"v3f":return function(q,S){return[e(q,S),e(q,S),e(q,S)]}(q,S);case"int":return T(q,S);case"rational":return function(q,S){return[T(q,S),B(q,S)]}(q,S);case"timecode":return function(q,S){return[B(q,S),B(q,S)]}(q,S);case"preview":return S.value+=z,"skipped";default:return void(S.value+=z)}}function d(q){for(let S=1;S<q.length;S++){const b=q[S-1]+q[S]-128;q[S]=b}}function K(q,S){let b=0,z=Math.floor((q.length+1)/2),C=0;const v=q.length-1;for(;!(C>v)&&(S[C++]=q[b++],!(C>v));)S[C++]=q[z++]}const D=20000630;function x(q,S){if(q.getUint32(0,!0)!=D)throw new Error("Incorrect OpenEXR format");const b=q.getUint8(4),C=q.getUint8(5),v={singleTile:!!(2&C),longName:!!(4&C),deepFormat:!!(8&C),multiPart:!!(16&C)};S.value=8;const U={};let g=!0;for(;g;){const b=X(q.buffer,S);if(b){const C=X(q.buffer,S),v=L(q,S,C,B(q,S));void 0===v?z.b.Warn(`Unknown header attribute type ${C}'.`):U[b]=v}else g=!1}if(0!=(-5&C))throw new Error("Unsupported file format");return{version:b,spec:v,...U}}const F=32768,a=65535;function n(q,S,b,z,C){for(;b<q;)S=S<<8|m(z,C),b+=8;return{l:S>>(b-=q)&(1<<q)-1,c:S,lc:b}}function o(q,S,b,z){return{c:q=q<<8|m(b,z),lc:S+=8}}function s(q,S,b,z,C,v,U,g,r){if(q==S){if(z<8){const q=o(b,z,C,v);b=q.c,z=q.lc}let q=b>>(z-=8);if(q=new Uint8Array([q])[0],g.value+q>r)return null;const S=U[g.value-1];for(;q-- >0;)U[g.value++]=S}else{if(!(g.value<r))return null;U[g.value++]=q}return{c:b,lc:z}}const A=new Array(59);function w(q,S,b,z,C,v){const U=S;let g=0,r=0;for(;z<=C;z++){if(U.value-S.value>b)return;let I=n(6,g,r,q,U);const V=I.l;if(g=I.c,r=I.lc,v[z]=V,V==Q){if(U.value-S.value>b)throw new Error("Error in HufUnpackEncTable");I=n(8,g,r,q,U);let V=I.l+k;if(g=I.c,r=I.lc,z+V>C+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)v[z++]=0;z--}else if(V>=H){let q=V-H+2;if(z+q>C+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)v[z++]=0;z--}}!function(q){for(let b=0;b<=58;++b)A[b]=0;for(let b=0;b<R;++b)A[q[b]]+=1;let S=0;for(let b=58;b>0;--b){const q=S+A[b]>>1;A[b]=S,S=q}for(let b=0;b<R;++b){const S=q[b];S>0&&(q[b]=S|A[S]++<<6)}}(v)}function P(q){return 63&q}function h(q){return q>>6}function O(q,S,b,z,C,v){const U=b.value,g=B(S,b),r=B(S,b);b.value+=4;const I=B(S,b);if(b.value+=4,g<0||g>=R||r<0||r>=R)throw new Error("Wrong HUF_ENCSIZE");const V=new Array(R),l=new Array(G);!function(q){for(let S=0;S<G;S++)q[S]={},q[S].len=0,q[S].lit=0,q[S].p=null}(l);if(w(q,b,z-(b.value-U),g,r,V),I>8*(z-(b.value-U)))throw new Error("Wrong hufUncompress");!function(q,S,b,z){for(;S<=b;S++){const b=h(q[S]),C=P(q[S]);if(b>>C)throw new Error("Invalid table entry");if(C>y){const q=z[b>>C-y];if(q.len)throw new Error("Invalid table entry");if(q.lit++,q.p){const S=q.p;q.p=new Array(q.lit);for(let b=0;b<q.lit-1;++b)q.p[b]=S[b]}else q.p=new Array(1);q.p[q.lit-1]=S}else if(C){let q=0;for(let v=1<<y-C;v>0;v--){const v=z[(b<<y-C)+q];if(v.len||v.p)throw new Error("Invalid table entry");v.len=C,v.lit=S,q++}}}}(V,g,r,l),function(q,S,b,z,C,v,U,g,r){let I=0,V=0;const l=U,R=Math.trunc(z.value+(C+7)/8);for(;z.value<R;){let C=o(I,V,b,z);for(I=C.c,V=C.lc;V>=y;){const U=S[I>>V-y&Z];if(U.len){V-=U.len;const q=s(U.lit,v,I,V,b,z,g,r,l);q&&(I=q.c,V=q.lc)}else{if(!U.p)throw new Error("hufDecode issues");let S;for(S=0;S<U.lit;S++){const y=P(q[U.p[S]]);for(;V<y&&z.value<R;)C=o(I,V,b,z),I=C.c,V=C.lc;if(V>=y&&h(q[U.p[S]])==(I>>V-y&(1<<y)-1)){V-=y;const q=s(U.p[S],v,I,V,b,z,g,r,l);q&&(I=q.c,V=q.lc);break}}if(S==U.lit)throw new Error("HufDecode issues")}}}const G=8-C&7;for(I>>=G,V-=G;V>0;){const q=S[I<<y-V&Z];if(!q.len)throw new Error("HufDecode issues");{V-=q.len;const S=s(q.lit,v,I,V,b,z,g,r,l);S&&(I=S.c,V=S.lc)}}}(V,l,q,b,I,r,v,C,{value:0})}function j(q){return 65535&q}function M(q){const S=j(q);return S>32767?S-65536:S}function p(q,S){const b=M(q),z=M(S),C=b+(1&z)+(z>>1);return{a:C,b:C-z}}function Y(q,S){const b=j(q),z=j(S),C=b-(z>>1)&a;return{a:z+C-F&a,b:C}}function c(q,S,b,z,C,v,U){const g=U<16384,r=b>C?C:b;let I,V,l=1;for(;l<=r;)l<<=1;for(l>>=1,I=l,l>>=1;l>=1;){V=0;const U=V+v*(C-I),r=v*l,y=v*I,R=z*l,G=z*I;let Z,H,Q,k;for(;V<=U;V+=y){let C=V;const v=V+z*(b-I);for(;C<=v;C+=G){const b=C+R,z=C+r,v=z+R;if(g){let U=p(q[C+S],q[z+S]);Z=U.a,Q=U.b,U=p(q[b+S],q[v+S]),H=U.a,k=U.b,U=p(Z,H),q[C+S]=U.a,q[b+S]=U.b,U=p(Q,k),q[z+S]=U.a,q[v+S]=U.b}else{let U=Y(q[C+S],q[z+S]);Z=U.a,Q=U.b,U=Y(q[b+S],q[v+S]),H=U.a,k=U.b,U=Y(Z,H),q[C+S]=U.a,q[b+S]=U.b,U=Y(Q,k),q[z+S]=U.a,q[v+S]=U.b}}if(b&l){const b=C+r;let z;z=g?p(q[C+S],q[b+S]):Y(q[C+S],q[b+S]),Z=z.a,q[b+S]=z.b,q[C+S]=Z}}if(C&l){let C=V;const v=V+z*(b-I);for(;C<=v;C+=G){const b=C+R;let z;z=g?p(q[C+S],q[b+S]):Y(q[C+S],q[b+S]),Z=z.a,q[b+S]=z.b,q[C+S]=Z}}I=l,l>>=1}return V}function qq(q){return new DataView(q.array.buffer,q.offset.value,q.size)}function Sq(q){const S=q.viewer.buffer.slice(q.offset.value,q.offset.value+q.size),b=new Uint8Array(function(q){let S=q.byteLength;const b=[];let z=0;const C=new DataView(q);for(;S>0;){const q=C.getInt8(z++);if(q<0){const v=-q;S-=v+1;for(let q=0;q<v;q++)b.push(C.getUint8(z++))}else{const v=q;S-=2;const U=C.getUint8(z++);for(let q=0;q<v+1;q++)b.push(U)}}return b}(S)),z=new Uint8Array(b.length);return d(b),K(b,z),new DataView(z.buffer)}function bq(q){const S=q.array.slice(q.offset.value,q.offset.value+q.size),b=fflate.unzlibSync(S),z=new Uint8Array(b.length);return d(b),K(b,z),new DataView(z.buffer)}function zq(q){const S=q.array.slice(q.offset.value,q.offset.value+q.size),b=fflate.unzlibSync(S),z=q.lines*q.channels*q.width,C=1==q.type?new Uint16Array(z):new Uint32Array(z);let v=0,U=0;const g=new Array(4);for(let r=0;r<q.lines;r++)for(let S=0;S<q.channels;S++){let S=0;switch(q.type){case 1:g[0]=v,g[1]=g[0]+q.width,v=g[1]+q.width;for(let z=0;z<q.width;++z){S+=b[g[0]++]<<8|b[g[1]++],C[U]=S,U++}break;case 2:g[0]=v,g[1]=g[0]+q.width,g[2]=g[1]+q.width,v=g[2]+q.width;for(let z=0;z<q.width;++z){S+=b[g[0]++]<<24|b[g[1]++]<<16|b[g[2]++]<<8,C[U]=S,U++}}}return new DataView(C.buffer)}function Cq(q){const S=q.viewer,b={value:q.offset.value},z=new Uint16Array(q.width*q.scanlineBlockSize*(q.channels*q.type)),C=new Uint8Array(l);let v=0;const U=new Array(q.channels);for(let r=0;r<q.channels;r++)U[r]={},U[r].start=v,U[r].end=U[r].start,U[r].nx=q.width,U[r].ny=q.lines,U[r].size=q.type,v+=U[r].nx*U[r].ny*U[r].size;const g=f(S,b),I=f(S,b);if(I>=l)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(g<=I)for(let r=0;r<I-g+1;r++)C[r+g]=t(S,b);const y=new Uint16Array(V),R=function(q,S){let b=0;for(let C=0;C<V;++C)(0==C||q[C>>3]&1<<(7&C))&&(S[b++]=C);const z=b-1;for(;b<V;)S[b++]=0;return z}(C,y),G=B(S,b);O(q.array,S,b,G,z,v);for(let r=0;r<q.channels;++r){const q=U[r];for(let S=0;S<U[r].size;++S)c(z,q.start+S,q.nx,q.size,q.ny,q.nx*q.size,R)}!function(q,S,b){for(let z=0;z<b;++z)S[z]=q[S[z]]}(y,z,v);let Z=0;const H=new Uint8Array(z.buffer.byteLength);for(let V=0;V<q.lines;V++)for(let S=0;S<q.channels;S++){const q=U[S],b=q.nx*q.size,C=new Uint8Array(z.buffer,q.end*r,b*r);H.set(C,Z),Z+=b*r,q.end+=b}return new DataView(H.buffer)}var vq,Uq=b(10921);!function(q){q[q.Float=0]="Float",q[q.HalfFloat=1]="HalfFloat"}(vq||(vq={}));class gq{}async function rq(q,S,b,z){const C={size:0,viewer:S,array:new Uint8Array(S.buffer),offset:b,width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,channels:q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(q.compression){case W.NO_COMPRESSION:C.lines=1,C.uncompress=qq;break;case W.RLE_COMPRESSION:C.lines=1,C.uncompress=Sq;break;case W.ZIPS_COMPRESSION:C.lines=1,C.uncompress=bq,await Uq.Tools.LoadScriptAsync(gq.FFLATEUrl);break;case W.ZIP_COMPRESSION:C.lines=16,C.uncompress=bq,await Uq.Tools.LoadScriptAsync(gq.FFLATEUrl);break;case W.PIZ_COMPRESSION:C.lines=32,C.uncompress=Cq;break;case W.PXR24_COMPRESSION:C.lines=16,C.uncompress=zq,await Uq.Tools.LoadScriptAsync(gq.FFLATEUrl);break;default:throw new Error(W[q.compression]+" is unsupported")}C.scanlineBlockSize=C.lines;const v={};for(const U of q.channels)switch(U.name){case"R":case"G":case"B":case"A":case"Y":v[U.name]=!0,C.type=U.pixelType}let g=!1;if(v.R&&v.G&&v.B&&v.A)C.outputChannels=4,C.decodeChannels={R:0,G:1,B:2,A:3};else if(v.R&&v.G&&v.B)g=!0,C.outputChannels=4,C.decodeChannels={R:0,G:1,B:2,A:3};else if(v.R&&v.G)C.outputChannels=2,C.decodeChannels={R:0,G:1};else if(v.R)C.outputChannels=1,C.decodeChannels={R:0};else{if(!v.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");C.outputChannels=1,C.decodeChannels={Y:0}}if(1===C.type)switch(z){case vq.Float:C.getter=i,C.inputSize=r;break;case vq.HalfFloat:C.getter=f,C.inputSize=r}else{if(2!==C.type)throw new Error("Unsupported pixelType "+C.type+" for "+q.compression);switch(z){case vq.Float:C.getter=e,C.inputSize=U;break;case vq.HalfFloat:C.getter=J,C.inputSize=U}}C.blockCount=C.height/C.scanlineBlockSize;for(let U=0;U<C.blockCount;U++)E(S,b);const I=C.width*C.height*C.outputChannels;switch(z){case vq.Float:C.byteArray=new Float32Array(I),C.textureType=1,g&&C.byteArray.fill(1,0,I);break;case vq.HalfFloat:C.byteArray=new Uint16Array(I),C.textureType=2,g&&C.byteArray.fill(15360,0,I);break;default:throw new Error("Unsupported type: "+z)}let V=0;for(const U of q.channels)void 0!==C.decodeChannels[U.name]&&(C.channelLineOffsets[U.name]=V*C.width),V+=2*U.pixelType;return C.bytesPerLine=C.width*V,C.outLineWidth=C.width*C.outputChannels,"INCREASING_Y"===q.lineOrder?C.scanOrder=q=>q:C.scanOrder=q=>C.height-1-q,4==C.outputChannels?(C.format=5,C.linearSpace=!0):(C.format=6,C.linearSpace=!1),C}function Iq(q,S,b,z){const C={value:0};for(let v=0;v<q.height/q.scanlineBlockSize;v++){const U=T(b,z)-S.dataWindow.yMin;q.size=B(b,z),q.lines=U+q.scanlineBlockSize>q.height?q.height-U:q.scanlineBlockSize;const g=q.size<q.lines*q.bytesPerLine&&q.uncompress?q.uncompress(q):qq(q);z.value+=q.size;for(let b=0;b<q.scanlineBlockSize;b++){const z=v*q.scanlineBlockSize,U=b+q.scanOrder(z);if(U>=q.height)continue;const r=b*q.bytesPerLine,I=(q.height-1-U)*q.outLineWidth;for(let b=0;b<q.channels;b++){const z=S.channels[b].name,v=q.channelLineOffsets[z],U=q.decodeChannels[z];if(void 0!==U){C.value=r+v;for(let S=0;S<q.width;S++){const b=I+S*q.outputChannels+U;q.byteArray&&(q.byteArray[b]=q.getter(g,C))}}}}}}gq.DefaultOutputType=vq.HalfFloat,gq.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Vq{constructor(){this.supportCascades=!1}loadCubeData(q,S,b,z,C){throw".exr not supported in Cube."}loadData(q,S,b){const C=new DataView(q.buffer),v={value:0},U=x(C,v);rq(U,C,v,gq.DefaultOutputType).then((q=>{Iq(q,U,C,v);const z=U.dataWindow.xMax-U.dataWindow.xMin+1,g=U.dataWindow.yMax-U.dataWindow.yMin+1;b(z,g,S.generateMipMaps,!1,(()=>{const b=S.getEngine();S.format=U.format,S.type=q.textureType,S.invertY=!1,S._gammaSpace=!U.linearSpace,q.byteArray&&b._uploadDataToTextureDirectly(S,q.byteArray,0,0,void 0,!0)}))})).catch((q=>{z.b.Error("Failed to load EXR texture: ",q)}))}}async function lq(q){const S=new DataView(q),b={value:0},C=x(S,b);try{const q=await rq(C,S,b,vq.Float);return Iq(q,C,S,b),q.byteArray?{width:C.dataWindow.xMax-C.dataWindow.xMin+1,height:C.dataWindow.yMax-C.dataWindow.yMin+1,data:new Float32Array(q.byteArray)}:(z.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(v){z.b.Error("Failed to load EXR data: ",v)}return{width:0,height:0,data:null}}},11121:(q,S,b)=>{function z(q){return parseInt(q.toString().replace(/\W/g,""))}function C(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(q-S)<=b}function v(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return q<S-z||q>b+z}function U(q,S){return q===S?q:Math.random()*(S-q)+q}function g(q,S,b){return q+(S-q)*b}function r(q,S,b){let z=H(S-q,360);return z>180&&(z-=360),q+z*y(b)}function I(q,S,b){let z=0;return z=q!=S?y((b-q)/(S-q)):0,z}function V(q,S,b,z,C){const v=C*C,U=C*v;return q*(2*U-3*v+1)+b*(-2*U+3*v)+S*(U-2*v+C)+z*(U-v)}function l(q,S,b,z,C){const v=C*C;return 6*(v-C)*q+(3*v-4*C+1)*S+6*(-v+C)*b+(3*v-2*C)*z}function y(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(b,Math.max(S,q))}function R(q){return q-=2*Math.PI*Math.floor((q+Math.PI)/(2*Math.PI))}function G(q){const S=q.toString(16);return q<=15?("0"+S).toUpperCase():S.toUpperCase()}function Z(q){if(Math.log2)return Math.floor(Math.log2(q));if(q<0)return NaN;if(0===q)return-1/0;let S=0;if(q<1){for(;q<1;)S++,q*=2;S=-S}else if(q>1)for(;q>1;)S++,q=Math.floor(q/2);return S}function H(q,S){return q-Math.floor(q/S)*S}function Q(q,S,b){return(q-S)/(b-S)}function k(q,S,b){return q*(b-S)+S}function W(q,S){let b=H(S-q,360);return b>180&&(b-=360),b}function N(q,S){const b=H(q,2*S);return S-Math.abs(b-S)}function u(q,S,b){let z=y(b);return z=-2*z*z*z+3*z*z,S*z+q*(1-z)}function X(q,S,b){let z=0;return z=Math.abs(S-q)<=b?S:q+Math.sign(S-q)*b,z}function T(q,S,b){const z=W(q,S);let C=0;return C=-b<z&&z<b?S:X(q,S=q+z,b),C}function B(q,S,b){return(q-S)/(b-S)}function t(q,S,b){return(b-S)*q+S}function f(q,S){const b=q%S;return 0===b?S:f(S,b)}b.r(S),b.d(S,{Clamp:()=>y,DeltaAngle:()=>W,Denormalize:()=>k,ExtractAsInt:()=>z,Hermite:()=>V,Hermite1stDerivative:()=>l,HighestCommonFactor:()=>f,ILog2:()=>Z,InverseLerp:()=>I,Lerp:()=>g,LerpAngle:()=>r,MoveTowards:()=>X,MoveTowardsAngle:()=>T,Normalize:()=>Q,NormalizeRadians:()=>R,OutsideRange:()=>v,PercentToRange:()=>t,PingPong:()=>N,RandomRange:()=>U,RangeToPercent:()=>B,Repeat:()=>H,SmoothStep:()=>u,ToHex:()=>G,WithinEpsilon:()=>C})}}]);