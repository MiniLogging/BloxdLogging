"use strict";(self.hwpa2z1pqte=self.hwpa2z1pqte||[]).push([[16],{15397:(h,R,l)=>{l.r(R),l.d(R,{ReadExrDataAsync:()=>ch,_ExrTextureLoader:()=>uh});var j=l(12711),a=l(12917);const D=4,U=4,F=1,w=2,mh=8,u=65536,c=u>>3,J=14,q=65537,Q=1<<J,Y=Q-1,s=59,t=63,f=2+t-s;var T,E;!function(h){h[h.NO_COMPRESSION=0]="NO_COMPRESSION",h[h.RLE_COMPRESSION=1]="RLE_COMPRESSION",h[h.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",h[h.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",h[h.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",h[h.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(h){h[h.INCREASING_Y=0]="INCREASING_Y",h[h.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const x=function(){const h=new ArrayBuffer(4),R=new Float32Array(h),l=new Uint32Array(h),j=new Uint32Array(512),a=new Uint32Array(512);for(let w=0;w<256;++w){const h=w-127;h<-27?(j[w]=0,j[256|w]=32768,a[w]=24,a[256|w]=24):h<-14?(j[w]=1024>>-h-14,j[256|w]=1024>>-h-14|32768,a[w]=-h-1,a[256|w]=-h-1):h<=15?(j[w]=h+15<<10,j[256|w]=h+15<<10|32768,a[w]=13,a[256|w]=13):h<128?(j[w]=31744,j[256|w]=64512,a[w]=24,a[256|w]=24):(j[w]=31744,j[256|w]=64512,a[w]=13,a[256|w]=13)}const D=new Uint32Array(2048),U=new Uint32Array(64),F=new Uint32Array(64);for(let w=1;w<1024;++w){let h=w<<13,R=0;for(;0===(8388608&h);)h<<=1,R-=8388608;h&=-8388609,R+=947912704,D[w]=h|R}for(let w=1024;w<2048;++w)D[w]=939524096+(w-1024<<13);for(let w=1;w<31;++w)U[w]=w<<23;U[31]=1199570944,U[32]=2147483648;for(let w=33;w<63;++w)U[w]=2147483648+(w-32<<23);U[63]=3347054592;for(let w=1;w<64;++w)32!==w&&(F[w]=1024);return{floatView:R,uint32View:l,baseTable:j,shiftTable:a,mantissaTable:D,exponentTable:U,offsetTable:F}}();function G(h,R){const l=new Uint8Array(h);let j=0;for(;0!=l[R.value+j];)j+=1;const a=(new TextDecoder).decode(l.slice(R.value,R.value+j));return R.value=R.value+j+1,a}function p(h,R){const l=h.getInt32(R.value,!0);return R.value+=D,l}function O(h,R){const l=h.getUint32(R.value,!0);return R.value+=D,l}function y(h,R){const l=h.getUint8(R.value);return R.value+=F,l}function v(h,R){const l=h.getUint16(R.value,!0);return R.value+=w,l}function b(h,R){const l=h[R.value];return R.value+=F,l}function I(h,R){let l;return l="getBigInt64"in DataView.prototype?Number(h.getBigInt64(R.value,!0)):h.getUint32(R.value+4,!0)+Number(h.getUint32(R.value,!0)<<32),R.value+=mh,l}function L(h,R){const l=h.getFloat32(R.value,!0);return R.value+=U,l}function n(h,R){return function(h){const R=(31744&h)>>10,l=1023&h;return(h>>15?-1:1)*(R?31===R?l?NaN:1/0:Math.pow(2,R-15)*(1+l/1024):l/1024*6103515625e-14)}(v(h,R))}function r(h,R){return function(h){if(Math.abs(h)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");h=(0,a.Clamp)(h,-65504,65504),x.floatView[0]=h;const R=x.uint32View[0],l=R>>23&511;return x.baseTable[l]+((8388607&R)>>x.shiftTable[l])}(L(h,R))}function P(h,R,l,j){switch(l){case"string":case"stringvector":case"iccProfile":return function(h,R,l){const j=(new TextDecoder).decode(new Uint8Array(h).slice(R.value,R.value+l));return R.value=R.value+l,j}(h.buffer,R,j);case"chlist":return function(h,R,l){const j=R.value,a=[];for(;R.value<j+l-1;){const l=G(h.buffer,R),j=p(h,R),D=y(h,R);R.value+=3;const U=p(h,R),F=p(h,R);a.push({name:l,pixelType:j,pLinear:D,xSampling:U,ySampling:F})}return R.value+=1,a}(h,R,j);case"chromaticities":return function(h,R){return{redX:L(h,R),redY:L(h,R),greenX:L(h,R),greenY:L(h,R),blueX:L(h,R),blueY:L(h,R),whiteX:L(h,R),whiteY:L(h,R)}}(h,R);case"compression":return function(h,R){return y(h,R)}(h,R);case"box2i":return function(h,R){return{xMin:p(h,R),yMin:p(h,R),xMax:p(h,R),yMax:p(h,R)}}(h,R);case"lineOrder":return function(h,R){const l=y(h,R);return E[l]}(h,R);case"float":return L(h,R);case"v2f":return function(h,R){return[L(h,R),L(h,R)]}(h,R);case"v3f":return function(h,R){return[L(h,R),L(h,R),L(h,R)]}(h,R);case"int":return p(h,R);case"rational":return function(h,R){return[p(h,R),O(h,R)]}(h,R);case"timecode":return function(h,R){return[O(h,R),O(h,R)]}(h,R);case"preview":return R.value+=j,"skipped";default:return void(R.value+=j)}}function z(h){for(let R=1;R<h.length;R++){const l=h[R-1]+h[R]-128;h[R]=l}}function o(h,R){let l=0,j=Math.floor((h.length+1)/2),a=0;const D=h.length-1;for(;!(a>D)&&(R[a++]=h[l++],!(a>D));)R[a++]=h[j++]}const K=20000630;function W(h,R){if(h.getUint32(0,!0)!=K)throw new Error("Incorrect OpenEXR format");const l=h.getUint8(4),a=h.getUint8(5),D={singleTile:!!(2&a),longName:!!(4&a),deepFormat:!!(8&a),multiPart:!!(16&a)};R.value=8;const U={};let F=!0;for(;F;){const l=G(h.buffer,R);if(l){const a=G(h.buffer,R),D=P(h,R,a,O(h,R));void 0===D?j.c.Warn(`Unknown header attribute type ${a}'.`):U[l]=D}else F=!1}if(0!=(-5&a))throw new Error("Unsupported file format");return{version:l,spec:D,...U}}const g=32768,H=65535;function k(h,R,l,j,a){for(;l<h;)R=R<<8|b(j,a),l+=8;return{l:R>>(l-=h)&(1<<h)-1,c:R,lc:l}}function C(h,R,l,j){return{c:h=h<<8|b(l,j),lc:R+=8}}function A(h,R,l,j,a,D,U,F,w){if(h==R){if(j<8){const h=C(l,j,a,D);l=h.c,j=h.lc}let h=l>>(j-=8);if(h=new Uint8Array([h])[0],F.value+h>w)return null;const R=U[F.value-1];for(;h-- >0;)U[F.value++]=R}else{if(!(F.value<w))return null;U[F.value++]=h}return{c:l,lc:j}}const e=new Array(59);function S(h,R,l,j,a,D){const U=R;let F=0,w=0;for(;j<=a;j++){if(U.value-R.value>l)return;let mh=k(6,F,w,h,U);const u=mh.l;if(F=mh.c,w=mh.lc,D[j]=u,u==t){if(U.value-R.value>l)throw new Error("Error in HufUnpackEncTable");mh=k(8,F,w,h,U);let u=mh.l+f;if(F=mh.c,w=mh.lc,j+u>a+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)D[j++]=0;j--}else if(u>=s){let h=u-s+2;if(j+h>a+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)D[j++]=0;j--}}!function(h){for(let l=0;l<=58;++l)e[l]=0;for(let l=0;l<q;++l)e[h[l]]+=1;let R=0;for(let l=58;l>0;--l){const h=R+e[l]>>1;e[l]=R,R=h}for(let l=0;l<q;++l){const R=h[l];R>0&&(h[l]=R|e[R]++<<6)}}(D)}function Z(h){return 63&h}function M(h){return h>>6}function i(h,R,l,j,a,D){const U=l.value,F=O(R,l),w=O(R,l);l.value+=4;const mh=O(R,l);if(l.value+=4,F<0||F>=q||w<0||w>=q)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(q),c=new Array(Q);!function(h){for(let R=0;R<Q;R++)h[R]={},h[R].len=0,h[R].lit=0,h[R].p=null}(c);if(S(h,l,j-(l.value-U),F,w,u),mh>8*(j-(l.value-U)))throw new Error("Wrong hufUncompress");!function(h,R,l,j){for(;R<=l;R++){const l=M(h[R]),a=Z(h[R]);if(l>>a)throw new Error("Invalid table entry");if(a>J){const h=j[l>>a-J];if(h.len)throw new Error("Invalid table entry");if(h.lit++,h.p){const R=h.p;h.p=new Array(h.lit);for(let l=0;l<h.lit-1;++l)h.p[l]=R[l]}else h.p=new Array(1);h.p[h.lit-1]=R}else if(a){let h=0;for(let D=1<<J-a;D>0;D--){const D=j[(l<<J-a)+h];if(D.len||D.p)throw new Error("Invalid table entry");D.len=a,D.lit=R,h++}}}}(u,F,w,c),function(h,R,l,j,a,D,U,F,w){let mh=0,u=0;const c=U,q=Math.trunc(j.value+(a+7)/8);for(;j.value<q;){let a=C(mh,u,l,j);for(mh=a.c,u=a.lc;u>=J;){const U=R[mh>>u-J&Y];if(U.len){u-=U.len;const h=A(U.lit,D,mh,u,l,j,F,w,c);h&&(mh=h.c,u=h.lc)}else{if(!U.p)throw new Error("hufDecode issues");let R;for(R=0;R<U.lit;R++){const J=Z(h[U.p[R]]);for(;u<J&&j.value<q;)a=C(mh,u,l,j),mh=a.c,u=a.lc;if(u>=J&&M(h[U.p[R]])==(mh>>u-J&(1<<J)-1)){u-=J;const h=A(U.p[R],D,mh,u,l,j,F,w,c);h&&(mh=h.c,u=h.lc);break}}if(R==U.lit)throw new Error("HufDecode issues")}}}const Q=8-a&7;for(mh>>=Q,u-=Q;u>0;){const h=R[mh<<J-u&Y];if(!h.len)throw new Error("HufDecode issues");{u-=h.len;const R=A(h.lit,D,mh,u,l,j,F,w,c);R&&(mh=R.c,u=R.lc)}}}(u,c,h,l,mh,w,D,a,{value:0})}function d(h){return 65535&h}function X(h){const R=d(h);return R>32767?R-65536:R}function V(h,R){const l=X(h),j=X(R),a=l+(1&j)+(j>>1);return{a:a,b:a-j}}function B(h,R){const l=d(h),j=d(R),a=l-(j>>1)&H;return{a:j+a-g&H,b:a}}function N(h,R,l,j,a,D,U){const F=U<16384,w=l>a?a:l;let mh,u,c=1;for(;c<=w;)c<<=1;for(c>>=1,mh=c,c>>=1;c>=1;){u=0;const U=u+D*(a-mh),w=D*c,J=D*mh,q=j*c,Q=j*mh;let Y,s,t,f;for(;u<=U;u+=J){let a=u;const D=u+j*(l-mh);for(;a<=D;a+=Q){const l=a+q,j=a+w,D=j+q;if(F){let U=V(h[a+R],h[j+R]);Y=U.a,t=U.b,U=V(h[l+R],h[D+R]),s=U.a,f=U.b,U=V(Y,s),h[a+R]=U.a,h[l+R]=U.b,U=V(t,f),h[j+R]=U.a,h[D+R]=U.b}else{let U=B(h[a+R],h[j+R]);Y=U.a,t=U.b,U=B(h[l+R],h[D+R]),s=U.a,f=U.b,U=B(Y,s),h[a+R]=U.a,h[l+R]=U.b,U=B(t,f),h[j+R]=U.a,h[D+R]=U.b}}if(l&c){const l=a+w;let j;j=F?V(h[a+R],h[l+R]):B(h[a+R],h[l+R]),Y=j.a,h[l+R]=j.b,h[a+R]=Y}}if(a&c){let a=u;const D=u+j*(l-mh);for(;a<=D;a+=Q){const l=a+q;let j;j=F?V(h[a+R],h[l+R]):B(h[a+R],h[l+R]),Y=j.a,h[l+R]=j.b,h[a+R]=Y}}mh=c,c>>=1}return u}function hh(h){return new DataView(h.array.buffer,h.offset.value,h.size)}function Rh(h){const R=h.viewer.buffer.slice(h.offset.value,h.offset.value+h.size),l=new Uint8Array(function(h){let R=h.byteLength;const l=[];let j=0;const a=new DataView(h);for(;R>0;){const h=a.getInt8(j++);if(h<0){const D=-h;R-=D+1;for(let h=0;h<D;h++)l.push(a.getUint8(j++))}else{const D=h;R-=2;const U=a.getUint8(j++);for(let h=0;h<D+1;h++)l.push(U)}}return l}(R)),j=new Uint8Array(l.length);return z(l),o(l,j),new DataView(j.buffer)}function lh(h){const R=h.array.slice(h.offset.value,h.offset.value+h.size),l=fflate.unzlibSync(R),j=new Uint8Array(l.length);return z(l),o(l,j),new DataView(j.buffer)}function jh(h){const R=h.array.slice(h.offset.value,h.offset.value+h.size),l=fflate.unzlibSync(R),j=h.lines*h.channels*h.width,a=1==h.type?new Uint16Array(j):new Uint32Array(j);let D=0,U=0;const F=new Array(4);for(let w=0;w<h.lines;w++)for(let R=0;R<h.channels;R++){let R=0;switch(h.type){case 1:F[0]=D,F[1]=F[0]+h.width,D=F[1]+h.width;for(let j=0;j<h.width;++j){R+=l[F[0]++]<<8|l[F[1]++],a[U]=R,U++}break;case 2:F[0]=D,F[1]=F[0]+h.width,F[2]=F[1]+h.width,D=F[2]+h.width;for(let j=0;j<h.width;++j){R+=l[F[0]++]<<24|l[F[1]++]<<16|l[F[2]++]<<8,a[U]=R,U++}}}return new DataView(a.buffer)}function ah(h){const R=h.viewer,l={value:h.offset.value},j=new Uint16Array(h.width*h.scanlineBlockSize*(h.channels*h.type)),a=new Uint8Array(c);let D=0;const U=new Array(h.channels);for(let w=0;w<h.channels;w++)U[w]={},U[w].start=D,U[w].end=U[w].start,U[w].nx=h.width,U[w].ny=h.lines,U[w].size=h.type,D+=U[w].nx*U[w].ny*U[w].size;const F=v(R,l),mh=v(R,l);if(mh>=c)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(F<=mh)for(let w=0;w<mh-F+1;w++)a[w+F]=y(R,l);const J=new Uint16Array(u),q=function(h,R){let l=0;for(let a=0;a<u;++a)(0==a||h[a>>3]&1<<(7&a))&&(R[l++]=a);const j=l-1;for(;l<u;)R[l++]=0;return j}(a,J),Q=O(R,l);i(h.array,R,l,Q,j,D);for(let w=0;w<h.channels;++w){const h=U[w];for(let R=0;R<U[w].size;++R)N(j,h.start+R,h.nx,h.size,h.ny,h.nx*h.size,q)}!function(h,R,l){for(let j=0;j<l;++j)R[j]=h[R[j]]}(J,j,D);let Y=0;const s=new Uint8Array(j.buffer.byteLength);for(let u=0;u<h.lines;u++)for(let R=0;R<h.channels;R++){const h=U[R],l=h.nx*h.size,a=new Uint8Array(j.buffer,h.end*w,l*w);s.set(a,Y),Y+=l*w,h.end+=l}return new DataView(s.buffer)}var Dh,Uh=l(12689);!function(h){h[h.Float=0]="Float",h[h.HalfFloat=1]="HalfFloat"}(Dh||(Dh={}));class Fh{}async function wh(h,R,l,j){const a={size:0,viewer:R,array:new Uint8Array(R.buffer),offset:l,width:h.dataWindow.xMax-h.dataWindow.xMin+1,height:h.dataWindow.yMax-h.dataWindow.yMin+1,channels:h.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(h.compression){case T.NO_COMPRESSION:a.lines=1,a.uncompress=hh;break;case T.RLE_COMPRESSION:a.lines=1,a.uncompress=Rh;break;case T.ZIPS_COMPRESSION:a.lines=1,a.uncompress=lh,await Uh.Tools.LoadScriptAsync(Fh.FFLATEUrl);break;case T.ZIP_COMPRESSION:a.lines=16,a.uncompress=lh,await Uh.Tools.LoadScriptAsync(Fh.FFLATEUrl);break;case T.PIZ_COMPRESSION:a.lines=32,a.uncompress=ah;break;case T.PXR24_COMPRESSION:a.lines=16,a.uncompress=jh,await Uh.Tools.LoadScriptAsync(Fh.FFLATEUrl);break;default:throw new Error(T[h.compression]+" is unsupported")}a.scanlineBlockSize=a.lines;const D={};for(const U of h.channels)switch(U.name){case"R":case"G":case"B":case"A":case"Y":D[U.name]=!0,a.type=U.pixelType}let F=!1;if(D.R&&D.G&&D.B&&D.A)a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3};else if(D.R&&D.G&&D.B)F=!0,a.outputChannels=4,a.decodeChannels={R:0,G:1,B:2,A:3};else if(D.R&&D.G)a.outputChannels=2,a.decodeChannels={R:0,G:1};else if(D.R)a.outputChannels=1,a.decodeChannels={R:0};else{if(!D.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");a.outputChannels=1,a.decodeChannels={Y:0}}if(1===a.type)switch(j){case Dh.Float:a.getter=n,a.inputSize=w;break;case Dh.HalfFloat:a.getter=v,a.inputSize=w}else{if(2!==a.type)throw new Error("Unsupported pixelType "+a.type+" for "+h.compression);switch(j){case Dh.Float:a.getter=L,a.inputSize=U;break;case Dh.HalfFloat:a.getter=r,a.inputSize=U}}a.blockCount=a.height/a.scanlineBlockSize;for(let U=0;U<a.blockCount;U++)I(R,l);const mh=a.width*a.height*a.outputChannels;switch(j){case Dh.Float:a.byteArray=new Float32Array(mh),a.textureType=1,F&&a.byteArray.fill(1,0,mh);break;case Dh.HalfFloat:a.byteArray=new Uint16Array(mh),a.textureType=2,F&&a.byteArray.fill(15360,0,mh);break;default:throw new Error("Unsupported type: "+j)}let u=0;for(const U of h.channels)void 0!==a.decodeChannels[U.name]&&(a.channelLineOffsets[U.name]=u*a.width),u+=2*U.pixelType;return a.bytesPerLine=a.width*u,a.outLineWidth=a.width*a.outputChannels,"INCREASING_Y"===h.lineOrder?a.scanOrder=h=>h:a.scanOrder=h=>a.height-1-h,4==a.outputChannels?(a.format=5,a.linearSpace=!0):(a.format=6,a.linearSpace=!1),a}function mR(h,R,l,j){const a={value:0};for(let D=0;D<h.height/h.scanlineBlockSize;D++){const U=p(l,j)-R.dataWindow.yMin;h.size=O(l,j),h.lines=U+h.scanlineBlockSize>h.height?h.height-U:h.scanlineBlockSize;const F=h.size<h.lines*h.bytesPerLine&&h.uncompress?h.uncompress(h):hh(h);j.value+=h.size;for(let l=0;l<h.scanlineBlockSize;l++){const j=D*h.scanlineBlockSize,U=l+h.scanOrder(j);if(U>=h.height)continue;const w=l*h.bytesPerLine,mh=(h.height-1-U)*h.outLineWidth;for(let l=0;l<h.channels;l++){const j=R.channels[l].name,D=h.channelLineOffsets[j],U=h.decodeChannels[j];if(void 0!==U){a.value=w+D;for(let R=0;R<h.width;R++){const l=mh+R*h.outputChannels+U;h.byteArray&&(h.byteArray[l]=h.getter(F,a))}}}}}}Fh.DefaultOutputType=Dh.HalfFloat,Fh.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class uh{constructor(){this.supportCascades=!1}loadCubeData(h,R,l,j,a){throw".exr not supported in Cube."}loadData(h,R,l){const a=new DataView(h.buffer),D={value:0},U=W(a,D);wh(U,a,D,Fh.DefaultOutputType).then((h=>{mR(h,U,a,D);const j=U.dataWindow.xMax-U.dataWindow.xMin+1,F=U.dataWindow.yMax-U.dataWindow.yMin+1;l(j,F,R.generateMipMaps,!1,(()=>{const l=R.getEngine();R.format=U.format,R.type=h.textureType,R.invertY=!1,R._gammaSpace=!U.linearSpace,h.byteArray&&l._uploadDataToTextureDirectly(R,h.byteArray,0,0,void 0,!0)}))})).catch((h=>{j.c.Error("Failed to load EXR texture: ",h)}))}}async function ch(h){const R=new DataView(h),l={value:0},a=W(R,l);try{const h=await wh(a,R,l,Dh.Float);return mR(h,a,R,l),h.byteArray?{width:a.dataWindow.xMax-a.dataWindow.xMin+1,height:a.dataWindow.yMax-a.dataWindow.yMin+1,data:new Float32Array(h.byteArray)}:(j.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(D){j.c.Error("Failed to load EXR data: ",D)}return{width:0,height:0,data:null}}},12917:(h,R,l)=>{function j(h){return parseInt(h.toString().replace(/\W/g,""))}function a(h,R){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-R)<=l}function D(h,R,l){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<R-j||h>l+j}function U(h,R){return h===R?h:Math.random()*(R-h)+h}function F(h,R,l){return h+(R-h)*l}function w(h,R,l){let j=s(R-h,360);return j>180&&(j-=360),h+j*J(l)}function mh(h,R,l){let j=0;return j=h!=R?J((l-h)/(R-h)):0,j}function u(h,R,l,j,a){const D=a*a,U=a*D;return h*(2*U-3*D+1)+l*(-2*U+3*D)+R*(U-2*D+a)+j*(U-D)}function c(h,R,l,j,a){const D=a*a;return 6*(D-a)*h+(3*D-4*a+1)*R+6*(-D+a)*l+(3*D-2*a)*j}function J(h){let R=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(l,Math.max(R,h))}function q(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function Q(h){const R=h.toString(16);return h<=15?("0"+R).toUpperCase():R.toUpperCase()}function Y(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let R=0;if(h<1){for(;h<1;)R++,h*=2;R=-R}else if(h>1)for(;h>1;)R++,h=Math.floor(h/2);return R}function s(h,R){return h-Math.floor(h/R)*R}function t(h,R,l){return(h-R)/(l-R)}function f(h,R,l){return h*(l-R)+R}function T(h,R){let l=s(R-h,360);return l>180&&(l-=360),l}function E(h,R){const l=s(h,2*R);return R-Math.abs(l-R)}function x(h,R,l){let j=J(l);return j=-2*j*j*j+3*j*j,R*j+h*(1-j)}function G(h,R,l){let j=0;return j=Math.abs(R-h)<=l?R:h+Math.sign(R-h)*l,j}function p(h,R,l){const j=T(h,R);let a=0;return a=-l<j&&j<l?R:G(h,R=h+j,l),a}function O(h,R,l){return(h-R)/(l-R)}function y(h,R,l){return(l-R)*h+R}function v(h,R){const l=h%R;return 0===l?R:v(R,l)}l.r(R),l.d(R,{Clamp:()=>J,DeltaAngle:()=>T,Denormalize:()=>f,ExtractAsInt:()=>j,Hermite:()=>u,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>v,ILog2:()=>Y,InverseLerp:()=>mh,Lerp:()=>F,LerpAngle:()=>w,MoveTowards:()=>G,MoveTowardsAngle:()=>p,Normalize:()=>t,NormalizeRadians:()=>q,OutsideRange:()=>D,PercentToRange:()=>y,PingPong:()=>E,RandomRange:()=>U,RangeToPercent:()=>O,Repeat:()=>s,SmoothStep:()=>x,ToHex:()=>Q,WithinEpsilon:()=>a})}}]);