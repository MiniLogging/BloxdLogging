"use strict";(self.a14qw1h7fq=self.a14qw1h7fq||[]).push([[16],{13668:(R,J,B)=>{B.r(J),B.d(J,{ReadExrDataAsync:()=>lR,_ExrTextureLoader:()=>DR});var Q=B(11043),h=B(11201);const y=4,N=4,r=1,q=2,e=8,D=65536,l=D>>3,E=14,O=65537,n=1<<E,P=n-1,A=59,u=63,S=2+u-A;var f,a;!function(R){R[R.NO_COMPRESSION=0]="NO_COMPRESSION",R[R.RLE_COMPRESSION=1]="RLE_COMPRESSION",R[R.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",R[R.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",R[R.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",R[R.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(f||(f={})),function(R){R[R.INCREASING_Y=0]="INCREASING_Y",R[R.DECREASING_Y=1]="DECREASING_Y"}(a||(a={}));const s=function(){const R=new ArrayBuffer(4),J=new Float32Array(R),B=new Uint32Array(R),Q=new Uint32Array(512),h=new Uint32Array(512);for(let q=0;q<256;++q){const R=q-127;R<-27?(Q[q]=0,Q[256|q]=32768,h[q]=24,h[256|q]=24):R<-14?(Q[q]=1024>>-R-14,Q[256|q]=1024>>-R-14|32768,h[q]=-R-1,h[256|q]=-R-1):R<=15?(Q[q]=R+15<<10,Q[256|q]=R+15<<10|32768,h[q]=13,h[256|q]=13):R<128?(Q[q]=31744,Q[256|q]=64512,h[q]=24,h[256|q]=24):(Q[q]=31744,Q[256|q]=64512,h[q]=13,h[256|q]=13)}const y=new Uint32Array(2048),N=new Uint32Array(64),r=new Uint32Array(64);for(let q=1;q<1024;++q){let R=q<<13,J=0;for(;0===(8388608&R);)R<<=1,J-=8388608;R&=-8388609,J+=947912704,y[q]=R|J}for(let q=1024;q<2048;++q)y[q]=939524096+(q-1024<<13);for(let q=1;q<31;++q)N[q]=q<<23;N[31]=1199570944,N[32]=2147483648;for(let q=33;q<63;++q)N[q]=2147483648+(q-32<<23);N[63]=3347054592;for(let q=1;q<64;++q)32!==q&&(r[q]=1024);return{floatView:J,uint32View:B,baseTable:Q,shiftTable:h,mantissaTable:y,exponentTable:N,offsetTable:r}}();function x(R,J){const B=new Uint8Array(R);let Q=0;for(;0!=B[J.value+Q];)Q+=1;const h=(new TextDecoder).decode(B.slice(J.value,J.value+Q));return J.value=J.value+Q+1,h}function I(R,J){const B=R.getInt32(J.value,!0);return J.value+=y,B}function V(R,J){const B=R.getUint32(J.value,!0);return J.value+=y,B}function M(R,J){const B=R.getUint8(J.value);return J.value+=r,B}function H(R,J){const B=R.getUint16(J.value,!0);return J.value+=q,B}function d(R,J){const B=R[J.value];return J.value+=r,B}function X(R,J){let B;return B="getBigInt64"in DataView.prototype?Number(R.getBigInt64(J.value,!0)):R.getUint32(J.value+4,!0)+Number(R.getUint32(J.value,!0)<<32),J.value+=e,B}function c(R,J){const B=R.getFloat32(J.value,!0);return J.value+=N,B}function z(R,J){return function(R){const J=(31744&R)>>10,B=1023&R;return(R>>15?-1:1)*(J?31===J?B?NaN:1/0:Math.pow(2,J-15)*(1+B/1024):B/1024*6103515625e-14)}(H(R,J))}function p(R,J){return function(R){if(Math.abs(R)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");R=(0,h.Clamp)(R,-65504,65504),s.floatView[0]=R;const J=s.uint32View[0],B=J>>23&511;return s.baseTable[B]+((8388607&J)>>s.shiftTable[B])}(c(R,J))}function i(R,J,B,Q){switch(B){case"string":case"stringvector":case"iccProfile":return function(R,J,B){const Q=(new TextDecoder).decode(new Uint8Array(R).slice(J.value,J.value+B));return J.value=J.value+B,Q}(R.buffer,J,Q);case"chlist":return function(R,J,B){const Q=J.value,h=[];for(;J.value<Q+B-1;){const B=x(R.buffer,J),Q=I(R,J),y=M(R,J);J.value+=3;const N=I(R,J),r=I(R,J);h.push({name:B,pixelType:Q,pLinear:y,xSampling:N,ySampling:r})}return J.value+=1,h}(R,J,Q);case"chromaticities":return function(R,J){return{redX:c(R,J),redY:c(R,J),greenX:c(R,J),greenY:c(R,J),blueX:c(R,J),blueY:c(R,J),whiteX:c(R,J),whiteY:c(R,J)}}(R,J);case"compression":return function(R,J){return M(R,J)}(R,J);case"box2i":return function(R,J){return{xMin:I(R,J),yMin:I(R,J),xMax:I(R,J),yMax:I(R,J)}}(R,J);case"lineOrder":return function(R,J){const B=M(R,J);return a[B]}(R,J);case"float":return c(R,J);case"v2f":return function(R,J){return[c(R,J),c(R,J)]}(R,J);case"v3f":return function(R,J){return[c(R,J),c(R,J),c(R,J)]}(R,J);case"int":return I(R,J);case"rational":return function(R,J){return[I(R,J),V(R,J)]}(R,J);case"timecode":return function(R,J){return[V(R,J),V(R,J)]}(R,J);case"preview":return J.value+=Q,"skipped";default:return void(J.value+=Q)}}function W(R){for(let J=1;J<R.length;J++){const B=R[J-1]+R[J]-128;R[J]=B}}function k(R,J){let B=0,Q=Math.floor((R.length+1)/2),h=0;const y=R.length-1;for(;!(h>y)&&(J[h++]=R[B++],!(h>y));)J[h++]=R[Q++]}const Y=20000630;function G(R,J){if(R.getUint32(0,!0)!=Y)throw new Error("Incorrect OpenEXR format");const B=R.getUint8(4),h=R.getUint8(5),y={singleTile:!!(2&h),longName:!!(4&h),deepFormat:!!(8&h),multiPart:!!(16&h)};J.value=8;const N={};let r=!0;for(;r;){const B=x(R.buffer,J);if(B){const h=x(R.buffer,J),y=i(R,J,h,V(R,J));void 0===y?Q.d.Warn(`Unknown header attribute type ${h}'.`):N[B]=y}else r=!1}if(0!=(-5&h))throw new Error("Unsupported file format");return{version:B,spec:y,...N}}const g=32768,L=65535;function j(R,J,B,Q,h){for(;B<R;)J=J<<8|d(Q,h),B+=8;return{l:J>>(B-=R)&(1<<R)-1,c:J,lc:B}}function T(R,J,B,Q){return{c:R=R<<8|d(B,Q),lc:J+=8}}function F(R,J,B,Q,h,y,N,r,q){if(R==J){if(Q<8){const R=T(B,Q,h,y);B=R.c,Q=R.lc}let R=B>>(Q-=8);if(R=new Uint8Array([R])[0],r.value+R>q)return null;const J=N[r.value-1];for(;R-- >0;)N[r.value++]=J}else{if(!(r.value<q))return null;N[r.value++]=R}return{c:B,lc:Q}}const C=new Array(59);function b(R,J,B,Q,h,y){const N=J;let r=0,q=0;for(;Q<=h;Q++){if(N.value-J.value>B)return;let e=j(6,r,q,R,N);const D=e.l;if(r=e.c,q=e.lc,y[Q]=D,D==u){if(N.value-J.value>B)throw new Error("Error in HufUnpackEncTable");e=j(8,r,q,R,N);let D=e.l+S;if(r=e.c,q=e.lc,Q+D>h+1)throw new Error("Error in HufUnpackEncTable");for(;D--;)y[Q++]=0;Q--}else if(D>=A){let R=D-A+2;if(Q+R>h+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)y[Q++]=0;Q--}}!function(R){for(let B=0;B<=58;++B)C[B]=0;for(let B=0;B<O;++B)C[R[B]]+=1;let J=0;for(let B=58;B>0;--B){const R=J+C[B]>>1;C[B]=J,J=R}for(let B=0;B<O;++B){const J=R[B];J>0&&(R[B]=J|C[J]++<<6)}}(y)}function w(R){return 63&R}function K(R){return R>>6}function v(R,J,B,Q,h,y){const N=B.value,r=V(J,B),q=V(J,B);B.value+=4;const e=V(J,B);if(B.value+=4,r<0||r>=O||q<0||q>=O)throw new Error("Wrong HUF_ENCSIZE");const D=new Array(O),l=new Array(n);!function(R){for(let J=0;J<n;J++)R[J]={},R[J].len=0,R[J].lit=0,R[J].p=null}(l);if(b(R,B,Q-(B.value-N),r,q,D),e>8*(Q-(B.value-N)))throw new Error("Wrong hufUncompress");!function(R,J,B,Q){for(;J<=B;J++){const B=K(R[J]),h=w(R[J]);if(B>>h)throw new Error("Invalid table entry");if(h>E){const R=Q[B>>h-E];if(R.len)throw new Error("Invalid table entry");if(R.lit++,R.p){const J=R.p;R.p=new Array(R.lit);for(let B=0;B<R.lit-1;++B)R.p[B]=J[B]}else R.p=new Array(1);R.p[R.lit-1]=J}else if(h){let R=0;for(let y=1<<E-h;y>0;y--){const y=Q[(B<<E-h)+R];if(y.len||y.p)throw new Error("Invalid table entry");y.len=h,y.lit=J,R++}}}}(D,r,q,l),function(R,J,B,Q,h,y,N,r,q){let e=0,D=0;const l=N,O=Math.trunc(Q.value+(h+7)/8);for(;Q.value<O;){let h=T(e,D,B,Q);for(e=h.c,D=h.lc;D>=E;){const N=J[e>>D-E&P];if(N.len){D-=N.len;const R=F(N.lit,y,e,D,B,Q,r,q,l);R&&(e=R.c,D=R.lc)}else{if(!N.p)throw new Error("hufDecode issues");let J;for(J=0;J<N.lit;J++){const E=w(R[N.p[J]]);for(;D<E&&Q.value<O;)h=T(e,D,B,Q),e=h.c,D=h.lc;if(D>=E&&K(R[N.p[J]])==(e>>D-E&(1<<E)-1)){D-=E;const R=F(N.p[J],y,e,D,B,Q,r,q,l);R&&(e=R.c,D=R.lc);break}}if(J==N.lit)throw new Error("HufDecode issues")}}}const n=8-h&7;for(e>>=n,D-=n;D>0;){const R=J[e<<E-D&P];if(!R.len)throw new Error("HufDecode issues");{D-=R.len;const J=F(R.lit,y,e,D,B,Q,r,q,l);J&&(e=J.c,D=J.lc)}}}(D,l,R,B,e,q,y,h,{value:0})}function m(R){return 65535&R}function o(R){const J=m(R);return J>32767?J-65536:J}function t(R,J){const B=o(R),Q=o(J),h=B+(1&Q)+(Q>>1);return{a:h,b:h-Q}}function Z(R,J){const B=m(R),Q=m(J),h=B-(Q>>1)&L;return{a:Q+h-g&L,b:h}}function U(R,J,B,Q,h,y,N){const r=N<16384,q=B>h?h:B;let e,D,l=1;for(;l<=q;)l<<=1;for(l>>=1,e=l,l>>=1;l>=1;){D=0;const N=D+y*(h-e),q=y*l,E=y*e,O=Q*l,n=Q*e;let P,A,u,S;for(;D<=N;D+=E){let h=D;const y=D+Q*(B-e);for(;h<=y;h+=n){const B=h+O,Q=h+q,y=Q+O;if(r){let N=t(R[h+J],R[Q+J]);P=N.a,u=N.b,N=t(R[B+J],R[y+J]),A=N.a,S=N.b,N=t(P,A),R[h+J]=N.a,R[B+J]=N.b,N=t(u,S),R[Q+J]=N.a,R[y+J]=N.b}else{let N=Z(R[h+J],R[Q+J]);P=N.a,u=N.b,N=Z(R[B+J],R[y+J]),A=N.a,S=N.b,N=Z(P,A),R[h+J]=N.a,R[B+J]=N.b,N=Z(u,S),R[Q+J]=N.a,R[y+J]=N.b}}if(B&l){const B=h+q;let Q;Q=r?t(R[h+J],R[B+J]):Z(R[h+J],R[B+J]),P=Q.a,R[B+J]=Q.b,R[h+J]=P}}if(h&l){let h=D;const y=D+Q*(B-e);for(;h<=y;h+=n){const B=h+O;let Q;Q=r?t(R[h+J],R[B+J]):Z(R[h+J],R[B+J]),P=Q.a,R[B+J]=Q.b,R[h+J]=P}}e=l,l>>=1}return D}function RR(R){return new DataView(R.array.buffer,R.offset.value,R.size)}function JR(R){const J=R.viewer.buffer.slice(R.offset.value,R.offset.value+R.size),B=new Uint8Array(function(R){let J=R.byteLength;const B=[];let Q=0;const h=new DataView(R);for(;J>0;){const R=h.getInt8(Q++);if(R<0){const y=-R;J-=y+1;for(let R=0;R<y;R++)B.push(h.getUint8(Q++))}else{const y=R;J-=2;const N=h.getUint8(Q++);for(let R=0;R<y+1;R++)B.push(N)}}return B}(J)),Q=new Uint8Array(B.length);return W(B),k(B,Q),new DataView(Q.buffer)}function BR(R){const J=R.array.slice(R.offset.value,R.offset.value+R.size),B=fflate.unzlibSync(J),Q=new Uint8Array(B.length);return W(B),k(B,Q),new DataView(Q.buffer)}function QR(R){const J=R.array.slice(R.offset.value,R.offset.value+R.size),B=fflate.unzlibSync(J),Q=R.lines*R.channels*R.width,h=1==R.type?new Uint16Array(Q):new Uint32Array(Q);let y=0,N=0;const r=new Array(4);for(let q=0;q<R.lines;q++)for(let J=0;J<R.channels;J++){let J=0;switch(R.type){case 1:r[0]=y,r[1]=r[0]+R.width,y=r[1]+R.width;for(let Q=0;Q<R.width;++Q){J+=B[r[0]++]<<8|B[r[1]++],h[N]=J,N++}break;case 2:r[0]=y,r[1]=r[0]+R.width,r[2]=r[1]+R.width,y=r[2]+R.width;for(let Q=0;Q<R.width;++Q){J+=B[r[0]++]<<24|B[r[1]++]<<16|B[r[2]++]<<8,h[N]=J,N++}}}return new DataView(h.buffer)}function hR(R){const J=R.viewer,B={value:R.offset.value},Q=new Uint16Array(R.width*R.scanlineBlockSize*(R.channels*R.type)),h=new Uint8Array(l);let y=0;const N=new Array(R.channels);for(let q=0;q<R.channels;q++)N[q]={},N[q].start=y,N[q].end=N[q].start,N[q].nx=R.width,N[q].ny=R.lines,N[q].size=R.type,y+=N[q].nx*N[q].ny*N[q].size;const r=H(J,B),e=H(J,B);if(e>=l)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(r<=e)for(let q=0;q<e-r+1;q++)h[q+r]=M(J,B);const E=new Uint16Array(D),O=function(R,J){let B=0;for(let h=0;h<D;++h)(0==h||R[h>>3]&1<<(7&h))&&(J[B++]=h);const Q=B-1;for(;B<D;)J[B++]=0;return Q}(h,E),n=V(J,B);v(R.array,J,B,n,Q,y);for(let q=0;q<R.channels;++q){const R=N[q];for(let J=0;J<N[q].size;++J)U(Q,R.start+J,R.nx,R.size,R.ny,R.nx*R.size,O)}!function(R,J,B){for(let Q=0;Q<B;++Q)J[Q]=R[J[Q]]}(E,Q,y);let P=0;const A=new Uint8Array(Q.buffer.byteLength);for(let D=0;D<R.lines;D++)for(let J=0;J<R.channels;J++){const R=N[J],B=R.nx*R.size,h=new Uint8Array(Q.buffer,R.end*q,B*q);A.set(h,P),P+=B*q,R.end+=B}return new DataView(A.buffer)}var yR,NR=B(11030);!function(R){R[R.Float=0]="Float",R[R.HalfFloat=1]="HalfFloat"}(yR||(yR={}));class rR{}async function qR(R,J,B,Q){const h={size:0,viewer:J,array:new Uint8Array(J.buffer),offset:B,width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,channels:R.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(R.compression){case f.NO_COMPRESSION:h.lines=1,h.uncompress=RR;break;case f.RLE_COMPRESSION:h.lines=1,h.uncompress=JR;break;case f.ZIPS_COMPRESSION:h.lines=1,h.uncompress=BR,await NR.Tools.LoadScriptAsync(rR.FFLATEUrl);break;case f.ZIP_COMPRESSION:h.lines=16,h.uncompress=BR,await NR.Tools.LoadScriptAsync(rR.FFLATEUrl);break;case f.PIZ_COMPRESSION:h.lines=32,h.uncompress=hR;break;case f.PXR24_COMPRESSION:h.lines=16,h.uncompress=QR,await NR.Tools.LoadScriptAsync(rR.FFLATEUrl);break;default:throw new Error(f[R.compression]+" is unsupported")}h.scanlineBlockSize=h.lines;const y={};for(const N of R.channels)switch(N.name){case"R":case"G":case"B":case"A":case"Y":y[N.name]=!0,h.type=N.pixelType}let r=!1;if(y.R&&y.G&&y.B&&y.A)h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else if(y.R&&y.G&&y.B)r=!0,h.outputChannels=4,h.decodeChannels={R:0,G:1,B:2,A:3};else if(y.R&&y.G)h.outputChannels=2,h.decodeChannels={R:0,G:1};else if(y.R)h.outputChannels=1,h.decodeChannels={R:0};else{if(!y.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");h.outputChannels=1,h.decodeChannels={Y:0}}if(1===h.type)switch(Q){case yR.Float:h.getter=z,h.inputSize=q;break;case yR.HalfFloat:h.getter=H,h.inputSize=q}else{if(2!==h.type)throw new Error("Unsupported pixelType "+h.type+" for "+R.compression);switch(Q){case yR.Float:h.getter=c,h.inputSize=N;break;case yR.HalfFloat:h.getter=p,h.inputSize=N}}h.blockCount=h.height/h.scanlineBlockSize;for(let N=0;N<h.blockCount;N++)X(J,B);const e=h.width*h.height*h.outputChannels;switch(Q){case yR.Float:h.byteArray=new Float32Array(e),h.textureType=1,r&&h.byteArray.fill(1,0,e);break;case yR.HalfFloat:h.byteArray=new Uint16Array(e),h.textureType=2,r&&h.byteArray.fill(15360,0,e);break;default:throw new Error("Unsupported type: "+Q)}let D=0;for(const N of R.channels)void 0!==h.decodeChannels[N.name]&&(h.channelLineOffsets[N.name]=D*h.width),D+=2*N.pixelType;return h.bytesPerLine=h.width*D,h.outLineWidth=h.width*h.outputChannels,"INCREASING_Y"===R.lineOrder?h.scanOrder=R=>R:h.scanOrder=R=>h.height-1-R,4==h.outputChannels?(h.format=5,h.linearSpace=!0):(h.format=6,h.linearSpace=!1),h}function eR(R,J,B,Q){const h={value:0};for(let y=0;y<R.height/R.scanlineBlockSize;y++){const N=I(B,Q)-J.dataWindow.yMin;R.size=V(B,Q),R.lines=N+R.scanlineBlockSize>R.height?R.height-N:R.scanlineBlockSize;const r=R.size<R.lines*R.bytesPerLine&&R.uncompress?R.uncompress(R):RR(R);Q.value+=R.size;for(let B=0;B<R.scanlineBlockSize;B++){const Q=y*R.scanlineBlockSize,N=B+R.scanOrder(Q);if(N>=R.height)continue;const q=B*R.bytesPerLine,e=(R.height-1-N)*R.outLineWidth;for(let B=0;B<R.channels;B++){const Q=J.channels[B].name,y=R.channelLineOffsets[Q],N=R.decodeChannels[Q];if(void 0!==N){h.value=q+y;for(let J=0;J<R.width;J++){const B=e+J*R.outputChannels+N;R.byteArray&&(R.byteArray[B]=R.getter(r,h))}}}}}}rR.DefaultOutputType=yR.HalfFloat,rR.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class DR{constructor(){this.supportCascades=!1}loadCubeData(R,J,B,Q,h){throw".exr not supported in Cube."}loadData(R,J,B){const h=new DataView(R.buffer),y={value:0},N=G(h,y);qR(N,h,y,rR.DefaultOutputType).then((R=>{eR(R,N,h,y);const Q=N.dataWindow.xMax-N.dataWindow.xMin+1,r=N.dataWindow.yMax-N.dataWindow.yMin+1;B(Q,r,J.generateMipMaps,!1,(()=>{const B=J.getEngine();J.format=N.format,J.type=R.textureType,J.invertY=!1,J._gammaSpace=!N.linearSpace,R.byteArray&&B._uploadDataToTextureDirectly(J,R.byteArray,0,0,void 0,!0)}))})).catch((R=>{Q.d.Error("Failed to load EXR texture: ",R)}))}}async function lR(R){const J=new DataView(R),B={value:0},h=G(J,B);try{const R=await qR(h,J,B,yR.Float);return eR(R,h,J,B),R.byteArray?{width:h.dataWindow.xMax-h.dataWindow.xMin+1,height:h.dataWindow.yMax-h.dataWindow.yMin+1,data:new Float32Array(R.byteArray)}:(Q.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(y){Q.d.Error("Failed to load EXR data: ",y)}return{width:0,height:0,data:null}}},11201:(R,J,B)=>{function Q(R){return parseInt(R.toString().replace(/\W/g,""))}function h(R,J){let B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(R-J)<=B}function y(R,J,B){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return R<J-Q||R>B+Q}function N(R,J){return R===J?R:Math.random()*(J-R)+R}function r(R,J,B){return R+(J-R)*B}function q(R,J,B){let Q=A(J-R,360);return Q>180&&(Q-=360),R+Q*E(B)}function e(R,J,B){let Q=0;return Q=R!=J?E((B-R)/(J-R)):0,Q}function D(R,J,B,Q,h){const y=h*h,N=h*y;return R*(2*N-3*y+1)+B*(-2*N+3*y)+J*(N-2*y+h)+Q*(N-y)}function l(R,J,B,Q,h){const y=h*h;return 6*(y-h)*R+(3*y-4*h+1)*J+6*(-y+h)*B+(3*y-2*h)*Q}function E(R){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,B=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(B,Math.max(J,R))}function O(R){return R-=2*Math.PI*Math.floor((R+Math.PI)/(2*Math.PI))}function n(R){const J=R.toString(16);return R<=15?("0"+J).toUpperCase():J.toUpperCase()}function P(R){if(Math.log2)return Math.floor(Math.log2(R));if(R<0)return NaN;if(0===R)return-1/0;let J=0;if(R<1){for(;R<1;)J++,R*=2;J=-J}else if(R>1)for(;R>1;)J++,R=Math.floor(R/2);return J}function A(R,J){return R-Math.floor(R/J)*J}function u(R,J,B){return(R-J)/(B-J)}function S(R,J,B){return R*(B-J)+J}function f(R,J){let B=A(J-R,360);return B>180&&(B-=360),B}function a(R,J){const B=A(R,2*J);return J-Math.abs(B-J)}function s(R,J,B){let Q=E(B);return Q=-2*Q*Q*Q+3*Q*Q,J*Q+R*(1-Q)}function x(R,J,B){let Q=0;return Q=Math.abs(J-R)<=B?J:R+Math.sign(J-R)*B,Q}function I(R,J,B){const Q=f(R,J);let h=0;return h=-B<Q&&Q<B?J:x(R,J=R+Q,B),h}function V(R,J,B){return(R-J)/(B-J)}function M(R,J,B){return(B-J)*R+J}function H(R,J){const B=R%J;return 0===B?J:H(J,B)}B.r(J),B.d(J,{Clamp:()=>E,DeltaAngle:()=>f,Denormalize:()=>S,ExtractAsInt:()=>Q,Hermite:()=>D,Hermite1stDerivative:()=>l,HighestCommonFactor:()=>H,ILog2:()=>P,InverseLerp:()=>e,Lerp:()=>r,LerpAngle:()=>q,MoveTowards:()=>x,MoveTowardsAngle:()=>I,Normalize:()=>u,NormalizeRadians:()=>O,OutsideRange:()=>y,PercentToRange:()=>M,PingPong:()=>a,RandomRange:()=>N,RangeToPercent:()=>V,Repeat:()=>A,SmoothStep:()=>s,ToHex:()=>n,WithinEpsilon:()=>h})}}]);