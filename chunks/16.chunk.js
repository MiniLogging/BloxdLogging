"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[16],{13836:(k,Q,i)=>{i.r(Q),i.d(Q,{ReadExrDataAsync:()=>Gk,_ExrTextureLoader:()=>Jk});var Z=i(11134),U=i(11311);const C=4,B=4,o=1,m=2,O=8,J=65536,G=J>>3,H=14,e=65537,F=1<<H,z=F-1,E=59,l=63,h=2+l-E;var c,f;!function(k){k[k.NO_COMPRESSION=0]="NO_COMPRESSION",k[k.RLE_COMPRESSION=1]="RLE_COMPRESSION",k[k.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",k[k.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",k[k.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",k[k.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(c||(c={})),function(k){k[k.INCREASING_Y=0]="INCREASING_Y",k[k.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const Y=function(){const k=new ArrayBuffer(4),Q=new Float32Array(k),i=new Uint32Array(k),Z=new Uint32Array(512),U=new Uint32Array(512);for(let m=0;m<256;++m){const k=m-127;k<-27?(Z[m]=0,Z[256|m]=32768,U[m]=24,U[256|m]=24):k<-14?(Z[m]=1024>>-k-14,Z[256|m]=1024>>-k-14|32768,U[m]=-k-1,U[256|m]=-k-1):k<=15?(Z[m]=k+15<<10,Z[256|m]=k+15<<10|32768,U[m]=13,U[256|m]=13):k<128?(Z[m]=31744,Z[256|m]=64512,U[m]=24,U[256|m]=24):(Z[m]=31744,Z[256|m]=64512,U[m]=13,U[256|m]=13)}const C=new Uint32Array(2048),B=new Uint32Array(64),o=new Uint32Array(64);for(let m=1;m<1024;++m){let k=m<<13,Q=0;for(;0===(8388608&k);)k<<=1,Q-=8388608;k&=-8388609,Q+=947912704,C[m]=k|Q}for(let m=1024;m<2048;++m)C[m]=939524096+(m-1024<<13);for(let m=1;m<31;++m)B[m]=m<<23;B[31]=1199570944,B[32]=2147483648;for(let m=33;m<63;++m)B[m]=2147483648+(m-32<<23);B[63]=3347054592;for(let m=1;m<64;++m)32!==m&&(o[m]=1024);return{floatView:Q,uint32View:i,baseTable:Z,shiftTable:U,mantissaTable:C,exponentTable:B,offsetTable:o}}();function y(k,Q){const i=new Uint8Array(k);let Z=0;for(;0!=i[Q.value+Z];)Z+=1;const U=(new TextDecoder).decode(i.slice(Q.value,Q.value+Z));return Q.value=Q.value+Z+1,U}function L(k,Q){const i=k.getInt32(Q.value,!0);return Q.value+=C,i}function s(k,Q){const i=k.getUint32(Q.value,!0);return Q.value+=C,i}function u(k,Q){const i=k.getUint8(Q.value);return Q.value+=o,i}function a(k,Q){const i=k.getUint16(Q.value,!0);return Q.value+=m,i}function j(k,Q){const i=k[Q.value];return Q.value+=o,i}function T(k,Q){let i;return i="getBigInt64"in DataView.prototype?Number(k.getBigInt64(Q.value,!0)):k.getUint32(Q.value+4,!0)+Number(k.getUint32(Q.value,!0)<<32),Q.value+=O,i}function K(k,Q){const i=k.getFloat32(Q.value,!0);return Q.value+=B,i}function v(k,Q){return function(k){const Q=(31744&k)>>10,i=1023&k;return(k>>15?-1:1)*(Q?31===Q?i?NaN:1/0:Math.pow(2,Q-15)*(1+i/1024):i/1024*6103515625e-14)}(a(k,Q))}function N(k,Q){return function(k){if(Math.abs(k)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");k=(0,U.Clamp)(k,-65504,65504),Y.floatView[0]=k;const Q=Y.uint32View[0],i=Q>>23&511;return Y.baseTable[i]+((8388607&Q)>>Y.shiftTable[i])}(K(k,Q))}function X(k,Q,i,Z){switch(i){case"string":case"stringvector":case"iccProfile":return function(k,Q,i){const Z=(new TextDecoder).decode(new Uint8Array(k).slice(Q.value,Q.value+i));return Q.value=Q.value+i,Z}(k.buffer,Q,Z);case"chlist":return function(k,Q,i){const Z=Q.value,U=[];for(;Q.value<Z+i-1;){const i=y(k.buffer,Q),Z=L(k,Q),C=u(k,Q);Q.value+=3;const B=L(k,Q),o=L(k,Q);U.push({name:i,pixelType:Z,pLinear:C,xSampling:B,ySampling:o})}return Q.value+=1,U}(k,Q,Z);case"chromaticities":return function(k,Q){return{redX:K(k,Q),redY:K(k,Q),greenX:K(k,Q),greenY:K(k,Q),blueX:K(k,Q),blueY:K(k,Q),whiteX:K(k,Q),whiteY:K(k,Q)}}(k,Q);case"compression":return function(k,Q){return u(k,Q)}(k,Q);case"box2i":return function(k,Q){return{xMin:L(k,Q),yMin:L(k,Q),xMax:L(k,Q),yMax:L(k,Q)}}(k,Q);case"lineOrder":return function(k,Q){const i=u(k,Q);return f[i]}(k,Q);case"float":return K(k,Q);case"v2f":return function(k,Q){return[K(k,Q),K(k,Q)]}(k,Q);case"v3f":return function(k,Q){return[K(k,Q),K(k,Q),K(k,Q)]}(k,Q);case"int":return L(k,Q);case"rational":return function(k,Q){return[L(k,Q),s(k,Q)]}(k,Q);case"timecode":return function(k,Q){return[s(k,Q),s(k,Q)]}(k,Q);case"preview":return Q.value+=Z,"skipped";default:return void(Q.value+=Z)}}function p(k){for(let Q=1;Q<k.length;Q++){const i=k[Q-1]+k[Q]-128;k[Q]=i}}function d(k,Q){let i=0,Z=Math.floor((k.length+1)/2),U=0;const C=k.length-1;for(;!(U>C)&&(Q[U++]=k[i++],!(U>C));)Q[U++]=k[Z++]}const b=20000630;function D(k,Q){if(k.getUint32(0,!0)!=b)throw new Error("Incorrect OpenEXR format");const i=k.getUint8(4),U=k.getUint8(5),C={singleTile:!!(2&U),longName:!!(4&U),deepFormat:!!(8&U),multiPart:!!(16&U)};Q.value=8;const B={};let o=!0;for(;o;){const i=y(k.buffer,Q);if(i){const U=y(k.buffer,Q),C=X(k,Q,U,s(k,Q));void 0===C?Z.c.Warn(`Unknown header attribute type ${U}'.`):B[i]=C}else o=!1}if(0!=(-5&U))throw new Error("Unsupported file format");return{version:i,spec:C,...B}}const M=32768,W=65535;function A(k,Q,i,Z,U){for(;i<k;)Q=Q<<8|j(Z,U),i+=8;return{l:Q>>(i-=k)&(1<<k)-1,c:Q,lc:i}}function g(k,Q,i,Z){return{c:k=k<<8|j(i,Z),lc:Q+=8}}function R(k,Q,i,Z,U,C,B,o,m){if(k==Q){if(Z<8){const k=g(i,Z,U,C);i=k.c,Z=k.lc}let k=i>>(Z-=8);if(k=new Uint8Array([k])[0],o.value+k>m)return null;const Q=B[o.value-1];for(;k-- >0;)B[o.value++]=Q}else{if(!(o.value<m))return null;B[o.value++]=k}return{c:i,lc:Z}}const w=new Array(59);function S(k,Q,i,Z,U,C){const B=Q;let o=0,m=0;for(;Z<=U;Z++){if(B.value-Q.value>i)return;let O=A(6,o,m,k,B);const J=O.l;if(o=O.c,m=O.lc,C[Z]=J,J==l){if(B.value-Q.value>i)throw new Error("Error in HufUnpackEncTable");O=A(8,o,m,k,B);let J=O.l+h;if(o=O.c,m=O.lc,Z+J>U+1)throw new Error("Error in HufUnpackEncTable");for(;J--;)C[Z++]=0;Z--}else if(J>=E){let k=J-E+2;if(Z+k>U+1)throw new Error("Error in HufUnpackEncTable");for(;k--;)C[Z++]=0;Z--}}!function(k){for(let i=0;i<=58;++i)w[i]=0;for(let i=0;i<e;++i)w[k[i]]+=1;let Q=0;for(let i=58;i>0;--i){const k=Q+w[i]>>1;w[i]=Q,Q=k}for(let i=0;i<e;++i){const Q=k[i];Q>0&&(k[i]=Q|w[Q]++<<6)}}(C)}function q(k){return 63&k}function P(k){return k>>6}function t(k,Q,i,Z,U,C){const B=i.value,o=s(Q,i),m=s(Q,i);i.value+=4;const O=s(Q,i);if(i.value+=4,o<0||o>=e||m<0||m>=e)throw new Error("Wrong HUF_ENCSIZE");const J=new Array(e),G=new Array(F);!function(k){for(let Q=0;Q<F;Q++)k[Q]={},k[Q].len=0,k[Q].lit=0,k[Q].p=null}(G);if(S(k,i,Z-(i.value-B),o,m,J),O>8*(Z-(i.value-B)))throw new Error("Wrong hufUncompress");!function(k,Q,i,Z){for(;Q<=i;Q++){const i=P(k[Q]),U=q(k[Q]);if(i>>U)throw new Error("Invalid table entry");if(U>H){const k=Z[i>>U-H];if(k.len)throw new Error("Invalid table entry");if(k.lit++,k.p){const Q=k.p;k.p=new Array(k.lit);for(let i=0;i<k.lit-1;++i)k.p[i]=Q[i]}else k.p=new Array(1);k.p[k.lit-1]=Q}else if(U){let k=0;for(let C=1<<H-U;C>0;C--){const C=Z[(i<<H-U)+k];if(C.len||C.p)throw new Error("Invalid table entry");C.len=U,C.lit=Q,k++}}}}(J,o,m,G),function(k,Q,i,Z,U,C,B,o,m){let O=0,J=0;const G=B,e=Math.trunc(Z.value+(U+7)/8);for(;Z.value<e;){let U=g(O,J,i,Z);for(O=U.c,J=U.lc;J>=H;){const B=Q[O>>J-H&z];if(B.len){J-=B.len;const k=R(B.lit,C,O,J,i,Z,o,m,G);k&&(O=k.c,J=k.lc)}else{if(!B.p)throw new Error("hufDecode issues");let Q;for(Q=0;Q<B.lit;Q++){const H=q(k[B.p[Q]]);for(;J<H&&Z.value<e;)U=g(O,J,i,Z),O=U.c,J=U.lc;if(J>=H&&P(k[B.p[Q]])==(O>>J-H&(1<<H)-1)){J-=H;const k=R(B.p[Q],C,O,J,i,Z,o,m,G);k&&(O=k.c,J=k.lc);break}}if(Q==B.lit)throw new Error("HufDecode issues")}}}const F=8-U&7;for(O>>=F,J-=F;J>0;){const k=Q[O<<H-J&z];if(!k.len)throw new Error("HufDecode issues");{J-=k.len;const Q=R(k.lit,C,O,J,i,Z,o,m,G);Q&&(O=Q.c,J=Q.lc)}}}(J,G,k,i,O,m,C,U,{value:0})}function I(k){return 65535&k}function r(k){const Q=I(k);return Q>32767?Q-65536:Q}function n(k,Q){const i=r(k),Z=r(Q),U=i+(1&Z)+(Z>>1);return{a:U,b:U-Z}}function x(k,Q){const i=I(k),Z=I(Q),U=i-(Z>>1)&W;return{a:Z+U-M&W,b:U}}function V(k,Q,i,Z,U,C,B){const o=B<16384,m=i>U?U:i;let O,J,G=1;for(;G<=m;)G<<=1;for(G>>=1,O=G,G>>=1;G>=1;){J=0;const B=J+C*(U-O),m=C*G,H=C*O,e=Z*G,F=Z*O;let z,E,l,h;for(;J<=B;J+=H){let U=J;const C=J+Z*(i-O);for(;U<=C;U+=F){const i=U+e,Z=U+m,C=Z+e;if(o){let B=n(k[U+Q],k[Z+Q]);z=B.a,l=B.b,B=n(k[i+Q],k[C+Q]),E=B.a,h=B.b,B=n(z,E),k[U+Q]=B.a,k[i+Q]=B.b,B=n(l,h),k[Z+Q]=B.a,k[C+Q]=B.b}else{let B=x(k[U+Q],k[Z+Q]);z=B.a,l=B.b,B=x(k[i+Q],k[C+Q]),E=B.a,h=B.b,B=x(z,E),k[U+Q]=B.a,k[i+Q]=B.b,B=x(l,h),k[Z+Q]=B.a,k[C+Q]=B.b}}if(i&G){const i=U+m;let Z;Z=o?n(k[U+Q],k[i+Q]):x(k[U+Q],k[i+Q]),z=Z.a,k[i+Q]=Z.b,k[U+Q]=z}}if(U&G){let U=J;const C=J+Z*(i-O);for(;U<=C;U+=F){const i=U+e;let Z;Z=o?n(k[U+Q],k[i+Q]):x(k[U+Q],k[i+Q]),z=Z.a,k[i+Q]=Z.b,k[U+Q]=z}}O=G,G>>=1}return J}function kk(k){return new DataView(k.array.buffer,k.offset.value,k.size)}function Qk(k){const Q=k.viewer.buffer.slice(k.offset.value,k.offset.value+k.size),i=new Uint8Array(function(k){let Q=k.byteLength;const i=[];let Z=0;const U=new DataView(k);for(;Q>0;){const k=U.getInt8(Z++);if(k<0){const C=-k;Q-=C+1;for(let k=0;k<C;k++)i.push(U.getUint8(Z++))}else{const C=k;Q-=2;const B=U.getUint8(Z++);for(let k=0;k<C+1;k++)i.push(B)}}return i}(Q)),Z=new Uint8Array(i.length);return p(i),d(i,Z),new DataView(Z.buffer)}function ik(k){const Q=k.array.slice(k.offset.value,k.offset.value+k.size),i=fflate.unzlibSync(Q),Z=new Uint8Array(i.length);return p(i),d(i,Z),new DataView(Z.buffer)}function Zk(k){const Q=k.array.slice(k.offset.value,k.offset.value+k.size),i=fflate.unzlibSync(Q),Z=k.lines*k.channels*k.width,U=1==k.type?new Uint16Array(Z):new Uint32Array(Z);let C=0,B=0;const o=new Array(4);for(let m=0;m<k.lines;m++)for(let Q=0;Q<k.channels;Q++){let Q=0;switch(k.type){case 1:o[0]=C,o[1]=o[0]+k.width,C=o[1]+k.width;for(let Z=0;Z<k.width;++Z){Q+=i[o[0]++]<<8|i[o[1]++],U[B]=Q,B++}break;case 2:o[0]=C,o[1]=o[0]+k.width,o[2]=o[1]+k.width,C=o[2]+k.width;for(let Z=0;Z<k.width;++Z){Q+=i[o[0]++]<<24|i[o[1]++]<<16|i[o[2]++]<<8,U[B]=Q,B++}}}return new DataView(U.buffer)}function Uk(k){const Q=k.viewer,i={value:k.offset.value},Z=new Uint16Array(k.width*k.scanlineBlockSize*(k.channels*k.type)),U=new Uint8Array(G);let C=0;const B=new Array(k.channels);for(let m=0;m<k.channels;m++)B[m]={},B[m].start=C,B[m].end=B[m].start,B[m].nx=k.width,B[m].ny=k.lines,B[m].size=k.type,C+=B[m].nx*B[m].ny*B[m].size;const o=a(Q,i),O=a(Q,i);if(O>=G)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=O)for(let m=0;m<O-o+1;m++)U[m+o]=u(Q,i);const H=new Uint16Array(J),e=function(k,Q){let i=0;for(let U=0;U<J;++U)(0==U||k[U>>3]&1<<(7&U))&&(Q[i++]=U);const Z=i-1;for(;i<J;)Q[i++]=0;return Z}(U,H),F=s(Q,i);t(k.array,Q,i,F,Z,C);for(let m=0;m<k.channels;++m){const k=B[m];for(let Q=0;Q<B[m].size;++Q)V(Z,k.start+Q,k.nx,k.size,k.ny,k.nx*k.size,e)}!function(k,Q,i){for(let Z=0;Z<i;++Z)Q[Z]=k[Q[Z]]}(H,Z,C);let z=0;const E=new Uint8Array(Z.buffer.byteLength);for(let J=0;J<k.lines;J++)for(let Q=0;Q<k.channels;Q++){const k=B[Q],i=k.nx*k.size,U=new Uint8Array(Z.buffer,k.end*m,i*m);E.set(U,z),z+=i*m,k.end+=i}return new DataView(E.buffer)}var Ck,Bk=i(11119);!function(k){k[k.Float=0]="Float",k[k.HalfFloat=1]="HalfFloat"}(Ck||(Ck={}));class ok{}async function mk(k,Q,i,Z){const U={size:0,viewer:Q,array:new Uint8Array(Q.buffer),offset:i,width:k.dataWindow.xMax-k.dataWindow.xMin+1,height:k.dataWindow.yMax-k.dataWindow.yMin+1,channels:k.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(k.compression){case c.NO_COMPRESSION:U.lines=1,U.uncompress=kk;break;case c.RLE_COMPRESSION:U.lines=1,U.uncompress=Qk;break;case c.ZIPS_COMPRESSION:U.lines=1,U.uncompress=ik,await Bk.Tools.LoadScriptAsync(ok.FFLATEUrl);break;case c.ZIP_COMPRESSION:U.lines=16,U.uncompress=ik,await Bk.Tools.LoadScriptAsync(ok.FFLATEUrl);break;case c.PIZ_COMPRESSION:U.lines=32,U.uncompress=Uk;break;case c.PXR24_COMPRESSION:U.lines=16,U.uncompress=Zk,await Bk.Tools.LoadScriptAsync(ok.FFLATEUrl);break;default:throw new Error(c[k.compression]+" is unsupported")}U.scanlineBlockSize=U.lines;const C={};for(const B of k.channels)switch(B.name){case"R":case"G":case"B":case"A":case"Y":C[B.name]=!0,U.type=B.pixelType}let o=!1;if(C.R&&C.G&&C.B&&C.A)U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G&&C.B)o=!0,U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G)U.outputChannels=2,U.decodeChannels={R:0,G:1};else if(C.R)U.outputChannels=1,U.decodeChannels={R:0};else{if(!C.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");U.outputChannels=1,U.decodeChannels={Y:0}}if(1===U.type)switch(Z){case Ck.Float:U.getter=v,U.inputSize=m;break;case Ck.HalfFloat:U.getter=a,U.inputSize=m}else{if(2!==U.type)throw new Error("Unsupported pixelType "+U.type+" for "+k.compression);switch(Z){case Ck.Float:U.getter=K,U.inputSize=B;break;case Ck.HalfFloat:U.getter=N,U.inputSize=B}}U.blockCount=U.height/U.scanlineBlockSize;for(let B=0;B<U.blockCount;B++)T(Q,i);const O=U.width*U.height*U.outputChannels;switch(Z){case Ck.Float:U.byteArray=new Float32Array(O),U.textureType=1,o&&U.byteArray.fill(1,0,O);break;case Ck.HalfFloat:U.byteArray=new Uint16Array(O),U.textureType=2,o&&U.byteArray.fill(15360,0,O);break;default:throw new Error("Unsupported type: "+Z)}let J=0;for(const B of k.channels)void 0!==U.decodeChannels[B.name]&&(U.channelLineOffsets[B.name]=J*U.width),J+=2*B.pixelType;return U.bytesPerLine=U.width*J,U.outLineWidth=U.width*U.outputChannels,"INCREASING_Y"===k.lineOrder?U.scanOrder=k=>k:U.scanOrder=k=>U.height-1-k,4==U.outputChannels?(U.format=5,U.linearSpace=!0):(U.format=6,U.linearSpace=!1),U}function Ok(k,Q,i,Z){const U={value:0};for(let C=0;C<k.height/k.scanlineBlockSize;C++){const B=L(i,Z)-Q.dataWindow.yMin;k.size=s(i,Z),k.lines=B+k.scanlineBlockSize>k.height?k.height-B:k.scanlineBlockSize;const o=k.size<k.lines*k.bytesPerLine&&k.uncompress?k.uncompress(k):kk(k);Z.value+=k.size;for(let i=0;i<k.scanlineBlockSize;i++){const Z=C*k.scanlineBlockSize,B=i+k.scanOrder(Z);if(B>=k.height)continue;const m=i*k.bytesPerLine,O=(k.height-1-B)*k.outLineWidth;for(let i=0;i<k.channels;i++){const Z=Q.channels[i].name,C=k.channelLineOffsets[Z],B=k.decodeChannels[Z];if(void 0!==B){U.value=m+C;for(let Q=0;Q<k.width;Q++){const i=O+Q*k.outputChannels+B;k.byteArray&&(k.byteArray[i]=k.getter(o,U))}}}}}}ok.DefaultOutputType=Ck.HalfFloat,ok.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Jk{constructor(){this.supportCascades=!1}loadCubeData(k,Q,i,Z,U){throw".exr not supported in Cube."}loadData(k,Q,i){const U=new DataView(k.buffer),C={value:0},B=D(U,C);mk(B,U,C,ok.DefaultOutputType).then((k=>{Ok(k,B,U,C);const Z=B.dataWindow.xMax-B.dataWindow.xMin+1,o=B.dataWindow.yMax-B.dataWindow.yMin+1;i(Z,o,Q.generateMipMaps,!1,(()=>{const i=Q.getEngine();Q.format=B.format,Q.type=k.textureType,Q.invertY=!1,Q._gammaSpace=!B.linearSpace,k.byteArray&&i._uploadDataToTextureDirectly(Q,k.byteArray,0,0,void 0,!0)}))})).catch((k=>{Z.c.Error("Failed to load EXR texture: ",k)}))}}async function Gk(k){const Q=new DataView(k),i={value:0},U=D(Q,i);try{const k=await mk(U,Q,i,Ck.Float);return Ok(k,U,Q,i),k.byteArray?{width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,data:new Float32Array(k.byteArray)}:(Z.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(C){Z.c.Error("Failed to load EXR data: ",C)}return{width:0,height:0,data:null}}},11311:(k,Q,i)=>{function Z(k){return parseInt(k.toString().replace(/\W/g,""))}function U(k,Q){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(k-Q)<=i}function C(k,Q,i){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return k<Q-Z||k>i+Z}function B(k,Q){return k===Q?k:Math.random()*(Q-k)+k}function o(k,Q,i){return k+(Q-k)*i}function m(k,Q,i){let Z=E(Q-k,360);return Z>180&&(Z-=360),k+Z*H(i)}function O(k,Q,i){let Z=0;return Z=k!=Q?H((i-k)/(Q-k)):0,Z}function J(k,Q,i,Z,U){const C=U*U,B=U*C;return k*(2*B-3*C+1)+i*(-2*B+3*C)+Q*(B-2*C+U)+Z*(B-C)}function G(k,Q,i,Z,U){const C=U*U;return 6*(C-U)*k+(3*C-4*U+1)*Q+6*(-C+U)*i+(3*C-2*U)*Z}function H(k){let Q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(i,Math.max(Q,k))}function e(k){return k-=2*Math.PI*Math.floor((k+Math.PI)/(2*Math.PI))}function F(k){const Q=k.toString(16);return k<=15?("0"+Q).toUpperCase():Q.toUpperCase()}function z(k){if(Math.log2)return Math.floor(Math.log2(k));if(k<0)return NaN;if(0===k)return-1/0;let Q=0;if(k<1){for(;k<1;)Q++,k*=2;Q=-Q}else if(k>1)for(;k>1;)Q++,k=Math.floor(k/2);return Q}function E(k,Q){return k-Math.floor(k/Q)*Q}function l(k,Q,i){return(k-Q)/(i-Q)}function h(k,Q,i){return k*(i-Q)+Q}function c(k,Q){let i=E(Q-k,360);return i>180&&(i-=360),i}function f(k,Q){const i=E(k,2*Q);return Q-Math.abs(i-Q)}function Y(k,Q,i){let Z=H(i);return Z=-2*Z*Z*Z+3*Z*Z,Q*Z+k*(1-Z)}function y(k,Q,i){let Z=0;return Z=Math.abs(Q-k)<=i?Q:k+Math.sign(Q-k)*i,Z}function L(k,Q,i){const Z=c(k,Q);let U=0;return U=-i<Z&&Z<i?Q:y(k,Q=k+Z,i),U}function s(k,Q,i){return(k-Q)/(i-Q)}function u(k,Q,i){return(i-Q)*k+Q}function a(k,Q){const i=k%Q;return 0===i?Q:a(Q,i)}i.r(Q),i.d(Q,{Clamp:()=>H,DeltaAngle:()=>c,Denormalize:()=>h,ExtractAsInt:()=>Z,Hermite:()=>J,Hermite1stDerivative:()=>G,HighestCommonFactor:()=>a,ILog2:()=>z,InverseLerp:()=>O,Lerp:()=>o,LerpAngle:()=>m,MoveTowards:()=>y,MoveTowardsAngle:()=>L,Normalize:()=>l,NormalizeRadians:()=>e,OutsideRange:()=>C,PercentToRange:()=>u,PingPong:()=>f,RandomRange:()=>B,RangeToPercent:()=>s,Repeat:()=>E,SmoothStep:()=>Y,ToHex:()=>F,WithinEpsilon:()=>U})}}]);