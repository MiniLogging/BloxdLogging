"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13733:(Z,x,F)=>{F.r(x),F.d(x,{ReadExrDataAsync:()=>cZ,_ExrTextureLoader:()=>oZ});var u=F(11012),G=F(11194);const f=4,Y=4,j=1,d=2,t=8,o=65536,c=o>>3,s=14,J=65537,p=1<<s,U=p-1,k=59,M=63,m=2+M-k;var C,L;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(C||(C={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(L||(L={}));const H=function(){const Z=new ArrayBuffer(4),x=new Float32Array(Z),F=new Uint32Array(Z),u=new Uint32Array(512),G=new Uint32Array(512);for(let d=0;d<256;++d){const Z=d-127;Z<-27?(u[d]=0,u[256|d]=32768,G[d]=24,G[256|d]=24):Z<-14?(u[d]=1024>>-Z-14,u[256|d]=1024>>-Z-14|32768,G[d]=-Z-1,G[256|d]=-Z-1):Z<=15?(u[d]=Z+15<<10,u[256|d]=Z+15<<10|32768,G[d]=13,G[256|d]=13):Z<128?(u[d]=31744,u[256|d]=64512,G[d]=24,G[256|d]=24):(u[d]=31744,u[256|d]=64512,G[d]=13,G[256|d]=13)}const f=new Uint32Array(2048),Y=new Uint32Array(64),j=new Uint32Array(64);for(let d=1;d<1024;++d){let Z=d<<13,x=0;for(;0===(8388608&Z);)Z<<=1,x-=8388608;Z&=-8388609,x+=947912704,f[d]=Z|x}for(let d=1024;d<2048;++d)f[d]=939524096+(d-1024<<13);for(let d=1;d<31;++d)Y[d]=d<<23;Y[31]=1199570944,Y[32]=2147483648;for(let d=33;d<63;++d)Y[d]=2147483648+(d-32<<23);Y[63]=3347054592;for(let d=1;d<64;++d)32!==d&&(j[d]=1024);return{floatView:x,uint32View:F,baseTable:u,shiftTable:G,mantissaTable:f,exponentTable:Y,offsetTable:j}}();function S(Z,x){const F=new Uint8Array(Z);let u=0;for(;0!=F[x.value+u];)u+=1;const G=(new TextDecoder).decode(F.slice(x.value,x.value+u));return x.value=x.value+u+1,G}function K(Z,x){const F=Z.getInt32(x.value,!0);return x.value+=f,F}function y(Z,x){const F=Z.getUint32(x.value,!0);return x.value+=f,F}function q(Z,x){const F=Z.getUint8(x.value);return x.value+=j,F}function R(Z,x){const F=Z.getUint16(x.value,!0);return x.value+=d,F}function B(Z,x){const F=Z[x.value];return x.value+=j,F}function v(Z,x){let F;return F="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(x.value,!0)):Z.getUint32(x.value+4,!0)+Number(Z.getUint32(x.value,!0)<<32),x.value+=t,F}function l(Z,x){const F=Z.getFloat32(x.value,!0);return x.value+=Y,F}function i(Z,x){return function(Z){const x=(31744&Z)>>10,F=1023&Z;return(Z>>15?-1:1)*(x?31===x?F?NaN:1/0:Math.pow(2,x-15)*(1+F/1024):F/1024*6103515625e-14)}(R(Z,x))}function e(Z,x){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,G.Clamp)(Z,-65504,65504),H.floatView[0]=Z;const x=H.uint32View[0],F=x>>23&511;return H.baseTable[F]+((8388607&x)>>H.shiftTable[F])}(l(Z,x))}function b(Z,x,F,u){switch(F){case"string":case"stringvector":case"iccProfile":return function(Z,x,F){const u=(new TextDecoder).decode(new Uint8Array(Z).slice(x.value,x.value+F));return x.value=x.value+F,u}(Z.buffer,x,u);case"chlist":return function(Z,x,F){const u=x.value,G=[];for(;x.value<u+F-1;){const F=S(Z.buffer,x),u=K(Z,x),f=q(Z,x);x.value+=3;const Y=K(Z,x),j=K(Z,x);G.push({name:F,pixelType:u,pLinear:f,xSampling:Y,ySampling:j})}return x.value+=1,G}(Z,x,u);case"chromaticities":return function(Z,x){return{redX:l(Z,x),redY:l(Z,x),greenX:l(Z,x),greenY:l(Z,x),blueX:l(Z,x),blueY:l(Z,x),whiteX:l(Z,x),whiteY:l(Z,x)}}(Z,x);case"compression":return function(Z,x){return q(Z,x)}(Z,x);case"box2i":return function(Z,x){return{xMin:K(Z,x),yMin:K(Z,x),xMax:K(Z,x),yMax:K(Z,x)}}(Z,x);case"lineOrder":return function(Z,x){const F=q(Z,x);return L[F]}(Z,x);case"float":return l(Z,x);case"v2f":return function(Z,x){return[l(Z,x),l(Z,x)]}(Z,x);case"v3f":return function(Z,x){return[l(Z,x),l(Z,x),l(Z,x)]}(Z,x);case"int":return K(Z,x);case"rational":return function(Z,x){return[K(Z,x),y(Z,x)]}(Z,x);case"timecode":return function(Z,x){return[y(Z,x),y(Z,x)]}(Z,x);case"preview":return x.value+=u,"skipped";default:return void(x.value+=u)}}function E(Z){for(let x=1;x<Z.length;x++){const F=Z[x-1]+Z[x]-128;Z[x]=F}}function w(Z,x){let F=0,u=Math.floor((Z.length+1)/2),G=0;const f=Z.length-1;for(;!(G>f)&&(x[G++]=Z[F++],!(G>f));)x[G++]=Z[u++]}const T=20000630;function N(Z,x){if(Z.getUint32(0,!0)!=T)throw new Error("Incorrect OpenEXR format");const F=Z.getUint8(4),G=Z.getUint8(5),f={singleTile:!!(2&G),longName:!!(4&G),deepFormat:!!(8&G),multiPart:!!(16&G)};x.value=8;const Y={};let j=!0;for(;j;){const F=S(Z.buffer,x);if(F){const G=S(Z.buffer,x),f=b(Z,x,G,y(Z,x));void 0===f?u.d.Warn(`Unknown header attribute type ${G}'.`):Y[F]=f}else j=!1}if(0!=(-5&G))throw new Error("Unsupported file format");return{version:F,spec:f,...Y}}const W=32768,A=65535;function h(Z,x,F,u,G){for(;F<Z;)x=x<<8|B(u,G),F+=8;return{l:x>>(F-=Z)&(1<<Z)-1,c:x,lc:F}}function X(Z,x,F,u){return{c:Z=Z<<8|B(F,u),lc:x+=8}}function D(Z,x,F,u,G,f,Y,j,d){if(Z==x){if(u<8){const Z=X(F,u,G,f);F=Z.c,u=Z.lc}let Z=F>>(u-=8);if(Z=new Uint8Array([Z])[0],j.value+Z>d)return null;const x=Y[j.value-1];for(;Z-- >0;)Y[j.value++]=x}else{if(!(j.value<d))return null;Y[j.value++]=Z}return{c:F,lc:u}}const Q=new Array(59);function g(Z,x,F,u,G,f){const Y=x;let j=0,d=0;for(;u<=G;u++){if(Y.value-x.value>F)return;let t=h(6,j,d,Z,Y);const o=t.l;if(j=t.c,d=t.lc,f[u]=o,o==M){if(Y.value-x.value>F)throw new Error("Error in HufUnpackEncTable");t=h(8,j,d,Z,Y);let o=t.l+m;if(j=t.c,d=t.lc,u+o>G+1)throw new Error("Error in HufUnpackEncTable");for(;o--;)f[u++]=0;u--}else if(o>=k){let Z=o-k+2;if(u+Z>G+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)f[u++]=0;u--}}!function(Z){for(let F=0;F<=58;++F)Q[F]=0;for(let F=0;F<J;++F)Q[Z[F]]+=1;let x=0;for(let F=58;F>0;--F){const Z=x+Q[F]>>1;Q[F]=x,x=Z}for(let F=0;F<J;++F){const x=Z[F];x>0&&(Z[F]=x|Q[x]++<<6)}}(f)}function O(Z){return 63&Z}function n(Z){return Z>>6}function V(Z,x,F,u,G,f){const Y=F.value,j=y(x,F),d=y(x,F);F.value+=4;const t=y(x,F);if(F.value+=4,j<0||j>=J||d<0||d>=J)throw new Error("Wrong HUF_ENCSIZE");const o=new Array(J),c=new Array(p);!function(Z){for(let x=0;x<p;x++)Z[x]={},Z[x].len=0,Z[x].lit=0,Z[x].p=null}(c);if(g(Z,F,u-(F.value-Y),j,d,o),t>8*(u-(F.value-Y)))throw new Error("Wrong hufUncompress");!function(Z,x,F,u){for(;x<=F;x++){const F=n(Z[x]),G=O(Z[x]);if(F>>G)throw new Error("Invalid table entry");if(G>s){const Z=u[F>>G-s];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const x=Z.p;Z.p=new Array(Z.lit);for(let F=0;F<Z.lit-1;++F)Z.p[F]=x[F]}else Z.p=new Array(1);Z.p[Z.lit-1]=x}else if(G){let Z=0;for(let f=1<<s-G;f>0;f--){const f=u[(F<<s-G)+Z];if(f.len||f.p)throw new Error("Invalid table entry");f.len=G,f.lit=x,Z++}}}}(o,j,d,c),function(Z,x,F,u,G,f,Y,j,d){let t=0,o=0;const c=Y,J=Math.trunc(u.value+(G+7)/8);for(;u.value<J;){let G=X(t,o,F,u);for(t=G.c,o=G.lc;o>=s;){const Y=x[t>>o-s&U];if(Y.len){o-=Y.len;const Z=D(Y.lit,f,t,o,F,u,j,d,c);Z&&(t=Z.c,o=Z.lc)}else{if(!Y.p)throw new Error("hufDecode issues");let x;for(x=0;x<Y.lit;x++){const s=O(Z[Y.p[x]]);for(;o<s&&u.value<J;)G=X(t,o,F,u),t=G.c,o=G.lc;if(o>=s&&n(Z[Y.p[x]])==(t>>o-s&(1<<s)-1)){o-=s;const Z=D(Y.p[x],f,t,o,F,u,j,d,c);Z&&(t=Z.c,o=Z.lc);break}}if(x==Y.lit)throw new Error("HufDecode issues")}}}const p=8-G&7;for(t>>=p,o-=p;o>0;){const Z=x[t<<s-o&U];if(!Z.len)throw new Error("HufDecode issues");{o-=Z.len;const x=D(Z.lit,f,t,o,F,u,j,d,c);x&&(t=x.c,o=x.lc)}}}(o,c,Z,F,t,d,f,G,{value:0})}function a(Z){return 65535&Z}function I(Z){const x=a(Z);return x>32767?x-65536:x}function r(Z,x){const F=I(Z),u=I(x),G=F+(1&u)+(u>>1);return{a:G,b:G-u}}function z(Z,x){const F=a(Z),u=a(x),G=F-(u>>1)&A;return{a:u+G-W&A,b:G}}function P(Z,x,F,u,G,f,Y){const j=Y<16384,d=F>G?G:F;let t,o,c=1;for(;c<=d;)c<<=1;for(c>>=1,t=c,c>>=1;c>=1;){o=0;const Y=o+f*(G-t),d=f*c,s=f*t,J=u*c,p=u*t;let U,k,M,m;for(;o<=Y;o+=s){let G=o;const f=o+u*(F-t);for(;G<=f;G+=p){const F=G+J,u=G+d,f=u+J;if(j){let Y=r(Z[G+x],Z[u+x]);U=Y.a,M=Y.b,Y=r(Z[F+x],Z[f+x]),k=Y.a,m=Y.b,Y=r(U,k),Z[G+x]=Y.a,Z[F+x]=Y.b,Y=r(M,m),Z[u+x]=Y.a,Z[f+x]=Y.b}else{let Y=z(Z[G+x],Z[u+x]);U=Y.a,M=Y.b,Y=z(Z[F+x],Z[f+x]),k=Y.a,m=Y.b,Y=z(U,k),Z[G+x]=Y.a,Z[F+x]=Y.b,Y=z(M,m),Z[u+x]=Y.a,Z[f+x]=Y.b}}if(F&c){const F=G+d;let u;u=j?r(Z[G+x],Z[F+x]):z(Z[G+x],Z[F+x]),U=u.a,Z[F+x]=u.b,Z[G+x]=U}}if(G&c){let G=o;const f=o+u*(F-t);for(;G<=f;G+=p){const F=G+J;let u;u=j?r(Z[G+x],Z[F+x]):z(Z[G+x],Z[F+x]),U=u.a,Z[F+x]=u.b,Z[G+x]=U}}t=c,c>>=1}return o}function ZZ(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function xZ(Z){const x=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),F=new Uint8Array(function(Z){let x=Z.byteLength;const F=[];let u=0;const G=new DataView(Z);for(;x>0;){const Z=G.getInt8(u++);if(Z<0){const f=-Z;x-=f+1;for(let Z=0;Z<f;Z++)F.push(G.getUint8(u++))}else{const f=Z;x-=2;const Y=G.getUint8(u++);for(let Z=0;Z<f+1;Z++)F.push(Y)}}return F}(x)),u=new Uint8Array(F.length);return E(F),w(F,u),new DataView(u.buffer)}function FZ(Z){const x=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),F=fflate.unzlibSync(x),u=new Uint8Array(F.length);return E(F),w(F,u),new DataView(u.buffer)}function uZ(Z){const x=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),F=fflate.unzlibSync(x),u=Z.lines*Z.channels*Z.width,G=1==Z.type?new Uint16Array(u):new Uint32Array(u);let f=0,Y=0;const j=new Array(4);for(let d=0;d<Z.lines;d++)for(let x=0;x<Z.channels;x++){let x=0;switch(Z.type){case 1:j[0]=f,j[1]=j[0]+Z.width,f=j[1]+Z.width;for(let u=0;u<Z.width;++u){x+=F[j[0]++]<<8|F[j[1]++],G[Y]=x,Y++}break;case 2:j[0]=f,j[1]=j[0]+Z.width,j[2]=j[1]+Z.width,f=j[2]+Z.width;for(let u=0;u<Z.width;++u){x+=F[j[0]++]<<24|F[j[1]++]<<16|F[j[2]++]<<8,G[Y]=x,Y++}}}return new DataView(G.buffer)}function GZ(Z){const x=Z.viewer,F={value:Z.offset.value},u=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),G=new Uint8Array(c);let f=0;const Y=new Array(Z.channels);for(let d=0;d<Z.channels;d++)Y[d]={},Y[d].start=f,Y[d].end=Y[d].start,Y[d].nx=Z.width,Y[d].ny=Z.lines,Y[d].size=Z.type,f+=Y[d].nx*Y[d].ny*Y[d].size;const j=R(x,F),t=R(x,F);if(t>=c)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(j<=t)for(let d=0;d<t-j+1;d++)G[d+j]=q(x,F);const s=new Uint16Array(o),J=function(Z,x){let F=0;for(let G=0;G<o;++G)(0==G||Z[G>>3]&1<<(7&G))&&(x[F++]=G);const u=F-1;for(;F<o;)x[F++]=0;return u}(G,s),p=y(x,F);V(Z.array,x,F,p,u,f);for(let d=0;d<Z.channels;++d){const Z=Y[d];for(let x=0;x<Y[d].size;++x)P(u,Z.start+x,Z.nx,Z.size,Z.ny,Z.nx*Z.size,J)}!function(Z,x,F){for(let u=0;u<F;++u)x[u]=Z[x[u]]}(s,u,f);let U=0;const k=new Uint8Array(u.buffer.byteLength);for(let o=0;o<Z.lines;o++)for(let x=0;x<Z.channels;x++){const Z=Y[x],F=Z.nx*Z.size,G=new Uint8Array(u.buffer,Z.end*d,F*d);k.set(G,U),U+=F*d,Z.end+=F}return new DataView(k.buffer)}var fZ,YZ=F(10994);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(fZ||(fZ={}));class jZ{}async function dZ(Z,x,F,u){const G={size:0,viewer:x,array:new Uint8Array(x.buffer),offset:F,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case C.NO_COMPRESSION:G.lines=1,G.uncompress=ZZ;break;case C.RLE_COMPRESSION:G.lines=1,G.uncompress=xZ;break;case C.ZIPS_COMPRESSION:G.lines=1,G.uncompress=FZ,await YZ.Tools.LoadScriptAsync(jZ.FFLATEUrl);break;case C.ZIP_COMPRESSION:G.lines=16,G.uncompress=FZ,await YZ.Tools.LoadScriptAsync(jZ.FFLATEUrl);break;case C.PIZ_COMPRESSION:G.lines=32,G.uncompress=GZ;break;case C.PXR24_COMPRESSION:G.lines=16,G.uncompress=uZ,await YZ.Tools.LoadScriptAsync(jZ.FFLATEUrl);break;default:throw new Error(C[Z.compression]+" is unsupported")}G.scanlineBlockSize=G.lines;const f={};for(const Y of Z.channels)switch(Y.name){case"R":case"G":case"B":case"A":case"Y":f[Y.name]=!0,G.type=Y.pixelType}let j=!1;if(f.R&&f.G&&f.B&&f.A)G.outputChannels=4,G.decodeChannels={R:0,G:1,B:2,A:3};else if(f.R&&f.G&&f.B)j=!0,G.outputChannels=4,G.decodeChannels={R:0,G:1,B:2,A:3};else if(f.R&&f.G)G.outputChannels=2,G.decodeChannels={R:0,G:1};else if(f.R)G.outputChannels=1,G.decodeChannels={R:0};else{if(!f.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");G.outputChannels=1,G.decodeChannels={Y:0}}if(1===G.type)switch(u){case fZ.Float:G.getter=i,G.inputSize=d;break;case fZ.HalfFloat:G.getter=R,G.inputSize=d}else{if(2!==G.type)throw new Error("Unsupported pixelType "+G.type+" for "+Z.compression);switch(u){case fZ.Float:G.getter=l,G.inputSize=Y;break;case fZ.HalfFloat:G.getter=e,G.inputSize=Y}}G.blockCount=G.height/G.scanlineBlockSize;for(let Y=0;Y<G.blockCount;Y++)v(x,F);const t=G.width*G.height*G.outputChannels;switch(u){case fZ.Float:G.byteArray=new Float32Array(t),G.textureType=1,j&&G.byteArray.fill(1,0,t);break;case fZ.HalfFloat:G.byteArray=new Uint16Array(t),G.textureType=2,j&&G.byteArray.fill(15360,0,t);break;default:throw new Error("Unsupported type: "+u)}let o=0;for(const Y of Z.channels)void 0!==G.decodeChannels[Y.name]&&(G.channelLineOffsets[Y.name]=o*G.width),o+=2*Y.pixelType;return G.bytesPerLine=G.width*o,G.outLineWidth=G.width*G.outputChannels,"INCREASING_Y"===Z.lineOrder?G.scanOrder=Z=>Z:G.scanOrder=Z=>G.height-1-Z,4==G.outputChannels?(G.format=5,G.linearSpace=!0):(G.format=6,G.linearSpace=!1),G}function tZ(Z,x,F,u){const G={value:0};for(let f=0;f<Z.height/Z.scanlineBlockSize;f++){const Y=K(F,u)-x.dataWindow.yMin;Z.size=y(F,u),Z.lines=Y+Z.scanlineBlockSize>Z.height?Z.height-Y:Z.scanlineBlockSize;const j=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):ZZ(Z);u.value+=Z.size;for(let F=0;F<Z.scanlineBlockSize;F++){const u=f*Z.scanlineBlockSize,Y=F+Z.scanOrder(u);if(Y>=Z.height)continue;const d=F*Z.bytesPerLine,t=(Z.height-1-Y)*Z.outLineWidth;for(let F=0;F<Z.channels;F++){const u=x.channels[F].name,f=Z.channelLineOffsets[u],Y=Z.decodeChannels[u];if(void 0!==Y){G.value=d+f;for(let x=0;x<Z.width;x++){const F=t+x*Z.outputChannels+Y;Z.byteArray&&(Z.byteArray[F]=Z.getter(j,G))}}}}}}jZ.DefaultOutputType=fZ.HalfFloat,jZ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class oZ{constructor(){this.supportCascades=!1}loadCubeData(Z,x,F,u,G){throw".exr not supported in Cube."}loadData(Z,x,F){const G=new DataView(Z.buffer),f={value:0},Y=N(G,f);dZ(Y,G,f,jZ.DefaultOutputType).then((Z=>{tZ(Z,Y,G,f);const u=Y.dataWindow.xMax-Y.dataWindow.xMin+1,j=Y.dataWindow.yMax-Y.dataWindow.yMin+1;F(u,j,x.generateMipMaps,!1,(()=>{const F=x.getEngine();x.format=Y.format,x.type=Z.textureType,x.invertY=!1,x._gammaSpace=!Y.linearSpace,Z.byteArray&&F._uploadDataToTextureDirectly(x,Z.byteArray,0,0,void 0,!0)}))})).catch((Z=>{u.d.Error("Failed to load EXR texture: ",Z)}))}}async function cZ(Z){const x=new DataView(Z),F={value:0},G=N(x,F);try{const Z=await dZ(G,x,F,fZ.Float);return tZ(Z,G,x,F),Z.byteArray?{width:G.dataWindow.xMax-G.dataWindow.xMin+1,height:G.dataWindow.yMax-G.dataWindow.yMin+1,data:new Float32Array(Z.byteArray)}:(u.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(f){u.d.Error("Failed to load EXR data: ",f)}return{width:0,height:0,data:null}}},11194:(Z,x,F)=>{function u(Z){return parseInt(Z.toString().replace(/\W/g,""))}function G(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-x)<=F}function f(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<x-u||Z>F+u}function Y(Z,x){return Z===x?Z:Math.random()*(x-Z)+Z}function j(Z,x,F){return Z+(x-Z)*F}function d(Z,x,F){let u=k(x-Z,360);return u>180&&(u-=360),Z+u*s(F)}function t(Z,x,F){let u=0;return u=Z!=x?s((F-Z)/(x-Z)):0,u}function o(Z,x,F,u,G){const f=G*G,Y=G*f;return Z*(2*Y-3*f+1)+F*(-2*Y+3*f)+x*(Y-2*f+G)+u*(Y-f)}function c(Z,x,F,u,G){const f=G*G;return 6*(f-G)*Z+(3*f-4*G+1)*x+6*(-f+G)*F+(3*f-2*G)*u}function s(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(x,Z))}function J(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function p(Z){const x=Z.toString(16);return Z<=15?("0"+x).toUpperCase():x.toUpperCase()}function U(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let x=0;if(Z<1){for(;Z<1;)x++,Z*=2;x=-x}else if(Z>1)for(;Z>1;)x++,Z=Math.floor(Z/2);return x}function k(Z,x){return Z-Math.floor(Z/x)*x}function M(Z,x,F){return(Z-x)/(F-x)}function m(Z,x,F){return Z*(F-x)+x}function C(Z,x){let F=k(x-Z,360);return F>180&&(F-=360),F}function L(Z,x){const F=k(Z,2*x);return x-Math.abs(F-x)}function H(Z,x,F){let u=s(F);return u=-2*u*u*u+3*u*u,x*u+Z*(1-u)}function S(Z,x,F){let u=0;return u=Math.abs(x-Z)<=F?x:Z+Math.sign(x-Z)*F,u}function K(Z,x,F){const u=C(Z,x);let G=0;return G=-F<u&&u<F?x:S(Z,x=Z+u,F),G}function y(Z,x,F){return(Z-x)/(F-x)}function q(Z,x,F){return(F-x)*Z+x}function R(Z,x){const F=Z%x;return 0===F?x:R(x,F)}F.r(x),F.d(x,{Clamp:()=>s,DeltaAngle:()=>C,Denormalize:()=>m,ExtractAsInt:()=>u,Hermite:()=>o,Hermite1stDerivative:()=>c,HighestCommonFactor:()=>R,ILog2:()=>U,InverseLerp:()=>t,Lerp:()=>j,LerpAngle:()=>d,MoveTowards:()=>S,MoveTowardsAngle:()=>K,Normalize:()=>M,NormalizeRadians:()=>J,OutsideRange:()=>f,PercentToRange:()=>q,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>y,Repeat:()=>k,SmoothStep:()=>H,ToHex:()=>p,WithinEpsilon:()=>G})}}]);