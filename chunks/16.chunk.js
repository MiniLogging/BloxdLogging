"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[16],{14633:(t,U,y)=>{y.r(U),y.d(U,{ReadExrDataAsync:()=>Lt,_ExrTextureLoader:()=>Mt});var I=y(12221),r=y(12404);const Y=4,mt=4,X=1,P=2,G=8,M=65536,L=M>>3,h=14,Q=65537,F=1<<h,E=F-1,w=59,D=63,l=2+D-w;var g,B;!function(t){t[t.NO_COMPRESSION=0]="NO_COMPRESSION",t[t.RLE_COMPRESSION=1]="RLE_COMPRESSION",t[t.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",t[t.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",t[t.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",t[t.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(g||(g={})),function(t){t[t.INCREASING_Y=0]="INCREASING_Y",t[t.DECREASING_Y=1]="DECREASING_Y"}(B||(B={}));const b=function(){const t=new ArrayBuffer(4),U=new Float32Array(t),y=new Uint32Array(t),I=new Uint32Array(512),r=new Uint32Array(512);for(let P=0;P<256;++P){const t=P-127;t<-27?(I[P]=0,I[256|P]=32768,r[P]=24,r[256|P]=24):t<-14?(I[P]=1024>>-t-14,I[256|P]=1024>>-t-14|32768,r[P]=-t-1,r[256|P]=-t-1):t<=15?(I[P]=t+15<<10,I[256|P]=t+15<<10|32768,r[P]=13,r[256|P]=13):t<128?(I[P]=31744,I[256|P]=64512,r[P]=24,r[256|P]=24):(I[P]=31744,I[256|P]=64512,r[P]=13,r[256|P]=13)}const Y=new Uint32Array(2048),mt=new Uint32Array(64),X=new Uint32Array(64);for(let P=1;P<1024;++P){let t=P<<13,U=0;for(;0===(8388608&t);)t<<=1,U-=8388608;t&=-8388609,U+=947912704,Y[P]=t|U}for(let P=1024;P<2048;++P)Y[P]=939524096+(P-1024<<13);for(let P=1;P<31;++P)mt[P]=P<<23;mt[31]=1199570944,mt[32]=2147483648;for(let P=33;P<63;++P)mt[P]=2147483648+(P-32<<23);mt[63]=3347054592;for(let P=1;P<64;++P)32!==P&&(X[P]=1024);return{floatView:U,uint32View:y,baseTable:I,shiftTable:r,mantissaTable:Y,exponentTable:mt,offsetTable:X}}();function p(t,U){const y=new Uint8Array(t);let I=0;for(;0!=y[U.value+I];)I+=1;const r=(new TextDecoder).decode(y.slice(U.value,U.value+I));return U.value=U.value+I+1,r}function c(t,U){const y=t.getInt32(U.value,!0);return U.value+=Y,y}function f(t,U){const y=t.getUint32(U.value,!0);return U.value+=Y,y}function S(t,U){const y=t.getUint8(U.value);return U.value+=X,y}function N(t,U){const y=t.getUint16(U.value,!0);return U.value+=P,y}function j(t,U){const y=t[U.value];return U.value+=X,y}function J(t,U){let y;return y="getBigInt64"in DataView.prototype?Number(t.getBigInt64(U.value,!0)):t.getUint32(U.value+4,!0)+Number(t.getUint32(U.value,!0)<<32),U.value+=G,y}function a(t,U){const y=t.getFloat32(U.value,!0);return U.value+=mt,y}function d(t,U){return function(t){const U=(31744&t)>>10,y=1023&t;return(t>>15?-1:1)*(U?31===U?y?NaN:1/0:Math.pow(2,U-15)*(1+y/1024):y/1024*6103515625e-14)}(N(t,U))}function q(t,U){return function(t){if(Math.abs(t)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");t=(0,r.Clamp)(t,-65504,65504),b.floatView[0]=t;const U=b.uint32View[0],y=U>>23&511;return b.baseTable[y]+((8388607&U)>>b.shiftTable[y])}(a(t,U))}function H(t,U,y,I){switch(y){case"string":case"stringvector":case"iccProfile":return function(t,U,y){const I=(new TextDecoder).decode(new Uint8Array(t).slice(U.value,U.value+y));return U.value=U.value+y,I}(t.buffer,U,I);case"chlist":return function(t,U,y){const I=U.value,r=[];for(;U.value<I+y-1;){const y=p(t.buffer,U),I=c(t,U),Y=S(t,U);U.value+=3;const mt=c(t,U),X=c(t,U);r.push({name:y,pixelType:I,pLinear:Y,xSampling:mt,ySampling:X})}return U.value+=1,r}(t,U,I);case"chromaticities":return function(t,U){return{redX:a(t,U),redY:a(t,U),greenX:a(t,U),greenY:a(t,U),blueX:a(t,U),blueY:a(t,U),whiteX:a(t,U),whiteY:a(t,U)}}(t,U);case"compression":return function(t,U){return S(t,U)}(t,U);case"box2i":return function(t,U){return{xMin:c(t,U),yMin:c(t,U),xMax:c(t,U),yMax:c(t,U)}}(t,U);case"lineOrder":return function(t,U){const y=S(t,U);return B[y]}(t,U);case"float":return a(t,U);case"v2f":return function(t,U){return[a(t,U),a(t,U)]}(t,U);case"v3f":return function(t,U){return[a(t,U),a(t,U),a(t,U)]}(t,U);case"int":return c(t,U);case"rational":return function(t,U){return[c(t,U),f(t,U)]}(t,U);case"timecode":return function(t,U){return[f(t,U),f(t,U)]}(t,U);case"preview":return U.value+=I,"skipped";default:return void(U.value+=I)}}function e(t){for(let U=1;U<t.length;U++){const y=t[U-1]+t[U]-128;t[U]=y}}function o(t,U){let y=0,I=Math.floor((t.length+1)/2),r=0;const Y=t.length-1;for(;!(r>Y)&&(U[r++]=t[y++],!(r>Y));)U[r++]=t[I++]}const V=20000630;function n(t,U){if(t.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const y=t.getUint8(4),r=t.getUint8(5),Y={singleTile:!!(2&r),longName:!!(4&r),deepFormat:!!(8&r),multiPart:!!(16&r)};U.value=8;const mt={};let X=!0;for(;X;){const y=p(t.buffer,U);if(y){const r=p(t.buffer,U),Y=H(t,U,r,f(t,U));void 0===Y?I.b.Warn(`Unknown header attribute type ${r}'.`):mt[y]=Y}else X=!1}if(0!=(-5&r))throw new Error("Unsupported file format");return{version:y,spec:Y,...mt}}const i=32768,v=65535;function O(t,U,y,I,r){for(;y<t;)U=U<<8|j(I,r),y+=8;return{l:U>>(y-=t)&(1<<t)-1,c:U,lc:y}}function k(t,U,y,I){return{c:t=t<<8|j(y,I),lc:U+=8}}function s(t,U,y,I,r,Y,mt,X,P){if(t==U){if(I<8){const t=k(y,I,r,Y);y=t.c,I=t.lc}let t=y>>(I-=8);if(t=new Uint8Array([t])[0],X.value+t>P)return null;const U=mt[X.value-1];for(;t-- >0;)mt[X.value++]=U}else{if(!(X.value<P))return null;mt[X.value++]=t}return{c:y,lc:I}}const x=new Array(59);function Z(t,U,y,I,r,Y){const mt=U;let X=0,P=0;for(;I<=r;I++){if(mt.value-U.value>y)return;let G=O(6,X,P,t,mt);const M=G.l;if(X=G.c,P=G.lc,Y[I]=M,M==D){if(mt.value-U.value>y)throw new Error("Error in HufUnpackEncTable");G=O(8,X,P,t,mt);let M=G.l+l;if(X=G.c,P=G.lc,I+M>r+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)Y[I++]=0;I--}else if(M>=w){let t=M-w+2;if(I+t>r+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)Y[I++]=0;I--}}!function(t){for(let y=0;y<=58;++y)x[y]=0;for(let y=0;y<Q;++y)x[t[y]]+=1;let U=0;for(let y=58;y>0;--y){const t=U+x[y]>>1;x[y]=U,U=t}for(let y=0;y<Q;++y){const U=t[y];U>0&&(t[y]=U|x[U]++<<6)}}(Y)}function W(t){return 63&t}function A(t){return t>>6}function K(t,U,y,I,r,Y){const mt=y.value,X=f(U,y),P=f(U,y);y.value+=4;const G=f(U,y);if(y.value+=4,X<0||X>=Q||P<0||P>=Q)throw new Error("Wrong HUF_ENCSIZE");const M=new Array(Q),L=new Array(F);!function(t){for(let U=0;U<F;U++)t[U]={},t[U].len=0,t[U].lit=0,t[U].p=null}(L);if(Z(t,y,I-(y.value-mt),X,P,M),G>8*(I-(y.value-mt)))throw new Error("Wrong hufUncompress");!function(t,U,y,I){for(;U<=y;U++){const y=A(t[U]),r=W(t[U]);if(y>>r)throw new Error("Invalid table entry");if(r>h){const t=I[y>>r-h];if(t.len)throw new Error("Invalid table entry");if(t.lit++,t.p){const U=t.p;t.p=new Array(t.lit);for(let y=0;y<t.lit-1;++y)t.p[y]=U[y]}else t.p=new Array(1);t.p[t.lit-1]=U}else if(r){let t=0;for(let Y=1<<h-r;Y>0;Y--){const Y=I[(y<<h-r)+t];if(Y.len||Y.p)throw new Error("Invalid table entry");Y.len=r,Y.lit=U,t++}}}}(M,X,P,L),function(t,U,y,I,r,Y,mt,X,P){let G=0,M=0;const L=mt,Q=Math.trunc(I.value+(r+7)/8);for(;I.value<Q;){let r=k(G,M,y,I);for(G=r.c,M=r.lc;M>=h;){const mt=U[G>>M-h&E];if(mt.len){M-=mt.len;const t=s(mt.lit,Y,G,M,y,I,X,P,L);t&&(G=t.c,M=t.lc)}else{if(!mt.p)throw new Error("hufDecode issues");let U;for(U=0;U<mt.lit;U++){const h=W(t[mt.p[U]]);for(;M<h&&I.value<Q;)r=k(G,M,y,I),G=r.c,M=r.lc;if(M>=h&&A(t[mt.p[U]])==(G>>M-h&(1<<h)-1)){M-=h;const t=s(mt.p[U],Y,G,M,y,I,X,P,L);t&&(G=t.c,M=t.lc);break}}if(U==mt.lit)throw new Error("HufDecode issues")}}}const F=8-r&7;for(G>>=F,M-=F;M>0;){const t=U[G<<h-M&E];if(!t.len)throw new Error("HufDecode issues");{M-=t.len;const U=s(t.lit,Y,G,M,y,I,X,P,L);U&&(G=U.c,M=U.lc)}}}(M,L,t,y,G,P,Y,r,{value:0})}function C(t){return 65535&t}function R(t){const U=C(t);return U>32767?U-65536:U}function u(t,U){const y=R(t),I=R(U),r=y+(1&I)+(I>>1);return{a:r,b:r-I}}function T(t,U){const y=C(t),I=C(U),r=y-(I>>1)&v;return{a:I+r-i&v,b:r}}function z(t,U,y,I,r,Y,mt){const X=mt<16384,P=y>r?r:y;let G,M,L=1;for(;L<=P;)L<<=1;for(L>>=1,G=L,L>>=1;L>=1;){M=0;const mt=M+Y*(r-G),P=Y*L,h=Y*G,Q=I*L,F=I*G;let E,w,D,l;for(;M<=mt;M+=h){let r=M;const Y=M+I*(y-G);for(;r<=Y;r+=F){const y=r+Q,I=r+P,Y=I+Q;if(X){let mt=u(t[r+U],t[I+U]);E=mt.a,D=mt.b,mt=u(t[y+U],t[Y+U]),w=mt.a,l=mt.b,mt=u(E,w),t[r+U]=mt.a,t[y+U]=mt.b,mt=u(D,l),t[I+U]=mt.a,t[Y+U]=mt.b}else{let mt=T(t[r+U],t[I+U]);E=mt.a,D=mt.b,mt=T(t[y+U],t[Y+U]),w=mt.a,l=mt.b,mt=T(E,w),t[r+U]=mt.a,t[y+U]=mt.b,mt=T(D,l),t[I+U]=mt.a,t[Y+U]=mt.b}}if(y&L){const y=r+P;let I;I=X?u(t[r+U],t[y+U]):T(t[r+U],t[y+U]),E=I.a,t[y+U]=I.b,t[r+U]=E}}if(r&L){let r=M;const Y=M+I*(y-G);for(;r<=Y;r+=F){const y=r+Q;let I;I=X?u(t[r+U],t[y+U]):T(t[r+U],t[y+U]),E=I.a,t[y+U]=I.b,t[r+U]=E}}G=L,L>>=1}return M}function tt(t){return new DataView(t.array.buffer,t.offset.value,t.size)}function Ut(t){const U=t.viewer.buffer.slice(t.offset.value,t.offset.value+t.size),y=new Uint8Array(function(t){let U=t.byteLength;const y=[];let I=0;const r=new DataView(t);for(;U>0;){const t=r.getInt8(I++);if(t<0){const Y=-t;U-=Y+1;for(let t=0;t<Y;t++)y.push(r.getUint8(I++))}else{const Y=t;U-=2;const mt=r.getUint8(I++);for(let t=0;t<Y+1;t++)y.push(mt)}}return y}(U)),I=new Uint8Array(y.length);return e(y),o(y,I),new DataView(I.buffer)}function yt(t){const U=t.array.slice(t.offset.value,t.offset.value+t.size),y=fflate.unzlibSync(U),I=new Uint8Array(y.length);return e(y),o(y,I),new DataView(I.buffer)}function It(t){const U=t.array.slice(t.offset.value,t.offset.value+t.size),y=fflate.unzlibSync(U),I=t.lines*t.channels*t.width,r=1==t.type?new Uint16Array(I):new Uint32Array(I);let Y=0,mt=0;const X=new Array(4);for(let P=0;P<t.lines;P++)for(let U=0;U<t.channels;U++){let U=0;switch(t.type){case 1:X[0]=Y,X[1]=X[0]+t.width,Y=X[1]+t.width;for(let I=0;I<t.width;++I){U+=y[X[0]++]<<8|y[X[1]++],r[mt]=U,mt++}break;case 2:X[0]=Y,X[1]=X[0]+t.width,X[2]=X[1]+t.width,Y=X[2]+t.width;for(let I=0;I<t.width;++I){U+=y[X[0]++]<<24|y[X[1]++]<<16|y[X[2]++]<<8,r[mt]=U,mt++}}}return new DataView(r.buffer)}function rt(t){const U=t.viewer,y={value:t.offset.value},I=new Uint16Array(t.width*t.scanlineBlockSize*(t.channels*t.type)),r=new Uint8Array(L);let Y=0;const mt=new Array(t.channels);for(let P=0;P<t.channels;P++)mt[P]={},mt[P].start=Y,mt[P].end=mt[P].start,mt[P].nx=t.width,mt[P].ny=t.lines,mt[P].size=t.type,Y+=mt[P].nx*mt[P].ny*mt[P].size;const X=N(U,y),G=N(U,y);if(G>=L)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(X<=G)for(let P=0;P<G-X+1;P++)r[P+X]=S(U,y);const h=new Uint16Array(M),Q=function(t,U){let y=0;for(let r=0;r<M;++r)(0==r||t[r>>3]&1<<(7&r))&&(U[y++]=r);const I=y-1;for(;y<M;)U[y++]=0;return I}(r,h),F=f(U,y);K(t.array,U,y,F,I,Y);for(let P=0;P<t.channels;++P){const t=mt[P];for(let U=0;U<mt[P].size;++U)z(I,t.start+U,t.nx,t.size,t.ny,t.nx*t.size,Q)}!function(t,U,y){for(let I=0;I<y;++I)U[I]=t[U[I]]}(h,I,Y);let E=0;const w=new Uint8Array(I.buffer.byteLength);for(let M=0;M<t.lines;M++)for(let U=0;U<t.channels;U++){const t=mt[U],y=t.nx*t.size,r=new Uint8Array(I.buffer,t.end*P,y*P);w.set(r,E),E+=y*P,t.end+=y}return new DataView(w.buffer)}var Yt,mU=y(12198);!function(t){t[t.Float=0]="Float",t[t.HalfFloat=1]="HalfFloat"}(Yt||(Yt={}));class Xt{}async function Pt(t,U,y,I){const r={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:y,width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,channels:t.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(t.compression){case g.NO_COMPRESSION:r.lines=1,r.uncompress=tt;break;case g.RLE_COMPRESSION:r.lines=1,r.uncompress=Ut;break;case g.ZIPS_COMPRESSION:r.lines=1,r.uncompress=yt,await mU.Tools.LoadScriptAsync(Xt.FFLATEUrl);break;case g.ZIP_COMPRESSION:r.lines=16,r.uncompress=yt,await mU.Tools.LoadScriptAsync(Xt.FFLATEUrl);break;case g.PIZ_COMPRESSION:r.lines=32,r.uncompress=rt;break;case g.PXR24_COMPRESSION:r.lines=16,r.uncompress=It,await mU.Tools.LoadScriptAsync(Xt.FFLATEUrl);break;default:throw new Error(g[t.compression]+" is unsupported")}r.scanlineBlockSize=r.lines;const Y={};for(const mt of t.channels)switch(mt.name){case"R":case"G":case"B":case"A":case"Y":Y[mt.name]=!0,r.type=mt.pixelType}let X=!1;if(Y.R&&Y.G&&Y.B&&Y.A)r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(Y.R&&Y.G&&Y.B)X=!0,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(Y.R&&Y.G)r.outputChannels=2,r.decodeChannels={R:0,G:1};else if(Y.R)r.outputChannels=1,r.decodeChannels={R:0};else{if(!Y.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");r.outputChannels=1,r.decodeChannels={Y:0}}if(1===r.type)switch(I){case Yt.Float:r.getter=d,r.inputSize=P;break;case Yt.HalfFloat:r.getter=N,r.inputSize=P}else{if(2!==r.type)throw new Error("Unsupported pixelType "+r.type+" for "+t.compression);switch(I){case Yt.Float:r.getter=a,r.inputSize=mt;break;case Yt.HalfFloat:r.getter=q,r.inputSize=mt}}r.blockCount=r.height/r.scanlineBlockSize;for(let mt=0;mt<r.blockCount;mt++)J(U,y);const G=r.width*r.height*r.outputChannels;switch(I){case Yt.Float:r.byteArray=new Float32Array(G),r.textureType=1,X&&r.byteArray.fill(1,0,G);break;case Yt.HalfFloat:r.byteArray=new Uint16Array(G),r.textureType=2,X&&r.byteArray.fill(15360,0,G);break;default:throw new Error("Unsupported type: "+I)}let M=0;for(const mt of t.channels)void 0!==r.decodeChannels[mt.name]&&(r.channelLineOffsets[mt.name]=M*r.width),M+=2*mt.pixelType;return r.bytesPerLine=r.width*M,r.outLineWidth=r.width*r.outputChannels,"INCREASING_Y"===t.lineOrder?r.scanOrder=t=>t:r.scanOrder=t=>r.height-1-t,4==r.outputChannels?(r.format=5,r.linearSpace=!0):(r.format=6,r.linearSpace=!1),r}function Gt(t,U,y,I){const r={value:0};for(let Y=0;Y<t.height/t.scanlineBlockSize;Y++){const mt=c(y,I)-U.dataWindow.yMin;t.size=f(y,I),t.lines=mt+t.scanlineBlockSize>t.height?t.height-mt:t.scanlineBlockSize;const X=t.size<t.lines*t.bytesPerLine&&t.uncompress?t.uncompress(t):tt(t);I.value+=t.size;for(let y=0;y<t.scanlineBlockSize;y++){const I=Y*t.scanlineBlockSize,mt=y+t.scanOrder(I);if(mt>=t.height)continue;const P=y*t.bytesPerLine,G=(t.height-1-mt)*t.outLineWidth;for(let y=0;y<t.channels;y++){const I=U.channels[y].name,Y=t.channelLineOffsets[I],mt=t.decodeChannels[I];if(void 0!==mt){r.value=P+Y;for(let U=0;U<t.width;U++){const y=G+U*t.outputChannels+mt;t.byteArray&&(t.byteArray[y]=t.getter(X,r))}}}}}}Xt.DefaultOutputType=Yt.HalfFloat,Xt.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Mt{constructor(){this.supportCascades=!1}loadCubeData(t,U,y,I,r){throw".exr not supported in Cube."}loadData(t,U,y){const r=new DataView(t.buffer),Y={value:0},mt=n(r,Y);Pt(mt,r,Y,Xt.DefaultOutputType).then((t=>{Gt(t,mt,r,Y);const I=mt.dataWindow.xMax-mt.dataWindow.xMin+1,X=mt.dataWindow.yMax-mt.dataWindow.yMin+1;y(I,X,U.generateMipMaps,!1,(()=>{const y=U.getEngine();U.format=mt.format,U.type=t.textureType,U.invertY=!1,U._gammaSpace=!mt.linearSpace,t.byteArray&&y._uploadDataToTextureDirectly(U,t.byteArray,0,0,void 0,!0)}))})).catch((t=>{I.b.Error("Failed to load EXR texture: ",t)}))}}async function Lt(t){const U=new DataView(t),y={value:0},r=n(U,y);try{const t=await Pt(r,U,y,Yt.Float);return Gt(t,r,U,y),t.byteArray?{width:r.dataWindow.xMax-r.dataWindow.xMin+1,height:r.dataWindow.yMax-r.dataWindow.yMin+1,data:new Float32Array(t.byteArray)}:(I.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Y){I.b.Error("Failed to load EXR data: ",Y)}return{width:0,height:0,data:null}}},12404:(t,U,y)=>{function I(t){return parseInt(t.toString().replace(/\W/g,""))}function r(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(t-U)<=y}function Y(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return t<U-I||t>y+I}function mt(t,U){return t===U?t:Math.random()*(U-t)+t}function X(t,U,y){return t+(U-t)*y}function P(t,U,y){let I=w(U-t,360);return I>180&&(I-=360),t+I*h(y)}function G(t,U,y){let I=0;return I=t!=U?h((y-t)/(U-t)):0,I}function M(t,U,y,I,r){const Y=r*r,mt=r*Y;return t*(2*mt-3*Y+1)+y*(-2*mt+3*Y)+U*(mt-2*Y+r)+I*(mt-Y)}function L(t,U,y,I,r){const Y=r*r;return 6*(Y-r)*t+(3*Y-4*r+1)*U+6*(-Y+r)*y+(3*Y-2*r)*I}function h(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(y,Math.max(U,t))}function Q(t){return t-=2*Math.PI*Math.floor((t+Math.PI)/(2*Math.PI))}function F(t){const U=t.toString(16);return t<=15?("0"+U).toUpperCase():U.toUpperCase()}function E(t){if(Math.log2)return Math.floor(Math.log2(t));if(t<0)return NaN;if(0===t)return-1/0;let U=0;if(t<1){for(;t<1;)U++,t*=2;U=-U}else if(t>1)for(;t>1;)U++,t=Math.floor(t/2);return U}function w(t,U){return t-Math.floor(t/U)*U}function D(t,U,y){return(t-U)/(y-U)}function l(t,U,y){return t*(y-U)+U}function g(t,U){let y=w(U-t,360);return y>180&&(y-=360),y}function B(t,U){const y=w(t,2*U);return U-Math.abs(y-U)}function b(t,U,y){let I=h(y);return I=-2*I*I*I+3*I*I,U*I+t*(1-I)}function p(t,U,y){let I=0;return I=Math.abs(U-t)<=y?U:t+Math.sign(U-t)*y,I}function c(t,U,y){const I=g(t,U);let r=0;return r=-y<I&&I<y?U:p(t,U=t+I,y),r}function f(t,U,y){return(t-U)/(y-U)}function S(t,U,y){return(y-U)*t+U}function N(t,U){const y=t%U;return 0===y?U:N(U,y)}y.r(U),y.d(U,{Clamp:()=>h,DeltaAngle:()=>g,Denormalize:()=>l,ExtractAsInt:()=>I,Hermite:()=>M,Hermite1stDerivative:()=>L,HighestCommonFactor:()=>N,ILog2:()=>E,InverseLerp:()=>G,Lerp:()=>X,LerpAngle:()=>P,MoveTowards:()=>p,MoveTowardsAngle:()=>c,Normalize:()=>D,NormalizeRadians:()=>Q,OutsideRange:()=>Y,PercentToRange:()=>S,PingPong:()=>B,RandomRange:()=>mt,RangeToPercent:()=>f,Repeat:()=>w,SmoothStep:()=>b,ToHex:()=>F,WithinEpsilon:()=>r})}}]);