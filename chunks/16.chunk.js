"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[16],{14855:(E,U,g)=>{g.r(U),g.d(U,{ReadExrDataAsync:()=>PE,_ExrTextureLoader:()=>BE});var N=g(12186),L=g(12353);const D=4,S=4,u=1,s=2,C=8,B=65536,P=B>>3,F=14,f=65537,d=1<<F,I=d-1,y=59,h=63,V=2+h-y;var e,x;!function(E){E[E.NO_COMPRESSION=0]="NO_COMPRESSION",E[E.RLE_COMPRESSION=1]="RLE_COMPRESSION",E[E.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",E[E.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",E[E.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",E[E.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(e||(e={})),function(E){E[E.INCREASING_Y=0]="INCREASING_Y",E[E.DECREASING_Y=1]="DECREASING_Y"}(x||(x={}));const l=function(){const E=new ArrayBuffer(4),U=new Float32Array(E),g=new Uint32Array(E),N=new Uint32Array(512),L=new Uint32Array(512);for(let s=0;s<256;++s){const E=s-127;E<-27?(N[s]=0,N[256|s]=32768,L[s]=24,L[256|s]=24):E<-14?(N[s]=1024>>-E-14,N[256|s]=1024>>-E-14|32768,L[s]=-E-1,L[256|s]=-E-1):E<=15?(N[s]=E+15<<10,N[256|s]=E+15<<10|32768,L[s]=13,L[256|s]=13):E<128?(N[s]=31744,N[256|s]=64512,L[s]=24,L[256|s]=24):(N[s]=31744,N[256|s]=64512,L[s]=13,L[256|s]=13)}const D=new Uint32Array(2048),S=new Uint32Array(64),u=new Uint32Array(64);for(let s=1;s<1024;++s){let E=s<<13,U=0;for(;0===(8388608&E);)E<<=1,U-=8388608;E&=-8388609,U+=947912704,D[s]=E|U}for(let s=1024;s<2048;++s)D[s]=939524096+(s-1024<<13);for(let s=1;s<31;++s)S[s]=s<<23;S[31]=1199570944,S[32]=2147483648;for(let s=33;s<63;++s)S[s]=2147483648+(s-32<<23);S[63]=3347054592;for(let s=1;s<64;++s)32!==s&&(u[s]=1024);return{floatView:U,uint32View:g,baseTable:N,shiftTable:L,mantissaTable:D,exponentTable:S,offsetTable:u}}();function Y(E,U){const g=new Uint8Array(E);let N=0;for(;0!=g[U.value+N];)N+=1;const L=(new TextDecoder).decode(g.slice(U.value,U.value+N));return U.value=U.value+N+1,L}function t(E,U){const g=E.getInt32(U.value,!0);return U.value+=D,g}function G(E,U){const g=E.getUint32(U.value,!0);return U.value+=D,g}function b(E,U){const g=E.getUint8(U.value);return U.value+=u,g}function T(E,U){const g=E.getUint16(U.value,!0);return U.value+=s,g}function v(E,U){const g=E[U.value];return U.value+=u,g}function o(E,U){let g;return g="getBigInt64"in DataView.prototype?Number(E.getBigInt64(U.value,!0)):E.getUint32(U.value+4,!0)+Number(E.getUint32(U.value,!0)<<32),U.value+=C,g}function c(E,U){const g=E.getFloat32(U.value,!0);return U.value+=S,g}function r(E,U){return function(E){const U=(31744&E)>>10,g=1023&E;return(E>>15?-1:1)*(U?31===U?g?NaN:1/0:Math.pow(2,U-15)*(1+g/1024):g/1024*6103515625e-14)}(T(E,U))}function j(E,U){return function(E){if(Math.abs(E)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");E=(0,L.Clamp)(E,-65504,65504),l.floatView[0]=E;const U=l.uint32View[0],g=U>>23&511;return l.baseTable[g]+((8388607&U)>>l.shiftTable[g])}(c(E,U))}function Z(E,U,g,N){switch(g){case"string":case"stringvector":case"iccProfile":return function(E,U,g){const N=(new TextDecoder).decode(new Uint8Array(E).slice(U.value,U.value+g));return U.value=U.value+g,N}(E.buffer,U,N);case"chlist":return function(E,U,g){const N=U.value,L=[];for(;U.value<N+g-1;){const g=Y(E.buffer,U),N=t(E,U),D=b(E,U);U.value+=3;const S=t(E,U),u=t(E,U);L.push({name:g,pixelType:N,pLinear:D,xSampling:S,ySampling:u})}return U.value+=1,L}(E,U,N);case"chromaticities":return function(E,U){return{redX:c(E,U),redY:c(E,U),greenX:c(E,U),greenY:c(E,U),blueX:c(E,U),blueY:c(E,U),whiteX:c(E,U),whiteY:c(E,U)}}(E,U);case"compression":return function(E,U){return b(E,U)}(E,U);case"box2i":return function(E,U){return{xMin:t(E,U),yMin:t(E,U),xMax:t(E,U),yMax:t(E,U)}}(E,U);case"lineOrder":return function(E,U){const g=b(E,U);return x[g]}(E,U);case"float":return c(E,U);case"v2f":return function(E,U){return[c(E,U),c(E,U)]}(E,U);case"v3f":return function(E,U){return[c(E,U),c(E,U),c(E,U)]}(E,U);case"int":return t(E,U);case"rational":return function(E,U){return[t(E,U),G(E,U)]}(E,U);case"timecode":return function(E,U){return[G(E,U),G(E,U)]}(E,U);case"preview":return U.value+=N,"skipped";default:return void(U.value+=N)}}function A(E){for(let U=1;U<E.length;U++){const g=E[U-1]+E[U]-128;E[U]=g}}function w(E,U){let g=0,N=Math.floor((E.length+1)/2),L=0;const D=E.length-1;for(;!(L>D)&&(U[L++]=E[g++],!(L>D));)U[L++]=E[N++]}const a=20000630;function J(E,U){if(E.getUint32(0,!0)!=a)throw new Error("Incorrect OpenEXR format");const g=E.getUint8(4),L=E.getUint8(5),D={singleTile:!!(2&L),longName:!!(4&L),deepFormat:!!(8&L),multiPart:!!(16&L)};U.value=8;const S={};let u=!0;for(;u;){const g=Y(E.buffer,U);if(g){const L=Y(E.buffer,U),D=Z(E,U,L,G(E,U));void 0===D?N.d.Warn(`Unknown header attribute type ${L}'.`):S[g]=D}else u=!1}if(0!=(-5&L))throw new Error("Unsupported file format");return{version:g,spec:D,...S}}const q=32768,M=65535;function mE(E,U,g,N,L){for(;g<E;)U=U<<8|v(N,L),g+=8;return{l:U>>(g-=E)&(1<<E)-1,c:U,lc:g}}function W(E,U,g,N){return{c:E=E<<8|v(g,N),lc:U+=8}}function O(E,U,g,N,L,D,S,u,s){if(E==U){if(N<8){const E=W(g,N,L,D);g=E.c,N=E.lc}let E=g>>(N-=8);if(E=new Uint8Array([E])[0],u.value+E>s)return null;const U=S[u.value-1];for(;E-- >0;)S[u.value++]=U}else{if(!(u.value<s))return null;S[u.value++]=E}return{c:g,lc:N}}const Q=new Array(59);function R(E,U,g,N,L,D){const S=U;let u=0,s=0;for(;N<=L;N++){if(S.value-U.value>g)return;let C=mE(6,u,s,E,S);const B=C.l;if(u=C.c,s=C.lc,D[N]=B,B==h){if(S.value-U.value>g)throw new Error("Error in HufUnpackEncTable");C=mE(8,u,s,E,S);let B=C.l+V;if(u=C.c,s=C.lc,N+B>L+1)throw new Error("Error in HufUnpackEncTable");for(;B--;)D[N++]=0;N--}else if(B>=y){let E=B-y+2;if(N+E>L+1)throw new Error("Error in HufUnpackEncTable");for(;E--;)D[N++]=0;N--}}!function(E){for(let g=0;g<=58;++g)Q[g]=0;for(let g=0;g<f;++g)Q[E[g]]+=1;let U=0;for(let g=58;g>0;--g){const E=U+Q[g]>>1;Q[g]=U,U=E}for(let g=0;g<f;++g){const U=E[g];U>0&&(E[g]=U|Q[U]++<<6)}}(D)}function n(E){return 63&E}function k(E){return E>>6}function z(E,U,g,N,L,D){const S=g.value,u=G(U,g),s=G(U,g);g.value+=4;const C=G(U,g);if(g.value+=4,u<0||u>=f||s<0||s>=f)throw new Error("Wrong HUF_ENCSIZE");const B=new Array(f),P=new Array(d);!function(E){for(let U=0;U<d;U++)E[U]={},E[U].len=0,E[U].lit=0,E[U].p=null}(P);if(R(E,g,N-(g.value-S),u,s,B),C>8*(N-(g.value-S)))throw new Error("Wrong hufUncompress");!function(E,U,g,N){for(;U<=g;U++){const g=k(E[U]),L=n(E[U]);if(g>>L)throw new Error("Invalid table entry");if(L>F){const E=N[g>>L-F];if(E.len)throw new Error("Invalid table entry");if(E.lit++,E.p){const U=E.p;E.p=new Array(E.lit);for(let g=0;g<E.lit-1;++g)E.p[g]=U[g]}else E.p=new Array(1);E.p[E.lit-1]=U}else if(L){let E=0;for(let D=1<<F-L;D>0;D--){const D=N[(g<<F-L)+E];if(D.len||D.p)throw new Error("Invalid table entry");D.len=L,D.lit=U,E++}}}}(B,u,s,P),function(E,U,g,N,L,D,S,u,s){let C=0,B=0;const P=S,f=Math.trunc(N.value+(L+7)/8);for(;N.value<f;){let L=W(C,B,g,N);for(C=L.c,B=L.lc;B>=F;){const S=U[C>>B-F&I];if(S.len){B-=S.len;const E=O(S.lit,D,C,B,g,N,u,s,P);E&&(C=E.c,B=E.lc)}else{if(!S.p)throw new Error("hufDecode issues");let U;for(U=0;U<S.lit;U++){const F=n(E[S.p[U]]);for(;B<F&&N.value<f;)L=W(C,B,g,N),C=L.c,B=L.lc;if(B>=F&&k(E[S.p[U]])==(C>>B-F&(1<<F)-1)){B-=F;const E=O(S.p[U],D,C,B,g,N,u,s,P);E&&(C=E.c,B=E.lc);break}}if(U==S.lit)throw new Error("HufDecode issues")}}}const d=8-L&7;for(C>>=d,B-=d;B>0;){const E=U[C<<F-B&I];if(!E.len)throw new Error("HufDecode issues");{B-=E.len;const U=O(E.lit,D,C,B,g,N,u,s,P);U&&(C=U.c,B=U.lc)}}}(B,P,E,g,C,s,D,L,{value:0})}function i(E){return 65535&E}function p(E){const U=i(E);return U>32767?U-65536:U}function H(E,U){const g=p(E),N=p(U),L=g+(1&N)+(N>>1);return{a:L,b:L-N}}function K(E,U){const g=i(E),N=i(U),L=g-(N>>1)&M;return{a:N+L-q&M,b:L}}function X(E,U,g,N,L,D,S){const u=S<16384,s=g>L?L:g;let C,B,P=1;for(;P<=s;)P<<=1;for(P>>=1,C=P,P>>=1;P>=1;){B=0;const S=B+D*(L-C),s=D*P,F=D*C,f=N*P,d=N*C;let I,y,h,V;for(;B<=S;B+=F){let L=B;const D=B+N*(g-C);for(;L<=D;L+=d){const g=L+f,N=L+s,D=N+f;if(u){let S=H(E[L+U],E[N+U]);I=S.a,h=S.b,S=H(E[g+U],E[D+U]),y=S.a,V=S.b,S=H(I,y),E[L+U]=S.a,E[g+U]=S.b,S=H(h,V),E[N+U]=S.a,E[D+U]=S.b}else{let S=K(E[L+U],E[N+U]);I=S.a,h=S.b,S=K(E[g+U],E[D+U]),y=S.a,V=S.b,S=K(I,y),E[L+U]=S.a,E[g+U]=S.b,S=K(h,V),E[N+U]=S.a,E[D+U]=S.b}}if(g&P){const g=L+s;let N;N=u?H(E[L+U],E[g+U]):K(E[L+U],E[g+U]),I=N.a,E[g+U]=N.b,E[L+U]=I}}if(L&P){let L=B;const D=B+N*(g-C);for(;L<=D;L+=d){const g=L+f;let N;N=u?H(E[L+U],E[g+U]):K(E[L+U],E[g+U]),I=N.a,E[g+U]=N.b,E[L+U]=I}}C=P,P>>=1}return B}function EE(E){return new DataView(E.array.buffer,E.offset.value,E.size)}function UE(E){const U=E.viewer.buffer.slice(E.offset.value,E.offset.value+E.size),g=new Uint8Array(function(E){let U=E.byteLength;const g=[];let N=0;const L=new DataView(E);for(;U>0;){const E=L.getInt8(N++);if(E<0){const D=-E;U-=D+1;for(let E=0;E<D;E++)g.push(L.getUint8(N++))}else{const D=E;U-=2;const S=L.getUint8(N++);for(let E=0;E<D+1;E++)g.push(S)}}return g}(U)),N=new Uint8Array(g.length);return A(g),w(g,N),new DataView(N.buffer)}function gE(E){const U=E.array.slice(E.offset.value,E.offset.value+E.size),g=fflate.unzlibSync(U),N=new Uint8Array(g.length);return A(g),w(g,N),new DataView(N.buffer)}function NE(E){const U=E.array.slice(E.offset.value,E.offset.value+E.size),g=fflate.unzlibSync(U),N=E.lines*E.channels*E.width,L=1==E.type?new Uint16Array(N):new Uint32Array(N);let D=0,S=0;const u=new Array(4);for(let s=0;s<E.lines;s++)for(let U=0;U<E.channels;U++){let U=0;switch(E.type){case 1:u[0]=D,u[1]=u[0]+E.width,D=u[1]+E.width;for(let N=0;N<E.width;++N){U+=g[u[0]++]<<8|g[u[1]++],L[S]=U,S++}break;case 2:u[0]=D,u[1]=u[0]+E.width,u[2]=u[1]+E.width,D=u[2]+E.width;for(let N=0;N<E.width;++N){U+=g[u[0]++]<<24|g[u[1]++]<<16|g[u[2]++]<<8,L[S]=U,S++}}}return new DataView(L.buffer)}function LE(E){const U=E.viewer,g={value:E.offset.value},N=new Uint16Array(E.width*E.scanlineBlockSize*(E.channels*E.type)),L=new Uint8Array(P);let D=0;const S=new Array(E.channels);for(let s=0;s<E.channels;s++)S[s]={},S[s].start=D,S[s].end=S[s].start,S[s].nx=E.width,S[s].ny=E.lines,S[s].size=E.type,D+=S[s].nx*S[s].ny*S[s].size;const u=T(U,g),C=T(U,g);if(C>=P)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(u<=C)for(let s=0;s<C-u+1;s++)L[s+u]=b(U,g);const F=new Uint16Array(B),f=function(E,U){let g=0;for(let L=0;L<B;++L)(0==L||E[L>>3]&1<<(7&L))&&(U[g++]=L);const N=g-1;for(;g<B;)U[g++]=0;return N}(L,F),d=G(U,g);z(E.array,U,g,d,N,D);for(let s=0;s<E.channels;++s){const E=S[s];for(let U=0;U<S[s].size;++U)X(N,E.start+U,E.nx,E.size,E.ny,E.nx*E.size,f)}!function(E,U,g){for(let N=0;N<g;++N)U[N]=E[U[N]]}(F,N,D);let I=0;const y=new Uint8Array(N.buffer.byteLength);for(let B=0;B<E.lines;B++)for(let U=0;U<E.channels;U++){const E=S[U],g=E.nx*E.size,L=new Uint8Array(N.buffer,E.end*s,g*s);y.set(L,I),I+=g*s,E.end+=g}return new DataView(y.buffer)}var DE,SE=g(12165);!function(E){E[E.Float=0]="Float",E[E.HalfFloat=1]="HalfFloat"}(DE||(DE={}));class uE{}async function sE(E,U,g,N){const L={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:g,width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,channels:E.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(E.compression){case e.NO_COMPRESSION:L.lines=1,L.uncompress=EE;break;case e.RLE_COMPRESSION:L.lines=1,L.uncompress=UE;break;case e.ZIPS_COMPRESSION:L.lines=1,L.uncompress=gE,await SE.Tools.LoadScriptAsync(uE.FFLATEUrl);break;case e.ZIP_COMPRESSION:L.lines=16,L.uncompress=gE,await SE.Tools.LoadScriptAsync(uE.FFLATEUrl);break;case e.PIZ_COMPRESSION:L.lines=32,L.uncompress=LE;break;case e.PXR24_COMPRESSION:L.lines=16,L.uncompress=NE,await SE.Tools.LoadScriptAsync(uE.FFLATEUrl);break;default:throw new Error(e[E.compression]+" is unsupported")}L.scanlineBlockSize=L.lines;const D={};for(const S of E.channels)switch(S.name){case"R":case"G":case"B":case"A":case"Y":D[S.name]=!0,L.type=S.pixelType}let u=!1;if(D.R&&D.G&&D.B&&D.A)L.outputChannels=4,L.decodeChannels={R:0,G:1,B:2,A:3};else if(D.R&&D.G&&D.B)u=!0,L.outputChannels=4,L.decodeChannels={R:0,G:1,B:2,A:3};else if(D.R&&D.G)L.outputChannels=2,L.decodeChannels={R:0,G:1};else if(D.R)L.outputChannels=1,L.decodeChannels={R:0};else{if(!D.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");L.outputChannels=1,L.decodeChannels={Y:0}}if(1===L.type)switch(N){case DE.Float:L.getter=r,L.inputSize=s;break;case DE.HalfFloat:L.getter=T,L.inputSize=s}else{if(2!==L.type)throw new Error("Unsupported pixelType "+L.type+" for "+E.compression);switch(N){case DE.Float:L.getter=c,L.inputSize=S;break;case DE.HalfFloat:L.getter=j,L.inputSize=S}}L.blockCount=L.height/L.scanlineBlockSize;for(let S=0;S<L.blockCount;S++)o(U,g);const C=L.width*L.height*L.outputChannels;switch(N){case DE.Float:L.byteArray=new Float32Array(C),L.textureType=1,u&&L.byteArray.fill(1,0,C);break;case DE.HalfFloat:L.byteArray=new Uint16Array(C),L.textureType=2,u&&L.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+N)}let B=0;for(const S of E.channels)void 0!==L.decodeChannels[S.name]&&(L.channelLineOffsets[S.name]=B*L.width),B+=2*S.pixelType;return L.bytesPerLine=L.width*B,L.outLineWidth=L.width*L.outputChannels,"INCREASING_Y"===E.lineOrder?L.scanOrder=E=>E:L.scanOrder=E=>L.height-1-E,4==L.outputChannels?(L.format=5,L.linearSpace=!0):(L.format=6,L.linearSpace=!1),L}function CE(E,U,g,N){const L={value:0};for(let D=0;D<E.height/E.scanlineBlockSize;D++){const S=t(g,N)-U.dataWindow.yMin;E.size=G(g,N),E.lines=S+E.scanlineBlockSize>E.height?E.height-S:E.scanlineBlockSize;const u=E.size<E.lines*E.bytesPerLine&&E.uncompress?E.uncompress(E):EE(E);N.value+=E.size;for(let g=0;g<E.scanlineBlockSize;g++){const N=D*E.scanlineBlockSize,S=g+E.scanOrder(N);if(S>=E.height)continue;const s=g*E.bytesPerLine,C=(E.height-1-S)*E.outLineWidth;for(let g=0;g<E.channels;g++){const N=U.channels[g].name,D=E.channelLineOffsets[N],S=E.decodeChannels[N];if(void 0!==S){L.value=s+D;for(let U=0;U<E.width;U++){const g=C+U*E.outputChannels+S;E.byteArray&&(E.byteArray[g]=E.getter(u,L))}}}}}}uE.DefaultOutputType=DE.HalfFloat,uE.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class BE{constructor(){this.supportCascades=!1}loadCubeData(E,U,g,N,L){throw".exr not supported in Cube."}loadData(E,U,g){const L=new DataView(E.buffer),D={value:0},S=J(L,D);sE(S,L,D,uE.DefaultOutputType).then((E=>{CE(E,S,L,D);const N=S.dataWindow.xMax-S.dataWindow.xMin+1,u=S.dataWindow.yMax-S.dataWindow.yMin+1;g(N,u,U.generateMipMaps,!1,(()=>{const g=U.getEngine();U.format=S.format,U.type=E.textureType,U.invertY=!1,U._gammaSpace=!S.linearSpace,E.byteArray&&g._uploadDataToTextureDirectly(U,E.byteArray,0,0,void 0,!0)}))})).catch((E=>{N.d.Error("Failed to load EXR texture: ",E)}))}}async function PE(E){const U=new DataView(E),g={value:0},L=J(U,g);try{const E=await sE(L,U,g,DE.Float);return CE(E,L,U,g),E.byteArray?{width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,data:new Float32Array(E.byteArray)}:(N.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(D){N.d.Error("Failed to load EXR data: ",D)}return{width:0,height:0,data:null}}},12353:(E,U,g)=>{function N(E){return parseInt(E.toString().replace(/\W/g,""))}function L(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(E-U)<=g}function D(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return E<U-N||E>g+N}function S(E,U){return E===U?E:Math.random()*(U-E)+E}function u(E,U,g){return E+(U-E)*g}function s(E,U,g){let N=y(U-E,360);return N>180&&(N-=360),E+N*F(g)}function C(E,U,g){let N=0;return N=E!=U?F((g-E)/(U-E)):0,N}function B(E,U,g,N,L){const D=L*L,S=L*D;return E*(2*S-3*D+1)+g*(-2*S+3*D)+U*(S-2*D+L)+N*(S-D)}function P(E,U,g,N,L){const D=L*L;return 6*(D-L)*E+(3*D-4*L+1)*U+6*(-D+L)*g+(3*D-2*L)*N}function F(E){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(g,Math.max(U,E))}function f(E){return E-=2*Math.PI*Math.floor((E+Math.PI)/(2*Math.PI))}function d(E){const U=E.toString(16);return E<=15?("0"+U).toUpperCase():U.toUpperCase()}function I(E){if(Math.log2)return Math.floor(Math.log2(E));if(E<0)return NaN;if(0===E)return-1/0;let U=0;if(E<1){for(;E<1;)U++,E*=2;U=-U}else if(E>1)for(;E>1;)U++,E=Math.floor(E/2);return U}function y(E,U){return E-Math.floor(E/U)*U}function h(E,U,g){return(E-U)/(g-U)}function V(E,U,g){return E*(g-U)+U}function e(E,U){let g=y(U-E,360);return g>180&&(g-=360),g}function x(E,U){const g=y(E,2*U);return U-Math.abs(g-U)}function l(E,U,g){let N=F(g);return N=-2*N*N*N+3*N*N,U*N+E*(1-N)}function Y(E,U,g){let N=0;return N=Math.abs(U-E)<=g?U:E+Math.sign(U-E)*g,N}function t(E,U,g){const N=e(E,U);let L=0;return L=-g<N&&N<g?U:Y(E,U=E+N,g),L}function G(E,U,g){return(E-U)/(g-U)}function b(E,U,g){return(g-U)*E+U}function T(E,U){const g=E%U;return 0===g?U:T(U,g)}g.r(U),g.d(U,{Clamp:()=>F,DeltaAngle:()=>e,Denormalize:()=>V,ExtractAsInt:()=>N,Hermite:()=>B,Hermite1stDerivative:()=>P,HighestCommonFactor:()=>T,ILog2:()=>I,InverseLerp:()=>C,Lerp:()=>u,LerpAngle:()=>s,MoveTowards:()=>Y,MoveTowardsAngle:()=>t,Normalize:()=>h,NormalizeRadians:()=>f,OutsideRange:()=>D,PercentToRange:()=>b,PingPong:()=>x,RandomRange:()=>S,RangeToPercent:()=>G,Repeat:()=>y,SmoothStep:()=>l,ToHex:()=>d,WithinEpsilon:()=>L})}}]);