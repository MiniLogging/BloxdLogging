"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[16],{15091:(r,O,W)=>{W.r(O),W.d(O,{ReadExrDataAsync:()=>vr,_ExrTextureLoader:()=>dr});var q=W(12453),Q=W(12602);const C=4,T=4,h=1,J=2,mr=8,d=65536,v=d>>3,g=14,K=65537,U=1<<g,P=U-1,b=59,e=63,Y=2+e-b;var G,X;!function(r){r[r.NO_COMPRESSION=0]="NO_COMPRESSION",r[r.RLE_COMPRESSION=1]="RLE_COMPRESSION",r[r.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",r[r.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",r[r.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",r[r.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(G||(G={})),function(r){r[r.INCREASING_Y=0]="INCREASING_Y",r[r.DECREASING_Y=1]="DECREASING_Y"}(X||(X={}));const S=function(){const r=new ArrayBuffer(4),O=new Float32Array(r),W=new Uint32Array(r),q=new Uint32Array(512),Q=new Uint32Array(512);for(let J=0;J<256;++J){const r=J-127;r<-27?(q[J]=0,q[256|J]=32768,Q[J]=24,Q[256|J]=24):r<-14?(q[J]=1024>>-r-14,q[256|J]=1024>>-r-14|32768,Q[J]=-r-1,Q[256|J]=-r-1):r<=15?(q[J]=r+15<<10,q[256|J]=r+15<<10|32768,Q[J]=13,Q[256|J]=13):r<128?(q[J]=31744,q[256|J]=64512,Q[J]=24,Q[256|J]=24):(q[J]=31744,q[256|J]=64512,Q[J]=13,Q[256|J]=13)}const C=new Uint32Array(2048),T=new Uint32Array(64),h=new Uint32Array(64);for(let J=1;J<1024;++J){let r=J<<13,O=0;for(;0===(8388608&r);)r<<=1,O-=8388608;r&=-8388609,O+=947912704,C[J]=r|O}for(let J=1024;J<2048;++J)C[J]=939524096+(J-1024<<13);for(let J=1;J<31;++J)T[J]=J<<23;T[31]=1199570944,T[32]=2147483648;for(let J=33;J<63;++J)T[J]=2147483648+(J-32<<23);T[63]=3347054592;for(let J=1;J<64;++J)32!==J&&(h[J]=1024);return{floatView:O,uint32View:W,baseTable:q,shiftTable:Q,mantissaTable:C,exponentTable:T,offsetTable:h}}();function o(r,O){const W=new Uint8Array(r);let q=0;for(;0!=W[O.value+q];)q+=1;const Q=(new TextDecoder).decode(W.slice(O.value,O.value+q));return O.value=O.value+q+1,Q}function N(r,O){const W=r.getInt32(O.value,!0);return O.value+=C,W}function D(r,O){const W=r.getUint32(O.value,!0);return O.value+=C,W}function p(r,O){const W=r.getUint8(O.value);return O.value+=h,W}function z(r,O){const W=r.getUint16(O.value,!0);return O.value+=J,W}function L(r,O){const W=r[O.value];return O.value+=h,W}function M(r,O){let W;return W="getBigInt64"in DataView.prototype?Number(r.getBigInt64(O.value,!0)):r.getUint32(O.value+4,!0)+Number(r.getUint32(O.value,!0)<<32),O.value+=mr,W}function k(r,O){const W=r.getFloat32(O.value,!0);return O.value+=T,W}function s(r,O){return function(r){const O=(31744&r)>>10,W=1023&r;return(r>>15?-1:1)*(O?31===O?W?NaN:1/0:Math.pow(2,O-15)*(1+W/1024):W/1024*6103515625e-14)}(z(r,O))}function B(r,O){return function(r){if(Math.abs(r)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");r=(0,Q.Clamp)(r,-65504,65504),S.floatView[0]=r;const O=S.uint32View[0],W=O>>23&511;return S.baseTable[W]+((8388607&O)>>S.shiftTable[W])}(k(r,O))}function Z(r,O,W,q){switch(W){case"string":case"stringvector":case"iccProfile":return function(r,O,W){const q=(new TextDecoder).decode(new Uint8Array(r).slice(O.value,O.value+W));return O.value=O.value+W,q}(r.buffer,O,q);case"chlist":return function(r,O,W){const q=O.value,Q=[];for(;O.value<q+W-1;){const W=o(r.buffer,O),q=N(r,O),C=p(r,O);O.value+=3;const T=N(r,O),h=N(r,O);Q.push({name:W,pixelType:q,pLinear:C,xSampling:T,ySampling:h})}return O.value+=1,Q}(r,O,q);case"chromaticities":return function(r,O){return{redX:k(r,O),redY:k(r,O),greenX:k(r,O),greenY:k(r,O),blueX:k(r,O),blueY:k(r,O),whiteX:k(r,O),whiteY:k(r,O)}}(r,O);case"compression":return function(r,O){return p(r,O)}(r,O);case"box2i":return function(r,O){return{xMin:N(r,O),yMin:N(r,O),xMax:N(r,O),yMax:N(r,O)}}(r,O);case"lineOrder":return function(r,O){const W=p(r,O);return X[W]}(r,O);case"float":return k(r,O);case"v2f":return function(r,O){return[k(r,O),k(r,O)]}(r,O);case"v3f":return function(r,O){return[k(r,O),k(r,O),k(r,O)]}(r,O);case"int":return N(r,O);case"rational":return function(r,O){return[N(r,O),D(r,O)]}(r,O);case"timecode":return function(r,O){return[D(r,O),D(r,O)]}(r,O);case"preview":return O.value+=q,"skipped";default:return void(O.value+=q)}}function E(r){for(let O=1;O<r.length;O++){const W=r[O-1]+r[O]-128;r[O]=W}}function R(r,O){let W=0,q=Math.floor((r.length+1)/2),Q=0;const C=r.length-1;for(;!(Q>C)&&(O[Q++]=r[W++],!(Q>C));)O[Q++]=r[q++]}const V=20000630;function a(r,O){if(r.getUint32(0,!0)!=V)throw new Error("Incorrect OpenEXR format");const W=r.getUint8(4),Q=r.getUint8(5),C={singleTile:!!(2&Q),longName:!!(4&Q),deepFormat:!!(8&Q),multiPart:!!(16&Q)};O.value=8;const T={};let h=!0;for(;h;){const W=o(r.buffer,O);if(W){const Q=o(r.buffer,O),C=Z(r,O,Q,D(r,O));void 0===C?q.b.Warn(`Unknown header attribute type ${Q}'.`):T[W]=C}else h=!1}if(0!=(-5&Q))throw new Error("Unsupported file format");return{version:W,spec:C,...T}}const t=32768,i=65535;function l(r,O,W,q,Q){for(;W<r;)O=O<<8|L(q,Q),W+=8;return{l:O>>(W-=r)&(1<<r)-1,c:O,lc:W}}function y(r,O,W,q){return{c:r=r<<8|L(W,q),lc:O+=8}}function w(r,O,W,q,Q,C,T,h,J){if(r==O){if(q<8){const r=y(W,q,Q,C);W=r.c,q=r.lc}let r=W>>(q-=8);if(r=new Uint8Array([r])[0],h.value+r>J)return null;const O=T[h.value-1];for(;r-- >0;)T[h.value++]=O}else{if(!(h.value<J))return null;T[h.value++]=r}return{c:W,lc:q}}const u=new Array(59);function n(r,O,W,q,Q,C){const T=O;let h=0,J=0;for(;q<=Q;q++){if(T.value-O.value>W)return;let mr=l(6,h,J,r,T);const d=mr.l;if(h=mr.c,J=mr.lc,C[q]=d,d==e){if(T.value-O.value>W)throw new Error("Error in HufUnpackEncTable");mr=l(8,h,J,r,T);let d=mr.l+Y;if(h=mr.c,J=mr.lc,q+d>Q+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)C[q++]=0;q--}else if(d>=b){let r=d-b+2;if(q+r>Q+1)throw new Error("Error in HufUnpackEncTable");for(;r--;)C[q++]=0;q--}}!function(r){for(let W=0;W<=58;++W)u[W]=0;for(let W=0;W<K;++W)u[r[W]]+=1;let O=0;for(let W=58;W>0;--W){const r=O+u[W]>>1;u[W]=O,O=r}for(let W=0;W<K;++W){const O=r[W];O>0&&(r[W]=O|u[O]++<<6)}}(C)}function f(r){return 63&r}function F(r){return r>>6}function j(r,O,W,q,Q,C){const T=W.value,h=D(O,W),J=D(O,W);W.value+=4;const mr=D(O,W);if(W.value+=4,h<0||h>=K||J<0||J>=K)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(K),v=new Array(U);!function(r){for(let O=0;O<U;O++)r[O]={},r[O].len=0,r[O].lit=0,r[O].p=null}(v);if(n(r,W,q-(W.value-T),h,J,d),mr>8*(q-(W.value-T)))throw new Error("Wrong hufUncompress");!function(r,O,W,q){for(;O<=W;O++){const W=F(r[O]),Q=f(r[O]);if(W>>Q)throw new Error("Invalid table entry");if(Q>g){const r=q[W>>Q-g];if(r.len)throw new Error("Invalid table entry");if(r.lit++,r.p){const O=r.p;r.p=new Array(r.lit);for(let W=0;W<r.lit-1;++W)r.p[W]=O[W]}else r.p=new Array(1);r.p[r.lit-1]=O}else if(Q){let r=0;for(let C=1<<g-Q;C>0;C--){const C=q[(W<<g-Q)+r];if(C.len||C.p)throw new Error("Invalid table entry");C.len=Q,C.lit=O,r++}}}}(d,h,J,v),function(r,O,W,q,Q,C,T,h,J){let mr=0,d=0;const v=T,K=Math.trunc(q.value+(Q+7)/8);for(;q.value<K;){let Q=y(mr,d,W,q);for(mr=Q.c,d=Q.lc;d>=g;){const T=O[mr>>d-g&P];if(T.len){d-=T.len;const r=w(T.lit,C,mr,d,W,q,h,J,v);r&&(mr=r.c,d=r.lc)}else{if(!T.p)throw new Error("hufDecode issues");let O;for(O=0;O<T.lit;O++){const g=f(r[T.p[O]]);for(;d<g&&q.value<K;)Q=y(mr,d,W,q),mr=Q.c,d=Q.lc;if(d>=g&&F(r[T.p[O]])==(mr>>d-g&(1<<g)-1)){d-=g;const r=w(T.p[O],C,mr,d,W,q,h,J,v);r&&(mr=r.c,d=r.lc);break}}if(O==T.lit)throw new Error("HufDecode issues")}}}const U=8-Q&7;for(mr>>=U,d-=U;d>0;){const r=O[mr<<g-d&P];if(!r.len)throw new Error("HufDecode issues");{d-=r.len;const O=w(r.lit,C,mr,d,W,q,h,J,v);O&&(mr=O.c,d=O.lc)}}}(d,v,r,W,mr,J,C,Q,{value:0})}function H(r){return 65535&r}function A(r){const O=H(r);return O>32767?O-65536:O}function x(r,O){const W=A(r),q=A(O),Q=W+(1&q)+(q>>1);return{a:Q,b:Q-q}}function I(r,O){const W=H(r),q=H(O),Q=W-(q>>1)&i;return{a:q+Q-t&i,b:Q}}function c(r,O,W,q,Q,C,T){const h=T<16384,J=W>Q?Q:W;let mr,d,v=1;for(;v<=J;)v<<=1;for(v>>=1,mr=v,v>>=1;v>=1;){d=0;const T=d+C*(Q-mr),J=C*v,g=C*mr,K=q*v,U=q*mr;let P,b,e,Y;for(;d<=T;d+=g){let Q=d;const C=d+q*(W-mr);for(;Q<=C;Q+=U){const W=Q+K,q=Q+J,C=q+K;if(h){let T=x(r[Q+O],r[q+O]);P=T.a,e=T.b,T=x(r[W+O],r[C+O]),b=T.a,Y=T.b,T=x(P,b),r[Q+O]=T.a,r[W+O]=T.b,T=x(e,Y),r[q+O]=T.a,r[C+O]=T.b}else{let T=I(r[Q+O],r[q+O]);P=T.a,e=T.b,T=I(r[W+O],r[C+O]),b=T.a,Y=T.b,T=I(P,b),r[Q+O]=T.a,r[W+O]=T.b,T=I(e,Y),r[q+O]=T.a,r[C+O]=T.b}}if(W&v){const W=Q+J;let q;q=h?x(r[Q+O],r[W+O]):I(r[Q+O],r[W+O]),P=q.a,r[W+O]=q.b,r[Q+O]=P}}if(Q&v){let Q=d;const C=d+q*(W-mr);for(;Q<=C;Q+=U){const W=Q+K;let q;q=h?x(r[Q+O],r[W+O]):I(r[Q+O],r[W+O]),P=q.a,r[W+O]=q.b,r[Q+O]=P}}mr=v,v>>=1}return d}function rr(r){return new DataView(r.array.buffer,r.offset.value,r.size)}function Or(r){const O=r.viewer.buffer.slice(r.offset.value,r.offset.value+r.size),W=new Uint8Array(function(r){let O=r.byteLength;const W=[];let q=0;const Q=new DataView(r);for(;O>0;){const r=Q.getInt8(q++);if(r<0){const C=-r;O-=C+1;for(let r=0;r<C;r++)W.push(Q.getUint8(q++))}else{const C=r;O-=2;const T=Q.getUint8(q++);for(let r=0;r<C+1;r++)W.push(T)}}return W}(O)),q=new Uint8Array(W.length);return E(W),R(W,q),new DataView(q.buffer)}function Wr(r){const O=r.array.slice(r.offset.value,r.offset.value+r.size),W=fflate.unzlibSync(O),q=new Uint8Array(W.length);return E(W),R(W,q),new DataView(q.buffer)}function qr(r){const O=r.array.slice(r.offset.value,r.offset.value+r.size),W=fflate.unzlibSync(O),q=r.lines*r.channels*r.width,Q=1==r.type?new Uint16Array(q):new Uint32Array(q);let C=0,T=0;const h=new Array(4);for(let J=0;J<r.lines;J++)for(let O=0;O<r.channels;O++){let O=0;switch(r.type){case 1:h[0]=C,h[1]=h[0]+r.width,C=h[1]+r.width;for(let q=0;q<r.width;++q){O+=W[h[0]++]<<8|W[h[1]++],Q[T]=O,T++}break;case 2:h[0]=C,h[1]=h[0]+r.width,h[2]=h[1]+r.width,C=h[2]+r.width;for(let q=0;q<r.width;++q){O+=W[h[0]++]<<24|W[h[1]++]<<16|W[h[2]++]<<8,Q[T]=O,T++}}}return new DataView(Q.buffer)}function Qr(r){const O=r.viewer,W={value:r.offset.value},q=new Uint16Array(r.width*r.scanlineBlockSize*(r.channels*r.type)),Q=new Uint8Array(v);let C=0;const T=new Array(r.channels);for(let J=0;J<r.channels;J++)T[J]={},T[J].start=C,T[J].end=T[J].start,T[J].nx=r.width,T[J].ny=r.lines,T[J].size=r.type,C+=T[J].nx*T[J].ny*T[J].size;const h=z(O,W),mr=z(O,W);if(mr>=v)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(h<=mr)for(let J=0;J<mr-h+1;J++)Q[J+h]=p(O,W);const g=new Uint16Array(d),K=function(r,O){let W=0;for(let Q=0;Q<d;++Q)(0==Q||r[Q>>3]&1<<(7&Q))&&(O[W++]=Q);const q=W-1;for(;W<d;)O[W++]=0;return q}(Q,g),U=D(O,W);j(r.array,O,W,U,q,C);for(let J=0;J<r.channels;++J){const r=T[J];for(let O=0;O<T[J].size;++O)c(q,r.start+O,r.nx,r.size,r.ny,r.nx*r.size,K)}!function(r,O,W){for(let q=0;q<W;++q)O[q]=r[O[q]]}(g,q,C);let P=0;const b=new Uint8Array(q.buffer.byteLength);for(let d=0;d<r.lines;d++)for(let O=0;O<r.channels;O++){const r=T[O],W=r.nx*r.size,Q=new Uint8Array(q.buffer,r.end*J,W*J);b.set(Q,P),P+=W*J,r.end+=W}return new DataView(b.buffer)}var Cr,Tr=W(12428);!function(r){r[r.Float=0]="Float",r[r.HalfFloat=1]="HalfFloat"}(Cr||(Cr={}));class hr{}async function Jr(r,O,W,q){const Q={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:W,width:r.dataWindow.xMax-r.dataWindow.xMin+1,height:r.dataWindow.yMax-r.dataWindow.yMin+1,channels:r.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(r.compression){case G.NO_COMPRESSION:Q.lines=1,Q.uncompress=rr;break;case G.RLE_COMPRESSION:Q.lines=1,Q.uncompress=Or;break;case G.ZIPS_COMPRESSION:Q.lines=1,Q.uncompress=Wr,await Tr.Tools.LoadScriptAsync(hr.FFLATEUrl);break;case G.ZIP_COMPRESSION:Q.lines=16,Q.uncompress=Wr,await Tr.Tools.LoadScriptAsync(hr.FFLATEUrl);break;case G.PIZ_COMPRESSION:Q.lines=32,Q.uncompress=Qr;break;case G.PXR24_COMPRESSION:Q.lines=16,Q.uncompress=qr,await Tr.Tools.LoadScriptAsync(hr.FFLATEUrl);break;default:throw new Error(G[r.compression]+" is unsupported")}Q.scanlineBlockSize=Q.lines;const C={};for(const T of r.channels)switch(T.name){case"R":case"G":case"B":case"A":case"Y":C[T.name]=!0,Q.type=T.pixelType}let h=!1;if(C.R&&C.G&&C.B&&C.A)Q.outputChannels=4,Q.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G&&C.B)h=!0,Q.outputChannels=4,Q.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G)Q.outputChannels=2,Q.decodeChannels={R:0,G:1};else if(C.R)Q.outputChannels=1,Q.decodeChannels={R:0};else{if(!C.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Q.outputChannels=1,Q.decodeChannels={Y:0}}if(1===Q.type)switch(q){case Cr.Float:Q.getter=s,Q.inputSize=J;break;case Cr.HalfFloat:Q.getter=z,Q.inputSize=J}else{if(2!==Q.type)throw new Error("Unsupported pixelType "+Q.type+" for "+r.compression);switch(q){case Cr.Float:Q.getter=k,Q.inputSize=T;break;case Cr.HalfFloat:Q.getter=B,Q.inputSize=T}}Q.blockCount=Q.height/Q.scanlineBlockSize;for(let T=0;T<Q.blockCount;T++)M(O,W);const mr=Q.width*Q.height*Q.outputChannels;switch(q){case Cr.Float:Q.byteArray=new Float32Array(mr),Q.textureType=1,h&&Q.byteArray.fill(1,0,mr);break;case Cr.HalfFloat:Q.byteArray=new Uint16Array(mr),Q.textureType=2,h&&Q.byteArray.fill(15360,0,mr);break;default:throw new Error("Unsupported type: "+q)}let d=0;for(const T of r.channels)void 0!==Q.decodeChannels[T.name]&&(Q.channelLineOffsets[T.name]=d*Q.width),d+=2*T.pixelType;return Q.bytesPerLine=Q.width*d,Q.outLineWidth=Q.width*Q.outputChannels,"INCREASING_Y"===r.lineOrder?Q.scanOrder=r=>r:Q.scanOrder=r=>Q.height-1-r,4==Q.outputChannels?(Q.format=5,Q.linearSpace=!0):(Q.format=6,Q.linearSpace=!1),Q}function mO(r,O,W,q){const Q={value:0};for(let C=0;C<r.height/r.scanlineBlockSize;C++){const T=N(W,q)-O.dataWindow.yMin;r.size=D(W,q),r.lines=T+r.scanlineBlockSize>r.height?r.height-T:r.scanlineBlockSize;const h=r.size<r.lines*r.bytesPerLine&&r.uncompress?r.uncompress(r):rr(r);q.value+=r.size;for(let W=0;W<r.scanlineBlockSize;W++){const q=C*r.scanlineBlockSize,T=W+r.scanOrder(q);if(T>=r.height)continue;const J=W*r.bytesPerLine,mr=(r.height-1-T)*r.outLineWidth;for(let W=0;W<r.channels;W++){const q=O.channels[W].name,C=r.channelLineOffsets[q],T=r.decodeChannels[q];if(void 0!==T){Q.value=J+C;for(let O=0;O<r.width;O++){const W=mr+O*r.outputChannels+T;r.byteArray&&(r.byteArray[W]=r.getter(h,Q))}}}}}}hr.DefaultOutputType=Cr.HalfFloat,hr.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dr{constructor(){this.supportCascades=!1}loadCubeData(r,O,W,q,Q){throw".exr not supported in Cube."}loadData(r,O,W){const Q=new DataView(r.buffer),C={value:0},T=a(Q,C);Jr(T,Q,C,hr.DefaultOutputType).then((r=>{mO(r,T,Q,C);const q=T.dataWindow.xMax-T.dataWindow.xMin+1,h=T.dataWindow.yMax-T.dataWindow.yMin+1;W(q,h,O.generateMipMaps,!1,(()=>{const W=O.getEngine();O.format=T.format,O.type=r.textureType,O.invertY=!1,O._gammaSpace=!T.linearSpace,r.byteArray&&W._uploadDataToTextureDirectly(O,r.byteArray,0,0,void 0,!0)}))})).catch((r=>{q.b.Error("Failed to load EXR texture: ",r)}))}}async function vr(r){const O=new DataView(r),W={value:0},Q=a(O,W);try{const r=await Jr(Q,O,W,Cr.Float);return mO(r,Q,O,W),r.byteArray?{width:Q.dataWindow.xMax-Q.dataWindow.xMin+1,height:Q.dataWindow.yMax-Q.dataWindow.yMin+1,data:new Float32Array(r.byteArray)}:(q.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(C){q.b.Error("Failed to load EXR data: ",C)}return{width:0,height:0,data:null}}},12602:(r,O,W)=>{function q(r){return parseInt(r.toString().replace(/\W/g,""))}function Q(r,O){let W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(r-O)<=W}function C(r,O,W){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return r<O-q||r>W+q}function T(r,O){return r===O?r:Math.random()*(O-r)+r}function h(r,O,W){return r+(O-r)*W}function J(r,O,W){let q=b(O-r,360);return q>180&&(q-=360),r+q*g(W)}function mr(r,O,W){let q=0;return q=r!=O?g((W-r)/(O-r)):0,q}function d(r,O,W,q,Q){const C=Q*Q,T=Q*C;return r*(2*T-3*C+1)+W*(-2*T+3*C)+O*(T-2*C+Q)+q*(T-C)}function v(r,O,W,q,Q){const C=Q*Q;return 6*(C-Q)*r+(3*C-4*Q+1)*O+6*(-C+Q)*W+(3*C-2*Q)*q}function g(r){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,W=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(W,Math.max(O,r))}function K(r){return r-=2*Math.PI*Math.floor((r+Math.PI)/(2*Math.PI))}function U(r){const O=r.toString(16);return r<=15?("0"+O).toUpperCase():O.toUpperCase()}function P(r){if(Math.log2)return Math.floor(Math.log2(r));if(r<0)return NaN;if(0===r)return-1/0;let O=0;if(r<1){for(;r<1;)O++,r*=2;O=-O}else if(r>1)for(;r>1;)O++,r=Math.floor(r/2);return O}function b(r,O){return r-Math.floor(r/O)*O}function e(r,O,W){return(r-O)/(W-O)}function Y(r,O,W){return r*(W-O)+O}function G(r,O){let W=b(O-r,360);return W>180&&(W-=360),W}function X(r,O){const W=b(r,2*O);return O-Math.abs(W-O)}function S(r,O,W){let q=g(W);return q=-2*q*q*q+3*q*q,O*q+r*(1-q)}function o(r,O,W){let q=0;return q=Math.abs(O-r)<=W?O:r+Math.sign(O-r)*W,q}function N(r,O,W){const q=G(r,O);let Q=0;return Q=-W<q&&q<W?O:o(r,O=r+q,W),Q}function D(r,O,W){return(r-O)/(W-O)}function p(r,O,W){return(W-O)*r+O}function z(r,O){const W=r%O;return 0===W?O:z(O,W)}W.r(O),W.d(O,{Clamp:()=>g,DeltaAngle:()=>G,Denormalize:()=>Y,ExtractAsInt:()=>q,Hermite:()=>d,Hermite1stDerivative:()=>v,HighestCommonFactor:()=>z,ILog2:()=>P,InverseLerp:()=>mr,Lerp:()=>h,LerpAngle:()=>J,MoveTowards:()=>o,MoveTowardsAngle:()=>N,Normalize:()=>e,NormalizeRadians:()=>K,OutsideRange:()=>C,PercentToRange:()=>p,PingPong:()=>X,RandomRange:()=>T,RangeToPercent:()=>D,Repeat:()=>b,SmoothStep:()=>S,ToHex:()=>U,WithinEpsilon:()=>Q})}}]);