"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[16],{15099:(L,U,x)=>{x.r(U),x.d(U,{ReadExrDataAsync:()=>hL,_ExrTextureLoader:()=>rL});var mL=x(12406),p=x(12610);const G=4,F=4,a=1,o=2,A=8,r=65536,h=r>>3,b=14,E=65537,Y=1<<b,S=Y-1,V=59,H=63,Q=2+H-V;var q,f;!function(L){L[L.NO_COMPRESSION=0]="NO_COMPRESSION",L[L.RLE_COMPRESSION=1]="RLE_COMPRESSION",L[L.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",L[L.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",L[L.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",L[L.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(q||(q={})),function(L){L[L.INCREASING_Y=0]="INCREASING_Y",L[L.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const v=function(){const L=new ArrayBuffer(4),U=new Float32Array(L),x=new Uint32Array(L),mL=new Uint32Array(512),p=new Uint32Array(512);for(let o=0;o<256;++o){const L=o-127;L<-27?(mL[o]=0,mL[256|o]=32768,p[o]=24,p[256|o]=24):L<-14?(mL[o]=1024>>-L-14,mL[256|o]=1024>>-L-14|32768,p[o]=-L-1,p[256|o]=-L-1):L<=15?(mL[o]=L+15<<10,mL[256|o]=L+15<<10|32768,p[o]=13,p[256|o]=13):L<128?(mL[o]=31744,mL[256|o]=64512,p[o]=24,p[256|o]=24):(mL[o]=31744,mL[256|o]=64512,p[o]=13,p[256|o]=13)}const G=new Uint32Array(2048),F=new Uint32Array(64),a=new Uint32Array(64);for(let o=1;o<1024;++o){let L=o<<13,U=0;for(;0===(8388608&L);)L<<=1,U-=8388608;L&=-8388609,U+=947912704,G[o]=L|U}for(let o=1024;o<2048;++o)G[o]=939524096+(o-1024<<13);for(let o=1;o<31;++o)F[o]=o<<23;F[31]=1199570944,F[32]=2147483648;for(let o=33;o<63;++o)F[o]=2147483648+(o-32<<23);F[63]=3347054592;for(let o=1;o<64;++o)32!==o&&(a[o]=1024);return{floatView:U,uint32View:x,baseTable:mL,shiftTable:p,mantissaTable:G,exponentTable:F,offsetTable:a}}();function D(L,U){const x=new Uint8Array(L);let mL=0;for(;0!=x[U.value+mL];)mL+=1;const p=(new TextDecoder).decode(x.slice(U.value,U.value+mL));return U.value=U.value+mL+1,p}function P(L,U){const x=L.getInt32(U.value,!0);return U.value+=G,x}function d(L,U){const x=L.getUint32(U.value,!0);return U.value+=G,x}function K(L,U){const x=L.getUint8(U.value);return U.value+=a,x}function l(L,U){const x=L.getUint16(U.value,!0);return U.value+=o,x}function i(L,U){const x=L[U.value];return U.value+=a,x}function X(L,U){let x;return x="getBigInt64"in DataView.prototype?Number(L.getBigInt64(U.value,!0)):L.getUint32(U.value+4,!0)+Number(L.getUint32(U.value,!0)<<32),U.value+=A,x}function t(L,U){const x=L.getFloat32(U.value,!0);return U.value+=F,x}function y(L,U){return function(L){const U=(31744&L)>>10,x=1023&L;return(L>>15?-1:1)*(U?31===U?x?NaN:1/0:Math.pow(2,U-15)*(1+x/1024):x/1024*6103515625e-14)}(l(L,U))}function n(L,U){return function(L){if(Math.abs(L)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");L=(0,p.Clamp)(L,-65504,65504),v.floatView[0]=L;const U=v.uint32View[0],x=U>>23&511;return v.baseTable[x]+((8388607&U)>>v.shiftTable[x])}(t(L,U))}function N(L,U,x,mL){switch(x){case"string":case"stringvector":case"iccProfile":return function(L,U,x){const mL=(new TextDecoder).decode(new Uint8Array(L).slice(U.value,U.value+x));return U.value=U.value+x,mL}(L.buffer,U,mL);case"chlist":return function(L,U,x){const mL=U.value,p=[];for(;U.value<mL+x-1;){const x=D(L.buffer,U),mL=P(L,U),G=K(L,U);U.value+=3;const F=P(L,U),a=P(L,U);p.push({name:x,pixelType:mL,pLinear:G,xSampling:F,ySampling:a})}return U.value+=1,p}(L,U,mL);case"chromaticities":return function(L,U){return{redX:t(L,U),redY:t(L,U),greenX:t(L,U),greenY:t(L,U),blueX:t(L,U),blueY:t(L,U),whiteX:t(L,U),whiteY:t(L,U)}}(L,U);case"compression":return function(L,U){return K(L,U)}(L,U);case"box2i":return function(L,U){return{xMin:P(L,U),yMin:P(L,U),xMax:P(L,U),yMax:P(L,U)}}(L,U);case"lineOrder":return function(L,U){const x=K(L,U);return f[x]}(L,U);case"float":return t(L,U);case"v2f":return function(L,U){return[t(L,U),t(L,U)]}(L,U);case"v3f":return function(L,U){return[t(L,U),t(L,U),t(L,U)]}(L,U);case"int":return P(L,U);case"rational":return function(L,U){return[P(L,U),d(L,U)]}(L,U);case"timecode":return function(L,U){return[d(L,U),d(L,U)]}(L,U);case"preview":return U.value+=mL,"skipped";default:return void(U.value+=mL)}}function e(L){for(let U=1;U<L.length;U++){const x=L[U-1]+L[U]-128;L[U]=x}}function u(L,U){let x=0,mL=Math.floor((L.length+1)/2),p=0;const G=L.length-1;for(;!(p>G)&&(U[p++]=L[x++],!(p>G));)U[p++]=L[mL++]}const Z=20000630;function g(L,U){if(L.getUint32(0,!0)!=Z)throw new Error("Incorrect OpenEXR format");const x=L.getUint8(4),p=L.getUint8(5),G={singleTile:!!(2&p),longName:!!(4&p),deepFormat:!!(8&p),multiPart:!!(16&p)};U.value=8;const F={};let a=!0;for(;a;){const x=D(L.buffer,U);if(x){const p=D(L.buffer,U),G=N(L,U,p,d(L,U));void 0===G?mL.c.Warn(`Unknown header attribute type ${p}'.`):F[x]=G}else a=!1}if(0!=(-5&p))throw new Error("Unsupported file format");return{version:x,spec:G,...F}}const z=32768,M=65535;function J(L,U,x,mL,p){for(;x<L;)U=U<<8|i(mL,p),x+=8;return{l:U>>(x-=L)&(1<<L)-1,c:U,lc:x}}function j(L,U,x,mL){return{c:L=L<<8|i(x,mL),lc:U+=8}}function R(L,U,x,mL,p,G,F,a,o){if(L==U){if(mL<8){const L=j(x,mL,p,G);x=L.c,mL=L.lc}let L=x>>(mL-=8);if(L=new Uint8Array([L])[0],a.value+L>o)return null;const U=F[a.value-1];for(;L-- >0;)F[a.value++]=U}else{if(!(a.value<o))return null;F[a.value++]=L}return{c:x,lc:mL}}const c=new Array(59);function W(L,U,x,mL,p,G){const F=U;let a=0,o=0;for(;mL<=p;mL++){if(F.value-U.value>x)return;let A=J(6,a,o,L,F);const r=A.l;if(a=A.c,o=A.lc,G[mL]=r,r==H){if(F.value-U.value>x)throw new Error("Error in HufUnpackEncTable");A=J(8,a,o,L,F);let r=A.l+Q;if(a=A.c,o=A.lc,mL+r>p+1)throw new Error("Error in HufUnpackEncTable");for(;r--;)G[mL++]=0;mL--}else if(r>=V){let L=r-V+2;if(mL+L>p+1)throw new Error("Error in HufUnpackEncTable");for(;L--;)G[mL++]=0;mL--}}!function(L){for(let x=0;x<=58;++x)c[x]=0;for(let x=0;x<E;++x)c[L[x]]+=1;let U=0;for(let x=58;x>0;--x){const L=U+c[x]>>1;c[x]=U,U=L}for(let x=0;x<E;++x){const U=L[x];U>0&&(L[x]=U|c[U]++<<6)}}(G)}function I(L){return 63&L}function w(L){return L>>6}function B(L,U,x,mL,p,G){const F=x.value,a=d(U,x),o=d(U,x);x.value+=4;const A=d(U,x);if(x.value+=4,a<0||a>=E||o<0||o>=E)throw new Error("Wrong HUF_ENCSIZE");const r=new Array(E),h=new Array(Y);!function(L){for(let U=0;U<Y;U++)L[U]={},L[U].len=0,L[U].lit=0,L[U].p=null}(h);if(W(L,x,mL-(x.value-F),a,o,r),A>8*(mL-(x.value-F)))throw new Error("Wrong hufUncompress");!function(L,U,x,mL){for(;U<=x;U++){const x=w(L[U]),p=I(L[U]);if(x>>p)throw new Error("Invalid table entry");if(p>b){const L=mL[x>>p-b];if(L.len)throw new Error("Invalid table entry");if(L.lit++,L.p){const U=L.p;L.p=new Array(L.lit);for(let x=0;x<L.lit-1;++x)L.p[x]=U[x]}else L.p=new Array(1);L.p[L.lit-1]=U}else if(p){let L=0;for(let G=1<<b-p;G>0;G--){const G=mL[(x<<b-p)+L];if(G.len||G.p)throw new Error("Invalid table entry");G.len=p,G.lit=U,L++}}}}(r,a,o,h),function(L,U,x,mL,p,G,F,a,o){let A=0,r=0;const h=F,E=Math.trunc(mL.value+(p+7)/8);for(;mL.value<E;){let p=j(A,r,x,mL);for(A=p.c,r=p.lc;r>=b;){const F=U[A>>r-b&S];if(F.len){r-=F.len;const L=R(F.lit,G,A,r,x,mL,a,o,h);L&&(A=L.c,r=L.lc)}else{if(!F.p)throw new Error("hufDecode issues");let U;for(U=0;U<F.lit;U++){const b=I(L[F.p[U]]);for(;r<b&&mL.value<E;)p=j(A,r,x,mL),A=p.c,r=p.lc;if(r>=b&&w(L[F.p[U]])==(A>>r-b&(1<<b)-1)){r-=b;const L=R(F.p[U],G,A,r,x,mL,a,o,h);L&&(A=L.c,r=L.lc);break}}if(U==F.lit)throw new Error("HufDecode issues")}}}const Y=8-p&7;for(A>>=Y,r-=Y;r>0;){const L=U[A<<b-r&S];if(!L.len)throw new Error("HufDecode issues");{r-=L.len;const U=R(L.lit,G,A,r,x,mL,a,o,h);U&&(A=U.c,r=U.lc)}}}(r,h,L,x,A,o,G,p,{value:0})}function s(L){return 65535&L}function C(L){const U=s(L);return U>32767?U-65536:U}function k(L,U){const x=C(L),mL=C(U),p=x+(1&mL)+(mL>>1);return{a:p,b:p-mL}}function T(L,U){const x=s(L),mL=s(U),p=x-(mL>>1)&M;return{a:mL+p-z&M,b:p}}function O(L,U,x,mL,p,G,F){const a=F<16384,o=x>p?p:x;let A,r,h=1;for(;h<=o;)h<<=1;for(h>>=1,A=h,h>>=1;h>=1;){r=0;const F=r+G*(p-A),o=G*h,b=G*A,E=mL*h,Y=mL*A;let S,V,H,Q;for(;r<=F;r+=b){let p=r;const G=r+mL*(x-A);for(;p<=G;p+=Y){const x=p+E,mL=p+o,G=mL+E;if(a){let F=k(L[p+U],L[mL+U]);S=F.a,H=F.b,F=k(L[x+U],L[G+U]),V=F.a,Q=F.b,F=k(S,V),L[p+U]=F.a,L[x+U]=F.b,F=k(H,Q),L[mL+U]=F.a,L[G+U]=F.b}else{let F=T(L[p+U],L[mL+U]);S=F.a,H=F.b,F=T(L[x+U],L[G+U]),V=F.a,Q=F.b,F=T(S,V),L[p+U]=F.a,L[x+U]=F.b,F=T(H,Q),L[mL+U]=F.a,L[G+U]=F.b}}if(x&h){const x=p+o;let mL;mL=a?k(L[p+U],L[x+U]):T(L[p+U],L[x+U]),S=mL.a,L[x+U]=mL.b,L[p+U]=S}}if(p&h){let p=r;const G=r+mL*(x-A);for(;p<=G;p+=Y){const x=p+E;let mL;mL=a?k(L[p+U],L[x+U]):T(L[p+U],L[x+U]),S=mL.a,L[x+U]=mL.b,L[p+U]=S}}A=h,h>>=1}return r}function LL(L){return new DataView(L.array.buffer,L.offset.value,L.size)}function UL(L){const U=L.viewer.buffer.slice(L.offset.value,L.offset.value+L.size),x=new Uint8Array(function(L){let U=L.byteLength;const x=[];let mL=0;const p=new DataView(L);for(;U>0;){const L=p.getInt8(mL++);if(L<0){const G=-L;U-=G+1;for(let L=0;L<G;L++)x.push(p.getUint8(mL++))}else{const G=L;U-=2;const F=p.getUint8(mL++);for(let L=0;L<G+1;L++)x.push(F)}}return x}(U)),mL=new Uint8Array(x.length);return e(x),u(x,mL),new DataView(mL.buffer)}function xL(L){const U=L.array.slice(L.offset.value,L.offset.value+L.size),x=fflate.unzlibSync(U),mL=new Uint8Array(x.length);return e(x),u(x,mL),new DataView(mL.buffer)}function mU(L){const U=L.array.slice(L.offset.value,L.offset.value+L.size),x=fflate.unzlibSync(U),mL=L.lines*L.channels*L.width,p=1==L.type?new Uint16Array(mL):new Uint32Array(mL);let G=0,F=0;const a=new Array(4);for(let o=0;o<L.lines;o++)for(let U=0;U<L.channels;U++){let U=0;switch(L.type){case 1:a[0]=G,a[1]=a[0]+L.width,G=a[1]+L.width;for(let mL=0;mL<L.width;++mL){U+=x[a[0]++]<<8|x[a[1]++],p[F]=U,F++}break;case 2:a[0]=G,a[1]=a[0]+L.width,a[2]=a[1]+L.width,G=a[2]+L.width;for(let mL=0;mL<L.width;++mL){U+=x[a[0]++]<<24|x[a[1]++]<<16|x[a[2]++]<<8,p[F]=U,F++}}}return new DataView(p.buffer)}function pL(L){const U=L.viewer,x={value:L.offset.value},mL=new Uint16Array(L.width*L.scanlineBlockSize*(L.channels*L.type)),p=new Uint8Array(h);let G=0;const F=new Array(L.channels);for(let o=0;o<L.channels;o++)F[o]={},F[o].start=G,F[o].end=F[o].start,F[o].nx=L.width,F[o].ny=L.lines,F[o].size=L.type,G+=F[o].nx*F[o].ny*F[o].size;const a=l(U,x),A=l(U,x);if(A>=h)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(a<=A)for(let o=0;o<A-a+1;o++)p[o+a]=K(U,x);const b=new Uint16Array(r),E=function(L,U){let x=0;for(let p=0;p<r;++p)(0==p||L[p>>3]&1<<(7&p))&&(U[x++]=p);const mL=x-1;for(;x<r;)U[x++]=0;return mL}(p,b),Y=d(U,x);B(L.array,U,x,Y,mL,G);for(let o=0;o<L.channels;++o){const L=F[o];for(let U=0;U<F[o].size;++U)O(mL,L.start+U,L.nx,L.size,L.ny,L.nx*L.size,E)}!function(L,U,x){for(let mL=0;mL<x;++mL)U[mL]=L[U[mL]]}(b,mL,G);let S=0;const V=new Uint8Array(mL.buffer.byteLength);for(let r=0;r<L.lines;r++)for(let U=0;U<L.channels;U++){const L=F[U],x=L.nx*L.size,p=new Uint8Array(mL.buffer,L.end*o,x*o);V.set(p,S),S+=x*o,L.end+=x}return new DataView(V.buffer)}var GL,FL=x(12382);!function(L){L[L.Float=0]="Float",L[L.HalfFloat=1]="HalfFloat"}(GL||(GL={}));class aL{}async function oL(L,U,x,mL){const p={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:x,width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,channels:L.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(L.compression){case q.NO_COMPRESSION:p.lines=1,p.uncompress=LL;break;case q.RLE_COMPRESSION:p.lines=1,p.uncompress=UL;break;case q.ZIPS_COMPRESSION:p.lines=1,p.uncompress=xL,await FL.Tools.LoadScriptAsync(aL.FFLATEUrl);break;case q.ZIP_COMPRESSION:p.lines=16,p.uncompress=xL,await FL.Tools.LoadScriptAsync(aL.FFLATEUrl);break;case q.PIZ_COMPRESSION:p.lines=32,p.uncompress=pL;break;case q.PXR24_COMPRESSION:p.lines=16,p.uncompress=mU,await FL.Tools.LoadScriptAsync(aL.FFLATEUrl);break;default:throw new Error(q[L.compression]+" is unsupported")}p.scanlineBlockSize=p.lines;const G={};for(const F of L.channels)switch(F.name){case"R":case"G":case"B":case"A":case"Y":G[F.name]=!0,p.type=F.pixelType}let a=!1;if(G.R&&G.G&&G.B&&G.A)p.outputChannels=4,p.decodeChannels={R:0,G:1,B:2,A:3};else if(G.R&&G.G&&G.B)a=!0,p.outputChannels=4,p.decodeChannels={R:0,G:1,B:2,A:3};else if(G.R&&G.G)p.outputChannels=2,p.decodeChannels={R:0,G:1};else if(G.R)p.outputChannels=1,p.decodeChannels={R:0};else{if(!G.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");p.outputChannels=1,p.decodeChannels={Y:0}}if(1===p.type)switch(mL){case GL.Float:p.getter=y,p.inputSize=o;break;case GL.HalfFloat:p.getter=l,p.inputSize=o}else{if(2!==p.type)throw new Error("Unsupported pixelType "+p.type+" for "+L.compression);switch(mL){case GL.Float:p.getter=t,p.inputSize=F;break;case GL.HalfFloat:p.getter=n,p.inputSize=F}}p.blockCount=p.height/p.scanlineBlockSize;for(let F=0;F<p.blockCount;F++)X(U,x);const A=p.width*p.height*p.outputChannels;switch(mL){case GL.Float:p.byteArray=new Float32Array(A),p.textureType=1,a&&p.byteArray.fill(1,0,A);break;case GL.HalfFloat:p.byteArray=new Uint16Array(A),p.textureType=2,a&&p.byteArray.fill(15360,0,A);break;default:throw new Error("Unsupported type: "+mL)}let r=0;for(const F of L.channels)void 0!==p.decodeChannels[F.name]&&(p.channelLineOffsets[F.name]=r*p.width),r+=2*F.pixelType;return p.bytesPerLine=p.width*r,p.outLineWidth=p.width*p.outputChannels,"INCREASING_Y"===L.lineOrder?p.scanOrder=L=>L:p.scanOrder=L=>p.height-1-L,4==p.outputChannels?(p.format=5,p.linearSpace=!0):(p.format=6,p.linearSpace=!1),p}function AL(L,U,x,mL){const p={value:0};for(let G=0;G<L.height/L.scanlineBlockSize;G++){const F=P(x,mL)-U.dataWindow.yMin;L.size=d(x,mL),L.lines=F+L.scanlineBlockSize>L.height?L.height-F:L.scanlineBlockSize;const a=L.size<L.lines*L.bytesPerLine&&L.uncompress?L.uncompress(L):LL(L);mL.value+=L.size;for(let x=0;x<L.scanlineBlockSize;x++){const mL=G*L.scanlineBlockSize,F=x+L.scanOrder(mL);if(F>=L.height)continue;const o=x*L.bytesPerLine,A=(L.height-1-F)*L.outLineWidth;for(let x=0;x<L.channels;x++){const mL=U.channels[x].name,G=L.channelLineOffsets[mL],F=L.decodeChannels[mL];if(void 0!==F){p.value=o+G;for(let U=0;U<L.width;U++){const x=A+U*L.outputChannels+F;L.byteArray&&(L.byteArray[x]=L.getter(a,p))}}}}}}aL.DefaultOutputType=GL.HalfFloat,aL.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class rL{constructor(){this.supportCascades=!1}loadCubeData(L,U,x,mL,p){throw".exr not supported in Cube."}loadData(L,U,x){const p=new DataView(L.buffer),G={value:0},F=g(p,G);oL(F,p,G,aL.DefaultOutputType).then((L=>{AL(L,F,p,G);const mL=F.dataWindow.xMax-F.dataWindow.xMin+1,a=F.dataWindow.yMax-F.dataWindow.yMin+1;x(mL,a,U.generateMipMaps,!1,(()=>{const x=U.getEngine();U.format=F.format,U.type=L.textureType,U.invertY=!1,U._gammaSpace=!F.linearSpace,L.byteArray&&x._uploadDataToTextureDirectly(U,L.byteArray,0,0,void 0,!0)}))})).catch((L=>{mL.c.Error("Failed to load EXR texture: ",L)}))}}async function hL(L){const U=new DataView(L),x={value:0},p=g(U,x);try{const L=await oL(p,U,x,GL.Float);return AL(L,p,U,x),L.byteArray?{width:p.dataWindow.xMax-p.dataWindow.xMin+1,height:p.dataWindow.yMax-p.dataWindow.yMin+1,data:new Float32Array(L.byteArray)}:(mL.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(G){mL.c.Error("Failed to load EXR data: ",G)}return{width:0,height:0,data:null}}},12610:(L,U,x)=>{function mL(L){return parseInt(L.toString().replace(/\W/g,""))}function p(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(L-U)<=x}function G(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return L<U-mL||L>x+mL}function F(L,U){return L===U?L:Math.random()*(U-L)+L}function a(L,U,x){return L+(U-L)*x}function o(L,U,x){let mL=V(U-L,360);return mL>180&&(mL-=360),L+mL*b(x)}function A(L,U,x){let mL=0;return mL=L!=U?b((x-L)/(U-L)):0,mL}function r(L,U,x,mL,p){const G=p*p,F=p*G;return L*(2*F-3*G+1)+x*(-2*F+3*G)+U*(F-2*G+p)+mL*(F-G)}function h(L,U,x,mL,p){const G=p*p;return 6*(G-p)*L+(3*G-4*p+1)*U+6*(-G+p)*x+(3*G-2*p)*mL}function b(L){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(x,Math.max(U,L))}function E(L){return L-=2*Math.PI*Math.floor((L+Math.PI)/(2*Math.PI))}function Y(L){const U=L.toString(16);return L<=15?("0"+U).toUpperCase():U.toUpperCase()}function S(L){if(Math.log2)return Math.floor(Math.log2(L));if(L<0)return NaN;if(0===L)return-1/0;let U=0;if(L<1){for(;L<1;)U++,L*=2;U=-U}else if(L>1)for(;L>1;)U++,L=Math.floor(L/2);return U}function V(L,U){return L-Math.floor(L/U)*U}function H(L,U,x){return(L-U)/(x-U)}function Q(L,U,x){return L*(x-U)+U}function q(L,U){let x=V(U-L,360);return x>180&&(x-=360),x}function f(L,U){const x=V(L,2*U);return U-Math.abs(x-U)}function v(L,U,x){let mL=b(x);return mL=-2*mL*mL*mL+3*mL*mL,U*mL+L*(1-mL)}function D(L,U,x){let mL=0;return mL=Math.abs(U-L)<=x?U:L+Math.sign(U-L)*x,mL}function P(L,U,x){const mL=q(L,U);let p=0;return p=-x<mL&&mL<x?U:D(L,U=L+mL,x),p}function d(L,U,x){return(L-U)/(x-U)}function K(L,U,x){return(x-U)*L+U}function l(L,U){const x=L%U;return 0===x?U:l(U,x)}x.r(U),x.d(U,{Clamp:()=>b,DeltaAngle:()=>q,Denormalize:()=>Q,ExtractAsInt:()=>mL,Hermite:()=>r,Hermite1stDerivative:()=>h,HighestCommonFactor:()=>l,ILog2:()=>S,InverseLerp:()=>A,Lerp:()=>a,LerpAngle:()=>o,MoveTowards:()=>D,MoveTowardsAngle:()=>P,Normalize:()=>H,NormalizeRadians:()=>E,OutsideRange:()=>G,PercentToRange:()=>K,PingPong:()=>f,RandomRange:()=>F,RangeToPercent:()=>d,Repeat:()=>V,SmoothStep:()=>v,ToHex:()=>Y,WithinEpsilon:()=>p})}}]);