"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[16],{15113:(M,A,O)=>{O.r(A),O.d(A,{ReadExrDataAsync:()=>TM,_ExrTextureLoader:()=>eM});var S=O(22),z=O(12783),Q=O(12980);const X=4,c=4,j=1,B=2,g=8,e=65536,T=e>>3,J=14,K=65537,G=1<<J,d=G-1,w=59,I=63,b=2+I-w;var s,Y;!function(M){M[M.NO_COMPRESSION=0]="NO_COMPRESSION",M[M.RLE_COMPRESSION=1]="RLE_COMPRESSION",M[M.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",M[M.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",M[M.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",M[M.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(s||(s={})),function(M){M[M.INCREASING_Y=0]="INCREASING_Y",M[M.DECREASING_Y=1]="DECREASING_Y"}(Y||(Y={}));const E=function(){const M=new ArrayBuffer(4),A=new Float32Array(M),O=new Uint32Array(M),S=new Uint32Array(512),z=new Uint32Array(512);for(let j=0;j<256;++j){const M=j-127;M<-27?(S[j]=0,S[256|j]=32768,z[j]=24,z[256|j]=24):M<-14?(S[j]=1024>>-M-14,S[256|j]=1024>>-M-14|32768,z[j]=-M-1,z[256|j]=-M-1):M<=15?(S[j]=M+15<<10,S[256|j]=M+15<<10|32768,z[j]=13,z[256|j]=13):M<128?(S[j]=31744,S[256|j]=64512,z[j]=24,z[256|j]=24):(S[j]=31744,S[256|j]=64512,z[j]=13,z[256|j]=13)}const Q=new Uint32Array(2048),X=new Uint32Array(64),c=new Uint32Array(64);for(let j=1;j<1024;++j){let M=j<<13,A=0;for(;0===(8388608&M);)M<<=1,A-=8388608;M&=-8388609,A+=947912704,Q[j]=M|A}for(let j=1024;j<2048;++j)Q[j]=939524096+(j-1024<<13);for(let j=1;j<31;++j)X[j]=j<<23;X[31]=1199570944,X[32]=2147483648;for(let j=33;j<63;++j)X[j]=2147483648+(j-32<<23);X[63]=3347054592;for(let j=1;j<64;++j)32!==j&&(c[j]=1024);return{floatView:A,uint32View:O,baseTable:S,shiftTable:z,mantissaTable:Q,exponentTable:X,offsetTable:c}}();function H(M,A){const O=new Uint8Array(M);let S=0;for(;0!=O[A.value+S];)S+=1;const z=(new TextDecoder).decode(O.slice(A.value,A.value+S));return A.value=A.value+S+1,z}function C(M,A){const O=M.getInt32(A.value,!0);return A.value+=X,O}function f(M,A){const O=M.getUint32(A.value,!0);return A.value+=X,O}function D(M,A){const O=M.getUint8(A.value);return A.value+=j,O}function F(M,A){const O=M.getUint16(A.value,!0);return A.value+=B,O}function N(M,A){const O=M[A.value];return A.value+=j,O}function y(M,A){let O;return O="getBigInt64"in DataView.prototype?Number(M.getBigInt64(A.value,!0)):M.getUint32(A.value+4,!0)+Number(M.getUint32(A.value,!0)<<32),A.value+=g,O}function h(M,A){const O=M.getFloat32(A.value,!0);return A.value+=c,O}function u(M,A){return function(M){const A=(31744&M)>>10,O=1023&M;return(M>>15?-1:1)*(A?31===A?O?NaN:1/0:Math.pow(2,A-15)*(1+O/1024):O/1024*6103515625e-14)}(F(M,A))}function i(M,A){return function(M){if(Math.abs(M)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");M=(0,Q.Clamp)(M,-65504,65504),E.floatView[0]=M;const A=E.uint32View[0],O=A>>23&511;return E.baseTable[O]+((8388607&A)>>E.shiftTable[O])}(h(M,A))}function U(M,A,O,S){switch(O){case"string":case"stringvector":case"iccProfile":return function(M,A,O){const S=(new TextDecoder).decode(new Uint8Array(M).slice(A.value,A.value+O));return A.value=A.value+O,S}(M.buffer,A,S);case"chlist":return function(M,A,O){const S=A.value,z=[];for(;A.value<S+O-1;){const O=H(M.buffer,A),S=C(M,A),Q=D(M,A);A.value+=3;const X=C(M,A),c=C(M,A);z.push({name:O,pixelType:S,pLinear:Q,xSampling:X,ySampling:c})}return A.value+=1,z}(M,A,S);case"chromaticities":return function(M,A){return{redX:h(M,A),redY:h(M,A),greenX:h(M,A),greenY:h(M,A),blueX:h(M,A),blueY:h(M,A),whiteX:h(M,A),whiteY:h(M,A)}}(M,A);case"compression":return function(M,A){return D(M,A)}(M,A);case"box2i":return function(M,A){return{xMin:C(M,A),yMin:C(M,A),xMax:C(M,A),yMax:C(M,A)}}(M,A);case"lineOrder":return function(M,A){const O=D(M,A);return Y[O]}(M,A);case"float":return h(M,A);case"v2f":return function(M,A){return[h(M,A),h(M,A)]}(M,A);case"v3f":return function(M,A){return[h(M,A),h(M,A),h(M,A)]}(M,A);case"int":return C(M,A);case"rational":return function(M,A){return[C(M,A),f(M,A)]}(M,A);case"timecode":return function(M,A){return[f(M,A),f(M,A)]}(M,A);case"preview":return A.value+=S,"skipped";default:return void(A.value+=S)}}function L(M){for(let A=1;A<M.length;A++){const O=M[A-1]+M[A]-128;M[A]=O}}function t(M,A){let O=0,S=Math.floor((M.length+1)/2),z=0;const Q=M.length-1;for(;!(z>Q)&&(A[z++]=M[O++],!(z>Q));)A[z++]=M[S++]}const x=20000630;function o(M,A){if(M.getUint32(0,!0)!=x)throw new Error("Incorrect OpenEXR format");const O=M.getUint8(4),Q=M.getUint8(5),X={singleTile:!!(2&Q),longName:!!(4&Q),deepFormat:!!(8&Q),multiPart:!!(16&Q)};A.value=8;const c={};let j=!0;for(;j;){const O=H(M.buffer,A);if(O){const S=H(M.buffer,A),Q=U(M,A,S,f(M,A));void 0===Q?z.c.Warn("Unknown header attribute type ".concat(S,"'.")):c[O]=Q}else j=!1}if(0!=(-5&Q))throw new Error("Unsupported file format");return(0,S.d)({version:O,spec:X},c)}const p=32768,v=65535;function q(M,A,O,S,z){for(;O<M;)A=A<<8|N(S,z),O+=8;return{l:A>>(O-=M)&(1<<M)-1,c:A,lc:O}}function r(M,A,O,S){return{c:M=M<<8|N(O,S),lc:A+=8}}function n(M,A,O,S,z,Q,X,c,j){if(M==A){if(S<8){const M=r(O,S,z,Q);O=M.c,S=M.lc}let M=O>>(S-=8);if(M=new Uint8Array([M])[0],c.value+M>j)return null;const A=X[c.value-1];for(;M-- >0;)X[c.value++]=A}else{if(!(c.value<j))return null;X[c.value++]=M}return{c:O,lc:S}}const a=new Array(59);function V(M,A,O,S,z,Q){const X=A;let c=0,j=0;for(;S<=z;S++){if(X.value-A.value>O)return;let B=q(6,c,j,M,X);const g=B.l;if(c=B.c,j=B.lc,Q[S]=g,g==I){if(X.value-A.value>O)throw new Error("Error in HufUnpackEncTable");B=q(8,c,j,M,X);let g=B.l+b;if(c=B.c,j=B.lc,S+g>z+1)throw new Error("Error in HufUnpackEncTable");for(;g--;)Q[S++]=0;S--}else if(g>=w){let M=g-w+2;if(S+M>z+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)Q[S++]=0;S--}}!function(M){for(let O=0;O<=58;++O)a[O]=0;for(let O=0;O<K;++O)a[M[O]]+=1;let A=0;for(let O=58;O>0;--O){const M=A+a[O]>>1;a[O]=A,A=M}for(let O=0;O<K;++O){const A=M[O];A>0&&(M[O]=A|a[A]++<<6)}}(Q)}function Z(M){return 63&M}function P(M){return M>>6}function mM(M,A,O,S,z,Q){const X=O.value,c=f(A,O),j=f(A,O);O.value+=4;const B=f(A,O);if(O.value+=4,c<0||c>=K||j<0||j>=K)throw new Error("Wrong HUF_ENCSIZE");const g=new Array(K),e=new Array(G);!function(M){for(let A=0;A<G;A++)M[A]={},M[A].len=0,M[A].lit=0,M[A].p=null}(e);if(V(M,O,S-(O.value-X),c,j,g),B>8*(S-(O.value-X)))throw new Error("Wrong hufUncompress");!function(M,A,O,S){for(;A<=O;A++){const O=P(M[A]),z=Z(M[A]);if(O>>z)throw new Error("Invalid table entry");if(z>J){const M=S[O>>z-J];if(M.len)throw new Error("Invalid table entry");if(M.lit++,M.p){const A=M.p;M.p=new Array(M.lit);for(let O=0;O<M.lit-1;++O)M.p[O]=A[O]}else M.p=new Array(1);M.p[M.lit-1]=A}else if(z){let M=0;for(let Q=1<<J-z;Q>0;Q--){const Q=S[(O<<J-z)+M];if(Q.len||Q.p)throw new Error("Invalid table entry");Q.len=z,Q.lit=A,M++}}}}(g,c,j,e),function(M,A,O,S,z,Q,X,c,j){let B=0,g=0;const e=X,T=Math.trunc(S.value+(z+7)/8);for(;S.value<T;){let z=r(B,g,O,S);for(B=z.c,g=z.lc;g>=J;){const X=A[B>>g-J&d];if(X.len){g-=X.len;const M=n(X.lit,Q,B,g,O,S,c,j,e);M&&(B=M.c,g=M.lc)}else{if(!X.p)throw new Error("hufDecode issues");let A;for(A=0;A<X.lit;A++){const J=Z(M[X.p[A]]);for(;g<J&&S.value<T;)z=r(B,g,O,S),B=z.c,g=z.lc;if(g>=J&&P(M[X.p[A]])==(B>>g-J&(1<<J)-1)){g-=J;const M=n(X.p[A],Q,B,g,O,S,c,j,e);M&&(B=M.c,g=M.lc);break}}if(A==X.lit)throw new Error("HufDecode issues")}}}const K=8-z&7;for(B>>=K,g-=K;g>0;){const M=A[B<<J-g&d];if(!M.len)throw new Error("HufDecode issues");{g-=M.len;const A=n(M.lit,Q,B,g,O,S,c,j,e);A&&(B=A.c,g=A.lc)}}}(g,e,M,O,B,j,Q,z,{value:0})}function R(M){return 65535&M}function k(M){const A=R(M);return A>32767?A-65536:A}function W(M,A){const O=k(M),S=k(A),z=O+(1&S)+(S>>1);return{a:z,b:z-S}}function l(M,A){const O=R(M),S=R(A),z=O-(S>>1)&v;return{a:S+z-p&v,b:z}}function MM(M,A,O,S,z,Q,X){const c=X<16384,j=O>z?z:O;let B,g,e=1;for(;e<=j;)e<<=1;for(e>>=1,B=e,e>>=1;e>=1;){g=0;const X=g+Q*(z-B),j=Q*e,T=Q*B,J=S*e,K=S*B;let G,d,w,I;for(;g<=X;g+=T){let z=g;const Q=g+S*(O-B);for(;z<=Q;z+=K){const O=z+J,S=z+j,Q=S+J;if(c){let X=W(M[z+A],M[S+A]);G=X.a,w=X.b,X=W(M[O+A],M[Q+A]),d=X.a,I=X.b,X=W(G,d),M[z+A]=X.a,M[O+A]=X.b,X=W(w,I),M[S+A]=X.a,M[Q+A]=X.b}else{let X=l(M[z+A],M[S+A]);G=X.a,w=X.b,X=l(M[O+A],M[Q+A]),d=X.a,I=X.b,X=l(G,d),M[z+A]=X.a,M[O+A]=X.b,X=l(w,I),M[S+A]=X.a,M[Q+A]=X.b}}if(O&e){const O=z+j;let S;S=c?W(M[z+A],M[O+A]):l(M[z+A],M[O+A]),G=S.a,M[O+A]=S.b,M[z+A]=G}}if(z&e){let z=g;const Q=g+S*(O-B);for(;z<=Q;z+=K){const O=z+J;let S;S=c?W(M[z+A],M[O+A]):l(M[z+A],M[O+A]),G=S.a,M[O+A]=S.b,M[z+A]=G}}B=e,e>>=1}return g}function AM(M){return new DataView(M.array.buffer,M.offset.value,M.size)}function OM(M){const A=M.viewer.buffer.slice(M.offset.value,M.offset.value+M.size),O=new Uint8Array(function(M){let A=M.byteLength;const O=[];let S=0;const z=new DataView(M);for(;A>0;){const M=z.getInt8(S++);if(M<0){const Q=-M;A-=Q+1;for(let M=0;M<Q;M++)O.push(z.getUint8(S++))}else{const Q=M;A-=2;const X=z.getUint8(S++);for(let M=0;M<Q+1;M++)O.push(X)}}return O}(A)),S=new Uint8Array(O.length);return L(O),t(O,S),new DataView(S.buffer)}function SM(M){const A=M.array.slice(M.offset.value,M.offset.value+M.size),O=fflate.unzlibSync(A),S=new Uint8Array(O.length);return L(O),t(O,S),new DataView(S.buffer)}function zM(M){const A=M.array.slice(M.offset.value,M.offset.value+M.size),O=fflate.unzlibSync(A),S=M.lines*M.channels*M.width,z=1==M.type?new Uint16Array(S):new Uint32Array(S);let Q=0,X=0;const c=new Array(4);for(let j=0;j<M.lines;j++)for(let A=0;A<M.channels;A++){let A=0;switch(M.type){case 1:c[0]=Q,c[1]=c[0]+M.width,Q=c[1]+M.width;for(let S=0;S<M.width;++S){A+=O[c[0]++]<<8|O[c[1]++],z[X]=A,X++}break;case 2:c[0]=Q,c[1]=c[0]+M.width,c[2]=c[1]+M.width,Q=c[2]+M.width;for(let S=0;S<M.width;++S){A+=O[c[0]++]<<24|O[c[1]++]<<16|O[c[2]++]<<8,z[X]=A,X++}}}return new DataView(z.buffer)}function QM(M){const A=M.viewer,O={value:M.offset.value},S=new Uint16Array(M.width*M.scanlineBlockSize*(M.channels*M.type)),z=new Uint8Array(T);let Q=0;const X=new Array(M.channels);for(let B=0;B<M.channels;B++)X[B]={},X[B].start=Q,X[B].end=X[B].start,X[B].nx=M.width,X[B].ny=M.lines,X[B].size=M.type,Q+=X[B].nx*X[B].ny*X[B].size;const c=F(A,O),j=F(A,O);if(j>=T)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(c<=j)for(let B=0;B<j-c+1;B++)z[B+c]=D(A,O);const g=new Uint16Array(e),J=function(M,A){let O=0;for(let z=0;z<e;++z)(0==z||M[z>>3]&1<<(7&z))&&(A[O++]=z);const S=O-1;for(;O<e;)A[O++]=0;return S}(z,g),K=f(A,O);mM(M.array,A,O,K,S,Q);for(let B=0;B<M.channels;++B){const M=X[B];for(let A=0;A<X[B].size;++A)MM(S,M.start+A,M.nx,M.size,M.ny,M.nx*M.size,J)}!function(M,A,O){for(let S=0;S<O;++S)A[S]=M[A[S]]}(g,S,Q);let G=0;const d=new Uint8Array(S.buffer.byteLength);for(let e=0;e<M.lines;e++)for(let A=0;A<M.channels;A++){const M=X[A],O=M.nx*M.size,z=new Uint8Array(S.buffer,M.end*B,O*B);d.set(z,G),G+=O*B,M.end+=O}return new DataView(d.buffer)}var XM,cM=O(12768);!function(M){M[M.Float=0]="Float",M[M.HalfFloat=1]="HalfFloat"}(XM||(XM={}));class jM{}async function BM(M,A,O,S){const z={size:0,viewer:A,array:new Uint8Array(A.buffer),offset:O,width:M.dataWindow.xMax-M.dataWindow.xMin+1,height:M.dataWindow.yMax-M.dataWindow.yMin+1,channels:M.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(M.compression){case s.NO_COMPRESSION:z.lines=1,z.uncompress=AM;break;case s.RLE_COMPRESSION:z.lines=1,z.uncompress=OM;break;case s.ZIPS_COMPRESSION:z.lines=1,z.uncompress=SM,await cM.Tools.LoadScriptAsync(jM.FFLATEUrl);break;case s.ZIP_COMPRESSION:z.lines=16,z.uncompress=SM,await cM.Tools.LoadScriptAsync(jM.FFLATEUrl);break;case s.PIZ_COMPRESSION:z.lines=32,z.uncompress=QM;break;case s.PXR24_COMPRESSION:z.lines=16,z.uncompress=zM,await cM.Tools.LoadScriptAsync(jM.FFLATEUrl);break;default:throw new Error(s[M.compression]+" is unsupported")}z.scanlineBlockSize=z.lines;const Q={};for(const c of M.channels)switch(c.name){case"R":case"G":case"B":case"A":case"Y":Q[c.name]=!0,z.type=c.pixelType}let X=!1;if(Q.R&&Q.G&&Q.B&&Q.A)z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else if(Q.R&&Q.G&&Q.B)X=!0,z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else if(Q.R&&Q.G)z.outputChannels=2,z.decodeChannels={R:0,G:1};else if(Q.R)z.outputChannels=1,z.decodeChannels={R:0};else{if(!Q.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");z.outputChannels=1,z.decodeChannels={Y:0}}if(1===z.type)switch(S){case XM.Float:z.getter=u,z.inputSize=B;break;case XM.HalfFloat:z.getter=F,z.inputSize=B}else{if(2!==z.type)throw new Error("Unsupported pixelType "+z.type+" for "+M.compression);switch(S){case XM.Float:z.getter=h,z.inputSize=c;break;case XM.HalfFloat:z.getter=i,z.inputSize=c}}z.blockCount=z.height/z.scanlineBlockSize;for(let c=0;c<z.blockCount;c++)y(A,O);const j=z.width*z.height*z.outputChannels;switch(S){case XM.Float:z.byteArray=new Float32Array(j),z.textureType=1,X&&z.byteArray.fill(1,0,j);break;case XM.HalfFloat:z.byteArray=new Uint16Array(j),z.textureType=2,X&&z.byteArray.fill(15360,0,j);break;default:throw new Error("Unsupported type: "+S)}let g=0;for(const c of M.channels)void 0!==z.decodeChannels[c.name]&&(z.channelLineOffsets[c.name]=g*z.width),g+=2*c.pixelType;return z.bytesPerLine=z.width*g,z.outLineWidth=z.width*z.outputChannels,"INCREASING_Y"===M.lineOrder?z.scanOrder=M=>M:z.scanOrder=M=>z.height-1-M,4==z.outputChannels?(z.format=5,z.linearSpace=!0):(z.format=6,z.linearSpace=!1),z}function gM(M,A,O,S){const z={value:0};for(let Q=0;Q<M.height/M.scanlineBlockSize;Q++){const X=C(O,S)-A.dataWindow.yMin;M.size=f(O,S),M.lines=X+M.scanlineBlockSize>M.height?M.height-X:M.scanlineBlockSize;const c=M.size<M.lines*M.bytesPerLine&&M.uncompress?M.uncompress(M):AM(M);S.value+=M.size;for(let O=0;O<M.scanlineBlockSize;O++){const S=Q*M.scanlineBlockSize,X=O+M.scanOrder(S);if(X>=M.height)continue;const j=O*M.bytesPerLine,B=(M.height-1-X)*M.outLineWidth;for(let O=0;O<M.channels;O++){const S=A.channels[O].name,Q=M.channelLineOffsets[S],X=M.decodeChannels[S];if(void 0!==X){z.value=j+Q;for(let A=0;A<M.width;A++){const O=B+A*M.outputChannels+X;M.byteArray&&(M.byteArray[O]=M.getter(c,z))}}}}}}jM.DefaultOutputType=XM.HalfFloat,jM.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class eM{constructor(){this.supportCascades=!1}loadCubeData(M,A,O,S,z){throw".exr not supported in Cube."}loadData(M,A,O){const S=new DataView(M.buffer),Q={value:0},X=o(S,Q);BM(X,S,Q,jM.DefaultOutputType).then((M=>{gM(M,X,S,Q);const z=X.dataWindow.xMax-X.dataWindow.xMin+1,c=X.dataWindow.yMax-X.dataWindow.yMin+1;O(z,c,A.generateMipMaps,!1,(()=>{const O=A.getEngine();A.format=X.format,A.type=M.textureType,A.invertY=!1,A._gammaSpace=!X.linearSpace,M.byteArray&&O._uploadDataToTextureDirectly(A,M.byteArray,0,0,void 0,!0)}))})).catch((M=>{z.c.Error("Failed to load EXR texture: ",M)}))}}async function TM(M){const A=new DataView(M),O={value:0},S=o(A,O);try{const M=await BM(S,A,O,XM.Float);return gM(M,S,A,O),M.byteArray?{width:S.dataWindow.xMax-S.dataWindow.xMin+1,height:S.dataWindow.yMax-S.dataWindow.yMin+1,data:new Float32Array(M.byteArray)}:(z.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(Q){z.c.Error("Failed to load EXR data: ",Q)}return{width:0,height:0,data:null}}},12980:(M,A,O)=>{function S(M){return parseInt(M.toString().replace(/\W/g,""))}function z(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-A)<=O}function Q(M,A,O){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<A-S||M>O+S}function X(M,A){return M===A?M:Math.random()*(A-M)+M}function c(M,A,O){return M+(A-M)*O}function j(M,A,O){let S=d(A-M,360);return S>180&&(S-=360),M+S*T(O)}function B(M,A,O){let S=0;return S=M!=A?T((O-M)/(A-M)):0,S}function g(M,A,O,S,z){const Q=z*z,X=z*Q;return M*(2*X-3*Q+1)+O*(-2*X+3*Q)+A*(X-2*Q+z)+S*(X-Q)}function e(M,A,O,S,z){const Q=z*z;return 6*(Q-z)*M+(3*Q-4*z+1)*A+6*(-Q+z)*O+(3*Q-2*z)*S}function T(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(O,Math.max(A,M))}function J(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function K(M){const A=M.toString(16);return M<=15?("0"+A).toUpperCase():A.toUpperCase()}function G(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let A=0;if(M<1){for(;M<1;)A++,M*=2;A=-A}else if(M>1)for(;M>1;)A++,M=Math.floor(M/2);return A}function d(M,A){return M-Math.floor(M/A)*A}function w(M,A,O){return(M-A)/(O-A)}function I(M,A,O){return M*(O-A)+A}function b(M,A){let O=d(A-M,360);return O>180&&(O-=360),O}function s(M,A){const O=d(M,2*A);return A-Math.abs(O-A)}function Y(M,A,O){let S=T(O);return S=-2*S*S*S+3*S*S,A*S+M*(1-S)}function E(M,A,O){let S=0;return S=Math.abs(A-M)<=O?A:M+Math.sign(A-M)*O,S}function H(M,A,O){const S=b(M,A);let z=0;return z=-O<S&&S<O?A:E(M,A=M+S,O),z}function C(M,A,O){return(M-A)/(O-A)}function f(M,A,O){return(O-A)*M+A}function D(M,A){const O=M%A;return 0===O?A:D(A,O)}O.r(A),O.d(A,{Clamp:()=>T,DeltaAngle:()=>b,Denormalize:()=>I,ExtractAsInt:()=>S,Hermite:()=>g,Hermite1stDerivative:()=>e,HighestCommonFactor:()=>D,ILog2:()=>G,InverseLerp:()=>B,Lerp:()=>c,LerpAngle:()=>j,MoveTowards:()=>E,MoveTowardsAngle:()=>H,Normalize:()=>w,NormalizeRadians:()=>J,OutsideRange:()=>Q,PercentToRange:()=>f,PingPong:()=>s,RandomRange:()=>X,RangeToPercent:()=>C,Repeat:()=>d,SmoothStep:()=>Y,ToHex:()=>K,WithinEpsilon:()=>z})}}]);