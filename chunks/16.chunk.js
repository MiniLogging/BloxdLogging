"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[16],{14871:(M,Z,P)=>{P.r(Z),P.d(Z,{ReadExrDataAsync:()=>OM,_ExrTextureLoader:()=>dM});var x=P(12199),c=P(12387);const w=4,v=4,G=1,mM=2,K=8,d=65536,O=d>>3,H=14,j=65537,B=1<<H,U=B-1,n=59,L=63,u=2+L-n;var N,J;!function(M){M[M.NO_COMPRESSION=0]="NO_COMPRESSION",M[M.RLE_COMPRESSION=1]="RLE_COMPRESSION",M[M.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",M[M.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",M[M.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",M[M.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(N||(N={})),function(M){M[M.INCREASING_Y=0]="INCREASING_Y",M[M.DECREASING_Y=1]="DECREASING_Y"}(J||(J={}));const t=function(){const M=new ArrayBuffer(4),Z=new Float32Array(M),P=new Uint32Array(M),x=new Uint32Array(512),c=new Uint32Array(512);for(let mM=0;mM<256;++mM){const M=mM-127;M<-27?(x[mM]=0,x[256|mM]=32768,c[mM]=24,c[256|mM]=24):M<-14?(x[mM]=1024>>-M-14,x[256|mM]=1024>>-M-14|32768,c[mM]=-M-1,c[256|mM]=-M-1):M<=15?(x[mM]=M+15<<10,x[256|mM]=M+15<<10|32768,c[mM]=13,c[256|mM]=13):M<128?(x[mM]=31744,x[256|mM]=64512,c[mM]=24,c[256|mM]=24):(x[mM]=31744,x[256|mM]=64512,c[mM]=13,c[256|mM]=13)}const w=new Uint32Array(2048),v=new Uint32Array(64),G=new Uint32Array(64);for(let mM=1;mM<1024;++mM){let M=mM<<13,Z=0;for(;0===(8388608&M);)M<<=1,Z-=8388608;M&=-8388609,Z+=947912704,w[mM]=M|Z}for(let mM=1024;mM<2048;++mM)w[mM]=939524096+(mM-1024<<13);for(let mM=1;mM<31;++mM)v[mM]=mM<<23;v[31]=1199570944,v[32]=2147483648;for(let mM=33;mM<63;++mM)v[mM]=2147483648+(mM-32<<23);v[63]=3347054592;for(let mM=1;mM<64;++mM)32!==mM&&(G[mM]=1024);return{floatView:Z,uint32View:P,baseTable:x,shiftTable:c,mantissaTable:w,exponentTable:v,offsetTable:G}}();function F(M,Z){const P=new Uint8Array(M);let x=0;for(;0!=P[Z.value+x];)x+=1;const c=(new TextDecoder).decode(P.slice(Z.value,Z.value+x));return Z.value=Z.value+x+1,c}function D(M,Z){const P=M.getInt32(Z.value,!0);return Z.value+=w,P}function l(M,Z){const P=M.getUint32(Z.value,!0);return Z.value+=w,P}function h(M,Z){const P=M.getUint8(Z.value);return Z.value+=G,P}function Q(M,Z){const P=M.getUint16(Z.value,!0);return Z.value+=mM,P}function I(M,Z){const P=M[Z.value];return Z.value+=G,P}function s(M,Z){let P;return P="getBigInt64"in DataView.prototype?Number(M.getBigInt64(Z.value,!0)):M.getUint32(Z.value+4,!0)+Number(M.getUint32(Z.value,!0)<<32),Z.value+=K,P}function C(M,Z){const P=M.getFloat32(Z.value,!0);return Z.value+=v,P}function R(M,Z){return function(M){const Z=(31744&M)>>10,P=1023&M;return(M>>15?-1:1)*(Z?31===Z?P?NaN:1/0:Math.pow(2,Z-15)*(1+P/1024):P/1024*6103515625e-14)}(Q(M,Z))}function W(M,Z){return function(M){if(Math.abs(M)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");M=(0,c.Clamp)(M,-65504,65504),t.floatView[0]=M;const Z=t.uint32View[0],P=Z>>23&511;return t.baseTable[P]+((8388607&Z)>>t.shiftTable[P])}(C(M,Z))}function k(M,Z,P,x){switch(P){case"string":case"stringvector":case"iccProfile":return function(M,Z,P){const x=(new TextDecoder).decode(new Uint8Array(M).slice(Z.value,Z.value+P));return Z.value=Z.value+P,x}(M.buffer,Z,x);case"chlist":return function(M,Z,P){const x=Z.value,c=[];for(;Z.value<x+P-1;){const P=F(M.buffer,Z),x=D(M,Z),w=h(M,Z);Z.value+=3;const v=D(M,Z),G=D(M,Z);c.push({name:P,pixelType:x,pLinear:w,xSampling:v,ySampling:G})}return Z.value+=1,c}(M,Z,x);case"chromaticities":return function(M,Z){return{redX:C(M,Z),redY:C(M,Z),greenX:C(M,Z),greenY:C(M,Z),blueX:C(M,Z),blueY:C(M,Z),whiteX:C(M,Z),whiteY:C(M,Z)}}(M,Z);case"compression":return function(M,Z){return h(M,Z)}(M,Z);case"box2i":return function(M,Z){return{xMin:D(M,Z),yMin:D(M,Z),xMax:D(M,Z),yMax:D(M,Z)}}(M,Z);case"lineOrder":return function(M,Z){const P=h(M,Z);return J[P]}(M,Z);case"float":return C(M,Z);case"v2f":return function(M,Z){return[C(M,Z),C(M,Z)]}(M,Z);case"v3f":return function(M,Z){return[C(M,Z),C(M,Z),C(M,Z)]}(M,Z);case"int":return D(M,Z);case"rational":return function(M,Z){return[D(M,Z),l(M,Z)]}(M,Z);case"timecode":return function(M,Z){return[l(M,Z),l(M,Z)]}(M,Z);case"preview":return Z.value+=x,"skipped";default:return void(Z.value+=x)}}function A(M){for(let Z=1;Z<M.length;Z++){const P=M[Z-1]+M[Z]-128;M[Z]=P}}function o(M,Z){let P=0,x=Math.floor((M.length+1)/2),c=0;const w=M.length-1;for(;!(c>w)&&(Z[c++]=M[P++],!(c>w));)Z[c++]=M[x++]}const E=20000630;function r(M,Z){if(M.getUint32(0,!0)!=E)throw new Error("Incorrect OpenEXR format");const P=M.getUint8(4),c=M.getUint8(5),w={singleTile:!!(2&c),longName:!!(4&c),deepFormat:!!(8&c),multiPart:!!(16&c)};Z.value=8;const v={};let G=!0;for(;G;){const P=F(M.buffer,Z);if(P){const c=F(M.buffer,Z),w=k(M,Z,c,l(M,Z));void 0===w?x.d.Warn(`Unknown header attribute type ${c}'.`):v[P]=w}else G=!1}if(0!=(-5&c))throw new Error("Unsupported file format");return{version:P,spec:w,...v}}const q=32768,e=65535;function b(M,Z,P,x,c){for(;P<M;)Z=Z<<8|I(x,c),P+=8;return{l:Z>>(P-=M)&(1<<M)-1,c:Z,lc:P}}function a(M,Z,P,x){return{c:M=M<<8|I(P,x),lc:Z+=8}}function y(M,Z,P,x,c,w,v,G,mM){if(M==Z){if(x<8){const M=a(P,x,c,w);P=M.c,x=M.lc}let M=P>>(x-=8);if(M=new Uint8Array([M])[0],G.value+M>mM)return null;const Z=v[G.value-1];for(;M-- >0;)v[G.value++]=Z}else{if(!(G.value<mM))return null;v[G.value++]=M}return{c:P,lc:x}}const f=new Array(59);function Y(M,Z,P,x,c,w){const v=Z;let G=0,mM=0;for(;x<=c;x++){if(v.value-Z.value>P)return;let K=b(6,G,mM,M,v);const d=K.l;if(G=K.c,mM=K.lc,w[x]=d,d==L){if(v.value-Z.value>P)throw new Error("Error in HufUnpackEncTable");K=b(8,G,mM,M,v);let d=K.l+u;if(G=K.c,mM=K.lc,x+d>c+1)throw new Error("Error in HufUnpackEncTable");for(;d--;)w[x++]=0;x--}else if(d>=n){let M=d-n+2;if(x+M>c+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)w[x++]=0;x--}}!function(M){for(let P=0;P<=58;++P)f[P]=0;for(let P=0;P<j;++P)f[M[P]]+=1;let Z=0;for(let P=58;P>0;--P){const M=Z+f[P]>>1;f[P]=Z,Z=M}for(let P=0;P<j;++P){const Z=M[P];Z>0&&(M[P]=Z|f[Z]++<<6)}}(w)}function z(M){return 63&M}function i(M){return M>>6}function T(M,Z,P,x,c,w){const v=P.value,G=l(Z,P),mM=l(Z,P);P.value+=4;const K=l(Z,P);if(P.value+=4,G<0||G>=j||mM<0||mM>=j)throw new Error("Wrong HUF_ENCSIZE");const d=new Array(j),O=new Array(B);!function(M){for(let Z=0;Z<B;Z++)M[Z]={},M[Z].len=0,M[Z].lit=0,M[Z].p=null}(O);if(Y(M,P,x-(P.value-v),G,mM,d),K>8*(x-(P.value-v)))throw new Error("Wrong hufUncompress");!function(M,Z,P,x){for(;Z<=P;Z++){const P=i(M[Z]),c=z(M[Z]);if(P>>c)throw new Error("Invalid table entry");if(c>H){const M=x[P>>c-H];if(M.len)throw new Error("Invalid table entry");if(M.lit++,M.p){const Z=M.p;M.p=new Array(M.lit);for(let P=0;P<M.lit-1;++P)M.p[P]=Z[P]}else M.p=new Array(1);M.p[M.lit-1]=Z}else if(c){let M=0;for(let w=1<<H-c;w>0;w--){const w=x[(P<<H-c)+M];if(w.len||w.p)throw new Error("Invalid table entry");w.len=c,w.lit=Z,M++}}}}(d,G,mM,O),function(M,Z,P,x,c,w,v,G,mM){let K=0,d=0;const O=v,j=Math.trunc(x.value+(c+7)/8);for(;x.value<j;){let c=a(K,d,P,x);for(K=c.c,d=c.lc;d>=H;){const v=Z[K>>d-H&U];if(v.len){d-=v.len;const M=y(v.lit,w,K,d,P,x,G,mM,O);M&&(K=M.c,d=M.lc)}else{if(!v.p)throw new Error("hufDecode issues");let Z;for(Z=0;Z<v.lit;Z++){const H=z(M[v.p[Z]]);for(;d<H&&x.value<j;)c=a(K,d,P,x),K=c.c,d=c.lc;if(d>=H&&i(M[v.p[Z]])==(K>>d-H&(1<<H)-1)){d-=H;const M=y(v.p[Z],w,K,d,P,x,G,mM,O);M&&(K=M.c,d=M.lc);break}}if(Z==v.lit)throw new Error("HufDecode issues")}}}const B=8-c&7;for(K>>=B,d-=B;d>0;){const M=Z[K<<H-d&U];if(!M.len)throw new Error("HufDecode issues");{d-=M.len;const Z=y(M.lit,w,K,d,P,x,G,mM,O);Z&&(K=Z.c,d=Z.lc)}}}(d,O,M,P,K,mM,w,c,{value:0})}function p(M){return 65535&M}function S(M){const Z=p(M);return Z>32767?Z-65536:Z}function X(M,Z){const P=S(M),x=S(Z),c=P+(1&x)+(x>>1);return{a:c,b:c-x}}function V(M,Z){const P=p(M),x=p(Z),c=P-(x>>1)&e;return{a:x+c-q&e,b:c}}function g(M,Z,P,x,c,w,v){const G=v<16384,mM=P>c?c:P;let K,d,O=1;for(;O<=mM;)O<<=1;for(O>>=1,K=O,O>>=1;O>=1;){d=0;const v=d+w*(c-K),mM=w*O,H=w*K,j=x*O,B=x*K;let U,n,L,u;for(;d<=v;d+=H){let c=d;const w=d+x*(P-K);for(;c<=w;c+=B){const P=c+j,x=c+mM,w=x+j;if(G){let v=X(M[c+Z],M[x+Z]);U=v.a,L=v.b,v=X(M[P+Z],M[w+Z]),n=v.a,u=v.b,v=X(U,n),M[c+Z]=v.a,M[P+Z]=v.b,v=X(L,u),M[x+Z]=v.a,M[w+Z]=v.b}else{let v=V(M[c+Z],M[x+Z]);U=v.a,L=v.b,v=V(M[P+Z],M[w+Z]),n=v.a,u=v.b,v=V(U,n),M[c+Z]=v.a,M[P+Z]=v.b,v=V(L,u),M[x+Z]=v.a,M[w+Z]=v.b}}if(P&O){const P=c+mM;let x;x=G?X(M[c+Z],M[P+Z]):V(M[c+Z],M[P+Z]),U=x.a,M[P+Z]=x.b,M[c+Z]=U}}if(c&O){let c=d;const w=d+x*(P-K);for(;c<=w;c+=B){const P=c+j;let x;x=G?X(M[c+Z],M[P+Z]):V(M[c+Z],M[P+Z]),U=x.a,M[P+Z]=x.b,M[c+Z]=U}}K=O,O>>=1}return d}function MM(M){return new DataView(M.array.buffer,M.offset.value,M.size)}function ZM(M){const Z=M.viewer.buffer.slice(M.offset.value,M.offset.value+M.size),P=new Uint8Array(function(M){let Z=M.byteLength;const P=[];let x=0;const c=new DataView(M);for(;Z>0;){const M=c.getInt8(x++);if(M<0){const w=-M;Z-=w+1;for(let M=0;M<w;M++)P.push(c.getUint8(x++))}else{const w=M;Z-=2;const v=c.getUint8(x++);for(let M=0;M<w+1;M++)P.push(v)}}return P}(Z)),x=new Uint8Array(P.length);return A(P),o(P,x),new DataView(x.buffer)}function PM(M){const Z=M.array.slice(M.offset.value,M.offset.value+M.size),P=fflate.unzlibSync(Z),x=new Uint8Array(P.length);return A(P),o(P,x),new DataView(x.buffer)}function xM(M){const Z=M.array.slice(M.offset.value,M.offset.value+M.size),P=fflate.unzlibSync(Z),x=M.lines*M.channels*M.width,c=1==M.type?new Uint16Array(x):new Uint32Array(x);let w=0,v=0;const G=new Array(4);for(let mM=0;mM<M.lines;mM++)for(let Z=0;Z<M.channels;Z++){let Z=0;switch(M.type){case 1:G[0]=w,G[1]=G[0]+M.width,w=G[1]+M.width;for(let x=0;x<M.width;++x){Z+=P[G[0]++]<<8|P[G[1]++],c[v]=Z,v++}break;case 2:G[0]=w,G[1]=G[0]+M.width,G[2]=G[1]+M.width,w=G[2]+M.width;for(let x=0;x<M.width;++x){Z+=P[G[0]++]<<24|P[G[1]++]<<16|P[G[2]++]<<8,c[v]=Z,v++}}}return new DataView(c.buffer)}function cM(M){const Z=M.viewer,P={value:M.offset.value},x=new Uint16Array(M.width*M.scanlineBlockSize*(M.channels*M.type)),c=new Uint8Array(O);let w=0;const v=new Array(M.channels);for(let mM=0;mM<M.channels;mM++)v[mM]={},v[mM].start=w,v[mM].end=v[mM].start,v[mM].nx=M.width,v[mM].ny=M.lines,v[mM].size=M.type,w+=v[mM].nx*v[mM].ny*v[mM].size;const G=Q(Z,P),K=Q(Z,P);if(K>=O)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(G<=K)for(let mM=0;mM<K-G+1;mM++)c[mM+G]=h(Z,P);const H=new Uint16Array(d),j=function(M,Z){let P=0;for(let c=0;c<d;++c)(0==c||M[c>>3]&1<<(7&c))&&(Z[P++]=c);const x=P-1;for(;P<d;)Z[P++]=0;return x}(c,H),B=l(Z,P);T(M.array,Z,P,B,x,w);for(let mM=0;mM<M.channels;++mM){const M=v[mM];for(let Z=0;Z<v[mM].size;++Z)g(x,M.start+Z,M.nx,M.size,M.ny,M.nx*M.size,j)}!function(M,Z,P){for(let x=0;x<P;++x)Z[x]=M[Z[x]]}(H,x,w);let U=0;const n=new Uint8Array(x.buffer.byteLength);for(let d=0;d<M.lines;d++)for(let Z=0;Z<M.channels;Z++){const M=v[Z],P=M.nx*M.size,c=new Uint8Array(x.buffer,M.end*mM,P*mM);n.set(c,U),U+=P*mM,M.end+=P}return new DataView(n.buffer)}var wM,vM=P(12175);!function(M){M[M.Float=0]="Float",M[M.HalfFloat=1]="HalfFloat"}(wM||(wM={}));class GM{}async function mZ(M,Z,P,x){const c={size:0,viewer:Z,array:new Uint8Array(Z.buffer),offset:P,width:M.dataWindow.xMax-M.dataWindow.xMin+1,height:M.dataWindow.yMax-M.dataWindow.yMin+1,channels:M.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(M.compression){case N.NO_COMPRESSION:c.lines=1,c.uncompress=MM;break;case N.RLE_COMPRESSION:c.lines=1,c.uncompress=ZM;break;case N.ZIPS_COMPRESSION:c.lines=1,c.uncompress=PM,await vM.Tools.LoadScriptAsync(GM.FFLATEUrl);break;case N.ZIP_COMPRESSION:c.lines=16,c.uncompress=PM,await vM.Tools.LoadScriptAsync(GM.FFLATEUrl);break;case N.PIZ_COMPRESSION:c.lines=32,c.uncompress=cM;break;case N.PXR24_COMPRESSION:c.lines=16,c.uncompress=xM,await vM.Tools.LoadScriptAsync(GM.FFLATEUrl);break;default:throw new Error(N[M.compression]+" is unsupported")}c.scanlineBlockSize=c.lines;const w={};for(const v of M.channels)switch(v.name){case"R":case"G":case"B":case"A":case"Y":w[v.name]=!0,c.type=v.pixelType}let G=!1;if(w.R&&w.G&&w.B&&w.A)c.outputChannels=4,c.decodeChannels={R:0,G:1,B:2,A:3};else if(w.R&&w.G&&w.B)G=!0,c.outputChannels=4,c.decodeChannels={R:0,G:1,B:2,A:3};else if(w.R&&w.G)c.outputChannels=2,c.decodeChannels={R:0,G:1};else if(w.R)c.outputChannels=1,c.decodeChannels={R:0};else{if(!w.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");c.outputChannels=1,c.decodeChannels={Y:0}}if(1===c.type)switch(x){case wM.Float:c.getter=R,c.inputSize=mM;break;case wM.HalfFloat:c.getter=Q,c.inputSize=mM}else{if(2!==c.type)throw new Error("Unsupported pixelType "+c.type+" for "+M.compression);switch(x){case wM.Float:c.getter=C,c.inputSize=v;break;case wM.HalfFloat:c.getter=W,c.inputSize=v}}c.blockCount=c.height/c.scanlineBlockSize;for(let v=0;v<c.blockCount;v++)s(Z,P);const K=c.width*c.height*c.outputChannels;switch(x){case wM.Float:c.byteArray=new Float32Array(K),c.textureType=1,G&&c.byteArray.fill(1,0,K);break;case wM.HalfFloat:c.byteArray=new Uint16Array(K),c.textureType=2,G&&c.byteArray.fill(15360,0,K);break;default:throw new Error("Unsupported type: "+x)}let d=0;for(const v of M.channels)void 0!==c.decodeChannels[v.name]&&(c.channelLineOffsets[v.name]=d*c.width),d+=2*v.pixelType;return c.bytesPerLine=c.width*d,c.outLineWidth=c.width*c.outputChannels,"INCREASING_Y"===M.lineOrder?c.scanOrder=M=>M:c.scanOrder=M=>c.height-1-M,4==c.outputChannels?(c.format=5,c.linearSpace=!0):(c.format=6,c.linearSpace=!1),c}function KM(M,Z,P,x){const c={value:0};for(let w=0;w<M.height/M.scanlineBlockSize;w++){const v=D(P,x)-Z.dataWindow.yMin;M.size=l(P,x),M.lines=v+M.scanlineBlockSize>M.height?M.height-v:M.scanlineBlockSize;const G=M.size<M.lines*M.bytesPerLine&&M.uncompress?M.uncompress(M):MM(M);x.value+=M.size;for(let P=0;P<M.scanlineBlockSize;P++){const x=w*M.scanlineBlockSize,v=P+M.scanOrder(x);if(v>=M.height)continue;const mM=P*M.bytesPerLine,K=(M.height-1-v)*M.outLineWidth;for(let P=0;P<M.channels;P++){const x=Z.channels[P].name,w=M.channelLineOffsets[x],v=M.decodeChannels[x];if(void 0!==v){c.value=mM+w;for(let Z=0;Z<M.width;Z++){const P=K+Z*M.outputChannels+v;M.byteArray&&(M.byteArray[P]=M.getter(G,c))}}}}}}GM.DefaultOutputType=wM.HalfFloat,GM.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class dM{constructor(){this.supportCascades=!1}loadCubeData(M,Z,P,x,c){throw".exr not supported in Cube."}loadData(M,Z,P){const c=new DataView(M.buffer),w={value:0},v=r(c,w);mZ(v,c,w,GM.DefaultOutputType).then((M=>{KM(M,v,c,w);const x=v.dataWindow.xMax-v.dataWindow.xMin+1,G=v.dataWindow.yMax-v.dataWindow.yMin+1;P(x,G,Z.generateMipMaps,!1,(()=>{const P=Z.getEngine();Z.format=v.format,Z.type=M.textureType,Z.invertY=!1,Z._gammaSpace=!v.linearSpace,M.byteArray&&P._uploadDataToTextureDirectly(Z,M.byteArray,0,0,void 0,!0)}))})).catch((M=>{x.d.Error("Failed to load EXR texture: ",M)}))}}async function OM(M){const Z=new DataView(M),P={value:0},c=r(Z,P);try{const M=await mZ(c,Z,P,wM.Float);return KM(M,c,Z,P),M.byteArray?{width:c.dataWindow.xMax-c.dataWindow.xMin+1,height:c.dataWindow.yMax-c.dataWindow.yMin+1,data:new Float32Array(M.byteArray)}:(x.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(w){x.d.Error("Failed to load EXR data: ",w)}return{width:0,height:0,data:null}}},12387:(M,Z,P)=>{function x(M){return parseInt(M.toString().replace(/\W/g,""))}function c(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(M-Z)<=P}function w(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return M<Z-x||M>P+x}function v(M,Z){return M===Z?M:Math.random()*(Z-M)+M}function G(M,Z,P){return M+(Z-M)*P}function mM(M,Z,P){let x=n(Z-M,360);return x>180&&(x-=360),M+x*H(P)}function K(M,Z,P){let x=0;return x=M!=Z?H((P-M)/(Z-M)):0,x}function d(M,Z,P,x,c){const w=c*c,v=c*w;return M*(2*v-3*w+1)+P*(-2*v+3*w)+Z*(v-2*w+c)+x*(v-w)}function O(M,Z,P,x,c){const w=c*c;return 6*(w-c)*M+(3*w-4*c+1)*Z+6*(-w+c)*P+(3*w-2*c)*x}function H(M){let Z=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(P,Math.max(Z,M))}function j(M){return M-=2*Math.PI*Math.floor((M+Math.PI)/(2*Math.PI))}function B(M){const Z=M.toString(16);return M<=15?("0"+Z).toUpperCase():Z.toUpperCase()}function U(M){if(Math.log2)return Math.floor(Math.log2(M));if(M<0)return NaN;if(0===M)return-1/0;let Z=0;if(M<1){for(;M<1;)Z++,M*=2;Z=-Z}else if(M>1)for(;M>1;)Z++,M=Math.floor(M/2);return Z}function n(M,Z){return M-Math.floor(M/Z)*Z}function L(M,Z,P){return(M-Z)/(P-Z)}function u(M,Z,P){return M*(P-Z)+Z}function N(M,Z){let P=n(Z-M,360);return P>180&&(P-=360),P}function J(M,Z){const P=n(M,2*Z);return Z-Math.abs(P-Z)}function t(M,Z,P){let x=H(P);return x=-2*x*x*x+3*x*x,Z*x+M*(1-x)}function F(M,Z,P){let x=0;return x=Math.abs(Z-M)<=P?Z:M+Math.sign(Z-M)*P,x}function D(M,Z,P){const x=N(M,Z);let c=0;return c=-P<x&&x<P?Z:F(M,Z=M+x,P),c}function l(M,Z,P){return(M-Z)/(P-Z)}function h(M,Z,P){return(P-Z)*M+Z}function Q(M,Z){const P=M%Z;return 0===P?Z:Q(Z,P)}P.r(Z),P.d(Z,{Clamp:()=>H,DeltaAngle:()=>N,Denormalize:()=>u,ExtractAsInt:()=>x,Hermite:()=>d,Hermite1stDerivative:()=>O,HighestCommonFactor:()=>Q,ILog2:()=>U,InverseLerp:()=>K,Lerp:()=>G,LerpAngle:()=>mM,MoveTowards:()=>F,MoveTowardsAngle:()=>D,Normalize:()=>L,NormalizeRadians:()=>j,OutsideRange:()=>w,PercentToRange:()=>h,PingPong:()=>J,RandomRange:()=>v,RangeToPercent:()=>l,Repeat:()=>n,SmoothStep:()=>t,ToHex:()=>B,WithinEpsilon:()=>c})}}]);