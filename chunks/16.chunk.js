"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[16],{15168:(K,A,T)=>{T.r(A),T.d(A,{ReadExrDataAsync:()=>ZK,_ExrTextureLoader:()=>YK});var G=T(12548),B=T(12716);const L=4,f=4,O=1,C=2,Q=8,Y=65536,Z=Y>>3,x=14,J=65537,b=1<<x,P=b-1,F=59,d=63,N=2+d-F;var D,mK;!function(K){K[K.NO_COMPRESSION=0]="NO_COMPRESSION",K[K.RLE_COMPRESSION=1]="RLE_COMPRESSION",K[K.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",K[K.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",K[K.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",K[K.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(D||(D={})),function(K){K[K.INCREASING_Y=0]="INCREASING_Y",K[K.DECREASING_Y=1]="DECREASING_Y"}(mK||(mK={}));const U=function(){const K=new ArrayBuffer(4),A=new Float32Array(K),T=new Uint32Array(K),G=new Uint32Array(512),B=new Uint32Array(512);for(let C=0;C<256;++C){const K=C-127;K<-27?(G[C]=0,G[256|C]=32768,B[C]=24,B[256|C]=24):K<-14?(G[C]=1024>>-K-14,G[256|C]=1024>>-K-14|32768,B[C]=-K-1,B[256|C]=-K-1):K<=15?(G[C]=K+15<<10,G[256|C]=K+15<<10|32768,B[C]=13,B[256|C]=13):K<128?(G[C]=31744,G[256|C]=64512,B[C]=24,B[256|C]=24):(G[C]=31744,G[256|C]=64512,B[C]=13,B[256|C]=13)}const L=new Uint32Array(2048),f=new Uint32Array(64),O=new Uint32Array(64);for(let C=1;C<1024;++C){let K=C<<13,A=0;for(;0===(8388608&K);)K<<=1,A-=8388608;K&=-8388609,A+=947912704,L[C]=K|A}for(let C=1024;C<2048;++C)L[C]=939524096+(C-1024<<13);for(let C=1;C<31;++C)f[C]=C<<23;f[31]=1199570944,f[32]=2147483648;for(let C=33;C<63;++C)f[C]=2147483648+(C-32<<23);f[63]=3347054592;for(let C=1;C<64;++C)32!==C&&(O[C]=1024);return{floatView:A,uint32View:T,baseTable:G,shiftTable:B,mantissaTable:L,exponentTable:f,offsetTable:O}}();function z(K,A){const T=new Uint8Array(K);let G=0;for(;0!=T[A.value+G];)G+=1;const B=(new TextDecoder).decode(T.slice(A.value,A.value+G));return A.value=A.value+G+1,B}function g(K,A){const T=K.getInt32(A.value,!0);return A.value+=L,T}function S(K,A){const T=K.getUint32(A.value,!0);return A.value+=L,T}function l(K,A){const T=K.getUint8(A.value);return A.value+=O,T}function u(K,A){const T=K.getUint16(A.value,!0);return A.value+=C,T}function c(K,A){const T=K[A.value];return A.value+=O,T}function n(K,A){let T;return T="getBigInt64"in DataView.prototype?Number(K.getBigInt64(A.value,!0)):K.getUint32(A.value+4,!0)+Number(K.getUint32(A.value,!0)<<32),A.value+=Q,T}function H(K,A){const T=K.getFloat32(A.value,!0);return A.value+=f,T}function e(K,A){return function(K){const A=(31744&K)>>10,T=1023&K;return(K>>15?-1:1)*(A?31===A?T?NaN:1/0:Math.pow(2,A-15)*(1+T/1024):T/1024*6103515625e-14)}(u(K,A))}function p(K,A){return function(K){if(Math.abs(K)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");K=(0,B.Clamp)(K,-65504,65504),U.floatView[0]=K;const A=U.uint32View[0],T=A>>23&511;return U.baseTable[T]+((8388607&A)>>U.shiftTable[T])}(H(K,A))}function r(K,A,T,G){switch(T){case"string":case"stringvector":case"iccProfile":return function(K,A,T){const G=(new TextDecoder).decode(new Uint8Array(K).slice(A.value,A.value+T));return A.value=A.value+T,G}(K.buffer,A,G);case"chlist":return function(K,A,T){const G=A.value,B=[];for(;A.value<G+T-1;){const T=z(K.buffer,A),G=g(K,A),L=l(K,A);A.value+=3;const f=g(K,A),O=g(K,A);B.push({name:T,pixelType:G,pLinear:L,xSampling:f,ySampling:O})}return A.value+=1,B}(K,A,G);case"chromaticities":return function(K,A){return{redX:H(K,A),redY:H(K,A),greenX:H(K,A),greenY:H(K,A),blueX:H(K,A),blueY:H(K,A),whiteX:H(K,A),whiteY:H(K,A)}}(K,A);case"compression":return function(K,A){return l(K,A)}(K,A);case"box2i":return function(K,A){return{xMin:g(K,A),yMin:g(K,A),xMax:g(K,A),yMax:g(K,A)}}(K,A);case"lineOrder":return function(K,A){const T=l(K,A);return mK[T]}(K,A);case"float":return H(K,A);case"v2f":return function(K,A){return[H(K,A),H(K,A)]}(K,A);case"v3f":return function(K,A){return[H(K,A),H(K,A),H(K,A)]}(K,A);case"int":return g(K,A);case"rational":return function(K,A){return[g(K,A),S(K,A)]}(K,A);case"timecode":return function(K,A){return[S(K,A),S(K,A)]}(K,A);case"preview":return A.value+=G,"skipped";default:return void(A.value+=G)}}function h(K){for(let A=1;A<K.length;A++){const T=K[A-1]+K[A]-128;K[A]=T}}function k(K,A){let T=0,G=Math.floor((K.length+1)/2),B=0;const L=K.length-1;for(;!(B>L)&&(A[B++]=K[T++],!(B>L));)A[B++]=K[G++]}const s=20000630;function j(K,A){if(K.getUint32(0,!0)!=s)throw new Error("Incorrect OpenEXR format");const T=K.getUint8(4),B=K.getUint8(5),L={singleTile:!!(2&B),longName:!!(4&B),deepFormat:!!(8&B),multiPart:!!(16&B)};A.value=8;const f={};let O=!0;for(;O;){const T=z(K.buffer,A);if(T){const B=z(K.buffer,A),L=r(K,A,B,S(K,A));void 0===L?G.d.Warn(`Unknown header attribute type ${B}'.`):f[T]=L}else O=!1}if(0!=(-5&B))throw new Error("Unsupported file format");return{version:T,spec:L,...f}}const R=32768,v=65535;function I(K,A,T,G,B){for(;T<K;)A=A<<8|c(G,B),T+=8;return{l:A>>(T-=K)&(1<<K)-1,c:A,lc:T}}function o(K,A,T,G){return{c:K=K<<8|c(T,G),lc:A+=8}}function W(K,A,T,G,B,L,f,O,C){if(K==A){if(G<8){const K=o(T,G,B,L);T=K.c,G=K.lc}let K=T>>(G-=8);if(K=new Uint8Array([K])[0],O.value+K>C)return null;const A=f[O.value-1];for(;K-- >0;)f[O.value++]=A}else{if(!(O.value<C))return null;f[O.value++]=K}return{c:T,lc:G}}const i=new Array(59);function V(K,A,T,G,B,L){const f=A;let O=0,C=0;for(;G<=B;G++){if(f.value-A.value>T)return;let Q=I(6,O,C,K,f);const Y=Q.l;if(O=Q.c,C=Q.lc,L[G]=Y,Y==d){if(f.value-A.value>T)throw new Error("Error in HufUnpackEncTable");Q=I(8,O,C,K,f);let Y=Q.l+N;if(O=Q.c,C=Q.lc,G+Y>B+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)L[G++]=0;G--}else if(Y>=F){let K=Y-F+2;if(G+K>B+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)L[G++]=0;G--}}!function(K){for(let T=0;T<=58;++T)i[T]=0;for(let T=0;T<J;++T)i[K[T]]+=1;let A=0;for(let T=58;T>0;--T){const K=A+i[T]>>1;i[T]=A,A=K}for(let T=0;T<J;++T){const A=K[T];A>0&&(K[T]=A|i[A]++<<6)}}(L)}function X(K){return 63&K}function q(K){return K>>6}function y(K,A,T,G,B,L){const f=T.value,O=S(A,T),C=S(A,T);T.value+=4;const Q=S(A,T);if(T.value+=4,O<0||O>=J||C<0||C>=J)throw new Error("Wrong HUF_ENCSIZE");const Y=new Array(J),Z=new Array(b);!function(K){for(let A=0;A<b;A++)K[A]={},K[A].len=0,K[A].lit=0,K[A].p=null}(Z);if(V(K,T,G-(T.value-f),O,C,Y),Q>8*(G-(T.value-f)))throw new Error("Wrong hufUncompress");!function(K,A,T,G){for(;A<=T;A++){const T=q(K[A]),B=X(K[A]);if(T>>B)throw new Error("Invalid table entry");if(B>x){const K=G[T>>B-x];if(K.len)throw new Error("Invalid table entry");if(K.lit++,K.p){const A=K.p;K.p=new Array(K.lit);for(let T=0;T<K.lit-1;++T)K.p[T]=A[T]}else K.p=new Array(1);K.p[K.lit-1]=A}else if(B){let K=0;for(let L=1<<x-B;L>0;L--){const L=G[(T<<x-B)+K];if(L.len||L.p)throw new Error("Invalid table entry");L.len=B,L.lit=A,K++}}}}(Y,O,C,Z),function(K,A,T,G,B,L,f,O,C){let Q=0,Y=0;const Z=f,J=Math.trunc(G.value+(B+7)/8);for(;G.value<J;){let B=o(Q,Y,T,G);for(Q=B.c,Y=B.lc;Y>=x;){const f=A[Q>>Y-x&P];if(f.len){Y-=f.len;const K=W(f.lit,L,Q,Y,T,G,O,C,Z);K&&(Q=K.c,Y=K.lc)}else{if(!f.p)throw new Error("hufDecode issues");let A;for(A=0;A<f.lit;A++){const x=X(K[f.p[A]]);for(;Y<x&&G.value<J;)B=o(Q,Y,T,G),Q=B.c,Y=B.lc;if(Y>=x&&q(K[f.p[A]])==(Q>>Y-x&(1<<x)-1)){Y-=x;const K=W(f.p[A],L,Q,Y,T,G,O,C,Z);K&&(Q=K.c,Y=K.lc);break}}if(A==f.lit)throw new Error("HufDecode issues")}}}const b=8-B&7;for(Q>>=b,Y-=b;Y>0;){const K=A[Q<<x-Y&P];if(!K.len)throw new Error("HufDecode issues");{Y-=K.len;const A=W(K.lit,L,Q,Y,T,G,O,C,Z);A&&(Q=A.c,Y=A.lc)}}}(Y,Z,K,T,Q,C,L,B,{value:0})}function w(K){return 65535&K}function a(K){const A=w(K);return A>32767?A-65536:A}function M(K,A){const T=a(K),G=a(A),B=T+(1&G)+(G>>1);return{a:B,b:B-G}}function E(K,A){const T=w(K),G=w(A),B=T-(G>>1)&v;return{a:G+B-R&v,b:B}}function t(K,A,T,G,B,L,f){const O=f<16384,C=T>B?B:T;let Q,Y,Z=1;for(;Z<=C;)Z<<=1;for(Z>>=1,Q=Z,Z>>=1;Z>=1;){Y=0;const f=Y+L*(B-Q),C=L*Z,x=L*Q,J=G*Z,b=G*Q;let P,F,d,N;for(;Y<=f;Y+=x){let B=Y;const L=Y+G*(T-Q);for(;B<=L;B+=b){const T=B+J,G=B+C,L=G+J;if(O){let f=M(K[B+A],K[G+A]);P=f.a,d=f.b,f=M(K[T+A],K[L+A]),F=f.a,N=f.b,f=M(P,F),K[B+A]=f.a,K[T+A]=f.b,f=M(d,N),K[G+A]=f.a,K[L+A]=f.b}else{let f=E(K[B+A],K[G+A]);P=f.a,d=f.b,f=E(K[T+A],K[L+A]),F=f.a,N=f.b,f=E(P,F),K[B+A]=f.a,K[T+A]=f.b,f=E(d,N),K[G+A]=f.a,K[L+A]=f.b}}if(T&Z){const T=B+C;let G;G=O?M(K[B+A],K[T+A]):E(K[B+A],K[T+A]),P=G.a,K[T+A]=G.b,K[B+A]=P}}if(B&Z){let B=Y;const L=Y+G*(T-Q);for(;B<=L;B+=b){const T=B+J;let G;G=O?M(K[B+A],K[T+A]):E(K[B+A],K[T+A]),P=G.a,K[T+A]=G.b,K[B+A]=P}}Q=Z,Z>>=1}return Y}function KK(K){return new DataView(K.array.buffer,K.offset.value,K.size)}function AK(K){const A=K.viewer.buffer.slice(K.offset.value,K.offset.value+K.size),T=new Uint8Array(function(K){let A=K.byteLength;const T=[];let G=0;const B=new DataView(K);for(;A>0;){const K=B.getInt8(G++);if(K<0){const L=-K;A-=L+1;for(let K=0;K<L;K++)T.push(B.getUint8(G++))}else{const L=K;A-=2;const f=B.getUint8(G++);for(let K=0;K<L+1;K++)T.push(f)}}return T}(A)),G=new Uint8Array(T.length);return h(T),k(T,G),new DataView(G.buffer)}function TK(K){const A=K.array.slice(K.offset.value,K.offset.value+K.size),T=fflate.unzlibSync(A),G=new Uint8Array(T.length);return h(T),k(T,G),new DataView(G.buffer)}function GK(K){const A=K.array.slice(K.offset.value,K.offset.value+K.size),T=fflate.unzlibSync(A),G=K.lines*K.channels*K.width,B=1==K.type?new Uint16Array(G):new Uint32Array(G);let L=0,f=0;const O=new Array(4);for(let C=0;C<K.lines;C++)for(let A=0;A<K.channels;A++){let A=0;switch(K.type){case 1:O[0]=L,O[1]=O[0]+K.width,L=O[1]+K.width;for(let G=0;G<K.width;++G){A+=T[O[0]++]<<8|T[O[1]++],B[f]=A,f++}break;case 2:O[0]=L,O[1]=O[0]+K.width,O[2]=O[1]+K.width,L=O[2]+K.width;for(let G=0;G<K.width;++G){A+=T[O[0]++]<<24|T[O[1]++]<<16|T[O[2]++]<<8,B[f]=A,f++}}}return new DataView(B.buffer)}function BK(K){const A=K.viewer,T={value:K.offset.value},G=new Uint16Array(K.width*K.scanlineBlockSize*(K.channels*K.type)),B=new Uint8Array(Z);let L=0;const f=new Array(K.channels);for(let C=0;C<K.channels;C++)f[C]={},f[C].start=L,f[C].end=f[C].start,f[C].nx=K.width,f[C].ny=K.lines,f[C].size=K.type,L+=f[C].nx*f[C].ny*f[C].size;const O=u(A,T),Q=u(A,T);if(Q>=Z)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(O<=Q)for(let C=0;C<Q-O+1;C++)B[C+O]=l(A,T);const x=new Uint16Array(Y),J=function(K,A){let T=0;for(let B=0;B<Y;++B)(0==B||K[B>>3]&1<<(7&B))&&(A[T++]=B);const G=T-1;for(;T<Y;)A[T++]=0;return G}(B,x),b=S(A,T);y(K.array,A,T,b,G,L);for(let C=0;C<K.channels;++C){const K=f[C];for(let A=0;A<f[C].size;++A)t(G,K.start+A,K.nx,K.size,K.ny,K.nx*K.size,J)}!function(K,A,T){for(let G=0;G<T;++G)A[G]=K[A[G]]}(x,G,L);let P=0;const F=new Uint8Array(G.buffer.byteLength);for(let Y=0;Y<K.lines;Y++)for(let A=0;A<K.channels;A++){const K=f[A],T=K.nx*K.size,B=new Uint8Array(G.buffer,K.end*C,T*C);F.set(B,P),P+=T*C,K.end+=T}return new DataView(F.buffer)}var LK,fK=T(12526);!function(K){K[K.Float=0]="Float",K[K.HalfFloat=1]="HalfFloat"}(LK||(LK={}));class OK{}async function CK(K,A,T,G){const B={size:0,viewer:A,array:new Uint8Array(A.buffer),offset:T,width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,channels:K.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(K.compression){case D.NO_COMPRESSION:B.lines=1,B.uncompress=KK;break;case D.RLE_COMPRESSION:B.lines=1,B.uncompress=AK;break;case D.ZIPS_COMPRESSION:B.lines=1,B.uncompress=TK,await fK.Tools.LoadScriptAsync(OK.FFLATEUrl);break;case D.ZIP_COMPRESSION:B.lines=16,B.uncompress=TK,await fK.Tools.LoadScriptAsync(OK.FFLATEUrl);break;case D.PIZ_COMPRESSION:B.lines=32,B.uncompress=BK;break;case D.PXR24_COMPRESSION:B.lines=16,B.uncompress=GK,await fK.Tools.LoadScriptAsync(OK.FFLATEUrl);break;default:throw new Error(D[K.compression]+" is unsupported")}B.scanlineBlockSize=B.lines;const L={};for(const f of K.channels)switch(f.name){case"R":case"G":case"B":case"A":case"Y":L[f.name]=!0,B.type=f.pixelType}let O=!1;if(L.R&&L.G&&L.B&&L.A)B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G&&L.B)O=!0,B.outputChannels=4,B.decodeChannels={R:0,G:1,B:2,A:3};else if(L.R&&L.G)B.outputChannels=2,B.decodeChannels={R:0,G:1};else if(L.R)B.outputChannels=1,B.decodeChannels={R:0};else{if(!L.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");B.outputChannels=1,B.decodeChannels={Y:0}}if(1===B.type)switch(G){case LK.Float:B.getter=e,B.inputSize=C;break;case LK.HalfFloat:B.getter=u,B.inputSize=C}else{if(2!==B.type)throw new Error("Unsupported pixelType "+B.type+" for "+K.compression);switch(G){case LK.Float:B.getter=H,B.inputSize=f;break;case LK.HalfFloat:B.getter=p,B.inputSize=f}}B.blockCount=B.height/B.scanlineBlockSize;for(let f=0;f<B.blockCount;f++)n(A,T);const Q=B.width*B.height*B.outputChannels;switch(G){case LK.Float:B.byteArray=new Float32Array(Q),B.textureType=1,O&&B.byteArray.fill(1,0,Q);break;case LK.HalfFloat:B.byteArray=new Uint16Array(Q),B.textureType=2,O&&B.byteArray.fill(15360,0,Q);break;default:throw new Error("Unsupported type: "+G)}let Y=0;for(const f of K.channels)void 0!==B.decodeChannels[f.name]&&(B.channelLineOffsets[f.name]=Y*B.width),Y+=2*f.pixelType;return B.bytesPerLine=B.width*Y,B.outLineWidth=B.width*B.outputChannels,"INCREASING_Y"===K.lineOrder?B.scanOrder=K=>K:B.scanOrder=K=>B.height-1-K,4==B.outputChannels?(B.format=5,B.linearSpace=!0):(B.format=6,B.linearSpace=!1),B}function QK(K,A,T,G){const B={value:0};for(let L=0;L<K.height/K.scanlineBlockSize;L++){const f=g(T,G)-A.dataWindow.yMin;K.size=S(T,G),K.lines=f+K.scanlineBlockSize>K.height?K.height-f:K.scanlineBlockSize;const O=K.size<K.lines*K.bytesPerLine&&K.uncompress?K.uncompress(K):KK(K);G.value+=K.size;for(let T=0;T<K.scanlineBlockSize;T++){const G=L*K.scanlineBlockSize,f=T+K.scanOrder(G);if(f>=K.height)continue;const C=T*K.bytesPerLine,Q=(K.height-1-f)*K.outLineWidth;for(let T=0;T<K.channels;T++){const G=A.channels[T].name,L=K.channelLineOffsets[G],f=K.decodeChannels[G];if(void 0!==f){B.value=C+L;for(let A=0;A<K.width;A++){const T=Q+A*K.outputChannels+f;K.byteArray&&(K.byteArray[T]=K.getter(O,B))}}}}}}OK.DefaultOutputType=LK.HalfFloat,OK.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class YK{constructor(){this.supportCascades=!1}loadCubeData(K,A,T,G,B){throw".exr not supported in Cube."}loadData(K,A,T){const B=new DataView(K.buffer),L={value:0},f=j(B,L);CK(f,B,L,OK.DefaultOutputType).then((K=>{QK(K,f,B,L);const G=f.dataWindow.xMax-f.dataWindow.xMin+1,O=f.dataWindow.yMax-f.dataWindow.yMin+1;T(G,O,A.generateMipMaps,!1,(()=>{const T=A.getEngine();A.format=f.format,A.type=K.textureType,A.invertY=!1,A._gammaSpace=!f.linearSpace,K.byteArray&&T._uploadDataToTextureDirectly(A,K.byteArray,0,0,void 0,!0)}))})).catch((K=>{G.d.Error("Failed to load EXR texture: ",K)}))}}async function ZK(K){const A=new DataView(K),T={value:0},B=j(A,T);try{const K=await CK(B,A,T,LK.Float);return QK(K,B,A,T),K.byteArray?{width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,data:new Float32Array(K.byteArray)}:(G.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(L){G.d.Error("Failed to load EXR data: ",L)}return{width:0,height:0,data:null}}},12716:(K,A,T)=>{function G(K){return parseInt(K.toString().replace(/\W/g,""))}function B(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-A)<=T}function L(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<A-G||K>T+G}function f(K,A){return K===A?K:Math.random()*(A-K)+K}function O(K,A,T){return K+(A-K)*T}function C(K,A,T){let G=F(A-K,360);return G>180&&(G-=360),K+G*x(T)}function Q(K,A,T){let G=0;return G=K!=A?x((T-K)/(A-K)):0,G}function Y(K,A,T,G,B){const L=B*B,f=B*L;return K*(2*f-3*L+1)+T*(-2*f+3*L)+A*(f-2*L+B)+G*(f-L)}function Z(K,A,T,G,B){const L=B*B;return 6*(L-B)*K+(3*L-4*B+1)*A+6*(-L+B)*T+(3*L-2*B)*G}function x(K){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(T,Math.max(A,K))}function J(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function b(K){const A=K.toString(16);return K<=15?("0"+A).toUpperCase():A.toUpperCase()}function P(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let A=0;if(K<1){for(;K<1;)A++,K*=2;A=-A}else if(K>1)for(;K>1;)A++,K=Math.floor(K/2);return A}function F(K,A){return K-Math.floor(K/A)*A}function d(K,A,T){return(K-A)/(T-A)}function N(K,A,T){return K*(T-A)+A}function D(K,A){let T=F(A-K,360);return T>180&&(T-=360),T}function mK(K,A){const T=F(K,2*A);return A-Math.abs(T-A)}function U(K,A,T){let G=x(T);return G=-2*G*G*G+3*G*G,A*G+K*(1-G)}function z(K,A,T){let G=0;return G=Math.abs(A-K)<=T?A:K+Math.sign(A-K)*T,G}function g(K,A,T){const G=D(K,A);let B=0;return B=-T<G&&G<T?A:z(K,A=K+G,T),B}function S(K,A,T){return(K-A)/(T-A)}function l(K,A,T){return(T-A)*K+A}function u(K,A){const T=K%A;return 0===T?A:u(A,T)}T.r(A),T.d(A,{Clamp:()=>x,DeltaAngle:()=>D,Denormalize:()=>N,ExtractAsInt:()=>G,Hermite:()=>Y,Hermite1stDerivative:()=>Z,HighestCommonFactor:()=>u,ILog2:()=>P,InverseLerp:()=>Q,Lerp:()=>O,LerpAngle:()=>C,MoveTowards:()=>z,MoveTowardsAngle:()=>g,Normalize:()=>d,NormalizeRadians:()=>J,OutsideRange:()=>L,PercentToRange:()=>l,PingPong:()=>mK,RandomRange:()=>f,RangeToPercent:()=>S,Repeat:()=>F,SmoothStep:()=>U,ToHex:()=>b,WithinEpsilon:()=>B})}}]);