"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2539:(J,T,b)=>{function q(J){return Math.floor(J/8)}function t(J){return 1<<J%8}b.d(T,{OptimizeIndices:()=>B});class j{constructor(J){this.size=J,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(J){if(J>=this.size)throw new RangeError("Bit index out of range");const T=q(J),b=t(J);return 0!==(this._byteArray[T]&b)}set(J,T){if(J>=this.size)throw new RangeError("Bit index out of range");const b=q(J),j=t(J);T?this._byteArray[b]|=j:this._byteArray[b]&=~j}}function B(J){const T=[],b=J.length/3;for(let j=0;j<b;j++)T.push([J[3*j],J[3*j+1],J[3*j+2]]);const q=new Map;for(let j=0;j<T.length;j++){const J=T[j];for(const T of J){let J=q.get(T);J||q.set(T,J=[]),J.push(j)}}const t=new j(b),B=[],Y=J=>{const b=[J];for(;b.length>0;){const J=b.pop();if(!t.get(J)){t.set(J,!0),B.push(T[J]);for(const j of T[J]){const J=q.get(j);if(!J)return;for(const T of J)t.get(T)||b.push(T)}}}};for(let j=0;j<b;j++)t.get(j)||Y(j);let C=0;for(const j of B)J[C++]=j[0],J[C++]=j[1],J[C++]=j[2]}}}]);