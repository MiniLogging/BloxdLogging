"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[16],{13855:(m,S,h)=>{h.r(S),h.d(S,{ReadExrDataAsync:()=>Im,_ExrTextureLoader:()=>Vm});var l=h(11173),M=h(11359);const O=4,u=4,b=1,q=2,Y=8,V=65536,I=V>>3,Z=14,C=65537,B=1<<Z,D=B-1,E=59,n=63,L=2+n-E;var U,H;!function(m){m[m.NO_COMPRESSION=0]="NO_COMPRESSION",m[m.RLE_COMPRESSION=1]="RLE_COMPRESSION",m[m.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",m[m.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",m[m.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",m[m.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(m){m[m.INCREASING_Y=0]="INCREASING_Y",m[m.DECREASING_Y=1]="DECREASING_Y"}(H||(H={}));const R=function(){const m=new ArrayBuffer(4),S=new Float32Array(m),h=new Uint32Array(m),l=new Uint32Array(512),M=new Uint32Array(512);for(let q=0;q<256;++q){const m=q-127;m<-27?(l[q]=0,l[256|q]=32768,M[q]=24,M[256|q]=24):m<-14?(l[q]=1024>>-m-14,l[256|q]=1024>>-m-14|32768,M[q]=-m-1,M[256|q]=-m-1):m<=15?(l[q]=m+15<<10,l[256|q]=m+15<<10|32768,M[q]=13,M[256|q]=13):m<128?(l[q]=31744,l[256|q]=64512,M[q]=24,M[256|q]=24):(l[q]=31744,l[256|q]=64512,M[q]=13,M[256|q]=13)}const O=new Uint32Array(2048),u=new Uint32Array(64),b=new Uint32Array(64);for(let q=1;q<1024;++q){let m=q<<13,S=0;for(;0===(8388608&m);)m<<=1,S-=8388608;m&=-8388609,S+=947912704,O[q]=m|S}for(let q=1024;q<2048;++q)O[q]=939524096+(q-1024<<13);for(let q=1;q<31;++q)u[q]=q<<23;u[31]=1199570944,u[32]=2147483648;for(let q=33;q<63;++q)u[q]=2147483648+(q-32<<23);u[63]=3347054592;for(let q=1;q<64;++q)32!==q&&(b[q]=1024);return{floatView:S,uint32View:h,baseTable:l,shiftTable:M,mantissaTable:O,exponentTable:u,offsetTable:b}}();function y(m,S){const h=new Uint8Array(m);let l=0;for(;0!=h[S.value+l];)l+=1;const M=(new TextDecoder).decode(h.slice(S.value,S.value+l));return S.value=S.value+l+1,M}function o(m,S){const h=m.getInt32(S.value,!0);return S.value+=O,h}function s(m,S){const h=m.getUint32(S.value,!0);return S.value+=O,h}function v(m,S){const h=m.getUint8(S.value);return S.value+=b,h}function T(m,S){const h=m.getUint16(S.value,!0);return S.value+=q,h}function X(m,S){const h=m[S.value];return S.value+=b,h}function g(m,S){let h;return h="getBigInt64"in DataView.prototype?Number(m.getBigInt64(S.value,!0)):m.getUint32(S.value+4,!0)+Number(m.getUint32(S.value,!0)<<32),S.value+=Y,h}function G(m,S){const h=m.getFloat32(S.value,!0);return S.value+=u,h}function e(m,S){return function(m){const S=(31744&m)>>10,h=1023&m;return(m>>15?-1:1)*(S?31===S?h?NaN:1/0:Math.pow(2,S-15)*(1+h/1024):h/1024*6103515625e-14)}(T(m,S))}function a(m,S){return function(m){if(Math.abs(m)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");m=(0,M.Clamp)(m,-65504,65504),R.floatView[0]=m;const S=R.uint32View[0],h=S>>23&511;return R.baseTable[h]+((8388607&S)>>R.shiftTable[h])}(G(m,S))}function x(m,S,h,l){switch(h){case"string":case"stringvector":case"iccProfile":return function(m,S,h){const l=(new TextDecoder).decode(new Uint8Array(m).slice(S.value,S.value+h));return S.value=S.value+h,l}(m.buffer,S,l);case"chlist":return function(m,S,h){const l=S.value,M=[];for(;S.value<l+h-1;){const h=y(m.buffer,S),l=o(m,S),O=v(m,S);S.value+=3;const u=o(m,S),b=o(m,S);M.push({name:h,pixelType:l,pLinear:O,xSampling:u,ySampling:b})}return S.value+=1,M}(m,S,l);case"chromaticities":return function(m,S){return{redX:G(m,S),redY:G(m,S),greenX:G(m,S),greenY:G(m,S),blueX:G(m,S),blueY:G(m,S),whiteX:G(m,S),whiteY:G(m,S)}}(m,S);case"compression":return function(m,S){return v(m,S)}(m,S);case"box2i":return function(m,S){return{xMin:o(m,S),yMin:o(m,S),xMax:o(m,S),yMax:o(m,S)}}(m,S);case"lineOrder":return function(m,S){const h=v(m,S);return H[h]}(m,S);case"float":return G(m,S);case"v2f":return function(m,S){return[G(m,S),G(m,S)]}(m,S);case"v3f":return function(m,S){return[G(m,S),G(m,S),G(m,S)]}(m,S);case"int":return o(m,S);case"rational":return function(m,S){return[o(m,S),s(m,S)]}(m,S);case"timecode":return function(m,S){return[s(m,S),s(m,S)]}(m,S);case"preview":return S.value+=l,"skipped";default:return void(S.value+=l)}}function P(m){for(let S=1;S<m.length;S++){const h=m[S-1]+m[S]-128;m[S]=h}}function d(m,S){let h=0,l=Math.floor((m.length+1)/2),M=0;const O=m.length-1;for(;!(M>O)&&(S[M++]=m[h++],!(M>O));)S[M++]=m[l++]}const J=20000630;function N(m,S){if(m.getUint32(0,!0)!=J)throw new Error("Incorrect OpenEXR format");const h=m.getUint8(4),M=m.getUint8(5),O={singleTile:!!(2&M),longName:!!(4&M),deepFormat:!!(8&M),multiPart:!!(16&M)};S.value=8;const u={};let b=!0;for(;b;){const h=y(m.buffer,S);if(h){const M=y(m.buffer,S),O=x(m,S,M,s(m,S));void 0===O?l.e.Warn(`Unknown header attribute type ${M}'.`):u[h]=O}else b=!1}if(0!=(-5&M))throw new Error("Unsupported file format");return{version:h,spec:O,...u}}const j=32768,K=65535;function c(m,S,h,l,M){for(;h<m;)S=S<<8|X(l,M),h+=8;return{l:S>>(h-=m)&(1<<m)-1,c:S,lc:h}}function f(m,S,h,l){return{c:m=m<<8|X(h,l),lc:S+=8}}function p(m,S,h,l,M,O,u,b,q){if(m==S){if(l<8){const m=f(h,l,M,O);h=m.c,l=m.lc}let m=h>>(l-=8);if(m=new Uint8Array([m])[0],b.value+m>q)return null;const S=u[b.value-1];for(;m-- >0;)u[b.value++]=S}else{if(!(b.value<q))return null;u[b.value++]=m}return{c:h,lc:l}}const k=new Array(59);function r(m,S,h,l,M,O){const u=S;let b=0,q=0;for(;l<=M;l++){if(u.value-S.value>h)return;let Y=c(6,b,q,m,u);const V=Y.l;if(b=Y.c,q=Y.lc,O[l]=V,V==n){if(u.value-S.value>h)throw new Error("Error in HufUnpackEncTable");Y=c(8,b,q,m,u);let V=Y.l+L;if(b=Y.c,q=Y.lc,l+V>M+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)O[l++]=0;l--}else if(V>=E){let m=V-E+2;if(l+m>M+1)throw new Error("Error in HufUnpackEncTable");for(;m--;)O[l++]=0;l--}}!function(m){for(let h=0;h<=58;++h)k[h]=0;for(let h=0;h<C;++h)k[m[h]]+=1;let S=0;for(let h=58;h>0;--h){const m=S+k[h]>>1;k[h]=S,S=m}for(let h=0;h<C;++h){const S=m[h];S>0&&(m[h]=S|k[S]++<<6)}}(O)}function z(m){return 63&m}function Q(m){return m>>6}function F(m,S,h,l,M,O){const u=h.value,b=s(S,h),q=s(S,h);h.value+=4;const Y=s(S,h);if(h.value+=4,b<0||b>=C||q<0||q>=C)throw new Error("Wrong HUF_ENCSIZE");const V=new Array(C),I=new Array(B);!function(m){for(let S=0;S<B;S++)m[S]={},m[S].len=0,m[S].lit=0,m[S].p=null}(I);if(r(m,h,l-(h.value-u),b,q,V),Y>8*(l-(h.value-u)))throw new Error("Wrong hufUncompress");!function(m,S,h,l){for(;S<=h;S++){const h=Q(m[S]),M=z(m[S]);if(h>>M)throw new Error("Invalid table entry");if(M>Z){const m=l[h>>M-Z];if(m.len)throw new Error("Invalid table entry");if(m.lit++,m.p){const S=m.p;m.p=new Array(m.lit);for(let h=0;h<m.lit-1;++h)m.p[h]=S[h]}else m.p=new Array(1);m.p[m.lit-1]=S}else if(M){let m=0;for(let O=1<<Z-M;O>0;O--){const O=l[(h<<Z-M)+m];if(O.len||O.p)throw new Error("Invalid table entry");O.len=M,O.lit=S,m++}}}}(V,b,q,I),function(m,S,h,l,M,O,u,b,q){let Y=0,V=0;const I=u,C=Math.trunc(l.value+(M+7)/8);for(;l.value<C;){let M=f(Y,V,h,l);for(Y=M.c,V=M.lc;V>=Z;){const u=S[Y>>V-Z&D];if(u.len){V-=u.len;const m=p(u.lit,O,Y,V,h,l,b,q,I);m&&(Y=m.c,V=m.lc)}else{if(!u.p)throw new Error("hufDecode issues");let S;for(S=0;S<u.lit;S++){const Z=z(m[u.p[S]]);for(;V<Z&&l.value<C;)M=f(Y,V,h,l),Y=M.c,V=M.lc;if(V>=Z&&Q(m[u.p[S]])==(Y>>V-Z&(1<<Z)-1)){V-=Z;const m=p(u.p[S],O,Y,V,h,l,b,q,I);m&&(Y=m.c,V=m.lc);break}}if(S==u.lit)throw new Error("HufDecode issues")}}}const B=8-M&7;for(Y>>=B,V-=B;V>0;){const m=S[Y<<Z-V&D];if(!m.len)throw new Error("HufDecode issues");{V-=m.len;const S=p(m.lit,O,Y,V,h,l,b,q,I);S&&(Y=S.c,V=S.lc)}}}(V,I,m,h,Y,q,O,M,{value:0})}function w(m){return 65535&m}function t(m){const S=w(m);return S>32767?S-65536:S}function A(m,S){const h=t(m),l=t(S),M=h+(1&l)+(l>>1);return{a:M,b:M-l}}function i(m,S){const h=w(m),l=w(S),M=h-(l>>1)&K;return{a:l+M-j&K,b:M}}function W(m,S,h,l,M,O,u){const b=u<16384,q=h>M?M:h;let Y,V,I=1;for(;I<=q;)I<<=1;for(I>>=1,Y=I,I>>=1;I>=1;){V=0;const u=V+O*(M-Y),q=O*I,Z=O*Y,C=l*I,B=l*Y;let D,E,n,L;for(;V<=u;V+=Z){let M=V;const O=V+l*(h-Y);for(;M<=O;M+=B){const h=M+C,l=M+q,O=l+C;if(b){let u=A(m[M+S],m[l+S]);D=u.a,n=u.b,u=A(m[h+S],m[O+S]),E=u.a,L=u.b,u=A(D,E),m[M+S]=u.a,m[h+S]=u.b,u=A(n,L),m[l+S]=u.a,m[O+S]=u.b}else{let u=i(m[M+S],m[l+S]);D=u.a,n=u.b,u=i(m[h+S],m[O+S]),E=u.a,L=u.b,u=i(D,E),m[M+S]=u.a,m[h+S]=u.b,u=i(n,L),m[l+S]=u.a,m[O+S]=u.b}}if(h&I){const h=M+q;let l;l=b?A(m[M+S],m[h+S]):i(m[M+S],m[h+S]),D=l.a,m[h+S]=l.b,m[M+S]=D}}if(M&I){let M=V;const O=V+l*(h-Y);for(;M<=O;M+=B){const h=M+C;let l;l=b?A(m[M+S],m[h+S]):i(m[M+S],m[h+S]),D=l.a,m[h+S]=l.b,m[M+S]=D}}Y=I,I>>=1}return V}function mm(m){return new DataView(m.array.buffer,m.offset.value,m.size)}function Sm(m){const S=m.viewer.buffer.slice(m.offset.value,m.offset.value+m.size),h=new Uint8Array(function(m){let S=m.byteLength;const h=[];let l=0;const M=new DataView(m);for(;S>0;){const m=M.getInt8(l++);if(m<0){const O=-m;S-=O+1;for(let m=0;m<O;m++)h.push(M.getUint8(l++))}else{const O=m;S-=2;const u=M.getUint8(l++);for(let m=0;m<O+1;m++)h.push(u)}}return h}(S)),l=new Uint8Array(h.length);return P(h),d(h,l),new DataView(l.buffer)}function hm(m){const S=m.array.slice(m.offset.value,m.offset.value+m.size),h=fflate.unzlibSync(S),l=new Uint8Array(h.length);return P(h),d(h,l),new DataView(l.buffer)}function lm(m){const S=m.array.slice(m.offset.value,m.offset.value+m.size),h=fflate.unzlibSync(S),l=m.lines*m.channels*m.width,M=1==m.type?new Uint16Array(l):new Uint32Array(l);let O=0,u=0;const b=new Array(4);for(let q=0;q<m.lines;q++)for(let S=0;S<m.channels;S++){let S=0;switch(m.type){case 1:b[0]=O,b[1]=b[0]+m.width,O=b[1]+m.width;for(let l=0;l<m.width;++l){S+=h[b[0]++]<<8|h[b[1]++],M[u]=S,u++}break;case 2:b[0]=O,b[1]=b[0]+m.width,b[2]=b[1]+m.width,O=b[2]+m.width;for(let l=0;l<m.width;++l){S+=h[b[0]++]<<24|h[b[1]++]<<16|h[b[2]++]<<8,M[u]=S,u++}}}return new DataView(M.buffer)}function Mm(m){const S=m.viewer,h={value:m.offset.value},l=new Uint16Array(m.width*m.scanlineBlockSize*(m.channels*m.type)),M=new Uint8Array(I);let O=0;const u=new Array(m.channels);for(let q=0;q<m.channels;q++)u[q]={},u[q].start=O,u[q].end=u[q].start,u[q].nx=m.width,u[q].ny=m.lines,u[q].size=m.type,O+=u[q].nx*u[q].ny*u[q].size;const b=T(S,h),Y=T(S,h);if(Y>=I)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(b<=Y)for(let q=0;q<Y-b+1;q++)M[q+b]=v(S,h);const Z=new Uint16Array(V),C=function(m,S){let h=0;for(let M=0;M<V;++M)(0==M||m[M>>3]&1<<(7&M))&&(S[h++]=M);const l=h-1;for(;h<V;)S[h++]=0;return l}(M,Z),B=s(S,h);F(m.array,S,h,B,l,O);for(let q=0;q<m.channels;++q){const m=u[q];for(let S=0;S<u[q].size;++S)W(l,m.start+S,m.nx,m.size,m.ny,m.nx*m.size,C)}!function(m,S,h){for(let l=0;l<h;++l)S[l]=m[S[l]]}(Z,l,O);let D=0;const E=new Uint8Array(l.buffer.byteLength);for(let V=0;V<m.lines;V++)for(let S=0;S<m.channels;S++){const m=u[S],h=m.nx*m.size,M=new Uint8Array(l.buffer,m.end*q,h*q);E.set(M,D),D+=h*q,m.end+=h}return new DataView(E.buffer)}var Om,um=h(11156);!function(m){m[m.Float=0]="Float",m[m.HalfFloat=1]="HalfFloat"}(Om||(Om={}));class bm{}async function qm(m,S,h,l){const M={size:0,viewer:S,array:new Uint8Array(S.buffer),offset:h,width:m.dataWindow.xMax-m.dataWindow.xMin+1,height:m.dataWindow.yMax-m.dataWindow.yMin+1,channels:m.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(m.compression){case U.NO_COMPRESSION:M.lines=1,M.uncompress=mm;break;case U.RLE_COMPRESSION:M.lines=1,M.uncompress=Sm;break;case U.ZIPS_COMPRESSION:M.lines=1,M.uncompress=hm,await um.Tools.LoadScriptAsync(bm.FFLATEUrl);break;case U.ZIP_COMPRESSION:M.lines=16,M.uncompress=hm,await um.Tools.LoadScriptAsync(bm.FFLATEUrl);break;case U.PIZ_COMPRESSION:M.lines=32,M.uncompress=Mm;break;case U.PXR24_COMPRESSION:M.lines=16,M.uncompress=lm,await um.Tools.LoadScriptAsync(bm.FFLATEUrl);break;default:throw new Error(U[m.compression]+" is unsupported")}M.scanlineBlockSize=M.lines;const O={};for(const u of m.channels)switch(u.name){case"R":case"G":case"B":case"A":case"Y":O[u.name]=!0,M.type=u.pixelType}let b=!1;if(O.R&&O.G&&O.B&&O.A)M.outputChannels=4,M.decodeChannels={R:0,G:1,B:2,A:3};else if(O.R&&O.G&&O.B)b=!0,M.outputChannels=4,M.decodeChannels={R:0,G:1,B:2,A:3};else if(O.R&&O.G)M.outputChannels=2,M.decodeChannels={R:0,G:1};else if(O.R)M.outputChannels=1,M.decodeChannels={R:0};else{if(!O.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");M.outputChannels=1,M.decodeChannels={Y:0}}if(1===M.type)switch(l){case Om.Float:M.getter=e,M.inputSize=q;break;case Om.HalfFloat:M.getter=T,M.inputSize=q}else{if(2!==M.type)throw new Error("Unsupported pixelType "+M.type+" for "+m.compression);switch(l){case Om.Float:M.getter=G,M.inputSize=u;break;case Om.HalfFloat:M.getter=a,M.inputSize=u}}M.blockCount=M.height/M.scanlineBlockSize;for(let u=0;u<M.blockCount;u++)g(S,h);const Y=M.width*M.height*M.outputChannels;switch(l){case Om.Float:M.byteArray=new Float32Array(Y),M.textureType=1,b&&M.byteArray.fill(1,0,Y);break;case Om.HalfFloat:M.byteArray=new Uint16Array(Y),M.textureType=2,b&&M.byteArray.fill(15360,0,Y);break;default:throw new Error("Unsupported type: "+l)}let V=0;for(const u of m.channels)void 0!==M.decodeChannels[u.name]&&(M.channelLineOffsets[u.name]=V*M.width),V+=2*u.pixelType;return M.bytesPerLine=M.width*V,M.outLineWidth=M.width*M.outputChannels,"INCREASING_Y"===m.lineOrder?M.scanOrder=m=>m:M.scanOrder=m=>M.height-1-m,4==M.outputChannels?(M.format=5,M.linearSpace=!0):(M.format=6,M.linearSpace=!1),M}function Ym(m,S,h,l){const M={value:0};for(let O=0;O<m.height/m.scanlineBlockSize;O++){const u=o(h,l)-S.dataWindow.yMin;m.size=s(h,l),m.lines=u+m.scanlineBlockSize>m.height?m.height-u:m.scanlineBlockSize;const b=m.size<m.lines*m.bytesPerLine&&m.uncompress?m.uncompress(m):mm(m);l.value+=m.size;for(let h=0;h<m.scanlineBlockSize;h++){const l=O*m.scanlineBlockSize,u=h+m.scanOrder(l);if(u>=m.height)continue;const q=h*m.bytesPerLine,Y=(m.height-1-u)*m.outLineWidth;for(let h=0;h<m.channels;h++){const l=S.channels[h].name,O=m.channelLineOffsets[l],u=m.decodeChannels[l];if(void 0!==u){M.value=q+O;for(let S=0;S<m.width;S++){const h=Y+S*m.outputChannels+u;m.byteArray&&(m.byteArray[h]=m.getter(b,M))}}}}}}bm.DefaultOutputType=Om.HalfFloat,bm.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Vm{constructor(){this.supportCascades=!1}loadCubeData(m,S,h,l,M){throw".exr not supported in Cube."}loadData(m,S,h){const M=new DataView(m.buffer),O={value:0},u=N(M,O);qm(u,M,O,bm.DefaultOutputType).then((m=>{Ym(m,u,M,O);const l=u.dataWindow.xMax-u.dataWindow.xMin+1,b=u.dataWindow.yMax-u.dataWindow.yMin+1;h(l,b,S.generateMipMaps,!1,(()=>{const h=S.getEngine();S.format=u.format,S.type=m.textureType,S.invertY=!1,S._gammaSpace=!u.linearSpace,m.byteArray&&h._uploadDataToTextureDirectly(S,m.byteArray,0,0,void 0,!0)}))})).catch((m=>{l.e.Error("Failed to load EXR texture: ",m)}))}}async function Im(m){const S=new DataView(m),h={value:0},M=N(S,h);try{const m=await qm(M,S,h,Om.Float);return Ym(m,M,S,h),m.byteArray?{width:M.dataWindow.xMax-M.dataWindow.xMin+1,height:M.dataWindow.yMax-M.dataWindow.yMin+1,data:new Float32Array(m.byteArray)}:(l.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(O){l.e.Error("Failed to load EXR data: ",O)}return{width:0,height:0,data:null}}},11359:(m,S,h)=>{function l(m){return parseInt(m.toString().replace(/\W/g,""))}function M(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(m-S)<=h}function O(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return m<S-l||m>h+l}function u(m,S){return m===S?m:Math.random()*(S-m)+m}function b(m,S,h){return m+(S-m)*h}function q(m,S,h){let l=E(S-m,360);return l>180&&(l-=360),m+l*Z(h)}function Y(m,S,h){let l=0;return l=m!=S?Z((h-m)/(S-m)):0,l}function V(m,S,h,l,M){const O=M*M,u=M*O;return m*(2*u-3*O+1)+h*(-2*u+3*O)+S*(u-2*O+M)+l*(u-O)}function I(m,S,h,l,M){const O=M*M;return 6*(O-M)*m+(3*O-4*M+1)*S+6*(-O+M)*h+(3*O-2*M)*l}function Z(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(S,m))}function C(m){return m-=2*Math.PI*Math.floor((m+Math.PI)/(2*Math.PI))}function B(m){const S=m.toString(16);return m<=15?("0"+S).toUpperCase():S.toUpperCase()}function D(m){if(Math.log2)return Math.floor(Math.log2(m));if(m<0)return NaN;if(0===m)return-1/0;let S=0;if(m<1){for(;m<1;)S++,m*=2;S=-S}else if(m>1)for(;m>1;)S++,m=Math.floor(m/2);return S}function E(m,S){return m-Math.floor(m/S)*S}function n(m,S,h){return(m-S)/(h-S)}function L(m,S,h){return m*(h-S)+S}function U(m,S){let h=E(S-m,360);return h>180&&(h-=360),h}function H(m,S){const h=E(m,2*S);return S-Math.abs(h-S)}function R(m,S,h){let l=Z(h);return l=-2*l*l*l+3*l*l,S*l+m*(1-l)}function y(m,S,h){let l=0;return l=Math.abs(S-m)<=h?S:m+Math.sign(S-m)*h,l}function o(m,S,h){const l=U(m,S);let M=0;return M=-h<l&&l<h?S:y(m,S=m+l,h),M}function s(m,S,h){return(m-S)/(h-S)}function v(m,S,h){return(h-S)*m+S}function T(m,S){const h=m%S;return 0===h?S:T(S,h)}h.r(S),h.d(S,{Clamp:()=>Z,DeltaAngle:()=>U,Denormalize:()=>L,ExtractAsInt:()=>l,Hermite:()=>V,Hermite1stDerivative:()=>I,HighestCommonFactor:()=>T,ILog2:()=>D,InverseLerp:()=>Y,Lerp:()=>b,LerpAngle:()=>q,MoveTowards:()=>y,MoveTowardsAngle:()=>o,Normalize:()=>n,NormalizeRadians:()=>C,OutsideRange:()=>O,PercentToRange:()=>v,PingPong:()=>H,RandomRange:()=>u,RangeToPercent:()=>s,Repeat:()=>E,SmoothStep:()=>R,ToHex:()=>B,WithinEpsilon:()=>M})}}]);