"use strict";(self.nyfa010khv=self.nyfa010khv||[]).push([[16],{14624:(L,r,p)=>{p.r(r),p.d(r,{ReadExrDataAsync:()=>EL,_ExrTextureLoader:()=>tL});var J=p(11975),i=p(12154);const n=4,j=4,z=1,G=2,C=8,t=65536,E=t>>3,x=14,w=65537,g=1<<x,b=g-1,c=59,P=63,O=2+P-c;var h,U;!function(L){L[L.NO_COMPRESSION=0]="NO_COMPRESSION",L[L.RLE_COMPRESSION=1]="RLE_COMPRESSION",L[L.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",L[L.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",L[L.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",L[L.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(h||(h={})),function(L){L[L.INCREASING_Y=0]="INCREASING_Y",L[L.DECREASING_Y=1]="DECREASING_Y"}(U||(U={}));const W=function(){const L=new ArrayBuffer(4),r=new Float32Array(L),p=new Uint32Array(L),J=new Uint32Array(512),i=new Uint32Array(512);for(let G=0;G<256;++G){const L=G-127;L<-27?(J[G]=0,J[256|G]=32768,i[G]=24,i[256|G]=24):L<-14?(J[G]=1024>>-L-14,J[256|G]=1024>>-L-14|32768,i[G]=-L-1,i[256|G]=-L-1):L<=15?(J[G]=L+15<<10,J[256|G]=L+15<<10|32768,i[G]=13,i[256|G]=13):L<128?(J[G]=31744,J[256|G]=64512,i[G]=24,i[256|G]=24):(J[G]=31744,J[256|G]=64512,i[G]=13,i[256|G]=13)}const n=new Uint32Array(2048),j=new Uint32Array(64),z=new Uint32Array(64);for(let G=1;G<1024;++G){let L=G<<13,r=0;for(;0===(8388608&L);)L<<=1,r-=8388608;L&=-8388609,r+=947912704,n[G]=L|r}for(let G=1024;G<2048;++G)n[G]=939524096+(G-1024<<13);for(let G=1;G<31;++G)j[G]=G<<23;j[31]=1199570944,j[32]=2147483648;for(let G=33;G<63;++G)j[G]=2147483648+(G-32<<23);j[63]=3347054592;for(let G=1;G<64;++G)32!==G&&(z[G]=1024);return{floatView:r,uint32View:p,baseTable:J,shiftTable:i,mantissaTable:n,exponentTable:j,offsetTable:z}}();function B(L,r){const p=new Uint8Array(L);let J=0;for(;0!=p[r.value+J];)J+=1;const i=(new TextDecoder).decode(p.slice(r.value,r.value+J));return r.value=r.value+J+1,i}function F(L,r){const p=L.getInt32(r.value,!0);return r.value+=n,p}function Q(L,r){const p=L.getUint32(r.value,!0);return r.value+=n,p}function e(L,r){const p=L.getUint8(r.value);return r.value+=z,p}function v(L,r){const p=L.getUint16(r.value,!0);return r.value+=G,p}function y(L,r){const p=L[r.value];return r.value+=z,p}function A(L,r){let p;return p="getBigInt64"in DataView.prototype?Number(L.getBigInt64(r.value,!0)):L.getUint32(r.value+4,!0)+Number(L.getUint32(r.value,!0)<<32),r.value+=C,p}function u(L,r){const p=L.getFloat32(r.value,!0);return r.value+=j,p}function a(L,r){return function(L){const r=(31744&L)>>10,p=1023&L;return(L>>15?-1:1)*(r?31===r?p?NaN:1/0:Math.pow(2,r-15)*(1+p/1024):p/1024*6103515625e-14)}(v(L,r))}function q(L,r){return function(L){if(Math.abs(L)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");L=(0,i.Clamp)(L,-65504,65504),W.floatView[0]=L;const r=W.uint32View[0],p=r>>23&511;return W.baseTable[p]+((8388607&r)>>W.shiftTable[p])}(u(L,r))}function Z(L,r,p,J){switch(p){case"string":case"stringvector":case"iccProfile":return function(L,r,p){const J=(new TextDecoder).decode(new Uint8Array(L).slice(r.value,r.value+p));return r.value=r.value+p,J}(L.buffer,r,J);case"chlist":return function(L,r,p){const J=r.value,i=[];for(;r.value<J+p-1;){const p=B(L.buffer,r),J=F(L,r),n=e(L,r);r.value+=3;const j=F(L,r),z=F(L,r);i.push({name:p,pixelType:J,pLinear:n,xSampling:j,ySampling:z})}return r.value+=1,i}(L,r,J);case"chromaticities":return function(L,r){return{redX:u(L,r),redY:u(L,r),greenX:u(L,r),greenY:u(L,r),blueX:u(L,r),blueY:u(L,r),whiteX:u(L,r),whiteY:u(L,r)}}(L,r);case"compression":return function(L,r){return e(L,r)}(L,r);case"box2i":return function(L,r){return{xMin:F(L,r),yMin:F(L,r),xMax:F(L,r),yMax:F(L,r)}}(L,r);case"lineOrder":return function(L,r){const p=e(L,r);return U[p]}(L,r);case"float":return u(L,r);case"v2f":return function(L,r){return[u(L,r),u(L,r)]}(L,r);case"v3f":return function(L,r){return[u(L,r),u(L,r),u(L,r)]}(L,r);case"int":return F(L,r);case"rational":return function(L,r){return[F(L,r),Q(L,r)]}(L,r);case"timecode":return function(L,r){return[Q(L,r),Q(L,r)]}(L,r);case"preview":return r.value+=J,"skipped";default:return void(r.value+=J)}}function X(L){for(let r=1;r<L.length;r++){const p=L[r-1]+L[r]-128;L[r]=p}}function D(L,r){let p=0,J=Math.floor((L.length+1)/2),i=0;const n=L.length-1;for(;!(i>n)&&(r[i++]=L[p++],!(i>n));)r[i++]=L[J++]}const l=20000630;function T(L,r){if(L.getUint32(0,!0)!=l)throw new Error("Incorrect OpenEXR format");const p=L.getUint8(4),i=L.getUint8(5),n={singleTile:!!(2&i),longName:!!(4&i),deepFormat:!!(8&i),multiPart:!!(16&i)};r.value=8;const j={};let z=!0;for(;z;){const p=B(L.buffer,r);if(p){const i=B(L.buffer,r),n=Z(L,r,i,Q(L,r));void 0===n?J.d.Warn(`Unknown header attribute type ${i}'.`):j[p]=n}else z=!1}if(0!=(-5&i))throw new Error("Unsupported file format");return{version:p,spec:n,...j}}const Y=32768,M=65535;function f(L,r,p,J,i){for(;p<L;)r=r<<8|y(J,i),p+=8;return{l:r>>(p-=L)&(1<<L)-1,c:r,lc:p}}function d(L,r,p,J){return{c:L=L<<8|y(p,J),lc:r+=8}}function s(L,r,p,J,i,n,j,z,G){if(L==r){if(J<8){const L=d(p,J,i,n);p=L.c,J=L.lc}let L=p>>(J-=8);if(L=new Uint8Array([L])[0],z.value+L>G)return null;const r=j[z.value-1];for(;L-- >0;)j[z.value++]=r}else{if(!(z.value<G))return null;j[z.value++]=L}return{c:p,lc:J}}const H=new Array(59);function o(L,r,p,J,i,n){const j=r;let z=0,G=0;for(;J<=i;J++){if(j.value-r.value>p)return;let C=f(6,z,G,L,j);const t=C.l;if(z=C.c,G=C.lc,n[J]=t,t==P){if(j.value-r.value>p)throw new Error("Error in HufUnpackEncTable");C=f(8,z,G,L,j);let t=C.l+O;if(z=C.c,G=C.lc,J+t>i+1)throw new Error("Error in HufUnpackEncTable");for(;t--;)n[J++]=0;J--}else if(t>=c){let L=t-c+2;if(J+L>i+1)throw new Error("Error in HufUnpackEncTable");for(;L--;)n[J++]=0;J--}}!function(L){for(let p=0;p<=58;++p)H[p]=0;for(let p=0;p<w;++p)H[L[p]]+=1;let r=0;for(let p=58;p>0;--p){const L=r+H[p]>>1;H[p]=r,r=L}for(let p=0;p<w;++p){const r=L[p];r>0&&(L[p]=r|H[r]++<<6)}}(n)}function k(L){return 63&L}function R(L){return L>>6}function I(L,r,p,J,i,n){const j=p.value,z=Q(r,p),G=Q(r,p);p.value+=4;const C=Q(r,p);if(p.value+=4,z<0||z>=w||G<0||G>=w)throw new Error("Wrong HUF_ENCSIZE");const t=new Array(w),E=new Array(g);!function(L){for(let r=0;r<g;r++)L[r]={},L[r].len=0,L[r].lit=0,L[r].p=null}(E);if(o(L,p,J-(p.value-j),z,G,t),C>8*(J-(p.value-j)))throw new Error("Wrong hufUncompress");!function(L,r,p,J){for(;r<=p;r++){const p=R(L[r]),i=k(L[r]);if(p>>i)throw new Error("Invalid table entry");if(i>x){const L=J[p>>i-x];if(L.len)throw new Error("Invalid table entry");if(L.lit++,L.p){const r=L.p;L.p=new Array(L.lit);for(let p=0;p<L.lit-1;++p)L.p[p]=r[p]}else L.p=new Array(1);L.p[L.lit-1]=r}else if(i){let L=0;for(let n=1<<x-i;n>0;n--){const n=J[(p<<x-i)+L];if(n.len||n.p)throw new Error("Invalid table entry");n.len=i,n.lit=r,L++}}}}(t,z,G,E),function(L,r,p,J,i,n,j,z,G){let C=0,t=0;const E=j,w=Math.trunc(J.value+(i+7)/8);for(;J.value<w;){let i=d(C,t,p,J);for(C=i.c,t=i.lc;t>=x;){const j=r[C>>t-x&b];if(j.len){t-=j.len;const L=s(j.lit,n,C,t,p,J,z,G,E);L&&(C=L.c,t=L.lc)}else{if(!j.p)throw new Error("hufDecode issues");let r;for(r=0;r<j.lit;r++){const x=k(L[j.p[r]]);for(;t<x&&J.value<w;)i=d(C,t,p,J),C=i.c,t=i.lc;if(t>=x&&R(L[j.p[r]])==(C>>t-x&(1<<x)-1)){t-=x;const L=s(j.p[r],n,C,t,p,J,z,G,E);L&&(C=L.c,t=L.lc);break}}if(r==j.lit)throw new Error("HufDecode issues")}}}const g=8-i&7;for(C>>=g,t-=g;t>0;){const L=r[C<<x-t&b];if(!L.len)throw new Error("HufDecode issues");{t-=L.len;const r=s(L.lit,n,C,t,p,J,z,G,E);r&&(C=r.c,t=r.lc)}}}(t,E,L,p,C,G,n,i,{value:0})}function N(L){return 65535&L}function K(L){const r=N(L);return r>32767?r-65536:r}function mL(L,r){const p=K(L),J=K(r),i=p+(1&J)+(J>>1);return{a:i,b:i-J}}function V(L,r){const p=N(L),J=N(r),i=p-(J>>1)&M;return{a:J+i-Y&M,b:i}}function S(L,r,p,J,i,n,j){const z=j<16384,G=p>i?i:p;let C,t,E=1;for(;E<=G;)E<<=1;for(E>>=1,C=E,E>>=1;E>=1;){t=0;const j=t+n*(i-C),G=n*E,x=n*C,w=J*E,g=J*C;let b,c,P,O;for(;t<=j;t+=x){let i=t;const n=t+J*(p-C);for(;i<=n;i+=g){const p=i+w,J=i+G,n=J+w;if(z){let j=mL(L[i+r],L[J+r]);b=j.a,P=j.b,j=mL(L[p+r],L[n+r]),c=j.a,O=j.b,j=mL(b,c),L[i+r]=j.a,L[p+r]=j.b,j=mL(P,O),L[J+r]=j.a,L[n+r]=j.b}else{let j=V(L[i+r],L[J+r]);b=j.a,P=j.b,j=V(L[p+r],L[n+r]),c=j.a,O=j.b,j=V(b,c),L[i+r]=j.a,L[p+r]=j.b,j=V(P,O),L[J+r]=j.a,L[n+r]=j.b}}if(p&E){const p=i+G;let J;J=z?mL(L[i+r],L[p+r]):V(L[i+r],L[p+r]),b=J.a,L[p+r]=J.b,L[i+r]=b}}if(i&E){let i=t;const n=t+J*(p-C);for(;i<=n;i+=g){const p=i+w;let J;J=z?mL(L[i+r],L[p+r]):V(L[i+r],L[p+r]),b=J.a,L[p+r]=J.b,L[i+r]=b}}C=E,E>>=1}return t}function LL(L){return new DataView(L.array.buffer,L.offset.value,L.size)}function rL(L){const r=L.viewer.buffer.slice(L.offset.value,L.offset.value+L.size),p=new Uint8Array(function(L){let r=L.byteLength;const p=[];let J=0;const i=new DataView(L);for(;r>0;){const L=i.getInt8(J++);if(L<0){const n=-L;r-=n+1;for(let L=0;L<n;L++)p.push(i.getUint8(J++))}else{const n=L;r-=2;const j=i.getUint8(J++);for(let L=0;L<n+1;L++)p.push(j)}}return p}(r)),J=new Uint8Array(p.length);return X(p),D(p,J),new DataView(J.buffer)}function pL(L){const r=L.array.slice(L.offset.value,L.offset.value+L.size),p=fflate.unzlibSync(r),J=new Uint8Array(p.length);return X(p),D(p,J),new DataView(J.buffer)}function JL(L){const r=L.array.slice(L.offset.value,L.offset.value+L.size),p=fflate.unzlibSync(r),J=L.lines*L.channels*L.width,i=1==L.type?new Uint16Array(J):new Uint32Array(J);let n=0,j=0;const z=new Array(4);for(let G=0;G<L.lines;G++)for(let r=0;r<L.channels;r++){let r=0;switch(L.type){case 1:z[0]=n,z[1]=z[0]+L.width,n=z[1]+L.width;for(let J=0;J<L.width;++J){r+=p[z[0]++]<<8|p[z[1]++],i[j]=r,j++}break;case 2:z[0]=n,z[1]=z[0]+L.width,z[2]=z[1]+L.width,n=z[2]+L.width;for(let J=0;J<L.width;++J){r+=p[z[0]++]<<24|p[z[1]++]<<16|p[z[2]++]<<8,i[j]=r,j++}}}return new DataView(i.buffer)}function iL(L){const r=L.viewer,p={value:L.offset.value},J=new Uint16Array(L.width*L.scanlineBlockSize*(L.channels*L.type)),i=new Uint8Array(E);let n=0;const j=new Array(L.channels);for(let G=0;G<L.channels;G++)j[G]={},j[G].start=n,j[G].end=j[G].start,j[G].nx=L.width,j[G].ny=L.lines,j[G].size=L.type,n+=j[G].nx*j[G].ny*j[G].size;const z=v(r,p),C=v(r,p);if(C>=E)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(z<=C)for(let G=0;G<C-z+1;G++)i[G+z]=e(r,p);const x=new Uint16Array(t),w=function(L,r){let p=0;for(let i=0;i<t;++i)(0==i||L[i>>3]&1<<(7&i))&&(r[p++]=i);const J=p-1;for(;p<t;)r[p++]=0;return J}(i,x),g=Q(r,p);I(L.array,r,p,g,J,n);for(let G=0;G<L.channels;++G){const L=j[G];for(let r=0;r<j[G].size;++r)S(J,L.start+r,L.nx,L.size,L.ny,L.nx*L.size,w)}!function(L,r,p){for(let J=0;J<p;++J)r[J]=L[r[J]]}(x,J,n);let b=0;const c=new Uint8Array(J.buffer.byteLength);for(let t=0;t<L.lines;t++)for(let r=0;r<L.channels;r++){const L=j[r],p=L.nx*L.size,i=new Uint8Array(J.buffer,L.end*G,p*G);c.set(i,b),b+=p*G,L.end+=p}return new DataView(c.buffer)}var nL,jL=p(11957);!function(L){L[L.Float=0]="Float",L[L.HalfFloat=1]="HalfFloat"}(nL||(nL={}));class zL{}async function GL(L,r,p,J){const i={size:0,viewer:r,array:new Uint8Array(r.buffer),offset:p,width:L.dataWindow.xMax-L.dataWindow.xMin+1,height:L.dataWindow.yMax-L.dataWindow.yMin+1,channels:L.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(L.compression){case h.NO_COMPRESSION:i.lines=1,i.uncompress=LL;break;case h.RLE_COMPRESSION:i.lines=1,i.uncompress=rL;break;case h.ZIPS_COMPRESSION:i.lines=1,i.uncompress=pL,await jL.Tools.LoadScriptAsync(zL.FFLATEUrl);break;case h.ZIP_COMPRESSION:i.lines=16,i.uncompress=pL,await jL.Tools.LoadScriptAsync(zL.FFLATEUrl);break;case h.PIZ_COMPRESSION:i.lines=32,i.uncompress=iL;break;case h.PXR24_COMPRESSION:i.lines=16,i.uncompress=JL,await jL.Tools.LoadScriptAsync(zL.FFLATEUrl);break;default:throw new Error(h[L.compression]+" is unsupported")}i.scanlineBlockSize=i.lines;const n={};for(const j of L.channels)switch(j.name){case"R":case"G":case"B":case"A":case"Y":n[j.name]=!0,i.type=j.pixelType}let z=!1;if(n.R&&n.G&&n.B&&n.A)i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G&&n.B)z=!0,i.outputChannels=4,i.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G)i.outputChannels=2,i.decodeChannels={R:0,G:1};else if(n.R)i.outputChannels=1,i.decodeChannels={R:0};else{if(!n.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");i.outputChannels=1,i.decodeChannels={Y:0}}if(1===i.type)switch(J){case nL.Float:i.getter=a,i.inputSize=G;break;case nL.HalfFloat:i.getter=v,i.inputSize=G}else{if(2!==i.type)throw new Error("Unsupported pixelType "+i.type+" for "+L.compression);switch(J){case nL.Float:i.getter=u,i.inputSize=j;break;case nL.HalfFloat:i.getter=q,i.inputSize=j}}i.blockCount=i.height/i.scanlineBlockSize;for(let j=0;j<i.blockCount;j++)A(r,p);const C=i.width*i.height*i.outputChannels;switch(J){case nL.Float:i.byteArray=new Float32Array(C),i.textureType=1,z&&i.byteArray.fill(1,0,C);break;case nL.HalfFloat:i.byteArray=new Uint16Array(C),i.textureType=2,z&&i.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+J)}let t=0;for(const j of L.channels)void 0!==i.decodeChannels[j.name]&&(i.channelLineOffsets[j.name]=t*i.width),t+=2*j.pixelType;return i.bytesPerLine=i.width*t,i.outLineWidth=i.width*i.outputChannels,"INCREASING_Y"===L.lineOrder?i.scanOrder=L=>L:i.scanOrder=L=>i.height-1-L,4==i.outputChannels?(i.format=5,i.linearSpace=!0):(i.format=6,i.linearSpace=!1),i}function CL(L,r,p,J){const i={value:0};for(let n=0;n<L.height/L.scanlineBlockSize;n++){const j=F(p,J)-r.dataWindow.yMin;L.size=Q(p,J),L.lines=j+L.scanlineBlockSize>L.height?L.height-j:L.scanlineBlockSize;const z=L.size<L.lines*L.bytesPerLine&&L.uncompress?L.uncompress(L):LL(L);J.value+=L.size;for(let p=0;p<L.scanlineBlockSize;p++){const J=n*L.scanlineBlockSize,j=p+L.scanOrder(J);if(j>=L.height)continue;const G=p*L.bytesPerLine,C=(L.height-1-j)*L.outLineWidth;for(let p=0;p<L.channels;p++){const J=r.channels[p].name,n=L.channelLineOffsets[J],j=L.decodeChannels[J];if(void 0!==j){i.value=G+n;for(let r=0;r<L.width;r++){const p=C+r*L.outputChannels+j;L.byteArray&&(L.byteArray[p]=L.getter(z,i))}}}}}}zL.DefaultOutputType=nL.HalfFloat,zL.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class tL{constructor(){this.supportCascades=!1}loadCubeData(L,r,p,J,i){throw".exr not supported in Cube."}loadData(L,r,p){const i=new DataView(L.buffer),n={value:0},j=T(i,n);GL(j,i,n,zL.DefaultOutputType).then((L=>{CL(L,j,i,n);const J=j.dataWindow.xMax-j.dataWindow.xMin+1,z=j.dataWindow.yMax-j.dataWindow.yMin+1;p(J,z,r.generateMipMaps,!1,(()=>{const p=r.getEngine();r.format=j.format,r.type=L.textureType,r.invertY=!1,r._gammaSpace=!j.linearSpace,L.byteArray&&p._uploadDataToTextureDirectly(r,L.byteArray,0,0,void 0,!0)}))})).catch((L=>{J.d.Error("Failed to load EXR texture: ",L)}))}}async function EL(L){const r=new DataView(L),p={value:0},i=T(r,p);try{const L=await GL(i,r,p,nL.Float);return CL(L,i,r,p),L.byteArray?{width:i.dataWindow.xMax-i.dataWindow.xMin+1,height:i.dataWindow.yMax-i.dataWindow.yMin+1,data:new Float32Array(L.byteArray)}:(J.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(n){J.d.Error("Failed to load EXR data: ",n)}return{width:0,height:0,data:null}}},12154:(L,r,p)=>{function J(L){return parseInt(L.toString().replace(/\W/g,""))}function i(L,r){let p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(L-r)<=p}function n(L,r,p){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return L<r-J||L>p+J}function j(L,r){return L===r?L:Math.random()*(r-L)+L}function z(L,r,p){return L+(r-L)*p}function G(L,r,p){let J=c(r-L,360);return J>180&&(J-=360),L+J*x(p)}function C(L,r,p){let J=0;return J=L!=r?x((p-L)/(r-L)):0,J}function t(L,r,p,J,i){const n=i*i,j=i*n;return L*(2*j-3*n+1)+p*(-2*j+3*n)+r*(j-2*n+i)+J*(j-n)}function E(L,r,p,J,i){const n=i*i;return 6*(n-i)*L+(3*n-4*i+1)*r+6*(-n+i)*p+(3*n-2*i)*J}function x(L){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,p=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(p,Math.max(r,L))}function w(L){return L-=2*Math.PI*Math.floor((L+Math.PI)/(2*Math.PI))}function g(L){const r=L.toString(16);return L<=15?("0"+r).toUpperCase():r.toUpperCase()}function b(L){if(Math.log2)return Math.floor(Math.log2(L));if(L<0)return NaN;if(0===L)return-1/0;let r=0;if(L<1){for(;L<1;)r++,L*=2;r=-r}else if(L>1)for(;L>1;)r++,L=Math.floor(L/2);return r}function c(L,r){return L-Math.floor(L/r)*r}function P(L,r,p){return(L-r)/(p-r)}function O(L,r,p){return L*(p-r)+r}function h(L,r){let p=c(r-L,360);return p>180&&(p-=360),p}function U(L,r){const p=c(L,2*r);return r-Math.abs(p-r)}function W(L,r,p){let J=x(p);return J=-2*J*J*J+3*J*J,r*J+L*(1-J)}function B(L,r,p){let J=0;return J=Math.abs(r-L)<=p?r:L+Math.sign(r-L)*p,J}function F(L,r,p){const J=h(L,r);let i=0;return i=-p<J&&J<p?r:B(L,r=L+J,p),i}function Q(L,r,p){return(L-r)/(p-r)}function e(L,r,p){return(p-r)*L+r}function v(L,r){const p=L%r;return 0===p?r:v(r,p)}p.r(r),p.d(r,{Clamp:()=>x,DeltaAngle:()=>h,Denormalize:()=>O,ExtractAsInt:()=>J,Hermite:()=>t,Hermite1stDerivative:()=>E,HighestCommonFactor:()=>v,ILog2:()=>b,InverseLerp:()=>C,Lerp:()=>z,LerpAngle:()=>G,MoveTowards:()=>B,MoveTowardsAngle:()=>F,Normalize:()=>P,NormalizeRadians:()=>w,OutsideRange:()=>n,PercentToRange:()=>e,PingPong:()=>U,RandomRange:()=>j,RangeToPercent:()=>Q,Repeat:()=>c,SmoothStep:()=>W,ToHex:()=>g,WithinEpsilon:()=>i})}}]);