"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[16],{13670:(V,I,A)=>{A.r(I),A.d(I,{ReadExrDataAsync:()=>PV,_ExrTextureLoader:()=>XV});var B=A(11064),F=A(11249);const E=4,Y=4,H=1,c=2,b=8,X=65536,P=X>>3,J=14,G=65537,w=1<<J,t=w-1,u=59,W=63,g=2+W-u;var o,L;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(o||(o={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(L||(L={}));const z=function(){const V=new ArrayBuffer(4),I=new Float32Array(V),A=new Uint32Array(V),B=new Uint32Array(512),F=new Uint32Array(512);for(let c=0;c<256;++c){const V=c-127;V<-27?(B[c]=0,B[256|c]=32768,F[c]=24,F[256|c]=24):V<-14?(B[c]=1024>>-V-14,B[256|c]=1024>>-V-14|32768,F[c]=-V-1,F[256|c]=-V-1):V<=15?(B[c]=V+15<<10,B[256|c]=V+15<<10|32768,F[c]=13,F[256|c]=13):V<128?(B[c]=31744,B[256|c]=64512,F[c]=24,F[256|c]=24):(B[c]=31744,B[256|c]=64512,F[c]=13,F[256|c]=13)}const E=new Uint32Array(2048),Y=new Uint32Array(64),H=new Uint32Array(64);for(let c=1;c<1024;++c){let V=c<<13,I=0;for(;0===(8388608&V);)V<<=1,I-=8388608;V&=-8388609,I+=947912704,E[c]=V|I}for(let c=1024;c<2048;++c)E[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)Y[c]=c<<23;Y[31]=1199570944,Y[32]=2147483648;for(let c=33;c<63;++c)Y[c]=2147483648+(c-32<<23);Y[63]=3347054592;for(let c=1;c<64;++c)32!==c&&(H[c]=1024);return{floatView:I,uint32View:A,baseTable:B,shiftTable:F,mantissaTable:E,exponentTable:Y,offsetTable:H}}();function m(V,I){const A=new Uint8Array(V);let B=0;for(;0!=A[I.value+B];)B+=1;const F=(new TextDecoder).decode(A.slice(I.value,I.value+B));return I.value=I.value+B+1,F}function s(V,I){const A=V.getInt32(I.value,!0);return I.value+=E,A}function e(V,I){const A=V.getUint32(I.value,!0);return I.value+=E,A}function S(V,I){const A=V.getUint8(I.value);return I.value+=H,A}function Q(V,I){const A=V.getUint16(I.value,!0);return I.value+=c,A}function h(V,I){const A=V[I.value];return I.value+=H,A}function r(V,I){let A;return A="getBigInt64"in DataView.prototype?Number(V.getBigInt64(I.value,!0)):V.getUint32(I.value+4,!0)+Number(V.getUint32(I.value,!0)<<32),I.value+=b,A}function M(V,I){const A=V.getFloat32(I.value,!0);return I.value+=Y,A}function x(V,I){return function(V){const I=(31744&V)>>10,A=1023&V;return(V>>15?-1:1)*(I?31===I?A?NaN:1/0:Math.pow(2,I-15)*(1+A/1024):A/1024*6103515625e-14)}(Q(V,I))}function f(V,I){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,F.Clamp)(V,-65504,65504),z.floatView[0]=V;const I=z.uint32View[0],A=I>>23&511;return z.baseTable[A]+((8388607&I)>>z.shiftTable[A])}(M(V,I))}function R(V,I,A,B){switch(A){case"string":case"stringvector":case"iccProfile":return function(V,I,A){const B=(new TextDecoder).decode(new Uint8Array(V).slice(I.value,I.value+A));return I.value=I.value+A,B}(V.buffer,I,B);case"chlist":return function(V,I,A){const B=I.value,F=[];for(;I.value<B+A-1;){const A=m(V.buffer,I),B=s(V,I),E=S(V,I);I.value+=3;const Y=s(V,I),H=s(V,I);F.push({name:A,pixelType:B,pLinear:E,xSampling:Y,ySampling:H})}return I.value+=1,F}(V,I,B);case"chromaticities":return function(V,I){return{redX:M(V,I),redY:M(V,I),greenX:M(V,I),greenY:M(V,I),blueX:M(V,I),blueY:M(V,I),whiteX:M(V,I),whiteY:M(V,I)}}(V,I);case"compression":return function(V,I){return S(V,I)}(V,I);case"box2i":return function(V,I){return{xMin:s(V,I),yMin:s(V,I),xMax:s(V,I),yMax:s(V,I)}}(V,I);case"lineOrder":return function(V,I){const A=S(V,I);return L[A]}(V,I);case"float":return M(V,I);case"v2f":return function(V,I){return[M(V,I),M(V,I)]}(V,I);case"v3f":return function(V,I){return[M(V,I),M(V,I),M(V,I)]}(V,I);case"int":return s(V,I);case"rational":return function(V,I){return[s(V,I),e(V,I)]}(V,I);case"timecode":return function(V,I){return[e(V,I),e(V,I)]}(V,I);case"preview":return I.value+=B,"skipped";default:return void(I.value+=B)}}function q(V){for(let I=1;I<V.length;I++){const A=V[I-1]+V[I]-128;V[I]=A}}function N(V,I){let A=0,B=Math.floor((V.length+1)/2),F=0;const E=V.length-1;for(;!(F>E)&&(I[F++]=V[A++],!(F>E));)I[F++]=V[B++]}const l=20000630;function i(V,I){if(V.getUint32(0,!0)!=l)throw new Error("Incorrect OpenEXR format");const A=V.getUint8(4),F=V.getUint8(5),E={singleTile:!!(2&F),longName:!!(4&F),deepFormat:!!(8&F),multiPart:!!(16&F)};I.value=8;const Y={};let H=!0;for(;H;){const A=m(V.buffer,I);if(A){const F=m(V.buffer,I),E=R(V,I,F,e(V,I));void 0===E?B.b.Warn(`Unknown header attribute type ${F}'.`):Y[A]=E}else H=!1}if(0!=(-5&F))throw new Error("Unsupported file format");return{version:A,spec:E,...Y}}const y=32768,v=65535;function C(V,I,A,B,F){for(;A<V;)I=I<<8|h(B,F),A+=8;return{l:I>>(A-=V)&(1<<V)-1,c:I,lc:A}}function K(V,I,A,B){return{c:V=V<<8|h(A,B),lc:I+=8}}function p(V,I,A,B,F,E,Y,H,c){if(V==I){if(B<8){const V=K(A,B,F,E);A=V.c,B=V.lc}let V=A>>(B-=8);if(V=new Uint8Array([V])[0],H.value+V>c)return null;const I=Y[H.value-1];for(;V-- >0;)Y[H.value++]=I}else{if(!(H.value<c))return null;Y[H.value++]=V}return{c:A,lc:B}}const j=new Array(59);function T(V,I,A,B,F,E){const Y=I;let H=0,c=0;for(;B<=F;B++){if(Y.value-I.value>A)return;let b=C(6,H,c,V,Y);const X=b.l;if(H=b.c,c=b.lc,E[B]=X,X==W){if(Y.value-I.value>A)throw new Error("Error in HufUnpackEncTable");b=C(8,H,c,V,Y);let X=b.l+g;if(H=b.c,c=b.lc,B+X>F+1)throw new Error("Error in HufUnpackEncTable");for(;X--;)E[B++]=0;B--}else if(X>=u){let V=X-u+2;if(B+V>F+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)E[B++]=0;B--}}!function(V){for(let A=0;A<=58;++A)j[A]=0;for(let A=0;A<G;++A)j[V[A]]+=1;let I=0;for(let A=58;A>0;--A){const V=I+j[A]>>1;j[A]=I,I=V}for(let A=0;A<G;++A){const I=V[A];I>0&&(V[A]=I|j[I]++<<6)}}(E)}function d(V){return 63&V}function D(V){return V>>6}function O(V,I,A,B,F,E){const Y=A.value,H=e(I,A),c=e(I,A);A.value+=4;const b=e(I,A);if(A.value+=4,H<0||H>=G||c<0||c>=G)throw new Error("Wrong HUF_ENCSIZE");const X=new Array(G),P=new Array(w);!function(V){for(let I=0;I<w;I++)V[I]={},V[I].len=0,V[I].lit=0,V[I].p=null}(P);if(T(V,A,B-(A.value-Y),H,c,X),b>8*(B-(A.value-Y)))throw new Error("Wrong hufUncompress");!function(V,I,A,B){for(;I<=A;I++){const A=D(V[I]),F=d(V[I]);if(A>>F)throw new Error("Invalid table entry");if(F>J){const V=B[A>>F-J];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const I=V.p;V.p=new Array(V.lit);for(let A=0;A<V.lit-1;++A)V.p[A]=I[A]}else V.p=new Array(1);V.p[V.lit-1]=I}else if(F){let V=0;for(let E=1<<J-F;E>0;E--){const E=B[(A<<J-F)+V];if(E.len||E.p)throw new Error("Invalid table entry");E.len=F,E.lit=I,V++}}}}(X,H,c,P),function(V,I,A,B,F,E,Y,H,c){let b=0,X=0;const P=Y,G=Math.trunc(B.value+(F+7)/8);for(;B.value<G;){let F=K(b,X,A,B);for(b=F.c,X=F.lc;X>=J;){const Y=I[b>>X-J&t];if(Y.len){X-=Y.len;const V=p(Y.lit,E,b,X,A,B,H,c,P);V&&(b=V.c,X=V.lc)}else{if(!Y.p)throw new Error("hufDecode issues");let I;for(I=0;I<Y.lit;I++){const J=d(V[Y.p[I]]);for(;X<J&&B.value<G;)F=K(b,X,A,B),b=F.c,X=F.lc;if(X>=J&&D(V[Y.p[I]])==(b>>X-J&(1<<J)-1)){X-=J;const V=p(Y.p[I],E,b,X,A,B,H,c,P);V&&(b=V.c,X=V.lc);break}}if(I==Y.lit)throw new Error("HufDecode issues")}}}const w=8-F&7;for(b>>=w,X-=w;X>0;){const V=I[b<<J-X&t];if(!V.len)throw new Error("HufDecode issues");{X-=V.len;const I=p(V.lit,E,b,X,A,B,H,c,P);I&&(b=I.c,X=I.lc)}}}(X,P,V,A,b,c,E,F,{value:0})}function Z(V){return 65535&V}function a(V){const I=Z(V);return I>32767?I-65536:I}function k(V,I){const A=a(V),B=a(I),F=A+(1&B)+(B>>1);return{a:F,b:F-B}}function U(V,I){const A=Z(V),B=Z(I),F=A-(B>>1)&v;return{a:B+F-y&v,b:F}}function n(V,I,A,B,F,E,Y){const H=Y<16384,c=A>F?F:A;let b,X,P=1;for(;P<=c;)P<<=1;for(P>>=1,b=P,P>>=1;P>=1;){X=0;const Y=X+E*(F-b),c=E*P,J=E*b,G=B*P,w=B*b;let t,u,W,g;for(;X<=Y;X+=J){let F=X;const E=X+B*(A-b);for(;F<=E;F+=w){const A=F+G,B=F+c,E=B+G;if(H){let Y=k(V[F+I],V[B+I]);t=Y.a,W=Y.b,Y=k(V[A+I],V[E+I]),u=Y.a,g=Y.b,Y=k(t,u),V[F+I]=Y.a,V[A+I]=Y.b,Y=k(W,g),V[B+I]=Y.a,V[E+I]=Y.b}else{let Y=U(V[F+I],V[B+I]);t=Y.a,W=Y.b,Y=U(V[A+I],V[E+I]),u=Y.a,g=Y.b,Y=U(t,u),V[F+I]=Y.a,V[A+I]=Y.b,Y=U(W,g),V[B+I]=Y.a,V[E+I]=Y.b}}if(A&P){const A=F+c;let B;B=H?k(V[F+I],V[A+I]):U(V[F+I],V[A+I]),t=B.a,V[A+I]=B.b,V[F+I]=t}}if(F&P){let F=X;const E=X+B*(A-b);for(;F<=E;F+=w){const A=F+G;let B;B=H?k(V[F+I],V[A+I]):U(V[F+I],V[A+I]),t=B.a,V[A+I]=B.b,V[F+I]=t}}b=P,P>>=1}return X}function VV(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function IV(V){const I=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),A=new Uint8Array(function(V){let I=V.byteLength;const A=[];let B=0;const F=new DataView(V);for(;I>0;){const V=F.getInt8(B++);if(V<0){const E=-V;I-=E+1;for(let V=0;V<E;V++)A.push(F.getUint8(B++))}else{const E=V;I-=2;const Y=F.getUint8(B++);for(let V=0;V<E+1;V++)A.push(Y)}}return A}(I)),B=new Uint8Array(A.length);return q(A),N(A,B),new DataView(B.buffer)}function AV(V){const I=V.array.slice(V.offset.value,V.offset.value+V.size),A=fflate.unzlibSync(I),B=new Uint8Array(A.length);return q(A),N(A,B),new DataView(B.buffer)}function BV(V){const I=V.array.slice(V.offset.value,V.offset.value+V.size),A=fflate.unzlibSync(I),B=V.lines*V.channels*V.width,F=1==V.type?new Uint16Array(B):new Uint32Array(B);let E=0,Y=0;const H=new Array(4);for(let c=0;c<V.lines;c++)for(let I=0;I<V.channels;I++){let I=0;switch(V.type){case 1:H[0]=E,H[1]=H[0]+V.width,E=H[1]+V.width;for(let B=0;B<V.width;++B){I+=A[H[0]++]<<8|A[H[1]++],F[Y]=I,Y++}break;case 2:H[0]=E,H[1]=H[0]+V.width,H[2]=H[1]+V.width,E=H[2]+V.width;for(let B=0;B<V.width;++B){I+=A[H[0]++]<<24|A[H[1]++]<<16|A[H[2]++]<<8,F[Y]=I,Y++}}}return new DataView(F.buffer)}function FV(V){const I=V.viewer,A={value:V.offset.value},B=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),F=new Uint8Array(P);let E=0;const Y=new Array(V.channels);for(let c=0;c<V.channels;c++)Y[c]={},Y[c].start=E,Y[c].end=Y[c].start,Y[c].nx=V.width,Y[c].ny=V.lines,Y[c].size=V.type,E+=Y[c].nx*Y[c].ny*Y[c].size;const H=Q(I,A),b=Q(I,A);if(b>=P)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(H<=b)for(let c=0;c<b-H+1;c++)F[c+H]=S(I,A);const J=new Uint16Array(X),G=function(V,I){let A=0;for(let F=0;F<X;++F)(0==F||V[F>>3]&1<<(7&F))&&(I[A++]=F);const B=A-1;for(;A<X;)I[A++]=0;return B}(F,J),w=e(I,A);O(V.array,I,A,w,B,E);for(let c=0;c<V.channels;++c){const V=Y[c];for(let I=0;I<Y[c].size;++I)n(B,V.start+I,V.nx,V.size,V.ny,V.nx*V.size,G)}!function(V,I,A){for(let B=0;B<A;++B)I[B]=V[I[B]]}(J,B,E);let t=0;const u=new Uint8Array(B.buffer.byteLength);for(let X=0;X<V.lines;X++)for(let I=0;I<V.channels;I++){const V=Y[I],A=V.nx*V.size,F=new Uint8Array(B.buffer,V.end*c,A*c);u.set(F,t),t+=A*c,V.end+=A}return new DataView(u.buffer)}var EV,YV=A(11052);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(EV||(EV={}));class HV{}async function cV(V,I,A,B){const F={size:0,viewer:I,array:new Uint8Array(I.buffer),offset:A,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case o.NO_COMPRESSION:F.lines=1,F.uncompress=VV;break;case o.RLE_COMPRESSION:F.lines=1,F.uncompress=IV;break;case o.ZIPS_COMPRESSION:F.lines=1,F.uncompress=AV,await YV.Tools.LoadScriptAsync(HV.FFLATEUrl);break;case o.ZIP_COMPRESSION:F.lines=16,F.uncompress=AV,await YV.Tools.LoadScriptAsync(HV.FFLATEUrl);break;case o.PIZ_COMPRESSION:F.lines=32,F.uncompress=FV;break;case o.PXR24_COMPRESSION:F.lines=16,F.uncompress=BV,await YV.Tools.LoadScriptAsync(HV.FFLATEUrl);break;default:throw new Error(o[V.compression]+" is unsupported")}F.scanlineBlockSize=F.lines;const E={};for(const Y of V.channels)switch(Y.name){case"R":case"G":case"B":case"A":case"Y":E[Y.name]=!0,F.type=Y.pixelType}let H=!1;if(E.R&&E.G&&E.B&&E.A)F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else if(E.R&&E.G&&E.B)H=!0,F.outputChannels=4,F.decodeChannels={R:0,G:1,B:2,A:3};else if(E.R&&E.G)F.outputChannels=2,F.decodeChannels={R:0,G:1};else if(E.R)F.outputChannels=1,F.decodeChannels={R:0};else{if(!E.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");F.outputChannels=1,F.decodeChannels={Y:0}}if(1===F.type)switch(B){case EV.Float:F.getter=x,F.inputSize=c;break;case EV.HalfFloat:F.getter=Q,F.inputSize=c}else{if(2!==F.type)throw new Error("Unsupported pixelType "+F.type+" for "+V.compression);switch(B){case EV.Float:F.getter=M,F.inputSize=Y;break;case EV.HalfFloat:F.getter=f,F.inputSize=Y}}F.blockCount=F.height/F.scanlineBlockSize;for(let Y=0;Y<F.blockCount;Y++)r(I,A);const b=F.width*F.height*F.outputChannels;switch(B){case EV.Float:F.byteArray=new Float32Array(b),F.textureType=1,H&&F.byteArray.fill(1,0,b);break;case EV.HalfFloat:F.byteArray=new Uint16Array(b),F.textureType=2,H&&F.byteArray.fill(15360,0,b);break;default:throw new Error("Unsupported type: "+B)}let X=0;for(const Y of V.channels)void 0!==F.decodeChannels[Y.name]&&(F.channelLineOffsets[Y.name]=X*F.width),X+=2*Y.pixelType;return F.bytesPerLine=F.width*X,F.outLineWidth=F.width*F.outputChannels,"INCREASING_Y"===V.lineOrder?F.scanOrder=V=>V:F.scanOrder=V=>F.height-1-V,4==F.outputChannels?(F.format=5,F.linearSpace=!0):(F.format=6,F.linearSpace=!1),F}function bV(V,I,A,B){const F={value:0};for(let E=0;E<V.height/V.scanlineBlockSize;E++){const Y=s(A,B)-I.dataWindow.yMin;V.size=e(A,B),V.lines=Y+V.scanlineBlockSize>V.height?V.height-Y:V.scanlineBlockSize;const H=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):VV(V);B.value+=V.size;for(let A=0;A<V.scanlineBlockSize;A++){const B=E*V.scanlineBlockSize,Y=A+V.scanOrder(B);if(Y>=V.height)continue;const c=A*V.bytesPerLine,b=(V.height-1-Y)*V.outLineWidth;for(let A=0;A<V.channels;A++){const B=I.channels[A].name,E=V.channelLineOffsets[B],Y=V.decodeChannels[B];if(void 0!==Y){F.value=c+E;for(let I=0;I<V.width;I++){const A=b+I*V.outputChannels+Y;V.byteArray&&(V.byteArray[A]=V.getter(H,F))}}}}}}HV.DefaultOutputType=EV.HalfFloat,HV.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class XV{constructor(){this.supportCascades=!1}loadCubeData(V,I,A,B,F){throw".exr not supported in Cube."}loadData(V,I,A){const F=new DataView(V.buffer),E={value:0},Y=i(F,E);cV(Y,F,E,HV.DefaultOutputType).then((V=>{bV(V,Y,F,E);const B=Y.dataWindow.xMax-Y.dataWindow.xMin+1,H=Y.dataWindow.yMax-Y.dataWindow.yMin+1;A(B,H,I.generateMipMaps,!1,(()=>{const A=I.getEngine();I.format=Y.format,I.type=V.textureType,I.invertY=!1,I._gammaSpace=!Y.linearSpace,V.byteArray&&A._uploadDataToTextureDirectly(I,V.byteArray,0,0,void 0,!0)}))})).catch((V=>{B.b.Error("Failed to load EXR texture: ",V)}))}}async function PV(V){const I=new DataView(V),A={value:0},F=i(I,A);try{const V=await cV(F,I,A,EV.Float);return bV(V,F,I,A),V.byteArray?{width:F.dataWindow.xMax-F.dataWindow.xMin+1,height:F.dataWindow.yMax-F.dataWindow.yMin+1,data:new Float32Array(V.byteArray)}:(B.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(E){B.b.Error("Failed to load EXR data: ",E)}return{width:0,height:0,data:null}}},11249:(V,I,A)=>{function B(V){return parseInt(V.toString().replace(/\W/g,""))}function F(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(V-I)<=A}function E(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return V<I-B||V>A+B}function Y(V,I){return V===I?V:Math.random()*(I-V)+V}function H(V,I,A){return V+(I-V)*A}function c(V,I,A){let B=u(I-V,360);return B>180&&(B-=360),V+B*J(A)}function b(V,I,A){let B=0;return B=V!=I?J((A-V)/(I-V)):0,B}function X(V,I,A,B,F){const E=F*F,Y=F*E;return V*(2*Y-3*E+1)+A*(-2*Y+3*E)+I*(Y-2*E+F)+B*(Y-E)}function P(V,I,A,B,F){const E=F*F;return 6*(E-F)*V+(3*E-4*F+1)*I+6*(-E+F)*A+(3*E-2*F)*B}function J(V){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(A,Math.max(I,V))}function G(V){return V-=2*Math.PI*Math.floor((V+Math.PI)/(2*Math.PI))}function w(V){const I=V.toString(16);return V<=15?("0"+I).toUpperCase():I.toUpperCase()}function t(V){if(Math.log2)return Math.floor(Math.log2(V));if(V<0)return NaN;if(0===V)return-1/0;let I=0;if(V<1){for(;V<1;)I++,V*=2;I=-I}else if(V>1)for(;V>1;)I++,V=Math.floor(V/2);return I}function u(V,I){return V-Math.floor(V/I)*I}function W(V,I,A){return(V-I)/(A-I)}function g(V,I,A){return V*(A-I)+I}function o(V,I){let A=u(I-V,360);return A>180&&(A-=360),A}function L(V,I){const A=u(V,2*I);return I-Math.abs(A-I)}function z(V,I,A){let B=J(A);return B=-2*B*B*B+3*B*B,I*B+V*(1-B)}function m(V,I,A){let B=0;return B=Math.abs(I-V)<=A?I:V+Math.sign(I-V)*A,B}function s(V,I,A){const B=o(V,I);let F=0;return F=-A<B&&B<A?I:m(V,I=V+B,A),F}function e(V,I,A){return(V-I)/(A-I)}function S(V,I,A){return(A-I)*V+I}function Q(V,I){const A=V%I;return 0===A?I:Q(I,A)}A.r(I),A.d(I,{Clamp:()=>J,DeltaAngle:()=>o,Denormalize:()=>g,ExtractAsInt:()=>B,Hermite:()=>X,Hermite1stDerivative:()=>P,HighestCommonFactor:()=>Q,ILog2:()=>t,InverseLerp:()=>b,Lerp:()=>H,LerpAngle:()=>c,MoveTowards:()=>m,MoveTowardsAngle:()=>s,Normalize:()=>W,NormalizeRadians:()=>G,OutsideRange:()=>E,PercentToRange:()=>S,PingPong:()=>L,RandomRange:()=>Y,RangeToPercent:()=>e,Repeat:()=>u,SmoothStep:()=>z,ToHex:()=>w,WithinEpsilon:()=>F})}}]);