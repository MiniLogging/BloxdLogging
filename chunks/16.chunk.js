"use strict";(self["269hv5nclphh"]=self["269hv5nclphh"]||[]).push([[16],{14871:(E,H,d)=>{d.r(H),d.d(H,{ReadExrDataAsync:()=>ME,_ExrTextureLoader:()=>SE});var n=d(12237),Z=d(12406);const I=4,g=4,l=1,r=2,t=8,S=65536,M=S>>3,V=14,C=65537,w=1<<V,R=w-1,Q=59,L=63,D=2+L-Q;var e,s;!function(E){E[E.NO_COMPRESSION=0]="NO_COMPRESSION",E[E.RLE_COMPRESSION=1]="RLE_COMPRESSION",E[E.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",E[E.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",E[E.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",E[E.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(e||(e={})),function(E){E[E.INCREASING_Y=0]="INCREASING_Y",E[E.DECREASING_Y=1]="DECREASING_Y"}(s||(s={}));const i=function(){const E=new ArrayBuffer(4),H=new Float32Array(E),d=new Uint32Array(E),n=new Uint32Array(512),Z=new Uint32Array(512);for(let r=0;r<256;++r){const E=r-127;E<-27?(n[r]=0,n[256|r]=32768,Z[r]=24,Z[256|r]=24):E<-14?(n[r]=1024>>-E-14,n[256|r]=1024>>-E-14|32768,Z[r]=-E-1,Z[256|r]=-E-1):E<=15?(n[r]=E+15<<10,n[256|r]=E+15<<10|32768,Z[r]=13,Z[256|r]=13):E<128?(n[r]=31744,n[256|r]=64512,Z[r]=24,Z[256|r]=24):(n[r]=31744,n[256|r]=64512,Z[r]=13,Z[256|r]=13)}const I=new Uint32Array(2048),g=new Uint32Array(64),l=new Uint32Array(64);for(let r=1;r<1024;++r){let E=r<<13,H=0;for(;0===(8388608&E);)E<<=1,H-=8388608;E&=-8388609,H+=947912704,I[r]=E|H}for(let r=1024;r<2048;++r)I[r]=939524096+(r-1024<<13);for(let r=1;r<31;++r)g[r]=r<<23;g[31]=1199570944,g[32]=2147483648;for(let r=33;r<63;++r)g[r]=2147483648+(r-32<<23);g[63]=3347054592;for(let r=1;r<64;++r)32!==r&&(l[r]=1024);return{floatView:H,uint32View:d,baseTable:n,shiftTable:Z,mantissaTable:I,exponentTable:g,offsetTable:l}}();function p(E,H){const d=new Uint8Array(E);let n=0;for(;0!=d[H.value+n];)n+=1;const Z=(new TextDecoder).decode(d.slice(H.value,H.value+n));return H.value=H.value+n+1,Z}function f(E,H){const d=E.getInt32(H.value,!0);return H.value+=I,d}function P(E,H){const d=E.getUint32(H.value,!0);return H.value+=I,d}function j(E,H){const d=E.getUint8(H.value);return H.value+=l,d}function X(E,H){const d=E.getUint16(H.value,!0);return H.value+=r,d}function W(E,H){const d=E[H.value];return H.value+=l,d}function U(E,H){let d;return d="getBigInt64"in DataView.prototype?Number(E.getBigInt64(H.value,!0)):E.getUint32(H.value+4,!0)+Number(E.getUint32(H.value,!0)<<32),H.value+=t,d}function Y(E,H){const d=E.getFloat32(H.value,!0);return H.value+=g,d}function c(E,H){return function(E){const H=(31744&E)>>10,d=1023&E;return(E>>15?-1:1)*(H?31===H?d?NaN:1/0:Math.pow(2,H-15)*(1+d/1024):d/1024*6103515625e-14)}(X(E,H))}function u(E,H){return function(E){if(Math.abs(E)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");E=(0,Z.Clamp)(E,-65504,65504),i.floatView[0]=E;const H=i.uint32View[0],d=H>>23&511;return i.baseTable[d]+((8388607&H)>>i.shiftTable[d])}(Y(E,H))}function o(E,H,d,n){switch(d){case"string":case"stringvector":case"iccProfile":return function(E,H,d){const n=(new TextDecoder).decode(new Uint8Array(E).slice(H.value,H.value+d));return H.value=H.value+d,n}(E.buffer,H,n);case"chlist":return function(E,H,d){const n=H.value,Z=[];for(;H.value<n+d-1;){const d=p(E.buffer,H),n=f(E,H),I=j(E,H);H.value+=3;const g=f(E,H),l=f(E,H);Z.push({name:d,pixelType:n,pLinear:I,xSampling:g,ySampling:l})}return H.value+=1,Z}(E,H,n);case"chromaticities":return function(E,H){return{redX:Y(E,H),redY:Y(E,H),greenX:Y(E,H),greenY:Y(E,H),blueX:Y(E,H),blueY:Y(E,H),whiteX:Y(E,H),whiteY:Y(E,H)}}(E,H);case"compression":return function(E,H){return j(E,H)}(E,H);case"box2i":return function(E,H){return{xMin:f(E,H),yMin:f(E,H),xMax:f(E,H),yMax:f(E,H)}}(E,H);case"lineOrder":return function(E,H){const d=j(E,H);return s[d]}(E,H);case"float":return Y(E,H);case"v2f":return function(E,H){return[Y(E,H),Y(E,H)]}(E,H);case"v3f":return function(E,H){return[Y(E,H),Y(E,H),Y(E,H)]}(E,H);case"int":return f(E,H);case"rational":return function(E,H){return[f(E,H),P(E,H)]}(E,H);case"timecode":return function(E,H){return[P(E,H),P(E,H)]}(E,H);case"preview":return H.value+=n,"skipped";default:return void(H.value+=n)}}function F(E){for(let H=1;H<E.length;H++){const d=E[H-1]+E[H]-128;E[H]=d}}function a(E,H){let d=0,n=Math.floor((E.length+1)/2),Z=0;const I=E.length-1;for(;!(Z>I)&&(H[Z++]=E[d++],!(Z>I));)H[Z++]=E[n++]}const k=20000630;function O(E,H){if(E.getUint32(0,!0)!=k)throw new Error("Incorrect OpenEXR format");const d=E.getUint8(4),Z=E.getUint8(5),I={singleTile:!!(2&Z),longName:!!(4&Z),deepFormat:!!(8&Z),multiPart:!!(16&Z)};H.value=8;const g={};let l=!0;for(;l;){const d=p(E.buffer,H);if(d){const Z=p(E.buffer,H),I=o(E,H,Z,P(E,H));void 0===I?n.b.Warn(`Unknown header attribute type ${Z}'.`):g[d]=I}else l=!1}if(0!=(-5&Z))throw new Error("Unsupported file format");return{version:d,spec:I,...g}}const G=32768,x=65535;function q(E,H,d,n,Z){for(;d<E;)H=H<<8|W(n,Z),d+=8;return{l:H>>(d-=E)&(1<<E)-1,c:H,lc:d}}function b(E,H,d,n){return{c:E=E<<8|W(d,n),lc:H+=8}}function h(E,H,d,n,Z,I,g,l,r){if(E==H){if(n<8){const E=b(d,n,Z,I);d=E.c,n=E.lc}let E=d>>(n-=8);if(E=new Uint8Array([E])[0],l.value+E>r)return null;const H=g[l.value-1];for(;E-- >0;)g[l.value++]=H}else{if(!(l.value<r))return null;g[l.value++]=E}return{c:d,lc:n}}const y=new Array(59);function v(E,H,d,n,Z,I){const g=H;let l=0,r=0;for(;n<=Z;n++){if(g.value-H.value>d)return;let t=q(6,l,r,E,g);const S=t.l;if(l=t.c,r=t.lc,I[n]=S,S==L){if(g.value-H.value>d)throw new Error("Error in HufUnpackEncTable");t=q(8,l,r,E,g);let S=t.l+D;if(l=t.c,r=t.lc,n+S>Z+1)throw new Error("Error in HufUnpackEncTable");for(;S--;)I[n++]=0;n--}else if(S>=Q){let E=S-Q+2;if(n+E>Z+1)throw new Error("Error in HufUnpackEncTable");for(;E--;)I[n++]=0;n--}}!function(E){for(let d=0;d<=58;++d)y[d]=0;for(let d=0;d<C;++d)y[E[d]]+=1;let H=0;for(let d=58;d>0;--d){const E=H+y[d]>>1;y[d]=H,H=E}for(let d=0;d<C;++d){const H=E[d];H>0&&(E[d]=H|y[H]++<<6)}}(I)}function z(E){return 63&E}function K(E){return E>>6}function N(E,H,d,n,Z,I){const g=d.value,l=P(H,d),r=P(H,d);d.value+=4;const t=P(H,d);if(d.value+=4,l<0||l>=C||r<0||r>=C)throw new Error("Wrong HUF_ENCSIZE");const S=new Array(C),M=new Array(w);!function(E){for(let H=0;H<w;H++)E[H]={},E[H].len=0,E[H].lit=0,E[H].p=null}(M);if(v(E,d,n-(d.value-g),l,r,S),t>8*(n-(d.value-g)))throw new Error("Wrong hufUncompress");!function(E,H,d,n){for(;H<=d;H++){const d=K(E[H]),Z=z(E[H]);if(d>>Z)throw new Error("Invalid table entry");if(Z>V){const E=n[d>>Z-V];if(E.len)throw new Error("Invalid table entry");if(E.lit++,E.p){const H=E.p;E.p=new Array(E.lit);for(let d=0;d<E.lit-1;++d)E.p[d]=H[d]}else E.p=new Array(1);E.p[E.lit-1]=H}else if(Z){let E=0;for(let I=1<<V-Z;I>0;I--){const I=n[(d<<V-Z)+E];if(I.len||I.p)throw new Error("Invalid table entry");I.len=Z,I.lit=H,E++}}}}(S,l,r,M),function(E,H,d,n,Z,I,g,l,r){let t=0,S=0;const M=g,C=Math.trunc(n.value+(Z+7)/8);for(;n.value<C;){let Z=b(t,S,d,n);for(t=Z.c,S=Z.lc;S>=V;){const g=H[t>>S-V&R];if(g.len){S-=g.len;const E=h(g.lit,I,t,S,d,n,l,r,M);E&&(t=E.c,S=E.lc)}else{if(!g.p)throw new Error("hufDecode issues");let H;for(H=0;H<g.lit;H++){const V=z(E[g.p[H]]);for(;S<V&&n.value<C;)Z=b(t,S,d,n),t=Z.c,S=Z.lc;if(S>=V&&K(E[g.p[H]])==(t>>S-V&(1<<V)-1)){S-=V;const E=h(g.p[H],I,t,S,d,n,l,r,M);E&&(t=E.c,S=E.lc);break}}if(H==g.lit)throw new Error("HufDecode issues")}}}const w=8-Z&7;for(t>>=w,S-=w;S>0;){const E=H[t<<V-S&R];if(!E.len)throw new Error("HufDecode issues");{S-=E.len;const H=h(E.lit,I,t,S,d,n,l,r,M);H&&(t=H.c,S=H.lc)}}}(S,M,E,d,t,r,I,Z,{value:0})}function mE(E){return 65535&E}function T(E){const H=mE(E);return H>32767?H-65536:H}function A(E,H){const d=T(E),n=T(H),Z=d+(1&n)+(n>>1);return{a:Z,b:Z-n}}function B(E,H){const d=mE(E),n=mE(H),Z=d-(n>>1)&x;return{a:n+Z-G&x,b:Z}}function J(E,H,d,n,Z,I,g){const l=g<16384,r=d>Z?Z:d;let t,S,M=1;for(;M<=r;)M<<=1;for(M>>=1,t=M,M>>=1;M>=1;){S=0;const g=S+I*(Z-t),r=I*M,V=I*t,C=n*M,w=n*t;let R,Q,L,D;for(;S<=g;S+=V){let Z=S;const I=S+n*(d-t);for(;Z<=I;Z+=w){const d=Z+C,n=Z+r,I=n+C;if(l){let g=A(E[Z+H],E[n+H]);R=g.a,L=g.b,g=A(E[d+H],E[I+H]),Q=g.a,D=g.b,g=A(R,Q),E[Z+H]=g.a,E[d+H]=g.b,g=A(L,D),E[n+H]=g.a,E[I+H]=g.b}else{let g=B(E[Z+H],E[n+H]);R=g.a,L=g.b,g=B(E[d+H],E[I+H]),Q=g.a,D=g.b,g=B(R,Q),E[Z+H]=g.a,E[d+H]=g.b,g=B(L,D),E[n+H]=g.a,E[I+H]=g.b}}if(d&M){const d=Z+r;let n;n=l?A(E[Z+H],E[d+H]):B(E[Z+H],E[d+H]),R=n.a,E[d+H]=n.b,E[Z+H]=R}}if(Z&M){let Z=S;const I=S+n*(d-t);for(;Z<=I;Z+=w){const d=Z+C;let n;n=l?A(E[Z+H],E[d+H]):B(E[Z+H],E[d+H]),R=n.a,E[d+H]=n.b,E[Z+H]=R}}t=M,M>>=1}return S}function EE(E){return new DataView(E.array.buffer,E.offset.value,E.size)}function HE(E){const H=E.viewer.buffer.slice(E.offset.value,E.offset.value+E.size),d=new Uint8Array(function(E){let H=E.byteLength;const d=[];let n=0;const Z=new DataView(E);for(;H>0;){const E=Z.getInt8(n++);if(E<0){const I=-E;H-=I+1;for(let E=0;E<I;E++)d.push(Z.getUint8(n++))}else{const I=E;H-=2;const g=Z.getUint8(n++);for(let E=0;E<I+1;E++)d.push(g)}}return d}(H)),n=new Uint8Array(d.length);return F(d),a(d,n),new DataView(n.buffer)}function dE(E){const H=E.array.slice(E.offset.value,E.offset.value+E.size),d=fflate.unzlibSync(H),n=new Uint8Array(d.length);return F(d),a(d,n),new DataView(n.buffer)}function nE(E){const H=E.array.slice(E.offset.value,E.offset.value+E.size),d=fflate.unzlibSync(H),n=E.lines*E.channels*E.width,Z=1==E.type?new Uint16Array(n):new Uint32Array(n);let I=0,g=0;const l=new Array(4);for(let r=0;r<E.lines;r++)for(let H=0;H<E.channels;H++){let H=0;switch(E.type){case 1:l[0]=I,l[1]=l[0]+E.width,I=l[1]+E.width;for(let n=0;n<E.width;++n){H+=d[l[0]++]<<8|d[l[1]++],Z[g]=H,g++}break;case 2:l[0]=I,l[1]=l[0]+E.width,l[2]=l[1]+E.width,I=l[2]+E.width;for(let n=0;n<E.width;++n){H+=d[l[0]++]<<24|d[l[1]++]<<16|d[l[2]++]<<8,Z[g]=H,g++}}}return new DataView(Z.buffer)}function ZE(E){const H=E.viewer,d={value:E.offset.value},n=new Uint16Array(E.width*E.scanlineBlockSize*(E.channels*E.type)),Z=new Uint8Array(M);let I=0;const g=new Array(E.channels);for(let r=0;r<E.channels;r++)g[r]={},g[r].start=I,g[r].end=g[r].start,g[r].nx=E.width,g[r].ny=E.lines,g[r].size=E.type,I+=g[r].nx*g[r].ny*g[r].size;const l=X(H,d),t=X(H,d);if(t>=M)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(l<=t)for(let r=0;r<t-l+1;r++)Z[r+l]=j(H,d);const V=new Uint16Array(S),C=function(E,H){let d=0;for(let Z=0;Z<S;++Z)(0==Z||E[Z>>3]&1<<(7&Z))&&(H[d++]=Z);const n=d-1;for(;d<S;)H[d++]=0;return n}(Z,V),w=P(H,d);N(E.array,H,d,w,n,I);for(let r=0;r<E.channels;++r){const E=g[r];for(let H=0;H<g[r].size;++H)J(n,E.start+H,E.nx,E.size,E.ny,E.nx*E.size,C)}!function(E,H,d){for(let n=0;n<d;++n)H[n]=E[H[n]]}(V,n,I);let R=0;const Q=new Uint8Array(n.buffer.byteLength);for(let S=0;S<E.lines;S++)for(let H=0;H<E.channels;H++){const E=g[H],d=E.nx*E.size,Z=new Uint8Array(n.buffer,E.end*r,d*r);Q.set(Z,R),R+=d*r,E.end+=d}return new DataView(Q.buffer)}var IE,gE=d(12228);!function(E){E[E.Float=0]="Float",E[E.HalfFloat=1]="HalfFloat"}(IE||(IE={}));class lE{}async function rE(E,H,d,n){const Z={size:0,viewer:H,array:new Uint8Array(H.buffer),offset:d,width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,channels:E.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(E.compression){case e.NO_COMPRESSION:Z.lines=1,Z.uncompress=EE;break;case e.RLE_COMPRESSION:Z.lines=1,Z.uncompress=HE;break;case e.ZIPS_COMPRESSION:Z.lines=1,Z.uncompress=dE,await gE.Tools.LoadScriptAsync(lE.FFLATEUrl);break;case e.ZIP_COMPRESSION:Z.lines=16,Z.uncompress=dE,await gE.Tools.LoadScriptAsync(lE.FFLATEUrl);break;case e.PIZ_COMPRESSION:Z.lines=32,Z.uncompress=ZE;break;case e.PXR24_COMPRESSION:Z.lines=16,Z.uncompress=nE,await gE.Tools.LoadScriptAsync(lE.FFLATEUrl);break;default:throw new Error(e[E.compression]+" is unsupported")}Z.scanlineBlockSize=Z.lines;const I={};for(const g of E.channels)switch(g.name){case"R":case"G":case"B":case"A":case"Y":I[g.name]=!0,Z.type=g.pixelType}let l=!1;if(I.R&&I.G&&I.B&&I.A)Z.outputChannels=4,Z.decodeChannels={R:0,G:1,B:2,A:3};else if(I.R&&I.G&&I.B)l=!0,Z.outputChannels=4,Z.decodeChannels={R:0,G:1,B:2,A:3};else if(I.R&&I.G)Z.outputChannels=2,Z.decodeChannels={R:0,G:1};else if(I.R)Z.outputChannels=1,Z.decodeChannels={R:0};else{if(!I.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Z.outputChannels=1,Z.decodeChannels={Y:0}}if(1===Z.type)switch(n){case IE.Float:Z.getter=c,Z.inputSize=r;break;case IE.HalfFloat:Z.getter=X,Z.inputSize=r}else{if(2!==Z.type)throw new Error("Unsupported pixelType "+Z.type+" for "+E.compression);switch(n){case IE.Float:Z.getter=Y,Z.inputSize=g;break;case IE.HalfFloat:Z.getter=u,Z.inputSize=g}}Z.blockCount=Z.height/Z.scanlineBlockSize;for(let g=0;g<Z.blockCount;g++)U(H,d);const t=Z.width*Z.height*Z.outputChannels;switch(n){case IE.Float:Z.byteArray=new Float32Array(t),Z.textureType=1,l&&Z.byteArray.fill(1,0,t);break;case IE.HalfFloat:Z.byteArray=new Uint16Array(t),Z.textureType=2,l&&Z.byteArray.fill(15360,0,t);break;default:throw new Error("Unsupported type: "+n)}let S=0;for(const g of E.channels)void 0!==Z.decodeChannels[g.name]&&(Z.channelLineOffsets[g.name]=S*Z.width),S+=2*g.pixelType;return Z.bytesPerLine=Z.width*S,Z.outLineWidth=Z.width*Z.outputChannels,"INCREASING_Y"===E.lineOrder?Z.scanOrder=E=>E:Z.scanOrder=E=>Z.height-1-E,4==Z.outputChannels?(Z.format=5,Z.linearSpace=!0):(Z.format=6,Z.linearSpace=!1),Z}function tE(E,H,d,n){const Z={value:0};for(let I=0;I<E.height/E.scanlineBlockSize;I++){const g=f(d,n)-H.dataWindow.yMin;E.size=P(d,n),E.lines=g+E.scanlineBlockSize>E.height?E.height-g:E.scanlineBlockSize;const l=E.size<E.lines*E.bytesPerLine&&E.uncompress?E.uncompress(E):EE(E);n.value+=E.size;for(let d=0;d<E.scanlineBlockSize;d++){const n=I*E.scanlineBlockSize,g=d+E.scanOrder(n);if(g>=E.height)continue;const r=d*E.bytesPerLine,t=(E.height-1-g)*E.outLineWidth;for(let d=0;d<E.channels;d++){const n=H.channels[d].name,I=E.channelLineOffsets[n],g=E.decodeChannels[n];if(void 0!==g){Z.value=r+I;for(let H=0;H<E.width;H++){const d=t+H*E.outputChannels+g;E.byteArray&&(E.byteArray[d]=E.getter(l,Z))}}}}}}lE.DefaultOutputType=IE.HalfFloat,lE.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class SE{constructor(){this.supportCascades=!1}loadCubeData(E,H,d,n,Z){throw".exr not supported in Cube."}loadData(E,H,d){const Z=new DataView(E.buffer),I={value:0},g=O(Z,I);rE(g,Z,I,lE.DefaultOutputType).then((E=>{tE(E,g,Z,I);const n=g.dataWindow.xMax-g.dataWindow.xMin+1,l=g.dataWindow.yMax-g.dataWindow.yMin+1;d(n,l,H.generateMipMaps,!1,(()=>{const d=H.getEngine();H.format=g.format,H.type=E.textureType,H.invertY=!1,H._gammaSpace=!g.linearSpace,E.byteArray&&d._uploadDataToTextureDirectly(H,E.byteArray,0,0,void 0,!0)}))})).catch((E=>{n.b.Error("Failed to load EXR texture: ",E)}))}}async function ME(E){const H=new DataView(E),d={value:0},Z=O(H,d);try{const E=await rE(Z,H,d,IE.Float);return tE(E,Z,H,d),E.byteArray?{width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,data:new Float32Array(E.byteArray)}:(n.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(I){n.b.Error("Failed to load EXR data: ",I)}return{width:0,height:0,data:null}}},12406:(E,H,d)=>{function n(E){return parseInt(E.toString().replace(/\W/g,""))}function Z(E,H){let d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(E-H)<=d}function I(E,H,d){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return E<H-n||E>d+n}function g(E,H){return E===H?E:Math.random()*(H-E)+E}function l(E,H,d){return E+(H-E)*d}function r(E,H,d){let n=Q(H-E,360);return n>180&&(n-=360),E+n*V(d)}function t(E,H,d){let n=0;return n=E!=H?V((d-E)/(H-E)):0,n}function S(E,H,d,n,Z){const I=Z*Z,g=Z*I;return E*(2*g-3*I+1)+d*(-2*g+3*I)+H*(g-2*I+Z)+n*(g-I)}function M(E,H,d,n,Z){const I=Z*Z;return 6*(I-Z)*E+(3*I-4*Z+1)*H+6*(-I+Z)*d+(3*I-2*Z)*n}function V(E){let H=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,d=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(d,Math.max(H,E))}function C(E){return E-=2*Math.PI*Math.floor((E+Math.PI)/(2*Math.PI))}function w(E){const H=E.toString(16);return E<=15?("0"+H).toUpperCase():H.toUpperCase()}function R(E){if(Math.log2)return Math.floor(Math.log2(E));if(E<0)return NaN;if(0===E)return-1/0;let H=0;if(E<1){for(;E<1;)H++,E*=2;H=-H}else if(E>1)for(;E>1;)H++,E=Math.floor(E/2);return H}function Q(E,H){return E-Math.floor(E/H)*H}function L(E,H,d){return(E-H)/(d-H)}function D(E,H,d){return E*(d-H)+H}function e(E,H){let d=Q(H-E,360);return d>180&&(d-=360),d}function s(E,H){const d=Q(E,2*H);return H-Math.abs(d-H)}function i(E,H,d){let n=V(d);return n=-2*n*n*n+3*n*n,H*n+E*(1-n)}function p(E,H,d){let n=0;return n=Math.abs(H-E)<=d?H:E+Math.sign(H-E)*d,n}function f(E,H,d){const n=e(E,H);let Z=0;return Z=-d<n&&n<d?H:p(E,H=E+n,d),Z}function P(E,H,d){return(E-H)/(d-H)}function j(E,H,d){return(d-H)*E+H}function X(E,H){const d=E%H;return 0===d?H:X(H,d)}d.r(H),d.d(H,{Clamp:()=>V,DeltaAngle:()=>e,Denormalize:()=>D,ExtractAsInt:()=>n,Hermite:()=>S,Hermite1stDerivative:()=>M,HighestCommonFactor:()=>X,ILog2:()=>R,InverseLerp:()=>t,Lerp:()=>l,LerpAngle:()=>r,MoveTowards:()=>p,MoveTowardsAngle:()=>f,Normalize:()=>L,NormalizeRadians:()=>C,OutsideRange:()=>I,PercentToRange:()=>j,PingPong:()=>s,RandomRange:()=>g,RangeToPercent:()=>P,Repeat:()=>Q,SmoothStep:()=>i,ToHex:()=>w,WithinEpsilon:()=>Z})}}]);