"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2584:(n,k,T)=>{function c(n){return Math.floor(n/8)}function K(n){return 1<<n%8}T.d(k,{OptimizeIndices:()=>G});class Q{constructor(n){this.size=n,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(n){if(n>=this.size)throw new RangeError("Bit index out of range");const k=c(n),T=K(n);return 0!==(this._byteArray[k]&T)}set(n,k){if(n>=this.size)throw new RangeError("Bit index out of range");const T=c(n),Q=K(n);k?this._byteArray[T]|=Q:this._byteArray[T]&=~Q}}function G(n){const k=[],T=n.length/3;for(let Q=0;Q<T;Q++)k.push([n[3*Q],n[3*Q+1],n[3*Q+2]]);const c=new Map;for(let Q=0;Q<k.length;Q++){const n=k[Q];for(const k of n){let n=c.get(k);n||c.set(k,n=[]),n.push(Q)}}const K=new Q(T),G=[],w=n=>{const T=[n];for(;T.length>0;){const n=T.pop();if(!K.get(n)){K.set(n,!0),G.push(k[n]);for(const Q of k[n]){const n=c.get(Q);if(!n)return;for(const k of n)K.get(k)||T.push(k)}}}};for(let Q=0;Q<T;Q++)K.get(Q)||w(Q);let E=0;for(const Q of G)n[E++]=Q[0],n[E++]=Q[1],n[E++]=Q[2]}}}]);