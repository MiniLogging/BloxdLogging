"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2627:(u,F,z)=>{function p(u){return Math.floor(u/8)}function b(u){return 1<<u%8}z.d(F,{OptimizeIndices:()=>c});class R{constructor(u){this.size=u,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(u){if(u>=this.size)throw new RangeError("Bit index out of range");const F=p(u),z=b(u);return 0!==(this._byteArray[F]&z)}set(u,F){if(u>=this.size)throw new RangeError("Bit index out of range");const z=p(u),R=b(u);F?this._byteArray[z]|=R:this._byteArray[z]&=~R}}function c(u){const F=[],z=u.length/3;for(let R=0;R<z;R++)F.push([u[3*R],u[3*R+1],u[3*R+2]]);const p=new Map;for(let R=0;R<F.length;R++){const u=F[R];for(const F of u){let u=p.get(F);u||p.set(F,u=[]),u.push(R)}}const b=new R(z),c=[],I=u=>{const z=[u];for(;z.length>0;){const u=z.pop();if(!b.get(u)){b.set(u,!0),c.push(F[u]);for(const R of F[u]){const u=p.get(R);if(!u)return;for(const F of u)b.get(F)||z.push(F)}}}};for(let R=0;R<z;R++)b.get(R)||I(R);let G=0;for(const R of c)u[G++]=R[0],u[G++]=R[1],u[G++]=R[2]}}}]);