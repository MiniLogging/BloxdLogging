"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[16],{15181:(D,h,o)=>{o.r(h),o.d(h,{ReadExrDataAsync:()=>KD,_ExrTextureLoader:()=>kD});var H=o(12658),g=o(12842);const j=4,M=4,R=1,t=2,S=8,k=65536,K=k>>3,Q=14,v=65537,r=1<<Q,B=r-1,s=59,U=63,q=2+U-s;var c,y;!function(D){D[D.NO_COMPRESSION=0]="NO_COMPRESSION",D[D.RLE_COMPRESSION=1]="RLE_COMPRESSION",D[D.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",D[D.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",D[D.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",D[D.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(c||(c={})),function(D){D[D.INCREASING_Y=0]="INCREASING_Y",D[D.DECREASING_Y=1]="DECREASING_Y"}(y||(y={}));const b=function(){const D=new ArrayBuffer(4),h=new Float32Array(D),o=new Uint32Array(D),H=new Uint32Array(512),g=new Uint32Array(512);for(let t=0;t<256;++t){const D=t-127;D<-27?(H[t]=0,H[256|t]=32768,g[t]=24,g[256|t]=24):D<-14?(H[t]=1024>>-D-14,H[256|t]=1024>>-D-14|32768,g[t]=-D-1,g[256|t]=-D-1):D<=15?(H[t]=D+15<<10,H[256|t]=D+15<<10|32768,g[t]=13,g[256|t]=13):D<128?(H[t]=31744,H[256|t]=64512,g[t]=24,g[256|t]=24):(H[t]=31744,H[256|t]=64512,g[t]=13,g[256|t]=13)}const j=new Uint32Array(2048),M=new Uint32Array(64),R=new Uint32Array(64);for(let t=1;t<1024;++t){let D=t<<13,h=0;for(;0===(8388608&D);)D<<=1,h-=8388608;D&=-8388609,h+=947912704,j[t]=D|h}for(let t=1024;t<2048;++t)j[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)M[t]=t<<23;M[31]=1199570944,M[32]=2147483648;for(let t=33;t<63;++t)M[t]=2147483648+(t-32<<23);M[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(R[t]=1024);return{floatView:h,uint32View:o,baseTable:H,shiftTable:g,mantissaTable:j,exponentTable:M,offsetTable:R}}();function i(D,h){const o=new Uint8Array(D);let H=0;for(;0!=o[h.value+H];)H+=1;const g=(new TextDecoder).decode(o.slice(h.value,h.value+H));return h.value=h.value+H+1,g}function G(D,h){const o=D.getInt32(h.value,!0);return h.value+=j,o}function N(D,h){const o=D.getUint32(h.value,!0);return h.value+=j,o}function J(D,h){const o=D.getUint8(h.value);return h.value+=R,o}function O(D,h){const o=D.getUint16(h.value,!0);return h.value+=t,o}function E(D,h){const o=D[h.value];return h.value+=R,o}function L(D,h){let o;return o="getBigInt64"in DataView.prototype?Number(D.getBigInt64(h.value,!0)):D.getUint32(h.value+4,!0)+Number(D.getUint32(h.value,!0)<<32),h.value+=S,o}function T(D,h){const o=D.getFloat32(h.value,!0);return h.value+=M,o}function Z(D,h){return function(D){const h=(31744&D)>>10,o=1023&D;return(D>>15?-1:1)*(h?31===h?o?NaN:1/0:Math.pow(2,h-15)*(1+o/1024):o/1024*6103515625e-14)}(O(D,h))}function e(D,h){return function(D){if(Math.abs(D)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");D=(0,g.Clamp)(D,-65504,65504),b.floatView[0]=D;const h=b.uint32View[0],o=h>>23&511;return b.baseTable[o]+((8388607&h)>>b.shiftTable[o])}(T(D,h))}function p(D,h,o,H){switch(o){case"string":case"stringvector":case"iccProfile":return function(D,h,o){const H=(new TextDecoder).decode(new Uint8Array(D).slice(h.value,h.value+o));return h.value=h.value+o,H}(D.buffer,h,H);case"chlist":return function(D,h,o){const H=h.value,g=[];for(;h.value<H+o-1;){const o=i(D.buffer,h),H=G(D,h),j=J(D,h);h.value+=3;const M=G(D,h),R=G(D,h);g.push({name:o,pixelType:H,pLinear:j,xSampling:M,ySampling:R})}return h.value+=1,g}(D,h,H);case"chromaticities":return function(D,h){return{redX:T(D,h),redY:T(D,h),greenX:T(D,h),greenY:T(D,h),blueX:T(D,h),blueY:T(D,h),whiteX:T(D,h),whiteY:T(D,h)}}(D,h);case"compression":return function(D,h){return J(D,h)}(D,h);case"box2i":return function(D,h){return{xMin:G(D,h),yMin:G(D,h),xMax:G(D,h),yMax:G(D,h)}}(D,h);case"lineOrder":return function(D,h){const o=J(D,h);return y[o]}(D,h);case"float":return T(D,h);case"v2f":return function(D,h){return[T(D,h),T(D,h)]}(D,h);case"v3f":return function(D,h){return[T(D,h),T(D,h),T(D,h)]}(D,h);case"int":return G(D,h);case"rational":return function(D,h){return[G(D,h),N(D,h)]}(D,h);case"timecode":return function(D,h){return[N(D,h),N(D,h)]}(D,h);case"preview":return h.value+=H,"skipped";default:return void(h.value+=H)}}function mD(D){for(let h=1;h<D.length;h++){const o=D[h-1]+D[h]-128;D[h]=o}}function a(D,h){let o=0,H=Math.floor((D.length+1)/2),g=0;const j=D.length-1;for(;!(g>j)&&(h[g++]=D[o++],!(g>j));)h[g++]=D[H++]}const u=20000630;function I(D,h){if(D.getUint32(0,!0)!=u)throw new Error("Incorrect OpenEXR format");const o=D.getUint8(4),g=D.getUint8(5),j={singleTile:!!(2&g),longName:!!(4&g),deepFormat:!!(8&g),multiPart:!!(16&g)};h.value=8;const M={};let R=!0;for(;R;){const o=i(D.buffer,h);if(o){const g=i(D.buffer,h),j=p(D,h,g,N(D,h));void 0===j?H.d.Warn(`Unknown header attribute type ${g}'.`):M[o]=j}else R=!1}if(0!=(-5&g))throw new Error("Unsupported file format");return{version:o,spec:j,...M}}const P=32768,n=65535;function F(D,h,o,H,g){for(;o<D;)h=h<<8|E(H,g),o+=8;return{l:h>>(o-=D)&(1<<D)-1,c:h,lc:o}}function w(D,h,o,H){return{c:D=D<<8|E(o,H),lc:h+=8}}function Y(D,h,o,H,g,j,M,R,t){if(D==h){if(H<8){const D=w(o,H,g,j);o=D.c,H=D.lc}let D=o>>(H-=8);if(D=new Uint8Array([D])[0],R.value+D>t)return null;const h=M[R.value-1];for(;D-- >0;)M[R.value++]=h}else{if(!(R.value<t))return null;M[R.value++]=D}return{c:o,lc:H}}const l=new Array(59);function C(D,h,o,H,g,j){const M=h;let R=0,t=0;for(;H<=g;H++){if(M.value-h.value>o)return;let S=F(6,R,t,D,M);const k=S.l;if(R=S.c,t=S.lc,j[H]=k,k==U){if(M.value-h.value>o)throw new Error("Error in HufUnpackEncTable");S=F(8,R,t,D,M);let k=S.l+q;if(R=S.c,t=S.lc,H+k>g+1)throw new Error("Error in HufUnpackEncTable");for(;k--;)j[H++]=0;H--}else if(k>=s){let D=k-s+2;if(H+D>g+1)throw new Error("Error in HufUnpackEncTable");for(;D--;)j[H++]=0;H--}}!function(D){for(let o=0;o<=58;++o)l[o]=0;for(let o=0;o<v;++o)l[D[o]]+=1;let h=0;for(let o=58;o>0;--o){const D=h+l[o]>>1;l[o]=h,h=D}for(let o=0;o<v;++o){const h=D[o];h>0&&(D[o]=h|l[h]++<<6)}}(j)}function z(D){return 63&D}function f(D){return D>>6}function V(D,h,o,H,g,j){const M=o.value,R=N(h,o),t=N(h,o);o.value+=4;const S=N(h,o);if(o.value+=4,R<0||R>=v||t<0||t>=v)throw new Error("Wrong HUF_ENCSIZE");const k=new Array(v),K=new Array(r);!function(D){for(let h=0;h<r;h++)D[h]={},D[h].len=0,D[h].lit=0,D[h].p=null}(K);if(C(D,o,H-(o.value-M),R,t,k),S>8*(H-(o.value-M)))throw new Error("Wrong hufUncompress");!function(D,h,o,H){for(;h<=o;h++){const o=f(D[h]),g=z(D[h]);if(o>>g)throw new Error("Invalid table entry");if(g>Q){const D=H[o>>g-Q];if(D.len)throw new Error("Invalid table entry");if(D.lit++,D.p){const h=D.p;D.p=new Array(D.lit);for(let o=0;o<D.lit-1;++o)D.p[o]=h[o]}else D.p=new Array(1);D.p[D.lit-1]=h}else if(g){let D=0;for(let j=1<<Q-g;j>0;j--){const j=H[(o<<Q-g)+D];if(j.len||j.p)throw new Error("Invalid table entry");j.len=g,j.lit=h,D++}}}}(k,R,t,K),function(D,h,o,H,g,j,M,R,t){let S=0,k=0;const K=M,v=Math.trunc(H.value+(g+7)/8);for(;H.value<v;){let g=w(S,k,o,H);for(S=g.c,k=g.lc;k>=Q;){const M=h[S>>k-Q&B];if(M.len){k-=M.len;const D=Y(M.lit,j,S,k,o,H,R,t,K);D&&(S=D.c,k=D.lc)}else{if(!M.p)throw new Error("hufDecode issues");let h;for(h=0;h<M.lit;h++){const Q=z(D[M.p[h]]);for(;k<Q&&H.value<v;)g=w(S,k,o,H),S=g.c,k=g.lc;if(k>=Q&&f(D[M.p[h]])==(S>>k-Q&(1<<Q)-1)){k-=Q;const D=Y(M.p[h],j,S,k,o,H,R,t,K);D&&(S=D.c,k=D.lc);break}}if(h==M.lit)throw new Error("HufDecode issues")}}}const r=8-g&7;for(S>>=r,k-=r;k>0;){const D=h[S<<Q-k&B];if(!D.len)throw new Error("HufDecode issues");{k-=D.len;const h=Y(D.lit,j,S,k,o,H,R,t,K);h&&(S=h.c,k=h.lc)}}}(k,K,D,o,S,t,j,g,{value:0})}function d(D){return 65535&D}function X(D){const h=d(D);return h>32767?h-65536:h}function A(D,h){const o=X(D),H=X(h),g=o+(1&H)+(H>>1);return{a:g,b:g-H}}function W(D,h){const o=d(D),H=d(h),g=o-(H>>1)&n;return{a:H+g-P&n,b:g}}function x(D,h,o,H,g,j,M){const R=M<16384,t=o>g?g:o;let S,k,K=1;for(;K<=t;)K<<=1;for(K>>=1,S=K,K>>=1;K>=1;){k=0;const M=k+j*(g-S),t=j*K,Q=j*S,v=H*K,r=H*S;let B,s,U,q;for(;k<=M;k+=Q){let g=k;const j=k+H*(o-S);for(;g<=j;g+=r){const o=g+v,H=g+t,j=H+v;if(R){let M=A(D[g+h],D[H+h]);B=M.a,U=M.b,M=A(D[o+h],D[j+h]),s=M.a,q=M.b,M=A(B,s),D[g+h]=M.a,D[o+h]=M.b,M=A(U,q),D[H+h]=M.a,D[j+h]=M.b}else{let M=W(D[g+h],D[H+h]);B=M.a,U=M.b,M=W(D[o+h],D[j+h]),s=M.a,q=M.b,M=W(B,s),D[g+h]=M.a,D[o+h]=M.b,M=W(U,q),D[H+h]=M.a,D[j+h]=M.b}}if(o&K){const o=g+t;let H;H=R?A(D[g+h],D[o+h]):W(D[g+h],D[o+h]),B=H.a,D[o+h]=H.b,D[g+h]=B}}if(g&K){let g=k;const j=k+H*(o-S);for(;g<=j;g+=r){const o=g+v;let H;H=R?A(D[g+h],D[o+h]):W(D[g+h],D[o+h]),B=H.a,D[o+h]=H.b,D[g+h]=B}}S=K,K>>=1}return k}function DD(D){return new DataView(D.array.buffer,D.offset.value,D.size)}function hD(D){const h=D.viewer.buffer.slice(D.offset.value,D.offset.value+D.size),o=new Uint8Array(function(D){let h=D.byteLength;const o=[];let H=0;const g=new DataView(D);for(;h>0;){const D=g.getInt8(H++);if(D<0){const j=-D;h-=j+1;for(let D=0;D<j;D++)o.push(g.getUint8(H++))}else{const j=D;h-=2;const M=g.getUint8(H++);for(let D=0;D<j+1;D++)o.push(M)}}return o}(h)),H=new Uint8Array(o.length);return mD(o),a(o,H),new DataView(H.buffer)}function oD(D){const h=D.array.slice(D.offset.value,D.offset.value+D.size),o=fflate.unzlibSync(h),H=new Uint8Array(o.length);return mD(o),a(o,H),new DataView(H.buffer)}function HD(D){const h=D.array.slice(D.offset.value,D.offset.value+D.size),o=fflate.unzlibSync(h),H=D.lines*D.channels*D.width,g=1==D.type?new Uint16Array(H):new Uint32Array(H);let j=0,M=0;const R=new Array(4);for(let t=0;t<D.lines;t++)for(let h=0;h<D.channels;h++){let h=0;switch(D.type){case 1:R[0]=j,R[1]=R[0]+D.width,j=R[1]+D.width;for(let H=0;H<D.width;++H){h+=o[R[0]++]<<8|o[R[1]++],g[M]=h,M++}break;case 2:R[0]=j,R[1]=R[0]+D.width,R[2]=R[1]+D.width,j=R[2]+D.width;for(let H=0;H<D.width;++H){h+=o[R[0]++]<<24|o[R[1]++]<<16|o[R[2]++]<<8,g[M]=h,M++}}}return new DataView(g.buffer)}function gD(D){const h=D.viewer,o={value:D.offset.value},H=new Uint16Array(D.width*D.scanlineBlockSize*(D.channels*D.type)),g=new Uint8Array(K);let j=0;const M=new Array(D.channels);for(let t=0;t<D.channels;t++)M[t]={},M[t].start=j,M[t].end=M[t].start,M[t].nx=D.width,M[t].ny=D.lines,M[t].size=D.type,j+=M[t].nx*M[t].ny*M[t].size;const R=O(h,o),S=O(h,o);if(S>=K)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(R<=S)for(let t=0;t<S-R+1;t++)g[t+R]=J(h,o);const Q=new Uint16Array(k),v=function(D,h){let o=0;for(let g=0;g<k;++g)(0==g||D[g>>3]&1<<(7&g))&&(h[o++]=g);const H=o-1;for(;o<k;)h[o++]=0;return H}(g,Q),r=N(h,o);V(D.array,h,o,r,H,j);for(let t=0;t<D.channels;++t){const D=M[t];for(let h=0;h<M[t].size;++h)x(H,D.start+h,D.nx,D.size,D.ny,D.nx*D.size,v)}!function(D,h,o){for(let H=0;H<o;++H)h[H]=D[h[H]]}(Q,H,j);let B=0;const s=new Uint8Array(H.buffer.byteLength);for(let k=0;k<D.lines;k++)for(let h=0;h<D.channels;h++){const D=M[h],o=D.nx*D.size,g=new Uint8Array(H.buffer,D.end*t,o*t);s.set(g,B),B+=o*t,D.end+=o}return new DataView(s.buffer)}var jD,MD=o(12642);!function(D){D[D.Float=0]="Float",D[D.HalfFloat=1]="HalfFloat"}(jD||(jD={}));class RD{}async function tD(D,h,o,H){const g={size:0,viewer:h,array:new Uint8Array(h.buffer),offset:o,width:D.dataWindow.xMax-D.dataWindow.xMin+1,height:D.dataWindow.yMax-D.dataWindow.yMin+1,channels:D.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(D.compression){case c.NO_COMPRESSION:g.lines=1,g.uncompress=DD;break;case c.RLE_COMPRESSION:g.lines=1,g.uncompress=hD;break;case c.ZIPS_COMPRESSION:g.lines=1,g.uncompress=oD,await MD.Tools.LoadScriptAsync(RD.FFLATEUrl);break;case c.ZIP_COMPRESSION:g.lines=16,g.uncompress=oD,await MD.Tools.LoadScriptAsync(RD.FFLATEUrl);break;case c.PIZ_COMPRESSION:g.lines=32,g.uncompress=gD;break;case c.PXR24_COMPRESSION:g.lines=16,g.uncompress=HD,await MD.Tools.LoadScriptAsync(RD.FFLATEUrl);break;default:throw new Error(c[D.compression]+" is unsupported")}g.scanlineBlockSize=g.lines;const j={};for(const M of D.channels)switch(M.name){case"R":case"G":case"B":case"A":case"Y":j[M.name]=!0,g.type=M.pixelType}let R=!1;if(j.R&&j.G&&j.B&&j.A)g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(j.R&&j.G&&j.B)R=!0,g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(j.R&&j.G)g.outputChannels=2,g.decodeChannels={R:0,G:1};else if(j.R)g.outputChannels=1,g.decodeChannels={R:0};else{if(!j.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");g.outputChannels=1,g.decodeChannels={Y:0}}if(1===g.type)switch(H){case jD.Float:g.getter=Z,g.inputSize=t;break;case jD.HalfFloat:g.getter=O,g.inputSize=t}else{if(2!==g.type)throw new Error("Unsupported pixelType "+g.type+" for "+D.compression);switch(H){case jD.Float:g.getter=T,g.inputSize=M;break;case jD.HalfFloat:g.getter=e,g.inputSize=M}}g.blockCount=g.height/g.scanlineBlockSize;for(let M=0;M<g.blockCount;M++)L(h,o);const S=g.width*g.height*g.outputChannels;switch(H){case jD.Float:g.byteArray=new Float32Array(S),g.textureType=1,R&&g.byteArray.fill(1,0,S);break;case jD.HalfFloat:g.byteArray=new Uint16Array(S),g.textureType=2,R&&g.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+H)}let k=0;for(const M of D.channels)void 0!==g.decodeChannels[M.name]&&(g.channelLineOffsets[M.name]=k*g.width),k+=2*M.pixelType;return g.bytesPerLine=g.width*k,g.outLineWidth=g.width*g.outputChannels,"INCREASING_Y"===D.lineOrder?g.scanOrder=D=>D:g.scanOrder=D=>g.height-1-D,4==g.outputChannels?(g.format=5,g.linearSpace=!0):(g.format=6,g.linearSpace=!1),g}function SD(D,h,o,H){const g={value:0};for(let j=0;j<D.height/D.scanlineBlockSize;j++){const M=G(o,H)-h.dataWindow.yMin;D.size=N(o,H),D.lines=M+D.scanlineBlockSize>D.height?D.height-M:D.scanlineBlockSize;const R=D.size<D.lines*D.bytesPerLine&&D.uncompress?D.uncompress(D):DD(D);H.value+=D.size;for(let o=0;o<D.scanlineBlockSize;o++){const H=j*D.scanlineBlockSize,M=o+D.scanOrder(H);if(M>=D.height)continue;const t=o*D.bytesPerLine,S=(D.height-1-M)*D.outLineWidth;for(let o=0;o<D.channels;o++){const H=h.channels[o].name,j=D.channelLineOffsets[H],M=D.decodeChannels[H];if(void 0!==M){g.value=t+j;for(let h=0;h<D.width;h++){const o=S+h*D.outputChannels+M;D.byteArray&&(D.byteArray[o]=D.getter(R,g))}}}}}}RD.DefaultOutputType=jD.HalfFloat,RD.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class kD{constructor(){this.supportCascades=!1}loadCubeData(D,h,o,H,g){throw".exr not supported in Cube."}loadData(D,h,o){const g=new DataView(D.buffer),j={value:0},M=I(g,j);tD(M,g,j,RD.DefaultOutputType).then((D=>{SD(D,M,g,j);const H=M.dataWindow.xMax-M.dataWindow.xMin+1,R=M.dataWindow.yMax-M.dataWindow.yMin+1;o(H,R,h.generateMipMaps,!1,(()=>{const o=h.getEngine();h.format=M.format,h.type=D.textureType,h.invertY=!1,h._gammaSpace=!M.linearSpace,D.byteArray&&o._uploadDataToTextureDirectly(h,D.byteArray,0,0,void 0,!0)}))})).catch((D=>{H.d.Error("Failed to load EXR texture: ",D)}))}}async function KD(D){const h=new DataView(D),o={value:0},g=I(h,o);try{const D=await tD(g,h,o,jD.Float);return SD(D,g,h,o),D.byteArray?{width:g.dataWindow.xMax-g.dataWindow.xMin+1,height:g.dataWindow.yMax-g.dataWindow.yMin+1,data:new Float32Array(D.byteArray)}:(H.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(j){H.d.Error("Failed to load EXR data: ",j)}return{width:0,height:0,data:null}}},12842:(D,h,o)=>{function H(D){return parseInt(D.toString().replace(/\W/g,""))}function g(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(D-h)<=o}function j(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return D<h-H||D>o+H}function M(D,h){return D===h?D:Math.random()*(h-D)+D}function R(D,h,o){return D+(h-D)*o}function t(D,h,o){let H=s(h-D,360);return H>180&&(H-=360),D+H*Q(o)}function S(D,h,o){let H=0;return H=D!=h?Q((o-D)/(h-D)):0,H}function k(D,h,o,H,g){const j=g*g,M=g*j;return D*(2*M-3*j+1)+o*(-2*M+3*j)+h*(M-2*j+g)+H*(M-j)}function K(D,h,o,H,g){const j=g*g;return 6*(j-g)*D+(3*j-4*g+1)*h+6*(-j+g)*o+(3*j-2*g)*H}function Q(D){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(o,Math.max(h,D))}function v(D){return D-=2*Math.PI*Math.floor((D+Math.PI)/(2*Math.PI))}function r(D){const h=D.toString(16);return D<=15?("0"+h).toUpperCase():h.toUpperCase()}function B(D){if(Math.log2)return Math.floor(Math.log2(D));if(D<0)return NaN;if(0===D)return-1/0;let h=0;if(D<1){for(;D<1;)h++,D*=2;h=-h}else if(D>1)for(;D>1;)h++,D=Math.floor(D/2);return h}function s(D,h){return D-Math.floor(D/h)*h}function U(D,h,o){return(D-h)/(o-h)}function q(D,h,o){return D*(o-h)+h}function c(D,h){let o=s(h-D,360);return o>180&&(o-=360),o}function y(D,h){const o=s(D,2*h);return h-Math.abs(o-h)}function b(D,h,o){let H=Q(o);return H=-2*H*H*H+3*H*H,h*H+D*(1-H)}function i(D,h,o){let H=0;return H=Math.abs(h-D)<=o?h:D+Math.sign(h-D)*o,H}function G(D,h,o){const H=c(D,h);let g=0;return g=-o<H&&H<o?h:i(D,h=D+H,o),g}function N(D,h,o){return(D-h)/(o-h)}function J(D,h,o){return(o-h)*D+h}function O(D,h){const o=D%h;return 0===o?h:O(h,o)}o.r(h),o.d(h,{Clamp:()=>Q,DeltaAngle:()=>c,Denormalize:()=>q,ExtractAsInt:()=>H,Hermite:()=>k,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>O,ILog2:()=>B,InverseLerp:()=>S,Lerp:()=>R,LerpAngle:()=>t,MoveTowards:()=>i,MoveTowardsAngle:()=>G,Normalize:()=>U,NormalizeRadians:()=>v,OutsideRange:()=>j,PercentToRange:()=>J,PingPong:()=>y,RandomRange:()=>M,RangeToPercent:()=>N,Repeat:()=>s,SmoothStep:()=>b,ToHex:()=>r,WithinEpsilon:()=>g})}}]);