"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[16],{13569:(N,q,C)=>{C.r(q),C.d(q,{ReadExrDataAsync:()=>tN,_ExrTextureLoader:()=>nN});var d=C(10962),U=C(11142);const W=4,a=4,F=1,w=2,A=8,n=65536,t=n>>3,V=14,Z=65537,J=1<<V,Q=J-1,v=59,r=63,O=2+r-v;var K,i;!function(N){N[N.NO_COMPRESSION=0]="NO_COMPRESSION",N[N.RLE_COMPRESSION=1]="RLE_COMPRESSION",N[N.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",N[N.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",N[N.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",N[N.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(K||(K={})),function(N){N[N.INCREASING_Y=0]="INCREASING_Y",N[N.DECREASING_Y=1]="DECREASING_Y"}(i||(i={}));const I=function(){const N=new ArrayBuffer(4),q=new Float32Array(N),C=new Uint32Array(N),d=new Uint32Array(512),U=new Uint32Array(512);for(let w=0;w<256;++w){const N=w-127;N<-27?(d[w]=0,d[256|w]=32768,U[w]=24,U[256|w]=24):N<-14?(d[w]=1024>>-N-14,d[256|w]=1024>>-N-14|32768,U[w]=-N-1,U[256|w]=-N-1):N<=15?(d[w]=N+15<<10,d[256|w]=N+15<<10|32768,U[w]=13,U[256|w]=13):N<128?(d[w]=31744,d[256|w]=64512,U[w]=24,U[256|w]=24):(d[w]=31744,d[256|w]=64512,U[w]=13,U[256|w]=13)}const W=new Uint32Array(2048),a=new Uint32Array(64),F=new Uint32Array(64);for(let w=1;w<1024;++w){let N=w<<13,q=0;for(;0===(8388608&N);)N<<=1,q-=8388608;N&=-8388609,q+=947912704,W[w]=N|q}for(let w=1024;w<2048;++w)W[w]=939524096+(w-1024<<13);for(let w=1;w<31;++w)a[w]=w<<23;a[31]=1199570944,a[32]=2147483648;for(let w=33;w<63;++w)a[w]=2147483648+(w-32<<23);a[63]=3347054592;for(let w=1;w<64;++w)32!==w&&(F[w]=1024);return{floatView:q,uint32View:C,baseTable:d,shiftTable:U,mantissaTable:W,exponentTable:a,offsetTable:F}}();function j(N,q){const C=new Uint8Array(N);let d=0;for(;0!=C[q.value+d];)d+=1;const U=(new TextDecoder).decode(C.slice(q.value,q.value+d));return q.value=q.value+d+1,U}function l(N,q){const C=N.getInt32(q.value,!0);return q.value+=W,C}function T(N,q){const C=N.getUint32(q.value,!0);return q.value+=W,C}function z(N,q){const C=N.getUint8(q.value);return q.value+=F,C}function p(N,q){const C=N.getUint16(q.value,!0);return q.value+=w,C}function s(N,q){const C=N[q.value];return q.value+=F,C}function X(N,q){let C;return C="getBigInt64"in DataView.prototype?Number(N.getBigInt64(q.value,!0)):N.getUint32(q.value+4,!0)+Number(N.getUint32(q.value,!0)<<32),q.value+=A,C}function P(N,q){const C=N.getFloat32(q.value,!0);return q.value+=a,C}function M(N,q){return function(N){const q=(31744&N)>>10,C=1023&N;return(N>>15?-1:1)*(q?31===q?C?NaN:1/0:Math.pow(2,q-15)*(1+C/1024):C/1024*6103515625e-14)}(p(N,q))}function Y(N,q){return function(N){if(Math.abs(N)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");N=(0,U.Clamp)(N,-65504,65504),I.floatView[0]=N;const q=I.uint32View[0],C=q>>23&511;return I.baseTable[C]+((8388607&q)>>I.shiftTable[C])}(P(N,q))}function E(N,q,C,d){switch(C){case"string":case"stringvector":case"iccProfile":return function(N,q,C){const d=(new TextDecoder).decode(new Uint8Array(N).slice(q.value,q.value+C));return q.value=q.value+C,d}(N.buffer,q,d);case"chlist":return function(N,q,C){const d=q.value,U=[];for(;q.value<d+C-1;){const C=j(N.buffer,q),d=l(N,q),W=z(N,q);q.value+=3;const a=l(N,q),F=l(N,q);U.push({name:C,pixelType:d,pLinear:W,xSampling:a,ySampling:F})}return q.value+=1,U}(N,q,d);case"chromaticities":return function(N,q){return{redX:P(N,q),redY:P(N,q),greenX:P(N,q),greenY:P(N,q),blueX:P(N,q),blueY:P(N,q),whiteX:P(N,q),whiteY:P(N,q)}}(N,q);case"compression":return function(N,q){return z(N,q)}(N,q);case"box2i":return function(N,q){return{xMin:l(N,q),yMin:l(N,q),xMax:l(N,q),yMax:l(N,q)}}(N,q);case"lineOrder":return function(N,q){const C=z(N,q);return i[C]}(N,q);case"float":return P(N,q);case"v2f":return function(N,q){return[P(N,q),P(N,q)]}(N,q);case"v3f":return function(N,q){return[P(N,q),P(N,q),P(N,q)]}(N,q);case"int":return l(N,q);case"rational":return function(N,q){return[l(N,q),T(N,q)]}(N,q);case"timecode":return function(N,q){return[T(N,q),T(N,q)]}(N,q);case"preview":return q.value+=d,"skipped";default:return void(q.value+=d)}}function H(N){for(let q=1;q<N.length;q++){const C=N[q-1]+N[q]-128;N[q]=C}}function e(N,q){let C=0,d=Math.floor((N.length+1)/2),U=0;const W=N.length-1;for(;!(U>W)&&(q[U++]=N[C++],!(U>W));)q[U++]=N[d++]}const b=20000630;function o(N,q){if(N.getUint32(0,!0)!=b)throw new Error("Incorrect OpenEXR format");const C=N.getUint8(4),U=N.getUint8(5),W={singleTile:!!(2&U),longName:!!(4&U),deepFormat:!!(8&U),multiPart:!!(16&U)};q.value=8;const a={};let F=!0;for(;F;){const C=j(N.buffer,q);if(C){const U=j(N.buffer,q),W=E(N,q,U,T(N,q));void 0===W?d.c.Warn(`Unknown header attribute type ${U}'.`):a[C]=W}else F=!1}if(0!=(-5&U))throw new Error("Unsupported file format");return{version:C,spec:W,...a}}const S=32768,D=65535;function c(N,q,C,d,U){for(;C<N;)q=q<<8|s(d,U),C+=8;return{l:q>>(C-=N)&(1<<N)-1,c:q,lc:C}}function L(N,q,C,d){return{c:N=N<<8|s(C,d),lc:q+=8}}function G(N,q,C,d,U,W,a,F,w){if(N==q){if(d<8){const N=L(C,d,U,W);C=N.c,d=N.lc}let N=C>>(d-=8);if(N=new Uint8Array([N])[0],F.value+N>w)return null;const q=a[F.value-1];for(;N-- >0;)a[F.value++]=q}else{if(!(F.value<w))return null;a[F.value++]=N}return{c:C,lc:d}}const h=new Array(59);function B(N,q,C,d,U,W){const a=q;let F=0,w=0;for(;d<=U;d++){if(a.value-q.value>C)return;let A=c(6,F,w,N,a);const n=A.l;if(F=A.c,w=A.lc,W[d]=n,n==r){if(a.value-q.value>C)throw new Error("Error in HufUnpackEncTable");A=c(8,F,w,N,a);let n=A.l+O;if(F=A.c,w=A.lc,d+n>U+1)throw new Error("Error in HufUnpackEncTable");for(;n--;)W[d++]=0;d--}else if(n>=v){let N=n-v+2;if(d+N>U+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)W[d++]=0;d--}}!function(N){for(let C=0;C<=58;++C)h[C]=0;for(let C=0;C<Z;++C)h[N[C]]+=1;let q=0;for(let C=58;C>0;--C){const N=q+h[C]>>1;h[C]=q,q=N}for(let C=0;C<Z;++C){const q=N[C];q>0&&(N[C]=q|h[q]++<<6)}}(W)}function y(N){return 63&N}function R(N){return N>>6}function u(N,q,C,d,U,W){const a=C.value,F=T(q,C),w=T(q,C);C.value+=4;const A=T(q,C);if(C.value+=4,F<0||F>=Z||w<0||w>=Z)throw new Error("Wrong HUF_ENCSIZE");const n=new Array(Z),t=new Array(J);!function(N){for(let q=0;q<J;q++)N[q]={},N[q].len=0,N[q].lit=0,N[q].p=null}(t);if(B(N,C,d-(C.value-a),F,w,n),A>8*(d-(C.value-a)))throw new Error("Wrong hufUncompress");!function(N,q,C,d){for(;q<=C;q++){const C=R(N[q]),U=y(N[q]);if(C>>U)throw new Error("Invalid table entry");if(U>V){const N=d[C>>U-V];if(N.len)throw new Error("Invalid table entry");if(N.lit++,N.p){const q=N.p;N.p=new Array(N.lit);for(let C=0;C<N.lit-1;++C)N.p[C]=q[C]}else N.p=new Array(1);N.p[N.lit-1]=q}else if(U){let N=0;for(let W=1<<V-U;W>0;W--){const W=d[(C<<V-U)+N];if(W.len||W.p)throw new Error("Invalid table entry");W.len=U,W.lit=q,N++}}}}(n,F,w,t),function(N,q,C,d,U,W,a,F,w){let A=0,n=0;const t=a,Z=Math.trunc(d.value+(U+7)/8);for(;d.value<Z;){let U=L(A,n,C,d);for(A=U.c,n=U.lc;n>=V;){const a=q[A>>n-V&Q];if(a.len){n-=a.len;const N=G(a.lit,W,A,n,C,d,F,w,t);N&&(A=N.c,n=N.lc)}else{if(!a.p)throw new Error("hufDecode issues");let q;for(q=0;q<a.lit;q++){const V=y(N[a.p[q]]);for(;n<V&&d.value<Z;)U=L(A,n,C,d),A=U.c,n=U.lc;if(n>=V&&R(N[a.p[q]])==(A>>n-V&(1<<V)-1)){n-=V;const N=G(a.p[q],W,A,n,C,d,F,w,t);N&&(A=N.c,n=N.lc);break}}if(q==a.lit)throw new Error("HufDecode issues")}}}const J=8-U&7;for(A>>=J,n-=J;n>0;){const N=q[A<<V-n&Q];if(!N.len)throw new Error("HufDecode issues");{n-=N.len;const q=G(N.lit,W,A,n,C,d,F,w,t);q&&(A=q.c,n=q.lc)}}}(n,t,N,C,A,w,W,U,{value:0})}function m(N){return 65535&N}function f(N){const q=m(N);return q>32767?q-65536:q}function k(N,q){const C=f(N),d=f(q),U=C+(1&d)+(d>>1);return{a:U,b:U-d}}function g(N,q){const C=m(N),d=m(q),U=C-(d>>1)&D;return{a:d+U-S&D,b:U}}function x(N,q,C,d,U,W,a){const F=a<16384,w=C>U?U:C;let A,n,t=1;for(;t<=w;)t<<=1;for(t>>=1,A=t,t>>=1;t>=1;){n=0;const a=n+W*(U-A),w=W*t,V=W*A,Z=d*t,J=d*A;let Q,v,r,O;for(;n<=a;n+=V){let U=n;const W=n+d*(C-A);for(;U<=W;U+=J){const C=U+Z,d=U+w,W=d+Z;if(F){let a=k(N[U+q],N[d+q]);Q=a.a,r=a.b,a=k(N[C+q],N[W+q]),v=a.a,O=a.b,a=k(Q,v),N[U+q]=a.a,N[C+q]=a.b,a=k(r,O),N[d+q]=a.a,N[W+q]=a.b}else{let a=g(N[U+q],N[d+q]);Q=a.a,r=a.b,a=g(N[C+q],N[W+q]),v=a.a,O=a.b,a=g(Q,v),N[U+q]=a.a,N[C+q]=a.b,a=g(r,O),N[d+q]=a.a,N[W+q]=a.b}}if(C&t){const C=U+w;let d;d=F?k(N[U+q],N[C+q]):g(N[U+q],N[C+q]),Q=d.a,N[C+q]=d.b,N[U+q]=Q}}if(U&t){let U=n;const W=n+d*(C-A);for(;U<=W;U+=J){const C=U+Z;let d;d=F?k(N[U+q],N[C+q]):g(N[U+q],N[C+q]),Q=d.a,N[C+q]=d.b,N[U+q]=Q}}A=t,t>>=1}return n}function NN(N){return new DataView(N.array.buffer,N.offset.value,N.size)}function qN(N){const q=N.viewer.buffer.slice(N.offset.value,N.offset.value+N.size),C=new Uint8Array(function(N){let q=N.byteLength;const C=[];let d=0;const U=new DataView(N);for(;q>0;){const N=U.getInt8(d++);if(N<0){const W=-N;q-=W+1;for(let N=0;N<W;N++)C.push(U.getUint8(d++))}else{const W=N;q-=2;const a=U.getUint8(d++);for(let N=0;N<W+1;N++)C.push(a)}}return C}(q)),d=new Uint8Array(C.length);return H(C),e(C,d),new DataView(d.buffer)}function CN(N){const q=N.array.slice(N.offset.value,N.offset.value+N.size),C=fflate.unzlibSync(q),d=new Uint8Array(C.length);return H(C),e(C,d),new DataView(d.buffer)}function dN(N){const q=N.array.slice(N.offset.value,N.offset.value+N.size),C=fflate.unzlibSync(q),d=N.lines*N.channels*N.width,U=1==N.type?new Uint16Array(d):new Uint32Array(d);let W=0,a=0;const F=new Array(4);for(let w=0;w<N.lines;w++)for(let q=0;q<N.channels;q++){let q=0;switch(N.type){case 1:F[0]=W,F[1]=F[0]+N.width,W=F[1]+N.width;for(let d=0;d<N.width;++d){q+=C[F[0]++]<<8|C[F[1]++],U[a]=q,a++}break;case 2:F[0]=W,F[1]=F[0]+N.width,F[2]=F[1]+N.width,W=F[2]+N.width;for(let d=0;d<N.width;++d){q+=C[F[0]++]<<24|C[F[1]++]<<16|C[F[2]++]<<8,U[a]=q,a++}}}return new DataView(U.buffer)}function UN(N){const q=N.viewer,C={value:N.offset.value},d=new Uint16Array(N.width*N.scanlineBlockSize*(N.channels*N.type)),U=new Uint8Array(t);let W=0;const a=new Array(N.channels);for(let w=0;w<N.channels;w++)a[w]={},a[w].start=W,a[w].end=a[w].start,a[w].nx=N.width,a[w].ny=N.lines,a[w].size=N.type,W+=a[w].nx*a[w].ny*a[w].size;const F=p(q,C),A=p(q,C);if(A>=t)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(F<=A)for(let w=0;w<A-F+1;w++)U[w+F]=z(q,C);const V=new Uint16Array(n),Z=function(N,q){let C=0;for(let U=0;U<n;++U)(0==U||N[U>>3]&1<<(7&U))&&(q[C++]=U);const d=C-1;for(;C<n;)q[C++]=0;return d}(U,V),J=T(q,C);u(N.array,q,C,J,d,W);for(let w=0;w<N.channels;++w){const N=a[w];for(let q=0;q<a[w].size;++q)x(d,N.start+q,N.nx,N.size,N.ny,N.nx*N.size,Z)}!function(N,q,C){for(let d=0;d<C;++d)q[d]=N[q[d]]}(V,d,W);let Q=0;const v=new Uint8Array(d.buffer.byteLength);for(let n=0;n<N.lines;n++)for(let q=0;q<N.channels;q++){const N=a[q],C=N.nx*N.size,U=new Uint8Array(d.buffer,N.end*w,C*w);v.set(U,Q),Q+=C*w,N.end+=C}return new DataView(v.buffer)}var WN,aN=C(10945);!function(N){N[N.Float=0]="Float",N[N.HalfFloat=1]="HalfFloat"}(WN||(WN={}));class FN{}async function wN(N,q,C,d){const U={size:0,viewer:q,array:new Uint8Array(q.buffer),offset:C,width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,channels:N.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(N.compression){case K.NO_COMPRESSION:U.lines=1,U.uncompress=NN;break;case K.RLE_COMPRESSION:U.lines=1,U.uncompress=qN;break;case K.ZIPS_COMPRESSION:U.lines=1,U.uncompress=CN,await aN.Tools.LoadScriptAsync(FN.FFLATEUrl);break;case K.ZIP_COMPRESSION:U.lines=16,U.uncompress=CN,await aN.Tools.LoadScriptAsync(FN.FFLATEUrl);break;case K.PIZ_COMPRESSION:U.lines=32,U.uncompress=UN;break;case K.PXR24_COMPRESSION:U.lines=16,U.uncompress=dN,await aN.Tools.LoadScriptAsync(FN.FFLATEUrl);break;default:throw new Error(K[N.compression]+" is unsupported")}U.scanlineBlockSize=U.lines;const W={};for(const a of N.channels)switch(a.name){case"R":case"G":case"B":case"A":case"Y":W[a.name]=!0,U.type=a.pixelType}let F=!1;if(W.R&&W.G&&W.B&&W.A)U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(W.R&&W.G&&W.B)F=!0,U.outputChannels=4,U.decodeChannels={R:0,G:1,B:2,A:3};else if(W.R&&W.G)U.outputChannels=2,U.decodeChannels={R:0,G:1};else if(W.R)U.outputChannels=1,U.decodeChannels={R:0};else{if(!W.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");U.outputChannels=1,U.decodeChannels={Y:0}}if(1===U.type)switch(d){case WN.Float:U.getter=M,U.inputSize=w;break;case WN.HalfFloat:U.getter=p,U.inputSize=w}else{if(2!==U.type)throw new Error("Unsupported pixelType "+U.type+" for "+N.compression);switch(d){case WN.Float:U.getter=P,U.inputSize=a;break;case WN.HalfFloat:U.getter=Y,U.inputSize=a}}U.blockCount=U.height/U.scanlineBlockSize;for(let a=0;a<U.blockCount;a++)X(q,C);const A=U.width*U.height*U.outputChannels;switch(d){case WN.Float:U.byteArray=new Float32Array(A),U.textureType=1,F&&U.byteArray.fill(1,0,A);break;case WN.HalfFloat:U.byteArray=new Uint16Array(A),U.textureType=2,F&&U.byteArray.fill(15360,0,A);break;default:throw new Error("Unsupported type: "+d)}let n=0;for(const a of N.channels)void 0!==U.decodeChannels[a.name]&&(U.channelLineOffsets[a.name]=n*U.width),n+=2*a.pixelType;return U.bytesPerLine=U.width*n,U.outLineWidth=U.width*U.outputChannels,"INCREASING_Y"===N.lineOrder?U.scanOrder=N=>N:U.scanOrder=N=>U.height-1-N,4==U.outputChannels?(U.format=5,U.linearSpace=!0):(U.format=6,U.linearSpace=!1),U}function AN(N,q,C,d){const U={value:0};for(let W=0;W<N.height/N.scanlineBlockSize;W++){const a=l(C,d)-q.dataWindow.yMin;N.size=T(C,d),N.lines=a+N.scanlineBlockSize>N.height?N.height-a:N.scanlineBlockSize;const F=N.size<N.lines*N.bytesPerLine&&N.uncompress?N.uncompress(N):NN(N);d.value+=N.size;for(let C=0;C<N.scanlineBlockSize;C++){const d=W*N.scanlineBlockSize,a=C+N.scanOrder(d);if(a>=N.height)continue;const w=C*N.bytesPerLine,A=(N.height-1-a)*N.outLineWidth;for(let C=0;C<N.channels;C++){const d=q.channels[C].name,W=N.channelLineOffsets[d],a=N.decodeChannels[d];if(void 0!==a){U.value=w+W;for(let q=0;q<N.width;q++){const C=A+q*N.outputChannels+a;N.byteArray&&(N.byteArray[C]=N.getter(F,U))}}}}}}FN.DefaultOutputType=WN.HalfFloat,FN.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class nN{constructor(){this.supportCascades=!1}loadCubeData(N,q,C,d,U){throw".exr not supported in Cube."}loadData(N,q,C){const U=new DataView(N.buffer),W={value:0},a=o(U,W);wN(a,U,W,FN.DefaultOutputType).then((N=>{AN(N,a,U,W);const d=a.dataWindow.xMax-a.dataWindow.xMin+1,F=a.dataWindow.yMax-a.dataWindow.yMin+1;C(d,F,q.generateMipMaps,!1,(()=>{const C=q.getEngine();q.format=a.format,q.type=N.textureType,q.invertY=!1,q._gammaSpace=!a.linearSpace,N.byteArray&&C._uploadDataToTextureDirectly(q,N.byteArray,0,0,void 0,!0)}))})).catch((N=>{d.c.Error("Failed to load EXR texture: ",N)}))}}async function tN(N){const q=new DataView(N),C={value:0},U=o(q,C);try{const N=await wN(U,q,C,WN.Float);return AN(N,U,q,C),N.byteArray?{width:U.dataWindow.xMax-U.dataWindow.xMin+1,height:U.dataWindow.yMax-U.dataWindow.yMin+1,data:new Float32Array(N.byteArray)}:(d.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(W){d.c.Error("Failed to load EXR data: ",W)}return{width:0,height:0,data:null}}},11142:(N,q,C)=>{function d(N){return parseInt(N.toString().replace(/\W/g,""))}function U(N,q){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(N-q)<=C}function W(N,q,C){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return N<q-d||N>C+d}function a(N,q){return N===q?N:Math.random()*(q-N)+N}function F(N,q,C){return N+(q-N)*C}function w(N,q,C){let d=v(q-N,360);return d>180&&(d-=360),N+d*V(C)}function A(N,q,C){let d=0;return d=N!=q?V((C-N)/(q-N)):0,d}function n(N,q,C,d,U){const W=U*U,a=U*W;return N*(2*a-3*W+1)+C*(-2*a+3*W)+q*(a-2*W+U)+d*(a-W)}function t(N,q,C,d,U){const W=U*U;return 6*(W-U)*N+(3*W-4*U+1)*q+6*(-W+U)*C+(3*W-2*U)*d}function V(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(q,N))}function Z(N){return N-=2*Math.PI*Math.floor((N+Math.PI)/(2*Math.PI))}function J(N){const q=N.toString(16);return N<=15?("0"+q).toUpperCase():q.toUpperCase()}function Q(N){if(Math.log2)return Math.floor(Math.log2(N));if(N<0)return NaN;if(0===N)return-1/0;let q=0;if(N<1){for(;N<1;)q++,N*=2;q=-q}else if(N>1)for(;N>1;)q++,N=Math.floor(N/2);return q}function v(N,q){return N-Math.floor(N/q)*q}function r(N,q,C){return(N-q)/(C-q)}function O(N,q,C){return N*(C-q)+q}function K(N,q){let C=v(q-N,360);return C>180&&(C-=360),C}function i(N,q){const C=v(N,2*q);return q-Math.abs(C-q)}function I(N,q,C){let d=V(C);return d=-2*d*d*d+3*d*d,q*d+N*(1-d)}function j(N,q,C){let d=0;return d=Math.abs(q-N)<=C?q:N+Math.sign(q-N)*C,d}function l(N,q,C){const d=K(N,q);let U=0;return U=-C<d&&d<C?q:j(N,q=N+d,C),U}function T(N,q,C){return(N-q)/(C-q)}function z(N,q,C){return(C-q)*N+q}function p(N,q){const C=N%q;return 0===C?q:p(q,C)}C.r(q),C.d(q,{Clamp:()=>V,DeltaAngle:()=>K,Denormalize:()=>O,ExtractAsInt:()=>d,Hermite:()=>n,Hermite1stDerivative:()=>t,HighestCommonFactor:()=>p,ILog2:()=>Q,InverseLerp:()=>A,Lerp:()=>F,LerpAngle:()=>w,MoveTowards:()=>j,MoveTowardsAngle:()=>l,Normalize:()=>r,NormalizeRadians:()=>Z,OutsideRange:()=>W,PercentToRange:()=>z,PingPong:()=>i,RandomRange:()=>a,RangeToPercent:()=>T,Repeat:()=>v,SmoothStep:()=>I,ToHex:()=>J,WithinEpsilon:()=>U})}}]);