"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[16],{13561:(P,e,n)=>{n.r(e),n.d(e,{ReadExrDataAsync:()=>qP,_ExrTextureLoader:()=>RP});var H=n(10988),S=n(11148);const p=4,k=4,m=1,t=2,C=8,R=65536,q=R>>3,A=14,F=65537,Y=1<<A,j=Y-1,z=59,w=63,J=2+w-z;var I,O;!function(P){P[P.NO_COMPRESSION=0]="NO_COMPRESSION",P[P.RLE_COMPRESSION=1]="RLE_COMPRESSION",P[P.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",P[P.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",P[P.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",P[P.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(I||(I={})),function(P){P[P.INCREASING_Y=0]="INCREASING_Y",P[P.DECREASING_Y=1]="DECREASING_Y"}(O||(O={}));const V=function(){const P=new ArrayBuffer(4),e=new Float32Array(P),n=new Uint32Array(P),H=new Uint32Array(512),S=new Uint32Array(512);for(let t=0;t<256;++t){const P=t-127;P<-27?(H[t]=0,H[256|t]=32768,S[t]=24,S[256|t]=24):P<-14?(H[t]=1024>>-P-14,H[256|t]=1024>>-P-14|32768,S[t]=-P-1,S[256|t]=-P-1):P<=15?(H[t]=P+15<<10,H[256|t]=P+15<<10|32768,S[t]=13,S[256|t]=13):P<128?(H[t]=31744,H[256|t]=64512,S[t]=24,S[256|t]=24):(H[t]=31744,H[256|t]=64512,S[t]=13,S[256|t]=13)}const p=new Uint32Array(2048),k=new Uint32Array(64),m=new Uint32Array(64);for(let t=1;t<1024;++t){let P=t<<13,e=0;for(;0===(8388608&P);)P<<=1,e-=8388608;P&=-8388609,e+=947912704,p[t]=P|e}for(let t=1024;t<2048;++t)p[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)k[t]=t<<23;k[31]=1199570944,k[32]=2147483648;for(let t=33;t<63;++t)k[t]=2147483648+(t-32<<23);k[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(m[t]=1024);return{floatView:e,uint32View:n,baseTable:H,shiftTable:S,mantissaTable:p,exponentTable:k,offsetTable:m}}();function i(P,e){const n=new Uint8Array(P);let H=0;for(;0!=n[e.value+H];)H+=1;const S=(new TextDecoder).decode(n.slice(e.value,e.value+H));return e.value=e.value+H+1,S}function B(P,e){const n=P.getInt32(e.value,!0);return e.value+=p,n}function l(P,e){const n=P.getUint32(e.value,!0);return e.value+=p,n}function b(P,e){const n=P.getUint8(e.value);return e.value+=m,n}function T(P,e){const n=P.getUint16(e.value,!0);return e.value+=t,n}function d(P,e){const n=P[e.value];return e.value+=m,n}function N(P,e){let n;return n="getBigInt64"in DataView.prototype?Number(P.getBigInt64(e.value,!0)):P.getUint32(e.value+4,!0)+Number(P.getUint32(e.value,!0)<<32),e.value+=C,n}function Q(P,e){const n=P.getFloat32(e.value,!0);return e.value+=k,n}function c(P,e){return function(P){const e=(31744&P)>>10,n=1023&P;return(P>>15?-1:1)*(e?31===e?n?NaN:1/0:Math.pow(2,e-15)*(1+n/1024):n/1024*6103515625e-14)}(T(P,e))}function r(P,e){return function(P){if(Math.abs(P)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");P=(0,S.Clamp)(P,-65504,65504),V.floatView[0]=P;const e=V.uint32View[0],n=e>>23&511;return V.baseTable[n]+((8388607&e)>>V.shiftTable[n])}(Q(P,e))}function o(P,e,n,H){switch(n){case"string":case"stringvector":case"iccProfile":return function(P,e,n){const H=(new TextDecoder).decode(new Uint8Array(P).slice(e.value,e.value+n));return e.value=e.value+n,H}(P.buffer,e,H);case"chlist":return function(P,e,n){const H=e.value,S=[];for(;e.value<H+n-1;){const n=i(P.buffer,e),H=B(P,e),p=b(P,e);e.value+=3;const k=B(P,e),m=B(P,e);S.push({name:n,pixelType:H,pLinear:p,xSampling:k,ySampling:m})}return e.value+=1,S}(P,e,H);case"chromaticities":return function(P,e){return{redX:Q(P,e),redY:Q(P,e),greenX:Q(P,e),greenY:Q(P,e),blueX:Q(P,e),blueY:Q(P,e),whiteX:Q(P,e),whiteY:Q(P,e)}}(P,e);case"compression":return function(P,e){return b(P,e)}(P,e);case"box2i":return function(P,e){return{xMin:B(P,e),yMin:B(P,e),xMax:B(P,e),yMax:B(P,e)}}(P,e);case"lineOrder":return function(P,e){const n=b(P,e);return O[n]}(P,e);case"float":return Q(P,e);case"v2f":return function(P,e){return[Q(P,e),Q(P,e)]}(P,e);case"v3f":return function(P,e){return[Q(P,e),Q(P,e),Q(P,e)]}(P,e);case"int":return B(P,e);case"rational":return function(P,e){return[B(P,e),l(P,e)]}(P,e);case"timecode":return function(P,e){return[l(P,e),l(P,e)]}(P,e);case"preview":return e.value+=H,"skipped";default:return void(e.value+=H)}}function G(P){for(let e=1;e<P.length;e++){const n=P[e-1]+P[e]-128;P[e]=n}}function g(P,e){let n=0,H=Math.floor((P.length+1)/2),S=0;const p=P.length-1;for(;!(S>p)&&(e[S++]=P[n++],!(S>p));)e[S++]=P[H++]}const y=20000630;function f(P,e){if(P.getUint32(0,!0)!=y)throw new Error("Incorrect OpenEXR format");const n=P.getUint8(4),S=P.getUint8(5),p={singleTile:!!(2&S),longName:!!(4&S),deepFormat:!!(8&S),multiPart:!!(16&S)};e.value=8;const k={};let m=!0;for(;m;){const n=i(P.buffer,e);if(n){const S=i(P.buffer,e),p=o(P,e,S,l(P,e));void 0===p?H.c.Warn(`Unknown header attribute type ${S}'.`):k[n]=p}else m=!1}if(0!=(-5&S))throw new Error("Unsupported file format");return{version:n,spec:p,...k}}const Z=32768,v=65535;function u(P,e,n,H,S){for(;n<P;)e=e<<8|d(H,S),n+=8;return{l:e>>(n-=P)&(1<<P)-1,c:e,lc:n}}function W(P,e,n,H){return{c:P=P<<8|d(n,H),lc:e+=8}}function U(P,e,n,H,S,p,k,m,t){if(P==e){if(H<8){const P=W(n,H,S,p);n=P.c,H=P.lc}let P=n>>(H-=8);if(P=new Uint8Array([P])[0],m.value+P>t)return null;const e=k[m.value-1];for(;P-- >0;)k[m.value++]=e}else{if(!(m.value<t))return null;k[m.value++]=P}return{c:n,lc:H}}const a=new Array(59);function L(P,e,n,H,S,p){const k=e;let m=0,t=0;for(;H<=S;H++){if(k.value-e.value>n)return;let C=u(6,m,t,P,k);const R=C.l;if(m=C.c,t=C.lc,p[H]=R,R==w){if(k.value-e.value>n)throw new Error("Error in HufUnpackEncTable");C=u(8,m,t,P,k);let R=C.l+J;if(m=C.c,t=C.lc,H+R>S+1)throw new Error("Error in HufUnpackEncTable");for(;R--;)p[H++]=0;H--}else if(R>=z){let P=R-z+2;if(H+P>S+1)throw new Error("Error in HufUnpackEncTable");for(;P--;)p[H++]=0;H--}}!function(P){for(let n=0;n<=58;++n)a[n]=0;for(let n=0;n<F;++n)a[P[n]]+=1;let e=0;for(let n=58;n>0;--n){const P=e+a[n]>>1;a[n]=e,e=P}for(let n=0;n<F;++n){const e=P[n];e>0&&(P[n]=e|a[e]++<<6)}}(p)}function s(P){return 63&P}function E(P){return P>>6}function X(P,e,n,H,S,p){const k=n.value,m=l(e,n),t=l(e,n);n.value+=4;const C=l(e,n);if(n.value+=4,m<0||m>=F||t<0||t>=F)throw new Error("Wrong HUF_ENCSIZE");const R=new Array(F),q=new Array(Y);!function(P){for(let e=0;e<Y;e++)P[e]={},P[e].len=0,P[e].lit=0,P[e].p=null}(q);if(L(P,n,H-(n.value-k),m,t,R),C>8*(H-(n.value-k)))throw new Error("Wrong hufUncompress");!function(P,e,n,H){for(;e<=n;e++){const n=E(P[e]),S=s(P[e]);if(n>>S)throw new Error("Invalid table entry");if(S>A){const P=H[n>>S-A];if(P.len)throw new Error("Invalid table entry");if(P.lit++,P.p){const e=P.p;P.p=new Array(P.lit);for(let n=0;n<P.lit-1;++n)P.p[n]=e[n]}else P.p=new Array(1);P.p[P.lit-1]=e}else if(S){let P=0;for(let p=1<<A-S;p>0;p--){const p=H[(n<<A-S)+P];if(p.len||p.p)throw new Error("Invalid table entry");p.len=S,p.lit=e,P++}}}}(R,m,t,q),function(P,e,n,H,S,p,k,m,t){let C=0,R=0;const q=k,F=Math.trunc(H.value+(S+7)/8);for(;H.value<F;){let S=W(C,R,n,H);for(C=S.c,R=S.lc;R>=A;){const k=e[C>>R-A&j];if(k.len){R-=k.len;const P=U(k.lit,p,C,R,n,H,m,t,q);P&&(C=P.c,R=P.lc)}else{if(!k.p)throw new Error("hufDecode issues");let e;for(e=0;e<k.lit;e++){const A=s(P[k.p[e]]);for(;R<A&&H.value<F;)S=W(C,R,n,H),C=S.c,R=S.lc;if(R>=A&&E(P[k.p[e]])==(C>>R-A&(1<<A)-1)){R-=A;const P=U(k.p[e],p,C,R,n,H,m,t,q);P&&(C=P.c,R=P.lc);break}}if(e==k.lit)throw new Error("HufDecode issues")}}}const Y=8-S&7;for(C>>=Y,R-=Y;R>0;){const P=e[C<<A-R&j];if(!P.len)throw new Error("HufDecode issues");{R-=P.len;const e=U(P.lit,p,C,R,n,H,m,t,q);e&&(C=e.c,R=e.lc)}}}(R,q,P,n,C,t,p,S,{value:0})}function x(P){return 65535&P}function M(P){const e=x(P);return e>32767?e-65536:e}function K(P,e){const n=M(P),H=M(e),S=n+(1&H)+(H>>1);return{a:S,b:S-H}}function h(P,e){const n=x(P),H=x(e),S=n-(H>>1)&v;return{a:H+S-Z&v,b:S}}function D(P,e,n,H,S,p,k){const m=k<16384,t=n>S?S:n;let C,R,q=1;for(;q<=t;)q<<=1;for(q>>=1,C=q,q>>=1;q>=1;){R=0;const k=R+p*(S-C),t=p*q,A=p*C,F=H*q,Y=H*C;let j,z,w,J;for(;R<=k;R+=A){let S=R;const p=R+H*(n-C);for(;S<=p;S+=Y){const n=S+F,H=S+t,p=H+F;if(m){let k=K(P[S+e],P[H+e]);j=k.a,w=k.b,k=K(P[n+e],P[p+e]),z=k.a,J=k.b,k=K(j,z),P[S+e]=k.a,P[n+e]=k.b,k=K(w,J),P[H+e]=k.a,P[p+e]=k.b}else{let k=h(P[S+e],P[H+e]);j=k.a,w=k.b,k=h(P[n+e],P[p+e]),z=k.a,J=k.b,k=h(j,z),P[S+e]=k.a,P[n+e]=k.b,k=h(w,J),P[H+e]=k.a,P[p+e]=k.b}}if(n&q){const n=S+t;let H;H=m?K(P[S+e],P[n+e]):h(P[S+e],P[n+e]),j=H.a,P[n+e]=H.b,P[S+e]=j}}if(S&q){let S=R;const p=R+H*(n-C);for(;S<=p;S+=Y){const n=S+F;let H;H=m?K(P[S+e],P[n+e]):h(P[S+e],P[n+e]),j=H.a,P[n+e]=H.b,P[S+e]=j}}C=q,q>>=1}return R}function PP(P){return new DataView(P.array.buffer,P.offset.value,P.size)}function eP(P){const e=P.viewer.buffer.slice(P.offset.value,P.offset.value+P.size),n=new Uint8Array(function(P){let e=P.byteLength;const n=[];let H=0;const S=new DataView(P);for(;e>0;){const P=S.getInt8(H++);if(P<0){const p=-P;e-=p+1;for(let P=0;P<p;P++)n.push(S.getUint8(H++))}else{const p=P;e-=2;const k=S.getUint8(H++);for(let P=0;P<p+1;P++)n.push(k)}}return n}(e)),H=new Uint8Array(n.length);return G(n),g(n,H),new DataView(H.buffer)}function nP(P){const e=P.array.slice(P.offset.value,P.offset.value+P.size),n=fflate.unzlibSync(e),H=new Uint8Array(n.length);return G(n),g(n,H),new DataView(H.buffer)}function HP(P){const e=P.array.slice(P.offset.value,P.offset.value+P.size),n=fflate.unzlibSync(e),H=P.lines*P.channels*P.width,S=1==P.type?new Uint16Array(H):new Uint32Array(H);let p=0,k=0;const m=new Array(4);for(let t=0;t<P.lines;t++)for(let e=0;e<P.channels;e++){let e=0;switch(P.type){case 1:m[0]=p,m[1]=m[0]+P.width,p=m[1]+P.width;for(let H=0;H<P.width;++H){e+=n[m[0]++]<<8|n[m[1]++],S[k]=e,k++}break;case 2:m[0]=p,m[1]=m[0]+P.width,m[2]=m[1]+P.width,p=m[2]+P.width;for(let H=0;H<P.width;++H){e+=n[m[0]++]<<24|n[m[1]++]<<16|n[m[2]++]<<8,S[k]=e,k++}}}return new DataView(S.buffer)}function SP(P){const e=P.viewer,n={value:P.offset.value},H=new Uint16Array(P.width*P.scanlineBlockSize*(P.channels*P.type)),S=new Uint8Array(q);let p=0;const k=new Array(P.channels);for(let t=0;t<P.channels;t++)k[t]={},k[t].start=p,k[t].end=k[t].start,k[t].nx=P.width,k[t].ny=P.lines,k[t].size=P.type,p+=k[t].nx*k[t].ny*k[t].size;const m=T(e,n),C=T(e,n);if(C>=q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(m<=C)for(let t=0;t<C-m+1;t++)S[t+m]=b(e,n);const A=new Uint16Array(R),F=function(P,e){let n=0;for(let S=0;S<R;++S)(0==S||P[S>>3]&1<<(7&S))&&(e[n++]=S);const H=n-1;for(;n<R;)e[n++]=0;return H}(S,A),Y=l(e,n);X(P.array,e,n,Y,H,p);for(let t=0;t<P.channels;++t){const P=k[t];for(let e=0;e<k[t].size;++e)D(H,P.start+e,P.nx,P.size,P.ny,P.nx*P.size,F)}!function(P,e,n){for(let H=0;H<n;++H)e[H]=P[e[H]]}(A,H,p);let j=0;const z=new Uint8Array(H.buffer.byteLength);for(let R=0;R<P.lines;R++)for(let e=0;e<P.channels;e++){const P=k[e],n=P.nx*P.size,S=new Uint8Array(H.buffer,P.end*t,n*t);z.set(S,j),j+=n*t,P.end+=n}return new DataView(z.buffer)}var pP,kP=n(10972);!function(P){P[P.Float=0]="Float",P[P.HalfFloat=1]="HalfFloat"}(pP||(pP={}));class mP{}async function tP(P,e,n,H){const S={size:0,viewer:e,array:new Uint8Array(e.buffer),offset:n,width:P.dataWindow.xMax-P.dataWindow.xMin+1,height:P.dataWindow.yMax-P.dataWindow.yMin+1,channels:P.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(P.compression){case I.NO_COMPRESSION:S.lines=1,S.uncompress=PP;break;case I.RLE_COMPRESSION:S.lines=1,S.uncompress=eP;break;case I.ZIPS_COMPRESSION:S.lines=1,S.uncompress=nP,await kP.Tools.LoadScriptAsync(mP.FFLATEUrl);break;case I.ZIP_COMPRESSION:S.lines=16,S.uncompress=nP,await kP.Tools.LoadScriptAsync(mP.FFLATEUrl);break;case I.PIZ_COMPRESSION:S.lines=32,S.uncompress=SP;break;case I.PXR24_COMPRESSION:S.lines=16,S.uncompress=HP,await kP.Tools.LoadScriptAsync(mP.FFLATEUrl);break;default:throw new Error(I[P.compression]+" is unsupported")}S.scanlineBlockSize=S.lines;const p={};for(const k of P.channels)switch(k.name){case"R":case"G":case"B":case"A":case"Y":p[k.name]=!0,S.type=k.pixelType}let m=!1;if(p.R&&p.G&&p.B&&p.A)S.outputChannels=4,S.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G&&p.B)m=!0,S.outputChannels=4,S.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G)S.outputChannels=2,S.decodeChannels={R:0,G:1};else if(p.R)S.outputChannels=1,S.decodeChannels={R:0};else{if(!p.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");S.outputChannels=1,S.decodeChannels={Y:0}}if(1===S.type)switch(H){case pP.Float:S.getter=c,S.inputSize=t;break;case pP.HalfFloat:S.getter=T,S.inputSize=t}else{if(2!==S.type)throw new Error("Unsupported pixelType "+S.type+" for "+P.compression);switch(H){case pP.Float:S.getter=Q,S.inputSize=k;break;case pP.HalfFloat:S.getter=r,S.inputSize=k}}S.blockCount=S.height/S.scanlineBlockSize;for(let k=0;k<S.blockCount;k++)N(e,n);const C=S.width*S.height*S.outputChannels;switch(H){case pP.Float:S.byteArray=new Float32Array(C),S.textureType=1,m&&S.byteArray.fill(1,0,C);break;case pP.HalfFloat:S.byteArray=new Uint16Array(C),S.textureType=2,m&&S.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+H)}let R=0;for(const k of P.channels)void 0!==S.decodeChannels[k.name]&&(S.channelLineOffsets[k.name]=R*S.width),R+=2*k.pixelType;return S.bytesPerLine=S.width*R,S.outLineWidth=S.width*S.outputChannels,"INCREASING_Y"===P.lineOrder?S.scanOrder=P=>P:S.scanOrder=P=>S.height-1-P,4==S.outputChannels?(S.format=5,S.linearSpace=!0):(S.format=6,S.linearSpace=!1),S}function CP(P,e,n,H){const S={value:0};for(let p=0;p<P.height/P.scanlineBlockSize;p++){const k=B(n,H)-e.dataWindow.yMin;P.size=l(n,H),P.lines=k+P.scanlineBlockSize>P.height?P.height-k:P.scanlineBlockSize;const m=P.size<P.lines*P.bytesPerLine&&P.uncompress?P.uncompress(P):PP(P);H.value+=P.size;for(let n=0;n<P.scanlineBlockSize;n++){const H=p*P.scanlineBlockSize,k=n+P.scanOrder(H);if(k>=P.height)continue;const t=n*P.bytesPerLine,C=(P.height-1-k)*P.outLineWidth;for(let n=0;n<P.channels;n++){const H=e.channels[n].name,p=P.channelLineOffsets[H],k=P.decodeChannels[H];if(void 0!==k){S.value=t+p;for(let e=0;e<P.width;e++){const n=C+e*P.outputChannels+k;P.byteArray&&(P.byteArray[n]=P.getter(m,S))}}}}}}mP.DefaultOutputType=pP.HalfFloat,mP.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class RP{constructor(){this.supportCascades=!1}loadCubeData(P,e,n,H,S){throw".exr not supported in Cube."}loadData(P,e,n){const S=new DataView(P.buffer),p={value:0},k=f(S,p);tP(k,S,p,mP.DefaultOutputType).then((P=>{CP(P,k,S,p);const H=k.dataWindow.xMax-k.dataWindow.xMin+1,m=k.dataWindow.yMax-k.dataWindow.yMin+1;n(H,m,e.generateMipMaps,!1,(()=>{const n=e.getEngine();e.format=k.format,e.type=P.textureType,e.invertY=!1,e._gammaSpace=!k.linearSpace,P.byteArray&&n._uploadDataToTextureDirectly(e,P.byteArray,0,0,void 0,!0)}))})).catch((P=>{H.c.Error("Failed to load EXR texture: ",P)}))}}async function qP(P){const e=new DataView(P),n={value:0},S=f(e,n);try{const P=await tP(S,e,n,pP.Float);return CP(P,S,e,n),P.byteArray?{width:S.dataWindow.xMax-S.dataWindow.xMin+1,height:S.dataWindow.yMax-S.dataWindow.yMin+1,data:new Float32Array(P.byteArray)}:(H.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(p){H.c.Error("Failed to load EXR data: ",p)}return{width:0,height:0,data:null}}},11148:(P,e,n)=>{function H(P){return parseInt(P.toString().replace(/\W/g,""))}function S(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(P-e)<=n}function p(P,e,n){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return P<e-H||P>n+H}function k(P,e){return P===e?P:Math.random()*(e-P)+P}function m(P,e,n){return P+(e-P)*n}function t(P,e,n){let H=z(e-P,360);return H>180&&(H-=360),P+H*A(n)}function C(P,e,n){let H=0;return H=P!=e?A((n-P)/(e-P)):0,H}function R(P,e,n,H,S){const p=S*S,k=S*p;return P*(2*k-3*p+1)+n*(-2*k+3*p)+e*(k-2*p+S)+H*(k-p)}function q(P,e,n,H,S){const p=S*S;return 6*(p-S)*P+(3*p-4*S+1)*e+6*(-p+S)*n+(3*p-2*S)*H}function A(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(n,Math.max(e,P))}function F(P){return P-=2*Math.PI*Math.floor((P+Math.PI)/(2*Math.PI))}function Y(P){const e=P.toString(16);return P<=15?("0"+e).toUpperCase():e.toUpperCase()}function j(P){if(Math.log2)return Math.floor(Math.log2(P));if(P<0)return NaN;if(0===P)return-1/0;let e=0;if(P<1){for(;P<1;)e++,P*=2;e=-e}else if(P>1)for(;P>1;)e++,P=Math.floor(P/2);return e}function z(P,e){return P-Math.floor(P/e)*e}function w(P,e,n){return(P-e)/(n-e)}function J(P,e,n){return P*(n-e)+e}function I(P,e){let n=z(e-P,360);return n>180&&(n-=360),n}function O(P,e){const n=z(P,2*e);return e-Math.abs(n-e)}function V(P,e,n){let H=A(n);return H=-2*H*H*H+3*H*H,e*H+P*(1-H)}function i(P,e,n){let H=0;return H=Math.abs(e-P)<=n?e:P+Math.sign(e-P)*n,H}function B(P,e,n){const H=I(P,e);let S=0;return S=-n<H&&H<n?e:i(P,e=P+H,n),S}function l(P,e,n){return(P-e)/(n-e)}function b(P,e,n){return(n-e)*P+e}function T(P,e){const n=P%e;return 0===n?e:T(e,n)}n.r(e),n.d(e,{Clamp:()=>A,DeltaAngle:()=>I,Denormalize:()=>J,ExtractAsInt:()=>H,Hermite:()=>R,Hermite1stDerivative:()=>q,HighestCommonFactor:()=>T,ILog2:()=>j,InverseLerp:()=>C,Lerp:()=>m,LerpAngle:()=>t,MoveTowards:()=>i,MoveTowardsAngle:()=>B,Normalize:()=>w,NormalizeRadians:()=>F,OutsideRange:()=>p,PercentToRange:()=>b,PingPong:()=>O,RandomRange:()=>k,RangeToPercent:()=>l,Repeat:()=>z,SmoothStep:()=>V,ToHex:()=>Y,WithinEpsilon:()=>S})}}]);