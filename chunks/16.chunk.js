"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[16],{14272:(C,U,K)=>{K.r(U),K.d(U,{ReadExrDataAsync:()=>pC,_ExrTextureLoader:()=>jC});var m=K(11679),O=K(11846);const X=4,A=4,e=1,t=2,z=8,j=65536,p=j>>3,E=14,u=65537,b=1<<E,v=b-1,Q=59,V=63,f=2+V-Q;var F,Z;!function(C){C[C.NO_COMPRESSION=0]="NO_COMPRESSION",C[C.RLE_COMPRESSION=1]="RLE_COMPRESSION",C[C.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",C[C.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",C[C.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",C[C.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(F||(F={})),function(C){C[C.INCREASING_Y=0]="INCREASING_Y",C[C.DECREASING_Y=1]="DECREASING_Y"}(Z||(Z={}));const P=function(){const C=new ArrayBuffer(4),U=new Float32Array(C),K=new Uint32Array(C),m=new Uint32Array(512),O=new Uint32Array(512);for(let t=0;t<256;++t){const C=t-127;C<-27?(m[t]=0,m[256|t]=32768,O[t]=24,O[256|t]=24):C<-14?(m[t]=1024>>-C-14,m[256|t]=1024>>-C-14|32768,O[t]=-C-1,O[256|t]=-C-1):C<=15?(m[t]=C+15<<10,m[256|t]=C+15<<10|32768,O[t]=13,O[256|t]=13):C<128?(m[t]=31744,m[256|t]=64512,O[t]=24,O[256|t]=24):(m[t]=31744,m[256|t]=64512,O[t]=13,O[256|t]=13)}const X=new Uint32Array(2048),A=new Uint32Array(64),e=new Uint32Array(64);for(let t=1;t<1024;++t){let C=t<<13,U=0;for(;0===(8388608&C);)C<<=1,U-=8388608;C&=-8388609,U+=947912704,X[t]=C|U}for(let t=1024;t<2048;++t)X[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)A[t]=t<<23;A[31]=1199570944,A[32]=2147483648;for(let t=33;t<63;++t)A[t]=2147483648+(t-32<<23);A[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(e[t]=1024);return{floatView:U,uint32View:K,baseTable:m,shiftTable:O,mantissaTable:X,exponentTable:A,offsetTable:e}}();function H(C,U){const K=new Uint8Array(C);let m=0;for(;0!=K[U.value+m];)m+=1;const O=(new TextDecoder).decode(K.slice(U.value,U.value+m));return U.value=U.value+m+1,O}function d(C,U){const K=C.getInt32(U.value,!0);return U.value+=X,K}function T(C,U){const K=C.getUint32(U.value,!0);return U.value+=X,K}function y(C,U){const K=C.getUint8(U.value);return U.value+=e,K}function a(C,U){const K=C.getUint16(U.value,!0);return U.value+=t,K}function r(C,U){const K=C[U.value];return U.value+=e,K}function i(C,U){let K;return K="getBigInt64"in DataView.prototype?Number(C.getBigInt64(U.value,!0)):C.getUint32(U.value+4,!0)+Number(C.getUint32(U.value,!0)<<32),U.value+=z,K}function D(C,U){const K=C.getFloat32(U.value,!0);return U.value+=A,K}function l(C,U){return function(C){const U=(31744&C)>>10,K=1023&C;return(C>>15?-1:1)*(U?31===U?K?NaN:1/0:Math.pow(2,U-15)*(1+K/1024):K/1024*6103515625e-14)}(a(C,U))}function G(C,U){return function(C){if(Math.abs(C)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");C=(0,O.Clamp)(C,-65504,65504),P.floatView[0]=C;const U=P.uint32View[0],K=U>>23&511;return P.baseTable[K]+((8388607&U)>>P.shiftTable[K])}(D(C,U))}function J(C,U,K,m){switch(K){case"string":case"stringvector":case"iccProfile":return function(C,U,K){const m=(new TextDecoder).decode(new Uint8Array(C).slice(U.value,U.value+K));return U.value=U.value+K,m}(C.buffer,U,m);case"chlist":return function(C,U,K){const m=U.value,O=[];for(;U.value<m+K-1;){const K=H(C.buffer,U),m=d(C,U),X=y(C,U);U.value+=3;const A=d(C,U),e=d(C,U);O.push({name:K,pixelType:m,pLinear:X,xSampling:A,ySampling:e})}return U.value+=1,O}(C,U,m);case"chromaticities":return function(C,U){return{redX:D(C,U),redY:D(C,U),greenX:D(C,U),greenY:D(C,U),blueX:D(C,U),blueY:D(C,U),whiteX:D(C,U),whiteY:D(C,U)}}(C,U);case"compression":return function(C,U){return y(C,U)}(C,U);case"box2i":return function(C,U){return{xMin:d(C,U),yMin:d(C,U),xMax:d(C,U),yMax:d(C,U)}}(C,U);case"lineOrder":return function(C,U){const K=y(C,U);return Z[K]}(C,U);case"float":return D(C,U);case"v2f":return function(C,U){return[D(C,U),D(C,U)]}(C,U);case"v3f":return function(C,U){return[D(C,U),D(C,U),D(C,U)]}(C,U);case"int":return d(C,U);case"rational":return function(C,U){return[d(C,U),T(C,U)]}(C,U);case"timecode":return function(C,U){return[T(C,U),T(C,U)]}(C,U);case"preview":return U.value+=m,"skipped";default:return void(U.value+=m)}}function o(C){for(let U=1;U<C.length;U++){const K=C[U-1]+C[U]-128;C[U]=K}}function B(C,U){let K=0,m=Math.floor((C.length+1)/2),O=0;const X=C.length-1;for(;!(O>X)&&(U[O++]=C[K++],!(O>X));)U[O++]=C[m++]}const k=20000630;function w(C,U){if(C.getUint32(0,!0)!=k)throw new Error("Incorrect OpenEXR format");const K=C.getUint8(4),O=C.getUint8(5),X={singleTile:!!(2&O),longName:!!(4&O),deepFormat:!!(8&O),multiPart:!!(16&O)};U.value=8;const A={};let e=!0;for(;e;){const K=H(C.buffer,U);if(K){const O=H(C.buffer,U),X=J(C,U,O,T(C,U));void 0===X?m.d.Warn(`Unknown header attribute type ${O}'.`):A[K]=X}else e=!1}if(0!=(-5&O))throw new Error("Unsupported file format");return{version:K,spec:X,...A}}const h=32768,c=65535;function N(C,U,K,m,O){for(;K<C;)U=U<<8|r(m,O),K+=8;return{l:U>>(K-=C)&(1<<C)-1,c:U,lc:K}}function g(C,U,K,m){return{c:C=C<<8|r(K,m),lc:U+=8}}function M(C,U,K,m,O,X,A,e,t){if(C==U){if(m<8){const C=g(K,m,O,X);K=C.c,m=C.lc}let C=K>>(m-=8);if(C=new Uint8Array([C])[0],e.value+C>t)return null;const U=A[e.value-1];for(;C-- >0;)A[e.value++]=U}else{if(!(e.value<t))return null;A[e.value++]=C}return{c:K,lc:m}}const L=new Array(59);function Y(C,U,K,m,O,X){const A=U;let e=0,t=0;for(;m<=O;m++){if(A.value-U.value>K)return;let z=N(6,e,t,C,A);const j=z.l;if(e=z.c,t=z.lc,X[m]=j,j==V){if(A.value-U.value>K)throw new Error("Error in HufUnpackEncTable");z=N(8,e,t,C,A);let j=z.l+f;if(e=z.c,t=z.lc,m+j>O+1)throw new Error("Error in HufUnpackEncTable");for(;j--;)X[m++]=0;m--}else if(j>=Q){let C=j-Q+2;if(m+C>O+1)throw new Error("Error in HufUnpackEncTable");for(;C--;)X[m++]=0;m--}}!function(C){for(let K=0;K<=58;++K)L[K]=0;for(let K=0;K<u;++K)L[C[K]]+=1;let U=0;for(let K=58;K>0;--K){const C=U+L[K]>>1;L[K]=U,U=C}for(let K=0;K<u;++K){const U=C[K];U>0&&(C[K]=U|L[U]++<<6)}}(X)}function W(C){return 63&C}function x(C){return C>>6}function n(C,U,K,m,O,X){const A=K.value,e=T(U,K),t=T(U,K);K.value+=4;const z=T(U,K);if(K.value+=4,e<0||e>=u||t<0||t>=u)throw new Error("Wrong HUF_ENCSIZE");const j=new Array(u),p=new Array(b);!function(C){for(let U=0;U<b;U++)C[U]={},C[U].len=0,C[U].lit=0,C[U].p=null}(p);if(Y(C,K,m-(K.value-A),e,t,j),z>8*(m-(K.value-A)))throw new Error("Wrong hufUncompress");!function(C,U,K,m){for(;U<=K;U++){const K=x(C[U]),O=W(C[U]);if(K>>O)throw new Error("Invalid table entry");if(O>E){const C=m[K>>O-E];if(C.len)throw new Error("Invalid table entry");if(C.lit++,C.p){const U=C.p;C.p=new Array(C.lit);for(let K=0;K<C.lit-1;++K)C.p[K]=U[K]}else C.p=new Array(1);C.p[C.lit-1]=U}else if(O){let C=0;for(let X=1<<E-O;X>0;X--){const X=m[(K<<E-O)+C];if(X.len||X.p)throw new Error("Invalid table entry");X.len=O,X.lit=U,C++}}}}(j,e,t,p),function(C,U,K,m,O,X,A,e,t){let z=0,j=0;const p=A,u=Math.trunc(m.value+(O+7)/8);for(;m.value<u;){let O=g(z,j,K,m);for(z=O.c,j=O.lc;j>=E;){const A=U[z>>j-E&v];if(A.len){j-=A.len;const C=M(A.lit,X,z,j,K,m,e,t,p);C&&(z=C.c,j=C.lc)}else{if(!A.p)throw new Error("hufDecode issues");let U;for(U=0;U<A.lit;U++){const E=W(C[A.p[U]]);for(;j<E&&m.value<u;)O=g(z,j,K,m),z=O.c,j=O.lc;if(j>=E&&x(C[A.p[U]])==(z>>j-E&(1<<E)-1)){j-=E;const C=M(A.p[U],X,z,j,K,m,e,t,p);C&&(z=C.c,j=C.lc);break}}if(U==A.lit)throw new Error("HufDecode issues")}}}const b=8-O&7;for(z>>=b,j-=b;j>0;){const C=U[z<<E-j&v];if(!C.len)throw new Error("HufDecode issues");{j-=C.len;const U=M(C.lit,X,z,j,K,m,e,t,p);U&&(z=U.c,j=U.lc)}}}(j,p,C,K,z,t,X,O,{value:0})}function S(C){return 65535&C}function s(C){const U=S(C);return U>32767?U-65536:U}function R(C,U){const K=s(C),m=s(U),O=K+(1&m)+(m>>1);return{a:O,b:O-m}}function q(C,U){const K=S(C),m=S(U),O=K-(m>>1)&c;return{a:m+O-h&c,b:O}}function I(C,U,K,m,O,X,A){const e=A<16384,t=K>O?O:K;let z,j,p=1;for(;p<=t;)p<<=1;for(p>>=1,z=p,p>>=1;p>=1;){j=0;const A=j+X*(O-z),t=X*p,E=X*z,u=m*p,b=m*z;let v,Q,V,f;for(;j<=A;j+=E){let O=j;const X=j+m*(K-z);for(;O<=X;O+=b){const K=O+u,m=O+t,X=m+u;if(e){let A=R(C[O+U],C[m+U]);v=A.a,V=A.b,A=R(C[K+U],C[X+U]),Q=A.a,f=A.b,A=R(v,Q),C[O+U]=A.a,C[K+U]=A.b,A=R(V,f),C[m+U]=A.a,C[X+U]=A.b}else{let A=q(C[O+U],C[m+U]);v=A.a,V=A.b,A=q(C[K+U],C[X+U]),Q=A.a,f=A.b,A=q(v,Q),C[O+U]=A.a,C[K+U]=A.b,A=q(V,f),C[m+U]=A.a,C[X+U]=A.b}}if(K&p){const K=O+t;let m;m=e?R(C[O+U],C[K+U]):q(C[O+U],C[K+U]),v=m.a,C[K+U]=m.b,C[O+U]=v}}if(O&p){let O=j;const X=j+m*(K-z);for(;O<=X;O+=b){const K=O+u;let m;m=e?R(C[O+U],C[K+U]):q(C[O+U],C[K+U]),v=m.a,C[K+U]=m.b,C[O+U]=v}}z=p,p>>=1}return j}function CC(C){return new DataView(C.array.buffer,C.offset.value,C.size)}function UC(C){const U=C.viewer.buffer.slice(C.offset.value,C.offset.value+C.size),K=new Uint8Array(function(C){let U=C.byteLength;const K=[];let m=0;const O=new DataView(C);for(;U>0;){const C=O.getInt8(m++);if(C<0){const X=-C;U-=X+1;for(let C=0;C<X;C++)K.push(O.getUint8(m++))}else{const X=C;U-=2;const A=O.getUint8(m++);for(let C=0;C<X+1;C++)K.push(A)}}return K}(U)),m=new Uint8Array(K.length);return o(K),B(K,m),new DataView(m.buffer)}function KC(C){const U=C.array.slice(C.offset.value,C.offset.value+C.size),K=fflate.unzlibSync(U),m=new Uint8Array(K.length);return o(K),B(K,m),new DataView(m.buffer)}function mC(C){const U=C.array.slice(C.offset.value,C.offset.value+C.size),K=fflate.unzlibSync(U),m=C.lines*C.channels*C.width,O=1==C.type?new Uint16Array(m):new Uint32Array(m);let X=0,A=0;const e=new Array(4);for(let t=0;t<C.lines;t++)for(let U=0;U<C.channels;U++){let U=0;switch(C.type){case 1:e[0]=X,e[1]=e[0]+C.width,X=e[1]+C.width;for(let m=0;m<C.width;++m){U+=K[e[0]++]<<8|K[e[1]++],O[A]=U,A++}break;case 2:e[0]=X,e[1]=e[0]+C.width,e[2]=e[1]+C.width,X=e[2]+C.width;for(let m=0;m<C.width;++m){U+=K[e[0]++]<<24|K[e[1]++]<<16|K[e[2]++]<<8,O[A]=U,A++}}}return new DataView(O.buffer)}function OC(C){const U=C.viewer,K={value:C.offset.value},m=new Uint16Array(C.width*C.scanlineBlockSize*(C.channels*C.type)),O=new Uint8Array(p);let X=0;const A=new Array(C.channels);for(let t=0;t<C.channels;t++)A[t]={},A[t].start=X,A[t].end=A[t].start,A[t].nx=C.width,A[t].ny=C.lines,A[t].size=C.type,X+=A[t].nx*A[t].ny*A[t].size;const e=a(U,K),z=a(U,K);if(z>=p)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(e<=z)for(let t=0;t<z-e+1;t++)O[t+e]=y(U,K);const E=new Uint16Array(j),u=function(C,U){let K=0;for(let O=0;O<j;++O)(0==O||C[O>>3]&1<<(7&O))&&(U[K++]=O);const m=K-1;for(;K<j;)U[K++]=0;return m}(O,E),b=T(U,K);n(C.array,U,K,b,m,X);for(let t=0;t<C.channels;++t){const C=A[t];for(let U=0;U<A[t].size;++U)I(m,C.start+U,C.nx,C.size,C.ny,C.nx*C.size,u)}!function(C,U,K){for(let m=0;m<K;++m)U[m]=C[U[m]]}(E,m,X);let v=0;const Q=new Uint8Array(m.buffer.byteLength);for(let j=0;j<C.lines;j++)for(let U=0;U<C.channels;U++){const C=A[U],K=C.nx*C.size,O=new Uint8Array(m.buffer,C.end*t,K*t);Q.set(O,v),v+=K*t,C.end+=K}return new DataView(Q.buffer)}var XC,AC=K(11660);!function(C){C[C.Float=0]="Float",C[C.HalfFloat=1]="HalfFloat"}(XC||(XC={}));class eC{}async function tC(C,U,K,m){const O={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:K,width:C.dataWindow.xMax-C.dataWindow.xMin+1,height:C.dataWindow.yMax-C.dataWindow.yMin+1,channels:C.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(C.compression){case F.NO_COMPRESSION:O.lines=1,O.uncompress=CC;break;case F.RLE_COMPRESSION:O.lines=1,O.uncompress=UC;break;case F.ZIPS_COMPRESSION:O.lines=1,O.uncompress=KC,await AC.Tools.LoadScriptAsync(eC.FFLATEUrl);break;case F.ZIP_COMPRESSION:O.lines=16,O.uncompress=KC,await AC.Tools.LoadScriptAsync(eC.FFLATEUrl);break;case F.PIZ_COMPRESSION:O.lines=32,O.uncompress=OC;break;case F.PXR24_COMPRESSION:O.lines=16,O.uncompress=mC,await AC.Tools.LoadScriptAsync(eC.FFLATEUrl);break;default:throw new Error(F[C.compression]+" is unsupported")}O.scanlineBlockSize=O.lines;const X={};for(const A of C.channels)switch(A.name){case"R":case"G":case"B":case"A":case"Y":X[A.name]=!0,O.type=A.pixelType}let e=!1;if(X.R&&X.G&&X.B&&X.A)O.outputChannels=4,O.decodeChannels={R:0,G:1,B:2,A:3};else if(X.R&&X.G&&X.B)e=!0,O.outputChannels=4,O.decodeChannels={R:0,G:1,B:2,A:3};else if(X.R&&X.G)O.outputChannels=2,O.decodeChannels={R:0,G:1};else if(X.R)O.outputChannels=1,O.decodeChannels={R:0};else{if(!X.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");O.outputChannels=1,O.decodeChannels={Y:0}}if(1===O.type)switch(m){case XC.Float:O.getter=l,O.inputSize=t;break;case XC.HalfFloat:O.getter=a,O.inputSize=t}else{if(2!==O.type)throw new Error("Unsupported pixelType "+O.type+" for "+C.compression);switch(m){case XC.Float:O.getter=D,O.inputSize=A;break;case XC.HalfFloat:O.getter=G,O.inputSize=A}}O.blockCount=O.height/O.scanlineBlockSize;for(let A=0;A<O.blockCount;A++)i(U,K);const z=O.width*O.height*O.outputChannels;switch(m){case XC.Float:O.byteArray=new Float32Array(z),O.textureType=1,e&&O.byteArray.fill(1,0,z);break;case XC.HalfFloat:O.byteArray=new Uint16Array(z),O.textureType=2,e&&O.byteArray.fill(15360,0,z);break;default:throw new Error("Unsupported type: "+m)}let j=0;for(const A of C.channels)void 0!==O.decodeChannels[A.name]&&(O.channelLineOffsets[A.name]=j*O.width),j+=2*A.pixelType;return O.bytesPerLine=O.width*j,O.outLineWidth=O.width*O.outputChannels,"INCREASING_Y"===C.lineOrder?O.scanOrder=C=>C:O.scanOrder=C=>O.height-1-C,4==O.outputChannels?(O.format=5,O.linearSpace=!0):(O.format=6,O.linearSpace=!1),O}function zC(C,U,K,m){const O={value:0};for(let X=0;X<C.height/C.scanlineBlockSize;X++){const A=d(K,m)-U.dataWindow.yMin;C.size=T(K,m),C.lines=A+C.scanlineBlockSize>C.height?C.height-A:C.scanlineBlockSize;const e=C.size<C.lines*C.bytesPerLine&&C.uncompress?C.uncompress(C):CC(C);m.value+=C.size;for(let K=0;K<C.scanlineBlockSize;K++){const m=X*C.scanlineBlockSize,A=K+C.scanOrder(m);if(A>=C.height)continue;const t=K*C.bytesPerLine,z=(C.height-1-A)*C.outLineWidth;for(let K=0;K<C.channels;K++){const m=U.channels[K].name,X=C.channelLineOffsets[m],A=C.decodeChannels[m];if(void 0!==A){O.value=t+X;for(let U=0;U<C.width;U++){const K=z+U*C.outputChannels+A;C.byteArray&&(C.byteArray[K]=C.getter(e,O))}}}}}}eC.DefaultOutputType=XC.HalfFloat,eC.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class jC{constructor(){this.supportCascades=!1}loadCubeData(C,U,K,m,O){throw".exr not supported in Cube."}loadData(C,U,K){const O=new DataView(C.buffer),X={value:0},A=w(O,X);tC(A,O,X,eC.DefaultOutputType).then((C=>{zC(C,A,O,X);const m=A.dataWindow.xMax-A.dataWindow.xMin+1,e=A.dataWindow.yMax-A.dataWindow.yMin+1;K(m,e,U.generateMipMaps,!1,(()=>{const K=U.getEngine();U.format=A.format,U.type=C.textureType,U.invertY=!1,U._gammaSpace=!A.linearSpace,C.byteArray&&K._uploadDataToTextureDirectly(U,C.byteArray,0,0,void 0,!0)}))})).catch((C=>{m.d.Error("Failed to load EXR texture: ",C)}))}}async function pC(C){const U=new DataView(C),K={value:0},O=w(U,K);try{const C=await tC(O,U,K,XC.Float);return zC(C,O,U,K),C.byteArray?{width:O.dataWindow.xMax-O.dataWindow.xMin+1,height:O.dataWindow.yMax-O.dataWindow.yMin+1,data:new Float32Array(C.byteArray)}:(m.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(X){m.d.Error("Failed to load EXR data: ",X)}return{width:0,height:0,data:null}}},11846:(C,U,K)=>{function m(C){return parseInt(C.toString().replace(/\W/g,""))}function O(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(C-U)<=K}function X(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return C<U-m||C>K+m}function A(C,U){return C===U?C:Math.random()*(U-C)+C}function e(C,U,K){return C+(U-C)*K}function t(C,U,K){let m=Q(U-C,360);return m>180&&(m-=360),C+m*E(K)}function z(C,U,K){let m=0;return m=C!=U?E((K-C)/(U-C)):0,m}function j(C,U,K,m,O){const X=O*O,A=O*X;return C*(2*A-3*X+1)+K*(-2*A+3*X)+U*(A-2*X+O)+m*(A-X)}function p(C,U,K,m,O){const X=O*O;return 6*(X-O)*C+(3*X-4*O+1)*U+6*(-X+O)*K+(3*X-2*O)*m}function E(C){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(K,Math.max(U,C))}function u(C){return C-=2*Math.PI*Math.floor((C+Math.PI)/(2*Math.PI))}function b(C){const U=C.toString(16);return C<=15?("0"+U).toUpperCase():U.toUpperCase()}function v(C){if(Math.log2)return Math.floor(Math.log2(C));if(C<0)return NaN;if(0===C)return-1/0;let U=0;if(C<1){for(;C<1;)U++,C*=2;U=-U}else if(C>1)for(;C>1;)U++,C=Math.floor(C/2);return U}function Q(C,U){return C-Math.floor(C/U)*U}function V(C,U,K){return(C-U)/(K-U)}function f(C,U,K){return C*(K-U)+U}function F(C,U){let K=Q(U-C,360);return K>180&&(K-=360),K}function Z(C,U){const K=Q(C,2*U);return U-Math.abs(K-U)}function P(C,U,K){let m=E(K);return m=-2*m*m*m+3*m*m,U*m+C*(1-m)}function H(C,U,K){let m=0;return m=Math.abs(U-C)<=K?U:C+Math.sign(U-C)*K,m}function d(C,U,K){const m=F(C,U);let O=0;return O=-K<m&&m<K?U:H(C,U=C+m,K),O}function T(C,U,K){return(C-U)/(K-U)}function y(C,U,K){return(K-U)*C+U}function a(C,U){const K=C%U;return 0===K?U:a(U,K)}K.r(U),K.d(U,{Clamp:()=>E,DeltaAngle:()=>F,Denormalize:()=>f,ExtractAsInt:()=>m,Hermite:()=>j,Hermite1stDerivative:()=>p,HighestCommonFactor:()=>a,ILog2:()=>v,InverseLerp:()=>z,Lerp:()=>e,LerpAngle:()=>t,MoveTowards:()=>H,MoveTowardsAngle:()=>d,Normalize:()=>V,NormalizeRadians:()=>u,OutsideRange:()=>X,PercentToRange:()=>y,PingPong:()=>Z,RandomRange:()=>A,RangeToPercent:()=>T,Repeat:()=>Q,SmoothStep:()=>P,ToHex:()=>b,WithinEpsilon:()=>O})}}]);