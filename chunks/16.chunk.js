"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2708:(P,Q,O)=>{function b(P){return Math.floor(P/8)}function F(P){return 1<<P%8}O.d(Q,{OptimizeIndices:()=>m});class g{constructor(P){this.size=P,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(P){if(P>=this.size)throw new RangeError("Bit index out of range");const Q=b(P),O=F(P);return 0!==(this._byteArray[Q]&O)}set(P,Q){if(P>=this.size)throw new RangeError("Bit index out of range");const O=b(P),g=F(P);Q?this._byteArray[O]|=g:this._byteArray[O]&=~g}}function m(P){const Q=[],O=P.length/3;for(let g=0;g<O;g++)Q.push([P[3*g],P[3*g+1],P[3*g+2]]);const b=new Map;for(let g=0;g<Q.length;g++){const P=Q[g];for(const Q of P){let P=b.get(Q);P||b.set(Q,P=[]),P.push(g)}}const F=new g(O),m=[],q=P=>{const O=[P];for(;O.length>0;){const P=O.pop();if(!F.get(P)){F.set(P,!0),m.push(Q[P]);for(const g of Q[P]){const P=b.get(g);if(!P)return;for(const Q of P)F.get(Q)||O.push(Q)}}}};for(let g=0;g<O;g++)F.get(g)||q(g);let R=0;for(const g of m)P[R++]=g[0],P[R++]=g[1],P[R++]=g[2]}}}]);