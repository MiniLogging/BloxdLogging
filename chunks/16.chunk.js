"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[16],{15277:(h,d,T)=>{T.r(d),T.d(d,{ReadExrDataAsync:()=>Sh,_ExrTextureLoader:()=>Zh});var Y=T(12596),y=T(12787);const C=4,n=4,X=1,F=2,U=8,Z=65536,S=Z>>3,r=14,c=65537,O=1<<r,f=O-1,J=59,W=63,L=2+W-J;var D,V;!function(h){h[h.NO_COMPRESSION=0]="NO_COMPRESSION",h[h.RLE_COMPRESSION=1]="RLE_COMPRESSION",h[h.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",h[h.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",h[h.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",h[h.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(D||(D={})),function(h){h[h.INCREASING_Y=0]="INCREASING_Y",h[h.DECREASING_Y=1]="DECREASING_Y"}(V||(V={}));const i=function(){const h=new ArrayBuffer(4),d=new Float32Array(h),T=new Uint32Array(h),Y=new Uint32Array(512),y=new Uint32Array(512);for(let F=0;F<256;++F){const h=F-127;h<-27?(Y[F]=0,Y[256|F]=32768,y[F]=24,y[256|F]=24):h<-14?(Y[F]=1024>>-h-14,Y[256|F]=1024>>-h-14|32768,y[F]=-h-1,y[256|F]=-h-1):h<=15?(Y[F]=h+15<<10,Y[256|F]=h+15<<10|32768,y[F]=13,y[256|F]=13):h<128?(Y[F]=31744,Y[256|F]=64512,y[F]=24,y[256|F]=24):(Y[F]=31744,Y[256|F]=64512,y[F]=13,y[256|F]=13)}const C=new Uint32Array(2048),n=new Uint32Array(64),X=new Uint32Array(64);for(let F=1;F<1024;++F){let h=F<<13,d=0;for(;0===(8388608&h);)h<<=1,d-=8388608;h&=-8388609,d+=947912704,C[F]=h|d}for(let F=1024;F<2048;++F)C[F]=939524096+(F-1024<<13);for(let F=1;F<31;++F)n[F]=F<<23;n[31]=1199570944,n[32]=2147483648;for(let F=33;F<63;++F)n[F]=2147483648+(F-32<<23);n[63]=3347054592;for(let F=1;F<64;++F)32!==F&&(X[F]=1024);return{floatView:d,uint32View:T,baseTable:Y,shiftTable:y,mantissaTable:C,exponentTable:n,offsetTable:X}}();function w(h,d){const T=new Uint8Array(h);let Y=0;for(;0!=T[d.value+Y];)Y+=1;const y=(new TextDecoder).decode(T.slice(d.value,d.value+Y));return d.value=d.value+Y+1,y}function s(h,d){const T=h.getInt32(d.value,!0);return d.value+=C,T}function E(h,d){const T=h.getUint32(d.value,!0);return d.value+=C,T}function z(h,d){const T=h.getUint8(d.value);return d.value+=X,T}function x(h,d){const T=h.getUint16(d.value,!0);return d.value+=F,T}function g(h,d){const T=h[d.value];return d.value+=X,T}function H(h,d){let T;return T="getBigInt64"in DataView.prototype?Number(h.getBigInt64(d.value,!0)):h.getUint32(d.value+4,!0)+Number(h.getUint32(d.value,!0)<<32),d.value+=U,T}function p(h,d){const T=h.getFloat32(d.value,!0);return d.value+=n,T}function k(h,d){return function(h){const d=(31744&h)>>10,T=1023&h;return(h>>15?-1:1)*(d?31===d?T?NaN:1/0:Math.pow(2,d-15)*(1+T/1024):T/1024*6103515625e-14)}(x(h,d))}function o(h,d){return function(h){if(Math.abs(h)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");h=(0,y.Clamp)(h,-65504,65504),i.floatView[0]=h;const d=i.uint32View[0],T=d>>23&511;return i.baseTable[T]+((8388607&d)>>i.shiftTable[T])}(p(h,d))}function u(h,d,T,Y){switch(T){case"string":case"stringvector":case"iccProfile":return function(h,d,T){const Y=(new TextDecoder).decode(new Uint8Array(h).slice(d.value,d.value+T));return d.value=d.value+T,Y}(h.buffer,d,Y);case"chlist":return function(h,d,T){const Y=d.value,y=[];for(;d.value<Y+T-1;){const T=w(h.buffer,d),Y=s(h,d),C=z(h,d);d.value+=3;const n=s(h,d),X=s(h,d);y.push({name:T,pixelType:Y,pLinear:C,xSampling:n,ySampling:X})}return d.value+=1,y}(h,d,Y);case"chromaticities":return function(h,d){return{redX:p(h,d),redY:p(h,d),greenX:p(h,d),greenY:p(h,d),blueX:p(h,d),blueY:p(h,d),whiteX:p(h,d),whiteY:p(h,d)}}(h,d);case"compression":return function(h,d){return z(h,d)}(h,d);case"box2i":return function(h,d){return{xMin:s(h,d),yMin:s(h,d),xMax:s(h,d),yMax:s(h,d)}}(h,d);case"lineOrder":return function(h,d){const T=z(h,d);return V[T]}(h,d);case"float":return p(h,d);case"v2f":return function(h,d){return[p(h,d),p(h,d)]}(h,d);case"v3f":return function(h,d){return[p(h,d),p(h,d),p(h,d)]}(h,d);case"int":return s(h,d);case"rational":return function(h,d){return[s(h,d),E(h,d)]}(h,d);case"timecode":return function(h,d){return[E(h,d),E(h,d)]}(h,d);case"preview":return d.value+=Y,"skipped";default:return void(d.value+=Y)}}function N(h){for(let d=1;d<h.length;d++){const T=h[d-1]+h[d]-128;h[d]=T}}function K(h,d){let T=0,Y=Math.floor((h.length+1)/2),y=0;const C=h.length-1;for(;!(y>C)&&(d[y++]=h[T++],!(y>C));)d[y++]=h[Y++]}const l=20000630;function q(h,d){if(h.getUint32(0,!0)!=l)throw new Error("Incorrect OpenEXR format");const T=h.getUint8(4),y=h.getUint8(5),C={singleTile:!!(2&y),longName:!!(4&y),deepFormat:!!(8&y),multiPart:!!(16&y)};d.value=8;const n={};let X=!0;for(;X;){const T=w(h.buffer,d);if(T){const y=w(h.buffer,d),C=u(h,d,y,E(h,d));void 0===C?Y.c.Warn(`Unknown header attribute type ${y}'.`):n[T]=C}else X=!1}if(0!=(-5&y))throw new Error("Unsupported file format");return{version:T,spec:C,...n}}const j=32768,a=65535;function e(h,d,T,Y,y){for(;T<h;)d=d<<8|g(Y,y),T+=8;return{l:d>>(T-=h)&(1<<h)-1,c:d,lc:T}}function v(h,d,T,Y){return{c:h=h<<8|g(T,Y),lc:d+=8}}function G(h,d,T,Y,y,C,n,X,F){if(h==d){if(Y<8){const h=v(T,Y,y,C);T=h.c,Y=h.lc}let h=T>>(Y-=8);if(h=new Uint8Array([h])[0],X.value+h>F)return null;const d=n[X.value-1];for(;h-- >0;)n[X.value++]=d}else{if(!(X.value<F))return null;n[X.value++]=h}return{c:T,lc:Y}}const b=new Array(59);function B(h,d,T,Y,y,C){const n=d;let X=0,F=0;for(;Y<=y;Y++){if(n.value-d.value>T)return;let U=e(6,X,F,h,n);const Z=U.l;if(X=U.c,F=U.lc,C[Y]=Z,Z==W){if(n.value-d.value>T)throw new Error("Error in HufUnpackEncTable");U=e(8,X,F,h,n);let Z=U.l+L;if(X=U.c,F=U.lc,Y+Z>y+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)C[Y++]=0;Y--}else if(Z>=J){let h=Z-J+2;if(Y+h>y+1)throw new Error("Error in HufUnpackEncTable");for(;h--;)C[Y++]=0;Y--}}!function(h){for(let T=0;T<=58;++T)b[T]=0;for(let T=0;T<c;++T)b[h[T]]+=1;let d=0;for(let T=58;T>0;--T){const h=d+b[T]>>1;b[T]=d,d=h}for(let T=0;T<c;++T){const d=h[T];d>0&&(h[T]=d|b[d]++<<6)}}(C)}function M(h){return 63&h}function mh(h){return h>>6}function R(h,d,T,Y,y,C){const n=T.value,X=E(d,T),F=E(d,T);T.value+=4;const U=E(d,T);if(T.value+=4,X<0||X>=c||F<0||F>=c)throw new Error("Wrong HUF_ENCSIZE");const Z=new Array(c),S=new Array(O);!function(h){for(let d=0;d<O;d++)h[d]={},h[d].len=0,h[d].lit=0,h[d].p=null}(S);if(B(h,T,Y-(T.value-n),X,F,Z),U>8*(Y-(T.value-n)))throw new Error("Wrong hufUncompress");!function(h,d,T,Y){for(;d<=T;d++){const T=mh(h[d]),y=M(h[d]);if(T>>y)throw new Error("Invalid table entry");if(y>r){const h=Y[T>>y-r];if(h.len)throw new Error("Invalid table entry");if(h.lit++,h.p){const d=h.p;h.p=new Array(h.lit);for(let T=0;T<h.lit-1;++T)h.p[T]=d[T]}else h.p=new Array(1);h.p[h.lit-1]=d}else if(y){let h=0;for(let C=1<<r-y;C>0;C--){const C=Y[(T<<r-y)+h];if(C.len||C.p)throw new Error("Invalid table entry");C.len=y,C.lit=d,h++}}}}(Z,X,F,S),function(h,d,T,Y,y,C,n,X,F){let U=0,Z=0;const S=n,c=Math.trunc(Y.value+(y+7)/8);for(;Y.value<c;){let y=v(U,Z,T,Y);for(U=y.c,Z=y.lc;Z>=r;){const n=d[U>>Z-r&f];if(n.len){Z-=n.len;const h=G(n.lit,C,U,Z,T,Y,X,F,S);h&&(U=h.c,Z=h.lc)}else{if(!n.p)throw new Error("hufDecode issues");let d;for(d=0;d<n.lit;d++){const r=M(h[n.p[d]]);for(;Z<r&&Y.value<c;)y=v(U,Z,T,Y),U=y.c,Z=y.lc;if(Z>=r&&mh(h[n.p[d]])==(U>>Z-r&(1<<r)-1)){Z-=r;const h=G(n.p[d],C,U,Z,T,Y,X,F,S);h&&(U=h.c,Z=h.lc);break}}if(d==n.lit)throw new Error("HufDecode issues")}}}const O=8-y&7;for(U>>=O,Z-=O;Z>0;){const h=d[U<<r-Z&f];if(!h.len)throw new Error("HufDecode issues");{Z-=h.len;const d=G(h.lit,C,U,Z,T,Y,X,F,S);d&&(U=d.c,Z=d.lc)}}}(Z,S,h,T,U,F,C,y,{value:0})}function Q(h){return 65535&h}function I(h){const d=Q(h);return d>32767?d-65536:d}function A(h,d){const T=I(h),Y=I(d),y=T+(1&Y)+(Y>>1);return{a:y,b:y-Y}}function P(h,d){const T=Q(h),Y=Q(d),y=T-(Y>>1)&a;return{a:Y+y-j&a,b:y}}function t(h,d,T,Y,y,C,n){const X=n<16384,F=T>y?y:T;let U,Z,S=1;for(;S<=F;)S<<=1;for(S>>=1,U=S,S>>=1;S>=1;){Z=0;const n=Z+C*(y-U),F=C*S,r=C*U,c=Y*S,O=Y*U;let f,J,W,L;for(;Z<=n;Z+=r){let y=Z;const C=Z+Y*(T-U);for(;y<=C;y+=O){const T=y+c,Y=y+F,C=Y+c;if(X){let n=A(h[y+d],h[Y+d]);f=n.a,W=n.b,n=A(h[T+d],h[C+d]),J=n.a,L=n.b,n=A(f,J),h[y+d]=n.a,h[T+d]=n.b,n=A(W,L),h[Y+d]=n.a,h[C+d]=n.b}else{let n=P(h[y+d],h[Y+d]);f=n.a,W=n.b,n=P(h[T+d],h[C+d]),J=n.a,L=n.b,n=P(f,J),h[y+d]=n.a,h[T+d]=n.b,n=P(W,L),h[Y+d]=n.a,h[C+d]=n.b}}if(T&S){const T=y+F;let Y;Y=X?A(h[y+d],h[T+d]):P(h[y+d],h[T+d]),f=Y.a,h[T+d]=Y.b,h[y+d]=f}}if(y&S){let y=Z;const C=Z+Y*(T-U);for(;y<=C;y+=O){const T=y+c;let Y;Y=X?A(h[y+d],h[T+d]):P(h[y+d],h[T+d]),f=Y.a,h[T+d]=Y.b,h[y+d]=f}}U=S,S>>=1}return Z}function hh(h){return new DataView(h.array.buffer,h.offset.value,h.size)}function dh(h){const d=h.viewer.buffer.slice(h.offset.value,h.offset.value+h.size),T=new Uint8Array(function(h){let d=h.byteLength;const T=[];let Y=0;const y=new DataView(h);for(;d>0;){const h=y.getInt8(Y++);if(h<0){const C=-h;d-=C+1;for(let h=0;h<C;h++)T.push(y.getUint8(Y++))}else{const C=h;d-=2;const n=y.getUint8(Y++);for(let h=0;h<C+1;h++)T.push(n)}}return T}(d)),Y=new Uint8Array(T.length);return N(T),K(T,Y),new DataView(Y.buffer)}function Th(h){const d=h.array.slice(h.offset.value,h.offset.value+h.size),T=fflate.unzlibSync(d),Y=new Uint8Array(T.length);return N(T),K(T,Y),new DataView(Y.buffer)}function Yh(h){const d=h.array.slice(h.offset.value,h.offset.value+h.size),T=fflate.unzlibSync(d),Y=h.lines*h.channels*h.width,y=1==h.type?new Uint16Array(Y):new Uint32Array(Y);let C=0,n=0;const X=new Array(4);for(let F=0;F<h.lines;F++)for(let d=0;d<h.channels;d++){let d=0;switch(h.type){case 1:X[0]=C,X[1]=X[0]+h.width,C=X[1]+h.width;for(let Y=0;Y<h.width;++Y){d+=T[X[0]++]<<8|T[X[1]++],y[n]=d,n++}break;case 2:X[0]=C,X[1]=X[0]+h.width,X[2]=X[1]+h.width,C=X[2]+h.width;for(let Y=0;Y<h.width;++Y){d+=T[X[0]++]<<24|T[X[1]++]<<16|T[X[2]++]<<8,y[n]=d,n++}}}return new DataView(y.buffer)}function yh(h){const d=h.viewer,T={value:h.offset.value},Y=new Uint16Array(h.width*h.scanlineBlockSize*(h.channels*h.type)),y=new Uint8Array(S);let C=0;const n=new Array(h.channels);for(let F=0;F<h.channels;F++)n[F]={},n[F].start=C,n[F].end=n[F].start,n[F].nx=h.width,n[F].ny=h.lines,n[F].size=h.type,C+=n[F].nx*n[F].ny*n[F].size;const X=x(d,T),U=x(d,T);if(U>=S)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(X<=U)for(let F=0;F<U-X+1;F++)y[F+X]=z(d,T);const r=new Uint16Array(Z),c=function(h,d){let T=0;for(let y=0;y<Z;++y)(0==y||h[y>>3]&1<<(7&y))&&(d[T++]=y);const Y=T-1;for(;T<Z;)d[T++]=0;return Y}(y,r),O=E(d,T);R(h.array,d,T,O,Y,C);for(let F=0;F<h.channels;++F){const h=n[F];for(let d=0;d<n[F].size;++d)t(Y,h.start+d,h.nx,h.size,h.ny,h.nx*h.size,c)}!function(h,d,T){for(let Y=0;Y<T;++Y)d[Y]=h[d[Y]]}(r,Y,C);let f=0;const J=new Uint8Array(Y.buffer.byteLength);for(let Z=0;Z<h.lines;Z++)for(let d=0;d<h.channels;d++){const h=n[d],T=h.nx*h.size,y=new Uint8Array(Y.buffer,h.end*F,T*F);J.set(y,f),f+=T*F,h.end+=T}return new DataView(J.buffer)}var Ch,nh=T(12574);!function(h){h[h.Float=0]="Float",h[h.HalfFloat=1]="HalfFloat"}(Ch||(Ch={}));class Xh{}async function Fh(h,d,T,Y){const y={size:0,viewer:d,array:new Uint8Array(d.buffer),offset:T,width:h.dataWindow.xMax-h.dataWindow.xMin+1,height:h.dataWindow.yMax-h.dataWindow.yMin+1,channels:h.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(h.compression){case D.NO_COMPRESSION:y.lines=1,y.uncompress=hh;break;case D.RLE_COMPRESSION:y.lines=1,y.uncompress=dh;break;case D.ZIPS_COMPRESSION:y.lines=1,y.uncompress=Th,await nh.Tools.LoadScriptAsync(Xh.FFLATEUrl);break;case D.ZIP_COMPRESSION:y.lines=16,y.uncompress=Th,await nh.Tools.LoadScriptAsync(Xh.FFLATEUrl);break;case D.PIZ_COMPRESSION:y.lines=32,y.uncompress=yh;break;case D.PXR24_COMPRESSION:y.lines=16,y.uncompress=Yh,await nh.Tools.LoadScriptAsync(Xh.FFLATEUrl);break;default:throw new Error(D[h.compression]+" is unsupported")}y.scanlineBlockSize=y.lines;const C={};for(const n of h.channels)switch(n.name){case"R":case"G":case"B":case"A":case"Y":C[n.name]=!0,y.type=n.pixelType}let X=!1;if(C.R&&C.G&&C.B&&C.A)y.outputChannels=4,y.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G&&C.B)X=!0,y.outputChannels=4,y.decodeChannels={R:0,G:1,B:2,A:3};else if(C.R&&C.G)y.outputChannels=2,y.decodeChannels={R:0,G:1};else if(C.R)y.outputChannels=1,y.decodeChannels={R:0};else{if(!C.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");y.outputChannels=1,y.decodeChannels={Y:0}}if(1===y.type)switch(Y){case Ch.Float:y.getter=k,y.inputSize=F;break;case Ch.HalfFloat:y.getter=x,y.inputSize=F}else{if(2!==y.type)throw new Error("Unsupported pixelType "+y.type+" for "+h.compression);switch(Y){case Ch.Float:y.getter=p,y.inputSize=n;break;case Ch.HalfFloat:y.getter=o,y.inputSize=n}}y.blockCount=y.height/y.scanlineBlockSize;for(let n=0;n<y.blockCount;n++)H(d,T);const U=y.width*y.height*y.outputChannels;switch(Y){case Ch.Float:y.byteArray=new Float32Array(U),y.textureType=1,X&&y.byteArray.fill(1,0,U);break;case Ch.HalfFloat:y.byteArray=new Uint16Array(U),y.textureType=2,X&&y.byteArray.fill(15360,0,U);break;default:throw new Error("Unsupported type: "+Y)}let Z=0;for(const n of h.channels)void 0!==y.decodeChannels[n.name]&&(y.channelLineOffsets[n.name]=Z*y.width),Z+=2*n.pixelType;return y.bytesPerLine=y.width*Z,y.outLineWidth=y.width*y.outputChannels,"INCREASING_Y"===h.lineOrder?y.scanOrder=h=>h:y.scanOrder=h=>y.height-1-h,4==y.outputChannels?(y.format=5,y.linearSpace=!0):(y.format=6,y.linearSpace=!1),y}function Uh(h,d,T,Y){const y={value:0};for(let C=0;C<h.height/h.scanlineBlockSize;C++){const n=s(T,Y)-d.dataWindow.yMin;h.size=E(T,Y),h.lines=n+h.scanlineBlockSize>h.height?h.height-n:h.scanlineBlockSize;const X=h.size<h.lines*h.bytesPerLine&&h.uncompress?h.uncompress(h):hh(h);Y.value+=h.size;for(let T=0;T<h.scanlineBlockSize;T++){const Y=C*h.scanlineBlockSize,n=T+h.scanOrder(Y);if(n>=h.height)continue;const F=T*h.bytesPerLine,U=(h.height-1-n)*h.outLineWidth;for(let T=0;T<h.channels;T++){const Y=d.channels[T].name,C=h.channelLineOffsets[Y],n=h.decodeChannels[Y];if(void 0!==n){y.value=F+C;for(let d=0;d<h.width;d++){const T=U+d*h.outputChannels+n;h.byteArray&&(h.byteArray[T]=h.getter(X,y))}}}}}}Xh.DefaultOutputType=Ch.HalfFloat,Xh.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Zh{constructor(){this.supportCascades=!1}loadCubeData(h,d,T,Y,y){throw".exr not supported in Cube."}loadData(h,d,T){const y=new DataView(h.buffer),C={value:0},n=q(y,C);Fh(n,y,C,Xh.DefaultOutputType).then((h=>{Uh(h,n,y,C);const Y=n.dataWindow.xMax-n.dataWindow.xMin+1,X=n.dataWindow.yMax-n.dataWindow.yMin+1;T(Y,X,d.generateMipMaps,!1,(()=>{const T=d.getEngine();d.format=n.format,d.type=h.textureType,d.invertY=!1,d._gammaSpace=!n.linearSpace,h.byteArray&&T._uploadDataToTextureDirectly(d,h.byteArray,0,0,void 0,!0)}))})).catch((h=>{Y.c.Error("Failed to load EXR texture: ",h)}))}}async function Sh(h){const d=new DataView(h),T={value:0},y=q(d,T);try{const h=await Fh(y,d,T,Ch.Float);return Uh(h,y,d,T),h.byteArray?{width:y.dataWindow.xMax-y.dataWindow.xMin+1,height:y.dataWindow.yMax-y.dataWindow.yMin+1,data:new Float32Array(h.byteArray)}:(Y.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(C){Y.c.Error("Failed to load EXR data: ",C)}return{width:0,height:0,data:null}}},12787:(h,d,T)=>{function Y(h){return parseInt(h.toString().replace(/\W/g,""))}function y(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(h-d)<=T}function C(h,d,T){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return h<d-Y||h>T+Y}function n(h,d){return h===d?h:Math.random()*(d-h)+h}function X(h,d,T){return h+(d-h)*T}function F(h,d,T){let Y=J(d-h,360);return Y>180&&(Y-=360),h+Y*r(T)}function U(h,d,T){let Y=0;return Y=h!=d?r((T-h)/(d-h)):0,Y}function Z(h,d,T,Y,y){const C=y*y,n=y*C;return h*(2*n-3*C+1)+T*(-2*n+3*C)+d*(n-2*C+y)+Y*(n-C)}function S(h,d,T,Y,y){const C=y*y;return 6*(C-y)*h+(3*C-4*y+1)*d+6*(-C+y)*T+(3*C-2*y)*Y}function r(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(T,Math.max(d,h))}function c(h){return h-=2*Math.PI*Math.floor((h+Math.PI)/(2*Math.PI))}function O(h){const d=h.toString(16);return h<=15?("0"+d).toUpperCase():d.toUpperCase()}function f(h){if(Math.log2)return Math.floor(Math.log2(h));if(h<0)return NaN;if(0===h)return-1/0;let d=0;if(h<1){for(;h<1;)d++,h*=2;d=-d}else if(h>1)for(;h>1;)d++,h=Math.floor(h/2);return d}function J(h,d){return h-Math.floor(h/d)*d}function W(h,d,T){return(h-d)/(T-d)}function L(h,d,T){return h*(T-d)+d}function D(h,d){let T=J(d-h,360);return T>180&&(T-=360),T}function V(h,d){const T=J(h,2*d);return d-Math.abs(T-d)}function i(h,d,T){let Y=r(T);return Y=-2*Y*Y*Y+3*Y*Y,d*Y+h*(1-Y)}function w(h,d,T){let Y=0;return Y=Math.abs(d-h)<=T?d:h+Math.sign(d-h)*T,Y}function s(h,d,T){const Y=D(h,d);let y=0;return y=-T<Y&&Y<T?d:w(h,d=h+Y,T),y}function E(h,d,T){return(h-d)/(T-d)}function z(h,d,T){return(T-d)*h+d}function x(h,d){const T=h%d;return 0===T?d:x(d,T)}T.r(d),T.d(d,{Clamp:()=>r,DeltaAngle:()=>D,Denormalize:()=>L,ExtractAsInt:()=>Y,Hermite:()=>Z,Hermite1stDerivative:()=>S,HighestCommonFactor:()=>x,ILog2:()=>f,InverseLerp:()=>U,Lerp:()=>X,LerpAngle:()=>F,MoveTowards:()=>w,MoveTowardsAngle:()=>s,Normalize:()=>W,NormalizeRadians:()=>c,OutsideRange:()=>C,PercentToRange:()=>z,PingPong:()=>V,RandomRange:()=>n,RangeToPercent:()=>E,Repeat:()=>J,SmoothStep:()=>i,ToHex:()=>O,WithinEpsilon:()=>y})}}]);