"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[16],{15434:(Y,c,h)=>{h.r(c),h.d(c,{ReadExrDataAsync:()=>qY,_ExrTextureLoader:()=>WY});var C=h(12700),E=h(12883);const N=4,Q=4,b=1,H=2,w=8,W=65536,q=W>>3,k=14,M=65537,p=1<<k,P=p-1,y=59,d=63,D=2+d-y;var T,e;!function(Y){Y[Y.NO_COMPRESSION=0]="NO_COMPRESSION",Y[Y.RLE_COMPRESSION=1]="RLE_COMPRESSION",Y[Y.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Y[Y.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Y[Y.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Y[Y.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(Y){Y[Y.INCREASING_Y=0]="INCREASING_Y",Y[Y.DECREASING_Y=1]="DECREASING_Y"}(e||(e={}));const r=function(){const Y=new ArrayBuffer(4),c=new Float32Array(Y),h=new Uint32Array(Y),C=new Uint32Array(512),E=new Uint32Array(512);for(let H=0;H<256;++H){const Y=H-127;Y<-27?(C[H]=0,C[256|H]=32768,E[H]=24,E[256|H]=24):Y<-14?(C[H]=1024>>-Y-14,C[256|H]=1024>>-Y-14|32768,E[H]=-Y-1,E[256|H]=-Y-1):Y<=15?(C[H]=Y+15<<10,C[256|H]=Y+15<<10|32768,E[H]=13,E[256|H]=13):Y<128?(C[H]=31744,C[256|H]=64512,E[H]=24,E[256|H]=24):(C[H]=31744,C[256|H]=64512,E[H]=13,E[256|H]=13)}const N=new Uint32Array(2048),Q=new Uint32Array(64),b=new Uint32Array(64);for(let H=1;H<1024;++H){let Y=H<<13,c=0;for(;0===(8388608&Y);)Y<<=1,c-=8388608;Y&=-8388609,c+=947912704,N[H]=Y|c}for(let H=1024;H<2048;++H)N[H]=939524096+(H-1024<<13);for(let H=1;H<31;++H)Q[H]=H<<23;Q[31]=1199570944,Q[32]=2147483648;for(let H=33;H<63;++H)Q[H]=2147483648+(H-32<<23);Q[63]=3347054592;for(let H=1;H<64;++H)32!==H&&(b[H]=1024);return{floatView:c,uint32View:h,baseTable:C,shiftTable:E,mantissaTable:N,exponentTable:Q,offsetTable:b}}();function X(Y,c){const h=new Uint8Array(Y);let C=0;for(;0!=h[c.value+C];)C+=1;const E=(new TextDecoder).decode(h.slice(c.value,c.value+C));return c.value=c.value+C+1,E}function Z(Y,c){const h=Y.getInt32(c.value,!0);return c.value+=N,h}function a(Y,c){const h=Y.getUint32(c.value,!0);return c.value+=N,h}function G(Y,c){const h=Y.getUint8(c.value);return c.value+=b,h}function K(Y,c){const h=Y.getUint16(c.value,!0);return c.value+=H,h}function I(Y,c){const h=Y[c.value];return c.value+=b,h}function s(Y,c){let h;return h="getBigInt64"in DataView.prototype?Number(Y.getBigInt64(c.value,!0)):Y.getUint32(c.value+4,!0)+Number(Y.getUint32(c.value,!0)<<32),c.value+=w,h}function x(Y,c){const h=Y.getFloat32(c.value,!0);return c.value+=Q,h}function A(Y,c){return function(Y){const c=(31744&Y)>>10,h=1023&Y;return(Y>>15?-1:1)*(c?31===c?h?NaN:1/0:Math.pow(2,c-15)*(1+h/1024):h/1024*6103515625e-14)}(K(Y,c))}function V(Y,c){return function(Y){if(Math.abs(Y)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Y=(0,E.Clamp)(Y,-65504,65504),r.floatView[0]=Y;const c=r.uint32View[0],h=c>>23&511;return r.baseTable[h]+((8388607&c)>>r.shiftTable[h])}(x(Y,c))}function U(Y,c,h,C){switch(h){case"string":case"stringvector":case"iccProfile":return function(Y,c,h){const C=(new TextDecoder).decode(new Uint8Array(Y).slice(c.value,c.value+h));return c.value=c.value+h,C}(Y.buffer,c,C);case"chlist":return function(Y,c,h){const C=c.value,E=[];for(;c.value<C+h-1;){const h=X(Y.buffer,c),C=Z(Y,c),N=G(Y,c);c.value+=3;const Q=Z(Y,c),b=Z(Y,c);E.push({name:h,pixelType:C,pLinear:N,xSampling:Q,ySampling:b})}return c.value+=1,E}(Y,c,C);case"chromaticities":return function(Y,c){return{redX:x(Y,c),redY:x(Y,c),greenX:x(Y,c),greenY:x(Y,c),blueX:x(Y,c),blueY:x(Y,c),whiteX:x(Y,c),whiteY:x(Y,c)}}(Y,c);case"compression":return function(Y,c){return G(Y,c)}(Y,c);case"box2i":return function(Y,c){return{xMin:Z(Y,c),yMin:Z(Y,c),xMax:Z(Y,c),yMax:Z(Y,c)}}(Y,c);case"lineOrder":return function(Y,c){const h=G(Y,c);return e[h]}(Y,c);case"float":return x(Y,c);case"v2f":return function(Y,c){return[x(Y,c),x(Y,c)]}(Y,c);case"v3f":return function(Y,c){return[x(Y,c),x(Y,c),x(Y,c)]}(Y,c);case"int":return Z(Y,c);case"rational":return function(Y,c){return[Z(Y,c),a(Y,c)]}(Y,c);case"timecode":return function(Y,c){return[a(Y,c),a(Y,c)]}(Y,c);case"preview":return c.value+=C,"skipped";default:return void(c.value+=C)}}function l(Y){for(let c=1;c<Y.length;c++){const h=Y[c-1]+Y[c]-128;Y[c]=h}}function n(Y,c){let h=0,C=Math.floor((Y.length+1)/2),E=0;const N=Y.length-1;for(;!(E>N)&&(c[E++]=Y[h++],!(E>N));)c[E++]=Y[C++]}const v=20000630;function g(Y,c){if(Y.getUint32(0,!0)!=v)throw new Error("Incorrect OpenEXR format");const h=Y.getUint8(4),E=Y.getUint8(5),N={singleTile:!!(2&E),longName:!!(4&E),deepFormat:!!(8&E),multiPart:!!(16&E)};c.value=8;const Q={};let b=!0;for(;b;){const h=X(Y.buffer,c);if(h){const E=X(Y.buffer,c),N=U(Y,c,E,a(Y,c));void 0===N?C.e.Warn(`Unknown header attribute type ${E}'.`):Q[h]=N}else b=!1}if(0!=(-5&E))throw new Error("Unsupported file format");return{version:h,spec:N,...Q}}const z=32768,O=65535;function o(Y,c,h,C,E){for(;h<Y;)c=c<<8|I(C,E),h+=8;return{l:c>>(h-=Y)&(1<<Y)-1,c:c,lc:h}}function f(Y,c,h,C){return{c:Y=Y<<8|I(h,C),lc:c+=8}}function L(Y,c,h,C,E,N,Q,b,H){if(Y==c){if(C<8){const Y=f(h,C,E,N);h=Y.c,C=Y.lc}let Y=h>>(C-=8);if(Y=new Uint8Array([Y])[0],b.value+Y>H)return null;const c=Q[b.value-1];for(;Y-- >0;)Q[b.value++]=c}else{if(!(b.value<H))return null;Q[b.value++]=Y}return{c:h,lc:C}}const u=new Array(59);function i(Y,c,h,C,E,N){const Q=c;let b=0,H=0;for(;C<=E;C++){if(Q.value-c.value>h)return;let w=o(6,b,H,Y,Q);const W=w.l;if(b=w.c,H=w.lc,N[C]=W,W==d){if(Q.value-c.value>h)throw new Error("Error in HufUnpackEncTable");w=o(8,b,H,Y,Q);let W=w.l+D;if(b=w.c,H=w.lc,C+W>E+1)throw new Error("Error in HufUnpackEncTable");for(;W--;)N[C++]=0;C--}else if(W>=y){let Y=W-y+2;if(C+Y>E+1)throw new Error("Error in HufUnpackEncTable");for(;Y--;)N[C++]=0;C--}}!function(Y){for(let h=0;h<=58;++h)u[h]=0;for(let h=0;h<M;++h)u[Y[h]]+=1;let c=0;for(let h=58;h>0;--h){const Y=c+u[h]>>1;u[h]=c,c=Y}for(let h=0;h<M;++h){const c=Y[h];c>0&&(Y[h]=c|u[c]++<<6)}}(N)}function R(Y){return 63&Y}function B(Y){return Y>>6}function t(Y,c,h,C,E,N){const Q=h.value,b=a(c,h),H=a(c,h);h.value+=4;const w=a(c,h);if(h.value+=4,b<0||b>=M||H<0||H>=M)throw new Error("Wrong HUF_ENCSIZE");const W=new Array(M),q=new Array(p);!function(Y){for(let c=0;c<p;c++)Y[c]={},Y[c].len=0,Y[c].lit=0,Y[c].p=null}(q);if(i(Y,h,C-(h.value-Q),b,H,W),w>8*(C-(h.value-Q)))throw new Error("Wrong hufUncompress");!function(Y,c,h,C){for(;c<=h;c++){const h=B(Y[c]),E=R(Y[c]);if(h>>E)throw new Error("Invalid table entry");if(E>k){const Y=C[h>>E-k];if(Y.len)throw new Error("Invalid table entry");if(Y.lit++,Y.p){const c=Y.p;Y.p=new Array(Y.lit);for(let h=0;h<Y.lit-1;++h)Y.p[h]=c[h]}else Y.p=new Array(1);Y.p[Y.lit-1]=c}else if(E){let Y=0;for(let N=1<<k-E;N>0;N--){const N=C[(h<<k-E)+Y];if(N.len||N.p)throw new Error("Invalid table entry");N.len=E,N.lit=c,Y++}}}}(W,b,H,q),function(Y,c,h,C,E,N,Q,b,H){let w=0,W=0;const q=Q,M=Math.trunc(C.value+(E+7)/8);for(;C.value<M;){let E=f(w,W,h,C);for(w=E.c,W=E.lc;W>=k;){const Q=c[w>>W-k&P];if(Q.len){W-=Q.len;const Y=L(Q.lit,N,w,W,h,C,b,H,q);Y&&(w=Y.c,W=Y.lc)}else{if(!Q.p)throw new Error("hufDecode issues");let c;for(c=0;c<Q.lit;c++){const k=R(Y[Q.p[c]]);for(;W<k&&C.value<M;)E=f(w,W,h,C),w=E.c,W=E.lc;if(W>=k&&B(Y[Q.p[c]])==(w>>W-k&(1<<k)-1)){W-=k;const Y=L(Q.p[c],N,w,W,h,C,b,H,q);Y&&(w=Y.c,W=Y.lc);break}}if(c==Q.lit)throw new Error("HufDecode issues")}}}const p=8-E&7;for(w>>=p,W-=p;W>0;){const Y=c[w<<k-W&P];if(!Y.len)throw new Error("HufDecode issues");{W-=Y.len;const c=L(Y.lit,N,w,W,h,C,b,H,q);c&&(w=c.c,W=c.lc)}}}(W,q,Y,h,w,H,N,E,{value:0})}function F(Y){return 65535&Y}function J(Y){const c=F(Y);return c>32767?c-65536:c}function j(Y,c){const h=J(Y),C=J(c),E=h+(1&C)+(C>>1);return{a:E,b:E-C}}function S(Y,c){const h=F(Y),C=F(c),E=h-(C>>1)&O;return{a:C+E-z&O,b:E}}function mY(Y,c,h,C,E,N,Q){const b=Q<16384,H=h>E?E:h;let w,W,q=1;for(;q<=H;)q<<=1;for(q>>=1,w=q,q>>=1;q>=1;){W=0;const Q=W+N*(E-w),H=N*q,k=N*w,M=C*q,p=C*w;let P,y,d,D;for(;W<=Q;W+=k){let E=W;const N=W+C*(h-w);for(;E<=N;E+=p){const h=E+M,C=E+H,N=C+M;if(b){let Q=j(Y[E+c],Y[C+c]);P=Q.a,d=Q.b,Q=j(Y[h+c],Y[N+c]),y=Q.a,D=Q.b,Q=j(P,y),Y[E+c]=Q.a,Y[h+c]=Q.b,Q=j(d,D),Y[C+c]=Q.a,Y[N+c]=Q.b}else{let Q=S(Y[E+c],Y[C+c]);P=Q.a,d=Q.b,Q=S(Y[h+c],Y[N+c]),y=Q.a,D=Q.b,Q=S(P,y),Y[E+c]=Q.a,Y[h+c]=Q.b,Q=S(d,D),Y[C+c]=Q.a,Y[N+c]=Q.b}}if(h&q){const h=E+H;let C;C=b?j(Y[E+c],Y[h+c]):S(Y[E+c],Y[h+c]),P=C.a,Y[h+c]=C.b,Y[E+c]=P}}if(E&q){let E=W;const N=W+C*(h-w);for(;E<=N;E+=p){const h=E+M;let C;C=b?j(Y[E+c],Y[h+c]):S(Y[E+c],Y[h+c]),P=C.a,Y[h+c]=C.b,Y[E+c]=P}}w=q,q>>=1}return W}function YY(Y){return new DataView(Y.array.buffer,Y.offset.value,Y.size)}function cY(Y){const c=Y.viewer.buffer.slice(Y.offset.value,Y.offset.value+Y.size),h=new Uint8Array(function(Y){let c=Y.byteLength;const h=[];let C=0;const E=new DataView(Y);for(;c>0;){const Y=E.getInt8(C++);if(Y<0){const N=-Y;c-=N+1;for(let Y=0;Y<N;Y++)h.push(E.getUint8(C++))}else{const N=Y;c-=2;const Q=E.getUint8(C++);for(let Y=0;Y<N+1;Y++)h.push(Q)}}return h}(c)),C=new Uint8Array(h.length);return l(h),n(h,C),new DataView(C.buffer)}function hY(Y){const c=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),h=fflate.unzlibSync(c),C=new Uint8Array(h.length);return l(h),n(h,C),new DataView(C.buffer)}function CY(Y){const c=Y.array.slice(Y.offset.value,Y.offset.value+Y.size),h=fflate.unzlibSync(c),C=Y.lines*Y.channels*Y.width,E=1==Y.type?new Uint16Array(C):new Uint32Array(C);let N=0,Q=0;const b=new Array(4);for(let H=0;H<Y.lines;H++)for(let c=0;c<Y.channels;c++){let c=0;switch(Y.type){case 1:b[0]=N,b[1]=b[0]+Y.width,N=b[1]+Y.width;for(let C=0;C<Y.width;++C){c+=h[b[0]++]<<8|h[b[1]++],E[Q]=c,Q++}break;case 2:b[0]=N,b[1]=b[0]+Y.width,b[2]=b[1]+Y.width,N=b[2]+Y.width;for(let C=0;C<Y.width;++C){c+=h[b[0]++]<<24|h[b[1]++]<<16|h[b[2]++]<<8,E[Q]=c,Q++}}}return new DataView(E.buffer)}function EY(Y){const c=Y.viewer,h={value:Y.offset.value},C=new Uint16Array(Y.width*Y.scanlineBlockSize*(Y.channels*Y.type)),E=new Uint8Array(q);let N=0;const Q=new Array(Y.channels);for(let H=0;H<Y.channels;H++)Q[H]={},Q[H].start=N,Q[H].end=Q[H].start,Q[H].nx=Y.width,Q[H].ny=Y.lines,Q[H].size=Y.type,N+=Q[H].nx*Q[H].ny*Q[H].size;const b=K(c,h),w=K(c,h);if(w>=q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(b<=w)for(let H=0;H<w-b+1;H++)E[H+b]=G(c,h);const k=new Uint16Array(W),M=function(Y,c){let h=0;for(let E=0;E<W;++E)(0==E||Y[E>>3]&1<<(7&E))&&(c[h++]=E);const C=h-1;for(;h<W;)c[h++]=0;return C}(E,k),p=a(c,h);t(Y.array,c,h,p,C,N);for(let H=0;H<Y.channels;++H){const Y=Q[H];for(let c=0;c<Q[H].size;++c)mY(C,Y.start+c,Y.nx,Y.size,Y.ny,Y.nx*Y.size,M)}!function(Y,c,h){for(let C=0;C<h;++C)c[C]=Y[c[C]]}(k,C,N);let P=0;const y=new Uint8Array(C.buffer.byteLength);for(let W=0;W<Y.lines;W++)for(let c=0;c<Y.channels;c++){const Y=Q[c],h=Y.nx*Y.size,E=new Uint8Array(C.buffer,Y.end*H,h*H);y.set(E,P),P+=h*H,Y.end+=h}return new DataView(y.buffer)}var NY,QY=h(12687);!function(Y){Y[Y.Float=0]="Float",Y[Y.HalfFloat=1]="HalfFloat"}(NY||(NY={}));class bY{}async function HY(Y,c,h,C){const E={size:0,viewer:c,array:new Uint8Array(c.buffer),offset:h,width:Y.dataWindow.xMax-Y.dataWindow.xMin+1,height:Y.dataWindow.yMax-Y.dataWindow.yMin+1,channels:Y.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Y.compression){case T.NO_COMPRESSION:E.lines=1,E.uncompress=YY;break;case T.RLE_COMPRESSION:E.lines=1,E.uncompress=cY;break;case T.ZIPS_COMPRESSION:E.lines=1,E.uncompress=hY,await QY.Tools.LoadScriptAsync(bY.FFLATEUrl);break;case T.ZIP_COMPRESSION:E.lines=16,E.uncompress=hY,await QY.Tools.LoadScriptAsync(bY.FFLATEUrl);break;case T.PIZ_COMPRESSION:E.lines=32,E.uncompress=EY;break;case T.PXR24_COMPRESSION:E.lines=16,E.uncompress=CY,await QY.Tools.LoadScriptAsync(bY.FFLATEUrl);break;default:throw new Error(T[Y.compression]+" is unsupported")}E.scanlineBlockSize=E.lines;const N={};for(const Q of Y.channels)switch(Q.name){case"R":case"G":case"B":case"A":case"Y":N[Q.name]=!0,E.type=Q.pixelType}let b=!1;if(N.R&&N.G&&N.B&&N.A)E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G&&N.B)b=!0,E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(N.R&&N.G)E.outputChannels=2,E.decodeChannels={R:0,G:1};else if(N.R)E.outputChannels=1,E.decodeChannels={R:0};else{if(!N.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");E.outputChannels=1,E.decodeChannels={Y:0}}if(1===E.type)switch(C){case NY.Float:E.getter=A,E.inputSize=H;break;case NY.HalfFloat:E.getter=K,E.inputSize=H}else{if(2!==E.type)throw new Error("Unsupported pixelType "+E.type+" for "+Y.compression);switch(C){case NY.Float:E.getter=x,E.inputSize=Q;break;case NY.HalfFloat:E.getter=V,E.inputSize=Q}}E.blockCount=E.height/E.scanlineBlockSize;for(let Q=0;Q<E.blockCount;Q++)s(c,h);const w=E.width*E.height*E.outputChannels;switch(C){case NY.Float:E.byteArray=new Float32Array(w),E.textureType=1,b&&E.byteArray.fill(1,0,w);break;case NY.HalfFloat:E.byteArray=new Uint16Array(w),E.textureType=2,b&&E.byteArray.fill(15360,0,w);break;default:throw new Error("Unsupported type: "+C)}let W=0;for(const Q of Y.channels)void 0!==E.decodeChannels[Q.name]&&(E.channelLineOffsets[Q.name]=W*E.width),W+=2*Q.pixelType;return E.bytesPerLine=E.width*W,E.outLineWidth=E.width*E.outputChannels,"INCREASING_Y"===Y.lineOrder?E.scanOrder=Y=>Y:E.scanOrder=Y=>E.height-1-Y,4==E.outputChannels?(E.format=5,E.linearSpace=!0):(E.format=6,E.linearSpace=!1),E}function wY(Y,c,h,C){const E={value:0};for(let N=0;N<Y.height/Y.scanlineBlockSize;N++){const Q=Z(h,C)-c.dataWindow.yMin;Y.size=a(h,C),Y.lines=Q+Y.scanlineBlockSize>Y.height?Y.height-Q:Y.scanlineBlockSize;const b=Y.size<Y.lines*Y.bytesPerLine&&Y.uncompress?Y.uncompress(Y):YY(Y);C.value+=Y.size;for(let h=0;h<Y.scanlineBlockSize;h++){const C=N*Y.scanlineBlockSize,Q=h+Y.scanOrder(C);if(Q>=Y.height)continue;const H=h*Y.bytesPerLine,w=(Y.height-1-Q)*Y.outLineWidth;for(let h=0;h<Y.channels;h++){const C=c.channels[h].name,N=Y.channelLineOffsets[C],Q=Y.decodeChannels[C];if(void 0!==Q){E.value=H+N;for(let c=0;c<Y.width;c++){const h=w+c*Y.outputChannels+Q;Y.byteArray&&(Y.byteArray[h]=Y.getter(b,E))}}}}}}bY.DefaultOutputType=NY.HalfFloat,bY.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class WY{constructor(){this.supportCascades=!1}loadCubeData(Y,c,h,C,E){throw".exr not supported in Cube."}loadData(Y,c,h){const E=new DataView(Y.buffer),N={value:0},Q=g(E,N);HY(Q,E,N,bY.DefaultOutputType).then((Y=>{wY(Y,Q,E,N);const C=Q.dataWindow.xMax-Q.dataWindow.xMin+1,b=Q.dataWindow.yMax-Q.dataWindow.yMin+1;h(C,b,c.generateMipMaps,!1,(()=>{const h=c.getEngine();c.format=Q.format,c.type=Y.textureType,c.invertY=!1,c._gammaSpace=!Q.linearSpace,Y.byteArray&&h._uploadDataToTextureDirectly(c,Y.byteArray,0,0,void 0,!0)}))})).catch((Y=>{C.e.Error("Failed to load EXR texture: ",Y)}))}}async function qY(Y){const c=new DataView(Y),h={value:0},E=g(c,h);try{const Y=await HY(E,c,h,NY.Float);return wY(Y,E,c,h),Y.byteArray?{width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,data:new Float32Array(Y.byteArray)}:(C.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(N){C.e.Error("Failed to load EXR data: ",N)}return{width:0,height:0,data:null}}},12883:(Y,c,h)=>{function C(Y){return parseInt(Y.toString().replace(/\W/g,""))}function E(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Y-c)<=h}function N(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Y<c-C||Y>h+C}function Q(Y,c){return Y===c?Y:Math.random()*(c-Y)+Y}function b(Y,c,h){return Y+(c-Y)*h}function H(Y,c,h){let C=y(c-Y,360);return C>180&&(C-=360),Y+C*k(h)}function w(Y,c,h){let C=0;return C=Y!=c?k((h-Y)/(c-Y)):0,C}function W(Y,c,h,C,E){const N=E*E,Q=E*N;return Y*(2*Q-3*N+1)+h*(-2*Q+3*N)+c*(Q-2*N+E)+C*(Q-N)}function q(Y,c,h,C,E){const N=E*E;return 6*(N-E)*Y+(3*N-4*E+1)*c+6*(-N+E)*h+(3*N-2*E)*C}function k(Y){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(h,Math.max(c,Y))}function M(Y){return Y-=2*Math.PI*Math.floor((Y+Math.PI)/(2*Math.PI))}function p(Y){const c=Y.toString(16);return Y<=15?("0"+c).toUpperCase():c.toUpperCase()}function P(Y){if(Math.log2)return Math.floor(Math.log2(Y));if(Y<0)return NaN;if(0===Y)return-1/0;let c=0;if(Y<1){for(;Y<1;)c++,Y*=2;c=-c}else if(Y>1)for(;Y>1;)c++,Y=Math.floor(Y/2);return c}function y(Y,c){return Y-Math.floor(Y/c)*c}function d(Y,c,h){return(Y-c)/(h-c)}function D(Y,c,h){return Y*(h-c)+c}function T(Y,c){let h=y(c-Y,360);return h>180&&(h-=360),h}function e(Y,c){const h=y(Y,2*c);return c-Math.abs(h-c)}function r(Y,c,h){let C=k(h);return C=-2*C*C*C+3*C*C,c*C+Y*(1-C)}function X(Y,c,h){let C=0;return C=Math.abs(c-Y)<=h?c:Y+Math.sign(c-Y)*h,C}function Z(Y,c,h){const C=T(Y,c);let E=0;return E=-h<C&&C<h?c:X(Y,c=Y+C,h),E}function a(Y,c,h){return(Y-c)/(h-c)}function G(Y,c,h){return(h-c)*Y+c}function K(Y,c){const h=Y%c;return 0===h?c:K(c,h)}h.r(c),h.d(c,{Clamp:()=>k,DeltaAngle:()=>T,Denormalize:()=>D,ExtractAsInt:()=>C,Hermite:()=>W,Hermite1stDerivative:()=>q,HighestCommonFactor:()=>K,ILog2:()=>P,InverseLerp:()=>w,Lerp:()=>b,LerpAngle:()=>H,MoveTowards:()=>X,MoveTowardsAngle:()=>Z,Normalize:()=>d,NormalizeRadians:()=>M,OutsideRange:()=>N,PercentToRange:()=>G,PingPong:()=>e,RandomRange:()=>Q,RangeToPercent:()=>a,Repeat:()=>y,SmoothStep:()=>r,ToHex:()=>p,WithinEpsilon:()=>E})}}]);