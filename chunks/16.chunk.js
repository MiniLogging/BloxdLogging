"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{13669:(B,I,C)=>{C.r(I),C.d(I,{ReadExrDataAsync:()=>RB,_ExrTextureLoader:()=>NB});var M=C(11027),x=C(11212);const y=4,f=4,L=1,e=2,g=8,N=65536,R=N>>3,H=14,F=65537,k=1<<H,q=k-1,S=59,o=63,U=2+o-S;var G,V;!function(B){B[B.NO_COMPRESSION=0]="NO_COMPRESSION",B[B.RLE_COMPRESSION=1]="RLE_COMPRESSION",B[B.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",B[B.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",B[B.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",B[B.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(G||(G={})),function(B){B[B.INCREASING_Y=0]="INCREASING_Y",B[B.DECREASING_Y=1]="DECREASING_Y"}(V||(V={}));const c=function(){const B=new ArrayBuffer(4),I=new Float32Array(B),C=new Uint32Array(B),M=new Uint32Array(512),x=new Uint32Array(512);for(let e=0;e<256;++e){const B=e-127;B<-27?(M[e]=0,M[256|e]=32768,x[e]=24,x[256|e]=24):B<-14?(M[e]=1024>>-B-14,M[256|e]=1024>>-B-14|32768,x[e]=-B-1,x[256|e]=-B-1):B<=15?(M[e]=B+15<<10,M[256|e]=B+15<<10|32768,x[e]=13,x[256|e]=13):B<128?(M[e]=31744,M[256|e]=64512,x[e]=24,x[256|e]=24):(M[e]=31744,M[256|e]=64512,x[e]=13,x[256|e]=13)}const y=new Uint32Array(2048),f=new Uint32Array(64),L=new Uint32Array(64);for(let e=1;e<1024;++e){let B=e<<13,I=0;for(;0===(8388608&B);)B<<=1,I-=8388608;B&=-8388609,I+=947912704,y[e]=B|I}for(let e=1024;e<2048;++e)y[e]=939524096+(e-1024<<13);for(let e=1;e<31;++e)f[e]=e<<23;f[31]=1199570944,f[32]=2147483648;for(let e=33;e<63;++e)f[e]=2147483648+(e-32<<23);f[63]=3347054592;for(let e=1;e<64;++e)32!==e&&(L[e]=1024);return{floatView:I,uint32View:C,baseTable:M,shiftTable:x,mantissaTable:y,exponentTable:f,offsetTable:L}}();function t(B,I){const C=new Uint8Array(B);let M=0;for(;0!=C[I.value+M];)M+=1;const x=(new TextDecoder).decode(C.slice(I.value,I.value+M));return I.value=I.value+M+1,x}function r(B,I){const C=B.getInt32(I.value,!0);return I.value+=y,C}function A(B,I){const C=B.getUint32(I.value,!0);return I.value+=y,C}function D(B,I){const C=B.getUint8(I.value);return I.value+=L,C}function J(B,I){const C=B.getUint16(I.value,!0);return I.value+=e,C}function i(B,I){const C=B[I.value];return I.value+=L,C}function u(B,I){let C;return C="getBigInt64"in DataView.prototype?Number(B.getBigInt64(I.value,!0)):B.getUint32(I.value+4,!0)+Number(B.getUint32(I.value,!0)<<32),I.value+=g,C}function p(B,I){const C=B.getFloat32(I.value,!0);return I.value+=f,C}function n(B,I){return function(B){const I=(31744&B)>>10,C=1023&B;return(B>>15?-1:1)*(I?31===I?C?NaN:1/0:Math.pow(2,I-15)*(1+C/1024):C/1024*6103515625e-14)}(J(B,I))}function O(B,I){return function(B){if(Math.abs(B)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");B=(0,x.Clamp)(B,-65504,65504),c.floatView[0]=B;const I=c.uint32View[0],C=I>>23&511;return c.baseTable[C]+((8388607&I)>>c.shiftTable[C])}(p(B,I))}function a(B,I,C,M){switch(C){case"string":case"stringvector":case"iccProfile":return function(B,I,C){const M=(new TextDecoder).decode(new Uint8Array(B).slice(I.value,I.value+C));return I.value=I.value+C,M}(B.buffer,I,M);case"chlist":return function(B,I,C){const M=I.value,x=[];for(;I.value<M+C-1;){const C=t(B.buffer,I),M=r(B,I),y=D(B,I);I.value+=3;const f=r(B,I),L=r(B,I);x.push({name:C,pixelType:M,pLinear:y,xSampling:f,ySampling:L})}return I.value+=1,x}(B,I,M);case"chromaticities":return function(B,I){return{redX:p(B,I),redY:p(B,I),greenX:p(B,I),greenY:p(B,I),blueX:p(B,I),blueY:p(B,I),whiteX:p(B,I),whiteY:p(B,I)}}(B,I);case"compression":return function(B,I){return D(B,I)}(B,I);case"box2i":return function(B,I){return{xMin:r(B,I),yMin:r(B,I),xMax:r(B,I),yMax:r(B,I)}}(B,I);case"lineOrder":return function(B,I){const C=D(B,I);return V[C]}(B,I);case"float":return p(B,I);case"v2f":return function(B,I){return[p(B,I),p(B,I)]}(B,I);case"v3f":return function(B,I){return[p(B,I),p(B,I),p(B,I)]}(B,I);case"int":return r(B,I);case"rational":return function(B,I){return[r(B,I),A(B,I)]}(B,I);case"timecode":return function(B,I){return[A(B,I),A(B,I)]}(B,I);case"preview":return I.value+=M,"skipped";default:return void(I.value+=M)}}function W(B){for(let I=1;I<B.length;I++){const C=B[I-1]+B[I]-128;B[I]=C}}function d(B,I){let C=0,M=Math.floor((B.length+1)/2),x=0;const y=B.length-1;for(;!(x>y)&&(I[x++]=B[C++],!(x>y));)I[x++]=B[M++]}const l=20000630;function E(B,I){if(B.getUint32(0,!0)!=l)throw new Error("Incorrect OpenEXR format");const C=B.getUint8(4),x=B.getUint8(5),y={singleTile:!!(2&x),longName:!!(4&x),deepFormat:!!(8&x),multiPart:!!(16&x)};I.value=8;const f={};let L=!0;for(;L;){const C=t(B.buffer,I);if(C){const x=t(B.buffer,I),y=a(B,I,x,A(B,I));void 0===y?M.b.Warn(`Unknown header attribute type ${x}'.`):f[C]=y}else L=!1}if(0!=(-5&x))throw new Error("Unsupported file format");return{version:C,spec:y,...f}}const Q=32768,Z=65535;function z(B,I,C,M,x){for(;C<B;)I=I<<8|i(M,x),C+=8;return{l:I>>(C-=B)&(1<<B)-1,c:I,lc:C}}function b(B,I,C,M){return{c:B=B<<8|i(C,M),lc:I+=8}}function Y(B,I,C,M,x,y,f,L,e){if(B==I){if(M<8){const B=b(C,M,x,y);C=B.c,M=B.lc}let B=C>>(M-=8);if(B=new Uint8Array([B])[0],L.value+B>e)return null;const I=f[L.value-1];for(;B-- >0;)f[L.value++]=I}else{if(!(L.value<e))return null;f[L.value++]=B}return{c:C,lc:M}}const v=new Array(59);function s(B,I,C,M,x,y){const f=I;let L=0,e=0;for(;M<=x;M++){if(f.value-I.value>C)return;let g=z(6,L,e,B,f);const N=g.l;if(L=g.c,e=g.lc,y[M]=N,N==o){if(f.value-I.value>C)throw new Error("Error in HufUnpackEncTable");g=z(8,L,e,B,f);let N=g.l+U;if(L=g.c,e=g.lc,M+N>x+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)y[M++]=0;M--}else if(N>=S){let B=N-S+2;if(M+B>x+1)throw new Error("Error in HufUnpackEncTable");for(;B--;)y[M++]=0;M--}}!function(B){for(let C=0;C<=58;++C)v[C]=0;for(let C=0;C<F;++C)v[B[C]]+=1;let I=0;for(let C=58;C>0;--C){const B=I+v[C]>>1;v[C]=I,I=B}for(let C=0;C<F;++C){const I=B[C];I>0&&(B[C]=I|v[I]++<<6)}}(y)}function X(B){return 63&B}function T(B){return B>>6}function P(B,I,C,M,x,y){const f=C.value,L=A(I,C),e=A(I,C);C.value+=4;const g=A(I,C);if(C.value+=4,L<0||L>=F||e<0||e>=F)throw new Error("Wrong HUF_ENCSIZE");const N=new Array(F),R=new Array(k);!function(B){for(let I=0;I<k;I++)B[I]={},B[I].len=0,B[I].lit=0,B[I].p=null}(R);if(s(B,C,M-(C.value-f),L,e,N),g>8*(M-(C.value-f)))throw new Error("Wrong hufUncompress");!function(B,I,C,M){for(;I<=C;I++){const C=T(B[I]),x=X(B[I]);if(C>>x)throw new Error("Invalid table entry");if(x>H){const B=M[C>>x-H];if(B.len)throw new Error("Invalid table entry");if(B.lit++,B.p){const I=B.p;B.p=new Array(B.lit);for(let C=0;C<B.lit-1;++C)B.p[C]=I[C]}else B.p=new Array(1);B.p[B.lit-1]=I}else if(x){let B=0;for(let y=1<<H-x;y>0;y--){const y=M[(C<<H-x)+B];if(y.len||y.p)throw new Error("Invalid table entry");y.len=x,y.lit=I,B++}}}}(N,L,e,R),function(B,I,C,M,x,y,f,L,e){let g=0,N=0;const R=f,F=Math.trunc(M.value+(x+7)/8);for(;M.value<F;){let x=b(g,N,C,M);for(g=x.c,N=x.lc;N>=H;){const f=I[g>>N-H&q];if(f.len){N-=f.len;const B=Y(f.lit,y,g,N,C,M,L,e,R);B&&(g=B.c,N=B.lc)}else{if(!f.p)throw new Error("hufDecode issues");let I;for(I=0;I<f.lit;I++){const H=X(B[f.p[I]]);for(;N<H&&M.value<F;)x=b(g,N,C,M),g=x.c,N=x.lc;if(N>=H&&T(B[f.p[I]])==(g>>N-H&(1<<H)-1)){N-=H;const B=Y(f.p[I],y,g,N,C,M,L,e,R);B&&(g=B.c,N=B.lc);break}}if(I==f.lit)throw new Error("HufDecode issues")}}}const k=8-x&7;for(g>>=k,N-=k;N>0;){const B=I[g<<H-N&q];if(!B.len)throw new Error("HufDecode issues");{N-=B.len;const I=Y(B.lit,y,g,N,C,M,L,e,R);I&&(g=I.c,N=I.lc)}}}(N,R,B,C,g,e,y,x,{value:0})}function h(B){return 65535&B}function j(B){const I=h(B);return I>32767?I-65536:I}function w(B,I){const C=j(B),M=j(I),x=C+(1&M)+(M>>1);return{a:x,b:x-M}}function K(B,I){const C=h(B),M=h(I),x=C-(M>>1)&Z;return{a:M+x-Q&Z,b:x}}function m(B,I,C,M,x,y,f){const L=f<16384,e=C>x?x:C;let g,N,R=1;for(;R<=e;)R<<=1;for(R>>=1,g=R,R>>=1;R>=1;){N=0;const f=N+y*(x-g),e=y*R,H=y*g,F=M*R,k=M*g;let q,S,o,U;for(;N<=f;N+=H){let x=N;const y=N+M*(C-g);for(;x<=y;x+=k){const C=x+F,M=x+e,y=M+F;if(L){let f=w(B[x+I],B[M+I]);q=f.a,o=f.b,f=w(B[C+I],B[y+I]),S=f.a,U=f.b,f=w(q,S),B[x+I]=f.a,B[C+I]=f.b,f=w(o,U),B[M+I]=f.a,B[y+I]=f.b}else{let f=K(B[x+I],B[M+I]);q=f.a,o=f.b,f=K(B[C+I],B[y+I]),S=f.a,U=f.b,f=K(q,S),B[x+I]=f.a,B[C+I]=f.b,f=K(o,U),B[M+I]=f.a,B[y+I]=f.b}}if(C&R){const C=x+e;let M;M=L?w(B[x+I],B[C+I]):K(B[x+I],B[C+I]),q=M.a,B[C+I]=M.b,B[x+I]=q}}if(x&R){let x=N;const y=N+M*(C-g);for(;x<=y;x+=k){const C=x+F;let M;M=L?w(B[x+I],B[C+I]):K(B[x+I],B[C+I]),q=M.a,B[C+I]=M.b,B[x+I]=q}}g=R,R>>=1}return N}function BB(B){return new DataView(B.array.buffer,B.offset.value,B.size)}function IB(B){const I=B.viewer.buffer.slice(B.offset.value,B.offset.value+B.size),C=new Uint8Array(function(B){let I=B.byteLength;const C=[];let M=0;const x=new DataView(B);for(;I>0;){const B=x.getInt8(M++);if(B<0){const y=-B;I-=y+1;for(let B=0;B<y;B++)C.push(x.getUint8(M++))}else{const y=B;I-=2;const f=x.getUint8(M++);for(let B=0;B<y+1;B++)C.push(f)}}return C}(I)),M=new Uint8Array(C.length);return W(C),d(C,M),new DataView(M.buffer)}function CB(B){const I=B.array.slice(B.offset.value,B.offset.value+B.size),C=fflate.unzlibSync(I),M=new Uint8Array(C.length);return W(C),d(C,M),new DataView(M.buffer)}function MB(B){const I=B.array.slice(B.offset.value,B.offset.value+B.size),C=fflate.unzlibSync(I),M=B.lines*B.channels*B.width,x=1==B.type?new Uint16Array(M):new Uint32Array(M);let y=0,f=0;const L=new Array(4);for(let e=0;e<B.lines;e++)for(let I=0;I<B.channels;I++){let I=0;switch(B.type){case 1:L[0]=y,L[1]=L[0]+B.width,y=L[1]+B.width;for(let M=0;M<B.width;++M){I+=C[L[0]++]<<8|C[L[1]++],x[f]=I,f++}break;case 2:L[0]=y,L[1]=L[0]+B.width,L[2]=L[1]+B.width,y=L[2]+B.width;for(let M=0;M<B.width;++M){I+=C[L[0]++]<<24|C[L[1]++]<<16|C[L[2]++]<<8,x[f]=I,f++}}}return new DataView(x.buffer)}function xB(B){const I=B.viewer,C={value:B.offset.value},M=new Uint16Array(B.width*B.scanlineBlockSize*(B.channels*B.type)),x=new Uint8Array(R);let y=0;const f=new Array(B.channels);for(let e=0;e<B.channels;e++)f[e]={},f[e].start=y,f[e].end=f[e].start,f[e].nx=B.width,f[e].ny=B.lines,f[e].size=B.type,y+=f[e].nx*f[e].ny*f[e].size;const L=J(I,C),g=J(I,C);if(g>=R)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(L<=g)for(let e=0;e<g-L+1;e++)x[e+L]=D(I,C);const H=new Uint16Array(N),F=function(B,I){let C=0;for(let x=0;x<N;++x)(0==x||B[x>>3]&1<<(7&x))&&(I[C++]=x);const M=C-1;for(;C<N;)I[C++]=0;return M}(x,H),k=A(I,C);P(B.array,I,C,k,M,y);for(let e=0;e<B.channels;++e){const B=f[e];for(let I=0;I<f[e].size;++I)m(M,B.start+I,B.nx,B.size,B.ny,B.nx*B.size,F)}!function(B,I,C){for(let M=0;M<C;++M)I[M]=B[I[M]]}(H,M,y);let q=0;const S=new Uint8Array(M.buffer.byteLength);for(let N=0;N<B.lines;N++)for(let I=0;I<B.channels;I++){const B=f[I],C=B.nx*B.size,x=new Uint8Array(M.buffer,B.end*e,C*e);S.set(x,q),q+=C*e,B.end+=C}return new DataView(S.buffer)}var yB,fB=C(11018);!function(B){B[B.Float=0]="Float",B[B.HalfFloat=1]="HalfFloat"}(yB||(yB={}));class LB{}async function eB(B,I,C,M){const x={size:0,viewer:I,array:new Uint8Array(I.buffer),offset:C,width:B.dataWindow.xMax-B.dataWindow.xMin+1,height:B.dataWindow.yMax-B.dataWindow.yMin+1,channels:B.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(B.compression){case G.NO_COMPRESSION:x.lines=1,x.uncompress=BB;break;case G.RLE_COMPRESSION:x.lines=1,x.uncompress=IB;break;case G.ZIPS_COMPRESSION:x.lines=1,x.uncompress=CB,await fB.Tools.LoadScriptAsync(LB.FFLATEUrl);break;case G.ZIP_COMPRESSION:x.lines=16,x.uncompress=CB,await fB.Tools.LoadScriptAsync(LB.FFLATEUrl);break;case G.PIZ_COMPRESSION:x.lines=32,x.uncompress=xB;break;case G.PXR24_COMPRESSION:x.lines=16,x.uncompress=MB,await fB.Tools.LoadScriptAsync(LB.FFLATEUrl);break;default:throw new Error(G[B.compression]+" is unsupported")}x.scanlineBlockSize=x.lines;const y={};for(const f of B.channels)switch(f.name){case"R":case"G":case"B":case"A":case"Y":y[f.name]=!0,x.type=f.pixelType}let L=!1;if(y.R&&y.G&&y.B&&y.A)x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else if(y.R&&y.G&&y.B)L=!0,x.outputChannels=4,x.decodeChannels={R:0,G:1,B:2,A:3};else if(y.R&&y.G)x.outputChannels=2,x.decodeChannels={R:0,G:1};else if(y.R)x.outputChannels=1,x.decodeChannels={R:0};else{if(!y.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");x.outputChannels=1,x.decodeChannels={Y:0}}if(1===x.type)switch(M){case yB.Float:x.getter=n,x.inputSize=e;break;case yB.HalfFloat:x.getter=J,x.inputSize=e}else{if(2!==x.type)throw new Error("Unsupported pixelType "+x.type+" for "+B.compression);switch(M){case yB.Float:x.getter=p,x.inputSize=f;break;case yB.HalfFloat:x.getter=O,x.inputSize=f}}x.blockCount=x.height/x.scanlineBlockSize;for(let f=0;f<x.blockCount;f++)u(I,C);const g=x.width*x.height*x.outputChannels;switch(M){case yB.Float:x.byteArray=new Float32Array(g),x.textureType=1,L&&x.byteArray.fill(1,0,g);break;case yB.HalfFloat:x.byteArray=new Uint16Array(g),x.textureType=2,L&&x.byteArray.fill(15360,0,g);break;default:throw new Error("Unsupported type: "+M)}let N=0;for(const f of B.channels)void 0!==x.decodeChannels[f.name]&&(x.channelLineOffsets[f.name]=N*x.width),N+=2*f.pixelType;return x.bytesPerLine=x.width*N,x.outLineWidth=x.width*x.outputChannels,"INCREASING_Y"===B.lineOrder?x.scanOrder=B=>B:x.scanOrder=B=>x.height-1-B,4==x.outputChannels?(x.format=5,x.linearSpace=!0):(x.format=6,x.linearSpace=!1),x}function gB(B,I,C,M){const x={value:0};for(let y=0;y<B.height/B.scanlineBlockSize;y++){const f=r(C,M)-I.dataWindow.yMin;B.size=A(C,M),B.lines=f+B.scanlineBlockSize>B.height?B.height-f:B.scanlineBlockSize;const L=B.size<B.lines*B.bytesPerLine&&B.uncompress?B.uncompress(B):BB(B);M.value+=B.size;for(let C=0;C<B.scanlineBlockSize;C++){const M=y*B.scanlineBlockSize,f=C+B.scanOrder(M);if(f>=B.height)continue;const e=C*B.bytesPerLine,g=(B.height-1-f)*B.outLineWidth;for(let C=0;C<B.channels;C++){const M=I.channels[C].name,y=B.channelLineOffsets[M],f=B.decodeChannels[M];if(void 0!==f){x.value=e+y;for(let I=0;I<B.width;I++){const C=g+I*B.outputChannels+f;B.byteArray&&(B.byteArray[C]=B.getter(L,x))}}}}}}LB.DefaultOutputType=yB.HalfFloat,LB.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class NB{constructor(){this.supportCascades=!1}loadCubeData(B,I,C,M,x){throw".exr not supported in Cube."}loadData(B,I,C){const x=new DataView(B.buffer),y={value:0},f=E(x,y);eB(f,x,y,LB.DefaultOutputType).then((B=>{gB(B,f,x,y);const M=f.dataWindow.xMax-f.dataWindow.xMin+1,L=f.dataWindow.yMax-f.dataWindow.yMin+1;C(M,L,I.generateMipMaps,!1,(()=>{const C=I.getEngine();I.format=f.format,I.type=B.textureType,I.invertY=!1,I._gammaSpace=!f.linearSpace,B.byteArray&&C._uploadDataToTextureDirectly(I,B.byteArray,0,0,void 0,!0)}))})).catch((B=>{M.b.Error("Failed to load EXR texture: ",B)}))}}async function RB(B){const I=new DataView(B),C={value:0},x=E(I,C);try{const B=await eB(x,I,C,yB.Float);return gB(B,x,I,C),B.byteArray?{width:x.dataWindow.xMax-x.dataWindow.xMin+1,height:x.dataWindow.yMax-x.dataWindow.yMin+1,data:new Float32Array(B.byteArray)}:(M.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(y){M.b.Error("Failed to load EXR data: ",y)}return{width:0,height:0,data:null}}},11212:(B,I,C)=>{function M(B){return parseInt(B.toString().replace(/\W/g,""))}function x(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(B-I)<=C}function y(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return B<I-M||B>C+M}function f(B,I){return B===I?B:Math.random()*(I-B)+B}function L(B,I,C){return B+(I-B)*C}function e(B,I,C){let M=S(I-B,360);return M>180&&(M-=360),B+M*H(C)}function g(B,I,C){let M=0;return M=B!=I?H((C-B)/(I-B)):0,M}function N(B,I,C,M,x){const y=x*x,f=x*y;return B*(2*f-3*y+1)+C*(-2*f+3*y)+I*(f-2*y+x)+M*(f-y)}function R(B,I,C,M,x){const y=x*x;return 6*(y-x)*B+(3*y-4*x+1)*I+6*(-y+x)*C+(3*y-2*x)*M}function H(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(C,Math.max(I,B))}function F(B){return B-=2*Math.PI*Math.floor((B+Math.PI)/(2*Math.PI))}function k(B){const I=B.toString(16);return B<=15?("0"+I).toUpperCase():I.toUpperCase()}function q(B){if(Math.log2)return Math.floor(Math.log2(B));if(B<0)return NaN;if(0===B)return-1/0;let I=0;if(B<1){for(;B<1;)I++,B*=2;I=-I}else if(B>1)for(;B>1;)I++,B=Math.floor(B/2);return I}function S(B,I){return B-Math.floor(B/I)*I}function o(B,I,C){return(B-I)/(C-I)}function U(B,I,C){return B*(C-I)+I}function G(B,I){let C=S(I-B,360);return C>180&&(C-=360),C}function V(B,I){const C=S(B,2*I);return I-Math.abs(C-I)}function c(B,I,C){let M=H(C);return M=-2*M*M*M+3*M*M,I*M+B*(1-M)}function t(B,I,C){let M=0;return M=Math.abs(I-B)<=C?I:B+Math.sign(I-B)*C,M}function r(B,I,C){const M=G(B,I);let x=0;return x=-C<M&&M<C?I:t(B,I=B+M,C),x}function A(B,I,C){return(B-I)/(C-I)}function D(B,I,C){return(C-I)*B+I}function J(B,I){const C=B%I;return 0===C?I:J(I,C)}C.r(I),C.d(I,{Clamp:()=>H,DeltaAngle:()=>G,Denormalize:()=>U,ExtractAsInt:()=>M,Hermite:()=>N,Hermite1stDerivative:()=>R,HighestCommonFactor:()=>J,ILog2:()=>q,InverseLerp:()=>g,Lerp:()=>L,LerpAngle:()=>e,MoveTowards:()=>t,MoveTowardsAngle:()=>r,Normalize:()=>o,NormalizeRadians:()=>F,OutsideRange:()=>y,PercentToRange:()=>D,PingPong:()=>V,RandomRange:()=>f,RangeToPercent:()=>A,Repeat:()=>S,SmoothStep:()=>c,ToHex:()=>k,WithinEpsilon:()=>x})}}]);