"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[16],{14154:(D,l,G)=>{G.r(l),G.d(l,{ReadExrDataAsync:()=>gD,_ExrTextureLoader:()=>nD});var V=G(11546),N=G(11728);const M=4,b=4,X=1,t=2,R=8,n=65536,g=n>>3,j=14,e=65537,K=1<<j,F=K-1,d=59,H=63,h=2+H-d;var x,r;!function(D){D[D.NO_COMPRESSION=0]="NO_COMPRESSION",D[D.RLE_COMPRESSION=1]="RLE_COMPRESSION",D[D.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",D[D.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",D[D.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",D[D.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(x||(x={})),function(D){D[D.INCREASING_Y=0]="INCREASING_Y",D[D.DECREASING_Y=1]="DECREASING_Y"}(r||(r={}));const o=function(){const D=new ArrayBuffer(4),l=new Float32Array(D),G=new Uint32Array(D),V=new Uint32Array(512),N=new Uint32Array(512);for(let t=0;t<256;++t){const D=t-127;D<-27?(V[t]=0,V[256|t]=32768,N[t]=24,N[256|t]=24):D<-14?(V[t]=1024>>-D-14,V[256|t]=1024>>-D-14|32768,N[t]=-D-1,N[256|t]=-D-1):D<=15?(V[t]=D+15<<10,V[256|t]=D+15<<10|32768,N[t]=13,N[256|t]=13):D<128?(V[t]=31744,V[256|t]=64512,N[t]=24,N[256|t]=24):(V[t]=31744,V[256|t]=64512,N[t]=13,N[256|t]=13)}const M=new Uint32Array(2048),b=new Uint32Array(64),X=new Uint32Array(64);for(let t=1;t<1024;++t){let D=t<<13,l=0;for(;0===(8388608&D);)D<<=1,l-=8388608;D&=-8388609,l+=947912704,M[t]=D|l}for(let t=1024;t<2048;++t)M[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)b[t]=t<<23;b[31]=1199570944,b[32]=2147483648;for(let t=33;t<63;++t)b[t]=2147483648+(t-32<<23);b[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(X[t]=1024);return{floatView:l,uint32View:G,baseTable:V,shiftTable:N,mantissaTable:M,exponentTable:b,offsetTable:X}}();function L(D,l){const G=new Uint8Array(D);let V=0;for(;0!=G[l.value+V];)V+=1;const N=(new TextDecoder).decode(G.slice(l.value,l.value+V));return l.value=l.value+V+1,N}function u(D,l){const G=D.getInt32(l.value,!0);return l.value+=M,G}function B(D,l){const G=D.getUint32(l.value,!0);return l.value+=M,G}function I(D,l){const G=D.getUint8(l.value);return l.value+=X,G}function W(D,l){const G=D.getUint16(l.value,!0);return l.value+=t,G}function i(D,l){const G=D[l.value];return l.value+=X,G}function y(D,l){let G;return G="getBigInt64"in DataView.prototype?Number(D.getBigInt64(l.value,!0)):D.getUint32(l.value+4,!0)+Number(D.getUint32(l.value,!0)<<32),l.value+=R,G}function S(D,l){const G=D.getFloat32(l.value,!0);return l.value+=b,G}function O(D,l){return function(D){const l=(31744&D)>>10,G=1023&D;return(D>>15?-1:1)*(l?31===l?G?NaN:1/0:Math.pow(2,l-15)*(1+G/1024):G/1024*6103515625e-14)}(W(D,l))}function s(D,l){return function(D){if(Math.abs(D)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");D=(0,N.Clamp)(D,-65504,65504),o.floatView[0]=D;const l=o.uint32View[0],G=l>>23&511;return o.baseTable[G]+((8388607&l)>>o.shiftTable[G])}(S(D,l))}function U(D,l,G,V){switch(G){case"string":case"stringvector":case"iccProfile":return function(D,l,G){const V=(new TextDecoder).decode(new Uint8Array(D).slice(l.value,l.value+G));return l.value=l.value+G,V}(D.buffer,l,V);case"chlist":return function(D,l,G){const V=l.value,N=[];for(;l.value<V+G-1;){const G=L(D.buffer,l),V=u(D,l),M=I(D,l);l.value+=3;const b=u(D,l),X=u(D,l);N.push({name:G,pixelType:V,pLinear:M,xSampling:b,ySampling:X})}return l.value+=1,N}(D,l,V);case"chromaticities":return function(D,l){return{redX:S(D,l),redY:S(D,l),greenX:S(D,l),greenY:S(D,l),blueX:S(D,l),blueY:S(D,l),whiteX:S(D,l),whiteY:S(D,l)}}(D,l);case"compression":return function(D,l){return I(D,l)}(D,l);case"box2i":return function(D,l){return{xMin:u(D,l),yMin:u(D,l),xMax:u(D,l),yMax:u(D,l)}}(D,l);case"lineOrder":return function(D,l){const G=I(D,l);return r[G]}(D,l);case"float":return S(D,l);case"v2f":return function(D,l){return[S(D,l),S(D,l)]}(D,l);case"v3f":return function(D,l){return[S(D,l),S(D,l),S(D,l)]}(D,l);case"int":return u(D,l);case"rational":return function(D,l){return[u(D,l),B(D,l)]}(D,l);case"timecode":return function(D,l){return[B(D,l),B(D,l)]}(D,l);case"preview":return l.value+=V,"skipped";default:return void(l.value+=V)}}function f(D){for(let l=1;l<D.length;l++){const G=D[l-1]+D[l]-128;D[l]=G}}function q(D,l){let G=0,V=Math.floor((D.length+1)/2),N=0;const M=D.length-1;for(;!(N>M)&&(l[N++]=D[G++],!(N>M));)l[N++]=D[V++]}const c=20000630;function v(D,l){if(D.getUint32(0,!0)!=c)throw new Error("Incorrect OpenEXR format");const G=D.getUint8(4),N=D.getUint8(5),M={singleTile:!!(2&N),longName:!!(4&N),deepFormat:!!(8&N),multiPart:!!(16&N)};l.value=8;const b={};let X=!0;for(;X;){const G=L(D.buffer,l);if(G){const N=L(D.buffer,l),M=U(D,l,N,B(D,l));void 0===M?V.d.Warn(`Unknown header attribute type ${N}'.`):b[G]=M}else X=!1}if(0!=(-5&N))throw new Error("Unsupported file format");return{version:G,spec:M,...b}}const Z=32768,J=65535;function Y(D,l,G,V,N){for(;G<D;)l=l<<8|i(V,N),G+=8;return{l:l>>(G-=D)&(1<<D)-1,c:l,lc:G}}function z(D,l,G,V){return{c:D=D<<8|i(G,V),lc:l+=8}}function E(D,l,G,V,N,M,b,X,t){if(D==l){if(V<8){const D=z(G,V,N,M);G=D.c,V=D.lc}let D=G>>(V-=8);if(D=new Uint8Array([D])[0],X.value+D>t)return null;const l=b[X.value-1];for(;D-- >0;)b[X.value++]=l}else{if(!(X.value<t))return null;b[X.value++]=D}return{c:G,lc:V}}const P=new Array(59);function p(D,l,G,V,N,M){const b=l;let X=0,t=0;for(;V<=N;V++){if(b.value-l.value>G)return;let R=Y(6,X,t,D,b);const n=R.l;if(X=R.c,t=R.lc,M[V]=n,n==H){if(b.value-l.value>G)throw new Error("Error in HufUnpackEncTable");R=Y(8,X,t,D,b);let n=R.l+h;if(X=R.c,t=R.lc,V+n>N+1)throw new Error("Error in HufUnpackEncTable");for(;n--;)M[V++]=0;V--}else if(n>=d){let D=n-d+2;if(V+D>N+1)throw new Error("Error in HufUnpackEncTable");for(;D--;)M[V++]=0;V--}}!function(D){for(let G=0;G<=58;++G)P[G]=0;for(let G=0;G<e;++G)P[D[G]]+=1;let l=0;for(let G=58;G>0;--G){const D=l+P[G]>>1;P[G]=l,l=D}for(let G=0;G<e;++G){const l=D[G];l>0&&(D[G]=l|P[l]++<<6)}}(M)}function k(D){return 63&D}function m(D){return D>>6}function T(D,l,G,V,N,M){const b=G.value,X=B(l,G),t=B(l,G);G.value+=4;const R=B(l,G);if(G.value+=4,X<0||X>=e||t<0||t>=e)throw new Error("Wrong HUF_ENCSIZE");const n=new Array(e),g=new Array(K);!function(D){for(let l=0;l<K;l++)D[l]={},D[l].len=0,D[l].lit=0,D[l].p=null}(g);if(p(D,G,V-(G.value-b),X,t,n),R>8*(V-(G.value-b)))throw new Error("Wrong hufUncompress");!function(D,l,G,V){for(;l<=G;l++){const G=m(D[l]),N=k(D[l]);if(G>>N)throw new Error("Invalid table entry");if(N>j){const D=V[G>>N-j];if(D.len)throw new Error("Invalid table entry");if(D.lit++,D.p){const l=D.p;D.p=new Array(D.lit);for(let G=0;G<D.lit-1;++G)D.p[G]=l[G]}else D.p=new Array(1);D.p[D.lit-1]=l}else if(N){let D=0;for(let M=1<<j-N;M>0;M--){const M=V[(G<<j-N)+D];if(M.len||M.p)throw new Error("Invalid table entry");M.len=N,M.lit=l,D++}}}}(n,X,t,g),function(D,l,G,V,N,M,b,X,t){let R=0,n=0;const g=b,e=Math.trunc(V.value+(N+7)/8);for(;V.value<e;){let N=z(R,n,G,V);for(R=N.c,n=N.lc;n>=j;){const b=l[R>>n-j&F];if(b.len){n-=b.len;const D=E(b.lit,M,R,n,G,V,X,t,g);D&&(R=D.c,n=D.lc)}else{if(!b.p)throw new Error("hufDecode issues");let l;for(l=0;l<b.lit;l++){const j=k(D[b.p[l]]);for(;n<j&&V.value<e;)N=z(R,n,G,V),R=N.c,n=N.lc;if(n>=j&&m(D[b.p[l]])==(R>>n-j&(1<<j)-1)){n-=j;const D=E(b.p[l],M,R,n,G,V,X,t,g);D&&(R=D.c,n=D.lc);break}}if(l==b.lit)throw new Error("HufDecode issues")}}}const K=8-N&7;for(R>>=K,n-=K;n>0;){const D=l[R<<j-n&F];if(!D.len)throw new Error("HufDecode issues");{n-=D.len;const l=E(D.lit,M,R,n,G,V,X,t,g);l&&(R=l.c,n=l.lc)}}}(n,g,D,G,R,t,M,N,{value:0})}function C(D){return 65535&D}function w(D){const l=C(D);return l>32767?l-65536:l}function A(D,l){const G=w(D),V=w(l),N=G+(1&V)+(V>>1);return{a:N,b:N-V}}function a(D,l){const G=C(D),V=C(l),N=G-(V>>1)&J;return{a:V+N-Z&J,b:N}}function Q(D,l,G,V,N,M,b){const X=b<16384,t=G>N?N:G;let R,n,g=1;for(;g<=t;)g<<=1;for(g>>=1,R=g,g>>=1;g>=1;){n=0;const b=n+M*(N-R),t=M*g,j=M*R,e=V*g,K=V*R;let F,d,H,h;for(;n<=b;n+=j){let N=n;const M=n+V*(G-R);for(;N<=M;N+=K){const G=N+e,V=N+t,M=V+e;if(X){let b=A(D[N+l],D[V+l]);F=b.a,H=b.b,b=A(D[G+l],D[M+l]),d=b.a,h=b.b,b=A(F,d),D[N+l]=b.a,D[G+l]=b.b,b=A(H,h),D[V+l]=b.a,D[M+l]=b.b}else{let b=a(D[N+l],D[V+l]);F=b.a,H=b.b,b=a(D[G+l],D[M+l]),d=b.a,h=b.b,b=a(F,d),D[N+l]=b.a,D[G+l]=b.b,b=a(H,h),D[V+l]=b.a,D[M+l]=b.b}}if(G&g){const G=N+t;let V;V=X?A(D[N+l],D[G+l]):a(D[N+l],D[G+l]),F=V.a,D[G+l]=V.b,D[N+l]=F}}if(N&g){let N=n;const M=n+V*(G-R);for(;N<=M;N+=K){const G=N+e;let V;V=X?A(D[N+l],D[G+l]):a(D[N+l],D[G+l]),F=V.a,D[G+l]=V.b,D[N+l]=F}}R=g,g>>=1}return n}function DD(D){return new DataView(D.array.buffer,D.offset.value,D.size)}function lD(D){const l=D.viewer.buffer.slice(D.offset.value,D.offset.value+D.size),G=new Uint8Array(function(D){let l=D.byteLength;const G=[];let V=0;const N=new DataView(D);for(;l>0;){const D=N.getInt8(V++);if(D<0){const M=-D;l-=M+1;for(let D=0;D<M;D++)G.push(N.getUint8(V++))}else{const M=D;l-=2;const b=N.getUint8(V++);for(let D=0;D<M+1;D++)G.push(b)}}return G}(l)),V=new Uint8Array(G.length);return f(G),q(G,V),new DataView(V.buffer)}function GD(D){const l=D.array.slice(D.offset.value,D.offset.value+D.size),G=fflate.unzlibSync(l),V=new Uint8Array(G.length);return f(G),q(G,V),new DataView(V.buffer)}function VD(D){const l=D.array.slice(D.offset.value,D.offset.value+D.size),G=fflate.unzlibSync(l),V=D.lines*D.channels*D.width,N=1==D.type?new Uint16Array(V):new Uint32Array(V);let M=0,b=0;const X=new Array(4);for(let t=0;t<D.lines;t++)for(let l=0;l<D.channels;l++){let l=0;switch(D.type){case 1:X[0]=M,X[1]=X[0]+D.width,M=X[1]+D.width;for(let V=0;V<D.width;++V){l+=G[X[0]++]<<8|G[X[1]++],N[b]=l,b++}break;case 2:X[0]=M,X[1]=X[0]+D.width,X[2]=X[1]+D.width,M=X[2]+D.width;for(let V=0;V<D.width;++V){l+=G[X[0]++]<<24|G[X[1]++]<<16|G[X[2]++]<<8,N[b]=l,b++}}}return new DataView(N.buffer)}function ND(D){const l=D.viewer,G={value:D.offset.value},V=new Uint16Array(D.width*D.scanlineBlockSize*(D.channels*D.type)),N=new Uint8Array(g);let M=0;const b=new Array(D.channels);for(let t=0;t<D.channels;t++)b[t]={},b[t].start=M,b[t].end=b[t].start,b[t].nx=D.width,b[t].ny=D.lines,b[t].size=D.type,M+=b[t].nx*b[t].ny*b[t].size;const X=W(l,G),R=W(l,G);if(R>=g)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(X<=R)for(let t=0;t<R-X+1;t++)N[t+X]=I(l,G);const j=new Uint16Array(n),e=function(D,l){let G=0;for(let N=0;N<n;++N)(0==N||D[N>>3]&1<<(7&N))&&(l[G++]=N);const V=G-1;for(;G<n;)l[G++]=0;return V}(N,j),K=B(l,G);T(D.array,l,G,K,V,M);for(let t=0;t<D.channels;++t){const D=b[t];for(let l=0;l<b[t].size;++l)Q(V,D.start+l,D.nx,D.size,D.ny,D.nx*D.size,e)}!function(D,l,G){for(let V=0;V<G;++V)l[V]=D[l[V]]}(j,V,M);let F=0;const d=new Uint8Array(V.buffer.byteLength);for(let n=0;n<D.lines;n++)for(let l=0;l<D.channels;l++){const D=b[l],G=D.nx*D.size,N=new Uint8Array(V.buffer,D.end*t,G*t);d.set(N,F),F+=G*t,D.end+=G}return new DataView(d.buffer)}var MD,bD=G(11530);!function(D){D[D.Float=0]="Float",D[D.HalfFloat=1]="HalfFloat"}(MD||(MD={}));class XD{}async function tD(D,l,G,V){const N={size:0,viewer:l,array:new Uint8Array(l.buffer),offset:G,width:D.dataWindow.xMax-D.dataWindow.xMin+1,height:D.dataWindow.yMax-D.dataWindow.yMin+1,channels:D.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(D.compression){case x.NO_COMPRESSION:N.lines=1,N.uncompress=DD;break;case x.RLE_COMPRESSION:N.lines=1,N.uncompress=lD;break;case x.ZIPS_COMPRESSION:N.lines=1,N.uncompress=GD,await bD.Tools.LoadScriptAsync(XD.FFLATEUrl);break;case x.ZIP_COMPRESSION:N.lines=16,N.uncompress=GD,await bD.Tools.LoadScriptAsync(XD.FFLATEUrl);break;case x.PIZ_COMPRESSION:N.lines=32,N.uncompress=ND;break;case x.PXR24_COMPRESSION:N.lines=16,N.uncompress=VD,await bD.Tools.LoadScriptAsync(XD.FFLATEUrl);break;default:throw new Error(x[D.compression]+" is unsupported")}N.scanlineBlockSize=N.lines;const M={};for(const b of D.channels)switch(b.name){case"R":case"G":case"B":case"A":case"Y":M[b.name]=!0,N.type=b.pixelType}let X=!1;if(M.R&&M.G&&M.B&&M.A)N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(M.R&&M.G&&M.B)X=!0,N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(M.R&&M.G)N.outputChannels=2,N.decodeChannels={R:0,G:1};else if(M.R)N.outputChannels=1,N.decodeChannels={R:0};else{if(!M.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");N.outputChannels=1,N.decodeChannels={Y:0}}if(1===N.type)switch(V){case MD.Float:N.getter=O,N.inputSize=t;break;case MD.HalfFloat:N.getter=W,N.inputSize=t}else{if(2!==N.type)throw new Error("Unsupported pixelType "+N.type+" for "+D.compression);switch(V){case MD.Float:N.getter=S,N.inputSize=b;break;case MD.HalfFloat:N.getter=s,N.inputSize=b}}N.blockCount=N.height/N.scanlineBlockSize;for(let b=0;b<N.blockCount;b++)y(l,G);const R=N.width*N.height*N.outputChannels;switch(V){case MD.Float:N.byteArray=new Float32Array(R),N.textureType=1,X&&N.byteArray.fill(1,0,R);break;case MD.HalfFloat:N.byteArray=new Uint16Array(R),N.textureType=2,X&&N.byteArray.fill(15360,0,R);break;default:throw new Error("Unsupported type: "+V)}let n=0;for(const b of D.channels)void 0!==N.decodeChannels[b.name]&&(N.channelLineOffsets[b.name]=n*N.width),n+=2*b.pixelType;return N.bytesPerLine=N.width*n,N.outLineWidth=N.width*N.outputChannels,"INCREASING_Y"===D.lineOrder?N.scanOrder=D=>D:N.scanOrder=D=>N.height-1-D,4==N.outputChannels?(N.format=5,N.linearSpace=!0):(N.format=6,N.linearSpace=!1),N}function RD(D,l,G,V){const N={value:0};for(let M=0;M<D.height/D.scanlineBlockSize;M++){const b=u(G,V)-l.dataWindow.yMin;D.size=B(G,V),D.lines=b+D.scanlineBlockSize>D.height?D.height-b:D.scanlineBlockSize;const X=D.size<D.lines*D.bytesPerLine&&D.uncompress?D.uncompress(D):DD(D);V.value+=D.size;for(let G=0;G<D.scanlineBlockSize;G++){const V=M*D.scanlineBlockSize,b=G+D.scanOrder(V);if(b>=D.height)continue;const t=G*D.bytesPerLine,R=(D.height-1-b)*D.outLineWidth;for(let G=0;G<D.channels;G++){const V=l.channels[G].name,M=D.channelLineOffsets[V],b=D.decodeChannels[V];if(void 0!==b){N.value=t+M;for(let l=0;l<D.width;l++){const G=R+l*D.outputChannels+b;D.byteArray&&(D.byteArray[G]=D.getter(X,N))}}}}}}XD.DefaultOutputType=MD.HalfFloat,XD.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class nD{constructor(){this.supportCascades=!1}loadCubeData(D,l,G,V,N){throw".exr not supported in Cube."}loadData(D,l,G){const N=new DataView(D.buffer),M={value:0},b=v(N,M);tD(b,N,M,XD.DefaultOutputType).then((D=>{RD(D,b,N,M);const V=b.dataWindow.xMax-b.dataWindow.xMin+1,X=b.dataWindow.yMax-b.dataWindow.yMin+1;G(V,X,l.generateMipMaps,!1,(()=>{const G=l.getEngine();l.format=b.format,l.type=D.textureType,l.invertY=!1,l._gammaSpace=!b.linearSpace,D.byteArray&&G._uploadDataToTextureDirectly(l,D.byteArray,0,0,void 0,!0)}))})).catch((D=>{V.d.Error("Failed to load EXR texture: ",D)}))}}async function gD(D){const l=new DataView(D),G={value:0},N=v(l,G);try{const D=await tD(N,l,G,MD.Float);return RD(D,N,l,G),D.byteArray?{width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,data:new Float32Array(D.byteArray)}:(V.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(M){V.d.Error("Failed to load EXR data: ",M)}return{width:0,height:0,data:null}}},11728:(D,l,G)=>{function V(D){return parseInt(D.toString().replace(/\W/g,""))}function N(D,l){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(D-l)<=G}function M(D,l,G){let V=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return D<l-V||D>G+V}function b(D,l){return D===l?D:Math.random()*(l-D)+D}function X(D,l,G){return D+(l-D)*G}function t(D,l,G){let V=d(l-D,360);return V>180&&(V-=360),D+V*j(G)}function R(D,l,G){let V=0;return V=D!=l?j((G-D)/(l-D)):0,V}function n(D,l,G,V,N){const M=N*N,b=N*M;return D*(2*b-3*M+1)+G*(-2*b+3*M)+l*(b-2*M+N)+V*(b-M)}function g(D,l,G,V,N){const M=N*N;return 6*(M-N)*D+(3*M-4*N+1)*l+6*(-M+N)*G+(3*M-2*N)*V}function j(D){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(G,Math.max(l,D))}function e(D){return D-=2*Math.PI*Math.floor((D+Math.PI)/(2*Math.PI))}function K(D){const l=D.toString(16);return D<=15?("0"+l).toUpperCase():l.toUpperCase()}function F(D){if(Math.log2)return Math.floor(Math.log2(D));if(D<0)return NaN;if(0===D)return-1/0;let l=0;if(D<1){for(;D<1;)l++,D*=2;l=-l}else if(D>1)for(;D>1;)l++,D=Math.floor(D/2);return l}function d(D,l){return D-Math.floor(D/l)*l}function H(D,l,G){return(D-l)/(G-l)}function h(D,l,G){return D*(G-l)+l}function x(D,l){let G=d(l-D,360);return G>180&&(G-=360),G}function r(D,l){const G=d(D,2*l);return l-Math.abs(G-l)}function o(D,l,G){let V=j(G);return V=-2*V*V*V+3*V*V,l*V+D*(1-V)}function L(D,l,G){let V=0;return V=Math.abs(l-D)<=G?l:D+Math.sign(l-D)*G,V}function u(D,l,G){const V=x(D,l);let N=0;return N=-G<V&&V<G?l:L(D,l=D+V,G),N}function B(D,l,G){return(D-l)/(G-l)}function I(D,l,G){return(G-l)*D+l}function W(D,l){const G=D%l;return 0===G?l:W(l,G)}G.r(l),G.d(l,{Clamp:()=>j,DeltaAngle:()=>x,Denormalize:()=>h,ExtractAsInt:()=>V,Hermite:()=>n,Hermite1stDerivative:()=>g,HighestCommonFactor:()=>W,ILog2:()=>F,InverseLerp:()=>R,Lerp:()=>X,LerpAngle:()=>t,MoveTowards:()=>L,MoveTowardsAngle:()=>u,Normalize:()=>H,NormalizeRadians:()=>e,OutsideRange:()=>M,PercentToRange:()=>I,PingPong:()=>r,RandomRange:()=>b,RangeToPercent:()=>B,Repeat:()=>d,SmoothStep:()=>o,ToHex:()=>K,WithinEpsilon:()=>N})}}]);