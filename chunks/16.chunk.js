"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[16],{13775:(H,O,S)=>{S.r(O),S.d(O,{ReadExrDataAsync:()=>hH,_ExrTextureLoader:()=>oH});var t=S(11151),q=S(11317);const p=4,G=4,U=1,V=2,w=8,o=65536,h=o>>3,a=14,j=65537,e=1<<a,X=e-1,E=59,y=63,T=2+y-E;var K,b;!function(H){H[H.NO_COMPRESSION=0]="NO_COMPRESSION",H[H.RLE_COMPRESSION=1]="RLE_COMPRESSION",H[H.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",H[H.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",H[H.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",H[H.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(K||(K={})),function(H){H[H.INCREASING_Y=0]="INCREASING_Y",H[H.DECREASING_Y=1]="DECREASING_Y"}(b||(b={}));const D=function(){const H=new ArrayBuffer(4),O=new Float32Array(H),S=new Uint32Array(H),t=new Uint32Array(512),q=new Uint32Array(512);for(let V=0;V<256;++V){const H=V-127;H<-27?(t[V]=0,t[256|V]=32768,q[V]=24,q[256|V]=24):H<-14?(t[V]=1024>>-H-14,t[256|V]=1024>>-H-14|32768,q[V]=-H-1,q[256|V]=-H-1):H<=15?(t[V]=H+15<<10,t[256|V]=H+15<<10|32768,q[V]=13,q[256|V]=13):H<128?(t[V]=31744,t[256|V]=64512,q[V]=24,q[256|V]=24):(t[V]=31744,t[256|V]=64512,q[V]=13,q[256|V]=13)}const p=new Uint32Array(2048),G=new Uint32Array(64),U=new Uint32Array(64);for(let V=1;V<1024;++V){let H=V<<13,O=0;for(;0===(8388608&H);)H<<=1,O-=8388608;H&=-8388609,O+=947912704,p[V]=H|O}for(let V=1024;V<2048;++V)p[V]=939524096+(V-1024<<13);for(let V=1;V<31;++V)G[V]=V<<23;G[31]=1199570944,G[32]=2147483648;for(let V=33;V<63;++V)G[V]=2147483648+(V-32<<23);G[63]=3347054592;for(let V=1;V<64;++V)32!==V&&(U[V]=1024);return{floatView:O,uint32View:S,baseTable:t,shiftTable:q,mantissaTable:p,exponentTable:G,offsetTable:U}}();function F(H,O){const S=new Uint8Array(H);let t=0;for(;0!=S[O.value+t];)t+=1;const q=(new TextDecoder).decode(S.slice(O.value,O.value+t));return O.value=O.value+t+1,q}function Y(H,O){const S=H.getInt32(O.value,!0);return O.value+=p,S}function l(H,O){const S=H.getUint32(O.value,!0);return O.value+=p,S}function d(H,O){const S=H.getUint8(O.value);return O.value+=U,S}function v(H,O){const S=H.getUint16(O.value,!0);return O.value+=V,S}function z(H,O){const S=H[O.value];return O.value+=U,S}function m(H,O){let S;return S="getBigInt64"in DataView.prototype?Number(H.getBigInt64(O.value,!0)):H.getUint32(O.value+4,!0)+Number(H.getUint32(O.value,!0)<<32),O.value+=w,S}function r(H,O){const S=H.getFloat32(O.value,!0);return O.value+=G,S}function W(H,O){return function(H){const O=(31744&H)>>10,S=1023&H;return(H>>15?-1:1)*(O?31===O?S?NaN:1/0:Math.pow(2,O-15)*(1+S/1024):S/1024*6103515625e-14)}(v(H,O))}function g(H,O){return function(H){if(Math.abs(H)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");H=(0,q.Clamp)(H,-65504,65504),D.floatView[0]=H;const O=D.uint32View[0],S=O>>23&511;return D.baseTable[S]+((8388607&O)>>D.shiftTable[S])}(r(H,O))}function N(H,O,S,t){switch(S){case"string":case"stringvector":case"iccProfile":return function(H,O,S){const t=(new TextDecoder).decode(new Uint8Array(H).slice(O.value,O.value+S));return O.value=O.value+S,t}(H.buffer,O,t);case"chlist":return function(H,O,S){const t=O.value,q=[];for(;O.value<t+S-1;){const S=F(H.buffer,O),t=Y(H,O),p=d(H,O);O.value+=3;const G=Y(H,O),U=Y(H,O);q.push({name:S,pixelType:t,pLinear:p,xSampling:G,ySampling:U})}return O.value+=1,q}(H,O,t);case"chromaticities":return function(H,O){return{redX:r(H,O),redY:r(H,O),greenX:r(H,O),greenY:r(H,O),blueX:r(H,O),blueY:r(H,O),whiteX:r(H,O),whiteY:r(H,O)}}(H,O);case"compression":return function(H,O){return d(H,O)}(H,O);case"box2i":return function(H,O){return{xMin:Y(H,O),yMin:Y(H,O),xMax:Y(H,O),yMax:Y(H,O)}}(H,O);case"lineOrder":return function(H,O){const S=d(H,O);return b[S]}(H,O);case"float":return r(H,O);case"v2f":return function(H,O){return[r(H,O),r(H,O)]}(H,O);case"v3f":return function(H,O){return[r(H,O),r(H,O),r(H,O)]}(H,O);case"int":return Y(H,O);case"rational":return function(H,O){return[Y(H,O),l(H,O)]}(H,O);case"timecode":return function(H,O){return[l(H,O),l(H,O)]}(H,O);case"preview":return O.value+=t,"skipped";default:return void(O.value+=t)}}function x(H){for(let O=1;O<H.length;O++){const S=H[O-1]+H[O]-128;H[O]=S}}function k(H,O){let S=0,t=Math.floor((H.length+1)/2),q=0;const p=H.length-1;for(;!(q>p)&&(O[q++]=H[S++],!(q>p));)O[q++]=H[t++]}const A=20000630;function u(H,O){if(H.getUint32(0,!0)!=A)throw new Error("Incorrect OpenEXR format");const S=H.getUint8(4),q=H.getUint8(5),p={singleTile:!!(2&q),longName:!!(4&q),deepFormat:!!(8&q),multiPart:!!(16&q)};O.value=8;const G={};let U=!0;for(;U;){const S=F(H.buffer,O);if(S){const q=F(H.buffer,O),p=N(H,O,q,l(H,O));void 0===p?t.b.Warn(`Unknown header attribute type ${q}'.`):G[S]=p}else U=!1}if(0!=(-5&q))throw new Error("Unsupported file format");return{version:S,spec:p,...G}}const J=32768,P=65535;function f(H,O,S,t,q){for(;S<H;)O=O<<8|z(t,q),S+=8;return{l:O>>(S-=H)&(1<<H)-1,c:O,lc:S}}function c(H,O,S,t){return{c:H=H<<8|z(S,t),lc:O+=8}}function R(H,O,S,t,q,p,G,U,V){if(H==O){if(t<8){const H=c(S,t,q,p);S=H.c,t=H.lc}let H=S>>(t-=8);if(H=new Uint8Array([H])[0],U.value+H>V)return null;const O=G[U.value-1];for(;H-- >0;)G[U.value++]=O}else{if(!(U.value<V))return null;G[U.value++]=H}return{c:S,lc:t}}const B=new Array(59);function Z(H,O,S,t,q,p){const G=O;let U=0,V=0;for(;t<=q;t++){if(G.value-O.value>S)return;let w=f(6,U,V,H,G);const o=w.l;if(U=w.c,V=w.lc,p[t]=o,o==y){if(G.value-O.value>S)throw new Error("Error in HufUnpackEncTable");w=f(8,U,V,H,G);let o=w.l+T;if(U=w.c,V=w.lc,t+o>q+1)throw new Error("Error in HufUnpackEncTable");for(;o--;)p[t++]=0;t--}else if(o>=E){let H=o-E+2;if(t+H>q+1)throw new Error("Error in HufUnpackEncTable");for(;H--;)p[t++]=0;t--}}!function(H){for(let S=0;S<=58;++S)B[S]=0;for(let S=0;S<j;++S)B[H[S]]+=1;let O=0;for(let S=58;S>0;--S){const H=O+B[S]>>1;B[S]=O,O=H}for(let S=0;S<j;++S){const O=H[S];O>0&&(H[S]=O|B[O]++<<6)}}(p)}function I(H){return 63&H}function s(H){return H>>6}function i(H,O,S,t,q,p){const G=S.value,U=l(O,S),V=l(O,S);S.value+=4;const w=l(O,S);if(S.value+=4,U<0||U>=j||V<0||V>=j)throw new Error("Wrong HUF_ENCSIZE");const o=new Array(j),h=new Array(e);!function(H){for(let O=0;O<e;O++)H[O]={},H[O].len=0,H[O].lit=0,H[O].p=null}(h);if(Z(H,S,t-(S.value-G),U,V,o),w>8*(t-(S.value-G)))throw new Error("Wrong hufUncompress");!function(H,O,S,t){for(;O<=S;O++){const S=s(H[O]),q=I(H[O]);if(S>>q)throw new Error("Invalid table entry");if(q>a){const H=t[S>>q-a];if(H.len)throw new Error("Invalid table entry");if(H.lit++,H.p){const O=H.p;H.p=new Array(H.lit);for(let S=0;S<H.lit-1;++S)H.p[S]=O[S]}else H.p=new Array(1);H.p[H.lit-1]=O}else if(q){let H=0;for(let p=1<<a-q;p>0;p--){const p=t[(S<<a-q)+H];if(p.len||p.p)throw new Error("Invalid table entry");p.len=q,p.lit=O,H++}}}}(o,U,V,h),function(H,O,S,t,q,p,G,U,V){let w=0,o=0;const h=G,j=Math.trunc(t.value+(q+7)/8);for(;t.value<j;){let q=c(w,o,S,t);for(w=q.c,o=q.lc;o>=a;){const G=O[w>>o-a&X];if(G.len){o-=G.len;const H=R(G.lit,p,w,o,S,t,U,V,h);H&&(w=H.c,o=H.lc)}else{if(!G.p)throw new Error("hufDecode issues");let O;for(O=0;O<G.lit;O++){const a=I(H[G.p[O]]);for(;o<a&&t.value<j;)q=c(w,o,S,t),w=q.c,o=q.lc;if(o>=a&&s(H[G.p[O]])==(w>>o-a&(1<<a)-1)){o-=a;const H=R(G.p[O],p,w,o,S,t,U,V,h);H&&(w=H.c,o=H.lc);break}}if(O==G.lit)throw new Error("HufDecode issues")}}}const e=8-q&7;for(w>>=e,o-=e;o>0;){const H=O[w<<a-o&X];if(!H.len)throw new Error("HufDecode issues");{o-=H.len;const O=R(H.lit,p,w,o,S,t,U,V,h);O&&(w=O.c,o=O.lc)}}}(o,h,H,S,w,V,p,q,{value:0})}function M(H){return 65535&H}function C(H){const O=M(H);return O>32767?O-65536:O}function n(H,O){const S=C(H),t=C(O),q=S+(1&t)+(t>>1);return{a:q,b:q-t}}function Q(H,O){const S=M(H),t=M(O),q=S-(t>>1)&P;return{a:t+q-J&P,b:q}}function L(H,O,S,t,q,p,G){const U=G<16384,V=S>q?q:S;let w,o,h=1;for(;h<=V;)h<<=1;for(h>>=1,w=h,h>>=1;h>=1;){o=0;const G=o+p*(q-w),V=p*h,a=p*w,j=t*h,e=t*w;let X,E,y,T;for(;o<=G;o+=a){let q=o;const p=o+t*(S-w);for(;q<=p;q+=e){const S=q+j,t=q+V,p=t+j;if(U){let G=n(H[q+O],H[t+O]);X=G.a,y=G.b,G=n(H[S+O],H[p+O]),E=G.a,T=G.b,G=n(X,E),H[q+O]=G.a,H[S+O]=G.b,G=n(y,T),H[t+O]=G.a,H[p+O]=G.b}else{let G=Q(H[q+O],H[t+O]);X=G.a,y=G.b,G=Q(H[S+O],H[p+O]),E=G.a,T=G.b,G=Q(X,E),H[q+O]=G.a,H[S+O]=G.b,G=Q(y,T),H[t+O]=G.a,H[p+O]=G.b}}if(S&h){const S=q+V;let t;t=U?n(H[q+O],H[S+O]):Q(H[q+O],H[S+O]),X=t.a,H[S+O]=t.b,H[q+O]=X}}if(q&h){let q=o;const p=o+t*(S-w);for(;q<=p;q+=e){const S=q+j;let t;t=U?n(H[q+O],H[S+O]):Q(H[q+O],H[S+O]),X=t.a,H[S+O]=t.b,H[q+O]=X}}w=h,h>>=1}return o}function HH(H){return new DataView(H.array.buffer,H.offset.value,H.size)}function OH(H){const O=H.viewer.buffer.slice(H.offset.value,H.offset.value+H.size),S=new Uint8Array(function(H){let O=H.byteLength;const S=[];let t=0;const q=new DataView(H);for(;O>0;){const H=q.getInt8(t++);if(H<0){const p=-H;O-=p+1;for(let H=0;H<p;H++)S.push(q.getUint8(t++))}else{const p=H;O-=2;const G=q.getUint8(t++);for(let H=0;H<p+1;H++)S.push(G)}}return S}(O)),t=new Uint8Array(S.length);return x(S),k(S,t),new DataView(t.buffer)}function SH(H){const O=H.array.slice(H.offset.value,H.offset.value+H.size),S=fflate.unzlibSync(O),t=new Uint8Array(S.length);return x(S),k(S,t),new DataView(t.buffer)}function tH(H){const O=H.array.slice(H.offset.value,H.offset.value+H.size),S=fflate.unzlibSync(O),t=H.lines*H.channels*H.width,q=1==H.type?new Uint16Array(t):new Uint32Array(t);let p=0,G=0;const U=new Array(4);for(let V=0;V<H.lines;V++)for(let O=0;O<H.channels;O++){let O=0;switch(H.type){case 1:U[0]=p,U[1]=U[0]+H.width,p=U[1]+H.width;for(let t=0;t<H.width;++t){O+=S[U[0]++]<<8|S[U[1]++],q[G]=O,G++}break;case 2:U[0]=p,U[1]=U[0]+H.width,U[2]=U[1]+H.width,p=U[2]+H.width;for(let t=0;t<H.width;++t){O+=S[U[0]++]<<24|S[U[1]++]<<16|S[U[2]++]<<8,q[G]=O,G++}}}return new DataView(q.buffer)}function qH(H){const O=H.viewer,S={value:H.offset.value},t=new Uint16Array(H.width*H.scanlineBlockSize*(H.channels*H.type)),q=new Uint8Array(h);let p=0;const G=new Array(H.channels);for(let V=0;V<H.channels;V++)G[V]={},G[V].start=p,G[V].end=G[V].start,G[V].nx=H.width,G[V].ny=H.lines,G[V].size=H.type,p+=G[V].nx*G[V].ny*G[V].size;const U=v(O,S),w=v(O,S);if(w>=h)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(U<=w)for(let V=0;V<w-U+1;V++)q[V+U]=d(O,S);const a=new Uint16Array(o),j=function(H,O){let S=0;for(let q=0;q<o;++q)(0==q||H[q>>3]&1<<(7&q))&&(O[S++]=q);const t=S-1;for(;S<o;)O[S++]=0;return t}(q,a),e=l(O,S);i(H.array,O,S,e,t,p);for(let V=0;V<H.channels;++V){const H=G[V];for(let O=0;O<G[V].size;++O)L(t,H.start+O,H.nx,H.size,H.ny,H.nx*H.size,j)}!function(H,O,S){for(let t=0;t<S;++t)O[t]=H[O[t]]}(a,t,p);let X=0;const E=new Uint8Array(t.buffer.byteLength);for(let o=0;o<H.lines;o++)for(let O=0;O<H.channels;O++){const H=G[O],S=H.nx*H.size,q=new Uint8Array(t.buffer,H.end*V,S*V);E.set(q,X),X+=S*V,H.end+=S}return new DataView(E.buffer)}var pH,GH=S(11131);!function(H){H[H.Float=0]="Float",H[H.HalfFloat=1]="HalfFloat"}(pH||(pH={}));class UH{}async function VH(H,O,S,t){const q={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:S,width:H.dataWindow.xMax-H.dataWindow.xMin+1,height:H.dataWindow.yMax-H.dataWindow.yMin+1,channels:H.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(H.compression){case K.NO_COMPRESSION:q.lines=1,q.uncompress=HH;break;case K.RLE_COMPRESSION:q.lines=1,q.uncompress=OH;break;case K.ZIPS_COMPRESSION:q.lines=1,q.uncompress=SH,await GH.Tools.LoadScriptAsync(UH.FFLATEUrl);break;case K.ZIP_COMPRESSION:q.lines=16,q.uncompress=SH,await GH.Tools.LoadScriptAsync(UH.FFLATEUrl);break;case K.PIZ_COMPRESSION:q.lines=32,q.uncompress=qH;break;case K.PXR24_COMPRESSION:q.lines=16,q.uncompress=tH,await GH.Tools.LoadScriptAsync(UH.FFLATEUrl);break;default:throw new Error(K[H.compression]+" is unsupported")}q.scanlineBlockSize=q.lines;const p={};for(const G of H.channels)switch(G.name){case"R":case"G":case"B":case"A":case"Y":p[G.name]=!0,q.type=G.pixelType}let U=!1;if(p.R&&p.G&&p.B&&p.A)q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G&&p.B)U=!0,q.outputChannels=4,q.decodeChannels={R:0,G:1,B:2,A:3};else if(p.R&&p.G)q.outputChannels=2,q.decodeChannels={R:0,G:1};else if(p.R)q.outputChannels=1,q.decodeChannels={R:0};else{if(!p.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");q.outputChannels=1,q.decodeChannels={Y:0}}if(1===q.type)switch(t){case pH.Float:q.getter=W,q.inputSize=V;break;case pH.HalfFloat:q.getter=v,q.inputSize=V}else{if(2!==q.type)throw new Error("Unsupported pixelType "+q.type+" for "+H.compression);switch(t){case pH.Float:q.getter=r,q.inputSize=G;break;case pH.HalfFloat:q.getter=g,q.inputSize=G}}q.blockCount=q.height/q.scanlineBlockSize;for(let G=0;G<q.blockCount;G++)m(O,S);const w=q.width*q.height*q.outputChannels;switch(t){case pH.Float:q.byteArray=new Float32Array(w),q.textureType=1,U&&q.byteArray.fill(1,0,w);break;case pH.HalfFloat:q.byteArray=new Uint16Array(w),q.textureType=2,U&&q.byteArray.fill(15360,0,w);break;default:throw new Error("Unsupported type: "+t)}let o=0;for(const G of H.channels)void 0!==q.decodeChannels[G.name]&&(q.channelLineOffsets[G.name]=o*q.width),o+=2*G.pixelType;return q.bytesPerLine=q.width*o,q.outLineWidth=q.width*q.outputChannels,"INCREASING_Y"===H.lineOrder?q.scanOrder=H=>H:q.scanOrder=H=>q.height-1-H,4==q.outputChannels?(q.format=5,q.linearSpace=!0):(q.format=6,q.linearSpace=!1),q}function wH(H,O,S,t){const q={value:0};for(let p=0;p<H.height/H.scanlineBlockSize;p++){const G=Y(S,t)-O.dataWindow.yMin;H.size=l(S,t),H.lines=G+H.scanlineBlockSize>H.height?H.height-G:H.scanlineBlockSize;const U=H.size<H.lines*H.bytesPerLine&&H.uncompress?H.uncompress(H):HH(H);t.value+=H.size;for(let S=0;S<H.scanlineBlockSize;S++){const t=p*H.scanlineBlockSize,G=S+H.scanOrder(t);if(G>=H.height)continue;const V=S*H.bytesPerLine,w=(H.height-1-G)*H.outLineWidth;for(let S=0;S<H.channels;S++){const t=O.channels[S].name,p=H.channelLineOffsets[t],G=H.decodeChannels[t];if(void 0!==G){q.value=V+p;for(let O=0;O<H.width;O++){const S=w+O*H.outputChannels+G;H.byteArray&&(H.byteArray[S]=H.getter(U,q))}}}}}}UH.DefaultOutputType=pH.HalfFloat,UH.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class oH{constructor(){this.supportCascades=!1}loadCubeData(H,O,S,t,q){throw".exr not supported in Cube."}loadData(H,O,S){const q=new DataView(H.buffer),p={value:0},G=u(q,p);VH(G,q,p,UH.DefaultOutputType).then((H=>{wH(H,G,q,p);const t=G.dataWindow.xMax-G.dataWindow.xMin+1,U=G.dataWindow.yMax-G.dataWindow.yMin+1;S(t,U,O.generateMipMaps,!1,(()=>{const S=O.getEngine();O.format=G.format,O.type=H.textureType,O.invertY=!1,O._gammaSpace=!G.linearSpace,H.byteArray&&S._uploadDataToTextureDirectly(O,H.byteArray,0,0,void 0,!0)}))})).catch((H=>{t.b.Error("Failed to load EXR texture: ",H)}))}}async function hH(H){const O=new DataView(H),S={value:0},q=u(O,S);try{const H=await VH(q,O,S,pH.Float);return wH(H,q,O,S),H.byteArray?{width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,data:new Float32Array(H.byteArray)}:(t.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(p){t.b.Error("Failed to load EXR data: ",p)}return{width:0,height:0,data:null}}},11317:(H,O,S)=>{function t(H){return parseInt(H.toString().replace(/\W/g,""))}function q(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(H-O)<=S}function p(H,O,S){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return H<O-t||H>S+t}function G(H,O){return H===O?H:Math.random()*(O-H)+H}function U(H,O,S){return H+(O-H)*S}function V(H,O,S){let t=E(O-H,360);return t>180&&(t-=360),H+t*a(S)}function w(H,O,S){let t=0;return t=H!=O?a((S-H)/(O-H)):0,t}function o(H,O,S,t,q){const p=q*q,G=q*p;return H*(2*G-3*p+1)+S*(-2*G+3*p)+O*(G-2*p+q)+t*(G-p)}function h(H,O,S,t,q){const p=q*q;return 6*(p-q)*H+(3*p-4*q+1)*O+6*(-p+q)*S+(3*p-2*q)*t}function a(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(S,Math.max(O,H))}function j(H){return H-=2*Math.PI*Math.floor((H+Math.PI)/(2*Math.PI))}function e(H){const O=H.toString(16);return H<=15?("0"+O).toUpperCase():O.toUpperCase()}function X(H){if(Math.log2)return Math.floor(Math.log2(H));if(H<0)return NaN;if(0===H)return-1/0;let O=0;if(H<1){for(;H<1;)O++,H*=2;O=-O}else if(H>1)for(;H>1;)O++,H=Math.floor(H/2);return O}function E(H,O){return H-Math.floor(H/O)*O}function y(H,O,S){return(H-O)/(S-O)}function T(H,O,S){return H*(S-O)+O}function K(H,O){let S=E(O-H,360);return S>180&&(S-=360),S}function b(H,O){const S=E(H,2*O);return O-Math.abs(S-O)}function D(H,O,S){let t=a(S);return t=-2*t*t*t+3*t*t,O*t+H*(1-t)}function F(H,O,S){let t=0;return t=Math.abs(O-H)<=S?O:H+Math.sign(O-H)*S,t}function Y(H,O,S){const t=K(H,O);let q=0;return q=-S<t&&t<S?O:F(H,O=H+t,S),q}function l(H,O,S){return(H-O)/(S-O)}function d(H,O,S){return(S-O)*H+O}function v(H,O){const S=H%O;return 0===S?O:v(O,S)}S.r(O),S.d(O,{Clamp:()=>a,DeltaAngle:()=>K,Denormalize:()=>T,ExtractAsInt:()=>t,Hermite:()=>o,Hermite1stDerivative:()=>h,HighestCommonFactor:()=>v,ILog2:()=>X,InverseLerp:()=>w,Lerp:()=>U,LerpAngle:()=>V,MoveTowards:()=>F,MoveTowardsAngle:()=>Y,Normalize:()=>y,NormalizeRadians:()=>j,OutsideRange:()=>p,PercentToRange:()=>d,PingPong:()=>b,RandomRange:()=>G,RangeToPercent:()=>l,Repeat:()=>E,SmoothStep:()=>D,ToHex:()=>e,WithinEpsilon:()=>q})}}]);