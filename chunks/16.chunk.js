"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[16],{2593:(W,F,c)=>{function T(W){return Math.floor(W/8)}function Y(W){return 1<<W%8}c.d(F,{OptimizeIndices:()=>w});class Z{constructor(W){this.size=W,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(W){if(W>=this.size)throw new RangeError("Bit index out of range");const F=T(W),c=Y(W);return 0!==(this._byteArray[F]&c)}set(W,F){if(W>=this.size)throw new RangeError("Bit index out of range");const c=T(W),Z=Y(W);F?this._byteArray[c]|=Z:this._byteArray[c]&=~Z}}function w(W){const F=[],c=W.length/3;for(let Z=0;Z<c;Z++)F.push([W[3*Z],W[3*Z+1],W[3*Z+2]]);const T=new Map;for(let Z=0;Z<F.length;Z++){const W=F[Z];for(const F of W){let W=T.get(F);W||T.set(F,W=[]),W.push(Z)}}const Y=new Z(c),w=[],A=W=>{const c=[W];for(;c.length>0;){const W=c.pop();if(!Y.get(W)){Y.set(W,!0),w.push(F[W]);for(const Z of F[W]){const W=T.get(Z);if(!W)return;for(const F of W)Y.get(F)||c.push(F)}}}};for(let Z=0;Z<c;Z++)Y.get(Z)||A(Z);let u=0;for(const Z of w)W[u++]=Z[0],W[u++]=Z[1],W[u++]=Z[2]}}}]);