"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[16],{13726:(F,b,Q)=>{Q.r(b),Q.d(b,{ReadExrDataAsync:()=>KF,_ExrTextureLoader:()=>GF});var C=Q(11146),z=Q(11329);const t=4,g=4,W=1,Z=2,q=8,G=65536,K=G>>3,e=14,N=65537,y=1<<e,E=y-1,c=59,X=63,L=2+X-c;var i,f;!function(F){F[F.NO_COMPRESSION=0]="NO_COMPRESSION",F[F.RLE_COMPRESSION=1]="RLE_COMPRESSION",F[F.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",F[F.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",F[F.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",F[F.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(i||(i={})),function(F){F[F.INCREASING_Y=0]="INCREASING_Y",F[F.DECREASING_Y=1]="DECREASING_Y"}(f||(f={}));const k=function(){const F=new ArrayBuffer(4),b=new Float32Array(F),Q=new Uint32Array(F),C=new Uint32Array(512),z=new Uint32Array(512);for(let Z=0;Z<256;++Z){const F=Z-127;F<-27?(C[Z]=0,C[256|Z]=32768,z[Z]=24,z[256|Z]=24):F<-14?(C[Z]=1024>>-F-14,C[256|Z]=1024>>-F-14|32768,z[Z]=-F-1,z[256|Z]=-F-1):F<=15?(C[Z]=F+15<<10,C[256|Z]=F+15<<10|32768,z[Z]=13,z[256|Z]=13):F<128?(C[Z]=31744,C[256|Z]=64512,z[Z]=24,z[256|Z]=24):(C[Z]=31744,C[256|Z]=64512,z[Z]=13,z[256|Z]=13)}const t=new Uint32Array(2048),g=new Uint32Array(64),W=new Uint32Array(64);for(let Z=1;Z<1024;++Z){let F=Z<<13,b=0;for(;0===(8388608&F);)F<<=1,b-=8388608;F&=-8388609,b+=947912704,t[Z]=F|b}for(let Z=1024;Z<2048;++Z)t[Z]=939524096+(Z-1024<<13);for(let Z=1;Z<31;++Z)g[Z]=Z<<23;g[31]=1199570944,g[32]=2147483648;for(let Z=33;Z<63;++Z)g[Z]=2147483648+(Z-32<<23);g[63]=3347054592;for(let Z=1;Z<64;++Z)32!==Z&&(W[Z]=1024);return{floatView:b,uint32View:Q,baseTable:C,shiftTable:z,mantissaTable:t,exponentTable:g,offsetTable:W}}();function m(F,b){const Q=new Uint8Array(F);let C=0;for(;0!=Q[b.value+C];)C+=1;const z=(new TextDecoder).decode(Q.slice(b.value,b.value+C));return b.value=b.value+C+1,z}function R(F,b){const Q=F.getInt32(b.value,!0);return b.value+=t,Q}function p(F,b){const Q=F.getUint32(b.value,!0);return b.value+=t,Q}function D(F,b){const Q=F.getUint8(b.value);return b.value+=W,Q}function P(F,b){const Q=F.getUint16(b.value,!0);return b.value+=Z,Q}function n(F,b){const Q=F[b.value];return b.value+=W,Q}function j(F,b){let Q;return Q="getBigInt64"in DataView.prototype?Number(F.getBigInt64(b.value,!0)):F.getUint32(b.value+4,!0)+Number(F.getUint32(b.value,!0)<<32),b.value+=q,Q}function w(F,b){const Q=F.getFloat32(b.value,!0);return b.value+=g,Q}function Y(F,b){return function(F){const b=(31744&F)>>10,Q=1023&F;return(F>>15?-1:1)*(b?31===b?Q?NaN:1/0:Math.pow(2,b-15)*(1+Q/1024):Q/1024*6103515625e-14)}(P(F,b))}function s(F,b){return function(F){if(Math.abs(F)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");F=(0,z.Clamp)(F,-65504,65504),k.floatView[0]=F;const b=k.uint32View[0],Q=b>>23&511;return k.baseTable[Q]+((8388607&b)>>k.shiftTable[Q])}(w(F,b))}function V(F,b,Q,C){switch(Q){case"string":case"stringvector":case"iccProfile":return function(F,b,Q){const C=(new TextDecoder).decode(new Uint8Array(F).slice(b.value,b.value+Q));return b.value=b.value+Q,C}(F.buffer,b,C);case"chlist":return function(F,b,Q){const C=b.value,z=[];for(;b.value<C+Q-1;){const Q=m(F.buffer,b),C=R(F,b),t=D(F,b);b.value+=3;const g=R(F,b),W=R(F,b);z.push({name:Q,pixelType:C,pLinear:t,xSampling:g,ySampling:W})}return b.value+=1,z}(F,b,C);case"chromaticities":return function(F,b){return{redX:w(F,b),redY:w(F,b),greenX:w(F,b),greenY:w(F,b),blueX:w(F,b),blueY:w(F,b),whiteX:w(F,b),whiteY:w(F,b)}}(F,b);case"compression":return function(F,b){return D(F,b)}(F,b);case"box2i":return function(F,b){return{xMin:R(F,b),yMin:R(F,b),xMax:R(F,b),yMax:R(F,b)}}(F,b);case"lineOrder":return function(F,b){const Q=D(F,b);return f[Q]}(F,b);case"float":return w(F,b);case"v2f":return function(F,b){return[w(F,b),w(F,b)]}(F,b);case"v3f":return function(F,b){return[w(F,b),w(F,b),w(F,b)]}(F,b);case"int":return R(F,b);case"rational":return function(F,b){return[R(F,b),p(F,b)]}(F,b);case"timecode":return function(F,b){return[p(F,b),p(F,b)]}(F,b);case"preview":return b.value+=C,"skipped";default:return void(b.value+=C)}}function h(F){for(let b=1;b<F.length;b++){const Q=F[b-1]+F[b]-128;F[b]=Q}}function l(F,b){let Q=0,C=Math.floor((F.length+1)/2),z=0;const t=F.length-1;for(;!(z>t)&&(b[z++]=F[Q++],!(z>t));)b[z++]=F[C++]}const T=20000630;function o(F,b){if(F.getUint32(0,!0)!=T)throw new Error("Incorrect OpenEXR format");const Q=F.getUint8(4),z=F.getUint8(5),t={singleTile:!!(2&z),longName:!!(4&z),deepFormat:!!(8&z),multiPart:!!(16&z)};b.value=8;const g={};let W=!0;for(;W;){const Q=m(F.buffer,b);if(Q){const z=m(F.buffer,b),t=V(F,b,z,p(F,b));void 0===t?C.e.Warn(`Unknown header attribute type ${z}'.`):g[Q]=t}else W=!1}if(0!=(-5&z))throw new Error("Unsupported file format");return{version:Q,spec:t,...g}}const S=32768,O=65535;function x(F,b,Q,C,z){for(;Q<F;)b=b<<8|n(C,z),Q+=8;return{l:b>>(Q-=F)&(1<<F)-1,c:b,lc:Q}}function a(F,b,Q,C){return{c:F=F<<8|n(Q,C),lc:b+=8}}function A(F,b,Q,C,z,t,g,W,Z){if(F==b){if(C<8){const F=a(Q,C,z,t);Q=F.c,C=F.lc}let F=Q>>(C-=8);if(F=new Uint8Array([F])[0],W.value+F>Z)return null;const b=g[W.value-1];for(;F-- >0;)g[W.value++]=b}else{if(!(W.value<Z))return null;g[W.value++]=F}return{c:Q,lc:C}}const U=new Array(59);function u(F,b,Q,C,z,t){const g=b;let W=0,Z=0;for(;C<=z;C++){if(g.value-b.value>Q)return;let q=x(6,W,Z,F,g);const G=q.l;if(W=q.c,Z=q.lc,t[C]=G,G==X){if(g.value-b.value>Q)throw new Error("Error in HufUnpackEncTable");q=x(8,W,Z,F,g);let G=q.l+L;if(W=q.c,Z=q.lc,C+G>z+1)throw new Error("Error in HufUnpackEncTable");for(;G--;)t[C++]=0;C--}else if(G>=c){let F=G-c+2;if(C+F>z+1)throw new Error("Error in HufUnpackEncTable");for(;F--;)t[C++]=0;C--}}!function(F){for(let Q=0;Q<=58;++Q)U[Q]=0;for(let Q=0;Q<N;++Q)U[F[Q]]+=1;let b=0;for(let Q=58;Q>0;--Q){const F=b+U[Q]>>1;U[Q]=b,b=F}for(let Q=0;Q<N;++Q){const b=F[Q];b>0&&(F[Q]=b|U[b]++<<6)}}(t)}function v(F){return 63&F}function J(F){return F>>6}function I(F,b,Q,C,z,t){const g=Q.value,W=p(b,Q),Z=p(b,Q);Q.value+=4;const q=p(b,Q);if(Q.value+=4,W<0||W>=N||Z<0||Z>=N)throw new Error("Wrong HUF_ENCSIZE");const G=new Array(N),K=new Array(y);!function(F){for(let b=0;b<y;b++)F[b]={},F[b].len=0,F[b].lit=0,F[b].p=null}(K);if(u(F,Q,C-(Q.value-g),W,Z,G),q>8*(C-(Q.value-g)))throw new Error("Wrong hufUncompress");!function(F,b,Q,C){for(;b<=Q;b++){const Q=J(F[b]),z=v(F[b]);if(Q>>z)throw new Error("Invalid table entry");if(z>e){const F=C[Q>>z-e];if(F.len)throw new Error("Invalid table entry");if(F.lit++,F.p){const b=F.p;F.p=new Array(F.lit);for(let Q=0;Q<F.lit-1;++Q)F.p[Q]=b[Q]}else F.p=new Array(1);F.p[F.lit-1]=b}else if(z){let F=0;for(let t=1<<e-z;t>0;t--){const t=C[(Q<<e-z)+F];if(t.len||t.p)throw new Error("Invalid table entry");t.len=z,t.lit=b,F++}}}}(G,W,Z,K),function(F,b,Q,C,z,t,g,W,Z){let q=0,G=0;const K=g,N=Math.trunc(C.value+(z+7)/8);for(;C.value<N;){let z=a(q,G,Q,C);for(q=z.c,G=z.lc;G>=e;){const g=b[q>>G-e&E];if(g.len){G-=g.len;const F=A(g.lit,t,q,G,Q,C,W,Z,K);F&&(q=F.c,G=F.lc)}else{if(!g.p)throw new Error("hufDecode issues");let b;for(b=0;b<g.lit;b++){const e=v(F[g.p[b]]);for(;G<e&&C.value<N;)z=a(q,G,Q,C),q=z.c,G=z.lc;if(G>=e&&J(F[g.p[b]])==(q>>G-e&(1<<e)-1)){G-=e;const F=A(g.p[b],t,q,G,Q,C,W,Z,K);F&&(q=F.c,G=F.lc);break}}if(b==g.lit)throw new Error("HufDecode issues")}}}const y=8-z&7;for(q>>=y,G-=y;G>0;){const F=b[q<<e-G&E];if(!F.len)throw new Error("HufDecode issues");{G-=F.len;const b=A(F.lit,t,q,G,Q,C,W,Z,K);b&&(q=b.c,G=b.lc)}}}(G,K,F,Q,q,Z,t,z,{value:0})}function M(F){return 65535&F}function r(F){const b=M(F);return b>32767?b-65536:b}function H(F,b){const Q=r(F),C=r(b),z=Q+(1&C)+(C>>1);return{a:z,b:z-C}}function B(F,b){const Q=M(F),C=M(b),z=Q-(C>>1)&O;return{a:C+z-S&O,b:z}}function d(F,b,Q,C,z,t,g){const W=g<16384,Z=Q>z?z:Q;let q,G,K=1;for(;K<=Z;)K<<=1;for(K>>=1,q=K,K>>=1;K>=1;){G=0;const g=G+t*(z-q),Z=t*K,e=t*q,N=C*K,y=C*q;let E,c,X,L;for(;G<=g;G+=e){let z=G;const t=G+C*(Q-q);for(;z<=t;z+=y){const Q=z+N,C=z+Z,t=C+N;if(W){let g=H(F[z+b],F[C+b]);E=g.a,X=g.b,g=H(F[Q+b],F[t+b]),c=g.a,L=g.b,g=H(E,c),F[z+b]=g.a,F[Q+b]=g.b,g=H(X,L),F[C+b]=g.a,F[t+b]=g.b}else{let g=B(F[z+b],F[C+b]);E=g.a,X=g.b,g=B(F[Q+b],F[t+b]),c=g.a,L=g.b,g=B(E,c),F[z+b]=g.a,F[Q+b]=g.b,g=B(X,L),F[C+b]=g.a,F[t+b]=g.b}}if(Q&K){const Q=z+Z;let C;C=W?H(F[z+b],F[Q+b]):B(F[z+b],F[Q+b]),E=C.a,F[Q+b]=C.b,F[z+b]=E}}if(z&K){let z=G;const t=G+C*(Q-q);for(;z<=t;z+=y){const Q=z+N;let C;C=W?H(F[z+b],F[Q+b]):B(F[z+b],F[Q+b]),E=C.a,F[Q+b]=C.b,F[z+b]=E}}q=K,K>>=1}return G}function FF(F){return new DataView(F.array.buffer,F.offset.value,F.size)}function bF(F){const b=F.viewer.buffer.slice(F.offset.value,F.offset.value+F.size),Q=new Uint8Array(function(F){let b=F.byteLength;const Q=[];let C=0;const z=new DataView(F);for(;b>0;){const F=z.getInt8(C++);if(F<0){const t=-F;b-=t+1;for(let F=0;F<t;F++)Q.push(z.getUint8(C++))}else{const t=F;b-=2;const g=z.getUint8(C++);for(let F=0;F<t+1;F++)Q.push(g)}}return Q}(b)),C=new Uint8Array(Q.length);return h(Q),l(Q,C),new DataView(C.buffer)}function QF(F){const b=F.array.slice(F.offset.value,F.offset.value+F.size),Q=fflate.unzlibSync(b),C=new Uint8Array(Q.length);return h(Q),l(Q,C),new DataView(C.buffer)}function CF(F){const b=F.array.slice(F.offset.value,F.offset.value+F.size),Q=fflate.unzlibSync(b),C=F.lines*F.channels*F.width,z=1==F.type?new Uint16Array(C):new Uint32Array(C);let t=0,g=0;const W=new Array(4);for(let Z=0;Z<F.lines;Z++)for(let b=0;b<F.channels;b++){let b=0;switch(F.type){case 1:W[0]=t,W[1]=W[0]+F.width,t=W[1]+F.width;for(let C=0;C<F.width;++C){b+=Q[W[0]++]<<8|Q[W[1]++],z[g]=b,g++}break;case 2:W[0]=t,W[1]=W[0]+F.width,W[2]=W[1]+F.width,t=W[2]+F.width;for(let C=0;C<F.width;++C){b+=Q[W[0]++]<<24|Q[W[1]++]<<16|Q[W[2]++]<<8,z[g]=b,g++}}}return new DataView(z.buffer)}function zF(F){const b=F.viewer,Q={value:F.offset.value},C=new Uint16Array(F.width*F.scanlineBlockSize*(F.channels*F.type)),z=new Uint8Array(K);let t=0;const g=new Array(F.channels);for(let Z=0;Z<F.channels;Z++)g[Z]={},g[Z].start=t,g[Z].end=g[Z].start,g[Z].nx=F.width,g[Z].ny=F.lines,g[Z].size=F.type,t+=g[Z].nx*g[Z].ny*g[Z].size;const W=P(b,Q),q=P(b,Q);if(q>=K)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(W<=q)for(let Z=0;Z<q-W+1;Z++)z[Z+W]=D(b,Q);const e=new Uint16Array(G),N=function(F,b){let Q=0;for(let z=0;z<G;++z)(0==z||F[z>>3]&1<<(7&z))&&(b[Q++]=z);const C=Q-1;for(;Q<G;)b[Q++]=0;return C}(z,e),y=p(b,Q);I(F.array,b,Q,y,C,t);for(let Z=0;Z<F.channels;++Z){const F=g[Z];for(let b=0;b<g[Z].size;++b)d(C,F.start+b,F.nx,F.size,F.ny,F.nx*F.size,N)}!function(F,b,Q){for(let C=0;C<Q;++C)b[C]=F[b[C]]}(e,C,t);let E=0;const c=new Uint8Array(C.buffer.byteLength);for(let G=0;G<F.lines;G++)for(let b=0;b<F.channels;b++){const F=g[b],Q=F.nx*F.size,z=new Uint8Array(C.buffer,F.end*Z,Q*Z);c.set(z,E),E+=Q*Z,F.end+=Q}return new DataView(c.buffer)}var tF,gF=Q(11128);!function(F){F[F.Float=0]="Float",F[F.HalfFloat=1]="HalfFloat"}(tF||(tF={}));class WF{}async function ZF(F,b,Q,C){const z={size:0,viewer:b,array:new Uint8Array(b.buffer),offset:Q,width:F.dataWindow.xMax-F.dataWindow.xMin+1,height:F.dataWindow.yMax-F.dataWindow.yMin+1,channels:F.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(F.compression){case i.NO_COMPRESSION:z.lines=1,z.uncompress=FF;break;case i.RLE_COMPRESSION:z.lines=1,z.uncompress=bF;break;case i.ZIPS_COMPRESSION:z.lines=1,z.uncompress=QF,await gF.Tools.LoadScriptAsync(WF.FFLATEUrl);break;case i.ZIP_COMPRESSION:z.lines=16,z.uncompress=QF,await gF.Tools.LoadScriptAsync(WF.FFLATEUrl);break;case i.PIZ_COMPRESSION:z.lines=32,z.uncompress=zF;break;case i.PXR24_COMPRESSION:z.lines=16,z.uncompress=CF,await gF.Tools.LoadScriptAsync(WF.FFLATEUrl);break;default:throw new Error(i[F.compression]+" is unsupported")}z.scanlineBlockSize=z.lines;const t={};for(const g of F.channels)switch(g.name){case"R":case"G":case"B":case"A":case"Y":t[g.name]=!0,z.type=g.pixelType}let W=!1;if(t.R&&t.G&&t.B&&t.A)z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else if(t.R&&t.G&&t.B)W=!0,z.outputChannels=4,z.decodeChannels={R:0,G:1,B:2,A:3};else if(t.R&&t.G)z.outputChannels=2,z.decodeChannels={R:0,G:1};else if(t.R)z.outputChannels=1,z.decodeChannels={R:0};else{if(!t.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");z.outputChannels=1,z.decodeChannels={Y:0}}if(1===z.type)switch(C){case tF.Float:z.getter=Y,z.inputSize=Z;break;case tF.HalfFloat:z.getter=P,z.inputSize=Z}else{if(2!==z.type)throw new Error("Unsupported pixelType "+z.type+" for "+F.compression);switch(C){case tF.Float:z.getter=w,z.inputSize=g;break;case tF.HalfFloat:z.getter=s,z.inputSize=g}}z.blockCount=z.height/z.scanlineBlockSize;for(let g=0;g<z.blockCount;g++)j(b,Q);const q=z.width*z.height*z.outputChannels;switch(C){case tF.Float:z.byteArray=new Float32Array(q),z.textureType=1,W&&z.byteArray.fill(1,0,q);break;case tF.HalfFloat:z.byteArray=new Uint16Array(q),z.textureType=2,W&&z.byteArray.fill(15360,0,q);break;default:throw new Error("Unsupported type: "+C)}let G=0;for(const g of F.channels)void 0!==z.decodeChannels[g.name]&&(z.channelLineOffsets[g.name]=G*z.width),G+=2*g.pixelType;return z.bytesPerLine=z.width*G,z.outLineWidth=z.width*z.outputChannels,"INCREASING_Y"===F.lineOrder?z.scanOrder=F=>F:z.scanOrder=F=>z.height-1-F,4==z.outputChannels?(z.format=5,z.linearSpace=!0):(z.format=6,z.linearSpace=!1),z}function qF(F,b,Q,C){const z={value:0};for(let t=0;t<F.height/F.scanlineBlockSize;t++){const g=R(Q,C)-b.dataWindow.yMin;F.size=p(Q,C),F.lines=g+F.scanlineBlockSize>F.height?F.height-g:F.scanlineBlockSize;const W=F.size<F.lines*F.bytesPerLine&&F.uncompress?F.uncompress(F):FF(F);C.value+=F.size;for(let Q=0;Q<F.scanlineBlockSize;Q++){const C=t*F.scanlineBlockSize,g=Q+F.scanOrder(C);if(g>=F.height)continue;const Z=Q*F.bytesPerLine,q=(F.height-1-g)*F.outLineWidth;for(let Q=0;Q<F.channels;Q++){const C=b.channels[Q].name,t=F.channelLineOffsets[C],g=F.decodeChannels[C];if(void 0!==g){z.value=Z+t;for(let b=0;b<F.width;b++){const Q=q+b*F.outputChannels+g;F.byteArray&&(F.byteArray[Q]=F.getter(W,z))}}}}}}WF.DefaultOutputType=tF.HalfFloat,WF.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class GF{constructor(){this.supportCascades=!1}loadCubeData(F,b,Q,C,z){throw".exr not supported in Cube."}loadData(F,b,Q){const z=new DataView(F.buffer),t={value:0},g=o(z,t);ZF(g,z,t,WF.DefaultOutputType).then((F=>{qF(F,g,z,t);const C=g.dataWindow.xMax-g.dataWindow.xMin+1,W=g.dataWindow.yMax-g.dataWindow.yMin+1;Q(C,W,b.generateMipMaps,!1,(()=>{const Q=b.getEngine();b.format=g.format,b.type=F.textureType,b.invertY=!1,b._gammaSpace=!g.linearSpace,F.byteArray&&Q._uploadDataToTextureDirectly(b,F.byteArray,0,0,void 0,!0)}))})).catch((F=>{C.e.Error("Failed to load EXR texture: ",F)}))}}async function KF(F){const b=new DataView(F),Q={value:0},z=o(b,Q);try{const F=await ZF(z,b,Q,tF.Float);return qF(F,z,b,Q),F.byteArray?{width:z.dataWindow.xMax-z.dataWindow.xMin+1,height:z.dataWindow.yMax-z.dataWindow.yMin+1,data:new Float32Array(F.byteArray)}:(C.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(t){C.e.Error("Failed to load EXR data: ",t)}return{width:0,height:0,data:null}}},11329:(F,b,Q)=>{function C(F){return parseInt(F.toString().replace(/\W/g,""))}function z(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(F-b)<=Q}function t(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return F<b-C||F>Q+C}function g(F,b){return F===b?F:Math.random()*(b-F)+F}function W(F,b,Q){return F+(b-F)*Q}function Z(F,b,Q){let C=c(b-F,360);return C>180&&(C-=360),F+C*e(Q)}function q(F,b,Q){let C=0;return C=F!=b?e((Q-F)/(b-F)):0,C}function G(F,b,Q,C,z){const t=z*z,g=z*t;return F*(2*g-3*t+1)+Q*(-2*g+3*t)+b*(g-2*t+z)+C*(g-t)}function K(F,b,Q,C,z){const t=z*z;return 6*(t-z)*F+(3*t-4*z+1)*b+6*(-t+z)*Q+(3*t-2*z)*C}function e(F){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(Q,Math.max(b,F))}function N(F){return F-=2*Math.PI*Math.floor((F+Math.PI)/(2*Math.PI))}function y(F){const b=F.toString(16);return F<=15?("0"+b).toUpperCase():b.toUpperCase()}function E(F){if(Math.log2)return Math.floor(Math.log2(F));if(F<0)return NaN;if(0===F)return-1/0;let b=0;if(F<1){for(;F<1;)b++,F*=2;b=-b}else if(F>1)for(;F>1;)b++,F=Math.floor(F/2);return b}function c(F,b){return F-Math.floor(F/b)*b}function X(F,b,Q){return(F-b)/(Q-b)}function L(F,b,Q){return F*(Q-b)+b}function i(F,b){let Q=c(b-F,360);return Q>180&&(Q-=360),Q}function f(F,b){const Q=c(F,2*b);return b-Math.abs(Q-b)}function k(F,b,Q){let C=e(Q);return C=-2*C*C*C+3*C*C,b*C+F*(1-C)}function m(F,b,Q){let C=0;return C=Math.abs(b-F)<=Q?b:F+Math.sign(b-F)*Q,C}function R(F,b,Q){const C=i(F,b);let z=0;return z=-Q<C&&C<Q?b:m(F,b=F+C,Q),z}function p(F,b,Q){return(F-b)/(Q-b)}function D(F,b,Q){return(Q-b)*F+b}function P(F,b){const Q=F%b;return 0===Q?b:P(b,Q)}Q.r(b),Q.d(b,{Clamp:()=>e,DeltaAngle:()=>i,Denormalize:()=>L,ExtractAsInt:()=>C,Hermite:()=>G,Hermite1stDerivative:()=>K,HighestCommonFactor:()=>P,ILog2:()=>E,InverseLerp:()=>q,Lerp:()=>W,LerpAngle:()=>Z,MoveTowards:()=>m,MoveTowardsAngle:()=>R,Normalize:()=>X,NormalizeRadians:()=>N,OutsideRange:()=>t,PercentToRange:()=>D,PingPong:()=>f,RandomRange:()=>g,RangeToPercent:()=>p,Repeat:()=>c,SmoothStep:()=>k,ToHex:()=>y,WithinEpsilon:()=>z})}}]);