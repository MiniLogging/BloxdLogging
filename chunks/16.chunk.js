"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[16],{14070:(F,P,f)=>{f.r(P),f.d(P,{ReadExrDataAsync:()=>uF,_ExrTextureLoader:()=>iF});var c=f(11474),N=f(11664);const q=4,H=4,A=1,o=2,j=8,i=65536,u=i>>3,T=14,Y=65537,t=1<<T,C=t-1,L=59,J=63,B=2+J-L;var z,Z;!function(F){F[F.NO_COMPRESSION=0]="NO_COMPRESSION",F[F.RLE_COMPRESSION=1]="RLE_COMPRESSION",F[F.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",F[F.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",F[F.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",F[F.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(z||(z={})),function(F){F[F.INCREASING_Y=0]="INCREASING_Y",F[F.DECREASING_Y=1]="DECREASING_Y"}(Z||(Z={}));const R=function(){const F=new ArrayBuffer(4),P=new Float32Array(F),f=new Uint32Array(F),c=new Uint32Array(512),N=new Uint32Array(512);for(let o=0;o<256;++o){const F=o-127;F<-27?(c[o]=0,c[256|o]=32768,N[o]=24,N[256|o]=24):F<-14?(c[o]=1024>>-F-14,c[256|o]=1024>>-F-14|32768,N[o]=-F-1,N[256|o]=-F-1):F<=15?(c[o]=F+15<<10,c[256|o]=F+15<<10|32768,N[o]=13,N[256|o]=13):F<128?(c[o]=31744,c[256|o]=64512,N[o]=24,N[256|o]=24):(c[o]=31744,c[256|o]=64512,N[o]=13,N[256|o]=13)}const q=new Uint32Array(2048),H=new Uint32Array(64),A=new Uint32Array(64);for(let o=1;o<1024;++o){let F=o<<13,P=0;for(;0===(8388608&F);)F<<=1,P-=8388608;F&=-8388609,P+=947912704,q[o]=F|P}for(let o=1024;o<2048;++o)q[o]=939524096+(o-1024<<13);for(let o=1;o<31;++o)H[o]=o<<23;H[31]=1199570944,H[32]=2147483648;for(let o=33;o<63;++o)H[o]=2147483648+(o-32<<23);H[63]=3347054592;for(let o=1;o<64;++o)32!==o&&(A[o]=1024);return{floatView:P,uint32View:f,baseTable:c,shiftTable:N,mantissaTable:q,exponentTable:H,offsetTable:A}}();function y(F,P){const f=new Uint8Array(F);let c=0;for(;0!=f[P.value+c];)c+=1;const N=(new TextDecoder).decode(f.slice(P.value,P.value+c));return P.value=P.value+c+1,N}function O(F,P){const f=F.getInt32(P.value,!0);return P.value+=q,f}function d(F,P){const f=F.getUint32(P.value,!0);return P.value+=q,f}function M(F,P){const f=F.getUint8(P.value);return P.value+=A,f}function V(F,P){const f=F.getUint16(P.value,!0);return P.value+=o,f}function Q(F,P){const f=F[P.value];return P.value+=A,f}function K(F,P){let f;return f="getBigInt64"in DataView.prototype?Number(F.getBigInt64(P.value,!0)):F.getUint32(P.value+4,!0)+Number(F.getUint32(P.value,!0)<<32),P.value+=j,f}function x(F,P){const f=F.getFloat32(P.value,!0);return P.value+=H,f}function k(F,P){return function(F){const P=(31744&F)>>10,f=1023&F;return(F>>15?-1:1)*(P?31===P?f?NaN:1/0:Math.pow(2,P-15)*(1+f/1024):f/1024*6103515625e-14)}(V(F,P))}function I(F,P){return function(F){if(Math.abs(F)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");F=(0,N.Clamp)(F,-65504,65504),R.floatView[0]=F;const P=R.uint32View[0],f=P>>23&511;return R.baseTable[f]+((8388607&P)>>R.shiftTable[f])}(x(F,P))}function E(F,P,f,c){switch(f){case"string":case"stringvector":case"iccProfile":return function(F,P,f){const c=(new TextDecoder).decode(new Uint8Array(F).slice(P.value,P.value+f));return P.value=P.value+f,c}(F.buffer,P,c);case"chlist":return function(F,P,f){const c=P.value,N=[];for(;P.value<c+f-1;){const f=y(F.buffer,P),c=O(F,P),q=M(F,P);P.value+=3;const H=O(F,P),A=O(F,P);N.push({name:f,pixelType:c,pLinear:q,xSampling:H,ySampling:A})}return P.value+=1,N}(F,P,c);case"chromaticities":return function(F,P){return{redX:x(F,P),redY:x(F,P),greenX:x(F,P),greenY:x(F,P),blueX:x(F,P),blueY:x(F,P),whiteX:x(F,P),whiteY:x(F,P)}}(F,P);case"compression":return function(F,P){return M(F,P)}(F,P);case"box2i":return function(F,P){return{xMin:O(F,P),yMin:O(F,P),xMax:O(F,P),yMax:O(F,P)}}(F,P);case"lineOrder":return function(F,P){const f=M(F,P);return Z[f]}(F,P);case"float":return x(F,P);case"v2f":return function(F,P){return[x(F,P),x(F,P)]}(F,P);case"v3f":return function(F,P){return[x(F,P),x(F,P),x(F,P)]}(F,P);case"int":return O(F,P);case"rational":return function(F,P){return[O(F,P),d(F,P)]}(F,P);case"timecode":return function(F,P){return[d(F,P),d(F,P)]}(F,P);case"preview":return P.value+=c,"skipped";default:return void(P.value+=c)}}function r(F){for(let P=1;P<F.length;P++){const f=F[P-1]+F[P]-128;F[P]=f}}function n(F,P){let f=0,c=Math.floor((F.length+1)/2),N=0;const q=F.length-1;for(;!(N>q)&&(P[N++]=F[f++],!(N>q));)P[N++]=F[c++]}const p=20000630;function U(F,P){if(F.getUint32(0,!0)!=p)throw new Error("Incorrect OpenEXR format");const f=F.getUint8(4),N=F.getUint8(5),q={singleTile:!!(2&N),longName:!!(4&N),deepFormat:!!(8&N),multiPart:!!(16&N)};P.value=8;const H={};let A=!0;for(;A;){const f=y(F.buffer,P);if(f){const N=y(F.buffer,P),q=E(F,P,N,d(F,P));void 0===q?c.d.Warn(`Unknown header attribute type ${N}'.`):H[f]=q}else A=!1}if(0!=(-5&N))throw new Error("Unsupported file format");return{version:f,spec:q,...H}}const e=32768,D=65535;function l(F,P,f,c,N){for(;f<F;)P=P<<8|Q(c,N),f+=8;return{l:P>>(f-=F)&(1<<F)-1,c:P,lc:f}}function W(F,P,f,c){return{c:F=F<<8|Q(f,c),lc:P+=8}}function b(F,P,f,c,N,q,H,A,o){if(F==P){if(c<8){const F=W(f,c,N,q);f=F.c,c=F.lc}let F=f>>(c-=8);if(F=new Uint8Array([F])[0],A.value+F>o)return null;const P=H[A.value-1];for(;F-- >0;)H[A.value++]=P}else{if(!(A.value<o))return null;H[A.value++]=F}return{c:f,lc:c}}const v=new Array(59);function s(F,P,f,c,N,q){const H=P;let A=0,o=0;for(;c<=N;c++){if(H.value-P.value>f)return;let j=l(6,A,o,F,H);const i=j.l;if(A=j.c,o=j.lc,q[c]=i,i==J){if(H.value-P.value>f)throw new Error("Error in HufUnpackEncTable");j=l(8,A,o,F,H);let i=j.l+B;if(A=j.c,o=j.lc,c+i>N+1)throw new Error("Error in HufUnpackEncTable");for(;i--;)q[c++]=0;c--}else if(i>=L){let F=i-L+2;if(c+F>N+1)throw new Error("Error in HufUnpackEncTable");for(;F--;)q[c++]=0;c--}}!function(F){for(let f=0;f<=58;++f)v[f]=0;for(let f=0;f<Y;++f)v[F[f]]+=1;let P=0;for(let f=58;f>0;--f){const F=P+v[f]>>1;v[f]=P,P=F}for(let f=0;f<Y;++f){const P=F[f];P>0&&(F[f]=P|v[P]++<<6)}}(q)}function X(F){return 63&F}function m(F){return F>>6}function a(F,P,f,c,N,q){const H=f.value,A=d(P,f),o=d(P,f);f.value+=4;const j=d(P,f);if(f.value+=4,A<0||A>=Y||o<0||o>=Y)throw new Error("Wrong HUF_ENCSIZE");const i=new Array(Y),u=new Array(t);!function(F){for(let P=0;P<t;P++)F[P]={},F[P].len=0,F[P].lit=0,F[P].p=null}(u);if(s(F,f,c-(f.value-H),A,o,i),j>8*(c-(f.value-H)))throw new Error("Wrong hufUncompress");!function(F,P,f,c){for(;P<=f;P++){const f=m(F[P]),N=X(F[P]);if(f>>N)throw new Error("Invalid table entry");if(N>T){const F=c[f>>N-T];if(F.len)throw new Error("Invalid table entry");if(F.lit++,F.p){const P=F.p;F.p=new Array(F.lit);for(let f=0;f<F.lit-1;++f)F.p[f]=P[f]}else F.p=new Array(1);F.p[F.lit-1]=P}else if(N){let F=0;for(let q=1<<T-N;q>0;q--){const q=c[(f<<T-N)+F];if(q.len||q.p)throw new Error("Invalid table entry");q.len=N,q.lit=P,F++}}}}(i,A,o,u),function(F,P,f,c,N,q,H,A,o){let j=0,i=0;const u=H,Y=Math.trunc(c.value+(N+7)/8);for(;c.value<Y;){let N=W(j,i,f,c);for(j=N.c,i=N.lc;i>=T;){const H=P[j>>i-T&C];if(H.len){i-=H.len;const F=b(H.lit,q,j,i,f,c,A,o,u);F&&(j=F.c,i=F.lc)}else{if(!H.p)throw new Error("hufDecode issues");let P;for(P=0;P<H.lit;P++){const T=X(F[H.p[P]]);for(;i<T&&c.value<Y;)N=W(j,i,f,c),j=N.c,i=N.lc;if(i>=T&&m(F[H.p[P]])==(j>>i-T&(1<<T)-1)){i-=T;const F=b(H.p[P],q,j,i,f,c,A,o,u);F&&(j=F.c,i=F.lc);break}}if(P==H.lit)throw new Error("HufDecode issues")}}}const t=8-N&7;for(j>>=t,i-=t;i>0;){const F=P[j<<T-i&C];if(!F.len)throw new Error("HufDecode issues");{i-=F.len;const P=b(F.lit,q,j,i,f,c,A,o,u);P&&(j=P.c,i=P.lc)}}}(i,u,F,f,j,o,q,N,{value:0})}function w(F){return 65535&F}function g(F){const P=w(F);return P>32767?P-65536:P}function G(F,P){const f=g(F),c=g(P),N=f+(1&c)+(c>>1);return{a:N,b:N-c}}function h(F,P){const f=w(F),c=w(P),N=f-(c>>1)&D;return{a:c+N-e&D,b:N}}function S(F,P,f,c,N,q,H){const A=H<16384,o=f>N?N:f;let j,i,u=1;for(;u<=o;)u<<=1;for(u>>=1,j=u,u>>=1;u>=1;){i=0;const H=i+q*(N-j),o=q*u,T=q*j,Y=c*u,t=c*j;let C,L,J,B;for(;i<=H;i+=T){let N=i;const q=i+c*(f-j);for(;N<=q;N+=t){const f=N+Y,c=N+o,q=c+Y;if(A){let H=G(F[N+P],F[c+P]);C=H.a,J=H.b,H=G(F[f+P],F[q+P]),L=H.a,B=H.b,H=G(C,L),F[N+P]=H.a,F[f+P]=H.b,H=G(J,B),F[c+P]=H.a,F[q+P]=H.b}else{let H=h(F[N+P],F[c+P]);C=H.a,J=H.b,H=h(F[f+P],F[q+P]),L=H.a,B=H.b,H=h(C,L),F[N+P]=H.a,F[f+P]=H.b,H=h(J,B),F[c+P]=H.a,F[q+P]=H.b}}if(f&u){const f=N+o;let c;c=A?G(F[N+P],F[f+P]):h(F[N+P],F[f+P]),C=c.a,F[f+P]=c.b,F[N+P]=C}}if(N&u){let N=i;const q=i+c*(f-j);for(;N<=q;N+=t){const f=N+Y;let c;c=A?G(F[N+P],F[f+P]):h(F[N+P],F[f+P]),C=c.a,F[f+P]=c.b,F[N+P]=C}}j=u,u>>=1}return i}function FF(F){return new DataView(F.array.buffer,F.offset.value,F.size)}function PF(F){const P=F.viewer.buffer.slice(F.offset.value,F.offset.value+F.size),f=new Uint8Array(function(F){let P=F.byteLength;const f=[];let c=0;const N=new DataView(F);for(;P>0;){const F=N.getInt8(c++);if(F<0){const q=-F;P-=q+1;for(let F=0;F<q;F++)f.push(N.getUint8(c++))}else{const q=F;P-=2;const H=N.getUint8(c++);for(let F=0;F<q+1;F++)f.push(H)}}return f}(P)),c=new Uint8Array(f.length);return r(f),n(f,c),new DataView(c.buffer)}function fF(F){const P=F.array.slice(F.offset.value,F.offset.value+F.size),f=fflate.unzlibSync(P),c=new Uint8Array(f.length);return r(f),n(f,c),new DataView(c.buffer)}function cF(F){const P=F.array.slice(F.offset.value,F.offset.value+F.size),f=fflate.unzlibSync(P),c=F.lines*F.channels*F.width,N=1==F.type?new Uint16Array(c):new Uint32Array(c);let q=0,H=0;const A=new Array(4);for(let o=0;o<F.lines;o++)for(let P=0;P<F.channels;P++){let P=0;switch(F.type){case 1:A[0]=q,A[1]=A[0]+F.width,q=A[1]+F.width;for(let c=0;c<F.width;++c){P+=f[A[0]++]<<8|f[A[1]++],N[H]=P,H++}break;case 2:A[0]=q,A[1]=A[0]+F.width,A[2]=A[1]+F.width,q=A[2]+F.width;for(let c=0;c<F.width;++c){P+=f[A[0]++]<<24|f[A[1]++]<<16|f[A[2]++]<<8,N[H]=P,H++}}}return new DataView(N.buffer)}function NF(F){const P=F.viewer,f={value:F.offset.value},c=new Uint16Array(F.width*F.scanlineBlockSize*(F.channels*F.type)),N=new Uint8Array(u);let q=0;const H=new Array(F.channels);for(let o=0;o<F.channels;o++)H[o]={},H[o].start=q,H[o].end=H[o].start,H[o].nx=F.width,H[o].ny=F.lines,H[o].size=F.type,q+=H[o].nx*H[o].ny*H[o].size;const A=V(P,f),j=V(P,f);if(j>=u)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(A<=j)for(let o=0;o<j-A+1;o++)N[o+A]=M(P,f);const T=new Uint16Array(i),Y=function(F,P){let f=0;for(let N=0;N<i;++N)(0==N||F[N>>3]&1<<(7&N))&&(P[f++]=N);const c=f-1;for(;f<i;)P[f++]=0;return c}(N,T),t=d(P,f);a(F.array,P,f,t,c,q);for(let o=0;o<F.channels;++o){const F=H[o];for(let P=0;P<H[o].size;++P)S(c,F.start+P,F.nx,F.size,F.ny,F.nx*F.size,Y)}!function(F,P,f){for(let c=0;c<f;++c)P[c]=F[P[c]]}(T,c,q);let C=0;const L=new Uint8Array(c.buffer.byteLength);for(let i=0;i<F.lines;i++)for(let P=0;P<F.channels;P++){const F=H[P],f=F.nx*F.size,N=new Uint8Array(c.buffer,F.end*o,f*o);L.set(N,C),C+=f*o,F.end+=f}return new DataView(L.buffer)}var qF,HF=f(11462);!function(F){F[F.Float=0]="Float",F[F.HalfFloat=1]="HalfFloat"}(qF||(qF={}));class AF{}async function oF(F,P,f,c){const N={size:0,viewer:P,array:new Uint8Array(P.buffer),offset:f,width:F.dataWindow.xMax-F.dataWindow.xMin+1,height:F.dataWindow.yMax-F.dataWindow.yMin+1,channels:F.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(F.compression){case z.NO_COMPRESSION:N.lines=1,N.uncompress=FF;break;case z.RLE_COMPRESSION:N.lines=1,N.uncompress=PF;break;case z.ZIPS_COMPRESSION:N.lines=1,N.uncompress=fF,await HF.Tools.LoadScriptAsync(AF.FFLATEUrl);break;case z.ZIP_COMPRESSION:N.lines=16,N.uncompress=fF,await HF.Tools.LoadScriptAsync(AF.FFLATEUrl);break;case z.PIZ_COMPRESSION:N.lines=32,N.uncompress=NF;break;case z.PXR24_COMPRESSION:N.lines=16,N.uncompress=cF,await HF.Tools.LoadScriptAsync(AF.FFLATEUrl);break;default:throw new Error(z[F.compression]+" is unsupported")}N.scanlineBlockSize=N.lines;const q={};for(const H of F.channels)switch(H.name){case"R":case"G":case"B":case"A":case"Y":q[H.name]=!0,N.type=H.pixelType}let A=!1;if(q.R&&q.G&&q.B&&q.A)N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(q.R&&q.G&&q.B)A=!0,N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(q.R&&q.G)N.outputChannels=2,N.decodeChannels={R:0,G:1};else if(q.R)N.outputChannels=1,N.decodeChannels={R:0};else{if(!q.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");N.outputChannels=1,N.decodeChannels={Y:0}}if(1===N.type)switch(c){case qF.Float:N.getter=k,N.inputSize=o;break;case qF.HalfFloat:N.getter=V,N.inputSize=o}else{if(2!==N.type)throw new Error("Unsupported pixelType "+N.type+" for "+F.compression);switch(c){case qF.Float:N.getter=x,N.inputSize=H;break;case qF.HalfFloat:N.getter=I,N.inputSize=H}}N.blockCount=N.height/N.scanlineBlockSize;for(let H=0;H<N.blockCount;H++)K(P,f);const j=N.width*N.height*N.outputChannels;switch(c){case qF.Float:N.byteArray=new Float32Array(j),N.textureType=1,A&&N.byteArray.fill(1,0,j);break;case qF.HalfFloat:N.byteArray=new Uint16Array(j),N.textureType=2,A&&N.byteArray.fill(15360,0,j);break;default:throw new Error("Unsupported type: "+c)}let i=0;for(const H of F.channels)void 0!==N.decodeChannels[H.name]&&(N.channelLineOffsets[H.name]=i*N.width),i+=2*H.pixelType;return N.bytesPerLine=N.width*i,N.outLineWidth=N.width*N.outputChannels,"INCREASING_Y"===F.lineOrder?N.scanOrder=F=>F:N.scanOrder=F=>N.height-1-F,4==N.outputChannels?(N.format=5,N.linearSpace=!0):(N.format=6,N.linearSpace=!1),N}function jF(F,P,f,c){const N={value:0};for(let q=0;q<F.height/F.scanlineBlockSize;q++){const H=O(f,c)-P.dataWindow.yMin;F.size=d(f,c),F.lines=H+F.scanlineBlockSize>F.height?F.height-H:F.scanlineBlockSize;const A=F.size<F.lines*F.bytesPerLine&&F.uncompress?F.uncompress(F):FF(F);c.value+=F.size;for(let f=0;f<F.scanlineBlockSize;f++){const c=q*F.scanlineBlockSize,H=f+F.scanOrder(c);if(H>=F.height)continue;const o=f*F.bytesPerLine,j=(F.height-1-H)*F.outLineWidth;for(let f=0;f<F.channels;f++){const c=P.channels[f].name,q=F.channelLineOffsets[c],H=F.decodeChannels[c];if(void 0!==H){N.value=o+q;for(let P=0;P<F.width;P++){const f=j+P*F.outputChannels+H;F.byteArray&&(F.byteArray[f]=F.getter(A,N))}}}}}}AF.DefaultOutputType=qF.HalfFloat,AF.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class iF{constructor(){this.supportCascades=!1}loadCubeData(F,P,f,c,N){throw".exr not supported in Cube."}loadData(F,P,f){const N=new DataView(F.buffer),q={value:0},H=U(N,q);oF(H,N,q,AF.DefaultOutputType).then((F=>{jF(F,H,N,q);const c=H.dataWindow.xMax-H.dataWindow.xMin+1,A=H.dataWindow.yMax-H.dataWindow.yMin+1;f(c,A,P.generateMipMaps,!1,(()=>{const f=P.getEngine();P.format=H.format,P.type=F.textureType,P.invertY=!1,P._gammaSpace=!H.linearSpace,F.byteArray&&f._uploadDataToTextureDirectly(P,F.byteArray,0,0,void 0,!0)}))})).catch((F=>{c.d.Error("Failed to load EXR texture: ",F)}))}}async function uF(F){const P=new DataView(F),f={value:0},N=U(P,f);try{const F=await oF(N,P,f,qF.Float);return jF(F,N,P,f),F.byteArray?{width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,data:new Float32Array(F.byteArray)}:(c.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(q){c.d.Error("Failed to load EXR data: ",q)}return{width:0,height:0,data:null}}},11664:(F,P,f)=>{function c(F){return parseInt(F.toString().replace(/\W/g,""))}function N(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(F-P)<=f}function q(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return F<P-c||F>f+c}function H(F,P){return F===P?F:Math.random()*(P-F)+F}function A(F,P,f){return F+(P-F)*f}function o(F,P,f){let c=L(P-F,360);return c>180&&(c-=360),F+c*T(f)}function j(F,P,f){let c=0;return c=F!=P?T((f-F)/(P-F)):0,c}function i(F,P,f,c,N){const q=N*N,H=N*q;return F*(2*H-3*q+1)+f*(-2*H+3*q)+P*(H-2*q+N)+c*(H-q)}function u(F,P,f,c,N){const q=N*N;return 6*(q-N)*F+(3*q-4*N+1)*P+6*(-q+N)*f+(3*q-2*N)*c}function T(F){let P=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(f,Math.max(P,F))}function Y(F){return F-=2*Math.PI*Math.floor((F+Math.PI)/(2*Math.PI))}function t(F){const P=F.toString(16);return F<=15?("0"+P).toUpperCase():P.toUpperCase()}function C(F){if(Math.log2)return Math.floor(Math.log2(F));if(F<0)return NaN;if(0===F)return-1/0;let P=0;if(F<1){for(;F<1;)P++,F*=2;P=-P}else if(F>1)for(;F>1;)P++,F=Math.floor(F/2);return P}function L(F,P){return F-Math.floor(F/P)*P}function J(F,P,f){return(F-P)/(f-P)}function B(F,P,f){return F*(f-P)+P}function z(F,P){let f=L(P-F,360);return f>180&&(f-=360),f}function Z(F,P){const f=L(F,2*P);return P-Math.abs(f-P)}function R(F,P,f){let c=T(f);return c=-2*c*c*c+3*c*c,P*c+F*(1-c)}function y(F,P,f){let c=0;return c=Math.abs(P-F)<=f?P:F+Math.sign(P-F)*f,c}function O(F,P,f){const c=z(F,P);let N=0;return N=-f<c&&c<f?P:y(F,P=F+c,f),N}function d(F,P,f){return(F-P)/(f-P)}function M(F,P,f){return(f-P)*F+P}function V(F,P){const f=F%P;return 0===f?P:V(P,f)}f.r(P),f.d(P,{Clamp:()=>T,DeltaAngle:()=>z,Denormalize:()=>B,ExtractAsInt:()=>c,Hermite:()=>i,Hermite1stDerivative:()=>u,HighestCommonFactor:()=>V,ILog2:()=>C,InverseLerp:()=>j,Lerp:()=>A,LerpAngle:()=>o,MoveTowards:()=>y,MoveTowardsAngle:()=>O,Normalize:()=>J,NormalizeRadians:()=>Y,OutsideRange:()=>q,PercentToRange:()=>M,PingPong:()=>Z,RandomRange:()=>H,RangeToPercent:()=>d,Repeat:()=>L,SmoothStep:()=>R,ToHex:()=>t,WithinEpsilon:()=>N})}}]);