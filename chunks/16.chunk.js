"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[16],{14203:(K,O,F)=>{F.r(O),F.d(O,{ReadExrDataAsync:()=>tK,_ExrTextureLoader:()=>MK});var f=F(11534),r=F(11734);const l=4,q=4,J=1,c=2,E=8,M=65536,t=M>>3,j=14,X=65537,u=1<<j,T=u-1,o=59,k=63,N=2+k-o;var Z,L;!function(K){K[K.NO_COMPRESSION=0]="NO_COMPRESSION",K[K.RLE_COMPRESSION=1]="RLE_COMPRESSION",K[K.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",K[K.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",K[K.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",K[K.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(Z||(Z={})),function(K){K[K.INCREASING_Y=0]="INCREASING_Y",K[K.DECREASING_Y=1]="DECREASING_Y"}(L||(L={}));const d=function(){const K=new ArrayBuffer(4),O=new Float32Array(K),F=new Uint32Array(K),f=new Uint32Array(512),r=new Uint32Array(512);for(let c=0;c<256;++c){const K=c-127;K<-27?(f[c]=0,f[256|c]=32768,r[c]=24,r[256|c]=24):K<-14?(f[c]=1024>>-K-14,f[256|c]=1024>>-K-14|32768,r[c]=-K-1,r[256|c]=-K-1):K<=15?(f[c]=K+15<<10,f[256|c]=K+15<<10|32768,r[c]=13,r[256|c]=13):K<128?(f[c]=31744,f[256|c]=64512,r[c]=24,r[256|c]=24):(f[c]=31744,f[256|c]=64512,r[c]=13,r[256|c]=13)}const l=new Uint32Array(2048),q=new Uint32Array(64),J=new Uint32Array(64);for(let c=1;c<1024;++c){let K=c<<13,O=0;for(;0===(8388608&K);)K<<=1,O-=8388608;K&=-8388609,O+=947912704,l[c]=K|O}for(let c=1024;c<2048;++c)l[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)q[c]=c<<23;q[31]=1199570944,q[32]=2147483648;for(let c=33;c<63;++c)q[c]=2147483648+(c-32<<23);q[63]=3347054592;for(let c=1;c<64;++c)32!==c&&(J[c]=1024);return{floatView:O,uint32View:F,baseTable:f,shiftTable:r,mantissaTable:l,exponentTable:q,offsetTable:J}}();function a(K,O){const F=new Uint8Array(K);let f=0;for(;0!=F[O.value+f];)f+=1;const r=(new TextDecoder).decode(F.slice(O.value,O.value+f));return O.value=O.value+f+1,r}function g(K,O){const F=K.getInt32(O.value,!0);return O.value+=l,F}function H(K,O){const F=K.getUint32(O.value,!0);return O.value+=l,F}function e(K,O){const F=K.getUint8(O.value);return O.value+=J,F}function W(K,O){const F=K.getUint16(O.value,!0);return O.value+=c,F}function p(K,O){const F=K[O.value];return O.value+=J,F}function y(K,O){let F;return F="getBigInt64"in DataView.prototype?Number(K.getBigInt64(O.value,!0)):K.getUint32(O.value+4,!0)+Number(K.getUint32(O.value,!0)<<32),O.value+=E,F}function A(K,O){const F=K.getFloat32(O.value,!0);return O.value+=q,F}function Q(K,O){return function(K){const O=(31744&K)>>10,F=1023&K;return(K>>15?-1:1)*(O?31===O?F?NaN:1/0:Math.pow(2,O-15)*(1+F/1024):F/1024*6103515625e-14)}(W(K,O))}function R(K,O){return function(K){if(Math.abs(K)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");K=(0,r.Clamp)(K,-65504,65504),d.floatView[0]=K;const O=d.uint32View[0],F=O>>23&511;return d.baseTable[F]+((8388607&O)>>d.shiftTable[F])}(A(K,O))}function G(K,O,F,f){switch(F){case"string":case"stringvector":case"iccProfile":return function(K,O,F){const f=(new TextDecoder).decode(new Uint8Array(K).slice(O.value,O.value+F));return O.value=O.value+F,f}(K.buffer,O,f);case"chlist":return function(K,O,F){const f=O.value,r=[];for(;O.value<f+F-1;){const F=a(K.buffer,O),f=g(K,O),l=e(K,O);O.value+=3;const q=g(K,O),J=g(K,O);r.push({name:F,pixelType:f,pLinear:l,xSampling:q,ySampling:J})}return O.value+=1,r}(K,O,f);case"chromaticities":return function(K,O){return{redX:A(K,O),redY:A(K,O),greenX:A(K,O),greenY:A(K,O),blueX:A(K,O),blueY:A(K,O),whiteX:A(K,O),whiteY:A(K,O)}}(K,O);case"compression":return function(K,O){return e(K,O)}(K,O);case"box2i":return function(K,O){return{xMin:g(K,O),yMin:g(K,O),xMax:g(K,O),yMax:g(K,O)}}(K,O);case"lineOrder":return function(K,O){const F=e(K,O);return L[F]}(K,O);case"float":return A(K,O);case"v2f":return function(K,O){return[A(K,O),A(K,O)]}(K,O);case"v3f":return function(K,O){return[A(K,O),A(K,O),A(K,O)]}(K,O);case"int":return g(K,O);case"rational":return function(K,O){return[g(K,O),H(K,O)]}(K,O);case"timecode":return function(K,O){return[H(K,O),H(K,O)]}(K,O);case"preview":return O.value+=f,"skipped";default:return void(O.value+=f)}}function z(K){for(let O=1;O<K.length;O++){const F=K[O-1]+K[O]-128;K[O]=F}}function m(K,O){let F=0,f=Math.floor((K.length+1)/2),r=0;const l=K.length-1;for(;!(r>l)&&(O[r++]=K[F++],!(r>l));)O[r++]=K[f++]}const x=20000630;function V(K,O){if(K.getUint32(0,!0)!=x)throw new Error("Incorrect OpenEXR format");const F=K.getUint8(4),r=K.getUint8(5),l={singleTile:!!(2&r),longName:!!(4&r),deepFormat:!!(8&r),multiPart:!!(16&r)};O.value=8;const q={};let J=!0;for(;J;){const F=a(K.buffer,O);if(F){const r=a(K.buffer,O),l=G(K,O,r,H(K,O));void 0===l?f.c.Warn(`Unknown header attribute type ${r}'.`):q[F]=l}else J=!1}if(0!=(-5&r))throw new Error("Unsupported file format");return{version:F,spec:l,...q}}const v=32768,Y=65535;function B(K,O,F,f,r){for(;F<K;)O=O<<8|p(f,r),F+=8;return{l:O>>(F-=K)&(1<<K)-1,c:O,lc:F}}function n(K,O,F,f){return{c:K=K<<8|p(F,f),lc:O+=8}}function C(K,O,F,f,r,l,q,J,c){if(K==O){if(f<8){const K=n(F,f,r,l);F=K.c,f=K.lc}let K=F>>(f-=8);if(K=new Uint8Array([K])[0],J.value+K>c)return null;const O=q[J.value-1];for(;K-- >0;)q[J.value++]=O}else{if(!(J.value<c))return null;q[J.value++]=K}return{c:F,lc:f}}const I=new Array(59);function D(K,O,F,f,r,l){const q=O;let J=0,c=0;for(;f<=r;f++){if(q.value-O.value>F)return;let E=B(6,J,c,K,q);const M=E.l;if(J=E.c,c=E.lc,l[f]=M,M==k){if(q.value-O.value>F)throw new Error("Error in HufUnpackEncTable");E=B(8,J,c,K,q);let M=E.l+N;if(J=E.c,c=E.lc,f+M>r+1)throw new Error("Error in HufUnpackEncTable");for(;M--;)l[f++]=0;f--}else if(M>=o){let K=M-o+2;if(f+K>r+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)l[f++]=0;f--}}!function(K){for(let F=0;F<=58;++F)I[F]=0;for(let F=0;F<X;++F)I[K[F]]+=1;let O=0;for(let F=58;F>0;--F){const K=O+I[F]>>1;I[F]=O,O=K}for(let F=0;F<X;++F){const O=K[F];O>0&&(K[F]=O|I[O]++<<6)}}(l)}function h(K){return 63&K}function b(K){return K>>6}function i(K,O,F,f,r,l){const q=F.value,J=H(O,F),c=H(O,F);F.value+=4;const E=H(O,F);if(F.value+=4,J<0||J>=X||c<0||c>=X)throw new Error("Wrong HUF_ENCSIZE");const M=new Array(X),t=new Array(u);!function(K){for(let O=0;O<u;O++)K[O]={},K[O].len=0,K[O].lit=0,K[O].p=null}(t);if(D(K,F,f-(F.value-q),J,c,M),E>8*(f-(F.value-q)))throw new Error("Wrong hufUncompress");!function(K,O,F,f){for(;O<=F;O++){const F=b(K[O]),r=h(K[O]);if(F>>r)throw new Error("Invalid table entry");if(r>j){const K=f[F>>r-j];if(K.len)throw new Error("Invalid table entry");if(K.lit++,K.p){const O=K.p;K.p=new Array(K.lit);for(let F=0;F<K.lit-1;++F)K.p[F]=O[F]}else K.p=new Array(1);K.p[K.lit-1]=O}else if(r){let K=0;for(let l=1<<j-r;l>0;l--){const l=f[(F<<j-r)+K];if(l.len||l.p)throw new Error("Invalid table entry");l.len=r,l.lit=O,K++}}}}(M,J,c,t),function(K,O,F,f,r,l,q,J,c){let E=0,M=0;const t=q,X=Math.trunc(f.value+(r+7)/8);for(;f.value<X;){let r=n(E,M,F,f);for(E=r.c,M=r.lc;M>=j;){const q=O[E>>M-j&T];if(q.len){M-=q.len;const K=C(q.lit,l,E,M,F,f,J,c,t);K&&(E=K.c,M=K.lc)}else{if(!q.p)throw new Error("hufDecode issues");let O;for(O=0;O<q.lit;O++){const j=h(K[q.p[O]]);for(;M<j&&f.value<X;)r=n(E,M,F,f),E=r.c,M=r.lc;if(M>=j&&b(K[q.p[O]])==(E>>M-j&(1<<j)-1)){M-=j;const K=C(q.p[O],l,E,M,F,f,J,c,t);K&&(E=K.c,M=K.lc);break}}if(O==q.lit)throw new Error("HufDecode issues")}}}const u=8-r&7;for(E>>=u,M-=u;M>0;){const K=O[E<<j-M&T];if(!K.len)throw new Error("HufDecode issues");{M-=K.len;const O=C(K.lit,l,E,M,F,f,J,c,t);O&&(E=O.c,M=O.lc)}}}(M,t,K,F,E,c,l,r,{value:0})}function w(K){return 65535&K}function s(K){const O=w(K);return O>32767?O-65536:O}function U(K,O){const F=s(K),f=s(O),r=F+(1&f)+(f>>1);return{a:r,b:r-f}}function P(K,O){const F=w(K),f=w(O),r=F-(f>>1)&Y;return{a:f+r-v&Y,b:r}}function S(K,O,F,f,r,l,q){const J=q<16384,c=F>r?r:F;let E,M,t=1;for(;t<=c;)t<<=1;for(t>>=1,E=t,t>>=1;t>=1;){M=0;const q=M+l*(r-E),c=l*t,j=l*E,X=f*t,u=f*E;let T,o,k,N;for(;M<=q;M+=j){let r=M;const l=M+f*(F-E);for(;r<=l;r+=u){const F=r+X,f=r+c,l=f+X;if(J){let q=U(K[r+O],K[f+O]);T=q.a,k=q.b,q=U(K[F+O],K[l+O]),o=q.a,N=q.b,q=U(T,o),K[r+O]=q.a,K[F+O]=q.b,q=U(k,N),K[f+O]=q.a,K[l+O]=q.b}else{let q=P(K[r+O],K[f+O]);T=q.a,k=q.b,q=P(K[F+O],K[l+O]),o=q.a,N=q.b,q=P(T,o),K[r+O]=q.a,K[F+O]=q.b,q=P(k,N),K[f+O]=q.a,K[l+O]=q.b}}if(F&t){const F=r+c;let f;f=J?U(K[r+O],K[F+O]):P(K[r+O],K[F+O]),T=f.a,K[F+O]=f.b,K[r+O]=T}}if(r&t){let r=M;const l=M+f*(F-E);for(;r<=l;r+=u){const F=r+X;let f;f=J?U(K[r+O],K[F+O]):P(K[r+O],K[F+O]),T=f.a,K[F+O]=f.b,K[r+O]=T}}E=t,t>>=1}return M}function KK(K){return new DataView(K.array.buffer,K.offset.value,K.size)}function OK(K){const O=K.viewer.buffer.slice(K.offset.value,K.offset.value+K.size),F=new Uint8Array(function(K){let O=K.byteLength;const F=[];let f=0;const r=new DataView(K);for(;O>0;){const K=r.getInt8(f++);if(K<0){const l=-K;O-=l+1;for(let K=0;K<l;K++)F.push(r.getUint8(f++))}else{const l=K;O-=2;const q=r.getUint8(f++);for(let K=0;K<l+1;K++)F.push(q)}}return F}(O)),f=new Uint8Array(F.length);return z(F),m(F,f),new DataView(f.buffer)}function FK(K){const O=K.array.slice(K.offset.value,K.offset.value+K.size),F=fflate.unzlibSync(O),f=new Uint8Array(F.length);return z(F),m(F,f),new DataView(f.buffer)}function fK(K){const O=K.array.slice(K.offset.value,K.offset.value+K.size),F=fflate.unzlibSync(O),f=K.lines*K.channels*K.width,r=1==K.type?new Uint16Array(f):new Uint32Array(f);let l=0,q=0;const J=new Array(4);for(let c=0;c<K.lines;c++)for(let O=0;O<K.channels;O++){let O=0;switch(K.type){case 1:J[0]=l,J[1]=J[0]+K.width,l=J[1]+K.width;for(let f=0;f<K.width;++f){O+=F[J[0]++]<<8|F[J[1]++],r[q]=O,q++}break;case 2:J[0]=l,J[1]=J[0]+K.width,J[2]=J[1]+K.width,l=J[2]+K.width;for(let f=0;f<K.width;++f){O+=F[J[0]++]<<24|F[J[1]++]<<16|F[J[2]++]<<8,r[q]=O,q++}}}return new DataView(r.buffer)}function rK(K){const O=K.viewer,F={value:K.offset.value},f=new Uint16Array(K.width*K.scanlineBlockSize*(K.channels*K.type)),r=new Uint8Array(t);let l=0;const q=new Array(K.channels);for(let c=0;c<K.channels;c++)q[c]={},q[c].start=l,q[c].end=q[c].start,q[c].nx=K.width,q[c].ny=K.lines,q[c].size=K.type,l+=q[c].nx*q[c].ny*q[c].size;const J=W(O,F),E=W(O,F);if(E>=t)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(J<=E)for(let c=0;c<E-J+1;c++)r[c+J]=e(O,F);const j=new Uint16Array(M),X=function(K,O){let F=0;for(let r=0;r<M;++r)(0==r||K[r>>3]&1<<(7&r))&&(O[F++]=r);const f=F-1;for(;F<M;)O[F++]=0;return f}(r,j),u=H(O,F);i(K.array,O,F,u,f,l);for(let c=0;c<K.channels;++c){const K=q[c];for(let O=0;O<q[c].size;++O)S(f,K.start+O,K.nx,K.size,K.ny,K.nx*K.size,X)}!function(K,O,F){for(let f=0;f<F;++f)O[f]=K[O[f]]}(j,f,l);let T=0;const o=new Uint8Array(f.buffer.byteLength);for(let M=0;M<K.lines;M++)for(let O=0;O<K.channels;O++){const K=q[O],F=K.nx*K.size,r=new Uint8Array(f.buffer,K.end*c,F*c);o.set(r,T),T+=F*c,K.end+=F}return new DataView(o.buffer)}var lK,qK=F(11517);!function(K){K[K.Float=0]="Float",K[K.HalfFloat=1]="HalfFloat"}(lK||(lK={}));class JK{}async function cK(K,O,F,f){const r={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:F,width:K.dataWindow.xMax-K.dataWindow.xMin+1,height:K.dataWindow.yMax-K.dataWindow.yMin+1,channels:K.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(K.compression){case Z.NO_COMPRESSION:r.lines=1,r.uncompress=KK;break;case Z.RLE_COMPRESSION:r.lines=1,r.uncompress=OK;break;case Z.ZIPS_COMPRESSION:r.lines=1,r.uncompress=FK,await qK.Tools.LoadScriptAsync(JK.FFLATEUrl);break;case Z.ZIP_COMPRESSION:r.lines=16,r.uncompress=FK,await qK.Tools.LoadScriptAsync(JK.FFLATEUrl);break;case Z.PIZ_COMPRESSION:r.lines=32,r.uncompress=rK;break;case Z.PXR24_COMPRESSION:r.lines=16,r.uncompress=fK,await qK.Tools.LoadScriptAsync(JK.FFLATEUrl);break;default:throw new Error(Z[K.compression]+" is unsupported")}r.scanlineBlockSize=r.lines;const l={};for(const q of K.channels)switch(q.name){case"R":case"G":case"B":case"A":case"Y":l[q.name]=!0,r.type=q.pixelType}let J=!1;if(l.R&&l.G&&l.B&&l.A)r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G&&l.B)J=!0,r.outputChannels=4,r.decodeChannels={R:0,G:1,B:2,A:3};else if(l.R&&l.G)r.outputChannels=2,r.decodeChannels={R:0,G:1};else if(l.R)r.outputChannels=1,r.decodeChannels={R:0};else{if(!l.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");r.outputChannels=1,r.decodeChannels={Y:0}}if(1===r.type)switch(f){case lK.Float:r.getter=Q,r.inputSize=c;break;case lK.HalfFloat:r.getter=W,r.inputSize=c}else{if(2!==r.type)throw new Error("Unsupported pixelType "+r.type+" for "+K.compression);switch(f){case lK.Float:r.getter=A,r.inputSize=q;break;case lK.HalfFloat:r.getter=R,r.inputSize=q}}r.blockCount=r.height/r.scanlineBlockSize;for(let q=0;q<r.blockCount;q++)y(O,F);const E=r.width*r.height*r.outputChannels;switch(f){case lK.Float:r.byteArray=new Float32Array(E),r.textureType=1,J&&r.byteArray.fill(1,0,E);break;case lK.HalfFloat:r.byteArray=new Uint16Array(E),r.textureType=2,J&&r.byteArray.fill(15360,0,E);break;default:throw new Error("Unsupported type: "+f)}let M=0;for(const q of K.channels)void 0!==r.decodeChannels[q.name]&&(r.channelLineOffsets[q.name]=M*r.width),M+=2*q.pixelType;return r.bytesPerLine=r.width*M,r.outLineWidth=r.width*r.outputChannels,"INCREASING_Y"===K.lineOrder?r.scanOrder=K=>K:r.scanOrder=K=>r.height-1-K,4==r.outputChannels?(r.format=5,r.linearSpace=!0):(r.format=6,r.linearSpace=!1),r}function EK(K,O,F,f){const r={value:0};for(let l=0;l<K.height/K.scanlineBlockSize;l++){const q=g(F,f)-O.dataWindow.yMin;K.size=H(F,f),K.lines=q+K.scanlineBlockSize>K.height?K.height-q:K.scanlineBlockSize;const J=K.size<K.lines*K.bytesPerLine&&K.uncompress?K.uncompress(K):KK(K);f.value+=K.size;for(let F=0;F<K.scanlineBlockSize;F++){const f=l*K.scanlineBlockSize,q=F+K.scanOrder(f);if(q>=K.height)continue;const c=F*K.bytesPerLine,E=(K.height-1-q)*K.outLineWidth;for(let F=0;F<K.channels;F++){const f=O.channels[F].name,l=K.channelLineOffsets[f],q=K.decodeChannels[f];if(void 0!==q){r.value=c+l;for(let O=0;O<K.width;O++){const F=E+O*K.outputChannels+q;K.byteArray&&(K.byteArray[F]=K.getter(J,r))}}}}}}JK.DefaultOutputType=lK.HalfFloat,JK.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class MK{constructor(){this.supportCascades=!1}loadCubeData(K,O,F,f,r){throw".exr not supported in Cube."}loadData(K,O,F){const r=new DataView(K.buffer),l={value:0},q=V(r,l);cK(q,r,l,JK.DefaultOutputType).then((K=>{EK(K,q,r,l);const f=q.dataWindow.xMax-q.dataWindow.xMin+1,J=q.dataWindow.yMax-q.dataWindow.yMin+1;F(f,J,O.generateMipMaps,!1,(()=>{const F=O.getEngine();O.format=q.format,O.type=K.textureType,O.invertY=!1,O._gammaSpace=!q.linearSpace,K.byteArray&&F._uploadDataToTextureDirectly(O,K.byteArray,0,0,void 0,!0)}))})).catch((K=>{f.c.Error("Failed to load EXR texture: ",K)}))}}async function tK(K){const O=new DataView(K),F={value:0},r=V(O,F);try{const K=await cK(r,O,F,lK.Float);return EK(K,r,O,F),K.byteArray?{width:r.dataWindow.xMax-r.dataWindow.xMin+1,height:r.dataWindow.yMax-r.dataWindow.yMin+1,data:new Float32Array(K.byteArray)}:(f.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(l){f.c.Error("Failed to load EXR data: ",l)}return{width:0,height:0,data:null}}},11734:(K,O,F)=>{function f(K){return parseInt(K.toString().replace(/\W/g,""))}function r(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(K-O)<=F}function l(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return K<O-f||K>F+f}function q(K,O){return K===O?K:Math.random()*(O-K)+K}function J(K,O,F){return K+(O-K)*F}function c(K,O,F){let f=o(O-K,360);return f>180&&(f-=360),K+f*j(F)}function E(K,O,F){let f=0;return f=K!=O?j((F-K)/(O-K)):0,f}function M(K,O,F,f,r){const l=r*r,q=r*l;return K*(2*q-3*l+1)+F*(-2*q+3*l)+O*(q-2*l+r)+f*(q-l)}function t(K,O,F,f,r){const l=r*r;return 6*(l-r)*K+(3*l-4*r+1)*O+6*(-l+r)*F+(3*l-2*r)*f}function j(K){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(F,Math.max(O,K))}function X(K){return K-=2*Math.PI*Math.floor((K+Math.PI)/(2*Math.PI))}function u(K){const O=K.toString(16);return K<=15?("0"+O).toUpperCase():O.toUpperCase()}function T(K){if(Math.log2)return Math.floor(Math.log2(K));if(K<0)return NaN;if(0===K)return-1/0;let O=0;if(K<1){for(;K<1;)O++,K*=2;O=-O}else if(K>1)for(;K>1;)O++,K=Math.floor(K/2);return O}function o(K,O){return K-Math.floor(K/O)*O}function k(K,O,F){return(K-O)/(F-O)}function N(K,O,F){return K*(F-O)+O}function Z(K,O){let F=o(O-K,360);return F>180&&(F-=360),F}function L(K,O){const F=o(K,2*O);return O-Math.abs(F-O)}function d(K,O,F){let f=j(F);return f=-2*f*f*f+3*f*f,O*f+K*(1-f)}function a(K,O,F){let f=0;return f=Math.abs(O-K)<=F?O:K+Math.sign(O-K)*F,f}function g(K,O,F){const f=Z(K,O);let r=0;return r=-F<f&&f<F?O:a(K,O=K+f,F),r}function H(K,O,F){return(K-O)/(F-O)}function e(K,O,F){return(F-O)*K+O}function W(K,O){const F=K%O;return 0===F?O:W(O,F)}F.r(O),F.d(O,{Clamp:()=>j,DeltaAngle:()=>Z,Denormalize:()=>N,ExtractAsInt:()=>f,Hermite:()=>M,Hermite1stDerivative:()=>t,HighestCommonFactor:()=>W,ILog2:()=>T,InverseLerp:()=>E,Lerp:()=>J,LerpAngle:()=>c,MoveTowards:()=>a,MoveTowardsAngle:()=>g,Normalize:()=>k,NormalizeRadians:()=>X,OutsideRange:()=>l,PercentToRange:()=>e,PingPong:()=>L,RandomRange:()=>q,RangeToPercent:()=>H,Repeat:()=>o,SmoothStep:()=>d,ToHex:()=>u,WithinEpsilon:()=>r})}}]);