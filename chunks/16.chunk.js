"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[16],{14830:(N,U,V)=>{V.r(U),V.d(U,{ReadExrDataAsync:()=>pN,_ExrTextureLoader:()=>EN});var A=V(12193),t=V(12395);const n=4,q=4,i=1,z=2,S=8,E=65536,p=E>>3,k=14,B=65537,C=1<<k,x=C-1,J=59,d=63,r=2+d-J;var v,h;!function(N){N[N.NO_COMPRESSION=0]="NO_COMPRESSION",N[N.RLE_COMPRESSION=1]="RLE_COMPRESSION",N[N.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",N[N.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",N[N.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",N[N.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(v||(v={})),function(N){N[N.INCREASING_Y=0]="INCREASING_Y",N[N.DECREASING_Y=1]="DECREASING_Y"}(h||(h={}));const c=function(){const N=new ArrayBuffer(4),U=new Float32Array(N),V=new Uint32Array(N),A=new Uint32Array(512),t=new Uint32Array(512);for(let z=0;z<256;++z){const N=z-127;N<-27?(A[z]=0,A[256|z]=32768,t[z]=24,t[256|z]=24):N<-14?(A[z]=1024>>-N-14,A[256|z]=1024>>-N-14|32768,t[z]=-N-1,t[256|z]=-N-1):N<=15?(A[z]=N+15<<10,A[256|z]=N+15<<10|32768,t[z]=13,t[256|z]=13):N<128?(A[z]=31744,A[256|z]=64512,t[z]=24,t[256|z]=24):(A[z]=31744,A[256|z]=64512,t[z]=13,t[256|z]=13)}const n=new Uint32Array(2048),q=new Uint32Array(64),i=new Uint32Array(64);for(let z=1;z<1024;++z){let N=z<<13,U=0;for(;0===(8388608&N);)N<<=1,U-=8388608;N&=-8388609,U+=947912704,n[z]=N|U}for(let z=1024;z<2048;++z)n[z]=939524096+(z-1024<<13);for(let z=1;z<31;++z)q[z]=z<<23;q[31]=1199570944,q[32]=2147483648;for(let z=33;z<63;++z)q[z]=2147483648+(z-32<<23);q[63]=3347054592;for(let z=1;z<64;++z)32!==z&&(i[z]=1024);return{floatView:U,uint32View:V,baseTable:A,shiftTable:t,mantissaTable:n,exponentTable:q,offsetTable:i}}();function H(N,U){const V=new Uint8Array(N);let A=0;for(;0!=V[U.value+A];)A+=1;const t=(new TextDecoder).decode(V.slice(U.value,U.value+A));return U.value=U.value+A+1,t}function Y(N,U){const V=N.getInt32(U.value,!0);return U.value+=n,V}function W(N,U){const V=N.getUint32(U.value,!0);return U.value+=n,V}function s(N,U){const V=N.getUint8(U.value);return U.value+=i,V}function M(N,U){const V=N.getUint16(U.value,!0);return U.value+=z,V}function a(N,U){const V=N[U.value];return U.value+=i,V}function mN(N,U){let V;return V="getBigInt64"in DataView.prototype?Number(N.getBigInt64(U.value,!0)):N.getUint32(U.value+4,!0)+Number(N.getUint32(U.value,!0)<<32),U.value+=S,V}function w(N,U){const V=N.getFloat32(U.value,!0);return U.value+=q,V}function X(N,U){return function(N){const U=(31744&N)>>10,V=1023&N;return(N>>15?-1:1)*(U?31===U?V?NaN:1/0:Math.pow(2,U-15)*(1+V/1024):V/1024*6103515625e-14)}(M(N,U))}function e(N,U){return function(N){if(Math.abs(N)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");N=(0,t.Clamp)(N,-65504,65504),c.floatView[0]=N;const U=c.uint32View[0],V=U>>23&511;return c.baseTable[V]+((8388607&U)>>c.shiftTable[V])}(w(N,U))}function Q(N,U,V,A){switch(V){case"string":case"stringvector":case"iccProfile":return function(N,U,V){const A=(new TextDecoder).decode(new Uint8Array(N).slice(U.value,U.value+V));return U.value=U.value+V,A}(N.buffer,U,A);case"chlist":return function(N,U,V){const A=U.value,t=[];for(;U.value<A+V-1;){const V=H(N.buffer,U),A=Y(N,U),n=s(N,U);U.value+=3;const q=Y(N,U),i=Y(N,U);t.push({name:V,pixelType:A,pLinear:n,xSampling:q,ySampling:i})}return U.value+=1,t}(N,U,A);case"chromaticities":return function(N,U){return{redX:w(N,U),redY:w(N,U),greenX:w(N,U),greenY:w(N,U),blueX:w(N,U),blueY:w(N,U),whiteX:w(N,U),whiteY:w(N,U)}}(N,U);case"compression":return function(N,U){return s(N,U)}(N,U);case"box2i":return function(N,U){return{xMin:Y(N,U),yMin:Y(N,U),xMax:Y(N,U),yMax:Y(N,U)}}(N,U);case"lineOrder":return function(N,U){const V=s(N,U);return h[V]}(N,U);case"float":return w(N,U);case"v2f":return function(N,U){return[w(N,U),w(N,U)]}(N,U);case"v3f":return function(N,U){return[w(N,U),w(N,U),w(N,U)]}(N,U);case"int":return Y(N,U);case"rational":return function(N,U){return[Y(N,U),W(N,U)]}(N,U);case"timecode":return function(N,U){return[W(N,U),W(N,U)]}(N,U);case"preview":return U.value+=A,"skipped";default:return void(U.value+=A)}}function u(N){for(let U=1;U<N.length;U++){const V=N[U-1]+N[U]-128;N[U]=V}}function L(N,U){let V=0,A=Math.floor((N.length+1)/2),t=0;const n=N.length-1;for(;!(t>n)&&(U[t++]=N[V++],!(t>n));)U[t++]=N[A++]}const I=20000630;function o(N,U){if(N.getUint32(0,!0)!=I)throw new Error("Incorrect OpenEXR format");const V=N.getUint8(4),t=N.getUint8(5),n={singleTile:!!(2&t),longName:!!(4&t),deepFormat:!!(8&t),multiPart:!!(16&t)};U.value=8;const q={};let i=!0;for(;i;){const V=H(N.buffer,U);if(V){const t=H(N.buffer,U),n=Q(N,U,t,W(N,U));void 0===n?A.b.Warn(`Unknown header attribute type ${t}'.`):q[V]=n}else i=!1}if(0!=(-5&t))throw new Error("Unsupported file format");return{version:V,spec:n,...q}}const R=32768,D=65535;function G(N,U,V,A,t){for(;V<N;)U=U<<8|a(A,t),V+=8;return{l:U>>(V-=N)&(1<<N)-1,c:U,lc:V}}function g(N,U,V,A){return{c:N=N<<8|a(V,A),lc:U+=8}}function l(N,U,V,A,t,n,q,i,z){if(N==U){if(A<8){const N=g(V,A,t,n);V=N.c,A=N.lc}let N=V>>(A-=8);if(N=new Uint8Array([N])[0],i.value+N>z)return null;const U=q[i.value-1];for(;N-- >0;)q[i.value++]=U}else{if(!(i.value<z))return null;q[i.value++]=N}return{c:V,lc:A}}const K=new Array(59);function j(N,U,V,A,t,n){const q=U;let i=0,z=0;for(;A<=t;A++){if(q.value-U.value>V)return;let S=G(6,i,z,N,q);const E=S.l;if(i=S.c,z=S.lc,n[A]=E,E==d){if(q.value-U.value>V)throw new Error("Error in HufUnpackEncTable");S=G(8,i,z,N,q);let E=S.l+r;if(i=S.c,z=S.lc,A+E>t+1)throw new Error("Error in HufUnpackEncTable");for(;E--;)n[A++]=0;A--}else if(E>=J){let N=E-J+2;if(A+N>t+1)throw new Error("Error in HufUnpackEncTable");for(;N--;)n[A++]=0;A--}}!function(N){for(let V=0;V<=58;++V)K[V]=0;for(let V=0;V<B;++V)K[N[V]]+=1;let U=0;for(let V=58;V>0;--V){const N=U+K[V]>>1;K[V]=U,U=N}for(let V=0;V<B;++V){const U=N[V];U>0&&(N[V]=U|K[U]++<<6)}}(n)}function F(N){return 63&N}function P(N){return N>>6}function T(N,U,V,A,t,n){const q=V.value,i=W(U,V),z=W(U,V);V.value+=4;const S=W(U,V);if(V.value+=4,i<0||i>=B||z<0||z>=B)throw new Error("Wrong HUF_ENCSIZE");const E=new Array(B),p=new Array(C);!function(N){for(let U=0;U<C;U++)N[U]={},N[U].len=0,N[U].lit=0,N[U].p=null}(p);if(j(N,V,A-(V.value-q),i,z,E),S>8*(A-(V.value-q)))throw new Error("Wrong hufUncompress");!function(N,U,V,A){for(;U<=V;U++){const V=P(N[U]),t=F(N[U]);if(V>>t)throw new Error("Invalid table entry");if(t>k){const N=A[V>>t-k];if(N.len)throw new Error("Invalid table entry");if(N.lit++,N.p){const U=N.p;N.p=new Array(N.lit);for(let V=0;V<N.lit-1;++V)N.p[V]=U[V]}else N.p=new Array(1);N.p[N.lit-1]=U}else if(t){let N=0;for(let n=1<<k-t;n>0;n--){const n=A[(V<<k-t)+N];if(n.len||n.p)throw new Error("Invalid table entry");n.len=t,n.lit=U,N++}}}}(E,i,z,p),function(N,U,V,A,t,n,q,i,z){let S=0,E=0;const p=q,B=Math.trunc(A.value+(t+7)/8);for(;A.value<B;){let t=g(S,E,V,A);for(S=t.c,E=t.lc;E>=k;){const q=U[S>>E-k&x];if(q.len){E-=q.len;const N=l(q.lit,n,S,E,V,A,i,z,p);N&&(S=N.c,E=N.lc)}else{if(!q.p)throw new Error("hufDecode issues");let U;for(U=0;U<q.lit;U++){const k=F(N[q.p[U]]);for(;E<k&&A.value<B;)t=g(S,E,V,A),S=t.c,E=t.lc;if(E>=k&&P(N[q.p[U]])==(S>>E-k&(1<<k)-1)){E-=k;const N=l(q.p[U],n,S,E,V,A,i,z,p);N&&(S=N.c,E=N.lc);break}}if(U==q.lit)throw new Error("HufDecode issues")}}}const C=8-t&7;for(S>>=C,E-=C;E>0;){const N=U[S<<k-E&x];if(!N.len)throw new Error("HufDecode issues");{E-=N.len;const U=l(N.lit,n,S,E,V,A,i,z,p);U&&(S=U.c,E=U.lc)}}}(E,p,N,V,S,z,n,t,{value:0})}function f(N){return 65535&N}function O(N){const U=f(N);return U>32767?U-65536:U}function Z(N,U){const V=O(N),A=O(U),t=V+(1&A)+(A>>1);return{a:t,b:t-A}}function b(N,U){const V=f(N),A=f(U),t=V-(A>>1)&D;return{a:A+t-R&D,b:t}}function y(N,U,V,A,t,n,q){const i=q<16384,z=V>t?t:V;let S,E,p=1;for(;p<=z;)p<<=1;for(p>>=1,S=p,p>>=1;p>=1;){E=0;const q=E+n*(t-S),z=n*p,k=n*S,B=A*p,C=A*S;let x,J,d,r;for(;E<=q;E+=k){let t=E;const n=E+A*(V-S);for(;t<=n;t+=C){const V=t+B,A=t+z,n=A+B;if(i){let q=Z(N[t+U],N[A+U]);x=q.a,d=q.b,q=Z(N[V+U],N[n+U]),J=q.a,r=q.b,q=Z(x,J),N[t+U]=q.a,N[V+U]=q.b,q=Z(d,r),N[A+U]=q.a,N[n+U]=q.b}else{let q=b(N[t+U],N[A+U]);x=q.a,d=q.b,q=b(N[V+U],N[n+U]),J=q.a,r=q.b,q=b(x,J),N[t+U]=q.a,N[V+U]=q.b,q=b(d,r),N[A+U]=q.a,N[n+U]=q.b}}if(V&p){const V=t+z;let A;A=i?Z(N[t+U],N[V+U]):b(N[t+U],N[V+U]),x=A.a,N[V+U]=A.b,N[t+U]=x}}if(t&p){let t=E;const n=E+A*(V-S);for(;t<=n;t+=C){const V=t+B;let A;A=i?Z(N[t+U],N[V+U]):b(N[t+U],N[V+U]),x=A.a,N[V+U]=A.b,N[t+U]=x}}S=p,p>>=1}return E}function NN(N){return new DataView(N.array.buffer,N.offset.value,N.size)}function UN(N){const U=N.viewer.buffer.slice(N.offset.value,N.offset.value+N.size),V=new Uint8Array(function(N){let U=N.byteLength;const V=[];let A=0;const t=new DataView(N);for(;U>0;){const N=t.getInt8(A++);if(N<0){const n=-N;U-=n+1;for(let N=0;N<n;N++)V.push(t.getUint8(A++))}else{const n=N;U-=2;const q=t.getUint8(A++);for(let N=0;N<n+1;N++)V.push(q)}}return V}(U)),A=new Uint8Array(V.length);return u(V),L(V,A),new DataView(A.buffer)}function VN(N){const U=N.array.slice(N.offset.value,N.offset.value+N.size),V=fflate.unzlibSync(U),A=new Uint8Array(V.length);return u(V),L(V,A),new DataView(A.buffer)}function AN(N){const U=N.array.slice(N.offset.value,N.offset.value+N.size),V=fflate.unzlibSync(U),A=N.lines*N.channels*N.width,t=1==N.type?new Uint16Array(A):new Uint32Array(A);let n=0,q=0;const i=new Array(4);for(let z=0;z<N.lines;z++)for(let U=0;U<N.channels;U++){let U=0;switch(N.type){case 1:i[0]=n,i[1]=i[0]+N.width,n=i[1]+N.width;for(let A=0;A<N.width;++A){U+=V[i[0]++]<<8|V[i[1]++],t[q]=U,q++}break;case 2:i[0]=n,i[1]=i[0]+N.width,i[2]=i[1]+N.width,n=i[2]+N.width;for(let A=0;A<N.width;++A){U+=V[i[0]++]<<24|V[i[1]++]<<16|V[i[2]++]<<8,t[q]=U,q++}}}return new DataView(t.buffer)}function tN(N){const U=N.viewer,V={value:N.offset.value},A=new Uint16Array(N.width*N.scanlineBlockSize*(N.channels*N.type)),t=new Uint8Array(p);let n=0;const q=new Array(N.channels);for(let z=0;z<N.channels;z++)q[z]={},q[z].start=n,q[z].end=q[z].start,q[z].nx=N.width,q[z].ny=N.lines,q[z].size=N.type,n+=q[z].nx*q[z].ny*q[z].size;const i=M(U,V),S=M(U,V);if(S>=p)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(i<=S)for(let z=0;z<S-i+1;z++)t[z+i]=s(U,V);const k=new Uint16Array(E),B=function(N,U){let V=0;for(let t=0;t<E;++t)(0==t||N[t>>3]&1<<(7&t))&&(U[V++]=t);const A=V-1;for(;V<E;)U[V++]=0;return A}(t,k),C=W(U,V);T(N.array,U,V,C,A,n);for(let z=0;z<N.channels;++z){const N=q[z];for(let U=0;U<q[z].size;++U)y(A,N.start+U,N.nx,N.size,N.ny,N.nx*N.size,B)}!function(N,U,V){for(let A=0;A<V;++A)U[A]=N[U[A]]}(k,A,n);let x=0;const J=new Uint8Array(A.buffer.byteLength);for(let E=0;E<N.lines;E++)for(let U=0;U<N.channels;U++){const N=q[U],V=N.nx*N.size,t=new Uint8Array(A.buffer,N.end*z,V*z);J.set(t,x),x+=V*z,N.end+=V}return new DataView(J.buffer)}var nN,qN=V(12179);!function(N){N[N.Float=0]="Float",N[N.HalfFloat=1]="HalfFloat"}(nN||(nN={}));class iN{}async function zN(N,U,V,A){const t={size:0,viewer:U,array:new Uint8Array(U.buffer),offset:V,width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,channels:N.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(N.compression){case v.NO_COMPRESSION:t.lines=1,t.uncompress=NN;break;case v.RLE_COMPRESSION:t.lines=1,t.uncompress=UN;break;case v.ZIPS_COMPRESSION:t.lines=1,t.uncompress=VN,await qN.Tools.LoadScriptAsync(iN.FFLATEUrl);break;case v.ZIP_COMPRESSION:t.lines=16,t.uncompress=VN,await qN.Tools.LoadScriptAsync(iN.FFLATEUrl);break;case v.PIZ_COMPRESSION:t.lines=32,t.uncompress=tN;break;case v.PXR24_COMPRESSION:t.lines=16,t.uncompress=AN,await qN.Tools.LoadScriptAsync(iN.FFLATEUrl);break;default:throw new Error(v[N.compression]+" is unsupported")}t.scanlineBlockSize=t.lines;const n={};for(const q of N.channels)switch(q.name){case"R":case"G":case"B":case"A":case"Y":n[q.name]=!0,t.type=q.pixelType}let i=!1;if(n.R&&n.G&&n.B&&n.A)t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G&&n.B)i=!0,t.outputChannels=4,t.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G)t.outputChannels=2,t.decodeChannels={R:0,G:1};else if(n.R)t.outputChannels=1,t.decodeChannels={R:0};else{if(!n.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");t.outputChannels=1,t.decodeChannels={Y:0}}if(1===t.type)switch(A){case nN.Float:t.getter=X,t.inputSize=z;break;case nN.HalfFloat:t.getter=M,t.inputSize=z}else{if(2!==t.type)throw new Error("Unsupported pixelType "+t.type+" for "+N.compression);switch(A){case nN.Float:t.getter=w,t.inputSize=q;break;case nN.HalfFloat:t.getter=e,t.inputSize=q}}t.blockCount=t.height/t.scanlineBlockSize;for(let q=0;q<t.blockCount;q++)mN(U,V);const S=t.width*t.height*t.outputChannels;switch(A){case nN.Float:t.byteArray=new Float32Array(S),t.textureType=1,i&&t.byteArray.fill(1,0,S);break;case nN.HalfFloat:t.byteArray=new Uint16Array(S),t.textureType=2,i&&t.byteArray.fill(15360,0,S);break;default:throw new Error("Unsupported type: "+A)}let E=0;for(const q of N.channels)void 0!==t.decodeChannels[q.name]&&(t.channelLineOffsets[q.name]=E*t.width),E+=2*q.pixelType;return t.bytesPerLine=t.width*E,t.outLineWidth=t.width*t.outputChannels,"INCREASING_Y"===N.lineOrder?t.scanOrder=N=>N:t.scanOrder=N=>t.height-1-N,4==t.outputChannels?(t.format=5,t.linearSpace=!0):(t.format=6,t.linearSpace=!1),t}function SN(N,U,V,A){const t={value:0};for(let n=0;n<N.height/N.scanlineBlockSize;n++){const q=Y(V,A)-U.dataWindow.yMin;N.size=W(V,A),N.lines=q+N.scanlineBlockSize>N.height?N.height-q:N.scanlineBlockSize;const i=N.size<N.lines*N.bytesPerLine&&N.uncompress?N.uncompress(N):NN(N);A.value+=N.size;for(let V=0;V<N.scanlineBlockSize;V++){const A=n*N.scanlineBlockSize,q=V+N.scanOrder(A);if(q>=N.height)continue;const z=V*N.bytesPerLine,S=(N.height-1-q)*N.outLineWidth;for(let V=0;V<N.channels;V++){const A=U.channels[V].name,n=N.channelLineOffsets[A],q=N.decodeChannels[A];if(void 0!==q){t.value=z+n;for(let U=0;U<N.width;U++){const V=S+U*N.outputChannels+q;N.byteArray&&(N.byteArray[V]=N.getter(i,t))}}}}}}iN.DefaultOutputType=nN.HalfFloat,iN.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class EN{constructor(){this.supportCascades=!1}loadCubeData(N,U,V,A,t){throw".exr not supported in Cube."}loadData(N,U,V){const t=new DataView(N.buffer),n={value:0},q=o(t,n);zN(q,t,n,iN.DefaultOutputType).then((N=>{SN(N,q,t,n);const A=q.dataWindow.xMax-q.dataWindow.xMin+1,i=q.dataWindow.yMax-q.dataWindow.yMin+1;V(A,i,U.generateMipMaps,!1,(()=>{const V=U.getEngine();U.format=q.format,U.type=N.textureType,U.invertY=!1,U._gammaSpace=!q.linearSpace,N.byteArray&&V._uploadDataToTextureDirectly(U,N.byteArray,0,0,void 0,!0)}))})).catch((N=>{A.b.Error("Failed to load EXR texture: ",N)}))}}async function pN(N){const U=new DataView(N),V={value:0},t=o(U,V);try{const N=await zN(t,U,V,nN.Float);return SN(N,t,U,V),N.byteArray?{width:t.dataWindow.xMax-t.dataWindow.xMin+1,height:t.dataWindow.yMax-t.dataWindow.yMin+1,data:new Float32Array(N.byteArray)}:(A.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(n){A.b.Error("Failed to load EXR data: ",n)}return{width:0,height:0,data:null}}},12395:(N,U,V)=>{function A(N){return parseInt(N.toString().replace(/\W/g,""))}function t(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(N-U)<=V}function n(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return N<U-A||N>V+A}function q(N,U){return N===U?N:Math.random()*(U-N)+N}function i(N,U,V){return N+(U-N)*V}function z(N,U,V){let A=J(U-N,360);return A>180&&(A-=360),N+A*k(V)}function S(N,U,V){let A=0;return A=N!=U?k((V-N)/(U-N)):0,A}function E(N,U,V,A,t){const n=t*t,q=t*n;return N*(2*q-3*n+1)+V*(-2*q+3*n)+U*(q-2*n+t)+A*(q-n)}function p(N,U,V,A,t){const n=t*t;return 6*(n-t)*N+(3*n-4*t+1)*U+6*(-n+t)*V+(3*n-2*t)*A}function k(N){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(V,Math.max(U,N))}function B(N){return N-=2*Math.PI*Math.floor((N+Math.PI)/(2*Math.PI))}function C(N){const U=N.toString(16);return N<=15?("0"+U).toUpperCase():U.toUpperCase()}function x(N){if(Math.log2)return Math.floor(Math.log2(N));if(N<0)return NaN;if(0===N)return-1/0;let U=0;if(N<1){for(;N<1;)U++,N*=2;U=-U}else if(N>1)for(;N>1;)U++,N=Math.floor(N/2);return U}function J(N,U){return N-Math.floor(N/U)*U}function d(N,U,V){return(N-U)/(V-U)}function r(N,U,V){return N*(V-U)+U}function v(N,U){let V=J(U-N,360);return V>180&&(V-=360),V}function h(N,U){const V=J(N,2*U);return U-Math.abs(V-U)}function c(N,U,V){let A=k(V);return A=-2*A*A*A+3*A*A,U*A+N*(1-A)}function H(N,U,V){let A=0;return A=Math.abs(U-N)<=V?U:N+Math.sign(U-N)*V,A}function Y(N,U,V){const A=v(N,U);let t=0;return t=-V<A&&A<V?U:H(N,U=N+A,V),t}function W(N,U,V){return(N-U)/(V-U)}function s(N,U,V){return(V-U)*N+U}function M(N,U){const V=N%U;return 0===V?U:M(U,V)}V.r(U),V.d(U,{Clamp:()=>k,DeltaAngle:()=>v,Denormalize:()=>r,ExtractAsInt:()=>A,Hermite:()=>E,Hermite1stDerivative:()=>p,HighestCommonFactor:()=>M,ILog2:()=>x,InverseLerp:()=>S,Lerp:()=>i,LerpAngle:()=>z,MoveTowards:()=>H,MoveTowardsAngle:()=>Y,Normalize:()=>d,NormalizeRadians:()=>B,OutsideRange:()=>n,PercentToRange:()=>s,PingPong:()=>h,RandomRange:()=>q,RangeToPercent:()=>W,Repeat:()=>J,SmoothStep:()=>c,ToHex:()=>C,WithinEpsilon:()=>t})}}]);