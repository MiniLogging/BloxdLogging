"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[16],{14275:(Z,h,V)=>{V.r(h),V.d(h,{ReadExrDataAsync:()=>NZ,_ExrTextureLoader:()=>xZ});var v=V(11580),A=V(11748);const H=4,K=4,d=1,a=2,n=8,x=65536,N=x>>3,D=14,k=65537,u=1<<D,F=u-1,b=59,o=63,q=2+o-b;var X,E;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(X||(X={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const j=function(){const Z=new ArrayBuffer(4),h=new Float32Array(Z),V=new Uint32Array(Z),v=new Uint32Array(512),A=new Uint32Array(512);for(let a=0;a<256;++a){const Z=a-127;Z<-27?(v[a]=0,v[256|a]=32768,A[a]=24,A[256|a]=24):Z<-14?(v[a]=1024>>-Z-14,v[256|a]=1024>>-Z-14|32768,A[a]=-Z-1,A[256|a]=-Z-1):Z<=15?(v[a]=Z+15<<10,v[256|a]=Z+15<<10|32768,A[a]=13,A[256|a]=13):Z<128?(v[a]=31744,v[256|a]=64512,A[a]=24,A[256|a]=24):(v[a]=31744,v[256|a]=64512,A[a]=13,A[256|a]=13)}const H=new Uint32Array(2048),K=new Uint32Array(64),d=new Uint32Array(64);for(let a=1;a<1024;++a){let Z=a<<13,h=0;for(;0===(8388608&Z);)Z<<=1,h-=8388608;Z&=-8388609,h+=947912704,H[a]=Z|h}for(let a=1024;a<2048;++a)H[a]=939524096+(a-1024<<13);for(let a=1;a<31;++a)K[a]=a<<23;K[31]=1199570944,K[32]=2147483648;for(let a=33;a<63;++a)K[a]=2147483648+(a-32<<23);K[63]=3347054592;for(let a=1;a<64;++a)32!==a&&(d[a]=1024);return{floatView:h,uint32View:V,baseTable:v,shiftTable:A,mantissaTable:H,exponentTable:K,offsetTable:d}}();function P(Z,h){const V=new Uint8Array(Z);let v=0;for(;0!=V[h.value+v];)v+=1;const A=(new TextDecoder).decode(V.slice(h.value,h.value+v));return h.value=h.value+v+1,A}function C(Z,h){const V=Z.getInt32(h.value,!0);return h.value+=H,V}function l(Z,h){const V=Z.getUint32(h.value,!0);return h.value+=H,V}function B(Z,h){const V=Z.getUint8(h.value);return h.value+=d,V}function S(Z,h){const V=Z.getUint16(h.value,!0);return h.value+=a,V}function r(Z,h){const V=Z[h.value];return h.value+=d,V}function L(Z,h){let V;return V="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(h.value,!0)):Z.getUint32(h.value+4,!0)+Number(Z.getUint32(h.value,!0)<<32),h.value+=n,V}function y(Z,h){const V=Z.getFloat32(h.value,!0);return h.value+=K,V}function W(Z,h){return function(Z){const h=(31744&Z)>>10,V=1023&Z;return(Z>>15?-1:1)*(h?31===h?V?NaN:1/0:Math.pow(2,h-15)*(1+V/1024):V/1024*6103515625e-14)}(S(Z,h))}function z(Z,h){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,A.Clamp)(Z,-65504,65504),j.floatView[0]=Z;const h=j.uint32View[0],V=h>>23&511;return j.baseTable[V]+((8388607&h)>>j.shiftTable[V])}(y(Z,h))}function m(Z,h,V,v){switch(V){case"string":case"stringvector":case"iccProfile":return function(Z,h,V){const v=(new TextDecoder).decode(new Uint8Array(Z).slice(h.value,h.value+V));return h.value=h.value+V,v}(Z.buffer,h,v);case"chlist":return function(Z,h,V){const v=h.value,A=[];for(;h.value<v+V-1;){const V=P(Z.buffer,h),v=C(Z,h),H=B(Z,h);h.value+=3;const K=C(Z,h),d=C(Z,h);A.push({name:V,pixelType:v,pLinear:H,xSampling:K,ySampling:d})}return h.value+=1,A}(Z,h,v);case"chromaticities":return function(Z,h){return{redX:y(Z,h),redY:y(Z,h),greenX:y(Z,h),greenY:y(Z,h),blueX:y(Z,h),blueY:y(Z,h),whiteX:y(Z,h),whiteY:y(Z,h)}}(Z,h);case"compression":return function(Z,h){return B(Z,h)}(Z,h);case"box2i":return function(Z,h){return{xMin:C(Z,h),yMin:C(Z,h),xMax:C(Z,h),yMax:C(Z,h)}}(Z,h);case"lineOrder":return function(Z,h){const V=B(Z,h);return E[V]}(Z,h);case"float":return y(Z,h);case"v2f":return function(Z,h){return[y(Z,h),y(Z,h)]}(Z,h);case"v3f":return function(Z,h){return[y(Z,h),y(Z,h),y(Z,h)]}(Z,h);case"int":return C(Z,h);case"rational":return function(Z,h){return[C(Z,h),l(Z,h)]}(Z,h);case"timecode":return function(Z,h){return[l(Z,h),l(Z,h)]}(Z,h);case"preview":return h.value+=v,"skipped";default:return void(h.value+=v)}}function g(Z){for(let h=1;h<Z.length;h++){const V=Z[h-1]+Z[h]-128;Z[h]=V}}function I(Z,h){let V=0,v=Math.floor((Z.length+1)/2),A=0;const H=Z.length-1;for(;!(A>H)&&(h[A++]=Z[V++],!(A>H));)h[A++]=Z[v++]}const e=20000630;function U(Z,h){if(Z.getUint32(0,!0)!=e)throw new Error("Incorrect OpenEXR format");const V=Z.getUint8(4),A=Z.getUint8(5),H={singleTile:!!(2&A),longName:!!(4&A),deepFormat:!!(8&A),multiPart:!!(16&A)};h.value=8;const K={};let d=!0;for(;d;){const V=P(Z.buffer,h);if(V){const A=P(Z.buffer,h),H=m(Z,h,A,l(Z,h));void 0===H?v.b.Warn(`Unknown header attribute type ${A}'.`):K[V]=H}else d=!1}if(0!=(-5&A))throw new Error("Unsupported file format");return{version:V,spec:H,...K}}const R=32768,Q=65535;function w(Z,h,V,v,A){for(;V<Z;)h=h<<8|r(v,A),V+=8;return{l:h>>(V-=Z)&(1<<Z)-1,c:h,lc:V}}function T(Z,h,V,v){return{c:Z=Z<<8|r(V,v),lc:h+=8}}function t(Z,h,V,v,A,H,K,d,a){if(Z==h){if(v<8){const Z=T(V,v,A,H);V=Z.c,v=Z.lc}let Z=V>>(v-=8);if(Z=new Uint8Array([Z])[0],d.value+Z>a)return null;const h=K[d.value-1];for(;Z-- >0;)K[d.value++]=h}else{if(!(d.value<a))return null;K[d.value++]=Z}return{c:V,lc:v}}const c=new Array(59);function i(Z,h,V,v,A,H){const K=h;let d=0,a=0;for(;v<=A;v++){if(K.value-h.value>V)return;let n=w(6,d,a,Z,K);const x=n.l;if(d=n.c,a=n.lc,H[v]=x,x==o){if(K.value-h.value>V)throw new Error("Error in HufUnpackEncTable");n=w(8,d,a,Z,K);let x=n.l+q;if(d=n.c,a=n.lc,v+x>A+1)throw new Error("Error in HufUnpackEncTable");for(;x--;)H[v++]=0;v--}else if(x>=b){let Z=x-b+2;if(v+Z>A+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)H[v++]=0;v--}}!function(Z){for(let V=0;V<=58;++V)c[V]=0;for(let V=0;V<k;++V)c[Z[V]]+=1;let h=0;for(let V=58;V>0;--V){const Z=h+c[V]>>1;c[V]=h,h=Z}for(let V=0;V<k;++V){const h=Z[V];h>0&&(Z[V]=h|c[h]++<<6)}}(H)}function M(Z){return 63&Z}function O(Z){return Z>>6}function s(Z,h,V,v,A,H){const K=V.value,d=l(h,V),a=l(h,V);V.value+=4;const n=l(h,V);if(V.value+=4,d<0||d>=k||a<0||a>=k)throw new Error("Wrong HUF_ENCSIZE");const x=new Array(k),N=new Array(u);!function(Z){for(let h=0;h<u;h++)Z[h]={},Z[h].len=0,Z[h].lit=0,Z[h].p=null}(N);if(i(Z,V,v-(V.value-K),d,a,x),n>8*(v-(V.value-K)))throw new Error("Wrong hufUncompress");!function(Z,h,V,v){for(;h<=V;h++){const V=O(Z[h]),A=M(Z[h]);if(V>>A)throw new Error("Invalid table entry");if(A>D){const Z=v[V>>A-D];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const h=Z.p;Z.p=new Array(Z.lit);for(let V=0;V<Z.lit-1;++V)Z.p[V]=h[V]}else Z.p=new Array(1);Z.p[Z.lit-1]=h}else if(A){let Z=0;for(let H=1<<D-A;H>0;H--){const H=v[(V<<D-A)+Z];if(H.len||H.p)throw new Error("Invalid table entry");H.len=A,H.lit=h,Z++}}}}(x,d,a,N),function(Z,h,V,v,A,H,K,d,a){let n=0,x=0;const N=K,k=Math.trunc(v.value+(A+7)/8);for(;v.value<k;){let A=T(n,x,V,v);for(n=A.c,x=A.lc;x>=D;){const K=h[n>>x-D&F];if(K.len){x-=K.len;const Z=t(K.lit,H,n,x,V,v,d,a,N);Z&&(n=Z.c,x=Z.lc)}else{if(!K.p)throw new Error("hufDecode issues");let h;for(h=0;h<K.lit;h++){const D=M(Z[K.p[h]]);for(;x<D&&v.value<k;)A=T(n,x,V,v),n=A.c,x=A.lc;if(x>=D&&O(Z[K.p[h]])==(n>>x-D&(1<<D)-1)){x-=D;const Z=t(K.p[h],H,n,x,V,v,d,a,N);Z&&(n=Z.c,x=Z.lc);break}}if(h==K.lit)throw new Error("HufDecode issues")}}}const u=8-A&7;for(n>>=u,x-=u;x>0;){const Z=h[n<<D-x&F];if(!Z.len)throw new Error("HufDecode issues");{x-=Z.len;const h=t(Z.lit,H,n,x,V,v,d,a,N);h&&(n=h.c,x=h.lc)}}}(x,N,Z,V,n,a,H,A,{value:0})}function J(Z){return 65535&Z}function f(Z){const h=J(Z);return h>32767?h-65536:h}function p(Z,h){const V=f(Z),v=f(h),A=V+(1&v)+(v>>1);return{a:A,b:A-v}}function Y(Z,h){const V=J(Z),v=J(h),A=V-(v>>1)&Q;return{a:v+A-R&Q,b:A}}function G(Z,h,V,v,A,H,K){const d=K<16384,a=V>A?A:V;let n,x,N=1;for(;N<=a;)N<<=1;for(N>>=1,n=N,N>>=1;N>=1;){x=0;const K=x+H*(A-n),a=H*N,D=H*n,k=v*N,u=v*n;let F,b,o,q;for(;x<=K;x+=D){let A=x;const H=x+v*(V-n);for(;A<=H;A+=u){const V=A+k,v=A+a,H=v+k;if(d){let K=p(Z[A+h],Z[v+h]);F=K.a,o=K.b,K=p(Z[V+h],Z[H+h]),b=K.a,q=K.b,K=p(F,b),Z[A+h]=K.a,Z[V+h]=K.b,K=p(o,q),Z[v+h]=K.a,Z[H+h]=K.b}else{let K=Y(Z[A+h],Z[v+h]);F=K.a,o=K.b,K=Y(Z[V+h],Z[H+h]),b=K.a,q=K.b,K=Y(F,b),Z[A+h]=K.a,Z[V+h]=K.b,K=Y(o,q),Z[v+h]=K.a,Z[H+h]=K.b}}if(V&N){const V=A+a;let v;v=d?p(Z[A+h],Z[V+h]):Y(Z[A+h],Z[V+h]),F=v.a,Z[V+h]=v.b,Z[A+h]=F}}if(A&N){let A=x;const H=x+v*(V-n);for(;A<=H;A+=u){const V=A+k;let v;v=d?p(Z[A+h],Z[V+h]):Y(Z[A+h],Z[V+h]),F=v.a,Z[V+h]=v.b,Z[A+h]=F}}n=N,N>>=1}return x}function ZZ(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function hZ(Z){const h=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),V=new Uint8Array(function(Z){let h=Z.byteLength;const V=[];let v=0;const A=new DataView(Z);for(;h>0;){const Z=A.getInt8(v++);if(Z<0){const H=-Z;h-=H+1;for(let Z=0;Z<H;Z++)V.push(A.getUint8(v++))}else{const H=Z;h-=2;const K=A.getUint8(v++);for(let Z=0;Z<H+1;Z++)V.push(K)}}return V}(h)),v=new Uint8Array(V.length);return g(V),I(V,v),new DataView(v.buffer)}function VZ(Z){const h=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),V=fflate.unzlibSync(h),v=new Uint8Array(V.length);return g(V),I(V,v),new DataView(v.buffer)}function vZ(Z){const h=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),V=fflate.unzlibSync(h),v=Z.lines*Z.channels*Z.width,A=1==Z.type?new Uint16Array(v):new Uint32Array(v);let H=0,K=0;const d=new Array(4);for(let a=0;a<Z.lines;a++)for(let h=0;h<Z.channels;h++){let h=0;switch(Z.type){case 1:d[0]=H,d[1]=d[0]+Z.width,H=d[1]+Z.width;for(let v=0;v<Z.width;++v){h+=V[d[0]++]<<8|V[d[1]++],A[K]=h,K++}break;case 2:d[0]=H,d[1]=d[0]+Z.width,d[2]=d[1]+Z.width,H=d[2]+Z.width;for(let v=0;v<Z.width;++v){h+=V[d[0]++]<<24|V[d[1]++]<<16|V[d[2]++]<<8,A[K]=h,K++}}}return new DataView(A.buffer)}function AZ(Z){const h=Z.viewer,V={value:Z.offset.value},v=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),A=new Uint8Array(N);let H=0;const K=new Array(Z.channels);for(let a=0;a<Z.channels;a++)K[a]={},K[a].start=H,K[a].end=K[a].start,K[a].nx=Z.width,K[a].ny=Z.lines,K[a].size=Z.type,H+=K[a].nx*K[a].ny*K[a].size;const d=S(h,V),n=S(h,V);if(n>=N)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(d<=n)for(let a=0;a<n-d+1;a++)A[a+d]=B(h,V);const D=new Uint16Array(x),k=function(Z,h){let V=0;for(let A=0;A<x;++A)(0==A||Z[A>>3]&1<<(7&A))&&(h[V++]=A);const v=V-1;for(;V<x;)h[V++]=0;return v}(A,D),u=l(h,V);s(Z.array,h,V,u,v,H);for(let a=0;a<Z.channels;++a){const Z=K[a];for(let h=0;h<K[a].size;++h)G(v,Z.start+h,Z.nx,Z.size,Z.ny,Z.nx*Z.size,k)}!function(Z,h,V){for(let v=0;v<V;++v)h[v]=Z[h[v]]}(D,v,H);let F=0;const b=new Uint8Array(v.buffer.byteLength);for(let x=0;x<Z.lines;x++)for(let h=0;h<Z.channels;h++){const Z=K[h],V=Z.nx*Z.size,A=new Uint8Array(v.buffer,Z.end*a,V*a);b.set(A,F),F+=V*a,Z.end+=V}return new DataView(b.buffer)}var HZ,KZ=V(11564);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(HZ||(HZ={}));class dZ{}async function aZ(Z,h,V,v){const A={size:0,viewer:h,array:new Uint8Array(h.buffer),offset:V,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case X.NO_COMPRESSION:A.lines=1,A.uncompress=ZZ;break;case X.RLE_COMPRESSION:A.lines=1,A.uncompress=hZ;break;case X.ZIPS_COMPRESSION:A.lines=1,A.uncompress=VZ,await KZ.Tools.LoadScriptAsync(dZ.FFLATEUrl);break;case X.ZIP_COMPRESSION:A.lines=16,A.uncompress=VZ,await KZ.Tools.LoadScriptAsync(dZ.FFLATEUrl);break;case X.PIZ_COMPRESSION:A.lines=32,A.uncompress=AZ;break;case X.PXR24_COMPRESSION:A.lines=16,A.uncompress=vZ,await KZ.Tools.LoadScriptAsync(dZ.FFLATEUrl);break;default:throw new Error(X[Z.compression]+" is unsupported")}A.scanlineBlockSize=A.lines;const H={};for(const K of Z.channels)switch(K.name){case"R":case"G":case"B":case"A":case"Y":H[K.name]=!0,A.type=K.pixelType}let d=!1;if(H.R&&H.G&&H.B&&H.A)A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(H.R&&H.G&&H.B)d=!0,A.outputChannels=4,A.decodeChannels={R:0,G:1,B:2,A:3};else if(H.R&&H.G)A.outputChannels=2,A.decodeChannels={R:0,G:1};else if(H.R)A.outputChannels=1,A.decodeChannels={R:0};else{if(!H.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");A.outputChannels=1,A.decodeChannels={Y:0}}if(1===A.type)switch(v){case HZ.Float:A.getter=W,A.inputSize=a;break;case HZ.HalfFloat:A.getter=S,A.inputSize=a}else{if(2!==A.type)throw new Error("Unsupported pixelType "+A.type+" for "+Z.compression);switch(v){case HZ.Float:A.getter=y,A.inputSize=K;break;case HZ.HalfFloat:A.getter=z,A.inputSize=K}}A.blockCount=A.height/A.scanlineBlockSize;for(let K=0;K<A.blockCount;K++)L(h,V);const n=A.width*A.height*A.outputChannels;switch(v){case HZ.Float:A.byteArray=new Float32Array(n),A.textureType=1,d&&A.byteArray.fill(1,0,n);break;case HZ.HalfFloat:A.byteArray=new Uint16Array(n),A.textureType=2,d&&A.byteArray.fill(15360,0,n);break;default:throw new Error("Unsupported type: "+v)}let x=0;for(const K of Z.channels)void 0!==A.decodeChannels[K.name]&&(A.channelLineOffsets[K.name]=x*A.width),x+=2*K.pixelType;return A.bytesPerLine=A.width*x,A.outLineWidth=A.width*A.outputChannels,"INCREASING_Y"===Z.lineOrder?A.scanOrder=Z=>Z:A.scanOrder=Z=>A.height-1-Z,4==A.outputChannels?(A.format=5,A.linearSpace=!0):(A.format=6,A.linearSpace=!1),A}function nZ(Z,h,V,v){const A={value:0};for(let H=0;H<Z.height/Z.scanlineBlockSize;H++){const K=C(V,v)-h.dataWindow.yMin;Z.size=l(V,v),Z.lines=K+Z.scanlineBlockSize>Z.height?Z.height-K:Z.scanlineBlockSize;const d=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):ZZ(Z);v.value+=Z.size;for(let V=0;V<Z.scanlineBlockSize;V++){const v=H*Z.scanlineBlockSize,K=V+Z.scanOrder(v);if(K>=Z.height)continue;const a=V*Z.bytesPerLine,n=(Z.height-1-K)*Z.outLineWidth;for(let V=0;V<Z.channels;V++){const v=h.channels[V].name,H=Z.channelLineOffsets[v],K=Z.decodeChannels[v];if(void 0!==K){A.value=a+H;for(let h=0;h<Z.width;h++){const V=n+h*Z.outputChannels+K;Z.byteArray&&(Z.byteArray[V]=Z.getter(d,A))}}}}}}dZ.DefaultOutputType=HZ.HalfFloat,dZ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class xZ{constructor(){this.supportCascades=!1}loadCubeData(Z,h,V,v,A){throw".exr not supported in Cube."}loadData(Z,h,V){const A=new DataView(Z.buffer),H={value:0},K=U(A,H);aZ(K,A,H,dZ.DefaultOutputType).then((Z=>{nZ(Z,K,A,H);const v=K.dataWindow.xMax-K.dataWindow.xMin+1,d=K.dataWindow.yMax-K.dataWindow.yMin+1;V(v,d,h.generateMipMaps,!1,(()=>{const V=h.getEngine();h.format=K.format,h.type=Z.textureType,h.invertY=!1,h._gammaSpace=!K.linearSpace,Z.byteArray&&V._uploadDataToTextureDirectly(h,Z.byteArray,0,0,void 0,!0)}))})).catch((Z=>{v.b.Error("Failed to load EXR texture: ",Z)}))}}async function NZ(Z){const h=new DataView(Z),V={value:0},A=U(h,V);try{const Z=await aZ(A,h,V,HZ.Float);return nZ(Z,A,h,V),Z.byteArray?{width:A.dataWindow.xMax-A.dataWindow.xMin+1,height:A.dataWindow.yMax-A.dataWindow.yMin+1,data:new Float32Array(Z.byteArray)}:(v.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(H){v.b.Error("Failed to load EXR data: ",H)}return{width:0,height:0,data:null}}},11748:(Z,h,V)=>{function v(Z){return parseInt(Z.toString().replace(/\W/g,""))}function A(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1401298e-51;return Math.abs(Z-h)<=V}function H(Z,h,V){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1401298e-51;return Z<h-v||Z>V+v}function K(Z,h){return Z===h?Z:Math.random()*(h-Z)+Z}function d(Z,h,V){return Z+(h-Z)*V}function a(Z,h,V){let v=b(h-Z,360);return v>180&&(v-=360),Z+v*D(V)}function n(Z,h,V){let v=0;return v=Z!=h?D((V-Z)/(h-Z)):0,v}function x(Z,h,V,v,A){const H=A*A,K=A*H;return Z*(2*K-3*H+1)+V*(-2*K+3*H)+h*(K-2*H+A)+v*(K-H)}function N(Z,h,V,v,A){const H=A*A;return 6*(H-A)*Z+(3*H-4*A+1)*h+6*(-H+A)*V+(3*H-2*A)*v}function D(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return Math.min(V,Math.max(h,Z))}function k(Z){return Z-=2*Math.PI*Math.floor((Z+Math.PI)/(2*Math.PI))}function u(Z){const h=Z.toString(16);return Z<=15?("0"+h).toUpperCase():h.toUpperCase()}function F(Z){if(Math.log2)return Math.floor(Math.log2(Z));if(Z<0)return NaN;if(0===Z)return-1/0;let h=0;if(Z<1){for(;Z<1;)h++,Z*=2;h=-h}else if(Z>1)for(;Z>1;)h++,Z=Math.floor(Z/2);return h}function b(Z,h){return Z-Math.floor(Z/h)*h}function o(Z,h,V){return(Z-h)/(V-h)}function q(Z,h,V){return Z*(V-h)+h}function X(Z,h){let V=b(h-Z,360);return V>180&&(V-=360),V}function E(Z,h){const V=b(Z,2*h);return h-Math.abs(V-h)}function j(Z,h,V){let v=D(V);return v=-2*v*v*v+3*v*v,h*v+Z*(1-v)}function P(Z,h,V){let v=0;return v=Math.abs(h-Z)<=V?h:Z+Math.sign(h-Z)*V,v}function C(Z,h,V){const v=X(Z,h);let A=0;return A=-V<v&&v<V?h:P(Z,h=Z+v,V),A}function l(Z,h,V){return(Z-h)/(V-h)}function B(Z,h,V){return(V-h)*Z+h}function S(Z,h){const V=Z%h;return 0===V?h:S(h,V)}V.r(h),V.d(h,{Clamp:()=>D,DeltaAngle:()=>X,Denormalize:()=>q,ExtractAsInt:()=>v,Hermite:()=>x,Hermite1stDerivative:()=>N,HighestCommonFactor:()=>S,ILog2:()=>F,InverseLerp:()=>n,Lerp:()=>d,LerpAngle:()=>a,MoveTowards:()=>P,MoveTowardsAngle:()=>C,Normalize:()=>o,NormalizeRadians:()=>k,OutsideRange:()=>H,PercentToRange:()=>B,PingPong:()=>E,RandomRange:()=>K,RangeToPercent:()=>l,Repeat:()=>b,SmoothStep:()=>j,ToHex:()=>u,WithinEpsilon:()=>A})}}]);