"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13244:(z,u,Y)=>{Y.r(u),Y.d(u,{ReadExrDataAsync:()=>gz,_ExrTextureLoader:()=>Dz});var H=Y(10953),E=Y(10937);const J=4,l=4,T=1,b=2,L=8,D=65536,g=D>>3,M=14,q=65537,C=1<<M,K=C-1,h=59,o=63,d=2+o-h;var t,W;!function(z){z[z.NO_COMPRESSION=0]="NO_COMPRESSION",z[z.RLE_COMPRESSION=1]="RLE_COMPRESSION",z[z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",z[z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",z[z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",z[z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(t||(t={})),function(z){z[z.INCREASING_Y=0]="INCREASING_Y",z[z.DECREASING_Y=1]="DECREASING_Y"}(W||(W={}));const Z=function(){const z=new ArrayBuffer(4),u=new Float32Array(z),Y=new Uint32Array(z),H=new Uint32Array(512),E=new Uint32Array(512);for(let b=0;b<256;++b){const z=b-127;z<-27?(H[b]=0,H[256|b]=32768,E[b]=24,E[256|b]=24):z<-14?(H[b]=1024>>-z-14,H[256|b]=1024>>-z-14|32768,E[b]=-z-1,E[256|b]=-z-1):z<=15?(H[b]=z+15<<10,H[256|b]=z+15<<10|32768,E[b]=13,E[256|b]=13):z<128?(H[b]=31744,H[256|b]=64512,E[b]=24,E[256|b]=24):(H[b]=31744,H[256|b]=64512,E[b]=13,E[256|b]=13)}const J=new Uint32Array(2048),l=new Uint32Array(64),T=new Uint32Array(64);for(let b=1;b<1024;++b){let z=b<<13,u=0;for(;0===(8388608&z);)z<<=1,u-=8388608;z&=-8388609,u+=947912704,J[b]=z|u}for(let b=1024;b<2048;++b)J[b]=939524096+(b-1024<<13);for(let b=1;b<31;++b)l[b]=b<<23;l[31]=1199570944,l[32]=2147483648;for(let b=33;b<63;++b)l[b]=2147483648+(b-32<<23);l[63]=3347054592;for(let b=1;b<64;++b)32!==b&&(T[b]=1024);return{floatView:u,uint32View:Y,baseTable:H,shiftTable:E,mantissaTable:J,exponentTable:l,offsetTable:T}}();function s(z,u){const Y=new Uint8Array(z);let H=0;for(;0!=Y[u.value+H];)H+=1;const E=(new TextDecoder).decode(Y.slice(u.value,u.value+H));return u.value=u.value+H+1,E}function v(z,u){const Y=z.getInt32(u.value,!0);return u.value+=J,Y}function i(z,u){const Y=z.getUint32(u.value,!0);return u.value+=J,Y}function X(z,u){const Y=z.getUint8(u.value);return u.value+=T,Y}function Q(z,u){const Y=z.getUint16(u.value,!0);return u.value+=b,Y}function V(z,u){const Y=z[u.value];return u.value+=T,Y}function A(z,u){let Y;return Y="getBigInt64"in DataView.prototype?Number(z.getBigInt64(u.value,!0)):z.getUint32(u.value+4,!0)+Number(z.getUint32(u.value,!0)<<32),u.value+=L,Y}function x(z,u){const Y=z.getFloat32(u.value,!0);return u.value+=l,Y}function G(z,u){return function(z){const u=(31744&z)>>10,Y=1023&z;return(z>>15?-1:1)*(u?31===u?Y?NaN:1/0:Math.pow(2,u-15)*(1+Y/1024):Y/1024*6103515625e-14)}(Q(z,u))}function F(z,u){return function(z){if(Math.abs(z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");z=(0,E.Clamp)(z,-65504,65504),Z.floatView[0]=z;const u=Z.uint32View[0],Y=u>>23&511;return Z.baseTable[Y]+((8388607&u)>>Z.shiftTable[Y])}(x(z,u))}function R(z,u,Y,H){switch(Y){case"string":case"stringvector":case"iccProfile":return function(z,u,Y){const H=(new TextDecoder).decode(new Uint8Array(z).slice(u.value,u.value+Y));return u.value=u.value+Y,H}(z.buffer,u,H);case"chlist":return function(z,u,Y){const H=u.value,E=[];for(;u.value<H+Y-1;){const Y=s(z.buffer,u),H=v(z,u),J=X(z,u);u.value+=3;const l=v(z,u),T=v(z,u);E.push({name:Y,pixelType:H,pLinear:J,xSampling:l,ySampling:T})}return u.value+=1,E}(z,u,H);case"chromaticities":return function(z,u){return{redX:x(z,u),redY:x(z,u),greenX:x(z,u),greenY:x(z,u),blueX:x(z,u),blueY:x(z,u),whiteX:x(z,u),whiteY:x(z,u)}}(z,u);case"compression":return function(z,u){return X(z,u)}(z,u);case"box2i":return function(z,u){return{xMin:v(z,u),yMin:v(z,u),xMax:v(z,u),yMax:v(z,u)}}(z,u);case"lineOrder":return function(z,u){const Y=X(z,u);return W[Y]}(z,u);case"float":return x(z,u);case"v2f":return function(z,u){return[x(z,u),x(z,u)]}(z,u);case"v3f":return function(z,u){return[x(z,u),x(z,u),x(z,u)]}(z,u);case"int":return v(z,u);case"rational":return function(z,u){return[v(z,u),i(z,u)]}(z,u);case"timecode":return function(z,u){return[i(z,u),i(z,u)]}(z,u);case"preview":return u.value+=H,"skipped";default:return void(u.value+=H)}}function w(z){for(let u=1;u<z.length;u++){const Y=z[u-1]+z[u]-128;z[u]=Y}}function c(z,u){let Y=0,H=Math.floor((z.length+1)/2),E=0;const J=z.length-1;for(;!(E>J)&&(u[E++]=z[Y++],!(E>J));)u[E++]=z[H++]}const U=20000630;function O(z,u){if(z.getUint32(0,!0)!=U)throw new Error("Incorrect OpenEXR format");const Y=z.getUint8(4),E=z.getUint8(5),J={singleTile:!!(2&E),longName:!!(4&E),deepFormat:!!(8&E),multiPart:!!(16&E)};u.value=8;const l={};let T=!0;for(;T;){const Y=s(z.buffer,u);if(Y){const E=s(z.buffer,u),J=R(z,u,E,i(z,u));void 0===J?H.b.Warn(`Unknown header attribute type ${E}'.`):l[Y]=J}else T=!1}if(0!=(-5&E))throw new Error("Unsupported file format");return{version:Y,spec:J,...l}}const n=32768,m=65535;function p(z,u,Y,H,E){for(;Y<z;)u=u<<8|V(H,E),Y+=8;return{l:u>>(Y-=z)&(1<<z)-1,c:u,lc:Y}}function S(z,u,Y,H){return{c:z=z<<8|V(Y,H),lc:u+=8}}function I(z,u,Y,H,E,J,l,T,b){if(z==u){if(H<8){const z=S(Y,H,E,J);Y=z.c,H=z.lc}let z=Y>>(H-=8);if(z=new Uint8Array([z])[0],T.value+z>b)return null;const u=l[T.value-1];for(;z-- >0;)l[T.value++]=u}else{if(!(T.value<b))return null;l[T.value++]=z}return{c:Y,lc:H}}const y=new Array(59);function a(z,u,Y,H,E,J){const l=u;let T=0,b=0;for(;H<=E;H++){if(l.value-u.value>Y)return;let L=p(6,T,b,z,l);const D=L.l;if(T=L.c,b=L.lc,J[H]=D,D==o){if(l.value-u.value>Y)throw new Error("Error in HufUnpackEncTable");L=p(8,T,b,z,l);let D=L.l+d;if(T=L.c,b=L.lc,H+D>E+1)throw new Error("Error in HufUnpackEncTable");for(;D--;)J[H++]=0;H--}else if(D>=h){let z=D-h+2;if(H+z>E+1)throw new Error("Error in HufUnpackEncTable");for(;z--;)J[H++]=0;H--}}!function(z){for(let Y=0;Y<=58;++Y)y[Y]=0;for(let Y=0;Y<q;++Y)y[z[Y]]+=1;let u=0;for(let Y=58;Y>0;--Y){const z=u+y[Y]>>1;y[Y]=u,u=z}for(let Y=0;Y<q;++Y){const u=z[Y];u>0&&(z[Y]=u|y[u]++<<6)}}(J)}function j(z){return 63&z}function k(z){return z>>6}function P(z,u,Y,H,E,J){const l=Y.value,T=i(u,Y),b=i(u,Y);Y.value+=4;const L=i(u,Y);if(Y.value+=4,T<0||T>=q||b<0||b>=q)throw new Error("Wrong HUF_ENCSIZE");const D=new Array(q),g=new Array(C);!function(z){for(let u=0;u<C;u++)z[u]={},z[u].len=0,z[u].lit=0,z[u].p=null}(g);if(a(z,Y,H-(Y.value-l),T,b,D),L>8*(H-(Y.value-l)))throw new Error("Wrong hufUncompress");!function(z,u,Y,H){for(;u<=Y;u++){const Y=k(z[u]),E=j(z[u]);if(Y>>E)throw new Error("Invalid table entry");if(E>M){const z=H[Y>>E-M];if(z.len)throw new Error("Invalid table entry");if(z.lit++,z.p){const u=z.p;z.p=new Array(z.lit);for(let Y=0;Y<z.lit-1;++Y)z.p[Y]=u[Y]}else z.p=new Array(1);z.p[z.lit-1]=u}else if(E){let z=0;for(let J=1<<M-E;J>0;J--){const J=H[(Y<<M-E)+z];if(J.len||J.p)throw new Error("Invalid table entry");J.len=E,J.lit=u,z++}}}}(D,T,b,g),function(z,u,Y,H,E,J,l,T,b){let L=0,D=0;const g=l,q=Math.trunc(H.value+(E+7)/8);for(;H.value<q;){let E=S(L,D,Y,H);for(L=E.c,D=E.lc;D>=M;){const l=u[L>>D-M&K];if(l.len){D-=l.len;const z=I(l.lit,J,L,D,Y,H,T,b,g);z&&(L=z.c,D=z.lc)}else{if(!l.p)throw new Error("hufDecode issues");let u;for(u=0;u<l.lit;u++){const M=j(z[l.p[u]]);for(;D<M&&H.value<q;)E=S(L,D,Y,H),L=E.c,D=E.lc;if(D>=M&&k(z[l.p[u]])==(L>>D-M&(1<<M)-1)){D-=M;const z=I(l.p[u],J,L,D,Y,H,T,b,g);z&&(L=z.c,D=z.lc);break}}if(u==l.lit)throw new Error("HufDecode issues")}}}const C=8-E&7;for(L>>=C,D-=C;D>0;){const z=u[L<<M-D&K];if(!z.len)throw new Error("HufDecode issues");{D-=z.len;const u=I(z.lit,J,L,D,Y,H,T,b,g);u&&(L=u.c,D=u.lc)}}}(D,g,z,Y,L,b,J,E,{value:0})}function e(z){return 65535&z}function N(z){const u=e(z);return u>32767?u-65536:u}function B(z,u){const Y=N(z),H=N(u),E=Y+(1&H)+(H>>1);return{a:E,b:E-H}}function f(z,u){const Y=e(z),H=e(u),E=Y-(H>>1)&m;return{a:H+E-n&m,b:E}}function r(z,u,Y,H,E,J,l){const T=l<16384,b=Y>E?E:Y;let L,D,g=1;for(;g<=b;)g<<=1;for(g>>=1,L=g,g>>=1;g>=1;){D=0;const l=D+J*(E-L),b=J*g,M=J*L,q=H*g,C=H*L;let K,h,o,d;for(;D<=l;D+=M){let E=D;const J=D+H*(Y-L);for(;E<=J;E+=C){const Y=E+q,H=E+b,J=H+q;if(T){let l=B(z[E+u],z[H+u]);K=l.a,o=l.b,l=B(z[Y+u],z[J+u]),h=l.a,d=l.b,l=B(K,h),z[E+u]=l.a,z[Y+u]=l.b,l=B(o,d),z[H+u]=l.a,z[J+u]=l.b}else{let l=f(z[E+u],z[H+u]);K=l.a,o=l.b,l=f(z[Y+u],z[J+u]),h=l.a,d=l.b,l=f(K,h),z[E+u]=l.a,z[Y+u]=l.b,l=f(o,d),z[H+u]=l.a,z[J+u]=l.b}}if(Y&g){const Y=E+b;let H;H=T?B(z[E+u],z[Y+u]):f(z[E+u],z[Y+u]),K=H.a,z[Y+u]=H.b,z[E+u]=K}}if(E&g){let E=D;const J=D+H*(Y-L);for(;E<=J;E+=C){const Y=E+q;let H;H=T?B(z[E+u],z[Y+u]):f(z[E+u],z[Y+u]),K=H.a,z[Y+u]=H.b,z[E+u]=K}}L=g,g>>=1}return D}function zz(z){return new DataView(z.array.buffer,z.offset.value,z.size)}function uz(z){const u=z.viewer.buffer.slice(z.offset.value,z.offset.value+z.size),Y=new Uint8Array(function(z){let u=z.byteLength;const Y=[];let H=0;const E=new DataView(z);for(;u>0;){const z=E.getInt8(H++);if(z<0){const J=-z;u-=J+1;for(let z=0;z<J;z++)Y.push(E.getUint8(H++))}else{const J=z;u-=2;const l=E.getUint8(H++);for(let z=0;z<J+1;z++)Y.push(l)}}return Y}(u)),H=new Uint8Array(Y.length);return w(Y),c(Y,H),new DataView(H.buffer)}function Yz(z){const u=z.array.slice(z.offset.value,z.offset.value+z.size),Y=fflate.unzlibSync(u),H=new Uint8Array(Y.length);return w(Y),c(Y,H),new DataView(H.buffer)}function Hz(z){const u=z.array.slice(z.offset.value,z.offset.value+z.size),Y=fflate.unzlibSync(u),H=z.lines*z.channels*z.width,E=1==z.type?new Uint16Array(H):new Uint32Array(H);let J=0,l=0;const T=new Array(4);for(let b=0;b<z.lines;b++)for(let u=0;u<z.channels;u++){let u=0;switch(z.type){case 1:T[0]=J,T[1]=T[0]+z.width,J=T[1]+z.width;for(let H=0;H<z.width;++H){u+=Y[T[0]++]<<8|Y[T[1]++],E[l]=u,l++}break;case 2:T[0]=J,T[1]=T[0]+z.width,T[2]=T[1]+z.width,J=T[2]+z.width;for(let H=0;H<z.width;++H){u+=Y[T[0]++]<<24|Y[T[1]++]<<16|Y[T[2]++]<<8,E[l]=u,l++}}}return new DataView(E.buffer)}function Ez(z){const u=z.viewer,Y={value:z.offset.value},H=new Uint16Array(z.width*z.scanlineBlockSize*(z.channels*z.type)),E=new Uint8Array(g);let J=0;const l=new Array(z.channels);for(let b=0;b<z.channels;b++)l[b]={},l[b].start=J,l[b].end=l[b].start,l[b].nx=z.width,l[b].ny=z.lines,l[b].size=z.type,J+=l[b].nx*l[b].ny*l[b].size;const T=Q(u,Y),L=Q(u,Y);if(L>=g)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(T<=L)for(let b=0;b<L-T+1;b++)E[b+T]=X(u,Y);const M=new Uint16Array(D),q=function(z,u){let Y=0;for(let E=0;E<D;++E)(0==E||z[E>>3]&1<<(7&E))&&(u[Y++]=E);const H=Y-1;for(;Y<D;)u[Y++]=0;return H}(E,M),C=i(u,Y);P(z.array,u,Y,C,H,J);for(let b=0;b<z.channels;++b){const z=l[b];for(let u=0;u<l[b].size;++u)r(H,z.start+u,z.nx,z.size,z.ny,z.nx*z.size,q)}!function(z,u,Y){for(let H=0;H<Y;++H)u[H]=z[u[H]]}(M,H,J);let K=0;const h=new Uint8Array(H.buffer.byteLength);for(let D=0;D<z.lines;D++)for(let u=0;u<z.channels;u++){const z=l[u],Y=z.nx*z.size,E=new Uint8Array(H.buffer,z.end*b,Y*b);h.set(E,K),K+=Y*b,z.end+=Y}return new DataView(h.buffer)}var Jz,lz=Y(10945);!function(z){z[z.Float=0]="Float",z[z.HalfFloat=1]="HalfFloat"}(Jz||(Jz={}));class Tz{}async function bz(z,u,Y,H){const E={size:0,viewer:u,array:new Uint8Array(u.buffer),offset:Y,width:z.dataWindow.xMax-z.dataWindow.xMin+1,height:z.dataWindow.yMax-z.dataWindow.yMin+1,channels:z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(z.compression){case t.NO_COMPRESSION:E.lines=1,E.uncompress=zz;break;case t.RLE_COMPRESSION:E.lines=1,E.uncompress=uz;break;case t.ZIPS_COMPRESSION:E.lines=1,E.uncompress=Yz,await lz.e.LoadScriptAsync(Tz.FFLATEUrl);break;case t.ZIP_COMPRESSION:E.lines=16,E.uncompress=Yz,await lz.e.LoadScriptAsync(Tz.FFLATEUrl);break;case t.PIZ_COMPRESSION:E.lines=32,E.uncompress=Ez;break;case t.PXR24_COMPRESSION:E.lines=16,E.uncompress=Hz,await lz.e.LoadScriptAsync(Tz.FFLATEUrl);break;default:throw new Error(t[z.compression]+" is unsupported")}E.scanlineBlockSize=E.lines;const J={};for(const l of z.channels)switch(l.name){case"R":case"G":case"B":case"A":case"Y":J[l.name]=!0,E.type=l.pixelType}let T=!1;if(J.R&&J.G&&J.B&&J.A)E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(J.R&&J.G&&J.B)T=!0,E.outputChannels=4,E.decodeChannels={R:0,G:1,B:2,A:3};else if(J.R&&J.G)E.outputChannels=2,E.decodeChannels={R:0,G:1};else if(J.R)E.outputChannels=1,E.decodeChannels={R:0};else{if(!J.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");E.outputChannels=1,E.decodeChannels={Y:0}}if(1===E.type)switch(H){case Jz.Float:E.getter=G,E.inputSize=b;break;case Jz.HalfFloat:E.getter=Q,E.inputSize=b}else{if(2!==E.type)throw new Error("Unsupported pixelType "+E.type+" for "+z.compression);switch(H){case Jz.Float:E.getter=x,E.inputSize=l;break;case Jz.HalfFloat:E.getter=F,E.inputSize=l}}E.blockCount=E.height/E.scanlineBlockSize;for(let l=0;l<E.blockCount;l++)A(u,Y);const L=E.width*E.height*E.outputChannels;switch(H){case Jz.Float:E.byteArray=new Float32Array(L),E.textureType=1,T&&E.byteArray.fill(1,0,L);break;case Jz.HalfFloat:E.byteArray=new Uint16Array(L),E.textureType=2,T&&E.byteArray.fill(15360,0,L);break;default:throw new Error("Unsupported type: "+H)}let D=0;for(const l of z.channels)void 0!==E.decodeChannels[l.name]&&(E.channelLineOffsets[l.name]=D*E.width),D+=2*l.pixelType;return E.bytesPerLine=E.width*D,E.outLineWidth=E.width*E.outputChannels,"INCREASING_Y"===z.lineOrder?E.scanOrder=z=>z:E.scanOrder=z=>E.height-1-z,4==E.outputChannels?(E.format=5,E.linearSpace=!0):(E.format=6,E.linearSpace=!1),E}function Lz(z,u,Y,H){const E={value:0};for(let J=0;J<z.height/z.scanlineBlockSize;J++){const l=v(Y,H)-u.dataWindow.yMin;z.size=i(Y,H),z.lines=l+z.scanlineBlockSize>z.height?z.height-l:z.scanlineBlockSize;const T=z.size<z.lines*z.bytesPerLine&&z.uncompress?z.uncompress(z):zz(z);H.value+=z.size;for(let Y=0;Y<z.scanlineBlockSize;Y++){const H=J*z.scanlineBlockSize,l=Y+z.scanOrder(H);if(l>=z.height)continue;const b=Y*z.bytesPerLine,L=(z.height-1-l)*z.outLineWidth;for(let Y=0;Y<z.channels;Y++){const H=u.channels[Y].name,J=z.channelLineOffsets[H],l=z.decodeChannels[H];if(void 0!==l){E.value=b+J;for(let u=0;u<z.width;u++){const Y=L+u*z.outputChannels+l;z.byteArray&&(z.byteArray[Y]=z.getter(T,E))}}}}}}Tz.DefaultOutputType=Jz.HalfFloat,Tz.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Dz{constructor(){this.supportCascades=!1}loadCubeData(z,u,Y,H,E){throw".exr not supported in Cube."}loadData(z,u,Y){const E=new DataView(z.buffer),J={value:0},l=O(E,J);bz(l,E,J,Tz.DefaultOutputType).then((z=>{Lz(z,l,E,J);const H=l.dataWindow.xMax-l.dataWindow.xMin+1,T=l.dataWindow.yMax-l.dataWindow.yMin+1;Y(H,T,u.generateMipMaps,!1,(()=>{const Y=u.getEngine();u.format=l.format,u.type=z.textureType,u.invertY=!1,u._gammaSpace=!l.linearSpace,z.byteArray&&Y._uploadDataToTextureDirectly(u,z.byteArray,0,0,void 0,!0)}))})).catch((z=>{H.b.Error("Failed to load EXR texture: ",z)}))}}async function gz(z){const u=new DataView(z),Y={value:0},E=O(u,Y);try{const z=await bz(E,u,Y,Jz.Float);return Lz(z,E,u,Y),z.byteArray?{width:E.dataWindow.xMax-E.dataWindow.xMin+1,height:E.dataWindow.yMax-E.dataWindow.yMin+1,data:new Float32Array(z.byteArray)}:(H.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(J){H.b.Error("Failed to load EXR data: ",J)}return{width:0,height:0,data:null}}}}]);