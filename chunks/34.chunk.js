"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13607:(Z,c,L)=>{L.r(c),L.d(c,{ReadExrDataAsync:()=>iZ,_ExrTextureLoader:()=>zZ});var k=L(11052),N=L(11032);const R=4,G=4,V=1,p=2,J=8,z=65536,i=z>>3,t=14,E=65537,x=1<<t,q=x-1,O=59,w=63,M=2+w-O;var P,j;!function(Z){Z[Z.NO_COMPRESSION=0]="NO_COMPRESSION",Z[Z.RLE_COMPRESSION=1]="RLE_COMPRESSION",Z[Z.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",Z[Z.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",Z[Z.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",Z[Z.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(P||(P={})),function(Z){Z[Z.INCREASING_Y=0]="INCREASING_Y",Z[Z.DECREASING_Y=1]="DECREASING_Y"}(j||(j={}));const o=function(){const Z=new ArrayBuffer(4),c=new Float32Array(Z),L=new Uint32Array(Z),k=new Uint32Array(512),N=new Uint32Array(512);for(let p=0;p<256;++p){const Z=p-127;Z<-27?(k[p]=0,k[256|p]=32768,N[p]=24,N[256|p]=24):Z<-14?(k[p]=1024>>-Z-14,k[256|p]=1024>>-Z-14|32768,N[p]=-Z-1,N[256|p]=-Z-1):Z<=15?(k[p]=Z+15<<10,k[256|p]=Z+15<<10|32768,N[p]=13,N[256|p]=13):Z<128?(k[p]=31744,k[256|p]=64512,N[p]=24,N[256|p]=24):(k[p]=31744,k[256|p]=64512,N[p]=13,N[256|p]=13)}const R=new Uint32Array(2048),G=new Uint32Array(64),V=new Uint32Array(64);for(let p=1;p<1024;++p){let Z=p<<13,c=0;for(;0===(8388608&Z);)Z<<=1,c-=8388608;Z&=-8388609,c+=947912704,R[p]=Z|c}for(let p=1024;p<2048;++p)R[p]=939524096+(p-1024<<13);for(let p=1;p<31;++p)G[p]=p<<23;G[31]=1199570944,G[32]=2147483648;for(let p=33;p<63;++p)G[p]=2147483648+(p-32<<23);G[63]=3347054592;for(let p=1;p<64;++p)32!==p&&(V[p]=1024);return{floatView:c,uint32View:L,baseTable:k,shiftTable:N,mantissaTable:R,exponentTable:G,offsetTable:V}}();function u(Z,c){const L=new Uint8Array(Z);let k=0;for(;0!=L[c.value+k];)k+=1;const N=(new TextDecoder).decode(L.slice(c.value,c.value+k));return c.value=c.value+k+1,N}function X(Z,c){const L=Z.getInt32(c.value,!0);return c.value+=R,L}function h(Z,c){const L=Z.getUint32(c.value,!0);return c.value+=R,L}function B(Z,c){const L=Z.getUint8(c.value);return c.value+=V,L}function D(Z,c){const L=Z.getUint16(c.value,!0);return c.value+=p,L}function e(Z,c){const L=Z[c.value];return c.value+=V,L}function H(Z,c){let L;return L="getBigInt64"in DataView.prototype?Number(Z.getBigInt64(c.value,!0)):Z.getUint32(c.value+4,!0)+Number(Z.getUint32(c.value,!0)<<32),c.value+=J,L}function l(Z,c){const L=Z.getFloat32(c.value,!0);return c.value+=G,L}function W(Z,c){return function(Z){const c=(31744&Z)>>10,L=1023&Z;return(Z>>15?-1:1)*(c?31===c?L?NaN:1/0:Math.pow(2,c-15)*(1+L/1024):L/1024*6103515625e-14)}(D(Z,c))}function T(Z,c){return function(Z){if(Math.abs(Z)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");Z=(0,N.Clamp)(Z,-65504,65504),o.floatView[0]=Z;const c=o.uint32View[0],L=c>>23&511;return o.baseTable[L]+((8388607&c)>>o.shiftTable[L])}(l(Z,c))}function I(Z,c,L,k){switch(L){case"string":case"stringvector":case"iccProfile":return function(Z,c,L){const k=(new TextDecoder).decode(new Uint8Array(Z).slice(c.value,c.value+L));return c.value=c.value+L,k}(Z.buffer,c,k);case"chlist":return function(Z,c,L){const k=c.value,N=[];for(;c.value<k+L-1;){const L=u(Z.buffer,c),k=X(Z,c),R=B(Z,c);c.value+=3;const G=X(Z,c),V=X(Z,c);N.push({name:L,pixelType:k,pLinear:R,xSampling:G,ySampling:V})}return c.value+=1,N}(Z,c,k);case"chromaticities":return function(Z,c){return{redX:l(Z,c),redY:l(Z,c),greenX:l(Z,c),greenY:l(Z,c),blueX:l(Z,c),blueY:l(Z,c),whiteX:l(Z,c),whiteY:l(Z,c)}}(Z,c);case"compression":return function(Z,c){return B(Z,c)}(Z,c);case"box2i":return function(Z,c){return{xMin:X(Z,c),yMin:X(Z,c),xMax:X(Z,c),yMax:X(Z,c)}}(Z,c);case"lineOrder":return function(Z,c){const L=B(Z,c);return j[L]}(Z,c);case"float":return l(Z,c);case"v2f":return function(Z,c){return[l(Z,c),l(Z,c)]}(Z,c);case"v3f":return function(Z,c){return[l(Z,c),l(Z,c),l(Z,c)]}(Z,c);case"int":return X(Z,c);case"rational":return function(Z,c){return[X(Z,c),h(Z,c)]}(Z,c);case"timecode":return function(Z,c){return[h(Z,c),h(Z,c)]}(Z,c);case"preview":return c.value+=k,"skipped";default:return void(c.value+=k)}}function d(Z){for(let c=1;c<Z.length;c++){const L=Z[c-1]+Z[c]-128;Z[c]=L}}function Q(Z,c){let L=0,k=Math.floor((Z.length+1)/2),N=0;const R=Z.length-1;for(;!(N>R)&&(c[N++]=Z[L++],!(N>R));)c[N++]=Z[k++]}const r=20000630;function f(Z,c){if(Z.getUint32(0,!0)!=r)throw new Error("Incorrect OpenEXR format");const L=Z.getUint8(4),N=Z.getUint8(5),R={singleTile:!!(2&N),longName:!!(4&N),deepFormat:!!(8&N),multiPart:!!(16&N)};c.value=8;const G={};let V=!0;for(;V;){const L=u(Z.buffer,c);if(L){const N=u(Z.buffer,c),R=I(Z,c,N,h(Z,c));void 0===R?k.e.Warn(`Unknown header attribute type ${N}'.`):G[L]=R}else V=!1}if(0!=(-5&N))throw new Error("Unsupported file format");return{version:L,spec:R,...G}}const S=32768,s=65535;function m(Z,c,L,k,N){for(;L<Z;)c=c<<8|e(k,N),L+=8;return{l:c>>(L-=Z)&(1<<Z)-1,c:c,lc:L}}function A(Z,c,L,k){return{c:Z=Z<<8|e(L,k),lc:c+=8}}function b(Z,c,L,k,N,R,G,V,p){if(Z==c){if(k<8){const Z=A(L,k,N,R);L=Z.c,k=Z.lc}let Z=L>>(k-=8);if(Z=new Uint8Array([Z])[0],V.value+Z>p)return null;const c=G[V.value-1];for(;Z-- >0;)G[V.value++]=c}else{if(!(V.value<p))return null;G[V.value++]=Z}return{c:L,lc:k}}const F=new Array(59);function U(Z,c,L,k,N,R){const G=c;let V=0,p=0;for(;k<=N;k++){if(G.value-c.value>L)return;let J=m(6,V,p,Z,G);const z=J.l;if(V=J.c,p=J.lc,R[k]=z,z==w){if(G.value-c.value>L)throw new Error("Error in HufUnpackEncTable");J=m(8,V,p,Z,G);let z=J.l+M;if(V=J.c,p=J.lc,k+z>N+1)throw new Error("Error in HufUnpackEncTable");for(;z--;)R[k++]=0;k--}else if(z>=O){let Z=z-O+2;if(k+Z>N+1)throw new Error("Error in HufUnpackEncTable");for(;Z--;)R[k++]=0;k--}}!function(Z){for(let L=0;L<=58;++L)F[L]=0;for(let L=0;L<E;++L)F[Z[L]]+=1;let c=0;for(let L=58;L>0;--L){const Z=c+F[L]>>1;F[L]=c,c=Z}for(let L=0;L<E;++L){const c=Z[L];c>0&&(Z[L]=c|F[c]++<<6)}}(R)}function K(Z){return 63&Z}function n(Z){return Z>>6}function g(Z,c,L,k,N,R){const G=L.value,V=h(c,L),p=h(c,L);L.value+=4;const J=h(c,L);if(L.value+=4,V<0||V>=E||p<0||p>=E)throw new Error("Wrong HUF_ENCSIZE");const z=new Array(E),i=new Array(x);!function(Z){for(let c=0;c<x;c++)Z[c]={},Z[c].len=0,Z[c].lit=0,Z[c].p=null}(i);if(U(Z,L,k-(L.value-G),V,p,z),J>8*(k-(L.value-G)))throw new Error("Wrong hufUncompress");!function(Z,c,L,k){for(;c<=L;c++){const L=n(Z[c]),N=K(Z[c]);if(L>>N)throw new Error("Invalid table entry");if(N>t){const Z=k[L>>N-t];if(Z.len)throw new Error("Invalid table entry");if(Z.lit++,Z.p){const c=Z.p;Z.p=new Array(Z.lit);for(let L=0;L<Z.lit-1;++L)Z.p[L]=c[L]}else Z.p=new Array(1);Z.p[Z.lit-1]=c}else if(N){let Z=0;for(let R=1<<t-N;R>0;R--){const R=k[(L<<t-N)+Z];if(R.len||R.p)throw new Error("Invalid table entry");R.len=N,R.lit=c,Z++}}}}(z,V,p,i),function(Z,c,L,k,N,R,G,V,p){let J=0,z=0;const i=G,E=Math.trunc(k.value+(N+7)/8);for(;k.value<E;){let N=A(J,z,L,k);for(J=N.c,z=N.lc;z>=t;){const G=c[J>>z-t&q];if(G.len){z-=G.len;const Z=b(G.lit,R,J,z,L,k,V,p,i);Z&&(J=Z.c,z=Z.lc)}else{if(!G.p)throw new Error("hufDecode issues");let c;for(c=0;c<G.lit;c++){const t=K(Z[G.p[c]]);for(;z<t&&k.value<E;)N=A(J,z,L,k),J=N.c,z=N.lc;if(z>=t&&n(Z[G.p[c]])==(J>>z-t&(1<<t)-1)){z-=t;const Z=b(G.p[c],R,J,z,L,k,V,p,i);Z&&(J=Z.c,z=Z.lc);break}}if(c==G.lit)throw new Error("HufDecode issues")}}}const x=8-N&7;for(J>>=x,z-=x;z>0;){const Z=c[J<<t-z&q];if(!Z.len)throw new Error("HufDecode issues");{z-=Z.len;const c=b(Z.lit,R,J,z,L,k,V,p,i);c&&(J=c.c,z=c.lc)}}}(z,i,Z,L,J,p,R,N,{value:0})}function y(Z){return 65535&Z}function v(Z){const c=y(Z);return c>32767?c-65536:c}function Y(Z,c){const L=v(Z),k=v(c),N=L+(1&k)+(k>>1);return{a:N,b:N-k}}function a(Z,c){const L=y(Z),k=y(c),N=L-(k>>1)&s;return{a:k+N-S&s,b:N}}function C(Z,c,L,k,N,R,G){const V=G<16384,p=L>N?N:L;let J,z,i=1;for(;i<=p;)i<<=1;for(i>>=1,J=i,i>>=1;i>=1;){z=0;const G=z+R*(N-J),p=R*i,t=R*J,E=k*i,x=k*J;let q,O,w,M;for(;z<=G;z+=t){let N=z;const R=z+k*(L-J);for(;N<=R;N+=x){const L=N+E,k=N+p,R=k+E;if(V){let G=Y(Z[N+c],Z[k+c]);q=G.a,w=G.b,G=Y(Z[L+c],Z[R+c]),O=G.a,M=G.b,G=Y(q,O),Z[N+c]=G.a,Z[L+c]=G.b,G=Y(w,M),Z[k+c]=G.a,Z[R+c]=G.b}else{let G=a(Z[N+c],Z[k+c]);q=G.a,w=G.b,G=a(Z[L+c],Z[R+c]),O=G.a,M=G.b,G=a(q,O),Z[N+c]=G.a,Z[L+c]=G.b,G=a(w,M),Z[k+c]=G.a,Z[R+c]=G.b}}if(L&i){const L=N+p;let k;k=V?Y(Z[N+c],Z[L+c]):a(Z[N+c],Z[L+c]),q=k.a,Z[L+c]=k.b,Z[N+c]=q}}if(N&i){let N=z;const R=z+k*(L-J);for(;N<=R;N+=x){const L=N+E;let k;k=V?Y(Z[N+c],Z[L+c]):a(Z[N+c],Z[L+c]),q=k.a,Z[L+c]=k.b,Z[N+c]=q}}J=i,i>>=1}return z}function ZZ(Z){return new DataView(Z.array.buffer,Z.offset.value,Z.size)}function cZ(Z){const c=Z.viewer.buffer.slice(Z.offset.value,Z.offset.value+Z.size),L=new Uint8Array(function(Z){let c=Z.byteLength;const L=[];let k=0;const N=new DataView(Z);for(;c>0;){const Z=N.getInt8(k++);if(Z<0){const R=-Z;c-=R+1;for(let Z=0;Z<R;Z++)L.push(N.getUint8(k++))}else{const R=Z;c-=2;const G=N.getUint8(k++);for(let Z=0;Z<R+1;Z++)L.push(G)}}return L}(c)),k=new Uint8Array(L.length);return d(L),Q(L,k),new DataView(k.buffer)}function LZ(Z){const c=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),L=fflate.unzlibSync(c),k=new Uint8Array(L.length);return d(L),Q(L,k),new DataView(k.buffer)}function kZ(Z){const c=Z.array.slice(Z.offset.value,Z.offset.value+Z.size),L=fflate.unzlibSync(c),k=Z.lines*Z.channels*Z.width,N=1==Z.type?new Uint16Array(k):new Uint32Array(k);let R=0,G=0;const V=new Array(4);for(let p=0;p<Z.lines;p++)for(let c=0;c<Z.channels;c++){let c=0;switch(Z.type){case 1:V[0]=R,V[1]=V[0]+Z.width,R=V[1]+Z.width;for(let k=0;k<Z.width;++k){c+=L[V[0]++]<<8|L[V[1]++],N[G]=c,G++}break;case 2:V[0]=R,V[1]=V[0]+Z.width,V[2]=V[1]+Z.width,R=V[2]+Z.width;for(let k=0;k<Z.width;++k){c+=L[V[0]++]<<24|L[V[1]++]<<16|L[V[2]++]<<8,N[G]=c,G++}}}return new DataView(N.buffer)}function NZ(Z){const c=Z.viewer,L={value:Z.offset.value},k=new Uint16Array(Z.width*Z.scanlineBlockSize*(Z.channels*Z.type)),N=new Uint8Array(i);let R=0;const G=new Array(Z.channels);for(let p=0;p<Z.channels;p++)G[p]={},G[p].start=R,G[p].end=G[p].start,G[p].nx=Z.width,G[p].ny=Z.lines,G[p].size=Z.type,R+=G[p].nx*G[p].ny*G[p].size;const V=D(c,L),J=D(c,L);if(J>=i)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(V<=J)for(let p=0;p<J-V+1;p++)N[p+V]=B(c,L);const t=new Uint16Array(z),E=function(Z,c){let L=0;for(let N=0;N<z;++N)(0==N||Z[N>>3]&1<<(7&N))&&(c[L++]=N);const k=L-1;for(;L<z;)c[L++]=0;return k}(N,t),x=h(c,L);g(Z.array,c,L,x,k,R);for(let p=0;p<Z.channels;++p){const Z=G[p];for(let c=0;c<G[p].size;++c)C(k,Z.start+c,Z.nx,Z.size,Z.ny,Z.nx*Z.size,E)}!function(Z,c,L){for(let k=0;k<L;++k)c[k]=Z[c[k]]}(t,k,R);let q=0;const O=new Uint8Array(k.buffer.byteLength);for(let z=0;z<Z.lines;z++)for(let c=0;c<Z.channels;c++){const Z=G[c],L=Z.nx*Z.size,N=new Uint8Array(k.buffer,Z.end*p,L*p);O.set(N,q),q+=L*p,Z.end+=L}return new DataView(O.buffer)}var RZ,GZ=L(11038);!function(Z){Z[Z.Float=0]="Float",Z[Z.HalfFloat=1]="HalfFloat"}(RZ||(RZ={}));class VZ{}async function pZ(Z,c,L,k){const N={size:0,viewer:c,array:new Uint8Array(c.buffer),offset:L,width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,channels:Z.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(Z.compression){case P.NO_COMPRESSION:N.lines=1,N.uncompress=ZZ;break;case P.RLE_COMPRESSION:N.lines=1,N.uncompress=cZ;break;case P.ZIPS_COMPRESSION:N.lines=1,N.uncompress=LZ,await GZ.c.LoadScriptAsync(VZ.FFLATEUrl);break;case P.ZIP_COMPRESSION:N.lines=16,N.uncompress=LZ,await GZ.c.LoadScriptAsync(VZ.FFLATEUrl);break;case P.PIZ_COMPRESSION:N.lines=32,N.uncompress=NZ;break;case P.PXR24_COMPRESSION:N.lines=16,N.uncompress=kZ,await GZ.c.LoadScriptAsync(VZ.FFLATEUrl);break;default:throw new Error(P[Z.compression]+" is unsupported")}N.scanlineBlockSize=N.lines;const R={};for(const G of Z.channels)switch(G.name){case"R":case"G":case"B":case"A":case"Y":R[G.name]=!0,N.type=G.pixelType}let V=!1;if(R.R&&R.G&&R.B&&R.A)N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(R.R&&R.G&&R.B)V=!0,N.outputChannels=4,N.decodeChannels={R:0,G:1,B:2,A:3};else if(R.R&&R.G)N.outputChannels=2,N.decodeChannels={R:0,G:1};else if(R.R)N.outputChannels=1,N.decodeChannels={R:0};else{if(!R.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");N.outputChannels=1,N.decodeChannels={Y:0}}if(1===N.type)switch(k){case RZ.Float:N.getter=W,N.inputSize=p;break;case RZ.HalfFloat:N.getter=D,N.inputSize=p}else{if(2!==N.type)throw new Error("Unsupported pixelType "+N.type+" for "+Z.compression);switch(k){case RZ.Float:N.getter=l,N.inputSize=G;break;case RZ.HalfFloat:N.getter=T,N.inputSize=G}}N.blockCount=N.height/N.scanlineBlockSize;for(let G=0;G<N.blockCount;G++)H(c,L);const J=N.width*N.height*N.outputChannels;switch(k){case RZ.Float:N.byteArray=new Float32Array(J),N.textureType=1,V&&N.byteArray.fill(1,0,J);break;case RZ.HalfFloat:N.byteArray=new Uint16Array(J),N.textureType=2,V&&N.byteArray.fill(15360,0,J);break;default:throw new Error("Unsupported type: "+k)}let z=0;for(const G of Z.channels)void 0!==N.decodeChannels[G.name]&&(N.channelLineOffsets[G.name]=z*N.width),z+=2*G.pixelType;return N.bytesPerLine=N.width*z,N.outLineWidth=N.width*N.outputChannels,"INCREASING_Y"===Z.lineOrder?N.scanOrder=Z=>Z:N.scanOrder=Z=>N.height-1-Z,4==N.outputChannels?(N.format=5,N.linearSpace=!0):(N.format=6,N.linearSpace=!1),N}function JZ(Z,c,L,k){const N={value:0};for(let R=0;R<Z.height/Z.scanlineBlockSize;R++){const G=X(L,k)-c.dataWindow.yMin;Z.size=h(L,k),Z.lines=G+Z.scanlineBlockSize>Z.height?Z.height-G:Z.scanlineBlockSize;const V=Z.size<Z.lines*Z.bytesPerLine&&Z.uncompress?Z.uncompress(Z):ZZ(Z);k.value+=Z.size;for(let L=0;L<Z.scanlineBlockSize;L++){const k=R*Z.scanlineBlockSize,G=L+Z.scanOrder(k);if(G>=Z.height)continue;const p=L*Z.bytesPerLine,J=(Z.height-1-G)*Z.outLineWidth;for(let L=0;L<Z.channels;L++){const k=c.channels[L].name,R=Z.channelLineOffsets[k],G=Z.decodeChannels[k];if(void 0!==G){N.value=p+R;for(let c=0;c<Z.width;c++){const L=J+c*Z.outputChannels+G;Z.byteArray&&(Z.byteArray[L]=Z.getter(V,N))}}}}}}VZ.DefaultOutputType=RZ.HalfFloat,VZ.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class zZ{constructor(){this.supportCascades=!1}loadCubeData(Z,c,L,k,N){throw".exr not supported in Cube."}loadData(Z,c,L){const N=new DataView(Z.buffer),R={value:0},G=f(N,R);pZ(G,N,R,VZ.DefaultOutputType).then((Z=>{JZ(Z,G,N,R);const k=G.dataWindow.xMax-G.dataWindow.xMin+1,V=G.dataWindow.yMax-G.dataWindow.yMin+1;L(k,V,c.generateMipMaps,!1,(()=>{const L=c.getEngine();c.format=G.format,c.type=Z.textureType,c.invertY=!1,c._gammaSpace=!G.linearSpace,Z.byteArray&&L._uploadDataToTextureDirectly(c,Z.byteArray,0,0,void 0,!0)}))})).catch((Z=>{k.e.Error("Failed to load EXR texture: ",Z)}))}}async function iZ(Z){const c=new DataView(Z),L={value:0},N=f(c,L);try{const Z=await pZ(N,c,L,RZ.Float);return JZ(Z,N,c,L),Z.byteArray?{width:N.dataWindow.xMax-N.dataWindow.xMin+1,height:N.dataWindow.yMax-N.dataWindow.yMin+1,data:new Float32Array(Z.byteArray)}:(k.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(R){k.e.Error("Failed to load EXR data: ",R)}return{width:0,height:0,data:null}}}}]);