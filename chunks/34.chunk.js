"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13808:(G,V,W)=>{W.r(V),W.d(V,{ReadExrDataAsync:()=>xG,_ExrTextureLoader:()=>AG});var J=W(11201),R=W(11182);const d=4,k=4,z=1,X=2,P=8,A=65536,x=A>>3,q=14,L=65537,t=1<<q,Y=t-1,g=59,B=63,S=2+B-g;var p,b;!function(G){G[G.NO_COMPRESSION=0]="NO_COMPRESSION",G[G.RLE_COMPRESSION=1]="RLE_COMPRESSION",G[G.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",G[G.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",G[G.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",G[G.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(p||(p={})),function(G){G[G.INCREASING_Y=0]="INCREASING_Y",G[G.DECREASING_Y=1]="DECREASING_Y"}(b||(b={}));const r=function(){const G=new ArrayBuffer(4),V=new Float32Array(G),W=new Uint32Array(G),J=new Uint32Array(512),R=new Uint32Array(512);for(let X=0;X<256;++X){const G=X-127;G<-27?(J[X]=0,J[256|X]=32768,R[X]=24,R[256|X]=24):G<-14?(J[X]=1024>>-G-14,J[256|X]=1024>>-G-14|32768,R[X]=-G-1,R[256|X]=-G-1):G<=15?(J[X]=G+15<<10,J[256|X]=G+15<<10|32768,R[X]=13,R[256|X]=13):G<128?(J[X]=31744,J[256|X]=64512,R[X]=24,R[256|X]=24):(J[X]=31744,J[256|X]=64512,R[X]=13,R[256|X]=13)}const d=new Uint32Array(2048),k=new Uint32Array(64),z=new Uint32Array(64);for(let X=1;X<1024;++X){let G=X<<13,V=0;for(;0===(8388608&G);)G<<=1,V-=8388608;G&=-8388609,V+=947912704,d[X]=G|V}for(let X=1024;X<2048;++X)d[X]=939524096+(X-1024<<13);for(let X=1;X<31;++X)k[X]=X<<23;k[31]=1199570944,k[32]=2147483648;for(let X=33;X<63;++X)k[X]=2147483648+(X-32<<23);k[63]=3347054592;for(let X=1;X<64;++X)32!==X&&(z[X]=1024);return{floatView:V,uint32View:W,baseTable:J,shiftTable:R,mantissaTable:d,exponentTable:k,offsetTable:z}}();function y(G,V){const W=new Uint8Array(G);let J=0;for(;0!=W[V.value+J];)J+=1;const R=(new TextDecoder).decode(W.slice(V.value,V.value+J));return V.value=V.value+J+1,R}function u(G,V){const W=G.getInt32(V.value,!0);return V.value+=d,W}function H(G,V){const W=G.getUint32(V.value,!0);return V.value+=d,W}function n(G,V){const W=G.getUint8(V.value);return V.value+=z,W}function D(G,V){const W=G.getUint16(V.value,!0);return V.value+=X,W}function i(G,V){const W=G[V.value];return V.value+=z,W}function e(G,V){let W;return W="getBigInt64"in DataView.prototype?Number(G.getBigInt64(V.value,!0)):G.getUint32(V.value+4,!0)+Number(G.getUint32(V.value,!0)<<32),V.value+=P,W}function F(G,V){const W=G.getFloat32(V.value,!0);return V.value+=k,W}function f(G,V){return function(G){const V=(31744&G)>>10,W=1023&G;return(G>>15?-1:1)*(V?31===V?W?NaN:1/0:Math.pow(2,V-15)*(1+W/1024):W/1024*6103515625e-14)}(D(G,V))}function v(G,V){return function(G){if(Math.abs(G)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");G=(0,R.Clamp)(G,-65504,65504),r.floatView[0]=G;const V=r.uint32View[0],W=V>>23&511;return r.baseTable[W]+((8388607&V)>>r.shiftTable[W])}(F(G,V))}function C(G,V,W,J){switch(W){case"string":case"stringvector":case"iccProfile":return function(G,V,W){const J=(new TextDecoder).decode(new Uint8Array(G).slice(V.value,V.value+W));return V.value=V.value+W,J}(G.buffer,V,J);case"chlist":return function(G,V,W){const J=V.value,R=[];for(;V.value<J+W-1;){const W=y(G.buffer,V),J=u(G,V),d=n(G,V);V.value+=3;const k=u(G,V),z=u(G,V);R.push({name:W,pixelType:J,pLinear:d,xSampling:k,ySampling:z})}return V.value+=1,R}(G,V,J);case"chromaticities":return function(G,V){return{redX:F(G,V),redY:F(G,V),greenX:F(G,V),greenY:F(G,V),blueX:F(G,V),blueY:F(G,V),whiteX:F(G,V),whiteY:F(G,V)}}(G,V);case"compression":return function(G,V){return n(G,V)}(G,V);case"box2i":return function(G,V){return{xMin:u(G,V),yMin:u(G,V),xMax:u(G,V),yMax:u(G,V)}}(G,V);case"lineOrder":return function(G,V){const W=n(G,V);return b[W]}(G,V);case"float":return F(G,V);case"v2f":return function(G,V){return[F(G,V),F(G,V)]}(G,V);case"v3f":return function(G,V){return[F(G,V),F(G,V),F(G,V)]}(G,V);case"int":return u(G,V);case"rational":return function(G,V){return[u(G,V),H(G,V)]}(G,V);case"timecode":return function(G,V){return[H(G,V),H(G,V)]}(G,V);case"preview":return V.value+=J,"skipped";default:return void(V.value+=J)}}function l(G){for(let V=1;V<G.length;V++){const W=G[V-1]+G[V]-128;G[V]=W}}function m(G,V){let W=0,J=Math.floor((G.length+1)/2),R=0;const d=G.length-1;for(;!(R>d)&&(V[R++]=G[W++],!(R>d));)V[R++]=G[J++]}const w=20000630;function N(G,V){if(G.getUint32(0,!0)!=w)throw new Error("Incorrect OpenEXR format");const W=G.getUint8(4),R=G.getUint8(5),d={singleTile:!!(2&R),longName:!!(4&R),deepFormat:!!(8&R),multiPart:!!(16&R)};V.value=8;const k={};let z=!0;for(;z;){const W=y(G.buffer,V);if(W){const R=y(G.buffer,V),d=C(G,V,R,H(G,V));void 0===d?J.c.Warn(`Unknown header attribute type ${R}'.`):k[W]=d}else z=!1}if(0!=(-5&R))throw new Error("Unsupported file format");return{version:W,spec:d,...k}}const U=32768,a=65535;function M(G,V,W,J,R){for(;W<G;)V=V<<8|i(J,R),W+=8;return{l:V>>(W-=G)&(1<<G)-1,c:V,lc:W}}function T(G,V,W,J){return{c:G=G<<8|i(W,J),lc:V+=8}}function K(G,V,W,J,R,d,k,z,X){if(G==V){if(J<8){const G=T(W,J,R,d);W=G.c,J=G.lc}let G=W>>(J-=8);if(G=new Uint8Array([G])[0],z.value+G>X)return null;const V=k[z.value-1];for(;G-- >0;)k[z.value++]=V}else{if(!(z.value<X))return null;k[z.value++]=G}return{c:W,lc:J}}const s=new Array(59);function Q(G,V,W,J,R,d){const k=V;let z=0,X=0;for(;J<=R;J++){if(k.value-V.value>W)return;let P=M(6,z,X,G,k);const A=P.l;if(z=P.c,X=P.lc,d[J]=A,A==B){if(k.value-V.value>W)throw new Error("Error in HufUnpackEncTable");P=M(8,z,X,G,k);let A=P.l+S;if(z=P.c,X=P.lc,J+A>R+1)throw new Error("Error in HufUnpackEncTable");for(;A--;)d[J++]=0;J--}else if(A>=g){let G=A-g+2;if(J+G>R+1)throw new Error("Error in HufUnpackEncTable");for(;G--;)d[J++]=0;J--}}!function(G){for(let W=0;W<=58;++W)s[W]=0;for(let W=0;W<L;++W)s[G[W]]+=1;let V=0;for(let W=58;W>0;--W){const G=V+s[W]>>1;s[W]=V,V=G}for(let W=0;W<L;++W){const V=G[W];V>0&&(G[W]=V|s[V]++<<6)}}(d)}function Z(G){return 63&G}function E(G){return G>>6}function h(G,V,W,J,R,d){const k=W.value,z=H(V,W),X=H(V,W);W.value+=4;const P=H(V,W);if(W.value+=4,z<0||z>=L||X<0||X>=L)throw new Error("Wrong HUF_ENCSIZE");const A=new Array(L),x=new Array(t);!function(G){for(let V=0;V<t;V++)G[V]={},G[V].len=0,G[V].lit=0,G[V].p=null}(x);if(Q(G,W,J-(W.value-k),z,X,A),P>8*(J-(W.value-k)))throw new Error("Wrong hufUncompress");!function(G,V,W,J){for(;V<=W;V++){const W=E(G[V]),R=Z(G[V]);if(W>>R)throw new Error("Invalid table entry");if(R>q){const G=J[W>>R-q];if(G.len)throw new Error("Invalid table entry");if(G.lit++,G.p){const V=G.p;G.p=new Array(G.lit);for(let W=0;W<G.lit-1;++W)G.p[W]=V[W]}else G.p=new Array(1);G.p[G.lit-1]=V}else if(R){let G=0;for(let d=1<<q-R;d>0;d--){const d=J[(W<<q-R)+G];if(d.len||d.p)throw new Error("Invalid table entry");d.len=R,d.lit=V,G++}}}}(A,z,X,x),function(G,V,W,J,R,d,k,z,X){let P=0,A=0;const x=k,L=Math.trunc(J.value+(R+7)/8);for(;J.value<L;){let R=T(P,A,W,J);for(P=R.c,A=R.lc;A>=q;){const k=V[P>>A-q&Y];if(k.len){A-=k.len;const G=K(k.lit,d,P,A,W,J,z,X,x);G&&(P=G.c,A=G.lc)}else{if(!k.p)throw new Error("hufDecode issues");let V;for(V=0;V<k.lit;V++){const q=Z(G[k.p[V]]);for(;A<q&&J.value<L;)R=T(P,A,W,J),P=R.c,A=R.lc;if(A>=q&&E(G[k.p[V]])==(P>>A-q&(1<<q)-1)){A-=q;const G=K(k.p[V],d,P,A,W,J,z,X,x);G&&(P=G.c,A=G.lc);break}}if(V==k.lit)throw new Error("HufDecode issues")}}}const t=8-R&7;for(P>>=t,A-=t;A>0;){const G=V[P<<q-A&Y];if(!G.len)throw new Error("HufDecode issues");{A-=G.len;const V=K(G.lit,d,P,A,W,J,z,X,x);V&&(P=V.c,A=V.lc)}}}(A,x,G,W,P,X,d,R,{value:0})}function o(G){return 65535&G}function c(G){const V=o(G);return V>32767?V-65536:V}function j(G,V){const W=c(G),J=c(V),R=W+(1&J)+(J>>1);return{a:R,b:R-J}}function I(G,V){const W=o(G),J=o(V),R=W-(J>>1)&a;return{a:J+R-U&a,b:R}}function O(G,V,W,J,R,d,k){const z=k<16384,X=W>R?R:W;let P,A,x=1;for(;x<=X;)x<<=1;for(x>>=1,P=x,x>>=1;x>=1;){A=0;const k=A+d*(R-P),X=d*x,q=d*P,L=J*x,t=J*P;let Y,g,B,S;for(;A<=k;A+=q){let R=A;const d=A+J*(W-P);for(;R<=d;R+=t){const W=R+L,J=R+X,d=J+L;if(z){let k=j(G[R+V],G[J+V]);Y=k.a,B=k.b,k=j(G[W+V],G[d+V]),g=k.a,S=k.b,k=j(Y,g),G[R+V]=k.a,G[W+V]=k.b,k=j(B,S),G[J+V]=k.a,G[d+V]=k.b}else{let k=I(G[R+V],G[J+V]);Y=k.a,B=k.b,k=I(G[W+V],G[d+V]),g=k.a,S=k.b,k=I(Y,g),G[R+V]=k.a,G[W+V]=k.b,k=I(B,S),G[J+V]=k.a,G[d+V]=k.b}}if(W&x){const W=R+X;let J;J=z?j(G[R+V],G[W+V]):I(G[R+V],G[W+V]),Y=J.a,G[W+V]=J.b,G[R+V]=Y}}if(R&x){let R=A;const d=A+J*(W-P);for(;R<=d;R+=t){const W=R+L;let J;J=z?j(G[R+V],G[W+V]):I(G[R+V],G[W+V]),Y=J.a,G[W+V]=J.b,G[R+V]=Y}}P=x,x>>=1}return A}function GG(G){return new DataView(G.array.buffer,G.offset.value,G.size)}function VG(G){const V=G.viewer.buffer.slice(G.offset.value,G.offset.value+G.size),W=new Uint8Array(function(G){let V=G.byteLength;const W=[];let J=0;const R=new DataView(G);for(;V>0;){const G=R.getInt8(J++);if(G<0){const d=-G;V-=d+1;for(let G=0;G<d;G++)W.push(R.getUint8(J++))}else{const d=G;V-=2;const k=R.getUint8(J++);for(let G=0;G<d+1;G++)W.push(k)}}return W}(V)),J=new Uint8Array(W.length);return l(W),m(W,J),new DataView(J.buffer)}function WG(G){const V=G.array.slice(G.offset.value,G.offset.value+G.size),W=fflate.unzlibSync(V),J=new Uint8Array(W.length);return l(W),m(W,J),new DataView(J.buffer)}function JG(G){const V=G.array.slice(G.offset.value,G.offset.value+G.size),W=fflate.unzlibSync(V),J=G.lines*G.channels*G.width,R=1==G.type?new Uint16Array(J):new Uint32Array(J);let d=0,k=0;const z=new Array(4);for(let X=0;X<G.lines;X++)for(let V=0;V<G.channels;V++){let V=0;switch(G.type){case 1:z[0]=d,z[1]=z[0]+G.width,d=z[1]+G.width;for(let J=0;J<G.width;++J){V+=W[z[0]++]<<8|W[z[1]++],R[k]=V,k++}break;case 2:z[0]=d,z[1]=z[0]+G.width,z[2]=z[1]+G.width,d=z[2]+G.width;for(let J=0;J<G.width;++J){V+=W[z[0]++]<<24|W[z[1]++]<<16|W[z[2]++]<<8,R[k]=V,k++}}}return new DataView(R.buffer)}function RG(G){const V=G.viewer,W={value:G.offset.value},J=new Uint16Array(G.width*G.scanlineBlockSize*(G.channels*G.type)),R=new Uint8Array(x);let d=0;const k=new Array(G.channels);for(let X=0;X<G.channels;X++)k[X]={},k[X].start=d,k[X].end=k[X].start,k[X].nx=G.width,k[X].ny=G.lines,k[X].size=G.type,d+=k[X].nx*k[X].ny*k[X].size;const z=D(V,W),P=D(V,W);if(P>=x)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(z<=P)for(let X=0;X<P-z+1;X++)R[X+z]=n(V,W);const q=new Uint16Array(A),L=function(G,V){let W=0;for(let R=0;R<A;++R)(0==R||G[R>>3]&1<<(7&R))&&(V[W++]=R);const J=W-1;for(;W<A;)V[W++]=0;return J}(R,q),t=H(V,W);h(G.array,V,W,t,J,d);for(let X=0;X<G.channels;++X){const G=k[X];for(let V=0;V<k[X].size;++V)O(J,G.start+V,G.nx,G.size,G.ny,G.nx*G.size,L)}!function(G,V,W){for(let J=0;J<W;++J)V[J]=G[V[J]]}(q,J,d);let Y=0;const g=new Uint8Array(J.buffer.byteLength);for(let A=0;A<G.lines;A++)for(let V=0;V<G.channels;V++){const G=k[V],W=G.nx*G.size,R=new Uint8Array(J.buffer,G.end*X,W*X);g.set(R,Y),Y+=W*X,G.end+=W}return new DataView(g.buffer)}var dG,kG=W(11189);!function(G){G[G.Float=0]="Float",G[G.HalfFloat=1]="HalfFloat"}(dG||(dG={}));class zG{}async function XG(G,V,W,J){const R={size:0,viewer:V,array:new Uint8Array(V.buffer),offset:W,width:G.dataWindow.xMax-G.dataWindow.xMin+1,height:G.dataWindow.yMax-G.dataWindow.yMin+1,channels:G.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(G.compression){case p.NO_COMPRESSION:R.lines=1,R.uncompress=GG;break;case p.RLE_COMPRESSION:R.lines=1,R.uncompress=VG;break;case p.ZIPS_COMPRESSION:R.lines=1,R.uncompress=WG,await kG.h.LoadScriptAsync(zG.FFLATEUrl);break;case p.ZIP_COMPRESSION:R.lines=16,R.uncompress=WG,await kG.h.LoadScriptAsync(zG.FFLATEUrl);break;case p.PIZ_COMPRESSION:R.lines=32,R.uncompress=RG;break;case p.PXR24_COMPRESSION:R.lines=16,R.uncompress=JG,await kG.h.LoadScriptAsync(zG.FFLATEUrl);break;default:throw new Error(p[G.compression]+" is unsupported")}R.scanlineBlockSize=R.lines;const d={};for(const k of G.channels)switch(k.name){case"R":case"G":case"B":case"A":case"Y":d[k.name]=!0,R.type=k.pixelType}let z=!1;if(d.R&&d.G&&d.B&&d.A)R.outputChannels=4,R.decodeChannels={R:0,G:1,B:2,A:3};else if(d.R&&d.G&&d.B)z=!0,R.outputChannels=4,R.decodeChannels={R:0,G:1,B:2,A:3};else if(d.R&&d.G)R.outputChannels=2,R.decodeChannels={R:0,G:1};else if(d.R)R.outputChannels=1,R.decodeChannels={R:0};else{if(!d.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");R.outputChannels=1,R.decodeChannels={Y:0}}if(1===R.type)switch(J){case dG.Float:R.getter=f,R.inputSize=X;break;case dG.HalfFloat:R.getter=D,R.inputSize=X}else{if(2!==R.type)throw new Error("Unsupported pixelType "+R.type+" for "+G.compression);switch(J){case dG.Float:R.getter=F,R.inputSize=k;break;case dG.HalfFloat:R.getter=v,R.inputSize=k}}R.blockCount=R.height/R.scanlineBlockSize;for(let k=0;k<R.blockCount;k++)e(V,W);const P=R.width*R.height*R.outputChannels;switch(J){case dG.Float:R.byteArray=new Float32Array(P),R.textureType=1,z&&R.byteArray.fill(1,0,P);break;case dG.HalfFloat:R.byteArray=new Uint16Array(P),R.textureType=2,z&&R.byteArray.fill(15360,0,P);break;default:throw new Error("Unsupported type: "+J)}let A=0;for(const k of G.channels)void 0!==R.decodeChannels[k.name]&&(R.channelLineOffsets[k.name]=A*R.width),A+=2*k.pixelType;return R.bytesPerLine=R.width*A,R.outLineWidth=R.width*R.outputChannels,"INCREASING_Y"===G.lineOrder?R.scanOrder=G=>G:R.scanOrder=G=>R.height-1-G,4==R.outputChannels?(R.format=5,R.linearSpace=!0):(R.format=6,R.linearSpace=!1),R}function PG(G,V,W,J){const R={value:0};for(let d=0;d<G.height/G.scanlineBlockSize;d++){const k=u(W,J)-V.dataWindow.yMin;G.size=H(W,J),G.lines=k+G.scanlineBlockSize>G.height?G.height-k:G.scanlineBlockSize;const z=G.size<G.lines*G.bytesPerLine&&G.uncompress?G.uncompress(G):GG(G);J.value+=G.size;for(let W=0;W<G.scanlineBlockSize;W++){const J=d*G.scanlineBlockSize,k=W+G.scanOrder(J);if(k>=G.height)continue;const X=W*G.bytesPerLine,P=(G.height-1-k)*G.outLineWidth;for(let W=0;W<G.channels;W++){const J=V.channels[W].name,d=G.channelLineOffsets[J],k=G.decodeChannels[J];if(void 0!==k){R.value=X+d;for(let V=0;V<G.width;V++){const W=P+V*G.outputChannels+k;G.byteArray&&(G.byteArray[W]=G.getter(z,R))}}}}}}zG.DefaultOutputType=dG.HalfFloat,zG.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class AG{constructor(){this.supportCascades=!1}loadCubeData(G,V,W,J,R){throw".exr not supported in Cube."}loadData(G,V,W){const R=new DataView(G.buffer),d={value:0},k=N(R,d);XG(k,R,d,zG.DefaultOutputType).then((G=>{PG(G,k,R,d);const J=k.dataWindow.xMax-k.dataWindow.xMin+1,z=k.dataWindow.yMax-k.dataWindow.yMin+1;W(J,z,V.generateMipMaps,!1,(()=>{const W=V.getEngine();V.format=k.format,V.type=G.textureType,V.invertY=!1,V._gammaSpace=!k.linearSpace,G.byteArray&&W._uploadDataToTextureDirectly(V,G.byteArray,0,0,void 0,!0)}))})).catch((G=>{J.c.Error("Failed to load EXR texture: ",G)}))}}async function xG(G){const V=new DataView(G),W={value:0},R=N(V,W);try{const G=await XG(R,V,W,dG.Float);return PG(G,R,V,W),G.byteArray?{width:R.dataWindow.xMax-R.dataWindow.xMin+1,height:R.dataWindow.yMax-R.dataWindow.yMin+1,data:new Float32Array(G.byteArray)}:(J.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(d){J.c.Error("Failed to load EXR data: ",d)}return{width:0,height:0,data:null}}}}]);