"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13666:(w,p,e)=>{e.r(p),e.d(p,{ReadExrDataAsync:()=>kw,_ExrTextureLoader:()=>Xw});var r=e(11081),I=e(11063);const d=4,f=4,q=1,E=2,j=8,X=65536,k=X>>3,m=14,J=65537,K=1<<m,y=K-1,c=59,s=63,O=2+s-c;var a,A;!function(w){w[w.NO_COMPRESSION=0]="NO_COMPRESSION",w[w.RLE_COMPRESSION=1]="RLE_COMPRESSION",w[w.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",w[w.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",w[w.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",w[w.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(a||(a={})),function(w){w[w.INCREASING_Y=0]="INCREASING_Y",w[w.DECREASING_Y=1]="DECREASING_Y"}(A||(A={}));const z=function(){const w=new ArrayBuffer(4),p=new Float32Array(w),e=new Uint32Array(w),r=new Uint32Array(512),I=new Uint32Array(512);for(let E=0;E<256;++E){const w=E-127;w<-27?(r[E]=0,r[256|E]=32768,I[E]=24,I[256|E]=24):w<-14?(r[E]=1024>>-w-14,r[256|E]=1024>>-w-14|32768,I[E]=-w-1,I[256|E]=-w-1):w<=15?(r[E]=w+15<<10,r[256|E]=w+15<<10|32768,I[E]=13,I[256|E]=13):w<128?(r[E]=31744,r[256|E]=64512,I[E]=24,I[256|E]=24):(r[E]=31744,r[256|E]=64512,I[E]=13,I[256|E]=13)}const d=new Uint32Array(2048),f=new Uint32Array(64),q=new Uint32Array(64);for(let E=1;E<1024;++E){let w=E<<13,p=0;for(;0===(8388608&w);)w<<=1,p-=8388608;w&=-8388609,p+=947912704,d[E]=w|p}for(let E=1024;E<2048;++E)d[E]=939524096+(E-1024<<13);for(let E=1;E<31;++E)f[E]=E<<23;f[31]=1199570944,f[32]=2147483648;for(let E=33;E<63;++E)f[E]=2147483648+(E-32<<23);f[63]=3347054592;for(let E=1;E<64;++E)32!==E&&(q[E]=1024);return{floatView:p,uint32View:e,baseTable:r,shiftTable:I,mantissaTable:d,exponentTable:f,offsetTable:q}}();function M(w,p){const e=new Uint8Array(w);let r=0;for(;0!=e[p.value+r];)r+=1;const I=(new TextDecoder).decode(e.slice(p.value,p.value+r));return p.value=p.value+r+1,I}function i(w,p){const e=w.getInt32(p.value,!0);return p.value+=d,e}function t(w,p){const e=w.getUint32(p.value,!0);return p.value+=d,e}function n(w,p){const e=w.getUint8(p.value);return p.value+=q,e}function l(w,p){const e=w.getUint16(p.value,!0);return p.value+=E,e}function N(w,p){const e=w[p.value];return p.value+=q,e}function U(w,p){let e;return e="getBigInt64"in DataView.prototype?Number(w.getBigInt64(p.value,!0)):w.getUint32(p.value+4,!0)+Number(w.getUint32(p.value,!0)<<32),p.value+=j,e}function v(w,p){const e=w.getFloat32(p.value,!0);return p.value+=f,e}function R(w,p){return function(w){const p=(31744&w)>>10,e=1023&w;return(w>>15?-1:1)*(p?31===p?e?NaN:1/0:Math.pow(2,p-15)*(1+e/1024):e/1024*6103515625e-14)}(l(w,p))}function V(w,p){return function(w){if(Math.abs(w)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");w=(0,I.Clamp)(w,-65504,65504),z.floatView[0]=w;const p=z.uint32View[0],e=p>>23&511;return z.baseTable[e]+((8388607&p)>>z.shiftTable[e])}(v(w,p))}function b(w,p,e,r){switch(e){case"string":case"stringvector":case"iccProfile":return function(w,p,e){const r=(new TextDecoder).decode(new Uint8Array(w).slice(p.value,p.value+e));return p.value=p.value+e,r}(w.buffer,p,r);case"chlist":return function(w,p,e){const r=p.value,I=[];for(;p.value<r+e-1;){const e=M(w.buffer,p),r=i(w,p),d=n(w,p);p.value+=3;const f=i(w,p),q=i(w,p);I.push({name:e,pixelType:r,pLinear:d,xSampling:f,ySampling:q})}return p.value+=1,I}(w,p,r);case"chromaticities":return function(w,p){return{redX:v(w,p),redY:v(w,p),greenX:v(w,p),greenY:v(w,p),blueX:v(w,p),blueY:v(w,p),whiteX:v(w,p),whiteY:v(w,p)}}(w,p);case"compression":return function(w,p){return n(w,p)}(w,p);case"box2i":return function(w,p){return{xMin:i(w,p),yMin:i(w,p),xMax:i(w,p),yMax:i(w,p)}}(w,p);case"lineOrder":return function(w,p){const e=n(w,p);return A[e]}(w,p);case"float":return v(w,p);case"v2f":return function(w,p){return[v(w,p),v(w,p)]}(w,p);case"v3f":return function(w,p){return[v(w,p),v(w,p),v(w,p)]}(w,p);case"int":return i(w,p);case"rational":return function(w,p){return[i(w,p),t(w,p)]}(w,p);case"timecode":return function(w,p){return[t(w,p),t(w,p)]}(w,p);case"preview":return p.value+=r,"skipped";default:return void(p.value+=r)}}function h(w){for(let p=1;p<w.length;p++){const e=w[p-1]+w[p]-128;w[p]=e}}function P(w,p){let e=0,r=Math.floor((w.length+1)/2),I=0;const d=w.length-1;for(;!(I>d)&&(p[I++]=w[e++],!(I>d));)p[I++]=w[r++]}const u=20000630;function Y(w,p){if(w.getUint32(0,!0)!=u)throw new Error("Incorrect OpenEXR format");const e=w.getUint8(4),I=w.getUint8(5),d={singleTile:!!(2&I),longName:!!(4&I),deepFormat:!!(8&I),multiPart:!!(16&I)};p.value=8;const f={};let q=!0;for(;q;){const e=M(w.buffer,p);if(e){const I=M(w.buffer,p),d=b(w,p,I,t(w,p));void 0===d?r.c.Warn(`Unknown header attribute type ${I}'.`):f[e]=d}else q=!1}if(0!=(-5&I))throw new Error("Unsupported file format");return{version:e,spec:d,...f}}const L=32768,W=65535;function F(w,p,e,r,I){for(;e<w;)p=p<<8|N(r,I),e+=8;return{l:p>>(e-=w)&(1<<w)-1,c:p,lc:e}}function H(w,p,e,r){return{c:w=w<<8|N(e,r),lc:p+=8}}function B(w,p,e,r,I,d,f,q,E){if(w==p){if(r<8){const w=H(e,r,I,d);e=w.c,r=w.lc}let w=e>>(r-=8);if(w=new Uint8Array([w])[0],q.value+w>E)return null;const p=f[q.value-1];for(;w-- >0;)f[q.value++]=p}else{if(!(q.value<E))return null;f[q.value++]=w}return{c:e,lc:r}}const D=new Array(59);function T(w,p,e,r,I,d){const f=p;let q=0,E=0;for(;r<=I;r++){if(f.value-p.value>e)return;let j=F(6,q,E,w,f);const X=j.l;if(q=j.c,E=j.lc,d[r]=X,X==s){if(f.value-p.value>e)throw new Error("Error in HufUnpackEncTable");j=F(8,q,E,w,f);let X=j.l+O;if(q=j.c,E=j.lc,r+X>I+1)throw new Error("Error in HufUnpackEncTable");for(;X--;)d[r++]=0;r--}else if(X>=c){let w=X-c+2;if(r+w>I+1)throw new Error("Error in HufUnpackEncTable");for(;w--;)d[r++]=0;r--}}!function(w){for(let e=0;e<=58;++e)D[e]=0;for(let e=0;e<J;++e)D[w[e]]+=1;let p=0;for(let e=58;e>0;--e){const w=p+D[e]>>1;D[e]=p,p=w}for(let e=0;e<J;++e){const p=w[e];p>0&&(w[e]=p|D[p]++<<6)}}(d)}function Z(w){return 63&w}function G(w){return w>>6}function g(w,p,e,r,I,d){const f=e.value,q=t(p,e),E=t(p,e);e.value+=4;const j=t(p,e);if(e.value+=4,q<0||q>=J||E<0||E>=J)throw new Error("Wrong HUF_ENCSIZE");const X=new Array(J),k=new Array(K);!function(w){for(let p=0;p<K;p++)w[p]={},w[p].len=0,w[p].lit=0,w[p].p=null}(k);if(T(w,e,r-(e.value-f),q,E,X),j>8*(r-(e.value-f)))throw new Error("Wrong hufUncompress");!function(w,p,e,r){for(;p<=e;p++){const e=G(w[p]),I=Z(w[p]);if(e>>I)throw new Error("Invalid table entry");if(I>m){const w=r[e>>I-m];if(w.len)throw new Error("Invalid table entry");if(w.lit++,w.p){const p=w.p;w.p=new Array(w.lit);for(let e=0;e<w.lit-1;++e)w.p[e]=p[e]}else w.p=new Array(1);w.p[w.lit-1]=p}else if(I){let w=0;for(let d=1<<m-I;d>0;d--){const d=r[(e<<m-I)+w];if(d.len||d.p)throw new Error("Invalid table entry");d.len=I,d.lit=p,w++}}}}(X,q,E,k),function(w,p,e,r,I,d,f,q,E){let j=0,X=0;const k=f,J=Math.trunc(r.value+(I+7)/8);for(;r.value<J;){let I=H(j,X,e,r);for(j=I.c,X=I.lc;X>=m;){const f=p[j>>X-m&y];if(f.len){X-=f.len;const w=B(f.lit,d,j,X,e,r,q,E,k);w&&(j=w.c,X=w.lc)}else{if(!f.p)throw new Error("hufDecode issues");let p;for(p=0;p<f.lit;p++){const m=Z(w[f.p[p]]);for(;X<m&&r.value<J;)I=H(j,X,e,r),j=I.c,X=I.lc;if(X>=m&&G(w[f.p[p]])==(j>>X-m&(1<<m)-1)){X-=m;const w=B(f.p[p],d,j,X,e,r,q,E,k);w&&(j=w.c,X=w.lc);break}}if(p==f.lit)throw new Error("HufDecode issues")}}}const K=8-I&7;for(j>>=K,X-=K;X>0;){const w=p[j<<m-X&y];if(!w.len)throw new Error("HufDecode issues");{X-=w.len;const p=B(w.lit,d,j,X,e,r,q,E,k);p&&(j=p.c,X=p.lc)}}}(X,k,w,e,j,E,d,I,{value:0})}function o(w){return 65535&w}function C(w){const p=o(w);return p>32767?p-65536:p}function Q(w,p){const e=C(w),r=C(p),I=e+(1&r)+(r>>1);return{a:I,b:I-r}}function x(w,p){const e=o(w),r=o(p),I=e-(r>>1)&W;return{a:r+I-L&W,b:I}}function S(w,p,e,r,I,d,f){const q=f<16384,E=e>I?I:e;let j,X,k=1;for(;k<=E;)k<<=1;for(k>>=1,j=k,k>>=1;k>=1;){X=0;const f=X+d*(I-j),E=d*k,m=d*j,J=r*k,K=r*j;let y,c,s,O;for(;X<=f;X+=m){let I=X;const d=X+r*(e-j);for(;I<=d;I+=K){const e=I+J,r=I+E,d=r+J;if(q){let f=Q(w[I+p],w[r+p]);y=f.a,s=f.b,f=Q(w[e+p],w[d+p]),c=f.a,O=f.b,f=Q(y,c),w[I+p]=f.a,w[e+p]=f.b,f=Q(s,O),w[r+p]=f.a,w[d+p]=f.b}else{let f=x(w[I+p],w[r+p]);y=f.a,s=f.b,f=x(w[e+p],w[d+p]),c=f.a,O=f.b,f=x(y,c),w[I+p]=f.a,w[e+p]=f.b,f=x(s,O),w[r+p]=f.a,w[d+p]=f.b}}if(e&k){const e=I+E;let r;r=q?Q(w[I+p],w[e+p]):x(w[I+p],w[e+p]),y=r.a,w[e+p]=r.b,w[I+p]=y}}if(I&k){let I=X;const d=X+r*(e-j);for(;I<=d;I+=K){const e=I+J;let r;r=q?Q(w[I+p],w[e+p]):x(w[I+p],w[e+p]),y=r.a,w[e+p]=r.b,w[I+p]=y}}j=k,k>>=1}return X}function ww(w){return new DataView(w.array.buffer,w.offset.value,w.size)}function pw(w){const p=w.viewer.buffer.slice(w.offset.value,w.offset.value+w.size),e=new Uint8Array(function(w){let p=w.byteLength;const e=[];let r=0;const I=new DataView(w);for(;p>0;){const w=I.getInt8(r++);if(w<0){const d=-w;p-=d+1;for(let w=0;w<d;w++)e.push(I.getUint8(r++))}else{const d=w;p-=2;const f=I.getUint8(r++);for(let w=0;w<d+1;w++)e.push(f)}}return e}(p)),r=new Uint8Array(e.length);return h(e),P(e,r),new DataView(r.buffer)}function ew(w){const p=w.array.slice(w.offset.value,w.offset.value+w.size),e=fflate.unzlibSync(p),r=new Uint8Array(e.length);return h(e),P(e,r),new DataView(r.buffer)}function rw(w){const p=w.array.slice(w.offset.value,w.offset.value+w.size),e=fflate.unzlibSync(p),r=w.lines*w.channels*w.width,I=1==w.type?new Uint16Array(r):new Uint32Array(r);let d=0,f=0;const q=new Array(4);for(let E=0;E<w.lines;E++)for(let p=0;p<w.channels;p++){let p=0;switch(w.type){case 1:q[0]=d,q[1]=q[0]+w.width,d=q[1]+w.width;for(let r=0;r<w.width;++r){p+=e[q[0]++]<<8|e[q[1]++],I[f]=p,f++}break;case 2:q[0]=d,q[1]=q[0]+w.width,q[2]=q[1]+w.width,d=q[2]+w.width;for(let r=0;r<w.width;++r){p+=e[q[0]++]<<24|e[q[1]++]<<16|e[q[2]++]<<8,I[f]=p,f++}}}return new DataView(I.buffer)}function Iw(w){const p=w.viewer,e={value:w.offset.value},r=new Uint16Array(w.width*w.scanlineBlockSize*(w.channels*w.type)),I=new Uint8Array(k);let d=0;const f=new Array(w.channels);for(let E=0;E<w.channels;E++)f[E]={},f[E].start=d,f[E].end=f[E].start,f[E].nx=w.width,f[E].ny=w.lines,f[E].size=w.type,d+=f[E].nx*f[E].ny*f[E].size;const q=l(p,e),j=l(p,e);if(j>=k)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(q<=j)for(let E=0;E<j-q+1;E++)I[E+q]=n(p,e);const m=new Uint16Array(X),J=function(w,p){let e=0;for(let I=0;I<X;++I)(0==I||w[I>>3]&1<<(7&I))&&(p[e++]=I);const r=e-1;for(;e<X;)p[e++]=0;return r}(I,m),K=t(p,e);g(w.array,p,e,K,r,d);for(let E=0;E<w.channels;++E){const w=f[E];for(let p=0;p<f[E].size;++p)S(r,w.start+p,w.nx,w.size,w.ny,w.nx*w.size,J)}!function(w,p,e){for(let r=0;r<e;++r)p[r]=w[p[r]]}(m,r,d);let y=0;const c=new Uint8Array(r.buffer.byteLength);for(let X=0;X<w.lines;X++)for(let p=0;p<w.channels;p++){const w=f[p],e=w.nx*w.size,I=new Uint8Array(r.buffer,w.end*E,e*E);c.set(I,y),y+=e*E,w.end+=e}return new DataView(c.buffer)}var dw,fw=e(11071);!function(w){w[w.Float=0]="Float",w[w.HalfFloat=1]="HalfFloat"}(dw||(dw={}));class qw{}async function Ew(w,p,e,r){const I={size:0,viewer:p,array:new Uint8Array(p.buffer),offset:e,width:w.dataWindow.xMax-w.dataWindow.xMin+1,height:w.dataWindow.yMax-w.dataWindow.yMin+1,channels:w.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(w.compression){case a.NO_COMPRESSION:I.lines=1,I.uncompress=ww;break;case a.RLE_COMPRESSION:I.lines=1,I.uncompress=pw;break;case a.ZIPS_COMPRESSION:I.lines=1,I.uncompress=ew,await fw.g.LoadScriptAsync(qw.FFLATEUrl);break;case a.ZIP_COMPRESSION:I.lines=16,I.uncompress=ew,await fw.g.LoadScriptAsync(qw.FFLATEUrl);break;case a.PIZ_COMPRESSION:I.lines=32,I.uncompress=Iw;break;case a.PXR24_COMPRESSION:I.lines=16,I.uncompress=rw,await fw.g.LoadScriptAsync(qw.FFLATEUrl);break;default:throw new Error(a[w.compression]+" is unsupported")}I.scanlineBlockSize=I.lines;const d={};for(const f of w.channels)switch(f.name){case"R":case"G":case"B":case"A":case"Y":d[f.name]=!0,I.type=f.pixelType}let q=!1;if(d.R&&d.G&&d.B&&d.A)I.outputChannels=4,I.decodeChannels={R:0,G:1,B:2,A:3};else if(d.R&&d.G&&d.B)q=!0,I.outputChannels=4,I.decodeChannels={R:0,G:1,B:2,A:3};else if(d.R&&d.G)I.outputChannels=2,I.decodeChannels={R:0,G:1};else if(d.R)I.outputChannels=1,I.decodeChannels={R:0};else{if(!d.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");I.outputChannels=1,I.decodeChannels={Y:0}}if(1===I.type)switch(r){case dw.Float:I.getter=R,I.inputSize=E;break;case dw.HalfFloat:I.getter=l,I.inputSize=E}else{if(2!==I.type)throw new Error("Unsupported pixelType "+I.type+" for "+w.compression);switch(r){case dw.Float:I.getter=v,I.inputSize=f;break;case dw.HalfFloat:I.getter=V,I.inputSize=f}}I.blockCount=I.height/I.scanlineBlockSize;for(let f=0;f<I.blockCount;f++)U(p,e);const j=I.width*I.height*I.outputChannels;switch(r){case dw.Float:I.byteArray=new Float32Array(j),I.textureType=1,q&&I.byteArray.fill(1,0,j);break;case dw.HalfFloat:I.byteArray=new Uint16Array(j),I.textureType=2,q&&I.byteArray.fill(15360,0,j);break;default:throw new Error("Unsupported type: "+r)}let X=0;for(const f of w.channels)void 0!==I.decodeChannels[f.name]&&(I.channelLineOffsets[f.name]=X*I.width),X+=2*f.pixelType;return I.bytesPerLine=I.width*X,I.outLineWidth=I.width*I.outputChannels,"INCREASING_Y"===w.lineOrder?I.scanOrder=w=>w:I.scanOrder=w=>I.height-1-w,4==I.outputChannels?(I.format=5,I.linearSpace=!0):(I.format=6,I.linearSpace=!1),I}function jw(w,p,e,r){const I={value:0};for(let d=0;d<w.height/w.scanlineBlockSize;d++){const f=i(e,r)-p.dataWindow.yMin;w.size=t(e,r),w.lines=f+w.scanlineBlockSize>w.height?w.height-f:w.scanlineBlockSize;const q=w.size<w.lines*w.bytesPerLine&&w.uncompress?w.uncompress(w):ww(w);r.value+=w.size;for(let e=0;e<w.scanlineBlockSize;e++){const r=d*w.scanlineBlockSize,f=e+w.scanOrder(r);if(f>=w.height)continue;const E=e*w.bytesPerLine,j=(w.height-1-f)*w.outLineWidth;for(let e=0;e<w.channels;e++){const r=p.channels[e].name,d=w.channelLineOffsets[r],f=w.decodeChannels[r];if(void 0!==f){I.value=E+d;for(let p=0;p<w.width;p++){const e=j+p*w.outputChannels+f;w.byteArray&&(w.byteArray[e]=w.getter(q,I))}}}}}}qw.DefaultOutputType=dw.HalfFloat,qw.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Xw{constructor(){this.supportCascades=!1}loadCubeData(w,p,e,r,I){throw".exr not supported in Cube."}loadData(w,p,e){const I=new DataView(w.buffer),d={value:0},f=Y(I,d);Ew(f,I,d,qw.DefaultOutputType).then((w=>{jw(w,f,I,d);const r=f.dataWindow.xMax-f.dataWindow.xMin+1,q=f.dataWindow.yMax-f.dataWindow.yMin+1;e(r,q,p.generateMipMaps,!1,(()=>{const e=p.getEngine();p.format=f.format,p.type=w.textureType,p.invertY=!1,p._gammaSpace=!f.linearSpace,w.byteArray&&e._uploadDataToTextureDirectly(p,w.byteArray,0,0,void 0,!0)}))})).catch((w=>{r.c.Error("Failed to load EXR texture: ",w)}))}}async function kw(w){const p=new DataView(w),e={value:0},I=Y(p,e);try{const w=await Ew(I,p,e,dw.Float);return jw(w,I,p,e),w.byteArray?{width:I.dataWindow.xMax-I.dataWindow.xMin+1,height:I.dataWindow.yMax-I.dataWindow.yMin+1,data:new Float32Array(w.byteArray)}:(r.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(d){r.c.Error("Failed to load EXR data: ",d)}return{width:0,height:0,data:null}}}}]);