"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13401:(q,c,U)=>{U.r(c),U.d(c,{ReadExrDataAsync:()=>uq,_ExrTextureLoader:()=>Dq});var J=U(10886),Q=U(10870);const s=4,g=4,X=1,n=2,W=8,D=65536,u=D>>3,K=14,r=65537,H=1<<K,b=H-1,h=59,o=63,a=2+o-h;var p,R;!function(q){q[q.NO_COMPRESSION=0]="NO_COMPRESSION",q[q.RLE_COMPRESSION=1]="RLE_COMPRESSION",q[q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",q[q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",q[q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",q[q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(p||(p={})),function(q){q[q.INCREASING_Y=0]="INCREASING_Y",q[q.DECREASING_Y=1]="DECREASING_Y"}(R||(R={}));const I=function(){const q=new ArrayBuffer(4),c=new Float32Array(q),U=new Uint32Array(q),J=new Uint32Array(512),Q=new Uint32Array(512);for(let n=0;n<256;++n){const q=n-127;q<-27?(J[n]=0,J[256|n]=32768,Q[n]=24,Q[256|n]=24):q<-14?(J[n]=1024>>-q-14,J[256|n]=1024>>-q-14|32768,Q[n]=-q-1,Q[256|n]=-q-1):q<=15?(J[n]=q+15<<10,J[256|n]=q+15<<10|32768,Q[n]=13,Q[256|n]=13):q<128?(J[n]=31744,J[256|n]=64512,Q[n]=24,Q[256|n]=24):(J[n]=31744,J[256|n]=64512,Q[n]=13,Q[256|n]=13)}const s=new Uint32Array(2048),g=new Uint32Array(64),X=new Uint32Array(64);for(let n=1;n<1024;++n){let q=n<<13,c=0;for(;0===(8388608&q);)q<<=1,c-=8388608;q&=-8388609,c+=947912704,s[n]=q|c}for(let n=1024;n<2048;++n)s[n]=939524096+(n-1024<<13);for(let n=1;n<31;++n)g[n]=n<<23;g[31]=1199570944,g[32]=2147483648;for(let n=33;n<63;++n)g[n]=2147483648+(n-32<<23);g[63]=3347054592;for(let n=1;n<64;++n)32!==n&&(X[n]=1024);return{floatView:c,uint32View:U,baseTable:J,shiftTable:Q,mantissaTable:s,exponentTable:g,offsetTable:X}}();function t(q,c){const U=new Uint8Array(q);let J=0;for(;0!=U[c.value+J];)J+=1;const Q=(new TextDecoder).decode(U.slice(c.value,c.value+J));return c.value=c.value+J+1,Q}function C(q,c){const U=q.getInt32(c.value,!0);return c.value+=s,U}function i(q,c){const U=q.getUint32(c.value,!0);return c.value+=s,U}function F(q,c){const U=q.getUint8(c.value);return c.value+=X,U}function v(q,c){const U=q.getUint16(c.value,!0);return c.value+=n,U}function Y(q,c){const U=q[c.value];return c.value+=X,U}function k(q,c){let U;return U="getBigInt64"in DataView.prototype?Number(q.getBigInt64(c.value,!0)):q.getUint32(c.value+4,!0)+Number(q.getUint32(c.value,!0)<<32),c.value+=W,U}function V(q,c){const U=q.getFloat32(c.value,!0);return c.value+=g,U}function O(q,c){return function(q){const c=(31744&q)>>10,U=1023&q;return(q>>15?-1:1)*(c?31===c?U?NaN:1/0:Math.pow(2,c-15)*(1+U/1024):U/1024*6103515625e-14)}(v(q,c))}function G(q,c){return function(q){if(Math.abs(q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");q=(0,Q.Clamp)(q,-65504,65504),I.floatView[0]=q;const c=I.uint32View[0],U=c>>23&511;return I.baseTable[U]+((8388607&c)>>I.shiftTable[U])}(V(q,c))}function S(q,c,U,J){switch(U){case"string":case"stringvector":case"iccProfile":return function(q,c,U){const J=(new TextDecoder).decode(new Uint8Array(q).slice(c.value,c.value+U));return c.value=c.value+U,J}(q.buffer,c,J);case"chlist":return function(q,c,U){const J=c.value,Q=[];for(;c.value<J+U-1;){const U=t(q.buffer,c),J=C(q,c),s=F(q,c);c.value+=3;const g=C(q,c),X=C(q,c);Q.push({name:U,pixelType:J,pLinear:s,xSampling:g,ySampling:X})}return c.value+=1,Q}(q,c,J);case"chromaticities":return function(q,c){return{redX:V(q,c),redY:V(q,c),greenX:V(q,c),greenY:V(q,c),blueX:V(q,c),blueY:V(q,c),whiteX:V(q,c),whiteY:V(q,c)}}(q,c);case"compression":return function(q,c){return F(q,c)}(q,c);case"box2i":return function(q,c){return{xMin:C(q,c),yMin:C(q,c),xMax:C(q,c),yMax:C(q,c)}}(q,c);case"lineOrder":return function(q,c){const U=F(q,c);return R[U]}(q,c);case"float":return V(q,c);case"v2f":return function(q,c){return[V(q,c),V(q,c)]}(q,c);case"v3f":return function(q,c){return[V(q,c),V(q,c),V(q,c)]}(q,c);case"int":return C(q,c);case"rational":return function(q,c){return[C(q,c),i(q,c)]}(q,c);case"timecode":return function(q,c){return[i(q,c),i(q,c)]}(q,c);case"preview":return c.value+=J,"skipped";default:return void(c.value+=J)}}function Z(q){for(let c=1;c<q.length;c++){const U=q[c-1]+q[c]-128;q[c]=U}}function x(q,c){let U=0,J=Math.floor((q.length+1)/2),Q=0;const s=q.length-1;for(;!(Q>s)&&(c[Q++]=q[U++],!(Q>s));)c[Q++]=q[J++]}const z=20000630;function y(q,c){if(q.getUint32(0,!0)!=z)throw new Error("Incorrect OpenEXR format");const U=q.getUint8(4),Q=q.getUint8(5),s={singleTile:!!(2&Q),longName:!!(4&Q),deepFormat:!!(8&Q),multiPart:!!(16&Q)};c.value=8;const g={};let X=!0;for(;X;){const U=t(q.buffer,c);if(U){const Q=t(q.buffer,c),s=S(q,c,Q,i(q,c));void 0===s?J.c.Warn(`Unknown header attribute type ${Q}'.`):g[U]=s}else X=!1}if(0!=(-5&Q))throw new Error("Unsupported file format");return{version:U,spec:s,...g}}const M=32768,T=65535;function m(q,c,U,J,Q){for(;U<q;)c=c<<8|Y(J,Q),U+=8;return{l:c>>(U-=q)&(1<<q)-1,c:c,lc:U}}function d(q,c,U,J){return{c:q=q<<8|Y(U,J),lc:c+=8}}function e(q,c,U,J,Q,s,g,X,n){if(q==c){if(J<8){const q=d(U,J,Q,s);U=q.c,J=q.lc}let q=U>>(J-=8);if(q=new Uint8Array([q])[0],X.value+q>n)return null;const c=g[X.value-1];for(;q-- >0;)g[X.value++]=c}else{if(!(X.value<n))return null;g[X.value++]=q}return{c:U,lc:J}}const B=new Array(59);function N(q,c,U,J,Q,s){const g=c;let X=0,n=0;for(;J<=Q;J++){if(g.value-c.value>U)return;let W=m(6,X,n,q,g);const D=W.l;if(X=W.c,n=W.lc,s[J]=D,D==o){if(g.value-c.value>U)throw new Error("Error in HufUnpackEncTable");W=m(8,X,n,q,g);let D=W.l+a;if(X=W.c,n=W.lc,J+D>Q+1)throw new Error("Error in HufUnpackEncTable");for(;D--;)s[J++]=0;J--}else if(D>=h){let q=D-h+2;if(J+q>Q+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)s[J++]=0;J--}}!function(q){for(let U=0;U<=58;++U)B[U]=0;for(let U=0;U<r;++U)B[q[U]]+=1;let c=0;for(let U=58;U>0;--U){const q=c+B[U]>>1;B[U]=c,c=q}for(let U=0;U<r;++U){const c=q[U];c>0&&(q[U]=c|B[c]++<<6)}}(s)}function P(q){return 63&q}function w(q){return q>>6}function L(q,c,U,J,Q,s){const g=U.value,X=i(c,U),n=i(c,U);U.value+=4;const W=i(c,U);if(U.value+=4,X<0||X>=r||n<0||n>=r)throw new Error("Wrong HUF_ENCSIZE");const D=new Array(r),u=new Array(H);!function(q){for(let c=0;c<H;c++)q[c]={},q[c].len=0,q[c].lit=0,q[c].p=null}(u);if(N(q,U,J-(U.value-g),X,n,D),W>8*(J-(U.value-g)))throw new Error("Wrong hufUncompress");!function(q,c,U,J){for(;c<=U;c++){const U=w(q[c]),Q=P(q[c]);if(U>>Q)throw new Error("Invalid table entry");if(Q>K){const q=J[U>>Q-K];if(q.len)throw new Error("Invalid table entry");if(q.lit++,q.p){const c=q.p;q.p=new Array(q.lit);for(let U=0;U<q.lit-1;++U)q.p[U]=c[U]}else q.p=new Array(1);q.p[q.lit-1]=c}else if(Q){let q=0;for(let s=1<<K-Q;s>0;s--){const s=J[(U<<K-Q)+q];if(s.len||s.p)throw new Error("Invalid table entry");s.len=Q,s.lit=c,q++}}}}(D,X,n,u),function(q,c,U,J,Q,s,g,X,n){let W=0,D=0;const u=g,r=Math.trunc(J.value+(Q+7)/8);for(;J.value<r;){let Q=d(W,D,U,J);for(W=Q.c,D=Q.lc;D>=K;){const g=c[W>>D-K&b];if(g.len){D-=g.len;const q=e(g.lit,s,W,D,U,J,X,n,u);q&&(W=q.c,D=q.lc)}else{if(!g.p)throw new Error("hufDecode issues");let c;for(c=0;c<g.lit;c++){const K=P(q[g.p[c]]);for(;D<K&&J.value<r;)Q=d(W,D,U,J),W=Q.c,D=Q.lc;if(D>=K&&w(q[g.p[c]])==(W>>D-K&(1<<K)-1)){D-=K;const q=e(g.p[c],s,W,D,U,J,X,n,u);q&&(W=q.c,D=q.lc);break}}if(c==g.lit)throw new Error("HufDecode issues")}}}const H=8-Q&7;for(W>>=H,D-=H;D>0;){const q=c[W<<K-D&b];if(!q.len)throw new Error("HufDecode issues");{D-=q.len;const c=e(q.lit,s,W,D,U,J,X,n,u);c&&(W=c.c,D=c.lc)}}}(D,u,q,U,W,n,s,Q,{value:0})}function l(q){return 65535&q}function j(q){const c=l(q);return c>32767?c-65536:c}function f(q,c){const U=j(q),J=j(c),Q=U+(1&J)+(J>>1);return{a:Q,b:Q-J}}function A(q,c){const U=l(q),J=l(c),Q=U-(J>>1)&T;return{a:J+Q-M&T,b:Q}}function E(q,c,U,J,Q,s,g){const X=g<16384,n=U>Q?Q:U;let W,D,u=1;for(;u<=n;)u<<=1;for(u>>=1,W=u,u>>=1;u>=1;){D=0;const g=D+s*(Q-W),n=s*u,K=s*W,r=J*u,H=J*W;let b,h,o,a;for(;D<=g;D+=K){let Q=D;const s=D+J*(U-W);for(;Q<=s;Q+=H){const U=Q+r,J=Q+n,s=J+r;if(X){let g=f(q[Q+c],q[J+c]);b=g.a,o=g.b,g=f(q[U+c],q[s+c]),h=g.a,a=g.b,g=f(b,h),q[Q+c]=g.a,q[U+c]=g.b,g=f(o,a),q[J+c]=g.a,q[s+c]=g.b}else{let g=A(q[Q+c],q[J+c]);b=g.a,o=g.b,g=A(q[U+c],q[s+c]),h=g.a,a=g.b,g=A(b,h),q[Q+c]=g.a,q[U+c]=g.b,g=A(o,a),q[J+c]=g.a,q[s+c]=g.b}}if(U&u){const U=Q+n;let J;J=X?f(q[Q+c],q[U+c]):A(q[Q+c],q[U+c]),b=J.a,q[U+c]=J.b,q[Q+c]=b}}if(Q&u){let Q=D;const s=D+J*(U-W);for(;Q<=s;Q+=H){const U=Q+r;let J;J=X?f(q[Q+c],q[U+c]):A(q[Q+c],q[U+c]),b=J.a,q[U+c]=J.b,q[Q+c]=b}}W=u,u>>=1}return D}function qq(q){return new DataView(q.array.buffer,q.offset.value,q.size)}function cq(q){const c=q.viewer.buffer.slice(q.offset.value,q.offset.value+q.size),U=new Uint8Array(function(q){let c=q.byteLength;const U=[];let J=0;const Q=new DataView(q);for(;c>0;){const q=Q.getInt8(J++);if(q<0){const s=-q;c-=s+1;for(let q=0;q<s;q++)U.push(Q.getUint8(J++))}else{const s=q;c-=2;const g=Q.getUint8(J++);for(let q=0;q<s+1;q++)U.push(g)}}return U}(c)),J=new Uint8Array(U.length);return Z(U),x(U,J),new DataView(J.buffer)}function Uq(q){const c=q.array.slice(q.offset.value,q.offset.value+q.size),U=fflate.unzlibSync(c),J=new Uint8Array(U.length);return Z(U),x(U,J),new DataView(J.buffer)}function Jq(q){const c=q.array.slice(q.offset.value,q.offset.value+q.size),U=fflate.unzlibSync(c),J=q.lines*q.channels*q.width,Q=1==q.type?new Uint16Array(J):new Uint32Array(J);let s=0,g=0;const X=new Array(4);for(let n=0;n<q.lines;n++)for(let c=0;c<q.channels;c++){let c=0;switch(q.type){case 1:X[0]=s,X[1]=X[0]+q.width,s=X[1]+q.width;for(let J=0;J<q.width;++J){c+=U[X[0]++]<<8|U[X[1]++],Q[g]=c,g++}break;case 2:X[0]=s,X[1]=X[0]+q.width,X[2]=X[1]+q.width,s=X[2]+q.width;for(let J=0;J<q.width;++J){c+=U[X[0]++]<<24|U[X[1]++]<<16|U[X[2]++]<<8,Q[g]=c,g++}}}return new DataView(Q.buffer)}function Qq(q){const c=q.viewer,U={value:q.offset.value},J=new Uint16Array(q.width*q.scanlineBlockSize*(q.channels*q.type)),Q=new Uint8Array(u);let s=0;const g=new Array(q.channels);for(let n=0;n<q.channels;n++)g[n]={},g[n].start=s,g[n].end=g[n].start,g[n].nx=q.width,g[n].ny=q.lines,g[n].size=q.type,s+=g[n].nx*g[n].ny*g[n].size;const X=v(c,U),W=v(c,U);if(W>=u)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(X<=W)for(let n=0;n<W-X+1;n++)Q[n+X]=F(c,U);const K=new Uint16Array(D),r=function(q,c){let U=0;for(let Q=0;Q<D;++Q)(0==Q||q[Q>>3]&1<<(7&Q))&&(c[U++]=Q);const J=U-1;for(;U<D;)c[U++]=0;return J}(Q,K),H=i(c,U);L(q.array,c,U,H,J,s);for(let n=0;n<q.channels;++n){const q=g[n];for(let c=0;c<g[n].size;++c)E(J,q.start+c,q.nx,q.size,q.ny,q.nx*q.size,r)}!function(q,c,U){for(let J=0;J<U;++J)c[J]=q[c[J]]}(K,J,s);let b=0;const h=new Uint8Array(J.buffer.byteLength);for(let D=0;D<q.lines;D++)for(let c=0;c<q.channels;c++){const q=g[c],U=q.nx*q.size,Q=new Uint8Array(J.buffer,q.end*n,U*n);h.set(Q,b),b+=U*n,q.end+=U}return new DataView(h.buffer)}var sq,gq=U(10879);!function(q){q[q.Float=0]="Float",q[q.HalfFloat=1]="HalfFloat"}(sq||(sq={}));class Xq{}async function nq(q,c,U,J){const Q={size:0,viewer:c,array:new Uint8Array(c.buffer),offset:U,width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,channels:q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(q.compression){case p.NO_COMPRESSION:Q.lines=1,Q.uncompress=qq;break;case p.RLE_COMPRESSION:Q.lines=1,Q.uncompress=cq;break;case p.ZIPS_COMPRESSION:Q.lines=1,Q.uncompress=Uq,await gq.e.LoadScriptAsync(Xq.FFLATEUrl);break;case p.ZIP_COMPRESSION:Q.lines=16,Q.uncompress=Uq,await gq.e.LoadScriptAsync(Xq.FFLATEUrl);break;case p.PIZ_COMPRESSION:Q.lines=32,Q.uncompress=Qq;break;case p.PXR24_COMPRESSION:Q.lines=16,Q.uncompress=Jq,await gq.e.LoadScriptAsync(Xq.FFLATEUrl);break;default:throw new Error(p[q.compression]+" is unsupported")}Q.scanlineBlockSize=Q.lines;const s={};for(const g of q.channels)switch(g.name){case"R":case"G":case"B":case"A":case"Y":s[g.name]=!0,Q.type=g.pixelType}let X=!1;if(s.R&&s.G&&s.B&&s.A)Q.outputChannels=4,Q.decodeChannels={R:0,G:1,B:2,A:3};else if(s.R&&s.G&&s.B)X=!0,Q.outputChannels=4,Q.decodeChannels={R:0,G:1,B:2,A:3};else if(s.R&&s.G)Q.outputChannels=2,Q.decodeChannels={R:0,G:1};else if(s.R)Q.outputChannels=1,Q.decodeChannels={R:0};else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Q.outputChannels=1,Q.decodeChannels={Y:0}}if(1===Q.type)switch(J){case sq.Float:Q.getter=O,Q.inputSize=n;break;case sq.HalfFloat:Q.getter=v,Q.inputSize=n}else{if(2!==Q.type)throw new Error("Unsupported pixelType "+Q.type+" for "+q.compression);switch(J){case sq.Float:Q.getter=V,Q.inputSize=g;break;case sq.HalfFloat:Q.getter=G,Q.inputSize=g}}Q.blockCount=Q.height/Q.scanlineBlockSize;for(let g=0;g<Q.blockCount;g++)k(c,U);const W=Q.width*Q.height*Q.outputChannels;switch(J){case sq.Float:Q.byteArray=new Float32Array(W),Q.textureType=1,X&&Q.byteArray.fill(1,0,W);break;case sq.HalfFloat:Q.byteArray=new Uint16Array(W),Q.textureType=2,X&&Q.byteArray.fill(15360,0,W);break;default:throw new Error("Unsupported type: "+J)}let D=0;for(const g of q.channels)void 0!==Q.decodeChannels[g.name]&&(Q.channelLineOffsets[g.name]=D*Q.width),D+=2*g.pixelType;return Q.bytesPerLine=Q.width*D,Q.outLineWidth=Q.width*Q.outputChannels,"INCREASING_Y"===q.lineOrder?Q.scanOrder=q=>q:Q.scanOrder=q=>Q.height-1-q,4==Q.outputChannels?(Q.format=5,Q.linearSpace=!0):(Q.format=6,Q.linearSpace=!1),Q}function Wq(q,c,U,J){const Q={value:0};for(let s=0;s<q.height/q.scanlineBlockSize;s++){const g=C(U,J)-c.dataWindow.yMin;q.size=i(U,J),q.lines=g+q.scanlineBlockSize>q.height?q.height-g:q.scanlineBlockSize;const X=q.size<q.lines*q.bytesPerLine&&q.uncompress?q.uncompress(q):qq(q);J.value+=q.size;for(let U=0;U<q.scanlineBlockSize;U++){const J=s*q.scanlineBlockSize,g=U+q.scanOrder(J);if(g>=q.height)continue;const n=U*q.bytesPerLine,W=(q.height-1-g)*q.outLineWidth;for(let U=0;U<q.channels;U++){const J=c.channels[U].name,s=q.channelLineOffsets[J],g=q.decodeChannels[J];if(void 0!==g){Q.value=n+s;for(let c=0;c<q.width;c++){const U=W+c*q.outputChannels+g;q.byteArray&&(q.byteArray[U]=q.getter(X,Q))}}}}}}Xq.DefaultOutputType=sq.HalfFloat,Xq.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Dq{constructor(){this.supportCascades=!1}loadCubeData(q,c,U,J,Q){throw".exr not supported in Cube."}loadData(q,c,U){const Q=new DataView(q.buffer),s={value:0},g=y(Q,s);nq(g,Q,s,Xq.DefaultOutputType).then((q=>{Wq(q,g,Q,s);const J=g.dataWindow.xMax-g.dataWindow.xMin+1,X=g.dataWindow.yMax-g.dataWindow.yMin+1;U(J,X,c.generateMipMaps,!1,(()=>{const U=c.getEngine();c.format=g.format,c.type=q.textureType,c.invertY=!1,c._gammaSpace=!g.linearSpace,q.byteArray&&U._uploadDataToTextureDirectly(c,q.byteArray,0,0,void 0,!0)}))})).catch((q=>{J.c.Error("Failed to load EXR texture: ",q)}))}}async function uq(q){const c=new DataView(q),U={value:0},Q=y(c,U);try{const q=await nq(Q,c,U,sq.Float);return Wq(q,Q,c,U),q.byteArray?{width:Q.dataWindow.xMax-Q.dataWindow.xMin+1,height:Q.dataWindow.yMax-Q.dataWindow.yMin+1,data:new Float32Array(q.byteArray)}:(J.c.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(s){J.c.Error("Failed to load EXR data: ",s)}return{width:0,height:0,data:null}}}}]);