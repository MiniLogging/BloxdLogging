"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13684:(V,I,m)=>{m.r(I),m.d(I,{ReadExrDataAsync:()=>YV,_ExrTextureLoader:()=>KV});var C=m(11085),l=m(11074);const s=4,F=4,k=1,j=2,E=8,K=65536,Y=K>>3,X=14,O=65537,v=1<<X,N=v-1,t=59,D=63,b=2+D-t;var T,n;!function(V){V[V.NO_COMPRESSION=0]="NO_COMPRESSION",V[V.RLE_COMPRESSION=1]="RLE_COMPRESSION",V[V.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",V[V.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",V[V.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",V[V.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(T||(T={})),function(V){V[V.INCREASING_Y=0]="INCREASING_Y",V[V.DECREASING_Y=1]="DECREASING_Y"}(n||(n={}));const x=function(){const V=new ArrayBuffer(4),I=new Float32Array(V),m=new Uint32Array(V),C=new Uint32Array(512),l=new Uint32Array(512);for(let j=0;j<256;++j){const V=j-127;V<-27?(C[j]=0,C[256|j]=32768,l[j]=24,l[256|j]=24):V<-14?(C[j]=1024>>-V-14,C[256|j]=1024>>-V-14|32768,l[j]=-V-1,l[256|j]=-V-1):V<=15?(C[j]=V+15<<10,C[256|j]=V+15<<10|32768,l[j]=13,l[256|j]=13):V<128?(C[j]=31744,C[256|j]=64512,l[j]=24,l[256|j]=24):(C[j]=31744,C[256|j]=64512,l[j]=13,l[256|j]=13)}const s=new Uint32Array(2048),F=new Uint32Array(64),k=new Uint32Array(64);for(let j=1;j<1024;++j){let V=j<<13,I=0;for(;0===(8388608&V);)V<<=1,I-=8388608;V&=-8388609,I+=947912704,s[j]=V|I}for(let j=1024;j<2048;++j)s[j]=939524096+(j-1024<<13);for(let j=1;j<31;++j)F[j]=j<<23;F[31]=1199570944,F[32]=2147483648;for(let j=33;j<63;++j)F[j]=2147483648+(j-32<<23);F[63]=3347054592;for(let j=1;j<64;++j)32!==j&&(k[j]=1024);return{floatView:I,uint32View:m,baseTable:C,shiftTable:l,mantissaTable:s,exponentTable:F,offsetTable:k}}();function S(V,I){const m=new Uint8Array(V);let C=0;for(;0!=m[I.value+C];)C+=1;const l=(new TextDecoder).decode(m.slice(I.value,I.value+C));return I.value=I.value+C+1,l}function c(V,I){const m=V.getInt32(I.value,!0);return I.value+=s,m}function H(V,I){const m=V.getUint32(I.value,!0);return I.value+=s,m}function y(V,I){const m=V.getUint8(I.value);return I.value+=k,m}function z(V,I){const m=V.getUint16(I.value,!0);return I.value+=j,m}function Z(V,I){const m=V[I.value];return I.value+=k,m}function B(V,I){let m;return m="getBigInt64"in DataView.prototype?Number(V.getBigInt64(I.value,!0)):V.getUint32(I.value+4,!0)+Number(V.getUint32(I.value,!0)<<32),I.value+=E,m}function W(V,I){const m=V.getFloat32(I.value,!0);return I.value+=F,m}function Q(V,I){return function(V){const I=(31744&V)>>10,m=1023&V;return(V>>15?-1:1)*(I?31===I?m?NaN:1/0:Math.pow(2,I-15)*(1+m/1024):m/1024*6103515625e-14)}(z(V,I))}function G(V,I){return function(V){if(Math.abs(V)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");V=(0,l.Clamp)(V,-65504,65504),x.floatView[0]=V;const I=x.uint32View[0],m=I>>23&511;return x.baseTable[m]+((8388607&I)>>x.shiftTable[m])}(W(V,I))}function r(V,I,m,C){switch(m){case"string":case"stringvector":case"iccProfile":return function(V,I,m){const C=(new TextDecoder).decode(new Uint8Array(V).slice(I.value,I.value+m));return I.value=I.value+m,C}(V.buffer,I,C);case"chlist":return function(V,I,m){const C=I.value,l=[];for(;I.value<C+m-1;){const m=S(V.buffer,I),C=c(V,I),s=y(V,I);I.value+=3;const F=c(V,I),k=c(V,I);l.push({name:m,pixelType:C,pLinear:s,xSampling:F,ySampling:k})}return I.value+=1,l}(V,I,C);case"chromaticities":return function(V,I){return{redX:W(V,I),redY:W(V,I),greenX:W(V,I),greenY:W(V,I),blueX:W(V,I),blueY:W(V,I),whiteX:W(V,I),whiteY:W(V,I)}}(V,I);case"compression":return function(V,I){return y(V,I)}(V,I);case"box2i":return function(V,I){return{xMin:c(V,I),yMin:c(V,I),xMax:c(V,I),yMax:c(V,I)}}(V,I);case"lineOrder":return function(V,I){const m=y(V,I);return n[m]}(V,I);case"float":return W(V,I);case"v2f":return function(V,I){return[W(V,I),W(V,I)]}(V,I);case"v3f":return function(V,I){return[W(V,I),W(V,I),W(V,I)]}(V,I);case"int":return c(V,I);case"rational":return function(V,I){return[c(V,I),H(V,I)]}(V,I);case"timecode":return function(V,I){return[H(V,I),H(V,I)]}(V,I);case"preview":return I.value+=C,"skipped";default:return void(I.value+=C)}}function g(V){for(let I=1;I<V.length;I++){const m=V[I-1]+V[I]-128;V[I]=m}}function h(V,I){let m=0,C=Math.floor((V.length+1)/2),l=0;const s=V.length-1;for(;!(l>s)&&(I[l++]=V[m++],!(l>s));)I[l++]=V[C++]}const d=20000630;function R(V,I){if(V.getUint32(0,!0)!=d)throw new Error("Incorrect OpenEXR format");const m=V.getUint8(4),l=V.getUint8(5),s={singleTile:!!(2&l),longName:!!(4&l),deepFormat:!!(8&l),multiPart:!!(16&l)};I.value=8;const F={};let k=!0;for(;k;){const m=S(V.buffer,I);if(m){const l=S(V.buffer,I),s=r(V,I,l,H(V,I));void 0===s?C.d.Warn(`Unknown header attribute type ${l}'.`):F[m]=s}else k=!1}if(0!=(-5&l))throw new Error("Unsupported file format");return{version:m,spec:s,...F}}const i=32768,q=65535;function P(V,I,m,C,l){for(;m<V;)I=I<<8|Z(C,l),m+=8;return{l:I>>(m-=V)&(1<<V)-1,c:I,lc:m}}function u(V,I,m,C){return{c:V=V<<8|Z(m,C),lc:I+=8}}function o(V,I,m,C,l,s,F,k,j){if(V==I){if(C<8){const V=u(m,C,l,s);m=V.c,C=V.lc}let V=m>>(C-=8);if(V=new Uint8Array([V])[0],k.value+V>j)return null;const I=F[k.value-1];for(;V-- >0;)F[k.value++]=I}else{if(!(k.value<j))return null;F[k.value++]=V}return{c:m,lc:C}}const p=new Array(59);function M(V,I,m,C,l,s){const F=I;let k=0,j=0;for(;C<=l;C++){if(F.value-I.value>m)return;let E=P(6,k,j,V,F);const K=E.l;if(k=E.c,j=E.lc,s[C]=K,K==D){if(F.value-I.value>m)throw new Error("Error in HufUnpackEncTable");E=P(8,k,j,V,F);let K=E.l+b;if(k=E.c,j=E.lc,C+K>l+1)throw new Error("Error in HufUnpackEncTable");for(;K--;)s[C++]=0;C--}else if(K>=t){let V=K-t+2;if(C+V>l+1)throw new Error("Error in HufUnpackEncTable");for(;V--;)s[C++]=0;C--}}!function(V){for(let m=0;m<=58;++m)p[m]=0;for(let m=0;m<O;++m)p[V[m]]+=1;let I=0;for(let m=58;m>0;--m){const V=I+p[m]>>1;p[m]=I,I=V}for(let m=0;m<O;++m){const I=V[m];I>0&&(V[m]=I|p[I]++<<6)}}(s)}function f(V){return 63&V}function w(V){return V>>6}function A(V,I,m,C,l,s){const F=m.value,k=H(I,m),j=H(I,m);m.value+=4;const E=H(I,m);if(m.value+=4,k<0||k>=O||j<0||j>=O)throw new Error("Wrong HUF_ENCSIZE");const K=new Array(O),Y=new Array(v);!function(V){for(let I=0;I<v;I++)V[I]={},V[I].len=0,V[I].lit=0,V[I].p=null}(Y);if(M(V,m,C-(m.value-F),k,j,K),E>8*(C-(m.value-F)))throw new Error("Wrong hufUncompress");!function(V,I,m,C){for(;I<=m;I++){const m=w(V[I]),l=f(V[I]);if(m>>l)throw new Error("Invalid table entry");if(l>X){const V=C[m>>l-X];if(V.len)throw new Error("Invalid table entry");if(V.lit++,V.p){const I=V.p;V.p=new Array(V.lit);for(let m=0;m<V.lit-1;++m)V.p[m]=I[m]}else V.p=new Array(1);V.p[V.lit-1]=I}else if(l){let V=0;for(let s=1<<X-l;s>0;s--){const s=C[(m<<X-l)+V];if(s.len||s.p)throw new Error("Invalid table entry");s.len=l,s.lit=I,V++}}}}(K,k,j,Y),function(V,I,m,C,l,s,F,k,j){let E=0,K=0;const Y=F,O=Math.trunc(C.value+(l+7)/8);for(;C.value<O;){let l=u(E,K,m,C);for(E=l.c,K=l.lc;K>=X;){const F=I[E>>K-X&N];if(F.len){K-=F.len;const V=o(F.lit,s,E,K,m,C,k,j,Y);V&&(E=V.c,K=V.lc)}else{if(!F.p)throw new Error("hufDecode issues");let I;for(I=0;I<F.lit;I++){const X=f(V[F.p[I]]);for(;K<X&&C.value<O;)l=u(E,K,m,C),E=l.c,K=l.lc;if(K>=X&&w(V[F.p[I]])==(E>>K-X&(1<<X)-1)){K-=X;const V=o(F.p[I],s,E,K,m,C,k,j,Y);V&&(E=V.c,K=V.lc);break}}if(I==F.lit)throw new Error("HufDecode issues")}}}const v=8-l&7;for(E>>=v,K-=v;K>0;){const V=I[E<<X-K&N];if(!V.len)throw new Error("HufDecode issues");{K-=V.len;const I=o(V.lit,s,E,K,m,C,k,j,Y);I&&(E=I.c,K=I.lc)}}}(K,Y,V,m,E,j,s,l,{value:0})}function J(V){return 65535&V}function U(V){const I=J(V);return I>32767?I-65536:I}function e(V,I){const m=U(V),C=U(I),l=m+(1&C)+(C>>1);return{a:l,b:l-C}}function a(V,I){const m=J(V),C=J(I),l=m-(C>>1)&q;return{a:C+l-i&q,b:l}}function L(V,I,m,C,l,s,F){const k=F<16384,j=m>l?l:m;let E,K,Y=1;for(;Y<=j;)Y<<=1;for(Y>>=1,E=Y,Y>>=1;Y>=1;){K=0;const F=K+s*(l-E),j=s*Y,X=s*E,O=C*Y,v=C*E;let N,t,D,b;for(;K<=F;K+=X){let l=K;const s=K+C*(m-E);for(;l<=s;l+=v){const m=l+O,C=l+j,s=C+O;if(k){let F=e(V[l+I],V[C+I]);N=F.a,D=F.b,F=e(V[m+I],V[s+I]),t=F.a,b=F.b,F=e(N,t),V[l+I]=F.a,V[m+I]=F.b,F=e(D,b),V[C+I]=F.a,V[s+I]=F.b}else{let F=a(V[l+I],V[C+I]);N=F.a,D=F.b,F=a(V[m+I],V[s+I]),t=F.a,b=F.b,F=a(N,t),V[l+I]=F.a,V[m+I]=F.b,F=a(D,b),V[C+I]=F.a,V[s+I]=F.b}}if(m&Y){const m=l+j;let C;C=k?e(V[l+I],V[m+I]):a(V[l+I],V[m+I]),N=C.a,V[m+I]=C.b,V[l+I]=N}}if(l&Y){let l=K;const s=K+C*(m-E);for(;l<=s;l+=v){const m=l+O;let C;C=k?e(V[l+I],V[m+I]):a(V[l+I],V[m+I]),N=C.a,V[m+I]=C.b,V[l+I]=N}}E=Y,Y>>=1}return K}function VV(V){return new DataView(V.array.buffer,V.offset.value,V.size)}function IV(V){const I=V.viewer.buffer.slice(V.offset.value,V.offset.value+V.size),m=new Uint8Array(function(V){let I=V.byteLength;const m=[];let C=0;const l=new DataView(V);for(;I>0;){const V=l.getInt8(C++);if(V<0){const s=-V;I-=s+1;for(let V=0;V<s;V++)m.push(l.getUint8(C++))}else{const s=V;I-=2;const F=l.getUint8(C++);for(let V=0;V<s+1;V++)m.push(F)}}return m}(I)),C=new Uint8Array(m.length);return g(m),h(m,C),new DataView(C.buffer)}function mV(V){const I=V.array.slice(V.offset.value,V.offset.value+V.size),m=fflate.unzlibSync(I),C=new Uint8Array(m.length);return g(m),h(m,C),new DataView(C.buffer)}function CV(V){const I=V.array.slice(V.offset.value,V.offset.value+V.size),m=fflate.unzlibSync(I),C=V.lines*V.channels*V.width,l=1==V.type?new Uint16Array(C):new Uint32Array(C);let s=0,F=0;const k=new Array(4);for(let j=0;j<V.lines;j++)for(let I=0;I<V.channels;I++){let I=0;switch(V.type){case 1:k[0]=s,k[1]=k[0]+V.width,s=k[1]+V.width;for(let C=0;C<V.width;++C){I+=m[k[0]++]<<8|m[k[1]++],l[F]=I,F++}break;case 2:k[0]=s,k[1]=k[0]+V.width,k[2]=k[1]+V.width,s=k[2]+V.width;for(let C=0;C<V.width;++C){I+=m[k[0]++]<<24|m[k[1]++]<<16|m[k[2]++]<<8,l[F]=I,F++}}}return new DataView(l.buffer)}function lV(V){const I=V.viewer,m={value:V.offset.value},C=new Uint16Array(V.width*V.scanlineBlockSize*(V.channels*V.type)),l=new Uint8Array(Y);let s=0;const F=new Array(V.channels);for(let j=0;j<V.channels;j++)F[j]={},F[j].start=s,F[j].end=F[j].start,F[j].nx=V.width,F[j].ny=V.lines,F[j].size=V.type,s+=F[j].nx*F[j].ny*F[j].size;const k=z(I,m),E=z(I,m);if(E>=Y)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(k<=E)for(let j=0;j<E-k+1;j++)l[j+k]=y(I,m);const X=new Uint16Array(K),O=function(V,I){let m=0;for(let l=0;l<K;++l)(0==l||V[l>>3]&1<<(7&l))&&(I[m++]=l);const C=m-1;for(;m<K;)I[m++]=0;return C}(l,X),v=H(I,m);A(V.array,I,m,v,C,s);for(let j=0;j<V.channels;++j){const V=F[j];for(let I=0;I<F[j].size;++I)L(C,V.start+I,V.nx,V.size,V.ny,V.nx*V.size,O)}!function(V,I,m){for(let C=0;C<m;++C)I[C]=V[I[C]]}(X,C,s);let N=0;const t=new Uint8Array(C.buffer.byteLength);for(let K=0;K<V.lines;K++)for(let I=0;I<V.channels;I++){const V=F[I],m=V.nx*V.size,l=new Uint8Array(C.buffer,V.end*j,m*j);t.set(l,N),N+=m*j,V.end+=m}return new DataView(t.buffer)}var sV,FV=m(11076);!function(V){V[V.Float=0]="Float",V[V.HalfFloat=1]="HalfFloat"}(sV||(sV={}));class kV{}async function jV(V,I,m,C){const l={size:0,viewer:I,array:new Uint8Array(I.buffer),offset:m,width:V.dataWindow.xMax-V.dataWindow.xMin+1,height:V.dataWindow.yMax-V.dataWindow.yMin+1,channels:V.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(V.compression){case T.NO_COMPRESSION:l.lines=1,l.uncompress=VV;break;case T.RLE_COMPRESSION:l.lines=1,l.uncompress=IV;break;case T.ZIPS_COMPRESSION:l.lines=1,l.uncompress=mV,await FV.d.LoadScriptAsync(kV.FFLATEUrl);break;case T.ZIP_COMPRESSION:l.lines=16,l.uncompress=mV,await FV.d.LoadScriptAsync(kV.FFLATEUrl);break;case T.PIZ_COMPRESSION:l.lines=32,l.uncompress=lV;break;case T.PXR24_COMPRESSION:l.lines=16,l.uncompress=CV,await FV.d.LoadScriptAsync(kV.FFLATEUrl);break;default:throw new Error(T[V.compression]+" is unsupported")}l.scanlineBlockSize=l.lines;const s={};for(const F of V.channels)switch(F.name){case"R":case"G":case"B":case"A":case"Y":s[F.name]=!0,l.type=F.pixelType}let k=!1;if(s.R&&s.G&&s.B&&s.A)l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(s.R&&s.G&&s.B)k=!0,l.outputChannels=4,l.decodeChannels={R:0,G:1,B:2,A:3};else if(s.R&&s.G)l.outputChannels=2,l.decodeChannels={R:0,G:1};else if(s.R)l.outputChannels=1,l.decodeChannels={R:0};else{if(!s.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");l.outputChannels=1,l.decodeChannels={Y:0}}if(1===l.type)switch(C){case sV.Float:l.getter=Q,l.inputSize=j;break;case sV.HalfFloat:l.getter=z,l.inputSize=j}else{if(2!==l.type)throw new Error("Unsupported pixelType "+l.type+" for "+V.compression);switch(C){case sV.Float:l.getter=W,l.inputSize=F;break;case sV.HalfFloat:l.getter=G,l.inputSize=F}}l.blockCount=l.height/l.scanlineBlockSize;for(let F=0;F<l.blockCount;F++)B(I,m);const E=l.width*l.height*l.outputChannels;switch(C){case sV.Float:l.byteArray=new Float32Array(E),l.textureType=1,k&&l.byteArray.fill(1,0,E);break;case sV.HalfFloat:l.byteArray=new Uint16Array(E),l.textureType=2,k&&l.byteArray.fill(15360,0,E);break;default:throw new Error("Unsupported type: "+C)}let K=0;for(const F of V.channels)void 0!==l.decodeChannels[F.name]&&(l.channelLineOffsets[F.name]=K*l.width),K+=2*F.pixelType;return l.bytesPerLine=l.width*K,l.outLineWidth=l.width*l.outputChannels,"INCREASING_Y"===V.lineOrder?l.scanOrder=V=>V:l.scanOrder=V=>l.height-1-V,4==l.outputChannels?(l.format=5,l.linearSpace=!0):(l.format=6,l.linearSpace=!1),l}function EV(V,I,m,C){const l={value:0};for(let s=0;s<V.height/V.scanlineBlockSize;s++){const F=c(m,C)-I.dataWindow.yMin;V.size=H(m,C),V.lines=F+V.scanlineBlockSize>V.height?V.height-F:V.scanlineBlockSize;const k=V.size<V.lines*V.bytesPerLine&&V.uncompress?V.uncompress(V):VV(V);C.value+=V.size;for(let m=0;m<V.scanlineBlockSize;m++){const C=s*V.scanlineBlockSize,F=m+V.scanOrder(C);if(F>=V.height)continue;const j=m*V.bytesPerLine,E=(V.height-1-F)*V.outLineWidth;for(let m=0;m<V.channels;m++){const C=I.channels[m].name,s=V.channelLineOffsets[C],F=V.decodeChannels[C];if(void 0!==F){l.value=j+s;for(let I=0;I<V.width;I++){const m=E+I*V.outputChannels+F;V.byteArray&&(V.byteArray[m]=V.getter(k,l))}}}}}}kV.DefaultOutputType=sV.HalfFloat,kV.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class KV{constructor(){this.supportCascades=!1}loadCubeData(V,I,m,C,l){throw".exr not supported in Cube."}loadData(V,I,m){const l=new DataView(V.buffer),s={value:0},F=R(l,s);jV(F,l,s,kV.DefaultOutputType).then((V=>{EV(V,F,l,s);const C=F.dataWindow.xMax-F.dataWindow.xMin+1,k=F.dataWindow.yMax-F.dataWindow.yMin+1;m(C,k,I.generateMipMaps,!1,(()=>{const m=I.getEngine();I.format=F.format,I.type=V.textureType,I.invertY=!1,I._gammaSpace=!F.linearSpace,V.byteArray&&m._uploadDataToTextureDirectly(I,V.byteArray,0,0,void 0,!0)}))})).catch((V=>{C.d.Error("Failed to load EXR texture: ",V)}))}}async function YV(V){const I=new DataView(V),m={value:0},l=R(I,m);try{const V=await jV(l,I,m,sV.Float);return EV(V,l,I,m),V.byteArray?{width:l.dataWindow.xMax-l.dataWindow.xMin+1,height:l.dataWindow.yMax-l.dataWindow.yMin+1,data:new Float32Array(V.byteArray)}:(C.d.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(s){C.d.Error("Failed to load EXR data: ",s)}return{width:0,height:0,data:null}}}}]);