"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13476:(x,O,Q)=>{Q.r(O),Q.d(O,{ReadExrDataAsync:()=>Lx,_ExrTextureLoader:()=>Ux});var X=Q(10905),Z=Q(10889);const n=4,V=4,o=1,l=2,C=8,U=65536,L=U>>3,h=14,N=65537,a=1<<h,K=a-1,M=59,Y=63,g=2+Y-M;var v,R;!function(x){x[x.NO_COMPRESSION=0]="NO_COMPRESSION",x[x.RLE_COMPRESSION=1]="RLE_COMPRESSION",x[x.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",x[x.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",x[x.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",x[x.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(v||(v={})),function(x){x[x.INCREASING_Y=0]="INCREASING_Y",x[x.DECREASING_Y=1]="DECREASING_Y"}(R||(R={}));const s=function(){const x=new ArrayBuffer(4),O=new Float32Array(x),Q=new Uint32Array(x),X=new Uint32Array(512),Z=new Uint32Array(512);for(let l=0;l<256;++l){const x=l-127;x<-27?(X[l]=0,X[256|l]=32768,Z[l]=24,Z[256|l]=24):x<-14?(X[l]=1024>>-x-14,X[256|l]=1024>>-x-14|32768,Z[l]=-x-1,Z[256|l]=-x-1):x<=15?(X[l]=x+15<<10,X[256|l]=x+15<<10|32768,Z[l]=13,Z[256|l]=13):x<128?(X[l]=31744,X[256|l]=64512,Z[l]=24,Z[256|l]=24):(X[l]=31744,X[256|l]=64512,Z[l]=13,Z[256|l]=13)}const n=new Uint32Array(2048),V=new Uint32Array(64),o=new Uint32Array(64);for(let l=1;l<1024;++l){let x=l<<13,O=0;for(;0===(8388608&x);)x<<=1,O-=8388608;x&=-8388609,O+=947912704,n[l]=x|O}for(let l=1024;l<2048;++l)n[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)V[l]=l<<23;V[31]=1199570944,V[32]=2147483648;for(let l=33;l<63;++l)V[l]=2147483648+(l-32<<23);V[63]=3347054592;for(let l=1;l<64;++l)32!==l&&(o[l]=1024);return{floatView:O,uint32View:Q,baseTable:X,shiftTable:Z,mantissaTable:n,exponentTable:V,offsetTable:o}}();function q(x,O){const Q=new Uint8Array(x);let X=0;for(;0!=Q[O.value+X];)X+=1;const Z=(new TextDecoder).decode(Q.slice(O.value,O.value+X));return O.value=O.value+X+1,Z}function G(x,O){const Q=x.getInt32(O.value,!0);return O.value+=n,Q}function k(x,O){const Q=x.getUint32(O.value,!0);return O.value+=n,Q}function J(x,O){const Q=x.getUint8(O.value);return O.value+=o,Q}function t(x,O){const Q=x.getUint16(O.value,!0);return O.value+=l,Q}function c(x,O){const Q=x[O.value];return O.value+=o,Q}function d(x,O){let Q;return Q="getBigInt64"in DataView.prototype?Number(x.getBigInt64(O.value,!0)):x.getUint32(O.value+4,!0)+Number(x.getUint32(O.value,!0)<<32),O.value+=C,Q}function u(x,O){const Q=x.getFloat32(O.value,!0);return O.value+=V,Q}function A(x,O){return function(x){const O=(31744&x)>>10,Q=1023&x;return(x>>15?-1:1)*(O?31===O?Q?NaN:1/0:Math.pow(2,O-15)*(1+Q/1024):Q/1024*6103515625e-14)}(t(x,O))}function f(x,O){return function(x){if(Math.abs(x)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");x=(0,Z.Clamp)(x,-65504,65504),s.floatView[0]=x;const O=s.uint32View[0],Q=O>>23&511;return s.baseTable[Q]+((8388607&O)>>s.shiftTable[Q])}(u(x,O))}function E(x,O,Q,X){switch(Q){case"string":case"stringvector":case"iccProfile":return function(x,O,Q){const X=(new TextDecoder).decode(new Uint8Array(x).slice(O.value,O.value+Q));return O.value=O.value+Q,X}(x.buffer,O,X);case"chlist":return function(x,O,Q){const X=O.value,Z=[];for(;O.value<X+Q-1;){const Q=q(x.buffer,O),X=G(x,O),n=J(x,O);O.value+=3;const V=G(x,O),o=G(x,O);Z.push({name:Q,pixelType:X,pLinear:n,xSampling:V,ySampling:o})}return O.value+=1,Z}(x,O,X);case"chromaticities":return function(x,O){return{redX:u(x,O),redY:u(x,O),greenX:u(x,O),greenY:u(x,O),blueX:u(x,O),blueY:u(x,O),whiteX:u(x,O),whiteY:u(x,O)}}(x,O);case"compression":return function(x,O){return J(x,O)}(x,O);case"box2i":return function(x,O){return{xMin:G(x,O),yMin:G(x,O),xMax:G(x,O),yMax:G(x,O)}}(x,O);case"lineOrder":return function(x,O){const Q=J(x,O);return R[Q]}(x,O);case"float":return u(x,O);case"v2f":return function(x,O){return[u(x,O),u(x,O)]}(x,O);case"v3f":return function(x,O){return[u(x,O),u(x,O),u(x,O)]}(x,O);case"int":return G(x,O);case"rational":return function(x,O){return[G(x,O),k(x,O)]}(x,O);case"timecode":return function(x,O){return[k(x,O),k(x,O)]}(x,O);case"preview":return O.value+=X,"skipped";default:return void(O.value+=X)}}function z(x){for(let O=1;O<x.length;O++){const Q=x[O-1]+x[O]-128;x[O]=Q}}function F(x,O){let Q=0,X=Math.floor((x.length+1)/2),Z=0;const n=x.length-1;for(;!(Z>n)&&(O[Z++]=x[Q++],!(Z>n));)O[Z++]=x[X++]}const b=20000630;function D(x,O){if(x.getUint32(0,!0)!=b)throw new Error("Incorrect OpenEXR format");const Q=x.getUint8(4),Z=x.getUint8(5),n={singleTile:!!(2&Z),longName:!!(4&Z),deepFormat:!!(8&Z),multiPart:!!(16&Z)};O.value=8;const V={};let o=!0;for(;o;){const Q=q(x.buffer,O);if(Q){const Z=q(x.buffer,O),n=E(x,O,Z,k(x,O));void 0===n?X.e.Warn(`Unknown header attribute type ${Z}'.`):V[Q]=n}else o=!1}if(0!=(-5&Z))throw new Error("Unsupported file format");return{version:Q,spec:n,...V}}const W=32768,y=65535;function I(x,O,Q,X,Z){for(;Q<x;)O=O<<8|c(X,Z),Q+=8;return{l:O>>(Q-=x)&(1<<x)-1,c:O,lc:Q}}function r(x,O,Q,X){return{c:x=x<<8|c(Q,X),lc:O+=8}}function j(x,O,Q,X,Z,n,V,o,l){if(x==O){if(X<8){const x=r(Q,X,Z,n);Q=x.c,X=x.lc}let x=Q>>(X-=8);if(x=new Uint8Array([x])[0],o.value+x>l)return null;const O=V[o.value-1];for(;x-- >0;)V[o.value++]=O}else{if(!(o.value<l))return null;V[o.value++]=x}return{c:Q,lc:X}}const T=new Array(59);function e(x,O,Q,X,Z,n){const V=O;let o=0,l=0;for(;X<=Z;X++){if(V.value-O.value>Q)return;let C=I(6,o,l,x,V);const U=C.l;if(o=C.c,l=C.lc,n[X]=U,U==Y){if(V.value-O.value>Q)throw new Error("Error in HufUnpackEncTable");C=I(8,o,l,x,V);let U=C.l+g;if(o=C.c,l=C.lc,X+U>Z+1)throw new Error("Error in HufUnpackEncTable");for(;U--;)n[X++]=0;X--}else if(U>=M){let x=U-M+2;if(X+x>Z+1)throw new Error("Error in HufUnpackEncTable");for(;x--;)n[X++]=0;X--}}!function(x){for(let Q=0;Q<=58;++Q)T[Q]=0;for(let Q=0;Q<N;++Q)T[x[Q]]+=1;let O=0;for(let Q=58;Q>0;--Q){const x=O+T[Q]>>1;T[Q]=O,O=x}for(let Q=0;Q<N;++Q){const O=x[Q];O>0&&(x[Q]=O|T[O]++<<6)}}(n)}function B(x){return 63&x}function i(x){return x>>6}function H(x,O,Q,X,Z,n){const V=Q.value,o=k(O,Q),l=k(O,Q);Q.value+=4;const C=k(O,Q);if(Q.value+=4,o<0||o>=N||l<0||l>=N)throw new Error("Wrong HUF_ENCSIZE");const U=new Array(N),L=new Array(a);!function(x){for(let O=0;O<a;O++)x[O]={},x[O].len=0,x[O].lit=0,x[O].p=null}(L);if(e(x,Q,X-(Q.value-V),o,l,U),C>8*(X-(Q.value-V)))throw new Error("Wrong hufUncompress");!function(x,O,Q,X){for(;O<=Q;O++){const Q=i(x[O]),Z=B(x[O]);if(Q>>Z)throw new Error("Invalid table entry");if(Z>h){const x=X[Q>>Z-h];if(x.len)throw new Error("Invalid table entry");if(x.lit++,x.p){const O=x.p;x.p=new Array(x.lit);for(let Q=0;Q<x.lit-1;++Q)x.p[Q]=O[Q]}else x.p=new Array(1);x.p[x.lit-1]=O}else if(Z){let x=0;for(let n=1<<h-Z;n>0;n--){const n=X[(Q<<h-Z)+x];if(n.len||n.p)throw new Error("Invalid table entry");n.len=Z,n.lit=O,x++}}}}(U,o,l,L),function(x,O,Q,X,Z,n,V,o,l){let C=0,U=0;const L=V,N=Math.trunc(X.value+(Z+7)/8);for(;X.value<N;){let Z=r(C,U,Q,X);for(C=Z.c,U=Z.lc;U>=h;){const V=O[C>>U-h&K];if(V.len){U-=V.len;const x=j(V.lit,n,C,U,Q,X,o,l,L);x&&(C=x.c,U=x.lc)}else{if(!V.p)throw new Error("hufDecode issues");let O;for(O=0;O<V.lit;O++){const h=B(x[V.p[O]]);for(;U<h&&X.value<N;)Z=r(C,U,Q,X),C=Z.c,U=Z.lc;if(U>=h&&i(x[V.p[O]])==(C>>U-h&(1<<h)-1)){U-=h;const x=j(V.p[O],n,C,U,Q,X,o,l,L);x&&(C=x.c,U=x.lc);break}}if(O==V.lit)throw new Error("HufDecode issues")}}}const a=8-Z&7;for(C>>=a,U-=a;U>0;){const x=O[C<<h-U&K];if(!x.len)throw new Error("HufDecode issues");{U-=x.len;const O=j(x.lit,n,C,U,Q,X,o,l,L);O&&(C=O.c,U=O.lc)}}}(U,L,x,Q,C,l,n,Z,{value:0})}function S(x){return 65535&x}function p(x){const O=S(x);return O>32767?O-65536:O}function P(x,O){const Q=p(x),X=p(O),Z=Q+(1&X)+(X>>1);return{a:Z,b:Z-X}}function m(x,O){const Q=S(x),X=S(O),Z=Q-(X>>1)&y;return{a:X+Z-W&y,b:Z}}function w(x,O,Q,X,Z,n,V){const o=V<16384,l=Q>Z?Z:Q;let C,U,L=1;for(;L<=l;)L<<=1;for(L>>=1,C=L,L>>=1;L>=1;){U=0;const V=U+n*(Z-C),l=n*L,h=n*C,N=X*L,a=X*C;let K,M,Y,g;for(;U<=V;U+=h){let Z=U;const n=U+X*(Q-C);for(;Z<=n;Z+=a){const Q=Z+N,X=Z+l,n=X+N;if(o){let V=P(x[Z+O],x[X+O]);K=V.a,Y=V.b,V=P(x[Q+O],x[n+O]),M=V.a,g=V.b,V=P(K,M),x[Z+O]=V.a,x[Q+O]=V.b,V=P(Y,g),x[X+O]=V.a,x[n+O]=V.b}else{let V=m(x[Z+O],x[X+O]);K=V.a,Y=V.b,V=m(x[Q+O],x[n+O]),M=V.a,g=V.b,V=m(K,M),x[Z+O]=V.a,x[Q+O]=V.b,V=m(Y,g),x[X+O]=V.a,x[n+O]=V.b}}if(Q&L){const Q=Z+l;let X;X=o?P(x[Z+O],x[Q+O]):m(x[Z+O],x[Q+O]),K=X.a,x[Q+O]=X.b,x[Z+O]=K}}if(Z&L){let Z=U;const n=U+X*(Q-C);for(;Z<=n;Z+=a){const Q=Z+N;let X;X=o?P(x[Z+O],x[Q+O]):m(x[Z+O],x[Q+O]),K=X.a,x[Q+O]=X.b,x[Z+O]=K}}C=L,L>>=1}return U}function xx(x){return new DataView(x.array.buffer,x.offset.value,x.size)}function Ox(x){const O=x.viewer.buffer.slice(x.offset.value,x.offset.value+x.size),Q=new Uint8Array(function(x){let O=x.byteLength;const Q=[];let X=0;const Z=new DataView(x);for(;O>0;){const x=Z.getInt8(X++);if(x<0){const n=-x;O-=n+1;for(let x=0;x<n;x++)Q.push(Z.getUint8(X++))}else{const n=x;O-=2;const V=Z.getUint8(X++);for(let x=0;x<n+1;x++)Q.push(V)}}return Q}(O)),X=new Uint8Array(Q.length);return z(Q),F(Q,X),new DataView(X.buffer)}function Qx(x){const O=x.array.slice(x.offset.value,x.offset.value+x.size),Q=fflate.unzlibSync(O),X=new Uint8Array(Q.length);return z(Q),F(Q,X),new DataView(X.buffer)}function Xx(x){const O=x.array.slice(x.offset.value,x.offset.value+x.size),Q=fflate.unzlibSync(O),X=x.lines*x.channels*x.width,Z=1==x.type?new Uint16Array(X):new Uint32Array(X);let n=0,V=0;const o=new Array(4);for(let l=0;l<x.lines;l++)for(let O=0;O<x.channels;O++){let O=0;switch(x.type){case 1:o[0]=n,o[1]=o[0]+x.width,n=o[1]+x.width;for(let X=0;X<x.width;++X){O+=Q[o[0]++]<<8|Q[o[1]++],Z[V]=O,V++}break;case 2:o[0]=n,o[1]=o[0]+x.width,o[2]=o[1]+x.width,n=o[2]+x.width;for(let X=0;X<x.width;++X){O+=Q[o[0]++]<<24|Q[o[1]++]<<16|Q[o[2]++]<<8,Z[V]=O,V++}}}return new DataView(Z.buffer)}function Zx(x){const O=x.viewer,Q={value:x.offset.value},X=new Uint16Array(x.width*x.scanlineBlockSize*(x.channels*x.type)),Z=new Uint8Array(L);let n=0;const V=new Array(x.channels);for(let l=0;l<x.channels;l++)V[l]={},V[l].start=n,V[l].end=V[l].start,V[l].nx=x.width,V[l].ny=x.lines,V[l].size=x.type,n+=V[l].nx*V[l].ny*V[l].size;const o=t(O,Q),C=t(O,Q);if(C>=L)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(o<=C)for(let l=0;l<C-o+1;l++)Z[l+o]=J(O,Q);const h=new Uint16Array(U),N=function(x,O){let Q=0;for(let Z=0;Z<U;++Z)(0==Z||x[Z>>3]&1<<(7&Z))&&(O[Q++]=Z);const X=Q-1;for(;Q<U;)O[Q++]=0;return X}(Z,h),a=k(O,Q);H(x.array,O,Q,a,X,n);for(let l=0;l<x.channels;++l){const x=V[l];for(let O=0;O<V[l].size;++O)w(X,x.start+O,x.nx,x.size,x.ny,x.nx*x.size,N)}!function(x,O,Q){for(let X=0;X<Q;++X)O[X]=x[O[X]]}(h,X,n);let K=0;const M=new Uint8Array(X.buffer.byteLength);for(let U=0;U<x.lines;U++)for(let O=0;O<x.channels;O++){const x=V[O],Q=x.nx*x.size,Z=new Uint8Array(X.buffer,x.end*l,Q*l);M.set(Z,K),K+=Q*l,x.end+=Q}return new DataView(M.buffer)}var nx,Vx=Q(10894);!function(x){x[x.Float=0]="Float",x[x.HalfFloat=1]="HalfFloat"}(nx||(nx={}));class ox{}async function lx(x,O,Q,X){const Z={size:0,viewer:O,array:new Uint8Array(O.buffer),offset:Q,width:x.dataWindow.xMax-x.dataWindow.xMin+1,height:x.dataWindow.yMax-x.dataWindow.yMin+1,channels:x.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(x.compression){case v.NO_COMPRESSION:Z.lines=1,Z.uncompress=xx;break;case v.RLE_COMPRESSION:Z.lines=1,Z.uncompress=Ox;break;case v.ZIPS_COMPRESSION:Z.lines=1,Z.uncompress=Qx,await Vx.g.LoadScriptAsync(ox.FFLATEUrl);break;case v.ZIP_COMPRESSION:Z.lines=16,Z.uncompress=Qx,await Vx.g.LoadScriptAsync(ox.FFLATEUrl);break;case v.PIZ_COMPRESSION:Z.lines=32,Z.uncompress=Zx;break;case v.PXR24_COMPRESSION:Z.lines=16,Z.uncompress=Xx,await Vx.g.LoadScriptAsync(ox.FFLATEUrl);break;default:throw new Error(v[x.compression]+" is unsupported")}Z.scanlineBlockSize=Z.lines;const n={};for(const V of x.channels)switch(V.name){case"R":case"G":case"B":case"A":case"Y":n[V.name]=!0,Z.type=V.pixelType}let o=!1;if(n.R&&n.G&&n.B&&n.A)Z.outputChannels=4,Z.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G&&n.B)o=!0,Z.outputChannels=4,Z.decodeChannels={R:0,G:1,B:2,A:3};else if(n.R&&n.G)Z.outputChannels=2,Z.decodeChannels={R:0,G:1};else if(n.R)Z.outputChannels=1,Z.decodeChannels={R:0};else{if(!n.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");Z.outputChannels=1,Z.decodeChannels={Y:0}}if(1===Z.type)switch(X){case nx.Float:Z.getter=A,Z.inputSize=l;break;case nx.HalfFloat:Z.getter=t,Z.inputSize=l}else{if(2!==Z.type)throw new Error("Unsupported pixelType "+Z.type+" for "+x.compression);switch(X){case nx.Float:Z.getter=u,Z.inputSize=V;break;case nx.HalfFloat:Z.getter=f,Z.inputSize=V}}Z.blockCount=Z.height/Z.scanlineBlockSize;for(let V=0;V<Z.blockCount;V++)d(O,Q);const C=Z.width*Z.height*Z.outputChannels;switch(X){case nx.Float:Z.byteArray=new Float32Array(C),Z.textureType=1,o&&Z.byteArray.fill(1,0,C);break;case nx.HalfFloat:Z.byteArray=new Uint16Array(C),Z.textureType=2,o&&Z.byteArray.fill(15360,0,C);break;default:throw new Error("Unsupported type: "+X)}let U=0;for(const V of x.channels)void 0!==Z.decodeChannels[V.name]&&(Z.channelLineOffsets[V.name]=U*Z.width),U+=2*V.pixelType;return Z.bytesPerLine=Z.width*U,Z.outLineWidth=Z.width*Z.outputChannels,"INCREASING_Y"===x.lineOrder?Z.scanOrder=x=>x:Z.scanOrder=x=>Z.height-1-x,4==Z.outputChannels?(Z.format=5,Z.linearSpace=!0):(Z.format=6,Z.linearSpace=!1),Z}function Cx(x,O,Q,X){const Z={value:0};for(let n=0;n<x.height/x.scanlineBlockSize;n++){const V=G(Q,X)-O.dataWindow.yMin;x.size=k(Q,X),x.lines=V+x.scanlineBlockSize>x.height?x.height-V:x.scanlineBlockSize;const o=x.size<x.lines*x.bytesPerLine&&x.uncompress?x.uncompress(x):xx(x);X.value+=x.size;for(let Q=0;Q<x.scanlineBlockSize;Q++){const X=n*x.scanlineBlockSize,V=Q+x.scanOrder(X);if(V>=x.height)continue;const l=Q*x.bytesPerLine,C=(x.height-1-V)*x.outLineWidth;for(let Q=0;Q<x.channels;Q++){const X=O.channels[Q].name,n=x.channelLineOffsets[X],V=x.decodeChannels[X];if(void 0!==V){Z.value=l+n;for(let O=0;O<x.width;O++){const Q=C+O*x.outputChannels+V;x.byteArray&&(x.byteArray[Q]=x.getter(o,Z))}}}}}}ox.DefaultOutputType=nx.HalfFloat,ox.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Ux{constructor(){this.supportCascades=!1}loadCubeData(x,O,Q,X,Z){throw".exr not supported in Cube."}loadData(x,O,Q){const Z=new DataView(x.buffer),n={value:0},V=D(Z,n);lx(V,Z,n,ox.DefaultOutputType).then((x=>{Cx(x,V,Z,n);const X=V.dataWindow.xMax-V.dataWindow.xMin+1,o=V.dataWindow.yMax-V.dataWindow.yMin+1;Q(X,o,O.generateMipMaps,!1,(()=>{const Q=O.getEngine();O.format=V.format,O.type=x.textureType,O.invertY=!1,O._gammaSpace=!V.linearSpace,x.byteArray&&Q._uploadDataToTextureDirectly(O,x.byteArray,0,0,void 0,!0)}))})).catch((x=>{X.e.Error("Failed to load EXR texture: ",x)}))}}async function Lx(x){const O=new DataView(x),Q={value:0},Z=D(O,Q);try{const x=await lx(Z,O,Q,nx.Float);return Cx(x,Z,O,Q),x.byteArray?{width:Z.dataWindow.xMax-Z.dataWindow.xMin+1,height:Z.dataWindow.yMax-Z.dataWindow.yMin+1,data:new Float32Array(x.byteArray)}:(X.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(n){X.e.Error("Failed to load EXR data: ",n)}return{width:0,height:0,data:null}}}}]);