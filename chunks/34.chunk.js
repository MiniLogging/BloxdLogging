"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13531:(s,Z,o)=>{o.r(Z),o.d(Z,{ReadExrDataAsync:()=>Qs,_ExrTextureLoader:()=>Bs});var t=o(10955),j=o(10935);const S=4,a=4,O=1,v=2,G=8,B=65536,Q=B>>3,D=14,z=65537,Y=1<<D,b=Y-1,f=59,A=63,d=2+A-f;var U,u;!function(s){s[s.NO_COMPRESSION=0]="NO_COMPRESSION",s[s.RLE_COMPRESSION=1]="RLE_COMPRESSION",s[s.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",s[s.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",s[s.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",s[s.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(U||(U={})),function(s){s[s.INCREASING_Y=0]="INCREASING_Y",s[s.DECREASING_Y=1]="DECREASING_Y"}(u||(u={}));const H=function(){const s=new ArrayBuffer(4),Z=new Float32Array(s),o=new Uint32Array(s),t=new Uint32Array(512),j=new Uint32Array(512);for(let v=0;v<256;++v){const s=v-127;s<-27?(t[v]=0,t[256|v]=32768,j[v]=24,j[256|v]=24):s<-14?(t[v]=1024>>-s-14,t[256|v]=1024>>-s-14|32768,j[v]=-s-1,j[256|v]=-s-1):s<=15?(t[v]=s+15<<10,t[256|v]=s+15<<10|32768,j[v]=13,j[256|v]=13):s<128?(t[v]=31744,t[256|v]=64512,j[v]=24,j[256|v]=24):(t[v]=31744,t[256|v]=64512,j[v]=13,j[256|v]=13)}const S=new Uint32Array(2048),a=new Uint32Array(64),O=new Uint32Array(64);for(let v=1;v<1024;++v){let s=v<<13,Z=0;for(;0===(8388608&s);)s<<=1,Z-=8388608;s&=-8388609,Z+=947912704,S[v]=s|Z}for(let v=1024;v<2048;++v)S[v]=939524096+(v-1024<<13);for(let v=1;v<31;++v)a[v]=v<<23;a[31]=1199570944,a[32]=2147483648;for(let v=33;v<63;++v)a[v]=2147483648+(v-32<<23);a[63]=3347054592;for(let v=1;v<64;++v)32!==v&&(O[v]=1024);return{floatView:Z,uint32View:o,baseTable:t,shiftTable:j,mantissaTable:S,exponentTable:a,offsetTable:O}}();function F(s,Z){const o=new Uint8Array(s);let t=0;for(;0!=o[Z.value+t];)t+=1;const j=(new TextDecoder).decode(o.slice(Z.value,Z.value+t));return Z.value=Z.value+t+1,j}function i(s,Z){const o=s.getInt32(Z.value,!0);return Z.value+=S,o}function N(s,Z){const o=s.getUint32(Z.value,!0);return Z.value+=S,o}function L(s,Z){const o=s.getUint8(Z.value);return Z.value+=O,o}function V(s,Z){const o=s.getUint16(Z.value,!0);return Z.value+=v,o}function g(s,Z){const o=s[Z.value];return Z.value+=O,o}function l(s,Z){let o;return o="getBigInt64"in DataView.prototype?Number(s.getBigInt64(Z.value,!0)):s.getUint32(Z.value+4,!0)+Number(s.getUint32(Z.value,!0)<<32),Z.value+=G,o}function R(s,Z){const o=s.getFloat32(Z.value,!0);return Z.value+=a,o}function e(s,Z){return function(s){const Z=(31744&s)>>10,o=1023&s;return(s>>15?-1:1)*(Z?31===Z?o?NaN:1/0:Math.pow(2,Z-15)*(1+o/1024):o/1024*6103515625e-14)}(V(s,Z))}function c(s,Z){return function(s){if(Math.abs(s)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");s=(0,j.Clamp)(s,-65504,65504),H.floatView[0]=s;const Z=H.uint32View[0],o=Z>>23&511;return H.baseTable[o]+((8388607&Z)>>H.shiftTable[o])}(R(s,Z))}function w(s,Z,o,t){switch(o){case"string":case"stringvector":case"iccProfile":return function(s,Z,o){const t=(new TextDecoder).decode(new Uint8Array(s).slice(Z.value,Z.value+o));return Z.value=Z.value+o,t}(s.buffer,Z,t);case"chlist":return function(s,Z,o){const t=Z.value,j=[];for(;Z.value<t+o-1;){const o=F(s.buffer,Z),t=i(s,Z),S=L(s,Z);Z.value+=3;const a=i(s,Z),O=i(s,Z);j.push({name:o,pixelType:t,pLinear:S,xSampling:a,ySampling:O})}return Z.value+=1,j}(s,Z,t);case"chromaticities":return function(s,Z){return{redX:R(s,Z),redY:R(s,Z),greenX:R(s,Z),greenY:R(s,Z),blueX:R(s,Z),blueY:R(s,Z),whiteX:R(s,Z),whiteY:R(s,Z)}}(s,Z);case"compression":return function(s,Z){return L(s,Z)}(s,Z);case"box2i":return function(s,Z){return{xMin:i(s,Z),yMin:i(s,Z),xMax:i(s,Z),yMax:i(s,Z)}}(s,Z);case"lineOrder":return function(s,Z){const o=L(s,Z);return u[o]}(s,Z);case"float":return R(s,Z);case"v2f":return function(s,Z){return[R(s,Z),R(s,Z)]}(s,Z);case"v3f":return function(s,Z){return[R(s,Z),R(s,Z),R(s,Z)]}(s,Z);case"int":return i(s,Z);case"rational":return function(s,Z){return[i(s,Z),N(s,Z)]}(s,Z);case"timecode":return function(s,Z){return[N(s,Z),N(s,Z)]}(s,Z);case"preview":return Z.value+=t,"skipped";default:return void(Z.value+=t)}}function X(s){for(let Z=1;Z<s.length;Z++){const o=s[Z-1]+s[Z]-128;s[Z]=o}}function W(s,Z){let o=0,t=Math.floor((s.length+1)/2),j=0;const S=s.length-1;for(;!(j>S)&&(Z[j++]=s[o++],!(j>S));)Z[j++]=s[t++]}const q=20000630;function h(s,Z){if(s.getUint32(0,!0)!=q)throw new Error("Incorrect OpenEXR format");const o=s.getUint8(4),j=s.getUint8(5),S={singleTile:!!(2&j),longName:!!(4&j),deepFormat:!!(8&j),multiPart:!!(16&j)};Z.value=8;const a={};let O=!0;for(;O;){const o=F(s.buffer,Z);if(o){const j=F(s.buffer,Z),S=w(s,Z,j,N(s,Z));void 0===S?t.b.Warn(`Unknown header attribute type ${j}'.`):a[o]=S}else O=!1}if(0!=(-5&j))throw new Error("Unsupported file format");return{version:o,spec:S,...a}}const M=32768,x=65535;function k(s,Z,o,t,j){for(;o<s;)Z=Z<<8|g(t,j),o+=8;return{l:Z>>(o-=s)&(1<<s)-1,c:Z,lc:o}}function y(s,Z,o,t){return{c:s=s<<8|g(o,t),lc:Z+=8}}function I(s,Z,o,t,j,S,a,O,v){if(s==Z){if(t<8){const s=y(o,t,j,S);o=s.c,t=s.lc}let s=o>>(t-=8);if(s=new Uint8Array([s])[0],O.value+s>v)return null;const Z=a[O.value-1];for(;s-- >0;)a[O.value++]=Z}else{if(!(O.value<v))return null;a[O.value++]=s}return{c:o,lc:t}}const C=new Array(59);function K(s,Z,o,t,j,S){const a=Z;let O=0,v=0;for(;t<=j;t++){if(a.value-Z.value>o)return;let G=k(6,O,v,s,a);const B=G.l;if(O=G.c,v=G.lc,S[t]=B,B==A){if(a.value-Z.value>o)throw new Error("Error in HufUnpackEncTable");G=k(8,O,v,s,a);let B=G.l+d;if(O=G.c,v=G.lc,t+B>j+1)throw new Error("Error in HufUnpackEncTable");for(;B--;)S[t++]=0;t--}else if(B>=f){let s=B-f+2;if(t+s>j+1)throw new Error("Error in HufUnpackEncTable");for(;s--;)S[t++]=0;t--}}!function(s){for(let o=0;o<=58;++o)C[o]=0;for(let o=0;o<z;++o)C[s[o]]+=1;let Z=0;for(let o=58;o>0;--o){const s=Z+C[o]>>1;C[o]=Z,Z=s}for(let o=0;o<z;++o){const Z=s[o];Z>0&&(s[o]=Z|C[Z]++<<6)}}(S)}function p(s){return 63&s}function E(s){return s>>6}function P(s,Z,o,t,j,S){const a=o.value,O=N(Z,o),v=N(Z,o);o.value+=4;const G=N(Z,o);if(o.value+=4,O<0||O>=z||v<0||v>=z)throw new Error("Wrong HUF_ENCSIZE");const B=new Array(z),Q=new Array(Y);!function(s){for(let Z=0;Z<Y;Z++)s[Z]={},s[Z].len=0,s[Z].lit=0,s[Z].p=null}(Q);if(K(s,o,t-(o.value-a),O,v,B),G>8*(t-(o.value-a)))throw new Error("Wrong hufUncompress");!function(s,Z,o,t){for(;Z<=o;Z++){const o=E(s[Z]),j=p(s[Z]);if(o>>j)throw new Error("Invalid table entry");if(j>D){const s=t[o>>j-D];if(s.len)throw new Error("Invalid table entry");if(s.lit++,s.p){const Z=s.p;s.p=new Array(s.lit);for(let o=0;o<s.lit-1;++o)s.p[o]=Z[o]}else s.p=new Array(1);s.p[s.lit-1]=Z}else if(j){let s=0;for(let S=1<<D-j;S>0;S--){const S=t[(o<<D-j)+s];if(S.len||S.p)throw new Error("Invalid table entry");S.len=j,S.lit=Z,s++}}}}(B,O,v,Q),function(s,Z,o,t,j,S,a,O,v){let G=0,B=0;const Q=a,z=Math.trunc(t.value+(j+7)/8);for(;t.value<z;){let j=y(G,B,o,t);for(G=j.c,B=j.lc;B>=D;){const a=Z[G>>B-D&b];if(a.len){B-=a.len;const s=I(a.lit,S,G,B,o,t,O,v,Q);s&&(G=s.c,B=s.lc)}else{if(!a.p)throw new Error("hufDecode issues");let Z;for(Z=0;Z<a.lit;Z++){const D=p(s[a.p[Z]]);for(;B<D&&t.value<z;)j=y(G,B,o,t),G=j.c,B=j.lc;if(B>=D&&E(s[a.p[Z]])==(G>>B-D&(1<<D)-1)){B-=D;const s=I(a.p[Z],S,G,B,o,t,O,v,Q);s&&(G=s.c,B=s.lc);break}}if(Z==a.lit)throw new Error("HufDecode issues")}}}const Y=8-j&7;for(G>>=Y,B-=Y;B>0;){const s=Z[G<<D-B&b];if(!s.len)throw new Error("HufDecode issues");{B-=s.len;const Z=I(s.lit,S,G,B,o,t,O,v,Q);Z&&(G=Z.c,B=Z.lc)}}}(B,Q,s,o,G,v,S,j,{value:0})}function r(s){return 65535&s}function T(s){const Z=r(s);return Z>32767?Z-65536:Z}function m(s,Z){const o=T(s),t=T(Z),j=o+(1&t)+(t>>1);return{a:j,b:j-t}}function n(s,Z){const o=r(s),t=r(Z),j=o-(t>>1)&x;return{a:t+j-M&x,b:j}}function J(s,Z,o,t,j,S,a){const O=a<16384,v=o>j?j:o;let G,B,Q=1;for(;Q<=v;)Q<<=1;for(Q>>=1,G=Q,Q>>=1;Q>=1;){B=0;const a=B+S*(j-G),v=S*Q,D=S*G,z=t*Q,Y=t*G;let b,f,A,d;for(;B<=a;B+=D){let j=B;const S=B+t*(o-G);for(;j<=S;j+=Y){const o=j+z,t=j+v,S=t+z;if(O){let a=m(s[j+Z],s[t+Z]);b=a.a,A=a.b,a=m(s[o+Z],s[S+Z]),f=a.a,d=a.b,a=m(b,f),s[j+Z]=a.a,s[o+Z]=a.b,a=m(A,d),s[t+Z]=a.a,s[S+Z]=a.b}else{let a=n(s[j+Z],s[t+Z]);b=a.a,A=a.b,a=n(s[o+Z],s[S+Z]),f=a.a,d=a.b,a=n(b,f),s[j+Z]=a.a,s[o+Z]=a.b,a=n(A,d),s[t+Z]=a.a,s[S+Z]=a.b}}if(o&Q){const o=j+v;let t;t=O?m(s[j+Z],s[o+Z]):n(s[j+Z],s[o+Z]),b=t.a,s[o+Z]=t.b,s[j+Z]=b}}if(j&Q){let j=B;const S=B+t*(o-G);for(;j<=S;j+=Y){const o=j+z;let t;t=O?m(s[j+Z],s[o+Z]):n(s[j+Z],s[o+Z]),b=t.a,s[o+Z]=t.b,s[j+Z]=b}}G=Q,Q>>=1}return B}function ss(s){return new DataView(s.array.buffer,s.offset.value,s.size)}function Zs(s){const Z=s.viewer.buffer.slice(s.offset.value,s.offset.value+s.size),o=new Uint8Array(function(s){let Z=s.byteLength;const o=[];let t=0;const j=new DataView(s);for(;Z>0;){const s=j.getInt8(t++);if(s<0){const S=-s;Z-=S+1;for(let s=0;s<S;s++)o.push(j.getUint8(t++))}else{const S=s;Z-=2;const a=j.getUint8(t++);for(let s=0;s<S+1;s++)o.push(a)}}return o}(Z)),t=new Uint8Array(o.length);return X(o),W(o,t),new DataView(t.buffer)}function os(s){const Z=s.array.slice(s.offset.value,s.offset.value+s.size),o=fflate.unzlibSync(Z),t=new Uint8Array(o.length);return X(o),W(o,t),new DataView(t.buffer)}function ts(s){const Z=s.array.slice(s.offset.value,s.offset.value+s.size),o=fflate.unzlibSync(Z),t=s.lines*s.channels*s.width,j=1==s.type?new Uint16Array(t):new Uint32Array(t);let S=0,a=0;const O=new Array(4);for(let v=0;v<s.lines;v++)for(let Z=0;Z<s.channels;Z++){let Z=0;switch(s.type){case 1:O[0]=S,O[1]=O[0]+s.width,S=O[1]+s.width;for(let t=0;t<s.width;++t){Z+=o[O[0]++]<<8|o[O[1]++],j[a]=Z,a++}break;case 2:O[0]=S,O[1]=O[0]+s.width,O[2]=O[1]+s.width,S=O[2]+s.width;for(let t=0;t<s.width;++t){Z+=o[O[0]++]<<24|o[O[1]++]<<16|o[O[2]++]<<8,j[a]=Z,a++}}}return new DataView(j.buffer)}function js(s){const Z=s.viewer,o={value:s.offset.value},t=new Uint16Array(s.width*s.scanlineBlockSize*(s.channels*s.type)),j=new Uint8Array(Q);let S=0;const a=new Array(s.channels);for(let v=0;v<s.channels;v++)a[v]={},a[v].start=S,a[v].end=a[v].start,a[v].nx=s.width,a[v].ny=s.lines,a[v].size=s.type,S+=a[v].nx*a[v].ny*a[v].size;const O=V(Z,o),G=V(Z,o);if(G>=Q)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(O<=G)for(let v=0;v<G-O+1;v++)j[v+O]=L(Z,o);const D=new Uint16Array(B),z=function(s,Z){let o=0;for(let j=0;j<B;++j)(0==j||s[j>>3]&1<<(7&j))&&(Z[o++]=j);const t=o-1;for(;o<B;)Z[o++]=0;return t}(j,D),Y=N(Z,o);P(s.array,Z,o,Y,t,S);for(let v=0;v<s.channels;++v){const s=a[v];for(let Z=0;Z<a[v].size;++Z)J(t,s.start+Z,s.nx,s.size,s.ny,s.nx*s.size,z)}!function(s,Z,o){for(let t=0;t<o;++t)Z[t]=s[Z[t]]}(D,t,S);let b=0;const f=new Uint8Array(t.buffer.byteLength);for(let B=0;B<s.lines;B++)for(let Z=0;Z<s.channels;Z++){const s=a[Z],o=s.nx*s.size,j=new Uint8Array(t.buffer,s.end*v,o*v);f.set(j,b),b+=o*v,s.end+=o}return new DataView(f.buffer)}var Ss,as=o(10938);!function(s){s[s.Float=0]="Float",s[s.HalfFloat=1]="HalfFloat"}(Ss||(Ss={}));class Os{}async function vs(s,Z,o,t){const j={size:0,viewer:Z,array:new Uint8Array(Z.buffer),offset:o,width:s.dataWindow.xMax-s.dataWindow.xMin+1,height:s.dataWindow.yMax-s.dataWindow.yMin+1,channels:s.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(s.compression){case U.NO_COMPRESSION:j.lines=1,j.uncompress=ss;break;case U.RLE_COMPRESSION:j.lines=1,j.uncompress=Zs;break;case U.ZIPS_COMPRESSION:j.lines=1,j.uncompress=os,await as.g.LoadScriptAsync(Os.FFLATEUrl);break;case U.ZIP_COMPRESSION:j.lines=16,j.uncompress=os,await as.g.LoadScriptAsync(Os.FFLATEUrl);break;case U.PIZ_COMPRESSION:j.lines=32,j.uncompress=js;break;case U.PXR24_COMPRESSION:j.lines=16,j.uncompress=ts,await as.g.LoadScriptAsync(Os.FFLATEUrl);break;default:throw new Error(U[s.compression]+" is unsupported")}j.scanlineBlockSize=j.lines;const S={};for(const a of s.channels)switch(a.name){case"R":case"G":case"B":case"A":case"Y":S[a.name]=!0,j.type=a.pixelType}let O=!1;if(S.R&&S.G&&S.B&&S.A)j.outputChannels=4,j.decodeChannels={R:0,G:1,B:2,A:3};else if(S.R&&S.G&&S.B)O=!0,j.outputChannels=4,j.decodeChannels={R:0,G:1,B:2,A:3};else if(S.R&&S.G)j.outputChannels=2,j.decodeChannels={R:0,G:1};else if(S.R)j.outputChannels=1,j.decodeChannels={R:0};else{if(!S.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");j.outputChannels=1,j.decodeChannels={Y:0}}if(1===j.type)switch(t){case Ss.Float:j.getter=e,j.inputSize=v;break;case Ss.HalfFloat:j.getter=V,j.inputSize=v}else{if(2!==j.type)throw new Error("Unsupported pixelType "+j.type+" for "+s.compression);switch(t){case Ss.Float:j.getter=R,j.inputSize=a;break;case Ss.HalfFloat:j.getter=c,j.inputSize=a}}j.blockCount=j.height/j.scanlineBlockSize;for(let a=0;a<j.blockCount;a++)l(Z,o);const G=j.width*j.height*j.outputChannels;switch(t){case Ss.Float:j.byteArray=new Float32Array(G),j.textureType=1,O&&j.byteArray.fill(1,0,G);break;case Ss.HalfFloat:j.byteArray=new Uint16Array(G),j.textureType=2,O&&j.byteArray.fill(15360,0,G);break;default:throw new Error("Unsupported type: "+t)}let B=0;for(const a of s.channels)void 0!==j.decodeChannels[a.name]&&(j.channelLineOffsets[a.name]=B*j.width),B+=2*a.pixelType;return j.bytesPerLine=j.width*B,j.outLineWidth=j.width*j.outputChannels,"INCREASING_Y"===s.lineOrder?j.scanOrder=s=>s:j.scanOrder=s=>j.height-1-s,4==j.outputChannels?(j.format=5,j.linearSpace=!0):(j.format=6,j.linearSpace=!1),j}function Gs(s,Z,o,t){const j={value:0};for(let S=0;S<s.height/s.scanlineBlockSize;S++){const a=i(o,t)-Z.dataWindow.yMin;s.size=N(o,t),s.lines=a+s.scanlineBlockSize>s.height?s.height-a:s.scanlineBlockSize;const O=s.size<s.lines*s.bytesPerLine&&s.uncompress?s.uncompress(s):ss(s);t.value+=s.size;for(let o=0;o<s.scanlineBlockSize;o++){const t=S*s.scanlineBlockSize,a=o+s.scanOrder(t);if(a>=s.height)continue;const v=o*s.bytesPerLine,G=(s.height-1-a)*s.outLineWidth;for(let o=0;o<s.channels;o++){const t=Z.channels[o].name,S=s.channelLineOffsets[t],a=s.decodeChannels[t];if(void 0!==a){j.value=v+S;for(let Z=0;Z<s.width;Z++){const o=G+Z*s.outputChannels+a;s.byteArray&&(s.byteArray[o]=s.getter(O,j))}}}}}}Os.DefaultOutputType=Ss.HalfFloat,Os.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class Bs{constructor(){this.supportCascades=!1}loadCubeData(s,Z,o,t,j){throw".exr not supported in Cube."}loadData(s,Z,o){const j=new DataView(s.buffer),S={value:0},a=h(j,S);vs(a,j,S,Os.DefaultOutputType).then((s=>{Gs(s,a,j,S);const t=a.dataWindow.xMax-a.dataWindow.xMin+1,O=a.dataWindow.yMax-a.dataWindow.yMin+1;o(t,O,Z.generateMipMaps,!1,(()=>{const o=Z.getEngine();Z.format=a.format,Z.type=s.textureType,Z.invertY=!1,Z._gammaSpace=!a.linearSpace,s.byteArray&&o._uploadDataToTextureDirectly(Z,s.byteArray,0,0,void 0,!0)}))})).catch((s=>{t.b.Error("Failed to load EXR texture: ",s)}))}}async function Qs(s){const Z=new DataView(s),o={value:0},j=h(Z,o);try{const s=await vs(j,Z,o,Ss.Float);return Gs(s,j,Z,o),s.byteArray?{width:j.dataWindow.xMax-j.dataWindow.xMin+1,height:j.dataWindow.yMax-j.dataWindow.yMin+1,data:new Float32Array(s.byteArray)}:(t.b.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(S){t.b.Error("Failed to load EXR data: ",S)}return{width:0,height:0,data:null}}}}]);