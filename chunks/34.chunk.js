"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[34],{13456:(q,f,j)=>{j.r(f),j.d(f,{ReadExrDataAsync:()=>Xq,_ExrTextureLoader:()=>uq});var d=j(11005),g=j(10985);const h=4,L=4,Q=1,H=2,r=8,u=65536,X=u>>3,z=14,B=65537,D=1<<z,i=D-1,t=59,O=63,N=2+O-t;var w,E;!function(q){q[q.NO_COMPRESSION=0]="NO_COMPRESSION",q[q.RLE_COMPRESSION=1]="RLE_COMPRESSION",q[q.ZIPS_COMPRESSION=2]="ZIPS_COMPRESSION",q[q.ZIP_COMPRESSION=3]="ZIP_COMPRESSION",q[q.PIZ_COMPRESSION=4]="PIZ_COMPRESSION",q[q.PXR24_COMPRESSION=5]="PXR24_COMPRESSION"}(w||(w={})),function(q){q[q.INCREASING_Y=0]="INCREASING_Y",q[q.DECREASING_Y=1]="DECREASING_Y"}(E||(E={}));const s=function(){const q=new ArrayBuffer(4),f=new Float32Array(q),j=new Uint32Array(q),d=new Uint32Array(512),g=new Uint32Array(512);for(let H=0;H<256;++H){const q=H-127;q<-27?(d[H]=0,d[256|H]=32768,g[H]=24,g[256|H]=24):q<-14?(d[H]=1024>>-q-14,d[256|H]=1024>>-q-14|32768,g[H]=-q-1,g[256|H]=-q-1):q<=15?(d[H]=q+15<<10,d[256|H]=q+15<<10|32768,g[H]=13,g[256|H]=13):q<128?(d[H]=31744,d[256|H]=64512,g[H]=24,g[256|H]=24):(d[H]=31744,d[256|H]=64512,g[H]=13,g[256|H]=13)}const h=new Uint32Array(2048),L=new Uint32Array(64),Q=new Uint32Array(64);for(let H=1;H<1024;++H){let q=H<<13,f=0;for(;0===(8388608&q);)q<<=1,f-=8388608;q&=-8388609,f+=947912704,h[H]=q|f}for(let H=1024;H<2048;++H)h[H]=939524096+(H-1024<<13);for(let H=1;H<31;++H)L[H]=H<<23;L[31]=1199570944,L[32]=2147483648;for(let H=33;H<63;++H)L[H]=2147483648+(H-32<<23);L[63]=3347054592;for(let H=1;H<64;++H)32!==H&&(Q[H]=1024);return{floatView:f,uint32View:j,baseTable:d,shiftTable:g,mantissaTable:h,exponentTable:L,offsetTable:Q}}();function S(q,f){const j=new Uint8Array(q);let d=0;for(;0!=j[f.value+d];)d+=1;const g=(new TextDecoder).decode(j.slice(f.value,f.value+d));return f.value=f.value+d+1,g}function e(q,f){const j=q.getInt32(f.value,!0);return f.value+=h,j}function Z(q,f){const j=q.getUint32(f.value,!0);return f.value+=h,j}function I(q,f){const j=q.getUint8(f.value);return f.value+=Q,j}function T(q,f){const j=q.getUint16(f.value,!0);return f.value+=H,j}function W(q,f){const j=q[f.value];return f.value+=Q,j}function n(q,f){let j;return j="getBigInt64"in DataView.prototype?Number(q.getBigInt64(f.value,!0)):q.getUint32(f.value+4,!0)+Number(q.getUint32(f.value,!0)<<32),f.value+=r,j}function U(q,f){const j=q.getFloat32(f.value,!0);return f.value+=L,j}function Y(q,f){return function(q){const f=(31744&q)>>10,j=1023&q;return(q>>15?-1:1)*(f?31===f?j?NaN:1/0:Math.pow(2,f-15)*(1+j/1024):j/1024*6103515625e-14)}(T(q,f))}function v(q,f){return function(q){if(Math.abs(q)>65504)throw new Error("Value out of range.Consider using float instead of half-float.");q=(0,g.Clamp)(q,-65504,65504),s.floatView[0]=q;const f=s.uint32View[0],j=f>>23&511;return s.baseTable[j]+((8388607&f)>>s.shiftTable[j])}(U(q,f))}function F(q,f,j,d){switch(j){case"string":case"stringvector":case"iccProfile":return function(q,f,j){const d=(new TextDecoder).decode(new Uint8Array(q).slice(f.value,f.value+j));return f.value=f.value+j,d}(q.buffer,f,d);case"chlist":return function(q,f,j){const d=f.value,g=[];for(;f.value<d+j-1;){const j=S(q.buffer,f),d=e(q,f),h=I(q,f);f.value+=3;const L=e(q,f),Q=e(q,f);g.push({name:j,pixelType:d,pLinear:h,xSampling:L,ySampling:Q})}return f.value+=1,g}(q,f,d);case"chromaticities":return function(q,f){return{redX:U(q,f),redY:U(q,f),greenX:U(q,f),greenY:U(q,f),blueX:U(q,f),blueY:U(q,f),whiteX:U(q,f),whiteY:U(q,f)}}(q,f);case"compression":return function(q,f){return I(q,f)}(q,f);case"box2i":return function(q,f){return{xMin:e(q,f),yMin:e(q,f),xMax:e(q,f),yMax:e(q,f)}}(q,f);case"lineOrder":return function(q,f){const j=I(q,f);return E[j]}(q,f);case"float":return U(q,f);case"v2f":return function(q,f){return[U(q,f),U(q,f)]}(q,f);case"v3f":return function(q,f){return[U(q,f),U(q,f),U(q,f)]}(q,f);case"int":return e(q,f);case"rational":return function(q,f){return[e(q,f),Z(q,f)]}(q,f);case"timecode":return function(q,f){return[Z(q,f),Z(q,f)]}(q,f);case"preview":return f.value+=d,"skipped";default:return void(f.value+=d)}}function M(q){for(let f=1;f<q.length;f++){const j=q[f-1]+q[f]-128;q[f]=j}}function o(q,f){let j=0,d=Math.floor((q.length+1)/2),g=0;const h=q.length-1;for(;!(g>h)&&(f[g++]=q[j++],!(g>h));)f[g++]=q[d++]}const b=20000630;function x(q,f){if(q.getUint32(0,!0)!=b)throw new Error("Incorrect OpenEXR format");const j=q.getUint8(4),g=q.getUint8(5),h={singleTile:!!(2&g),longName:!!(4&g),deepFormat:!!(8&g),multiPart:!!(16&g)};f.value=8;const L={};let Q=!0;for(;Q;){const j=S(q.buffer,f);if(j){const g=S(q.buffer,f),h=F(q,f,g,Z(q,f));void 0===h?d.e.Warn(`Unknown header attribute type ${g}'.`):L[j]=h}else Q=!1}if(0!=(-5&g))throw new Error("Unsupported file format");return{version:j,spec:h,...L}}const R=32768,A=65535;function k(q,f,j,d,g){for(;j<q;)f=f<<8|W(d,g),j+=8;return{l:f>>(j-=q)&(1<<q)-1,c:f,lc:j}}function y(q,f,j,d){return{c:q=q<<8|W(j,d),lc:f+=8}}function p(q,f,j,d,g,h,L,Q,H){if(q==f){if(d<8){const q=y(j,d,g,h);j=q.c,d=q.lc}let q=j>>(d-=8);if(q=new Uint8Array([q])[0],Q.value+q>H)return null;const f=L[Q.value-1];for(;q-- >0;)L[Q.value++]=f}else{if(!(Q.value<H))return null;L[Q.value++]=q}return{c:j,lc:d}}const l=new Array(59);function V(q,f,j,d,g,h){const L=f;let Q=0,H=0;for(;d<=g;d++){if(L.value-f.value>j)return;let r=k(6,Q,H,q,L);const u=r.l;if(Q=r.c,H=r.lc,h[d]=u,u==O){if(L.value-f.value>j)throw new Error("Error in HufUnpackEncTable");r=k(8,Q,H,q,L);let u=r.l+N;if(Q=r.c,H=r.lc,d+u>g+1)throw new Error("Error in HufUnpackEncTable");for(;u--;)h[d++]=0;d--}else if(u>=t){let q=u-t+2;if(d+q>g+1)throw new Error("Error in HufUnpackEncTable");for(;q--;)h[d++]=0;d--}}!function(q){for(let j=0;j<=58;++j)l[j]=0;for(let j=0;j<B;++j)l[q[j]]+=1;let f=0;for(let j=58;j>0;--j){const q=f+l[j]>>1;l[j]=f,f=q}for(let j=0;j<B;++j){const f=q[j];f>0&&(q[j]=f|l[f]++<<6)}}(h)}function a(q){return 63&q}function P(q){return q>>6}function C(q,f,j,d,g,h){const L=j.value,Q=Z(f,j),H=Z(f,j);j.value+=4;const r=Z(f,j);if(j.value+=4,Q<0||Q>=B||H<0||H>=B)throw new Error("Wrong HUF_ENCSIZE");const u=new Array(B),X=new Array(D);!function(q){for(let f=0;f<D;f++)q[f]={},q[f].len=0,q[f].lit=0,q[f].p=null}(X);if(V(q,j,d-(j.value-L),Q,H,u),r>8*(d-(j.value-L)))throw new Error("Wrong hufUncompress");!function(q,f,j,d){for(;f<=j;f++){const j=P(q[f]),g=a(q[f]);if(j>>g)throw new Error("Invalid table entry");if(g>z){const q=d[j>>g-z];if(q.len)throw new Error("Invalid table entry");if(q.lit++,q.p){const f=q.p;q.p=new Array(q.lit);for(let j=0;j<q.lit-1;++j)q.p[j]=f[j]}else q.p=new Array(1);q.p[q.lit-1]=f}else if(g){let q=0;for(let h=1<<z-g;h>0;h--){const h=d[(j<<z-g)+q];if(h.len||h.p)throw new Error("Invalid table entry");h.len=g,h.lit=f,q++}}}}(u,Q,H,X),function(q,f,j,d,g,h,L,Q,H){let r=0,u=0;const X=L,B=Math.trunc(d.value+(g+7)/8);for(;d.value<B;){let g=y(r,u,j,d);for(r=g.c,u=g.lc;u>=z;){const L=f[r>>u-z&i];if(L.len){u-=L.len;const q=p(L.lit,h,r,u,j,d,Q,H,X);q&&(r=q.c,u=q.lc)}else{if(!L.p)throw new Error("hufDecode issues");let f;for(f=0;f<L.lit;f++){const z=a(q[L.p[f]]);for(;u<z&&d.value<B;)g=y(r,u,j,d),r=g.c,u=g.lc;if(u>=z&&P(q[L.p[f]])==(r>>u-z&(1<<z)-1)){u-=z;const q=p(L.p[f],h,r,u,j,d,Q,H,X);q&&(r=q.c,u=q.lc);break}}if(f==L.lit)throw new Error("HufDecode issues")}}}const D=8-g&7;for(r>>=D,u-=D;u>0;){const q=f[r<<z-u&i];if(!q.len)throw new Error("HufDecode issues");{u-=q.len;const f=p(q.lit,h,r,u,j,d,Q,H,X);f&&(r=f.c,u=f.lc)}}}(u,X,q,j,r,H,h,g,{value:0})}function c(q){return 65535&q}function G(q){const f=c(q);return f>32767?f-65536:f}function m(q,f){const j=G(q),d=G(f),g=j+(1&d)+(d>>1);return{a:g,b:g-d}}function K(q,f){const j=c(q),d=c(f),g=j-(d>>1)&A;return{a:d+g-R&A,b:g}}function J(q,f,j,d,g,h,L){const Q=L<16384,H=j>g?g:j;let r,u,X=1;for(;X<=H;)X<<=1;for(X>>=1,r=X,X>>=1;X>=1;){u=0;const L=u+h*(g-r),H=h*X,z=h*r,B=d*X,D=d*r;let i,t,O,N;for(;u<=L;u+=z){let g=u;const h=u+d*(j-r);for(;g<=h;g+=D){const j=g+B,d=g+H,h=d+B;if(Q){let L=m(q[g+f],q[d+f]);i=L.a,O=L.b,L=m(q[j+f],q[h+f]),t=L.a,N=L.b,L=m(i,t),q[g+f]=L.a,q[j+f]=L.b,L=m(O,N),q[d+f]=L.a,q[h+f]=L.b}else{let L=K(q[g+f],q[d+f]);i=L.a,O=L.b,L=K(q[j+f],q[h+f]),t=L.a,N=L.b,L=K(i,t),q[g+f]=L.a,q[j+f]=L.b,L=K(O,N),q[d+f]=L.a,q[h+f]=L.b}}if(j&X){const j=g+H;let d;d=Q?m(q[g+f],q[j+f]):K(q[g+f],q[j+f]),i=d.a,q[j+f]=d.b,q[g+f]=i}}if(g&X){let g=u;const h=u+d*(j-r);for(;g<=h;g+=D){const j=g+B;let d;d=Q?m(q[g+f],q[j+f]):K(q[g+f],q[j+f]),i=d.a,q[j+f]=d.b,q[g+f]=i}}r=X,X>>=1}return u}function qq(q){return new DataView(q.array.buffer,q.offset.value,q.size)}function fq(q){const f=q.viewer.buffer.slice(q.offset.value,q.offset.value+q.size),j=new Uint8Array(function(q){let f=q.byteLength;const j=[];let d=0;const g=new DataView(q);for(;f>0;){const q=g.getInt8(d++);if(q<0){const h=-q;f-=h+1;for(let q=0;q<h;q++)j.push(g.getUint8(d++))}else{const h=q;f-=2;const L=g.getUint8(d++);for(let q=0;q<h+1;q++)j.push(L)}}return j}(f)),d=new Uint8Array(j.length);return M(j),o(j,d),new DataView(d.buffer)}function jq(q){const f=q.array.slice(q.offset.value,q.offset.value+q.size),j=fflate.unzlibSync(f),d=new Uint8Array(j.length);return M(j),o(j,d),new DataView(d.buffer)}function dq(q){const f=q.array.slice(q.offset.value,q.offset.value+q.size),j=fflate.unzlibSync(f),d=q.lines*q.channels*q.width,g=1==q.type?new Uint16Array(d):new Uint32Array(d);let h=0,L=0;const Q=new Array(4);for(let H=0;H<q.lines;H++)for(let f=0;f<q.channels;f++){let f=0;switch(q.type){case 1:Q[0]=h,Q[1]=Q[0]+q.width,h=Q[1]+q.width;for(let d=0;d<q.width;++d){f+=j[Q[0]++]<<8|j[Q[1]++],g[L]=f,L++}break;case 2:Q[0]=h,Q[1]=Q[0]+q.width,Q[2]=Q[1]+q.width,h=Q[2]+q.width;for(let d=0;d<q.width;++d){f+=j[Q[0]++]<<24|j[Q[1]++]<<16|j[Q[2]++]<<8,g[L]=f,L++}}}return new DataView(g.buffer)}function gq(q){const f=q.viewer,j={value:q.offset.value},d=new Uint16Array(q.width*q.scanlineBlockSize*(q.channels*q.type)),g=new Uint8Array(X);let h=0;const L=new Array(q.channels);for(let H=0;H<q.channels;H++)L[H]={},L[H].start=h,L[H].end=L[H].start,L[H].nx=q.width,L[H].ny=q.lines,L[H].size=q.type,h+=L[H].nx*L[H].ny*L[H].size;const Q=T(f,j),r=T(f,j);if(r>=X)throw new Error("Wrong PIZ_COMPRESSION BITMAP_SIZE");if(Q<=r)for(let H=0;H<r-Q+1;H++)g[H+Q]=I(f,j);const z=new Uint16Array(u),B=function(q,f){let j=0;for(let g=0;g<u;++g)(0==g||q[g>>3]&1<<(7&g))&&(f[j++]=g);const d=j-1;for(;j<u;)f[j++]=0;return d}(g,z),D=Z(f,j);C(q.array,f,j,D,d,h);for(let H=0;H<q.channels;++H){const q=L[H];for(let f=0;f<L[H].size;++f)J(d,q.start+f,q.nx,q.size,q.ny,q.nx*q.size,B)}!function(q,f,j){for(let d=0;d<j;++d)f[d]=q[f[d]]}(z,d,h);let i=0;const t=new Uint8Array(d.buffer.byteLength);for(let u=0;u<q.lines;u++)for(let f=0;f<q.channels;f++){const q=L[f],j=q.nx*q.size,g=new Uint8Array(d.buffer,q.end*H,j*H);t.set(g,i),i+=j*H,q.end+=j}return new DataView(t.buffer)}var hq,Lq=j(10992);!function(q){q[q.Float=0]="Float",q[q.HalfFloat=1]="HalfFloat"}(hq||(hq={}));class Qq{}async function Hq(q,f,j,d){const g={size:0,viewer:f,array:new Uint8Array(f.buffer),offset:j,width:q.dataWindow.xMax-q.dataWindow.xMin+1,height:q.dataWindow.yMax-q.dataWindow.yMin+1,channels:q.channels.length,channelLineOffsets:{},scanOrder:()=>0,bytesPerLine:0,outLineWidth:0,lines:0,scanlineBlockSize:0,inputSize:null,type:0,uncompress:null,getter:()=>0,format:5,outputChannels:0,decodeChannels:{},blockCount:null,byteArray:null,linearSpace:!1,textureType:0};switch(q.compression){case w.NO_COMPRESSION:g.lines=1,g.uncompress=qq;break;case w.RLE_COMPRESSION:g.lines=1,g.uncompress=fq;break;case w.ZIPS_COMPRESSION:g.lines=1,g.uncompress=jq,await Lq.h.LoadScriptAsync(Qq.FFLATEUrl);break;case w.ZIP_COMPRESSION:g.lines=16,g.uncompress=jq,await Lq.h.LoadScriptAsync(Qq.FFLATEUrl);break;case w.PIZ_COMPRESSION:g.lines=32,g.uncompress=gq;break;case w.PXR24_COMPRESSION:g.lines=16,g.uncompress=dq,await Lq.h.LoadScriptAsync(Qq.FFLATEUrl);break;default:throw new Error(w[q.compression]+" is unsupported")}g.scanlineBlockSize=g.lines;const h={};for(const L of q.channels)switch(L.name){case"R":case"G":case"B":case"A":case"Y":h[L.name]=!0,g.type=L.pixelType}let Q=!1;if(h.R&&h.G&&h.B&&h.A)g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(h.R&&h.G&&h.B)Q=!0,g.outputChannels=4,g.decodeChannels={R:0,G:1,B:2,A:3};else if(h.R&&h.G)g.outputChannels=2,g.decodeChannels={R:0,G:1};else if(h.R)g.outputChannels=1,g.decodeChannels={R:0};else{if(!h.Y)throw new Error("EXRLoader.parse: file contains unsupported data channels.");g.outputChannels=1,g.decodeChannels={Y:0}}if(1===g.type)switch(d){case hq.Float:g.getter=Y,g.inputSize=H;break;case hq.HalfFloat:g.getter=T,g.inputSize=H}else{if(2!==g.type)throw new Error("Unsupported pixelType "+g.type+" for "+q.compression);switch(d){case hq.Float:g.getter=U,g.inputSize=L;break;case hq.HalfFloat:g.getter=v,g.inputSize=L}}g.blockCount=g.height/g.scanlineBlockSize;for(let L=0;L<g.blockCount;L++)n(f,j);const r=g.width*g.height*g.outputChannels;switch(d){case hq.Float:g.byteArray=new Float32Array(r),g.textureType=1,Q&&g.byteArray.fill(1,0,r);break;case hq.HalfFloat:g.byteArray=new Uint16Array(r),g.textureType=2,Q&&g.byteArray.fill(15360,0,r);break;default:throw new Error("Unsupported type: "+d)}let u=0;for(const L of q.channels)void 0!==g.decodeChannels[L.name]&&(g.channelLineOffsets[L.name]=u*g.width),u+=2*L.pixelType;return g.bytesPerLine=g.width*u,g.outLineWidth=g.width*g.outputChannels,"INCREASING_Y"===q.lineOrder?g.scanOrder=q=>q:g.scanOrder=q=>g.height-1-q,4==g.outputChannels?(g.format=5,g.linearSpace=!0):(g.format=6,g.linearSpace=!1),g}function rq(q,f,j,d){const g={value:0};for(let h=0;h<q.height/q.scanlineBlockSize;h++){const L=e(j,d)-f.dataWindow.yMin;q.size=Z(j,d),q.lines=L+q.scanlineBlockSize>q.height?q.height-L:q.scanlineBlockSize;const Q=q.size<q.lines*q.bytesPerLine&&q.uncompress?q.uncompress(q):qq(q);d.value+=q.size;for(let j=0;j<q.scanlineBlockSize;j++){const d=h*q.scanlineBlockSize,L=j+q.scanOrder(d);if(L>=q.height)continue;const H=j*q.bytesPerLine,r=(q.height-1-L)*q.outLineWidth;for(let j=0;j<q.channels;j++){const d=f.channels[j].name,h=q.channelLineOffsets[d],L=q.decodeChannels[d];if(void 0!==L){g.value=H+h;for(let f=0;f<q.width;f++){const j=r+f*q.outputChannels+L;q.byteArray&&(q.byteArray[j]=q.getter(Q,g))}}}}}}Qq.DefaultOutputType=hq.HalfFloat,Qq.FFLATEUrl="https://unpkg.com/fflate@0.8.2";class uq{constructor(){this.supportCascades=!1}loadCubeData(q,f,j,d,g){throw".exr not supported in Cube."}loadData(q,f,j){const g=new DataView(q.buffer),h={value:0},L=x(g,h);Hq(L,g,h,Qq.DefaultOutputType).then((q=>{rq(q,L,g,h);const d=L.dataWindow.xMax-L.dataWindow.xMin+1,Q=L.dataWindow.yMax-L.dataWindow.yMin+1;j(d,Q,f.generateMipMaps,!1,(()=>{const j=f.getEngine();f.format=L.format,f.type=q.textureType,f.invertY=!1,f._gammaSpace=!L.linearSpace,q.byteArray&&j._uploadDataToTextureDirectly(f,q.byteArray,0,0,void 0,!0)}))})).catch((q=>{d.e.Error("Failed to load EXR texture: ",q)}))}}async function Xq(q){const f=new DataView(q),j={value:0},g=x(f,j);try{const q=await Hq(g,f,j,hq.Float);return rq(q,g,f,j),q.byteArray?{width:g.dataWindow.xMax-g.dataWindow.xMin+1,height:g.dataWindow.yMax-g.dataWindow.yMin+1,data:new Float32Array(q.byteArray)}:(d.e.Error("Failed to decode EXR data: No byte array available."),{width:0,height:0,data:null})}catch(h){d.e.Error("Failed to load EXR data: ",h)}return{width:0,height:0,data:null}}}}]);