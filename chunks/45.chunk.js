"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[45],{14377:(Y,b,C)=>{C.d(b,{c:()=>n,g:()=>Q,i:()=>u,k:()=>c});var R=C(12645),q=C(12831),A=C(12852),E=C(13015),B=C(12767),g=C(12860),r=(C(13077),C(12924)),O=C(12669);C(13325),C(13053),C(13337);const F="image/png",y=2,S=[134,22,135,150,246,214,150,54];function n(Y){const b=new DataView(Y.buffer,Y.byteOffset,Y.byteLength);let C=0;for(let E=0;E<S.length;E++)if(b.getUint8(C++)!==S[E])return O.e.Error("Not a babylon environment map"),null;let R="",q=0;for(;q=b.getUint8(C++);)R+=String.fromCharCode(q);let A=JSON.parse(R);return A=t(A),A.binaryDataPosition=C,A.RF&&(A.RF.lodGenerationScale=A.RF.lodGenerationScale||.8),A}function t(Y){if(Y.version>y)throw new Error(`Unsupported babylon environment map version "${Y.version}". Latest supported version is "${y}".`);return 2===Y.version?Y:Y={...Y,version:2,imageType:F}}function I(Y,b){const C=(b=t(b)).RF;let R=Math.log2(b.width);if(R=Math.round(R)+1,C.mipmaps.length!==6*R)throw new Error(`Unsupported specular mipmaps number "${C.mipmaps.length}"`);const q=new Array(R);for(let A=0;A<R;A++){q[A]=new Array(6);for(let R=0;R<6;R++){const E=C.mipmaps[6*A+R];q[A][R]=new Uint8Array(Y.buffer,Y.byteOffset+b.binaryDataPosition+E.position,E.length)}}return q}function w(Y,b){var C;b=t(b);const R=new Array(6),q=null===(C=b.irradiance)||void 0===C?void 0:C.irradianceTexture;if(q){if(6!==q.faces.length)throw new Error(`Incorrect irradiance texture faces number "${q.faces.length}"`);for(let C=0;C<6;C++){const A=q.faces[C];R[C]=new Uint8Array(Y.buffer,Y.byteOffset+b.binaryDataPosition+A.position,A.length)}}return R}function Q(Y,b,C){var R;const A=(C=t(C)).RF;if(!A)return Promise.resolve([]);Y._lodGenerationScale=A.lodGenerationScale;const E=[],B=I(b,C);E.push(p(Y,B,C.imageType));const g=null===(R=C.irradiance)||void 0===R?void 0:R.irradianceTexture;if(g){var r,O;const R=w(b,C);let A=null;null!==(r=C.irradiance)&&void 0!==r&&null!==(O=r.irradianceTexture)&&void 0!==O&&O.dominantDirection&&(A=q.AC.OC(C.irradiance.irradianceTexture.dominantDirection)),E.push(mY(Y,R,g.size,C.imageType,A))}return Promise.all(E)}async function N(Y,b,C,R,q,A,E,B,g,r,O){return await new Promise(((F,y)=>{if(C){const C=b.createTexture(null,!0,!0,null,1,null,(Y=>{y(Y)}),Y);null===R||void 0===R||R.onEffectCreatedObservable.addOnce((B=>{B.executeWhenCompiled((()=>{R.externalTextureSamplerBinding=!0,R.onApply=R=>{R._bindTexture("textureSampler",C),R.setFloat2("scale",1,b._features.needsInvertingBitmap&&Y instanceof ImageBitmap?-1:1)},b.scenes.length&&(b.scenes[0].postProcessManager.directRender([R],r,!0,A,E),b.restoreDefaultFramebuffer(),C.dispose(),URL.revokeObjectURL(q),F())}))}))}else{if(b._uploadImageToTexture(O,Y,A,E),B){const C=g[E];C&&b._uploadImageToTexture(C._texture,Y,A,0)}F()}}))}async function p(Y,b){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:F;const R=Y.getEngine();Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,R.updateTextureSamplingMode(3,Y),await L(Y,b,!0,C),Y.isReady=!0}async function mY(Y,b,C){let R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const A=Y.getEngine(),E=new B.b(A,5),r=new g.c(A,E);Y._irradianceTexture=r,r._dominantDirection=q,E.isCube=!0,E.format=5,E.type=0,E.generateMipMaps=!0,E._cachedAnisotropicFilteringLevel=null,E.generateMipMaps=!0,E.width=C,E.height=C,A.updateTextureSamplingMode(3,E),await L(E,[b],!1,R),A.generateMipMapsForCubemap(E),E.isReady=!0}async function L(Y,b,q){let E=arguments.length>3&&void 0!==arguments[3]?arguments[3]:F;if(!R.Tools.IsExponentOfTwo(Y.width))throw new Error("Texture size must be a power of two");const O=(0,A.ILog2)(Y.width)+1,y=Y.getEngine();let S=!1,n=!1,t=null,I=null,w=null;const Q=y.getCaps();Q.textureLOD?y._features.supportRenderAndCopyToLodForFloatTextures?Q.textureHalfFloatRender&&Q.textureHalfFloatLinearFiltering?(S=!0,Y.type=2):Q.textureFloatRender&&Q.textureFloatLinearFiltering&&(S=!0,Y.type=1):S=!1:(S=!1,n=q);let p=0;if(S)y.isWebGPU?(p=1,await C.e(42).then(C.bind(C,15924))):await C.e(35).then(C.bind(C,15927)),t=new r.b("rgbdDecode","rgbdDecode",null,null,1,null,3,y,!1,void 0,Y.type,void 0,null,!1,void 0,p),Y._isRGBD=!1,Y.invertY=!1,I=y.createRenderTargetCubeTexture(Y.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:Y.type,format:5});else if(Y._isRGBD=!0,Y.invertY=!0,n){const b=3;w={};const C=Y._lodGenerationScale,R=Y._lodGenerationOffset;for(let q=0;q<b;q++){const A=(O-1)*C+R,E=R+(A-R)*(1-q/(b-1)),r=Math.round(Math.min(Math.max(E,0),A)),F=new B.b(y,2);F.isCube=!0,F.invertY=!0,F.generateMipMaps=!1,y.updateTextureSamplingMode(2,F);const S=new g.c(null);switch(S._isCube=!0,S._texture=F,w[r]=S,q){case 0:Y._lodTextureLow=S;break;case 1:Y._lodTextureMid=S;break;case 2:Y._lodTextureHigh=S}}}const mY=[];for(let C=0;C<b.length;C++)for(let R=0;R<6;R++){const q=b[C][R],A=new Blob([q],{type:E}),B=URL.createObjectURL(A);let g;if(y._features.forceBitmapOverHTMLImageElement)g=y.createImageBitmap(A,{premultiplyAlpha:"none"}).then((async b=>await N(b,y,S,t,B,R,C,n,w,I,Y)));else{const b=new Image;b.src=B,g=new Promise(((q,A)=>{b.onload=()=>{N(b,y,S,t,B,R,C,n,w,I,Y).then((()=>q())).catch((Y=>{A(Y)}))},b.onerror=Y=>{A(Y)}}))}mY.push(g)}if(await Promise.all(mY),b.length<O){let C;const R=Math.pow(2,O-1-b.length),q=R*R*4;switch(Y.type){case 0:C=new Uint8Array(q);break;case 2:C=new Uint16Array(q);break;case 1:C=new Float32Array(q)}for(let A=b.length;A<O;A++)for(let b=0;b<6;b++){var L;y._uploadArrayBufferViewToTexture((null===(L=I)||void 0===L?void 0:L.texture)||Y,C,b,A)}}if(I){const b=Y._irradianceTexture;Y._irradianceTexture=null,y._releaseTexture(Y),I._swapAndDie(Y),Y._irradianceTexture=b}t&&t.dispose(),n&&(Y._lodTextureHigh&&Y._lodTextureHigh._texture&&(Y._lodTextureHigh._texture.isReady=!0),Y._lodTextureMid&&Y._lodTextureMid._texture&&(Y._lodTextureMid._texture.isReady=!0),Y._lodTextureLow&&Y._lodTextureLow._texture&&(Y._lodTextureLow._texture.isReady=!0))}function u(Y,b){const C=(b=t(b)).irradiance;if(!C)return;const R=new E.g;q.AC.FromArrayToRef(C.x,0,R.x),q.AC.FromArrayToRef(C.y,0,R.y),q.AC.FromArrayToRef(C.z,0,R.z),q.AC.FromArrayToRef(C.xx,0,R.xx),q.AC.FromArrayToRef(C.yy,0,R.yy),q.AC.FromArrayToRef(C.zz,0,R.zz),q.AC.FromArrayToRef(C.yz,0,R.yz),q.AC.FromArrayToRef(C.zx,0,R.zx),q.AC.FromArrayToRef(C.xy,0,R.xy),Y._sphericalPolynomial=R}function c(Y,b,C,R,q){const A=p(Y.getEngine().createRawCubeTexture(null,Y.width,Y.format,Y.type,Y.generateMipMaps,Y.invertY,Y.samplingMode,Y._compression),b).then((()=>Y));return Y.onRebuildCallback=Y=>({proxy:A,isReady:!0,isAsync:!0}),Y._source=13,Y._bufferViewArrayArray=b,Y._lodGenerationScale=R,Y._lodGenerationOffset=q,Y._sphericalPolynomial=C,p(Y,b).then((()=>(Y.isReady=!0,Y)))}}}]);