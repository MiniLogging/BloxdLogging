"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[45],{13216:(F,P,f)=>{f.d(P,{d:()=>t,g:()=>B,i:()=>O,l:()=>d});var c=f(11462),N=f(11639),q=f(11664),H=f(11801),A=f(11567),o=f(11666),j=(f(11845),f(11728)),i=f(11474);f(12127),f(11835),f(12138);const u="image/png",T=2,Y=[134,22,135,150,246,214,150,54];function t(F){const P=new DataView(F.buffer,F.byteOffset,F.byteLength);let f=0;for(let H=0;H<Y.length;H++)if(P.getUint8(f++)!==Y[H])return i.d.Error("Not a babylon environment map"),null;let c="",N=0;for(;N=P.getUint8(f++);)c+=String.fromCharCode(N);let q=JSON.parse(c);return q=C(q),q.binaryDataPosition=f,q.ni&&(q.ni.lodGenerationScale=q.ni.lodGenerationScale||.8),q}function C(F){if(F.version>T)throw new Error(`Unsupported babylon environment map version "${F.version}". Latest supported version is "${T}".`);return 2===F.version?F:F={...F,version:2,imageType:u}}function L(F,P){const f=(P=C(P)).ni;let c=Math.log2(P.width);if(c=Math.round(c)+1,f.mipmaps.length!==6*c)throw new Error(`Unsupported specular mipmaps number "${f.mipmaps.length}"`);const N=new Array(c);for(let q=0;q<c;q++){N[q]=new Array(6);for(let c=0;c<6;c++){const H=f.mipmaps[6*q+c];N[q][c]=new Uint8Array(F.buffer,F.byteOffset+P.binaryDataPosition+H.position,H.length)}}return N}function J(F,P){var f;P=C(P);const c=new Array(6),N=null===(f=P.irradiance)||void 0===f?void 0:f.irradianceTexture;if(N){if(6!==N.faces.length)throw new Error(`Incorrect irradiance texture faces number "${N.faces.length}"`);for(let f=0;f<6;f++){const q=N.faces[f];c[f]=new Uint8Array(F.buffer,F.byteOffset+P.binaryDataPosition+q.position,q.length)}}return c}function B(F,P,f){var c;const q=(f=C(f)).ni;if(!q)return Promise.resolve([]);F._lodGenerationScale=q.lodGenerationScale;const H=[],A=L(P,f);H.push(Z(F,A,f.imageType));const o=null===(c=f.irradiance)||void 0===c?void 0:c.irradianceTexture;if(o){var j,i;const c=J(P,f);let q=null;null!==(j=f.irradiance)&&void 0!==j&&null!==(i=j.irradianceTexture)&&void 0!==i&&i.dominantDirection&&(q=N.tP.zP(f.irradiance.irradianceTexture.dominantDirection)),H.push(R(F,c,o.size,f.imageType,q))}return Promise.all(H)}async function z(F,P,f,c,N,q,H,A,o,j,i){return await new Promise(((u,T)=>{if(f){const f=P.createTexture(null,!0,!0,null,1,null,(F=>{T(F)}),F);null===c||void 0===c||c.onEffectCreatedObservable.addOnce((A=>{A.executeWhenCompiled((()=>{c.externalTextureSamplerBinding=!0,c.onApply=c=>{c._bindTexture("textureSampler",f),c.setFloat2("scale",1,P._features.needsInvertingBitmap&&F instanceof ImageBitmap?-1:1)},P.scenes.length&&(P.scenes[0].postProcessManager.directRender([c],j,!0,q,H),P.restoreDefaultFramebuffer(),f.dispose(),URL.revokeObjectURL(N),u())}))}))}else{if(P._uploadImageToTexture(i,F,q,H),A){const f=o[H];f&&P._uploadImageToTexture(f._texture,F,q,0)}u()}}))}async function Z(F,P){let f=arguments.length>2&&void 0!==arguments[2]?arguments[2]:u;const c=F.getEngine();F.format=5,F.type=0,F.generateMipMaps=!0,F._cachedAnisotropicFilteringLevel=null,c.updateTextureSamplingMode(3,F),await y(F,P,!0,f),F.isReady=!0}async function R(F,P,f){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:u,N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const q=F.getEngine(),H=new A.b(q,5),j=new o.b(q,H);F._irradianceTexture=j,j._dominantDirection=N,H.isCube=!0,H.format=5,H.type=0,H.generateMipMaps=!0,H._cachedAnisotropicFilteringLevel=null,H.generateMipMaps=!0,H.width=f,H.height=f,q.updateTextureSamplingMode(3,H),await y(H,[P],!1,c),q.generateMipMapsForCubemap(H),H.isReady=!0}async function y(F,P,N){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:u;if(!c.Tools.IsExponentOfTwo(F.width))throw new Error("Texture size must be a power of two");const i=(0,q.ILog2)(F.width)+1,T=F.getEngine();let Y=!1,t=!1,C=null,L=null,J=null;const B=T.getCaps();B.textureLOD?T._features.supportRenderAndCopyToLodForFloatTextures?B.textureHalfFloatRender&&B.textureHalfFloatLinearFiltering?(Y=!0,F.type=2):B.textureFloatRender&&B.textureFloatLinearFiltering&&(Y=!0,F.type=1):Y=!1:(Y=!1,t=N);let Z=0;if(Y)T.isWebGPU?(Z=1,await f.e(42).then(f.bind(f,14651))):await f.e(35).then(f.bind(f,14660)),C=new j.b("rgbdDecode","rgbdDecode",null,null,1,null,3,T,!1,void 0,F.type,void 0,null,!1,void 0,Z),F._isRGBD=!1,F.invertY=!1,L=T.createRenderTargetCubeTexture(F.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:F.type,format:5});else if(F._isRGBD=!0,F.invertY=!0,t){const P=3;J={};const f=F._lodGenerationScale,c=F._lodGenerationOffset;for(let N=0;N<P;N++){const q=(i-1)*f+c,H=c+(q-c)*(1-N/(P-1)),j=Math.round(Math.min(Math.max(H,0),q)),u=new A.b(T,2);u.isCube=!0,u.invertY=!0,u.generateMipMaps=!1,T.updateTextureSamplingMode(2,u);const Y=new o.b(null);switch(Y._isCube=!0,Y._texture=u,J[j]=Y,N){case 0:F._lodTextureLow=Y;break;case 1:F._lodTextureMid=Y;break;case 2:F._lodTextureHigh=Y}}}const R=[];for(let f=0;f<P.length;f++)for(let c=0;c<6;c++){const N=P[f][c],q=new Blob([N],{type:H}),A=URL.createObjectURL(q);let o;if(T._features.forceBitmapOverHTMLImageElement)o=T.createImageBitmap(q,{premultiplyAlpha:"none"}).then((async P=>await z(P,T,Y,C,A,c,f,t,J,L,F)));else{const P=new Image;P.src=A,o=new Promise(((N,q)=>{P.onload=()=>{z(P,T,Y,C,A,c,f,t,J,L,F).then((()=>N())).catch((F=>{q(F)}))},P.onerror=F=>{q(F)}}))}R.push(o)}if(await Promise.all(R),P.length<i){let f;const c=Math.pow(2,i-1-P.length),N=c*c*4;switch(F.type){case 0:f=new Uint8Array(N);break;case 2:f=new Uint16Array(N);break;case 1:f=new Float32Array(N)}for(let q=P.length;q<i;q++)for(let P=0;P<6;P++){var y;T._uploadArrayBufferViewToTexture((null===(y=L)||void 0===y?void 0:y.texture)||F,f,P,q)}}if(L){const P=F._irradianceTexture;F._irradianceTexture=null,T._releaseTexture(F),L._swapAndDie(F),F._irradianceTexture=P}C&&C.dispose(),t&&(F._lodTextureHigh&&F._lodTextureHigh._texture&&(F._lodTextureHigh._texture.isReady=!0),F._lodTextureMid&&F._lodTextureMid._texture&&(F._lodTextureMid._texture.isReady=!0),F._lodTextureLow&&F._lodTextureLow._texture&&(F._lodTextureLow._texture.isReady=!0))}function O(F,P){const f=(P=C(P)).irradiance;if(!f)return;const c=new H.h;N.tP.FromArrayToRef(f.x,0,c.x),N.tP.FromArrayToRef(f.y,0,c.y),N.tP.FromArrayToRef(f.z,0,c.z),N.tP.FromArrayToRef(f.xx,0,c.xx),N.tP.FromArrayToRef(f.yy,0,c.yy),N.tP.FromArrayToRef(f.zz,0,c.zz),N.tP.FromArrayToRef(f.yz,0,c.yz),N.tP.FromArrayToRef(f.zx,0,c.zx),N.tP.FromArrayToRef(f.xy,0,c.xy),F._sphericalPolynomial=c}function d(F,P,f,c,N){const q=Z(F.getEngine().createRawCubeTexture(null,F.width,F.format,F.type,F.generateMipMaps,F.invertY,F.samplingMode,F._compression),P).then((()=>F));return F.onRebuildCallback=F=>({proxy:q,isReady:!0,isAsync:!0}),F._source=13,F._bufferViewArrayArray=P,F._lodGenerationScale=c,F._lodGenerationOffset=N,F._sphericalPolynomial=f,Z(F,P).then((()=>(F.isReady=!0,F)))}}}]);