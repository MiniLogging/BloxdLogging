"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[45],{12910:(F,b,Q)=>{Q.d(b,{b:()=>y,c:()=>L,e:()=>R,f:()=>p});var C=Q(11128),z=Q(11309),t=Q(11329),g=Q(11505),W=Q(11241),Z=Q(11332),q=(Q(11537),Q(11401)),G=Q(11146);Q(11796),Q(11526),Q(11803);const K="image/png",e=2,N=[134,22,135,150,246,214,150,54];function y(F){const b=new DataView(F.buffer,F.byteOffset,F.byteLength);let Q=0;for(let g=0;g<N.length;g++)if(b.getUint8(Q++)!==N[g])return G.e.Error("Not a babylon environment map"),null;let C="",z=0;for(;z=b.getUint8(Q++);)C+=String.fromCharCode(z);let t=JSON.parse(C);return t=E(t),t.binaryDataPosition=Q,t.OG&&(t.OG.lodGenerationScale=t.OG.lodGenerationScale||.8),t}function E(F){if(F.version>e)throw new Error(`Unsupported babylon environment map version "${F.version}". Latest supported version is "${e}".`);return 2===F.version?F:F={...F,version:2,imageType:K}}function c(F,b){const Q=(b=E(b)).OG;let C=Math.log2(b.width);if(C=Math.round(C)+1,Q.mipmaps.length!==6*C)throw new Error(`Unsupported specular mipmaps number "${Q.mipmaps.length}"`);const z=new Array(C);for(let t=0;t<C;t++){z[t]=new Array(6);for(let C=0;C<6;C++){const g=Q.mipmaps[6*t+C];z[t][C]=new Uint8Array(F.buffer,F.byteOffset+b.binaryDataPosition+g.position,g.length)}}return z}function X(F,b){var Q;b=E(b);const C=new Array(6),z=null===(Q=b.irradiance)||void 0===Q?void 0:Q.irradianceTexture;if(z){if(6!==z.faces.length)throw new Error(`Incorrect irradiance texture faces number "${z.faces.length}"`);for(let Q=0;Q<6;Q++){const t=z.faces[Q];C[Q]=new Uint8Array(F.buffer,F.byteOffset+b.binaryDataPosition+t.position,t.length)}}return C}function L(F,b,Q){var C;const t=(Q=E(Q)).OG;if(!t)return Promise.resolve([]);F._lodGenerationScale=t.lodGenerationScale;const g=[],W=c(b,Q);g.push(f(F,W,Q.imageType));const Z=null===(C=Q.irradiance)||void 0===C?void 0:C.irradianceTexture;if(Z){var q,G;const C=X(b,Q);let t=null;null!==(q=Q.irradiance)&&void 0!==q&&null!==(G=q.irradianceTexture)&&void 0!==G&&G.dominantDirection&&(t=z.gQ.KQ(Q.irradiance.irradianceTexture.dominantDirection)),g.push(k(F,C,Z.size,Q.imageType,t))}return Promise.all(g)}async function i(F,b,Q,C,z,t,g,W,Z,q,G){return await new Promise(((K,e)=>{if(Q){const Q=b.createTexture(null,!0,!0,null,1,null,(F=>{e(F)}),F);null===C||void 0===C||C.onEffectCreatedObservable.addOnce((W=>{W.executeWhenCompiled((()=>{C.externalTextureSamplerBinding=!0,C.onApply=C=>{C._bindTexture("textureSampler",Q),C.setFloat2("scale",1,b._features.needsInvertingBitmap&&F instanceof ImageBitmap?-1:1)},b.scenes.length&&(b.scenes[0].postProcessManager.directRender([C],q,!0,t,g),b.restoreDefaultFramebuffer(),Q.dispose(),URL.revokeObjectURL(z),K())}))}))}else{if(b._uploadImageToTexture(G,F,t,g),W){const Q=Z[g];Q&&b._uploadImageToTexture(Q._texture,F,t,0)}K()}}))}async function f(F,b){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:K;const C=F.getEngine();F.format=5,F.type=0,F.generateMipMaps=!0,F._cachedAnisotropicFilteringLevel=null,C.updateTextureSamplingMode(3,F),await m(F,b,!0,Q),F.isReady=!0}async function k(F,b,Q){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const t=F.getEngine(),g=new W.b(t,5),q=new Z.e(t,g);F._irradianceTexture=q,q._dominantDirection=z,g.isCube=!0,g.format=5,g.type=0,g.generateMipMaps=!0,g._cachedAnisotropicFilteringLevel=null,g.generateMipMaps=!0,g.width=Q,g.height=Q,t.updateTextureSamplingMode(3,g),await m(g,[b],!1,C),t.generateMipMapsForCubemap(g),g.isReady=!0}async function m(F,b,z){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K;if(!C.Tools.IsExponentOfTwo(F.width))throw new Error("Texture size must be a power of two");const G=(0,t.ILog2)(F.width)+1,e=F.getEngine();let N=!1,y=!1,E=null,c=null,X=null;const L=e.getCaps();L.textureLOD?e._features.supportRenderAndCopyToLodForFloatTextures?L.textureHalfFloatRender&&L.textureHalfFloatLinearFiltering?(N=!0,F.type=2):L.textureFloatRender&&L.textureFloatLinearFiltering&&(N=!0,F.type=1):N=!1:(N=!1,y=z);let f=0;if(N)e.isWebGPU?(f=1,await Q.e(42).then(Q.bind(Q,14292))):await Q.e(35).then(Q.bind(Q,14298)),E=new q.b("rgbdDecode","rgbdDecode",null,null,1,null,3,e,!1,void 0,F.type,void 0,null,!1,void 0,f),F._isRGBD=!1,F.invertY=!1,c=e.createRenderTargetCubeTexture(F.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:F.type,format:5});else if(F._isRGBD=!0,F.invertY=!0,y){const b=3;X={};const Q=F._lodGenerationScale,C=F._lodGenerationOffset;for(let z=0;z<b;z++){const t=(G-1)*Q+C,g=C+(t-C)*(1-z/(b-1)),q=Math.round(Math.min(Math.max(g,0),t)),K=new W.b(e,2);K.isCube=!0,K.invertY=!0,K.generateMipMaps=!1,e.updateTextureSamplingMode(2,K);const N=new Z.e(null);switch(N._isCube=!0,N._texture=K,X[q]=N,z){case 0:F._lodTextureLow=N;break;case 1:F._lodTextureMid=N;break;case 2:F._lodTextureHigh=N}}}const k=[];for(let Q=0;Q<b.length;Q++)for(let C=0;C<6;C++){const z=b[Q][C],t=new Blob([z],{type:g}),W=URL.createObjectURL(t);let Z;if(e._features.forceBitmapOverHTMLImageElement)Z=e.createImageBitmap(t,{premultiplyAlpha:"none"}).then((async b=>await i(b,e,N,E,W,C,Q,y,X,c,F)));else{const b=new Image;b.src=W,Z=new Promise(((z,t)=>{b.onload=()=>{i(b,e,N,E,W,C,Q,y,X,c,F).then((()=>z())).catch((F=>{t(F)}))},b.onerror=F=>{t(F)}}))}k.push(Z)}if(await Promise.all(k),b.length<G){let Q;const C=Math.pow(2,G-1-b.length),z=C*C*4;switch(F.type){case 0:Q=new Uint8Array(z);break;case 2:Q=new Uint16Array(z);break;case 1:Q=new Float32Array(z)}for(let t=b.length;t<G;t++)for(let b=0;b<6;b++){var m;e._uploadArrayBufferViewToTexture((null===(m=c)||void 0===m?void 0:m.texture)||F,Q,b,t)}}if(c){const b=F._irradianceTexture;F._irradianceTexture=null,e._releaseTexture(F),c._swapAndDie(F),F._irradianceTexture=b}E&&E.dispose(),y&&(F._lodTextureHigh&&F._lodTextureHigh._texture&&(F._lodTextureHigh._texture.isReady=!0),F._lodTextureMid&&F._lodTextureMid._texture&&(F._lodTextureMid._texture.isReady=!0),F._lodTextureLow&&F._lodTextureLow._texture&&(F._lodTextureLow._texture.isReady=!0))}function R(F,b){const Q=(b=E(b)).irradiance;if(!Q)return;const C=new g.e;z.gQ.FromArrayToRef(Q.x,0,C.x),z.gQ.FromArrayToRef(Q.y,0,C.y),z.gQ.FromArrayToRef(Q.z,0,C.z),z.gQ.FromArrayToRef(Q.xx,0,C.xx),z.gQ.FromArrayToRef(Q.yy,0,C.yy),z.gQ.FromArrayToRef(Q.zz,0,C.zz),z.gQ.FromArrayToRef(Q.yz,0,C.yz),z.gQ.FromArrayToRef(Q.zx,0,C.zx),z.gQ.FromArrayToRef(Q.xy,0,C.xy),F._sphericalPolynomial=C}function p(F,b,Q,C,z){const t=f(F.getEngine().createRawCubeTexture(null,F.width,F.format,F.type,F.generateMipMaps,F.invertY,F.samplingMode,F._compression),b).then((()=>F));return F.onRebuildCallback=F=>({proxy:t,isReady:!0,isAsync:!0}),F._source=13,F._bufferViewArrayArray=b,F._lodGenerationScale=C,F._lodGenerationOffset=z,F._sphericalPolynomial=Q,f(F,b).then((()=>(F.isReady=!0,F)))}}}]);