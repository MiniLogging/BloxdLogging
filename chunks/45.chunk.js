"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[45],{13014:(m,S,h)=>{h.d(S,{e:()=>B,h:()=>L,l:()=>o,o:()=>s});var l=h(11156),M=h(11347),O=h(11359),u=h(11520),b=h(11262),q=h(11368),Y=(h(11567),h(11441)),V=h(11173);h(11811),h(11550),h(11822);const I="image/png",Z=2,C=[134,22,135,150,246,214,150,54];function B(m){const S=new DataView(m.buffer,m.byteOffset,m.byteLength);let h=0;for(let u=0;u<C.length;u++)if(S.getUint8(h++)!==C[u])return V.e.Error("Not a babylon environment map"),null;let l="",M=0;for(;M=S.getUint8(h++);)l+=String.fromCharCode(M);let O=JSON.parse(l);return O=D(O),O.binaryDataPosition=h,O.dV&&(O.dV.lodGenerationScale=O.dV.lodGenerationScale||.8),O}function D(m){if(m.version>Z)throw new Error(`Unsupported babylon environment map version "${m.version}". Latest supported version is "${Z}".`);return 2===m.version?m:m={...m,version:2,imageType:I}}function E(m,S){const h=(S=D(S)).dV;let l=Math.log2(S.width);if(l=Math.round(l)+1,h.mipmaps.length!==6*l)throw new Error(`Unsupported specular mipmaps number "${h.mipmaps.length}"`);const M=new Array(l);for(let O=0;O<l;O++){M[O]=new Array(6);for(let l=0;l<6;l++){const u=h.mipmaps[6*O+l];M[O][l]=new Uint8Array(m.buffer,m.byteOffset+S.binaryDataPosition+u.position,u.length)}}return M}function n(m,S){var h;S=D(S);const l=new Array(6),M=null===(h=S.irradiance)||void 0===h?void 0:h.irradianceTexture;if(M){if(6!==M.faces.length)throw new Error(`Incorrect irradiance texture faces number "${M.faces.length}"`);for(let h=0;h<6;h++){const O=M.faces[h];l[h]=new Uint8Array(m.buffer,m.byteOffset+S.binaryDataPosition+O.position,O.length)}}return l}function L(m,S,h){var l;const O=(h=D(h)).dV;if(!O)return Promise.resolve([]);m._lodGenerationScale=O.lodGenerationScale;const u=[],b=E(S,h);u.push(H(m,b,h.imageType));const q=null===(l=h.irradiance)||void 0===l?void 0:l.irradianceTexture;if(q){var Y,V;const l=n(S,h);let O=null;null!==(Y=h.irradiance)&&void 0!==Y&&null!==(V=Y.irradianceTexture)&&void 0!==V&&V.dominantDirection&&(O=M.nS.yS(h.irradiance.irradianceTexture.dominantDirection)),u.push(R(m,l,q.size,h.imageType,O))}return Promise.all(u)}async function U(m,S,h,l,M,O,u,b,q,Y,V){return await new Promise(((I,Z)=>{if(h){const h=S.createTexture(null,!0,!0,null,1,null,(m=>{Z(m)}),m);null===l||void 0===l||l.onEffectCreatedObservable.addOnce((b=>{b.executeWhenCompiled((()=>{l.externalTextureSamplerBinding=!0,l.onApply=l=>{l._bindTexture("textureSampler",h),l.setFloat2("scale",1,S._features.needsInvertingBitmap&&m instanceof ImageBitmap?-1:1)},S.scenes.length&&(S.scenes[0].postProcessManager.directRender([l],Y,!0,O,u),S.restoreDefaultFramebuffer(),h.dispose(),URL.revokeObjectURL(M),I())}))}))}else{if(S._uploadImageToTexture(V,m,O,u),b){const h=q[u];h&&S._uploadImageToTexture(h._texture,m,O,0)}I()}}))}async function H(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:I;const l=m.getEngine();m.format=5,m.type=0,m.generateMipMaps=!0,m._cachedAnisotropicFilteringLevel=null,l.updateTextureSamplingMode(3,m),await y(m,S,!0,h),m.isReady=!0}async function R(m,S,h){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I,M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const O=m.getEngine(),u=new b.d(O,5),Y=new q.c(O,u);m._irradianceTexture=Y,Y._dominantDirection=M,u.isCube=!0,u.format=5,u.type=0,u.generateMipMaps=!0,u._cachedAnisotropicFilteringLevel=null,u.generateMipMaps=!0,u.width=h,u.height=h,O.updateTextureSamplingMode(3,u),await y(u,[S],!1,l),O.generateMipMapsForCubemap(u),u.isReady=!0}async function y(m,S,M){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I;if(!l.Tools.IsExponentOfTwo(m.width))throw new Error("Texture size must be a power of two");const V=(0,O.ILog2)(m.width)+1,Z=m.getEngine();let C=!1,B=!1,D=null,E=null,n=null;const L=Z.getCaps();L.textureLOD?Z._features.supportRenderAndCopyToLodForFloatTextures?L.textureHalfFloatRender&&L.textureHalfFloatLinearFiltering?(C=!0,m.type=2):L.textureFloatRender&&L.textureFloatLinearFiltering&&(C=!0,m.type=1):C=!1:(C=!1,B=M);let H=0;if(C)Z.isWebGPU?(H=1,await h.e(42).then(h.bind(h,14415))):await h.e(35).then(h.bind(h,14424)),D=new Y.e("rgbdDecode","rgbdDecode",null,null,1,null,3,Z,!1,void 0,m.type,void 0,null,!1,void 0,H),m._isRGBD=!1,m.invertY=!1,E=Z.createRenderTargetCubeTexture(m.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:m.type,format:5});else if(m._isRGBD=!0,m.invertY=!0,B){const S=3;n={};const h=m._lodGenerationScale,l=m._lodGenerationOffset;for(let M=0;M<S;M++){const O=(V-1)*h+l,u=l+(O-l)*(1-M/(S-1)),Y=Math.round(Math.min(Math.max(u,0),O)),I=new b.d(Z,2);I.isCube=!0,I.invertY=!0,I.generateMipMaps=!1,Z.updateTextureSamplingMode(2,I);const C=new q.c(null);switch(C._isCube=!0,C._texture=I,n[Y]=C,M){case 0:m._lodTextureLow=C;break;case 1:m._lodTextureMid=C;break;case 2:m._lodTextureHigh=C}}}const R=[];for(let h=0;h<S.length;h++)for(let l=0;l<6;l++){const M=S[h][l],O=new Blob([M],{type:u}),b=URL.createObjectURL(O);let q;if(Z._features.forceBitmapOverHTMLImageElement)q=Z.createImageBitmap(O,{premultiplyAlpha:"none"}).then((async S=>await U(S,Z,C,D,b,l,h,B,n,E,m)));else{const S=new Image;S.src=b,q=new Promise(((M,O)=>{S.onload=()=>{U(S,Z,C,D,b,l,h,B,n,E,m).then((()=>M())).catch((m=>{O(m)}))},S.onerror=m=>{O(m)}}))}R.push(q)}if(await Promise.all(R),S.length<V){let h;const l=Math.pow(2,V-1-S.length),M=l*l*4;switch(m.type){case 0:h=new Uint8Array(M);break;case 2:h=new Uint16Array(M);break;case 1:h=new Float32Array(M)}for(let O=S.length;O<V;O++)for(let S=0;S<6;S++){var y;Z._uploadArrayBufferViewToTexture((null===(y=E)||void 0===y?void 0:y.texture)||m,h,S,O)}}if(E){const S=m._irradianceTexture;m._irradianceTexture=null,Z._releaseTexture(m),E._swapAndDie(m),m._irradianceTexture=S}D&&D.dispose(),B&&(m._lodTextureHigh&&m._lodTextureHigh._texture&&(m._lodTextureHigh._texture.isReady=!0),m._lodTextureMid&&m._lodTextureMid._texture&&(m._lodTextureMid._texture.isReady=!0),m._lodTextureLow&&m._lodTextureLow._texture&&(m._lodTextureLow._texture.isReady=!0))}function o(m,S){const h=(S=D(S)).irradiance;if(!h)return;const l=new u.i;M.nS.FromArrayToRef(h.x,0,l.x),M.nS.FromArrayToRef(h.y,0,l.y),M.nS.FromArrayToRef(h.z,0,l.z),M.nS.FromArrayToRef(h.xx,0,l.xx),M.nS.FromArrayToRef(h.yy,0,l.yy),M.nS.FromArrayToRef(h.zz,0,l.zz),M.nS.FromArrayToRef(h.yz,0,l.yz),M.nS.FromArrayToRef(h.zx,0,l.zx),M.nS.FromArrayToRef(h.xy,0,l.xy),m._sphericalPolynomial=l}function s(m,S,h,l,M){const O=H(m.getEngine().createRawCubeTexture(null,m.width,m.format,m.type,m.generateMipMaps,m.invertY,m.samplingMode,m._compression),S).then((()=>m));return m.onRebuildCallback=m=>({proxy:O,isReady:!0,isAsync:!0}),m._source=13,m._bufferViewArrayArray=S,m._lodGenerationScale=l,m._lodGenerationOffset=M,m._sphericalPolynomial=h,H(m,S).then((()=>(m.isReady=!0,m)))}}}]);