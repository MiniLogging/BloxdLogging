"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[45],{13069:(S,v,D)=>{D.d(v,{c:()=>R,g:()=>q,i:()=>x,m:()=>W});var z=D(11175),e=D(11371),N=D(11393),m=D(11573),B=D(11301),g=D(11400),E=(D(11619),D(11485)),h=D(11190);D(11864),D(11605),D(11877);const A="image/png",w=2,n=[134,22,135,150,246,214,150,54];function R(S){const v=new DataView(S.buffer,S.byteOffset,S.byteLength);let D=0;for(let m=0;m<n.length;m++)if(v.getUint8(D++)!==n[m])return h.b.Error("Not a babylon environment map"),null;let z="",e=0;for(;e=v.getUint8(D++);)z+=String.fromCharCode(e);let N=JSON.parse(z);return N=O(N),N.binaryDataPosition=D,N.Jh&&(N.Jh.lodGenerationScale=N.Jh.lodGenerationScale||.8),N}function O(S){if(S.version>w)throw new Error(`Unsupported babylon environment map version "${S.version}". Latest supported version is "${w}".`);return 2===S.version?S:S={...S,version:2,imageType:A}}function I(S,v){const D=(v=O(v)).Jh;let z=Math.log2(v.width);if(z=Math.round(z)+1,D.mipmaps.length!==6*z)throw new Error(`Unsupported specular mipmaps number "${D.mipmaps.length}"`);const e=new Array(z);for(let N=0;N<z;N++){e[N]=new Array(6);for(let z=0;z<6;z++){const m=D.mipmaps[6*N+z];e[N][z]=new Uint8Array(S.buffer,S.byteOffset+v.binaryDataPosition+m.position,m.length)}}return e}function K(S,v){var D;v=O(v);const z=new Array(6),e=null===(D=v.irradiance)||void 0===D?void 0:D.irradianceTexture;if(e){if(6!==e.faces.length)throw new Error(`Incorrect irradiance texture faces number "${e.faces.length}"`);for(let D=0;D<6;D++){const N=e.faces[D];z[D]=new Uint8Array(S.buffer,S.byteOffset+v.binaryDataPosition+N.position,N.length)}}return z}function q(S,v,D){var z;const N=(D=O(D)).Jh;if(!N)return Promise.resolve([]);S._lodGenerationScale=N.lodGenerationScale;const m=[],B=I(v,D);m.push(s(S,B,D.imageType));const g=null===(z=D.irradiance)||void 0===z?void 0:z.irradianceTexture;if(g){var E,h;const z=K(v,D);let N=null;null!==(E=D.irradiance)&&void 0!==E&&null!==(h=E.irradianceTexture)&&void 0!==h&&h.dominantDirection&&(N=e.Rv.uv(D.irradiance.irradianceTexture.dominantDirection)),m.push(r(S,z,g.size,D.imageType,N))}return Promise.all(m)}async function u(S,v,D,z,e,N,m,B,g,E,h){return await new Promise(((A,w)=>{if(D){const D=v.createTexture(null,!0,!0,null,1,null,(S=>{w(S)}),S);null===z||void 0===z||z.onEffectCreatedObservable.addOnce((B=>{B.executeWhenCompiled((()=>{z.externalTextureSamplerBinding=!0,z.onApply=z=>{z._bindTexture("textureSampler",D),z.setFloat2("scale",1,v._features.needsInvertingBitmap&&S instanceof ImageBitmap?-1:1)},v.scenes.length&&(v.scenes[0].postProcessManager.directRender([z],E,!0,N,m),v.restoreDefaultFramebuffer(),D.dispose(),URL.revokeObjectURL(e),A())}))}))}else{if(v._uploadImageToTexture(h,S,N,m),B){const D=g[m];D&&v._uploadImageToTexture(D._texture,S,N,0)}A()}}))}async function s(S,v){let D=arguments.length>2&&void 0!==arguments[2]?arguments[2]:A;const z=S.getEngine();S.format=5,S.type=0,S.generateMipMaps=!0,S._cachedAnisotropicFilteringLevel=null,z.updateTextureSamplingMode(3,S),await d(S,v,!0,D),S.isReady=!0}async function r(S,v,D){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A,e=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const N=S.getEngine(),m=new B.b(N,5),E=new g.e(N,m);S._irradianceTexture=E,E._dominantDirection=e,m.isCube=!0,m.format=5,m.type=0,m.generateMipMaps=!0,m._cachedAnisotropicFilteringLevel=null,m.generateMipMaps=!0,m.width=D,m.height=D,N.updateTextureSamplingMode(3,m),await d(m,[v],!1,z),N.generateMipMapsForCubemap(m),m.isReady=!0}async function d(S,v,e){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:A;if(!z.Tools.IsExponentOfTwo(S.width))throw new Error("Texture size must be a power of two");const h=(0,N.ILog2)(S.width)+1,w=S.getEngine();let n=!1,R=!1,O=null,I=null,K=null;const q=w.getCaps();q.textureLOD?w._features.supportRenderAndCopyToLodForFloatTextures?q.textureHalfFloatRender&&q.textureHalfFloatLinearFiltering?(n=!0,S.type=2):q.textureFloatRender&&q.textureFloatLinearFiltering&&(n=!0,S.type=1):n=!1:(n=!1,R=e);let s=0;if(n)w.isWebGPU?(s=1,await D.e(42).then(D.bind(D,14435))):await D.e(35).then(D.bind(D,14441)),O=new E.e("rgbdDecode","rgbdDecode",null,null,1,null,3,w,!1,void 0,S.type,void 0,null,!1,void 0,s),S._isRGBD=!1,S.invertY=!1,I=w.createRenderTargetCubeTexture(S.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:S.type,format:5});else if(S._isRGBD=!0,S.invertY=!0,R){const v=3;K={};const D=S._lodGenerationScale,z=S._lodGenerationOffset;for(let e=0;e<v;e++){const N=(h-1)*D+z,m=z+(N-z)*(1-e/(v-1)),E=Math.round(Math.min(Math.max(m,0),N)),A=new B.b(w,2);A.isCube=!0,A.invertY=!0,A.generateMipMaps=!1,w.updateTextureSamplingMode(2,A);const n=new g.e(null);switch(n._isCube=!0,n._texture=A,K[E]=n,e){case 0:S._lodTextureLow=n;break;case 1:S._lodTextureMid=n;break;case 2:S._lodTextureHigh=n}}}const r=[];for(let D=0;D<v.length;D++)for(let z=0;z<6;z++){const e=v[D][z],N=new Blob([e],{type:m}),B=URL.createObjectURL(N);let g;if(w._features.forceBitmapOverHTMLImageElement)g=w.createImageBitmap(N,{premultiplyAlpha:"none"}).then((async v=>await u(v,w,n,O,B,z,D,R,K,I,S)));else{const v=new Image;v.src=B,g=new Promise(((e,N)=>{v.onload=()=>{u(v,w,n,O,B,z,D,R,K,I,S).then((()=>e())).catch((S=>{N(S)}))},v.onerror=S=>{N(S)}}))}r.push(g)}if(await Promise.all(r),v.length<h){let D;const z=Math.pow(2,h-1-v.length),e=z*z*4;switch(S.type){case 0:D=new Uint8Array(e);break;case 2:D=new Uint16Array(e);break;case 1:D=new Float32Array(e)}for(let N=v.length;N<h;N++)for(let v=0;v<6;v++){var d;w._uploadArrayBufferViewToTexture((null===(d=I)||void 0===d?void 0:d.texture)||S,D,v,N)}}if(I){const v=S._irradianceTexture;S._irradianceTexture=null,w._releaseTexture(S),I._swapAndDie(S),S._irradianceTexture=v}O&&O.dispose(),R&&(S._lodTextureHigh&&S._lodTextureHigh._texture&&(S._lodTextureHigh._texture.isReady=!0),S._lodTextureMid&&S._lodTextureMid._texture&&(S._lodTextureMid._texture.isReady=!0),S._lodTextureLow&&S._lodTextureLow._texture&&(S._lodTextureLow._texture.isReady=!0))}function x(S,v){const D=(v=O(v)).irradiance;if(!D)return;const z=new m.g;e.Rv.FromArrayToRef(D.x,0,z.x),e.Rv.FromArrayToRef(D.y,0,z.y),e.Rv.FromArrayToRef(D.z,0,z.z),e.Rv.FromArrayToRef(D.xx,0,z.xx),e.Rv.FromArrayToRef(D.yy,0,z.yy),e.Rv.FromArrayToRef(D.zz,0,z.zz),e.Rv.FromArrayToRef(D.yz,0,z.yz),e.Rv.FromArrayToRef(D.zx,0,z.zx),e.Rv.FromArrayToRef(D.xy,0,z.xy),S._sphericalPolynomial=z}function W(S,v,D,z,e){const N=s(S.getEngine().createRawCubeTexture(null,S.width,S.format,S.type,S.generateMipMaps,S.invertY,S.samplingMode,S._compression),v).then((()=>S));return S.onRebuildCallback=S=>({proxy:N,isReady:!0,isAsync:!0}),S._source=13,S._bufferViewArrayArray=v,S._lodGenerationScale=z,S._lodGenerationOffset=e,S._sphericalPolynomial=D,s(S,v).then((()=>(S.isReady=!0,S)))}}}]);