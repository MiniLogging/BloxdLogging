"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[45],{14124:(u,R,I)=>{I.d(R,{e:()=>P,f:()=>f,i:()=>e,k:()=>Y});var B=I(12294),U=I(12481),K=I(12491),C=I(12654),D=I(12415),s=I(12499),t=(I(12703),I(12575)),G=I(12315);I(12964),I(12689),I(12974);const S="image/png",b=2,r=[134,22,135,150,246,214,150,54];function P(u){const R=new DataView(u.buffer,u.byteOffset,u.byteLength);let I=0;for(let C=0;C<r.length;C++)if(R.getUint8(I++)!==r[C])return G.b.Error("Not a babylon environment map"),null;let B="",U=0;for(;U=R.getUint8(I++);)B+=String.fromCharCode(U);let K=JSON.parse(B);return K=X(K),K.binaryDataPosition=I,K.rG&&(K.rG.lodGenerationScale=K.rG.lodGenerationScale||.8),K}function X(u){if(u.version>b)throw new Error(`Unsupported babylon environment map version "${u.version}". Latest supported version is "${b}".`);return 2===u.version?u:u={...u,version:2,imageType:S}}function E(u,R){const I=(R=X(R)).rG;let B=Math.log2(R.width);if(B=Math.round(B)+1,I.mipmaps.length!==6*B)throw new Error(`Unsupported specular mipmaps number "${I.mipmaps.length}"`);const U=new Array(B);for(let K=0;K<B;K++){U[K]=new Array(6);for(let B=0;B<6;B++){const C=I.mipmaps[6*K+B];U[K][B]=new Uint8Array(u.buffer,u.byteOffset+R.binaryDataPosition+C.position,C.length)}}return U}function z(u,R){var I;R=X(R);const B=new Array(6),U=null===(I=R.irradiance)||void 0===I?void 0:I.irradianceTexture;if(U){if(6!==U.faces.length)throw new Error(`Incorrect irradiance texture faces number "${U.faces.length}"`);for(let I=0;I<6;I++){const K=U.faces[I];B[I]=new Uint8Array(u.buffer,u.byteOffset+R.binaryDataPosition+K.position,K.length)}}return B}function f(u,R,I){var B;const K=(I=X(I)).rG;if(!K)return Promise.resolve([]);u._lodGenerationScale=K.lodGenerationScale;const C=[],D=E(R,I);C.push(Q(u,D,I.imageType));const s=null===(B=I.irradiance)||void 0===B?void 0:B.irradianceTexture;if(s){var t,G;const B=z(R,I);let K=null;null!==(t=I.irradiance)&&void 0!==t&&null!==(G=t.irradianceTexture)&&void 0!==G&&G.dominantDirection&&(K=U.PR.TR(I.irradiance.irradianceTexture.dominantDirection)),C.push(V(u,B,s.size,I.imageType,K))}return Promise.all(C)}async function T(u,R,I,B,U,K,C,D,s,t,G){return await new Promise(((S,b)=>{if(I){const I=R.createTexture(null,!0,!0,null,1,null,(u=>{b(u)}),u);null===B||void 0===B||B.onEffectCreatedObservable.addOnce((D=>{D.executeWhenCompiled((()=>{B.externalTextureSamplerBinding=!0,B.onApply=B=>{B._bindTexture("textureSampler",I),B.setFloat2("scale",1,R._features.needsInvertingBitmap&&u instanceof ImageBitmap?-1:1)},R.scenes.length&&(R.scenes[0].postProcessManager.directRender([B],t,!0,K,C),R.restoreDefaultFramebuffer(),I.dispose(),URL.revokeObjectURL(U),S())}))}))}else{if(R._uploadImageToTexture(G,u,K,C),D){const I=s[C];I&&R._uploadImageToTexture(I._texture,u,K,0)}S()}}))}async function Q(u,R){let I=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S;const B=u.getEngine();u.format=5,u.type=0,u.generateMipMaps=!0,u._cachedAnisotropicFilteringLevel=null,B.updateTextureSamplingMode(3,u),await q(u,R,!0,I),u.isReady=!0}async function V(u,R,I){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S,U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const K=u.getEngine(),C=new D.d(K,5),t=new s.b(K,C);u._irradianceTexture=t,t._dominantDirection=U,C.isCube=!0,C.format=5,C.type=0,C.generateMipMaps=!0,C._cachedAnisotropicFilteringLevel=null,C.generateMipMaps=!0,C.width=I,C.height=I,K.updateTextureSamplingMode(3,C),await q(C,[R],!1,B),K.generateMipMapsForCubemap(C),C.isReady=!0}async function q(u,R,U){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S;if(!B.Tools.IsExponentOfTwo(u.width))throw new Error("Texture size must be a power of two");const G=(0,K.ILog2)(u.width)+1,b=u.getEngine();let r=!1,P=!1,X=null,E=null,z=null;const f=b.getCaps();f.textureLOD?b._features.supportRenderAndCopyToLodForFloatTextures?f.textureHalfFloatRender&&f.textureHalfFloatLinearFiltering?(r=!0,u.type=2):f.textureFloatRender&&f.textureFloatLinearFiltering&&(r=!0,u.type=1):r=!1:(r=!1,P=U);let Q=0;if(r)b.isWebGPU?(Q=1,await I.e(42).then(I.bind(I,15488))):await I.e(35).then(I.bind(I,15492)),X=new t.e("rgbdDecode","rgbdDecode",null,null,1,null,3,b,!1,void 0,u.type,void 0,null,!1,void 0,Q),u._isRGBD=!1,u.invertY=!1,E=b.createRenderTargetCubeTexture(u.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:u.type,format:5});else if(u._isRGBD=!0,u.invertY=!0,P){const R=3;z={};const I=u._lodGenerationScale,B=u._lodGenerationOffset;for(let U=0;U<R;U++){const K=(G-1)*I+B,C=B+(K-B)*(1-U/(R-1)),t=Math.round(Math.min(Math.max(C,0),K)),S=new D.d(b,2);S.isCube=!0,S.invertY=!0,S.generateMipMaps=!1,b.updateTextureSamplingMode(2,S);const r=new s.b(null);switch(r._isCube=!0,r._texture=S,z[t]=r,U){case 0:u._lodTextureLow=r;break;case 1:u._lodTextureMid=r;break;case 2:u._lodTextureHigh=r}}}const V=[];for(let I=0;I<R.length;I++)for(let B=0;B<6;B++){const U=R[I][B],K=new Blob([U],{type:C}),D=URL.createObjectURL(K);let s;if(b._features.forceBitmapOverHTMLImageElement)s=b.createImageBitmap(K,{premultiplyAlpha:"none"}).then((async R=>await T(R,b,r,X,D,B,I,P,z,E,u)));else{const R=new Image;R.src=D,s=new Promise(((U,K)=>{R.onload=()=>{T(R,b,r,X,D,B,I,P,z,E,u).then((()=>U())).catch((u=>{K(u)}))},R.onerror=u=>{K(u)}}))}V.push(s)}if(await Promise.all(V),R.length<G){let I;const B=Math.pow(2,G-1-R.length),U=B*B*4;switch(u.type){case 0:I=new Uint8Array(U);break;case 2:I=new Uint16Array(U);break;case 1:I=new Float32Array(U)}for(let K=R.length;K<G;K++)for(let R=0;R<6;R++){var q;b._uploadArrayBufferViewToTexture((null===(q=E)||void 0===q?void 0:q.texture)||u,I,R,K)}}if(E){const R=u._irradianceTexture;u._irradianceTexture=null,b._releaseTexture(u),E._swapAndDie(u),u._irradianceTexture=R}X&&X.dispose(),P&&(u._lodTextureHigh&&u._lodTextureHigh._texture&&(u._lodTextureHigh._texture.isReady=!0),u._lodTextureMid&&u._lodTextureMid._texture&&(u._lodTextureMid._texture.isReady=!0),u._lodTextureLow&&u._lodTextureLow._texture&&(u._lodTextureLow._texture.isReady=!0))}function e(u,R){const I=(R=X(R)).irradiance;if(!I)return;const B=new C.g;U.PR.FromArrayToRef(I.x,0,B.x),U.PR.FromArrayToRef(I.y,0,B.y),U.PR.FromArrayToRef(I.z,0,B.z),U.PR.FromArrayToRef(I.xx,0,B.xx),U.PR.FromArrayToRef(I.yy,0,B.yy),U.PR.FromArrayToRef(I.zz,0,B.zz),U.PR.FromArrayToRef(I.yz,0,B.yz),U.PR.FromArrayToRef(I.zx,0,B.zx),U.PR.FromArrayToRef(I.xy,0,B.xy),u._sphericalPolynomial=B}function Y(u,R,I,B,U){const K=Q(u.getEngine().createRawCubeTexture(null,u.width,u.format,u.type,u.generateMipMaps,u.invertY,u.samplingMode,u._compression),R).then((()=>u));return u.onRebuildCallback=u=>({proxy:K,isReady:!0,isAsync:!0}),u._source=13,u._bufferViewArrayArray=R,u._lodGenerationScale=B,u._lodGenerationOffset=U,u._sphericalPolynomial=I,Q(u,R).then((()=>(u.isReady=!0,u)))}}}]);