"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[45],{12750:(h,V,i)=>{i.d(V,{b:()=>T,f:()=>f,i:()=>D,j:()=>O});var S=i(10952),l=i(11138),Y=i(11162),g=i(11335),q=i(11064),B=i(11167),J=(i(11382),i(11250)),I=i(10967);i(11643),i(11362),i(11653);const v="image/png",s=2,t=[134,22,135,150,246,214,150,54];function T(h){const V=new DataView(h.buffer,h.byteOffset,h.byteLength);let i=0;for(let g=0;g<t.length;g++)if(V.getUint8(i++)!==t[g])return I.d.Error("Not a babylon environment map"),null;let S="",l=0;for(;l=V.getUint8(i++);)S+=String.fromCharCode(l);let Y=JSON.parse(S);return Y=e(Y),Y.binaryDataPosition=i,Y.yJ&&(Y.yJ.lodGenerationScale=Y.yJ.lodGenerationScale||.8),Y}function e(h){if(h.version>s)throw new Error(`Unsupported babylon environment map version "${h.version}". Latest supported version is "${s}".`);return 2===h.version?h:h={...h,version:2,imageType:v}}function n(h,V){const i=(V=e(V)).yJ;let S=Math.log2(V.width);if(S=Math.round(S)+1,i.mipmaps.length!==6*S)throw new Error(`Unsupported specular mipmaps number "${i.mipmaps.length}"`);const l=new Array(S);for(let Y=0;Y<S;Y++){l[Y]=new Array(6);for(let S=0;S<6;S++){const g=i.mipmaps[6*Y+S];l[Y][S]=new Uint8Array(h.buffer,h.byteOffset+V.binaryDataPosition+g.position,g.length)}}return l}function c(h,V){var i;V=e(V);const S=new Array(6),l=null===(i=V.irradiance)||void 0===i?void 0:i.irradianceTexture;if(l){if(6!==l.faces.length)throw new Error(`Incorrect irradiance texture faces number "${l.faces.length}"`);for(let i=0;i<6;i++){const Y=l.faces[i];S[i]=new Uint8Array(h.buffer,h.byteOffset+V.binaryDataPosition+Y.position,Y.length)}}return S}function f(h,V,i){var S;const Y=(i=e(i)).yJ;if(!Y)return Promise.resolve([]);h._lodGenerationScale=Y.lodGenerationScale;const g=[],q=n(V,i);g.push(L(h,q,i.imageType));const B=null===(S=i.irradiance)||void 0===S?void 0:S.irradianceTexture;if(B){var J,I;const S=c(V,i);let Y=null;null!==(J=i.irradiance)&&void 0!==J&&null!==(I=J.irradianceTexture)&&void 0!==I&&I.dominantDirection&&(Y=l.nV.UV(i.irradiance.irradianceTexture.dominantDirection)),g.push(U(h,S,B.size,i.imageType,Y))}return Promise.all(g)}async function P(h,V,i,S,l,Y,g,q,B,J,I){return await new Promise(((v,s)=>{if(i){const i=V.createTexture(null,!0,!0,null,1,null,(h=>{s(h)}),h);null===S||void 0===S||S.onEffectCreatedObservable.addOnce((q=>{q.executeWhenCompiled((()=>{S.externalTextureSamplerBinding=!0,S.onApply=S=>{S._bindTexture("textureSampler",i),S.setFloat2("scale",1,V._features.needsInvertingBitmap&&h instanceof ImageBitmap?-1:1)},V.scenes.length&&(V.scenes[0].postProcessManager.directRender([S],J,!0,Y,g),V.restoreDefaultFramebuffer(),i.dispose(),URL.revokeObjectURL(l),v())}))}))}else{if(V._uploadImageToTexture(I,h,Y,g),q){const i=B[g];i&&V._uploadImageToTexture(i._texture,h,Y,0)}v()}}))}async function L(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:v;const S=h.getEngine();h.format=5,h.type=0,h.generateMipMaps=!0,h._cachedAnisotropicFilteringLevel=null,S.updateTextureSamplingMode(3,h),await X(h,V,!0,i),h.isReady=!0}async function U(h,V,i){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const Y=h.getEngine(),g=new q.c(Y,5),J=new B.e(Y,g);h._irradianceTexture=J,J._dominantDirection=l,g.isCube=!0,g.format=5,g.type=0,g.generateMipMaps=!0,g._cachedAnisotropicFilteringLevel=null,g.generateMipMaps=!0,g.width=i,g.height=i,Y.updateTextureSamplingMode(3,g),await X(g,[V],!1,S),Y.generateMipMapsForCubemap(g),g.isReady=!0}async function X(h,V,l){let g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v;if(!S.Tools.IsExponentOfTwo(h.width))throw new Error("Texture size must be a power of two");const I=(0,Y.ILog2)(h.width)+1,s=h.getEngine();let t=!1,T=!1,e=null,n=null,c=null;const f=s.getCaps();f.textureLOD?s._features.supportRenderAndCopyToLodForFloatTextures?f.textureHalfFloatRender&&f.textureHalfFloatLinearFiltering?(t=!0,h.type=2):f.textureFloatRender&&f.textureFloatLinearFiltering&&(t=!0,h.type=1):t=!1:(t=!1,T=l);let L=0;if(t)s.isWebGPU?(L=1,await i.e(42).then(i.bind(i,14167))):await i.e(35).then(i.bind(i,14175)),e=new J.d("rgbdDecode","rgbdDecode",null,null,1,null,3,s,!1,void 0,h.type,void 0,null,!1,void 0,L),h._isRGBD=!1,h.invertY=!1,n=s.createRenderTargetCubeTexture(h.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:h.type,format:5});else if(h._isRGBD=!0,h.invertY=!0,T){const V=3;c={};const i=h._lodGenerationScale,S=h._lodGenerationOffset;for(let l=0;l<V;l++){const Y=(I-1)*i+S,g=S+(Y-S)*(1-l/(V-1)),J=Math.round(Math.min(Math.max(g,0),Y)),v=new q.c(s,2);v.isCube=!0,v.invertY=!0,v.generateMipMaps=!1,s.updateTextureSamplingMode(2,v);const t=new B.e(null);switch(t._isCube=!0,t._texture=v,c[J]=t,l){case 0:h._lodTextureLow=t;break;case 1:h._lodTextureMid=t;break;case 2:h._lodTextureHigh=t}}}const U=[];for(let i=0;i<V.length;i++)for(let S=0;S<6;S++){const l=V[i][S],Y=new Blob([l],{type:g}),q=URL.createObjectURL(Y);let B;if(s._features.forceBitmapOverHTMLImageElement)B=s.createImageBitmap(Y,{premultiplyAlpha:"none"}).then((async V=>await P(V,s,t,e,q,S,i,T,c,n,h)));else{const V=new Image;V.src=q,B=new Promise(((l,Y)=>{V.onload=()=>{P(V,s,t,e,q,S,i,T,c,n,h).then((()=>l())).catch((h=>{Y(h)}))},V.onerror=h=>{Y(h)}}))}U.push(B)}if(await Promise.all(U),V.length<I){let i;const S=Math.pow(2,I-1-V.length),l=S*S*4;switch(h.type){case 0:i=new Uint8Array(l);break;case 2:i=new Uint16Array(l);break;case 1:i=new Float32Array(l)}for(let Y=V.length;Y<I;Y++)for(let V=0;V<6;V++){var X;s._uploadArrayBufferViewToTexture((null===(X=n)||void 0===X?void 0:X.texture)||h,i,V,Y)}}if(n){const V=h._irradianceTexture;h._irradianceTexture=null,s._releaseTexture(h),n._swapAndDie(h),h._irradianceTexture=V}e&&e.dispose(),T&&(h._lodTextureHigh&&h._lodTextureHigh._texture&&(h._lodTextureHigh._texture.isReady=!0),h._lodTextureMid&&h._lodTextureMid._texture&&(h._lodTextureMid._texture.isReady=!0),h._lodTextureLow&&h._lodTextureLow._texture&&(h._lodTextureLow._texture.isReady=!0))}function D(h,V){const i=(V=e(V)).irradiance;if(!i)return;const S=new g.e;l.nV.FromArrayToRef(i.x,0,S.x),l.nV.FromArrayToRef(i.y,0,S.y),l.nV.FromArrayToRef(i.z,0,S.z),l.nV.FromArrayToRef(i.xx,0,S.xx),l.nV.FromArrayToRef(i.yy,0,S.yy),l.nV.FromArrayToRef(i.zz,0,S.zz),l.nV.FromArrayToRef(i.yz,0,S.yz),l.nV.FromArrayToRef(i.zx,0,S.zx),l.nV.FromArrayToRef(i.xy,0,S.xy),h._sphericalPolynomial=S}function O(h,V,i,S,l){const Y=L(h.getEngine().createRawCubeTexture(null,h.width,h.format,h.type,h.generateMipMaps,h.invertY,h.samplingMode,h._compression),V).then((()=>h));return h.onRebuildCallback=h=>({proxy:Y,isReady:!0,isAsync:!0}),h._source=13,h._bufferViewArrayArray=V,h._lodGenerationScale=S,h._lodGenerationOffset=l,h._sphericalPolynomial=i,L(h,V).then((()=>(h.isReady=!0,h)))}}}]);