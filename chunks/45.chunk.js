"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[45],{14415:(Y,c,h)=>{h.d(c,{b:()=>p,c:()=>D,f:()=>Z,h:()=>a});var C=h(12687),E=h(12869),N=h(12883),Q=h(13068),b=h(12805),H=h(12890),w=(h(13110),h(12980)),W=h(12700);h(13370),h(13097),h(13386);const q="image/png",k=2,M=[134,22,135,150,246,214,150,54];function p(Y){const c=new DataView(Y.buffer,Y.byteOffset,Y.byteLength);let h=0;for(let Q=0;Q<M.length;Q++)if(c.getUint8(h++)!==M[Q])return W.e.Error("Not a babylon environment map"),null;let C="",E=0;for(;E=c.getUint8(h++);)C+=String.fromCharCode(E);let N=JSON.parse(C);return N=P(N),N.binaryDataPosition=h,N.Yk&&(N.Yk.lodGenerationScale=N.Yk.lodGenerationScale||.8),N}function P(Y){if(Y.version>k)throw new Error(`Unsupported babylon environment map version "${Y.version}". Latest supported version is "${k}".`);return 2===Y.version?Y:Y={...Y,version:2,imageType:q}}function y(Y,c){const h=(c=P(c)).Yk;let C=Math.log2(c.width);if(C=Math.round(C)+1,h.mipmaps.length!==6*C)throw new Error(`Unsupported specular mipmaps number "${h.mipmaps.length}"`);const E=new Array(C);for(let N=0;N<C;N++){E[N]=new Array(6);for(let C=0;C<6;C++){const Q=h.mipmaps[6*N+C];E[N][C]=new Uint8Array(Y.buffer,Y.byteOffset+c.binaryDataPosition+Q.position,Q.length)}}return E}function d(Y,c){var h;c=P(c);const C=new Array(6),E=null===(h=c.irradiance)||void 0===h?void 0:h.irradianceTexture;if(E){if(6!==E.faces.length)throw new Error(`Incorrect irradiance texture faces number "${E.faces.length}"`);for(let h=0;h<6;h++){const N=E.faces[h];C[h]=new Uint8Array(Y.buffer,Y.byteOffset+c.binaryDataPosition+N.position,N.length)}}return C}function D(Y,c,h){var C;const N=(h=P(h)).Yk;if(!N)return Promise.resolve([]);Y._lodGenerationScale=N.lodGenerationScale;const Q=[],b=y(c,h);Q.push(e(Y,b,h.imageType));const H=null===(C=h.irradiance)||void 0===C?void 0:C.irradianceTexture;if(H){var w,W;const C=d(c,h);let N=null;null!==(w=h.irradiance)&&void 0!==w&&null!==(W=w.irradianceTexture)&&void 0!==W&&W.dominantDirection&&(N=E.bh.dh(h.irradiance.irradianceTexture.dominantDirection)),Q.push(r(Y,C,H.size,h.imageType,N))}return Promise.all(Q)}async function T(Y,c,h,C,E,N,Q,b,H,w,W){return await new Promise(((q,k)=>{if(h){const h=c.createTexture(null,!0,!0,null,1,null,(Y=>{k(Y)}),Y);null===C||void 0===C||C.onEffectCreatedObservable.addOnce((b=>{b.executeWhenCompiled((()=>{C.externalTextureSamplerBinding=!0,C.onApply=C=>{C._bindTexture("textureSampler",h),C.setFloat2("scale",1,c._features.needsInvertingBitmap&&Y instanceof ImageBitmap?-1:1)},c.scenes.length&&(c.scenes[0].postProcessManager.directRender([C],w,!0,N,Q),c.restoreDefaultFramebuffer(),h.dispose(),URL.revokeObjectURL(E),q())}))}))}else{if(c._uploadImageToTexture(W,Y,N,Q),b){const h=H[Q];h&&c._uploadImageToTexture(h._texture,Y,N,0)}q()}}))}async function e(Y,c){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:q;const C=Y.getEngine();Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,C.updateTextureSamplingMode(3,Y),await X(Y,c,!0,h),Y.isReady=!0}async function r(Y,c,h){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q,E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const N=Y.getEngine(),Q=new b.c(N,5),w=new H.c(N,Q);Y._irradianceTexture=w,w._dominantDirection=E,Q.isCube=!0,Q.format=5,Q.type=0,Q.generateMipMaps=!0,Q._cachedAnisotropicFilteringLevel=null,Q.generateMipMaps=!0,Q.width=h,Q.height=h,N.updateTextureSamplingMode(3,Q),await X(Q,[c],!1,C),N.generateMipMapsForCubemap(Q),Q.isReady=!0}async function X(Y,c,E){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q;if(!C.Tools.IsExponentOfTwo(Y.width))throw new Error("Texture size must be a power of two");const W=(0,N.ILog2)(Y.width)+1,k=Y.getEngine();let M=!1,p=!1,P=null,y=null,d=null;const D=k.getCaps();D.textureLOD?k._features.supportRenderAndCopyToLodForFloatTextures?D.textureHalfFloatRender&&D.textureHalfFloatLinearFiltering?(M=!0,Y.type=2):D.textureFloatRender&&D.textureFloatLinearFiltering&&(M=!0,Y.type=1):M=!1:(M=!1,p=E);let e=0;if(M)k.isWebGPU?(e=1,await h.e(42).then(h.bind(h,16020))):await h.e(35).then(h.bind(h,16025)),P=new w.c("rgbdDecode","rgbdDecode",null,null,1,null,3,k,!1,void 0,Y.type,void 0,null,!1,void 0,e),Y._isRGBD=!1,Y.invertY=!1,y=k.createRenderTargetCubeTexture(Y.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:Y.type,format:5});else if(Y._isRGBD=!0,Y.invertY=!0,p){const c=3;d={};const h=Y._lodGenerationScale,C=Y._lodGenerationOffset;for(let E=0;E<c;E++){const N=(W-1)*h+C,Q=C+(N-C)*(1-E/(c-1)),w=Math.round(Math.min(Math.max(Q,0),N)),q=new b.c(k,2);q.isCube=!0,q.invertY=!0,q.generateMipMaps=!1,k.updateTextureSamplingMode(2,q);const M=new H.c(null);switch(M._isCube=!0,M._texture=q,d[w]=M,E){case 0:Y._lodTextureLow=M;break;case 1:Y._lodTextureMid=M;break;case 2:Y._lodTextureHigh=M}}}const r=[];for(let h=0;h<c.length;h++)for(let C=0;C<6;C++){const E=c[h][C],N=new Blob([E],{type:Q}),b=URL.createObjectURL(N);let H;if(k._features.forceBitmapOverHTMLImageElement)H=k.createImageBitmap(N,{premultiplyAlpha:"none"}).then((async c=>await T(c,k,M,P,b,C,h,p,d,y,Y)));else{const c=new Image;c.src=b,H=new Promise(((E,N)=>{c.onload=()=>{T(c,k,M,P,b,C,h,p,d,y,Y).then((()=>E())).catch((Y=>{N(Y)}))},c.onerror=Y=>{N(Y)}}))}r.push(H)}if(await Promise.all(r),c.length<W){let h;const C=Math.pow(2,W-1-c.length),E=C*C*4;switch(Y.type){case 0:h=new Uint8Array(E);break;case 2:h=new Uint16Array(E);break;case 1:h=new Float32Array(E)}for(let N=c.length;N<W;N++)for(let c=0;c<6;c++){var X;k._uploadArrayBufferViewToTexture((null===(X=y)||void 0===X?void 0:X.texture)||Y,h,c,N)}}if(y){const c=Y._irradianceTexture;Y._irradianceTexture=null,k._releaseTexture(Y),y._swapAndDie(Y),Y._irradianceTexture=c}P&&P.dispose(),p&&(Y._lodTextureHigh&&Y._lodTextureHigh._texture&&(Y._lodTextureHigh._texture.isReady=!0),Y._lodTextureMid&&Y._lodTextureMid._texture&&(Y._lodTextureMid._texture.isReady=!0),Y._lodTextureLow&&Y._lodTextureLow._texture&&(Y._lodTextureLow._texture.isReady=!0))}function Z(Y,c){const h=(c=P(c)).irradiance;if(!h)return;const C=new Q.f;E.bh.FromArrayToRef(h.x,0,C.x),E.bh.FromArrayToRef(h.y,0,C.y),E.bh.FromArrayToRef(h.z,0,C.z),E.bh.FromArrayToRef(h.xx,0,C.xx),E.bh.FromArrayToRef(h.yy,0,C.yy),E.bh.FromArrayToRef(h.zz,0,C.zz),E.bh.FromArrayToRef(h.yz,0,C.yz),E.bh.FromArrayToRef(h.zx,0,C.zx),E.bh.FromArrayToRef(h.xy,0,C.xy),Y._sphericalPolynomial=C}function a(Y,c,h,C,E){const N=e(Y.getEngine().createRawCubeTexture(null,Y.width,Y.format,Y.type,Y.generateMipMaps,Y.invertY,Y.samplingMode,Y._compression),c).then((()=>Y));return Y.onRebuildCallback=Y=>({proxy:N,isReady:!0,isAsync:!0}),Y._source=13,Y._bufferViewArrayArray=c,Y._lodGenerationScale=C,Y._lodGenerationOffset=E,Y._sphericalPolynomial=h,e(Y,c).then((()=>(Y.isReady=!0,Y)))}}}]);