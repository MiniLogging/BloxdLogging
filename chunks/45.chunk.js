"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[45],{13078:(n,y,H)=>{H.d(y,{b:()=>T,d:()=>l,e:()=>f,i:()=>c});var o=H(11094),G=H(11288),h=H(11303),k=H(11500),i=H(11230),B=H(11309),V=(H(11554),H(11399)),q=H(11114);H(11862),H(11542),H(11873);const b="image/png",A=2,U=[134,22,135,150,246,214,150,54];function T(n){const y=new DataView(n.buffer,n.byteOffset,n.byteLength);let H=0;for(let k=0;k<U.length;k++)if(y.getUint8(H++)!==U[k])return q.d.Error("Not a babylon environment map"),null;let o="",G=0;for(;G=y.getUint8(H++);)o+=String.fromCharCode(G);let h=JSON.parse(o);return h=W(h),h.binaryDataPosition=H,h.Uq&&(h.Uq.lodGenerationScale=h.Uq.lodGenerationScale||.8),h}function W(n){if(n.version>A)throw new Error(`Unsupported babylon environment map version "${n.version}". Latest supported version is "${A}".`);return 2===n.version?n:n={...n,version:2,imageType:b}}function z(n,y){const H=(y=W(y)).Uq;let o=Math.log2(y.width);if(o=Math.round(o)+1,H.mipmaps.length!==6*o)throw new Error(`Unsupported specular mipmaps number "${H.mipmaps.length}"`);const G=new Array(o);for(let h=0;h<o;h++){G[h]=new Array(6);for(let o=0;o<6;o++){const k=H.mipmaps[6*h+o];G[h][o]=new Uint8Array(n.buffer,n.byteOffset+y.binaryDataPosition+k.position,k.length)}}return G}function Q(n,y){var H;y=W(y);const o=new Array(6),G=null===(H=y.irradiance)||void 0===H?void 0:H.irradianceTexture;if(G){if(6!==G.faces.length)throw new Error(`Incorrect irradiance texture faces number "${G.faces.length}"`);for(let H=0;H<6;H++){const h=G.faces[H];o[H]=new Uint8Array(n.buffer,n.byteOffset+y.binaryDataPosition+h.position,h.length)}}return o}function l(n,y,H){var o;const h=(H=W(H)).Uq;if(!h)return Promise.resolve([]);n._lodGenerationScale=h.lodGenerationScale;const k=[],i=z(y,H);k.push(F(n,i,H.imageType));const B=null===(o=H.irradiance)||void 0===o?void 0:o.irradianceTexture;if(B){var V,q;const o=Q(y,H);let h=null;null!==(V=H.irradiance)&&void 0!==V&&null!==(q=V.irradianceTexture)&&void 0!==q&&q.dominantDirection&&(h=G.zy.gy(H.irradiance.irradianceTexture.dominantDirection)),k.push(g(n,o,B.size,H.imageType,h))}return Promise.all(k)}async function v(n,y,H,o,G,h,k,i,B,V,q){return await new Promise(((b,A)=>{if(H){const H=y.createTexture(null,!0,!0,null,1,null,(n=>{A(n)}),n);null===o||void 0===o||o.onEffectCreatedObservable.addOnce((i=>{i.executeWhenCompiled((()=>{o.externalTextureSamplerBinding=!0,o.onApply=o=>{o._bindTexture("textureSampler",H),o.setFloat2("scale",1,y._features.needsInvertingBitmap&&n instanceof ImageBitmap?-1:1)},y.scenes.length&&(y.scenes[0].postProcessManager.directRender([o],V,!0,h,k),y.restoreDefaultFramebuffer(),H.dispose(),URL.revokeObjectURL(G),b())}))}))}else{if(y._uploadImageToTexture(q,n,h,k),i){const H=B[k];H&&y._uploadImageToTexture(H._texture,n,h,0)}b()}}))}async function F(n,y){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:b;const o=n.getEngine();n.format=5,n.type=0,n.generateMipMaps=!0,n._cachedAnisotropicFilteringLevel=null,o.updateTextureSamplingMode(3,n),await M(n,y,!0,H),n.isReady=!0}async function g(n,y,H){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:b,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const h=n.getEngine(),k=new i.b(h,5),V=new B.d(h,k);n._irradianceTexture=V,V._dominantDirection=G,k.isCube=!0,k.format=5,k.type=0,k.generateMipMaps=!0,k._cachedAnisotropicFilteringLevel=null,k.generateMipMaps=!0,k.width=H,k.height=H,h.updateTextureSamplingMode(3,k),await M(k,[y],!1,o),h.generateMipMapsForCubemap(k),k.isReady=!0}async function M(n,y,G){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:b;if(!o.Tools.IsExponentOfTwo(n.width))throw new Error("Texture size must be a power of two");const q=(0,h.ILog2)(n.width)+1,A=n.getEngine();let U=!1,T=!1,W=null,z=null,Q=null;const l=A.getCaps();l.textureLOD?A._features.supportRenderAndCopyToLodForFloatTextures?l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?(U=!0,n.type=2):l.textureFloatRender&&l.textureFloatLinearFiltering&&(U=!0,n.type=1):U=!1:(U=!1,T=G);let F=0;if(U)A.isWebGPU?(F=1,await H.e(42).then(H.bind(H,14426))):await H.e(35).then(H.bind(H,14433)),W=new V.e("rgbdDecode","rgbdDecode",null,null,1,null,3,A,!1,void 0,n.type,void 0,null,!1,void 0,F),n._isRGBD=!1,n.invertY=!1,z=A.createRenderTargetCubeTexture(n.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:n.type,format:5});else if(n._isRGBD=!0,n.invertY=!0,T){const y=3;Q={};const H=n._lodGenerationScale,o=n._lodGenerationOffset;for(let G=0;G<y;G++){const h=(q-1)*H+o,k=o+(h-o)*(1-G/(y-1)),V=Math.round(Math.min(Math.max(k,0),h)),b=new i.b(A,2);b.isCube=!0,b.invertY=!0,b.generateMipMaps=!1,A.updateTextureSamplingMode(2,b);const U=new B.d(null);switch(U._isCube=!0,U._texture=b,Q[V]=U,G){case 0:n._lodTextureLow=U;break;case 1:n._lodTextureMid=U;break;case 2:n._lodTextureHigh=U}}}const g=[];for(let H=0;H<y.length;H++)for(let o=0;o<6;o++){const G=y[H][o],h=new Blob([G],{type:k}),i=URL.createObjectURL(h);let B;if(A._features.forceBitmapOverHTMLImageElement)B=A.createImageBitmap(h,{premultiplyAlpha:"none"}).then((async y=>await v(y,A,U,W,i,o,H,T,Q,z,n)));else{const y=new Image;y.src=i,B=new Promise(((G,h)=>{y.onload=()=>{v(y,A,U,W,i,o,H,T,Q,z,n).then((()=>G())).catch((n=>{h(n)}))},y.onerror=n=>{h(n)}}))}g.push(B)}if(await Promise.all(g),y.length<q){let H;const o=Math.pow(2,q-1-y.length),G=o*o*4;switch(n.type){case 0:H=new Uint8Array(G);break;case 2:H=new Uint16Array(G);break;case 1:H=new Float32Array(G)}for(let h=y.length;h<q;h++)for(let y=0;y<6;y++){var M;A._uploadArrayBufferViewToTexture((null===(M=z)||void 0===M?void 0:M.texture)||n,H,y,h)}}if(z){const y=n._irradianceTexture;n._irradianceTexture=null,A._releaseTexture(n),z._swapAndDie(n),n._irradianceTexture=y}W&&W.dispose(),T&&(n._lodTextureHigh&&n._lodTextureHigh._texture&&(n._lodTextureHigh._texture.isReady=!0),n._lodTextureMid&&n._lodTextureMid._texture&&(n._lodTextureMid._texture.isReady=!0),n._lodTextureLow&&n._lodTextureLow._texture&&(n._lodTextureLow._texture.isReady=!0))}function f(n,y){const H=(y=W(y)).irradiance;if(!H)return;const o=new k.f;G.zy.FromArrayToRef(H.x,0,o.x),G.zy.FromArrayToRef(H.y,0,o.y),G.zy.FromArrayToRef(H.z,0,o.z),G.zy.FromArrayToRef(H.xx,0,o.xx),G.zy.FromArrayToRef(H.yy,0,o.yy),G.zy.FromArrayToRef(H.zz,0,o.zz),G.zy.FromArrayToRef(H.yz,0,o.yz),G.zy.FromArrayToRef(H.zx,0,o.zx),G.zy.FromArrayToRef(H.xy,0,o.xy),n._sphericalPolynomial=o}function c(n,y,H,o,G){const h=F(n.getEngine().createRawCubeTexture(null,n.width,n.format,n.type,n.generateMipMaps,n.invertY,n.samplingMode,n._compression),y).then((()=>n));return n.onRebuildCallback=n=>({proxy:h,isReady:!0,isAsync:!0}),n._source=13,n._bufferViewArrayArray=y,n._lodGenerationScale=o,n._lodGenerationOffset=G,n._sphericalPolynomial=H,F(n,y).then((()=>(n.isReady=!0,n)))}}}]);