"use strict";(self.uw9p3pwwsje=self.uw9p3pwwsje||[]).push([[45],{14323:(D,h,o)=>{o.d(h,{e:()=>r,g:()=>q,j:()=>G,m:()=>N});var H=o(12642),g=o(12831),j=o(12842),M=o(13016),R=o(12771),t=o(12849),S=(o(13065),o(12923)),k=o(12658);o(13347),o(13046),o(13364);const K="image/png",Q=2,v=[134,22,135,150,246,214,150,54];function r(D){const h=new DataView(D.buffer,D.byteOffset,D.byteLength);let o=0;for(let M=0;M<v.length;M++)if(h.getUint8(o++)!==v[M])return k.d.Error("Not a babylon environment map"),null;let H="",g=0;for(;g=h.getUint8(o++);)H+=String.fromCharCode(g);let j=JSON.parse(H);return j=B(j),j.binaryDataPosition=o,j.MK&&(j.MK.lodGenerationScale=j.MK.lodGenerationScale||.8),j}function B(D){if(D.version>Q)throw new Error(`Unsupported babylon environment map version "${D.version}". Latest supported version is "${Q}".`);return 2===D.version?D:D={...D,version:2,imageType:K}}function s(D,h){const o=(h=B(h)).MK;let H=Math.log2(h.width);if(H=Math.round(H)+1,o.mipmaps.length!==6*H)throw new Error(`Unsupported specular mipmaps number "${o.mipmaps.length}"`);const g=new Array(H);for(let j=0;j<H;j++){g[j]=new Array(6);for(let H=0;H<6;H++){const M=o.mipmaps[6*j+H];g[j][H]=new Uint8Array(D.buffer,D.byteOffset+h.binaryDataPosition+M.position,M.length)}}return g}function U(D,h){var o;h=B(h);const H=new Array(6),g=null===(o=h.irradiance)||void 0===o?void 0:o.irradianceTexture;if(g){if(6!==g.faces.length)throw new Error(`Incorrect irradiance texture faces number "${g.faces.length}"`);for(let o=0;o<6;o++){const j=g.faces[o];H[o]=new Uint8Array(D.buffer,D.byteOffset+h.binaryDataPosition+j.position,j.length)}}return H}function q(D,h,o){var H;const j=(o=B(o)).MK;if(!j)return Promise.resolve([]);D._lodGenerationScale=j.lodGenerationScale;const M=[],R=s(h,o);M.push(y(D,R,o.imageType));const t=null===(H=o.irradiance)||void 0===H?void 0:H.irradianceTexture;if(t){var S,k;const H=U(h,o);let j=null;null!==(S=o.irradiance)&&void 0!==S&&null!==(k=S.irradianceTexture)&&void 0!==k&&k.dominantDirection&&(j=g.Gh.Ih(o.irradiance.irradianceTexture.dominantDirection)),M.push(b(D,H,t.size,o.imageType,j))}return Promise.all(M)}async function c(D,h,o,H,g,j,M,R,t,S,k){return await new Promise(((K,Q)=>{if(o){const o=h.createTexture(null,!0,!0,null,1,null,(D=>{Q(D)}),D);null===H||void 0===H||H.onEffectCreatedObservable.addOnce((R=>{R.executeWhenCompiled((()=>{H.externalTextureSamplerBinding=!0,H.onApply=H=>{H._bindTexture("textureSampler",o),H.setFloat2("scale",1,h._features.needsInvertingBitmap&&D instanceof ImageBitmap?-1:1)},h.scenes.length&&(h.scenes[0].postProcessManager.directRender([H],S,!0,j,M),h.restoreDefaultFramebuffer(),o.dispose(),URL.revokeObjectURL(g),K())}))}))}else{if(h._uploadImageToTexture(k,D,j,M),R){const o=t[M];o&&h._uploadImageToTexture(o._texture,D,j,0)}K()}}))}async function y(D,h){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:K;const H=D.getEngine();D.format=5,D.type=0,D.generateMipMaps=!0,D._cachedAnisotropicFilteringLevel=null,H.updateTextureSamplingMode(3,D),await i(D,h,!0,o),D.isReady=!0}async function b(D,h,o){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K,g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const j=D.getEngine(),M=new R.c(j,5),S=new t.e(j,M);D._irradianceTexture=S,S._dominantDirection=g,M.isCube=!0,M.format=5,M.type=0,M.generateMipMaps=!0,M._cachedAnisotropicFilteringLevel=null,M.generateMipMaps=!0,M.width=o,M.height=o,j.updateTextureSamplingMode(3,M),await i(M,[h],!1,H),j.generateMipMapsForCubemap(M),M.isReady=!0}async function i(D,h,g){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:K;if(!H.Tools.IsExponentOfTwo(D.width))throw new Error("Texture size must be a power of two");const k=(0,j.ILog2)(D.width)+1,Q=D.getEngine();let v=!1,r=!1,B=null,s=null,U=null;const q=Q.getCaps();q.textureLOD?Q._features.supportRenderAndCopyToLodForFloatTextures?q.textureHalfFloatRender&&q.textureHalfFloatLinearFiltering?(v=!0,D.type=2):q.textureFloatRender&&q.textureFloatLinearFiltering&&(v=!0,D.type=1):v=!1:(v=!1,r=g);let y=0;if(v)Q.isWebGPU?(y=1,await o.e(42).then(o.bind(o,15723))):await o.e(35).then(o.bind(o,15730)),B=new S.e("rgbdDecode","rgbdDecode",null,null,1,null,3,Q,!1,void 0,D.type,void 0,null,!1,void 0,y),D._isRGBD=!1,D.invertY=!1,s=Q.createRenderTargetCubeTexture(D.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:D.type,format:5});else if(D._isRGBD=!0,D.invertY=!0,r){const h=3;U={};const o=D._lodGenerationScale,H=D._lodGenerationOffset;for(let g=0;g<h;g++){const j=(k-1)*o+H,M=H+(j-H)*(1-g/(h-1)),S=Math.round(Math.min(Math.max(M,0),j)),K=new R.c(Q,2);K.isCube=!0,K.invertY=!0,K.generateMipMaps=!1,Q.updateTextureSamplingMode(2,K);const v=new t.e(null);switch(v._isCube=!0,v._texture=K,U[S]=v,g){case 0:D._lodTextureLow=v;break;case 1:D._lodTextureMid=v;break;case 2:D._lodTextureHigh=v}}}const b=[];for(let o=0;o<h.length;o++)for(let H=0;H<6;H++){const g=h[o][H],j=new Blob([g],{type:M}),R=URL.createObjectURL(j);let t;if(Q._features.forceBitmapOverHTMLImageElement)t=Q.createImageBitmap(j,{premultiplyAlpha:"none"}).then((async h=>await c(h,Q,v,B,R,H,o,r,U,s,D)));else{const h=new Image;h.src=R,t=new Promise(((g,j)=>{h.onload=()=>{c(h,Q,v,B,R,H,o,r,U,s,D).then((()=>g())).catch((D=>{j(D)}))},h.onerror=D=>{j(D)}}))}b.push(t)}if(await Promise.all(b),h.length<k){let o;const H=Math.pow(2,k-1-h.length),g=H*H*4;switch(D.type){case 0:o=new Uint8Array(g);break;case 2:o=new Uint16Array(g);break;case 1:o=new Float32Array(g)}for(let j=h.length;j<k;j++)for(let h=0;h<6;h++){var i;Q._uploadArrayBufferViewToTexture((null===(i=s)||void 0===i?void 0:i.texture)||D,o,h,j)}}if(s){const h=D._irradianceTexture;D._irradianceTexture=null,Q._releaseTexture(D),s._swapAndDie(D),D._irradianceTexture=h}B&&B.dispose(),r&&(D._lodTextureHigh&&D._lodTextureHigh._texture&&(D._lodTextureHigh._texture.isReady=!0),D._lodTextureMid&&D._lodTextureMid._texture&&(D._lodTextureMid._texture.isReady=!0),D._lodTextureLow&&D._lodTextureLow._texture&&(D._lodTextureLow._texture.isReady=!0))}function G(D,h){const o=(h=B(h)).irradiance;if(!o)return;const H=new M.g;g.Gh.FromArrayToRef(o.x,0,H.x),g.Gh.FromArrayToRef(o.y,0,H.y),g.Gh.FromArrayToRef(o.z,0,H.z),g.Gh.FromArrayToRef(o.xx,0,H.xx),g.Gh.FromArrayToRef(o.yy,0,H.yy),g.Gh.FromArrayToRef(o.zz,0,H.zz),g.Gh.FromArrayToRef(o.yz,0,H.yz),g.Gh.FromArrayToRef(o.zx,0,H.zx),g.Gh.FromArrayToRef(o.xy,0,H.xy),D._sphericalPolynomial=H}function N(D,h,o,H,g){const j=y(D.getEngine().createRawCubeTexture(null,D.width,D.format,D.type,D.generateMipMaps,D.invertY,D.samplingMode,D._compression),h).then((()=>D));return D.onRebuildCallback=D=>({proxy:j,isReady:!0,isAsync:!0}),D._source=13,D._bufferViewArrayArray=h,D._lodGenerationScale=H,D._lodGenerationOffset=g,D._sphericalPolynomial=o,y(D,h).then((()=>(D.isReady=!0,D)))}}}]);