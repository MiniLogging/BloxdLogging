"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[45],{13055:(B,E,v)=>{v.d(E,{b:()=>G,e:()=>g,g:()=>r,k:()=>i});var z=v(11193),o=v(11380),q=v(11394),c=v(11552),S=v(11323),x=v(11401),D=(v(11601),v(11463)),h=v(11213);v(11888),v(11589),v(11898);const y="image/png",Q=2,P=[134,22,135,150,246,214,150,54];function G(B){const E=new DataView(B.buffer,B.byteOffset,B.byteLength);let v=0;for(let c=0;c<P.length;c++)if(E.getUint8(v++)!==P[c])return h.c.Error("Not a babylon environment map"),null;let z="",o=0;for(;o=E.getUint8(v++);)z+=String.fromCharCode(o);let q=JSON.parse(z);return q=Y(q),q.binaryDataPosition=v,q.eh&&(q.eh.lodGenerationScale=q.eh.lodGenerationScale||.8),q}function Y(B){if(B.version>Q)throw new Error(`Unsupported babylon environment map version "${B.version}". Latest supported version is "${Q}".`);return 2===B.version?B:B={...B,version:2,imageType:y}}function a(B,E){const v=(E=Y(E)).eh;let z=Math.log2(E.width);if(z=Math.round(z)+1,v.mipmaps.length!==6*z)throw new Error(`Unsupported specular mipmaps number "${v.mipmaps.length}"`);const o=new Array(z);for(let q=0;q<z;q++){o[q]=new Array(6);for(let z=0;z<6;z++){const c=v.mipmaps[6*q+z];o[q][z]=new Uint8Array(B.buffer,B.byteOffset+E.binaryDataPosition+c.position,c.length)}}return o}function m(B,E){var v;E=Y(E);const z=new Array(6),o=null===(v=E.irradiance)||void 0===v?void 0:v.irradianceTexture;if(o){if(6!==o.faces.length)throw new Error(`Incorrect irradiance texture faces number "${o.faces.length}"`);for(let v=0;v<6;v++){const q=o.faces[v];z[v]=new Uint8Array(B.buffer,B.byteOffset+E.binaryDataPosition+q.position,q.length)}}return z}function g(B,E,v){var z;const q=(v=Y(v)).eh;if(!q)return Promise.resolve([]);B._lodGenerationScale=q.lodGenerationScale;const c=[],S=a(E,v);c.push(T(B,S,v.imageType));const x=null===(z=v.irradiance)||void 0===z?void 0:z.irradianceTexture;if(x){var D,h;const z=m(E,v);let q=null;null!==(D=v.irradiance)&&void 0!==D&&null!==(h=D.irradianceTexture)&&void 0!==h&&h.dominantDirection&&(q=o.GE.VE(v.irradiance.irradianceTexture.dominantDirection)),c.push(N(B,z,x.size,v.imageType,q))}return Promise.all(c)}async function V(B,E,v,z,o,q,c,S,x,D,h){return await new Promise(((y,Q)=>{if(v){const v=E.createTexture(null,!0,!0,null,1,null,(B=>{Q(B)}),B);null===z||void 0===z||z.onEffectCreatedObservable.addOnce((S=>{S.executeWhenCompiled((()=>{z.externalTextureSamplerBinding=!0,z.onApply=z=>{z._bindTexture("textureSampler",v),z.setFloat2("scale",1,E._features.needsInvertingBitmap&&B instanceof ImageBitmap?-1:1)},E.scenes.length&&(E.scenes[0].postProcessManager.directRender([z],D,!0,q,c),E.restoreDefaultFramebuffer(),v.dispose(),URL.revokeObjectURL(o),y())}))}))}else{if(E._uploadImageToTexture(h,B,q,c),S){const v=x[c];v&&E._uploadImageToTexture(v._texture,B,q,0)}y()}}))}async function T(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:y;const z=B.getEngine();B.format=5,B.type=0,B.generateMipMaps=!0,B._cachedAnisotropicFilteringLevel=null,z.updateTextureSamplingMode(3,B),await X(B,E,!0,v),B.isReady=!0}async function N(B,E,v){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const q=B.getEngine(),c=new S.b(q,5),D=new x.d(q,c);B._irradianceTexture=D,D._dominantDirection=o,c.isCube=!0,c.format=5,c.type=0,c.generateMipMaps=!0,c._cachedAnisotropicFilteringLevel=null,c.generateMipMaps=!0,c.width=v,c.height=v,q.updateTextureSamplingMode(3,c),await X(c,[E],!1,z),q.generateMipMapsForCubemap(c),c.isReady=!0}async function X(B,E,o){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y;if(!z.Tools.IsExponentOfTwo(B.width))throw new Error("Texture size must be a power of two");const h=(0,q.ILog2)(B.width)+1,Q=B.getEngine();let P=!1,G=!1,Y=null,a=null,m=null;const g=Q.getCaps();g.textureLOD?Q._features.supportRenderAndCopyToLodForFloatTextures?g.textureHalfFloatRender&&g.textureHalfFloatLinearFiltering?(P=!0,B.type=2):g.textureFloatRender&&g.textureFloatLinearFiltering&&(P=!0,B.type=1):P=!1:(P=!1,G=o);let T=0;if(P)Q.isWebGPU?(T=1,await v.e(42).then(v.bind(v,14375))):await v.e(35).then(v.bind(v,14379)),Y=new D.c("rgbdDecode","rgbdDecode",null,null,1,null,3,Q,!1,void 0,B.type,void 0,null,!1,void 0,T),B._isRGBD=!1,B.invertY=!1,a=Q.createRenderTargetCubeTexture(B.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:B.type,format:5});else if(B._isRGBD=!0,B.invertY=!0,G){const E=3;m={};const v=B._lodGenerationScale,z=B._lodGenerationOffset;for(let o=0;o<E;o++){const q=(h-1)*v+z,c=z+(q-z)*(1-o/(E-1)),D=Math.round(Math.min(Math.max(c,0),q)),y=new S.b(Q,2);y.isCube=!0,y.invertY=!0,y.generateMipMaps=!1,Q.updateTextureSamplingMode(2,y);const P=new x.d(null);switch(P._isCube=!0,P._texture=y,m[D]=P,o){case 0:B._lodTextureLow=P;break;case 1:B._lodTextureMid=P;break;case 2:B._lodTextureHigh=P}}}const N=[];for(let v=0;v<E.length;v++)for(let z=0;z<6;z++){const o=E[v][z],q=new Blob([o],{type:c}),S=URL.createObjectURL(q);let x;if(Q._features.forceBitmapOverHTMLImageElement)x=Q.createImageBitmap(q,{premultiplyAlpha:"none"}).then((async E=>await V(E,Q,P,Y,S,z,v,G,m,a,B)));else{const E=new Image;E.src=S,x=new Promise(((o,q)=>{E.onload=()=>{V(E,Q,P,Y,S,z,v,G,m,a,B).then((()=>o())).catch((B=>{q(B)}))},E.onerror=B=>{q(B)}}))}N.push(x)}if(await Promise.all(N),E.length<h){let v;const z=Math.pow(2,h-1-E.length),o=z*z*4;switch(B.type){case 0:v=new Uint8Array(o);break;case 2:v=new Uint16Array(o);break;case 1:v=new Float32Array(o)}for(let q=E.length;q<h;q++)for(let E=0;E<6;E++){var X;Q._uploadArrayBufferViewToTexture((null===(X=a)||void 0===X?void 0:X.texture)||B,v,E,q)}}if(a){const E=B._irradianceTexture;B._irradianceTexture=null,Q._releaseTexture(B),a._swapAndDie(B),B._irradianceTexture=E}Y&&Y.dispose(),G&&(B._lodTextureHigh&&B._lodTextureHigh._texture&&(B._lodTextureHigh._texture.isReady=!0),B._lodTextureMid&&B._lodTextureMid._texture&&(B._lodTextureMid._texture.isReady=!0),B._lodTextureLow&&B._lodTextureLow._texture&&(B._lodTextureLow._texture.isReady=!0))}function r(B,E){const v=(E=Y(E)).irradiance;if(!v)return;const z=new c.g;o.GE.FromArrayToRef(v.x,0,z.x),o.GE.FromArrayToRef(v.y,0,z.y),o.GE.FromArrayToRef(v.z,0,z.z),o.GE.FromArrayToRef(v.xx,0,z.xx),o.GE.FromArrayToRef(v.yy,0,z.yy),o.GE.FromArrayToRef(v.zz,0,z.zz),o.GE.FromArrayToRef(v.yz,0,z.yz),o.GE.FromArrayToRef(v.zx,0,z.zx),o.GE.FromArrayToRef(v.xy,0,z.xy),B._sphericalPolynomial=z}function i(B,E,v,z,o){const q=T(B.getEngine().createRawCubeTexture(null,B.width,B.format,B.type,B.generateMipMaps,B.invertY,B.samplingMode,B._compression),E).then((()=>B));return B.onRebuildCallback=B=>({proxy:q,isReady:!0,isAsync:!0}),B._source=13,B._bufferViewArrayArray=E,B._lodGenerationScale=z,B._lodGenerationOffset=o,B._sphericalPolynomial=v,T(B,E).then((()=>(B.isReady=!0,B)))}}}]);