"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[45],{14008:(E,U,g)=>{g.d(U,{e:()=>d,f:()=>V,i:()=>t,l:()=>G});var N=g(12165),L=g(12334),D=g(12353),S=g(12527),u=g(12273),s=g(12355),C=(g(12573),g(12430)),B=g(12186);g(12834),g(12554),g(12844);const P="image/png",F=2,f=[134,22,135,150,246,214,150,54];function d(E){const U=new DataView(E.buffer,E.byteOffset,E.byteLength);let g=0;for(let S=0;S<f.length;S++)if(U.getUint8(g++)!==f[S])return B.d.Error("Not a babylon environment map"),null;let N="",L=0;for(;L=U.getUint8(g++);)N+=String.fromCharCode(L);let D=JSON.parse(N);return D=I(D),D.binaryDataPosition=g,D.uB&&(D.uB.lodGenerationScale=D.uB.lodGenerationScale||.8),D}function I(E){if(E.version>F)throw new Error(`Unsupported babylon environment map version "${E.version}". Latest supported version is "${F}".`);return 2===E.version?E:E={...E,version:2,imageType:P}}function y(E,U){const g=(U=I(U)).uB;let N=Math.log2(U.width);if(N=Math.round(N)+1,g.mipmaps.length!==6*N)throw new Error(`Unsupported specular mipmaps number "${g.mipmaps.length}"`);const L=new Array(N);for(let D=0;D<N;D++){L[D]=new Array(6);for(let N=0;N<6;N++){const S=g.mipmaps[6*D+N];L[D][N]=new Uint8Array(E.buffer,E.byteOffset+U.binaryDataPosition+S.position,S.length)}}return L}function h(E,U){var g;U=I(U);const N=new Array(6),L=null===(g=U.irradiance)||void 0===g?void 0:g.irradianceTexture;if(L){if(6!==L.faces.length)throw new Error(`Incorrect irradiance texture faces number "${L.faces.length}"`);for(let g=0;g<6;g++){const D=L.faces[g];N[g]=new Uint8Array(E.buffer,E.byteOffset+U.binaryDataPosition+D.position,D.length)}}return N}function V(E,U,g){var N;const D=(g=I(g)).uB;if(!D)return Promise.resolve([]);E._lodGenerationScale=D.lodGenerationScale;const S=[],u=y(U,g);S.push(x(E,u,g.imageType));const s=null===(N=g.irradiance)||void 0===N?void 0:N.irradianceTexture;if(s){var C,B;const N=h(U,g);let D=null;null!==(C=g.irradiance)&&void 0!==C&&null!==(B=C.irradianceTexture)&&void 0!==B&&B.dominantDirection&&(D=L.dU.eU(g.irradiance.irradianceTexture.dominantDirection)),S.push(l(E,N,s.size,g.imageType,D))}return Promise.all(S)}async function e(E,U,g,N,L,D,S,u,s,C,B){return await new Promise(((P,F)=>{if(g){const g=U.createTexture(null,!0,!0,null,1,null,(E=>{F(E)}),E);null===N||void 0===N||N.onEffectCreatedObservable.addOnce((u=>{u.executeWhenCompiled((()=>{N.externalTextureSamplerBinding=!0,N.onApply=N=>{N._bindTexture("textureSampler",g),N.setFloat2("scale",1,U._features.needsInvertingBitmap&&E instanceof ImageBitmap?-1:1)},U.scenes.length&&(U.scenes[0].postProcessManager.directRender([N],C,!0,D,S),U.restoreDefaultFramebuffer(),g.dispose(),URL.revokeObjectURL(L),P())}))}))}else{if(U._uploadImageToTexture(B,E,D,S),u){const g=s[S];g&&U._uploadImageToTexture(g._texture,E,D,0)}P()}}))}async function x(E,U){let g=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P;const N=E.getEngine();E.format=5,E.type=0,E.generateMipMaps=!0,E._cachedAnisotropicFilteringLevel=null,N.updateTextureSamplingMode(3,E),await Y(E,U,!0,g),E.isReady=!0}async function l(E,U,g){let N=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const D=E.getEngine(),S=new u.c(D,5),C=new s.d(D,S);E._irradianceTexture=C,C._dominantDirection=L,S.isCube=!0,S.format=5,S.type=0,S.generateMipMaps=!0,S._cachedAnisotropicFilteringLevel=null,S.generateMipMaps=!0,S.width=g,S.height=g,D.updateTextureSamplingMode(3,S),await Y(S,[U],!1,N),D.generateMipMapsForCubemap(S),S.isReady=!0}async function Y(E,U,L){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P;if(!N.Tools.IsExponentOfTwo(E.width))throw new Error("Texture size must be a power of two");const B=(0,D.ILog2)(E.width)+1,F=E.getEngine();let f=!1,d=!1,I=null,y=null,h=null;const V=F.getCaps();V.textureLOD?F._features.supportRenderAndCopyToLodForFloatTextures?V.textureHalfFloatRender&&V.textureHalfFloatLinearFiltering?(f=!0,E.type=2):V.textureFloatRender&&V.textureFloatLinearFiltering&&(f=!0,E.type=1):f=!1:(f=!1,d=L);let x=0;if(f)F.isWebGPU?(x=1,await g.e(42).then(g.bind(g,15402))):await g.e(35).then(g.bind(g,15411)),I=new C.e("rgbdDecode","rgbdDecode",null,null,1,null,3,F,!1,void 0,E.type,void 0,null,!1,void 0,x),E._isRGBD=!1,E.invertY=!1,y=F.createRenderTargetCubeTexture(E.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:E.type,format:5});else if(E._isRGBD=!0,E.invertY=!0,d){const U=3;h={};const g=E._lodGenerationScale,N=E._lodGenerationOffset;for(let L=0;L<U;L++){const D=(B-1)*g+N,S=N+(D-N)*(1-L/(U-1)),C=Math.round(Math.min(Math.max(S,0),D)),P=new u.c(F,2);P.isCube=!0,P.invertY=!0,P.generateMipMaps=!1,F.updateTextureSamplingMode(2,P);const f=new s.d(null);switch(f._isCube=!0,f._texture=P,h[C]=f,L){case 0:E._lodTextureLow=f;break;case 1:E._lodTextureMid=f;break;case 2:E._lodTextureHigh=f}}}const l=[];for(let g=0;g<U.length;g++)for(let N=0;N<6;N++){const L=U[g][N],D=new Blob([L],{type:S}),u=URL.createObjectURL(D);let s;if(F._features.forceBitmapOverHTMLImageElement)s=F.createImageBitmap(D,{premultiplyAlpha:"none"}).then((async U=>await e(U,F,f,I,u,N,g,d,h,y,E)));else{const U=new Image;U.src=u,s=new Promise(((L,D)=>{U.onload=()=>{e(U,F,f,I,u,N,g,d,h,y,E).then((()=>L())).catch((E=>{D(E)}))},U.onerror=E=>{D(E)}}))}l.push(s)}if(await Promise.all(l),U.length<B){let g;const N=Math.pow(2,B-1-U.length),L=N*N*4;switch(E.type){case 0:g=new Uint8Array(L);break;case 2:g=new Uint16Array(L);break;case 1:g=new Float32Array(L)}for(let D=U.length;D<B;D++)for(let U=0;U<6;U++){var Y;F._uploadArrayBufferViewToTexture((null===(Y=y)||void 0===Y?void 0:Y.texture)||E,g,U,D)}}if(y){const U=E._irradianceTexture;E._irradianceTexture=null,F._releaseTexture(E),y._swapAndDie(E),E._irradianceTexture=U}I&&I.dispose(),d&&(E._lodTextureHigh&&E._lodTextureHigh._texture&&(E._lodTextureHigh._texture.isReady=!0),E._lodTextureMid&&E._lodTextureMid._texture&&(E._lodTextureMid._texture.isReady=!0),E._lodTextureLow&&E._lodTextureLow._texture&&(E._lodTextureLow._texture.isReady=!0))}function t(E,U){const g=(U=I(U)).irradiance;if(!g)return;const N=new S.f;L.dU.FromArrayToRef(g.x,0,N.x),L.dU.FromArrayToRef(g.y,0,N.y),L.dU.FromArrayToRef(g.z,0,N.z),L.dU.FromArrayToRef(g.xx,0,N.xx),L.dU.FromArrayToRef(g.yy,0,N.yy),L.dU.FromArrayToRef(g.zz,0,N.zz),L.dU.FromArrayToRef(g.yz,0,N.yz),L.dU.FromArrayToRef(g.zx,0,N.zx),L.dU.FromArrayToRef(g.xy,0,N.xy),E._sphericalPolynomial=N}function G(E,U,g,N,L){const D=x(E.getEngine().createRawCubeTexture(null,E.width,E.format,E.type,E.generateMipMaps,E.invertY,E.samplingMode,E._compression),U).then((()=>E));return E.onRebuildCallback=E=>({proxy:D,isReady:!0,isAsync:!0}),E._source=13,E._bufferViewArrayArray=U,E._lodGenerationScale=N,E._lodGenerationOffset=L,E._sphericalPolynomial=g,x(E,U).then((()=>(E.isReady=!0,E)))}}}]);