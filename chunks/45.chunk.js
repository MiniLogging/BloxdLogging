"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[45],{14193:(M,A,O)=>{O.d(A,{c:()=>G,d:()=>b,g:()=>C,j:()=>f});var S=O(22),z=O(12768),Q=O(12970),X=O(12980),c=O(13177),j=O(12888),B=O(12986),g=(O(13214),O(13084)),e=O(12783);O(13480),O(13196),O(13489);const T="image/png",J=2,K=[134,22,135,150,246,214,150,54];function G(M){const A=new DataView(M.buffer,M.byteOffset,M.byteLength);let O=0;for(let X=0;X<K.length;X++)if(A.getUint8(O++)!==K[X])return e.c.Error("Not a babylon environment map"),null;let S="",z=0;for(;z=A.getUint8(O++);)S+=String.fromCharCode(z);let Q=JSON.parse(S);return Q=d(Q),Q.binaryDataPosition=O,Q.se&&(Q.se.lodGenerationScale=Q.se.lodGenerationScale||.8),Q}function d(M){if(M.version>J)throw new Error('Unsupported babylon environment map version "'.concat(M.version,'". Latest supported version is "').concat(J,'".'));return 2===M.version?M:M=(0,S.d)((0,S.d)({},M),{},{version:2,imageType:T})}function w(M,A){const O=(A=d(A)).se;let S=Math.log2(A.width);if(S=Math.round(S)+1,O.mipmaps.length!==6*S)throw new Error('Unsupported specular mipmaps number "'.concat(O.mipmaps.length,'"'));const z=new Array(S);for(let Q=0;Q<S;Q++){z[Q]=new Array(6);for(let S=0;S<6;S++){const X=O.mipmaps[6*Q+S];z[Q][S]=new Uint8Array(M.buffer,M.byteOffset+A.binaryDataPosition+X.position,X.length)}}return z}function I(M,A){var O;A=d(A);const S=new Array(6),z=null===(O=A.irradiance)||void 0===O?void 0:O.irradianceTexture;if(z){if(6!==z.faces.length)throw new Error('Incorrect irradiance texture faces number "'.concat(z.faces.length,'"'));for(let O=0;O<6;O++){const Q=z.faces[O];S[O]=new Uint8Array(M.buffer,M.byteOffset+A.binaryDataPosition+Q.position,Q.length)}}return S}function b(M,A,O){var S;const z=(O=d(O)).se;if(!z)return Promise.resolve([]);M._lodGenerationScale=z.lodGenerationScale;const X=[],c=w(A,O);X.push(Y(M,c,O.imageType));const j=null===(S=O.irradiance)||void 0===S?void 0:S.irradianceTexture;if(j){var B,g;const S=I(A,O);let z=null;null!==(B=O.irradiance)&&void 0!==B&&null!==(g=B.irradianceTexture)&&void 0!==g&&g.dominantDirection&&(z=Q.GA.sA(O.irradiance.irradianceTexture.dominantDirection)),X.push(E(M,S,j.size,O.imageType,z))}return Promise.all(X)}async function s(M,A,O,S,z,Q,X,c,j,B,g){return await new Promise(((e,T)=>{if(O){const O=A.createTexture(null,!0,!0,null,1,null,(M=>{T(M)}),M);null===S||void 0===S||S.onEffectCreatedObservable.addOnce((c=>{c.executeWhenCompiled((()=>{S.externalTextureSamplerBinding=!0,S.onApply=S=>{S._bindTexture("textureSampler",O),S.setFloat2("scale",1,A._features.needsInvertingBitmap&&M instanceof ImageBitmap?-1:1)},A.scenes.length&&(A.scenes[0].postProcessManager.directRender([S],B,!0,Q,X),A.restoreDefaultFramebuffer(),O.dispose(),URL.revokeObjectURL(z),e())}))}))}else{if(A._uploadImageToTexture(g,M,Q,X),c){const O=j[X];O&&A._uploadImageToTexture(O._texture,M,Q,0)}e()}}))}async function Y(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:T;const S=M.getEngine();M.format=5,M.type=0,M.generateMipMaps=!0,M._cachedAnisotropicFilteringLevel=null,S.updateTextureSamplingMode(3,M),await H(M,A,!0,O),M.isReady=!0}async function E(M,A,O){let S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:T,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const Q=M.getEngine(),X=new j.b(Q,5),c=new B.d(Q,X);M._irradianceTexture=c,c._dominantDirection=z,X.isCube=!0,X.format=5,X.type=0,X.generateMipMaps=!0,X._cachedAnisotropicFilteringLevel=null,X.generateMipMaps=!0,X.width=O,X.height=O,Q.updateTextureSamplingMode(3,X),await H(X,[A],!1,S),Q.generateMipMapsForCubemap(X),X.isReady=!0}async function H(M,A,S){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:T;if(!z.Tools.IsExponentOfTwo(M.width))throw new Error("Texture size must be a power of two");const c=(0,X.ILog2)(M.width)+1,e=M.getEngine();let J=!1,K=!1,G=null,d=null,w=null;const I=e.getCaps();I.textureLOD?e._features.supportRenderAndCopyToLodForFloatTextures?I.textureHalfFloatRender&&I.textureHalfFloatLinearFiltering?(J=!0,M.type=2):I.textureFloatRender&&I.textureFloatLinearFiltering&&(J=!0,M.type=1):J=!1:(J=!1,K=S);let b=0;if(J)e.isWebGPU?(b=1,await O.e(42).then(O.bind(O,15634))):await O.e(35).then(O.bind(O,15638)),G=new g.c("rgbdDecode","rgbdDecode",null,null,1,null,3,e,!1,void 0,M.type,void 0,null,!1,void 0,b),M._isRGBD=!1,M.invertY=!1,d=e.createRenderTargetCubeTexture(M.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:M.type,format:5});else if(M._isRGBD=!0,M.invertY=!0,K){const A=3;w={};const O=M._lodGenerationScale,S=M._lodGenerationOffset;for(let z=0;z<A;z++){const Q=(c-1)*O+S,X=S+(Q-S)*(1-z/(A-1)),g=Math.round(Math.min(Math.max(X,0),Q)),T=new j.b(e,2);T.isCube=!0,T.invertY=!0,T.generateMipMaps=!1,e.updateTextureSamplingMode(2,T);const J=new B.d(null);switch(J._isCube=!0,J._texture=T,w[g]=J,z){case 0:M._lodTextureLow=J;break;case 1:M._lodTextureMid=J;break;case 2:M._lodTextureHigh=J}}}const Y=[];for(let O=0;O<A.length;O++)for(let S=0;S<6;S++){const z=A[O][S],X=new Blob([z],{type:Q}),c=URL.createObjectURL(X);let j;if(e._features.forceBitmapOverHTMLImageElement)j=e.createImageBitmap(X,{premultiplyAlpha:"none"}).then((async A=>await s(A,e,J,G,c,S,O,K,w,d,M)));else{const A=new Image;A.src=c,j=new Promise(((z,Q)=>{A.onload=()=>{s(A,e,J,G,c,S,O,K,w,d,M).then((()=>z())).catch((M=>{Q(M)}))},A.onerror=M=>{Q(M)}}))}Y.push(j)}if(await Promise.all(Y),A.length<c){let O;const S=Math.pow(2,c-1-A.length),z=S*S*4;switch(M.type){case 0:O=new Uint8Array(z);break;case 2:O=new Uint16Array(z);break;case 1:O=new Float32Array(z)}for(let Q=A.length;Q<c;Q++)for(let A=0;A<6;A++){var E;e._uploadArrayBufferViewToTexture((null===(E=d)||void 0===E?void 0:E.texture)||M,O,A,Q)}}if(d){const A=M._irradianceTexture;M._irradianceTexture=null,e._releaseTexture(M),d._swapAndDie(M),M._irradianceTexture=A}G&&G.dispose(),K&&(M._lodTextureHigh&&M._lodTextureHigh._texture&&(M._lodTextureHigh._texture.isReady=!0),M._lodTextureMid&&M._lodTextureMid._texture&&(M._lodTextureMid._texture.isReady=!0),M._lodTextureLow&&M._lodTextureLow._texture&&(M._lodTextureLow._texture.isReady=!0))}function C(M,A){const O=(A=d(A)).irradiance;if(!O)return;const S=new c.g;Q.GA.FromArrayToRef(O.x,0,S.x),Q.GA.FromArrayToRef(O.y,0,S.y),Q.GA.FromArrayToRef(O.z,0,S.z),Q.GA.FromArrayToRef(O.xx,0,S.xx),Q.GA.FromArrayToRef(O.yy,0,S.yy),Q.GA.FromArrayToRef(O.zz,0,S.zz),Q.GA.FromArrayToRef(O.yz,0,S.yz),Q.GA.FromArrayToRef(O.zx,0,S.zx),Q.GA.FromArrayToRef(O.xy,0,S.xy),M._sphericalPolynomial=S}function f(M,A,O,S,z){const Q=Y(M.getEngine().createRawCubeTexture(null,M.width,M.format,M.type,M.generateMipMaps,M.invertY,M.samplingMode,M._compression),A).then((()=>M));return M.onRebuildCallback=M=>({proxy:Q,isReady:!0,isAsync:!0}),M._source=13,M._bufferViewArrayArray=A,M._lodGenerationScale=S,M._lodGenerationOffset=z,M._sphericalPolynomial=O,Y(M,A).then((()=>(M.isReady=!0,M)))}}}]);