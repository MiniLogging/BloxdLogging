"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[45],{12827:(G,A,j)=>{j.d(A,{d:()=>U,f:()=>Y,g:()=>D,j:()=>g});var u=j(11043),k=j(11218),B=j(11237),x=j(11402),s=j(11156),O=j(11240),d=(j(11458),j(11313)),h=j(11065);j(11688),j(11441),j(11702);const H="image/png",F=2,R=[134,22,135,150,246,214,150,54];function U(G){const A=new DataView(G.buffer,G.byteOffset,G.byteLength);let j=0;for(let x=0;x<R.length;x++)if(A.getUint8(j++)!==R[x])return h.e.Error("Not a babylon environment map"),null;let u="",k=0;for(;k=A.getUint8(j++);)u+=String.fromCharCode(k);let B=JSON.parse(u);return B=S(B),B.binaryDataPosition=j,B.sH&&(B.sH.lodGenerationScale=B.sH.lodGenerationScale||.8),B}function S(G){if(G.version>F)throw new Error(`Unsupported babylon environment map version "${G.version}". Latest supported version is "${F}".`);return 2===G.version?G:G={...G,version:2,imageType:H}}function C(G,A){const j=(A=S(A)).sH;let u=Math.log2(A.width);if(u=Math.round(u)+1,j.mipmaps.length!==6*u)throw new Error(`Unsupported specular mipmaps number "${j.mipmaps.length}"`);const k=new Array(u);for(let B=0;B<u;B++){k[B]=new Array(6);for(let u=0;u<6;u++){const x=j.mipmaps[6*B+u];k[B][u]=new Uint8Array(G.buffer,G.byteOffset+A.binaryDataPosition+x.position,x.length)}}return k}function t(G,A){var j;A=S(A);const u=new Array(6),k=null===(j=A.irradiance)||void 0===j?void 0:j.irradianceTexture;if(k){if(6!==k.faces.length)throw new Error(`Incorrect irradiance texture faces number "${k.faces.length}"`);for(let j=0;j<6;j++){const B=k.faces[j];u[j]=new Uint8Array(G.buffer,G.byteOffset+A.binaryDataPosition+B.position,B.length)}}return u}function Y(G,A,j){var u;const B=(j=S(j)).sH;if(!B)return Promise.resolve([]);G._lodGenerationScale=B.lodGenerationScale;const x=[],s=C(A,j);x.push(Q(G,s,j.imageType));const O=null===(u=j.irradiance)||void 0===u?void 0:u.irradianceTexture;if(O){var d,h;const u=t(A,j);let B=null;null!==(d=j.irradiance)&&void 0!==d&&null!==(h=d.irradianceTexture)&&void 0!==h&&h.dominantDirection&&(B=k.SA.QA(j.irradiance.irradianceTexture.dominantDirection)),x.push(X(G,u,O.size,j.imageType,B))}return Promise.all(x)}async function n(G,A,j,u,k,B,x,s,O,d,h){return await new Promise(((H,F)=>{if(j){const j=A.createTexture(null,!0,!0,null,1,null,(G=>{F(G)}),G);null===u||void 0===u||u.onEffectCreatedObservable.addOnce((s=>{s.executeWhenCompiled((()=>{u.externalTextureSamplerBinding=!0,u.onApply=u=>{u._bindTexture("textureSampler",j),u.setFloat2("scale",1,A._features.needsInvertingBitmap&&G instanceof ImageBitmap?-1:1)},A.scenes.length&&(A.scenes[0].postProcessManager.directRender([u],d,!0,B,x),A.restoreDefaultFramebuffer(),j.dispose(),URL.revokeObjectURL(k),H())}))}))}else{if(A._uploadImageToTexture(h,G,B,x),s){const j=O[x];j&&A._uploadImageToTexture(j._texture,G,B,0)}H()}}))}async function Q(G,A){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:H;const u=G.getEngine();G.format=5,G.type=0,G.generateMipMaps=!0,G._cachedAnisotropicFilteringLevel=null,u.updateTextureSamplingMode(3,G),await I(G,A,!0,j),G.isReady=!0}async function X(G,A,j){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H,k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const B=G.getEngine(),x=new s.d(B,5),d=new O.b(B,x);G._irradianceTexture=d,d._dominantDirection=k,x.isCube=!0,x.format=5,x.type=0,x.generateMipMaps=!0,x._cachedAnisotropicFilteringLevel=null,x.generateMipMaps=!0,x.width=j,x.height=j,B.updateTextureSamplingMode(3,x),await I(x,[A],!1,u),B.generateMipMapsForCubemap(x),x.isReady=!0}async function I(G,A,k){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H;if(!u.Tools.IsExponentOfTwo(G.width))throw new Error("Texture size must be a power of two");const h=(0,B.ILog2)(G.width)+1,F=G.getEngine();let R=!1,U=!1,S=null,C=null,t=null;const Y=F.getCaps();Y.textureLOD?F._features.supportRenderAndCopyToLodForFloatTextures?Y.textureHalfFloatRender&&Y.textureHalfFloatLinearFiltering?(R=!0,G.type=2):Y.textureFloatRender&&Y.textureFloatLinearFiltering&&(R=!0,G.type=1):R=!1:(R=!1,U=k);let Q=0;if(R)F.isWebGPU?(Q=1,await j.e(42).then(j.bind(j,14247))):await j.e(35).then(j.bind(j,14249)),S=new d.e("rgbdDecode","rgbdDecode",null,null,1,null,3,F,!1,void 0,G.type,void 0,null,!1,void 0,Q),G._isRGBD=!1,G.invertY=!1,C=F.createRenderTargetCubeTexture(G.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:G.type,format:5});else if(G._isRGBD=!0,G.invertY=!0,U){const A=3;t={};const j=G._lodGenerationScale,u=G._lodGenerationOffset;for(let k=0;k<A;k++){const B=(h-1)*j+u,x=u+(B-u)*(1-k/(A-1)),d=Math.round(Math.min(Math.max(x,0),B)),H=new s.d(F,2);H.isCube=!0,H.invertY=!0,H.generateMipMaps=!1,F.updateTextureSamplingMode(2,H);const R=new O.b(null);switch(R._isCube=!0,R._texture=H,t[d]=R,k){case 0:G._lodTextureLow=R;break;case 1:G._lodTextureMid=R;break;case 2:G._lodTextureHigh=R}}}const X=[];for(let j=0;j<A.length;j++)for(let u=0;u<6;u++){const k=A[j][u],B=new Blob([k],{type:x}),s=URL.createObjectURL(B);let O;if(F._features.forceBitmapOverHTMLImageElement)O=F.createImageBitmap(B,{premultiplyAlpha:"none"}).then((async A=>await n(A,F,R,S,s,u,j,U,t,C,G)));else{const A=new Image;A.src=s,O=new Promise(((k,B)=>{A.onload=()=>{n(A,F,R,S,s,u,j,U,t,C,G).then((()=>k())).catch((G=>{B(G)}))},A.onerror=G=>{B(G)}}))}X.push(O)}if(await Promise.all(X),A.length<h){let j;const u=Math.pow(2,h-1-A.length),k=u*u*4;switch(G.type){case 0:j=new Uint8Array(k);break;case 2:j=new Uint16Array(k);break;case 1:j=new Float32Array(k)}for(let B=A.length;B<h;B++)for(let A=0;A<6;A++){var I;F._uploadArrayBufferViewToTexture((null===(I=C)||void 0===I?void 0:I.texture)||G,j,A,B)}}if(C){const A=G._irradianceTexture;G._irradianceTexture=null,F._releaseTexture(G),C._swapAndDie(G),G._irradianceTexture=A}S&&S.dispose(),U&&(G._lodTextureHigh&&G._lodTextureHigh._texture&&(G._lodTextureHigh._texture.isReady=!0),G._lodTextureMid&&G._lodTextureMid._texture&&(G._lodTextureMid._texture.isReady=!0),G._lodTextureLow&&G._lodTextureLow._texture&&(G._lodTextureLow._texture.isReady=!0))}function D(G,A){const j=(A=S(A)).irradiance;if(!j)return;const u=new x.h;k.SA.FromArrayToRef(j.x,0,u.x),k.SA.FromArrayToRef(j.y,0,u.y),k.SA.FromArrayToRef(j.z,0,u.z),k.SA.FromArrayToRef(j.xx,0,u.xx),k.SA.FromArrayToRef(j.yy,0,u.yy),k.SA.FromArrayToRef(j.zz,0,u.zz),k.SA.FromArrayToRef(j.yz,0,u.yz),k.SA.FromArrayToRef(j.zx,0,u.zx),k.SA.FromArrayToRef(j.xy,0,u.xy),G._sphericalPolynomial=u}function g(G,A,j,u,k){const B=Q(G.getEngine().createRawCubeTexture(null,G.width,G.format,G.type,G.generateMipMaps,G.invertY,G.samplingMode,G._compression),A).then((()=>G));return G.onRebuildCallback=G=>({proxy:B,isReady:!0,isAsync:!0}),G._source=13,G._bufferViewArrayArray=A,G._lodGenerationScale=u,G._lodGenerationOffset=k,G._sphericalPolynomial=j,Q(G,A).then((()=>(G.isReady=!0,G)))}}}]);