"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[45],{14451:(I,x,L)=>{L.d(x,{e:()=>v,h:()=>U,j:()=>t,l:()=>f});var F=L(12791),X=L(12983),G=L(13001),Y=L(13171),p=L(12909),B=L(13004),l=(L(13218),L(13081)),W=L(12809);L(13476),L(13202),L(13484);const Q="image/png",e=2,g=[134,22,135,150,246,214,150,54];function v(I){const x=new DataView(I.buffer,I.byteOffset,I.byteLength);let L=0;for(let Y=0;Y<g.length;Y++)if(x.getUint8(L++)!==g[Y])return W.c.Error("Not a babylon environment map"),null;let F="",X=0;for(;X=x.getUint8(L++);)F+=String.fromCharCode(X);let G=JSON.parse(F);return G=z(G),G.binaryDataPosition=L,G.IQ&&(G.IQ.lodGenerationScale=G.IQ.lodGenerationScale||.8),G}function z(I){if(I.version>e)throw new Error(`Unsupported babylon environment map version "${I.version}". Latest supported version is "${e}".`);return 2===I.version?I:I={...I,version:2,imageType:Q}}function H(I,x){const L=(x=z(x)).IQ;let F=Math.log2(x.width);if(F=Math.round(F)+1,L.mipmaps.length!==6*F)throw new Error(`Unsupported specular mipmaps number "${L.mipmaps.length}"`);const X=new Array(F);for(let G=0;G<F;G++){X[G]=new Array(6);for(let F=0;F<6;F++){const Y=L.mipmaps[6*G+F];X[G][F]=new Uint8Array(I.buffer,I.byteOffset+x.binaryDataPosition+Y.position,Y.length)}}return X}function s(I,x){var L;x=z(x);const F=new Array(6),X=null===(L=x.irradiance)||void 0===L?void 0:L.irradianceTexture;if(X){if(6!==X.faces.length)throw new Error(`Incorrect irradiance texture faces number "${X.faces.length}"`);for(let L=0;L<6;L++){const G=X.faces[L];F[L]=new Uint8Array(I.buffer,I.byteOffset+x.binaryDataPosition+G.position,G.length)}}return F}function U(I,x,L){var F;const G=(L=z(L)).IQ;if(!G)return Promise.resolve([]);I._lodGenerationScale=G.lodGenerationScale;const Y=[],p=H(x,L);Y.push(y(I,p,L.imageType));const B=null===(F=L.irradiance)||void 0===F?void 0:F.irradianceTexture;if(B){var l,W;const F=s(x,L);let G=null;null!==(l=L.irradiance)&&void 0!==l&&null!==(W=l.irradianceTexture)&&void 0!==W&&W.dominantDirection&&(G=X.sx.tx(L.irradiance.irradianceTexture.dominantDirection)),Y.push(T(I,F,B.size,L.imageType,G))}return Promise.all(Y)}async function q(I,x,L,F,X,G,Y,p,B,l,W){return await new Promise(((Q,e)=>{if(L){const L=x.createTexture(null,!0,!0,null,1,null,(I=>{e(I)}),I);null===F||void 0===F||F.onEffectCreatedObservable.addOnce((p=>{p.executeWhenCompiled((()=>{F.externalTextureSamplerBinding=!0,F.onApply=F=>{F._bindTexture("textureSampler",L),F.setFloat2("scale",1,x._features.needsInvertingBitmap&&I instanceof ImageBitmap?-1:1)},x.scenes.length&&(x.scenes[0].postProcessManager.directRender([F],l,!0,G,Y),x.restoreDefaultFramebuffer(),L.dispose(),URL.revokeObjectURL(X),Q())}))}))}else{if(x._uploadImageToTexture(W,I,G,Y),p){const L=B[Y];L&&x._uploadImageToTexture(L._texture,I,G,0)}Q()}}))}async function y(I,x){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Q;const F=I.getEngine();I.format=5,I.type=0,I.generateMipMaps=!0,I._cachedAnisotropicFilteringLevel=null,F.updateTextureSamplingMode(3,I),await Z(I,x,!0,L),I.isReady=!0}async function T(I,x,L){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q,X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const G=I.getEngine(),Y=new p.d(G,5),l=new B.d(G,Y);I._irradianceTexture=l,l._dominantDirection=X,Y.isCube=!0,Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,Y.generateMipMaps=!0,Y.width=L,Y.height=L,G.updateTextureSamplingMode(3,Y),await Z(Y,[x],!1,F),G.generateMipMapsForCubemap(Y),Y.isReady=!0}async function Z(I,x,X){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q;if(!F.Tools.IsExponentOfTwo(I.width))throw new Error("Texture size must be a power of two");const W=(0,G.ILog2)(I.width)+1,e=I.getEngine();let g=!1,v=!1,z=null,H=null,s=null;const U=e.getCaps();U.textureLOD?e._features.supportRenderAndCopyToLodForFloatTextures?U.textureHalfFloatRender&&U.textureHalfFloatLinearFiltering?(g=!0,I.type=2):U.textureFloatRender&&U.textureFloatLinearFiltering&&(g=!0,I.type=1):g=!1:(g=!1,v=X);let y=0;if(g)e.isWebGPU?(y=1,await L.e(42).then(L.bind(L,15907))):await L.e(35).then(L.bind(L,15913)),z=new l.d("rgbdDecode","rgbdDecode",null,null,1,null,3,e,!1,void 0,I.type,void 0,null,!1,void 0,y),I._isRGBD=!1,I.invertY=!1,H=e.createRenderTargetCubeTexture(I.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:I.type,format:5});else if(I._isRGBD=!0,I.invertY=!0,v){const x=3;s={};const L=I._lodGenerationScale,F=I._lodGenerationOffset;for(let X=0;X<x;X++){const G=(W-1)*L+F,Y=F+(G-F)*(1-X/(x-1)),l=Math.round(Math.min(Math.max(Y,0),G)),Q=new p.d(e,2);Q.isCube=!0,Q.invertY=!0,Q.generateMipMaps=!1,e.updateTextureSamplingMode(2,Q);const g=new B.d(null);switch(g._isCube=!0,g._texture=Q,s[l]=g,X){case 0:I._lodTextureLow=g;break;case 1:I._lodTextureMid=g;break;case 2:I._lodTextureHigh=g}}}const T=[];for(let L=0;L<x.length;L++)for(let F=0;F<6;F++){const X=x[L][F],G=new Blob([X],{type:Y}),p=URL.createObjectURL(G);let B;if(e._features.forceBitmapOverHTMLImageElement)B=e.createImageBitmap(G,{premultiplyAlpha:"none"}).then((async x=>await q(x,e,g,z,p,F,L,v,s,H,I)));else{const x=new Image;x.src=p,B=new Promise(((X,G)=>{x.onload=()=>{q(x,e,g,z,p,F,L,v,s,H,I).then((()=>X())).catch((I=>{G(I)}))},x.onerror=I=>{G(I)}}))}T.push(B)}if(await Promise.all(T),x.length<W){let L;const F=Math.pow(2,W-1-x.length),X=F*F*4;switch(I.type){case 0:L=new Uint8Array(X);break;case 2:L=new Uint16Array(X);break;case 1:L=new Float32Array(X)}for(let G=x.length;G<W;G++)for(let x=0;x<6;x++){var Z;e._uploadArrayBufferViewToTexture((null===(Z=H)||void 0===Z?void 0:Z.texture)||I,L,x,G)}}if(H){const x=I._irradianceTexture;I._irradianceTexture=null,e._releaseTexture(I),H._swapAndDie(I),I._irradianceTexture=x}z&&z.dispose(),v&&(I._lodTextureHigh&&I._lodTextureHigh._texture&&(I._lodTextureHigh._texture.isReady=!0),I._lodTextureMid&&I._lodTextureMid._texture&&(I._lodTextureMid._texture.isReady=!0),I._lodTextureLow&&I._lodTextureLow._texture&&(I._lodTextureLow._texture.isReady=!0))}function t(I,x){const L=(x=z(x)).irradiance;if(!L)return;const F=new Y.g;X.sx.FromArrayToRef(L.x,0,F.x),X.sx.FromArrayToRef(L.y,0,F.y),X.sx.FromArrayToRef(L.z,0,F.z),X.sx.FromArrayToRef(L.xx,0,F.xx),X.sx.FromArrayToRef(L.yy,0,F.yy),X.sx.FromArrayToRef(L.zz,0,F.zz),X.sx.FromArrayToRef(L.yz,0,F.yz),X.sx.FromArrayToRef(L.zx,0,F.zx),X.sx.FromArrayToRef(L.xy,0,F.xy),I._sphericalPolynomial=F}function f(I,x,L,F,X){const G=y(I.getEngine().createRawCubeTexture(null,I.width,I.format,I.type,I.generateMipMaps,I.invertY,I.samplingMode,I._compression),x).then((()=>I));return I.onRebuildCallback=I=>({proxy:G,isReady:!0,isAsync:!0}),I._source=13,I._bufferViewArrayArray=x,I._lodGenerationScale=F,I._lodGenerationOffset=X,I._sphericalPolynomial=L,y(I,x).then((()=>(I.isReady=!0,I)))}}}]);