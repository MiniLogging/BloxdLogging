"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[45],{12844:(B,I,C)=>{C.d(I,{d:()=>k,g:()=>U,k:()=>r,o:()=>A});var M=C(11018),x=C(11194),y=C(11212),f=C(11383),L=C(11129),e=C(11217),g=(C(11440),C(11294)),N=C(11027);C(11686),C(11423),C(11697);const R="image/png",H=2,F=[134,22,135,150,246,214,150,54];function k(B){const I=new DataView(B.buffer,B.byteOffset,B.byteLength);let C=0;for(let f=0;f<F.length;f++)if(I.getUint8(C++)!==F[f])return N.b.Error("Not a babylon environment map"),null;let M="",x=0;for(;x=I.getUint8(C++);)M+=String.fromCharCode(x);let y=JSON.parse(M);return y=q(y),y.binaryDataPosition=C,y.WN&&(y.WN.lodGenerationScale=y.WN.lodGenerationScale||.8),y}function q(B){if(B.version>H)throw new Error(`Unsupported babylon environment map version "${B.version}". Latest supported version is "${H}".`);return 2===B.version?B:B={...B,version:2,imageType:R}}function S(B,I){const C=(I=q(I)).WN;let M=Math.log2(I.width);if(M=Math.round(M)+1,C.mipmaps.length!==6*M)throw new Error(`Unsupported specular mipmaps number "${C.mipmaps.length}"`);const x=new Array(M);for(let y=0;y<M;y++){x[y]=new Array(6);for(let M=0;M<6;M++){const f=C.mipmaps[6*y+M];x[y][M]=new Uint8Array(B.buffer,B.byteOffset+I.binaryDataPosition+f.position,f.length)}}return x}function o(B,I){var C;I=q(I);const M=new Array(6),x=null===(C=I.irradiance)||void 0===C?void 0:C.irradianceTexture;if(x){if(6!==x.faces.length)throw new Error(`Incorrect irradiance texture faces number "${x.faces.length}"`);for(let C=0;C<6;C++){const y=x.faces[C];M[C]=new Uint8Array(B.buffer,B.byteOffset+I.binaryDataPosition+y.position,y.length)}}return M}function U(B,I,C){var M;const y=(C=q(C)).WN;if(!y)return Promise.resolve([]);B._lodGenerationScale=y.lodGenerationScale;const f=[],L=S(I,C);f.push(V(B,L,C.imageType));const e=null===(M=C.irradiance)||void 0===M?void 0:M.irradianceTexture;if(e){var g,N;const M=o(I,C);let y=null;null!==(g=C.irradiance)&&void 0!==g&&null!==(N=g.irradianceTexture)&&void 0!==N&&N.dominantDirection&&(y=x.HI.oI(C.irradiance.irradianceTexture.dominantDirection)),f.push(c(B,M,e.size,C.imageType,y))}return Promise.all(f)}async function G(B,I,C,M,x,y,f,L,e,g,N){return await new Promise(((R,H)=>{if(C){const C=I.createTexture(null,!0,!0,null,1,null,(B=>{H(B)}),B);null===M||void 0===M||M.onEffectCreatedObservable.addOnce((L=>{L.executeWhenCompiled((()=>{M.externalTextureSamplerBinding=!0,M.onApply=M=>{M._bindTexture("textureSampler",C),M.setFloat2("scale",1,I._features.needsInvertingBitmap&&B instanceof ImageBitmap?-1:1)},I.scenes.length&&(I.scenes[0].postProcessManager.directRender([M],g,!0,y,f),I.restoreDefaultFramebuffer(),C.dispose(),URL.revokeObjectURL(x),R())}))}))}else{if(I._uploadImageToTexture(N,B,y,f),L){const C=e[f];C&&I._uploadImageToTexture(C._texture,B,y,0)}R()}}))}async function V(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:R;const M=B.getEngine();B.format=5,B.type=0,B.generateMipMaps=!0,B._cachedAnisotropicFilteringLevel=null,M.updateTextureSamplingMode(3,B),await t(B,I,!0,C),B.isReady=!0}async function c(B,I,C){let M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R,x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const y=B.getEngine(),f=new L.b(y,5),g=new e.c(y,f);B._irradianceTexture=g,g._dominantDirection=x,f.isCube=!0,f.format=5,f.type=0,f.generateMipMaps=!0,f._cachedAnisotropicFilteringLevel=null,f.generateMipMaps=!0,f.width=C,f.height=C,y.updateTextureSamplingMode(3,f),await t(f,[I],!1,M),y.generateMipMapsForCubemap(f),f.isReady=!0}async function t(B,I,x){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R;if(!M.Tools.IsExponentOfTwo(B.width))throw new Error("Texture size must be a power of two");const N=(0,y.ILog2)(B.width)+1,H=B.getEngine();let F=!1,k=!1,q=null,S=null,o=null;const U=H.getCaps();U.textureLOD?H._features.supportRenderAndCopyToLodForFloatTextures?U.textureHalfFloatRender&&U.textureHalfFloatLinearFiltering?(F=!0,B.type=2):U.textureFloatRender&&U.textureFloatLinearFiltering&&(F=!0,B.type=1):F=!1:(F=!1,k=x);let V=0;if(F)H.isWebGPU?(V=1,await C.e(42).then(C.bind(C,14191))):await C.e(35).then(C.bind(C,14198)),q=new g.d("rgbdDecode","rgbdDecode",null,null,1,null,3,H,!1,void 0,B.type,void 0,null,!1,void 0,V),B._isRGBD=!1,B.invertY=!1,S=H.createRenderTargetCubeTexture(B.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:B.type,format:5});else if(B._isRGBD=!0,B.invertY=!0,k){const I=3;o={};const C=B._lodGenerationScale,M=B._lodGenerationOffset;for(let x=0;x<I;x++){const y=(N-1)*C+M,f=M+(y-M)*(1-x/(I-1)),g=Math.round(Math.min(Math.max(f,0),y)),R=new L.b(H,2);R.isCube=!0,R.invertY=!0,R.generateMipMaps=!1,H.updateTextureSamplingMode(2,R);const F=new e.c(null);switch(F._isCube=!0,F._texture=R,o[g]=F,x){case 0:B._lodTextureLow=F;break;case 1:B._lodTextureMid=F;break;case 2:B._lodTextureHigh=F}}}const c=[];for(let C=0;C<I.length;C++)for(let M=0;M<6;M++){const x=I[C][M],y=new Blob([x],{type:f}),L=URL.createObjectURL(y);let e;if(H._features.forceBitmapOverHTMLImageElement)e=H.createImageBitmap(y,{premultiplyAlpha:"none"}).then((async I=>await G(I,H,F,q,L,M,C,k,o,S,B)));else{const I=new Image;I.src=L,e=new Promise(((x,y)=>{I.onload=()=>{G(I,H,F,q,L,M,C,k,o,S,B).then((()=>x())).catch((B=>{y(B)}))},I.onerror=B=>{y(B)}}))}c.push(e)}if(await Promise.all(c),I.length<N){let C;const M=Math.pow(2,N-1-I.length),x=M*M*4;switch(B.type){case 0:C=new Uint8Array(x);break;case 2:C=new Uint16Array(x);break;case 1:C=new Float32Array(x)}for(let y=I.length;y<N;y++)for(let I=0;I<6;I++){var t;H._uploadArrayBufferViewToTexture((null===(t=S)||void 0===t?void 0:t.texture)||B,C,I,y)}}if(S){const I=B._irradianceTexture;B._irradianceTexture=null,H._releaseTexture(B),S._swapAndDie(B),B._irradianceTexture=I}q&&q.dispose(),k&&(B._lodTextureHigh&&B._lodTextureHigh._texture&&(B._lodTextureHigh._texture.isReady=!0),B._lodTextureMid&&B._lodTextureMid._texture&&(B._lodTextureMid._texture.isReady=!0),B._lodTextureLow&&B._lodTextureLow._texture&&(B._lodTextureLow._texture.isReady=!0))}function r(B,I){const C=(I=q(I)).irradiance;if(!C)return;const M=new f.f;x.HI.FromArrayToRef(C.x,0,M.x),x.HI.FromArrayToRef(C.y,0,M.y),x.HI.FromArrayToRef(C.z,0,M.z),x.HI.FromArrayToRef(C.xx,0,M.xx),x.HI.FromArrayToRef(C.yy,0,M.yy),x.HI.FromArrayToRef(C.zz,0,M.zz),x.HI.FromArrayToRef(C.yz,0,M.yz),x.HI.FromArrayToRef(C.zx,0,M.zx),x.HI.FromArrayToRef(C.xy,0,M.xy),B._sphericalPolynomial=M}function A(B,I,C,M,x){const y=V(B.getEngine().createRawCubeTexture(null,B.width,B.format,B.type,B.generateMipMaps,B.invertY,B.samplingMode,B._compression),I).then((()=>B));return B.onRebuildCallback=B=>({proxy:y,isReady:!0,isAsync:!0}),B._source=13,B._bufferViewArrayArray=I,B._lodGenerationScale=M,B._lodGenerationOffset=x,B._sphericalPolynomial=C,V(B,I).then((()=>(B.isReady=!0,B)))}}}]);