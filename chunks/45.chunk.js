"use strict";(self["5dou0t7wntc"]=self["5dou0t7wntc"]||[]).push([[45],{13401:(K,O,F)=>{F.d(O,{d:()=>u,e:()=>N,h:()=>g,k:()=>H});var f=F(11517),r=F(11713),l=F(11734),q=F(11924),J=F(11636),c=F(11742),E=(F(11964),F(11825)),M=F(11534);F(12246),F(11951),F(12254);const t="image/png",j=2,X=[134,22,135,150,246,214,150,54];function u(K){const O=new DataView(K.buffer,K.byteOffset,K.byteLength);let F=0;for(let q=0;q<X.length;q++)if(O.getUint8(F++)!==X[q])return M.c.Error("Not a babylon environment map"),null;let f="",r=0;for(;r=O.getUint8(F++);)f+=String.fromCharCode(r);let l=JSON.parse(f);return l=T(l),l.binaryDataPosition=F,l.nM&&(l.nM.lodGenerationScale=l.nM.lodGenerationScale||.8),l}function T(K){if(K.version>j)throw new Error(`Unsupported babylon environment map version "${K.version}". Latest supported version is "${j}".`);return 2===K.version?K:K={...K,version:2,imageType:t}}function o(K,O){const F=(O=T(O)).nM;let f=Math.log2(O.width);if(f=Math.round(f)+1,F.mipmaps.length!==6*f)throw new Error(`Unsupported specular mipmaps number "${F.mipmaps.length}"`);const r=new Array(f);for(let l=0;l<f;l++){r[l]=new Array(6);for(let f=0;f<6;f++){const q=F.mipmaps[6*l+f];r[l][f]=new Uint8Array(K.buffer,K.byteOffset+O.binaryDataPosition+q.position,q.length)}}return r}function k(K,O){var F;O=T(O);const f=new Array(6),r=null===(F=O.irradiance)||void 0===F?void 0:F.irradianceTexture;if(r){if(6!==r.faces.length)throw new Error(`Incorrect irradiance texture faces number "${r.faces.length}"`);for(let F=0;F<6;F++){const l=r.faces[F];f[F]=new Uint8Array(K.buffer,K.byteOffset+O.binaryDataPosition+l.position,l.length)}}return f}function N(K,O,F){var f;const l=(F=T(F)).nM;if(!l)return Promise.resolve([]);K._lodGenerationScale=l.lodGenerationScale;const q=[],J=o(O,F);q.push(L(K,J,F.imageType));const c=null===(f=F.irradiance)||void 0===f?void 0:f.irradianceTexture;if(c){var E,M;const f=k(O,F);let l=null;null!==(E=F.irradiance)&&void 0!==E&&null!==(M=E.irradianceTexture)&&void 0!==M&&M.dominantDirection&&(l=r.TO.LO(F.irradiance.irradianceTexture.dominantDirection)),q.push(d(K,f,c.size,F.imageType,l))}return Promise.all(q)}async function Z(K,O,F,f,r,l,q,J,c,E,M){return await new Promise(((t,j)=>{if(F){const F=O.createTexture(null,!0,!0,null,1,null,(K=>{j(K)}),K);null===f||void 0===f||f.onEffectCreatedObservable.addOnce((J=>{J.executeWhenCompiled((()=>{f.externalTextureSamplerBinding=!0,f.onApply=f=>{f._bindTexture("textureSampler",F),f.setFloat2("scale",1,O._features.needsInvertingBitmap&&K instanceof ImageBitmap?-1:1)},O.scenes.length&&(O.scenes[0].postProcessManager.directRender([f],E,!0,l,q),O.restoreDefaultFramebuffer(),F.dispose(),URL.revokeObjectURL(r),t())}))}))}else{if(O._uploadImageToTexture(M,K,l,q),J){const F=c[q];F&&O._uploadImageToTexture(F._texture,K,l,0)}t()}}))}async function L(K,O){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t;const f=K.getEngine();K.format=5,K.type=0,K.generateMipMaps=!0,K._cachedAnisotropicFilteringLevel=null,f.updateTextureSamplingMode(3,K),await a(K,O,!0,F),K.isReady=!0}async function d(K,O,F){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const l=K.getEngine(),q=new J.e(l,5),E=new c.c(l,q);K._irradianceTexture=E,E._dominantDirection=r,q.isCube=!0,q.format=5,q.type=0,q.generateMipMaps=!0,q._cachedAnisotropicFilteringLevel=null,q.generateMipMaps=!0,q.width=F,q.height=F,l.updateTextureSamplingMode(3,q),await a(q,[O],!1,f),l.generateMipMapsForCubemap(q),q.isReady=!0}async function a(K,O,r){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t;if(!f.Tools.IsExponentOfTwo(K.width))throw new Error("Texture size must be a power of two");const M=(0,l.ILog2)(K.width)+1,j=K.getEngine();let X=!1,u=!1,T=null,o=null,k=null;const N=j.getCaps();N.textureLOD?j._features.supportRenderAndCopyToLodForFloatTextures?N.textureHalfFloatRender&&N.textureHalfFloatLinearFiltering?(X=!0,K.type=2):N.textureFloatRender&&N.textureFloatLinearFiltering&&(X=!0,K.type=1):X=!1:(X=!1,u=r);let L=0;if(X)j.isWebGPU?(L=1,await F.e(42).then(F.bind(F,14765))):await F.e(35).then(F.bind(F,14774)),T=new E.e("rgbdDecode","rgbdDecode",null,null,1,null,3,j,!1,void 0,K.type,void 0,null,!1,void 0,L),K._isRGBD=!1,K.invertY=!1,o=j.createRenderTargetCubeTexture(K.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:K.type,format:5});else if(K._isRGBD=!0,K.invertY=!0,u){const O=3;k={};const F=K._lodGenerationScale,f=K._lodGenerationOffset;for(let r=0;r<O;r++){const l=(M-1)*F+f,q=f+(l-f)*(1-r/(O-1)),E=Math.round(Math.min(Math.max(q,0),l)),t=new J.e(j,2);t.isCube=!0,t.invertY=!0,t.generateMipMaps=!1,j.updateTextureSamplingMode(2,t);const X=new c.c(null);switch(X._isCube=!0,X._texture=t,k[E]=X,r){case 0:K._lodTextureLow=X;break;case 1:K._lodTextureMid=X;break;case 2:K._lodTextureHigh=X}}}const d=[];for(let F=0;F<O.length;F++)for(let f=0;f<6;f++){const r=O[F][f],l=new Blob([r],{type:q}),J=URL.createObjectURL(l);let c;if(j._features.forceBitmapOverHTMLImageElement)c=j.createImageBitmap(l,{premultiplyAlpha:"none"}).then((async O=>await Z(O,j,X,T,J,f,F,u,k,o,K)));else{const O=new Image;O.src=J,c=new Promise(((r,l)=>{O.onload=()=>{Z(O,j,X,T,J,f,F,u,k,o,K).then((()=>r())).catch((K=>{l(K)}))},O.onerror=K=>{l(K)}}))}d.push(c)}if(await Promise.all(d),O.length<M){let F;const f=Math.pow(2,M-1-O.length),r=f*f*4;switch(K.type){case 0:F=new Uint8Array(r);break;case 2:F=new Uint16Array(r);break;case 1:F=new Float32Array(r)}for(let l=O.length;l<M;l++)for(let O=0;O<6;O++){var a;j._uploadArrayBufferViewToTexture((null===(a=o)||void 0===a?void 0:a.texture)||K,F,O,l)}}if(o){const O=K._irradianceTexture;K._irradianceTexture=null,j._releaseTexture(K),o._swapAndDie(K),K._irradianceTexture=O}T&&T.dispose(),u&&(K._lodTextureHigh&&K._lodTextureHigh._texture&&(K._lodTextureHigh._texture.isReady=!0),K._lodTextureMid&&K._lodTextureMid._texture&&(K._lodTextureMid._texture.isReady=!0),K._lodTextureLow&&K._lodTextureLow._texture&&(K._lodTextureLow._texture.isReady=!0))}function g(K,O){const F=(O=T(O)).irradiance;if(!F)return;const f=new q.e;r.TO.FromArrayToRef(F.x,0,f.x),r.TO.FromArrayToRef(F.y,0,f.y),r.TO.FromArrayToRef(F.z,0,f.z),r.TO.FromArrayToRef(F.xx,0,f.xx),r.TO.FromArrayToRef(F.yy,0,f.yy),r.TO.FromArrayToRef(F.zz,0,f.zz),r.TO.FromArrayToRef(F.yz,0,f.yz),r.TO.FromArrayToRef(F.zx,0,f.zx),r.TO.FromArrayToRef(F.xy,0,f.xy),K._sphericalPolynomial=f}function H(K,O,F,f,r){const l=L(K.getEngine().createRawCubeTexture(null,K.width,K.format,K.type,K.generateMipMaps,K.invertY,K.samplingMode,K._compression),O).then((()=>K));return K.onRebuildCallback=K=>({proxy:l,isReady:!0,isAsync:!0}),K._source=13,K._bufferViewArrayArray=O,K._lodGenerationScale=f,K._lodGenerationOffset=r,K._sphericalPolynomial=F,L(K,O).then((()=>(K.isReady=!0,K)))}}}]);