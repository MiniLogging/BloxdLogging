"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[45],{14179:(K,A,T)=>{T.d(A,{d:()=>b,f:()=>N,g:()=>g,k:()=>S});var G=T(12526),B=T(12700),L=T(12716),f=T(12883),O=T(12637),C=T(12722),Q=(T(12931),T(12788)),Y=T(12548);T(13206),T(12915),T(13219);const Z="image/png",x=2,J=[134,22,135,150,246,214,150,54];function b(K){const A=new DataView(K.buffer,K.byteOffset,K.byteLength);let T=0;for(let f=0;f<J.length;f++)if(A.getUint8(T++)!==J[f])return Y.d.Error("Not a babylon environment map"),null;let G="",B=0;for(;B=A.getUint8(T++);)G+=String.fromCharCode(B);let L=JSON.parse(G);return L=P(L),L.binaryDataPosition=T,L.eY&&(L.eY.lodGenerationScale=L.eY.lodGenerationScale||.8),L}function P(K){if(K.version>x)throw new Error(`Unsupported babylon environment map version "${K.version}". Latest supported version is "${x}".`);return 2===K.version?K:K={...K,version:2,imageType:Z}}function F(K,A){const T=(A=P(A)).eY;let G=Math.log2(A.width);if(G=Math.round(G)+1,T.mipmaps.length!==6*G)throw new Error(`Unsupported specular mipmaps number "${T.mipmaps.length}"`);const B=new Array(G);for(let L=0;L<G;L++){B[L]=new Array(6);for(let G=0;G<6;G++){const f=T.mipmaps[6*L+G];B[L][G]=new Uint8Array(K.buffer,K.byteOffset+A.binaryDataPosition+f.position,f.length)}}return B}function d(K,A){var T;A=P(A);const G=new Array(6),B=null===(T=A.irradiance)||void 0===T?void 0:T.irradianceTexture;if(B){if(6!==B.faces.length)throw new Error(`Incorrect irradiance texture faces number "${B.faces.length}"`);for(let T=0;T<6;T++){const L=B.faces[T];G[T]=new Uint8Array(K.buffer,K.byteOffset+A.binaryDataPosition+L.position,L.length)}}return G}function N(K,A,T){var G;const L=(T=P(T)).eY;if(!L)return Promise.resolve([]);K._lodGenerationScale=L.lodGenerationScale;const f=[],O=F(A,T);f.push(mK(K,O,T.imageType));const C=null===(G=T.irradiance)||void 0===G?void 0:G.irradianceTexture;if(C){var Q,Y;const G=d(A,T);let L=null;null!==(Q=T.irradiance)&&void 0!==Q&&null!==(Y=Q.irradianceTexture)&&void 0!==Y&&Y.dominantDirection&&(L=B.PA.mT(T.irradiance.irradianceTexture.dominantDirection)),f.push(U(K,G,C.size,T.imageType,L))}return Promise.all(f)}async function D(K,A,T,G,B,L,f,O,C,Q,Y){return await new Promise(((Z,x)=>{if(T){const T=A.createTexture(null,!0,!0,null,1,null,(K=>{x(K)}),K);null===G||void 0===G||G.onEffectCreatedObservable.addOnce((O=>{O.executeWhenCompiled((()=>{G.externalTextureSamplerBinding=!0,G.onApply=G=>{G._bindTexture("textureSampler",T),G.setFloat2("scale",1,A._features.needsInvertingBitmap&&K instanceof ImageBitmap?-1:1)},A.scenes.length&&(A.scenes[0].postProcessManager.directRender([G],Q,!0,L,f),A.restoreDefaultFramebuffer(),T.dispose(),URL.revokeObjectURL(B),Z())}))}))}else{if(A._uploadImageToTexture(Y,K,L,f),O){const T=C[f];T&&A._uploadImageToTexture(T._texture,K,L,0)}Z()}}))}async function mK(K,A){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Z;const G=K.getEngine();K.format=5,K.type=0,K.generateMipMaps=!0,K._cachedAnisotropicFilteringLevel=null,G.updateTextureSamplingMode(3,K),await z(K,A,!0,T),K.isReady=!0}async function U(K,A,T){let G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const L=K.getEngine(),f=new O.b(L,5),Q=new C.e(L,f);K._irradianceTexture=Q,Q._dominantDirection=B,f.isCube=!0,f.format=5,f.type=0,f.generateMipMaps=!0,f._cachedAnisotropicFilteringLevel=null,f.generateMipMaps=!0,f.width=T,f.height=T,L.updateTextureSamplingMode(3,f),await z(f,[A],!1,G),L.generateMipMapsForCubemap(f),f.isReady=!0}async function z(K,A,B){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z;if(!G.Tools.IsExponentOfTwo(K.width))throw new Error("Texture size must be a power of two");const Y=(0,L.ILog2)(K.width)+1,x=K.getEngine();let J=!1,b=!1,P=null,F=null,d=null;const N=x.getCaps();N.textureLOD?x._features.supportRenderAndCopyToLodForFloatTextures?N.textureHalfFloatRender&&N.textureHalfFloatLinearFiltering?(J=!0,K.type=2):N.textureFloatRender&&N.textureFloatLinearFiltering&&(J=!0,K.type=1):J=!1:(J=!1,b=B);let mK=0;if(J)x.isWebGPU?(mK=1,await T.e(42).then(T.bind(T,15705))):await T.e(35).then(T.bind(T,15708)),P=new Q.d("rgbdDecode","rgbdDecode",null,null,1,null,3,x,!1,void 0,K.type,void 0,null,!1,void 0,mK),K._isRGBD=!1,K.invertY=!1,F=x.createRenderTargetCubeTexture(K.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:K.type,format:5});else if(K._isRGBD=!0,K.invertY=!0,b){const A=3;d={};const T=K._lodGenerationScale,G=K._lodGenerationOffset;for(let B=0;B<A;B++){const L=(Y-1)*T+G,f=G+(L-G)*(1-B/(A-1)),Q=Math.round(Math.min(Math.max(f,0),L)),Z=new O.b(x,2);Z.isCube=!0,Z.invertY=!0,Z.generateMipMaps=!1,x.updateTextureSamplingMode(2,Z);const J=new C.e(null);switch(J._isCube=!0,J._texture=Z,d[Q]=J,B){case 0:K._lodTextureLow=J;break;case 1:K._lodTextureMid=J;break;case 2:K._lodTextureHigh=J}}}const U=[];for(let T=0;T<A.length;T++)for(let G=0;G<6;G++){const B=A[T][G],L=new Blob([B],{type:f}),O=URL.createObjectURL(L);let C;if(x._features.forceBitmapOverHTMLImageElement)C=x.createImageBitmap(L,{premultiplyAlpha:"none"}).then((async A=>await D(A,x,J,P,O,G,T,b,d,F,K)));else{const A=new Image;A.src=O,C=new Promise(((B,L)=>{A.onload=()=>{D(A,x,J,P,O,G,T,b,d,F,K).then((()=>B())).catch((K=>{L(K)}))},A.onerror=K=>{L(K)}}))}U.push(C)}if(await Promise.all(U),A.length<Y){let T;const G=Math.pow(2,Y-1-A.length),B=G*G*4;switch(K.type){case 0:T=new Uint8Array(B);break;case 2:T=new Uint16Array(B);break;case 1:T=new Float32Array(B)}for(let L=A.length;L<Y;L++)for(let A=0;A<6;A++){var z;x._uploadArrayBufferViewToTexture((null===(z=F)||void 0===z?void 0:z.texture)||K,T,A,L)}}if(F){const A=K._irradianceTexture;K._irradianceTexture=null,x._releaseTexture(K),F._swapAndDie(K),K._irradianceTexture=A}P&&P.dispose(),b&&(K._lodTextureHigh&&K._lodTextureHigh._texture&&(K._lodTextureHigh._texture.isReady=!0),K._lodTextureMid&&K._lodTextureMid._texture&&(K._lodTextureMid._texture.isReady=!0),K._lodTextureLow&&K._lodTextureLow._texture&&(K._lodTextureLow._texture.isReady=!0))}function g(K,A){const T=(A=P(A)).irradiance;if(!T)return;const G=new f.g;B.PA.FromArrayToRef(T.x,0,G.x),B.PA.FromArrayToRef(T.y,0,G.y),B.PA.FromArrayToRef(T.z,0,G.z),B.PA.FromArrayToRef(T.xx,0,G.xx),B.PA.FromArrayToRef(T.yy,0,G.yy),B.PA.FromArrayToRef(T.zz,0,G.zz),B.PA.FromArrayToRef(T.yz,0,G.yz),B.PA.FromArrayToRef(T.zx,0,G.zx),B.PA.FromArrayToRef(T.xy,0,G.xy),K._sphericalPolynomial=G}function S(K,A,T,G,B){const L=mK(K.getEngine().createRawCubeTexture(null,K.width,K.format,K.type,K.generateMipMaps,K.invertY,K.samplingMode,K._compression),A).then((()=>K));return K.onRebuildCallback=K=>({proxy:L,isReady:!0,isAsync:!0}),K._source=13,K._bufferViewArrayArray=A,K._lodGenerationScale=G,K._lodGenerationOffset=B,K._sphericalPolynomial=T,mK(K,A).then((()=>(K.isReady=!0,K)))}}}]);