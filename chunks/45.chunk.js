"use strict";(self["7c63p8lin4r"]=self["7c63p8lin4r"]||[]).push([[45],{14149:(z,u,U)=>{U.d(u,{e:()=>E,i:()=>T,m:()=>L,p:()=>O});var J=U(21),v=U(12748),f=U(12914),g=U(12935),w=U(13116),P=U(12853),R=U(12940),S=(U(13161),U(13017)),d=U(12760);U(13385),U(13144),U(13393);const mz="image/png",Z=2,A=[134,22,135,150,246,214,150,54];function E(z){const u=new DataView(z.buffer,z.byteOffset,z.byteLength);let U=0;for(let g=0;g<A.length;g++)if(u.getUint8(U++)!==A[g])return d.d.Error("Not a babylon environment map"),null;let J="",v=0;for(;v=u.getUint8(U++);)J+=String.fromCharCode(v);let f=JSON.parse(J);return f=C(f),f.binaryDataPosition=U,f.sS&&(f.sS.lodGenerationScale=f.sS.lodGenerationScale||.8),f}function C(z){if(z.version>Z)throw new Error('Unsupported babylon environment map version "'.concat(z.version,'". Latest supported version is "').concat(Z,'".'));return 2===z.version?z:z=(0,J.e)((0,J.e)({},z),{},{version:2,imageType:mz})}function r(z,u){const U=(u=C(u)).sS;let J=Math.log2(u.width);if(J=Math.round(J)+1,U.mipmaps.length!==6*J)throw new Error('Unsupported specular mipmaps number "'.concat(U.mipmaps.length,'"'));const v=new Array(J);for(let f=0;f<J;f++){v[f]=new Array(6);for(let J=0;J<6;J++){const g=U.mipmaps[6*f+J];v[f][J]=new Uint8Array(z.buffer,z.byteOffset+u.binaryDataPosition+g.position,g.length)}}return v}function M(z,u){var U;u=C(u);const J=new Array(6),v=null===(U=u.irradiance)||void 0===U?void 0:U.irradianceTexture;if(v){if(6!==v.faces.length)throw new Error('Incorrect irradiance texture faces number "'.concat(v.faces.length,'"'));for(let U=0;U<6;U++){const f=v.faces[U];J[U]=new Uint8Array(z.buffer,z.byteOffset+u.binaryDataPosition+f.position,f.length)}}return J}function T(z,u,U){var J;const v=(U=C(U)).sS;if(!v)return Promise.resolve([]);z._lodGenerationScale=v.lodGenerationScale;const g=[],w=r(u,U);g.push(h(z,w,U.imageType));const P=null===(J=U.irradiance)||void 0===J?void 0:J.irradianceTexture;if(P){var R,S;const J=M(u,U);let v=null;null!==(R=U.irradiance)&&void 0!==R&&null!==(S=R.irradianceTexture)&&void 0!==S&&S.dominantDirection&&(v=f.Eu.Xu(U.irradiance.irradianceTexture.dominantDirection)),g.push(t(z,J,P.size,U.imageType,v))}return Promise.all(g)}async function X(z,u,U,J,v,f,g,w,P,R,S){return await new Promise(((d,mz)=>{if(U){const U=u.createTexture(null,!0,!0,null,1,null,(z=>{mz(z)}),z);null===J||void 0===J||J.onEffectCreatedObservable.addOnce((w=>{w.executeWhenCompiled((()=>{J.externalTextureSamplerBinding=!0,J.onApply=J=>{J._bindTexture("textureSampler",U),J.setFloat2("scale",1,u._features.needsInvertingBitmap&&z instanceof ImageBitmap?-1:1)},u.scenes.length&&(u.scenes[0].postProcessManager.directRender([J],R,!0,f,g),u.restoreDefaultFramebuffer(),U.dispose(),URL.revokeObjectURL(v),d())}))}))}else{if(u._uploadImageToTexture(S,z,f,g),w){const U=P[g];U&&u._uploadImageToTexture(U._texture,z,f,0)}d()}}))}async function h(z,u){let U=arguments.length>2&&void 0!==arguments[2]?arguments[2]:mz;const J=z.getEngine();z.format=5,z.type=0,z.generateMipMaps=!0,z._cachedAnisotropicFilteringLevel=null,J.updateTextureSamplingMode(3,z),await V(z,u,!0,U),z.isReady=!0}async function t(z,u,U){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mz,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const f=z.getEngine(),g=new P.c(f,5),w=new R.c(f,g);z._irradianceTexture=w,w._dominantDirection=v,g.isCube=!0,g.format=5,g.type=0,g.generateMipMaps=!0,g._cachedAnisotropicFilteringLevel=null,g.generateMipMaps=!0,g.width=U,g.height=U,f.updateTextureSamplingMode(3,g),await V(g,[u],!1,J),f.generateMipMapsForCubemap(g),g.isReady=!0}async function V(z,u,J){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:mz;if(!v.Tools.IsExponentOfTwo(z.width))throw new Error("Texture size must be a power of two");const w=(0,g.ILog2)(z.width)+1,d=z.getEngine();let Z=!1,A=!1,E=null,C=null,r=null;const M=d.getCaps();M.textureLOD?d._features.supportRenderAndCopyToLodForFloatTextures?M.textureHalfFloatRender&&M.textureHalfFloatLinearFiltering?(Z=!0,z.type=2):M.textureFloatRender&&M.textureFloatLinearFiltering&&(Z=!0,z.type=1):Z=!1:(Z=!1,A=J);let T=0;if(Z)d.isWebGPU?(T=1,await U.e(42).then(U.bind(U,15536))):await U.e(35).then(U.bind(U,15540)),E=new S.c("rgbdDecode","rgbdDecode",null,null,1,null,3,d,!1,void 0,z.type,void 0,null,!1,void 0,T),z._isRGBD=!1,z.invertY=!1,C=d.createRenderTargetCubeTexture(z.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:z.type,format:5});else if(z._isRGBD=!0,z.invertY=!0,A){const u=3;r={};const U=z._lodGenerationScale,J=z._lodGenerationOffset;for(let v=0;v<u;v++){const f=(w-1)*U+J,g=J+(f-J)*(1-v/(u-1)),S=Math.round(Math.min(Math.max(g,0),f)),mz=new P.c(d,2);mz.isCube=!0,mz.invertY=!0,mz.generateMipMaps=!1,d.updateTextureSamplingMode(2,mz);const Z=new R.c(null);switch(Z._isCube=!0,Z._texture=mz,r[S]=Z,v){case 0:z._lodTextureLow=Z;break;case 1:z._lodTextureMid=Z;break;case 2:z._lodTextureHigh=Z}}}const h=[];for(let U=0;U<u.length;U++)for(let J=0;J<6;J++){const v=u[U][J],g=new Blob([v],{type:f}),w=URL.createObjectURL(g);let P;if(d._features.forceBitmapOverHTMLImageElement)P=d.createImageBitmap(g,{premultiplyAlpha:"none"}).then((async u=>await X(u,d,Z,E,w,J,U,A,r,C,z)));else{const u=new Image;u.src=w,P=new Promise(((v,f)=>{u.onload=()=>{X(u,d,Z,E,w,J,U,A,r,C,z).then((()=>v())).catch((z=>{f(z)}))},u.onerror=z=>{f(z)}}))}h.push(P)}if(await Promise.all(h),u.length<w){let U;const J=Math.pow(2,w-1-u.length),v=J*J*4;switch(z.type){case 0:U=new Uint8Array(v);break;case 2:U=new Uint16Array(v);break;case 1:U=new Float32Array(v)}for(let f=u.length;f<w;f++)for(let u=0;u<6;u++){var t;d._uploadArrayBufferViewToTexture((null===(t=C)||void 0===t?void 0:t.texture)||z,U,u,f)}}if(C){const u=z._irradianceTexture;z._irradianceTexture=null,d._releaseTexture(z),C._swapAndDie(z),z._irradianceTexture=u}E&&E.dispose(),A&&(z._lodTextureHigh&&z._lodTextureHigh._texture&&(z._lodTextureHigh._texture.isReady=!0),z._lodTextureMid&&z._lodTextureMid._texture&&(z._lodTextureMid._texture.isReady=!0),z._lodTextureLow&&z._lodTextureLow._texture&&(z._lodTextureLow._texture.isReady=!0))}function L(z,u){const U=(u=C(u)).irradiance;if(!U)return;const J=new w.f;f.Eu.FromArrayToRef(U.x,0,J.x),f.Eu.FromArrayToRef(U.y,0,J.y),f.Eu.FromArrayToRef(U.z,0,J.z),f.Eu.FromArrayToRef(U.xx,0,J.xx),f.Eu.FromArrayToRef(U.yy,0,J.yy),f.Eu.FromArrayToRef(U.zz,0,J.zz),f.Eu.FromArrayToRef(U.yz,0,J.yz),f.Eu.FromArrayToRef(U.zx,0,J.zx),f.Eu.FromArrayToRef(U.xy,0,J.xy),z._sphericalPolynomial=J}function O(z,u,U,J,v){const f=h(z.getEngine().createRawCubeTexture(null,z.width,z.format,z.type,z.generateMipMaps,z.invertY,z.samplingMode,z._compression),u).then((()=>z));return z.onRebuildCallback=z=>({proxy:f,isReady:!0,isAsync:!0}),z._source=13,z._bufferViewArrayArray=u,z._lodGenerationScale=J,z._lodGenerationOffset=v,z._sphericalPolynomial=U,h(z,u).then((()=>(z.isReady=!0,z)))}}}]);