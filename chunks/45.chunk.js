"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[45],{14093:(U,G,C)=>{C.d(G,{d:()=>p,g:()=>h,j:()=>S,l:()=>v});var L=C(26),X=C(12718),l=C(12896),t=C(12911),E=C(13064),K=C(12826),P=C(12913),O=(C(13097),C(12985)),T=C(12731);C(13367),C(13089),C(13381);const D="image/png",y=2,V=[134,22,135,150,246,214,150,54];function p(U){const G=new DataView(U.buffer,U.byteOffset,U.byteLength);let C=0;for(let t=0;t<V.length;t++)if(G.getUint8(C++)!==V[t])return T.d.Error("Not a babylon environment map"),null;let L="",X=0;for(;X=G.getUint8(C++);)L+=String.fromCharCode(X);let l=JSON.parse(L);return l=I(l),l.binaryDataPosition=C,l.jO&&(l.jO.lodGenerationScale=l.jO.lodGenerationScale||.8),l}function I(U){if(U.version>y)throw new Error('Unsupported babylon environment map version "'.concat(U.version,'". Latest supported version is "').concat(y,'".'));return 2===U.version?U:U=(0,L.b)((0,L.b)({},U),{},{version:2,imageType:D})}function H(U,G){const C=(G=I(G)).jO;let L=Math.log2(G.width);if(L=Math.round(L)+1,C.mipmaps.length!==6*L)throw new Error('Unsupported specular mipmaps number "'.concat(C.mipmaps.length,'"'));const X=new Array(L);for(let l=0;l<L;l++){X[l]=new Array(6);for(let L=0;L<6;L++){const t=C.mipmaps[6*l+L];X[l][L]=new Uint8Array(U.buffer,U.byteOffset+G.binaryDataPosition+t.position,t.length)}}return X}function x(U,G){var C;G=I(G);const L=new Array(6),X=null===(C=G.irradiance)||void 0===C?void 0:C.irradianceTexture;if(X){if(6!==X.faces.length)throw new Error('Incorrect irradiance texture faces number "'.concat(X.faces.length,'"'));for(let C=0;C<6;C++){const l=X.faces[C];L[C]=new Uint8Array(U.buffer,U.byteOffset+G.binaryDataPosition+l.position,l.length)}}return L}function h(U,G,C){var L;const X=(C=I(C)).jO;if(!X)return Promise.resolve([]);U._lodGenerationScale=X.lodGenerationScale;const t=[],E=H(G,C);t.push(b(U,E,C.imageType));const K=null===(L=C.irradiance)||void 0===L?void 0:L.irradianceTexture;if(K){var P,O;const L=x(G,C);let X=null;null!==(P=C.irradiance)&&void 0!==P&&null!==(O=P.irradianceTexture)&&void 0!==O&&O.dominantDirection&&(X=l.pG.NG(C.irradiance.irradianceTexture.dominantDirection)),t.push(o(U,L,K.size,C.imageType,X))}return Promise.all(t)}async function N(U,G,C,L,X,l,t,E,K,P,O){return await new Promise(((T,D)=>{if(C){const C=G.createTexture(null,!0,!0,null,1,null,(U=>{D(U)}),U);null===L||void 0===L||L.onEffectCreatedObservable.addOnce((E=>{E.executeWhenCompiled((()=>{L.externalTextureSamplerBinding=!0,L.onApply=L=>{L._bindTexture("textureSampler",C),L.setFloat2("scale",1,G._features.needsInvertingBitmap&&U instanceof ImageBitmap?-1:1)},G.scenes.length&&(G.scenes[0].postProcessManager.directRender([L],P,!0,l,t),G.restoreDefaultFramebuffer(),C.dispose(),URL.revokeObjectURL(X),T())}))}))}else{if(G._uploadImageToTexture(O,U,l,t),E){const C=K[t];C&&G._uploadImageToTexture(C._texture,U,l,0)}T()}}))}async function b(U,G){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:D;const L=U.getEngine();U.format=5,U.type=0,U.generateMipMaps=!0,U._cachedAnisotropicFilteringLevel=null,L.updateTextureSamplingMode(3,U),await w(U,G,!0,C),U.isReady=!0}async function o(U,G,C){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:D,X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const l=U.getEngine(),t=new K.b(l,5),E=new P.e(l,t);U._irradianceTexture=E,E._dominantDirection=X,t.isCube=!0,t.format=5,t.type=0,t.generateMipMaps=!0,t._cachedAnisotropicFilteringLevel=null,t.generateMipMaps=!0,t.width=C,t.height=C,l.updateTextureSamplingMode(3,t),await w(t,[G],!1,L),l.generateMipMapsForCubemap(t),t.isReady=!0}async function w(U,G,L){let l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:D;if(!X.Tools.IsExponentOfTwo(U.width))throw new Error("Texture size must be a power of two");const E=(0,t.ILog2)(U.width)+1,T=U.getEngine();let y=!1,V=!1,p=null,I=null,H=null;const x=T.getCaps();x.textureLOD?T._features.supportRenderAndCopyToLodForFloatTextures?x.textureHalfFloatRender&&x.textureHalfFloatLinearFiltering?(y=!0,U.type=2):x.textureFloatRender&&x.textureFloatLinearFiltering&&(y=!0,U.type=1):y=!1:(y=!1,V=L);let h=0;if(y)T.isWebGPU?(h=1,await C.e(42).then(C.bind(C,15469))):await C.e(35).then(C.bind(C,15473)),p=new O.e("rgbdDecode","rgbdDecode",null,null,1,null,3,T,!1,void 0,U.type,void 0,null,!1,void 0,h),U._isRGBD=!1,U.invertY=!1,I=T.createRenderTargetCubeTexture(U.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:U.type,format:5});else if(U._isRGBD=!0,U.invertY=!0,V){const G=3;H={};const C=U._lodGenerationScale,L=U._lodGenerationOffset;for(let X=0;X<G;X++){const l=(E-1)*C+L,t=L+(l-L)*(1-X/(G-1)),O=Math.round(Math.min(Math.max(t,0),l)),D=new K.b(T,2);D.isCube=!0,D.invertY=!0,D.generateMipMaps=!1,T.updateTextureSamplingMode(2,D);const y=new P.e(null);switch(y._isCube=!0,y._texture=D,H[O]=y,X){case 0:U._lodTextureLow=y;break;case 1:U._lodTextureMid=y;break;case 2:U._lodTextureHigh=y}}}const b=[];for(let C=0;C<G.length;C++)for(let L=0;L<6;L++){const X=G[C][L],t=new Blob([X],{type:l}),E=URL.createObjectURL(t);let K;if(T._features.forceBitmapOverHTMLImageElement)K=T.createImageBitmap(t,{premultiplyAlpha:"none"}).then((async G=>await N(G,T,y,p,E,L,C,V,H,I,U)));else{const G=new Image;G.src=E,K=new Promise(((X,l)=>{G.onload=()=>{N(G,T,y,p,E,L,C,V,H,I,U).then((()=>X())).catch((U=>{l(U)}))},G.onerror=U=>{l(U)}}))}b.push(K)}if(await Promise.all(b),G.length<E){let C;const L=Math.pow(2,E-1-G.length),X=L*L*4;switch(U.type){case 0:C=new Uint8Array(X);break;case 2:C=new Uint16Array(X);break;case 1:C=new Float32Array(X)}for(let l=G.length;l<E;l++)for(let G=0;G<6;G++){var o;T._uploadArrayBufferViewToTexture((null===(o=I)||void 0===o?void 0:o.texture)||U,C,G,l)}}if(I){const G=U._irradianceTexture;U._irradianceTexture=null,T._releaseTexture(U),I._swapAndDie(U),U._irradianceTexture=G}p&&p.dispose(),V&&(U._lodTextureHigh&&U._lodTextureHigh._texture&&(U._lodTextureHigh._texture.isReady=!0),U._lodTextureMid&&U._lodTextureMid._texture&&(U._lodTextureMid._texture.isReady=!0),U._lodTextureLow&&U._lodTextureLow._texture&&(U._lodTextureLow._texture.isReady=!0))}function S(U,G){const C=(G=I(G)).irradiance;if(!C)return;const L=new E.g;l.pG.FromArrayToRef(C.x,0,L.x),l.pG.FromArrayToRef(C.y,0,L.y),l.pG.FromArrayToRef(C.z,0,L.z),l.pG.FromArrayToRef(C.xx,0,L.xx),l.pG.FromArrayToRef(C.yy,0,L.yy),l.pG.FromArrayToRef(C.zz,0,L.zz),l.pG.FromArrayToRef(C.yz,0,L.yz),l.pG.FromArrayToRef(C.zx,0,L.zx),l.pG.FromArrayToRef(C.xy,0,L.xy),U._sphericalPolynomial=L}function v(U,G,C,L,X){const l=b(U.getEngine().createRawCubeTexture(null,U.width,U.format,U.type,U.generateMipMaps,U.invertY,U.samplingMode,U._compression),G).then((()=>U));return U.onRebuildCallback=U=>({proxy:l,isReady:!0,isAsync:!0}),U._source=13,U._bufferViewArrayArray=G,U._lodGenerationScale=L,U._lodGenerationOffset=X,U._sphericalPolynomial=C,b(U,G).then((()=>(U.isReady=!0,U)))}}}]);