"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[45],{14266:(p,b,M)=>{M.d(b,{e:()=>c,g:()=>Y,i:()=>u,k:()=>e});var h=M(12608),Q=M(12777),mp=M(12789),y=M(12957),P=M(12711),w=M(12798),t=(M(13013),M(12870)),z=M(12622);M(13282),M(12997),M(13293);const x="image/png",S=2,X=[134,22,135,150,246,214,150,54];function c(p){const b=new DataView(p.buffer,p.byteOffset,p.byteLength);let M=0;for(let y=0;y<X.length;y++)if(b.getUint8(M++)!==X[y])return z.d.Error("Not a babylon environment map"),null;let h="",Q=0;for(;Q=b.getUint8(M++);)h+=String.fromCharCode(Q);let mp=JSON.parse(h);return mp=J(mp),mp.binaryDataPosition=M,mp.Hx&&(mp.Hx.lodGenerationScale=mp.Hx.lodGenerationScale||.8),mp}function J(p){if(p.version>S)throw new Error(`Unsupported babylon environment map version "${p.version}". Latest supported version is "${S}".`);return 2===p.version?p:p={...p,version:2,imageType:x}}function g(p,b){const M=(b=J(b)).Hx;let h=Math.log2(b.width);if(h=Math.round(h)+1,M.mipmaps.length!==6*h)throw new Error(`Unsupported specular mipmaps number "${M.mipmaps.length}"`);const Q=new Array(h);for(let mp=0;mp<h;mp++){Q[mp]=new Array(6);for(let h=0;h<6;h++){const y=M.mipmaps[6*mp+h];Q[mp][h]=new Uint8Array(p.buffer,p.byteOffset+b.binaryDataPosition+y.position,y.length)}}return Q}function f(p,b){var M;b=J(b);const h=new Array(6),Q=null===(M=b.irradiance)||void 0===M?void 0:M.irradianceTexture;if(Q){if(6!==Q.faces.length)throw new Error(`Incorrect irradiance texture faces number "${Q.faces.length}"`);for(let M=0;M<6;M++){const mp=Q.faces[M];h[M]=new Uint8Array(p.buffer,p.byteOffset+b.binaryDataPosition+mp.position,mp.length)}}return h}function Y(p,b,M){var h;const mp=(M=J(M)).Hx;if(!mp)return Promise.resolve([]);p._lodGenerationScale=mp.lodGenerationScale;const y=[],P=g(b,M);y.push(o(p,P,M.imageType));const w=null===(h=M.irradiance)||void 0===h?void 0:h.irradianceTexture;if(w){var t,z;const h=f(b,M);let mp=null;null!==(t=M.irradiance)&&void 0!==t&&null!==(z=t.irradianceTexture)&&void 0!==z&&z.dominantDirection&&(mp=Q.QM.tM(M.irradiance.irradianceTexture.dominantDirection)),y.push(l(p,h,w.size,M.imageType,mp))}return Promise.all(y)}async function a(p,b,M,h,Q,mp,y,P,w,t,z){return await new Promise(((x,S)=>{if(M){const M=b.createTexture(null,!0,!0,null,1,null,(p=>{S(p)}),p);null===h||void 0===h||h.onEffectCreatedObservable.addOnce((P=>{P.executeWhenCompiled((()=>{h.externalTextureSamplerBinding=!0,h.onApply=h=>{h._bindTexture("textureSampler",M),h.setFloat2("scale",1,b._features.needsInvertingBitmap&&p instanceof ImageBitmap?-1:1)},b.scenes.length&&(b.scenes[0].postProcessManager.directRender([h],t,!0,mp,y),b.restoreDefaultFramebuffer(),M.dispose(),URL.revokeObjectURL(Q),x())}))}))}else{if(b._uploadImageToTexture(z,p,mp,y),P){const M=w[y];M&&b._uploadImageToTexture(M._texture,p,mp,0)}x()}}))}async function o(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:x;const h=p.getEngine();p.format=5,p.type=0,p.generateMipMaps=!0,p._cachedAnisotropicFilteringLevel=null,h.updateTextureSamplingMode(3,p),await L(p,b,!0,M),p.isReady=!0}async function l(p,b,M){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x,Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const mp=p.getEngine(),y=new P.e(mp,5),t=new w.e(mp,y);p._irradianceTexture=t,t._dominantDirection=Q,y.isCube=!0,y.format=5,y.type=0,y.generateMipMaps=!0,y._cachedAnisotropicFilteringLevel=null,y.generateMipMaps=!0,y.width=M,y.height=M,mp.updateTextureSamplingMode(3,y),await L(y,[b],!1,h),mp.generateMipMapsForCubemap(y),y.isReady=!0}async function L(p,b,Q){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:x;if(!h.Tools.IsExponentOfTwo(p.width))throw new Error("Texture size must be a power of two");const z=(0,mp.ILog2)(p.width)+1,S=p.getEngine();let X=!1,c=!1,J=null,g=null,f=null;const Y=S.getCaps();Y.textureLOD?S._features.supportRenderAndCopyToLodForFloatTextures?Y.textureHalfFloatRender&&Y.textureHalfFloatLinearFiltering?(X=!0,p.type=2):Y.textureFloatRender&&Y.textureFloatLinearFiltering&&(X=!0,p.type=1):X=!1:(X=!1,c=Q);let o=0;if(X)S.isWebGPU?(o=1,await M.e(42).then(M.bind(M,15819))):await M.e(35).then(M.bind(M,15828)),J=new t.d("rgbdDecode","rgbdDecode",null,null,1,null,3,S,!1,void 0,p.type,void 0,null,!1,void 0,o),p._isRGBD=!1,p.invertY=!1,g=S.createRenderTargetCubeTexture(p.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:p.type,format:5});else if(p._isRGBD=!0,p.invertY=!0,c){const b=3;f={};const M=p._lodGenerationScale,h=p._lodGenerationOffset;for(let Q=0;Q<b;Q++){const mp=(z-1)*M+h,y=h+(mp-h)*(1-Q/(b-1)),t=Math.round(Math.min(Math.max(y,0),mp)),x=new P.e(S,2);x.isCube=!0,x.invertY=!0,x.generateMipMaps=!1,S.updateTextureSamplingMode(2,x);const X=new w.e(null);switch(X._isCube=!0,X._texture=x,f[t]=X,Q){case 0:p._lodTextureLow=X;break;case 1:p._lodTextureMid=X;break;case 2:p._lodTextureHigh=X}}}const l=[];for(let M=0;M<b.length;M++)for(let h=0;h<6;h++){const Q=b[M][h],mp=new Blob([Q],{type:y}),P=URL.createObjectURL(mp);let w;if(S._features.forceBitmapOverHTMLImageElement)w=S.createImageBitmap(mp,{premultiplyAlpha:"none"}).then((async b=>await a(b,S,X,J,P,h,M,c,f,g,p)));else{const b=new Image;b.src=P,w=new Promise(((Q,mp)=>{b.onload=()=>{a(b,S,X,J,P,h,M,c,f,g,p).then((()=>Q())).catch((p=>{mp(p)}))},b.onerror=p=>{mp(p)}}))}l.push(w)}if(await Promise.all(l),b.length<z){let M;const h=Math.pow(2,z-1-b.length),Q=h*h*4;switch(p.type){case 0:M=new Uint8Array(Q);break;case 2:M=new Uint16Array(Q);break;case 1:M=new Float32Array(Q)}for(let mp=b.length;mp<z;mp++)for(let b=0;b<6;b++){var L;S._uploadArrayBufferViewToTexture((null===(L=g)||void 0===L?void 0:L.texture)||p,M,b,mp)}}if(g){const b=p._irradianceTexture;p._irradianceTexture=null,S._releaseTexture(p),g._swapAndDie(p),p._irradianceTexture=b}J&&J.dispose(),c&&(p._lodTextureHigh&&p._lodTextureHigh._texture&&(p._lodTextureHigh._texture.isReady=!0),p._lodTextureMid&&p._lodTextureMid._texture&&(p._lodTextureMid._texture.isReady=!0),p._lodTextureLow&&p._lodTextureLow._texture&&(p._lodTextureLow._texture.isReady=!0))}function u(p,b){const M=(b=J(b)).irradiance;if(!M)return;const h=new y.f;Q.QM.FromArrayToRef(M.x,0,h.x),Q.QM.FromArrayToRef(M.y,0,h.y),Q.QM.FromArrayToRef(M.z,0,h.z),Q.QM.FromArrayToRef(M.xx,0,h.xx),Q.QM.FromArrayToRef(M.yy,0,h.yy),Q.QM.FromArrayToRef(M.zz,0,h.zz),Q.QM.FromArrayToRef(M.yz,0,h.yz),Q.QM.FromArrayToRef(M.zx,0,h.zx),Q.QM.FromArrayToRef(M.xy,0,h.xy),p._sphericalPolynomial=h}function e(p,b,M,h,Q){const mp=o(p.getEngine().createRawCubeTexture(null,p.width,p.format,p.type,p.generateMipMaps,p.invertY,p.samplingMode,p._compression),b).then((()=>p));return p.onRebuildCallback=p=>({proxy:mp,isReady:!0,isAsync:!0}),p._source=13,p._bufferViewArrayArray=b,p._lodGenerationScale=h,p._lodGenerationOffset=Q,p._sphericalPolynomial=M,o(p,b).then((()=>(p.isReady=!0,p)))}}}]);