"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[45],{12873:(P,f,Y)=>{Y.d(f,{e:()=>u,h:()=>M,i:()=>v,k:()=>c});var C=Y(11014),q=Y(11179),m=Y(11198),L=Y(11377),o=Y(11119),w=Y(11203),d=(Y(11429),Y(11283)),R=Y(11025);Y(11705),Y(11413),Y(11717);const y="image/png",r=2,i=[134,22,135,150,246,214,150,54];function u(P){const f=new DataView(P.buffer,P.byteOffset,P.byteLength);let Y=0;for(let L=0;L<i.length;L++)if(f.getUint8(Y++)!==i[L])return R.e.Error("Not a babylon environment map"),null;let C="",q=0;for(;q=f.getUint8(Y++);)C+=String.fromCharCode(q);let m=JSON.parse(C);return m=g(m),m.binaryDataPosition=Y,m.KR&&(m.KR.lodGenerationScale=m.KR.lodGenerationScale||.8),m}function g(P){if(P.version>r)throw new Error(`Unsupported babylon environment map version "${P.version}". Latest supported version is "${r}".`);return 2===P.version?P:P={...P,version:2,imageType:y}}function S(P,f){const Y=(f=g(f)).KR;let C=Math.log2(f.width);if(C=Math.round(C)+1,Y.mipmaps.length!==6*C)throw new Error(`Unsupported specular mipmaps number "${Y.mipmaps.length}"`);const q=new Array(C);for(let m=0;m<C;m++){q[m]=new Array(6);for(let C=0;C<6;C++){const L=Y.mipmaps[6*m+C];q[m][C]=new Uint8Array(P.buffer,P.byteOffset+f.binaryDataPosition+L.position,L.length)}}return q}function K(P,f){var Y;f=g(f);const C=new Array(6),q=null===(Y=f.irradiance)||void 0===Y?void 0:Y.irradianceTexture;if(q){if(6!==q.faces.length)throw new Error(`Incorrect irradiance texture faces number "${q.faces.length}"`);for(let Y=0;Y<6;Y++){const m=q.faces[Y];C[Y]=new Uint8Array(P.buffer,P.byteOffset+f.binaryDataPosition+m.position,m.length)}}return C}function M(P,f,Y){var C;const m=(Y=g(Y)).KR;if(!m)return Promise.resolve([]);P._lodGenerationScale=m.lodGenerationScale;const L=[],o=S(f,Y);L.push(O(P,o,Y.imageType));const w=null===(C=Y.irradiance)||void 0===C?void 0:C.irradianceTexture;if(w){var d,R;const C=K(f,Y);let m=null;null!==(d=Y.irradiance)&&void 0!==d&&null!==(R=d.irradianceTexture)&&void 0!==R&&R.dominantDirection&&(m=q.Of.ef(Y.irradiance.irradianceTexture.dominantDirection)),L.push(n(P,C,w.size,Y.imageType,m))}return Promise.all(L)}async function V(P,f,Y,C,q,m,L,o,w,d,R){return await new Promise(((y,r)=>{if(Y){const Y=f.createTexture(null,!0,!0,null,1,null,(P=>{r(P)}),P);null===C||void 0===C||C.onEffectCreatedObservable.addOnce((o=>{o.executeWhenCompiled((()=>{C.externalTextureSamplerBinding=!0,C.onApply=C=>{C._bindTexture("textureSampler",Y),C.setFloat2("scale",1,f._features.needsInvertingBitmap&&P instanceof ImageBitmap?-1:1)},f.scenes.length&&(f.scenes[0].postProcessManager.directRender([C],d,!0,m,L),f.restoreDefaultFramebuffer(),Y.dispose(),URL.revokeObjectURL(q),y())}))}))}else{if(f._uploadImageToTexture(R,P,m,L),o){const Y=w[L];Y&&f._uploadImageToTexture(Y._texture,P,m,0)}y()}}))}async function O(P,f){let Y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:y;const C=P.getEngine();P.format=5,P.type=0,P.generateMipMaps=!0,P._cachedAnisotropicFilteringLevel=null,C.updateTextureSamplingMode(3,P),await l(P,f,!0,Y),P.isReady=!0}async function n(P,f,Y){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const m=P.getEngine(),L=new o.b(m,5),d=new w.d(m,L);P._irradianceTexture=d,d._dominantDirection=q,L.isCube=!0,L.format=5,L.type=0,L.generateMipMaps=!0,L._cachedAnisotropicFilteringLevel=null,L.generateMipMaps=!0,L.width=Y,L.height=Y,m.updateTextureSamplingMode(3,L),await l(L,[f],!1,C),m.generateMipMapsForCubemap(L),L.isReady=!0}async function l(P,f,q){let L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:y;if(!C.Tools.IsExponentOfTwo(P.width))throw new Error("Texture size must be a power of two");const R=(0,m.ILog2)(P.width)+1,r=P.getEngine();let i=!1,u=!1,g=null,S=null,K=null;const M=r.getCaps();M.textureLOD?r._features.supportRenderAndCopyToLodForFloatTextures?M.textureHalfFloatRender&&M.textureHalfFloatLinearFiltering?(i=!0,P.type=2):M.textureFloatRender&&M.textureFloatLinearFiltering&&(i=!0,P.type=1):i=!1:(i=!1,u=q);let O=0;if(i)r.isWebGPU?(O=1,await Y.e(42).then(Y.bind(Y,14218))):await Y.e(35).then(Y.bind(Y,14220)),g=new d.c("rgbdDecode","rgbdDecode",null,null,1,null,3,r,!1,void 0,P.type,void 0,null,!1,void 0,O),P._isRGBD=!1,P.invertY=!1,S=r.createRenderTargetCubeTexture(P.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:P.type,format:5});else if(P._isRGBD=!0,P.invertY=!0,u){const f=3;K={};const Y=P._lodGenerationScale,C=P._lodGenerationOffset;for(let q=0;q<f;q++){const m=(R-1)*Y+C,L=C+(m-C)*(1-q/(f-1)),d=Math.round(Math.min(Math.max(L,0),m)),y=new o.b(r,2);y.isCube=!0,y.invertY=!0,y.generateMipMaps=!1,r.updateTextureSamplingMode(2,y);const i=new w.d(null);switch(i._isCube=!0,i._texture=y,K[d]=i,q){case 0:P._lodTextureLow=i;break;case 1:P._lodTextureMid=i;break;case 2:P._lodTextureHigh=i}}}const n=[];for(let Y=0;Y<f.length;Y++)for(let C=0;C<6;C++){const q=f[Y][C],m=new Blob([q],{type:L}),o=URL.createObjectURL(m);let w;if(r._features.forceBitmapOverHTMLImageElement)w=r.createImageBitmap(m,{premultiplyAlpha:"none"}).then((async f=>await V(f,r,i,g,o,C,Y,u,K,S,P)));else{const f=new Image;f.src=o,w=new Promise(((q,m)=>{f.onload=()=>{V(f,r,i,g,o,C,Y,u,K,S,P).then((()=>q())).catch((P=>{m(P)}))},f.onerror=P=>{m(P)}}))}n.push(w)}if(await Promise.all(n),f.length<R){let Y;const C=Math.pow(2,R-1-f.length),q=C*C*4;switch(P.type){case 0:Y=new Uint8Array(q);break;case 2:Y=new Uint16Array(q);break;case 1:Y=new Float32Array(q)}for(let m=f.length;m<R;m++)for(let f=0;f<6;f++){var l;r._uploadArrayBufferViewToTexture((null===(l=S)||void 0===l?void 0:l.texture)||P,Y,f,m)}}if(S){const f=P._irradianceTexture;P._irradianceTexture=null,r._releaseTexture(P),S._swapAndDie(P),P._irradianceTexture=f}g&&g.dispose(),u&&(P._lodTextureHigh&&P._lodTextureHigh._texture&&(P._lodTextureHigh._texture.isReady=!0),P._lodTextureMid&&P._lodTextureMid._texture&&(P._lodTextureMid._texture.isReady=!0),P._lodTextureLow&&P._lodTextureLow._texture&&(P._lodTextureLow._texture.isReady=!0))}function v(P,f){const Y=(f=g(f)).irradiance;if(!Y)return;const C=new L.f;q.Of.FromArrayToRef(Y.x,0,C.x),q.Of.FromArrayToRef(Y.y,0,C.y),q.Of.FromArrayToRef(Y.z,0,C.z),q.Of.FromArrayToRef(Y.xx,0,C.xx),q.Of.FromArrayToRef(Y.yy,0,C.yy),q.Of.FromArrayToRef(Y.zz,0,C.zz),q.Of.FromArrayToRef(Y.yz,0,C.yz),q.Of.FromArrayToRef(Y.zx,0,C.zx),q.Of.FromArrayToRef(Y.xy,0,C.xy),P._sphericalPolynomial=C}function c(P,f,Y,C,q){const m=O(P.getEngine().createRawCubeTexture(null,P.width,P.format,P.type,P.generateMipMaps,P.invertY,P.samplingMode,P._compression),f).then((()=>P));return P.onRebuildCallback=P=>({proxy:m,isReady:!0,isAsync:!0}),P._source=13,P._bufferViewArrayArray=f,P._lodGenerationScale=C,P._lodGenerationOffset=q,P._sphericalPolynomial=Y,O(P,f).then((()=>(P.isReady=!0,P)))}}}]);