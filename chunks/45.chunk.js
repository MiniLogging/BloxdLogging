"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[45],{12949:(K,H,M)=>{M.d(H,{b:()=>v,e:()=>B,g:()=>l,k:()=>s});var q=M(11100),w=M(11290),u=M(11307),y=M(11472),h=M(11216),W=M(11309),I=(M(11522),M(11393)),f=M(11112);M(11790),M(11502),M(11800);const z="image/png",G=2,a=[134,22,135,150,246,214,150,54];function v(K){const H=new DataView(K.buffer,K.byteOffset,K.byteLength);let M=0;for(let y=0;y<a.length;y++)if(H.getUint8(M++)!==a[y])return f.e.Error("Not a babylon environment map"),null;let q="",w=0;for(;w=H.getUint8(M++);)q+=String.fromCharCode(w);let u=JSON.parse(q);return u=O(u),u.binaryDataPosition=M,u.Vf&&(u.Vf.lodGenerationScale=u.Vf.lodGenerationScale||.8),u}function O(K){if(K.version>G)throw new Error(`Unsupported babylon environment map version "${K.version}". Latest supported version is "${G}".`);return 2===K.version?K:K={...K,version:2,imageType:z}}function L(K,H){const M=(H=O(H)).Vf;let q=Math.log2(H.width);if(q=Math.round(q)+1,M.mipmaps.length!==6*q)throw new Error(`Unsupported specular mipmaps number "${M.mipmaps.length}"`);const w=new Array(q);for(let u=0;u<q;u++){w[u]=new Array(6);for(let q=0;q<6;q++){const y=M.mipmaps[6*u+q];w[u][q]=new Uint8Array(K.buffer,K.byteOffset+H.binaryDataPosition+y.position,y.length)}}return w}function S(K,H){var M;H=O(H);const q=new Array(6),w=null===(M=H.irradiance)||void 0===M?void 0:M.irradianceTexture;if(w){if(6!==w.faces.length)throw new Error(`Incorrect irradiance texture faces number "${w.faces.length}"`);for(let M=0;M<6;M++){const u=w.faces[M];q[M]=new Uint8Array(K.buffer,K.byteOffset+H.binaryDataPosition+u.position,u.length)}}return q}function B(K,H,M){var q;const u=(M=O(M)).Vf;if(!u)return Promise.resolve([]);K._lodGenerationScale=u.lodGenerationScale;const y=[],h=L(H,M);y.push(i(K,h,M.imageType));const W=null===(q=M.irradiance)||void 0===q?void 0:q.irradianceTexture;if(W){var I,f;const q=S(H,M);let u=null;null!==(I=M.irradiance)&&void 0!==I&&null!==(f=I.irradianceTexture)&&void 0!==f&&f.dominantDirection&&(u=w.OH.iH(M.irradiance.irradianceTexture.dominantDirection)),y.push(Z(K,q,W.size,M.imageType,u))}return Promise.all(y)}async function C(K,H,M,q,w,u,y,h,W,I,f){return await new Promise(((z,G)=>{if(M){const M=H.createTexture(null,!0,!0,null,1,null,(K=>{G(K)}),K);null===q||void 0===q||q.onEffectCreatedObservable.addOnce((h=>{h.executeWhenCompiled((()=>{q.externalTextureSamplerBinding=!0,q.onApply=q=>{q._bindTexture("textureSampler",M),q.setFloat2("scale",1,H._features.needsInvertingBitmap&&K instanceof ImageBitmap?-1:1)},H.scenes.length&&(H.scenes[0].postProcessManager.directRender([q],I,!0,u,y),H.restoreDefaultFramebuffer(),M.dispose(),URL.revokeObjectURL(w),z())}))}))}else{if(H._uploadImageToTexture(f,K,u,y),h){const M=W[y];M&&H._uploadImageToTexture(M._texture,K,u,0)}z()}}))}async function i(K,H){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:z;const q=K.getEngine();K.format=5,K.type=0,K.generateMipMaps=!0,K._cachedAnisotropicFilteringLevel=null,q.updateTextureSamplingMode(3,K),await E(K,H,!0,M),K.isReady=!0}async function Z(K,H,M){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z,w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const u=K.getEngine(),y=new h.d(u,5),I=new W.b(u,y);K._irradianceTexture=I,I._dominantDirection=w,y.isCube=!0,y.format=5,y.type=0,y.generateMipMaps=!0,y._cachedAnisotropicFilteringLevel=null,y.generateMipMaps=!0,y.width=M,y.height=M,u.updateTextureSamplingMode(3,y),await E(y,[H],!1,q),u.generateMipMapsForCubemap(y),y.isReady=!0}async function E(K,H,w){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:z;if(!q.Tools.IsExponentOfTwo(K.width))throw new Error("Texture size must be a power of two");const f=(0,u.ILog2)(K.width)+1,G=K.getEngine();let a=!1,v=!1,O=null,L=null,S=null;const B=G.getCaps();B.textureLOD?G._features.supportRenderAndCopyToLodForFloatTextures?B.textureHalfFloatRender&&B.textureHalfFloatLinearFiltering?(a=!0,K.type=2):B.textureFloatRender&&B.textureFloatLinearFiltering&&(a=!0,K.type=1):a=!1:(a=!1,v=w);let i=0;if(a)G.isWebGPU?(i=1,await M.e(42).then(M.bind(M,14281))):await M.e(35).then(M.bind(M,14286)),O=new I.d("rgbdDecode","rgbdDecode",null,null,1,null,3,G,!1,void 0,K.type,void 0,null,!1,void 0,i),K._isRGBD=!1,K.invertY=!1,L=G.createRenderTargetCubeTexture(K.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:K.type,format:5});else if(K._isRGBD=!0,K.invertY=!0,v){const H=3;S={};const M=K._lodGenerationScale,q=K._lodGenerationOffset;for(let w=0;w<H;w++){const u=(f-1)*M+q,y=q+(u-q)*(1-w/(H-1)),I=Math.round(Math.min(Math.max(y,0),u)),z=new h.d(G,2);z.isCube=!0,z.invertY=!0,z.generateMipMaps=!1,G.updateTextureSamplingMode(2,z);const a=new W.b(null);switch(a._isCube=!0,a._texture=z,S[I]=a,w){case 0:K._lodTextureLow=a;break;case 1:K._lodTextureMid=a;break;case 2:K._lodTextureHigh=a}}}const Z=[];for(let M=0;M<H.length;M++)for(let q=0;q<6;q++){const w=H[M][q],u=new Blob([w],{type:y}),h=URL.createObjectURL(u);let W;if(G._features.forceBitmapOverHTMLImageElement)W=G.createImageBitmap(u,{premultiplyAlpha:"none"}).then((async H=>await C(H,G,a,O,h,q,M,v,S,L,K)));else{const H=new Image;H.src=h,W=new Promise(((w,u)=>{H.onload=()=>{C(H,G,a,O,h,q,M,v,S,L,K).then((()=>w())).catch((K=>{u(K)}))},H.onerror=K=>{u(K)}}))}Z.push(W)}if(await Promise.all(Z),H.length<f){let M;const q=Math.pow(2,f-1-H.length),w=q*q*4;switch(K.type){case 0:M=new Uint8Array(w);break;case 2:M=new Uint16Array(w);break;case 1:M=new Float32Array(w)}for(let u=H.length;u<f;u++)for(let H=0;H<6;H++){var E;G._uploadArrayBufferViewToTexture((null===(E=L)||void 0===E?void 0:E.texture)||K,M,H,u)}}if(L){const H=K._irradianceTexture;K._irradianceTexture=null,G._releaseTexture(K),L._swapAndDie(K),K._irradianceTexture=H}O&&O.dispose(),v&&(K._lodTextureHigh&&K._lodTextureHigh._texture&&(K._lodTextureHigh._texture.isReady=!0),K._lodTextureMid&&K._lodTextureMid._texture&&(K._lodTextureMid._texture.isReady=!0),K._lodTextureLow&&K._lodTextureLow._texture&&(K._lodTextureLow._texture.isReady=!0))}function l(K,H){const M=(H=O(H)).irradiance;if(!M)return;const q=new y.e;w.OH.FromArrayToRef(M.x,0,q.x),w.OH.FromArrayToRef(M.y,0,q.y),w.OH.FromArrayToRef(M.z,0,q.z),w.OH.FromArrayToRef(M.xx,0,q.xx),w.OH.FromArrayToRef(M.yy,0,q.yy),w.OH.FromArrayToRef(M.zz,0,q.zz),w.OH.FromArrayToRef(M.yz,0,q.yz),w.OH.FromArrayToRef(M.zx,0,q.zx),w.OH.FromArrayToRef(M.xy,0,q.xy),K._sphericalPolynomial=q}function s(K,H,M,q,w){const u=i(K.getEngine().createRawCubeTexture(null,K.width,K.format,K.type,K.generateMipMaps,K.invertY,K.samplingMode,K._compression),H).then((()=>K));return K.onRebuildCallback=K=>({proxy:u,isReady:!0,isAsync:!0}),K._source=13,K._bufferViewArrayArray=H,K._lodGenerationScale=q,K._lodGenerationOffset=w,K._sphericalPolynomial=M,i(K,H).then((()=>(K.isReady=!0,K)))}}}]);