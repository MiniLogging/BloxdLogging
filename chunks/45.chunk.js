"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[45],{12925:(V,I,A)=>{A.d(I,{d:()=>w,g:()=>g,j:()=>s,k:()=>e});var B=A(11052),F=A(11231),E=A(11249),Y=A(11416),H=A(11167),c=A(11251),b=(A(11473),A(11325)),X=A(11064);A(11770),A(11454),A(11777);const P="image/png",J=2,G=[134,22,135,150,246,214,150,54];function w(V){const I=new DataView(V.buffer,V.byteOffset,V.byteLength);let A=0;for(let Y=0;Y<G.length;Y++)if(I.getUint8(A++)!==G[Y])return X.b.Error("Not a babylon environment map"),null;let B="",F=0;for(;F=I.getUint8(A++);)B+=String.fromCharCode(F);let E=JSON.parse(B);return E=t(E),E.binaryDataPosition=A,E.QP&&(E.QP.lodGenerationScale=E.QP.lodGenerationScale||.8),E}function t(V){if(V.version>J)throw new Error(`Unsupported babylon environment map version "${V.version}". Latest supported version is "${J}".`);return 2===V.version?V:V={...V,version:2,imageType:P}}function u(V,I){const A=(I=t(I)).QP;let B=Math.log2(I.width);if(B=Math.round(B)+1,A.mipmaps.length!==6*B)throw new Error(`Unsupported specular mipmaps number "${A.mipmaps.length}"`);const F=new Array(B);for(let E=0;E<B;E++){F[E]=new Array(6);for(let B=0;B<6;B++){const Y=A.mipmaps[6*E+B];F[E][B]=new Uint8Array(V.buffer,V.byteOffset+I.binaryDataPosition+Y.position,Y.length)}}return F}function W(V,I){var A;I=t(I);const B=new Array(6),F=null===(A=I.irradiance)||void 0===A?void 0:A.irradianceTexture;if(F){if(6!==F.faces.length)throw new Error(`Incorrect irradiance texture faces number "${F.faces.length}"`);for(let A=0;A<6;A++){const E=F.faces[A];B[A]=new Uint8Array(V.buffer,V.byteOffset+I.binaryDataPosition+E.position,E.length)}}return B}function g(V,I,A){var B;const E=(A=t(A)).QP;if(!E)return Promise.resolve([]);V._lodGenerationScale=E.lodGenerationScale;const Y=[],H=u(I,A);Y.push(L(V,H,A.imageType));const c=null===(B=A.irradiance)||void 0===B?void 0:B.irradianceTexture;if(c){var b,X;const B=W(I,A);let E=null;null!==(b=A.irradiance)&&void 0!==b&&null!==(X=b.irradianceTexture)&&void 0!==X&&X.dominantDirection&&(E=F.tI.LI(A.irradiance.irradianceTexture.dominantDirection)),Y.push(z(V,B,c.size,A.imageType,E))}return Promise.all(Y)}async function o(V,I,A,B,F,E,Y,H,c,b,X){return await new Promise(((P,J)=>{if(A){const A=I.createTexture(null,!0,!0,null,1,null,(V=>{J(V)}),V);null===B||void 0===B||B.onEffectCreatedObservable.addOnce((H=>{H.executeWhenCompiled((()=>{B.externalTextureSamplerBinding=!0,B.onApply=B=>{B._bindTexture("textureSampler",A),B.setFloat2("scale",1,I._features.needsInvertingBitmap&&V instanceof ImageBitmap?-1:1)},I.scenes.length&&(I.scenes[0].postProcessManager.directRender([B],b,!0,E,Y),I.restoreDefaultFramebuffer(),A.dispose(),URL.revokeObjectURL(F),P())}))}))}else{if(I._uploadImageToTexture(X,V,E,Y),H){const A=c[Y];A&&I._uploadImageToTexture(A._texture,V,E,0)}P()}}))}async function L(V,I){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:P;const B=V.getEngine();V.format=5,V.type=0,V.generateMipMaps=!0,V._cachedAnisotropicFilteringLevel=null,B.updateTextureSamplingMode(3,V),await m(V,I,!0,A),V.isReady=!0}async function z(V,I,A){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P,F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const E=V.getEngine(),Y=new H.d(E,5),b=new c.b(E,Y);V._irradianceTexture=b,b._dominantDirection=F,Y.isCube=!0,Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,Y.generateMipMaps=!0,Y.width=A,Y.height=A,E.updateTextureSamplingMode(3,Y),await m(Y,[I],!1,B),E.generateMipMapsForCubemap(Y),Y.isReady=!0}async function m(V,I,F){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P;if(!B.Tools.IsExponentOfTwo(V.width))throw new Error("Texture size must be a power of two");const X=(0,E.ILog2)(V.width)+1,J=V.getEngine();let G=!1,w=!1,t=null,u=null,W=null;const g=J.getCaps();g.textureLOD?J._features.supportRenderAndCopyToLodForFloatTextures?g.textureHalfFloatRender&&g.textureHalfFloatLinearFiltering?(G=!0,V.type=2):g.textureFloatRender&&g.textureFloatLinearFiltering&&(G=!0,V.type=1):G=!1:(G=!1,w=F);let L=0;if(G)J.isWebGPU?(L=1,await A.e(42).then(A.bind(A,14170))):await A.e(35).then(A.bind(A,14176)),t=new b.d("rgbdDecode","rgbdDecode",null,null,1,null,3,J,!1,void 0,V.type,void 0,null,!1,void 0,L),V._isRGBD=!1,V.invertY=!1,u=J.createRenderTargetCubeTexture(V.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:V.type,format:5});else if(V._isRGBD=!0,V.invertY=!0,w){const I=3;W={};const A=V._lodGenerationScale,B=V._lodGenerationOffset;for(let F=0;F<I;F++){const E=(X-1)*A+B,Y=B+(E-B)*(1-F/(I-1)),b=Math.round(Math.min(Math.max(Y,0),E)),P=new H.d(J,2);P.isCube=!0,P.invertY=!0,P.generateMipMaps=!1,J.updateTextureSamplingMode(2,P);const G=new c.b(null);switch(G._isCube=!0,G._texture=P,W[b]=G,F){case 0:V._lodTextureLow=G;break;case 1:V._lodTextureMid=G;break;case 2:V._lodTextureHigh=G}}}const z=[];for(let A=0;A<I.length;A++)for(let B=0;B<6;B++){const F=I[A][B],E=new Blob([F],{type:Y}),H=URL.createObjectURL(E);let c;if(J._features.forceBitmapOverHTMLImageElement)c=J.createImageBitmap(E,{premultiplyAlpha:"none"}).then((async I=>await o(I,J,G,t,H,B,A,w,W,u,V)));else{const I=new Image;I.src=H,c=new Promise(((F,E)=>{I.onload=()=>{o(I,J,G,t,H,B,A,w,W,u,V).then((()=>F())).catch((V=>{E(V)}))},I.onerror=V=>{E(V)}}))}z.push(c)}if(await Promise.all(z),I.length<X){let A;const B=Math.pow(2,X-1-I.length),F=B*B*4;switch(V.type){case 0:A=new Uint8Array(F);break;case 2:A=new Uint16Array(F);break;case 1:A=new Float32Array(F)}for(let E=I.length;E<X;E++)for(let I=0;I<6;I++){var m;J._uploadArrayBufferViewToTexture((null===(m=u)||void 0===m?void 0:m.texture)||V,A,I,E)}}if(u){const I=V._irradianceTexture;V._irradianceTexture=null,J._releaseTexture(V),u._swapAndDie(V),V._irradianceTexture=I}t&&t.dispose(),w&&(V._lodTextureHigh&&V._lodTextureHigh._texture&&(V._lodTextureHigh._texture.isReady=!0),V._lodTextureMid&&V._lodTextureMid._texture&&(V._lodTextureMid._texture.isReady=!0),V._lodTextureLow&&V._lodTextureLow._texture&&(V._lodTextureLow._texture.isReady=!0))}function s(V,I){const A=(I=t(I)).irradiance;if(!A)return;const B=new Y.h;F.tI.FromArrayToRef(A.x,0,B.x),F.tI.FromArrayToRef(A.y,0,B.y),F.tI.FromArrayToRef(A.z,0,B.z),F.tI.FromArrayToRef(A.xx,0,B.xx),F.tI.FromArrayToRef(A.yy,0,B.yy),F.tI.FromArrayToRef(A.zz,0,B.zz),F.tI.FromArrayToRef(A.yz,0,B.yz),F.tI.FromArrayToRef(A.zx,0,B.zx),F.tI.FromArrayToRef(A.xy,0,B.xy),V._sphericalPolynomial=B}function e(V,I,A,B,F){const E=L(V.getEngine().createRawCubeTexture(null,V.width,V.format,V.type,V.generateMipMaps,V.invertY,V.samplingMode,V._compression),I).then((()=>V));return V.onRebuildCallback=V=>({proxy:E,isReady:!0,isAsync:!0}),V._source=13,V._bufferViewArrayArray=I,V._lodGenerationScale=B,V._lodGenerationOffset=F,V._sphericalPolynomial=A,L(V,I).then((()=>(V.isReady=!0,V)))}}}]);