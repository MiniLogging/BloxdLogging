"use strict";(self.ynu1yiqvs98=self.ynu1yiqvs98||[]).push([[45],{12772:(I,E,j)=>{j.d(E,{b:()=>K,e:()=>X,i:()=>Q,k:()=>G});var e=j(10953),w=j(11117),z=j(11136),h=j(11307),t=j(11056),U=j(11139),R=(j(11363),j(11227)),P=j(10974);j(11613),j(11345),j(11624);const o="image/png",Z=2,c=[134,22,135,150,246,214,150,54];function K(I){const E=new DataView(I.buffer,I.byteOffset,I.byteLength);let j=0;for(let h=0;h<c.length;h++)if(E.getUint8(j++)!==c[h])return P.b.Error("Not a babylon environment map"),null;let e="",w=0;for(;w=E.getUint8(j++);)e+=String.fromCharCode(w);let z=JSON.parse(e);return z=L(z),z.binaryDataPosition=j,z.qP&&(z.qP.lodGenerationScale=z.qP.lodGenerationScale||.8),z}function L(I){if(I.version>Z)throw new Error(`Unsupported babylon environment map version "${I.version}". Latest supported version is "${Z}".`);return 2===I.version?I:I={...I,version:2,imageType:o}}function F(I,E){const j=(E=L(E)).qP;let e=Math.log2(E.width);if(e=Math.round(e)+1,j.mipmaps.length!==6*e)throw new Error(`Unsupported specular mipmaps number "${j.mipmaps.length}"`);const w=new Array(e);for(let z=0;z<e;z++){w[z]=new Array(6);for(let e=0;e<6;e++){const h=j.mipmaps[6*z+e];w[z][e]=new Uint8Array(I.buffer,I.byteOffset+E.binaryDataPosition+h.position,h.length)}}return w}function C(I,E){var j;E=L(E);const e=new Array(6),w=null===(j=E.irradiance)||void 0===j?void 0:j.irradianceTexture;if(w){if(6!==w.faces.length)throw new Error(`Incorrect irradiance texture faces number "${w.faces.length}"`);for(let j=0;j<6;j++){const z=w.faces[j];e[j]=new Uint8Array(I.buffer,I.byteOffset+E.binaryDataPosition+z.position,z.length)}}return e}function X(I,E,j){var e;const z=(j=L(j)).qP;if(!z)return Promise.resolve([]);I._lodGenerationScale=z.lodGenerationScale;const h=[],t=F(E,j);h.push(x(I,t,j.imageType));const U=null===(e=j.irradiance)||void 0===e?void 0:e.irradianceTexture;if(U){var R,P;const e=C(E,j);let z=null;null!==(R=j.irradiance)&&void 0!==R&&null!==(P=R.irradianceTexture)&&void 0!==P&&P.dominantDirection&&(z=w.LE.xE(j.irradiance.irradianceTexture.dominantDirection)),h.push(u(I,e,U.size,j.imageType,z))}return Promise.all(h)}async function q(I,E,j,e,w,z,h,t,U,R,P){return await new Promise(((o,Z)=>{if(j){const j=E.createTexture(null,!0,!0,null,1,null,(I=>{Z(I)}),I);null===e||void 0===e||e.onEffectCreatedObservable.addOnce((t=>{t.executeWhenCompiled((()=>{e.externalTextureSamplerBinding=!0,e.onApply=e=>{e._bindTexture("textureSampler",j),e.setFloat2("scale",1,E._features.needsInvertingBitmap&&I instanceof ImageBitmap?-1:1)},E.scenes.length&&(E.scenes[0].postProcessManager.directRender([e],R,!0,z,h),E.restoreDefaultFramebuffer(),j.dispose(),URL.revokeObjectURL(w),o())}))}))}else{if(E._uploadImageToTexture(P,I,z,h),t){const j=U[h];j&&E._uploadImageToTexture(j._texture,I,z,0)}o()}}))}async function x(I,E){let j=arguments.length>2&&void 0!==arguments[2]?arguments[2]:o;const e=I.getEngine();I.format=5,I.type=0,I.generateMipMaps=!0,I._cachedAnisotropicFilteringLevel=null,e.updateTextureSamplingMode(3,I),await b(I,E,!0,j),I.isReady=!0}async function u(I,E,j){let e=arguments.length>3&&void 0!==arguments[3]?arguments[3]:o,w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const z=I.getEngine(),h=new t.e(z,5),R=new U.d(z,h);I._irradianceTexture=R,R._dominantDirection=w,h.isCube=!0,h.format=5,h.type=0,h.generateMipMaps=!0,h._cachedAnisotropicFilteringLevel=null,h.generateMipMaps=!0,h.width=j,h.height=j,z.updateTextureSamplingMode(3,h),await b(h,[E],!1,e),z.generateMipMapsForCubemap(h),h.isReady=!0}async function b(I,E,w){let h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:o;if(!e.Tools.IsExponentOfTwo(I.width))throw new Error("Texture size must be a power of two");const P=(0,z.ILog2)(I.width)+1,Z=I.getEngine();let c=!1,K=!1,L=null,F=null,C=null;const X=Z.getCaps();X.textureLOD?Z._features.supportRenderAndCopyToLodForFloatTextures?X.textureHalfFloatRender&&X.textureHalfFloatLinearFiltering?(c=!0,I.type=2):X.textureFloatRender&&X.textureFloatLinearFiltering&&(c=!0,I.type=1):c=!1:(c=!1,K=w);let x=0;if(c)Z.isWebGPU?(x=1,await j.e(42).then(j.bind(j,14163))):await j.e(35).then(j.bind(j,14172)),L=new R.c("rgbdDecode","rgbdDecode",null,null,1,null,3,Z,!1,void 0,I.type,void 0,null,!1,void 0,x),I._isRGBD=!1,I.invertY=!1,F=Z.createRenderTargetCubeTexture(I.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:I.type,format:5});else if(I._isRGBD=!0,I.invertY=!0,K){const E=3;C={};const j=I._lodGenerationScale,e=I._lodGenerationOffset;for(let w=0;w<E;w++){const z=(P-1)*j+e,h=e+(z-e)*(1-w/(E-1)),R=Math.round(Math.min(Math.max(h,0),z)),o=new t.e(Z,2);o.isCube=!0,o.invertY=!0,o.generateMipMaps=!1,Z.updateTextureSamplingMode(2,o);const c=new U.d(null);switch(c._isCube=!0,c._texture=o,C[R]=c,w){case 0:I._lodTextureLow=c;break;case 1:I._lodTextureMid=c;break;case 2:I._lodTextureHigh=c}}}const u=[];for(let j=0;j<E.length;j++)for(let e=0;e<6;e++){const w=E[j][e],z=new Blob([w],{type:h}),t=URL.createObjectURL(z);let U;if(Z._features.forceBitmapOverHTMLImageElement)U=Z.createImageBitmap(z,{premultiplyAlpha:"none"}).then((async E=>await q(E,Z,c,L,t,e,j,K,C,F,I)));else{const E=new Image;E.src=t,U=new Promise(((w,z)=>{E.onload=()=>{q(E,Z,c,L,t,e,j,K,C,F,I).then((()=>w())).catch((I=>{z(I)}))},E.onerror=I=>{z(I)}}))}u.push(U)}if(await Promise.all(u),E.length<P){let j;const e=Math.pow(2,P-1-E.length),w=e*e*4;switch(I.type){case 0:j=new Uint8Array(w);break;case 2:j=new Uint16Array(w);break;case 1:j=new Float32Array(w)}for(let z=E.length;z<P;z++)for(let E=0;E<6;E++){var b;Z._uploadArrayBufferViewToTexture((null===(b=F)||void 0===b?void 0:b.texture)||I,j,E,z)}}if(F){const E=I._irradianceTexture;I._irradianceTexture=null,Z._releaseTexture(I),F._swapAndDie(I),I._irradianceTexture=E}L&&L.dispose(),K&&(I._lodTextureHigh&&I._lodTextureHigh._texture&&(I._lodTextureHigh._texture.isReady=!0),I._lodTextureMid&&I._lodTextureMid._texture&&(I._lodTextureMid._texture.isReady=!0),I._lodTextureLow&&I._lodTextureLow._texture&&(I._lodTextureLow._texture.isReady=!0))}function Q(I,E){const j=(E=L(E)).irradiance;if(!j)return;const e=new h.d;w.LE.FromArrayToRef(j.x,0,e.x),w.LE.FromArrayToRef(j.y,0,e.y),w.LE.FromArrayToRef(j.z,0,e.z),w.LE.FromArrayToRef(j.xx,0,e.xx),w.LE.FromArrayToRef(j.yy,0,e.yy),w.LE.FromArrayToRef(j.zz,0,e.zz),w.LE.FromArrayToRef(j.yz,0,e.yz),w.LE.FromArrayToRef(j.zx,0,e.zx),w.LE.FromArrayToRef(j.xy,0,e.xy),I._sphericalPolynomial=e}function G(I,E,j,e,w){const z=x(I.getEngine().createRawCubeTexture(null,I.width,I.format,I.type,I.generateMipMaps,I.invertY,I.samplingMode,I._compression),E).then((()=>I));return I.onRebuildCallback=I=>({proxy:z,isReady:!0,isAsync:!0}),I._source=13,I._bufferViewArrayArray=E,I._lodGenerationScale=e,I._lodGenerationOffset=w,I._sphericalPolynomial=j,x(I,E).then((()=>(I.isReady=!0,I)))}}}]);