"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[45],{13802:(t,U,y)=>{y.d(U,{b:()=>F,c:()=>l,g:()=>c,h:()=>f});var I=y(12198),r=y(12386),Y=y(12404),mt=y(12597),X=y(12320),P=y(12413),G=(y(12653),y(12501)),M=y(12221);y(12925),y(12635),y(12941);const L="image/png",h=2,Q=[134,22,135,150,246,214,150,54];function F(t){const U=new DataView(t.buffer,t.byteOffset,t.byteLength);let y=0;for(let mt=0;mt<Q.length;mt++)if(U.getUint8(y++)!==Q[mt])return M.b.Error("Not a babylon environment map"),null;let I="",r=0;for(;r=U.getUint8(y++);)I+=String.fromCharCode(r);let Y=JSON.parse(I);return Y=E(Y),Y.binaryDataPosition=y,Y.BM&&(Y.BM.lodGenerationScale=Y.BM.lodGenerationScale||.8),Y}function E(t){if(t.version>h)throw new Error(`Unsupported babylon environment map version "${t.version}". Latest supported version is "${h}".`);return 2===t.version?t:t={...t,version:2,imageType:L}}function w(t,U){const y=(U=E(U)).BM;let I=Math.log2(U.width);if(I=Math.round(I)+1,y.mipmaps.length!==6*I)throw new Error(`Unsupported specular mipmaps number "${y.mipmaps.length}"`);const r=new Array(I);for(let Y=0;Y<I;Y++){r[Y]=new Array(6);for(let I=0;I<6;I++){const mt=y.mipmaps[6*Y+I];r[Y][I]=new Uint8Array(t.buffer,t.byteOffset+U.binaryDataPosition+mt.position,mt.length)}}return r}function D(t,U){var y;U=E(U);const I=new Array(6),r=null===(y=U.irradiance)||void 0===y?void 0:y.irradianceTexture;if(r){if(6!==r.faces.length)throw new Error(`Incorrect irradiance texture faces number "${r.faces.length}"`);for(let y=0;y<6;y++){const Y=r.faces[y];I[y]=new Uint8Array(t.buffer,t.byteOffset+U.binaryDataPosition+Y.position,Y.length)}}return I}function l(t,U,y){var I;const Y=(y=E(y)).BM;if(!Y)return Promise.resolve([]);t._lodGenerationScale=Y.lodGenerationScale;const mt=[],X=w(U,y);mt.push(B(t,X,y.imageType));const P=null===(I=y.irradiance)||void 0===I?void 0:I.irradianceTexture;if(P){var G,M;const I=D(U,y);let Y=null;null!==(G=y.irradiance)&&void 0!==G&&null!==(M=G.irradianceTexture)&&void 0!==M&&M.dominantDirection&&(Y=r.DU.pU(y.irradiance.irradianceTexture.dominantDirection)),mt.push(b(t,I,P.size,y.imageType,Y))}return Promise.all(mt)}async function g(t,U,y,I,r,Y,mt,X,P,G,M){return await new Promise(((L,h)=>{if(y){const y=U.createTexture(null,!0,!0,null,1,null,(t=>{h(t)}),t);null===I||void 0===I||I.onEffectCreatedObservable.addOnce((X=>{X.executeWhenCompiled((()=>{I.externalTextureSamplerBinding=!0,I.onApply=I=>{I._bindTexture("textureSampler",y),I.setFloat2("scale",1,U._features.needsInvertingBitmap&&t instanceof ImageBitmap?-1:1)},U.scenes.length&&(U.scenes[0].postProcessManager.directRender([I],G,!0,Y,mt),U.restoreDefaultFramebuffer(),y.dispose(),URL.revokeObjectURL(r),L())}))}))}else{if(U._uploadImageToTexture(M,t,Y,mt),X){const y=P[mt];y&&U._uploadImageToTexture(y._texture,t,Y,0)}L()}}))}async function B(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:L;const I=t.getEngine();t.format=5,t.type=0,t.generateMipMaps=!0,t._cachedAnisotropicFilteringLevel=null,I.updateTextureSamplingMode(3,t),await p(t,U,!0,y),t.isReady=!0}async function b(t,U,y){let I=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const Y=t.getEngine(),mt=new X.e(Y,5),G=new P.d(Y,mt);t._irradianceTexture=G,G._dominantDirection=r,mt.isCube=!0,mt.format=5,mt.type=0,mt.generateMipMaps=!0,mt._cachedAnisotropicFilteringLevel=null,mt.generateMipMaps=!0,mt.width=y,mt.height=y,Y.updateTextureSamplingMode(3,mt),await p(mt,[U],!1,I),Y.generateMipMapsForCubemap(mt),mt.isReady=!0}async function p(t,U,r){let mt=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L;if(!I.Tools.IsExponentOfTwo(t.width))throw new Error("Texture size must be a power of two");const M=(0,Y.ILog2)(t.width)+1,h=t.getEngine();let Q=!1,F=!1,E=null,w=null,D=null;const l=h.getCaps();l.textureLOD?h._features.supportRenderAndCopyToLodForFloatTextures?l.textureHalfFloatRender&&l.textureHalfFloatLinearFiltering?(Q=!0,t.type=2):l.textureFloatRender&&l.textureFloatLinearFiltering&&(Q=!0,t.type=1):Q=!1:(Q=!1,F=r);let B=0;if(Q)h.isWebGPU?(B=1,await y.e(42).then(y.bind(y,15189))):await y.e(35).then(y.bind(y,15194)),E=new G.e("rgbdDecode","rgbdDecode",null,null,1,null,3,h,!1,void 0,t.type,void 0,null,!1,void 0,B),t._isRGBD=!1,t.invertY=!1,w=h.createRenderTargetCubeTexture(t.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:t.type,format:5});else if(t._isRGBD=!0,t.invertY=!0,F){const U=3;D={};const y=t._lodGenerationScale,I=t._lodGenerationOffset;for(let r=0;r<U;r++){const Y=(M-1)*y+I,mt=I+(Y-I)*(1-r/(U-1)),G=Math.round(Math.min(Math.max(mt,0),Y)),L=new X.e(h,2);L.isCube=!0,L.invertY=!0,L.generateMipMaps=!1,h.updateTextureSamplingMode(2,L);const Q=new P.d(null);switch(Q._isCube=!0,Q._texture=L,D[G]=Q,r){case 0:t._lodTextureLow=Q;break;case 1:t._lodTextureMid=Q;break;case 2:t._lodTextureHigh=Q}}}const b=[];for(let y=0;y<U.length;y++)for(let I=0;I<6;I++){const r=U[y][I],Y=new Blob([r],{type:mt}),X=URL.createObjectURL(Y);let P;if(h._features.forceBitmapOverHTMLImageElement)P=h.createImageBitmap(Y,{premultiplyAlpha:"none"}).then((async U=>await g(U,h,Q,E,X,I,y,F,D,w,t)));else{const U=new Image;U.src=X,P=new Promise(((r,Y)=>{U.onload=()=>{g(U,h,Q,E,X,I,y,F,D,w,t).then((()=>r())).catch((t=>{Y(t)}))},U.onerror=t=>{Y(t)}}))}b.push(P)}if(await Promise.all(b),U.length<M){let y;const I=Math.pow(2,M-1-U.length),r=I*I*4;switch(t.type){case 0:y=new Uint8Array(r);break;case 2:y=new Uint16Array(r);break;case 1:y=new Float32Array(r)}for(let Y=U.length;Y<M;Y++)for(let U=0;U<6;U++){var p;h._uploadArrayBufferViewToTexture((null===(p=w)||void 0===p?void 0:p.texture)||t,y,U,Y)}}if(w){const U=t._irradianceTexture;t._irradianceTexture=null,h._releaseTexture(t),w._swapAndDie(t),t._irradianceTexture=U}E&&E.dispose(),F&&(t._lodTextureHigh&&t._lodTextureHigh._texture&&(t._lodTextureHigh._texture.isReady=!0),t._lodTextureMid&&t._lodTextureMid._texture&&(t._lodTextureMid._texture.isReady=!0),t._lodTextureLow&&t._lodTextureLow._texture&&(t._lodTextureLow._texture.isReady=!0))}function c(t,U){const y=(U=E(U)).irradiance;if(!y)return;const I=new mt.e;r.DU.FromArrayToRef(y.x,0,I.x),r.DU.FromArrayToRef(y.y,0,I.y),r.DU.FromArrayToRef(y.z,0,I.z),r.DU.FromArrayToRef(y.xx,0,I.xx),r.DU.FromArrayToRef(y.yy,0,I.yy),r.DU.FromArrayToRef(y.zz,0,I.zz),r.DU.FromArrayToRef(y.yz,0,I.yz),r.DU.FromArrayToRef(y.zx,0,I.zx),r.DU.FromArrayToRef(y.xy,0,I.xy),t._sphericalPolynomial=I}function f(t,U,y,I,r){const Y=B(t.getEngine().createRawCubeTexture(null,t.width,t.format,t.type,t.generateMipMaps,t.invertY,t.samplingMode,t._compression),U).then((()=>t));return t.onRebuildCallback=t=>({proxy:Y,isReady:!0,isAsync:!0}),t._source=13,t._bufferViewArrayArray=U,t._lodGenerationScale=I,t._lodGenerationOffset=r,t._sphericalPolynomial=y,B(t,U).then((()=>(t.isReady=!0,t)))}}}]);