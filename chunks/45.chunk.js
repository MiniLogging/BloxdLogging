"use strict";(self["80dd64vgxnn"]=self["80dd64vgxnn"]||[]).push([[45],{14226:(mm,o,u)=>{u.d(o,{d:()=>H,e:()=>t,g:()=>S,h:()=>P});var f=u(12549),B=u(12740),O=u(12752),r=u(12912),w=u(12675),p=u(12760),K=(u(12965),u(12839)),z=u(12565);u(13205),u(12946),u(13220);const Y="image/png",q=2,x=[134,22,135,150,246,214,150,54];function H(mm){const o=new DataView(mm.buffer,mm.byteOffset,mm.byteLength);let u=0;for(let r=0;r<x.length;r++)if(o.getUint8(u++)!==x[r])return z.e.Error("Not a babylon environment map"),null;let f="",B=0;for(;B=o.getUint8(u++);)f+=String.fromCharCode(B);let O=JSON.parse(f);return O=E(O),O.binaryDataPosition=u,O.fY&&(O.fY.lodGenerationScale=O.fY.lodGenerationScale||.8),O}function E(mm){if(mm.version>q)throw new Error(`Unsupported babylon environment map version "${mm.version}". Latest supported version is "${q}".`);return 2===mm.version?mm:mm={...mm,version:2,imageType:Y}}function M(mm,o){const u=(o=E(o)).fY;let f=Math.log2(o.width);if(f=Math.round(f)+1,u.mipmaps.length!==6*f)throw new Error(`Unsupported specular mipmaps number "${u.mipmaps.length}"`);const B=new Array(f);for(let O=0;O<f;O++){B[O]=new Array(6);for(let f=0;f<6;f++){const r=u.mipmaps[6*O+f];B[O][f]=new Uint8Array(mm.buffer,mm.byteOffset+o.binaryDataPosition+r.position,r.length)}}return B}function l(mm,o){var u;o=E(o);const f=new Array(6),B=null===(u=o.irradiance)||void 0===u?void 0:u.irradianceTexture;if(B){if(6!==B.faces.length)throw new Error(`Incorrect irradiance texture faces number "${B.faces.length}"`);for(let u=0;u<6;u++){const O=B.faces[u];f[u]=new Uint8Array(mm.buffer,mm.byteOffset+o.binaryDataPosition+O.position,O.length)}}return f}function t(mm,o,u){var f;const O=(u=E(u)).fY;if(!O)return Promise.resolve([]);mm._lodGenerationScale=O.lodGenerationScale;const r=[],w=M(o,u);r.push(b(mm,w,u.imageType));const p=null===(f=u.irradiance)||void 0===f?void 0:f.irradianceTexture;if(p){var K,z;const f=l(o,u);let O=null;null!==(K=u.irradiance)&&void 0!==K&&null!==(z=K.irradianceTexture)&&void 0!==z&&z.dominantDirection&&(O=B.lo.So(u.irradiance.irradianceTexture.dominantDirection)),r.push(J(mm,f,p.size,u.imageType,O))}return Promise.all(r)}async function Q(mm,o,u,f,B,O,r,w,p,K,z){return await new Promise(((Y,q)=>{if(u){const u=o.createTexture(null,!0,!0,null,1,null,(mm=>{q(mm)}),mm);null===f||void 0===f||f.onEffectCreatedObservable.addOnce((w=>{w.executeWhenCompiled((()=>{f.externalTextureSamplerBinding=!0,f.onApply=f=>{f._bindTexture("textureSampler",u),f.setFloat2("scale",1,o._features.needsInvertingBitmap&&mm instanceof ImageBitmap?-1:1)},o.scenes.length&&(o.scenes[0].postProcessManager.directRender([f],K,!0,O,r),o.restoreDefaultFramebuffer(),u.dispose(),URL.revokeObjectURL(B),Y())}))}))}else{if(o._uploadImageToTexture(z,mm,O,r),w){const u=p[r];u&&o._uploadImageToTexture(u._texture,mm,O,0)}Y()}}))}async function b(mm,o){let u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Y;const f=mm.getEngine();mm.format=5,mm.type=0,mm.generateMipMaps=!0,mm._cachedAnisotropicFilteringLevel=null,f.updateTextureSamplingMode(3,mm),await N(mm,o,!0,u),mm.isReady=!0}async function J(mm,o,u){let f=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y,B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const O=mm.getEngine(),r=new w.e(O,5),K=new p.c(O,r);mm._irradianceTexture=K,K._dominantDirection=B,r.isCube=!0,r.format=5,r.type=0,r.generateMipMaps=!0,r._cachedAnisotropicFilteringLevel=null,r.generateMipMaps=!0,r.width=u,r.height=u,O.updateTextureSamplingMode(3,r),await N(r,[o],!1,f),O.generateMipMapsForCubemap(r),r.isReady=!0}async function N(mm,o,B){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Y;if(!f.Tools.IsExponentOfTwo(mm.width))throw new Error("Texture size must be a power of two");const z=(0,O.ILog2)(mm.width)+1,q=mm.getEngine();let x=!1,H=!1,E=null,M=null,l=null;const t=q.getCaps();t.textureLOD?q._features.supportRenderAndCopyToLodForFloatTextures?t.textureHalfFloatRender&&t.textureHalfFloatLinearFiltering?(x=!0,mm.type=2):t.textureFloatRender&&t.textureFloatLinearFiltering&&(x=!0,mm.type=1):x=!1:(x=!1,H=B);let b=0;if(x)q.isWebGPU?(b=1,await u.e(42).then(u.bind(u,15641))):await u.e(35).then(u.bind(u,15646)),E=new K.d("rgbdDecode","rgbdDecode",null,null,1,null,3,q,!1,void 0,mm.type,void 0,null,!1,void 0,b),mm._isRGBD=!1,mm.invertY=!1,M=q.createRenderTargetCubeTexture(mm.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:mm.type,format:5});else if(mm._isRGBD=!0,mm.invertY=!0,H){const o=3;l={};const u=mm._lodGenerationScale,f=mm._lodGenerationOffset;for(let B=0;B<o;B++){const O=(z-1)*u+f,r=f+(O-f)*(1-B/(o-1)),K=Math.round(Math.min(Math.max(r,0),O)),Y=new w.e(q,2);Y.isCube=!0,Y.invertY=!0,Y.generateMipMaps=!1,q.updateTextureSamplingMode(2,Y);const x=new p.c(null);switch(x._isCube=!0,x._texture=Y,l[K]=x,B){case 0:mm._lodTextureLow=x;break;case 1:mm._lodTextureMid=x;break;case 2:mm._lodTextureHigh=x}}}const J=[];for(let u=0;u<o.length;u++)for(let f=0;f<6;f++){const B=o[u][f],O=new Blob([B],{type:r}),w=URL.createObjectURL(O);let p;if(q._features.forceBitmapOverHTMLImageElement)p=q.createImageBitmap(O,{premultiplyAlpha:"none"}).then((async o=>await Q(o,q,x,E,w,f,u,H,l,M,mm)));else{const o=new Image;o.src=w,p=new Promise(((B,O)=>{o.onload=()=>{Q(o,q,x,E,w,f,u,H,l,M,mm).then((()=>B())).catch((mm=>{O(mm)}))},o.onerror=mm=>{O(mm)}}))}J.push(p)}if(await Promise.all(J),o.length<z){let u;const f=Math.pow(2,z-1-o.length),B=f*f*4;switch(mm.type){case 0:u=new Uint8Array(B);break;case 2:u=new Uint16Array(B);break;case 1:u=new Float32Array(B)}for(let O=o.length;O<z;O++)for(let o=0;o<6;o++){var N;q._uploadArrayBufferViewToTexture((null===(N=M)||void 0===N?void 0:N.texture)||mm,u,o,O)}}if(M){const o=mm._irradianceTexture;mm._irradianceTexture=null,q._releaseTexture(mm),M._swapAndDie(mm),mm._irradianceTexture=o}E&&E.dispose(),H&&(mm._lodTextureHigh&&mm._lodTextureHigh._texture&&(mm._lodTextureHigh._texture.isReady=!0),mm._lodTextureMid&&mm._lodTextureMid._texture&&(mm._lodTextureMid._texture.isReady=!0),mm._lodTextureLow&&mm._lodTextureLow._texture&&(mm._lodTextureLow._texture.isReady=!0))}function S(mm,o){const u=(o=E(o)).irradiance;if(!u)return;const f=new r.c;B.lo.FromArrayToRef(u.x,0,f.x),B.lo.FromArrayToRef(u.y,0,f.y),B.lo.FromArrayToRef(u.z,0,f.z),B.lo.FromArrayToRef(u.xx,0,f.xx),B.lo.FromArrayToRef(u.yy,0,f.yy),B.lo.FromArrayToRef(u.zz,0,f.zz),B.lo.FromArrayToRef(u.yz,0,f.yz),B.lo.FromArrayToRef(u.zx,0,f.zx),B.lo.FromArrayToRef(u.xy,0,f.xy),mm._sphericalPolynomial=f}function P(mm,o,u,f,B){const O=b(mm.getEngine().createRawCubeTexture(null,mm.width,mm.format,mm.type,mm.generateMipMaps,mm.invertY,mm.samplingMode,mm._compression),o).then((()=>mm));return mm.onRebuildCallback=mm=>({proxy:O,isReady:!0,isAsync:!0}),mm._source=13,mm._bufferViewArrayArray=o,mm._lodGenerationScale=f,mm._lodGenerationOffset=B,mm._sphericalPolynomial=u,b(mm,o).then((()=>(mm.isReady=!0,mm)))}}}]);