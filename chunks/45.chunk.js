"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[45],{13831:(I,O,C)=>{C.d(O,{e:()=>q,i:()=>r,k:()=>n,l:()=>X});var j=C(12083),K=C(12272),i=C(12282),y=C(12447),S=C(12201),U=C(12284),p=(C(12487),C(12363)),N=C(12103);C(12734),C(12468),C(12746);const Q="image/png",s=2,Z=[134,22,135,150,246,214,150,54];function q(I){const O=new DataView(I.buffer,I.byteOffset,I.byteLength);let C=0;for(let y=0;y<Z.length;y++)if(O.getUint8(C++)!==Z[y])return N.c.Error("Not a babylon environment map"),null;let j="",K=0;for(;K=O.getUint8(C++);)j+=String.fromCharCode(K);let i=JSON.parse(j);return i=mI(i),i.binaryDataPosition=C,i.ZN&&(i.ZN.lodGenerationScale=i.ZN.lodGenerationScale||.8),i}function mI(I){if(I.version>s)throw new Error(`Unsupported babylon environment map version "${I.version}". Latest supported version is "${s}".`);return 2===I.version?I:I={...I,version:2,imageType:Q}}function E(I,O){const C=(O=mI(O)).ZN;let j=Math.log2(O.width);if(j=Math.round(j)+1,C.mipmaps.length!==6*j)throw new Error(`Unsupported specular mipmaps number "${C.mipmaps.length}"`);const K=new Array(j);for(let i=0;i<j;i++){K[i]=new Array(6);for(let j=0;j<6;j++){const y=C.mipmaps[6*i+j];K[i][j]=new Uint8Array(I.buffer,I.byteOffset+O.binaryDataPosition+y.position,y.length)}}return K}function h(I,O){var C;O=mI(O);const j=new Array(6),K=null===(C=O.irradiance)||void 0===C?void 0:C.irradianceTexture;if(K){if(6!==K.faces.length)throw new Error(`Incorrect irradiance texture faces number "${K.faces.length}"`);for(let C=0;C<6;C++){const i=K.faces[C];j[C]=new Uint8Array(I.buffer,I.byteOffset+O.binaryDataPosition+i.position,i.length)}}return j}function r(I,O,C){var j;const i=(C=mI(C)).ZN;if(!i)return Promise.resolve([]);I._lodGenerationScale=i.lodGenerationScale;const y=[],S=E(O,C);y.push(Y(I,S,C.imageType));const U=null===(j=C.irradiance)||void 0===j?void 0:j.irradianceTexture;if(U){var p,N;const j=h(O,C);let i=null;null!==(p=C.irradiance)&&void 0!==p&&null!==(N=p.irradianceTexture)&&void 0!==N&&N.dominantDirection&&(i=K.mC.YO(C.irradiance.irradianceTexture.dominantDirection)),y.push(o(I,j,U.size,C.imageType,i))}return Promise.all(y)}async function W(I,O,C,j,K,i,y,S,U,p,N){return await new Promise(((Q,s)=>{if(C){const C=O.createTexture(null,!0,!0,null,1,null,(I=>{s(I)}),I);null===j||void 0===j||j.onEffectCreatedObservable.addOnce((S=>{S.executeWhenCompiled((()=>{j.externalTextureSamplerBinding=!0,j.onApply=j=>{j._bindTexture("textureSampler",C),j.setFloat2("scale",1,O._features.needsInvertingBitmap&&I instanceof ImageBitmap?-1:1)},O.scenes.length&&(O.scenes[0].postProcessManager.directRender([j],p,!0,i,y),O.restoreDefaultFramebuffer(),C.dispose(),URL.revokeObjectURL(K),Q())}))}))}else{if(O._uploadImageToTexture(N,I,i,y),S){const C=U[y];C&&O._uploadImageToTexture(C._texture,I,i,0)}Q()}}))}async function Y(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Q;const j=I.getEngine();I.format=5,I.type=0,I.generateMipMaps=!0,I._cachedAnisotropicFilteringLevel=null,j.updateTextureSamplingMode(3,I),await c(I,O,!0,C),I.isReady=!0}async function o(I,O,C){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q,K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const i=I.getEngine(),y=new S.c(i,5),p=new U.c(i,y);I._irradianceTexture=p,p._dominantDirection=K,y.isCube=!0,y.format=5,y.type=0,y.generateMipMaps=!0,y._cachedAnisotropicFilteringLevel=null,y.generateMipMaps=!0,y.width=C,y.height=C,i.updateTextureSamplingMode(3,y),await c(y,[O],!1,j),i.generateMipMapsForCubemap(y),y.isReady=!0}async function c(I,O,K){let y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q;if(!j.Tools.IsExponentOfTwo(I.width))throw new Error("Texture size must be a power of two");const N=(0,i.ILog2)(I.width)+1,s=I.getEngine();let Z=!1,q=!1,mI=null,E=null,h=null;const r=s.getCaps();r.textureLOD?s._features.supportRenderAndCopyToLodForFloatTextures?r.textureHalfFloatRender&&r.textureHalfFloatLinearFiltering?(Z=!0,I.type=2):r.textureFloatRender&&r.textureFloatLinearFiltering&&(Z=!0,I.type=1):Z=!1:(Z=!1,q=K);let Y=0;if(Z)s.isWebGPU?(Y=1,await C.e(42).then(C.bind(C,15187))):await C.e(35).then(C.bind(C,15193)),mI=new p.c("rgbdDecode","rgbdDecode",null,null,1,null,3,s,!1,void 0,I.type,void 0,null,!1,void 0,Y),I._isRGBD=!1,I.invertY=!1,E=s.createRenderTargetCubeTexture(I.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:I.type,format:5});else if(I._isRGBD=!0,I.invertY=!0,q){const O=3;h={};const C=I._lodGenerationScale,j=I._lodGenerationOffset;for(let K=0;K<O;K++){const i=(N-1)*C+j,y=j+(i-j)*(1-K/(O-1)),p=Math.round(Math.min(Math.max(y,0),i)),Q=new S.c(s,2);Q.isCube=!0,Q.invertY=!0,Q.generateMipMaps=!1,s.updateTextureSamplingMode(2,Q);const Z=new U.c(null);switch(Z._isCube=!0,Z._texture=Q,h[p]=Z,K){case 0:I._lodTextureLow=Z;break;case 1:I._lodTextureMid=Z;break;case 2:I._lodTextureHigh=Z}}}const o=[];for(let C=0;C<O.length;C++)for(let j=0;j<6;j++){const K=O[C][j],i=new Blob([K],{type:y}),S=URL.createObjectURL(i);let U;if(s._features.forceBitmapOverHTMLImageElement)U=s.createImageBitmap(i,{premultiplyAlpha:"none"}).then((async O=>await W(O,s,Z,mI,S,j,C,q,h,E,I)));else{const O=new Image;O.src=S,U=new Promise(((K,i)=>{O.onload=()=>{W(O,s,Z,mI,S,j,C,q,h,E,I).then((()=>K())).catch((I=>{i(I)}))},O.onerror=I=>{i(I)}}))}o.push(U)}if(await Promise.all(o),O.length<N){let C;const j=Math.pow(2,N-1-O.length),K=j*j*4;switch(I.type){case 0:C=new Uint8Array(K);break;case 2:C=new Uint16Array(K);break;case 1:C=new Float32Array(K)}for(let i=O.length;i<N;i++)for(let O=0;O<6;O++){var c;s._uploadArrayBufferViewToTexture((null===(c=E)||void 0===c?void 0:c.texture)||I,C,O,i)}}if(E){const O=I._irradianceTexture;I._irradianceTexture=null,s._releaseTexture(I),E._swapAndDie(I),I._irradianceTexture=O}mI&&mI.dispose(),q&&(I._lodTextureHigh&&I._lodTextureHigh._texture&&(I._lodTextureHigh._texture.isReady=!0),I._lodTextureMid&&I._lodTextureMid._texture&&(I._lodTextureMid._texture.isReady=!0),I._lodTextureLow&&I._lodTextureLow._texture&&(I._lodTextureLow._texture.isReady=!0))}function n(I,O){const C=(O=mI(O)).irradiance;if(!C)return;const j=new y.f;K.mC.FromArrayToRef(C.x,0,j.x),K.mC.FromArrayToRef(C.y,0,j.y),K.mC.FromArrayToRef(C.z,0,j.z),K.mC.FromArrayToRef(C.xx,0,j.xx),K.mC.FromArrayToRef(C.yy,0,j.yy),K.mC.FromArrayToRef(C.zz,0,j.zz),K.mC.FromArrayToRef(C.yz,0,j.yz),K.mC.FromArrayToRef(C.zx,0,j.zx),K.mC.FromArrayToRef(C.xy,0,j.xy),I._sphericalPolynomial=j}function X(I,O,C,j,K){const i=Y(I.getEngine().createRawCubeTexture(null,I.width,I.format,I.type,I.generateMipMaps,I.invertY,I.samplingMode,I._compression),O).then((()=>I));return I.onRebuildCallback=I=>({proxy:i,isReady:!0,isAsync:!0}),I._source=13,I._bufferViewArrayArray=O,I._lodGenerationScale=j,I._lodGenerationOffset=K,I._sphericalPolynomial=C,Y(I,O).then((()=>(I.isReady=!0,I)))}}}]);