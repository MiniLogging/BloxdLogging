"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[45],{12790:(q,S,b)=>{b.d(S,{e:()=>G,g:()=>k,i:()=>T,m:()=>B});var z=b(10921),C=b(11103),v=b(11121),U=b(11291),g=b(11033),r=b(11128),I=(b(11339),b(11206)),V=b(10943);b(11607),b(11325),b(11622);const l="image/png",y=2,R=[134,22,135,150,246,214,150,54];function G(q){const S=new DataView(q.buffer,q.byteOffset,q.byteLength);let b=0;for(let U=0;U<R.length;U++)if(S.getUint8(b++)!==R[U])return V.b.Error("Not a babylon environment map"),null;let z="",C=0;for(;C=S.getUint8(b++);)z+=String.fromCharCode(C);let v=JSON.parse(z);return v=Z(v),v.binaryDataPosition=b,v.eV&&(v.eV.lodGenerationScale=v.eV.lodGenerationScale||.8),v}function Z(q){if(q.version>y)throw new Error(`Unsupported babylon environment map version "${q.version}". Latest supported version is "${y}".`);return 2===q.version?q:q={...q,version:2,imageType:l}}function H(q,S){const b=(S=Z(S)).eV;let z=Math.log2(S.width);if(z=Math.round(z)+1,b.mipmaps.length!==6*z)throw new Error(`Unsupported specular mipmaps number "${b.mipmaps.length}"`);const C=new Array(z);for(let v=0;v<z;v++){C[v]=new Array(6);for(let z=0;z<6;z++){const U=b.mipmaps[6*v+z];C[v][z]=new Uint8Array(q.buffer,q.byteOffset+S.binaryDataPosition+U.position,U.length)}}return C}function Q(q,S){var b;S=Z(S);const z=new Array(6),C=null===(b=S.irradiance)||void 0===b?void 0:b.irradianceTexture;if(C){if(6!==C.faces.length)throw new Error(`Incorrect irradiance texture faces number "${C.faces.length}"`);for(let b=0;b<6;b++){const v=C.faces[b];z[b]=new Uint8Array(q.buffer,q.byteOffset+S.binaryDataPosition+v.position,v.length)}}return z}function k(q,S,b){var z;const v=(b=Z(b)).eV;if(!v)return Promise.resolve([]);q._lodGenerationScale=v.lodGenerationScale;const U=[],g=H(S,b);U.push(N(q,g,b.imageType));const r=null===(z=b.irradiance)||void 0===z?void 0:z.irradianceTexture;if(r){var I,V;const z=Q(S,b);let v=null;null!==(I=b.irradiance)&&void 0!==I&&null!==(V=I.irradianceTexture)&&void 0!==V&&V.dominantDirection&&(v=C.yS.Hb(b.irradiance.irradianceTexture.dominantDirection)),U.push(u(q,z,r.size,b.imageType,v))}return Promise.all(U)}async function W(q,S,b,z,C,v,U,g,r,I,V){return await new Promise(((l,y)=>{if(b){const b=S.createTexture(null,!0,!0,null,1,null,(q=>{y(q)}),q);null===z||void 0===z||z.onEffectCreatedObservable.addOnce((g=>{g.executeWhenCompiled((()=>{z.externalTextureSamplerBinding=!0,z.onApply=z=>{z._bindTexture("textureSampler",b),z.setFloat2("scale",1,S._features.needsInvertingBitmap&&q instanceof ImageBitmap?-1:1)},S.scenes.length&&(S.scenes[0].postProcessManager.directRender([z],I,!0,v,U),S.restoreDefaultFramebuffer(),b.dispose(),URL.revokeObjectURL(C),l())}))}))}else{if(S._uploadImageToTexture(V,q,v,U),g){const b=r[U];b&&S._uploadImageToTexture(b._texture,q,v,0)}l()}}))}async function N(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:l;const z=q.getEngine();q.format=5,q.type=0,q.generateMipMaps=!0,q._cachedAnisotropicFilteringLevel=null,z.updateTextureSamplingMode(3,q),await X(q,S,!0,b),q.isReady=!0}async function u(q,S,b){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const v=q.getEngine(),U=new g.d(v,5),I=new r.d(v,U);q._irradianceTexture=I,I._dominantDirection=C,U.isCube=!0,U.format=5,U.type=0,U.generateMipMaps=!0,U._cachedAnisotropicFilteringLevel=null,U.generateMipMaps=!0,U.width=b,U.height=b,v.updateTextureSamplingMode(3,U),await X(U,[S],!1,z),v.generateMipMapsForCubemap(U),U.isReady=!0}async function X(q,S,C){let U=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l;if(!z.Tools.IsExponentOfTwo(q.width))throw new Error("Texture size must be a power of two");const V=(0,v.ILog2)(q.width)+1,y=q.getEngine();let R=!1,G=!1,Z=null,H=null,Q=null;const k=y.getCaps();k.textureLOD?y._features.supportRenderAndCopyToLodForFloatTextures?k.textureHalfFloatRender&&k.textureHalfFloatLinearFiltering?(R=!0,q.type=2):k.textureFloatRender&&k.textureFloatLinearFiltering&&(R=!0,q.type=1):R=!1:(R=!1,G=C);let N=0;if(R)y.isWebGPU?(N=1,await b.e(42).then(b.bind(b,14152))):await b.e(35).then(b.bind(b,14154)),Z=new I.d("rgbdDecode","rgbdDecode",null,null,1,null,3,y,!1,void 0,q.type,void 0,null,!1,void 0,N),q._isRGBD=!1,q.invertY=!1,H=y.createRenderTargetCubeTexture(q.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:q.type,format:5});else if(q._isRGBD=!0,q.invertY=!0,G){const S=3;Q={};const b=q._lodGenerationScale,z=q._lodGenerationOffset;for(let C=0;C<S;C++){const v=(V-1)*b+z,U=z+(v-z)*(1-C/(S-1)),I=Math.round(Math.min(Math.max(U,0),v)),l=new g.d(y,2);l.isCube=!0,l.invertY=!0,l.generateMipMaps=!1,y.updateTextureSamplingMode(2,l);const R=new r.d(null);switch(R._isCube=!0,R._texture=l,Q[I]=R,C){case 0:q._lodTextureLow=R;break;case 1:q._lodTextureMid=R;break;case 2:q._lodTextureHigh=R}}}const u=[];for(let b=0;b<S.length;b++)for(let z=0;z<6;z++){const C=S[b][z],v=new Blob([C],{type:U}),g=URL.createObjectURL(v);let r;if(y._features.forceBitmapOverHTMLImageElement)r=y.createImageBitmap(v,{premultiplyAlpha:"none"}).then((async S=>await W(S,y,R,Z,g,z,b,G,Q,H,q)));else{const S=new Image;S.src=g,r=new Promise(((C,v)=>{S.onload=()=>{W(S,y,R,Z,g,z,b,G,Q,H,q).then((()=>C())).catch((q=>{v(q)}))},S.onerror=q=>{v(q)}}))}u.push(r)}if(await Promise.all(u),S.length<V){let b;const z=Math.pow(2,V-1-S.length),C=z*z*4;switch(q.type){case 0:b=new Uint8Array(C);break;case 2:b=new Uint16Array(C);break;case 1:b=new Float32Array(C)}for(let v=S.length;v<V;v++)for(let S=0;S<6;S++){var X;y._uploadArrayBufferViewToTexture((null===(X=H)||void 0===X?void 0:X.texture)||q,b,S,v)}}if(H){const S=q._irradianceTexture;q._irradianceTexture=null,y._releaseTexture(q),H._swapAndDie(q),q._irradianceTexture=S}Z&&Z.dispose(),G&&(q._lodTextureHigh&&q._lodTextureHigh._texture&&(q._lodTextureHigh._texture.isReady=!0),q._lodTextureMid&&q._lodTextureMid._texture&&(q._lodTextureMid._texture.isReady=!0),q._lodTextureLow&&q._lodTextureLow._texture&&(q._lodTextureLow._texture.isReady=!0))}function T(q,S){const b=(S=Z(S)).irradiance;if(!b)return;const z=new U.c;C.yS.FromArrayToRef(b.x,0,z.x),C.yS.FromArrayToRef(b.y,0,z.y),C.yS.FromArrayToRef(b.z,0,z.z),C.yS.FromArrayToRef(b.xx,0,z.xx),C.yS.FromArrayToRef(b.yy,0,z.yy),C.yS.FromArrayToRef(b.zz,0,z.zz),C.yS.FromArrayToRef(b.yz,0,z.yz),C.yS.FromArrayToRef(b.zx,0,z.zx),C.yS.FromArrayToRef(b.xy,0,z.xy),q._sphericalPolynomial=z}function B(q,S,b,z,C){const v=N(q.getEngine().createRawCubeTexture(null,q.width,q.format,q.type,q.generateMipMaps,q.invertY,q.samplingMode,q._compression),S).then((()=>q));return q.onRebuildCallback=q=>({proxy:v,isReady:!0,isAsync:!0}),q._source=13,q._bufferViewArrayArray=S,q._lodGenerationScale=z,q._lodGenerationOffset=C,q._sphericalPolynomial=b,N(q,S).then((()=>(q.isReady=!0,q)))}}}]);