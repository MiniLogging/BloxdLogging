"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[45],{14067:(V,h,mV)=>{mV.d(h,{d:()=>R,h:()=>c,l:()=>D,m:()=>H});var t=mV(12253),L=mV(12422),N=mV(12435),A=mV(12597),k=mV(12359),C=mV(12438),K=(mV(12648),mV(12516)),o=mV(12264);mV(12894),mV(12625),mV(12907);const n="image/png",q=2,x=[134,22,135,150,246,214,150,54];function R(V){const h=new DataView(V.buffer,V.byteOffset,V.byteLength);let mV=0;for(let A=0;A<x.length;A++)if(h.getUint8(mV++)!==x[A])return o.e.Error("Not a babylon environment map"),null;let t="",L=0;for(;L=h.getUint8(mV++);)t+=String.fromCharCode(L);let N=JSON.parse(t);return N=d(N),N.binaryDataPosition=mV,N.so&&(N.so.lodGenerationScale=N.so.lodGenerationScale||.8),N}function d(V){if(V.version>q)throw new Error(`Unsupported babylon environment map version "${V.version}". Latest supported version is "${q}".`);return 2===V.version?V:V={...V,version:2,imageType:n}}function s(V,h){const mV=(h=d(h)).so;let t=Math.log2(h.width);if(t=Math.round(t)+1,mV.mipmaps.length!==6*t)throw new Error(`Unsupported specular mipmaps number "${mV.mipmaps.length}"`);const L=new Array(t);for(let N=0;N<t;N++){L[N]=new Array(6);for(let t=0;t<6;t++){const A=mV.mipmaps[6*N+t];L[N][t]=new Uint8Array(V.buffer,V.byteOffset+h.binaryDataPosition+A.position,A.length)}}return L}function M(V,h){var mV;h=d(h);const t=new Array(6),L=null===(mV=h.irradiance)||void 0===mV?void 0:mV.irradianceTexture;if(L){if(6!==L.faces.length)throw new Error(`Incorrect irradiance texture faces number "${L.faces.length}"`);for(let mV=0;mV<6;mV++){const N=L.faces[mV];t[mV]=new Uint8Array(V.buffer,V.byteOffset+h.binaryDataPosition+N.position,N.length)}}return t}function c(V,h,mV){var t;const N=(mV=d(mV)).so;if(!N)return Promise.resolve([]);V._lodGenerationScale=N.lodGenerationScale;const A=[],k=s(h,mV);A.push(Q(V,k,mV.imageType));const C=null===(t=mV.irradiance)||void 0===t?void 0:t.irradianceTexture;if(C){var K,o;const t=M(h,mV);let N=null;null!==(K=mV.irradiance)&&void 0!==K&&null!==(o=K.irradianceTexture)&&void 0!==o&&o.dominantDirection&&(N=L.sh.Dh(mV.irradiance.irradianceTexture.dominantDirection)),A.push(J(V,t,C.size,mV.imageType,N))}return Promise.all(A)}async function z(V,h,mV,t,L,N,A,k,C,K,o){return await new Promise(((n,q)=>{if(mV){const mV=h.createTexture(null,!0,!0,null,1,null,(V=>{q(V)}),V);null===t||void 0===t||t.onEffectCreatedObservable.addOnce((k=>{k.executeWhenCompiled((()=>{t.externalTextureSamplerBinding=!0,t.onApply=t=>{t._bindTexture("textureSampler",mV),t.setFloat2("scale",1,h._features.needsInvertingBitmap&&V instanceof ImageBitmap?-1:1)},h.scenes.length&&(h.scenes[0].postProcessManager.directRender([t],K,!0,N,A),h.restoreDefaultFramebuffer(),mV.dispose(),URL.revokeObjectURL(L),n())}))}))}else{if(h._uploadImageToTexture(o,V,N,A),k){const mV=C[A];mV&&h._uploadImageToTexture(mV._texture,V,N,0)}n()}}))}async function Q(V,h){let mV=arguments.length>2&&void 0!==arguments[2]?arguments[2]:n;const t=V.getEngine();V.format=5,V.type=0,V.generateMipMaps=!0,V._cachedAnisotropicFilteringLevel=null,t.updateTextureSamplingMode(3,V),await v(V,h,!0,mV),V.isReady=!0}async function J(V,h,mV){let t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const N=V.getEngine(),A=new k.d(N,5),K=new C.b(N,A);V._irradianceTexture=K,K._dominantDirection=L,A.isCube=!0,A.format=5,A.type=0,A.generateMipMaps=!0,A._cachedAnisotropicFilteringLevel=null,A.generateMipMaps=!0,A.width=mV,A.height=mV,N.updateTextureSamplingMode(3,A),await v(A,[h],!1,t),N.generateMipMapsForCubemap(A),A.isReady=!0}async function v(V,h,L){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:n;if(!t.Tools.IsExponentOfTwo(V.width))throw new Error("Texture size must be a power of two");const o=(0,N.ILog2)(V.width)+1,q=V.getEngine();let x=!1,R=!1,d=null,s=null,M=null;const c=q.getCaps();c.textureLOD?q._features.supportRenderAndCopyToLodForFloatTextures?c.textureHalfFloatRender&&c.textureHalfFloatLinearFiltering?(x=!0,V.type=2):c.textureFloatRender&&c.textureFloatLinearFiltering&&(x=!0,V.type=1):x=!1:(x=!1,R=L);let Q=0;if(x)q.isWebGPU?(Q=1,await mV.e(42).then(mV.bind(mV,15426))):await mV.e(35).then(mV.bind(mV,15428)),d=new K.c("rgbdDecode","rgbdDecode",null,null,1,null,3,q,!1,void 0,V.type,void 0,null,!1,void 0,Q),V._isRGBD=!1,V.invertY=!1,s=q.createRenderTargetCubeTexture(V.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:V.type,format:5});else if(V._isRGBD=!0,V.invertY=!0,R){const h=3;M={};const mV=V._lodGenerationScale,t=V._lodGenerationOffset;for(let L=0;L<h;L++){const N=(o-1)*mV+t,A=t+(N-t)*(1-L/(h-1)),K=Math.round(Math.min(Math.max(A,0),N)),n=new k.d(q,2);n.isCube=!0,n.invertY=!0,n.generateMipMaps=!1,q.updateTextureSamplingMode(2,n);const x=new C.b(null);switch(x._isCube=!0,x._texture=n,M[K]=x,L){case 0:V._lodTextureLow=x;break;case 1:V._lodTextureMid=x;break;case 2:V._lodTextureHigh=x}}}const J=[];for(let mV=0;mV<h.length;mV++)for(let t=0;t<6;t++){const L=h[mV][t],N=new Blob([L],{type:A}),k=URL.createObjectURL(N);let C;if(q._features.forceBitmapOverHTMLImageElement)C=q.createImageBitmap(N,{premultiplyAlpha:"none"}).then((async h=>await z(h,q,x,d,k,t,mV,R,M,s,V)));else{const h=new Image;h.src=k,C=new Promise(((L,N)=>{h.onload=()=>{z(h,q,x,d,k,t,mV,R,M,s,V).then((()=>L())).catch((V=>{N(V)}))},h.onerror=V=>{N(V)}}))}J.push(C)}if(await Promise.all(J),h.length<o){let mV;const t=Math.pow(2,o-1-h.length),L=t*t*4;switch(V.type){case 0:mV=new Uint8Array(L);break;case 2:mV=new Uint16Array(L);break;case 1:mV=new Float32Array(L)}for(let N=h.length;N<o;N++)for(let h=0;h<6;h++){var v;q._uploadArrayBufferViewToTexture((null===(v=s)||void 0===v?void 0:v.texture)||V,mV,h,N)}}if(s){const h=V._irradianceTexture;V._irradianceTexture=null,q._releaseTexture(V),s._swapAndDie(V),V._irradianceTexture=h}d&&d.dispose(),R&&(V._lodTextureHigh&&V._lodTextureHigh._texture&&(V._lodTextureHigh._texture.isReady=!0),V._lodTextureMid&&V._lodTextureMid._texture&&(V._lodTextureMid._texture.isReady=!0),V._lodTextureLow&&V._lodTextureLow._texture&&(V._lodTextureLow._texture.isReady=!0))}function D(V,h){const mV=(h=d(h)).irradiance;if(!mV)return;const t=new A.f;L.sh.FromArrayToRef(mV.x,0,t.x),L.sh.FromArrayToRef(mV.y,0,t.y),L.sh.FromArrayToRef(mV.z,0,t.z),L.sh.FromArrayToRef(mV.xx,0,t.xx),L.sh.FromArrayToRef(mV.yy,0,t.yy),L.sh.FromArrayToRef(mV.zz,0,t.zz),L.sh.FromArrayToRef(mV.yz,0,t.yz),L.sh.FromArrayToRef(mV.zx,0,t.zx),L.sh.FromArrayToRef(mV.xy,0,t.xy),V._sphericalPolynomial=t}function H(V,h,mV,t,L){const N=Q(V.getEngine().createRawCubeTexture(null,V.width,V.format,V.type,V.generateMipMaps,V.invertY,V.samplingMode,V._compression),h).then((()=>V));return V.onRebuildCallback=V=>({proxy:N,isReady:!0,isAsync:!0}),V._source=13,V._bufferViewArrayArray=h,V._lodGenerationScale=t,V._lodGenerationOffset=L,V._sphericalPolynomial=mV,Q(V,h).then((()=>(V.isReady=!0,V)))}}}]);