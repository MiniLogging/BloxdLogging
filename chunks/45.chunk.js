"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[45],{14309:(L,U,x)=>{x.d(U,{e:()=>Y,i:()=>Q,k:()=>P,n:()=>d});var mL=x(12382),p=x(12589),G=x(12610),F=x(12773),a=x(12521),o=x(12613),A=(x(12820),x(12686)),r=x(12406);x(13110),x(12803),x(13122);const h="image/png",b=2,E=[134,22,135,150,246,214,150,54];function Y(L){const U=new DataView(L.buffer,L.byteOffset,L.byteLength);let x=0;for(let F=0;F<E.length;F++)if(U.getUint8(x++)!==E[F])return r.c.Error("Not a babylon environment map"),null;let mL="",p=0;for(;p=U.getUint8(x++);)mL+=String.fromCharCode(p);let G=JSON.parse(mL);return G=S(G),G.binaryDataPosition=x,G.Pr&&(G.Pr.lodGenerationScale=G.Pr.lodGenerationScale||.8),G}function S(L){if(L.version>b)throw new Error(`Unsupported babylon environment map version "${L.version}". Latest supported version is "${b}".`);return 2===L.version?L:L={...L,version:2,imageType:h}}function V(L,U){const x=(U=S(U)).Pr;let mL=Math.log2(U.width);if(mL=Math.round(mL)+1,x.mipmaps.length!==6*mL)throw new Error(`Unsupported specular mipmaps number "${x.mipmaps.length}"`);const p=new Array(mL);for(let G=0;G<mL;G++){p[G]=new Array(6);for(let mL=0;mL<6;mL++){const F=x.mipmaps[6*G+mL];p[G][mL]=new Uint8Array(L.buffer,L.byteOffset+U.binaryDataPosition+F.position,F.length)}}return p}function H(L,U){var x;U=S(U);const mL=new Array(6),p=null===(x=U.irradiance)||void 0===x?void 0:x.irradianceTexture;if(p){if(6!==p.faces.length)throw new Error(`Incorrect irradiance texture faces number "${p.faces.length}"`);for(let x=0;x<6;x++){const G=p.faces[x];mL[x]=new Uint8Array(L.buffer,L.byteOffset+U.binaryDataPosition+G.position,G.length)}}return mL}function Q(L,U,x){var mL;const G=(x=S(x)).Pr;if(!G)return Promise.resolve([]);L._lodGenerationScale=G.lodGenerationScale;const F=[],a=V(U,x);F.push(f(L,a,x.imageType));const o=null===(mL=x.irradiance)||void 0===mL?void 0:mL.irradianceTexture;if(o){var A,r;const mL=H(U,x);let G=null;null!==(A=x.irradiance)&&void 0!==A&&null!==(r=A.irradianceTexture)&&void 0!==r&&r.dominantDirection&&(G=p.YU.qU(x.irradiance.irradianceTexture.dominantDirection)),F.push(v(L,mL,o.size,x.imageType,G))}return Promise.all(F)}async function q(L,U,x,mL,p,G,F,a,o,A,r){return await new Promise(((h,b)=>{if(x){const x=U.createTexture(null,!0,!0,null,1,null,(L=>{b(L)}),L);null===mL||void 0===mL||mL.onEffectCreatedObservable.addOnce((a=>{a.executeWhenCompiled((()=>{mL.externalTextureSamplerBinding=!0,mL.onApply=mL=>{mL._bindTexture("textureSampler",x),mL.setFloat2("scale",1,U._features.needsInvertingBitmap&&L instanceof ImageBitmap?-1:1)},U.scenes.length&&(U.scenes[0].postProcessManager.directRender([mL],A,!0,G,F),U.restoreDefaultFramebuffer(),x.dispose(),URL.revokeObjectURL(p),h())}))}))}else{if(U._uploadImageToTexture(r,L,G,F),a){const x=o[F];x&&U._uploadImageToTexture(x._texture,L,G,0)}h()}}))}async function f(L,U){let x=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h;const mL=L.getEngine();L.format=5,L.type=0,L.generateMipMaps=!0,L._cachedAnisotropicFilteringLevel=null,mL.updateTextureSamplingMode(3,L),await D(L,U,!0,x),L.isReady=!0}async function v(L,U,x){let mL=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h,p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const G=L.getEngine(),F=new a.d(G,5),A=new o.e(G,F);L._irradianceTexture=A,A._dominantDirection=p,F.isCube=!0,F.format=5,F.type=0,F.generateMipMaps=!0,F._cachedAnisotropicFilteringLevel=null,F.generateMipMaps=!0,F.width=x,F.height=x,G.updateTextureSamplingMode(3,F),await D(F,[U],!1,mL),G.generateMipMapsForCubemap(F),F.isReady=!0}async function D(L,U,p){let F=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h;if(!mL.Tools.IsExponentOfTwo(L.width))throw new Error("Texture size must be a power of two");const r=(0,G.ILog2)(L.width)+1,b=L.getEngine();let E=!1,Y=!1,S=null,V=null,H=null;const Q=b.getCaps();Q.textureLOD?b._features.supportRenderAndCopyToLodForFloatTextures?Q.textureHalfFloatRender&&Q.textureHalfFloatLinearFiltering?(E=!0,L.type=2):Q.textureFloatRender&&Q.textureFloatLinearFiltering&&(E=!0,L.type=1):E=!1:(E=!1,Y=p);let f=0;if(E)b.isWebGPU?(f=1,await x.e(42).then(x.bind(x,15668))):await x.e(35).then(x.bind(x,15673)),S=new A.e("rgbdDecode","rgbdDecode",null,null,1,null,3,b,!1,void 0,L.type,void 0,null,!1,void 0,f),L._isRGBD=!1,L.invertY=!1,V=b.createRenderTargetCubeTexture(L.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:L.type,format:5});else if(L._isRGBD=!0,L.invertY=!0,Y){const U=3;H={};const x=L._lodGenerationScale,mL=L._lodGenerationOffset;for(let p=0;p<U;p++){const G=(r-1)*x+mL,F=mL+(G-mL)*(1-p/(U-1)),A=Math.round(Math.min(Math.max(F,0),G)),h=new a.d(b,2);h.isCube=!0,h.invertY=!0,h.generateMipMaps=!1,b.updateTextureSamplingMode(2,h);const E=new o.e(null);switch(E._isCube=!0,E._texture=h,H[A]=E,p){case 0:L._lodTextureLow=E;break;case 1:L._lodTextureMid=E;break;case 2:L._lodTextureHigh=E}}}const v=[];for(let x=0;x<U.length;x++)for(let mL=0;mL<6;mL++){const p=U[x][mL],G=new Blob([p],{type:F}),a=URL.createObjectURL(G);let o;if(b._features.forceBitmapOverHTMLImageElement)o=b.createImageBitmap(G,{premultiplyAlpha:"none"}).then((async U=>await q(U,b,E,S,a,mL,x,Y,H,V,L)));else{const U=new Image;U.src=a,o=new Promise(((p,G)=>{U.onload=()=>{q(U,b,E,S,a,mL,x,Y,H,V,L).then((()=>p())).catch((L=>{G(L)}))},U.onerror=L=>{G(L)}}))}v.push(o)}if(await Promise.all(v),U.length<r){let x;const mL=Math.pow(2,r-1-U.length),p=mL*mL*4;switch(L.type){case 0:x=new Uint8Array(p);break;case 2:x=new Uint16Array(p);break;case 1:x=new Float32Array(p)}for(let G=U.length;G<r;G++)for(let U=0;U<6;U++){var D;b._uploadArrayBufferViewToTexture((null===(D=V)||void 0===D?void 0:D.texture)||L,x,U,G)}}if(V){const U=L._irradianceTexture;L._irradianceTexture=null,b._releaseTexture(L),V._swapAndDie(L),L._irradianceTexture=U}S&&S.dispose(),Y&&(L._lodTextureHigh&&L._lodTextureHigh._texture&&(L._lodTextureHigh._texture.isReady=!0),L._lodTextureMid&&L._lodTextureMid._texture&&(L._lodTextureMid._texture.isReady=!0),L._lodTextureLow&&L._lodTextureLow._texture&&(L._lodTextureLow._texture.isReady=!0))}function P(L,U){const x=(U=S(U)).irradiance;if(!x)return;const mL=new F.d;p.YU.FromArrayToRef(x.x,0,mL.x),p.YU.FromArrayToRef(x.y,0,mL.y),p.YU.FromArrayToRef(x.z,0,mL.z),p.YU.FromArrayToRef(x.xx,0,mL.xx),p.YU.FromArrayToRef(x.yy,0,mL.yy),p.YU.FromArrayToRef(x.zz,0,mL.zz),p.YU.FromArrayToRef(x.yz,0,mL.yz),p.YU.FromArrayToRef(x.zx,0,mL.zx),p.YU.FromArrayToRef(x.xy,0,mL.xy),L._sphericalPolynomial=mL}function d(L,U,x,mL,p){const G=f(L.getEngine().createRawCubeTexture(null,L.width,L.format,L.type,L.generateMipMaps,L.invertY,L.samplingMode,L._compression),U).then((()=>L));return L.onRebuildCallback=L=>({proxy:G,isReady:!0,isAsync:!0}),L._source=13,L._bufferViewArrayArray=U,L._lodGenerationScale=mL,L._lodGenerationOffset=p,L._sphericalPolynomial=x,f(L,U).then((()=>(L.isReady=!0,L)))}}}]);