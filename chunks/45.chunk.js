"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[45],{12901:(Z,x,F)=>{F.d(x,{e:()=>p,g:()=>m,j:()=>K,m:()=>y});var u=F(10994),G=F(11179),f=F(11194),Y=F(11399),j=F(11117),d=F(11201),t=(F(11447),F(11289)),o=F(11012);F(11719),F(11433),F(11727);const c="image/png",s=2,J=[134,22,135,150,246,214,150,54];function p(Z){const x=new DataView(Z.buffer,Z.byteOffset,Z.byteLength);let F=0;for(let Y=0;Y<J.length;Y++)if(x.getUint8(F++)!==J[Y])return o.d.Error("Not a babylon environment map"),null;let u="",G=0;for(;G=x.getUint8(F++);)u+=String.fromCharCode(G);let f=JSON.parse(u);return f=U(f),f.binaryDataPosition=F,f.Co&&(f.Co.lodGenerationScale=f.Co.lodGenerationScale||.8),f}function U(Z){if(Z.version>s)throw new Error(`Unsupported babylon environment map version "${Z.version}". Latest supported version is "${s}".`);return 2===Z.version?Z:Z={...Z,version:2,imageType:c}}function k(Z,x){const F=(x=U(x)).Co;let u=Math.log2(x.width);if(u=Math.round(u)+1,F.mipmaps.length!==6*u)throw new Error(`Unsupported specular mipmaps number "${F.mipmaps.length}"`);const G=new Array(u);for(let f=0;f<u;f++){G[f]=new Array(6);for(let u=0;u<6;u++){const Y=F.mipmaps[6*f+u];G[f][u]=new Uint8Array(Z.buffer,Z.byteOffset+x.binaryDataPosition+Y.position,Y.length)}}return G}function M(Z,x){var F;x=U(x);const u=new Array(6),G=null===(F=x.irradiance)||void 0===F?void 0:F.irradianceTexture;if(G){if(6!==G.faces.length)throw new Error(`Incorrect irradiance texture faces number "${G.faces.length}"`);for(let F=0;F<6;F++){const f=G.faces[F];u[F]=new Uint8Array(Z.buffer,Z.byteOffset+x.binaryDataPosition+f.position,f.length)}}return u}function m(Z,x,F){var u;const f=(F=U(F)).Co;if(!f)return Promise.resolve([]);Z._lodGenerationScale=f.lodGenerationScale;const Y=[],j=k(x,F);Y.push(L(Z,j,F.imageType));const d=null===(u=F.irradiance)||void 0===u?void 0:u.irradianceTexture;if(d){var t,o;const u=M(x,F);let f=null;null!==(t=F.irradiance)&&void 0!==t&&null!==(o=t.irradianceTexture)&&void 0!==o&&o.dominantDirection&&(f=G.kx.Hx(F.irradiance.irradianceTexture.dominantDirection)),Y.push(H(Z,u,d.size,F.imageType,f))}return Promise.all(Y)}async function C(Z,x,F,u,G,f,Y,j,d,t,o){return await new Promise(((c,s)=>{if(F){const F=x.createTexture(null,!0,!0,null,1,null,(Z=>{s(Z)}),Z);null===u||void 0===u||u.onEffectCreatedObservable.addOnce((j=>{j.executeWhenCompiled((()=>{u.externalTextureSamplerBinding=!0,u.onApply=u=>{u._bindTexture("textureSampler",F),u.setFloat2("scale",1,x._features.needsInvertingBitmap&&Z instanceof ImageBitmap?-1:1)},x.scenes.length&&(x.scenes[0].postProcessManager.directRender([u],t,!0,f,Y),x.restoreDefaultFramebuffer(),F.dispose(),URL.revokeObjectURL(G),c())}))}))}else{if(x._uploadImageToTexture(o,Z,f,Y),j){const F=d[Y];F&&x._uploadImageToTexture(F._texture,Z,f,0)}c()}}))}async function L(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c;const u=Z.getEngine();Z.format=5,Z.type=0,Z.generateMipMaps=!0,Z._cachedAnisotropicFilteringLevel=null,u.updateTextureSamplingMode(3,Z),await S(Z,x,!0,F),Z.isReady=!0}async function H(Z,x,F){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const f=Z.getEngine(),Y=new j.e(f,5),t=new d.e(f,Y);Z._irradianceTexture=t,t._dominantDirection=G,Y.isCube=!0,Y.format=5,Y.type=0,Y.generateMipMaps=!0,Y._cachedAnisotropicFilteringLevel=null,Y.generateMipMaps=!0,Y.width=F,Y.height=F,f.updateTextureSamplingMode(3,Y),await S(Y,[x],!1,u),f.generateMipMapsForCubemap(Y),Y.isReady=!0}async function S(Z,x,G){let Y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c;if(!u.Tools.IsExponentOfTwo(Z.width))throw new Error("Texture size must be a power of two");const o=(0,f.ILog2)(Z.width)+1,s=Z.getEngine();let J=!1,p=!1,U=null,k=null,M=null;const m=s.getCaps();m.textureLOD?s._features.supportRenderAndCopyToLodForFloatTextures?m.textureHalfFloatRender&&m.textureHalfFloatLinearFiltering?(J=!0,Z.type=2):m.textureFloatRender&&m.textureFloatLinearFiltering&&(J=!0,Z.type=1):J=!1:(J=!1,p=G);let L=0;if(J)s.isWebGPU?(L=1,await F.e(42).then(F.bind(F,14282))):await F.e(35).then(F.bind(F,14290)),U=new t.c("rgbdDecode","rgbdDecode",null,null,1,null,3,s,!1,void 0,Z.type,void 0,null,!1,void 0,L),Z._isRGBD=!1,Z.invertY=!1,k=s.createRenderTargetCubeTexture(Z.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:Z.type,format:5});else if(Z._isRGBD=!0,Z.invertY=!0,p){const x=3;M={};const F=Z._lodGenerationScale,u=Z._lodGenerationOffset;for(let G=0;G<x;G++){const f=(o-1)*F+u,Y=u+(f-u)*(1-G/(x-1)),t=Math.round(Math.min(Math.max(Y,0),f)),c=new j.e(s,2);c.isCube=!0,c.invertY=!0,c.generateMipMaps=!1,s.updateTextureSamplingMode(2,c);const J=new d.e(null);switch(J._isCube=!0,J._texture=c,M[t]=J,G){case 0:Z._lodTextureLow=J;break;case 1:Z._lodTextureMid=J;break;case 2:Z._lodTextureHigh=J}}}const H=[];for(let F=0;F<x.length;F++)for(let u=0;u<6;u++){const G=x[F][u],f=new Blob([G],{type:Y}),j=URL.createObjectURL(f);let d;if(s._features.forceBitmapOverHTMLImageElement)d=s.createImageBitmap(f,{premultiplyAlpha:"none"}).then((async x=>await C(x,s,J,U,j,u,F,p,M,k,Z)));else{const x=new Image;x.src=j,d=new Promise(((G,f)=>{x.onload=()=>{C(x,s,J,U,j,u,F,p,M,k,Z).then((()=>G())).catch((Z=>{f(Z)}))},x.onerror=Z=>{f(Z)}}))}H.push(d)}if(await Promise.all(H),x.length<o){let F;const u=Math.pow(2,o-1-x.length),G=u*u*4;switch(Z.type){case 0:F=new Uint8Array(G);break;case 2:F=new Uint16Array(G);break;case 1:F=new Float32Array(G)}for(let f=x.length;f<o;f++)for(let x=0;x<6;x++){var S;s._uploadArrayBufferViewToTexture((null===(S=k)||void 0===S?void 0:S.texture)||Z,F,x,f)}}if(k){const x=Z._irradianceTexture;Z._irradianceTexture=null,s._releaseTexture(Z),k._swapAndDie(Z),Z._irradianceTexture=x}U&&U.dispose(),p&&(Z._lodTextureHigh&&Z._lodTextureHigh._texture&&(Z._lodTextureHigh._texture.isReady=!0),Z._lodTextureMid&&Z._lodTextureMid._texture&&(Z._lodTextureMid._texture.isReady=!0),Z._lodTextureLow&&Z._lodTextureLow._texture&&(Z._lodTextureLow._texture.isReady=!0))}function K(Z,x){const F=(x=U(x)).irradiance;if(!F)return;const u=new Y.f;G.kx.FromArrayToRef(F.x,0,u.x),G.kx.FromArrayToRef(F.y,0,u.y),G.kx.FromArrayToRef(F.z,0,u.z),G.kx.FromArrayToRef(F.xx,0,u.xx),G.kx.FromArrayToRef(F.yy,0,u.yy),G.kx.FromArrayToRef(F.zz,0,u.zz),G.kx.FromArrayToRef(F.yz,0,u.yz),G.kx.FromArrayToRef(F.zx,0,u.zx),G.kx.FromArrayToRef(F.xy,0,u.xy),Z._sphericalPolynomial=u}function y(Z,x,F,u,G){const f=L(Z.getEngine().createRawCubeTexture(null,Z.width,Z.format,Z.type,Z.generateMipMaps,Z.invertY,Z.samplingMode,Z._compression),x).then((()=>Z));return Z.onRebuildCallback=Z=>({proxy:f,isReady:!0,isAsync:!0}),Z._source=13,Z._bufferViewArrayArray=x,Z._lodGenerationScale=u,Z._lodGenerationOffset=G,Z._sphericalPolynomial=F,L(Z,x).then((()=>(Z.isReady=!0,Z)))}}}]);