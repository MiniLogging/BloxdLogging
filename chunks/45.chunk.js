"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[45],{13472:(C,U,K)=>{K.d(U,{c:()=>b,e:()=>f,f:()=>d,i:()=>T});var m=K(11660),O=K(11827),X=K(11846),A=K(12018),e=K(11773),t=K(11854),z=(K(12078),K(11932)),j=K(11679);K(12339),K(12061),K(12348);const p="image/png",E=2,u=[134,22,135,150,246,214,150,54];function b(C){const U=new DataView(C.buffer,C.byteOffset,C.byteLength);let K=0;for(let A=0;A<u.length;A++)if(U.getUint8(K++)!==u[A])return j.d.Error("Not a babylon environment map"),null;let m="",O=0;for(;O=U.getUint8(K++);)m+=String.fromCharCode(O);let X=JSON.parse(m);return X=v(X),X.binaryDataPosition=K,X.Pj&&(X.Pj.lodGenerationScale=X.Pj.lodGenerationScale||.8),X}function v(C){if(C.version>E)throw new Error(`Unsupported babylon environment map version "${C.version}". Latest supported version is "${E}".`);return 2===C.version?C:C={...C,version:2,imageType:p}}function Q(C,U){const K=(U=v(U)).Pj;let m=Math.log2(U.width);if(m=Math.round(m)+1,K.mipmaps.length!==6*m)throw new Error(`Unsupported specular mipmaps number "${K.mipmaps.length}"`);const O=new Array(m);for(let X=0;X<m;X++){O[X]=new Array(6);for(let m=0;m<6;m++){const A=K.mipmaps[6*X+m];O[X][m]=new Uint8Array(C.buffer,C.byteOffset+U.binaryDataPosition+A.position,A.length)}}return O}function V(C,U){var K;U=v(U);const m=new Array(6),O=null===(K=U.irradiance)||void 0===K?void 0:K.irradianceTexture;if(O){if(6!==O.faces.length)throw new Error(`Incorrect irradiance texture faces number "${O.faces.length}"`);for(let K=0;K<6;K++){const X=O.faces[K];m[K]=new Uint8Array(C.buffer,C.byteOffset+U.binaryDataPosition+X.position,X.length)}}return m}function f(C,U,K){var m;const X=(K=v(K)).Pj;if(!X)return Promise.resolve([]);C._lodGenerationScale=X.lodGenerationScale;const A=[],e=Q(U,K);A.push(Z(C,e,K.imageType));const t=null===(m=K.irradiance)||void 0===m?void 0:m.irradianceTexture;if(t){var z,j;const m=V(U,K);let X=null;null!==(z=K.irradiance)&&void 0!==z&&null!==(j=z.irradianceTexture)&&void 0!==j&&j.dominantDirection&&(X=O.bU.FU(K.irradiance.irradianceTexture.dominantDirection)),A.push(P(C,m,t.size,K.imageType,X))}return Promise.all(A)}async function F(C,U,K,m,O,X,A,e,t,z,j){return await new Promise(((p,E)=>{if(K){const K=U.createTexture(null,!0,!0,null,1,null,(C=>{E(C)}),C);null===m||void 0===m||m.onEffectCreatedObservable.addOnce((e=>{e.executeWhenCompiled((()=>{m.externalTextureSamplerBinding=!0,m.onApply=m=>{m._bindTexture("textureSampler",K),m.setFloat2("scale",1,U._features.needsInvertingBitmap&&C instanceof ImageBitmap?-1:1)},U.scenes.length&&(U.scenes[0].postProcessManager.directRender([m],z,!0,X,A),U.restoreDefaultFramebuffer(),K.dispose(),URL.revokeObjectURL(O),p())}))}))}else{if(U._uploadImageToTexture(j,C,X,A),e){const K=t[A];K&&U._uploadImageToTexture(K._texture,C,X,0)}p()}}))}async function Z(C,U){let K=arguments.length>2&&void 0!==arguments[2]?arguments[2]:p;const m=C.getEngine();C.format=5,C.type=0,C.generateMipMaps=!0,C._cachedAnisotropicFilteringLevel=null,m.updateTextureSamplingMode(3,C),await H(C,U,!0,K),C.isReady=!0}async function P(C,U,K){let m=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p,O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const X=C.getEngine(),A=new e.d(X,5),z=new t.c(X,A);C._irradianceTexture=z,z._dominantDirection=O,A.isCube=!0,A.format=5,A.type=0,A.generateMipMaps=!0,A._cachedAnisotropicFilteringLevel=null,A.generateMipMaps=!0,A.width=K,A.height=K,X.updateTextureSamplingMode(3,A),await H(A,[U],!1,m),X.generateMipMapsForCubemap(A),A.isReady=!0}async function H(C,U,O){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p;if(!m.Tools.IsExponentOfTwo(C.width))throw new Error("Texture size must be a power of two");const j=(0,X.ILog2)(C.width)+1,E=C.getEngine();let u=!1,b=!1,v=null,Q=null,V=null;const f=E.getCaps();f.textureLOD?E._features.supportRenderAndCopyToLodForFloatTextures?f.textureHalfFloatRender&&f.textureHalfFloatLinearFiltering?(u=!0,C.type=2):f.textureFloatRender&&f.textureFloatLinearFiltering&&(u=!0,C.type=1):u=!1:(u=!1,b=O);let Z=0;if(u)E.isWebGPU?(Z=1,await K.e(42).then(K.bind(K,14830))):await K.e(35).then(K.bind(K,14838)),v=new z.b("rgbdDecode","rgbdDecode",null,null,1,null,3,E,!1,void 0,C.type,void 0,null,!1,void 0,Z),C._isRGBD=!1,C.invertY=!1,Q=E.createRenderTargetCubeTexture(C.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:C.type,format:5});else if(C._isRGBD=!0,C.invertY=!0,b){const U=3;V={};const K=C._lodGenerationScale,m=C._lodGenerationOffset;for(let O=0;O<U;O++){const X=(j-1)*K+m,A=m+(X-m)*(1-O/(U-1)),z=Math.round(Math.min(Math.max(A,0),X)),p=new e.d(E,2);p.isCube=!0,p.invertY=!0,p.generateMipMaps=!1,E.updateTextureSamplingMode(2,p);const u=new t.c(null);switch(u._isCube=!0,u._texture=p,V[z]=u,O){case 0:C._lodTextureLow=u;break;case 1:C._lodTextureMid=u;break;case 2:C._lodTextureHigh=u}}}const P=[];for(let K=0;K<U.length;K++)for(let m=0;m<6;m++){const O=U[K][m],X=new Blob([O],{type:A}),e=URL.createObjectURL(X);let t;if(E._features.forceBitmapOverHTMLImageElement)t=E.createImageBitmap(X,{premultiplyAlpha:"none"}).then((async U=>await F(U,E,u,v,e,m,K,b,V,Q,C)));else{const U=new Image;U.src=e,t=new Promise(((O,X)=>{U.onload=()=>{F(U,E,u,v,e,m,K,b,V,Q,C).then((()=>O())).catch((C=>{X(C)}))},U.onerror=C=>{X(C)}}))}P.push(t)}if(await Promise.all(P),U.length<j){let K;const m=Math.pow(2,j-1-U.length),O=m*m*4;switch(C.type){case 0:K=new Uint8Array(O);break;case 2:K=new Uint16Array(O);break;case 1:K=new Float32Array(O)}for(let X=U.length;X<j;X++)for(let U=0;U<6;U++){var H;E._uploadArrayBufferViewToTexture((null===(H=Q)||void 0===H?void 0:H.texture)||C,K,U,X)}}if(Q){const U=C._irradianceTexture;C._irradianceTexture=null,E._releaseTexture(C),Q._swapAndDie(C),C._irradianceTexture=U}v&&v.dispose(),b&&(C._lodTextureHigh&&C._lodTextureHigh._texture&&(C._lodTextureHigh._texture.isReady=!0),C._lodTextureMid&&C._lodTextureMid._texture&&(C._lodTextureMid._texture.isReady=!0),C._lodTextureLow&&C._lodTextureLow._texture&&(C._lodTextureLow._texture.isReady=!0))}function d(C,U){const K=(U=v(U)).irradiance;if(!K)return;const m=new A.g;O.bU.FromArrayToRef(K.x,0,m.x),O.bU.FromArrayToRef(K.y,0,m.y),O.bU.FromArrayToRef(K.z,0,m.z),O.bU.FromArrayToRef(K.xx,0,m.xx),O.bU.FromArrayToRef(K.yy,0,m.yy),O.bU.FromArrayToRef(K.zz,0,m.zz),O.bU.FromArrayToRef(K.yz,0,m.yz),O.bU.FromArrayToRef(K.zx,0,m.zx),O.bU.FromArrayToRef(K.xy,0,m.xy),C._sphericalPolynomial=m}function T(C,U,K,m,O){const X=Z(C.getEngine().createRawCubeTexture(null,C.width,C.format,C.type,C.generateMipMaps,C.invertY,C.samplingMode,C._compression),U).then((()=>C));return C.onRebuildCallback=C=>({proxy:X,isReady:!0,isAsync:!0}),C._source=13,C._bufferViewArrayArray=U,C._lodGenerationScale=m,C._lodGenerationOffset=O,C._sphericalPolynomial=K,Z(C,U).then((()=>(C.isReady=!0,C)))}}}]);