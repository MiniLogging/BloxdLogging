"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[45],{14263:(s,k,h)=>{h.d(k,{b:()=>d,e:()=>R,i:()=>G,m:()=>Q});var A=h(12402),g=h(12590),ms=h(12607),i=h(12788),K=h(12515),H=h(12614),O=(h(12836),h(12697)),c=h(12422);h(13103),h(12817),h(13113);const S="image/png",a=2,r=[134,22,135,150,246,214,150,54];function d(s){const k=new DataView(s.buffer,s.byteOffset,s.byteLength);let h=0;for(let i=0;i<r.length;i++)if(k.getUint8(h++)!==r[i])return c.c.Error("Not a babylon environment map"),null;let A="",g=0;for(;g=k.getUint8(h++);)A+=String.fromCharCode(g);let ms=JSON.parse(A);return ms=E(ms),ms.binaryDataPosition=h,ms.rS&&(ms.rS.lodGenerationScale=ms.rS.lodGenerationScale||.8),ms}function E(s){if(s.version>a)throw new Error(`Unsupported babylon environment map version "${s.version}". Latest supported version is "${a}".`);return 2===s.version?s:s={...s,version:2,imageType:S}}function j(s,k){const h=(k=E(k)).rS;let A=Math.log2(k.width);if(A=Math.round(A)+1,h.mipmaps.length!==6*A)throw new Error(`Unsupported specular mipmaps number "${h.mipmaps.length}"`);const g=new Array(A);for(let ms=0;ms<A;ms++){g[ms]=new Array(6);for(let A=0;A<6;A++){const i=h.mipmaps[6*ms+A];g[ms][A]=new Uint8Array(s.buffer,s.byteOffset+k.binaryDataPosition+i.position,i.length)}}return g}function P(s,k){var h;k=E(k);const A=new Array(6),g=null===(h=k.irradiance)||void 0===h?void 0:h.irradianceTexture;if(g){if(6!==g.faces.length)throw new Error(`Incorrect irradiance texture faces number "${g.faces.length}"`);for(let h=0;h<6;h++){const ms=g.faces[h];A[h]=new Uint8Array(s.buffer,s.byteOffset+k.binaryDataPosition+ms.position,ms.length)}}return A}function R(s,k,h){var A;const ms=(h=E(h)).rS;if(!ms)return Promise.resolve([]);s._lodGenerationScale=ms.lodGenerationScale;const i=[],K=j(k,h);i.push(w(s,K,h.imageType));const H=null===(A=h.irradiance)||void 0===A?void 0:A.irradianceTexture;if(H){var O,c;const A=P(k,h);let ms=null;null!==(O=h.irradiance)&&void 0!==O&&null!==(c=O.irradianceTexture)&&void 0!==c&&c.dominantDirection&&(ms=g.Pk.uk(h.irradiance.irradianceTexture.dominantDirection)),i.push(B(s,A,H.size,h.imageType,ms))}return Promise.all(i)}async function D(s,k,h,A,g,ms,i,K,H,O,c){return await new Promise(((S,a)=>{if(h){const h=k.createTexture(null,!0,!0,null,1,null,(s=>{a(s)}),s);null===A||void 0===A||A.onEffectCreatedObservable.addOnce((K=>{K.executeWhenCompiled((()=>{A.externalTextureSamplerBinding=!0,A.onApply=A=>{A._bindTexture("textureSampler",h),A.setFloat2("scale",1,k._features.needsInvertingBitmap&&s instanceof ImageBitmap?-1:1)},k.scenes.length&&(k.scenes[0].postProcessManager.directRender([A],O,!0,ms,i),k.restoreDefaultFramebuffer(),h.dispose(),URL.revokeObjectURL(g),S())}))}))}else{if(k._uploadImageToTexture(c,s,ms,i),K){const h=H[i];h&&k._uploadImageToTexture(h._texture,s,ms,0)}S()}}))}async function w(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:S;const A=s.getEngine();s.format=5,s.type=0,s.generateMipMaps=!0,s._cachedAnisotropicFilteringLevel=null,A.updateTextureSamplingMode(3,s),await u(s,k,!0,h),s.isReady=!0}async function B(s,k,h){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S,g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const ms=s.getEngine(),i=new K.c(ms,5),O=new H.e(ms,i);s._irradianceTexture=O,O._dominantDirection=g,i.isCube=!0,i.format=5,i.type=0,i.generateMipMaps=!0,i._cachedAnisotropicFilteringLevel=null,i.generateMipMaps=!0,i.width=h,i.height=h,ms.updateTextureSamplingMode(3,i),await u(i,[k],!1,A),ms.generateMipMapsForCubemap(i),i.isReady=!0}async function u(s,k,g){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:S;if(!A.Tools.IsExponentOfTwo(s.width))throw new Error("Texture size must be a power of two");const c=(0,ms.ILog2)(s.width)+1,a=s.getEngine();let r=!1,d=!1,E=null,j=null,P=null;const R=a.getCaps();R.textureLOD?a._features.supportRenderAndCopyToLodForFloatTextures?R.textureHalfFloatRender&&R.textureHalfFloatLinearFiltering?(r=!0,s.type=2):R.textureFloatRender&&R.textureFloatLinearFiltering&&(r=!0,s.type=1):r=!1:(r=!1,d=g);let w=0;if(r)a.isWebGPU?(w=1,await h.e(42).then(h.bind(h,15647))):await h.e(35).then(h.bind(h,15656)),E=new O.e("rgbdDecode","rgbdDecode",null,null,1,null,3,a,!1,void 0,s.type,void 0,null,!1,void 0,w),s._isRGBD=!1,s.invertY=!1,j=a.createRenderTargetCubeTexture(s.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:s.type,format:5});else if(s._isRGBD=!0,s.invertY=!0,d){const k=3;P={};const h=s._lodGenerationScale,A=s._lodGenerationOffset;for(let g=0;g<k;g++){const ms=(c-1)*h+A,i=A+(ms-A)*(1-g/(k-1)),O=Math.round(Math.min(Math.max(i,0),ms)),S=new K.c(a,2);S.isCube=!0,S.invertY=!0,S.generateMipMaps=!1,a.updateTextureSamplingMode(2,S);const r=new H.e(null);switch(r._isCube=!0,r._texture=S,P[O]=r,g){case 0:s._lodTextureLow=r;break;case 1:s._lodTextureMid=r;break;case 2:s._lodTextureHigh=r}}}const B=[];for(let h=0;h<k.length;h++)for(let A=0;A<6;A++){const g=k[h][A],ms=new Blob([g],{type:i}),K=URL.createObjectURL(ms);let H;if(a._features.forceBitmapOverHTMLImageElement)H=a.createImageBitmap(ms,{premultiplyAlpha:"none"}).then((async k=>await D(k,a,r,E,K,A,h,d,P,j,s)));else{const k=new Image;k.src=K,H=new Promise(((g,ms)=>{k.onload=()=>{D(k,a,r,E,K,A,h,d,P,j,s).then((()=>g())).catch((s=>{ms(s)}))},k.onerror=s=>{ms(s)}}))}B.push(H)}if(await Promise.all(B),k.length<c){let h;const A=Math.pow(2,c-1-k.length),g=A*A*4;switch(s.type){case 0:h=new Uint8Array(g);break;case 2:h=new Uint16Array(g);break;case 1:h=new Float32Array(g)}for(let ms=k.length;ms<c;ms++)for(let k=0;k<6;k++){var u;a._uploadArrayBufferViewToTexture((null===(u=j)||void 0===u?void 0:u.texture)||s,h,k,ms)}}if(j){const k=s._irradianceTexture;s._irradianceTexture=null,a._releaseTexture(s),j._swapAndDie(s),s._irradianceTexture=k}E&&E.dispose(),d&&(s._lodTextureHigh&&s._lodTextureHigh._texture&&(s._lodTextureHigh._texture.isReady=!0),s._lodTextureMid&&s._lodTextureMid._texture&&(s._lodTextureMid._texture.isReady=!0),s._lodTextureLow&&s._lodTextureLow._texture&&(s._lodTextureLow._texture.isReady=!0))}function G(s,k){const h=(k=E(k)).irradiance;if(!h)return;const A=new i.f;g.Pk.FromArrayToRef(h.x,0,A.x),g.Pk.FromArrayToRef(h.y,0,A.y),g.Pk.FromArrayToRef(h.z,0,A.z),g.Pk.FromArrayToRef(h.xx,0,A.xx),g.Pk.FromArrayToRef(h.yy,0,A.yy),g.Pk.FromArrayToRef(h.zz,0,A.zz),g.Pk.FromArrayToRef(h.yz,0,A.yz),g.Pk.FromArrayToRef(h.zx,0,A.zx),g.Pk.FromArrayToRef(h.xy,0,A.xy),s._sphericalPolynomial=A}function Q(s,k,h,A,g){const ms=w(s.getEngine().createRawCubeTexture(null,s.width,s.format,s.type,s.generateMipMaps,s.invertY,s.samplingMode,s._compression),k).then((()=>s));return s.onRebuildCallback=s=>({proxy:ms,isReady:!0,isAsync:!0}),s._source=13,s._bufferViewArrayArray=k,s._lodGenerationScale=A,s._lodGenerationOffset=g,s._sphericalPolynomial=h,w(s,k).then((()=>(s.isReady=!0,s)))}}}]);