"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[45],{14028:(M,Z,P)=>{P.d(Z,{c:()=>B,f:()=>u,h:()=>D,l:()=>l});var x=P(12175),c=P(12373),w=P(12387),v=P(12549),G=P(12291),mM=P(12390),K=(P(12596),P(12462)),d=P(12199);P(12868),P(12579),P(12880);const O="image/png",H=2,j=[134,22,135,150,246,214,150,54];function B(M){const Z=new DataView(M.buffer,M.byteOffset,M.byteLength);let P=0;for(let v=0;v<j.length;v++)if(Z.getUint8(P++)!==j[v])return d.d.Error("Not a babylon environment map"),null;let x="",c=0;for(;c=Z.getUint8(P++);)x+=String.fromCharCode(c);let w=JSON.parse(x);return w=U(w),w.binaryDataPosition=P,w.HO&&(w.HO.lodGenerationScale=w.HO.lodGenerationScale||.8),w}function U(M){if(M.version>H)throw new Error(`Unsupported babylon environment map version "${M.version}". Latest supported version is "${H}".`);return 2===M.version?M:M={...M,version:2,imageType:O}}function n(M,Z){const P=(Z=U(Z)).HO;let x=Math.log2(Z.width);if(x=Math.round(x)+1,P.mipmaps.length!==6*x)throw new Error(`Unsupported specular mipmaps number "${P.mipmaps.length}"`);const c=new Array(x);for(let w=0;w<x;w++){c[w]=new Array(6);for(let x=0;x<6;x++){const v=P.mipmaps[6*w+x];c[w][x]=new Uint8Array(M.buffer,M.byteOffset+Z.binaryDataPosition+v.position,v.length)}}return c}function L(M,Z){var P;Z=U(Z);const x=new Array(6),c=null===(P=Z.irradiance)||void 0===P?void 0:P.irradianceTexture;if(c){if(6!==c.faces.length)throw new Error(`Incorrect irradiance texture faces number "${c.faces.length}"`);for(let P=0;P<6;P++){const w=c.faces[P];x[P]=new Uint8Array(M.buffer,M.byteOffset+Z.binaryDataPosition+w.position,w.length)}}return x}function u(M,Z,P){var x;const w=(P=U(P)).HO;if(!w)return Promise.resolve([]);M._lodGenerationScale=w.lodGenerationScale;const v=[],G=n(Z,P);v.push(J(M,G,P.imageType));const mM=null===(x=P.irradiance)||void 0===x?void 0:x.irradianceTexture;if(mM){var K,d;const x=L(Z,P);let w=null;null!==(K=P.irradiance)&&void 0!==K&&null!==(d=K.irradianceTexture)&&void 0!==d&&d.dominantDirection&&(w=c.BZ.NZ(P.irradiance.irradianceTexture.dominantDirection)),v.push(t(M,x,mM.size,P.imageType,w))}return Promise.all(v)}async function N(M,Z,P,x,c,w,v,G,mM,K,d){return await new Promise(((O,H)=>{if(P){const P=Z.createTexture(null,!0,!0,null,1,null,(M=>{H(M)}),M);null===x||void 0===x||x.onEffectCreatedObservable.addOnce((G=>{G.executeWhenCompiled((()=>{x.externalTextureSamplerBinding=!0,x.onApply=x=>{x._bindTexture("textureSampler",P),x.setFloat2("scale",1,Z._features.needsInvertingBitmap&&M instanceof ImageBitmap?-1:1)},Z.scenes.length&&(Z.scenes[0].postProcessManager.directRender([x],K,!0,w,v),Z.restoreDefaultFramebuffer(),P.dispose(),URL.revokeObjectURL(c),O())}))}))}else{if(Z._uploadImageToTexture(d,M,w,v),G){const P=mM[v];P&&Z._uploadImageToTexture(P._texture,M,w,0)}O()}}))}async function J(M,Z){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:O;const x=M.getEngine();M.format=5,M.type=0,M.generateMipMaps=!0,M._cachedAnisotropicFilteringLevel=null,x.updateTextureSamplingMode(3,M),await F(M,Z,!0,P),M.isReady=!0}async function t(M,Z,P){let x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:O,c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const w=M.getEngine(),v=new G.d(w,5),K=new mM.b(w,v);M._irradianceTexture=K,K._dominantDirection=c,v.isCube=!0,v.format=5,v.type=0,v.generateMipMaps=!0,v._cachedAnisotropicFilteringLevel=null,v.generateMipMaps=!0,v.width=P,v.height=P,w.updateTextureSamplingMode(3,v),await F(v,[Z],!1,x),w.generateMipMapsForCubemap(v),v.isReady=!0}async function F(M,Z,c){let v=arguments.length>3&&void 0!==arguments[3]?arguments[3]:O;if(!x.Tools.IsExponentOfTwo(M.width))throw new Error("Texture size must be a power of two");const d=(0,w.ILog2)(M.width)+1,H=M.getEngine();let j=!1,B=!1,U=null,n=null,L=null;const u=H.getCaps();u.textureLOD?H._features.supportRenderAndCopyToLodForFloatTextures?u.textureHalfFloatRender&&u.textureHalfFloatLinearFiltering?(j=!0,M.type=2):u.textureFloatRender&&u.textureFloatLinearFiltering&&(j=!0,M.type=1):j=!1:(j=!1,B=c);let J=0;if(j)H.isWebGPU?(J=1,await P.e(42).then(P.bind(P,15415))):await P.e(35).then(P.bind(P,15423)),U=new K.e("rgbdDecode","rgbdDecode",null,null,1,null,3,H,!1,void 0,M.type,void 0,null,!1,void 0,J),M._isRGBD=!1,M.invertY=!1,n=H.createRenderTargetCubeTexture(M.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:M.type,format:5});else if(M._isRGBD=!0,M.invertY=!0,B){const Z=3;L={};const P=M._lodGenerationScale,x=M._lodGenerationOffset;for(let c=0;c<Z;c++){const w=(d-1)*P+x,v=x+(w-x)*(1-c/(Z-1)),K=Math.round(Math.min(Math.max(v,0),w)),O=new G.d(H,2);O.isCube=!0,O.invertY=!0,O.generateMipMaps=!1,H.updateTextureSamplingMode(2,O);const j=new mM.b(null);switch(j._isCube=!0,j._texture=O,L[K]=j,c){case 0:M._lodTextureLow=j;break;case 1:M._lodTextureMid=j;break;case 2:M._lodTextureHigh=j}}}const t=[];for(let P=0;P<Z.length;P++)for(let x=0;x<6;x++){const c=Z[P][x],w=new Blob([c],{type:v}),G=URL.createObjectURL(w);let mM;if(H._features.forceBitmapOverHTMLImageElement)mM=H.createImageBitmap(w,{premultiplyAlpha:"none"}).then((async Z=>await N(Z,H,j,U,G,x,P,B,L,n,M)));else{const Z=new Image;Z.src=G,mM=new Promise(((c,w)=>{Z.onload=()=>{N(Z,H,j,U,G,x,P,B,L,n,M).then((()=>c())).catch((M=>{w(M)}))},Z.onerror=M=>{w(M)}}))}t.push(mM)}if(await Promise.all(t),Z.length<d){let P;const x=Math.pow(2,d-1-Z.length),c=x*x*4;switch(M.type){case 0:P=new Uint8Array(c);break;case 2:P=new Uint16Array(c);break;case 1:P=new Float32Array(c)}for(let w=Z.length;w<d;w++)for(let Z=0;Z<6;Z++){var F;H._uploadArrayBufferViewToTexture((null===(F=n)||void 0===F?void 0:F.texture)||M,P,Z,w)}}if(n){const Z=M._irradianceTexture;M._irradianceTexture=null,H._releaseTexture(M),n._swapAndDie(M),M._irradianceTexture=Z}U&&U.dispose(),B&&(M._lodTextureHigh&&M._lodTextureHigh._texture&&(M._lodTextureHigh._texture.isReady=!0),M._lodTextureMid&&M._lodTextureMid._texture&&(M._lodTextureMid._texture.isReady=!0),M._lodTextureLow&&M._lodTextureLow._texture&&(M._lodTextureLow._texture.isReady=!0))}function D(M,Z){const P=(Z=U(Z)).irradiance;if(!P)return;const x=new v.h;c.BZ.FromArrayToRef(P.x,0,x.x),c.BZ.FromArrayToRef(P.y,0,x.y),c.BZ.FromArrayToRef(P.z,0,x.z),c.BZ.FromArrayToRef(P.xx,0,x.xx),c.BZ.FromArrayToRef(P.yy,0,x.yy),c.BZ.FromArrayToRef(P.zz,0,x.zz),c.BZ.FromArrayToRef(P.yz,0,x.yz),c.BZ.FromArrayToRef(P.zx,0,x.zx),c.BZ.FromArrayToRef(P.xy,0,x.xy),M._sphericalPolynomial=x}function l(M,Z,P,x,c){const w=J(M.getEngine().createRawCubeTexture(null,M.width,M.format,M.type,M.generateMipMaps,M.invertY,M.samplingMode,M._compression),Z).then((()=>M));return M.onRebuildCallback=M=>({proxy:w,isReady:!0,isAsync:!0}),M._source=13,M._bufferViewArrayArray=Z,M._lodGenerationScale=x,M._lodGenerationOffset=c,M._sphericalPolynomial=P,J(M,Z).then((()=>(M.isReady=!0,M)))}}}]);