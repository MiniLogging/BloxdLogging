"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[45],{13988:(H,u,J)=>{J.d(u,{d:()=>l,e:()=>k,i:()=>Z,j:()=>Y});var O=J(12171),U=J(12338),h=J(12349),w=J(12512),g=J(12280),B=J(12358),b=(J(12568),J(12434)),d=J(12185);J(12831),J(12546),J(12848);const G="image/png",P=2,mH=[134,22,135,150,246,214,150,54];function l(H){const u=new DataView(H.buffer,H.byteOffset,H.byteLength);let J=0;for(let w=0;w<mH.length;w++)if(u.getUint8(J++)!==mH[w])return d.b.Error("Not a babylon environment map"),null;let O="",U=0;for(;U=u.getUint8(J++);)O+=String.fromCharCode(U);let h=JSON.parse(O);return h=r(h),h.binaryDataPosition=J,h.cG&&(h.cG.lodGenerationScale=h.cG.lodGenerationScale||.8),h}function r(H){if(H.version>P)throw new Error(`Unsupported babylon environment map version "${H.version}". Latest supported version is "${P}".`);return 2===H.version?H:H={...H,version:2,imageType:G}}function p(H,u){const J=(u=r(u)).cG;let O=Math.log2(u.width);if(O=Math.round(O)+1,J.mipmaps.length!==6*O)throw new Error(`Unsupported specular mipmaps number "${J.mipmaps.length}"`);const U=new Array(O);for(let h=0;h<O;h++){U[h]=new Array(6);for(let O=0;O<6;O++){const w=J.mipmaps[6*h+O];U[h][O]=new Uint8Array(H.buffer,H.byteOffset+u.binaryDataPosition+w.position,w.length)}}return U}function a(H,u){var J;u=r(u);const O=new Array(6),U=null===(J=u.irradiance)||void 0===J?void 0:J.irradianceTexture;if(U){if(6!==U.faces.length)throw new Error(`Incorrect irradiance texture faces number "${U.faces.length}"`);for(let J=0;J<6;J++){const h=U.faces[J];O[J]=new Uint8Array(H.buffer,H.byteOffset+u.binaryDataPosition+h.position,h.length)}}return O}function k(H,u,J){var O;const h=(J=r(J)).cG;if(!h)return Promise.resolve([]);H._lodGenerationScale=h.lodGenerationScale;const w=[],g=p(u,J);w.push(j(H,g,J.imageType));const B=null===(O=J.irradiance)||void 0===O?void 0:O.irradianceTexture;if(B){var b,d;const O=a(u,J);let h=null;null!==(b=J.irradiance)&&void 0!==b&&null!==(d=b.irradianceTexture)&&void 0!==d&&d.dominantDirection&&(h=U.lu.Cu(J.irradiance.irradianceTexture.dominantDirection)),w.push(M(H,O,B.size,J.imageType,h))}return Promise.all(w)}async function C(H,u,J,O,U,h,w,g,B,b,d){return await new Promise(((G,P)=>{if(J){const J=u.createTexture(null,!0,!0,null,1,null,(H=>{P(H)}),H);null===O||void 0===O||O.onEffectCreatedObservable.addOnce((g=>{g.executeWhenCompiled((()=>{O.externalTextureSamplerBinding=!0,O.onApply=O=>{O._bindTexture("textureSampler",J),O.setFloat2("scale",1,u._features.needsInvertingBitmap&&H instanceof ImageBitmap?-1:1)},u.scenes.length&&(u.scenes[0].postProcessManager.directRender([O],b,!0,h,w),u.restoreDefaultFramebuffer(),J.dispose(),URL.revokeObjectURL(U),G())}))}))}else{if(u._uploadImageToTexture(d,H,h,w),g){const J=B[w];J&&u._uploadImageToTexture(J._texture,H,h,0)}G()}}))}async function j(H,u){let J=arguments.length>2&&void 0!==arguments[2]?arguments[2]:G;const O=H.getEngine();H.format=5,H.type=0,H.generateMipMaps=!0,H._cachedAnisotropicFilteringLevel=null,O.updateTextureSamplingMode(3,H),await L(H,u,!0,J),H.isReady=!0}async function M(H,u,J){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G,U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const h=H.getEngine(),w=new g.c(h,5),b=new B.b(h,w);H._irradianceTexture=b,b._dominantDirection=U,w.isCube=!0,w.format=5,w.type=0,w.generateMipMaps=!0,w._cachedAnisotropicFilteringLevel=null,w.generateMipMaps=!0,w.width=J,w.height=J,h.updateTextureSamplingMode(3,w),await L(w,[u],!1,O),h.generateMipMapsForCubemap(w),w.isReady=!0}async function L(H,u,U){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:G;if(!O.Tools.IsExponentOfTwo(H.width))throw new Error("Texture size must be a power of two");const d=(0,h.ILog2)(H.width)+1,P=H.getEngine();let mH=!1,l=!1,r=null,p=null,a=null;const k=P.getCaps();k.textureLOD?P._features.supportRenderAndCopyToLodForFloatTextures?k.textureHalfFloatRender&&k.textureHalfFloatLinearFiltering?(mH=!0,H.type=2):k.textureFloatRender&&k.textureFloatLinearFiltering&&(mH=!0,H.type=1):mH=!1:(mH=!1,l=U);let j=0;if(mH)P.isWebGPU?(j=1,await J.e(42).then(J.bind(J,15327))):await J.e(35).then(J.bind(J,15334)),r=new b.e("rgbdDecode","rgbdDecode",null,null,1,null,3,P,!1,void 0,H.type,void 0,null,!1,void 0,j),H._isRGBD=!1,H.invertY=!1,p=P.createRenderTargetCubeTexture(H.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:H.type,format:5});else if(H._isRGBD=!0,H.invertY=!0,l){const u=3;a={};const J=H._lodGenerationScale,O=H._lodGenerationOffset;for(let U=0;U<u;U++){const h=(d-1)*J+O,w=O+(h-O)*(1-U/(u-1)),b=Math.round(Math.min(Math.max(w,0),h)),G=new g.c(P,2);G.isCube=!0,G.invertY=!0,G.generateMipMaps=!1,P.updateTextureSamplingMode(2,G);const mH=new B.b(null);switch(mH._isCube=!0,mH._texture=G,a[b]=mH,U){case 0:H._lodTextureLow=mH;break;case 1:H._lodTextureMid=mH;break;case 2:H._lodTextureHigh=mH}}}const M=[];for(let J=0;J<u.length;J++)for(let O=0;O<6;O++){const U=u[J][O],h=new Blob([U],{type:w}),g=URL.createObjectURL(h);let B;if(P._features.forceBitmapOverHTMLImageElement)B=P.createImageBitmap(h,{premultiplyAlpha:"none"}).then((async u=>await C(u,P,mH,r,g,O,J,l,a,p,H)));else{const u=new Image;u.src=g,B=new Promise(((U,h)=>{u.onload=()=>{C(u,P,mH,r,g,O,J,l,a,p,H).then((()=>U())).catch((H=>{h(H)}))},u.onerror=H=>{h(H)}}))}M.push(B)}if(await Promise.all(M),u.length<d){let J;const O=Math.pow(2,d-1-u.length),U=O*O*4;switch(H.type){case 0:J=new Uint8Array(U);break;case 2:J=new Uint16Array(U);break;case 1:J=new Float32Array(U)}for(let h=u.length;h<d;h++)for(let u=0;u<6;u++){var L;P._uploadArrayBufferViewToTexture((null===(L=p)||void 0===L?void 0:L.texture)||H,J,u,h)}}if(p){const u=H._irradianceTexture;H._irradianceTexture=null,P._releaseTexture(H),p._swapAndDie(H),H._irradianceTexture=u}r&&r.dispose(),l&&(H._lodTextureHigh&&H._lodTextureHigh._texture&&(H._lodTextureHigh._texture.isReady=!0),H._lodTextureMid&&H._lodTextureMid._texture&&(H._lodTextureMid._texture.isReady=!0),H._lodTextureLow&&H._lodTextureLow._texture&&(H._lodTextureLow._texture.isReady=!0))}function Z(H,u){const J=(u=r(u)).irradiance;if(!J)return;const O=new w.e;U.lu.FromArrayToRef(J.x,0,O.x),U.lu.FromArrayToRef(J.y,0,O.y),U.lu.FromArrayToRef(J.z,0,O.z),U.lu.FromArrayToRef(J.xx,0,O.xx),U.lu.FromArrayToRef(J.yy,0,O.yy),U.lu.FromArrayToRef(J.zz,0,O.zz),U.lu.FromArrayToRef(J.yz,0,O.yz),U.lu.FromArrayToRef(J.zx,0,O.zx),U.lu.FromArrayToRef(J.xy,0,O.xy),H._sphericalPolynomial=O}function Y(H,u,J,O,U){const h=j(H.getEngine().createRawCubeTexture(null,H.width,H.format,H.type,H.generateMipMaps,H.invertY,H.samplingMode,H._compression),u).then((()=>H));return H.onRebuildCallback=H=>({proxy:h,isReady:!0,isAsync:!0}),H._source=13,H._bufferViewArrayArray=u,H._lodGenerationScale=O,H._lodGenerationOffset=U,H._sphericalPolynomial=J,j(H,u).then((()=>(H.isReady=!0,H)))}}}]);