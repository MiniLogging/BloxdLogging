"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[45],{13996:(N,U,V)=>{V.d(U,{b:()=>C,d:()=>r,h:()=>Y,j:()=>W});var A=V(12179),t=V(12383),n=V(12395),q=V(12559),i=V(12319),z=V(12402),S=(V(12601),V(12485)),E=V(12193);V(12850),V(12584),V(12866);const p="image/png",k=2,B=[134,22,135,150,246,214,150,54];function C(N){const U=new DataView(N.buffer,N.byteOffset,N.byteLength);let V=0;for(let q=0;q<B.length;q++)if(U.getUint8(V++)!==B[q])return E.b.Error("Not a babylon environment map"),null;let A="",t=0;for(;t=U.getUint8(V++);)A+=String.fromCharCode(t);let n=JSON.parse(A);return n=x(n),n.binaryDataPosition=V,n.CE&&(n.CE.lodGenerationScale=n.CE.lodGenerationScale||.8),n}function x(N){if(N.version>k)throw new Error(`Unsupported babylon environment map version "${N.version}". Latest supported version is "${k}".`);return 2===N.version?N:N={...N,version:2,imageType:p}}function J(N,U){const V=(U=x(U)).CE;let A=Math.log2(U.width);if(A=Math.round(A)+1,V.mipmaps.length!==6*A)throw new Error(`Unsupported specular mipmaps number "${V.mipmaps.length}"`);const t=new Array(A);for(let n=0;n<A;n++){t[n]=new Array(6);for(let A=0;A<6;A++){const q=V.mipmaps[6*n+A];t[n][A]=new Uint8Array(N.buffer,N.byteOffset+U.binaryDataPosition+q.position,q.length)}}return t}function d(N,U){var V;U=x(U);const A=new Array(6),t=null===(V=U.irradiance)||void 0===V?void 0:V.irradianceTexture;if(t){if(6!==t.faces.length)throw new Error(`Incorrect irradiance texture faces number "${t.faces.length}"`);for(let V=0;V<6;V++){const n=t.faces[V];A[V]=new Uint8Array(N.buffer,N.byteOffset+U.binaryDataPosition+n.position,n.length)}}return A}function r(N,U,V){var A;const n=(V=x(V)).CE;if(!n)return Promise.resolve([]);N._lodGenerationScale=n.lodGenerationScale;const q=[],i=J(U,V);q.push(h(N,i,V.imageType));const z=null===(A=V.irradiance)||void 0===A?void 0:A.irradianceTexture;if(z){var S,E;const A=d(U,V);let n=null;null!==(S=V.irradiance)&&void 0!==S&&null!==(E=S.irradianceTexture)&&void 0!==E&&E.dominantDirection&&(n=t.CU.vU(V.irradiance.irradianceTexture.dominantDirection)),q.push(c(N,A,z.size,V.imageType,n))}return Promise.all(q)}async function v(N,U,V,A,t,n,q,i,z,S,E){return await new Promise(((p,k)=>{if(V){const V=U.createTexture(null,!0,!0,null,1,null,(N=>{k(N)}),N);null===A||void 0===A||A.onEffectCreatedObservable.addOnce((i=>{i.executeWhenCompiled((()=>{A.externalTextureSamplerBinding=!0,A.onApply=A=>{A._bindTexture("textureSampler",V),A.setFloat2("scale",1,U._features.needsInvertingBitmap&&N instanceof ImageBitmap?-1:1)},U.scenes.length&&(U.scenes[0].postProcessManager.directRender([A],S,!0,n,q),U.restoreDefaultFramebuffer(),V.dispose(),URL.revokeObjectURL(t),p())}))}))}else{if(U._uploadImageToTexture(E,N,n,q),i){const V=z[q];V&&U._uploadImageToTexture(V._texture,N,n,0)}p()}}))}async function h(N,U){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:p;const A=N.getEngine();N.format=5,N.type=0,N.generateMipMaps=!0,N._cachedAnisotropicFilteringLevel=null,A.updateTextureSamplingMode(3,N),await H(N,U,!0,V),N.isReady=!0}async function c(N,U,V){let A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p,t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const n=N.getEngine(),q=new i.d(n,5),S=new z.b(n,q);N._irradianceTexture=S,S._dominantDirection=t,q.isCube=!0,q.format=5,q.type=0,q.generateMipMaps=!0,q._cachedAnisotropicFilteringLevel=null,q.generateMipMaps=!0,q.width=V,q.height=V,n.updateTextureSamplingMode(3,q),await H(q,[U],!1,A),n.generateMipMapsForCubemap(q),q.isReady=!0}async function H(N,U,t){let q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p;if(!A.Tools.IsExponentOfTwo(N.width))throw new Error("Texture size must be a power of two");const E=(0,n.ILog2)(N.width)+1,k=N.getEngine();let B=!1,C=!1,x=null,J=null,d=null;const r=k.getCaps();r.textureLOD?k._features.supportRenderAndCopyToLodForFloatTextures?r.textureHalfFloatRender&&r.textureHalfFloatLinearFiltering?(B=!0,N.type=2):r.textureFloatRender&&r.textureFloatLinearFiltering&&(B=!0,N.type=1):B=!1:(B=!1,C=t);let h=0;if(B)k.isWebGPU?(h=1,await V.e(42).then(V.bind(V,15405))):await V.e(35).then(V.bind(V,15410)),x=new S.c("rgbdDecode","rgbdDecode",null,null,1,null,3,k,!1,void 0,N.type,void 0,null,!1,void 0,h),N._isRGBD=!1,N.invertY=!1,J=k.createRenderTargetCubeTexture(N.width,{generateDepthBuffer:!1,generateMipMaps:!0,generateStencilBuffer:!1,samplingMode:3,type:N.type,format:5});else if(N._isRGBD=!0,N.invertY=!0,C){const U=3;d={};const V=N._lodGenerationScale,A=N._lodGenerationOffset;for(let t=0;t<U;t++){const n=(E-1)*V+A,q=A+(n-A)*(1-t/(U-1)),S=Math.round(Math.min(Math.max(q,0),n)),p=new i.d(k,2);p.isCube=!0,p.invertY=!0,p.generateMipMaps=!1,k.updateTextureSamplingMode(2,p);const B=new z.b(null);switch(B._isCube=!0,B._texture=p,d[S]=B,t){case 0:N._lodTextureLow=B;break;case 1:N._lodTextureMid=B;break;case 2:N._lodTextureHigh=B}}}const c=[];for(let V=0;V<U.length;V++)for(let A=0;A<6;A++){const t=U[V][A],n=new Blob([t],{type:q}),i=URL.createObjectURL(n);let z;if(k._features.forceBitmapOverHTMLImageElement)z=k.createImageBitmap(n,{premultiplyAlpha:"none"}).then((async U=>await v(U,k,B,x,i,A,V,C,d,J,N)));else{const U=new Image;U.src=i,z=new Promise(((t,n)=>{U.onload=()=>{v(U,k,B,x,i,A,V,C,d,J,N).then((()=>t())).catch((N=>{n(N)}))},U.onerror=N=>{n(N)}}))}c.push(z)}if(await Promise.all(c),U.length<E){let V;const A=Math.pow(2,E-1-U.length),t=A*A*4;switch(N.type){case 0:V=new Uint8Array(t);break;case 2:V=new Uint16Array(t);break;case 1:V=new Float32Array(t)}for(let n=U.length;n<E;n++)for(let U=0;U<6;U++){var H;k._uploadArrayBufferViewToTexture((null===(H=J)||void 0===H?void 0:H.texture)||N,V,U,n)}}if(J){const U=N._irradianceTexture;N._irradianceTexture=null,k._releaseTexture(N),J._swapAndDie(N),N._irradianceTexture=U}x&&x.dispose(),C&&(N._lodTextureHigh&&N._lodTextureHigh._texture&&(N._lodTextureHigh._texture.isReady=!0),N._lodTextureMid&&N._lodTextureMid._texture&&(N._lodTextureMid._texture.isReady=!0),N._lodTextureLow&&N._lodTextureLow._texture&&(N._lodTextureLow._texture.isReady=!0))}function Y(N,U){const V=(U=x(U)).irradiance;if(!V)return;const A=new q.d;t.CU.FromArrayToRef(V.x,0,A.x),t.CU.FromArrayToRef(V.y,0,A.y),t.CU.FromArrayToRef(V.z,0,A.z),t.CU.FromArrayToRef(V.xx,0,A.xx),t.CU.FromArrayToRef(V.yy,0,A.yy),t.CU.FromArrayToRef(V.zz,0,A.zz),t.CU.FromArrayToRef(V.yz,0,A.yz),t.CU.FromArrayToRef(V.zx,0,A.zx),t.CU.FromArrayToRef(V.xy,0,A.xy),N._sphericalPolynomial=A}function W(N,U,V,A,t){const n=h(N.getEngine().createRawCubeTexture(null,N.width,N.format,N.type,N.generateMipMaps,N.invertY,N.samplingMode,N._compression),U).then((()=>N));return N.onRebuildCallback=N=>({proxy:n,isReady:!0,isAsync:!0}),N._source=13,N._bufferViewArrayArray=U,N._lodGenerationScale=A,N._lodGenerationOffset=t,N._sphericalPolynomial=V,h(N,U).then((()=>(N.isReady=!0,N)))}}}]);