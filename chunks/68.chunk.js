"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{14192:(n,k,T)=>{T.r(k),T.d(k,{FlowGraphJsonPointerParserBlock:()=>P});var c=T(12829),K=T(12831);const Q=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class G{constructor(n,k){this.path=n,this.ownerBlock=k,this.templatedInputs=[];let T=Q.exec(n);const G=new Set;for(;T;){const[,w]=T;if(G.has(w))throw new Error("Duplicate template variable detected.");G.add(w),this.templatedInputs.push(k.registerDataInput(w,K.j,new c.d(0))),T=Q.exec(n)}}getAccessor(n,k){let T=this.path;for(const c of this.templatedInputs){const n=c.getValue(k).value;if("number"!==typeof n||n<0)throw new Error("Invalid value for templated input.");T=T.replace(`{${c.name}}`,n.toString())}return n.convert(T)}}var w=T(675),E=T(730),I=T(764),S=T(14053);class P extends S.b{constructor(n){super(K.e,n),this.config=n,this.object=this.registerDataOutput("object",K.e),this.propertyName=this.registerDataOutput("propertyName",K.e),this.setterFunction=this.registerDataOutput("setFunction",K.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",K.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",K.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new G(n.jsonPointer,this)}_doOperation(n){var k,T,c;const K=this.templateComponent.getAccessor(this.config.pathConverter,n),Q=K.info.get(K.object),G=null===(k=(T=K.info).getTarget)||void 0===k?void 0:k.call(T,K.object),w=null===(c=K.info.getPropertyName)||void 0===c?void 0:c[0](K.object);if(!G)throw new Error("Object is undefined");return this.object.setValue(G,n),w&&this.propertyName.setValue(w,n),Q}_setPropertyValue(n,k,T,c){var K,Q;const G=this.templateComponent.getAccessor(this.config.pathConverter,c),w=G.info.type;w.startsWith("Color")&&(T=W(T,w)),null===(K=(Q=G.info).set)||void 0===K||K.call(Q,T,G.object)}_getPropertyValue(n,k,T){const c=this.templateComponent.getAccessor(this.config.pathConverter,T),K=c.info.type,Q=c.info.get(c.object);return K.startsWith("Color")?function(n){if(n instanceof I.e)return new E.o(n.r,n.g,n.b);if(n instanceof I.g)return new E.p(n.r,n.g,n.b,n.a);throw new Error("Invalid color type")}(Q):Q}_getInterpolationAnimationPropertyInfo(n,k,T){const c=this.templateComponent.getAccessor(this.config.pathConverter,T);return(n,k,T,K)=>{var Q;const G=[],w=c.info.type;return w.startsWith("Color")&&(n=n.map((n=>({frame:n.frame,value:W(n.value,w)})))),null===(Q=c.info.interpolation)||void 0===Q||Q.forEach(((k,Q)=>{var w;const E=(null===(w=c.info.getPropertyName)||void 0===w?void 0:w[Q](c.object))||"Animation-interpolation-"+Q;let I=n;T!==k.type&&(I=n.map((n=>({frame:n.frame,value:k.getValue(void 0,n.value.wi?n.value.wi():[n.value],0,1)}))));const S=k.buildAnimations(c.object,E,60,I);for(const n of S)K&&n.babylonAnimation.setEasingFunction(K),G.push(n.babylonAnimation)})),G}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function W(n,k){return n.getClassName().startsWith("Color")?n:"Ri"===k?new I.e(n.x,n.y,n.z):"Si"===k?new I.g(n.x,n.y,n.z,n.w):n}(0,w.f)("FlowGraphJsonPointerParserBlock",P)},14053:(n,k,T)=>{T.d(k,{b:()=>w});var c=T(12845),K=T(12831);const Q="cachedOperationValue",G="cachedExecutionId";class w extends c.b{constructor(n,k){super(k),this.value=this.registerDataOutput("value",n),this.isValid=this.registerDataOutput("isValid",K.g)}_updateOutputs(n){const k=n._getExecutionVariable(this,G,-1),T=n._getExecutionVariable(this,Q,null);if(void 0!==T&&null!==T&&k===n.executionId)this.isValid.setValue(!0,n),this.value.setValue(T,n);else try{const k=this._doOperation(n);if(void 0===k||null===k)return void this.isValid.setValue(!1,n);n._setExecutionVariable(this,Q,k),n._setExecutionVariable(this,G,n.executionId),this.value.setValue(k,n),this.isValid.setValue(!0,n)}catch(c){this.isValid.setValue(!1,n)}}}}}]);