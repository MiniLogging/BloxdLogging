"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{13904:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphJsonPointerParserBlock:()=>j});var T=c(12512),Y=c(12517);const Z=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class w{constructor(W,F){this.path=W,this.ownerBlock=F,this.templatedInputs=[];let c=Z.exec(W);const w=new Set;for(;c;){const[,A]=c;if(w.has(A))throw new Error("Duplicate template variable detected.");w.add(A),this.templatedInputs.push(F.registerDataInput(A,Y.f,new T.c(0))),c=Z.exec(W)}}getAccessor(W,F){let c=this.path;for(const T of this.templatedInputs){const W=T.getValue(F).value;if("number"!==typeof W||W<0)throw new Error("Invalid value for templated input.");c=c.replace(`{${T.name}}`,W.toString())}return W.convert(c)}}var A=c(642),u=c(694),s=c(723),x=c(13768);class j extends x.d{constructor(W){super(Y.c,W),this.config=W,this.object=this.registerDataOutput("object",Y.c),this.propertyName=this.registerDataOutput("propertyName",Y.c),this.setterFunction=this.registerDataOutput("setFunction",Y.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",Y.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",Y.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new w(W.jsonPointer,this)}_doOperation(W){var F,c,T;const Y=this.templateComponent.getAccessor(this.config.pathConverter,W),Z=Y.info.get(Y.object),w=null===(F=(c=Y.info).getTarget)||void 0===F?void 0:F.call(c,Y.object),A=null===(T=Y.info.getPropertyName)||void 0===T?void 0:T[0](Y.object);if(!w)throw new Error("Object is undefined");return this.object.setValue(w,W),A&&this.propertyName.setValue(A,W),Z}_setPropertyValue(W,F,c,T){var Y,Z;const w=this.templateComponent.getAccessor(this.config.pathConverter,T),A=w.info.type;A.startsWith("Color")&&(c=N(c,A)),null===(Y=(Z=w.info).set)||void 0===Y||Y.call(Z,c,w.object)}_getPropertyValue(W,F,c){const T=this.templateComponent.getAccessor(this.config.pathConverter,c),Y=T.info.type,Z=T.info.get(T.object);return Y.startsWith("Color")?function(W){if(W instanceof s.b)return new u.l(W.r,W.g,W.b);if(W instanceof s.c)return new u.m(W.r,W.g,W.b,W.a);throw new Error("Invalid color type")}(Z):Z}_getInterpolationAnimationPropertyInfo(W,F,c){const T=this.templateComponent.getAccessor(this.config.pathConverter,c);return(W,F,c,Y)=>{var Z;const w=[],A=T.info.type;return A.startsWith("Color")&&(W=W.map((W=>({frame:W.frame,value:N(W.value,A)})))),null===(Z=T.info.interpolation)||void 0===Z||Z.forEach(((F,Z)=>{var A;const u=(null===(A=T.info.getPropertyName)||void 0===A?void 0:A[Z](T.object))||"Animation-interpolation-"+Z;let s=W;c!==F.type&&(s=W.map((W=>({frame:W.frame,value:F.getValue(void 0,W.value.zi?W.value.zi():[W.value],0,1)}))));const x=F.buildAnimations(T.object,u,60,s);for(const W of x)Y&&W.babylonAnimation.setEasingFunction(Y),w.push(W.babylonAnimation)})),w}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function N(W,F){return W.getClassName().startsWith("Color")?W:"Ui"===F?new s.b(W.x,W.y,W.z):"Vi"===F?new s.c(W.x,W.y,W.z,W.w):W}(0,A.h)("FlowGraphJsonPointerParserBlock",j)},13768:(W,F,c)=>{c.d(F,{d:()=>A});var T=c(12543),Y=c(12517);const Z="cachedOperationValue",w="cachedExecutionId";class A extends T.d{constructor(W,F){super(F),this.value=this.registerDataOutput("value",W),this.isValid=this.registerDataOutput("isValid",Y.e)}_updateOutputs(W){const F=W._getExecutionVariable(this,w,-1),c=W._getExecutionVariable(this,Z,null);if(void 0!==c&&null!==c&&F===W.executionId)this.isValid.setValue(!0,W),this.value.setValue(c,W);else try{const F=this._doOperation(W);if(void 0===F||null===F)return void this.isValid.setValue(!1,W);W._setExecutionVariable(this,Z,F),W._setExecutionVariable(this,w,W.executionId),this.value.setValue(F,W),this.isValid.setValue(!0,W)}catch(T){this.isValid.setValue(!1,W)}}}}}]);