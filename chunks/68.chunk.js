"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{13974:(A,X,s)=>{s.r(X),s.d(X,{FlowGraphJsonPointerParserBlock:()=>v});var N=s(12672),f=s(12677);const E=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class g{constructor(A,X){this.path=A,this.ownerBlock=X,this.templatedInputs=[];let s=E.exec(A);const g=new Set;for(;s;){const[,K]=s;if(g.has(K))throw new Error("Duplicate template variable detected.");g.add(K),this.templatedInputs.push(X.registerDataInput(K,f.f,new N.e(0))),s=E.exec(A)}}getAccessor(A,X){let s=this.path;for(const N of this.templatedInputs){const A=N.getValue(X).value;if("number"!==typeof A||A<0)throw new Error("Invalid value for templated input.");s=s.replace(`{${N.name}}`,A.toString())}return A.convert(s)}}var K=s(616),r=s(678),i=s(709),Y=s(13839);class v extends Y.e{constructor(A){super(f.b,A),this.config=A,this.object=this.registerDataOutput("object",f.b),this.propertyName=this.registerDataOutput("propertyName",f.b),this.setterFunction=this.registerDataOutput("setFunction",f.b,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",f.b,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",f.b,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new g(A.jsonPointer,this)}_doOperation(A){var X,s,N;const f=this.templateComponent.getAccessor(this.config.pathConverter,A),E=f.info.get(f.object),g=null===(X=(s=f.info).getTarget)||void 0===X?void 0:X.call(s,f.object),K=null===(N=f.info.getPropertyName)||void 0===N?void 0:N[0](f.object);if(!g)throw new Error("Object is undefined");return this.object.setValue(g,A),K&&this.propertyName.setValue(K,A),E}_setPropertyValue(A,X,s,N){var f,E;const g=this.templateComponent.getAccessor(this.config.pathConverter,N),K=g.info.type;K.startsWith("Color")&&(s=c(s,K)),null===(f=(E=g.info).set)||void 0===f||f.call(E,s,g.object)}_getPropertyValue(A,X,s){const N=this.templateComponent.getAccessor(this.config.pathConverter,s),f=N.info.type,E=N.info.get(N.object);return f.startsWith("Color")?function(A){if(A instanceof i.e)return new r.k(A.r,A.g,A.b);if(A instanceof i.h)return new r.m(A.r,A.g,A.b,A.a);throw new Error("Invalid color type")}(E):E}_getInterpolationAnimationPropertyInfo(A,X,s){const N=this.templateComponent.getAccessor(this.config.pathConverter,s);return(A,X,s,f)=>{var E;const g=[],K=N.info.type;return K.startsWith("Color")&&(A=A.map((A=>({frame:A.frame,value:c(A.value,K)})))),null===(E=N.info.interpolation)||void 0===E||E.forEach(((X,E)=>{var K;const r=(null===(K=N.info.getPropertyName)||void 0===K?void 0:K[E](N.object))||"Animation-interpolation-"+E;let i=A;s!==X.type&&(i=A.map((A=>({frame:A.frame,value:X.getValue(void 0,A.value.zi?A.value.zi():[A.value],0,1)}))));const Y=X.buildAnimations(N.object,r,60,i);for(const A of Y)f&&A.babylonAnimation.setEasingFunction(f),g.push(A.babylonAnimation)})),g}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function c(A,X){return A.getClassName().startsWith("Color")?A:"Ui"===X?new i.e(A.x,A.y,A.z):"Vi"===X?new i.h(A.x,A.y,A.z,A.w):A}(0,K.f)("FlowGraphJsonPointerParserBlock",v)},13839:(A,X,s)=>{s.d(X,{e:()=>K});var N=s(12701),f=s(12677);const E="cachedOperationValue",g="cachedExecutionId";class K extends N.e{constructor(A,X){super(X),this.value=this.registerDataOutput("value",A),this.isValid=this.registerDataOutput("isValid",f.c)}_updateOutputs(A){const X=A._getExecutionVariable(this,g,-1),s=A._getExecutionVariable(this,E,null);if(void 0!==s&&null!==s&&X===A.executionId)this.isValid.setValue(!0,A),this.value.setValue(s,A);else try{const X=this._doOperation(A);if(void 0===X||null===X)return void this.isValid.setValue(!1,A);A._setExecutionVariable(this,E,X),A._setExecutionVariable(this,g,A.executionId),this.value.setValue(X,A),this.isValid.setValue(!0,A)}catch(N){this.isValid.setValue(!1,A)}}}}}]);