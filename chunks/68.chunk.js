"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{14157:(U,M,b)=>{b.r(M),b.d(M,{FlowGraphJsonPointerParserBlock:()=>P});var a=b(12767),A=b(12775);const H=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class W{constructor(U,M){this.path=U,this.ownerBlock=M,this.templatedInputs=[];let b=H.exec(U);const W=new Set;for(;b;){const[,y]=b;if(W.has(y))throw new Error("Duplicate template variable detected.");W.add(y),this.templatedInputs.push(M.registerDataInput(y,A.i,new a.e(0))),b=H.exec(U)}}getAccessor(U,M){let b=this.path;for(const a of this.templatedInputs){const U=a.getValue(M).value;if("number"!==typeof U||U<0)throw new Error("Invalid value for templated input.");b=b.replace(`{${a.name}}`,U.toString())}return U.convert(b)}}var y=b(609),O=b(670),e=b(707),x=b(14008);class P extends x.c{constructor(U){super(A.c,U),this.config=U,this.object=this.registerDataOutput("object",A.c),this.propertyName=this.registerDataOutput("propertyName",A.c),this.setterFunction=this.registerDataOutput("setFunction",A.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",A.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",A.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new W(U.jsonPointer,this)}_doOperation(U){var M,b,a;const A=this.templateComponent.getAccessor(this.config.pathConverter,U),H=A.info.get(A.object),W=null===(M=(b=A.info).getTarget)||void 0===M?void 0:M.call(b,A.object),y=null===(a=A.info.getPropertyName)||void 0===a?void 0:a[0](A.object);if(!W)throw new Error("Object is undefined");return this.object.setValue(W,U),y&&this.propertyName.setValue(y,U),H}_setPropertyValue(U,M,b,a){var A,H;const W=this.templateComponent.getAccessor(this.config.pathConverter,a),y=W.info.type;y.startsWith("Color")&&(b=Z(b,y)),null===(A=(H=W.info).set)||void 0===A||A.call(H,b,W.object)}_getPropertyValue(U,M,b){const a=this.templateComponent.getAccessor(this.config.pathConverter,b),A=a.info.type,H=a.info.get(a.object);return A.startsWith("Color")?function(U){if(U instanceof e.c)return new O.l(U.r,U.g,U.b);if(U instanceof e.e)return new O.n(U.r,U.g,U.b,U.a);throw new Error("Invalid color type")}(H):H}_getInterpolationAnimationPropertyInfo(U,M,b){const a=this.templateComponent.getAccessor(this.config.pathConverter,b);return(U,M,b,A)=>{var H;const W=[],y=a.info.type;return y.startsWith("Color")&&(U=U.map((U=>({frame:U.frame,value:Z(U.value,y)})))),null===(H=a.info.interpolation)||void 0===H||H.forEach(((M,H)=>{var y;const O=(null===(y=a.info.getPropertyName)||void 0===y?void 0:y[H](a.object))||"Animation-interpolation-"+H;let e=U;b!==M.type&&(e=U.map((U=>({frame:U.frame,value:M.getValue(void 0,U.value.tk?U.value.tk():[U.value],0,1)}))));const x=M.buildAnimations(a.object,O,60,e);for(const U of x)A&&U.babylonAnimation.setEasingFunction(A),W.push(U.babylonAnimation)})),W}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function Z(U,M){return U.getClassName().startsWith("Color")?U:"Ck"===M?new e.c(U.x,U.y,U.z):"Dk"===M?new e.e(U.x,U.y,U.z,U.w):U}(0,y.i)("FlowGraphJsonPointerParserBlock",P)},14008:(U,M,b)=>{b.d(M,{c:()=>y});var a=b(12795),A=b(12775);const H="cachedOperationValue",W="cachedExecutionId";class y extends a.c{constructor(U,M){super(M),this.value=this.registerDataOutput("value",U),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(U){const M=U._getExecutionVariable(this,W,-1),b=U._getExecutionVariable(this,H,null);if(void 0!==b&&null!==b&&M===U.executionId)this.isValid.setValue(!0,U),this.value.setValue(b,U);else try{const M=this._doOperation(U);if(void 0===M||null===M)return void this.isValid.setValue(!1,U);U._setExecutionVariable(this,H,M),U._setExecutionVariable(this,W,U.executionId),this.value.setValue(M,U),this.isValid.setValue(!0,U)}catch(a){this.isValid.setValue(!1,U)}}}}}]);