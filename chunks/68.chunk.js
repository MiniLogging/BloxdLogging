"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{14022:(J,T,b)=>{b.r(T),b.d(T,{FlowGraphJsonPointerParserBlock:()=>a});var q=b(12598),t=b(12603);const j=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class B{constructor(J,T){this.path=J,this.ownerBlock=T,this.templatedInputs=[];let b=j.exec(J);const B=new Set;for(;b;){const[,Y]=b;if(B.has(Y))throw new Error("Duplicate template variable detected.");B.add(Y),this.templatedInputs.push(T.registerDataInput(Y,t.i,new q.e(0))),b=j.exec(J)}}getAccessor(J,T){let b=this.path;for(const q of this.templatedInputs){const J=q.getValue(T).value;if("number"!==typeof J||J<0)throw new Error("Invalid value for templated input.");b=b.replace(`{${q.name}}`,J.toString())}return J.convert(b)}}var Y=b(639),C=b(697),F=b(731),A=b(13865);class a extends A.c{constructor(J){super(t.c,J),this.config=J,this.object=this.registerDataOutput("object",t.c),this.propertyName=this.registerDataOutput("propertyName",t.c),this.setterFunction=this.registerDataOutput("setFunction",t.c,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",t.c,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",t.c,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new B(J.jsonPointer,this)}_doOperation(J){var T,b,q;const t=this.templateComponent.getAccessor(this.config.pathConverter,J),j=t.info.get(t.object),B=null===(T=(b=t.info).getTarget)||void 0===T?void 0:T.call(b,t.object),Y=null===(q=t.info.getPropertyName)||void 0===q?void 0:q[0](t.object);if(!B)throw new Error("Object is undefined");return this.object.setValue(B,J),Y&&this.propertyName.setValue(Y,J),j}_setPropertyValue(J,T,b,q){var t,j;const B=this.templateComponent.getAccessor(this.config.pathConverter,q),Y=B.info.type;Y.startsWith("Color")&&(b=P(b,Y)),null===(t=(j=B.info).set)||void 0===t||t.call(j,b,B.object)}_getPropertyValue(J,T,b){const q=this.templateComponent.getAccessor(this.config.pathConverter,b),t=q.info.type,j=q.info.get(q.object);return t.startsWith("Color")?function(J){if(J instanceof F.b)return new C.n(J.r,J.g,J.b);if(J instanceof F.d)return new C.p(J.r,J.g,J.b,J.a);throw new Error("Invalid color type")}(j):j}_getInterpolationAnimationPropertyInfo(J,T,b){const q=this.templateComponent.getAccessor(this.config.pathConverter,b);return(J,T,b,t)=>{var j;const B=[],Y=q.info.type;return Y.startsWith("Color")&&(J=J.map((J=>({frame:J.frame,value:P(J.value,Y)})))),null===(j=q.info.interpolation)||void 0===j||j.forEach(((T,j)=>{var Y;const C=(null===(Y=q.info.getPropertyName)||void 0===Y?void 0:Y[j](q.object))||"Animation-interpolation-"+j;let F=J;b!==T.type&&(F=J.map((J=>({frame:J.frame,value:T.getValue(void 0,J.value.Ai?J.value.Ai():[J.value],0,1)}))));const A=T.buildAnimations(q.object,C,60,F);for(const J of A)t&&J.babylonAnimation.setEasingFunction(t),B.push(J.babylonAnimation)})),B}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function P(J,T){return J.getClassName().startsWith("Color")?J:"Vi"===T?new F.b(J.x,J.y,J.z):"Wi"===T?new F.d(J.x,J.y,J.z,J.w):J}(0,Y.g)("FlowGraphJsonPointerParserBlock",a)},13865:(J,T,b)=>{b.d(T,{c:()=>Y});var q=b(12627),t=b(12603);const j="cachedOperationValue",B="cachedExecutionId";class Y extends q.b{constructor(J,T){super(T),this.value=this.registerDataOutput("value",J),this.isValid=this.registerDataOutput("isValid",t.e)}_updateOutputs(J){const T=J._getExecutionVariable(this,B,-1),b=J._getExecutionVariable(this,j,null);if(void 0!==b&&null!==b&&T===J.executionId)this.isValid.setValue(!0,J),this.value.setValue(b,J);else try{const T=this._doOperation(J);if(void 0===T||null===T)return void this.isValid.setValue(!1,J);J._setExecutionVariable(this,j,T),J._setExecutionVariable(this,B,J.executionId),this.value.setValue(T,J),this.isValid.setValue(!0,J)}catch(q){this.isValid.setValue(!1,J)}}}}}]);