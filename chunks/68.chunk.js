"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{14300:(u,F,z)=>{z.r(F),z.d(F,{FlowGraphJsonPointerParserBlock:()=>W});var p=z(12944),b=z(12952);const R=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class c{constructor(u,F){this.path=u,this.ownerBlock=F,this.templatedInputs=[];let z=R.exec(u);const c=new Set;for(;z;){const[,I]=z;if(c.has(I))throw new Error("Duplicate template variable detected.");c.add(I),this.templatedInputs.push(F.registerDataInput(I,b.l,new p.d(0))),z=R.exec(u)}}getAccessor(u,F){let z=this.path;for(const p of this.templatedInputs){const u=p.getValue(F).value;if("number"!==typeof u||u<0)throw new Error("Invalid value for templated input.");z=z.replace(`{${p.name}}`,u.toString())}return u.convert(z)}}var I=z(668),G=z(730),X=z(766),j=z(14133);class W extends j.e{constructor(u){super(b.e,u),this.config=u,this.object=this.registerDataOutput("object",b.e),this.propertyName=this.registerDataOutput("propertyName",b.e),this.setterFunction=this.registerDataOutput("setFunction",b.e,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",b.e,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",b.e,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new c(u.jsonPointer,this)}_doOperation(u){var F,z,p;const b=this.templateComponent.getAccessor(this.config.pathConverter,u),R=b.info.get(b.object),c=null===(F=(z=b.info).getTarget)||void 0===F?void 0:F.call(z,b.object),I=null===(p=b.info.getPropertyName)||void 0===p?void 0:p[0](b.object);if(!c)throw new Error("Object is undefined");return this.object.setValue(c,u),I&&this.propertyName.setValue(I,u),R}_setPropertyValue(u,F,z,p){var b,R;const c=this.templateComponent.getAccessor(this.config.pathConverter,p),I=c.info.type;I.startsWith("Color")&&(z=E(z,I)),null===(b=(R=c.info).set)||void 0===b||b.call(R,z,c.object)}_getPropertyValue(u,F,z){const p=this.templateComponent.getAccessor(this.config.pathConverter,z),b=p.info.type,R=p.info.get(p.object);return b.startsWith("Color")?function(u){if(u instanceof X.b)return new G.l(u.r,u.g,u.b);if(u instanceof X.f)return new G.p(u.r,u.g,u.b,u.a);throw new Error("Invalid color type")}(R):R}_getInterpolationAnimationPropertyInfo(u,F,z){const p=this.templateComponent.getAccessor(this.config.pathConverter,z);return(u,F,z,b)=>{var R;const c=[],I=p.info.type;return I.startsWith("Color")&&(u=u.map((u=>({frame:u.frame,value:E(u.value,I)})))),null===(R=p.info.interpolation)||void 0===R||R.forEach(((F,R)=>{var I;const G=(null===(I=p.info.getPropertyName)||void 0===I?void 0:I[R](p.object))||"Animation-interpolation-"+R;let X=u;z!==F.type&&(X=u.map((u=>({frame:u.frame,value:F.getValue(void 0,u.value.fk?u.value.fk():[u.value],0,1)}))));const j=F.buildAnimations(p.object,G,60,X);for(const u of j)b&&u.babylonAnimation.setEasingFunction(b),c.push(u.babylonAnimation)})),c}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function E(u,F){return u.getClassName().startsWith("Color")?u:"pk"===F?new X.b(u.x,u.y,u.z):"qk"===F?new X.f(u.x,u.y,u.z,u.w):u}(0,I.h)("FlowGraphJsonPointerParserBlock",W)},14133:(u,F,z)=>{z.d(F,{e:()=>I});var p=z(12980),b=z(12952);const R="cachedOperationValue",c="cachedExecutionId";class I extends p.d{constructor(u,F){super(F),this.value=this.registerDataOutput("value",u),this.isValid=this.registerDataOutput("isValid",b.i)}_updateOutputs(u){const F=u._getExecutionVariable(this,c,-1),z=u._getExecutionVariable(this,R,null);if(void 0!==z&&null!==z&&F===u.executionId)this.isValid.setValue(!0,u),this.value.setValue(z,u);else try{const F=this._doOperation(u);if(void 0===F||null===F)return void this.isValid.setValue(!1,u);u._setExecutionVariable(this,R,F),u._setExecutionVariable(this,c,u.executionId),this.value.setValue(F,u),this.isValid.setValue(!0,u)}catch(p){this.isValid.setValue(!1,u)}}}}}]);