"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[68],{14186:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphJsonPointerParserBlock:()=>L});var b=O(12867),F=O(12871);const g=new RegExp(/\/\{(\w+)\}(?=\/|$)/g);class m{constructor(P,Q){this.path=P,this.ownerBlock=Q,this.templatedInputs=[];let O=g.exec(P);const m=new Set;for(;O;){const[,q]=O;if(m.has(q))throw new Error("Duplicate template variable detected.");m.add(q),this.templatedInputs.push(Q.registerDataInput(q,F.h,new b.c(0))),O=g.exec(P)}}getAccessor(P,Q){let O=this.path;for(const b of this.templatedInputs){const P=b.getValue(Q).value;if("number"!==typeof P||P<0)throw new Error("Invalid value for templated input.");O=O.replace(`{${b.name}}`,P.toString())}return P.convert(O)}}var q=O(696),R=O(751),X=O(797),C=O(14042);class L extends C.e{constructor(P){super(F.d,P),this.config=P,this.object=this.registerDataOutput("object",F.d),this.propertyName=this.registerDataOutput("propertyName",F.d),this.setterFunction=this.registerDataOutput("setFunction",F.d,this._setPropertyValue.bind(this)),this.getterFunction=this.registerDataOutput("getFunction",F.d,this._getPropertyValue.bind(this)),this.generateAnimationsFunction=this.registerDataOutput("generateAnimationsFunction",F.d,this._getInterpolationAnimationPropertyInfo.bind(this)),this.templateComponent=new m(P.jsonPointer,this)}_doOperation(P){var Q,O,b;const F=this.templateComponent.getAccessor(this.config.pathConverter,P),g=F.info.get(F.object),m=null===(Q=(O=F.info).getTarget)||void 0===Q?void 0:Q.call(O,F.object),q=null===(b=F.info.getPropertyName)||void 0===b?void 0:b[0](F.object);if(!m)throw new Error("Object is undefined");return this.object.setValue(m,P),q&&this.propertyName.setValue(q,P),g}_setPropertyValue(P,Q,O,b){var F,g;const m=this.templateComponent.getAccessor(this.config.pathConverter,b),q=m.info.type;q.startsWith("Color")&&(O=G(O,q)),null===(F=(g=m.info).set)||void 0===F||F.call(g,O,m.object)}_getPropertyValue(P,Q,O){const b=this.templateComponent.getAccessor(this.config.pathConverter,O),F=b.info.type,g=b.info.get(b.object);return F.startsWith("Color")?function(P){if(P instanceof X.d)return new R.j(P.r,P.g,P.b);if(P instanceof X.h)return new R.k(P.r,P.g,P.b,P.a);throw new Error("Invalid color type")}(g):g}_getInterpolationAnimationPropertyInfo(P,Q,O){const b=this.templateComponent.getAccessor(this.config.pathConverter,O);return(P,Q,O,F)=>{var g;const m=[],q=b.info.type;return q.startsWith("Color")&&(P=P.map((P=>({frame:P.frame,value:G(P.value,q)})))),null===(g=b.info.interpolation)||void 0===g||g.forEach(((Q,g)=>{var q;const R=(null===(q=b.info.getPropertyName)||void 0===q?void 0:q[g](b.object))||"Animation-interpolation-"+g;let X=P;O!==Q.type&&(X=P.map((P=>({frame:P.frame,value:Q.getValue(void 0,P.value.kk?P.value.kk():[P.value],0,1)}))));const C=Q.buildAnimations(b.object,R,60,X);for(const P of C)F&&P.babylonAnimation.setEasingFunction(F),m.push(P.babylonAnimation)})),m}}getClassName(){return"FlowGraphJsonPointerParserBlock"}}function G(P,Q){return P.getClassName().startsWith("Color")?P:"uk"===Q?new X.d(P.x,P.y,P.z):"vk"===Q?new X.h(P.x,P.y,P.z,P.w):P}(0,q.f)("FlowGraphJsonPointerParserBlock",L)},14042:(P,Q,O)=>{O.d(Q,{e:()=>q});var b=O(12885),F=O(12871);const g="cachedOperationValue",m="cachedExecutionId";class q extends b.c{constructor(P,Q){super(Q),this.value=this.registerDataOutput("value",P),this.isValid=this.registerDataOutput("isValid",F.g)}_updateOutputs(P){const Q=P._getExecutionVariable(this,m,-1),O=P._getExecutionVariable(this,g,null);if(void 0!==O&&null!==O&&Q===P.executionId)this.isValid.setValue(!0,P),this.value.setValue(O,P);else try{const Q=this._doOperation(P);if(void 0===Q||null===Q)return void this.isValid.setValue(!1,P);P._setExecutionVariable(this,g,Q),P._setExecutionVariable(this,m,P.executionId),this.value.setValue(Q,P),this.isValid.setValue(!0,P)}catch(b){this.isValid.setValue(!1,P)}}}}}]);