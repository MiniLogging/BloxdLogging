"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13690:(W,F,c)=>{c.r(F),c.d(F,{FlowGraphPlayAnimationBlock:()=>A});var T=c(12563),Y=c(12517),Z=c(642),w=c(13634);class A extends T.c{constructor(W){super(W,["animationLoop","animationEnd","animationGroupLoop"]),this.config=W,this.speed=this.registerDataInput("speed",Y.n),this.loop=this.registerDataInput("loop",Y.e),this.from=this.registerDataInput("from",Y.n,0),this.to=this.registerDataInput("to",Y.n),this.currentFrame=this.registerDataOutput("currentFrame",Y.n),this.currentTime=this.registerDataOutput("currentTime",Y.n),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",Y.c),this.animationGroup=this.registerDataInput("animationGroup",Y.c,null===W||void 0===W?void 0:W.animationGroup),this.animation=this.registerDataInput("animation",Y.c),this.object=this.registerDataInput("object",Y.c)}_preparePendingTasks(W){const F=this.animationGroup.getValue(W),c=this.animation.getValue(W);if(!F&&!c)return this._reportError(W,"No animation or animation group provided");{const Y=this.currentAnimationGroup.getValue(W);Y&&Y!==F&&Y.dispose();let Z=F;if(c&&!Z){const F=this.object.getValue(W);if(!F)return this._reportError(W,"No target object provided");const T=Array.isArray(c)?c:[c],Y=T[0].name;Z=new w.AnimationGroup("flowGraphAnimationGroup-"+Y+"-"+F.name,W.configuration.rg);let A=!1;const u=W._getGlobalContextVariable("interpolationAnimations",[]);for(const W of T)Z.addTargetedAnimation(W,F),-1!==u.indexOf(W.uniqueId)&&(A=!0);A&&this._checkInterpolationDuplications(W,T,F)}const A=this.speed.getValue(W)||1,u=this.from.getValue(W)??0,s=this.to.getValue(W)||Z.to,x=!isFinite(s)||this.loop.getValue(W);this.currentAnimationGroup.setValue(Z,W);const j=W._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==j.indexOf(Z.uniqueId)&&Z.stop();try{Z.start(x,A,u,s),Z.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(W))),Z.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(W))),Z.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(W))),Z.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(W))),j.push(Z.uniqueId),W._setGlobalContextVariable("currentlyRunningAnimationGroups",j)}catch(T){this._reportError(W,T)}}}_reportError(W,F){super._reportError(W,F),this.currentFrame.setValue(-1,W),this.currentTime.setValue(-1,W)}_executeOnTick(W){const F=this.currentAnimationGroup.getValue(W);var c;F&&(this.currentFrame.setValue(F.getCurrentFrame(),W),this.currentTime.setValue((null===(c=F.animatables[0])||void 0===c?void 0:c.elapsedTime)??0,W))}_execute(W){this._startPendingTasks(W)}_onAnimationGroupEnd(W){this._removeFromCurrentlyRunning(W,this.currentAnimationGroup.getValue(W)),this._resetAfterCanceled(W),this.done._activateSignal(W)}_checkInterpolationDuplications(W,F,c){const T=W._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const Y of T){const T=W.assetsContext.animationGroups.find((W=>W.uniqueId===Y));if(T)for(const Y of T.targetedAnimations)for(const Z of F)Y.animation.targetProperty===Z.targetProperty&&Y.target===c&&this._stopAnimationGroup(W,T)}}_stopAnimationGroup(W,F){F.stop(!0),F.dispose(),this._removeFromCurrentlyRunning(W,F)}_removeFromCurrentlyRunning(W,F){const c=W._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),T=c.indexOf(F.uniqueId);-1!==T&&(c.splice(T,1),W._setGlobalContextVariable("currentlyRunningAnimationGroups",c))}_cancelPendingTasks(W){const F=this.currentAnimationGroup.getValue(W);F&&this._stopAnimationGroup(W,F)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,Z.h)("FlowGraphPlayAnimationBlock",A)}}]);