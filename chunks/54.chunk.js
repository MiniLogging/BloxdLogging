"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13968:(P,Q,O)=>{O.r(Q),O.d(Q,{FlowGraphPlayAnimationBlock:()=>q});var b=O(12916),F=O(12871),g=O(696),m=O(13907);class q extends b.b{constructor(P){super(P,["animationLoop","animationEnd","animationGroupLoop"]),this.config=P,this.speed=this.registerDataInput("speed",F.o),this.loop=this.registerDataInput("loop",F.g),this.from=this.registerDataInput("from",F.o,0),this.to=this.registerDataInput("to",F.o),this.currentFrame=this.registerDataOutput("currentFrame",F.o),this.currentTime=this.registerDataOutput("currentTime",F.o),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",F.d),this.animationGroup=this.registerDataInput("animationGroup",F.d,null===P||void 0===P?void 0:P.animationGroup),this.animation=this.registerDataInput("animation",F.d),this.object=this.registerDataInput("object",F.d)}_preparePendingTasks(P){const Q=this.animationGroup.getValue(P),O=this.animation.getValue(P);if(!Q&&!O)return this._reportError(P,"No animation or animation group provided");{const F=this.currentAnimationGroup.getValue(P);F&&F!==Q&&F.dispose();let g=Q;if(O&&!g){const Q=this.object.getValue(P);if(!Q)return this._reportError(P,"No target object provided");const b=Array.isArray(O)?O:[O],F=b[0].name;g=new m.AnimationGroup("flowGraphAnimationGroup-"+F+"-"+Q.name,P.configuration.qg);let q=!1;const R=P._getGlobalContextVariable("interpolationAnimations",[]);for(const P of b)g.addTargetedAnimation(P,Q),-1!==R.indexOf(P.uniqueId)&&(q=!0);q&&this._checkInterpolationDuplications(P,b,Q)}const q=this.speed.getValue(P)||1,R=this.from.getValue(P)??0,X=this.to.getValue(P)||g.to,C=!isFinite(X)||this.loop.getValue(P);this.currentAnimationGroup.setValue(g,P);const L=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==L.indexOf(g.uniqueId)&&g.stop();try{g.start(C,q,R,X),g.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(P))),g.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(P))),g.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(P))),g.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(P))),L.push(g.uniqueId),P._setGlobalContextVariable("currentlyRunningAnimationGroups",L)}catch(b){this._reportError(P,b)}}}_reportError(P,Q){super._reportError(P,Q),this.currentFrame.setValue(-1,P),this.currentTime.setValue(-1,P)}_executeOnTick(P){const Q=this.currentAnimationGroup.getValue(P);var O;Q&&(this.currentFrame.setValue(Q.getCurrentFrame(),P),this.currentTime.setValue((null===(O=Q.animatables[0])||void 0===O?void 0:O.elapsedTime)??0,P))}_execute(P){this._startPendingTasks(P)}_onAnimationGroupEnd(P){this._removeFromCurrentlyRunning(P,this.currentAnimationGroup.getValue(P)),this._resetAfterCanceled(P),this.done._activateSignal(P)}_checkInterpolationDuplications(P,Q,O){const b=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const F of b){const b=P.assetsContext.animationGroups.find((P=>P.uniqueId===F));if(b)for(const F of b.targetedAnimations)for(const g of Q)F.animation.targetProperty===g.targetProperty&&F.target===O&&this._stopAnimationGroup(P,b)}}_stopAnimationGroup(P,Q){Q.stop(!0),Q.dispose(),this._removeFromCurrentlyRunning(P,Q)}_removeFromCurrentlyRunning(P,Q){const O=P._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),b=O.indexOf(Q.uniqueId);-1!==b&&(O.splice(b,1),P._setGlobalContextVariable("currentlyRunningAnimationGroups",O))}_cancelPendingTasks(P){const Q=this.currentAnimationGroup.getValue(P);Q&&this._stopAnimationGroup(P,Q)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,g.f)("FlowGraphPlayAnimationBlock",q)}}]);