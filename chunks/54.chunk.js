"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13976:(n,k,T)=>{T.r(k),T.d(k,{FlowGraphPlayAnimationBlock:()=>w});var c=T(12871),K=T(12831),Q=T(675),G=T(13915);class w extends c.e{constructor(n){super(n,["animationLoop","animationEnd","animationGroupLoop"]),this.config=n,this.speed=this.registerDataInput("speed",K.w),this.loop=this.registerDataInput("loop",K.g),this.from=this.registerDataInput("from",K.w,0),this.to=this.registerDataInput("to",K.w),this.currentFrame=this.registerDataOutput("currentFrame",K.w),this.currentTime=this.registerDataOutput("currentTime",K.w),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",K.e),this.animationGroup=this.registerDataInput("animationGroup",K.e,null===n||void 0===n?void 0:n.animationGroup),this.animation=this.registerDataInput("animation",K.e),this.object=this.registerDataInput("object",K.e)}_preparePendingTasks(n){const k=this.animationGroup.getValue(n),T=this.animation.getValue(n);if(!k&&!T)return this._reportError(n,"No animation or animation group provided");{const K=this.currentAnimationGroup.getValue(n);K&&K!==k&&K.dispose();let Q=k;if(T&&!Q){const k=this.object.getValue(n);if(!k)return this._reportError(n,"No target object provided");const c=Array.isArray(T)?T:[T],K=c[0].name;Q=new G.AnimationGroup("flowGraphAnimationGroup-"+K+"-"+k.name,n.configuration.me);let w=!1;const E=n._getGlobalContextVariable("interpolationAnimations",[]);for(const n of c)Q.addTargetedAnimation(n,k),-1!==E.indexOf(n.uniqueId)&&(w=!0);w&&this._checkInterpolationDuplications(n,c,k)}const w=this.speed.getValue(n)||1,E=this.from.getValue(n)??0,I=this.to.getValue(n)||Q.to,S=!isFinite(I)||this.loop.getValue(n);this.currentAnimationGroup.setValue(Q,n);const P=n._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==P.indexOf(Q.uniqueId)&&Q.stop();try{Q.start(S,w,E,I),Q.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(n))),Q.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(n))),Q.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(n))),Q.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(n))),P.push(Q.uniqueId),n._setGlobalContextVariable("currentlyRunningAnimationGroups",P)}catch(c){this._reportError(n,c)}}}_reportError(n,k){super._reportError(n,k),this.currentFrame.setValue(-1,n),this.currentTime.setValue(-1,n)}_executeOnTick(n){const k=this.currentAnimationGroup.getValue(n);var T;k&&(this.currentFrame.setValue(k.getCurrentFrame(),n),this.currentTime.setValue((null===(T=k.animatables[0])||void 0===T?void 0:T.elapsedTime)??0,n))}_execute(n){this._startPendingTasks(n)}_onAnimationGroupEnd(n){this._removeFromCurrentlyRunning(n,this.currentAnimationGroup.getValue(n)),this._resetAfterCanceled(n),this.done._activateSignal(n)}_checkInterpolationDuplications(n,k,T){const c=n._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const K of c){const c=n.assetsContext.animationGroups.find((n=>n.uniqueId===K));if(c)for(const K of c.targetedAnimations)for(const Q of k)K.animation.targetProperty===Q.targetProperty&&K.target===T&&this._stopAnimationGroup(n,c)}}_stopAnimationGroup(n,k){k.stop(!0),k.dispose(),this._removeFromCurrentlyRunning(n,k)}_removeFromCurrentlyRunning(n,k){const T=n._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),c=T.indexOf(k.uniqueId);-1!==c&&(T.splice(c,1),n._setGlobalContextVariable("currentlyRunningAnimationGroups",T))}_cancelPendingTasks(n){const k=this.currentAnimationGroup.getValue(n);k&&this._stopAnimationGroup(n,k)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,Q.f)("FlowGraphPlayAnimationBlock",w)}}]);