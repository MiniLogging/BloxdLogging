"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13778:(A,X,s)=>{s.r(X),s.d(X,{FlowGraphPlayAnimationBlock:()=>K});var N=s(12715),f=s(12677),E=s(616),g=s(13709);class K extends N.c{constructor(A){super(A,["animationLoop","animationEnd","animationGroupLoop"]),this.config=A,this.speed=this.registerDataInput("speed",f.n),this.loop=this.registerDataInput("loop",f.c),this.from=this.registerDataInput("from",f.n,0),this.to=this.registerDataInput("to",f.n),this.currentFrame=this.registerDataOutput("currentFrame",f.n),this.currentTime=this.registerDataOutput("currentTime",f.n),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",f.b),this.animationGroup=this.registerDataInput("animationGroup",f.b,null===A||void 0===A?void 0:A.animationGroup),this.animation=this.registerDataInput("animation",f.b),this.object=this.registerDataInput("object",f.b)}_preparePendingTasks(A){const X=this.animationGroup.getValue(A),s=this.animation.getValue(A);if(!X&&!s)return this._reportError(A,"No animation or animation group provided");{const f=this.currentAnimationGroup.getValue(A);f&&f!==X&&f.dispose();let E=X;if(s&&!E){const X=this.object.getValue(A);if(!X)return this._reportError(A,"No target object provided");const N=Array.isArray(s)?s:[s],f=N[0].name;E=new g.AnimationGroup("flowGraphAnimationGroup-"+f+"-"+X.name,A.configuration.eg);let K=!1;const r=A._getGlobalContextVariable("interpolationAnimations",[]);for(const A of N)E.addTargetedAnimation(A,X),-1!==r.indexOf(A.uniqueId)&&(K=!0);K&&this._checkInterpolationDuplications(A,N,X)}const K=this.speed.getValue(A)||1,r=this.from.getValue(A)??0,i=this.to.getValue(A)||E.to,Y=!isFinite(i)||this.loop.getValue(A);this.currentAnimationGroup.setValue(E,A);const v=A._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==v.indexOf(E.uniqueId)&&E.stop();try{E.start(Y,K,r,i),E.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(A))),E.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(A))),E.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(A))),E.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(A))),v.push(E.uniqueId),A._setGlobalContextVariable("currentlyRunningAnimationGroups",v)}catch(N){this._reportError(A,N)}}}_reportError(A,X){super._reportError(A,X),this.currentFrame.setValue(-1,A),this.currentTime.setValue(-1,A)}_executeOnTick(A){const X=this.currentAnimationGroup.getValue(A);var s;X&&(this.currentFrame.setValue(X.getCurrentFrame(),A),this.currentTime.setValue((null===(s=X.animatables[0])||void 0===s?void 0:s.elapsedTime)??0,A))}_execute(A){this._startPendingTasks(A)}_onAnimationGroupEnd(A){this._removeFromCurrentlyRunning(A,this.currentAnimationGroup.getValue(A)),this._resetAfterCanceled(A),this.done._activateSignal(A)}_checkInterpolationDuplications(A,X,s){const N=A._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const f of N){const N=A.assetsContext.animationGroups.find((A=>A.uniqueId===f));if(N)for(const f of N.targetedAnimations)for(const E of X)f.animation.targetProperty===E.targetProperty&&f.target===s&&this._stopAnimationGroup(A,N)}}_stopAnimationGroup(A,X){X.stop(!0),X.dispose(),this._removeFromCurrentlyRunning(A,X)}_removeFromCurrentlyRunning(A,X){const s=A._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),N=s.indexOf(X.uniqueId);-1!==N&&(s.splice(N,1),A._setGlobalContextVariable("currentlyRunningAnimationGroups",s))}_cancelPendingTasks(A){const X=this.currentAnimationGroup.getValue(A);X&&this._stopAnimationGroup(A,X)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,E.f)("FlowGraphPlayAnimationBlock",K)}}]);