"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{14084:(u,F,z)=>{z.r(F),z.d(F,{FlowGraphPlayAnimationBlock:()=>I});var p=z(13e3),b=z(12952),R=z(668),c=z(14024);class I extends p.e{constructor(u){super(u,["animationLoop","animationEnd","animationGroupLoop"]),this.config=u,this.speed=this.registerDataInput("speed",b.t),this.loop=this.registerDataInput("loop",b.i),this.from=this.registerDataInput("from",b.t,0),this.to=this.registerDataInput("to",b.t),this.currentFrame=this.registerDataOutput("currentFrame",b.t),this.currentTime=this.registerDataOutput("currentTime",b.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",b.e),this.animationGroup=this.registerDataInput("animationGroup",b.e,null===u||void 0===u?void 0:u.animationGroup),this.animation=this.registerDataInput("animation",b.e),this.object=this.registerDataInput("object",b.e)}_preparePendingTasks(u){const F=this.animationGroup.getValue(u),z=this.animation.getValue(u);if(!F&&!z)return this._reportError(u,"No animation or animation group provided");{const b=this.currentAnimationGroup.getValue(u);b&&b!==F&&b.dispose();let R=F;if(z&&!R){const F=this.object.getValue(u);if(!F)return this._reportError(u,"No target object provided");const p=Array.isArray(z)?z:[z],b=p[0].name;R=new c.AnimationGroup("flowGraphAnimationGroup-"+b+"-"+F.name,u.configuration.Je);let I=!1;const G=u._getGlobalContextVariable("interpolationAnimations",[]);for(const u of p)R.addTargetedAnimation(u,F),-1!==G.indexOf(u.uniqueId)&&(I=!0);I&&this._checkInterpolationDuplications(u,p,F)}const I=this.speed.getValue(u)||1,G=this.from.getValue(u)??0,X=this.to.getValue(u)||R.to,j=!isFinite(X)||this.loop.getValue(u);this.currentAnimationGroup.setValue(R,u);const W=u._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==W.indexOf(R.uniqueId)&&R.stop();try{R.start(j,I,G,X),R.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(u))),R.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(u))),R.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(u))),R.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(u))),W.push(R.uniqueId),u._setGlobalContextVariable("currentlyRunningAnimationGroups",W)}catch(p){this._reportError(u,p)}}}_reportError(u,F){super._reportError(u,F),this.currentFrame.setValue(-1,u),this.currentTime.setValue(-1,u)}_executeOnTick(u){const F=this.currentAnimationGroup.getValue(u);var z;F&&(this.currentFrame.setValue(F.getCurrentFrame(),u),this.currentTime.setValue((null===(z=F.animatables[0])||void 0===z?void 0:z.elapsedTime)??0,u))}_execute(u){this._startPendingTasks(u)}_onAnimationGroupEnd(u){this._removeFromCurrentlyRunning(u,this.currentAnimationGroup.getValue(u)),this._resetAfterCanceled(u),this.done._activateSignal(u)}_checkInterpolationDuplications(u,F,z){const p=u._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const b of p){const p=u.assetsContext.animationGroups.find((u=>u.uniqueId===b));if(p)for(const b of p.targetedAnimations)for(const R of F)b.animation.targetProperty===R.targetProperty&&b.target===z&&this._stopAnimationGroup(u,p)}}_stopAnimationGroup(u,F){F.stop(!0),F.dispose(),this._removeFromCurrentlyRunning(u,F)}_removeFromCurrentlyRunning(u,F){const z=u._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),p=z.indexOf(F.uniqueId);-1!==p&&(z.splice(p,1),u._setGlobalContextVariable("currentlyRunningAnimationGroups",z))}_cancelPendingTasks(u){const F=this.currentAnimationGroup.getValue(u);F&&this._stopAnimationGroup(u,F)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,R.h)("FlowGraphPlayAnimationBlock",I)}}]);