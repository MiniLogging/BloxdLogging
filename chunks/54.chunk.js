"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13798:(J,T,b)=>{b.r(T),b.d(T,{FlowGraphPlayAnimationBlock:()=>Y});var q=b(12644),t=b(12603),j=b(639),B=b(13729);class Y extends q.b{constructor(J){super(J,["animationLoop","animationEnd","animationGroupLoop"]),this.config=J,this.speed=this.registerDataInput("speed",t.r),this.loop=this.registerDataInput("loop",t.e),this.from=this.registerDataInput("from",t.r,0),this.to=this.registerDataInput("to",t.r),this.currentFrame=this.registerDataOutput("currentFrame",t.r),this.currentTime=this.registerDataOutput("currentTime",t.r),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",t.c),this.animationGroup=this.registerDataInput("animationGroup",t.c,null===J||void 0===J?void 0:J.animationGroup),this.animation=this.registerDataInput("animation",t.c),this.object=this.registerDataInput("object",t.c)}_preparePendingTasks(J){const T=this.animationGroup.getValue(J),b=this.animation.getValue(J);if(!T&&!b)return this._reportError(J,"No animation or animation group provided");{const t=this.currentAnimationGroup.getValue(J);t&&t!==T&&t.dispose();let j=T;if(b&&!j){const T=this.object.getValue(J);if(!T)return this._reportError(J,"No target object provided");const q=Array.isArray(b)?b:[b],t=q[0].name;j=new B.AnimationGroup("flowGraphAnimationGroup-"+t+"-"+T.name,J.configuration.cg);let Y=!1;const C=J._getGlobalContextVariable("interpolationAnimations",[]);for(const J of q)j.addTargetedAnimation(J,T),-1!==C.indexOf(J.uniqueId)&&(Y=!0);Y&&this._checkInterpolationDuplications(J,q,T)}const Y=this.speed.getValue(J)||1,C=this.from.getValue(J)??0,F=this.to.getValue(J)||j.to,A=!isFinite(F)||this.loop.getValue(J);this.currentAnimationGroup.setValue(j,J);const a=J._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==a.indexOf(j.uniqueId)&&j.stop();try{j.start(A,Y,C,F),j.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(J))),j.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(J))),j.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(J))),j.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(J))),a.push(j.uniqueId),J._setGlobalContextVariable("currentlyRunningAnimationGroups",a)}catch(q){this._reportError(J,q)}}}_reportError(J,T){super._reportError(J,T),this.currentFrame.setValue(-1,J),this.currentTime.setValue(-1,J)}_executeOnTick(J){const T=this.currentAnimationGroup.getValue(J);var b;T&&(this.currentFrame.setValue(T.getCurrentFrame(),J),this.currentTime.setValue((null===(b=T.animatables[0])||void 0===b?void 0:b.elapsedTime)??0,J))}_execute(J){this._startPendingTasks(J)}_onAnimationGroupEnd(J){this._removeFromCurrentlyRunning(J,this.currentAnimationGroup.getValue(J)),this._resetAfterCanceled(J),this.done._activateSignal(J)}_checkInterpolationDuplications(J,T,b){const q=J._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const t of q){const q=J.assetsContext.animationGroups.find((J=>J.uniqueId===t));if(q)for(const t of q.targetedAnimations)for(const j of T)t.animation.targetProperty===j.targetProperty&&t.target===b&&this._stopAnimationGroup(J,q)}}_stopAnimationGroup(J,T){T.stop(!0),T.dispose(),this._removeFromCurrentlyRunning(J,T)}_removeFromCurrentlyRunning(J,T){const b=J._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),q=b.indexOf(T.uniqueId);-1!==q&&(b.splice(q,1),J._setGlobalContextVariable("currentlyRunningAnimationGroups",b))}_cancelPendingTasks(J){const T=this.currentAnimationGroup.getValue(J);T&&this._stopAnimationGroup(J,T)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,j.g)("FlowGraphPlayAnimationBlock",Y)}}]);