"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[54],{13954:(U,M,b)=>{b.r(M),b.d(M,{FlowGraphPlayAnimationBlock:()=>y});var a=b(12823),A=b(12775),H=b(609),W=b(13892);class y extends a.d{constructor(U){super(U,["animationLoop","animationEnd","animationGroupLoop"]),this.config=U,this.speed=this.registerDataInput("speed",A.t),this.loop=this.registerDataInput("loop",A.f),this.from=this.registerDataInput("from",A.t,0),this.to=this.registerDataInput("to",A.t),this.currentFrame=this.registerDataOutput("currentFrame",A.t),this.currentTime=this.registerDataOutput("currentTime",A.t),this.currentAnimationGroup=this.registerDataOutput("currentAnimationGroup",A.c),this.animationGroup=this.registerDataInput("animationGroup",A.c,null===U||void 0===U?void 0:U.animationGroup),this.animation=this.registerDataInput("animation",A.c),this.object=this.registerDataInput("object",A.c)}_preparePendingTasks(U){const M=this.animationGroup.getValue(U),b=this.animation.getValue(U);if(!M&&!b)return this._reportError(U,"No animation or animation group provided");{const A=this.currentAnimationGroup.getValue(U);A&&A!==M&&A.dispose();let H=M;if(b&&!H){const M=this.object.getValue(U);if(!M)return this._reportError(U,"No target object provided");const a=Array.isArray(b)?b:[b],A=a[0].name;H=new W.AnimationGroup("flowGraphAnimationGroup-"+A+"-"+M.name,U.configuration.$e);let y=!1;const O=U._getGlobalContextVariable("interpolationAnimations",[]);for(const U of a)H.addTargetedAnimation(U,M),-1!==O.indexOf(U.uniqueId)&&(y=!0);y&&this._checkInterpolationDuplications(U,a,M)}const y=this.speed.getValue(U)||1,O=this.from.getValue(U)??0,e=this.to.getValue(U)||H.to,x=!isFinite(e)||this.loop.getValue(U);this.currentAnimationGroup.setValue(H,U);const P=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);-1!==P.indexOf(H.uniqueId)&&H.stop();try{H.start(x,y,O,e),H.onAnimationGroupEndObservable.add((()=>this._onAnimationGroupEnd(U))),H.onAnimationEndObservable.add((()=>this._eventsSignalOutputs.animationEnd._activateSignal(U))),H.onAnimationLoopObservable.add((()=>this._eventsSignalOutputs.animationLoop._activateSignal(U))),H.onAnimationGroupLoopObservable.add((()=>this._eventsSignalOutputs.animationGroupLoop._activateSignal(U))),P.push(H.uniqueId),U._setGlobalContextVariable("currentlyRunningAnimationGroups",P)}catch(a){this._reportError(U,a)}}}_reportError(U,M){super._reportError(U,M),this.currentFrame.setValue(-1,U),this.currentTime.setValue(-1,U)}_executeOnTick(U){const M=this.currentAnimationGroup.getValue(U);var b;M&&(this.currentFrame.setValue(M.getCurrentFrame(),U),this.currentTime.setValue((null===(b=M.animatables[0])||void 0===b?void 0:b.elapsedTime)??0,U))}_execute(U){this._startPendingTasks(U)}_onAnimationGroupEnd(U){this._removeFromCurrentlyRunning(U,this.currentAnimationGroup.getValue(U)),this._resetAfterCanceled(U),this.done._activateSignal(U)}_checkInterpolationDuplications(U,M,b){const a=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]);for(const A of a){const a=U.assetsContext.animationGroups.find((U=>U.uniqueId===A));if(a)for(const A of a.targetedAnimations)for(const H of M)A.animation.targetProperty===H.targetProperty&&A.target===b&&this._stopAnimationGroup(U,a)}}_stopAnimationGroup(U,M){M.stop(!0),M.dispose(),this._removeFromCurrentlyRunning(U,M)}_removeFromCurrentlyRunning(U,M){const b=U._getGlobalContextVariable("currentlyRunningAnimationGroups",[]),a=b.indexOf(M.uniqueId);-1!==a&&(b.splice(a,1),U._setGlobalContextVariable("currentlyRunningAnimationGroups",b))}_cancelPendingTasks(U){const M=this.currentAnimationGroup.getValue(U);M&&this._stopAnimationGroup(U,M)}getClassName(){return"FlowGraphPlayAnimationBlock"}}(0,H.i)("FlowGraphPlayAnimationBlock",y)}}]);