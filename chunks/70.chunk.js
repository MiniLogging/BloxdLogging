"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[70],{14161:(h,V,i)=>{function S(h){return Math.floor(h/8)}function l(h){return 1<<h%8}i.d(V,{OptimizeIndices:()=>g});class Y{constructor(h){this.size=h,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(h){if(h>=this.size)throw new RangeError("Bit index out of range");const V=S(h),i=l(h);return 0!==(this._byteArray[V]&i)}set(h,V){if(h>=this.size)throw new RangeError("Bit index out of range");const i=S(h),Y=l(h);V?this._byteArray[i]|=Y:this._byteArray[i]&=~Y}}function g(h){const V=[],i=h.length/3;for(let Y=0;Y<i;Y++)V.push([h[3*Y],h[3*Y+1],h[3*Y+2]]);const S=new Map;for(let Y=0;Y<V.length;Y++){const h=V[Y];for(const V of h){let h=S.get(V);h||S.set(V,h=[]),h.push(Y)}}const l=new Y(i),g=[],q=h=>{const i=[h];for(;i.length>0;){const h=i.pop();if(!l.get(h)){l.set(h,!0),g.push(V[h]);for(const Y of V[h]){const h=S.get(Y);if(!h)return;for(const V of h)l.get(V)||i.push(V)}}}};for(let Y=0;Y<i;Y++)l.get(Y)||q(Y);let B=0;for(const Y of g)h[B++]=Y[0],h[B++]=Y[1],h[B++]=Y[2]}}}]);