"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[70],{15661:(L,U,x)=>{function mL(L){return Math.floor(L/8)}function p(L){return 1<<L%8}x.d(U,{OptimizeIndices:()=>F});class G{constructor(L){this.size=L,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(L){if(L>=this.size)throw new RangeError("Bit index out of range");const U=mL(L),x=p(L);return 0!==(this._byteArray[U]&x)}set(L,U){if(L>=this.size)throw new RangeError("Bit index out of range");const x=mL(L),G=p(L);U?this._byteArray[x]|=G:this._byteArray[x]&=~G}}function F(L){const U=[],x=L.length/3;for(let G=0;G<x;G++)U.push([L[3*G],L[3*G+1],L[3*G+2]]);const mL=new Map;for(let G=0;G<U.length;G++){const L=U[G];for(const U of L){let L=mL.get(U);L||mL.set(U,L=[]),L.push(G)}}const p=new G(x),F=[],a=L=>{const x=[L];for(;x.length>0;){const L=x.pop();if(!p.get(L)){p.set(L,!0),F.push(U[L]);for(const G of U[L]){const L=mL.get(G);if(!L)return;for(const U of L)p.get(U)||x.push(U)}}}};for(let G=0;G<x;G++)p.get(G)||a(G);let o=0;for(const G of F)L[o++]=G[0],L[o++]=G[1],L[o++]=G[2]}}}]);