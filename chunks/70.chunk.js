"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[70],{14645:(F,P,f)=>{function c(F){return Math.floor(F/8)}function N(F){return 1<<F%8}f.d(P,{OptimizeIndices:()=>H});class q{constructor(F){this.size=F,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(F){if(F>=this.size)throw new RangeError("Bit index out of range");const P=c(F),f=N(F);return 0!==(this._byteArray[P]&f)}set(F,P){if(F>=this.size)throw new RangeError("Bit index out of range");const f=c(F),q=N(F);P?this._byteArray[f]|=q:this._byteArray[f]&=~q}}function H(F){const P=[],f=F.length/3;for(let q=0;q<f;q++)P.push([F[3*q],F[3*q+1],F[3*q+2]]);const c=new Map;for(let q=0;q<P.length;q++){const F=P[q];for(const P of F){let F=c.get(P);F||c.set(P,F=[]),F.push(q)}}const N=new q(f),H=[],A=F=>{const f=[F];for(;f.length>0;){const F=f.pop();if(!N.get(F)){N.set(F,!0),H.push(P[F]);for(const q of P[F]){const F=c.get(q);if(!F)return;for(const P of F)N.get(P)||f.push(P)}}}};for(let q=0;q<f;q++)N.get(q)||A(q);let o=0;for(const q of H)F[o++]=q[0],F[o++]=q[1],F[o++]=q[2]}}}]);