"use strict";(self.agop5zpabxv=self.agop5zpabxv||[]).push([[70],{15319:(H,u,J)=>{function O(H){return Math.floor(H/8)}function U(H){return 1<<H%8}J.d(u,{OptimizeIndices:()=>w});class h{constructor(H){this.size=H,this._byteArray=new Uint8Array(Math.ceil(this.size/8))}get(H){if(H>=this.size)throw new RangeError("Bit index out of range");const u=O(H),J=U(H);return 0!==(this._byteArray[u]&J)}set(H,u){if(H>=this.size)throw new RangeError("Bit index out of range");const J=O(H),h=U(H);u?this._byteArray[J]|=h:this._byteArray[J]&=~h}}function w(H){const u=[],J=H.length/3;for(let h=0;h<J;h++)u.push([H[3*h],H[3*h+1],H[3*h+2]]);const O=new Map;for(let h=0;h<u.length;h++){const H=u[h];for(const u of H){let H=O.get(u);H||O.set(u,H=[]),H.push(h)}}const U=new h(J),w=[],g=H=>{const J=[H];for(;J.length>0;){const H=J.pop();if(!U.get(H)){U.set(H,!0),w.push(u[H]);for(const h of u[H]){const H=O.get(h);if(!H)return;for(const u of H)U.get(u)||J.push(u)}}}};for(let h=0;h<J;h++)U.get(h)||g(h);let B=0;for(const h of w)H[B++]=h[0],H[B++]=h[1],H[B++]=h[2]}}}]);