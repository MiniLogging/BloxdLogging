"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13145:(u,G,s)=>{s.r(G),s.d(G,{AnimationGroup:()=>c,TargetedAnimation:()=>r});var T=s(11838),z=s(10568),O=s(10619),m=s(10896),f=s(11831),C=s(10904);class x{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(u,G,s,z){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=G,this._target=u,this._scene=s,this._host=z,this._activeTargets=[],G._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===T.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=C.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const u={frame:0,value:this._minValue};this._keys.splice(0,0,u)}if(this._target instanceof Array){let u=0;for(const G of this._target)this._preparePath(G,u),this._getOriginalValues(u),u++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const O=G.getEvents();O&&O.length>0&&O.forEach((u=>{this._events.push(u._clone())})),this._enableBlending=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(u){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const s=this._animation.targetPropertyPath;if(s.length>1){let T=u;for(let u=0;u<s.length-1;u++){const G=s[u];if(T=T[G],void 0===T)throw new Error(`Invalid property (${G}) in property path (${s.join(".")})`)}this._targetPath=s[s.length-1],this._activeTargets[G]=T}else this._targetPath=s[0],this._activeTargets[G]=u;if(void 0===this._activeTargets[G][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${s.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let u=0;for(const G of this._target)void 0!==this._originalValue[u]&&this._setValue(G,this._activeTargets[u],this._originalValue[u],-1,u),u++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let u=0;u<this._events.length;u++)this._events[u].isDone=!1}isStopped(){return this._stopped}dispose(){const u=this._animation.runtimeAnimations.indexOf(this);u>-1&&this._animation.runtimeAnimations.splice(u,1)}setValue(u,G){if(this._targetIsArray)for(let s=0;s<this._target.length;s++){const T=this._target[s];this._setValue(T,this._activeTargets[s],u,G,s)}else this._setValue(this._target,this._directTarget,u,G,0)}_getOriginalValues(){let u,G=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const s=this._activeTargets[G];u=s.getLocalMatrix&&"_matrix"===this._targetPath?s.getLocalMatrix():s[this._targetPath],u&&u.clone?this._originalValue[G]=u.clone():this._originalValue[G]=u}_registerTargetForLateAnimationBinding(u,G){const s=u.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(s),s._lateAnimationHolders||(s._lateAnimationHolders={}),s._lateAnimationHolders[u.targetPath]||(s._lateAnimationHolders[u.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:G}),u.isAdditive?(s._lateAnimationHolders[u.targetPath].additiveAnimations.push(u),s._lateAnimationHolders[u.targetPath].totalAdditiveWeight+=u.weight):(s._lateAnimationHolders[u.targetPath].animations.push(u),s._lateAnimationHolders[u.targetPath].totalWeight+=u.weight)}_setValue(u,G,s,z,O){if(this._currentActiveTarget=G,this._weight=z,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const u=G[this._targetPath];u.clone?this._originalBlendValue=u.clone():this._originalBlendValue=u}this._originalBlendValue.m?T.b.AllowMatrixDecomposeForInterpolation?this._currentValue?C.d.DecomposeLerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=C.d.DecomposeLerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue?C.d.LerpToRef(this._originalBlendValue,s,this._blendingFactor,this._currentValue):this._currentValue=C.d.Lerp(this._originalBlendValue,s,this._blendingFactor):this._currentValue=T.b._UniversalLerp(this._originalBlendValue,s,this._blendingFactor);const z=u&&u.animationPropertiesOverride?u.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=z}else this._currentValue?this._currentValue.p?this._currentValue.p(s):this._currentValue=s:null!==s&&void 0!==s&&s.clone?this._currentValue=s.clone():this._currentValue=s;-1!==z?this._registerTargetForLateAnimationBinding(this,this._originalValue[O]):this._animationState.loopMode===T.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[O],G[this._targetPath]):G[this._targetPath]=this._originalValue[O]+this._currentValue:G[this._targetPath]=this._currentValue,u.pg&&u.pg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(u){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const s=this._animation.getKeys();u<s[0].frame?u=s[0].frame:u>s[s.length-1].frame&&(u=s[s.length-1].frame);const T=this._events;if(T.length)for(let O=0;O<T.length;O++)T[O].onlyOnce||(T[O].isDone=T[O].frame<u);this._currentFrame=u;const z=this._animation._interpolate(u,this._animationState);this.setValue(z,G)}_prepareForSpeedRatioChange(u){const G=this._previousElapsedTime*(this._animation.framePerSecond*u)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-G}animate(u,G,s,z,O){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const f=this._animation,C=f.targetPropertyPath;if(!C||C.length<1)return this._stopped=!0,!1;let x=!0;(G<this._minFrame||G>this._maxFrame)&&(G=this._minFrame),(s<this._minFrame||s>this._maxFrame)&&(s=this._maxFrame);const g=s-G;let b,Q=u*(f.framePerSecond*O)/1e3+this._absoluteFrameOffset,Y=0,n=!1;const V=z&&this._animationState.loopMode===T.b.ANIMATIONLOOPMODE_YOYO;if(V){const u=(Q-G)/g,s=Math.sin(u*Math.PI);Q=Math.abs(s)*g+G;const T=s>=0?1:-1;this._yoyoDirection!==T&&(n=!0),this._yoyoDirection=T}if(this._previousElapsedTime=u,this._previousAbsoluteFrame=Q,!z&&s>=G&&(Q>=g&&O>0||Q<=0&&O<0))x=!1,Y=f._getKeyValue(this._maxValue);else if(!z&&G>=s&&(Q<=g&&O<0||Q>=0&&O>0))x=!1,Y=f._getKeyValue(this._minValue);else if(this._animationState.loopMode!==T.b.ANIMATIONLOOPMODE_CYCLE){const u=s.toString()+G.toString();if(!this._offsetsCache[u]){this._animationState.repeatCount=0,this._animationState.loopMode=T.b.ANIMATIONLOOPMODE_CYCLE;const z=f._interpolate(G,this._animationState),O=f._interpolate(s,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),f.dataType){case T.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[u]=O-z;break;case T.b.ANIMATIONTYPE_QUATERNION:case T.b.ANIMATIONTYPE_VECTOR3:case T.b.ANIMATIONTYPE_VECTOR2:case T.b.ANIMATIONTYPE_SIZE:case T.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[u]=O.Nc(z)}this._highLimitsCache[u]=O}Y=this._highLimitsCache[u],b=this._offsetsCache[u]}if(void 0===b)switch(f.dataType){case T.b.ANIMATIONTYPE_FLOAT:b=0;break;case T.b.ANIMATIONTYPE_QUATERNION:b=T.i;break;case T.b.ANIMATIONTYPE_VECTOR3:b=T.o;break;case T.b.ANIMATIONTYPE_VECTOR2:b=T.n;break;case T.b.ANIMATIONTYPE_SIZE:b=T.l;break;case T.b.ANIMATIONTYPE_COLOR3:b=T.f;break;case T.b.ANIMATIONTYPE_COLOR4:b=T.h}let F;if(this._host&&this._host.syncRoot){const u=this._host.syncRoot;F=G+g*((u.masterFrame-u.fromFrame)/(u.toFrame-u.fromFrame))}else F=Q>0&&G>s||Q<0&&G<s?x&&0!==g?s+Q%g:G:x&&0!==g?G+Q%g:s;const r=this._events;if(!V&&(O>0&&this.currentFrame>F||O<0&&this.currentFrame<F)||V&&n){this._onLoop();for(let u=0;u<r.length;u++)r[u].onlyOnce||(r[u].isDone=!1);this._animationState.key=O>0?0:f.getKeys().length-1}this._currentFrame=F,this._animationState.repeatCount=0===g?0:Q/g|0,this._animationState.highLimitValue=Y,this._animationState.offsetValue=b;const c=f._interpolate(F,this._animationState);if(this.setValue(c,m),r.length)for(let T=0;T<r.length;T++)if(g>=0&&F>=r[T].frame&&r[T].frame>=G||g<0&&F<=r[T].frame&&r[T].frame<=G){const u=r[T];u.isDone||(u.onlyOnce&&(r.splice(T,1),T--),u.isDone=!0,u.action(F))}return x||(this._stopped=!0),x}}var g=s(10601);class b{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(u){this._weight=-1!==u?Math.min(Math.max(u,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(u){for(let G=0;G<this._runtimeAnimations.length;G++){this._runtimeAnimations[G]._prepareForSpeedRatioChange(u)}this._speedRatio=u,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(u,G){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,O=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,f=arguments.length>6?arguments[6]:void 0,C=arguments.length>7?arguments[7]:void 0,x=arguments.length>8?arguments[8]:void 0,g=arguments.length>9&&void 0!==arguments[9]&&arguments[9],b=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=G,this.fromFrame=s,this.toFrame=T,this.loopAnimation=O,this.onAnimationEnd=f,this.onAnimationLoop=x,this.isAdditive=g,this.playOrder=b,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.vd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new z.e,this.onAnimationLoopObservable=new z.e,this._scene=u,C&&this.appendAnimations(G,C),this._speedRatio=m,u._activeAnimatables.push(this)}syncWith(u){if(this._syncRoot=u,u){const u=this._scene._activeAnimatables.indexOf(this);u>-1&&(this._scene._activeAnimatables.splice(u,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(u,G){for(let s=0;s<G.length;s++){const T=G[s],z=new x(u,T,this._scene,this);z._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(z)}}getAnimationByTargetProperty(u){const G=this._runtimeAnimations;for(let s=0;s<G.length;s++)if(G[s].animation.targetProperty===u)return G[s].animation;return null}getRuntimeAnimationByTargetProperty(u){const G=this._runtimeAnimations;for(let s=0;s<G.length;s++)if(G[s].animation.targetProperty===u)return G[s];return null}reset(){const u=this._runtimeAnimations;for(let G=0;G<u.length;G++)u[G].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(u){const G=this._runtimeAnimations;for(let s=0;s<G.length;s++)G[s].animation.enableBlending=!0,G[s].animation.blendingSpeed=u}disableBlending(){const u=this._runtimeAnimations;for(let G=0;G<u.length;G++)u[G].animation.enableBlending=!1}goToFrame(u){const G=this._runtimeAnimations;if(G[0]){const s=G[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??G[0].currentFrame;const T=0===this.speedRatio?0:(u-this._frameToSyncFromJump)/s*1e3/this.speedRatio;this._manualJumpDelay=-T}for(let s=0;s<G.length;s++)G[s].goToFrame(u,this._weight);this._goToFrame=u}get paused(){return this.vd}pause(){this.vd||(this.vd=!0)}restart(){this.vd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(u,G){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],T=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(u||G){const z=this._scene._activeAnimatables.indexOf(this);if(z>-1){const O=this._runtimeAnimations;for(let s=O.length-1;s>=0;s--){const T=O[s];u&&T.animation.name!=u||(G&&!G(T.target)||(T.dispose(),O.splice(s,1)))}0==O.length&&(s||this._scene._activeAnimatables.splice(z,1),T||this._raiseOnAnimationEnd())}}else{const u=this._scene._activeAnimatables.indexOf(this);if(u>-1){s||this._scene._activeAnimatables.splice(u,1);const G=this._runtimeAnimations;for(let u=0;u<G.length;u++)G[u].dispose();this._runtimeAnimations.length=0,T||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((u=>{this.onAnimationEndObservable.add((()=>{u(this)}),void 0,void 0,this,!0)}))}_animate(u){if(this.vd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=u),!0;if(null===this._localDelayOffset?(this._localDelayOffset=u,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=u-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let G=!1;const s=this._runtimeAnimations;let T;for(T=0;T<s.length;T++){const z=s[T].animate(u-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);G=G||z}if(this.animationStarted=G,!G){if(this.disposeOnEnd)for(T=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(T,1),T=0;T<s.length;T++)s[T].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return G}}function Q(u){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return u.originalValue;let G=1;const s=C.l.gb[0],T=C.l.gb[1],z=C.l.Quaternion[0];let O=0;const m=u.animations[0],f=u.originalValue;let x=1,g=!1;if(u.totalWeight<1)x=1-u.totalWeight,f.decompose(T,z,s);else{if(O=1,G=u.totalWeight,x=m.weight/G,1==x){if(!u.totalAdditiveWeight)return m.currentValue;g=!0}m.currentValue.decompose(T,z,s)}if(!g){T.scaleInPlace(x),s.scaleInPlace(x),z.scaleInPlace(x);for(let m=O;m<u.animations.length;m++){const O=u.animations[m];if(0===O.weight)continue;x=O.weight/G;const f=C.l.gb[2],g=C.l.gb[3],b=C.l.Quaternion[1];O.currentValue.decompose(g,b,f),g.scaleAndAddToRef(x,T),b.scaleAndAddToRef(C.h.Dot(z,b)>0?x:-x,z),f.scaleAndAddToRef(x,s)}z.normalize()}for(let Q=0;Q<u.additiveAnimations.length;Q++){const G=u.additiveAnimations[Q];if(0===G.weight)continue;const O=C.l.gb[2],m=C.l.gb[3],f=C.l.Quaternion[1];G.currentValue.decompose(m,f,O),m.multiplyToRef(T,m),C.q.LerpToRef(T,m,G.weight,T),z.multiplyToRef(f,f),C.h.SlerpToRef(z,f,G.weight,z),O.scaleAndAddToRef(G.weight,s)}const b=m?m._animationState.workValue:C.l.Matrix[0].clone();return C.d.ComposeToRef(T,z,s,b),b}function Y(u,G){if(0===u.totalWeight&&0===u.totalAdditiveWeight)return G;const s=u.animations[0],T=u.originalValue;let z=G;if(0===u.totalWeight&&u.totalAdditiveWeight>0)z.p(T);else if(1===u.animations.length){if(C.h.SlerpToRef(T,s.currentValue,Math.min(1,u.totalWeight),z),0===u.totalAdditiveWeight)return z}else if(u.animations.length>1){let s,O,m=1;if(u.totalWeight<1){const G=1-u.totalWeight;s=[],O=[],s.push(T),O.push(G)}else{if(2===u.animations.length&&(C.h.SlerpToRef(u.animations[0].currentValue,u.animations[1].currentValue,u.animations[1].weight/u.totalWeight,G),0===u.totalAdditiveWeight))return G;s=[],O=[],m=u.totalWeight}for(let G=0;G<u.animations.length;G++){const T=u.animations[G];s.push(T.currentValue),O.push(T.weight/m)}let f=0;for(let u=0;u<s.length;)u?(f+=O[u],C.h.SlerpToRef(z,s[u],O[u]/f,z),u++):(C.h.SlerpToRef(s[u],s[u+1],O[u+1]/(O[u]+O[u+1]),G),z=G,f=O[u]+O[u+1],u+=2)}for(let O=0;O<u.additiveAnimations.length;O++){const G=u.additiveAnimations[O];0!==G.weight&&(z.multiplyToRef(G.currentValue,C.l.Quaternion[0]),C.h.SlerpToRef(z,C.l.Quaternion[0],G.weight,z))}return z}var n,V,F=s(10889);n=F.e,(V=f.b)&&(V.prototype.copyAnimationRange=function(u,G,s){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new T.b(this.name,"_matrix",u.animations[0].framePerSecond,T.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const m=u.animations[0].getRange(G);if(!m)return!1;const f=m.from,C=m.to,x=u.animations[0].getKeys(),g=u.length,b=u.getParent(),Q=this.getParent(),Y=z&&b&&g&&this.length&&g!==this.length,n=Y&&Q&&b?Q.length/b.length:1,V=z&&!Q&&O&&(1!==O.x||1!==O.y||1!==O.z),F=this.animations[0].getKeys();let r,c,j;for(let T=0,l=x.length;T<l;T++)r=x[T],r.frame>=f&&r.frame<=C&&(z?(j=r.value.clone(),Y?(c=j.getTranslation(),j.setTranslation(c.scaleInPlace(n))):V&&O?(c=j.getTranslation(),j.setTranslation(c.multiplyInPlace(O))):j=r.value):j=r.value,F.push({frame:r.frame+s,value:j}));return this.animations[0].createRange(G,f+s,C+s),!0}),n&&(n.prototype._animate=function(u){if(!this.animationsEnabled)return;const G=g.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=G}this.deltaTime=void 0!==u?u:this.useConstantAnimationDeltaTime?16:(G-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=G;const s=this._activeAnimatables;if(0===s.length)return;this._animationTime+=this.deltaTime;const z=this._animationTime;for(let T=0;T<s.length;T++){const u=s[T];!u._animate(z)&&u.disposeOnEnd&&T--}!function(u){if(u._registeredForLateAnimationBindings.length){for(let G=0;G<u._registeredForLateAnimationBindings.length;G++){const s=u._registeredForLateAnimationBindings.data[G];for(const u in s._lateAnimationHolders){const G=s._lateAnimationHolders[u],z=G.animations[0],O=G.originalValue;if(void 0===O||null===O)continue;const m=T.b.AllowMatrixDecomposeForInterpolation&&O.m;let f=s[u];if(m)f=Q(G);else if(void 0!==O.w)f=Y(G,f||C.h.Identity());else{let u=0,s=1;const m=z&&z._animationState.loopMode===T.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(G.totalWeight<1)f=m?O.clone?O.clone():O:z&&O.scale?O.scale(1-G.totalWeight):z?O*(1-G.totalWeight):O.clone?O.clone():O;else if(z){s=G.totalWeight;const T=z.weight/s;f=1!==T?z.currentValue.scale?z.currentValue.scale(T):z.currentValue*T:z.currentValue,m&&(f.addToRef?f.addToRef(O,f):f+=O),u=1}for(let T=u;T<G.animations.length;T++){const u=G.animations[T],z=u.weight/s;z&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(z,f):f+=u.currentValue*z)}for(let T=0;T<G.additiveAnimations.length;T++){const u=G.additiveAnimations[T],s=u.weight;s&&(u.currentValue.scaleAndAddToRef?u.currentValue.scaleAndAddToRef(s,f):f+=u.currentValue*s)}}s[u]=f}s._lateAnimationHolders={}}u._registeredForLateAnimationBindings.reset()}}(this)},n.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((u,G)=>u.playOrder-G.playOrder))},n.prototype.beginWeightedAnimation=function(u,G,s){let T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,z=arguments.length>4?arguments[4]:void 0,O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,C=arguments.length>8?arguments[8]:void 0,x=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const b=this.beginAnimation(u,G,s,z,O,m,f,!1,C,x,g);return b.weight=T,b},n.prototype.beginAnimation=function(u,G,s,T){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,O=arguments.length>5?arguments[5]:void 0,m=arguments.length>6?arguments[6]:void 0,f=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],C=arguments.length>8?arguments[8]:void 0,x=arguments.length>9?arguments[9]:void 0,g=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(z<0){const u=G;G=s,s=u,z=-z}G>s&&(z=-z),f&&this.stopAnimation(u,void 0,C),m||(m=new b(this,u,G,s,T,z,O,void 0,x,g));const Q=!C||C(u);if(u.animations&&Q&&m.appendAnimations(u,u.animations),u.getAnimatables){const g=u.getAnimatables();for(let u=0;u<g.length;u++)this.beginAnimation(g[u],G,s,T,z,O,m,f,C,x)}return m.reset(),m},n.prototype.beginHierarchyAnimation=function(u,G,s,T,z){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,m=arguments.length>6?arguments[6]:void 0,f=arguments.length>7?arguments[7]:void 0,C=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],x=arguments.length>9?arguments[9]:void 0,g=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const b=u.getDescendants(G),Q=[];Q.push(this.beginAnimation(u,s,T,z,O,m,f,C,x,void 0,g));for(const Y of b)Q.push(this.beginAnimation(Y,s,T,z,O,m,f,C,x,void 0,g));return Q},n.prototype.beginDirectAnimation=function(u,G,s,T,z){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(O<0){const u=s;s=T,T=u,O=-O}return s>T&&(O=-O),new b(this,u,s,T,z,O,arguments.length>6?arguments[6]:void 0,G,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},n.prototype.beginDirectHierarchyAnimation=function(u,G,s,T,z,O,m,f,C){let x=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const g=u.getDescendants(G),b=[];b.push(this.beginDirectAnimation(u,s,T,z,O,m,f,C,x));for(const Q of g)b.push(this.beginDirectAnimation(Q,s,T,z,O,m,f,C,x));return b},n.prototype.getAnimatableByTarget=function(u){for(let G=0;G<this._activeAnimatables.length;G++)if(this._activeAnimatables[G].target===u)return this._activeAnimatables[G];return null},n.prototype.getAllAnimatablesByTarget=function(u){const G=[];for(let s=0;s<this._activeAnimatables.length;s++)this._activeAnimatables[s].target===u&&G.push(this._activeAnimatables[s]);return G},n.prototype.stopAnimation=function(u,G,s){const T=this.getAllAnimatablesByTarget(u);for(const z of T)z.stop(G,s)},n.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let u=0;u<this._activeAnimatables.length;u++)this._activeAnimatables[u].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const u of this.animationGroups)u.stop()});class r{getClassName(){return"TargetedAnimation"}serialize(){const u={};return u.animation=this.animation.serialize(),u.targetId=this.target.id,u}}class c{get mask(){return this._mask}set mask(u){this._mask!==u&&(this._mask=u,this.syncWithMask(!0))}syncWithMask(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||u){this._numActiveAnimatables=0;for(let u=0;u<this._animatables.length;++u){const G=this._animatables[u];!this.mask||this.mask.disabled||this.mask.retainsTarget(G.target.name)?(this._numActiveAnimatables++,G.paused&&G.restart()):G.paused||G.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let u=0;u<this._animatables.length;++u){const G=this._animatables[u];this.mask.retainsTarget(G.target.name)||(G.stop(),this._animatables.splice(u,1),--u)}for(let u=0;u<this._targetedAnimations.length;u++){const G=this._targetedAnimations[u];this.mask.retainsTarget(G.target.name)||(this._targetedAnimations.splice(u,1),--u)}}}get from(){return this._from}set from(u){if(this._from!==u){this._from=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].fromFrame=this._from}}}get to(){return this._to}set to(u){if(this._to!==u){this._to=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(u){if(this._speedRatio!==u){this._speedRatio=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(u){if(this._loopAnimation!==u){this._loopAnimation=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(u){if(this._isAdditive!==u){this._isAdditive=u;for(let u=0;u<this._animatables.length;u++){this._animatables[u].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(u){this._weight!==u&&(this._weight=u,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(u){if(this._playOrder!==u&&(this._playOrder=u,this._animatables.length>0)){for(let u=0;u<this._animatables.length;u++)this._animatables[u].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(u){if(this._enableBlending!==u&&(this._enableBlending=u,null!==u))for(let G=0;G<this._targetedAnimations.length;++G)this._targetedAnimations[G].animation.enableBlending=u}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(u){if(this._blendingSpeed!==u&&(this._blendingSpeed=u,null!==u))for(let G=0;G<this._targetedAnimations.length;++G)this._targetedAnimations[G].animation.blendingSpeed=u}getLength(u,G){u=u??this._from;return((G=G??this._to)-u)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(u){let G=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2],T=arguments.length>3?arguments[3]:void 0;if(0===u.length)return null;T=T??u[0].weight;let z=Number.MAX_VALUE,O=-Number.MAX_VALUE;if(s)for(const f of u)f.from<z&&(z=f.from),f.to>O&&(O=f.to);const m=new c(u[0].name+"_merged",u[0]._scene,T);for(const f of u){s&&f.normalize(z,O);for(const u of f.targetedAnimations)m.addTargetedAnimation(u.animation,u.target);G&&f.dispose()}return m}constructor(u){let G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=u,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new z.e,this.onAnimationLoopObservable=new z.e,this.onAnimationGroupLoopObservable=new z.e,this.onAnimationGroupEndObservable=new z.e,this.onAnimationGroupPauseObservable=new z.e,this.onAnimationGroupPlayObservable=new z.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=G||O.d.LastCreatedScene,this._weight=s,this._playOrder=T,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(u,G){const s=new r;s.animation=u,s.target=G;const T=u.getKeys();return this._from>T[0].frame&&(this._from=T[0].frame),this._to<T[T.length-1].frame&&(this._to=T[T.length-1].frame),null!==this._enableBlending&&(u.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(u.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(s),this._shouldStart=!0,s}removeTargetedAnimation(u){for(let G=this._targetedAnimations.length-1;G>-1;G--){this._targetedAnimations[G].animation===u&&this._targetedAnimations.splice(G,1)}}normalize(){let u=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==u&&(u=this._from),null==G&&(G=this._to);for(let s=0;s<this._targetedAnimations.length;s++){const T=this._targetedAnimations[s].animation.getKeys(),z=T[0],O=T[T.length-1];if(z.frame>u){const G={frame:u,value:z.value,inTangent:z.inTangent,outTangent:z.outTangent,interpolation:z.interpolation};T.splice(0,0,G)}if(O.frame<G){const u={frame:G,value:O.value,inTangent:O.inTangent,outTangent:O.outTangent,interpolation:O.interpolation};T.push(u)}}return this._from=u,this._to=G,this}_processLoop(u,G,s){u.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(G),this._animationLoopFlags[s]||(this._animationLoopFlags[s]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0],G=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,s=arguments.length>2?arguments[2]:void 0,T=arguments.length>3?arguments[3]:void 0,z=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=u,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let O=0;O<this._targetedAnimations.length;O++){const m=this._targetedAnimations[O],f=this._scene.beginDirectAnimation(m.target,[m.animation],void 0!==s?s:this._from,void 0!==T?T:this._to,u,G,void 0,void 0,void 0!==z?z:this._isAdditive);f.weight=this._weight,f.playOrder=this._playOrder,f.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(m),this._checkAnimationGroupEnded(f)},this._processLoop(f,m,O),this._animatables.push(f)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=G,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let u=0;u<this._animatables.length;u++){this._animatables[u].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(u){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==u&&(this.loopAnimation=u),this.restart()):(this.stop(),this.start(u,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].reset()}return this}restart(){if(!this._isStarted)return this;for(let u=0;u<this._animatables.length;u++){this._animatables[u].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let u=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const G=this._animatables.slice();for(let T=0;T<G.length;T++)G[T].stop(void 0,void 0,!0,u);let s=0;for(let T=0;T<this._scene._activeAnimatables.length;T++){const G=this._scene._activeAnimatables[T];G._runtimeAnimations.length>0?this._scene._activeAnimatables[s++]=G:u&&this._checkAnimationGroupEnded(G,u)}return this._scene._activeAnimatables.length=s,this._isStarted=!1,this}setWeightForAllAnimatables(u){for(let G=0;G<this._animatables.length;G++){this._animatables[G].weight=u}return this}syncAllAnimationsWith(u){for(let G=0;G<this._animatables.length;G++){this._animatables[G].syncWith(u)}return this}goToFrame(u){if(!this._isStarted)return this;for(let G=0;G<this._animatables.length;G++){this._animatables[G].goToFrame(u)}return this}getCurrentFrame(){var u;return(null===(u=this.animatables[0])||void 0===u?void 0:u.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const u=this._scene.animationGroups.indexOf(this);if(u>-1&&this._scene.animationGroups.splice(u,1),this._parentContainer){const u=this._parentContainer.animationGroups.indexOf(this);u>-1&&this._parentContainer.animationGroups.splice(u,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(u){let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const s=this._animatables.indexOf(u);s>-1&&this._animatables.splice(s,1),0===this._animatables.length&&(this._isStarted=!1,G||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(u,G){let s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const T=new c(u||this.name,this._scene,this._weight,this._playOrder);T._from=this.from,T._to=this.to,T._speedRatio=this.speedRatio,T._loopAnimation=this.loopAnimation,T._isAdditive=this.isAdditive,T._enableBlending=this.enableBlending,T._blendingSpeed=this.blendingSpeed,T.metadata=this.metadata,T.mask=this.mask;for(const z of this._targetedAnimations)T.addTargetedAnimation(s?z.animation.clone():z.animation,G?G(z.target):z.target);return T}serialize(){const u={};u.name=this.name,u.from=this.from,u.to=this.to,u.speedRatio=this.speedRatio,u.loopAnimation=this.loopAnimation,u.isAdditive=this.isAdditive,u.weight=this.weight,u.playOrder=this.playOrder,u.enableBlending=this.enableBlending,u.blendingSpeed=this.blendingSpeed,u.targetedAnimations=[];for(let G=0;G<this.targetedAnimations.length;G++){const s=this.targetedAnimations[G];u.targetedAnimations[G]=s.serialize()}return m.c&&m.c.HasTags(this)&&(u.tags=m.c.GetTags(this)),this.metadata&&(u.metadata=this.metadata),u}static Parse(u,G){const s=new c(u.name,G,u.weight,u.playOrder);for(let z=0;z<u.targetedAnimations.length;z++){const O=u.targetedAnimations[z],m=T.b.Parse(O.animation),f=O.targetId;if("influence"===O.animation.property){const u=G.getMorphTargetById(f);u&&s.addTargetedAnimation(m,u)}else{const u=G.getNodeById(f);null!=u&&s.addTargetedAnimation(m,u)}}return m.c&&m.c.AddTagsTo(s,u.tags),null!==u.from&&null!==u.to&&s.normalize(u.from,u.to),void 0!==u.speedRatio&&(s._speedRatio=u.speedRatio),void 0!==u.loopAnimation&&(s._loopAnimation=u.loopAnimation),void 0!==u.isAdditive&&(s._isAdditive=u.isAdditive),void 0!==u.weight&&(s._weight=u.weight),void 0!==u.playOrder&&(s._playOrder=u.playOrder),void 0!==u.enableBlending&&(s._enableBlending=u.enableBlending),void 0!==u.blendingSpeed&&(s._blendingSpeed=u.blendingSpeed),void 0!==u.metadata&&(s.metadata=u.metadata),s}static MakeAnimationAdditive(u,G,s){let z;z="object"===typeof G?G:{referenceFrame:G,range:s,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let O=u;z.cloneOriginalAnimationGroup&&(O=u.clone(z.clonedAnimationGroupName||O.name));const m=O.targetedAnimations;for(let f=0;f<m.length;f++){const u=m[f];u.animation=T.b.MakeAnimationAdditive(u.animation,z)}if(O.isAdditive=!0,z.clipKeys){let u=Number.MAX_VALUE,G=-Number.MAX_VALUE;const s=O.targetedAnimations;for(let T=0;T<s.length;T++){const z=s[T].animation.getKeys();u>z[0].frame&&(u=z[0].frame),G<z[z.length-1].frame&&(G=z[z.length-1].frame)}O._from=u,O._to=G}return O}static ClipKeys(u,G,s,T,z){const O=u.clone(T||u.name);return c.ClipKeysInPlace(O,G,s,z)}static ClipKeysInPlace(u,G,s,T){return c.ClipInPlace(u,G,s,T,!1)}static ClipFrames(u,G,s,T,z){const O=u.clone(T||u.name);return c.ClipFramesInPlace(O,G,s,z)}static ClipFramesInPlace(u,G,s,T){return c.ClipInPlace(u,G,s,T,!0)}static ClipInPlace(u,G,s,T){let z=arguments.length>4&&void 0!==arguments[4]&&arguments[4],O=Number.MAX_VALUE,m=-Number.MAX_VALUE;const f=u.targetedAnimations;for(let C=0;C<f.length;C++){const u=f[C],x=T?u.animation:u.animation.clone();z&&(x.createKeyForFrame(G),x.createKeyForFrame(s));const g=x.getKeys(),b=[];let Q=Number.MAX_VALUE;for(let T=0;T<g.length;T++){const u=g[T];if(!z&&T>=G&&T<=s||z&&u.frame>=G&&u.frame<=s){const G={frame:u.frame,value:u.value.clone?u.value.clone():u.value,inTangent:u.inTangent,outTangent:u.outTangent,interpolation:u.interpolation,lockedTangent:u.lockedTangent};Q===Number.MAX_VALUE&&(Q=G.frame),G.frame-=Q,b.push(G)}}0!==b.length?(O>b[0].frame&&(O=b[0].frame),m<b[b.length-1].frame&&(m=b[b.length-1].frame),x.setKeys(b,!0),u.animation=x):(f.splice(C,1),C--)}return u._from=O,u._to=m,u}getClassName(){return"AnimationGroup"}toString(u){let G="Name: "+this.name;return G+=", type: "+this.getClassName(),u&&(G+=", from: "+this._from,G+=", to: "+this._to,G+=", isStarted: "+this._isStarted,G+=", speedRatio: "+this._speedRatio,G+=", targetedAnimations length: "+this._targetedAnimations.length,G+=", animatables length: "+this._animatables),G}}}}]);