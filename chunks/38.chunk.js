"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13281:(E,Y,C)=>{C.r(Y),C.d(Y,{AnimationGroup:()=>M,TargetedAnimation:()=>Z});var P=C(12018),K=C(10739),m=C(10778),u=C(11057),T=C(12009),a=C(11064);class J{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(E,Y,C,K){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=Y,this._target=E,this._scene=C,this._host=K,this._activeTargets=[],Y._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===P.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=a.b.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const E={frame:0,value:this._minValue};this._keys.splice(0,0,E)}if(this._target instanceof Array){let E=0;for(const Y of this._target)this._preparePath(Y,E),this._getOriginalValues(E),E++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const m=Y.getEvents();m&&m.length>0&&m.forEach((E=>{this._events.push(E._clone())})),this._enableBlending=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(E){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const C=this._animation.targetPropertyPath;if(C.length>1){let P=E;for(let E=0;E<C.length-1;E++){const Y=C[E];if(P=P[Y],void 0===P)throw new Error(`Invalid property (${Y}) in property path (${C.join(".")})`)}this._targetPath=C[C.length-1],this._activeTargets[Y]=P}else this._targetPath=C[0],this._activeTargets[Y]=E;if(void 0===this._activeTargets[Y][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${C.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let E=0;for(const Y of this._target)void 0!==this._originalValue[E]&&this._setValue(Y,this._activeTargets[E],this._originalValue[E],-1,E),E++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let E=0;E<this._events.length;E++)this._events[E].isDone=!1}isStopped(){return this._stopped}dispose(){const E=this._animation.runtimeAnimations.indexOf(this);E>-1&&this._animation.runtimeAnimations.splice(E,1)}setValue(E,Y){if(this._targetIsArray)for(let C=0;C<this._target.length;C++){const P=this._target[C];this._setValue(P,this._activeTargets[C],E,Y,C)}else this._setValue(this._target,this._directTarget,E,Y,0)}_getOriginalValues(){let E,Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const C=this._activeTargets[Y];E=C.getLocalMatrix&&"_matrix"===this._targetPath?C.getLocalMatrix():C[this._targetPath],E&&E.clone?this._originalValue[Y]=E.clone():this._originalValue[Y]=E}_registerTargetForLateAnimationBinding(E,Y){const C=E.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(C),C._lateAnimationHolders||(C._lateAnimationHolders={}),C._lateAnimationHolders[E.targetPath]||(C._lateAnimationHolders[E.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:Y}),E.isAdditive?(C._lateAnimationHolders[E.targetPath].additiveAnimations.push(E),C._lateAnimationHolders[E.targetPath].totalAdditiveWeight+=E.weight):(C._lateAnimationHolders[E.targetPath].animations.push(E),C._lateAnimationHolders[E.targetPath].totalWeight+=E.weight)}_setValue(E,Y,C,K,m){if(this._currentActiveTarget=Y,this._weight=K,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const E=Y[this._targetPath];E.clone?this._originalBlendValue=E.clone():this._originalBlendValue=E}this._originalBlendValue.m?P.e.AllowMatrixDecomposeForInterpolation?this._currentValue?a.b.DecomposeLerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=a.b.DecomposeLerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue?a.b.LerpToRef(this._originalBlendValue,C,this._blendingFactor,this._currentValue):this._currentValue=a.b.Lerp(this._originalBlendValue,C,this._blendingFactor):this._currentValue=P.e._UniversalLerp(this._originalBlendValue,C,this._blendingFactor);const K=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=K}else this._currentValue?this._currentValue.p?this._currentValue.p(C):this._currentValue=C:null!==C&&void 0!==C&&C.clone?this._currentValue=C.clone():this._currentValue=C;-1!==K?this._registerTargetForLateAnimationBinding(this,this._originalValue[m]):this._animationState.loopMode===P.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[m],Y[this._targetPath]):Y[this._targetPath]=this._originalValue[m]+this._currentValue:Y[this._targetPath]=this._currentValue,E.Pg&&E.Pg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(E){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const C=this._animation.getKeys();E<C[0].frame?E=C[0].frame:E>C[C.length-1].frame&&(E=C[C.length-1].frame);const P=this._events;if(P.length)for(let m=0;m<P.length;m++)P[m].onlyOnce||(P[m].isDone=P[m].frame<E);this._currentFrame=E;const K=this._animation._interpolate(E,this._animationState);this.setValue(K,Y)}_prepareForSpeedRatioChange(E){const Y=this._previousElapsedTime*(this._animation.framePerSecond*E)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-Y}animate(E,Y,C,K,m){let u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const T=this._animation,a=T.targetPropertyPath;if(!a||a.length<1)return this._stopped=!0,!1;let J=!0;(Y<this._minFrame||Y>this._maxFrame)&&(Y=this._minFrame),(C<this._minFrame||C>this._maxFrame)&&(C=this._maxFrame);const t=C-Y;let p,W=E*(T.framePerSecond*m)/1e3+this._absoluteFrameOffset,k=0,y=!1;const v=K&&this._animationState.loopMode===P.e.ANIMATIONLOOPMODE_YOYO;if(v){const E=(W-Y)/t,C=Math.sin(E*Math.PI);W=Math.abs(C)*t+Y;const P=C>=0?1:-1;this._yoyoDirection!==P&&(y=!0),this._yoyoDirection=P}if(this._previousElapsedTime=E,this._previousAbsoluteFrame=W,!K&&C>=Y&&(W>=t&&m>0||W<=0&&m<0))J=!1,k=T._getKeyValue(this._maxValue);else if(!K&&Y>=C&&(W<=t&&m<0||W>=0&&m>0))J=!1,k=T._getKeyValue(this._minValue);else if(this._animationState.loopMode!==P.e.ANIMATIONLOOPMODE_CYCLE){const E=C.toString()+Y.toString();if(!this._offsetsCache[E]){this._animationState.repeatCount=0,this._animationState.loopMode=P.e.ANIMATIONLOOPMODE_CYCLE;const K=T._interpolate(Y,this._animationState),m=T._interpolate(C,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),T.dataType){case P.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[E]=m-K;break;case P.e.ANIMATIONTYPE_QUATERNION:case P.e.ANIMATIONTYPE_VECTOR3:case P.e.ANIMATIONTYPE_VECTOR2:case P.e.ANIMATIONTYPE_SIZE:case P.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[E]=m.md(K)}this._highLimitsCache[E]=m}k=this._highLimitsCache[E],p=this._offsetsCache[E]}if(void 0===p)switch(T.dataType){case P.e.ANIMATIONTYPE_FLOAT:p=0;break;case P.e.ANIMATIONTYPE_QUATERNION:p=P.m;break;case P.e.ANIMATIONTYPE_VECTOR3:p=P.v;break;case P.e.ANIMATIONTYPE_VECTOR2:p=P.t;break;case P.e.ANIMATIONTYPE_SIZE:p=P.q;break;case P.e.ANIMATIONTYPE_COLOR3:p=P.h;break;case P.e.ANIMATIONTYPE_COLOR4:p=P.i}let V;if(this._host&&this._host.syncRoot){const E=this._host.syncRoot;V=Y+t*((E.masterFrame-E.fromFrame)/(E.toFrame-E.fromFrame))}else V=W>0&&Y>C||W<0&&Y<C?J&&0!==t?C+W%t:Y:J&&0!==t?Y+W%t:C;const Z=this._events;if(!v&&(m>0&&this.currentFrame>V||m<0&&this.currentFrame<V)||v&&y){this._onLoop();for(let E=0;E<Z.length;E++)Z[E].onlyOnce||(Z[E].isDone=!1);this._animationState.key=m>0?0:T.getKeys().length-1}this._currentFrame=V,this._animationState.repeatCount=0===t?0:W/t|0,this._animationState.highLimitValue=k,this._animationState.offsetValue=p;const M=T._interpolate(V,this._animationState);if(this.setValue(M,u),Z.length)for(let P=0;P<Z.length;P++)if(t>=0&&V>=Z[P].frame&&Z[P].frame>=Y||t<0&&V<=Z[P].frame&&Z[P].frame<=Y){const E=Z[P];E.isDone||(E.onlyOnce&&(Z.splice(P,1),P--),E.isDone=!0,E.action(V))}return J||(this._stopped=!0),J}}var t=C(10763);class p{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(E){this._weight=-1!==E?Math.min(Math.max(E,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(E){for(let Y=0;Y<this._runtimeAnimations.length;Y++){this._runtimeAnimations[Y]._prepareForSpeedRatioChange(E)}this._speedRatio=E,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(E,Y){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,m=arguments.length>4&&void 0!==arguments[4]&&arguments[4],u=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,T=arguments.length>6?arguments[6]:void 0,a=arguments.length>7?arguments[7]:void 0,J=arguments.length>8?arguments[8]:void 0,t=arguments.length>9&&void 0!==arguments[9]&&arguments[9],p=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=Y,this.fromFrame=C,this.toFrame=P,this.loopAnimation=m,this.onAnimationEnd=T,this.onAnimationLoop=J,this.isAdditive=t,this.playOrder=p,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Pd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new K.e,this.onAnimationLoopObservable=new K.e,this._scene=E,a&&this.appendAnimations(Y,a),this._speedRatio=u,E._activeAnimatables.push(this)}syncWith(E){if(this._syncRoot=E,E){const E=this._scene._activeAnimatables.indexOf(this);E>-1&&(this._scene._activeAnimatables.splice(E,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(E,Y){for(let C=0;C<Y.length;C++){const P=Y[C],K=new J(E,P,this._scene,this);K._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(K)}}getAnimationByTargetProperty(E){const Y=this._runtimeAnimations;for(let C=0;C<Y.length;C++)if(Y[C].animation.targetProperty===E)return Y[C].animation;return null}getRuntimeAnimationByTargetProperty(E){const Y=this._runtimeAnimations;for(let C=0;C<Y.length;C++)if(Y[C].animation.targetProperty===E)return Y[C];return null}reset(){const E=this._runtimeAnimations;for(let Y=0;Y<E.length;Y++)E[Y].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(E){const Y=this._runtimeAnimations;for(let C=0;C<Y.length;C++)Y[C].animation.enableBlending=!0,Y[C].animation.blendingSpeed=E}disableBlending(){const E=this._runtimeAnimations;for(let Y=0;Y<E.length;Y++)E[Y].animation.enableBlending=!1}goToFrame(E){const Y=this._runtimeAnimations;if(Y[0]){const C=Y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??Y[0].currentFrame;const P=0===this.speedRatio?0:(E-this._frameToSyncFromJump)/C*1e3/this.speedRatio;this._manualJumpDelay=-P}for(let C=0;C<Y.length;C++)Y[C].goToFrame(E,this._weight);this._goToFrame=E}get paused(){return this.Pd}pause(){this.Pd||(this.Pd=!0)}restart(){this.Pd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(E,Y){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(E||Y){const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){const m=this._runtimeAnimations;for(let C=m.length-1;C>=0;C--){const P=m[C];E&&P.animation.name!=E||(Y&&!Y(P.target)||(P.dispose(),m.splice(C,1)))}0==m.length&&(C||this._scene._activeAnimatables.splice(K,1),P||this._raiseOnAnimationEnd())}}else{const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){C||this._scene._activeAnimatables.splice(E,1);const Y=this._runtimeAnimations;for(let E=0;E<Y.length;E++)Y[E].dispose();this._runtimeAnimations.length=0,P||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((E=>{this.onAnimationEndObservable.add((()=>{E(this)}),void 0,void 0,this,!0)}))}_animate(E){if(this.Pd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=E),!0;if(null===this._localDelayOffset?(this._localDelayOffset=E,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=E-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let Y=!1;const C=this._runtimeAnimations;let P;for(P=0;P<C.length;P++){const K=C[P].animate(E-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);Y=Y||K}if(this.animationStarted=Y,!Y){if(this.disposeOnEnd)for(P=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(P,1),P=0;P<C.length;P++)C[P].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return Y}}function W(E){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return E.originalValue;let Y=1;const C=a.h.o[0],P=a.h.o[1],K=a.h.Quaternion[0];let m=0;const u=E.animations[0],T=E.originalValue;let J=1,t=!1;if(E.totalWeight<1)J=1-E.totalWeight,T.decompose(P,K,C);else{if(m=1,Y=E.totalWeight,J=u.weight/Y,1==J){if(!E.totalAdditiveWeight)return u.currentValue;t=!0}u.currentValue.decompose(P,K,C)}if(!t){P.scaleInPlace(J),C.scaleInPlace(J),K.scaleInPlace(J);for(let u=m;u<E.animations.length;u++){const m=E.animations[u];if(0===m.weight)continue;J=m.weight/Y;const T=a.h.o[2],t=a.h.o[3],p=a.h.Quaternion[1];m.currentValue.decompose(t,p,T),t.scaleAndAddToRef(J,P),p.scaleAndAddToRef(a.e.Dot(K,p)>0?J:-J,K),T.scaleAndAddToRef(J,C)}K.normalize()}for(let W=0;W<E.additiveAnimations.length;W++){const Y=E.additiveAnimations[W];if(0===Y.weight)continue;const m=a.h.o[2],u=a.h.o[3],T=a.h.Quaternion[1];Y.currentValue.decompose(u,T,m),u.multiplyToRef(P,u),a.m.LerpToRef(P,u,Y.weight,P),K.multiplyToRef(T,T),a.e.SlerpToRef(K,T,Y.weight,K),m.scaleAndAddToRef(Y.weight,C)}const p=u?u._animationState.workValue:a.h.Matrix[0].clone();return a.b.ComposeToRef(P,K,C,p),p}function k(E,Y){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return Y;const C=E.animations[0],P=E.originalValue;let K=Y;if(0===E.totalWeight&&E.totalAdditiveWeight>0)K.p(P);else if(1===E.animations.length){if(a.e.SlerpToRef(P,C.currentValue,Math.min(1,E.totalWeight),K),0===E.totalAdditiveWeight)return K}else if(E.animations.length>1){let C,m,u=1;if(E.totalWeight<1){const Y=1-E.totalWeight;C=[],m=[],C.push(P),m.push(Y)}else{if(2===E.animations.length&&(a.e.SlerpToRef(E.animations[0].currentValue,E.animations[1].currentValue,E.animations[1].weight/E.totalWeight,Y),0===E.totalAdditiveWeight))return Y;C=[],m=[],u=E.totalWeight}for(let Y=0;Y<E.animations.length;Y++){const P=E.animations[Y];C.push(P.currentValue),m.push(P.weight/u)}let T=0;for(let E=0;E<C.length;)E?(T+=m[E],a.e.SlerpToRef(K,C[E],m[E]/T,K),E++):(a.e.SlerpToRef(C[E],C[E+1],m[E+1]/(m[E]+m[E+1]),Y),K=Y,T=m[E]+m[E+1],E+=2)}for(let m=0;m<E.additiveAnimations.length;m++){const Y=E.additiveAnimations[m];0!==Y.weight&&(K.multiplyToRef(Y.currentValue,a.h.Quaternion[0]),a.e.SlerpToRef(K,a.h.Quaternion[0],Y.weight,K))}return K}var y,v,V=C(11053);y=V.e,(v=T.b)&&(v.prototype.copyAnimationRange=function(E,Y,C){let K=arguments.length>3&&void 0!==arguments[3]&&arguments[3],m=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new P.e(this.name,"_matrix",E.animations[0].framePerSecond,P.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const u=E.animations[0].getRange(Y);if(!u)return!1;const T=u.from,a=u.to,J=E.animations[0].getKeys(),t=E.length,p=E.getParent(),W=this.getParent(),k=K&&p&&t&&this.length&&t!==this.length,y=k&&W&&p?W.length/p.length:1,v=K&&!W&&m&&(1!==m.x||1!==m.y||1!==m.z),V=this.animations[0].getKeys();let Z,M,h;for(let P=0,f=J.length;P<f;P++)Z=J[P],Z.frame>=T&&Z.frame<=a&&(K?(h=Z.value.clone(),k?(M=h.getTranslation(),h.setTranslation(M.scaleInPlace(y))):v&&m?(M=h.getTranslation(),h.setTranslation(M.multiplyInPlace(m))):h=Z.value):h=Z.value,V.push({frame:Z.frame+C,value:h}));return this.animations[0].createRange(Y,T+C,a+C),!0}),y&&(y.prototype._animate=function(E){if(!this.animationsEnabled)return;const Y=t.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=Y}this.deltaTime=void 0!==E?E:this.useConstantAnimationDeltaTime?16:(Y-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=Y;const C=this._activeAnimatables;if(0===C.length)return;this._animationTime+=this.deltaTime;const K=this._animationTime;for(let P=0;P<C.length;P++){const E=C[P];!E._animate(K)&&E.disposeOnEnd&&P--}!function(E){if(E._registeredForLateAnimationBindings.length){for(let Y=0;Y<E._registeredForLateAnimationBindings.length;Y++){const C=E._registeredForLateAnimationBindings.data[Y];for(const E in C._lateAnimationHolders){const Y=C._lateAnimationHolders[E],K=Y.animations[0],m=Y.originalValue;if(void 0===m||null===m)continue;const u=P.e.AllowMatrixDecomposeForInterpolation&&m.m;let T=C[E];if(u)T=W(Y);else if(void 0!==m.w)T=k(Y,T||a.e.Identity());else{let E=0,C=1;const u=K&&K._animationState.loopMode===P.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(Y.totalWeight<1)T=u?m.clone?m.clone():m:K&&m.scale?m.scale(1-Y.totalWeight):K?m*(1-Y.totalWeight):m.clone?m.clone():m;else if(K){C=Y.totalWeight;const P=K.weight/C;T=1!==P?K.currentValue.scale?K.currentValue.scale(P):K.currentValue*P:K.currentValue,u&&(T.addToRef?T.addToRef(m,T):T+=m),E=1}for(let P=E;P<Y.animations.length;P++){const E=Y.animations[P],K=E.weight/C;K&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(K,T):T+=E.currentValue*K)}for(let P=0;P<Y.additiveAnimations.length;P++){const E=Y.additiveAnimations[P],C=E.weight;C&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(C,T):T+=E.currentValue*C)}}C[E]=T}C._lateAnimationHolders={}}E._registeredForLateAnimationBindings.reset()}}(this)},y.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((E,Y)=>E.playOrder-Y.playOrder))},y.prototype.beginWeightedAnimation=function(E,Y,C){let P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,K=arguments.length>4?arguments[4]:void 0,m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const p=this.beginAnimation(E,Y,C,K,m,u,T,!1,a,J,t);return p.weight=P,p},y.prototype.beginAnimation=function(E,Y,C,P){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,m=arguments.length>5?arguments[5]:void 0,u=arguments.length>6?arguments[6]:void 0,T=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],a=arguments.length>8?arguments[8]:void 0,J=arguments.length>9?arguments[9]:void 0,t=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(K<0){const E=Y;Y=C,C=E,K=-K}Y>C&&(K=-K),T&&this.stopAnimation(E,void 0,a),u||(u=new p(this,E,Y,C,P,K,m,void 0,J,t));const W=!a||a(E);if(E.animations&&W&&u.appendAnimations(E,E.animations),E.getAnimatables){const t=E.getAnimatables();for(let E=0;E<t.length;E++)this.beginAnimation(t[E],Y,C,P,K,m,u,T,a,J)}return u.reset(),u},y.prototype.beginHierarchyAnimation=function(E,Y,C,P,K){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,u=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,a=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],J=arguments.length>9?arguments[9]:void 0,t=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const p=E.getDescendants(Y),W=[];W.push(this.beginAnimation(E,C,P,K,m,u,T,a,J,void 0,t));for(const k of p)W.push(this.beginAnimation(k,C,P,K,m,u,T,a,J,void 0,t));return W},y.prototype.beginDirectAnimation=function(E,Y,C,P,K){let m=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(m<0){const E=C;C=P,P=E,m=-m}return C>P&&(m=-m),new p(this,E,C,P,K,m,arguments.length>6?arguments[6]:void 0,Y,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},y.prototype.beginDirectHierarchyAnimation=function(E,Y,C,P,K,m,u,T,a){let J=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const t=E.getDescendants(Y),p=[];p.push(this.beginDirectAnimation(E,C,P,K,m,u,T,a,J));for(const W of t)p.push(this.beginDirectAnimation(W,C,P,K,m,u,T,a,J));return p},y.prototype.getAnimatableByTarget=function(E){for(let Y=0;Y<this._activeAnimatables.length;Y++)if(this._activeAnimatables[Y].target===E)return this._activeAnimatables[Y];return null},y.prototype.getAllAnimatablesByTarget=function(E){const Y=[];for(let C=0;C<this._activeAnimatables.length;C++)this._activeAnimatables[C].target===E&&Y.push(this._activeAnimatables[C]);return Y},y.prototype.stopAnimation=function(E,Y,C){const P=this.getAllAnimatablesByTarget(E);for(const K of P)K.stop(Y,C)},y.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const E of this.animationGroups)E.stop()});class Z{getClassName(){return"TargetedAnimation"}serialize(){const E={};return E.animation=this.animation.serialize(),E.targetId=this.target.id,E}}class M{get mask(){return this._mask}set mask(E){this._mask!==E&&(this._mask=E,this.syncWithMask(!0))}syncWithMask(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||E){this._numActiveAnimatables=0;for(let E=0;E<this._animatables.length;++E){const Y=this._animatables[E];!this.mask||this.mask.disabled||this.mask.retainsTarget(Y.target.name)?(this._numActiveAnimatables++,Y.paused&&Y.restart()):Y.paused||Y.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let E=0;E<this._animatables.length;++E){const Y=this._animatables[E];this.mask.retainsTarget(Y.target.name)||(Y.stop(),this._animatables.splice(E,1),--E)}for(let E=0;E<this._targetedAnimations.length;E++){const Y=this._targetedAnimations[E];this.mask.retainsTarget(Y.target.name)||(this._targetedAnimations.splice(E,1),--E)}}}get from(){return this._from}set from(E){if(this._from!==E){this._from=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].fromFrame=this._from}}}get to(){return this._to}set to(E){if(this._to!==E){this._to=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(E){if(this._speedRatio!==E){this._speedRatio=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(E){if(this._loopAnimation!==E){this._loopAnimation=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(E){if(this._isAdditive!==E){this._isAdditive=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(E){this._weight!==E&&(this._weight=E,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(E){if(this._playOrder!==E&&(this._playOrder=E,this._animatables.length>0)){for(let E=0;E<this._animatables.length;E++)this._animatables[E].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(E){if(this._enableBlending!==E&&(this._enableBlending=E,null!==E))for(let Y=0;Y<this._targetedAnimations.length;++Y)this._targetedAnimations[Y].animation.enableBlending=E}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(E){if(this._blendingSpeed!==E&&(this._blendingSpeed=E,null!==E))for(let Y=0;Y<this._targetedAnimations.length;++Y)this._targetedAnimations[Y].animation.blendingSpeed=E}getLength(E,Y){E=E??this._from;return((Y=Y??this._to)-E)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(E){let Y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]&&arguments[2],P=arguments.length>3?arguments[3]:void 0;if(0===E.length)return null;P=P??E[0].weight;let K=Number.MAX_VALUE,m=-Number.MAX_VALUE;if(C)for(const T of E)T.from<K&&(K=T.from),T.to>m&&(m=T.to);const u=new M(E[0].name+"_merged",E[0]._scene,P);for(const T of E){C&&T.normalize(K,m);for(const E of T.targetedAnimations)u.addTargetedAnimation(E.animation,E.target);Y&&T.dispose()}return u}constructor(E){let Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,P=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=E,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new K.e,this.onAnimationLoopObservable=new K.e,this.onAnimationGroupLoopObservable=new K.e,this.onAnimationGroupEndObservable=new K.e,this.onAnimationGroupPauseObservable=new K.e,this.onAnimationGroupPlayObservable=new K.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=Y||m.e.LastCreatedScene,this._weight=C,this._playOrder=P,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(E,Y){const C=new Z;C.animation=E,C.target=Y;const P=E.getKeys();return this._from>P[0].frame&&(this._from=P[0].frame),this._to<P[P.length-1].frame&&(this._to=P[P.length-1].frame),null!==this._enableBlending&&(E.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(E.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(C),this._shouldStart=!0,C}removeTargetedAnimation(E){for(let Y=this._targetedAnimations.length-1;Y>-1;Y--){this._targetedAnimations[Y].animation===E&&this._targetedAnimations.splice(Y,1)}}normalize(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==E&&(E=this._from),null==Y&&(Y=this._to);for(let C=0;C<this._targetedAnimations.length;C++){const P=this._targetedAnimations[C].animation.getKeys(),K=P[0],m=P[P.length-1];if(K.frame>E){const Y={frame:E,value:K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation};P.splice(0,0,Y)}if(m.frame<Y){const E={frame:Y,value:m.value,inTangent:m.inTangent,outTangent:m.outTangent,interpolation:m.interpolation};P.push(E)}}return this._from=E,this._to=Y,this}_processLoop(E,Y,C){E.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(Y),this._animationLoopFlags[C]||(this._animationLoopFlags[C]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0],Y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,C=arguments.length>2?arguments[2]:void 0,P=arguments.length>3?arguments[3]:void 0,K=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=E,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let m=0;m<this._targetedAnimations.length;m++){const u=this._targetedAnimations[m],T=this._scene.beginDirectAnimation(u.target,[u.animation],void 0!==C?C:this._from,void 0!==P?P:this._to,E,Y,void 0,void 0,void 0!==K?K:this._isAdditive);T.weight=this._weight,T.playOrder=this._playOrder,T.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(u),this._checkAnimationGroupEnded(T)},this._processLoop(T,u,m),this._animatables.push(T)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=Y,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let E=0;E<this._animatables.length;E++){this._animatables[E].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(E){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==E&&(this.loopAnimation=E),this.restart()):(this.stop(),this.start(E,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].reset()}return this}restart(){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const Y=this._animatables.slice();for(let P=0;P<Y.length;P++)Y[P].stop(void 0,void 0,!0,E);let C=0;for(let P=0;P<this._scene._activeAnimatables.length;P++){const Y=this._scene._activeAnimatables[P];Y._runtimeAnimations.length>0?this._scene._activeAnimatables[C++]=Y:E&&this._checkAnimationGroupEnded(Y,E)}return this._scene._activeAnimatables.length=C,this._isStarted=!1,this}setWeightForAllAnimatables(E){for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].weight=E}return this}syncAllAnimationsWith(E){for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].syncWith(E)}return this}goToFrame(E){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].goToFrame(E)}return this}getCurrentFrame(){var E;return(null===(E=this.animatables[0])||void 0===E?void 0:E.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const E=this._scene.animationGroups.indexOf(this);if(E>-1&&this._scene.animationGroups.splice(E,1),this._parentContainer){const E=this._parentContainer.animationGroups.indexOf(this);E>-1&&this._parentContainer.animationGroups.splice(E,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(E){let Y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const C=this._animatables.indexOf(E);C>-1&&this._animatables.splice(C,1),0===this._animatables.length&&(this._isStarted=!1,Y||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(E,Y){let C=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const P=new M(E||this.name,this._scene,this._weight,this._playOrder);P._from=this.from,P._to=this.to,P._speedRatio=this.speedRatio,P._loopAnimation=this.loopAnimation,P._isAdditive=this.isAdditive,P._enableBlending=this.enableBlending,P._blendingSpeed=this.blendingSpeed,P.metadata=this.metadata,P.mask=this.mask;for(const K of this._targetedAnimations)P.addTargetedAnimation(C?K.animation.clone():K.animation,Y?Y(K.target):K.target);return P}serialize(){const E={};E.name=this.name,E.from=this.from,E.to=this.to,E.speedRatio=this.speedRatio,E.loopAnimation=this.loopAnimation,E.isAdditive=this.isAdditive,E.weight=this.weight,E.playOrder=this.playOrder,E.enableBlending=this.enableBlending,E.blendingSpeed=this.blendingSpeed,E.targetedAnimations=[];for(let Y=0;Y<this.targetedAnimations.length;Y++){const C=this.targetedAnimations[Y];E.targetedAnimations[Y]=C.serialize()}return u.b&&u.b.HasTags(this)&&(E.tags=u.b.GetTags(this)),this.metadata&&(E.metadata=this.metadata),E}static Parse(E,Y){const C=new M(E.name,Y,E.weight,E.playOrder);for(let K=0;K<E.targetedAnimations.length;K++){const m=E.targetedAnimations[K],u=P.e.Parse(m.animation),T=m.targetId;if("influence"===m.animation.property){const E=Y.getMorphTargetById(T);E&&C.addTargetedAnimation(u,E)}else{const E=Y.getNodeById(T);null!=E&&C.addTargetedAnimation(u,E)}}return u.b&&u.b.AddTagsTo(C,E.tags),null!==E.from&&null!==E.to&&C.normalize(E.from,E.to),void 0!==E.speedRatio&&(C._speedRatio=E.speedRatio),void 0!==E.loopAnimation&&(C._loopAnimation=E.loopAnimation),void 0!==E.isAdditive&&(C._isAdditive=E.isAdditive),void 0!==E.weight&&(C._weight=E.weight),void 0!==E.playOrder&&(C._playOrder=E.playOrder),void 0!==E.enableBlending&&(C._enableBlending=E.enableBlending),void 0!==E.blendingSpeed&&(C._blendingSpeed=E.blendingSpeed),void 0!==E.metadata&&(C.metadata=E.metadata),C}static MakeAnimationAdditive(E,Y,C){let K;K="object"===typeof Y?Y:{referenceFrame:Y,range:C,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let m=E;K.cloneOriginalAnimationGroup&&(m=E.clone(K.clonedAnimationGroupName||m.name));const u=m.targetedAnimations;for(let T=0;T<u.length;T++){const E=u[T];E.animation=P.e.MakeAnimationAdditive(E.animation,K)}if(m.isAdditive=!0,K.clipKeys){let E=Number.MAX_VALUE,Y=-Number.MAX_VALUE;const C=m.targetedAnimations;for(let P=0;P<C.length;P++){const K=C[P].animation.getKeys();E>K[0].frame&&(E=K[0].frame),Y<K[K.length-1].frame&&(Y=K[K.length-1].frame)}m._from=E,m._to=Y}return m}static ClipKeys(E,Y,C,P,K){const m=E.clone(P||E.name);return M.ClipKeysInPlace(m,Y,C,K)}static ClipKeysInPlace(E,Y,C,P){return M.ClipInPlace(E,Y,C,P,!1)}static ClipFrames(E,Y,C,P,K){const m=E.clone(P||E.name);return M.ClipFramesInPlace(m,Y,C,K)}static ClipFramesInPlace(E,Y,C,P){return M.ClipInPlace(E,Y,C,P,!0)}static ClipInPlace(E,Y,C,P){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4],m=Number.MAX_VALUE,u=-Number.MAX_VALUE;const T=E.targetedAnimations;for(let a=0;a<T.length;a++){const E=T[a],J=P?E.animation:E.animation.clone();K&&(J.createKeyForFrame(Y),J.createKeyForFrame(C));const t=J.getKeys(),p=[];let W=Number.MAX_VALUE;for(let P=0;P<t.length;P++){const E=t[P];if(!K&&P>=Y&&P<=C||K&&E.frame>=Y&&E.frame<=C){const Y={frame:E.frame,value:E.value.clone?E.value.clone():E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation,lockedTangent:E.lockedTangent};W===Number.MAX_VALUE&&(W=Y.frame),Y.frame-=W,p.push(Y)}}0!==p.length?(m>p[0].frame&&(m=p[0].frame),u<p[p.length-1].frame&&(u=p[p.length-1].frame),J.setKeys(p,!0),E.animation=J):(T.splice(a,1),a--)}return E._from=m,E._to=u,E}getClassName(){return"AnimationGroup"}toString(E){let Y="Name: "+this.name;return Y+=", type: "+this.getClassName(),E&&(Y+=", from: "+this._from,Y+=", to: "+this._to,Y+=", isStarted: "+this._isStarted,Y+=", speedRatio: "+this._speedRatio,Y+=", targetedAnimations length: "+this._targetedAnimations.length,Y+=", animatables length: "+this._animatables),Y}}}}]);