"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13222:(Y,j,X)=>{X.r(j),X.d(j,{AnimationGroup:()=>O,TargetedAnimation:()=>C});var u=X(12020),K=X(10752),U=X(10794),I=X(11056),y=X(12011),T=X(11062);class E{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Y,j,X,K){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=j,this._target=Y,this._scene=X,this._host=K,this._activeTargets=[],j._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===u.e.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=T.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Y={frame:0,value:this._minValue};this._keys.splice(0,0,Y)}if(this._target instanceof Array){let Y=0;for(const j of this._target)this._preparePath(j,Y),this._getOriginalValues(Y),Y++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const U=j.getEvents();U&&U.length>0&&U.forEach((Y=>{this._events.push(Y._clone())})),this._enableBlending=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Y){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const X=this._animation.targetPropertyPath;if(X.length>1){let u=Y;for(let Y=0;Y<X.length-1;Y++){const j=X[Y];if(u=u[j],void 0===u)throw new Error(`Invalid property (${j}) in property path (${X.join(".")})`)}this._targetPath=X[X.length-1],this._activeTargets[j]=u}else this._targetPath=X[0],this._activeTargets[j]=Y;if(void 0===this._activeTargets[j][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${X.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Y=0;for(const j of this._target)void 0!==this._originalValue[Y]&&this._setValue(j,this._activeTargets[Y],this._originalValue[Y],-1,Y),Y++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Y=0;Y<this._events.length;Y++)this._events[Y].isDone=!1}isStopped(){return this._stopped}dispose(){const Y=this._animation.runtimeAnimations.indexOf(this);Y>-1&&this._animation.runtimeAnimations.splice(Y,1)}setValue(Y,j){if(this._targetIsArray)for(let X=0;X<this._target.length;X++){const u=this._target[X];this._setValue(u,this._activeTargets[X],Y,j,X)}else this._setValue(this._target,this._directTarget,Y,j,0)}_getOriginalValues(){let Y,j=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=this._activeTargets[j];Y=X.getLocalMatrix&&"_matrix"===this._targetPath?X.getLocalMatrix():X[this._targetPath],Y&&Y.clone?this._originalValue[j]=Y.clone():this._originalValue[j]=Y}_registerTargetForLateAnimationBinding(Y,j){const X=Y.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(X),X._lateAnimationHolders||(X._lateAnimationHolders={}),X._lateAnimationHolders[Y.targetPath]||(X._lateAnimationHolders[Y.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:j}),Y.isAdditive?(X._lateAnimationHolders[Y.targetPath].additiveAnimations.push(Y),X._lateAnimationHolders[Y.targetPath].totalAdditiveWeight+=Y.weight):(X._lateAnimationHolders[Y.targetPath].animations.push(Y),X._lateAnimationHolders[Y.targetPath].totalWeight+=Y.weight)}_setValue(Y,j,X,K,U){if(this._currentActiveTarget=j,this._weight=K,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Y=j[this._targetPath];Y.clone?this._originalBlendValue=Y.clone():this._originalBlendValue=Y}this._originalBlendValue.m?u.e.AllowMatrixDecomposeForInterpolation?this._currentValue?T.d.DecomposeLerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=T.d.DecomposeLerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue?T.d.LerpToRef(this._originalBlendValue,X,this._blendingFactor,this._currentValue):this._currentValue=T.d.Lerp(this._originalBlendValue,X,this._blendingFactor):this._currentValue=u.e._UniversalLerp(this._originalBlendValue,X,this._blendingFactor);const K=Y&&Y.animationPropertiesOverride?Y.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=K}else this._currentValue?this._currentValue.p?this._currentValue.p(X):this._currentValue=X:null!==X&&void 0!==X&&X.clone?this._currentValue=X.clone():this._currentValue=X;-1!==K?this._registerTargetForLateAnimationBinding(this,this._originalValue[U]):this._animationState.loopMode===u.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[U],j[this._targetPath]):j[this._targetPath]=this._originalValue[U]+this._currentValue:j[this._targetPath]=this._currentValue,Y.vg&&Y.vg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Y){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const X=this._animation.getKeys();Y<X[0].frame?Y=X[0].frame:Y>X[X.length-1].frame&&(Y=X[X.length-1].frame);const u=this._events;if(u.length)for(let U=0;U<u.length;U++)u[U].onlyOnce||(u[U].isDone=u[U].frame<Y);this._currentFrame=Y;const K=this._animation._interpolate(Y,this._animationState);this.setValue(K,j)}_prepareForSpeedRatioChange(Y){const j=this._previousElapsedTime*(this._animation.framePerSecond*Y)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-j}animate(Y,j,X,K,U){let I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const y=this._animation,T=y.targetPropertyPath;if(!T||T.length<1)return this._stopped=!0,!1;let E=!0;(j<this._minFrame||j>this._maxFrame)&&(j=this._minFrame),(X<this._minFrame||X>this._maxFrame)&&(X=this._maxFrame);const e=X-j;let a,N=Y*(y.framePerSecond*U)/1e3+this._absoluteFrameOffset,d=0,i=!1;const M=K&&this._animationState.loopMode===u.e.ANIMATIONLOOPMODE_YOYO;if(M){const Y=(N-j)/e,X=Math.sin(Y*Math.PI);N=Math.abs(X)*e+j;const u=X>=0?1:-1;this._yoyoDirection!==u&&(i=!0),this._yoyoDirection=u}if(this._previousElapsedTime=Y,this._previousAbsoluteFrame=N,!K&&X>=j&&(N>=e&&U>0||N<=0&&U<0))E=!1,d=y._getKeyValue(this._maxValue);else if(!K&&j>=X&&(N<=e&&U<0||N>=0&&U>0))E=!1,d=y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==u.e.ANIMATIONLOOPMODE_CYCLE){const Y=X.toString()+j.toString();if(!this._offsetsCache[Y]){this._animationState.repeatCount=0,this._animationState.loopMode=u.e.ANIMATIONLOOPMODE_CYCLE;const K=y._interpolate(j,this._animationState),U=y._interpolate(X,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),y.dataType){case u.e.ANIMATIONTYPE_FLOAT:this._offsetsCache[Y]=U-K;break;case u.e.ANIMATIONTYPE_QUATERNION:case u.e.ANIMATIONTYPE_VECTOR3:case u.e.ANIMATIONTYPE_VECTOR2:case u.e.ANIMATIONTYPE_SIZE:case u.e.ANIMATIONTYPE_COLOR3:this._offsetsCache[Y]=U.Ec(K)}this._highLimitsCache[Y]=U}d=this._highLimitsCache[Y],a=this._offsetsCache[Y]}if(void 0===a)switch(y.dataType){case u.e.ANIMATIONTYPE_FLOAT:a=0;break;case u.e.ANIMATIONTYPE_QUATERNION:a=u.j;break;case u.e.ANIMATIONTYPE_VECTOR3:a=u.r;break;case u.e.ANIMATIONTYPE_VECTOR2:a=u.p;break;case u.e.ANIMATIONTYPE_SIZE:a=u.n;break;case u.e.ANIMATIONTYPE_COLOR3:a=u.g;break;case u.e.ANIMATIONTYPE_COLOR4:a=u.h}let R;if(this._host&&this._host.syncRoot){const Y=this._host.syncRoot;R=j+e*((Y.masterFrame-Y.fromFrame)/(Y.toFrame-Y.fromFrame))}else R=N>0&&j>X||N<0&&j<X?E&&0!==e?X+N%e:j:E&&0!==e?j+N%e:X;const C=this._events;if(!M&&(U>0&&this.currentFrame>R||U<0&&this.currentFrame<R)||M&&i){this._onLoop();for(let Y=0;Y<C.length;Y++)C[Y].onlyOnce||(C[Y].isDone=!1);this._animationState.key=U>0?0:y.getKeys().length-1}this._currentFrame=R,this._animationState.repeatCount=0===e?0:N/e|0,this._animationState.highLimitValue=d,this._animationState.offsetValue=a;const O=y._interpolate(R,this._animationState);if(this.setValue(O,I),C.length)for(let u=0;u<C.length;u++)if(e>=0&&R>=C[u].frame&&C[u].frame>=j||e<0&&R<=C[u].frame&&C[u].frame<=j){const Y=C[u];Y.isDone||(Y.onlyOnce&&(C.splice(u,1),u--),Y.isDone=!0,Y.action(R))}return E||(this._stopped=!0),E}}var e=X(10777);class a{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Y){this._weight=-1!==Y?Math.min(Math.max(Y,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Y){for(let j=0;j<this._runtimeAnimations.length;j++){this._runtimeAnimations[j]._prepareForSpeedRatioChange(Y)}this._speedRatio=Y,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Y,j){let X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,U=arguments.length>4&&void 0!==arguments[4]&&arguments[4],I=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,y=arguments.length>6?arguments[6]:void 0,T=arguments.length>7?arguments[7]:void 0,E=arguments.length>8?arguments[8]:void 0,e=arguments.length>9&&void 0!==arguments[9]&&arguments[9],a=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=j,this.fromFrame=X,this.toFrame=u,this.loopAnimation=U,this.onAnimationEnd=y,this.onAnimationLoop=E,this.isAdditive=e,this.playOrder=a,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Id=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new K.c,this.onAnimationLoopObservable=new K.c,this._scene=Y,T&&this.appendAnimations(j,T),this._speedRatio=I,Y._activeAnimatables.push(this)}syncWith(Y){if(this._syncRoot=Y,Y){const Y=this._scene._activeAnimatables.indexOf(this);Y>-1&&(this._scene._activeAnimatables.splice(Y,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Y,j){for(let X=0;X<j.length;X++){const u=j[X],K=new E(Y,u,this._scene,this);K._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(K)}}getAnimationByTargetProperty(Y){const j=this._runtimeAnimations;for(let X=0;X<j.length;X++)if(j[X].animation.targetProperty===Y)return j[X].animation;return null}getRuntimeAnimationByTargetProperty(Y){const j=this._runtimeAnimations;for(let X=0;X<j.length;X++)if(j[X].animation.targetProperty===Y)return j[X];return null}reset(){const Y=this._runtimeAnimations;for(let j=0;j<Y.length;j++)Y[j].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Y){const j=this._runtimeAnimations;for(let X=0;X<j.length;X++)j[X].animation.enableBlending=!0,j[X].animation.blendingSpeed=Y}disableBlending(){const Y=this._runtimeAnimations;for(let j=0;j<Y.length;j++)Y[j].animation.enableBlending=!1}goToFrame(Y){const j=this._runtimeAnimations;if(j[0]){const X=j[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??j[0].currentFrame;const u=0===this.speedRatio?0:(Y-this._frameToSyncFromJump)/X*1e3/this.speedRatio;this._manualJumpDelay=-u}for(let X=0;X<j.length;X++)j[X].goToFrame(Y,this._weight);this._goToFrame=Y}get paused(){return this.Id}pause(){this.Id||(this.Id=!0)}restart(){this.Id=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Y,j){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Y||j){const K=this._scene._activeAnimatables.indexOf(this);if(K>-1){const U=this._runtimeAnimations;for(let X=U.length-1;X>=0;X--){const u=U[X];Y&&u.animation.name!=Y||(j&&!j(u.target)||(u.dispose(),U.splice(X,1)))}0==U.length&&(X||this._scene._activeAnimatables.splice(K,1),u||this._raiseOnAnimationEnd())}}else{const Y=this._scene._activeAnimatables.indexOf(this);if(Y>-1){X||this._scene._activeAnimatables.splice(Y,1);const j=this._runtimeAnimations;for(let Y=0;Y<j.length;Y++)j[Y].dispose();this._runtimeAnimations.length=0,u||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((Y=>{this.onAnimationEndObservable.add((()=>{Y(this)}),void 0,void 0,this,!0)}))}_animate(Y){if(this.Id)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Y),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Y,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Y-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let j=!1;const X=this._runtimeAnimations;let u;for(u=0;u<X.length;u++){const K=X[u].animate(Y-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);j=j||K}if(this.animationStarted=j,!j){if(this.disposeOnEnd)for(u=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(u,1),u=0;u<X.length;u++)X[u].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return j}}function N(Y){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return Y.originalValue;let j=1;const X=T.k.hb[0],u=T.k.hb[1],K=T.k.Quaternion[0];let U=0;const I=Y.animations[0],y=Y.originalValue;let E=1,e=!1;if(Y.totalWeight<1)E=1-Y.totalWeight,y.decompose(u,K,X);else{if(U=1,j=Y.totalWeight,E=I.weight/j,1==E){if(!Y.totalAdditiveWeight)return I.currentValue;e=!0}I.currentValue.decompose(u,K,X)}if(!e){u.scaleInPlace(E),X.scaleInPlace(E),K.scaleInPlace(E);for(let I=U;I<Y.animations.length;I++){const U=Y.animations[I];if(0===U.weight)continue;E=U.weight/j;const y=T.k.hb[2],e=T.k.hb[3],a=T.k.Quaternion[1];U.currentValue.decompose(e,a,y),e.scaleAndAddToRef(E,u),a.scaleAndAddToRef(T.g.Dot(K,a)>0?E:-E,K),y.scaleAndAddToRef(E,X)}K.normalize()}for(let N=0;N<Y.additiveAnimations.length;N++){const j=Y.additiveAnimations[N];if(0===j.weight)continue;const U=T.k.hb[2],I=T.k.hb[3],y=T.k.Quaternion[1];j.currentValue.decompose(I,y,U),I.multiplyToRef(u,I),T.m.LerpToRef(u,I,j.weight,u),K.multiplyToRef(y,y),T.g.SlerpToRef(K,y,j.weight,K),U.scaleAndAddToRef(j.weight,X)}const a=I?I._animationState.workValue:T.k.Matrix[0].clone();return T.d.ComposeToRef(u,K,X,a),a}function d(Y,j){if(0===Y.totalWeight&&0===Y.totalAdditiveWeight)return j;const X=Y.animations[0],u=Y.originalValue;let K=j;if(0===Y.totalWeight&&Y.totalAdditiveWeight>0)K.p(u);else if(1===Y.animations.length){if(T.g.SlerpToRef(u,X.currentValue,Math.min(1,Y.totalWeight),K),0===Y.totalAdditiveWeight)return K}else if(Y.animations.length>1){let X,U,I=1;if(Y.totalWeight<1){const j=1-Y.totalWeight;X=[],U=[],X.push(u),U.push(j)}else{if(2===Y.animations.length&&(T.g.SlerpToRef(Y.animations[0].currentValue,Y.animations[1].currentValue,Y.animations[1].weight/Y.totalWeight,j),0===Y.totalAdditiveWeight))return j;X=[],U=[],I=Y.totalWeight}for(let j=0;j<Y.animations.length;j++){const u=Y.animations[j];X.push(u.currentValue),U.push(u.weight/I)}let y=0;for(let Y=0;Y<X.length;)Y?(y+=U[Y],T.g.SlerpToRef(K,X[Y],U[Y]/y,K),Y++):(T.g.SlerpToRef(X[Y],X[Y+1],U[Y+1]/(U[Y]+U[Y+1]),j),K=j,y=U[Y]+U[Y+1],Y+=2)}for(let U=0;U<Y.additiveAnimations.length;U++){const j=Y.additiveAnimations[U];0!==j.weight&&(K.multiplyToRef(j.currentValue,T.k.Quaternion[0]),T.g.SlerpToRef(K,T.k.Quaternion[0],j.weight,K))}return K}var i,M,R=X(11051);i=R.b,(M=y.d)&&(M.prototype.copyAnimationRange=function(Y,j,X){let K=arguments.length>3&&void 0!==arguments[3]&&arguments[3],U=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new u.e(this.name,"_matrix",Y.animations[0].framePerSecond,u.e.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const I=Y.animations[0].getRange(j);if(!I)return!1;const y=I.from,T=I.to,E=Y.animations[0].getKeys(),e=Y.length,a=Y.getParent(),N=this.getParent(),d=K&&a&&e&&this.length&&e!==this.length,i=d&&N&&a?N.length/a.length:1,M=K&&!N&&U&&(1!==U.x||1!==U.y||1!==U.z),R=this.animations[0].getKeys();let C,O,P;for(let u=0,Q=E.length;u<Q;u++)C=E[u],C.frame>=y&&C.frame<=T&&(K?(P=C.value.clone(),d?(O=P.getTranslation(),P.setTranslation(O.scaleInPlace(i))):M&&U?(O=P.getTranslation(),P.setTranslation(O.multiplyInPlace(U))):P=C.value):P=C.value,R.push({frame:C.frame+X,value:P}));return this.animations[0].createRange(j,y+X,T+X),!0}),i&&(i.prototype._animate=function(Y){if(!this.animationsEnabled)return;const j=e.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=j}this.deltaTime=void 0!==Y?Y:this.useConstantAnimationDeltaTime?16:(j-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=j;const X=this._activeAnimatables;if(0===X.length)return;this._animationTime+=this.deltaTime;const K=this._animationTime;for(let u=0;u<X.length;u++){const Y=X[u];!Y._animate(K)&&Y.disposeOnEnd&&u--}!function(Y){if(Y._registeredForLateAnimationBindings.length){for(let j=0;j<Y._registeredForLateAnimationBindings.length;j++){const X=Y._registeredForLateAnimationBindings.data[j];for(const Y in X._lateAnimationHolders){const j=X._lateAnimationHolders[Y],K=j.animations[0],U=j.originalValue;if(void 0===U||null===U)continue;const I=u.e.AllowMatrixDecomposeForInterpolation&&U.m;let y=X[Y];if(I)y=N(j);else if(void 0!==U.w)y=d(j,y||T.g.Identity());else{let Y=0,X=1;const I=K&&K._animationState.loopMode===u.e.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(j.totalWeight<1)y=I?U.clone?U.clone():U:K&&U.scale?U.scale(1-j.totalWeight):K?U*(1-j.totalWeight):U.clone?U.clone():U;else if(K){X=j.totalWeight;const u=K.weight/X;y=1!==u?K.currentValue.scale?K.currentValue.scale(u):K.currentValue*u:K.currentValue,I&&(y.addToRef?y.addToRef(U,y):y+=U),Y=1}for(let u=Y;u<j.animations.length;u++){const Y=j.animations[u],K=Y.weight/X;K&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(K,y):y+=Y.currentValue*K)}for(let u=0;u<j.additiveAnimations.length;u++){const Y=j.additiveAnimations[u],X=Y.weight;X&&(Y.currentValue.scaleAndAddToRef?Y.currentValue.scaleAndAddToRef(X,y):y+=Y.currentValue*X)}}X[Y]=y}X._lateAnimationHolders={}}Y._registeredForLateAnimationBindings.reset()}}(this)},i.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Y,j)=>Y.playOrder-j.playOrder))},i.prototype.beginWeightedAnimation=function(Y,j,X){let u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,K=arguments.length>4?arguments[4]:void 0,U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,I=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,T=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,e=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const a=this.beginAnimation(Y,j,X,K,U,I,y,!1,T,E,e);return a.weight=u,a},i.prototype.beginAnimation=function(Y,j,X,u){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,U=arguments.length>5?arguments[5]:void 0,I=arguments.length>6?arguments[6]:void 0,y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],T=arguments.length>8?arguments[8]:void 0,E=arguments.length>9?arguments[9]:void 0,e=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(K<0){const Y=j;j=X,X=Y,K=-K}j>X&&(K=-K),y&&this.stopAnimation(Y,void 0,T),I||(I=new a(this,Y,j,X,u,K,U,void 0,E,e));const N=!T||T(Y);if(Y.animations&&N&&I.appendAnimations(Y,Y.animations),Y.getAnimatables){const e=Y.getAnimatables();for(let Y=0;Y<e.length;Y++)this.beginAnimation(e[Y],j,X,u,K,U,I,y,T,E)}return I.reset(),I},i.prototype.beginHierarchyAnimation=function(Y,j,X,u,K){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,I=arguments.length>6?arguments[6]:void 0,y=arguments.length>7?arguments[7]:void 0,T=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],E=arguments.length>9?arguments[9]:void 0,e=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const a=Y.getDescendants(j),N=[];N.push(this.beginAnimation(Y,X,u,K,U,I,y,T,E,void 0,e));for(const d of a)N.push(this.beginAnimation(d,X,u,K,U,I,y,T,E,void 0,e));return N},i.prototype.beginDirectAnimation=function(Y,j,X,u,K){let U=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(U<0){const Y=X;X=u,u=Y,U=-U}return X>u&&(U=-U),new a(this,Y,X,u,K,U,arguments.length>6?arguments[6]:void 0,j,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},i.prototype.beginDirectHierarchyAnimation=function(Y,j,X,u,K,U,I,y,T){let E=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const e=Y.getDescendants(j),a=[];a.push(this.beginDirectAnimation(Y,X,u,K,U,I,y,T,E));for(const N of e)a.push(this.beginDirectAnimation(N,X,u,K,U,I,y,T,E));return a},i.prototype.getAnimatableByTarget=function(Y){for(let j=0;j<this._activeAnimatables.length;j++)if(this._activeAnimatables[j].target===Y)return this._activeAnimatables[j];return null},i.prototype.getAllAnimatablesByTarget=function(Y){const j=[];for(let X=0;X<this._activeAnimatables.length;X++)this._activeAnimatables[X].target===Y&&j.push(this._activeAnimatables[X]);return j},i.prototype.stopAnimation=function(Y,j,X){const u=this.getAllAnimatablesByTarget(Y);for(const K of u)K.stop(j,X)},i.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Y=0;Y<this._activeAnimatables.length;Y++)this._activeAnimatables[Y].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Y of this.animationGroups)Y.stop()});class C{getClassName(){return"TargetedAnimation"}serialize(){const Y={};return Y.animation=this.animation.serialize(),Y.targetId=this.target.id,Y}}class O{get mask(){return this._mask}set mask(Y){this._mask!==Y&&(this._mask=Y,this.syncWithMask(!0))}syncWithMask(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Y){this._numActiveAnimatables=0;for(let Y=0;Y<this._animatables.length;++Y){const j=this._animatables[Y];!this.mask||this.mask.disabled||this.mask.retainsTarget(j.target.name)?(this._numActiveAnimatables++,j.paused&&j.restart()):j.paused||j.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Y=0;Y<this._animatables.length;++Y){const j=this._animatables[Y];this.mask.retainsTarget(j.target.name)||(j.stop(),this._animatables.splice(Y,1),--Y)}for(let Y=0;Y<this._targetedAnimations.length;Y++){const j=this._targetedAnimations[Y];this.mask.retainsTarget(j.target.name)||(this._targetedAnimations.splice(Y,1),--Y)}}}get from(){return this._from}set from(Y){if(this._from!==Y){this._from=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].fromFrame=this._from}}}get to(){return this._to}set to(Y){if(this._to!==Y){this._to=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Y){if(this._speedRatio!==Y){this._speedRatio=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Y){if(this._loopAnimation!==Y){this._loopAnimation=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Y){if(this._isAdditive!==Y){this._isAdditive=Y;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Y){this._weight!==Y&&(this._weight=Y,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Y){if(this._playOrder!==Y&&(this._playOrder=Y,this._animatables.length>0)){for(let Y=0;Y<this._animatables.length;Y++)this._animatables[Y].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Y){if(this._enableBlending!==Y&&(this._enableBlending=Y,null!==Y))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.enableBlending=Y}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Y){if(this._blendingSpeed!==Y&&(this._blendingSpeed=Y,null!==Y))for(let j=0;j<this._targetedAnimations.length;++j)this._targetedAnimations[j].animation.blendingSpeed=Y}getLength(Y,j){Y=Y??this._from;return((j=j??this._to)-Y)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Y){let j=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],X=arguments.length>2&&void 0!==arguments[2]&&arguments[2],u=arguments.length>3?arguments[3]:void 0;if(0===Y.length)return null;u=u??Y[0].weight;let K=Number.MAX_VALUE,U=-Number.MAX_VALUE;if(X)for(const y of Y)y.from<K&&(K=y.from),y.to>U&&(U=y.to);const I=new O(Y[0].name+"_merged",Y[0]._scene,u);for(const y of Y){X&&y.normalize(K,U);for(const Y of y.targetedAnimations)I.addTargetedAnimation(Y.animation,Y.target);j&&y.dispose()}return I}constructor(Y){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,X=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,u=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Y,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new K.c,this.onAnimationLoopObservable=new K.c,this.onAnimationGroupLoopObservable=new K.c,this.onAnimationGroupEndObservable=new K.c,this.onAnimationGroupPauseObservable=new K.c,this.onAnimationGroupPlayObservable=new K.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=j||U.c.LastCreatedScene,this._weight=X,this._playOrder=u,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Y,j){const X=new C;X.animation=Y,X.target=j;const u=Y.getKeys();return this._from>u[0].frame&&(this._from=u[0].frame),this._to<u[u.length-1].frame&&(this._to=u[u.length-1].frame),null!==this._enableBlending&&(Y.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Y.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(X),this._shouldStart=!0,X}removeTargetedAnimation(Y){for(let j=this._targetedAnimations.length-1;j>-1;j--){this._targetedAnimations[j].animation===Y&&this._targetedAnimations.splice(j,1)}}normalize(){let Y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Y&&(Y=this._from),null==j&&(j=this._to);for(let X=0;X<this._targetedAnimations.length;X++){const u=this._targetedAnimations[X].animation.getKeys(),K=u[0],U=u[u.length-1];if(K.frame>Y){const j={frame:Y,value:K.value,inTangent:K.inTangent,outTangent:K.outTangent,interpolation:K.interpolation};u.splice(0,0,j)}if(U.frame<j){const Y={frame:j,value:U.value,inTangent:U.inTangent,outTangent:U.outTangent,interpolation:U.interpolation};u.push(Y)}}return this._from=Y,this._to=j,this}_processLoop(Y,j,X){Y.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(j),this._animationLoopFlags[X]||(this._animationLoopFlags[X]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0],j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,X=arguments.length>2?arguments[2]:void 0,u=arguments.length>3?arguments[3]:void 0,K=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Y,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let U=0;U<this._targetedAnimations.length;U++){const I=this._targetedAnimations[U],y=this._scene.beginDirectAnimation(I.target,[I.animation],void 0!==X?X:this._from,void 0!==u?u:this._to,Y,j,void 0,void 0,void 0!==K?K:this._isAdditive);y.weight=this._weight,y.playOrder=this._playOrder,y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(I),this._checkAnimationGroupEnded(y)},this._processLoop(y,I,U),this._animatables.push(y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=j,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Y){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Y&&(this.loopAnimation=Y),this.restart()):(this.stop(),this.start(Y,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].reset()}return this}restart(){if(!this._isStarted)return this;for(let Y=0;Y<this._animatables.length;Y++){this._animatables[Y].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Y=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const j=this._animatables.slice();for(let u=0;u<j.length;u++)j[u].stop(void 0,void 0,!0,Y);let X=0;for(let u=0;u<this._scene._activeAnimatables.length;u++){const j=this._scene._activeAnimatables[u];j._runtimeAnimations.length>0?this._scene._activeAnimatables[X++]=j:Y&&this._checkAnimationGroupEnded(j,Y)}return this._scene._activeAnimatables.length=X,this._isStarted=!1,this}setWeightForAllAnimatables(Y){for(let j=0;j<this._animatables.length;j++){this._animatables[j].weight=Y}return this}syncAllAnimationsWith(Y){for(let j=0;j<this._animatables.length;j++){this._animatables[j].syncWith(Y)}return this}goToFrame(Y){if(!this._isStarted)return this;for(let j=0;j<this._animatables.length;j++){this._animatables[j].goToFrame(Y)}return this}getCurrentFrame(){var Y;return(null===(Y=this.animatables[0])||void 0===Y?void 0:Y.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Y=this._scene.animationGroups.indexOf(this);if(Y>-1&&this._scene.animationGroups.splice(Y,1),this._parentContainer){const Y=this._parentContainer.animationGroups.indexOf(this);Y>-1&&this._parentContainer.animationGroups.splice(Y,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Y){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const X=this._animatables.indexOf(Y);X>-1&&this._animatables.splice(X,1),0===this._animatables.length&&(this._isStarted=!1,j||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(Y,j){let X=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const u=new O(Y||this.name,this._scene,this._weight,this._playOrder);u._from=this.from,u._to=this.to,u._speedRatio=this.speedRatio,u._loopAnimation=this.loopAnimation,u._isAdditive=this.isAdditive,u._enableBlending=this.enableBlending,u._blendingSpeed=this.blendingSpeed,u.metadata=this.metadata,u.mask=this.mask;for(const K of this._targetedAnimations)u.addTargetedAnimation(X?K.animation.clone():K.animation,j?j(K.target):K.target);return u}serialize(){const Y={};Y.name=this.name,Y.from=this.from,Y.to=this.to,Y.speedRatio=this.speedRatio,Y.loopAnimation=this.loopAnimation,Y.isAdditive=this.isAdditive,Y.weight=this.weight,Y.playOrder=this.playOrder,Y.enableBlending=this.enableBlending,Y.blendingSpeed=this.blendingSpeed,Y.targetedAnimations=[];for(let j=0;j<this.targetedAnimations.length;j++){const X=this.targetedAnimations[j];Y.targetedAnimations[j]=X.serialize()}return I.b&&I.b.HasTags(this)&&(Y.tags=I.b.GetTags(this)),this.metadata&&(Y.metadata=this.metadata),Y}static Parse(Y,j){const X=new O(Y.name,j,Y.weight,Y.playOrder);for(let K=0;K<Y.targetedAnimations.length;K++){const U=Y.targetedAnimations[K],I=u.e.Parse(U.animation),y=U.targetId;if("influence"===U.animation.property){const Y=j.getMorphTargetById(y);Y&&X.addTargetedAnimation(I,Y)}else{const Y=j.getNodeById(y);null!=Y&&X.addTargetedAnimation(I,Y)}}return I.b&&I.b.AddTagsTo(X,Y.tags),null!==Y.from&&null!==Y.to&&X.normalize(Y.from,Y.to),void 0!==Y.speedRatio&&(X._speedRatio=Y.speedRatio),void 0!==Y.loopAnimation&&(X._loopAnimation=Y.loopAnimation),void 0!==Y.isAdditive&&(X._isAdditive=Y.isAdditive),void 0!==Y.weight&&(X._weight=Y.weight),void 0!==Y.playOrder&&(X._playOrder=Y.playOrder),void 0!==Y.enableBlending&&(X._enableBlending=Y.enableBlending),void 0!==Y.blendingSpeed&&(X._blendingSpeed=Y.blendingSpeed),void 0!==Y.metadata&&(X.metadata=Y.metadata),X}static MakeAnimationAdditive(Y,j,X){let K;K="object"===typeof j?j:{referenceFrame:j,range:X,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let U=Y;K.cloneOriginalAnimationGroup&&(U=Y.clone(K.clonedAnimationGroupName||U.name));const I=U.targetedAnimations;for(let y=0;y<I.length;y++){const Y=I[y];Y.animation=u.e.MakeAnimationAdditive(Y.animation,K)}if(U.isAdditive=!0,K.clipKeys){let Y=Number.MAX_VALUE,j=-Number.MAX_VALUE;const X=U.targetedAnimations;for(let u=0;u<X.length;u++){const K=X[u].animation.getKeys();Y>K[0].frame&&(Y=K[0].frame),j<K[K.length-1].frame&&(j=K[K.length-1].frame)}U._from=Y,U._to=j}return U}static ClipKeys(Y,j,X,u,K){const U=Y.clone(u||Y.name);return O.ClipKeysInPlace(U,j,X,K)}static ClipKeysInPlace(Y,j,X,u){return O.ClipInPlace(Y,j,X,u,!1)}static ClipFrames(Y,j,X,u,K){const U=Y.clone(u||Y.name);return O.ClipFramesInPlace(U,j,X,K)}static ClipFramesInPlace(Y,j,X,u){return O.ClipInPlace(Y,j,X,u,!0)}static ClipInPlace(Y,j,X,u){let K=arguments.length>4&&void 0!==arguments[4]&&arguments[4],U=Number.MAX_VALUE,I=-Number.MAX_VALUE;const y=Y.targetedAnimations;for(let T=0;T<y.length;T++){const Y=y[T],E=u?Y.animation:Y.animation.clone();K&&(E.createKeyForFrame(j),E.createKeyForFrame(X));const e=E.getKeys(),a=[];let N=Number.MAX_VALUE;for(let u=0;u<e.length;u++){const Y=e[u];if(!K&&u>=j&&u<=X||K&&Y.frame>=j&&Y.frame<=X){const j={frame:Y.frame,value:Y.value.clone?Y.value.clone():Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation,lockedTangent:Y.lockedTangent};N===Number.MAX_VALUE&&(N=j.frame),j.frame-=N,a.push(j)}}0!==a.length?(U>a[0].frame&&(U=a[0].frame),I<a[a.length-1].frame&&(I=a[a.length-1].frame),E.setKeys(a,!0),Y.animation=E):(y.splice(T,1),T--)}return Y._from=U,Y._to=I,Y}getClassName(){return"AnimationGroup"}toString(Y){let j="Name: "+this.name;return j+=", type: "+this.getClassName(),Y&&(j+=", from: "+this._from,j+=", to: "+this._to,j+=", isStarted: "+this._isStarted,j+=", speedRatio: "+this._speedRatio,j+=", targetedAnimations length: "+this._targetedAnimations.length,j+=", animatables length: "+this._animatables),j}}}}]);