"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13222:(A,e,E)=>{E.r(e),E.d(e,{AnimationGroup:()=>I,TargetedAnimation:()=>z});var Q=E(11977),x=E(10717),t=E(10754),H=E(11023),h=E(11969),Y=E(11030);class F{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(A,e,E,x){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=e,this._target=A,this._scene=E,this._host=x,this._activeTargets=[],e._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Q.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Y.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const A={frame:0,value:this._minValue};this._keys.splice(0,0,A)}if(this._target instanceof Array){let A=0;for(const e of this._target)this._preparePath(e,A),this._getOriginalValues(A),A++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const t=e.getEvents();t&&t.length>0&&t.forEach((A=>{this._events.push(A._clone())})),this._enableBlending=A&&A.animationPropertiesOverride?A.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(A){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const E=this._animation.targetPropertyPath;if(E.length>1){let Q=A;for(let A=0;A<E.length-1;A++){const e=E[A];if(Q=Q[e],void 0===Q)throw new Error(`Invalid property (${e}) in property path (${E.join(".")})`)}this._targetPath=E[E.length-1],this._activeTargets[e]=Q}else this._targetPath=E[0],this._activeTargets[e]=A;if(void 0===this._activeTargets[e][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${E.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let A=0;for(const e of this._target)void 0!==this._originalValue[A]&&this._setValue(e,this._activeTargets[A],this._originalValue[A],-1,A),A++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let A=0;A<this._events.length;A++)this._events[A].isDone=!1}isStopped(){return this._stopped}dispose(){const A=this._animation.runtimeAnimations.indexOf(this);A>-1&&this._animation.runtimeAnimations.splice(A,1)}setValue(A,e){if(this._targetIsArray)for(let E=0;E<this._target.length;E++){const Q=this._target[E];this._setValue(Q,this._activeTargets[E],A,e,E)}else this._setValue(this._target,this._directTarget,A,e,0)}_getOriginalValues(){let A,e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=this._activeTargets[e];A=E.getLocalMatrix&&"_matrix"===this._targetPath?E.getLocalMatrix():E[this._targetPath],A&&A.clone?this._originalValue[e]=A.clone():this._originalValue[e]=A}_registerTargetForLateAnimationBinding(A,e){const E=A.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(E),E._lateAnimationHolders||(E._lateAnimationHolders={}),E._lateAnimationHolders[A.targetPath]||(E._lateAnimationHolders[A.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:e}),A.isAdditive?(E._lateAnimationHolders[A.targetPath].additiveAnimations.push(A),E._lateAnimationHolders[A.targetPath].totalAdditiveWeight+=A.weight):(E._lateAnimationHolders[A.targetPath].animations.push(A),E._lateAnimationHolders[A.targetPath].totalWeight+=A.weight)}_setValue(A,e,E,x,t){if(this._currentActiveTarget=e,this._weight=x,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const A=e[this._targetPath];A.clone?this._originalBlendValue=A.clone():this._originalBlendValue=A}this._originalBlendValue.m?Q.c.AllowMatrixDecomposeForInterpolation?this._currentValue?Y.e.DecomposeLerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=Y.e.DecomposeLerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue?Y.e.LerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=Y.e.Lerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue=Q.c._UniversalLerp(this._originalBlendValue,E,this._blendingFactor);const x=A&&A.animationPropertiesOverride?A.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=x}else this._currentValue?this._currentValue.p?this._currentValue.p(E):this._currentValue=E:null!==E&&void 0!==E&&E.clone?this._currentValue=E.clone():this._currentValue=E;-1!==x?this._registerTargetForLateAnimationBinding(this,this._originalValue[t]):this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[t],e[this._targetPath]):e[this._targetPath]=this._originalValue[t]+this._currentValue:e[this._targetPath]=this._currentValue,A.Ug&&A.Ug(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(A){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const E=this._animation.getKeys();A<E[0].frame?A=E[0].frame:A>E[E.length-1].frame&&(A=E[E.length-1].frame);const Q=this._events;if(Q.length)for(let t=0;t<Q.length;t++)Q[t].onlyOnce||(Q[t].isDone=Q[t].frame<A);this._currentFrame=A;const x=this._animation._interpolate(A,this._animationState);this.setValue(x,e)}_prepareForSpeedRatioChange(A){const e=this._previousElapsedTime*(this._animation.framePerSecond*A)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-e}animate(A,e,E,x,t){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const h=this._animation,Y=h.targetPropertyPath;if(!Y||Y.length<1)return this._stopped=!0,!1;let F=!0;(e<this._minFrame||e>this._maxFrame)&&(e=this._minFrame),(E<this._minFrame||E>this._maxFrame)&&(E=this._maxFrame);const w=E-e;let r,S=A*(h.framePerSecond*t)/1e3+this._absoluteFrameOffset,v=0,c=!1;const D=x&&this._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_YOYO;if(D){const A=(S-e)/w,E=Math.sin(A*Math.PI);S=Math.abs(E)*w+e;const Q=E>=0?1:-1;this._yoyoDirection!==Q&&(c=!0),this._yoyoDirection=Q}if(this._previousElapsedTime=A,this._previousAbsoluteFrame=S,!x&&E>=e&&(S>=w&&t>0||S<=0&&t<0))F=!1,v=h._getKeyValue(this._maxValue);else if(!x&&e>=E&&(S<=w&&t<0||S>=0&&t>0))F=!1,v=h._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Q.c.ANIMATIONLOOPMODE_CYCLE){const A=E.toString()+e.toString();if(!this._offsetsCache[A]){this._animationState.repeatCount=0,this._animationState.loopMode=Q.c.ANIMATIONLOOPMODE_CYCLE;const x=h._interpolate(e,this._animationState),t=h._interpolate(E,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),h.dataType){case Q.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[A]=t-x;break;case Q.c.ANIMATIONTYPE_QUATERNION:case Q.c.ANIMATIONTYPE_VECTOR3:case Q.c.ANIMATIONTYPE_VECTOR2:case Q.c.ANIMATIONTYPE_SIZE:case Q.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[A]=t.Dd(x)}this._highLimitsCache[A]=t}v=this._highLimitsCache[A],r=this._offsetsCache[A]}if(void 0===r)switch(h.dataType){case Q.c.ANIMATIONTYPE_FLOAT:r=0;break;case Q.c.ANIMATIONTYPE_QUATERNION:r=Q.j;break;case Q.c.ANIMATIONTYPE_VECTOR3:r=Q.q;break;case Q.c.ANIMATIONTYPE_VECTOR2:r=Q.o;break;case Q.c.ANIMATIONTYPE_SIZE:r=Q.m;break;case Q.c.ANIMATIONTYPE_COLOR3:r=Q.g;break;case Q.c.ANIMATIONTYPE_COLOR4:r=Q.i}let a;if(this._host&&this._host.syncRoot){const A=this._host.syncRoot;a=e+w*((A.masterFrame-A.fromFrame)/(A.toFrame-A.fromFrame))}else a=S>0&&e>E||S<0&&e<E?F&&0!==w?E+S%w:e:F&&0!==w?e+S%w:E;const z=this._events;if(!D&&(t>0&&this.currentFrame>a||t<0&&this.currentFrame<a)||D&&c){this._onLoop();for(let A=0;A<z.length;A++)z[A].onlyOnce||(z[A].isDone=!1);this._animationState.key=t>0?0:h.getKeys().length-1}this._currentFrame=a,this._animationState.repeatCount=0===w?0:S/w|0,this._animationState.highLimitValue=v,this._animationState.offsetValue=r;const I=h._interpolate(a,this._animationState);if(this.setValue(I,H),z.length)for(let Q=0;Q<z.length;Q++)if(w>=0&&a>=z[Q].frame&&z[Q].frame>=e||w<0&&a<=z[Q].frame&&z[Q].frame<=e){const A=z[Q];A.isDone||(A.onlyOnce&&(z.splice(Q,1),Q--),A.isDone=!0,A.action(a))}return F||(this._stopped=!0),F}}var w=E(10739);class r{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(A){this._weight=-1!==A?Math.min(Math.max(A,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(A){for(let e=0;e<this._runtimeAnimations.length;e++){this._runtimeAnimations[e]._prepareForSpeedRatioChange(A)}this._speedRatio=A,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(A,e){let E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,t=arguments.length>4&&void 0!==arguments[4]&&arguments[4],H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,h=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,F=arguments.length>8?arguments[8]:void 0,w=arguments.length>9&&void 0!==arguments[9]&&arguments[9],r=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=e,this.fromFrame=E,this.toFrame=Q,this.loopAnimation=t,this.onAnimationEnd=h,this.onAnimationLoop=F,this.isAdditive=w,this.playOrder=r,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.he=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new x.c,this.onAnimationLoopObservable=new x.c,this._scene=A,Y&&this.appendAnimations(e,Y),this._speedRatio=H,A._activeAnimatables.push(this)}syncWith(A){if(this._syncRoot=A,A){const A=this._scene._activeAnimatables.indexOf(this);A>-1&&(this._scene._activeAnimatables.splice(A,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(A,e){for(let E=0;E<e.length;E++){const Q=e[E],x=new F(A,Q,this._scene,this);x._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(x)}}getAnimationByTargetProperty(A){const e=this._runtimeAnimations;for(let E=0;E<e.length;E++)if(e[E].animation.targetProperty===A)return e[E].animation;return null}getRuntimeAnimationByTargetProperty(A){const e=this._runtimeAnimations;for(let E=0;E<e.length;E++)if(e[E].animation.targetProperty===A)return e[E];return null}reset(){const A=this._runtimeAnimations;for(let e=0;e<A.length;e++)A[e].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(A){const e=this._runtimeAnimations;for(let E=0;E<e.length;E++)e[E].animation.enableBlending=!0,e[E].animation.blendingSpeed=A}disableBlending(){const A=this._runtimeAnimations;for(let e=0;e<A.length;e++)A[e].animation.enableBlending=!1}goToFrame(A){const e=this._runtimeAnimations;if(e[0]){const E=e[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??e[0].currentFrame;const Q=0===this.speedRatio?0:(A-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-Q}for(let E=0;E<e.length;E++)e[E].goToFrame(A,this._weight);this._goToFrame=A}get paused(){return this.he}pause(){this.he||(this.he=!0)}restart(){this.he=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(A,e){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(A||e){const x=this._scene._activeAnimatables.indexOf(this);if(x>-1){const t=this._runtimeAnimations;for(let E=t.length-1;E>=0;E--){const Q=t[E];A&&Q.animation.name!=A||(e&&!e(Q.target)||(Q.dispose(),t.splice(E,1)))}0==t.length&&(E||this._scene._activeAnimatables.splice(x,1),Q||this._raiseOnAnimationEnd())}}else{const A=this._scene._activeAnimatables.indexOf(this);if(A>-1){E||this._scene._activeAnimatables.splice(A,1);const e=this._runtimeAnimations;for(let A=0;A<e.length;A++)e[A].dispose();this._runtimeAnimations.length=0,Q||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((A=>{this.onAnimationEndObservable.add((()=>{A(this)}),void 0,void 0,this,!0)}))}_animate(A){if(this.he)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=A),!0;if(null===this._localDelayOffset?(this._localDelayOffset=A,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=A-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let e=!1;const E=this._runtimeAnimations;let Q;for(Q=0;Q<E.length;Q++){const x=E[Q].animate(A-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);e=e||x}if(this.animationStarted=e,!e){if(this.disposeOnEnd)for(Q=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Q,1),Q=0;Q<E.length;Q++)E[Q].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return e}}function S(A){if(0===A.totalWeight&&0===A.totalAdditiveWeight)return A.originalValue;let e=1;const E=Y.j.fb[0],Q=Y.j.fb[1],x=Y.j.Quaternion[0];let t=0;const H=A.animations[0],h=A.originalValue;let F=1,w=!1;if(A.totalWeight<1)F=1-A.totalWeight,h.decompose(Q,x,E);else{if(t=1,e=A.totalWeight,F=H.weight/e,1==F){if(!A.totalAdditiveWeight)return H.currentValue;w=!0}H.currentValue.decompose(Q,x,E)}if(!w){Q.scaleInPlace(F),E.scaleInPlace(F),x.scaleInPlace(F);for(let H=t;H<A.animations.length;H++){const t=A.animations[H];if(0===t.weight)continue;F=t.weight/e;const h=Y.j.fb[2],w=Y.j.fb[3],r=Y.j.Quaternion[1];t.currentValue.decompose(w,r,h),w.scaleAndAddToRef(F,Q),r.scaleAndAddToRef(Y.f.Dot(x,r)>0?F:-F,x),h.scaleAndAddToRef(F,E)}x.normalize()}for(let S=0;S<A.additiveAnimations.length;S++){const e=A.additiveAnimations[S];if(0===e.weight)continue;const t=Y.j.fb[2],H=Y.j.fb[3],h=Y.j.Quaternion[1];e.currentValue.decompose(H,h,t),H.multiplyToRef(Q,H),Y.n.LerpToRef(Q,H,e.weight,Q),x.multiplyToRef(h,h),Y.f.SlerpToRef(x,h,e.weight,x),t.scaleAndAddToRef(e.weight,E)}const r=H?H._animationState.workValue:Y.j.Matrix[0].clone();return Y.e.ComposeToRef(Q,x,E,r),r}function v(A,e){if(0===A.totalWeight&&0===A.totalAdditiveWeight)return e;const E=A.animations[0],Q=A.originalValue;let x=e;if(0===A.totalWeight&&A.totalAdditiveWeight>0)x.p(Q);else if(1===A.animations.length){if(Y.f.SlerpToRef(Q,E.currentValue,Math.min(1,A.totalWeight),x),0===A.totalAdditiveWeight)return x}else if(A.animations.length>1){let E,t,H=1;if(A.totalWeight<1){const e=1-A.totalWeight;E=[],t=[],E.push(Q),t.push(e)}else{if(2===A.animations.length&&(Y.f.SlerpToRef(A.animations[0].currentValue,A.animations[1].currentValue,A.animations[1].weight/A.totalWeight,e),0===A.totalAdditiveWeight))return e;E=[],t=[],H=A.totalWeight}for(let e=0;e<A.animations.length;e++){const Q=A.animations[e];E.push(Q.currentValue),t.push(Q.weight/H)}let h=0;for(let A=0;A<E.length;)A?(h+=t[A],Y.f.SlerpToRef(x,E[A],t[A]/h,x),A++):(Y.f.SlerpToRef(E[A],E[A+1],t[A+1]/(t[A]+t[A+1]),e),x=e,h=t[A]+t[A+1],A+=2)}for(let t=0;t<A.additiveAnimations.length;t++){const e=A.additiveAnimations[t];0!==e.weight&&(x.multiplyToRef(e.currentValue,Y.j.Quaternion[0]),Y.f.SlerpToRef(x,Y.j.Quaternion[0],e.weight,x))}return x}var c,D,a=E(11014);c=a.b,(D=h.d)&&(D.prototype.copyAnimationRange=function(A,e,E){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Q.c(this.name,"_matrix",A.animations[0].framePerSecond,Q.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const H=A.animations[0].getRange(e);if(!H)return!1;const h=H.from,Y=H.to,F=A.animations[0].getKeys(),w=A.length,r=A.getParent(),S=this.getParent(),v=x&&r&&w&&this.length&&w!==this.length,c=v&&S&&r?S.length/r.length:1,D=x&&!S&&t&&(1!==t.x||1!==t.y||1!==t.z),a=this.animations[0].getKeys();let z,I,J;for(let Q=0,K=F.length;Q<K;Q++)z=F[Q],z.frame>=h&&z.frame<=Y&&(x?(J=z.value.clone(),v?(I=J.getTranslation(),J.setTranslation(I.scaleInPlace(c))):D&&t?(I=J.getTranslation(),J.setTranslation(I.multiplyInPlace(t))):J=z.value):J=z.value,a.push({frame:z.frame+E,value:J}));return this.animations[0].createRange(e,h+E,Y+E),!0}),c&&(c.prototype._animate=function(A){if(!this.animationsEnabled)return;const e=w.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=e}this.deltaTime=void 0!==A?A:this.useConstantAnimationDeltaTime?16:(e-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=e;const E=this._activeAnimatables;if(0===E.length)return;this._animationTime+=this.deltaTime;const x=this._animationTime;for(let Q=0;Q<E.length;Q++){const A=E[Q];!A._animate(x)&&A.disposeOnEnd&&Q--}!function(A){if(A._registeredForLateAnimationBindings.length){for(let e=0;e<A._registeredForLateAnimationBindings.length;e++){const E=A._registeredForLateAnimationBindings.data[e];for(const A in E._lateAnimationHolders){const e=E._lateAnimationHolders[A],x=e.animations[0],t=e.originalValue;if(void 0===t||null===t)continue;const H=Q.c.AllowMatrixDecomposeForInterpolation&&t.m;let h=E[A];if(H)h=S(e);else if(void 0!==t.w)h=v(e,h||Y.f.Identity());else{let A=0,E=1;const H=x&&x._animationState.loopMode===Q.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(e.totalWeight<1)h=H?t.clone?t.clone():t:x&&t.scale?t.scale(1-e.totalWeight):x?t*(1-e.totalWeight):t.clone?t.clone():t;else if(x){E=e.totalWeight;const Q=x.weight/E;h=1!==Q?x.currentValue.scale?x.currentValue.scale(Q):x.currentValue*Q:x.currentValue,H&&(h.addToRef?h.addToRef(t,h):h+=t),A=1}for(let Q=A;Q<e.animations.length;Q++){const A=e.animations[Q],x=A.weight/E;x&&(A.currentValue.scaleAndAddToRef?A.currentValue.scaleAndAddToRef(x,h):h+=A.currentValue*x)}for(let Q=0;Q<e.additiveAnimations.length;Q++){const A=e.additiveAnimations[Q],E=A.weight;E&&(A.currentValue.scaleAndAddToRef?A.currentValue.scaleAndAddToRef(E,h):h+=A.currentValue*E)}}E[A]=h}E._lateAnimationHolders={}}A._registeredForLateAnimationBindings.reset()}}(this)},c.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((A,e)=>A.playOrder-e.playOrder))},c.prototype.beginWeightedAnimation=function(A,e,E){let Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,x=arguments.length>4?arguments[4]:void 0,t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,H=arguments.length>6?arguments[6]:void 0,h=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,w=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const r=this.beginAnimation(A,e,E,x,t,H,h,!1,Y,F,w);return r.weight=Q,r},c.prototype.beginAnimation=function(A,e,E,Q){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,t=arguments.length>5?arguments[5]:void 0,H=arguments.length>6?arguments[6]:void 0,h=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Y=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,w=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(x<0){const A=e;e=E,E=A,x=-x}e>E&&(x=-x),h&&this.stopAnimation(A,void 0,Y),H||(H=new r(this,A,e,E,Q,x,t,void 0,F,w));const S=!Y||Y(A);if(A.animations&&S&&H.appendAnimations(A,A.animations),A.getAnimatables){const w=A.getAnimatables();for(let A=0;A<w.length;A++)this.beginAnimation(w[A],e,E,Q,x,t,H,h,Y,F)}return H.reset(),H},c.prototype.beginHierarchyAnimation=function(A,e,E,Q,x){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,H=arguments.length>6?arguments[6]:void 0,h=arguments.length>7?arguments[7]:void 0,Y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],F=arguments.length>9?arguments[9]:void 0,w=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const r=A.getDescendants(e),S=[];S.push(this.beginAnimation(A,E,Q,x,t,H,h,Y,F,void 0,w));for(const v of r)S.push(this.beginAnimation(v,E,Q,x,t,H,h,Y,F,void 0,w));return S},c.prototype.beginDirectAnimation=function(A,e,E,Q,x){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(t<0){const A=E;E=Q,Q=A,t=-t}return E>Q&&(t=-t),new r(this,A,E,Q,x,t,arguments.length>6?arguments[6]:void 0,e,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},c.prototype.beginDirectHierarchyAnimation=function(A,e,E,Q,x,t,H,h,Y){let F=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const w=A.getDescendants(e),r=[];r.push(this.beginDirectAnimation(A,E,Q,x,t,H,h,Y,F));for(const S of w)r.push(this.beginDirectAnimation(S,E,Q,x,t,H,h,Y,F));return r},c.prototype.getAnimatableByTarget=function(A){for(let e=0;e<this._activeAnimatables.length;e++)if(this._activeAnimatables[e].target===A)return this._activeAnimatables[e];return null},c.prototype.getAllAnimatablesByTarget=function(A){const e=[];for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].target===A&&e.push(this._activeAnimatables[E]);return e},c.prototype.stopAnimation=function(A,e,E){const Q=this.getAllAnimatablesByTarget(A);for(const x of Q)x.stop(e,E)},c.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let A=0;A<this._activeAnimatables.length;A++)this._activeAnimatables[A].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const A of this.animationGroups)A.stop()});class z{getClassName(){return"TargetedAnimation"}serialize(){const A={};return A.animation=this.animation.serialize(),A.targetId=this.target.id,A}}class I{get mask(){return this._mask}set mask(A){this._mask!==A&&(this._mask=A,this.syncWithMask(!0))}syncWithMask(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||A){this._numActiveAnimatables=0;for(let A=0;A<this._animatables.length;++A){const e=this._animatables[A];!this.mask||this.mask.disabled||this.mask.retainsTarget(e.target.name)?(this._numActiveAnimatables++,e.paused&&e.restart()):e.paused||e.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let A=0;A<this._animatables.length;++A){const e=this._animatables[A];this.mask.retainsTarget(e.target.name)||(e.stop(),this._animatables.splice(A,1),--A)}for(let A=0;A<this._targetedAnimations.length;A++){const e=this._targetedAnimations[A];this.mask.retainsTarget(e.target.name)||(this._targetedAnimations.splice(A,1),--A)}}}get from(){return this._from}set from(A){if(this._from!==A){this._from=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].fromFrame=this._from}}}get to(){return this._to}set to(A){if(this._to!==A){this._to=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(A){if(this._speedRatio!==A){this._speedRatio=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(A){if(this._loopAnimation!==A){this._loopAnimation=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(A){if(this._isAdditive!==A){this._isAdditive=A;for(let A=0;A<this._animatables.length;A++){this._animatables[A].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(A){this._weight!==A&&(this._weight=A,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(A){if(this._playOrder!==A&&(this._playOrder=A,this._animatables.length>0)){for(let A=0;A<this._animatables.length;A++)this._animatables[A].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(A){if(this._enableBlending!==A&&(this._enableBlending=A,null!==A))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.enableBlending=A}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(A){if(this._blendingSpeed!==A&&(this._blendingSpeed=A,null!==A))for(let e=0;e<this._targetedAnimations.length;++e)this._targetedAnimations[e].animation.blendingSpeed=A}getLength(A,e){A=A??this._from;return((e=e??this._to)-A)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(A){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Q=arguments.length>3?arguments[3]:void 0;if(0===A.length)return null;Q=Q??A[0].weight;let x=Number.MAX_VALUE,t=-Number.MAX_VALUE;if(E)for(const h of A)h.from<x&&(x=h.from),h.to>t&&(t=h.to);const H=new I(A[0].name+"_merged",A[0]._scene,Q);for(const h of A){E&&h.normalize(x,t);for(const A of h.targetedAnimations)H.addTargetedAnimation(A.animation,A.target);e&&h.dispose()}return H}constructor(A){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=A,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new x.c,this.onAnimationLoopObservable=new x.c,this.onAnimationGroupLoopObservable=new x.c,this.onAnimationGroupEndObservable=new x.c,this.onAnimationGroupPauseObservable=new x.c,this.onAnimationGroupPlayObservable=new x.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=e||t.e.LastCreatedScene,this._weight=E,this._playOrder=Q,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(A,e){const E=new z;E.animation=A,E.target=e;const Q=A.getKeys();return this._from>Q[0].frame&&(this._from=Q[0].frame),this._to<Q[Q.length-1].frame&&(this._to=Q[Q.length-1].frame),null!==this._enableBlending&&(A.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(A.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(E),this._shouldStart=!0,E}removeTargetedAnimation(A){for(let e=this._targetedAnimations.length-1;e>-1;e--){this._targetedAnimations[e].animation===A&&this._targetedAnimations.splice(e,1)}}normalize(){let A=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==A&&(A=this._from),null==e&&(e=this._to);for(let E=0;E<this._targetedAnimations.length;E++){const Q=this._targetedAnimations[E].animation.getKeys(),x=Q[0],t=Q[Q.length-1];if(x.frame>A){const e={frame:A,value:x.value,inTangent:x.inTangent,outTangent:x.outTangent,interpolation:x.interpolation};Q.splice(0,0,e)}if(t.frame<e){const A={frame:e,value:t.value,inTangent:t.inTangent,outTangent:t.outTangent,interpolation:t.interpolation};Q.push(A)}}return this._from=A,this._to=e,this}_processLoop(A,e,E){A.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(e),this._animationLoopFlags[E]||(this._animationLoopFlags[E]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0],e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,E=arguments.length>2?arguments[2]:void 0,Q=arguments.length>3?arguments[3]:void 0,x=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=A,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let t=0;t<this._targetedAnimations.length;t++){const H=this._targetedAnimations[t],h=this._scene.beginDirectAnimation(H.target,[H.animation],void 0!==E?E:this._from,void 0!==Q?Q:this._to,A,e,void 0,void 0,void 0!==x?x:this._isAdditive);h.weight=this._weight,h.playOrder=this._playOrder,h.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(H),this._checkAnimationGroupEnded(h)},this._processLoop(h,H,t),this._animatables.push(h)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=e,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let A=0;A<this._animatables.length;A++){this._animatables[A].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(A){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==A&&(this.loopAnimation=A),this.restart()):(this.stop(),this.start(A,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let A=0;A<this._animatables.length;A++){this._animatables[A].reset()}return this}restart(){if(!this._isStarted)return this;for(let A=0;A<this._animatables.length;A++){this._animatables[A].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let A=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const e=this._animatables.slice();for(let Q=0;Q<e.length;Q++)e[Q].stop(void 0,void 0,!0,A);let E=0;for(let Q=0;Q<this._scene._activeAnimatables.length;Q++){const e=this._scene._activeAnimatables[Q];e._runtimeAnimations.length>0?this._scene._activeAnimatables[E++]=e:A&&this._checkAnimationGroupEnded(e,A)}return this._scene._activeAnimatables.length=E,this._isStarted=!1,this}setWeightForAllAnimatables(A){for(let e=0;e<this._animatables.length;e++){this._animatables[e].weight=A}return this}syncAllAnimationsWith(A){for(let e=0;e<this._animatables.length;e++){this._animatables[e].syncWith(A)}return this}goToFrame(A){if(!this._isStarted)return this;for(let e=0;e<this._animatables.length;e++){this._animatables[e].goToFrame(A)}return this}getCurrentFrame(){var A;return(null===(A=this.animatables[0])||void 0===A?void 0:A.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const A=this._scene.animationGroups.indexOf(this);if(A>-1&&this._scene.animationGroups.splice(A,1),this._parentContainer){const A=this._parentContainer.animationGroups.indexOf(this);A>-1&&this._parentContainer.animationGroups.splice(A,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(A){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const E=this._animatables.indexOf(A);E>-1&&this._animatables.splice(E,1),0===this._animatables.length&&(this._isStarted=!1,e||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(A,e){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=new I(A||this.name,this._scene,this._weight,this._playOrder);Q._from=this.from,Q._to=this.to,Q._speedRatio=this.speedRatio,Q._loopAnimation=this.loopAnimation,Q._isAdditive=this.isAdditive,Q._enableBlending=this.enableBlending,Q._blendingSpeed=this.blendingSpeed,Q.metadata=this.metadata,Q.mask=this.mask;for(const x of this._targetedAnimations)Q.addTargetedAnimation(E?x.animation.clone():x.animation,e?e(x.target):x.target);return Q}serialize(){const A={};A.name=this.name,A.from=this.from,A.to=this.to,A.speedRatio=this.speedRatio,A.loopAnimation=this.loopAnimation,A.isAdditive=this.isAdditive,A.weight=this.weight,A.playOrder=this.playOrder,A.enableBlending=this.enableBlending,A.blendingSpeed=this.blendingSpeed,A.targetedAnimations=[];for(let e=0;e<this.targetedAnimations.length;e++){const E=this.targetedAnimations[e];A.targetedAnimations[e]=E.serialize()}return H.b&&H.b.HasTags(this)&&(A.tags=H.b.GetTags(this)),this.metadata&&(A.metadata=this.metadata),A}static Parse(A,e){const E=new I(A.name,e,A.weight,A.playOrder);for(let x=0;x<A.targetedAnimations.length;x++){const t=A.targetedAnimations[x],H=Q.c.Parse(t.animation),h=t.targetId;if("influence"===t.animation.property){const A=e.getMorphTargetById(h);A&&E.addTargetedAnimation(H,A)}else{const A=e.getNodeById(h);null!=A&&E.addTargetedAnimation(H,A)}}return H.b&&H.b.AddTagsTo(E,A.tags),null!==A.from&&null!==A.to&&E.normalize(A.from,A.to),void 0!==A.speedRatio&&(E._speedRatio=A.speedRatio),void 0!==A.loopAnimation&&(E._loopAnimation=A.loopAnimation),void 0!==A.isAdditive&&(E._isAdditive=A.isAdditive),void 0!==A.weight&&(E._weight=A.weight),void 0!==A.playOrder&&(E._playOrder=A.playOrder),void 0!==A.enableBlending&&(E._enableBlending=A.enableBlending),void 0!==A.blendingSpeed&&(E._blendingSpeed=A.blendingSpeed),void 0!==A.metadata&&(E.metadata=A.metadata),E}static MakeAnimationAdditive(A,e,E){let x;x="object"===typeof e?e:{referenceFrame:e,range:E,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let t=A;x.cloneOriginalAnimationGroup&&(t=A.clone(x.clonedAnimationGroupName||t.name));const H=t.targetedAnimations;for(let h=0;h<H.length;h++){const A=H[h];A.animation=Q.c.MakeAnimationAdditive(A.animation,x)}if(t.isAdditive=!0,x.clipKeys){let A=Number.MAX_VALUE,e=-Number.MAX_VALUE;const E=t.targetedAnimations;for(let Q=0;Q<E.length;Q++){const x=E[Q].animation.getKeys();A>x[0].frame&&(A=x[0].frame),e<x[x.length-1].frame&&(e=x[x.length-1].frame)}t._from=A,t._to=e}return t}static ClipKeys(A,e,E,Q,x){const t=A.clone(Q||A.name);return I.ClipKeysInPlace(t,e,E,x)}static ClipKeysInPlace(A,e,E,Q){return I.ClipInPlace(A,e,E,Q,!1)}static ClipFrames(A,e,E,Q,x){const t=A.clone(Q||A.name);return I.ClipFramesInPlace(t,e,E,x)}static ClipFramesInPlace(A,e,E,Q){return I.ClipInPlace(A,e,E,Q,!0)}static ClipInPlace(A,e,E,Q){let x=arguments.length>4&&void 0!==arguments[4]&&arguments[4],t=Number.MAX_VALUE,H=-Number.MAX_VALUE;const h=A.targetedAnimations;for(let Y=0;Y<h.length;Y++){const A=h[Y],F=Q?A.animation:A.animation.clone();x&&(F.createKeyForFrame(e),F.createKeyForFrame(E));const w=F.getKeys(),r=[];let S=Number.MAX_VALUE;for(let Q=0;Q<w.length;Q++){const A=w[Q];if(!x&&Q>=e&&Q<=E||x&&A.frame>=e&&A.frame<=E){const e={frame:A.frame,value:A.value.clone?A.value.clone():A.value,inTangent:A.inTangent,outTangent:A.outTangent,interpolation:A.interpolation,lockedTangent:A.lockedTangent};S===Number.MAX_VALUE&&(S=e.frame),e.frame-=S,r.push(e)}}0!==r.length?(t>r[0].frame&&(t=r[0].frame),H<r[r.length-1].frame&&(H=r[r.length-1].frame),F.setKeys(r,!0),A.animation=F):(h.splice(Y,1),Y--)}return A._from=t,A._to=H,A}getClassName(){return"AnimationGroup"}toString(A){let e="Name: "+this.name;return e+=", type: "+this.getClassName(),A&&(e+=", from: "+this._from,e+=", to: "+this._to,e+=", isStarted: "+this._isStarted,e+=", speedRatio: "+this._speedRatio,e+=", targetedAnimations length: "+this._targetedAnimations.length,e+=", animatables length: "+this._animatables),e}}}}]);