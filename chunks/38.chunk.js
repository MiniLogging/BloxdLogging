"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13605:(H,c,y)=>{y.r(c),y.d(c,{AnimationGroup:()=>Q,TargetedAnimation:()=>h});var Z=y(12290),F=y(10763),P=y(10810),S=y(11083),n=y(12283),O=y(11092);class a{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(H,c,y,F){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=c,this._target=H,this._scene=y,this._host=F,this._activeTargets=[],c._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===Z.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=O.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const H={frame:0,value:this._minValue};this._keys.splice(0,0,H)}if(this._target instanceof Array){let H=0;for(const c of this._target)this._preparePath(c,H),this._getOriginalValues(H),H++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const P=c.getEvents();P&&P.length>0&&P.forEach((H=>{this._events.push(H._clone())})),this._enableBlending=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(H){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const y=this._animation.targetPropertyPath;if(y.length>1){let Z=H;for(let H=0;H<y.length-1;H++){const c=y[H];if(Z=Z[c],void 0===Z)throw new Error(`Invalid property (${c}) in property path (${y.join(".")})`)}this._targetPath=y[y.length-1],this._activeTargets[c]=Z}else this._targetPath=y[0],this._activeTargets[c]=H;if(void 0===this._activeTargets[c][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${y.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let H=0;for(const c of this._target)void 0!==this._originalValue[H]&&this._setValue(c,this._activeTargets[H],this._originalValue[H],-1,H),H++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let H=0;H<this._events.length;H++)this._events[H].isDone=!1}isStopped(){return this._stopped}dispose(){const H=this._animation.runtimeAnimations.indexOf(this);H>-1&&this._animation.runtimeAnimations.splice(H,1)}setValue(H,c){if(this._targetIsArray)for(let y=0;y<this._target.length;y++){const Z=this._target[y];this._setValue(Z,this._activeTargets[y],H,c,y)}else this._setValue(this._target,this._directTarget,H,c,0)}_getOriginalValues(){let H,c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const y=this._activeTargets[c];H=y.getLocalMatrix&&"_matrix"===this._targetPath?y.getLocalMatrix():y[this._targetPath],H&&H.clone?this._originalValue[c]=H.clone():this._originalValue[c]=H}_registerTargetForLateAnimationBinding(H,c){const y=H.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(y),y._lateAnimationHolders||(y._lateAnimationHolders={}),y._lateAnimationHolders[H.targetPath]||(y._lateAnimationHolders[H.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:c}),H.isAdditive?(y._lateAnimationHolders[H.targetPath].additiveAnimations.push(H),y._lateAnimationHolders[H.targetPath].totalAdditiveWeight+=H.weight):(y._lateAnimationHolders[H.targetPath].animations.push(H),y._lateAnimationHolders[H.targetPath].totalWeight+=H.weight)}_setValue(H,c,y,F,P){if(this._currentActiveTarget=c,this._weight=F,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const H=c[this._targetPath];H.clone?this._originalBlendValue=H.clone():this._originalBlendValue=H}this._originalBlendValue.m?Z.c.AllowMatrixDecomposeForInterpolation?this._currentValue?O.d.DecomposeLerpToRef(this._originalBlendValue,y,this._blendingFactor,this._currentValue):this._currentValue=O.d.DecomposeLerp(this._originalBlendValue,y,this._blendingFactor):this._currentValue?O.d.LerpToRef(this._originalBlendValue,y,this._blendingFactor,this._currentValue):this._currentValue=O.d.Lerp(this._originalBlendValue,y,this._blendingFactor):this._currentValue=Z.c._UniversalLerp(this._originalBlendValue,y,this._blendingFactor);const F=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=F}else this._currentValue?this._currentValue.p?this._currentValue.p(y):this._currentValue=y:null!==y&&void 0!==y&&y.clone?this._currentValue=y.clone():this._currentValue=y;-1!==F?this._registerTargetForLateAnimationBinding(this,this._originalValue[P]):this._animationState.loopMode===Z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[P],c[this._targetPath]):c[this._targetPath]=this._originalValue[P]+this._currentValue:c[this._targetPath]=this._currentValue,H.Fg&&H.Fg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(H){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const y=this._animation.getKeys();H<y[0].frame?H=y[0].frame:H>y[y.length-1].frame&&(H=y[y.length-1].frame);const Z=this._events;if(Z.length)for(let P=0;P<Z.length;P++)Z[P].onlyOnce||(Z[P].isDone=Z[P].frame<H);this._currentFrame=H;const F=this._animation._interpolate(H,this._animationState);this.setValue(F,c)}_prepareForSpeedRatioChange(H){const c=this._previousElapsedTime*(this._animation.framePerSecond*H)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-c}animate(H,c,y,F,P){let S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const n=this._animation,O=n.targetPropertyPath;if(!O||O.length<1)return this._stopped=!0,!1;let a=!0;(c<this._minFrame||c>this._maxFrame)&&(c=this._minFrame),(y<this._minFrame||y>this._maxFrame)&&(y=this._maxFrame);const i=y-c;let C,g=H*(n.framePerSecond*P)/1e3+this._absoluteFrameOffset,v=0,m=!1;const z=F&&this._animationState.loopMode===Z.c.ANIMATIONLOOPMODE_YOYO;if(z){const H=(g-c)/i,y=Math.sin(H*Math.PI);g=Math.abs(y)*i+c;const Z=y>=0?1:-1;this._yoyoDirection!==Z&&(m=!0),this._yoyoDirection=Z}if(this._previousElapsedTime=H,this._previousAbsoluteFrame=g,!F&&y>=c&&(g>=i&&P>0||g<=0&&P<0))a=!1,v=n._getKeyValue(this._maxValue);else if(!F&&c>=y&&(g<=i&&P<0||g>=0&&P>0))a=!1,v=n._getKeyValue(this._minValue);else if(this._animationState.loopMode!==Z.c.ANIMATIONLOOPMODE_CYCLE){const H=y.toString()+c.toString();if(!this._offsetsCache[H]){this._animationState.repeatCount=0,this._animationState.loopMode=Z.c.ANIMATIONLOOPMODE_CYCLE;const F=n._interpolate(c,this._animationState),P=n._interpolate(y,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),n.dataType){case Z.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[H]=P-F;break;case Z.c.ANIMATIONTYPE_QUATERNION:case Z.c.ANIMATIONTYPE_VECTOR3:case Z.c.ANIMATIONTYPE_VECTOR2:case Z.c.ANIMATIONTYPE_SIZE:case Z.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[H]=P.Rc(F)}this._highLimitsCache[H]=P}v=this._highLimitsCache[H],C=this._offsetsCache[H]}if(void 0===C)switch(n.dataType){case Z.c.ANIMATIONTYPE_FLOAT:C=0;break;case Z.c.ANIMATIONTYPE_QUATERNION:C=Z.h;break;case Z.c.ANIMATIONTYPE_VECTOR3:C=Z.n;break;case Z.c.ANIMATIONTYPE_VECTOR2:C=Z.k;break;case Z.c.ANIMATIONTYPE_SIZE:C=Z.j;break;case Z.c.ANIMATIONTYPE_COLOR3:C=Z.d;break;case Z.c.ANIMATIONTYPE_COLOR4:C=Z.e}let V;if(this._host&&this._host.syncRoot){const H=this._host.syncRoot;V=c+i*((H.masterFrame-H.fromFrame)/(H.toFrame-H.fromFrame))}else V=g>0&&c>y||g<0&&c<y?a&&0!==i?y+g%i:c:a&&0!==i?c+g%i:y;const h=this._events;if(!z&&(P>0&&this.currentFrame>V||P<0&&this.currentFrame<V)||z&&m){this._onLoop();for(let H=0;H<h.length;H++)h[H].onlyOnce||(h[H].isDone=!1);this._animationState.key=P>0?0:n.getKeys().length-1}this._currentFrame=V,this._animationState.repeatCount=0===i?0:g/i|0,this._animationState.highLimitValue=v,this._animationState.offsetValue=C;const Q=n._interpolate(V,this._animationState);if(this.setValue(Q,S),h.length)for(let Z=0;Z<h.length;Z++)if(i>=0&&V>=h[Z].frame&&h[Z].frame>=c||i<0&&V<=h[Z].frame&&h[Z].frame<=c){const H=h[Z];H.isDone||(H.onlyOnce&&(h.splice(Z,1),Z--),H.isDone=!0,H.action(V))}return a||(this._stopped=!0),a}}var i=y(10790);class C{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(H){this._weight=-1!==H?Math.min(Math.max(H,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(H){for(let c=0;c<this._runtimeAnimations.length;c++){this._runtimeAnimations[c]._prepareForSpeedRatioChange(H)}this._speedRatio=H,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(H,c){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,P=arguments.length>4&&void 0!==arguments[4]&&arguments[4],S=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,n=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,i=arguments.length>9&&void 0!==arguments[9]&&arguments[9],C=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=c,this.fromFrame=y,this.toFrame=Z,this.loopAnimation=P,this.onAnimationEnd=n,this.onAnimationLoop=a,this.isAdditive=i,this.playOrder=C,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.zd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new F.e,this.onAnimationLoopObservable=new F.e,this._scene=H,O&&this.appendAnimations(c,O),this._speedRatio=S,H._activeAnimatables.push(this)}syncWith(H){if(this._syncRoot=H,H){const H=this._scene._activeAnimatables.indexOf(this);H>-1&&(this._scene._activeAnimatables.splice(H,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(H,c){for(let y=0;y<c.length;y++){const Z=c[y],F=new a(H,Z,this._scene,this);F._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(F)}}getAnimationByTargetProperty(H){const c=this._runtimeAnimations;for(let y=0;y<c.length;y++)if(c[y].animation.targetProperty===H)return c[y].animation;return null}getRuntimeAnimationByTargetProperty(H){const c=this._runtimeAnimations;for(let y=0;y<c.length;y++)if(c[y].animation.targetProperty===H)return c[y];return null}reset(){const H=this._runtimeAnimations;for(let c=0;c<H.length;c++)H[c].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(H){const c=this._runtimeAnimations;for(let y=0;y<c.length;y++)c[y].animation.enableBlending=!0,c[y].animation.blendingSpeed=H}disableBlending(){const H=this._runtimeAnimations;for(let c=0;c<H.length;c++)H[c].animation.enableBlending=!1}goToFrame(H){const c=this._runtimeAnimations;if(c[0]){const y=c[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??c[0].currentFrame;const Z=0===this.speedRatio?0:(H-this._frameToSyncFromJump)/y*1e3/this.speedRatio;this._manualJumpDelay=-Z}for(let y=0;y<c.length;y++)c[y].goToFrame(H,this._weight);this._goToFrame=H}get paused(){return this.zd}pause(){this.zd||(this.zd=!0)}restart(){this.zd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(H,c){let y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(H||c){const F=this._scene._activeAnimatables.indexOf(this);if(F>-1){const P=this._runtimeAnimations;for(let y=P.length-1;y>=0;y--){const Z=P[y];H&&Z.animation.name!=H||(c&&!c(Z.target)||(Z.dispose(),P.splice(y,1)))}0==P.length&&(y||this._scene._activeAnimatables.splice(F,1),Z||this._raiseOnAnimationEnd())}}else{const H=this._scene._activeAnimatables.indexOf(this);if(H>-1){y||this._scene._activeAnimatables.splice(H,1);const c=this._runtimeAnimations;for(let H=0;H<c.length;H++)c[H].dispose();this._runtimeAnimations.length=0,Z||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((H=>{this.onAnimationEndObservable.add((()=>{H(this)}),void 0,void 0,this,!0)}))}_animate(H){if(this.zd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=H),!0;if(null===this._localDelayOffset?(this._localDelayOffset=H,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=H-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let c=!1;const y=this._runtimeAnimations;let Z;for(Z=0;Z<y.length;Z++){const F=y[Z].animate(H-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);c=c||F}if(this.animationStarted=c,!c){if(this.disposeOnEnd)for(Z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(Z,1),Z=0;Z<y.length;Z++)y[Z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return c}}function g(H){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return H.originalValue;let c=1;const y=O.h.o[0],Z=O.h.o[1],F=O.h.Quaternion[0];let P=0;const S=H.animations[0],n=H.originalValue;let a=1,i=!1;if(H.totalWeight<1)a=1-H.totalWeight,n.decompose(Z,F,y);else{if(P=1,c=H.totalWeight,a=S.weight/c,1==a){if(!H.totalAdditiveWeight)return S.currentValue;i=!0}S.currentValue.decompose(Z,F,y)}if(!i){Z.scaleInPlace(a),y.scaleInPlace(a),F.scaleInPlace(a);for(let S=P;S<H.animations.length;S++){const P=H.animations[S];if(0===P.weight)continue;a=P.weight/c;const n=O.h.o[2],i=O.h.o[3],C=O.h.Quaternion[1];P.currentValue.decompose(i,C,n),i.scaleAndAddToRef(a,Z),C.scaleAndAddToRef(O.f.Dot(F,C)>0?a:-a,F),n.scaleAndAddToRef(a,y)}F.normalize()}for(let g=0;g<H.additiveAnimations.length;g++){const c=H.additiveAnimations[g];if(0===c.weight)continue;const P=O.h.o[2],S=O.h.o[3],n=O.h.Quaternion[1];c.currentValue.decompose(S,n,P),S.multiplyToRef(Z,S),O.n.LerpToRef(Z,S,c.weight,Z),F.multiplyToRef(n,n),O.f.SlerpToRef(F,n,c.weight,F),P.scaleAndAddToRef(c.weight,y)}const C=S?S._animationState.workValue:O.h.Matrix[0].clone();return O.d.ComposeToRef(Z,F,y,C),C}function v(H,c){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return c;const y=H.animations[0],Z=H.originalValue;let F=c;if(0===H.totalWeight&&H.totalAdditiveWeight>0)F.p(Z);else if(1===H.animations.length){if(O.f.SlerpToRef(Z,y.currentValue,Math.min(1,H.totalWeight),F),0===H.totalAdditiveWeight)return F}else if(H.animations.length>1){let y,P,S=1;if(H.totalWeight<1){const c=1-H.totalWeight;y=[],P=[],y.push(Z),P.push(c)}else{if(2===H.animations.length&&(O.f.SlerpToRef(H.animations[0].currentValue,H.animations[1].currentValue,H.animations[1].weight/H.totalWeight,c),0===H.totalAdditiveWeight))return c;y=[],P=[],S=H.totalWeight}for(let c=0;c<H.animations.length;c++){const Z=H.animations[c];y.push(Z.currentValue),P.push(Z.weight/S)}let n=0;for(let H=0;H<y.length;)H?(n+=P[H],O.f.SlerpToRef(F,y[H],P[H]/n,F),H++):(O.f.SlerpToRef(y[H],y[H+1],P[H+1]/(P[H]+P[H+1]),c),F=c,n=P[H]+P[H+1],H+=2)}for(let P=0;P<H.additiveAnimations.length;P++){const c=H.additiveAnimations[P];0!==c.weight&&(F.multiplyToRef(c.currentValue,O.h.Quaternion[0]),O.f.SlerpToRef(F,O.h.Quaternion[0],c.weight,F))}return F}var m,z,V=y(11076);m=V.d,(z=n.d)&&(z.prototype.copyAnimationRange=function(H,c,y){let F=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new Z.c(this.name,"_matrix",H.animations[0].framePerSecond,Z.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const S=H.animations[0].getRange(c);if(!S)return!1;const n=S.from,O=S.to,a=H.animations[0].getKeys(),i=H.length,C=H.getParent(),g=this.getParent(),v=F&&C&&i&&this.length&&i!==this.length,m=v&&g&&C?g.length/C.length:1,z=F&&!g&&P&&(1!==P.x||1!==P.y||1!==P.z),V=this.animations[0].getKeys();let h,Q,D;for(let Z=0,f=a.length;Z<f;Z++)h=a[Z],h.frame>=n&&h.frame<=O&&(F?(D=h.value.clone(),v?(Q=D.getTranslation(),D.setTranslation(Q.scaleInPlace(m))):z&&P?(Q=D.getTranslation(),D.setTranslation(Q.multiplyInPlace(P))):D=h.value):D=h.value,V.push({frame:h.frame+y,value:D}));return this.animations[0].createRange(c,n+y,O+y),!0}),m&&(m.prototype._animate=function(H){if(!this.animationsEnabled)return;const c=i.b.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=c}this.deltaTime=void 0!==H?H:this.useConstantAnimationDeltaTime?16:(c-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=c;const y=this._activeAnimatables;if(0===y.length)return;this._animationTime+=this.deltaTime;const F=this._animationTime;for(let Z=0;Z<y.length;Z++){const H=y[Z];!H._animate(F)&&H.disposeOnEnd&&Z--}!function(H){if(H._registeredForLateAnimationBindings.length){for(let c=0;c<H._registeredForLateAnimationBindings.length;c++){const y=H._registeredForLateAnimationBindings.data[c];for(const H in y._lateAnimationHolders){const c=y._lateAnimationHolders[H],F=c.animations[0],P=c.originalValue;if(void 0===P||null===P)continue;const S=Z.c.AllowMatrixDecomposeForInterpolation&&P.m;let n=y[H];if(S)n=g(c);else if(void 0!==P.w)n=v(c,n||O.f.Identity());else{let H=0,y=1;const S=F&&F._animationState.loopMode===Z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(c.totalWeight<1)n=S?P.clone?P.clone():P:F&&P.scale?P.scale(1-c.totalWeight):F?P*(1-c.totalWeight):P.clone?P.clone():P;else if(F){y=c.totalWeight;const Z=F.weight/y;n=1!==Z?F.currentValue.scale?F.currentValue.scale(Z):F.currentValue*Z:F.currentValue,S&&(n.addToRef?n.addToRef(P,n):n+=P),H=1}for(let Z=H;Z<c.animations.length;Z++){const H=c.animations[Z],F=H.weight/y;F&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(F,n):n+=H.currentValue*F)}for(let Z=0;Z<c.additiveAnimations.length;Z++){const H=c.additiveAnimations[Z],y=H.weight;y&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(y,n):n+=H.currentValue*y)}}y[H]=n}y._lateAnimationHolders={}}H._registeredForLateAnimationBindings.reset()}}(this)},m.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((H,c)=>H.playOrder-c.playOrder))},m.prototype.beginWeightedAnimation=function(H,c,y){let Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,F=arguments.length>4?arguments[4]:void 0,P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,i=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const C=this.beginAnimation(H,c,y,F,P,S,n,!1,O,a,i);return C.weight=Z,C},m.prototype.beginAnimation=function(H,c,y,Z){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,P=arguments.length>5?arguments[5]:void 0,S=arguments.length>6?arguments[6]:void 0,n=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],O=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,i=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(F<0){const H=c;c=y,y=H,F=-F}c>y&&(F=-F),n&&this.stopAnimation(H,void 0,O),S||(S=new C(this,H,c,y,Z,F,P,void 0,a,i));const g=!O||O(H);if(H.animations&&g&&S.appendAnimations(H,H.animations),H.getAnimatables){const i=H.getAnimatables();for(let H=0;H<i.length;H++)this.beginAnimation(i[H],c,y,Z,F,P,S,n,O,a)}return S.reset(),S},m.prototype.beginHierarchyAnimation=function(H,c,y,Z,F){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,n=arguments.length>7?arguments[7]:void 0,O=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=arguments.length>9?arguments[9]:void 0,i=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const C=H.getDescendants(c),g=[];g.push(this.beginAnimation(H,y,Z,F,P,S,n,O,a,void 0,i));for(const v of C)g.push(this.beginAnimation(v,y,Z,F,P,S,n,O,a,void 0,i));return g},m.prototype.beginDirectAnimation=function(H,c,y,Z,F){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(P<0){const H=y;y=Z,Z=H,P=-P}return y>Z&&(P=-P),new C(this,H,y,Z,F,P,arguments.length>6?arguments[6]:void 0,c,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},m.prototype.beginDirectHierarchyAnimation=function(H,c,y,Z,F,P,S,n,O){let a=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const i=H.getDescendants(c),C=[];C.push(this.beginDirectAnimation(H,y,Z,F,P,S,n,O,a));for(const g of i)C.push(this.beginDirectAnimation(g,y,Z,F,P,S,n,O,a));return C},m.prototype.getAnimatableByTarget=function(H){for(let c=0;c<this._activeAnimatables.length;c++)if(this._activeAnimatables[c].target===H)return this._activeAnimatables[c];return null},m.prototype.getAllAnimatablesByTarget=function(H){const c=[];for(let y=0;y<this._activeAnimatables.length;y++)this._activeAnimatables[y].target===H&&c.push(this._activeAnimatables[y]);return c},m.prototype.stopAnimation=function(H,c,y){const Z=this.getAllAnimatablesByTarget(H);for(const F of Z)F.stop(c,y)},m.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const H of this.animationGroups)H.stop()});class h{getClassName(){return"TargetedAnimation"}serialize(){const H={};return H.animation=this.animation.serialize(),H.targetId=this.target.id,H}}class Q{get mask(){return this._mask}set mask(H){this._mask!==H&&(this._mask=H,this.syncWithMask(!0))}syncWithMask(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||H){this._numActiveAnimatables=0;for(let H=0;H<this._animatables.length;++H){const c=this._animatables[H];!this.mask||this.mask.disabled||this.mask.retainsTarget(c.target.name)?(this._numActiveAnimatables++,c.paused&&c.restart()):c.paused||c.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let H=0;H<this._animatables.length;++H){const c=this._animatables[H];this.mask.retainsTarget(c.target.name)||(c.stop(),this._animatables.splice(H,1),--H)}for(let H=0;H<this._targetedAnimations.length;H++){const c=this._targetedAnimations[H];this.mask.retainsTarget(c.target.name)||(this._targetedAnimations.splice(H,1),--H)}}}get from(){return this._from}set from(H){if(this._from!==H){this._from=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].fromFrame=this._from}}}get to(){return this._to}set to(H){if(this._to!==H){this._to=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(H){if(this._speedRatio!==H){this._speedRatio=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(H){if(this._loopAnimation!==H){this._loopAnimation=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(H){if(this._isAdditive!==H){this._isAdditive=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(H){this._weight!==H&&(this._weight=H,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(H){if(this._playOrder!==H&&(this._playOrder=H,this._animatables.length>0)){for(let H=0;H<this._animatables.length;H++)this._animatables[H].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(H){if(this._enableBlending!==H&&(this._enableBlending=H,null!==H))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.enableBlending=H}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(H){if(this._blendingSpeed!==H&&(this._blendingSpeed=H,null!==H))for(let c=0;c<this._targetedAnimations.length;++c)this._targetedAnimations[c].animation.blendingSpeed=H}getLength(H,c){H=H??this._from;return((c=c??this._to)-H)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(H){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],y=arguments.length>2&&void 0!==arguments[2]&&arguments[2],Z=arguments.length>3?arguments[3]:void 0;if(0===H.length)return null;Z=Z??H[0].weight;let F=Number.MAX_VALUE,P=-Number.MAX_VALUE;if(y)for(const n of H)n.from<F&&(F=n.from),n.to>P&&(P=n.to);const S=new Q(H[0].name+"_merged",H[0]._scene,Z);for(const n of H){y&&n.normalize(F,P);for(const H of n.targetedAnimations)S.addTargetedAnimation(H.animation,H.target);c&&n.dispose()}return S}constructor(H){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,Z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=H,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new F.e,this.onAnimationLoopObservable=new F.e,this.onAnimationGroupLoopObservable=new F.e,this.onAnimationGroupEndObservable=new F.e,this.onAnimationGroupPauseObservable=new F.e,this.onAnimationGroupPlayObservable=new F.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=c||P.b.LastCreatedScene,this._weight=y,this._playOrder=Z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(H,c){const y=new h;y.animation=H,y.target=c;const Z=H.getKeys();return this._from>Z[0].frame&&(this._from=Z[0].frame),this._to<Z[Z.length-1].frame&&(this._to=Z[Z.length-1].frame),null!==this._enableBlending&&(H.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(H.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(y),this._shouldStart=!0,y}removeTargetedAnimation(H){for(let c=this._targetedAnimations.length-1;c>-1;c--){this._targetedAnimations[c].animation===H&&this._targetedAnimations.splice(c,1)}}normalize(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==H&&(H=this._from),null==c&&(c=this._to);for(let y=0;y<this._targetedAnimations.length;y++){const Z=this._targetedAnimations[y].animation.getKeys(),F=Z[0],P=Z[Z.length-1];if(F.frame>H){const c={frame:H,value:F.value,inTangent:F.inTangent,outTangent:F.outTangent,interpolation:F.interpolation};Z.splice(0,0,c)}if(P.frame<c){const H={frame:c,value:P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation};Z.push(H)}}return this._from=H,this._to=c,this}_processLoop(H,c,y){H.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(c),this._animationLoopFlags[y]||(this._animationLoopFlags[y]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0],c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,y=arguments.length>2?arguments[2]:void 0,Z=arguments.length>3?arguments[3]:void 0,F=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=H,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let P=0;P<this._targetedAnimations.length;P++){const S=this._targetedAnimations[P],n=this._scene.beginDirectAnimation(S.target,[S.animation],void 0!==y?y:this._from,void 0!==Z?Z:this._to,H,c,void 0,void 0,void 0!==F?F:this._isAdditive);n.weight=this._weight,n.playOrder=this._playOrder,n.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(S),this._checkAnimationGroupEnded(n)},this._processLoop(n,S,P),this._animatables.push(n)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=c,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let H=0;H<this._animatables.length;H++){this._animatables[H].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(H){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==H&&(this.loopAnimation=H),this.restart()):(this.stop(),this.start(H,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].reset()}return this}restart(){if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const c=this._animatables.slice();for(let Z=0;Z<c.length;Z++)c[Z].stop(void 0,void 0,!0,H);let y=0;for(let Z=0;Z<this._scene._activeAnimatables.length;Z++){const c=this._scene._activeAnimatables[Z];c._runtimeAnimations.length>0?this._scene._activeAnimatables[y++]=c:H&&this._checkAnimationGroupEnded(c,H)}return this._scene._activeAnimatables.length=y,this._isStarted=!1,this}setWeightForAllAnimatables(H){for(let c=0;c<this._animatables.length;c++){this._animatables[c].weight=H}return this}syncAllAnimationsWith(H){for(let c=0;c<this._animatables.length;c++){this._animatables[c].syncWith(H)}return this}goToFrame(H){if(!this._isStarted)return this;for(let c=0;c<this._animatables.length;c++){this._animatables[c].goToFrame(H)}return this}getCurrentFrame(){var H;return(null===(H=this.animatables[0])||void 0===H?void 0:H.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const H=this._scene.animationGroups.indexOf(this);if(H>-1&&this._scene.animationGroups.splice(H,1),this._parentContainer){const H=this._parentContainer.animationGroups.indexOf(this);H>-1&&this._parentContainer.animationGroups.splice(H,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(H){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const y=this._animatables.indexOf(H);y>-1&&this._animatables.splice(y,1),0===this._animatables.length&&(this._isStarted=!1,c||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(H,c){let y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Z=new Q(H||this.name,this._scene,this._weight,this._playOrder);Z._from=this.from,Z._to=this.to,Z._speedRatio=this.speedRatio,Z._loopAnimation=this.loopAnimation,Z._isAdditive=this.isAdditive,Z._enableBlending=this.enableBlending,Z._blendingSpeed=this.blendingSpeed,Z.metadata=this.metadata,Z.mask=this.mask;for(const F of this._targetedAnimations)Z.addTargetedAnimation(y?F.animation.clone():F.animation,c?c(F.target):F.target);return Z}serialize(){const H={};H.name=this.name,H.from=this.from,H.to=this.to,H.speedRatio=this.speedRatio,H.loopAnimation=this.loopAnimation,H.isAdditive=this.isAdditive,H.weight=this.weight,H.playOrder=this.playOrder,H.enableBlending=this.enableBlending,H.blendingSpeed=this.blendingSpeed,H.targetedAnimations=[];for(let c=0;c<this.targetedAnimations.length;c++){const y=this.targetedAnimations[c];H.targetedAnimations[c]=y.serialize()}return S.d&&S.d.HasTags(this)&&(H.tags=S.d.GetTags(this)),this.metadata&&(H.metadata=this.metadata),H}static Parse(H,c){const y=new Q(H.name,c,H.weight,H.playOrder);for(let F=0;F<H.targetedAnimations.length;F++){const P=H.targetedAnimations[F],S=Z.c.Parse(P.animation),n=P.targetId;if("influence"===P.animation.property){const H=c.getMorphTargetById(n);H&&y.addTargetedAnimation(S,H)}else{const H=c.getNodeById(n);null!=H&&y.addTargetedAnimation(S,H)}}return S.d&&S.d.AddTagsTo(y,H.tags),null!==H.from&&null!==H.to&&y.normalize(H.from,H.to),void 0!==H.speedRatio&&(y._speedRatio=H.speedRatio),void 0!==H.loopAnimation&&(y._loopAnimation=H.loopAnimation),void 0!==H.isAdditive&&(y._isAdditive=H.isAdditive),void 0!==H.weight&&(y._weight=H.weight),void 0!==H.playOrder&&(y._playOrder=H.playOrder),void 0!==H.enableBlending&&(y._enableBlending=H.enableBlending),void 0!==H.blendingSpeed&&(y._blendingSpeed=H.blendingSpeed),void 0!==H.metadata&&(y.metadata=H.metadata),y}static MakeAnimationAdditive(H,c,y){let F;F="object"===typeof c?c:{referenceFrame:c,range:y,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let P=H;F.cloneOriginalAnimationGroup&&(P=H.clone(F.clonedAnimationGroupName||P.name));const S=P.targetedAnimations;for(let n=0;n<S.length;n++){const H=S[n];H.animation=Z.c.MakeAnimationAdditive(H.animation,F)}if(P.isAdditive=!0,F.clipKeys){let H=Number.MAX_VALUE,c=-Number.MAX_VALUE;const y=P.targetedAnimations;for(let Z=0;Z<y.length;Z++){const F=y[Z].animation.getKeys();H>F[0].frame&&(H=F[0].frame),c<F[F.length-1].frame&&(c=F[F.length-1].frame)}P._from=H,P._to=c}return P}static ClipKeys(H,c,y,Z,F){const P=H.clone(Z||H.name);return Q.ClipKeysInPlace(P,c,y,F)}static ClipKeysInPlace(H,c,y,Z){return Q.ClipInPlace(H,c,y,Z,!1)}static ClipFrames(H,c,y,Z,F){const P=H.clone(Z||H.name);return Q.ClipFramesInPlace(P,c,y,F)}static ClipFramesInPlace(H,c,y,Z){return Q.ClipInPlace(H,c,y,Z,!0)}static ClipInPlace(H,c,y,Z){let F=arguments.length>4&&void 0!==arguments[4]&&arguments[4],P=Number.MAX_VALUE,S=-Number.MAX_VALUE;const n=H.targetedAnimations;for(let O=0;O<n.length;O++){const H=n[O],a=Z?H.animation:H.animation.clone();F&&(a.createKeyForFrame(c),a.createKeyForFrame(y));const i=a.getKeys(),C=[];let g=Number.MAX_VALUE;for(let Z=0;Z<i.length;Z++){const H=i[Z];if(!F&&Z>=c&&Z<=y||F&&H.frame>=c&&H.frame<=y){const c={frame:H.frame,value:H.value.clone?H.value.clone():H.value,inTangent:H.inTangent,outTangent:H.outTangent,interpolation:H.interpolation,lockedTangent:H.lockedTangent};g===Number.MAX_VALUE&&(g=c.frame),c.frame-=g,C.push(c)}}0!==C.length?(P>C[0].frame&&(P=C[0].frame),S<C[C.length-1].frame&&(S=C[C.length-1].frame),a.setKeys(C,!0),H.animation=a):(n.splice(O,1),O--)}return H._from=P,H._to=S,H}getClassName(){return"AnimationGroup"}toString(H){let c="Name: "+this.name;return c+=", type: "+this.getClassName(),H&&(c+=", from: "+this._from,c+=", to: "+this._to,c+=", isStarted: "+this._isStarted,c+=", speedRatio: "+this._speedRatio,c+=", targetedAnimations length: "+this._targetedAnimations.length,c+=", animatables length: "+this._animatables),c}}}}]);