"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13377:(E,b,h)=>{h.r(b),h.d(b,{AnimationGroup:()=>M,TargetedAnimation:()=>S});var a=h(12145),k=h(10824),G=h(10869),V=h(11170),l=h(12141),O=h(11175);class v{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(E,b,h,k){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=b,this._target=E,this._scene=h,this._host=k,this._activeTargets=[],b._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===a.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=O.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const E={frame:0,value:this._minValue};this._keys.splice(0,0,E)}if(this._target instanceof Array){let E=0;for(const b of this._target)this._preparePath(b,E),this._getOriginalValues(E),E++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const G=b.getEvents();G&&G.length>0&&G.forEach((E=>{this._events.push(E._clone())})),this._enableBlending=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(E){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const h=this._animation.targetPropertyPath;if(h.length>1){let a=E;for(let E=0;E<h.length-1;E++){const b=h[E];if(a=a[b],void 0===a)throw new Error(`Invalid property (${b}) in property path (${h.join(".")})`)}this._targetPath=h[h.length-1],this._activeTargets[b]=a}else this._targetPath=h[0],this._activeTargets[b]=E;if(void 0===this._activeTargets[b][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${h.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let E=0;for(const b of this._target)void 0!==this._originalValue[E]&&this._setValue(b,this._activeTargets[E],this._originalValue[E],-1,E),E++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let E=0;E<this._events.length;E++)this._events[E].isDone=!1}isStopped(){return this._stopped}dispose(){const E=this._animation.runtimeAnimations.indexOf(this);E>-1&&this._animation.runtimeAnimations.splice(E,1)}setValue(E,b){if(this._targetIsArray)for(let h=0;h<this._target.length;h++){const a=this._target[h];this._setValue(a,this._activeTargets[h],E,b,h)}else this._setValue(this._target,this._directTarget,E,b,0)}_getOriginalValues(){let E,b=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=this._activeTargets[b];E=h.getLocalMatrix&&"_matrix"===this._targetPath?h.getLocalMatrix():h[this._targetPath],E&&E.clone?this._originalValue[b]=E.clone():this._originalValue[b]=E}_registerTargetForLateAnimationBinding(E,b){const h=E.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(h),h._lateAnimationHolders||(h._lateAnimationHolders={}),h._lateAnimationHolders[E.targetPath]||(h._lateAnimationHolders[E.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:b}),E.isAdditive?(h._lateAnimationHolders[E.targetPath].additiveAnimations.push(E),h._lateAnimationHolders[E.targetPath].totalAdditiveWeight+=E.weight):(h._lateAnimationHolders[E.targetPath].animations.push(E),h._lateAnimationHolders[E.targetPath].totalWeight+=E.weight)}_setValue(E,b,h,k,G){if(this._currentActiveTarget=b,this._weight=k,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const E=b[this._targetPath];E.clone?this._originalBlendValue=E.clone():this._originalBlendValue=E}this._originalBlendValue.m?a.c.AllowMatrixDecomposeForInterpolation?this._currentValue?O.d.DecomposeLerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=O.d.DecomposeLerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue?O.d.LerpToRef(this._originalBlendValue,h,this._blendingFactor,this._currentValue):this._currentValue=O.d.Lerp(this._originalBlendValue,h,this._blendingFactor):this._currentValue=a.c._UniversalLerp(this._originalBlendValue,h,this._blendingFactor);const k=E&&E.animationPropertiesOverride?E.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=k}else this._currentValue?this._currentValue.p?this._currentValue.p(h):this._currentValue=h:null!==h&&void 0!==h&&h.clone?this._currentValue=h.clone():this._currentValue=h;-1!==k?this._registerTargetForLateAnimationBinding(this,this._originalValue[G]):this._animationState.loopMode===a.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[G],b[this._targetPath]):b[this._targetPath]=this._originalValue[G]+this._currentValue:b[this._targetPath]=this._currentValue,E.ah&&E.ah(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(E){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const h=this._animation.getKeys();E<h[0].frame?E=h[0].frame:E>h[h.length-1].frame&&(E=h[h.length-1].frame);const a=this._events;if(a.length)for(let G=0;G<a.length;G++)a[G].onlyOnce||(a[G].isDone=a[G].frame<E);this._currentFrame=E;const k=this._animation._interpolate(E,this._animationState);this.setValue(k,b)}_prepareForSpeedRatioChange(E){const b=this._previousElapsedTime*(this._animation.framePerSecond*E)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-b}animate(E,b,h,k,G){let V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const l=this._animation,O=l.targetPropertyPath;if(!O||O.length<1)return this._stopped=!0,!1;let v=!0;(b<this._minFrame||b>this._maxFrame)&&(b=this._minFrame),(h<this._minFrame||h>this._maxFrame)&&(h=this._maxFrame);const s=h-b;let U,B=E*(l.framePerSecond*G)/1e3+this._absoluteFrameOffset,o=0,u=!1;const D=k&&this._animationState.loopMode===a.c.ANIMATIONLOOPMODE_YOYO;if(D){const E=(B-b)/s,h=Math.sin(E*Math.PI);B=Math.abs(h)*s+b;const a=h>=0?1:-1;this._yoyoDirection!==a&&(u=!0),this._yoyoDirection=a}if(this._previousElapsedTime=E,this._previousAbsoluteFrame=B,!k&&h>=b&&(B>=s&&G>0||B<=0&&G<0))v=!1,o=l._getKeyValue(this._maxValue);else if(!k&&b>=h&&(B<=s&&G<0||B>=0&&G>0))v=!1,o=l._getKeyValue(this._minValue);else if(this._animationState.loopMode!==a.c.ANIMATIONLOOPMODE_CYCLE){const E=h.toString()+b.toString();if(!this._offsetsCache[E]){this._animationState.repeatCount=0,this._animationState.loopMode=a.c.ANIMATIONLOOPMODE_CYCLE;const k=l._interpolate(b,this._animationState),G=l._interpolate(h,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),l.dataType){case a.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[E]=G-k;break;case a.c.ANIMATIONTYPE_QUATERNION:case a.c.ANIMATIONTYPE_VECTOR3:case a.c.ANIMATIONTYPE_VECTOR2:case a.c.ANIMATIONTYPE_SIZE:case a.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[E]=G.Xc(k)}this._highLimitsCache[E]=G}o=this._highLimitsCache[E],U=this._offsetsCache[E]}if(void 0===U)switch(l.dataType){case a.c.ANIMATIONTYPE_FLOAT:U=0;break;case a.c.ANIMATIONTYPE_QUATERNION:U=a.i;break;case a.c.ANIMATIONTYPE_VECTOR3:U=a.t;break;case a.c.ANIMATIONTYPE_VECTOR2:U=a.p;break;case a.c.ANIMATIONTYPE_SIZE:U=a.m;break;case a.c.ANIMATIONTYPE_COLOR3:U=a.d;break;case a.c.ANIMATIONTYPE_COLOR4:U=a.e}let g;if(this._host&&this._host.syncRoot){const E=this._host.syncRoot;g=b+s*((E.masterFrame-E.fromFrame)/(E.toFrame-E.fromFrame))}else g=B>0&&b>h||B<0&&b<h?v&&0!==s?h+B%s:b:v&&0!==s?b+B%s:h;const S=this._events;if(!D&&(G>0&&this.currentFrame>g||G<0&&this.currentFrame<g)||D&&u){this._onLoop();for(let E=0;E<S.length;E++)S[E].onlyOnce||(S[E].isDone=!1);this._animationState.key=G>0?0:l.getKeys().length-1}this._currentFrame=g,this._animationState.repeatCount=0===s?0:B/s|0,this._animationState.highLimitValue=o,this._animationState.offsetValue=U;const M=l._interpolate(g,this._animationState);if(this.setValue(M,V),S.length)for(let a=0;a<S.length;a++)if(s>=0&&g>=S[a].frame&&S[a].frame>=b||s<0&&g<=S[a].frame&&S[a].frame<=b){const E=S[a];E.isDone||(E.onlyOnce&&(S.splice(a,1),a--),E.isDone=!0,E.action(g))}return v||(this._stopped=!0),v}}var s=h(10846);class U{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(E){this._weight=-1!==E?Math.min(Math.max(E,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(E){for(let b=0;b<this._runtimeAnimations.length;b++){this._runtimeAnimations[b]._prepareForSpeedRatioChange(E)}this._speedRatio=E,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(E,b){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,G=arguments.length>4&&void 0!==arguments[4]&&arguments[4],V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,l=arguments.length>6?arguments[6]:void 0,O=arguments.length>7?arguments[7]:void 0,v=arguments.length>8?arguments[8]:void 0,s=arguments.length>9&&void 0!==arguments[9]&&arguments[9],U=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=b,this.fromFrame=h,this.toFrame=a,this.loopAnimation=G,this.onAnimationEnd=l,this.onAnimationLoop=v,this.isAdditive=s,this.playOrder=U,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Md=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new k.e,this.onAnimationLoopObservable=new k.e,this._scene=E,O&&this.appendAnimations(b,O),this._speedRatio=V,E._activeAnimatables.push(this)}syncWith(E){if(this._syncRoot=E,E){const E=this._scene._activeAnimatables.indexOf(this);E>-1&&(this._scene._activeAnimatables.splice(E,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(E,b){for(let h=0;h<b.length;h++){const a=b[h],k=new v(E,a,this._scene,this);k._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(k)}}getAnimationByTargetProperty(E){const b=this._runtimeAnimations;for(let h=0;h<b.length;h++)if(b[h].animation.targetProperty===E)return b[h].animation;return null}getRuntimeAnimationByTargetProperty(E){const b=this._runtimeAnimations;for(let h=0;h<b.length;h++)if(b[h].animation.targetProperty===E)return b[h];return null}reset(){const E=this._runtimeAnimations;for(let b=0;b<E.length;b++)E[b].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(E){const b=this._runtimeAnimations;for(let h=0;h<b.length;h++)b[h].animation.enableBlending=!0,b[h].animation.blendingSpeed=E}disableBlending(){const E=this._runtimeAnimations;for(let b=0;b<E.length;b++)E[b].animation.enableBlending=!1}goToFrame(E){const b=this._runtimeAnimations;if(b[0]){const h=b[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??b[0].currentFrame;const a=0===this.speedRatio?0:(E-this._frameToSyncFromJump)/h*1e3/this.speedRatio;this._manualJumpDelay=-a}for(let h=0;h<b.length;h++)b[h].goToFrame(E,this._weight);this._goToFrame=E}get paused(){return this.Md}pause(){this.Md||(this.Md=!0)}restart(){this.Md=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(E,b){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(E||b){const k=this._scene._activeAnimatables.indexOf(this);if(k>-1){const G=this._runtimeAnimations;for(let h=G.length-1;h>=0;h--){const a=G[h];E&&a.animation.name!=E||(b&&!b(a.target)||(a.dispose(),G.splice(h,1)))}0==G.length&&(h||this._scene._activeAnimatables.splice(k,1),a||this._raiseOnAnimationEnd())}}else{const E=this._scene._activeAnimatables.indexOf(this);if(E>-1){h||this._scene._activeAnimatables.splice(E,1);const b=this._runtimeAnimations;for(let E=0;E<b.length;E++)b[E].dispose();this._runtimeAnimations.length=0,a||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((E=>{this.onAnimationEndObservable.add((()=>{E(this)}),void 0,void 0,this,!0)}))}_animate(E){if(this.Md)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=E),!0;if(null===this._localDelayOffset?(this._localDelayOffset=E,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=E-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let b=!1;const h=this._runtimeAnimations;let a;for(a=0;a<h.length;a++){const k=h[a].animate(E-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);b=b||k}if(this.animationStarted=b,!b){if(this.disposeOnEnd)for(a=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(a,1),a=0;a<h.length;a++)h[a].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return b}}function B(E){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return E.originalValue;let b=1;const h=O.h.o[0],a=O.h.o[1],k=O.h.Quaternion[0];let G=0;const V=E.animations[0],l=E.originalValue;let v=1,s=!1;if(E.totalWeight<1)v=1-E.totalWeight,l.decompose(a,k,h);else{if(G=1,b=E.totalWeight,v=V.weight/b,1==v){if(!E.totalAdditiveWeight)return V.currentValue;s=!0}V.currentValue.decompose(a,k,h)}if(!s){a.scaleInPlace(v),h.scaleInPlace(v),k.scaleInPlace(v);for(let V=G;V<E.animations.length;V++){const G=E.animations[V];if(0===G.weight)continue;v=G.weight/b;const l=O.h.o[2],s=O.h.o[3],U=O.h.Quaternion[1];G.currentValue.decompose(s,U,l),s.scaleAndAddToRef(v,a),U.scaleAndAddToRef(O.g.Dot(k,U)>0?v:-v,k),l.scaleAndAddToRef(v,h)}k.normalize()}for(let B=0;B<E.additiveAnimations.length;B++){const b=E.additiveAnimations[B];if(0===b.weight)continue;const G=O.h.o[2],V=O.h.o[3],l=O.h.Quaternion[1];b.currentValue.decompose(V,l,G),V.multiplyToRef(a,V),O.k.LerpToRef(a,V,b.weight,a),k.multiplyToRef(l,l),O.g.SlerpToRef(k,l,b.weight,k),G.scaleAndAddToRef(b.weight,h)}const U=V?V._animationState.workValue:O.h.Matrix[0].clone();return O.d.ComposeToRef(a,k,h,U),U}function o(E,b){if(0===E.totalWeight&&0===E.totalAdditiveWeight)return b;const h=E.animations[0],a=E.originalValue;let k=b;if(0===E.totalWeight&&E.totalAdditiveWeight>0)k.p(a);else if(1===E.animations.length){if(O.g.SlerpToRef(a,h.currentValue,Math.min(1,E.totalWeight),k),0===E.totalAdditiveWeight)return k}else if(E.animations.length>1){let h,G,V=1;if(E.totalWeight<1){const b=1-E.totalWeight;h=[],G=[],h.push(a),G.push(b)}else{if(2===E.animations.length&&(O.g.SlerpToRef(E.animations[0].currentValue,E.animations[1].currentValue,E.animations[1].weight/E.totalWeight,b),0===E.totalAdditiveWeight))return b;h=[],G=[],V=E.totalWeight}for(let b=0;b<E.animations.length;b++){const a=E.animations[b];h.push(a.currentValue),G.push(a.weight/V)}let l=0;for(let E=0;E<h.length;)E?(l+=G[E],O.g.SlerpToRef(k,h[E],G[E]/l,k),E++):(O.g.SlerpToRef(h[E],h[E+1],G[E+1]/(G[E]+G[E+1]),b),k=b,l=G[E]+G[E+1],E+=2)}for(let G=0;G<E.additiveAnimations.length;G++){const b=E.additiveAnimations[G];0!==b.weight&&(k.multiplyToRef(b.currentValue,O.h.Quaternion[0]),O.g.SlerpToRef(k,O.h.Quaternion[0],b.weight,k))}return k}var u,D,g=h(11163);u=g.e,(D=l.e)&&(D.prototype.copyAnimationRange=function(E,b,h){let k=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new a.c(this.name,"_matrix",E.animations[0].framePerSecond,a.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const V=E.animations[0].getRange(b);if(!V)return!1;const l=V.from,O=V.to,v=E.animations[0].getKeys(),s=E.length,U=E.getParent(),B=this.getParent(),o=k&&U&&s&&this.length&&s!==this.length,u=o&&B&&U?B.length/U.length:1,D=k&&!B&&G&&(1!==G.x||1!==G.y||1!==G.z),g=this.animations[0].getKeys();let S,M,I;for(let a=0,j=v.length;a<j;a++)S=v[a],S.frame>=l&&S.frame<=O&&(k?(I=S.value.clone(),o?(M=I.getTranslation(),I.setTranslation(M.scaleInPlace(u))):D&&G?(M=I.getTranslation(),I.setTranslation(M.multiplyInPlace(G))):I=S.value):I=S.value,g.push({frame:S.frame+h,value:I}));return this.animations[0].createRange(b,l+h,O+h),!0}),u&&(u.prototype._animate=function(E){if(!this.animationsEnabled)return;const b=s.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=b}this.deltaTime=void 0!==E?E:this.useConstantAnimationDeltaTime?16:(b-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=b;const h=this._activeAnimatables;if(0===h.length)return;this._animationTime+=this.deltaTime;const k=this._animationTime;for(let a=0;a<h.length;a++){const E=h[a];!E._animate(k)&&E.disposeOnEnd&&a--}!function(E){if(E._registeredForLateAnimationBindings.length){for(let b=0;b<E._registeredForLateAnimationBindings.length;b++){const h=E._registeredForLateAnimationBindings.data[b];for(const E in h._lateAnimationHolders){const b=h._lateAnimationHolders[E],k=b.animations[0],G=b.originalValue;if(void 0===G||null===G)continue;const V=a.c.AllowMatrixDecomposeForInterpolation&&G.m;let l=h[E];if(V)l=B(b);else if(void 0!==G.w)l=o(b,l||O.g.Identity());else{let E=0,h=1;const V=k&&k._animationState.loopMode===a.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(b.totalWeight<1)l=V?G.clone?G.clone():G:k&&G.scale?G.scale(1-b.totalWeight):k?G*(1-b.totalWeight):G.clone?G.clone():G;else if(k){h=b.totalWeight;const a=k.weight/h;l=1!==a?k.currentValue.scale?k.currentValue.scale(a):k.currentValue*a:k.currentValue,V&&(l.addToRef?l.addToRef(G,l):l+=G),E=1}for(let a=E;a<b.animations.length;a++){const E=b.animations[a],k=E.weight/h;k&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(k,l):l+=E.currentValue*k)}for(let a=0;a<b.additiveAnimations.length;a++){const E=b.additiveAnimations[a],h=E.weight;h&&(E.currentValue.scaleAndAddToRef?E.currentValue.scaleAndAddToRef(h,l):l+=E.currentValue*h)}}h[E]=l}h._lateAnimationHolders={}}E._registeredForLateAnimationBindings.reset()}}(this)},u.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((E,b)=>E.playOrder-b.playOrder))},u.prototype.beginWeightedAnimation=function(E,b,h){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,k=arguments.length>4?arguments[4]:void 0,G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,O=arguments.length>8?arguments[8]:void 0,v=arguments.length>9?arguments[9]:void 0,s=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const U=this.beginAnimation(E,b,h,k,G,V,l,!1,O,v,s);return U.weight=a,U},u.prototype.beginAnimation=function(E,b,h,a){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,G=arguments.length>5?arguments[5]:void 0,V=arguments.length>6?arguments[6]:void 0,l=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],O=arguments.length>8?arguments[8]:void 0,v=arguments.length>9?arguments[9]:void 0,s=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(k<0){const E=b;b=h,h=E,k=-k}b>h&&(k=-k),l&&this.stopAnimation(E,void 0,O),V||(V=new U(this,E,b,h,a,k,G,void 0,v,s));const B=!O||O(E);if(E.animations&&B&&V.appendAnimations(E,E.animations),E.getAnimatables){const s=E.getAnimatables();for(let E=0;E<s.length;E++)this.beginAnimation(s[E],b,h,a,k,G,V,l,O,v)}return V.reset(),V},u.prototype.beginHierarchyAnimation=function(E,b,h,a,k){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,V=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,O=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],v=arguments.length>9?arguments[9]:void 0,s=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const U=E.getDescendants(b),B=[];B.push(this.beginAnimation(E,h,a,k,G,V,l,O,v,void 0,s));for(const o of U)B.push(this.beginAnimation(o,h,a,k,G,V,l,O,v,void 0,s));return B},u.prototype.beginDirectAnimation=function(E,b,h,a,k){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(G<0){const E=h;h=a,a=E,G=-G}return h>a&&(G=-G),new U(this,E,h,a,k,G,arguments.length>6?arguments[6]:void 0,b,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},u.prototype.beginDirectHierarchyAnimation=function(E,b,h,a,k,G,V,l,O){let v=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const s=E.getDescendants(b),U=[];U.push(this.beginDirectAnimation(E,h,a,k,G,V,l,O,v));for(const B of s)U.push(this.beginDirectAnimation(B,h,a,k,G,V,l,O,v));return U},u.prototype.getAnimatableByTarget=function(E){for(let b=0;b<this._activeAnimatables.length;b++)if(this._activeAnimatables[b].target===E)return this._activeAnimatables[b];return null},u.prototype.getAllAnimatablesByTarget=function(E){const b=[];for(let h=0;h<this._activeAnimatables.length;h++)this._activeAnimatables[h].target===E&&b.push(this._activeAnimatables[h]);return b},u.prototype.stopAnimation=function(E,b,h){const a=this.getAllAnimatablesByTarget(E);for(const k of a)k.stop(b,h)},u.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const E of this.animationGroups)E.stop()});class S{getClassName(){return"TargetedAnimation"}serialize(){const E={};return E.animation=this.animation.serialize(),E.targetId=this.target.id,E}}class M{get mask(){return this._mask}set mask(E){this._mask!==E&&(this._mask=E,this.syncWithMask(!0))}syncWithMask(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||E){this._numActiveAnimatables=0;for(let E=0;E<this._animatables.length;++E){const b=this._animatables[E];!this.mask||this.mask.disabled||this.mask.retainsTarget(b.target.name)?(this._numActiveAnimatables++,b.paused&&b.restart()):b.paused||b.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let E=0;E<this._animatables.length;++E){const b=this._animatables[E];this.mask.retainsTarget(b.target.name)||(b.stop(),this._animatables.splice(E,1),--E)}for(let E=0;E<this._targetedAnimations.length;E++){const b=this._targetedAnimations[E];this.mask.retainsTarget(b.target.name)||(this._targetedAnimations.splice(E,1),--E)}}}get from(){return this._from}set from(E){if(this._from!==E){this._from=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].fromFrame=this._from}}}get to(){return this._to}set to(E){if(this._to!==E){this._to=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(E){if(this._speedRatio!==E){this._speedRatio=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(E){if(this._loopAnimation!==E){this._loopAnimation=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(E){if(this._isAdditive!==E){this._isAdditive=E;for(let E=0;E<this._animatables.length;E++){this._animatables[E].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(E){this._weight!==E&&(this._weight=E,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(E){if(this._playOrder!==E&&(this._playOrder=E,this._animatables.length>0)){for(let E=0;E<this._animatables.length;E++)this._animatables[E].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(E){if(this._enableBlending!==E&&(this._enableBlending=E,null!==E))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.enableBlending=E}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(E){if(this._blendingSpeed!==E&&(this._blendingSpeed=E,null!==E))for(let b=0;b<this._targetedAnimations.length;++b)this._targetedAnimations[b].animation.blendingSpeed=E}getLength(E,b){E=E??this._from;return((b=b??this._to)-E)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(E){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0;if(0===E.length)return null;a=a??E[0].weight;let k=Number.MAX_VALUE,G=-Number.MAX_VALUE;if(h)for(const l of E)l.from<k&&(k=l.from),l.to>G&&(G=l.to);const V=new M(E[0].name+"_merged",E[0]._scene,a);for(const l of E){h&&l.normalize(k,G);for(const E of l.targetedAnimations)V.addTargetedAnimation(E.animation,E.target);b&&l.dispose()}return V}constructor(E){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=E,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new k.e,this.onAnimationLoopObservable=new k.e,this.onAnimationGroupLoopObservable=new k.e,this.onAnimationGroupEndObservable=new k.e,this.onAnimationGroupPauseObservable=new k.e,this.onAnimationGroupPlayObservable=new k.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=b||G.b.LastCreatedScene,this._weight=h,this._playOrder=a,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(E,b){const h=new S;h.animation=E,h.target=b;const a=E.getKeys();return this._from>a[0].frame&&(this._from=a[0].frame),this._to<a[a.length-1].frame&&(this._to=a[a.length-1].frame),null!==this._enableBlending&&(E.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(E.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(h),this._shouldStart=!0,h}removeTargetedAnimation(E){for(let b=this._targetedAnimations.length-1;b>-1;b--){this._targetedAnimations[b].animation===E&&this._targetedAnimations.splice(b,1)}}normalize(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==E&&(E=this._from),null==b&&(b=this._to);for(let h=0;h<this._targetedAnimations.length;h++){const a=this._targetedAnimations[h].animation.getKeys(),k=a[0],G=a[a.length-1];if(k.frame>E){const b={frame:E,value:k.value,inTangent:k.inTangent,outTangent:k.outTangent,interpolation:k.interpolation};a.splice(0,0,b)}if(G.frame<b){const E={frame:b,value:G.value,inTangent:G.inTangent,outTangent:G.outTangent,interpolation:G.interpolation};a.push(E)}}return this._from=E,this._to=b,this}_processLoop(E,b,h){E.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(b),this._animationLoopFlags[h]||(this._animationLoopFlags[h]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0],b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,h=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,k=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=E,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let G=0;G<this._targetedAnimations.length;G++){const V=this._targetedAnimations[G],l=this._scene.beginDirectAnimation(V.target,[V.animation],void 0!==h?h:this._from,void 0!==a?a:this._to,E,b,void 0,void 0,void 0!==k?k:this._isAdditive);l.weight=this._weight,l.playOrder=this._playOrder,l.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(V),this._checkAnimationGroupEnded(l)},this._processLoop(l,V,G),this._animatables.push(l)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=b,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let E=0;E<this._animatables.length;E++){this._animatables[E].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(E){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==E&&(this.loopAnimation=E),this.restart()):(this.stop(),this.start(E,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].reset()}return this}restart(){if(!this._isStarted)return this;for(let E=0;E<this._animatables.length;E++){this._animatables[E].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const b=this._animatables.slice();for(let a=0;a<b.length;a++)b[a].stop(void 0,void 0,!0,E);let h=0;for(let a=0;a<this._scene._activeAnimatables.length;a++){const b=this._scene._activeAnimatables[a];b._runtimeAnimations.length>0?this._scene._activeAnimatables[h++]=b:E&&this._checkAnimationGroupEnded(b,E)}return this._scene._activeAnimatables.length=h,this._isStarted=!1,this}setWeightForAllAnimatables(E){for(let b=0;b<this._animatables.length;b++){this._animatables[b].weight=E}return this}syncAllAnimationsWith(E){for(let b=0;b<this._animatables.length;b++){this._animatables[b].syncWith(E)}return this}goToFrame(E){if(!this._isStarted)return this;for(let b=0;b<this._animatables.length;b++){this._animatables[b].goToFrame(E)}return this}getCurrentFrame(){var E;return(null===(E=this.animatables[0])||void 0===E?void 0:E.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const E=this._scene.animationGroups.indexOf(this);if(E>-1&&this._scene.animationGroups.splice(E,1),this._parentContainer){const E=this._parentContainer.animationGroups.indexOf(this);E>-1&&this._parentContainer.animationGroups.splice(E,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(E){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const h=this._animatables.indexOf(E);h>-1&&this._animatables.splice(h,1),0===this._animatables.length&&(this._isStarted=!1,b||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(E,b){let h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=new M(E||this.name,this._scene,this._weight,this._playOrder);a._from=this.from,a._to=this.to,a._speedRatio=this.speedRatio,a._loopAnimation=this.loopAnimation,a._isAdditive=this.isAdditive,a._enableBlending=this.enableBlending,a._blendingSpeed=this.blendingSpeed,a.metadata=this.metadata,a.mask=this.mask;for(const k of this._targetedAnimations)a.addTargetedAnimation(h?k.animation.clone():k.animation,b?b(k.target):k.target);return a}serialize(){const E={};E.name=this.name,E.from=this.from,E.to=this.to,E.speedRatio=this.speedRatio,E.loopAnimation=this.loopAnimation,E.isAdditive=this.isAdditive,E.weight=this.weight,E.playOrder=this.playOrder,E.enableBlending=this.enableBlending,E.blendingSpeed=this.blendingSpeed,E.targetedAnimations=[];for(let b=0;b<this.targetedAnimations.length;b++){const h=this.targetedAnimations[b];E.targetedAnimations[b]=h.serialize()}return V.b&&V.b.HasTags(this)&&(E.tags=V.b.GetTags(this)),this.metadata&&(E.metadata=this.metadata),E}static Parse(E,b){const h=new M(E.name,b,E.weight,E.playOrder);for(let k=0;k<E.targetedAnimations.length;k++){const G=E.targetedAnimations[k],V=a.c.Parse(G.animation),l=G.targetId;if("influence"===G.animation.property){const E=b.getMorphTargetById(l);E&&h.addTargetedAnimation(V,E)}else{const E=b.getNodeById(l);null!=E&&h.addTargetedAnimation(V,E)}}return V.b&&V.b.AddTagsTo(h,E.tags),null!==E.from&&null!==E.to&&h.normalize(E.from,E.to),void 0!==E.speedRatio&&(h._speedRatio=E.speedRatio),void 0!==E.loopAnimation&&(h._loopAnimation=E.loopAnimation),void 0!==E.isAdditive&&(h._isAdditive=E.isAdditive),void 0!==E.weight&&(h._weight=E.weight),void 0!==E.playOrder&&(h._playOrder=E.playOrder),void 0!==E.enableBlending&&(h._enableBlending=E.enableBlending),void 0!==E.blendingSpeed&&(h._blendingSpeed=E.blendingSpeed),void 0!==E.metadata&&(h.metadata=E.metadata),h}static MakeAnimationAdditive(E,b,h){let k;k="object"===typeof b?b:{referenceFrame:b,range:h,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let G=E;k.cloneOriginalAnimationGroup&&(G=E.clone(k.clonedAnimationGroupName||G.name));const V=G.targetedAnimations;for(let l=0;l<V.length;l++){const E=V[l];E.animation=a.c.MakeAnimationAdditive(E.animation,k)}if(G.isAdditive=!0,k.clipKeys){let E=Number.MAX_VALUE,b=-Number.MAX_VALUE;const h=G.targetedAnimations;for(let a=0;a<h.length;a++){const k=h[a].animation.getKeys();E>k[0].frame&&(E=k[0].frame),b<k[k.length-1].frame&&(b=k[k.length-1].frame)}G._from=E,G._to=b}return G}static ClipKeys(E,b,h,a,k){const G=E.clone(a||E.name);return M.ClipKeysInPlace(G,b,h,k)}static ClipKeysInPlace(E,b,h,a){return M.ClipInPlace(E,b,h,a,!1)}static ClipFrames(E,b,h,a,k){const G=E.clone(a||E.name);return M.ClipFramesInPlace(G,b,h,k)}static ClipFramesInPlace(E,b,h,a){return M.ClipInPlace(E,b,h,a,!0)}static ClipInPlace(E,b,h,a){let k=arguments.length>4&&void 0!==arguments[4]&&arguments[4],G=Number.MAX_VALUE,V=-Number.MAX_VALUE;const l=E.targetedAnimations;for(let O=0;O<l.length;O++){const E=l[O],v=a?E.animation:E.animation.clone();k&&(v.createKeyForFrame(b),v.createKeyForFrame(h));const s=v.getKeys(),U=[];let B=Number.MAX_VALUE;for(let a=0;a<s.length;a++){const E=s[a];if(!k&&a>=b&&a<=h||k&&E.frame>=b&&E.frame<=h){const b={frame:E.frame,value:E.value.clone?E.value.clone():E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation,lockedTangent:E.lockedTangent};B===Number.MAX_VALUE&&(B=b.frame),b.frame-=B,U.push(b)}}0!==U.length?(G>U[0].frame&&(G=U[0].frame),V<U[U.length-1].frame&&(V=U[U.length-1].frame),v.setKeys(U,!0),E.animation=v):(l.splice(O,1),O--)}return E._from=G,E._to=V,E}getClassName(){return"AnimationGroup"}toString(E){let b="Name: "+this.name;return b+=", type: "+this.getClassName(),E&&(b+=", from: "+this._from,b+=", to: "+this._to,b+=", isStarted: "+this._isStarted,b+=", speedRatio: "+this._speedRatio,b+=", targetedAnimations length: "+this._targetedAnimations.length,b+=", animatables length: "+this._animatables),b}}}}]);