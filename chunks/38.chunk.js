"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13262:(R,q,L)=>{L.r(q),L.d(q,{AnimationGroup:()=>d,TargetedAnimation:()=>c});var B=L(12047),N=L(10760),h=L(10797),Z=L(11074),z=L(12039),Y=L(11081);class F{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(R,q,L,N){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=q,this._target=R,this._scene=L,this._host=N,this._activeTargets=[],q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===B.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=Y.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const R={frame:0,value:this._minValue};this._keys.splice(0,0,R)}if(this._target instanceof Array){let R=0;for(const q of this._target)this._preparePath(q,R),this._getOriginalValues(R),R++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const h=q.getEvents();h&&h.length>0&&h.forEach((R=>{this._events.push(R._clone())})),this._enableBlending=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(R){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const L=this._animation.targetPropertyPath;if(L.length>1){let B=R;for(let R=0;R<L.length-1;R++){const q=L[R];if(B=B[q],void 0===B)throw new Error(`Invalid property (${q}) in property path (${L.join(".")})`)}this._targetPath=L[L.length-1],this._activeTargets[q]=B}else this._targetPath=L[0],this._activeTargets[q]=R;if(void 0===this._activeTargets[q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${L.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let R=0;for(const q of this._target)void 0!==this._originalValue[R]&&this._setValue(q,this._activeTargets[R],this._originalValue[R],-1,R),R++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let R=0;R<this._events.length;R++)this._events[R].isDone=!1}isStopped(){return this._stopped}dispose(){const R=this._animation.runtimeAnimations.indexOf(this);R>-1&&this._animation.runtimeAnimations.splice(R,1)}setValue(R,q){if(this._targetIsArray)for(let L=0;L<this._target.length;L++){const B=this._target[L];this._setValue(B,this._activeTargets[L],R,q,L)}else this._setValue(this._target,this._directTarget,R,q,0)}_getOriginalValues(){let R,q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const L=this._activeTargets[q];R=L.getLocalMatrix&&"_matrix"===this._targetPath?L.getLocalMatrix():L[this._targetPath],R&&R.clone?this._originalValue[q]=R.clone():this._originalValue[q]=R}_registerTargetForLateAnimationBinding(R,q){const L=R.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(L),L._lateAnimationHolders||(L._lateAnimationHolders={}),L._lateAnimationHolders[R.targetPath]||(L._lateAnimationHolders[R.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:q}),R.isAdditive?(L._lateAnimationHolders[R.targetPath].additiveAnimations.push(R),L._lateAnimationHolders[R.targetPath].totalAdditiveWeight+=R.weight):(L._lateAnimationHolders[R.targetPath].animations.push(R),L._lateAnimationHolders[R.targetPath].totalWeight+=R.weight)}_setValue(R,q,L,N,h){if(this._currentActiveTarget=q,this._weight=N,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const R=q[this._targetPath];R.clone?this._originalBlendValue=R.clone():this._originalBlendValue=R}this._originalBlendValue.m?B.b.AllowMatrixDecomposeForInterpolation?this._currentValue?Y.c.DecomposeLerpToRef(this._originalBlendValue,L,this._blendingFactor,this._currentValue):this._currentValue=Y.c.DecomposeLerp(this._originalBlendValue,L,this._blendingFactor):this._currentValue?Y.c.LerpToRef(this._originalBlendValue,L,this._blendingFactor,this._currentValue):this._currentValue=Y.c.Lerp(this._originalBlendValue,L,this._blendingFactor):this._currentValue=B.b._UniversalLerp(this._originalBlendValue,L,this._blendingFactor);const N=R&&R.animationPropertiesOverride?R.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=N}else this._currentValue?this._currentValue.p?this._currentValue.p(L):this._currentValue=L:null!==L&&void 0!==L&&L.clone?this._currentValue=L.clone():this._currentValue=L;-1!==N?this._registerTargetForLateAnimationBinding(this,this._originalValue[h]):this._animationState.loopMode===B.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[h],q[this._targetPath]):q[this._targetPath]=this._originalValue[h]+this._currentValue:q[this._targetPath]=this._currentValue,R.Ag&&R.Ag(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(R){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const L=this._animation.getKeys();R<L[0].frame?R=L[0].frame:R>L[L.length-1].frame&&(R=L[L.length-1].frame);const B=this._events;if(B.length)for(let h=0;h<B.length;h++)B[h].onlyOnce||(B[h].isDone=B[h].frame<R);this._currentFrame=R;const N=this._animation._interpolate(R,this._animationState);this.setValue(N,q)}_prepareForSpeedRatioChange(R){const q=this._previousElapsedTime*(this._animation.framePerSecond*R)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-q}animate(R,q,L,N,h){let Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const z=this._animation,Y=z.targetPropertyPath;if(!Y||Y.length<1)return this._stopped=!0,!1;let F=!0;(q<this._minFrame||q>this._maxFrame)&&(q=this._minFrame),(L<this._minFrame||L>this._maxFrame)&&(L=this._maxFrame);const C=L-q;let e,y=R*(z.framePerSecond*h)/1e3+this._absoluteFrameOffset,U=0,n=!1;const r=N&&this._animationState.loopMode===B.b.ANIMATIONLOOPMODE_YOYO;if(r){const R=(y-q)/C,L=Math.sin(R*Math.PI);y=Math.abs(L)*C+q;const B=L>=0?1:-1;this._yoyoDirection!==B&&(n=!0),this._yoyoDirection=B}if(this._previousElapsedTime=R,this._previousAbsoluteFrame=y,!N&&L>=q&&(y>=C&&h>0||y<=0&&h<0))F=!1,U=z._getKeyValue(this._maxValue);else if(!N&&q>=L&&(y<=C&&h<0||y>=0&&h>0))F=!1,U=z._getKeyValue(this._minValue);else if(this._animationState.loopMode!==B.b.ANIMATIONLOOPMODE_CYCLE){const R=L.toString()+q.toString();if(!this._offsetsCache[R]){this._animationState.repeatCount=0,this._animationState.loopMode=B.b.ANIMATIONLOOPMODE_CYCLE;const N=z._interpolate(q,this._animationState),h=z._interpolate(L,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),z.dataType){case B.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[R]=h-N;break;case B.b.ANIMATIONTYPE_QUATERNION:case B.b.ANIMATIONTYPE_VECTOR3:case B.b.ANIMATIONTYPE_VECTOR2:case B.b.ANIMATIONTYPE_SIZE:case B.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[R]=h.Bc(N)}this._highLimitsCache[R]=h}U=this._highLimitsCache[R],e=this._offsetsCache[R]}if(void 0===e)switch(z.dataType){case B.b.ANIMATIONTYPE_FLOAT:e=0;break;case B.b.ANIMATIONTYPE_QUATERNION:e=B.j;break;case B.b.ANIMATIONTYPE_VECTOR3:e=B.q;break;case B.b.ANIMATIONTYPE_VECTOR2:e=B.n;break;case B.b.ANIMATIONTYPE_SIZE:e=B.k;break;case B.b.ANIMATIONTYPE_COLOR3:e=B.e;break;case B.b.ANIMATIONTYPE_COLOR4:e=B.i}let p;if(this._host&&this._host.syncRoot){const R=this._host.syncRoot;p=q+C*((R.masterFrame-R.fromFrame)/(R.toFrame-R.fromFrame))}else p=y>0&&q>L||y<0&&q<L?F&&0!==C?L+y%C:q:F&&0!==C?q+y%C:L;const c=this._events;if(!r&&(h>0&&this.currentFrame>p||h<0&&this.currentFrame<p)||r&&n){this._onLoop();for(let R=0;R<c.length;R++)c[R].onlyOnce||(c[R].isDone=!1);this._animationState.key=h>0?0:z.getKeys().length-1}this._currentFrame=p,this._animationState.repeatCount=0===C?0:y/C|0,this._animationState.highLimitValue=U,this._animationState.offsetValue=e;const d=z._interpolate(p,this._animationState);if(this.setValue(d,Z),c.length)for(let B=0;B<c.length;B++)if(C>=0&&p>=c[B].frame&&c[B].frame>=q||C<0&&p<=c[B].frame&&c[B].frame<=q){const R=c[B];R.isDone||(R.onlyOnce&&(c.splice(B,1),B--),R.isDone=!0,R.action(p))}return F||(this._stopped=!0),F}}var C=L(10778);class e{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(R){this._weight=-1!==R?Math.min(Math.max(R,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(R){for(let q=0;q<this._runtimeAnimations.length;q++){this._runtimeAnimations[q]._prepareForSpeedRatioChange(R)}this._speedRatio=R,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(R,q){let L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,h=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,F=arguments.length>8?arguments[8]:void 0,C=arguments.length>9&&void 0!==arguments[9]&&arguments[9],e=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=q,this.fromFrame=L,this.toFrame=B,this.loopAnimation=h,this.onAnimationEnd=z,this.onAnimationLoop=F,this.isAdditive=C,this.playOrder=e,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.vd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new N.b,this.onAnimationLoopObservable=new N.b,this._scene=R,Y&&this.appendAnimations(q,Y),this._speedRatio=Z,R._activeAnimatables.push(this)}syncWith(R){if(this._syncRoot=R,R){const R=this._scene._activeAnimatables.indexOf(this);R>-1&&(this._scene._activeAnimatables.splice(R,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(R,q){for(let L=0;L<q.length;L++){const B=q[L],N=new F(R,B,this._scene,this);N._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(N)}}getAnimationByTargetProperty(R){const q=this._runtimeAnimations;for(let L=0;L<q.length;L++)if(q[L].animation.targetProperty===R)return q[L].animation;return null}getRuntimeAnimationByTargetProperty(R){const q=this._runtimeAnimations;for(let L=0;L<q.length;L++)if(q[L].animation.targetProperty===R)return q[L];return null}reset(){const R=this._runtimeAnimations;for(let q=0;q<R.length;q++)R[q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(R){const q=this._runtimeAnimations;for(let L=0;L<q.length;L++)q[L].animation.enableBlending=!0,q[L].animation.blendingSpeed=R}disableBlending(){const R=this._runtimeAnimations;for(let q=0;q<R.length;q++)R[q].animation.enableBlending=!1}goToFrame(R){const q=this._runtimeAnimations;if(q[0]){const L=q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??q[0].currentFrame;const B=0===this.speedRatio?0:(R-this._frameToSyncFromJump)/L*1e3/this.speedRatio;this._manualJumpDelay=-B}for(let L=0;L<q.length;L++)q[L].goToFrame(R,this._weight);this._goToFrame=R}get paused(){return this.vd}pause(){this.vd||(this.vd=!0)}restart(){this.vd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(R,q){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(R||q){const N=this._scene._activeAnimatables.indexOf(this);if(N>-1){const h=this._runtimeAnimations;for(let L=h.length-1;L>=0;L--){const B=h[L];R&&B.animation.name!=R||(q&&!q(B.target)||(B.dispose(),h.splice(L,1)))}0==h.length&&(L||this._scene._activeAnimatables.splice(N,1),B||this._raiseOnAnimationEnd())}}else{const R=this._scene._activeAnimatables.indexOf(this);if(R>-1){L||this._scene._activeAnimatables.splice(R,1);const q=this._runtimeAnimations;for(let R=0;R<q.length;R++)q[R].dispose();this._runtimeAnimations.length=0,B||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((R=>{this.onAnimationEndObservable.add((()=>{R(this)}),void 0,void 0,this,!0)}))}_animate(R){if(this.vd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=R),!0;if(null===this._localDelayOffset?(this._localDelayOffset=R,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=R-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let q=!1;const L=this._runtimeAnimations;let B;for(B=0;B<L.length;B++){const N=L[B].animate(R-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);q=q||N}if(this.animationStarted=q,!q){if(this.disposeOnEnd)for(B=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(B,1),B=0;B<L.length;B++)L[B].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return q}}function y(R){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return R.originalValue;let q=1;const L=Y.h.o[0],B=Y.h.o[1],N=Y.h.Quaternion[0];let h=0;const Z=R.animations[0],z=R.originalValue;let F=1,C=!1;if(R.totalWeight<1)F=1-R.totalWeight,z.decompose(B,N,L);else{if(h=1,q=R.totalWeight,F=Z.weight/q,1==F){if(!R.totalAdditiveWeight)return Z.currentValue;C=!0}Z.currentValue.decompose(B,N,L)}if(!C){B.scaleInPlace(F),L.scaleInPlace(F),N.scaleInPlace(F);for(let Z=h;Z<R.animations.length;Z++){const h=R.animations[Z];if(0===h.weight)continue;F=h.weight/q;const z=Y.h.o[2],C=Y.h.o[3],e=Y.h.Quaternion[1];h.currentValue.decompose(C,e,z),C.scaleAndAddToRef(F,B),e.scaleAndAddToRef(Y.d.Dot(N,e)>0?F:-F,N),z.scaleAndAddToRef(F,L)}N.normalize()}for(let y=0;y<R.additiveAnimations.length;y++){const q=R.additiveAnimations[y];if(0===q.weight)continue;const h=Y.h.o[2],Z=Y.h.o[3],z=Y.h.Quaternion[1];q.currentValue.decompose(Z,z,h),Z.multiplyToRef(B,Z),Y.m.LerpToRef(B,Z,q.weight,B),N.multiplyToRef(z,z),Y.d.SlerpToRef(N,z,q.weight,N),h.scaleAndAddToRef(q.weight,L)}const e=Z?Z._animationState.workValue:Y.h.Matrix[0].clone();return Y.c.ComposeToRef(B,N,L,e),e}function U(R,q){if(0===R.totalWeight&&0===R.totalAdditiveWeight)return q;const L=R.animations[0],B=R.originalValue;let N=q;if(0===R.totalWeight&&R.totalAdditiveWeight>0)N.p(B);else if(1===R.animations.length){if(Y.d.SlerpToRef(B,L.currentValue,Math.min(1,R.totalWeight),N),0===R.totalAdditiveWeight)return N}else if(R.animations.length>1){let L,h,Z=1;if(R.totalWeight<1){const q=1-R.totalWeight;L=[],h=[],L.push(B),h.push(q)}else{if(2===R.animations.length&&(Y.d.SlerpToRef(R.animations[0].currentValue,R.animations[1].currentValue,R.animations[1].weight/R.totalWeight,q),0===R.totalAdditiveWeight))return q;L=[],h=[],Z=R.totalWeight}for(let q=0;q<R.animations.length;q++){const B=R.animations[q];L.push(B.currentValue),h.push(B.weight/Z)}let z=0;for(let R=0;R<L.length;)R?(z+=h[R],Y.d.SlerpToRef(N,L[R],h[R]/z,N),R++):(Y.d.SlerpToRef(L[R],L[R+1],h[R+1]/(h[R]+h[R+1]),q),N=q,z=h[R]+h[R+1],R+=2)}for(let h=0;h<R.additiveAnimations.length;h++){const q=R.additiveAnimations[h];0!==q.weight&&(N.multiplyToRef(q.currentValue,Y.h.Quaternion[0]),Y.d.SlerpToRef(N,Y.h.Quaternion[0],q.weight,N))}return N}var n,r,p=L(11071);n=p.b,(r=z.d)&&(r.prototype.copyAnimationRange=function(R,q,L){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new B.b(this.name,"_matrix",R.animations[0].framePerSecond,B.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const Z=R.animations[0].getRange(q);if(!Z)return!1;const z=Z.from,Y=Z.to,F=R.animations[0].getKeys(),C=R.length,e=R.getParent(),y=this.getParent(),U=N&&e&&C&&this.length&&C!==this.length,n=U&&y&&e?y.length/e.length:1,r=N&&!y&&h&&(1!==h.x||1!==h.y||1!==h.z),p=this.animations[0].getKeys();let c,d,f;for(let B=0,v=F.length;B<v;B++)c=F[B],c.frame>=z&&c.frame<=Y&&(N?(f=c.value.clone(),U?(d=f.getTranslation(),f.setTranslation(d.scaleInPlace(n))):r&&h?(d=f.getTranslation(),f.setTranslation(d.multiplyInPlace(h))):f=c.value):f=c.value,p.push({frame:c.frame+L,value:f}));return this.animations[0].createRange(q,z+L,Y+L),!0}),n&&(n.prototype._animate=function(R){if(!this.animationsEnabled)return;const q=C.c.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=q}this.deltaTime=void 0!==R?R:this.useConstantAnimationDeltaTime?16:(q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=q;const L=this._activeAnimatables;if(0===L.length)return;this._animationTime+=this.deltaTime;const N=this._animationTime;for(let B=0;B<L.length;B++){const R=L[B];!R._animate(N)&&R.disposeOnEnd&&B--}!function(R){if(R._registeredForLateAnimationBindings.length){for(let q=0;q<R._registeredForLateAnimationBindings.length;q++){const L=R._registeredForLateAnimationBindings.data[q];for(const R in L._lateAnimationHolders){const q=L._lateAnimationHolders[R],N=q.animations[0],h=q.originalValue;if(void 0===h||null===h)continue;const Z=B.b.AllowMatrixDecomposeForInterpolation&&h.m;let z=L[R];if(Z)z=y(q);else if(void 0!==h.w)z=U(q,z||Y.d.Identity());else{let R=0,L=1;const Z=N&&N._animationState.loopMode===B.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(q.totalWeight<1)z=Z?h.clone?h.clone():h:N&&h.scale?h.scale(1-q.totalWeight):N?h*(1-q.totalWeight):h.clone?h.clone():h;else if(N){L=q.totalWeight;const B=N.weight/L;z=1!==B?N.currentValue.scale?N.currentValue.scale(B):N.currentValue*B:N.currentValue,Z&&(z.addToRef?z.addToRef(h,z):z+=h),R=1}for(let B=R;B<q.animations.length;B++){const R=q.animations[B],N=R.weight/L;N&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(N,z):z+=R.currentValue*N)}for(let B=0;B<q.additiveAnimations.length;B++){const R=q.additiveAnimations[B],L=R.weight;L&&(R.currentValue.scaleAndAddToRef?R.currentValue.scaleAndAddToRef(L,z):z+=R.currentValue*L)}}L[R]=z}L._lateAnimationHolders={}}R._registeredForLateAnimationBindings.reset()}}(this)},n.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((R,q)=>R.playOrder-q.playOrder))},n.prototype.beginWeightedAnimation=function(R,q,L){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,N=arguments.length>4?arguments[4]:void 0,h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Z=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,Y=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const e=this.beginAnimation(R,q,L,N,h,Z,z,!1,Y,F,C);return e.weight=B,e},n.prototype.beginAnimation=function(R,q,L,B){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,h=arguments.length>5?arguments[5]:void 0,Z=arguments.length>6?arguments[6]:void 0,z=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],Y=arguments.length>8?arguments[8]:void 0,F=arguments.length>9?arguments[9]:void 0,C=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(N<0){const R=q;q=L,L=R,N=-N}q>L&&(N=-N),z&&this.stopAnimation(R,void 0,Y),Z||(Z=new e(this,R,q,L,B,N,h,void 0,F,C));const y=!Y||Y(R);if(R.animations&&y&&Z.appendAnimations(R,R.animations),R.getAnimatables){const C=R.getAnimatables();for(let R=0;R<C.length;R++)this.beginAnimation(C[R],q,L,B,N,h,Z,z,Y,F)}return Z.reset(),Z},n.prototype.beginHierarchyAnimation=function(R,q,L,B,N){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Z=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,Y=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],F=arguments.length>9?arguments[9]:void 0,C=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const e=R.getDescendants(q),y=[];y.push(this.beginAnimation(R,L,B,N,h,Z,z,Y,F,void 0,C));for(const U of e)y.push(this.beginAnimation(U,L,B,N,h,Z,z,Y,F,void 0,C));return y},n.prototype.beginDirectAnimation=function(R,q,L,B,N){let h=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(h<0){const R=L;L=B,B=R,h=-h}return L>B&&(h=-h),new e(this,R,L,B,N,h,arguments.length>6?arguments[6]:void 0,q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},n.prototype.beginDirectHierarchyAnimation=function(R,q,L,B,N,h,Z,z,Y){let F=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const C=R.getDescendants(q),e=[];e.push(this.beginDirectAnimation(R,L,B,N,h,Z,z,Y,F));for(const y of C)e.push(this.beginDirectAnimation(y,L,B,N,h,Z,z,Y,F));return e},n.prototype.getAnimatableByTarget=function(R){for(let q=0;q<this._activeAnimatables.length;q++)if(this._activeAnimatables[q].target===R)return this._activeAnimatables[q];return null},n.prototype.getAllAnimatablesByTarget=function(R){const q=[];for(let L=0;L<this._activeAnimatables.length;L++)this._activeAnimatables[L].target===R&&q.push(this._activeAnimatables[L]);return q},n.prototype.stopAnimation=function(R,q,L){const B=this.getAllAnimatablesByTarget(R);for(const N of B)N.stop(q,L)},n.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let R=0;R<this._activeAnimatables.length;R++)this._activeAnimatables[R].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const R of this.animationGroups)R.stop()});class c{getClassName(){return"TargetedAnimation"}serialize(){const R={};return R.animation=this.animation.serialize(),R.targetId=this.target.id,R}}class d{get mask(){return this._mask}set mask(R){this._mask!==R&&(this._mask=R,this.syncWithMask(!0))}syncWithMask(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||R){this._numActiveAnimatables=0;for(let R=0;R<this._animatables.length;++R){const q=this._animatables[R];!this.mask||this.mask.disabled||this.mask.retainsTarget(q.target.name)?(this._numActiveAnimatables++,q.paused&&q.restart()):q.paused||q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let R=0;R<this._animatables.length;++R){const q=this._animatables[R];this.mask.retainsTarget(q.target.name)||(q.stop(),this._animatables.splice(R,1),--R)}for(let R=0;R<this._targetedAnimations.length;R++){const q=this._targetedAnimations[R];this.mask.retainsTarget(q.target.name)||(this._targetedAnimations.splice(R,1),--R)}}}get from(){return this._from}set from(R){if(this._from!==R){this._from=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].fromFrame=this._from}}}get to(){return this._to}set to(R){if(this._to!==R){this._to=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(R){if(this._speedRatio!==R){this._speedRatio=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(R){if(this._loopAnimation!==R){this._loopAnimation=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(R){if(this._isAdditive!==R){this._isAdditive=R;for(let R=0;R<this._animatables.length;R++){this._animatables[R].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(R){this._weight!==R&&(this._weight=R,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(R){if(this._playOrder!==R&&(this._playOrder=R,this._animatables.length>0)){for(let R=0;R<this._animatables.length;R++)this._animatables[R].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(R){if(this._enableBlending!==R&&(this._enableBlending=R,null!==R))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.enableBlending=R}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(R){if(this._blendingSpeed!==R&&(this._blendingSpeed=R,null!==R))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.blendingSpeed=R}getLength(R,q){R=R??this._from;return((q=q??this._to)-R)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(R){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],L=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3?arguments[3]:void 0;if(0===R.length)return null;B=B??R[0].weight;let N=Number.MAX_VALUE,h=-Number.MAX_VALUE;if(L)for(const z of R)z.from<N&&(N=z.from),z.to>h&&(h=z.to);const Z=new d(R[0].name+"_merged",R[0]._scene,B);for(const z of R){L&&z.normalize(N,h);for(const R of z.targetedAnimations)Z.addTargetedAnimation(R.animation,R.target);q&&z.dispose()}return Z}constructor(R){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,L=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=R,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new N.b,this.onAnimationLoopObservable=new N.b,this.onAnimationGroupLoopObservable=new N.b,this.onAnimationGroupEndObservable=new N.b,this.onAnimationGroupPauseObservable=new N.b,this.onAnimationGroupPlayObservable=new N.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=q||h.b.LastCreatedScene,this._weight=L,this._playOrder=B,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(R,q){const L=new c;L.animation=R,L.target=q;const B=R.getKeys();return this._from>B[0].frame&&(this._from=B[0].frame),this._to<B[B.length-1].frame&&(this._to=B[B.length-1].frame),null!==this._enableBlending&&(R.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(R.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(L),this._shouldStart=!0,L}removeTargetedAnimation(R){for(let q=this._targetedAnimations.length-1;q>-1;q--){this._targetedAnimations[q].animation===R&&this._targetedAnimations.splice(q,1)}}normalize(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==R&&(R=this._from),null==q&&(q=this._to);for(let L=0;L<this._targetedAnimations.length;L++){const B=this._targetedAnimations[L].animation.getKeys(),N=B[0],h=B[B.length-1];if(N.frame>R){const q={frame:R,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};B.splice(0,0,q)}if(h.frame<q){const R={frame:q,value:h.value,inTangent:h.inTangent,outTangent:h.outTangent,interpolation:h.interpolation};B.push(R)}}return this._from=R,this._to=q,this}_processLoop(R,q,L){R.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(q),this._animationLoopFlags[L]||(this._animationLoopFlags[L]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0],q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,L=arguments.length>2?arguments[2]:void 0,B=arguments.length>3?arguments[3]:void 0,N=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=R,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let h=0;h<this._targetedAnimations.length;h++){const Z=this._targetedAnimations[h],z=this._scene.beginDirectAnimation(Z.target,[Z.animation],void 0!==L?L:this._from,void 0!==B?B:this._to,R,q,void 0,void 0,void 0!==N?N:this._isAdditive);z.weight=this._weight,z.playOrder=this._playOrder,z.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(Z),this._checkAnimationGroupEnded(z)},this._processLoop(z,Z,h),this._animatables.push(z)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let R=0;R<this._animatables.length;R++){this._animatables[R].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(R){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==R&&(this.loopAnimation=R),this.restart()):(this.stop(),this.start(R,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].reset()}return this}restart(){if(!this._isStarted)return this;for(let R=0;R<this._animatables.length;R++){this._animatables[R].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const q=this._animatables.slice();for(let B=0;B<q.length;B++)q[B].stop(void 0,void 0,!0,R);let L=0;for(let B=0;B<this._scene._activeAnimatables.length;B++){const q=this._scene._activeAnimatables[B];q._runtimeAnimations.length>0?this._scene._activeAnimatables[L++]=q:R&&this._checkAnimationGroupEnded(q,R)}return this._scene._activeAnimatables.length=L,this._isStarted=!1,this}setWeightForAllAnimatables(R){for(let q=0;q<this._animatables.length;q++){this._animatables[q].weight=R}return this}syncAllAnimationsWith(R){for(let q=0;q<this._animatables.length;q++){this._animatables[q].syncWith(R)}return this}goToFrame(R){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].goToFrame(R)}return this}getCurrentFrame(){var R;return(null===(R=this.animatables[0])||void 0===R?void 0:R.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const R=this._scene.animationGroups.indexOf(this);if(R>-1&&this._scene.animationGroups.splice(R,1),this._parentContainer){const R=this._parentContainer.animationGroups.indexOf(this);R>-1&&this._parentContainer.animationGroups.splice(R,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(R){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const L=this._animatables.indexOf(R);L>-1&&this._animatables.splice(L,1),0===this._animatables.length&&(this._isStarted=!1,q||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(R,q){let L=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=new d(R||this.name,this._scene,this._weight,this._playOrder);B._from=this.from,B._to=this.to,B._speedRatio=this.speedRatio,B._loopAnimation=this.loopAnimation,B._isAdditive=this.isAdditive,B._enableBlending=this.enableBlending,B._blendingSpeed=this.blendingSpeed,B.metadata=this.metadata,B.mask=this.mask;for(const N of this._targetedAnimations)B.addTargetedAnimation(L?N.animation.clone():N.animation,q?q(N.target):N.target);return B}serialize(){const R={};R.name=this.name,R.from=this.from,R.to=this.to,R.speedRatio=this.speedRatio,R.loopAnimation=this.loopAnimation,R.isAdditive=this.isAdditive,R.weight=this.weight,R.playOrder=this.playOrder,R.enableBlending=this.enableBlending,R.blendingSpeed=this.blendingSpeed,R.targetedAnimations=[];for(let q=0;q<this.targetedAnimations.length;q++){const L=this.targetedAnimations[q];R.targetedAnimations[q]=L.serialize()}return Z.b&&Z.b.HasTags(this)&&(R.tags=Z.b.GetTags(this)),this.metadata&&(R.metadata=this.metadata),R}static Parse(R,q){const L=new d(R.name,q,R.weight,R.playOrder);for(let N=0;N<R.targetedAnimations.length;N++){const h=R.targetedAnimations[N],Z=B.b.Parse(h.animation),z=h.targetId;if("influence"===h.animation.property){const R=q.getMorphTargetById(z);R&&L.addTargetedAnimation(Z,R)}else{const R=q.getNodeById(z);null!=R&&L.addTargetedAnimation(Z,R)}}return Z.b&&Z.b.AddTagsTo(L,R.tags),null!==R.from&&null!==R.to&&L.normalize(R.from,R.to),void 0!==R.speedRatio&&(L._speedRatio=R.speedRatio),void 0!==R.loopAnimation&&(L._loopAnimation=R.loopAnimation),void 0!==R.isAdditive&&(L._isAdditive=R.isAdditive),void 0!==R.weight&&(L._weight=R.weight),void 0!==R.playOrder&&(L._playOrder=R.playOrder),void 0!==R.enableBlending&&(L._enableBlending=R.enableBlending),void 0!==R.blendingSpeed&&(L._blendingSpeed=R.blendingSpeed),void 0!==R.metadata&&(L.metadata=R.metadata),L}static MakeAnimationAdditive(R,q,L){let N;N="object"===typeof q?q:{referenceFrame:q,range:L,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let h=R;N.cloneOriginalAnimationGroup&&(h=R.clone(N.clonedAnimationGroupName||h.name));const Z=h.targetedAnimations;for(let z=0;z<Z.length;z++){const R=Z[z];R.animation=B.b.MakeAnimationAdditive(R.animation,N)}if(h.isAdditive=!0,N.clipKeys){let R=Number.MAX_VALUE,q=-Number.MAX_VALUE;const L=h.targetedAnimations;for(let B=0;B<L.length;B++){const N=L[B].animation.getKeys();R>N[0].frame&&(R=N[0].frame),q<N[N.length-1].frame&&(q=N[N.length-1].frame)}h._from=R,h._to=q}return h}static ClipKeys(R,q,L,B,N){const h=R.clone(B||R.name);return d.ClipKeysInPlace(h,q,L,N)}static ClipKeysInPlace(R,q,L,B){return d.ClipInPlace(R,q,L,B,!1)}static ClipFrames(R,q,L,B,N){const h=R.clone(B||R.name);return d.ClipFramesInPlace(h,q,L,N)}static ClipFramesInPlace(R,q,L,B){return d.ClipInPlace(R,q,L,B,!0)}static ClipInPlace(R,q,L,B){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],h=Number.MAX_VALUE,Z=-Number.MAX_VALUE;const z=R.targetedAnimations;for(let Y=0;Y<z.length;Y++){const R=z[Y],F=B?R.animation:R.animation.clone();N&&(F.createKeyForFrame(q),F.createKeyForFrame(L));const C=F.getKeys(),e=[];let y=Number.MAX_VALUE;for(let B=0;B<C.length;B++){const R=C[B];if(!N&&B>=q&&B<=L||N&&R.frame>=q&&R.frame<=L){const q={frame:R.frame,value:R.value.clone?R.value.clone():R.value,inTangent:R.inTangent,outTangent:R.outTangent,interpolation:R.interpolation,lockedTangent:R.lockedTangent};y===Number.MAX_VALUE&&(y=q.frame),q.frame-=y,e.push(q)}}0!==e.length?(h>e[0].frame&&(h=e[0].frame),Z<e[e.length-1].frame&&(Z=e[e.length-1].frame),F.setKeys(e,!0),R.animation=F):(z.splice(Y,1),Y--)}return R._from=h,R._to=Z,R}getClassName(){return"AnimationGroup"}toString(R){let q="Name: "+this.name;return q+=", type: "+this.getClassName(),R&&(q+=", from: "+this._from,q+=", to: "+this._to,q+=", isStarted: "+this._isStarted,q+=", speedRatio: "+this._speedRatio,q+=", targetedAnimations length: "+this._targetedAnimations.length,q+=", animatables length: "+this._animatables),q}}}}]);