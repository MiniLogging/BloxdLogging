"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13380:(N,q,R)=>{R.r(q),R.d(q,{AnimationGroup:()=>H,TargetedAnimation:()=>V});var z=R(12075),v=R(10893),B=R(10933),F=R(11178),S=R(12067),A=R(11181);class y{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(N,q,R,v){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=q,this._target=N,this._scene=R,this._host=v,this._activeTargets=[],q._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===z.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=A.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const N={frame:0,value:this._minValue};this._keys.splice(0,0,N)}if(this._target instanceof Array){let N=0;for(const q of this._target)this._preparePath(q,N),this._getOriginalValues(N),N++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const B=q.getEvents();B&&B.length>0&&B.forEach((N=>{this._events.push(N._clone())})),this._enableBlending=N&&N.animationPropertiesOverride?N.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const R=this._animation.targetPropertyPath;if(R.length>1){let z=N;for(let N=0;N<R.length-1;N++){const q=R[N];if(z=z[q],void 0===z)throw new Error(`Invalid property (${q}) in property path (${R.join(".")})`)}this._targetPath=R[R.length-1],this._activeTargets[q]=z}else this._targetPath=R[0],this._activeTargets[q]=N;if(void 0===this._activeTargets[q][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${R.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let N=0;for(const q of this._target)void 0!==this._originalValue[N]&&this._setValue(q,this._activeTargets[N],this._originalValue[N],-1,N),N++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let N=0;N<this._events.length;N++)this._events[N].isDone=!1}isStopped(){return this._stopped}dispose(){const N=this._animation.runtimeAnimations.indexOf(this);N>-1&&this._animation.runtimeAnimations.splice(N,1)}setValue(N,q){if(this._targetIsArray)for(let R=0;R<this._target.length;R++){const z=this._target[R];this._setValue(z,this._activeTargets[R],N,q,R)}else this._setValue(this._target,this._directTarget,N,q,0)}_getOriginalValues(){let N,q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const R=this._activeTargets[q];N=R.getLocalMatrix&&"_matrix"===this._targetPath?R.getLocalMatrix():R[this._targetPath],N&&N.clone?this._originalValue[q]=N.clone():this._originalValue[q]=N}_registerTargetForLateAnimationBinding(N,q){const R=N.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(R),R._lateAnimationHolders||(R._lateAnimationHolders={}),R._lateAnimationHolders[N.targetPath]||(R._lateAnimationHolders[N.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:q}),N.isAdditive?(R._lateAnimationHolders[N.targetPath].additiveAnimations.push(N),R._lateAnimationHolders[N.targetPath].totalAdditiveWeight+=N.weight):(R._lateAnimationHolders[N.targetPath].animations.push(N),R._lateAnimationHolders[N.targetPath].totalWeight+=N.weight)}_setValue(N,q,R,v,B){if(this._currentActiveTarget=q,this._weight=v,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const N=q[this._targetPath];N.clone?this._originalBlendValue=N.clone():this._originalBlendValue=N}this._originalBlendValue.m?z.c.AllowMatrixDecomposeForInterpolation?this._currentValue?A.d.DecomposeLerpToRef(this._originalBlendValue,R,this._blendingFactor,this._currentValue):this._currentValue=A.d.DecomposeLerp(this._originalBlendValue,R,this._blendingFactor):this._currentValue?A.d.LerpToRef(this._originalBlendValue,R,this._blendingFactor,this._currentValue):this._currentValue=A.d.Lerp(this._originalBlendValue,R,this._blendingFactor):this._currentValue=z.c._UniversalLerp(this._originalBlendValue,R,this._blendingFactor);const v=N&&N.animationPropertiesOverride?N.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=v}else this._currentValue?this._currentValue.p?this._currentValue.p(R):this._currentValue=R:null!==R&&void 0!==R&&R.clone?this._currentValue=R.clone():this._currentValue=R;-1!==v?this._registerTargetForLateAnimationBinding(this,this._originalValue[B]):this._animationState.loopMode===z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[B],q[this._targetPath]):q[this._targetPath]=this._originalValue[B]+this._currentValue:q[this._targetPath]=this._currentValue,N.Lg&&N.Lg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const R=this._animation.getKeys();N<R[0].frame?N=R[0].frame:N>R[R.length-1].frame&&(N=R[R.length-1].frame);const z=this._events;if(z.length)for(let B=0;B<z.length;B++)z[B].onlyOnce||(z[B].isDone=z[B].frame<N);this._currentFrame=N;const v=this._animation._interpolate(N,this._animationState);this.setValue(v,q)}_prepareForSpeedRatioChange(N){const q=this._previousElapsedTime*(this._animation.framePerSecond*N)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-q}animate(N,q,R,v,B){let F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const S=this._animation,A=S.targetPropertyPath;if(!A||A.length<1)return this._stopped=!0,!1;let y=!0;(q<this._minFrame||q>this._maxFrame)&&(q=this._minFrame),(R<this._minFrame||R>this._maxFrame)&&(R=this._maxFrame);const E=R-q;let t,x=N*(S.framePerSecond*B)/1e3+this._absoluteFrameOffset,e=0,b=!1;const f=v&&this._animationState.loopMode===z.c.ANIMATIONLOOPMODE_YOYO;if(f){const N=(x-q)/E,R=Math.sin(N*Math.PI);x=Math.abs(R)*E+q;const z=R>=0?1:-1;this._yoyoDirection!==z&&(b=!0),this._yoyoDirection=z}if(this._previousElapsedTime=N,this._previousAbsoluteFrame=x,!v&&R>=q&&(x>=E&&B>0||x<=0&&B<0))y=!1,e=S._getKeyValue(this._maxValue);else if(!v&&q>=R&&(x<=E&&B<0||x>=0&&B>0))y=!1,e=S._getKeyValue(this._minValue);else if(this._animationState.loopMode!==z.c.ANIMATIONLOOPMODE_CYCLE){const N=R.toString()+q.toString();if(!this._offsetsCache[N]){this._animationState.repeatCount=0,this._animationState.loopMode=z.c.ANIMATIONLOOPMODE_CYCLE;const v=S._interpolate(q,this._animationState),B=S._interpolate(R,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),S.dataType){case z.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[N]=B-v;break;case z.c.ANIMATIONTYPE_QUATERNION:case z.c.ANIMATIONTYPE_VECTOR3:case z.c.ANIMATIONTYPE_VECTOR2:case z.c.ANIMATIONTYPE_SIZE:case z.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[N]=B.gd(v)}this._highLimitsCache[N]=B}e=this._highLimitsCache[N],t=this._offsetsCache[N]}if(void 0===t)switch(S.dataType){case z.c.ANIMATIONTYPE_FLOAT:t=0;break;case z.c.ANIMATIONTYPE_QUATERNION:t=z.k;break;case z.c.ANIMATIONTYPE_VECTOR3:t=z.p;break;case z.c.ANIMATIONTYPE_VECTOR2:t=z.n;break;case z.c.ANIMATIONTYPE_SIZE:t=z.m;break;case z.c.ANIMATIONTYPE_COLOR3:t=z.g;break;case z.c.ANIMATIONTYPE_COLOR4:t=z.h}let D;if(this._host&&this._host.syncRoot){const N=this._host.syncRoot;D=q+E*((N.masterFrame-N.fromFrame)/(N.toFrame-N.fromFrame))}else D=x>0&&q>R||x<0&&q<R?y&&0!==E?R+x%E:q:y&&0!==E?q+x%E:R;const V=this._events;if(!f&&(B>0&&this.currentFrame>D||B<0&&this.currentFrame<D)||f&&b){this._onLoop();for(let N=0;N<V.length;N++)V[N].onlyOnce||(V[N].isDone=!1);this._animationState.key=B>0?0:S.getKeys().length-1}this._currentFrame=D,this._animationState.repeatCount=0===E?0:x/E|0,this._animationState.highLimitValue=e,this._animationState.offsetValue=t;const H=S._interpolate(D,this._animationState);if(this.setValue(H,F),V.length)for(let z=0;z<V.length;z++)if(E>=0&&D>=V[z].frame&&V[z].frame>=q||E<0&&D<=V[z].frame&&V[z].frame<=q){const N=V[z];N.isDone||(N.onlyOnce&&(V.splice(z,1),z--),N.isDone=!0,N.action(D))}return y||(this._stopped=!0),y}}var E=R(10919);class t{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(N){this._weight=-1!==N?Math.min(Math.max(N,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(N){for(let q=0;q<this._runtimeAnimations.length;q++){this._runtimeAnimations[q]._prepareForSpeedRatioChange(N)}this._speedRatio=N,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(N,q){let R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,B=arguments.length>4&&void 0!==arguments[4]&&arguments[4],F=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,S=arguments.length>6?arguments[6]:void 0,A=arguments.length>7?arguments[7]:void 0,y=arguments.length>8?arguments[8]:void 0,E=arguments.length>9&&void 0!==arguments[9]&&arguments[9],t=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=q,this.fromFrame=R,this.toFrame=z,this.loopAnimation=B,this.onAnimationEnd=S,this.onAnimationLoop=y,this.isAdditive=E,this.playOrder=t,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Pd=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new v.d,this.onAnimationLoopObservable=new v.d,this._scene=N,A&&this.appendAnimations(q,A),this._speedRatio=F,N._activeAnimatables.push(this)}syncWith(N){if(this._syncRoot=N,N){const N=this._scene._activeAnimatables.indexOf(this);N>-1&&(this._scene._activeAnimatables.splice(N,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(N,q){for(let R=0;R<q.length;R++){const z=q[R],v=new y(N,z,this._scene,this);v._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(v)}}getAnimationByTargetProperty(N){const q=this._runtimeAnimations;for(let R=0;R<q.length;R++)if(q[R].animation.targetProperty===N)return q[R].animation;return null}getRuntimeAnimationByTargetProperty(N){const q=this._runtimeAnimations;for(let R=0;R<q.length;R++)if(q[R].animation.targetProperty===N)return q[R];return null}reset(){const N=this._runtimeAnimations;for(let q=0;q<N.length;q++)N[q].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(N){const q=this._runtimeAnimations;for(let R=0;R<q.length;R++)q[R].animation.enableBlending=!0,q[R].animation.blendingSpeed=N}disableBlending(){const N=this._runtimeAnimations;for(let q=0;q<N.length;q++)N[q].animation.enableBlending=!1}goToFrame(N){const q=this._runtimeAnimations;if(q[0]){const R=q[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??q[0].currentFrame;const z=0===this.speedRatio?0:(N-this._frameToSyncFromJump)/R*1e3/this.speedRatio;this._manualJumpDelay=-z}for(let R=0;R<q.length;R++)q[R].goToFrame(N,this._weight);this._goToFrame=N}get paused(){return this.Pd}pause(){this.Pd||(this.Pd=!0)}restart(){this.Pd=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(N,q){let R=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(N||q){const v=this._scene._activeAnimatables.indexOf(this);if(v>-1){const B=this._runtimeAnimations;for(let R=B.length-1;R>=0;R--){const z=B[R];N&&z.animation.name!=N||(q&&!q(z.target)||(z.dispose(),B.splice(R,1)))}0==B.length&&(R||this._scene._activeAnimatables.splice(v,1),z||this._raiseOnAnimationEnd())}}else{const N=this._scene._activeAnimatables.indexOf(this);if(N>-1){R||this._scene._activeAnimatables.splice(N,1);const q=this._runtimeAnimations;for(let N=0;N<q.length;N++)q[N].dispose();this._runtimeAnimations.length=0,z||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((N=>{this.onAnimationEndObservable.add((()=>{N(this)}),void 0,void 0,this,!0)}))}_animate(N){if(this.Pd)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=N),!0;if(null===this._localDelayOffset?(this._localDelayOffset=N,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=N-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let q=!1;const R=this._runtimeAnimations;let z;for(z=0;z<R.length;z++){const v=R[z].animate(N-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);q=q||v}if(this.animationStarted=q,!q){if(this.disposeOnEnd)for(z=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(z,1),z=0;z<R.length;z++)R[z].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return q}}function x(N){if(0===N.totalWeight&&0===N.totalAdditiveWeight)return N.originalValue;let q=1;const R=A.k.o[0],z=A.k.o[1],v=A.k.Quaternion[0];let B=0;const F=N.animations[0],S=N.originalValue;let y=1,E=!1;if(N.totalWeight<1)y=1-N.totalWeight,S.decompose(z,v,R);else{if(B=1,q=N.totalWeight,y=F.weight/q,1==y){if(!N.totalAdditiveWeight)return F.currentValue;E=!0}F.currentValue.decompose(z,v,R)}if(!E){z.scaleInPlace(y),R.scaleInPlace(y),v.scaleInPlace(y);for(let F=B;F<N.animations.length;F++){const B=N.animations[F];if(0===B.weight)continue;y=B.weight/q;const S=A.k.o[2],E=A.k.o[3],t=A.k.Quaternion[1];B.currentValue.decompose(E,t,S),E.scaleAndAddToRef(y,z),t.scaleAndAddToRef(A.g.Dot(v,t)>0?y:-y,v),S.scaleAndAddToRef(y,R)}v.normalize()}for(let x=0;x<N.additiveAnimations.length;x++){const q=N.additiveAnimations[x];if(0===q.weight)continue;const B=A.k.o[2],F=A.k.o[3],S=A.k.Quaternion[1];q.currentValue.decompose(F,S,B),F.multiplyToRef(z,F),A.m.LerpToRef(z,F,q.weight,z),v.multiplyToRef(S,S),A.g.SlerpToRef(v,S,q.weight,v),B.scaleAndAddToRef(q.weight,R)}const t=F?F._animationState.workValue:A.k.Matrix[0].clone();return A.d.ComposeToRef(z,v,R,t),t}function e(N,q){if(0===N.totalWeight&&0===N.totalAdditiveWeight)return q;const R=N.animations[0],z=N.originalValue;let v=q;if(0===N.totalWeight&&N.totalAdditiveWeight>0)v.p(z);else if(1===N.animations.length){if(A.g.SlerpToRef(z,R.currentValue,Math.min(1,N.totalWeight),v),0===N.totalAdditiveWeight)return v}else if(N.animations.length>1){let R,B,F=1;if(N.totalWeight<1){const q=1-N.totalWeight;R=[],B=[],R.push(z),B.push(q)}else{if(2===N.animations.length&&(A.g.SlerpToRef(N.animations[0].currentValue,N.animations[1].currentValue,N.animations[1].weight/N.totalWeight,q),0===N.totalAdditiveWeight))return q;R=[],B=[],F=N.totalWeight}for(let q=0;q<N.animations.length;q++){const z=N.animations[q];R.push(z.currentValue),B.push(z.weight/F)}let S=0;for(let N=0;N<R.length;)N?(S+=B[N],A.g.SlerpToRef(v,R[N],B[N]/S,v),N++):(A.g.SlerpToRef(R[N],R[N+1],B[N+1]/(B[N]+B[N+1]),q),v=q,S=B[N]+B[N+1],N+=2)}for(let B=0;B<N.additiveAnimations.length;B++){const q=N.additiveAnimations[B];0!==q.weight&&(v.multiplyToRef(q.currentValue,A.k.Quaternion[0]),A.g.SlerpToRef(v,A.k.Quaternion[0],q.weight,v))}return v}var b,f,D=R(11172);b=D.b,(f=S.e)&&(f.prototype.copyAnimationRange=function(N,q,R){let v=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new z.c(this.name,"_matrix",N.animations[0].framePerSecond,z.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const F=N.animations[0].getRange(q);if(!F)return!1;const S=F.from,A=F.to,y=N.animations[0].getKeys(),E=N.length,t=N.getParent(),x=this.getParent(),e=v&&t&&E&&this.length&&E!==this.length,b=e&&x&&t?x.length/t.length:1,f=v&&!x&&B&&(1!==B.x||1!==B.y||1!==B.z),D=this.animations[0].getKeys();let V,H,Y;for(let z=0,T=y.length;z<T;z++)V=y[z],V.frame>=S&&V.frame<=A&&(v?(Y=V.value.clone(),e?(H=Y.getTranslation(),Y.setTranslation(H.scaleInPlace(b))):f&&B?(H=Y.getTranslation(),Y.setTranslation(H.multiplyInPlace(B))):Y=V.value):Y=V.value,D.push({frame:V.frame+R,value:Y}));return this.animations[0].createRange(q,S+R,A+R),!0}),b&&(b.prototype._animate=function(N){if(!this.animationsEnabled)return;const q=E.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=q}this.deltaTime=void 0!==N?N:this.useConstantAnimationDeltaTime?16:(q-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=q;const R=this._activeAnimatables;if(0===R.length)return;this._animationTime+=this.deltaTime;const v=this._animationTime;for(let z=0;z<R.length;z++){const N=R[z];!N._animate(v)&&N.disposeOnEnd&&z--}!function(N){if(N._registeredForLateAnimationBindings.length){for(let q=0;q<N._registeredForLateAnimationBindings.length;q++){const R=N._registeredForLateAnimationBindings.data[q];for(const N in R._lateAnimationHolders){const q=R._lateAnimationHolders[N],v=q.animations[0],B=q.originalValue;if(void 0===B||null===B)continue;const F=z.c.AllowMatrixDecomposeForInterpolation&&B.m;let S=R[N];if(F)S=x(q);else if(void 0!==B.w)S=e(q,S||A.g.Identity());else{let N=0,R=1;const F=v&&v._animationState.loopMode===z.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(q.totalWeight<1)S=F?B.clone?B.clone():B:v&&B.scale?B.scale(1-q.totalWeight):v?B*(1-q.totalWeight):B.clone?B.clone():B;else if(v){R=q.totalWeight;const z=v.weight/R;S=1!==z?v.currentValue.scale?v.currentValue.scale(z):v.currentValue*z:v.currentValue,F&&(S.addToRef?S.addToRef(B,S):S+=B),N=1}for(let z=N;z<q.animations.length;z++){const N=q.animations[z],v=N.weight/R;v&&(N.currentValue.scaleAndAddToRef?N.currentValue.scaleAndAddToRef(v,S):S+=N.currentValue*v)}for(let z=0;z<q.additiveAnimations.length;z++){const N=q.additiveAnimations[z],R=N.weight;R&&(N.currentValue.scaleAndAddToRef?N.currentValue.scaleAndAddToRef(R,S):S+=N.currentValue*R)}}R[N]=S}R._lateAnimationHolders={}}N._registeredForLateAnimationBindings.reset()}}(this)},b.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((N,q)=>N.playOrder-q.playOrder))},b.prototype.beginWeightedAnimation=function(N,q,R){let z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,v=arguments.length>4?arguments[4]:void 0,B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,F=arguments.length>6?arguments[6]:void 0,S=arguments.length>7?arguments[7]:void 0,A=arguments.length>8?arguments[8]:void 0,y=arguments.length>9?arguments[9]:void 0,E=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const t=this.beginAnimation(N,q,R,v,B,F,S,!1,A,y,E);return t.weight=z,t},b.prototype.beginAnimation=function(N,q,R,z){let v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,B=arguments.length>5?arguments[5]:void 0,F=arguments.length>6?arguments[6]:void 0,S=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],A=arguments.length>8?arguments[8]:void 0,y=arguments.length>9?arguments[9]:void 0,E=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(v<0){const N=q;q=R,R=N,v=-v}q>R&&(v=-v),S&&this.stopAnimation(N,void 0,A),F||(F=new t(this,N,q,R,z,v,B,void 0,y,E));const x=!A||A(N);if(N.animations&&x&&F.appendAnimations(N,N.animations),N.getAnimatables){const E=N.getAnimatables();for(let N=0;N<E.length;N++)this.beginAnimation(E[N],q,R,z,v,B,F,S,A,y)}return F.reset(),F},b.prototype.beginHierarchyAnimation=function(N,q,R,z,v){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,F=arguments.length>6?arguments[6]:void 0,S=arguments.length>7?arguments[7]:void 0,A=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],y=arguments.length>9?arguments[9]:void 0,E=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const t=N.getDescendants(q),x=[];x.push(this.beginAnimation(N,R,z,v,B,F,S,A,y,void 0,E));for(const e of t)x.push(this.beginAnimation(e,R,z,v,B,F,S,A,y,void 0,E));return x},b.prototype.beginDirectAnimation=function(N,q,R,z,v){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(B<0){const N=R;R=z,z=N,B=-B}return R>z&&(B=-B),new t(this,N,R,z,v,B,arguments.length>6?arguments[6]:void 0,q,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},b.prototype.beginDirectHierarchyAnimation=function(N,q,R,z,v,B,F,S,A){let y=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const E=N.getDescendants(q),t=[];t.push(this.beginDirectAnimation(N,R,z,v,B,F,S,A,y));for(const x of E)t.push(this.beginDirectAnimation(x,R,z,v,B,F,S,A,y));return t},b.prototype.getAnimatableByTarget=function(N){for(let q=0;q<this._activeAnimatables.length;q++)if(this._activeAnimatables[q].target===N)return this._activeAnimatables[q];return null},b.prototype.getAllAnimatablesByTarget=function(N){const q=[];for(let R=0;R<this._activeAnimatables.length;R++)this._activeAnimatables[R].target===N&&q.push(this._activeAnimatables[R]);return q},b.prototype.stopAnimation=function(N,q,R){const z=this.getAllAnimatablesByTarget(N);for(const v of z)v.stop(q,R)},b.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let N=0;N<this._activeAnimatables.length;N++)this._activeAnimatables[N].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const N of this.animationGroups)N.stop()});class V{getClassName(){return"TargetedAnimation"}serialize(){const N={};return N.animation=this.animation.serialize(),N.targetId=this.target.id,N}}class H{get mask(){return this._mask}set mask(N){this._mask!==N&&(this._mask=N,this.syncWithMask(!0))}syncWithMask(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||N){this._numActiveAnimatables=0;for(let N=0;N<this._animatables.length;++N){const q=this._animatables[N];!this.mask||this.mask.disabled||this.mask.retainsTarget(q.target.name)?(this._numActiveAnimatables++,q.paused&&q.restart()):q.paused||q.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let N=0;N<this._animatables.length;++N){const q=this._animatables[N];this.mask.retainsTarget(q.target.name)||(q.stop(),this._animatables.splice(N,1),--N)}for(let N=0;N<this._targetedAnimations.length;N++){const q=this._targetedAnimations[N];this.mask.retainsTarget(q.target.name)||(this._targetedAnimations.splice(N,1),--N)}}}get from(){return this._from}set from(N){if(this._from!==N){this._from=N;for(let N=0;N<this._animatables.length;N++){this._animatables[N].fromFrame=this._from}}}get to(){return this._to}set to(N){if(this._to!==N){this._to=N;for(let N=0;N<this._animatables.length;N++){this._animatables[N].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(N){if(this._speedRatio!==N){this._speedRatio=N;for(let N=0;N<this._animatables.length;N++){this._animatables[N].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(N){if(this._loopAnimation!==N){this._loopAnimation=N;for(let N=0;N<this._animatables.length;N++){this._animatables[N].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(N){if(this._isAdditive!==N){this._isAdditive=N;for(let N=0;N<this._animatables.length;N++){this._animatables[N].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(N){this._weight!==N&&(this._weight=N,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(N){if(this._playOrder!==N&&(this._playOrder=N,this._animatables.length>0)){for(let N=0;N<this._animatables.length;N++)this._animatables[N].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(N){if(this._enableBlending!==N&&(this._enableBlending=N,null!==N))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.enableBlending=N}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(N){if(this._blendingSpeed!==N&&(this._blendingSpeed=N,null!==N))for(let q=0;q<this._targetedAnimations.length;++q)this._targetedAnimations[q].animation.blendingSpeed=N}getLength(N,q){N=N??this._from;return((q=q??this._to)-N)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(N){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2],z=arguments.length>3?arguments[3]:void 0;if(0===N.length)return null;z=z??N[0].weight;let v=Number.MAX_VALUE,B=-Number.MAX_VALUE;if(R)for(const S of N)S.from<v&&(v=S.from),S.to>B&&(B=S.to);const F=new H(N[0].name+"_merged",N[0]._scene,z);for(const S of N){R&&S.normalize(v,B);for(const N of S.targetedAnimations)F.addTargetedAnimation(N.animation,N.target);q&&S.dispose()}return F}constructor(N){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,R=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=N,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new v.d,this.onAnimationLoopObservable=new v.d,this.onAnimationGroupLoopObservable=new v.d,this.onAnimationGroupEndObservable=new v.d,this.onAnimationGroupPauseObservable=new v.d,this.onAnimationGroupPlayObservable=new v.d,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=q||B.b.LastCreatedScene,this._weight=R,this._playOrder=z,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(N,q){const R=new V;R.animation=N,R.target=q;const z=N.getKeys();return this._from>z[0].frame&&(this._from=z[0].frame),this._to<z[z.length-1].frame&&(this._to=z[z.length-1].frame),null!==this._enableBlending&&(N.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(N.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(R),this._shouldStart=!0,R}removeTargetedAnimation(N){for(let q=this._targetedAnimations.length-1;q>-1;q--){this._targetedAnimations[q].animation===N&&this._targetedAnimations.splice(q,1)}}normalize(){let N=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==N&&(N=this._from),null==q&&(q=this._to);for(let R=0;R<this._targetedAnimations.length;R++){const z=this._targetedAnimations[R].animation.getKeys(),v=z[0],B=z[z.length-1];if(v.frame>N){const q={frame:N,value:v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation};z.splice(0,0,q)}if(B.frame<q){const N={frame:q,value:B.value,inTangent:B.inTangent,outTangent:B.outTangent,interpolation:B.interpolation};z.push(N)}}return this._from=N,this._to=q,this}_processLoop(N,q,R){N.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(q),this._animationLoopFlags[R]||(this._animationLoopFlags[R]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0],q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,R=arguments.length>2?arguments[2]:void 0,z=arguments.length>3?arguments[3]:void 0,v=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=N,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let B=0;B<this._targetedAnimations.length;B++){const F=this._targetedAnimations[B],S=this._scene.beginDirectAnimation(F.target,[F.animation],void 0!==R?R:this._from,void 0!==z?z:this._to,N,q,void 0,void 0,void 0!==v?v:this._isAdditive);S.weight=this._weight,S.playOrder=this._playOrder,S.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(F),this._checkAnimationGroupEnded(S)},this._processLoop(S,F,B),this._animatables.push(S)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=q,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let N=0;N<this._animatables.length;N++){this._animatables[N].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(N){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==N&&(this.loopAnimation=N),this.restart()):(this.stop(),this.start(N,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let N=0;N<this._animatables.length;N++){this._animatables[N].reset()}return this}restart(){if(!this._isStarted)return this;for(let N=0;N<this._animatables.length;N++){this._animatables[N].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let N=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const q=this._animatables.slice();for(let z=0;z<q.length;z++)q[z].stop(void 0,void 0,!0,N);let R=0;for(let z=0;z<this._scene._activeAnimatables.length;z++){const q=this._scene._activeAnimatables[z];q._runtimeAnimations.length>0?this._scene._activeAnimatables[R++]=q:N&&this._checkAnimationGroupEnded(q,N)}return this._scene._activeAnimatables.length=R,this._isStarted=!1,this}setWeightForAllAnimatables(N){for(let q=0;q<this._animatables.length;q++){this._animatables[q].weight=N}return this}syncAllAnimationsWith(N){for(let q=0;q<this._animatables.length;q++){this._animatables[q].syncWith(N)}return this}goToFrame(N){if(!this._isStarted)return this;for(let q=0;q<this._animatables.length;q++){this._animatables[q].goToFrame(N)}return this}getCurrentFrame(){var N;return(null===(N=this.animatables[0])||void 0===N?void 0:N.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const N=this._scene.animationGroups.indexOf(this);if(N>-1&&this._scene.animationGroups.splice(N,1),this._parentContainer){const N=this._parentContainer.animationGroups.indexOf(this);N>-1&&this._parentContainer.animationGroups.splice(N,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(N){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const R=this._animatables.indexOf(N);R>-1&&this._animatables.splice(R,1),0===this._animatables.length&&(this._isStarted=!1,q||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(N,q){let R=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const z=new H(N||this.name,this._scene,this._weight,this._playOrder);z._from=this.from,z._to=this.to,z._speedRatio=this.speedRatio,z._loopAnimation=this.loopAnimation,z._isAdditive=this.isAdditive,z._enableBlending=this.enableBlending,z._blendingSpeed=this.blendingSpeed,z.metadata=this.metadata,z.mask=this.mask;for(const v of this._targetedAnimations)z.addTargetedAnimation(R?v.animation.clone():v.animation,q?q(v.target):v.target);return z}serialize(){const N={};N.name=this.name,N.from=this.from,N.to=this.to,N.speedRatio=this.speedRatio,N.loopAnimation=this.loopAnimation,N.isAdditive=this.isAdditive,N.weight=this.weight,N.playOrder=this.playOrder,N.enableBlending=this.enableBlending,N.blendingSpeed=this.blendingSpeed,N.targetedAnimations=[];for(let q=0;q<this.targetedAnimations.length;q++){const R=this.targetedAnimations[q];N.targetedAnimations[q]=R.serialize()}return F.b&&F.b.HasTags(this)&&(N.tags=F.b.GetTags(this)),this.metadata&&(N.metadata=this.metadata),N}static Parse(N,q){const R=new H(N.name,q,N.weight,N.playOrder);for(let v=0;v<N.targetedAnimations.length;v++){const B=N.targetedAnimations[v],F=z.c.Parse(B.animation),S=B.targetId;if("influence"===B.animation.property){const N=q.getMorphTargetById(S);N&&R.addTargetedAnimation(F,N)}else{const N=q.getNodeById(S);null!=N&&R.addTargetedAnimation(F,N)}}return F.b&&F.b.AddTagsTo(R,N.tags),null!==N.from&&null!==N.to&&R.normalize(N.from,N.to),void 0!==N.speedRatio&&(R._speedRatio=N.speedRatio),void 0!==N.loopAnimation&&(R._loopAnimation=N.loopAnimation),void 0!==N.isAdditive&&(R._isAdditive=N.isAdditive),void 0!==N.weight&&(R._weight=N.weight),void 0!==N.playOrder&&(R._playOrder=N.playOrder),void 0!==N.enableBlending&&(R._enableBlending=N.enableBlending),void 0!==N.blendingSpeed&&(R._blendingSpeed=N.blendingSpeed),void 0!==N.metadata&&(R.metadata=N.metadata),R}static MakeAnimationAdditive(N,q,R){let v;v="object"===typeof q?q:{referenceFrame:q,range:R,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let B=N;v.cloneOriginalAnimationGroup&&(B=N.clone(v.clonedAnimationGroupName||B.name));const F=B.targetedAnimations;for(let S=0;S<F.length;S++){const N=F[S];N.animation=z.c.MakeAnimationAdditive(N.animation,v)}if(B.isAdditive=!0,v.clipKeys){let N=Number.MAX_VALUE,q=-Number.MAX_VALUE;const R=B.targetedAnimations;for(let z=0;z<R.length;z++){const v=R[z].animation.getKeys();N>v[0].frame&&(N=v[0].frame),q<v[v.length-1].frame&&(q=v[v.length-1].frame)}B._from=N,B._to=q}return B}static ClipKeys(N,q,R,z,v){const B=N.clone(z||N.name);return H.ClipKeysInPlace(B,q,R,v)}static ClipKeysInPlace(N,q,R,z){return H.ClipInPlace(N,q,R,z,!1)}static ClipFrames(N,q,R,z,v){const B=N.clone(z||N.name);return H.ClipFramesInPlace(B,q,R,v)}static ClipFramesInPlace(N,q,R,z){return H.ClipInPlace(N,q,R,z,!0)}static ClipInPlace(N,q,R,z){let v=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=Number.MAX_VALUE,F=-Number.MAX_VALUE;const S=N.targetedAnimations;for(let A=0;A<S.length;A++){const N=S[A],y=z?N.animation:N.animation.clone();v&&(y.createKeyForFrame(q),y.createKeyForFrame(R));const E=y.getKeys(),t=[];let x=Number.MAX_VALUE;for(let z=0;z<E.length;z++){const N=E[z];if(!v&&z>=q&&z<=R||v&&N.frame>=q&&N.frame<=R){const q={frame:N.frame,value:N.value.clone?N.value.clone():N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation,lockedTangent:N.lockedTangent};x===Number.MAX_VALUE&&(x=q.frame),q.frame-=x,t.push(q)}}0!==t.length?(B>t[0].frame&&(B=t[0].frame),F<t[t.length-1].frame&&(F=t[t.length-1].frame),y.setKeys(t,!0),N.animation=y):(S.splice(A,1),A--)}return N._from=B,N._to=F,N}getClassName(){return"AnimationGroup"}toString(N){let q="Name: "+this.name;return q+=", type: "+this.getClassName(),N&&(q+=", from: "+this._from,q+=", to: "+this._to,q+=", isStarted: "+this._isStarted,q+=", speedRatio: "+this._speedRatio,q+=", targetedAnimations length: "+this._targetedAnimations.length,q+=", animatables length: "+this._animatables),q}}}}]);