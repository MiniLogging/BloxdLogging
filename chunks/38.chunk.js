"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13587:(H,p,V)=>{V.r(p),V.d(p,{AnimationGroup:()=>M,TargetedAnimation:()=>y});var c=V(12234),C=V(10772),E=V(10821),z=V(11102),w=V(12231),t=V(11108);class Q{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(H,p,V,C){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=p,this._target=H,this._scene=V,this._host=C,this._activeTargets=[],p._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===c.b.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=t.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const H={frame:0,value:this._minValue};this._keys.splice(0,0,H)}if(this._target instanceof Array){let H=0;for(const p of this._target)this._preparePath(p,H),this._getOriginalValues(H),H++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const E=p.getEvents();E&&E.length>0&&E.forEach((H=>{this._events.push(H._clone())})),this._enableBlending=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(H){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const V=this._animation.targetPropertyPath;if(V.length>1){let c=H;for(let H=0;H<V.length-1;H++){const p=V[H];if(c=c[p],void 0===c)throw new Error(`Invalid property (${p}) in property path (${V.join(".")})`)}this._targetPath=V[V.length-1],this._activeTargets[p]=c}else this._targetPath=V[0],this._activeTargets[p]=H;if(void 0===this._activeTargets[p][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${V.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let H=0;for(const p of this._target)void 0!==this._originalValue[H]&&this._setValue(p,this._activeTargets[H],this._originalValue[H],-1,H),H++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let H=0;H<this._events.length;H++)this._events[H].isDone=!1}isStopped(){return this._stopped}dispose(){const H=this._animation.runtimeAnimations.indexOf(this);H>-1&&this._animation.runtimeAnimations.splice(H,1)}setValue(H,p){if(this._targetIsArray)for(let V=0;V<this._target.length;V++){const c=this._target[V];this._setValue(c,this._activeTargets[V],H,p,V)}else this._setValue(this._target,this._directTarget,H,p,0)}_getOriginalValues(){let H,p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const V=this._activeTargets[p];H=V.getLocalMatrix&&"_matrix"===this._targetPath?V.getLocalMatrix():V[this._targetPath],H&&H.clone?this._originalValue[p]=H.clone():this._originalValue[p]=H}_registerTargetForLateAnimationBinding(H,p){const V=H.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(V),V._lateAnimationHolders||(V._lateAnimationHolders={}),V._lateAnimationHolders[H.targetPath]||(V._lateAnimationHolders[H.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:p}),H.isAdditive?(V._lateAnimationHolders[H.targetPath].additiveAnimations.push(H),V._lateAnimationHolders[H.targetPath].totalAdditiveWeight+=H.weight):(V._lateAnimationHolders[H.targetPath].animations.push(H),V._lateAnimationHolders[H.targetPath].totalWeight+=H.weight)}_setValue(H,p,V,C,E){if(this._currentActiveTarget=p,this._weight=C,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const H=p[this._targetPath];H.clone?this._originalBlendValue=H.clone():this._originalBlendValue=H}this._originalBlendValue.m?c.b.AllowMatrixDecomposeForInterpolation?this._currentValue?t.e.DecomposeLerpToRef(this._originalBlendValue,V,this._blendingFactor,this._currentValue):this._currentValue=t.e.DecomposeLerp(this._originalBlendValue,V,this._blendingFactor):this._currentValue?t.e.LerpToRef(this._originalBlendValue,V,this._blendingFactor,this._currentValue):this._currentValue=t.e.Lerp(this._originalBlendValue,V,this._blendingFactor):this._currentValue=c.b._UniversalLerp(this._originalBlendValue,V,this._blendingFactor);const C=H&&H.animationPropertiesOverride?H.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=C}else this._currentValue?this._currentValue.p?this._currentValue.p(V):this._currentValue=V:null!==V&&void 0!==V&&V.clone?this._currentValue=V.clone():this._currentValue=V;-1!==C?this._registerTargetForLateAnimationBinding(this,this._originalValue[E]):this._animationState.loopMode===c.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[E],p[this._targetPath]):p[this._targetPath]=this._originalValue[E]+this._currentValue:p[this._targetPath]=this._currentValue,H.Pg&&H.Pg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(H){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const V=this._animation.getKeys();H<V[0].frame?H=V[0].frame:H>V[V.length-1].frame&&(H=V[V.length-1].frame);const c=this._events;if(c.length)for(let E=0;E<c.length;E++)c[E].onlyOnce||(c[E].isDone=c[E].frame<H);this._currentFrame=H;const C=this._animation._interpolate(H,this._animationState);this.setValue(C,p)}_prepareForSpeedRatioChange(H){const p=this._previousElapsedTime*(this._animation.framePerSecond*H)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-p}animate(H,p,V,C,E){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const w=this._animation,t=w.targetPropertyPath;if(!t||t.length<1)return this._stopped=!0,!1;let Q=!0;(p<this._minFrame||p>this._maxFrame)&&(p=this._minFrame),(V<this._minFrame||V>this._maxFrame)&&(V=this._maxFrame);const P=V-p;let U,J=H*(w.framePerSecond*E)/1e3+this._absoluteFrameOffset,l=0,N=!1;const Z=C&&this._animationState.loopMode===c.b.ANIMATIONLOOPMODE_YOYO;if(Z){const H=(J-p)/P,V=Math.sin(H*Math.PI);J=Math.abs(V)*P+p;const c=V>=0?1:-1;this._yoyoDirection!==c&&(N=!0),this._yoyoDirection=c}if(this._previousElapsedTime=H,this._previousAbsoluteFrame=J,!C&&V>=p&&(J>=P&&E>0||J<=0&&E<0))Q=!1,l=w._getKeyValue(this._maxValue);else if(!C&&p>=V&&(J<=P&&E<0||J>=0&&E>0))Q=!1,l=w._getKeyValue(this._minValue);else if(this._animationState.loopMode!==c.b.ANIMATIONLOOPMODE_CYCLE){const H=V.toString()+p.toString();if(!this._offsetsCache[H]){this._animationState.repeatCount=0,this._animationState.loopMode=c.b.ANIMATIONLOOPMODE_CYCLE;const C=w._interpolate(p,this._animationState),E=w._interpolate(V,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),w.dataType){case c.b.ANIMATIONTYPE_FLOAT:this._offsetsCache[H]=E-C;break;case c.b.ANIMATIONTYPE_QUATERNION:case c.b.ANIMATIONTYPE_VECTOR3:case c.b.ANIMATIONTYPE_VECTOR2:case c.b.ANIMATIONTYPE_SIZE:case c.b.ANIMATIONTYPE_COLOR3:this._offsetsCache[H]=E.gd(C)}this._highLimitsCache[H]=E}l=this._highLimitsCache[H],U=this._offsetsCache[H]}if(void 0===U)switch(w.dataType){case c.b.ANIMATIONTYPE_FLOAT:U=0;break;case c.b.ANIMATIONTYPE_QUATERNION:U=c.l;break;case c.b.ANIMATIONTYPE_VECTOR3:U=c.s;break;case c.b.ANIMATIONTYPE_VECTOR2:U=c.p;break;case c.b.ANIMATIONTYPE_SIZE:U=c.m;break;case c.b.ANIMATIONTYPE_COLOR3:U=c.f;break;case c.b.ANIMATIONTYPE_COLOR4:U=c.j}let Y;if(this._host&&this._host.syncRoot){const H=this._host.syncRoot;Y=p+P*((H.masterFrame-H.fromFrame)/(H.toFrame-H.fromFrame))}else Y=J>0&&p>V||J<0&&p<V?Q&&0!==P?V+J%P:p:Q&&0!==P?p+J%P:V;const y=this._events;if(!Z&&(E>0&&this.currentFrame>Y||E<0&&this.currentFrame<Y)||Z&&N){this._onLoop();for(let H=0;H<y.length;H++)y[H].onlyOnce||(y[H].isDone=!1);this._animationState.key=E>0?0:w.getKeys().length-1}this._currentFrame=Y,this._animationState.repeatCount=0===P?0:J/P|0,this._animationState.highLimitValue=l,this._animationState.offsetValue=U;const M=w._interpolate(Y,this._animationState);if(this.setValue(M,z),y.length)for(let c=0;c<y.length;c++)if(P>=0&&Y>=y[c].frame&&y[c].frame>=p||P<0&&Y<=y[c].frame&&y[c].frame<=p){const H=y[c];H.isDone||(H.onlyOnce&&(y.splice(c,1),c--),H.isDone=!0,H.action(Y))}return Q||(this._stopped=!0),Q}}var P=V(10803);class U{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(H){this._weight=-1!==H?Math.min(Math.max(H,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(H){for(let p=0;p<this._runtimeAnimations.length;p++){this._runtimeAnimations[p]._prepareForSpeedRatioChange(H)}this._speedRatio=H,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(H,p){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,E=arguments.length>4&&void 0!==arguments[4]&&arguments[4],z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,w=arguments.length>6?arguments[6]:void 0,t=arguments.length>7?arguments[7]:void 0,Q=arguments.length>8?arguments[8]:void 0,P=arguments.length>9&&void 0!==arguments[9]&&arguments[9],U=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=p,this.fromFrame=V,this.toFrame=c,this.loopAnimation=E,this.onAnimationEnd=w,this.onAnimationLoop=Q,this.isAdditive=P,this.playOrder=U,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Md=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new C.c,this.onAnimationLoopObservable=new C.c,this._scene=H,t&&this.appendAnimations(p,t),this._speedRatio=z,H._activeAnimatables.push(this)}syncWith(H){if(this._syncRoot=H,H){const H=this._scene._activeAnimatables.indexOf(this);H>-1&&(this._scene._activeAnimatables.splice(H,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(H,p){for(let V=0;V<p.length;V++){const c=p[V],C=new Q(H,c,this._scene,this);C._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(C)}}getAnimationByTargetProperty(H){const p=this._runtimeAnimations;for(let V=0;V<p.length;V++)if(p[V].animation.targetProperty===H)return p[V].animation;return null}getRuntimeAnimationByTargetProperty(H){const p=this._runtimeAnimations;for(let V=0;V<p.length;V++)if(p[V].animation.targetProperty===H)return p[V];return null}reset(){const H=this._runtimeAnimations;for(let p=0;p<H.length;p++)H[p].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(H){const p=this._runtimeAnimations;for(let V=0;V<p.length;V++)p[V].animation.enableBlending=!0,p[V].animation.blendingSpeed=H}disableBlending(){const H=this._runtimeAnimations;for(let p=0;p<H.length;p++)H[p].animation.enableBlending=!1}goToFrame(H){const p=this._runtimeAnimations;if(p[0]){const V=p[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??p[0].currentFrame;const c=0===this.speedRatio?0:(H-this._frameToSyncFromJump)/V*1e3/this.speedRatio;this._manualJumpDelay=-c}for(let V=0;V<p.length;V++)p[V].goToFrame(H,this._weight);this._goToFrame=H}get paused(){return this.Md}pause(){this.Md||(this.Md=!0)}restart(){this.Md=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(H,p){let V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(H||p){const C=this._scene._activeAnimatables.indexOf(this);if(C>-1){const E=this._runtimeAnimations;for(let V=E.length-1;V>=0;V--){const c=E[V];H&&c.animation.name!=H||(p&&!p(c.target)||(c.dispose(),E.splice(V,1)))}0==E.length&&(V||this._scene._activeAnimatables.splice(C,1),c||this._raiseOnAnimationEnd())}}else{const H=this._scene._activeAnimatables.indexOf(this);if(H>-1){V||this._scene._activeAnimatables.splice(H,1);const p=this._runtimeAnimations;for(let H=0;H<p.length;H++)p[H].dispose();this._runtimeAnimations.length=0,c||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((H=>{this.onAnimationEndObservable.add((()=>{H(this)}),void 0,void 0,this,!0)}))}_animate(H){if(this.Md)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=H),!0;if(null===this._localDelayOffset?(this._localDelayOffset=H,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=H-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let p=!1;const V=this._runtimeAnimations;let c;for(c=0;c<V.length;c++){const C=V[c].animate(H-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);p=p||C}if(this.animationStarted=p,!p){if(this.disposeOnEnd)for(c=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(c,1),c=0;c<V.length;c++)V[c].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return p}}function J(H){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return H.originalValue;let p=1;const V=t.l.o[0],c=t.l.o[1],C=t.l.Quaternion[0];let E=0;const z=H.animations[0],w=H.originalValue;let Q=1,P=!1;if(H.totalWeight<1)Q=1-H.totalWeight,w.decompose(c,C,V);else{if(E=1,p=H.totalWeight,Q=z.weight/p,1==Q){if(!H.totalAdditiveWeight)return z.currentValue;P=!0}z.currentValue.decompose(c,C,V)}if(!P){c.scaleInPlace(Q),V.scaleInPlace(Q),C.scaleInPlace(Q);for(let z=E;z<H.animations.length;z++){const E=H.animations[z];if(0===E.weight)continue;Q=E.weight/p;const w=t.l.o[2],P=t.l.o[3],U=t.l.Quaternion[1];E.currentValue.decompose(P,U,w),P.scaleAndAddToRef(Q,c),U.scaleAndAddToRef(t.i.Dot(C,U)>0?Q:-Q,C),w.scaleAndAddToRef(Q,V)}C.normalize()}for(let J=0;J<H.additiveAnimations.length;J++){const p=H.additiveAnimations[J];if(0===p.weight)continue;const E=t.l.o[2],z=t.l.o[3],w=t.l.Quaternion[1];p.currentValue.decompose(z,w,E),z.multiplyToRef(c,z),t.p.LerpToRef(c,z,p.weight,c),C.multiplyToRef(w,w),t.i.SlerpToRef(C,w,p.weight,C),E.scaleAndAddToRef(p.weight,V)}const U=z?z._animationState.workValue:t.l.Matrix[0].clone();return t.e.ComposeToRef(c,C,V,U),U}function l(H,p){if(0===H.totalWeight&&0===H.totalAdditiveWeight)return p;const V=H.animations[0],c=H.originalValue;let C=p;if(0===H.totalWeight&&H.totalAdditiveWeight>0)C.p(c);else if(1===H.animations.length){if(t.i.SlerpToRef(c,V.currentValue,Math.min(1,H.totalWeight),C),0===H.totalAdditiveWeight)return C}else if(H.animations.length>1){let V,E,z=1;if(H.totalWeight<1){const p=1-H.totalWeight;V=[],E=[],V.push(c),E.push(p)}else{if(2===H.animations.length&&(t.i.SlerpToRef(H.animations[0].currentValue,H.animations[1].currentValue,H.animations[1].weight/H.totalWeight,p),0===H.totalAdditiveWeight))return p;V=[],E=[],z=H.totalWeight}for(let p=0;p<H.animations.length;p++){const c=H.animations[p];V.push(c.currentValue),E.push(c.weight/z)}let w=0;for(let H=0;H<V.length;)H?(w+=E[H],t.i.SlerpToRef(C,V[H],E[H]/w,C),H++):(t.i.SlerpToRef(V[H],V[H+1],E[H+1]/(E[H]+E[H+1]),p),C=p,w=E[H]+E[H+1],H+=2)}for(let E=0;E<H.additiveAnimations.length;E++){const p=H.additiveAnimations[E];0!==p.weight&&(C.multiplyToRef(p.currentValue,t.l.Quaternion[0]),t.i.SlerpToRef(C,t.l.Quaternion[0],p.weight,C))}return C}var N,Z,Y=V(11093);N=Y.d,(Z=w.e)&&(Z.prototype.copyAnimationRange=function(H,p,V){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3],E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new c.b(this.name,"_matrix",H.animations[0].framePerSecond,c.b.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const z=H.animations[0].getRange(p);if(!z)return!1;const w=z.from,t=z.to,Q=H.animations[0].getKeys(),P=H.length,U=H.getParent(),J=this.getParent(),l=C&&U&&P&&this.length&&P!==this.length,N=l&&J&&U?J.length/U.length:1,Z=C&&!J&&E&&(1!==E.x||1!==E.y||1!==E.z),Y=this.animations[0].getKeys();let y,M,q;for(let c=0,j=Q.length;c<j;c++)y=Q[c],y.frame>=w&&y.frame<=t&&(C?(q=y.value.clone(),l?(M=q.getTranslation(),q.setTranslation(M.scaleInPlace(N))):Z&&E?(M=q.getTranslation(),q.setTranslation(M.multiplyInPlace(E))):q=y.value):q=y.value,Y.push({frame:y.frame+V,value:q}));return this.animations[0].createRange(p,w+V,t+V),!0}),N&&(N.prototype._animate=function(H){if(!this.animationsEnabled)return;const p=P.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=p}this.deltaTime=void 0!==H?H:this.useConstantAnimationDeltaTime?16:(p-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=p;const V=this._activeAnimatables;if(0===V.length)return;this._animationTime+=this.deltaTime;const C=this._animationTime;for(let c=0;c<V.length;c++){const H=V[c];!H._animate(C)&&H.disposeOnEnd&&c--}!function(H){if(H._registeredForLateAnimationBindings.length){for(let p=0;p<H._registeredForLateAnimationBindings.length;p++){const V=H._registeredForLateAnimationBindings.data[p];for(const H in V._lateAnimationHolders){const p=V._lateAnimationHolders[H],C=p.animations[0],E=p.originalValue;if(void 0===E||null===E)continue;const z=c.b.AllowMatrixDecomposeForInterpolation&&E.m;let w=V[H];if(z)w=J(p);else if(void 0!==E.w)w=l(p,w||t.i.Identity());else{let H=0,V=1;const z=C&&C._animationState.loopMode===c.b.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(p.totalWeight<1)w=z?E.clone?E.clone():E:C&&E.scale?E.scale(1-p.totalWeight):C?E*(1-p.totalWeight):E.clone?E.clone():E;else if(C){V=p.totalWeight;const c=C.weight/V;w=1!==c?C.currentValue.scale?C.currentValue.scale(c):C.currentValue*c:C.currentValue,z&&(w.addToRef?w.addToRef(E,w):w+=E),H=1}for(let c=H;c<p.animations.length;c++){const H=p.animations[c],C=H.weight/V;C&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(C,w):w+=H.currentValue*C)}for(let c=0;c<p.additiveAnimations.length;c++){const H=p.additiveAnimations[c],V=H.weight;V&&(H.currentValue.scaleAndAddToRef?H.currentValue.scaleAndAddToRef(V,w):w+=H.currentValue*V)}}V[H]=w}V._lateAnimationHolders={}}H._registeredForLateAnimationBindings.reset()}}(this)},N.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((H,p)=>H.playOrder-p.playOrder))},N.prototype.beginWeightedAnimation=function(H,p,V){let c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,C=arguments.length>4?arguments[4]:void 0,E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,t=arguments.length>8?arguments[8]:void 0,Q=arguments.length>9?arguments[9]:void 0,P=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const U=this.beginAnimation(H,p,V,C,E,z,w,!1,t,Q,P);return U.weight=c,U},N.prototype.beginAnimation=function(H,p,V,c){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,E=arguments.length>5?arguments[5]:void 0,z=arguments.length>6?arguments[6]:void 0,w=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],t=arguments.length>8?arguments[8]:void 0,Q=arguments.length>9?arguments[9]:void 0,P=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(C<0){const H=p;p=V,V=H,C=-C}p>V&&(C=-C),w&&this.stopAnimation(H,void 0,t),z||(z=new U(this,H,p,V,c,C,E,void 0,Q,P));const J=!t||t(H);if(H.animations&&J&&z.appendAnimations(H,H.animations),H.getAnimatables){const P=H.getAnimatables();for(let H=0;H<P.length;H++)this.beginAnimation(P[H],p,V,c,C,E,z,w,t,Q)}return z.reset(),z},N.prototype.beginHierarchyAnimation=function(H,p,V,c,C){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,z=arguments.length>6?arguments[6]:void 0,w=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Q=arguments.length>9?arguments[9]:void 0,P=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const U=H.getDescendants(p),J=[];J.push(this.beginAnimation(H,V,c,C,E,z,w,t,Q,void 0,P));for(const l of U)J.push(this.beginAnimation(l,V,c,C,E,z,w,t,Q,void 0,P));return J},N.prototype.beginDirectAnimation=function(H,p,V,c,C){let E=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(E<0){const H=V;V=c,c=H,E=-E}return V>c&&(E=-E),new U(this,H,V,c,C,E,arguments.length>6?arguments[6]:void 0,p,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},N.prototype.beginDirectHierarchyAnimation=function(H,p,V,c,C,E,z,w,t){let Q=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const P=H.getDescendants(p),U=[];U.push(this.beginDirectAnimation(H,V,c,C,E,z,w,t,Q));for(const J of P)U.push(this.beginDirectAnimation(J,V,c,C,E,z,w,t,Q));return U},N.prototype.getAnimatableByTarget=function(H){for(let p=0;p<this._activeAnimatables.length;p++)if(this._activeAnimatables[p].target===H)return this._activeAnimatables[p];return null},N.prototype.getAllAnimatablesByTarget=function(H){const p=[];for(let V=0;V<this._activeAnimatables.length;V++)this._activeAnimatables[V].target===H&&p.push(this._activeAnimatables[V]);return p},N.prototype.stopAnimation=function(H,p,V){const c=this.getAllAnimatablesByTarget(H);for(const C of c)C.stop(p,V)},N.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let H=0;H<this._activeAnimatables.length;H++)this._activeAnimatables[H].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const H of this.animationGroups)H.stop()});class y{getClassName(){return"TargetedAnimation"}serialize(){const H={};return H.animation=this.animation.serialize(),H.targetId=this.target.id,H}}class M{get mask(){return this._mask}set mask(H){this._mask!==H&&(this._mask=H,this.syncWithMask(!0))}syncWithMask(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||H){this._numActiveAnimatables=0;for(let H=0;H<this._animatables.length;++H){const p=this._animatables[H];!this.mask||this.mask.disabled||this.mask.retainsTarget(p.target.name)?(this._numActiveAnimatables++,p.paused&&p.restart()):p.paused||p.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let H=0;H<this._animatables.length;++H){const p=this._animatables[H];this.mask.retainsTarget(p.target.name)||(p.stop(),this._animatables.splice(H,1),--H)}for(let H=0;H<this._targetedAnimations.length;H++){const p=this._targetedAnimations[H];this.mask.retainsTarget(p.target.name)||(this._targetedAnimations.splice(H,1),--H)}}}get from(){return this._from}set from(H){if(this._from!==H){this._from=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].fromFrame=this._from}}}get to(){return this._to}set to(H){if(this._to!==H){this._to=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(H){if(this._speedRatio!==H){this._speedRatio=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(H){if(this._loopAnimation!==H){this._loopAnimation=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(H){if(this._isAdditive!==H){this._isAdditive=H;for(let H=0;H<this._animatables.length;H++){this._animatables[H].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(H){this._weight!==H&&(this._weight=H,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(H){if(this._playOrder!==H&&(this._playOrder=H,this._animatables.length>0)){for(let H=0;H<this._animatables.length;H++)this._animatables[H].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(H){if(this._enableBlending!==H&&(this._enableBlending=H,null!==H))for(let p=0;p<this._targetedAnimations.length;++p)this._targetedAnimations[p].animation.enableBlending=H}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(H){if(this._blendingSpeed!==H&&(this._blendingSpeed=H,null!==H))for(let p=0;p<this._targetedAnimations.length;++p)this._targetedAnimations[p].animation.blendingSpeed=H}getLength(H,p){H=H??this._from;return((p=p??this._to)-H)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(H){let p=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],V=arguments.length>2&&void 0!==arguments[2]&&arguments[2],c=arguments.length>3?arguments[3]:void 0;if(0===H.length)return null;c=c??H[0].weight;let C=Number.MAX_VALUE,E=-Number.MAX_VALUE;if(V)for(const w of H)w.from<C&&(C=w.from),w.to>E&&(E=w.to);const z=new M(H[0].name+"_merged",H[0]._scene,c);for(const w of H){V&&w.normalize(C,E);for(const H of w.targetedAnimations)z.addTargetedAnimation(H.animation,H.target);p&&w.dispose()}return z}constructor(H){let p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=H,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new C.c,this.onAnimationLoopObservable=new C.c,this.onAnimationGroupLoopObservable=new C.c,this.onAnimationGroupEndObservable=new C.c,this.onAnimationGroupPauseObservable=new C.c,this.onAnimationGroupPlayObservable=new C.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=p||E.e.LastCreatedScene,this._weight=V,this._playOrder=c,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(H,p){const V=new y;V.animation=H,V.target=p;const c=H.getKeys();return this._from>c[0].frame&&(this._from=c[0].frame),this._to<c[c.length-1].frame&&(this._to=c[c.length-1].frame),null!==this._enableBlending&&(H.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(H.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(V),this._shouldStart=!0,V}removeTargetedAnimation(H){for(let p=this._targetedAnimations.length-1;p>-1;p--){this._targetedAnimations[p].animation===H&&this._targetedAnimations.splice(p,1)}}normalize(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==H&&(H=this._from),null==p&&(p=this._to);for(let V=0;V<this._targetedAnimations.length;V++){const c=this._targetedAnimations[V].animation.getKeys(),C=c[0],E=c[c.length-1];if(C.frame>H){const p={frame:H,value:C.value,inTangent:C.inTangent,outTangent:C.outTangent,interpolation:C.interpolation};c.splice(0,0,p)}if(E.frame<p){const H={frame:p,value:E.value,inTangent:E.inTangent,outTangent:E.outTangent,interpolation:E.interpolation};c.push(H)}}return this._from=H,this._to=p,this}_processLoop(H,p,V){H.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(p),this._animationLoopFlags[V]||(this._animationLoopFlags[V]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0],p=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,V=arguments.length>2?arguments[2]:void 0,c=arguments.length>3?arguments[3]:void 0,C=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=H,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let E=0;E<this._targetedAnimations.length;E++){const z=this._targetedAnimations[E],w=this._scene.beginDirectAnimation(z.target,[z.animation],void 0!==V?V:this._from,void 0!==c?c:this._to,H,p,void 0,void 0,void 0!==C?C:this._isAdditive);w.weight=this._weight,w.playOrder=this._playOrder,w.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(z),this._checkAnimationGroupEnded(w)},this._processLoop(w,z,E),this._animatables.push(w)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=p,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let H=0;H<this._animatables.length;H++){this._animatables[H].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(H){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==H&&(this.loopAnimation=H),this.restart()):(this.stop(),this.start(H,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].reset()}return this}restart(){if(!this._isStarted)return this;for(let H=0;H<this._animatables.length;H++){this._animatables[H].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const p=this._animatables.slice();for(let c=0;c<p.length;c++)p[c].stop(void 0,void 0,!0,H);let V=0;for(let c=0;c<this._scene._activeAnimatables.length;c++){const p=this._scene._activeAnimatables[c];p._runtimeAnimations.length>0?this._scene._activeAnimatables[V++]=p:H&&this._checkAnimationGroupEnded(p,H)}return this._scene._activeAnimatables.length=V,this._isStarted=!1,this}setWeightForAllAnimatables(H){for(let p=0;p<this._animatables.length;p++){this._animatables[p].weight=H}return this}syncAllAnimationsWith(H){for(let p=0;p<this._animatables.length;p++){this._animatables[p].syncWith(H)}return this}goToFrame(H){if(!this._isStarted)return this;for(let p=0;p<this._animatables.length;p++){this._animatables[p].goToFrame(H)}return this}getCurrentFrame(){var H;return(null===(H=this.animatables[0])||void 0===H?void 0:H.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const H=this._scene.animationGroups.indexOf(this);if(H>-1&&this._scene.animationGroups.splice(H,1),this._parentContainer){const H=this._parentContainer.animationGroups.indexOf(this);H>-1&&this._parentContainer.animationGroups.splice(H,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(H){let p=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const V=this._animatables.indexOf(H);V>-1&&this._animatables.splice(V,1),0===this._animatables.length&&(this._isStarted=!1,p||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(H,p){let V=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=new M(H||this.name,this._scene,this._weight,this._playOrder);c._from=this.from,c._to=this.to,c._speedRatio=this.speedRatio,c._loopAnimation=this.loopAnimation,c._isAdditive=this.isAdditive,c._enableBlending=this.enableBlending,c._blendingSpeed=this.blendingSpeed,c.metadata=this.metadata,c.mask=this.mask;for(const C of this._targetedAnimations)c.addTargetedAnimation(V?C.animation.clone():C.animation,p?p(C.target):C.target);return c}serialize(){const H={};H.name=this.name,H.from=this.from,H.to=this.to,H.speedRatio=this.speedRatio,H.loopAnimation=this.loopAnimation,H.isAdditive=this.isAdditive,H.weight=this.weight,H.playOrder=this.playOrder,H.enableBlending=this.enableBlending,H.blendingSpeed=this.blendingSpeed,H.targetedAnimations=[];for(let p=0;p<this.targetedAnimations.length;p++){const V=this.targetedAnimations[p];H.targetedAnimations[p]=V.serialize()}return z.d&&z.d.HasTags(this)&&(H.tags=z.d.GetTags(this)),this.metadata&&(H.metadata=this.metadata),H}static Parse(H,p){const V=new M(H.name,p,H.weight,H.playOrder);for(let C=0;C<H.targetedAnimations.length;C++){const E=H.targetedAnimations[C],z=c.b.Parse(E.animation),w=E.targetId;if("influence"===E.animation.property){const H=p.getMorphTargetById(w);H&&V.addTargetedAnimation(z,H)}else{const H=p.getNodeById(w);null!=H&&V.addTargetedAnimation(z,H)}}return z.d&&z.d.AddTagsTo(V,H.tags),null!==H.from&&null!==H.to&&V.normalize(H.from,H.to),void 0!==H.speedRatio&&(V._speedRatio=H.speedRatio),void 0!==H.loopAnimation&&(V._loopAnimation=H.loopAnimation),void 0!==H.isAdditive&&(V._isAdditive=H.isAdditive),void 0!==H.weight&&(V._weight=H.weight),void 0!==H.playOrder&&(V._playOrder=H.playOrder),void 0!==H.enableBlending&&(V._enableBlending=H.enableBlending),void 0!==H.blendingSpeed&&(V._blendingSpeed=H.blendingSpeed),void 0!==H.metadata&&(V.metadata=H.metadata),V}static MakeAnimationAdditive(H,p,V){let C;C="object"===typeof p?p:{referenceFrame:p,range:V,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let E=H;C.cloneOriginalAnimationGroup&&(E=H.clone(C.clonedAnimationGroupName||E.name));const z=E.targetedAnimations;for(let w=0;w<z.length;w++){const H=z[w];H.animation=c.b.MakeAnimationAdditive(H.animation,C)}if(E.isAdditive=!0,C.clipKeys){let H=Number.MAX_VALUE,p=-Number.MAX_VALUE;const V=E.targetedAnimations;for(let c=0;c<V.length;c++){const C=V[c].animation.getKeys();H>C[0].frame&&(H=C[0].frame),p<C[C.length-1].frame&&(p=C[C.length-1].frame)}E._from=H,E._to=p}return E}static ClipKeys(H,p,V,c,C){const E=H.clone(c||H.name);return M.ClipKeysInPlace(E,p,V,C)}static ClipKeysInPlace(H,p,V,c){return M.ClipInPlace(H,p,V,c,!1)}static ClipFrames(H,p,V,c,C){const E=H.clone(c||H.name);return M.ClipFramesInPlace(E,p,V,C)}static ClipFramesInPlace(H,p,V,c){return M.ClipInPlace(H,p,V,c,!0)}static ClipInPlace(H,p,V,c){let C=arguments.length>4&&void 0!==arguments[4]&&arguments[4],E=Number.MAX_VALUE,z=-Number.MAX_VALUE;const w=H.targetedAnimations;for(let t=0;t<w.length;t++){const H=w[t],Q=c?H.animation:H.animation.clone();C&&(Q.createKeyForFrame(p),Q.createKeyForFrame(V));const P=Q.getKeys(),U=[];let J=Number.MAX_VALUE;for(let c=0;c<P.length;c++){const H=P[c];if(!C&&c>=p&&c<=V||C&&H.frame>=p&&H.frame<=V){const p={frame:H.frame,value:H.value.clone?H.value.clone():H.value,inTangent:H.inTangent,outTangent:H.outTangent,interpolation:H.interpolation,lockedTangent:H.lockedTangent};J===Number.MAX_VALUE&&(J=p.frame),p.frame-=J,U.push(p)}}0!==U.length?(E>U[0].frame&&(E=U[0].frame),z<U[U.length-1].frame&&(z=U[U.length-1].frame),Q.setKeys(U,!0),H.animation=Q):(w.splice(t,1),t--)}return H._from=E,H._to=z,H}getClassName(){return"AnimationGroup"}toString(H){let p="Name: "+this.name;return p+=", type: "+this.getClassName(),H&&(p+=", from: "+this._from,p+=", to: "+this._to,p+=", isStarted: "+this._isStarted,p+=", speedRatio: "+this._speedRatio,p+=", targetedAnimations length: "+this._targetedAnimations.length,p+=", animatables length: "+this._animatables),p}}}}]);