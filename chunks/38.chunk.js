"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13570:(v,y,n)=>{n.r(y),n.d(y,{AnimationGroup:()=>E,TargetedAnimation:()=>h});var B=n(12275),J=n(10795),P=n(10820),b=n(11076),Y=n(12270),l=n(11081);class a{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(v,y,n,J){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=y,this._target=v,this._scene=n,this._host=J,this._activeTargets=[],y._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===B.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=l.d.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const v={frame:0,value:this._minValue};this._keys.splice(0,0,v)}if(this._target instanceof Array){let v=0;for(const y of this._target)this._preparePath(y,v),this._getOriginalValues(v),v++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const P=y.getEvents();P&&P.length>0&&P.forEach((v=>{this._events.push(v._clone())})),this._enableBlending=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(v){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=this._animation.targetPropertyPath;if(n.length>1){let B=v;for(let v=0;v<n.length-1;v++){const y=n[v];if(B=B[y],void 0===B)throw new Error(`Invalid property (${y}) in property path (${n.join(".")})`)}this._targetPath=n[n.length-1],this._activeTargets[y]=B}else this._targetPath=n[0],this._activeTargets[y]=v;if(void 0===this._activeTargets[y][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${n.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let v=0;for(const y of this._target)void 0!==this._originalValue[v]&&this._setValue(y,this._activeTargets[v],this._originalValue[v],-1,v),v++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let v=0;v<this._events.length;v++)this._events[v].isDone=!1}isStopped(){return this._stopped}dispose(){const v=this._animation.runtimeAnimations.indexOf(this);v>-1&&this._animation.runtimeAnimations.splice(v,1)}setValue(v,y){if(this._targetIsArray)for(let n=0;n<this._target.length;n++){const B=this._target[n];this._setValue(B,this._activeTargets[n],v,y,n)}else this._setValue(this._target,this._directTarget,v,y,0)}_getOriginalValues(){let v,y=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=this._activeTargets[y];v=n.getLocalMatrix&&"_matrix"===this._targetPath?n.getLocalMatrix():n[this._targetPath],v&&v.clone?this._originalValue[y]=v.clone():this._originalValue[y]=v}_registerTargetForLateAnimationBinding(v,y){const n=v.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(n),n._lateAnimationHolders||(n._lateAnimationHolders={}),n._lateAnimationHolders[v.targetPath]||(n._lateAnimationHolders[v.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:y}),v.isAdditive?(n._lateAnimationHolders[v.targetPath].additiveAnimations.push(v),n._lateAnimationHolders[v.targetPath].totalAdditiveWeight+=v.weight):(n._lateAnimationHolders[v.targetPath].animations.push(v),n._lateAnimationHolders[v.targetPath].totalWeight+=v.weight)}_setValue(v,y,n,J,P){if(this._currentActiveTarget=y,this._weight=J,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const v=y[this._targetPath];v.clone?this._originalBlendValue=v.clone():this._originalBlendValue=v}this._originalBlendValue.m?B.c.AllowMatrixDecomposeForInterpolation?this._currentValue?l.d.DecomposeLerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=l.d.DecomposeLerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue?l.d.LerpToRef(this._originalBlendValue,n,this._blendingFactor,this._currentValue):this._currentValue=l.d.Lerp(this._originalBlendValue,n,this._blendingFactor):this._currentValue=B.c._UniversalLerp(this._originalBlendValue,n,this._blendingFactor);const J=v&&v.animationPropertiesOverride?v.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=J}else this._currentValue?this._currentValue.p?this._currentValue.p(n):this._currentValue=n:null!==n&&void 0!==n&&n.clone?this._currentValue=n.clone():this._currentValue=n;-1!==J?this._registerTargetForLateAnimationBinding(this,this._originalValue[P]):this._animationState.loopMode===B.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[P],y[this._targetPath]):y[this._targetPath]=this._originalValue[P]+this._currentValue:y[this._targetPath]=this._currentValue,v.eh&&v.eh(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(v){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=this._animation.getKeys();v<n[0].frame?v=n[0].frame:v>n[n.length-1].frame&&(v=n[n.length-1].frame);const B=this._events;if(B.length)for(let P=0;P<B.length;P++)B[P].onlyOnce||(B[P].isDone=B[P].frame<v);this._currentFrame=v;const J=this._animation._interpolate(v,this._animationState);this.setValue(J,y)}_prepareForSpeedRatioChange(v){const y=this._previousElapsedTime*(this._animation.framePerSecond*v)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-y}animate(v,y,n,J,P){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const Y=this._animation,l=Y.targetPropertyPath;if(!l||l.length<1)return this._stopped=!0,!1;let a=!0;(y<this._minFrame||y>this._maxFrame)&&(y=this._minFrame),(n<this._minFrame||n>this._maxFrame)&&(n=this._maxFrame);const Z=n-y;let x,f=v*(Y.framePerSecond*P)/1e3+this._absoluteFrameOffset,N=0,i=!1;const g=J&&this._animationState.loopMode===B.c.ANIMATIONLOOPMODE_YOYO;if(g){const v=(f-y)/Z,n=Math.sin(v*Math.PI);f=Math.abs(n)*Z+y;const B=n>=0?1:-1;this._yoyoDirection!==B&&(i=!0),this._yoyoDirection=B}if(this._previousElapsedTime=v,this._previousAbsoluteFrame=f,!J&&n>=y&&(f>=Z&&P>0||f<=0&&P<0))a=!1,N=Y._getKeyValue(this._maxValue);else if(!J&&y>=n&&(f<=Z&&P<0||f>=0&&P>0))a=!1,N=Y._getKeyValue(this._minValue);else if(this._animationState.loopMode!==B.c.ANIMATIONLOOPMODE_CYCLE){const v=n.toString()+y.toString();if(!this._offsetsCache[v]){this._animationState.repeatCount=0,this._animationState.loopMode=B.c.ANIMATIONLOOPMODE_CYCLE;const J=Y._interpolate(y,this._animationState),P=Y._interpolate(n,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),Y.dataType){case B.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[v]=P-J;break;case B.c.ANIMATIONTYPE_QUATERNION:case B.c.ANIMATIONTYPE_VECTOR3:case B.c.ANIMATIONTYPE_VECTOR2:case B.c.ANIMATIONTYPE_SIZE:case B.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[v]=P.od(J)}this._highLimitsCache[v]=P}N=this._highLimitsCache[v],x=this._offsetsCache[v]}if(void 0===x)switch(Y.dataType){case B.c.ANIMATIONTYPE_FLOAT:x=0;break;case B.c.ANIMATIONTYPE_QUATERNION:x=B.l;break;case B.c.ANIMATIONTYPE_VECTOR3:x=B.t;break;case B.c.ANIMATIONTYPE_VECTOR2:x=B.q;break;case B.c.ANIMATIONTYPE_SIZE:x=B.n;break;case B.c.ANIMATIONTYPE_COLOR3:x=B.e;break;case B.c.ANIMATIONTYPE_COLOR4:x=B.h}let c;if(this._host&&this._host.syncRoot){const v=this._host.syncRoot;c=y+Z*((v.masterFrame-v.fromFrame)/(v.toFrame-v.fromFrame))}else c=f>0&&y>n||f<0&&y<n?a&&0!==Z?n+f%Z:y:a&&0!==Z?y+f%Z:n;const h=this._events;if(!g&&(P>0&&this.currentFrame>c||P<0&&this.currentFrame<c)||g&&i){this._onLoop();for(let v=0;v<h.length;v++)h[v].onlyOnce||(h[v].isDone=!1);this._animationState.key=P>0?0:Y.getKeys().length-1}this._currentFrame=c,this._animationState.repeatCount=0===Z?0:f/Z|0,this._animationState.highLimitValue=N,this._animationState.offsetValue=x;const E=Y._interpolate(c,this._animationState);if(this.setValue(E,b),h.length)for(let B=0;B<h.length;B++)if(Z>=0&&c>=h[B].frame&&h[B].frame>=y||Z<0&&c<=h[B].frame&&h[B].frame<=y){const v=h[B];v.isDone||(v.onlyOnce&&(h.splice(B,1),B--),v.isDone=!0,v.action(c))}return a||(this._stopped=!0),a}}var Z=n(10805);class x{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(v){this._weight=-1!==v?Math.min(Math.max(v,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(v){for(let y=0;y<this._runtimeAnimations.length;y++){this._runtimeAnimations[y]._prepareForSpeedRatioChange(v)}this._speedRatio=v,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(v,y){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,P=arguments.length>4&&void 0!==arguments[4]&&arguments[4],b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,Y=arguments.length>6?arguments[6]:void 0,l=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,Z=arguments.length>9&&void 0!==arguments[9]&&arguments[9],x=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=y,this.fromFrame=n,this.toFrame=B,this.loopAnimation=P,this.onAnimationEnd=Y,this.onAnimationLoop=a,this.isAdditive=Z,this.playOrder=x,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.be=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new J.e,this.onAnimationLoopObservable=new J.e,this._scene=v,l&&this.appendAnimations(y,l),this._speedRatio=b,v._activeAnimatables.push(this)}syncWith(v){if(this._syncRoot=v,v){const v=this._scene._activeAnimatables.indexOf(this);v>-1&&(this._scene._activeAnimatables.splice(v,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(v,y){for(let n=0;n<y.length;n++){const B=y[n],J=new a(v,B,this._scene,this);J._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(J)}}getAnimationByTargetProperty(v){const y=this._runtimeAnimations;for(let n=0;n<y.length;n++)if(y[n].animation.targetProperty===v)return y[n].animation;return null}getRuntimeAnimationByTargetProperty(v){const y=this._runtimeAnimations;for(let n=0;n<y.length;n++)if(y[n].animation.targetProperty===v)return y[n];return null}reset(){const v=this._runtimeAnimations;for(let y=0;y<v.length;y++)v[y].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(v){const y=this._runtimeAnimations;for(let n=0;n<y.length;n++)y[n].animation.enableBlending=!0,y[n].animation.blendingSpeed=v}disableBlending(){const v=this._runtimeAnimations;for(let y=0;y<v.length;y++)v[y].animation.enableBlending=!1}goToFrame(v){const y=this._runtimeAnimations;if(y[0]){const n=y[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??y[0].currentFrame;const B=0===this.speedRatio?0:(v-this._frameToSyncFromJump)/n*1e3/this.speedRatio;this._manualJumpDelay=-B}for(let n=0;n<y.length;n++)y[n].goToFrame(v,this._weight);this._goToFrame=v}get paused(){return this.be}pause(){this.be||(this.be=!0)}restart(){this.be=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(v,y){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(v||y){const J=this._scene._activeAnimatables.indexOf(this);if(J>-1){const P=this._runtimeAnimations;for(let n=P.length-1;n>=0;n--){const B=P[n];v&&B.animation.name!=v||(y&&!y(B.target)||(B.dispose(),P.splice(n,1)))}0==P.length&&(n||this._scene._activeAnimatables.splice(J,1),B||this._raiseOnAnimationEnd())}}else{const v=this._scene._activeAnimatables.indexOf(this);if(v>-1){n||this._scene._activeAnimatables.splice(v,1);const y=this._runtimeAnimations;for(let v=0;v<y.length;v++)y[v].dispose();this._runtimeAnimations.length=0,B||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((v=>{this.onAnimationEndObservable.add((()=>{v(this)}),void 0,void 0,this,!0)}))}_animate(v){if(this.be)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=v),!0;if(null===this._localDelayOffset?(this._localDelayOffset=v,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=v-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let y=!1;const n=this._runtimeAnimations;let B;for(B=0;B<n.length;B++){const J=n[B].animate(v-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);y=y||J}if(this.animationStarted=y,!y){if(this.disposeOnEnd)for(B=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(B,1),B=0;B<n.length;B++)n[B].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return y}}function f(v){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return v.originalValue;let y=1;const n=l.i.o[0],B=l.i.o[1],J=l.i.Quaternion[0];let P=0;const b=v.animations[0],Y=v.originalValue;let a=1,Z=!1;if(v.totalWeight<1)a=1-v.totalWeight,Y.decompose(B,J,n);else{if(P=1,y=v.totalWeight,a=b.weight/y,1==a){if(!v.totalAdditiveWeight)return b.currentValue;Z=!0}b.currentValue.decompose(B,J,n)}if(!Z){B.scaleInPlace(a),n.scaleInPlace(a),J.scaleInPlace(a);for(let b=P;b<v.animations.length;b++){const P=v.animations[b];if(0===P.weight)continue;a=P.weight/y;const Y=l.i.o[2],Z=l.i.o[3],x=l.i.Quaternion[1];P.currentValue.decompose(Z,x,Y),Z.scaleAndAddToRef(a,B),x.scaleAndAddToRef(l.g.Dot(J,x)>0?a:-a,J),Y.scaleAndAddToRef(a,n)}J.normalize()}for(let f=0;f<v.additiveAnimations.length;f++){const y=v.additiveAnimations[f];if(0===y.weight)continue;const P=l.i.o[2],b=l.i.o[3],Y=l.i.Quaternion[1];y.currentValue.decompose(b,Y,P),b.multiplyToRef(B,b),l.n.LerpToRef(B,b,y.weight,B),J.multiplyToRef(Y,Y),l.g.SlerpToRef(J,Y,y.weight,J),P.scaleAndAddToRef(y.weight,n)}const x=b?b._animationState.workValue:l.i.Matrix[0].clone();return l.d.ComposeToRef(B,J,n,x),x}function N(v,y){if(0===v.totalWeight&&0===v.totalAdditiveWeight)return y;const n=v.animations[0],B=v.originalValue;let J=y;if(0===v.totalWeight&&v.totalAdditiveWeight>0)J.p(B);else if(1===v.animations.length){if(l.g.SlerpToRef(B,n.currentValue,Math.min(1,v.totalWeight),J),0===v.totalAdditiveWeight)return J}else if(v.animations.length>1){let n,P,b=1;if(v.totalWeight<1){const y=1-v.totalWeight;n=[],P=[],n.push(B),P.push(y)}else{if(2===v.animations.length&&(l.g.SlerpToRef(v.animations[0].currentValue,v.animations[1].currentValue,v.animations[1].weight/v.totalWeight,y),0===v.totalAdditiveWeight))return y;n=[],P=[],b=v.totalWeight}for(let y=0;y<v.animations.length;y++){const B=v.animations[y];n.push(B.currentValue),P.push(B.weight/b)}let Y=0;for(let v=0;v<n.length;)v?(Y+=P[v],l.g.SlerpToRef(J,n[v],P[v]/Y,J),v++):(l.g.SlerpToRef(n[v],n[v+1],P[v+1]/(P[v]+P[v+1]),y),J=y,Y=P[v]+P[v+1],v+=2)}for(let P=0;P<v.additiveAnimations.length;P++){const y=v.additiveAnimations[P];0!==y.weight&&(J.multiplyToRef(y.currentValue,l.i.Quaternion[0]),l.g.SlerpToRef(J,l.i.Quaternion[0],y.weight,J))}return J}var i,g,c=n(11070);i=c.e,(g=Y.c)&&(g.prototype.copyAnimationRange=function(v,y,n){let J=arguments.length>3&&void 0!==arguments[3]&&arguments[3],P=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new B.c(this.name,"_matrix",v.animations[0].framePerSecond,B.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const b=v.animations[0].getRange(y);if(!b)return!1;const Y=b.from,l=b.to,a=v.animations[0].getKeys(),Z=v.length,x=v.getParent(),f=this.getParent(),N=J&&x&&Z&&this.length&&Z!==this.length,i=N&&f&&x?f.length/x.length:1,g=J&&!f&&P&&(1!==P.x||1!==P.y||1!==P.z),c=this.animations[0].getKeys();let h,E,W;for(let B=0,s=a.length;B<s;B++)h=a[B],h.frame>=Y&&h.frame<=l&&(J?(W=h.value.clone(),N?(E=W.getTranslation(),W.setTranslation(E.scaleInPlace(i))):g&&P?(E=W.getTranslation(),W.setTranslation(E.multiplyInPlace(P))):W=h.value):W=h.value,c.push({frame:h.frame+n,value:W}));return this.animations[0].createRange(y,Y+n,l+n),!0}),i&&(i.prototype._animate=function(v){if(!this.animationsEnabled)return;const y=Z.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=y}this.deltaTime=void 0!==v?v:this.useConstantAnimationDeltaTime?16:(y-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=y;const n=this._activeAnimatables;if(0===n.length)return;this._animationTime+=this.deltaTime;const J=this._animationTime;for(let B=0;B<n.length;B++){const v=n[B];!v._animate(J)&&v.disposeOnEnd&&B--}!function(v){if(v._registeredForLateAnimationBindings.length){for(let y=0;y<v._registeredForLateAnimationBindings.length;y++){const n=v._registeredForLateAnimationBindings.data[y];for(const v in n._lateAnimationHolders){const y=n._lateAnimationHolders[v],J=y.animations[0],P=y.originalValue;if(void 0===P||null===P)continue;const b=B.c.AllowMatrixDecomposeForInterpolation&&P.m;let Y=n[v];if(b)Y=f(y);else if(void 0!==P.w)Y=N(y,Y||l.g.Identity());else{let v=0,n=1;const b=J&&J._animationState.loopMode===B.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(y.totalWeight<1)Y=b?P.clone?P.clone():P:J&&P.scale?P.scale(1-y.totalWeight):J?P*(1-y.totalWeight):P.clone?P.clone():P;else if(J){n=y.totalWeight;const B=J.weight/n;Y=1!==B?J.currentValue.scale?J.currentValue.scale(B):J.currentValue*B:J.currentValue,b&&(Y.addToRef?Y.addToRef(P,Y):Y+=P),v=1}for(let B=v;B<y.animations.length;B++){const v=y.animations[B],J=v.weight/n;J&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(J,Y):Y+=v.currentValue*J)}for(let B=0;B<y.additiveAnimations.length;B++){const v=y.additiveAnimations[B],n=v.weight;n&&(v.currentValue.scaleAndAddToRef?v.currentValue.scaleAndAddToRef(n,Y):Y+=v.currentValue*n)}}n[v]=Y}n._lateAnimationHolders={}}v._registeredForLateAnimationBindings.reset()}}(this)},i.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((v,y)=>v.playOrder-y.playOrder))},i.prototype.beginWeightedAnimation=function(v,y,n){let B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,J=arguments.length>4?arguments[4]:void 0,P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,l=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const x=this.beginAnimation(v,y,n,J,P,b,Y,!1,l,a,Z);return x.weight=B,x},i.prototype.beginAnimation=function(v,y,n,B){let J=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,P=arguments.length>5?arguments[5]:void 0,b=arguments.length>6?arguments[6]:void 0,Y=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],l=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,Z=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(J<0){const v=y;y=n,n=v,J=-J}y>n&&(J=-J),Y&&this.stopAnimation(v,void 0,l),b||(b=new x(this,v,y,n,B,J,P,void 0,a,Z));const f=!l||l(v);if(v.animations&&f&&b.appendAnimations(v,v.animations),v.getAnimatables){const Z=v.getAnimatables();for(let v=0;v<Z.length;v++)this.beginAnimation(Z[v],y,n,B,J,P,b,Y,l,a)}return b.reset(),b},i.prototype.beginHierarchyAnimation=function(v,y,n,B,J){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,b=arguments.length>6?arguments[6]:void 0,Y=arguments.length>7?arguments[7]:void 0,l=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=arguments.length>9?arguments[9]:void 0,Z=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const x=v.getDescendants(y),f=[];f.push(this.beginAnimation(v,n,B,J,P,b,Y,l,a,void 0,Z));for(const N of x)f.push(this.beginAnimation(N,n,B,J,P,b,Y,l,a,void 0,Z));return f},i.prototype.beginDirectAnimation=function(v,y,n,B,J){let P=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(P<0){const v=n;n=B,B=v,P=-P}return n>B&&(P=-P),new x(this,v,n,B,J,P,arguments.length>6?arguments[6]:void 0,y,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},i.prototype.beginDirectHierarchyAnimation=function(v,y,n,B,J,P,b,Y,l){let a=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const Z=v.getDescendants(y),x=[];x.push(this.beginDirectAnimation(v,n,B,J,P,b,Y,l,a));for(const f of Z)x.push(this.beginDirectAnimation(f,n,B,J,P,b,Y,l,a));return x},i.prototype.getAnimatableByTarget=function(v){for(let y=0;y<this._activeAnimatables.length;y++)if(this._activeAnimatables[y].target===v)return this._activeAnimatables[y];return null},i.prototype.getAllAnimatablesByTarget=function(v){const y=[];for(let n=0;n<this._activeAnimatables.length;n++)this._activeAnimatables[n].target===v&&y.push(this._activeAnimatables[n]);return y},i.prototype.stopAnimation=function(v,y,n){const B=this.getAllAnimatablesByTarget(v);for(const J of B)J.stop(y,n)},i.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let v=0;v<this._activeAnimatables.length;v++)this._activeAnimatables[v].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const v of this.animationGroups)v.stop()});class h{getClassName(){return"TargetedAnimation"}serialize(){const v={};return v.animation=this.animation.serialize(),v.targetId=this.target.id,v}}class E{get mask(){return this._mask}set mask(v){this._mask!==v&&(this._mask=v,this.syncWithMask(!0))}syncWithMask(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||v){this._numActiveAnimatables=0;for(let v=0;v<this._animatables.length;++v){const y=this._animatables[v];!this.mask||this.mask.disabled||this.mask.retainsTarget(y.target.name)?(this._numActiveAnimatables++,y.paused&&y.restart()):y.paused||y.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let v=0;v<this._animatables.length;++v){const y=this._animatables[v];this.mask.retainsTarget(y.target.name)||(y.stop(),this._animatables.splice(v,1),--v)}for(let v=0;v<this._targetedAnimations.length;v++){const y=this._targetedAnimations[v];this.mask.retainsTarget(y.target.name)||(this._targetedAnimations.splice(v,1),--v)}}}get from(){return this._from}set from(v){if(this._from!==v){this._from=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].fromFrame=this._from}}}get to(){return this._to}set to(v){if(this._to!==v){this._to=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(v){if(this._speedRatio!==v){this._speedRatio=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(v){if(this._loopAnimation!==v){this._loopAnimation=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(v){if(this._isAdditive!==v){this._isAdditive=v;for(let v=0;v<this._animatables.length;v++){this._animatables[v].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(v){this._weight!==v&&(this._weight=v,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(v){if(this._playOrder!==v&&(this._playOrder=v,this._animatables.length>0)){for(let v=0;v<this._animatables.length;v++)this._animatables[v].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(v){if(this._enableBlending!==v&&(this._enableBlending=v,null!==v))for(let y=0;y<this._targetedAnimations.length;++y)this._targetedAnimations[y].animation.enableBlending=v}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(v){if(this._blendingSpeed!==v&&(this._blendingSpeed=v,null!==v))for(let y=0;y<this._targetedAnimations.length;++y)this._targetedAnimations[y].animation.blendingSpeed=v}getLength(v,y){v=v??this._from;return((y=y??this._to)-v)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(v){let y=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],B=arguments.length>3?arguments[3]:void 0;if(0===v.length)return null;B=B??v[0].weight;let J=Number.MAX_VALUE,P=-Number.MAX_VALUE;if(n)for(const Y of v)Y.from<J&&(J=Y.from),Y.to>P&&(P=Y.to);const b=new E(v[0].name+"_merged",v[0]._scene,B);for(const Y of v){n&&Y.normalize(J,P);for(const v of Y.targetedAnimations)b.addTargetedAnimation(v.animation,v.target);y&&Y.dispose()}return b}constructor(v){let y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=v,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new J.e,this.onAnimationLoopObservable=new J.e,this.onAnimationGroupLoopObservable=new J.e,this.onAnimationGroupEndObservable=new J.e,this.onAnimationGroupPauseObservable=new J.e,this.onAnimationGroupPlayObservable=new J.e,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=y||P.b.LastCreatedScene,this._weight=n,this._playOrder=B,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(v,y){const n=new h;n.animation=v,n.target=y;const B=v.getKeys();return this._from>B[0].frame&&(this._from=B[0].frame),this._to<B[B.length-1].frame&&(this._to=B[B.length-1].frame),null!==this._enableBlending&&(v.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(v.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(n),this._shouldStart=!0,n}removeTargetedAnimation(v){for(let y=this._targetedAnimations.length-1;y>-1;y--){this._targetedAnimations[y].animation===v&&this._targetedAnimations.splice(y,1)}}normalize(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==v&&(v=this._from),null==y&&(y=this._to);for(let n=0;n<this._targetedAnimations.length;n++){const B=this._targetedAnimations[n].animation.getKeys(),J=B[0],P=B[B.length-1];if(J.frame>v){const y={frame:v,value:J.value,inTangent:J.inTangent,outTangent:J.outTangent,interpolation:J.interpolation};B.splice(0,0,y)}if(P.frame<y){const v={frame:y,value:P.value,inTangent:P.inTangent,outTangent:P.outTangent,interpolation:P.interpolation};B.push(v)}}return this._from=v,this._to=y,this}_processLoop(v,y,n){v.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(y),this._animationLoopFlags[n]||(this._animationLoopFlags[n]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0],y=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,B=arguments.length>3?arguments[3]:void 0,J=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=v,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let P=0;P<this._targetedAnimations.length;P++){const b=this._targetedAnimations[P],Y=this._scene.beginDirectAnimation(b.target,[b.animation],void 0!==n?n:this._from,void 0!==B?B:this._to,v,y,void 0,void 0,void 0!==J?J:this._isAdditive);Y.weight=this._weight,Y.playOrder=this._playOrder,Y.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(b),this._checkAnimationGroupEnded(Y)},this._processLoop(Y,b,P),this._animatables.push(Y)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=y,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let v=0;v<this._animatables.length;v++){this._animatables[v].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(v){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==v&&(this.loopAnimation=v),this.restart()):(this.stop(),this.start(v,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].reset()}return this}restart(){if(!this._isStarted)return this;for(let v=0;v<this._animatables.length;v++){this._animatables[v].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const y=this._animatables.slice();for(let B=0;B<y.length;B++)y[B].stop(void 0,void 0,!0,v);let n=0;for(let B=0;B<this._scene._activeAnimatables.length;B++){const y=this._scene._activeAnimatables[B];y._runtimeAnimations.length>0?this._scene._activeAnimatables[n++]=y:v&&this._checkAnimationGroupEnded(y,v)}return this._scene._activeAnimatables.length=n,this._isStarted=!1,this}setWeightForAllAnimatables(v){for(let y=0;y<this._animatables.length;y++){this._animatables[y].weight=v}return this}syncAllAnimationsWith(v){for(let y=0;y<this._animatables.length;y++){this._animatables[y].syncWith(v)}return this}goToFrame(v){if(!this._isStarted)return this;for(let y=0;y<this._animatables.length;y++){this._animatables[y].goToFrame(v)}return this}getCurrentFrame(){var v;return(null===(v=this.animatables[0])||void 0===v?void 0:v.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const v=this._scene.animationGroups.indexOf(this);if(v>-1&&this._scene.animationGroups.splice(v,1),this._parentContainer){const v=this._parentContainer.animationGroups.indexOf(this);v>-1&&this._parentContainer.animationGroups.splice(v,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(v){let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=this._animatables.indexOf(v);n>-1&&this._animatables.splice(n,1),0===this._animatables.length&&(this._isStarted=!1,y||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(v,y){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=new E(v||this.name,this._scene,this._weight,this._playOrder);B._from=this.from,B._to=this.to,B._speedRatio=this.speedRatio,B._loopAnimation=this.loopAnimation,B._isAdditive=this.isAdditive,B._enableBlending=this.enableBlending,B._blendingSpeed=this.blendingSpeed,B.metadata=this.metadata,B.mask=this.mask;for(const J of this._targetedAnimations)B.addTargetedAnimation(n?J.animation.clone():J.animation,y?y(J.target):J.target);return B}serialize(){const v={};v.name=this.name,v.from=this.from,v.to=this.to,v.speedRatio=this.speedRatio,v.loopAnimation=this.loopAnimation,v.isAdditive=this.isAdditive,v.weight=this.weight,v.playOrder=this.playOrder,v.enableBlending=this.enableBlending,v.blendingSpeed=this.blendingSpeed,v.targetedAnimations=[];for(let y=0;y<this.targetedAnimations.length;y++){const n=this.targetedAnimations[y];v.targetedAnimations[y]=n.serialize()}return b.c&&b.c.HasTags(this)&&(v.tags=b.c.GetTags(this)),this.metadata&&(v.metadata=this.metadata),v}static Parse(v,y){const n=new E(v.name,y,v.weight,v.playOrder);for(let J=0;J<v.targetedAnimations.length;J++){const P=v.targetedAnimations[J],b=B.c.Parse(P.animation),Y=P.targetId;if("influence"===P.animation.property){const v=y.getMorphTargetById(Y);v&&n.addTargetedAnimation(b,v)}else{const v=y.getNodeById(Y);null!=v&&n.addTargetedAnimation(b,v)}}return b.c&&b.c.AddTagsTo(n,v.tags),null!==v.from&&null!==v.to&&n.normalize(v.from,v.to),void 0!==v.speedRatio&&(n._speedRatio=v.speedRatio),void 0!==v.loopAnimation&&(n._loopAnimation=v.loopAnimation),void 0!==v.isAdditive&&(n._isAdditive=v.isAdditive),void 0!==v.weight&&(n._weight=v.weight),void 0!==v.playOrder&&(n._playOrder=v.playOrder),void 0!==v.enableBlending&&(n._enableBlending=v.enableBlending),void 0!==v.blendingSpeed&&(n._blendingSpeed=v.blendingSpeed),void 0!==v.metadata&&(n.metadata=v.metadata),n}static MakeAnimationAdditive(v,y,n){let J;J="object"===typeof y?y:{referenceFrame:y,range:n,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let P=v;J.cloneOriginalAnimationGroup&&(P=v.clone(J.clonedAnimationGroupName||P.name));const b=P.targetedAnimations;for(let Y=0;Y<b.length;Y++){const v=b[Y];v.animation=B.c.MakeAnimationAdditive(v.animation,J)}if(P.isAdditive=!0,J.clipKeys){let v=Number.MAX_VALUE,y=-Number.MAX_VALUE;const n=P.targetedAnimations;for(let B=0;B<n.length;B++){const J=n[B].animation.getKeys();v>J[0].frame&&(v=J[0].frame),y<J[J.length-1].frame&&(y=J[J.length-1].frame)}P._from=v,P._to=y}return P}static ClipKeys(v,y,n,B,J){const P=v.clone(B||v.name);return E.ClipKeysInPlace(P,y,n,J)}static ClipKeysInPlace(v,y,n,B){return E.ClipInPlace(v,y,n,B,!1)}static ClipFrames(v,y,n,B,J){const P=v.clone(B||v.name);return E.ClipFramesInPlace(P,y,n,J)}static ClipFramesInPlace(v,y,n,B){return E.ClipInPlace(v,y,n,B,!0)}static ClipInPlace(v,y,n,B){let J=arguments.length>4&&void 0!==arguments[4]&&arguments[4],P=Number.MAX_VALUE,b=-Number.MAX_VALUE;const Y=v.targetedAnimations;for(let l=0;l<Y.length;l++){const v=Y[l],a=B?v.animation:v.animation.clone();J&&(a.createKeyForFrame(y),a.createKeyForFrame(n));const Z=a.getKeys(),x=[];let f=Number.MAX_VALUE;for(let B=0;B<Z.length;B++){const v=Z[B];if(!J&&B>=y&&B<=n||J&&v.frame>=y&&v.frame<=n){const y={frame:v.frame,value:v.value.clone?v.value.clone():v.value,inTangent:v.inTangent,outTangent:v.outTangent,interpolation:v.interpolation,lockedTangent:v.lockedTangent};f===Number.MAX_VALUE&&(f=y.frame),y.frame-=f,x.push(y)}}0!==x.length?(P>x[0].frame&&(P=x[0].frame),b<x[x.length-1].frame&&(b=x[x.length-1].frame),a.setKeys(x,!0),v.animation=a):(Y.splice(l,1),l--)}return v._from=P,v._to=b,v}getClassName(){return"AnimationGroup"}toString(v){let y="Name: "+this.name;return y+=", type: "+this.getClassName(),v&&(y+=", from: "+this._from,y+=", to: "+this._to,y+=", isStarted: "+this._isStarted,y+=", speedRatio: "+this._speedRatio,y+=", targetedAnimations length: "+this._targetedAnimations.length,y+=", animatables length: "+this._animatables),y}}}}]);