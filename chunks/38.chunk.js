"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13265:(d,t,A)=>{A.r(t),A.d(t,{AnimationGroup:()=>T,TargetedAnimation:()=>U});var w=A(12029),N=A(10730),p=A(10775),B=A(11067),X=A(12026),W=A(11076);class a{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(d,t,A,N){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=t,this._target=d,this._scene=A,this._host=N,this._activeTargets=[],t._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===w.d.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=W.c.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const d={frame:0,value:this._minValue};this._keys.splice(0,0,d)}if(this._target instanceof Array){let d=0;for(const t of this._target)this._preparePath(t,d),this._getOriginalValues(d),d++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const p=t.getEvents();p&&p.length>0&&p.forEach((d=>{this._events.push(d._clone())})),this._enableBlending=d&&d.animationPropertiesOverride?d.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(d){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const A=this._animation.targetPropertyPath;if(A.length>1){let w=d;for(let d=0;d<A.length-1;d++){const t=A[d];if(w=w[t],void 0===w)throw new Error(`Invalid property (${t}) in property path (${A.join(".")})`)}this._targetPath=A[A.length-1],this._activeTargets[t]=w}else this._targetPath=A[0],this._activeTargets[t]=d;if(void 0===this._activeTargets[t][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${A.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let d=0;for(const t of this._target)void 0!==this._originalValue[d]&&this._setValue(t,this._activeTargets[d],this._originalValue[d],-1,d),d++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let d=0;d<this._events.length;d++)this._events[d].isDone=!1}isStopped(){return this._stopped}dispose(){const d=this._animation.runtimeAnimations.indexOf(this);d>-1&&this._animation.runtimeAnimations.splice(d,1)}setValue(d,t){if(this._targetIsArray)for(let A=0;A<this._target.length;A++){const w=this._target[A];this._setValue(w,this._activeTargets[A],d,t,A)}else this._setValue(this._target,this._directTarget,d,t,0)}_getOriginalValues(){let d,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const A=this._activeTargets[t];d=A.getLocalMatrix&&"_matrix"===this._targetPath?A.getLocalMatrix():A[this._targetPath],d&&d.clone?this._originalValue[t]=d.clone():this._originalValue[t]=d}_registerTargetForLateAnimationBinding(d,t){const A=d.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(A),A._lateAnimationHolders||(A._lateAnimationHolders={}),A._lateAnimationHolders[d.targetPath]||(A._lateAnimationHolders[d.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:t}),d.isAdditive?(A._lateAnimationHolders[d.targetPath].additiveAnimations.push(d),A._lateAnimationHolders[d.targetPath].totalAdditiveWeight+=d.weight):(A._lateAnimationHolders[d.targetPath].animations.push(d),A._lateAnimationHolders[d.targetPath].totalWeight+=d.weight)}_setValue(d,t,A,N,p){if(this._currentActiveTarget=t,this._weight=N,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const d=t[this._targetPath];d.clone?this._originalBlendValue=d.clone():this._originalBlendValue=d}this._originalBlendValue.m?w.d.AllowMatrixDecomposeForInterpolation?this._currentValue?W.c.DecomposeLerpToRef(this._originalBlendValue,A,this._blendingFactor,this._currentValue):this._currentValue=W.c.DecomposeLerp(this._originalBlendValue,A,this._blendingFactor):this._currentValue?W.c.LerpToRef(this._originalBlendValue,A,this._blendingFactor,this._currentValue):this._currentValue=W.c.Lerp(this._originalBlendValue,A,this._blendingFactor):this._currentValue=w.d._UniversalLerp(this._originalBlendValue,A,this._blendingFactor);const N=d&&d.animationPropertiesOverride?d.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=N}else this._currentValue?this._currentValue.p?this._currentValue.p(A):this._currentValue=A:null!==A&&void 0!==A&&A.clone?this._currentValue=A.clone():this._currentValue=A;-1!==N?this._registerTargetForLateAnimationBinding(this,this._originalValue[p]):this._animationState.loopMode===w.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[p],t[this._targetPath]):t[this._targetPath]=this._originalValue[p]+this._currentValue:t[this._targetPath]=this._currentValue,d.Cg&&d.Cg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(d){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const A=this._animation.getKeys();d<A[0].frame?d=A[0].frame:d>A[A.length-1].frame&&(d=A[A.length-1].frame);const w=this._events;if(w.length)for(let p=0;p<w.length;p++)w[p].onlyOnce||(w[p].isDone=w[p].frame<d);this._currentFrame=d;const N=this._animation._interpolate(d,this._animationState);this.setValue(N,t)}_prepareForSpeedRatioChange(d){const t=this._previousElapsedTime*(this._animation.framePerSecond*d)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-t}animate(d,t,A,N,p){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const X=this._animation,W=X.targetPropertyPath;if(!W||W.length<1)return this._stopped=!0,!1;let a=!0;(t<this._minFrame||t>this._maxFrame)&&(t=this._minFrame),(A<this._minFrame||A>this._maxFrame)&&(A=this._maxFrame);const D=A-t;let i,k=d*(X.framePerSecond*p)/1e3+this._absoluteFrameOffset,b=0,Q=!1;const P=N&&this._animationState.loopMode===w.d.ANIMATIONLOOPMODE_YOYO;if(P){const d=(k-t)/D,A=Math.sin(d*Math.PI);k=Math.abs(A)*D+t;const w=A>=0?1:-1;this._yoyoDirection!==w&&(Q=!0),this._yoyoDirection=w}if(this._previousElapsedTime=d,this._previousAbsoluteFrame=k,!N&&A>=t&&(k>=D&&p>0||k<=0&&p<0))a=!1,b=X._getKeyValue(this._maxValue);else if(!N&&t>=A&&(k<=D&&p<0||k>=0&&p>0))a=!1,b=X._getKeyValue(this._minValue);else if(this._animationState.loopMode!==w.d.ANIMATIONLOOPMODE_CYCLE){const d=A.toString()+t.toString();if(!this._offsetsCache[d]){this._animationState.repeatCount=0,this._animationState.loopMode=w.d.ANIMATIONLOOPMODE_CYCLE;const N=X._interpolate(t,this._animationState),p=X._interpolate(A,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),X.dataType){case w.d.ANIMATIONTYPE_FLOAT:this._offsetsCache[d]=p-N;break;case w.d.ANIMATIONTYPE_QUATERNION:case w.d.ANIMATIONTYPE_VECTOR3:case w.d.ANIMATIONTYPE_VECTOR2:case w.d.ANIMATIONTYPE_SIZE:case w.d.ANIMATIONTYPE_COLOR3:this._offsetsCache[d]=p.Uc(N)}this._highLimitsCache[d]=p}b=this._highLimitsCache[d],i=this._offsetsCache[d]}if(void 0===i)switch(X.dataType){case w.d.ANIMATIONTYPE_FLOAT:i=0;break;case w.d.ANIMATIONTYPE_QUATERNION:i=w.h;break;case w.d.ANIMATIONTYPE_VECTOR3:i=w.o;break;case w.d.ANIMATIONTYPE_VECTOR2:i=w.l;break;case w.d.ANIMATIONTYPE_SIZE:i=w.i;break;case w.d.ANIMATIONTYPE_COLOR3:i=w.f;break;case w.d.ANIMATIONTYPE_COLOR4:i=w.g}let J;if(this._host&&this._host.syncRoot){const d=this._host.syncRoot;J=t+D*((d.masterFrame-d.fromFrame)/(d.toFrame-d.fromFrame))}else J=k>0&&t>A||k<0&&t<A?a&&0!==D?A+k%D:t:a&&0!==D?t+k%D:A;const U=this._events;if(!P&&(p>0&&this.currentFrame>J||p<0&&this.currentFrame<J)||P&&Q){this._onLoop();for(let d=0;d<U.length;d++)U[d].onlyOnce||(U[d].isDone=!1);this._animationState.key=p>0?0:X.getKeys().length-1}this._currentFrame=J,this._animationState.repeatCount=0===D?0:k/D|0,this._animationState.highLimitValue=b,this._animationState.offsetValue=i;const T=X._interpolate(J,this._animationState);if(this.setValue(T,B),U.length)for(let w=0;w<U.length;w++)if(D>=0&&J>=U[w].frame&&U[w].frame>=t||D<0&&J<=U[w].frame&&U[w].frame<=t){const d=U[w];d.isDone||(d.onlyOnce&&(U.splice(w,1),w--),d.isDone=!0,d.action(J))}return a||(this._stopped=!0),a}}var D=A(10756);class i{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(d){this._weight=-1!==d?Math.min(Math.max(d,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(d){for(let t=0;t<this._runtimeAnimations.length;t++){this._runtimeAnimations[t]._prepareForSpeedRatioChange(d)}this._speedRatio=d,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(d,t){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,p=arguments.length>4&&void 0!==arguments[4]&&arguments[4],B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,X=arguments.length>6?arguments[6]:void 0,W=arguments.length>7?arguments[7]:void 0,a=arguments.length>8?arguments[8]:void 0,D=arguments.length>9&&void 0!==arguments[9]&&arguments[9],i=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=t,this.fromFrame=A,this.toFrame=w,this.loopAnimation=p,this.onAnimationEnd=X,this.onAnimationLoop=a,this.isAdditive=D,this.playOrder=i,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.Id=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new N.b,this.onAnimationLoopObservable=new N.b,this._scene=d,W&&this.appendAnimations(t,W),this._speedRatio=B,d._activeAnimatables.push(this)}syncWith(d){if(this._syncRoot=d,d){const d=this._scene._activeAnimatables.indexOf(this);d>-1&&(this._scene._activeAnimatables.splice(d,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(d,t){for(let A=0;A<t.length;A++){const w=t[A],N=new a(d,w,this._scene,this);N._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(N)}}getAnimationByTargetProperty(d){const t=this._runtimeAnimations;for(let A=0;A<t.length;A++)if(t[A].animation.targetProperty===d)return t[A].animation;return null}getRuntimeAnimationByTargetProperty(d){const t=this._runtimeAnimations;for(let A=0;A<t.length;A++)if(t[A].animation.targetProperty===d)return t[A];return null}reset(){const d=this._runtimeAnimations;for(let t=0;t<d.length;t++)d[t].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(d){const t=this._runtimeAnimations;for(let A=0;A<t.length;A++)t[A].animation.enableBlending=!0,t[A].animation.blendingSpeed=d}disableBlending(){const d=this._runtimeAnimations;for(let t=0;t<d.length;t++)d[t].animation.enableBlending=!1}goToFrame(d){const t=this._runtimeAnimations;if(t[0]){const A=t[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??t[0].currentFrame;const w=0===this.speedRatio?0:(d-this._frameToSyncFromJump)/A*1e3/this.speedRatio;this._manualJumpDelay=-w}for(let A=0;A<t.length;A++)t[A].goToFrame(d,this._weight);this._goToFrame=d}get paused(){return this.Id}pause(){this.Id||(this.Id=!0)}restart(){this.Id=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(d,t){let A=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(d||t){const N=this._scene._activeAnimatables.indexOf(this);if(N>-1){const p=this._runtimeAnimations;for(let A=p.length-1;A>=0;A--){const w=p[A];d&&w.animation.name!=d||(t&&!t(w.target)||(w.dispose(),p.splice(A,1)))}0==p.length&&(A||this._scene._activeAnimatables.splice(N,1),w||this._raiseOnAnimationEnd())}}else{const d=this._scene._activeAnimatables.indexOf(this);if(d>-1){A||this._scene._activeAnimatables.splice(d,1);const t=this._runtimeAnimations;for(let d=0;d<t.length;d++)t[d].dispose();this._runtimeAnimations.length=0,w||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((d=>{this.onAnimationEndObservable.add((()=>{d(this)}),void 0,void 0,this,!0)}))}_animate(d){if(this.Id)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=d),!0;if(null===this._localDelayOffset?(this._localDelayOffset=d,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=d-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let t=!1;const A=this._runtimeAnimations;let w;for(w=0;w<A.length;w++){const N=A[w].animate(d-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);t=t||N}if(this.animationStarted=t,!t){if(this.disposeOnEnd)for(w=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(w,1),w=0;w<A.length;w++)A[w].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return t}}function k(d){if(0===d.totalWeight&&0===d.totalAdditiveWeight)return d.originalValue;let t=1;const A=W.h.gb[0],w=W.h.gb[1],N=W.h.Quaternion[0];let p=0;const B=d.animations[0],X=d.originalValue;let a=1,D=!1;if(d.totalWeight<1)a=1-d.totalWeight,X.decompose(w,N,A);else{if(p=1,t=d.totalWeight,a=B.weight/t,1==a){if(!d.totalAdditiveWeight)return B.currentValue;D=!0}B.currentValue.decompose(w,N,A)}if(!D){w.scaleInPlace(a),A.scaleInPlace(a),N.scaleInPlace(a);for(let B=p;B<d.animations.length;B++){const p=d.animations[B];if(0===p.weight)continue;a=p.weight/t;const X=W.h.gb[2],D=W.h.gb[3],i=W.h.Quaternion[1];p.currentValue.decompose(D,i,X),D.scaleAndAddToRef(a,w),i.scaleAndAddToRef(W.f.Dot(N,i)>0?a:-a,N),X.scaleAndAddToRef(a,A)}N.normalize()}for(let k=0;k<d.additiveAnimations.length;k++){const t=d.additiveAnimations[k];if(0===t.weight)continue;const p=W.h.gb[2],B=W.h.gb[3],X=W.h.Quaternion[1];t.currentValue.decompose(B,X,p),B.multiplyToRef(w,B),W.l.LerpToRef(w,B,t.weight,w),N.multiplyToRef(X,X),W.f.SlerpToRef(N,X,t.weight,N),p.scaleAndAddToRef(t.weight,A)}const i=B?B._animationState.workValue:W.h.Matrix[0].clone();return W.c.ComposeToRef(w,N,A,i),i}function b(d,t){if(0===d.totalWeight&&0===d.totalAdditiveWeight)return t;const A=d.animations[0],w=d.originalValue;let N=t;if(0===d.totalWeight&&d.totalAdditiveWeight>0)N.p(w);else if(1===d.animations.length){if(W.f.SlerpToRef(w,A.currentValue,Math.min(1,d.totalWeight),N),0===d.totalAdditiveWeight)return N}else if(d.animations.length>1){let A,p,B=1;if(d.totalWeight<1){const t=1-d.totalWeight;A=[],p=[],A.push(w),p.push(t)}else{if(2===d.animations.length&&(W.f.SlerpToRef(d.animations[0].currentValue,d.animations[1].currentValue,d.animations[1].weight/d.totalWeight,t),0===d.totalAdditiveWeight))return t;A=[],p=[],B=d.totalWeight}for(let t=0;t<d.animations.length;t++){const w=d.animations[t];A.push(w.currentValue),p.push(w.weight/B)}let X=0;for(let d=0;d<A.length;)d?(X+=p[d],W.f.SlerpToRef(N,A[d],p[d]/X,N),d++):(W.f.SlerpToRef(A[d],A[d+1],p[d+1]/(p[d]+p[d+1]),t),N=t,X=p[d]+p[d+1],d+=2)}for(let p=0;p<d.additiveAnimations.length;p++){const t=d.additiveAnimations[p];0!==t.weight&&(N.multiplyToRef(t.currentValue,W.h.Quaternion[0]),W.f.SlerpToRef(N,W.h.Quaternion[0],t.weight,N))}return N}var Q,P,J=A(11061);Q=J.e,(P=X.b)&&(P.prototype.copyAnimationRange=function(d,t,A){let N=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new w.d(this.name,"_matrix",d.animations[0].framePerSecond,w.d.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const B=d.animations[0].getRange(t);if(!B)return!1;const X=B.from,W=B.to,a=d.animations[0].getKeys(),D=d.length,i=d.getParent(),k=this.getParent(),b=N&&i&&D&&this.length&&D!==this.length,Q=b&&k&&i?k.length/i.length:1,P=N&&!k&&p&&(1!==p.x||1!==p.y||1!==p.z),J=this.animations[0].getKeys();let U,T,F;for(let w=0,q=a.length;w<q;w++)U=a[w],U.frame>=X&&U.frame<=W&&(N?(F=U.value.clone(),b?(T=F.getTranslation(),F.setTranslation(T.scaleInPlace(Q))):P&&p?(T=F.getTranslation(),F.setTranslation(T.multiplyInPlace(p))):F=U.value):F=U.value,J.push({frame:U.frame+A,value:F}));return this.animations[0].createRange(t,X+A,W+A),!0}),Q&&(Q.prototype._animate=function(d){if(!this.animationsEnabled)return;const t=D.d.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=t}this.deltaTime=void 0!==d?d:this.useConstantAnimationDeltaTime?16:(t-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=t;const A=this._activeAnimatables;if(0===A.length)return;this._animationTime+=this.deltaTime;const N=this._animationTime;for(let w=0;w<A.length;w++){const d=A[w];!d._animate(N)&&d.disposeOnEnd&&w--}!function(d){if(d._registeredForLateAnimationBindings.length){for(let t=0;t<d._registeredForLateAnimationBindings.length;t++){const A=d._registeredForLateAnimationBindings.data[t];for(const d in A._lateAnimationHolders){const t=A._lateAnimationHolders[d],N=t.animations[0],p=t.originalValue;if(void 0===p||null===p)continue;const B=w.d.AllowMatrixDecomposeForInterpolation&&p.m;let X=A[d];if(B)X=k(t);else if(void 0!==p.w)X=b(t,X||W.f.Identity());else{let d=0,A=1;const B=N&&N._animationState.loopMode===w.d.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(t.totalWeight<1)X=B?p.clone?p.clone():p:N&&p.scale?p.scale(1-t.totalWeight):N?p*(1-t.totalWeight):p.clone?p.clone():p;else if(N){A=t.totalWeight;const w=N.weight/A;X=1!==w?N.currentValue.scale?N.currentValue.scale(w):N.currentValue*w:N.currentValue,B&&(X.addToRef?X.addToRef(p,X):X+=p),d=1}for(let w=d;w<t.animations.length;w++){const d=t.animations[w],N=d.weight/A;N&&(d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(N,X):X+=d.currentValue*N)}for(let w=0;w<t.additiveAnimations.length;w++){const d=t.additiveAnimations[w],A=d.weight;A&&(d.currentValue.scaleAndAddToRef?d.currentValue.scaleAndAddToRef(A,X):X+=d.currentValue*A)}}A[d]=X}A._lateAnimationHolders={}}d._registeredForLateAnimationBindings.reset()}}(this)},Q.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((d,t)=>d.playOrder-t.playOrder))},Q.prototype.beginWeightedAnimation=function(d,t,A){let w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,N=arguments.length>4?arguments[4]:void 0,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,W=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const i=this.beginAnimation(d,t,A,N,p,B,X,!1,W,a,D);return i.weight=w,i},Q.prototype.beginAnimation=function(d,t,A,w){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,p=arguments.length>5?arguments[5]:void 0,B=arguments.length>6?arguments[6]:void 0,X=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],W=arguments.length>8?arguments[8]:void 0,a=arguments.length>9?arguments[9]:void 0,D=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(N<0){const d=t;t=A,A=d,N=-N}t>A&&(N=-N),X&&this.stopAnimation(d,void 0,W),B||(B=new i(this,d,t,A,w,N,p,void 0,a,D));const k=!W||W(d);if(d.animations&&k&&B.appendAnimations(d,d.animations),d.getAnimatables){const D=d.getAnimatables();for(let d=0;d<D.length;d++)this.beginAnimation(D[d],t,A,w,N,p,B,X,W,a)}return B.reset(),B},Q.prototype.beginHierarchyAnimation=function(d,t,A,w,N){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,B=arguments.length>6?arguments[6]:void 0,X=arguments.length>7?arguments[7]:void 0,W=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],a=arguments.length>9?arguments[9]:void 0,D=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const i=d.getDescendants(t),k=[];k.push(this.beginAnimation(d,A,w,N,p,B,X,W,a,void 0,D));for(const b of i)k.push(this.beginAnimation(b,A,w,N,p,B,X,W,a,void 0,D));return k},Q.prototype.beginDirectAnimation=function(d,t,A,w,N){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(p<0){const d=A;A=w,w=d,p=-p}return A>w&&(p=-p),new i(this,d,A,w,N,p,arguments.length>6?arguments[6]:void 0,t,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},Q.prototype.beginDirectHierarchyAnimation=function(d,t,A,w,N,p,B,X,W){let a=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const D=d.getDescendants(t),i=[];i.push(this.beginDirectAnimation(d,A,w,N,p,B,X,W,a));for(const k of D)i.push(this.beginDirectAnimation(k,A,w,N,p,B,X,W,a));return i},Q.prototype.getAnimatableByTarget=function(d){for(let t=0;t<this._activeAnimatables.length;t++)if(this._activeAnimatables[t].target===d)return this._activeAnimatables[t];return null},Q.prototype.getAllAnimatablesByTarget=function(d){const t=[];for(let A=0;A<this._activeAnimatables.length;A++)this._activeAnimatables[A].target===d&&t.push(this._activeAnimatables[A]);return t},Q.prototype.stopAnimation=function(d,t,A){const w=this.getAllAnimatablesByTarget(d);for(const N of w)N.stop(t,A)},Q.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let d=0;d<this._activeAnimatables.length;d++)this._activeAnimatables[d].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const d of this.animationGroups)d.stop()});class U{getClassName(){return"TargetedAnimation"}serialize(){const d={};return d.animation=this.animation.serialize(),d.targetId=this.target.id,d}}class T{get mask(){return this._mask}set mask(d){this._mask!==d&&(this._mask=d,this.syncWithMask(!0))}syncWithMask(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||d){this._numActiveAnimatables=0;for(let d=0;d<this._animatables.length;++d){const t=this._animatables[d];!this.mask||this.mask.disabled||this.mask.retainsTarget(t.target.name)?(this._numActiveAnimatables++,t.paused&&t.restart()):t.paused||t.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let d=0;d<this._animatables.length;++d){const t=this._animatables[d];this.mask.retainsTarget(t.target.name)||(t.stop(),this._animatables.splice(d,1),--d)}for(let d=0;d<this._targetedAnimations.length;d++){const t=this._targetedAnimations[d];this.mask.retainsTarget(t.target.name)||(this._targetedAnimations.splice(d,1),--d)}}}get from(){return this._from}set from(d){if(this._from!==d){this._from=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].fromFrame=this._from}}}get to(){return this._to}set to(d){if(this._to!==d){this._to=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(d){if(this._speedRatio!==d){this._speedRatio=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(d){if(this._loopAnimation!==d){this._loopAnimation=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(d){if(this._isAdditive!==d){this._isAdditive=d;for(let d=0;d<this._animatables.length;d++){this._animatables[d].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(d){this._weight!==d&&(this._weight=d,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(d){if(this._playOrder!==d&&(this._playOrder=d,this._animatables.length>0)){for(let d=0;d<this._animatables.length;d++)this._animatables[d].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(d){if(this._enableBlending!==d&&(this._enableBlending=d,null!==d))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.enableBlending=d}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(d){if(this._blendingSpeed!==d&&(this._blendingSpeed=d,null!==d))for(let t=0;t<this._targetedAnimations.length;++t)this._targetedAnimations[t].animation.blendingSpeed=d}getLength(d,t){d=d??this._from;return((t=t??this._to)-d)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(d){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2],w=arguments.length>3?arguments[3]:void 0;if(0===d.length)return null;w=w??d[0].weight;let N=Number.MAX_VALUE,p=-Number.MAX_VALUE;if(A)for(const X of d)X.from<N&&(N=X.from),X.to>p&&(p=X.to);const B=new T(d[0].name+"_merged",d[0]._scene,w);for(const X of d){A&&X.normalize(N,p);for(const d of X.targetedAnimations)B.addTargetedAnimation(d.animation,d.target);t&&X.dispose()}return B}constructor(d){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,w=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=d,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new N.b,this.onAnimationLoopObservable=new N.b,this.onAnimationGroupLoopObservable=new N.b,this.onAnimationGroupEndObservable=new N.b,this.onAnimationGroupPauseObservable=new N.b,this.onAnimationGroupPlayObservable=new N.b,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=t||p.e.LastCreatedScene,this._weight=A,this._playOrder=w,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(d,t){const A=new U;A.animation=d,A.target=t;const w=d.getKeys();return this._from>w[0].frame&&(this._from=w[0].frame),this._to<w[w.length-1].frame&&(this._to=w[w.length-1].frame),null!==this._enableBlending&&(d.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(d.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(A),this._shouldStart=!0,A}removeTargetedAnimation(d){for(let t=this._targetedAnimations.length-1;t>-1;t--){this._targetedAnimations[t].animation===d&&this._targetedAnimations.splice(t,1)}}normalize(){let d=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==d&&(d=this._from),null==t&&(t=this._to);for(let A=0;A<this._targetedAnimations.length;A++){const w=this._targetedAnimations[A].animation.getKeys(),N=w[0],p=w[w.length-1];if(N.frame>d){const t={frame:d,value:N.value,inTangent:N.inTangent,outTangent:N.outTangent,interpolation:N.interpolation};w.splice(0,0,t)}if(p.frame<t){const d={frame:t,value:p.value,inTangent:p.inTangent,outTangent:p.outTangent,interpolation:p.interpolation};w.push(d)}}return this._from=d,this._to=t,this}_processLoop(d,t,A){d.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(t),this._animationLoopFlags[A]||(this._animationLoopFlags[A]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,A=arguments.length>2?arguments[2]:void 0,w=arguments.length>3?arguments[3]:void 0,N=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=d,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let p=0;p<this._targetedAnimations.length;p++){const B=this._targetedAnimations[p],X=this._scene.beginDirectAnimation(B.target,[B.animation],void 0!==A?A:this._from,void 0!==w?w:this._to,d,t,void 0,void 0,void 0!==N?N:this._isAdditive);X.weight=this._weight,X.playOrder=this._playOrder,X.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(B),this._checkAnimationGroupEnded(X)},this._processLoop(X,B,p),this._animatables.push(X)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=t,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let d=0;d<this._animatables.length;d++){this._animatables[d].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(d){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==d&&(this.loopAnimation=d),this.restart()):(this.stop(),this.start(d,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].reset()}return this}restart(){if(!this._isStarted)return this;for(let d=0;d<this._animatables.length;d++){this._animatables[d].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let d=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const t=this._animatables.slice();for(let w=0;w<t.length;w++)t[w].stop(void 0,void 0,!0,d);let A=0;for(let w=0;w<this._scene._activeAnimatables.length;w++){const t=this._scene._activeAnimatables[w];t._runtimeAnimations.length>0?this._scene._activeAnimatables[A++]=t:d&&this._checkAnimationGroupEnded(t,d)}return this._scene._activeAnimatables.length=A,this._isStarted=!1,this}setWeightForAllAnimatables(d){for(let t=0;t<this._animatables.length;t++){this._animatables[t].weight=d}return this}syncAllAnimationsWith(d){for(let t=0;t<this._animatables.length;t++){this._animatables[t].syncWith(d)}return this}goToFrame(d){if(!this._isStarted)return this;for(let t=0;t<this._animatables.length;t++){this._animatables[t].goToFrame(d)}return this}getCurrentFrame(){var d;return(null===(d=this.animatables[0])||void 0===d?void 0:d.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const d=this._scene.animationGroups.indexOf(this);if(d>-1&&this._scene.animationGroups.splice(d,1),this._parentContainer){const d=this._parentContainer.animationGroups.indexOf(this);d>-1&&this._parentContainer.animationGroups.splice(d,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(d){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const A=this._animatables.indexOf(d);A>-1&&this._animatables.splice(A,1),0===this._animatables.length&&(this._isStarted=!1,t||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(d,t){let A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const w=new T(d||this.name,this._scene,this._weight,this._playOrder);w._from=this.from,w._to=this.to,w._speedRatio=this.speedRatio,w._loopAnimation=this.loopAnimation,w._isAdditive=this.isAdditive,w._enableBlending=this.enableBlending,w._blendingSpeed=this.blendingSpeed,w.metadata=this.metadata,w.mask=this.mask;for(const N of this._targetedAnimations)w.addTargetedAnimation(A?N.animation.clone():N.animation,t?t(N.target):N.target);return w}serialize(){const d={};d.name=this.name,d.from=this.from,d.to=this.to,d.speedRatio=this.speedRatio,d.loopAnimation=this.loopAnimation,d.isAdditive=this.isAdditive,d.weight=this.weight,d.playOrder=this.playOrder,d.enableBlending=this.enableBlending,d.blendingSpeed=this.blendingSpeed,d.targetedAnimations=[];for(let t=0;t<this.targetedAnimations.length;t++){const A=this.targetedAnimations[t];d.targetedAnimations[t]=A.serialize()}return B.c&&B.c.HasTags(this)&&(d.tags=B.c.GetTags(this)),this.metadata&&(d.metadata=this.metadata),d}static Parse(d,t){const A=new T(d.name,t,d.weight,d.playOrder);for(let N=0;N<d.targetedAnimations.length;N++){const p=d.targetedAnimations[N],B=w.d.Parse(p.animation),X=p.targetId;if("influence"===p.animation.property){const d=t.getMorphTargetById(X);d&&A.addTargetedAnimation(B,d)}else{const d=t.getNodeById(X);null!=d&&A.addTargetedAnimation(B,d)}}return B.c&&B.c.AddTagsTo(A,d.tags),null!==d.from&&null!==d.to&&A.normalize(d.from,d.to),void 0!==d.speedRatio&&(A._speedRatio=d.speedRatio),void 0!==d.loopAnimation&&(A._loopAnimation=d.loopAnimation),void 0!==d.isAdditive&&(A._isAdditive=d.isAdditive),void 0!==d.weight&&(A._weight=d.weight),void 0!==d.playOrder&&(A._playOrder=d.playOrder),void 0!==d.enableBlending&&(A._enableBlending=d.enableBlending),void 0!==d.blendingSpeed&&(A._blendingSpeed=d.blendingSpeed),void 0!==d.metadata&&(A.metadata=d.metadata),A}static MakeAnimationAdditive(d,t,A){let N;N="object"===typeof t?t:{referenceFrame:t,range:A,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let p=d;N.cloneOriginalAnimationGroup&&(p=d.clone(N.clonedAnimationGroupName||p.name));const B=p.targetedAnimations;for(let X=0;X<B.length;X++){const d=B[X];d.animation=w.d.MakeAnimationAdditive(d.animation,N)}if(p.isAdditive=!0,N.clipKeys){let d=Number.MAX_VALUE,t=-Number.MAX_VALUE;const A=p.targetedAnimations;for(let w=0;w<A.length;w++){const N=A[w].animation.getKeys();d>N[0].frame&&(d=N[0].frame),t<N[N.length-1].frame&&(t=N[N.length-1].frame)}p._from=d,p._to=t}return p}static ClipKeys(d,t,A,w,N){const p=d.clone(w||d.name);return T.ClipKeysInPlace(p,t,A,N)}static ClipKeysInPlace(d,t,A,w){return T.ClipInPlace(d,t,A,w,!1)}static ClipFrames(d,t,A,w,N){const p=d.clone(w||d.name);return T.ClipFramesInPlace(p,t,A,N)}static ClipFramesInPlace(d,t,A,w){return T.ClipInPlace(d,t,A,w,!0)}static ClipInPlace(d,t,A,w){let N=arguments.length>4&&void 0!==arguments[4]&&arguments[4],p=Number.MAX_VALUE,B=-Number.MAX_VALUE;const X=d.targetedAnimations;for(let W=0;W<X.length;W++){const d=X[W],a=w?d.animation:d.animation.clone();N&&(a.createKeyForFrame(t),a.createKeyForFrame(A));const D=a.getKeys(),i=[];let k=Number.MAX_VALUE;for(let w=0;w<D.length;w++){const d=D[w];if(!N&&w>=t&&w<=A||N&&d.frame>=t&&d.frame<=A){const t={frame:d.frame,value:d.value.clone?d.value.clone():d.value,inTangent:d.inTangent,outTangent:d.outTangent,interpolation:d.interpolation,lockedTangent:d.lockedTangent};k===Number.MAX_VALUE&&(k=t.frame),t.frame-=k,i.push(t)}}0!==i.length?(p>i[0].frame&&(p=i[0].frame),B<i[i.length-1].frame&&(B=i[i.length-1].frame),a.setKeys(i,!0),d.animation=a):(X.splice(W,1),W--)}return d._from=p,d._to=B,d}getClassName(){return"AnimationGroup"}toString(d){let t="Name: "+this.name;return t+=", type: "+this.getClassName(),d&&(t+=", from: "+this._from,t+=", to: "+this._to,t+=", isStarted: "+this._isStarted,t+=", speedRatio: "+this._speedRatio,t+=", targetedAnimations length: "+this._targetedAnimations.length,t+=", animatables length: "+this._animatables),t}}}}]);