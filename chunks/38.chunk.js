"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[38],{13308:(Z,J,E)=>{E.r(J),E.d(J,{AnimationGroup:()=>T,TargetedAnimation:()=>K});var O=E(12094),i=E(10904),Y=E(10942),C=E(11196),d=E(12088),z=E(11198);class g{get currentFrame(){return this._currentFrame}get weight(){return this._weight}get currentValue(){return this._currentValue}get targetPath(){return this._targetPath}get target(){return this._currentActiveTarget}get isAdditive(){return this._host&&this._host.isAdditive}constructor(Z,J,E,i){if(this._events=new Array,this._currentFrame=0,this._originalValue=new Array,this._originalBlendValue=null,this._offsetsCache={},this._highLimitsCache={},this._stopped=!1,this._blendingFactor=0,this._currentValue=null,this._currentActiveTarget=null,this._directTarget=null,this._targetPath="",this._weight=1,this._absoluteFrameOffset=0,this._previousElapsedTime=0,this._yoyoDirection=1,this._previousAbsoluteFrame=0,this._targetIsArray=!1,this._animation=J,this._target=Z,this._scene=E,this._host=i,this._activeTargets=[],J._runtimeAnimations.push(this),this._animationState={key:0,repeatCount:0,loopMode:this._getCorrectLoopMode()},this._animation.dataType===O.c.ANIMATIONTYPE_MATRIX&&(this._animationState.workValue=z.e.Zero()),this._keys=this._animation.getKeys(),this._minFrame=this._keys[0].frame,this._maxFrame=this._keys[this._keys.length-1].frame,this._minValue=this._keys[0].value,this._maxValue=this._keys[this._keys.length-1].value,0!==this._minFrame){const Z={frame:0,value:this._minValue};this._keys.splice(0,0,Z)}if(this._target instanceof Array){let Z=0;for(const J of this._target)this._preparePath(J,Z),this._getOriginalValues(Z),Z++;this._targetIsArray=!0}else this._preparePath(this._target),this._getOriginalValues(),this._targetIsArray=!1,this._directTarget=this._activeTargets[0];const Y=J.getEvents();Y&&Y.length>0&&Y.forEach((Z=>{this._events.push(Z._clone())})),this._enableBlending=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.enableBlending:this._animation.enableBlending}_preparePath(Z){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const E=this._animation.targetPropertyPath;if(E.length>1){let O=Z;for(let Z=0;Z<E.length-1;Z++){const J=E[Z];if(O=O[J],void 0===O)throw new Error(`Invalid property (${J}) in property path (${E.join(".")})`)}this._targetPath=E[E.length-1],this._activeTargets[J]=O}else this._targetPath=E[0],this._activeTargets[J]=Z;if(void 0===this._activeTargets[J][this._targetPath])throw new Error(`Invalid property (${this._targetPath}) in property path (${E.join(".")})`)}get animation(){return this._animation}reset(){if(arguments.length>0&&void 0!==arguments[0]&&arguments[0])if(this._target instanceof Array){let Z=0;for(const J of this._target)void 0!==this._originalValue[Z]&&this._setValue(J,this._activeTargets[Z],this._originalValue[Z],-1,Z),Z++}else void 0!==this._originalValue[0]&&this._setValue(this._target,this._directTarget,this._originalValue[0],-1,0);this._offsetsCache={},this._highLimitsCache={},this._currentFrame=0,this._blendingFactor=0;for(let Z=0;Z<this._events.length;Z++)this._events[Z].isDone=!1}isStopped(){return this._stopped}dispose(){const Z=this._animation.runtimeAnimations.indexOf(this);Z>-1&&this._animation.runtimeAnimations.splice(Z,1)}setValue(Z,J){if(this._targetIsArray)for(let E=0;E<this._target.length;E++){const O=this._target[E];this._setValue(O,this._activeTargets[E],Z,J,E)}else this._setValue(this._target,this._directTarget,Z,J,0)}_getOriginalValues(){let Z,J=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=this._activeTargets[J];Z=E.getLocalMatrix&&"_matrix"===this._targetPath?E.getLocalMatrix():E[this._targetPath],Z&&Z.clone?this._originalValue[J]=Z.clone():this._originalValue[J]=Z}_registerTargetForLateAnimationBinding(Z,J){const E=Z.target;this._scene._registeredForLateAnimationBindings.pushNoDuplicate(E),E._lateAnimationHolders||(E._lateAnimationHolders={}),E._lateAnimationHolders[Z.targetPath]||(E._lateAnimationHolders[Z.targetPath]={totalWeight:0,totalAdditiveWeight:0,animations:[],additiveAnimations:[],originalValue:J}),Z.isAdditive?(E._lateAnimationHolders[Z.targetPath].additiveAnimations.push(Z),E._lateAnimationHolders[Z.targetPath].totalAdditiveWeight+=Z.weight):(E._lateAnimationHolders[Z.targetPath].animations.push(Z),E._lateAnimationHolders[Z.targetPath].totalWeight+=Z.weight)}_setValue(Z,J,E,i,Y){if(this._currentActiveTarget=J,this._weight=i,this._enableBlending&&this._blendingFactor<=1){if(!this._originalBlendValue){const Z=J[this._targetPath];Z.clone?this._originalBlendValue=Z.clone():this._originalBlendValue=Z}this._originalBlendValue.m?O.c.AllowMatrixDecomposeForInterpolation?this._currentValue?z.e.DecomposeLerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=z.e.DecomposeLerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue?z.e.LerpToRef(this._originalBlendValue,E,this._blendingFactor,this._currentValue):this._currentValue=z.e.Lerp(this._originalBlendValue,E,this._blendingFactor):this._currentValue=O.c._UniversalLerp(this._originalBlendValue,E,this._blendingFactor);const i=Z&&Z.animationPropertiesOverride?Z.animationPropertiesOverride.blendingSpeed:this._animation.blendingSpeed;this._blendingFactor+=i}else this._currentValue?this._currentValue.p?this._currentValue.p(E):this._currentValue=E:null!==E&&void 0!==E&&E.clone?this._currentValue=E.clone():this._currentValue=E;-1!==i?this._registerTargetForLateAnimationBinding(this,this._originalValue[Y]):this._animationState.loopMode===O.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT?this._currentValue.addToRef?this._currentValue.addToRef(this._originalValue[Y],J[this._targetPath]):J[this._targetPath]=this._originalValue[Y]+this._currentValue:J[this._targetPath]=this._currentValue,Z.wg&&Z.wg(this._animation.targetProperty)}_getCorrectLoopMode(){return this._target&&this._target.animationPropertiesOverride?this._target.animationPropertiesOverride.loopMode:this._animation.loopMode}goToFrame(Z){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const E=this._animation.getKeys();Z<E[0].frame?Z=E[0].frame:Z>E[E.length-1].frame&&(Z=E[E.length-1].frame);const O=this._events;if(O.length)for(let Y=0;Y<O.length;Y++)O[Y].onlyOnce||(O[Y].isDone=O[Y].frame<Z);this._currentFrame=Z;const i=this._animation._interpolate(Z,this._animationState);this.setValue(i,J)}_prepareForSpeedRatioChange(Z){const J=this._previousElapsedTime*(this._animation.framePerSecond*Z)/1e3;this._absoluteFrameOffset=this._previousAbsoluteFrame-J}animate(Z,J,E,i,Y){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:-1;const d=this._animation,z=d.targetPropertyPath;if(!z||z.length<1)return this._stopped=!0,!1;let g=!0;(J<this._minFrame||J>this._maxFrame)&&(J=this._minFrame),(E<this._minFrame||E>this._maxFrame)&&(E=this._maxFrame);const A=E-J;let R,h=Z*(d.framePerSecond*Y)/1e3+this._absoluteFrameOffset,L=0,v=!1;const X=i&&this._animationState.loopMode===O.c.ANIMATIONLOOPMODE_YOYO;if(X){const Z=(h-J)/A,E=Math.sin(Z*Math.PI);h=Math.abs(E)*A+J;const O=E>=0?1:-1;this._yoyoDirection!==O&&(v=!0),this._yoyoDirection=O}if(this._previousElapsedTime=Z,this._previousAbsoluteFrame=h,!i&&E>=J&&(h>=A&&Y>0||h<=0&&Y<0))g=!1,L=d._getKeyValue(this._maxValue);else if(!i&&J>=E&&(h<=A&&Y<0||h>=0&&Y>0))g=!1,L=d._getKeyValue(this._minValue);else if(this._animationState.loopMode!==O.c.ANIMATIONLOOPMODE_CYCLE){const Z=E.toString()+J.toString();if(!this._offsetsCache[Z]){this._animationState.repeatCount=0,this._animationState.loopMode=O.c.ANIMATIONLOOPMODE_CYCLE;const i=d._interpolate(J,this._animationState),Y=d._interpolate(E,this._animationState);switch(this._animationState.loopMode=this._getCorrectLoopMode(),d.dataType){case O.c.ANIMATIONTYPE_FLOAT:this._offsetsCache[Z]=Y-i;break;case O.c.ANIMATIONTYPE_QUATERNION:case O.c.ANIMATIONTYPE_VECTOR3:case O.c.ANIMATIONTYPE_VECTOR2:case O.c.ANIMATIONTYPE_SIZE:case O.c.ANIMATIONTYPE_COLOR3:this._offsetsCache[Z]=Y.bc(i)}this._highLimitsCache[Z]=Y}L=this._highLimitsCache[Z],R=this._offsetsCache[Z]}if(void 0===R)switch(d.dataType){case O.c.ANIMATIONTYPE_FLOAT:R=0;break;case O.c.ANIMATIONTYPE_QUATERNION:R=O.i;break;case O.c.ANIMATIONTYPE_VECTOR3:R=O.u;break;case O.c.ANIMATIONTYPE_VECTOR2:R=O.q;break;case O.c.ANIMATIONTYPE_SIZE:R=O.m;break;case O.c.ANIMATIONTYPE_COLOR3:R=O.f;break;case O.c.ANIMATIONTYPE_COLOR4:R=O.g}let l;if(this._host&&this._host.syncRoot){const Z=this._host.syncRoot;l=J+A*((Z.masterFrame-Z.fromFrame)/(Z.toFrame-Z.fromFrame))}else l=h>0&&J>E||h<0&&J<E?g&&0!==A?E+h%A:J:g&&0!==A?J+h%A:E;const K=this._events;if(!X&&(Y>0&&this.currentFrame>l||Y<0&&this.currentFrame<l)||X&&v){this._onLoop();for(let Z=0;Z<K.length;Z++)K[Z].onlyOnce||(K[Z].isDone=!1);this._animationState.key=Y>0?0:d.getKeys().length-1}this._currentFrame=l,this._animationState.repeatCount=0===A?0:h/A|0,this._animationState.highLimitValue=L,this._animationState.offsetValue=R;const T=d._interpolate(l,this._animationState);if(this.setValue(T,C),K.length)for(let O=0;O<K.length;O++)if(A>=0&&l>=K[O].frame&&K[O].frame>=J||A<0&&l<=K[O].frame&&K[O].frame<=J){const Z=K[O];Z.isDone||(Z.onlyOnce&&(K.splice(O,1),O--),Z.isDone=!0,Z.action(l))}return g||(this._stopped=!0),g}}var A=E(10926);class R{get syncRoot(){return this._syncRoot}get masterFrame(){return 0===this._runtimeAnimations.length?0:this._runtimeAnimations[0].currentFrame}get weight(){return this._weight}set weight(Z){this._weight=-1!==Z?Math.min(Math.max(Z,0),1):-1}get speedRatio(){return this._speedRatio}set speedRatio(Z){for(let J=0;J<this._runtimeAnimations.length;J++){this._runtimeAnimations[J]._prepareForSpeedRatioChange(Z)}this._speedRatio=Z,null!==this._goToFrame&&this.goToFrame(this._goToFrame)}get elapsedTime(){return null===this._localDelayOffset?0:this._scene._animationTime-this._localDelayOffset}constructor(Z,J){let E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:100,Y=arguments.length>4&&void 0!==arguments[4]&&arguments[4],C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,d=arguments.length>6?arguments[6]:void 0,z=arguments.length>7?arguments[7]:void 0,g=arguments.length>8?arguments[8]:void 0,A=arguments.length>9&&void 0!==arguments[9]&&arguments[9],R=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0;this.target=J,this.fromFrame=E,this.toFrame=O,this.loopAnimation=Y,this.onAnimationEnd=d,this.onAnimationLoop=g,this.isAdditive=A,this.playOrder=R,this._localDelayOffset=null,this._pausedDelay=null,this._manualJumpDelay=null,this._runtimeAnimations=new Array,this.od=!1,this._speedRatio=1,this._weight=-1,this._syncRoot=null,this._frameToSyncFromJump=null,this._goToFrame=null,this.disposeOnEnd=!0,this.animationStarted=!1,this.onAnimationEndObservable=new i.c,this.onAnimationLoopObservable=new i.c,this._scene=Z,z&&this.appendAnimations(J,z),this._speedRatio=C,Z._activeAnimatables.push(this)}syncWith(Z){if(this._syncRoot=Z,Z){const Z=this._scene._activeAnimatables.indexOf(this);Z>-1&&(this._scene._activeAnimatables.splice(Z,1),this._scene._activeAnimatables.push(this))}return this}getAnimations(){return this._runtimeAnimations}appendAnimations(Z,J){for(let E=0;E<J.length;E++){const O=J[E],i=new g(Z,O,this._scene,this);i._onLoop=()=>{this.onAnimationLoopObservable.notifyObservers(this),this.onAnimationLoop&&this.onAnimationLoop()},this._runtimeAnimations.push(i)}}getAnimationByTargetProperty(Z){const J=this._runtimeAnimations;for(let E=0;E<J.length;E++)if(J[E].animation.targetProperty===Z)return J[E].animation;return null}getRuntimeAnimationByTargetProperty(Z){const J=this._runtimeAnimations;for(let E=0;E<J.length;E++)if(J[E].animation.targetProperty===Z)return J[E];return null}reset(){const Z=this._runtimeAnimations;for(let J=0;J<Z.length;J++)Z[J].reset(!0);this._localDelayOffset=null,this._pausedDelay=null}enableBlending(Z){const J=this._runtimeAnimations;for(let E=0;E<J.length;E++)J[E].animation.enableBlending=!0,J[E].animation.blendingSpeed=Z}disableBlending(){const Z=this._runtimeAnimations;for(let J=0;J<Z.length;J++)Z[J].animation.enableBlending=!1}goToFrame(Z){const J=this._runtimeAnimations;if(J[0]){const E=J[0].animation.framePerSecond;this._frameToSyncFromJump=this._frameToSyncFromJump??J[0].currentFrame;const O=0===this.speedRatio?0:(Z-this._frameToSyncFromJump)/E*1e3/this.speedRatio;this._manualJumpDelay=-O}for(let E=0;E<J.length;E++)J[E].goToFrame(Z,this._weight);this._goToFrame=Z}get paused(){return this.od}pause(){this.od||(this.od=!0)}restart(){this.od=!1}_raiseOnAnimationEnd(){this.onAnimationEnd&&this.onAnimationEnd(),this.onAnimationEndObservable.notifyObservers(this)}stop(Z,J){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],O=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Z||J){const i=this._scene._activeAnimatables.indexOf(this);if(i>-1){const Y=this._runtimeAnimations;for(let E=Y.length-1;E>=0;E--){const O=Y[E];Z&&O.animation.name!=Z||(J&&!J(O.target)||(O.dispose(),Y.splice(E,1)))}0==Y.length&&(E||this._scene._activeAnimatables.splice(i,1),O||this._raiseOnAnimationEnd())}}else{const Z=this._scene._activeAnimatables.indexOf(this);if(Z>-1){E||this._scene._activeAnimatables.splice(Z,1);const J=this._runtimeAnimations;for(let Z=0;Z<J.length;Z++)J[Z].dispose();this._runtimeAnimations.length=0,O||this._raiseOnAnimationEnd()}}}waitAsync(){return new Promise((Z=>{this.onAnimationEndObservable.add((()=>{Z(this)}),void 0,void 0,this,!0)}))}_animate(Z){if(this.od)return this.animationStarted=!1,null===this._pausedDelay&&(this._pausedDelay=Z),!0;if(null===this._localDelayOffset?(this._localDelayOffset=Z,this._pausedDelay=null):null!==this._pausedDelay&&(this._localDelayOffset+=Z-this._pausedDelay,this._pausedDelay=null),null!==this._manualJumpDelay&&(this._localDelayOffset+=this._manualJumpDelay,this._manualJumpDelay=null,this._frameToSyncFromJump=null),this._goToFrame=null,0===this._weight)return!0;let J=!1;const E=this._runtimeAnimations;let O;for(O=0;O<E.length;O++){const i=E[O].animate(Z-this._localDelayOffset,this.fromFrame,this.toFrame,this.loopAnimation,this._speedRatio,this._weight);J=J||i}if(this.animationStarted=J,!J){if(this.disposeOnEnd)for(O=this._scene._activeAnimatables.indexOf(this),this._scene._activeAnimatables.splice(O,1),O=0;O<E.length;O++)E[O].dispose();this._raiseOnAnimationEnd(),this.disposeOnEnd&&(this.onAnimationEnd=null,this.onAnimationLoop=null,this.onAnimationLoopObservable.clear(),this.onAnimationEndObservable.clear())}return J}}function h(Z){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return Z.originalValue;let J=1;const E=z.j.fb[0],O=z.j.fb[1],i=z.j.Quaternion[0];let Y=0;const C=Z.animations[0],d=Z.originalValue;let g=1,A=!1;if(Z.totalWeight<1)g=1-Z.totalWeight,d.decompose(O,i,E);else{if(Y=1,J=Z.totalWeight,g=C.weight/J,1==g){if(!Z.totalAdditiveWeight)return C.currentValue;A=!0}C.currentValue.decompose(O,i,E)}if(!A){O.scaleInPlace(g),E.scaleInPlace(g),i.scaleInPlace(g);for(let C=Y;C<Z.animations.length;C++){const Y=Z.animations[C];if(0===Y.weight)continue;g=Y.weight/J;const d=z.j.fb[2],A=z.j.fb[3],R=z.j.Quaternion[1];Y.currentValue.decompose(A,R,d),A.scaleAndAddToRef(g,O),R.scaleAndAddToRef(z.h.Dot(i,R)>0?g:-g,i),d.scaleAndAddToRef(g,E)}i.normalize()}for(let h=0;h<Z.additiveAnimations.length;h++){const J=Z.additiveAnimations[h];if(0===J.weight)continue;const Y=z.j.fb[2],C=z.j.fb[3],d=z.j.Quaternion[1];J.currentValue.decompose(C,d,Y),C.multiplyToRef(O,C),z.o.LerpToRef(O,C,J.weight,O),i.multiplyToRef(d,d),z.h.SlerpToRef(i,d,J.weight,i),Y.scaleAndAddToRef(J.weight,E)}const R=C?C._animationState.workValue:z.j.Matrix[0].clone();return z.e.ComposeToRef(O,i,E,R),R}function L(Z,J){if(0===Z.totalWeight&&0===Z.totalAdditiveWeight)return J;const E=Z.animations[0],O=Z.originalValue;let i=J;if(0===Z.totalWeight&&Z.totalAdditiveWeight>0)i.p(O);else if(1===Z.animations.length){if(z.h.SlerpToRef(O,E.currentValue,Math.min(1,Z.totalWeight),i),0===Z.totalAdditiveWeight)return i}else if(Z.animations.length>1){let E,Y,C=1;if(Z.totalWeight<1){const J=1-Z.totalWeight;E=[],Y=[],E.push(O),Y.push(J)}else{if(2===Z.animations.length&&(z.h.SlerpToRef(Z.animations[0].currentValue,Z.animations[1].currentValue,Z.animations[1].weight/Z.totalWeight,J),0===Z.totalAdditiveWeight))return J;E=[],Y=[],C=Z.totalWeight}for(let J=0;J<Z.animations.length;J++){const O=Z.animations[J];E.push(O.currentValue),Y.push(O.weight/C)}let d=0;for(let Z=0;Z<E.length;)Z?(d+=Y[Z],z.h.SlerpToRef(i,E[Z],Y[Z]/d,i),Z++):(z.h.SlerpToRef(E[Z],E[Z+1],Y[Z+1]/(Y[Z]+Y[Z+1]),J),i=J,d=Y[Z]+Y[Z+1],Z+=2)}for(let Y=0;Y<Z.additiveAnimations.length;Y++){const J=Z.additiveAnimations[Y];0!==J.weight&&(i.multiplyToRef(J.currentValue,z.j.Quaternion[0]),z.h.SlerpToRef(i,z.j.Quaternion[0],J.weight,i))}return i}var v,X,l=E(11191);v=l.d,(X=d.d)&&(X.prototype.copyAnimationRange=function(Z,J,E){let i=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;0===this.animations.length&&(this.animations.push(new O.c(this.name,"_matrix",Z.animations[0].framePerSecond,O.c.ANIMATIONTYPE_MATRIX,0)),this.animations[0].setKeys([]));const C=Z.animations[0].getRange(J);if(!C)return!1;const d=C.from,z=C.to,g=Z.animations[0].getKeys(),A=Z.length,R=Z.getParent(),h=this.getParent(),L=i&&R&&A&&this.length&&A!==this.length,v=L&&h&&R?h.length/R.length:1,X=i&&!h&&Y&&(1!==Y.x||1!==Y.y||1!==Y.z),l=this.animations[0].getKeys();let K,T,W;for(let O=0,n=g.length;O<n;O++)K=g[O],K.frame>=d&&K.frame<=z&&(i?(W=K.value.clone(),L?(T=W.getTranslation(),W.setTranslation(T.scaleInPlace(v))):X&&Y?(T=W.getTranslation(),W.setTranslation(T.multiplyInPlace(Y))):W=K.value):W=K.value,l.push({frame:K.frame+E,value:W}));return this.animations[0].createRange(J,d+E,z+E),!0}),v&&(v.prototype._animate=function(Z){if(!this.animationsEnabled)return;const J=A.e.Now;if(!this._animationTimeLast){if(this._pendingData.length>0)return;this._animationTimeLast=J}this.deltaTime=void 0!==Z?Z:this.useConstantAnimationDeltaTime?16:(J-this._animationTimeLast)*this.animationTimeScale,this._animationTimeLast=J;const E=this._activeAnimatables;if(0===E.length)return;this._animationTime+=this.deltaTime;const i=this._animationTime;for(let O=0;O<E.length;O++){const Z=E[O];!Z._animate(i)&&Z.disposeOnEnd&&O--}!function(Z){if(Z._registeredForLateAnimationBindings.length){for(let J=0;J<Z._registeredForLateAnimationBindings.length;J++){const E=Z._registeredForLateAnimationBindings.data[J];for(const Z in E._lateAnimationHolders){const J=E._lateAnimationHolders[Z],i=J.animations[0],Y=J.originalValue;if(void 0===Y||null===Y)continue;const C=O.c.AllowMatrixDecomposeForInterpolation&&Y.m;let d=E[Z];if(C)d=h(J);else if(void 0!==Y.w)d=L(J,d||z.h.Identity());else{let Z=0,E=1;const C=i&&i._animationState.loopMode===O.c.ANIMATIONLOOPMODE_RELATIVE_FROM_CURRENT;if(J.totalWeight<1)d=C?Y.clone?Y.clone():Y:i&&Y.scale?Y.scale(1-J.totalWeight):i?Y*(1-J.totalWeight):Y.clone?Y.clone():Y;else if(i){E=J.totalWeight;const O=i.weight/E;d=1!==O?i.currentValue.scale?i.currentValue.scale(O):i.currentValue*O:i.currentValue,C&&(d.addToRef?d.addToRef(Y,d):d+=Y),Z=1}for(let O=Z;O<J.animations.length;O++){const Z=J.animations[O],i=Z.weight/E;i&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(i,d):d+=Z.currentValue*i)}for(let O=0;O<J.additiveAnimations.length;O++){const Z=J.additiveAnimations[O],E=Z.weight;E&&(Z.currentValue.scaleAndAddToRef?Z.currentValue.scaleAndAddToRef(E,d):d+=Z.currentValue*E)}}E[Z]=d}E._lateAnimationHolders={}}Z._registeredForLateAnimationBindings.reset()}}(this)},v.prototype.sortActiveAnimatables=function(){this._activeAnimatables.sort(((Z,J)=>Z.playOrder-J.playOrder))},v.prototype.beginWeightedAnimation=function(Z,J,E){let O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,i=arguments.length>4?arguments[4]:void 0,Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,z=arguments.length>8?arguments[8]:void 0,g=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];const R=this.beginAnimation(Z,J,E,i,Y,C,d,!1,z,g,A);return R.weight=O,R},v.prototype.beginAnimation=function(Z,J,E,O){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,Y=arguments.length>5?arguments[5]:void 0,C=arguments.length>6?arguments[6]:void 0,d=!(arguments.length>7&&void 0!==arguments[7])||arguments[7],z=arguments.length>8?arguments[8]:void 0,g=arguments.length>9?arguments[9]:void 0,A=arguments.length>10&&void 0!==arguments[10]&&arguments[10];if(i<0){const Z=J;J=E,E=Z,i=-i}J>E&&(i=-i),d&&this.stopAnimation(Z,void 0,z),C||(C=new R(this,Z,J,E,O,i,Y,void 0,g,A));const h=!z||z(Z);if(Z.animations&&h&&C.appendAnimations(Z,Z.animations),Z.getAnimatables){const A=Z.getAnimatables();for(let Z=0;Z<A.length;Z++)this.beginAnimation(A[Z],J,E,O,i,Y,C,d,z,g)}return C.reset(),C},v.prototype.beginHierarchyAnimation=function(Z,J,E,O,i){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,C=arguments.length>6?arguments[6]:void 0,d=arguments.length>7?arguments[7]:void 0,z=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],g=arguments.length>9?arguments[9]:void 0,A=arguments.length>11&&void 0!==arguments[11]&&arguments[11];const R=Z.getDescendants(J),h=[];h.push(this.beginAnimation(Z,E,O,i,Y,C,d,z,g,void 0,A));for(const L of R)h.push(this.beginAnimation(L,E,O,i,Y,C,d,z,g,void 0,A));return h},v.prototype.beginDirectAnimation=function(Z,J,E,O,i){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1;if(Y<0){const Z=E;E=O,O=Z,Y=-Y}return E>O&&(Y=-Y),new R(this,Z,E,O,i,Y,arguments.length>6?arguments[6]:void 0,J,arguments.length>7?arguments[7]:void 0,arguments.length>8&&void 0!==arguments[8]&&arguments[8])},v.prototype.beginDirectHierarchyAnimation=function(Z,J,E,O,i,Y,C,d,z){let g=arguments.length>9&&void 0!==arguments[9]&&arguments[9];const A=Z.getDescendants(J),R=[];R.push(this.beginDirectAnimation(Z,E,O,i,Y,C,d,z,g));for(const h of A)R.push(this.beginDirectAnimation(h,E,O,i,Y,C,d,z,g));return R},v.prototype.getAnimatableByTarget=function(Z){for(let J=0;J<this._activeAnimatables.length;J++)if(this._activeAnimatables[J].target===Z)return this._activeAnimatables[J];return null},v.prototype.getAllAnimatablesByTarget=function(Z){const J=[];for(let E=0;E<this._activeAnimatables.length;E++)this._activeAnimatables[E].target===Z&&J.push(this._activeAnimatables[E]);return J},v.prototype.stopAnimation=function(Z,J,E){const O=this.getAllAnimatablesByTarget(Z);for(const i of O)i.stop(J,E)},v.prototype.stopAllAnimations=function(){if(this._activeAnimatables){for(let Z=0;Z<this._activeAnimatables.length;Z++)this._activeAnimatables[Z].stop(void 0,void 0,!0);this._activeAnimatables.length=0}for(const Z of this.animationGroups)Z.stop()});class K{getClassName(){return"TargetedAnimation"}serialize(){const Z={};return Z.animation=this.animation.serialize(),Z.targetId=this.target.id,Z}}class T{get mask(){return this._mask}set mask(Z){this._mask!==Z&&(this._mask=Z,this.syncWithMask(!0))}syncWithMask(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(this.mask||Z){this._numActiveAnimatables=0;for(let Z=0;Z<this._animatables.length;++Z){const J=this._animatables[Z];!this.mask||this.mask.disabled||this.mask.retainsTarget(J.target.name)?(this._numActiveAnimatables++,J.paused&&J.restart()):J.paused||J.pause()}}else this._numActiveAnimatables=this._targetedAnimations.length}removeUnmaskedAnimations(){if(this.mask&&!this.mask.disabled){for(let Z=0;Z<this._animatables.length;++Z){const J=this._animatables[Z];this.mask.retainsTarget(J.target.name)||(J.stop(),this._animatables.splice(Z,1),--Z)}for(let Z=0;Z<this._targetedAnimations.length;Z++){const J=this._targetedAnimations[Z];this.mask.retainsTarget(J.target.name)||(this._targetedAnimations.splice(Z,1),--Z)}}}get from(){return this._from}set from(Z){if(this._from!==Z){this._from=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].fromFrame=this._from}}}get to(){return this._to}set to(Z){if(this._to!==Z){this._to=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].toFrame=this._to}}}get isStarted(){return this._isStarted}get isPlaying(){return this._isStarted&&!this._isPaused}get speedRatio(){return this._speedRatio}set speedRatio(Z){if(this._speedRatio!==Z){this._speedRatio=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].speedRatio=this._speedRatio}}}get loopAnimation(){return this._loopAnimation}set loopAnimation(Z){if(this._loopAnimation!==Z){this._loopAnimation=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].loopAnimation=this._loopAnimation}}}get isAdditive(){return this._isAdditive}set isAdditive(Z){if(this._isAdditive!==Z){this._isAdditive=Z;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].isAdditive=this._isAdditive}}}get weight(){return this._weight}set weight(Z){this._weight!==Z&&(this._weight=Z,this.setWeightForAllAnimatables(this._weight))}get targetedAnimations(){return this._targetedAnimations}get animatables(){return this._animatables}get children(){return this._targetedAnimations}get playOrder(){return this._playOrder}set playOrder(Z){if(this._playOrder!==Z&&(this._playOrder=Z,this._animatables.length>0)){for(let Z=0;Z<this._animatables.length;Z++)this._animatables[Z].playOrder=this._playOrder;this._scene.sortActiveAnimatables()}}get enableBlending(){return this._enableBlending}set enableBlending(Z){if(this._enableBlending!==Z&&(this._enableBlending=Z,null!==Z))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.enableBlending=Z}get blendingSpeed(){return this._blendingSpeed}set blendingSpeed(Z){if(this._blendingSpeed!==Z&&(this._blendingSpeed=Z,null!==Z))for(let J=0;J<this._targetedAnimations.length;++J)this._targetedAnimations[J].animation.blendingSpeed=Z}getLength(Z,J){Z=Z??this._from;return((J=J??this._to)-Z)/(this.targetedAnimations[0].animation.framePerSecond*this._speedRatio)}static MergeAnimationGroups(Z){let J=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],E=arguments.length>2&&void 0!==arguments[2]&&arguments[2],O=arguments.length>3?arguments[3]:void 0;if(0===Z.length)return null;O=O??Z[0].weight;let i=Number.MAX_VALUE,Y=-Number.MAX_VALUE;if(E)for(const d of Z)d.from<i&&(i=d.from),d.to>Y&&(Y=d.to);const C=new T(Z[0].name+"_merged",Z[0]._scene,O);for(const d of Z){E&&d.normalize(i,Y);for(const Z of d.targetedAnimations)C.addTargetedAnimation(Z.animation,Z.target);J&&d.dispose()}return C}constructor(Z){let J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,E=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,O=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;this.name=Z,this._targetedAnimations=new Array,this._animatables=new Array,this._from=Number.MAX_VALUE,this._to=-Number.MAX_VALUE,this._speedRatio=1,this._loopAnimation=!1,this._isAdditive=!1,this._weight=-1,this._playOrder=0,this._enableBlending=null,this._blendingSpeed=null,this._numActiveAnimatables=0,this._shouldStart=!0,this._parentContainer=null,this.onAnimationEndObservable=new i.c,this.onAnimationLoopObservable=new i.c,this.onAnimationGroupLoopObservable=new i.c,this.onAnimationGroupEndObservable=new i.c,this.onAnimationGroupPauseObservable=new i.c,this.onAnimationGroupPlayObservable=new i.c,this.metadata=null,this._mask=null,this._animationLoopFlags=[],this._scene=J||Y.d.LastCreatedScene,this._weight=E,this._playOrder=O,this.uniqueId=this._scene.getUniqueId(),this._scene.addAnimationGroup(this)}addTargetedAnimation(Z,J){const E=new K;E.animation=Z,E.target=J;const O=Z.getKeys();return this._from>O[0].frame&&(this._from=O[0].frame),this._to<O[O.length-1].frame&&(this._to=O[O.length-1].frame),null!==this._enableBlending&&(Z.enableBlending=this._enableBlending),null!==this._blendingSpeed&&(Z.blendingSpeed=this._blendingSpeed),this._targetedAnimations.push(E),this._shouldStart=!0,E}removeTargetedAnimation(Z){for(let J=this._targetedAnimations.length-1;J>-1;J--){this._targetedAnimations[J].animation===Z&&this._targetedAnimations.splice(J,1)}}normalize(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;null==Z&&(Z=this._from),null==J&&(J=this._to);for(let E=0;E<this._targetedAnimations.length;E++){const O=this._targetedAnimations[E].animation.getKeys(),i=O[0],Y=O[O.length-1];if(i.frame>Z){const J={frame:Z,value:i.value,inTangent:i.inTangent,outTangent:i.outTangent,interpolation:i.interpolation};O.splice(0,0,J)}if(Y.frame<J){const Z={frame:J,value:Y.value,inTangent:Y.inTangent,outTangent:Y.outTangent,interpolation:Y.interpolation};O.push(Z)}}return this._from=Z,this._to=J,this}_processLoop(Z,J,E){Z.onAnimationLoop=()=>{this.onAnimationLoopObservable.notifyObservers(J),this._animationLoopFlags[E]||(this._animationLoopFlags[E]=!0,this._animationLoopCount++,this._animationLoopCount===this._numActiveAnimatables&&(this.onAnimationGroupLoopObservable.notifyObservers(this),this._animationLoopCount=0,this._animationLoopFlags.length=0))}}start(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0],J=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,E=arguments.length>2?arguments[2]:void 0,O=arguments.length>3?arguments[3]:void 0,i=arguments.length>4?arguments[4]:void 0;if(this._isStarted||0===this._targetedAnimations.length)return this;this._loopAnimation=Z,this._shouldStart=!1,this._animationLoopCount=0,this._animationLoopFlags.length=0;for(let Y=0;Y<this._targetedAnimations.length;Y++){const C=this._targetedAnimations[Y],d=this._scene.beginDirectAnimation(C.target,[C.animation],void 0!==E?E:this._from,void 0!==O?O:this._to,Z,J,void 0,void 0,void 0!==i?i:this._isAdditive);d.weight=this._weight,d.playOrder=this._playOrder,d.onAnimationEnd=()=>{this.onAnimationEndObservable.notifyObservers(C),this._checkAnimationGroupEnded(d)},this._processLoop(d,C,Y),this._animatables.push(d)}return this.syncWithMask(),this._scene.sortActiveAnimatables(),this._speedRatio=J,this._isStarted=!0,this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}pause(){if(!this._isStarted)return this;this._isPaused=!0;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].pause()}return this.onAnimationGroupPauseObservable.notifyObservers(this),this}play(Z){return this.isStarted&&this._animatables.length&&!this._shouldStart?(void 0!==Z&&(this.loopAnimation=Z),this.restart()):(this.stop(),this.start(Z,this._speedRatio)),this}reset(){if(!this._isStarted)return this.play(),this.goToFrame(0),this.stop(!0),this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].reset()}return this}restart(){if(!this._isStarted)return this;for(let Z=0;Z<this._animatables.length;Z++){this._animatables[Z].restart()}return this.syncWithMask(),this._isPaused=!1,this.onAnimationGroupPlayObservable.notifyObservers(this),this}stop(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];if(!this._isStarted)return this;const J=this._animatables.slice();for(let O=0;O<J.length;O++)J[O].stop(void 0,void 0,!0,Z);let E=0;for(let O=0;O<this._scene._activeAnimatables.length;O++){const J=this._scene._activeAnimatables[O];J._runtimeAnimations.length>0?this._scene._activeAnimatables[E++]=J:Z&&this._checkAnimationGroupEnded(J,Z)}return this._scene._activeAnimatables.length=E,this._isStarted=!1,this}setWeightForAllAnimatables(Z){for(let J=0;J<this._animatables.length;J++){this._animatables[J].weight=Z}return this}syncAllAnimationsWith(Z){for(let J=0;J<this._animatables.length;J++){this._animatables[J].syncWith(Z)}return this}goToFrame(Z){if(!this._isStarted)return this;for(let J=0;J<this._animatables.length;J++){this._animatables[J].goToFrame(Z)}return this}getCurrentFrame(){var Z;return(null===(Z=this.animatables[0])||void 0===Z?void 0:Z.masterFrame)||0}dispose(){this.isStarted&&this.stop(),this._targetedAnimations.length=0,this._animatables.length=0;const Z=this._scene.animationGroups.indexOf(this);if(Z>-1&&this._scene.animationGroups.splice(Z,1),this._parentContainer){const Z=this._parentContainer.animationGroups.indexOf(this);Z>-1&&this._parentContainer.animationGroups.splice(Z,1),this._parentContainer=null}this.onAnimationEndObservable.clear(),this.onAnimationGroupEndObservable.clear(),this.onAnimationGroupPauseObservable.clear(),this.onAnimationGroupPlayObservable.clear(),this.onAnimationLoopObservable.clear(),this.onAnimationGroupLoopObservable.clear()}_checkAnimationGroupEnded(Z){let J=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const E=this._animatables.indexOf(Z);E>-1&&this._animatables.splice(E,1),0===this._animatables.length&&(this._isStarted=!1,J||this.onAnimationGroupEndObservable.notifyObservers(this))}clone(Z,J){let E=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const O=new T(Z||this.name,this._scene,this._weight,this._playOrder);O._from=this.from,O._to=this.to,O._speedRatio=this.speedRatio,O._loopAnimation=this.loopAnimation,O._isAdditive=this.isAdditive,O._enableBlending=this.enableBlending,O._blendingSpeed=this.blendingSpeed,O.metadata=this.metadata,O.mask=this.mask;for(const i of this._targetedAnimations)O.addTargetedAnimation(E?i.animation.clone():i.animation,J?J(i.target):i.target);return O}serialize(){const Z={};Z.name=this.name,Z.from=this.from,Z.to=this.to,Z.speedRatio=this.speedRatio,Z.loopAnimation=this.loopAnimation,Z.isAdditive=this.isAdditive,Z.weight=this.weight,Z.playOrder=this.playOrder,Z.enableBlending=this.enableBlending,Z.blendingSpeed=this.blendingSpeed,Z.targetedAnimations=[];for(let J=0;J<this.targetedAnimations.length;J++){const E=this.targetedAnimations[J];Z.targetedAnimations[J]=E.serialize()}return C.c&&C.c.HasTags(this)&&(Z.tags=C.c.GetTags(this)),this.metadata&&(Z.metadata=this.metadata),Z}static Parse(Z,J){const E=new T(Z.name,J,Z.weight,Z.playOrder);for(let i=0;i<Z.targetedAnimations.length;i++){const Y=Z.targetedAnimations[i],C=O.c.Parse(Y.animation),d=Y.targetId;if("influence"===Y.animation.property){const Z=J.getMorphTargetById(d);Z&&E.addTargetedAnimation(C,Z)}else{const Z=J.getNodeById(d);null!=Z&&E.addTargetedAnimation(C,Z)}}return C.c&&C.c.AddTagsTo(E,Z.tags),null!==Z.from&&null!==Z.to&&E.normalize(Z.from,Z.to),void 0!==Z.speedRatio&&(E._speedRatio=Z.speedRatio),void 0!==Z.loopAnimation&&(E._loopAnimation=Z.loopAnimation),void 0!==Z.isAdditive&&(E._isAdditive=Z.isAdditive),void 0!==Z.weight&&(E._weight=Z.weight),void 0!==Z.playOrder&&(E._playOrder=Z.playOrder),void 0!==Z.enableBlending&&(E._enableBlending=Z.enableBlending),void 0!==Z.blendingSpeed&&(E._blendingSpeed=Z.blendingSpeed),void 0!==Z.metadata&&(E.metadata=Z.metadata),E}static MakeAnimationAdditive(Z,J,E){let i;i="object"===typeof J?J:{referenceFrame:J,range:E,cloneOriginalAnimationGroup:arguments.length>3&&void 0!==arguments[3]&&arguments[3],clonedAnimationName:arguments.length>4?arguments[4]:void 0};let Y=Z;i.cloneOriginalAnimationGroup&&(Y=Z.clone(i.clonedAnimationGroupName||Y.name));const C=Y.targetedAnimations;for(let d=0;d<C.length;d++){const Z=C[d];Z.animation=O.c.MakeAnimationAdditive(Z.animation,i)}if(Y.isAdditive=!0,i.clipKeys){let Z=Number.MAX_VALUE,J=-Number.MAX_VALUE;const E=Y.targetedAnimations;for(let O=0;O<E.length;O++){const i=E[O].animation.getKeys();Z>i[0].frame&&(Z=i[0].frame),J<i[i.length-1].frame&&(J=i[i.length-1].frame)}Y._from=Z,Y._to=J}return Y}static ClipKeys(Z,J,E,O,i){const Y=Z.clone(O||Z.name);return T.ClipKeysInPlace(Y,J,E,i)}static ClipKeysInPlace(Z,J,E,O){return T.ClipInPlace(Z,J,E,O,!1)}static ClipFrames(Z,J,E,O,i){const Y=Z.clone(O||Z.name);return T.ClipFramesInPlace(Y,J,E,i)}static ClipFramesInPlace(Z,J,E,O){return T.ClipInPlace(Z,J,E,O,!0)}static ClipInPlace(Z,J,E,O){let i=arguments.length>4&&void 0!==arguments[4]&&arguments[4],Y=Number.MAX_VALUE,C=-Number.MAX_VALUE;const d=Z.targetedAnimations;for(let z=0;z<d.length;z++){const Z=d[z],g=O?Z.animation:Z.animation.clone();i&&(g.createKeyForFrame(J),g.createKeyForFrame(E));const A=g.getKeys(),R=[];let h=Number.MAX_VALUE;for(let O=0;O<A.length;O++){const Z=A[O];if(!i&&O>=J&&O<=E||i&&Z.frame>=J&&Z.frame<=E){const J={frame:Z.frame,value:Z.value.clone?Z.value.clone():Z.value,inTangent:Z.inTangent,outTangent:Z.outTangent,interpolation:Z.interpolation,lockedTangent:Z.lockedTangent};h===Number.MAX_VALUE&&(h=J.frame),J.frame-=h,R.push(J)}}0!==R.length?(Y>R[0].frame&&(Y=R[0].frame),C<R[R.length-1].frame&&(C=R[R.length-1].frame),g.setKeys(R,!0),Z.animation=g):(d.splice(z,1),z--)}return Z._from=Y,Z._to=C,Z}getClassName(){return"AnimationGroup"}toString(Z){let J="Name: "+this.name;return J+=", type: "+this.getClassName(),Z&&(J+=", from: "+this._from,J+=", to: "+this._to,J+=", isStarted: "+this._isStarted,J+=", speedRatio: "+this._speedRatio,J+=", targetedAnimations length: "+this._targetedAnimations.length,J+=", animatables length: "+this._animatables),J}}}}]);