"use strict";(self["6xhfpmwgjr5"]=self["6xhfpmwgjr5"]||[]).push([[47],{15709:(P,a,R)=>{R.r(a),R.d(a,{_BasisTextureLoader:()=>t});var S,A=R(12225),Z=R(12399),p=R(12359);function j(){const P=0,a=1,R=2,S=3,A=6,Z=8,p=9,j=10,U=14;let Q=null;function h(P,a,R,S,A){const Z=P.getImageTranscodedSizeInBytes(a,R,S);let p=new Uint8Array(Z);if(!P.transcodeImage(p,a,R,S,1,0))return null;if(A){p=function(P,a,R,S){const A=new Uint16Array(4),Z=new Uint16Array(R*S),p=R/4,j=S/4;for(let U=0;U<j;U++)for(let S=0;S<p;S++){const j=a+8*(U*p+S);A[0]=P[j]|P[j+1]<<8,A[1]=P[j+2]|P[j+3]<<8,A[2]=(2*(31&A[0])+1*(31&A[1]))/3|(2*(2016&A[0])+1*(2016&A[1]))/3&2016|(2*(63488&A[0])+1*(63488&A[1]))/3&63488,A[3]=(2*(31&A[1])+1*(31&A[0]))/3|(2*(2016&A[1])+1*(2016&A[0]))/3&2016|(2*(63488&A[1])+1*(63488&A[0]))/3&63488;for(let a=0;a<4;a++){const p=P[j+4+a];let Q=(4*U+a)*R+4*S;Z[Q++]=A[3&p],Z[Q++]=A[p>>2&3],Z[Q++]=A[p>>4&3],Z[Q++]=A[p>>6&3]}}return Z}(p,0,P.getImageWidth(a,R)+3&-4,P.getImageHeight(a,R)+3&-4)}return p}onmessage=l=>{if("init"===l.data.action){if(l.data.url)try{importScripts(l.data.url)}catch(V){postMessage({action:"error",error:V})}Q||(Q=BASIS({wasmBinary:l.data.wasmBinary})),null!==Q&&Q.then((P=>{BASIS=P,P.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===l.data.action){const Q=l.data.config,V=l.data.imageData,f=new BASIS.BasisFile(V),O=function(P){const a=P.getHasAlpha(),R=P.getNumImages(),S=[];for(let A=0;A<R;A++){const a={levels:[]},R=P.getNumLevels(A);for(let S=0;S<R;S++){const R={width:P.getImageWidth(A,S),height:P.getImageHeight(A,S)};a.levels.push(R)}S.push(a)}return{jj:a,images:S}}(f);let q=l.data.ignoreSupportedFormats?null:function(Q,h){let l=null;Q.supportedCompressionFormats&&(l=Q.supportedCompressionFormats.astc?j:Q.supportedCompressionFormats.bc7?A:Q.supportedCompressionFormats.s3tc?h.jj?S:R:Q.supportedCompressionFormats.pvrtc?h.jj?p:Z:Q.supportedCompressionFormats.etc2?a:Q.supportedCompressionFormats.etc1?P:U);return l}(l.data.config,O),y=!1;null===q&&(y=!0,q=O.jj?S:R);let t=!0;f.startTranscoding()||(t=!1);const W=[];for(let P=0;P<O.images.length&&t;P++){const a=O.images[P];if(void 0===Q.loadSingleImage||Q.loadSingleImage===P){let R=a.levels.length;!1===Q.loadMipmapLevels&&(R=1);for(let S=0;S<R;S++){const R=a.levels[S],A=h(f,P,S,q,y);if(!A){t=!1;break}R.transcodedPixels=A,W.push(R.transcodedPixels.buffer)}}}f.close(),f.delete(),y&&(q=-1),t?postMessage({action:"transcode",success:t,id:l.data.id,fileInfo:O,format:q},W):postMessage({action:"transcode",success:t,id:l.data.id})}}}!function(P){P[P.cTFETC1=0]="cTFETC1",P[P.cTFETC2=1]="cTFETC2",P[P.cTFBC1=2]="cTFBC1",P[P.cTFBC3=3]="cTFBC3",P[P.cTFBC4=4]="cTFBC4",P[P.cTFBC5=5]="cTFBC5",P[P.cTFBC7=6]="cTFBC7",P[P.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",P[P.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",P[P.cTFASTC_4x4=10]="cTFASTC_4x4",P[P.cTFATC_RGB=11]="cTFATC_RGB",P[P.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",P[P.cTFRGBA32=13]="cTFRGBA32",P[P.cTFRGB565=14]="cTFRGB565",P[P.cTFBGR565=15]="cTFBGR565",P[P.cTFRGBA4444=16]="cTFRGBA4444",P[P.cTFFXT1_RGB=17]="cTFFXT1_RGB",P[P.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",P[P.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",P[P.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",P[P.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(S||(S={}));const U={JSModuleURL:`${A.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${A.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Q=null,h=null,l=0;const V=async()=>(Q||(Q=new Promise(((P,a)=>{h?P(h):A.Tools.LoadFileAsync(A.Tools.GetBabylonScriptURL(U.WasmModuleURL)).then((R=>{if("function"!==typeof URL)return a("Basis transcoder requires an environment with a URL constructor");const S=URL.createObjectURL(new Blob([`(${j})()`],{type:"application/javascript"}));h=new Worker(S),async function(P,a,R){return await new Promise(((S,Z)=>{const p=a=>{"init"===a.data.action?(P.removeEventListener("message",p),S(P)):"error"===a.data.action&&Z(a.data.error||"error initializing worker")};P.addEventListener("message",p),P.postMessage({action:"init",url:R?A.Tools.GetBabylonScriptURL(R):void 0,wasmBinary:a},[a])}))}(h,R,U.JSModuleURL).then(P,a)})).catch(a)}))),await Q),f=async(P,a)=>{const R=P instanceof ArrayBuffer?new Uint8Array(P):P;return await new Promise(((P,S)=>{V().then((()=>{const A=l++,Z=a=>{"transcode"===a.data.action&&a.data.id===A&&(h.removeEventListener("message",Z),a.data.success?P(a.data):S("Transcode is not supported on this device"))};h.addEventListener("message",Z);const p=new Uint8Array(R.byteLength);p.set(new Uint8Array(R.buffer,R.byteOffset,R.byteLength)),h.postMessage({action:"transcode",id:A,imageData:p,config:a,ignoreSupportedFormats:false},[p.buffer])}),(P=>{S(P)}))}))},O=(P,a)=>{var R;let S=null===(R=a._gl)||void 0===R?void 0:R.TEXTURE_2D;var A;P.isCube&&(S=null===(A=a._gl)||void 0===A?void 0:A.TEXTURE_CUBE_MAP);a._bindTextureDirectly(S,P,!0)},q=(P,a)=>{const R=P.getEngine();for(let j=0;j<a.fileInfo.images.length;j++){const U=a.fileInfo.images[j].levels[0];if(P._invertVScale=P.invertY,-1===a.format||a.format===S.cTFRGB565)if(P.type=10,P.format=4,!R._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0)P._invertVScale=!P.invertY,P.width=U.width+3&-4,P.height=U.height+3&-4,P.samplingMode=2,O(P,R),R._uploadDataToTextureDirectly(P,new Uint16Array(U.transcodedPixels.buffer),j,0,4,!0);else{const a=new p.c(R,2);P._invertVScale=P.invertY,a.type=10,a.format=4,a.width=U.width+3&-4,a.height=U.height+3&-4,O(a,R),R._uploadDataToTextureDirectly(a,new Uint16Array(U.transcodedPixels.buffer),j,0,4,!0),R._rescaleTexture(a,P,R.scenes[0],R._getInternalFormat(4),(()=>{R._releaseTexture(a),O(P,R)}))}else{P.width=U.width,P.height=U.height,P.generateMipMaps=a.fileInfo.images[j].levels.length>1;const S=y.GetInternalFormatFromBasisFormat(a.format,R);P.format=S,O(P,R);const p=a.fileInfo.images[j].levels;for(let a=0;a<p.length;a++){const A=p[a];R._uploadCompressedDataToTextureDirectly(P,S,A.width,A.height,A.transcodedPixels,j,a)}!R._features.basisNeedsPOT||Math.log2(P.width)%1===0&&Math.log2(P.height)%1===0||(A.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),P._cachedWrapU=Z.e.CLAMP_ADDRESSMODE,P._cachedWrapV=Z.e.CLAMP_ADDRESSMODE)}}},y={JSModuleURL:U.JSModuleURL,WasmModuleURL:U.WasmModuleURL,GetInternalFormatFromBasisFormat:(P,a)=>{let R;switch(P){case S.cTFETC1:R=36196;break;case S.cTFBC1:R=33776;break;case S.cTFBC4:R=33779;break;case S.cTFASTC_4x4:R=37808;break;case S.cTFETC2:R=37496;break;case S.cTFBC7:R=36492}if(void 0===R)throw"The chosen Basis transcoder format is not currently supported";return R},TranscodeAsync:f,LoadTextureFromTranscodeResult:q};Object.defineProperty(y,"JSModuleURL",{get:function(){return U.JSModuleURL},set:function(P){U.JSModuleURL=P}}),Object.defineProperty(y,"WasmModuleURL",{get:function(){return U.WasmModuleURL},set:function(P){U.WasmModuleURL=P}});class t{constructor(){this.supportCascades=!1}loadCubeData(P,a,R,S,Z){if(Array.isArray(P))return;const p=a.getEngine().getCaps(),j={supportedCompressionFormats:{etc1:!!p.etc1,s3tc:!!p.s3tc,pvrtc:!!p.pvrtc,etc2:!!p.etc2,astc:!!p.astc,bc7:!!p.bptc}};f(P,j).then((P=>{const R=P.fileInfo.images[0].levels.length>1&&a.generateMipMaps;q(a,P),a.getEngine()._setCubeMapTextureParams(a,R),a.isReady=!0,a.onLoadedObservable.notifyObservers(a),a.onLoadedObservable.clear(),S&&S()})).catch((P=>{A.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),a.isReady=!0,Z&&Z(P)}))}loadData(P,a,R){const S=a.getEngine().getCaps(),Z={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};f(P,Z).then((P=>{const S=P.fileInfo.images[0].levels[0],A=P.fileInfo.images[0].levels.length>1&&a.generateMipMaps;R(S.width,S.height,A,-1!==P.format,(()=>{q(a,P)}))})).catch((P=>{A.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),A.Tools.Warn(`Failed to transcode Basis file: ${P}`),R(0,0,!1,!1,(()=>{}),!0)}))}}}}]);