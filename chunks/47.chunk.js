"use strict";(self.fwuvyyymhp8=self.fwuvyyymhp8||[]).push([[47],{14798:(N,U,V)=>{V.r(U),V.d(U,{_BasisTextureLoader:()=>d});var A,t=V(12179),n=V(12364),q=V(12319);function i(){const N=0,U=1,V=2,A=3,t=6,n=8,q=9,i=10,z=14;let S=null;function E(N,U,V,A,t){const n=N.getImageTranscodedSizeInBytes(U,V,A);let q=new Uint8Array(n);if(!N.transcodeImage(q,U,V,A,1,0))return null;if(t){q=function(N,U,V,A){const t=new Uint16Array(4),n=new Uint16Array(V*A),q=V/4,i=A/4;for(let z=0;z<i;z++)for(let A=0;A<q;A++){const i=U+8*(z*q+A);t[0]=N[i]|N[i+1]<<8,t[1]=N[i+2]|N[i+3]<<8,t[2]=(2*(31&t[0])+1*(31&t[1]))/3|(2*(2016&t[0])+1*(2016&t[1]))/3&2016|(2*(63488&t[0])+1*(63488&t[1]))/3&63488,t[3]=(2*(31&t[1])+1*(31&t[0]))/3|(2*(2016&t[1])+1*(2016&t[0]))/3&2016|(2*(63488&t[1])+1*(63488&t[0]))/3&63488;for(let U=0;U<4;U++){const q=N[i+4+U];let S=(4*z+U)*V+4*A;n[S++]=t[3&q],n[S++]=t[q>>2&3],n[S++]=t[q>>4&3],n[S++]=t[q>>6&3]}}return n}(q,0,N.getImageWidth(U,V)+3&-4,N.getImageHeight(U,V)+3&-4)}return q}onmessage=p=>{if("init"===p.data.action){if(p.data.url)try{importScripts(p.data.url)}catch(k){postMessage({action:"error",error:k})}S||(S=BASIS({wasmBinary:p.data.wasmBinary})),null!==S&&S.then((N=>{BASIS=N,N.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===p.data.action){const S=p.data.config,k=p.data.imageData,B=new BASIS.BasisFile(k),C=function(N){const U=N.getHasAlpha(),V=N.getNumImages(),A=[];for(let t=0;t<V;t++){const U={levels:[]},V=N.getNumLevels(t);for(let A=0;A<V;A++){const V={width:N.getImageWidth(t,A),height:N.getImageHeight(t,A)};U.levels.push(V)}A.push(U)}return{ki:U,images:A}}(B);let x=p.data.ignoreSupportedFormats?null:function(S,E){let p=null;S.supportedCompressionFormats&&(p=S.supportedCompressionFormats.astc?i:S.supportedCompressionFormats.bc7?t:S.supportedCompressionFormats.s3tc?E.ki?A:V:S.supportedCompressionFormats.pvrtc?E.ki?q:n:S.supportedCompressionFormats.etc2?U:S.supportedCompressionFormats.etc1?N:z);return p}(p.data.config,C),J=!1;null===x&&(J=!0,x=C.ki?A:V);let d=!0;B.startTranscoding()||(d=!1);const r=[];for(let N=0;N<C.images.length&&d;N++){const U=C.images[N];if(void 0===S.loadSingleImage||S.loadSingleImage===N){let V=U.levels.length;!1===S.loadMipmapLevels&&(V=1);for(let A=0;A<V;A++){const V=U.levels[A],t=E(B,N,A,x,J);if(!t){d=!1;break}V.transcodedPixels=t,r.push(V.transcodedPixels.buffer)}}}B.close(),B.delete(),J&&(x=-1),d?postMessage({action:"transcode",success:d,id:p.data.id,fileInfo:C,format:x},r):postMessage({action:"transcode",success:d,id:p.data.id})}}}!function(N){N[N.cTFETC1=0]="cTFETC1",N[N.cTFETC2=1]="cTFETC2",N[N.cTFBC1=2]="cTFBC1",N[N.cTFBC3=3]="cTFBC3",N[N.cTFBC4=4]="cTFBC4",N[N.cTFBC5=5]="cTFBC5",N[N.cTFBC7=6]="cTFBC7",N[N.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",N[N.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",N[N.cTFASTC_4x4=10]="cTFASTC_4x4",N[N.cTFATC_RGB=11]="cTFATC_RGB",N[N.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",N[N.cTFRGBA32=13]="cTFRGBA32",N[N.cTFRGB565=14]="cTFRGB565",N[N.cTFBGR565=15]="cTFBGR565",N[N.cTFRGBA4444=16]="cTFRGBA4444",N[N.cTFFXT1_RGB=17]="cTFFXT1_RGB",N[N.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",N[N.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",N[N.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",N[N.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(A||(A={}));const z={JSModuleURL:`${t.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${t.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let S=null,E=null,p=0;const k=async()=>(S||(S=new Promise(((N,U)=>{E?N(E):t.Tools.LoadFileAsync(t.Tools.GetBabylonScriptURL(z.WasmModuleURL)).then((V=>{if("function"!==typeof URL)return U("Basis transcoder requires an environment with a URL constructor");const A=URL.createObjectURL(new Blob([`(${i})()`],{type:"application/javascript"}));E=new Worker(A),async function(N,U,V){return await new Promise(((A,n)=>{const q=U=>{"init"===U.data.action?(N.removeEventListener("message",q),A(N)):"error"===U.data.action&&n(U.data.error||"error initializing worker")};N.addEventListener("message",q),N.postMessage({action:"init",url:V?t.Tools.GetBabylonScriptURL(V):void 0,wasmBinary:U},[U])}))}(E,V,z.JSModuleURL).then(N,U)})).catch(U)}))),await S),B=async(N,U)=>{const V=N instanceof ArrayBuffer?new Uint8Array(N):N;return await new Promise(((N,A)=>{k().then((()=>{const t=p++,n=U=>{"transcode"===U.data.action&&U.data.id===t&&(E.removeEventListener("message",n),U.data.success?N(U.data):A("Transcode is not supported on this device"))};E.addEventListener("message",n);const q=new Uint8Array(V.byteLength);q.set(new Uint8Array(V.buffer,V.byteOffset,V.byteLength)),E.postMessage({action:"transcode",id:t,imageData:q,config:U,ignoreSupportedFormats:false},[q.buffer])}),(N=>{A(N)}))}))},C=(N,U)=>{var V;let A=null===(V=U._gl)||void 0===V?void 0:V.TEXTURE_2D;var t;N.isCube&&(A=null===(t=U._gl)||void 0===t?void 0:t.TEXTURE_CUBE_MAP);U._bindTextureDirectly(A,N,!0)},x=(N,U)=>{const V=N.getEngine();for(let i=0;i<U.fileInfo.images.length;i++){const z=U.fileInfo.images[i].levels[0];if(N._invertVScale=N.invertY,-1===U.format||U.format===A.cTFRGB565)if(N.type=10,N.format=4,!V._features.basisNeedsPOT||Math.log2(z.width)%1===0&&Math.log2(z.height)%1===0)N._invertVScale=!N.invertY,N.width=z.width+3&-4,N.height=z.height+3&-4,N.samplingMode=2,C(N,V),V._uploadDataToTextureDirectly(N,new Uint16Array(z.transcodedPixels.buffer),i,0,4,!0);else{const U=new q.d(V,2);N._invertVScale=N.invertY,U.type=10,U.format=4,U.width=z.width+3&-4,U.height=z.height+3&-4,C(U,V),V._uploadDataToTextureDirectly(U,new Uint16Array(z.transcodedPixels.buffer),i,0,4,!0),V._rescaleTexture(U,N,V.scenes[0],V._getInternalFormat(4),(()=>{V._releaseTexture(U),C(N,V)}))}else{N.width=z.width,N.height=z.height,N.generateMipMaps=U.fileInfo.images[i].levels.length>1;const A=J.GetInternalFormatFromBasisFormat(U.format,V);N.format=A,C(N,V);const q=U.fileInfo.images[i].levels;for(let U=0;U<q.length;U++){const t=q[U];V._uploadCompressedDataToTextureDirectly(N,A,t.width,t.height,t.transcodedPixels,i,U)}!V._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0||(t.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),N._cachedWrapU=n.e.CLAMP_ADDRESSMODE,N._cachedWrapV=n.e.CLAMP_ADDRESSMODE)}}},J={JSModuleURL:z.JSModuleURL,WasmModuleURL:z.WasmModuleURL,GetInternalFormatFromBasisFormat:(N,U)=>{let V;switch(N){case A.cTFETC1:V=36196;break;case A.cTFBC1:V=33776;break;case A.cTFBC4:V=33779;break;case A.cTFASTC_4x4:V=37808;break;case A.cTFETC2:V=37496;break;case A.cTFBC7:V=36492}if(void 0===V)throw"The chosen Basis transcoder format is not currently supported";return V},TranscodeAsync:B,LoadTextureFromTranscodeResult:x};Object.defineProperty(J,"JSModuleURL",{get:function(){return z.JSModuleURL},set:function(N){z.JSModuleURL=N}}),Object.defineProperty(J,"WasmModuleURL",{get:function(){return z.WasmModuleURL},set:function(N){z.WasmModuleURL=N}});class d{constructor(){this.supportCascades=!1}loadCubeData(N,U,V,A,n){if(Array.isArray(N))return;const q=U.getEngine().getCaps(),i={supportedCompressionFormats:{etc1:!!q.etc1,s3tc:!!q.s3tc,pvrtc:!!q.pvrtc,etc2:!!q.etc2,astc:!!q.astc,bc7:!!q.bptc}};B(N,i).then((N=>{const V=N.fileInfo.images[0].levels.length>1&&U.generateMipMaps;x(U,N),U.getEngine()._setCubeMapTextureParams(U,V),U.isReady=!0,U.onLoadedObservable.notifyObservers(U),U.onLoadedObservable.clear(),A&&A()})).catch((N=>{t.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.isReady=!0,n&&n(N)}))}loadData(N,U,V){const A=U.getEngine().getCaps(),n={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};B(N,n).then((N=>{const A=N.fileInfo.images[0].levels[0],t=N.fileInfo.images[0].levels.length>1&&U.generateMipMaps;V(A.width,A.height,t,-1!==N.format,(()=>{x(U,N)}))})).catch((N=>{t.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),t.Tools.Warn(`Failed to transcode Basis file: ${N}`),V(0,0,!1,!1,(()=>{}),!0)}))}}}}]);