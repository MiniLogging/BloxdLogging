"use strict";(self.fyqbdzs5tyo=self.fyqbdzs5tyo||[]).push([[47],{13651:(V,I,A)=>{A.r(I),A.d(I,{_BasisTextureLoader:()=>W});var B,F=A(11052),E=A(11207),Y=A(11167);function H(){const V=0,I=1,A=2,B=3,F=6,E=8,Y=9,H=10,c=14;let b=null;function X(V,I,A,B,F){const E=V.getImageTranscodedSizeInBytes(I,A,B);let Y=new Uint8Array(E);if(!V.transcodeImage(Y,I,A,B,1,0))return null;if(F){Y=function(V,I,A,B){const F=new Uint16Array(4),E=new Uint16Array(A*B),Y=A/4,H=B/4;for(let c=0;c<H;c++)for(let B=0;B<Y;B++){const H=I+8*(c*Y+B);F[0]=V[H]|V[H+1]<<8,F[1]=V[H+2]|V[H+3]<<8,F[2]=(2*(31&F[0])+1*(31&F[1]))/3|(2*(2016&F[0])+1*(2016&F[1]))/3&2016|(2*(63488&F[0])+1*(63488&F[1]))/3&63488,F[3]=(2*(31&F[1])+1*(31&F[0]))/3|(2*(2016&F[1])+1*(2016&F[0]))/3&2016|(2*(63488&F[1])+1*(63488&F[0]))/3&63488;for(let I=0;I<4;I++){const Y=V[H+4+I];let b=(4*c+I)*A+4*B;E[b++]=F[3&Y],E[b++]=F[Y>>2&3],E[b++]=F[Y>>4&3],E[b++]=F[Y>>6&3]}}return E}(Y,0,V.getImageWidth(I,A)+3&-4,V.getImageHeight(I,A)+3&-4)}return Y}onmessage=P=>{if("init"===P.data.action){if(P.data.url)try{importScripts(P.data.url)}catch(J){postMessage({action:"error",error:J})}b||(b=BASIS({wasmBinary:P.data.wasmBinary})),null!==b&&b.then((V=>{BASIS=V,V.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===P.data.action){const b=P.data.config,J=P.data.imageData,G=new BASIS.BasisFile(J),w=function(V){const I=V.getHasAlpha(),A=V.getNumImages(),B=[];for(let F=0;F<A;F++){const I={levels:[]},A=V.getNumLevels(F);for(let B=0;B<A;B++){const A={width:V.getImageWidth(F,B),height:V.getImageHeight(F,B)};I.levels.push(A)}B.push(I)}return{BH:I,images:B}}(G);let t=P.data.ignoreSupportedFormats?null:function(b,X){let P=null;b.supportedCompressionFormats&&(P=b.supportedCompressionFormats.astc?H:b.supportedCompressionFormats.bc7?F:b.supportedCompressionFormats.s3tc?X.BH?B:A:b.supportedCompressionFormats.pvrtc?X.BH?Y:E:b.supportedCompressionFormats.etc2?I:b.supportedCompressionFormats.etc1?V:c);return P}(P.data.config,w),u=!1;null===t&&(u=!0,t=w.BH?B:A);let W=!0;G.startTranscoding()||(W=!1);const g=[];for(let V=0;V<w.images.length&&W;V++){const I=w.images[V];if(void 0===b.loadSingleImage||b.loadSingleImage===V){let A=I.levels.length;!1===b.loadMipmapLevels&&(A=1);for(let B=0;B<A;B++){const A=I.levels[B],F=X(G,V,B,t,u);if(!F){W=!1;break}A.transcodedPixels=F,g.push(A.transcodedPixels.buffer)}}}G.close(),G.delete(),u&&(t=-1),W?postMessage({action:"transcode",success:W,id:P.data.id,fileInfo:w,format:t},g):postMessage({action:"transcode",success:W,id:P.data.id})}}}!function(V){V[V.cTFETC1=0]="cTFETC1",V[V.cTFETC2=1]="cTFETC2",V[V.cTFBC1=2]="cTFBC1",V[V.cTFBC3=3]="cTFBC3",V[V.cTFBC4=4]="cTFBC4",V[V.cTFBC5=5]="cTFBC5",V[V.cTFBC7=6]="cTFBC7",V[V.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",V[V.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",V[V.cTFASTC_4x4=10]="cTFASTC_4x4",V[V.cTFATC_RGB=11]="cTFATC_RGB",V[V.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",V[V.cTFRGBA32=13]="cTFRGBA32",V[V.cTFRGB565=14]="cTFRGB565",V[V.cTFBGR565=15]="cTFBGR565",V[V.cTFRGBA4444=16]="cTFRGBA4444",V[V.cTFFXT1_RGB=17]="cTFFXT1_RGB",V[V.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",V[V.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",V[V.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",V[V.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(B||(B={}));const c={JSModuleURL:`${F.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${F.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let b=null,X=null,P=0;const J=async()=>(b||(b=new Promise(((V,I)=>{X?V(X):F.Tools.LoadFileAsync(F.Tools.GetBabylonScriptURL(c.WasmModuleURL)).then((A=>{if("function"!==typeof URL)return I("Basis transcoder requires an environment with a URL constructor");const B=URL.createObjectURL(new Blob([`(${H})()`],{type:"application/javascript"}));X=new Worker(B),async function(V,I,A){return await new Promise(((B,E)=>{const Y=I=>{"init"===I.data.action?(V.removeEventListener("message",Y),B(V)):"error"===I.data.action&&E(I.data.error||"error initializing worker")};V.addEventListener("message",Y),V.postMessage({action:"init",url:A?F.Tools.GetBabylonScriptURL(A):void 0,wasmBinary:I},[I])}))}(X,A,c.JSModuleURL).then(V,I)})).catch(I)}))),await b),G=async(V,I)=>{const A=V instanceof ArrayBuffer?new Uint8Array(V):V;return await new Promise(((V,B)=>{J().then((()=>{const F=P++,E=I=>{"transcode"===I.data.action&&I.data.id===F&&(X.removeEventListener("message",E),I.data.success?V(I.data):B("Transcode is not supported on this device"))};X.addEventListener("message",E);const Y=new Uint8Array(A.byteLength);Y.set(new Uint8Array(A.buffer,A.byteOffset,A.byteLength)),X.postMessage({action:"transcode",id:F,imageData:Y,config:I,ignoreSupportedFormats:false},[Y.buffer])}),(V=>{B(V)}))}))},w=(V,I)=>{var A;let B=null===(A=I._gl)||void 0===A?void 0:A.TEXTURE_2D;var F;V.isCube&&(B=null===(F=I._gl)||void 0===F?void 0:F.TEXTURE_CUBE_MAP);I._bindTextureDirectly(B,V,!0)},t=(V,I)=>{const A=V.getEngine();for(let H=0;H<I.fileInfo.images.length;H++){const c=I.fileInfo.images[H].levels[0];if(V._invertVScale=V.invertY,-1===I.format||I.format===B.cTFRGB565)if(V.type=10,V.format=4,!A._features.basisNeedsPOT||Math.log2(c.width)%1===0&&Math.log2(c.height)%1===0)V._invertVScale=!V.invertY,V.width=c.width+3&-4,V.height=c.height+3&-4,V.samplingMode=2,w(V,A),A._uploadDataToTextureDirectly(V,new Uint16Array(c.transcodedPixels.buffer),H,0,4,!0);else{const I=new Y.d(A,2);V._invertVScale=V.invertY,I.type=10,I.format=4,I.width=c.width+3&-4,I.height=c.height+3&-4,w(I,A),A._uploadDataToTextureDirectly(I,new Uint16Array(c.transcodedPixels.buffer),H,0,4,!0),A._rescaleTexture(I,V,A.scenes[0],A._getInternalFormat(4),(()=>{A._releaseTexture(I),w(V,A)}))}else{V.width=c.width,V.height=c.height,V.generateMipMaps=I.fileInfo.images[H].levels.length>1;const B=u.GetInternalFormatFromBasisFormat(I.format,A);V.format=B,w(V,A);const Y=I.fileInfo.images[H].levels;for(let I=0;I<Y.length;I++){const F=Y[I];A._uploadCompressedDataToTextureDirectly(V,B,F.width,F.height,F.transcodedPixels,H,I)}!A._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0||(F.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),V._cachedWrapU=E.e.CLAMP_ADDRESSMODE,V._cachedWrapV=E.e.CLAMP_ADDRESSMODE)}}},u={JSModuleURL:c.JSModuleURL,WasmModuleURL:c.WasmModuleURL,GetInternalFormatFromBasisFormat:(V,I)=>{let A;switch(V){case B.cTFETC1:A=36196;break;case B.cTFBC1:A=33776;break;case B.cTFBC4:A=33779;break;case B.cTFASTC_4x4:A=37808;break;case B.cTFETC2:A=37496;break;case B.cTFBC7:A=36492}if(void 0===A)throw"The chosen Basis transcoder format is not currently supported";return A},TranscodeAsync:G,LoadTextureFromTranscodeResult:t};Object.defineProperty(u,"JSModuleURL",{get:function(){return c.JSModuleURL},set:function(V){c.JSModuleURL=V}}),Object.defineProperty(u,"WasmModuleURL",{get:function(){return c.WasmModuleURL},set:function(V){c.WasmModuleURL=V}});class W{constructor(){this.supportCascades=!1}loadCubeData(V,I,A,B,E){if(Array.isArray(V))return;const Y=I.getEngine().getCaps(),H={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};G(V,H).then((V=>{const A=V.fileInfo.images[0].levels.length>1&&I.generateMipMaps;t(I,V),I.getEngine()._setCubeMapTextureParams(I,A),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),B&&B()})).catch((V=>{F.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.isReady=!0,E&&E(V)}))}loadData(V,I,A){const B=I.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};G(V,E).then((V=>{const B=V.fileInfo.images[0].levels[0],F=V.fileInfo.images[0].levels.length>1&&I.generateMipMaps;A(B.width,B.height,F,-1!==V.format,(()=>{t(I,V)}))})).catch((V=>{F.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),F.Tools.Warn(`Failed to transcode Basis file: ${V}`),A(0,0,!1,!1,(()=>{}),!0)}))}}}}]);