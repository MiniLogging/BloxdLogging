"use strict";(self["9d4d30r2sf"]=self["9d4d30r2sf"]||[]).push([[47],{14978:(o,v,V)=>{V.r(v),V.d(v,{_BasisTextureLoader:()=>R});var g,E=V(12291),I=V(12471),Q=V(12418);function U(){const o=0,v=1,V=2,g=3,E=6,I=8,Q=9,U=10,n=14;let O=null;function h(o,v,V,g,E){const I=o.getImageTranscodedSizeInBytes(v,V,g);let Q=new Uint8Array(I);if(!o.transcodeImage(Q,v,V,g,1,0))return null;if(E){Q=function(o,v,V,g){const E=new Uint16Array(4),I=new Uint16Array(V*g),Q=V/4,U=g/4;for(let n=0;n<U;n++)for(let g=0;g<Q;g++){const U=v+8*(n*Q+g);E[0]=o[U]|o[U+1]<<8,E[1]=o[U+2]|o[U+3]<<8,E[2]=(2*(31&E[0])+1*(31&E[1]))/3|(2*(2016&E[0])+1*(2016&E[1]))/3&2016|(2*(63488&E[0])+1*(63488&E[1]))/3&63488,E[3]=(2*(31&E[1])+1*(31&E[0]))/3|(2*(2016&E[1])+1*(2016&E[0]))/3&2016|(2*(63488&E[1])+1*(63488&E[0]))/3&63488;for(let v=0;v<4;v++){const Q=o[U+4+v];let O=(4*n+v)*V+4*g;I[O++]=E[3&Q],I[O++]=E[Q>>2&3],I[O++]=E[Q>>4&3],I[O++]=E[Q>>6&3]}}return I}(Q,0,o.getImageWidth(v,V)+3&-4,o.getImageHeight(v,V)+3&-4)}return Q}onmessage=x=>{if("init"===x.data.action){if(x.data.url)try{importScripts(x.data.url)}catch(f){postMessage({action:"error",error:f})}O||(O=BASIS({wasmBinary:x.data.wasmBinary})),null!==O&&O.then((o=>{BASIS=o,o.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===x.data.action){const O=x.data.config,f=x.data.imageData,l=new BASIS.BasisFile(f),S=function(o){const v=o.getHasAlpha(),V=o.getNumImages(),g=[];for(let E=0;E<V;E++){const v={levels:[]},V=o.getNumLevels(E);for(let g=0;g<V;g++){const V={width:o.getImageWidth(E,g),height:o.getImageHeight(E,g)};v.levels.push(V)}g.push(v)}return{Kg:v,images:g}}(l);let T=x.data.ignoreSupportedFormats?null:function(O,h){let x=null;O.supportedCompressionFormats&&(x=O.supportedCompressionFormats.astc?U:O.supportedCompressionFormats.bc7?E:O.supportedCompressionFormats.s3tc?h.Kg?g:V:O.supportedCompressionFormats.pvrtc?h.Kg?Q:I:O.supportedCompressionFormats.etc2?v:O.supportedCompressionFormats.etc1?o:n);return x}(x.data.config,S),c=!1;null===T&&(c=!0,T=S.Kg?g:V);let R=!0;l.startTranscoding()||(R=!1);const j=[];for(let o=0;o<S.images.length&&R;o++){const v=S.images[o];if(void 0===O.loadSingleImage||O.loadSingleImage===o){let V=v.levels.length;!1===O.loadMipmapLevels&&(V=1);for(let g=0;g<V;g++){const V=v.levels[g],E=h(l,o,g,T,c);if(!E){R=!1;break}V.transcodedPixels=E,j.push(V.transcodedPixels.buffer)}}}l.close(),l.delete(),c&&(T=-1),R?postMessage({action:"transcode",success:R,id:x.data.id,fileInfo:S,format:T},j):postMessage({action:"transcode",success:R,id:x.data.id})}}}!function(o){o[o.cTFETC1=0]="cTFETC1",o[o.cTFETC2=1]="cTFETC2",o[o.cTFBC1=2]="cTFBC1",o[o.cTFBC3=3]="cTFBC3",o[o.cTFBC4=4]="cTFBC4",o[o.cTFBC5=5]="cTFBC5",o[o.cTFBC7=6]="cTFBC7",o[o.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",o[o.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",o[o.cTFASTC_4x4=10]="cTFASTC_4x4",o[o.cTFATC_RGB=11]="cTFATC_RGB",o[o.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",o[o.cTFRGBA32=13]="cTFRGBA32",o[o.cTFRGB565=14]="cTFRGB565",o[o.cTFBGR565=15]="cTFBGR565",o[o.cTFRGBA4444=16]="cTFRGBA4444",o[o.cTFFXT1_RGB=17]="cTFFXT1_RGB",o[o.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",o[o.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",o[o.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",o[o.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(g||(g={}));const n={JSModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let O=null,h=null,x=0;const f=async()=>(O||(O=new Promise(((o,v)=>{h?o(h):E.Tools.LoadFileAsync(E.Tools.GetBabylonScriptURL(n.WasmModuleURL)).then((V=>{if("function"!==typeof URL)return v("Basis transcoder requires an environment with a URL constructor");const g=URL.createObjectURL(new Blob([`(${U})()`],{type:"application/javascript"}));h=new Worker(g),async function(o,v,V){return await new Promise(((g,I)=>{const Q=v=>{"init"===v.data.action?(o.removeEventListener("message",Q),g(o)):"error"===v.data.action&&I(v.data.error||"error initializing worker")};o.addEventListener("message",Q),o.postMessage({action:"init",url:V?E.Tools.GetBabylonScriptURL(V):void 0,wasmBinary:v},[v])}))}(h,V,n.JSModuleURL).then(o,v)})).catch(v)}))),await O),l=async(o,v)=>{const V=o instanceof ArrayBuffer?new Uint8Array(o):o;return await new Promise(((o,g)=>{f().then((()=>{const E=x++,I=v=>{"transcode"===v.data.action&&v.data.id===E&&(h.removeEventListener("message",I),v.data.success?o(v.data):g("Transcode is not supported on this device"))};h.addEventListener("message",I);const Q=new Uint8Array(V.byteLength);Q.set(new Uint8Array(V.buffer,V.byteOffset,V.byteLength)),h.postMessage({action:"transcode",id:E,imageData:Q,config:v,ignoreSupportedFormats:false},[Q.buffer])}),(o=>{g(o)}))}))},S=(o,v)=>{var V;let g=null===(V=v._gl)||void 0===V?void 0:V.TEXTURE_2D;var E;o.isCube&&(g=null===(E=v._gl)||void 0===E?void 0:E.TEXTURE_CUBE_MAP);v._bindTextureDirectly(g,o,!0)},T=(o,v)=>{const V=o.getEngine();for(let U=0;U<v.fileInfo.images.length;U++){const n=v.fileInfo.images[U].levels[0];if(o._invertVScale=o.invertY,-1===v.format||v.format===g.cTFRGB565)if(o.type=10,o.format=4,!V._features.basisNeedsPOT||Math.log2(n.width)%1===0&&Math.log2(n.height)%1===0)o._invertVScale=!o.invertY,o.width=n.width+3&-4,o.height=n.height+3&-4,o.samplingMode=2,S(o,V),V._uploadDataToTextureDirectly(o,new Uint16Array(n.transcodedPixels.buffer),U,0,4,!0);else{const v=new Q.c(V,2);o._invertVScale=o.invertY,v.type=10,v.format=4,v.width=n.width+3&-4,v.height=n.height+3&-4,S(v,V),V._uploadDataToTextureDirectly(v,new Uint16Array(n.transcodedPixels.buffer),U,0,4,!0),V._rescaleTexture(v,o,V.scenes[0],V._getInternalFormat(4),(()=>{V._releaseTexture(v),S(o,V)}))}else{o.width=n.width,o.height=n.height,o.generateMipMaps=v.fileInfo.images[U].levels.length>1;const g=c.GetInternalFormatFromBasisFormat(v.format,V);o.format=g,S(o,V);const Q=v.fileInfo.images[U].levels;for(let v=0;v<Q.length;v++){const E=Q[v];V._uploadCompressedDataToTextureDirectly(o,g,E.width,E.height,E.transcodedPixels,U,v)}!V._features.basisNeedsPOT||Math.log2(o.width)%1===0&&Math.log2(o.height)%1===0||(E.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),o._cachedWrapU=I.e.CLAMP_ADDRESSMODE,o._cachedWrapV=I.e.CLAMP_ADDRESSMODE)}}},c={JSModuleURL:n.JSModuleURL,WasmModuleURL:n.WasmModuleURL,GetInternalFormatFromBasisFormat:(o,v)=>{let V;switch(o){case g.cTFETC1:V=36196;break;case g.cTFBC1:V=33776;break;case g.cTFBC4:V=33779;break;case g.cTFASTC_4x4:V=37808;break;case g.cTFETC2:V=37496;break;case g.cTFBC7:V=36492}if(void 0===V)throw"The chosen Basis transcoder format is not currently supported";return V},TranscodeAsync:l,LoadTextureFromTranscodeResult:T};Object.defineProperty(c,"JSModuleURL",{get:function(){return n.JSModuleURL},set:function(o){n.JSModuleURL=o}}),Object.defineProperty(c,"WasmModuleURL",{get:function(){return n.WasmModuleURL},set:function(o){n.WasmModuleURL=o}});class R{constructor(){this.supportCascades=!1}loadCubeData(o,v,V,g,I){if(Array.isArray(o))return;const Q=v.getEngine().getCaps(),U={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};l(o,U).then((o=>{const V=o.fileInfo.images[0].levels.length>1&&v.generateMipMaps;T(v,o),v.getEngine()._setCubeMapTextureParams(v,V),v.isReady=!0,v.onLoadedObservable.notifyObservers(v),v.onLoadedObservable.clear(),g&&g()})).catch((o=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),v.isReady=!0,I&&I(o)}))}loadData(o,v,V){const g=v.getEngine().getCaps(),I={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};l(o,I).then((o=>{const g=o.fileInfo.images[0].levels[0],E=o.fileInfo.images[0].levels.length>1&&v.generateMipMaps;V(g.width,g.height,E,-1!==o.format,(()=>{T(v,o)}))})).catch((o=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),E.Tools.Warn(`Failed to transcode Basis file: ${o}`),V(0,0,!1,!1,(()=>{}),!0)}))}}}}]);