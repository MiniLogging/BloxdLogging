"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[47],{13808:(B,E,v)=>{v.r(E),v.d(E,{_BasisTextureLoader:()=>m});var z,o=v(11193),q=v(11361),c=v(11323);function S(){const B=0,E=1,v=2,z=3,o=6,q=8,c=9,S=10,x=14;let D=null;function h(B,E,v,z,o){const q=B.getImageTranscodedSizeInBytes(E,v,z);let c=new Uint8Array(q);if(!B.transcodeImage(c,E,v,z,1,0))return null;if(o){c=function(B,E,v,z){const o=new Uint16Array(4),q=new Uint16Array(v*z),c=v/4,S=z/4;for(let x=0;x<S;x++)for(let z=0;z<c;z++){const S=E+8*(x*c+z);o[0]=B[S]|B[S+1]<<8,o[1]=B[S+2]|B[S+3]<<8,o[2]=(2*(31&o[0])+1*(31&o[1]))/3|(2*(2016&o[0])+1*(2016&o[1]))/3&2016|(2*(63488&o[0])+1*(63488&o[1]))/3&63488,o[3]=(2*(31&o[1])+1*(31&o[0]))/3|(2*(2016&o[1])+1*(2016&o[0]))/3&2016|(2*(63488&o[1])+1*(63488&o[0]))/3&63488;for(let E=0;E<4;E++){const c=B[S+4+E];let D=(4*x+E)*v+4*z;q[D++]=o[3&c],q[D++]=o[c>>2&3],q[D++]=o[c>>4&3],q[D++]=o[c>>6&3]}}return q}(c,0,B.getImageWidth(E,v)+3&-4,B.getImageHeight(E,v)+3&-4)}return c}onmessage=y=>{if("init"===y.data.action){if(y.data.url)try{importScripts(y.data.url)}catch(Q){postMessage({action:"error",error:Q})}D||(D=BASIS({wasmBinary:y.data.wasmBinary})),null!==D&&D.then((B=>{BASIS=B,B.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===y.data.action){const D=y.data.config,Q=y.data.imageData,P=new BASIS.BasisFile(Q),G=function(B){const E=B.getHasAlpha(),v=B.getNumImages(),z=[];for(let o=0;o<v;o++){const E={levels:[]},v=B.getNumLevels(o);for(let z=0;z<v;z++){const v={width:B.getImageWidth(o,z),height:B.getImageHeight(o,z)};E.levels.push(v)}z.push(E)}return{Sc:E,images:z}}(P);let Y=y.data.ignoreSupportedFormats?null:function(D,h){let y=null;D.supportedCompressionFormats&&(y=D.supportedCompressionFormats.astc?S:D.supportedCompressionFormats.bc7?o:D.supportedCompressionFormats.s3tc?h.Sc?z:v:D.supportedCompressionFormats.pvrtc?h.Sc?c:q:D.supportedCompressionFormats.etc2?E:D.supportedCompressionFormats.etc1?B:x);return y}(y.data.config,G),a=!1;null===Y&&(a=!0,Y=G.Sc?z:v);let m=!0;P.startTranscoding()||(m=!1);const g=[];for(let B=0;B<G.images.length&&m;B++){const E=G.images[B];if(void 0===D.loadSingleImage||D.loadSingleImage===B){let v=E.levels.length;!1===D.loadMipmapLevels&&(v=1);for(let z=0;z<v;z++){const v=E.levels[z],o=h(P,B,z,Y,a);if(!o){m=!1;break}v.transcodedPixels=o,g.push(v.transcodedPixels.buffer)}}}P.close(),P.delete(),a&&(Y=-1),m?postMessage({action:"transcode",success:m,id:y.data.id,fileInfo:G,format:Y},g):postMessage({action:"transcode",success:m,id:y.data.id})}}}!function(B){B[B.cTFETC1=0]="cTFETC1",B[B.cTFETC2=1]="cTFETC2",B[B.cTFBC1=2]="cTFBC1",B[B.cTFBC3=3]="cTFBC3",B[B.cTFBC4=4]="cTFBC4",B[B.cTFBC5=5]="cTFBC5",B[B.cTFBC7=6]="cTFBC7",B[B.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",B[B.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",B[B.cTFASTC_4x4=10]="cTFASTC_4x4",B[B.cTFATC_RGB=11]="cTFATC_RGB",B[B.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",B[B.cTFRGBA32=13]="cTFRGBA32",B[B.cTFRGB565=14]="cTFRGB565",B[B.cTFBGR565=15]="cTFBGR565",B[B.cTFRGBA4444=16]="cTFRGBA4444",B[B.cTFFXT1_RGB=17]="cTFFXT1_RGB",B[B.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",B[B.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",B[B.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",B[B.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(z||(z={}));const x={JSModuleURL:`${o.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${o.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let D=null,h=null,y=0;const Q=async()=>(D||(D=new Promise(((B,E)=>{h?B(h):o.Tools.LoadFileAsync(o.Tools.GetBabylonScriptURL(x.WasmModuleURL)).then((v=>{if("function"!==typeof URL)return E("Basis transcoder requires an environment with a URL constructor");const z=URL.createObjectURL(new Blob([`(${S})()`],{type:"application/javascript"}));h=new Worker(z),async function(B,E,v){return await new Promise(((z,q)=>{const c=E=>{"init"===E.data.action?(B.removeEventListener("message",c),z(B)):"error"===E.data.action&&q(E.data.error||"error initializing worker")};B.addEventListener("message",c),B.postMessage({action:"init",url:v?o.Tools.GetBabylonScriptURL(v):void 0,wasmBinary:E},[E])}))}(h,v,x.JSModuleURL).then(B,E)})).catch(E)}))),await D),P=async(B,E)=>{const v=B instanceof ArrayBuffer?new Uint8Array(B):B;return await new Promise(((B,z)=>{Q().then((()=>{const o=y++,q=E=>{"transcode"===E.data.action&&E.data.id===o&&(h.removeEventListener("message",q),E.data.success?B(E.data):z("Transcode is not supported on this device"))};h.addEventListener("message",q);const c=new Uint8Array(v.byteLength);c.set(new Uint8Array(v.buffer,v.byteOffset,v.byteLength)),h.postMessage({action:"transcode",id:o,imageData:c,config:E,ignoreSupportedFormats:false},[c.buffer])}),(B=>{z(B)}))}))},G=(B,E)=>{var v;let z=null===(v=E._gl)||void 0===v?void 0:v.TEXTURE_2D;var o;B.isCube&&(z=null===(o=E._gl)||void 0===o?void 0:o.TEXTURE_CUBE_MAP);E._bindTextureDirectly(z,B,!0)},Y=(B,E)=>{const v=B.getEngine();for(let S=0;S<E.fileInfo.images.length;S++){const x=E.fileInfo.images[S].levels[0];if(B._invertVScale=B.invertY,-1===E.format||E.format===z.cTFRGB565)if(B.type=10,B.format=4,!v._features.basisNeedsPOT||Math.log2(x.width)%1===0&&Math.log2(x.height)%1===0)B._invertVScale=!B.invertY,B.width=x.width+3&-4,B.height=x.height+3&-4,B.samplingMode=2,G(B,v),v._uploadDataToTextureDirectly(B,new Uint16Array(x.transcodedPixels.buffer),S,0,4,!0);else{const E=new c.b(v,2);B._invertVScale=B.invertY,E.type=10,E.format=4,E.width=x.width+3&-4,E.height=x.height+3&-4,G(E,v),v._uploadDataToTextureDirectly(E,new Uint16Array(x.transcodedPixels.buffer),S,0,4,!0),v._rescaleTexture(E,B,v.scenes[0],v._getInternalFormat(4),(()=>{v._releaseTexture(E),G(B,v)}))}else{B.width=x.width,B.height=x.height,B.generateMipMaps=E.fileInfo.images[S].levels.length>1;const z=a.GetInternalFormatFromBasisFormat(E.format,v);B.format=z,G(B,v);const c=E.fileInfo.images[S].levels;for(let E=0;E<c.length;E++){const o=c[E];v._uploadCompressedDataToTextureDirectly(B,z,o.width,o.height,o.transcodedPixels,S,E)}!v._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0||(o.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),B._cachedWrapU=q.b.CLAMP_ADDRESSMODE,B._cachedWrapV=q.b.CLAMP_ADDRESSMODE)}}},a={JSModuleURL:x.JSModuleURL,WasmModuleURL:x.WasmModuleURL,GetInternalFormatFromBasisFormat:(B,E)=>{let v;switch(B){case z.cTFETC1:v=36196;break;case z.cTFBC1:v=33776;break;case z.cTFBC4:v=33779;break;case z.cTFASTC_4x4:v=37808;break;case z.cTFETC2:v=37496;break;case z.cTFBC7:v=36492}if(void 0===v)throw"The chosen Basis transcoder format is not currently supported";return v},TranscodeAsync:P,LoadTextureFromTranscodeResult:Y};Object.defineProperty(a,"JSModuleURL",{get:function(){return x.JSModuleURL},set:function(B){x.JSModuleURL=B}}),Object.defineProperty(a,"WasmModuleURL",{get:function(){return x.WasmModuleURL},set:function(B){x.WasmModuleURL=B}});class m{constructor(){this.supportCascades=!1}loadCubeData(B,E,v,z,q){if(Array.isArray(B))return;const c=E.getEngine().getCaps(),S={supportedCompressionFormats:{etc1:!!c.etc1,s3tc:!!c.s3tc,pvrtc:!!c.pvrtc,etc2:!!c.etc2,astc:!!c.astc,bc7:!!c.bptc}};P(B,S).then((B=>{const v=B.fileInfo.images[0].levels.length>1&&E.generateMipMaps;Y(E,B),E.getEngine()._setCubeMapTextureParams(E,v),E.isReady=!0,E.onLoadedObservable.notifyObservers(E),E.onLoadedObservable.clear(),z&&z()})).catch((B=>{o.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),E.isReady=!0,q&&q(B)}))}loadData(B,E,v){const z=E.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};P(B,q).then((B=>{const z=B.fileInfo.images[0].levels[0],o=B.fileInfo.images[0].levels.length>1&&E.generateMipMaps;v(z.width,z.height,o,-1!==B.format,(()=>{Y(E,B)}))})).catch((B=>{o.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),o.Tools.Warn(`Failed to transcode Basis file: ${B}`),v(0,0,!1,!1,(()=>{}),!0)}))}}}}]);