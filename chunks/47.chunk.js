"use strict";(self.zjjkhojdx1=self.zjjkhojdx1||[]).push([[47],{13656:(k,h,o)=>{o.r(h),o.d(h,{_BasisTextureLoader:()=>f});var x,I=o(11078),q=o(11223),Y=o(11180);function J(){const k=0,h=1,o=2,x=3,I=6,q=8,Y=9,J=10,G=14;let l=null;function A(k,h,o,x,I){const q=k.getImageTranscodedSizeInBytes(h,o,x);let Y=new Uint8Array(q);if(!k.transcodeImage(Y,h,o,x,1,0))return null;if(I){Y=function(k,h,o,x){const I=new Uint16Array(4),q=new Uint16Array(o*x),Y=o/4,J=x/4;for(let G=0;G<J;G++)for(let x=0;x<Y;x++){const J=h+8*(G*Y+x);I[0]=k[J]|k[J+1]<<8,I[1]=k[J+2]|k[J+3]<<8,I[2]=(2*(31&I[0])+1*(31&I[1]))/3|(2*(2016&I[0])+1*(2016&I[1]))/3&2016|(2*(63488&I[0])+1*(63488&I[1]))/3&63488,I[3]=(2*(31&I[1])+1*(31&I[0]))/3|(2*(2016&I[1])+1*(2016&I[0]))/3&2016|(2*(63488&I[1])+1*(63488&I[0]))/3&63488;for(let h=0;h<4;h++){const Y=k[J+4+h];let l=(4*G+h)*o+4*x;q[l++]=I[3&Y],q[l++]=I[Y>>2&3],q[l++]=I[Y>>4&3],q[l++]=I[Y>>6&3]}}return q}(Y,0,k.getImageWidth(h,o)+3&-4,k.getImageHeight(h,o)+3&-4)}return Y}onmessage=K=>{if("init"===K.data.action){if(K.data.url)try{importScripts(K.data.url)}catch(a){postMessage({action:"error",error:a})}l||(l=BASIS({wasmBinary:K.data.wasmBinary})),null!==l&&l.then((k=>{BASIS=k,k.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===K.data.action){const l=K.data.config,a=K.data.imageData,N=new BASIS.BasisFile(a),X=function(k){const h=k.getHasAlpha(),o=k.getNumImages(),x=[];for(let I=0;I<o;I++){const h={levels:[]},o=k.getNumLevels(I);for(let x=0;x<o;x++){const o={width:k.getImageWidth(I,x),height:k.getImageHeight(I,x)};h.levels.push(o)}x.push(h)}return{Sh:h,images:x}}(N);let c=K.data.ignoreSupportedFormats?null:function(l,A){let K=null;l.supportedCompressionFormats&&(K=l.supportedCompressionFormats.astc?J:l.supportedCompressionFormats.bc7?I:l.supportedCompressionFormats.s3tc?A.Sh?x:o:l.supportedCompressionFormats.pvrtc?A.Sh?Y:q:l.supportedCompressionFormats.etc2?h:l.supportedCompressionFormats.etc1?k:G);return K}(K.data.config,X),W=!1;null===c&&(W=!0,c=X.Sh?x:o);let f=!0;N.startTranscoding()||(f=!1);const M=[];for(let k=0;k<X.images.length&&f;k++){const h=X.images[k];if(void 0===l.loadSingleImage||l.loadSingleImage===k){let o=h.levels.length;!1===l.loadMipmapLevels&&(o=1);for(let x=0;x<o;x++){const o=h.levels[x],I=A(N,k,x,c,W);if(!I){f=!1;break}o.transcodedPixels=I,M.push(o.transcodedPixels.buffer)}}}N.close(),N.delete(),W&&(c=-1),f?postMessage({action:"transcode",success:f,id:K.data.id,fileInfo:X,format:c},M):postMessage({action:"transcode",success:f,id:K.data.id})}}}!function(k){k[k.cTFETC1=0]="cTFETC1",k[k.cTFETC2=1]="cTFETC2",k[k.cTFBC1=2]="cTFBC1",k[k.cTFBC3=3]="cTFBC3",k[k.cTFBC4=4]="cTFBC4",k[k.cTFBC5=5]="cTFBC5",k[k.cTFBC7=6]="cTFBC7",k[k.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",k[k.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",k[k.cTFASTC_4x4=10]="cTFASTC_4x4",k[k.cTFATC_RGB=11]="cTFATC_RGB",k[k.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",k[k.cTFRGBA32=13]="cTFRGBA32",k[k.cTFRGB565=14]="cTFRGB565",k[k.cTFBGR565=15]="cTFBGR565",k[k.cTFRGBA4444=16]="cTFRGBA4444",k[k.cTFFXT1_RGB=17]="cTFFXT1_RGB",k[k.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",k[k.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",k[k.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",k[k.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(x||(x={}));const G={JSModuleURL:`${I.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${I.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let l=null,A=null,K=0;const a=async()=>(l||(l=new Promise(((k,h)=>{A?k(A):I.Tools.LoadFileAsync(I.Tools.GetBabylonScriptURL(G.WasmModuleURL)).then((o=>{if("function"!==typeof URL)return h("Basis transcoder requires an environment with a URL constructor");const x=URL.createObjectURL(new Blob([`(${J})()`],{type:"application/javascript"}));A=new Worker(x),async function(k,h,o){return await new Promise(((x,q)=>{const Y=h=>{"init"===h.data.action?(k.removeEventListener("message",Y),x(k)):"error"===h.data.action&&q(h.data.error||"error initializing worker")};k.addEventListener("message",Y),k.postMessage({action:"init",url:o?I.Tools.GetBabylonScriptURL(o):void 0,wasmBinary:h},[h])}))}(A,o,G.JSModuleURL).then(k,h)})).catch(h)}))),await l),N=async(k,h)=>{const o=k instanceof ArrayBuffer?new Uint8Array(k):k;return await new Promise(((k,x)=>{a().then((()=>{const I=K++,q=h=>{"transcode"===h.data.action&&h.data.id===I&&(A.removeEventListener("message",q),h.data.success?k(h.data):x("Transcode is not supported on this device"))};A.addEventListener("message",q);const Y=new Uint8Array(o.byteLength);Y.set(new Uint8Array(o.buffer,o.byteOffset,o.byteLength)),A.postMessage({action:"transcode",id:I,imageData:Y,config:h,ignoreSupportedFormats:false},[Y.buffer])}),(k=>{x(k)}))}))},X=(k,h)=>{var o;let x=null===(o=h._gl)||void 0===o?void 0:o.TEXTURE_2D;var I;k.isCube&&(x=null===(I=h._gl)||void 0===I?void 0:I.TEXTURE_CUBE_MAP);h._bindTextureDirectly(x,k,!0)},c=(k,h)=>{const o=k.getEngine();for(let J=0;J<h.fileInfo.images.length;J++){const G=h.fileInfo.images[J].levels[0];if(k._invertVScale=k.invertY,-1===h.format||h.format===x.cTFRGB565)if(k.type=10,k.format=4,!o._features.basisNeedsPOT||Math.log2(G.width)%1===0&&Math.log2(G.height)%1===0)k._invertVScale=!k.invertY,k.width=G.width+3&-4,k.height=G.height+3&-4,k.samplingMode=2,X(k,o),o._uploadDataToTextureDirectly(k,new Uint16Array(G.transcodedPixels.buffer),J,0,4,!0);else{const h=new Y.c(o,2);k._invertVScale=k.invertY,h.type=10,h.format=4,h.width=G.width+3&-4,h.height=G.height+3&-4,X(h,o),o._uploadDataToTextureDirectly(h,new Uint16Array(G.transcodedPixels.buffer),J,0,4,!0),o._rescaleTexture(h,k,o.scenes[0],o._getInternalFormat(4),(()=>{o._releaseTexture(h),X(k,o)}))}else{k.width=G.width,k.height=G.height,k.generateMipMaps=h.fileInfo.images[J].levels.length>1;const x=W.GetInternalFormatFromBasisFormat(h.format,o);k.format=x,X(k,o);const Y=h.fileInfo.images[J].levels;for(let h=0;h<Y.length;h++){const I=Y[h];o._uploadCompressedDataToTextureDirectly(k,x,I.width,I.height,I.transcodedPixels,J,h)}!o._features.basisNeedsPOT||Math.log2(k.width)%1===0&&Math.log2(k.height)%1===0||(I.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),k._cachedWrapU=q.b.CLAMP_ADDRESSMODE,k._cachedWrapV=q.b.CLAMP_ADDRESSMODE)}}},W={JSModuleURL:G.JSModuleURL,WasmModuleURL:G.WasmModuleURL,GetInternalFormatFromBasisFormat:(k,h)=>{let o;switch(k){case x.cTFETC1:o=36196;break;case x.cTFBC1:o=33776;break;case x.cTFBC4:o=33779;break;case x.cTFASTC_4x4:o=37808;break;case x.cTFETC2:o=37496;break;case x.cTFBC7:o=36492}if(void 0===o)throw"The chosen Basis transcoder format is not currently supported";return o},TranscodeAsync:N,LoadTextureFromTranscodeResult:c};Object.defineProperty(W,"JSModuleURL",{get:function(){return G.JSModuleURL},set:function(k){G.JSModuleURL=k}}),Object.defineProperty(W,"WasmModuleURL",{get:function(){return G.WasmModuleURL},set:function(k){G.WasmModuleURL=k}});class f{constructor(){this.supportCascades=!1}loadCubeData(k,h,o,x,q){if(Array.isArray(k))return;const Y=h.getEngine().getCaps(),J={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};N(k,J).then((k=>{const o=k.fileInfo.images[0].levels.length>1&&h.generateMipMaps;c(h,k),h.getEngine()._setCubeMapTextureParams(h,o),h.isReady=!0,h.onLoadedObservable.notifyObservers(h),h.onLoadedObservable.clear(),x&&x()})).catch((k=>{I.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.isReady=!0,q&&q(k)}))}loadData(k,h,o){const x=h.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};N(k,q).then((k=>{const x=k.fileInfo.images[0].levels[0],I=k.fileInfo.images[0].levels.length>1&&h.generateMipMaps;o(x.width,x.height,I,-1!==k.format,(()=>{c(h,k)}))})).catch((k=>{I.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.Tools.Warn(`Failed to transcode Basis file: ${k}`),o(0,0,!1,!1,(()=>{}),!0)}))}}}}]);