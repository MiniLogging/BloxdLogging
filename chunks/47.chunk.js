"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[47],{13748:(H,O,S)=>{S.r(O),S.d(O,{_BasisTextureLoader:()=>y});var t,q=S(11131),p=S(11279),G=S(11239);function U(){const H=0,O=1,S=2,t=3,q=6,p=8,G=9,U=10,V=14;let w=null;function o(H,O,S,t,q){const p=H.getImageTranscodedSizeInBytes(O,S,t);let G=new Uint8Array(p);if(!H.transcodeImage(G,O,S,t,1,0))return null;if(q){G=function(H,O,S,t){const q=new Uint16Array(4),p=new Uint16Array(S*t),G=S/4,U=t/4;for(let V=0;V<U;V++)for(let t=0;t<G;t++){const U=O+8*(V*G+t);q[0]=H[U]|H[U+1]<<8,q[1]=H[U+2]|H[U+3]<<8,q[2]=(2*(31&q[0])+1*(31&q[1]))/3|(2*(2016&q[0])+1*(2016&q[1]))/3&2016|(2*(63488&q[0])+1*(63488&q[1]))/3&63488,q[3]=(2*(31&q[1])+1*(31&q[0]))/3|(2*(2016&q[1])+1*(2016&q[0]))/3&2016|(2*(63488&q[1])+1*(63488&q[0]))/3&63488;for(let O=0;O<4;O++){const G=H[U+4+O];let w=(4*V+O)*S+4*t;p[w++]=q[3&G],p[w++]=q[G>>2&3],p[w++]=q[G>>4&3],p[w++]=q[G>>6&3]}}return p}(G,0,H.getImageWidth(O,S)+3&-4,H.getImageHeight(O,S)+3&-4)}return G}onmessage=h=>{if("init"===h.data.action){if(h.data.url)try{importScripts(h.data.url)}catch(a){postMessage({action:"error",error:a})}w||(w=BASIS({wasmBinary:h.data.wasmBinary})),null!==w&&w.then((H=>{BASIS=H,H.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===h.data.action){const w=h.data.config,a=h.data.imageData,j=new BASIS.BasisFile(a),e=function(H){const O=H.getHasAlpha(),S=H.getNumImages(),t=[];for(let q=0;q<S;q++){const O={levels:[]},S=H.getNumLevels(q);for(let t=0;t<S;t++){const S={width:H.getImageWidth(q,t),height:H.getImageHeight(q,t)};O.levels.push(S)}t.push(O)}return{GU:O,images:t}}(j);let X=h.data.ignoreSupportedFormats?null:function(w,o){let h=null;w.supportedCompressionFormats&&(h=w.supportedCompressionFormats.astc?U:w.supportedCompressionFormats.bc7?q:w.supportedCompressionFormats.s3tc?o.GU?t:S:w.supportedCompressionFormats.pvrtc?o.GU?G:p:w.supportedCompressionFormats.etc2?O:w.supportedCompressionFormats.etc1?H:V);return h}(h.data.config,e),E=!1;null===X&&(E=!0,X=e.GU?t:S);let y=!0;j.startTranscoding()||(y=!1);const T=[];for(let H=0;H<e.images.length&&y;H++){const O=e.images[H];if(void 0===w.loadSingleImage||w.loadSingleImage===H){let S=O.levels.length;!1===w.loadMipmapLevels&&(S=1);for(let t=0;t<S;t++){const S=O.levels[t],q=o(j,H,t,X,E);if(!q){y=!1;break}S.transcodedPixels=q,T.push(S.transcodedPixels.buffer)}}}j.close(),j.delete(),E&&(X=-1),y?postMessage({action:"transcode",success:y,id:h.data.id,fileInfo:e,format:X},T):postMessage({action:"transcode",success:y,id:h.data.id})}}}!function(H){H[H.cTFETC1=0]="cTFETC1",H[H.cTFETC2=1]="cTFETC2",H[H.cTFBC1=2]="cTFBC1",H[H.cTFBC3=3]="cTFBC3",H[H.cTFBC4=4]="cTFBC4",H[H.cTFBC5=5]="cTFBC5",H[H.cTFBC7=6]="cTFBC7",H[H.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",H[H.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",H[H.cTFASTC_4x4=10]="cTFASTC_4x4",H[H.cTFATC_RGB=11]="cTFATC_RGB",H[H.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",H[H.cTFRGBA32=13]="cTFRGBA32",H[H.cTFRGB565=14]="cTFRGB565",H[H.cTFBGR565=15]="cTFBGR565",H[H.cTFRGBA4444=16]="cTFRGBA4444",H[H.cTFFXT1_RGB=17]="cTFFXT1_RGB",H[H.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",H[H.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",H[H.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",H[H.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(t||(t={}));const V={JSModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let w=null,o=null,h=0;const a=async()=>(w||(w=new Promise(((H,O)=>{o?H(o):q.Tools.LoadFileAsync(q.Tools.GetBabylonScriptURL(V.WasmModuleURL)).then((S=>{if("function"!==typeof URL)return O("Basis transcoder requires an environment with a URL constructor");const t=URL.createObjectURL(new Blob([`(${U})()`],{type:"application/javascript"}));o=new Worker(t),async function(H,O,S){return await new Promise(((t,p)=>{const G=O=>{"init"===O.data.action?(H.removeEventListener("message",G),t(H)):"error"===O.data.action&&p(O.data.error||"error initializing worker")};H.addEventListener("message",G),H.postMessage({action:"init",url:S?q.Tools.GetBabylonScriptURL(S):void 0,wasmBinary:O},[O])}))}(o,S,V.JSModuleURL).then(H,O)})).catch(O)}))),await w),j=async(H,O)=>{const S=H instanceof ArrayBuffer?new Uint8Array(H):H;return await new Promise(((H,t)=>{a().then((()=>{const q=h++,p=O=>{"transcode"===O.data.action&&O.data.id===q&&(o.removeEventListener("message",p),O.data.success?H(O.data):t("Transcode is not supported on this device"))};o.addEventListener("message",p);const G=new Uint8Array(S.byteLength);G.set(new Uint8Array(S.buffer,S.byteOffset,S.byteLength)),o.postMessage({action:"transcode",id:q,imageData:G,config:O,ignoreSupportedFormats:false},[G.buffer])}),(H=>{t(H)}))}))},e=(H,O)=>{var S;let t=null===(S=O._gl)||void 0===S?void 0:S.TEXTURE_2D;var q;H.isCube&&(t=null===(q=O._gl)||void 0===q?void 0:q.TEXTURE_CUBE_MAP);O._bindTextureDirectly(t,H,!0)},X=(H,O)=>{const S=H.getEngine();for(let U=0;U<O.fileInfo.images.length;U++){const V=O.fileInfo.images[U].levels[0];if(H._invertVScale=H.invertY,-1===O.format||O.format===t.cTFRGB565)if(H.type=10,H.format=4,!S._features.basisNeedsPOT||Math.log2(V.width)%1===0&&Math.log2(V.height)%1===0)H._invertVScale=!H.invertY,H.width=V.width+3&-4,H.height=V.height+3&-4,H.samplingMode=2,e(H,S),S._uploadDataToTextureDirectly(H,new Uint16Array(V.transcodedPixels.buffer),U,0,4,!0);else{const O=new G.d(S,2);H._invertVScale=H.invertY,O.type=10,O.format=4,O.width=V.width+3&-4,O.height=V.height+3&-4,e(O,S),S._uploadDataToTextureDirectly(O,new Uint16Array(V.transcodedPixels.buffer),U,0,4,!0),S._rescaleTexture(O,H,S.scenes[0],S._getInternalFormat(4),(()=>{S._releaseTexture(O),e(H,S)}))}else{H.width=V.width,H.height=V.height,H.generateMipMaps=O.fileInfo.images[U].levels.length>1;const t=E.GetInternalFormatFromBasisFormat(O.format,S);H.format=t,e(H,S);const G=O.fileInfo.images[U].levels;for(let O=0;O<G.length;O++){const q=G[O];S._uploadCompressedDataToTextureDirectly(H,t,q.width,q.height,q.transcodedPixels,U,O)}!S._features.basisNeedsPOT||Math.log2(H.width)%1===0&&Math.log2(H.height)%1===0||(q.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),H._cachedWrapU=p.b.CLAMP_ADDRESSMODE,H._cachedWrapV=p.b.CLAMP_ADDRESSMODE)}}},E={JSModuleURL:V.JSModuleURL,WasmModuleURL:V.WasmModuleURL,GetInternalFormatFromBasisFormat:(H,O)=>{let S;switch(H){case t.cTFETC1:S=36196;break;case t.cTFBC1:S=33776;break;case t.cTFBC4:S=33779;break;case t.cTFASTC_4x4:S=37808;break;case t.cTFETC2:S=37496;break;case t.cTFBC7:S=36492}if(void 0===S)throw"The chosen Basis transcoder format is not currently supported";return S},TranscodeAsync:j,LoadTextureFromTranscodeResult:X};Object.defineProperty(E,"JSModuleURL",{get:function(){return V.JSModuleURL},set:function(H){V.JSModuleURL=H}}),Object.defineProperty(E,"WasmModuleURL",{get:function(){return V.WasmModuleURL},set:function(H){V.WasmModuleURL=H}});class y{constructor(){this.supportCascades=!1}loadCubeData(H,O,S,t,p){if(Array.isArray(H))return;const G=O.getEngine().getCaps(),U={supportedCompressionFormats:{etc1:!!G.etc1,s3tc:!!G.s3tc,pvrtc:!!G.pvrtc,etc2:!!G.etc2,astc:!!G.astc,bc7:!!G.bptc}};j(H,U).then((H=>{const S=H.fileInfo.images[0].levels.length>1&&O.generateMipMaps;X(O,H),O.getEngine()._setCubeMapTextureParams(O,S),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),t&&t()})).catch((H=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.isReady=!0,p&&p(H)}))}loadData(H,O,S){const t=O.getEngine().getCaps(),p={supportedCompressionFormats:{etc1:!!t.etc1,s3tc:!!t.s3tc,pvrtc:!!t.pvrtc,etc2:!!t.etc2,astc:!!t.astc,bc7:!!t.bptc}};j(H,p).then((H=>{const t=H.fileInfo.images[0].levels[0],q=H.fileInfo.images[0].levels.length>1&&O.generateMipMaps;S(t.width,t.height,q,-1!==H.format,(()=>{X(O,H)}))})).catch((H=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.Tools.Warn(`Failed to transcode Basis file: ${H}`),S(0,0,!1,!1,(()=>{}),!0)}))}}}}]);