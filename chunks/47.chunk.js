"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[47],{15413:(Y,c,h)=>{h.r(c),h.d(c,{_BasisTextureLoader:()=>d});var C,E=h(12687),N=h(12848),Q=h(12805);function b(){const Y=0,c=1,h=2,C=3,E=6,N=8,Q=9,b=10,H=14;let w=null;function W(Y,c,h,C,E){const N=Y.getImageTranscodedSizeInBytes(c,h,C);let Q=new Uint8Array(N);if(!Y.transcodeImage(Q,c,h,C,1,0))return null;if(E){Q=function(Y,c,h,C){const E=new Uint16Array(4),N=new Uint16Array(h*C),Q=h/4,b=C/4;for(let H=0;H<b;H++)for(let C=0;C<Q;C++){const b=c+8*(H*Q+C);E[0]=Y[b]|Y[b+1]<<8,E[1]=Y[b+2]|Y[b+3]<<8,E[2]=(2*(31&E[0])+1*(31&E[1]))/3|(2*(2016&E[0])+1*(2016&E[1]))/3&2016|(2*(63488&E[0])+1*(63488&E[1]))/3&63488,E[3]=(2*(31&E[1])+1*(31&E[0]))/3|(2*(2016&E[1])+1*(2016&E[0]))/3&2016|(2*(63488&E[1])+1*(63488&E[0]))/3&63488;for(let c=0;c<4;c++){const Q=Y[b+4+c];let w=(4*H+c)*h+4*C;N[w++]=E[3&Q],N[w++]=E[Q>>2&3],N[w++]=E[Q>>4&3],N[w++]=E[Q>>6&3]}}return N}(Q,0,Y.getImageWidth(c,h)+3&-4,Y.getImageHeight(c,h)+3&-4)}return Q}onmessage=q=>{if("init"===q.data.action){if(q.data.url)try{importScripts(q.data.url)}catch(k){postMessage({action:"error",error:k})}w||(w=BASIS({wasmBinary:q.data.wasmBinary})),null!==w&&w.then((Y=>{BASIS=Y,Y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===q.data.action){const w=q.data.config,k=q.data.imageData,M=new BASIS.BasisFile(k),p=function(Y){const c=Y.getHasAlpha(),h=Y.getNumImages(),C=[];for(let E=0;E<h;E++){const c={levels:[]},h=Y.getNumLevels(E);for(let C=0;C<h;C++){const h={width:Y.getImageWidth(E,C),height:Y.getImageHeight(E,C)};c.levels.push(h)}C.push(c)}return{Zc:c,images:C}}(M);let P=q.data.ignoreSupportedFormats?null:function(w,W){let q=null;w.supportedCompressionFormats&&(q=w.supportedCompressionFormats.astc?b:w.supportedCompressionFormats.bc7?E:w.supportedCompressionFormats.s3tc?W.Zc?C:h:w.supportedCompressionFormats.pvrtc?W.Zc?Q:N:w.supportedCompressionFormats.etc2?c:w.supportedCompressionFormats.etc1?Y:H);return q}(q.data.config,p),y=!1;null===P&&(y=!0,P=p.Zc?C:h);let d=!0;M.startTranscoding()||(d=!1);const D=[];for(let Y=0;Y<p.images.length&&d;Y++){const c=p.images[Y];if(void 0===w.loadSingleImage||w.loadSingleImage===Y){let h=c.levels.length;!1===w.loadMipmapLevels&&(h=1);for(let C=0;C<h;C++){const h=c.levels[C],E=W(M,Y,C,P,y);if(!E){d=!1;break}h.transcodedPixels=E,D.push(h.transcodedPixels.buffer)}}}M.close(),M.delete(),y&&(P=-1),d?postMessage({action:"transcode",success:d,id:q.data.id,fileInfo:p,format:P},D):postMessage({action:"transcode",success:d,id:q.data.id})}}}!function(Y){Y[Y.cTFETC1=0]="cTFETC1",Y[Y.cTFETC2=1]="cTFETC2",Y[Y.cTFBC1=2]="cTFBC1",Y[Y.cTFBC3=3]="cTFBC3",Y[Y.cTFBC4=4]="cTFBC4",Y[Y.cTFBC5=5]="cTFBC5",Y[Y.cTFBC7=6]="cTFBC7",Y[Y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Y[Y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Y[Y.cTFASTC_4x4=10]="cTFASTC_4x4",Y[Y.cTFATC_RGB=11]="cTFATC_RGB",Y[Y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Y[Y.cTFRGBA32=13]="cTFRGBA32",Y[Y.cTFRGB565=14]="cTFRGB565",Y[Y.cTFBGR565=15]="cTFBGR565",Y[Y.cTFRGBA4444=16]="cTFRGBA4444",Y[Y.cTFFXT1_RGB=17]="cTFFXT1_RGB",Y[Y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Y[Y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Y[Y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Y[Y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(C||(C={}));const H={JSModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let w=null,W=null,q=0;const k=async()=>(w||(w=new Promise(((Y,c)=>{W?Y(W):E.Tools.LoadFileAsync(E.Tools.GetBabylonScriptURL(H.WasmModuleURL)).then((h=>{if("function"!==typeof URL)return c("Basis transcoder requires an environment with a URL constructor");const C=URL.createObjectURL(new Blob([`(${b})()`],{type:"application/javascript"}));W=new Worker(C),async function(Y,c,h){return await new Promise(((C,N)=>{const Q=c=>{"init"===c.data.action?(Y.removeEventListener("message",Q),C(Y)):"error"===c.data.action&&N(c.data.error||"error initializing worker")};Y.addEventListener("message",Q),Y.postMessage({action:"init",url:h?E.Tools.GetBabylonScriptURL(h):void 0,wasmBinary:c},[c])}))}(W,h,H.JSModuleURL).then(Y,c)})).catch(c)}))),await w),M=async(Y,c)=>{const h=Y instanceof ArrayBuffer?new Uint8Array(Y):Y;return await new Promise(((Y,C)=>{k().then((()=>{const E=q++,N=c=>{"transcode"===c.data.action&&c.data.id===E&&(W.removeEventListener("message",N),c.data.success?Y(c.data):C("Transcode is not supported on this device"))};W.addEventListener("message",N);const Q=new Uint8Array(h.byteLength);Q.set(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),W.postMessage({action:"transcode",id:E,imageData:Q,config:c,ignoreSupportedFormats:false},[Q.buffer])}),(Y=>{C(Y)}))}))},p=(Y,c)=>{var h;let C=null===(h=c._gl)||void 0===h?void 0:h.TEXTURE_2D;var E;Y.isCube&&(C=null===(E=c._gl)||void 0===E?void 0:E.TEXTURE_CUBE_MAP);c._bindTextureDirectly(C,Y,!0)},P=(Y,c)=>{const h=Y.getEngine();for(let b=0;b<c.fileInfo.images.length;b++){const H=c.fileInfo.images[b].levels[0];if(Y._invertVScale=Y.invertY,-1===c.format||c.format===C.cTFRGB565)if(Y.type=10,Y.format=4,!h._features.basisNeedsPOT||Math.log2(H.width)%1===0&&Math.log2(H.height)%1===0)Y._invertVScale=!Y.invertY,Y.width=H.width+3&-4,Y.height=H.height+3&-4,Y.samplingMode=2,p(Y,h),h._uploadDataToTextureDirectly(Y,new Uint16Array(H.transcodedPixels.buffer),b,0,4,!0);else{const c=new Q.c(h,2);Y._invertVScale=Y.invertY,c.type=10,c.format=4,c.width=H.width+3&-4,c.height=H.height+3&-4,p(c,h),h._uploadDataToTextureDirectly(c,new Uint16Array(H.transcodedPixels.buffer),b,0,4,!0),h._rescaleTexture(c,Y,h.scenes[0],h._getInternalFormat(4),(()=>{h._releaseTexture(c),p(Y,h)}))}else{Y.width=H.width,Y.height=H.height,Y.generateMipMaps=c.fileInfo.images[b].levels.length>1;const C=y.GetInternalFormatFromBasisFormat(c.format,h);Y.format=C,p(Y,h);const Q=c.fileInfo.images[b].levels;for(let c=0;c<Q.length;c++){const E=Q[c];h._uploadCompressedDataToTextureDirectly(Y,C,E.width,E.height,E.transcodedPixels,b,c)}!h._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0||(E.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Y._cachedWrapU=N.d.CLAMP_ADDRESSMODE,Y._cachedWrapV=N.d.CLAMP_ADDRESSMODE)}}},y={JSModuleURL:H.JSModuleURL,WasmModuleURL:H.WasmModuleURL,GetInternalFormatFromBasisFormat:(Y,c)=>{let h;switch(Y){case C.cTFETC1:h=36196;break;case C.cTFBC1:h=33776;break;case C.cTFBC4:h=33779;break;case C.cTFASTC_4x4:h=37808;break;case C.cTFETC2:h=37496;break;case C.cTFBC7:h=36492}if(void 0===h)throw"The chosen Basis transcoder format is not currently supported";return h},TranscodeAsync:M,LoadTextureFromTranscodeResult:P};Object.defineProperty(y,"JSModuleURL",{get:function(){return H.JSModuleURL},set:function(Y){H.JSModuleURL=Y}}),Object.defineProperty(y,"WasmModuleURL",{get:function(){return H.WasmModuleURL},set:function(Y){H.WasmModuleURL=Y}});class d{constructor(){this.supportCascades=!1}loadCubeData(Y,c,h,C,N){if(Array.isArray(Y))return;const Q=c.getEngine().getCaps(),b={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};M(Y,b).then((Y=>{const h=Y.fileInfo.images[0].levels.length>1&&c.generateMipMaps;P(c,Y),c.getEngine()._setCubeMapTextureParams(c,h),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),C&&C()})).catch((Y=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.isReady=!0,N&&N(Y)}))}loadData(Y,c,h){const C=c.getEngine().getCaps(),N={supportedCompressionFormats:{etc1:!!C.etc1,s3tc:!!C.s3tc,pvrtc:!!C.pvrtc,etc2:!!C.etc2,astc:!!C.astc,bc7:!!C.bptc}};M(Y,N).then((Y=>{const C=Y.fileInfo.images[0].levels[0],E=Y.fileInfo.images[0].levels.length>1&&c.generateMipMaps;h(C.width,C.height,E,-1!==Y.format,(()=>{P(c,Y)}))})).catch((Y=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),E.Tools.Warn(`Failed to transcode Basis file: ${Y}`),h(0,0,!1,!1,(()=>{}),!0)}))}}}}]);