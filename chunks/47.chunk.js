"use strict";(self["9jl1vn4ei5r"]=self["9jl1vn4ei5r"]||[]).push([[47],{14165:(M,p,b)=>{b.r(p),b.d(p,{_BasisTextureLoader:()=>K});var Q,q=b(11621),B=b(11780),k=b(11729);function u(){const M=0,p=1,b=2,Q=3,q=6,B=8,k=9,u=10,T=14;let O=null;function H(M,p,b,Q,q){const B=M.getImageTranscodedSizeInBytes(p,b,Q);let k=new Uint8Array(B);if(!M.transcodeImage(k,p,b,Q,1,0))return null;if(q){k=function(M,p,b,Q){const q=new Uint16Array(4),B=new Uint16Array(b*Q),k=b/4,u=Q/4;for(let T=0;T<u;T++)for(let Q=0;Q<k;Q++){const u=p+8*(T*k+Q);q[0]=M[u]|M[u+1]<<8,q[1]=M[u+2]|M[u+3]<<8,q[2]=(2*(31&q[0])+1*(31&q[1]))/3|(2*(2016&q[0])+1*(2016&q[1]))/3&2016|(2*(63488&q[0])+1*(63488&q[1]))/3&63488,q[3]=(2*(31&q[1])+1*(31&q[0]))/3|(2*(2016&q[1])+1*(2016&q[0]))/3&2016|(2*(63488&q[1])+1*(63488&q[0]))/3&63488;for(let p=0;p<4;p++){const k=M[u+4+p];let O=(4*T+p)*b+4*Q;B[O++]=q[3&k],B[O++]=q[k>>2&3],B[O++]=q[k>>4&3],B[O++]=q[k>>6&3]}}return B}(k,0,M.getImageWidth(p,b)+3&-4,M.getImageHeight(p,b)+3&-4)}return k}onmessage=F=>{if("init"===F.data.action){if(F.data.url)try{importScripts(F.data.url)}catch(o){postMessage({action:"error",error:o})}O||(O=BASIS({wasmBinary:F.data.wasmBinary})),null!==O&&O.then((M=>{BASIS=M,M.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===F.data.action){const O=F.data.config,o=F.data.imageData,W=new BASIS.BasisFile(o),i=function(M){const p=M.getHasAlpha(),b=M.getNumImages(),Q=[];for(let q=0;q<b;q++){const p={levels:[]},b=M.getNumLevels(q);for(let Q=0;Q<b;Q++){const b={width:M.getImageWidth(q,Q),height:M.getImageHeight(q,Q)};p.levels.push(b)}Q.push(p)}return{Hb:p,images:Q}}(W);let A=F.data.ignoreSupportedFormats?null:function(O,H){let F=null;O.supportedCompressionFormats&&(F=O.supportedCompressionFormats.astc?u:O.supportedCompressionFormats.bc7?q:O.supportedCompressionFormats.s3tc?H.Hb?Q:b:O.supportedCompressionFormats.pvrtc?H.Hb?k:B:O.supportedCompressionFormats.etc2?p:O.supportedCompressionFormats.etc1?M:T);return F}(F.data.config,i),j=!1;null===A&&(j=!0,A=i.Hb?Q:b);let K=!0;W.startTranscoding()||(K=!1);const D=[];for(let M=0;M<i.images.length&&K;M++){const p=i.images[M];if(void 0===O.loadSingleImage||O.loadSingleImage===M){let b=p.levels.length;!1===O.loadMipmapLevels&&(b=1);for(let Q=0;Q<b;Q++){const b=p.levels[Q],q=H(W,M,Q,A,j);if(!q){K=!1;break}b.transcodedPixels=q,D.push(b.transcodedPixels.buffer)}}}W.close(),W.delete(),j&&(A=-1),K?postMessage({action:"transcode",success:K,id:F.data.id,fileInfo:i,format:A},D):postMessage({action:"transcode",success:K,id:F.data.id})}}}!function(M){M[M.cTFETC1=0]="cTFETC1",M[M.cTFETC2=1]="cTFETC2",M[M.cTFBC1=2]="cTFBC1",M[M.cTFBC3=3]="cTFBC3",M[M.cTFBC4=4]="cTFBC4",M[M.cTFBC5=5]="cTFBC5",M[M.cTFBC7=6]="cTFBC7",M[M.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",M[M.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",M[M.cTFASTC_4x4=10]="cTFASTC_4x4",M[M.cTFATC_RGB=11]="cTFATC_RGB",M[M.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",M[M.cTFRGBA32=13]="cTFRGBA32",M[M.cTFRGB565=14]="cTFRGB565",M[M.cTFBGR565=15]="cTFBGR565",M[M.cTFRGBA4444=16]="cTFRGBA4444",M[M.cTFFXT1_RGB=17]="cTFFXT1_RGB",M[M.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",M[M.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",M[M.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",M[M.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Q||(Q={}));const T={JSModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let O=null,H=null,F=0;const o=async()=>(O||(O=new Promise(((M,p)=>{H?M(H):q.Tools.LoadFileAsync(q.Tools.GetBabylonScriptURL(T.WasmModuleURL)).then((b=>{if("function"!==typeof URL)return p("Basis transcoder requires an environment with a URL constructor");const Q=URL.createObjectURL(new Blob([`(${u})()`],{type:"application/javascript"}));H=new Worker(Q),async function(M,p,b){return await new Promise(((Q,B)=>{const k=p=>{"init"===p.data.action?(M.removeEventListener("message",k),Q(M)):"error"===p.data.action&&B(p.data.error||"error initializing worker")};M.addEventListener("message",k),M.postMessage({action:"init",url:b?q.Tools.GetBabylonScriptURL(b):void 0,wasmBinary:p},[p])}))}(H,b,T.JSModuleURL).then(M,p)})).catch(p)}))),await O),W=async(M,p)=>{const b=M instanceof ArrayBuffer?new Uint8Array(M):M;return await new Promise(((M,Q)=>{o().then((()=>{const q=F++,B=p=>{"transcode"===p.data.action&&p.data.id===q&&(H.removeEventListener("message",B),p.data.success?M(p.data):Q("Transcode is not supported on this device"))};H.addEventListener("message",B);const k=new Uint8Array(b.byteLength);k.set(new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),H.postMessage({action:"transcode",id:q,imageData:k,config:p,ignoreSupportedFormats:false},[k.buffer])}),(M=>{Q(M)}))}))},i=(M,p)=>{var b;let Q=null===(b=p._gl)||void 0===b?void 0:b.TEXTURE_2D;var q;M.isCube&&(Q=null===(q=p._gl)||void 0===q?void 0:q.TEXTURE_CUBE_MAP);p._bindTextureDirectly(Q,M,!0)},A=(M,p)=>{const b=M.getEngine();for(let u=0;u<p.fileInfo.images.length;u++){const T=p.fileInfo.images[u].levels[0];if(M._invertVScale=M.invertY,-1===p.format||p.format===Q.cTFRGB565)if(M.type=10,M.format=4,!b._features.basisNeedsPOT||Math.log2(T.width)%1===0&&Math.log2(T.height)%1===0)M._invertVScale=!M.invertY,M.width=T.width+3&-4,M.height=T.height+3&-4,M.samplingMode=2,i(M,b),b._uploadDataToTextureDirectly(M,new Uint16Array(T.transcodedPixels.buffer),u,0,4,!0);else{const p=new k.b(b,2);M._invertVScale=M.invertY,p.type=10,p.format=4,p.width=T.width+3&-4,p.height=T.height+3&-4,i(p,b),b._uploadDataToTextureDirectly(p,new Uint16Array(T.transcodedPixels.buffer),u,0,4,!0),b._rescaleTexture(p,M,b.scenes[0],b._getInternalFormat(4),(()=>{b._releaseTexture(p),i(M,b)}))}else{M.width=T.width,M.height=T.height,M.generateMipMaps=p.fileInfo.images[u].levels.length>1;const Q=j.GetInternalFormatFromBasisFormat(p.format,b);M.format=Q,i(M,b);const k=p.fileInfo.images[u].levels;for(let p=0;p<k.length;p++){const q=k[p];b._uploadCompressedDataToTextureDirectly(M,Q,q.width,q.height,q.transcodedPixels,u,p)}!b._features.basisNeedsPOT||Math.log2(M.width)%1===0&&Math.log2(M.height)%1===0||(q.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),M._cachedWrapU=B.b.CLAMP_ADDRESSMODE,M._cachedWrapV=B.b.CLAMP_ADDRESSMODE)}}},j={JSModuleURL:T.JSModuleURL,WasmModuleURL:T.WasmModuleURL,GetInternalFormatFromBasisFormat:(M,p)=>{let b;switch(M){case Q.cTFETC1:b=36196;break;case Q.cTFBC1:b=33776;break;case Q.cTFBC4:b=33779;break;case Q.cTFASTC_4x4:b=37808;break;case Q.cTFETC2:b=37496;break;case Q.cTFBC7:b=36492}if(void 0===b)throw"The chosen Basis transcoder format is not currently supported";return b},TranscodeAsync:W,LoadTextureFromTranscodeResult:A};Object.defineProperty(j,"JSModuleURL",{get:function(){return T.JSModuleURL},set:function(M){T.JSModuleURL=M}}),Object.defineProperty(j,"WasmModuleURL",{get:function(){return T.WasmModuleURL},set:function(M){T.WasmModuleURL=M}});class K{constructor(){this.supportCascades=!1}loadCubeData(M,p,b,Q,B){if(Array.isArray(M))return;const k=p.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};W(M,u).then((M=>{const b=M.fileInfo.images[0].levels.length>1&&p.generateMipMaps;A(p,M),p.getEngine()._setCubeMapTextureParams(p,b),p.isReady=!0,p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),Q&&Q()})).catch((M=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.isReady=!0,B&&B(M)}))}loadData(M,p,b){const Q=p.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};W(M,B).then((M=>{const Q=M.fileInfo.images[0].levels[0],q=M.fileInfo.images[0].levels.length>1&&p.generateMipMaps;b(Q.width,Q.height,q,-1!==M.format,(()=>{A(p,M)}))})).catch((M=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.Tools.Warn(`Failed to transcode Basis file: ${M}`),b(0,0,!1,!1,(()=>{}),!0)}))}}}}]);