"use strict";(self.dwifukwnts=self.dwifukwnts||[]).push([[47],{14036:(U,X,b)=>{b.r(X),b.d(X,{_BasisTextureLoader:()=>I});var F,E=b(11385),w=b(11570),Q=b(11528);function z(){const U=0,X=1,b=2,F=3,E=6,w=8,Q=9,z=10,q=14;let p=null;function S(U,X,b,F,E){const w=U.getImageTranscodedSizeInBytes(X,b,F);let Q=new Uint8Array(w);if(!U.transcodeImage(Q,X,b,F,1,0))return null;if(E){Q=function(U,X,b,F){const E=new Uint16Array(4),w=new Uint16Array(b*F),Q=b/4,z=F/4;for(let q=0;q<z;q++)for(let F=0;F<Q;F++){const z=X+8*(q*Q+F);E[0]=U[z]|U[z+1]<<8,E[1]=U[z+2]|U[z+3]<<8,E[2]=(2*(31&E[0])+1*(31&E[1]))/3|(2*(2016&E[0])+1*(2016&E[1]))/3&2016|(2*(63488&E[0])+1*(63488&E[1]))/3&63488,E[3]=(2*(31&E[1])+1*(31&E[0]))/3|(2*(2016&E[1])+1*(2016&E[0]))/3&2016|(2*(63488&E[1])+1*(63488&E[0]))/3&63488;for(let X=0;X<4;X++){const Q=U[z+4+X];let p=(4*q+X)*b+4*F;w[p++]=E[3&Q],w[p++]=E[Q>>2&3],w[p++]=E[Q>>4&3],w[p++]=E[Q>>6&3]}}return w}(Q,0,U.getImageWidth(X,b)+3&-4,U.getImageHeight(X,b)+3&-4)}return Q}onmessage=R=>{if("init"===R.data.action){if(R.data.url)try{importScripts(R.data.url)}catch(n){postMessage({action:"error",error:n})}p||(p=BASIS({wasmBinary:R.data.wasmBinary})),null!==p&&p.then((U=>{BASIS=U,U.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===R.data.action){const p=R.data.config,n=R.data.imageData,a=new BASIS.BasisFile(n),J=function(U){const X=U.getHasAlpha(),b=U.getNumImages(),F=[];for(let E=0;E<b;E++){const X={levels:[]},b=U.getNumLevels(E);for(let F=0;F<b;F++){const b={width:U.getImageWidth(E,F),height:U.getImageHeight(E,F)};X.levels.push(b)}F.push(X)}return{mb:X,images:F}}(a);let m=R.data.ignoreSupportedFormats?null:function(p,S){let R=null;p.supportedCompressionFormats&&(R=p.supportedCompressionFormats.astc?z:p.supportedCompressionFormats.bc7?E:p.supportedCompressionFormats.s3tc?S.mb?F:b:p.supportedCompressionFormats.pvrtc?S.mb?Q:w:p.supportedCompressionFormats.etc2?X:p.supportedCompressionFormats.etc1?U:q);return R}(R.data.config,J),x=!1;null===m&&(x=!0,m=J.mb?F:b);let I=!0;a.startTranscoding()||(I=!1);const O=[];for(let U=0;U<J.images.length&&I;U++){const X=J.images[U];if(void 0===p.loadSingleImage||p.loadSingleImage===U){let b=X.levels.length;!1===p.loadMipmapLevels&&(b=1);for(let F=0;F<b;F++){const b=X.levels[F],E=S(a,U,F,m,x);if(!E){I=!1;break}b.transcodedPixels=E,O.push(b.transcodedPixels.buffer)}}}a.close(),a.delete(),x&&(m=-1),I?postMessage({action:"transcode",success:I,id:R.data.id,fileInfo:J,format:m},O):postMessage({action:"transcode",success:I,id:R.data.id})}}}!function(U){U[U.cTFETC1=0]="cTFETC1",U[U.cTFETC2=1]="cTFETC2",U[U.cTFBC1=2]="cTFBC1",U[U.cTFBC3=3]="cTFBC3",U[U.cTFBC4=4]="cTFBC4",U[U.cTFBC5=5]="cTFBC5",U[U.cTFBC7=6]="cTFBC7",U[U.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",U[U.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",U[U.cTFASTC_4x4=10]="cTFASTC_4x4",U[U.cTFATC_RGB=11]="cTFATC_RGB",U[U.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",U[U.cTFRGBA32=13]="cTFRGBA32",U[U.cTFRGB565=14]="cTFRGB565",U[U.cTFBGR565=15]="cTFBGR565",U[U.cTFRGBA4444=16]="cTFRGBA4444",U[U.cTFFXT1_RGB=17]="cTFFXT1_RGB",U[U.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",U[U.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",U[U.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",U[U.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(F||(F={}));const q={JSModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${E.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let p=null,S=null,R=0;const n=async()=>(p||(p=new Promise(((U,X)=>{S?U(S):E.Tools.LoadFileAsync(E.Tools.GetBabylonScriptURL(q.WasmModuleURL)).then((b=>{if("function"!==typeof URL)return X("Basis transcoder requires an environment with a URL constructor");const F=URL.createObjectURL(new Blob([`(${z})()`],{type:"application/javascript"}));S=new Worker(F),async function(U,X,b){return await new Promise(((F,w)=>{const Q=X=>{"init"===X.data.action?(U.removeEventListener("message",Q),F(U)):"error"===X.data.action&&w(X.data.error||"error initializing worker")};U.addEventListener("message",Q),U.postMessage({action:"init",url:b?E.Tools.GetBabylonScriptURL(b):void 0,wasmBinary:X},[X])}))}(S,b,q.JSModuleURL).then(U,X)})).catch(X)}))),await p),a=async(U,X)=>{const b=U instanceof ArrayBuffer?new Uint8Array(U):U;return await new Promise(((U,F)=>{n().then((()=>{const E=R++,w=X=>{"transcode"===X.data.action&&X.data.id===E&&(S.removeEventListener("message",w),X.data.success?U(X.data):F("Transcode is not supported on this device"))};S.addEventListener("message",w);const Q=new Uint8Array(b.byteLength);Q.set(new Uint8Array(b.buffer,b.byteOffset,b.byteLength)),S.postMessage({action:"transcode",id:E,imageData:Q,config:X,ignoreSupportedFormats:false},[Q.buffer])}),(U=>{F(U)}))}))},J=(U,X)=>{var b;let F=null===(b=X._gl)||void 0===b?void 0:b.TEXTURE_2D;var E;U.isCube&&(F=null===(E=X._gl)||void 0===E?void 0:E.TEXTURE_CUBE_MAP);X._bindTextureDirectly(F,U,!0)},m=(U,X)=>{const b=U.getEngine();for(let z=0;z<X.fileInfo.images.length;z++){const q=X.fileInfo.images[z].levels[0];if(U._invertVScale=U.invertY,-1===X.format||X.format===F.cTFRGB565)if(U.type=10,U.format=4,!b._features.basisNeedsPOT||Math.log2(q.width)%1===0&&Math.log2(q.height)%1===0)U._invertVScale=!U.invertY,U.width=q.width+3&-4,U.height=q.height+3&-4,U.samplingMode=2,J(U,b),b._uploadDataToTextureDirectly(U,new Uint16Array(q.transcodedPixels.buffer),z,0,4,!0);else{const X=new Q.e(b,2);U._invertVScale=U.invertY,X.type=10,X.format=4,X.width=q.width+3&-4,X.height=q.height+3&-4,J(X,b),b._uploadDataToTextureDirectly(X,new Uint16Array(q.transcodedPixels.buffer),z,0,4,!0),b._rescaleTexture(X,U,b.scenes[0],b._getInternalFormat(4),(()=>{b._releaseTexture(X),J(U,b)}))}else{U.width=q.width,U.height=q.height,U.generateMipMaps=X.fileInfo.images[z].levels.length>1;const F=x.GetInternalFormatFromBasisFormat(X.format,b);U.format=F,J(U,b);const Q=X.fileInfo.images[z].levels;for(let X=0;X<Q.length;X++){const E=Q[X];b._uploadCompressedDataToTextureDirectly(U,F,E.width,E.height,E.transcodedPixels,z,X)}!b._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0||(E.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),U._cachedWrapU=w.c.CLAMP_ADDRESSMODE,U._cachedWrapV=w.c.CLAMP_ADDRESSMODE)}}},x={JSModuleURL:q.JSModuleURL,WasmModuleURL:q.WasmModuleURL,GetInternalFormatFromBasisFormat:(U,X)=>{let b;switch(U){case F.cTFETC1:b=36196;break;case F.cTFBC1:b=33776;break;case F.cTFBC4:b=33779;break;case F.cTFASTC_4x4:b=37808;break;case F.cTFETC2:b=37496;break;case F.cTFBC7:b=36492}if(void 0===b)throw"The chosen Basis transcoder format is not currently supported";return b},TranscodeAsync:a,LoadTextureFromTranscodeResult:m};Object.defineProperty(x,"JSModuleURL",{get:function(){return q.JSModuleURL},set:function(U){q.JSModuleURL=U}}),Object.defineProperty(x,"WasmModuleURL",{get:function(){return q.WasmModuleURL},set:function(U){q.WasmModuleURL=U}});class I{constructor(){this.supportCascades=!1}loadCubeData(U,X,b,F,w){if(Array.isArray(U))return;const Q=X.getEngine().getCaps(),z={supportedCompressionFormats:{etc1:!!Q.etc1,s3tc:!!Q.s3tc,pvrtc:!!Q.pvrtc,etc2:!!Q.etc2,astc:!!Q.astc,bc7:!!Q.bptc}};a(U,z).then((U=>{const b=U.fileInfo.images[0].levels.length>1&&X.generateMipMaps;m(X,U),X.getEngine()._setCubeMapTextureParams(X,b),X.isReady=!0,X.onLoadedObservable.notifyObservers(X),X.onLoadedObservable.clear(),F&&F()})).catch((U=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.isReady=!0,w&&w(U)}))}loadData(U,X,b){const F=X.getEngine().getCaps(),w={supportedCompressionFormats:{etc1:!!F.etc1,s3tc:!!F.s3tc,pvrtc:!!F.pvrtc,etc2:!!F.etc2,astc:!!F.astc,bc7:!!F.bptc}};a(U,w).then((U=>{const F=U.fileInfo.images[0].levels[0],E=U.fileInfo.images[0].levels.length>1&&X.generateMipMaps;b(F.width,F.height,E,-1!==U.format,(()=>{m(X,U)}))})).catch((U=>{E.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),E.Tools.Warn(`Failed to transcode Basis file: ${U}`),b(0,0,!1,!1,(()=>{}),!0)}))}}}}]);