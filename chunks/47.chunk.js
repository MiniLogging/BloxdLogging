"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[47],{13827:(m,S,h)=>{h.r(S),h.d(S,{_BasisTextureLoader:()=>n});var l,M=h(11156),O=h(11321),u=h(11262);function b(){const m=0,S=1,h=2,l=3,M=6,O=8,u=9,b=10,q=14;let Y=null;function V(m,S,h,l,M){const O=m.getImageTranscodedSizeInBytes(S,h,l);let u=new Uint8Array(O);if(!m.transcodeImage(u,S,h,l,1,0))return null;if(M){u=function(m,S,h,l){const M=new Uint16Array(4),O=new Uint16Array(h*l),u=h/4,b=l/4;for(let q=0;q<b;q++)for(let l=0;l<u;l++){const b=S+8*(q*u+l);M[0]=m[b]|m[b+1]<<8,M[1]=m[b+2]|m[b+3]<<8,M[2]=(2*(31&M[0])+1*(31&M[1]))/3|(2*(2016&M[0])+1*(2016&M[1]))/3&2016|(2*(63488&M[0])+1*(63488&M[1]))/3&63488,M[3]=(2*(31&M[1])+1*(31&M[0]))/3|(2*(2016&M[1])+1*(2016&M[0]))/3&2016|(2*(63488&M[1])+1*(63488&M[0]))/3&63488;for(let S=0;S<4;S++){const u=m[b+4+S];let Y=(4*q+S)*h+4*l;O[Y++]=M[3&u],O[Y++]=M[u>>2&3],O[Y++]=M[u>>4&3],O[Y++]=M[u>>6&3]}}return O}(u,0,m.getImageWidth(S,h)+3&-4,m.getImageHeight(S,h)+3&-4)}return u}onmessage=I=>{if("init"===I.data.action){if(I.data.url)try{importScripts(I.data.url)}catch(Z){postMessage({action:"error",error:Z})}Y||(Y=BASIS({wasmBinary:I.data.wasmBinary})),null!==Y&&Y.then((m=>{BASIS=m,m.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===I.data.action){const Y=I.data.config,Z=I.data.imageData,C=new BASIS.BasisFile(Z),B=function(m){const S=m.getHasAlpha(),h=m.getNumImages(),l=[];for(let M=0;M<h;M++){const S={levels:[]},h=m.getNumLevels(M);for(let l=0;l<h;l++){const h={width:m.getImageWidth(M,l),height:m.getImageHeight(M,l)};S.levels.push(h)}l.push(S)}return{Sb:S,images:l}}(C);let D=I.data.ignoreSupportedFormats?null:function(Y,V){let I=null;Y.supportedCompressionFormats&&(I=Y.supportedCompressionFormats.astc?b:Y.supportedCompressionFormats.bc7?M:Y.supportedCompressionFormats.s3tc?V.Sb?l:h:Y.supportedCompressionFormats.pvrtc?V.Sb?u:O:Y.supportedCompressionFormats.etc2?S:Y.supportedCompressionFormats.etc1?m:q);return I}(I.data.config,B),E=!1;null===D&&(E=!0,D=B.Sb?l:h);let n=!0;C.startTranscoding()||(n=!1);const L=[];for(let m=0;m<B.images.length&&n;m++){const S=B.images[m];if(void 0===Y.loadSingleImage||Y.loadSingleImage===m){let h=S.levels.length;!1===Y.loadMipmapLevels&&(h=1);for(let l=0;l<h;l++){const h=S.levels[l],M=V(C,m,l,D,E);if(!M){n=!1;break}h.transcodedPixels=M,L.push(h.transcodedPixels.buffer)}}}C.close(),C.delete(),E&&(D=-1),n?postMessage({action:"transcode",success:n,id:I.data.id,fileInfo:B,format:D},L):postMessage({action:"transcode",success:n,id:I.data.id})}}}!function(m){m[m.cTFETC1=0]="cTFETC1",m[m.cTFETC2=1]="cTFETC2",m[m.cTFBC1=2]="cTFBC1",m[m.cTFBC3=3]="cTFBC3",m[m.cTFBC4=4]="cTFBC4",m[m.cTFBC5=5]="cTFBC5",m[m.cTFBC7=6]="cTFBC7",m[m.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",m[m.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",m[m.cTFASTC_4x4=10]="cTFASTC_4x4",m[m.cTFATC_RGB=11]="cTFATC_RGB",m[m.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",m[m.cTFRGBA32=13]="cTFRGBA32",m[m.cTFRGB565=14]="cTFRGB565",m[m.cTFBGR565=15]="cTFBGR565",m[m.cTFRGBA4444=16]="cTFRGBA4444",m[m.cTFFXT1_RGB=17]="cTFFXT1_RGB",m[m.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",m[m.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",m[m.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",m[m.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(l||(l={}));const q={JSModuleURL:`${M.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${M.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Y=null,V=null,I=0;const Z=async()=>(Y||(Y=new Promise(((m,S)=>{V?m(V):M.Tools.LoadFileAsync(M.Tools.GetBabylonScriptURL(q.WasmModuleURL)).then((h=>{if("function"!==typeof URL)return S("Basis transcoder requires an environment with a URL constructor");const l=URL.createObjectURL(new Blob([`(${b})()`],{type:"application/javascript"}));V=new Worker(l),async function(m,S,h){return await new Promise(((l,O)=>{const u=S=>{"init"===S.data.action?(m.removeEventListener("message",u),l(m)):"error"===S.data.action&&O(S.data.error||"error initializing worker")};m.addEventListener("message",u),m.postMessage({action:"init",url:h?M.Tools.GetBabylonScriptURL(h):void 0,wasmBinary:S},[S])}))}(V,h,q.JSModuleURL).then(m,S)})).catch(S)}))),await Y),C=async(m,S)=>{const h=m instanceof ArrayBuffer?new Uint8Array(m):m;return await new Promise(((m,l)=>{Z().then((()=>{const M=I++,O=S=>{"transcode"===S.data.action&&S.data.id===M&&(V.removeEventListener("message",O),S.data.success?m(S.data):l("Transcode is not supported on this device"))};V.addEventListener("message",O);const u=new Uint8Array(h.byteLength);u.set(new Uint8Array(h.buffer,h.byteOffset,h.byteLength)),V.postMessage({action:"transcode",id:M,imageData:u,config:S,ignoreSupportedFormats:false},[u.buffer])}),(m=>{l(m)}))}))},B=(m,S)=>{var h;let l=null===(h=S._gl)||void 0===h?void 0:h.TEXTURE_2D;var M;m.isCube&&(l=null===(M=S._gl)||void 0===M?void 0:M.TEXTURE_CUBE_MAP);S._bindTextureDirectly(l,m,!0)},D=(m,S)=>{const h=m.getEngine();for(let b=0;b<S.fileInfo.images.length;b++){const q=S.fileInfo.images[b].levels[0];if(m._invertVScale=m.invertY,-1===S.format||S.format===l.cTFRGB565)if(m.type=10,m.format=4,!h._features.basisNeedsPOT||Math.log2(q.width)%1===0&&Math.log2(q.height)%1===0)m._invertVScale=!m.invertY,m.width=q.width+3&-4,m.height=q.height+3&-4,m.samplingMode=2,B(m,h),h._uploadDataToTextureDirectly(m,new Uint16Array(q.transcodedPixels.buffer),b,0,4,!0);else{const S=new u.d(h,2);m._invertVScale=m.invertY,S.type=10,S.format=4,S.width=q.width+3&-4,S.height=q.height+3&-4,B(S,h),h._uploadDataToTextureDirectly(S,new Uint16Array(q.transcodedPixels.buffer),b,0,4,!0),h._rescaleTexture(S,m,h.scenes[0],h._getInternalFormat(4),(()=>{h._releaseTexture(S),B(m,h)}))}else{m.width=q.width,m.height=q.height,m.generateMipMaps=S.fileInfo.images[b].levels.length>1;const l=E.GetInternalFormatFromBasisFormat(S.format,h);m.format=l,B(m,h);const u=S.fileInfo.images[b].levels;for(let S=0;S<u.length;S++){const M=u[S];h._uploadCompressedDataToTextureDirectly(m,l,M.width,M.height,M.transcodedPixels,b,S)}!h._features.basisNeedsPOT||Math.log2(m.width)%1===0&&Math.log2(m.height)%1===0||(M.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),m._cachedWrapU=O.e.CLAMP_ADDRESSMODE,m._cachedWrapV=O.e.CLAMP_ADDRESSMODE)}}},E={JSModuleURL:q.JSModuleURL,WasmModuleURL:q.WasmModuleURL,GetInternalFormatFromBasisFormat:(m,S)=>{let h;switch(m){case l.cTFETC1:h=36196;break;case l.cTFBC1:h=33776;break;case l.cTFBC4:h=33779;break;case l.cTFASTC_4x4:h=37808;break;case l.cTFETC2:h=37496;break;case l.cTFBC7:h=36492}if(void 0===h)throw"The chosen Basis transcoder format is not currently supported";return h},TranscodeAsync:C,LoadTextureFromTranscodeResult:D};Object.defineProperty(E,"JSModuleURL",{get:function(){return q.JSModuleURL},set:function(m){q.JSModuleURL=m}}),Object.defineProperty(E,"WasmModuleURL",{get:function(){return q.WasmModuleURL},set:function(m){q.WasmModuleURL=m}});class n{constructor(){this.supportCascades=!1}loadCubeData(m,S,h,l,O){if(Array.isArray(m))return;const u=S.getEngine().getCaps(),b={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};C(m,b).then((m=>{const h=m.fileInfo.images[0].levels.length>1&&S.generateMipMaps;D(S,m),S.getEngine()._setCubeMapTextureParams(S,h),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),l&&l()})).catch((m=>{M.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.isReady=!0,O&&O(m)}))}loadData(m,S,h){const l=S.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!l.etc1,s3tc:!!l.s3tc,pvrtc:!!l.pvrtc,etc2:!!l.etc2,astc:!!l.astc,bc7:!!l.bptc}};C(m,O).then((m=>{const l=m.fileInfo.images[0].levels[0],M=m.fileInfo.images[0].levels.length>1&&S.generateMipMaps;h(l.width,l.height,M,-1!==m.format,(()=>{D(S,m)}))})).catch((m=>{M.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),M.Tools.Warn(`Failed to transcode Basis file: ${m}`),h(0,0,!1,!1,(()=>{}),!0)}))}}}}]);