"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[47],{13698:(Z,x,F)=>{F.r(x),F.d(x,{_BasisTextureLoader:()=>M});var u,G=F(10994),f=F(11157),Y=F(11117);function j(){const Z=0,x=1,F=2,u=3,G=6,f=8,Y=9,j=10,d=14;let t=null;function o(Z,x,F,u,G){const f=Z.getImageTranscodedSizeInBytes(x,F,u);let Y=new Uint8Array(f);if(!Z.transcodeImage(Y,x,F,u,1,0))return null;if(G){Y=function(Z,x,F,u){const G=new Uint16Array(4),f=new Uint16Array(F*u),Y=F/4,j=u/4;for(let d=0;d<j;d++)for(let u=0;u<Y;u++){const j=x+8*(d*Y+u);G[0]=Z[j]|Z[j+1]<<8,G[1]=Z[j+2]|Z[j+3]<<8,G[2]=(2*(31&G[0])+1*(31&G[1]))/3|(2*(2016&G[0])+1*(2016&G[1]))/3&2016|(2*(63488&G[0])+1*(63488&G[1]))/3&63488,G[3]=(2*(31&G[1])+1*(31&G[0]))/3|(2*(2016&G[1])+1*(2016&G[0]))/3&2016|(2*(63488&G[1])+1*(63488&G[0]))/3&63488;for(let x=0;x<4;x++){const Y=Z[j+4+x];let t=(4*d+x)*F+4*u;f[t++]=G[3&Y],f[t++]=G[Y>>2&3],f[t++]=G[Y>>4&3],f[t++]=G[Y>>6&3]}}return f}(Y,0,Z.getImageWidth(x,F)+3&-4,Z.getImageHeight(x,F)+3&-4)}return Y}onmessage=c=>{if("init"===c.data.action){if(c.data.url)try{importScripts(c.data.url)}catch(s){postMessage({action:"error",error:s})}t||(t=BASIS({wasmBinary:c.data.wasmBinary})),null!==t&&t.then((Z=>{BASIS=Z,Z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===c.data.action){const t=c.data.config,s=c.data.imageData,J=new BASIS.BasisFile(s),p=function(Z){const x=Z.getHasAlpha(),F=Z.getNumImages(),u=[];for(let G=0;G<F;G++){const x={levels:[]},F=Z.getNumLevels(G);for(let u=0;u<F;u++){const F={width:Z.getImageWidth(G,u),height:Z.getImageHeight(G,u)};x.levels.push(F)}u.push(x)}return{Af:x,images:u}}(J);let U=c.data.ignoreSupportedFormats?null:function(t,o){let c=null;t.supportedCompressionFormats&&(c=t.supportedCompressionFormats.astc?j:t.supportedCompressionFormats.bc7?G:t.supportedCompressionFormats.s3tc?o.Af?u:F:t.supportedCompressionFormats.pvrtc?o.Af?Y:f:t.supportedCompressionFormats.etc2?x:t.supportedCompressionFormats.etc1?Z:d);return c}(c.data.config,p),k=!1;null===U&&(k=!0,U=p.Af?u:F);let M=!0;J.startTranscoding()||(M=!1);const m=[];for(let Z=0;Z<p.images.length&&M;Z++){const x=p.images[Z];if(void 0===t.loadSingleImage||t.loadSingleImage===Z){let F=x.levels.length;!1===t.loadMipmapLevels&&(F=1);for(let u=0;u<F;u++){const F=x.levels[u],G=o(J,Z,u,U,k);if(!G){M=!1;break}F.transcodedPixels=G,m.push(F.transcodedPixels.buffer)}}}J.close(),J.delete(),k&&(U=-1),M?postMessage({action:"transcode",success:M,id:c.data.id,fileInfo:p,format:U},m):postMessage({action:"transcode",success:M,id:c.data.id})}}}!function(Z){Z[Z.cTFETC1=0]="cTFETC1",Z[Z.cTFETC2=1]="cTFETC2",Z[Z.cTFBC1=2]="cTFBC1",Z[Z.cTFBC3=3]="cTFBC3",Z[Z.cTFBC4=4]="cTFBC4",Z[Z.cTFBC5=5]="cTFBC5",Z[Z.cTFBC7=6]="cTFBC7",Z[Z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Z[Z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Z[Z.cTFASTC_4x4=10]="cTFASTC_4x4",Z[Z.cTFATC_RGB=11]="cTFATC_RGB",Z[Z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Z[Z.cTFRGBA32=13]="cTFRGBA32",Z[Z.cTFRGB565=14]="cTFRGB565",Z[Z.cTFBGR565=15]="cTFBGR565",Z[Z.cTFRGBA4444=16]="cTFRGBA4444",Z[Z.cTFFXT1_RGB=17]="cTFFXT1_RGB",Z[Z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Z[Z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Z[Z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Z[Z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(u||(u={}));const d={JSModuleURL:`${G.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${G.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let t=null,o=null,c=0;const s=async()=>(t||(t=new Promise(((Z,x)=>{o?Z(o):G.Tools.LoadFileAsync(G.Tools.GetBabylonScriptURL(d.WasmModuleURL)).then((F=>{if("function"!==typeof URL)return x("Basis transcoder requires an environment with a URL constructor");const u=URL.createObjectURL(new Blob([`(${j})()`],{type:"application/javascript"}));o=new Worker(u),async function(Z,x,F){return await new Promise(((u,f)=>{const Y=x=>{"init"===x.data.action?(Z.removeEventListener("message",Y),u(Z)):"error"===x.data.action&&f(x.data.error||"error initializing worker")};Z.addEventListener("message",Y),Z.postMessage({action:"init",url:F?G.Tools.GetBabylonScriptURL(F):void 0,wasmBinary:x},[x])}))}(o,F,d.JSModuleURL).then(Z,x)})).catch(x)}))),await t),J=async(Z,x)=>{const F=Z instanceof ArrayBuffer?new Uint8Array(Z):Z;return await new Promise(((Z,u)=>{s().then((()=>{const G=c++,f=x=>{"transcode"===x.data.action&&x.data.id===G&&(o.removeEventListener("message",f),x.data.success?Z(x.data):u("Transcode is not supported on this device"))};o.addEventListener("message",f);const Y=new Uint8Array(F.byteLength);Y.set(new Uint8Array(F.buffer,F.byteOffset,F.byteLength)),o.postMessage({action:"transcode",id:G,imageData:Y,config:x,ignoreSupportedFormats:false},[Y.buffer])}),(Z=>{u(Z)}))}))},p=(Z,x)=>{var F;let u=null===(F=x._gl)||void 0===F?void 0:F.TEXTURE_2D;var G;Z.isCube&&(u=null===(G=x._gl)||void 0===G?void 0:G.TEXTURE_CUBE_MAP);x._bindTextureDirectly(u,Z,!0)},U=(Z,x)=>{const F=Z.getEngine();for(let j=0;j<x.fileInfo.images.length;j++){const d=x.fileInfo.images[j].levels[0];if(Z._invertVScale=Z.invertY,-1===x.format||x.format===u.cTFRGB565)if(Z.type=10,Z.format=4,!F._features.basisNeedsPOT||Math.log2(d.width)%1===0&&Math.log2(d.height)%1===0)Z._invertVScale=!Z.invertY,Z.width=d.width+3&-4,Z.height=d.height+3&-4,Z.samplingMode=2,p(Z,F),F._uploadDataToTextureDirectly(Z,new Uint16Array(d.transcodedPixels.buffer),j,0,4,!0);else{const x=new Y.e(F,2);Z._invertVScale=Z.invertY,x.type=10,x.format=4,x.width=d.width+3&-4,x.height=d.height+3&-4,p(x,F),F._uploadDataToTextureDirectly(x,new Uint16Array(d.transcodedPixels.buffer),j,0,4,!0),F._rescaleTexture(x,Z,F.scenes[0],F._getInternalFormat(4),(()=>{F._releaseTexture(x),p(Z,F)}))}else{Z.width=d.width,Z.height=d.height,Z.generateMipMaps=x.fileInfo.images[j].levels.length>1;const u=k.GetInternalFormatFromBasisFormat(x.format,F);Z.format=u,p(Z,F);const Y=x.fileInfo.images[j].levels;for(let x=0;x<Y.length;x++){const G=Y[x];F._uploadCompressedDataToTextureDirectly(Z,u,G.width,G.height,G.transcodedPixels,j,x)}!F._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0||(G.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Z._cachedWrapU=f.c.CLAMP_ADDRESSMODE,Z._cachedWrapV=f.c.CLAMP_ADDRESSMODE)}}},k={JSModuleURL:d.JSModuleURL,WasmModuleURL:d.WasmModuleURL,GetInternalFormatFromBasisFormat:(Z,x)=>{let F;switch(Z){case u.cTFETC1:F=36196;break;case u.cTFBC1:F=33776;break;case u.cTFBC4:F=33779;break;case u.cTFASTC_4x4:F=37808;break;case u.cTFETC2:F=37496;break;case u.cTFBC7:F=36492}if(void 0===F)throw"The chosen Basis transcoder format is not currently supported";return F},TranscodeAsync:J,LoadTextureFromTranscodeResult:U};Object.defineProperty(k,"JSModuleURL",{get:function(){return d.JSModuleURL},set:function(Z){d.JSModuleURL=Z}}),Object.defineProperty(k,"WasmModuleURL",{get:function(){return d.WasmModuleURL},set:function(Z){d.WasmModuleURL=Z}});class M{constructor(){this.supportCascades=!1}loadCubeData(Z,x,F,u,f){if(Array.isArray(Z))return;const Y=x.getEngine().getCaps(),j={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};J(Z,j).then((Z=>{const F=Z.fileInfo.images[0].levels.length>1&&x.generateMipMaps;U(x,Z),x.getEngine()._setCubeMapTextureParams(x,F),x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),u&&u()})).catch((Z=>{G.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.isReady=!0,f&&f(Z)}))}loadData(Z,x,F){const u=x.getEngine().getCaps(),f={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};J(Z,f).then((Z=>{const u=Z.fileInfo.images[0].levels[0],G=Z.fileInfo.images[0].levels.length>1&&x.generateMipMaps;F(u.width,u.height,G,-1!==Z.format,(()=>{U(x,Z)}))})).catch((Z=>{G.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),G.Tools.Warn(`Failed to transcode Basis file: ${Z}`),F(0,0,!1,!1,(()=>{}),!0)}))}}}}]);