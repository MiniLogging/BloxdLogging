"use strict";(self.ufnpnb83drd=self.ufnpnb83drd||[]).push([[47],{14822:(E,U,g)=>{g.r(U),g.d(U,{_BasisTextureLoader:()=>h});var N,L=g(12165),D=g(12311),S=g(12273);function u(){const E=0,U=1,g=2,N=3,L=6,D=8,S=9,u=10,s=14;let C=null;function B(E,U,g,N,L){const D=E.getImageTranscodedSizeInBytes(U,g,N);let S=new Uint8Array(D);if(!E.transcodeImage(S,U,g,N,1,0))return null;if(L){S=function(E,U,g,N){const L=new Uint16Array(4),D=new Uint16Array(g*N),S=g/4,u=N/4;for(let s=0;s<u;s++)for(let N=0;N<S;N++){const u=U+8*(s*S+N);L[0]=E[u]|E[u+1]<<8,L[1]=E[u+2]|E[u+3]<<8,L[2]=(2*(31&L[0])+1*(31&L[1]))/3|(2*(2016&L[0])+1*(2016&L[1]))/3&2016|(2*(63488&L[0])+1*(63488&L[1]))/3&63488,L[3]=(2*(31&L[1])+1*(31&L[0]))/3|(2*(2016&L[1])+1*(2016&L[0]))/3&2016|(2*(63488&L[1])+1*(63488&L[0]))/3&63488;for(let U=0;U<4;U++){const S=E[u+4+U];let C=(4*s+U)*g+4*N;D[C++]=L[3&S],D[C++]=L[S>>2&3],D[C++]=L[S>>4&3],D[C++]=L[S>>6&3]}}return D}(S,0,E.getImageWidth(U,g)+3&-4,E.getImageHeight(U,g)+3&-4)}return S}onmessage=P=>{if("init"===P.data.action){if(P.data.url)try{importScripts(P.data.url)}catch(F){postMessage({action:"error",error:F})}C||(C=BASIS({wasmBinary:P.data.wasmBinary})),null!==C&&C.then((E=>{BASIS=E,E.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===P.data.action){const C=P.data.config,F=P.data.imageData,f=new BASIS.BasisFile(F),d=function(E){const U=E.getHasAlpha(),g=E.getNumImages(),N=[];for(let L=0;L<g;L++){const U={levels:[]},g=E.getNumLevels(L);for(let N=0;N<g;N++){const g={width:E.getImageWidth(L,N),height:E.getImageHeight(L,N)};U.levels.push(g)}N.push(U)}return{Qg:U,images:N}}(f);let I=P.data.ignoreSupportedFormats?null:function(C,B){let P=null;C.supportedCompressionFormats&&(P=C.supportedCompressionFormats.astc?u:C.supportedCompressionFormats.bc7?L:C.supportedCompressionFormats.s3tc?B.Qg?N:g:C.supportedCompressionFormats.pvrtc?B.Qg?S:D:C.supportedCompressionFormats.etc2?U:C.supportedCompressionFormats.etc1?E:s);return P}(P.data.config,d),y=!1;null===I&&(y=!0,I=d.Qg?N:g);let h=!0;f.startTranscoding()||(h=!1);const V=[];for(let E=0;E<d.images.length&&h;E++){const U=d.images[E];if(void 0===C.loadSingleImage||C.loadSingleImage===E){let g=U.levels.length;!1===C.loadMipmapLevels&&(g=1);for(let N=0;N<g;N++){const g=U.levels[N],L=B(f,E,N,I,y);if(!L){h=!1;break}g.transcodedPixels=L,V.push(g.transcodedPixels.buffer)}}}f.close(),f.delete(),y&&(I=-1),h?postMessage({action:"transcode",success:h,id:P.data.id,fileInfo:d,format:I},V):postMessage({action:"transcode",success:h,id:P.data.id})}}}!function(E){E[E.cTFETC1=0]="cTFETC1",E[E.cTFETC2=1]="cTFETC2",E[E.cTFBC1=2]="cTFBC1",E[E.cTFBC3=3]="cTFBC3",E[E.cTFBC4=4]="cTFBC4",E[E.cTFBC5=5]="cTFBC5",E[E.cTFBC7=6]="cTFBC7",E[E.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",E[E.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",E[E.cTFASTC_4x4=10]="cTFASTC_4x4",E[E.cTFATC_RGB=11]="cTFATC_RGB",E[E.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",E[E.cTFRGBA32=13]="cTFRGBA32",E[E.cTFRGB565=14]="cTFRGB565",E[E.cTFBGR565=15]="cTFBGR565",E[E.cTFRGBA4444=16]="cTFRGBA4444",E[E.cTFFXT1_RGB=17]="cTFFXT1_RGB",E[E.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",E[E.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",E[E.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",E[E.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(N||(N={}));const s={JSModuleURL:`${L.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${L.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,B=null,P=0;const F=async()=>(C||(C=new Promise(((E,U)=>{B?E(B):L.Tools.LoadFileAsync(L.Tools.GetBabylonScriptURL(s.WasmModuleURL)).then((g=>{if("function"!==typeof URL)return U("Basis transcoder requires an environment with a URL constructor");const N=URL.createObjectURL(new Blob([`(${u})()`],{type:"application/javascript"}));B=new Worker(N),async function(E,U,g){return await new Promise(((N,D)=>{const S=U=>{"init"===U.data.action?(E.removeEventListener("message",S),N(E)):"error"===U.data.action&&D(U.data.error||"error initializing worker")};E.addEventListener("message",S),E.postMessage({action:"init",url:g?L.Tools.GetBabylonScriptURL(g):void 0,wasmBinary:U},[U])}))}(B,g,s.JSModuleURL).then(E,U)})).catch(U)}))),await C),f=async(E,U)=>{const g=E instanceof ArrayBuffer?new Uint8Array(E):E;return await new Promise(((E,N)=>{F().then((()=>{const L=P++,D=U=>{"transcode"===U.data.action&&U.data.id===L&&(B.removeEventListener("message",D),U.data.success?E(U.data):N("Transcode is not supported on this device"))};B.addEventListener("message",D);const S=new Uint8Array(g.byteLength);S.set(new Uint8Array(g.buffer,g.byteOffset,g.byteLength)),B.postMessage({action:"transcode",id:L,imageData:S,config:U,ignoreSupportedFormats:false},[S.buffer])}),(E=>{N(E)}))}))},d=(E,U)=>{var g;let N=null===(g=U._gl)||void 0===g?void 0:g.TEXTURE_2D;var L;E.isCube&&(N=null===(L=U._gl)||void 0===L?void 0:L.TEXTURE_CUBE_MAP);U._bindTextureDirectly(N,E,!0)},I=(E,U)=>{const g=E.getEngine();for(let u=0;u<U.fileInfo.images.length;u++){const s=U.fileInfo.images[u].levels[0];if(E._invertVScale=E.invertY,-1===U.format||U.format===N.cTFRGB565)if(E.type=10,E.format=4,!g._features.basisNeedsPOT||Math.log2(s.width)%1===0&&Math.log2(s.height)%1===0)E._invertVScale=!E.invertY,E.width=s.width+3&-4,E.height=s.height+3&-4,E.samplingMode=2,d(E,g),g._uploadDataToTextureDirectly(E,new Uint16Array(s.transcodedPixels.buffer),u,0,4,!0);else{const U=new S.c(g,2);E._invertVScale=E.invertY,U.type=10,U.format=4,U.width=s.width+3&-4,U.height=s.height+3&-4,d(U,g),g._uploadDataToTextureDirectly(U,new Uint16Array(s.transcodedPixels.buffer),u,0,4,!0),g._rescaleTexture(U,E,g.scenes[0],g._getInternalFormat(4),(()=>{g._releaseTexture(U),d(E,g)}))}else{E.width=s.width,E.height=s.height,E.generateMipMaps=U.fileInfo.images[u].levels.length>1;const N=y.GetInternalFormatFromBasisFormat(U.format,g);E.format=N,d(E,g);const S=U.fileInfo.images[u].levels;for(let U=0;U<S.length;U++){const L=S[U];g._uploadCompressedDataToTextureDirectly(E,N,L.width,L.height,L.transcodedPixels,u,U)}!g._features.basisNeedsPOT||Math.log2(E.width)%1===0&&Math.log2(E.height)%1===0||(L.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),E._cachedWrapU=D.c.CLAMP_ADDRESSMODE,E._cachedWrapV=D.c.CLAMP_ADDRESSMODE)}}},y={JSModuleURL:s.JSModuleURL,WasmModuleURL:s.WasmModuleURL,GetInternalFormatFromBasisFormat:(E,U)=>{let g;switch(E){case N.cTFETC1:g=36196;break;case N.cTFBC1:g=33776;break;case N.cTFBC4:g=33779;break;case N.cTFASTC_4x4:g=37808;break;case N.cTFETC2:g=37496;break;case N.cTFBC7:g=36492}if(void 0===g)throw"The chosen Basis transcoder format is not currently supported";return g},TranscodeAsync:f,LoadTextureFromTranscodeResult:I};Object.defineProperty(y,"JSModuleURL",{get:function(){return s.JSModuleURL},set:function(E){s.JSModuleURL=E}}),Object.defineProperty(y,"WasmModuleURL",{get:function(){return s.WasmModuleURL},set:function(E){s.WasmModuleURL=E}});class h{constructor(){this.supportCascades=!1}loadCubeData(E,U,g,N,D){if(Array.isArray(E))return;const S=U.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};f(E,u).then((E=>{const g=E.fileInfo.images[0].levels.length>1&&U.generateMipMaps;I(U,E),U.getEngine()._setCubeMapTextureParams(U,g),U.isReady=!0,U.onLoadedObservable.notifyObservers(U),U.onLoadedObservable.clear(),N&&N()})).catch((E=>{L.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.isReady=!0,D&&D(E)}))}loadData(E,U,g){const N=U.getEngine().getCaps(),D={supportedCompressionFormats:{etc1:!!N.etc1,s3tc:!!N.s3tc,pvrtc:!!N.pvrtc,etc2:!!N.etc2,astc:!!N.astc,bc7:!!N.bptc}};f(E,D).then((E=>{const N=E.fileInfo.images[0].levels[0],L=E.fileInfo.images[0].levels.length>1&&U.generateMipMaps;g(N.width,N.height,L,-1!==E.format,(()=>{I(U,E)}))})).catch((E=>{L.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),L.Tools.Warn(`Failed to transcode Basis file: ${E}`),g(0,0,!1,!1,(()=>{}),!0)}))}}}}]);