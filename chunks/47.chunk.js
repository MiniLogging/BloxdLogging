"use strict";(self.bjbkv7h3qsd=self.bjbkv7h3qsd||[]).push([[47],{13632:(G,A,j)=>{j.r(A),j.d(A,{_BasisTextureLoader:()=>t});var u,k=j(11043),B=j(11196),x=j(11156);function s(){const G=0,A=1,j=2,u=3,k=6,B=8,x=9,s=10,O=14;let d=null;function h(G,A,j,u,k){const B=G.getImageTranscodedSizeInBytes(A,j,u);let x=new Uint8Array(B);if(!G.transcodeImage(x,A,j,u,1,0))return null;if(k){x=function(G,A,j,u){const k=new Uint16Array(4),B=new Uint16Array(j*u),x=j/4,s=u/4;for(let O=0;O<s;O++)for(let u=0;u<x;u++){const s=A+8*(O*x+u);k[0]=G[s]|G[s+1]<<8,k[1]=G[s+2]|G[s+3]<<8,k[2]=(2*(31&k[0])+1*(31&k[1]))/3|(2*(2016&k[0])+1*(2016&k[1]))/3&2016|(2*(63488&k[0])+1*(63488&k[1]))/3&63488,k[3]=(2*(31&k[1])+1*(31&k[0]))/3|(2*(2016&k[1])+1*(2016&k[0]))/3&2016|(2*(63488&k[1])+1*(63488&k[0]))/3&63488;for(let A=0;A<4;A++){const x=G[s+4+A];let d=(4*O+A)*j+4*u;B[d++]=k[3&x],B[d++]=k[x>>2&3],B[d++]=k[x>>4&3],B[d++]=k[x>>6&3]}}return B}(x,0,G.getImageWidth(A,j)+3&-4,G.getImageHeight(A,j)+3&-4)}return x}onmessage=H=>{if("init"===H.data.action){if(H.data.url)try{importScripts(H.data.url)}catch(F){postMessage({action:"error",error:F})}d||(d=BASIS({wasmBinary:H.data.wasmBinary})),null!==d&&d.then((G=>{BASIS=G,G.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===H.data.action){const d=H.data.config,F=H.data.imageData,R=new BASIS.BasisFile(F),U=function(G){const A=G.getHasAlpha(),j=G.getNumImages(),u=[];for(let k=0;k<j;k++){const A={levels:[]},j=G.getNumLevels(k);for(let u=0;u<j;u++){const j={width:G.getImageWidth(k,u),height:G.getImageHeight(k,u)};A.levels.push(j)}u.push(A)}return{Hs:A,images:u}}(R);let S=H.data.ignoreSupportedFormats?null:function(d,h){let H=null;d.supportedCompressionFormats&&(H=d.supportedCompressionFormats.astc?s:d.supportedCompressionFormats.bc7?k:d.supportedCompressionFormats.s3tc?h.Hs?u:j:d.supportedCompressionFormats.pvrtc?h.Hs?x:B:d.supportedCompressionFormats.etc2?A:d.supportedCompressionFormats.etc1?G:O);return H}(H.data.config,U),C=!1;null===S&&(C=!0,S=U.Hs?u:j);let t=!0;R.startTranscoding()||(t=!1);const Y=[];for(let G=0;G<U.images.length&&t;G++){const A=U.images[G];if(void 0===d.loadSingleImage||d.loadSingleImage===G){let j=A.levels.length;!1===d.loadMipmapLevels&&(j=1);for(let u=0;u<j;u++){const j=A.levels[u],k=h(R,G,u,S,C);if(!k){t=!1;break}j.transcodedPixels=k,Y.push(j.transcodedPixels.buffer)}}}R.close(),R.delete(),C&&(S=-1),t?postMessage({action:"transcode",success:t,id:H.data.id,fileInfo:U,format:S},Y):postMessage({action:"transcode",success:t,id:H.data.id})}}}!function(G){G[G.cTFETC1=0]="cTFETC1",G[G.cTFETC2=1]="cTFETC2",G[G.cTFBC1=2]="cTFBC1",G[G.cTFBC3=3]="cTFBC3",G[G.cTFBC4=4]="cTFBC4",G[G.cTFBC5=5]="cTFBC5",G[G.cTFBC7=6]="cTFBC7",G[G.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",G[G.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",G[G.cTFASTC_4x4=10]="cTFASTC_4x4",G[G.cTFATC_RGB=11]="cTFATC_RGB",G[G.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",G[G.cTFRGBA32=13]="cTFRGBA32",G[G.cTFRGB565=14]="cTFRGB565",G[G.cTFBGR565=15]="cTFBGR565",G[G.cTFRGBA4444=16]="cTFRGBA4444",G[G.cTFFXT1_RGB=17]="cTFFXT1_RGB",G[G.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",G[G.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",G[G.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",G[G.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(u||(u={}));const O={JSModuleURL:`${k.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${k.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let d=null,h=null,H=0;const F=async()=>(d||(d=new Promise(((G,A)=>{h?G(h):k.Tools.LoadFileAsync(k.Tools.GetBabylonScriptURL(O.WasmModuleURL)).then((j=>{if("function"!==typeof URL)return A("Basis transcoder requires an environment with a URL constructor");const u=URL.createObjectURL(new Blob([`(${s})()`],{type:"application/javascript"}));h=new Worker(u),async function(G,A,j){return await new Promise(((u,B)=>{const x=A=>{"init"===A.data.action?(G.removeEventListener("message",x),u(G)):"error"===A.data.action&&B(A.data.error||"error initializing worker")};G.addEventListener("message",x),G.postMessage({action:"init",url:j?k.Tools.GetBabylonScriptURL(j):void 0,wasmBinary:A},[A])}))}(h,j,O.JSModuleURL).then(G,A)})).catch(A)}))),await d),R=async(G,A)=>{const j=G instanceof ArrayBuffer?new Uint8Array(G):G;return await new Promise(((G,u)=>{F().then((()=>{const k=H++,B=A=>{"transcode"===A.data.action&&A.data.id===k&&(h.removeEventListener("message",B),A.data.success?G(A.data):u("Transcode is not supported on this device"))};h.addEventListener("message",B);const x=new Uint8Array(j.byteLength);x.set(new Uint8Array(j.buffer,j.byteOffset,j.byteLength)),h.postMessage({action:"transcode",id:k,imageData:x,config:A,ignoreSupportedFormats:false},[x.buffer])}),(G=>{u(G)}))}))},U=(G,A)=>{var j;let u=null===(j=A._gl)||void 0===j?void 0:j.TEXTURE_2D;var k;G.isCube&&(u=null===(k=A._gl)||void 0===k?void 0:k.TEXTURE_CUBE_MAP);A._bindTextureDirectly(u,G,!0)},S=(G,A)=>{const j=G.getEngine();for(let s=0;s<A.fileInfo.images.length;s++){const O=A.fileInfo.images[s].levels[0];if(G._invertVScale=G.invertY,-1===A.format||A.format===u.cTFRGB565)if(G.type=10,G.format=4,!j._features.basisNeedsPOT||Math.log2(O.width)%1===0&&Math.log2(O.height)%1===0)G._invertVScale=!G.invertY,G.width=O.width+3&-4,G.height=O.height+3&-4,G.samplingMode=2,U(G,j),j._uploadDataToTextureDirectly(G,new Uint16Array(O.transcodedPixels.buffer),s,0,4,!0);else{const A=new x.d(j,2);G._invertVScale=G.invertY,A.type=10,A.format=4,A.width=O.width+3&-4,A.height=O.height+3&-4,U(A,j),j._uploadDataToTextureDirectly(A,new Uint16Array(O.transcodedPixels.buffer),s,0,4,!0),j._rescaleTexture(A,G,j.scenes[0],j._getInternalFormat(4),(()=>{j._releaseTexture(A),U(G,j)}))}else{G.width=O.width,G.height=O.height,G.generateMipMaps=A.fileInfo.images[s].levels.length>1;const u=C.GetInternalFormatFromBasisFormat(A.format,j);G.format=u,U(G,j);const x=A.fileInfo.images[s].levels;for(let A=0;A<x.length;A++){const k=x[A];j._uploadCompressedDataToTextureDirectly(G,u,k.width,k.height,k.transcodedPixels,s,A)}!j._features.basisNeedsPOT||Math.log2(G.width)%1===0&&Math.log2(G.height)%1===0||(k.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),G._cachedWrapU=B.e.CLAMP_ADDRESSMODE,G._cachedWrapV=B.e.CLAMP_ADDRESSMODE)}}},C={JSModuleURL:O.JSModuleURL,WasmModuleURL:O.WasmModuleURL,GetInternalFormatFromBasisFormat:(G,A)=>{let j;switch(G){case u.cTFETC1:j=36196;break;case u.cTFBC1:j=33776;break;case u.cTFBC4:j=33779;break;case u.cTFASTC_4x4:j=37808;break;case u.cTFETC2:j=37496;break;case u.cTFBC7:j=36492}if(void 0===j)throw"The chosen Basis transcoder format is not currently supported";return j},TranscodeAsync:R,LoadTextureFromTranscodeResult:S};Object.defineProperty(C,"JSModuleURL",{get:function(){return O.JSModuleURL},set:function(G){O.JSModuleURL=G}}),Object.defineProperty(C,"WasmModuleURL",{get:function(){return O.WasmModuleURL},set:function(G){O.WasmModuleURL=G}});class t{constructor(){this.supportCascades=!1}loadCubeData(G,A,j,u,B){if(Array.isArray(G))return;const x=A.getEngine().getCaps(),s={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};R(G,s).then((G=>{const j=G.fileInfo.images[0].levels.length>1&&A.generateMipMaps;S(A,G),A.getEngine()._setCubeMapTextureParams(A,j),A.isReady=!0,A.onLoadedObservable.notifyObservers(A),A.onLoadedObservable.clear(),u&&u()})).catch((G=>{k.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),A.isReady=!0,B&&B(G)}))}loadData(G,A,j){const u=A.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!u.etc1,s3tc:!!u.s3tc,pvrtc:!!u.pvrtc,etc2:!!u.etc2,astc:!!u.astc,bc7:!!u.bptc}};R(G,B).then((G=>{const u=G.fileInfo.images[0].levels[0],k=G.fileInfo.images[0].levels.length>1&&A.generateMipMaps;j(u.width,u.height,k,-1!==G.format,(()=>{S(A,G)}))})).catch((G=>{k.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),k.Tools.Warn(`Failed to transcode Basis file: ${G}`),j(0,0,!1,!1,(()=>{}),!0)}))}}}}]);