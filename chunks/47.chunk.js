"use strict";(self.g111kvdsqxc=self.g111kvdsqxc||[]).push([[47],{13724:(K,H,M)=>{M.r(H),M.d(H,{_BasisTextureLoader:()=>S});var q,w=M(11100),u=M(11267),y=M(11216);function h(){const K=0,H=1,M=2,q=3,w=6,u=8,y=9,h=10,W=14;let I=null;function f(K,H,M,q,w){const u=K.getImageTranscodedSizeInBytes(H,M,q);let y=new Uint8Array(u);if(!K.transcodeImage(y,H,M,q,1,0))return null;if(w){y=function(K,H,M,q){const w=new Uint16Array(4),u=new Uint16Array(M*q),y=M/4,h=q/4;for(let W=0;W<h;W++)for(let q=0;q<y;q++){const h=H+8*(W*y+q);w[0]=K[h]|K[h+1]<<8,w[1]=K[h+2]|K[h+3]<<8,w[2]=(2*(31&w[0])+1*(31&w[1]))/3|(2*(2016&w[0])+1*(2016&w[1]))/3&2016|(2*(63488&w[0])+1*(63488&w[1]))/3&63488,w[3]=(2*(31&w[1])+1*(31&w[0]))/3|(2*(2016&w[1])+1*(2016&w[0]))/3&2016|(2*(63488&w[1])+1*(63488&w[0]))/3&63488;for(let H=0;H<4;H++){const y=K[h+4+H];let I=(4*W+H)*M+4*q;u[I++]=w[3&y],u[I++]=w[y>>2&3],u[I++]=w[y>>4&3],u[I++]=w[y>>6&3]}}return u}(y,0,K.getImageWidth(H,M)+3&-4,K.getImageHeight(H,M)+3&-4)}return y}onmessage=z=>{if("init"===z.data.action){if(z.data.url)try{importScripts(z.data.url)}catch(G){postMessage({action:"error",error:G})}I||(I=BASIS({wasmBinary:z.data.wasmBinary})),null!==I&&I.then((K=>{BASIS=K,K.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===z.data.action){const I=z.data.config,G=z.data.imageData,a=new BASIS.BasisFile(G),v=function(K){const H=K.getHasAlpha(),M=K.getNumImages(),q=[];for(let w=0;w<M;w++){const H={levels:[]},M=K.getNumLevels(w);for(let q=0;q<M;q++){const M={width:K.getImageWidth(w,q),height:K.getImageHeight(w,q)};H.levels.push(M)}q.push(H)}return{Wh:H,images:q}}(a);let O=z.data.ignoreSupportedFormats?null:function(I,f){let z=null;I.supportedCompressionFormats&&(z=I.supportedCompressionFormats.astc?h:I.supportedCompressionFormats.bc7?w:I.supportedCompressionFormats.s3tc?f.Wh?q:M:I.supportedCompressionFormats.pvrtc?f.Wh?y:u:I.supportedCompressionFormats.etc2?H:I.supportedCompressionFormats.etc1?K:W);return z}(z.data.config,v),L=!1;null===O&&(L=!0,O=v.Wh?q:M);let S=!0;a.startTranscoding()||(S=!1);const B=[];for(let K=0;K<v.images.length&&S;K++){const H=v.images[K];if(void 0===I.loadSingleImage||I.loadSingleImage===K){let M=H.levels.length;!1===I.loadMipmapLevels&&(M=1);for(let q=0;q<M;q++){const M=H.levels[q],w=f(a,K,q,O,L);if(!w){S=!1;break}M.transcodedPixels=w,B.push(M.transcodedPixels.buffer)}}}a.close(),a.delete(),L&&(O=-1),S?postMessage({action:"transcode",success:S,id:z.data.id,fileInfo:v,format:O},B):postMessage({action:"transcode",success:S,id:z.data.id})}}}!function(K){K[K.cTFETC1=0]="cTFETC1",K[K.cTFETC2=1]="cTFETC2",K[K.cTFBC1=2]="cTFBC1",K[K.cTFBC3=3]="cTFBC3",K[K.cTFBC4=4]="cTFBC4",K[K.cTFBC5=5]="cTFBC5",K[K.cTFBC7=6]="cTFBC7",K[K.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",K[K.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",K[K.cTFASTC_4x4=10]="cTFASTC_4x4",K[K.cTFATC_RGB=11]="cTFATC_RGB",K[K.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",K[K.cTFRGBA32=13]="cTFRGBA32",K[K.cTFRGB565=14]="cTFRGB565",K[K.cTFBGR565=15]="cTFBGR565",K[K.cTFRGBA4444=16]="cTFRGBA4444",K[K.cTFFXT1_RGB=17]="cTFFXT1_RGB",K[K.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",K[K.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",K[K.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",K[K.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(q||(q={}));const W={JSModuleURL:`${w.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${w.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let I=null,f=null,z=0;const G=async()=>(I||(I=new Promise(((K,H)=>{f?K(f):w.Tools.LoadFileAsync(w.Tools.GetBabylonScriptURL(W.WasmModuleURL)).then((M=>{if("function"!==typeof URL)return H("Basis transcoder requires an environment with a URL constructor");const q=URL.createObjectURL(new Blob([`(${h})()`],{type:"application/javascript"}));f=new Worker(q),async function(K,H,M){return await new Promise(((q,u)=>{const y=H=>{"init"===H.data.action?(K.removeEventListener("message",y),q(K)):"error"===H.data.action&&u(H.data.error||"error initializing worker")};K.addEventListener("message",y),K.postMessage({action:"init",url:M?w.Tools.GetBabylonScriptURL(M):void 0,wasmBinary:H},[H])}))}(f,M,W.JSModuleURL).then(K,H)})).catch(H)}))),await I),a=async(K,H)=>{const M=K instanceof ArrayBuffer?new Uint8Array(K):K;return await new Promise(((K,q)=>{G().then((()=>{const w=z++,u=H=>{"transcode"===H.data.action&&H.data.id===w&&(f.removeEventListener("message",u),H.data.success?K(H.data):q("Transcode is not supported on this device"))};f.addEventListener("message",u);const y=new Uint8Array(M.byteLength);y.set(new Uint8Array(M.buffer,M.byteOffset,M.byteLength)),f.postMessage({action:"transcode",id:w,imageData:y,config:H,ignoreSupportedFormats:false},[y.buffer])}),(K=>{q(K)}))}))},v=(K,H)=>{var M;let q=null===(M=H._gl)||void 0===M?void 0:M.TEXTURE_2D;var w;K.isCube&&(q=null===(w=H._gl)||void 0===w?void 0:w.TEXTURE_CUBE_MAP);H._bindTextureDirectly(q,K,!0)},O=(K,H)=>{const M=K.getEngine();for(let h=0;h<H.fileInfo.images.length;h++){const W=H.fileInfo.images[h].levels[0];if(K._invertVScale=K.invertY,-1===H.format||H.format===q.cTFRGB565)if(K.type=10,K.format=4,!M._features.basisNeedsPOT||Math.log2(W.width)%1===0&&Math.log2(W.height)%1===0)K._invertVScale=!K.invertY,K.width=W.width+3&-4,K.height=W.height+3&-4,K.samplingMode=2,v(K,M),M._uploadDataToTextureDirectly(K,new Uint16Array(W.transcodedPixels.buffer),h,0,4,!0);else{const H=new y.d(M,2);K._invertVScale=K.invertY,H.type=10,H.format=4,H.width=W.width+3&-4,H.height=W.height+3&-4,v(H,M),M._uploadDataToTextureDirectly(H,new Uint16Array(W.transcodedPixels.buffer),h,0,4,!0),M._rescaleTexture(H,K,M.scenes[0],M._getInternalFormat(4),(()=>{M._releaseTexture(H),v(K,M)}))}else{K.width=W.width,K.height=W.height,K.generateMipMaps=H.fileInfo.images[h].levels.length>1;const q=L.GetInternalFormatFromBasisFormat(H.format,M);K.format=q,v(K,M);const y=H.fileInfo.images[h].levels;for(let H=0;H<y.length;H++){const w=y[H];M._uploadCompressedDataToTextureDirectly(K,q,w.width,w.height,w.transcodedPixels,h,H)}!M._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0||(w.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),K._cachedWrapU=u.b.CLAMP_ADDRESSMODE,K._cachedWrapV=u.b.CLAMP_ADDRESSMODE)}}},L={JSModuleURL:W.JSModuleURL,WasmModuleURL:W.WasmModuleURL,GetInternalFormatFromBasisFormat:(K,H)=>{let M;switch(K){case q.cTFETC1:M=36196;break;case q.cTFBC1:M=33776;break;case q.cTFBC4:M=33779;break;case q.cTFASTC_4x4:M=37808;break;case q.cTFETC2:M=37496;break;case q.cTFBC7:M=36492}if(void 0===M)throw"The chosen Basis transcoder format is not currently supported";return M},TranscodeAsync:a,LoadTextureFromTranscodeResult:O};Object.defineProperty(L,"JSModuleURL",{get:function(){return W.JSModuleURL},set:function(K){W.JSModuleURL=K}}),Object.defineProperty(L,"WasmModuleURL",{get:function(){return W.WasmModuleURL},set:function(K){W.WasmModuleURL=K}});class S{constructor(){this.supportCascades=!1}loadCubeData(K,H,M,q,u){if(Array.isArray(K))return;const y=H.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!y.etc1,s3tc:!!y.s3tc,pvrtc:!!y.pvrtc,etc2:!!y.etc2,astc:!!y.astc,bc7:!!y.bptc}};a(K,h).then((K=>{const M=K.fileInfo.images[0].levels.length>1&&H.generateMipMaps;O(H,K),H.getEngine()._setCubeMapTextureParams(H,M),H.isReady=!0,H.onLoadedObservable.notifyObservers(H),H.onLoadedObservable.clear(),q&&q()})).catch((K=>{w.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),H.isReady=!0,u&&u(K)}))}loadData(K,H,M){const q=H.getEngine().getCaps(),u={supportedCompressionFormats:{etc1:!!q.etc1,s3tc:!!q.s3tc,pvrtc:!!q.pvrtc,etc2:!!q.etc2,astc:!!q.astc,bc7:!!q.bptc}};a(K,u).then((K=>{const q=K.fileInfo.images[0].levels[0],w=K.fileInfo.images[0].levels.length>1&&H.generateMipMaps;M(q.width,q.height,w,-1!==K.format,(()=>{O(H,K)}))})).catch((K=>{w.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),w.Tools.Warn(`Failed to transcode Basis file: ${K}`),M(0,0,!1,!1,(()=>{}),!0)}))}}}}]);