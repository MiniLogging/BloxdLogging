"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[47],{15260:(h,d,T)=>{T.r(d),T.d(d,{_BasisTextureLoader:()=>W});var Y,y=T(12574),C=T(12741),n=T(12684);function X(){const h=0,d=1,T=2,Y=3,y=6,C=8,n=9,X=10,F=14;let U=null;function Z(h,d,T,Y,y){const C=h.getImageTranscodedSizeInBytes(d,T,Y);let n=new Uint8Array(C);if(!h.transcodeImage(n,d,T,Y,1,0))return null;if(y){n=function(h,d,T,Y){const y=new Uint16Array(4),C=new Uint16Array(T*Y),n=T/4,X=Y/4;for(let F=0;F<X;F++)for(let Y=0;Y<n;Y++){const X=d+8*(F*n+Y);y[0]=h[X]|h[X+1]<<8,y[1]=h[X+2]|h[X+3]<<8,y[2]=(2*(31&y[0])+1*(31&y[1]))/3|(2*(2016&y[0])+1*(2016&y[1]))/3&2016|(2*(63488&y[0])+1*(63488&y[1]))/3&63488,y[3]=(2*(31&y[1])+1*(31&y[0]))/3|(2*(2016&y[1])+1*(2016&y[0]))/3&2016|(2*(63488&y[1])+1*(63488&y[0]))/3&63488;for(let d=0;d<4;d++){const n=h[X+4+d];let U=(4*F+d)*T+4*Y;C[U++]=y[3&n],C[U++]=y[n>>2&3],C[U++]=y[n>>4&3],C[U++]=y[n>>6&3]}}return C}(n,0,h.getImageWidth(d,T)+3&-4,h.getImageHeight(d,T)+3&-4)}return n}onmessage=S=>{if("init"===S.data.action){if(S.data.url)try{importScripts(S.data.url)}catch(r){postMessage({action:"error",error:r})}U||(U=BASIS({wasmBinary:S.data.wasmBinary})),null!==U&&U.then((h=>{BASIS=h,h.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===S.data.action){const U=S.data.config,r=S.data.imageData,c=new BASIS.BasisFile(r),O=function(h){const d=h.getHasAlpha(),T=h.getNumImages(),Y=[];for(let y=0;y<T;y++){const d={levels:[]},T=h.getNumLevels(y);for(let Y=0;Y<T;Y++){const T={width:h.getImageWidth(y,Y),height:h.getImageHeight(y,Y)};d.levels.push(T)}Y.push(d)}return{vd:d,images:Y}}(c);let f=S.data.ignoreSupportedFormats?null:function(U,Z){let S=null;U.supportedCompressionFormats&&(S=U.supportedCompressionFormats.astc?X:U.supportedCompressionFormats.bc7?y:U.supportedCompressionFormats.s3tc?Z.vd?Y:T:U.supportedCompressionFormats.pvrtc?Z.vd?n:C:U.supportedCompressionFormats.etc2?d:U.supportedCompressionFormats.etc1?h:F);return S}(S.data.config,O),J=!1;null===f&&(J=!0,f=O.vd?Y:T);let W=!0;c.startTranscoding()||(W=!1);const L=[];for(let h=0;h<O.images.length&&W;h++){const d=O.images[h];if(void 0===U.loadSingleImage||U.loadSingleImage===h){let T=d.levels.length;!1===U.loadMipmapLevels&&(T=1);for(let Y=0;Y<T;Y++){const T=d.levels[Y],y=Z(c,h,Y,f,J);if(!y){W=!1;break}T.transcodedPixels=y,L.push(T.transcodedPixels.buffer)}}}c.close(),c.delete(),J&&(f=-1),W?postMessage({action:"transcode",success:W,id:S.data.id,fileInfo:O,format:f},L):postMessage({action:"transcode",success:W,id:S.data.id})}}}!function(h){h[h.cTFETC1=0]="cTFETC1",h[h.cTFETC2=1]="cTFETC2",h[h.cTFBC1=2]="cTFBC1",h[h.cTFBC3=3]="cTFBC3",h[h.cTFBC4=4]="cTFBC4",h[h.cTFBC5=5]="cTFBC5",h[h.cTFBC7=6]="cTFBC7",h[h.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",h[h.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",h[h.cTFASTC_4x4=10]="cTFASTC_4x4",h[h.cTFATC_RGB=11]="cTFATC_RGB",h[h.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",h[h.cTFRGBA32=13]="cTFRGBA32",h[h.cTFRGB565=14]="cTFRGB565",h[h.cTFBGR565=15]="cTFBGR565",h[h.cTFRGBA4444=16]="cTFRGBA4444",h[h.cTFFXT1_RGB=17]="cTFFXT1_RGB",h[h.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",h[h.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",h[h.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",h[h.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Y||(Y={}));const F={JSModuleURL:`${y.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${y.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let U=null,Z=null,S=0;const r=async()=>(U||(U=new Promise(((h,d)=>{Z?h(Z):y.Tools.LoadFileAsync(y.Tools.GetBabylonScriptURL(F.WasmModuleURL)).then((T=>{if("function"!==typeof URL)return d("Basis transcoder requires an environment with a URL constructor");const Y=URL.createObjectURL(new Blob([`(${X})()`],{type:"application/javascript"}));Z=new Worker(Y),async function(h,d,T){return await new Promise(((Y,C)=>{const n=d=>{"init"===d.data.action?(h.removeEventListener("message",n),Y(h)):"error"===d.data.action&&C(d.data.error||"error initializing worker")};h.addEventListener("message",n),h.postMessage({action:"init",url:T?y.Tools.GetBabylonScriptURL(T):void 0,wasmBinary:d},[d])}))}(Z,T,F.JSModuleURL).then(h,d)})).catch(d)}))),await U),c=async(h,d)=>{const T=h instanceof ArrayBuffer?new Uint8Array(h):h;return await new Promise(((h,Y)=>{r().then((()=>{const y=S++,C=d=>{"transcode"===d.data.action&&d.data.id===y&&(Z.removeEventListener("message",C),d.data.success?h(d.data):Y("Transcode is not supported on this device"))};Z.addEventListener("message",C);const n=new Uint8Array(T.byteLength);n.set(new Uint8Array(T.buffer,T.byteOffset,T.byteLength)),Z.postMessage({action:"transcode",id:y,imageData:n,config:d,ignoreSupportedFormats:false},[n.buffer])}),(h=>{Y(h)}))}))},O=(h,d)=>{var T;let Y=null===(T=d._gl)||void 0===T?void 0:T.TEXTURE_2D;var y;h.isCube&&(Y=null===(y=d._gl)||void 0===y?void 0:y.TEXTURE_CUBE_MAP);d._bindTextureDirectly(Y,h,!0)},f=(h,d)=>{const T=h.getEngine();for(let X=0;X<d.fileInfo.images.length;X++){const F=d.fileInfo.images[X].levels[0];if(h._invertVScale=h.invertY,-1===d.format||d.format===Y.cTFRGB565)if(h.type=10,h.format=4,!T._features.basisNeedsPOT||Math.log2(F.width)%1===0&&Math.log2(F.height)%1===0)h._invertVScale=!h.invertY,h.width=F.width+3&-4,h.height=F.height+3&-4,h.samplingMode=2,O(h,T),T._uploadDataToTextureDirectly(h,new Uint16Array(F.transcodedPixels.buffer),X,0,4,!0);else{const d=new n.e(T,2);h._invertVScale=h.invertY,d.type=10,d.format=4,d.width=F.width+3&-4,d.height=F.height+3&-4,O(d,T),T._uploadDataToTextureDirectly(d,new Uint16Array(F.transcodedPixels.buffer),X,0,4,!0),T._rescaleTexture(d,h,T.scenes[0],T._getInternalFormat(4),(()=>{T._releaseTexture(d),O(h,T)}))}else{h.width=F.width,h.height=F.height,h.generateMipMaps=d.fileInfo.images[X].levels.length>1;const Y=J.GetInternalFormatFromBasisFormat(d.format,T);h.format=Y,O(h,T);const n=d.fileInfo.images[X].levels;for(let d=0;d<n.length;d++){const y=n[d];T._uploadCompressedDataToTextureDirectly(h,Y,y.width,y.height,y.transcodedPixels,X,d)}!T._features.basisNeedsPOT||Math.log2(h.width)%1===0&&Math.log2(h.height)%1===0||(y.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),h._cachedWrapU=C.c.CLAMP_ADDRESSMODE,h._cachedWrapV=C.c.CLAMP_ADDRESSMODE)}}},J={JSModuleURL:F.JSModuleURL,WasmModuleURL:F.WasmModuleURL,GetInternalFormatFromBasisFormat:(h,d)=>{let T;switch(h){case Y.cTFETC1:T=36196;break;case Y.cTFBC1:T=33776;break;case Y.cTFBC4:T=33779;break;case Y.cTFASTC_4x4:T=37808;break;case Y.cTFETC2:T=37496;break;case Y.cTFBC7:T=36492}if(void 0===T)throw"The chosen Basis transcoder format is not currently supported";return T},TranscodeAsync:c,LoadTextureFromTranscodeResult:f};Object.defineProperty(J,"JSModuleURL",{get:function(){return F.JSModuleURL},set:function(h){F.JSModuleURL=h}}),Object.defineProperty(J,"WasmModuleURL",{get:function(){return F.WasmModuleURL},set:function(h){F.WasmModuleURL=h}});class W{constructor(){this.supportCascades=!1}loadCubeData(h,d,T,Y,C){if(Array.isArray(h))return;const n=d.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!n.etc1,s3tc:!!n.s3tc,pvrtc:!!n.pvrtc,etc2:!!n.etc2,astc:!!n.astc,bc7:!!n.bptc}};c(h,X).then((h=>{const T=h.fileInfo.images[0].levels.length>1&&d.generateMipMaps;f(d,h),d.getEngine()._setCubeMapTextureParams(d,T),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),Y&&Y()})).catch((h=>{y.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),d.isReady=!0,C&&C(h)}))}loadData(h,d,T){const Y=d.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};c(h,C).then((h=>{const Y=h.fileInfo.images[0].levels[0],y=h.fileInfo.images[0].levels.length>1&&d.generateMipMaps;T(Y.width,Y.height,y,-1!==h.format,(()=>{f(d,h)}))})).catch((h=>{y.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),y.Tools.Warn(`Failed to transcode Basis file: ${h}`),T(0,0,!1,!1,(()=>{}),!0)}))}}}}]);