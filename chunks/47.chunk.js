"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[47],{14911:(U,G,C)=>{C.r(G),C.d(G,{_BasisTextureLoader:()=>H});var L,X=C(12718),l=C(12873),t=C(12826);function E(){const U=0,G=1,C=2,L=3,X=6,l=8,t=9,E=10,K=14;let P=null;function O(U,G,C,L,X){const l=U.getImageTranscodedSizeInBytes(G,C,L);let t=new Uint8Array(l);if(!U.transcodeImage(t,G,C,L,1,0))return null;if(X){t=function(U,G,C,L){const X=new Uint16Array(4),l=new Uint16Array(C*L),t=C/4,E=L/4;for(let K=0;K<E;K++)for(let L=0;L<t;L++){const E=G+8*(K*t+L);X[0]=U[E]|U[E+1]<<8,X[1]=U[E+2]|U[E+3]<<8,X[2]=(2*(31&X[0])+1*(31&X[1]))/3|(2*(2016&X[0])+1*(2016&X[1]))/3&2016|(2*(63488&X[0])+1*(63488&X[1]))/3&63488,X[3]=(2*(31&X[1])+1*(31&X[0]))/3|(2*(2016&X[1])+1*(2016&X[0]))/3&2016|(2*(63488&X[1])+1*(63488&X[0]))/3&63488;for(let G=0;G<4;G++){const t=U[E+4+G];let P=(4*K+G)*C+4*L;l[P++]=X[3&t],l[P++]=X[t>>2&3],l[P++]=X[t>>4&3],l[P++]=X[t>>6&3]}}return l}(t,0,U.getImageWidth(G,C)+3&-4,U.getImageHeight(G,C)+3&-4)}return t}onmessage=T=>{if("init"===T.data.action){if(T.data.url)try{importScripts(T.data.url)}catch(D){postMessage({action:"error",error:D})}P||(P=BASIS({wasmBinary:T.data.wasmBinary})),null!==P&&P.then((U=>{BASIS=U,U.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===T.data.action){const P=T.data.config,D=T.data.imageData,y=new BASIS.BasisFile(D),V=function(U){const G=U.getHasAlpha(),C=U.getNumImages(),L=[];for(let X=0;X<C;X++){const G={levels:[]},C=U.getNumLevels(X);for(let L=0;L<C;L++){const C={width:U.getImageWidth(X,L),height:U.getImageHeight(X,L)};G.levels.push(C)}L.push(G)}return{jE:G,images:L}}(y);let p=T.data.ignoreSupportedFormats?null:function(P,O){let T=null;P.supportedCompressionFormats&&(T=P.supportedCompressionFormats.astc?E:P.supportedCompressionFormats.bc7?X:P.supportedCompressionFormats.s3tc?O.jE?L:C:P.supportedCompressionFormats.pvrtc?O.jE?t:l:P.supportedCompressionFormats.etc2?G:P.supportedCompressionFormats.etc1?U:K);return T}(T.data.config,V),I=!1;null===p&&(I=!0,p=V.jE?L:C);let H=!0;y.startTranscoding()||(H=!1);const x=[];for(let U=0;U<V.images.length&&H;U++){const G=V.images[U];if(void 0===P.loadSingleImage||P.loadSingleImage===U){let C=G.levels.length;!1===P.loadMipmapLevels&&(C=1);for(let L=0;L<C;L++){const C=G.levels[L],X=O(y,U,L,p,I);if(!X){H=!1;break}C.transcodedPixels=X,x.push(C.transcodedPixels.buffer)}}}y.close(),y.delete(),I&&(p=-1),H?postMessage({action:"transcode",success:H,id:T.data.id,fileInfo:V,format:p},x):postMessage({action:"transcode",success:H,id:T.data.id})}}}!function(U){U[U.cTFETC1=0]="cTFETC1",U[U.cTFETC2=1]="cTFETC2",U[U.cTFBC1=2]="cTFBC1",U[U.cTFBC3=3]="cTFBC3",U[U.cTFBC4=4]="cTFBC4",U[U.cTFBC5=5]="cTFBC5",U[U.cTFBC7=6]="cTFBC7",U[U.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",U[U.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",U[U.cTFASTC_4x4=10]="cTFASTC_4x4",U[U.cTFATC_RGB=11]="cTFATC_RGB",U[U.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",U[U.cTFRGBA32=13]="cTFRGBA32",U[U.cTFRGB565=14]="cTFRGB565",U[U.cTFBGR565=15]="cTFBGR565",U[U.cTFRGBA4444=16]="cTFRGBA4444",U[U.cTFFXT1_RGB=17]="cTFFXT1_RGB",U[U.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",U[U.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",U[U.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",U[U.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(L||(L={}));const K={JSModuleURL:"".concat(X.Tools._DefaultCdnUrl,"/basisTranscoder/1/basis_transcoder.js"),WasmModuleURL:"".concat(X.Tools._DefaultCdnUrl,"/basisTranscoder/1/basis_transcoder.wasm")};let P=null,O=null,T=0;const D=async()=>(P||(P=new Promise(((U,G)=>{O?U(O):X.Tools.LoadFileAsync(X.Tools.GetBabylonScriptURL(K.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return G("Basis transcoder requires an environment with a URL constructor");const L=URL.createObjectURL(new Blob(["(".concat(E,")()")],{type:"application/javascript"}));O=new Worker(L),async function(U,G,C){return await new Promise(((L,l)=>{const t=G=>{"init"===G.data.action?(U.removeEventListener("message",t),L(U)):"error"===G.data.action&&l(G.data.error||"error initializing worker")};U.addEventListener("message",t),U.postMessage({action:"init",url:C?X.Tools.GetBabylonScriptURL(C):void 0,wasmBinary:G},[G])}))}(O,C,K.JSModuleURL).then(U,G)})).catch(G)}))),await P),y=async(U,G)=>{const C=U instanceof ArrayBuffer?new Uint8Array(U):U;return await new Promise(((U,L)=>{D().then((()=>{const X=T++,l=G=>{"transcode"===G.data.action&&G.data.id===X&&(O.removeEventListener("message",l),G.data.success?U(G.data):L("Transcode is not supported on this device"))};O.addEventListener("message",l);const t=new Uint8Array(C.byteLength);t.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),O.postMessage({action:"transcode",id:X,imageData:t,config:G,ignoreSupportedFormats:false},[t.buffer])}),(U=>{L(U)}))}))},V=(U,G)=>{var C;let L=null===(C=G._gl)||void 0===C?void 0:C.TEXTURE_2D;var X;U.isCube&&(L=null===(X=G._gl)||void 0===X?void 0:X.TEXTURE_CUBE_MAP);G._bindTextureDirectly(L,U,!0)},p=(U,G)=>{const C=U.getEngine();for(let E=0;E<G.fileInfo.images.length;E++){const K=G.fileInfo.images[E].levels[0];if(U._invertVScale=U.invertY,-1===G.format||G.format===L.cTFRGB565)if(U.type=10,U.format=4,!C._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0)U._invertVScale=!U.invertY,U.width=K.width+3&-4,U.height=K.height+3&-4,U.samplingMode=2,V(U,C),C._uploadDataToTextureDirectly(U,new Uint16Array(K.transcodedPixels.buffer),E,0,4,!0);else{const G=new t.b(C,2);U._invertVScale=U.invertY,G.type=10,G.format=4,G.width=K.width+3&-4,G.height=K.height+3&-4,V(G,C),C._uploadDataToTextureDirectly(G,new Uint16Array(K.transcodedPixels.buffer),E,0,4,!0),C._rescaleTexture(G,U,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(G),V(U,C)}))}else{U.width=K.width,U.height=K.height,U.generateMipMaps=G.fileInfo.images[E].levels.length>1;const L=I.GetInternalFormatFromBasisFormat(G.format,C);U.format=L,V(U,C);const t=G.fileInfo.images[E].levels;for(let G=0;G<t.length;G++){const X=t[G];C._uploadCompressedDataToTextureDirectly(U,L,X.width,X.height,X.transcodedPixels,E,G)}!C._features.basisNeedsPOT||Math.log2(U.width)%1===0&&Math.log2(U.height)%1===0||(X.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),U._cachedWrapU=l.c.CLAMP_ADDRESSMODE,U._cachedWrapV=l.c.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:K.JSModuleURL,WasmModuleURL:K.WasmModuleURL,GetInternalFormatFromBasisFormat:(U,G)=>{let C;switch(U){case L.cTFETC1:C=36196;break;case L.cTFBC1:C=33776;break;case L.cTFBC4:C=33779;break;case L.cTFASTC_4x4:C=37808;break;case L.cTFETC2:C=37496;break;case L.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:y,LoadTextureFromTranscodeResult:p};Object.defineProperty(I,"JSModuleURL",{get:function(){return K.JSModuleURL},set:function(U){K.JSModuleURL=U}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return K.WasmModuleURL},set:function(U){K.WasmModuleURL=U}});class H{constructor(){this.supportCascades=!1}loadCubeData(U,G,C,L,l){if(Array.isArray(U))return;const t=G.getEngine().getCaps(),E={supportedCompressionFormats:{etc1:!!t.etc1,s3tc:!!t.s3tc,pvrtc:!!t.pvrtc,etc2:!!t.etc2,astc:!!t.astc,bc7:!!t.bptc}};y(U,E).then((U=>{const C=U.fileInfo.images[0].levels.length>1&&G.generateMipMaps;p(G,U),G.getEngine()._setCubeMapTextureParams(G,C),G.isReady=!0,G.onLoadedObservable.notifyObservers(G),G.onLoadedObservable.clear(),L&&L()})).catch((U=>{X.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),G.isReady=!0,l&&l(U)}))}loadData(U,G,C){const L=G.getEngine().getCaps(),l={supportedCompressionFormats:{etc1:!!L.etc1,s3tc:!!L.s3tc,pvrtc:!!L.pvrtc,etc2:!!L.etc2,astc:!!L.astc,bc7:!!L.bptc}};y(U,l).then((U=>{const L=U.fileInfo.images[0].levels[0],X=U.fileInfo.images[0].levels.length>1&&G.generateMipMaps;C(L.width,L.height,X,-1!==U.format,(()=>{p(G,U)}))})).catch((U=>{X.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.Tools.Warn("Failed to transcode Basis file: ".concat(U)),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);