"use strict";(self.k9ivgwsw3f=self.k9ivgwsw3f||[]).push([[47],{15365:(Y,b,C)=>{C.r(b),C.d(b,{_BasisTextureLoader:()=>w});var R,q=C(12645),A=C(12814),E=C(12767);function B(){const Y=0,b=1,C=2,R=3,q=6,A=8,E=9,B=10,g=14;let r=null;function O(Y,b,C,R,q){const A=Y.getImageTranscodedSizeInBytes(b,C,R);let E=new Uint8Array(A);if(!Y.transcodeImage(E,b,C,R,1,0))return null;if(q){E=function(Y,b,C,R){const q=new Uint16Array(4),A=new Uint16Array(C*R),E=C/4,B=R/4;for(let g=0;g<B;g++)for(let R=0;R<E;R++){const B=b+8*(g*E+R);q[0]=Y[B]|Y[B+1]<<8,q[1]=Y[B+2]|Y[B+3]<<8,q[2]=(2*(31&q[0])+1*(31&q[1]))/3|(2*(2016&q[0])+1*(2016&q[1]))/3&2016|(2*(63488&q[0])+1*(63488&q[1]))/3&63488,q[3]=(2*(31&q[1])+1*(31&q[0]))/3|(2*(2016&q[1])+1*(2016&q[0]))/3&2016|(2*(63488&q[1])+1*(63488&q[0]))/3&63488;for(let b=0;b<4;b++){const E=Y[B+4+b];let r=(4*g+b)*C+4*R;A[r++]=q[3&E],A[r++]=q[E>>2&3],A[r++]=q[E>>4&3],A[r++]=q[E>>6&3]}}return A}(E,0,Y.getImageWidth(b,C)+3&-4,Y.getImageHeight(b,C)+3&-4)}return E}onmessage=F=>{if("init"===F.data.action){if(F.data.url)try{importScripts(F.data.url)}catch(y){postMessage({action:"error",error:y})}r||(r=BASIS({wasmBinary:F.data.wasmBinary})),null!==r&&r.then((Y=>{BASIS=Y,Y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===F.data.action){const r=F.data.config,y=F.data.imageData,S=new BASIS.BasisFile(y),n=function(Y){const b=Y.getHasAlpha(),C=Y.getNumImages(),R=[];for(let q=0;q<C;q++){const b={levels:[]},C=Y.getNumLevels(q);for(let R=0;R<C;R++){const C={width:Y.getImageWidth(q,R),height:Y.getImageHeight(q,R)};b.levels.push(C)}R.push(b)}return{lb:b,images:R}}(S);let t=F.data.ignoreSupportedFormats?null:function(r,O){let F=null;r.supportedCompressionFormats&&(F=r.supportedCompressionFormats.astc?B:r.supportedCompressionFormats.bc7?q:r.supportedCompressionFormats.s3tc?O.lb?R:C:r.supportedCompressionFormats.pvrtc?O.lb?E:A:r.supportedCompressionFormats.etc2?b:r.supportedCompressionFormats.etc1?Y:g);return F}(F.data.config,n),I=!1;null===t&&(I=!0,t=n.lb?R:C);let w=!0;S.startTranscoding()||(w=!1);const Q=[];for(let Y=0;Y<n.images.length&&w;Y++){const b=n.images[Y];if(void 0===r.loadSingleImage||r.loadSingleImage===Y){let C=b.levels.length;!1===r.loadMipmapLevels&&(C=1);for(let R=0;R<C;R++){const C=b.levels[R],q=O(S,Y,R,t,I);if(!q){w=!1;break}C.transcodedPixels=q,Q.push(C.transcodedPixels.buffer)}}}S.close(),S.delete(),I&&(t=-1),w?postMessage({action:"transcode",success:w,id:F.data.id,fileInfo:n,format:t},Q):postMessage({action:"transcode",success:w,id:F.data.id})}}}!function(Y){Y[Y.cTFETC1=0]="cTFETC1",Y[Y.cTFETC2=1]="cTFETC2",Y[Y.cTFBC1=2]="cTFBC1",Y[Y.cTFBC3=3]="cTFBC3",Y[Y.cTFBC4=4]="cTFBC4",Y[Y.cTFBC5=5]="cTFBC5",Y[Y.cTFBC7=6]="cTFBC7",Y[Y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Y[Y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Y[Y.cTFASTC_4x4=10]="cTFASTC_4x4",Y[Y.cTFATC_RGB=11]="cTFATC_RGB",Y[Y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Y[Y.cTFRGBA32=13]="cTFRGBA32",Y[Y.cTFRGB565=14]="cTFRGB565",Y[Y.cTFBGR565=15]="cTFBGR565",Y[Y.cTFRGBA4444=16]="cTFRGBA4444",Y[Y.cTFFXT1_RGB=17]="cTFFXT1_RGB",Y[Y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Y[Y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Y[Y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Y[Y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(R||(R={}));const g={JSModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let r=null,O=null,F=0;const y=async()=>(r||(r=new Promise(((Y,b)=>{O?Y(O):q.Tools.LoadFileAsync(q.Tools.GetBabylonScriptURL(g.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const R=URL.createObjectURL(new Blob([`(${B})()`],{type:"application/javascript"}));O=new Worker(R),async function(Y,b,C){return await new Promise(((R,A)=>{const E=b=>{"init"===b.data.action?(Y.removeEventListener("message",E),R(Y)):"error"===b.data.action&&A(b.data.error||"error initializing worker")};Y.addEventListener("message",E),Y.postMessage({action:"init",url:C?q.Tools.GetBabylonScriptURL(C):void 0,wasmBinary:b},[b])}))}(O,C,g.JSModuleURL).then(Y,b)})).catch(b)}))),await r),S=async(Y,b)=>{const C=Y instanceof ArrayBuffer?new Uint8Array(Y):Y;return await new Promise(((Y,R)=>{y().then((()=>{const q=F++,A=b=>{"transcode"===b.data.action&&b.data.id===q&&(O.removeEventListener("message",A),b.data.success?Y(b.data):R("Transcode is not supported on this device"))};O.addEventListener("message",A);const E=new Uint8Array(C.byteLength);E.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),O.postMessage({action:"transcode",id:q,imageData:E,config:b,ignoreSupportedFormats:false},[E.buffer])}),(Y=>{R(Y)}))}))},n=(Y,b)=>{var C;let R=null===(C=b._gl)||void 0===C?void 0:C.TEXTURE_2D;var q;Y.isCube&&(R=null===(q=b._gl)||void 0===q?void 0:q.TEXTURE_CUBE_MAP);b._bindTextureDirectly(R,Y,!0)},t=(Y,b)=>{const C=Y.getEngine();for(let B=0;B<b.fileInfo.images.length;B++){const g=b.fileInfo.images[B].levels[0];if(Y._invertVScale=Y.invertY,-1===b.format||b.format===R.cTFRGB565)if(Y.type=10,Y.format=4,!C._features.basisNeedsPOT||Math.log2(g.width)%1===0&&Math.log2(g.height)%1===0)Y._invertVScale=!Y.invertY,Y.width=g.width+3&-4,Y.height=g.height+3&-4,Y.samplingMode=2,n(Y,C),C._uploadDataToTextureDirectly(Y,new Uint16Array(g.transcodedPixels.buffer),B,0,4,!0);else{const b=new E.b(C,2);Y._invertVScale=Y.invertY,b.type=10,b.format=4,b.width=g.width+3&-4,b.height=g.height+3&-4,n(b,C),C._uploadDataToTextureDirectly(b,new Uint16Array(g.transcodedPixels.buffer),B,0,4,!0),C._rescaleTexture(b,Y,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(b),n(Y,C)}))}else{Y.width=g.width,Y.height=g.height,Y.generateMipMaps=b.fileInfo.images[B].levels.length>1;const R=I.GetInternalFormatFromBasisFormat(b.format,C);Y.format=R,n(Y,C);const E=b.fileInfo.images[B].levels;for(let b=0;b<E.length;b++){const q=E[b];C._uploadCompressedDataToTextureDirectly(Y,R,q.width,q.height,q.transcodedPixels,B,b)}!C._features.basisNeedsPOT||Math.log2(Y.width)%1===0&&Math.log2(Y.height)%1===0||(q.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Y._cachedWrapU=A.b.CLAMP_ADDRESSMODE,Y._cachedWrapV=A.b.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:g.JSModuleURL,WasmModuleURL:g.WasmModuleURL,GetInternalFormatFromBasisFormat:(Y,b)=>{let C;switch(Y){case R.cTFETC1:C=36196;break;case R.cTFBC1:C=33776;break;case R.cTFBC4:C=33779;break;case R.cTFASTC_4x4:C=37808;break;case R.cTFETC2:C=37496;break;case R.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:S,LoadTextureFromTranscodeResult:t};Object.defineProperty(I,"JSModuleURL",{get:function(){return g.JSModuleURL},set:function(Y){g.JSModuleURL=Y}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return g.WasmModuleURL},set:function(Y){g.WasmModuleURL=Y}});class w{constructor(){this.supportCascades=!1}loadCubeData(Y,b,C,R,A){if(Array.isArray(Y))return;const E=b.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!E.etc1,s3tc:!!E.s3tc,pvrtc:!!E.pvrtc,etc2:!!E.etc2,astc:!!E.astc,bc7:!!E.bptc}};S(Y,B).then((Y=>{const C=Y.fileInfo.images[0].levels.length>1&&b.generateMipMaps;t(b,Y),b.getEngine()._setCubeMapTextureParams(b,C),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),R&&R()})).catch((Y=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,A&&A(Y)}))}loadData(Y,b,C){const R=b.getEngine().getCaps(),A={supportedCompressionFormats:{etc1:!!R.etc1,s3tc:!!R.s3tc,pvrtc:!!R.pvrtc,etc2:!!R.etc2,astc:!!R.astc,bc7:!!R.bptc}};S(Y,A).then((Y=>{const R=Y.fileInfo.images[0].levels[0],q=Y.fileInfo.images[0].levels.length>1&&b.generateMipMaps;C(R.width,R.height,q,-1!==Y.format,(()=>{t(b,Y)}))})).catch((Y=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.Tools.Warn(`Failed to transcode Basis file: ${Y}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);