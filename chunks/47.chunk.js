"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[47],{14045:(F,P,f)=>{f.r(P),f.d(P,{_BasisTextureLoader:()=>J});var c,N=f(11462),q=f(11612),H=f(11567);function A(){const F=0,P=1,f=2,c=3,N=6,q=8,H=9,A=10,o=14;let j=null;function i(F,P,f,c,N){const q=F.getImageTranscodedSizeInBytes(P,f,c);let H=new Uint8Array(q);if(!F.transcodeImage(H,P,f,c,1,0))return null;if(N){H=function(F,P,f,c){const N=new Uint16Array(4),q=new Uint16Array(f*c),H=f/4,A=c/4;for(let o=0;o<A;o++)for(let c=0;c<H;c++){const A=P+8*(o*H+c);N[0]=F[A]|F[A+1]<<8,N[1]=F[A+2]|F[A+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let P=0;P<4;P++){const H=F[A+4+P];let j=(4*o+P)*f+4*c;q[j++]=N[3&H],q[j++]=N[H>>2&3],q[j++]=N[H>>4&3],q[j++]=N[H>>6&3]}}return q}(H,0,F.getImageWidth(P,f)+3&-4,F.getImageHeight(P,f)+3&-4)}return H}onmessage=u=>{if("init"===u.data.action){if(u.data.url)try{importScripts(u.data.url)}catch(T){postMessage({action:"error",error:T})}j||(j=BASIS({wasmBinary:u.data.wasmBinary})),null!==j&&j.then((F=>{BASIS=F,F.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===u.data.action){const j=u.data.config,T=u.data.imageData,Y=new BASIS.BasisFile(T),t=function(F){const P=F.getHasAlpha(),f=F.getNumImages(),c=[];for(let N=0;N<f;N++){const P={levels:[]},f=F.getNumLevels(N);for(let c=0;c<f;c++){const f={width:F.getImageWidth(N,c),height:F.getImageHeight(N,c)};P.levels.push(f)}c.push(P)}return{ef:P,images:c}}(Y);let C=u.data.ignoreSupportedFormats?null:function(j,i){let u=null;j.supportedCompressionFormats&&(u=j.supportedCompressionFormats.astc?A:j.supportedCompressionFormats.bc7?N:j.supportedCompressionFormats.s3tc?i.ef?c:f:j.supportedCompressionFormats.pvrtc?i.ef?H:q:j.supportedCompressionFormats.etc2?P:j.supportedCompressionFormats.etc1?F:o);return u}(u.data.config,t),L=!1;null===C&&(L=!0,C=t.ef?c:f);let J=!0;Y.startTranscoding()||(J=!1);const B=[];for(let F=0;F<t.images.length&&J;F++){const P=t.images[F];if(void 0===j.loadSingleImage||j.loadSingleImage===F){let f=P.levels.length;!1===j.loadMipmapLevels&&(f=1);for(let c=0;c<f;c++){const f=P.levels[c],N=i(Y,F,c,C,L);if(!N){J=!1;break}f.transcodedPixels=N,B.push(f.transcodedPixels.buffer)}}}Y.close(),Y.delete(),L&&(C=-1),J?postMessage({action:"transcode",success:J,id:u.data.id,fileInfo:t,format:C},B):postMessage({action:"transcode",success:J,id:u.data.id})}}}!function(F){F[F.cTFETC1=0]="cTFETC1",F[F.cTFETC2=1]="cTFETC2",F[F.cTFBC1=2]="cTFBC1",F[F.cTFBC3=3]="cTFBC3",F[F.cTFBC4=4]="cTFBC4",F[F.cTFBC5=5]="cTFBC5",F[F.cTFBC7=6]="cTFBC7",F[F.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",F[F.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",F[F.cTFASTC_4x4=10]="cTFASTC_4x4",F[F.cTFATC_RGB=11]="cTFATC_RGB",F[F.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",F[F.cTFRGBA32=13]="cTFRGBA32",F[F.cTFRGB565=14]="cTFRGB565",F[F.cTFBGR565=15]="cTFBGR565",F[F.cTFRGBA4444=16]="cTFRGBA4444",F[F.cTFFXT1_RGB=17]="cTFFXT1_RGB",F[F.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",F[F.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",F[F.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",F[F.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(c||(c={}));const o={JSModuleURL:`${N.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let j=null,i=null,u=0;const T=async()=>(j||(j=new Promise(((F,P)=>{i?F(i):N.Tools.LoadFileAsync(N.Tools.GetBabylonScriptURL(o.WasmModuleURL)).then((f=>{if("function"!==typeof URL)return P("Basis transcoder requires an environment with a URL constructor");const c=URL.createObjectURL(new Blob([`(${A})()`],{type:"application/javascript"}));i=new Worker(c),async function(F,P,f){return await new Promise(((c,q)=>{const H=P=>{"init"===P.data.action?(F.removeEventListener("message",H),c(F)):"error"===P.data.action&&q(P.data.error||"error initializing worker")};F.addEventListener("message",H),F.postMessage({action:"init",url:f?N.Tools.GetBabylonScriptURL(f):void 0,wasmBinary:P},[P])}))}(i,f,o.JSModuleURL).then(F,P)})).catch(P)}))),await j),Y=async(F,P)=>{const f=F instanceof ArrayBuffer?new Uint8Array(F):F;return await new Promise(((F,c)=>{T().then((()=>{const N=u++,q=P=>{"transcode"===P.data.action&&P.data.id===N&&(i.removeEventListener("message",q),P.data.success?F(P.data):c("Transcode is not supported on this device"))};i.addEventListener("message",q);const H=new Uint8Array(f.byteLength);H.set(new Uint8Array(f.buffer,f.byteOffset,f.byteLength)),i.postMessage({action:"transcode",id:N,imageData:H,config:P,ignoreSupportedFormats:false},[H.buffer])}),(F=>{c(F)}))}))},t=(F,P)=>{var f;let c=null===(f=P._gl)||void 0===f?void 0:f.TEXTURE_2D;var N;F.isCube&&(c=null===(N=P._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);P._bindTextureDirectly(c,F,!0)},C=(F,P)=>{const f=F.getEngine();for(let A=0;A<P.fileInfo.images.length;A++){const o=P.fileInfo.images[A].levels[0];if(F._invertVScale=F.invertY,-1===P.format||P.format===c.cTFRGB565)if(F.type=10,F.format=4,!f._features.basisNeedsPOT||Math.log2(o.width)%1===0&&Math.log2(o.height)%1===0)F._invertVScale=!F.invertY,F.width=o.width+3&-4,F.height=o.height+3&-4,F.samplingMode=2,t(F,f),f._uploadDataToTextureDirectly(F,new Uint16Array(o.transcodedPixels.buffer),A,0,4,!0);else{const P=new H.b(f,2);F._invertVScale=F.invertY,P.type=10,P.format=4,P.width=o.width+3&-4,P.height=o.height+3&-4,t(P,f),f._uploadDataToTextureDirectly(P,new Uint16Array(o.transcodedPixels.buffer),A,0,4,!0),f._rescaleTexture(P,F,f.scenes[0],f._getInternalFormat(4),(()=>{f._releaseTexture(P),t(F,f)}))}else{F.width=o.width,F.height=o.height,F.generateMipMaps=P.fileInfo.images[A].levels.length>1;const c=L.GetInternalFormatFromBasisFormat(P.format,f);F.format=c,t(F,f);const H=P.fileInfo.images[A].levels;for(let P=0;P<H.length;P++){const N=H[P];f._uploadCompressedDataToTextureDirectly(F,c,N.width,N.height,N.transcodedPixels,A,P)}!f._features.basisNeedsPOT||Math.log2(F.width)%1===0&&Math.log2(F.height)%1===0||(N.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),F._cachedWrapU=q.e.CLAMP_ADDRESSMODE,F._cachedWrapV=q.e.CLAMP_ADDRESSMODE)}}},L={JSModuleURL:o.JSModuleURL,WasmModuleURL:o.WasmModuleURL,GetInternalFormatFromBasisFormat:(F,P)=>{let f;switch(F){case c.cTFETC1:f=36196;break;case c.cTFBC1:f=33776;break;case c.cTFBC4:f=33779;break;case c.cTFASTC_4x4:f=37808;break;case c.cTFETC2:f=37496;break;case c.cTFBC7:f=36492}if(void 0===f)throw"The chosen Basis transcoder format is not currently supported";return f},TranscodeAsync:Y,LoadTextureFromTranscodeResult:C};Object.defineProperty(L,"JSModuleURL",{get:function(){return o.JSModuleURL},set:function(F){o.JSModuleURL=F}}),Object.defineProperty(L,"WasmModuleURL",{get:function(){return o.WasmModuleURL},set:function(F){o.WasmModuleURL=F}});class J{constructor(){this.supportCascades=!1}loadCubeData(F,P,f,c,q){if(Array.isArray(F))return;const H=P.getEngine().getCaps(),A={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};Y(F,A).then((F=>{const f=F.fileInfo.images[0].levels.length>1&&P.generateMipMaps;C(P,F),P.getEngine()._setCubeMapTextureParams(P,f),P.isReady=!0,P.onLoadedObservable.notifyObservers(P),P.onLoadedObservable.clear(),c&&c()})).catch((F=>{N.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),P.isReady=!0,q&&q(F)}))}loadData(F,P,f){const c=P.getEngine().getCaps(),q={supportedCompressionFormats:{etc1:!!c.etc1,s3tc:!!c.s3tc,pvrtc:!!c.pvrtc,etc2:!!c.etc2,astc:!!c.astc,bc7:!!c.bptc}};Y(F,q).then((F=>{const c=F.fileInfo.images[0].levels[0],N=F.fileInfo.images[0].levels.length>1&&P.generateMipMaps;f(c.width,c.height,N,-1!==F.format,(()=>{C(P,F)}))})).catch((F=>{N.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.Tools.Warn(`Failed to transcode Basis file: ${F}`),f(0,0,!1,!1,(()=>{}),!0)}))}}}}]);