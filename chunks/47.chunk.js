"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[47],{13638:(B,I,C)=>{C.r(I),C.d(I,{_BasisTextureLoader:()=>o});var M,x=C(11018),y=C(11171),f=C(11129);function L(){const B=0,I=1,C=2,M=3,x=6,y=8,f=9,L=10,e=14;let g=null;function N(B,I,C,M,x){const y=B.getImageTranscodedSizeInBytes(I,C,M);let f=new Uint8Array(y);if(!B.transcodeImage(f,I,C,M,1,0))return null;if(x){f=function(B,I,C,M){const x=new Uint16Array(4),y=new Uint16Array(C*M),f=C/4,L=M/4;for(let e=0;e<L;e++)for(let M=0;M<f;M++){const L=I+8*(e*f+M);x[0]=B[L]|B[L+1]<<8,x[1]=B[L+2]|B[L+3]<<8,x[2]=(2*(31&x[0])+1*(31&x[1]))/3|(2*(2016&x[0])+1*(2016&x[1]))/3&2016|(2*(63488&x[0])+1*(63488&x[1]))/3&63488,x[3]=(2*(31&x[1])+1*(31&x[0]))/3|(2*(2016&x[1])+1*(2016&x[0]))/3&2016|(2*(63488&x[1])+1*(63488&x[0]))/3&63488;for(let I=0;I<4;I++){const f=B[L+4+I];let g=(4*e+I)*C+4*M;y[g++]=x[3&f],y[g++]=x[f>>2&3],y[g++]=x[f>>4&3],y[g++]=x[f>>6&3]}}return y}(f,0,B.getImageWidth(I,C)+3&-4,B.getImageHeight(I,C)+3&-4)}return f}onmessage=R=>{if("init"===R.data.action){if(R.data.url)try{importScripts(R.data.url)}catch(H){postMessage({action:"error",error:H})}g||(g=BASIS({wasmBinary:R.data.wasmBinary})),null!==g&&g.then((B=>{BASIS=B,B.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===R.data.action){const g=R.data.config,H=R.data.imageData,F=new BASIS.BasisFile(H),k=function(B){const I=B.getHasAlpha(),C=B.getNumImages(),M=[];for(let x=0;x<C;x++){const I={levels:[]},C=B.getNumLevels(x);for(let M=0;M<C;M++){const C={width:B.getImageWidth(x,M),height:B.getImageHeight(x,M)};I.levels.push(C)}M.push(I)}return{if:I,images:M}}(F);let q=R.data.ignoreSupportedFormats?null:function(g,N){let R=null;g.supportedCompressionFormats&&(R=g.supportedCompressionFormats.astc?L:g.supportedCompressionFormats.bc7?x:g.supportedCompressionFormats.s3tc?N.if?M:C:g.supportedCompressionFormats.pvrtc?N.if?f:y:g.supportedCompressionFormats.etc2?I:g.supportedCompressionFormats.etc1?B:e);return R}(R.data.config,k),S=!1;null===q&&(S=!0,q=k.if?M:C);let o=!0;F.startTranscoding()||(o=!1);const U=[];for(let B=0;B<k.images.length&&o;B++){const I=k.images[B];if(void 0===g.loadSingleImage||g.loadSingleImage===B){let C=I.levels.length;!1===g.loadMipmapLevels&&(C=1);for(let M=0;M<C;M++){const C=I.levels[M],x=N(F,B,M,q,S);if(!x){o=!1;break}C.transcodedPixels=x,U.push(C.transcodedPixels.buffer)}}}F.close(),F.delete(),S&&(q=-1),o?postMessage({action:"transcode",success:o,id:R.data.id,fileInfo:k,format:q},U):postMessage({action:"transcode",success:o,id:R.data.id})}}}!function(B){B[B.cTFETC1=0]="cTFETC1",B[B.cTFETC2=1]="cTFETC2",B[B.cTFBC1=2]="cTFBC1",B[B.cTFBC3=3]="cTFBC3",B[B.cTFBC4=4]="cTFBC4",B[B.cTFBC5=5]="cTFBC5",B[B.cTFBC7=6]="cTFBC7",B[B.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",B[B.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",B[B.cTFASTC_4x4=10]="cTFASTC_4x4",B[B.cTFATC_RGB=11]="cTFATC_RGB",B[B.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",B[B.cTFRGBA32=13]="cTFRGBA32",B[B.cTFRGB565=14]="cTFRGB565",B[B.cTFBGR565=15]="cTFBGR565",B[B.cTFRGBA4444=16]="cTFRGBA4444",B[B.cTFFXT1_RGB=17]="cTFFXT1_RGB",B[B.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",B[B.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",B[B.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",B[B.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(M||(M={}));const e={JSModuleURL:`${x.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${x.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let g=null,N=null,R=0;const H=async()=>(g||(g=new Promise(((B,I)=>{N?B(N):x.Tools.LoadFileAsync(x.Tools.GetBabylonScriptURL(e.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return I("Basis transcoder requires an environment with a URL constructor");const M=URL.createObjectURL(new Blob([`(${L})()`],{type:"application/javascript"}));N=new Worker(M),async function(B,I,C){return await new Promise(((M,y)=>{const f=I=>{"init"===I.data.action?(B.removeEventListener("message",f),M(B)):"error"===I.data.action&&y(I.data.error||"error initializing worker")};B.addEventListener("message",f),B.postMessage({action:"init",url:C?x.Tools.GetBabylonScriptURL(C):void 0,wasmBinary:I},[I])}))}(N,C,e.JSModuleURL).then(B,I)})).catch(I)}))),await g),F=async(B,I)=>{const C=B instanceof ArrayBuffer?new Uint8Array(B):B;return await new Promise(((B,M)=>{H().then((()=>{const x=R++,y=I=>{"transcode"===I.data.action&&I.data.id===x&&(N.removeEventListener("message",y),I.data.success?B(I.data):M("Transcode is not supported on this device"))};N.addEventListener("message",y);const f=new Uint8Array(C.byteLength);f.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),N.postMessage({action:"transcode",id:x,imageData:f,config:I,ignoreSupportedFormats:false},[f.buffer])}),(B=>{M(B)}))}))},k=(B,I)=>{var C;let M=null===(C=I._gl)||void 0===C?void 0:C.TEXTURE_2D;var x;B.isCube&&(M=null===(x=I._gl)||void 0===x?void 0:x.TEXTURE_CUBE_MAP);I._bindTextureDirectly(M,B,!0)},q=(B,I)=>{const C=B.getEngine();for(let L=0;L<I.fileInfo.images.length;L++){const e=I.fileInfo.images[L].levels[0];if(B._invertVScale=B.invertY,-1===I.format||I.format===M.cTFRGB565)if(B.type=10,B.format=4,!C._features.basisNeedsPOT||Math.log2(e.width)%1===0&&Math.log2(e.height)%1===0)B._invertVScale=!B.invertY,B.width=e.width+3&-4,B.height=e.height+3&-4,B.samplingMode=2,k(B,C),C._uploadDataToTextureDirectly(B,new Uint16Array(e.transcodedPixels.buffer),L,0,4,!0);else{const I=new f.b(C,2);B._invertVScale=B.invertY,I.type=10,I.format=4,I.width=e.width+3&-4,I.height=e.height+3&-4,k(I,C),C._uploadDataToTextureDirectly(I,new Uint16Array(e.transcodedPixels.buffer),L,0,4,!0),C._rescaleTexture(I,B,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(I),k(B,C)}))}else{B.width=e.width,B.height=e.height,B.generateMipMaps=I.fileInfo.images[L].levels.length>1;const M=S.GetInternalFormatFromBasisFormat(I.format,C);B.format=M,k(B,C);const f=I.fileInfo.images[L].levels;for(let I=0;I<f.length;I++){const x=f[I];C._uploadCompressedDataToTextureDirectly(B,M,x.width,x.height,x.transcodedPixels,L,I)}!C._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0||(x.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),B._cachedWrapU=y.c.CLAMP_ADDRESSMODE,B._cachedWrapV=y.c.CLAMP_ADDRESSMODE)}}},S={JSModuleURL:e.JSModuleURL,WasmModuleURL:e.WasmModuleURL,GetInternalFormatFromBasisFormat:(B,I)=>{let C;switch(B){case M.cTFETC1:C=36196;break;case M.cTFBC1:C=33776;break;case M.cTFBC4:C=33779;break;case M.cTFASTC_4x4:C=37808;break;case M.cTFETC2:C=37496;break;case M.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:F,LoadTextureFromTranscodeResult:q};Object.defineProperty(S,"JSModuleURL",{get:function(){return e.JSModuleURL},set:function(B){e.JSModuleURL=B}}),Object.defineProperty(S,"WasmModuleURL",{get:function(){return e.WasmModuleURL},set:function(B){e.WasmModuleURL=B}});class o{constructor(){this.supportCascades=!1}loadCubeData(B,I,C,M,y){if(Array.isArray(B))return;const f=I.getEngine().getCaps(),L={supportedCompressionFormats:{etc1:!!f.etc1,s3tc:!!f.s3tc,pvrtc:!!f.pvrtc,etc2:!!f.etc2,astc:!!f.astc,bc7:!!f.bptc}};F(B,L).then((B=>{const C=B.fileInfo.images[0].levels.length>1&&I.generateMipMaps;q(I,B),I.getEngine()._setCubeMapTextureParams(I,C),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),M&&M()})).catch((B=>{x.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),I.isReady=!0,y&&y(B)}))}loadData(B,I,C){const M=I.getEngine().getCaps(),y={supportedCompressionFormats:{etc1:!!M.etc1,s3tc:!!M.s3tc,pvrtc:!!M.pvrtc,etc2:!!M.etc2,astc:!!M.astc,bc7:!!M.bptc}};F(B,y).then((B=>{const M=B.fileInfo.images[0].levels[0],x=B.fileInfo.images[0].levels.length>1&&I.generateMipMaps;C(M.width,M.height,x,-1!==B.format,(()=>{q(I,B)}))})).catch((B=>{x.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.Tools.Warn(`Failed to transcode Basis file: ${B}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);