"use strict";(self.wy695la1oic=self.wy695la1oic||[]).push([[47],{13853:(S,v,D)=>{D.r(v),D.d(v,{_BasisTextureLoader:()=>K});var z,e=D(11175),N=D(11350),m=D(11301);function B(){const S=0,v=1,D=2,z=3,e=6,N=8,m=9,B=10,g=14;let E=null;function h(S,v,D,z,e){const N=S.getImageTranscodedSizeInBytes(v,D,z);let m=new Uint8Array(N);if(!S.transcodeImage(m,v,D,z,1,0))return null;if(e){m=function(S,v,D,z){const e=new Uint16Array(4),N=new Uint16Array(D*z),m=D/4,B=z/4;for(let g=0;g<B;g++)for(let z=0;z<m;z++){const B=v+8*(g*m+z);e[0]=S[B]|S[B+1]<<8,e[1]=S[B+2]|S[B+3]<<8,e[2]=(2*(31&e[0])+1*(31&e[1]))/3|(2*(2016&e[0])+1*(2016&e[1]))/3&2016|(2*(63488&e[0])+1*(63488&e[1]))/3&63488,e[3]=(2*(31&e[1])+1*(31&e[0]))/3|(2*(2016&e[1])+1*(2016&e[0]))/3&2016|(2*(63488&e[1])+1*(63488&e[0]))/3&63488;for(let v=0;v<4;v++){const m=S[B+4+v];let E=(4*g+v)*D+4*z;N[E++]=e[3&m],N[E++]=e[m>>2&3],N[E++]=e[m>>4&3],N[E++]=e[m>>6&3]}}return N}(m,0,S.getImageWidth(v,D)+3&-4,S.getImageHeight(v,D)+3&-4)}return m}onmessage=A=>{if("init"===A.data.action){if(A.data.url)try{importScripts(A.data.url)}catch(w){postMessage({action:"error",error:w})}E||(E=BASIS({wasmBinary:A.data.wasmBinary})),null!==E&&E.then((S=>{BASIS=S,S.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===A.data.action){const E=A.data.config,w=A.data.imageData,n=new BASIS.BasisFile(w),R=function(S){const v=S.getHasAlpha(),D=S.getNumImages(),z=[];for(let e=0;e<D;e++){const v={levels:[]},D=S.getNumLevels(e);for(let z=0;z<D;z++){const D={width:S.getImageWidth(e,z),height:S.getImageHeight(e,z)};v.levels.push(D)}z.push(v)}return{de:v,images:z}}(n);let O=A.data.ignoreSupportedFormats?null:function(E,h){let A=null;E.supportedCompressionFormats&&(A=E.supportedCompressionFormats.astc?B:E.supportedCompressionFormats.bc7?e:E.supportedCompressionFormats.s3tc?h.de?z:D:E.supportedCompressionFormats.pvrtc?h.de?m:N:E.supportedCompressionFormats.etc2?v:E.supportedCompressionFormats.etc1?S:g);return A}(A.data.config,R),I=!1;null===O&&(I=!0,O=R.de?z:D);let K=!0;n.startTranscoding()||(K=!1);const q=[];for(let S=0;S<R.images.length&&K;S++){const v=R.images[S];if(void 0===E.loadSingleImage||E.loadSingleImage===S){let D=v.levels.length;!1===E.loadMipmapLevels&&(D=1);for(let z=0;z<D;z++){const D=v.levels[z],e=h(n,S,z,O,I);if(!e){K=!1;break}D.transcodedPixels=e,q.push(D.transcodedPixels.buffer)}}}n.close(),n.delete(),I&&(O=-1),K?postMessage({action:"transcode",success:K,id:A.data.id,fileInfo:R,format:O},q):postMessage({action:"transcode",success:K,id:A.data.id})}}}!function(S){S[S.cTFETC1=0]="cTFETC1",S[S.cTFETC2=1]="cTFETC2",S[S.cTFBC1=2]="cTFBC1",S[S.cTFBC3=3]="cTFBC3",S[S.cTFBC4=4]="cTFBC4",S[S.cTFBC5=5]="cTFBC5",S[S.cTFBC7=6]="cTFBC7",S[S.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",S[S.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",S[S.cTFASTC_4x4=10]="cTFASTC_4x4",S[S.cTFATC_RGB=11]="cTFATC_RGB",S[S.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",S[S.cTFRGBA32=13]="cTFRGBA32",S[S.cTFRGB565=14]="cTFRGB565",S[S.cTFBGR565=15]="cTFBGR565",S[S.cTFRGBA4444=16]="cTFRGBA4444",S[S.cTFFXT1_RGB=17]="cTFFXT1_RGB",S[S.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",S[S.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",S[S.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",S[S.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(z||(z={}));const g={JSModuleURL:`${e.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${e.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let E=null,h=null,A=0;const w=async()=>(E||(E=new Promise(((S,v)=>{h?S(h):e.Tools.LoadFileAsync(e.Tools.GetBabylonScriptURL(g.WasmModuleURL)).then((D=>{if("function"!==typeof URL)return v("Basis transcoder requires an environment with a URL constructor");const z=URL.createObjectURL(new Blob([`(${B})()`],{type:"application/javascript"}));h=new Worker(z),async function(S,v,D){return await new Promise(((z,N)=>{const m=v=>{"init"===v.data.action?(S.removeEventListener("message",m),z(S)):"error"===v.data.action&&N(v.data.error||"error initializing worker")};S.addEventListener("message",m),S.postMessage({action:"init",url:D?e.Tools.GetBabylonScriptURL(D):void 0,wasmBinary:v},[v])}))}(h,D,g.JSModuleURL).then(S,v)})).catch(v)}))),await E),n=async(S,v)=>{const D=S instanceof ArrayBuffer?new Uint8Array(S):S;return await new Promise(((S,z)=>{w().then((()=>{const e=A++,N=v=>{"transcode"===v.data.action&&v.data.id===e&&(h.removeEventListener("message",N),v.data.success?S(v.data):z("Transcode is not supported on this device"))};h.addEventListener("message",N);const m=new Uint8Array(D.byteLength);m.set(new Uint8Array(D.buffer,D.byteOffset,D.byteLength)),h.postMessage({action:"transcode",id:e,imageData:m,config:v,ignoreSupportedFormats:false},[m.buffer])}),(S=>{z(S)}))}))},R=(S,v)=>{var D;let z=null===(D=v._gl)||void 0===D?void 0:D.TEXTURE_2D;var e;S.isCube&&(z=null===(e=v._gl)||void 0===e?void 0:e.TEXTURE_CUBE_MAP);v._bindTextureDirectly(z,S,!0)},O=(S,v)=>{const D=S.getEngine();for(let B=0;B<v.fileInfo.images.length;B++){const g=v.fileInfo.images[B].levels[0];if(S._invertVScale=S.invertY,-1===v.format||v.format===z.cTFRGB565)if(S.type=10,S.format=4,!D._features.basisNeedsPOT||Math.log2(g.width)%1===0&&Math.log2(g.height)%1===0)S._invertVScale=!S.invertY,S.width=g.width+3&-4,S.height=g.height+3&-4,S.samplingMode=2,R(S,D),D._uploadDataToTextureDirectly(S,new Uint16Array(g.transcodedPixels.buffer),B,0,4,!0);else{const v=new m.b(D,2);S._invertVScale=S.invertY,v.type=10,v.format=4,v.width=g.width+3&-4,v.height=g.height+3&-4,R(v,D),D._uploadDataToTextureDirectly(v,new Uint16Array(g.transcodedPixels.buffer),B,0,4,!0),D._rescaleTexture(v,S,D.scenes[0],D._getInternalFormat(4),(()=>{D._releaseTexture(v),R(S,D)}))}else{S.width=g.width,S.height=g.height,S.generateMipMaps=v.fileInfo.images[B].levels.length>1;const z=I.GetInternalFormatFromBasisFormat(v.format,D);S.format=z,R(S,D);const m=v.fileInfo.images[B].levels;for(let v=0;v<m.length;v++){const e=m[v];D._uploadCompressedDataToTextureDirectly(S,z,e.width,e.height,e.transcodedPixels,B,v)}!D._features.basisNeedsPOT||Math.log2(S.width)%1===0&&Math.log2(S.height)%1===0||(e.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),S._cachedWrapU=N.d.CLAMP_ADDRESSMODE,S._cachedWrapV=N.d.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:g.JSModuleURL,WasmModuleURL:g.WasmModuleURL,GetInternalFormatFromBasisFormat:(S,v)=>{let D;switch(S){case z.cTFETC1:D=36196;break;case z.cTFBC1:D=33776;break;case z.cTFBC4:D=33779;break;case z.cTFASTC_4x4:D=37808;break;case z.cTFETC2:D=37496;break;case z.cTFBC7:D=36492}if(void 0===D)throw"The chosen Basis transcoder format is not currently supported";return D},TranscodeAsync:n,LoadTextureFromTranscodeResult:O};Object.defineProperty(I,"JSModuleURL",{get:function(){return g.JSModuleURL},set:function(S){g.JSModuleURL=S}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return g.WasmModuleURL},set:function(S){g.WasmModuleURL=S}});class K{constructor(){this.supportCascades=!1}loadCubeData(S,v,D,z,N){if(Array.isArray(S))return;const m=v.getEngine().getCaps(),B={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};n(S,B).then((S=>{const D=S.fileInfo.images[0].levels.length>1&&v.generateMipMaps;O(v,S),v.getEngine()._setCubeMapTextureParams(v,D),v.isReady=!0,v.onLoadedObservable.notifyObservers(v),v.onLoadedObservable.clear(),z&&z()})).catch((S=>{e.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),v.isReady=!0,N&&N(S)}))}loadData(S,v,D){const z=v.getEngine().getCaps(),N={supportedCompressionFormats:{etc1:!!z.etc1,s3tc:!!z.s3tc,pvrtc:!!z.pvrtc,etc2:!!z.etc2,astc:!!z.astc,bc7:!!z.bptc}};n(S,N).then((S=>{const z=S.fileInfo.images[0].levels[0],e=S.fileInfo.images[0].levels.length>1&&v.generateMipMaps;D(z.width,z.height,e,-1!==S.format,(()=>{O(v,S)}))})).catch((S=>{e.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),e.Tools.Warn(`Failed to transcode Basis file: ${S}`),D(0,0,!1,!1,(()=>{}),!0)}))}}}}]);