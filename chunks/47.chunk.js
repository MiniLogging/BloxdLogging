"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[47],{13542:(N,q,C)=>{C.r(q),C.d(q,{_BasisTextureLoader:()=>r});var d,U=C(10945),W=C(11101),a=C(11055);function F(){const N=0,q=1,C=2,d=3,U=6,W=8,a=9,F=10,w=14;let A=null;function n(N,q,C,d,U){const W=N.getImageTranscodedSizeInBytes(q,C,d);let a=new Uint8Array(W);if(!N.transcodeImage(a,q,C,d,1,0))return null;if(U){a=function(N,q,C,d){const U=new Uint16Array(4),W=new Uint16Array(C*d),a=C/4,F=d/4;for(let w=0;w<F;w++)for(let d=0;d<a;d++){const F=q+8*(w*a+d);U[0]=N[F]|N[F+1]<<8,U[1]=N[F+2]|N[F+3]<<8,U[2]=(2*(31&U[0])+1*(31&U[1]))/3|(2*(2016&U[0])+1*(2016&U[1]))/3&2016|(2*(63488&U[0])+1*(63488&U[1]))/3&63488,U[3]=(2*(31&U[1])+1*(31&U[0]))/3|(2*(2016&U[1])+1*(2016&U[0]))/3&2016|(2*(63488&U[1])+1*(63488&U[0]))/3&63488;for(let q=0;q<4;q++){const a=N[F+4+q];let A=(4*w+q)*C+4*d;W[A++]=U[3&a],W[A++]=U[a>>2&3],W[A++]=U[a>>4&3],W[A++]=U[a>>6&3]}}return W}(a,0,N.getImageWidth(q,C)+3&-4,N.getImageHeight(q,C)+3&-4)}return a}onmessage=t=>{if("init"===t.data.action){if(t.data.url)try{importScripts(t.data.url)}catch(V){postMessage({action:"error",error:V})}A||(A=BASIS({wasmBinary:t.data.wasmBinary})),null!==A&&A.then((N=>{BASIS=N,N.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===t.data.action){const A=t.data.config,V=t.data.imageData,Z=new BASIS.BasisFile(V),J=function(N){const q=N.getHasAlpha(),C=N.getNumImages(),d=[];for(let U=0;U<C;U++){const q={levels:[]},C=N.getNumLevels(U);for(let d=0;d<C;d++){const C={width:N.getImageWidth(U,d),height:N.getImageHeight(U,d)};q.levels.push(C)}d.push(q)}return{pd:q,images:d}}(Z);let Q=t.data.ignoreSupportedFormats?null:function(A,n){let t=null;A.supportedCompressionFormats&&(t=A.supportedCompressionFormats.astc?F:A.supportedCompressionFormats.bc7?U:A.supportedCompressionFormats.s3tc?n.pd?d:C:A.supportedCompressionFormats.pvrtc?n.pd?a:W:A.supportedCompressionFormats.etc2?q:A.supportedCompressionFormats.etc1?N:w);return t}(t.data.config,J),v=!1;null===Q&&(v=!0,Q=J.pd?d:C);let r=!0;Z.startTranscoding()||(r=!1);const O=[];for(let N=0;N<J.images.length&&r;N++){const q=J.images[N];if(void 0===A.loadSingleImage||A.loadSingleImage===N){let C=q.levels.length;!1===A.loadMipmapLevels&&(C=1);for(let d=0;d<C;d++){const C=q.levels[d],U=n(Z,N,d,Q,v);if(!U){r=!1;break}C.transcodedPixels=U,O.push(C.transcodedPixels.buffer)}}}Z.close(),Z.delete(),v&&(Q=-1),r?postMessage({action:"transcode",success:r,id:t.data.id,fileInfo:J,format:Q},O):postMessage({action:"transcode",success:r,id:t.data.id})}}}!function(N){N[N.cTFETC1=0]="cTFETC1",N[N.cTFETC2=1]="cTFETC2",N[N.cTFBC1=2]="cTFBC1",N[N.cTFBC3=3]="cTFBC3",N[N.cTFBC4=4]="cTFBC4",N[N.cTFBC5=5]="cTFBC5",N[N.cTFBC7=6]="cTFBC7",N[N.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",N[N.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",N[N.cTFASTC_4x4=10]="cTFASTC_4x4",N[N.cTFATC_RGB=11]="cTFATC_RGB",N[N.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",N[N.cTFRGBA32=13]="cTFRGBA32",N[N.cTFRGB565=14]="cTFRGB565",N[N.cTFBGR565=15]="cTFBGR565",N[N.cTFRGBA4444=16]="cTFRGBA4444",N[N.cTFFXT1_RGB=17]="cTFFXT1_RGB",N[N.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",N[N.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",N[N.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",N[N.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(d||(d={}));const w={JSModuleURL:`${U.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${U.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let A=null,n=null,t=0;const V=async()=>(A||(A=new Promise(((N,q)=>{n?N(n):U.Tools.LoadFileAsync(U.Tools.GetBabylonScriptURL(w.WasmModuleURL)).then((C=>{if("function"!==typeof URL)return q("Basis transcoder requires an environment with a URL constructor");const d=URL.createObjectURL(new Blob([`(${F})()`],{type:"application/javascript"}));n=new Worker(d),async function(N,q,C){return await new Promise(((d,W)=>{const a=q=>{"init"===q.data.action?(N.removeEventListener("message",a),d(N)):"error"===q.data.action&&W(q.data.error||"error initializing worker")};N.addEventListener("message",a),N.postMessage({action:"init",url:C?U.Tools.GetBabylonScriptURL(C):void 0,wasmBinary:q},[q])}))}(n,C,w.JSModuleURL).then(N,q)})).catch(q)}))),await A),Z=async(N,q)=>{const C=N instanceof ArrayBuffer?new Uint8Array(N):N;return await new Promise(((N,d)=>{V().then((()=>{const U=t++,W=q=>{"transcode"===q.data.action&&q.data.id===U&&(n.removeEventListener("message",W),q.data.success?N(q.data):d("Transcode is not supported on this device"))};n.addEventListener("message",W);const a=new Uint8Array(C.byteLength);a.set(new Uint8Array(C.buffer,C.byteOffset,C.byteLength)),n.postMessage({action:"transcode",id:U,imageData:a,config:q,ignoreSupportedFormats:false},[a.buffer])}),(N=>{d(N)}))}))},J=(N,q)=>{var C;let d=null===(C=q._gl)||void 0===C?void 0:C.TEXTURE_2D;var U;N.isCube&&(d=null===(U=q._gl)||void 0===U?void 0:U.TEXTURE_CUBE_MAP);q._bindTextureDirectly(d,N,!0)},Q=(N,q)=>{const C=N.getEngine();for(let F=0;F<q.fileInfo.images.length;F++){const w=q.fileInfo.images[F].levels[0];if(N._invertVScale=N.invertY,-1===q.format||q.format===d.cTFRGB565)if(N.type=10,N.format=4,!C._features.basisNeedsPOT||Math.log2(w.width)%1===0&&Math.log2(w.height)%1===0)N._invertVScale=!N.invertY,N.width=w.width+3&-4,N.height=w.height+3&-4,N.samplingMode=2,J(N,C),C._uploadDataToTextureDirectly(N,new Uint16Array(w.transcodedPixels.buffer),F,0,4,!0);else{const q=new a.e(C,2);N._invertVScale=N.invertY,q.type=10,q.format=4,q.width=w.width+3&-4,q.height=w.height+3&-4,J(q,C),C._uploadDataToTextureDirectly(q,new Uint16Array(w.transcodedPixels.buffer),F,0,4,!0),C._rescaleTexture(q,N,C.scenes[0],C._getInternalFormat(4),(()=>{C._releaseTexture(q),J(N,C)}))}else{N.width=w.width,N.height=w.height,N.generateMipMaps=q.fileInfo.images[F].levels.length>1;const d=v.GetInternalFormatFromBasisFormat(q.format,C);N.format=d,J(N,C);const a=q.fileInfo.images[F].levels;for(let q=0;q<a.length;q++){const U=a[q];C._uploadCompressedDataToTextureDirectly(N,d,U.width,U.height,U.transcodedPixels,F,q)}!C._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0||(U.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),N._cachedWrapU=W.c.CLAMP_ADDRESSMODE,N._cachedWrapV=W.c.CLAMP_ADDRESSMODE)}}},v={JSModuleURL:w.JSModuleURL,WasmModuleURL:w.WasmModuleURL,GetInternalFormatFromBasisFormat:(N,q)=>{let C;switch(N){case d.cTFETC1:C=36196;break;case d.cTFBC1:C=33776;break;case d.cTFBC4:C=33779;break;case d.cTFASTC_4x4:C=37808;break;case d.cTFETC2:C=37496;break;case d.cTFBC7:C=36492}if(void 0===C)throw"The chosen Basis transcoder format is not currently supported";return C},TranscodeAsync:Z,LoadTextureFromTranscodeResult:Q};Object.defineProperty(v,"JSModuleURL",{get:function(){return w.JSModuleURL},set:function(N){w.JSModuleURL=N}}),Object.defineProperty(v,"WasmModuleURL",{get:function(){return w.WasmModuleURL},set:function(N){w.WasmModuleURL=N}});class r{constructor(){this.supportCascades=!1}loadCubeData(N,q,C,d,W){if(Array.isArray(N))return;const a=q.getEngine().getCaps(),F={supportedCompressionFormats:{etc1:!!a.etc1,s3tc:!!a.s3tc,pvrtc:!!a.pvrtc,etc2:!!a.etc2,astc:!!a.astc,bc7:!!a.bptc}};Z(N,F).then((N=>{const C=N.fileInfo.images[0].levels.length>1&&q.generateMipMaps;Q(q,N),q.getEngine()._setCubeMapTextureParams(q,C),q.isReady=!0,q.onLoadedObservable.notifyObservers(q),q.onLoadedObservable.clear(),d&&d()})).catch((N=>{U.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.isReady=!0,W&&W(N)}))}loadData(N,q,C){const d=q.getEngine().getCaps(),W={supportedCompressionFormats:{etc1:!!d.etc1,s3tc:!!d.s3tc,pvrtc:!!d.pvrtc,etc2:!!d.etc2,astc:!!d.astc,bc7:!!d.bptc}};Z(N,W).then((N=>{const d=N.fileInfo.images[0].levels[0],U=N.fileInfo.images[0].levels.length>1&&q.generateMipMaps;C(d.width,d.height,U,-1!==N.format,(()=>{Q(q,N)}))})).catch((N=>{U.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.Tools.Warn(`Failed to transcode Basis file: ${N}`),C(0,0,!1,!1,(()=>{}),!0)}))}}}}]);