"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[47],{15330:(I,x,L)=>{L.r(x),L.d(x,{_BasisTextureLoader:()=>s});var F,X=L(12791),G=L(12965),Y=L(12909);function p(){const I=0,x=1,L=2,F=3,X=6,G=8,Y=9,p=10,B=14;let l=null;function W(I,x,L,F,X){const G=I.getImageTranscodedSizeInBytes(x,L,F);let Y=new Uint8Array(G);if(!I.transcodeImage(Y,x,L,F,1,0))return null;if(X){Y=function(I,x,L,F){const X=new Uint16Array(4),G=new Uint16Array(L*F),Y=L/4,p=F/4;for(let B=0;B<p;B++)for(let F=0;F<Y;F++){const p=x+8*(B*Y+F);X[0]=I[p]|I[p+1]<<8,X[1]=I[p+2]|I[p+3]<<8,X[2]=(2*(31&X[0])+1*(31&X[1]))/3|(2*(2016&X[0])+1*(2016&X[1]))/3&2016|(2*(63488&X[0])+1*(63488&X[1]))/3&63488,X[3]=(2*(31&X[1])+1*(31&X[0]))/3|(2*(2016&X[1])+1*(2016&X[0]))/3&2016|(2*(63488&X[1])+1*(63488&X[0]))/3&63488;for(let x=0;x<4;x++){const Y=I[p+4+x];let l=(4*B+x)*L+4*F;G[l++]=X[3&Y],G[l++]=X[Y>>2&3],G[l++]=X[Y>>4&3],G[l++]=X[Y>>6&3]}}return G}(Y,0,I.getImageWidth(x,L)+3&-4,I.getImageHeight(x,L)+3&-4)}return Y}onmessage=Q=>{if("init"===Q.data.action){if(Q.data.url)try{importScripts(Q.data.url)}catch(e){postMessage({action:"error",error:e})}l||(l=BASIS({wasmBinary:Q.data.wasmBinary})),null!==l&&l.then((I=>{BASIS=I,I.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Q.data.action){const l=Q.data.config,e=Q.data.imageData,g=new BASIS.BasisFile(e),v=function(I){const x=I.getHasAlpha(),L=I.getNumImages(),F=[];for(let X=0;X<L;X++){const x={levels:[]},L=I.getNumLevels(X);for(let F=0;F<L;F++){const L={width:I.getImageWidth(X,F),height:I.getImageHeight(X,F)};x.levels.push(L)}F.push(x)}return{bp:x,images:F}}(g);let z=Q.data.ignoreSupportedFormats?null:function(l,W){let Q=null;l.supportedCompressionFormats&&(Q=l.supportedCompressionFormats.astc?p:l.supportedCompressionFormats.bc7?X:l.supportedCompressionFormats.s3tc?W.bp?F:L:l.supportedCompressionFormats.pvrtc?W.bp?Y:G:l.supportedCompressionFormats.etc2?x:l.supportedCompressionFormats.etc1?I:B);return Q}(Q.data.config,v),H=!1;null===z&&(H=!0,z=v.bp?F:L);let s=!0;g.startTranscoding()||(s=!1);const U=[];for(let I=0;I<v.images.length&&s;I++){const x=v.images[I];if(void 0===l.loadSingleImage||l.loadSingleImage===I){let L=x.levels.length;!1===l.loadMipmapLevels&&(L=1);for(let F=0;F<L;F++){const L=x.levels[F],X=W(g,I,F,z,H);if(!X){s=!1;break}L.transcodedPixels=X,U.push(L.transcodedPixels.buffer)}}}g.close(),g.delete(),H&&(z=-1),s?postMessage({action:"transcode",success:s,id:Q.data.id,fileInfo:v,format:z},U):postMessage({action:"transcode",success:s,id:Q.data.id})}}}!function(I){I[I.cTFETC1=0]="cTFETC1",I[I.cTFETC2=1]="cTFETC2",I[I.cTFBC1=2]="cTFBC1",I[I.cTFBC3=3]="cTFBC3",I[I.cTFBC4=4]="cTFBC4",I[I.cTFBC5=5]="cTFBC5",I[I.cTFBC7=6]="cTFBC7",I[I.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",I[I.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",I[I.cTFASTC_4x4=10]="cTFASTC_4x4",I[I.cTFATC_RGB=11]="cTFATC_RGB",I[I.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",I[I.cTFRGBA32=13]="cTFRGBA32",I[I.cTFRGB565=14]="cTFRGB565",I[I.cTFBGR565=15]="cTFBGR565",I[I.cTFRGBA4444=16]="cTFRGBA4444",I[I.cTFFXT1_RGB=17]="cTFFXT1_RGB",I[I.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",I[I.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",I[I.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",I[I.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(F||(F={}));const B={JSModuleURL:`${X.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${X.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let l=null,W=null,Q=0;const e=async()=>(l||(l=new Promise(((I,x)=>{W?I(W):X.Tools.LoadFileAsync(X.Tools.GetBabylonScriptURL(B.WasmModuleURL)).then((L=>{if("function"!==typeof URL)return x("Basis transcoder requires an environment with a URL constructor");const F=URL.createObjectURL(new Blob([`(${p})()`],{type:"application/javascript"}));W=new Worker(F),async function(I,x,L){return await new Promise(((F,G)=>{const Y=x=>{"init"===x.data.action?(I.removeEventListener("message",Y),F(I)):"error"===x.data.action&&G(x.data.error||"error initializing worker")};I.addEventListener("message",Y),I.postMessage({action:"init",url:L?X.Tools.GetBabylonScriptURL(L):void 0,wasmBinary:x},[x])}))}(W,L,B.JSModuleURL).then(I,x)})).catch(x)}))),await l),g=async(I,x)=>{const L=I instanceof ArrayBuffer?new Uint8Array(I):I;return await new Promise(((I,F)=>{e().then((()=>{const X=Q++,G=x=>{"transcode"===x.data.action&&x.data.id===X&&(W.removeEventListener("message",G),x.data.success?I(x.data):F("Transcode is not supported on this device"))};W.addEventListener("message",G);const Y=new Uint8Array(L.byteLength);Y.set(new Uint8Array(L.buffer,L.byteOffset,L.byteLength)),W.postMessage({action:"transcode",id:X,imageData:Y,config:x,ignoreSupportedFormats:false},[Y.buffer])}),(I=>{F(I)}))}))},v=(I,x)=>{var L;let F=null===(L=x._gl)||void 0===L?void 0:L.TEXTURE_2D;var X;I.isCube&&(F=null===(X=x._gl)||void 0===X?void 0:X.TEXTURE_CUBE_MAP);x._bindTextureDirectly(F,I,!0)},z=(I,x)=>{const L=I.getEngine();for(let p=0;p<x.fileInfo.images.length;p++){const B=x.fileInfo.images[p].levels[0];if(I._invertVScale=I.invertY,-1===x.format||x.format===F.cTFRGB565)if(I.type=10,I.format=4,!L._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0)I._invertVScale=!I.invertY,I.width=B.width+3&-4,I.height=B.height+3&-4,I.samplingMode=2,v(I,L),L._uploadDataToTextureDirectly(I,new Uint16Array(B.transcodedPixels.buffer),p,0,4,!0);else{const x=new Y.d(L,2);I._invertVScale=I.invertY,x.type=10,x.format=4,x.width=B.width+3&-4,x.height=B.height+3&-4,v(x,L),L._uploadDataToTextureDirectly(x,new Uint16Array(B.transcodedPixels.buffer),p,0,4,!0),L._rescaleTexture(x,I,L.scenes[0],L._getInternalFormat(4),(()=>{L._releaseTexture(x),v(I,L)}))}else{I.width=B.width,I.height=B.height,I.generateMipMaps=x.fileInfo.images[p].levels.length>1;const F=H.GetInternalFormatFromBasisFormat(x.format,L);I.format=F,v(I,L);const Y=x.fileInfo.images[p].levels;for(let x=0;x<Y.length;x++){const X=Y[x];L._uploadCompressedDataToTextureDirectly(I,F,X.width,X.height,X.transcodedPixels,p,x)}!L._features.basisNeedsPOT||Math.log2(I.width)%1===0&&Math.log2(I.height)%1===0||(X.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),I._cachedWrapU=G.d.CLAMP_ADDRESSMODE,I._cachedWrapV=G.d.CLAMP_ADDRESSMODE)}}},H={JSModuleURL:B.JSModuleURL,WasmModuleURL:B.WasmModuleURL,GetInternalFormatFromBasisFormat:(I,x)=>{let L;switch(I){case F.cTFETC1:L=36196;break;case F.cTFBC1:L=33776;break;case F.cTFBC4:L=33779;break;case F.cTFASTC_4x4:L=37808;break;case F.cTFETC2:L=37496;break;case F.cTFBC7:L=36492}if(void 0===L)throw"The chosen Basis transcoder format is not currently supported";return L},TranscodeAsync:g,LoadTextureFromTranscodeResult:z};Object.defineProperty(H,"JSModuleURL",{get:function(){return B.JSModuleURL},set:function(I){B.JSModuleURL=I}}),Object.defineProperty(H,"WasmModuleURL",{get:function(){return B.WasmModuleURL},set:function(I){B.WasmModuleURL=I}});class s{constructor(){this.supportCascades=!1}loadCubeData(I,x,L,F,G){if(Array.isArray(I))return;const Y=x.getEngine().getCaps(),p={supportedCompressionFormats:{etc1:!!Y.etc1,s3tc:!!Y.s3tc,pvrtc:!!Y.pvrtc,etc2:!!Y.etc2,astc:!!Y.astc,bc7:!!Y.bptc}};g(I,p).then((I=>{const L=I.fileInfo.images[0].levels.length>1&&x.generateMipMaps;z(x,I),x.getEngine()._setCubeMapTextureParams(x,L),x.isReady=!0,x.onLoadedObservable.notifyObservers(x),x.onLoadedObservable.clear(),F&&F()})).catch((I=>{X.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),x.isReady=!0,G&&G(I)}))}loadData(I,x,L){const F=x.getEngine().getCaps(),G={supportedCompressionFormats:{etc1:!!F.etc1,s3tc:!!F.s3tc,pvrtc:!!F.pvrtc,etc2:!!F.etc2,astc:!!F.astc,bc7:!!F.bptc}};g(I,G).then((I=>{const F=I.fileInfo.images[0].levels[0],X=I.fileInfo.images[0].levels.length>1&&x.generateMipMaps;L(F.width,F.height,X,-1!==I.format,(()=>{z(x,I)}))})).catch((I=>{X.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),X.Tools.Warn(`Failed to transcode Basis file: ${I}`),L(0,0,!1,!1,(()=>{}),!0)}))}}}}]);