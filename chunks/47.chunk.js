"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[47],{13665:(P,f,Y)=>{Y.r(f),Y.d(f,{_BasisTextureLoader:()=>K});var C,q=Y(11014),m=Y(11160),L=Y(11119);function o(){const P=0,f=1,Y=2,C=3,q=6,m=8,L=9,o=10,w=14;let d=null;function R(P,f,Y,C,q){const m=P.getImageTranscodedSizeInBytes(f,Y,C);let L=new Uint8Array(m);if(!P.transcodeImage(L,f,Y,C,1,0))return null;if(q){L=function(P,f,Y,C){const q=new Uint16Array(4),m=new Uint16Array(Y*C),L=Y/4,o=C/4;for(let w=0;w<o;w++)for(let C=0;C<L;C++){const o=f+8*(w*L+C);q[0]=P[o]|P[o+1]<<8,q[1]=P[o+2]|P[o+3]<<8,q[2]=(2*(31&q[0])+1*(31&q[1]))/3|(2*(2016&q[0])+1*(2016&q[1]))/3&2016|(2*(63488&q[0])+1*(63488&q[1]))/3&63488,q[3]=(2*(31&q[1])+1*(31&q[0]))/3|(2*(2016&q[1])+1*(2016&q[0]))/3&2016|(2*(63488&q[1])+1*(63488&q[0]))/3&63488;for(let f=0;f<4;f++){const L=P[o+4+f];let d=(4*w+f)*Y+4*C;m[d++]=q[3&L],m[d++]=q[L>>2&3],m[d++]=q[L>>4&3],m[d++]=q[L>>6&3]}}return m}(L,0,P.getImageWidth(f,Y)+3&-4,P.getImageHeight(f,Y)+3&-4)}return L}onmessage=y=>{if("init"===y.data.action){if(y.data.url)try{importScripts(y.data.url)}catch(r){postMessage({action:"error",error:r})}d||(d=BASIS({wasmBinary:y.data.wasmBinary})),null!==d&&d.then((P=>{BASIS=P,P.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===y.data.action){const d=y.data.config,r=y.data.imageData,i=new BASIS.BasisFile(r),u=function(P){const f=P.getHasAlpha(),Y=P.getNumImages(),C=[];for(let q=0;q<Y;q++){const f={levels:[]},Y=P.getNumLevels(q);for(let C=0;C<Y;C++){const Y={width:P.getImageWidth(q,C),height:P.getImageHeight(q,C)};f.levels.push(Y)}C.push(f)}return{Gf:f,images:C}}(i);let g=y.data.ignoreSupportedFormats?null:function(d,R){let y=null;d.supportedCompressionFormats&&(y=d.supportedCompressionFormats.astc?o:d.supportedCompressionFormats.bc7?q:d.supportedCompressionFormats.s3tc?R.Gf?C:Y:d.supportedCompressionFormats.pvrtc?R.Gf?L:m:d.supportedCompressionFormats.etc2?f:d.supportedCompressionFormats.etc1?P:w);return y}(y.data.config,u),S=!1;null===g&&(S=!0,g=u.Gf?C:Y);let K=!0;i.startTranscoding()||(K=!1);const M=[];for(let P=0;P<u.images.length&&K;P++){const f=u.images[P];if(void 0===d.loadSingleImage||d.loadSingleImage===P){let Y=f.levels.length;!1===d.loadMipmapLevels&&(Y=1);for(let C=0;C<Y;C++){const Y=f.levels[C],q=R(i,P,C,g,S);if(!q){K=!1;break}Y.transcodedPixels=q,M.push(Y.transcodedPixels.buffer)}}}i.close(),i.delete(),S&&(g=-1),K?postMessage({action:"transcode",success:K,id:y.data.id,fileInfo:u,format:g},M):postMessage({action:"transcode",success:K,id:y.data.id})}}}!function(P){P[P.cTFETC1=0]="cTFETC1",P[P.cTFETC2=1]="cTFETC2",P[P.cTFBC1=2]="cTFBC1",P[P.cTFBC3=3]="cTFBC3",P[P.cTFBC4=4]="cTFBC4",P[P.cTFBC5=5]="cTFBC5",P[P.cTFBC7=6]="cTFBC7",P[P.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",P[P.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",P[P.cTFASTC_4x4=10]="cTFASTC_4x4",P[P.cTFATC_RGB=11]="cTFATC_RGB",P[P.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",P[P.cTFRGBA32=13]="cTFRGBA32",P[P.cTFRGB565=14]="cTFRGB565",P[P.cTFBGR565=15]="cTFBGR565",P[P.cTFRGBA4444=16]="cTFRGBA4444",P[P.cTFFXT1_RGB=17]="cTFFXT1_RGB",P[P.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",P[P.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",P[P.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",P[P.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(C||(C={}));const w={JSModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let d=null,R=null,y=0;const r=async()=>(d||(d=new Promise(((P,f)=>{R?P(R):q.Tools.LoadFileAsync(q.Tools.GetBabylonScriptURL(w.WasmModuleURL)).then((Y=>{if("function"!==typeof URL)return f("Basis transcoder requires an environment with a URL constructor");const C=URL.createObjectURL(new Blob([`(${o})()`],{type:"application/javascript"}));R=new Worker(C),async function(P,f,Y){return await new Promise(((C,m)=>{const L=f=>{"init"===f.data.action?(P.removeEventListener("message",L),C(P)):"error"===f.data.action&&m(f.data.error||"error initializing worker")};P.addEventListener("message",L),P.postMessage({action:"init",url:Y?q.Tools.GetBabylonScriptURL(Y):void 0,wasmBinary:f},[f])}))}(R,Y,w.JSModuleURL).then(P,f)})).catch(f)}))),await d),i=async(P,f)=>{const Y=P instanceof ArrayBuffer?new Uint8Array(P):P;return await new Promise(((P,C)=>{r().then((()=>{const q=y++,m=f=>{"transcode"===f.data.action&&f.data.id===q&&(R.removeEventListener("message",m),f.data.success?P(f.data):C("Transcode is not supported on this device"))};R.addEventListener("message",m);const L=new Uint8Array(Y.byteLength);L.set(new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength)),R.postMessage({action:"transcode",id:q,imageData:L,config:f,ignoreSupportedFormats:false},[L.buffer])}),(P=>{C(P)}))}))},u=(P,f)=>{var Y;let C=null===(Y=f._gl)||void 0===Y?void 0:Y.TEXTURE_2D;var q;P.isCube&&(C=null===(q=f._gl)||void 0===q?void 0:q.TEXTURE_CUBE_MAP);f._bindTextureDirectly(C,P,!0)},g=(P,f)=>{const Y=P.getEngine();for(let o=0;o<f.fileInfo.images.length;o++){const w=f.fileInfo.images[o].levels[0];if(P._invertVScale=P.invertY,-1===f.format||f.format===C.cTFRGB565)if(P.type=10,P.format=4,!Y._features.basisNeedsPOT||Math.log2(w.width)%1===0&&Math.log2(w.height)%1===0)P._invertVScale=!P.invertY,P.width=w.width+3&-4,P.height=w.height+3&-4,P.samplingMode=2,u(P,Y),Y._uploadDataToTextureDirectly(P,new Uint16Array(w.transcodedPixels.buffer),o,0,4,!0);else{const f=new L.b(Y,2);P._invertVScale=P.invertY,f.type=10,f.format=4,f.width=w.width+3&-4,f.height=w.height+3&-4,u(f,Y),Y._uploadDataToTextureDirectly(f,new Uint16Array(w.transcodedPixels.buffer),o,0,4,!0),Y._rescaleTexture(f,P,Y.scenes[0],Y._getInternalFormat(4),(()=>{Y._releaseTexture(f),u(P,Y)}))}else{P.width=w.width,P.height=w.height,P.generateMipMaps=f.fileInfo.images[o].levels.length>1;const C=S.GetInternalFormatFromBasisFormat(f.format,Y);P.format=C,u(P,Y);const L=f.fileInfo.images[o].levels;for(let f=0;f<L.length;f++){const q=L[f];Y._uploadCompressedDataToTextureDirectly(P,C,q.width,q.height,q.transcodedPixels,o,f)}!Y._features.basisNeedsPOT||Math.log2(P.width)%1===0&&Math.log2(P.height)%1===0||(q.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),P._cachedWrapU=m.c.CLAMP_ADDRESSMODE,P._cachedWrapV=m.c.CLAMP_ADDRESSMODE)}}},S={JSModuleURL:w.JSModuleURL,WasmModuleURL:w.WasmModuleURL,GetInternalFormatFromBasisFormat:(P,f)=>{let Y;switch(P){case C.cTFETC1:Y=36196;break;case C.cTFBC1:Y=33776;break;case C.cTFBC4:Y=33779;break;case C.cTFASTC_4x4:Y=37808;break;case C.cTFETC2:Y=37496;break;case C.cTFBC7:Y=36492}if(void 0===Y)throw"The chosen Basis transcoder format is not currently supported";return Y},TranscodeAsync:i,LoadTextureFromTranscodeResult:g};Object.defineProperty(S,"JSModuleURL",{get:function(){return w.JSModuleURL},set:function(P){w.JSModuleURL=P}}),Object.defineProperty(S,"WasmModuleURL",{get:function(){return w.WasmModuleURL},set:function(P){w.WasmModuleURL=P}});class K{constructor(){this.supportCascades=!1}loadCubeData(P,f,Y,C,m){if(Array.isArray(P))return;const L=f.getEngine().getCaps(),o={supportedCompressionFormats:{etc1:!!L.etc1,s3tc:!!L.s3tc,pvrtc:!!L.pvrtc,etc2:!!L.etc2,astc:!!L.astc,bc7:!!L.bptc}};i(P,o).then((P=>{const Y=P.fileInfo.images[0].levels.length>1&&f.generateMipMaps;g(f,P),f.getEngine()._setCubeMapTextureParams(f,Y),f.isReady=!0,f.onLoadedObservable.notifyObservers(f),f.onLoadedObservable.clear(),C&&C()})).catch((P=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),f.isReady=!0,m&&m(P)}))}loadData(P,f,Y){const C=f.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!C.etc1,s3tc:!!C.s3tc,pvrtc:!!C.pvrtc,etc2:!!C.etc2,astc:!!C.astc,bc7:!!C.bptc}};i(P,m).then((P=>{const C=P.fileInfo.images[0].levels[0],q=P.fileInfo.images[0].levels.length>1&&f.generateMipMaps;Y(C.width,C.height,q,-1!==P.format,(()=>{g(f,P)}))})).catch((P=>{q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),q.Tools.Warn(`Failed to transcode Basis file: ${P}`),Y(0,0,!1,!1,(()=>{}),!0)}))}}}}]);