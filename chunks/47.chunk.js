"use strict";(self.fkqm0epoq5=self.fkqm0epoq5||[]).push([[47],{14130:(D,l,G)=>{G.r(l),G.d(l,{_BasisTextureLoader:()=>H});var V,N=G(11530),M=G(11686),b=G(11644);function X(){const D=0,l=1,G=2,V=3,N=6,M=8,b=9,X=10,t=14;let R=null;function n(D,l,G,V,N){const M=D.getImageTranscodedSizeInBytes(l,G,V);let b=new Uint8Array(M);if(!D.transcodeImage(b,l,G,V,1,0))return null;if(N){b=function(D,l,G,V){const N=new Uint16Array(4),M=new Uint16Array(G*V),b=G/4,X=V/4;for(let t=0;t<X;t++)for(let V=0;V<b;V++){const X=l+8*(t*b+V);N[0]=D[X]|D[X+1]<<8,N[1]=D[X+2]|D[X+3]<<8,N[2]=(2*(31&N[0])+1*(31&N[1]))/3|(2*(2016&N[0])+1*(2016&N[1]))/3&2016|(2*(63488&N[0])+1*(63488&N[1]))/3&63488,N[3]=(2*(31&N[1])+1*(31&N[0]))/3|(2*(2016&N[1])+1*(2016&N[0]))/3&2016|(2*(63488&N[1])+1*(63488&N[0]))/3&63488;for(let l=0;l<4;l++){const b=D[X+4+l];let R=(4*t+l)*G+4*V;M[R++]=N[3&b],M[R++]=N[b>>2&3],M[R++]=N[b>>4&3],M[R++]=N[b>>6&3]}}return M}(b,0,D.getImageWidth(l,G)+3&-4,D.getImageHeight(l,G)+3&-4)}return b}onmessage=g=>{if("init"===g.data.action){if(g.data.url)try{importScripts(g.data.url)}catch(j){postMessage({action:"error",error:j})}R||(R=BASIS({wasmBinary:g.data.wasmBinary})),null!==R&&R.then((D=>{BASIS=D,D.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===g.data.action){const R=g.data.config,j=g.data.imageData,e=new BASIS.BasisFile(j),K=function(D){const l=D.getHasAlpha(),G=D.getNumImages(),V=[];for(let N=0;N<G;N++){const l={levels:[]},G=D.getNumLevels(N);for(let V=0;V<G;V++){const G={width:D.getImageWidth(N,V),height:D.getImageHeight(N,V)};l.levels.push(G)}V.push(l)}return{eb:l,images:V}}(e);let F=g.data.ignoreSupportedFormats?null:function(R,n){let g=null;R.supportedCompressionFormats&&(g=R.supportedCompressionFormats.astc?X:R.supportedCompressionFormats.bc7?N:R.supportedCompressionFormats.s3tc?n.eb?V:G:R.supportedCompressionFormats.pvrtc?n.eb?b:M:R.supportedCompressionFormats.etc2?l:R.supportedCompressionFormats.etc1?D:t);return g}(g.data.config,K),d=!1;null===F&&(d=!0,F=K.eb?V:G);let H=!0;e.startTranscoding()||(H=!1);const h=[];for(let D=0;D<K.images.length&&H;D++){const l=K.images[D];if(void 0===R.loadSingleImage||R.loadSingleImage===D){let G=l.levels.length;!1===R.loadMipmapLevels&&(G=1);for(let V=0;V<G;V++){const G=l.levels[V],N=n(e,D,V,F,d);if(!N){H=!1;break}G.transcodedPixels=N,h.push(G.transcodedPixels.buffer)}}}e.close(),e.delete(),d&&(F=-1),H?postMessage({action:"transcode",success:H,id:g.data.id,fileInfo:K,format:F},h):postMessage({action:"transcode",success:H,id:g.data.id})}}}!function(D){D[D.cTFETC1=0]="cTFETC1",D[D.cTFETC2=1]="cTFETC2",D[D.cTFBC1=2]="cTFBC1",D[D.cTFBC3=3]="cTFBC3",D[D.cTFBC4=4]="cTFBC4",D[D.cTFBC5=5]="cTFBC5",D[D.cTFBC7=6]="cTFBC7",D[D.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",D[D.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",D[D.cTFASTC_4x4=10]="cTFASTC_4x4",D[D.cTFATC_RGB=11]="cTFATC_RGB",D[D.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",D[D.cTFRGBA32=13]="cTFRGBA32",D[D.cTFRGB565=14]="cTFRGB565",D[D.cTFBGR565=15]="cTFBGR565",D[D.cTFRGBA4444=16]="cTFRGBA4444",D[D.cTFFXT1_RGB=17]="cTFFXT1_RGB",D[D.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",D[D.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",D[D.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",D[D.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(V||(V={}));const t={JSModuleURL:`${N.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${N.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let R=null,n=null,g=0;const j=async()=>(R||(R=new Promise(((D,l)=>{n?D(n):N.Tools.LoadFileAsync(N.Tools.GetBabylonScriptURL(t.WasmModuleURL)).then((G=>{if("function"!==typeof URL)return l("Basis transcoder requires an environment with a URL constructor");const V=URL.createObjectURL(new Blob([`(${X})()`],{type:"application/javascript"}));n=new Worker(V),async function(D,l,G){return await new Promise(((V,M)=>{const b=l=>{"init"===l.data.action?(D.removeEventListener("message",b),V(D)):"error"===l.data.action&&M(l.data.error||"error initializing worker")};D.addEventListener("message",b),D.postMessage({action:"init",url:G?N.Tools.GetBabylonScriptURL(G):void 0,wasmBinary:l},[l])}))}(n,G,t.JSModuleURL).then(D,l)})).catch(l)}))),await R),e=async(D,l)=>{const G=D instanceof ArrayBuffer?new Uint8Array(D):D;return await new Promise(((D,V)=>{j().then((()=>{const N=g++,M=l=>{"transcode"===l.data.action&&l.data.id===N&&(n.removeEventListener("message",M),l.data.success?D(l.data):V("Transcode is not supported on this device"))};n.addEventListener("message",M);const b=new Uint8Array(G.byteLength);b.set(new Uint8Array(G.buffer,G.byteOffset,G.byteLength)),n.postMessage({action:"transcode",id:N,imageData:b,config:l,ignoreSupportedFormats:false},[b.buffer])}),(D=>{V(D)}))}))},K=(D,l)=>{var G;let V=null===(G=l._gl)||void 0===G?void 0:G.TEXTURE_2D;var N;D.isCube&&(V=null===(N=l._gl)||void 0===N?void 0:N.TEXTURE_CUBE_MAP);l._bindTextureDirectly(V,D,!0)},F=(D,l)=>{const G=D.getEngine();for(let X=0;X<l.fileInfo.images.length;X++){const t=l.fileInfo.images[X].levels[0];if(D._invertVScale=D.invertY,-1===l.format||l.format===V.cTFRGB565)if(D.type=10,D.format=4,!G._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)D._invertVScale=!D.invertY,D.width=t.width+3&-4,D.height=t.height+3&-4,D.samplingMode=2,K(D,G),G._uploadDataToTextureDirectly(D,new Uint16Array(t.transcodedPixels.buffer),X,0,4,!0);else{const l=new b.b(G,2);D._invertVScale=D.invertY,l.type=10,l.format=4,l.width=t.width+3&-4,l.height=t.height+3&-4,K(l,G),G._uploadDataToTextureDirectly(l,new Uint16Array(t.transcodedPixels.buffer),X,0,4,!0),G._rescaleTexture(l,D,G.scenes[0],G._getInternalFormat(4),(()=>{G._releaseTexture(l),K(D,G)}))}else{D.width=t.width,D.height=t.height,D.generateMipMaps=l.fileInfo.images[X].levels.length>1;const V=d.GetInternalFormatFromBasisFormat(l.format,G);D.format=V,K(D,G);const b=l.fileInfo.images[X].levels;for(let l=0;l<b.length;l++){const N=b[l];G._uploadCompressedDataToTextureDirectly(D,V,N.width,N.height,N.transcodedPixels,X,l)}!G._features.basisNeedsPOT||Math.log2(D.width)%1===0&&Math.log2(D.height)%1===0||(N.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),D._cachedWrapU=M.b.CLAMP_ADDRESSMODE,D._cachedWrapV=M.b.CLAMP_ADDRESSMODE)}}},d={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(D,l)=>{let G;switch(D){case V.cTFETC1:G=36196;break;case V.cTFBC1:G=33776;break;case V.cTFBC4:G=33779;break;case V.cTFASTC_4x4:G=37808;break;case V.cTFETC2:G=37496;break;case V.cTFBC7:G=36492}if(void 0===G)throw"The chosen Basis transcoder format is not currently supported";return G},TranscodeAsync:e,LoadTextureFromTranscodeResult:F};Object.defineProperty(d,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(D){t.JSModuleURL=D}}),Object.defineProperty(d,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(D){t.WasmModuleURL=D}});class H{constructor(){this.supportCascades=!1}loadCubeData(D,l,G,V,M){if(Array.isArray(D))return;const b=l.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!b.etc1,s3tc:!!b.s3tc,pvrtc:!!b.pvrtc,etc2:!!b.etc2,astc:!!b.astc,bc7:!!b.bptc}};e(D,X).then((D=>{const G=D.fileInfo.images[0].levels.length>1&&l.generateMipMaps;F(l,D),l.getEngine()._setCubeMapTextureParams(l,G),l.isReady=!0,l.onLoadedObservable.notifyObservers(l),l.onLoadedObservable.clear(),V&&V()})).catch((D=>{N.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),l.isReady=!0,M&&M(D)}))}loadData(D,l,G){const V=l.getEngine().getCaps(),M={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};e(D,M).then((D=>{const V=D.fileInfo.images[0].levels[0],N=D.fileInfo.images[0].levels.length>1&&l.generateMipMaps;G(V.width,V.height,N,-1!==D.format,(()=>{F(l,D)}))})).catch((D=>{N.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),N.Tools.Warn(`Failed to transcode Basis file: ${D}`),G(0,0,!1,!1,(()=>{}),!0)}))}}}}]);