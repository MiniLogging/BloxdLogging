"use strict";(self.xeuzlpp225k=self.xeuzlpp225k||[]).push([[47],{13812:(k,Q,i)=>{i.r(Q),i.d(Q,{_BasisTextureLoader:()=>l});var Z,U=i(11119),C=i(11273),B=i(11235);function o(){const k=0,Q=1,i=2,Z=3,U=6,C=8,B=9,o=10,m=14;let O=null;function J(k,Q,i,Z,U){const C=k.getImageTranscodedSizeInBytes(Q,i,Z);let B=new Uint8Array(C);if(!k.transcodeImage(B,Q,i,Z,1,0))return null;if(U){B=function(k,Q,i,Z){const U=new Uint16Array(4),C=new Uint16Array(i*Z),B=i/4,o=Z/4;for(let m=0;m<o;m++)for(let Z=0;Z<B;Z++){const o=Q+8*(m*B+Z);U[0]=k[o]|k[o+1]<<8,U[1]=k[o+2]|k[o+3]<<8,U[2]=(2*(31&U[0])+1*(31&U[1]))/3|(2*(2016&U[0])+1*(2016&U[1]))/3&2016|(2*(63488&U[0])+1*(63488&U[1]))/3&63488,U[3]=(2*(31&U[1])+1*(31&U[0]))/3|(2*(2016&U[1])+1*(2016&U[0]))/3&2016|(2*(63488&U[1])+1*(63488&U[0]))/3&63488;for(let Q=0;Q<4;Q++){const B=k[o+4+Q];let O=(4*m+Q)*i+4*Z;C[O++]=U[3&B],C[O++]=U[B>>2&3],C[O++]=U[B>>4&3],C[O++]=U[B>>6&3]}}return C}(B,0,k.getImageWidth(Q,i)+3&-4,k.getImageHeight(Q,i)+3&-4)}return B}onmessage=G=>{if("init"===G.data.action){if(G.data.url)try{importScripts(G.data.url)}catch(H){postMessage({action:"error",error:H})}O||(O=BASIS({wasmBinary:G.data.wasmBinary})),null!==O&&O.then((k=>{BASIS=k,k.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===G.data.action){const O=G.data.config,H=G.data.imageData,e=new BASIS.BasisFile(H),F=function(k){const Q=k.getHasAlpha(),i=k.getNumImages(),Z=[];for(let U=0;U<i;U++){const Q={levels:[]},i=k.getNumLevels(U);for(let Z=0;Z<i;Z++){const i={width:k.getImageWidth(U,Z),height:k.getImageHeight(U,Z)};Q.levels.push(i)}Z.push(Q)}return{Uo:Q,images:Z}}(e);let z=G.data.ignoreSupportedFormats?null:function(O,J){let G=null;O.supportedCompressionFormats&&(G=O.supportedCompressionFormats.astc?o:O.supportedCompressionFormats.bc7?U:O.supportedCompressionFormats.s3tc?J.Uo?Z:i:O.supportedCompressionFormats.pvrtc?J.Uo?B:C:O.supportedCompressionFormats.etc2?Q:O.supportedCompressionFormats.etc1?k:m);return G}(G.data.config,F),E=!1;null===z&&(E=!0,z=F.Uo?Z:i);let l=!0;e.startTranscoding()||(l=!1);const h=[];for(let k=0;k<F.images.length&&l;k++){const Q=F.images[k];if(void 0===O.loadSingleImage||O.loadSingleImage===k){let i=Q.levels.length;!1===O.loadMipmapLevels&&(i=1);for(let Z=0;Z<i;Z++){const i=Q.levels[Z],U=J(e,k,Z,z,E);if(!U){l=!1;break}i.transcodedPixels=U,h.push(i.transcodedPixels.buffer)}}}e.close(),e.delete(),E&&(z=-1),l?postMessage({action:"transcode",success:l,id:G.data.id,fileInfo:F,format:z},h):postMessage({action:"transcode",success:l,id:G.data.id})}}}!function(k){k[k.cTFETC1=0]="cTFETC1",k[k.cTFETC2=1]="cTFETC2",k[k.cTFBC1=2]="cTFBC1",k[k.cTFBC3=3]="cTFBC3",k[k.cTFBC4=4]="cTFBC4",k[k.cTFBC5=5]="cTFBC5",k[k.cTFBC7=6]="cTFBC7",k[k.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",k[k.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",k[k.cTFASTC_4x4=10]="cTFASTC_4x4",k[k.cTFATC_RGB=11]="cTFATC_RGB",k[k.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",k[k.cTFRGBA32=13]="cTFRGBA32",k[k.cTFRGB565=14]="cTFRGB565",k[k.cTFBGR565=15]="cTFBGR565",k[k.cTFRGBA4444=16]="cTFRGBA4444",k[k.cTFFXT1_RGB=17]="cTFFXT1_RGB",k[k.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",k[k.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",k[k.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",k[k.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(Z||(Z={}));const m={JSModuleURL:`${U.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${U.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let O=null,J=null,G=0;const H=async()=>(O||(O=new Promise(((k,Q)=>{J?k(J):U.Tools.LoadFileAsync(U.Tools.GetBabylonScriptURL(m.WasmModuleURL)).then((i=>{if("function"!==typeof URL)return Q("Basis transcoder requires an environment with a URL constructor");const Z=URL.createObjectURL(new Blob([`(${o})()`],{type:"application/javascript"}));J=new Worker(Z),async function(k,Q,i){return await new Promise(((Z,C)=>{const B=Q=>{"init"===Q.data.action?(k.removeEventListener("message",B),Z(k)):"error"===Q.data.action&&C(Q.data.error||"error initializing worker")};k.addEventListener("message",B),k.postMessage({action:"init",url:i?U.Tools.GetBabylonScriptURL(i):void 0,wasmBinary:Q},[Q])}))}(J,i,m.JSModuleURL).then(k,Q)})).catch(Q)}))),await O),e=async(k,Q)=>{const i=k instanceof ArrayBuffer?new Uint8Array(k):k;return await new Promise(((k,Z)=>{H().then((()=>{const U=G++,C=Q=>{"transcode"===Q.data.action&&Q.data.id===U&&(J.removeEventListener("message",C),Q.data.success?k(Q.data):Z("Transcode is not supported on this device"))};J.addEventListener("message",C);const B=new Uint8Array(i.byteLength);B.set(new Uint8Array(i.buffer,i.byteOffset,i.byteLength)),J.postMessage({action:"transcode",id:U,imageData:B,config:Q,ignoreSupportedFormats:false},[B.buffer])}),(k=>{Z(k)}))}))},F=(k,Q)=>{var i;let Z=null===(i=Q._gl)||void 0===i?void 0:i.TEXTURE_2D;var U;k.isCube&&(Z=null===(U=Q._gl)||void 0===U?void 0:U.TEXTURE_CUBE_MAP);Q._bindTextureDirectly(Z,k,!0)},z=(k,Q)=>{const i=k.getEngine();for(let o=0;o<Q.fileInfo.images.length;o++){const m=Q.fileInfo.images[o].levels[0];if(k._invertVScale=k.invertY,-1===Q.format||Q.format===Z.cTFRGB565)if(k.type=10,k.format=4,!i._features.basisNeedsPOT||Math.log2(m.width)%1===0&&Math.log2(m.height)%1===0)k._invertVScale=!k.invertY,k.width=m.width+3&-4,k.height=m.height+3&-4,k.samplingMode=2,F(k,i),i._uploadDataToTextureDirectly(k,new Uint16Array(m.transcodedPixels.buffer),o,0,4,!0);else{const Q=new B.c(i,2);k._invertVScale=k.invertY,Q.type=10,Q.format=4,Q.width=m.width+3&-4,Q.height=m.height+3&-4,F(Q,i),i._uploadDataToTextureDirectly(Q,new Uint16Array(m.transcodedPixels.buffer),o,0,4,!0),i._rescaleTexture(Q,k,i.scenes[0],i._getInternalFormat(4),(()=>{i._releaseTexture(Q),F(k,i)}))}else{k.width=m.width,k.height=m.height,k.generateMipMaps=Q.fileInfo.images[o].levels.length>1;const Z=E.GetInternalFormatFromBasisFormat(Q.format,i);k.format=Z,F(k,i);const B=Q.fileInfo.images[o].levels;for(let Q=0;Q<B.length;Q++){const U=B[Q];i._uploadCompressedDataToTextureDirectly(k,Z,U.width,U.height,U.transcodedPixels,o,Q)}!i._features.basisNeedsPOT||Math.log2(k.width)%1===0&&Math.log2(k.height)%1===0||(U.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),k._cachedWrapU=C.c.CLAMP_ADDRESSMODE,k._cachedWrapV=C.c.CLAMP_ADDRESSMODE)}}},E={JSModuleURL:m.JSModuleURL,WasmModuleURL:m.WasmModuleURL,GetInternalFormatFromBasisFormat:(k,Q)=>{let i;switch(k){case Z.cTFETC1:i=36196;break;case Z.cTFBC1:i=33776;break;case Z.cTFBC4:i=33779;break;case Z.cTFASTC_4x4:i=37808;break;case Z.cTFETC2:i=37496;break;case Z.cTFBC7:i=36492}if(void 0===i)throw"The chosen Basis transcoder format is not currently supported";return i},TranscodeAsync:e,LoadTextureFromTranscodeResult:z};Object.defineProperty(E,"JSModuleURL",{get:function(){return m.JSModuleURL},set:function(k){m.JSModuleURL=k}}),Object.defineProperty(E,"WasmModuleURL",{get:function(){return m.WasmModuleURL},set:function(k){m.WasmModuleURL=k}});class l{constructor(){this.supportCascades=!1}loadCubeData(k,Q,i,Z,C){if(Array.isArray(k))return;const B=Q.getEngine().getCaps(),o={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};e(k,o).then((k=>{const i=k.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;z(Q,k),Q.getEngine()._setCubeMapTextureParams(Q,i),Q.isReady=!0,Q.onLoadedObservable.notifyObservers(Q),Q.onLoadedObservable.clear(),Z&&Z()})).catch((k=>{U.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Q.isReady=!0,C&&C(k)}))}loadData(k,Q,i){const Z=Q.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!Z.etc1,s3tc:!!Z.s3tc,pvrtc:!!Z.pvrtc,etc2:!!Z.etc2,astc:!!Z.astc,bc7:!!Z.bptc}};e(k,C).then((k=>{const Z=k.fileInfo.images[0].levels[0],U=k.fileInfo.images[0].levels.length>1&&Q.generateMipMaps;i(Z.width,Z.height,U,-1!==k.format,(()=>{z(Q,k)}))})).catch((k=>{U.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.Tools.Warn(`Failed to transcode Basis file: ${k}`),i(0,0,!1,!1,(()=>{}),!0)}))}}}}]);