"use strict";(self.rsqbdnwe5e=self.rsqbdnwe5e||[]).push([[47],{14796:(N,p,T)=>{T.r(p),T.d(p,{_BasisTextureLoader:()=>L});var A,a=T(12190),C=T(12352),U=T(12302);function X(){const N=0,p=1,T=2,A=3,a=6,C=8,U=9,X=10,y=14;let e=null;function H(N,p,T,A,a){const C=N.getImageTranscodedSizeInBytes(p,T,A);let U=new Uint8Array(C);if(!N.transcodeImage(U,p,T,A,1,0))return null;if(a){U=function(N,p,T,A){const a=new Uint16Array(4),C=new Uint16Array(T*A),U=T/4,X=A/4;for(let y=0;y<X;y++)for(let A=0;A<U;A++){const X=p+8*(y*U+A);a[0]=N[X]|N[X+1]<<8,a[1]=N[X+2]|N[X+3]<<8,a[2]=(2*(31&a[0])+1*(31&a[1]))/3|(2*(2016&a[0])+1*(2016&a[1]))/3&2016|(2*(63488&a[0])+1*(63488&a[1]))/3&63488,a[3]=(2*(31&a[1])+1*(31&a[0]))/3|(2*(2016&a[1])+1*(2016&a[0]))/3&2016|(2*(63488&a[1])+1*(63488&a[0]))/3&63488;for(let p=0;p<4;p++){const U=N[X+4+p];let e=(4*y+p)*T+4*A;C[e++]=a[3&U],C[e++]=a[U>>2&3],C[e++]=a[U>>4&3],C[e++]=a[U>>6&3]}}return C}(U,0,N.getImageWidth(p,T)+3&-4,N.getImageHeight(p,T)+3&-4)}return U}onmessage=M=>{if("init"===M.data.action){if(M.data.url)try{importScripts(M.data.url)}catch(b){postMessage({action:"error",error:b})}e||(e=BASIS({wasmBinary:M.data.wasmBinary})),null!==e&&e.then((N=>{BASIS=N,N.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===M.data.action){const e=M.data.config,b=M.data.imageData,l=new BASIS.BasisFile(b),k=function(N){const p=N.getHasAlpha(),T=N.getNumImages(),A=[];for(let a=0;a<T;a++){const p={levels:[]},T=N.getNumLevels(a);for(let A=0;A<T;A++){const T={width:N.getImageWidth(a,A),height:N.getImageHeight(a,A)};p.levels.push(T)}A.push(p)}return{XX:p,images:A}}(l);let x=M.data.ignoreSupportedFormats?null:function(e,H){let M=null;e.supportedCompressionFormats&&(M=e.supportedCompressionFormats.astc?X:e.supportedCompressionFormats.bc7?a:e.supportedCompressionFormats.s3tc?H.XX?A:T:e.supportedCompressionFormats.pvrtc?H.XX?U:C:e.supportedCompressionFormats.etc2?p:e.supportedCompressionFormats.etc1?N:y);return M}(M.data.config,k),I=!1;null===x&&(I=!0,x=k.XX?A:T);let L=!0;l.startTranscoding()||(L=!1);const n=[];for(let N=0;N<k.images.length&&L;N++){const p=k.images[N];if(void 0===e.loadSingleImage||e.loadSingleImage===N){let T=p.levels.length;!1===e.loadMipmapLevels&&(T=1);for(let A=0;A<T;A++){const T=p.levels[A],a=H(l,N,A,x,I);if(!a){L=!1;break}T.transcodedPixels=a,n.push(T.transcodedPixels.buffer)}}}l.close(),l.delete(),I&&(x=-1),L?postMessage({action:"transcode",success:L,id:M.data.id,fileInfo:k,format:x},n):postMessage({action:"transcode",success:L,id:M.data.id})}}}!function(N){N[N.cTFETC1=0]="cTFETC1",N[N.cTFETC2=1]="cTFETC2",N[N.cTFBC1=2]="cTFBC1",N[N.cTFBC3=3]="cTFBC3",N[N.cTFBC4=4]="cTFBC4",N[N.cTFBC5=5]="cTFBC5",N[N.cTFBC7=6]="cTFBC7",N[N.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",N[N.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",N[N.cTFASTC_4x4=10]="cTFASTC_4x4",N[N.cTFATC_RGB=11]="cTFATC_RGB",N[N.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",N[N.cTFRGBA32=13]="cTFRGBA32",N[N.cTFRGB565=14]="cTFRGB565",N[N.cTFBGR565=15]="cTFBGR565",N[N.cTFRGBA4444=16]="cTFRGBA4444",N[N.cTFFXT1_RGB=17]="cTFFXT1_RGB",N[N.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",N[N.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",N[N.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",N[N.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(A||(A={}));const y={JSModuleURL:`${a.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${a.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let e=null,H=null,M=0;const b=async()=>(e||(e=new Promise(((N,p)=>{H?N(H):a.Tools.LoadFileAsync(a.Tools.GetBabylonScriptURL(y.WasmModuleURL)).then((T=>{if("function"!==typeof URL)return p("Basis transcoder requires an environment with a URL constructor");const A=URL.createObjectURL(new Blob([`(${X})()`],{type:"application/javascript"}));H=new Worker(A),async function(N,p,T){return await new Promise(((A,C)=>{const U=p=>{"init"===p.data.action?(N.removeEventListener("message",U),A(N)):"error"===p.data.action&&C(p.data.error||"error initializing worker")};N.addEventListener("message",U),N.postMessage({action:"init",url:T?a.Tools.GetBabylonScriptURL(T):void 0,wasmBinary:p},[p])}))}(H,T,y.JSModuleURL).then(N,p)})).catch(p)}))),await e),l=async(N,p)=>{const T=N instanceof ArrayBuffer?new Uint8Array(N):N;return await new Promise(((N,A)=>{b().then((()=>{const a=M++,C=p=>{"transcode"===p.data.action&&p.data.id===a&&(H.removeEventListener("message",C),p.data.success?N(p.data):A("Transcode is not supported on this device"))};H.addEventListener("message",C);const U=new Uint8Array(T.byteLength);U.set(new Uint8Array(T.buffer,T.byteOffset,T.byteLength)),H.postMessage({action:"transcode",id:a,imageData:U,config:p,ignoreSupportedFormats:false},[U.buffer])}),(N=>{A(N)}))}))},k=(N,p)=>{var T;let A=null===(T=p._gl)||void 0===T?void 0:T.TEXTURE_2D;var a;N.isCube&&(A=null===(a=p._gl)||void 0===a?void 0:a.TEXTURE_CUBE_MAP);p._bindTextureDirectly(A,N,!0)},x=(N,p)=>{const T=N.getEngine();for(let X=0;X<p.fileInfo.images.length;X++){const y=p.fileInfo.images[X].levels[0];if(N._invertVScale=N.invertY,-1===p.format||p.format===A.cTFRGB565)if(N.type=10,N.format=4,!T._features.basisNeedsPOT||Math.log2(y.width)%1===0&&Math.log2(y.height)%1===0)N._invertVScale=!N.invertY,N.width=y.width+3&-4,N.height=y.height+3&-4,N.samplingMode=2,k(N,T),T._uploadDataToTextureDirectly(N,new Uint16Array(y.transcodedPixels.buffer),X,0,4,!0);else{const p=new U.d(T,2);N._invertVScale=N.invertY,p.type=10,p.format=4,p.width=y.width+3&-4,p.height=y.height+3&-4,k(p,T),T._uploadDataToTextureDirectly(p,new Uint16Array(y.transcodedPixels.buffer),X,0,4,!0),T._rescaleTexture(p,N,T.scenes[0],T._getInternalFormat(4),(()=>{T._releaseTexture(p),k(N,T)}))}else{N.width=y.width,N.height=y.height,N.generateMipMaps=p.fileInfo.images[X].levels.length>1;const A=I.GetInternalFormatFromBasisFormat(p.format,T);N.format=A,k(N,T);const U=p.fileInfo.images[X].levels;for(let p=0;p<U.length;p++){const a=U[p];T._uploadCompressedDataToTextureDirectly(N,A,a.width,a.height,a.transcodedPixels,X,p)}!T._features.basisNeedsPOT||Math.log2(N.width)%1===0&&Math.log2(N.height)%1===0||(a.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),N._cachedWrapU=C.c.CLAMP_ADDRESSMODE,N._cachedWrapV=C.c.CLAMP_ADDRESSMODE)}}},I={JSModuleURL:y.JSModuleURL,WasmModuleURL:y.WasmModuleURL,GetInternalFormatFromBasisFormat:(N,p)=>{let T;switch(N){case A.cTFETC1:T=36196;break;case A.cTFBC1:T=33776;break;case A.cTFBC4:T=33779;break;case A.cTFASTC_4x4:T=37808;break;case A.cTFETC2:T=37496;break;case A.cTFBC7:T=36492}if(void 0===T)throw"The chosen Basis transcoder format is not currently supported";return T},TranscodeAsync:l,LoadTextureFromTranscodeResult:x};Object.defineProperty(I,"JSModuleURL",{get:function(){return y.JSModuleURL},set:function(N){y.JSModuleURL=N}}),Object.defineProperty(I,"WasmModuleURL",{get:function(){return y.WasmModuleURL},set:function(N){y.WasmModuleURL=N}});class L{constructor(){this.supportCascades=!1}loadCubeData(N,p,T,A,C){if(Array.isArray(N))return;const U=p.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!U.etc1,s3tc:!!U.s3tc,pvrtc:!!U.pvrtc,etc2:!!U.etc2,astc:!!U.astc,bc7:!!U.bptc}};l(N,X).then((N=>{const T=N.fileInfo.images[0].levels.length>1&&p.generateMipMaps;x(p,N),p.getEngine()._setCubeMapTextureParams(p,T),p.isReady=!0,p.onLoadedObservable.notifyObservers(p),p.onLoadedObservable.clear(),A&&A()})).catch((N=>{a.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),p.isReady=!0,C&&C(N)}))}loadData(N,p,T){const A=p.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};l(N,C).then((N=>{const A=N.fileInfo.images[0].levels[0],a=N.fileInfo.images[0].levels.length>1&&p.generateMipMaps;T(A.width,A.height,a,-1!==N.format,(()=>{x(p,N)}))})).catch((N=>{a.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),a.Tools.Warn(`Failed to transcode Basis file: ${N}`),T(0,0,!1,!1,(()=>{}),!0)}))}}}}]);