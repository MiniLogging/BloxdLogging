"use strict";(self.zcqpiao938m=self.zcqpiao938m||[]).push([[47],{14245:(C,U,K)=>{K.r(U),K.d(U,{_BasisTextureLoader:()=>V});var m,O=K(11660),X=K(11808),A=K(11773);function e(){const C=0,U=1,K=2,m=3,O=6,X=8,A=9,e=10,t=14;let z=null;function j(C,U,K,m,O){const X=C.getImageTranscodedSizeInBytes(U,K,m);let A=new Uint8Array(X);if(!C.transcodeImage(A,U,K,m,1,0))return null;if(O){A=function(C,U,K,m){const O=new Uint16Array(4),X=new Uint16Array(K*m),A=K/4,e=m/4;for(let t=0;t<e;t++)for(let m=0;m<A;m++){const e=U+8*(t*A+m);O[0]=C[e]|C[e+1]<<8,O[1]=C[e+2]|C[e+3]<<8,O[2]=(2*(31&O[0])+1*(31&O[1]))/3|(2*(2016&O[0])+1*(2016&O[1]))/3&2016|(2*(63488&O[0])+1*(63488&O[1]))/3&63488,O[3]=(2*(31&O[1])+1*(31&O[0]))/3|(2*(2016&O[1])+1*(2016&O[0]))/3&2016|(2*(63488&O[1])+1*(63488&O[0]))/3&63488;for(let U=0;U<4;U++){const A=C[e+4+U];let z=(4*t+U)*K+4*m;X[z++]=O[3&A],X[z++]=O[A>>2&3],X[z++]=O[A>>4&3],X[z++]=O[A>>6&3]}}return X}(A,0,C.getImageWidth(U,K)+3&-4,C.getImageHeight(U,K)+3&-4)}return A}onmessage=p=>{if("init"===p.data.action){if(p.data.url)try{importScripts(p.data.url)}catch(E){postMessage({action:"error",error:E})}z||(z=BASIS({wasmBinary:p.data.wasmBinary})),null!==z&&z.then((C=>{BASIS=C,C.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===p.data.action){const z=p.data.config,E=p.data.imageData,u=new BASIS.BasisFile(E),b=function(C){const U=C.getHasAlpha(),K=C.getNumImages(),m=[];for(let O=0;O<K;O++){const U={levels:[]},K=C.getNumLevels(O);for(let m=0;m<K;m++){const K={width:C.getImageWidth(O,m),height:C.getImageHeight(O,m)};U.levels.push(K)}m.push(U)}return{Xe:U,images:m}}(u);let v=p.data.ignoreSupportedFormats?null:function(z,j){let p=null;z.supportedCompressionFormats&&(p=z.supportedCompressionFormats.astc?e:z.supportedCompressionFormats.bc7?O:z.supportedCompressionFormats.s3tc?j.Xe?m:K:z.supportedCompressionFormats.pvrtc?j.Xe?A:X:z.supportedCompressionFormats.etc2?U:z.supportedCompressionFormats.etc1?C:t);return p}(p.data.config,b),Q=!1;null===v&&(Q=!0,v=b.Xe?m:K);let V=!0;u.startTranscoding()||(V=!1);const f=[];for(let C=0;C<b.images.length&&V;C++){const U=b.images[C];if(void 0===z.loadSingleImage||z.loadSingleImage===C){let K=U.levels.length;!1===z.loadMipmapLevels&&(K=1);for(let m=0;m<K;m++){const K=U.levels[m],O=j(u,C,m,v,Q);if(!O){V=!1;break}K.transcodedPixels=O,f.push(K.transcodedPixels.buffer)}}}u.close(),u.delete(),Q&&(v=-1),V?postMessage({action:"transcode",success:V,id:p.data.id,fileInfo:b,format:v},f):postMessage({action:"transcode",success:V,id:p.data.id})}}}!function(C){C[C.cTFETC1=0]="cTFETC1",C[C.cTFETC2=1]="cTFETC2",C[C.cTFBC1=2]="cTFBC1",C[C.cTFBC3=3]="cTFBC3",C[C.cTFBC4=4]="cTFBC4",C[C.cTFBC5=5]="cTFBC5",C[C.cTFBC7=6]="cTFBC7",C[C.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",C[C.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",C[C.cTFASTC_4x4=10]="cTFASTC_4x4",C[C.cTFATC_RGB=11]="cTFATC_RGB",C[C.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",C[C.cTFRGBA32=13]="cTFRGBA32",C[C.cTFRGB565=14]="cTFRGB565",C[C.cTFBGR565=15]="cTFBGR565",C[C.cTFRGBA4444=16]="cTFRGBA4444",C[C.cTFFXT1_RGB=17]="cTFFXT1_RGB",C[C.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",C[C.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",C[C.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",C[C.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(m||(m={}));const t={JSModuleURL:`${O.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${O.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let z=null,j=null,p=0;const E=async()=>(z||(z=new Promise(((C,U)=>{j?C(j):O.Tools.LoadFileAsync(O.Tools.GetBabylonScriptURL(t.WasmModuleURL)).then((K=>{if("function"!==typeof URL)return U("Basis transcoder requires an environment with a URL constructor");const m=URL.createObjectURL(new Blob([`(${e})()`],{type:"application/javascript"}));j=new Worker(m),async function(C,U,K){return await new Promise(((m,X)=>{const A=U=>{"init"===U.data.action?(C.removeEventListener("message",A),m(C)):"error"===U.data.action&&X(U.data.error||"error initializing worker")};C.addEventListener("message",A),C.postMessage({action:"init",url:K?O.Tools.GetBabylonScriptURL(K):void 0,wasmBinary:U},[U])}))}(j,K,t.JSModuleURL).then(C,U)})).catch(U)}))),await z),u=async(C,U)=>{const K=C instanceof ArrayBuffer?new Uint8Array(C):C;return await new Promise(((C,m)=>{E().then((()=>{const O=p++,X=U=>{"transcode"===U.data.action&&U.data.id===O&&(j.removeEventListener("message",X),U.data.success?C(U.data):m("Transcode is not supported on this device"))};j.addEventListener("message",X);const A=new Uint8Array(K.byteLength);A.set(new Uint8Array(K.buffer,K.byteOffset,K.byteLength)),j.postMessage({action:"transcode",id:O,imageData:A,config:U,ignoreSupportedFormats:false},[A.buffer])}),(C=>{m(C)}))}))},b=(C,U)=>{var K;let m=null===(K=U._gl)||void 0===K?void 0:K.TEXTURE_2D;var O;C.isCube&&(m=null===(O=U._gl)||void 0===O?void 0:O.TEXTURE_CUBE_MAP);U._bindTextureDirectly(m,C,!0)},v=(C,U)=>{const K=C.getEngine();for(let e=0;e<U.fileInfo.images.length;e++){const t=U.fileInfo.images[e].levels[0];if(C._invertVScale=C.invertY,-1===U.format||U.format===m.cTFRGB565)if(C.type=10,C.format=4,!K._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)C._invertVScale=!C.invertY,C.width=t.width+3&-4,C.height=t.height+3&-4,C.samplingMode=2,b(C,K),K._uploadDataToTextureDirectly(C,new Uint16Array(t.transcodedPixels.buffer),e,0,4,!0);else{const U=new A.d(K,2);C._invertVScale=C.invertY,U.type=10,U.format=4,U.width=t.width+3&-4,U.height=t.height+3&-4,b(U,K),K._uploadDataToTextureDirectly(U,new Uint16Array(t.transcodedPixels.buffer),e,0,4,!0),K._rescaleTexture(U,C,K.scenes[0],K._getInternalFormat(4),(()=>{K._releaseTexture(U),b(C,K)}))}else{C.width=t.width,C.height=t.height,C.generateMipMaps=U.fileInfo.images[e].levels.length>1;const m=Q.GetInternalFormatFromBasisFormat(U.format,K);C.format=m,b(C,K);const A=U.fileInfo.images[e].levels;for(let U=0;U<A.length;U++){const O=A[U];K._uploadCompressedDataToTextureDirectly(C,m,O.width,O.height,O.transcodedPixels,e,U)}!K._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0||(O.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),C._cachedWrapU=X.b.CLAMP_ADDRESSMODE,C._cachedWrapV=X.b.CLAMP_ADDRESSMODE)}}},Q={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(C,U)=>{let K;switch(C){case m.cTFETC1:K=36196;break;case m.cTFBC1:K=33776;break;case m.cTFBC4:K=33779;break;case m.cTFASTC_4x4:K=37808;break;case m.cTFETC2:K=37496;break;case m.cTFBC7:K=36492}if(void 0===K)throw"The chosen Basis transcoder format is not currently supported";return K},TranscodeAsync:u,LoadTextureFromTranscodeResult:v};Object.defineProperty(Q,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(C){t.JSModuleURL=C}}),Object.defineProperty(Q,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(C){t.WasmModuleURL=C}});class V{constructor(){this.supportCascades=!1}loadCubeData(C,U,K,m,X){if(Array.isArray(C))return;const A=U.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!A.etc1,s3tc:!!A.s3tc,pvrtc:!!A.pvrtc,etc2:!!A.etc2,astc:!!A.astc,bc7:!!A.bptc}};u(C,e).then((C=>{const K=C.fileInfo.images[0].levels.length>1&&U.generateMipMaps;v(U,C),U.getEngine()._setCubeMapTextureParams(U,K),U.isReady=!0,U.onLoadedObservable.notifyObservers(U),U.onLoadedObservable.clear(),m&&m()})).catch((C=>{O.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),U.isReady=!0,X&&X(C)}))}loadData(C,U,K){const m=U.getEngine().getCaps(),X={supportedCompressionFormats:{etc1:!!m.etc1,s3tc:!!m.s3tc,pvrtc:!!m.pvrtc,etc2:!!m.etc2,astc:!!m.astc,bc7:!!m.bptc}};u(C,X).then((C=>{const m=C.fileInfo.images[0].levels[0],O=C.fileInfo.images[0].levels.length>1&&U.generateMipMaps;K(m.width,m.height,O,-1!==C.format,(()=>{v(U,C)}))})).catch((C=>{O.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.Tools.Warn(`Failed to transcode Basis file: ${C}`),K(0,0,!1,!1,(()=>{}),!0)}))}}}}]);