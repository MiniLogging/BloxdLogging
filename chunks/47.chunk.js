"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[47],{13829:(f,v,Z)=>{Z.r(v),Z.d(v,{_BasisTextureLoader:()=>U});var V,h=Z(11230),J=Z(11401),l=Z(11360);function e(){const f=0,v=1,Z=2,V=3,h=6,J=8,l=9,e=10,C=14;let H=null;function O(f,v,Z,V,h){const J=f.getImageTranscodedSizeInBytes(v,Z,V);let l=new Uint8Array(J);if(!f.transcodeImage(l,v,Z,V,1,0))return null;if(h){l=function(f,v,Z,V){const h=new Uint16Array(4),J=new Uint16Array(Z*V),l=Z/4,e=V/4;for(let C=0;C<e;C++)for(let V=0;V<l;V++){const e=v+8*(C*l+V);h[0]=f[e]|f[e+1]<<8,h[1]=f[e+2]|f[e+3]<<8,h[2]=(2*(31&h[0])+1*(31&h[1]))/3|(2*(2016&h[0])+1*(2016&h[1]))/3&2016|(2*(63488&h[0])+1*(63488&h[1]))/3&63488,h[3]=(2*(31&h[1])+1*(31&h[0]))/3|(2*(2016&h[1])+1*(2016&h[0]))/3&2016|(2*(63488&h[1])+1*(63488&h[0]))/3&63488;for(let v=0;v<4;v++){const l=f[e+4+v];let H=(4*C+v)*Z+4*V;J[H++]=h[3&l],J[H++]=h[l>>2&3],J[H++]=h[l>>4&3],J[H++]=h[l>>6&3]}}return J}(l,0,f.getImageWidth(v,Z)+3&-4,f.getImageHeight(v,Z)+3&-4)}return l}onmessage=u=>{if("init"===u.data.action){if(u.data.url)try{importScripts(u.data.url)}catch(W){postMessage({action:"error",error:W})}H||(H=BASIS({wasmBinary:u.data.wasmBinary})),null!==H&&H.then((f=>{BASIS=f,f.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===u.data.action){const H=u.data.config,W=u.data.imageData,a=new BASIS.BasisFile(W),b=function(f){const v=f.getHasAlpha(),Z=f.getNumImages(),V=[];for(let h=0;h<Z;h++){const v={levels:[]},Z=f.getNumLevels(h);for(let V=0;V<Z;V++){const Z={width:f.getImageWidth(h,V),height:f.getImageHeight(h,V)};v.levels.push(Z)}V.push(v)}return{th:v,images:V}}(a);let X=u.data.ignoreSupportedFormats?null:function(H,O){let u=null;H.supportedCompressionFormats&&(u=H.supportedCompressionFormats.astc?e:H.supportedCompressionFormats.bc7?h:H.supportedCompressionFormats.s3tc?O.th?V:Z:H.supportedCompressionFormats.pvrtc?O.th?l:J:H.supportedCompressionFormats.etc2?v:H.supportedCompressionFormats.etc1?f:C);return u}(u.data.config,b),F=!1;null===X&&(F=!0,X=b.th?V:Z);let U=!0;a.startTranscoding()||(U=!1);const K=[];for(let f=0;f<b.images.length&&U;f++){const v=b.images[f];if(void 0===H.loadSingleImage||H.loadSingleImage===f){let Z=v.levels.length;!1===H.loadMipmapLevels&&(Z=1);for(let V=0;V<Z;V++){const Z=v.levels[V],h=O(a,f,V,X,F);if(!h){U=!1;break}Z.transcodedPixels=h,K.push(Z.transcodedPixels.buffer)}}}a.close(),a.delete(),F&&(X=-1),U?postMessage({action:"transcode",success:U,id:u.data.id,fileInfo:b,format:X},K):postMessage({action:"transcode",success:U,id:u.data.id})}}}!function(f){f[f.cTFETC1=0]="cTFETC1",f[f.cTFETC2=1]="cTFETC2",f[f.cTFBC1=2]="cTFBC1",f[f.cTFBC3=3]="cTFBC3",f[f.cTFBC4=4]="cTFBC4",f[f.cTFBC5=5]="cTFBC5",f[f.cTFBC7=6]="cTFBC7",f[f.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",f[f.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",f[f.cTFASTC_4x4=10]="cTFASTC_4x4",f[f.cTFATC_RGB=11]="cTFATC_RGB",f[f.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",f[f.cTFRGBA32=13]="cTFRGBA32",f[f.cTFRGB565=14]="cTFRGB565",f[f.cTFBGR565=15]="cTFBGR565",f[f.cTFRGBA4444=16]="cTFRGBA4444",f[f.cTFFXT1_RGB=17]="cTFFXT1_RGB",f[f.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",f[f.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",f[f.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",f[f.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(V||(V={}));const C={JSModuleURL:`${h.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${h.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let H=null,O=null,u=0;const W=async()=>(H||(H=new Promise(((f,v)=>{O?f(O):h.Tools.LoadFileAsync(h.Tools.GetBabylonScriptURL(C.WasmModuleURL)).then((Z=>{if("function"!==typeof URL)return v("Basis transcoder requires an environment with a URL constructor");const V=URL.createObjectURL(new Blob([`(${e})()`],{type:"application/javascript"}));O=new Worker(V),async function(f,v,Z){return await new Promise(((V,J)=>{const l=v=>{"init"===v.data.action?(f.removeEventListener("message",l),V(f)):"error"===v.data.action&&J(v.data.error||"error initializing worker")};f.addEventListener("message",l),f.postMessage({action:"init",url:Z?h.Tools.GetBabylonScriptURL(Z):void 0,wasmBinary:v},[v])}))}(O,Z,C.JSModuleURL).then(f,v)})).catch(v)}))),await H),a=async(f,v)=>{const Z=f instanceof ArrayBuffer?new Uint8Array(f):f;return await new Promise(((f,V)=>{W().then((()=>{const h=u++,J=v=>{"transcode"===v.data.action&&v.data.id===h&&(O.removeEventListener("message",J),v.data.success?f(v.data):V("Transcode is not supported on this device"))};O.addEventListener("message",J);const l=new Uint8Array(Z.byteLength);l.set(new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength)),O.postMessage({action:"transcode",id:h,imageData:l,config:v,ignoreSupportedFormats:false},[l.buffer])}),(f=>{V(f)}))}))},b=(f,v)=>{var Z;let V=null===(Z=v._gl)||void 0===Z?void 0:Z.TEXTURE_2D;var h;f.isCube&&(V=null===(h=v._gl)||void 0===h?void 0:h.TEXTURE_CUBE_MAP);v._bindTextureDirectly(V,f,!0)},X=(f,v)=>{const Z=f.getEngine();for(let e=0;e<v.fileInfo.images.length;e++){const C=v.fileInfo.images[e].levels[0];if(f._invertVScale=f.invertY,-1===v.format||v.format===V.cTFRGB565)if(f.type=10,f.format=4,!Z._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)f._invertVScale=!f.invertY,f.width=C.width+3&-4,f.height=C.height+3&-4,f.samplingMode=2,b(f,Z),Z._uploadDataToTextureDirectly(f,new Uint16Array(C.transcodedPixels.buffer),e,0,4,!0);else{const v=new l.c(Z,2);f._invertVScale=f.invertY,v.type=10,v.format=4,v.width=C.width+3&-4,v.height=C.height+3&-4,b(v,Z),Z._uploadDataToTextureDirectly(v,new Uint16Array(C.transcodedPixels.buffer),e,0,4,!0),Z._rescaleTexture(v,f,Z.scenes[0],Z._getInternalFormat(4),(()=>{Z._releaseTexture(v),b(f,Z)}))}else{f.width=C.width,f.height=C.height,f.generateMipMaps=v.fileInfo.images[e].levels.length>1;const V=F.GetInternalFormatFromBasisFormat(v.format,Z);f.format=V,b(f,Z);const l=v.fileInfo.images[e].levels;for(let v=0;v<l.length;v++){const h=l[v];Z._uploadCompressedDataToTextureDirectly(f,V,h.width,h.height,h.transcodedPixels,e,v)}!Z._features.basisNeedsPOT||Math.log2(f.width)%1===0&&Math.log2(f.height)%1===0||(h.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),f._cachedWrapU=J.e.CLAMP_ADDRESSMODE,f._cachedWrapV=J.e.CLAMP_ADDRESSMODE)}}},F={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(f,v)=>{let Z;switch(f){case V.cTFETC1:Z=36196;break;case V.cTFBC1:Z=33776;break;case V.cTFBC4:Z=33779;break;case V.cTFASTC_4x4:Z=37808;break;case V.cTFETC2:Z=37496;break;case V.cTFBC7:Z=36492}if(void 0===Z)throw"The chosen Basis transcoder format is not currently supported";return Z},TranscodeAsync:a,LoadTextureFromTranscodeResult:X};Object.defineProperty(F,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(f){C.JSModuleURL=f}}),Object.defineProperty(F,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(f){C.WasmModuleURL=f}});class U{constructor(){this.supportCascades=!1}loadCubeData(f,v,Z,V,J){if(Array.isArray(f))return;const l=v.getEngine().getCaps(),e={supportedCompressionFormats:{etc1:!!l.etc1,s3tc:!!l.s3tc,pvrtc:!!l.pvrtc,etc2:!!l.etc2,astc:!!l.astc,bc7:!!l.bptc}};a(f,e).then((f=>{const Z=f.fileInfo.images[0].levels.length>1&&v.generateMipMaps;X(v,f),v.getEngine()._setCubeMapTextureParams(v,Z),v.isReady=!0,v.onLoadedObservable.notifyObservers(v),v.onLoadedObservable.clear(),V&&V()})).catch((f=>{h.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),v.isReady=!0,J&&J(f)}))}loadData(f,v,Z){const V=v.getEngine().getCaps(),J={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};a(f,J).then((f=>{const V=f.fileInfo.images[0].levels[0],h=f.fileInfo.images[0].levels.length>1&&v.generateMipMaps;Z(V.width,V.height,h,-1!==f.format,(()=>{X(v,f)}))})).catch((f=>{h.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.Tools.Warn(`Failed to transcode Basis file: ${f}`),Z(0,0,!1,!1,(()=>{}),!0)}))}}}}]);