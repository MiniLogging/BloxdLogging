"use strict";(self.h6ljd275xwr=self.h6ljd275xwr||[]).push([[47],{13842:(n,y,H)=>{H.r(y),H.d(y,{_BasisTextureLoader:()=>Q});var o,G=H(11094),h=H(11269),k=H(11230);function i(){const n=0,y=1,H=2,o=3,G=6,h=8,k=9,i=10,B=14;let V=null;function q(n,y,H,o,G){const h=n.getImageTranscodedSizeInBytes(y,H,o);let k=new Uint8Array(h);if(!n.transcodeImage(k,y,H,o,1,0))return null;if(G){k=function(n,y,H,o){const G=new Uint16Array(4),h=new Uint16Array(H*o),k=H/4,i=o/4;for(let B=0;B<i;B++)for(let o=0;o<k;o++){const i=y+8*(B*k+o);G[0]=n[i]|n[i+1]<<8,G[1]=n[i+2]|n[i+3]<<8,G[2]=(2*(31&G[0])+1*(31&G[1]))/3|(2*(2016&G[0])+1*(2016&G[1]))/3&2016|(2*(63488&G[0])+1*(63488&G[1]))/3&63488,G[3]=(2*(31&G[1])+1*(31&G[0]))/3|(2*(2016&G[1])+1*(2016&G[0]))/3&2016|(2*(63488&G[1])+1*(63488&G[0]))/3&63488;for(let y=0;y<4;y++){const k=n[i+4+y];let V=(4*B+y)*H+4*o;h[V++]=G[3&k],h[V++]=G[k>>2&3],h[V++]=G[k>>4&3],h[V++]=G[k>>6&3]}}return h}(k,0,n.getImageWidth(y,H)+3&-4,n.getImageHeight(y,H)+3&-4)}return k}onmessage=b=>{if("init"===b.data.action){if(b.data.url)try{importScripts(b.data.url)}catch(A){postMessage({action:"error",error:A})}V||(V=BASIS({wasmBinary:b.data.wasmBinary})),null!==V&&V.then((n=>{BASIS=n,n.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===b.data.action){const V=b.data.config,A=b.data.imageData,U=new BASIS.BasisFile(A),T=function(n){const y=n.getHasAlpha(),H=n.getNumImages(),o=[];for(let G=0;G<H;G++){const y={levels:[]},H=n.getNumLevels(G);for(let o=0;o<H;o++){const H={width:n.getImageWidth(G,o),height:n.getImageHeight(G,o)};y.levels.push(H)}o.push(y)}return{Ti:y,images:o}}(U);let W=b.data.ignoreSupportedFormats?null:function(V,q){let b=null;V.supportedCompressionFormats&&(b=V.supportedCompressionFormats.astc?i:V.supportedCompressionFormats.bc7?G:V.supportedCompressionFormats.s3tc?q.Ti?o:H:V.supportedCompressionFormats.pvrtc?q.Ti?k:h:V.supportedCompressionFormats.etc2?y:V.supportedCompressionFormats.etc1?n:B);return b}(b.data.config,T),z=!1;null===W&&(z=!0,W=T.Ti?o:H);let Q=!0;U.startTranscoding()||(Q=!1);const l=[];for(let n=0;n<T.images.length&&Q;n++){const y=T.images[n];if(void 0===V.loadSingleImage||V.loadSingleImage===n){let H=y.levels.length;!1===V.loadMipmapLevels&&(H=1);for(let o=0;o<H;o++){const H=y.levels[o],G=q(U,n,o,W,z);if(!G){Q=!1;break}H.transcodedPixels=G,l.push(H.transcodedPixels.buffer)}}}U.close(),U.delete(),z&&(W=-1),Q?postMessage({action:"transcode",success:Q,id:b.data.id,fileInfo:T,format:W},l):postMessage({action:"transcode",success:Q,id:b.data.id})}}}!function(n){n[n.cTFETC1=0]="cTFETC1",n[n.cTFETC2=1]="cTFETC2",n[n.cTFBC1=2]="cTFBC1",n[n.cTFBC3=3]="cTFBC3",n[n.cTFBC4=4]="cTFBC4",n[n.cTFBC5=5]="cTFBC5",n[n.cTFBC7=6]="cTFBC7",n[n.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",n[n.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",n[n.cTFASTC_4x4=10]="cTFASTC_4x4",n[n.cTFATC_RGB=11]="cTFATC_RGB",n[n.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",n[n.cTFRGBA32=13]="cTFRGBA32",n[n.cTFRGB565=14]="cTFRGB565",n[n.cTFBGR565=15]="cTFBGR565",n[n.cTFRGBA4444=16]="cTFRGBA4444",n[n.cTFFXT1_RGB=17]="cTFFXT1_RGB",n[n.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",n[n.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",n[n.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",n[n.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(o||(o={}));const B={JSModuleURL:`${G.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${G.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let V=null,q=null,b=0;const A=async()=>(V||(V=new Promise(((n,y)=>{q?n(q):G.Tools.LoadFileAsync(G.Tools.GetBabylonScriptURL(B.WasmModuleURL)).then((H=>{if("function"!==typeof URL)return y("Basis transcoder requires an environment with a URL constructor");const o=URL.createObjectURL(new Blob([`(${i})()`],{type:"application/javascript"}));q=new Worker(o),async function(n,y,H){return await new Promise(((o,h)=>{const k=y=>{"init"===y.data.action?(n.removeEventListener("message",k),o(n)):"error"===y.data.action&&h(y.data.error||"error initializing worker")};n.addEventListener("message",k),n.postMessage({action:"init",url:H?G.Tools.GetBabylonScriptURL(H):void 0,wasmBinary:y},[y])}))}(q,H,B.JSModuleURL).then(n,y)})).catch(y)}))),await V),U=async(n,y)=>{const H=n instanceof ArrayBuffer?new Uint8Array(n):n;return await new Promise(((n,o)=>{A().then((()=>{const G=b++,h=y=>{"transcode"===y.data.action&&y.data.id===G&&(q.removeEventListener("message",h),y.data.success?n(y.data):o("Transcode is not supported on this device"))};q.addEventListener("message",h);const k=new Uint8Array(H.byteLength);k.set(new Uint8Array(H.buffer,H.byteOffset,H.byteLength)),q.postMessage({action:"transcode",id:G,imageData:k,config:y,ignoreSupportedFormats:false},[k.buffer])}),(n=>{o(n)}))}))},T=(n,y)=>{var H;let o=null===(H=y._gl)||void 0===H?void 0:H.TEXTURE_2D;var G;n.isCube&&(o=null===(G=y._gl)||void 0===G?void 0:G.TEXTURE_CUBE_MAP);y._bindTextureDirectly(o,n,!0)},W=(n,y)=>{const H=n.getEngine();for(let i=0;i<y.fileInfo.images.length;i++){const B=y.fileInfo.images[i].levels[0];if(n._invertVScale=n.invertY,-1===y.format||y.format===o.cTFRGB565)if(n.type=10,n.format=4,!H._features.basisNeedsPOT||Math.log2(B.width)%1===0&&Math.log2(B.height)%1===0)n._invertVScale=!n.invertY,n.width=B.width+3&-4,n.height=B.height+3&-4,n.samplingMode=2,T(n,H),H._uploadDataToTextureDirectly(n,new Uint16Array(B.transcodedPixels.buffer),i,0,4,!0);else{const y=new k.b(H,2);n._invertVScale=n.invertY,y.type=10,y.format=4,y.width=B.width+3&-4,y.height=B.height+3&-4,T(y,H),H._uploadDataToTextureDirectly(y,new Uint16Array(B.transcodedPixels.buffer),i,0,4,!0),H._rescaleTexture(y,n,H.scenes[0],H._getInternalFormat(4),(()=>{H._releaseTexture(y),T(n,H)}))}else{n.width=B.width,n.height=B.height,n.generateMipMaps=y.fileInfo.images[i].levels.length>1;const o=z.GetInternalFormatFromBasisFormat(y.format,H);n.format=o,T(n,H);const k=y.fileInfo.images[i].levels;for(let y=0;y<k.length;y++){const G=k[y];H._uploadCompressedDataToTextureDirectly(n,o,G.width,G.height,G.transcodedPixels,i,y)}!H._features.basisNeedsPOT||Math.log2(n.width)%1===0&&Math.log2(n.height)%1===0||(G.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),n._cachedWrapU=h.b.CLAMP_ADDRESSMODE,n._cachedWrapV=h.b.CLAMP_ADDRESSMODE)}}},z={JSModuleURL:B.JSModuleURL,WasmModuleURL:B.WasmModuleURL,GetInternalFormatFromBasisFormat:(n,y)=>{let H;switch(n){case o.cTFETC1:H=36196;break;case o.cTFBC1:H=33776;break;case o.cTFBC4:H=33779;break;case o.cTFASTC_4x4:H=37808;break;case o.cTFETC2:H=37496;break;case o.cTFBC7:H=36492}if(void 0===H)throw"The chosen Basis transcoder format is not currently supported";return H},TranscodeAsync:U,LoadTextureFromTranscodeResult:W};Object.defineProperty(z,"JSModuleURL",{get:function(){return B.JSModuleURL},set:function(n){B.JSModuleURL=n}}),Object.defineProperty(z,"WasmModuleURL",{get:function(){return B.WasmModuleURL},set:function(n){B.WasmModuleURL=n}});class Q{constructor(){this.supportCascades=!1}loadCubeData(n,y,H,o,h){if(Array.isArray(n))return;const k=y.getEngine().getCaps(),i={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};U(n,i).then((n=>{const H=n.fileInfo.images[0].levels.length>1&&y.generateMipMaps;W(y,n),y.getEngine()._setCubeMapTextureParams(y,H),y.isReady=!0,y.onLoadedObservable.notifyObservers(y),y.onLoadedObservable.clear(),o&&o()})).catch((n=>{G.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),y.isReady=!0,h&&h(n)}))}loadData(n,y,H){const o=y.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!o.etc1,s3tc:!!o.s3tc,pvrtc:!!o.pvrtc,etc2:!!o.etc2,astc:!!o.astc,bc7:!!o.bptc}};U(n,h).then((n=>{const o=n.fileInfo.images[0].levels[0],G=n.fileInfo.images[0].levels.length>1&&y.generateMipMaps;H(o.width,o.height,G,-1!==n.format,(()=>{W(y,n)}))})).catch((n=>{G.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),G.Tools.Warn(`Failed to transcode Basis file: ${n}`),H(0,0,!1,!1,(()=>{}),!0)}))}}}}]);