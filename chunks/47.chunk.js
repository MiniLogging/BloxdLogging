"use strict";(self["3gghkoft8x"]=self["3gghkoft8x"]||[]).push([[47],{14784:(y,S,I)=>{I.r(S),I.d(S,{_BasisTextureLoader:()=>j});var V,i=I(12128),A=I(12304),B=I(12265);function d(){const y=0,S=1,I=2,V=3,i=6,A=8,B=9,d=10,F=14;let J=null;function u(y,S,I,V,i){const A=y.getImageTranscodedSizeInBytes(S,I,V);let B=new Uint8Array(A);if(!y.transcodeImage(B,S,I,V,1,0))return null;if(i){B=function(y,S,I,V){const i=new Uint16Array(4),A=new Uint16Array(I*V),B=I/4,d=V/4;for(let F=0;F<d;F++)for(let V=0;V<B;V++){const d=S+8*(F*B+V);i[0]=y[d]|y[d+1]<<8,i[1]=y[d+2]|y[d+3]<<8,i[2]=(2*(31&i[0])+1*(31&i[1]))/3|(2*(2016&i[0])+1*(2016&i[1]))/3&2016|(2*(63488&i[0])+1*(63488&i[1]))/3&63488,i[3]=(2*(31&i[1])+1*(31&i[0]))/3|(2*(2016&i[1])+1*(2016&i[0]))/3&2016|(2*(63488&i[1])+1*(63488&i[0]))/3&63488;for(let S=0;S<4;S++){const B=y[d+4+S];let J=(4*F+S)*I+4*V;A[J++]=i[3&B],A[J++]=i[B>>2&3],A[J++]=i[B>>4&3],A[J++]=i[B>>6&3]}}return A}(B,0,y.getImageWidth(S,I)+3&-4,y.getImageHeight(S,I)+3&-4)}return B}onmessage=K=>{if("init"===K.data.action){if(K.data.url)try{importScripts(K.data.url)}catch(G){postMessage({action:"error",error:G})}J||(J=BASIS({wasmBinary:K.data.wasmBinary})),null!==J&&J.then((y=>{BASIS=y,y.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===K.data.action){const J=K.data.config,G=K.data.imageData,p=new BASIS.BasisFile(G),L=function(y){const S=y.getHasAlpha(),I=y.getNumImages(),V=[];for(let i=0;i<I;i++){const S={levels:[]},I=y.getNumLevels(i);for(let V=0;V<I;V++){const I={width:y.getImageWidth(i,V),height:y.getImageHeight(i,V)};S.levels.push(I)}V.push(S)}return{Fd:S,images:V}}(p);let T=K.data.ignoreSupportedFormats?null:function(J,u){let K=null;J.supportedCompressionFormats&&(K=J.supportedCompressionFormats.astc?d:J.supportedCompressionFormats.bc7?i:J.supportedCompressionFormats.s3tc?u.Fd?V:I:J.supportedCompressionFormats.pvrtc?u.Fd?B:A:J.supportedCompressionFormats.etc2?S:J.supportedCompressionFormats.etc1?y:F);return K}(K.data.config,L),l=!1;null===T&&(l=!0,T=L.Fd?V:I);let j=!0;p.startTranscoding()||(j=!1);const s=[];for(let y=0;y<L.images.length&&j;y++){const S=L.images[y];if(void 0===J.loadSingleImage||J.loadSingleImage===y){let I=S.levels.length;!1===J.loadMipmapLevels&&(I=1);for(let V=0;V<I;V++){const I=S.levels[V],i=u(p,y,V,T,l);if(!i){j=!1;break}I.transcodedPixels=i,s.push(I.transcodedPixels.buffer)}}}p.close(),p.delete(),l&&(T=-1),j?postMessage({action:"transcode",success:j,id:K.data.id,fileInfo:L,format:T},s):postMessage({action:"transcode",success:j,id:K.data.id})}}}!function(y){y[y.cTFETC1=0]="cTFETC1",y[y.cTFETC2=1]="cTFETC2",y[y.cTFBC1=2]="cTFBC1",y[y.cTFBC3=3]="cTFBC3",y[y.cTFBC4=4]="cTFBC4",y[y.cTFBC5=5]="cTFBC5",y[y.cTFBC7=6]="cTFBC7",y[y.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",y[y.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",y[y.cTFASTC_4x4=10]="cTFASTC_4x4",y[y.cTFATC_RGB=11]="cTFATC_RGB",y[y.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",y[y.cTFRGBA32=13]="cTFRGBA32",y[y.cTFRGB565=14]="cTFRGB565",y[y.cTFBGR565=15]="cTFBGR565",y[y.cTFRGBA4444=16]="cTFRGBA4444",y[y.cTFFXT1_RGB=17]="cTFFXT1_RGB",y[y.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",y[y.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",y[y.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",y[y.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(V||(V={}));const F={JSModuleURL:`${i.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${i.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let J=null,u=null,K=0;const G=async()=>(J||(J=new Promise(((y,S)=>{u?y(u):i.Tools.LoadFileAsync(i.Tools.GetBabylonScriptURL(F.WasmModuleURL)).then((I=>{if("function"!==typeof URL)return S("Basis transcoder requires an environment with a URL constructor");const V=URL.createObjectURL(new Blob([`(${d})()`],{type:"application/javascript"}));u=new Worker(V),async function(y,S,I){return await new Promise(((V,A)=>{const B=S=>{"init"===S.data.action?(y.removeEventListener("message",B),V(y)):"error"===S.data.action&&A(S.data.error||"error initializing worker")};y.addEventListener("message",B),y.postMessage({action:"init",url:I?i.Tools.GetBabylonScriptURL(I):void 0,wasmBinary:S},[S])}))}(u,I,F.JSModuleURL).then(y,S)})).catch(S)}))),await J),p=async(y,S)=>{const I=y instanceof ArrayBuffer?new Uint8Array(y):y;return await new Promise(((y,V)=>{G().then((()=>{const i=K++,A=S=>{"transcode"===S.data.action&&S.data.id===i&&(u.removeEventListener("message",A),S.data.success?y(S.data):V("Transcode is not supported on this device"))};u.addEventListener("message",A);const B=new Uint8Array(I.byteLength);B.set(new Uint8Array(I.buffer,I.byteOffset,I.byteLength)),u.postMessage({action:"transcode",id:i,imageData:B,config:S,ignoreSupportedFormats:false},[B.buffer])}),(y=>{V(y)}))}))},L=(y,S)=>{var I;let V=null===(I=S._gl)||void 0===I?void 0:I.TEXTURE_2D;var i;y.isCube&&(V=null===(i=S._gl)||void 0===i?void 0:i.TEXTURE_CUBE_MAP);S._bindTextureDirectly(V,y,!0)},T=(y,S)=>{const I=y.getEngine();for(let d=0;d<S.fileInfo.images.length;d++){const F=S.fileInfo.images[d].levels[0];if(y._invertVScale=y.invertY,-1===S.format||S.format===V.cTFRGB565)if(y.type=10,y.format=4,!I._features.basisNeedsPOT||Math.log2(F.width)%1===0&&Math.log2(F.height)%1===0)y._invertVScale=!y.invertY,y.width=F.width+3&-4,y.height=F.height+3&-4,y.samplingMode=2,L(y,I),I._uploadDataToTextureDirectly(y,new Uint16Array(F.transcodedPixels.buffer),d,0,4,!0);else{const S=new B.c(I,2);y._invertVScale=y.invertY,S.type=10,S.format=4,S.width=F.width+3&-4,S.height=F.height+3&-4,L(S,I),I._uploadDataToTextureDirectly(S,new Uint16Array(F.transcodedPixels.buffer),d,0,4,!0),I._rescaleTexture(S,y,I.scenes[0],I._getInternalFormat(4),(()=>{I._releaseTexture(S),L(y,I)}))}else{y.width=F.width,y.height=F.height,y.generateMipMaps=S.fileInfo.images[d].levels.length>1;const V=l.GetInternalFormatFromBasisFormat(S.format,I);y.format=V,L(y,I);const B=S.fileInfo.images[d].levels;for(let S=0;S<B.length;S++){const i=B[S];I._uploadCompressedDataToTextureDirectly(y,V,i.width,i.height,i.transcodedPixels,d,S)}!I._features.basisNeedsPOT||Math.log2(y.width)%1===0&&Math.log2(y.height)%1===0||(i.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),y._cachedWrapU=A.e.CLAMP_ADDRESSMODE,y._cachedWrapV=A.e.CLAMP_ADDRESSMODE)}}},l={JSModuleURL:F.JSModuleURL,WasmModuleURL:F.WasmModuleURL,GetInternalFormatFromBasisFormat:(y,S)=>{let I;switch(y){case V.cTFETC1:I=36196;break;case V.cTFBC1:I=33776;break;case V.cTFBC4:I=33779;break;case V.cTFASTC_4x4:I=37808;break;case V.cTFETC2:I=37496;break;case V.cTFBC7:I=36492}if(void 0===I)throw"The chosen Basis transcoder format is not currently supported";return I},TranscodeAsync:p,LoadTextureFromTranscodeResult:T};Object.defineProperty(l,"JSModuleURL",{get:function(){return F.JSModuleURL},set:function(y){F.JSModuleURL=y}}),Object.defineProperty(l,"WasmModuleURL",{get:function(){return F.WasmModuleURL},set:function(y){F.WasmModuleURL=y}});class j{constructor(){this.supportCascades=!1}loadCubeData(y,S,I,V,A){if(Array.isArray(y))return;const B=S.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!B.etc1,s3tc:!!B.s3tc,pvrtc:!!B.pvrtc,etc2:!!B.etc2,astc:!!B.astc,bc7:!!B.bptc}};p(y,d).then((y=>{const I=y.fileInfo.images[0].levels.length>1&&S.generateMipMaps;T(S,y),S.getEngine()._setCubeMapTextureParams(S,I),S.isReady=!0,S.onLoadedObservable.notifyObservers(S),S.onLoadedObservable.clear(),V&&V()})).catch((y=>{i.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.isReady=!0,A&&A(y)}))}loadData(y,S,I){const V=S.getEngine().getCaps(),A={supportedCompressionFormats:{etc1:!!V.etc1,s3tc:!!V.s3tc,pvrtc:!!V.pvrtc,etc2:!!V.etc2,astc:!!V.astc,bc7:!!V.bptc}};p(y,A).then((y=>{const V=y.fileInfo.images[0].levels[0],i=y.fileInfo.images[0].levels.length>1&&S.generateMipMaps;I(V.width,V.height,i,-1!==y.format,(()=>{T(S,y)}))})).catch((y=>{i.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),i.Tools.Warn(`Failed to transcode Basis file: ${y}`),I(0,0,!1,!1,(()=>{}),!0)}))}}}}]);