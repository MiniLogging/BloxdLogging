"use strict";(self.rvold1i0ywi=self.rvold1i0ywi||[]).push([[47],{13698:(F,b,Q)=>{Q.r(b),Q.d(b,{_BasisTextureLoader:()=>X});var C,z=Q(11128),t=Q(11287),g=Q(11241);function W(){const F=0,b=1,Q=2,C=3,z=6,t=8,g=9,W=10,Z=14;let q=null;function G(F,b,Q,C,z){const t=F.getImageTranscodedSizeInBytes(b,Q,C);let g=new Uint8Array(t);if(!F.transcodeImage(g,b,Q,C,1,0))return null;if(z){g=function(F,b,Q,C){const z=new Uint16Array(4),t=new Uint16Array(Q*C),g=Q/4,W=C/4;for(let Z=0;Z<W;Z++)for(let C=0;C<g;C++){const W=b+8*(Z*g+C);z[0]=F[W]|F[W+1]<<8,z[1]=F[W+2]|F[W+3]<<8,z[2]=(2*(31&z[0])+1*(31&z[1]))/3|(2*(2016&z[0])+1*(2016&z[1]))/3&2016|(2*(63488&z[0])+1*(63488&z[1]))/3&63488,z[3]=(2*(31&z[1])+1*(31&z[0]))/3|(2*(2016&z[1])+1*(2016&z[0]))/3&2016|(2*(63488&z[1])+1*(63488&z[0]))/3&63488;for(let b=0;b<4;b++){const g=F[W+4+b];let q=(4*Z+b)*Q+4*C;t[q++]=z[3&g],t[q++]=z[g>>2&3],t[q++]=z[g>>4&3],t[q++]=z[g>>6&3]}}return t}(g,0,F.getImageWidth(b,Q)+3&-4,F.getImageHeight(b,Q)+3&-4)}return g}onmessage=K=>{if("init"===K.data.action){if(K.data.url)try{importScripts(K.data.url)}catch(e){postMessage({action:"error",error:e})}q||(q=BASIS({wasmBinary:K.data.wasmBinary})),null!==q&&q.then((F=>{BASIS=F,F.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===K.data.action){const q=K.data.config,e=K.data.imageData,N=new BASIS.BasisFile(e),y=function(F){const b=F.getHasAlpha(),Q=F.getNumImages(),C=[];for(let z=0;z<Q;z++){const b={levels:[]},Q=F.getNumLevels(z);for(let C=0;C<Q;C++){const Q={width:F.getImageWidth(z,C),height:F.getImageHeight(z,C)};b.levels.push(Q)}C.push(b)}return{ib:b,images:C}}(N);let E=K.data.ignoreSupportedFormats?null:function(q,G){let K=null;q.supportedCompressionFormats&&(K=q.supportedCompressionFormats.astc?W:q.supportedCompressionFormats.bc7?z:q.supportedCompressionFormats.s3tc?G.ib?C:Q:q.supportedCompressionFormats.pvrtc?G.ib?g:t:q.supportedCompressionFormats.etc2?b:q.supportedCompressionFormats.etc1?F:Z);return K}(K.data.config,y),c=!1;null===E&&(c=!0,E=y.ib?C:Q);let X=!0;N.startTranscoding()||(X=!1);const L=[];for(let F=0;F<y.images.length&&X;F++){const b=y.images[F];if(void 0===q.loadSingleImage||q.loadSingleImage===F){let Q=b.levels.length;!1===q.loadMipmapLevels&&(Q=1);for(let C=0;C<Q;C++){const Q=b.levels[C],z=G(N,F,C,E,c);if(!z){X=!1;break}Q.transcodedPixels=z,L.push(Q.transcodedPixels.buffer)}}}N.close(),N.delete(),c&&(E=-1),X?postMessage({action:"transcode",success:X,id:K.data.id,fileInfo:y,format:E},L):postMessage({action:"transcode",success:X,id:K.data.id})}}}!function(F){F[F.cTFETC1=0]="cTFETC1",F[F.cTFETC2=1]="cTFETC2",F[F.cTFBC1=2]="cTFBC1",F[F.cTFBC3=3]="cTFBC3",F[F.cTFBC4=4]="cTFBC4",F[F.cTFBC5=5]="cTFBC5",F[F.cTFBC7=6]="cTFBC7",F[F.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",F[F.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",F[F.cTFASTC_4x4=10]="cTFASTC_4x4",F[F.cTFATC_RGB=11]="cTFATC_RGB",F[F.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",F[F.cTFRGBA32=13]="cTFRGBA32",F[F.cTFRGB565=14]="cTFRGB565",F[F.cTFBGR565=15]="cTFBGR565",F[F.cTFRGBA4444=16]="cTFRGBA4444",F[F.cTFFXT1_RGB=17]="cTFFXT1_RGB",F[F.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",F[F.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",F[F.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",F[F.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(C||(C={}));const Z={JSModuleURL:`${z.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${z.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let q=null,G=null,K=0;const e=async()=>(q||(q=new Promise(((F,b)=>{G?F(G):z.Tools.LoadFileAsync(z.Tools.GetBabylonScriptURL(Z.WasmModuleURL)).then((Q=>{if("function"!==typeof URL)return b("Basis transcoder requires an environment with a URL constructor");const C=URL.createObjectURL(new Blob([`(${W})()`],{type:"application/javascript"}));G=new Worker(C),async function(F,b,Q){return await new Promise(((C,t)=>{const g=b=>{"init"===b.data.action?(F.removeEventListener("message",g),C(F)):"error"===b.data.action&&t(b.data.error||"error initializing worker")};F.addEventListener("message",g),F.postMessage({action:"init",url:Q?z.Tools.GetBabylonScriptURL(Q):void 0,wasmBinary:b},[b])}))}(G,Q,Z.JSModuleURL).then(F,b)})).catch(b)}))),await q),N=async(F,b)=>{const Q=F instanceof ArrayBuffer?new Uint8Array(F):F;return await new Promise(((F,C)=>{e().then((()=>{const z=K++,t=b=>{"transcode"===b.data.action&&b.data.id===z&&(G.removeEventListener("message",t),b.data.success?F(b.data):C("Transcode is not supported on this device"))};G.addEventListener("message",t);const g=new Uint8Array(Q.byteLength);g.set(new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength)),G.postMessage({action:"transcode",id:z,imageData:g,config:b,ignoreSupportedFormats:false},[g.buffer])}),(F=>{C(F)}))}))},y=(F,b)=>{var Q;let C=null===(Q=b._gl)||void 0===Q?void 0:Q.TEXTURE_2D;var z;F.isCube&&(C=null===(z=b._gl)||void 0===z?void 0:z.TEXTURE_CUBE_MAP);b._bindTextureDirectly(C,F,!0)},E=(F,b)=>{const Q=F.getEngine();for(let W=0;W<b.fileInfo.images.length;W++){const Z=b.fileInfo.images[W].levels[0];if(F._invertVScale=F.invertY,-1===b.format||b.format===C.cTFRGB565)if(F.type=10,F.format=4,!Q._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0)F._invertVScale=!F.invertY,F.width=Z.width+3&-4,F.height=Z.height+3&-4,F.samplingMode=2,y(F,Q),Q._uploadDataToTextureDirectly(F,new Uint16Array(Z.transcodedPixels.buffer),W,0,4,!0);else{const b=new g.b(Q,2);F._invertVScale=F.invertY,b.type=10,b.format=4,b.width=Z.width+3&-4,b.height=Z.height+3&-4,y(b,Q),Q._uploadDataToTextureDirectly(b,new Uint16Array(Z.transcodedPixels.buffer),W,0,4,!0),Q._rescaleTexture(b,F,Q.scenes[0],Q._getInternalFormat(4),(()=>{Q._releaseTexture(b),y(F,Q)}))}else{F.width=Z.width,F.height=Z.height,F.generateMipMaps=b.fileInfo.images[W].levels.length>1;const C=c.GetInternalFormatFromBasisFormat(b.format,Q);F.format=C,y(F,Q);const g=b.fileInfo.images[W].levels;for(let b=0;b<g.length;b++){const z=g[b];Q._uploadCompressedDataToTextureDirectly(F,C,z.width,z.height,z.transcodedPixels,W,b)}!Q._features.basisNeedsPOT||Math.log2(F.width)%1===0&&Math.log2(F.height)%1===0||(z.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),F._cachedWrapU=t.b.CLAMP_ADDRESSMODE,F._cachedWrapV=t.b.CLAMP_ADDRESSMODE)}}},c={JSModuleURL:Z.JSModuleURL,WasmModuleURL:Z.WasmModuleURL,GetInternalFormatFromBasisFormat:(F,b)=>{let Q;switch(F){case C.cTFETC1:Q=36196;break;case C.cTFBC1:Q=33776;break;case C.cTFBC4:Q=33779;break;case C.cTFASTC_4x4:Q=37808;break;case C.cTFETC2:Q=37496;break;case C.cTFBC7:Q=36492}if(void 0===Q)throw"The chosen Basis transcoder format is not currently supported";return Q},TranscodeAsync:N,LoadTextureFromTranscodeResult:E};Object.defineProperty(c,"JSModuleURL",{get:function(){return Z.JSModuleURL},set:function(F){Z.JSModuleURL=F}}),Object.defineProperty(c,"WasmModuleURL",{get:function(){return Z.WasmModuleURL},set:function(F){Z.WasmModuleURL=F}});class X{constructor(){this.supportCascades=!1}loadCubeData(F,b,Q,C,t){if(Array.isArray(F))return;const g=b.getEngine().getCaps(),W={supportedCompressionFormats:{etc1:!!g.etc1,s3tc:!!g.s3tc,pvrtc:!!g.pvrtc,etc2:!!g.etc2,astc:!!g.astc,bc7:!!g.bptc}};N(F,W).then((F=>{const Q=F.fileInfo.images[0].levels.length>1&&b.generateMipMaps;E(b,F),b.getEngine()._setCubeMapTextureParams(b,Q),b.isReady=!0,b.onLoadedObservable.notifyObservers(b),b.onLoadedObservable.clear(),C&&C()})).catch((F=>{z.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),b.isReady=!0,t&&t(F)}))}loadData(F,b,Q){const C=b.getEngine().getCaps(),t={supportedCompressionFormats:{etc1:!!C.etc1,s3tc:!!C.s3tc,pvrtc:!!C.pvrtc,etc2:!!C.etc2,astc:!!C.astc,bc7:!!C.bptc}};N(F,t).then((F=>{const C=F.fileInfo.images[0].levels[0],z=F.fileInfo.images[0].levels.length>1&&b.generateMipMaps;Q(C.width,C.height,z,-1!==F.format,(()=>{E(b,F)}))})).catch((F=>{z.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.Tools.Warn(`Failed to transcode Basis file: ${F}`),Q(0,0,!1,!1,(()=>{}),!0)}))}}}}]);