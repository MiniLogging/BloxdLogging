"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[47],{14252:(Z,h,V)=>{V.r(h),V.d(h,{_BasisTextureLoader:()=>o});var v,A=V(11564),H=V(11713),K=V(11673);function d(){const Z=0,h=1,V=2,v=3,A=6,H=8,K=9,d=10,a=14;let n=null;function x(Z,h,V,v,A){const H=Z.getImageTranscodedSizeInBytes(h,V,v);let K=new Uint8Array(H);if(!Z.transcodeImage(K,h,V,v,1,0))return null;if(A){K=function(Z,h,V,v){const A=new Uint16Array(4),H=new Uint16Array(V*v),K=V/4,d=v/4;for(let a=0;a<d;a++)for(let v=0;v<K;v++){const d=h+8*(a*K+v);A[0]=Z[d]|Z[d+1]<<8,A[1]=Z[d+2]|Z[d+3]<<8,A[2]=(2*(31&A[0])+1*(31&A[1]))/3|(2*(2016&A[0])+1*(2016&A[1]))/3&2016|(2*(63488&A[0])+1*(63488&A[1]))/3&63488,A[3]=(2*(31&A[1])+1*(31&A[0]))/3|(2*(2016&A[1])+1*(2016&A[0]))/3&2016|(2*(63488&A[1])+1*(63488&A[0]))/3&63488;for(let h=0;h<4;h++){const K=Z[d+4+h];let n=(4*a+h)*V+4*v;H[n++]=A[3&K],H[n++]=A[K>>2&3],H[n++]=A[K>>4&3],H[n++]=A[K>>6&3]}}return H}(K,0,Z.getImageWidth(h,V)+3&-4,Z.getImageHeight(h,V)+3&-4)}return K}onmessage=N=>{if("init"===N.data.action){if(N.data.url)try{importScripts(N.data.url)}catch(D){postMessage({action:"error",error:D})}n||(n=BASIS({wasmBinary:N.data.wasmBinary})),null!==n&&n.then((Z=>{BASIS=Z,Z.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===N.data.action){const n=N.data.config,D=N.data.imageData,k=new BASIS.BasisFile(D),u=function(Z){const h=Z.getHasAlpha(),V=Z.getNumImages(),v=[];for(let A=0;A<V;A++){const h={levels:[]},V=Z.getNumLevels(A);for(let v=0;v<V;v++){const V={width:Z.getImageWidth(A,v),height:Z.getImageHeight(A,v)};h.levels.push(V)}v.push(h)}return{Uh:h,images:v}}(k);let F=N.data.ignoreSupportedFormats?null:function(n,x){let N=null;n.supportedCompressionFormats&&(N=n.supportedCompressionFormats.astc?d:n.supportedCompressionFormats.bc7?A:n.supportedCompressionFormats.s3tc?x.Uh?v:V:n.supportedCompressionFormats.pvrtc?x.Uh?K:H:n.supportedCompressionFormats.etc2?h:n.supportedCompressionFormats.etc1?Z:a);return N}(N.data.config,u),b=!1;null===F&&(b=!0,F=u.Uh?v:V);let o=!0;k.startTranscoding()||(o=!1);const q=[];for(let Z=0;Z<u.images.length&&o;Z++){const h=u.images[Z];if(void 0===n.loadSingleImage||n.loadSingleImage===Z){let V=h.levels.length;!1===n.loadMipmapLevels&&(V=1);for(let v=0;v<V;v++){const V=h.levels[v],A=x(k,Z,v,F,b);if(!A){o=!1;break}V.transcodedPixels=A,q.push(V.transcodedPixels.buffer)}}}k.close(),k.delete(),b&&(F=-1),o?postMessage({action:"transcode",success:o,id:N.data.id,fileInfo:u,format:F},q):postMessage({action:"transcode",success:o,id:N.data.id})}}}!function(Z){Z[Z.cTFETC1=0]="cTFETC1",Z[Z.cTFETC2=1]="cTFETC2",Z[Z.cTFBC1=2]="cTFBC1",Z[Z.cTFBC3=3]="cTFBC3",Z[Z.cTFBC4=4]="cTFBC4",Z[Z.cTFBC5=5]="cTFBC5",Z[Z.cTFBC7=6]="cTFBC7",Z[Z.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",Z[Z.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",Z[Z.cTFASTC_4x4=10]="cTFASTC_4x4",Z[Z.cTFATC_RGB=11]="cTFATC_RGB",Z[Z.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",Z[Z.cTFRGBA32=13]="cTFRGBA32",Z[Z.cTFRGB565=14]="cTFRGB565",Z[Z.cTFBGR565=15]="cTFBGR565",Z[Z.cTFRGBA4444=16]="cTFRGBA4444",Z[Z.cTFFXT1_RGB=17]="cTFFXT1_RGB",Z[Z.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",Z[Z.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",Z[Z.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",Z[Z.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(v||(v={}));const a={JSModuleURL:`${A.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${A.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let n=null,x=null,N=0;const D=async()=>(n||(n=new Promise(((Z,h)=>{x?Z(x):A.Tools.LoadFileAsync(A.Tools.GetBabylonScriptURL(a.WasmModuleURL)).then((V=>{if("function"!==typeof URL)return h("Basis transcoder requires an environment with a URL constructor");const v=URL.createObjectURL(new Blob([`(${d})()`],{type:"application/javascript"}));x=new Worker(v),async function(Z,h,V){return await new Promise(((v,H)=>{const K=h=>{"init"===h.data.action?(Z.removeEventListener("message",K),v(Z)):"error"===h.data.action&&H(h.data.error||"error initializing worker")};Z.addEventListener("message",K),Z.postMessage({action:"init",url:V?A.Tools.GetBabylonScriptURL(V):void 0,wasmBinary:h},[h])}))}(x,V,a.JSModuleURL).then(Z,h)})).catch(h)}))),await n),k=async(Z,h)=>{const V=Z instanceof ArrayBuffer?new Uint8Array(Z):Z;return await new Promise(((Z,v)=>{D().then((()=>{const A=N++,H=h=>{"transcode"===h.data.action&&h.data.id===A&&(x.removeEventListener("message",H),h.data.success?Z(h.data):v("Transcode is not supported on this device"))};x.addEventListener("message",H);const K=new Uint8Array(V.byteLength);K.set(new Uint8Array(V.buffer,V.byteOffset,V.byteLength)),x.postMessage({action:"transcode",id:A,imageData:K,config:h,ignoreSupportedFormats:false},[K.buffer])}),(Z=>{v(Z)}))}))},u=(Z,h)=>{var V;let v=null===(V=h._gl)||void 0===V?void 0:V.TEXTURE_2D;var A;Z.isCube&&(v=null===(A=h._gl)||void 0===A?void 0:A.TEXTURE_CUBE_MAP);h._bindTextureDirectly(v,Z,!0)},F=(Z,h)=>{const V=Z.getEngine();for(let d=0;d<h.fileInfo.images.length;d++){const a=h.fileInfo.images[d].levels[0];if(Z._invertVScale=Z.invertY,-1===h.format||h.format===v.cTFRGB565)if(Z.type=10,Z.format=4,!V._features.basisNeedsPOT||Math.log2(a.width)%1===0&&Math.log2(a.height)%1===0)Z._invertVScale=!Z.invertY,Z.width=a.width+3&-4,Z.height=a.height+3&-4,Z.samplingMode=2,u(Z,V),V._uploadDataToTextureDirectly(Z,new Uint16Array(a.transcodedPixels.buffer),d,0,4,!0);else{const h=new K.c(V,2);Z._invertVScale=Z.invertY,h.type=10,h.format=4,h.width=a.width+3&-4,h.height=a.height+3&-4,u(h,V),V._uploadDataToTextureDirectly(h,new Uint16Array(a.transcodedPixels.buffer),d,0,4,!0),V._rescaleTexture(h,Z,V.scenes[0],V._getInternalFormat(4),(()=>{V._releaseTexture(h),u(Z,V)}))}else{Z.width=a.width,Z.height=a.height,Z.generateMipMaps=h.fileInfo.images[d].levels.length>1;const v=b.GetInternalFormatFromBasisFormat(h.format,V);Z.format=v,u(Z,V);const K=h.fileInfo.images[d].levels;for(let h=0;h<K.length;h++){const A=K[h];V._uploadCompressedDataToTextureDirectly(Z,v,A.width,A.height,A.transcodedPixels,d,h)}!V._features.basisNeedsPOT||Math.log2(Z.width)%1===0&&Math.log2(Z.height)%1===0||(A.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),Z._cachedWrapU=H.e.CLAMP_ADDRESSMODE,Z._cachedWrapV=H.e.CLAMP_ADDRESSMODE)}}},b={JSModuleURL:a.JSModuleURL,WasmModuleURL:a.WasmModuleURL,GetInternalFormatFromBasisFormat:(Z,h)=>{let V;switch(Z){case v.cTFETC1:V=36196;break;case v.cTFBC1:V=33776;break;case v.cTFBC4:V=33779;break;case v.cTFASTC_4x4:V=37808;break;case v.cTFETC2:V=37496;break;case v.cTFBC7:V=36492}if(void 0===V)throw"The chosen Basis transcoder format is not currently supported";return V},TranscodeAsync:k,LoadTextureFromTranscodeResult:F};Object.defineProperty(b,"JSModuleURL",{get:function(){return a.JSModuleURL},set:function(Z){a.JSModuleURL=Z}}),Object.defineProperty(b,"WasmModuleURL",{get:function(){return a.WasmModuleURL},set:function(Z){a.WasmModuleURL=Z}});class o{constructor(){this.supportCascades=!1}loadCubeData(Z,h,V,v,H){if(Array.isArray(Z))return;const K=h.getEngine().getCaps(),d={supportedCompressionFormats:{etc1:!!K.etc1,s3tc:!!K.s3tc,pvrtc:!!K.pvrtc,etc2:!!K.etc2,astc:!!K.astc,bc7:!!K.bptc}};k(Z,d).then((Z=>{const V=Z.fileInfo.images[0].levels.length>1&&h.generateMipMaps;F(h,Z),h.getEngine()._setCubeMapTextureParams(h,V),h.isReady=!0,h.onLoadedObservable.notifyObservers(h),h.onLoadedObservable.clear(),v&&v()})).catch((Z=>{A.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),h.isReady=!0,H&&H(Z)}))}loadData(Z,h,V){const v=h.getEngine().getCaps(),H={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};k(Z,H).then((Z=>{const v=Z.fileInfo.images[0].levels[0],A=Z.fileInfo.images[0].levels.length>1&&h.generateMipMaps;V(v.width,v.height,A,-1!==Z.format,(()=>{F(h,Z)}))})).catch((Z=>{A.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),A.Tools.Warn(`Failed to transcode Basis file: ${Z}`),V(0,0,!1,!1,(()=>{}),!0)}))}}}}]);