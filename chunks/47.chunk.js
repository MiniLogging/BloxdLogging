"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[47],{15081:(M,A,O)=>{O.r(A),O.d(A,{_BasisTextureLoader:()=>w});var S,z=O(12768),Q=O(12949),X=O(12888);function c(){const M=0,A=1,O=2,S=3,z=6,Q=8,X=9,c=10,j=14;let B=null;function g(M,A,O,S,z){const Q=M.getImageTranscodedSizeInBytes(A,O,S);let X=new Uint8Array(Q);if(!M.transcodeImage(X,A,O,S,1,0))return null;if(z){X=function(M,A,O,S){const z=new Uint16Array(4),Q=new Uint16Array(O*S),X=O/4,c=S/4;for(let j=0;j<c;j++)for(let S=0;S<X;S++){const c=A+8*(j*X+S);z[0]=M[c]|M[c+1]<<8,z[1]=M[c+2]|M[c+3]<<8,z[2]=(2*(31&z[0])+1*(31&z[1]))/3|(2*(2016&z[0])+1*(2016&z[1]))/3&2016|(2*(63488&z[0])+1*(63488&z[1]))/3&63488,z[3]=(2*(31&z[1])+1*(31&z[0]))/3|(2*(2016&z[1])+1*(2016&z[0]))/3&2016|(2*(63488&z[1])+1*(63488&z[0]))/3&63488;for(let A=0;A<4;A++){const X=M[c+4+A];let B=(4*j+A)*O+4*S;Q[B++]=z[3&X],Q[B++]=z[X>>2&3],Q[B++]=z[X>>4&3],Q[B++]=z[X>>6&3]}}return Q}(X,0,M.getImageWidth(A,O)+3&-4,M.getImageHeight(A,O)+3&-4)}return X}onmessage=e=>{if("init"===e.data.action){if(e.data.url)try{importScripts(e.data.url)}catch(T){postMessage({action:"error",error:T})}B||(B=BASIS({wasmBinary:e.data.wasmBinary})),null!==B&&B.then((M=>{BASIS=M,M.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===e.data.action){const B=e.data.config,T=e.data.imageData,J=new BASIS.BasisFile(T),K=function(M){const A=M.getHasAlpha(),O=M.getNumImages(),S=[];for(let z=0;z<O;z++){const A={levels:[]},O=M.getNumLevels(z);for(let S=0;S<O;S++){const O={width:M.getImageWidth(z,S),height:M.getImageHeight(z,S)};A.levels.push(O)}S.push(A)}return{ec:A,images:S}}(J);let G=e.data.ignoreSupportedFormats?null:function(B,g){let e=null;B.supportedCompressionFormats&&(e=B.supportedCompressionFormats.astc?c:B.supportedCompressionFormats.bc7?z:B.supportedCompressionFormats.s3tc?g.ec?S:O:B.supportedCompressionFormats.pvrtc?g.ec?X:Q:B.supportedCompressionFormats.etc2?A:B.supportedCompressionFormats.etc1?M:j);return e}(e.data.config,K),d=!1;null===G&&(d=!0,G=K.ec?S:O);let w=!0;J.startTranscoding()||(w=!1);const I=[];for(let M=0;M<K.images.length&&w;M++){const A=K.images[M];if(void 0===B.loadSingleImage||B.loadSingleImage===M){let O=A.levels.length;!1===B.loadMipmapLevels&&(O=1);for(let S=0;S<O;S++){const O=A.levels[S],z=g(J,M,S,G,d);if(!z){w=!1;break}O.transcodedPixels=z,I.push(O.transcodedPixels.buffer)}}}J.close(),J.delete(),d&&(G=-1),w?postMessage({action:"transcode",success:w,id:e.data.id,fileInfo:K,format:G},I):postMessage({action:"transcode",success:w,id:e.data.id})}}}!function(M){M[M.cTFETC1=0]="cTFETC1",M[M.cTFETC2=1]="cTFETC2",M[M.cTFBC1=2]="cTFBC1",M[M.cTFBC3=3]="cTFBC3",M[M.cTFBC4=4]="cTFBC4",M[M.cTFBC5=5]="cTFBC5",M[M.cTFBC7=6]="cTFBC7",M[M.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",M[M.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",M[M.cTFASTC_4x4=10]="cTFASTC_4x4",M[M.cTFATC_RGB=11]="cTFATC_RGB",M[M.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",M[M.cTFRGBA32=13]="cTFRGBA32",M[M.cTFRGB565=14]="cTFRGB565",M[M.cTFBGR565=15]="cTFBGR565",M[M.cTFRGBA4444=16]="cTFRGBA4444",M[M.cTFFXT1_RGB=17]="cTFFXT1_RGB",M[M.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",M[M.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",M[M.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",M[M.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(S||(S={}));const j={JSModuleURL:"".concat(z.Tools._DefaultCdnUrl,"/basisTranscoder/1/basis_transcoder.js"),WasmModuleURL:"".concat(z.Tools._DefaultCdnUrl,"/basisTranscoder/1/basis_transcoder.wasm")};let B=null,g=null,e=0;const T=async()=>(B||(B=new Promise(((M,A)=>{g?M(g):z.Tools.LoadFileAsync(z.Tools.GetBabylonScriptURL(j.WasmModuleURL)).then((O=>{if("function"!==typeof URL)return A("Basis transcoder requires an environment with a URL constructor");const S=URL.createObjectURL(new Blob(["(".concat(c,")()")],{type:"application/javascript"}));g=new Worker(S),async function(M,A,O){return await new Promise(((S,Q)=>{const X=A=>{"init"===A.data.action?(M.removeEventListener("message",X),S(M)):"error"===A.data.action&&Q(A.data.error||"error initializing worker")};M.addEventListener("message",X),M.postMessage({action:"init",url:O?z.Tools.GetBabylonScriptURL(O):void 0,wasmBinary:A},[A])}))}(g,O,j.JSModuleURL).then(M,A)})).catch(A)}))),await B),J=async(M,A)=>{const O=M instanceof ArrayBuffer?new Uint8Array(M):M;return await new Promise(((M,S)=>{T().then((()=>{const z=e++,Q=A=>{"transcode"===A.data.action&&A.data.id===z&&(g.removeEventListener("message",Q),A.data.success?M(A.data):S("Transcode is not supported on this device"))};g.addEventListener("message",Q);const X=new Uint8Array(O.byteLength);X.set(new Uint8Array(O.buffer,O.byteOffset,O.byteLength)),g.postMessage({action:"transcode",id:z,imageData:X,config:A,ignoreSupportedFormats:false},[X.buffer])}),(M=>{S(M)}))}))},K=(M,A)=>{var O;let S=null===(O=A._gl)||void 0===O?void 0:O.TEXTURE_2D;var z;M.isCube&&(S=null===(z=A._gl)||void 0===z?void 0:z.TEXTURE_CUBE_MAP);A._bindTextureDirectly(S,M,!0)},G=(M,A)=>{const O=M.getEngine();for(let c=0;c<A.fileInfo.images.length;c++){const j=A.fileInfo.images[c].levels[0];if(M._invertVScale=M.invertY,-1===A.format||A.format===S.cTFRGB565)if(M.type=10,M.format=4,!O._features.basisNeedsPOT||Math.log2(j.width)%1===0&&Math.log2(j.height)%1===0)M._invertVScale=!M.invertY,M.width=j.width+3&-4,M.height=j.height+3&-4,M.samplingMode=2,K(M,O),O._uploadDataToTextureDirectly(M,new Uint16Array(j.transcodedPixels.buffer),c,0,4,!0);else{const A=new X.b(O,2);M._invertVScale=M.invertY,A.type=10,A.format=4,A.width=j.width+3&-4,A.height=j.height+3&-4,K(A,O),O._uploadDataToTextureDirectly(A,new Uint16Array(j.transcodedPixels.buffer),c,0,4,!0),O._rescaleTexture(A,M,O.scenes[0],O._getInternalFormat(4),(()=>{O._releaseTexture(A),K(M,O)}))}else{M.width=j.width,M.height=j.height,M.generateMipMaps=A.fileInfo.images[c].levels.length>1;const S=d.GetInternalFormatFromBasisFormat(A.format,O);M.format=S,K(M,O);const X=A.fileInfo.images[c].levels;for(let A=0;A<X.length;A++){const z=X[A];O._uploadCompressedDataToTextureDirectly(M,S,z.width,z.height,z.transcodedPixels,c,A)}!O._features.basisNeedsPOT||Math.log2(M.width)%1===0&&Math.log2(M.height)%1===0||(z.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),M._cachedWrapU=Q.c.CLAMP_ADDRESSMODE,M._cachedWrapV=Q.c.CLAMP_ADDRESSMODE)}}},d={JSModuleURL:j.JSModuleURL,WasmModuleURL:j.WasmModuleURL,GetInternalFormatFromBasisFormat:(M,A)=>{let O;switch(M){case S.cTFETC1:O=36196;break;case S.cTFBC1:O=33776;break;case S.cTFBC4:O=33779;break;case S.cTFASTC_4x4:O=37808;break;case S.cTFETC2:O=37496;break;case S.cTFBC7:O=36492}if(void 0===O)throw"The chosen Basis transcoder format is not currently supported";return O},TranscodeAsync:J,LoadTextureFromTranscodeResult:G};Object.defineProperty(d,"JSModuleURL",{get:function(){return j.JSModuleURL},set:function(M){j.JSModuleURL=M}}),Object.defineProperty(d,"WasmModuleURL",{get:function(){return j.WasmModuleURL},set:function(M){j.WasmModuleURL=M}});class w{constructor(){this.supportCascades=!1}loadCubeData(M,A,O,S,Q){if(Array.isArray(M))return;const X=A.getEngine().getCaps(),c={supportedCompressionFormats:{etc1:!!X.etc1,s3tc:!!X.s3tc,pvrtc:!!X.pvrtc,etc2:!!X.etc2,astc:!!X.astc,bc7:!!X.bptc}};J(M,c).then((M=>{const O=M.fileInfo.images[0].levels.length>1&&A.generateMipMaps;G(A,M),A.getEngine()._setCubeMapTextureParams(A,O),A.isReady=!0,A.onLoadedObservable.notifyObservers(A),A.onLoadedObservable.clear(),S&&S()})).catch((M=>{z.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),A.isReady=!0,Q&&Q(M)}))}loadData(M,A,O){const S=A.getEngine().getCaps(),Q={supportedCompressionFormats:{etc1:!!S.etc1,s3tc:!!S.s3tc,pvrtc:!!S.pvrtc,etc2:!!S.etc2,astc:!!S.astc,bc7:!!S.bptc}};J(M,Q).then((M=>{const S=M.fileInfo.images[0].levels[0],z=M.fileInfo.images[0].levels.length>1&&A.generateMipMaps;O(S.width,S.height,z,-1!==M.format,(()=>{G(A,M)}))})).catch((M=>{z.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),z.Tools.Warn("Failed to transcode Basis file: ".concat(M)),O(0,0,!1,!1,(()=>{}),!0)}))}}}}]);