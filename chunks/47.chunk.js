"use strict";(self.qcdfysujsyf=self.qcdfysujsyf||[]).push([[47],{15137:(K,A,T)=>{T.r(A),T.d(A,{_BasisTextureLoader:()=>d});var G,B=T(12526),L=T(12674),f=T(12637);function O(){const K=0,A=1,T=2,G=3,B=6,L=8,f=9,O=10,C=14;let Q=null;function Y(K,A,T,G,B){const L=K.getImageTranscodedSizeInBytes(A,T,G);let f=new Uint8Array(L);if(!K.transcodeImage(f,A,T,G,1,0))return null;if(B){f=function(K,A,T,G){const B=new Uint16Array(4),L=new Uint16Array(T*G),f=T/4,O=G/4;for(let C=0;C<O;C++)for(let G=0;G<f;G++){const O=A+8*(C*f+G);B[0]=K[O]|K[O+1]<<8,B[1]=K[O+2]|K[O+3]<<8,B[2]=(2*(31&B[0])+1*(31&B[1]))/3|(2*(2016&B[0])+1*(2016&B[1]))/3&2016|(2*(63488&B[0])+1*(63488&B[1]))/3&63488,B[3]=(2*(31&B[1])+1*(31&B[0]))/3|(2*(2016&B[1])+1*(2016&B[0]))/3&2016|(2*(63488&B[1])+1*(63488&B[0]))/3&63488;for(let A=0;A<4;A++){const f=K[O+4+A];let Q=(4*C+A)*T+4*G;L[Q++]=B[3&f],L[Q++]=B[f>>2&3],L[Q++]=B[f>>4&3],L[Q++]=B[f>>6&3]}}return L}(f,0,K.getImageWidth(A,T)+3&-4,K.getImageHeight(A,T)+3&-4)}return f}onmessage=Z=>{if("init"===Z.data.action){if(Z.data.url)try{importScripts(Z.data.url)}catch(x){postMessage({action:"error",error:x})}Q||(Q=BASIS({wasmBinary:Z.data.wasmBinary})),null!==Q&&Q.then((K=>{BASIS=K,K.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===Z.data.action){const Q=Z.data.config,x=Z.data.imageData,J=new BASIS.BasisFile(x),b=function(K){const A=K.getHasAlpha(),T=K.getNumImages(),G=[];for(let B=0;B<T;B++){const A={levels:[]},T=K.getNumLevels(B);for(let G=0;G<T;G++){const T={width:K.getImageWidth(B,G),height:K.getImageHeight(B,G)};A.levels.push(T)}G.push(A)}return{sf:A,images:G}}(J);let P=Z.data.ignoreSupportedFormats?null:function(Q,Y){let Z=null;Q.supportedCompressionFormats&&(Z=Q.supportedCompressionFormats.astc?O:Q.supportedCompressionFormats.bc7?B:Q.supportedCompressionFormats.s3tc?Y.sf?G:T:Q.supportedCompressionFormats.pvrtc?Y.sf?f:L:Q.supportedCompressionFormats.etc2?A:Q.supportedCompressionFormats.etc1?K:C);return Z}(Z.data.config,b),F=!1;null===P&&(F=!0,P=b.sf?G:T);let d=!0;J.startTranscoding()||(d=!1);const N=[];for(let K=0;K<b.images.length&&d;K++){const A=b.images[K];if(void 0===Q.loadSingleImage||Q.loadSingleImage===K){let T=A.levels.length;!1===Q.loadMipmapLevels&&(T=1);for(let G=0;G<T;G++){const T=A.levels[G],B=Y(J,K,G,P,F);if(!B){d=!1;break}T.transcodedPixels=B,N.push(T.transcodedPixels.buffer)}}}J.close(),J.delete(),F&&(P=-1),d?postMessage({action:"transcode",success:d,id:Z.data.id,fileInfo:b,format:P},N):postMessage({action:"transcode",success:d,id:Z.data.id})}}}!function(K){K[K.cTFETC1=0]="cTFETC1",K[K.cTFETC2=1]="cTFETC2",K[K.cTFBC1=2]="cTFBC1",K[K.cTFBC3=3]="cTFBC3",K[K.cTFBC4=4]="cTFBC4",K[K.cTFBC5=5]="cTFBC5",K[K.cTFBC7=6]="cTFBC7",K[K.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",K[K.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",K[K.cTFASTC_4x4=10]="cTFASTC_4x4",K[K.cTFATC_RGB=11]="cTFATC_RGB",K[K.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",K[K.cTFRGBA32=13]="cTFRGBA32",K[K.cTFRGB565=14]="cTFRGB565",K[K.cTFBGR565=15]="cTFBGR565",K[K.cTFRGBA4444=16]="cTFRGBA4444",K[K.cTFFXT1_RGB=17]="cTFFXT1_RGB",K[K.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",K[K.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",K[K.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",K[K.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(G||(G={}));const C={JSModuleURL:`${B.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${B.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let Q=null,Y=null,Z=0;const x=async()=>(Q||(Q=new Promise(((K,A)=>{Y?K(Y):B.Tools.LoadFileAsync(B.Tools.GetBabylonScriptURL(C.WasmModuleURL)).then((T=>{if("function"!==typeof URL)return A("Basis transcoder requires an environment with a URL constructor");const G=URL.createObjectURL(new Blob([`(${O})()`],{type:"application/javascript"}));Y=new Worker(G),async function(K,A,T){return await new Promise(((G,L)=>{const f=A=>{"init"===A.data.action?(K.removeEventListener("message",f),G(K)):"error"===A.data.action&&L(A.data.error||"error initializing worker")};K.addEventListener("message",f),K.postMessage({action:"init",url:T?B.Tools.GetBabylonScriptURL(T):void 0,wasmBinary:A},[A])}))}(Y,T,C.JSModuleURL).then(K,A)})).catch(A)}))),await Q),J=async(K,A)=>{const T=K instanceof ArrayBuffer?new Uint8Array(K):K;return await new Promise(((K,G)=>{x().then((()=>{const B=Z++,L=A=>{"transcode"===A.data.action&&A.data.id===B&&(Y.removeEventListener("message",L),A.data.success?K(A.data):G("Transcode is not supported on this device"))};Y.addEventListener("message",L);const f=new Uint8Array(T.byteLength);f.set(new Uint8Array(T.buffer,T.byteOffset,T.byteLength)),Y.postMessage({action:"transcode",id:B,imageData:f,config:A,ignoreSupportedFormats:false},[f.buffer])}),(K=>{G(K)}))}))},b=(K,A)=>{var T;let G=null===(T=A._gl)||void 0===T?void 0:T.TEXTURE_2D;var B;K.isCube&&(G=null===(B=A._gl)||void 0===B?void 0:B.TEXTURE_CUBE_MAP);A._bindTextureDirectly(G,K,!0)},P=(K,A)=>{const T=K.getEngine();for(let O=0;O<A.fileInfo.images.length;O++){const C=A.fileInfo.images[O].levels[0];if(K._invertVScale=K.invertY,-1===A.format||A.format===G.cTFRGB565)if(K.type=10,K.format=4,!T._features.basisNeedsPOT||Math.log2(C.width)%1===0&&Math.log2(C.height)%1===0)K._invertVScale=!K.invertY,K.width=C.width+3&-4,K.height=C.height+3&-4,K.samplingMode=2,b(K,T),T._uploadDataToTextureDirectly(K,new Uint16Array(C.transcodedPixels.buffer),O,0,4,!0);else{const A=new f.b(T,2);K._invertVScale=K.invertY,A.type=10,A.format=4,A.width=C.width+3&-4,A.height=C.height+3&-4,b(A,T),T._uploadDataToTextureDirectly(A,new Uint16Array(C.transcodedPixels.buffer),O,0,4,!0),T._rescaleTexture(A,K,T.scenes[0],T._getInternalFormat(4),(()=>{T._releaseTexture(A),b(K,T)}))}else{K.width=C.width,K.height=C.height,K.generateMipMaps=A.fileInfo.images[O].levels.length>1;const G=F.GetInternalFormatFromBasisFormat(A.format,T);K.format=G,b(K,T);const f=A.fileInfo.images[O].levels;for(let A=0;A<f.length;A++){const B=f[A];T._uploadCompressedDataToTextureDirectly(K,G,B.width,B.height,B.transcodedPixels,O,A)}!T._features.basisNeedsPOT||Math.log2(K.width)%1===0&&Math.log2(K.height)%1===0||(B.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),K._cachedWrapU=L.c.CLAMP_ADDRESSMODE,K._cachedWrapV=L.c.CLAMP_ADDRESSMODE)}}},F={JSModuleURL:C.JSModuleURL,WasmModuleURL:C.WasmModuleURL,GetInternalFormatFromBasisFormat:(K,A)=>{let T;switch(K){case G.cTFETC1:T=36196;break;case G.cTFBC1:T=33776;break;case G.cTFBC4:T=33779;break;case G.cTFASTC_4x4:T=37808;break;case G.cTFETC2:T=37496;break;case G.cTFBC7:T=36492}if(void 0===T)throw"The chosen Basis transcoder format is not currently supported";return T},TranscodeAsync:J,LoadTextureFromTranscodeResult:P};Object.defineProperty(F,"JSModuleURL",{get:function(){return C.JSModuleURL},set:function(K){C.JSModuleURL=K}}),Object.defineProperty(F,"WasmModuleURL",{get:function(){return C.WasmModuleURL},set:function(K){C.WasmModuleURL=K}});class d{constructor(){this.supportCascades=!1}loadCubeData(K,A,T,G,L){if(Array.isArray(K))return;const f=A.getEngine().getCaps(),O={supportedCompressionFormats:{etc1:!!f.etc1,s3tc:!!f.s3tc,pvrtc:!!f.pvrtc,etc2:!!f.etc2,astc:!!f.astc,bc7:!!f.bptc}};J(K,O).then((K=>{const T=K.fileInfo.images[0].levels.length>1&&A.generateMipMaps;P(A,K),A.getEngine()._setCubeMapTextureParams(A,T),A.isReady=!0,A.onLoadedObservable.notifyObservers(A),A.onLoadedObservable.clear(),G&&G()})).catch((K=>{B.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),A.isReady=!0,L&&L(K)}))}loadData(K,A,T){const G=A.getEngine().getCaps(),L={supportedCompressionFormats:{etc1:!!G.etc1,s3tc:!!G.s3tc,pvrtc:!!G.pvrtc,etc2:!!G.etc2,astc:!!G.astc,bc7:!!G.bptc}};J(K,L).then((K=>{const G=K.fileInfo.images[0].levels[0],B=K.fileInfo.images[0].levels.length>1&&A.generateMipMaps;T(G.width,G.height,B,-1!==K.format,(()=>{P(A,K)}))})).catch((K=>{B.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),B.Tools.Warn(`Failed to transcode Basis file: ${K}`),T(0,0,!1,!1,(()=>{}),!0)}))}}}}]);