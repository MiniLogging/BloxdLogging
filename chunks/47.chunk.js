"use strict";(self.ipz2em9uj1g=self.ipz2em9uj1g||[]).push([[47],{15065:(r,O,W)=>{W.r(O),W.d(O,{_BasisTextureLoader:()=>e});var q,Q=W(12428),C=W(12575),T=W(12540);function h(){const r=0,O=1,W=2,q=3,Q=6,C=8,T=9,h=10,J=14;let mr=null;function d(r,O,W,q,Q){const C=r.getImageTranscodedSizeInBytes(O,W,q);let T=new Uint8Array(C);if(!r.transcodeImage(T,O,W,q,1,0))return null;if(Q){T=function(r,O,W,q){const Q=new Uint16Array(4),C=new Uint16Array(W*q),T=W/4,h=q/4;for(let J=0;J<h;J++)for(let q=0;q<T;q++){const h=O+8*(J*T+q);Q[0]=r[h]|r[h+1]<<8,Q[1]=r[h+2]|r[h+3]<<8,Q[2]=(2*(31&Q[0])+1*(31&Q[1]))/3|(2*(2016&Q[0])+1*(2016&Q[1]))/3&2016|(2*(63488&Q[0])+1*(63488&Q[1]))/3&63488,Q[3]=(2*(31&Q[1])+1*(31&Q[0]))/3|(2*(2016&Q[1])+1*(2016&Q[0]))/3&2016|(2*(63488&Q[1])+1*(63488&Q[0]))/3&63488;for(let O=0;O<4;O++){const T=r[h+4+O];let mr=(4*J+O)*W+4*q;C[mr++]=Q[3&T],C[mr++]=Q[T>>2&3],C[mr++]=Q[T>>4&3],C[mr++]=Q[T>>6&3]}}return C}(T,0,r.getImageWidth(O,W)+3&-4,r.getImageHeight(O,W)+3&-4)}return T}onmessage=v=>{if("init"===v.data.action){if(v.data.url)try{importScripts(v.data.url)}catch(g){postMessage({action:"error",error:g})}mr||(mr=BASIS({wasmBinary:v.data.wasmBinary})),null!==mr&&mr.then((r=>{BASIS=r,r.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===v.data.action){const mr=v.data.config,g=v.data.imageData,K=new BASIS.BasisFile(g),U=function(r){const O=r.getHasAlpha(),W=r.getNumImages(),q=[];for(let Q=0;Q<W;Q++){const O={levels:[]},W=r.getNumLevels(Q);for(let q=0;q<W;q++){const W={width:r.getImageWidth(Q,q),height:r.getImageHeight(Q,q)};O.levels.push(W)}q.push(O)}return{Gh:O,images:q}}(K);let P=v.data.ignoreSupportedFormats?null:function(mr,d){let v=null;mr.supportedCompressionFormats&&(v=mr.supportedCompressionFormats.astc?h:mr.supportedCompressionFormats.bc7?Q:mr.supportedCompressionFormats.s3tc?d.Gh?q:W:mr.supportedCompressionFormats.pvrtc?d.Gh?T:C:mr.supportedCompressionFormats.etc2?O:mr.supportedCompressionFormats.etc1?r:J);return v}(v.data.config,U),b=!1;null===P&&(b=!0,P=U.Gh?q:W);let e=!0;K.startTranscoding()||(e=!1);const Y=[];for(let r=0;r<U.images.length&&e;r++){const O=U.images[r];if(void 0===mr.loadSingleImage||mr.loadSingleImage===r){let W=O.levels.length;!1===mr.loadMipmapLevels&&(W=1);for(let q=0;q<W;q++){const W=O.levels[q],Q=d(K,r,q,P,b);if(!Q){e=!1;break}W.transcodedPixels=Q,Y.push(W.transcodedPixels.buffer)}}}K.close(),K.delete(),b&&(P=-1),e?postMessage({action:"transcode",success:e,id:v.data.id,fileInfo:U,format:P},Y):postMessage({action:"transcode",success:e,id:v.data.id})}}}!function(r){r[r.cTFETC1=0]="cTFETC1",r[r.cTFETC2=1]="cTFETC2",r[r.cTFBC1=2]="cTFBC1",r[r.cTFBC3=3]="cTFBC3",r[r.cTFBC4=4]="cTFBC4",r[r.cTFBC5=5]="cTFBC5",r[r.cTFBC7=6]="cTFBC7",r[r.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",r[r.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",r[r.cTFASTC_4x4=10]="cTFASTC_4x4",r[r.cTFATC_RGB=11]="cTFATC_RGB",r[r.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",r[r.cTFRGBA32=13]="cTFRGBA32",r[r.cTFRGB565=14]="cTFRGB565",r[r.cTFBGR565=15]="cTFBGR565",r[r.cTFRGBA4444=16]="cTFRGBA4444",r[r.cTFFXT1_RGB=17]="cTFFXT1_RGB",r[r.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",r[r.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",r[r.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",r[r.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(q||(q={}));const J={JSModuleURL:`${Q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${Q.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let mr=null,d=null,v=0;const g=async()=>(mr||(mr=new Promise(((r,O)=>{d?r(d):Q.Tools.LoadFileAsync(Q.Tools.GetBabylonScriptURL(J.WasmModuleURL)).then((W=>{if("function"!==typeof URL)return O("Basis transcoder requires an environment with a URL constructor");const q=URL.createObjectURL(new Blob([`(${h})()`],{type:"application/javascript"}));d=new Worker(q),async function(r,O,W){return await new Promise(((q,C)=>{const T=O=>{"init"===O.data.action?(r.removeEventListener("message",T),q(r)):"error"===O.data.action&&C(O.data.error||"error initializing worker")};r.addEventListener("message",T),r.postMessage({action:"init",url:W?Q.Tools.GetBabylonScriptURL(W):void 0,wasmBinary:O},[O])}))}(d,W,J.JSModuleURL).then(r,O)})).catch(O)}))),await mr),K=async(r,O)=>{const W=r instanceof ArrayBuffer?new Uint8Array(r):r;return await new Promise(((r,q)=>{g().then((()=>{const Q=v++,C=O=>{"transcode"===O.data.action&&O.data.id===Q&&(d.removeEventListener("message",C),O.data.success?r(O.data):q("Transcode is not supported on this device"))};d.addEventListener("message",C);const T=new Uint8Array(W.byteLength);T.set(new Uint8Array(W.buffer,W.byteOffset,W.byteLength)),d.postMessage({action:"transcode",id:Q,imageData:T,config:O,ignoreSupportedFormats:false},[T.buffer])}),(r=>{q(r)}))}))},U=(r,O)=>{var W;let q=null===(W=O._gl)||void 0===W?void 0:W.TEXTURE_2D;var Q;r.isCube&&(q=null===(Q=O._gl)||void 0===Q?void 0:Q.TEXTURE_CUBE_MAP);O._bindTextureDirectly(q,r,!0)},P=(r,O)=>{const W=r.getEngine();for(let h=0;h<O.fileInfo.images.length;h++){const J=O.fileInfo.images[h].levels[0];if(r._invertVScale=r.invertY,-1===O.format||O.format===q.cTFRGB565)if(r.type=10,r.format=4,!W._features.basisNeedsPOT||Math.log2(J.width)%1===0&&Math.log2(J.height)%1===0)r._invertVScale=!r.invertY,r.width=J.width+3&-4,r.height=J.height+3&-4,r.samplingMode=2,U(r,W),W._uploadDataToTextureDirectly(r,new Uint16Array(J.transcodedPixels.buffer),h,0,4,!0);else{const O=new T.e(W,2);r._invertVScale=r.invertY,O.type=10,O.format=4,O.width=J.width+3&-4,O.height=J.height+3&-4,U(O,W),W._uploadDataToTextureDirectly(O,new Uint16Array(J.transcodedPixels.buffer),h,0,4,!0),W._rescaleTexture(O,r,W.scenes[0],W._getInternalFormat(4),(()=>{W._releaseTexture(O),U(r,W)}))}else{r.width=J.width,r.height=J.height,r.generateMipMaps=O.fileInfo.images[h].levels.length>1;const q=b.GetInternalFormatFromBasisFormat(O.format,W);r.format=q,U(r,W);const T=O.fileInfo.images[h].levels;for(let O=0;O<T.length;O++){const Q=T[O];W._uploadCompressedDataToTextureDirectly(r,q,Q.width,Q.height,Q.transcodedPixels,h,O)}!W._features.basisNeedsPOT||Math.log2(r.width)%1===0&&Math.log2(r.height)%1===0||(Q.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),r._cachedWrapU=C.e.CLAMP_ADDRESSMODE,r._cachedWrapV=C.e.CLAMP_ADDRESSMODE)}}},b={JSModuleURL:J.JSModuleURL,WasmModuleURL:J.WasmModuleURL,GetInternalFormatFromBasisFormat:(r,O)=>{let W;switch(r){case q.cTFETC1:W=36196;break;case q.cTFBC1:W=33776;break;case q.cTFBC4:W=33779;break;case q.cTFASTC_4x4:W=37808;break;case q.cTFETC2:W=37496;break;case q.cTFBC7:W=36492}if(void 0===W)throw"The chosen Basis transcoder format is not currently supported";return W},TranscodeAsync:K,LoadTextureFromTranscodeResult:P};Object.defineProperty(b,"JSModuleURL",{get:function(){return J.JSModuleURL},set:function(r){J.JSModuleURL=r}}),Object.defineProperty(b,"WasmModuleURL",{get:function(){return J.WasmModuleURL},set:function(r){J.WasmModuleURL=r}});class e{constructor(){this.supportCascades=!1}loadCubeData(r,O,W,q,C){if(Array.isArray(r))return;const T=O.getEngine().getCaps(),h={supportedCompressionFormats:{etc1:!!T.etc1,s3tc:!!T.s3tc,pvrtc:!!T.pvrtc,etc2:!!T.etc2,astc:!!T.astc,bc7:!!T.bptc}};K(r,h).then((r=>{const W=r.fileInfo.images[0].levels.length>1&&O.generateMipMaps;P(O,r),O.getEngine()._setCubeMapTextureParams(O,W),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),q&&q()})).catch((r=>{Q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),O.isReady=!0,C&&C(r)}))}loadData(r,O,W){const q=O.getEngine().getCaps(),C={supportedCompressionFormats:{etc1:!!q.etc1,s3tc:!!q.s3tc,pvrtc:!!q.pvrtc,etc2:!!q.etc2,astc:!!q.astc,bc7:!!q.bptc}};K(r,C).then((r=>{const q=r.fileInfo.images[0].levels[0],Q=r.fileInfo.images[0].levels.length>1&&O.generateMipMaps;W(q.width,q.height,Q,-1!==r.format,(()=>{P(O,r)}))})).catch((r=>{Q.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Q.Tools.Warn(`Failed to transcode Basis file: ${r}`),W(0,0,!1,!1,(()=>{}),!0)}))}}}}]);