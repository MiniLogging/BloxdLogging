"use strict";(self.pp3k1ov3ibi=self.pp3k1ov3ibi||[]).push([[47],{14843:(M,Z,P)=>{P.r(Z),P.d(Z,{_BasisTextureLoader:()=>L});var x,c=P(12175),w=P(12344),v=P(12291);function G(){const M=0,Z=1,P=2,x=3,c=6,w=8,v=9,G=10,mM=14;let K=null;function d(M,Z,P,x,c){const w=M.getImageTranscodedSizeInBytes(Z,P,x);let v=new Uint8Array(w);if(!M.transcodeImage(v,Z,P,x,1,0))return null;if(c){v=function(M,Z,P,x){const c=new Uint16Array(4),w=new Uint16Array(P*x),v=P/4,G=x/4;for(let mM=0;mM<G;mM++)for(let x=0;x<v;x++){const G=Z+8*(mM*v+x);c[0]=M[G]|M[G+1]<<8,c[1]=M[G+2]|M[G+3]<<8,c[2]=(2*(31&c[0])+1*(31&c[1]))/3|(2*(2016&c[0])+1*(2016&c[1]))/3&2016|(2*(63488&c[0])+1*(63488&c[1]))/3&63488,c[3]=(2*(31&c[1])+1*(31&c[0]))/3|(2*(2016&c[1])+1*(2016&c[0]))/3&2016|(2*(63488&c[1])+1*(63488&c[0]))/3&63488;for(let Z=0;Z<4;Z++){const v=M[G+4+Z];let K=(4*mM+Z)*P+4*x;w[K++]=c[3&v],w[K++]=c[v>>2&3],w[K++]=c[v>>4&3],w[K++]=c[v>>6&3]}}return w}(v,0,M.getImageWidth(Z,P)+3&-4,M.getImageHeight(Z,P)+3&-4)}return v}onmessage=O=>{if("init"===O.data.action){if(O.data.url)try{importScripts(O.data.url)}catch(H){postMessage({action:"error",error:H})}K||(K=BASIS({wasmBinary:O.data.wasmBinary})),null!==K&&K.then((M=>{BASIS=M,M.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===O.data.action){const K=O.data.config,H=O.data.imageData,j=new BASIS.BasisFile(H),B=function(M){const Z=M.getHasAlpha(),P=M.getNumImages(),x=[];for(let c=0;c<P;c++){const Z={levels:[]},P=M.getNumLevels(c);for(let x=0;x<P;x++){const P={width:M.getImageWidth(c,x),height:M.getImageHeight(c,x)};Z.levels.push(P)}x.push(Z)}return{Lc:Z,images:x}}(j);let U=O.data.ignoreSupportedFormats?null:function(K,d){let O=null;K.supportedCompressionFormats&&(O=K.supportedCompressionFormats.astc?G:K.supportedCompressionFormats.bc7?c:K.supportedCompressionFormats.s3tc?d.Lc?x:P:K.supportedCompressionFormats.pvrtc?d.Lc?v:w:K.supportedCompressionFormats.etc2?Z:K.supportedCompressionFormats.etc1?M:mM);return O}(O.data.config,B),n=!1;null===U&&(n=!0,U=B.Lc?x:P);let L=!0;j.startTranscoding()||(L=!1);const u=[];for(let M=0;M<B.images.length&&L;M++){const Z=B.images[M];if(void 0===K.loadSingleImage||K.loadSingleImage===M){let P=Z.levels.length;!1===K.loadMipmapLevels&&(P=1);for(let x=0;x<P;x++){const P=Z.levels[x],c=d(j,M,x,U,n);if(!c){L=!1;break}P.transcodedPixels=c,u.push(P.transcodedPixels.buffer)}}}j.close(),j.delete(),n&&(U=-1),L?postMessage({action:"transcode",success:L,id:O.data.id,fileInfo:B,format:U},u):postMessage({action:"transcode",success:L,id:O.data.id})}}}!function(M){M[M.cTFETC1=0]="cTFETC1",M[M.cTFETC2=1]="cTFETC2",M[M.cTFBC1=2]="cTFBC1",M[M.cTFBC3=3]="cTFBC3",M[M.cTFBC4=4]="cTFBC4",M[M.cTFBC5=5]="cTFBC5",M[M.cTFBC7=6]="cTFBC7",M[M.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",M[M.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",M[M.cTFASTC_4x4=10]="cTFASTC_4x4",M[M.cTFATC_RGB=11]="cTFATC_RGB",M[M.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",M[M.cTFRGBA32=13]="cTFRGBA32",M[M.cTFRGB565=14]="cTFRGB565",M[M.cTFBGR565=15]="cTFBGR565",M[M.cTFRGBA4444=16]="cTFRGBA4444",M[M.cTFFXT1_RGB=17]="cTFFXT1_RGB",M[M.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",M[M.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",M[M.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",M[M.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(x||(x={}));const mM={JSModuleURL:`${c.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${c.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let K=null,d=null,O=0;const H=async()=>(K||(K=new Promise(((M,Z)=>{d?M(d):c.Tools.LoadFileAsync(c.Tools.GetBabylonScriptURL(mM.WasmModuleURL)).then((P=>{if("function"!==typeof URL)return Z("Basis transcoder requires an environment with a URL constructor");const x=URL.createObjectURL(new Blob([`(${G})()`],{type:"application/javascript"}));d=new Worker(x),async function(M,Z,P){return await new Promise(((x,w)=>{const v=Z=>{"init"===Z.data.action?(M.removeEventListener("message",v),x(M)):"error"===Z.data.action&&w(Z.data.error||"error initializing worker")};M.addEventListener("message",v),M.postMessage({action:"init",url:P?c.Tools.GetBabylonScriptURL(P):void 0,wasmBinary:Z},[Z])}))}(d,P,mM.JSModuleURL).then(M,Z)})).catch(Z)}))),await K),j=async(M,Z)=>{const P=M instanceof ArrayBuffer?new Uint8Array(M):M;return await new Promise(((M,x)=>{H().then((()=>{const c=O++,w=Z=>{"transcode"===Z.data.action&&Z.data.id===c&&(d.removeEventListener("message",w),Z.data.success?M(Z.data):x("Transcode is not supported on this device"))};d.addEventListener("message",w);const v=new Uint8Array(P.byteLength);v.set(new Uint8Array(P.buffer,P.byteOffset,P.byteLength)),d.postMessage({action:"transcode",id:c,imageData:v,config:Z,ignoreSupportedFormats:false},[v.buffer])}),(M=>{x(M)}))}))},B=(M,Z)=>{var P;let x=null===(P=Z._gl)||void 0===P?void 0:P.TEXTURE_2D;var c;M.isCube&&(x=null===(c=Z._gl)||void 0===c?void 0:c.TEXTURE_CUBE_MAP);Z._bindTextureDirectly(x,M,!0)},U=(M,Z)=>{const P=M.getEngine();for(let G=0;G<Z.fileInfo.images.length;G++){const mM=Z.fileInfo.images[G].levels[0];if(M._invertVScale=M.invertY,-1===Z.format||Z.format===x.cTFRGB565)if(M.type=10,M.format=4,!P._features.basisNeedsPOT||Math.log2(mM.width)%1===0&&Math.log2(mM.height)%1===0)M._invertVScale=!M.invertY,M.width=mM.width+3&-4,M.height=mM.height+3&-4,M.samplingMode=2,B(M,P),P._uploadDataToTextureDirectly(M,new Uint16Array(mM.transcodedPixels.buffer),G,0,4,!0);else{const Z=new v.d(P,2);M._invertVScale=M.invertY,Z.type=10,Z.format=4,Z.width=mM.width+3&-4,Z.height=mM.height+3&-4,B(Z,P),P._uploadDataToTextureDirectly(Z,new Uint16Array(mM.transcodedPixels.buffer),G,0,4,!0),P._rescaleTexture(Z,M,P.scenes[0],P._getInternalFormat(4),(()=>{P._releaseTexture(Z),B(M,P)}))}else{M.width=mM.width,M.height=mM.height,M.generateMipMaps=Z.fileInfo.images[G].levels.length>1;const x=n.GetInternalFormatFromBasisFormat(Z.format,P);M.format=x,B(M,P);const v=Z.fileInfo.images[G].levels;for(let Z=0;Z<v.length;Z++){const c=v[Z];P._uploadCompressedDataToTextureDirectly(M,x,c.width,c.height,c.transcodedPixels,G,Z)}!P._features.basisNeedsPOT||Math.log2(M.width)%1===0&&Math.log2(M.height)%1===0||(c.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),M._cachedWrapU=w.e.CLAMP_ADDRESSMODE,M._cachedWrapV=w.e.CLAMP_ADDRESSMODE)}}},n={JSModuleURL:mM.JSModuleURL,WasmModuleURL:mM.WasmModuleURL,GetInternalFormatFromBasisFormat:(M,Z)=>{let P;switch(M){case x.cTFETC1:P=36196;break;case x.cTFBC1:P=33776;break;case x.cTFBC4:P=33779;break;case x.cTFASTC_4x4:P=37808;break;case x.cTFETC2:P=37496;break;case x.cTFBC7:P=36492}if(void 0===P)throw"The chosen Basis transcoder format is not currently supported";return P},TranscodeAsync:j,LoadTextureFromTranscodeResult:U};Object.defineProperty(n,"JSModuleURL",{get:function(){return mM.JSModuleURL},set:function(M){mM.JSModuleURL=M}}),Object.defineProperty(n,"WasmModuleURL",{get:function(){return mM.WasmModuleURL},set:function(M){mM.WasmModuleURL=M}});class L{constructor(){this.supportCascades=!1}loadCubeData(M,Z,P,x,w){if(Array.isArray(M))return;const v=Z.getEngine().getCaps(),G={supportedCompressionFormats:{etc1:!!v.etc1,s3tc:!!v.s3tc,pvrtc:!!v.pvrtc,etc2:!!v.etc2,astc:!!v.astc,bc7:!!v.bptc}};j(M,G).then((M=>{const P=M.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;U(Z,M),Z.getEngine()._setCubeMapTextureParams(Z,P),Z.isReady=!0,Z.onLoadedObservable.notifyObservers(Z),Z.onLoadedObservable.clear(),x&&x()})).catch((M=>{c.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),Z.isReady=!0,w&&w(M)}))}loadData(M,Z,P){const x=Z.getEngine().getCaps(),w={supportedCompressionFormats:{etc1:!!x.etc1,s3tc:!!x.s3tc,pvrtc:!!x.pvrtc,etc2:!!x.etc2,astc:!!x.astc,bc7:!!x.bptc}};j(M,w).then((M=>{const x=M.fileInfo.images[0].levels[0],c=M.fileInfo.images[0].levels.length>1&&Z.generateMipMaps;P(x.width,x.height,c,-1!==M.format,(()=>{U(Z,M)}))})).catch((M=>{c.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),c.Tools.Warn(`Failed to transcode Basis file: ${M}`),P(0,0,!1,!1,(()=>{}),!0)}))}}}}]);