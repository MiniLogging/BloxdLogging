"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[47],{13540:(P,e,n)=>{n.r(e),n.d(e,{_BasisTextureLoader:()=>w});var H,S=n(10972),p=n(11119),k=n(11079);function m(){const P=0,e=1,n=2,H=3,S=6,p=8,k=9,m=10,t=14;let C=null;function R(P,e,n,H,S){const p=P.getImageTranscodedSizeInBytes(e,n,H);let k=new Uint8Array(p);if(!P.transcodeImage(k,e,n,H,1,0))return null;if(S){k=function(P,e,n,H){const S=new Uint16Array(4),p=new Uint16Array(n*H),k=n/4,m=H/4;for(let t=0;t<m;t++)for(let H=0;H<k;H++){const m=e+8*(t*k+H);S[0]=P[m]|P[m+1]<<8,S[1]=P[m+2]|P[m+3]<<8,S[2]=(2*(31&S[0])+1*(31&S[1]))/3|(2*(2016&S[0])+1*(2016&S[1]))/3&2016|(2*(63488&S[0])+1*(63488&S[1]))/3&63488,S[3]=(2*(31&S[1])+1*(31&S[0]))/3|(2*(2016&S[1])+1*(2016&S[0]))/3&2016|(2*(63488&S[1])+1*(63488&S[0]))/3&63488;for(let e=0;e<4;e++){const k=P[m+4+e];let C=(4*t+e)*n+4*H;p[C++]=S[3&k],p[C++]=S[k>>2&3],p[C++]=S[k>>4&3],p[C++]=S[k>>6&3]}}return p}(k,0,P.getImageWidth(e,n)+3&-4,P.getImageHeight(e,n)+3&-4)}return k}onmessage=q=>{if("init"===q.data.action){if(q.data.url)try{importScripts(q.data.url)}catch(A){postMessage({action:"error",error:A})}C||(C=BASIS({wasmBinary:q.data.wasmBinary})),null!==C&&C.then((P=>{BASIS=P,P.initializeBasis(),postMessage({action:"init"})}))}else if("transcode"===q.data.action){const C=q.data.config,A=q.data.imageData,F=new BASIS.BasisFile(A),Y=function(P){const e=P.getHasAlpha(),n=P.getNumImages(),H=[];for(let S=0;S<n;S++){const e={levels:[]},n=P.getNumLevels(S);for(let H=0;H<n;H++){const n={width:P.getImageWidth(S,H),height:P.getImageHeight(S,H)};e.levels.push(n)}H.push(e)}return{We:e,images:H}}(F);let j=q.data.ignoreSupportedFormats?null:function(C,R){let q=null;C.supportedCompressionFormats&&(q=C.supportedCompressionFormats.astc?m:C.supportedCompressionFormats.bc7?S:C.supportedCompressionFormats.s3tc?R.We?H:n:C.supportedCompressionFormats.pvrtc?R.We?k:p:C.supportedCompressionFormats.etc2?e:C.supportedCompressionFormats.etc1?P:t);return q}(q.data.config,Y),z=!1;null===j&&(z=!0,j=Y.We?H:n);let w=!0;F.startTranscoding()||(w=!1);const J=[];for(let P=0;P<Y.images.length&&w;P++){const e=Y.images[P];if(void 0===C.loadSingleImage||C.loadSingleImage===P){let n=e.levels.length;!1===C.loadMipmapLevels&&(n=1);for(let H=0;H<n;H++){const n=e.levels[H],S=R(F,P,H,j,z);if(!S){w=!1;break}n.transcodedPixels=S,J.push(n.transcodedPixels.buffer)}}}F.close(),F.delete(),z&&(j=-1),w?postMessage({action:"transcode",success:w,id:q.data.id,fileInfo:Y,format:j},J):postMessage({action:"transcode",success:w,id:q.data.id})}}}!function(P){P[P.cTFETC1=0]="cTFETC1",P[P.cTFETC2=1]="cTFETC2",P[P.cTFBC1=2]="cTFBC1",P[P.cTFBC3=3]="cTFBC3",P[P.cTFBC4=4]="cTFBC4",P[P.cTFBC5=5]="cTFBC5",P[P.cTFBC7=6]="cTFBC7",P[P.cTFPVRTC1_4_RGB=8]="cTFPVRTC1_4_RGB",P[P.cTFPVRTC1_4_RGBA=9]="cTFPVRTC1_4_RGBA",P[P.cTFASTC_4x4=10]="cTFASTC_4x4",P[P.cTFATC_RGB=11]="cTFATC_RGB",P[P.cTFATC_RGBA_INTERPOLATED_ALPHA=12]="cTFATC_RGBA_INTERPOLATED_ALPHA",P[P.cTFRGBA32=13]="cTFRGBA32",P[P.cTFRGB565=14]="cTFRGB565",P[P.cTFBGR565=15]="cTFBGR565",P[P.cTFRGBA4444=16]="cTFRGBA4444",P[P.cTFFXT1_RGB=17]="cTFFXT1_RGB",P[P.cTFPVRTC2_4_RGB=18]="cTFPVRTC2_4_RGB",P[P.cTFPVRTC2_4_RGBA=19]="cTFPVRTC2_4_RGBA",P[P.cTFETC2_EAC_R11=20]="cTFETC2_EAC_R11",P[P.cTFETC2_EAC_RG11=21]="cTFETC2_EAC_RG11"}(H||(H={}));const t={JSModuleURL:`${S.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.js`,WasmModuleURL:`${S.Tools._DefaultCdnUrl}/basisTranscoder/1/basis_transcoder.wasm`};let C=null,R=null,q=0;const A=async()=>(C||(C=new Promise(((P,e)=>{R?P(R):S.Tools.LoadFileAsync(S.Tools.GetBabylonScriptURL(t.WasmModuleURL)).then((n=>{if("function"!==typeof URL)return e("Basis transcoder requires an environment with a URL constructor");const H=URL.createObjectURL(new Blob([`(${m})()`],{type:"application/javascript"}));R=new Worker(H),async function(P,e,n){return await new Promise(((H,p)=>{const k=e=>{"init"===e.data.action?(P.removeEventListener("message",k),H(P)):"error"===e.data.action&&p(e.data.error||"error initializing worker")};P.addEventListener("message",k),P.postMessage({action:"init",url:n?S.Tools.GetBabylonScriptURL(n):void 0,wasmBinary:e},[e])}))}(R,n,t.JSModuleURL).then(P,e)})).catch(e)}))),await C),F=async(P,e)=>{const n=P instanceof ArrayBuffer?new Uint8Array(P):P;return await new Promise(((P,H)=>{A().then((()=>{const S=q++,p=e=>{"transcode"===e.data.action&&e.data.id===S&&(R.removeEventListener("message",p),e.data.success?P(e.data):H("Transcode is not supported on this device"))};R.addEventListener("message",p);const k=new Uint8Array(n.byteLength);k.set(new Uint8Array(n.buffer,n.byteOffset,n.byteLength)),R.postMessage({action:"transcode",id:S,imageData:k,config:e,ignoreSupportedFormats:false},[k.buffer])}),(P=>{H(P)}))}))},Y=(P,e)=>{var n;let H=null===(n=e._gl)||void 0===n?void 0:n.TEXTURE_2D;var S;P.isCube&&(H=null===(S=e._gl)||void 0===S?void 0:S.TEXTURE_CUBE_MAP);e._bindTextureDirectly(H,P,!0)},j=(P,e)=>{const n=P.getEngine();for(let m=0;m<e.fileInfo.images.length;m++){const t=e.fileInfo.images[m].levels[0];if(P._invertVScale=P.invertY,-1===e.format||e.format===H.cTFRGB565)if(P.type=10,P.format=4,!n._features.basisNeedsPOT||Math.log2(t.width)%1===0&&Math.log2(t.height)%1===0)P._invertVScale=!P.invertY,P.width=t.width+3&-4,P.height=t.height+3&-4,P.samplingMode=2,Y(P,n),n._uploadDataToTextureDirectly(P,new Uint16Array(t.transcodedPixels.buffer),m,0,4,!0);else{const e=new k.b(n,2);P._invertVScale=P.invertY,e.type=10,e.format=4,e.width=t.width+3&-4,e.height=t.height+3&-4,Y(e,n),n._uploadDataToTextureDirectly(e,new Uint16Array(t.transcodedPixels.buffer),m,0,4,!0),n._rescaleTexture(e,P,n.scenes[0],n._getInternalFormat(4),(()=>{n._releaseTexture(e),Y(P,n)}))}else{P.width=t.width,P.height=t.height,P.generateMipMaps=e.fileInfo.images[m].levels.length>1;const H=z.GetInternalFormatFromBasisFormat(e.format,n);P.format=H,Y(P,n);const k=e.fileInfo.images[m].levels;for(let e=0;e<k.length;e++){const S=k[e];n._uploadCompressedDataToTextureDirectly(P,H,S.width,S.height,S.transcodedPixels,m,e)}!n._features.basisNeedsPOT||Math.log2(P.width)%1===0&&Math.log2(P.height)%1===0||(S.Tools.Warn("Loaded .basis texture width and height are not a power of two. Texture wrapping will be set to Texture.CLAMP_ADDRESSMODE as other modes are not supported with non power of two dimensions in webGL 1."),P._cachedWrapU=p.e.CLAMP_ADDRESSMODE,P._cachedWrapV=p.e.CLAMP_ADDRESSMODE)}}},z={JSModuleURL:t.JSModuleURL,WasmModuleURL:t.WasmModuleURL,GetInternalFormatFromBasisFormat:(P,e)=>{let n;switch(P){case H.cTFETC1:n=36196;break;case H.cTFBC1:n=33776;break;case H.cTFBC4:n=33779;break;case H.cTFASTC_4x4:n=37808;break;case H.cTFETC2:n=37496;break;case H.cTFBC7:n=36492}if(void 0===n)throw"The chosen Basis transcoder format is not currently supported";return n},TranscodeAsync:F,LoadTextureFromTranscodeResult:j};Object.defineProperty(z,"JSModuleURL",{get:function(){return t.JSModuleURL},set:function(P){t.JSModuleURL=P}}),Object.defineProperty(z,"WasmModuleURL",{get:function(){return t.WasmModuleURL},set:function(P){t.WasmModuleURL=P}});class w{constructor(){this.supportCascades=!1}loadCubeData(P,e,n,H,p){if(Array.isArray(P))return;const k=e.getEngine().getCaps(),m={supportedCompressionFormats:{etc1:!!k.etc1,s3tc:!!k.s3tc,pvrtc:!!k.pvrtc,etc2:!!k.etc2,astc:!!k.astc,bc7:!!k.bptc}};F(P,m).then((P=>{const n=P.fileInfo.images[0].levels.length>1&&e.generateMipMaps;j(e,P),e.getEngine()._setCubeMapTextureParams(e,n),e.isReady=!0,e.onLoadedObservable.notifyObservers(e),e.onLoadedObservable.clear(),H&&H()})).catch((P=>{S.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),e.isReady=!0,p&&p(P)}))}loadData(P,e,n){const H=e.getEngine().getCaps(),p={supportedCompressionFormats:{etc1:!!H.etc1,s3tc:!!H.s3tc,pvrtc:!!H.pvrtc,etc2:!!H.etc2,astc:!!H.astc,bc7:!!H.bptc}};F(P,p).then((P=>{const H=P.fileInfo.images[0].levels[0],S=P.fileInfo.images[0].levels.length>1&&e.generateMipMaps;n(H.width,H.height,S,-1!==P.format,(()=>{j(e,P)}))})).catch((P=>{S.Tools.Warn("Failed to transcode Basis file, transcoding may not be supported on this device"),S.Tools.Warn(`Failed to transcode Basis file: ${P}`),n(0,0,!1,!1,(()=>{}),!0)}))}}}}]);