"use strict";(self.uji65st81d=self.uji65st81d||[]).push([[50],{14839:(V,h,mV)=>{mV.r(h),mV.d(h,{_TGATextureLoader:()=>k});var t=mV(12264);function L(V){let h=0;return{id_length:V[h++],colormap_type:V[h++],image_type:V[h++],colormap_index:V[h++]|V[h++]<<8,colormap_length:V[h++]|V[h++]<<8,colormap_size:V[h++],origin:[V[h++]|V[h++]<<8,V[h++]|V[h++]<<8],width:V[h++]|V[h++]<<8,height:V[h++]|V[h++]<<8,pixel_size:V[h++],flags:V[h++]}}function N(V,h){if(h.length<19)return void t.e.Error("Unable to load TGA file - Not enough data to contain header");let mV=18;const N=L(h);if(N.id_length+mV>h.length)return void t.e.Error("Unable to load TGA file - Not enough data");mV+=N.id_length;let k,C=!1,K=!1,o=!1;switch(N.image_type){case 9:C=!0;case 1:K=!0;break;case 10:C=!0;case 2:break;case 11:C=!0;case 3:o=!0}const n=N.pixel_size>>3,q=N.width*N.height*n;let x,R,d,s,M,c,z;if(K&&(x=h.subarray(mV,mV+=N.colormap_length*(N.colormap_size>>3))),C){let V,t,L;k=new Uint8Array(q);let N=0;const A=new Uint8Array(n);for(;mV<q&&N<q;)if(V=h[mV++],t=1+(127&V),128&V){for(L=0;L<n;++L)A[L]=h[mV++];for(L=0;L<t;++L)k.set(A,N+L*n);N+=n*t}else{for(t*=n,L=0;L<t;++L)k[N+L]=h[mV++];N+=t}}else k=h.subarray(mV,mV+=K?N.width*N.height:q);switch((48&N.flags)>>4){default:case 2:R=0,s=1,z=N.width,d=0,M=1,c=N.height;break;case 0:R=0,s=1,z=N.width,d=N.height-1,M=-1,c=-1;break;case 3:R=N.width-1,s=-1,z=-1,d=0,M=1,c=N.height;break;case 1:R=N.width-1,s=-1,z=-1,d=N.height-1,M=-1,c=-1}const Q="_getImageData"+(o?"Grey":"")+N.pixel_size+"bits",J=A[Q](N,x,k,d,M,c,R,s,z);V.getEngine()._uploadDataToTextureDirectly(V,J)}const A={GetTGAHeader:L,UploadContent:N,_getImageData8bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=h,n=V.width,q=V.height;let x,R,d,s=0;const M=new Uint8Array(n*q*4);for(d=t;d!==N;d+=L)for(R=A;R!==C;R+=k,s++)x=K[s],M[4*(R+n*d)+3]=255,M[4*(R+n*d)+2]=o[3*x+0],M[4*(R+n*d)+1]=o[3*x+1],M[4*(R+n*d)+0]=o[3*x+2];return M},_getImageData16bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=V.width,n=V.height;let q,x,R,d=0;const s=new Uint8Array(o*n*4);for(R=t;R!==N;R+=L)for(x=A;x!==C;x+=k,d+=2){q=K[d+0]+(K[d+1]<<8);const V=255*((31744&q)>>10)/31|0,h=255*((992&q)>>5)/31|0,mV=255*(31&q)/31|0;s[4*(x+o*R)+0]=V,s[4*(x+o*R)+1]=h,s[4*(x+o*R)+2]=mV,s[4*(x+o*R)+3]=32768&q?0:255}return s},_getImageData24bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=V.width,n=V.height;let q,x,R=0;const d=new Uint8Array(o*n*4);for(x=t;x!==N;x+=L)for(q=A;q!==C;q+=k,R+=3)d[4*(q+o*x)+3]=255,d[4*(q+o*x)+2]=K[R+0],d[4*(q+o*x)+1]=K[R+1],d[4*(q+o*x)+0]=K[R+2];return d},_getImageData32bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=V.width,n=V.height;let q,x,R=0;const d=new Uint8Array(o*n*4);for(x=t;x!==N;x+=L)for(q=A;q!==C;q+=k,R+=4)d[4*(q+o*x)+2]=K[R+0],d[4*(q+o*x)+1]=K[R+1],d[4*(q+o*x)+0]=K[R+2],d[4*(q+o*x)+3]=K[R+3];return d},_getImageDataGrey8bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=V.width,n=V.height;let q,x,R,d=0;const s=new Uint8Array(o*n*4);for(R=t;R!==N;R+=L)for(x=A;x!==C;x+=k,d++)q=K[d],s[4*(x+o*R)+0]=q,s[4*(x+o*R)+1]=q,s[4*(x+o*R)+2]=q,s[4*(x+o*R)+3]=255;return s},_getImageDataGrey16bits:function(V,h,mV,t,L,N,A,k,C){const K=mV,o=V.width,n=V.height;let q,x,R=0;const d=new Uint8Array(o*n*4);for(x=t;x!==N;x+=L)for(q=A;q!==C;q+=k,R+=2)d[4*(q+o*x)+0]=K[R+0],d[4*(q+o*x)+1]=K[R+0],d[4*(q+o*x)+2]=K[R+0],d[4*(q+o*x)+3]=K[R+1];return d}};class k{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(V,h,mV){const t=new Uint8Array(V.buffer,V.byteOffset,V.byteLength),A=L(t);mV(A.width,A.height,h.generateMipMaps,!1,(()=>{N(h,t)}))}}}}]);