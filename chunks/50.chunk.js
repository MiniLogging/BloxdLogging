"use strict";(self.wj3aziuz228=self.wj3aziuz228||[]).push([[50],{14934:(u,R,I)=>{I.r(R),I.d(R,{_TGATextureLoader:()=>D});var B=I(12315);function U(u){let R=0;return{id_length:u[R++],colormap_type:u[R++],image_type:u[R++],colormap_index:u[R++]|u[R++]<<8,colormap_length:u[R++]|u[R++]<<8,colormap_size:u[R++],origin:[u[R++]|u[R++]<<8,u[R++]|u[R++]<<8],width:u[R++]|u[R++]<<8,height:u[R++]|u[R++]<<8,pixel_size:u[R++],flags:u[R++]}}function K(u,R){if(R.length<19)return void B.b.Error("Unable to load TGA file - Not enough data to contain header");let I=18;const K=U(R);if(K.id_length+I>R.length)return void B.b.Error("Unable to load TGA file - Not enough data");I+=K.id_length;let D,s=!1,t=!1,G=!1;switch(K.image_type){case 9:s=!0;case 1:t=!0;break;case 10:s=!0;case 2:break;case 11:s=!0;case 3:G=!0}const S=K.pixel_size>>3,b=K.width*K.height*S;let r,P,X,E,z,f,T;if(t&&(r=R.subarray(I,I+=K.colormap_length*(K.colormap_size>>3))),s){let u,B,U;D=new Uint8Array(b);let K=0;const C=new Uint8Array(S);for(;I<b&&K<b;)if(u=R[I++],B=1+(127&u),128&u){for(U=0;U<S;++U)C[U]=R[I++];for(U=0;U<B;++U)D.set(C,K+U*S);K+=S*B}else{for(B*=S,U=0;U<B;++U)D[K+U]=R[I++];K+=B}}else D=R.subarray(I,I+=t?K.width*K.height:b);switch((48&K.flags)>>4){default:case 2:P=0,E=1,T=K.width,X=0,z=1,f=K.height;break;case 0:P=0,E=1,T=K.width,X=K.height-1,z=-1,f=-1;break;case 3:P=K.width-1,E=-1,T=-1,X=0,z=1,f=K.height;break;case 1:P=K.width-1,E=-1,T=-1,X=K.height-1,z=-1,f=-1}const Q="_getImageData"+(G?"Grey":"")+K.pixel_size+"bits",V=C[Q](K,r,D,X,z,f,P,E,T);u.getEngine()._uploadDataToTextureDirectly(u,V)}const C={GetTGAHeader:U,UploadContent:K,_getImageData8bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=R,S=u.width,b=u.height;let r,P,X,E=0;const z=new Uint8Array(S*b*4);for(X=B;X!==K;X+=U)for(P=C;P!==s;P+=D,E++)r=t[E],z[4*(P+S*X)+3]=255,z[4*(P+S*X)+2]=G[3*r+0],z[4*(P+S*X)+1]=G[3*r+1],z[4*(P+S*X)+0]=G[3*r+2];return z},_getImageData16bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=u.width,S=u.height;let b,r,P,X=0;const E=new Uint8Array(G*S*4);for(P=B;P!==K;P+=U)for(r=C;r!==s;r+=D,X+=2){b=t[X+0]+(t[X+1]<<8);const u=255*((31744&b)>>10)/31|0,R=255*((992&b)>>5)/31|0,I=255*(31&b)/31|0;E[4*(r+G*P)+0]=u,E[4*(r+G*P)+1]=R,E[4*(r+G*P)+2]=I,E[4*(r+G*P)+3]=32768&b?0:255}return E},_getImageData24bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=u.width,S=u.height;let b,r,P=0;const X=new Uint8Array(G*S*4);for(r=B;r!==K;r+=U)for(b=C;b!==s;b+=D,P+=3)X[4*(b+G*r)+3]=255,X[4*(b+G*r)+2]=t[P+0],X[4*(b+G*r)+1]=t[P+1],X[4*(b+G*r)+0]=t[P+2];return X},_getImageData32bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=u.width,S=u.height;let b,r,P=0;const X=new Uint8Array(G*S*4);for(r=B;r!==K;r+=U)for(b=C;b!==s;b+=D,P+=4)X[4*(b+G*r)+2]=t[P+0],X[4*(b+G*r)+1]=t[P+1],X[4*(b+G*r)+0]=t[P+2],X[4*(b+G*r)+3]=t[P+3];return X},_getImageDataGrey8bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=u.width,S=u.height;let b,r,P,X=0;const E=new Uint8Array(G*S*4);for(P=B;P!==K;P+=U)for(r=C;r!==s;r+=D,X++)b=t[X],E[4*(r+G*P)+0]=b,E[4*(r+G*P)+1]=b,E[4*(r+G*P)+2]=b,E[4*(r+G*P)+3]=255;return E},_getImageDataGrey16bits:function(u,R,I,B,U,K,C,D,s){const t=I,G=u.width,S=u.height;let b,r,P=0;const X=new Uint8Array(G*S*4);for(r=B;r!==K;r+=U)for(b=C;b!==s;b+=D,P+=2)X[4*(b+G*r)+0]=t[P+0],X[4*(b+G*r)+1]=t[P+0],X[4*(b+G*r)+2]=t[P+0],X[4*(b+G*r)+3]=t[P+1];return X}};class D{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(u,R,I){const B=new Uint8Array(u.buffer,u.byteOffset,u.byteLength),C=U(B);I(C.width,C.height,R.generateMipMaps,!1,(()=>{K(R,B)}))}}}}]);