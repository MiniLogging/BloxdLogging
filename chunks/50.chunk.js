"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[50],{15097:(L,U,x)=>{x.r(U),x.d(U,{_TGATextureLoader:()=>a});var mL=x(12406);function p(L){let U=0;return{id_length:L[U++],colormap_type:L[U++],image_type:L[U++],colormap_index:L[U++]|L[U++]<<8,colormap_length:L[U++]|L[U++]<<8,colormap_size:L[U++],origin:[L[U++]|L[U++]<<8,L[U++]|L[U++]<<8],width:L[U++]|L[U++]<<8,height:L[U++]|L[U++]<<8,pixel_size:L[U++],flags:L[U++]}}function G(L,U){if(U.length<19)return void mL.c.Error("Unable to load TGA file - Not enough data to contain header");let x=18;const G=p(U);if(G.id_length+x>U.length)return void mL.c.Error("Unable to load TGA file - Not enough data");x+=G.id_length;let a,o=!1,A=!1,r=!1;switch(G.image_type){case 9:o=!0;case 1:A=!0;break;case 10:o=!0;case 2:break;case 11:o=!0;case 3:r=!0}const h=G.pixel_size>>3,b=G.width*G.height*h;let E,Y,S,V,H,Q,q;if(A&&(E=U.subarray(x,x+=G.colormap_length*(G.colormap_size>>3))),o){let L,mL,p;a=new Uint8Array(b);let G=0;const F=new Uint8Array(h);for(;x<b&&G<b;)if(L=U[x++],mL=1+(127&L),128&L){for(p=0;p<h;++p)F[p]=U[x++];for(p=0;p<mL;++p)a.set(F,G+p*h);G+=h*mL}else{for(mL*=h,p=0;p<mL;++p)a[G+p]=U[x++];G+=mL}}else a=U.subarray(x,x+=A?G.width*G.height:b);switch((48&G.flags)>>4){default:case 2:Y=0,V=1,q=G.width,S=0,H=1,Q=G.height;break;case 0:Y=0,V=1,q=G.width,S=G.height-1,H=-1,Q=-1;break;case 3:Y=G.width-1,V=-1,q=-1,S=0,H=1,Q=G.height;break;case 1:Y=G.width-1,V=-1,q=-1,S=G.height-1,H=-1,Q=-1}const f="_getImageData"+(r?"Grey":"")+G.pixel_size+"bits",v=F[f](G,E,a,S,H,Q,Y,V,q);L.getEngine()._uploadDataToTextureDirectly(L,v)}const F={GetTGAHeader:p,UploadContent:G,_getImageData8bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=U,h=L.width,b=L.height;let E,Y,S,V=0;const H=new Uint8Array(h*b*4);for(S=mL;S!==G;S+=p)for(Y=F;Y!==o;Y+=a,V++)E=A[V],H[4*(Y+h*S)+3]=255,H[4*(Y+h*S)+2]=r[3*E+0],H[4*(Y+h*S)+1]=r[3*E+1],H[4*(Y+h*S)+0]=r[3*E+2];return H},_getImageData16bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=L.width,h=L.height;let b,E,Y,S=0;const V=new Uint8Array(r*h*4);for(Y=mL;Y!==G;Y+=p)for(E=F;E!==o;E+=a,S+=2){b=A[S+0]+(A[S+1]<<8);const L=255*((31744&b)>>10)/31|0,U=255*((992&b)>>5)/31|0,x=255*(31&b)/31|0;V[4*(E+r*Y)+0]=L,V[4*(E+r*Y)+1]=U,V[4*(E+r*Y)+2]=x,V[4*(E+r*Y)+3]=32768&b?0:255}return V},_getImageData24bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=L.width,h=L.height;let b,E,Y=0;const S=new Uint8Array(r*h*4);for(E=mL;E!==G;E+=p)for(b=F;b!==o;b+=a,Y+=3)S[4*(b+r*E)+3]=255,S[4*(b+r*E)+2]=A[Y+0],S[4*(b+r*E)+1]=A[Y+1],S[4*(b+r*E)+0]=A[Y+2];return S},_getImageData32bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=L.width,h=L.height;let b,E,Y=0;const S=new Uint8Array(r*h*4);for(E=mL;E!==G;E+=p)for(b=F;b!==o;b+=a,Y+=4)S[4*(b+r*E)+2]=A[Y+0],S[4*(b+r*E)+1]=A[Y+1],S[4*(b+r*E)+0]=A[Y+2],S[4*(b+r*E)+3]=A[Y+3];return S},_getImageDataGrey8bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=L.width,h=L.height;let b,E,Y,S=0;const V=new Uint8Array(r*h*4);for(Y=mL;Y!==G;Y+=p)for(E=F;E!==o;E+=a,S++)b=A[S],V[4*(E+r*Y)+0]=b,V[4*(E+r*Y)+1]=b,V[4*(E+r*Y)+2]=b,V[4*(E+r*Y)+3]=255;return V},_getImageDataGrey16bits:function(L,U,x,mL,p,G,F,a,o){const A=x,r=L.width,h=L.height;let b,E,Y=0;const S=new Uint8Array(r*h*4);for(E=mL;E!==G;E+=p)for(b=F;b!==o;b+=a,Y+=2)S[4*(b+r*E)+0]=A[Y+0],S[4*(b+r*E)+1]=A[Y+0],S[4*(b+r*E)+2]=A[Y+0],S[4*(b+r*E)+3]=A[Y+1];return S}};class a{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(L,U,x){const mL=new Uint8Array(L.buffer,L.byteOffset,L.byteLength),F=p(mL);x(F.width,F.height,U.generateMipMaps,!1,(()=>{G(U,mL)}))}}}}]);