"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[50],{15431:(Y,c,h)=>{h.r(c),h.d(c,{_TGATextureLoader:()=>b});var C=h(12700);function E(Y){let c=0;return{id_length:Y[c++],colormap_type:Y[c++],image_type:Y[c++],colormap_index:Y[c++]|Y[c++]<<8,colormap_length:Y[c++]|Y[c++]<<8,colormap_size:Y[c++],origin:[Y[c++]|Y[c++]<<8,Y[c++]|Y[c++]<<8],width:Y[c++]|Y[c++]<<8,height:Y[c++]|Y[c++]<<8,pixel_size:Y[c++],flags:Y[c++]}}function N(Y,c){if(c.length<19)return void C.e.Error("Unable to load TGA file - Not enough data to contain header");let h=18;const N=E(c);if(N.id_length+h>c.length)return void C.e.Error("Unable to load TGA file - Not enough data");h+=N.id_length;let b,H=!1,w=!1,W=!1;switch(N.image_type){case 9:H=!0;case 1:w=!0;break;case 10:H=!0;case 2:break;case 11:H=!0;case 3:W=!0}const q=N.pixel_size>>3,k=N.width*N.height*q;let M,p,P,y,d,D,T;if(w&&(M=c.subarray(h,h+=N.colormap_length*(N.colormap_size>>3))),H){let Y,C,E;b=new Uint8Array(k);let N=0;const Q=new Uint8Array(q);for(;h<k&&N<k;)if(Y=c[h++],C=1+(127&Y),128&Y){for(E=0;E<q;++E)Q[E]=c[h++];for(E=0;E<C;++E)b.set(Q,N+E*q);N+=q*C}else{for(C*=q,E=0;E<C;++E)b[N+E]=c[h++];N+=C}}else b=c.subarray(h,h+=w?N.width*N.height:k);switch((48&N.flags)>>4){default:case 2:p=0,y=1,T=N.width,P=0,d=1,D=N.height;break;case 0:p=0,y=1,T=N.width,P=N.height-1,d=-1,D=-1;break;case 3:p=N.width-1,y=-1,T=-1,P=0,d=1,D=N.height;break;case 1:p=N.width-1,y=-1,T=-1,P=N.height-1,d=-1,D=-1}const e="_getImageData"+(W?"Grey":"")+N.pixel_size+"bits",r=Q[e](N,M,b,P,d,D,p,y,T);Y.getEngine()._uploadDataToTextureDirectly(Y,r)}const Q={GetTGAHeader:E,UploadContent:N,_getImageData8bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=c,q=Y.width,k=Y.height;let M,p,P,y=0;const d=new Uint8Array(q*k*4);for(P=C;P!==N;P+=E)for(p=Q;p!==H;p+=b,y++)M=w[y],d[4*(p+q*P)+3]=255,d[4*(p+q*P)+2]=W[3*M+0],d[4*(p+q*P)+1]=W[3*M+1],d[4*(p+q*P)+0]=W[3*M+2];return d},_getImageData16bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=Y.width,q=Y.height;let k,M,p,P=0;const y=new Uint8Array(W*q*4);for(p=C;p!==N;p+=E)for(M=Q;M!==H;M+=b,P+=2){k=w[P+0]+(w[P+1]<<8);const Y=255*((31744&k)>>10)/31|0,c=255*((992&k)>>5)/31|0,h=255*(31&k)/31|0;y[4*(M+W*p)+0]=Y,y[4*(M+W*p)+1]=c,y[4*(M+W*p)+2]=h,y[4*(M+W*p)+3]=32768&k?0:255}return y},_getImageData24bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=Y.width,q=Y.height;let k,M,p=0;const P=new Uint8Array(W*q*4);for(M=C;M!==N;M+=E)for(k=Q;k!==H;k+=b,p+=3)P[4*(k+W*M)+3]=255,P[4*(k+W*M)+2]=w[p+0],P[4*(k+W*M)+1]=w[p+1],P[4*(k+W*M)+0]=w[p+2];return P},_getImageData32bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=Y.width,q=Y.height;let k,M,p=0;const P=new Uint8Array(W*q*4);for(M=C;M!==N;M+=E)for(k=Q;k!==H;k+=b,p+=4)P[4*(k+W*M)+2]=w[p+0],P[4*(k+W*M)+1]=w[p+1],P[4*(k+W*M)+0]=w[p+2],P[4*(k+W*M)+3]=w[p+3];return P},_getImageDataGrey8bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=Y.width,q=Y.height;let k,M,p,P=0;const y=new Uint8Array(W*q*4);for(p=C;p!==N;p+=E)for(M=Q;M!==H;M+=b,P++)k=w[P],y[4*(M+W*p)+0]=k,y[4*(M+W*p)+1]=k,y[4*(M+W*p)+2]=k,y[4*(M+W*p)+3]=255;return y},_getImageDataGrey16bits:function(Y,c,h,C,E,N,Q,b,H){const w=h,W=Y.width,q=Y.height;let k,M,p=0;const P=new Uint8Array(W*q*4);for(M=C;M!==N;M+=E)for(k=Q;k!==H;k+=b,p+=2)P[4*(k+W*M)+0]=w[p+0],P[4*(k+W*M)+1]=w[p+0],P[4*(k+W*M)+2]=w[p+0],P[4*(k+W*M)+3]=w[p+1];return P}};class b{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Y,c,h){const C=new Uint8Array(Y.buffer,Y.byteOffset,Y.byteLength),Q=E(C);h(Q.width,Q.height,c.generateMipMaps,!1,(()=>{N(c,C)}))}}}}]);