"use strict";(self.hbnkweqmycf=self.hbnkweqmycf||[]).push([[50],{14065:(F,P,f)=>{f.r(P),f.d(P,{_TGATextureLoader:()=>A});var c=f(11474);function N(F){let P=0;return{id_length:F[P++],colormap_type:F[P++],image_type:F[P++],colormap_index:F[P++]|F[P++]<<8,colormap_length:F[P++]|F[P++]<<8,colormap_size:F[P++],origin:[F[P++]|F[P++]<<8,F[P++]|F[P++]<<8],width:F[P++]|F[P++]<<8,height:F[P++]|F[P++]<<8,pixel_size:F[P++],flags:F[P++]}}function q(F,P){if(P.length<19)return void c.d.Error("Unable to load TGA file - Not enough data to contain header");let f=18;const q=N(P);if(q.id_length+f>P.length)return void c.d.Error("Unable to load TGA file - Not enough data");f+=q.id_length;let A,o=!1,j=!1,i=!1;switch(q.image_type){case 9:o=!0;case 1:j=!0;break;case 10:o=!0;case 2:break;case 11:o=!0;case 3:i=!0}const u=q.pixel_size>>3,T=q.width*q.height*u;let Y,t,C,L,J,B,z;if(j&&(Y=P.subarray(f,f+=q.colormap_length*(q.colormap_size>>3))),o){let F,c,N;A=new Uint8Array(T);let q=0;const H=new Uint8Array(u);for(;f<T&&q<T;)if(F=P[f++],c=1+(127&F),128&F){for(N=0;N<u;++N)H[N]=P[f++];for(N=0;N<c;++N)A.set(H,q+N*u);q+=u*c}else{for(c*=u,N=0;N<c;++N)A[q+N]=P[f++];q+=c}}else A=P.subarray(f,f+=j?q.width*q.height:T);switch((48&q.flags)>>4){default:case 2:t=0,L=1,z=q.width,C=0,J=1,B=q.height;break;case 0:t=0,L=1,z=q.width,C=q.height-1,J=-1,B=-1;break;case 3:t=q.width-1,L=-1,z=-1,C=0,J=1,B=q.height;break;case 1:t=q.width-1,L=-1,z=-1,C=q.height-1,J=-1,B=-1}const Z="_getImageData"+(i?"Grey":"")+q.pixel_size+"bits",R=H[Z](q,Y,A,C,J,B,t,L,z);F.getEngine()._uploadDataToTextureDirectly(F,R)}const H={GetTGAHeader:N,UploadContent:q,_getImageData8bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=P,u=F.width,T=F.height;let Y,t,C,L=0;const J=new Uint8Array(u*T*4);for(C=c;C!==q;C+=N)for(t=H;t!==o;t+=A,L++)Y=j[L],J[4*(t+u*C)+3]=255,J[4*(t+u*C)+2]=i[3*Y+0],J[4*(t+u*C)+1]=i[3*Y+1],J[4*(t+u*C)+0]=i[3*Y+2];return J},_getImageData16bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=F.width,u=F.height;let T,Y,t,C=0;const L=new Uint8Array(i*u*4);for(t=c;t!==q;t+=N)for(Y=H;Y!==o;Y+=A,C+=2){T=j[C+0]+(j[C+1]<<8);const F=255*((31744&T)>>10)/31|0,P=255*((992&T)>>5)/31|0,f=255*(31&T)/31|0;L[4*(Y+i*t)+0]=F,L[4*(Y+i*t)+1]=P,L[4*(Y+i*t)+2]=f,L[4*(Y+i*t)+3]=32768&T?0:255}return L},_getImageData24bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=F.width,u=F.height;let T,Y,t=0;const C=new Uint8Array(i*u*4);for(Y=c;Y!==q;Y+=N)for(T=H;T!==o;T+=A,t+=3)C[4*(T+i*Y)+3]=255,C[4*(T+i*Y)+2]=j[t+0],C[4*(T+i*Y)+1]=j[t+1],C[4*(T+i*Y)+0]=j[t+2];return C},_getImageData32bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=F.width,u=F.height;let T,Y,t=0;const C=new Uint8Array(i*u*4);for(Y=c;Y!==q;Y+=N)for(T=H;T!==o;T+=A,t+=4)C[4*(T+i*Y)+2]=j[t+0],C[4*(T+i*Y)+1]=j[t+1],C[4*(T+i*Y)+0]=j[t+2],C[4*(T+i*Y)+3]=j[t+3];return C},_getImageDataGrey8bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=F.width,u=F.height;let T,Y,t,C=0;const L=new Uint8Array(i*u*4);for(t=c;t!==q;t+=N)for(Y=H;Y!==o;Y+=A,C++)T=j[C],L[4*(Y+i*t)+0]=T,L[4*(Y+i*t)+1]=T,L[4*(Y+i*t)+2]=T,L[4*(Y+i*t)+3]=255;return L},_getImageDataGrey16bits:function(F,P,f,c,N,q,H,A,o){const j=f,i=F.width,u=F.height;let T,Y,t=0;const C=new Uint8Array(i*u*4);for(Y=c;Y!==q;Y+=N)for(T=H;T!==o;T+=A,t+=2)C[4*(T+i*Y)+0]=j[t+0],C[4*(T+i*Y)+1]=j[t+0],C[4*(T+i*Y)+2]=j[t+0],C[4*(T+i*Y)+3]=j[t+1];return C}};class A{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(F,P,f){const c=new Uint8Array(F.buffer,F.byteOffset,F.byteLength),H=N(c);f(H.width,H.height,P.generateMipMaps,!1,(()=>{q(P,c)}))}}}}]);