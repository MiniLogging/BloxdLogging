"use strict";(self.z22hkk7o33f=self.z22hkk7o33f||[]).push([[50],{14929:(U,G,C)=>{C.r(G),C.d(G,{_TGATextureLoader:()=>E});var L=C(12731);function X(U){let G=0;return{id_length:U[G++],colormap_type:U[G++],image_type:U[G++],colormap_index:U[G++]|U[G++]<<8,colormap_length:U[G++]|U[G++]<<8,colormap_size:U[G++],origin:[U[G++]|U[G++]<<8,U[G++]|U[G++]<<8],width:U[G++]|U[G++]<<8,height:U[G++]|U[G++]<<8,pixel_size:U[G++],flags:U[G++]}}function l(U,G){if(G.length<19)return void L.d.Error("Unable to load TGA file - Not enough data to contain header");let C=18;const l=X(G);if(l.id_length+C>G.length)return void L.d.Error("Unable to load TGA file - Not enough data");C+=l.id_length;let E,K=!1,P=!1,O=!1;switch(l.image_type){case 9:K=!0;case 1:P=!0;break;case 10:K=!0;case 2:break;case 11:K=!0;case 3:O=!0}const T=l.pixel_size>>3,D=l.width*l.height*T;let y,V,p,I,H,x,h;if(P&&(y=G.subarray(C,C+=l.colormap_length*(l.colormap_size>>3))),K){let U,L,X;E=new Uint8Array(D);let l=0;const t=new Uint8Array(T);for(;C<D&&l<D;)if(U=G[C++],L=1+(127&U),128&U){for(X=0;X<T;++X)t[X]=G[C++];for(X=0;X<L;++X)E.set(t,l+X*T);l+=T*L}else{for(L*=T,X=0;X<L;++X)E[l+X]=G[C++];l+=L}}else E=G.subarray(C,C+=P?l.width*l.height:D);switch((48&l.flags)>>4){default:case 2:V=0,I=1,h=l.width,p=0,H=1,x=l.height;break;case 0:V=0,I=1,h=l.width,p=l.height-1,H=-1,x=-1;break;case 3:V=l.width-1,I=-1,h=-1,p=0,H=1,x=l.height;break;case 1:V=l.width-1,I=-1,h=-1,p=l.height-1,H=-1,x=-1}const N="_getImageData"+(O?"Grey":"")+l.pixel_size+"bits",b=t[N](l,y,E,p,H,x,V,I,h);U.getEngine()._uploadDataToTextureDirectly(U,b)}const t={GetTGAHeader:X,UploadContent:l,_getImageData8bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=G,T=U.width,D=U.height;let y,V,p,I=0;const H=new Uint8Array(T*D*4);for(p=L;p!==l;p+=X)for(V=t;V!==K;V+=E,I++)y=P[I],H[4*(V+T*p)+3]=255,H[4*(V+T*p)+2]=O[3*y+0],H[4*(V+T*p)+1]=O[3*y+1],H[4*(V+T*p)+0]=O[3*y+2];return H},_getImageData16bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=U.width,T=U.height;let D,y,V,p=0;const I=new Uint8Array(O*T*4);for(V=L;V!==l;V+=X)for(y=t;y!==K;y+=E,p+=2){D=P[p+0]+(P[p+1]<<8);const U=255*((31744&D)>>10)/31|0,G=255*((992&D)>>5)/31|0,C=255*(31&D)/31|0;I[4*(y+O*V)+0]=U,I[4*(y+O*V)+1]=G,I[4*(y+O*V)+2]=C,I[4*(y+O*V)+3]=32768&D?0:255}return I},_getImageData24bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=U.width,T=U.height;let D,y,V=0;const p=new Uint8Array(O*T*4);for(y=L;y!==l;y+=X)for(D=t;D!==K;D+=E,V+=3)p[4*(D+O*y)+3]=255,p[4*(D+O*y)+2]=P[V+0],p[4*(D+O*y)+1]=P[V+1],p[4*(D+O*y)+0]=P[V+2];return p},_getImageData32bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=U.width,T=U.height;let D,y,V=0;const p=new Uint8Array(O*T*4);for(y=L;y!==l;y+=X)for(D=t;D!==K;D+=E,V+=4)p[4*(D+O*y)+2]=P[V+0],p[4*(D+O*y)+1]=P[V+1],p[4*(D+O*y)+0]=P[V+2],p[4*(D+O*y)+3]=P[V+3];return p},_getImageDataGrey8bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=U.width,T=U.height;let D,y,V,p=0;const I=new Uint8Array(O*T*4);for(V=L;V!==l;V+=X)for(y=t;y!==K;y+=E,p++)D=P[p],I[4*(y+O*V)+0]=D,I[4*(y+O*V)+1]=D,I[4*(y+O*V)+2]=D,I[4*(y+O*V)+3]=255;return I},_getImageDataGrey16bits:function(U,G,C,L,X,l,t,E,K){const P=C,O=U.width,T=U.height;let D,y,V=0;const p=new Uint8Array(O*T*4);for(y=L;y!==l;y+=X)for(D=t;D!==K;D+=E,V+=2)p[4*(D+O*y)+0]=P[V+0],p[4*(D+O*y)+1]=P[V+0],p[4*(D+O*y)+2]=P[V+0],p[4*(D+O*y)+3]=P[V+1];return p}};class E{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(U,G,C){const L=new Uint8Array(U.buffer,U.byteOffset,U.byteLength),t=X(L);C(t.width,t.height,G.generateMipMaps,!1,(()=>{l(G,L)}))}}}}]);