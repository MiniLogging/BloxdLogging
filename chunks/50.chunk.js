"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[50],{14646:(I,O,C)=>{C.r(O),C.d(O,{_TGATextureLoader:()=>S});var j=C(12103);function K(I){let O=0;return{id_length:I[O++],colormap_type:I[O++],image_type:I[O++],colormap_index:I[O++]|I[O++]<<8,colormap_length:I[O++]|I[O++]<<8,colormap_size:I[O++],origin:[I[O++]|I[O++]<<8,I[O++]|I[O++]<<8],width:I[O++]|I[O++]<<8,height:I[O++]|I[O++]<<8,pixel_size:I[O++],flags:I[O++]}}function i(I,O){if(O.length<19)return void j.c.Error("Unable to load TGA file - Not enough data to contain header");let C=18;const i=K(O);if(i.id_length+C>O.length)return void j.c.Error("Unable to load TGA file - Not enough data");C+=i.id_length;let S,U=!1,p=!1,N=!1;switch(i.image_type){case 9:U=!0;case 1:p=!0;break;case 10:U=!0;case 2:break;case 11:U=!0;case 3:N=!0}const Q=i.pixel_size>>3,s=i.width*i.height*Q;let Z,q,mI,E,h,r,W;if(p&&(Z=O.subarray(C,C+=i.colormap_length*(i.colormap_size>>3))),U){let I,j,K;S=new Uint8Array(s);let i=0;const y=new Uint8Array(Q);for(;C<s&&i<s;)if(I=O[C++],j=1+(127&I),128&I){for(K=0;K<Q;++K)y[K]=O[C++];for(K=0;K<j;++K)S.set(y,i+K*Q);i+=Q*j}else{for(j*=Q,K=0;K<j;++K)S[i+K]=O[C++];i+=j}}else S=O.subarray(C,C+=p?i.width*i.height:s);switch((48&i.flags)>>4){default:case 2:q=0,E=1,W=i.width,mI=0,h=1,r=i.height;break;case 0:q=0,E=1,W=i.width,mI=i.height-1,h=-1,r=-1;break;case 3:q=i.width-1,E=-1,W=-1,mI=0,h=1,r=i.height;break;case 1:q=i.width-1,E=-1,W=-1,mI=i.height-1,h=-1,r=-1}const Y="_getImageData"+(N?"Grey":"")+i.pixel_size+"bits",o=y[Y](i,Z,S,mI,h,r,q,E,W);I.getEngine()._uploadDataToTextureDirectly(I,o)}const y={GetTGAHeader:K,UploadContent:i,_getImageData8bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=O,Q=I.width,s=I.height;let Z,q,mI,E=0;const h=new Uint8Array(Q*s*4);for(mI=j;mI!==i;mI+=K)for(q=y;q!==U;q+=S,E++)Z=p[E],h[4*(q+Q*mI)+3]=255,h[4*(q+Q*mI)+2]=N[3*Z+0],h[4*(q+Q*mI)+1]=N[3*Z+1],h[4*(q+Q*mI)+0]=N[3*Z+2];return h},_getImageData16bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=I.width,Q=I.height;let s,Z,q,mI=0;const E=new Uint8Array(N*Q*4);for(q=j;q!==i;q+=K)for(Z=y;Z!==U;Z+=S,mI+=2){s=p[mI+0]+(p[mI+1]<<8);const I=255*((31744&s)>>10)/31|0,O=255*((992&s)>>5)/31|0,C=255*(31&s)/31|0;E[4*(Z+N*q)+0]=I,E[4*(Z+N*q)+1]=O,E[4*(Z+N*q)+2]=C,E[4*(Z+N*q)+3]=32768&s?0:255}return E},_getImageData24bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=I.width,Q=I.height;let s,Z,q=0;const mI=new Uint8Array(N*Q*4);for(Z=j;Z!==i;Z+=K)for(s=y;s!==U;s+=S,q+=3)mI[4*(s+N*Z)+3]=255,mI[4*(s+N*Z)+2]=p[q+0],mI[4*(s+N*Z)+1]=p[q+1],mI[4*(s+N*Z)+0]=p[q+2];return mI},_getImageData32bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=I.width,Q=I.height;let s,Z,q=0;const mI=new Uint8Array(N*Q*4);for(Z=j;Z!==i;Z+=K)for(s=y;s!==U;s+=S,q+=4)mI[4*(s+N*Z)+2]=p[q+0],mI[4*(s+N*Z)+1]=p[q+1],mI[4*(s+N*Z)+0]=p[q+2],mI[4*(s+N*Z)+3]=p[q+3];return mI},_getImageDataGrey8bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=I.width,Q=I.height;let s,Z,q,mI=0;const E=new Uint8Array(N*Q*4);for(q=j;q!==i;q+=K)for(Z=y;Z!==U;Z+=S,mI++)s=p[mI],E[4*(Z+N*q)+0]=s,E[4*(Z+N*q)+1]=s,E[4*(Z+N*q)+2]=s,E[4*(Z+N*q)+3]=255;return E},_getImageDataGrey16bits:function(I,O,C,j,K,i,y,S,U){const p=C,N=I.width,Q=I.height;let s,Z,q=0;const mI=new Uint8Array(N*Q*4);for(Z=j;Z!==i;Z+=K)for(s=y;s!==U;s+=S,q+=2)mI[4*(s+N*Z)+0]=p[q+0],mI[4*(s+N*Z)+1]=p[q+0],mI[4*(s+N*Z)+2]=p[q+0],mI[4*(s+N*Z)+3]=p[q+1];return mI}};class S{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(I,O,C){const j=new Uint8Array(I.buffer,I.byteOffset,I.byteLength),y=K(j);C(y.width,y.height,O.generateMipMaps,!1,(()=>{i(O,j)}))}}}}]);