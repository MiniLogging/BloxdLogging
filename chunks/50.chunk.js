"use strict";(self.bbj0x35f849=self.bbj0x35f849||[]).push([[50],{13564:(N,q,C)=>{C.r(q),C.d(q,{_TGATextureLoader:()=>F});var d=C(10962);function U(N){let q=0;return{id_length:N[q++],colormap_type:N[q++],image_type:N[q++],colormap_index:N[q++]|N[q++]<<8,colormap_length:N[q++]|N[q++]<<8,colormap_size:N[q++],origin:[N[q++]|N[q++]<<8,N[q++]|N[q++]<<8],width:N[q++]|N[q++]<<8,height:N[q++]|N[q++]<<8,pixel_size:N[q++],flags:N[q++]}}function W(N,q){if(q.length<19)return void d.c.Error("Unable to load TGA file - Not enough data to contain header");let C=18;const W=U(q);if(W.id_length+C>q.length)return void d.c.Error("Unable to load TGA file - Not enough data");C+=W.id_length;let F,w=!1,A=!1,n=!1;switch(W.image_type){case 9:w=!0;case 1:A=!0;break;case 10:w=!0;case 2:break;case 11:w=!0;case 3:n=!0}const t=W.pixel_size>>3,V=W.width*W.height*t;let Z,J,Q,v,r,O,K;if(A&&(Z=q.subarray(C,C+=W.colormap_length*(W.colormap_size>>3))),w){let N,d,U;F=new Uint8Array(V);let W=0;const a=new Uint8Array(t);for(;C<V&&W<V;)if(N=q[C++],d=1+(127&N),128&N){for(U=0;U<t;++U)a[U]=q[C++];for(U=0;U<d;++U)F.set(a,W+U*t);W+=t*d}else{for(d*=t,U=0;U<d;++U)F[W+U]=q[C++];W+=d}}else F=q.subarray(C,C+=A?W.width*W.height:V);switch((48&W.flags)>>4){default:case 2:J=0,v=1,K=W.width,Q=0,r=1,O=W.height;break;case 0:J=0,v=1,K=W.width,Q=W.height-1,r=-1,O=-1;break;case 3:J=W.width-1,v=-1,K=-1,Q=0,r=1,O=W.height;break;case 1:J=W.width-1,v=-1,K=-1,Q=W.height-1,r=-1,O=-1}const i="_getImageData"+(n?"Grey":"")+W.pixel_size+"bits",I=a[i](W,Z,F,Q,r,O,J,v,K);N.getEngine()._uploadDataToTextureDirectly(N,I)}const a={GetTGAHeader:U,UploadContent:W,_getImageData8bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=q,t=N.width,V=N.height;let Z,J,Q,v=0;const r=new Uint8Array(t*V*4);for(Q=d;Q!==W;Q+=U)for(J=a;J!==w;J+=F,v++)Z=A[v],r[4*(J+t*Q)+3]=255,r[4*(J+t*Q)+2]=n[3*Z+0],r[4*(J+t*Q)+1]=n[3*Z+1],r[4*(J+t*Q)+0]=n[3*Z+2];return r},_getImageData16bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=N.width,t=N.height;let V,Z,J,Q=0;const v=new Uint8Array(n*t*4);for(J=d;J!==W;J+=U)for(Z=a;Z!==w;Z+=F,Q+=2){V=A[Q+0]+(A[Q+1]<<8);const N=255*((31744&V)>>10)/31|0,q=255*((992&V)>>5)/31|0,C=255*(31&V)/31|0;v[4*(Z+n*J)+0]=N,v[4*(Z+n*J)+1]=q,v[4*(Z+n*J)+2]=C,v[4*(Z+n*J)+3]=32768&V?0:255}return v},_getImageData24bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=N.width,t=N.height;let V,Z,J=0;const Q=new Uint8Array(n*t*4);for(Z=d;Z!==W;Z+=U)for(V=a;V!==w;V+=F,J+=3)Q[4*(V+n*Z)+3]=255,Q[4*(V+n*Z)+2]=A[J+0],Q[4*(V+n*Z)+1]=A[J+1],Q[4*(V+n*Z)+0]=A[J+2];return Q},_getImageData32bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=N.width,t=N.height;let V,Z,J=0;const Q=new Uint8Array(n*t*4);for(Z=d;Z!==W;Z+=U)for(V=a;V!==w;V+=F,J+=4)Q[4*(V+n*Z)+2]=A[J+0],Q[4*(V+n*Z)+1]=A[J+1],Q[4*(V+n*Z)+0]=A[J+2],Q[4*(V+n*Z)+3]=A[J+3];return Q},_getImageDataGrey8bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=N.width,t=N.height;let V,Z,J,Q=0;const v=new Uint8Array(n*t*4);for(J=d;J!==W;J+=U)for(Z=a;Z!==w;Z+=F,Q++)V=A[Q],v[4*(Z+n*J)+0]=V,v[4*(Z+n*J)+1]=V,v[4*(Z+n*J)+2]=V,v[4*(Z+n*J)+3]=255;return v},_getImageDataGrey16bits:function(N,q,C,d,U,W,a,F,w){const A=C,n=N.width,t=N.height;let V,Z,J=0;const Q=new Uint8Array(n*t*4);for(Z=d;Z!==W;Z+=U)for(V=a;V!==w;V+=F,J+=2)Q[4*(V+n*Z)+0]=A[J+0],Q[4*(V+n*Z)+1]=A[J+0],Q[4*(V+n*Z)+2]=A[J+0],Q[4*(V+n*Z)+3]=A[J+1];return Q}};class F{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(N,q,C){const d=new Uint8Array(N.buffer,N.byteOffset,N.byteLength),a=U(d);C(a.width,a.height,q.generateMipMaps,!1,(()=>{W(q,d)}))}}}}]);