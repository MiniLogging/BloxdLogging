"use strict";(self.ozi0exxand9=self.ozi0exxand9||[]).push([[50],{13846:(f,v,Z)=>{Z.r(v),Z.d(v,{_TGATextureLoader:()=>e});var V=Z(11247);function h(f){let v=0;return{id_length:f[v++],colormap_type:f[v++],image_type:f[v++],colormap_index:f[v++]|f[v++]<<8,colormap_length:f[v++]|f[v++]<<8,colormap_size:f[v++],origin:[f[v++]|f[v++]<<8,f[v++]|f[v++]<<8],width:f[v++]|f[v++]<<8,height:f[v++]|f[v++]<<8,pixel_size:f[v++],flags:f[v++]}}function J(f,v){if(v.length<19)return void V.e.Error("Unable to load TGA file - Not enough data to contain header");let Z=18;const J=h(v);if(J.id_length+Z>v.length)return void V.e.Error("Unable to load TGA file - Not enough data");Z+=J.id_length;let e,C=!1,H=!1,O=!1;switch(J.image_type){case 9:C=!0;case 1:H=!0;break;case 10:C=!0;case 2:break;case 11:C=!0;case 3:O=!0}const u=J.pixel_size>>3,W=J.width*J.height*u;let a,b,X,F,U,K,M;if(H&&(a=v.subarray(Z,Z+=J.colormap_length*(J.colormap_size>>3))),C){let f,V,h;e=new Uint8Array(W);let J=0;const l=new Uint8Array(u);for(;Z<W&&J<W;)if(f=v[Z++],V=1+(127&f),128&f){for(h=0;h<u;++h)l[h]=v[Z++];for(h=0;h<V;++h)e.set(l,J+h*u);J+=u*V}else{for(V*=u,h=0;h<V;++h)e[J+h]=v[Z++];J+=V}}else e=v.subarray(Z,Z+=H?J.width*J.height:W);switch((48&J.flags)>>4){default:case 2:b=0,F=1,M=J.width,X=0,U=1,K=J.height;break;case 0:b=0,F=1,M=J.width,X=J.height-1,U=-1,K=-1;break;case 3:b=J.width-1,F=-1,M=-1,X=0,U=1,K=J.height;break;case 1:b=J.width-1,F=-1,M=-1,X=J.height-1,U=-1,K=-1}const A="_getImageData"+(O?"Grey":"")+J.pixel_size+"bits",s=l[A](J,a,e,X,U,K,b,F,M);f.getEngine()._uploadDataToTextureDirectly(f,s)}const l={GetTGAHeader:h,UploadContent:J,_getImageData8bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=v,u=f.width,W=f.height;let a,b,X,F=0;const U=new Uint8Array(u*W*4);for(X=V;X!==J;X+=h)for(b=l;b!==C;b+=e,F++)a=H[F],U[4*(b+u*X)+3]=255,U[4*(b+u*X)+2]=O[3*a+0],U[4*(b+u*X)+1]=O[3*a+1],U[4*(b+u*X)+0]=O[3*a+2];return U},_getImageData16bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=f.width,u=f.height;let W,a,b,X=0;const F=new Uint8Array(O*u*4);for(b=V;b!==J;b+=h)for(a=l;a!==C;a+=e,X+=2){W=H[X+0]+(H[X+1]<<8);const f=255*((31744&W)>>10)/31|0,v=255*((992&W)>>5)/31|0,Z=255*(31&W)/31|0;F[4*(a+O*b)+0]=f,F[4*(a+O*b)+1]=v,F[4*(a+O*b)+2]=Z,F[4*(a+O*b)+3]=32768&W?0:255}return F},_getImageData24bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=f.width,u=f.height;let W,a,b=0;const X=new Uint8Array(O*u*4);for(a=V;a!==J;a+=h)for(W=l;W!==C;W+=e,b+=3)X[4*(W+O*a)+3]=255,X[4*(W+O*a)+2]=H[b+0],X[4*(W+O*a)+1]=H[b+1],X[4*(W+O*a)+0]=H[b+2];return X},_getImageData32bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=f.width,u=f.height;let W,a,b=0;const X=new Uint8Array(O*u*4);for(a=V;a!==J;a+=h)for(W=l;W!==C;W+=e,b+=4)X[4*(W+O*a)+2]=H[b+0],X[4*(W+O*a)+1]=H[b+1],X[4*(W+O*a)+0]=H[b+2],X[4*(W+O*a)+3]=H[b+3];return X},_getImageDataGrey8bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=f.width,u=f.height;let W,a,b,X=0;const F=new Uint8Array(O*u*4);for(b=V;b!==J;b+=h)for(a=l;a!==C;a+=e,X++)W=H[X],F[4*(a+O*b)+0]=W,F[4*(a+O*b)+1]=W,F[4*(a+O*b)+2]=W,F[4*(a+O*b)+3]=255;return F},_getImageDataGrey16bits:function(f,v,Z,V,h,J,l,e,C){const H=Z,O=f.width,u=f.height;let W,a,b=0;const X=new Uint8Array(O*u*4);for(a=V;a!==J;a+=h)for(W=l;W!==C;W+=e,b+=2)X[4*(W+O*a)+0]=H[b+0],X[4*(W+O*a)+1]=H[b+0],X[4*(W+O*a)+2]=H[b+0],X[4*(W+O*a)+3]=H[b+1];return X}};class e{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(f,v,Z){const V=new Uint8Array(f.buffer,f.byteOffset,f.byteLength),l=h(V);Z(l.width,l.height,v.generateMipMaps,!1,(()=>{J(v,V)}))}}}}]);