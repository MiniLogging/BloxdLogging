"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[50],{14271:(Z,h,V)=>{V.r(h),V.d(h,{_TGATextureLoader:()=>d});var v=V(11580);function A(Z){let h=0;return{id_length:Z[h++],colormap_type:Z[h++],image_type:Z[h++],colormap_index:Z[h++]|Z[h++]<<8,colormap_length:Z[h++]|Z[h++]<<8,colormap_size:Z[h++],origin:[Z[h++]|Z[h++]<<8,Z[h++]|Z[h++]<<8],width:Z[h++]|Z[h++]<<8,height:Z[h++]|Z[h++]<<8,pixel_size:Z[h++],flags:Z[h++]}}function H(Z,h){if(h.length<19)return void v.b.Error("Unable to load TGA file - Not enough data to contain header");let V=18;const H=A(h);if(H.id_length+V>h.length)return void v.b.Error("Unable to load TGA file - Not enough data");V+=H.id_length;let d,a=!1,n=!1,x=!1;switch(H.image_type){case 9:a=!0;case 1:n=!0;break;case 10:a=!0;case 2:break;case 11:a=!0;case 3:x=!0}const N=H.pixel_size>>3,D=H.width*H.height*N;let k,u,F,b,o,q,X;if(n&&(k=h.subarray(V,V+=H.colormap_length*(H.colormap_size>>3))),a){let Z,v,A;d=new Uint8Array(D);let H=0;const K=new Uint8Array(N);for(;V<D&&H<D;)if(Z=h[V++],v=1+(127&Z),128&Z){for(A=0;A<N;++A)K[A]=h[V++];for(A=0;A<v;++A)d.set(K,H+A*N);H+=N*v}else{for(v*=N,A=0;A<v;++A)d[H+A]=h[V++];H+=v}}else d=h.subarray(V,V+=n?H.width*H.height:D);switch((48&H.flags)>>4){default:case 2:u=0,b=1,X=H.width,F=0,o=1,q=H.height;break;case 0:u=0,b=1,X=H.width,F=H.height-1,o=-1,q=-1;break;case 3:u=H.width-1,b=-1,X=-1,F=0,o=1,q=H.height;break;case 1:u=H.width-1,b=-1,X=-1,F=H.height-1,o=-1,q=-1}const E="_getImageData"+(x?"Grey":"")+H.pixel_size+"bits",j=K[E](H,k,d,F,o,q,u,b,X);Z.getEngine()._uploadDataToTextureDirectly(Z,j)}const K={GetTGAHeader:A,UploadContent:H,_getImageData8bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=h,N=Z.width,D=Z.height;let k,u,F,b=0;const o=new Uint8Array(N*D*4);for(F=v;F!==H;F+=A)for(u=K;u!==a;u+=d,b++)k=n[b],o[4*(u+N*F)+3]=255,o[4*(u+N*F)+2]=x[3*k+0],o[4*(u+N*F)+1]=x[3*k+1],o[4*(u+N*F)+0]=x[3*k+2];return o},_getImageData16bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=Z.width,N=Z.height;let D,k,u,F=0;const b=new Uint8Array(x*N*4);for(u=v;u!==H;u+=A)for(k=K;k!==a;k+=d,F+=2){D=n[F+0]+(n[F+1]<<8);const Z=255*((31744&D)>>10)/31|0,h=255*((992&D)>>5)/31|0,V=255*(31&D)/31|0;b[4*(k+x*u)+0]=Z,b[4*(k+x*u)+1]=h,b[4*(k+x*u)+2]=V,b[4*(k+x*u)+3]=32768&D?0:255}return b},_getImageData24bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=Z.width,N=Z.height;let D,k,u=0;const F=new Uint8Array(x*N*4);for(k=v;k!==H;k+=A)for(D=K;D!==a;D+=d,u+=3)F[4*(D+x*k)+3]=255,F[4*(D+x*k)+2]=n[u+0],F[4*(D+x*k)+1]=n[u+1],F[4*(D+x*k)+0]=n[u+2];return F},_getImageData32bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=Z.width,N=Z.height;let D,k,u=0;const F=new Uint8Array(x*N*4);for(k=v;k!==H;k+=A)for(D=K;D!==a;D+=d,u+=4)F[4*(D+x*k)+2]=n[u+0],F[4*(D+x*k)+1]=n[u+1],F[4*(D+x*k)+0]=n[u+2],F[4*(D+x*k)+3]=n[u+3];return F},_getImageDataGrey8bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=Z.width,N=Z.height;let D,k,u,F=0;const b=new Uint8Array(x*N*4);for(u=v;u!==H;u+=A)for(k=K;k!==a;k+=d,F++)D=n[F],b[4*(k+x*u)+0]=D,b[4*(k+x*u)+1]=D,b[4*(k+x*u)+2]=D,b[4*(k+x*u)+3]=255;return b},_getImageDataGrey16bits:function(Z,h,V,v,A,H,K,d,a){const n=V,x=Z.width,N=Z.height;let D,k,u=0;const F=new Uint8Array(x*N*4);for(k=v;k!==H;k+=A)for(D=K;D!==a;D+=d,u+=2)F[4*(D+x*k)+0]=n[u+0],F[4*(D+x*k)+1]=n[u+0],F[4*(D+x*k)+2]=n[u+0],F[4*(D+x*k)+3]=n[u+1];return F}};class d{constructor(){this.supportCascades=!1}loadCubeData(){throw".env not supported in Cube."}loadData(Z,h,V){const v=new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength),K=A(v);V(K.width,K.height,h.generateMipMaps,!1,(()=>{H(h,v)}))}}}}]);