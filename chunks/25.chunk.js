"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11876:(Z,U,n)=>{n.r(U),n.d(U,{EXT_materials_diffuse_roughness:()=>JU,EXT_mesh_gpu_instancing:()=>kZ,GLTF2Export:()=>QZ,GLTFData:()=>R,KHR_draco_mesh_compression:()=>nU,KHR_lights_punctual:()=>GU,KHR_materials_anisotropy:()=>FU,KHR_materials_clearcoat:()=>SU,KHR_materials_diffuse_transmission:()=>sU,KHR_materials_dispersion:()=>OU,KHR_materials_emissive_strength:()=>tU,KHR_materials_ior:()=>KU,KHR_materials_iridescence:()=>DU,KHR_materials_sheen:()=>jU,KHR_materials_specular:()=>XU,KHR_materials_transmission:()=>PU,KHR_materials_unlit:()=>xU,KHR_materials_volume:()=>oU,KHR_texture_transform:()=>aU,OBJExport:()=>H,STLExport:()=>MU,USDZExportAsync:()=>Un,_ConvertToGLTFPBRMetallicRoughness:()=>T,_SolveMetallic:()=>P,__IGLTFExporterExtension:()=>V});var i=n(702),B=n(498),l=n(871);class H{static OBJ(Z,U,n,H){const V=[];let G=1,R=1;U&&(n||(n="mat"),V.push("mtllib "+n+".mtl"));for(let d=0;d<Z.length;d++){const n=Z[d],F=n.name||`mesh${d}}`;V.push(`o ${F}`);let y=null;if(H){const Z=n.yi(!0);y=new i.b,Z.invertToRef(y),n.bakeTransformIntoVertices(Z)}if(U){const Z=n.material;Z&&V.push("usemtl "+Z.id)}const S=n.ui;if(!S){B.e.Warn("No geometry is present on the mesh");continue}const q=S.getVerticesData("position"),c=S.getVerticesData("Xi"),s=S.getVerticesData("uv"),z=S.zi();let O=0,E=0;if(!q||!z){B.e.Warn("There are no position vertices or indices on the mesh!");continue}const t=Z[0].va().useRightHandedSystem?1:-1;for(let Z=0;Z<q.length;Z+=3)V.push("v "+q[Z]*t+" "+q[Z+1]+" "+q[Z+2]),O++;if(null!=c)for(let Z=0;Z<c.length;Z+=3)V.push("vn "+c[Z]*t+" "+c[Z+1]+" "+c[Z+2]);if(null!=s)for(let Z=0;Z<s.length;Z+=2)V.push("vt "+s[Z]+" "+s[Z+1]),E++;const p=["","",""],K=(n.material||n.va().defaultMaterial)._getEffectiveOrientation(n),[C,D]=K===l.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let Z=0;Z<z.length;Z+=3){const U=[String(z[Z]+G),String(z[Z+C]+G),String(z[Z+D]+G)],n=[String(z[Z]+R),String(z[Z+C]+R),String(z[Z+D]+R)],i=U,B=null!=s?n:p,l=null!=c?U:p;V.push("f "+i[0]+"/"+B[0]+"/"+l[0]+" "+i[1]+"/"+B[1]+"/"+l[1]+" "+i[2]+"/"+B[2]+"/"+l[2])}H&&y&&n.bakeTransformIntoVertices(y),G+=O,R+=E}return V.join("\n")}static MTL(Z){const U=[],n=Z.material;U.push("newmtl mat1"),U.push("  Ns "+n.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+n.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+n.ambientColor.r.toFixed(4)+" "+n.ambientColor.g.toFixed(4)+" "+n.ambientColor.b.toFixed(4)),U.push("  Kd "+n.diffuseColor.r.toFixed(4)+" "+n.diffuseColor.g.toFixed(4)+" "+n.diffuseColor.b.toFixed(4)),U.push("  Ks "+n.specularColor.r.toFixed(4)+" "+n.specularColor.g.toFixed(4)+" "+n.specularColor.b.toFixed(4)),U.push("  Ke "+n.emissiveColor.r.toFixed(4)+" "+n.emissiveColor.g.toFixed(4)+" "+n.emissiveColor.b.toFixed(4));n.ambientTexture&&U.push("  map_Ka "+n.ambientTexture.name),n.diffuseTexture&&U.push("  map_Kd "+n.diffuseTexture.name),n.specularTexture&&U.push("  map_Ks "+n.specularTexture.name),n.bumpTexture&&U.push("  map_bump -imfchan z "+n.bumpTexture.name),n.opacityTexture&&U.push("  map_d "+n.opacityTexture.name);return U.join("\n")}}var V=0,G=n(551);class R{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Z in this.files){const U=this.files[Z],n=new Blob([U],{type:(0,G.i)(Z)});B.e.Download(n,Z)}}}var d=n(761),F=n(850),y=n(843),S=n(11883),q=n(2343),c=n(547),s=n(739),z=n(718);const O=z.HighestCommonFactor,E={...z,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:O};var t=n(2301),p=n(2303),K=n(11890),C=n(11899),D=n(2466);const u=1e-6,j=new s.b(.04,.04,.04),v=1024,X=s.b.White(),h=s.b.Black();function P(Z,U,n){if(U<j.r)return 0;const i=j.r,B=Z*n/(1-j.r)+U-2*j.r,l=B*B-4*i*(j.r-U);return E.Clamp((-B+Math.sqrt(l))/(2*i),0,1)}function T(Z){const U=Z.diffuseColor.toLinearSpace(Z.va().getEngine().useExactSrgbConversions).scale(.5),n=Z.alpha,B=function(Z){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new i.j(0,1),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new i.j(0,.1),B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new i.j(0,.1),l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new i.j(1300,.1);return function(Z,U,n,i,B){return(1-Z)*(1-Z)*(1-Z)*U+3*(1-Z)*(1-Z)*Z*n+3*(1-Z)*Z*Z*i+Z*Z*Z*B}(Math.pow(Z/l.x,.333333),U.y,n.y,B.y,l.y)}(E.Clamp(Z.specularPower,0,v));return{baseColorFactor:[U.r,U.g,U.b,n],metallicFactor:0,roughnessFactor:B}}function x(Z,U){U.needAlphaBlending()?Z.alphaMode="BLEND":U.needAlphaTesting()&&(Z.alphaMode="MASK",Z.alphaCutoff=U.alphaCutOff)}function w(Z,U,n){const i=new Uint8Array(Z*U*4);for(let B=0;B<i.length;B+=4)i[B]=i[B+1]=i[B+2]=i[B+3]=255;return K.c.CreateRGBATexture(i,Z,U,n)}function o(Z){if(Z instanceof Uint8Array){const U=Z.length,n=new Float32Array(Z.length);for(let i=0;i<U;++i)n[i]=Z[i]/255;return n}if(Z instanceof Float32Array)return Z;throw new Error("Unsupported pixel format!")}class N{constructor(Z){this._exporter=Z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Z){return Z?this._textureMap.get(Z)??null:null}async exportStandardMaterialAsync(Z,U,n){const i=T(Z),l={name:Z.name};if(null==Z.Di||Z.Di||(Z.twoSidedLighting||B.e.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),n){const n=[],B=Z.diffuseTexture;B&&n.push(this.exportTextureAsync(B,U).then((Z=>{Z&&(i.baseColorTexture=Z)})));const H=Z.bumpTexture;H&&n.push(this.exportTextureAsync(H,U).then((Z=>{Z&&(l.normalTexture=Z,1!==H.level&&(l.normalTexture.scale=H.level))})));const V=Z.emissiveTexture;V&&(l.emissiveFactor=[1,1,1],n.push(this.exportTextureAsync(V,U).then((Z=>{Z&&(l.emissiveTexture=Z)}))));const G=Z.ambientTexture;G&&n.push(this.exportTextureAsync(G,U).then((Z=>{if(Z){const U={index:Z.index};l.occlusionTexture=U}}))),n.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(n))}(Z.alpha<1||Z.opacityTexture)&&(Z.alphaMode===C.d.ALPHA_COMBINE?l.alphaMode="BLEND":B.e.Warn(Z.name+": glTF 2.0 does not support alpha mode: "+Z.alphaMode.toString())),Z.emissiveColor&&!Z.emissiveColor.equalsWithEpsilon(h,u)&&(l.emissiveFactor=Z.emissiveColor.Ei()),l.pbrMetallicRoughness=i,x(l,Z),await this._finishMaterialAsync(l,Z,U);const H=this._exporter._materials;return H.push(l),H.length-1}async _finishMaterialAsync(Z,U,n){const i=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Z,U),B=[];for(const l of i)B.push(this.exportTextureAsync(l,n));await Promise.all(B),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Z,U)}async _getImageDataAsync(Z,U,i,B){const l=C.d.TEXTURETYPE_UNSIGNED_BYTE,H=this._exporter._babylonScene,V=H.getEngine(),G=V.createRawTexture(Z,U,i,C.d.TEXTUREFORMAT_RGBA,!1,!0,p.c.NEAREST_SAMPLINGMODE,null,l);V.isWebGPU?await n.e(45).then(n.bind(n,13374)):await n.e(46).then(n.bind(n,13377)),await t.l.ApplyPostProcess("pass",G,H,l,C.d.TEXTURE_NEAREST_SAMPLINGMODE,C.d.TEXTUREFORMAT_RGBA);const R=await V._readTexturePixels(G,U,i);return await D.DumpTools.DumpDataAsync(U,i,R,B,void 0,!0,!0)}_resizeTexturesToSameDimensions(Z,U,n){const i=Z?Z.getSize():{width:0,height:0},B=U?U.getSize():{width:0,height:0};let l,H;return i.width<B.width?(l=Z&&Z instanceof p.c?t.l.CreateResizedCopy(Z,B.width,B.height,!0):w(B.width,B.height,n),H=U):i.width>B.width?(H=U&&U instanceof p.c?t.l.CreateResizedCopy(U,i.width,i.height,!0):w(i.width,i.height,n),l=Z):(l=Z,H=U),{texture1:l,texture2:H}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,U,n,i){const B=new Array;if(!Z&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const l=Z?Z.va():U?U.va():null;if(l){var H;const V=this._resizeTexturesToSameDimensions(Z,U,l),G=null===(H=V.texture1)||void 0===H?void 0:H.getSize();let R,d;const F=G.width,y=G.height,S=await V.texture1.readPixels(),q=await V.texture2.readPixels();if(!S)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(R=o(S),!q)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");d=o(q);const c=d.byteLength,z=new Uint8Array(c),O=new Uint8Array(c),E=4,t=h;let p=0,K=0;for(let Z=0;Z<y;++Z)for(let U=0;U<F;++U){const i=(F*Z+U)*E,B={diffuseColor:new s.b(R[i],R[i+1],R[i+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(n.diffuseColor),specularColor:new s.b(d[i],d[i+1],d[i+2]).toLinearSpace(l.getEngine().useExactSrgbConversions).multiply(n.specularColor),glossiness:d[i+3]*n.glossiness},H=this._convertSpecularGlossinessToMetallicRoughness(B);t.r=Math.max(t.r,H.baseColor.r),t.g=Math.max(t.g,H.baseColor.g),t.b=Math.max(t.b,H.baseColor.b),p=Math.max(p,H.metallic),K=Math.max(K,H.roughness),O[i]=255*H.baseColor.r,O[i+1]=255*H.baseColor.g,O[i+2]=255*H.baseColor.b,O[i+3]=V.texture1.Jj?255*R[i+3]:255,z[i]=0,z[i+1]=255*H.roughness,z[i+2]=255*H.metallic,z[i+3]=255}const C={baseColor:t,metallic:p,roughness:K};let D=!1,j=!1;for(let Z=0;Z<y;++Z)for(let U=0;U<F;++U){const n=(F*Z+U)*E;O[n]/=C.baseColor.r>u?C.baseColor.r:1,O[n+1]/=C.baseColor.g>u?C.baseColor.g:1,O[n+2]/=C.baseColor.b>u?C.baseColor.b:1;const i=s.b.FromInts(O[n],O[n+1],O[n+2]).toGammaSpace(l.getEngine().useExactSrgbConversions);O[n]=255*i.r,O[n+1]=255*i.g,O[n+2]=255*i.b,i.equalsWithEpsilon(X,u)||(j=!0),z[n+1]/=C.roughness>u?C.roughness:1,z[n+2]/=C.metallic>u?C.metallic:1;s.b.FromInts(255,z[n+1],z[n+2]).equalsWithEpsilon(X,u)||(D=!0)}return D&&B.push(this._getImageDataAsync(z,F,y,i).then((Z=>{C.metallicRoughnessTextureData=Z}))),j&&B.push(this._getImageDataAsync(O,F,y,i).then((Z=>{C.baseColorTextureData=Z}))),await Promise.all(B).then((()=>C))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Z){const U=this._getPerceivedBrightness(Z.diffuseColor),n=this._getPerceivedBrightness(Z.specularColor),i=1-this._getMaxComponent(Z.specularColor),B=P(U,n,i),l=Z.diffuseColor.scale(i/(1-j.r)/Math.max(1-B)),H=Z.specularColor.Qg(j.scale(1-B)).scale(1/Math.max(B));let V=s.b.Lerp(l,H,B*B);V=V.clampToRef(0,1,V);return{baseColor:V,metallic:B,roughness:1-Z.glossiness}}_getPerceivedBrightness(Z){return Z?Math.sqrt(.299*Z.r*Z.r+.587*Z.g*Z.g+.114*Z.b*Z.b):0}_getMaxComponent(Z){return Z?Math.max(Z.r,Math.max(Z.g,Z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Z,U,n,i){const B=[],l={baseColor:Z._albedoColor,metallic:Z._metallic,roughness:Z._roughness};if(i){Z._albedoTexture&&B.push(this.exportTextureAsync(Z._albedoTexture,U).then((Z=>{Z&&(n.baseColorTexture=Z)})));const i=Z._metallicTexture;i&&B.push(this.exportTextureAsync(i,U).then((Z=>{Z&&(n.metallicRoughnessTexture=Z)})))}return B.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(B)),l}_getTextureSampler(Z){const U={};if(!Z||!(Z instanceof p.c))return U;const n=this._getGLTFTextureWrapMode(Z.wrapU);10497!==n&&(U.wrapS=n);const i=this._getGLTFTextureWrapMode(Z.wrapV);switch(10497!==i&&(U.wrapT=i),Z.samplingMode){case p.c.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case p.c.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case p.c.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case p.c.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case p.c.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case p.c.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case p.c.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case p.c.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case p.c.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case p.c.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case p.c.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case p.c.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(Z){switch(Z){case p.c.WRAP_ADDRESSMODE:return 10497;case p.c.CLAMP_ADDRESSMODE:return 33071;case p.c.MIRROR_ADDRESSMODE:return 33648;default:return B.e.Error(`Unsupported Texture Wrap Mode ${Z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Z,U,n,i){const B={diffuseColor:Z._albedoColor,specularColor:Z._reflectivityColor,glossiness:Z._microSurface},l=Z._albedoTexture,H=Z._reflectivityTexture,V=Z._useMicroSurfaceFromReflectivityMapAlpha;if(H&&!V)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((l||H)&&i){this._exporter._materialNeedsUVsSet.add(Z);const i=this._exportTextureSampler(l||H),V=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(l,H,B,U),G=this._exporter._textures;if(V.baseColorTextureData){const Z=this._exportImage(`baseColor${G.length}`,U,V.baseColorTextureData);n.baseColorTexture=this._exportTextureInfo(Z,i,null===l||void 0===l?void 0:l.coordinatesIndex)}if(V.metallicRoughnessTextureData){const Z=this._exportImage(`metallicRoughness${G.length}`,U,V.metallicRoughnessTextureData);n.metallicRoughnessTexture=this._exportTextureInfo(Z,i,null===H||void 0===H?void 0:H.coordinatesIndex)}return V}return this._convertSpecularGlossinessToMetallicRoughness(B)}async exportPBRMaterialAsync(Z,U,n){const i={},B={name:Z.name},l=Z.isMetallicWorkflow();if(l){const U=Z._albedoColor,n=Z.alpha;U&&(i.baseColorFactor=[U.r,U.g,U.b,n])}const H=l?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Z,U,i,n):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Z,U,i,n);await this._setMetallicRoughnessPbrMaterialAsync(H,Z,B,i,U,n),await this._finishMaterialAsync(B,Z,U);const V=this._exporter._materials;return V.push(B),V.length-1}async _setMetallicRoughnessPbrMaterialAsync(Z,U,n,i,l,H){if(x(n,U),Z.baseColor.equalsWithEpsilon(X,u)&&E.WithinEpsilon(U.alpha,1,u)||(i.baseColorFactor=[Z.baseColor.r,Z.baseColor.g,Z.baseColor.b,U.alpha]),null!=Z.metallic&&1!==Z.metallic&&(i.metallicFactor=Z.metallic),null!=Z.roughness&&1!==Z.roughness&&(i.roughnessFactor=Z.roughness),null==U.Di||U.Di||(U._twoSidedLighting||B.e.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),H){const Z=[],i=U._bumpTexture;i&&Z.push(this.exportTextureAsync(i,l).then((Z=>{Z&&(n.normalTexture=Z,1!==i.level&&(n.normalTexture.scale=i.level))})));const B=U._ambientTexture;B&&Z.push(this.exportTextureAsync(B,l).then((Z=>{if(Z){const i={index:Z.index,texCoord:Z.texCoord,extensions:Z.extensions};n.occlusionTexture=i;const B=U._ambientTextureStrength;B&&(i.strength=B)}})));const H=U._emissiveTexture;H&&Z.push(this.exportTextureAsync(H,l).then((Z=>{Z&&(n.emissiveTexture=Z)}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(Z))}const V=U._emissiveColor;V.equalsWithEpsilon(h,u)||(n.emissiveFactor=V.Ei()),n.pbrMetallicRoughness=i}_getPixelsFromTextureAsync(Z){return function(Z){switch(Z){case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case C.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Z.textureFormat)?(0,t.j)(Z,Z._texture.width,Z._texture.height):(Z.textureType,C.d.TEXTURETYPE_UNSIGNED_BYTE,Z.readPixels())}async exportTextureAsync(Z,U){const n=this._exporter._extensionsPreExportTextureAsync("exporter",Z,U);return n?await n.then((async n=>n?await this._exportTextureInfoAsync(n,U):await this._exportTextureInfoAsync(Z,U))):await this._exportTextureInfoAsync(Z,U)}async _exportTextureInfoAsync(Z,U){let n=this._textureMap.get(Z);if(!n){const i=await this._getPixelsFromTextureAsync(Z);if(!i)return null;const l=this._exportTextureSampler(Z),H=Z.mimeType;if(H)switch(H){case"image/jpeg":case"image/png":case"image/webp":U=H;break;default:B.e.Warn(`Unsupported media type: ${H}. Exporting texture as PNG.`)}const V=this._internalTextureToImage,G=Z.getInternalTexture().uniqueId;V[G]||(V[G]={});let R=V[G][U];if(void 0===R){const n=Z.getSize();R=(async()=>{const B=await this._getImageDataAsync(i,n.width,n.height,U);return this._exportImage(Z.name,U,B)})(),V[G][U]=R}n=this._exportTextureInfo(await R,l,Z.coordinatesIndex),this._textureMap.set(Z,n),this._exporter._extensionsPostExportTextures("exporter",n,Z)}return n}_exportImage(Z,U,n){const i=this._exporter._images;let l;if(this._exporter._shouldUseGlb){l={name:Z,mimeType:U,bufferView:void 0};const i=this._exporter._bufferManager.createBufferView(new Uint8Array(n));this._exporter._bufferManager.setBufferView(l,i)}else{const H=Z.replace(/\.\/|\/|\.\\|\\/g,"_"),V=function(Z){switch(Z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let G=H+V;i.some((Z=>Z.uri===G))&&(G=`${H}_${B.e.RandomId()}${V}`),l={name:Z,uri:G},this._exporter._imageData[G]={data:n,mimeType:U}}return i.push(l),i.length-1}_exportTextureInfo(Z,U,n){const i=this._exporter._textures;let B=i.findIndex((n=>n.sampler==U&&n.source===Z));-1===B&&(B=i.length,i.push({source:Z,sampler:U}));const l={index:B};return n&&(l.texCoord=n),l}_exportTextureSampler(Z){const U=this._getTextureSampler(Z),n=this._exporter._samplers,i=n.findIndex((Z=>Z.minFilter===U.minFilter&&Z.magFilter===U.magFilter&&Z.wrapS===U.wrapS&&Z.wrapT===U.wrapT));return-1!==i?i:(n.push(U),n.length-1)}}var J=n(772),W=n(513),a=n(11906),M=n(705);const m=i.k.Zero(),A=i.d.Identity(),Y=i.k.One(),Q=new i.k(-1,1,1);function L(Z,U){const{byteOffset:n,byteStride:i,type:B,normalized:l}=Z,H=Z.getSize(),V=U.reduce(((Z,U)=>U.getTotalVertices()>Z?U.getTotalVertices():Z),-Number.MAX_VALUE);return{byteOffset:n,byteStride:i,componentCount:H,type:B,count:V*H,normalized:l,totalVertices:V,kind:Z.getKind()}}function k(Z){switch(Z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function I(Z){switch(Z){case d.f.PositionKind:case d.f.NormalKind:case d.f.TangentKind:case d.f.ColorKind:case d.f.MatricesIndicesKind:case d.f.MatricesIndicesExtraKind:case d.f.MatricesWeightsKind:case d.f.MatricesWeightsExtraKind:case d.f.UVKind:case d.f.UV2Kind:case d.f.UV3Kind:case d.f.UV4Kind:case d.f.UV5Kind:case d.f.UV6Kind:return!0}return!1}function e(Z){switch(Z){case l.c.TriangleFillMode:return 4;case l.c.TriangleStripDrawMode:return 5;case l.c.TriangleFanDrawMode:return 6;case l.c.PointListDrawMode:case l.c.PointFillMode:return 0;case l.c.LineLoopDrawMode:return 2;case l.c.LineListDrawMode:return 1;case l.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Z}`)}function g(Z){const U=Math.sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);U>0&&(Z.x/=U,Z.y/=U,Z.z/=U)}function b(Z){return Z.x*=-1,Z}function r(Z){if(Z.x*Z.x+Z.y*Z.y>.5){const U=Math.abs(Z.x),n=Math.abs(Z.y);if(U>n){const n=Math.sign(Z.x);Z.x=U,Z.y*=-n,Z.z*=-n,Z.w*=n}else{const U=Math.sign(Z.y);Z.x*=-U,Z.y=n,Z.z*=U,Z.w*=-U}}else{const U=Math.abs(Z.z),n=Math.abs(Z.w);if(U>n){const n=Math.sign(Z.z);Z.x*=-n,Z.y*=n,Z.z=U,Z.w*=-n}else{const U=Math.sign(Z.w);Z.x*=U,Z.y*=-U,Z.z*=-U,Z.w=n}}return Z}function f(Z){Z.li(-Z.z,Z.w,Z.x,-Z.y)}function ZZ(Z,U){const n=i.k.FromArrayToRef(U.translation||[0,0,0],0,i.g.ti[0]),B=i.d.FromArrayToRef(U.rotation||[0,0,0,1],0,i.g.Quaternion[0]),l=i.b.ComposeToRef(Y,B,n,i.g.Matrix[0]),H=i.k.FromArrayToRef(Z.translation||[0,0,0],0,i.g.ti[2]),V=i.d.FromArrayToRef(Z.rotation||[0,0,0,1],0,i.g.Quaternion[1]),G=i.b.ComposeToRef(Y,V,H,i.g.Matrix[1]);l.multiplyToRef(G,G),G.decompose(void 0,B,n),n.equalsWithEpsilon(m,M.e)?delete U.translation:U.translation=n.Ei(),B.equalsWithEpsilon(A,M.e)?delete U.rotation:U.rotation=B.Ei(),U.scale&&delete U.scale}function UZ(Z,U){if(!(U instanceof F.c))return!1;if(!(1===U.getChildren().length&&0===Z.getChildren().length&&Z.parent===U))return!1;const n=Z.va(),i=Z instanceof a.e&&!n.useRightHandedSystem?Q:Y;return!!U.mi.equalsWithEpsilon(i,M.e)||(W.c.Warn(`Cannot collapse node ${Z.name} into parent node ${U.name} with modified scaling.`),!1)}function nZ(Z){if(Z instanceof Array){const U=new Float32Array(Z);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(Z)?new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength):new Uint8Array(Z)}function iZ(Z,U){for(const[n,i]of Object.entries(Z)){const B=U[n];(Array.isArray(i)&&Array.isArray(B)&&BZ(i,B)||i===B)&&delete Z[n]}return Z}function BZ(Z,U){return Z.length===U.length&&Z.every(((Z,n)=>Z===U[n]))}const lZ=i.b.Compose(new i.k(-1,1,1),i.d.Identity(),i.k.Zero());function HZ(Z,U){if(!(Z instanceof F.c))return!1;if(U){if(!Z.getWorldMatrix().equalsWithEpsilon(i.b.IdentityReadOnly,M.e))return!1}else{if(!Z.getWorldMatrix().multiplyToRef(lZ,i.g.Matrix[0]).equalsWithEpsilon(i.b.IdentityReadOnly,M.e))return!1}return!(Z instanceof y.c&&Z.ui)}const VZ=new Map([[Int8Array,(Z,U,n)=>Z.setInt8(U,n)],[Uint8Array,(Z,U,n)=>Z.setUint8(U,n)],[Uint8ClampedArray,(Z,U,n)=>Z.setUint8(U,n)],[Int16Array,(Z,U,n)=>Z.setInt16(U,n,!0)],[Uint16Array,(Z,U,n)=>Z.setUint16(U,n,!0)],[Int32Array,(Z,U,n)=>Z.setInt32(U,n,!0)],[Uint32Array,(Z,U,n)=>Z.setUint32(U,n,!0)],[Float32Array,(Z,U,n)=>Z.setFloat32(U,n,!0)],[Float64Array,(Z,U,n)=>Z.setFloat64(U,n,!0)]]);class GZ{writeTypedArray(Z){this._checkGrowBuffer(Z.byteLength);const U=VZ.get(Z.constructor);for(let n=0;n<Z.length;n++)U(this._dataView,this._byteOffset,Z[n]),this._byteOffset+=Z.BYTES_PER_ELEMENT}constructor(Z){this._data=new Uint8Array(Z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Z),this._byteOffset++}writeInt8(Z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Z),this._byteOffset++}writeInt16(Z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Z,!0),this._byteOffset+=2}writeUInt16(Z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Z,!0),this._byteOffset+=2}writeInt32(Z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Z,!0),this._byteOffset+=4}writeUInt32(Z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat32(Z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat64(Z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Z,!0),this._byteOffset+=8}_checkGrowBuffer(Z){const U=this.byteOffset+Z;if(U>this._data.byteLength){const Z=new Uint8Array(2*U);Z.set(this._data),this._data=Z,this._dataView=new DataView(this._data.buffer)}}}function RZ(Z){return Z%4===0?4:Z%2===0?2:1}class dZ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Z){let U=0;this._bufferViewToData.forEach((Z=>{U+=Z.byteLength}));const n=new GZ(U),i=Array.from(this._bufferViewToData.keys()).sort(((Z,U)=>RZ(U.byteLength)-RZ(Z.byteLength)));for(const B of i){B.byteOffset=n.byteOffset,Z.push(B);const U=Z.length-1,i=this.getPropertiesWithBufferView(B);for(const Z of i)Z.bufferView=U;n.writeTypedArray(this._bufferViewToData.get(B)),this._bufferViewToData.delete(B)}return n.getOutputData()}createBufferView(Z,U){const n={buffer:0,byteOffset:void 0,byteLength:Z.byteLength,byteStride:U};return this._bufferViewToData.set(n,Z),n}createAccessor(Z,U,n,i,B,l,H){this._verifyBufferView(Z);const V={bufferView:void 0,componentType:n,count:i,type:U,min:null===l||void 0===l?void 0:l.min,max:null===l||void 0===l?void 0:l.max,normalized:H,byteOffset:B};return this.setBufferView(V,Z),this._accessorToBufferView.set(V,Z),V}setBufferView(Z,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(Z)}removeBufferView(Z){const U=this.getPropertiesWithBufferView(Z);for(const n of U)void 0!==n.bufferView&&delete n.bufferView;this._bufferViewToData.delete(Z),this._bufferViewToProperties.delete(Z),this._accessorToBufferView.forEach(((U,n)=>{U===Z&&(void 0!==n.byteOffset&&delete n.byteOffset,this._accessorToBufferView.delete(n))}))}getBufferView(Z){const U=this._accessorToBufferView.get(Z);return this._verifyBufferView(U),U}getPropertiesWithBufferView(Z){return this._verifyBufferView(Z),this._bufferViewToProperties.set(Z,this._bufferViewToProperties.get(Z)??[]),this._bufferViewToProperties.get(Z)}getData(Z){return this._verifyBufferView(Z),this._bufferViewToData.get(Z)}_verifyBufferView(Z){if(void 0===Z||!this._bufferViewToData.has(Z))throw new Error(`BufferView ${Z} not found in BufferManager.`)}}var FZ,yZ=n(670),SZ=n(896),qZ=n(11911),cZ=n(11958),sZ=n(11964),zZ=n(11973),OZ=n(490),EZ=n(11979);!function(Z){Z[Z.INTANGENT=0]="INTANGENT",Z[Z.OUTTANGENT=1]="OUTTANGENT"}(FZ||(FZ={}));class tZ{static _IsTransformable(Z){return Z&&(Z instanceof F.c||Z instanceof yZ.d||Z instanceof EZ.d)}static _CreateNodeAnimation(Z,U,n,i,l){if(this._IsTransformable(Z)){const H=[],V=[],G=U.getKeys(),R=tZ._CalculateMinMaxKeyFrames(G),d=tZ._DeduceInterpolation(G,n,i),F=d.interpolationType,y=d.shouldBakeAnimation;if(y?tZ._CreateBakedAnimation(Z,U,n,R.min,R.max,U.framePerSecond,l,H,V,R,i):"LINEAR"===F||"STEP"===F?tZ._CreateLinearOrStepAnimation(Z,U,n,H,V,i):"CUBICSPLINE"===F?tZ._CreateCubicSplineAnimation(Z,U,n,H,V,i):tZ._CreateBakedAnimation(Z,U,n,R.min,R.max,U.framePerSecond,l,H,V,R,i),H.length&&V.length){return{inputs:H,outputs:V,samplerInterpolation:F,inputsMin:y?R.min:B.e.FloatRound(R.min/U.framePerSecond),inputsMax:y?R.max:B.e.FloatRound(R.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(Z){let U=null,n="VEC3",i=!1;const l=Z.targetProperty.split(".");switch(l[0]){case"mi":U="scale";break;case"position":U="translation";break;case"rotation":n="VEC4",U="rotation";break;case"rotationQuaternion":n="VEC4",i=!0,U="rotation";break;case"influence":n="SCALAR",U="weights";break;default:B.e.Error(`Unsupported animatable property ${l[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:n,useQuaternion:i}:(B.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Z,U,n,i,B,l,H,V,G,R,d){let F;if(tZ._IsTransformable(Z)&&Z.animations)for(const y of Z.animations){if(d&&!d(y))continue;const B=tZ._DeduceAnimationInfo(y);B&&(F={name:y.name,samplers:[],channels:[]},tZ._AddAnimation(`${y.name}`,y.hasRunningRuntimeAnimations?U:F,Z,y,B.dataAccessorType,B.animationChannelTargetPath,i,l,H,V,B.useQuaternion,G,R),F.samplers.length&&F.channels.length&&n.push(F))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Z,U,n,i,B,l,H,V,G,R,d){let F;if(Z instanceof OZ.e){const B=Z.morphTargetManager;if(B)for(let y=0;y<B.numTargets;++y){const S=B.getTarget(y);for(const q of S.animations){if(d&&!d(q))continue;const S=new sZ.e(`${q.name}`,"influence",q.framePerSecond,q.dataType,q.loopMode,q.enableBlending),c=[],s=q.getKeys();for(let Z=0;Z<s.length;++Z){const U=s[Z];for(let Z=0;Z<B.numTargets;++Z)Z==y?c.push(U):c.push({frame:U.frame,value:0})}S.setKeys(c);const z=tZ._DeduceAnimationInfo(S);z&&(F={name:S.name,samplers:[],channels:[]},tZ._AddAnimation(q.name,q.hasRunningRuntimeAnimations?U:F,Z,S,z.dataAccessorType,z.animationChannelTargetPath,i,l,H,V,z.useQuaternion,G,R,B.numTargets),F.samplers.length&&F.channels.length&&n.push(F))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Z,U,n,i,B,l,H,V,G){let R;if(Z.animationGroups){const F=Z.animationGroups;for(const y of F){const F=new Map,S=new Map,q=new Set,c=y.to-y.from;R={name:y.name,channels:[],samplers:[]};for(let U=0;U<y.targetedAnimations.length;++U){const c=y.targetedAnimations[U],s=c.target,z=c.animation;if(G&&!G(z))continue;const O=V.has(s);if(this._IsTransformable(s)||1===s.length&&this._IsTransformable(s[0])){const Z=tZ._DeduceAnimationInfo(c.animation);if(Z){const U=this._IsTransformable(s)?s:this._IsTransformable(s[0])?s[0]:null;U&&tZ._AddAnimation(`${z.name}`,R,U,z,Z.dataAccessorType,Z.animationChannelTargetPath,n,i,B,l,Z.useQuaternion,H,O)}}else if(s instanceof zZ.b||1===s.length&&s[0]instanceof zZ.b){if(tZ._DeduceAnimationInfo(c.animation)){const U=s instanceof zZ.b?s:s[0];if(U){const n=Z.morphTargetManagers.find((Z=>{for(let n=0;n<Z.numTargets;++n)if(Z.getTarget(n)===U)return!0;return!1}));if(n){const i=Z.meshes.find((Z=>Z.morphTargetManager===n));var d;if(i)F.has(i)||F.set(i,new Map),null===(d=F.get(i))||void 0===d||d.set(U,z),q.add(i),S.set(i,z)}}}}}q.forEach((Z=>{const U=Z.morphTargetManager;let V=null;const G=[],d=S.get(Z).getKeys(),q=d.length;for(let n=0;n<q;++n)for(let i=0;i<U.numTargets;++i){const B=U.getTarget(i),l=F.get(Z);if(l){const U=l.get(B);U?(V||(V=new sZ.e(`${y.name}_${Z.name}_MorphWeightAnimation`,"influence",U.framePerSecond,sZ.e.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),G.push(U.getKeys()[n])):G.push({frame:y.from+c/q*n,value:B.influence,inTangent:d[0].inTangent?0:void 0,outTangent:d[0].outTangent?0:void 0})}}V.setKeys(G);const s=tZ._DeduceAnimationInfo(V);s&&tZ._AddAnimation(`${y.name}_${Z.name}_MorphWeightAnimation`,R,Z,V,s.dataAccessorType,s.animationChannelTargetPath,n,i,B,l,s.useQuaternion,H,!1,null===U||void 0===U?void 0:U.numTargets)})),R.channels.length&&R.samplers.length&&U.push(R)}}}static _AddAnimation(Z,U,n,B,l,H,V,G,R,d,F,y,S,q){const c=tZ._CreateNodeAnimation(n,B,H,F,y);let s,z,O,E,t,p;if(c){if(q){let Z=0,U=0;const n=[];for(;c.inputs.length>0;)U=c.inputs.shift(),Z%q==0&&n.push(U),Z++;c.inputs=n}const Z=V.get(n),B=new Float32Array(c.inputs);s=G.createBufferView(B),z=G.createAccessor(s,"SCALAR",5126,c.inputs.length,void 0,{min:[c.inputsMin],max:[c.inputsMax]}),d.push(z),O=d.length-1;const R=new i.d,F=new i.k,y=new i.k,K=n instanceof yZ.d,C=k(l),D=new Float32Array(c.outputs.length*C);c.outputs.forEach((function(Z,U){let n=Z;switch(H){case"translation":S&&(i.k.FromArrayToRef(Z,0,y),b(y),y.toArray(n));break;case"rotation":4===Z.length?i.d.FromArrayToRef(Z,0,R):(n=new Array(4),i.k.FromArrayToRef(Z,0,F),i.d.FromEulerVectorToRef(F,R)),S&&(r(R),K&&f(R)),R.toArray(n)}D.set(n,U*C)})),s=G.createBufferView(D),z=G.createAccessor(s,l,5126,c.outputs.length),d.push(z),E=d.length-1,t={interpolation:c.samplerInterpolation,input:O,output:E},U.samplers.push(t),p={sampler:U.samplers.length-1,target:{node:Z,path:H}},U.channels.push(p)}}static _CreateBakedAnimation(Z,U,n,l,H,V,G,R,d,F,y){let S;const q=i.d.Identity();let c,s=null,z=null,O=null,E=null,t=null,p=null;F.min=B.e.FloatRound(l/V);const K=U.getKeys();for(let i=0,C=K.length;i<C;++i){if(p=null,O=K[i],i+1<C)if(E=K[i+1],O.value.equals&&O.value.equals(E.value)||O.value===E.value){if(0!==i)continue;p=O.frame}else p=E.frame;else{if(t=K[i-1],O.value.equals&&O.value.equals(t.value)||O.value===t.value)continue;p=H}if(p)for(let i=O.frame;i<=p;i+=G){if(c=B.e.FloatRound(i/V),c===s)continue;s=c,z=c;const l={key:0,repeatCount:0,loopMode:U.loopMode};S=U._interpolate(i,l),tZ._SetInterpolatedValue(Z,S,c,U,n,q,R,d,y)}}z&&(F.max=z)}static _ConvertFactorToVector3OrQuaternion(Z,U,n,l,H){const V=tZ._GetBasePositionRotationOrScale(U,l,H),G=n.targetProperty.split("."),R=G?G[1]:"",d=H?i.d.ri(V).normalize():i.k.ri(V);switch(R){case"x":case"y":case"z":d[R]=Z;break;case"w":d.w=Z;break;default:B.e.Error(`glTFAnimation: Unsupported component name "${R}"!`)}return d}static _SetInterpolatedValue(Z,U,n,B,l,H,V,G,R){let d;V.push(n),"weights"!==l?(B.dataType===sZ.e.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,Z,B,l,R)),"rotation"===l?(R?H=U:(d=U,i.d.RotationYawPitchRollToRef(d.y,d.x,d.z,H)),G.push(H.Ei())):(d=U,G.push(d.Ei()))):G.push([U])}static _CreateLinearOrStepAnimation(Z,U,n,i,B,l){for(const H of U.getKeys())i.push(H.frame/U.framePerSecond),tZ._AddKeyframeValue(H,U,B,n,Z,l)}static _CreateCubicSplineAnimation(Z,U,n,i,B,l){U.getKeys().forEach((function(H){i.push(H.frame/U.framePerSecond),tZ._AddSplineTangent(FZ.INTANGENT,B,n,"CUBICSPLINE",H,l),tZ._AddKeyframeValue(H,U,B,n,Z,l),tZ._AddSplineTangent(FZ.OUTTANGENT,B,n,"CUBICSPLINE",H,l)}))}static _GetBasePositionRotationOrScale(Z,U,n){let B;if("rotation"===U)if(n){B=(Z.rotationQuaternion??i.d.Identity()).Ei()}else{B=(Z.rotation??i.k.Zero()).Ei()}else if("translation"===U){B=(Z.position??i.k.Zero()).Ei()}else{B=(Z.mi??i.k.One()).Ei()}return B}static _AddKeyframeValue(Z,U,n,l,H,V){let G;const R=U.dataType;if(R===sZ.e.ANIMATIONTYPE_VECTOR3){let U=Z.value.Ei();if("rotation"===l){const Z=i.k.ri(U);U=i.d.RotationYawPitchRoll(Z.y,Z.x,Z.z).Ei()}n.push(U)}else if(R===sZ.e.ANIMATIONTYPE_FLOAT){if("weights"===l)n.push([Z.value]);else if(G=this._ConvertFactorToVector3OrQuaternion(Z.value,H,U,l,V),G){if("rotation"===l){const Z=V?G:i.d.RotationYawPitchRoll(G.y,G.x,G.z).normalize();n.push(Z.Ei())}n.push(G.Ei())}}else R===sZ.e.ANIMATIONTYPE_QUATERNION?n.push(Z.value.normalize().Ei()):B.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Z,U,n){let i,B,l=!1;if("rotation"===U&&!n)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let H=0,V=Z.length;H<V;++H)if(B=Z[H],B.inTangent||B.outTangent)if(i){if("CUBICSPLINE"!==i){i="LINEAR",l=!0;break}}else i="CUBICSPLINE";else if(i){if("CUBICSPLINE"===i||B.interpolation&&1===B.interpolation&&"STEP"!==i){i="LINEAR",l=!0;break}}else i=B.interpolation&&1===B.interpolation?"STEP":"LINEAR";return i||(i="LINEAR"),{interpolationType:i,shouldBakeAnimation:l}}static _AddSplineTangent(Z,U,n,B,l,H){let V;const G=Z===FZ.INTANGENT?l.inTangent:l.outTangent;if("CUBICSPLINE"===B){if("rotation"===n)if(G)if(H)V=G.Ei();else{const Z=G;V=i.d.RotationYawPitchRoll(Z.y,Z.x,Z.z).Ei()}else V=[0,0,0,0];else V="weights"===n?G?[G]:[0]:G?G.Ei():[0,0,0];U.push(V)}}static _CalculateMinMaxKeyFrames(Z){let U=1/0,n=-1/0;return Z.forEach((function(Z){U=Math.min(U,Z.frame),n=Math.max(n,Z.frame)})),{min:U,max:n}}}function pZ(Z,U,n,l,H,V){const G={attributes:{},influence:Z.influence,name:Z.name},R=U.ui;if(!R)return B.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),G;const F=V?-1:1,y=i.k.Zero();let S=0,q=0;if(Z.hasPositions){const l=Z.getPositions(),V=R.getVerticesData(d.f.PositionKind);if(V){const Z=new Float32Array(V.length),U=[1/0,1/0,1/0],B=[-1/0,-1/0,-1/0];q=V.length/3,S=0;for(let n=S;n<q;++n){const H=i.k.ri(V,3*n);i.k.ri(l,3*n).subtractToRef(H,y),y.x*=F,U[0]=Math.min(U[0],y.x),B[0]=Math.max(B[0],y.x),U[1]=Math.min(U[1],y.y),B[1]=Math.max(B[1],y.y),U[2]=Math.min(U[2],y.z),B[2]=Math.max(B[2],y.z),Z[3*n]=y.x,Z[3*n+1]=y.y,Z[3*n+2]=y.z}const R=n.createBufferView(Z,12),d=n.createAccessor(R,"VEC3",5126,l.length/3,0,{min:U,max:B});H.push(d),G.attributes.POSITION=H.length-1}else B.e.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(Z.hasNormals){const l=Z.getNormals(),V=R.getVerticesData(d.f.NormalKind);if(V){const Z=new Float32Array(V.length);q=V.length/3,S=0;for(let n=S;n<q;++n){const U=i.k.ri(V,3*n).normalize();i.k.ri(l,3*n).normalize().subtractToRef(U,y),Z[3*n]=y.x*F,Z[3*n+1]=y.y,Z[3*n+2]=y.z}const U=n.createBufferView(Z,12),B=n.createAccessor(U,"VEC3",5126,l.length/3,0);H.push(B),G.attributes.NORMAL=H.length-1}else B.e.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(Z.hasTangents){const l=Z.getTangents(),V=R.getVerticesData(d.f.TangentKind);if(V){q=V.length/4;const Z=new Float32Array(3*q);S=0;for(let n=S;n<q;++n){const U=i.k.ri(V,4*n);g(U);const B=i.k.ri(l,3*n);g(B),B.subtractToRef(U,y),Z[3*n]=y.x*F,Z[3*n+1]=y.y,Z[3*n+2]=y.z}const U=n.createBufferView(Z,12),B=n.createAccessor(U,"VEC3",5126,q,0);H.push(B),G.attributes.TANGENT=H.length-1}else B.e.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(Z.hasColors){const l=Z.getColors(),V=R.getVerticesData(d.f.ColorKind),F=R.getVertexBuffer(d.f.ColorKind);if(V&&F){const Z=F.getSize();q=V.length/Z;const U=new Float32Array(q*Z);S=0;for(let n=S;n<q;++n)if(3===Z){const B=i.k.ri(V,n*Z);i.k.ri(l,n*Z).subtractToRef(B,y),U[3*n]=y.x,U[3*n+1]=y.y,U[3*n+2]=y.z}else if(4===Z){const B=new i.o,H=i.o.ri(V,n*Z);i.o.ri(l,n*Z).subtractToRef(H,B),U[4*n]=B.x,U[4*n+1]=B.y,U[4*n+2]=B.z,U[4*n+3]=B.w}else B.e.Warn(`Unsupported number of components for color attribute: ${Z}`);const R=n.createBufferView(U,4*Z),d=n.createAccessor(R,3===Z?"VEC3":"VEC4",5126,q,0);H.push(d),G.attributes.COLOR_0=H.length-1}else B.e.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return G}var KZ=n(11986),CZ=n(11923),DZ=n(11920),uZ=n(633);class jZ{}jZ.DEFAULT_COLOR=s.b.White(),jZ.DEFAULT_WIDTH_ATTENUATED=1,jZ.DEFAULT_WIDTH=.1;var vZ=n(2280),XZ=n(11997);class hZ{static ConvertPoints(Z,U){if(Z.length&&Array.isArray(Z)&&"number"===typeof Z[0])return[Z];if(Z.length&&Array.isArray(Z[0])&&"number"===typeof Z[0][0])return Z;if(Z.length&&!Array.isArray(Z[0])&&Z[0]instanceof i.k){const U=[];for(let n=0;n<Z.length;n++){const i=Z[n];U.push(i.x,i.y,i.z)}return[U]}if(Z.length>0&&Array.isArray(Z[0])&&Z[0].length>0&&Z[0][0]instanceof i.k){const U=[],n=Z;for(const Z of n)U.push(Z.flatMap((Z=>[Z.x,Z.y,Z.z])));return U}if(Z instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const n=[],i=3*U.floatArrayStride;for(let U=0;U<Z.length;U+=i){const B=new Array(i);for(let n=0;n<i;n++)B[n]=Z[U+n];n.push(B)}return n}return[Array.from(Z)]}if(Z.length&&Z[0]instanceof Float32Array){const U=[];for(const n of Z)U.push(Array.from(n));return U}return[]}static OmitZeroLengthPredicate(Z,U,n){const i=[];return U.Qg(Z).lengthSquared()>0&&i.push([Z,U]),n.Qg(U).lengthSquared()>0&&i.push([U,n]),Z.Qg(n).lengthSquared()>0&&i.push([n,Z]),0===i.length?null:i}static OmitDuplicatesPredicate(Z,U,n,i){const B=[];return hZ._SearchInPoints(Z,U,i)||B.push([Z,U]),hZ._SearchInPoints(U,n,i)||B.push([U,n]),hZ._SearchInPoints(n,Z,i)||B.push([n,Z]),0===B.length?null:B}static _SearchInPoints(Z,U,n){for(const H of n)for(let n=0;n<H.length;n++){var i,B,l;if(null!==(i=H[n])&&void 0!==i&&i.equals(Z))if(null!==(B=H[n+1])&&void 0!==B&&B.equals(U)||null!==(l=H[n-1])&&void 0!==l&&l.equals(U))return!0}return!1}static MeshesToLines(Z,U){const n=[];for(let B=0;B<Z.length;B++){const l=Z[B],H=l.getVerticesData(d.f.PositionKind),V=l.zi();if(H&&V)for(let Z=0,G=0;Z<V.length;Z++){const R=3*V[G++],d=3*V[G++],F=3*V[G++],y=new i.k(H[R],H[R+1],H[R+2]),S=new i.k(H[d],H[d+1],H[d+2]),q=new i.k(H[F],H[F+1],H[F+2]);if(U){const i=U(y,S,q,n,Z,R,l,B,H,V);if(i)for(const Z of i)n.push(Z)}else n.push([y,S],[S,q],[q,y])}}return n}static ToVector3Array(Z){if(Array.isArray(Z[0])){const U=[],n=Z;for(const Z of n){const n=[];for(let U=0;U<Z.length;U+=3)n.push(new i.k(Z[U],Z[U+1],Z[U+2]));U.push(n)}return U}const U=Z,n=[];for(let B=0;B<U.length;B+=3)n.push(new i.k(U[B],U[B+1],U[B+2]));return n}static ToNumberArray(Z){return Z.flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetPointsCountInfo(Z){const U=new Array(Z.length);let n=0;for(let i=Z.length;i--;)U[i]=Z[i].length/3,n+=U[i];return{total:n,counts:U}}static GetLineLength(Z){if(0===Z.length)return 0;let U;U="number"===typeof Z[0]?hZ.ToVector3Array(Z):Z;const n=i.g.ti[0];let B=0;for(let i=0;i<U.length-1;i++){const Z=U[i];B+=U[i+1].subtractToRef(Z,n).length()}return B}static GetLineLengthArray(Z){const U=new Float32Array(Z.length/3);let n=0;for(let i=0,B=Z.length/3-1;i<B;i++){let B=Z[3*i+0],l=Z[3*i+1],H=Z[3*i+2];B-=Z[3*i+3],l-=Z[3*i+4],H-=Z[3*i+5];n+=Math.sqrt(B*B+l*l+H*H),U[i+1]=n}return U}static SegmentizeSegmentByCount(Z,U,n){const B=[],l=U.Qg(Z),H=i.g.ti[0];H.si(n);const V=i.g.ti[1];l.divideToRef(H,V);let G=Z.clone();B.push(G);for(let i=0;i<n;i++)G=G.clone(),B.push(G.addInPlace(V));return B}static SegmentizeLineBySegmentLength(Z,U){const n=Z[0]instanceof i.k?hZ.GetLineSegments(Z):"number"===typeof Z[0]?hZ.GetLineSegments(hZ.ToVector3Array(Z)):Z,B=[];for(const i of n)if(i.length>U){const Z=hZ.SegmentizeSegmentByCount(i.point1,i.point2,Math.ceil(i.length/U));for(const U of Z)B.push(U)}else B.push(i.point1),B.push(i.point2);return B}static SegmentizeLineBySegmentCount(Z,U){const n="number"===typeof Z[0]?hZ.ToVector3Array(Z):Z,i=hZ.GetLineLength(n)/U;return hZ.SegmentizeLineBySegmentLength(n,i)}static GetLineSegments(Z){const U=[];for(let n=0;n<Z.length-1;n++){const i=Z[n],B=Z[n+1],l=B.Qg(i).length();U.push({point1:i,point2:B,length:l})}return U}static GetMinMaxSegmentLength(Z){const U=hZ.GetLineSegments(Z).sort((Z=>Z.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(Z,U,n){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const l=U*n;let H=0,V=0;const G=Z.length;for(let i=0;i<G;i++){if(l<=H+Z[i].length){V=i;break}H+=Z[i].length}const R=(l-H)/Z[V].length;return Z[V].point2.subtractToRef(Z[V].point1,i.g.ti[0]),i.g.ti[1]=i.g.ti[0].multiplyByFloats(R,R,R),B||i.g.ti[1].addInPlace(Z[V].point1),i.g.ti[1].clone()}static GetCircleLinePoints(Z,U){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const H=[];for(let V=0;V<=U;V++)H.push(new i.k(Math.cos(V*l)*Z,Math.sin(V*l)*B,n));return H}static GetBezierLinePoints(Z,U,n,i){return vZ.e.CreateQuadraticBezier(Z,U,n,i).getPoints().flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetArrowCap(Z,U,n,i,B){let l=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,H=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Z.clone(),Z.add(U.multiplyByFloats(n,n,n))],widths:[i,B,l,H]}}static GetPointsFromText(Z,U,n,i){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,l=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const H=[],V=(0,XZ.b)(Z,U,n,i);for(const G of V){for(const Z of G.paths){const U=[],n=Z.getPoints();for(const Z of n)U.push(Z.x,Z.y,B);H.push(U)}if(l)for(const Z of G.holes){const U=[],n=Z.getPoints();for(const Z of n)U.push(Z.x,Z.y,B);H.push(U)}}return H}static Color3toRGBAUint8(Z){const U=new Uint8Array(4*Z.length);for(let n=0,i=0;n<Z.length;n++)U[i++]=255*Z[n].r,U[i++]=255*Z[n].g,U[i++]=255*Z[n].b,U[i++]=255;return U}static CreateColorsTexture(Z,U,n,i){const B=i.getEngine().getCaps().maxTextureSize??1,l=U.length>B?B:U.length,H=Math.ceil(U.length/B);H>1&&(U=[...U,...Array(l*H-U.length).fill(U[0])]);const V=hZ.Color3toRGBAUint8(U),G=new K.c(V,l,H,q.c.TEXTUREFORMAT_RGBA,i,!1,!0,n);return G.name=Z,G}static PrepareEmptyColorsTexture(Z){if(!jZ.EmptyColorsTexture){const U=new Uint8Array(4);jZ.EmptyColorsTexture=new K.c(U,1,1,q.c.TEXTUREFORMAT_RGBA,Z,!1,!1,K.c.NEAREST_NEAREST),jZ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return jZ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Z;null===(Z=jZ.EmptyColorsTexture)||void 0===Z||Z.dispose(),jZ.EmptyColorsTexture=null}static BooleanToNumber(Z){return Z?1:0}}class PZ extends DZ.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class TZ extends CZ.e{isCompatible(Z){return!0}constructor(Z,U,n){var B;n=n||{color:jZ.DEFAULT_COLOR};const l=new PZ;l.GREASED_LINE_HAS_COLOR=!!n.color&&!n.useColors,l.GREASED_LINE_SIZE_ATTENUATION=n.sizeAttenuation??!1,l.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===n.colorDistributionType,l.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??Z.va()).useRightHandedSystem,l.GREASED_LINE_CAMERA_FACING=n.cameraFacing??!0,super(Z,TZ.GREASED_LINE_MATERIAL_NAME,200,l,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(B=n)||void 0===B?void 0:B.forceGLSL)||TZ.ForceGLSL,this._scene=U??Z.va(),this._engine=this._scene.getEngine(),this._cameraFacing=n.cameraFacing??!0,this.visibility=n.visibility??1,this.useDash=n.useDash??!1,this.dashRatio=n.dashRatio??.5,this.dashOffset=n.dashOffset??0,this.width=n.width?n.width:n.sizeAttenuation?jZ.DEFAULT_WIDTH_ATTENUATED:jZ.DEFAULT_WIDTH,this._sizeAttenuation=n.sizeAttenuation??!1,this.colorMode=n.colorMode??0,this._color=n.color??null,this.useColors=n.useColors??!1,this._colorsDistributionType=n.colorDistributionType??0,this.colorsSampling=n.colorsSampling??K.c.NEAREST_NEAREST,this._colors=n.za??null,this.dashCount=n.dashCount??1,this.resolution=n.resolution??new i.j(this._engine.getRenderWidth(),this._engine.getRenderHeight()),n.colorsTexture?this.colorsTexture=n.colorsTexture:this._colors?this.colorsTexture=hZ.CreateColorsTexture(`${Z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??jZ.DEFAULT_COLOR,hZ.PrepareEmptyColorsTexture(this._scene)),this._engine.Oi.add((()=>{hZ.DisposeEmptyColorsTexture()}))}getAttributes(Z){Z.push("grl_offsets"),Z.push("grl_widths"),Z.push("grl_colorPointers"),Z.push("grl_counters"),this._cameraFacing?(Z.push("grl_previousAndSide"),Z.push("grl_nextAndCounters")):Z.push("grl_slopes")}getSamplers(Z){Z.push("grl_colors")}getActiveTextures(Z){this.colorsTexture&&Z.push(this.colorsTexture)}getUniforms(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Z&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(Z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Z){if(this._cameraFacing){Z.cj("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Z.cj("viewProjection",this._scene.getTransformMatrix());const U=i.g.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,Z.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=i.g.Vector4[0];U.x=hZ.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,Z.updateVector4("grl_dashOptions",U);const n=i.g.Vector4[1];n.x=this.colorMode,n.y=this.visibility,n.z=this.colorsTexture?this.colorsTexture.getSize().width:0,n.w=hZ.BooleanToNumber(this.useColors),Z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",n),this._color&&Z.updateColor3("grl_singleColor",this._color);const B=this.colorsTexture??jZ.EmptyColorsTexture;Z.setTexture("grl_colors",B),Z.updateFloat2("grl_textureSize",(null===B||void 0===B?void 0:B.getSize().width)??1,(null===B||void 0===B?void 0:B.getSize().height)??1)}prepareDefines(Z,U,n){Z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Z.GREASED_LINE_USE_OFFSETS=!!n.offsets}getClassName(){return TZ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Z){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(Z,U){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(Z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Z,this._cameraFacing):function(Z,U){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(Z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Z,this._cameraFacing)}dispose(){var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}get za(){return this._colors}set za(Z){this.setColors(Z)}setColors(Z){var U;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var l;if(this._colors=Z,null!==Z&&0!==Z.length){if(!n||i)if(this.colorsTexture&&B===Z.length&&!i){const U=hZ.Color3toRGBAUint8(Z);this.colorsTexture.update(U)}else{var H;null===(H=this.colorsTexture)||void 0===H||H.dispose(),this.colorsTexture=hZ.CreateColorsTexture(`${this._material.name}-colors-texture`,Z,this.colorsSampling,this._scene)}}else null===(l=this.colorsTexture)||void 0===l||l.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Z||null!==this._color&&null===Z?(this._color=Z,U||this.markAllDefinesAsDirty()):this._color=Z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Z){this._aspect=Z.x/Z.y,this._resolution=Z}serialize(){const Z=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.za=this._colors),this._color&&(U.color=this._color),Z.greasedLineMaterialOptions=U,Z}parse(Z,U,n){var i;super.parse(Z,U,n);const B=Z.greasedLineMaterialOptions;null===(i=this.colorsTexture)||void 0===i||i.dispose(),B.color&&this.setColor(B.color,!0),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.za&&(this.za=B.za),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),this.za?this.colorsTexture=hZ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,U):hZ.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(Z){var U;const n=Z;null===(U=n.colorsTexture)||void 0===U||U.dispose(),this._colors&&(n.colorsTexture=hZ.CreateColorsTexture(`${n._material.name}-colors-texture`,this._colors,n.colorsSampling,this._scene)),n.setColor(this.color,!0),n.colorsDistributionType=this.colorsDistributionType,n.colorsSampling=this.colorsSampling,n.colorMode=this.colorMode,n.useColors=this.useColors,n.visibility=this.visibility,n.useDash=this.useDash,n.dashCount=this.dashCount,n.dashRatio=this.dashRatio,n.dashOffset=this.dashOffset,n.width=this.width,n.sizeAttenuation=this.sizeAttenuation,n.resolution=this.resolution,n.markAllDefinesAsDirty()}_isGLSL(Z){return 0===Z||this._forceGLSL}}TZ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",TZ.ForceGLSL=!1,(0,uZ.g)(`BABYLON.${TZ.GREASED_LINE_MATERIAL_NAME}`,TZ);var xZ=n(776),wZ=n(521),oZ=n(11989),NZ=n(621);class JZ extends oZ.d{constructor(Z,U,B){const l=U.getEngine(),H=l.isWebGPU&&!(B.forceGLSL||JZ.ForceGLSL),V=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&V.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const G=["position","grl_widths","grl_offsets","grl_colorPointers"];B.cameraFacing?(V.push("GREASED_LINE_CAMERA_FACING"),G.push("grl_previousAndSide","grl_nextAndCounters")):(G.push("grl_slopes"),G.push("grl_counters"));const R=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(H||R.push("world","viewProjection","view","projection"),super(Z,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:H?["Scene","Mesh"]:void 0,attributes:G,uniforms:R,samplers:H?[]:["grlColors"],defines:V,extraInitializationsAsync:async()=>{H?await Promise.all([n.e(51).then(n.bind(n,13992)),n.e(59).then(n.bind(n,13996))]):await Promise.all([n.e(54).then(n.bind(n,14003)),n.e(60).then(n.bind(n,14005))])},shaderLanguage:H?1:0}),this._color=s.b.White(),this._colorsDistributionType=0,this._colorsTexture=null,B=B||{color:jZ.DEFAULT_COLOR},this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.dashCount=B.dashCount??1,this.width=B.width?B.width:B.sizeAttenuation&&B.cameraFacing?jZ.DEFAULT_WIDTH_ATTENUATED:jZ.DEFAULT_WIDTH,this.sizeAttenuation=B.sizeAttenuation??!1,this.color=B.color??s.b.White(),this.useColors=B.useColors??!1,this.colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??K.c.NEAREST_NEAREST,this.colorMode=B.colorMode??0,this._colors=B.za??null,this._cameraFacing=B.cameraFacing??!0,this.resolution=B.resolution??new i.j(l.getRenderWidth(),l.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=hZ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??jZ.DEFAULT_COLOR,this.colorsTexture=hZ.PrepareEmptyColorsTexture(U)),H){const Z=new NZ.e;Z.setParameters(),Z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Z)}l.Oi.add((()=>{hZ.DisposeEmptyColorsTexture()}))}dispose(){var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new i.j(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(Z){this.setColors(Z)}setColors(Z){var U;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],i=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var l;if(this._colors=Z,null!==Z&&0!==Z.length){if(!n||i)if(this._colorsTexture&&B===Z.length&&!i){const U=hZ.Color3toRGBAUint8(Z);this._colorsTexture.update(U)}else{var H;null===(H=this._colorsTexture)||void 0===H||H.dispose(),this.colorsTexture=hZ.CreateColorsTexture(`${this.name}-colors-texture`,Z,this.colorsSampling,this.va())}}else null===(l=this._colorsTexture)||void 0===l||l.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Z){this._colorsTexture=Z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Z){this._width=Z,this.setFloat("grlWidth",Z)}get useColors(){return this._useColors}set useColors(Z){this._useColors=Z,this.setFloat("grlUseColors",hZ.BooleanToNumber(Z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Z){this._colorsSampling=Z}get visibility(){return this._visibility}set visibility(Z){this._visibility=Z,this.setFloat("grlVisibility",Z)}get useDash(){return this._useDash}set useDash(Z){this._useDash=Z,this.setFloat("grlUseDash",hZ.BooleanToNumber(Z))}get dashOffset(){return this._dashOffset}set dashOffset(Z){this._dashOffset=Z,this.setFloat("grlDashOffset",Z)}get dashRatio(){return this._dashRatio}set dashRatio(Z){this._dashRatio=Z,this.setFloat("grlDashRatio",Z)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.setFloat("grlSizeAttenuation",hZ.BooleanToNumber(Z))}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){Z=Z??jZ.DEFAULT_COLOR,this._color=Z,this.setColor3("grlColor",Z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Z){this._colorMode=Z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Z){this._resolution=Z,this.setVector2("grlResolution",Z),this.setFloat("grlAspect",Z.x/Z.y)}serialize(){const Z=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.za=this._colors),Z.greasedLineMaterialOptions=U,Z}parse(Z,U,n){var i;const B=Z.greasedLineMaterialOptions;null===(i=this._colorsTexture)||void 0===i||i.dispose(),B.color&&(this.color=B.color),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),B.za?this.colorsTexture=hZ.CreateColorsTexture(`${this.name}-colors-texture`,B.za,this.colorsSampling,this.va()):this.colorsTexture=hZ.PrepareEmptyColorsTexture(U),this._cameraFacing=B.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var WZ,aZ,MZ;JZ.ForceGLSL=!1,function(Z){Z[Z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Z[Z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(WZ||(WZ={})),function(Z){Z[Z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Z[Z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Z[Z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(aZ||(aZ={})),function(Z){Z[Z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Z[Z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Z[Z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Z[Z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Z[Z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(MZ||(MZ={}));class mZ extends OZ.e{constructor(Z,U,n){super(Z,U,null,null,!1,!1),this.name=Z,this._options=n,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=n.lazy??!1,this._updatable=n.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=n.colorPointers??[],this._widths=n.widths??new Array(n.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Z){let U=0;for(const i of this._points)U+=i.length;const n=U/3*2-this._widths.length;for(let i=0;i<n;i++)this._widths.push(Z)}updateLazy(){var Z,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Z=this._options.ribbonOptions)||void 0===Z?void 0:Z.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(Z,U){for(const n of Z)this._points.push(n);this._lazy||this.setPoints(this._points,U)}dispose(Z){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Z,U)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(Z){this._uvs=Z instanceof Float32Array?Z:new Float32Array(Z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Z){this.material instanceof JZ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Z||void 0===Z?void 0:Z.length)>0),this._offsets=Z,this._offsetsBuffer?this._offsetsBuffer.update(Z):this._createOffsetsBuffer(Z)}get widths(){return this._widths}set widths(Z){this._widths=Z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Z)}get colorPointers(){return this._colorPointers}set colorPointers(Z){this._colorPointers=Z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Z)}get greasedLineMaterial(){var Z,U;if(this.material&&this.material instanceof JZ)return this.material;const n=null===(Z=this.material)||void 0===Z||null===(U=Z.pluginManager)||void 0===U?void 0:U.getPlugin(TZ.GREASED_LINE_MATERIAL_NAME);return n||void 0}get points(){const Z=[];return wZ.c.DeepCopy(this._points,Z),Z}setPoints(Z,U){this._points=hZ.ConvertPoints(Z,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Z){super.serialize(Z),Z.type=this.getClassName(),Z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new xZ.b;return U.xa=this._vertexPositions,U.indices=this._indices,U.Aa=this._uvs,Z&&(U.ya=[],xZ.b.ComputeNormals(this._vertexPositions,this._indices,U.ya)),U.Ca(this,this._options.updatable),U}_createOffsetsBuffer(Z){const U=this._scene.getEngine(),n=new d.e(U,Z,this._updatable,3);this.setVerticesBuffer(n.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=n}}class AZ{constructor(Z,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Z,this.wasAddedByNoopNode=U}getIndicesAccessor(Z,U,n,i,B){var l,H,V,G;return null===(l=this._indicesAccessorMap.get(Z))||void 0===l||null===(H=l.get(U))||void 0===H||null===(V=H.get(n))||void 0===V||null===(G=V.get(i))||void 0===G?void 0:G.get(B)}setIndicesAccessor(Z,U,n,i,B,l){let H=this._indicesAccessorMap.get(Z);H||(H=new Map,this._indicesAccessorMap.set(Z,H));let V=H.get(U);V||(V=new Map,H.set(U,V));let G=V.get(n);G||(G=new Map,V.set(n,G));let R=G.get(i);R||(R=new Map,G.set(i,R)),R.set(B,l)}pushExportedNode(Z){this._exportedNodes.has(Z)||this._exportedNodes.add(Z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Z){return this._vertexBufferViewMap.get(Z)}setVertexBufferView(Z,U){this._vertexBufferViewMap.set(Z,U)}setRemappedBufferView(Z,U,n){this._remappedBufferView.set(Z,new Map),this._remappedBufferView.get(Z).set(U,n)}getRemappedBufferView(Z,U){var n;return null===(n=this._remappedBufferView.get(Z))||void 0===n?void 0:n.get(U)}getVertexAccessor(Z,U,n){var i,B;return null===(i=this._vertexAccessorMap.get(Z))||void 0===i||null===(B=i.get(U))||void 0===B?void 0:B.get(n)}setVertexAccessor(Z,U,n,i){let B=this._vertexAccessorMap.get(Z);B||(B=new Map,this._vertexAccessorMap.set(Z,B));let l=B.get(U);l||(l=new Map,B.set(U,l)),l.set(n,i)}hasVertexColorAlpha(Z){return this._vertexMapColorAlpha.get(Z)||!1}setHasVertexColorAlpha(Z,U){return this._vertexMapColorAlpha.set(Z,U)}getMesh(Z){return this._meshMap.get(Z)}setMesh(Z,U){this._meshMap.set(Z,U)}bindMorphDataToMesh(Z,U){const n=this._meshMorphTargetMap.get(Z)||[];this._meshMorphTargetMap.set(Z,n),-1===n.indexOf(U)&&n.push(U)}getMorphTargetsFromMesh(Z){return this._meshMorphTargetMap.get(Z)}}class YZ{_ApplyExtension(Z,U,n,i){if(n>=U.length)return Promise.resolve(Z);const B=i(U[n],Z);return B?B.then((async Z=>Z?await this._ApplyExtension(Z,U,n+1,i):null)):this._ApplyExtension(Z,U,n+1,i)}_ApplyExtensions(Z,U){const n=[];for(const i of YZ._ExtensionNames)n.push(this._extensions[i]);return this._ApplyExtension(Z,n,0,U)}_extensionsPreExportTextureAsync(Z,U,n){return this._ApplyExtensions(U,((U,i)=>U.preExportTextureAsync&&U.preExportTextureAsync(Z,i,n)))}_extensionsPostExportNodeAsync(Z,U,n,i,B){return this._ApplyExtensions(U,((U,l)=>U.postExportNodeAsync&&U.postExportNodeAsync(Z,l,n,i,B,this._bufferManager)))}_extensionsPostExportMaterialAsync(Z,U,n){return this._ApplyExtensions(U,((U,i)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(Z,i,n)))}_extensionsPostExportMaterialAdditionalTextures(Z,U,n){const i=[];for(const B of YZ._ExtensionNames){const l=this._extensions[B];l.postExportMaterialAdditionalTextures&&i.push(...l.postExportMaterialAdditionalTextures(Z,U,n))}return i}_extensionsPostExportTextures(Z,U,n){for(const i of YZ._ExtensionNames){const B=this._extensions[i];B.postExportTexture&&B.postExportTexture(Z,U,n)}}_extensionsPostExportMeshPrimitive(Z){for(const U of YZ._ExtensionNames){const n=this._extensions[U];n.postExportMeshPrimitive&&n.postExportMeshPrimitive(Z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Z of YZ._ExtensionNames){const U=this._extensions[Z];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Z){for(const U of YZ._ExtensionNames){const n=this._extensions[U];n.enabled&&Z(n)}}_extensionsOnExporting(){this._forEachExtensions((Z=>{var U,n,i;Z.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Z.name)&&this._glTF.extensionsUsed.push(Z.name),Z.required&&((n=this._glTF).extensionsRequired||(n.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Z.name)&&this._glTF.extensionsRequired.push(Z.name)),(i=this._glTF).extensions||(i.extensions={}),Z.onExporting&&Z.onExporting())}))}_loadExtensions(){for(const Z of YZ._ExtensionNames){const U=YZ._ExtensionFactories[Z](this);this._extensions[Z]=U}}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:c.b.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${q.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new N(this),this._extensions={},this._bufferManager=new dZ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Z)throw new Error("No scene available to export");this._babylonScene=Z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Z=>{var U;return null===Z||void 0===Z||null===(U=Z.Li)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const Z in this._extensions){this._extensions[Z].dispose()}}get options(){return this._options}static RegisterExtension(Z,U){YZ.UnregisterExtension(Z)&&B.e.Warn(`Extension with the name ${Z} already exists`),YZ._ExtensionFactories[Z]=U,YZ._ExtensionNames.push(Z)}static UnregisterExtension(Z){if(!YZ._ExtensionFactories[Z])return!1;delete YZ._ExtensionFactories[Z];const U=YZ._ExtensionNames.indexOf(Z);return-1!==U&&YZ._ExtensionNames.splice(U,1),!0}_generateJSON(Z,U,n){const i={byteLength:Z};return i.byteLength&&(this._glTF.buffers=[i]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Rk=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(i.uri=U+".bin"),n?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Z){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(U.byteLength,Z,!0),i=new Blob([U],{type:"application/octet-stream"}),B=Z+".gltf",l=Z+".bin",H=new R;if(H.files[B]=n,H.files[l]=i,this._imageData)for(const V in this._imageData)H.files[V]=new Blob([this._imageData[V].data],{type:this._imageData[V].mimeType});return H}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Z){const U=Z%4;return 0===U?U:4-U}async generateGLBAsync(Z){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(U.byteLength),i=Z+".glb";let B,l=n.length;if("undefined"!==typeof TextEncoder){B=(new TextEncoder).encode(n),l=B.length}const H=this._getPadding(l),V=this._getPadding(U.byteLength),G=28+l+H+U.byteLength+V,d=new GZ(G);if(d.writeUInt32(1179937895),d.writeUInt32(2),d.writeUInt32(G),d.writeUInt32(l+H),d.writeUInt32(1313821514),B)d.writeTypedArray(B);else{const Z="_".charCodeAt(0);for(let U=0;U<l;++U){const i=n.charCodeAt(U);i!=n.codePointAt(U)?d.writeUInt8(Z):d.writeUInt8(i)}}for(let R=0;R<H;++R)d.writeUInt8(32);d.writeUInt32(U.byteLength+V),d.writeUInt32(5130562),d.writeTypedArray(U);for(let R=0;R<V;++R)d.writeUInt8(0);const F=new R;return F.files[i]=new Blob([d.getOutputData()],{type:"application/octet-stream"}),F}_setNodeTransformation(Z,U,n){if(U.getPivotPoint().equalsWithEpsilon(m,M.e)||B.e.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(m,M.e)){const B=i.g.ti[0].p(U.position);n&&b(B),Z.translation=B.Ei()}U.mi.equalsWithEpsilon(Y,M.e)||(Z.scale=U.mi.Ei());const l=U.rotationQuaternion||i.d.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);l.equalsWithEpsilon(A,M.e)||(n&&r(l),Z.rotation=l.normalize().Ei())}_setCameraTransformation(Z,U,n){if(!U.position.equalsWithEpsilon(m,M.e)){const B=i.g.ti[0].p(U.position);n&&b(B),Z.translation=B.Ei()}const B=U.rotationQuaternion||i.d.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);n&&r(B),this._babylonScene.useRightHandedSystem||f(B),B.equalsWithEpsilon(A,M.e)||(Z.rotation=B.Ei())}_listAvailableCameras(){for(const Z of this._babylonScene.cameras){const U={type:Z.mode===yZ.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Z.name&&(U.name=Z.name),"perspective"===U.type)U.perspective={aspectRatio:Z.getEngine().getAspectRatio(Z),yfov:Z.fovMode===yZ.d.FOVMODE_VERTICAL_FIXED?Z.fov:Z.fov*Z.getEngine().getAspectRatio(Z),znear:Z.Ai,zfar:Z.maxZ};else if("orthographic"===U.type){const n=Z.orthoLeft&&Z.orthoRight?.5*(Z.orthoRight-Z.orthoLeft):.5*Z.getEngine().getRenderWidth(),i=Z.orthoBottom&&Z.orthoTop?.5*(Z.orthoTop-Z.orthoBottom):.5*Z.getEngine().getRenderHeight();U.orthographic={xmag:n,ymag:i,znear:Z.Ai,zfar:Z.maxZ}}this._camerasMap.set(Z,U)}}_exportAndAssignCameras(){const Z=Array.from(this._camerasMap.values());for(const U of Z){const Z=this._nodesCameraMap.get(U);if(void 0!==Z){this._cameras.push(U);for(const U of Z)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(Z,U)}}_exportAndAssignSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const U=this._skinMap.get(Z);if(void 0==U)continue;const n={},i=[];let l=-1;for(let B=0;B<Z.bones.length;++B){const U=Z.bones[B],i=U.getIndex()??B;-1!==i&&(n[i]=U,i>l&&(l=i))}for(let Z=0;Z<=l;++Z){const l=n[Z];i.push(l.getAbsoluteInverseBindMatrix());const H=l.getTransformNode();if(null!==H){const Z=this._nodeMap.get(H);H&&null!==Z&&void 0!==Z?U.joints.push(Z):B.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else B.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const H=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==H){const Z=64*i.length,n=new Float32Array(Z/4);i.forEach(((Z,U)=>{n.set(Z.m,16*U)}));const B=this._bufferManager.createBufferView(n);this._accessors.push(this._bufferManager.createAccessor(B,"MAT4",5126,i.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of H)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const Z={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(Z.extras=U)}const U=new Array,n=new Array,i=new Array;for(const V of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&HZ(V,this._babylonScene.useRightHandedSystem)?i.push(...V.getChildren()):this._babylonScene.useRightHandedSystem?U.push(V):n.push(V);this._listAvailableCameras(),this._listAvailableSkeletons();const B=new AZ(!0,!1);Z.nodes.push(...await this._exportNodesAsync(n,B));const l=new AZ(!1,!1);Z.nodes.push(...await this._exportNodesAsync(U,l));const H=new AZ(!1,!0);Z.nodes.push(...await this._exportNodesAsync(i,H)),Z.nodes.length&&this._scenes.push(Z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&tZ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Z){let U=this._shouldExportNodeMap.get(Z);return void 0===U&&(U=this._options.shouldExportNode(Z),this._shouldExportNodeMap.set(Z,U)),U}async _exportNodesAsync(Z,U){const n=new Array;this._exportBuffers(Z,U);for(const i of Z)await this._exportNodeAsync(i,n,U);return n}_collectBuffers(Z,U,n,i,B){if(this._shouldExportNode(Z)&&Z instanceof y.c&&Z.ui){const l=Z.ui.getVertexBuffers();if(l)for(const i in l){if(!I(i))continue;const H=l[i];B.setHasVertexColorAlpha(H,Z.hasVertexAlpha);const V=H._buffer,G=U.get(V)||[];U.set(V,G),-1===G.indexOf(H)&&G.push(H);const R=n.get(H)||[];n.set(H,R),-1===R.indexOf(Z)&&R.push(Z)}const H=Z.morphTargetManager;if(H)for(let U=0;U<H.numTargets;U++){const n=H.getTarget(U),B=i.get(n)||[];i.set(n,B),-1===B.indexOf(Z)&&B.push(Z)}}for(const l of Z.getChildren())this._collectBuffers(l,U,n,i,B)}_exportBuffers(Z,U){const n=new Map,i=new Map,B=new Map;for(const V of Z)this._collectBuffers(V,n,i,B,U);const l=Array.from(n.keys());for(const V of l){const Z=V.getData();if(!Z)throw new Error("Buffer data is not available");const B=n.get(V);if(!B)continue;const l=B[0].byteStride;if(B.some((Z=>Z.byteStride!==l)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const H=nZ(Z).slice();for(const U of B){const Z=i.get(U),{byteOffset:n,byteStride:B,componentCount:l,type:V,count:G,normalized:R,kind:F}=L(U,Z);switch(F){case d.f.NormalKind:case d.f.TangentKind:(0,J.j)(H,n,B,l,V,G,R,(Z=>{const U=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]);if(U>0){const n=1/U;Z[0]*=n,Z[1]*=n,Z[2]*=n}}));break;case d.f.ColorKind:{const U=Z.filter((Z=>Z.material instanceof cZ.d||null==Z.material)).length;if(0==U)break;if(U!=Z.length){W.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}V==d.f.UNSIGNED_BYTE&&W.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const i=new s.b,F=new s.d,y=this._babylonScene.getEngine().useExactSrgbConversions;(0,J.j)(H,n,B,l,V,G,R,(Z=>{3===Z.length?(i.Vi(Z,0),i.toLinearSpaceToRef(i,y),i.toArray(Z,0)):(F.Vi(Z,0),F.toLinearSpaceToRef(F,y),F.toArray(Z,0))}))}}}if(U.convertToRightHanded){for(const Z of B){const U=i.get(Z),{byteOffset:n,byteStride:B,componentCount:l,type:V,count:G,normalized:R,kind:F}=L(Z,U);switch(F){case d.f.PositionKind:case d.f.NormalKind:case d.f.TangentKind:(0,J.j)(H,n,B,l,V,G,R,(Z=>{Z[0]=-Z[0]}))}}U.convertedToRightHandedBuffers.set(V,H)}const G=this._bufferManager.createBufferView(H,l);U.setVertexBufferView(V,G);const R=new Map;for(const U of B){const Z=i.get(U),{kind:n,totalVertices:B}=L(U,Z);switch(n){case d.f.MatricesIndicesKind:case d.f.MatricesIndicesExtraKind:if(U.type==d.f.FLOAT){const Z=U.getFloatData(B);null!==Z&&R.set(U,Z)}}}0!==R.size&&W.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const F=Array.from(R.keys());for(const n of F){const Z=R.get(n);if(!Z)continue;const i=Z.some((Z=>Z>=256)),B=new(i?Uint16Array:Uint8Array)(Z.length);for(let U=0;U<Z.length;U++)B[U]=Z[U];const l=this._bufferManager.createBufferView(B,4*(i?2:1));U.setRemappedBufferView(V,n,l)}}const H=Array.from(B.keys());for(const V of H){const Z=B.get(V);if(!Z)continue;const n=pZ(V,Z[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const i of Z)U.bindMorphDataToMesh(i,n)}}async _exportNodeAsync(Z,U,n){let i=this._nodeMap.get(Z);if(void 0!==i)return void(U.includes(i)||U.push(i));const B=await this._createNodeAsync(Z,n);if(B){i=this._nodes.length,this._nodes.push(B),this._nodeMap.set(Z,i),n.pushExportedNode(Z),U.push(i);const l={name:"runtime animations",channels:[],samplers:[]},H=[];this._babylonScene.animationGroups.length||(tZ._CreateMorphTargetAnimationFromMorphTargetAnimations(Z,l,H,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation),Z.animations.length&&tZ._CreateNodeAnimationFromNodeAnimations(Z,l,H,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation)),l.channels.length&&l.samplers.length&&this._animations.push(l),H.forEach((Z=>{Z.channels.length&&Z.samplers.length&&this._animations.push(Z)}))}const l=B?[]:U;for(const H of Z.getChildren())await this._exportNodeAsync(H,l,n);B&&l.length&&(B.children=l)}async _createNodeAsync(Z,U){if(!this._shouldExportNode(Z))return null;const n={};if(Z.name&&(n.name=Z.name),Z.metadata){const U=this._options.metadataSelector(Z.metadata);U&&(n.extras=U)}if(Z instanceof F.c&&(this._setNodeTransformation(n,Z,U.convertToRightHanded),Z instanceof y.c)){const B=Z instanceof S.d?Z.sourceMesh:Z;if(B.Bi&&B.Bi.length>0&&(n.mesh=await this._exportMeshAsync(B,U)),Z.skeleton){const U=this._skinMap.get(Z.skeleton);var i;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(i=this._nodesSkinMap.get(U))||void 0===i||i.push(n)}}if(Z instanceof a.e){const i=this._camerasMap.get(Z);if(i){var B;void 0===this._nodesCameraMap.get(i)&&this._nodesCameraMap.set(i,[]),this._setCameraTransformation(n,Z,U.convertToRightHanded);const H=Z.parent;if(null!==H&&UZ(Z,H)){const Z=this._nodeMap.get(H);if(void 0!==Z){var l;const U=this._nodes[Z];return ZZ(n,U),null===(l=this._nodesCameraMap.get(i))||void 0===l||l.push(U),null}}null===(B=this._nodesCameraMap.get(i))||void 0===B||B.push(n)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",n,Z,this._nodeMap,U.convertToRightHanded)?n:(W.c.Warn(`Not exporting node ${Z.name}`),null)}_exportIndices(Z,U,n,i,B,H,V,G,R){let d=Z;R.mode=e(H);const F=V!==l.c.CounterClockWiseSideOrientation,y=!G.wasAddedByNoopNode&&F,S=function(Z){switch(Z){case l.c.TriangleFillMode:case l.c.TriangleStripDrawMode:case l.c.TriangleFanDrawMode:return!0}return!1}(H)&&y;if(S){if(H===l.c.TriangleStripDrawMode||H===l.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");R.mode=e(H);const V=U?new Uint32Array(i):new Uint16Array(i);if(Z)for(let U=0;U+2<i;U+=3)V[U]=Z[n+U]+B,V[U+1]=Z[n+U+2]+B,V[U+2]=Z[n+U+1]+B;else for(let Z=0;Z+2<i;Z+=3)V[Z]=Z,V[Z+1]=Z+2,V[Z+2]=Z+1;d=V}else if(Z&&0!==B){const l=U?new Uint32Array(i):new Uint16Array(i);for(let U=0;U<i;U++)l[U]=Z[n+U]+B;d=l}if(d){let l=G.getIndicesAccessor(Z,n,i,B,S);if(void 0===l){const H=function(Z,U,n,i){if(Z instanceof Uint16Array||Z instanceof Uint32Array)return Z;if(Z instanceof Int32Array)return new Uint32Array(Z.buffer,Z.byteOffset,Z.length);const B=Z.slice(U,U+n);return i?new Uint32Array(B):new Uint16Array(B)}(d,0,i,U),V=this._bufferManager.createBufferView(H),R=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(V,"SCALAR",R,i,0)),l=this._accessors.length-1,G.setIndicesAccessor(Z,n,i,B,S,l)}R.indices=l}}_exportVertexBuffer(Z,U,n,i,B,l){const H=Z.getKind();if(!I(H))return;if(H.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let V=B.getVertexAccessor(Z,n,i);if(void 0===V){const U=B.convertedToRightHandedBuffers.get(Z._buffer)||Z._buffer.getData(),l=H===d.f.PositionKind?function(Z,U,n,i){const{byteOffset:B,byteStride:l,type:H,normalized:V}=U,G=U.getSize(),R=new Array(G).fill(1/0),d=new Array(G).fill(-1/0);return(0,J.j)(Z,B+n*l,l,G,H,i*G,V,(Z=>{for(let U=0;U<G;U++)R[U]=Math.min(R[U],Z[U]),d[U]=Math.max(d[U],Z[U])})),{min:R,max:d}}(U,Z,n,i):void 0,G=(H===d.f.MatricesIndicesKind||H===d.f.MatricesIndicesExtraKind)&&Z.type===d.f.FLOAT,R=G?d.f.UNSIGNED_BYTE:Z.type,F=G?void 0:Z.normalized,y=G?B.getRemappedBufferView(Z._buffer,Z):B.getVertexBufferView(Z._buffer),S=Z.byteOffset+n*Z.byteStride;this._accessors.push(this._bufferManager.createAccessor(y,function(Z,U){if(Z==d.f.ColorKind)return U?"VEC4":"VEC3";switch(Z){case d.f.PositionKind:case d.f.NormalKind:return"VEC3";case d.f.TangentKind:case d.f.MatricesIndicesKind:case d.f.MatricesIndicesExtraKind:case d.f.MatricesWeightsKind:case d.f.MatricesWeightsExtraKind:return"VEC4";case d.f.UVKind:case d.f.UV2Kind:case d.f.UV3Kind:case d.f.UV4Kind:case d.f.UV5Kind:case d.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Z}`)}(H,B.hasVertexColorAlpha(Z)),R,i,S,l,F)),V=this._accessors.length-1,B.setVertexAccessor(Z,n,i,V)}l.attributes[function(Z){switch(Z){case d.f.PositionKind:return"POSITION";case d.f.NormalKind:return"NORMAL";case d.f.TangentKind:return"TANGENT";case d.f.ColorKind:return"COLOR_0";case d.f.UVKind:return"TEXCOORD_0";case d.f.UV2Kind:return"TEXCOORD_1";case d.f.UV3Kind:return"TEXCOORD_2";case d.f.UV4Kind:return"TEXCOORD_3";case d.f.UV5Kind:return"TEXCOORD_4";case d.f.UV6Kind:return"TEXCOORD_5";case d.f.MatricesIndicesKind:return"JOINTS_0";case d.f.MatricesIndicesExtraKind:return"JOINTS_1";case d.f.MatricesWeightsKind:return"WEIGHTS_0";case d.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Z}`)}(H)]=V}async _exportMaterialAsync(Z,U,n,i){let B=this._materialMap.get(Z);if(void 0===B){const i=U&&Object.keys(U).some((Z=>Z.startsWith("uv")));if((Z=Z instanceof SZ.d?Z.Gi[n.materialIndex]:Z)instanceof qZ.c)B=await this._materialExporter.exportPBRMaterialAsync(Z,"image/png",i);else{if(!(Z instanceof cZ.d))return void W.c.Warn(`Unsupported material '${Z.name}' with type ${Z.getClassName()}`);B=await this._materialExporter.exportStandardMaterialAsync(Z,"image/png",i)}this._materialMap.set(Z,B)}i.material=B}async _exportMeshAsync(Z,U){var n;let i=U.getMesh(Z);if(void 0!==i)return i;const B={primitives:[]};i=this._meshes.length,this._meshes.push(B),U.setMesh(Z,i);const H=Z.isUnIndexed?null:Z.zi(),V=null===(n=Z.ui)||void 0===n?void 0:n.getVertexBuffers(),G=U.getMorphTargetsFromMesh(Z),R=Z instanceof KZ.b,d=Z instanceof mZ,F=Z.Bi;if(V&&F&&F.length>0)for(const q of F){const n={attributes:{}},i=q.Ha()||this._babylonScene.defaultMaterial;if(d){var y,S;const U={name:i.name},B=Z,l=s.b.White(),H=(null===(y=B.material)||void 0===y?void 0:y.alpha)??1,V=(null===(S=B.greasedLineMaterial)||void 0===S?void 0:S.color)??l;(!V.equalsWithEpsilon(l,M.e)||H<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...V.Ei(),H]}),this._materials.push(U),n.material=this._materials.length-1}else if(R){const U={name:i.name},B=Z;(!B.color.equalsWithEpsilon(s.b.White(),M.e)||B.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...B.color.Ei(),B.alpha]}),this._materials.push(U),n.material=this._materials.length-1}else await this._exportMaterialAsync(i,V,q,n);const F=R||d?l.c.LineListDrawMode:Z.overrideRenderingFillMode??i.fillMode,c=i._getEffectiveOrientation(Z);this._exportIndices(H,H?(0,J.e)(H,q.indexCount,q.indexStart,q.verticesStart):q.verticesCount>65535,H?q.indexStart:q.verticesStart,H?q.indexCount:q.verticesCount,-q.verticesStart,F,c,U,n);for(const Z of Object.values(V))this._exportVertexBuffer(Z,i,q.verticesStart,q.verticesCount,U,n);if(G){n.targets=[];for(const Z of G)n.targets.push(Z.attributes)}B.primitives.push(n),this._extensionsPostExportMeshPrimitive(n)}if(G){B.weights=[],B.extras||(B.extras={}),B.extras.targetNames=[];for(const Z of G)B.weights.push(Z.influence),B.extras.targetNames.push(Z.name)}return i}}YZ._ExtensionNames=new Array,YZ._ExtensionFactories={};class QZ{static async GLTFAsync(Z,U,n){n&&n.exportWithoutWaitingForScene||await Z.whenReadyAsync();const i=new YZ(Z,n),B=await i.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return i.dispose(),B}static async GLBAsync(Z,U,n){n&&n.exportWithoutWaitingForScene||await Z.whenReadyAsync();const i=new YZ(Z,n),B=await i.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return i.dispose(),B}}n(484);const LZ="EXT_mesh_gpu_instancing";class kZ{constructor(Z){this.name=LZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Z,U,n,B,l,H){return await new Promise((Z=>{if(U&&n instanceof OZ.e&&n.hasThinInstances&&this._exporter){this._wasUsed=!0;const Z=i.k.Zero(),B=i.d.Identity(),V=i.k.One(),G=n.thinInstanceGetWorldMatrices(),R=i.g.ti[2],d=i.g.Quaternion[1],F=i.g.ti[3];let y=!1,S=!1,q=!1;const c=new Float32Array(3*n.oi),s=new Float32Array(4*n.oi),z=new Float32Array(3*n.oi);let O=0;for(const U of G)U.decompose(F,d,R),l&&(b(R),r(d)),c.set(R.Ei(),3*O),s.set(d.normalize().Ei(),4*O),z.set(F.Ei(),3*O),y=y||!R.equalsWithEpsilon(Z),S=S||!d.equalsWithEpsilon(B),q=q||!F.equalsWithEpsilon(V),O++;const E={attributes:{}};y&&(E.attributes.TRANSLATION=this._buildAccessor(c,"VEC3",n.oi,H)),S&&(E.attributes.ROTATION=this._buildAccessor(s,"VEC4",n.oi,H)),q&&(E.attributes.SCALE=this._buildAccessor(z,"VEC3",n.oi,H)),U.extensions=U.extensions||{},U.extensions[LZ]=E}Z(U)}))}_buildAccessor(Z,U,n,i){const B=i.createBufferView(Z),l=i.createAccessor(B,U,5126,n);return this._exporter._accessors.push(l),this._exporter._accessors.length-1}}YZ.RegisterExtension(LZ,(Z=>new kZ(Z)));var IZ=n(12013),eZ=n(12022),gZ=n(12029),bZ=n(12038);function rZ(Z){return Z===gZ.d.PositionKind?"POSITION":Z===gZ.d.NormalKind?"NORMAL":Z===gZ.d.ColorKind?"COLOR":Z.startsWith(gZ.d.UVKind)?"TEX_COORD":"GENERIC"}const fZ={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class ZU extends IZ.e{static get DefaultAvailable(){return(0,IZ.k)(ZU.DefaultConfiguration)}static get Default(){return ZU._Default??(ZU._Default=new ZU),ZU._Default}static ResetDefault(Z){ZU._Default&&(Z||ZU._Default.dispose(),ZU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Z,U){return{module:await(U||DracoEncoderModule)({wasmBinary:Z})}}_getWorkerContent(){return`${eZ.f}(${eZ.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:ZU.DefaultConfiguration)}async _encodeAsync(Z,U,n){const i=n?(0,bZ.e)(fZ,n):fZ;if(this._workerPoolPromise){const n=await this._workerPoolPromise;return await new Promise(((B,l)=>{n.push(((n,H)=>{const V=Z=>{n.removeEventListener("error",V),n.removeEventListener("message",G),l(Z),H()},G=Z=>{"encodeMeshDone"===Z.data.id&&(n.removeEventListener("error",V),n.removeEventListener("message",G),B(Z.data.encodedMeshData),H())};n.addEventListener("error",V),n.addEventListener("message",G);const R=[];for(const U of Z)R.push(U.data.buffer);U&&R.push(U.buffer),n.postMessage({id:"encodeMesh",attributes:Z,indices:U,options:i},R)}))}))}if(this._modulePromise){const n=await this._modulePromise;return(0,eZ.f)(n.module,Z,U,i)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Z,U){if(0==Z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Z instanceof OZ.e&&Z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(W.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const n=function(Z){let U=Z.zi(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,J.e)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(Z),i=function(Z,U){const n=[];for(const i of Z.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(i)){if(i===gZ.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const B=Z.getVertexBuffer(i),l=B.getSize(),H=(0,J.r)(B.getData(),l,B.type,B.byteOffset,B.byteStride,B.normalized,Z.getTotalVertices(),!0);n.push({kind:i,dracoName:rZ(i),size:l,data:H})}return n}(Z,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(i,n,U)}}ZU.DefaultConfiguration={wasmUrl:`${B.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${B.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${B.e._DefaultCdnUrl}/draco_encoder.js`},ZU._Default=null;const UU="KHR_draco_mesh_compression";class nU{get wasUsed(){return this._wasUsed}constructor(Z){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Z.options.meshCompressionMethod&&ZU.DefaultAvailable}dispose(){}postExportMeshPrimitive(Z,U,n){if(!this.enabled)return;if(4!==Z.mode&&5!==Z.mode)return void W.c.Warn("Cannot compress primitive with mode "+Z.mode+".");const i=[],B=[];let l=null;if(void 0!==Z.indices){const H=n[Z.indices],V=U.getBufferView(H);l=U.getData(V).slice(),i.push(V),B.push(H)}const H=[];for(const[d,F]of Object.entries(Z.attributes)){const Z=n[F],l=U.getBufferView(Z),G=k(Z.type),R=(0,J.r)(U.getData(l),G,Z.componentType,Z.byteOffset||0,l.byteStride||(0,J.m)(Z.componentType)*G,Z.normalized||!1,Z.count,!0);H.push({kind:d,dracoName:(V=d,"POSITION"===V?"POSITION":"NORMAL"===V?"NORMAL":V.startsWith("COLOR")?"COLOR":V.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:k(Z.type),data:R}),i.push(l),B.push(Z)}var V;const G={method:Z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},R=ZU.Default._encodeAsync(H,l,G).then((n=>{if(!n)return void W.c.Error("Draco encoding failed for primitive.");const l={bufferView:-1,attributes:n.attributeIds},H=U.createBufferView(n.data);U.setBufferView(l,H);for(const Z of i)this._bufferViewsUsed.add(Z);for(const Z of B)this._accessorsUsed.add(Z);Z.extensions||(Z.extensions={}),Z.extensions[UU]=l})).catch((Z=>{W.c.Error("Draco encoding failed for primitive: "+Z)}));this._encodePromises.push(R),this._wasUsed=!0}async preGenerateBinaryAsync(Z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{Z.getPropertiesWithBufferView(U).every((Z=>this._accessorsUsed.has(Z)))&&Z.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}YZ.RegisterExtension(UU,(Z=>new nU(Z)));var iU=n(12043);const BU="KHR_lights_punctual",lU={name:"",color:[1,1,1],bb:1,range:Number.MAX_VALUE},HU={innerConeAngle:0,outerConeAngle:Math.PI/4},VU=i.k.Backward();class GU{constructor(Z){this.name=BU,this.enabled=!0,this.required=!1,this._exporter=Z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[BU]=this._lights}async postExportNodeAsync(Z,U,n,B,l){return await new Promise((H=>{if(!(n instanceof EZ.d))return void H(U);const V=n.getTypeID()==EZ.d.LIGHTTYPEID_POINTLIGHT?"point":n.getTypeID()==EZ.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":n.getTypeID()==EZ.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!V||!(n instanceof iU.d))return W.c.Warn(`${Z}: Light ${n.name} is not supported in ${BU}`),void H(U);if(n.falloffType!==EZ.d.FALLOFF_GLTF&&W.c.Warn(`${Z}: Light falloff for ${n.name} does not match the ${BU} specification!`),!n.position.equalsToFloats(0,0,0)){const Z=i.g.ti[0].p(n.position);l&&b(Z),U.translation=Z.Ei()}if("point"!==V){const Z=n.direction.normalizeToRef(i.g.ti[0]);l&&b(Z);const B=i.d.FromUnitVectorsToRef(VU,Z,i.g.Quaternion[0]);i.d.IsIdentity(B)||(U.rotation=B.Ei())}const G={type:V,name:n.name,color:n.cb.Ei(),bb:n.bb,range:n.range};if(iZ(G,lU),"spot"===V){const Z=n;G.spot={innerConeAngle:Z.innerAngle/2,outerConeAngle:Z.angle/2},iZ(G.spot,HU)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(G);const R={ab:this._lights.lights.length-1},d=n.parent;if(d&&UZ(n,d)){const Z=B.get(d);if(Z){const n=this._exporter._nodes[Z];return ZZ(U,n),n.extensions||(n.extensions={}),n.extensions[BU]=R,void H(null)}}U.extensions||(U.extensions={}),U.extensions[BU]=R,H(U)}))}}YZ.RegisterExtension(BU,(Z=>new GU(Z)));var RU=n(11918);const dU="KHR_materials_anisotropy";class FU{constructor(Z){this.name=dU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof RU.e&&n.anisotropy.isEnabled&&!n.anisotropy.legacy?(n.anisotropy.texture&&i.push(n.anisotropy.texture),i):[]}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof RU.e){if(!n.anisotropy.isEnabled||n.anisotropy.legacy)return void Z(U);this._wasUsed=!0,U.extensions=U.extensions||{};const i=this._exporter._materialExporter.getTextureInfo(n.anisotropy.texture),B={anisotropyStrength:n.anisotropy.bb,anisotropyRotation:n.anisotropy.angle,anisotropyTexture:i??void 0};null!==B.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(n),U.extensions[dU]=B}Z(U)}))}}YZ.RegisterExtension(dU,(Z=>new FU(Z)));const yU="KHR_materials_clearcoat";class SU{constructor(Z){this.name=yU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof RU.e&&n.clearCoat.isEnabled?(n.clearCoat.texture&&i.push(n.clearCoat.texture),!n.clearCoat.useRoughnessFromMainTexture&&n.clearCoat.textureRoughness&&i.push(n.clearCoat.textureRoughness),n.clearCoat.bumpTexture&&i.push(n.clearCoat.bumpTexture),i):[]}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof RU.e){if(!n.clearCoat.isEnabled)return void Z(U);this._wasUsed=!0,U.extensions=U.extensions||{};const i=this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture);let l;l=n.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(n.clearCoat.textureRoughness),n.clearCoat.isTintEnabled&&B.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${n.name}`),n.clearCoat.remapF0OnInterfaceChange&&B.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${n.name}`);const H=this._exporter._materialExporter.getTextureInfo(n.clearCoat.bumpTexture),V={clearcoatFactor:n.clearCoat.bb,clearcoatTexture:i??void 0,clearcoatRoughnessFactor:n.clearCoat.roughness,clearcoatRoughnessTexture:l??void 0,clearcoatNormalTexture:H??void 0};null===V.clearcoatTexture&&null===V.clearcoatRoughnessTexture&&null===V.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),U.extensions[yU]=V}Z(U)}))}}YZ.RegisterExtension(yU,(Z=>new SU(Z)));const qU="KHR_materials_diffuse_transmission";function cU(Z,U){const n=U.subSurface;let i=null;return n.translucencyIntensityTexture?i=n.translucencyIntensityTexture:n.thicknessTexture&&n.useMaskFromThicknessTexture&&(i=n.thicknessTexture),i&&!n.useGltfStyleTextures?(W.c.Warn(`${Z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):i}class sU{constructor(Z){this.name=qU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];if(n instanceof qZ.c&&this._isExtensionEnabled(n)){const U=cU(Z,n);return U&&i.push(U),n.subSurface.translucencyColorTexture&&i.push(n.subSurface.translucencyColorTexture),i}return i}_isExtensionEnabled(Z){if(Z.unlit)return!1;const U=Z.subSurface;return!!U.isTranslucencyEnabled&&(!Z.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(Z,U,n){return new Promise((i=>{if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const i=n.subSurface,B=cU(Z,n),l=0==i.translucencyIntensity?void 0:i.translucencyIntensity,H=this._exporter._materialExporter.getTextureInfo(B)??void 0,V=!i.translucencyColor||i.translucencyColor.equalsFloats(1,1,1)?void 0:i.translucencyColor.Ei(),G=this._exporter._materialExporter.getTextureInfo(i.translucencyColorTexture)??void 0,R={diffuseTransmissionFactor:l,diffuseTransmissionTexture:H,diffuseTransmissionColorFactor:V,diffuseTransmissionColorTexture:G};(H||G)&&this._exporter._materialNeedsUVsSet.add(n),U.extensions=U.extensions||{},U.extensions[qU]=R}i(U)}))}}YZ.RegisterExtension(qU,(Z=>new sU(Z)));const zU="KHR_materials_dispersion";class OU{constructor(){this.name=zU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){if(Z.unlit)return!1;const U=Z.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const Z={dispersion:n.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[zU]=Z}Z(U)}))}}YZ.RegisterExtension(zU,(()=>new OU));const EU="KHR_materials_emissive_strength";class tU{constructor(){this.name=EU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Z,U,n){return await new Promise((Z=>{if(!(n instanceof qZ.c))return Z(U);const i=n.emissiveColor.Ei(),B=Math.max(...i);if(B>1){this._wasUsed=!0,U.extensions||(U.extensions={});const Z={emissiveStrength:B},i=n.emissiveColor.scale(1/Z.emissiveStrength);U.emissiveFactor=i.Ei(),U.extensions[EU]=Z}return Z(U)}))}}YZ.RegisterExtension(EU,(Z=>new tU));const pU="KHR_materials_ior";class KU{constructor(){this.name=pU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.indexOfRefraction&&1.5!=Z.indexOfRefraction)}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const Z={ior:n.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[pU]=Z}Z(U)}))}}YZ.RegisterExtension(pU,(Z=>new KU));const CU="KHR_materials_iridescence";class DU{constructor(Z){this.name=CU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof RU.e&&n.iridescence.isEnabled?(n.iridescence.texture&&i.push(n.iridescence.texture),n.iridescence.thicknessTexture&&n.iridescence.thicknessTexture!==n.iridescence.texture&&i.push(n.iridescence.thicknessTexture),i):[]}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof RU.e){if(!n.iridescence.isEnabled)return void Z(U);this._wasUsed=!0,U.extensions=U.extensions||{};const i=this._exporter._materialExporter.getTextureInfo(n.iridescence.texture),B=this._exporter._materialExporter.getTextureInfo(n.iridescence.thicknessTexture),l={iridescenceFactor:n.iridescence.bb,iridescenceIor:n.iridescence.indexOfRefraction,iridescenceThicknessMinimum:n.iridescence.minimumThickness,iridescenceThicknessMaximum:n.iridescence.maximumThickness,iridescenceTexture:i??void 0,iridescenceThicknessTexture:B??void 0};null===l.iridescenceTexture&&null===l.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(n),U.extensions[CU]=l}Z(U)}))}}YZ.RegisterExtension(CU,(Z=>new DU(Z)));const uU="KHR_materials_sheen";class jU{constructor(Z){this.name=uU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){return n instanceof qZ.c&&n.sheen.isEnabled&&n.sheen.texture?[n.sheen.texture]:[]}async postExportMaterialAsync(Z,U,n){return await new Promise((Z=>{if(n instanceof qZ.c){if(!n.sheen.isEnabled)return void Z(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const i={sheenColorFactor:n.sheen.color.Ei(),sheenRoughnessFactor:n.sheen.roughness??0};null===i.sheenColorTexture&&null===i.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),n.sheen.texture&&(i.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),n.sheen.textureRoughness&&!n.sheen.useRoughnessFromMainTexture?i.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.textureRoughness)??void 0:n.sheen.texture&&n.sheen.useRoughnessFromMainTexture&&(i.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),U.extensions[uU]=i}Z(U)}))}}YZ.RegisterExtension(uU,(Z=>new jU(Z)));const vU="KHR_materials_specular";class XU{constructor(Z){this.name=vU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof qZ.c&&this._isExtensionEnabled(n)?(n.metallicReflectanceTexture&&i.push(n.metallicReflectanceTexture),n.reflectanceTexture&&i.push(n.reflectanceTexture),i):i}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.metallicF0Factor&&1!=Z.metallicF0Factor||void 0!=Z.metallicReflectanceColor&&!Z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.metallicReflectanceTexture||null!=Z.reflectanceTexture}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0,U.extensions=U.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(n.metallicReflectanceTexture)??void 0,i=this._exporter._materialExporter.getTextureInfo(n.reflectanceTexture)??void 0,B={specularFactor:1==n.metallicF0Factor?void 0:n.metallicF0Factor,specularTexture:Z,specularColorFactor:n.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:n.metallicReflectanceColor.Ei(),specularColorTexture:i};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),U.extensions[vU]=B}Z(U)}))}}YZ.RegisterExtension(vU,(Z=>new XU(Z)));const hU="KHR_materials_transmission";class PU{constructor(Z){this.name=hU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof qZ.c&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&i.push(n.subSurface.thicknessTexture),i):i}_isExtensionEnabled(Z){if(Z.unlit)return!1;const U=Z.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(Z)}_hasTexturesExtension(Z){return null!=Z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Z,U,n){if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const i=n.subSurface,B={transmissionFactor:0===i.refractionIntensity?void 0:i.refractionIntensity};if(this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),i.refractionIntensityTexture)if(i.useGltfStyleTextures){const Z=await this._exporter._materialExporter.exportTextureAsync(i.refractionIntensityTexture,"image/png");Z&&(B.transmissionTexture=Z)}else W.c.Warn(`${Z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[hU]=B}return U}}YZ.RegisterExtension(hU,(Z=>new PU(Z)));const TU="KHR_materials_unlit";class xU{constructor(){this.name=TU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{let i=!1;n instanceof qZ.c?i=n.unlit:n instanceof cZ.d&&(i=n.disableLighting),i&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[TU]={}),Z(U)}))}}YZ.RegisterExtension(TU,(()=>new xU));const wU="KHR_materials_volume";class oU{constructor(Z){this.name=wU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof qZ.c&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&i.push(n.subSurface.thicknessTexture),i):i}_isExtensionEnabled(Z){if(Z.unlit)return!1;const U=Z.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=s.b.White()||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.subSurface.thicknessTexture}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof qZ.c&&this._isExtensionEnabled(n)){this._wasUsed=!0;const Z=n.subSurface,i={thicknessFactor:0==Z.maximumThickness?void 0:Z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Z.thicknessTexture)??void 0,attenuationDistance:Z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Z.tintColorAtDistance,attenuationColor:Z.tintColor.equalsFloats(1,1,1)?void 0:Z.tintColor.Ei()};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),U.extensions=U.extensions||{},U.extensions[wU]=i}Z(U)}))}}YZ.RegisterExtension(wU,(Z=>new oU(Z)));const NU="EXT_materials_diffuse_roughness";class JU{constructor(Z){this.name=NU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,U,n){const i=[];return n instanceof RU.e&&n._baseDiffuseRoughness?(n._baseDiffuseRoughnessTexture&&i.push(n._baseDiffuseRoughnessTexture),i):[]}postExportMaterialAsync(Z,U,n){return new Promise((Z=>{if(n instanceof RU.e){if(!n._baseDiffuseRoughness)return void Z(U);this._wasUsed=!0,U.extensions=U.extensions||{};const i=this._exporter._materialExporter.getTextureInfo(n._baseDiffuseRoughnessTexture),B={diffuseRoughnessFactor:n._baseDiffuseRoughness,diffuseRoughnessTexture:i??void 0};null!==B.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(n),U.extensions[NU]=B}Z(U)}))}}YZ.RegisterExtension(NU,(Z=>new JU(Z)));const WU="KHR_texture_transform";class aU{constructor(){this.name=WU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Z,U,n){if(n.va()||B.e.Warn(`${Z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${n.name}!`),(0!==n.uAng||0!==n.vAng)&&(B.e.Warn(`${Z}: Texture ${n.name} with rotation in the u or v axis is not supported in glTF.`),0!==n.uRotationCenter||0!==n.vRotationCenter))return;const i={};let l=!1;if(0===n.uOffset&&0===n.vOffset||(i.offset=[n.uOffset,n.vOffset],l=!0),1===n.uScale&&1===n.vScale||(i.scale=[n.uScale,n.vScale],l=!0),0!==n.wAng){if(0!==n.uRotationCenter||0!==n.vRotationCenter){if(n.homogeneousRotationInUVTransform&&n.uScale!==n.vScale)return void B.e.Warn(`${Z}: Texture ${n.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${WU}.`);B.e.Warn(`${Z}: Texture ${n.name} with non-origin rotation center will be exported using an adjusted offset with ${WU}.`),i.offset=function(Z){const{uOffset:U,vOffset:n,uRotationCenter:i,vRotationCenter:B,uScale:l,vScale:H,wAng:V}=Z,G=Math.cos(V),R=Math.sin(V),d=i*l,F=B*H;return[U+(d*(1-G)+F*R),n+(F*(1-G)-d*R)]}(n)}i.rotation=-n.wAng,l=!0}0!==n.coordinatesIndex&&(i.texCoord=n.coordinatesIndex,l=!0),l&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[WU]=i)}}YZ.RegisterExtension(WU,(()=>new aU));class MU{static CreateSTL(Z){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],l=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],H=arguments.length>5&&void 0!==arguments[5]&&arguments[5],V=arguments.length>6&&void 0!==arguments[6]&&arguments[6],G=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const R=function(Z,U,n){const B=[3*Z[n],3*Z[n+1],3*Z[n+2]],l=[new i.k(U[B[0]],U[B[0]+2],U[B[0]+1]),new i.k(U[B[1]],U[B[1]+2],U[B[1]+1]),new i.k(U[B[2]],U[B[2]+2],U[B[2]+1])],H=l[0].Qg(l[1]),V=l[2].Qg(l[1]);return{v:l,n:i.k.Cross(V,H).normalize()}},F=function(Z,U,n,i){return U=y(Z,U,n.x,i),U=y(Z,U,n.y,i),y(Z,U,n.z,i)},y=function(Z,U,n,i){return Z.setFloat32(U,n,i),U+4},q=function(Z){if(V){let U=Z;Z instanceof S.d&&(U=Z.sourceMesh);const n=U.getVerticesData(d.f.PositionKind,!0,!0);if(!n)return[];const B=i.k.Zero();let l;for(l=0;l<n.length;l+=3)i.k.TransformCoordinatesFromFloatsToRef(n[l],n[l+1],n[l+2],Z.yi(!0),B).toArray(n,l);return n}return Z.getVerticesData(d.f.PositionKind)||[]};V&&(H=!0);let c="",s=0,z=0;if(B){for(let n=0;n<Z.length;n++){const U=Z[n].zi();s+=U?U.length/3:0}const U=new ArrayBuffer(84+50*s);c=new DataView(U),z+=80,c.setUint32(z,s,l),z+=4}else G||(c="solid stlmesh\r\n");for(let i=0;i<Z.length;i++){const U=Z[i];!B&&G&&(c+="solid "+U.name+"\r\n"),!H&&U instanceof OZ.e&&U.bakeCurrentTransformIntoVertices();const n=q(U),V=U.zi()||[];for(let Z=0;Z<V.length;Z+=3){const U=R(V,n,Z);B?(z=F(c,z,U.n,l),z=F(c,z,U.v[0],l),z=F(c,z,U.v[1],l),z=F(c,z,U.v[2],l),z+=2):(c+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",c+="\t\touter loop\r\n",c+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",c+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",c+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",c+="\t\tendloop\r\n",c+="\tendfacet\r\n")}!B&&G&&(c+="endsolid "+name+"\r\n")}if(B||G||(c+="endsolid stlmesh"),U){const Z=document.createElement("a"),U=new Blob([c],{type:"application/octet-stream"});Z.href=window.URL.createObjectURL(U),Z.download=n+".stl",Z.click()}return c}}function mU(Z,U){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const i=[];for(let B=0;B<Z.length/n;B++){const l=Z[B*n],H=Z[B*n+1],V=Z[B*n+2];i.push(`(${l.toPrecision(U.precision)}, ${H.toPrecision(U.precision)}, ${V.toPrecision(U.precision)})`)}return i.join(", ")}function AU(Z,U){const n=[];for(let i=0;i<Z.length/2;i++){const B=Z[2*i],l=Z[2*i+1];n.push(`(${B.toPrecision(U.precision)}, ${(1-l).toPrecision(U.precision)})`)}return n.join(", ")}function YU(Z,U){const n=Z.getVerticesData(d.f.PositionKind),i=Z.getVerticesData(d.f.NormalKind);if(n&&i)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Z){var U;const n=null!==(U=Z.zi())&&void 0!==U&&U.length?Z.getTotalIndices():Z.getTotalVertices();return Array(n/3).fill(3).join(", ")}(Z)}]\n\t\tint[] faceVertexIndices = [${function(Z){const U=Z.zi(),n=[];if(null!==U)for(let i=0;i<U.length;i++)n.push(U[i]);else{const U=Z.getTotalVertices();for(let Z=0;Z<U;Z++)n.push(Z)}return n.join(", ")}(Z)}]\n\t\tnormal3f[] normals = [${mU(i,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${mU(n,U)}]\n        ${function(Z,U){let n="";for(let B=0;B<4;B++){const i=B>0?B:"",l=Z.getVerticesData(d.f.UVKind+(i?i+1:""));l&&(n+=`\n\t\ttexCoord2f[] primvars:st${i} = [${AU(l,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const i=Z.getVerticesData(d.f.ColorKind);return i&&(n+=`\n\tcolor3f[] primvars:displayColor = [${mU(i,U,i.length/Z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),n}(Z,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function QU(Z,U){return`\n        def "Geometry"\n        {\n        ${YU(Z,U)}\n        }\n        `}function LU(Z){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=Z,fflate.strToU8(U)}function kU(Z){const U=Z.m;return`( ${IU(U,0)}, ${IU(U,4)}, ${IU(U,8)}, ${IU(U,12)} )`}function IU(Z,U){return`(${Z[U+0]}, ${Z[U+1]}, ${Z[U+2]}, ${Z[U+3]})`}function eU(Z){const U="Object_"+Z.uniqueId,n=function(Z){const U=Z.getWorldMatrix().clone(),n=Z.va().useRightHandedSystem;if(!n){let i=Z.parent;for(;i;){if(HZ(i,n)){U.multiplyToRef(i.getWorldMatrix().invert(),U);break}i=i.parent}}return U.determinant()<0&&B.e.Warn(`Exporting mesh ${Z.name} with negative scale. Result may look incorrect in destination engine.`),U}(Z),i=kU(n);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${Z.ui.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${i}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Z.material.uniqueId}>\n}\n\n`}function gU(Z){switch(Z){case C.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case C.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case C.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function bU(Z){return`(${Z.x}, ${Z.y})`}function rU(Z){return`(${Z.r}, ${Z.g}, ${Z.b})`}function fU(Z,U,n,B,l,H){const V=Z.getInternalTexture().uniqueId+"_"+Z.invertY;l[V]=Z;const G=Z.coordinatesIndex>0?"st"+Z.coordinatesIndex:"st",R=new i.j(Z.uScale,Z.vScale),d=new i.j(Z.uOffset,Z.vOffset),F=Z.wAng,y=Math.sin(F),S=Math.cos(F);return d.y=1-d.y-R.y,d.x+=y*R.x,d.y+=(1-S)*R.y,`\n    def Shader "PrimvarReader_${n}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${G}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${n}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${n}.outputs:result>\n        float inputs:rotation = ${(F*(180/Math.PI)).toFixed(H.precision)}\n        float2 inputs:scale = ${bU(R)}\n        float2 inputs:translation = ${bU(d)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Z.uniqueId}_${n}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${V}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${n}.outputs:result>\n        ${B?"float4 inputs:scale = "+function(Z){return`(${Z.r}, ${Z.g}, ${Z.b}, 1.0)`}(B):""}\n        token inputs:sourceColorSpace = "${Z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${gU(Z.wrapU)}"\n        token inputs:wrapT = "${gU(Z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function Zn(Z,U,n){const i="\t\t\t",B=[],l=[],{diffuseMap:H,cb:V,alphaCutOff:G,emissiveMap:R,emissive:d,normalMap:F,roughnessMap:y,roughnessChannel:S,roughness:q,metalnessMap:c,metalnessChannel:z,metalness:O,aoMap:E,aoMapChannel:t,aoMapIntensity:p,alphaMap:K,ior:C,clearCoatEnabled:D,clearCoat:u,clearCoatMap:j,clearCoatRoughness:v,clearCoatRoughnessMap:X}=function(Z){const U={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Z instanceof cZ.d?{...U,diffuseMap:Z.diffuseTexture,cb:Z.diffuseColor,alphaCutOff:Z.alphaCutOff,emissiveMap:Z.emissiveTexture,emissive:Z.emissiveColor,roughness:1,alphaMap:Z.opacityTexture}:Z instanceof RU.e?{...U,diffuseMap:Z._albedoTexture,cb:Z._albedoColor,alphaCutOff:Z._alphaCutOff,emissiveMap:Z._emissiveTexture,emissive:Z._emissiveColor,normalMap:Z._bumpTexture,roughnessMap:Z._metallicTexture,roughnessChannel:Z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Z._roughness??1,metalnessMap:Z._metallicTexture,metalnessChannel:Z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Z._metallic??0,aoMap:Z._ambientTexture,aoMapChannel:Z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Z._ambientTextureStrength,alphaMap:Z._opacityTexture,ior:Z.subSurface.indexOfRefraction,clearCoatEnabled:Z.clearCoat.isEnabled,clearCoat:Z.clearCoat.bb,clearCoatMap:Z.clearCoat.texture,clearCoatRoughness:Z.clearCoat.roughness,clearCoatRoughnessMap:Z.clearCoat.useRoughnessFromMainTexture?Z.clearCoat.texture:Z.clearCoat.textureRoughness}:U}(Z);return null!==H?(B.push(`${i}color3f inputs:diffuseColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:rgb>`),Z.needAlphaBlending()?B.push(`${i}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:a>`):Z.needAlphaTesting()&&(B.push(`${i}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${H.uniqueId}_diffuse.outputs:a>`),B.push(`${i}float inputs:opacityThreshold = ${G}`)),l.push(fU(H,Z,"diffuse",V,U,n))):B.push(`${i}color3f inputs:diffuseColor = ${rU(V||s.b.White())}`),null!==R?(B.push(`${i}color3f inputs:emissiveColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${R.uniqueId}_emissive.outputs:rgb>`),l.push(fU(R,Z,"emissive",d,U,n))):d&&d.toLuminance()>0&&B.push(`${i}color3f inputs:emissiveColor = ${rU(d)}`),null!==F&&(B.push(`${i}normal3f inputs:normal.connect = </Materials/Material_${Z.uniqueId}/Texture_${F.uniqueId}_normal.outputs:rgb>`),l.push(fU(F,Z,"Xi",null,U,n))),null!==E&&(B.push(`${i}float inputs:occlusion.connect = </Materials/Material_${Z.uniqueId}/Texture_${E.uniqueId}_occlusion.outputs:${t}>`),l.push(fU(E,Z,"occlusion",new s.b(p,p,p),U,n))),null!==y?(B.push(`${i}float inputs:roughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${y.uniqueId}_roughness.outputs:${S}>`),l.push(fU(y,Z,"roughness",new s.b(q,q,q),U,n))):B.push(`${i}float inputs:roughness = ${q}`),null!==c?(B.push(`${i}float inputs:metallic.connect = </Materials/Material_${Z.uniqueId}/Texture_${c.uniqueId}_metallic.outputs:${z}>`),l.push(fU(c,Z,"metallic",new s.b(O,O,O),U,n))):B.push(`${i}float inputs:metallic = ${O}`),null!==K?(B.push(`${i}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_opacity.outputs:r>`),B.push(`${i}float inputs:opacityThreshold = 0.0001`),l.push(fU(K,Z,"opacity",null,U,n))):B.push(`${i}float inputs:opacity = ${Z.alpha}`),D&&(null!==j?(B.push(`${i}float inputs:clearcoat.connect = </Materials/Material_${Z.uniqueId}/Texture_${j.uniqueId}_clearcoat.outputs:r>`),l.push(fU(j,Z,"clearcoat",new s.b(u,u,u),U,n))):B.push(`${i}float inputs:clearcoat = ${u}`),null!==X?(B.push(`${i}float inputs:clearcoatRoughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${X.uniqueId}_clearcoatRoughness.outputs:g>`),l.push(fU(X,Z,"clearcoatRoughness",new s.b(v,v,v),U,n))):B.push(`${i}float inputs:clearcoatRoughness = ${v}`)),B.push(`${i}float inputs:ior = ${C}`),`\n\tdef Material "Material_${Z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${B.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Z.uniqueId}/PreviewSurface.outputs:surface>\n\n${l.join("\n")}\n\n\t}\n`}async function Un(Z,U,n){const l={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await B.e.LoadScriptAsync(l.fflateUrl);const H={};H[l.modelFileName]=null;let V='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';V+=function(Z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Z.planeAnchoringAlignment}"`:""}\n            `}(l);const G={};for(const i of Z.meshes){if(0===i.getTotalVertices())continue;const Z=i,U=Z.ui,R=Z.material;if(!R||!U||n&&!n(Z))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(R.getClassName())){const n="geometries/Geometry_"+U.uniqueId+".usda";if(!(n in H)){const Z=QU(U,l);H[n]=LU(Z)}R.uniqueId in G||(G[R.uniqueId]=R),V+=eU(Z)}else B.e.Warn("USDZExportAsync does not support this material type: "+R.getClassName())}Z.activeCamera&&l.exportCamera&&(V+=function(Z,U){const n="Camera_"+Z.uniqueId,B=kU(i.b.RotationY(Math.PI).multiply(Z.getWorldMatrix()));if(Z.mode===C.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Ai.toPrecision(U.precision)}, ${Z.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Z.orthoLeft||1)+Math.abs(Z.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Z.orthoTop||1)+Math.abs(Z.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const i=Z.getEngine().getAspectRatio(Z),l=U.cameraSensorWidth||35;return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Ai.toPrecision(U.precision)}, ${Z.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(l/(2*Math.tan(.5*Z.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(l*i).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(l/i).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(Z.activeCamera,l)),V+="\n            }\n        }\n    }";const R={};V+=function(Z,U,n){const i=[];for(const B in Z){const l=Z[B];i.push(Zn(l,U,n))}return`\n    def "Materials"\n{\n${i.join("")}\n}\n\n`}(G,R,l),H[l.modelFileName]=fflate.strToU8(V);for(const i in R){const Z=R[i],U=Z.getSize(),n=await Z.readPixels();if(!n)throw new Error("Texture data is not available");const B=await D.DumpTools.DumpDataAsync(U.width,U.height,n,"image/png",void 0,!1,!0);H[`textures/Texture_${i}.png`]=new Uint8Array(B).slice()}let d=0;for(const i in H){const Z=H[i];if(!Z)continue;d+=34+i.length;const U=63&d;if(4!==U){const n=new Uint8Array(64-U);H[i]=[Z,{extra:{12345:n}}]}d=Z.length}return fflate.zipSync(H,{level:0})}}}]);