"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{12676:(q,f,j)=>{var d=j(11090),g=j(11005),h=j(11030),L=j(11105),Q=j(11065),H=j(11096);Q.b.prototype._partialLoadFile=function(q,f,j,d){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(q,(q=>{j[f]=q,j._internalCount++,6===j._internalCount&&d(j)}),void 0,void 0,!0,((q,f)=>{g&&q&&g(q.status+" "+q.statusText,f)}))},Q.b.prototype._cascadeLoadFiles=function(q,f,j){let d=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const g=[];g._internalCount=0;for(let h=0;h<6;h++)this._partialLoadFile(j[h],h,g,f,d)},Q.b.prototype._cascadeLoadImgs=function(q,f,j,d){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,h=arguments.length>5?arguments[5]:void 0;const L=[];L._internalCount=0;for(let Q=0;Q<6;Q++)this._partialLoadImg(d[Q],Q,L,q,f,j,g,h)},Q.b.prototype._partialLoadImg=function(q,f,j,d,g,Q){let H=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,r=arguments.length>7?arguments[7]:void 0;const u=(0,L.d)();(0,h.p)(q,(q=>{j[f]=q,j._internalCount++,d&&d.removePendingData(u),6===j._internalCount&&Q&&Q(g,j)}),((q,f)=>{d&&d.removePendingData(u),H&&H(q,f)}),d?d.offlineProvider:null,r),d&&d.addPendingData(u)},Q.b.prototype.createCubeTextureBase=function(q,f,j,h){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,r=arguments.length>6?arguments[6]:void 0,u=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,X=arguments.length>8&&void 0!==arguments[8]&&arguments[8],z=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,B=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,D=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,i=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,t=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,O=arguments.length>14&&void 0!==arguments[14]&&arguments[14],N=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const w=D||new d.c(this,7);w.isCube=!0,w.url=q,w.generateMipMaps=!h,w._lodGenerationScale=z,w._lodGenerationOffset=B,w._useSRGBBuffer=!!O&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!h),w!==D&&(w.label=q.substring(0,60)),this._doNotHandleContextLost||(w._extension=u,w._files=j,w._buffer=N);const E=q;this._transformTextureUrl&&!D&&(q=this._transformTextureUrl(q));const s=u??function(q){const f=q.split("?")[0],j=f.lastIndexOf(".");return j>-1?f.substring(j).toLowerCase():""}(q),S=(0,H.e)(s),e=(q,f)=>{w.dispose(),Q?Q(q,f):q&&g.e.Warn(q)},Z=(d,Q)=>{q===E?d&&e(d.status+" "+d.statusText,Q):(g.e.Warn(`Failed to load ${q}, falling back to the ${E}`),this.createCubeTextureBase(E,f,j,!!h,L,e,r,u,X,z,B,w,i,t,O,N))};if(S)S.then((d=>{const g=q=>{i&&i(w,q),d.loadCubeData(q,w,X,L,((q,f)=>{e(q,f)}))};N?g(N):j&&6===j.length?d.supportCascades?this._cascadeLoadFiles(f,(q=>g(q.map((q=>new Uint8Array(q))))),j,e):e("Textures type does not support cascades."):this._loadFile(q,(q=>g(new Uint8Array(q))),void 0,void 0,!0,Z)}));else{if(!j||0===j.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(f,w,((q,f)=>{t&&t(q,f)}),j,e)}return this._internalTexturesCache.push(w),w}},13413:(q,f,j)=>{j.r(f),j.d(f,{_DDSTextureLoader:()=>h});var d=j(11389),g=j(13420);class h{constructor(){this.supportCascades=!0}loadCubeData(q,f,j,h){const L=f.getEngine();let Q,H=!1,r=1e3;if(Array.isArray(q))for(let d=0;d<q.length;d++){const j=q[d];Q=g.DDSTools.GetDDSInfo(j),f.width=Q.width,f.height=Q.height,H=(Q.isRGB||Q.isLuminance||Q.mipmapCount>1)&&f.generateMipMaps,L._unpackFlipY(Q.isCompressed),g.DDSTools.UploadDDSLevels(L,f,j,Q,H,6,-1,d),Q.isFourCC||1!==Q.mipmapCount?r=Q.mipmapCount-1:L.generateMipMapsForCubemap(f)}else{const h=q;Q=g.DDSTools.GetDDSInfo(h),f.width=Q.width,f.height=Q.height,j&&(Q.sphericalPolynomial=new d.f),H=(Q.isRGB||Q.isLuminance||Q.mipmapCount>1)&&f.generateMipMaps,L._unpackFlipY(Q.isCompressed),g.DDSTools.UploadDDSLevels(L,f,h,Q,H,6),Q.isFourCC||1!==Q.mipmapCount?r=Q.mipmapCount-1:L.generateMipMapsForCubemap(f,!1)}L._setCubeMapTextureParams(f,H,r),f.isReady=!0,f.onLoadedObservable.notifyObservers(f),f.onLoadedObservable.clear(),h&&h({isDDS:!0,width:f.width,info:Q,data:q,texture:f})}loadData(q,f,j){const d=g.DDSTools.GetDDSInfo(q),h=(d.isRGB||d.isLuminance||d.mipmapCount>1)&&f.generateMipMaps&&Math.max(d.width,d.height)>>d.mipmapCount-1===1;j(d.width,d.height,h,d.isFourCC,(()=>{g.DDSTools.UploadDDSLevels(f.getEngine(),f,q,d,h,1)}))}}},13420:(q,f,j)=>{j.d(f,{DDSTools:()=>D});var d=j(10985),g=j(11005),h=j(11581),L=j(11433);j(12676);const Q=131072,H=131072;function r(q){return q.charCodeAt(0)+(q.charCodeAt(1)<<8)+(q.charCodeAt(2)<<16)+(q.charCodeAt(3)<<24)}const u=r("DXT1"),X=r("DXT3"),z=r("DXT5"),B=r("DX10");class D{static GetDDSInfo(q){const f=new Int32Array(q.buffer,q.byteOffset,31),j=new Int32Array(q.buffer,q.byteOffset,35);let d=1;f[2]&Q&&(d=Math.max(1,f[7]));const g=f[21],h=g===B?j[32]:0;let L=0;switch(g){case 113:L=2;break;case 116:L=1;break;case B:if(10===h){L=2;break}if(2===h){L=1;break}}return{width:f[4],height:f[3],mipmapCount:d,isFourCC:4===(4&f[20]),isRGB:64===(64&f[20]),isLuminance:(f[20]&H)===H,isCube:512===(512&f[28]),isCompressed:g===u||g===X||g===z,dxgiFormat:h,textureType:L}}static _GetHalfFloatAsFloatRGBAArrayBuffer(q,f,j,d,g,h){const Q=new Float32Array(d),H=new Uint16Array(g,j);let r=0;for(let u=0;u<f;u++)for(let f=0;f<q;f++){const j=4*(f+u*q);Q[r]=(0,L.f)(H[j]),Q[r+1]=(0,L.f)(H[j+1]),Q[r+2]=(0,L.f)(H[j+2]),D.StoreLODInAlphaChannel?Q[r+3]=h:Q[r+3]=(0,L.f)(H[j+3]),r+=4}return Q}static _GetHalfFloatRGBAArrayBuffer(q,f,j,d,g,h){if(D.StoreLODInAlphaChannel){const Q=new Uint16Array(d),H=new Uint16Array(g,j);let r=0;for(let j=0;j<f;j++)for(let f=0;f<q;f++){const d=4*(f+j*q);Q[r]=H[d],Q[r+1]=H[d+1],Q[r+2]=H[d+2],Q[r+3]=(0,L.p)(h),r+=4}return Q}return new Uint16Array(g,j,d)}static _GetFloatRGBAArrayBuffer(q,f,j,d,g,h){if(D.StoreLODInAlphaChannel){const L=new Float32Array(d),Q=new Float32Array(g,j);let H=0;for(let j=0;j<f;j++)for(let f=0;f<q;f++){const d=4*(f+j*q);L[H]=Q[d],L[H+1]=Q[d+1],L[H+2]=Q[d+2],L[H+3]=h,H+=4}return L}return new Float32Array(g,j,d)}static _GetFloatAsHalfFloatRGBAArrayBuffer(q,f,j,d,g,h){const Q=new Uint16Array(d),H=new Float32Array(g,j);let r=0;for(let u=0;u<f;u++)for(let f=0;f<q;f++)Q[r]=(0,L.p)(H[r]),Q[r+1]=(0,L.p)(H[r+1]),Q[r+2]=(0,L.p)(H[r+2]),D.StoreLODInAlphaChannel?Q[r+3]=(0,L.p)(h):Q[r+3]=(0,L.p)(H[r+3]),r+=4;return Q}static _GetFloatAsUIntRGBAArrayBuffer(q,f,j,g,h,L){const Q=new Uint8Array(g),H=new Float32Array(h,j);let r=0;for(let u=0;u<f;u++)for(let f=0;f<q;f++){const j=4*(f+u*q);Q[r]=255*(0,d.Clamp)(H[j]),Q[r+1]=255*(0,d.Clamp)(H[j+1]),Q[r+2]=255*(0,d.Clamp)(H[j+2]),D.StoreLODInAlphaChannel?Q[r+3]=L:Q[r+3]=255*(0,d.Clamp)(H[j+3]),r+=4}return Q}static _GetHalfFloatAsUIntRGBAArrayBuffer(q,f,j,g,h,Q){const H=new Uint8Array(g),r=new Uint16Array(h,j);let u=0;for(let X=0;X<f;X++)for(let f=0;f<q;f++){const j=4*(f+X*q);H[u]=255*(0,d.Clamp)((0,L.f)(r[j])),H[u+1]=255*(0,d.Clamp)((0,L.f)(r[j+1])),H[u+2]=255*(0,d.Clamp)((0,L.f)(r[j+2])),D.StoreLODInAlphaChannel?H[u+3]=Q:H[u+3]=255*(0,d.Clamp)((0,L.f)(r[j+3])),u+=4}return H}static _GetRGBAArrayBuffer(q,f,j,d,g,h,L,Q,H){const r=new Uint8Array(d),u=new Uint8Array(g,j);let X=0;for(let z=0;z<f;z++)for(let f=0;f<q;f++){const j=4*(f+z*q);r[X]=u[j+h],r[X+1]=u[j+L],r[X+2]=u[j+Q],r[X+3]=u[j+H],X+=4}return r}static _ExtractLongWordOrder(q){return 0===q||255===q||-16777216===q?0:1+D._ExtractLongWordOrder(q>>8)}static _GetRGBArrayBuffer(q,f,j,d,g,h,L,Q){const H=new Uint8Array(d),r=new Uint8Array(g,j);let u=0;for(let X=0;X<f;X++)for(let f=0;f<q;f++){const j=3*(f+X*q);H[u]=r[j+h],H[u+1]=r[j+L],H[u+2]=r[j+Q],u+=3}return H}static _GetLuminanceArrayBuffer(q,f,j,d,g){const h=new Uint8Array(d),L=new Uint8Array(g,j);let Q=0;for(let H=0;H<f;H++)for(let f=0;f<q;f++){const j=f+H*q;h[Q]=L[j],Q++}return h}static UploadDDSLevels(q,f,j,d,L,H){let r=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,i=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],O=null;d.sphericalPolynomial&&(O=[]);const N=!!q.getCaps().s3tc;f.generateMipMaps=L;const w=new Int32Array(j.buffer,j.byteOffset,31);let E,s,S,e,Z,I,T,W=0,n=0,U=1;if(542327876!==w[0])return void g.e.Error("Invalid magic number in DDS header");if(!d.isFourCC&&!d.isRGB&&!d.isLuminance)return void g.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(d.isCompressed&&!N)return void g.e.Error("Compressed textures are not supported on this platform.");let Y=w[22];e=w[1]+4;let v=!1;if(d.isFourCC)switch(E=w[21],E){case u:U=8,n=33777;break;case X:U=16,n=33778;break;case z:U=16,n=33779;break;case 113:v=!0,Y=64;break;case 116:v=!0,Y=128;break;case B:{e+=20;let q=!1;switch(d.dxgiFormat){case 10:v=!0,Y=64,q=!0;break;case 2:v=!0,Y=128,q=!0;break;case 88:d.isRGB=!0,d.isFourCC=!1,Y=32,q=!0}if(q)break}default:return void g.e.Error(["Unsupported FourCC code:",(F=E,String.fromCharCode(255&F,F>>8&255,F>>16&255,F>>24&255))])}var F;const M=D._ExtractLongWordOrder(w[23]),o=D._ExtractLongWordOrder(w[24]),b=D._ExtractLongWordOrder(w[25]),x=D._ExtractLongWordOrder(w[26]);v&&(n=q._getRGBABufferInternalSizedFormat(d.textureType)),I=1,w[2]&Q&&!1!==L&&(I=Math.max(1,w[7]));const R=i||0,A=q.getCaps();for(let g=R;g<H;g++){for(s=w[4],S=w[3],T=0;T<I;++T){if(-1===r||r===T){const h=-1===r?T:0;if(!d.isCompressed&&d.isFourCC){f.format=5,W=s*S*4;let d=null;if(q._badOS||q._badDesktopOS||!A.textureHalfFloat&&!A.textureFloat)128===Y?(d=D._GetFloatAsUIntRGBAArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,h),O&&0==h&&O.push(D._GetFloatRGBAArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,h))):64===Y&&(d=D._GetHalfFloatAsUIntRGBAArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,h),O&&0==h&&O.push(D._GetHalfFloatAsFloatRGBAArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,h))),f.type=0;else{const q=A.textureFloat&&(t&&A.textureFloatLinearFiltering||!t),g=A.textureHalfFloat&&(t&&A.textureHalfFloatLinearFiltering||!t),L=(128===Y||64===Y&&!g)&&q?1:(64===Y||128===Y&&!q)&&g?2:0;let Q,H=null;if(128===Y)switch(L){case 1:Q=D._GetFloatRGBAArrayBuffer,H=null;break;case 2:Q=D._GetFloatAsHalfFloatRGBAArrayBuffer,H=D._GetFloatRGBAArrayBuffer;break;case 0:Q=D._GetFloatAsUIntRGBAArrayBuffer,H=D._GetFloatRGBAArrayBuffer}else switch(L){case 1:Q=D._GetHalfFloatAsFloatRGBAArrayBuffer,H=null;break;case 2:Q=D._GetHalfFloatRGBAArrayBuffer,H=D._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:Q=D._GetHalfFloatAsUIntRGBAArrayBuffer,H=D._GetHalfFloatAsFloatRGBAArrayBuffer}f.type=L,d=Q(s,S,j.byteOffset+e,W,j.buffer,h),O&&0==h&&O.push(H?H(s,S,j.byteOffset+e,W,j.buffer,h):d)}d&&q._uploadDataToTextureDirectly(f,d,g,h)}else if(d.isRGB)f.type=0,24===Y?(f.format=4,W=s*S*3,Z=D._GetRGBArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,M,o,b),q._uploadDataToTextureDirectly(f,Z,g,h)):(f.format=5,W=s*S*4,Z=D._GetRGBAArrayBuffer(s,S,j.byteOffset+e,W,j.buffer,M,o,b,x),q._uploadDataToTextureDirectly(f,Z,g,h));else if(d.isLuminance){const d=q._getUnpackAlignement(),L=s;W=Math.floor((s+d-1)/d)*d*(S-1)+L,Z=D._GetLuminanceArrayBuffer(s,S,j.byteOffset+e,W,j.buffer),f.format=1,f.type=0,q._uploadDataToTextureDirectly(f,Z,g,h)}else W=Math.max(4,s)/4*Math.max(4,S)/4*U,Z=new Uint8Array(j.buffer,j.byteOffset+e,W),f.type=0,q._uploadCompressedDataToTextureDirectly(f,n,s,S,Z,g,h)}e+=Y?s*S*(Y/8):W,s*=.5,S*=.5,s=Math.max(1,s),S=Math.max(1,S)}if(void 0!==i)break}O&&O.length>0?d.sphericalPolynomial=h.d.ConvertCubeMapToSphericalPolynomial({size:w[4],right:O[0],left:O[1],up:O[2],down:O[3],front:O[4],back:O[5],format:5,type:1,gammaSpace:!1}):d.sphericalPolynomial=void 0}}D.StoreLODInAlphaChannel=!1}}]);