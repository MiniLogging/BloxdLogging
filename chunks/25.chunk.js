"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11775:(U,W,l)=>{l.r(W),l.d(W,{EXT_materials_diffuse_roughness:()=>vW,EXT_mesh_gpu_instancing:()=>cU,GLTF2Export:()=>PU,GLTFData:()=>A,KHR_draco_mesh_compression:()=>lW,KHR_lights_punctual:()=>kW,KHR_materials_anisotropy:()=>yW,KHR_materials_clearcoat:()=>sW,KHR_materials_diffuse_transmission:()=>rW,KHR_materials_dispersion:()=>fW,KHR_materials_emissive_strength:()=>EW,KHR_materials_ior:()=>NW,KHR_materials_iridescence:()=>oW,KHR_materials_sheen:()=>OW,KHR_materials_specular:()=>dW,KHR_materials_transmission:()=>VW,KHR_materials_unlit:()=>xW,KHR_materials_volume:()=>RW,KHR_texture_transform:()=>QW,OBJExport:()=>p,STLExport:()=>GW,USDZExportAsync:()=>Wl,_ConvertToGLTFPBRMetallicRoughness:()=>n,_SolveMetallic:()=>V,__IGLTFExporterExtension:()=>B});var M=l(706),t=l(503),L=l(851);class p{static OBJ(U,W,l,p){const B=[];let k=1,A=1;W&&(l||(l="mat"),B.push("mtllib "+l+".mtl"));for(let q=0;q<U.length;q++){const l=U[q],y=l.name||`mesh${q}}`;B.push(`o ${y}`);let j=null;if(p){const U=l.fk(!0);j=new M.c,U.invertToRef(j),l.bakeTransformIntoVertices(U)}if(W){const U=l.material;U&&B.push("usemtl "+U.id)}const s=l.vk;if(!s){t.h.Warn("No geometry is present on the mesh");continue}const w=s.getVerticesData("position"),K=s.getVerticesData("rk"),r=s.getVerticesData("uv"),m=s.hk();let f=0,g=0;if(!w||!m){t.h.Warn("There are no position vertices or indices on the mesh!");continue}const E=U[0].va().useRightHandedSystem?1:-1;for(let U=0;U<w.length;U+=3)B.push("v "+w[U]*E+" "+w[U+1]+" "+w[U+2]),f++;if(null!=K)for(let U=0;U<K.length;U+=3)B.push("vn "+K[U]*E+" "+K[U+1]+" "+K[U+2]);if(null!=r)for(let U=0;U<r.length;U+=2)B.push("vt "+r[U]+" "+r[U+1]),g++;const Z=["","",""],N=(l.material||l.va().defaultMaterial)._getEffectiveOrientation(l),[D,o]=N===L.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let U=0;U<m.length;U+=3){const W=[String(m[U]+k),String(m[U+D]+k),String(m[U+o]+k)],l=[String(m[U]+A),String(m[U+D]+A),String(m[U+o]+A)],M=W,t=null!=r?l:Z,L=null!=K?W:Z;B.push("f "+M[0]+"/"+t[0]+"/"+L[0]+" "+M[1]+"/"+t[1]+"/"+L[1]+" "+M[2]+"/"+t[2]+"/"+L[2])}p&&j&&l.bakeTransformIntoVertices(j),k+=f,A+=g}return B.join("\n")}static MTL(U){const W=[],l=U.material;W.push("newmtl mat1"),W.push("  Ns "+l.specularPower.toFixed(4)),W.push("  Ni 1.5000"),W.push("  d "+l.alpha.toFixed(4)),W.push("  Tr 0.0000"),W.push("  Tf 1.0000 1.0000 1.0000"),W.push("  illum 2"),W.push("  Ka "+l.ambientColor.r.toFixed(4)+" "+l.ambientColor.g.toFixed(4)+" "+l.ambientColor.b.toFixed(4)),W.push("  Kd "+l.diffuseColor.r.toFixed(4)+" "+l.diffuseColor.g.toFixed(4)+" "+l.diffuseColor.b.toFixed(4)),W.push("  Ks "+l.specularColor.r.toFixed(4)+" "+l.specularColor.g.toFixed(4)+" "+l.specularColor.b.toFixed(4)),W.push("  Ke "+l.emissiveColor.r.toFixed(4)+" "+l.emissiveColor.g.toFixed(4)+" "+l.emissiveColor.b.toFixed(4));l.ambientTexture&&W.push("  map_Ka "+l.ambientTexture.name),l.diffuseTexture&&W.push("  map_Kd "+l.diffuseTexture.name),l.specularTexture&&W.push("  map_Ks "+l.specularTexture.name),l.bumpTexture&&W.push("  map_bump -imfchan z "+l.bumpTexture.name),l.opacityTexture&&W.push("  map_d "+l.opacityTexture.name);return W.join("\n")}}var B=0,k=l(547);class A{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const U in this.files){const W=this.files[U],l=new Blob([W],{type:(0,k.e)(U)});t.h.Download(l,U)}}}var q=l(763),y=l(828),j=l(821),s=l(11778),w=l(2088),K=l(543),r=l(742),m=l(722);const f=m.HighestCommonFactor,g={...m,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:f};var E=l(2046),Z=l(2048),N=l(11781),D=l(11783),o=l(2239);const i=1e-6,O=new r.e(.04,.04,.04),e=1024,d=r.e.White(),H=r.e.Black();function V(U,W,l){if(W<O.r)return 0;const M=O.r,t=U*l/(1-O.r)+W-2*O.r,L=t*t-4*M*(O.r-W);return g.Clamp((-t+Math.sqrt(L))/(2*M),0,1)}function n(U){const W=U.diffuseColor.toLinearSpace(U.va().getEngine().useExactSrgbConversions).scale(.5),l=U.alpha,t=function(U){let W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new M.h(0,1),l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new M.h(0,.1),t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new M.h(0,.1),L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new M.h(1300,.1);return function(U,W,l,M,t){return(1-U)*(1-U)*(1-U)*W+3*(1-U)*(1-U)*U*l+3*(1-U)*U*U*M+U*U*U*t}(Math.pow(U/L.x,.333333),W.y,l.y,t.y,L.y)}(g.Clamp(U.specularPower,0,e));return{baseColorFactor:[W.r,W.g,W.b,l],metallicFactor:0,roughnessFactor:t}}function x(U,W){W.needAlphaBlending()?U.alphaMode="BLEND":W.needAlphaTesting()&&(U.alphaMode="MASK",U.alphaCutoff=W.alphaCutOff)}function I(U,W,l){const M=new Uint8Array(U*W*4);for(let t=0;t<M.length;t+=4)M[t]=M[t+1]=M[t+2]=M[t+3]=255;return N.e.CreateRGBATexture(M,U,W,l)}function R(U){if(U instanceof Uint8Array){const W=U.length,l=new Float32Array(U.length);for(let M=0;M<W;++M)l[M]=U[M]/255;return l}if(U instanceof Float32Array)return U;throw new Error("Unsupported pixel format!")}class F{constructor(U){this._exporter=U,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(U){return U?this._textureMap.get(U)??null:null}async exportStandardMaterialAsync(U,W,l){const M=n(U),L={name:U.name};if(null==U.sk||U.sk||(U.twoSidedLighting||t.h.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),l){const l=[],t=U.diffuseTexture;t&&l.push(this.exportTextureAsync(t,W).then((U=>{U&&(M.baseColorTexture=U)})));const p=U.bumpTexture;p&&l.push(this.exportTextureAsync(p,W).then((U=>{U&&(L.normalTexture=U,1!==p.level&&(L.normalTexture.scale=p.level))})));const B=U.emissiveTexture;B&&(L.emissiveFactor=[1,1,1],l.push(this.exportTextureAsync(B,W).then((U=>{U&&(L.emissiveTexture=U)}))));const k=U.ambientTexture;k&&l.push(this.exportTextureAsync(k,W).then((U=>{if(U){const W={index:U.index};L.occlusionTexture=W}}))),l.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(l))}(U.alpha<1||U.opacityTexture)&&(U.alphaMode===D.c.ALPHA_COMBINE?L.alphaMode="BLEND":t.h.Warn(U.name+": glTF 2.0 does not support alpha mode: "+U.alphaMode.toString())),U.emissiveColor&&!U.emissiveColor.equalsWithEpsilon(H,i)&&(L.emissiveFactor=U.emissiveColor.qk()),L.pbrMetallicRoughness=M,x(L,U),await this._finishMaterialAsync(L,U,W);const p=this._exporter._materials;return p.push(L),p.length-1}async _finishMaterialAsync(U,W,l){const M=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",U,W),t=[];for(const L of M)t.push(this.exportTextureAsync(L,l));await Promise.all(t),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",U,W)}async _getImageDataAsync(U,W,M,t){const L=D.c.TEXTURETYPE_UNSIGNED_BYTE,p=this._exporter._babylonScene,B=p.getEngine(),k=B.createRawTexture(U,W,M,D.c.TEXTUREFORMAT_RGBA,!1,!0,Z.d.NEAREST_SAMPLINGMODE,null,L);B.isWebGPU?await l.e(45).then(l.bind(l,13276)):await l.e(46).then(l.bind(l,13285)),await E.j.ApplyPostProcess("pass",k,p,L,D.c.TEXTURE_NEAREST_SAMPLINGMODE,D.c.TEXTUREFORMAT_RGBA);const A=await B._readTexturePixels(k,W,M);return await o.DumpTools.DumpDataAsync(W,M,A,t,void 0,!0,!0)}_resizeTexturesToSameDimensions(U,W,l){const M=U?U.getSize():{width:0,height:0},t=W?W.getSize():{width:0,height:0};let L,p;return M.width<t.width?(L=U&&U instanceof Z.d?E.j.CreateResizedCopy(U,t.width,t.height,!0):I(t.width,t.height,l),p=W):M.width>t.width?(p=W&&W instanceof Z.d?E.j.CreateResizedCopy(W,M.width,M.height,!0):I(M.width,M.height,l),L=U):(L=U,p=W),{texture1:L,texture2:p}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(U,W,l,M){const t=new Array;if(!U&&!W)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const L=U?U.va():W?W.va():null;if(L){var p;const B=this._resizeTexturesToSameDimensions(U,W,L),k=null===(p=B.texture1)||void 0===p?void 0:p.getSize();let A,q;const y=k.width,j=k.height,s=await B.texture1.readPixels(),w=await B.texture2.readPixels();if(!s)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(A=R(s),!w)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");q=R(w);const K=q.byteLength,m=new Uint8Array(K),f=new Uint8Array(K),g=4,E=H;let Z=0,N=0;for(let U=0;U<j;++U)for(let W=0;W<y;++W){const M=(y*U+W)*g,t={diffuseColor:new r.e(A[M],A[M+1],A[M+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(l.diffuseColor),specularColor:new r.e(q[M],q[M+1],q[M+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(l.specularColor),glossiness:q[M+3]*l.glossiness},p=this._convertSpecularGlossinessToMetallicRoughness(t);E.r=Math.max(E.r,p.baseColor.r),E.g=Math.max(E.g,p.baseColor.g),E.b=Math.max(E.b,p.baseColor.b),Z=Math.max(Z,p.metallic),N=Math.max(N,p.roughness),f[M]=255*p.baseColor.r,f[M+1]=255*p.baseColor.g,f[M+2]=255*p.baseColor.b,f[M+3]=B.texture1.yi?255*A[M+3]:255,m[M]=0,m[M+1]=255*p.roughness,m[M+2]=255*p.metallic,m[M+3]=255}const D={baseColor:E,metallic:Z,roughness:N};let o=!1,O=!1;for(let U=0;U<j;++U)for(let W=0;W<y;++W){const l=(y*U+W)*g;f[l]/=D.baseColor.r>i?D.baseColor.r:1,f[l+1]/=D.baseColor.g>i?D.baseColor.g:1,f[l+2]/=D.baseColor.b>i?D.baseColor.b:1;const M=r.e.FromInts(f[l],f[l+1],f[l+2]).toGammaSpace(L.getEngine().useExactSrgbConversions);f[l]=255*M.r,f[l+1]=255*M.g,f[l+2]=255*M.b,M.equalsWithEpsilon(d,i)||(O=!0),m[l+1]/=D.roughness>i?D.roughness:1,m[l+2]/=D.metallic>i?D.metallic:1;r.e.FromInts(255,m[l+1],m[l+2]).equalsWithEpsilon(d,i)||(o=!0)}return o&&t.push(this._getImageDataAsync(m,y,j,M).then((U=>{D.metallicRoughnessTextureData=U}))),O&&t.push(this._getImageDataAsync(f,y,j,M).then((U=>{D.baseColorTextureData=U}))),await Promise.all(t).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(U){const W=this._getPerceivedBrightness(U.diffuseColor),l=this._getPerceivedBrightness(U.specularColor),M=1-this._getMaxComponent(U.specularColor),t=V(W,l,M),L=U.diffuseColor.scale(M/(1-O.r)/Math.max(1-t)),p=U.specularColor.de(O.scale(1-t)).scale(1/Math.max(t));let B=r.e.Lerp(L,p,t*t);B=B.clampToRef(0,1,B);return{baseColor:B,metallic:t,roughness:1-U.glossiness}}_getPerceivedBrightness(U){return U?Math.sqrt(.299*U.r*U.r+.587*U.g*U.g+.114*U.b*U.b):0}_getMaxComponent(U){return U?Math.max(U.r,Math.max(U.g,U.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(U,W,l,M){const t=[],L={baseColor:U._albedoColor,metallic:U._metallic,roughness:U._roughness};if(M){U._albedoTexture&&t.push(this.exportTextureAsync(U._albedoTexture,W).then((U=>{U&&(l.baseColorTexture=U)})));const M=U._metallicTexture;M&&t.push(this.exportTextureAsync(M,W).then((U=>{U&&(l.metallicRoughnessTexture=U)})))}return t.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(t)),L}_getTextureSampler(U){const W={};if(!U||!(U instanceof Z.d))return W;const l=this._getGLTFTextureWrapMode(U.wrapU);10497!==l&&(W.wrapS=l);const M=this._getGLTFTextureWrapMode(U.wrapV);switch(10497!==M&&(W.wrapT=M),U.samplingMode){case Z.d.LINEAR_LINEAR:W.magFilter=9729,W.minFilter=9729;break;case Z.d.LINEAR_NEAREST:W.magFilter=9729,W.minFilter=9728;break;case Z.d.NEAREST_LINEAR:W.magFilter=9728,W.minFilter=9729;break;case Z.d.NEAREST_LINEAR_MIPLINEAR:W.magFilter=9728,W.minFilter=9987;break;case Z.d.NEAREST_NEAREST:W.magFilter=9728,W.minFilter=9728;break;case Z.d.NEAREST_LINEAR_MIPNEAREST:W.magFilter=9728,W.minFilter=9985;break;case Z.d.LINEAR_NEAREST_MIPNEAREST:W.magFilter=9729,W.minFilter=9984;break;case Z.d.LINEAR_NEAREST_MIPLINEAR:W.magFilter=9729,W.minFilter=9986;break;case Z.d.NEAREST_NEAREST_MIPLINEAR:W.magFilter=9728,W.minFilter=9986;break;case Z.d.LINEAR_LINEAR_MIPLINEAR:W.magFilter=9729,W.minFilter=9987;break;case Z.d.LINEAR_LINEAR_MIPNEAREST:W.magFilter=9729,W.minFilter=9985;break;case Z.d.NEAREST_NEAREST_MIPNEAREST:W.magFilter=9728,W.minFilter=9984}return W}_getGLTFTextureWrapMode(U){switch(U){case Z.d.WRAP_ADDRESSMODE:return 10497;case Z.d.CLAMP_ADDRESSMODE:return 33071;case Z.d.MIRROR_ADDRESSMODE:return 33648;default:return t.h.Error(`Unsupported Texture Wrap Mode ${U}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(U,W,l,M){const t={diffuseColor:U._albedoColor,specularColor:U._reflectivityColor,glossiness:U._microSurface},L=U._albedoTexture,p=U._reflectivityTexture,B=U._useMicroSurfaceFromReflectivityMapAlpha;if(p&&!B)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((L||p)&&M){this._exporter._materialNeedsUVsSet.add(U);const M=this._exportTextureSampler(L||p),B=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,p,t,W),k=this._exporter._textures;if(B.baseColorTextureData){const U=this._exportImage(`baseColor${k.length}`,W,B.baseColorTextureData);l.baseColorTexture=this._exportTextureInfo(U,M,null===L||void 0===L?void 0:L.coordinatesIndex)}if(B.metallicRoughnessTextureData){const U=this._exportImage(`metallicRoughness${k.length}`,W,B.metallicRoughnessTextureData);l.metallicRoughnessTexture=this._exportTextureInfo(U,M,null===p||void 0===p?void 0:p.coordinatesIndex)}return B}return this._convertSpecularGlossinessToMetallicRoughness(t)}async exportPBRMaterialAsync(U,W,l){const M={},t={name:U.name},L=U.isMetallicWorkflow();if(L){const W=U._albedoColor,l=U.alpha;W&&(M.baseColorFactor=[W.r,W.g,W.b,l])}const p=L?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(U,W,M,l):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(U,W,M,l);await this._setMetallicRoughnessPbrMaterialAsync(p,U,t,M,W,l),await this._finishMaterialAsync(t,U,W);const B=this._exporter._materials;return B.push(t),B.length-1}async _setMetallicRoughnessPbrMaterialAsync(U,W,l,M,L,p){if(x(l,W),U.baseColor.equalsWithEpsilon(d,i)&&g.WithinEpsilon(W.alpha,1,i)||(M.baseColorFactor=[U.baseColor.r,U.baseColor.g,U.baseColor.b,W.alpha]),null!=U.metallic&&1!==U.metallic&&(M.metallicFactor=U.metallic),null!=U.roughness&&1!==U.roughness&&(M.roughnessFactor=U.roughness),null==W.sk||W.sk||(W._twoSidedLighting||t.h.Warn(W.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),l.doubleSided=!0),p){const U=[],M=W._bumpTexture;M&&U.push(this.exportTextureAsync(M,L).then((U=>{U&&(l.normalTexture=U,1!==M.level&&(l.normalTexture.scale=M.level))})));const t=W._ambientTexture;t&&U.push(this.exportTextureAsync(t,L).then((U=>{if(U){const M={index:U.index,texCoord:U.texCoord,extensions:U.extensions};l.occlusionTexture=M;const t=W._ambientTextureStrength;t&&(M.strength=t)}})));const p=W._emissiveTexture;p&&U.push(this.exportTextureAsync(p,L).then((U=>{U&&(l.emissiveTexture=U)}))),U.length>0&&(this._exporter._materialNeedsUVsSet.add(W),await Promise.all(U))}const B=W._emissiveColor;B.equalsWithEpsilon(H,i)||(l.emissiveFactor=B.qk()),l.pbrMetallicRoughness=M}_getPixelsFromTextureAsync(U){return function(U){switch(U){case D.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(U.textureFormat)?(0,E.f)(U,U._texture.width,U._texture.height):(U.textureType,D.c.TEXTURETYPE_UNSIGNED_BYTE,U.readPixels())}async exportTextureAsync(U,W){const l=this._exporter._extensionsPreExportTextureAsync("exporter",U,W);return l?await l.then((async l=>l?await this._exportTextureInfoAsync(l,W):await this._exportTextureInfoAsync(U,W))):await this._exportTextureInfoAsync(U,W)}async _exportTextureInfoAsync(U,W){let l=this._textureMap.get(U);if(!l){const M=await this._getPixelsFromTextureAsync(U);if(!M)return null;const L=this._exportTextureSampler(U),p=U.mimeType;if(p)switch(p){case"image/jpeg":case"image/png":case"image/webp":W=p;break;default:t.h.Warn(`Unsupported media type: ${p}. Exporting texture as PNG.`)}const B=this._internalTextureToImage,k=U.getInternalTexture().uniqueId;B[k]||(B[k]={});let A=B[k][W];if(void 0===A){const l=U.getSize();A=(async()=>{const t=await this._getImageDataAsync(M,l.width,l.height,W);return this._exportImage(U.name,W,t)})(),B[k][W]=A}l=this._exportTextureInfo(await A,L,U.coordinatesIndex),this._textureMap.set(U,l),this._exporter._extensionsPostExportTextures("exporter",l,U)}return l}_exportImage(U,W,l){const M=this._exporter._images;let L;if(this._exporter._shouldUseGlb){L={name:U,mimeType:W,bufferView:void 0};const M=this._exporter._bufferManager.createBufferView(new Uint8Array(l));this._exporter._bufferManager.setBufferView(L,M)}else{const p=U.replace(/\.\/|\/|\.\\|\\/g,"_"),B=function(U){switch(U){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(W);let k=p+B;M.some((U=>U.uri===k))&&(k=`${p}_${t.h.RandomId()}${B}`),L={name:U,uri:k},this._exporter._imageData[k]={data:l,mimeType:W}}return M.push(L),M.length-1}_exportTextureInfo(U,W,l){const M=this._exporter._textures;let t=M.findIndex((l=>l.sampler==W&&l.source===U));-1===t&&(t=M.length,M.push({source:U,sampler:W}));const L={index:t};return l&&(L.texCoord=l),L}_exportTextureSampler(U){const W=this._getTextureSampler(U),l=this._exporter._samplers,M=l.findIndex((U=>U.minFilter===W.minFilter&&U.magFilter===W.magFilter&&U.wrapS===W.wrapS&&U.wrapT===W.wrapT));return-1!==M?M:(l.push(W),l.length-1)}}var v=l(772),J=l(512),Q=l(11789),G=l(711);const u=M.l.Zero(),b=M.e.Identity(),C=M.l.One(),P=new M.l(-1,1,1);function S(U,W){const{byteOffset:l,byteStride:M,type:t,normalized:L}=U,p=U.getSize(),B=W.reduce(((U,W)=>W.getTotalVertices()>U?W.getTotalVertices():U),-Number.MAX_VALUE);return{byteOffset:l,byteStride:M,componentCount:p,type:t,count:B*p,normalized:L,totalVertices:B,kind:U.getKind()}}function c(U){switch(U){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function h(U){switch(U){case q.e.PositionKind:case q.e.NormalKind:case q.e.TangentKind:case q.e.ColorKind:case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:case q.e.MatricesWeightsKind:case q.e.MatricesWeightsExtraKind:case q.e.UVKind:case q.e.UV2Kind:case q.e.UV3Kind:case q.e.UV4Kind:case q.e.UV5Kind:case q.e.UV6Kind:return!0}return!1}function z(U){switch(U){case L.b.TriangleFillMode:return 4;case L.b.TriangleStripDrawMode:return 5;case L.b.TriangleFanDrawMode:return 6;case L.b.PointListDrawMode:case L.b.PointFillMode:return 0;case L.b.LineLoopDrawMode:return 2;case L.b.LineListDrawMode:return 1;case L.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${U}`)}function a(U){const W=Math.sqrt(U.x*U.x+U.y*U.y+U.z*U.z);W>0&&(U.x/=W,U.y/=W,U.z/=W)}function Y(U){return U.x*=-1,U}function X(U){if(U.x*U.x+U.y*U.y>.5){const W=Math.abs(U.x),l=Math.abs(U.y);if(W>l){const l=Math.sign(U.x);U.x=W,U.y*=-l,U.z*=-l,U.w*=l}else{const W=Math.sign(U.y);U.x*=-W,U.y=l,U.z*=W,U.w*=-W}}else{const W=Math.abs(U.z),l=Math.abs(U.w);if(W>l){const l=Math.sign(U.z);U.x*=-l,U.y*=l,U.z=W,U.w*=-l}else{const W=Math.sign(U.w);U.x*=W,U.y*=-W,U.z*=-W,U.w=l}}return U}function T(U){U.wd(-U.z,U.w,U.x,-U.y)}function UU(U,W){const l=M.l.FromArrayToRef(W.translation||[0,0,0],0,M.f.ik[0]),t=M.e.FromArrayToRef(W.rotation||[0,0,0,1],0,M.f.Quaternion[0]),L=M.c.ComposeToRef(C,t,l,M.f.Matrix[0]),p=M.l.FromArrayToRef(U.translation||[0,0,0],0,M.f.ik[2]),B=M.e.FromArrayToRef(U.rotation||[0,0,0,1],0,M.f.Quaternion[1]),k=M.c.ComposeToRef(C,B,p,M.f.Matrix[1]);L.multiplyToRef(k,k),k.decompose(void 0,t,l),l.equalsWithEpsilon(u,G.d)?delete W.translation:W.translation=l.qk(),t.equalsWithEpsilon(b,G.d)?delete W.rotation:W.rotation=t.qk(),W.scale&&delete W.scale}function WU(U,W){if(!(W instanceof y.d))return!1;if(!(1===W.getChildren().length&&0===U.getChildren().length&&U.parent===W))return!1;const l=U.va(),M=U instanceof Q.b&&!l.useRightHandedSystem?P:C;return!!W.yd.equalsWithEpsilon(M,G.d)||(J.b.Warn(`Cannot collapse node ${U.name} into parent node ${W.name} with modified scaling.`),!1)}function lU(U){if(U instanceof Array){const W=new Float32Array(U);return new Uint8Array(W.buffer,W.byteOffset,W.byteLength)}return ArrayBuffer.isView(U)?new Uint8Array(U.buffer,U.byteOffset,U.byteLength):new Uint8Array(U)}function MU(U,W){for(const[l,M]of Object.entries(U)){const t=W[l];(Array.isArray(M)&&Array.isArray(t)&&tU(M,t)||M===t)&&delete U[l]}return U}function tU(U,W){return U.length===W.length&&U.every(((U,l)=>U===W[l]))}const LU=M.c.Compose(new M.l(-1,1,1),M.e.Identity(),M.l.Zero());function pU(U,W){if(!(U instanceof y.d))return!1;if(W){if(!U.getWorldMatrix().equalsWithEpsilon(M.c.IdentityReadOnly,G.d))return!1}else{if(!U.getWorldMatrix().multiplyToRef(LU,M.f.Matrix[0]).equalsWithEpsilon(M.c.IdentityReadOnly,G.d))return!1}return!(U instanceof j.c&&U.vk)}const BU=new Map([[Int8Array,(U,W,l)=>U.setInt8(W,l)],[Uint8Array,(U,W,l)=>U.setUint8(W,l)],[Uint8ClampedArray,(U,W,l)=>U.setUint8(W,l)],[Int16Array,(U,W,l)=>U.setInt16(W,l,!0)],[Uint16Array,(U,W,l)=>U.setUint16(W,l,!0)],[Int32Array,(U,W,l)=>U.setInt32(W,l,!0)],[Uint32Array,(U,W,l)=>U.setUint32(W,l,!0)],[Float32Array,(U,W,l)=>U.setFloat32(W,l,!0)],[Float64Array,(U,W,l)=>U.setFloat64(W,l,!0)]]);class kU{writeTypedArray(U){this._checkGrowBuffer(U.byteLength);const W=BU.get(U.constructor);for(let l=0;l<U.length;l++)W(this._dataView,this._byteOffset,U[l]),this._byteOffset+=U.BYTES_PER_ELEMENT}constructor(U){this._data=new Uint8Array(U),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(U){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,U),this._byteOffset++}writeInt8(U){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,U),this._byteOffset++}writeInt16(U){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,U,!0),this._byteOffset+=2}writeUInt16(U){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,U,!0),this._byteOffset+=2}writeInt32(U){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,U,!0),this._byteOffset+=4}writeUInt32(U){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat32(U){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,U,!0),this._byteOffset+=4}writeFloat64(U){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,U,!0),this._byteOffset+=8}_checkGrowBuffer(U){const W=this.byteOffset+U;if(W>this._data.byteLength){const U=new Uint8Array(2*W);U.set(this._data),this._data=U,this._dataView=new DataView(this._data.buffer)}}}function AU(U){return U%4===0?4:U%2===0?2:1}class qU{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(U){let W=0;this._bufferViewToData.forEach((U=>{W+=U.byteLength}));const l=new kU(W),M=Array.from(this._bufferViewToData.keys()).sort(((U,W)=>AU(W.byteLength)-AU(U.byteLength)));for(const t of M){t.byteOffset=l.byteOffset,U.push(t);const W=U.length-1,M=this.getPropertiesWithBufferView(t);for(const U of M)U.bufferView=W;l.writeTypedArray(this._bufferViewToData.get(t)),this._bufferViewToData.delete(t)}return l.getOutputData()}createBufferView(U,W){const l={buffer:0,byteOffset:void 0,byteLength:U.byteLength,byteStride:W};return this._bufferViewToData.set(l,U),l}createAccessor(U,W,l,M,t,L,p){this._verifyBufferView(U);const B={bufferView:void 0,componentType:l,count:M,type:W,min:null===L||void 0===L?void 0:L.min,max:null===L||void 0===L?void 0:L.max,normalized:p,byteOffset:t};return this.setBufferView(B,U),this._accessorToBufferView.set(B,U),B}setBufferView(U,W){this._verifyBufferView(W);this.getPropertiesWithBufferView(W).push(U)}removeBufferView(U){const W=this.getPropertiesWithBufferView(U);for(const l of W)void 0!==l.bufferView&&delete l.bufferView;this._bufferViewToData.delete(U),this._bufferViewToProperties.delete(U),this._accessorToBufferView.forEach(((W,l)=>{W===U&&(void 0!==l.byteOffset&&delete l.byteOffset,this._accessorToBufferView.delete(l))}))}getBufferView(U){const W=this._accessorToBufferView.get(U);return this._verifyBufferView(W),W}getPropertiesWithBufferView(U){return this._verifyBufferView(U),this._bufferViewToProperties.set(U,this._bufferViewToProperties.get(U)??[]),this._bufferViewToProperties.get(U)}getData(U){return this._verifyBufferView(U),this._bufferViewToData.get(U)}_verifyBufferView(U){if(void 0===U||!this._bufferViewToData.has(U))throw new Error(`BufferView ${U} not found in BufferManager.`)}}var yU,jU=l(677),sU=l(875),wU=l(11798),KU=l(11851),rU=l(11860),mU=l(11864),fU=l(487),gU=l(11868);!function(U){U[U.INTANGENT=0]="INTANGENT",U[U.OUTTANGENT=1]="OUTTANGENT"}(yU||(yU={}));class EU{static _IsTransformable(U){return U&&(U instanceof y.d||U instanceof jU.d||U instanceof gU.c)}static _CreateNodeAnimation(U,W,l,M,L){if(this._IsTransformable(U)){const p=[],B=[],k=W.getKeys(),A=EU._CalculateMinMaxKeyFrames(k),q=EU._DeduceInterpolation(k,l,M),y=q.interpolationType,j=q.shouldBakeAnimation;if(j?EU._CreateBakedAnimation(U,W,l,A.min,A.max,W.framePerSecond,L,p,B,A,M):"LINEAR"===y||"STEP"===y?EU._CreateLinearOrStepAnimation(U,W,l,p,B,M):"CUBICSPLINE"===y?EU._CreateCubicSplineAnimation(U,W,l,p,B,M):EU._CreateBakedAnimation(U,W,l,A.min,A.max,W.framePerSecond,L,p,B,A,M),p.length&&B.length){return{inputs:p,outputs:B,samplerInterpolation:y,inputsMin:j?A.min:t.h.FloatRound(A.min/W.framePerSecond),inputsMax:j?A.max:t.h.FloatRound(A.max/W.framePerSecond)}}}return null}static _DeduceAnimationInfo(U){let W=null,l="VEC3",M=!1;const L=U.targetProperty.split(".");switch(L[0]){case"yd":W="scale";break;case"position":W="translation";break;case"rotation":l="VEC4",W="rotation";break;case"rotationQuaternion":l="VEC4",M=!0,W="rotation";break;case"influence":l="SCALAR",W="weights";break;default:t.h.Error(`Unsupported animatable property ${L[0]}`)}return W?{animationChannelTargetPath:W,dataAccessorType:l,useQuaternion:M}:(t.h.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(U,W,l,M,t,L,p,B,k,A,q){let y;if(EU._IsTransformable(U)&&U.animations)for(const j of U.animations){if(q&&!q(j))continue;const t=EU._DeduceAnimationInfo(j);t&&(y={name:j.name,samplers:[],channels:[]},EU._AddAnimation(`${j.name}`,j.hasRunningRuntimeAnimations?W:y,U,j,t.dataAccessorType,t.animationChannelTargetPath,M,L,p,B,t.useQuaternion,k,A),y.samplers.length&&y.channels.length&&l.push(y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(U,W,l,M,t,L,p,B,k,A,q){let y;if(U instanceof fU.e){const t=U.morphTargetManager;if(t)for(let j=0;j<t.numTargets;++j){const s=t.getTarget(j);for(const w of s.animations){if(q&&!q(w))continue;const s=new rU.c(`${w.name}`,"influence",w.framePerSecond,w.dataType,w.loopMode,w.enableBlending),K=[],r=w.getKeys();for(let U=0;U<r.length;++U){const W=r[U];for(let U=0;U<t.numTargets;++U)U==j?K.push(W):K.push({frame:W.frame,value:0})}s.setKeys(K);const m=EU._DeduceAnimationInfo(s);m&&(y={name:s.name,samplers:[],channels:[]},EU._AddAnimation(w.name,w.hasRunningRuntimeAnimations?W:y,U,s,m.dataAccessorType,m.animationChannelTargetPath,M,L,p,B,m.useQuaternion,k,A,t.numTargets),y.samplers.length&&y.channels.length&&l.push(y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(U,W,l,M,t,L,p,B,k){let A;if(U.animationGroups){const y=U.animationGroups;for(const j of y){const y=new Map,s=new Map,w=new Set,K=j.to-j.from;A={name:j.name,channels:[],samplers:[]};for(let W=0;W<j.targetedAnimations.length;++W){const K=j.targetedAnimations[W],r=K.target,m=K.animation;if(k&&!k(m))continue;const f=B.has(r);if(this._IsTransformable(r)||1===r.length&&this._IsTransformable(r[0])){const U=EU._DeduceAnimationInfo(K.animation);if(U){const W=this._IsTransformable(r)?r:this._IsTransformable(r[0])?r[0]:null;W&&EU._AddAnimation(`${m.name}`,A,W,m,U.dataAccessorType,U.animationChannelTargetPath,l,M,t,L,U.useQuaternion,p,f)}}else if(r instanceof mU.b||1===r.length&&r[0]instanceof mU.b){if(EU._DeduceAnimationInfo(K.animation)){const W=r instanceof mU.b?r:r[0];if(W){const l=U.morphTargetManagers.find((U=>{for(let l=0;l<U.numTargets;++l)if(U.getTarget(l)===W)return!0;return!1}));if(l){const M=U.meshes.find((U=>U.morphTargetManager===l));var q;if(M)y.has(M)||y.set(M,new Map),null===(q=y.get(M))||void 0===q||q.set(W,m),w.add(M),s.set(M,m)}}}}}w.forEach((U=>{const W=U.morphTargetManager;let B=null;const k=[],q=s.get(U).getKeys(),w=q.length;for(let l=0;l<w;++l)for(let M=0;M<W.numTargets;++M){const t=W.getTarget(M),L=y.get(U);if(L){const W=L.get(t);W?(B||(B=new rU.c(`${j.name}_${U.name}_MorphWeightAnimation`,"influence",W.framePerSecond,rU.c.ANIMATIONTYPE_FLOAT,W.loopMode,W.enableBlending)),k.push(W.getKeys()[l])):k.push({frame:j.from+K/w*l,value:t.influence,inTangent:q[0].inTangent?0:void 0,outTangent:q[0].outTangent?0:void 0})}}B.setKeys(k);const r=EU._DeduceAnimationInfo(B);r&&EU._AddAnimation(`${j.name}_${U.name}_MorphWeightAnimation`,A,U,B,r.dataAccessorType,r.animationChannelTargetPath,l,M,t,L,r.useQuaternion,p,!1,null===W||void 0===W?void 0:W.numTargets)})),A.channels.length&&A.samplers.length&&W.push(A)}}}static _AddAnimation(U,W,l,t,L,p,B,k,A,q,y,j,s,w){const K=EU._CreateNodeAnimation(l,t,p,y,j);let r,m,f,g,E,Z;if(K){if(w){let U=0,W=0;const l=[];for(;K.inputs.length>0;)W=K.inputs.shift(),U%w==0&&l.push(W),U++;K.inputs=l}const U=B.get(l),t=new Float32Array(K.inputs);r=k.createBufferView(t),m=k.createAccessor(r,"SCALAR",5126,K.inputs.length,void 0,{min:[K.inputsMin],max:[K.inputsMax]}),q.push(m),f=q.length-1;const A=new M.e,y=new M.l,j=new M.l,N=l instanceof jU.d,D=c(L),o=new Float32Array(K.outputs.length*D);K.outputs.forEach((function(U,W){let l=U;switch(p){case"translation":s&&(M.l.FromArrayToRef(U,0,j),Y(j),j.toArray(l));break;case"rotation":4===U.length?M.e.FromArrayToRef(U,0,A):(l=new Array(4),M.l.FromArrayToRef(U,0,y),M.e.FromEulerVectorToRef(y,A)),s&&(X(A),N&&T(A)),A.toArray(l)}o.set(l,W*D)})),r=k.createBufferView(o),m=k.createAccessor(r,L,5126,K.outputs.length),q.push(m),g=q.length-1,E={interpolation:K.samplerInterpolation,input:f,output:g},W.samplers.push(E),Z={sampler:W.samplers.length-1,target:{node:U,path:p}},W.channels.push(Z)}}static _CreateBakedAnimation(U,W,l,L,p,B,k,A,q,y,j){let s;const w=M.e.Identity();let K,r=null,m=null,f=null,g=null,E=null,Z=null;y.min=t.h.FloatRound(L/B);const N=W.getKeys();for(let M=0,D=N.length;M<D;++M){if(Z=null,f=N[M],M+1<D)if(g=N[M+1],f.value.equals&&f.value.equals(g.value)||f.value===g.value){if(0!==M)continue;Z=f.frame}else Z=g.frame;else{if(E=N[M-1],f.value.equals&&f.value.equals(E.value)||f.value===E.value)continue;Z=p}if(Z)for(let M=f.frame;M<=Z;M+=k){if(K=t.h.FloatRound(M/B),K===r)continue;r=K,m=K;const L={key:0,repeatCount:0,loopMode:W.loopMode};s=W._interpolate(M,L),EU._SetInterpolatedValue(U,s,K,W,l,w,A,q,j)}}m&&(y.max=m)}static _ConvertFactorToVector3OrQuaternion(U,W,l,L,p){const B=EU._GetBasePositionRotationOrScale(W,L,p),k=l.targetProperty.split("."),A=k?k[1]:"",q=p?M.e.gk(B).normalize():M.l.gk(B);switch(A){case"x":case"y":case"z":q[A]=U;break;case"w":q.w=U;break;default:t.h.Error(`glTFAnimation: Unsupported component name "${A}"!`)}return q}static _SetInterpolatedValue(U,W,l,t,L,p,B,k,A){let q;B.push(l),"weights"!==L?(t.dataType===rU.c.ANIMATIONTYPE_FLOAT&&(W=this._ConvertFactorToVector3OrQuaternion(W,U,t,L,A)),"rotation"===L?(A?p=W:(q=W,M.e.RotationYawPitchRollToRef(q.y,q.x,q.z,p)),k.push(p.qk())):(q=W,k.push(q.qk()))):k.push([W])}static _CreateLinearOrStepAnimation(U,W,l,M,t,L){for(const p of W.getKeys())M.push(p.frame/W.framePerSecond),EU._AddKeyframeValue(p,W,t,l,U,L)}static _CreateCubicSplineAnimation(U,W,l,M,t,L){W.getKeys().forEach((function(p){M.push(p.frame/W.framePerSecond),EU._AddSplineTangent(yU.INTANGENT,t,l,"CUBICSPLINE",p,L),EU._AddKeyframeValue(p,W,t,l,U,L),EU._AddSplineTangent(yU.OUTTANGENT,t,l,"CUBICSPLINE",p,L)}))}static _GetBasePositionRotationOrScale(U,W,l){let t;if("rotation"===W)if(l){t=(U.rotationQuaternion??M.e.Identity()).qk()}else{t=(U.rotation??M.l.Zero()).qk()}else if("translation"===W){t=(U.position??M.l.Zero()).qk()}else{t=(U.yd??M.l.One()).qk()}return t}static _AddKeyframeValue(U,W,l,L,p,B){let k;const A=W.dataType;if(A===rU.c.ANIMATIONTYPE_VECTOR3){let W=U.value.qk();if("rotation"===L){const U=M.l.gk(W);W=M.e.RotationYawPitchRoll(U.y,U.x,U.z).qk()}l.push(W)}else if(A===rU.c.ANIMATIONTYPE_FLOAT){if("weights"===L)l.push([U.value]);else if(k=this._ConvertFactorToVector3OrQuaternion(U.value,p,W,L,B),k){if("rotation"===L){const U=B?k:M.e.RotationYawPitchRoll(k.y,k.x,k.z).normalize();l.push(U.qk())}l.push(k.qk())}}else A===rU.c.ANIMATIONTYPE_QUATERNION?l.push(U.value.normalize().qk()):t.h.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(U,W,l){let M,t,L=!1;if("rotation"===W&&!l)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let p=0,B=U.length;p<B;++p)if(t=U[p],t.inTangent||t.outTangent)if(M){if("CUBICSPLINE"!==M){M="LINEAR",L=!0;break}}else M="CUBICSPLINE";else if(M){if("CUBICSPLINE"===M||t.interpolation&&1===t.interpolation&&"STEP"!==M){M="LINEAR",L=!0;break}}else M=t.interpolation&&1===t.interpolation?"STEP":"LINEAR";return M||(M="LINEAR"),{interpolationType:M,shouldBakeAnimation:L}}static _AddSplineTangent(U,W,l,t,L,p){let B;const k=U===yU.INTANGENT?L.inTangent:L.outTangent;if("CUBICSPLINE"===t){if("rotation"===l)if(k)if(p)B=k.qk();else{const U=k;B=M.e.RotationYawPitchRoll(U.y,U.x,U.z).qk()}else B=[0,0,0,0];else B="weights"===l?k?[k]:[0]:k?k.qk():[0,0,0];W.push(B)}}static _CalculateMinMaxKeyFrames(U){let W=1/0,l=-1/0;return U.forEach((function(U){W=Math.min(W,U.frame),l=Math.max(l,U.frame)})),{min:W,max:l}}}function ZU(U,W,l,L,p,B){const k={attributes:{},influence:U.influence,name:U.name},A=W.vk;if(!A)return t.h.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),k;const y=B?-1:1,j=M.l.Zero();let s=0,w=0;if(U.hasPositions){const L=U.getPositions(),B=A.getVerticesData(q.e.PositionKind);if(B){const U=new Float32Array(B.length),W=[1/0,1/0,1/0],t=[-1/0,-1/0,-1/0];w=B.length/3,s=0;for(let l=s;l<w;++l){const p=M.l.gk(B,3*l);M.l.gk(L,3*l).subtractToRef(p,j),j.x*=y,W[0]=Math.min(W[0],j.x),t[0]=Math.max(t[0],j.x),W[1]=Math.min(W[1],j.y),t[1]=Math.max(t[1],j.y),W[2]=Math.min(W[2],j.z),t[2]=Math.max(t[2],j.z),U[3*l]=j.x,U[3*l+1]=j.y,U[3*l+2]=j.z}const A=l.createBufferView(U,12),q=l.createAccessor(A,"VEC3",5126,L.length/3,0,{min:W,max:t});p.push(q),k.attributes.POSITION=p.length-1}else t.h.Warn(`Morph target positions for mesh ${W.name} were not exported. Mesh does not have position vertex data`)}if(U.hasNormals){const L=U.getNormals(),B=A.getVerticesData(q.e.NormalKind);if(B){const U=new Float32Array(B.length);w=B.length/3,s=0;for(let l=s;l<w;++l){const W=M.l.gk(B,3*l).normalize();M.l.gk(L,3*l).normalize().subtractToRef(W,j),U[3*l]=j.x*y,U[3*l+1]=j.y,U[3*l+2]=j.z}const W=l.createBufferView(U,12),t=l.createAccessor(W,"VEC3",5126,L.length/3,0);p.push(t),k.attributes.NORMAL=p.length-1}else t.h.Warn(`Morph target normals for mesh ${W.name} were not exported. Mesh does not have normals vertex data`)}if(U.hasTangents){const L=U.getTangents(),B=A.getVerticesData(q.e.TangentKind);if(B){w=B.length/4;const U=new Float32Array(3*w);s=0;for(let l=s;l<w;++l){const W=M.l.gk(B,4*l);a(W);const t=M.l.gk(L,3*l);a(t),t.subtractToRef(W,j),U[3*l]=j.x*y,U[3*l+1]=j.y,U[3*l+2]=j.z}const W=l.createBufferView(U,12),t=l.createAccessor(W,"VEC3",5126,w,0);p.push(t),k.attributes.TANGENT=p.length-1}else t.h.Warn(`Morph target tangents for mesh ${W.name} were not exported. Mesh does not have tangents vertex data`)}if(U.hasColors){const L=U.getColors(),B=A.getVerticesData(q.e.ColorKind),y=A.getVertexBuffer(q.e.ColorKind);if(B&&y){const U=y.getSize();w=B.length/U;const W=new Float32Array(w*U);s=0;for(let l=s;l<w;++l)if(3===U){const t=M.l.gk(B,l*U);M.l.gk(L,l*U).subtractToRef(t,j),W[3*l]=j.x,W[3*l+1]=j.y,W[3*l+2]=j.z}else if(4===U){const t=new M.p,p=M.p.gk(B,l*U);M.p.gk(L,l*U).subtractToRef(p,t),W[4*l]=t.x,W[4*l+1]=t.y,W[4*l+2]=t.z,W[4*l+3]=t.w}else t.h.Warn(`Unsupported number of components for color attribute: ${U}`);const A=l.createBufferView(W,4*U),q=l.createAccessor(A,3===U?"VEC3":"VEC4",5126,w,0);p.push(q),k.attributes.COLOR_0=p.length-1}else t.h.Warn(`Morph target colors for mesh ${W.name} were not exported. Mesh does not have colors vertex data`)}return k}var NU=l(11873),DU=l(11821),oU=l(11816),iU=l(655);class OU{}OU.DEFAULT_COLOR=r.e.White(),OU.DEFAULT_WIDTH_ATTENUATED=1,OU.DEFAULT_WIDTH=.1;var eU=l(2024),dU=l(11881);class HU{static ConvertPoints(U,W){if(U.length&&Array.isArray(U)&&"number"===typeof U[0])return[U];if(U.length&&Array.isArray(U[0])&&"number"===typeof U[0][0])return U;if(U.length&&!Array.isArray(U[0])&&U[0]instanceof M.l){const W=[];for(let l=0;l<U.length;l++){const M=U[l];W.push(M.x,M.y,M.z)}return[W]}if(U.length>0&&Array.isArray(U[0])&&U[0].length>0&&U[0][0]instanceof M.l){const W=[],l=U;for(const U of l)W.push(U.flatMap((U=>[U.x,U.y,U.z])));return W}if(U instanceof Float32Array){if(null!==W&&void 0!==W&&W.floatArrayStride){const l=[],M=3*W.floatArrayStride;for(let W=0;W<U.length;W+=M){const t=new Array(M);for(let l=0;l<M;l++)t[l]=U[W+l];l.push(t)}return l}return[Array.from(U)]}if(U.length&&U[0]instanceof Float32Array){const W=[];for(const l of U)W.push(Array.from(l));return W}return[]}static OmitZeroLengthPredicate(U,W,l){const M=[];return W.de(U).lengthSquared()>0&&M.push([U,W]),l.de(W).lengthSquared()>0&&M.push([W,l]),U.de(l).lengthSquared()>0&&M.push([l,U]),0===M.length?null:M}static OmitDuplicatesPredicate(U,W,l,M){const t=[];return HU._SearchInPoints(U,W,M)||t.push([U,W]),HU._SearchInPoints(W,l,M)||t.push([W,l]),HU._SearchInPoints(l,U,M)||t.push([l,U]),0===t.length?null:t}static _SearchInPoints(U,W,l){for(const p of l)for(let l=0;l<p.length;l++){var M,t,L;if(null!==(M=p[l])&&void 0!==M&&M.equals(U))if(null!==(t=p[l+1])&&void 0!==t&&t.equals(W)||null!==(L=p[l-1])&&void 0!==L&&L.equals(W))return!0}return!1}static MeshesToLines(U,W){const l=[];for(let t=0;t<U.length;t++){const L=U[t],p=L.getVerticesData(q.e.PositionKind),B=L.hk();if(p&&B)for(let U=0,k=0;U<B.length;U++){const A=3*B[k++],q=3*B[k++],y=3*B[k++],j=new M.l(p[A],p[A+1],p[A+2]),s=new M.l(p[q],p[q+1],p[q+2]),w=new M.l(p[y],p[y+1],p[y+2]);if(W){const M=W(j,s,w,l,U,A,L,t,p,B);if(M)for(const U of M)l.push(U)}else l.push([j,s],[s,w],[w,j])}}return l}static ToVector3Array(U){if(Array.isArray(U[0])){const W=[],l=U;for(const U of l){const l=[];for(let W=0;W<U.length;W+=3)l.push(new M.l(U[W],U[W+1],U[W+2]));W.push(l)}return W}const W=U,l=[];for(let t=0;t<W.length;t+=3)l.push(new M.l(W[t],W[t+1],W[t+2]));return l}static ToNumberArray(U){return U.flatMap((U=>[U.x,U.y,U.z]))}static GetPointsCountInfo(U){const W=new Array(U.length);let l=0;for(let M=U.length;M--;)W[M]=U[M].length/3,l+=W[M];return{total:l,counts:W}}static GetLineLength(U){if(0===U.length)return 0;let W;W="number"===typeof U[0]?HU.ToVector3Array(U):U;const l=M.f.ik[0];let t=0;for(let M=0;M<W.length-1;M++){const U=W[M];t+=W[M+1].subtractToRef(U,l).length()}return t}static GetLineLengthArray(U){const W=new Float32Array(U.length/3);let l=0;for(let M=0,t=U.length/3-1;M<t;M++){let t=U[3*M+0],L=U[3*M+1],p=U[3*M+2];t-=U[3*M+3],L-=U[3*M+4],p-=U[3*M+5];l+=Math.sqrt(t*t+L*L+p*p),W[M+1]=l}return W}static SegmentizeSegmentByCount(U,W,l){const t=[],L=W.de(U),p=M.f.ik[0];p.jk(l);const B=M.f.ik[1];L.divideToRef(p,B);let k=U.clone();t.push(k);for(let M=0;M<l;M++)k=k.clone(),t.push(k.addInPlace(B));return t}static SegmentizeLineBySegmentLength(U,W){const l=U[0]instanceof M.l?HU.GetLineSegments(U):"number"===typeof U[0]?HU.GetLineSegments(HU.ToVector3Array(U)):U,t=[];for(const M of l)if(M.length>W){const U=HU.SegmentizeSegmentByCount(M.point1,M.point2,Math.ceil(M.length/W));for(const W of U)t.push(W)}else t.push(M.point1),t.push(M.point2);return t}static SegmentizeLineBySegmentCount(U,W){const l="number"===typeof U[0]?HU.ToVector3Array(U):U,M=HU.GetLineLength(l)/W;return HU.SegmentizeLineBySegmentLength(l,M)}static GetLineSegments(U){const W=[];for(let l=0;l<U.length-1;l++){const M=U[l],t=U[l+1],L=t.de(M).length();W.push({point1:M,point2:t,length:L})}return W}static GetMinMaxSegmentLength(U){const W=HU.GetLineSegments(U).sort((U=>U.length));return{min:W[0].length,max:W[W.length-1].length}}static GetPositionOnLineByVisibility(U,W,l){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=W*l;let p=0,B=0;const k=U.length;for(let M=0;M<k;M++){if(L<=p+U[M].length){B=M;break}p+=U[M].length}const A=(L-p)/U[B].length;return U[B].point2.subtractToRef(U[B].point1,M.f.ik[0]),M.f.ik[1]=M.f.ik[0].multiplyByFloats(A,A,A),t||M.f.ik[1].addInPlace(U[B].point1),M.f.ik[1].clone()}static GetCircleLinePoints(U,W){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:U,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/W;const p=[];for(let B=0;B<=W;B++)p.push(new M.l(Math.cos(B*L)*U,Math.sin(B*L)*t,l));return p}static GetBezierLinePoints(U,W,l,M){return eU.f.CreateQuadraticBezier(U,W,l,M).getPoints().flatMap((U=>[U.x,U.y,U.z]))}static GetArrowCap(U,W,l,M,t){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[U.clone(),U.add(W.multiplyByFloats(l,l,l))],widths:[M,t,L,p]}}static GetPointsFromText(U,W,l,M){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const p=[],B=(0,dU.b)(U,W,l,M);for(const k of B){for(const U of k.paths){const W=[],l=U.getPoints();for(const U of l)W.push(U.x,U.y,t);p.push(W)}if(L)for(const U of k.holes){const W=[],l=U.getPoints();for(const U of l)W.push(U.x,U.y,t);p.push(W)}}return p}static Color3toRGBAUint8(U){const W=new Uint8Array(4*U.length);for(let l=0,M=0;l<U.length;l++)W[M++]=255*U[l].r,W[M++]=255*U[l].g,W[M++]=255*U[l].b,W[M++]=255;return W}static CreateColorsTexture(U,W,l,M){const t=M.getEngine().getCaps().maxTextureSize??1,L=W.length>t?t:W.length,p=Math.ceil(W.length/t);p>1&&(W=[...W,...Array(L*p-W.length).fill(W[0])]);const B=HU.Color3toRGBAUint8(W),k=new N.e(B,L,p,w.c.TEXTUREFORMAT_RGBA,M,!1,!0,l);return k.name=U,k}static PrepareEmptyColorsTexture(U){if(!OU.EmptyColorsTexture){const W=new Uint8Array(4);OU.EmptyColorsTexture=new N.e(W,1,1,w.c.TEXTUREFORMAT_RGBA,U,!1,!1,N.e.NEAREST_NEAREST),OU.EmptyColorsTexture.name="grlEmptyColorsTexture"}return OU.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var U;null===(U=OU.EmptyColorsTexture)||void 0===U||U.dispose(),OU.EmptyColorsTexture=null}static BooleanToNumber(U){return U?1:0}}class VU extends oU.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class nU extends DU.c{isCompatible(U){return!0}constructor(U,W,l){var t;l=l||{color:OU.DEFAULT_COLOR};const L=new VU;L.GREASED_LINE_HAS_COLOR=!!l.color&&!l.useColors,L.GREASED_LINE_SIZE_ATTENUATION=l.sizeAttenuation??!1,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===l.colorDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(W??U.va()).useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=l.cameraFacing??!0,super(U,nU.GREASED_LINE_MATERIAL_NAME,200,L,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(t=l)||void 0===t?void 0:t.forceGLSL)||nU.ForceGLSL,this._scene=W??U.va(),this._engine=this._scene.getEngine(),this._cameraFacing=l.cameraFacing??!0,this.visibility=l.visibility??1,this.useDash=l.useDash??!1,this.dashRatio=l.dashRatio??.5,this.dashOffset=l.dashOffset??0,this.width=l.width?l.width:l.sizeAttenuation?OU.DEFAULT_WIDTH_ATTENUATED:OU.DEFAULT_WIDTH,this._sizeAttenuation=l.sizeAttenuation??!1,this.colorMode=l.colorMode??0,this._color=l.color??null,this.useColors=l.useColors??!1,this._colorsDistributionType=l.colorDistributionType??0,this.colorsSampling=l.colorsSampling??N.e.NEAREST_NEAREST,this._colors=l.za??null,this.dashCount=l.dashCount??1,this.resolution=l.resolution??new M.h(this._engine.getRenderWidth(),this._engine.getRenderHeight()),l.colorsTexture?this.colorsTexture=l.colorsTexture:this._colors?this.colorsTexture=HU.CreateColorsTexture(`${U.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??OU.DEFAULT_COLOR,HU.PrepareEmptyColorsTexture(this._scene)),this._engine.nk.add((()=>{HU.DisposeEmptyColorsTexture()}))}getAttributes(U){U.push("grl_offsets"),U.push("grl_widths"),U.push("grl_colorPointers"),U.push("grl_counters"),this._cameraFacing?(U.push("grl_previousAndSide"),U.push("grl_nextAndCounters")):U.push("grl_slopes")}getSamplers(U){U.push("grl_colors")}getActiveTextures(U){this.colorsTexture&&U.push(this.colorsTexture)}getUniforms(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const W=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&W.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===U&&W.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:W,vertex:this._cameraFacing&&this._isGLSL(U)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(U)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(U){if(this._cameraFacing){U.wk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||U.wk("viewProjection",this._scene.getTransformMatrix());const W=M.f.Vector4[0];W.x=this._aspect,W.y=this._resolution.x,W.z=this._resolution.y,W.w=this.width,U.updateVector4("grl_aspect_resolution_lineWidth",W)}const W=M.f.Vector4[0];W.x=HU.BooleanToNumber(this.useDash),W.y=this._dashArray,W.z=this.dashOffset,W.w=this.dashRatio,U.updateVector4("grl_dashOptions",W);const l=M.f.Vector4[1];l.x=this.colorMode,l.y=this.visibility,l.z=this.colorsTexture?this.colorsTexture.getSize().width:0,l.w=HU.BooleanToNumber(this.useColors),U.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",l),this._color&&U.updateColor3("grl_singleColor",this._color);const t=this.colorsTexture??OU.EmptyColorsTexture;U.setTexture("grl_colors",t),U.updateFloat2("grl_textureSize",(null===t||void 0===t?void 0:t.getSize().width)??1,(null===t||void 0===t?void 0:t.getSize().height)??1)}prepareDefines(U,W,l){U.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,U.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,U.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,U.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=W.useRightHandedSystem,U.GREASED_LINE_CAMERA_FACING=this._cameraFacing,U.GREASED_LINE_USE_OFFSETS=!!l.offsets}getClassName(){return nU.GREASED_LINE_MATERIAL_NAME}getCustomCode(U){let W=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(W)?function(U,W){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return W&&(U["!gl_Position\\=viewProjection\\*worldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(U,this._cameraFacing):function(U,W){if("vertex"===U){const U={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return W&&(U["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),U}return"fragment"===U?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(U,this._cameraFacing)}dispose(){var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),super.dispose()}get za(){return this._colors}set za(U){this.setColors(U)}setColors(U){var W;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(W=this._colors)||void 0===W?void 0:W.length)??0;var L;if(this._colors=U,null!==U&&0!==U.length){if(!l||M)if(this.colorsTexture&&t===U.length&&!M){const W=HU.Color3toRGBAUint8(U);this.colorsTexture.update(W)}else{var p;null===(p=this.colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=HU.CreateColorsTexture(`${this._material.name}-colors-texture`,U,this.colorsSampling,this._scene)}}else null===(L=this.colorsTexture)||void 0===L||L.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.markAllDefinesAsDirty()}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==U||null!==this._color&&null===U?(this._color=U,W||this.markAllDefinesAsDirty()):this._color=U}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(U){this._aspect=U.x/U.y,this._resolution=U}serialize(){const U=super.serialize(),W={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(W.za=this._colors),this._color&&(W.color=this._color),U.greasedLineMaterialOptions=W,U}parse(U,W,l){var M;super.parse(U,W,l);const t=U.greasedLineMaterialOptions;null===(M=this.colorsTexture)||void 0===M||M.dispose(),t.color&&this.setColor(t.color,!0),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.za&&(this.za=t.za),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),this.za?this.colorsTexture=HU.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,W):HU.PrepareEmptyColorsTexture(W),this.markAllDefinesAsDirty()}copyTo(U){var W;const l=U;null===(W=l.colorsTexture)||void 0===W||W.dispose(),this._colors&&(l.colorsTexture=HU.CreateColorsTexture(`${l._material.name}-colors-texture`,this._colors,l.colorsSampling,this._scene)),l.setColor(this.color,!0),l.colorsDistributionType=this.colorsDistributionType,l.colorsSampling=this.colorsSampling,l.colorMode=this.colorMode,l.useColors=this.useColors,l.visibility=this.visibility,l.useDash=this.useDash,l.dashCount=this.dashCount,l.dashRatio=this.dashRatio,l.dashOffset=this.dashOffset,l.width=this.width,l.sizeAttenuation=this.sizeAttenuation,l.resolution=this.resolution,l.markAllDefinesAsDirty()}_isGLSL(U){return 0===U||this._forceGLSL}}nU.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",nU.ForceGLSL=!1,(0,iU.f)(`BABYLON.${nU.GREASED_LINE_MATERIAL_NAME}`,nU);var xU=l(774),IU=l(520),RU=l(11879),FU=l(631);class vU extends RU.b{constructor(U,W,t){const L=W.getEngine(),p=L.isWebGPU&&!(t.forceGLSL||vU.ForceGLSL),B=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];W.useRightHandedSystem&&B.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const k=["position","grl_widths","grl_offsets","grl_colorPointers"];t.cameraFacing?(B.push("GREASED_LINE_CAMERA_FACING"),k.push("grl_previousAndSide","grl_nextAndCounters")):(k.push("grl_slopes"),k.push("grl_counters"));const A=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(p||A.push("world","viewProjection","view","projection"),super(U,W,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:p?["Scene","Mesh"]:void 0,attributes:k,uniforms:A,samplers:p?[]:["grlColors"],defines:B,extraInitializationsAsync:async()=>{p?await Promise.all([l.e(51).then(l.bind(l,13888)),l.e(59).then(l.bind(l,13890))]):await Promise.all([l.e(54).then(l.bind(l,13897)),l.e(60).then(l.bind(l,13905))])},shaderLanguage:p?1:0}),this._color=r.e.White(),this._colorsDistributionType=0,this._colorsTexture=null,t=t||{color:OU.DEFAULT_COLOR},this.visibility=t.visibility??1,this.useDash=t.useDash??!1,this.dashRatio=t.dashRatio??.5,this.dashOffset=t.dashOffset??0,this.dashCount=t.dashCount??1,this.width=t.width?t.width:t.sizeAttenuation&&t.cameraFacing?OU.DEFAULT_WIDTH_ATTENUATED:OU.DEFAULT_WIDTH,this.sizeAttenuation=t.sizeAttenuation??!1,this.color=t.color??r.e.White(),this.useColors=t.useColors??!1,this.colorsDistributionType=t.colorDistributionType??0,this.colorsSampling=t.colorsSampling??N.e.NEAREST_NEAREST,this.colorMode=t.colorMode??0,this._colors=t.za??null,this._cameraFacing=t.cameraFacing??!0,this.resolution=t.resolution??new M.h(L.getRenderWidth(),L.getRenderHeight()),t.colorsTexture?this.colorsTexture=t.colorsTexture:this._colors?this.colorsTexture=HU.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,W):(this._color=this._color??OU.DEFAULT_COLOR,this.colorsTexture=HU.PrepareEmptyColorsTexture(W)),p){const U=new FU.b;U.setParameters(),U.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",U)}L.nk.add((()=>{HU.DisposeEmptyColorsTexture()}))}dispose(){var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new M.h(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(U){this.setColors(U)}setColors(U){var W;let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(W=this._colors)||void 0===W?void 0:W.length)??0;var L;if(this._colors=U,null!==U&&0!==U.length){if(!l||M)if(this._colorsTexture&&t===U.length&&!M){const W=HU.Color3toRGBAUint8(U);this._colorsTexture.update(W)}else{var p;null===(p=this._colorsTexture)||void 0===p||p.dispose(),this.colorsTexture=HU.CreateColorsTexture(`${this.name}-colors-texture`,U,this.colorsSampling,this.va())}}else null===(L=this._colorsTexture)||void 0===L||L.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(U){this._colorsTexture=U,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(U){this._width=U,this.setFloat("grlWidth",U)}get useColors(){return this._useColors}set useColors(U){this._useColors=U,this.setFloat("grlUseColors",HU.BooleanToNumber(U))}get colorsSampling(){return this._colorsSampling}set colorsSampling(U){this._colorsSampling=U}get visibility(){return this._visibility}set visibility(U){this._visibility=U,this.setFloat("grlVisibility",U)}get useDash(){return this._useDash}set useDash(U){this._useDash=U,this.setFloat("grlUseDash",HU.BooleanToNumber(U))}get dashOffset(){return this._dashOffset}set dashOffset(U){this._dashOffset=U,this.setFloat("grlDashOffset",U)}get dashRatio(){return this._dashRatio}set dashRatio(U){this._dashRatio=U,this.setFloat("grlDashRatio",U)}get dashCount(){return this._dashCount}set dashCount(U){this._dashCount=U,this._dashArray=1/U,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(U){this._sizeAttenuation=U,this.setFloat("grlSizeAttenuation",HU.BooleanToNumber(U))}get color(){return this._color}set color(U){this.setColor(U)}setColor(U){U=U??OU.DEFAULT_COLOR,this._color=U,this.setColor3("grlColor",U)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(U){this._colorsDistributionType=U,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(U){this._colorMode=U,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(U){this._resolution=U,this.setVector2("grlResolution",U),this.setFloat("grlAspect",U.x/U.y)}serialize(){const U=super.serialize(),W={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(W.za=this._colors),U.greasedLineMaterialOptions=W,U}parse(U,W,l){var M;const t=U.greasedLineMaterialOptions;null===(M=this._colorsTexture)||void 0===M||M.dispose(),t.color&&(this.color=t.color),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),t.za?this.colorsTexture=HU.CreateColorsTexture(`${this.name}-colors-texture`,t.za,this.colorsSampling,this.va()):this.colorsTexture=HU.PrepareEmptyColorsTexture(W),this._cameraFacing=t.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var JU,QU,GU;vU.ForceGLSL=!1,function(U){U[U.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",U[U.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(JU||(JU={})),function(U){U[U.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",U[U.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",U[U.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(QU||(QU={})),function(U){U[U.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",U[U.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",U[U.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",U[U.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",U[U.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(GU||(GU={}));class uU extends fU.e{constructor(U,W,l){super(U,W,null,null,!1,!1),this.name=U,this._options=l,this._lazy=!1,this._updatable=!1,this._engine=W.getEngine(),this._lazy=l.lazy??!1,this._updatable=l.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=l.colorPointers??[],this._widths=l.widths??new Array(l.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(U){let W=0;for(const M of this._points)W+=M.length;const l=W/3*2-this._widths.length;for(let M=0;M<l;M++)this._widths.push(U)}updateLazy(){var U,W;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(U=this._options.ribbonOptions)||void 0===U?void 0:U.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(W=this.greasedLineMaterial)||void 0===W||W.updateLazy()}addPoints(U,W){for(const l of U)this._points.push(l);this._lazy||this.setPoints(this._points,W)}dispose(U){let W=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(U,W)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(U){this._uvs=U instanceof Float32Array?U:new Float32Array(U),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(U){this.material instanceof vU&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===U||void 0===U?void 0:U.length)>0),this._offsets=U,this._offsetsBuffer?this._offsetsBuffer.update(U):this._createOffsetsBuffer(U)}get widths(){return this._widths}set widths(U){this._widths=U,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(U)}get colorPointers(){return this._colorPointers}set colorPointers(U){this._colorPointers=U,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(U)}get greasedLineMaterial(){var U,W;if(this.material&&this.material instanceof vU)return this.material;const l=null===(U=this.material)||void 0===U||null===(W=U.pluginManager)||void 0===W?void 0:W.getPlugin(nU.GREASED_LINE_MATERIAL_NAME);return l||void 0}get points(){const U=[];return IU.b.DeepCopy(this._points,U),U}setPoints(U,W){this._points=HU.ConvertPoints(U,(null===W||void 0===W?void 0:W.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==W&&void 0!==W&&W.colorPointers||this._updateColorPointers(),this._setPoints(this._points,W)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(U){super.serialize(U),U.type=this.getClassName(),U.lineOptions=this._createLineOptions()}_createVertexBuffers(){let U=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const W=new xU.b;return W.xa=this._vertexPositions,W.indices=this._indices,W.Aa=this._uvs,U&&(W.ya=[],xU.b.ComputeNormals(this._vertexPositions,this._indices,W.ya)),W.Ca(this,this._options.updatable),W}_createOffsetsBuffer(U){const W=this._scene.getEngine(),l=new q.b(W,U,this._updatable,3);this.setVerticesBuffer(l.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=l}}class bU{constructor(U,W){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=U,this.wasAddedByNoopNode=W}getIndicesAccessor(U,W,l,M,t){var L,p,B,k;return null===(L=this._indicesAccessorMap.get(U))||void 0===L||null===(p=L.get(W))||void 0===p||null===(B=p.get(l))||void 0===B||null===(k=B.get(M))||void 0===k?void 0:k.get(t)}setIndicesAccessor(U,W,l,M,t,L){let p=this._indicesAccessorMap.get(U);p||(p=new Map,this._indicesAccessorMap.set(U,p));let B=p.get(W);B||(B=new Map,p.set(W,B));let k=B.get(l);k||(k=new Map,B.set(l,k));let A=k.get(M);A||(A=new Map,k.set(M,A)),A.set(t,L)}pushExportedNode(U){this._exportedNodes.has(U)||this._exportedNodes.add(U)}getNodesSet(){return this._exportedNodes}getVertexBufferView(U){return this._vertexBufferViewMap.get(U)}setVertexBufferView(U,W){this._vertexBufferViewMap.set(U,W)}setRemappedBufferView(U,W,l){this._remappedBufferView.set(U,new Map),this._remappedBufferView.get(U).set(W,l)}getRemappedBufferView(U,W){var l;return null===(l=this._remappedBufferView.get(U))||void 0===l?void 0:l.get(W)}getVertexAccessor(U,W,l){var M,t;return null===(M=this._vertexAccessorMap.get(U))||void 0===M||null===(t=M.get(W))||void 0===t?void 0:t.get(l)}setVertexAccessor(U,W,l,M){let t=this._vertexAccessorMap.get(U);t||(t=new Map,this._vertexAccessorMap.set(U,t));let L=t.get(W);L||(L=new Map,t.set(W,L)),L.set(l,M)}hasVertexColorAlpha(U){return this._vertexMapColorAlpha.get(U)||!1}setHasVertexColorAlpha(U,W){return this._vertexMapColorAlpha.set(U,W)}getMesh(U){return this._meshMap.get(U)}setMesh(U,W){this._meshMap.set(U,W)}bindMorphDataToMesh(U,W){const l=this._meshMorphTargetMap.get(U)||[];this._meshMorphTargetMap.set(U,l),-1===l.indexOf(W)&&l.push(W)}getMorphTargetsFromMesh(U){return this._meshMorphTargetMap.get(U)}}class CU{_ApplyExtension(U,W,l,M){if(l>=W.length)return Promise.resolve(U);const t=M(W[l],U);return t?t.then((async U=>U?await this._ApplyExtension(U,W,l+1,M):null)):this._ApplyExtension(U,W,l+1,M)}_ApplyExtensions(U,W){const l=[];for(const M of CU._ExtensionNames)l.push(this._extensions[M]);return this._ApplyExtension(U,l,0,W)}_extensionsPreExportTextureAsync(U,W,l){return this._ApplyExtensions(W,((W,M)=>W.preExportTextureAsync&&W.preExportTextureAsync(U,M,l)))}_extensionsPostExportNodeAsync(U,W,l,M,t){return this._ApplyExtensions(W,((W,L)=>W.postExportNodeAsync&&W.postExportNodeAsync(U,L,l,M,t,this._bufferManager)))}_extensionsPostExportMaterialAsync(U,W,l){return this._ApplyExtensions(W,((W,M)=>W.postExportMaterialAsync&&W.postExportMaterialAsync(U,M,l)))}_extensionsPostExportMaterialAdditionalTextures(U,W,l){const M=[];for(const t of CU._ExtensionNames){const L=this._extensions[t];L.postExportMaterialAdditionalTextures&&M.push(...L.postExportMaterialAdditionalTextures(U,W,l))}return M}_extensionsPostExportTextures(U,W,l){for(const M of CU._ExtensionNames){const t=this._extensions[M];t.postExportTexture&&t.postExportTexture(U,W,l)}}_extensionsPostExportMeshPrimitive(U){for(const W of CU._ExtensionNames){const l=this._extensions[W];l.postExportMeshPrimitive&&l.postExportMeshPrimitive(U,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const U of CU._ExtensionNames){const W=this._extensions[U];W.preGenerateBinaryAsync&&await W.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(U){for(const W of CU._ExtensionNames){const l=this._extensions[W];l.enabled&&U(l)}}_extensionsOnExporting(){this._forEachExtensions((U=>{var W,l,M;U.wasUsed&&((W=this._glTF).extensionsUsed||(W.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(U.name)&&this._glTF.extensionsUsed.push(U.name),U.required&&((l=this._glTF).extensionsRequired||(l.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(U.name)&&this._glTF.extensionsRequired.push(U.name)),(M=this._glTF).extensions||(M.extensions={}),U.onExporting&&U.onExporting())}))}_loadExtensions(){for(const U of CU._ExtensionNames){const W=CU._ExtensionFactories[U](this);this._extensions[U]=W}}constructor(){let U=arguments.length>0&&void 0!==arguments[0]?arguments[0]:K.d.LastCreatedScene,W=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${w.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new F(this),this._extensions={},this._bufferManager=new qU,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!U)throw new Error("No scene available to export");this._babylonScene=U,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:U=>{var W;return null===U||void 0===U||null===(W=U.Tk)||void 0===W?void 0:W.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...W},this._loadExtensions()}dispose(){for(const U in this._extensions){this._extensions[U].dispose()}}get options(){return this._options}static RegisterExtension(U,W){CU.UnregisterExtension(U)&&t.h.Warn(`Extension with the name ${U} already exists`),CU._ExtensionFactories[U]=W,CU._ExtensionNames.push(U)}static UnregisterExtension(U){if(!CU._ExtensionFactories[U])return!1;delete CU._ExtensionFactories[U];const W=CU._ExtensionNames.indexOf(U);return-1!==W&&CU._ExtensionNames.splice(W,1),!0}_generateJSON(U,W,l){const M={byteLength:U};return M.byteLength&&(this._glTF.buffers=[M]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Gd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(M.uri=W+".bin"),l?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(U){const W=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(W.byteLength,U,!0),M=new Blob([W],{type:"application/octet-stream"}),t=U+".gltf",L=U+".bin",p=new A;if(p.files[t]=l,p.files[L]=M,this._imageData)for(const B in this._imageData)p.files[B]=new Blob([this._imageData[B].data],{type:this._imageData[B].mimeType});return p}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(U){const W=U%4;return 0===W?W:4-W}async generateGLBAsync(U){this._shouldUseGlb=!0;const W=await this._generateBinaryAsync();this._extensionsOnExporting();const l=this._generateJSON(W.byteLength),M=U+".glb";let t,L=l.length;if("undefined"!==typeof TextEncoder){t=(new TextEncoder).encode(l),L=t.length}const p=this._getPadding(L),B=this._getPadding(W.byteLength),k=28+L+p+W.byteLength+B,q=new kU(k);if(q.writeUInt32(1179937895),q.writeUInt32(2),q.writeUInt32(k),q.writeUInt32(L+p),q.writeUInt32(1313821514),t)q.writeTypedArray(t);else{const U="_".charCodeAt(0);for(let W=0;W<L;++W){const M=l.charCodeAt(W);M!=l.codePointAt(W)?q.writeUInt8(U):q.writeUInt8(M)}}for(let A=0;A<p;++A)q.writeUInt8(32);q.writeUInt32(W.byteLength+B),q.writeUInt32(5130562),q.writeTypedArray(W);for(let A=0;A<B;++A)q.writeUInt8(0);const y=new A;return y.files[M]=new Blob([q.getOutputData()],{type:"application/octet-stream"}),y}_setNodeTransformation(U,W,l){if(W.getPivotPoint().equalsWithEpsilon(u,G.d)||t.h.Warn("Pivot points are not supported in the glTF serializer"),!W.position.equalsWithEpsilon(u,G.d)){const t=M.f.ik[0].p(W.position);l&&Y(t),U.translation=t.qk()}W.yd.equalsWithEpsilon(C,G.d)||(U.scale=W.yd.qk());const L=W.rotationQuaternion||M.e.FromEulerAngles(W.rotation.x,W.rotation.y,W.rotation.z);L.equalsWithEpsilon(b,G.d)||(l&&X(L),U.rotation=L.normalize().qk())}_setCameraTransformation(U,W,l){if(!W.position.equalsWithEpsilon(u,G.d)){const t=M.f.ik[0].p(W.position);l&&Y(t),U.translation=t.qk()}const t=W.rotationQuaternion||M.e.FromEulerAngles(W.rotation.x,W.rotation.y,W.rotation.z);l&&X(t),this._babylonScene.useRightHandedSystem||T(t),t.equalsWithEpsilon(b,G.d)||(U.rotation=t.qk())}_listAvailableCameras(){for(const U of this._babylonScene.cameras){const W={type:U.mode===jU.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(U.name&&(W.name=U.name),"perspective"===W.type)W.perspective={aspectRatio:U.getEngine().getAspectRatio(U),yfov:U.fovMode===jU.d.FOVMODE_VERTICAL_FIXED?U.fov:U.fov*U.getEngine().getAspectRatio(U),znear:U.bk,zfar:U.maxZ};else if("orthographic"===W.type){const l=U.orthoLeft&&U.orthoRight?.5*(U.orthoRight-U.orthoLeft):.5*U.getEngine().getRenderWidth(),M=U.orthoBottom&&U.orthoTop?.5*(U.orthoTop-U.orthoBottom):.5*U.getEngine().getRenderHeight();W.orthographic={xmag:l,ymag:M,znear:U.bk,zfar:U.maxZ}}this._camerasMap.set(U,W)}}_exportAndAssignCameras(){const U=Array.from(this._camerasMap.values());for(const W of U){const U=this._nodesCameraMap.get(W);if(void 0!==U){this._cameras.push(W);for(const W of U)W.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const U of this._babylonScene.skeletons){if(U.bones.length<=0)continue;const W={joints:[]};this._skinMap.set(U,W)}}_exportAndAssignSkeletons(){for(const U of this._babylonScene.skeletons){if(U.bones.length<=0)continue;const W=this._skinMap.get(U);if(void 0==W)continue;const l={},M=[];let L=-1;for(let t=0;t<U.bones.length;++t){const W=U.bones[t],M=W.getIndex()??t;-1!==M&&(l[M]=W,M>L&&(L=M))}for(let U=0;U<=L;++U){const L=l[U];M.push(L.getAbsoluteInverseBindMatrix());const p=L.getTransformNode();if(null!==p){const U=this._nodeMap.get(p);p&&null!==U&&void 0!==U?W.joints.push(U):t.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}else t.h.Warn("Exporting a bone without a linked transform node is currently unsupported")}const p=this._nodesSkinMap.get(W);if(W.joints.length>0&&void 0!==p){const U=64*M.length,l=new Float32Array(U/4);M.forEach(((U,W)=>{l.set(U.m,16*W)}));const t=this._bufferManager.createBufferView(l);this._accessors.push(this._bufferManager.createAccessor(t,"MAT4",5126,M.length)),W.inverseBindMatrices=this._accessors.length-1,this._skins.push(W);for(const W of p)W.skin=this._skins.length-1}}}async _exportSceneAsync(){const U={nodes:[]};if(this._babylonScene.metadata){const W=this._options.metadataSelector(this._babylonScene.metadata);W&&(U.extras=W)}const W=new Array,l=new Array,M=new Array;for(const B of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&pU(B,this._babylonScene.useRightHandedSystem)?M.push(...B.getChildren()):this._babylonScene.useRightHandedSystem?W.push(B):l.push(B);this._listAvailableCameras(),this._listAvailableSkeletons();const t=new bU(!0,!1);U.nodes.push(...await this._exportNodesAsync(l,t));const L=new bU(!1,!1);U.nodes.push(...await this._exportNodesAsync(W,L));const p=new bU(!1,!0);U.nodes.push(...await this._exportNodesAsync(M,p)),U.nodes.length&&this._scenes.push(U),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&EU._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,t.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(U){let W=this._shouldExportNodeMap.get(U);return void 0===W&&(W=this._options.shouldExportNode(U),this._shouldExportNodeMap.set(U,W)),W}async _exportNodesAsync(U,W){const l=new Array;this._exportBuffers(U,W);for(const M of U)await this._exportNodeAsync(M,l,W);return l}_collectBuffers(U,W,l,M,t){if(this._shouldExportNode(U)&&U instanceof j.c&&U.vk){const L=U.vk.getVertexBuffers();if(L)for(const M in L){if(!h(M))continue;const p=L[M];t.setHasVertexColorAlpha(p,U.hasVertexAlpha);const B=p._buffer,k=W.get(B)||[];W.set(B,k),-1===k.indexOf(p)&&k.push(p);const A=l.get(p)||[];l.set(p,A),-1===A.indexOf(U)&&A.push(U)}const p=U.morphTargetManager;if(p)for(let W=0;W<p.numTargets;W++){const l=p.getTarget(W),t=M.get(l)||[];M.set(l,t),-1===t.indexOf(U)&&t.push(U)}}for(const L of U.getChildren())this._collectBuffers(L,W,l,M,t)}_exportBuffers(U,W){const l=new Map,M=new Map,t=new Map;for(const B of U)this._collectBuffers(B,l,M,t,W);const L=Array.from(l.keys());for(const B of L){const U=B.getData();if(!U)throw new Error("Buffer data is not available");const t=l.get(B);if(!t)continue;const L=t[0].byteStride;if(t.some((U=>U.byteStride!==L)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const p=lU(U).slice();for(const W of t){const U=M.get(W),{byteOffset:l,byteStride:t,componentCount:L,type:B,count:k,normalized:A,kind:y}=S(W,U);switch(y){case q.e.NormalKind:case q.e.TangentKind:(0,v.h)(p,l,t,L,B,k,A,(U=>{const W=Math.sqrt(U[0]*U[0]+U[1]*U[1]+U[2]*U[2]);if(W>0){const l=1/W;U[0]*=l,U[1]*=l,U[2]*=l}}));break;case q.e.ColorKind:{const W=U.filter((U=>U.material instanceof KU.e||null==U.material)).length;if(0==W)break;if(W!=U.length){J.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}B==q.e.UNSIGNED_BYTE&&J.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const M=new r.e,y=new r.f,j=this._babylonScene.getEngine().useExactSrgbConversions;(0,v.h)(p,l,t,L,B,k,A,(U=>{3===U.length?(M.fe(U,0),M.toLinearSpaceToRef(M,j),M.toArray(U,0)):(y.fe(U,0),y.toLinearSpaceToRef(y,j),y.toArray(U,0))}))}}}if(W.convertToRightHanded){for(const U of t){const W=M.get(U),{byteOffset:l,byteStride:t,componentCount:L,type:B,count:k,normalized:A,kind:y}=S(U,W);switch(y){case q.e.PositionKind:case q.e.NormalKind:case q.e.TangentKind:(0,v.h)(p,l,t,L,B,k,A,(U=>{U[0]=-U[0]}))}}W.convertedToRightHandedBuffers.set(B,p)}const k=this._bufferManager.createBufferView(p,L);W.setVertexBufferView(B,k);const A=new Map;for(const W of t){const U=M.get(W),{kind:l,totalVertices:t}=S(W,U);switch(l){case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:if(W.type==q.e.FLOAT){const U=W.getFloatData(t);null!==U&&A.set(W,U)}}}0!==A.size&&J.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const y=Array.from(A.keys());for(const l of y){const U=A.get(l);if(!U)continue;const M=U.some((U=>U>=256)),t=new(M?Uint16Array:Uint8Array)(U.length);for(let W=0;W<U.length;W++)t[W]=U[W];const L=this._bufferManager.createBufferView(t,4*(M?2:1));W.setRemappedBufferView(B,l,L)}}const p=Array.from(t.keys());for(const B of p){const U=t.get(B);if(!U)continue;const l=ZU(B,U[0],this._bufferManager,this._bufferViews,this._accessors,W.convertToRightHanded);for(const M of U)W.bindMorphDataToMesh(M,l)}}async _exportNodeAsync(U,W,l){let M=this._nodeMap.get(U);if(void 0!==M)return void(W.includes(M)||W.push(M));const t=await this._createNodeAsync(U,l);if(t){M=this._nodes.length,this._nodes.push(t),this._nodeMap.set(U,M),l.pushExportedNode(U),W.push(M);const L={name:"runtime animations",channels:[],samplers:[]},p=[];this._babylonScene.animationGroups.length||(EU._CreateMorphTargetAnimationFromMorphTargetAnimations(U,L,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation),U.animations.length&&EU._CreateNodeAnimationFromNodeAnimations(U,L,p,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.convertToRightHanded,this._options.shouldExportAnimation)),L.channels.length&&L.samplers.length&&this._animations.push(L),p.forEach((U=>{U.channels.length&&U.samplers.length&&this._animations.push(U)}))}const L=t?[]:W;for(const p of U.getChildren())await this._exportNodeAsync(p,L,l);t&&L.length&&(t.children=L)}async _createNodeAsync(U,W){if(!this._shouldExportNode(U))return null;const l={};if(U.name&&(l.name=U.name),U.metadata){const W=this._options.metadataSelector(U.metadata);W&&(l.extras=W)}if(U instanceof y.d&&(this._setNodeTransformation(l,U,W.convertToRightHanded),U instanceof j.c)){const t=U instanceof s.b?U.sourceMesh:U;if(t.uk&&t.uk.length>0&&(l.mesh=await this._exportMeshAsync(t,W)),U.skeleton){const W=this._skinMap.get(U.skeleton);var M;if(void 0!==W)void 0===this._nodesSkinMap.get(W)&&this._nodesSkinMap.set(W,[]),null===(M=this._nodesSkinMap.get(W))||void 0===M||M.push(l)}}if(U instanceof Q.b){const M=this._camerasMap.get(U);if(M){var t;void 0===this._nodesCameraMap.get(M)&&this._nodesCameraMap.set(M,[]),this._setCameraTransformation(l,U,W.convertToRightHanded);const p=U.parent;if(null!==p&&WU(U,p)){const U=this._nodeMap.get(p);if(void 0!==U){var L;const W=this._nodes[U];return UU(l,W),null===(L=this._nodesCameraMap.get(M))||void 0===L||L.push(W),null}}null===(t=this._nodesCameraMap.get(M))||void 0===t||t.push(l)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",l,U,this._nodeMap,W.convertToRightHanded)?l:(J.b.Warn(`Not exporting node ${U.name}`),null)}_exportIndices(U,W,l,M,t,p,B,k,A){let q=U;A.mode=z(p);const y=B!==L.b.CounterClockWiseSideOrientation,j=!k.wasAddedByNoopNode&&y,s=function(U){switch(U){case L.b.TriangleFillMode:case L.b.TriangleStripDrawMode:case L.b.TriangleFanDrawMode:return!0}return!1}(p)&&j;if(s){if(p===L.b.TriangleStripDrawMode||p===L.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");A.mode=z(p);const B=W?new Uint32Array(M):new Uint16Array(M);if(U)for(let W=0;W+2<M;W+=3)B[W]=U[l+W]+t,B[W+1]=U[l+W+2]+t,B[W+2]=U[l+W+1]+t;else for(let U=0;U+2<M;U+=3)B[U]=U,B[U+1]=U+2,B[U+2]=U+1;q=B}else if(U&&0!==t){const L=W?new Uint32Array(M):new Uint16Array(M);for(let W=0;W<M;W++)L[W]=U[l+W]+t;q=L}if(q){let L=k.getIndicesAccessor(U,l,M,t,s);if(void 0===L){const p=function(U,W,l,M){if(U instanceof Uint16Array||U instanceof Uint32Array)return U;if(U instanceof Int32Array)return new Uint32Array(U.buffer,U.byteOffset,U.length);const t=U.slice(W,W+l);return M?new Uint32Array(t):new Uint16Array(t)}(q,0,M,W),B=this._bufferManager.createBufferView(p),A=W?5125:5123;this._accessors.push(this._bufferManager.createAccessor(B,"SCALAR",A,M,0)),L=this._accessors.length-1,k.setIndicesAccessor(U,l,M,t,s,L)}A.indices=L}}_exportVertexBuffer(U,W,l,M,t,L){const p=U.getKind();if(!h(p))return;if(p.startsWith("uv")&&!this._options.exportUnusedUVs&&(!W||!this._materialNeedsUVsSet.has(W)))return;let B=t.getVertexAccessor(U,l,M);if(void 0===B){const W=t.convertedToRightHandedBuffers.get(U._buffer)||U._buffer.getData(),L=p===q.e.PositionKind?function(U,W,l,M){const{byteOffset:t,byteStride:L,type:p,normalized:B}=W,k=W.getSize(),A=new Array(k).fill(1/0),q=new Array(k).fill(-1/0);return(0,v.h)(U,t+l*L,L,k,p,M*k,B,(U=>{for(let W=0;W<k;W++)A[W]=Math.min(A[W],U[W]),q[W]=Math.max(q[W],U[W])})),{min:A,max:q}}(W,U,l,M):void 0,k=(p===q.e.MatricesIndicesKind||p===q.e.MatricesIndicesExtraKind)&&U.type===q.e.FLOAT,A=k?q.e.UNSIGNED_BYTE:U.type,y=k?void 0:U.normalized,j=k?t.getRemappedBufferView(U._buffer,U):t.getVertexBufferView(U._buffer),s=U.byteOffset+l*U.byteStride;this._accessors.push(this._bufferManager.createAccessor(j,function(U,W){if(U==q.e.ColorKind)return W?"VEC4":"VEC3";switch(U){case q.e.PositionKind:case q.e.NormalKind:return"VEC3";case q.e.TangentKind:case q.e.MatricesIndicesKind:case q.e.MatricesIndicesExtraKind:case q.e.MatricesWeightsKind:case q.e.MatricesWeightsExtraKind:return"VEC4";case q.e.UVKind:case q.e.UV2Kind:case q.e.UV3Kind:case q.e.UV4Kind:case q.e.UV5Kind:case q.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${U}`)}(p,t.hasVertexColorAlpha(U)),A,M,s,L,y)),B=this._accessors.length-1,t.setVertexAccessor(U,l,M,B)}L.attributes[function(U){switch(U){case q.e.PositionKind:return"POSITION";case q.e.NormalKind:return"NORMAL";case q.e.TangentKind:return"TANGENT";case q.e.ColorKind:return"COLOR_0";case q.e.UVKind:return"TEXCOORD_0";case q.e.UV2Kind:return"TEXCOORD_1";case q.e.UV3Kind:return"TEXCOORD_2";case q.e.UV4Kind:return"TEXCOORD_3";case q.e.UV5Kind:return"TEXCOORD_4";case q.e.UV6Kind:return"TEXCOORD_5";case q.e.MatricesIndicesKind:return"JOINTS_0";case q.e.MatricesIndicesExtraKind:return"JOINTS_1";case q.e.MatricesWeightsKind:return"WEIGHTS_0";case q.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${U}`)}(p)]=B}async _exportMaterialAsync(U,W,l,M){let t=this._materialMap.get(U);if(void 0===t){const M=W&&Object.keys(W).some((U=>U.startsWith("uv")));if((U=U instanceof sU.e?U.yk[l.materialIndex]:U)instanceof wU.c)t=await this._materialExporter.exportPBRMaterialAsync(U,"image/png",M);else{if(!(U instanceof KU.e))return void J.b.Warn(`Unsupported material '${U.name}' with type ${U.getClassName()}`);t=await this._materialExporter.exportStandardMaterialAsync(U,"image/png",M)}this._materialMap.set(U,t)}M.material=t}async _exportMeshAsync(U,W){var l;let M=W.getMesh(U);if(void 0!==M)return M;const t={primitives:[]};M=this._meshes.length,this._meshes.push(t),W.setMesh(U,M);const p=U.isUnIndexed?null:U.hk(),B=null===(l=U.vk)||void 0===l?void 0:l.getVertexBuffers(),k=W.getMorphTargetsFromMesh(U),A=U instanceof NU.e,q=U instanceof uU,y=U.uk;if(B&&y&&y.length>0)for(const w of y){const l={attributes:{}},M=w.Ha()||this._babylonScene.defaultMaterial;if(q){var j,s;const W={name:M.name},t=U,L=r.e.White(),p=(null===(j=t.material)||void 0===j?void 0:j.alpha)??1,B=(null===(s=t.greasedLineMaterial)||void 0===s?void 0:s.color)??L;(!B.equalsWithEpsilon(L,G.d)||p<1)&&(W.pbrMetallicRoughness={baseColorFactor:[...B.qk(),p]}),this._materials.push(W),l.material=this._materials.length-1}else if(A){const W={name:M.name},t=U;(!t.color.equalsWithEpsilon(r.e.White(),G.d)||t.alpha<1)&&(W.pbrMetallicRoughness={baseColorFactor:[...t.color.qk(),t.alpha]}),this._materials.push(W),l.material=this._materials.length-1}else await this._exportMaterialAsync(M,B,w,l);const y=A||q?L.b.LineListDrawMode:U.overrideRenderingFillMode??M.fillMode,K=M._getEffectiveOrientation(U);this._exportIndices(p,p?(0,v.c)(p,w.indexCount,w.indexStart,w.verticesStart):w.verticesCount>65535,p?w.indexStart:w.verticesStart,p?w.indexCount:w.verticesCount,-w.verticesStart,y,K,W,l);for(const U of Object.values(B))this._exportVertexBuffer(U,M,w.verticesStart,w.verticesCount,W,l);if(k){l.targets=[];for(const U of k)l.targets.push(U.attributes)}t.primitives.push(l),this._extensionsPostExportMeshPrimitive(l)}if(k){t.weights=[],t.extras||(t.extras={}),t.extras.targetNames=[];for(const U of k)t.weights.push(U.influence),t.extras.targetNames.push(U.name)}return M}}CU._ExtensionNames=new Array,CU._ExtensionFactories={};class PU{static async GLTFAsync(U,W,l){l&&l.exportWithoutWaitingForScene||await U.whenReadyAsync();const M=new CU(U,l),t=await M.generateGLTFAsync(W.replace(/\.[^/.]+$/,""));return M.dispose(),t}static async GLBAsync(U,W,l){l&&l.exportWithoutWaitingForScene||await U.whenReadyAsync();const M=new CU(U,l),t=await M.generateGLBAsync(W.replace(/\.[^/.]+$/,""));return M.dispose(),t}}l(485);const SU="EXT_mesh_gpu_instancing";class cU{constructor(U){this.name=SU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(U,W,l,t,L,p){return await new Promise((U=>{if(W&&l instanceof fU.e&&l.hasThinInstances&&this._exporter){this._wasUsed=!0;const U=M.l.Zero(),t=M.e.Identity(),B=M.l.One(),k=l.thinInstanceGetWorldMatrices(),A=M.f.ik[2],q=M.f.Quaternion[1],y=M.f.ik[3];let j=!1,s=!1,w=!1;const K=new Float32Array(3*l.Pk),r=new Float32Array(4*l.Pk),m=new Float32Array(3*l.Pk);let f=0;for(const W of k)W.decompose(y,q,A),L&&(Y(A),X(q)),K.set(A.qk(),3*f),r.set(q.normalize().qk(),4*f),m.set(y.qk(),3*f),j=j||!A.equalsWithEpsilon(U),s=s||!q.equalsWithEpsilon(t),w=w||!y.equalsWithEpsilon(B),f++;const g={attributes:{}};j&&(g.attributes.TRANSLATION=this._buildAccessor(K,"VEC3",l.Pk,p)),s&&(g.attributes.ROTATION=this._buildAccessor(r,"VEC4",l.Pk,p)),w&&(g.attributes.SCALE=this._buildAccessor(m,"VEC3",l.Pk,p)),W.extensions=W.extensions||{},W.extensions[SU]=g}U(W)}))}_buildAccessor(U,W,l,M){const t=M.createBufferView(U),L=M.createAccessor(t,W,5126,l);return this._exporter._accessors.push(L),this._exporter._accessors.length-1}}CU.RegisterExtension(SU,(U=>new cU(U)));var hU=l(11889),zU=l(11896),aU=l(11898),YU=l(11907);function XU(U){return U===aU.c.PositionKind?"POSITION":U===aU.c.NormalKind?"NORMAL":U===aU.c.ColorKind?"COLOR":U.startsWith(aU.c.UVKind)?"TEX_COORD":"GENERIC"}const TU={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class UW extends hU.c{static get DefaultAvailable(){return(0,hU.j)(UW.DefaultConfiguration)}static get Default(){return UW._Default??(UW._Default=new UW),UW._Default}static ResetDefault(U){UW._Default&&(U||UW._Default.dispose(),UW._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(U,W){return{module:await(W||DracoEncoderModule)({wasmBinary:U})}}_getWorkerContent(){return`${zU.h}(${zU.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:UW.DefaultConfiguration)}async _encodeAsync(U,W,l){const M=l?(0,YU.d)(TU,l):TU;if(this._workerPoolPromise){const l=await this._workerPoolPromise;return await new Promise(((t,L)=>{l.push(((l,p)=>{const B=U=>{l.removeEventListener("error",B),l.removeEventListener("message",k),L(U),p()},k=U=>{"encodeMeshDone"===U.data.id&&(l.removeEventListener("error",B),l.removeEventListener("message",k),t(U.data.encodedMeshData),p())};l.addEventListener("error",B),l.addEventListener("message",k);const A=[];for(const W of U)A.push(W.data.buffer);W&&A.push(W.buffer),l.postMessage({id:"encodeMesh",attributes:U,indices:W,options:M},A)}))}))}if(this._modulePromise){const l=await this._modulePromise;return(0,zU.h)(l.module,U,W,M)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(U,W){if(0==U.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");U instanceof fU.e&&U.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===W||void 0===W?void 0:W.method)&&(J.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),W.method="MESH_SEQUENTIAL_ENCODING");const l=function(U){let W=U.hk(void 0,!0);return!W||W instanceof Uint32Array||W instanceof Uint16Array||(W=((0,v.c)(W,W.length)?Uint32Array:Uint16Array).from(W)),W}(U),M=function(U,W){const l=[];for(const M of U.getVerticesDataKinds()){if(null!==W&&void 0!==W&&W.includes(M)){if(M===aU.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const t=U.getVertexBuffer(M),L=t.getSize(),p=(0,v.r)(t.getData(),L,t.type,t.byteOffset,t.byteStride,t.normalized,U.getTotalVertices(),!0);l.push({kind:M,dracoName:XU(M),size:L,data:p})}return l}(U,null===W||void 0===W?void 0:W.excludedAttributes);return await this._encodeAsync(M,l,W)}}UW.DefaultConfiguration={wasmUrl:`${t.h._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${t.h._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${t.h._DefaultCdnUrl}/draco_encoder.js`},UW._Default=null;const WW="KHR_draco_mesh_compression";class lW{get wasUsed(){return this._wasUsed}constructor(U){this.name=WW,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===U.options.meshCompressionMethod&&UW.DefaultAvailable}dispose(){}postExportMeshPrimitive(U,W,l){if(!this.enabled)return;if(4!==U.mode&&5!==U.mode)return void J.b.Warn("Cannot compress primitive with mode "+U.mode+".");const M=[],t=[];let L=null;if(void 0!==U.indices){const p=l[U.indices],B=W.getBufferView(p);L=W.getData(B).slice(),M.push(B),t.push(p)}const p=[];for(const[q,y]of Object.entries(U.attributes)){const U=l[y],L=W.getBufferView(U),k=c(U.type),A=(0,v.r)(W.getData(L),k,U.componentType,U.byteOffset||0,L.byteStride||(0,v.l)(U.componentType)*k,U.normalized||!1,U.count,!0);p.push({kind:q,dracoName:(B=q,"POSITION"===B?"POSITION":"NORMAL"===B?"NORMAL":B.startsWith("COLOR")?"COLOR":B.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:c(U.type),data:A}),M.push(L),t.push(U)}var B;const k={method:U.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},A=UW.Default._encodeAsync(p,L,k).then((l=>{if(!l)return void J.b.Error("Draco encoding failed for primitive.");const L={bufferView:-1,attributes:l.attributeIds},p=W.createBufferView(l.data);W.setBufferView(L,p);for(const U of M)this._bufferViewsUsed.add(U);for(const U of t)this._accessorsUsed.add(U);U.extensions||(U.extensions={}),U.extensions[WW]=L})).catch((U=>{J.b.Error("Draco encoding failed for primitive: "+U)}));this._encodePromises.push(A),this._wasUsed=!0}async preGenerateBinaryAsync(U){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((W=>{U.getPropertiesWithBufferView(W).every((U=>this._accessorsUsed.has(U)))&&U.removeBufferView(W)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}CU.RegisterExtension(WW,(U=>new lW(U)));var MW=l(11914);const tW="KHR_lights_punctual",LW={name:"",color:[1,1,1],bb:1,range:Number.MAX_VALUE},pW={innerConeAngle:0,outerConeAngle:Math.PI/4},BW=M.l.Backward();class kW{constructor(U){this.name=tW,this.enabled=!0,this.required=!1,this._exporter=U}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[tW]=this._lights}async postExportNodeAsync(U,W,l,t,L){return await new Promise((p=>{if(!(l instanceof gU.c))return void p(W);const B=l.getTypeID()==gU.c.LIGHTTYPEID_POINTLIGHT?"point":l.getTypeID()==gU.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":l.getTypeID()==gU.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!B||!(l instanceof MW.d))return J.b.Warn(`${U}: Light ${l.name} is not supported in ${tW}`),void p(W);if(l.falloffType!==gU.c.FALLOFF_GLTF&&J.b.Warn(`${U}: Light falloff for ${l.name} does not match the ${tW} specification!`),!l.position.equalsToFloats(0,0,0)){const U=M.f.ik[0].p(l.position);L&&Y(U),W.translation=U.qk()}if("point"!==B){const U=l.direction.normalizeToRef(M.f.ik[0]);L&&Y(U);const t=M.e.FromUnitVectorsToRef(BW,U,M.f.Quaternion[0]);M.e.IsIdentity(t)||(W.rotation=t.qk())}const k={type:B,name:l.name,color:l.cb.qk(),bb:l.bb,range:l.range};if(MU(k,LW),"spot"===B){const U=l;k.spot={innerConeAngle:U.innerAngle/2,outerConeAngle:U.angle/2},MU(k.spot,pW)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(k);const A={ab:this._lights.lights.length-1},q=l.parent;if(q&&WU(l,q)){const U=t.get(q);if(U){const l=this._exporter._nodes[U];return UU(W,l),l.extensions||(l.extensions={}),l.extensions[tW]=A,void p(null)}}W.extensions||(W.extensions={}),W.extensions[tW]=A,p(W)}))}}CU.RegisterExtension(tW,(U=>new kW(U)));var AW=l(11813);const qW="KHR_materials_anisotropy";class yW{constructor(U){this.name=qW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof AW.b&&l.anisotropy.isEnabled&&!l.anisotropy.legacy?(l.anisotropy.texture&&M.push(l.anisotropy.texture),M):[]}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof AW.b){if(!l.anisotropy.isEnabled||l.anisotropy.legacy)return void U(W);this._wasUsed=!0,W.extensions=W.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(l.anisotropy.texture),t={anisotropyStrength:l.anisotropy.bb,anisotropyRotation:l.anisotropy.angle,anisotropyTexture:M??void 0};null!==t.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(l),W.extensions[qW]=t}U(W)}))}}CU.RegisterExtension(qW,(U=>new yW(U)));const jW="KHR_materials_clearcoat";class sW{constructor(U){this.name=jW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof AW.b&&l.clearCoat.isEnabled?(l.clearCoat.texture&&M.push(l.clearCoat.texture),!l.clearCoat.useRoughnessFromMainTexture&&l.clearCoat.textureRoughness&&M.push(l.clearCoat.textureRoughness),l.clearCoat.bumpTexture&&M.push(l.clearCoat.bumpTexture),M):[]}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof AW.b){if(!l.clearCoat.isEnabled)return void U(W);this._wasUsed=!0,W.extensions=W.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture);let L;L=l.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(l.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(l.clearCoat.textureRoughness),l.clearCoat.isTintEnabled&&t.h.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${l.name}`),l.clearCoat.remapF0OnInterfaceChange&&t.h.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${l.name}`);const p=this._exporter._materialExporter.getTextureInfo(l.clearCoat.bumpTexture),B={clearcoatFactor:l.clearCoat.bb,clearcoatTexture:M??void 0,clearcoatRoughnessFactor:l.clearCoat.roughness,clearcoatRoughnessTexture:L??void 0,clearcoatNormalTexture:p??void 0};null===B.clearcoatTexture&&null===B.clearcoatRoughnessTexture&&null===B.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),W.extensions[jW]=B}U(W)}))}}CU.RegisterExtension(jW,(U=>new sW(U)));const wW="KHR_materials_diffuse_transmission";function KW(U,W){const l=W.subSurface;let M=null;return l.translucencyIntensityTexture?M=l.translucencyIntensityTexture:l.thicknessTexture&&l.useMaskFromThicknessTexture&&(M=l.thicknessTexture),M&&!l.useGltfStyleTextures?(J.b.Warn(`${U}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${W.name}`,1),null):M}class rW{constructor(U){this.name=wW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];if(l instanceof wU.c&&this._isExtensionEnabled(l)){const W=KW(U,l);return W&&M.push(W),l.subSurface.translucencyColorTexture&&M.push(l.subSurface.translucencyColorTexture),M}return M}_isExtensionEnabled(U){if(U.unlit)return!1;const W=U.subSurface;return!!W.isTranslucencyEnabled&&(!U.unlit&&!W.useAlbedoToTintTranslucency&&W.useGltfStyleTextures&&1===W.volumeIndexOfRefraction&&0===W.minimumThickness&&0===W.maximumThickness)}postExportMaterialAsync(U,W,l){return new Promise((M=>{if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const M=l.subSurface,t=KW(U,l),L=0==M.translucencyIntensity?void 0:M.translucencyIntensity,p=this._exporter._materialExporter.getTextureInfo(t)??void 0,B=!M.translucencyColor||M.translucencyColor.equalsFloats(1,1,1)?void 0:M.translucencyColor.qk(),k=this._exporter._materialExporter.getTextureInfo(M.translucencyColorTexture)??void 0,A={diffuseTransmissionFactor:L,diffuseTransmissionTexture:p,diffuseTransmissionColorFactor:B,diffuseTransmissionColorTexture:k};(p||k)&&this._exporter._materialNeedsUVsSet.add(l),W.extensions=W.extensions||{},W.extensions[wW]=A}M(W)}))}}CU.RegisterExtension(wW,(U=>new rW(U)));const mW="KHR_materials_dispersion";class fW{constructor(){this.name=mW,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){if(U.unlit)return!1;const W=U.subSurface;return!(!W.isRefractionEnabled&&!W.isDispersionEnabled)}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const U={dispersion:l.subSurface.dispersion};W.extensions=W.extensions||{},W.extensions[mW]=U}U(W)}))}}CU.RegisterExtension(mW,(()=>new fW));const gW="KHR_materials_emissive_strength";class EW{constructor(){this.name=gW,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(U,W,l){return await new Promise((U=>{if(!(l instanceof wU.c))return U(W);const M=l.emissiveColor.qk(),t=Math.max(...M);if(t>1){this._wasUsed=!0,W.extensions||(W.extensions={});const U={emissiveStrength:t},M=l.emissiveColor.scale(1/U.emissiveStrength);W.emissiveFactor=M.qk(),W.extensions[gW]=U}return U(W)}))}}CU.RegisterExtension(gW,(U=>new EW));const ZW="KHR_materials_ior";class NW{constructor(){this.name=ZW,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.indexOfRefraction&&1.5!=U.indexOfRefraction)}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const U={ior:l.indexOfRefraction};W.extensions=W.extensions||{},W.extensions[ZW]=U}U(W)}))}}CU.RegisterExtension(ZW,(U=>new NW));const DW="KHR_materials_iridescence";class oW{constructor(U){this.name=DW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof AW.b&&l.iridescence.isEnabled?(l.iridescence.texture&&M.push(l.iridescence.texture),l.iridescence.thicknessTexture&&l.iridescence.thicknessTexture!==l.iridescence.texture&&M.push(l.iridescence.thicknessTexture),M):[]}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof AW.b){if(!l.iridescence.isEnabled)return void U(W);this._wasUsed=!0,W.extensions=W.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(l.iridescence.texture),t=this._exporter._materialExporter.getTextureInfo(l.iridescence.thicknessTexture),L={iridescenceFactor:l.iridescence.bb,iridescenceIor:l.iridescence.indexOfRefraction,iridescenceThicknessMinimum:l.iridescence.minimumThickness,iridescenceThicknessMaximum:l.iridescence.maximumThickness,iridescenceTexture:M??void 0,iridescenceThicknessTexture:t??void 0};null===L.iridescenceTexture&&null===L.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(l),W.extensions[DW]=L}U(W)}))}}CU.RegisterExtension(DW,(U=>new oW(U)));const iW="KHR_materials_sheen";class OW{constructor(U){this.name=iW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){return l instanceof wU.c&&l.sheen.isEnabled&&l.sheen.texture?[l.sheen.texture]:[]}async postExportMaterialAsync(U,W,l){return await new Promise((U=>{if(l instanceof wU.c){if(!l.sheen.isEnabled)return void U(W);this._wasUsed=!0,null==W.extensions&&(W.extensions={});const M={sheenColorFactor:l.sheen.color.qk(),sheenRoughnessFactor:l.sheen.roughness??0};null===M.sheenColorTexture&&null===M.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(l),l.sheen.texture&&(M.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),l.sheen.textureRoughness&&!l.sheen.useRoughnessFromMainTexture?M.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.textureRoughness)??void 0:l.sheen.texture&&l.sheen.useRoughnessFromMainTexture&&(M.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(l.sheen.texture)??void 0),W.extensions[iW]=M}U(W)}))}}CU.RegisterExtension(iW,(U=>new OW(U)));const eW="KHR_materials_specular";class dW{constructor(U){this.name=eW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof wU.c&&this._isExtensionEnabled(l)?(l.metallicReflectanceTexture&&M.push(l.metallicReflectanceTexture),l.reflectanceTexture&&M.push(l.reflectanceTexture),M):M}_isExtensionEnabled(U){return!U.unlit&&(void 0!=U.metallicF0Factor&&1!=U.metallicF0Factor||void 0!=U.metallicReflectanceColor&&!U.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.metallicReflectanceTexture||null!=U.reflectanceTexture}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0,W.extensions=W.extensions||{};const U=this._exporter._materialExporter.getTextureInfo(l.metallicReflectanceTexture)??void 0,M=this._exporter._materialExporter.getTextureInfo(l.reflectanceTexture)??void 0,t={specularFactor:1==l.metallicF0Factor?void 0:l.metallicF0Factor,specularTexture:U,specularColorFactor:l.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:l.metallicReflectanceColor.qk(),specularColorTexture:M};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),W.extensions[eW]=t}U(W)}))}}CU.RegisterExtension(eW,(U=>new dW(U)));const HW="KHR_materials_transmission";class VW{constructor(U){this.name=HW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof wU.c&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&M.push(l.subSurface.thicknessTexture),M):M}_isExtensionEnabled(U){if(U.unlit)return!1;const W=U.subSurface;return W.isRefractionEnabled&&void 0!=W.refractionIntensity&&0!=W.refractionIntensity||this._hasTexturesExtension(U)}_hasTexturesExtension(U){return null!=U.subSurface.refractionIntensityTexture}async postExportMaterialAsync(U,W,l){if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const M=l.subSurface,t={transmissionFactor:0===M.refractionIntensity?void 0:M.refractionIntensity};if(this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),M.refractionIntensityTexture)if(M.useGltfStyleTextures){const U=await this._exporter._materialExporter.exportTextureAsync(M.refractionIntensityTexture,"image/png");U&&(t.transmissionTexture=U)}else J.b.Warn(`${U}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);W.extensions||(W.extensions={}),W.extensions[HW]=t}return W}}CU.RegisterExtension(HW,(U=>new VW(U)));const nW="KHR_materials_unlit";class xW{constructor(){this.name=nW,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(U,W,l){return new Promise((U=>{let M=!1;l instanceof wU.c?M=l.unlit:l instanceof KU.e&&(M=l.disableLighting),M&&(this._wasUsed=!0,null==W.extensions&&(W.extensions={}),W.extensions[nW]={}),U(W)}))}}CU.RegisterExtension(nW,(()=>new xW));const IW="KHR_materials_volume";class RW{constructor(U){this.name=IW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof wU.c&&this._isExtensionEnabled(l)?(l.subSurface.thicknessTexture&&M.push(l.subSurface.thicknessTexture),M):M}_isExtensionEnabled(U){if(U.unlit)return!1;const W=U.subSurface;return!(!W.isRefractionEnabled&&!W.isTranslucencyEnabled)&&(void 0!=W.maximumThickness&&0!=W.maximumThickness||void 0!=W.tintColorAtDistance&&W.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=W.tintColor&&W.tintColor!=r.e.White()||this._hasTexturesExtension(U))}_hasTexturesExtension(U){return null!=U.subSurface.thicknessTexture}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof wU.c&&this._isExtensionEnabled(l)){this._wasUsed=!0;const U=l.subSurface,M={thicknessFactor:0==U.maximumThickness?void 0:U.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(U.thicknessTexture)??void 0,attenuationDistance:U.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:U.tintColorAtDistance,attenuationColor:U.tintColor.equalsFloats(1,1,1)?void 0:U.tintColor.qk()};this._hasTexturesExtension(l)&&this._exporter._materialNeedsUVsSet.add(l),W.extensions=W.extensions||{},W.extensions[IW]=M}U(W)}))}}CU.RegisterExtension(IW,(U=>new RW(U)));const FW="EXT_materials_diffuse_roughness";class vW{constructor(U){this.name=FW,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=U}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(U,W,l){const M=[];return l instanceof AW.b&&l._baseDiffuseRoughness?(l._baseDiffuseRoughnessTexture&&M.push(l._baseDiffuseRoughnessTexture),M):[]}postExportMaterialAsync(U,W,l){return new Promise((U=>{if(l instanceof AW.b){if(!l._baseDiffuseRoughness)return void U(W);this._wasUsed=!0,W.extensions=W.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(l._baseDiffuseRoughnessTexture),t={diffuseRoughnessFactor:l._baseDiffuseRoughness,diffuseRoughnessTexture:M??void 0};null!==t.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(l),W.extensions[FW]=t}U(W)}))}}CU.RegisterExtension(FW,(U=>new vW(U)));const JW="KHR_texture_transform";class QW{constructor(){this.name=JW,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(U,W,l){if(l.va()||t.h.Warn(`${U}: /*@__KEY__*/"scene" is not defined for Babylon texture ${l.name}!`),(0!==l.uAng||0!==l.vAng)&&(t.h.Warn(`${U}: Texture ${l.name} with rotation in the u or v axis is not supported in glTF.`),0!==l.uRotationCenter||0!==l.vRotationCenter))return;const M={};let L=!1;if(0===l.uOffset&&0===l.vOffset||(M.offset=[l.uOffset,l.vOffset],L=!0),1===l.uScale&&1===l.vScale||(M.scale=[l.uScale,l.vScale],L=!0),0!==l.wAng){if(0!==l.uRotationCenter||0!==l.vRotationCenter){if(l.homogeneousRotationInUVTransform&&l.uScale!==l.vScale)return void t.h.Warn(`${U}: Texture ${l.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${JW}.`);t.h.Warn(`${U}: Texture ${l.name} with non-origin rotation center will be exported using an adjusted offset with ${JW}.`),M.offset=function(U){const{uOffset:W,vOffset:l,uRotationCenter:M,vRotationCenter:t,uScale:L,vScale:p,wAng:B}=U,k=Math.cos(B),A=Math.sin(B),q=M*L,y=t*p;return[W+(q*(1-k)+y*A),l+(y*(1-k)-q*A)]}(l)}M.rotation=-l.wAng,L=!0}0!==l.coordinatesIndex&&(M.texCoord=l.coordinatesIndex,L=!0),L&&(this._wasUsed=!0,W.extensions||(W.extensions={}),W.extensions[JW]=M)}}CU.RegisterExtension(JW,(()=>new QW));class GW{static CreateSTL(U){let W=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],p=arguments.length>5&&void 0!==arguments[5]&&arguments[5],B=arguments.length>6&&void 0!==arguments[6]&&arguments[6],k=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const A=function(U,W,l){const t=[3*U[l],3*U[l+1],3*U[l+2]],L=[new M.l(W[t[0]],W[t[0]+2],W[t[0]+1]),new M.l(W[t[1]],W[t[1]+2],W[t[1]+1]),new M.l(W[t[2]],W[t[2]+2],W[t[2]+1])],p=L[0].de(L[1]),B=L[2].de(L[1]);return{v:L,n:M.l.Cross(B,p).normalize()}},y=function(U,W,l,M){return W=j(U,W,l.x,M),W=j(U,W,l.y,M),j(U,W,l.z,M)},j=function(U,W,l,M){return U.setFloat32(W,l,M),W+4},w=function(U){if(B){let W=U;U instanceof s.b&&(W=U.sourceMesh);const l=W.getVerticesData(q.e.PositionKind,!0,!0);if(!l)return[];const t=M.l.Zero();let L;for(L=0;L<l.length;L+=3)M.l.TransformCoordinatesFromFloatsToRef(l[L],l[L+1],l[L+2],U.fk(!0),t).toArray(l,L);return l}return U.getVerticesData(q.e.PositionKind)||[]};B&&(p=!0);let K="",r=0,m=0;if(t){for(let l=0;l<U.length;l++){const W=U[l].hk();r+=W?W.length/3:0}const W=new ArrayBuffer(84+50*r);K=new DataView(W),m+=80,K.setUint32(m,r,L),m+=4}else k||(K="solid stlmesh\r\n");for(let M=0;M<U.length;M++){const W=U[M];!t&&k&&(K+="solid "+W.name+"\r\n"),!p&&W instanceof fU.e&&W.bakeCurrentTransformIntoVertices();const l=w(W),B=W.hk()||[];for(let U=0;U<B.length;U+=3){const W=A(B,l,U);t?(m=y(K,m,W.n,L),m=y(K,m,W.v[0],L),m=y(K,m,W.v[1],L),m=y(K,m,W.v[2],L),m+=2):(K+="\tfacet normal "+W.n.x+" "+W.n.y+" "+W.n.z+"\r\n",K+="\t\touter loop\r\n",K+="\t\t\tvertex "+W.v[0].x+" "+W.v[0].y+" "+W.v[0].z+"\r\n",K+="\t\t\tvertex "+W.v[1].x+" "+W.v[1].y+" "+W.v[1].z+"\r\n",K+="\t\t\tvertex "+W.v[2].x+" "+W.v[2].y+" "+W.v[2].z+"\r\n",K+="\t\tendloop\r\n",K+="\tendfacet\r\n")}!t&&k&&(K+="endsolid "+name+"\r\n")}if(t||k||(K+="endsolid stlmesh"),W){const U=document.createElement("a"),W=new Blob([K],{type:"application/octet-stream"});U.href=window.URL.createObjectURL(W),U.download=l+".stl",U.click()}return K}}function uW(U,W){let l=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const M=[];for(let t=0;t<U.length/l;t++){const L=U[t*l],p=U[t*l+1],B=U[t*l+2];M.push(`(${L.toPrecision(W.precision)}, ${p.toPrecision(W.precision)}, ${B.toPrecision(W.precision)})`)}return M.join(", ")}function bW(U,W){const l=[];for(let M=0;M<U.length/2;M++){const t=U[2*M],L=U[2*M+1];l.push(`(${t.toPrecision(W.precision)}, ${(1-L).toPrecision(W.precision)})`)}return l.join(", ")}function CW(U,W){const l=U.getVerticesData(q.e.PositionKind),M=U.getVerticesData(q.e.NormalKind);if(l&&M)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(U){var W;const l=null!==(W=U.hk())&&void 0!==W&&W.length?U.getTotalIndices():U.getTotalVertices();return Array(l/3).fill(3).join(", ")}(U)}]\n\t\tint[] faceVertexIndices = [${function(U){const W=U.hk(),l=[];if(null!==W)for(let M=0;M<W.length;M++)l.push(W[M]);else{const W=U.getTotalVertices();for(let U=0;U<W;U++)l.push(U)}return l.join(", ")}(U)}]\n\t\tnormal3f[] normals = [${uW(M,W)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${uW(l,W)}]\n        ${function(U,W){let l="";for(let t=0;t<4;t++){const M=t>0?t:"",L=U.getVerticesData(q.e.UVKind+(M?M+1:""));L&&(l+=`\n\t\ttexCoord2f[] primvars:st${M} = [${bW(L,W)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const M=U.getVerticesData(q.e.ColorKind);return M&&(l+=`\n\tcolor3f[] primvars:displayColor = [${uW(M,W,M.length/U.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),l}(U,W)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function PW(U,W){return`\n        def "Geometry"\n        {\n        ${CW(U,W)}\n        }\n        `}function SW(U){let W='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return W+=U,fflate.strToU8(W)}function cW(U){const W=U.m;return`( ${hW(W,0)}, ${hW(W,4)}, ${hW(W,8)}, ${hW(W,12)} )`}function hW(U,W){return`(${U[W+0]}, ${U[W+1]}, ${U[W+2]}, ${U[W+3]})`}function zW(U){const W="Object_"+U.uniqueId,l=function(U){const W=U.getWorldMatrix().clone(),l=U.va().useRightHandedSystem;if(!l){let M=U.parent;for(;M;){if(pU(M,l)){W.multiplyToRef(M.getWorldMatrix().invert(),W);break}M=M.parent}}return W.determinant()<0&&t.h.Warn(`Exporting mesh ${U.name} with negative scale. Result may look incorrect in destination engine.`),W}(U),M=cW(l);return`def Xform "${W}" (\n\tprepend references = @./geometries/Geometry_${U.vk.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${M}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${U.material.uniqueId}>\n}\n\n`}function aW(U){switch(U){case D.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function YW(U){return`(${U.x}, ${U.y})`}function XW(U){return`(${U.r}, ${U.g}, ${U.b})`}function TW(U,W,l,t,L,p){const B=U.getInternalTexture().uniqueId+"_"+U.invertY;L[B]=U;const k=U.coordinatesIndex>0?"st"+U.coordinatesIndex:"st",A=new M.h(U.uScale,U.vScale),q=new M.h(U.uOffset,U.vOffset),y=U.wAng,j=Math.sin(y),s=Math.cos(y);return q.y=1-q.y-A.y,q.x+=j*A.x,q.y+=(1-s)*A.y,`\n    def Shader "PrimvarReader_${l}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${k}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${l}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${W.uniqueId}/PrimvarReader_${l}.outputs:result>\n        float inputs:rotation = ${(y*(180/Math.PI)).toFixed(p.precision)}\n        float2 inputs:scale = ${YW(A)}\n        float2 inputs:translation = ${YW(q)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${U.uniqueId}_${l}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${B}.png@\n        float2 inputs:st.connect = </Materials/Material_${W.uniqueId}/Transform2d_${l}.outputs:result>\n        ${t?"float4 inputs:scale = "+function(U){return`(${U.r}, ${U.g}, ${U.b}, 1.0)`}(t):""}\n        token inputs:sourceColorSpace = "${U.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${aW(U.wrapU)}"\n        token inputs:wrapT = "${aW(U.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${W.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ul(U,W,l){const M="\t\t\t",t=[],L=[],{diffuseMap:p,cb:B,alphaCutOff:k,emissiveMap:A,emissive:q,normalMap:y,roughnessMap:j,roughnessChannel:s,roughness:w,metalnessMap:K,metalnessChannel:m,metalness:f,aoMap:g,aoMapChannel:E,aoMapIntensity:Z,alphaMap:N,ior:D,clearCoatEnabled:o,clearCoat:i,clearCoatMap:O,clearCoatRoughness:e,clearCoatRoughnessMap:d}=function(U){const W={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return U instanceof KU.e?{...W,diffuseMap:U.diffuseTexture,cb:U.diffuseColor,alphaCutOff:U.alphaCutOff,emissiveMap:U.emissiveTexture,emissive:U.emissiveColor,roughness:1,alphaMap:U.opacityTexture}:U instanceof AW.b?{...W,diffuseMap:U._albedoTexture,cb:U._albedoColor,alphaCutOff:U._alphaCutOff,emissiveMap:U._emissiveTexture,emissive:U._emissiveColor,normalMap:U._bumpTexture,roughnessMap:U._metallicTexture,roughnessChannel:U._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:U._roughness??1,metalnessMap:U._metallicTexture,metalnessChannel:U._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:U._metallic??0,aoMap:U._ambientTexture,aoMapChannel:U._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:U._ambientTextureStrength,alphaMap:U._opacityTexture,ior:U.subSurface.indexOfRefraction,clearCoatEnabled:U.clearCoat.isEnabled,clearCoat:U.clearCoat.bb,clearCoatMap:U.clearCoat.texture,clearCoatRoughness:U.clearCoat.roughness,clearCoatRoughnessMap:U.clearCoat.useRoughnessFromMainTexture?U.clearCoat.texture:U.clearCoat.textureRoughness}:W}(U);return null!==p?(t.push(`${M}color3f inputs:diffuseColor.connect = </Materials/Material_${U.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:rgb>`),U.needAlphaBlending()?t.push(`${M}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`):U.needAlphaTesting()&&(t.push(`${M}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${p.uniqueId}_diffuse.outputs:a>`),t.push(`${M}float inputs:opacityThreshold = ${k}`)),L.push(TW(p,U,"diffuse",B,W,l))):t.push(`${M}color3f inputs:diffuseColor = ${XW(B||r.e.White())}`),null!==A?(t.push(`${M}color3f inputs:emissiveColor.connect = </Materials/Material_${U.uniqueId}/Texture_${A.uniqueId}_emissive.outputs:rgb>`),L.push(TW(A,U,"emissive",q,W,l))):q&&q.toLuminance()>0&&t.push(`${M}color3f inputs:emissiveColor = ${XW(q)}`),null!==y&&(t.push(`${M}normal3f inputs:normal.connect = </Materials/Material_${U.uniqueId}/Texture_${y.uniqueId}_normal.outputs:rgb>`),L.push(TW(y,U,"rk",null,W,l))),null!==g&&(t.push(`${M}float inputs:occlusion.connect = </Materials/Material_${U.uniqueId}/Texture_${g.uniqueId}_occlusion.outputs:${E}>`),L.push(TW(g,U,"occlusion",new r.e(Z,Z,Z),W,l))),null!==j?(t.push(`${M}float inputs:roughness.connect = </Materials/Material_${U.uniqueId}/Texture_${j.uniqueId}_roughness.outputs:${s}>`),L.push(TW(j,U,"roughness",new r.e(w,w,w),W,l))):t.push(`${M}float inputs:roughness = ${w}`),null!==K?(t.push(`${M}float inputs:metallic.connect = </Materials/Material_${U.uniqueId}/Texture_${K.uniqueId}_metallic.outputs:${m}>`),L.push(TW(K,U,"metallic",new r.e(f,f,f),W,l))):t.push(`${M}float inputs:metallic = ${f}`),null!==N?(t.push(`${M}float inputs:opacity.connect = </Materials/Material_${U.uniqueId}/Texture_${N.uniqueId}_opacity.outputs:r>`),t.push(`${M}float inputs:opacityThreshold = 0.0001`),L.push(TW(N,U,"opacity",null,W,l))):t.push(`${M}float inputs:opacity = ${U.alpha}`),o&&(null!==O?(t.push(`${M}float inputs:clearcoat.connect = </Materials/Material_${U.uniqueId}/Texture_${O.uniqueId}_clearcoat.outputs:r>`),L.push(TW(O,U,"clearcoat",new r.e(i,i,i),W,l))):t.push(`${M}float inputs:clearcoat = ${i}`),null!==d?(t.push(`${M}float inputs:clearcoatRoughness.connect = </Materials/Material_${U.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),L.push(TW(d,U,"clearcoatRoughness",new r.e(e,e,e),W,l))):t.push(`${M}float inputs:clearcoatRoughness = ${e}`)),t.push(`${M}float inputs:ior = ${D}`),`\n\tdef Material "Material_${U.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${t.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${U.uniqueId}/PreviewSurface.outputs:surface>\n\n${L.join("\n")}\n\n\t}\n`}async function Wl(U,W,l){const L={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...W};"undefined"===typeof fflate&&await t.h.LoadScriptAsync(L.fflateUrl);const p={};p[L.modelFileName]=null;let B='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';B+=function(U){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===U.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${U.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${U.planeAnchoringAlignment}"`:""}\n            `}(L);const k={};for(const M of U.meshes){if(0===M.getTotalVertices())continue;const U=M,W=U.vk,A=U.material;if(!A||!W||l&&!l(U))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(A.getClassName())){const l="geometries/Geometry_"+W.uniqueId+".usda";if(!(l in p)){const U=PW(W,L);p[l]=SW(U)}A.uniqueId in k||(k[A.uniqueId]=A),B+=zW(U)}else t.h.Warn("USDZExportAsync does not support this material type: "+A.getClassName())}U.activeCamera&&L.exportCamera&&(B+=function(U,W){const l="Camera_"+U.uniqueId,t=cW(M.c.RotationY(Math.PI).multiply(U.getWorldMatrix()));if(U.mode===D.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${U.bk.toPrecision(W.precision)}, ${U.maxZ.toPrecision(W.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(U.orthoLeft||1)+Math.abs(U.orthoRight||1))).toPrecision(W.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(U.orthoTop||1)+Math.abs(U.orthoBottom||1))).toPrecision(W.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const M=U.getEngine().getAspectRatio(U),L=W.cameraSensorWidth||35;return`def Camera "${l}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${U.bk.toPrecision(W.precision)}, ${U.maxZ.toPrecision(W.precision)})\n\t\t\tfloat focalLength = ${(L/(2*Math.tan(.5*U.fov))).toPrecision(W.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(L*M).toPrecision(W.precision)}\n\t\t\tfloat verticalAperture = ${(L/M).toPrecision(W.precision)}            \n\t\t}\n\t\n\t`}}(U.activeCamera,L)),B+="\n            }\n        }\n    }";const A={};B+=function(U,W,l){const M=[];for(const t in U){const L=U[t];M.push(Ul(L,W,l))}return`\n    def "Materials"\n{\n${M.join("")}\n}\n\n`}(k,A,L),p[L.modelFileName]=fflate.strToU8(B);for(const M in A){const U=A[M],W=U.getSize(),l=await U.readPixels();if(!l)throw new Error("Texture data is not available");const t=await o.DumpTools.DumpDataAsync(W.width,W.height,l,"image/png",void 0,!1,!0);p[`textures/Texture_${M}.png`]=new Uint8Array(t).slice()}let q=0;for(const M in p){const U=p[M];if(!U)continue;q+=34+M.length;const W=63&q;if(4!==W){const l=new Uint8Array(64-W);p[M]=[U,{extra:{12345:l}}]}q=U.length}return fflate.zipSync(p,{level:0})}}}]);