"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11916:(t,q,S)=>{S.r(q),S.d(q,{EXT_materials_diffuse_roughness:()=>fq,EXT_mesh_gpu_instancing:()=>wt,GLTF2Export:()=>Nt,GLTFData:()=>C,KHR_draco_mesh_compression:()=>Sq,KHR_lights_punctual:()=>eq,KHR_materials_anisotropy:()=>bq,KHR_materials_clearcoat:()=>iq,KHR_materials_diffuse_transmission:()=>Iq,KHR_materials_dispersion:()=>vq,KHR_materials_emissive_strength:()=>xq,KHR_materials_ior:()=>Vq,KHR_materials_iridescence:()=>Uq,KHR_materials_sheen:()=>jq,KHR_materials_specular:()=>Qq,KHR_materials_transmission:()=>Xq,KHR_materials_unlit:()=>Yq,KHR_materials_volume:()=>uq,KHR_texture_transform:()=>mq,OBJExport:()=>L,STLExport:()=>Aq,USDZExportAsync:()=>qS,_ConvertToGLTFPBRMetallicRoughness:()=>G,_SolveMetallic:()=>X,__IGLTFExporterExtension:()=>r});var o=S(678),B=S(490),z=S(819);class L{static OBJ(t,q,S,L){const r=[];let e=1,C=1;q&&(S||(S="mat"),r.push("mtllib "+S+".mtl"));for(let Z=0;Z<t.length;Z++){const S=t[Z],b=S.name||`mesh${Z}}`;r.push(`o ${b}`);let O=null;if(L){const t=S.Ai(!0);O=new o.e,t.invertToRef(O),S.bakeTransformIntoVertices(t)}if(q){const t=S.material;t&&r.push("usemtl "+t.id)}const i=S.xi;if(!i){B.f.Warn("No geometry is present on the mesh");continue}const h=i.getVerticesData("position"),l=i.getVerticesData("Zi"),I=i.getVerticesData("uv"),a=i.Bi();let v=0,M=0;if(!h||!a){B.f.Warn("There are no position vertices or indices on the mesh!");continue}const x=t[0].va().useRightHandedSystem?1:-1;for(let t=0;t<h.length;t+=3)r.push("v "+h[t]*x+" "+h[t+1]+" "+h[t+2]),v++;if(null!=l)for(let t=0;t<l.length;t+=3)r.push("vn "+l[t]*x+" "+l[t+1]+" "+l[t+2]);if(null!=I)for(let t=0;t<I.length;t+=2)r.push("vt "+I[t]+" "+I[t+1]),M++;const k=["","",""],V=(S.material||S.va().defaultMaterial)._getEffectiveOrientation(S),[J,U]=V===z.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let t=0;t<a.length;t+=3){const q=[String(a[t]+e),String(a[t+J]+e),String(a[t+U]+e)],S=[String(a[t]+C),String(a[t+J]+C),String(a[t+U]+C)],o=q,B=null!=I?S:k,z=null!=l?q:k;r.push("f "+o[0]+"/"+B[0]+"/"+z[0]+" "+o[1]+"/"+B[1]+"/"+z[1]+" "+o[2]+"/"+B[2]+"/"+z[2])}L&&O&&S.bakeTransformIntoVertices(O),e+=v,C+=M}return r.join("\n")}static MTL(t){const q=[],S=t.material;q.push("newmtl mat1"),q.push("  Ns "+S.specularPower.toFixed(4)),q.push("  Ni 1.5000"),q.push("  d "+S.alpha.toFixed(4)),q.push("  Tr 0.0000"),q.push("  Tf 1.0000 1.0000 1.0000"),q.push("  illum 2"),q.push("  Ka "+S.ambientColor.r.toFixed(4)+" "+S.ambientColor.g.toFixed(4)+" "+S.ambientColor.b.toFixed(4)),q.push("  Kd "+S.diffuseColor.r.toFixed(4)+" "+S.diffuseColor.g.toFixed(4)+" "+S.diffuseColor.b.toFixed(4)),q.push("  Ks "+S.specularColor.r.toFixed(4)+" "+S.specularColor.g.toFixed(4)+" "+S.specularColor.b.toFixed(4)),q.push("  Ke "+S.emissiveColor.r.toFixed(4)+" "+S.emissiveColor.g.toFixed(4)+" "+S.emissiveColor.b.toFixed(4));S.ambientTexture&&q.push("  map_Ka "+S.ambientTexture.name),S.diffuseTexture&&q.push("  map_Kd "+S.diffuseTexture.name),S.specularTexture&&q.push("  map_Ks "+S.specularTexture.name),S.bumpTexture&&q.push("  map_bump -imfchan z "+S.bumpTexture.name),S.opacityTexture&&q.push("  map_d "+S.opacityTexture.name);return q.join("\n")}}var r=0,e=S(527);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const t in this.files){const q=this.files[t],S=new Blob([q],{type:(0,e.h)(t)});B.f.Download(S,t)}}}var Z=S(716),b=S(793),O=S(791),i=S(11922),h=S(2351),l=S(523),I=S(706),a=S(689);const v=a.HighestCommonFactor,M={...a,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:v};var x=S(2300),k=S(2306),V=S(11925),J=S(11932),U=S(2488);const H=1e-6,j=new I.c(.04,.04,.04),y=1024,Q=I.c.White(),K=I.c.Black();function X(t,q,S){if(q<j.r)return 0;const o=j.r,B=t*S/(1-j.r)+q-2*j.r,z=B*B-4*o*(j.r-q);return M.Clamp((-B+Math.sqrt(z))/(2*o),0,1)}function G(t){const q=t.diffuseColor.toLinearSpace(t.va().getEngine().useExactSrgbConversions).scale(.5),S=t.alpha,B=function(t){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new o.l(0,1),S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new o.l(0,.1),B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new o.l(0,.1),z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new o.l(1300,.1);return function(t,q,S,o,B){return(1-t)*(1-t)*(1-t)*q+3*(1-t)*(1-t)*t*S+3*(1-t)*t*t*o+t*t*t*B}(Math.pow(t/z.x,.333333),q.y,S.y,B.y,z.y)}(M.Clamp(t.specularPower,0,y));return{baseColorFactor:[q.r,q.g,q.b,S],metallicFactor:0,roughnessFactor:B}}function Y(t,q){q.needAlphaBlending()?t.alphaMode="BLEND":q.needAlphaTesting()&&(t.alphaMode="MASK",t.alphaCutoff=q.alphaCutOff)}function n(t,q,S){const o=new Uint8Array(t*q*4);for(let B=0;B<o.length;B+=4)o[B]=o[B+1]=o[B+2]=o[B+3]=255;return V.d.CreateRGBATexture(o,t,q,S)}function u(t){if(t instanceof Uint8Array){const q=t.length,S=new Float32Array(t.length);for(let o=0;o<q;++o)S[o]=t[o]/255;return S}if(t instanceof Float32Array)return t;throw new Error("Unsupported pixel format!")}class W{constructor(t){this._exporter=t,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(t){return t?this._textureMap.get(t)??null:null}async exportStandardMaterialAsync(t,q,S){const o=G(t),z={name:t.name};if(null==t.Fi||t.Fi||(t.twoSidedLighting||B.f.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),z.doubleSided=!0),S){const S=[],B=t.diffuseTexture;B&&S.push(this.exportTextureAsync(B,q).then((t=>{t&&(o.baseColorTexture=t)})));const L=t.bumpTexture;L&&S.push(this.exportTextureAsync(L,q).then((t=>{t&&(z.normalTexture=t,1!==L.level&&(z.normalTexture.scale=L.level))})));const r=t.emissiveTexture;r&&(z.emissiveFactor=[1,1,1],S.push(this.exportTextureAsync(r,q).then((t=>{t&&(z.emissiveTexture=t)}))));const e=t.ambientTexture;e&&S.push(this.exportTextureAsync(e,q).then((t=>{if(t){const q={index:t.index};z.occlusionTexture=q}}))),S.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(S))}(t.alpha<1||t.opacityTexture)&&(t.alphaMode===J.d.ALPHA_COMBINE?z.alphaMode="BLEND":B.f.Warn(t.name+": glTF 2.0 does not support alpha mode: "+t.alphaMode.toString())),t.emissiveColor&&!t.emissiveColor.equalsWithEpsilon(K,H)&&(z.emissiveFactor=t.emissiveColor.Gi()),z.pbrMetallicRoughness=o,Y(z,t),await this._finishMaterialAsync(z,t,q);const L=this._exporter._materials;return L.push(z),L.length-1}async _finishMaterialAsync(t,q,S){const o=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",t,q),B=[];for(const z of o)B.push(this.exportTextureAsync(z,S));await Promise.all(B),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",t,q)}async _getImageDataAsync(t,q,o,B){const z=J.d.TEXTURETYPE_UNSIGNED_BYTE,L=this._exporter._babylonScene,r=L.getEngine(),e=r.createRawTexture(t,q,o,J.d.TEXTUREFORMAT_RGBA,!1,!0,k.b.NEAREST_SAMPLINGMODE,null,z);r.isWebGPU?await S.e(45).then(S.bind(S,13471)):await S.e(46).then(S.bind(S,13473)),await x.m.ApplyPostProcess("pass",e,L,z,J.d.TEXTURE_NEAREST_SAMPLINGMODE,J.d.TEXTUREFORMAT_RGBA);const C=await r._readTexturePixels(e,q,o);return await U.DumpTools.DumpDataAsync(q,o,C,B,void 0,!0,!0)}_resizeTexturesToSameDimensions(t,q,S){const o=t?t.getSize():{width:0,height:0},B=q?q.getSize():{width:0,height:0};let z,L;return o.width<B.width?(z=t&&t instanceof k.b?x.m.CreateResizedCopy(t,B.width,B.height,!0):n(B.width,B.height,S),L=q):o.width>B.width?(L=q&&q instanceof k.b?x.m.CreateResizedCopy(q,o.width,o.height,!0):n(o.width,o.height,S),z=t):(z=t,L=q),{texture1:z,texture2:L}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,q,S,o){const B=new Array;if(!t&&!q)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const z=t?t.va():q?q.va():null;if(z){var L;const r=this._resizeTexturesToSameDimensions(t,q,z),e=null===(L=r.texture1)||void 0===L?void 0:L.getSize();let C,Z;const b=e.width,O=e.height,i=await r.texture1.readPixels(),h=await r.texture2.readPixels();if(!i)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=u(i),!h)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");Z=u(h);const l=Z.byteLength,a=new Uint8Array(l),v=new Uint8Array(l),M=4,x=K;let k=0,V=0;for(let t=0;t<O;++t)for(let q=0;q<b;++q){const o=(b*t+q)*M,B={diffuseColor:new I.c(C[o],C[o+1],C[o+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(S.diffuseColor),specularColor:new I.c(Z[o],Z[o+1],Z[o+2]).toLinearSpace(z.getEngine().useExactSrgbConversions).multiply(S.specularColor),glossiness:Z[o+3]*S.glossiness},L=this._convertSpecularGlossinessToMetallicRoughness(B);x.r=Math.max(x.r,L.baseColor.r),x.g=Math.max(x.g,L.baseColor.g),x.b=Math.max(x.b,L.baseColor.b),k=Math.max(k,L.metallic),V=Math.max(V,L.roughness),v[o]=255*L.baseColor.r,v[o+1]=255*L.baseColor.g,v[o+2]=255*L.baseColor.b,v[o+3]=r.texture1.Lj?255*C[o+3]:255,a[o]=0,a[o+1]=255*L.roughness,a[o+2]=255*L.metallic,a[o+3]=255}const J={baseColor:x,metallic:k,roughness:V};let U=!1,j=!1;for(let t=0;t<O;++t)for(let q=0;q<b;++q){const S=(b*t+q)*M;v[S]/=J.baseColor.r>H?J.baseColor.r:1,v[S+1]/=J.baseColor.g>H?J.baseColor.g:1,v[S+2]/=J.baseColor.b>H?J.baseColor.b:1;const o=I.c.FromInts(v[S],v[S+1],v[S+2]).toGammaSpace(z.getEngine().useExactSrgbConversions);v[S]=255*o.r,v[S+1]=255*o.g,v[S+2]=255*o.b,o.equalsWithEpsilon(Q,H)||(j=!0),a[S+1]/=J.roughness>H?J.roughness:1,a[S+2]/=J.metallic>H?J.metallic:1;I.c.FromInts(255,a[S+1],a[S+2]).equalsWithEpsilon(Q,H)||(U=!0)}return U&&B.push(this._getImageDataAsync(a,b,O,o).then((t=>{J.metallicRoughnessTextureData=t}))),j&&B.push(this._getImageDataAsync(v,b,O,o).then((t=>{J.baseColorTextureData=t}))),await Promise.all(B).then((()=>J))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(t){const q=this._getPerceivedBrightness(t.diffuseColor),S=this._getPerceivedBrightness(t.specularColor),o=1-this._getMaxComponent(t.specularColor),B=X(q,S,o),z=t.diffuseColor.scale(o/(1-j.r)/Math.max(1-B)),L=t.specularColor.Kg(j.scale(1-B)).scale(1/Math.max(B));let r=I.c.Lerp(z,L,B*B);r=r.clampToRef(0,1,r);return{baseColor:r,metallic:B,roughness:1-t.glossiness}}_getPerceivedBrightness(t){return t?Math.sqrt(.299*t.r*t.r+.587*t.g*t.g+.114*t.b*t.b):0}_getMaxComponent(t){return t?Math.max(t.r,Math.max(t.g,t.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(t,q,S,o){const B=[],z={baseColor:t._albedoColor,metallic:t._metallic,roughness:t._roughness};if(o){t._albedoTexture&&B.push(this.exportTextureAsync(t._albedoTexture,q).then((t=>{t&&(S.baseColorTexture=t)})));const o=t._metallicTexture;o&&B.push(this.exportTextureAsync(o,q).then((t=>{t&&(S.metallicRoughnessTexture=t)})))}return B.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(B)),z}_getTextureSampler(t){const q={};if(!t||!(t instanceof k.b))return q;const S=this._getGLTFTextureWrapMode(t.wrapU);10497!==S&&(q.wrapS=S);const o=this._getGLTFTextureWrapMode(t.wrapV);switch(10497!==o&&(q.wrapT=o),t.samplingMode){case k.b.LINEAR_LINEAR:q.magFilter=9729,q.minFilter=9729;break;case k.b.LINEAR_NEAREST:q.magFilter=9729,q.minFilter=9728;break;case k.b.NEAREST_LINEAR:q.magFilter=9728,q.minFilter=9729;break;case k.b.NEAREST_LINEAR_MIPLINEAR:q.magFilter=9728,q.minFilter=9987;break;case k.b.NEAREST_NEAREST:q.magFilter=9728,q.minFilter=9728;break;case k.b.NEAREST_LINEAR_MIPNEAREST:q.magFilter=9728,q.minFilter=9985;break;case k.b.LINEAR_NEAREST_MIPNEAREST:q.magFilter=9729,q.minFilter=9984;break;case k.b.LINEAR_NEAREST_MIPLINEAR:q.magFilter=9729,q.minFilter=9986;break;case k.b.NEAREST_NEAREST_MIPLINEAR:q.magFilter=9728,q.minFilter=9986;break;case k.b.LINEAR_LINEAR_MIPLINEAR:q.magFilter=9729,q.minFilter=9987;break;case k.b.LINEAR_LINEAR_MIPNEAREST:q.magFilter=9729,q.minFilter=9985;break;case k.b.NEAREST_NEAREST_MIPNEAREST:q.magFilter=9728,q.minFilter=9984}return q}_getGLTFTextureWrapMode(t){switch(t){case k.b.WRAP_ADDRESSMODE:return 10497;case k.b.CLAMP_ADDRESSMODE:return 33071;case k.b.MIRROR_ADDRESSMODE:return 33648;default:return B.f.Error(`Unsupported Texture Wrap Mode ${t}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(t,q,S,o){const B={diffuseColor:t._albedoColor,specularColor:t._reflectivityColor,glossiness:t._microSurface},z=t._albedoTexture,L=t._reflectivityTexture,r=t._useMicroSurfaceFromReflectivityMapAlpha;if(L&&!r)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((z||L)&&o){this._exporter._materialNeedsUVsSet.add(t);const o=this._exportTextureSampler(z||L),r=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(z,L,B,q),e=this._exporter._textures;if(r.baseColorTextureData){const t=this._exportImage(`baseColor${e.length}`,q,r.baseColorTextureData);S.baseColorTexture=this._exportTextureInfo(t,o,null===z||void 0===z?void 0:z.coordinatesIndex)}if(r.metallicRoughnessTextureData){const t=this._exportImage(`metallicRoughness${e.length}`,q,r.metallicRoughnessTextureData);S.metallicRoughnessTexture=this._exportTextureInfo(t,o,null===L||void 0===L?void 0:L.coordinatesIndex)}return r}return this._convertSpecularGlossinessToMetallicRoughness(B)}async exportPBRMaterialAsync(t,q,S){const o={},B={name:t.name},z=t.isMetallicWorkflow();if(z){const q=t._albedoColor,S=t.alpha;q&&(o.baseColorFactor=[q.r,q.g,q.b,S])}const L=z?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(t,q,o,S):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(t,q,o,S);await this._setMetallicRoughnessPbrMaterialAsync(L,t,B,o,q,S),await this._finishMaterialAsync(B,t,q);const r=this._exporter._materials;return r.push(B),r.length-1}async _setMetallicRoughnessPbrMaterialAsync(t,q,S,o,z,L){if(Y(S,q),t.baseColor.equalsWithEpsilon(Q,H)&&M.WithinEpsilon(q.alpha,1,H)||(o.baseColorFactor=[t.baseColor.r,t.baseColor.g,t.baseColor.b,q.alpha]),null!=t.metallic&&1!==t.metallic&&(o.metallicFactor=t.metallic),null!=t.roughness&&1!==t.roughness&&(o.roughnessFactor=t.roughness),null==q.Fi||q.Fi||(q._twoSidedLighting||B.f.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),S.doubleSided=!0),L){const t=[],o=q._bumpTexture;o&&t.push(this.exportTextureAsync(o,z).then((t=>{t&&(S.normalTexture=t,1!==o.level&&(S.normalTexture.scale=o.level))})));const B=q._ambientTexture;B&&t.push(this.exportTextureAsync(B,z).then((t=>{if(t){const o={index:t.index,texCoord:t.texCoord,extensions:t.extensions};S.occlusionTexture=o;const B=q._ambientTextureStrength;B&&(o.strength=B)}})));const L=q._emissiveTexture;L&&t.push(this.exportTextureAsync(L,z).then((t=>{t&&(S.emissiveTexture=t)}))),t.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(t))}const r=q._emissiveColor;r.equalsWithEpsilon(K,H)||(S.emissiveFactor=r.Gi()),S.pbrMetallicRoughness=o}_getPixelsFromTextureAsync(t){return function(t){switch(t){case J.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case J.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case J.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case J.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case J.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case J.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case J.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case J.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case J.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case J.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case J.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case J.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case J.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(t.textureFormat)?(0,x.i)(t,t._texture.width,t._texture.height):(t.textureType,J.d.TEXTURETYPE_UNSIGNED_BYTE,t.readPixels())}async exportTextureAsync(t,q){const S=this._exporter._extensionsPreExportTextureAsync("exporter",t,q);return S?await S.then((async S=>S?await this._exportTextureInfoAsync(S,q):await this._exportTextureInfoAsync(t,q))):await this._exportTextureInfoAsync(t,q)}async _exportTextureInfoAsync(t,q){let S=this._textureMap.get(t);if(!S){const o=await this._getPixelsFromTextureAsync(t);if(!o)return null;const z=this._exportTextureSampler(t),L=t.mimeType;if(L)switch(L){case"image/jpeg":case"image/png":case"image/webp":q=L;break;default:B.f.Warn(`Unsupported media type: ${L}. Exporting texture as PNG.`)}const r=this._internalTextureToImage,e=t.getInternalTexture().uniqueId;r[e]||(r[e]={});let C=r[e][q];if(void 0===C){const S=t.getSize();C=(async()=>{const B=await this._getImageDataAsync(o,S.width,S.height,q);return this._exportImage(t.name,q,B)})(),r[e][q]=C}S=this._exportTextureInfo(await C,z,t.coordinatesIndex),this._textureMap.set(t,S),this._exporter._extensionsPostExportTextures("exporter",S,t)}return S}_exportImage(t,q,S){const o=this._exporter._images;let z;if(this._exporter._shouldUseGlb){z={name:t,mimeType:q,bufferView:void 0};const o=this._exporter._bufferManager.createBufferView(new Uint8Array(S));this._exporter._bufferManager.setBufferView(z,o)}else{const L=t.replace(/\.\/|\/|\.\\|\\/g,"_"),r=function(t){switch(t){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(q);let e=L+r;o.some((t=>t.uri===e))&&(e=`${L}_${B.f.RandomId()}${r}`),z={name:t,uri:e},this._exporter._imageData[e]={data:S,mimeType:q}}return o.push(z),o.length-1}_exportTextureInfo(t,q,S){const o=this._exporter._textures;let B=o.findIndex((S=>S.sampler==q&&S.source===t));-1===B&&(B=o.length,o.push({source:t,sampler:q}));const z={index:B};return S&&(z.texCoord=S),z}_exportTextureSampler(t){const q=this._getTextureSampler(t),S=this._exporter._samplers,o=S.findIndex((t=>t.minFilter===q.minFilter&&t.magFilter===q.magFilter&&t.wrapS===q.wrapS&&t.wrapT===q.wrapT));return-1!==o?o:(S.push(q),S.length-1)}}var f=S(726),D=S(496),m=S(11936),A=S(682);const c=o.o.Zero(),s=o.g.Identity(),g=o.o.One(),N=new o.o(-1,1,1);function T(t,q){const{byteOffset:S,byteStride:o,type:B,normalized:z}=t,L=t.getSize(),r=q.reduce(((t,q)=>q.getTotalVertices()>t?q.getTotalVertices():t),-Number.MAX_VALUE);return{byteOffset:S,byteStride:o,componentCount:L,type:B,count:r*L,normalized:z,totalVertices:r,kind:t.getKind()}}function w(t){switch(t){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function E(t){switch(t){case Z.i.PositionKind:case Z.i.NormalKind:case Z.i.TangentKind:case Z.i.ColorKind:case Z.i.MatricesIndicesKind:case Z.i.MatricesIndicesExtraKind:case Z.i.MatricesWeightsKind:case Z.i.MatricesWeightsExtraKind:case Z.i.UVKind:case Z.i.UV2Kind:case Z.i.UV3Kind:case Z.i.UV4Kind:case Z.i.UV5Kind:case Z.i.UV6Kind:return!0}return!1}function p(t){switch(t){case z.c.TriangleFillMode:return 4;case z.c.TriangleStripDrawMode:return 5;case z.c.TriangleFanDrawMode:return 6;case z.c.PointListDrawMode:case z.c.PointFillMode:return 0;case z.c.LineLoopDrawMode:return 2;case z.c.LineListDrawMode:return 1;case z.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${t}`)}function P(t){const q=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);q>0&&(t.x/=q,t.y/=q,t.z/=q)}function F(t){return t.x*=-1,t}function d(t){if(t.x*t.x+t.y*t.y>.5){const q=Math.abs(t.x),S=Math.abs(t.y);if(q>S){const S=Math.sign(t.x);t.x=q,t.y*=-S,t.z*=-S,t.w*=S}else{const q=Math.sign(t.y);t.x*=-q,t.y=S,t.z*=q,t.w*=-q}}else{const q=Math.abs(t.z),S=Math.abs(t.w);if(q>S){const S=Math.sign(t.z);t.x*=-S,t.y*=S,t.z=q,t.w*=-S}else{const q=Math.sign(t.w);t.x*=q,t.y*=-q,t.z*=-q,t.w=S}}return t}function R(t){t.ni(-t.z,t.w,t.x,-t.y)}function tt(t,q){const S=o.o.FromArrayToRef(q.translation||[0,0,0],0,o.j.wi[0]),B=o.g.FromArrayToRef(q.rotation||[0,0,0,1],0,o.j.Quaternion[0]),z=o.e.ComposeToRef(g,B,S,o.j.Matrix[0]),L=o.o.FromArrayToRef(t.translation||[0,0,0],0,o.j.wi[2]),r=o.g.FromArrayToRef(t.rotation||[0,0,0,1],0,o.j.Quaternion[1]),e=o.e.ComposeToRef(g,r,L,o.j.Matrix[1]);z.multiplyToRef(e,e),e.decompose(void 0,B,S),S.equalsWithEpsilon(c,A.d)?delete q.translation:q.translation=S.Gi(),B.equalsWithEpsilon(s,A.d)?delete q.rotation:q.rotation=B.Gi(),q.scale&&delete q.scale}function qt(t,q){if(!(q instanceof b.e))return!1;if(!(1===q.getChildren().length&&0===t.getChildren().length&&t.parent===q))return!1;const S=t.va(),o=t instanceof m.c&&!S.useRightHandedSystem?N:g;return!!q.oi.equalsWithEpsilon(o,A.d)||(D.c.Warn(`Cannot collapse node ${t.name} into parent node ${q.name} with modified scaling.`),!1)}function St(t){if(t instanceof Array){const q=new Float32Array(t);return new Uint8Array(q.buffer,q.byteOffset,q.byteLength)}return ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}function ot(t,q){for(const[S,o]of Object.entries(t)){const B=q[S];(Array.isArray(o)&&Array.isArray(B)&&Bt(o,B)||o===B)&&delete t[S]}return t}function Bt(t,q){return t.length===q.length&&t.every(((t,S)=>t===q[S]))}const zt=o.e.Compose(new o.o(-1,1,1),o.g.Identity(),o.o.Zero());function Lt(t,q){if(!(t instanceof b.e))return!1;if(q){if(!t.getWorldMatrix().equalsWithEpsilon(o.e.IdentityReadOnly,A.d))return!1}else{if(!t.getWorldMatrix().multiplyToRef(zt,o.j.Matrix[0]).equalsWithEpsilon(o.e.IdentityReadOnly,A.d))return!1}return!(t instanceof O.b&&t.xi)}const rt=new Map([[Int8Array,(t,q,S)=>t.setInt8(q,S)],[Uint8Array,(t,q,S)=>t.setUint8(q,S)],[Uint8ClampedArray,(t,q,S)=>t.setUint8(q,S)],[Int16Array,(t,q,S)=>t.setInt16(q,S,!0)],[Uint16Array,(t,q,S)=>t.setUint16(q,S,!0)],[Int32Array,(t,q,S)=>t.setInt32(q,S,!0)],[Uint32Array,(t,q,S)=>t.setUint32(q,S,!0)],[Float32Array,(t,q,S)=>t.setFloat32(q,S,!0)],[Float64Array,(t,q,S)=>t.setFloat64(q,S,!0)]]);class et{writeTypedArray(t){this._checkGrowBuffer(t.byteLength);const q=rt.get(t.constructor);for(let S=0;S<t.length;S++)q(this._dataView,this._byteOffset,t[S]),this._byteOffset+=t.BYTES_PER_ELEMENT}constructor(t){this._data=new Uint8Array(t),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(t){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,t),this._byteOffset++}writeInt8(t){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,t),this._byteOffset++}writeInt16(t){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,t,!0),this._byteOffset+=2}writeUInt16(t){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,t,!0),this._byteOffset+=2}writeInt32(t){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,t,!0),this._byteOffset+=4}writeUInt32(t){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat32(t){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat64(t){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,t,!0),this._byteOffset+=8}_checkGrowBuffer(t){const q=this.byteOffset+t;if(q>this._data.byteLength){const t=new Uint8Array(2*q);t.set(this._data),this._data=t,this._dataView=new DataView(this._data.buffer)}}}function Ct(t){return t%4===0?4:t%2===0?2:1}class Zt{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(t){let q=0;this._bufferViewToData.forEach((t=>{q+=t.byteLength}));const S=new et(q),o=Array.from(this._bufferViewToData.keys()).sort(((t,q)=>Ct(q.byteLength)-Ct(t.byteLength)));for(const B of o){B.byteOffset=S.byteOffset,t.push(B);const q=t.length-1,o=this.getPropertiesWithBufferView(B);for(const t of o)t.bufferView=q;S.writeTypedArray(this._bufferViewToData.get(B)),this._bufferViewToData.delete(B)}return S.getOutputData()}createBufferView(t,q){const S={buffer:0,byteOffset:void 0,byteLength:t.byteLength,byteStride:q};return this._bufferViewToData.set(S,t),S}createAccessor(t,q,S,o,B,z,L){this._verifyBufferView(t);const r={bufferView:void 0,componentType:S,count:o,type:q,min:null===z||void 0===z?void 0:z.min,max:null===z||void 0===z?void 0:z.max,normalized:L,byteOffset:B};return this.setBufferView(r,t),this._accessorToBufferView.set(r,t),r}setBufferView(t,q){this._verifyBufferView(q);this.getPropertiesWithBufferView(q).push(t)}removeBufferView(t){const q=this.getPropertiesWithBufferView(t);for(const S of q)void 0!==S.bufferView&&delete S.bufferView;this._bufferViewToData.delete(t),this._bufferViewToProperties.delete(t),this._accessorToBufferView.forEach(((q,S)=>{q===t&&(void 0!==S.byteOffset&&delete S.byteOffset,this._accessorToBufferView.delete(S))}))}getBufferView(t){const q=this._accessorToBufferView.get(t);return this._verifyBufferView(q),q}getPropertiesWithBufferView(t){return this._verifyBufferView(t),this._bufferViewToProperties.set(t,this._bufferViewToProperties.get(t)??[]),this._bufferViewToProperties.get(t)}getData(t){return this._verifyBufferView(t),this._bufferViewToData.get(t)}_verifyBufferView(t){if(void 0===t||!this._bufferViewToData.has(t))throw new Error(`BufferView ${t} not found in BufferManager.`)}}var bt,Ot=S(644),it=S(836),ht=S(11942),lt=S(12011),It=S(12019),at=S(12032),vt=S(483),Mt=S(12037);!function(t){t[t.INTANGENT=0]="INTANGENT",t[t.OUTTANGENT=1]="OUTTANGENT"}(bt||(bt={}));class xt{static _IsTransformable(t){return t&&(t instanceof b.e||t instanceof Ot.d||t instanceof Mt.b)}static _CreateNodeAnimation(t,q,S,o,z){if(this._IsTransformable(t)){const L=[],r=[],e=q.getKeys(),C=xt._CalculateMinMaxKeyFrames(e),Z=xt._DeduceInterpolation(e,S,o),b=Z.interpolationType,O=Z.shouldBakeAnimation;if(O?xt._CreateBakedAnimation(t,q,S,C.min,C.max,q.framePerSecond,z,L,r,C,o):"LINEAR"===b||"STEP"===b?xt._CreateLinearOrStepAnimation(t,q,S,L,r,o):"CUBICSPLINE"===b?xt._CreateCubicSplineAnimation(t,q,S,L,r,o):xt._CreateBakedAnimation(t,q,S,C.min,C.max,q.framePerSecond,z,L,r,C,o),L.length&&r.length){return{inputs:L,outputs:r,samplerInterpolation:b,inputsMin:O?C.min:B.f.FloatRound(C.min/q.framePerSecond),inputsMax:O?C.max:B.f.FloatRound(C.max/q.framePerSecond)}}}return null}static _DeduceAnimationInfo(t){let q=null,S="VEC3",o=!1;const z=t.targetProperty.split(".");switch(z[0]){case"oi":q="scale";break;case"position":q="translation";break;case"rotation":S="VEC4",q="rotation";break;case"rotationQuaternion":S="VEC4",o=!0,q="rotation";break;case"influence":S="SCALAR",q="weights";break;default:B.f.Error(`Unsupported animatable property ${z[0]}`)}return q?{animationChannelTargetPath:q,dataAccessorType:S,useQuaternion:o}:(B.f.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(t,q,S,o,B,z,L,r,e,C,Z){let b;if(xt._IsTransformable(t)&&t.animations)for(const O of t.animations){if(Z&&!Z(O))continue;const B=xt._DeduceAnimationInfo(O);B&&(b={name:O.name,samplers:[],channels:[]},xt._AddAnimation(`${O.name}`,O.hasRunningRuntimeAnimations?q:b,t,O,B.dataAccessorType,B.animationChannelTargetPath,o,z,L,r,B.useQuaternion,e,C),b.samplers.length&&b.channels.length&&S.push(b))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(t,q,S,o,B,z,L,r,e,C,Z){let b;if(t instanceof vt.c){const B=t.morphTargetManager;if(B)for(let O=0;O<B.numTargets;++O){const i=B.getTarget(O);for(const h of i.animations){if(Z&&!Z(h))continue;const i=new It.b(`${h.name}`,"influence",h.framePerSecond,h.dataType,h.loopMode,h.enableBlending),l=[],I=h.getKeys();for(let t=0;t<I.length;++t){const q=I[t];for(let t=0;t<B.numTargets;++t)t==O?l.push(q):l.push({frame:q.frame,value:0})}i.setKeys(l);const a=xt._DeduceAnimationInfo(i);a&&(b={name:i.name,samplers:[],channels:[]},xt._AddAnimation(h.name,h.hasRunningRuntimeAnimations?q:b,t,i,a.dataAccessorType,a.animationChannelTargetPath,o,z,L,r,a.useQuaternion,e,C,B.numTargets),b.samplers.length&&b.channels.length&&S.push(b))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(t,q,S,o,B,z,L,r,e){let C;if(t.animationGroups){const b=t.animationGroups;for(const O of b){const b=new Map,i=new Map,h=new Set,l=O.to-O.from;C={name:O.name,channels:[],samplers:[]};for(let q=0;q<O.targetedAnimations.length;++q){const l=O.targetedAnimations[q],I=l.target,a=l.animation;if(e&&!e(a))continue;const v=r.has(I);if(this._IsTransformable(I)||1===I.length&&this._IsTransformable(I[0])){const t=xt._DeduceAnimationInfo(l.animation);if(t){const q=this._IsTransformable(I)?I:this._IsTransformable(I[0])?I[0]:null;q&&xt._AddAnimation(`${a.name}`,C,q,a,t.dataAccessorType,t.animationChannelTargetPath,S,o,B,z,t.useQuaternion,L,v)}}else if(I instanceof at.b||1===I.length&&I[0]instanceof at.b){if(xt._DeduceAnimationInfo(l.animation)){const q=I instanceof at.b?I:I[0];if(q){const S=t.morphTargetManagers.find((t=>{for(let S=0;S<t.numTargets;++S)if(t.getTarget(S)===q)return!0;return!1}));if(S){const o=t.meshes.find((t=>t.morphTargetManager===S));var Z;if(o)b.has(o)||b.set(o,new Map),null===(Z=b.get(o))||void 0===Z||Z.set(q,a),h.add(o),i.set(o,a)}}}}}h.forEach((t=>{const q=t.morphTargetManager;let r=null;const e=[],Z=i.get(t).getKeys(),h=Z.length;for(let S=0;S<h;++S)for(let o=0;o<q.numTargets;++o){const B=q.getTarget(o),z=b.get(t);if(z){const q=z.get(B);q?(r||(r=new It.b(`${O.name}_${t.name}_MorphWeightAnimation`,"influence",q.framePerSecond,It.b.ANIMATIONTYPE_FLOAT,q.loopMode,q.enableBlending)),e.push(q.getKeys()[S])):e.push({frame:O.from+l/h*S,value:B.influence,inTangent:Z[0].inTangent?0:void 0,outTangent:Z[0].outTangent?0:void 0})}}r.setKeys(e);const I=xt._DeduceAnimationInfo(r);I&&xt._AddAnimation(`${O.name}_${t.name}_MorphWeightAnimation`,C,t,r,I.dataAccessorType,I.animationChannelTargetPath,S,o,B,z,I.useQuaternion,L,!1,null===q||void 0===q?void 0:q.numTargets)})),C.channels.length&&C.samplers.length&&q.push(C)}}}static _AddAnimation(t,q,S,B,z,L,r,e,C,Z,b,O,i,h){const l=xt._CreateNodeAnimation(S,B,L,b,O);let I,a,v,M,x,k;if(l){if(h){let t=0,q=0;const S=[];for(;l.inputs.length>0;)q=l.inputs.shift(),t%h==0&&S.push(q),t++;l.inputs=S}const t=r.get(S),B=new Float32Array(l.inputs);I=e.createBufferView(B),a=e.createAccessor(I,"SCALAR",5126,l.inputs.length,void 0,{min:[l.inputsMin],max:[l.inputsMax]}),Z.push(a),v=Z.length-1;const C=new o.g,b=new o.o,O=new o.o,V=S instanceof Ot.d,J=w(z),U=new Float32Array(l.outputs.length*J);l.outputs.forEach((function(t,q){let S=t;switch(L){case"translation":i&&(o.o.FromArrayToRef(t,0,O),F(O),O.toArray(S));break;case"rotation":4===t.length?o.g.FromArrayToRef(t,0,C):(S=new Array(4),o.o.FromArrayToRef(t,0,b),o.g.FromEulerVectorToRef(b,C)),i&&(d(C),V&&R(C)),C.toArray(S)}U.set(S,q*J)})),I=e.createBufferView(U),a=e.createAccessor(I,z,5126,l.outputs.length),Z.push(a),M=Z.length-1,x={interpolation:l.samplerInterpolation,input:v,output:M},q.samplers.push(x),k={sampler:q.samplers.length-1,target:{node:t,path:L}},q.channels.push(k)}}static _CreateBakedAnimation(t,q,S,z,L,r,e,C,Z,b,O){let i;const h=o.g.Identity();let l,I=null,a=null,v=null,M=null,x=null,k=null;b.min=B.f.FloatRound(z/r);const V=q.getKeys();for(let o=0,J=V.length;o<J;++o){if(k=null,v=V[o],o+1<J)if(M=V[o+1],v.value.equals&&v.value.equals(M.value)||v.value===M.value){if(0!==o)continue;k=v.frame}else k=M.frame;else{if(x=V[o-1],v.value.equals&&v.value.equals(x.value)||v.value===x.value)continue;k=L}if(k)for(let o=v.frame;o<=k;o+=e){if(l=B.f.FloatRound(o/r),l===I)continue;I=l,a=l;const z={key:0,repeatCount:0,loopMode:q.loopMode};i=q._interpolate(o,z),xt._SetInterpolatedValue(t,i,l,q,S,h,C,Z,O)}}a&&(b.max=a)}static _ConvertFactorToVector3OrQuaternion(t,q,S,z,L){const r=xt._GetBasePositionRotationOrScale(q,z,L),e=S.targetProperty.split("."),C=e?e[1]:"",Z=L?o.g.ti(r).normalize():o.o.ti(r);switch(C){case"x":case"y":case"z":Z[C]=t;break;case"w":Z.w=t;break;default:B.f.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return Z}static _SetInterpolatedValue(t,q,S,B,z,L,r,e,C){let Z;r.push(S),"weights"!==z?(B.dataType===It.b.ANIMATIONTYPE_FLOAT&&(q=this._ConvertFactorToVector3OrQuaternion(q,t,B,z,C)),"rotation"===z?(C?L=q:(Z=q,o.g.RotationYawPitchRollToRef(Z.y,Z.x,Z.z,L)),e.push(L.Gi())):(Z=q,e.push(Z.Gi()))):e.push([q])}static _CreateLinearOrStepAnimation(t,q,S,o,B,z){for(const L of q.getKeys())o.push(L.frame/q.framePerSecond),xt._AddKeyframeValue(L,q,B,S,t,z)}static _CreateCubicSplineAnimation(t,q,S,o,B,z){q.getKeys().forEach((function(L){o.push(L.frame/q.framePerSecond),xt._AddSplineTangent(bt.INTANGENT,B,S,"CUBICSPLINE",L,z),xt._AddKeyframeValue(L,q,B,S,t,z),xt._AddSplineTangent(bt.OUTTANGENT,B,S,"CUBICSPLINE",L,z)}))}static _GetBasePositionRotationOrScale(t,q,S){let B;if("rotation"===q)if(S){B=(t.rotationQuaternion??o.g.Identity()).Gi()}else{B=(t.rotation??o.o.Zero()).Gi()}else if("translation"===q){B=(t.position??o.o.Zero()).Gi()}else{B=(t.oi??o.o.One()).Gi()}return B}static _AddKeyframeValue(t,q,S,z,L,r){let e;const C=q.dataType;if(C===It.b.ANIMATIONTYPE_VECTOR3){let q=t.value.Gi();if("rotation"===z){const t=o.o.ti(q);q=o.g.RotationYawPitchRoll(t.y,t.x,t.z).Gi()}S.push(q)}else if(C===It.b.ANIMATIONTYPE_FLOAT){if("weights"===z)S.push([t.value]);else if(e=this._ConvertFactorToVector3OrQuaternion(t.value,L,q,z,r),e){if("rotation"===z){const t=r?e:o.g.RotationYawPitchRoll(e.y,e.x,e.z).normalize();S.push(t.Gi())}S.push(e.Gi())}}else C===It.b.ANIMATIONTYPE_QUATERNION?S.push(t.value.normalize().Gi()):B.f.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(t,q,S){let o,B,z=!1;if("rotation"===q&&!S)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let L=0,r=t.length;L<r;++L)if(B=t[L],B.inTangent||B.outTangent)if(o){if("CUBICSPLINE"!==o){o="LINEAR",z=!0;break}}else o="CUBICSPLINE";else if(o){if("CUBICSPLINE"===o||B.interpolation&&1===B.interpolation&&"STEP"!==o){o="LINEAR",z=!0;break}}else o=B.interpolation&&1===B.interpolation?"STEP":"LINEAR";return o||(o="LINEAR"),{interpolationType:o,shouldBakeAnimation:z}}static _AddSplineTangent(t,q,S,B,z,L){let r;const e=t===bt.INTANGENT?z.inTangent:z.outTangent;if("CUBICSPLINE"===B){if("rotation"===S)if(e)if(L)r=e.Gi();else{const t=e;r=o.g.RotationYawPitchRoll(t.y,t.x,t.z).Gi()}else r=[0,0,0,0];else r="weights"===S?e?[e]:[0]:e?e.Gi():[0,0,0];q.push(r)}}static _CalculateMinMaxKeyFrames(t){let q=1/0,S=-1/0;return t.forEach((function(t){q=Math.min(q,t.frame),S=Math.max(S,t.frame)})),{min:q,max:S}}}function kt(t,q,S,z,L,r){const e={attributes:{},influence:t.influence,name:t.name},C=q.xi;if(!C)return B.f.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),e;const b=r?-1:1,O=o.o.Zero();let i=0,h=0;if(t.hasPositions){const z=t.getPositions(),r=C.getVerticesData(Z.i.PositionKind);if(r){const t=new Float32Array(r.length),q=[1/0,1/0,1/0],B=[-1/0,-1/0,-1/0];h=r.length/3,i=0;for(let S=i;S<h;++S){const L=o.o.ti(r,3*S);o.o.ti(z,3*S).subtractToRef(L,O),O.x*=b,q[0]=Math.min(q[0],O.x),B[0]=Math.max(B[0],O.x),q[1]=Math.min(q[1],O.y),B[1]=Math.max(B[1],O.y),q[2]=Math.min(q[2],O.z),B[2]=Math.max(B[2],O.z),t[3*S]=O.x,t[3*S+1]=O.y,t[3*S+2]=O.z}const C=S.createBufferView(t,12),Z=S.createAccessor(C,"VEC3",5126,z.length/3,0,{min:q,max:B});L.push(Z),e.attributes.POSITION=L.length-1}else B.f.Warn(`Morph target positions for mesh ${q.name} were not exported. Mesh does not have position vertex data`)}if(t.hasNormals){const z=t.getNormals(),r=C.getVerticesData(Z.i.NormalKind);if(r){const t=new Float32Array(r.length);h=r.length/3,i=0;for(let S=i;S<h;++S){const q=o.o.ti(r,3*S).normalize();o.o.ti(z,3*S).normalize().subtractToRef(q,O),t[3*S]=O.x*b,t[3*S+1]=O.y,t[3*S+2]=O.z}const q=S.createBufferView(t,12),B=S.createAccessor(q,"VEC3",5126,z.length/3,0);L.push(B),e.attributes.NORMAL=L.length-1}else B.f.Warn(`Morph target normals for mesh ${q.name} were not exported. Mesh does not have normals vertex data`)}if(t.hasTangents){const z=t.getTangents(),r=C.getVerticesData(Z.i.TangentKind);if(r){h=r.length/4;const t=new Float32Array(3*h);i=0;for(let S=i;S<h;++S){const q=o.o.ti(r,4*S);P(q);const B=o.o.ti(z,3*S);P(B),B.subtractToRef(q,O),t[3*S]=O.x*b,t[3*S+1]=O.y,t[3*S+2]=O.z}const q=S.createBufferView(t,12),B=S.createAccessor(q,"VEC3",5126,h,0);L.push(B),e.attributes.TANGENT=L.length-1}else B.f.Warn(`Morph target tangents for mesh ${q.name} were not exported. Mesh does not have tangents vertex data`)}if(t.hasColors){const z=t.getColors(),r=C.getVerticesData(Z.i.ColorKind),b=C.getVertexBuffer(Z.i.ColorKind);if(r&&b){const t=b.getSize();h=r.length/t;const q=new Float32Array(h*t);i=0;for(let S=i;S<h;++S)if(3===t){const B=o.o.ti(r,S*t);o.o.ti(z,S*t).subtractToRef(B,O),q[3*S]=O.x,q[3*S+1]=O.y,q[3*S+2]=O.z}else if(4===t){const B=new o.s,L=o.s.ti(r,S*t);o.s.ti(z,S*t).subtractToRef(L,B),q[4*S]=B.x,q[4*S+1]=B.y,q[4*S+2]=B.z,q[4*S+3]=B.w}else B.f.Warn(`Unsupported number of components for color attribute: ${t}`);const C=S.createBufferView(q,4*t),Z=S.createAccessor(C,3===t?"VEC3":"VEC4",5126,h,0);L.push(Z),e.attributes.COLOR_0=L.length-1}else B.f.Warn(`Morph target colors for mesh ${q.name} were not exported. Mesh does not have colors vertex data`)}return e}var Vt=S(12045),Jt=S(11971),Ut=S(11965),Ht=S(622);class jt{}jt.DEFAULT_COLOR=I.c.White(),jt.DEFAULT_WIDTH_ATTENUATED=1,jt.DEFAULT_WIDTH=.1;var yt=S(2280),Qt=S(12059);class Kt{static ConvertPoints(t,q){if(t.length&&Array.isArray(t)&&"number"===typeof t[0])return[t];if(t.length&&Array.isArray(t[0])&&"number"===typeof t[0][0])return t;if(t.length&&!Array.isArray(t[0])&&t[0]instanceof o.o){const q=[];for(let S=0;S<t.length;S++){const o=t[S];q.push(o.x,o.y,o.z)}return[q]}if(t.length>0&&Array.isArray(t[0])&&t[0].length>0&&t[0][0]instanceof o.o){const q=[],S=t;for(const t of S)q.push(t.flatMap((t=>[t.x,t.y,t.z])));return q}if(t instanceof Float32Array){if(null!==q&&void 0!==q&&q.floatArrayStride){const S=[],o=3*q.floatArrayStride;for(let q=0;q<t.length;q+=o){const B=new Array(o);for(let S=0;S<o;S++)B[S]=t[q+S];S.push(B)}return S}return[Array.from(t)]}if(t.length&&t[0]instanceof Float32Array){const q=[];for(const S of t)q.push(Array.from(S));return q}return[]}static OmitZeroLengthPredicate(t,q,S){const o=[];return q.Kg(t).lengthSquared()>0&&o.push([t,q]),S.Kg(q).lengthSquared()>0&&o.push([q,S]),t.Kg(S).lengthSquared()>0&&o.push([S,t]),0===o.length?null:o}static OmitDuplicatesPredicate(t,q,S,o){const B=[];return Kt._SearchInPoints(t,q,o)||B.push([t,q]),Kt._SearchInPoints(q,S,o)||B.push([q,S]),Kt._SearchInPoints(S,t,o)||B.push([S,t]),0===B.length?null:B}static _SearchInPoints(t,q,S){for(const L of S)for(let S=0;S<L.length;S++){var o,B,z;if(null!==(o=L[S])&&void 0!==o&&o.equals(t))if(null!==(B=L[S+1])&&void 0!==B&&B.equals(q)||null!==(z=L[S-1])&&void 0!==z&&z.equals(q))return!0}return!1}static MeshesToLines(t,q){const S=[];for(let B=0;B<t.length;B++){const z=t[B],L=z.getVerticesData(Z.i.PositionKind),r=z.Bi();if(L&&r)for(let t=0,e=0;t<r.length;t++){const C=3*r[e++],Z=3*r[e++],b=3*r[e++],O=new o.o(L[C],L[C+1],L[C+2]),i=new o.o(L[Z],L[Z+1],L[Z+2]),h=new o.o(L[b],L[b+1],L[b+2]);if(q){const o=q(O,i,h,S,t,C,z,B,L,r);if(o)for(const t of o)S.push(t)}else S.push([O,i],[i,h],[h,O])}}return S}static ToVector3Array(t){if(Array.isArray(t[0])){const q=[],S=t;for(const t of S){const S=[];for(let q=0;q<t.length;q+=3)S.push(new o.o(t[q],t[q+1],t[q+2]));q.push(S)}return q}const q=t,S=[];for(let B=0;B<q.length;B+=3)S.push(new o.o(q[B],q[B+1],q[B+2]));return S}static ToNumberArray(t){return t.flatMap((t=>[t.x,t.y,t.z]))}static GetPointsCountInfo(t){const q=new Array(t.length);let S=0;for(let o=t.length;o--;)q[o]=t[o].length/3,S+=q[o];return{total:S,counts:q}}static GetLineLength(t){if(0===t.length)return 0;let q;q="number"===typeof t[0]?Kt.ToVector3Array(t):t;const S=o.j.wi[0];let B=0;for(let o=0;o<q.length-1;o++){const t=q[o];B+=q[o+1].subtractToRef(t,S).length()}return B}static GetLineLengthArray(t){const q=new Float32Array(t.length/3);let S=0;for(let o=0,B=t.length/3-1;o<B;o++){let B=t[3*o+0],z=t[3*o+1],L=t[3*o+2];B-=t[3*o+3],z-=t[3*o+4],L-=t[3*o+5];S+=Math.sqrt(B*B+z*z+L*L),q[o+1]=S}return q}static SegmentizeSegmentByCount(t,q,S){const B=[],z=q.Kg(t),L=o.j.wi[0];L.ui(S);const r=o.j.wi[1];z.divideToRef(L,r);let e=t.clone();B.push(e);for(let o=0;o<S;o++)e=e.clone(),B.push(e.addInPlace(r));return B}static SegmentizeLineBySegmentLength(t,q){const S=t[0]instanceof o.o?Kt.GetLineSegments(t):"number"===typeof t[0]?Kt.GetLineSegments(Kt.ToVector3Array(t)):t,B=[];for(const o of S)if(o.length>q){const t=Kt.SegmentizeSegmentByCount(o.point1,o.point2,Math.ceil(o.length/q));for(const q of t)B.push(q)}else B.push(o.point1),B.push(o.point2);return B}static SegmentizeLineBySegmentCount(t,q){const S="number"===typeof t[0]?Kt.ToVector3Array(t):t,o=Kt.GetLineLength(S)/q;return Kt.SegmentizeLineBySegmentLength(S,o)}static GetLineSegments(t){const q=[];for(let S=0;S<t.length-1;S++){const o=t[S],B=t[S+1],z=B.Kg(o).length();q.push({point1:o,point2:B,length:z})}return q}static GetMinMaxSegmentLength(t){const q=Kt.GetLineSegments(t).sort((t=>t.length));return{min:q[0].length,max:q[q.length-1].length}}static GetPositionOnLineByVisibility(t,q,S){let B=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const z=q*S;let L=0,r=0;const e=t.length;for(let o=0;o<e;o++){if(z<=L+t[o].length){r=o;break}L+=t[o].length}const C=(z-L)/t[r].length;return t[r].point2.subtractToRef(t[r].point1,o.j.wi[0]),o.j.wi[1]=o.j.wi[0].multiplyByFloats(C,C,C),B||o.j.wi[1].addInPlace(t[r].point1),o.j.wi[1].clone()}static GetCircleLinePoints(t,q){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,B=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/q;const L=[];for(let r=0;r<=q;r++)L.push(new o.o(Math.cos(r*z)*t,Math.sin(r*z)*B,S));return L}static GetBezierLinePoints(t,q,S,o){return yt.c.CreateQuadraticBezier(t,q,S,o).getPoints().flatMap((t=>[t.x,t.y,t.z]))}static GetArrowCap(t,q,S,o,B){let z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[t.clone(),t.add(q.multiplyByFloats(S,S,S))],widths:[o,B,z,L]}}static GetPointsFromText(t,q,S,o){let B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,z=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const L=[],r=(0,Qt.c)(t,q,S,o);for(const e of r){for(const t of e.paths){const q=[],S=t.getPoints();for(const t of S)q.push(t.x,t.y,B);L.push(q)}if(z)for(const t of e.holes){const q=[],S=t.getPoints();for(const t of S)q.push(t.x,t.y,B);L.push(q)}}return L}static Color3toRGBAUint8(t){const q=new Uint8Array(4*t.length);for(let S=0,o=0;S<t.length;S++)q[o++]=255*t[S].r,q[o++]=255*t[S].g,q[o++]=255*t[S].b,q[o++]=255;return q}static CreateColorsTexture(t,q,S,o){const B=o.getEngine().getCaps().maxTextureSize??1,z=q.length>B?B:q.length,L=Math.ceil(q.length/B);L>1&&(q=[...q,...Array(z*L-q.length).fill(q[0])]);const r=Kt.Color3toRGBAUint8(q),e=new V.d(r,z,L,h.e.TEXTUREFORMAT_RGBA,o,!1,!0,S);return e.name=t,e}static PrepareEmptyColorsTexture(t){if(!jt.EmptyColorsTexture){const q=new Uint8Array(4);jt.EmptyColorsTexture=new V.d(q,1,1,h.e.TEXTUREFORMAT_RGBA,t,!1,!1,V.d.NEAREST_NEAREST),jt.EmptyColorsTexture.name="grlEmptyColorsTexture"}return jt.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var t;null===(t=jt.EmptyColorsTexture)||void 0===t||t.dispose(),jt.EmptyColorsTexture=null}static BooleanToNumber(t){return t?1:0}}class Xt extends Ut.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Gt extends Jt.d{isCompatible(t){return!0}constructor(t,q,S){var B;S=S||{color:jt.DEFAULT_COLOR};const z=new Xt;z.GREASED_LINE_HAS_COLOR=!!S.color&&!S.useColors,z.GREASED_LINE_SIZE_ATTENUATION=S.sizeAttenuation??!1,z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===S.colorDistributionType,z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(q??t.va()).useRightHandedSystem,z.GREASED_LINE_CAMERA_FACING=S.cameraFacing??!0,super(t,Gt.GREASED_LINE_MATERIAL_NAME,200,z,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(B=S)||void 0===B?void 0:B.forceGLSL)||Gt.ForceGLSL,this._scene=q??t.va(),this._engine=this._scene.getEngine(),this._cameraFacing=S.cameraFacing??!0,this.visibility=S.visibility??1,this.useDash=S.useDash??!1,this.dashRatio=S.dashRatio??.5,this.dashOffset=S.dashOffset??0,this.width=S.width?S.width:S.sizeAttenuation?jt.DEFAULT_WIDTH_ATTENUATED:jt.DEFAULT_WIDTH,this._sizeAttenuation=S.sizeAttenuation??!1,this.colorMode=S.colorMode??0,this._color=S.color??null,this.useColors=S.useColors??!1,this._colorsDistributionType=S.colorDistributionType??0,this.colorsSampling=S.colorsSampling??V.d.NEAREST_NEAREST,this._colors=S.za??null,this.dashCount=S.dashCount??1,this.resolution=S.resolution??new o.l(this._engine.getRenderWidth(),this._engine.getRenderHeight()),S.colorsTexture?this.colorsTexture=S.colorsTexture:this._colors?this.colorsTexture=Kt.CreateColorsTexture(`${t.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??jt.DEFAULT_COLOR,Kt.PrepareEmptyColorsTexture(this._scene)),this._engine.Qi.add((()=>{Kt.DisposeEmptyColorsTexture()}))}getAttributes(t){t.push("grl_offsets"),t.push("grl_widths"),t.push("grl_colorPointers"),t.push("grl_counters"),this._cameraFacing?(t.push("grl_previousAndSide"),t.push("grl_nextAndCounters")):t.push("grl_slopes")}getSamplers(t){t.push("grl_colors")}getActiveTextures(t){this.colorsTexture&&t.push(this.colorsTexture)}getUniforms(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const q=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&q.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===t&&q.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:q,vertex:this._cameraFacing&&this._isGLSL(t)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(t)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(t){if(this._cameraFacing){t.ej("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||t.ej("viewProjection",this._scene.getTransformMatrix());const q=o.j.Vector4[0];q.x=this._aspect,q.y=this._resolution.x,q.z=this._resolution.y,q.w=this.width,t.updateVector4("grl_aspect_resolution_lineWidth",q)}const q=o.j.Vector4[0];q.x=Kt.BooleanToNumber(this.useDash),q.y=this._dashArray,q.z=this.dashOffset,q.w=this.dashRatio,t.updateVector4("grl_dashOptions",q);const S=o.j.Vector4[1];S.x=this.colorMode,S.y=this.visibility,S.z=this.colorsTexture?this.colorsTexture.getSize().width:0,S.w=Kt.BooleanToNumber(this.useColors),t.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",S),this._color&&t.updateColor3("grl_singleColor",this._color);const B=this.colorsTexture??jt.EmptyColorsTexture;t.setTexture("grl_colors",B),t.updateFloat2("grl_textureSize",(null===B||void 0===B?void 0:B.getSize().width)??1,(null===B||void 0===B?void 0:B.getSize().height)??1)}prepareDefines(t,q,S){t.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,t.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=q.useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=this._cameraFacing,t.GREASED_LINE_USE_OFFSETS=!!S.offsets}getClassName(){return Gt.GREASED_LINE_MATERIAL_NAME}getCustomCode(t){let q=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(q)?function(t,q){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return q&&(t["!gl_Position\\=viewProjection\\*worldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(t,this._cameraFacing):function(t,q){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return q&&(t["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(t,this._cameraFacing)}dispose(){var t;null===(t=this.colorsTexture)||void 0===t||t.dispose(),super.dispose()}get za(){return this._colors}set za(t){this.setColors(t)}setColors(t){var q;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(q=this._colors)||void 0===q?void 0:q.length)??0;var z;if(this._colors=t,null!==t&&0!==t.length){if(!S||o)if(this.colorsTexture&&B===t.length&&!o){const q=Kt.Color3toRGBAUint8(t);this.colorsTexture.update(q)}else{var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=Kt.CreateColorsTexture(`${this._material.name}-colors-texture`,t,this.colorsSampling,this._scene)}}else null===(z=this.colorsTexture)||void 0===z||z.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.markAllDefinesAsDirty()}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==t||null!==this._color&&null===t?(this._color=t,q||this.markAllDefinesAsDirty()):this._color=t}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(t){this._aspect=t.x/t.y,this._resolution=t}serialize(){const t=super.serialize(),q={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(q.za=this._colors),this._color&&(q.color=this._color),t.greasedLineMaterialOptions=q,t}parse(t,q,S){var o;super.parse(t,q,S);const B=t.greasedLineMaterialOptions;null===(o=this.colorsTexture)||void 0===o||o.dispose(),B.color&&this.setColor(B.color,!0),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.za&&(this.za=B.za),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),this.za?this.colorsTexture=Kt.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,q):Kt.PrepareEmptyColorsTexture(q),this.markAllDefinesAsDirty()}copyTo(t){var q;const S=t;null===(q=S.colorsTexture)||void 0===q||q.dispose(),this._colors&&(S.colorsTexture=Kt.CreateColorsTexture(`${S._material.name}-colors-texture`,this._colors,S.colorsSampling,this._scene)),S.setColor(this.color,!0),S.colorsDistributionType=this.colorsDistributionType,S.colorsSampling=this.colorsSampling,S.colorMode=this.colorMode,S.useColors=this.useColors,S.visibility=this.visibility,S.useDash=this.useDash,S.dashCount=this.dashCount,S.dashRatio=this.dashRatio,S.dashOffset=this.dashOffset,S.width=this.width,S.sizeAttenuation=this.sizeAttenuation,S.resolution=this.resolution,S.markAllDefinesAsDirty()}_isGLSL(t){return 0===t||this._forceGLSL}}Gt.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Gt.ForceGLSL=!1,(0,Ht.c)(`BABYLON.${Gt.GREASED_LINE_MATERIAL_NAME}`,Gt);var Yt=S(732),nt=S(503),ut=S(12050),Wt=S(601);class ft extends ut.d{constructor(t,q,B){const z=q.getEngine(),L=z.isWebGPU&&!(B.forceGLSL||ft.ForceGLSL),r=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];q.useRightHandedSystem&&r.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const e=["position","grl_widths","grl_offsets","grl_colorPointers"];B.cameraFacing?(r.push("GREASED_LINE_CAMERA_FACING"),e.push("grl_previousAndSide","grl_nextAndCounters")):(e.push("grl_slopes"),e.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(L||C.push("world","viewProjection","view","projection"),super(t,q,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:L?["Scene","Mesh"]:void 0,attributes:e,uniforms:C,samplers:L?[]:["grlColors"],defines:r,extraInitializationsAsync:async()=>{L?await Promise.all([S.e(51).then(S.bind(S,14073)),S.e(59).then(S.bind(S,14078))]):await Promise.all([S.e(54).then(S.bind(S,14084)),S.e(60).then(S.bind(S,14090))])},shaderLanguage:L?1:0}),this._color=I.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,B=B||{color:jt.DEFAULT_COLOR},this.visibility=B.visibility??1,this.useDash=B.useDash??!1,this.dashRatio=B.dashRatio??.5,this.dashOffset=B.dashOffset??0,this.dashCount=B.dashCount??1,this.width=B.width?B.width:B.sizeAttenuation&&B.cameraFacing?jt.DEFAULT_WIDTH_ATTENUATED:jt.DEFAULT_WIDTH,this.sizeAttenuation=B.sizeAttenuation??!1,this.color=B.color??I.c.White(),this.useColors=B.useColors??!1,this.colorsDistributionType=B.colorDistributionType??0,this.colorsSampling=B.colorsSampling??V.d.NEAREST_NEAREST,this.colorMode=B.colorMode??0,this._colors=B.za??null,this._cameraFacing=B.cameraFacing??!0,this.resolution=B.resolution??new o.l(z.getRenderWidth(),z.getRenderHeight()),B.colorsTexture?this.colorsTexture=B.colorsTexture:this._colors?this.colorsTexture=Kt.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,q):(this._color=this._color??jt.DEFAULT_COLOR,this.colorsTexture=Kt.PrepareEmptyColorsTexture(q)),L){const t=new Wt.c;t.setParameters(),t.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",t)}z.Qi.add((()=>{Kt.DisposeEmptyColorsTexture()}))}dispose(){var t;null===(t=this._colorsTexture)||void 0===t||t.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new o.l(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(t){this.setColors(t)}setColors(t){var q;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const B=(null===(q=this._colors)||void 0===q?void 0:q.length)??0;var z;if(this._colors=t,null!==t&&0!==t.length){if(!S||o)if(this._colorsTexture&&B===t.length&&!o){const q=Kt.Color3toRGBAUint8(t);this._colorsTexture.update(q)}else{var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),this.colorsTexture=Kt.CreateColorsTexture(`${this.name}-colors-texture`,t,this.colorsSampling,this.va())}}else null===(z=this._colorsTexture)||void 0===z||z.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(t){this._colorsTexture=t,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(t){this._width=t,this.setFloat("grlWidth",t)}get useColors(){return this._useColors}set useColors(t){this._useColors=t,this.setFloat("grlUseColors",Kt.BooleanToNumber(t))}get colorsSampling(){return this._colorsSampling}set colorsSampling(t){this._colorsSampling=t}get visibility(){return this._visibility}set visibility(t){this._visibility=t,this.setFloat("grlVisibility",t)}get useDash(){return this._useDash}set useDash(t){this._useDash=t,this.setFloat("grlUseDash",Kt.BooleanToNumber(t))}get dashOffset(){return this._dashOffset}set dashOffset(t){this._dashOffset=t,this.setFloat("grlDashOffset",t)}get dashRatio(){return this._dashRatio}set dashRatio(t){this._dashRatio=t,this.setFloat("grlDashRatio",t)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.setFloat("grlSizeAttenuation",Kt.BooleanToNumber(t))}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){t=t??jt.DEFAULT_COLOR,this._color=t,this.setColor3("grlColor",t)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(t){this._colorMode=t,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(t){this._resolution=t,this.setVector2("grlResolution",t),this.setFloat("grlAspect",t.x/t.y)}serialize(){const t=super.serialize(),q={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(q.za=this._colors),t.greasedLineMaterialOptions=q,t}parse(t,q,S){var o;const B=t.greasedLineMaterialOptions;null===(o=this._colorsTexture)||void 0===o||o.dispose(),B.color&&(this.color=B.color),B.colorDistributionType&&(this.colorsDistributionType=B.colorDistributionType),B.colorsSampling&&(this.colorsSampling=B.colorsSampling),B.colorMode&&(this.colorMode=B.colorMode),B.useColors&&(this.useColors=B.useColors),B.visibility&&(this.visibility=B.visibility),B.useDash&&(this.useDash=B.useDash),B.dashCount&&(this.dashCount=B.dashCount),B.dashRatio&&(this.dashRatio=B.dashRatio),B.dashOffset&&(this.dashOffset=B.dashOffset),B.width&&(this.width=B.width),B.sizeAttenuation&&(this.sizeAttenuation=B.sizeAttenuation),B.resolution&&(this.resolution=B.resolution),B.za?this.colorsTexture=Kt.CreateColorsTexture(`${this.name}-colors-texture`,B.za,this.colorsSampling,this.va()):this.colorsTexture=Kt.PrepareEmptyColorsTexture(q),this._cameraFacing=B.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Dt,mt,At;ft.ForceGLSL=!1,function(t){t[t.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",t[t.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Dt||(Dt={})),function(t){t[t.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",t[t.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",t[t.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(mt||(mt={})),function(t){t[t.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",t[t.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",t[t.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",t[t.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",t[t.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(At||(At={}));class ct extends vt.c{constructor(t,q,S){super(t,q,null,null,!1,!1),this.name=t,this._options=S,this._lazy=!1,this._updatable=!1,this._engine=q.getEngine(),this._lazy=S.lazy??!1,this._updatable=S.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=S.colorPointers??[],this._widths=S.widths??new Array(S.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(t){let q=0;for(const o of this._points)q+=o.length;const S=q/3*2-this._widths.length;for(let o=0;o<S;o++)this._widths.push(t)}updateLazy(){var t,q;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(t=this._options.ribbonOptions)||void 0===t?void 0:t.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(q=this.greasedLineMaterial)||void 0===q||q.updateLazy()}addPoints(t,q){for(const S of t)this._points.push(S);this._lazy||this.setPoints(this._points,q)}dispose(t){let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(t,q)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(t){this._uvs=t instanceof Float32Array?t:new Float32Array(t),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(t){this.material instanceof ft&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===t||void 0===t?void 0:t.length)>0),this._offsets=t,this._offsetsBuffer?this._offsetsBuffer.update(t):this._createOffsetsBuffer(t)}get widths(){return this._widths}set widths(t){this._widths=t,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(t)}get colorPointers(){return this._colorPointers}set colorPointers(t){this._colorPointers=t,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(t)}get greasedLineMaterial(){var t,q;if(this.material&&this.material instanceof ft)return this.material;const S=null===(t=this.material)||void 0===t||null===(q=t.pluginManager)||void 0===q?void 0:q.getPlugin(Gt.GREASED_LINE_MATERIAL_NAME);return S||void 0}get points(){const t=[];return nt.c.DeepCopy(this._points,t),t}setPoints(t,q){this._points=Kt.ConvertPoints(t,(null===q||void 0===q?void 0:q.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==q&&void 0!==q&&q.colorPointers||this._updateColorPointers(),this._setPoints(this._points,q)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(t){super.serialize(t),t.type=this.getClassName(),t.lineOptions=this._createLineOptions()}_createVertexBuffers(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const q=new Yt.e;return q.xa=this._vertexPositions,q.indices=this._indices,q.Aa=this._uvs,t&&(q.ya=[],Yt.e.ComputeNormals(this._vertexPositions,this._indices,q.ya)),q.Ca(this,this._options.updatable),q}_createOffsetsBuffer(t){const q=this._scene.getEngine(),S=new Z.e(q,t,this._updatable,3);this.setVerticesBuffer(S.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=S}}class st{constructor(t,q){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=t,this.wasAddedByNoopNode=q}getIndicesAccessor(t,q,S,o,B){var z,L,r,e;return null===(z=this._indicesAccessorMap.get(t))||void 0===z||null===(L=z.get(q))||void 0===L||null===(r=L.get(S))||void 0===r||null===(e=r.get(o))||void 0===e?void 0:e.get(B)}setIndicesAccessor(t,q,S,o,B,z){let L=this._indicesAccessorMap.get(t);L||(L=new Map,this._indicesAccessorMap.set(t,L));let r=L.get(q);r||(r=new Map,L.set(q,r));let e=r.get(S);e||(e=new Map,r.set(S,e));let C=e.get(o);C||(C=new Map,e.set(o,C)),C.set(B,z)}pushExportedNode(t){this._exportedNodes.has(t)||this._exportedNodes.add(t)}getNodesSet(){return this._exportedNodes}getVertexBufferView(t){return this._vertexBufferViewMap.get(t)}setVertexBufferView(t,q){this._vertexBufferViewMap.set(t,q)}setRemappedBufferView(t,q,S){this._remappedBufferView.set(t,new Map),this._remappedBufferView.get(t).set(q,S)}getRemappedBufferView(t,q){var S;return null===(S=this._remappedBufferView.get(t))||void 0===S?void 0:S.get(q)}getVertexAccessor(t,q,S){var o,B;return null===(o=this._vertexAccessorMap.get(t))||void 0===o||null===(B=o.get(q))||void 0===B?void 0:B.get(S)}setVertexAccessor(t,q,S,o){let B=this._vertexAccessorMap.get(t);B||(B=new Map,this._vertexAccessorMap.set(t,B));let z=B.get(q);z||(z=new Map,B.set(q,z)),z.set(S,o)}hasVertexColorAlpha(t){return this._vertexMapColorAlpha.get(t)||!1}setHasVertexColorAlpha(t,q){return this._vertexMapColorAlpha.set(t,q)}getMesh(t){return this._meshMap.get(t)}setMesh(t,q){this._meshMap.set(t,q)}bindMorphDataToMesh(t,q){const S=this._meshMorphTargetMap.get(t)||[];this._meshMorphTargetMap.set(t,S),-1===S.indexOf(q)&&S.push(q)}getMorphTargetsFromMesh(t){return this._meshMorphTargetMap.get(t)}}class gt{_ApplyExtension(t,q,S,o){if(S>=q.length)return Promise.resolve(t);const B=o(q[S],t);return B?B.then((async t=>t?await this._ApplyExtension(t,q,S+1,o):null)):this._ApplyExtension(t,q,S+1,o)}_ApplyExtensions(t,q){const S=[];for(const o of gt._ExtensionNames)S.push(this._extensions[o]);return this._ApplyExtension(t,S,0,q)}_extensionsPreExportTextureAsync(t,q,S){return this._ApplyExtensions(q,((q,o)=>q.preExportTextureAsync&&q.preExportTextureAsync(t,o,S)))}_extensionsPostExportNodeAsync(t,q,S,o,B){return this._ApplyExtensions(q,((q,z)=>q.postExportNodeAsync&&q.postExportNodeAsync(t,z,S,o,B,this._bufferManager)))}_extensionsPostExportMaterialAsync(t,q,S){return this._ApplyExtensions(q,((q,o)=>q.postExportMaterialAsync&&q.postExportMaterialAsync(t,o,S)))}_extensionsPostExportMaterialAdditionalTextures(t,q,S){const o=[];for(const B of gt._ExtensionNames){const z=this._extensions[B];z.postExportMaterialAdditionalTextures&&o.push(...z.postExportMaterialAdditionalTextures(t,q,S))}return o}_extensionsPostExportTextures(t,q,S){for(const o of gt._ExtensionNames){const B=this._extensions[o];B.postExportTexture&&B.postExportTexture(t,q,S)}}_extensionsPostExportMeshPrimitive(t){for(const q of gt._ExtensionNames){const S=this._extensions[q];S.postExportMeshPrimitive&&S.postExportMeshPrimitive(t,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const t of gt._ExtensionNames){const q=this._extensions[t];q.preGenerateBinaryAsync&&await q.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(t){for(const q of gt._ExtensionNames){const S=this._extensions[q];S.enabled&&t(S)}}_extensionsOnExporting(){this._forEachExtensions((t=>{var q,S,o;t.wasUsed&&((q=this._glTF).extensionsUsed||(q.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(t.name)&&this._glTF.extensionsUsed.push(t.name),t.required&&((S=this._glTF).extensionsRequired||(S.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(t.name)&&this._glTF.extensionsRequired.push(t.name)),(o=this._glTF).extensions||(o.extensions={}),t.onExporting&&t.onExporting())}))}_loadExtensions(){for(const t of gt._ExtensionNames){const q=gt._ExtensionFactories[t](this);this._extensions[t]=q}}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:l.b.LastCreatedScene,q=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${h.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new W(this),this._extensions={},this._bufferManager=new Zt,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!t)throw new Error("No scene available to export");this._babylonScene=t,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:t=>{var q;return null===t||void 0===t||null===(q=t.Ni)||void 0===q?void 0:q.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...q},this._loadExtensions()}dispose(){for(const t in this._extensions){this._extensions[t].dispose()}}get options(){return this._options}static RegisterExtension(t,q){gt.UnregisterExtension(t)&&B.f.Warn(`Extension with the name ${t} already exists`),gt._ExtensionFactories[t]=q,gt._ExtensionNames.push(t)}static UnregisterExtension(t){if(!gt._ExtensionFactories[t])return!1;delete gt._ExtensionFactories[t];const q=gt._ExtensionNames.indexOf(t);return-1!==q&&gt._ExtensionNames.splice(q,1),!0}_generateJSON(t,q,S){const o={byteLength:t};return o.byteLength&&(this._glTF.buffers=[o]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Tk=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(o.uri=q+".bin"),S?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(t){const q=await this._generateBinaryAsync();this._extensionsOnExporting();const S=this._generateJSON(q.byteLength,t,!0),o=new Blob([q],{type:"application/octet-stream"}),B=t+".gltf",z=t+".bin",L=new C;if(L.files[B]=S,L.files[z]=o,this._imageData)for(const r in this._imageData)L.files[r]=new Blob([this._imageData[r].data],{type:this._imageData[r].mimeType});return L}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(t){const q=t%4;return 0===q?q:4-q}async generateGLBAsync(t){this._shouldUseGlb=!0;const q=await this._generateBinaryAsync();this._extensionsOnExporting();const S=this._generateJSON(q.byteLength),o=t+".glb";let B,z=S.length;if("undefined"!==typeof TextEncoder){B=(new TextEncoder).encode(S),z=B.length}const L=this._getPadding(z),r=this._getPadding(q.byteLength),e=28+z+L+q.byteLength+r,Z=new et(e);if(Z.writeUInt32(1179937895),Z.writeUInt32(2),Z.writeUInt32(e),Z.writeUInt32(z+L),Z.writeUInt32(1313821514),B)Z.writeTypedArray(B);else{const t="_".charCodeAt(0);for(let q=0;q<z;++q){const o=S.charCodeAt(q);o!=S.codePointAt(q)?Z.writeUInt8(t):Z.writeUInt8(o)}}for(let C=0;C<L;++C)Z.writeUInt8(32);Z.writeUInt32(q.byteLength+r),Z.writeUInt32(5130562),Z.writeTypedArray(q);for(let C=0;C<r;++C)Z.writeUInt8(0);const b=new C;return b.files[o]=new Blob([Z.getOutputData()],{type:"application/octet-stream"}),b}_setNodeTransformation(t,q,S){if(q.getPivotPoint().equalsWithEpsilon(c,A.d)||B.f.Warn("Pivot points are not supported in the glTF serializer"),!q.position.equalsWithEpsilon(c,A.d)){const B=o.j.wi[0].p(q.position);S&&F(B),t.translation=B.Gi()}q.oi.equalsWithEpsilon(g,A.d)||(t.scale=q.oi.Gi());const z=q.rotationQuaternion||o.g.FromEulerAngles(q.rotation.x,q.rotation.y,q.rotation.z);z.equalsWithEpsilon(s,A.d)||(S&&d(z),t.rotation=z.normalize().Gi())}_setCameraTransformation(t,q,S){if(!q.position.equalsWithEpsilon(c,A.d)){const B=o.j.wi[0].p(q.position);S&&F(B),t.translation=B.Gi()}const B=q.rotationQuaternion||o.g.FromEulerAngles(q.rotation.x,q.rotation.y,q.rotation.z);S&&d(B),this._babylonScene.useRightHandedSystem||R(B),B.equalsWithEpsilon(s,A.d)||(t.rotation=B.Gi())}_listAvailableCameras(){for(const t of this._babylonScene.cameras){const q={type:t.mode===Ot.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(t.name&&(q.name=t.name),"perspective"===q.type)q.perspective={aspectRatio:t.getEngine().getAspectRatio(t),yfov:t.fovMode===Ot.d.FOVMODE_VERTICAL_FIXED?t.fov:t.fov*t.getEngine().getAspectRatio(t),znear:t.Ci,zfar:t.maxZ};else if("orthographic"===q.type){const S=t.orthoLeft&&t.orthoRight?.5*(t.orthoRight-t.orthoLeft):.5*t.getEngine().getRenderWidth(),o=t.orthoBottom&&t.orthoTop?.5*(t.orthoTop-t.orthoBottom):.5*t.getEngine().getRenderHeight();q.orthographic={xmag:S,ymag:o,znear:t.Ci,zfar:t.maxZ}}this._camerasMap.set(t,q)}}_exportAndAssignCameras(){const t=Array.from(this._camerasMap.values());for(const q of t){const t=this._nodesCameraMap.get(q);if(void 0!==t){this._cameras.push(q);for(const q of t)q.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const q={joints:[]};this._skinMap.set(t,q)}}_exportAndAssignSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const q=this._skinMap.get(t);if(void 0==q)continue;const S={},o=[];let z=-1;for(let B=0;B<t.bones.length;++B){const q=t.bones[B],o=q.getIndex()??B;-1!==o&&(S[o]=q,o>z&&(z=o))}for(let t=0;t<=z;++t){const z=S[t];o.push(z.getAbsoluteInverseBindMatrix());const L=z.getTransformNode();if(null!==L){const t=this._nodeMap.get(L);L&&null!==t&&void 0!==t?q.joints.push(t):B.f.Warn("Exporting a bone without a linked transform node is currently unsupported")}else B.f.Warn("Exporting a bone without a linked transform node is currently unsupported")}const L=this._nodesSkinMap.get(q);if(q.joints.length>0&&void 0!==L){const t=64*o.length,S=new Float32Array(t/4);o.forEach(((t,q)=>{S.set(t.m,16*q)}));const B=this._bufferManager.createBufferView(S);this._accessors.push(this._bufferManager.createAccessor(B,"MAT4",5126,o.length)),q.inverseBindMatrices=this._accessors.length-1,this._skins.push(q);for(const q of L)q.skin=this._skins.length-1}}}async _exportSceneAsync(){const t={nodes:[]};if(this._babylonScene.metadata){const q=this._options.metadataSelector(this._babylonScene.metadata);q&&(t.extras=q)}const q=new Array,S=new Array,o=new Array;for(const r of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Lt(r,this._babylonScene.useRightHandedSystem)?o.push(...r.getChildren()):this._babylonScene.useRightHandedSystem?q.push(r):S.push(r);this._listAvailableCameras(),this._listAvailableSkeletons();const B=new st(!0,!1);t.nodes.push(...await this._exportNodesAsync(S,B));const z=new st(!1,!1);t.nodes.push(...await this._exportNodesAsync(q,z));const L=new st(!1,!0);t.nodes.push(...await this._exportNodesAsync(o,L)),t.nodes.length&&this._scenes.push(t),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&xt._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,B.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(t){let q=this._shouldExportNodeMap.get(t);return void 0===q&&(q=this._options.shouldExportNode(t),this._shouldExportNodeMap.set(t,q)),q}async _exportNodesAsync(t,q){const S=new Array;this._exportBuffers(t,q);for(const o of t)await this._exportNodeAsync(o,S,q);return S}_collectBuffers(t,q,S,o,B){if(this._shouldExportNode(t)&&t instanceof O.b&&t.xi){const z=t.xi.getVertexBuffers();if(z)for(const o in z){if(!E(o))continue;const L=z[o];B.setHasVertexColorAlpha(L,t.hasVertexAlpha);const r=L._buffer,e=q.get(r)||[];q.set(r,e),-1===e.indexOf(L)&&e.push(L);const C=S.get(L)||[];S.set(L,C),-1===C.indexOf(t)&&C.push(t)}const L=t.morphTargetManager;if(L)for(let q=0;q<L.numTargets;q++){const S=L.getTarget(q),B=o.get(S)||[];o.set(S,B),-1===B.indexOf(t)&&B.push(t)}}for(const z of t.getChildren())this._collectBuffers(z,q,S,o,B)}_exportBuffers(t,q){const S=new Map,o=new Map,B=new Map;for(const r of t)this._collectBuffers(r,S,o,B,q);const z=Array.from(S.keys());for(const r of z){const t=r.getData();if(!t)throw new Error("Buffer data is not available");const B=S.get(r);if(!B)continue;const z=B[0].byteStride;if(B.some((t=>t.byteStride!==z)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const L=St(t).slice();for(const q of B){const t=o.get(q),{byteOffset:S,byteStride:B,componentCount:z,type:r,count:e,normalized:C,kind:b}=T(q,t);switch(b){case Z.i.NormalKind:case Z.i.TangentKind:(0,f.h)(L,S,B,z,r,e,C,(t=>{const q=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);if(q>0){const S=1/q;t[0]*=S,t[1]*=S,t[2]*=S}}));break;case Z.i.ColorKind:{const q=t.filter((t=>t.material instanceof lt.e||null==t.material)).length;if(0==q)break;if(q!=t.length){D.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}r==Z.i.UNSIGNED_BYTE&&D.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const o=new I.c,b=new I.d,O=this._babylonScene.getEngine().useExactSrgbConversions;(0,f.h)(L,S,B,z,r,e,C,(t=>{3===t.length?(o.Xi(t,0),o.toLinearSpaceToRef(o,O),o.toArray(t,0)):(b.Xi(t,0),b.toLinearSpaceToRef(b,O),b.toArray(t,0))}))}}}if(q.convertToRightHanded){for(const t of B){const q=o.get(t),{byteOffset:S,byteStride:B,componentCount:z,type:r,count:e,normalized:C,kind:b}=T(t,q);switch(b){case Z.i.PositionKind:case Z.i.NormalKind:case Z.i.TangentKind:(0,f.h)(L,S,B,z,r,e,C,(t=>{t[0]=-t[0]}))}}q.convertedToRightHandedBuffers.set(r,L)}const e=this._bufferManager.createBufferView(L,z);q.setVertexBufferView(r,e);const C=new Map;for(const q of B){const t=o.get(q),{kind:S,totalVertices:B}=T(q,t);switch(S){case Z.i.MatricesIndicesKind:case Z.i.MatricesIndicesExtraKind:if(q.type==Z.i.FLOAT){const t=q.getFloatData(B);null!==t&&C.set(q,t)}}}0!==C.size&&D.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const b=Array.from(C.keys());for(const S of b){const t=C.get(S);if(!t)continue;const o=t.some((t=>t>=256)),B=new(o?Uint16Array:Uint8Array)(t.length);for(let q=0;q<t.length;q++)B[q]=t[q];const z=this._bufferManager.createBufferView(B,4*(o?2:1));q.setRemappedBufferView(r,S,z)}}const L=Array.from(B.keys());for(const r of L){const t=B.get(r);if(!t)continue;const S=kt(r,t[0],this._bufferManager,this._bufferViews,this._accessors,q.convertToRightHanded);for(const o of t)q.bindMorphDataToMesh(o,S)}}async _exportNodeAsync(t,q,S){let o=this._nodeMap.get(t);if(void 0!==o)return void(q.includes(o)||q.push(o));const B=await this._createNodeAsync(t,S);if(B){o=this._nodes.length,this._nodes.push(B),this._nodeMap.set(t,o),S.pushExportedNode(t),q.push(o);const z={name:"runtime animations",channels:[],samplers:[]},L=[];this._babylonScene.animationGroups.length||(xt._CreateMorphTargetAnimationFromMorphTargetAnimations(t,z,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.convertToRightHanded,this._options.shouldExportAnimation),t.animations.length&&xt._CreateNodeAnimationFromNodeAnimations(t,z,L,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.convertToRightHanded,this._options.shouldExportAnimation)),z.channels.length&&z.samplers.length&&this._animations.push(z),L.forEach((t=>{t.channels.length&&t.samplers.length&&this._animations.push(t)}))}const z=B?[]:q;for(const L of t.getChildren())await this._exportNodeAsync(L,z,S);B&&z.length&&(B.children=z)}async _createNodeAsync(t,q){if(!this._shouldExportNode(t))return null;const S={};if(t.name&&(S.name=t.name),t.metadata){const q=this._options.metadataSelector(t.metadata);q&&(S.extras=q)}if(t instanceof b.e&&(this._setNodeTransformation(S,t,q.convertToRightHanded),t instanceof O.b)){const B=t instanceof i.c?t.sourceMesh:t;if(B.Di&&B.Di.length>0&&(S.mesh=await this._exportMeshAsync(B,q)),t.skeleton){const q=this._skinMap.get(t.skeleton);var o;if(void 0!==q)void 0===this._nodesSkinMap.get(q)&&this._nodesSkinMap.set(q,[]),null===(o=this._nodesSkinMap.get(q))||void 0===o||o.push(S)}}if(t instanceof m.c){const o=this._camerasMap.get(t);if(o){var B;void 0===this._nodesCameraMap.get(o)&&this._nodesCameraMap.set(o,[]),this._setCameraTransformation(S,t,q.convertToRightHanded);const L=t.parent;if(null!==L&&qt(t,L)){const t=this._nodeMap.get(L);if(void 0!==t){var z;const q=this._nodes[t];return tt(S,q),null===(z=this._nodesCameraMap.get(o))||void 0===z||z.push(q),null}}null===(B=this._nodesCameraMap.get(o))||void 0===B||B.push(S)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",S,t,this._nodeMap,q.convertToRightHanded)?S:(D.c.Warn(`Not exporting node ${t.name}`),null)}_exportIndices(t,q,S,o,B,L,r,e,C){let Z=t;C.mode=p(L);const b=r!==z.c.CounterClockWiseSideOrientation,O=!e.wasAddedByNoopNode&&b,i=function(t){switch(t){case z.c.TriangleFillMode:case z.c.TriangleStripDrawMode:case z.c.TriangleFanDrawMode:return!0}return!1}(L)&&O;if(i){if(L===z.c.TriangleStripDrawMode||L===z.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=p(L);const r=q?new Uint32Array(o):new Uint16Array(o);if(t)for(let q=0;q+2<o;q+=3)r[q]=t[S+q]+B,r[q+1]=t[S+q+2]+B,r[q+2]=t[S+q+1]+B;else for(let t=0;t+2<o;t+=3)r[t]=t,r[t+1]=t+2,r[t+2]=t+1;Z=r}else if(t&&0!==B){const z=q?new Uint32Array(o):new Uint16Array(o);for(let q=0;q<o;q++)z[q]=t[S+q]+B;Z=z}if(Z){let z=e.getIndicesAccessor(t,S,o,B,i);if(void 0===z){const L=function(t,q,S,o){if(t instanceof Uint16Array||t instanceof Uint32Array)return t;if(t instanceof Int32Array)return new Uint32Array(t.buffer,t.byteOffset,t.length);const B=t.slice(q,q+S);return o?new Uint32Array(B):new Uint16Array(B)}(Z,0,o,q),r=this._bufferManager.createBufferView(L),C=q?5125:5123;this._accessors.push(this._bufferManager.createAccessor(r,"SCALAR",C,o,0)),z=this._accessors.length-1,e.setIndicesAccessor(t,S,o,B,i,z)}C.indices=z}}_exportVertexBuffer(t,q,S,o,B,z){const L=t.getKind();if(!E(L))return;if(L.startsWith("uv")&&!this._options.exportUnusedUVs&&(!q||!this._materialNeedsUVsSet.has(q)))return;let r=B.getVertexAccessor(t,S,o);if(void 0===r){const q=B.convertedToRightHandedBuffers.get(t._buffer)||t._buffer.getData(),z=L===Z.i.PositionKind?function(t,q,S,o){const{byteOffset:B,byteStride:z,type:L,normalized:r}=q,e=q.getSize(),C=new Array(e).fill(1/0),Z=new Array(e).fill(-1/0);return(0,f.h)(t,B+S*z,z,e,L,o*e,r,(t=>{for(let q=0;q<e;q++)C[q]=Math.min(C[q],t[q]),Z[q]=Math.max(Z[q],t[q])})),{min:C,max:Z}}(q,t,S,o):void 0,e=(L===Z.i.MatricesIndicesKind||L===Z.i.MatricesIndicesExtraKind)&&t.type===Z.i.FLOAT,C=e?Z.i.UNSIGNED_BYTE:t.type,b=e?void 0:t.normalized,O=e?B.getRemappedBufferView(t._buffer,t):B.getVertexBufferView(t._buffer),i=t.byteOffset+S*t.byteStride;this._accessors.push(this._bufferManager.createAccessor(O,function(t,q){if(t==Z.i.ColorKind)return q?"VEC4":"VEC3";switch(t){case Z.i.PositionKind:case Z.i.NormalKind:return"VEC3";case Z.i.TangentKind:case Z.i.MatricesIndicesKind:case Z.i.MatricesIndicesExtraKind:case Z.i.MatricesWeightsKind:case Z.i.MatricesWeightsExtraKind:return"VEC4";case Z.i.UVKind:case Z.i.UV2Kind:case Z.i.UV3Kind:case Z.i.UV4Kind:case Z.i.UV5Kind:case Z.i.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${t}`)}(L,B.hasVertexColorAlpha(t)),C,o,i,z,b)),r=this._accessors.length-1,B.setVertexAccessor(t,S,o,r)}z.attributes[function(t){switch(t){case Z.i.PositionKind:return"POSITION";case Z.i.NormalKind:return"NORMAL";case Z.i.TangentKind:return"TANGENT";case Z.i.ColorKind:return"COLOR_0";case Z.i.UVKind:return"TEXCOORD_0";case Z.i.UV2Kind:return"TEXCOORD_1";case Z.i.UV3Kind:return"TEXCOORD_2";case Z.i.UV4Kind:return"TEXCOORD_3";case Z.i.UV5Kind:return"TEXCOORD_4";case Z.i.UV6Kind:return"TEXCOORD_5";case Z.i.MatricesIndicesKind:return"JOINTS_0";case Z.i.MatricesIndicesExtraKind:return"JOINTS_1";case Z.i.MatricesWeightsKind:return"WEIGHTS_0";case Z.i.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${t}`)}(L)]=r}async _exportMaterialAsync(t,q,S,o){let B=this._materialMap.get(t);if(void 0===B){const o=q&&Object.keys(q).some((t=>t.startsWith("uv")));if((t=t instanceof it.d?t.Ii[S.materialIndex]:t)instanceof ht.e)B=await this._materialExporter.exportPBRMaterialAsync(t,"image/png",o);else{if(!(t instanceof lt.e))return void D.c.Warn(`Unsupported material '${t.name}' with type ${t.getClassName()}`);B=await this._materialExporter.exportStandardMaterialAsync(t,"image/png",o)}this._materialMap.set(t,B)}o.material=B}async _exportMeshAsync(t,q){var S;let o=q.getMesh(t);if(void 0!==o)return o;const B={primitives:[]};o=this._meshes.length,this._meshes.push(B),q.setMesh(t,o);const L=t.isUnIndexed?null:t.Bi(),r=null===(S=t.xi)||void 0===S?void 0:S.getVertexBuffers(),e=q.getMorphTargetsFromMesh(t),C=t instanceof Vt.c,Z=t instanceof ct,b=t.Di;if(r&&b&&b.length>0)for(const h of b){const S={attributes:{}},o=h.Ha()||this._babylonScene.defaultMaterial;if(Z){var O,i;const q={name:o.name},B=t,z=I.c.White(),L=(null===(O=B.material)||void 0===O?void 0:O.alpha)??1,r=(null===(i=B.greasedLineMaterial)||void 0===i?void 0:i.color)??z;(!r.equalsWithEpsilon(z,A.d)||L<1)&&(q.pbrMetallicRoughness={baseColorFactor:[...r.Gi(),L]}),this._materials.push(q),S.material=this._materials.length-1}else if(C){const q={name:o.name},B=t;(!B.color.equalsWithEpsilon(I.c.White(),A.d)||B.alpha<1)&&(q.pbrMetallicRoughness={baseColorFactor:[...B.color.Gi(),B.alpha]}),this._materials.push(q),S.material=this._materials.length-1}else await this._exportMaterialAsync(o,r,h,S);const b=C||Z?z.c.LineListDrawMode:t.overrideRenderingFillMode??o.fillMode,l=o._getEffectiveOrientation(t);this._exportIndices(L,L?(0,f.b)(L,h.indexCount,h.indexStart,h.verticesStart):h.verticesCount>65535,L?h.indexStart:h.verticesStart,L?h.indexCount:h.verticesCount,-h.verticesStart,b,l,q,S);for(const t of Object.values(r))this._exportVertexBuffer(t,o,h.verticesStart,h.verticesCount,q,S);if(e){S.targets=[];for(const t of e)S.targets.push(t.attributes)}B.primitives.push(S),this._extensionsPostExportMeshPrimitive(S)}if(e){B.weights=[],B.extras||(B.extras={}),B.extras.targetNames=[];for(const t of e)B.weights.push(t.influence),B.extras.targetNames.push(t.name)}return o}}gt._ExtensionNames=new Array,gt._ExtensionFactories={};class Nt{static async GLTFAsync(t,q,S){S&&S.exportWithoutWaitingForScene||await t.whenReadyAsync();const o=new gt(t,S),B=await o.generateGLTFAsync(q.replace(/\.[^/.]+$/,""));return o.dispose(),B}static async GLBAsync(t,q,S){S&&S.exportWithoutWaitingForScene||await t.whenReadyAsync();const o=new gt(t,S),B=await o.generateGLBAsync(q.replace(/\.[^/.]+$/,""));return o.dispose(),B}}S(480);const Tt="EXT_mesh_gpu_instancing";class wt{constructor(t){this.name=Tt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(t,q,S,B,z,L){return await new Promise((t=>{if(q&&S instanceof vt.c&&S.hasThinInstances&&this._exporter){this._wasUsed=!0;const t=o.o.Zero(),B=o.g.Identity(),r=o.o.One(),e=S.thinInstanceGetWorldMatrices(),C=o.j.wi[2],Z=o.j.Quaternion[1],b=o.j.wi[3];let O=!1,i=!1,h=!1;const l=new Float32Array(3*S.qi),I=new Float32Array(4*S.qi),a=new Float32Array(3*S.qi);let v=0;for(const q of e)q.decompose(b,Z,C),z&&(F(C),d(Z)),l.set(C.Gi(),3*v),I.set(Z.normalize().Gi(),4*v),a.set(b.Gi(),3*v),O=O||!C.equalsWithEpsilon(t),i=i||!Z.equalsWithEpsilon(B),h=h||!b.equalsWithEpsilon(r),v++;const M={attributes:{}};O&&(M.attributes.TRANSLATION=this._buildAccessor(l,"VEC3",S.qi,L)),i&&(M.attributes.ROTATION=this._buildAccessor(I,"VEC4",S.qi,L)),h&&(M.attributes.SCALE=this._buildAccessor(a,"VEC3",S.qi,L)),q.extensions=q.extensions||{},q.extensions[Tt]=M}t(q)}))}_buildAccessor(t,q,S,o){const B=o.createBufferView(t),z=o.createAccessor(B,q,5126,S);return this._exporter._accessors.push(z),this._exporter._accessors.length-1}}gt.RegisterExtension(Tt,(t=>new wt(t)));var Et=S(12067),pt=S(12075),Pt=S(12083),Ft=S(12088);function dt(t){return t===Pt.e.PositionKind?"POSITION":t===Pt.e.NormalKind?"NORMAL":t===Pt.e.ColorKind?"COLOR":t.startsWith(Pt.e.UVKind)?"TEX_COORD":"GENERIC"}const Rt={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class tq extends Et.e{static get DefaultAvailable(){return(0,Et.l)(tq.DefaultConfiguration)}static get Default(){return tq._Default??(tq._Default=new tq),tq._Default}static ResetDefault(t){tq._Default&&(t||tq._Default.dispose(),tq._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(t,q){return{module:await(q||DracoEncoderModule)({wasmBinary:t})}}_getWorkerContent(){return`${pt.i}(${pt.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:tq.DefaultConfiguration)}async _encodeAsync(t,q,S){const o=S?(0,Ft.c)(Rt,S):Rt;if(this._workerPoolPromise){const S=await this._workerPoolPromise;return await new Promise(((B,z)=>{S.push(((S,L)=>{const r=t=>{S.removeEventListener("error",r),S.removeEventListener("message",e),z(t),L()},e=t=>{"encodeMeshDone"===t.data.id&&(S.removeEventListener("error",r),S.removeEventListener("message",e),B(t.data.encodedMeshData),L())};S.addEventListener("error",r),S.addEventListener("message",e);const C=[];for(const q of t)C.push(q.data.buffer);q&&C.push(q.buffer),S.postMessage({id:"encodeMesh",attributes:t,indices:q,options:o},C)}))}))}if(this._modulePromise){const S=await this._modulePromise;return(0,pt.i)(S.module,t,q,o)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(t,q){if(0==t.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");t instanceof vt.c&&t.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===q||void 0===q?void 0:q.method)&&(D.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),q.method="MESH_SEQUENTIAL_ENCODING");const S=function(t){let q=t.Bi(void 0,!0);return!q||q instanceof Uint32Array||q instanceof Uint16Array||(q=((0,f.b)(q,q.length)?Uint32Array:Uint16Array).from(q)),q}(t),o=function(t,q){const S=[];for(const o of t.getVerticesDataKinds()){if(null!==q&&void 0!==q&&q.includes(o)){if(o===Pt.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const B=t.getVertexBuffer(o),z=B.getSize(),L=(0,f.t)(B.getData(),z,B.type,B.byteOffset,B.byteStride,B.normalized,t.getTotalVertices(),!0);S.push({kind:o,dracoName:dt(o),size:z,data:L})}return S}(t,null===q||void 0===q?void 0:q.excludedAttributes);return await this._encodeAsync(o,S,q)}}tq.DefaultConfiguration={wasmUrl:`${B.f._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${B.f._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${B.f._DefaultCdnUrl}/draco_encoder.js`},tq._Default=null;const qq="KHR_draco_mesh_compression";class Sq{get wasUsed(){return this._wasUsed}constructor(t){this.name=qq,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===t.options.meshCompressionMethod&&tq.DefaultAvailable}dispose(){}postExportMeshPrimitive(t,q,S){if(!this.enabled)return;if(4!==t.mode&&5!==t.mode)return void D.c.Warn("Cannot compress primitive with mode "+t.mode+".");const o=[],B=[];let z=null;if(void 0!==t.indices){const L=S[t.indices],r=q.getBufferView(L);z=q.getData(r).slice(),o.push(r),B.push(L)}const L=[];for(const[Z,b]of Object.entries(t.attributes)){const t=S[b],z=q.getBufferView(t),e=w(t.type),C=(0,f.t)(q.getData(z),e,t.componentType,t.byteOffset||0,z.byteStride||(0,f.m)(t.componentType)*e,t.normalized||!1,t.count,!0);L.push({kind:Z,dracoName:(r=Z,"POSITION"===r?"POSITION":"NORMAL"===r?"NORMAL":r.startsWith("COLOR")?"COLOR":r.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:w(t.type),data:C}),o.push(z),B.push(t)}var r;const e={method:t.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=tq.Default._encodeAsync(L,z,e).then((S=>{if(!S)return void D.c.Error("Draco encoding failed for primitive.");const z={bufferView:-1,attributes:S.attributeIds},L=q.createBufferView(S.data);q.setBufferView(z,L);for(const t of o)this._bufferViewsUsed.add(t);for(const t of B)this._accessorsUsed.add(t);t.extensions||(t.extensions={}),t.extensions[qq]=z})).catch((t=>{D.c.Error("Draco encoding failed for primitive: "+t)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(t){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((q=>{t.getPropertiesWithBufferView(q).every((t=>this._accessorsUsed.has(t)))&&t.removeBufferView(q)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}gt.RegisterExtension(qq,(t=>new Sq(t)));var oq=S(12094);const Bq="KHR_lights_punctual",zq={name:"",color:[1,1,1],bb:1,range:Number.MAX_VALUE},Lq={innerConeAngle:0,outerConeAngle:Math.PI/4},rq=o.o.Backward();class eq{constructor(t){this.name=Bq,this.enabled=!0,this.required=!1,this._exporter=t}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Bq]=this._lights}async postExportNodeAsync(t,q,S,B,z){return await new Promise((L=>{if(!(S instanceof Mt.b))return void L(q);const r=S.getTypeID()==Mt.b.LIGHTTYPEID_POINTLIGHT?"point":S.getTypeID()==Mt.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":S.getTypeID()==Mt.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!r||!(S instanceof oq.d))return D.c.Warn(`${t}: Light ${S.name} is not supported in ${Bq}`),void L(q);if(S.falloffType!==Mt.b.FALLOFF_GLTF&&D.c.Warn(`${t}: Light falloff for ${S.name} does not match the ${Bq} specification!`),!S.position.equalsToFloats(0,0,0)){const t=o.j.wi[0].p(S.position);z&&F(t),q.translation=t.Gi()}if("point"!==r){const t=S.direction.normalizeToRef(o.j.wi[0]);z&&F(t);const B=o.g.FromUnitVectorsToRef(rq,t,o.j.Quaternion[0]);o.g.IsIdentity(B)||(q.rotation=B.Gi())}const e={type:r,name:S.name,color:S.cb.Gi(),bb:S.bb,range:S.range};if(ot(e,zq),"spot"===r){const t=S;e.spot={innerConeAngle:t.innerAngle/2,outerConeAngle:t.angle/2},ot(e.spot,Lq)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(e);const C={ab:this._lights.lights.length-1},Z=S.parent;if(Z&&qt(S,Z)){const t=B.get(Z);if(t){const S=this._exporter._nodes[t];return tt(q,S),S.extensions||(S.extensions={}),S.extensions[Bq]=C,void L(null)}}q.extensions||(q.extensions={}),q.extensions[Bq]=C,L(q)}))}}gt.RegisterExtension(Bq,(t=>new eq(t)));var Cq=S(11958);const Zq="KHR_materials_anisotropy";class bq{constructor(t){this.name=Zq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof Cq.b&&S.anisotropy.isEnabled&&!S.anisotropy.legacy?(S.anisotropy.texture&&o.push(S.anisotropy.texture),o):[]}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof Cq.b){if(!S.anisotropy.isEnabled||S.anisotropy.legacy)return void t(q);this._wasUsed=!0,q.extensions=q.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(S.anisotropy.texture),B={anisotropyStrength:S.anisotropy.bb,anisotropyRotation:S.anisotropy.angle,anisotropyTexture:o??void 0};null!==B.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(S),q.extensions[Zq]=B}t(q)}))}}gt.RegisterExtension(Zq,(t=>new bq(t)));const Oq="KHR_materials_clearcoat";class iq{constructor(t){this.name=Oq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof Cq.b&&S.clearCoat.isEnabled?(S.clearCoat.texture&&o.push(S.clearCoat.texture),!S.clearCoat.useRoughnessFromMainTexture&&S.clearCoat.textureRoughness&&o.push(S.clearCoat.textureRoughness),S.clearCoat.bumpTexture&&o.push(S.clearCoat.bumpTexture),o):[]}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof Cq.b){if(!S.clearCoat.isEnabled)return void t(q);this._wasUsed=!0,q.extensions=q.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(S.clearCoat.texture);let z;z=S.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(S.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(S.clearCoat.textureRoughness),S.clearCoat.isTintEnabled&&B.f.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${S.name}`),S.clearCoat.remapF0OnInterfaceChange&&B.f.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${S.name}`);const L=this._exporter._materialExporter.getTextureInfo(S.clearCoat.bumpTexture),r={clearcoatFactor:S.clearCoat.bb,clearcoatTexture:o??void 0,clearcoatRoughnessFactor:S.clearCoat.roughness,clearcoatRoughnessTexture:z??void 0,clearcoatNormalTexture:L??void 0};null===r.clearcoatTexture&&null===r.clearcoatRoughnessTexture&&null===r.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(S),q.extensions[Oq]=r}t(q)}))}}gt.RegisterExtension(Oq,(t=>new iq(t)));const hq="KHR_materials_diffuse_transmission";function lq(t,q){const S=q.subSurface;let o=null;return S.translucencyIntensityTexture?o=S.translucencyIntensityTexture:S.thicknessTexture&&S.useMaskFromThicknessTexture&&(o=S.thicknessTexture),o&&!S.useGltfStyleTextures?(D.c.Warn(`${t}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${q.name}`,1),null):o}class Iq{constructor(t){this.name=hq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];if(S instanceof ht.e&&this._isExtensionEnabled(S)){const q=lq(t,S);return q&&o.push(q),S.subSurface.translucencyColorTexture&&o.push(S.subSurface.translucencyColorTexture),o}return o}_isExtensionEnabled(t){if(t.unlit)return!1;const q=t.subSurface;return!!q.isTranslucencyEnabled&&(!t.unlit&&!q.useAlbedoToTintTranslucency&&q.useGltfStyleTextures&&1===q.volumeIndexOfRefraction&&0===q.minimumThickness&&0===q.maximumThickness)}postExportMaterialAsync(t,q,S){return new Promise((o=>{if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0;const o=S.subSurface,B=lq(t,S),z=0==o.translucencyIntensity?void 0:o.translucencyIntensity,L=this._exporter._materialExporter.getTextureInfo(B)??void 0,r=!o.translucencyColor||o.translucencyColor.equalsFloats(1,1,1)?void 0:o.translucencyColor.Gi(),e=this._exporter._materialExporter.getTextureInfo(o.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:z,diffuseTransmissionTexture:L,diffuseTransmissionColorFactor:r,diffuseTransmissionColorTexture:e};(L||e)&&this._exporter._materialNeedsUVsSet.add(S),q.extensions=q.extensions||{},q.extensions[hq]=C}o(q)}))}}gt.RegisterExtension(hq,(t=>new Iq(t)));const aq="KHR_materials_dispersion";class vq{constructor(){this.name=aq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){if(t.unlit)return!1;const q=t.subSurface;return!(!q.isRefractionEnabled&&!q.isDispersionEnabled)}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0;const t={dispersion:S.subSurface.dispersion};q.extensions=q.extensions||{},q.extensions[aq]=t}t(q)}))}}gt.RegisterExtension(aq,(()=>new vq));const Mq="KHR_materials_emissive_strength";class xq{constructor(){this.name=Mq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(t,q,S){return await new Promise((t=>{if(!(S instanceof ht.e))return t(q);const o=S.emissiveColor.Gi(),B=Math.max(...o);if(B>1){this._wasUsed=!0,q.extensions||(q.extensions={});const t={emissiveStrength:B},o=S.emissiveColor.scale(1/t.emissiveStrength);q.emissiveFactor=o.Gi(),q.extensions[Mq]=t}return t(q)}))}}gt.RegisterExtension(Mq,(t=>new xq));const kq="KHR_materials_ior";class Vq{constructor(){this.name=kq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.indexOfRefraction&&1.5!=t.indexOfRefraction)}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0;const t={ior:S.indexOfRefraction};q.extensions=q.extensions||{},q.extensions[kq]=t}t(q)}))}}gt.RegisterExtension(kq,(t=>new Vq));const Jq="KHR_materials_iridescence";class Uq{constructor(t){this.name=Jq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof Cq.b&&S.iridescence.isEnabled?(S.iridescence.texture&&o.push(S.iridescence.texture),S.iridescence.thicknessTexture&&S.iridescence.thicknessTexture!==S.iridescence.texture&&o.push(S.iridescence.thicknessTexture),o):[]}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof Cq.b){if(!S.iridescence.isEnabled)return void t(q);this._wasUsed=!0,q.extensions=q.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(S.iridescence.texture),B=this._exporter._materialExporter.getTextureInfo(S.iridescence.thicknessTexture),z={iridescenceFactor:S.iridescence.bb,iridescenceIor:S.iridescence.indexOfRefraction,iridescenceThicknessMinimum:S.iridescence.minimumThickness,iridescenceThicknessMaximum:S.iridescence.maximumThickness,iridescenceTexture:o??void 0,iridescenceThicknessTexture:B??void 0};null===z.iridescenceTexture&&null===z.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(S),q.extensions[Jq]=z}t(q)}))}}gt.RegisterExtension(Jq,(t=>new Uq(t)));const Hq="KHR_materials_sheen";class jq{constructor(t){this.name=Hq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){return S instanceof ht.e&&S.sheen.isEnabled&&S.sheen.texture?[S.sheen.texture]:[]}async postExportMaterialAsync(t,q,S){return await new Promise((t=>{if(S instanceof ht.e){if(!S.sheen.isEnabled)return void t(q);this._wasUsed=!0,null==q.extensions&&(q.extensions={});const o={sheenColorFactor:S.sheen.color.Gi(),sheenRoughnessFactor:S.sheen.roughness??0};null===o.sheenColorTexture&&null===o.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(S),S.sheen.texture&&(o.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.texture)??void 0),S.sheen.textureRoughness&&!S.sheen.useRoughnessFromMainTexture?o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.textureRoughness)??void 0:S.sheen.texture&&S.sheen.useRoughnessFromMainTexture&&(o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.texture)??void 0),q.extensions[Hq]=o}t(q)}))}}gt.RegisterExtension(Hq,(t=>new jq(t)));const yq="KHR_materials_specular";class Qq{constructor(t){this.name=yq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof ht.e&&this._isExtensionEnabled(S)?(S.metallicReflectanceTexture&&o.push(S.metallicReflectanceTexture),S.reflectanceTexture&&o.push(S.reflectanceTexture),o):o}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.metallicF0Factor&&1!=t.metallicF0Factor||void 0!=t.metallicReflectanceColor&&!t.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.metallicReflectanceTexture||null!=t.reflectanceTexture}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0,q.extensions=q.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(S.metallicReflectanceTexture)??void 0,o=this._exporter._materialExporter.getTextureInfo(S.reflectanceTexture)??void 0,B={specularFactor:1==S.metallicF0Factor?void 0:S.metallicF0Factor,specularTexture:t,specularColorFactor:S.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:S.metallicReflectanceColor.Gi(),specularColorTexture:o};this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),q.extensions[yq]=B}t(q)}))}}gt.RegisterExtension(yq,(t=>new Qq(t)));const Kq="KHR_materials_transmission";class Xq{constructor(t){this.name=Kq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof ht.e&&this._isExtensionEnabled(S)?(S.subSurface.thicknessTexture&&o.push(S.subSurface.thicknessTexture),o):o}_isExtensionEnabled(t){if(t.unlit)return!1;const q=t.subSurface;return q.isRefractionEnabled&&void 0!=q.refractionIntensity&&0!=q.refractionIntensity||this._hasTexturesExtension(t)}_hasTexturesExtension(t){return null!=t.subSurface.refractionIntensityTexture}async postExportMaterialAsync(t,q,S){if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0;const o=S.subSurface,B={transmissionFactor:0===o.refractionIntensity?void 0:o.refractionIntensity};if(this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),o.refractionIntensityTexture)if(o.useGltfStyleTextures){const t=await this._exporter._materialExporter.exportTextureAsync(o.refractionIntensityTexture,"image/png");t&&(B.transmissionTexture=t)}else D.c.Warn(`${t}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);q.extensions||(q.extensions={}),q.extensions[Kq]=B}return q}}gt.RegisterExtension(Kq,(t=>new Xq(t)));const Gq="KHR_materials_unlit";class Yq{constructor(){this.name=Gq,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(t,q,S){return new Promise((t=>{let o=!1;S instanceof ht.e?o=S.unlit:S instanceof lt.e&&(o=S.disableLighting),o&&(this._wasUsed=!0,null==q.extensions&&(q.extensions={}),q.extensions[Gq]={}),t(q)}))}}gt.RegisterExtension(Gq,(()=>new Yq));const nq="KHR_materials_volume";class uq{constructor(t){this.name=nq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof ht.e&&this._isExtensionEnabled(S)?(S.subSurface.thicknessTexture&&o.push(S.subSurface.thicknessTexture),o):o}_isExtensionEnabled(t){if(t.unlit)return!1;const q=t.subSurface;return!(!q.isRefractionEnabled&&!q.isTranslucencyEnabled)&&(void 0!=q.maximumThickness&&0!=q.maximumThickness||void 0!=q.tintColorAtDistance&&q.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=q.tintColor&&q.tintColor!=I.c.White()||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.subSurface.thicknessTexture}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof ht.e&&this._isExtensionEnabled(S)){this._wasUsed=!0;const t=S.subSurface,o={thicknessFactor:0==t.maximumThickness?void 0:t.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(t.thicknessTexture)??void 0,attenuationDistance:t.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:t.tintColorAtDistance,attenuationColor:t.tintColor.equalsFloats(1,1,1)?void 0:t.tintColor.Gi()};this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),q.extensions=q.extensions||{},q.extensions[nq]=o}t(q)}))}}gt.RegisterExtension(nq,(t=>new uq(t)));const Wq="EXT_materials_diffuse_roughness";class fq{constructor(t){this.name=Wq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,q,S){const o=[];return S instanceof Cq.b&&S._baseDiffuseRoughness?(S._baseDiffuseRoughnessTexture&&o.push(S._baseDiffuseRoughnessTexture),o):[]}postExportMaterialAsync(t,q,S){return new Promise((t=>{if(S instanceof Cq.b){if(!S._baseDiffuseRoughness)return void t(q);this._wasUsed=!0,q.extensions=q.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(S._baseDiffuseRoughnessTexture),B={diffuseRoughnessFactor:S._baseDiffuseRoughness,diffuseRoughnessTexture:o??void 0};null!==B.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(S),q.extensions[Wq]=B}t(q)}))}}gt.RegisterExtension(Wq,(t=>new fq(t)));const Dq="KHR_texture_transform";class mq{constructor(){this.name=Dq,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(t,q,S){if(S.va()||B.f.Warn(`${t}: /*@__KEY__*/"scene" is not defined for Babylon texture ${S.name}!`),(0!==S.uAng||0!==S.vAng)&&(B.f.Warn(`${t}: Texture ${S.name} with rotation in the u or v axis is not supported in glTF.`),0!==S.uRotationCenter||0!==S.vRotationCenter))return;const o={};let z=!1;if(0===S.uOffset&&0===S.vOffset||(o.offset=[S.uOffset,S.vOffset],z=!0),1===S.uScale&&1===S.vScale||(o.scale=[S.uScale,S.vScale],z=!0),0!==S.wAng){if(0!==S.uRotationCenter||0!==S.vRotationCenter){if(S.homogeneousRotationInUVTransform&&S.uScale!==S.vScale)return void B.f.Warn(`${t}: Texture ${S.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Dq}.`);B.f.Warn(`${t}: Texture ${S.name} with non-origin rotation center will be exported using an adjusted offset with ${Dq}.`),o.offset=function(t){const{uOffset:q,vOffset:S,uRotationCenter:o,vRotationCenter:B,uScale:z,vScale:L,wAng:r}=t,e=Math.cos(r),C=Math.sin(r),Z=o*z,b=B*L;return[q+(Z*(1-e)+b*C),S+(b*(1-e)-Z*C)]}(S)}o.rotation=-S.wAng,z=!0}0!==S.coordinatesIndex&&(o.texCoord=S.coordinatesIndex,z=!0),z&&(this._wasUsed=!0,q.extensions||(q.extensions={}),q.extensions[Dq]=o)}}gt.RegisterExtension(Dq,(()=>new mq));class Aq{static CreateSTL(t){let q=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",B=arguments.length>3&&void 0!==arguments[3]&&arguments[3],z=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],L=arguments.length>5&&void 0!==arguments[5]&&arguments[5],r=arguments.length>6&&void 0!==arguments[6]&&arguments[6],e=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(t,q,S){const B=[3*t[S],3*t[S+1],3*t[S+2]],z=[new o.o(q[B[0]],q[B[0]+2],q[B[0]+1]),new o.o(q[B[1]],q[B[1]+2],q[B[1]+1]),new o.o(q[B[2]],q[B[2]+2],q[B[2]+1])],L=z[0].Kg(z[1]),r=z[2].Kg(z[1]);return{v:z,n:o.o.Cross(r,L).normalize()}},b=function(t,q,S,o){return q=O(t,q,S.x,o),q=O(t,q,S.y,o),O(t,q,S.z,o)},O=function(t,q,S,o){return t.setFloat32(q,S,o),q+4},h=function(t){if(r){let q=t;t instanceof i.c&&(q=t.sourceMesh);const S=q.getVerticesData(Z.i.PositionKind,!0,!0);if(!S)return[];const B=o.o.Zero();let z;for(z=0;z<S.length;z+=3)o.o.TransformCoordinatesFromFloatsToRef(S[z],S[z+1],S[z+2],t.Ai(!0),B).toArray(S,z);return S}return t.getVerticesData(Z.i.PositionKind)||[]};r&&(L=!0);let l="",I=0,a=0;if(B){for(let S=0;S<t.length;S++){const q=t[S].Bi();I+=q?q.length/3:0}const q=new ArrayBuffer(84+50*I);l=new DataView(q),a+=80,l.setUint32(a,I,z),a+=4}else e||(l="solid stlmesh\r\n");for(let o=0;o<t.length;o++){const q=t[o];!B&&e&&(l+="solid "+q.name+"\r\n"),!L&&q instanceof vt.c&&q.bakeCurrentTransformIntoVertices();const S=h(q),r=q.Bi()||[];for(let t=0;t<r.length;t+=3){const q=C(r,S,t);B?(a=b(l,a,q.n,z),a=b(l,a,q.v[0],z),a=b(l,a,q.v[1],z),a=b(l,a,q.v[2],z),a+=2):(l+="\tfacet normal "+q.n.x+" "+q.n.y+" "+q.n.z+"\r\n",l+="\t\touter loop\r\n",l+="\t\t\tvertex "+q.v[0].x+" "+q.v[0].y+" "+q.v[0].z+"\r\n",l+="\t\t\tvertex "+q.v[1].x+" "+q.v[1].y+" "+q.v[1].z+"\r\n",l+="\t\t\tvertex "+q.v[2].x+" "+q.v[2].y+" "+q.v[2].z+"\r\n",l+="\t\tendloop\r\n",l+="\tendfacet\r\n")}!B&&e&&(l+="endsolid "+name+"\r\n")}if(B||e||(l+="endsolid stlmesh"),q){const t=document.createElement("a"),q=new Blob([l],{type:"application/octet-stream"});t.href=window.URL.createObjectURL(q),t.download=S+".stl",t.click()}return l}}function cq(t,q){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const o=[];for(let B=0;B<t.length/S;B++){const z=t[B*S],L=t[B*S+1],r=t[B*S+2];o.push(`(${z.toPrecision(q.precision)}, ${L.toPrecision(q.precision)}, ${r.toPrecision(q.precision)})`)}return o.join(", ")}function sq(t,q){const S=[];for(let o=0;o<t.length/2;o++){const B=t[2*o],z=t[2*o+1];S.push(`(${B.toPrecision(q.precision)}, ${(1-z).toPrecision(q.precision)})`)}return S.join(", ")}function gq(t,q){const S=t.getVerticesData(Z.i.PositionKind),o=t.getVerticesData(Z.i.NormalKind);if(S&&o)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t){var q;const S=null!==(q=t.Bi())&&void 0!==q&&q.length?t.getTotalIndices():t.getTotalVertices();return Array(S/3).fill(3).join(", ")}(t)}]\n\t\tint[] faceVertexIndices = [${function(t){const q=t.Bi(),S=[];if(null!==q)for(let o=0;o<q.length;o++)S.push(q[o]);else{const q=t.getTotalVertices();for(let t=0;t<q;t++)S.push(t)}return S.join(", ")}(t)}]\n\t\tnormal3f[] normals = [${cq(o,q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${cq(S,q)}]\n        ${function(t,q){let S="";for(let B=0;B<4;B++){const o=B>0?B:"",z=t.getVerticesData(Z.i.UVKind+(o?o+1:""));z&&(S+=`\n\t\ttexCoord2f[] primvars:st${o} = [${sq(z,q)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const o=t.getVerticesData(Z.i.ColorKind);return o&&(S+=`\n\tcolor3f[] primvars:displayColor = [${cq(o,q,o.length/t.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),S}(t,q)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Nq(t,q){return`\n        def "Geometry"\n        {\n        ${gq(t,q)}\n        }\n        `}function Tq(t){let q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return q+=t,fflate.strToU8(q)}function wq(t){const q=t.m;return`( ${Eq(q,0)}, ${Eq(q,4)}, ${Eq(q,8)}, ${Eq(q,12)} )`}function Eq(t,q){return`(${t[q+0]}, ${t[q+1]}, ${t[q+2]}, ${t[q+3]})`}function pq(t){const q="Object_"+t.uniqueId,S=function(t){const q=t.getWorldMatrix().clone(),S=t.va().useRightHandedSystem;if(!S){let o=t.parent;for(;o;){if(Lt(o,S)){q.multiplyToRef(o.getWorldMatrix().invert(),q);break}o=o.parent}}return q.determinant()<0&&B.f.Warn(`Exporting mesh ${t.name} with negative scale. Result may look incorrect in destination engine.`),q}(t),o=wq(S);return`def Xform "${q}" (\n\tprepend references = @./geometries/Geometry_${t.xi.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${o}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${t.material.uniqueId}>\n}\n\n`}function Pq(t){switch(t){case J.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case J.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case J.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Fq(t){return`(${t.x}, ${t.y})`}function dq(t){return`(${t.r}, ${t.g}, ${t.b})`}function Rq(t,q,S,B,z,L){const r=t.getInternalTexture().uniqueId+"_"+t.invertY;z[r]=t;const e=t.coordinatesIndex>0?"st"+t.coordinatesIndex:"st",C=new o.l(t.uScale,t.vScale),Z=new o.l(t.uOffset,t.vOffset),b=t.wAng,O=Math.sin(b),i=Math.cos(b);return Z.y=1-Z.y-C.y,Z.x+=O*C.x,Z.y+=(1-i)*C.y,`\n    def Shader "PrimvarReader_${S}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${e}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${S}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${q.uniqueId}/PrimvarReader_${S}.outputs:result>\n        float inputs:rotation = ${(b*(180/Math.PI)).toFixed(L.precision)}\n        float2 inputs:scale = ${Fq(C)}\n        float2 inputs:translation = ${Fq(Z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${t.uniqueId}_${S}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${r}.png@\n        float2 inputs:st.connect = </Materials/Material_${q.uniqueId}/Transform2d_${S}.outputs:result>\n        ${B?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(B):""}\n        token inputs:sourceColorSpace = "${t.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Pq(t.wrapU)}"\n        token inputs:wrapT = "${Pq(t.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${q.needAlphaBlending()?"float outputs:a":""}\n    }`}function tS(t,q,S){const o="\t\t\t",B=[],z=[],{diffuseMap:L,cb:r,alphaCutOff:e,emissiveMap:C,emissive:Z,normalMap:b,roughnessMap:O,roughnessChannel:i,roughness:h,metalnessMap:l,metalnessChannel:a,metalness:v,aoMap:M,aoMapChannel:x,aoMapIntensity:k,alphaMap:V,ior:J,clearCoatEnabled:U,clearCoat:H,clearCoatMap:j,clearCoatRoughness:y,clearCoatRoughnessMap:Q}=function(t){const q={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return t instanceof lt.e?{...q,diffuseMap:t.diffuseTexture,cb:t.diffuseColor,alphaCutOff:t.alphaCutOff,emissiveMap:t.emissiveTexture,emissive:t.emissiveColor,roughness:1,alphaMap:t.opacityTexture}:t instanceof Cq.b?{...q,diffuseMap:t._albedoTexture,cb:t._albedoColor,alphaCutOff:t._alphaCutOff,emissiveMap:t._emissiveTexture,emissive:t._emissiveColor,normalMap:t._bumpTexture,roughnessMap:t._metallicTexture,roughnessChannel:t._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:t._roughness??1,metalnessMap:t._metallicTexture,metalnessChannel:t._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:t._metallic??0,aoMap:t._ambientTexture,aoMapChannel:t._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:t._ambientTextureStrength,alphaMap:t._opacityTexture,ior:t.subSurface.indexOfRefraction,clearCoatEnabled:t.clearCoat.isEnabled,clearCoat:t.clearCoat.bb,clearCoatMap:t.clearCoat.texture,clearCoatRoughness:t.clearCoat.roughness,clearCoatRoughnessMap:t.clearCoat.useRoughnessFromMainTexture?t.clearCoat.texture:t.clearCoat.textureRoughness}:q}(t);return null!==L?(B.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${t.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:rgb>`),t.needAlphaBlending()?B.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`):t.needAlphaTesting()&&(B.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${L.uniqueId}_diffuse.outputs:a>`),B.push(`${o}float inputs:opacityThreshold = ${e}`)),z.push(Rq(L,t,"diffuse",r,q,S))):B.push(`${o}color3f inputs:diffuseColor = ${dq(r||I.c.White())}`),null!==C?(B.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${t.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),z.push(Rq(C,t,"emissive",Z,q,S))):Z&&Z.toLuminance()>0&&B.push(`${o}color3f inputs:emissiveColor = ${dq(Z)}`),null!==b&&(B.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${t.uniqueId}/Texture_${b.uniqueId}_normal.outputs:rgb>`),z.push(Rq(b,t,"Zi",null,q,S))),null!==M&&(B.push(`${o}float inputs:occlusion.connect = </Materials/Material_${t.uniqueId}/Texture_${M.uniqueId}_occlusion.outputs:${x}>`),z.push(Rq(M,t,"occlusion",new I.c(k,k,k),q,S))),null!==O?(B.push(`${o}float inputs:roughness.connect = </Materials/Material_${t.uniqueId}/Texture_${O.uniqueId}_roughness.outputs:${i}>`),z.push(Rq(O,t,"roughness",new I.c(h,h,h),q,S))):B.push(`${o}float inputs:roughness = ${h}`),null!==l?(B.push(`${o}float inputs:metallic.connect = </Materials/Material_${t.uniqueId}/Texture_${l.uniqueId}_metallic.outputs:${a}>`),z.push(Rq(l,t,"metallic",new I.c(v,v,v),q,S))):B.push(`${o}float inputs:metallic = ${v}`),null!==V?(B.push(`${o}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${V.uniqueId}_opacity.outputs:r>`),B.push(`${o}float inputs:opacityThreshold = 0.0001`),z.push(Rq(V,t,"opacity",null,q,S))):B.push(`${o}float inputs:opacity = ${t.alpha}`),U&&(null!==j?(B.push(`${o}float inputs:clearcoat.connect = </Materials/Material_${t.uniqueId}/Texture_${j.uniqueId}_clearcoat.outputs:r>`),z.push(Rq(j,t,"clearcoat",new I.c(H,H,H),q,S))):B.push(`${o}float inputs:clearcoat = ${H}`),null!==Q?(B.push(`${o}float inputs:clearcoatRoughness.connect = </Materials/Material_${t.uniqueId}/Texture_${Q.uniqueId}_clearcoatRoughness.outputs:g>`),z.push(Rq(Q,t,"clearcoatRoughness",new I.c(y,y,y),q,S))):B.push(`${o}float inputs:clearcoatRoughness = ${y}`)),B.push(`${o}float inputs:ior = ${J}`),`\n\tdef Material "Material_${t.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${B.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.uniqueId}/PreviewSurface.outputs:surface>\n\n${z.join("\n")}\n\n\t}\n`}async function qS(t,q,S){const z={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...q};"undefined"===typeof fflate&&await B.f.LoadScriptAsync(z.fflateUrl);const L={};L[z.modelFileName]=null;let r='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';r+=function(t){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===t.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${t.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.planeAnchoringAlignment}"`:""}\n            `}(z);const e={};for(const o of t.meshes){if(0===o.getTotalVertices())continue;const t=o,q=t.xi,C=t.material;if(!C||!q||S&&!S(t))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const S="geometries/Geometry_"+q.uniqueId+".usda";if(!(S in L)){const t=Nq(q,z);L[S]=Tq(t)}C.uniqueId in e||(e[C.uniqueId]=C),r+=pq(t)}else B.f.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}t.activeCamera&&z.exportCamera&&(r+=function(t,q){const S="Camera_"+t.uniqueId,B=wq(o.e.RotationY(Math.PI).multiply(t.getWorldMatrix()));if(t.mode===J.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${S}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.Ci.toPrecision(q.precision)}, ${t.maxZ.toPrecision(q.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.orthoLeft||1)+Math.abs(t.orthoRight||1))).toPrecision(q.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.orthoTop||1)+Math.abs(t.orthoBottom||1))).toPrecision(q.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const o=t.getEngine().getAspectRatio(t),z=q.cameraSensorWidth||35;return`def Camera "${S}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${B}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.Ci.toPrecision(q.precision)}, ${t.maxZ.toPrecision(q.precision)})\n\t\t\tfloat focalLength = ${(z/(2*Math.tan(.5*t.fov))).toPrecision(q.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(z*o).toPrecision(q.precision)}\n\t\t\tfloat verticalAperture = ${(z/o).toPrecision(q.precision)}            \n\t\t}\n\t\n\t`}}(t.activeCamera,z)),r+="\n            }\n        }\n    }";const C={};r+=function(t,q,S){const o=[];for(const B in t){const z=t[B];o.push(tS(z,q,S))}return`\n    def "Materials"\n{\n${o.join("")}\n}\n\n`}(e,C,z),L[z.modelFileName]=fflate.strToU8(r);for(const o in C){const t=C[o],q=t.getSize(),S=await t.readPixels();if(!S)throw new Error("Texture data is not available");const B=await U.DumpTools.DumpDataAsync(q.width,q.height,S,"image/png",void 0,!1,!0);L[`textures/Texture_${o}.png`]=new Uint8Array(B).slice()}let Z=0;for(const o in L){const t=L[o];if(!t)continue;Z+=34+o.length;const q=63&Z;if(4!==q){const S=new Uint8Array(64-q);L[o]=[t,{extra:{12345:S}}]}Z=t.length}return fflate.zipSync(L,{level:0})}}}]);