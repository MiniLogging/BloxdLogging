"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{12633:(h,d,m)=>{var j=m(11216),A=m(11121),b=m(11150),w=m(11245),a=m(11188),D=m(11229);a.b.prototype._partialLoadFile=function(h,d,m,j){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(h,(h=>{m[d]=h,m._internalCount++,6===m._internalCount&&j(m)}),void 0,void 0,!0,((h,d)=>{A&&h&&A(h.status+" "+h.statusText,d)}))},a.b.prototype._cascadeLoadFiles=function(h,d,m){let j=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const A=[];A._internalCount=0;for(let b=0;b<6;b++)this._partialLoadFile(m[b],b,A,d,j)},a.b.prototype._cascadeLoadImgs=function(h,d,m,j){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,b=arguments.length>5?arguments[5]:void 0;const w=[];w._internalCount=0;for(let a=0;a<6;a++)this._partialLoadImg(j[a],a,w,h,d,m,A,b)},a.b.prototype._partialLoadImg=function(h,d,m,j,A,a){let D=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,S=arguments.length>7?arguments[7]:void 0;const M=(0,w.d)();(0,b.y)(h,(h=>{m[d]=h,m._internalCount++,j&&j.removePendingData(M),6===m._internalCount&&a&&a(A,m)}),((h,d)=>{j&&j.removePendingData(M),D&&D(h,d)}),j?j.offlineProvider:null,S),j&&j.addPendingData(M)},a.b.prototype.createCubeTextureBase=function(h,d,m,b){let w=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,a=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,S=arguments.length>6?arguments[6]:void 0,M=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,q=arguments.length>8&&void 0!==arguments[8]&&arguments[8],E=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,I=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,R=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,Z=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,L=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,B=arguments.length>14&&void 0!==arguments[14]&&arguments[14],V=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const v=R||new j.c(this,7);v.isCube=!0,v.url=h,v.generateMipMaps=!b,v._lodGenerationScale=E,v._lodGenerationOffset=I,v._useSRGBBuffer=!!B&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!b),v!==R&&(v.label=h.substring(0,60)),this._doNotHandleContextLost||(v._extension=M,v._files=m,v._buffer=V);const C=h;this._transformTextureUrl&&!R&&(h=this._transformTextureUrl(h));const T=M??function(h){const d=h.split("?")[0],m=d.lastIndexOf(".");return m>-1?d.substring(m).toLowerCase():""}(h),o=(0,D.c)(T),y=(h,d)=>{v.dispose(),a?a(h,d):h&&A.c.Warn(h)},i=(j,a)=>{h===C?j&&y(j.status+" "+j.statusText,a):(A.c.Warn(`Failed to load ${h}, falling back to the ${C}`),this.createCubeTextureBase(C,d,m,!!b,w,y,S,M,q,E,I,v,Z,L,B,V))};if(o)o.then((j=>{const A=h=>{Z&&Z(v,h),j.loadCubeData(h,v,q,w,((h,d)=>{y(h,d)}))};V?A(V):m&&6===m.length?j.supportCascades?this._cascadeLoadFiles(d,(h=>A(h.map((h=>new Uint8Array(h))))),m,y):y("Textures type does not support cascades."):this._loadFile(h,(h=>A(new Uint8Array(h))),void 0,void 0,!0,i)}));else{if(!m||0===m.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(d,v,((h,d)=>{L&&L(h,d)}),m,y)}return this._internalTexturesCache.push(v),v}},13337:(h,d,m)=>{m.r(d),m.d(d,{_DDSTextureLoader:()=>b});var j=m(11516),A=m(13339);class b{constructor(){this.supportCascades=!0}loadCubeData(h,d,m,b){const w=d.getEngine();let a,D=!1,S=1e3;if(Array.isArray(h))for(let j=0;j<h.length;j++){const m=h[j];a=A.DDSTools.GetDDSInfo(m),d.width=a.width,d.height=a.height,D=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&d.generateMipMaps,w._unpackFlipY(a.isCompressed),A.DDSTools.UploadDDSLevels(w,d,m,a,D,6,-1,j),a.isFourCC||1!==a.mipmapCount?S=a.mipmapCount-1:w.generateMipMapsForCubemap(d)}else{const b=h;a=A.DDSTools.GetDDSInfo(b),d.width=a.width,d.height=a.height,m&&(a.sphericalPolynomial=new j.d),D=(a.isRGB||a.isLuminance||a.mipmapCount>1)&&d.generateMipMaps,w._unpackFlipY(a.isCompressed),A.DDSTools.UploadDDSLevels(w,d,b,a,D,6),a.isFourCC||1!==a.mipmapCount?S=a.mipmapCount-1:w.generateMipMapsForCubemap(d,!1)}w._setCubeMapTextureParams(d,D,S),d.isReady=!0,d.onLoadedObservable.notifyObservers(d),d.onLoadedObservable.clear(),b&&b({isDDS:!0,width:d.width,info:a,data:h,texture:d})}loadData(h,d,m){const j=A.DDSTools.GetDDSInfo(h),b=(j.isRGB||j.isLuminance||j.mipmapCount>1)&&d.generateMipMaps&&Math.max(j.width,j.height)>>j.mipmapCount-1===1;m(j.width,j.height,b,j.isFourCC,(()=>{A.DDSTools.UploadDDSLevels(d.getEngine(),d,h,j,b,1)}))}}},13339:(h,d,m)=>{m.d(d,{DDSTools:()=>R});var j=m(11099),A=m(11121),b=m(11682),w=m(11538);m(12633);const a=131072,D=131072;function S(h){return h.charCodeAt(0)+(h.charCodeAt(1)<<8)+(h.charCodeAt(2)<<16)+(h.charCodeAt(3)<<24)}const M=S("DXT1"),q=S("DXT3"),E=S("DXT5"),I=S("DX10");class R{static GetDDSInfo(h){const d=new Int32Array(h.buffer,h.byteOffset,31),m=new Int32Array(h.buffer,h.byteOffset,35);let j=1;d[2]&a&&(j=Math.max(1,d[7]));const A=d[21],b=A===I?m[32]:0;let w=0;switch(A){case 113:w=2;break;case 116:w=1;break;case I:if(10===b){w=2;break}if(2===b){w=1;break}}return{width:d[4],height:d[3],mipmapCount:j,isFourCC:4===(4&d[20]),isRGB:64===(64&d[20]),isLuminance:(d[20]&D)===D,isCube:512===(512&d[28]),isCompressed:A===M||A===q||A===E,dxgiFormat:b,textureType:w}}static _GetHalfFloatAsFloatRGBAArrayBuffer(h,d,m,j,A,b){const a=new Float32Array(j),D=new Uint16Array(A,m);let S=0;for(let M=0;M<d;M++)for(let d=0;d<h;d++){const m=4*(d+M*h);a[S]=(0,w.f)(D[m]),a[S+1]=(0,w.f)(D[m+1]),a[S+2]=(0,w.f)(D[m+2]),R.StoreLODInAlphaChannel?a[S+3]=b:a[S+3]=(0,w.f)(D[m+3]),S+=4}return a}static _GetHalfFloatRGBAArrayBuffer(h,d,m,j,A,b){if(R.StoreLODInAlphaChannel){const a=new Uint16Array(j),D=new Uint16Array(A,m);let S=0;for(let m=0;m<d;m++)for(let d=0;d<h;d++){const j=4*(d+m*h);a[S]=D[j],a[S+1]=D[j+1],a[S+2]=D[j+2],a[S+3]=(0,w.k)(b),S+=4}return a}return new Uint16Array(A,m,j)}static _GetFloatRGBAArrayBuffer(h,d,m,j,A,b){if(R.StoreLODInAlphaChannel){const w=new Float32Array(j),a=new Float32Array(A,m);let D=0;for(let m=0;m<d;m++)for(let d=0;d<h;d++){const j=4*(d+m*h);w[D]=a[j],w[D+1]=a[j+1],w[D+2]=a[j+2],w[D+3]=b,D+=4}return w}return new Float32Array(A,m,j)}static _GetFloatAsHalfFloatRGBAArrayBuffer(h,d,m,j,A,b){const a=new Uint16Array(j),D=new Float32Array(A,m);let S=0;for(let M=0;M<d;M++)for(let d=0;d<h;d++)a[S]=(0,w.k)(D[S]),a[S+1]=(0,w.k)(D[S+1]),a[S+2]=(0,w.k)(D[S+2]),R.StoreLODInAlphaChannel?a[S+3]=(0,w.k)(b):a[S+3]=(0,w.k)(D[S+3]),S+=4;return a}static _GetFloatAsUIntRGBAArrayBuffer(h,d,m,A,b,w){const a=new Uint8Array(A),D=new Float32Array(b,m);let S=0;for(let M=0;M<d;M++)for(let d=0;d<h;d++){const m=4*(d+M*h);a[S]=255*(0,j.Clamp)(D[m]),a[S+1]=255*(0,j.Clamp)(D[m+1]),a[S+2]=255*(0,j.Clamp)(D[m+2]),R.StoreLODInAlphaChannel?a[S+3]=w:a[S+3]=255*(0,j.Clamp)(D[m+3]),S+=4}return a}static _GetHalfFloatAsUIntRGBAArrayBuffer(h,d,m,A,b,a){const D=new Uint8Array(A),S=new Uint16Array(b,m);let M=0;for(let q=0;q<d;q++)for(let d=0;d<h;d++){const m=4*(d+q*h);D[M]=255*(0,j.Clamp)((0,w.f)(S[m])),D[M+1]=255*(0,j.Clamp)((0,w.f)(S[m+1])),D[M+2]=255*(0,j.Clamp)((0,w.f)(S[m+2])),R.StoreLODInAlphaChannel?D[M+3]=a:D[M+3]=255*(0,j.Clamp)((0,w.f)(S[m+3])),M+=4}return D}static _GetRGBAArrayBuffer(h,d,m,j,A,b,w,a,D){const S=new Uint8Array(j),M=new Uint8Array(A,m);let q=0;for(let E=0;E<d;E++)for(let d=0;d<h;d++){const m=4*(d+E*h);S[q]=M[m+b],S[q+1]=M[m+w],S[q+2]=M[m+a],S[q+3]=M[m+D],q+=4}return S}static _ExtractLongWordOrder(h){return 0===h||255===h||-16777216===h?0:1+R._ExtractLongWordOrder(h>>8)}static _GetRGBArrayBuffer(h,d,m,j,A,b,w,a){const D=new Uint8Array(j),S=new Uint8Array(A,m);let M=0;for(let q=0;q<d;q++)for(let d=0;d<h;d++){const m=3*(d+q*h);D[M]=S[m+b],D[M+1]=S[m+w],D[M+2]=S[m+a],M+=3}return D}static _GetLuminanceArrayBuffer(h,d,m,j,A){const b=new Uint8Array(j),w=new Uint8Array(A,m);let a=0;for(let D=0;D<d;D++)for(let d=0;d<h;d++){const m=d+D*h;b[a]=w[m],a++}return b}static UploadDDSLevels(h,d,m,j,w,D){let S=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,Z=arguments.length>7?arguments[7]:void 0,L=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],B=null;j.sphericalPolynomial&&(B=[]);const V=!!h.getCaps().s3tc;d.generateMipMaps=w;const v=new Int32Array(m.buffer,m.byteOffset,31);let C,T,o,y,i,g,F,f=0,H=0,c=1;if(542327876!==v[0])return void A.c.Error("Invalid magic number in DDS header");if(!j.isFourCC&&!j.isRGB&&!j.isLuminance)return void A.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(j.isCompressed&&!V)return void A.c.Error("Compressed textures are not supported on this platform.");let k=v[22];y=v[1]+4;let l=!1;if(j.isFourCC)switch(C=v[21],C){case M:c=8,H=33777;break;case q:c=16,H=33778;break;case E:c=16,H=33779;break;case 113:l=!0,k=64;break;case 116:l=!0,k=128;break;case I:{y+=20;let h=!1;switch(j.dxgiFormat){case 10:l=!0,k=64,h=!0;break;case 2:l=!0,k=128,h=!0;break;case 88:j.isRGB=!0,j.isFourCC=!1,k=32,h=!0}if(h)break}default:return void A.c.Error(["Unsupported FourCC code:",(K=C,String.fromCharCode(255&K,K>>8&255,K>>16&255,K>>24&255))])}var K;const N=R._ExtractLongWordOrder(v[23]),W=R._ExtractLongWordOrder(v[24]),r=R._ExtractLongWordOrder(v[25]),Y=R._ExtractLongWordOrder(v[26]);l&&(H=h._getRGBABufferInternalSizedFormat(j.textureType)),g=1,v[2]&a&&!1!==w&&(g=Math.max(1,v[7]));const x=Z||0,Q=h.getCaps();for(let A=x;A<D;A++){for(T=v[4],o=v[3],F=0;F<g;++F){if(-1===S||S===F){const b=-1===S?F:0;if(!j.isCompressed&&j.isFourCC){d.format=5,f=T*o*4;let j=null;if(h._badOS||h._badDesktopOS||!Q.textureHalfFloat&&!Q.textureFloat)128===k?(j=R._GetFloatAsUIntRGBAArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,b),B&&0==b&&B.push(R._GetFloatRGBAArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,b))):64===k&&(j=R._GetHalfFloatAsUIntRGBAArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,b),B&&0==b&&B.push(R._GetHalfFloatAsFloatRGBAArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,b))),d.type=0;else{const h=Q.textureFloat&&(L&&Q.textureFloatLinearFiltering||!L),A=Q.textureHalfFloat&&(L&&Q.textureHalfFloatLinearFiltering||!L),w=(128===k||64===k&&!A)&&h?1:(64===k||128===k&&!h)&&A?2:0;let a,D=null;if(128===k)switch(w){case 1:a=R._GetFloatRGBAArrayBuffer,D=null;break;case 2:a=R._GetFloatAsHalfFloatRGBAArrayBuffer,D=R._GetFloatRGBAArrayBuffer;break;case 0:a=R._GetFloatAsUIntRGBAArrayBuffer,D=R._GetFloatRGBAArrayBuffer}else switch(w){case 1:a=R._GetHalfFloatAsFloatRGBAArrayBuffer,D=null;break;case 2:a=R._GetHalfFloatRGBAArrayBuffer,D=R._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:a=R._GetHalfFloatAsUIntRGBAArrayBuffer,D=R._GetHalfFloatAsFloatRGBAArrayBuffer}d.type=w,j=a(T,o,m.byteOffset+y,f,m.buffer,b),B&&0==b&&B.push(D?D(T,o,m.byteOffset+y,f,m.buffer,b):j)}j&&h._uploadDataToTextureDirectly(d,j,A,b)}else if(j.isRGB)d.type=0,24===k?(d.format=4,f=T*o*3,i=R._GetRGBArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,N,W,r),h._uploadDataToTextureDirectly(d,i,A,b)):(d.format=5,f=T*o*4,i=R._GetRGBAArrayBuffer(T,o,m.byteOffset+y,f,m.buffer,N,W,r,Y),h._uploadDataToTextureDirectly(d,i,A,b));else if(j.isLuminance){const j=h._getUnpackAlignement(),w=T;f=Math.floor((T+j-1)/j)*j*(o-1)+w,i=R._GetLuminanceArrayBuffer(T,o,m.byteOffset+y,f,m.buffer),d.format=1,d.type=0,h._uploadDataToTextureDirectly(d,i,A,b)}else f=Math.max(4,T)/4*Math.max(4,o)/4*c,i=new Uint8Array(m.buffer,m.byteOffset+y,f),d.type=0,h._uploadCompressedDataToTextureDirectly(d,H,T,o,i,A,b)}y+=k?T*o*(k/8):f,T*=.5,o*=.5,T=Math.max(1,T),o=Math.max(1,o)}if(void 0!==Z)break}B&&B.length>0?j.sphericalPolynomial=b.e.ConvertCubeMapToSphericalPolynomial({size:v[4],right:B[0],left:B[1],up:B[2],down:B[3],front:B[4],back:B[5],format:5,type:1,gammaSpace:!1}):j.sphericalPolynomial=void 0}}R.StoreLODInAlphaChannel=!1}}]);