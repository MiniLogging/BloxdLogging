"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11826:(c,b,A)=>{A.r(b),A.d(b,{EXT_materials_diffuse_roughness:()=>Zb,EXT_mesh_gpu_instancing:()=>gc,GLTF2Export:()=>Tc,GLTFData:()=>C,KHR_draco_mesh_compression:()=>Ab,KHR_lights_punctual:()=>Lb,KHR_materials_anisotropy:()=>Xb,KHR_materials_clearcoat:()=>Nb,KHR_materials_diffuse_transmission:()=>Vb,KHR_materials_dispersion:()=>jb,KHR_materials_emissive_strength:()=>Mb,KHR_materials_ior:()=>db,KHR_materials_iridescence:()=>zb,KHR_materials_sheen:()=>Db,KHR_materials_specular:()=>vb,KHR_materials_transmission:()=>Pb,KHR_materials_unlit:()=>pb,KHR_materials_volume:()=>Ib,KHR_texture_transform:()=>Sb,OBJExport:()=>h,STLExport:()=>Bb,USDZExportAsync:()=>bA,_ConvertToGLTFPBRMetallicRoughness:()=>O,_SolveMetallic:()=>P,__IGLTFExporterExtension:()=>s});var o=A(688),t=A(525),n=A(852);class h{static OBJ(c,b,A,h){const s=[];let L=1,C=1;b&&(A||(A="mat"),s.push("mtllib "+A+".mtl"));for(let J=0;J<c.length;J++){const A=c[J],X=A.name||`mesh${J}}`;s.push(`o ${X}`);let R=null;if(h){const c=A.Zj(!0);R=new o.b,c.invertToRef(R),A.bakeTransformIntoVertices(c)}if(b){const c=A.material;c&&s.push("usemtl "+c.id)}const N=A.mk;if(!N){t.d.Warn("No geometry is present on the mesh");continue}const k=N.getVerticesData("position"),E=N.getVerticesData("ik"),V=N.getVerticesData("uv"),y=N._j();let j=0,F=0;if(!k||!y){t.d.Warn("There are no position vertices or indices on the mesh!");continue}const M=c[0].va().useRightHandedSystem?1:-1;for(let c=0;c<k.length;c+=3)s.push("v "+k[c]*M+" "+k[c+1]+" "+k[c+2]),j++;if(null!=E)for(let c=0;c<E.length;c+=3)s.push("vn "+E[c]*M+" "+E[c+1]+" "+E[c+2]);if(null!=V)for(let c=0;c<V.length;c+=2)s.push("vt "+V[c]+" "+V[c+1]),F++;const W=["","",""],d=(A.material||A.va().defaultMaterial)._getEffectiveOrientation(A),[r,z]=d===n.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let c=0;c<y.length;c+=3){const b=[String(y[c]+L),String(y[c+r]+L),String(y[c+z]+L)],A=[String(y[c]+C),String(y[c+r]+C),String(y[c+z]+C)],o=b,t=null!=V?A:W,n=null!=E?b:W;s.push("f "+o[0]+"/"+t[0]+"/"+n[0]+" "+o[1]+"/"+t[1]+"/"+n[1]+" "+o[2]+"/"+t[2]+"/"+n[2])}h&&R&&A.bakeTransformIntoVertices(R),L+=j,C+=F}return s.join("\n")}static MTL(c){const b=[],A=c.material;b.push("newmtl mat1"),b.push("  Ns "+A.specularPower.toFixed(4)),b.push("  Ni 1.5000"),b.push("  d "+A.alpha.toFixed(4)),b.push("  Tr 0.0000"),b.push("  Tf 1.0000 1.0000 1.0000"),b.push("  illum 2"),b.push("  Ka "+A.ambientColor.r.toFixed(4)+" "+A.ambientColor.g.toFixed(4)+" "+A.ambientColor.b.toFixed(4)),b.push("  Kd "+A.diffuseColor.r.toFixed(4)+" "+A.diffuseColor.g.toFixed(4)+" "+A.diffuseColor.b.toFixed(4)),b.push("  Ks "+A.specularColor.r.toFixed(4)+" "+A.specularColor.g.toFixed(4)+" "+A.specularColor.b.toFixed(4)),b.push("  Ke "+A.emissiveColor.r.toFixed(4)+" "+A.emissiveColor.g.toFixed(4)+" "+A.emissiveColor.b.toFixed(4));A.ambientTexture&&b.push("  map_Ka "+A.ambientTexture.name),A.diffuseTexture&&b.push("  map_Kd "+A.diffuseTexture.name),A.specularTexture&&b.push("  map_Ks "+A.specularTexture.name),A.bumpTexture&&b.push("  map_bump -imfchan z "+A.bumpTexture.name),A.opacityTexture&&b.push("  map_d "+A.opacityTexture.name);return b.join("\n")}}var s=0,L=A(552);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const c in this.files){const b=this.files[c],A=new Blob([b],{type:(0,L.j)(c)});t.d.Download(A,c)}}}var J=A(747),X=A(830),R=A(821),N=A(11831),k=A(2102),E=A(550),V=A(721),y=A(702);const j=y.HighestCommonFactor,F={...y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:j};var M=A(2064),W=A(2070),d=A(11833),r=A(11838),z=A(2231);const Y=1e-6,D=new V.d(.04,.04,.04),f=1024,v=V.d.White(),G=V.d.Black();function P(c,b,A){if(b<D.r)return 0;const o=D.r,t=c*A/(1-D.r)+b-2*D.r,n=t*t-4*o*(D.r-b);return F.Clamp((-t+Math.sqrt(n))/(2*o),0,1)}function O(c){const b=c.diffuseColor.toLinearSpace(c.va().getEngine().useExactSrgbConversions).scale(.5),A=c.alpha,t=function(c){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new o.h(0,1),A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new o.h(0,.1),t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new o.h(0,.1),n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new o.h(1300,.1);return function(c,b,A,o,t){return(1-c)*(1-c)*(1-c)*b+3*(1-c)*(1-c)*c*A+3*(1-c)*c*c*o+c*c*c*t}(Math.pow(c/n.x,.333333),b.y,A.y,t.y,n.y)}(F.Clamp(c.specularPower,0,f));return{baseColorFactor:[b.r,b.g,b.b,A],metallicFactor:0,roughnessFactor:t}}function p(c,b){b.needAlphaBlending()?c.alphaMode="BLEND":b.needAlphaTesting()&&(c.alphaMode="MASK",c.alphaCutoff=b.alphaCutOff)}function q(c,b,A){const o=new Uint8Array(c*b*4);for(let t=0;t<o.length;t+=4)o[t]=o[t+1]=o[t+2]=o[t+3]=255;return d.d.CreateRGBATexture(o,c,b,A)}function I(c){if(c instanceof Uint8Array){const b=c.length,A=new Float32Array(c.length);for(let o=0;o<b;++o)A[o]=c[o]/255;return A}if(c instanceof Float32Array)return c;throw new Error("Unsupported pixel format!")}class K{constructor(c){this._exporter=c,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(c){return c?this._textureMap.get(c)??null:null}async exportStandardMaterialAsync(c,b,A){const o=O(c),n={name:c.name};if(null==c.jk||c.jk||(c.twoSidedLighting||t.d.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),A){const A=[],t=c.diffuseTexture;t&&A.push(this.exportTextureAsync(t,b).then((c=>{c&&(o.baseColorTexture=c)})));const h=c.bumpTexture;h&&A.push(this.exportTextureAsync(h,b).then((c=>{c&&(n.normalTexture=c,1!==h.level&&(n.normalTexture.scale=h.level))})));const s=c.emissiveTexture;s&&(n.emissiveFactor=[1,1,1],A.push(this.exportTextureAsync(s,b).then((c=>{c&&(n.emissiveTexture=c)}))));const L=c.ambientTexture;L&&A.push(this.exportTextureAsync(L,b).then((c=>{if(c){const b={index:c.index};n.occlusionTexture=b}}))),A.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(A))}(c.alpha<1||c.opacityTexture)&&(c.alphaMode===r.e.ALPHA_COMBINE?n.alphaMode="BLEND":t.d.Warn(c.name+": glTF 2.0 does not support alpha mode: "+c.alphaMode.toString())),c.emissiveColor&&!c.emissiveColor.equalsWithEpsilon(G,Y)&&(n.emissiveFactor=c.emissiveColor.hk()),n.pbrMetallicRoughness=o,p(n,c),await this._finishMaterialAsync(n,c,b);const h=this._exporter._materials;return h.push(n),h.length-1}async _finishMaterialAsync(c,b,A){const o=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",c,b),t=[];for(const n of o)t.push(this.exportTextureAsync(n,A));await Promise.all(t),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",c,b)}async _getImageDataAsync(c,b,o,t){const n=r.e.TEXTURETYPE_UNSIGNED_BYTE,h=this._exporter._babylonScene,s=h.getEngine(),L=s.createRawTexture(c,b,o,r.e.TEXTUREFORMAT_RGBA,!1,!0,W.d.NEAREST_SAMPLINGMODE,null,n);s.isWebGPU?await A.e(45).then(A.bind(A,13323)):await A.e(46).then(A.bind(A,13326)),await M.i.ApplyPostProcess("pass",L,h,n,r.e.TEXTURE_NEAREST_SAMPLINGMODE,r.e.TEXTUREFORMAT_RGBA);const C=await s._readTexturePixels(L,b,o);return await z.DumpTools.DumpDataAsync(b,o,C,t,void 0,!0,!0)}_resizeTexturesToSameDimensions(c,b,A){const o=c?c.getSize():{width:0,height:0},t=b?b.getSize():{width:0,height:0};let n,h;return o.width<t.width?(n=c&&c instanceof W.d?M.i.CreateResizedCopy(c,t.width,t.height,!0):q(t.width,t.height,A),h=b):o.width>t.width?(h=b&&b instanceof W.d?M.i.CreateResizedCopy(b,o.width,o.height,!0):q(o.width,o.height,A),n=c):(n=c,h=b),{texture1:n,texture2:h}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(c,b,A,o){const t=new Array;if(!c&&!b)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const n=c?c.va():b?b.va():null;if(n){var h;const s=this._resizeTexturesToSameDimensions(c,b,n),L=null===(h=s.texture1)||void 0===h?void 0:h.getSize();let C,J;const X=L.width,R=L.height,N=await s.texture1.readPixels(),k=await s.texture2.readPixels();if(!N)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=I(N),!k)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");J=I(k);const E=J.byteLength,y=new Uint8Array(E),j=new Uint8Array(E),F=4,M=G;let W=0,d=0;for(let c=0;c<R;++c)for(let b=0;b<X;++b){const o=(X*c+b)*F,t={diffuseColor:new V.d(C[o],C[o+1],C[o+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(A.diffuseColor),specularColor:new V.d(J[o],J[o+1],J[o+2]).toLinearSpace(n.getEngine().useExactSrgbConversions).multiply(A.specularColor),glossiness:J[o+3]*A.glossiness},h=this._convertSpecularGlossinessToMetallicRoughness(t);M.r=Math.max(M.r,h.baseColor.r),M.g=Math.max(M.g,h.baseColor.g),M.b=Math.max(M.b,h.baseColor.b),W=Math.max(W,h.metallic),d=Math.max(d,h.roughness),j[o]=255*h.baseColor.r,j[o+1]=255*h.baseColor.g,j[o+2]=255*h.baseColor.b,j[o+3]=s.texture1.pi?255*C[o+3]:255,y[o]=0,y[o+1]=255*h.roughness,y[o+2]=255*h.metallic,y[o+3]=255}const r={baseColor:M,metallic:W,roughness:d};let z=!1,D=!1;for(let c=0;c<R;++c)for(let b=0;b<X;++b){const A=(X*c+b)*F;j[A]/=r.baseColor.r>Y?r.baseColor.r:1,j[A+1]/=r.baseColor.g>Y?r.baseColor.g:1,j[A+2]/=r.baseColor.b>Y?r.baseColor.b:1;const o=V.d.FromInts(j[A],j[A+1],j[A+2]).toGammaSpace(n.getEngine().useExactSrgbConversions);j[A]=255*o.r,j[A+1]=255*o.g,j[A+2]=255*o.b,o.equalsWithEpsilon(v,Y)||(D=!0),y[A+1]/=r.roughness>Y?r.roughness:1,y[A+2]/=r.metallic>Y?r.metallic:1;V.d.FromInts(255,y[A+1],y[A+2]).equalsWithEpsilon(v,Y)||(z=!0)}return z&&t.push(this._getImageDataAsync(y,X,R,o).then((c=>{r.metallicRoughnessTextureData=c}))),D&&t.push(this._getImageDataAsync(j,X,R,o).then((c=>{r.baseColorTextureData=c}))),await Promise.all(t).then((()=>r))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(c){const b=this._getPerceivedBrightness(c.diffuseColor),A=this._getPerceivedBrightness(c.specularColor),o=1-this._getMaxComponent(c.specularColor),t=P(b,A,o),n=c.diffuseColor.scale(o/(1-D.r)/Math.max(1-t)),h=c.specularColor.Xd(D.scale(1-t)).scale(1/Math.max(t));let s=V.d.Lerp(n,h,t*t);s=s.clampToRef(0,1,s);return{baseColor:s,metallic:t,roughness:1-c.glossiness}}_getPerceivedBrightness(c){return c?Math.sqrt(.299*c.r*c.r+.587*c.g*c.g+.114*c.b*c.b):0}_getMaxComponent(c){return c?Math.max(c.r,Math.max(c.g,c.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(c,b,A,o){const t=[],n={baseColor:c._albedoColor,metallic:c._metallic,roughness:c._roughness};if(o){c._albedoTexture&&t.push(this.exportTextureAsync(c._albedoTexture,b).then((c=>{c&&(A.baseColorTexture=c)})));const o=c._metallicTexture;o&&t.push(this.exportTextureAsync(o,b).then((c=>{c&&(A.metallicRoughnessTexture=c)})))}return t.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(t)),n}_getTextureSampler(c){const b={};if(!c||!(c instanceof W.d))return b;const A=this._getGLTFTextureWrapMode(c.wrapU);10497!==A&&(b.wrapS=A);const o=this._getGLTFTextureWrapMode(c.wrapV);switch(10497!==o&&(b.wrapT=o),c.samplingMode){case W.d.LINEAR_LINEAR:b.magFilter=9729,b.minFilter=9729;break;case W.d.LINEAR_NEAREST:b.magFilter=9729,b.minFilter=9728;break;case W.d.NEAREST_LINEAR:b.magFilter=9728,b.minFilter=9729;break;case W.d.NEAREST_LINEAR_MIPLINEAR:b.magFilter=9728,b.minFilter=9987;break;case W.d.NEAREST_NEAREST:b.magFilter=9728,b.minFilter=9728;break;case W.d.NEAREST_LINEAR_MIPNEAREST:b.magFilter=9728,b.minFilter=9985;break;case W.d.LINEAR_NEAREST_MIPNEAREST:b.magFilter=9729,b.minFilter=9984;break;case W.d.LINEAR_NEAREST_MIPLINEAR:b.magFilter=9729,b.minFilter=9986;break;case W.d.NEAREST_NEAREST_MIPLINEAR:b.magFilter=9728,b.minFilter=9986;break;case W.d.LINEAR_LINEAR_MIPLINEAR:b.magFilter=9729,b.minFilter=9987;break;case W.d.LINEAR_LINEAR_MIPNEAREST:b.magFilter=9729,b.minFilter=9985;break;case W.d.NEAREST_NEAREST_MIPNEAREST:b.magFilter=9728,b.minFilter=9984}return b}_getGLTFTextureWrapMode(c){switch(c){case W.d.WRAP_ADDRESSMODE:return 10497;case W.d.CLAMP_ADDRESSMODE:return 33071;case W.d.MIRROR_ADDRESSMODE:return 33648;default:return t.d.Error(`Unsupported Texture Wrap Mode ${c}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(c,b,A,o){const t={diffuseColor:c._albedoColor,specularColor:c._reflectivityColor,glossiness:c._microSurface},n=c._albedoTexture,h=c._reflectivityTexture,s=c._useMicroSurfaceFromReflectivityMapAlpha;if(h&&!s)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((n||h)&&o){this._exporter._materialNeedsUVsSet.add(c);const o=this._exportTextureSampler(n||h),s=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(n,h,t,b),L=this._exporter._textures;if(s.baseColorTextureData){const c=this._exportImage(`baseColor${L.length}`,b,s.baseColorTextureData);A.baseColorTexture=this._exportTextureInfo(c,o,null===n||void 0===n?void 0:n.coordinatesIndex)}if(s.metallicRoughnessTextureData){const c=this._exportImage(`metallicRoughness${L.length}`,b,s.metallicRoughnessTextureData);A.metallicRoughnessTexture=this._exportTextureInfo(c,o,null===h||void 0===h?void 0:h.coordinatesIndex)}return s}return this._convertSpecularGlossinessToMetallicRoughness(t)}async exportPBRMaterialAsync(c,b,A){const o={},t={name:c.name},n=c.isMetallicWorkflow();if(n){const b=c._albedoColor,A=c.alpha;b&&(o.baseColorFactor=[b.r,b.g,b.b,A])}const h=n?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(c,b,o,A):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(c,b,o,A);await this._setMetallicRoughnessPbrMaterialAsync(h,c,t,o,b,A),await this._finishMaterialAsync(t,c,b);const s=this._exporter._materials;return s.push(t),s.length-1}async _setMetallicRoughnessPbrMaterialAsync(c,b,A,o,n,h){if(p(A,b),c.baseColor.equalsWithEpsilon(v,Y)&&F.WithinEpsilon(b.alpha,1,Y)||(o.baseColorFactor=[c.baseColor.r,c.baseColor.g,c.baseColor.b,b.alpha]),null!=c.metallic&&1!==c.metallic&&(o.metallicFactor=c.metallic),null!=c.roughness&&1!==c.roughness&&(o.roughnessFactor=c.roughness),null==b.jk||b.jk||(b._twoSidedLighting||t.d.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),A.doubleSided=!0),h){const c=[],o=b._bumpTexture;o&&c.push(this.exportTextureAsync(o,n).then((c=>{c&&(A.normalTexture=c,1!==o.level&&(A.normalTexture.scale=o.level))})));const t=b._ambientTexture;t&&c.push(this.exportTextureAsync(t,n).then((c=>{if(c){const o={index:c.index,texCoord:c.texCoord,extensions:c.extensions};A.occlusionTexture=o;const t=b._ambientTextureStrength;t&&(o.strength=t)}})));const h=b._emissiveTexture;h&&c.push(this.exportTextureAsync(h,n).then((c=>{c&&(A.emissiveTexture=c)}))),c.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(c))}const s=b._emissiveColor;s.equalsWithEpsilon(G,Y)||(A.emissiveFactor=s.hk()),A.pbrMetallicRoughness=o}_getPixelsFromTextureAsync(c){return function(c){switch(c){case r.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case r.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case r.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case r.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case r.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case r.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case r.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case r.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case r.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case r.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case r.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case r.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(c.textureFormat)?(0,M.h)(c,c._texture.width,c._texture.height):(c.textureType,r.e.TEXTURETYPE_UNSIGNED_BYTE,c.readPixels())}async exportTextureAsync(c,b){const A=this._exporter._extensionsPreExportTextureAsync("exporter",c,b);return A?await A.then((async A=>A?await this._exportTextureInfoAsync(A,b):await this._exportTextureInfoAsync(c,b))):await this._exportTextureInfoAsync(c,b)}async _exportTextureInfoAsync(c,b){let A=this._textureMap.get(c);if(!A){const o=await this._getPixelsFromTextureAsync(c);if(!o)return null;const n=this._exportTextureSampler(c),h=c.mimeType;if(h)switch(h){case"image/jpeg":case"image/png":case"image/webp":b=h;break;default:t.d.Warn(`Unsupported media type: ${h}. Exporting texture as PNG.`)}const s=this._internalTextureToImage,L=c.getInternalTexture().uniqueId;s[L]||(s[L]={});let C=s[L][b];if(void 0===C){const A=c.getSize();C=(async()=>{const t=await this._getImageDataAsync(o,A.width,A.height,b);return this._exportImage(c.name,b,t)})(),s[L][b]=C}A=this._exportTextureInfo(await C,n,c.coordinatesIndex),this._textureMap.set(c,A),this._exporter._extensionsPostExportTextures("exporter",A,c)}return A}_exportImage(c,b,A){const o=this._exporter._images;let n;if(this._exporter._shouldUseGlb){n={name:c,mimeType:b,bufferView:void 0};const o=this._exporter._bufferManager.createBufferView(new Uint8Array(A));this._exporter._bufferManager.setBufferView(n,o)}else{const h=c.replace(/\.\/|\/|\.\\|\\/g,"_"),s=function(c){switch(c){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(b);let L=h+s;o.some((c=>c.uri===L))&&(L=`${h}_${t.d.RandomId()}${s}`),n={name:c,uri:L},this._exporter._imageData[L]={data:A,mimeType:b}}return o.push(n),o.length-1}_exportTextureInfo(c,b,A){const o=this._exporter._textures;let t=o.findIndex((A=>A.sampler==b&&A.source===c));-1===t&&(t=o.length,o.push({source:c,sampler:b}));const n={index:t};return A&&(n.texCoord=A),n}_exportTextureSampler(c){const b=this._getTextureSampler(c),A=this._exporter._samplers,o=A.findIndex((c=>c.minFilter===b.minFilter&&c.magFilter===b.magFilter&&c.wrapS===b.wrapS&&c.wrapT===b.wrapT));return-1!==o?o:(A.push(b),A.length-1)}}var Z=A(758),H=A(531),S=A(11843),B=A(693);const Q=o.k.Zero(),a=o.e.Identity(),l=o.k.One(),T=new o.k(-1,1,1);function i(c,b){const{byteOffset:A,byteStride:o,type:t,normalized:n}=c,h=c.getSize(),s=b.reduce(((c,b)=>b.getTotalVertices()>c?b.getTotalVertices():c),-Number.MAX_VALUE);return{byteOffset:A,byteStride:o,componentCount:h,type:t,count:s*h,normalized:n,totalVertices:s,kind:c.getKind()}}function g(c){switch(c){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function u(c){switch(c){case J.f.PositionKind:case J.f.NormalKind:case J.f.TangentKind:case J.f.ColorKind:case J.f.MatricesIndicesKind:case J.f.MatricesIndicesExtraKind:case J.f.MatricesWeightsKind:case J.f.MatricesWeightsExtraKind:case J.f.UVKind:case J.f.UV2Kind:case J.f.UV3Kind:case J.f.UV4Kind:case J.f.UV5Kind:case J.f.UV6Kind:return!0}return!1}function e(c){switch(c){case n.b.TriangleFillMode:return 4;case n.b.TriangleStripDrawMode:return 5;case n.b.TriangleFanDrawMode:return 6;case n.b.PointListDrawMode:case n.b.PointFillMode:return 0;case n.b.LineLoopDrawMode:return 2;case n.b.LineListDrawMode:return 1;case n.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${c}`)}function x(c){const b=Math.sqrt(c.x*c.x+c.y*c.y+c.z*c.z);b>0&&(c.x/=b,c.y/=b,c.z/=b)}function U(c){return c.x*=-1,c}function w(c){if(c.x*c.x+c.y*c.y>.5){const b=Math.abs(c.x),A=Math.abs(c.y);if(b>A){const A=Math.sign(c.x);c.x=b,c.y*=-A,c.z*=-A,c.w*=A}else{const b=Math.sign(c.y);c.x*=-b,c.y=A,c.z*=b,c.w*=-b}}else{const b=Math.abs(c.z),A=Math.abs(c.w);if(b>A){const A=Math.sign(c.z);c.x*=-A,c.y*=A,c.z=b,c.w*=-A}else{const b=Math.sign(c.w);c.x*=b,c.y*=-b,c.z*=-b,c.w=A}}return c}function m(c){c.jd(-c.z,c.w,c.x,-c.y)}function cc(c,b){const A=o.k.FromArrayToRef(b.translation||[0,0,0],0,o.f.ak[0]),t=o.e.FromArrayToRef(b.rotation||[0,0,0,1],0,o.f.Quaternion[0]),n=o.b.ComposeToRef(l,t,A,o.f.Matrix[0]),h=o.k.FromArrayToRef(c.translation||[0,0,0],0,o.f.ak[2]),s=o.e.FromArrayToRef(c.rotation||[0,0,0,1],0,o.f.Quaternion[1]),L=o.b.ComposeToRef(l,s,h,o.f.Matrix[1]);n.multiplyToRef(L,L),L.decompose(void 0,t,A),A.equalsWithEpsilon(Q,B.d)?delete b.translation:b.translation=A.hk(),t.equalsWithEpsilon(a,B.d)?delete b.rotation:b.rotation=t.hk(),b.scale&&delete b.scale}function bc(c,b){if(!(b instanceof X.e))return!1;if(!(1===b.getChildren().length&&0===c.getChildren().length&&c.parent===b))return!1;const A=c.va(),o=c instanceof S.e&&!A.useRightHandedSystem?T:l;return!!b.ld.equalsWithEpsilon(o,B.d)||(H.c.Warn(`Cannot collapse node ${c.name} into parent node ${b.name} with modified scaling.`),!1)}function Ac(c){if(c instanceof Array){const b=new Float32Array(c);return new Uint8Array(b.buffer,b.byteOffset,b.byteLength)}return ArrayBuffer.isView(c)?new Uint8Array(c.buffer,c.byteOffset,c.byteLength):new Uint8Array(c)}function oc(c,b){for(const[A,o]of Object.entries(c)){const t=b[A];(Array.isArray(o)&&Array.isArray(t)&&tc(o,t)||o===t)&&delete c[A]}return c}function tc(c,b){return c.length===b.length&&c.every(((c,A)=>c===b[A]))}const nc=o.b.Compose(new o.k(-1,1,1),o.e.Identity(),o.k.Zero());function hc(c,b){if(!(c instanceof X.e))return!1;if(b){if(!c.getWorldMatrix().equalsWithEpsilon(o.b.IdentityReadOnly,B.d))return!1}else{if(!c.getWorldMatrix().multiplyToRef(nc,o.f.Matrix[0]).equalsWithEpsilon(o.b.IdentityReadOnly,B.d))return!1}return!(c instanceof R.d&&c.mk)}const sc=new Map([[Int8Array,(c,b,A)=>c.setInt8(b,A)],[Uint8Array,(c,b,A)=>c.setUint8(b,A)],[Uint8ClampedArray,(c,b,A)=>c.setUint8(b,A)],[Int16Array,(c,b,A)=>c.setInt16(b,A,!0)],[Uint16Array,(c,b,A)=>c.setUint16(b,A,!0)],[Int32Array,(c,b,A)=>c.setInt32(b,A,!0)],[Uint32Array,(c,b,A)=>c.setUint32(b,A,!0)],[Float32Array,(c,b,A)=>c.setFloat32(b,A,!0)],[Float64Array,(c,b,A)=>c.setFloat64(b,A,!0)]]);class Lc{writeTypedArray(c){this._checkGrowBuffer(c.byteLength);const b=sc.get(c.constructor);for(let A=0;A<c.length;A++)b(this._dataView,this._byteOffset,c[A]),this._byteOffset+=c.BYTES_PER_ELEMENT}constructor(c){this._data=new Uint8Array(c),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(c){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,c),this._byteOffset++}writeInt8(c){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,c),this._byteOffset++}writeInt16(c){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,c,!0),this._byteOffset+=2}writeUInt16(c){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,c,!0),this._byteOffset+=2}writeInt32(c){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,c,!0),this._byteOffset+=4}writeUInt32(c){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,c,!0),this._byteOffset+=4}writeFloat32(c){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,c,!0),this._byteOffset+=4}writeFloat64(c){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,c,!0),this._byteOffset+=8}_checkGrowBuffer(c){const b=this.byteOffset+c;if(b>this._data.byteLength){const c=new Uint8Array(2*b);c.set(this._data),this._data=c,this._dataView=new DataView(this._data.buffer)}}}function Cc(c){return c%4===0?4:c%2===0?2:1}class Jc{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(c){let b=0;this._bufferViewToData.forEach((c=>{b+=c.byteLength}));const A=new Lc(b),o=Array.from(this._bufferViewToData.keys()).sort(((c,b)=>Cc(b.byteLength)-Cc(c.byteLength)));for(const t of o){t.byteOffset=A.byteOffset,c.push(t);const b=c.length-1,o=this.getPropertiesWithBufferView(t);for(const c of o)c.bufferView=b;A.writeTypedArray(this._bufferViewToData.get(t)),this._bufferViewToData.delete(t)}return A.getOutputData()}createBufferView(c,b){const A={buffer:0,byteOffset:void 0,byteLength:c.byteLength,byteStride:b};return this._bufferViewToData.set(A,c),A}createAccessor(c,b,A,o,t,n,h){this._verifyBufferView(c);const s={bufferView:void 0,componentType:A,count:o,type:b,min:null===n||void 0===n?void 0:n.min,max:null===n||void 0===n?void 0:n.max,normalized:h,byteOffset:t};return this.setBufferView(s,c),this._accessorToBufferView.set(s,c),s}setBufferView(c,b){this._verifyBufferView(b);this.getPropertiesWithBufferView(b).push(c)}removeBufferView(c){const b=this.getPropertiesWithBufferView(c);for(const A of b)void 0!==A.bufferView&&delete A.bufferView;this._bufferViewToData.delete(c),this._bufferViewToProperties.delete(c),this._accessorToBufferView.forEach(((b,A)=>{b===c&&(void 0!==A.byteOffset&&delete A.byteOffset,this._accessorToBufferView.delete(A))}))}getBufferView(c){const b=this._accessorToBufferView.get(c);return this._verifyBufferView(b),b}getPropertiesWithBufferView(c){return this._verifyBufferView(c),this._bufferViewToProperties.set(c,this._bufferViewToProperties.get(c)??[]),this._bufferViewToProperties.get(c)}getData(c){return this._verifyBufferView(c),this._bufferViewToData.get(c)}_verifyBufferView(c){if(void 0===c||!this._bufferViewToData.has(c))throw new Error(`BufferView ${c} not found in BufferManager.`)}}var Xc,Rc=A(663),Nc=A(875),kc=A(11847),Ec=A(11900),Vc=A(11907),yc=A(11917),jc=A(510),Fc=A(11921);!function(c){c[c.INTANGENT=0]="INTANGENT",c[c.OUTTANGENT=1]="OUTTANGENT"}(Xc||(Xc={}));class Mc{static _IsTransformable(c){return c&&(c instanceof X.e||c instanceof Rc.c||c instanceof Fc.e)}static _CreateNodeAnimation(c,b,A,o,n){if(this._IsTransformable(c)){const h=[],s=[],L=b.getKeys(),C=Mc._CalculateMinMaxKeyFrames(L),J=Mc._DeduceInterpolation(L,A,o),X=J.interpolationType,R=J.shouldBakeAnimation;if(R?Mc._CreateBakedAnimation(c,b,A,C.min,C.max,b.framePerSecond,n,h,s,C,o):"LINEAR"===X||"STEP"===X?Mc._CreateLinearOrStepAnimation(c,b,A,h,s,o):"CUBICSPLINE"===X?Mc._CreateCubicSplineAnimation(c,b,A,h,s,o):Mc._CreateBakedAnimation(c,b,A,C.min,C.max,b.framePerSecond,n,h,s,C,o),h.length&&s.length){return{inputs:h,outputs:s,samplerInterpolation:X,inputsMin:R?C.min:t.d.FloatRound(C.min/b.framePerSecond),inputsMax:R?C.max:t.d.FloatRound(C.max/b.framePerSecond)}}}return null}static _DeduceAnimationInfo(c){let b=null,A="VEC3",o=!1;const n=c.targetProperty.split(".");switch(n[0]){case"ld":b="scale";break;case"position":b="translation";break;case"rotation":A="VEC4",b="rotation";break;case"rotationQuaternion":A="VEC4",o=!0,b="rotation";break;case"influence":A="SCALAR",b="weights";break;default:t.d.Error(`Unsupported animatable property ${n[0]}`)}return b?{animationChannelTargetPath:b,dataAccessorType:A,useQuaternion:o}:(t.d.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(c,b,A,o,t,n,h,s,L,C,J){let X;if(Mc._IsTransformable(c)&&c.animations)for(const R of c.animations){if(J&&!J(R))continue;const t=Mc._DeduceAnimationInfo(R);t&&(X={name:R.name,samplers:[],channels:[]},Mc._AddAnimation(`${R.name}`,R.hasRunningRuntimeAnimations?b:X,c,R,t.dataAccessorType,t.animationChannelTargetPath,o,n,h,s,t.useQuaternion,L,C),X.samplers.length&&X.channels.length&&A.push(X))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(c,b,A,o,t,n,h,s,L,C,J){let X;if(c instanceof jc.d){const t=c.morphTargetManager;if(t)for(let R=0;R<t.numTargets;++R){const N=t.getTarget(R);for(const k of N.animations){if(J&&!J(k))continue;const N=new Vc.d(`${k.name}`,"influence",k.framePerSecond,k.dataType,k.loopMode,k.enableBlending),E=[],V=k.getKeys();for(let c=0;c<V.length;++c){const b=V[c];for(let c=0;c<t.numTargets;++c)c==R?E.push(b):E.push({frame:b.frame,value:0})}N.setKeys(E);const y=Mc._DeduceAnimationInfo(N);y&&(X={name:N.name,samplers:[],channels:[]},Mc._AddAnimation(k.name,k.hasRunningRuntimeAnimations?b:X,c,N,y.dataAccessorType,y.animationChannelTargetPath,o,n,h,s,y.useQuaternion,L,C,t.numTargets),X.samplers.length&&X.channels.length&&A.push(X))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(c,b,A,o,t,n,h,s,L){let C;if(c.animationGroups){const X=c.animationGroups;for(const R of X){const X=new Map,N=new Map,k=new Set,E=R.to-R.from;C={name:R.name,channels:[],samplers:[]};for(let b=0;b<R.targetedAnimations.length;++b){const E=R.targetedAnimations[b],V=E.target,y=E.animation;if(L&&!L(y))continue;const j=s.has(V);if(this._IsTransformable(V)||1===V.length&&this._IsTransformable(V[0])){const c=Mc._DeduceAnimationInfo(E.animation);if(c){const b=this._IsTransformable(V)?V:this._IsTransformable(V[0])?V[0]:null;b&&Mc._AddAnimation(`${y.name}`,C,b,y,c.dataAccessorType,c.animationChannelTargetPath,A,o,t,n,c.useQuaternion,h,j)}}else if(V instanceof yc.b||1===V.length&&V[0]instanceof yc.b){if(Mc._DeduceAnimationInfo(E.animation)){const b=V instanceof yc.b?V:V[0];if(b){const A=c.morphTargetManagers.find((c=>{for(let A=0;A<c.numTargets;++A)if(c.getTarget(A)===b)return!0;return!1}));if(A){const o=c.meshes.find((c=>c.morphTargetManager===A));var J;if(o)X.has(o)||X.set(o,new Map),null===(J=X.get(o))||void 0===J||J.set(b,y),k.add(o),N.set(o,y)}}}}}k.forEach((c=>{const b=c.morphTargetManager;let s=null;const L=[],J=N.get(c).getKeys(),k=J.length;for(let A=0;A<k;++A)for(let o=0;o<b.numTargets;++o){const t=b.getTarget(o),n=X.get(c);if(n){const b=n.get(t);b?(s||(s=new Vc.d(`${R.name}_${c.name}_MorphWeightAnimation`,"influence",b.framePerSecond,Vc.d.ANIMATIONTYPE_FLOAT,b.loopMode,b.enableBlending)),L.push(b.getKeys()[A])):L.push({frame:R.from+E/k*A,value:t.influence,inTangent:J[0].inTangent?0:void 0,outTangent:J[0].outTangent?0:void 0})}}s.setKeys(L);const V=Mc._DeduceAnimationInfo(s);V&&Mc._AddAnimation(`${R.name}_${c.name}_MorphWeightAnimation`,C,c,s,V.dataAccessorType,V.animationChannelTargetPath,A,o,t,n,V.useQuaternion,h,!1,null===b||void 0===b?void 0:b.numTargets)})),C.channels.length&&C.samplers.length&&b.push(C)}}}static _AddAnimation(c,b,A,t,n,h,s,L,C,J,X,R,N,k){const E=Mc._CreateNodeAnimation(A,t,h,X,R);let V,y,j,F,M,W;if(E){if(k){let c=0,b=0;const A=[];for(;E.inputs.length>0;)b=E.inputs.shift(),c%k==0&&A.push(b),c++;E.inputs=A}const c=s.get(A),t=new Float32Array(E.inputs);V=L.createBufferView(t),y=L.createAccessor(V,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),J.push(y),j=J.length-1;const C=new o.e,X=new o.k,R=new o.k,d=A instanceof Rc.c,r=g(n),z=new Float32Array(E.outputs.length*r);E.outputs.forEach((function(c,b){let A=c;switch(h){case"translation":N&&(o.k.FromArrayToRef(c,0,R),U(R),R.toArray(A));break;case"rotation":4===c.length?o.e.FromArrayToRef(c,0,C):(A=new Array(4),o.k.FromArrayToRef(c,0,X),o.e.FromEulerVectorToRef(X,C)),N&&(w(C),d&&m(C)),C.toArray(A)}z.set(A,b*r)})),V=L.createBufferView(z),y=L.createAccessor(V,n,5126,E.outputs.length),J.push(y),F=J.length-1,M={interpolation:E.samplerInterpolation,input:j,output:F},b.samplers.push(M),W={sampler:b.samplers.length-1,target:{node:c,path:h}},b.channels.push(W)}}static _CreateBakedAnimation(c,b,A,n,h,s,L,C,J,X,R){let N;const k=o.e.Identity();let E,V=null,y=null,j=null,F=null,M=null,W=null;X.min=t.d.FloatRound(n/s);const d=b.getKeys();for(let o=0,r=d.length;o<r;++o){if(W=null,j=d[o],o+1<r)if(F=d[o+1],j.value.equals&&j.value.equals(F.value)||j.value===F.value){if(0!==o)continue;W=j.frame}else W=F.frame;else{if(M=d[o-1],j.value.equals&&j.value.equals(M.value)||j.value===M.value)continue;W=h}if(W)for(let o=j.frame;o<=W;o+=L){if(E=t.d.FloatRound(o/s),E===V)continue;V=E,y=E;const n={key:0,repeatCount:0,loopMode:b.loopMode};N=b._interpolate(o,n),Mc._SetInterpolatedValue(c,N,E,b,A,k,C,J,R)}}y&&(X.max=y)}static _ConvertFactorToVector3OrQuaternion(c,b,A,n,h){const s=Mc._GetBasePositionRotationOrScale(b,n,h),L=A.targetProperty.split("."),C=L?L[1]:"",J=h?o.e.$j(s).normalize():o.k.$j(s);switch(C){case"x":case"y":case"z":J[C]=c;break;case"w":J.w=c;break;default:t.d.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return J}static _SetInterpolatedValue(c,b,A,t,n,h,s,L,C){let J;s.push(A),"weights"!==n?(t.dataType===Vc.d.ANIMATIONTYPE_FLOAT&&(b=this._ConvertFactorToVector3OrQuaternion(b,c,t,n,C)),"rotation"===n?(C?h=b:(J=b,o.e.RotationYawPitchRollToRef(J.y,J.x,J.z,h)),L.push(h.hk())):(J=b,L.push(J.hk()))):L.push([b])}static _CreateLinearOrStepAnimation(c,b,A,o,t,n){for(const h of b.getKeys())o.push(h.frame/b.framePerSecond),Mc._AddKeyframeValue(h,b,t,A,c,n)}static _CreateCubicSplineAnimation(c,b,A,o,t,n){b.getKeys().forEach((function(h){o.push(h.frame/b.framePerSecond),Mc._AddSplineTangent(Xc.INTANGENT,t,A,"CUBICSPLINE",h,n),Mc._AddKeyframeValue(h,b,t,A,c,n),Mc._AddSplineTangent(Xc.OUTTANGENT,t,A,"CUBICSPLINE",h,n)}))}static _GetBasePositionRotationOrScale(c,b,A){let t;if("rotation"===b)if(A){t=(c.rotationQuaternion??o.e.Identity()).hk()}else{t=(c.rotation??o.k.Zero()).hk()}else if("translation"===b){t=(c.position??o.k.Zero()).hk()}else{t=(c.ld??o.k.One()).hk()}return t}static _AddKeyframeValue(c,b,A,n,h,s){let L;const C=b.dataType;if(C===Vc.d.ANIMATIONTYPE_VECTOR3){let b=c.value.hk();if("rotation"===n){const c=o.k.$j(b);b=o.e.RotationYawPitchRoll(c.y,c.x,c.z).hk()}A.push(b)}else if(C===Vc.d.ANIMATIONTYPE_FLOAT){if("weights"===n)A.push([c.value]);else if(L=this._ConvertFactorToVector3OrQuaternion(c.value,h,b,n,s),L){if("rotation"===n){const c=s?L:o.e.RotationYawPitchRoll(L.y,L.x,L.z).normalize();A.push(c.hk())}A.push(L.hk())}}else C===Vc.d.ANIMATIONTYPE_QUATERNION?A.push(c.value.normalize().hk()):t.d.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(c,b,A){let o,t,n=!1;if("rotation"===b&&!A)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let h=0,s=c.length;h<s;++h)if(t=c[h],t.inTangent||t.outTangent)if(o){if("CUBICSPLINE"!==o){o="LINEAR",n=!0;break}}else o="CUBICSPLINE";else if(o){if("CUBICSPLINE"===o||t.interpolation&&1===t.interpolation&&"STEP"!==o){o="LINEAR",n=!0;break}}else o=t.interpolation&&1===t.interpolation?"STEP":"LINEAR";return o||(o="LINEAR"),{interpolationType:o,shouldBakeAnimation:n}}static _AddSplineTangent(c,b,A,t,n,h){let s;const L=c===Xc.INTANGENT?n.inTangent:n.outTangent;if("CUBICSPLINE"===t){if("rotation"===A)if(L)if(h)s=L.hk();else{const c=L;s=o.e.RotationYawPitchRoll(c.y,c.x,c.z).hk()}else s=[0,0,0,0];else s="weights"===A?L?[L]:[0]:L?L.hk():[0,0,0];b.push(s)}}static _CalculateMinMaxKeyFrames(c){let b=1/0,A=-1/0;return c.forEach((function(c){b=Math.min(b,c.frame),A=Math.max(A,c.frame)})),{min:b,max:A}}}function Wc(c,b,A,n,h,s){const L={attributes:{},influence:c.influence,name:c.name},C=b.mk;if(!C)return t.d.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),L;const X=s?-1:1,R=o.k.Zero();let N=0,k=0;if(c.hasPositions){const n=c.getPositions(),s=C.getVerticesData(J.f.PositionKind);if(s){const c=new Float32Array(s.length),b=[1/0,1/0,1/0],t=[-1/0,-1/0,-1/0];k=s.length/3,N=0;for(let A=N;A<k;++A){const h=o.k.$j(s,3*A);o.k.$j(n,3*A).subtractToRef(h,R),R.x*=X,b[0]=Math.min(b[0],R.x),t[0]=Math.max(t[0],R.x),b[1]=Math.min(b[1],R.y),t[1]=Math.max(t[1],R.y),b[2]=Math.min(b[2],R.z),t[2]=Math.max(t[2],R.z),c[3*A]=R.x,c[3*A+1]=R.y,c[3*A+2]=R.z}const C=A.createBufferView(c,12),J=A.createAccessor(C,"VEC3",5126,n.length/3,0,{min:b,max:t});h.push(J),L.attributes.POSITION=h.length-1}else t.d.Warn(`Morph target positions for mesh ${b.name} were not exported. Mesh does not have position vertex data`)}if(c.hasNormals){const n=c.getNormals(),s=C.getVerticesData(J.f.NormalKind);if(s){const c=new Float32Array(s.length);k=s.length/3,N=0;for(let A=N;A<k;++A){const b=o.k.$j(s,3*A).normalize();o.k.$j(n,3*A).normalize().subtractToRef(b,R),c[3*A]=R.x*X,c[3*A+1]=R.y,c[3*A+2]=R.z}const b=A.createBufferView(c,12),t=A.createAccessor(b,"VEC3",5126,n.length/3,0);h.push(t),L.attributes.NORMAL=h.length-1}else t.d.Warn(`Morph target normals for mesh ${b.name} were not exported. Mesh does not have normals vertex data`)}if(c.hasTangents){const n=c.getTangents(),s=C.getVerticesData(J.f.TangentKind);if(s){k=s.length/4;const c=new Float32Array(3*k);N=0;for(let A=N;A<k;++A){const b=o.k.$j(s,4*A);x(b);const t=o.k.$j(n,3*A);x(t),t.subtractToRef(b,R),c[3*A]=R.x*X,c[3*A+1]=R.y,c[3*A+2]=R.z}const b=A.createBufferView(c,12),t=A.createAccessor(b,"VEC3",5126,k,0);h.push(t),L.attributes.TANGENT=h.length-1}else t.d.Warn(`Morph target tangents for mesh ${b.name} were not exported. Mesh does not have tangents vertex data`)}if(c.hasColors){const n=c.getColors(),s=C.getVerticesData(J.f.ColorKind),X=C.getVertexBuffer(J.f.ColorKind);if(s&&X){const c=X.getSize();k=s.length/c;const b=new Float32Array(k*c);N=0;for(let A=N;A<k;++A)if(3===c){const t=o.k.$j(s,A*c);o.k.$j(n,A*c).subtractToRef(t,R),b[3*A]=R.x,b[3*A+1]=R.y,b[3*A+2]=R.z}else if(4===c){const t=new o.o,h=o.o.$j(s,A*c);o.o.$j(n,A*c).subtractToRef(h,t),b[4*A]=t.x,b[4*A+1]=t.y,b[4*A+2]=t.z,b[4*A+3]=t.w}else t.d.Warn(`Unsupported number of components for color attribute: ${c}`);const C=A.createBufferView(b,4*c),J=A.createAccessor(C,3===c?"VEC3":"VEC4",5126,k,0);h.push(J),L.attributes.COLOR_0=h.length-1}else t.d.Warn(`Morph target colors for mesh ${b.name} were not exported. Mesh does not have colors vertex data`)}return L}var dc=A(11930),rc=A(11864),zc=A(11862),Yc=A(633);class Dc{}Dc.DEFAULT_COLOR=V.d.White(),Dc.DEFAULT_WIDTH_ATTENUATED=1,Dc.DEFAULT_WIDTH=.1;var fc=A(2042),vc=A(11937);class Gc{static ConvertPoints(c,b){if(c.length&&Array.isArray(c)&&"number"===typeof c[0])return[c];if(c.length&&Array.isArray(c[0])&&"number"===typeof c[0][0])return c;if(c.length&&!Array.isArray(c[0])&&c[0]instanceof o.k){const b=[];for(let A=0;A<c.length;A++){const o=c[A];b.push(o.x,o.y,o.z)}return[b]}if(c.length>0&&Array.isArray(c[0])&&c[0].length>0&&c[0][0]instanceof o.k){const b=[],A=c;for(const c of A)b.push(c.flatMap((c=>[c.x,c.y,c.z])));return b}if(c instanceof Float32Array){if(null!==b&&void 0!==b&&b.floatArrayStride){const A=[],o=3*b.floatArrayStride;for(let b=0;b<c.length;b+=o){const t=new Array(o);for(let A=0;A<o;A++)t[A]=c[b+A];A.push(t)}return A}return[Array.from(c)]}if(c.length&&c[0]instanceof Float32Array){const b=[];for(const A of c)b.push(Array.from(A));return b}return[]}static OmitZeroLengthPredicate(c,b,A){const o=[];return b.Xd(c).lengthSquared()>0&&o.push([c,b]),A.Xd(b).lengthSquared()>0&&o.push([b,A]),c.Xd(A).lengthSquared()>0&&o.push([A,c]),0===o.length?null:o}static OmitDuplicatesPredicate(c,b,A,o){const t=[];return Gc._SearchInPoints(c,b,o)||t.push([c,b]),Gc._SearchInPoints(b,A,o)||t.push([b,A]),Gc._SearchInPoints(A,c,o)||t.push([A,c]),0===t.length?null:t}static _SearchInPoints(c,b,A){for(const h of A)for(let A=0;A<h.length;A++){var o,t,n;if(null!==(o=h[A])&&void 0!==o&&o.equals(c))if(null!==(t=h[A+1])&&void 0!==t&&t.equals(b)||null!==(n=h[A-1])&&void 0!==n&&n.equals(b))return!0}return!1}static MeshesToLines(c,b){const A=[];for(let t=0;t<c.length;t++){const n=c[t],h=n.getVerticesData(J.f.PositionKind),s=n._j();if(h&&s)for(let c=0,L=0;c<s.length;c++){const C=3*s[L++],J=3*s[L++],X=3*s[L++],R=new o.k(h[C],h[C+1],h[C+2]),N=new o.k(h[J],h[J+1],h[J+2]),k=new o.k(h[X],h[X+1],h[X+2]);if(b){const o=b(R,N,k,A,c,C,n,t,h,s);if(o)for(const c of o)A.push(c)}else A.push([R,N],[N,k],[k,R])}}return A}static ToVector3Array(c){if(Array.isArray(c[0])){const b=[],A=c;for(const c of A){const A=[];for(let b=0;b<c.length;b+=3)A.push(new o.k(c[b],c[b+1],c[b+2]));b.push(A)}return b}const b=c,A=[];for(let t=0;t<b.length;t+=3)A.push(new o.k(b[t],b[t+1],b[t+2]));return A}static ToNumberArray(c){return c.flatMap((c=>[c.x,c.y,c.z]))}static GetPointsCountInfo(c){const b=new Array(c.length);let A=0;for(let o=c.length;o--;)b[o]=c[o].length/3,A+=b[o];return{total:A,counts:b}}static GetLineLength(c){if(0===c.length)return 0;let b;b="number"===typeof c[0]?Gc.ToVector3Array(c):c;const A=o.f.ak[0];let t=0;for(let o=0;o<b.length-1;o++){const c=b[o];t+=b[o+1].subtractToRef(c,A).length()}return t}static GetLineLengthArray(c){const b=new Float32Array(c.length/3);let A=0;for(let o=0,t=c.length/3-1;o<t;o++){let t=c[3*o+0],n=c[3*o+1],h=c[3*o+2];t-=c[3*o+3],n-=c[3*o+4],h-=c[3*o+5];A+=Math.sqrt(t*t+n*n+h*h),b[o+1]=A}return b}static SegmentizeSegmentByCount(c,b,A){const t=[],n=b.Xd(c),h=o.f.ak[0];h.bk(A);const s=o.f.ak[1];n.divideToRef(h,s);let L=c.clone();t.push(L);for(let o=0;o<A;o++)L=L.clone(),t.push(L.addInPlace(s));return t}static SegmentizeLineBySegmentLength(c,b){const A=c[0]instanceof o.k?Gc.GetLineSegments(c):"number"===typeof c[0]?Gc.GetLineSegments(Gc.ToVector3Array(c)):c,t=[];for(const o of A)if(o.length>b){const c=Gc.SegmentizeSegmentByCount(o.point1,o.point2,Math.ceil(o.length/b));for(const b of c)t.push(b)}else t.push(o.point1),t.push(o.point2);return t}static SegmentizeLineBySegmentCount(c,b){const A="number"===typeof c[0]?Gc.ToVector3Array(c):c,o=Gc.GetLineLength(A)/b;return Gc.SegmentizeLineBySegmentLength(A,o)}static GetLineSegments(c){const b=[];for(let A=0;A<c.length-1;A++){const o=c[A],t=c[A+1],n=t.Xd(o).length();b.push({point1:o,point2:t,length:n})}return b}static GetMinMaxSegmentLength(c){const b=Gc.GetLineSegments(c).sort((c=>c.length));return{min:b[0].length,max:b[b.length-1].length}}static GetPositionOnLineByVisibility(c,b,A){let t=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const n=b*A;let h=0,s=0;const L=c.length;for(let o=0;o<L;o++){if(n<=h+c[o].length){s=o;break}h+=c[o].length}const C=(n-h)/c[s].length;return c[s].point2.subtractToRef(c[s].point1,o.f.ak[0]),o.f.ak[1]=o.f.ak[0].multiplyByFloats(C,C,C),t||o.f.ak[1].addInPlace(c[s].point1),o.f.ak[1].clone()}static GetCircleLinePoints(c,b){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,t=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c,n=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/b;const h=[];for(let s=0;s<=b;s++)h.push(new o.k(Math.cos(s*n)*c,Math.sin(s*n)*t,A));return h}static GetBezierLinePoints(c,b,A,o){return fc.g.CreateQuadraticBezier(c,b,A,o).getPoints().flatMap((c=>[c.x,c.y,c.z]))}static GetArrowCap(c,b,A,o,t){let n=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,h=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[c.clone(),c.add(b.multiplyByFloats(A,A,A))],widths:[o,t,n,h]}}static GetPointsFromText(c,b,A,o){let t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,n=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const h=[],s=(0,vc.c)(c,b,A,o);for(const L of s){for(const c of L.paths){const b=[],A=c.getPoints();for(const c of A)b.push(c.x,c.y,t);h.push(b)}if(n)for(const c of L.holes){const b=[],A=c.getPoints();for(const c of A)b.push(c.x,c.y,t);h.push(b)}}return h}static Color3toRGBAUint8(c){const b=new Uint8Array(4*c.length);for(let A=0,o=0;A<c.length;A++)b[o++]=255*c[A].r,b[o++]=255*c[A].g,b[o++]=255*c[A].b,b[o++]=255;return b}static CreateColorsTexture(c,b,A,o){const t=o.getEngine().getCaps().maxTextureSize??1,n=b.length>t?t:b.length,h=Math.ceil(b.length/t);h>1&&(b=[...b,...Array(n*h-b.length).fill(b[0])]);const s=Gc.Color3toRGBAUint8(b),L=new d.d(s,n,h,k.d.TEXTUREFORMAT_RGBA,o,!1,!0,A);return L.name=c,L}static PrepareEmptyColorsTexture(c){if(!Dc.EmptyColorsTexture){const b=new Uint8Array(4);Dc.EmptyColorsTexture=new d.d(b,1,1,k.d.TEXTUREFORMAT_RGBA,c,!1,!1,d.d.NEAREST_NEAREST),Dc.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Dc.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var c;null===(c=Dc.EmptyColorsTexture)||void 0===c||c.dispose(),Dc.EmptyColorsTexture=null}static BooleanToNumber(c){return c?1:0}}class Pc extends zc.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Oc extends rc.e{isCompatible(c){return!0}constructor(c,b,A){var t;A=A||{color:Dc.DEFAULT_COLOR};const n=new Pc;n.GREASED_LINE_HAS_COLOR=!!A.color&&!A.useColors,n.GREASED_LINE_SIZE_ATTENUATION=A.sizeAttenuation??!1,n.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===A.colorDistributionType,n.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(b??c.va()).useRightHandedSystem,n.GREASED_LINE_CAMERA_FACING=A.cameraFacing??!0,super(c,Oc.GREASED_LINE_MATERIAL_NAME,200,n,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(t=A)||void 0===t?void 0:t.forceGLSL)||Oc.ForceGLSL,this._scene=b??c.va(),this._engine=this._scene.getEngine(),this._cameraFacing=A.cameraFacing??!0,this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.width=A.width?A.width:A.sizeAttenuation?Dc.DEFAULT_WIDTH_ATTENUATED:Dc.DEFAULT_WIDTH,this._sizeAttenuation=A.sizeAttenuation??!1,this.colorMode=A.colorMode??0,this._color=A.color??null,this.useColors=A.useColors??!1,this._colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??d.d.NEAREST_NEAREST,this._colors=A.za??null,this.dashCount=A.dashCount??1,this.resolution=A.resolution??new o.h(this._engine.getRenderWidth(),this._engine.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=Gc.CreateColorsTexture(`${c.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Dc.DEFAULT_COLOR,Gc.PrepareEmptyColorsTexture(this._scene)),this._engine.fk.add((()=>{Gc.DisposeEmptyColorsTexture()}))}getAttributes(c){c.push("grl_offsets"),c.push("grl_widths"),c.push("grl_colorPointers"),c.push("grl_counters"),this._cameraFacing?(c.push("grl_previousAndSide"),c.push("grl_nextAndCounters")):c.push("grl_slopes")}getSamplers(c){c.push("grl_colors")}getActiveTextures(c){this.colorsTexture&&c.push(this.colorsTexture)}getUniforms(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&b.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===c&&b.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:b,vertex:this._cameraFacing&&this._isGLSL(c)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(c)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(c){if(this._cameraFacing){c.nk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||c.nk("viewProjection",this._scene.getTransformMatrix());const b=o.f.Vector4[0];b.x=this._aspect,b.y=this._resolution.x,b.z=this._resolution.y,b.w=this.width,c.updateVector4("grl_aspect_resolution_lineWidth",b)}const b=o.f.Vector4[0];b.x=Gc.BooleanToNumber(this.useDash),b.y=this._dashArray,b.z=this.dashOffset,b.w=this.dashRatio,c.updateVector4("grl_dashOptions",b);const A=o.f.Vector4[1];A.x=this.colorMode,A.y=this.visibility,A.z=this.colorsTexture?this.colorsTexture.getSize().width:0,A.w=Gc.BooleanToNumber(this.useColors),c.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",A),this._color&&c.updateColor3("grl_singleColor",this._color);const t=this.colorsTexture??Dc.EmptyColorsTexture;c.setTexture("grl_colors",t),c.updateFloat2("grl_textureSize",(null===t||void 0===t?void 0:t.getSize().width)??1,(null===t||void 0===t?void 0:t.getSize().height)??1)}prepareDefines(c,b,A){c.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,c.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,c.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,c.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=b.useRightHandedSystem,c.GREASED_LINE_CAMERA_FACING=this._cameraFacing,c.GREASED_LINE_USE_OFFSETS=!!A.offsets}getClassName(){return Oc.GREASED_LINE_MATERIAL_NAME}getCustomCode(c){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(b)?function(c,b){if("vertex"===c){const c={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return b&&(c["!gl_Position\\=viewProjection\\*worldPos;"]="//"),c}return"fragment"===c?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(c,this._cameraFacing):function(c,b){if("vertex"===c){const c={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return b&&(c["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),c}return"fragment"===c?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(c,this._cameraFacing)}dispose(){var c;null===(c=this.colorsTexture)||void 0===c||c.dispose(),super.dispose()}get za(){return this._colors}set za(c){this.setColors(c)}setColors(c){var b;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var n;if(this._colors=c,null!==c&&0!==c.length){if(!A||o)if(this.colorsTexture&&t===c.length&&!o){const b=Gc.Color3toRGBAUint8(c);this.colorsTexture.update(b)}else{var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),this.colorsTexture=Gc.CreateColorsTexture(`${this._material.name}-colors-texture`,c,this.colorsSampling,this._scene)}}else null===(n=this.colorsTexture)||void 0===n||n.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(c){this._dashCount=c,this._dashArray=1/c}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(c){this._sizeAttenuation=c,this.markAllDefinesAsDirty()}get color(){return this._color}set color(c){this.setColor(c)}setColor(c){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==c||null!==this._color&&null===c?(this._color=c,b||this.markAllDefinesAsDirty()):this._color=c}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(c){this._colorsDistributionType=c,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(c){this._aspect=c.x/c.y,this._resolution=c}serialize(){const c=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(b.za=this._colors),this._color&&(b.color=this._color),c.greasedLineMaterialOptions=b,c}parse(c,b,A){var o;super.parse(c,b,A);const t=c.greasedLineMaterialOptions;null===(o=this.colorsTexture)||void 0===o||o.dispose(),t.color&&this.setColor(t.color,!0),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.za&&(this.za=t.za),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),this.za?this.colorsTexture=Gc.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,b):Gc.PrepareEmptyColorsTexture(b),this.markAllDefinesAsDirty()}copyTo(c){var b;const A=c;null===(b=A.colorsTexture)||void 0===b||b.dispose(),this._colors&&(A.colorsTexture=Gc.CreateColorsTexture(`${A._material.name}-colors-texture`,this._colors,A.colorsSampling,this._scene)),A.setColor(this.color,!0),A.colorsDistributionType=this.colorsDistributionType,A.colorsSampling=this.colorsSampling,A.colorMode=this.colorMode,A.useColors=this.useColors,A.visibility=this.visibility,A.useDash=this.useDash,A.dashCount=this.dashCount,A.dashRatio=this.dashRatio,A.dashOffset=this.dashOffset,A.width=this.width,A.sizeAttenuation=this.sizeAttenuation,A.resolution=this.resolution,A.markAllDefinesAsDirty()}_isGLSL(c){return 0===c||this._forceGLSL}}Oc.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Oc.ForceGLSL=!1,(0,Yc.d)(`BABYLON.${Oc.GREASED_LINE_MATERIAL_NAME}`,Oc);var pc=A(760),qc=A(534),Ic=A(11933),Kc=A(618);class Zc extends Ic.e{constructor(c,b,t){const n=b.getEngine(),h=n.isWebGPU&&!(t.forceGLSL||Zc.ForceGLSL),s=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];b.useRightHandedSystem&&s.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const L=["position","grl_widths","grl_offsets","grl_colorPointers"];t.cameraFacing?(s.push("GREASED_LINE_CAMERA_FACING"),L.push("grl_previousAndSide","grl_nextAndCounters")):(L.push("grl_slopes"),L.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(h||C.push("world","viewProjection","view","projection"),super(c,b,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:h?["Scene","Mesh"]:void 0,attributes:L,uniforms:C,samplers:h?[]:["grlColors"],defines:s,extraInitializationsAsync:async()=>{h?await Promise.all([A.e(51).then(A.bind(A,13913)),A.e(59).then(A.bind(A,13922))]):await Promise.all([A.e(54).then(A.bind(A,13930)),A.e(60).then(A.bind(A,13936))])},shaderLanguage:h?1:0}),this._color=V.d.White(),this._colorsDistributionType=0,this._colorsTexture=null,t=t||{color:Dc.DEFAULT_COLOR},this.visibility=t.visibility??1,this.useDash=t.useDash??!1,this.dashRatio=t.dashRatio??.5,this.dashOffset=t.dashOffset??0,this.dashCount=t.dashCount??1,this.width=t.width?t.width:t.sizeAttenuation&&t.cameraFacing?Dc.DEFAULT_WIDTH_ATTENUATED:Dc.DEFAULT_WIDTH,this.sizeAttenuation=t.sizeAttenuation??!1,this.color=t.color??V.d.White(),this.useColors=t.useColors??!1,this.colorsDistributionType=t.colorDistributionType??0,this.colorsSampling=t.colorsSampling??d.d.NEAREST_NEAREST,this.colorMode=t.colorMode??0,this._colors=t.za??null,this._cameraFacing=t.cameraFacing??!0,this.resolution=t.resolution??new o.h(n.getRenderWidth(),n.getRenderHeight()),t.colorsTexture?this.colorsTexture=t.colorsTexture:this._colors?this.colorsTexture=Gc.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,b):(this._color=this._color??Dc.DEFAULT_COLOR,this.colorsTexture=Gc.PrepareEmptyColorsTexture(b)),h){const c=new Kc.c;c.setParameters(),c.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",c)}n.fk.add((()=>{Gc.DisposeEmptyColorsTexture()}))}dispose(){var c;null===(c=this._colorsTexture)||void 0===c||c.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new o.h(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(c){this.setColors(c)}setColors(c){var b;let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const t=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var n;if(this._colors=c,null!==c&&0!==c.length){if(!A||o)if(this._colorsTexture&&t===c.length&&!o){const b=Gc.Color3toRGBAUint8(c);this._colorsTexture.update(b)}else{var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),this.colorsTexture=Gc.CreateColorsTexture(`${this.name}-colors-texture`,c,this.colorsSampling,this.va())}}else null===(n=this._colorsTexture)||void 0===n||n.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(c){this._colorsTexture=c,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(c){this._width=c,this.setFloat("grlWidth",c)}get useColors(){return this._useColors}set useColors(c){this._useColors=c,this.setFloat("grlUseColors",Gc.BooleanToNumber(c))}get colorsSampling(){return this._colorsSampling}set colorsSampling(c){this._colorsSampling=c}get visibility(){return this._visibility}set visibility(c){this._visibility=c,this.setFloat("grlVisibility",c)}get useDash(){return this._useDash}set useDash(c){this._useDash=c,this.setFloat("grlUseDash",Gc.BooleanToNumber(c))}get dashOffset(){return this._dashOffset}set dashOffset(c){this._dashOffset=c,this.setFloat("grlDashOffset",c)}get dashRatio(){return this._dashRatio}set dashRatio(c){this._dashRatio=c,this.setFloat("grlDashRatio",c)}get dashCount(){return this._dashCount}set dashCount(c){this._dashCount=c,this._dashArray=1/c,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(c){this._sizeAttenuation=c,this.setFloat("grlSizeAttenuation",Gc.BooleanToNumber(c))}get color(){return this._color}set color(c){this.setColor(c)}setColor(c){c=c??Dc.DEFAULT_COLOR,this._color=c,this.setColor3("grlColor",c)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(c){this._colorsDistributionType=c,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(c){this._colorMode=c,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(c){this._resolution=c,this.setVector2("grlResolution",c),this.setFloat("grlAspect",c.x/c.y)}serialize(){const c=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(b.za=this._colors),c.greasedLineMaterialOptions=b,c}parse(c,b,A){var o;const t=c.greasedLineMaterialOptions;null===(o=this._colorsTexture)||void 0===o||o.dispose(),t.color&&(this.color=t.color),t.colorDistributionType&&(this.colorsDistributionType=t.colorDistributionType),t.colorsSampling&&(this.colorsSampling=t.colorsSampling),t.colorMode&&(this.colorMode=t.colorMode),t.useColors&&(this.useColors=t.useColors),t.visibility&&(this.visibility=t.visibility),t.useDash&&(this.useDash=t.useDash),t.dashCount&&(this.dashCount=t.dashCount),t.dashRatio&&(this.dashRatio=t.dashRatio),t.dashOffset&&(this.dashOffset=t.dashOffset),t.width&&(this.width=t.width),t.sizeAttenuation&&(this.sizeAttenuation=t.sizeAttenuation),t.resolution&&(this.resolution=t.resolution),t.za?this.colorsTexture=Gc.CreateColorsTexture(`${this.name}-colors-texture`,t.za,this.colorsSampling,this.va()):this.colorsTexture=Gc.PrepareEmptyColorsTexture(b),this._cameraFacing=t.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Hc,Sc,Bc;Zc.ForceGLSL=!1,function(c){c[c.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",c[c.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Hc||(Hc={})),function(c){c[c.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",c[c.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",c[c.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Sc||(Sc={})),function(c){c[c.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",c[c.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",c[c.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",c[c.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",c[c.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Bc||(Bc={}));class Qc extends jc.d{constructor(c,b,A){super(c,b,null,null,!1,!1),this.name=c,this._options=A,this._lazy=!1,this._updatable=!1,this._engine=b.getEngine(),this._lazy=A.lazy??!1,this._updatable=A.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=A.colorPointers??[],this._widths=A.widths??new Array(A.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(c){let b=0;for(const o of this._points)b+=o.length;const A=b/3*2-this._widths.length;for(let o=0;o<A;o++)this._widths.push(c)}updateLazy(){var c,b;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(c=this._options.ribbonOptions)||void 0===c?void 0:c.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(b=this.greasedLineMaterial)||void 0===b||b.updateLazy()}addPoints(c,b){for(const A of c)this._points.push(A);this._lazy||this.setPoints(this._points,b)}dispose(c){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(c,b)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(c){this._uvs=c instanceof Float32Array?c:new Float32Array(c),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(c){this.material instanceof Zc&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===c||void 0===c?void 0:c.length)>0),this._offsets=c,this._offsetsBuffer?this._offsetsBuffer.update(c):this._createOffsetsBuffer(c)}get widths(){return this._widths}set widths(c){this._widths=c,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(c)}get colorPointers(){return this._colorPointers}set colorPointers(c){this._colorPointers=c,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(c)}get greasedLineMaterial(){var c,b;if(this.material&&this.material instanceof Zc)return this.material;const A=null===(c=this.material)||void 0===c||null===(b=c.pluginManager)||void 0===b?void 0:b.getPlugin(Oc.GREASED_LINE_MATERIAL_NAME);return A||void 0}get points(){const c=[];return qc.d.DeepCopy(this._points,c),c}setPoints(c,b){this._points=Gc.ConvertPoints(c,(null===b||void 0===b?void 0:b.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==b&&void 0!==b&&b.colorPointers||this._updateColorPointers(),this._setPoints(this._points,b)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(c){super.serialize(c),c.type=this.getClassName(),c.lineOptions=this._createLineOptions()}_createVertexBuffers(){let c=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new pc.c;return b.xa=this._vertexPositions,b.indices=this._indices,b.Aa=this._uvs,c&&(b.ya=[],pc.c.ComputeNormals(this._vertexPositions,this._indices,b.ya)),b.Ca(this,this._options.updatable),b}_createOffsetsBuffer(c){const b=this._scene.getEngine(),A=new J.d(b,c,this._updatable,3);this.setVerticesBuffer(A.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=A}}class ac{constructor(c,b){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=c,this.wasAddedByNoopNode=b}getIndicesAccessor(c,b,A,o,t){var n,h,s,L;return null===(n=this._indicesAccessorMap.get(c))||void 0===n||null===(h=n.get(b))||void 0===h||null===(s=h.get(A))||void 0===s||null===(L=s.get(o))||void 0===L?void 0:L.get(t)}setIndicesAccessor(c,b,A,o,t,n){let h=this._indicesAccessorMap.get(c);h||(h=new Map,this._indicesAccessorMap.set(c,h));let s=h.get(b);s||(s=new Map,h.set(b,s));let L=s.get(A);L||(L=new Map,s.set(A,L));let C=L.get(o);C||(C=new Map,L.set(o,C)),C.set(t,n)}pushExportedNode(c){this._exportedNodes.has(c)||this._exportedNodes.add(c)}getNodesSet(){return this._exportedNodes}getVertexBufferView(c){return this._vertexBufferViewMap.get(c)}setVertexBufferView(c,b){this._vertexBufferViewMap.set(c,b)}setRemappedBufferView(c,b,A){this._remappedBufferView.set(c,new Map),this._remappedBufferView.get(c).set(b,A)}getRemappedBufferView(c,b){var A;return null===(A=this._remappedBufferView.get(c))||void 0===A?void 0:A.get(b)}getVertexAccessor(c,b,A){var o,t;return null===(o=this._vertexAccessorMap.get(c))||void 0===o||null===(t=o.get(b))||void 0===t?void 0:t.get(A)}setVertexAccessor(c,b,A,o){let t=this._vertexAccessorMap.get(c);t||(t=new Map,this._vertexAccessorMap.set(c,t));let n=t.get(b);n||(n=new Map,t.set(b,n)),n.set(A,o)}hasVertexColorAlpha(c){return this._vertexMapColorAlpha.get(c)||!1}setHasVertexColorAlpha(c,b){return this._vertexMapColorAlpha.set(c,b)}getMesh(c){return this._meshMap.get(c)}setMesh(c,b){this._meshMap.set(c,b)}bindMorphDataToMesh(c,b){const A=this._meshMorphTargetMap.get(c)||[];this._meshMorphTargetMap.set(c,A),-1===A.indexOf(b)&&A.push(b)}getMorphTargetsFromMesh(c){return this._meshMorphTargetMap.get(c)}}class lc{_ApplyExtension(c,b,A,o){if(A>=b.length)return Promise.resolve(c);const t=o(b[A],c);return t?t.then((async c=>c?await this._ApplyExtension(c,b,A+1,o):null)):this._ApplyExtension(c,b,A+1,o)}_ApplyExtensions(c,b){const A=[];for(const o of lc._ExtensionNames)A.push(this._extensions[o]);return this._ApplyExtension(c,A,0,b)}_extensionsPreExportTextureAsync(c,b,A){return this._ApplyExtensions(b,((b,o)=>b.preExportTextureAsync&&b.preExportTextureAsync(c,o,A)))}_extensionsPostExportNodeAsync(c,b,A,o,t){return this._ApplyExtensions(b,((b,n)=>b.postExportNodeAsync&&b.postExportNodeAsync(c,n,A,o,t,this._bufferManager)))}_extensionsPostExportMaterialAsync(c,b,A){return this._ApplyExtensions(b,((b,o)=>b.postExportMaterialAsync&&b.postExportMaterialAsync(c,o,A)))}_extensionsPostExportMaterialAdditionalTextures(c,b,A){const o=[];for(const t of lc._ExtensionNames){const n=this._extensions[t];n.postExportMaterialAdditionalTextures&&o.push(...n.postExportMaterialAdditionalTextures(c,b,A))}return o}_extensionsPostExportTextures(c,b,A){for(const o of lc._ExtensionNames){const t=this._extensions[o];t.postExportTexture&&t.postExportTexture(c,b,A)}}_extensionsPostExportMeshPrimitive(c){for(const b of lc._ExtensionNames){const A=this._extensions[b];A.postExportMeshPrimitive&&A.postExportMeshPrimitive(c,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const c of lc._ExtensionNames){const b=this._extensions[c];b.preGenerateBinaryAsync&&await b.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(c){for(const b of lc._ExtensionNames){const A=this._extensions[b];A.enabled&&c(A)}}_extensionsOnExporting(){this._forEachExtensions((c=>{var b,A,o;c.wasUsed&&((b=this._glTF).extensionsUsed||(b.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(c.name)&&this._glTF.extensionsUsed.push(c.name),c.required&&((A=this._glTF).extensionsRequired||(A.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(c.name)&&this._glTF.extensionsRequired.push(c.name)),(o=this._glTF).extensions||(o.extensions={}),c.onExporting&&c.onExporting())}))}_loadExtensions(){for(const c of lc._ExtensionNames){const b=lc._ExtensionFactories[c](this);this._extensions[c]=b}}constructor(){let c=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.c.LastCreatedScene,b=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${k.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new K(this),this._extensions={},this._bufferManager=new Jc,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!c)throw new Error("No scene available to export");this._babylonScene=c,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:c=>{var b;return null===c||void 0===c||null===(b=c.Lk)||void 0===b?void 0:b.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...b},this._loadExtensions()}dispose(){for(const c in this._extensions){this._extensions[c].dispose()}}get options(){return this._options}static RegisterExtension(c,b){lc.UnregisterExtension(c)&&t.d.Warn(`Extension with the name ${c} already exists`),lc._ExtensionFactories[c]=b,lc._ExtensionNames.push(c)}static UnregisterExtension(c){if(!lc._ExtensionFactories[c])return!1;delete lc._ExtensionFactories[c];const b=lc._ExtensionNames.indexOf(c);return-1!==b&&lc._ExtensionNames.splice(b,1),!0}_generateJSON(c,b,A){const o={byteLength:c};return o.byteLength&&(this._glTF.buffers=[o]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.yd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(o.uri=b+".bin"),A?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(c){const b=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(b.byteLength,c,!0),o=new Blob([b],{type:"application/octet-stream"}),t=c+".gltf",n=c+".bin",h=new C;if(h.files[t]=A,h.files[n]=o,this._imageData)for(const s in this._imageData)h.files[s]=new Blob([this._imageData[s].data],{type:this._imageData[s].mimeType});return h}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(c){const b=c%4;return 0===b?b:4-b}async generateGLBAsync(c){this._shouldUseGlb=!0;const b=await this._generateBinaryAsync();this._extensionsOnExporting();const A=this._generateJSON(b.byteLength),o=c+".glb";let t,n=A.length;if("undefined"!==typeof TextEncoder){t=(new TextEncoder).encode(A),n=t.length}const h=this._getPadding(n),s=this._getPadding(b.byteLength),L=28+n+h+b.byteLength+s,J=new Lc(L);if(J.writeUInt32(1179937895),J.writeUInt32(2),J.writeUInt32(L),J.writeUInt32(n+h),J.writeUInt32(1313821514),t)J.writeTypedArray(t);else{const c="_".charCodeAt(0);for(let b=0;b<n;++b){const o=A.charCodeAt(b);o!=A.codePointAt(b)?J.writeUInt8(c):J.writeUInt8(o)}}for(let C=0;C<h;++C)J.writeUInt8(32);J.writeUInt32(b.byteLength+s),J.writeUInt32(5130562),J.writeTypedArray(b);for(let C=0;C<s;++C)J.writeUInt8(0);const X=new C;return X.files[o]=new Blob([J.getOutputData()],{type:"application/octet-stream"}),X}_setNodeTransformation(c,b,A){if(b.getPivotPoint().equalsWithEpsilon(Q,B.d)||t.d.Warn("Pivot points are not supported in the glTF serializer"),!b.position.equalsWithEpsilon(Q,B.d)){const t=o.f.ak[0].p(b.position);A&&U(t),c.translation=t.hk()}b.ld.equalsWithEpsilon(l,B.d)||(c.scale=b.ld.hk());const n=b.rotationQuaternion||o.e.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);n.equalsWithEpsilon(a,B.d)||(A&&w(n),c.rotation=n.normalize().hk())}_setCameraTransformation(c,b,A){if(!b.position.equalsWithEpsilon(Q,B.d)){const t=o.f.ak[0].p(b.position);A&&U(t),c.translation=t.hk()}const t=b.rotationQuaternion||o.e.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);A&&w(t),this._babylonScene.useRightHandedSystem||m(t),t.equalsWithEpsilon(a,B.d)||(c.rotation=t.hk())}_listAvailableCameras(){for(const c of this._babylonScene.cameras){const b={type:c.mode===Rc.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(c.name&&(b.name=c.name),"perspective"===b.type)b.perspective={aspectRatio:c.getEngine().getAspectRatio(c),yfov:c.fovMode===Rc.c.FOVMODE_VERTICAL_FIXED?c.fov:c.fov*c.getEngine().getAspectRatio(c),znear:c.Vj,zfar:c.maxZ};else if("orthographic"===b.type){const A=c.orthoLeft&&c.orthoRight?.5*(c.orthoRight-c.orthoLeft):.5*c.getEngine().getRenderWidth(),o=c.orthoBottom&&c.orthoTop?.5*(c.orthoTop-c.orthoBottom):.5*c.getEngine().getRenderHeight();b.orthographic={xmag:A,ymag:o,znear:c.Vj,zfar:c.maxZ}}this._camerasMap.set(c,b)}}_exportAndAssignCameras(){const c=Array.from(this._camerasMap.values());for(const b of c){const c=this._nodesCameraMap.get(b);if(void 0!==c){this._cameras.push(b);for(const b of c)b.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const c of this._babylonScene.skeletons){if(c.bones.length<=0)continue;const b={joints:[]};this._skinMap.set(c,b)}}_exportAndAssignSkeletons(){for(const c of this._babylonScene.skeletons){if(c.bones.length<=0)continue;const b=this._skinMap.get(c);if(void 0==b)continue;const A={},o=[];let n=-1;for(let t=0;t<c.bones.length;++t){const b=c.bones[t],o=b.getIndex()??t;-1!==o&&(A[o]=b,o>n&&(n=o))}for(let c=0;c<=n;++c){const n=A[c];o.push(n.getAbsoluteInverseBindMatrix());const h=n.getTransformNode();if(null!==h){const c=this._nodeMap.get(h);h&&null!==c&&void 0!==c?b.joints.push(c):t.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}else t.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}const h=this._nodesSkinMap.get(b);if(b.joints.length>0&&void 0!==h){const c=64*o.length,A=new Float32Array(c/4);o.forEach(((c,b)=>{A.set(c.m,16*b)}));const t=this._bufferManager.createBufferView(A);this._accessors.push(this._bufferManager.createAccessor(t,"MAT4",5126,o.length)),b.inverseBindMatrices=this._accessors.length-1,this._skins.push(b);for(const b of h)b.skin=this._skins.length-1}}}async _exportSceneAsync(){const c={nodes:[]};if(this._babylonScene.metadata){const b=this._options.metadataSelector(this._babylonScene.metadata);b&&(c.extras=b)}const b=new Array,A=new Array,o=new Array;for(const s of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&hc(s,this._babylonScene.useRightHandedSystem)?o.push(...s.getChildren()):this._babylonScene.useRightHandedSystem?b.push(s):A.push(s);this._listAvailableCameras(),this._listAvailableSkeletons();const t=new ac(!0,!1);c.nodes.push(...await this._exportNodesAsync(A,t));const n=new ac(!1,!1);c.nodes.push(...await this._exportNodesAsync(b,n));const h=new ac(!1,!0);c.nodes.push(...await this._exportNodesAsync(o,h)),c.nodes.length&&this._scenes.push(c),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Mc._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,t.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(c){let b=this._shouldExportNodeMap.get(c);return void 0===b&&(b=this._options.shouldExportNode(c),this._shouldExportNodeMap.set(c,b)),b}async _exportNodesAsync(c,b){const A=new Array;this._exportBuffers(c,b);for(const o of c)await this._exportNodeAsync(o,A,b);return A}_collectBuffers(c,b,A,o,t){if(this._shouldExportNode(c)&&c instanceof R.d&&c.mk){const n=c.mk.getVertexBuffers();if(n)for(const o in n){if(!u(o))continue;const h=n[o];t.setHasVertexColorAlpha(h,c.hasVertexAlpha);const s=h._buffer,L=b.get(s)||[];b.set(s,L),-1===L.indexOf(h)&&L.push(h);const C=A.get(h)||[];A.set(h,C),-1===C.indexOf(c)&&C.push(c)}const h=c.morphTargetManager;if(h)for(let b=0;b<h.numTargets;b++){const A=h.getTarget(b),t=o.get(A)||[];o.set(A,t),-1===t.indexOf(c)&&t.push(c)}}for(const n of c.getChildren())this._collectBuffers(n,b,A,o,t)}_exportBuffers(c,b){const A=new Map,o=new Map,t=new Map;for(const s of c)this._collectBuffers(s,A,o,t,b);const n=Array.from(A.keys());for(const s of n){const c=s.getData();if(!c)throw new Error("Buffer data is not available");const t=A.get(s);if(!t)continue;const n=t[0].byteStride;if(t.some((c=>c.byteStride!==n)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const h=Ac(c).slice();for(const b of t){const c=o.get(b),{byteOffset:A,byteStride:t,componentCount:n,type:s,count:L,normalized:C,kind:X}=i(b,c);switch(X){case J.f.NormalKind:case J.f.TangentKind:(0,Z.h)(h,A,t,n,s,L,C,(c=>{const b=Math.sqrt(c[0]*c[0]+c[1]*c[1]+c[2]*c[2]);if(b>0){const A=1/b;c[0]*=A,c[1]*=A,c[2]*=A}}));break;case J.f.ColorKind:{const b=c.filter((c=>c.material instanceof Ec.d||null==c.material)).length;if(0==b)break;if(b!=c.length){H.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}s==J.f.UNSIGNED_BYTE&&H.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const o=new V.d,X=new V.h,R=this._babylonScene.getEngine().useExactSrgbConversions;(0,Z.h)(h,A,t,n,s,L,C,(c=>{3===c.length?(o.Zd(c,0),o.toLinearSpaceToRef(o,R),o.toArray(c,0)):(X.Zd(c,0),X.toLinearSpaceToRef(X,R),X.toArray(c,0))}))}}}if(b.convertToRightHanded){for(const c of t){const b=o.get(c),{byteOffset:A,byteStride:t,componentCount:n,type:s,count:L,normalized:C,kind:X}=i(c,b);switch(X){case J.f.PositionKind:case J.f.NormalKind:case J.f.TangentKind:(0,Z.h)(h,A,t,n,s,L,C,(c=>{c[0]=-c[0]}))}}b.convertedToRightHandedBuffers.set(s,h)}const L=this._bufferManager.createBufferView(h,n);b.setVertexBufferView(s,L);const C=new Map;for(const b of t){const c=o.get(b),{kind:A,totalVertices:t}=i(b,c);switch(A){case J.f.MatricesIndicesKind:case J.f.MatricesIndicesExtraKind:if(b.type==J.f.FLOAT){const c=b.getFloatData(t);null!==c&&C.set(b,c)}}}0!==C.size&&H.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const X=Array.from(C.keys());for(const A of X){const c=C.get(A);if(!c)continue;const o=c.some((c=>c>=256)),t=new(o?Uint16Array:Uint8Array)(c.length);for(let b=0;b<c.length;b++)t[b]=c[b];const n=this._bufferManager.createBufferView(t,4*(o?2:1));b.setRemappedBufferView(s,A,n)}}const h=Array.from(t.keys());for(const s of h){const c=t.get(s);if(!c)continue;const A=Wc(s,c[0],this._bufferManager,this._bufferViews,this._accessors,b.convertToRightHanded);for(const o of c)b.bindMorphDataToMesh(o,A)}}async _exportNodeAsync(c,b,A){let o=this._nodeMap.get(c);if(void 0!==o)return void(b.includes(o)||b.push(o));const t=await this._createNodeAsync(c,A);if(t){o=this._nodes.length,this._nodes.push(t),this._nodeMap.set(c,o),A.pushExportedNode(c),b.push(o);const n={name:"runtime animations",channels:[],samplers:[]},h=[];this._babylonScene.animationGroups.length||(Mc._CreateMorphTargetAnimationFromMorphTargetAnimations(c,n,h,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation),c.animations.length&&Mc._CreateNodeAnimationFromNodeAnimations(c,n,h,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.convertToRightHanded,this._options.shouldExportAnimation)),n.channels.length&&n.samplers.length&&this._animations.push(n),h.forEach((c=>{c.channels.length&&c.samplers.length&&this._animations.push(c)}))}const n=t?[]:b;for(const h of c.getChildren())await this._exportNodeAsync(h,n,A);t&&n.length&&(t.children=n)}async _createNodeAsync(c,b){if(!this._shouldExportNode(c))return null;const A={};if(c.name&&(A.name=c.name),c.metadata){const b=this._options.metadataSelector(c.metadata);b&&(A.extras=b)}if(c instanceof X.e&&(this._setNodeTransformation(A,c,b.convertToRightHanded),c instanceof R.d)){const t=c instanceof N.c?c.sourceMesh:c;if(t.lk&&t.lk.length>0&&(A.mesh=await this._exportMeshAsync(t,b)),c.skeleton){const b=this._skinMap.get(c.skeleton);var o;if(void 0!==b)void 0===this._nodesSkinMap.get(b)&&this._nodesSkinMap.set(b,[]),null===(o=this._nodesSkinMap.get(b))||void 0===o||o.push(A)}}if(c instanceof S.e){const o=this._camerasMap.get(c);if(o){var t;void 0===this._nodesCameraMap.get(o)&&this._nodesCameraMap.set(o,[]),this._setCameraTransformation(A,c,b.convertToRightHanded);const h=c.parent;if(null!==h&&bc(c,h)){const c=this._nodeMap.get(h);if(void 0!==c){var n;const b=this._nodes[c];return cc(A,b),null===(n=this._nodesCameraMap.get(o))||void 0===n||n.push(b),null}}null===(t=this._nodesCameraMap.get(o))||void 0===t||t.push(A)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",A,c,this._nodeMap,b.convertToRightHanded)?A:(H.c.Warn(`Not exporting node ${c.name}`),null)}_exportIndices(c,b,A,o,t,h,s,L,C){let J=c;C.mode=e(h);const X=s!==n.b.CounterClockWiseSideOrientation,R=!L.wasAddedByNoopNode&&X,N=function(c){switch(c){case n.b.TriangleFillMode:case n.b.TriangleStripDrawMode:case n.b.TriangleFanDrawMode:return!0}return!1}(h)&&R;if(N){if(h===n.b.TriangleStripDrawMode||h===n.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=e(h);const s=b?new Uint32Array(o):new Uint16Array(o);if(c)for(let b=0;b+2<o;b+=3)s[b]=c[A+b]+t,s[b+1]=c[A+b+2]+t,s[b+2]=c[A+b+1]+t;else for(let c=0;c+2<o;c+=3)s[c]=c,s[c+1]=c+2,s[c+2]=c+1;J=s}else if(c&&0!==t){const n=b?new Uint32Array(o):new Uint16Array(o);for(let b=0;b<o;b++)n[b]=c[A+b]+t;J=n}if(J){let n=L.getIndicesAccessor(c,A,o,t,N);if(void 0===n){const h=function(c,b,A,o){if(c instanceof Uint16Array||c instanceof Uint32Array)return c;if(c instanceof Int32Array)return new Uint32Array(c.buffer,c.byteOffset,c.length);const t=c.slice(b,b+A);return o?new Uint32Array(t):new Uint16Array(t)}(J,0,o,b),s=this._bufferManager.createBufferView(h),C=b?5125:5123;this._accessors.push(this._bufferManager.createAccessor(s,"SCALAR",C,o,0)),n=this._accessors.length-1,L.setIndicesAccessor(c,A,o,t,N,n)}C.indices=n}}_exportVertexBuffer(c,b,A,o,t,n){const h=c.getKind();if(!u(h))return;if(h.startsWith("uv")&&!this._options.exportUnusedUVs&&(!b||!this._materialNeedsUVsSet.has(b)))return;let s=t.getVertexAccessor(c,A,o);if(void 0===s){const b=t.convertedToRightHandedBuffers.get(c._buffer)||c._buffer.getData(),n=h===J.f.PositionKind?function(c,b,A,o){const{byteOffset:t,byteStride:n,type:h,normalized:s}=b,L=b.getSize(),C=new Array(L).fill(1/0),J=new Array(L).fill(-1/0);return(0,Z.h)(c,t+A*n,n,L,h,o*L,s,(c=>{for(let b=0;b<L;b++)C[b]=Math.min(C[b],c[b]),J[b]=Math.max(J[b],c[b])})),{min:C,max:J}}(b,c,A,o):void 0,L=(h===J.f.MatricesIndicesKind||h===J.f.MatricesIndicesExtraKind)&&c.type===J.f.FLOAT,C=L?J.f.UNSIGNED_BYTE:c.type,X=L?void 0:c.normalized,R=L?t.getRemappedBufferView(c._buffer,c):t.getVertexBufferView(c._buffer),N=c.byteOffset+A*c.byteStride;this._accessors.push(this._bufferManager.createAccessor(R,function(c,b){if(c==J.f.ColorKind)return b?"VEC4":"VEC3";switch(c){case J.f.PositionKind:case J.f.NormalKind:return"VEC3";case J.f.TangentKind:case J.f.MatricesIndicesKind:case J.f.MatricesIndicesExtraKind:case J.f.MatricesWeightsKind:case J.f.MatricesWeightsExtraKind:return"VEC4";case J.f.UVKind:case J.f.UV2Kind:case J.f.UV3Kind:case J.f.UV4Kind:case J.f.UV5Kind:case J.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${c}`)}(h,t.hasVertexColorAlpha(c)),C,o,N,n,X)),s=this._accessors.length-1,t.setVertexAccessor(c,A,o,s)}n.attributes[function(c){switch(c){case J.f.PositionKind:return"POSITION";case J.f.NormalKind:return"NORMAL";case J.f.TangentKind:return"TANGENT";case J.f.ColorKind:return"COLOR_0";case J.f.UVKind:return"TEXCOORD_0";case J.f.UV2Kind:return"TEXCOORD_1";case J.f.UV3Kind:return"TEXCOORD_2";case J.f.UV4Kind:return"TEXCOORD_3";case J.f.UV5Kind:return"TEXCOORD_4";case J.f.UV6Kind:return"TEXCOORD_5";case J.f.MatricesIndicesKind:return"JOINTS_0";case J.f.MatricesIndicesExtraKind:return"JOINTS_1";case J.f.MatricesWeightsKind:return"WEIGHTS_0";case J.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${c}`)}(h)]=s}async _exportMaterialAsync(c,b,A,o){let t=this._materialMap.get(c);if(void 0===t){const o=b&&Object.keys(b).some((c=>c.startsWith("uv")));if((c=c instanceof Nc.b?c.qk[A.materialIndex]:c)instanceof kc.b)t=await this._materialExporter.exportPBRMaterialAsync(c,"image/png",o);else{if(!(c instanceof Ec.d))return void H.c.Warn(`Unsupported material '${c.name}' with type ${c.getClassName()}`);t=await this._materialExporter.exportStandardMaterialAsync(c,"image/png",o)}this._materialMap.set(c,t)}o.material=t}async _exportMeshAsync(c,b){var A;let o=b.getMesh(c);if(void 0!==o)return o;const t={primitives:[]};o=this._meshes.length,this._meshes.push(t),b.setMesh(c,o);const h=c.isUnIndexed?null:c._j(),s=null===(A=c.mk)||void 0===A?void 0:A.getVertexBuffers(),L=b.getMorphTargetsFromMesh(c),C=c instanceof dc.b,J=c instanceof Qc,X=c.lk;if(s&&X&&X.length>0)for(const k of X){const A={attributes:{}},o=k.Ha()||this._babylonScene.defaultMaterial;if(J){var R,N;const b={name:o.name},t=c,n=V.d.White(),h=(null===(R=t.material)||void 0===R?void 0:R.alpha)??1,s=(null===(N=t.greasedLineMaterial)||void 0===N?void 0:N.color)??n;(!s.equalsWithEpsilon(n,B.d)||h<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...s.hk(),h]}),this._materials.push(b),A.material=this._materials.length-1}else if(C){const b={name:o.name},t=c;(!t.color.equalsWithEpsilon(V.d.White(),B.d)||t.alpha<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...t.color.hk(),t.alpha]}),this._materials.push(b),A.material=this._materials.length-1}else await this._exportMaterialAsync(o,s,k,A);const X=C||J?n.b.LineListDrawMode:c.overrideRenderingFillMode??o.fillMode,E=o._getEffectiveOrientation(c);this._exportIndices(h,h?(0,Z.d)(h,k.indexCount,k.indexStart,k.verticesStart):k.verticesCount>65535,h?k.indexStart:k.verticesStart,h?k.indexCount:k.verticesCount,-k.verticesStart,X,E,b,A);for(const c of Object.values(s))this._exportVertexBuffer(c,o,k.verticesStart,k.verticesCount,b,A);if(L){A.targets=[];for(const c of L)A.targets.push(c.attributes)}t.primitives.push(A),this._extensionsPostExportMeshPrimitive(A)}if(L){t.weights=[],t.extras||(t.extras={}),t.extras.targetNames=[];for(const c of L)t.weights.push(c.influence),t.extras.targetNames.push(c.name)}return o}}lc._ExtensionNames=new Array,lc._ExtensionFactories={};class Tc{static async GLTFAsync(c,b,A){A&&A.exportWithoutWaitingForScene||await c.whenReadyAsync();const o=new lc(c,A),t=await o.generateGLTFAsync(b.replace(/\.[^/.]+$/,""));return o.dispose(),t}static async GLBAsync(c,b,A){A&&A.exportWithoutWaitingForScene||await c.whenReadyAsync();const o=new lc(c,A),t=await o.generateGLBAsync(b.replace(/\.[^/.]+$/,""));return o.dispose(),t}}A(507);const ic="EXT_mesh_gpu_instancing";class gc{constructor(c){this.name=ic,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(c,b,A,t,n,h){return await new Promise((c=>{if(b&&A instanceof jc.d&&A.hasThinInstances&&this._exporter){this._wasUsed=!0;const c=o.k.Zero(),t=o.e.Identity(),s=o.k.One(),L=A.thinInstanceGetWorldMatrices(),C=o.f.ak[2],J=o.f.Quaternion[1],X=o.f.ak[3];let R=!1,N=!1,k=!1;const E=new Float32Array(3*A.Hk),V=new Float32Array(4*A.Hk),y=new Float32Array(3*A.Hk);let j=0;for(const b of L)b.decompose(X,J,C),n&&(U(C),w(J)),E.set(C.hk(),3*j),V.set(J.normalize().hk(),4*j),y.set(X.hk(),3*j),R=R||!C.equalsWithEpsilon(c),N=N||!J.equalsWithEpsilon(t),k=k||!X.equalsWithEpsilon(s),j++;const F={attributes:{}};R&&(F.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",A.Hk,h)),N&&(F.attributes.ROTATION=this._buildAccessor(V,"VEC4",A.Hk,h)),k&&(F.attributes.SCALE=this._buildAccessor(y,"VEC3",A.Hk,h)),b.extensions=b.extensions||{},b.extensions[ic]=F}c(b)}))}_buildAccessor(c,b,A,o){const t=o.createBufferView(c),n=o.createAccessor(t,b,5126,A);return this._exporter._accessors.push(n),this._exporter._accessors.length-1}}lc.RegisterExtension(ic,(c=>new gc(c)));var uc=A(11946),ec=A(11950),xc=A(11953),Uc=A(11955);function wc(c){return c===xc.b.PositionKind?"POSITION":c===xc.b.NormalKind?"NORMAL":c===xc.b.ColorKind?"COLOR":c.startsWith(xc.b.UVKind)?"TEX_COORD":"GENERIC"}const mc={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class cb extends uc.e{static get DefaultAvailable(){return(0,uc.j)(cb.DefaultConfiguration)}static get Default(){return cb._Default??(cb._Default=new cb),cb._Default}static ResetDefault(c){cb._Default&&(c||cb._Default.dispose(),cb._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(c,b){return{module:await(b||DracoEncoderModule)({wasmBinary:c})}}_getWorkerContent(){return`${ec.g}(${ec.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:cb.DefaultConfiguration)}async _encodeAsync(c,b,A){const o=A?(0,Uc.e)(mc,A):mc;if(this._workerPoolPromise){const A=await this._workerPoolPromise;return await new Promise(((t,n)=>{A.push(((A,h)=>{const s=c=>{A.removeEventListener("error",s),A.removeEventListener("message",L),n(c),h()},L=c=>{"encodeMeshDone"===c.data.id&&(A.removeEventListener("error",s),A.removeEventListener("message",L),t(c.data.encodedMeshData),h())};A.addEventListener("error",s),A.addEventListener("message",L);const C=[];for(const b of c)C.push(b.data.buffer);b&&C.push(b.buffer),A.postMessage({id:"encodeMesh",attributes:c,indices:b,options:o},C)}))}))}if(this._modulePromise){const A=await this._modulePromise;return(0,ec.g)(A.module,c,b,o)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(c,b){if(0==c.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");c instanceof jc.d&&c.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===b||void 0===b?void 0:b.method)&&(H.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),b.method="MESH_SEQUENTIAL_ENCODING");const A=function(c){let b=c._j(void 0,!0);return!b||b instanceof Uint32Array||b instanceof Uint16Array||(b=((0,Z.d)(b,b.length)?Uint32Array:Uint16Array).from(b)),b}(c),o=function(c,b){const A=[];for(const o of c.getVerticesDataKinds()){if(null!==b&&void 0!==b&&b.includes(o)){if(o===xc.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const t=c.getVertexBuffer(o),n=t.getSize(),h=(0,Z.t)(t.getData(),n,t.type,t.byteOffset,t.byteStride,t.normalized,c.getTotalVertices(),!0);A.push({kind:o,dracoName:wc(o),size:n,data:h})}return A}(c,null===b||void 0===b?void 0:b.excludedAttributes);return await this._encodeAsync(o,A,b)}}cb.DefaultConfiguration={wasmUrl:`${t.d._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${t.d._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${t.d._DefaultCdnUrl}/draco_encoder.js`},cb._Default=null;const bb="KHR_draco_mesh_compression";class Ab{get wasUsed(){return this._wasUsed}constructor(c){this.name=bb,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===c.options.meshCompressionMethod&&cb.DefaultAvailable}dispose(){}postExportMeshPrimitive(c,b,A){if(!this.enabled)return;if(4!==c.mode&&5!==c.mode)return void H.c.Warn("Cannot compress primitive with mode "+c.mode+".");const o=[],t=[];let n=null;if(void 0!==c.indices){const h=A[c.indices],s=b.getBufferView(h);n=b.getData(s).slice(),o.push(s),t.push(h)}const h=[];for(const[J,X]of Object.entries(c.attributes)){const c=A[X],n=b.getBufferView(c),L=g(c.type),C=(0,Z.t)(b.getData(n),L,c.componentType,c.byteOffset||0,n.byteStride||(0,Z.p)(c.componentType)*L,c.normalized||!1,c.count,!0);h.push({kind:J,dracoName:(s=J,"POSITION"===s?"POSITION":"NORMAL"===s?"NORMAL":s.startsWith("COLOR")?"COLOR":s.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:g(c.type),data:C}),o.push(n),t.push(c)}var s;const L={method:c.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=cb.Default._encodeAsync(h,n,L).then((A=>{if(!A)return void H.c.Error("Draco encoding failed for primitive.");const n={bufferView:-1,attributes:A.attributeIds},h=b.createBufferView(A.data);b.setBufferView(n,h);for(const c of o)this._bufferViewsUsed.add(c);for(const c of t)this._accessorsUsed.add(c);c.extensions||(c.extensions={}),c.extensions[bb]=n})).catch((c=>{H.c.Error("Draco encoding failed for primitive: "+c)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(c){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((b=>{c.getPropertiesWithBufferView(b).every((c=>this._accessorsUsed.has(c)))&&c.removeBufferView(b)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}lc.RegisterExtension(bb,(c=>new Ab(c)));var ob=A(11964);const tb="KHR_lights_punctual",nb={name:"",color:[1,1,1],cb:1,range:Number.MAX_VALUE},hb={innerConeAngle:0,outerConeAngle:Math.PI/4},sb=o.k.Backward();class Lb{constructor(c){this.name=tb,this.enabled=!0,this.required=!1,this._exporter=c}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[tb]=this._lights}async postExportNodeAsync(c,b,A,t,n){return await new Promise((h=>{if(!(A instanceof Fc.e))return void h(b);const s=A.getTypeID()==Fc.e.LIGHTTYPEID_POINTLIGHT?"point":A.getTypeID()==Fc.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":A.getTypeID()==Fc.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!s||!(A instanceof ob.d))return H.c.Warn(`${c}: Light ${A.name} is not supported in ${tb}`),void h(b);if(A.falloffType!==Fc.e.FALLOFF_GLTF&&H.c.Warn(`${c}: Light falloff for ${A.name} does not match the ${tb} specification!`),!A.position.equalsToFloats(0,0,0)){const c=o.f.ak[0].p(A.position);n&&U(c),b.translation=c.hk()}if("point"!==s){const c=A.direction.normalizeToRef(o.f.ak[0]);n&&U(c);const t=o.e.FromUnitVectorsToRef(sb,c,o.f.Quaternion[0]);o.e.IsIdentity(t)||(b.rotation=t.hk())}const L={type:s,name:A.name,color:A.fb.hk(),cb:A.cb,range:A.range};if(oc(L,nb),"spot"===s){const c=A;L.spot={innerConeAngle:c.innerAngle/2,outerConeAngle:c.angle/2},oc(L.spot,hb)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(L);const C={ab:this._lights.lights.length-1},J=A.parent;if(J&&bc(A,J)){const c=t.get(J);if(c){const A=this._exporter._nodes[c];return cc(b,A),A.extensions||(A.extensions={}),A.extensions[tb]=C,void h(null)}}b.extensions||(b.extensions={}),b.extensions[tb]=C,h(b)}))}}lc.RegisterExtension(tb,(c=>new Lb(c)));var Cb=A(11857);const Jb="KHR_materials_anisotropy";class Xb{constructor(c){this.name=Jb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof Cb.c&&A.anisotropy.isEnabled&&!A.anisotropy.legacy?(A.anisotropy.texture&&o.push(A.anisotropy.texture),o):[]}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof Cb.c){if(!A.anisotropy.isEnabled||A.anisotropy.legacy)return void c(b);this._wasUsed=!0,b.extensions=b.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(A.anisotropy.texture),t={anisotropyStrength:A.anisotropy.cb,anisotropyRotation:A.anisotropy.angle,anisotropyTexture:o??void 0};null!==t.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(A),b.extensions[Jb]=t}c(b)}))}}lc.RegisterExtension(Jb,(c=>new Xb(c)));const Rb="KHR_materials_clearcoat";class Nb{constructor(c){this.name=Rb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof Cb.c&&A.clearCoat.isEnabled?(A.clearCoat.texture&&o.push(A.clearCoat.texture),!A.clearCoat.useRoughnessFromMainTexture&&A.clearCoat.textureRoughness&&o.push(A.clearCoat.textureRoughness),A.clearCoat.bumpTexture&&o.push(A.clearCoat.bumpTexture),o):[]}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof Cb.c){if(!A.clearCoat.isEnabled)return void c(b);this._wasUsed=!0,b.extensions=b.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture);let n;n=A.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(A.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(A.clearCoat.textureRoughness),A.clearCoat.isTintEnabled&&t.d.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${A.name}`),A.clearCoat.remapF0OnInterfaceChange&&t.d.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${A.name}`);const h=this._exporter._materialExporter.getTextureInfo(A.clearCoat.bumpTexture),s={clearcoatFactor:A.clearCoat.cb,clearcoatTexture:o??void 0,clearcoatRoughnessFactor:A.clearCoat.roughness,clearcoatRoughnessTexture:n??void 0,clearcoatNormalTexture:h??void 0};null===s.clearcoatTexture&&null===s.clearcoatRoughnessTexture&&null===s.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),b.extensions[Rb]=s}c(b)}))}}lc.RegisterExtension(Rb,(c=>new Nb(c)));const kb="KHR_materials_diffuse_transmission";function Eb(c,b){const A=b.subSurface;let o=null;return A.translucencyIntensityTexture?o=A.translucencyIntensityTexture:A.thicknessTexture&&A.useMaskFromThicknessTexture&&(o=A.thicknessTexture),o&&!A.useGltfStyleTextures?(H.c.Warn(`${c}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${b.name}`,1),null):o}class Vb{constructor(c){this.name=kb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];if(A instanceof kc.b&&this._isExtensionEnabled(A)){const b=Eb(c,A);return b&&o.push(b),A.subSurface.translucencyColorTexture&&o.push(A.subSurface.translucencyColorTexture),o}return o}_isExtensionEnabled(c){if(c.unlit)return!1;const b=c.subSurface;return!!b.isTranslucencyEnabled&&(!c.unlit&&!b.useAlbedoToTintTranslucency&&b.useGltfStyleTextures&&1===b.volumeIndexOfRefraction&&0===b.minimumThickness&&0===b.maximumThickness)}postExportMaterialAsync(c,b,A){return new Promise((o=>{if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const o=A.subSurface,t=Eb(c,A),n=0==o.translucencyIntensity?void 0:o.translucencyIntensity,h=this._exporter._materialExporter.getTextureInfo(t)??void 0,s=!o.translucencyColor||o.translucencyColor.equalsFloats(1,1,1)?void 0:o.translucencyColor.hk(),L=this._exporter._materialExporter.getTextureInfo(o.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:n,diffuseTransmissionTexture:h,diffuseTransmissionColorFactor:s,diffuseTransmissionColorTexture:L};(h||L)&&this._exporter._materialNeedsUVsSet.add(A),b.extensions=b.extensions||{},b.extensions[kb]=C}o(b)}))}}lc.RegisterExtension(kb,(c=>new Vb(c)));const yb="KHR_materials_dispersion";class jb{constructor(){this.name=yb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(c){if(c.unlit)return!1;const b=c.subSurface;return!(!b.isRefractionEnabled&&!b.isDispersionEnabled)}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const c={dispersion:A.subSurface.dispersion};b.extensions=b.extensions||{},b.extensions[yb]=c}c(b)}))}}lc.RegisterExtension(yb,(()=>new jb));const Fb="KHR_materials_emissive_strength";class Mb{constructor(){this.name=Fb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(c,b,A){return await new Promise((c=>{if(!(A instanceof kc.b))return c(b);const o=A.emissiveColor.hk(),t=Math.max(...o);if(t>1){this._wasUsed=!0,b.extensions||(b.extensions={});const c={emissiveStrength:t},o=A.emissiveColor.scale(1/c.emissiveStrength);b.emissiveFactor=o.hk(),b.extensions[Fb]=c}return c(b)}))}}lc.RegisterExtension(Fb,(c=>new Mb));const Wb="KHR_materials_ior";class db{constructor(){this.name=Wb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(c){return!c.unlit&&(void 0!=c.indexOfRefraction&&1.5!=c.indexOfRefraction)}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const c={ior:A.indexOfRefraction};b.extensions=b.extensions||{},b.extensions[Wb]=c}c(b)}))}}lc.RegisterExtension(Wb,(c=>new db));const rb="KHR_materials_iridescence";class zb{constructor(c){this.name=rb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof Cb.c&&A.iridescence.isEnabled?(A.iridescence.texture&&o.push(A.iridescence.texture),A.iridescence.thicknessTexture&&A.iridescence.thicknessTexture!==A.iridescence.texture&&o.push(A.iridescence.thicknessTexture),o):[]}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof Cb.c){if(!A.iridescence.isEnabled)return void c(b);this._wasUsed=!0,b.extensions=b.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(A.iridescence.texture),t=this._exporter._materialExporter.getTextureInfo(A.iridescence.thicknessTexture),n={iridescenceFactor:A.iridescence.cb,iridescenceIor:A.iridescence.indexOfRefraction,iridescenceThicknessMinimum:A.iridescence.minimumThickness,iridescenceThicknessMaximum:A.iridescence.maximumThickness,iridescenceTexture:o??void 0,iridescenceThicknessTexture:t??void 0};null===n.iridescenceTexture&&null===n.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(A),b.extensions[rb]=n}c(b)}))}}lc.RegisterExtension(rb,(c=>new zb(c)));const Yb="KHR_materials_sheen";class Db{constructor(c){this.name=Yb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){return A instanceof kc.b&&A.sheen.isEnabled&&A.sheen.texture?[A.sheen.texture]:[]}async postExportMaterialAsync(c,b,A){return await new Promise((c=>{if(A instanceof kc.b){if(!A.sheen.isEnabled)return void c(b);this._wasUsed=!0,null==b.extensions&&(b.extensions={});const o={sheenColorFactor:A.sheen.color.hk(),sheenRoughnessFactor:A.sheen.roughness??0};null===o.sheenColorTexture&&null===o.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(A),A.sheen.texture&&(o.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),A.sheen.textureRoughness&&!A.sheen.useRoughnessFromMainTexture?o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.textureRoughness)??void 0:A.sheen.texture&&A.sheen.useRoughnessFromMainTexture&&(o.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(A.sheen.texture)??void 0),b.extensions[Yb]=o}c(b)}))}}lc.RegisterExtension(Yb,(c=>new Db(c)));const fb="KHR_materials_specular";class vb{constructor(c){this.name=fb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof kc.b&&this._isExtensionEnabled(A)?(A.metallicReflectanceTexture&&o.push(A.metallicReflectanceTexture),A.reflectanceTexture&&o.push(A.reflectanceTexture),o):o}_isExtensionEnabled(c){return!c.unlit&&(void 0!=c.metallicF0Factor&&1!=c.metallicF0Factor||void 0!=c.metallicReflectanceColor&&!c.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(c))}_hasTexturesExtension(c){return null!=c.metallicReflectanceTexture||null!=c.reflectanceTexture}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0,b.extensions=b.extensions||{};const c=this._exporter._materialExporter.getTextureInfo(A.metallicReflectanceTexture)??void 0,o=this._exporter._materialExporter.getTextureInfo(A.reflectanceTexture)??void 0,t={specularFactor:1==A.metallicF0Factor?void 0:A.metallicF0Factor,specularTexture:c,specularColorFactor:A.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:A.metallicReflectanceColor.hk(),specularColorTexture:o};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),b.extensions[fb]=t}c(b)}))}}lc.RegisterExtension(fb,(c=>new vb(c)));const Gb="KHR_materials_transmission";class Pb{constructor(c){this.name=Gb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof kc.b&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&o.push(A.subSurface.thicknessTexture),o):o}_isExtensionEnabled(c){if(c.unlit)return!1;const b=c.subSurface;return b.isRefractionEnabled&&void 0!=b.refractionIntensity&&0!=b.refractionIntensity||this._hasTexturesExtension(c)}_hasTexturesExtension(c){return null!=c.subSurface.refractionIntensityTexture}async postExportMaterialAsync(c,b,A){if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const o=A.subSurface,t={transmissionFactor:0===o.refractionIntensity?void 0:o.refractionIntensity};if(this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),o.refractionIntensityTexture)if(o.useGltfStyleTextures){const c=await this._exporter._materialExporter.exportTextureAsync(o.refractionIntensityTexture,"image/png");c&&(t.transmissionTexture=c)}else H.c.Warn(`${c}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);b.extensions||(b.extensions={}),b.extensions[Gb]=t}return b}}lc.RegisterExtension(Gb,(c=>new Pb(c)));const Ob="KHR_materials_unlit";class pb{constructor(){this.name=Ob,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(c,b,A){return new Promise((c=>{let o=!1;A instanceof kc.b?o=A.unlit:A instanceof Ec.d&&(o=A.disableLighting),o&&(this._wasUsed=!0,null==b.extensions&&(b.extensions={}),b.extensions[Ob]={}),c(b)}))}}lc.RegisterExtension(Ob,(()=>new pb));const qb="KHR_materials_volume";class Ib{constructor(c){this.name=qb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof kc.b&&this._isExtensionEnabled(A)?(A.subSurface.thicknessTexture&&o.push(A.subSurface.thicknessTexture),o):o}_isExtensionEnabled(c){if(c.unlit)return!1;const b=c.subSurface;return!(!b.isRefractionEnabled&&!b.isTranslucencyEnabled)&&(void 0!=b.maximumThickness&&0!=b.maximumThickness||void 0!=b.tintColorAtDistance&&b.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=b.tintColor&&b.tintColor!=V.d.White()||this._hasTexturesExtension(c))}_hasTexturesExtension(c){return null!=c.subSurface.thicknessTexture}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof kc.b&&this._isExtensionEnabled(A)){this._wasUsed=!0;const c=A.subSurface,o={thicknessFactor:0==c.maximumThickness?void 0:c.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(c.thicknessTexture)??void 0,attenuationDistance:c.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:c.tintColorAtDistance,attenuationColor:c.tintColor.equalsFloats(1,1,1)?void 0:c.tintColor.hk()};this._hasTexturesExtension(A)&&this._exporter._materialNeedsUVsSet.add(A),b.extensions=b.extensions||{},b.extensions[qb]=o}c(b)}))}}lc.RegisterExtension(qb,(c=>new Ib(c)));const Kb="EXT_materials_diffuse_roughness";class Zb{constructor(c){this.name=Kb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=c}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(c,b,A){const o=[];return A instanceof Cb.c&&A._baseDiffuseRoughness?(A._baseDiffuseRoughnessTexture&&o.push(A._baseDiffuseRoughnessTexture),o):[]}postExportMaterialAsync(c,b,A){return new Promise((c=>{if(A instanceof Cb.c){if(!A._baseDiffuseRoughness)return void c(b);this._wasUsed=!0,b.extensions=b.extensions||{};const o=this._exporter._materialExporter.getTextureInfo(A._baseDiffuseRoughnessTexture),t={diffuseRoughnessFactor:A._baseDiffuseRoughness,diffuseRoughnessTexture:o??void 0};null!==t.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(A),b.extensions[Kb]=t}c(b)}))}}lc.RegisterExtension(Kb,(c=>new Zb(c)));const Hb="KHR_texture_transform";class Sb{constructor(){this.name=Hb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(c,b,A){if(A.va()||t.d.Warn(`${c}: /*@__KEY__*/"scene" is not defined for Babylon texture ${A.name}!`),(0!==A.uAng||0!==A.vAng)&&(t.d.Warn(`${c}: Texture ${A.name} with rotation in the u or v axis is not supported in glTF.`),0!==A.uRotationCenter||0!==A.vRotationCenter))return;const o={};let n=!1;if(0===A.uOffset&&0===A.vOffset||(o.offset=[A.uOffset,A.vOffset],n=!0),1===A.uScale&&1===A.vScale||(o.scale=[A.uScale,A.vScale],n=!0),0!==A.wAng){if(0!==A.uRotationCenter||0!==A.vRotationCenter){if(A.homogeneousRotationInUVTransform&&A.uScale!==A.vScale)return void t.d.Warn(`${c}: Texture ${A.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hb}.`);t.d.Warn(`${c}: Texture ${A.name} with non-origin rotation center will be exported using an adjusted offset with ${Hb}.`),o.offset=function(c){const{uOffset:b,vOffset:A,uRotationCenter:o,vRotationCenter:t,uScale:n,vScale:h,wAng:s}=c,L=Math.cos(s),C=Math.sin(s),J=o*n,X=t*h;return[b+(J*(1-L)+X*C),A+(X*(1-L)-J*C)]}(A)}o.rotation=-A.wAng,n=!0}0!==A.coordinatesIndex&&(o.texCoord=A.coordinatesIndex,n=!0),n&&(this._wasUsed=!0,b.extensions||(b.extensions={}),b.extensions[Hb]=o)}}lc.RegisterExtension(Hb,(()=>new Sb));class Bb{static CreateSTL(c){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",t=arguments.length>3&&void 0!==arguments[3]&&arguments[3],n=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],h=arguments.length>5&&void 0!==arguments[5]&&arguments[5],s=arguments.length>6&&void 0!==arguments[6]&&arguments[6],L=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(c,b,A){const t=[3*c[A],3*c[A+1],3*c[A+2]],n=[new o.k(b[t[0]],b[t[0]+2],b[t[0]+1]),new o.k(b[t[1]],b[t[1]+2],b[t[1]+1]),new o.k(b[t[2]],b[t[2]+2],b[t[2]+1])],h=n[0].Xd(n[1]),s=n[2].Xd(n[1]);return{v:n,n:o.k.Cross(s,h).normalize()}},X=function(c,b,A,o){return b=R(c,b,A.x,o),b=R(c,b,A.y,o),R(c,b,A.z,o)},R=function(c,b,A,o){return c.setFloat32(b,A,o),b+4},k=function(c){if(s){let b=c;c instanceof N.c&&(b=c.sourceMesh);const A=b.getVerticesData(J.f.PositionKind,!0,!0);if(!A)return[];const t=o.k.Zero();let n;for(n=0;n<A.length;n+=3)o.k.TransformCoordinatesFromFloatsToRef(A[n],A[n+1],A[n+2],c.Zj(!0),t).toArray(A,n);return A}return c.getVerticesData(J.f.PositionKind)||[]};s&&(h=!0);let E="",V=0,y=0;if(t){for(let A=0;A<c.length;A++){const b=c[A]._j();V+=b?b.length/3:0}const b=new ArrayBuffer(84+50*V);E=new DataView(b),y+=80,E.setUint32(y,V,n),y+=4}else L||(E="solid stlmesh\r\n");for(let o=0;o<c.length;o++){const b=c[o];!t&&L&&(E+="solid "+b.name+"\r\n"),!h&&b instanceof jc.d&&b.bakeCurrentTransformIntoVertices();const A=k(b),s=b._j()||[];for(let c=0;c<s.length;c+=3){const b=C(s,A,c);t?(y=X(E,y,b.n,n),y=X(E,y,b.v[0],n),y=X(E,y,b.v[1],n),y=X(E,y,b.v[2],n),y+=2):(E+="\tfacet normal "+b.n.x+" "+b.n.y+" "+b.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+b.v[0].x+" "+b.v[0].y+" "+b.v[0].z+"\r\n",E+="\t\t\tvertex "+b.v[1].x+" "+b.v[1].y+" "+b.v[1].z+"\r\n",E+="\t\t\tvertex "+b.v[2].x+" "+b.v[2].y+" "+b.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!t&&L&&(E+="endsolid "+name+"\r\n")}if(t||L||(E+="endsolid stlmesh"),b){const c=document.createElement("a"),b=new Blob([E],{type:"application/octet-stream"});c.href=window.URL.createObjectURL(b),c.download=A+".stl",c.click()}return E}}function Qb(c,b){let A=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const o=[];for(let t=0;t<c.length/A;t++){const n=c[t*A],h=c[t*A+1],s=c[t*A+2];o.push(`(${n.toPrecision(b.precision)}, ${h.toPrecision(b.precision)}, ${s.toPrecision(b.precision)})`)}return o.join(", ")}function ab(c,b){const A=[];for(let o=0;o<c.length/2;o++){const t=c[2*o],n=c[2*o+1];A.push(`(${t.toPrecision(b.precision)}, ${(1-n).toPrecision(b.precision)})`)}return A.join(", ")}function lb(c,b){const A=c.getVerticesData(J.f.PositionKind),o=c.getVerticesData(J.f.NormalKind);if(A&&o)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(c){var b;const A=null!==(b=c._j())&&void 0!==b&&b.length?c.getTotalIndices():c.getTotalVertices();return Array(A/3).fill(3).join(", ")}(c)}]\n\t\tint[] faceVertexIndices = [${function(c){const b=c._j(),A=[];if(null!==b)for(let o=0;o<b.length;o++)A.push(b[o]);else{const b=c.getTotalVertices();for(let c=0;c<b;c++)A.push(c)}return A.join(", ")}(c)}]\n\t\tnormal3f[] normals = [${Qb(o,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Qb(A,b)}]\n        ${function(c,b){let A="";for(let t=0;t<4;t++){const o=t>0?t:"",n=c.getVerticesData(J.f.UVKind+(o?o+1:""));n&&(A+=`\n\t\ttexCoord2f[] primvars:st${o} = [${ab(n,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const o=c.getVerticesData(J.f.ColorKind);return o&&(A+=`\n\tcolor3f[] primvars:displayColor = [${Qb(o,b,o.length/c.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),A}(c,b)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Tb(c,b){return`\n        def "Geometry"\n        {\n        ${lb(c,b)}\n        }\n        `}function ib(c){let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return b+=c,fflate.strToU8(b)}function gb(c){const b=c.m;return`( ${ub(b,0)}, ${ub(b,4)}, ${ub(b,8)}, ${ub(b,12)} )`}function ub(c,b){return`(${c[b+0]}, ${c[b+1]}, ${c[b+2]}, ${c[b+3]})`}function eb(c){const b="Object_"+c.uniqueId,A=function(c){const b=c.getWorldMatrix().clone(),A=c.va().useRightHandedSystem;if(!A){let o=c.parent;for(;o;){if(hc(o,A)){b.multiplyToRef(o.getWorldMatrix().invert(),b);break}o=o.parent}}return b.determinant()<0&&t.d.Warn(`Exporting mesh ${c.name} with negative scale. Result may look incorrect in destination engine.`),b}(c),o=gb(A);return`def Xform "${b}" (\n\tprepend references = @./geometries/Geometry_${c.mk.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${o}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${c.material.uniqueId}>\n}\n\n`}function xb(c){switch(c){case r.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case r.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case r.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ub(c){return`(${c.x}, ${c.y})`}function wb(c){return`(${c.r}, ${c.g}, ${c.b})`}function mb(c,b,A,t,n,h){const s=c.getInternalTexture().uniqueId+"_"+c.invertY;n[s]=c;const L=c.coordinatesIndex>0?"st"+c.coordinatesIndex:"st",C=new o.h(c.uScale,c.vScale),J=new o.h(c.uOffset,c.vOffset),X=c.wAng,R=Math.sin(X),N=Math.cos(X);return J.y=1-J.y-C.y,J.x+=R*C.x,J.y+=(1-N)*C.y,`\n    def Shader "PrimvarReader_${A}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${L}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${A}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${b.uniqueId}/PrimvarReader_${A}.outputs:result>\n        float inputs:rotation = ${(X*(180/Math.PI)).toFixed(h.precision)}\n        float2 inputs:scale = ${Ub(C)}\n        float2 inputs:translation = ${Ub(J)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${c.uniqueId}_${A}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${s}.png@\n        float2 inputs:st.connect = </Materials/Material_${b.uniqueId}/Transform2d_${A}.outputs:result>\n        ${t?"float4 inputs:scale = "+function(c){return`(${c.r}, ${c.g}, ${c.b}, 1.0)`}(t):""}\n        token inputs:sourceColorSpace = "${c.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${xb(c.wrapU)}"\n        token inputs:wrapT = "${xb(c.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${b.needAlphaBlending()?"float outputs:a":""}\n    }`}function cA(c,b,A){const o="\t\t\t",t=[],n=[],{diffuseMap:h,fb:s,alphaCutOff:L,emissiveMap:C,emissive:J,normalMap:X,roughnessMap:R,roughnessChannel:N,roughness:k,metalnessMap:E,metalnessChannel:y,metalness:j,aoMap:F,aoMapChannel:M,aoMapIntensity:W,alphaMap:d,ior:r,clearCoatEnabled:z,clearCoat:Y,clearCoatMap:D,clearCoatRoughness:f,clearCoatRoughnessMap:v}=function(c){const b={diffuseMap:null,fb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return c instanceof Ec.d?{...b,diffuseMap:c.diffuseTexture,fb:c.diffuseColor,alphaCutOff:c.alphaCutOff,emissiveMap:c.emissiveTexture,emissive:c.emissiveColor,roughness:1,alphaMap:c.opacityTexture}:c instanceof Cb.c?{...b,diffuseMap:c._albedoTexture,fb:c._albedoColor,alphaCutOff:c._alphaCutOff,emissiveMap:c._emissiveTexture,emissive:c._emissiveColor,normalMap:c._bumpTexture,roughnessMap:c._metallicTexture,roughnessChannel:c._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:c._roughness??1,metalnessMap:c._metallicTexture,metalnessChannel:c._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:c._metallic??0,aoMap:c._ambientTexture,aoMapChannel:c._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:c._ambientTextureStrength,alphaMap:c._opacityTexture,ior:c.subSurface.indexOfRefraction,clearCoatEnabled:c.clearCoat.isEnabled,clearCoat:c.clearCoat.cb,clearCoatMap:c.clearCoat.texture,clearCoatRoughness:c.clearCoat.roughness,clearCoatRoughnessMap:c.clearCoat.useRoughnessFromMainTexture?c.clearCoat.texture:c.clearCoat.textureRoughness}:b}(c);return null!==h?(t.push(`${o}color3f inputs:diffuseColor.connect = </Materials/Material_${c.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:rgb>`),c.needAlphaBlending()?t.push(`${o}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:a>`):c.needAlphaTesting()&&(t.push(`${o}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${h.uniqueId}_diffuse.outputs:a>`),t.push(`${o}float inputs:opacityThreshold = ${L}`)),n.push(mb(h,c,"diffuse",s,b,A))):t.push(`${o}color3f inputs:diffuseColor = ${wb(s||V.d.White())}`),null!==C?(t.push(`${o}color3f inputs:emissiveColor.connect = </Materials/Material_${c.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),n.push(mb(C,c,"emissive",J,b,A))):J&&J.toLuminance()>0&&t.push(`${o}color3f inputs:emissiveColor = ${wb(J)}`),null!==X&&(t.push(`${o}normal3f inputs:normal.connect = </Materials/Material_${c.uniqueId}/Texture_${X.uniqueId}_normal.outputs:rgb>`),n.push(mb(X,c,"ik",null,b,A))),null!==F&&(t.push(`${o}float inputs:occlusion.connect = </Materials/Material_${c.uniqueId}/Texture_${F.uniqueId}_occlusion.outputs:${M}>`),n.push(mb(F,c,"occlusion",new V.d(W,W,W),b,A))),null!==R?(t.push(`${o}float inputs:roughness.connect = </Materials/Material_${c.uniqueId}/Texture_${R.uniqueId}_roughness.outputs:${N}>`),n.push(mb(R,c,"roughness",new V.d(k,k,k),b,A))):t.push(`${o}float inputs:roughness = ${k}`),null!==E?(t.push(`${o}float inputs:metallic.connect = </Materials/Material_${c.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${y}>`),n.push(mb(E,c,"metallic",new V.d(j,j,j),b,A))):t.push(`${o}float inputs:metallic = ${j}`),null!==d?(t.push(`${o}float inputs:opacity.connect = </Materials/Material_${c.uniqueId}/Texture_${d.uniqueId}_opacity.outputs:r>`),t.push(`${o}float inputs:opacityThreshold = 0.0001`),n.push(mb(d,c,"opacity",null,b,A))):t.push(`${o}float inputs:opacity = ${c.alpha}`),z&&(null!==D?(t.push(`${o}float inputs:clearcoat.connect = </Materials/Material_${c.uniqueId}/Texture_${D.uniqueId}_clearcoat.outputs:r>`),n.push(mb(D,c,"clearcoat",new V.d(Y,Y,Y),b,A))):t.push(`${o}float inputs:clearcoat = ${Y}`),null!==v?(t.push(`${o}float inputs:clearcoatRoughness.connect = </Materials/Material_${c.uniqueId}/Texture_${v.uniqueId}_clearcoatRoughness.outputs:g>`),n.push(mb(v,c,"clearcoatRoughness",new V.d(f,f,f),b,A))):t.push(`${o}float inputs:clearcoatRoughness = ${f}`)),t.push(`${o}float inputs:ior = ${r}`),`\n\tdef Material "Material_${c.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${t.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${c.uniqueId}/PreviewSurface.outputs:surface>\n\n${n.join("\n")}\n\n\t}\n`}async function bA(c,b,A){const n={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...b};"undefined"===typeof fflate&&await t.d.LoadScriptAsync(n.fflateUrl);const h={};h[n.modelFileName]=null;let s='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';s+=function(c){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===c.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${c.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${c.planeAnchoringAlignment}"`:""}\n            `}(n);const L={};for(const o of c.meshes){if(0===o.getTotalVertices())continue;const c=o,b=c.mk,C=c.material;if(!C||!b||A&&!A(c))continue;if(-1!==["gb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const A="geometries/Geometry_"+b.uniqueId+".usda";if(!(A in h)){const c=Tb(b,n);h[A]=ib(c)}C.uniqueId in L||(L[C.uniqueId]=C),s+=eb(c)}else t.d.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}c.activeCamera&&n.exportCamera&&(s+=function(c,b){const A="Camera_"+c.uniqueId,t=gb(o.b.RotationY(Math.PI).multiply(c.getWorldMatrix()));if(c.mode===r.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${c.Vj.toPrecision(b.precision)}, ${c.maxZ.toPrecision(b.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(c.orthoLeft||1)+Math.abs(c.orthoRight||1))).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(c.orthoTop||1)+Math.abs(c.orthoBottom||1))).toPrecision(b.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const o=c.getEngine().getAspectRatio(c),n=b.cameraSensorWidth||35;return`def Camera "${A}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${t}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${c.Vj.toPrecision(b.precision)}, ${c.maxZ.toPrecision(b.precision)})\n\t\t\tfloat focalLength = ${(n/(2*Math.tan(.5*c.fov))).toPrecision(b.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(n*o).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(n/o).toPrecision(b.precision)}            \n\t\t}\n\t\n\t`}}(c.activeCamera,n)),s+="\n            }\n        }\n    }";const C={};s+=function(c,b,A){const o=[];for(const t in c){const n=c[t];o.push(cA(n,b,A))}return`\n    def "Materials"\n{\n${o.join("")}\n}\n\n`}(L,C,n),h[n.modelFileName]=fflate.strToU8(s);for(const o in C){const c=C[o],b=c.getSize(),A=await c.readPixels();if(!A)throw new Error("Texture data is not available");const t=await z.DumpTools.DumpDataAsync(b.width,b.height,A,"image/png",void 0,!1,!0);h[`textures/Texture_${o}.png`]=new Uint8Array(t).slice()}let J=0;for(const o in h){const c=h[o];if(!c)continue;J+=34+o.length;const b=63&J;if(4!==b){const A=new Uint8Array(64-b);h[o]=[c,{extra:{12345:A}}]}J=c.length}return fflate.zipSync(h,{level:0})}}}]);