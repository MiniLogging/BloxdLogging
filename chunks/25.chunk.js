"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{12792:(Z,c,L)=>{var k=L(11139),N=L(11052),R=L(11081),G=L(11155),V=L(11110),p=L(11144);V.c.prototype._partialLoadFile=function(Z,c,L,k){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(Z,(Z=>{L[c]=Z,L._internalCount++,6===L._internalCount&&k(L)}),void 0,void 0,!0,((Z,c)=>{N&&Z&&N(Z.status+" "+Z.statusText,c)}))},V.c.prototype._cascadeLoadFiles=function(Z,c,L){let k=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const N=[];N._internalCount=0;for(let R=0;R<6;R++)this._partialLoadFile(L[R],R,N,c,k)},V.c.prototype._cascadeLoadImgs=function(Z,c,L,k){let N=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,R=arguments.length>5?arguments[5]:void 0;const G=[];G._internalCount=0;for(let V=0;V<6;V++)this._partialLoadImg(k[V],V,G,Z,c,L,N,R)},V.c.prototype._partialLoadImg=function(Z,c,L,k,N,V){let p=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,J=arguments.length>7?arguments[7]:void 0;const z=(0,G.d)();(0,R.s)(Z,(Z=>{L[c]=Z,L._internalCount++,k&&k.removePendingData(z),6===L._internalCount&&V&&V(N,L)}),((Z,c)=>{k&&k.removePendingData(z),p&&p(Z,c)}),k?k.offlineProvider:null,J),k&&k.addPendingData(z)},V.c.prototype.createCubeTextureBase=function(Z,c,L,R){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,V=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,J=arguments.length>6?arguments[6]:void 0,z=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,i=arguments.length>8&&void 0!==arguments[8]&&arguments[8],t=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,E=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,x=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,q=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,O=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,w=arguments.length>14&&void 0!==arguments[14]&&arguments[14],M=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const P=x||new k.e(this,7);P.isCube=!0,P.url=Z,P.generateMipMaps=!R,P._lodGenerationScale=t,P._lodGenerationOffset=E,P._useSRGBBuffer=!!w&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!R),P!==x&&(P.label=Z.substring(0,60)),this._doNotHandleContextLost||(P._extension=z,P._files=L,P._buffer=M);const j=Z;this._transformTextureUrl&&!x&&(Z=this._transformTextureUrl(Z));const o=z??function(Z){const c=Z.split("?")[0],L=c.lastIndexOf(".");return L>-1?c.substring(L).toLowerCase():""}(Z),u=(0,p.e)(o),X=(Z,c)=>{P.dispose(),V?V(Z,c):Z&&N.e.Warn(Z)},h=(k,V)=>{Z===j?k&&X(k.status+" "+k.statusText,V):(N.e.Warn(`Failed to load ${Z}, falling back to the ${j}`),this.createCubeTextureBase(j,c,L,!!R,G,X,J,z,i,t,E,P,q,O,w,M))};if(u)u.then((k=>{const N=Z=>{q&&q(P,Z),k.loadCubeData(Z,P,i,G,((Z,c)=>{X(Z,c)}))};M?N(M):L&&6===L.length?k.supportCascades?this._cascadeLoadFiles(c,(Z=>N(Z.map((Z=>new Uint8Array(Z))))),L,X):X("Textures type does not support cascades."):this._loadFile(Z,(Z=>N(new Uint8Array(Z))),void 0,void 0,!0,h)}));else{if(!L||0===L.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(c,P,((Z,c)=>{O&&O(Z,c)}),L,X)}return this._internalTexturesCache.push(P),P}},13574:(Z,c,L)=>{L.r(c),L.d(c,{_DDSTextureLoader:()=>R});var k=L(11461),N=L(13578);class R{constructor(){this.supportCascades=!0}loadCubeData(Z,c,L,R){const G=c.getEngine();let V,p=!1,J=1e3;if(Array.isArray(Z))for(let k=0;k<Z.length;k++){const L=Z[k];V=N.DDSTools.GetDDSInfo(L),c.width=V.width,c.height=V.height,p=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&c.generateMipMaps,G._unpackFlipY(V.isCompressed),N.DDSTools.UploadDDSLevels(G,c,L,V,p,6,-1,k),V.isFourCC||1!==V.mipmapCount?J=V.mipmapCount-1:G.generateMipMapsForCubemap(c)}else{const R=Z;V=N.DDSTools.GetDDSInfo(R),c.width=V.width,c.height=V.height,L&&(V.sphericalPolynomial=new k.d),p=(V.isRGB||V.isLuminance||V.mipmapCount>1)&&c.generateMipMaps,G._unpackFlipY(V.isCompressed),N.DDSTools.UploadDDSLevels(G,c,R,V,p,6),V.isFourCC||1!==V.mipmapCount?J=V.mipmapCount-1:G.generateMipMapsForCubemap(c,!1)}G._setCubeMapTextureParams(c,p,J),c.isReady=!0,c.onLoadedObservable.notifyObservers(c),c.onLoadedObservable.clear(),R&&R({isDDS:!0,width:c.width,info:V,data:Z,texture:c})}loadData(Z,c,L){const k=N.DDSTools.GetDDSInfo(Z),R=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&c.generateMipMaps&&Math.max(k.width,k.height)>>k.mipmapCount-1===1;L(k.width,k.height,R,k.isFourCC,(()=>{N.DDSTools.UploadDDSLevels(c.getEngine(),c,Z,k,R,1)}))}}},13578:(Z,c,L)=>{L.d(c,{DDSTools:()=>x});var k=L(11032),N=L(11052),R=L(11683),G=L(11503);L(12792);const V=131072,p=131072;function J(Z){return Z.charCodeAt(0)+(Z.charCodeAt(1)<<8)+(Z.charCodeAt(2)<<16)+(Z.charCodeAt(3)<<24)}const z=J("DXT1"),i=J("DXT3"),t=J("DXT5"),E=J("DX10");class x{static GetDDSInfo(Z){const c=new Int32Array(Z.buffer,Z.byteOffset,31),L=new Int32Array(Z.buffer,Z.byteOffset,35);let k=1;c[2]&V&&(k=Math.max(1,c[7]));const N=c[21],R=N===E?L[32]:0;let G=0;switch(N){case 113:G=2;break;case 116:G=1;break;case E:if(10===R){G=2;break}if(2===R){G=1;break}}return{width:c[4],height:c[3],mipmapCount:k,isFourCC:4===(4&c[20]),isRGB:64===(64&c[20]),isLuminance:(c[20]&p)===p,isCube:512===(512&c[28]),isCompressed:N===z||N===i||N===t,dxgiFormat:R,textureType:G}}static _GetHalfFloatAsFloatRGBAArrayBuffer(Z,c,L,k,N,R){const V=new Float32Array(k),p=new Uint16Array(N,L);let J=0;for(let z=0;z<c;z++)for(let c=0;c<Z;c++){const L=4*(c+z*Z);V[J]=(0,G.g)(p[L]),V[J+1]=(0,G.g)(p[L+1]),V[J+2]=(0,G.g)(p[L+2]),x.StoreLODInAlphaChannel?V[J+3]=R:V[J+3]=(0,G.g)(p[L+3]),J+=4}return V}static _GetHalfFloatRGBAArrayBuffer(Z,c,L,k,N,R){if(x.StoreLODInAlphaChannel){const V=new Uint16Array(k),p=new Uint16Array(N,L);let J=0;for(let L=0;L<c;L++)for(let c=0;c<Z;c++){const k=4*(c+L*Z);V[J]=p[k],V[J+1]=p[k+1],V[J+2]=p[k+2],V[J+3]=(0,G.q)(R),J+=4}return V}return new Uint16Array(N,L,k)}static _GetFloatRGBAArrayBuffer(Z,c,L,k,N,R){if(x.StoreLODInAlphaChannel){const G=new Float32Array(k),V=new Float32Array(N,L);let p=0;for(let L=0;L<c;L++)for(let c=0;c<Z;c++){const k=4*(c+L*Z);G[p]=V[k],G[p+1]=V[k+1],G[p+2]=V[k+2],G[p+3]=R,p+=4}return G}return new Float32Array(N,L,k)}static _GetFloatAsHalfFloatRGBAArrayBuffer(Z,c,L,k,N,R){const V=new Uint16Array(k),p=new Float32Array(N,L);let J=0;for(let z=0;z<c;z++)for(let c=0;c<Z;c++)V[J]=(0,G.q)(p[J]),V[J+1]=(0,G.q)(p[J+1]),V[J+2]=(0,G.q)(p[J+2]),x.StoreLODInAlphaChannel?V[J+3]=(0,G.q)(R):V[J+3]=(0,G.q)(p[J+3]),J+=4;return V}static _GetFloatAsUIntRGBAArrayBuffer(Z,c,L,N,R,G){const V=new Uint8Array(N),p=new Float32Array(R,L);let J=0;for(let z=0;z<c;z++)for(let c=0;c<Z;c++){const L=4*(c+z*Z);V[J]=255*(0,k.Clamp)(p[L]),V[J+1]=255*(0,k.Clamp)(p[L+1]),V[J+2]=255*(0,k.Clamp)(p[L+2]),x.StoreLODInAlphaChannel?V[J+3]=G:V[J+3]=255*(0,k.Clamp)(p[L+3]),J+=4}return V}static _GetHalfFloatAsUIntRGBAArrayBuffer(Z,c,L,N,R,V){const p=new Uint8Array(N),J=new Uint16Array(R,L);let z=0;for(let i=0;i<c;i++)for(let c=0;c<Z;c++){const L=4*(c+i*Z);p[z]=255*(0,k.Clamp)((0,G.g)(J[L])),p[z+1]=255*(0,k.Clamp)((0,G.g)(J[L+1])),p[z+2]=255*(0,k.Clamp)((0,G.g)(J[L+2])),x.StoreLODInAlphaChannel?p[z+3]=V:p[z+3]=255*(0,k.Clamp)((0,G.g)(J[L+3])),z+=4}return p}static _GetRGBAArrayBuffer(Z,c,L,k,N,R,G,V,p){const J=new Uint8Array(k),z=new Uint8Array(N,L);let i=0;for(let t=0;t<c;t++)for(let c=0;c<Z;c++){const L=4*(c+t*Z);J[i]=z[L+R],J[i+1]=z[L+G],J[i+2]=z[L+V],J[i+3]=z[L+p],i+=4}return J}static _ExtractLongWordOrder(Z){return 0===Z||255===Z||-16777216===Z?0:1+x._ExtractLongWordOrder(Z>>8)}static _GetRGBArrayBuffer(Z,c,L,k,N,R,G,V){const p=new Uint8Array(k),J=new Uint8Array(N,L);let z=0;for(let i=0;i<c;i++)for(let c=0;c<Z;c++){const L=3*(c+i*Z);p[z]=J[L+R],p[z+1]=J[L+G],p[z+2]=J[L+V],z+=3}return p}static _GetLuminanceArrayBuffer(Z,c,L,k,N){const R=new Uint8Array(k),G=new Uint8Array(N,L);let V=0;for(let p=0;p<c;p++)for(let c=0;c<Z;c++){const L=c+p*Z;R[V]=G[L],V++}return R}static UploadDDSLevels(Z,c,L,k,G,p){let J=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,q=arguments.length>7?arguments[7]:void 0,O=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],w=null;k.sphericalPolynomial&&(w=[]);const M=!!Z.getCaps().s3tc;c.generateMipMaps=G;const P=new Int32Array(L.buffer,L.byteOffset,31);let j,o,u,X,h,B,D,e=0,H=0,l=1;if(542327876!==P[0])return void N.e.Error("Invalid magic number in DDS header");if(!k.isFourCC&&!k.isRGB&&!k.isLuminance)return void N.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(k.isCompressed&&!M)return void N.e.Error("Compressed textures are not supported on this platform.");let W=P[22];X=P[1]+4;let T=!1;if(k.isFourCC)switch(j=P[21],j){case z:l=8,H=33777;break;case i:l=16,H=33778;break;case t:l=16,H=33779;break;case 113:T=!0,W=64;break;case 116:T=!0,W=128;break;case E:{X+=20;let Z=!1;switch(k.dxgiFormat){case 10:T=!0,W=64,Z=!0;break;case 2:T=!0,W=128,Z=!0;break;case 88:k.isRGB=!0,k.isFourCC=!1,W=32,Z=!0}if(Z)break}default:return void N.e.Error(["Unsupported FourCC code:",(I=j,String.fromCharCode(255&I,I>>8&255,I>>16&255,I>>24&255))])}var I;const d=x._ExtractLongWordOrder(P[23]),Q=x._ExtractLongWordOrder(P[24]),r=x._ExtractLongWordOrder(P[25]),f=x._ExtractLongWordOrder(P[26]);T&&(H=Z._getRGBABufferInternalSizedFormat(k.textureType)),B=1,P[2]&V&&!1!==G&&(B=Math.max(1,P[7]));const S=q||0,s=Z.getCaps();for(let N=S;N<p;N++){for(o=P[4],u=P[3],D=0;D<B;++D){if(-1===J||J===D){const R=-1===J?D:0;if(!k.isCompressed&&k.isFourCC){c.format=5,e=o*u*4;let k=null;if(Z._badOS||Z._badDesktopOS||!s.textureHalfFloat&&!s.textureFloat)128===W?(k=x._GetFloatAsUIntRGBAArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,R),w&&0==R&&w.push(x._GetFloatRGBAArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,R))):64===W&&(k=x._GetHalfFloatAsUIntRGBAArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,R),w&&0==R&&w.push(x._GetHalfFloatAsFloatRGBAArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,R))),c.type=0;else{const Z=s.textureFloat&&(O&&s.textureFloatLinearFiltering||!O),N=s.textureHalfFloat&&(O&&s.textureHalfFloatLinearFiltering||!O),G=(128===W||64===W&&!N)&&Z?1:(64===W||128===W&&!Z)&&N?2:0;let V,p=null;if(128===W)switch(G){case 1:V=x._GetFloatRGBAArrayBuffer,p=null;break;case 2:V=x._GetFloatAsHalfFloatRGBAArrayBuffer,p=x._GetFloatRGBAArrayBuffer;break;case 0:V=x._GetFloatAsUIntRGBAArrayBuffer,p=x._GetFloatRGBAArrayBuffer}else switch(G){case 1:V=x._GetHalfFloatAsFloatRGBAArrayBuffer,p=null;break;case 2:V=x._GetHalfFloatRGBAArrayBuffer,p=x._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:V=x._GetHalfFloatAsUIntRGBAArrayBuffer,p=x._GetHalfFloatAsFloatRGBAArrayBuffer}c.type=G,k=V(o,u,L.byteOffset+X,e,L.buffer,R),w&&0==R&&w.push(p?p(o,u,L.byteOffset+X,e,L.buffer,R):k)}k&&Z._uploadDataToTextureDirectly(c,k,N,R)}else if(k.isRGB)c.type=0,24===W?(c.format=4,e=o*u*3,h=x._GetRGBArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,d,Q,r),Z._uploadDataToTextureDirectly(c,h,N,R)):(c.format=5,e=o*u*4,h=x._GetRGBAArrayBuffer(o,u,L.byteOffset+X,e,L.buffer,d,Q,r,f),Z._uploadDataToTextureDirectly(c,h,N,R));else if(k.isLuminance){const k=Z._getUnpackAlignement(),G=o;e=Math.floor((o+k-1)/k)*k*(u-1)+G,h=x._GetLuminanceArrayBuffer(o,u,L.byteOffset+X,e,L.buffer),c.format=1,c.type=0,Z._uploadDataToTextureDirectly(c,h,N,R)}else e=Math.max(4,o)/4*Math.max(4,u)/4*l,h=new Uint8Array(L.buffer,L.byteOffset+X,e),c.type=0,Z._uploadCompressedDataToTextureDirectly(c,H,o,u,h,N,R)}X+=W?o*u*(W/8):e,o*=.5,u*=.5,o=Math.max(1,o),u=Math.max(1,u)}if(void 0!==q)break}w&&w.length>0?k.sphericalPolynomial=R.d.ConvertCubeMapToSphericalPolynomial({size:P[4],right:w[0],left:w[1],up:w[2],down:w[3],front:w[4],back:w[5],format:5,type:1,gammaSpace:!1}):k.sphericalPolynomial=void 0}}x.StoreLODInAlphaChannel=!1}}]);