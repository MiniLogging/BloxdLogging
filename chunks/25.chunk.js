"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{12677:(x,O,Q)=>{var X=Q(10994),Z=Q(10905),n=Q(10934),V=Q(11015),o=Q(10970),l=Q(11005);o.c.prototype._partialLoadFile=function(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(x,(x=>{Q[O]=x,Q._internalCount++,6===Q._internalCount&&X(Q)}),void 0,void 0,!0,((x,O)=>{Z&&x&&Z(x.status+" "+x.statusText,O)}))},o.c.prototype._cascadeLoadFiles=function(x,O,Q){let X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const Z=[];Z._internalCount=0;for(let n=0;n<6;n++)this._partialLoadFile(Q[n],n,Z,O,X)},o.c.prototype._cascadeLoadImgs=function(x,O,Q,X){let Z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,n=arguments.length>5?arguments[5]:void 0;const V=[];V._internalCount=0;for(let o=0;o<6;o++)this._partialLoadImg(X[o],o,V,x,O,Q,Z,n)},o.c.prototype._partialLoadImg=function(x,O,Q,X,Z,o){let l=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,C=arguments.length>7?arguments[7]:void 0;const U=(0,V.e)();(0,n.u)(x,(x=>{Q[O]=x,Q._internalCount++,X&&X.removePendingData(U),6===Q._internalCount&&o&&o(Z,Q)}),((x,O)=>{X&&X.removePendingData(U),l&&l(x,O)}),X?X.offlineProvider:null,C),X&&X.addPendingData(U)},o.c.prototype.createCubeTextureBase=function(x,O,Q,n){let V=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,C=arguments.length>6?arguments[6]:void 0,U=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,L=arguments.length>8&&void 0!==arguments[8]&&arguments[8],h=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,N=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,a=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,K=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,M=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,Y=arguments.length>14&&void 0!==arguments[14]&&arguments[14],g=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const v=a||new X.e(this,7);v.isCube=!0,v.url=x,v.generateMipMaps=!n,v._lodGenerationScale=h,v._lodGenerationOffset=N,v._useSRGBBuffer=!!Y&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!n),v!==a&&(v.label=x.substring(0,60)),this._doNotHandleContextLost||(v._extension=U,v._files=Q,v._buffer=g);const R=x;this._transformTextureUrl&&!a&&(x=this._transformTextureUrl(x));const s=U??function(x){const O=x.split("?")[0],Q=O.lastIndexOf(".");return Q>-1?O.substring(Q).toLowerCase():""}(x),q=(0,l.e)(s),G=(x,O)=>{v.dispose(),o?o(x,O):x&&Z.e.Warn(x)},k=(X,o)=>{x===R?X&&G(X.status+" "+X.statusText,o):(Z.e.Warn(`Failed to load ${x}, falling back to the ${R}`),this.createCubeTextureBase(R,O,Q,!!n,V,G,C,U,L,h,N,v,K,M,Y,g))};if(q)q.then((X=>{const Z=x=>{K&&K(v,x),X.loadCubeData(x,v,L,V,((x,O)=>{G(x,O)}))};g?Z(g):Q&&6===Q.length?X.supportCascades?this._cascadeLoadFiles(O,(x=>Z(x.map((x=>new Uint8Array(x))))),Q,G):G("Textures type does not support cascades."):this._loadFile(x,(x=>Z(new Uint8Array(x))),void 0,void 0,!0,k)}));else{if(!Q||0===Q.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(O,v,((x,O)=>{M&&M(x,O)}),Q,G)}return this._internalTexturesCache.push(v),v}},13440:(x,O,Q)=>{Q.r(O),Q.d(O,{_DDSTextureLoader:()=>n});var X=Q(11298),Z=Q(13447);class n{constructor(){this.supportCascades=!0}loadCubeData(x,O,Q,n){const V=O.getEngine();let o,l=!1,C=1e3;if(Array.isArray(x))for(let X=0;X<x.length;X++){const Q=x[X];o=Z.DDSTools.GetDDSInfo(Q),O.width=o.width,O.height=o.height,l=(o.isRGB||o.isLuminance||o.mipmapCount>1)&&O.generateMipMaps,V._unpackFlipY(o.isCompressed),Z.DDSTools.UploadDDSLevels(V,O,Q,o,l,6,-1,X),o.isFourCC||1!==o.mipmapCount?C=o.mipmapCount-1:V.generateMipMapsForCubemap(O)}else{const n=x;o=Z.DDSTools.GetDDSInfo(n),O.width=o.width,O.height=o.height,Q&&(o.sphericalPolynomial=new X.d),l=(o.isRGB||o.isLuminance||o.mipmapCount>1)&&O.generateMipMaps,V._unpackFlipY(o.isCompressed),Z.DDSTools.UploadDDSLevels(V,O,n,o,l,6),o.isFourCC||1!==o.mipmapCount?C=o.mipmapCount-1:V.generateMipMapsForCubemap(O,!1)}V._setCubeMapTextureParams(O,l,C),O.isReady=!0,O.onLoadedObservable.notifyObservers(O),O.onLoadedObservable.clear(),n&&n({isDDS:!0,width:O.width,info:o,data:x,texture:O})}loadData(x,O,Q){const X=Z.DDSTools.GetDDSInfo(x),n=(X.isRGB||X.isLuminance||X.mipmapCount>1)&&O.generateMipMaps&&Math.max(X.width,X.height)>>X.mipmapCount-1===1;Q(X.width,X.height,n,X.isFourCC,(()=>{Z.DDSTools.UploadDDSLevels(O.getEngine(),O,x,X,n,1)}))}}},13447:(x,O,Q)=>{Q.d(O,{DDSTools:()=>a});var X=Q(10889),Z=Q(10905),n=Q(11504),V=Q(11332);Q(12677);const o=131072,l=131072;function C(x){return x.charCodeAt(0)+(x.charCodeAt(1)<<8)+(x.charCodeAt(2)<<16)+(x.charCodeAt(3)<<24)}const U=C("DXT1"),L=C("DXT3"),h=C("DXT5"),N=C("DX10");class a{static GetDDSInfo(x){const O=new Int32Array(x.buffer,x.byteOffset,31),Q=new Int32Array(x.buffer,x.byteOffset,35);let X=1;O[2]&o&&(X=Math.max(1,O[7]));const Z=O[21],n=Z===N?Q[32]:0;let V=0;switch(Z){case 113:V=2;break;case 116:V=1;break;case N:if(10===n){V=2;break}if(2===n){V=1;break}}return{width:O[4],height:O[3],mipmapCount:X,isFourCC:4===(4&O[20]),isRGB:64===(64&O[20]),isLuminance:(O[20]&l)===l,isCube:512===(512&O[28]),isCompressed:Z===U||Z===L||Z===h,dxgiFormat:n,textureType:V}}static _GetHalfFloatAsFloatRGBAArrayBuffer(x,O,Q,X,Z,n){const o=new Float32Array(X),l=new Uint16Array(Z,Q);let C=0;for(let U=0;U<O;U++)for(let O=0;O<x;O++){const Q=4*(O+U*x);o[C]=(0,V.f)(l[Q]),o[C+1]=(0,V.f)(l[Q+1]),o[C+2]=(0,V.f)(l[Q+2]),a.StoreLODInAlphaChannel?o[C+3]=n:o[C+3]=(0,V.f)(l[Q+3]),C+=4}return o}static _GetHalfFloatRGBAArrayBuffer(x,O,Q,X,Z,n){if(a.StoreLODInAlphaChannel){const o=new Uint16Array(X),l=new Uint16Array(Z,Q);let C=0;for(let Q=0;Q<O;Q++)for(let O=0;O<x;O++){const X=4*(O+Q*x);o[C]=l[X],o[C+1]=l[X+1],o[C+2]=l[X+2],o[C+3]=(0,V.m)(n),C+=4}return o}return new Uint16Array(Z,Q,X)}static _GetFloatRGBAArrayBuffer(x,O,Q,X,Z,n){if(a.StoreLODInAlphaChannel){const V=new Float32Array(X),o=new Float32Array(Z,Q);let l=0;for(let Q=0;Q<O;Q++)for(let O=0;O<x;O++){const X=4*(O+Q*x);V[l]=o[X],V[l+1]=o[X+1],V[l+2]=o[X+2],V[l+3]=n,l+=4}return V}return new Float32Array(Z,Q,X)}static _GetFloatAsHalfFloatRGBAArrayBuffer(x,O,Q,X,Z,n){const o=new Uint16Array(X),l=new Float32Array(Z,Q);let C=0;for(let U=0;U<O;U++)for(let O=0;O<x;O++)o[C]=(0,V.m)(l[C]),o[C+1]=(0,V.m)(l[C+1]),o[C+2]=(0,V.m)(l[C+2]),a.StoreLODInAlphaChannel?o[C+3]=(0,V.m)(n):o[C+3]=(0,V.m)(l[C+3]),C+=4;return o}static _GetFloatAsUIntRGBAArrayBuffer(x,O,Q,Z,n,V){const o=new Uint8Array(Z),l=new Float32Array(n,Q);let C=0;for(let U=0;U<O;U++)for(let O=0;O<x;O++){const Q=4*(O+U*x);o[C]=255*(0,X.Clamp)(l[Q]),o[C+1]=255*(0,X.Clamp)(l[Q+1]),o[C+2]=255*(0,X.Clamp)(l[Q+2]),a.StoreLODInAlphaChannel?o[C+3]=V:o[C+3]=255*(0,X.Clamp)(l[Q+3]),C+=4}return o}static _GetHalfFloatAsUIntRGBAArrayBuffer(x,O,Q,Z,n,o){const l=new Uint8Array(Z),C=new Uint16Array(n,Q);let U=0;for(let L=0;L<O;L++)for(let O=0;O<x;O++){const Q=4*(O+L*x);l[U]=255*(0,X.Clamp)((0,V.f)(C[Q])),l[U+1]=255*(0,X.Clamp)((0,V.f)(C[Q+1])),l[U+2]=255*(0,X.Clamp)((0,V.f)(C[Q+2])),a.StoreLODInAlphaChannel?l[U+3]=o:l[U+3]=255*(0,X.Clamp)((0,V.f)(C[Q+3])),U+=4}return l}static _GetRGBAArrayBuffer(x,O,Q,X,Z,n,V,o,l){const C=new Uint8Array(X),U=new Uint8Array(Z,Q);let L=0;for(let h=0;h<O;h++)for(let O=0;O<x;O++){const Q=4*(O+h*x);C[L]=U[Q+n],C[L+1]=U[Q+V],C[L+2]=U[Q+o],C[L+3]=U[Q+l],L+=4}return C}static _ExtractLongWordOrder(x){return 0===x||255===x||-16777216===x?0:1+a._ExtractLongWordOrder(x>>8)}static _GetRGBArrayBuffer(x,O,Q,X,Z,n,V,o){const l=new Uint8Array(X),C=new Uint8Array(Z,Q);let U=0;for(let L=0;L<O;L++)for(let O=0;O<x;O++){const Q=3*(O+L*x);l[U]=C[Q+n],l[U+1]=C[Q+V],l[U+2]=C[Q+o],U+=3}return l}static _GetLuminanceArrayBuffer(x,O,Q,X,Z){const n=new Uint8Array(X),V=new Uint8Array(Z,Q);let o=0;for(let l=0;l<O;l++)for(let O=0;O<x;O++){const Q=O+l*x;n[o]=V[Q],o++}return n}static UploadDDSLevels(x,O,Q,X,V,l){let C=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,K=arguments.length>7?arguments[7]:void 0,M=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],Y=null;X.sphericalPolynomial&&(Y=[]);const g=!!x.getCaps().s3tc;O.generateMipMaps=V;const v=new Int32Array(Q.buffer,Q.byteOffset,31);let R,s,q,G,k,J,t,c=0,d=0,u=1;if(542327876!==v[0])return void Z.e.Error("Invalid magic number in DDS header");if(!X.isFourCC&&!X.isRGB&&!X.isLuminance)return void Z.e.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(X.isCompressed&&!g)return void Z.e.Error("Compressed textures are not supported on this platform.");let A=v[22];G=v[1]+4;let f=!1;if(X.isFourCC)switch(R=v[21],R){case U:u=8,d=33777;break;case L:u=16,d=33778;break;case h:u=16,d=33779;break;case 113:f=!0,A=64;break;case 116:f=!0,A=128;break;case N:{G+=20;let x=!1;switch(X.dxgiFormat){case 10:f=!0,A=64,x=!0;break;case 2:f=!0,A=128,x=!0;break;case 88:X.isRGB=!0,X.isFourCC=!1,A=32,x=!0}if(x)break}default:return void Z.e.Error(["Unsupported FourCC code:",(E=R,String.fromCharCode(255&E,E>>8&255,E>>16&255,E>>24&255))])}var E;const z=a._ExtractLongWordOrder(v[23]),F=a._ExtractLongWordOrder(v[24]),b=a._ExtractLongWordOrder(v[25]),D=a._ExtractLongWordOrder(v[26]);f&&(d=x._getRGBABufferInternalSizedFormat(X.textureType)),J=1,v[2]&o&&!1!==V&&(J=Math.max(1,v[7]));const W=K||0,y=x.getCaps();for(let Z=W;Z<l;Z++){for(s=v[4],q=v[3],t=0;t<J;++t){if(-1===C||C===t){const n=-1===C?t:0;if(!X.isCompressed&&X.isFourCC){O.format=5,c=s*q*4;let X=null;if(x._badOS||x._badDesktopOS||!y.textureHalfFloat&&!y.textureFloat)128===A?(X=a._GetFloatAsUIntRGBAArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,n),Y&&0==n&&Y.push(a._GetFloatRGBAArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,n))):64===A&&(X=a._GetHalfFloatAsUIntRGBAArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,n),Y&&0==n&&Y.push(a._GetHalfFloatAsFloatRGBAArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,n))),O.type=0;else{const x=y.textureFloat&&(M&&y.textureFloatLinearFiltering||!M),Z=y.textureHalfFloat&&(M&&y.textureHalfFloatLinearFiltering||!M),V=(128===A||64===A&&!Z)&&x?1:(64===A||128===A&&!x)&&Z?2:0;let o,l=null;if(128===A)switch(V){case 1:o=a._GetFloatRGBAArrayBuffer,l=null;break;case 2:o=a._GetFloatAsHalfFloatRGBAArrayBuffer,l=a._GetFloatRGBAArrayBuffer;break;case 0:o=a._GetFloatAsUIntRGBAArrayBuffer,l=a._GetFloatRGBAArrayBuffer}else switch(V){case 1:o=a._GetHalfFloatAsFloatRGBAArrayBuffer,l=null;break;case 2:o=a._GetHalfFloatRGBAArrayBuffer,l=a._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:o=a._GetHalfFloatAsUIntRGBAArrayBuffer,l=a._GetHalfFloatAsFloatRGBAArrayBuffer}O.type=V,X=o(s,q,Q.byteOffset+G,c,Q.buffer,n),Y&&0==n&&Y.push(l?l(s,q,Q.byteOffset+G,c,Q.buffer,n):X)}X&&x._uploadDataToTextureDirectly(O,X,Z,n)}else if(X.isRGB)O.type=0,24===A?(O.format=4,c=s*q*3,k=a._GetRGBArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,z,F,b),x._uploadDataToTextureDirectly(O,k,Z,n)):(O.format=5,c=s*q*4,k=a._GetRGBAArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer,z,F,b,D),x._uploadDataToTextureDirectly(O,k,Z,n));else if(X.isLuminance){const X=x._getUnpackAlignement(),V=s;c=Math.floor((s+X-1)/X)*X*(q-1)+V,k=a._GetLuminanceArrayBuffer(s,q,Q.byteOffset+G,c,Q.buffer),O.format=1,O.type=0,x._uploadDataToTextureDirectly(O,k,Z,n)}else c=Math.max(4,s)/4*Math.max(4,q)/4*u,k=new Uint8Array(Q.buffer,Q.byteOffset+G,c),O.type=0,x._uploadCompressedDataToTextureDirectly(O,d,s,q,k,Z,n)}G+=A?s*q*(A/8):c,s*=.5,q*=.5,s=Math.max(1,s),q=Math.max(1,q)}if(void 0!==K)break}Y&&Y.length>0?X.sphericalPolynomial=n.d.ConvertCubeMapToSphericalPolynomial({size:v[4],right:Y[0],left:Y[1],up:Y[2],down:Y[3],front:Y[4],back:Y[5],format:5,type:1,gammaSpace:!1}):X.sphericalPolynomial=void 0}}a.StoreLODInAlphaChannel=!1}}]);