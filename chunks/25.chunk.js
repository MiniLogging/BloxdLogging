"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{12872:(V,I,m)=>{var C=m(11161),l=m(11085),s=m(11102),F=m(11188),k=m(11136),j=m(11177);k.b.prototype._partialLoadFile=function(V,I,m,C){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(V,(V=>{m[I]=V,m._internalCount++,6===m._internalCount&&C(m)}),void 0,void 0,!0,((V,I)=>{l&&V&&l(V.status+" "+V.statusText,I)}))},k.b.prototype._cascadeLoadFiles=function(V,I,m){let C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const l=[];l._internalCount=0;for(let s=0;s<6;s++)this._partialLoadFile(m[s],s,l,I,C)},k.b.prototype._cascadeLoadImgs=function(V,I,m,C){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,s=arguments.length>5?arguments[5]:void 0;const F=[];F._internalCount=0;for(let k=0;k<6;k++)this._partialLoadImg(C[k],k,F,V,I,m,l,s)},k.b.prototype._partialLoadImg=function(V,I,m,C,l,k){let j=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,E=arguments.length>7?arguments[7]:void 0;const K=(0,F.d)();(0,s.u)(V,(V=>{m[I]=V,m._internalCount++,C&&C.removePendingData(K),6===m._internalCount&&k&&k(l,m)}),((V,I)=>{C&&C.removePendingData(K),j&&j(V,I)}),C?C.offlineProvider:null,E),C&&C.addPendingData(K)},k.b.prototype.createCubeTextureBase=function(V,I,m,s){let F=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,k=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,E=arguments.length>6?arguments[6]:void 0,K=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,Y=arguments.length>8&&void 0!==arguments[8]&&arguments[8],X=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,O=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,v=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,N=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,t=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,D=arguments.length>14&&void 0!==arguments[14]&&arguments[14],b=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const T=v||new C.e(this,7);T.isCube=!0,T.url=V,T.generateMipMaps=!s,T._lodGenerationScale=X,T._lodGenerationOffset=O,T._useSRGBBuffer=!!D&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!s),T!==v&&(T.label=V.substring(0,60)),this._doNotHandleContextLost||(T._extension=K,T._files=m,T._buffer=b);const n=V;this._transformTextureUrl&&!v&&(V=this._transformTextureUrl(V));const x=K??function(V){const I=V.split("?")[0],m=I.lastIndexOf(".");return m>-1?I.substring(m).toLowerCase():""}(V),S=(0,j.c)(x),c=(V,I)=>{T.dispose(),k?k(V,I):V&&l.d.Warn(V)},H=(C,k)=>{V===n?C&&c(C.status+" "+C.statusText,k):(l.d.Warn(`Failed to load ${V}, falling back to the ${n}`),this.createCubeTextureBase(n,I,m,!!s,F,c,E,K,Y,X,O,T,N,t,D,b))};if(S)S.then((C=>{const l=V=>{N&&N(T,V),C.loadCubeData(V,T,Y,F,((V,I)=>{c(V,I)}))};b?l(b):m&&6===m.length?C.supportCascades?this._cascadeLoadFiles(I,(V=>l(V.map((V=>new Uint8Array(V))))),m,c):c("Textures type does not support cascades."):this._loadFile(V,(V=>l(new Uint8Array(V))),void 0,void 0,!0,H)}));else{if(!m||0===m.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(I,T,((V,I)=>{t&&t(V,I)}),m,c)}return this._internalTexturesCache.push(T),T}},13647:(V,I,m)=>{m.r(I),m.d(I,{_DDSTextureLoader:()=>s});var C=m(11488),l=m(13655);class s{constructor(){this.supportCascades=!0}loadCubeData(V,I,m,s){const F=I.getEngine();let k,j=!1,E=1e3;if(Array.isArray(V))for(let C=0;C<V.length;C++){const m=V[C];k=l.DDSTools.GetDDSInfo(m),I.width=k.width,I.height=k.height,j=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&I.generateMipMaps,F._unpackFlipY(k.isCompressed),l.DDSTools.UploadDDSLevels(F,I,m,k,j,6,-1,C),k.isFourCC||1!==k.mipmapCount?E=k.mipmapCount-1:F.generateMipMapsForCubemap(I)}else{const s=V;k=l.DDSTools.GetDDSInfo(s),I.width=k.width,I.height=k.height,m&&(k.sphericalPolynomial=new C.c),j=(k.isRGB||k.isLuminance||k.mipmapCount>1)&&I.generateMipMaps,F._unpackFlipY(k.isCompressed),l.DDSTools.UploadDDSLevels(F,I,s,k,j,6),k.isFourCC||1!==k.mipmapCount?E=k.mipmapCount-1:F.generateMipMapsForCubemap(I,!1)}F._setCubeMapTextureParams(I,j,E),I.isReady=!0,I.onLoadedObservable.notifyObservers(I),I.onLoadedObservable.clear(),s&&s({isDDS:!0,width:I.width,info:k,data:V,texture:I})}loadData(V,I,m){const C=l.DDSTools.GetDDSInfo(V),s=(C.isRGB||C.isLuminance||C.mipmapCount>1)&&I.generateMipMaps&&Math.max(C.width,C.height)>>C.mipmapCount-1===1;m(C.width,C.height,s,C.isFourCC,(()=>{l.DDSTools.UploadDDSLevels(I.getEngine(),I,V,C,s,1)}))}}},13655:(V,I,m)=>{m.d(I,{DDSTools:()=>v});var C=m(11074),l=m(11085),s=m(11678),F=m(11514);m(12872);const k=131072,j=131072;function E(V){return V.charCodeAt(0)+(V.charCodeAt(1)<<8)+(V.charCodeAt(2)<<16)+(V.charCodeAt(3)<<24)}const K=E("DXT1"),Y=E("DXT3"),X=E("DXT5"),O=E("DX10");class v{static GetDDSInfo(V){const I=new Int32Array(V.buffer,V.byteOffset,31),m=new Int32Array(V.buffer,V.byteOffset,35);let C=1;I[2]&k&&(C=Math.max(1,I[7]));const l=I[21],s=l===O?m[32]:0;let F=0;switch(l){case 113:F=2;break;case 116:F=1;break;case O:if(10===s){F=2;break}if(2===s){F=1;break}}return{width:I[4],height:I[3],mipmapCount:C,isFourCC:4===(4&I[20]),isRGB:64===(64&I[20]),isLuminance:(I[20]&j)===j,isCube:512===(512&I[28]),isCompressed:l===K||l===Y||l===X,dxgiFormat:s,textureType:F}}static _GetHalfFloatAsFloatRGBAArrayBuffer(V,I,m,C,l,s){const k=new Float32Array(C),j=new Uint16Array(l,m);let E=0;for(let K=0;K<I;K++)for(let I=0;I<V;I++){const m=4*(I+K*V);k[E]=(0,F.e)(j[m]),k[E+1]=(0,F.e)(j[m+1]),k[E+2]=(0,F.e)(j[m+2]),v.StoreLODInAlphaChannel?k[E+3]=s:k[E+3]=(0,F.e)(j[m+3]),E+=4}return k}static _GetHalfFloatRGBAArrayBuffer(V,I,m,C,l,s){if(v.StoreLODInAlphaChannel){const k=new Uint16Array(C),j=new Uint16Array(l,m);let E=0;for(let m=0;m<I;m++)for(let I=0;I<V;I++){const C=4*(I+m*V);k[E]=j[C],k[E+1]=j[C+1],k[E+2]=j[C+2],k[E+3]=(0,F.n)(s),E+=4}return k}return new Uint16Array(l,m,C)}static _GetFloatRGBAArrayBuffer(V,I,m,C,l,s){if(v.StoreLODInAlphaChannel){const F=new Float32Array(C),k=new Float32Array(l,m);let j=0;for(let m=0;m<I;m++)for(let I=0;I<V;I++){const C=4*(I+m*V);F[j]=k[C],F[j+1]=k[C+1],F[j+2]=k[C+2],F[j+3]=s,j+=4}return F}return new Float32Array(l,m,C)}static _GetFloatAsHalfFloatRGBAArrayBuffer(V,I,m,C,l,s){const k=new Uint16Array(C),j=new Float32Array(l,m);let E=0;for(let K=0;K<I;K++)for(let I=0;I<V;I++)k[E]=(0,F.n)(j[E]),k[E+1]=(0,F.n)(j[E+1]),k[E+2]=(0,F.n)(j[E+2]),v.StoreLODInAlphaChannel?k[E+3]=(0,F.n)(s):k[E+3]=(0,F.n)(j[E+3]),E+=4;return k}static _GetFloatAsUIntRGBAArrayBuffer(V,I,m,l,s,F){const k=new Uint8Array(l),j=new Float32Array(s,m);let E=0;for(let K=0;K<I;K++)for(let I=0;I<V;I++){const m=4*(I+K*V);k[E]=255*(0,C.Clamp)(j[m]),k[E+1]=255*(0,C.Clamp)(j[m+1]),k[E+2]=255*(0,C.Clamp)(j[m+2]),v.StoreLODInAlphaChannel?k[E+3]=F:k[E+3]=255*(0,C.Clamp)(j[m+3]),E+=4}return k}static _GetHalfFloatAsUIntRGBAArrayBuffer(V,I,m,l,s,k){const j=new Uint8Array(l),E=new Uint16Array(s,m);let K=0;for(let Y=0;Y<I;Y++)for(let I=0;I<V;I++){const m=4*(I+Y*V);j[K]=255*(0,C.Clamp)((0,F.e)(E[m])),j[K+1]=255*(0,C.Clamp)((0,F.e)(E[m+1])),j[K+2]=255*(0,C.Clamp)((0,F.e)(E[m+2])),v.StoreLODInAlphaChannel?j[K+3]=k:j[K+3]=255*(0,C.Clamp)((0,F.e)(E[m+3])),K+=4}return j}static _GetRGBAArrayBuffer(V,I,m,C,l,s,F,k,j){const E=new Uint8Array(C),K=new Uint8Array(l,m);let Y=0;for(let X=0;X<I;X++)for(let I=0;I<V;I++){const m=4*(I+X*V);E[Y]=K[m+s],E[Y+1]=K[m+F],E[Y+2]=K[m+k],E[Y+3]=K[m+j],Y+=4}return E}static _ExtractLongWordOrder(V){return 0===V||255===V||-16777216===V?0:1+v._ExtractLongWordOrder(V>>8)}static _GetRGBArrayBuffer(V,I,m,C,l,s,F,k){const j=new Uint8Array(C),E=new Uint8Array(l,m);let K=0;for(let Y=0;Y<I;Y++)for(let I=0;I<V;I++){const m=3*(I+Y*V);j[K]=E[m+s],j[K+1]=E[m+F],j[K+2]=E[m+k],K+=3}return j}static _GetLuminanceArrayBuffer(V,I,m,C,l){const s=new Uint8Array(C),F=new Uint8Array(l,m);let k=0;for(let j=0;j<I;j++)for(let I=0;I<V;I++){const m=I+j*V;s[k]=F[m],k++}return s}static UploadDDSLevels(V,I,m,C,F,j){let E=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,N=arguments.length>7?arguments[7]:void 0,t=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],D=null;C.sphericalPolynomial&&(D=[]);const b=!!V.getCaps().s3tc;I.generateMipMaps=F;const T=new Int32Array(m.buffer,m.byteOffset,31);let n,x,S,c,H,y,z,Z=0,B=0,W=1;if(542327876!==T[0])return void l.d.Error("Invalid magic number in DDS header");if(!C.isFourCC&&!C.isRGB&&!C.isLuminance)return void l.d.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(C.isCompressed&&!b)return void l.d.Error("Compressed textures are not supported on this platform.");let Q=T[22];c=T[1]+4;let G=!1;if(C.isFourCC)switch(n=T[21],n){case K:W=8,B=33777;break;case Y:W=16,B=33778;break;case X:W=16,B=33779;break;case 113:G=!0,Q=64;break;case 116:G=!0,Q=128;break;case O:{c+=20;let V=!1;switch(C.dxgiFormat){case 10:G=!0,Q=64,V=!0;break;case 2:G=!0,Q=128,V=!0;break;case 88:C.isRGB=!0,C.isFourCC=!1,Q=32,V=!0}if(V)break}default:return void l.d.Error(["Unsupported FourCC code:",(r=n,String.fromCharCode(255&r,r>>8&255,r>>16&255,r>>24&255))])}var r;const g=v._ExtractLongWordOrder(T[23]),h=v._ExtractLongWordOrder(T[24]),d=v._ExtractLongWordOrder(T[25]),R=v._ExtractLongWordOrder(T[26]);G&&(B=V._getRGBABufferInternalSizedFormat(C.textureType)),y=1,T[2]&k&&!1!==F&&(y=Math.max(1,T[7]));const i=N||0,q=V.getCaps();for(let l=i;l<j;l++){for(x=T[4],S=T[3],z=0;z<y;++z){if(-1===E||E===z){const s=-1===E?z:0;if(!C.isCompressed&&C.isFourCC){I.format=5,Z=x*S*4;let C=null;if(V._badOS||V._badDesktopOS||!q.textureHalfFloat&&!q.textureFloat)128===Q?(C=v._GetFloatAsUIntRGBAArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,s),D&&0==s&&D.push(v._GetFloatRGBAArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,s))):64===Q&&(C=v._GetHalfFloatAsUIntRGBAArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,s),D&&0==s&&D.push(v._GetHalfFloatAsFloatRGBAArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,s))),I.type=0;else{const V=q.textureFloat&&(t&&q.textureFloatLinearFiltering||!t),l=q.textureHalfFloat&&(t&&q.textureHalfFloatLinearFiltering||!t),F=(128===Q||64===Q&&!l)&&V?1:(64===Q||128===Q&&!V)&&l?2:0;let k,j=null;if(128===Q)switch(F){case 1:k=v._GetFloatRGBAArrayBuffer,j=null;break;case 2:k=v._GetFloatAsHalfFloatRGBAArrayBuffer,j=v._GetFloatRGBAArrayBuffer;break;case 0:k=v._GetFloatAsUIntRGBAArrayBuffer,j=v._GetFloatRGBAArrayBuffer}else switch(F){case 1:k=v._GetHalfFloatAsFloatRGBAArrayBuffer,j=null;break;case 2:k=v._GetHalfFloatRGBAArrayBuffer,j=v._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:k=v._GetHalfFloatAsUIntRGBAArrayBuffer,j=v._GetHalfFloatAsFloatRGBAArrayBuffer}I.type=F,C=k(x,S,m.byteOffset+c,Z,m.buffer,s),D&&0==s&&D.push(j?j(x,S,m.byteOffset+c,Z,m.buffer,s):C)}C&&V._uploadDataToTextureDirectly(I,C,l,s)}else if(C.isRGB)I.type=0,24===Q?(I.format=4,Z=x*S*3,H=v._GetRGBArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,g,h,d),V._uploadDataToTextureDirectly(I,H,l,s)):(I.format=5,Z=x*S*4,H=v._GetRGBAArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer,g,h,d,R),V._uploadDataToTextureDirectly(I,H,l,s));else if(C.isLuminance){const C=V._getUnpackAlignement(),F=x;Z=Math.floor((x+C-1)/C)*C*(S-1)+F,H=v._GetLuminanceArrayBuffer(x,S,m.byteOffset+c,Z,m.buffer),I.format=1,I.type=0,V._uploadDataToTextureDirectly(I,H,l,s)}else Z=Math.max(4,x)/4*Math.max(4,S)/4*W,H=new Uint8Array(m.buffer,m.byteOffset+c,Z),I.type=0,V._uploadCompressedDataToTextureDirectly(I,B,x,S,H,l,s)}c+=Q?x*S*(Q/8):Z,x*=.5,S*=.5,x=Math.max(1,x),S=Math.max(1,S)}if(void 0!==N)break}D&&D.length>0?C.sphericalPolynomial=s.c.ConvertCubeMapToSphericalPolynomial({size:T[4],right:D[0],left:D[1],up:D[2],down:D[3],front:D[4],back:D[5],format:5,type:1,gammaSpace:!1}):C.sphericalPolynomial=void 0}}v.StoreLODInAlphaChannel=!1}}]);