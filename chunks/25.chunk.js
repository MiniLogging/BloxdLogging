"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11568:(L,j,P)=>{P.r(j),P.d(j,{EXT_materials_diffuse_roughness:()=>Hj,EXT_mesh_gpu_instancing:()=>pL,GLTF2Export:()=>IL,GLTFData:()=>D,KHR_draco_mesh_compression:()=>Pj,KHR_lights_punctual:()=>aj,KHR_materials_anisotropy:()=>gj,KHR_materials_clearcoat:()=>Nj,KHR_materials_diffuse_transmission:()=>fj,KHR_materials_dispersion:()=>Kj,KHR_materials_emissive_strength:()=>qj,KHR_materials_ior:()=>Tj,KHR_materials_iridescence:()=>Mj,KHR_materials_sheen:()=>lj,KHR_materials_specular:()=>dj,KHR_materials_transmission:()=>Ej,KHR_materials_unlit:()=>tj,KHR_materials_volume:()=>Fj,KHR_texture_transform:()=>ej,OBJExport:()=>Y,STLExport:()=>sj,USDZExportAsync:()=>jP,_ConvertToGLTFPBRMetallicRoughness:()=>U,_SolveMetallic:()=>E,__IGLTFExporterExtension:()=>u});var A=P(656),R=P(475),o=P(801);class Y{static OBJ(L,j,P,Y){const u=[];let a=1,D=1;j&&(P||(P="mat"),u.push("mtllib "+P+".mtl"));for(let S=0;S<L.length;S++){const P=L[S],g=P.name||`mesh${S}}`;u.push(`o ${g}`);let V=null;if(Y){const L=P.yi(!0);V=new A.e,L.invertToRef(V),P.bakeTransformIntoVertices(L)}if(j){const L=P.material;L&&u.push("usemtl "+L.id)}const N=P.ui;if(!N){R.d.Warn("No geometry is present on the mesh");continue}const C=N.getVerticesData("position"),b=N.getVerticesData("Xi"),f=N.getVerticesData("uv"),h=N.zi();let K=0,v=0;if(!C||!h){R.d.Warn("There are no position vertices or indices on the mesh!");continue}const q=L[0].va().useRightHandedSystem?1:-1;for(let L=0;L<C.length;L+=3)u.push("v "+C[L]*q+" "+C[L+1]+" "+C[L+2]),K++;if(null!=b)for(let L=0;L<b.length;L+=3)u.push("vn "+b[L]*q+" "+b[L+1]+" "+b[L+2]);if(null!=f)for(let L=0;L<f.length;L+=2)u.push("vt "+f[L]+" "+f[L+1]),v++;const y=["","",""],T=(P.material||P.va().defaultMaterial)._getEffectiveOrientation(P),[G,M]=T===o.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let L=0;L<h.length;L+=3){const j=[String(h[L]+a),String(h[L+G]+a),String(h[L+M]+a)],P=[String(h[L]+D),String(h[L+G]+D),String(h[L+M]+D)],A=j,R=null!=f?P:y,o=null!=b?j:y;u.push("f "+A[0]+"/"+R[0]+"/"+o[0]+" "+A[1]+"/"+R[1]+"/"+o[1]+" "+A[2]+"/"+R[2]+"/"+o[2])}Y&&V&&P.bakeTransformIntoVertices(V),a+=K,D+=v}return u.join("\n")}static MTL(L){const j=[],P=L.material;j.push("newmtl mat1"),j.push("  Ns "+P.specularPower.toFixed(4)),j.push("  Ni 1.5000"),j.push("  d "+P.alpha.toFixed(4)),j.push("  Tr 0.0000"),j.push("  Tf 1.0000 1.0000 1.0000"),j.push("  illum 2"),j.push("  Ka "+P.ambientColor.r.toFixed(4)+" "+P.ambientColor.g.toFixed(4)+" "+P.ambientColor.b.toFixed(4)),j.push("  Kd "+P.diffuseColor.r.toFixed(4)+" "+P.diffuseColor.g.toFixed(4)+" "+P.diffuseColor.b.toFixed(4)),j.push("  Ks "+P.specularColor.r.toFixed(4)+" "+P.specularColor.g.toFixed(4)+" "+P.specularColor.b.toFixed(4)),j.push("  Ke "+P.emissiveColor.r.toFixed(4)+" "+P.emissiveColor.g.toFixed(4)+" "+P.emissiveColor.b.toFixed(4));P.ambientTexture&&j.push("  map_Ka "+P.ambientTexture.name),P.diffuseTexture&&j.push("  map_Kd "+P.diffuseTexture.name),P.specularTexture&&j.push("  map_Ks "+P.specularTexture.name),P.bumpTexture&&j.push("  map_bump -imfchan z "+P.bumpTexture.name),P.opacityTexture&&j.push("  map_d "+P.opacityTexture.name);return j.join("\n")}}var u=0,a=P(528);class D{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const L in this.files){const j=this.files[L],P=new Blob([j],{type:(0,a.g)(L)});R.d.Download(P,L)}}}var S=P(708),g=P(780),V=P(778),N=P(11575),C=P(2074),b=P(519),f=P(685),h=P(670);const K=h.HighestCommonFactor,v={...h,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:K};var q=P(2026),y=P(2032),T=P(11580),G=P(11582),M=P(2201);const Q=1e-6,l=new f.e(.04,.04,.04),w=1024,d=f.e.White(),c=f.e.Black();function E(L,j,P){if(j<l.r)return 0;const A=l.r,R=L*P/(1-l.r)+j-2*l.r,o=R*R-4*A*(l.r-j);return v.Clamp((-R+Math.sqrt(o))/(2*A),0,1)}function U(L){const j=L.diffuseColor.toLinearSpace(L.va().getEngine().useExactSrgbConversions).scale(.5),P=L.alpha,R=function(L){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new A.n(0,1),P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new A.n(0,.1),R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new A.n(0,.1),o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new A.n(1300,.1);return function(L,j,P,A,R){return(1-L)*(1-L)*(1-L)*j+3*(1-L)*(1-L)*L*P+3*(1-L)*L*L*A+L*L*L*R}(Math.pow(L/o.x,.333333),j.y,P.y,R.y,o.y)}(v.Clamp(L.specularPower,0,w));return{baseColorFactor:[j.r,j.g,j.b,P],metallicFactor:0,roughnessFactor:R}}function t(L,j){j.needAlphaBlending()?L.alphaMode="BLEND":j.needAlphaTesting()&&(L.alphaMode="MASK",L.alphaCutoff=j.alphaCutOff)}function B(L,j,P){const A=new Uint8Array(L*j*4);for(let R=0;R<A.length;R+=4)A[R]=A[R+1]=A[R+2]=A[R+3]=255;return T.c.CreateRGBATexture(A,L,j,P)}function F(L){if(L instanceof Uint8Array){const j=L.length,P=new Float32Array(L.length);for(let A=0;A<j;++A)P[A]=L[A]/255;return P}if(L instanceof Float32Array)return L;throw new Error("Unsupported pixel format!")}class X{constructor(L){this._exporter=L,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(L){return L?this._textureMap.get(L)??null:null}async exportStandardMaterialAsync(L,j,P){const A=U(L),o={name:L.name};if(null==L.Di||L.Di||(L.twoSidedLighting||R.d.Warn(L.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),P){const P=[],R=L.diffuseTexture;R&&P.push(this.exportTextureAsync(R,j).then((L=>{L&&(A.baseColorTexture=L)})));const Y=L.bumpTexture;Y&&P.push(this.exportTextureAsync(Y,j).then((L=>{L&&(o.normalTexture=L,1!==Y.level&&(o.normalTexture.scale=Y.level))})));const u=L.emissiveTexture;u&&(o.emissiveFactor=[1,1,1],P.push(this.exportTextureAsync(u,j).then((L=>{L&&(o.emissiveTexture=L)}))));const a=L.ambientTexture;a&&P.push(this.exportTextureAsync(a,j).then((L=>{if(L){const j={index:L.index};o.occlusionTexture=j}}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(P))}(L.alpha<1||L.opacityTexture)&&(L.alphaMode===G.e.ALPHA_COMBINE?o.alphaMode="BLEND":R.d.Warn(L.name+": glTF 2.0 does not support alpha mode: "+L.alphaMode.toString())),L.emissiveColor&&!L.emissiveColor.equalsWithEpsilon(c,Q)&&(o.emissiveFactor=L.emissiveColor.Ei()),o.pbrMetallicRoughness=A,t(o,L),await this._finishMaterialAsync(o,L,j);const Y=this._exporter._materials;return Y.push(o),Y.length-1}async _finishMaterialAsync(L,j,P){const A=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",L,j),R=[];for(const o of A)R.push(this.exportTextureAsync(o,P));await Promise.all(R),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",L,j)}async _getImageDataAsync(L,j,A,R){const o=G.e.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,u=Y.getEngine(),a=u.createRawTexture(L,j,A,G.e.TEXTUREFORMAT_RGBA,!1,!0,y.e.NEAREST_SAMPLINGMODE,null,o);u.isWebGPU?await P.e(45).then(P.bind(P,13065)):await P.e(46).then(P.bind(P,13069)),await q.m.ApplyPostProcess("pass",a,Y,o,G.e.TEXTURE_NEAREST_SAMPLINGMODE,G.e.TEXTUREFORMAT_RGBA);const D=await u._readTexturePixels(a,j,A);return await M.DumpTools.DumpDataAsync(j,A,D,R,void 0,!0,!0)}_resizeTexturesToSameDimensions(L,j,P){const A=L?L.getSize():{width:0,height:0},R=j?j.getSize():{width:0,height:0};let o,Y;return A.width<R.width?(o=L&&L instanceof y.e?q.m.CreateResizedCopy(L,R.width,R.height,!0):B(R.width,R.height,P),Y=j):A.width>R.width?(Y=j&&j instanceof y.e?q.m.CreateResizedCopy(j,A.width,A.height,!0):B(A.width,A.height,P),o=L):(o=L,Y=j),{texture1:o,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,j,P,A){const R=new Array;if(!L&&!j)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const o=L?L.va():j?j.va():null;if(o){var Y;const u=this._resizeTexturesToSameDimensions(L,j,o),a=null===(Y=u.texture1)||void 0===Y?void 0:Y.getSize();let D,S;const g=a.width,V=a.height,N=await u.texture1.readPixels(),C=await u.texture2.readPixels();if(!N)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(D=F(N),!C)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");S=F(C);const b=S.byteLength,h=new Uint8Array(b),K=new Uint8Array(b),v=4,q=c;let y=0,T=0;for(let L=0;L<V;++L)for(let j=0;j<g;++j){const A=(g*L+j)*v,R={diffuseColor:new f.e(D[A],D[A+1],D[A+2]).toLinearSpace(o.getEngine().useExactSrgbConversions).multiply(P.diffuseColor),specularColor:new f.e(S[A],S[A+1],S[A+2]).toLinearSpace(o.getEngine().useExactSrgbConversions).multiply(P.specularColor),glossiness:S[A+3]*P.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(R);q.r=Math.max(q.r,Y.baseColor.r),q.g=Math.max(q.g,Y.baseColor.g),q.b=Math.max(q.b,Y.baseColor.b),y=Math.max(y,Y.metallic),T=Math.max(T,Y.roughness),K[A]=255*Y.baseColor.r,K[A+1]=255*Y.baseColor.g,K[A+2]=255*Y.baseColor.b,K[A+3]=u.texture1.Jj?255*D[A+3]:255,h[A]=0,h[A+1]=255*Y.roughness,h[A+2]=255*Y.metallic,h[A+3]=255}const G={baseColor:q,metallic:y,roughness:T};let M=!1,l=!1;for(let L=0;L<V;++L)for(let j=0;j<g;++j){const P=(g*L+j)*v;K[P]/=G.baseColor.r>Q?G.baseColor.r:1,K[P+1]/=G.baseColor.g>Q?G.baseColor.g:1,K[P+2]/=G.baseColor.b>Q?G.baseColor.b:1;const A=f.e.FromInts(K[P],K[P+1],K[P+2]).toGammaSpace(o.getEngine().useExactSrgbConversions);K[P]=255*A.r,K[P+1]=255*A.g,K[P+2]=255*A.b,A.equalsWithEpsilon(d,Q)||(l=!0),h[P+1]/=G.roughness>Q?G.roughness:1,h[P+2]/=G.metallic>Q?G.metallic:1;f.e.FromInts(255,h[P+1],h[P+2]).equalsWithEpsilon(d,Q)||(M=!0)}return M&&R.push(this._getImageDataAsync(h,g,V,A).then((L=>{G.metallicRoughnessTextureData=L}))),l&&R.push(this._getImageDataAsync(K,g,V,A).then((L=>{G.baseColorTextureData=L}))),await Promise.all(R).then((()=>G))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(L){const j=this._getPerceivedBrightness(L.diffuseColor),P=this._getPerceivedBrightness(L.specularColor),A=1-this._getMaxComponent(L.specularColor),R=E(j,P,A),o=L.diffuseColor.scale(A/(1-l.r)/Math.max(1-R)),Y=L.specularColor.xg(l.scale(1-R)).scale(1/Math.max(R));let u=f.e.Lerp(o,Y,R*R);u=u.clampToRef(0,1,u);return{baseColor:u,metallic:R,roughness:1-L.glossiness}}_getPerceivedBrightness(L){return L?Math.sqrt(.299*L.r*L.r+.587*L.g*L.g+.114*L.b*L.b):0}_getMaxComponent(L){return L?Math.max(L.r,Math.max(L.g,L.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(L,j,P,A){const R=[],o={baseColor:L._albedoColor,metallic:L._metallic,roughness:L._roughness};if(A){L._albedoTexture&&R.push(this.exportTextureAsync(L._albedoTexture,j).then((L=>{L&&(P.baseColorTexture=L)})));const A=L._metallicTexture;A&&R.push(this.exportTextureAsync(A,j).then((L=>{L&&(P.metallicRoughnessTexture=L)})))}return R.length>0&&(this._exporter._materialNeedsUVsSet.add(L),await Promise.all(R)),o}_getTextureSampler(L){const j={};if(!L||!(L instanceof y.e))return j;const P=this._getGLTFTextureWrapMode(L.wrapU);10497!==P&&(j.wrapS=P);const A=this._getGLTFTextureWrapMode(L.wrapV);switch(10497!==A&&(j.wrapT=A),L.samplingMode){case y.e.LINEAR_LINEAR:j.magFilter=9729,j.minFilter=9729;break;case y.e.LINEAR_NEAREST:j.magFilter=9729,j.minFilter=9728;break;case y.e.NEAREST_LINEAR:j.magFilter=9728,j.minFilter=9729;break;case y.e.NEAREST_LINEAR_MIPLINEAR:j.magFilter=9728,j.minFilter=9987;break;case y.e.NEAREST_NEAREST:j.magFilter=9728,j.minFilter=9728;break;case y.e.NEAREST_LINEAR_MIPNEAREST:j.magFilter=9728,j.minFilter=9985;break;case y.e.LINEAR_NEAREST_MIPNEAREST:j.magFilter=9729,j.minFilter=9984;break;case y.e.LINEAR_NEAREST_MIPLINEAR:j.magFilter=9729,j.minFilter=9986;break;case y.e.NEAREST_NEAREST_MIPLINEAR:j.magFilter=9728,j.minFilter=9986;break;case y.e.LINEAR_LINEAR_MIPLINEAR:j.magFilter=9729,j.minFilter=9987;break;case y.e.LINEAR_LINEAR_MIPNEAREST:j.magFilter=9729,j.minFilter=9985;break;case y.e.NEAREST_NEAREST_MIPNEAREST:j.magFilter=9728,j.minFilter=9984}return j}_getGLTFTextureWrapMode(L){switch(L){case y.e.WRAP_ADDRESSMODE:return 10497;case y.e.CLAMP_ADDRESSMODE:return 33071;case y.e.MIRROR_ADDRESSMODE:return 33648;default:return R.d.Error(`Unsupported Texture Wrap Mode ${L}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(L,j,P,A){const R={diffuseColor:L._albedoColor,specularColor:L._reflectivityColor,glossiness:L._microSurface},o=L._albedoTexture,Y=L._reflectivityTexture,u=L._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!u)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((o||Y)&&A){this._exporter._materialNeedsUVsSet.add(L);const A=this._exportTextureSampler(o||Y),u=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(o,Y,R,j),a=this._exporter._textures;if(u.baseColorTextureData){const L=this._exportImage(`baseColor${a.length}`,j,u.baseColorTextureData);P.baseColorTexture=this._exportTextureInfo(L,A,null===o||void 0===o?void 0:o.coordinatesIndex)}if(u.metallicRoughnessTextureData){const L=this._exportImage(`metallicRoughness${a.length}`,j,u.metallicRoughnessTextureData);P.metallicRoughnessTexture=this._exportTextureInfo(L,A,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return u}return this._convertSpecularGlossinessToMetallicRoughness(R)}async exportPBRMaterialAsync(L,j,P){const A={},R={name:L.name},o=L.isMetallicWorkflow();if(o){const j=L._albedoColor,P=L.alpha;j&&(A.baseColorFactor=[j.r,j.g,j.b,P])}const Y=o?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(L,j,A,P):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(L,j,A,P);await this._setMetallicRoughnessPbrMaterialAsync(Y,L,R,A,j,P),await this._finishMaterialAsync(R,L,j);const u=this._exporter._materials;return u.push(R),u.length-1}async _setMetallicRoughnessPbrMaterialAsync(L,j,P,A,o,Y){if(t(P,j),L.baseColor.equalsWithEpsilon(d,Q)&&v.WithinEpsilon(j.alpha,1,Q)||(A.baseColorFactor=[L.baseColor.r,L.baseColor.g,L.baseColor.b,j.alpha]),null!=L.metallic&&1!==L.metallic&&(A.metallicFactor=L.metallic),null!=L.roughness&&1!==L.roughness&&(A.roughnessFactor=L.roughness),null==j.Di||j.Di||(j._twoSidedLighting||R.d.Warn(j.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),P.doubleSided=!0),Y){const L=[],A=j._bumpTexture;A&&L.push(this.exportTextureAsync(A,o).then((L=>{L&&(P.normalTexture=L,1!==A.level&&(P.normalTexture.scale=A.level))})));const R=j._ambientTexture;R&&L.push(this.exportTextureAsync(R,o).then((L=>{if(L){const A={index:L.index,texCoord:L.texCoord,extensions:L.extensions};P.occlusionTexture=A;const R=j._ambientTextureStrength;R&&(A.strength=R)}})));const Y=j._emissiveTexture;Y&&L.push(this.exportTextureAsync(Y,o).then((L=>{L&&(P.emissiveTexture=L)}))),L.length>0&&(this._exporter._materialNeedsUVsSet.add(j),await Promise.all(L))}const u=j._emissiveColor;u.equalsWithEpsilon(c,Q)||(P.emissiveFactor=u.Ei()),P.pbrMetallicRoughness=A}_getPixelsFromTextureAsync(L){return function(L){switch(L){case G.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case G.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case G.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case G.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case G.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case G.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case G.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case G.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case G.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case G.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case G.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case G.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(L.textureFormat)?(0,q.j)(L,L._texture.width,L._texture.height):(L.textureType,G.e.TEXTURETYPE_UNSIGNED_BYTE,L.readPixels())}async exportTextureAsync(L,j){const P=this._exporter._extensionsPreExportTextureAsync("exporter",L,j);return P?await P.then((async P=>P?await this._exportTextureInfoAsync(P,j):await this._exportTextureInfoAsync(L,j))):await this._exportTextureInfoAsync(L,j)}async _exportTextureInfoAsync(L,j){let P=this._textureMap.get(L);if(!P){const A=await this._getPixelsFromTextureAsync(L);if(!A)return null;const o=this._exportTextureSampler(L),Y=L.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":j=Y;break;default:R.d.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const u=this._internalTextureToImage,a=L.getInternalTexture().uniqueId;u[a]||(u[a]={});let D=u[a][j];if(void 0===D){const P=L.getSize();D=(async()=>{const R=await this._getImageDataAsync(A,P.width,P.height,j);return this._exportImage(L.name,j,R)})(),u[a][j]=D}P=this._exportTextureInfo(await D,o,L.coordinatesIndex),this._textureMap.set(L,P),this._exporter._extensionsPostExportTextures("exporter",P,L)}return P}_exportImage(L,j,P){const A=this._exporter._images;let o;if(this._exporter._shouldUseGlb){o={name:L,mimeType:j,bufferView:void 0};const A=this._exporter._bufferManager.createBufferView(new Uint8Array(P));this._exporter._bufferManager.setBufferView(o,A)}else{const Y=L.replace(/\.\/|\/|\.\\|\\/g,"_"),u=function(L){switch(L){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(j);let a=Y+u;A.some((L=>L.uri===a))&&(a=`${Y}_${R.d.RandomId()}${u}`),o={name:L,uri:a},this._exporter._imageData[a]={data:P,mimeType:j}}return A.push(o),A.length-1}_exportTextureInfo(L,j,P){const A=this._exporter._textures;let R=A.findIndex((P=>P.sampler==j&&P.source===L));-1===R&&(R=A.length,A.push({source:L,sampler:j}));const o={index:R};return P&&(o.texCoord=P),o}_exportTextureSampler(L){const j=this._getTextureSampler(L),P=this._exporter._samplers,A=P.findIndex((L=>L.minFilter===j.minFilter&&L.magFilter===j.magFilter&&L.wrapS===j.wrapS&&L.wrapT===j.wrapT));return-1!==A?A:(P.push(j),P.length-1)}}var H=P(719),W=P(490),e=P(11589),s=P(661);const m=A.r.Zero(),x=A.i.Identity(),k=A.r.One(),I=new A.r(-1,1,1);function z(L,j){const{byteOffset:P,byteStride:A,type:R,normalized:o}=L,Y=L.getSize(),u=j.reduce(((L,j)=>j.getTotalVertices()>L?j.getTotalVertices():L),-Number.MAX_VALUE);return{byteOffset:P,byteStride:A,componentCount:Y,type:R,count:u*Y,normalized:o,totalVertices:u,kind:L.getKind()}}function p(L){switch(L){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function n(L){switch(L){case S.e.PositionKind:case S.e.NormalKind:case S.e.TangentKind:case S.e.ColorKind:case S.e.MatricesIndicesKind:case S.e.MatricesIndicesExtraKind:case S.e.MatricesWeightsKind:case S.e.MatricesWeightsExtraKind:case S.e.UVKind:case S.e.UV2Kind:case S.e.UV3Kind:case S.e.UV4Kind:case S.e.UV5Kind:case S.e.UV6Kind:return!0}return!1}function Z(L){switch(L){case o.c.TriangleFillMode:return 4;case o.c.TriangleStripDrawMode:return 5;case o.c.TriangleFanDrawMode:return 6;case o.c.PointListDrawMode:case o.c.PointFillMode:return 0;case o.c.LineLoopDrawMode:return 2;case o.c.LineListDrawMode:return 1;case o.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${L}`)}function O(L){const j=Math.sqrt(L.x*L.x+L.y*L.y+L.z*L.z);j>0&&(L.x/=j,L.y/=j,L.z/=j)}function i(L){return L.x*=-1,L}function J(L){if(L.x*L.x+L.y*L.y>.5){const j=Math.abs(L.x),P=Math.abs(L.y);if(j>P){const P=Math.sign(L.x);L.x=j,L.y*=-P,L.z*=-P,L.w*=P}else{const j=Math.sign(L.y);L.x*=-j,L.y=P,L.z*=j,L.w*=-j}}else{const j=Math.abs(L.z),P=Math.abs(L.w);if(j>P){const P=Math.sign(L.z);L.x*=-P,L.y*=P,L.z=j,L.w*=-P}else{const j=Math.sign(L.w);L.x*=j,L.y*=-j,L.z*=-j,L.w=P}}return L}function r(L){L.li(-L.z,L.w,L.x,-L.y)}function LL(L,j){const P=A.r.FromArrayToRef(j.translation||[0,0,0],0,A.m.ti[0]),R=A.i.FromArrayToRef(j.rotation||[0,0,0,1],0,A.m.Quaternion[0]),o=A.e.ComposeToRef(k,R,P,A.m.Matrix[0]),Y=A.r.FromArrayToRef(L.translation||[0,0,0],0,A.m.ti[2]),u=A.i.FromArrayToRef(L.rotation||[0,0,0,1],0,A.m.Quaternion[1]),a=A.e.ComposeToRef(k,u,Y,A.m.Matrix[1]);o.multiplyToRef(a,a),a.decompose(void 0,R,P),P.equalsWithEpsilon(m,s.c)?delete j.translation:j.translation=P.Ei(),R.equalsWithEpsilon(x,s.c)?delete j.rotation:j.rotation=R.Ei(),j.scale&&delete j.scale}function jL(L,j){if(!(j instanceof g.b))return!1;if(!(1===j.getChildren().length&&0===L.getChildren().length&&L.parent===j))return!1;const P=L.va(),A=L instanceof e.d&&!P.useRightHandedSystem?I:k;return!!j.mi.equalsWithEpsilon(A,s.c)||(W.e.Warn(`Cannot collapse node ${L.name} into parent node ${j.name} with modified scaling.`),!1)}function PL(L){if(L instanceof Array){const j=new Float32Array(L);return new Uint8Array(j.buffer,j.byteOffset,j.byteLength)}return ArrayBuffer.isView(L)?new Uint8Array(L.buffer,L.byteOffset,L.byteLength):new Uint8Array(L)}function AL(L,j){for(const[P,A]of Object.entries(L)){const R=j[P];(Array.isArray(A)&&Array.isArray(R)&&RL(A,R)||A===R)&&delete L[P]}return L}function RL(L,j){return L.length===j.length&&L.every(((L,P)=>L===j[P]))}const oL=A.e.Compose(new A.r(-1,1,1),A.i.Identity(),A.r.Zero());function YL(L,j){if(!(L instanceof g.b))return!1;if(j){if(!L.getWorldMatrix().equalsWithEpsilon(A.e.IdentityReadOnly,s.c))return!1}else{if(!L.getWorldMatrix().multiplyToRef(oL,A.m.Matrix[0]).equalsWithEpsilon(A.e.IdentityReadOnly,s.c))return!1}return!(L instanceof V.b&&L.ui)}const uL=new Map([[Int8Array,(L,j,P)=>L.setInt8(j,P)],[Uint8Array,(L,j,P)=>L.setUint8(j,P)],[Uint8ClampedArray,(L,j,P)=>L.setUint8(j,P)],[Int16Array,(L,j,P)=>L.setInt16(j,P,!0)],[Uint16Array,(L,j,P)=>L.setUint16(j,P,!0)],[Int32Array,(L,j,P)=>L.setInt32(j,P,!0)],[Uint32Array,(L,j,P)=>L.setUint32(j,P,!0)],[Float32Array,(L,j,P)=>L.setFloat32(j,P,!0)],[Float64Array,(L,j,P)=>L.setFloat64(j,P,!0)]]);class aL{writeTypedArray(L){this._checkGrowBuffer(L.byteLength);const j=uL.get(L.constructor);for(let P=0;P<L.length;P++)j(this._dataView,this._byteOffset,L[P]),this._byteOffset+=L.BYTES_PER_ELEMENT}constructor(L){this._data=new Uint8Array(L),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(L){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,L),this._byteOffset++}writeInt8(L){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,L),this._byteOffset++}writeInt16(L){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,L,!0),this._byteOffset+=2}writeUInt16(L){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,L,!0),this._byteOffset+=2}writeInt32(L){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,L,!0),this._byteOffset+=4}writeUInt32(L){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat32(L){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,L,!0),this._byteOffset+=4}writeFloat64(L){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,L,!0),this._byteOffset+=8}_checkGrowBuffer(L){const j=this.byteOffset+L;if(j>this._data.byteLength){const L=new Uint8Array(2*j);L.set(this._data),this._data=L,this._dataView=new DataView(this._data.buffer)}}}function DL(L){return L%4===0?4:L%2===0?2:1}class SL{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(L){let j=0;this._bufferViewToData.forEach((L=>{j+=L.byteLength}));const P=new aL(j),A=Array.from(this._bufferViewToData.keys()).sort(((L,j)=>DL(j.byteLength)-DL(L.byteLength)));for(const R of A){R.byteOffset=P.byteOffset,L.push(R);const j=L.length-1,A=this.getPropertiesWithBufferView(R);for(const L of A)L.bufferView=j;P.writeTypedArray(this._bufferViewToData.get(R)),this._bufferViewToData.delete(R)}return P.getOutputData()}createBufferView(L,j){const P={buffer:0,byteOffset:void 0,byteLength:L.byteLength,byteStride:j};return this._bufferViewToData.set(P,L),P}createAccessor(L,j,P,A,R,o,Y){this._verifyBufferView(L);const u={bufferView:void 0,componentType:P,count:A,type:j,min:null===o||void 0===o?void 0:o.min,max:null===o||void 0===o?void 0:o.max,normalized:Y,byteOffset:R};return this.setBufferView(u,L),this._accessorToBufferView.set(u,L),u}setBufferView(L,j){this._verifyBufferView(j);this.getPropertiesWithBufferView(j).push(L)}removeBufferView(L){const j=this.getPropertiesWithBufferView(L);for(const P of j)void 0!==P.bufferView&&delete P.bufferView;this._bufferViewToData.delete(L),this._bufferViewToProperties.delete(L),this._accessorToBufferView.forEach(((j,P)=>{j===L&&(void 0!==P.byteOffset&&delete P.byteOffset,this._accessorToBufferView.delete(P))}))}getBufferView(L){const j=this._accessorToBufferView.get(L);return this._verifyBufferView(j),j}getPropertiesWithBufferView(L){return this._verifyBufferView(L),this._bufferViewToProperties.set(L,this._bufferViewToProperties.get(L)??[]),this._bufferViewToProperties.get(L)}getData(L){return this._verifyBufferView(L),this._bufferViewToData.get(L)}_verifyBufferView(L){if(void 0===L||!this._bufferViewToData.has(L))throw new Error(`BufferView ${L} not found in BufferManager.`)}}var gL,VL=P(633),NL=P(821),CL=P(11595),bL=P(11666),fL=P(11669),hL=P(11680),KL=P(460),vL=P(11687);!function(L){L[L.INTANGENT=0]="INTANGENT",L[L.OUTTANGENT=1]="OUTTANGENT"}(gL||(gL={}));class qL{static _IsTransformable(L){return L&&(L instanceof g.b||L instanceof VL.e||L instanceof vL.d)}static _CreateNodeAnimation(L,j,P,A,o){if(this._IsTransformable(L)){const Y=[],u=[],a=j.getKeys(),D=qL._CalculateMinMaxKeyFrames(a),S=qL._DeduceInterpolation(a,P,A),g=S.interpolationType,V=S.shouldBakeAnimation;if(V?qL._CreateBakedAnimation(L,j,P,D.min,D.max,j.framePerSecond,o,Y,u,D,A):"LINEAR"===g||"STEP"===g?qL._CreateLinearOrStepAnimation(L,j,P,Y,u,A):"CUBICSPLINE"===g?qL._CreateCubicSplineAnimation(L,j,P,Y,u,A):qL._CreateBakedAnimation(L,j,P,D.min,D.max,j.framePerSecond,o,Y,u,D,A),Y.length&&u.length){return{inputs:Y,outputs:u,samplerInterpolation:g,inputsMin:V?D.min:R.d.FloatRound(D.min/j.framePerSecond),inputsMax:V?D.max:R.d.FloatRound(D.max/j.framePerSecond)}}}return null}static _DeduceAnimationInfo(L){let j=null,P="VEC3",A=!1;const o=L.targetProperty.split(".");switch(o[0]){case"mi":j="scale";break;case"position":j="translation";break;case"rotation":P="VEC4",j="rotation";break;case"rotationQuaternion":P="VEC4",A=!0,j="rotation";break;case"influence":P="SCALAR",j="weights";break;default:R.d.Error(`Unsupported animatable property ${o[0]}`)}return j?{animationChannelTargetPath:j,dataAccessorType:P,useQuaternion:A}:(R.d.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(L,j,P,A,R,o,Y,u,a,D,S){let g;if(qL._IsTransformable(L)&&L.animations)for(const V of L.animations){if(S&&!S(V))continue;const R=qL._DeduceAnimationInfo(V);R&&(g={name:V.name,samplers:[],channels:[]},qL._AddAnimation(`${V.name}`,V.hasRunningRuntimeAnimations?j:g,L,V,R.dataAccessorType,R.animationChannelTargetPath,A,o,Y,u,R.useQuaternion,a,D),g.samplers.length&&g.channels.length&&P.push(g))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(L,j,P,A,R,o,Y,u,a,D,S){let g;if(L instanceof KL.e){const R=L.morphTargetManager;if(R)for(let V=0;V<R.numTargets;++V){const N=R.getTarget(V);for(const C of N.animations){if(S&&!S(C))continue;const N=new fL.c(`${C.name}`,"influence",C.framePerSecond,C.dataType,C.loopMode,C.enableBlending),b=[],f=C.getKeys();for(let L=0;L<f.length;++L){const j=f[L];for(let L=0;L<R.numTargets;++L)L==V?b.push(j):b.push({frame:j.frame,value:0})}N.setKeys(b);const h=qL._DeduceAnimationInfo(N);h&&(g={name:N.name,samplers:[],channels:[]},qL._AddAnimation(C.name,C.hasRunningRuntimeAnimations?j:g,L,N,h.dataAccessorType,h.animationChannelTargetPath,A,o,Y,u,h.useQuaternion,a,D,R.numTargets),g.samplers.length&&g.channels.length&&P.push(g))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(L,j,P,A,R,o,Y,u,a){let D;if(L.animationGroups){const g=L.animationGroups;for(const V of g){const g=new Map,N=new Map,C=new Set,b=V.to-V.from;D={name:V.name,channels:[],samplers:[]};for(let j=0;j<V.targetedAnimations.length;++j){const b=V.targetedAnimations[j],f=b.target,h=b.animation;if(a&&!a(h))continue;const K=u.has(f);if(this._IsTransformable(f)||1===f.length&&this._IsTransformable(f[0])){const L=qL._DeduceAnimationInfo(b.animation);if(L){const j=this._IsTransformable(f)?f:this._IsTransformable(f[0])?f[0]:null;j&&qL._AddAnimation(`${h.name}`,D,j,h,L.dataAccessorType,L.animationChannelTargetPath,P,A,R,o,L.useQuaternion,Y,K)}}else if(f instanceof hL.e||1===f.length&&f[0]instanceof hL.e){if(qL._DeduceAnimationInfo(b.animation)){const j=f instanceof hL.e?f:f[0];if(j){const P=L.morphTargetManagers.find((L=>{for(let P=0;P<L.numTargets;++P)if(L.getTarget(P)===j)return!0;return!1}));if(P){const A=L.meshes.find((L=>L.morphTargetManager===P));var S;if(A)g.has(A)||g.set(A,new Map),null===(S=g.get(A))||void 0===S||S.set(j,h),C.add(A),N.set(A,h)}}}}}C.forEach((L=>{const j=L.morphTargetManager;let u=null;const a=[],S=N.get(L).getKeys(),C=S.length;for(let P=0;P<C;++P)for(let A=0;A<j.numTargets;++A){const R=j.getTarget(A),o=g.get(L);if(o){const j=o.get(R);j?(u||(u=new fL.c(`${V.name}_${L.name}_MorphWeightAnimation`,"influence",j.framePerSecond,fL.c.ANIMATIONTYPE_FLOAT,j.loopMode,j.enableBlending)),a.push(j.getKeys()[P])):a.push({frame:V.from+b/C*P,value:R.influence,inTangent:S[0].inTangent?0:void 0,outTangent:S[0].outTangent?0:void 0})}}u.setKeys(a);const f=qL._DeduceAnimationInfo(u);f&&qL._AddAnimation(`${V.name}_${L.name}_MorphWeightAnimation`,D,L,u,f.dataAccessorType,f.animationChannelTargetPath,P,A,R,o,f.useQuaternion,Y,!1,null===j||void 0===j?void 0:j.numTargets)})),D.channels.length&&D.samplers.length&&j.push(D)}}}static _AddAnimation(L,j,P,R,o,Y,u,a,D,S,g,V,N,C){const b=qL._CreateNodeAnimation(P,R,Y,g,V);let f,h,K,v,q,y;if(b){if(C){let L=0,j=0;const P=[];for(;b.inputs.length>0;)j=b.inputs.shift(),L%C==0&&P.push(j),L++;b.inputs=P}const L=u.get(P),R=new Float32Array(b.inputs);f=a.createBufferView(R),h=a.createAccessor(f,"SCALAR",5126,b.inputs.length,void 0,{min:[b.inputsMin],max:[b.inputsMax]}),S.push(h),K=S.length-1;const D=new A.i,g=new A.r,V=new A.r,T=P instanceof VL.e,G=p(o),M=new Float32Array(b.outputs.length*G);b.outputs.forEach((function(L,j){let P=L;switch(Y){case"translation":N&&(A.r.FromArrayToRef(L,0,V),i(V),V.toArray(P));break;case"rotation":4===L.length?A.i.FromArrayToRef(L,0,D):(P=new Array(4),A.r.FromArrayToRef(L,0,g),A.i.FromEulerVectorToRef(g,D)),N&&(J(D),T&&r(D)),D.toArray(P)}M.set(P,j*G)})),f=a.createBufferView(M),h=a.createAccessor(f,o,5126,b.outputs.length),S.push(h),v=S.length-1,q={interpolation:b.samplerInterpolation,input:K,output:v},j.samplers.push(q),y={sampler:j.samplers.length-1,target:{node:L,path:Y}},j.channels.push(y)}}static _CreateBakedAnimation(L,j,P,o,Y,u,a,D,S,g,V){let N;const C=A.i.Identity();let b,f=null,h=null,K=null,v=null,q=null,y=null;g.min=R.d.FloatRound(o/u);const T=j.getKeys();for(let A=0,G=T.length;A<G;++A){if(y=null,K=T[A],A+1<G)if(v=T[A+1],K.value.equals&&K.value.equals(v.value)||K.value===v.value){if(0!==A)continue;y=K.frame}else y=v.frame;else{if(q=T[A-1],K.value.equals&&K.value.equals(q.value)||K.value===q.value)continue;y=Y}if(y)for(let A=K.frame;A<=y;A+=a){if(b=R.d.FloatRound(A/u),b===f)continue;f=b,h=b;const o={key:0,repeatCount:0,loopMode:j.loopMode};N=j._interpolate(A,o),qL._SetInterpolatedValue(L,N,b,j,P,C,D,S,V)}}h&&(g.max=h)}static _ConvertFactorToVector3OrQuaternion(L,j,P,o,Y){const u=qL._GetBasePositionRotationOrScale(j,o,Y),a=P.targetProperty.split("."),D=a?a[1]:"",S=Y?A.i.ri(u).normalize():A.r.ri(u);switch(D){case"x":case"y":case"z":S[D]=L;break;case"w":S.w=L;break;default:R.d.Error(`glTFAnimation: Unsupported component name "${D}"!`)}return S}static _SetInterpolatedValue(L,j,P,R,o,Y,u,a,D){let S;u.push(P),"weights"!==o?(R.dataType===fL.c.ANIMATIONTYPE_FLOAT&&(j=this._ConvertFactorToVector3OrQuaternion(j,L,R,o,D)),"rotation"===o?(D?Y=j:(S=j,A.i.RotationYawPitchRollToRef(S.y,S.x,S.z,Y)),a.push(Y.Ei())):(S=j,a.push(S.Ei()))):a.push([j])}static _CreateLinearOrStepAnimation(L,j,P,A,R,o){for(const Y of j.getKeys())A.push(Y.frame/j.framePerSecond),qL._AddKeyframeValue(Y,j,R,P,L,o)}static _CreateCubicSplineAnimation(L,j,P,A,R,o){j.getKeys().forEach((function(Y){A.push(Y.frame/j.framePerSecond),qL._AddSplineTangent(gL.INTANGENT,R,P,"CUBICSPLINE",Y,o),qL._AddKeyframeValue(Y,j,R,P,L,o),qL._AddSplineTangent(gL.OUTTANGENT,R,P,"CUBICSPLINE",Y,o)}))}static _GetBasePositionRotationOrScale(L,j,P){let R;if("rotation"===j)if(P){R=(L.rotationQuaternion??A.i.Identity()).Ei()}else{R=(L.rotation??A.r.Zero()).Ei()}else if("translation"===j){R=(L.position??A.r.Zero()).Ei()}else{R=(L.mi??A.r.One()).Ei()}return R}static _AddKeyframeValue(L,j,P,o,Y,u){let a;const D=j.dataType;if(D===fL.c.ANIMATIONTYPE_VECTOR3){let j=L.value.Ei();if("rotation"===o){const L=A.r.ri(j);j=A.i.RotationYawPitchRoll(L.y,L.x,L.z).Ei()}P.push(j)}else if(D===fL.c.ANIMATIONTYPE_FLOAT){if("weights"===o)P.push([L.value]);else if(a=this._ConvertFactorToVector3OrQuaternion(L.value,Y,j,o,u),a){if("rotation"===o){const L=u?a:A.i.RotationYawPitchRoll(a.y,a.x,a.z).normalize();P.push(L.Ei())}P.push(a.Ei())}}else D===fL.c.ANIMATIONTYPE_QUATERNION?P.push(L.value.normalize().Ei()):R.d.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(L,j,P){let A,R,o=!1;if("rotation"===j&&!P)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,u=L.length;Y<u;++Y)if(R=L[Y],R.inTangent||R.outTangent)if(A){if("CUBICSPLINE"!==A){A="LINEAR",o=!0;break}}else A="CUBICSPLINE";else if(A){if("CUBICSPLINE"===A||R.interpolation&&1===R.interpolation&&"STEP"!==A){A="LINEAR",o=!0;break}}else A=R.interpolation&&1===R.interpolation?"STEP":"LINEAR";return A||(A="LINEAR"),{interpolationType:A,shouldBakeAnimation:o}}static _AddSplineTangent(L,j,P,R,o,Y){let u;const a=L===gL.INTANGENT?o.inTangent:o.outTangent;if("CUBICSPLINE"===R){if("rotation"===P)if(a)if(Y)u=a.Ei();else{const L=a;u=A.i.RotationYawPitchRoll(L.y,L.x,L.z).Ei()}else u=[0,0,0,0];else u="weights"===P?a?[a]:[0]:a?a.Ei():[0,0,0];j.push(u)}}static _CalculateMinMaxKeyFrames(L){let j=1/0,P=-1/0;return L.forEach((function(L){j=Math.min(j,L.frame),P=Math.max(P,L.frame)})),{min:j,max:P}}}function yL(L,j,P,o,Y,u){const a={attributes:{},influence:L.influence,name:L.name},D=j.ui;if(!D)return R.d.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),a;const g=u?-1:1,V=A.r.Zero();let N=0,C=0;if(L.hasPositions){const o=L.getPositions(),u=D.getVerticesData(S.e.PositionKind);if(u){const L=new Float32Array(u.length),j=[1/0,1/0,1/0],R=[-1/0,-1/0,-1/0];C=u.length/3,N=0;for(let P=N;P<C;++P){const Y=A.r.ri(u,3*P);A.r.ri(o,3*P).subtractToRef(Y,V),V.x*=g,j[0]=Math.min(j[0],V.x),R[0]=Math.max(R[0],V.x),j[1]=Math.min(j[1],V.y),R[1]=Math.max(R[1],V.y),j[2]=Math.min(j[2],V.z),R[2]=Math.max(R[2],V.z),L[3*P]=V.x,L[3*P+1]=V.y,L[3*P+2]=V.z}const D=P.createBufferView(L,12),S=P.createAccessor(D,"VEC3",5126,o.length/3,0,{min:j,max:R});Y.push(S),a.attributes.POSITION=Y.length-1}else R.d.Warn(`Morph target positions for mesh ${j.name} were not exported. Mesh does not have position vertex data`)}if(L.hasNormals){const o=L.getNormals(),u=D.getVerticesData(S.e.NormalKind);if(u){const L=new Float32Array(u.length);C=u.length/3,N=0;for(let P=N;P<C;++P){const j=A.r.ri(u,3*P).normalize();A.r.ri(o,3*P).normalize().subtractToRef(j,V),L[3*P]=V.x*g,L[3*P+1]=V.y,L[3*P+2]=V.z}const j=P.createBufferView(L,12),R=P.createAccessor(j,"VEC3",5126,o.length/3,0);Y.push(R),a.attributes.NORMAL=Y.length-1}else R.d.Warn(`Morph target normals for mesh ${j.name} were not exported. Mesh does not have normals vertex data`)}if(L.hasTangents){const o=L.getTangents(),u=D.getVerticesData(S.e.TangentKind);if(u){C=u.length/4;const L=new Float32Array(3*C);N=0;for(let P=N;P<C;++P){const j=A.r.ri(u,4*P);O(j);const R=A.r.ri(o,3*P);O(R),R.subtractToRef(j,V),L[3*P]=V.x*g,L[3*P+1]=V.y,L[3*P+2]=V.z}const j=P.createBufferView(L,12),R=P.createAccessor(j,"VEC3",5126,C,0);Y.push(R),a.attributes.TANGENT=Y.length-1}else R.d.Warn(`Morph target tangents for mesh ${j.name} were not exported. Mesh does not have tangents vertex data`)}if(L.hasColors){const o=L.getColors(),u=D.getVerticesData(S.e.ColorKind),g=D.getVertexBuffer(S.e.ColorKind);if(u&&g){const L=g.getSize();C=u.length/L;const j=new Float32Array(C*L);N=0;for(let P=N;P<C;++P)if(3===L){const R=A.r.ri(u,P*L);A.r.ri(o,P*L).subtractToRef(R,V),j[3*P]=V.x,j[3*P+1]=V.y,j[3*P+2]=V.z}else if(4===L){const R=new A.s,Y=A.s.ri(u,P*L);A.s.ri(o,P*L).subtractToRef(Y,R),j[4*P]=R.x,j[4*P+1]=R.y,j[4*P+2]=R.z,j[4*P+3]=R.w}else R.d.Warn(`Unsupported number of components for color attribute: ${L}`);const D=P.createBufferView(j,4*L),S=P.createAccessor(D,3===L?"VEC3":"VEC4",5126,C,0);Y.push(S),a.attributes.COLOR_0=Y.length-1}else R.d.Warn(`Morph target colors for mesh ${j.name} were not exported. Mesh does not have colors vertex data`)}return a}var TL=P(11690),GL=P(11620),ML=P(11612),QL=P(606);class lL{}lL.DEFAULT_COLOR=f.e.White(),lL.DEFAULT_WIDTH_ATTENUATED=1,lL.DEFAULT_WIDTH=.1;var wL=P(2005),dL=P(11694);class cL{static ConvertPoints(L,j){if(L.length&&Array.isArray(L)&&"number"===typeof L[0])return[L];if(L.length&&Array.isArray(L[0])&&"number"===typeof L[0][0])return L;if(L.length&&!Array.isArray(L[0])&&L[0]instanceof A.r){const j=[];for(let P=0;P<L.length;P++){const A=L[P];j.push(A.x,A.y,A.z)}return[j]}if(L.length>0&&Array.isArray(L[0])&&L[0].length>0&&L[0][0]instanceof A.r){const j=[],P=L;for(const L of P)j.push(L.flatMap((L=>[L.x,L.y,L.z])));return j}if(L instanceof Float32Array){if(null!==j&&void 0!==j&&j.floatArrayStride){const P=[],A=3*j.floatArrayStride;for(let j=0;j<L.length;j+=A){const R=new Array(A);for(let P=0;P<A;P++)R[P]=L[j+P];P.push(R)}return P}return[Array.from(L)]}if(L.length&&L[0]instanceof Float32Array){const j=[];for(const P of L)j.push(Array.from(P));return j}return[]}static OmitZeroLengthPredicate(L,j,P){const A=[];return j.xg(L).lengthSquared()>0&&A.push([L,j]),P.xg(j).lengthSquared()>0&&A.push([j,P]),L.xg(P).lengthSquared()>0&&A.push([P,L]),0===A.length?null:A}static OmitDuplicatesPredicate(L,j,P,A){const R=[];return cL._SearchInPoints(L,j,A)||R.push([L,j]),cL._SearchInPoints(j,P,A)||R.push([j,P]),cL._SearchInPoints(P,L,A)||R.push([P,L]),0===R.length?null:R}static _SearchInPoints(L,j,P){for(const Y of P)for(let P=0;P<Y.length;P++){var A,R,o;if(null!==(A=Y[P])&&void 0!==A&&A.equals(L))if(null!==(R=Y[P+1])&&void 0!==R&&R.equals(j)||null!==(o=Y[P-1])&&void 0!==o&&o.equals(j))return!0}return!1}static MeshesToLines(L,j){const P=[];for(let R=0;R<L.length;R++){const o=L[R],Y=o.getVerticesData(S.e.PositionKind),u=o.zi();if(Y&&u)for(let L=0,a=0;L<u.length;L++){const D=3*u[a++],S=3*u[a++],g=3*u[a++],V=new A.r(Y[D],Y[D+1],Y[D+2]),N=new A.r(Y[S],Y[S+1],Y[S+2]),C=new A.r(Y[g],Y[g+1],Y[g+2]);if(j){const A=j(V,N,C,P,L,D,o,R,Y,u);if(A)for(const L of A)P.push(L)}else P.push([V,N],[N,C],[C,V])}}return P}static ToVector3Array(L){if(Array.isArray(L[0])){const j=[],P=L;for(const L of P){const P=[];for(let j=0;j<L.length;j+=3)P.push(new A.r(L[j],L[j+1],L[j+2]));j.push(P)}return j}const j=L,P=[];for(let R=0;R<j.length;R+=3)P.push(new A.r(j[R],j[R+1],j[R+2]));return P}static ToNumberArray(L){return L.flatMap((L=>[L.x,L.y,L.z]))}static GetPointsCountInfo(L){const j=new Array(L.length);let P=0;for(let A=L.length;A--;)j[A]=L[A].length/3,P+=j[A];return{total:P,counts:j}}static GetLineLength(L){if(0===L.length)return 0;let j;j="number"===typeof L[0]?cL.ToVector3Array(L):L;const P=A.m.ti[0];let R=0;for(let A=0;A<j.length-1;A++){const L=j[A];R+=j[A+1].subtractToRef(L,P).length()}return R}static GetLineLengthArray(L){const j=new Float32Array(L.length/3);let P=0;for(let A=0,R=L.length/3-1;A<R;A++){let R=L[3*A+0],o=L[3*A+1],Y=L[3*A+2];R-=L[3*A+3],o-=L[3*A+4],Y-=L[3*A+5];P+=Math.sqrt(R*R+o*o+Y*Y),j[A+1]=P}return j}static SegmentizeSegmentByCount(L,j,P){const R=[],o=j.xg(L),Y=A.m.ti[0];Y.si(P);const u=A.m.ti[1];o.divideToRef(Y,u);let a=L.clone();R.push(a);for(let A=0;A<P;A++)a=a.clone(),R.push(a.addInPlace(u));return R}static SegmentizeLineBySegmentLength(L,j){const P=L[0]instanceof A.r?cL.GetLineSegments(L):"number"===typeof L[0]?cL.GetLineSegments(cL.ToVector3Array(L)):L,R=[];for(const A of P)if(A.length>j){const L=cL.SegmentizeSegmentByCount(A.point1,A.point2,Math.ceil(A.length/j));for(const j of L)R.push(j)}else R.push(A.point1),R.push(A.point2);return R}static SegmentizeLineBySegmentCount(L,j){const P="number"===typeof L[0]?cL.ToVector3Array(L):L,A=cL.GetLineLength(P)/j;return cL.SegmentizeLineBySegmentLength(P,A)}static GetLineSegments(L){const j=[];for(let P=0;P<L.length-1;P++){const A=L[P],R=L[P+1],o=R.xg(A).length();j.push({point1:A,point2:R,length:o})}return j}static GetMinMaxSegmentLength(L){const j=cL.GetLineSegments(L).sort((L=>L.length));return{min:j[0].length,max:j[j.length-1].length}}static GetPositionOnLineByVisibility(L,j,P){let R=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const o=j*P;let Y=0,u=0;const a=L.length;for(let A=0;A<a;A++){if(o<=Y+L[A].length){u=A;break}Y+=L[A].length}const D=(o-Y)/L[u].length;return L[u].point2.subtractToRef(L[u].point1,A.m.ti[0]),A.m.ti[1]=A.m.ti[0].multiplyByFloats(D,D,D),R||A.m.ti[1].addInPlace(L[u].point1),A.m.ti[1].clone()}static GetCircleLinePoints(L,j){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,R=arguments.length>3&&void 0!==arguments[3]?arguments[3]:L,o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/j;const Y=[];for(let u=0;u<=j;u++)Y.push(new A.r(Math.cos(u*o)*L,Math.sin(u*o)*R,P));return Y}static GetBezierLinePoints(L,j,P,A){return wL.d.CreateQuadraticBezier(L,j,P,A).getPoints().flatMap((L=>[L.x,L.y,L.z]))}static GetArrowCap(L,j,P,A,R){let o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[L.clone(),L.add(j.multiplyByFloats(P,P,P))],widths:[A,R,o,Y]}}static GetPointsFromText(L,j,P,A){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,o=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],u=(0,dL.d)(L,j,P,A);for(const a of u){for(const L of a.paths){const j=[],P=L.getPoints();for(const L of P)j.push(L.x,L.y,R);Y.push(j)}if(o)for(const L of a.holes){const j=[],P=L.getPoints();for(const L of P)j.push(L.x,L.y,R);Y.push(j)}}return Y}static Color3toRGBAUint8(L){const j=new Uint8Array(4*L.length);for(let P=0,A=0;P<L.length;P++)j[A++]=255*L[P].r,j[A++]=255*L[P].g,j[A++]=255*L[P].b,j[A++]=255;return j}static CreateColorsTexture(L,j,P,A){const R=A.getEngine().getCaps().maxTextureSize??1,o=j.length>R?R:j.length,Y=Math.ceil(j.length/R);Y>1&&(j=[...j,...Array(o*Y-j.length).fill(j[0])]);const u=cL.Color3toRGBAUint8(j),a=new T.c(u,o,Y,C.d.TEXTUREFORMAT_RGBA,A,!1,!0,P);return a.name=L,a}static PrepareEmptyColorsTexture(L){if(!lL.EmptyColorsTexture){const j=new Uint8Array(4);lL.EmptyColorsTexture=new T.c(j,1,1,C.d.TEXTUREFORMAT_RGBA,L,!1,!1,T.c.NEAREST_NEAREST),lL.EmptyColorsTexture.name="grlEmptyColorsTexture"}return lL.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var L;null===(L=lL.EmptyColorsTexture)||void 0===L||L.dispose(),lL.EmptyColorsTexture=null}static BooleanToNumber(L){return L?1:0}}class EL extends ML.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class UL extends GL.c{isCompatible(L){return!0}constructor(L,j,P){var R;P=P||{color:lL.DEFAULT_COLOR};const o=new EL;o.GREASED_LINE_HAS_COLOR=!!P.color&&!P.useColors,o.GREASED_LINE_SIZE_ATTENUATION=P.sizeAttenuation??!1,o.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===P.colorDistributionType,o.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(j??L.va()).useRightHandedSystem,o.GREASED_LINE_CAMERA_FACING=P.cameraFacing??!0,super(L,UL.GREASED_LINE_MATERIAL_NAME,200,o,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(R=P)||void 0===R?void 0:R.forceGLSL)||UL.ForceGLSL,this._scene=j??L.va(),this._engine=this._scene.getEngine(),this._cameraFacing=P.cameraFacing??!0,this.visibility=P.visibility??1,this.useDash=P.useDash??!1,this.dashRatio=P.dashRatio??.5,this.dashOffset=P.dashOffset??0,this.width=P.width?P.width:P.sizeAttenuation?lL.DEFAULT_WIDTH_ATTENUATED:lL.DEFAULT_WIDTH,this._sizeAttenuation=P.sizeAttenuation??!1,this.colorMode=P.colorMode??0,this._color=P.color??null,this.useColors=P.useColors??!1,this._colorsDistributionType=P.colorDistributionType??0,this.colorsSampling=P.colorsSampling??T.c.NEAREST_NEAREST,this._colors=P.za??null,this.dashCount=P.dashCount??1,this.resolution=P.resolution??new A.n(this._engine.getRenderWidth(),this._engine.getRenderHeight()),P.colorsTexture?this.colorsTexture=P.colorsTexture:this._colors?this.colorsTexture=cL.CreateColorsTexture(`${L.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??lL.DEFAULT_COLOR,cL.PrepareEmptyColorsTexture(this._scene)),this._engine.Oi.add((()=>{cL.DisposeEmptyColorsTexture()}))}getAttributes(L){L.push("grl_offsets"),L.push("grl_widths"),L.push("grl_colorPointers"),L.push("grl_counters"),this._cameraFacing?(L.push("grl_previousAndSide"),L.push("grl_nextAndCounters")):L.push("grl_slopes")}getSamplers(L){L.push("grl_colors")}getActiveTextures(L){this.colorsTexture&&L.push(this.colorsTexture)}getUniforms(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const j=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&j.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===L&&j.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:j,vertex:this._cameraFacing&&this._isGLSL(L)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(L)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(L){if(this._cameraFacing){L.cj("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||L.cj("viewProjection",this._scene.getTransformMatrix());const j=A.m.Vector4[0];j.x=this._aspect,j.y=this._resolution.x,j.z=this._resolution.y,j.w=this.width,L.updateVector4("grl_aspect_resolution_lineWidth",j)}const j=A.m.Vector4[0];j.x=cL.BooleanToNumber(this.useDash),j.y=this._dashArray,j.z=this.dashOffset,j.w=this.dashRatio,L.updateVector4("grl_dashOptions",j);const P=A.m.Vector4[1];P.x=this.colorMode,P.y=this.visibility,P.z=this.colorsTexture?this.colorsTexture.getSize().width:0,P.w=cL.BooleanToNumber(this.useColors),L.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",P),this._color&&L.updateColor3("grl_singleColor",this._color);const R=this.colorsTexture??lL.EmptyColorsTexture;L.setTexture("grl_colors",R),L.updateFloat2("grl_textureSize",(null===R||void 0===R?void 0:R.getSize().width)??1,(null===R||void 0===R?void 0:R.getSize().height)??1)}prepareDefines(L,j,P){L.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,L.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=j.useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=this._cameraFacing,L.GREASED_LINE_USE_OFFSETS=!!P.offsets}getClassName(){return UL.GREASED_LINE_MATERIAL_NAME}getCustomCode(L){let j=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(j)?function(L,j){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return j&&(L["!gl_Position\\=viewProjection\\*worldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(L,this._cameraFacing):function(L,j){if("vertex"===L){const L={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return j&&(L["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),L}return"fragment"===L?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(L,this._cameraFacing)}dispose(){var L;null===(L=this.colorsTexture)||void 0===L||L.dispose(),super.dispose()}get za(){return this._colors}set za(L){this.setColors(L)}setColors(L){var j;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=(null===(j=this._colors)||void 0===j?void 0:j.length)??0;var o;if(this._colors=L,null!==L&&0!==L.length){if(!P||A)if(this.colorsTexture&&R===L.length&&!A){const j=cL.Color3toRGBAUint8(L);this.colorsTexture.update(j)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=cL.CreateColorsTexture(`${this._material.name}-colors-texture`,L,this.colorsSampling,this._scene)}}else null===(o=this.colorsTexture)||void 0===o||o.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.markAllDefinesAsDirty()}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==L||null!==this._color&&null===L?(this._color=L,j||this.markAllDefinesAsDirty()):this._color=L}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(L){this._aspect=L.x/L.y,this._resolution=L}serialize(){const L=super.serialize(),j={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(j.za=this._colors),this._color&&(j.color=this._color),L.greasedLineMaterialOptions=j,L}parse(L,j,P){var A;super.parse(L,j,P);const R=L.greasedLineMaterialOptions;null===(A=this.colorsTexture)||void 0===A||A.dispose(),R.color&&this.setColor(R.color,!0),R.colorDistributionType&&(this.colorsDistributionType=R.colorDistributionType),R.za&&(this.za=R.za),R.colorsSampling&&(this.colorsSampling=R.colorsSampling),R.colorMode&&(this.colorMode=R.colorMode),R.useColors&&(this.useColors=R.useColors),R.visibility&&(this.visibility=R.visibility),R.useDash&&(this.useDash=R.useDash),R.dashCount&&(this.dashCount=R.dashCount),R.dashRatio&&(this.dashRatio=R.dashRatio),R.dashOffset&&(this.dashOffset=R.dashOffset),R.width&&(this.width=R.width),R.sizeAttenuation&&(this.sizeAttenuation=R.sizeAttenuation),R.resolution&&(this.resolution=R.resolution),this.za?this.colorsTexture=cL.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,j):cL.PrepareEmptyColorsTexture(j),this.markAllDefinesAsDirty()}copyTo(L){var j;const P=L;null===(j=P.colorsTexture)||void 0===j||j.dispose(),this._colors&&(P.colorsTexture=cL.CreateColorsTexture(`${P._material.name}-colors-texture`,this._colors,P.colorsSampling,this._scene)),P.setColor(this.color,!0),P.colorsDistributionType=this.colorsDistributionType,P.colorsSampling=this.colorsSampling,P.colorMode=this.colorMode,P.useColors=this.useColors,P.visibility=this.visibility,P.useDash=this.useDash,P.dashCount=this.dashCount,P.dashRatio=this.dashRatio,P.dashOffset=this.dashOffset,P.width=this.width,P.sizeAttenuation=this.sizeAttenuation,P.resolution=this.resolution,P.markAllDefinesAsDirty()}_isGLSL(L){return 0===L||this._forceGLSL}}UL.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",UL.ForceGLSL=!1,(0,QL.h)(`BABYLON.${UL.GREASED_LINE_MATERIAL_NAME}`,UL);var tL=P(722),BL=P(496),FL=P(11692),XL=P(598);class HL extends FL.c{constructor(L,j,R){const o=j.getEngine(),Y=o.isWebGPU&&!(R.forceGLSL||HL.ForceGLSL),u=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];j.useRightHandedSystem&&u.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const a=["position","grl_widths","grl_offsets","grl_colorPointers"];R.cameraFacing?(u.push("GREASED_LINE_CAMERA_FACING"),a.push("grl_previousAndSide","grl_nextAndCounters")):(a.push("grl_slopes"),a.push("grl_counters"));const D=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||D.push("world","viewProjection","view","projection"),super(L,j,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:a,uniforms:D,samplers:Y?[]:["grlColors"],defines:u,extraInitializationsAsync:async()=>{Y?await Promise.all([P.e(51).then(P.bind(P,13685)),P.e(59).then(P.bind(P,13688))]):await Promise.all([P.e(54).then(P.bind(P,13692)),P.e(60).then(P.bind(P,13699))])},shaderLanguage:Y?1:0}),this._color=f.e.White(),this._colorsDistributionType=0,this._colorsTexture=null,R=R||{color:lL.DEFAULT_COLOR},this.visibility=R.visibility??1,this.useDash=R.useDash??!1,this.dashRatio=R.dashRatio??.5,this.dashOffset=R.dashOffset??0,this.dashCount=R.dashCount??1,this.width=R.width?R.width:R.sizeAttenuation&&R.cameraFacing?lL.DEFAULT_WIDTH_ATTENUATED:lL.DEFAULT_WIDTH,this.sizeAttenuation=R.sizeAttenuation??!1,this.color=R.color??f.e.White(),this.useColors=R.useColors??!1,this.colorsDistributionType=R.colorDistributionType??0,this.colorsSampling=R.colorsSampling??T.c.NEAREST_NEAREST,this.colorMode=R.colorMode??0,this._colors=R.za??null,this._cameraFacing=R.cameraFacing??!0,this.resolution=R.resolution??new A.n(o.getRenderWidth(),o.getRenderHeight()),R.colorsTexture?this.colorsTexture=R.colorsTexture:this._colors?this.colorsTexture=cL.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,j):(this._color=this._color??lL.DEFAULT_COLOR,this.colorsTexture=cL.PrepareEmptyColorsTexture(j)),Y){const L=new XL.d;L.setParameters(),L.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",L)}o.Oi.add((()=>{cL.DisposeEmptyColorsTexture()}))}dispose(){var L;null===(L=this._colorsTexture)||void 0===L||L.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new A.n(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(L){this.setColors(L)}setColors(L){var j;let P=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const R=(null===(j=this._colors)||void 0===j?void 0:j.length)??0;var o;if(this._colors=L,null!==L&&0!==L.length){if(!P||A)if(this._colorsTexture&&R===L.length&&!A){const j=cL.Color3toRGBAUint8(L);this._colorsTexture.update(j)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=cL.CreateColorsTexture(`${this.name}-colors-texture`,L,this.colorsSampling,this.va())}}else null===(o=this._colorsTexture)||void 0===o||o.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(L){this._colorsTexture=L,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(L){this._width=L,this.setFloat("grlWidth",L)}get useColors(){return this._useColors}set useColors(L){this._useColors=L,this.setFloat("grlUseColors",cL.BooleanToNumber(L))}get colorsSampling(){return this._colorsSampling}set colorsSampling(L){this._colorsSampling=L}get visibility(){return this._visibility}set visibility(L){this._visibility=L,this.setFloat("grlVisibility",L)}get useDash(){return this._useDash}set useDash(L){this._useDash=L,this.setFloat("grlUseDash",cL.BooleanToNumber(L))}get dashOffset(){return this._dashOffset}set dashOffset(L){this._dashOffset=L,this.setFloat("grlDashOffset",L)}get dashRatio(){return this._dashRatio}set dashRatio(L){this._dashRatio=L,this.setFloat("grlDashRatio",L)}get dashCount(){return this._dashCount}set dashCount(L){this._dashCount=L,this._dashArray=1/L,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(L){this._sizeAttenuation=L,this.setFloat("grlSizeAttenuation",cL.BooleanToNumber(L))}get color(){return this._color}set color(L){this.setColor(L)}setColor(L){L=L??lL.DEFAULT_COLOR,this._color=L,this.setColor3("grlColor",L)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(L){this._colorsDistributionType=L,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(L){this._colorMode=L,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(L){this._resolution=L,this.setVector2("grlResolution",L),this.setFloat("grlAspect",L.x/L.y)}serialize(){const L=super.serialize(),j={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(j.za=this._colors),L.greasedLineMaterialOptions=j,L}parse(L,j,P){var A;const R=L.greasedLineMaterialOptions;null===(A=this._colorsTexture)||void 0===A||A.dispose(),R.color&&(this.color=R.color),R.colorDistributionType&&(this.colorsDistributionType=R.colorDistributionType),R.colorsSampling&&(this.colorsSampling=R.colorsSampling),R.colorMode&&(this.colorMode=R.colorMode),R.useColors&&(this.useColors=R.useColors),R.visibility&&(this.visibility=R.visibility),R.useDash&&(this.useDash=R.useDash),R.dashCount&&(this.dashCount=R.dashCount),R.dashRatio&&(this.dashRatio=R.dashRatio),R.dashOffset&&(this.dashOffset=R.dashOffset),R.width&&(this.width=R.width),R.sizeAttenuation&&(this.sizeAttenuation=R.sizeAttenuation),R.resolution&&(this.resolution=R.resolution),R.za?this.colorsTexture=cL.CreateColorsTexture(`${this.name}-colors-texture`,R.za,this.colorsSampling,this.va()):this.colorsTexture=cL.PrepareEmptyColorsTexture(j),this._cameraFacing=R.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var WL,eL,sL;HL.ForceGLSL=!1,function(L){L[L.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",L[L.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(WL||(WL={})),function(L){L[L.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",L[L.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",L[L.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(eL||(eL={})),function(L){L[L.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",L[L.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",L[L.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",L[L.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",L[L.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(sL||(sL={}));class mL extends KL.e{constructor(L,j,P){super(L,j,null,null,!1,!1),this.name=L,this._options=P,this._lazy=!1,this._updatable=!1,this._engine=j.getEngine(),this._lazy=P.lazy??!1,this._updatable=P.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=P.colorPointers??[],this._widths=P.widths??new Array(P.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(L){let j=0;for(const A of this._points)j+=A.length;const P=j/3*2-this._widths.length;for(let A=0;A<P;A++)this._widths.push(L)}updateLazy(){var L,j;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(L=this._options.ribbonOptions)||void 0===L?void 0:L.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(j=this.greasedLineMaterial)||void 0===j||j.updateLazy()}addPoints(L,j){for(const P of L)this._points.push(P);this._lazy||this.setPoints(this._points,j)}dispose(L){let j=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(L,j)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(L){this._uvs=L instanceof Float32Array?L:new Float32Array(L),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(L){this.material instanceof HL&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===L||void 0===L?void 0:L.length)>0),this._offsets=L,this._offsetsBuffer?this._offsetsBuffer.update(L):this._createOffsetsBuffer(L)}get widths(){return this._widths}set widths(L){this._widths=L,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(L)}get colorPointers(){return this._colorPointers}set colorPointers(L){this._colorPointers=L,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(L)}get greasedLineMaterial(){var L,j;if(this.material&&this.material instanceof HL)return this.material;const P=null===(L=this.material)||void 0===L||null===(j=L.pluginManager)||void 0===j?void 0:j.getPlugin(UL.GREASED_LINE_MATERIAL_NAME);return P||void 0}get points(){const L=[];return BL.b.DeepCopy(this._points,L),L}setPoints(L,j){this._points=cL.ConvertPoints(L,(null===j||void 0===j?void 0:j.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==j&&void 0!==j&&j.colorPointers||this._updateColorPointers(),this._setPoints(this._points,j)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(L){super.serialize(L),L.type=this.getClassName(),L.lineOptions=this._createLineOptions()}_createVertexBuffers(){let L=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const j=new tL.d;return j.xa=this._vertexPositions,j.indices=this._indices,j.Aa=this._uvs,L&&(j.ya=[],tL.d.ComputeNormals(this._vertexPositions,this._indices,j.ya)),j.Ca(this,this._options.updatable),j}_createOffsetsBuffer(L){const j=this._scene.getEngine(),P=new S.c(j,L,this._updatable,3);this.setVerticesBuffer(P.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=P}}class xL{constructor(L,j){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=L,this.wasAddedByNoopNode=j}getIndicesAccessor(L,j,P,A,R){var o,Y,u,a;return null===(o=this._indicesAccessorMap.get(L))||void 0===o||null===(Y=o.get(j))||void 0===Y||null===(u=Y.get(P))||void 0===u||null===(a=u.get(A))||void 0===a?void 0:a.get(R)}setIndicesAccessor(L,j,P,A,R,o){let Y=this._indicesAccessorMap.get(L);Y||(Y=new Map,this._indicesAccessorMap.set(L,Y));let u=Y.get(j);u||(u=new Map,Y.set(j,u));let a=u.get(P);a||(a=new Map,u.set(P,a));let D=a.get(A);D||(D=new Map,a.set(A,D)),D.set(R,o)}pushExportedNode(L){this._exportedNodes.has(L)||this._exportedNodes.add(L)}getNodesSet(){return this._exportedNodes}getVertexBufferView(L){return this._vertexBufferViewMap.get(L)}setVertexBufferView(L,j){this._vertexBufferViewMap.set(L,j)}setRemappedBufferView(L,j,P){this._remappedBufferView.set(L,new Map),this._remappedBufferView.get(L).set(j,P)}getRemappedBufferView(L,j){var P;return null===(P=this._remappedBufferView.get(L))||void 0===P?void 0:P.get(j)}getVertexAccessor(L,j,P){var A,R;return null===(A=this._vertexAccessorMap.get(L))||void 0===A||null===(R=A.get(j))||void 0===R?void 0:R.get(P)}setVertexAccessor(L,j,P,A){let R=this._vertexAccessorMap.get(L);R||(R=new Map,this._vertexAccessorMap.set(L,R));let o=R.get(j);o||(o=new Map,R.set(j,o)),o.set(P,A)}hasVertexColorAlpha(L){return this._vertexMapColorAlpha.get(L)||!1}setHasVertexColorAlpha(L,j){return this._vertexMapColorAlpha.set(L,j)}getMesh(L){return this._meshMap.get(L)}setMesh(L,j){this._meshMap.set(L,j)}bindMorphDataToMesh(L,j){const P=this._meshMorphTargetMap.get(L)||[];this._meshMorphTargetMap.set(L,P),-1===P.indexOf(j)&&P.push(j)}getMorphTargetsFromMesh(L){return this._meshMorphTargetMap.get(L)}}class kL{_ApplyExtension(L,j,P,A){if(P>=j.length)return Promise.resolve(L);const R=A(j[P],L);return R?R.then((async L=>L?await this._ApplyExtension(L,j,P+1,A):null)):this._ApplyExtension(L,j,P+1,A)}_ApplyExtensions(L,j){const P=[];for(const A of kL._ExtensionNames)P.push(this._extensions[A]);return this._ApplyExtension(L,P,0,j)}_extensionsPreExportTextureAsync(L,j,P){return this._ApplyExtensions(j,((j,A)=>j.preExportTextureAsync&&j.preExportTextureAsync(L,A,P)))}_extensionsPostExportNodeAsync(L,j,P,A,R){return this._ApplyExtensions(j,((j,o)=>j.postExportNodeAsync&&j.postExportNodeAsync(L,o,P,A,R,this._bufferManager)))}_extensionsPostExportMaterialAsync(L,j,P){return this._ApplyExtensions(j,((j,A)=>j.postExportMaterialAsync&&j.postExportMaterialAsync(L,A,P)))}_extensionsPostExportMaterialAdditionalTextures(L,j,P){const A=[];for(const R of kL._ExtensionNames){const o=this._extensions[R];o.postExportMaterialAdditionalTextures&&A.push(...o.postExportMaterialAdditionalTextures(L,j,P))}return A}_extensionsPostExportTextures(L,j,P){for(const A of kL._ExtensionNames){const R=this._extensions[A];R.postExportTexture&&R.postExportTexture(L,j,P)}}_extensionsPostExportMeshPrimitive(L){for(const j of kL._ExtensionNames){const P=this._extensions[j];P.postExportMeshPrimitive&&P.postExportMeshPrimitive(L,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const L of kL._ExtensionNames){const j=this._extensions[L];j.preGenerateBinaryAsync&&await j.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(L){for(const j of kL._ExtensionNames){const P=this._extensions[j];P.enabled&&L(P)}}_extensionsOnExporting(){this._forEachExtensions((L=>{var j,P,A;L.wasUsed&&((j=this._glTF).extensionsUsed||(j.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(L.name)&&this._glTF.extensionsUsed.push(L.name),L.required&&((P=this._glTF).extensionsRequired||(P.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(L.name)&&this._glTF.extensionsRequired.push(L.name)),(A=this._glTF).extensions||(A.extensions={}),L.onExporting&&L.onExporting())}))}_loadExtensions(){for(const L of kL._ExtensionNames){const j=kL._ExtensionFactories[L](this);this._extensions[L]=j}}constructor(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:b.b.LastCreatedScene,j=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${C.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new X(this),this._extensions={},this._bufferManager=new SL,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!L)throw new Error("No scene available to export");this._babylonScene=L,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:L=>{var j;return null===L||void 0===L||null===(j=L.Li)||void 0===j?void 0:j.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...j},this._loadExtensions()}dispose(){for(const L in this._extensions){this._extensions[L].dispose()}}get options(){return this._options}static RegisterExtension(L,j){kL.UnregisterExtension(L)&&R.d.Warn(`Extension with the name ${L} already exists`),kL._ExtensionFactories[L]=j,kL._ExtensionNames.push(L)}static UnregisterExtension(L){if(!kL._ExtensionFactories[L])return!1;delete kL._ExtensionFactories[L];const j=kL._ExtensionNames.indexOf(L);return-1!==j&&kL._ExtensionNames.splice(j,1),!0}_generateJSON(L,j,P){const A={byteLength:L};return A.byteLength&&(this._glTF.buffers=[A]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Rk=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(A.uri=j+".bin"),P?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(L){const j=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(j.byteLength,L,!0),A=new Blob([j],{type:"application/octet-stream"}),R=L+".gltf",o=L+".bin",Y=new D;if(Y.files[R]=P,Y.files[o]=A,this._imageData)for(const u in this._imageData)Y.files[u]=new Blob([this._imageData[u].data],{type:this._imageData[u].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(L){const j=L%4;return 0===j?j:4-j}async generateGLBAsync(L){this._shouldUseGlb=!0;const j=await this._generateBinaryAsync();this._extensionsOnExporting();const P=this._generateJSON(j.byteLength),A=L+".glb";let R,o=P.length;if("undefined"!==typeof TextEncoder){R=(new TextEncoder).encode(P),o=R.length}const Y=this._getPadding(o),u=this._getPadding(j.byteLength),a=28+o+Y+j.byteLength+u,S=new aL(a);if(S.writeUInt32(1179937895),S.writeUInt32(2),S.writeUInt32(a),S.writeUInt32(o+Y),S.writeUInt32(1313821514),R)S.writeTypedArray(R);else{const L="_".charCodeAt(0);for(let j=0;j<o;++j){const A=P.charCodeAt(j);A!=P.codePointAt(j)?S.writeUInt8(L):S.writeUInt8(A)}}for(let D=0;D<Y;++D)S.writeUInt8(32);S.writeUInt32(j.byteLength+u),S.writeUInt32(5130562),S.writeTypedArray(j);for(let D=0;D<u;++D)S.writeUInt8(0);const g=new D;return g.files[A]=new Blob([S.getOutputData()],{type:"application/octet-stream"}),g}_setNodeTransformation(L,j,P){if(j.getPivotPoint().equalsWithEpsilon(m,s.c)||R.d.Warn("Pivot points are not supported in the glTF serializer"),!j.position.equalsWithEpsilon(m,s.c)){const R=A.m.ti[0].p(j.position);P&&i(R),L.translation=R.Ei()}j.mi.equalsWithEpsilon(k,s.c)||(L.scale=j.mi.Ei());const o=j.rotationQuaternion||A.i.FromEulerAngles(j.rotation.x,j.rotation.y,j.rotation.z);o.equalsWithEpsilon(x,s.c)||(P&&J(o),L.rotation=o.normalize().Ei())}_setCameraTransformation(L,j,P){if(!j.position.equalsWithEpsilon(m,s.c)){const R=A.m.ti[0].p(j.position);P&&i(R),L.translation=R.Ei()}const R=j.rotationQuaternion||A.i.FromEulerAngles(j.rotation.x,j.rotation.y,j.rotation.z);P&&J(R),this._babylonScene.useRightHandedSystem||r(R),R.equalsWithEpsilon(x,s.c)||(L.rotation=R.Ei())}_listAvailableCameras(){for(const L of this._babylonScene.cameras){const j={type:L.mode===VL.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(L.name&&(j.name=L.name),"perspective"===j.type)j.perspective={aspectRatio:L.getEngine().getAspectRatio(L),yfov:L.fovMode===VL.e.FOVMODE_VERTICAL_FIXED?L.fov:L.fov*L.getEngine().getAspectRatio(L),znear:L.Ai,zfar:L.maxZ};else if("orthographic"===j.type){const P=L.orthoLeft&&L.orthoRight?.5*(L.orthoRight-L.orthoLeft):.5*L.getEngine().getRenderWidth(),A=L.orthoBottom&&L.orthoTop?.5*(L.orthoTop-L.orthoBottom):.5*L.getEngine().getRenderHeight();j.orthographic={xmag:P,ymag:A,znear:L.Ai,zfar:L.maxZ}}this._camerasMap.set(L,j)}}_exportAndAssignCameras(){const L=Array.from(this._camerasMap.values());for(const j of L){const L=this._nodesCameraMap.get(j);if(void 0!==L){this._cameras.push(j);for(const j of L)j.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const j={joints:[]};this._skinMap.set(L,j)}}_exportAndAssignSkeletons(){for(const L of this._babylonScene.skeletons){if(L.bones.length<=0)continue;const j=this._skinMap.get(L);if(void 0==j)continue;const P={},A=[];let o=-1;for(let R=0;R<L.bones.length;++R){const j=L.bones[R],A=j.getIndex()??R;-1!==A&&(P[A]=j,A>o&&(o=A))}for(let L=0;L<=o;++L){const o=P[L];A.push(o.getAbsoluteInverseBindMatrix());const Y=o.getTransformNode();if(null!==Y){const L=this._nodeMap.get(Y);Y&&null!==L&&void 0!==L?j.joints.push(L):R.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}else R.d.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(j);if(j.joints.length>0&&void 0!==Y){const L=64*A.length,P=new Float32Array(L/4);A.forEach(((L,j)=>{P.set(L.m,16*j)}));const R=this._bufferManager.createBufferView(P);this._accessors.push(this._bufferManager.createAccessor(R,"MAT4",5126,A.length)),j.inverseBindMatrices=this._accessors.length-1,this._skins.push(j);for(const j of Y)j.skin=this._skins.length-1}}}async _exportSceneAsync(){const L={nodes:[]};if(this._babylonScene.metadata){const j=this._options.metadataSelector(this._babylonScene.metadata);j&&(L.extras=j)}const j=new Array,P=new Array,A=new Array;for(const u of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&YL(u,this._babylonScene.useRightHandedSystem)?A.push(...u.getChildren()):this._babylonScene.useRightHandedSystem?j.push(u):P.push(u);this._listAvailableCameras(),this._listAvailableSkeletons();const R=new xL(!0,!1);L.nodes.push(...await this._exportNodesAsync(P,R));const o=new xL(!1,!1);L.nodes.push(...await this._exportNodesAsync(j,o));const Y=new xL(!1,!0);L.nodes.push(...await this._exportNodesAsync(A,Y)),L.nodes.length&&this._scenes.push(L),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&qL._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,R.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(L){let j=this._shouldExportNodeMap.get(L);return void 0===j&&(j=this._options.shouldExportNode(L),this._shouldExportNodeMap.set(L,j)),j}async _exportNodesAsync(L,j){const P=new Array;this._exportBuffers(L,j);for(const A of L)await this._exportNodeAsync(A,P,j);return P}_collectBuffers(L,j,P,A,R){if(this._shouldExportNode(L)&&L instanceof V.b&&L.ui){const o=L.ui.getVertexBuffers();if(o)for(const A in o){if(!n(A))continue;const Y=o[A];R.setHasVertexColorAlpha(Y,L.hasVertexAlpha);const u=Y._buffer,a=j.get(u)||[];j.set(u,a),-1===a.indexOf(Y)&&a.push(Y);const D=P.get(Y)||[];P.set(Y,D),-1===D.indexOf(L)&&D.push(L)}const Y=L.morphTargetManager;if(Y)for(let j=0;j<Y.numTargets;j++){const P=Y.getTarget(j),R=A.get(P)||[];A.set(P,R),-1===R.indexOf(L)&&R.push(L)}}for(const o of L.getChildren())this._collectBuffers(o,j,P,A,R)}_exportBuffers(L,j){const P=new Map,A=new Map,R=new Map;for(const u of L)this._collectBuffers(u,P,A,R,j);const o=Array.from(P.keys());for(const u of o){const L=u.getData();if(!L)throw new Error("Buffer data is not available");const R=P.get(u);if(!R)continue;const o=R[0].byteStride;if(R.some((L=>L.byteStride!==o)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=PL(L).slice();for(const j of R){const L=A.get(j),{byteOffset:P,byteStride:R,componentCount:o,type:u,count:a,normalized:D,kind:g}=z(j,L);switch(g){case S.e.NormalKind:case S.e.TangentKind:(0,H.g)(Y,P,R,o,u,a,D,(L=>{const j=Math.sqrt(L[0]*L[0]+L[1]*L[1]+L[2]*L[2]);if(j>0){const P=1/j;L[0]*=P,L[1]*=P,L[2]*=P}}));break;case S.e.ColorKind:{const j=L.filter((L=>L.material instanceof bL.e||null==L.material)).length;if(0==j)break;if(j!=L.length){W.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}u==S.e.UNSIGNED_BYTE&&W.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const A=new f.e,g=new f.i,V=this._babylonScene.getEngine().useExactSrgbConversions;(0,H.g)(Y,P,R,o,u,a,D,(L=>{3===L.length?(A.Vi(L,0),A.toLinearSpaceToRef(A,V),A.toArray(L,0)):(g.Vi(L,0),g.toLinearSpaceToRef(g,V),g.toArray(L,0))}))}}}if(j.convertToRightHanded){for(const L of R){const j=A.get(L),{byteOffset:P,byteStride:R,componentCount:o,type:u,count:a,normalized:D,kind:g}=z(L,j);switch(g){case S.e.PositionKind:case S.e.NormalKind:case S.e.TangentKind:(0,H.g)(Y,P,R,o,u,a,D,(L=>{L[0]=-L[0]}))}}j.convertedToRightHandedBuffers.set(u,Y)}const a=this._bufferManager.createBufferView(Y,o);j.setVertexBufferView(u,a);const D=new Map;for(const j of R){const L=A.get(j),{kind:P,totalVertices:R}=z(j,L);switch(P){case S.e.MatricesIndicesKind:case S.e.MatricesIndicesExtraKind:if(j.type==S.e.FLOAT){const L=j.getFloatData(R);null!==L&&D.set(j,L)}}}0!==D.size&&W.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const g=Array.from(D.keys());for(const P of g){const L=D.get(P);if(!L)continue;const A=L.some((L=>L>=256)),R=new(A?Uint16Array:Uint8Array)(L.length);for(let j=0;j<L.length;j++)R[j]=L[j];const o=this._bufferManager.createBufferView(R,4*(A?2:1));j.setRemappedBufferView(u,P,o)}}const Y=Array.from(R.keys());for(const u of Y){const L=R.get(u);if(!L)continue;const P=yL(u,L[0],this._bufferManager,this._bufferViews,this._accessors,j.convertToRightHanded);for(const A of L)j.bindMorphDataToMesh(A,P)}}async _exportNodeAsync(L,j,P){let A=this._nodeMap.get(L);if(void 0!==A)return void(j.includes(A)||j.push(A));const R=await this._createNodeAsync(L,P);if(R){A=this._nodes.length,this._nodes.push(R),this._nodeMap.set(L,A),P.pushExportedNode(L),j.push(A);const o={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(qL._CreateMorphTargetAnimationFromMorphTargetAnimations(L,o,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation),L.animations.length&&qL._CreateNodeAnimationFromNodeAnimations(L,o,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,P.convertToRightHanded,this._options.shouldExportAnimation)),o.channels.length&&o.samplers.length&&this._animations.push(o),Y.forEach((L=>{L.channels.length&&L.samplers.length&&this._animations.push(L)}))}const o=R?[]:j;for(const Y of L.getChildren())await this._exportNodeAsync(Y,o,P);R&&o.length&&(R.children=o)}async _createNodeAsync(L,j){if(!this._shouldExportNode(L))return null;const P={};if(L.name&&(P.name=L.name),L.metadata){const j=this._options.metadataSelector(L.metadata);j&&(P.extras=j)}if(L instanceof g.b&&(this._setNodeTransformation(P,L,j.convertToRightHanded),L instanceof V.b)){const R=L instanceof N.d?L.sourceMesh:L;if(R.Bi&&R.Bi.length>0&&(P.mesh=await this._exportMeshAsync(R,j)),L.skeleton){const j=this._skinMap.get(L.skeleton);var A;if(void 0!==j)void 0===this._nodesSkinMap.get(j)&&this._nodesSkinMap.set(j,[]),null===(A=this._nodesSkinMap.get(j))||void 0===A||A.push(P)}}if(L instanceof e.d){const A=this._camerasMap.get(L);if(A){var R;void 0===this._nodesCameraMap.get(A)&&this._nodesCameraMap.set(A,[]),this._setCameraTransformation(P,L,j.convertToRightHanded);const Y=L.parent;if(null!==Y&&jL(L,Y)){const L=this._nodeMap.get(Y);if(void 0!==L){var o;const j=this._nodes[L];return LL(P,j),null===(o=this._nodesCameraMap.get(A))||void 0===o||o.push(j),null}}null===(R=this._nodesCameraMap.get(A))||void 0===R||R.push(P)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",P,L,this._nodeMap,j.convertToRightHanded)?P:(W.e.Warn(`Not exporting node ${L.name}`),null)}_exportIndices(L,j,P,A,R,Y,u,a,D){let S=L;D.mode=Z(Y);const g=u!==o.c.CounterClockWiseSideOrientation,V=!a.wasAddedByNoopNode&&g,N=function(L){switch(L){case o.c.TriangleFillMode:case o.c.TriangleStripDrawMode:case o.c.TriangleFanDrawMode:return!0}return!1}(Y)&&V;if(N){if(Y===o.c.TriangleStripDrawMode||Y===o.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");D.mode=Z(Y);const u=j?new Uint32Array(A):new Uint16Array(A);if(L)for(let j=0;j+2<A;j+=3)u[j]=L[P+j]+R,u[j+1]=L[P+j+2]+R,u[j+2]=L[P+j+1]+R;else for(let L=0;L+2<A;L+=3)u[L]=L,u[L+1]=L+2,u[L+2]=L+1;S=u}else if(L&&0!==R){const o=j?new Uint32Array(A):new Uint16Array(A);for(let j=0;j<A;j++)o[j]=L[P+j]+R;S=o}if(S){let o=a.getIndicesAccessor(L,P,A,R,N);if(void 0===o){const Y=function(L,j,P,A){if(L instanceof Uint16Array||L instanceof Uint32Array)return L;if(L instanceof Int32Array)return new Uint32Array(L.buffer,L.byteOffset,L.length);const R=L.slice(j,j+P);return A?new Uint32Array(R):new Uint16Array(R)}(S,0,A,j),u=this._bufferManager.createBufferView(Y),D=j?5125:5123;this._accessors.push(this._bufferManager.createAccessor(u,"SCALAR",D,A,0)),o=this._accessors.length-1,a.setIndicesAccessor(L,P,A,R,N,o)}D.indices=o}}_exportVertexBuffer(L,j,P,A,R,o){const Y=L.getKind();if(!n(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!j||!this._materialNeedsUVsSet.has(j)))return;let u=R.getVertexAccessor(L,P,A);if(void 0===u){const j=R.convertedToRightHandedBuffers.get(L._buffer)||L._buffer.getData(),o=Y===S.e.PositionKind?function(L,j,P,A){const{byteOffset:R,byteStride:o,type:Y,normalized:u}=j,a=j.getSize(),D=new Array(a).fill(1/0),S=new Array(a).fill(-1/0);return(0,H.g)(L,R+P*o,o,a,Y,A*a,u,(L=>{for(let j=0;j<a;j++)D[j]=Math.min(D[j],L[j]),S[j]=Math.max(S[j],L[j])})),{min:D,max:S}}(j,L,P,A):void 0,a=(Y===S.e.MatricesIndicesKind||Y===S.e.MatricesIndicesExtraKind)&&L.type===S.e.FLOAT,D=a?S.e.UNSIGNED_BYTE:L.type,g=a?void 0:L.normalized,V=a?R.getRemappedBufferView(L._buffer,L):R.getVertexBufferView(L._buffer),N=L.byteOffset+P*L.byteStride;this._accessors.push(this._bufferManager.createAccessor(V,function(L,j){if(L==S.e.ColorKind)return j?"VEC4":"VEC3";switch(L){case S.e.PositionKind:case S.e.NormalKind:return"VEC3";case S.e.TangentKind:case S.e.MatricesIndicesKind:case S.e.MatricesIndicesExtraKind:case S.e.MatricesWeightsKind:case S.e.MatricesWeightsExtraKind:return"VEC4";case S.e.UVKind:case S.e.UV2Kind:case S.e.UV3Kind:case S.e.UV4Kind:case S.e.UV5Kind:case S.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${L}`)}(Y,R.hasVertexColorAlpha(L)),D,A,N,o,g)),u=this._accessors.length-1,R.setVertexAccessor(L,P,A,u)}o.attributes[function(L){switch(L){case S.e.PositionKind:return"POSITION";case S.e.NormalKind:return"NORMAL";case S.e.TangentKind:return"TANGENT";case S.e.ColorKind:return"COLOR_0";case S.e.UVKind:return"TEXCOORD_0";case S.e.UV2Kind:return"TEXCOORD_1";case S.e.UV3Kind:return"TEXCOORD_2";case S.e.UV4Kind:return"TEXCOORD_3";case S.e.UV5Kind:return"TEXCOORD_4";case S.e.UV6Kind:return"TEXCOORD_5";case S.e.MatricesIndicesKind:return"JOINTS_0";case S.e.MatricesIndicesExtraKind:return"JOINTS_1";case S.e.MatricesWeightsKind:return"WEIGHTS_0";case S.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${L}`)}(Y)]=u}async _exportMaterialAsync(L,j,P,A){let R=this._materialMap.get(L);if(void 0===R){const A=j&&Object.keys(j).some((L=>L.startsWith("uv")));if((L=L instanceof NL.e?L.Gi[P.materialIndex]:L)instanceof CL.c)R=await this._materialExporter.exportPBRMaterialAsync(L,"image/png",A);else{if(!(L instanceof bL.e))return void W.e.Warn(`Unsupported material '${L.name}' with type ${L.getClassName()}`);R=await this._materialExporter.exportStandardMaterialAsync(L,"image/png",A)}this._materialMap.set(L,R)}A.material=R}async _exportMeshAsync(L,j){var P;let A=j.getMesh(L);if(void 0!==A)return A;const R={primitives:[]};A=this._meshes.length,this._meshes.push(R),j.setMesh(L,A);const Y=L.isUnIndexed?null:L.zi(),u=null===(P=L.ui)||void 0===P?void 0:P.getVertexBuffers(),a=j.getMorphTargetsFromMesh(L),D=L instanceof TL.c,S=L instanceof mL,g=L.Bi;if(u&&g&&g.length>0)for(const C of g){const P={attributes:{}},A=C.Ha()||this._babylonScene.defaultMaterial;if(S){var V,N;const j={name:A.name},R=L,o=f.e.White(),Y=(null===(V=R.material)||void 0===V?void 0:V.alpha)??1,u=(null===(N=R.greasedLineMaterial)||void 0===N?void 0:N.color)??o;(!u.equalsWithEpsilon(o,s.c)||Y<1)&&(j.pbrMetallicRoughness={baseColorFactor:[...u.Ei(),Y]}),this._materials.push(j),P.material=this._materials.length-1}else if(D){const j={name:A.name},R=L;(!R.color.equalsWithEpsilon(f.e.White(),s.c)||R.alpha<1)&&(j.pbrMetallicRoughness={baseColorFactor:[...R.color.Ei(),R.alpha]}),this._materials.push(j),P.material=this._materials.length-1}else await this._exportMaterialAsync(A,u,C,P);const g=D||S?o.c.LineListDrawMode:L.overrideRenderingFillMode??A.fillMode,b=A._getEffectiveOrientation(L);this._exportIndices(Y,Y?(0,H.b)(Y,C.indexCount,C.indexStart,C.verticesStart):C.verticesCount>65535,Y?C.indexStart:C.verticesStart,Y?C.indexCount:C.verticesCount,-C.verticesStart,g,b,j,P);for(const L of Object.values(u))this._exportVertexBuffer(L,A,C.verticesStart,C.verticesCount,j,P);if(a){P.targets=[];for(const L of a)P.targets.push(L.attributes)}R.primitives.push(P),this._extensionsPostExportMeshPrimitive(P)}if(a){R.weights=[],R.extras||(R.extras={}),R.extras.targetNames=[];for(const L of a)R.weights.push(L.influence),R.extras.targetNames.push(L.name)}return A}}kL._ExtensionNames=new Array,kL._ExtensionFactories={};class IL{static async GLTFAsync(L,j,P){P&&P.exportWithoutWaitingForScene||await L.whenReadyAsync();const A=new kL(L,P),R=await A.generateGLTFAsync(j.replace(/\.[^/.]+$/,""));return A.dispose(),R}static async GLBAsync(L,j,P){P&&P.exportWithoutWaitingForScene||await L.whenReadyAsync();const A=new kL(L,P),R=await A.generateGLBAsync(j.replace(/\.[^/.]+$/,""));return A.dispose(),R}}P(454);const zL="EXT_mesh_gpu_instancing";class pL{constructor(L){this.name=zL,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(L,j,P,R,o,Y){return await new Promise((L=>{if(j&&P instanceof KL.e&&P.hasThinInstances&&this._exporter){this._wasUsed=!0;const L=A.r.Zero(),R=A.i.Identity(),u=A.r.One(),a=P.thinInstanceGetWorldMatrices(),D=A.m.ti[2],S=A.m.Quaternion[1],g=A.m.ti[3];let V=!1,N=!1,C=!1;const b=new Float32Array(3*P.oi),f=new Float32Array(4*P.oi),h=new Float32Array(3*P.oi);let K=0;for(const j of a)j.decompose(g,S,D),o&&(i(D),J(S)),b.set(D.Ei(),3*K),f.set(S.normalize().Ei(),4*K),h.set(g.Ei(),3*K),V=V||!D.equalsWithEpsilon(L),N=N||!S.equalsWithEpsilon(R),C=C||!g.equalsWithEpsilon(u),K++;const v={attributes:{}};V&&(v.attributes.TRANSLATION=this._buildAccessor(b,"VEC3",P.oi,Y)),N&&(v.attributes.ROTATION=this._buildAccessor(f,"VEC4",P.oi,Y)),C&&(v.attributes.SCALE=this._buildAccessor(h,"VEC3",P.oi,Y)),j.extensions=j.extensions||{},j.extensions[zL]=v}L(j)}))}_buildAccessor(L,j,P,A){const R=A.createBufferView(L),o=A.createAccessor(R,j,5126,P);return this._exporter._accessors.push(o),this._exporter._accessors.length-1}}kL.RegisterExtension(zL,(L=>new pL(L)));var nL=P(11706),ZL=P(11712),OL=P(11717),iL=P(11723);function JL(L){return L===OL.e.PositionKind?"POSITION":L===OL.e.NormalKind?"NORMAL":L===OL.e.ColorKind?"COLOR":L.startsWith(OL.e.UVKind)?"TEX_COORD":"GENERIC"}const rL={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Lj extends nL.b{static get DefaultAvailable(){return(0,nL.d)(Lj.DefaultConfiguration)}static get Default(){return Lj._Default??(Lj._Default=new Lj),Lj._Default}static ResetDefault(L){Lj._Default&&(L||Lj._Default.dispose(),Lj._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(L,j){return{module:await(j||DracoEncoderModule)({wasmBinary:L})}}_getWorkerContent(){return`${ZL.k}(${ZL.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Lj.DefaultConfiguration)}async _encodeAsync(L,j,P){const A=P?(0,iL.b)(rL,P):rL;if(this._workerPoolPromise){const P=await this._workerPoolPromise;return await new Promise(((R,o)=>{P.push(((P,Y)=>{const u=L=>{P.removeEventListener("error",u),P.removeEventListener("message",a),o(L),Y()},a=L=>{"encodeMeshDone"===L.data.id&&(P.removeEventListener("error",u),P.removeEventListener("message",a),R(L.data.encodedMeshData),Y())};P.addEventListener("error",u),P.addEventListener("message",a);const D=[];for(const j of L)D.push(j.data.buffer);j&&D.push(j.buffer),P.postMessage({id:"encodeMesh",attributes:L,indices:j,options:A},D)}))}))}if(this._modulePromise){const P=await this._modulePromise;return(0,ZL.k)(P.module,L,j,A)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(L,j){if(0==L.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");L instanceof KL.e&&L.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===j||void 0===j?void 0:j.method)&&(W.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),j.method="MESH_SEQUENTIAL_ENCODING");const P=function(L){let j=L.zi(void 0,!0);return!j||j instanceof Uint32Array||j instanceof Uint16Array||(j=((0,H.b)(j,j.length)?Uint32Array:Uint16Array).from(j)),j}(L),A=function(L,j){const P=[];for(const A of L.getVerticesDataKinds()){if(null!==j&&void 0!==j&&j.includes(A)){if(A===OL.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const R=L.getVertexBuffer(A),o=R.getSize(),Y=(0,H.r)(R.getData(),o,R.type,R.byteOffset,R.byteStride,R.normalized,L.getTotalVertices(),!0);P.push({kind:A,dracoName:JL(A),size:o,data:Y})}return P}(L,null===j||void 0===j?void 0:j.excludedAttributes);return await this._encodeAsync(A,P,j)}}Lj.DefaultConfiguration={wasmUrl:`${R.d._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${R.d._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${R.d._DefaultCdnUrl}/draco_encoder.js`},Lj._Default=null;const jj="KHR_draco_mesh_compression";class Pj{get wasUsed(){return this._wasUsed}constructor(L){this.name=jj,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===L.options.meshCompressionMethod&&Lj.DefaultAvailable}dispose(){}postExportMeshPrimitive(L,j,P){if(!this.enabled)return;if(4!==L.mode&&5!==L.mode)return void W.e.Warn("Cannot compress primitive with mode "+L.mode+".");const A=[],R=[];let o=null;if(void 0!==L.indices){const Y=P[L.indices],u=j.getBufferView(Y);o=j.getData(u).slice(),A.push(u),R.push(Y)}const Y=[];for(const[S,g]of Object.entries(L.attributes)){const L=P[g],o=j.getBufferView(L),a=p(L.type),D=(0,H.r)(j.getData(o),a,L.componentType,L.byteOffset||0,o.byteStride||(0,H.j)(L.componentType)*a,L.normalized||!1,L.count,!0);Y.push({kind:S,dracoName:(u=S,"POSITION"===u?"POSITION":"NORMAL"===u?"NORMAL":u.startsWith("COLOR")?"COLOR":u.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:p(L.type),data:D}),A.push(o),R.push(L)}var u;const a={method:L.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},D=Lj.Default._encodeAsync(Y,o,a).then((P=>{if(!P)return void W.e.Error("Draco encoding failed for primitive.");const o={bufferView:-1,attributes:P.attributeIds},Y=j.createBufferView(P.data);j.setBufferView(o,Y);for(const L of A)this._bufferViewsUsed.add(L);for(const L of R)this._accessorsUsed.add(L);L.extensions||(L.extensions={}),L.extensions[jj]=o})).catch((L=>{W.e.Error("Draco encoding failed for primitive: "+L)}));this._encodePromises.push(D),this._wasUsed=!0}async preGenerateBinaryAsync(L){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((j=>{L.getPropertiesWithBufferView(j).every((L=>this._accessorsUsed.has(L)))&&L.removeBufferView(j)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}kL.RegisterExtension(jj,(L=>new Pj(L)));var Aj=P(11725);const Rj="KHR_lights_punctual",oj={name:"",color:[1,1,1],bb:1,range:Number.MAX_VALUE},Yj={innerConeAngle:0,outerConeAngle:Math.PI/4},uj=A.r.Backward();class aj{constructor(L){this.name=Rj,this.enabled=!0,this.required=!1,this._exporter=L}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Rj]=this._lights}async postExportNodeAsync(L,j,P,R,o){return await new Promise((Y=>{if(!(P instanceof vL.d))return void Y(j);const u=P.getTypeID()==vL.d.LIGHTTYPEID_POINTLIGHT?"point":P.getTypeID()==vL.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":P.getTypeID()==vL.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!u||!(P instanceof Aj.b))return W.e.Warn(`${L}: Light ${P.name} is not supported in ${Rj}`),void Y(j);if(P.falloffType!==vL.d.FALLOFF_GLTF&&W.e.Warn(`${L}: Light falloff for ${P.name} does not match the ${Rj} specification!`),!P.position.equalsToFloats(0,0,0)){const L=A.m.ti[0].p(P.position);o&&i(L),j.translation=L.Ei()}if("point"!==u){const L=P.direction.normalizeToRef(A.m.ti[0]);o&&i(L);const R=A.i.FromUnitVectorsToRef(uj,L,A.m.Quaternion[0]);A.i.IsIdentity(R)||(j.rotation=R.Ei())}const a={type:u,name:P.name,color:P.cb.Ei(),bb:P.bb,range:P.range};if(AL(a,oj),"spot"===u){const L=P;a.spot={innerConeAngle:L.innerAngle/2,outerConeAngle:L.angle/2},AL(a.spot,Yj)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(a);const D={ab:this._lights.lights.length-1},S=P.parent;if(S&&jL(P,S)){const L=R.get(S);if(L){const P=this._exporter._nodes[L];return LL(j,P),P.extensions||(P.extensions={}),P.extensions[Rj]=D,void Y(null)}}j.extensions||(j.extensions={}),j.extensions[Rj]=D,Y(j)}))}}kL.RegisterExtension(Rj,(L=>new aj(L)));var Dj=P(11604);const Sj="KHR_materials_anisotropy";class gj{constructor(L){this.name=Sj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof Dj.e&&P.anisotropy.isEnabled&&!P.anisotropy.legacy?(P.anisotropy.texture&&A.push(P.anisotropy.texture),A):[]}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof Dj.e){if(!P.anisotropy.isEnabled||P.anisotropy.legacy)return void L(j);this._wasUsed=!0,j.extensions=j.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(P.anisotropy.texture),R={anisotropyStrength:P.anisotropy.bb,anisotropyRotation:P.anisotropy.angle,anisotropyTexture:A??void 0};null!==R.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(P),j.extensions[Sj]=R}L(j)}))}}kL.RegisterExtension(Sj,(L=>new gj(L)));const Vj="KHR_materials_clearcoat";class Nj{constructor(L){this.name=Vj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof Dj.e&&P.clearCoat.isEnabled?(P.clearCoat.texture&&A.push(P.clearCoat.texture),!P.clearCoat.useRoughnessFromMainTexture&&P.clearCoat.textureRoughness&&A.push(P.clearCoat.textureRoughness),P.clearCoat.bumpTexture&&A.push(P.clearCoat.bumpTexture),A):[]}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof Dj.e){if(!P.clearCoat.isEnabled)return void L(j);this._wasUsed=!0,j.extensions=j.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture);let o;o=P.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(P.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(P.clearCoat.textureRoughness),P.clearCoat.isTintEnabled&&R.d.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${P.name}`),P.clearCoat.remapF0OnInterfaceChange&&R.d.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${P.name}`);const Y=this._exporter._materialExporter.getTextureInfo(P.clearCoat.bumpTexture),u={clearcoatFactor:P.clearCoat.bb,clearcoatTexture:A??void 0,clearcoatRoughnessFactor:P.clearCoat.roughness,clearcoatRoughnessTexture:o??void 0,clearcoatNormalTexture:Y??void 0};null===u.clearcoatTexture&&null===u.clearcoatRoughnessTexture&&null===u.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),j.extensions[Vj]=u}L(j)}))}}kL.RegisterExtension(Vj,(L=>new Nj(L)));const Cj="KHR_materials_diffuse_transmission";function bj(L,j){const P=j.subSurface;let A=null;return P.translucencyIntensityTexture?A=P.translucencyIntensityTexture:P.thicknessTexture&&P.useMaskFromThicknessTexture&&(A=P.thicknessTexture),A&&!P.useGltfStyleTextures?(W.e.Warn(`${L}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${j.name}`,1),null):A}class fj{constructor(L){this.name=Cj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];if(P instanceof CL.c&&this._isExtensionEnabled(P)){const j=bj(L,P);return j&&A.push(j),P.subSurface.translucencyColorTexture&&A.push(P.subSurface.translucencyColorTexture),A}return A}_isExtensionEnabled(L){if(L.unlit)return!1;const j=L.subSurface;return!!j.isTranslucencyEnabled&&(!L.unlit&&!j.useAlbedoToTintTranslucency&&j.useGltfStyleTextures&&1===j.volumeIndexOfRefraction&&0===j.minimumThickness&&0===j.maximumThickness)}postExportMaterialAsync(L,j,P){return new Promise((A=>{if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0;const A=P.subSurface,R=bj(L,P),o=0==A.translucencyIntensity?void 0:A.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(R)??void 0,u=!A.translucencyColor||A.translucencyColor.equalsFloats(1,1,1)?void 0:A.translucencyColor.Ei(),a=this._exporter._materialExporter.getTextureInfo(A.translucencyColorTexture)??void 0,D={diffuseTransmissionFactor:o,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:u,diffuseTransmissionColorTexture:a};(Y||a)&&this._exporter._materialNeedsUVsSet.add(P),j.extensions=j.extensions||{},j.extensions[Cj]=D}A(j)}))}}kL.RegisterExtension(Cj,(L=>new fj(L)));const hj="KHR_materials_dispersion";class Kj{constructor(){this.name=hj,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){if(L.unlit)return!1;const j=L.subSurface;return!(!j.isRefractionEnabled&&!j.isDispersionEnabled)}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0;const L={dispersion:P.subSurface.dispersion};j.extensions=j.extensions||{},j.extensions[hj]=L}L(j)}))}}kL.RegisterExtension(hj,(()=>new Kj));const vj="KHR_materials_emissive_strength";class qj{constructor(){this.name=vj,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(L,j,P){return await new Promise((L=>{if(!(P instanceof CL.c))return L(j);const A=P.emissiveColor.Ei(),R=Math.max(...A);if(R>1){this._wasUsed=!0,j.extensions||(j.extensions={});const L={emissiveStrength:R},A=P.emissiveColor.scale(1/L.emissiveStrength);j.emissiveFactor=A.Ei(),j.extensions[vj]=L}return L(j)}))}}kL.RegisterExtension(vj,(L=>new qj));const yj="KHR_materials_ior";class Tj{constructor(){this.name=yj,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.indexOfRefraction&&1.5!=L.indexOfRefraction)}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0;const L={ior:P.indexOfRefraction};j.extensions=j.extensions||{},j.extensions[yj]=L}L(j)}))}}kL.RegisterExtension(yj,(L=>new Tj));const Gj="KHR_materials_iridescence";class Mj{constructor(L){this.name=Gj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof Dj.e&&P.iridescence.isEnabled?(P.iridescence.texture&&A.push(P.iridescence.texture),P.iridescence.thicknessTexture&&P.iridescence.thicknessTexture!==P.iridescence.texture&&A.push(P.iridescence.thicknessTexture),A):[]}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof Dj.e){if(!P.iridescence.isEnabled)return void L(j);this._wasUsed=!0,j.extensions=j.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(P.iridescence.texture),R=this._exporter._materialExporter.getTextureInfo(P.iridescence.thicknessTexture),o={iridescenceFactor:P.iridescence.bb,iridescenceIor:P.iridescence.indexOfRefraction,iridescenceThicknessMinimum:P.iridescence.minimumThickness,iridescenceThicknessMaximum:P.iridescence.maximumThickness,iridescenceTexture:A??void 0,iridescenceThicknessTexture:R??void 0};null===o.iridescenceTexture&&null===o.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(P),j.extensions[Gj]=o}L(j)}))}}kL.RegisterExtension(Gj,(L=>new Mj(L)));const Qj="KHR_materials_sheen";class lj{constructor(L){this.name=Qj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){return P instanceof CL.c&&P.sheen.isEnabled&&P.sheen.texture?[P.sheen.texture]:[]}async postExportMaterialAsync(L,j,P){return await new Promise((L=>{if(P instanceof CL.c){if(!P.sheen.isEnabled)return void L(j);this._wasUsed=!0,null==j.extensions&&(j.extensions={});const A={sheenColorFactor:P.sheen.color.Ei(),sheenRoughnessFactor:P.sheen.roughness??0};null===A.sheenColorTexture&&null===A.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(P),P.sheen.texture&&(A.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),P.sheen.textureRoughness&&!P.sheen.useRoughnessFromMainTexture?A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.textureRoughness)??void 0:P.sheen.texture&&P.sheen.useRoughnessFromMainTexture&&(A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(P.sheen.texture)??void 0),j.extensions[Qj]=A}L(j)}))}}kL.RegisterExtension(Qj,(L=>new lj(L)));const wj="KHR_materials_specular";class dj{constructor(L){this.name=wj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof CL.c&&this._isExtensionEnabled(P)?(P.metallicReflectanceTexture&&A.push(P.metallicReflectanceTexture),P.reflectanceTexture&&A.push(P.reflectanceTexture),A):A}_isExtensionEnabled(L){return!L.unlit&&(void 0!=L.metallicF0Factor&&1!=L.metallicF0Factor||void 0!=L.metallicReflectanceColor&&!L.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.metallicReflectanceTexture||null!=L.reflectanceTexture}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0,j.extensions=j.extensions||{};const L=this._exporter._materialExporter.getTextureInfo(P.metallicReflectanceTexture)??void 0,A=this._exporter._materialExporter.getTextureInfo(P.reflectanceTexture)??void 0,R={specularFactor:1==P.metallicF0Factor?void 0:P.metallicF0Factor,specularTexture:L,specularColorFactor:P.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:P.metallicReflectanceColor.Ei(),specularColorTexture:A};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),j.extensions[wj]=R}L(j)}))}}kL.RegisterExtension(wj,(L=>new dj(L)));const cj="KHR_materials_transmission";class Ej{constructor(L){this.name=cj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof CL.c&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&A.push(P.subSurface.thicknessTexture),A):A}_isExtensionEnabled(L){if(L.unlit)return!1;const j=L.subSurface;return j.isRefractionEnabled&&void 0!=j.refractionIntensity&&0!=j.refractionIntensity||this._hasTexturesExtension(L)}_hasTexturesExtension(L){return null!=L.subSurface.refractionIntensityTexture}async postExportMaterialAsync(L,j,P){if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0;const A=P.subSurface,R={transmissionFactor:0===A.refractionIntensity?void 0:A.refractionIntensity};if(this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),A.refractionIntensityTexture)if(A.useGltfStyleTextures){const L=await this._exporter._materialExporter.exportTextureAsync(A.refractionIntensityTexture,"image/png");L&&(R.transmissionTexture=L)}else W.e.Warn(`${L}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);j.extensions||(j.extensions={}),j.extensions[cj]=R}return j}}kL.RegisterExtension(cj,(L=>new Ej(L)));const Uj="KHR_materials_unlit";class tj{constructor(){this.name=Uj,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(L,j,P){return new Promise((L=>{let A=!1;P instanceof CL.c?A=P.unlit:P instanceof bL.e&&(A=P.disableLighting),A&&(this._wasUsed=!0,null==j.extensions&&(j.extensions={}),j.extensions[Uj]={}),L(j)}))}}kL.RegisterExtension(Uj,(()=>new tj));const Bj="KHR_materials_volume";class Fj{constructor(L){this.name=Bj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof CL.c&&this._isExtensionEnabled(P)?(P.subSurface.thicknessTexture&&A.push(P.subSurface.thicknessTexture),A):A}_isExtensionEnabled(L){if(L.unlit)return!1;const j=L.subSurface;return!(!j.isRefractionEnabled&&!j.isTranslucencyEnabled)&&(void 0!=j.maximumThickness&&0!=j.maximumThickness||void 0!=j.tintColorAtDistance&&j.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=j.tintColor&&j.tintColor!=f.e.White()||this._hasTexturesExtension(L))}_hasTexturesExtension(L){return null!=L.subSurface.thicknessTexture}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof CL.c&&this._isExtensionEnabled(P)){this._wasUsed=!0;const L=P.subSurface,A={thicknessFactor:0==L.maximumThickness?void 0:L.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(L.thicknessTexture)??void 0,attenuationDistance:L.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:L.tintColorAtDistance,attenuationColor:L.tintColor.equalsFloats(1,1,1)?void 0:L.tintColor.Ei()};this._hasTexturesExtension(P)&&this._exporter._materialNeedsUVsSet.add(P),j.extensions=j.extensions||{},j.extensions[Bj]=A}L(j)}))}}kL.RegisterExtension(Bj,(L=>new Fj(L)));const Xj="EXT_materials_diffuse_roughness";class Hj{constructor(L){this.name=Xj,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=L}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(L,j,P){const A=[];return P instanceof Dj.e&&P._baseDiffuseRoughness?(P._baseDiffuseRoughnessTexture&&A.push(P._baseDiffuseRoughnessTexture),A):[]}postExportMaterialAsync(L,j,P){return new Promise((L=>{if(P instanceof Dj.e){if(!P._baseDiffuseRoughness)return void L(j);this._wasUsed=!0,j.extensions=j.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(P._baseDiffuseRoughnessTexture),R={diffuseRoughnessFactor:P._baseDiffuseRoughness,diffuseRoughnessTexture:A??void 0};null!==R.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(P),j.extensions[Xj]=R}L(j)}))}}kL.RegisterExtension(Xj,(L=>new Hj(L)));const Wj="KHR_texture_transform";class ej{constructor(){this.name=Wj,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(L,j,P){if(P.va()||R.d.Warn(`${L}: /*@__KEY__*/"scene" is not defined for Babylon texture ${P.name}!`),(0!==P.uAng||0!==P.vAng)&&(R.d.Warn(`${L}: Texture ${P.name} with rotation in the u or v axis is not supported in glTF.`),0!==P.uRotationCenter||0!==P.vRotationCenter))return;const A={};let o=!1;if(0===P.uOffset&&0===P.vOffset||(A.offset=[P.uOffset,P.vOffset],o=!0),1===P.uScale&&1===P.vScale||(A.scale=[P.uScale,P.vScale],o=!0),0!==P.wAng){if(0!==P.uRotationCenter||0!==P.vRotationCenter){if(P.homogeneousRotationInUVTransform&&P.uScale!==P.vScale)return void R.d.Warn(`${L}: Texture ${P.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Wj}.`);R.d.Warn(`${L}: Texture ${P.name} with non-origin rotation center will be exported using an adjusted offset with ${Wj}.`),A.offset=function(L){const{uOffset:j,vOffset:P,uRotationCenter:A,vRotationCenter:R,uScale:o,vScale:Y,wAng:u}=L,a=Math.cos(u),D=Math.sin(u),S=A*o,g=R*Y;return[j+(S*(1-a)+g*D),P+(g*(1-a)-S*D)]}(P)}A.rotation=-P.wAng,o=!0}0!==P.coordinatesIndex&&(A.texCoord=P.coordinatesIndex,o=!0),o&&(this._wasUsed=!0,j.extensions||(j.extensions={}),j.extensions[Wj]=A)}}kL.RegisterExtension(Wj,(()=>new ej));class sj{static CreateSTL(L){let j=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",R=arguments.length>3&&void 0!==arguments[3]&&arguments[3],o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],u=arguments.length>6&&void 0!==arguments[6]&&arguments[6],a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const D=function(L,j,P){const R=[3*L[P],3*L[P+1],3*L[P+2]],o=[new A.r(j[R[0]],j[R[0]+2],j[R[0]+1]),new A.r(j[R[1]],j[R[1]+2],j[R[1]+1]),new A.r(j[R[2]],j[R[2]+2],j[R[2]+1])],Y=o[0].xg(o[1]),u=o[2].xg(o[1]);return{v:o,n:A.r.Cross(u,Y).normalize()}},g=function(L,j,P,A){return j=V(L,j,P.x,A),j=V(L,j,P.y,A),V(L,j,P.z,A)},V=function(L,j,P,A){return L.setFloat32(j,P,A),j+4},C=function(L){if(u){let j=L;L instanceof N.d&&(j=L.sourceMesh);const P=j.getVerticesData(S.e.PositionKind,!0,!0);if(!P)return[];const R=A.r.Zero();let o;for(o=0;o<P.length;o+=3)A.r.TransformCoordinatesFromFloatsToRef(P[o],P[o+1],P[o+2],L.yi(!0),R).toArray(P,o);return P}return L.getVerticesData(S.e.PositionKind)||[]};u&&(Y=!0);let b="",f=0,h=0;if(R){for(let P=0;P<L.length;P++){const j=L[P].zi();f+=j?j.length/3:0}const j=new ArrayBuffer(84+50*f);b=new DataView(j),h+=80,b.setUint32(h,f,o),h+=4}else a||(b="solid stlmesh\r\n");for(let A=0;A<L.length;A++){const j=L[A];!R&&a&&(b+="solid "+j.name+"\r\n"),!Y&&j instanceof KL.e&&j.bakeCurrentTransformIntoVertices();const P=C(j),u=j.zi()||[];for(let L=0;L<u.length;L+=3){const j=D(u,P,L);R?(h=g(b,h,j.n,o),h=g(b,h,j.v[0],o),h=g(b,h,j.v[1],o),h=g(b,h,j.v[2],o),h+=2):(b+="\tfacet normal "+j.n.x+" "+j.n.y+" "+j.n.z+"\r\n",b+="\t\touter loop\r\n",b+="\t\t\tvertex "+j.v[0].x+" "+j.v[0].y+" "+j.v[0].z+"\r\n",b+="\t\t\tvertex "+j.v[1].x+" "+j.v[1].y+" "+j.v[1].z+"\r\n",b+="\t\t\tvertex "+j.v[2].x+" "+j.v[2].y+" "+j.v[2].z+"\r\n",b+="\t\tendloop\r\n",b+="\tendfacet\r\n")}!R&&a&&(b+="endsolid "+name+"\r\n")}if(R||a||(b+="endsolid stlmesh"),j){const L=document.createElement("a"),j=new Blob([b],{type:"application/octet-stream"});L.href=window.URL.createObjectURL(j),L.download=P+".stl",L.click()}return b}}function mj(L,j){let P=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const A=[];for(let R=0;R<L.length/P;R++){const o=L[R*P],Y=L[R*P+1],u=L[R*P+2];A.push(`(${o.toPrecision(j.precision)}, ${Y.toPrecision(j.precision)}, ${u.toPrecision(j.precision)})`)}return A.join(", ")}function xj(L,j){const P=[];for(let A=0;A<L.length/2;A++){const R=L[2*A],o=L[2*A+1];P.push(`(${R.toPrecision(j.precision)}, ${(1-o).toPrecision(j.precision)})`)}return P.join(", ")}function kj(L,j){const P=L.getVerticesData(S.e.PositionKind),A=L.getVerticesData(S.e.NormalKind);if(P&&A)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(L){var j;const P=null!==(j=L.zi())&&void 0!==j&&j.length?L.getTotalIndices():L.getTotalVertices();return Array(P/3).fill(3).join(", ")}(L)}]\n\t\tint[] faceVertexIndices = [${function(L){const j=L.zi(),P=[];if(null!==j)for(let A=0;A<j.length;A++)P.push(j[A]);else{const j=L.getTotalVertices();for(let L=0;L<j;L++)P.push(L)}return P.join(", ")}(L)}]\n\t\tnormal3f[] normals = [${mj(A,j)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${mj(P,j)}]\n        ${function(L,j){let P="";for(let R=0;R<4;R++){const A=R>0?R:"",o=L.getVerticesData(S.e.UVKind+(A?A+1:""));o&&(P+=`\n\t\ttexCoord2f[] primvars:st${A} = [${xj(o,j)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const A=L.getVerticesData(S.e.ColorKind);return A&&(P+=`\n\tcolor3f[] primvars:displayColor = [${mj(A,j,A.length/L.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),P}(L,j)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Ij(L,j){return`\n        def "Geometry"\n        {\n        ${kj(L,j)}\n        }\n        `}function zj(L){let j='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return j+=L,fflate.strToU8(j)}function pj(L){const j=L.m;return`( ${nj(j,0)}, ${nj(j,4)}, ${nj(j,8)}, ${nj(j,12)} )`}function nj(L,j){return`(${L[j+0]}, ${L[j+1]}, ${L[j+2]}, ${L[j+3]})`}function Zj(L){const j="Object_"+L.uniqueId,P=function(L){const j=L.getWorldMatrix().clone(),P=L.va().useRightHandedSystem;if(!P){let A=L.parent;for(;A;){if(YL(A,P)){j.multiplyToRef(A.getWorldMatrix().invert(),j);break}A=A.parent}}return j.determinant()<0&&R.d.Warn(`Exporting mesh ${L.name} with negative scale. Result may look incorrect in destination engine.`),j}(L),A=pj(P);return`def Xform "${j}" (\n\tprepend references = @./geometries/Geometry_${L.ui.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${A}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${L.material.uniqueId}>\n}\n\n`}function Oj(L){switch(L){case G.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case G.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case G.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ij(L){return`(${L.x}, ${L.y})`}function Jj(L){return`(${L.r}, ${L.g}, ${L.b})`}function rj(L,j,P,R,o,Y){const u=L.getInternalTexture().uniqueId+"_"+L.invertY;o[u]=L;const a=L.coordinatesIndex>0?"st"+L.coordinatesIndex:"st",D=new A.n(L.uScale,L.vScale),S=new A.n(L.uOffset,L.vOffset),g=L.wAng,V=Math.sin(g),N=Math.cos(g);return S.y=1-S.y-D.y,S.x+=V*D.x,S.y+=(1-N)*D.y,`\n    def Shader "PrimvarReader_${P}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${a}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${P}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${j.uniqueId}/PrimvarReader_${P}.outputs:result>\n        float inputs:rotation = ${(g*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${ij(D)}\n        float2 inputs:translation = ${ij(S)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${L.uniqueId}_${P}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${u}.png@\n        float2 inputs:st.connect = </Materials/Material_${j.uniqueId}/Transform2d_${P}.outputs:result>\n        ${R?"float4 inputs:scale = "+function(L){return`(${L.r}, ${L.g}, ${L.b}, 1.0)`}(R):""}\n        token inputs:sourceColorSpace = "${L.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Oj(L.wrapU)}"\n        token inputs:wrapT = "${Oj(L.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${j.needAlphaBlending()?"float outputs:a":""}\n    }`}function LP(L,j,P){const A="\t\t\t",R=[],o=[],{diffuseMap:Y,cb:u,alphaCutOff:a,emissiveMap:D,emissive:S,normalMap:g,roughnessMap:V,roughnessChannel:N,roughness:C,metalnessMap:b,metalnessChannel:h,metalness:K,aoMap:v,aoMapChannel:q,aoMapIntensity:y,alphaMap:T,ior:G,clearCoatEnabled:M,clearCoat:Q,clearCoatMap:l,clearCoatRoughness:w,clearCoatRoughnessMap:d}=function(L){const j={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return L instanceof bL.e?{...j,diffuseMap:L.diffuseTexture,cb:L.diffuseColor,alphaCutOff:L.alphaCutOff,emissiveMap:L.emissiveTexture,emissive:L.emissiveColor,roughness:1,alphaMap:L.opacityTexture}:L instanceof Dj.e?{...j,diffuseMap:L._albedoTexture,cb:L._albedoColor,alphaCutOff:L._alphaCutOff,emissiveMap:L._emissiveTexture,emissive:L._emissiveColor,normalMap:L._bumpTexture,roughnessMap:L._metallicTexture,roughnessChannel:L._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:L._roughness??1,metalnessMap:L._metallicTexture,metalnessChannel:L._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:L._metallic??0,aoMap:L._ambientTexture,aoMapChannel:L._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:L._ambientTextureStrength,alphaMap:L._opacityTexture,ior:L.subSurface.indexOfRefraction,clearCoatEnabled:L.clearCoat.isEnabled,clearCoat:L.clearCoat.bb,clearCoatMap:L.clearCoat.texture,clearCoatRoughness:L.clearCoat.roughness,clearCoatRoughnessMap:L.clearCoat.useRoughnessFromMainTexture?L.clearCoat.texture:L.clearCoat.textureRoughness}:j}(L);return null!==Y?(R.push(`${A}color3f inputs:diffuseColor.connect = </Materials/Material_${L.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),L.needAlphaBlending()?R.push(`${A}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):L.needAlphaTesting()&&(R.push(`${A}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),R.push(`${A}float inputs:opacityThreshold = ${a}`)),o.push(rj(Y,L,"diffuse",u,j,P))):R.push(`${A}color3f inputs:diffuseColor = ${Jj(u||f.e.White())}`),null!==D?(R.push(`${A}color3f inputs:emissiveColor.connect = </Materials/Material_${L.uniqueId}/Texture_${D.uniqueId}_emissive.outputs:rgb>`),o.push(rj(D,L,"emissive",S,j,P))):S&&S.toLuminance()>0&&R.push(`${A}color3f inputs:emissiveColor = ${Jj(S)}`),null!==g&&(R.push(`${A}normal3f inputs:normal.connect = </Materials/Material_${L.uniqueId}/Texture_${g.uniqueId}_normal.outputs:rgb>`),o.push(rj(g,L,"Xi",null,j,P))),null!==v&&(R.push(`${A}float inputs:occlusion.connect = </Materials/Material_${L.uniqueId}/Texture_${v.uniqueId}_occlusion.outputs:${q}>`),o.push(rj(v,L,"occlusion",new f.e(y,y,y),j,P))),null!==V?(R.push(`${A}float inputs:roughness.connect = </Materials/Material_${L.uniqueId}/Texture_${V.uniqueId}_roughness.outputs:${N}>`),o.push(rj(V,L,"roughness",new f.e(C,C,C),j,P))):R.push(`${A}float inputs:roughness = ${C}`),null!==b?(R.push(`${A}float inputs:metallic.connect = </Materials/Material_${L.uniqueId}/Texture_${b.uniqueId}_metallic.outputs:${h}>`),o.push(rj(b,L,"metallic",new f.e(K,K,K),j,P))):R.push(`${A}float inputs:metallic = ${K}`),null!==T?(R.push(`${A}float inputs:opacity.connect = </Materials/Material_${L.uniqueId}/Texture_${T.uniqueId}_opacity.outputs:r>`),R.push(`${A}float inputs:opacityThreshold = 0.0001`),o.push(rj(T,L,"opacity",null,j,P))):R.push(`${A}float inputs:opacity = ${L.alpha}`),M&&(null!==l?(R.push(`${A}float inputs:clearcoat.connect = </Materials/Material_${L.uniqueId}/Texture_${l.uniqueId}_clearcoat.outputs:r>`),o.push(rj(l,L,"clearcoat",new f.e(Q,Q,Q),j,P))):R.push(`${A}float inputs:clearcoat = ${Q}`),null!==d?(R.push(`${A}float inputs:clearcoatRoughness.connect = </Materials/Material_${L.uniqueId}/Texture_${d.uniqueId}_clearcoatRoughness.outputs:g>`),o.push(rj(d,L,"clearcoatRoughness",new f.e(w,w,w),j,P))):R.push(`${A}float inputs:clearcoatRoughness = ${w}`)),R.push(`${A}float inputs:ior = ${G}`),`\n\tdef Material "Material_${L.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${R.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${L.uniqueId}/PreviewSurface.outputs:surface>\n\n${o.join("\n")}\n\n\t}\n`}async function jP(L,j,P){const o={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...j};"undefined"===typeof fflate&&await R.d.LoadScriptAsync(o.fflateUrl);const Y={};Y[o.modelFileName]=null;let u='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';u+=function(L){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===L.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${L.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${L.planeAnchoringAlignment}"`:""}\n            `}(o);const a={};for(const A of L.meshes){if(0===A.getTotalVertices())continue;const L=A,j=L.ui,D=L.material;if(!D||!j||P&&!P(L))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(D.getClassName())){const P="geometries/Geometry_"+j.uniqueId+".usda";if(!(P in Y)){const L=Ij(j,o);Y[P]=zj(L)}D.uniqueId in a||(a[D.uniqueId]=D),u+=Zj(L)}else R.d.Warn("USDZExportAsync does not support this material type: "+D.getClassName())}L.activeCamera&&o.exportCamera&&(u+=function(L,j){const P="Camera_"+L.uniqueId,R=pj(A.e.RotationY(Math.PI).multiply(L.getWorldMatrix()));if(L.mode===G.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${R}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.Ai.toPrecision(j.precision)}, ${L.maxZ.toPrecision(j.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(L.orthoLeft||1)+Math.abs(L.orthoRight||1))).toPrecision(j.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(L.orthoTop||1)+Math.abs(L.orthoBottom||1))).toPrecision(j.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const A=L.getEngine().getAspectRatio(L),o=j.cameraSensorWidth||35;return`def Camera "${P}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${R}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${L.Ai.toPrecision(j.precision)}, ${L.maxZ.toPrecision(j.precision)})\n\t\t\tfloat focalLength = ${(o/(2*Math.tan(.5*L.fov))).toPrecision(j.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(o*A).toPrecision(j.precision)}\n\t\t\tfloat verticalAperture = ${(o/A).toPrecision(j.precision)}            \n\t\t}\n\t\n\t`}}(L.activeCamera,o)),u+="\n            }\n        }\n    }";const D={};u+=function(L,j,P){const A=[];for(const R in L){const o=L[R];A.push(LP(o,j,P))}return`\n    def "Materials"\n{\n${A.join("")}\n}\n\n`}(a,D,o),Y[o.modelFileName]=fflate.strToU8(u);for(const A in D){const L=D[A],j=L.getSize(),P=await L.readPixels();if(!P)throw new Error("Texture data is not available");const R=await M.DumpTools.DumpDataAsync(j.width,j.height,P,"image/png",void 0,!1,!0);Y[`textures/Texture_${A}.png`]=new Uint8Array(R).slice()}let S=0;for(const A in Y){const L=Y[A];if(!L)continue;S+=34+A.length;const j=63&S;if(4!==j){const P=new Uint8Array(64-j);Y[A]=[L,{extra:{12345:P}}]}S=L.length}return fflate.zipSync(Y,{level:0})}}}]);