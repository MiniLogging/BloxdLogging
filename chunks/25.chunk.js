"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{11897:(v,d,Q)=>{Q.r(d),Q.d(d,{EXT_materials_diffuse_roughness:()=>td,EXT_mesh_gpu_instancing:()=>Uv,GLTF2Export:()=>av,GLTFData:()=>C,KHR_draco_mesh_compression:()=>Qd,KHR_lights_punctual:()=>rd,KHR_materials_anisotropy:()=>yd,KHR_materials_clearcoat:()=>Bd,KHR_materials_diffuse_transmission:()=>Vd,KHR_materials_dispersion:()=>Sd,KHR_materials_emissive_strength:()=>fd,KHR_materials_ior:()=>Od,KHR_materials_iridescence:()=>Kd,KHR_materials_sheen:()=>gd,KHR_materials_specular:()=>Md,KHR_materials_transmission:()=>Dd,KHR_materials_unlit:()=>Zd,KHR_materials_volume:()=>xd,KHR_texture_transform:()=>Wd,OBJExport:()=>e,STLExport:()=>qd,USDZExportAsync:()=>dQ,_ConvertToGLTFPBRMetallicRoughness:()=>i,_SolveMetallic:()=>D,__IGLTFExporterExtension:()=>F});var n=Q(651),T=Q(475),L=Q(829);class e{static OBJ(v,d,Q,e){const F=[];let r=1,C=1;d&&(Q||(Q="mat"),F.push("mtllib "+Q+".mtl"));for(let u=0;u<v.length;u++){const Q=v[u],y=Q.name||`mesh${u}}`;F.push(`o ${y}`);let z=null;if(e){const v=Q.ck(!0);z=new n.b,v.invertToRef(z),Q.bakeTransformIntoVertices(v)}if(d){const v=Q.material;v&&F.push("usemtl "+v.id)}const B=Q.sk;if(!B){T.e.Warn("No geometry is present on the mesh");continue}const X=B.getVerticesData("position"),m=B.getVerticesData("nk"),V=B.getVerticesData("uv"),h=B.ek();let S=0,A=0;if(!X||!h){T.e.Warn("There are no position vertices or indices on the mesh!");continue}const f=v[0].va().useRightHandedSystem?1:-1;for(let v=0;v<X.length;v+=3)F.push("v "+X[v]*f+" "+X[v+1]+" "+X[v+2]),S++;if(null!=m)for(let v=0;v<m.length;v+=3)F.push("vn "+m[v]*f+" "+m[v+1]+" "+m[v+2]);if(null!=V)for(let v=0;v<V.length;v+=2)F.push("vt "+V[v]+" "+V[v+1]),A++;const P=["","",""],O=(Q.material||Q.va().defaultMaterial)._getEffectiveOrientation(Q),[J,K]=O===L.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let v=0;v<h.length;v+=3){const d=[String(h[v]+r),String(h[v+J]+r),String(h[v+K]+r)],Q=[String(h[v]+C),String(h[v+J]+C),String(h[v+K]+C)],n=d,T=null!=V?Q:P,L=null!=m?d:P;F.push("f "+n[0]+"/"+T[0]+"/"+L[0]+" "+n[1]+"/"+T[1]+"/"+L[1]+" "+n[2]+"/"+T[2]+"/"+L[2])}e&&z&&Q.bakeTransformIntoVertices(z),r+=S,C+=A}return F.join("\n")}static MTL(v){const d=[],Q=v.material;d.push("newmtl mat1"),d.push("  Ns "+Q.specularPower.toFixed(4)),d.push("  Ni 1.5000"),d.push("  d "+Q.alpha.toFixed(4)),d.push("  Tr 0.0000"),d.push("  Tf 1.0000 1.0000 1.0000"),d.push("  illum 2"),d.push("  Ka "+Q.ambientColor.r.toFixed(4)+" "+Q.ambientColor.g.toFixed(4)+" "+Q.ambientColor.b.toFixed(4)),d.push("  Kd "+Q.diffuseColor.r.toFixed(4)+" "+Q.diffuseColor.g.toFixed(4)+" "+Q.diffuseColor.b.toFixed(4)),d.push("  Ks "+Q.specularColor.r.toFixed(4)+" "+Q.specularColor.g.toFixed(4)+" "+Q.specularColor.b.toFixed(4)),d.push("  Ke "+Q.emissiveColor.r.toFixed(4)+" "+Q.emissiveColor.g.toFixed(4)+" "+Q.emissiveColor.b.toFixed(4));Q.ambientTexture&&d.push("  map_Ka "+Q.ambientTexture.name),Q.diffuseTexture&&d.push("  map_Kd "+Q.diffuseTexture.name),Q.specularTexture&&d.push("  map_Ks "+Q.specularTexture.name),Q.bumpTexture&&d.push("  map_bump -imfchan z "+Q.bumpTexture.name),Q.opacityTexture&&d.push("  map_d "+Q.opacityTexture.name);return d.join("\n")}}var F=0,r=Q(512);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const v in this.files){const d=this.files[v],Q=new Blob([d],{type:(0,r.k)(v)});T.e.Download(Q,v)}}}var u=Q(706),y=Q(809),z=Q(800),B=Q(11901),X=Q(2072),m=Q(508),V=Q(686),h=Q(664);const S=h.HighestCommonFactor,A={...h,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:S};var f=Q(2033),P=Q(2041),O=Q(11909),J=Q(11913),K=Q(2237);const o=1e-6,g=new V.c(.04,.04,.04),R=1024,M=V.c.White(),Y=V.c.Black();function D(v,d,Q){if(d<g.r)return 0;const n=g.r,T=v*Q/(1-g.r)+d-2*g.r,L=T*T-4*n*(g.r-d);return A.Clamp((-T+Math.sqrt(L))/(2*n),0,1)}function i(v){const d=v.diffuseColor.toLinearSpace(v.va().getEngine().useExactSrgbConversions).scale(.5),Q=v.alpha,T=function(v){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new n.i(0,1),Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new n.i(0,.1),T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new n.i(0,.1),L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new n.i(1300,.1);return function(v,d,Q,n,T){return(1-v)*(1-v)*(1-v)*d+3*(1-v)*(1-v)*v*Q+3*(1-v)*v*v*n+v*v*v*T}(Math.pow(v/L.x,.333333),d.y,Q.y,T.y,L.y)}(A.Clamp(v.specularPower,0,R));return{baseColorFactor:[d.r,d.g,d.b,Q],metallicFactor:0,roughnessFactor:T}}function Z(v,d){d.needAlphaBlending()?v.alphaMode="BLEND":d.needAlphaTesting()&&(v.alphaMode="MASK",v.alphaCutoff=d.alphaCutOff)}function j(v,d,Q){const n=new Uint8Array(v*d*4);for(let T=0;T<n.length;T+=4)n[T]=n[T+1]=n[T+2]=n[T+3]=255;return O.c.CreateRGBATexture(n,v,d,Q)}function x(v){if(v instanceof Uint8Array){const d=v.length,Q=new Float32Array(v.length);for(let n=0;n<d;++n)Q[n]=v[n]/255;return Q}if(v instanceof Float32Array)return v;throw new Error("Unsupported pixel format!")}class k{constructor(v){this._exporter=v,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(v){return v?this._textureMap.get(v)??null:null}async exportStandardMaterialAsync(v,d,Q){const n=i(v),L={name:v.name};if(null==v.pk||v.pk||(v.twoSidedLighting||T.e.Warn(v.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),L.doubleSided=!0),Q){const Q=[],T=v.diffuseTexture;T&&Q.push(this.exportTextureAsync(T,d).then((v=>{v&&(n.baseColorTexture=v)})));const e=v.bumpTexture;e&&Q.push(this.exportTextureAsync(e,d).then((v=>{v&&(L.normalTexture=v,1!==e.level&&(L.normalTexture.scale=e.level))})));const F=v.emissiveTexture;F&&(L.emissiveFactor=[1,1,1],Q.push(this.exportTextureAsync(F,d).then((v=>{v&&(L.emissiveTexture=v)}))));const r=v.ambientTexture;r&&Q.push(this.exportTextureAsync(r,d).then((v=>{if(v){const d={index:v.index};L.occlusionTexture=d}}))),Q.length>0&&(this._exporter._materialNeedsUVsSet.add(v),await Promise.all(Q))}(v.alpha<1||v.opacityTexture)&&(v.alphaMode===J.e.ALPHA_COMBINE?L.alphaMode="BLEND":T.e.Warn(v.name+": glTF 2.0 does not support alpha mode: "+v.alphaMode.toString())),v.emissiveColor&&!v.emissiveColor.equalsWithEpsilon(Y,o)&&(L.emissiveFactor=v.emissiveColor.mk()),L.pbrMetallicRoughness=n,Z(L,v),await this._finishMaterialAsync(L,v,d);const e=this._exporter._materials;return e.push(L),e.length-1}async _finishMaterialAsync(v,d,Q){const n=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",v,d),T=[];for(const L of n)T.push(this.exportTextureAsync(L,Q));await Promise.all(T),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",v,d)}async _getImageDataAsync(v,d,n,T){const L=J.e.TEXTURETYPE_UNSIGNED_BYTE,e=this._exporter._babylonScene,F=e.getEngine(),r=F.createRawTexture(v,d,n,J.e.TEXTUREFORMAT_RGBA,!1,!0,P.e.NEAREST_SAMPLINGMODE,null,L);F.isWebGPU?await Q.e(45).then(Q.bind(Q,13490)):await Q.e(46).then(Q.bind(Q,13497)),await f.j.ApplyPostProcess("pass",r,e,L,J.e.TEXTURE_NEAREST_SAMPLINGMODE,J.e.TEXTUREFORMAT_RGBA);const C=await F._readTexturePixels(r,d,n);return await K.DumpTools.DumpDataAsync(d,n,C,T,void 0,!0,!0)}_resizeTexturesToSameDimensions(v,d,Q){const n=v?v.getSize():{width:0,height:0},T=d?d.getSize():{width:0,height:0};let L,e;return n.width<T.width?(L=v&&v instanceof P.e?f.j.CreateResizedCopy(v,T.width,T.height,!0):j(T.width,T.height,Q),e=d):n.width>T.width?(e=d&&d instanceof P.e?f.j.CreateResizedCopy(d,n.width,n.height,!0):j(n.width,n.height,Q),L=v):(L=v,e=d),{texture1:L,texture2:e}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(v,d,Q,n){const T=new Array;if(!v&&!d)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const L=v?v.va():d?d.va():null;if(L){var e;const F=this._resizeTexturesToSameDimensions(v,d,L),r=null===(e=F.texture1)||void 0===e?void 0:e.getSize();let C,u;const y=r.width,z=r.height,B=await F.texture1.readPixels(),X=await F.texture2.readPixels();if(!B)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=x(B),!X)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");u=x(X);const m=u.byteLength,h=new Uint8Array(m),S=new Uint8Array(m),A=4,f=Y;let P=0,O=0;for(let v=0;v<z;++v)for(let d=0;d<y;++d){const n=(y*v+d)*A,T={diffuseColor:new V.c(C[n],C[n+1],C[n+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(Q.diffuseColor),specularColor:new V.c(u[n],u[n+1],u[n+2]).toLinearSpace(L.getEngine().useExactSrgbConversions).multiply(Q.specularColor),glossiness:u[n+3]*Q.glossiness},e=this._convertSpecularGlossinessToMetallicRoughness(T);f.r=Math.max(f.r,e.baseColor.r),f.g=Math.max(f.g,e.baseColor.g),f.b=Math.max(f.b,e.baseColor.b),P=Math.max(P,e.metallic),O=Math.max(O,e.roughness),S[n]=255*e.baseColor.r,S[n+1]=255*e.baseColor.g,S[n+2]=255*e.baseColor.b,S[n+3]=F.texture1.ui?255*C[n+3]:255,h[n]=0,h[n+1]=255*e.roughness,h[n+2]=255*e.metallic,h[n+3]=255}const J={baseColor:f,metallic:P,roughness:O};let K=!1,g=!1;for(let v=0;v<z;++v)for(let d=0;d<y;++d){const Q=(y*v+d)*A;S[Q]/=J.baseColor.r>o?J.baseColor.r:1,S[Q+1]/=J.baseColor.g>o?J.baseColor.g:1,S[Q+2]/=J.baseColor.b>o?J.baseColor.b:1;const n=V.c.FromInts(S[Q],S[Q+1],S[Q+2]).toGammaSpace(L.getEngine().useExactSrgbConversions);S[Q]=255*n.r,S[Q+1]=255*n.g,S[Q+2]=255*n.b,n.equalsWithEpsilon(M,o)||(g=!0),h[Q+1]/=J.roughness>o?J.roughness:1,h[Q+2]/=J.metallic>o?J.metallic:1;V.c.FromInts(255,h[Q+1],h[Q+2]).equalsWithEpsilon(M,o)||(K=!0)}return K&&T.push(this._getImageDataAsync(h,y,z,n).then((v=>{J.metallicRoughnessTextureData=v}))),g&&T.push(this._getImageDataAsync(S,y,z,n).then((v=>{J.baseColorTextureData=v}))),await Promise.all(T).then((()=>J))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(v){const d=this._getPerceivedBrightness(v.diffuseColor),Q=this._getPerceivedBrightness(v.specularColor),n=1-this._getMaxComponent(v.specularColor),T=D(d,Q,n),L=v.diffuseColor.scale(n/(1-g.r)/Math.max(1-T)),e=v.specularColor.Wd(g.scale(1-T)).scale(1/Math.max(T));let F=V.c.Lerp(L,e,T*T);F=F.clampToRef(0,1,F);return{baseColor:F,metallic:T,roughness:1-v.glossiness}}_getPerceivedBrightness(v){return v?Math.sqrt(.299*v.r*v.r+.587*v.g*v.g+.114*v.b*v.b):0}_getMaxComponent(v){return v?Math.max(v.r,Math.max(v.g,v.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(v,d,Q,n){const T=[],L={baseColor:v._albedoColor,metallic:v._metallic,roughness:v._roughness};if(n){v._albedoTexture&&T.push(this.exportTextureAsync(v._albedoTexture,d).then((v=>{v&&(Q.baseColorTexture=v)})));const n=v._metallicTexture;n&&T.push(this.exportTextureAsync(n,d).then((v=>{v&&(Q.metallicRoughnessTexture=v)})))}return T.length>0&&(this._exporter._materialNeedsUVsSet.add(v),await Promise.all(T)),L}_getTextureSampler(v){const d={};if(!v||!(v instanceof P.e))return d;const Q=this._getGLTFTextureWrapMode(v.wrapU);10497!==Q&&(d.wrapS=Q);const n=this._getGLTFTextureWrapMode(v.wrapV);switch(10497!==n&&(d.wrapT=n),v.samplingMode){case P.e.LINEAR_LINEAR:d.magFilter=9729,d.minFilter=9729;break;case P.e.LINEAR_NEAREST:d.magFilter=9729,d.minFilter=9728;break;case P.e.NEAREST_LINEAR:d.magFilter=9728,d.minFilter=9729;break;case P.e.NEAREST_LINEAR_MIPLINEAR:d.magFilter=9728,d.minFilter=9987;break;case P.e.NEAREST_NEAREST:d.magFilter=9728,d.minFilter=9728;break;case P.e.NEAREST_LINEAR_MIPNEAREST:d.magFilter=9728,d.minFilter=9985;break;case P.e.LINEAR_NEAREST_MIPNEAREST:d.magFilter=9729,d.minFilter=9984;break;case P.e.LINEAR_NEAREST_MIPLINEAR:d.magFilter=9729,d.minFilter=9986;break;case P.e.NEAREST_NEAREST_MIPLINEAR:d.magFilter=9728,d.minFilter=9986;break;case P.e.LINEAR_LINEAR_MIPLINEAR:d.magFilter=9729,d.minFilter=9987;break;case P.e.LINEAR_LINEAR_MIPNEAREST:d.magFilter=9729,d.minFilter=9985;break;case P.e.NEAREST_NEAREST_MIPNEAREST:d.magFilter=9728,d.minFilter=9984}return d}_getGLTFTextureWrapMode(v){switch(v){case P.e.WRAP_ADDRESSMODE:return 10497;case P.e.CLAMP_ADDRESSMODE:return 33071;case P.e.MIRROR_ADDRESSMODE:return 33648;default:return T.e.Error(`Unsupported Texture Wrap Mode ${v}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(v,d,Q,n){const T={diffuseColor:v._albedoColor,specularColor:v._reflectivityColor,glossiness:v._microSurface},L=v._albedoTexture,e=v._reflectivityTexture,F=v._useMicroSurfaceFromReflectivityMapAlpha;if(e&&!F)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((L||e)&&n){this._exporter._materialNeedsUVsSet.add(v);const n=this._exportTextureSampler(L||e),F=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(L,e,T,d),r=this._exporter._textures;if(F.baseColorTextureData){const v=this._exportImage(`baseColor${r.length}`,d,F.baseColorTextureData);Q.baseColorTexture=this._exportTextureInfo(v,n,null===L||void 0===L?void 0:L.coordinatesIndex)}if(F.metallicRoughnessTextureData){const v=this._exportImage(`metallicRoughness${r.length}`,d,F.metallicRoughnessTextureData);Q.metallicRoughnessTexture=this._exportTextureInfo(v,n,null===e||void 0===e?void 0:e.coordinatesIndex)}return F}return this._convertSpecularGlossinessToMetallicRoughness(T)}async exportPBRMaterialAsync(v,d,Q){const n={},T={name:v.name},L=v.isMetallicWorkflow();if(L){const d=v._albedoColor,Q=v.alpha;d&&(n.baseColorFactor=[d.r,d.g,d.b,Q])}const e=L?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(v,d,n,Q):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(v,d,n,Q);await this._setMetallicRoughnessPbrMaterialAsync(e,v,T,n,d,Q),await this._finishMaterialAsync(T,v,d);const F=this._exporter._materials;return F.push(T),F.length-1}async _setMetallicRoughnessPbrMaterialAsync(v,d,Q,n,L,e){if(Z(Q,d),v.baseColor.equalsWithEpsilon(M,o)&&A.WithinEpsilon(d.alpha,1,o)||(n.baseColorFactor=[v.baseColor.r,v.baseColor.g,v.baseColor.b,d.alpha]),null!=v.metallic&&1!==v.metallic&&(n.metallicFactor=v.metallic),null!=v.roughness&&1!==v.roughness&&(n.roughnessFactor=v.roughness),null==d.pk||d.pk||(d._twoSidedLighting||T.e.Warn(d.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Q.doubleSided=!0),e){const v=[],n=d._bumpTexture;n&&v.push(this.exportTextureAsync(n,L).then((v=>{v&&(Q.normalTexture=v,1!==n.level&&(Q.normalTexture.scale=n.level))})));const T=d._ambientTexture;T&&v.push(this.exportTextureAsync(T,L).then((v=>{if(v){const n={index:v.index,texCoord:v.texCoord,extensions:v.extensions};Q.occlusionTexture=n;const T=d._ambientTextureStrength;T&&(n.strength=T)}})));const e=d._emissiveTexture;e&&v.push(this.exportTextureAsync(e,L).then((v=>{v&&(Q.emissiveTexture=v)}))),v.length>0&&(this._exporter._materialNeedsUVsSet.add(d),await Promise.all(v))}const F=d._emissiveColor;F.equalsWithEpsilon(Y,o)||(Q.emissiveFactor=F.mk()),Q.pbrMetallicRoughness=n}_getPixelsFromTextureAsync(v){return function(v){switch(v){case J.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case J.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case J.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case J.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case J.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case J.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case J.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case J.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case J.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case J.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case J.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case J.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case J.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(v.textureFormat)?(0,f.f)(v,v._texture.width,v._texture.height):(v.textureType,J.e.TEXTURETYPE_UNSIGNED_BYTE,v.readPixels())}async exportTextureAsync(v,d){const Q=this._exporter._extensionsPreExportTextureAsync("exporter",v,d);return Q?await Q.then((async Q=>Q?await this._exportTextureInfoAsync(Q,d):await this._exportTextureInfoAsync(v,d))):await this._exportTextureInfoAsync(v,d)}async _exportTextureInfoAsync(v,d){let Q=this._textureMap.get(v);if(!Q){const n=await this._getPixelsFromTextureAsync(v);if(!n)return null;const L=this._exportTextureSampler(v),e=v.mimeType;if(e)switch(e){case"image/jpeg":case"image/png":case"image/webp":d=e;break;default:T.e.Warn(`Unsupported media type: ${e}. Exporting texture as PNG.`)}const F=this._internalTextureToImage,r=v.getInternalTexture().uniqueId;F[r]||(F[r]={});let C=F[r][d];if(void 0===C){const Q=v.getSize();C=(async()=>{const T=await this._getImageDataAsync(n,Q.width,Q.height,d);return this._exportImage(v.name,d,T)})(),F[r][d]=C}Q=this._exportTextureInfo(await C,L,v.coordinatesIndex),this._textureMap.set(v,Q),this._exporter._extensionsPostExportTextures("exporter",Q,v)}return Q}_exportImage(v,d,Q){const n=this._exporter._images;let L;if(this._exporter._shouldUseGlb){L={name:v,mimeType:d,bufferView:void 0};const n=this._exporter._bufferManager.createBufferView(new Uint8Array(Q));this._exporter._bufferManager.setBufferView(L,n)}else{const e=v.replace(/\.\/|\/|\.\\|\\/g,"_"),F=function(v){switch(v){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(d);let r=e+F;n.some((v=>v.uri===r))&&(r=`${e}_${T.e.RandomId()}${F}`),L={name:v,uri:r},this._exporter._imageData[r]={data:Q,mimeType:d}}return n.push(L),n.length-1}_exportTextureInfo(v,d,Q){const n=this._exporter._textures;let T=n.findIndex((Q=>Q.sampler==d&&Q.source===v));-1===T&&(T=n.length,n.push({source:v,sampler:d}));const L={index:T};return Q&&(L.texCoord=Q),L}_exportTextureSampler(v){const d=this._getTextureSampler(v),Q=this._exporter._samplers,n=Q.findIndex((v=>v.minFilter===d.minFilter&&v.magFilter===d.magFilter&&v.wrapS===d.wrapS&&v.wrapT===d.wrapT));return-1!==n?n:(Q.push(d),Q.length-1)}}var t=Q(722),p=Q(482),W=Q(11916),q=Q(658);const b=n.j.Zero(),H=n.c.Identity(),s=n.j.One(),a=new n.j(-1,1,1);function I(v,d){const{byteOffset:Q,byteStride:n,type:T,normalized:L}=v,e=v.getSize(),F=d.reduce(((v,d)=>d.getTotalVertices()>v?d.getTotalVertices():v),-Number.MAX_VALUE);return{byteOffset:Q,byteStride:n,componentCount:e,type:T,count:F*e,normalized:L,totalVertices:F,kind:v.getKind()}}function U(v){switch(v){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function c(v){switch(v){case u.e.PositionKind:case u.e.NormalKind:case u.e.TangentKind:case u.e.ColorKind:case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:case u.e.MatricesWeightsKind:case u.e.MatricesWeightsExtraKind:case u.e.UVKind:case u.e.UV2Kind:case u.e.UV3Kind:case u.e.UV4Kind:case u.e.UV5Kind:case u.e.UV6Kind:return!0}return!1}function w(v){switch(v){case L.c.TriangleFillMode:return 4;case L.c.TriangleStripDrawMode:return 5;case L.c.TriangleFanDrawMode:return 6;case L.c.PointListDrawMode:case L.c.PointFillMode:return 0;case L.c.LineLoopDrawMode:return 2;case L.c.LineListDrawMode:return 1;case L.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${v}`)}function G(v){const d=Math.sqrt(v.x*v.x+v.y*v.y+v.z*v.z);d>0&&(v.x/=d,v.y/=d,v.z/=d)}function E(v){return v.x*=-1,v}function N(v){if(v.x*v.x+v.y*v.y>.5){const d=Math.abs(v.x),Q=Math.abs(v.y);if(d>Q){const Q=Math.sign(v.x);v.x=d,v.y*=-Q,v.z*=-Q,v.w*=Q}else{const d=Math.sign(v.y);v.x*=-d,v.y=Q,v.z*=d,v.w*=-d}}else{const d=Math.abs(v.z),Q=Math.abs(v.w);if(d>Q){const Q=Math.sign(v.z);v.x*=-Q,v.y*=Q,v.z=d,v.w*=-Q}else{const d=Math.sign(v.w);v.x*=d,v.y*=-d,v.z*=-d,v.w=Q}}return v}function l(v){v.ld(-v.z,v.w,v.x,-v.y)}function vv(v,d){const Q=n.j.FromArrayToRef(d.translation||[0,0,0],0,n.g.fk[0]),T=n.c.FromArrayToRef(d.rotation||[0,0,0,1],0,n.g.Quaternion[0]),L=n.b.ComposeToRef(s,T,Q,n.g.Matrix[0]),e=n.j.FromArrayToRef(v.translation||[0,0,0],0,n.g.fk[2]),F=n.c.FromArrayToRef(v.rotation||[0,0,0,1],0,n.g.Quaternion[1]),r=n.b.ComposeToRef(s,F,e,n.g.Matrix[1]);L.multiplyToRef(r,r),r.decompose(void 0,T,Q),Q.equalsWithEpsilon(b,q.b)?delete d.translation:d.translation=Q.mk(),T.equalsWithEpsilon(H,q.b)?delete d.rotation:d.rotation=T.mk(),d.scale&&delete d.scale}function dv(v,d){if(!(d instanceof y.d))return!1;if(!(1===d.getChildren().length&&0===v.getChildren().length&&v.parent===d))return!1;const Q=v.va(),n=v instanceof W.e&&!Q.useRightHandedSystem?a:s;return!!d.md.equalsWithEpsilon(n,q.b)||(p.d.Warn(`Cannot collapse node ${v.name} into parent node ${d.name} with modified scaling.`),!1)}function Qv(v){if(v instanceof Array){const d=new Float32Array(v);return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}return ArrayBuffer.isView(v)?new Uint8Array(v.buffer,v.byteOffset,v.byteLength):new Uint8Array(v)}function nv(v,d){for(const[Q,n]of Object.entries(v)){const T=d[Q];(Array.isArray(n)&&Array.isArray(T)&&Tv(n,T)||n===T)&&delete v[Q]}return v}function Tv(v,d){return v.length===d.length&&v.every(((v,Q)=>v===d[Q]))}const Lv=n.b.Compose(new n.j(-1,1,1),n.c.Identity(),n.j.Zero());function ev(v,d){if(!(v instanceof y.d))return!1;if(d){if(!v.getWorldMatrix().equalsWithEpsilon(n.b.IdentityReadOnly,q.b))return!1}else{if(!v.getWorldMatrix().multiplyToRef(Lv,n.g.Matrix[0]).equalsWithEpsilon(n.b.IdentityReadOnly,q.b))return!1}return!(v instanceof z.d&&v.sk)}const Fv=new Map([[Int8Array,(v,d,Q)=>v.setInt8(d,Q)],[Uint8Array,(v,d,Q)=>v.setUint8(d,Q)],[Uint8ClampedArray,(v,d,Q)=>v.setUint8(d,Q)],[Int16Array,(v,d,Q)=>v.setInt16(d,Q,!0)],[Uint16Array,(v,d,Q)=>v.setUint16(d,Q,!0)],[Int32Array,(v,d,Q)=>v.setInt32(d,Q,!0)],[Uint32Array,(v,d,Q)=>v.setUint32(d,Q,!0)],[Float32Array,(v,d,Q)=>v.setFloat32(d,Q,!0)],[Float64Array,(v,d,Q)=>v.setFloat64(d,Q,!0)]]);class rv{writeTypedArray(v){this._checkGrowBuffer(v.byteLength);const d=Fv.get(v.constructor);for(let Q=0;Q<v.length;Q++)d(this._dataView,this._byteOffset,v[Q]),this._byteOffset+=v.BYTES_PER_ELEMENT}constructor(v){this._data=new Uint8Array(v),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(v){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,v),this._byteOffset++}writeInt8(v){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,v),this._byteOffset++}writeInt16(v){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,v,!0),this._byteOffset+=2}writeUInt16(v){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,v,!0),this._byteOffset+=2}writeInt32(v){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,v,!0),this._byteOffset+=4}writeUInt32(v){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,v,!0),this._byteOffset+=4}writeFloat32(v){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,v,!0),this._byteOffset+=4}writeFloat64(v){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,v,!0),this._byteOffset+=8}_checkGrowBuffer(v){const d=this.byteOffset+v;if(d>this._data.byteLength){const v=new Uint8Array(2*d);v.set(this._data),this._data=v,this._dataView=new DataView(this._data.buffer)}}}function Cv(v){return v%4===0?4:v%2===0?2:1}class uv{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(v){let d=0;this._bufferViewToData.forEach((v=>{d+=v.byteLength}));const Q=new rv(d),n=Array.from(this._bufferViewToData.keys()).sort(((v,d)=>Cv(d.byteLength)-Cv(v.byteLength)));for(const T of n){T.byteOffset=Q.byteOffset,v.push(T);const d=v.length-1,n=this.getPropertiesWithBufferView(T);for(const v of n)v.bufferView=d;Q.writeTypedArray(this._bufferViewToData.get(T)),this._bufferViewToData.delete(T)}return Q.getOutputData()}createBufferView(v,d){const Q={buffer:0,byteOffset:void 0,byteLength:v.byteLength,byteStride:d};return this._bufferViewToData.set(Q,v),Q}createAccessor(v,d,Q,n,T,L,e){this._verifyBufferView(v);const F={bufferView:void 0,componentType:Q,count:n,type:d,min:null===L||void 0===L?void 0:L.min,max:null===L||void 0===L?void 0:L.max,normalized:e,byteOffset:T};return this.setBufferView(F,v),this._accessorToBufferView.set(F,v),F}setBufferView(v,d){this._verifyBufferView(d);this.getPropertiesWithBufferView(d).push(v)}removeBufferView(v){const d=this.getPropertiesWithBufferView(v);for(const Q of d)void 0!==Q.bufferView&&delete Q.bufferView;this._bufferViewToData.delete(v),this._bufferViewToProperties.delete(v),this._accessorToBufferView.forEach(((d,Q)=>{d===v&&(void 0!==Q.byteOffset&&delete Q.byteOffset,this._accessorToBufferView.delete(Q))}))}getBufferView(v){const d=this._accessorToBufferView.get(v);return this._verifyBufferView(d),d}getPropertiesWithBufferView(v){return this._verifyBufferView(v),this._bufferViewToProperties.set(v,this._bufferViewToProperties.get(v)??[]),this._bufferViewToProperties.get(v)}getData(v){return this._verifyBufferView(v),this._bufferViewToData.get(v)}_verifyBufferView(v){if(void 0===v||!this._bufferViewToData.has(v))throw new Error(`BufferView ${v} not found in BufferManager.`)}}var yv,zv=Q(616),Bv=Q(854),Xv=Q(11923),mv=Q(11993),Vv=Q(12002),hv=Q(12015),Sv=Q(470),Av=Q(12023);!function(v){v[v.INTANGENT=0]="INTANGENT",v[v.OUTTANGENT=1]="OUTTANGENT"}(yv||(yv={}));class fv{static _IsTransformable(v){return v&&(v instanceof y.d||v instanceof zv.c||v instanceof Av.d)}static _CreateNodeAnimation(v,d,Q,n,L){if(this._IsTransformable(v)){const e=[],F=[],r=d.getKeys(),C=fv._CalculateMinMaxKeyFrames(r),u=fv._DeduceInterpolation(r,Q,n),y=u.interpolationType,z=u.shouldBakeAnimation;if(z?fv._CreateBakedAnimation(v,d,Q,C.min,C.max,d.framePerSecond,L,e,F,C,n):"LINEAR"===y||"STEP"===y?fv._CreateLinearOrStepAnimation(v,d,Q,e,F,n):"CUBICSPLINE"===y?fv._CreateCubicSplineAnimation(v,d,Q,e,F,n):fv._CreateBakedAnimation(v,d,Q,C.min,C.max,d.framePerSecond,L,e,F,C,n),e.length&&F.length){return{inputs:e,outputs:F,samplerInterpolation:y,inputsMin:z?C.min:T.e.FloatRound(C.min/d.framePerSecond),inputsMax:z?C.max:T.e.FloatRound(C.max/d.framePerSecond)}}}return null}static _DeduceAnimationInfo(v){let d=null,Q="VEC3",n=!1;const L=v.targetProperty.split(".");switch(L[0]){case"md":d="scale";break;case"position":d="translation";break;case"rotation":Q="VEC4",d="rotation";break;case"rotationQuaternion":Q="VEC4",n=!0,d="rotation";break;case"influence":Q="SCALAR",d="weights";break;default:T.e.Error(`Unsupported animatable property ${L[0]}`)}return d?{animationChannelTargetPath:d,dataAccessorType:Q,useQuaternion:n}:(T.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(v,d,Q,n,T,L,e,F,r,C,u){let y;if(fv._IsTransformable(v)&&v.animations)for(const z of v.animations){if(u&&!u(z))continue;const T=fv._DeduceAnimationInfo(z);T&&(y={name:z.name,samplers:[],channels:[]},fv._AddAnimation(`${z.name}`,z.hasRunningRuntimeAnimations?d:y,v,z,T.dataAccessorType,T.animationChannelTargetPath,n,L,e,F,T.useQuaternion,r,C),y.samplers.length&&y.channels.length&&Q.push(y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(v,d,Q,n,T,L,e,F,r,C,u){let y;if(v instanceof Sv.b){const T=v.morphTargetManager;if(T)for(let z=0;z<T.numTargets;++z){const B=T.getTarget(z);for(const X of B.animations){if(u&&!u(X))continue;const B=new Vv.d(`${X.name}`,"influence",X.framePerSecond,X.dataType,X.loopMode,X.enableBlending),m=[],V=X.getKeys();for(let v=0;v<V.length;++v){const d=V[v];for(let v=0;v<T.numTargets;++v)v==z?m.push(d):m.push({frame:d.frame,value:0})}B.setKeys(m);const h=fv._DeduceAnimationInfo(B);h&&(y={name:B.name,samplers:[],channels:[]},fv._AddAnimation(X.name,X.hasRunningRuntimeAnimations?d:y,v,B,h.dataAccessorType,h.animationChannelTargetPath,n,L,e,F,h.useQuaternion,r,C,T.numTargets),y.samplers.length&&y.channels.length&&Q.push(y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(v,d,Q,n,T,L,e,F,r){let C;if(v.animationGroups){const y=v.animationGroups;for(const z of y){const y=new Map,B=new Map,X=new Set,m=z.to-z.from;C={name:z.name,channels:[],samplers:[]};for(let d=0;d<z.targetedAnimations.length;++d){const m=z.targetedAnimations[d],V=m.target,h=m.animation;if(r&&!r(h))continue;const S=F.has(V);if(this._IsTransformable(V)||1===V.length&&this._IsTransformable(V[0])){const v=fv._DeduceAnimationInfo(m.animation);if(v){const d=this._IsTransformable(V)?V:this._IsTransformable(V[0])?V[0]:null;d&&fv._AddAnimation(`${h.name}`,C,d,h,v.dataAccessorType,v.animationChannelTargetPath,Q,n,T,L,v.useQuaternion,e,S)}}else if(V instanceof hv.e||1===V.length&&V[0]instanceof hv.e){if(fv._DeduceAnimationInfo(m.animation)){const d=V instanceof hv.e?V:V[0];if(d){const Q=v.morphTargetManagers.find((v=>{for(let Q=0;Q<v.numTargets;++Q)if(v.getTarget(Q)===d)return!0;return!1}));if(Q){const n=v.meshes.find((v=>v.morphTargetManager===Q));var u;if(n)y.has(n)||y.set(n,new Map),null===(u=y.get(n))||void 0===u||u.set(d,h),X.add(n),B.set(n,h)}}}}}X.forEach((v=>{const d=v.morphTargetManager;let F=null;const r=[],u=B.get(v).getKeys(),X=u.length;for(let Q=0;Q<X;++Q)for(let n=0;n<d.numTargets;++n){const T=d.getTarget(n),L=y.get(v);if(L){const d=L.get(T);d?(F||(F=new Vv.d(`${z.name}_${v.name}_MorphWeightAnimation`,"influence",d.framePerSecond,Vv.d.ANIMATIONTYPE_FLOAT,d.loopMode,d.enableBlending)),r.push(d.getKeys()[Q])):r.push({frame:z.from+m/X*Q,value:T.influence,inTangent:u[0].inTangent?0:void 0,outTangent:u[0].outTangent?0:void 0})}}F.setKeys(r);const V=fv._DeduceAnimationInfo(F);V&&fv._AddAnimation(`${z.name}_${v.name}_MorphWeightAnimation`,C,v,F,V.dataAccessorType,V.animationChannelTargetPath,Q,n,T,L,V.useQuaternion,e,!1,null===d||void 0===d?void 0:d.numTargets)})),C.channels.length&&C.samplers.length&&d.push(C)}}}static _AddAnimation(v,d,Q,T,L,e,F,r,C,u,y,z,B,X){const m=fv._CreateNodeAnimation(Q,T,e,y,z);let V,h,S,A,f,P;if(m){if(X){let v=0,d=0;const Q=[];for(;m.inputs.length>0;)d=m.inputs.shift(),v%X==0&&Q.push(d),v++;m.inputs=Q}const v=F.get(Q),T=new Float32Array(m.inputs);V=r.createBufferView(T),h=r.createAccessor(V,"SCALAR",5126,m.inputs.length,void 0,{min:[m.inputsMin],max:[m.inputsMax]}),u.push(h),S=u.length-1;const C=new n.c,y=new n.j,z=new n.j,O=Q instanceof zv.c,J=U(L),K=new Float32Array(m.outputs.length*J);m.outputs.forEach((function(v,d){let Q=v;switch(e){case"translation":B&&(n.j.FromArrayToRef(v,0,z),E(z),z.toArray(Q));break;case"rotation":4===v.length?n.c.FromArrayToRef(v,0,C):(Q=new Array(4),n.j.FromArrayToRef(v,0,y),n.c.FromEulerVectorToRef(y,C)),B&&(N(C),O&&l(C)),C.toArray(Q)}K.set(Q,d*J)})),V=r.createBufferView(K),h=r.createAccessor(V,L,5126,m.outputs.length),u.push(h),A=u.length-1,f={interpolation:m.samplerInterpolation,input:S,output:A},d.samplers.push(f),P={sampler:d.samplers.length-1,target:{node:v,path:e}},d.channels.push(P)}}static _CreateBakedAnimation(v,d,Q,L,e,F,r,C,u,y,z){let B;const X=n.c.Identity();let m,V=null,h=null,S=null,A=null,f=null,P=null;y.min=T.e.FloatRound(L/F);const O=d.getKeys();for(let n=0,J=O.length;n<J;++n){if(P=null,S=O[n],n+1<J)if(A=O[n+1],S.value.equals&&S.value.equals(A.value)||S.value===A.value){if(0!==n)continue;P=S.frame}else P=A.frame;else{if(f=O[n-1],S.value.equals&&S.value.equals(f.value)||S.value===f.value)continue;P=e}if(P)for(let n=S.frame;n<=P;n+=r){if(m=T.e.FloatRound(n/F),m===V)continue;V=m,h=m;const L={key:0,repeatCount:0,loopMode:d.loopMode};B=d._interpolate(n,L),fv._SetInterpolatedValue(v,B,m,d,Q,X,C,u,z)}}h&&(y.max=h)}static _ConvertFactorToVector3OrQuaternion(v,d,Q,L,e){const F=fv._GetBasePositionRotationOrScale(d,L,e),r=Q.targetProperty.split("."),C=r?r[1]:"",u=e?n.c.dk(F).normalize():n.j.dk(F);switch(C){case"x":case"y":case"z":u[C]=v;break;case"w":u.w=v;break;default:T.e.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return u}static _SetInterpolatedValue(v,d,Q,T,L,e,F,r,C){let u;F.push(Q),"weights"!==L?(T.dataType===Vv.d.ANIMATIONTYPE_FLOAT&&(d=this._ConvertFactorToVector3OrQuaternion(d,v,T,L,C)),"rotation"===L?(C?e=d:(u=d,n.c.RotationYawPitchRollToRef(u.y,u.x,u.z,e)),r.push(e.mk())):(u=d,r.push(u.mk()))):r.push([d])}static _CreateLinearOrStepAnimation(v,d,Q,n,T,L){for(const e of d.getKeys())n.push(e.frame/d.framePerSecond),fv._AddKeyframeValue(e,d,T,Q,v,L)}static _CreateCubicSplineAnimation(v,d,Q,n,T,L){d.getKeys().forEach((function(e){n.push(e.frame/d.framePerSecond),fv._AddSplineTangent(yv.INTANGENT,T,Q,"CUBICSPLINE",e,L),fv._AddKeyframeValue(e,d,T,Q,v,L),fv._AddSplineTangent(yv.OUTTANGENT,T,Q,"CUBICSPLINE",e,L)}))}static _GetBasePositionRotationOrScale(v,d,Q){let T;if("rotation"===d)if(Q){T=(v.rotationQuaternion??n.c.Identity()).mk()}else{T=(v.rotation??n.j.Zero()).mk()}else if("translation"===d){T=(v.position??n.j.Zero()).mk()}else{T=(v.md??n.j.One()).mk()}return T}static _AddKeyframeValue(v,d,Q,L,e,F){let r;const C=d.dataType;if(C===Vv.d.ANIMATIONTYPE_VECTOR3){let d=v.value.mk();if("rotation"===L){const v=n.j.dk(d);d=n.c.RotationYawPitchRoll(v.y,v.x,v.z).mk()}Q.push(d)}else if(C===Vv.d.ANIMATIONTYPE_FLOAT){if("weights"===L)Q.push([v.value]);else if(r=this._ConvertFactorToVector3OrQuaternion(v.value,e,d,L,F),r){if("rotation"===L){const v=F?r:n.c.RotationYawPitchRoll(r.y,r.x,r.z).normalize();Q.push(v.mk())}Q.push(r.mk())}}else C===Vv.d.ANIMATIONTYPE_QUATERNION?Q.push(v.value.normalize().mk()):T.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(v,d,Q){let n,T,L=!1;if("rotation"===d&&!Q)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let e=0,F=v.length;e<F;++e)if(T=v[e],T.inTangent||T.outTangent)if(n){if("CUBICSPLINE"!==n){n="LINEAR",L=!0;break}}else n="CUBICSPLINE";else if(n){if("CUBICSPLINE"===n||T.interpolation&&1===T.interpolation&&"STEP"!==n){n="LINEAR",L=!0;break}}else n=T.interpolation&&1===T.interpolation?"STEP":"LINEAR";return n||(n="LINEAR"),{interpolationType:n,shouldBakeAnimation:L}}static _AddSplineTangent(v,d,Q,T,L,e){let F;const r=v===yv.INTANGENT?L.inTangent:L.outTangent;if("CUBICSPLINE"===T){if("rotation"===Q)if(r)if(e)F=r.mk();else{const v=r;F=n.c.RotationYawPitchRoll(v.y,v.x,v.z).mk()}else F=[0,0,0,0];else F="weights"===Q?r?[r]:[0]:r?r.mk():[0,0,0];d.push(F)}}static _CalculateMinMaxKeyFrames(v){let d=1/0,Q=-1/0;return v.forEach((function(v){d=Math.min(d,v.frame),Q=Math.max(Q,v.frame)})),{min:d,max:Q}}}function Pv(v,d,Q,L,e,F){const r={attributes:{},influence:v.influence,name:v.name},C=d.sk;if(!C)return T.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),r;const y=F?-1:1,z=n.j.Zero();let B=0,X=0;if(v.hasPositions){const L=v.getPositions(),F=C.getVerticesData(u.e.PositionKind);if(F){const v=new Float32Array(F.length),d=[1/0,1/0,1/0],T=[-1/0,-1/0,-1/0];X=F.length/3,B=0;for(let Q=B;Q<X;++Q){const e=n.j.dk(F,3*Q);n.j.dk(L,3*Q).subtractToRef(e,z),z.x*=y,d[0]=Math.min(d[0],z.x),T[0]=Math.max(T[0],z.x),d[1]=Math.min(d[1],z.y),T[1]=Math.max(T[1],z.y),d[2]=Math.min(d[2],z.z),T[2]=Math.max(T[2],z.z),v[3*Q]=z.x,v[3*Q+1]=z.y,v[3*Q+2]=z.z}const C=Q.createBufferView(v,12),u=Q.createAccessor(C,"VEC3",5126,L.length/3,0,{min:d,max:T});e.push(u),r.attributes.POSITION=e.length-1}else T.e.Warn(`Morph target positions for mesh ${d.name} were not exported. Mesh does not have position vertex data`)}if(v.hasNormals){const L=v.getNormals(),F=C.getVerticesData(u.e.NormalKind);if(F){const v=new Float32Array(F.length);X=F.length/3,B=0;for(let Q=B;Q<X;++Q){const d=n.j.dk(F,3*Q).normalize();n.j.dk(L,3*Q).normalize().subtractToRef(d,z),v[3*Q]=z.x*y,v[3*Q+1]=z.y,v[3*Q+2]=z.z}const d=Q.createBufferView(v,12),T=Q.createAccessor(d,"VEC3",5126,L.length/3,0);e.push(T),r.attributes.NORMAL=e.length-1}else T.e.Warn(`Morph target normals for mesh ${d.name} were not exported. Mesh does not have normals vertex data`)}if(v.hasTangents){const L=v.getTangents(),F=C.getVerticesData(u.e.TangentKind);if(F){X=F.length/4;const v=new Float32Array(3*X);B=0;for(let Q=B;Q<X;++Q){const d=n.j.dk(F,4*Q);G(d);const T=n.j.dk(L,3*Q);G(T),T.subtractToRef(d,z),v[3*Q]=z.x*y,v[3*Q+1]=z.y,v[3*Q+2]=z.z}const d=Q.createBufferView(v,12),T=Q.createAccessor(d,"VEC3",5126,X,0);e.push(T),r.attributes.TANGENT=e.length-1}else T.e.Warn(`Morph target tangents for mesh ${d.name} were not exported. Mesh does not have tangents vertex data`)}if(v.hasColors){const L=v.getColors(),F=C.getVerticesData(u.e.ColorKind),y=C.getVertexBuffer(u.e.ColorKind);if(F&&y){const v=y.getSize();X=F.length/v;const d=new Float32Array(X*v);B=0;for(let Q=B;Q<X;++Q)if(3===v){const T=n.j.dk(F,Q*v);n.j.dk(L,Q*v).subtractToRef(T,z),d[3*Q]=z.x,d[3*Q+1]=z.y,d[3*Q+2]=z.z}else if(4===v){const T=new n.k,e=n.k.dk(F,Q*v);n.k.dk(L,Q*v).subtractToRef(e,T),d[4*Q]=T.x,d[4*Q+1]=T.y,d[4*Q+2]=T.z,d[4*Q+3]=T.w}else T.e.Warn(`Unsupported number of components for color attribute: ${v}`);const C=Q.createBufferView(d,4*v),u=Q.createAccessor(C,3===v?"VEC3":"VEC4",5126,X,0);e.push(u),r.attributes.COLOR_0=e.length-1}else T.e.Warn(`Morph target colors for mesh ${d.name} were not exported. Mesh does not have colors vertex data`)}return r}var Ov=Q(12027),Jv=Q(11944),Kv=Q(11939),ov=Q(591);class gv{}gv.DEFAULT_COLOR=V.c.White(),gv.DEFAULT_WIDTH_ATTENUATED=1,gv.DEFAULT_WIDTH=.1;var Rv=Q(2017),Mv=Q(12042);class Yv{static ConvertPoints(v,d){if(v.length&&Array.isArray(v)&&"number"===typeof v[0])return[v];if(v.length&&Array.isArray(v[0])&&"number"===typeof v[0][0])return v;if(v.length&&!Array.isArray(v[0])&&v[0]instanceof n.j){const d=[];for(let Q=0;Q<v.length;Q++){const n=v[Q];d.push(n.x,n.y,n.z)}return[d]}if(v.length>0&&Array.isArray(v[0])&&v[0].length>0&&v[0][0]instanceof n.j){const d=[],Q=v;for(const v of Q)d.push(v.flatMap((v=>[v.x,v.y,v.z])));return d}if(v instanceof Float32Array){if(null!==d&&void 0!==d&&d.floatArrayStride){const Q=[],n=3*d.floatArrayStride;for(let d=0;d<v.length;d+=n){const T=new Array(n);for(let Q=0;Q<n;Q++)T[Q]=v[d+Q];Q.push(T)}return Q}return[Array.from(v)]}if(v.length&&v[0]instanceof Float32Array){const d=[];for(const Q of v)d.push(Array.from(Q));return d}return[]}static OmitZeroLengthPredicate(v,d,Q){const n=[];return d.Wd(v).lengthSquared()>0&&n.push([v,d]),Q.Wd(d).lengthSquared()>0&&n.push([d,Q]),v.Wd(Q).lengthSquared()>0&&n.push([Q,v]),0===n.length?null:n}static OmitDuplicatesPredicate(v,d,Q,n){const T=[];return Yv._SearchInPoints(v,d,n)||T.push([v,d]),Yv._SearchInPoints(d,Q,n)||T.push([d,Q]),Yv._SearchInPoints(Q,v,n)||T.push([Q,v]),0===T.length?null:T}static _SearchInPoints(v,d,Q){for(const e of Q)for(let Q=0;Q<e.length;Q++){var n,T,L;if(null!==(n=e[Q])&&void 0!==n&&n.equals(v))if(null!==(T=e[Q+1])&&void 0!==T&&T.equals(d)||null!==(L=e[Q-1])&&void 0!==L&&L.equals(d))return!0}return!1}static MeshesToLines(v,d){const Q=[];for(let T=0;T<v.length;T++){const L=v[T],e=L.getVerticesData(u.e.PositionKind),F=L.ek();if(e&&F)for(let v=0,r=0;v<F.length;v++){const C=3*F[r++],u=3*F[r++],y=3*F[r++],z=new n.j(e[C],e[C+1],e[C+2]),B=new n.j(e[u],e[u+1],e[u+2]),X=new n.j(e[y],e[y+1],e[y+2]);if(d){const n=d(z,B,X,Q,v,C,L,T,e,F);if(n)for(const v of n)Q.push(v)}else Q.push([z,B],[B,X],[X,z])}}return Q}static ToVector3Array(v){if(Array.isArray(v[0])){const d=[],Q=v;for(const v of Q){const Q=[];for(let d=0;d<v.length;d+=3)Q.push(new n.j(v[d],v[d+1],v[d+2]));d.push(Q)}return d}const d=v,Q=[];for(let T=0;T<d.length;T+=3)Q.push(new n.j(d[T],d[T+1],d[T+2]));return Q}static ToNumberArray(v){return v.flatMap((v=>[v.x,v.y,v.z]))}static GetPointsCountInfo(v){const d=new Array(v.length);let Q=0;for(let n=v.length;n--;)d[n]=v[n].length/3,Q+=d[n];return{total:Q,counts:d}}static GetLineLength(v){if(0===v.length)return 0;let d;d="number"===typeof v[0]?Yv.ToVector3Array(v):v;const Q=n.g.fk[0];let T=0;for(let n=0;n<d.length-1;n++){const v=d[n];T+=d[n+1].subtractToRef(v,Q).length()}return T}static GetLineLengthArray(v){const d=new Float32Array(v.length/3);let Q=0;for(let n=0,T=v.length/3-1;n<T;n++){let T=v[3*n+0],L=v[3*n+1],e=v[3*n+2];T-=v[3*n+3],L-=v[3*n+4],e-=v[3*n+5];Q+=Math.sqrt(T*T+L*L+e*e),d[n+1]=Q}return d}static SegmentizeSegmentByCount(v,d,Q){const T=[],L=d.Wd(v),e=n.g.fk[0];e.gk(Q);const F=n.g.fk[1];L.divideToRef(e,F);let r=v.clone();T.push(r);for(let n=0;n<Q;n++)r=r.clone(),T.push(r.addInPlace(F));return T}static SegmentizeLineBySegmentLength(v,d){const Q=v[0]instanceof n.j?Yv.GetLineSegments(v):"number"===typeof v[0]?Yv.GetLineSegments(Yv.ToVector3Array(v)):v,T=[];for(const n of Q)if(n.length>d){const v=Yv.SegmentizeSegmentByCount(n.point1,n.point2,Math.ceil(n.length/d));for(const d of v)T.push(d)}else T.push(n.point1),T.push(n.point2);return T}static SegmentizeLineBySegmentCount(v,d){const Q="number"===typeof v[0]?Yv.ToVector3Array(v):v,n=Yv.GetLineLength(Q)/d;return Yv.SegmentizeLineBySegmentLength(Q,n)}static GetLineSegments(v){const d=[];for(let Q=0;Q<v.length-1;Q++){const n=v[Q],T=v[Q+1],L=T.Wd(n).length();d.push({point1:n,point2:T,length:L})}return d}static GetMinMaxSegmentLength(v){const d=Yv.GetLineSegments(v).sort((v=>v.length));return{min:d[0].length,max:d[d.length-1].length}}static GetPositionOnLineByVisibility(v,d,Q){let T=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const L=d*Q;let e=0,F=0;const r=v.length;for(let n=0;n<r;n++){if(L<=e+v[n].length){F=n;break}e+=v[n].length}const C=(L-e)/v[F].length;return v[F].point2.subtractToRef(v[F].point1,n.g.fk[0]),n.g.fk[1]=n.g.fk[0].multiplyByFloats(C,C,C),T||n.g.fk[1].addInPlace(v[F].point1),n.g.fk[1].clone()}static GetCircleLinePoints(v,d){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,T=arguments.length>3&&void 0!==arguments[3]?arguments[3]:v,L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/d;const e=[];for(let F=0;F<=d;F++)e.push(new n.j(Math.cos(F*L)*v,Math.sin(F*L)*T,Q));return e}static GetBezierLinePoints(v,d,Q,n){return Rv.e.CreateQuadraticBezier(v,d,Q,n).getPoints().flatMap((v=>[v.x,v.y,v.z]))}static GetArrowCap(v,d,Q,n,T){let L=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,e=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[v.clone(),v.add(d.multiplyByFloats(Q,Q,Q))],widths:[n,T,L,e]}}static GetPointsFromText(v,d,Q,n){let T=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,L=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const e=[],F=(0,Mv.e)(v,d,Q,n);for(const r of F){for(const v of r.paths){const d=[],Q=v.getPoints();for(const v of Q)d.push(v.x,v.y,T);e.push(d)}if(L)for(const v of r.holes){const d=[],Q=v.getPoints();for(const v of Q)d.push(v.x,v.y,T);e.push(d)}}return e}static Color3toRGBAUint8(v){const d=new Uint8Array(4*v.length);for(let Q=0,n=0;Q<v.length;Q++)d[n++]=255*v[Q].r,d[n++]=255*v[Q].g,d[n++]=255*v[Q].b,d[n++]=255;return d}static CreateColorsTexture(v,d,Q,n){const T=n.getEngine().getCaps().maxTextureSize??1,L=d.length>T?T:d.length,e=Math.ceil(d.length/T);e>1&&(d=[...d,...Array(L*e-d.length).fill(d[0])]);const F=Yv.Color3toRGBAUint8(d),r=new O.c(F,L,e,X.b.TEXTUREFORMAT_RGBA,n,!1,!0,Q);return r.name=v,r}static PrepareEmptyColorsTexture(v){if(!gv.EmptyColorsTexture){const d=new Uint8Array(4);gv.EmptyColorsTexture=new O.c(d,1,1,X.b.TEXTUREFORMAT_RGBA,v,!1,!1,O.c.NEAREST_NEAREST),gv.EmptyColorsTexture.name="grlEmptyColorsTexture"}return gv.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var v;null===(v=gv.EmptyColorsTexture)||void 0===v||v.dispose(),gv.EmptyColorsTexture=null}static BooleanToNumber(v){return v?1:0}}class Dv extends Kv.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class iv extends Jv.c{isCompatible(v){return!0}constructor(v,d,Q){var T;Q=Q||{color:gv.DEFAULT_COLOR};const L=new Dv;L.GREASED_LINE_HAS_COLOR=!!Q.color&&!Q.useColors,L.GREASED_LINE_SIZE_ATTENUATION=Q.sizeAttenuation??!1,L.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===Q.colorDistributionType,L.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(d??v.va()).useRightHandedSystem,L.GREASED_LINE_CAMERA_FACING=Q.cameraFacing??!0,super(v,iv.GREASED_LINE_MATERIAL_NAME,200,L,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(T=Q)||void 0===T?void 0:T.forceGLSL)||iv.ForceGLSL,this._scene=d??v.va(),this._engine=this._scene.getEngine(),this._cameraFacing=Q.cameraFacing??!0,this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.width=Q.width?Q.width:Q.sizeAttenuation?gv.DEFAULT_WIDTH_ATTENUATED:gv.DEFAULT_WIDTH,this._sizeAttenuation=Q.sizeAttenuation??!1,this.colorMode=Q.colorMode??0,this._color=Q.color??null,this.useColors=Q.useColors??!1,this._colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??O.c.NEAREST_NEAREST,this._colors=Q.za??null,this.dashCount=Q.dashCount??1,this.resolution=Q.resolution??new n.i(this._engine.getRenderWidth(),this._engine.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=Yv.CreateColorsTexture(`${v.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??gv.DEFAULT_COLOR,Yv.PrepareEmptyColorsTexture(this._scene)),this._engine.kk.add((()=>{Yv.DisposeEmptyColorsTexture()}))}getAttributes(v){v.push("grl_offsets"),v.push("grl_widths"),v.push("grl_colorPointers"),v.push("grl_counters"),this._cameraFacing?(v.push("grl_previousAndSide"),v.push("grl_nextAndCounters")):v.push("grl_slopes")}getSamplers(v){v.push("grl_colors")}getActiveTextures(v){this.colorsTexture&&v.push(this.colorsTexture)}getUniforms(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&d.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===v&&d.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:d,vertex:this._cameraFacing&&this._isGLSL(v)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(v)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(v){if(this._cameraFacing){v.tk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||v.tk("viewProjection",this._scene.getTransformMatrix());const d=n.g.Vector4[0];d.x=this._aspect,d.y=this._resolution.x,d.z=this._resolution.y,d.w=this.width,v.updateVector4("grl_aspect_resolution_lineWidth",d)}const d=n.g.Vector4[0];d.x=Yv.BooleanToNumber(this.useDash),d.y=this._dashArray,d.z=this.dashOffset,d.w=this.dashRatio,v.updateVector4("grl_dashOptions",d);const Q=n.g.Vector4[1];Q.x=this.colorMode,Q.y=this.visibility,Q.z=this.colorsTexture?this.colorsTexture.getSize().width:0,Q.w=Yv.BooleanToNumber(this.useColors),v.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",Q),this._color&&v.updateColor3("grl_singleColor",this._color);const T=this.colorsTexture??gv.EmptyColorsTexture;v.setTexture("grl_colors",T),v.updateFloat2("grl_textureSize",(null===T||void 0===T?void 0:T.getSize().width)??1,(null===T||void 0===T?void 0:T.getSize().height)??1)}prepareDefines(v,d,Q){v.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,v.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,v.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,v.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=d.useRightHandedSystem,v.GREASED_LINE_CAMERA_FACING=this._cameraFacing,v.GREASED_LINE_USE_OFFSETS=!!Q.offsets}getClassName(){return iv.GREASED_LINE_MATERIAL_NAME}getCustomCode(v){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(d)?function(v,d){if("vertex"===v){const v={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return d&&(v["!gl_Position\\=viewProjection\\*worldPos;"]="//"),v}return"fragment"===v?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(v,this._cameraFacing):function(v,d){if("vertex"===v){const v={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return d&&(v["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),v}return"fragment"===v?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(v,this._cameraFacing)}dispose(){var v;null===(v=this.colorsTexture)||void 0===v||v.dispose(),super.dispose()}get za(){return this._colors}set za(v){this.setColors(v)}setColors(v){var d;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const T=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var L;if(this._colors=v,null!==v&&0!==v.length){if(!Q||n)if(this.colorsTexture&&T===v.length&&!n){const d=Yv.Color3toRGBAUint8(v);this.colorsTexture.update(d)}else{var e;null===(e=this.colorsTexture)||void 0===e||e.dispose(),this.colorsTexture=Yv.CreateColorsTexture(`${this._material.name}-colors-texture`,v,this.colorsSampling,this._scene)}}else null===(L=this.colorsTexture)||void 0===L||L.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(v){this._dashCount=v,this._dashArray=1/v}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(v){this._sizeAttenuation=v,this.markAllDefinesAsDirty()}get color(){return this._color}set color(v){this.setColor(v)}setColor(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==v||null!==this._color&&null===v?(this._color=v,d||this.markAllDefinesAsDirty()):this._color=v}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(v){this._colorsDistributionType=v,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(v){this._aspect=v.x/v.y,this._resolution=v}serialize(){const v=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(d.za=this._colors),this._color&&(d.color=this._color),v.greasedLineMaterialOptions=d,v}parse(v,d,Q){var n;super.parse(v,d,Q);const T=v.greasedLineMaterialOptions;null===(n=this.colorsTexture)||void 0===n||n.dispose(),T.color&&this.setColor(T.color,!0),T.colorDistributionType&&(this.colorsDistributionType=T.colorDistributionType),T.za&&(this.za=T.za),T.colorsSampling&&(this.colorsSampling=T.colorsSampling),T.colorMode&&(this.colorMode=T.colorMode),T.useColors&&(this.useColors=T.useColors),T.visibility&&(this.visibility=T.visibility),T.useDash&&(this.useDash=T.useDash),T.dashCount&&(this.dashCount=T.dashCount),T.dashRatio&&(this.dashRatio=T.dashRatio),T.dashOffset&&(this.dashOffset=T.dashOffset),T.width&&(this.width=T.width),T.sizeAttenuation&&(this.sizeAttenuation=T.sizeAttenuation),T.resolution&&(this.resolution=T.resolution),this.za?this.colorsTexture=Yv.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,d):Yv.PrepareEmptyColorsTexture(d),this.markAllDefinesAsDirty()}copyTo(v){var d;const Q=v;null===(d=Q.colorsTexture)||void 0===d||d.dispose(),this._colors&&(Q.colorsTexture=Yv.CreateColorsTexture(`${Q._material.name}-colors-texture`,this._colors,Q.colorsSampling,this._scene)),Q.setColor(this.color,!0),Q.colorsDistributionType=this.colorsDistributionType,Q.colorsSampling=this.colorsSampling,Q.colorMode=this.colorMode,Q.useColors=this.useColors,Q.visibility=this.visibility,Q.useDash=this.useDash,Q.dashCount=this.dashCount,Q.dashRatio=this.dashRatio,Q.dashOffset=this.dashOffset,Q.width=this.width,Q.sizeAttenuation=this.sizeAttenuation,Q.resolution=this.resolution,Q.markAllDefinesAsDirty()}_isGLSL(v){return 0===v||this._forceGLSL}}iv.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",iv.ForceGLSL=!1,(0,ov.f)(`BABYLON.${iv.GREASED_LINE_MATERIAL_NAME}`,iv);var Zv=Q(725),jv=Q(484),xv=Q(12033),kv=Q(576);class tv extends xv.b{constructor(v,d,T){const L=d.getEngine(),e=L.isWebGPU&&!(T.forceGLSL||tv.ForceGLSL),F=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];d.useRightHandedSystem&&F.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const r=["position","grl_widths","grl_offsets","grl_colorPointers"];T.cameraFacing?(F.push("GREASED_LINE_CAMERA_FACING"),r.push("grl_previousAndSide","grl_nextAndCounters")):(r.push("grl_slopes"),r.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(e||C.push("world","viewProjection","view","projection"),super(v,d,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:e?["Scene","Mesh"]:void 0,attributes:r,uniforms:C,samplers:e?[]:["grlColors"],defines:F,extraInitializationsAsync:async()=>{e?await Promise.all([Q.e(51).then(Q.bind(Q,14105)),Q.e(59).then(Q.bind(Q,14109))]):await Promise.all([Q.e(54).then(Q.bind(Q,14118)),Q.e(60).then(Q.bind(Q,14124))])},shaderLanguage:e?1:0}),this._color=V.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,T=T||{color:gv.DEFAULT_COLOR},this.visibility=T.visibility??1,this.useDash=T.useDash??!1,this.dashRatio=T.dashRatio??.5,this.dashOffset=T.dashOffset??0,this.dashCount=T.dashCount??1,this.width=T.width?T.width:T.sizeAttenuation&&T.cameraFacing?gv.DEFAULT_WIDTH_ATTENUATED:gv.DEFAULT_WIDTH,this.sizeAttenuation=T.sizeAttenuation??!1,this.color=T.color??V.c.White(),this.useColors=T.useColors??!1,this.colorsDistributionType=T.colorDistributionType??0,this.colorsSampling=T.colorsSampling??O.c.NEAREST_NEAREST,this.colorMode=T.colorMode??0,this._colors=T.za??null,this._cameraFacing=T.cameraFacing??!0,this.resolution=T.resolution??new n.i(L.getRenderWidth(),L.getRenderHeight()),T.colorsTexture?this.colorsTexture=T.colorsTexture:this._colors?this.colorsTexture=Yv.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,d):(this._color=this._color??gv.DEFAULT_COLOR,this.colorsTexture=Yv.PrepareEmptyColorsTexture(d)),e){const v=new kv.d;v.setParameters(),v.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",v)}L.kk.add((()=>{Yv.DisposeEmptyColorsTexture()}))}dispose(){var v;null===(v=this._colorsTexture)||void 0===v||v.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new n.i(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(v){this.setColors(v)}setColors(v){var d;let Q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const T=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var L;if(this._colors=v,null!==v&&0!==v.length){if(!Q||n)if(this._colorsTexture&&T===v.length&&!n){const d=Yv.Color3toRGBAUint8(v);this._colorsTexture.update(d)}else{var e;null===(e=this._colorsTexture)||void 0===e||e.dispose(),this.colorsTexture=Yv.CreateColorsTexture(`${this.name}-colors-texture`,v,this.colorsSampling,this.va())}}else null===(L=this._colorsTexture)||void 0===L||L.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(v){this._colorsTexture=v,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(v){this._width=v,this.setFloat("grlWidth",v)}get useColors(){return this._useColors}set useColors(v){this._useColors=v,this.setFloat("grlUseColors",Yv.BooleanToNumber(v))}get colorsSampling(){return this._colorsSampling}set colorsSampling(v){this._colorsSampling=v}get visibility(){return this._visibility}set visibility(v){this._visibility=v,this.setFloat("grlVisibility",v)}get useDash(){return this._useDash}set useDash(v){this._useDash=v,this.setFloat("grlUseDash",Yv.BooleanToNumber(v))}get dashOffset(){return this._dashOffset}set dashOffset(v){this._dashOffset=v,this.setFloat("grlDashOffset",v)}get dashRatio(){return this._dashRatio}set dashRatio(v){this._dashRatio=v,this.setFloat("grlDashRatio",v)}get dashCount(){return this._dashCount}set dashCount(v){this._dashCount=v,this._dashArray=1/v,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(v){this._sizeAttenuation=v,this.setFloat("grlSizeAttenuation",Yv.BooleanToNumber(v))}get color(){return this._color}set color(v){this.setColor(v)}setColor(v){v=v??gv.DEFAULT_COLOR,this._color=v,this.setColor3("grlColor",v)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(v){this._colorsDistributionType=v,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(v){this._colorMode=v,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(v){this._resolution=v,this.setVector2("grlResolution",v),this.setFloat("grlAspect",v.x/v.y)}serialize(){const v=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(d.za=this._colors),v.greasedLineMaterialOptions=d,v}parse(v,d,Q){var n;const T=v.greasedLineMaterialOptions;null===(n=this._colorsTexture)||void 0===n||n.dispose(),T.color&&(this.color=T.color),T.colorDistributionType&&(this.colorsDistributionType=T.colorDistributionType),T.colorsSampling&&(this.colorsSampling=T.colorsSampling),T.colorMode&&(this.colorMode=T.colorMode),T.useColors&&(this.useColors=T.useColors),T.visibility&&(this.visibility=T.visibility),T.useDash&&(this.useDash=T.useDash),T.dashCount&&(this.dashCount=T.dashCount),T.dashRatio&&(this.dashRatio=T.dashRatio),T.dashOffset&&(this.dashOffset=T.dashOffset),T.width&&(this.width=T.width),T.sizeAttenuation&&(this.sizeAttenuation=T.sizeAttenuation),T.resolution&&(this.resolution=T.resolution),T.za?this.colorsTexture=Yv.CreateColorsTexture(`${this.name}-colors-texture`,T.za,this.colorsSampling,this.va()):this.colorsTexture=Yv.PrepareEmptyColorsTexture(d),this._cameraFacing=T.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var pv,Wv,qv;tv.ForceGLSL=!1,function(v){v[v.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",v[v.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(pv||(pv={})),function(v){v[v.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",v[v.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",v[v.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Wv||(Wv={})),function(v){v[v.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",v[v.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",v[v.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",v[v.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",v[v.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(qv||(qv={}));class bv extends Sv.b{constructor(v,d,Q){super(v,d,null,null,!1,!1),this.name=v,this._options=Q,this._lazy=!1,this._updatable=!1,this._engine=d.getEngine(),this._lazy=Q.lazy??!1,this._updatable=Q.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=Q.colorPointers??[],this._widths=Q.widths??new Array(Q.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(v){let d=0;for(const n of this._points)d+=n.length;const Q=d/3*2-this._widths.length;for(let n=0;n<Q;n++)this._widths.push(v)}updateLazy(){var v,d;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(v=this._options.ribbonOptions)||void 0===v?void 0:v.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(d=this.greasedLineMaterial)||void 0===d||d.updateLazy()}addPoints(v,d){for(const Q of v)this._points.push(Q);this._lazy||this.setPoints(this._points,d)}dispose(v){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(v,d)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(v){this._uvs=v instanceof Float32Array?v:new Float32Array(v),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(v){this.material instanceof tv&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===v||void 0===v?void 0:v.length)>0),this._offsets=v,this._offsetsBuffer?this._offsetsBuffer.update(v):this._createOffsetsBuffer(v)}get widths(){return this._widths}set widths(v){this._widths=v,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(v)}get colorPointers(){return this._colorPointers}set colorPointers(v){this._colorPointers=v,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(v)}get greasedLineMaterial(){var v,d;if(this.material&&this.material instanceof tv)return this.material;const Q=null===(v=this.material)||void 0===v||null===(d=v.pluginManager)||void 0===d?void 0:d.getPlugin(iv.GREASED_LINE_MATERIAL_NAME);return Q||void 0}get points(){const v=[];return jv.d.DeepCopy(this._points,v),v}setPoints(v,d){this._points=Yv.ConvertPoints(v,(null===d||void 0===d?void 0:d.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==d&&void 0!==d&&d.colorPointers||this._updateColorPointers(),this._setPoints(this._points,d)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(v){super.serialize(v),v.type=this.getClassName(),v.lineOptions=this._createLineOptions()}_createVertexBuffers(){let v=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new Zv.b;return d.xa=this._vertexPositions,d.indices=this._indices,d.Aa=this._uvs,v&&(d.ya=[],Zv.b.ComputeNormals(this._vertexPositions,this._indices,d.ya)),d.Ca(this,this._options.updatable),d}_createOffsetsBuffer(v){const d=this._scene.getEngine(),Q=new u.c(d,v,this._updatable,3);this.setVerticesBuffer(Q.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=Q}}class Hv{constructor(v,d){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=v,this.wasAddedByNoopNode=d}getIndicesAccessor(v,d,Q,n,T){var L,e,F,r;return null===(L=this._indicesAccessorMap.get(v))||void 0===L||null===(e=L.get(d))||void 0===e||null===(F=e.get(Q))||void 0===F||null===(r=F.get(n))||void 0===r?void 0:r.get(T)}setIndicesAccessor(v,d,Q,n,T,L){let e=this._indicesAccessorMap.get(v);e||(e=new Map,this._indicesAccessorMap.set(v,e));let F=e.get(d);F||(F=new Map,e.set(d,F));let r=F.get(Q);r||(r=new Map,F.set(Q,r));let C=r.get(n);C||(C=new Map,r.set(n,C)),C.set(T,L)}pushExportedNode(v){this._exportedNodes.has(v)||this._exportedNodes.add(v)}getNodesSet(){return this._exportedNodes}getVertexBufferView(v){return this._vertexBufferViewMap.get(v)}setVertexBufferView(v,d){this._vertexBufferViewMap.set(v,d)}setRemappedBufferView(v,d,Q){this._remappedBufferView.set(v,new Map),this._remappedBufferView.get(v).set(d,Q)}getRemappedBufferView(v,d){var Q;return null===(Q=this._remappedBufferView.get(v))||void 0===Q?void 0:Q.get(d)}getVertexAccessor(v,d,Q){var n,T;return null===(n=this._vertexAccessorMap.get(v))||void 0===n||null===(T=n.get(d))||void 0===T?void 0:T.get(Q)}setVertexAccessor(v,d,Q,n){let T=this._vertexAccessorMap.get(v);T||(T=new Map,this._vertexAccessorMap.set(v,T));let L=T.get(d);L||(L=new Map,T.set(d,L)),L.set(Q,n)}hasVertexColorAlpha(v){return this._vertexMapColorAlpha.get(v)||!1}setHasVertexColorAlpha(v,d){return this._vertexMapColorAlpha.set(v,d)}getMesh(v){return this._meshMap.get(v)}setMesh(v,d){this._meshMap.set(v,d)}bindMorphDataToMesh(v,d){const Q=this._meshMorphTargetMap.get(v)||[];this._meshMorphTargetMap.set(v,Q),-1===Q.indexOf(d)&&Q.push(d)}getMorphTargetsFromMesh(v){return this._meshMorphTargetMap.get(v)}}class sv{_ApplyExtension(v,d,Q,n){if(Q>=d.length)return Promise.resolve(v);const T=n(d[Q],v);return T?T.then((async v=>v?await this._ApplyExtension(v,d,Q+1,n):null)):this._ApplyExtension(v,d,Q+1,n)}_ApplyExtensions(v,d){const Q=[];for(const n of sv._ExtensionNames)Q.push(this._extensions[n]);return this._ApplyExtension(v,Q,0,d)}_extensionsPreExportTextureAsync(v,d,Q){return this._ApplyExtensions(d,((d,n)=>d.preExportTextureAsync&&d.preExportTextureAsync(v,n,Q)))}_extensionsPostExportNodeAsync(v,d,Q,n,T){return this._ApplyExtensions(d,((d,L)=>d.postExportNodeAsync&&d.postExportNodeAsync(v,L,Q,n,T,this._bufferManager)))}_extensionsPostExportMaterialAsync(v,d,Q){return this._ApplyExtensions(d,((d,n)=>d.postExportMaterialAsync&&d.postExportMaterialAsync(v,n,Q)))}_extensionsPostExportMaterialAdditionalTextures(v,d,Q){const n=[];for(const T of sv._ExtensionNames){const L=this._extensions[T];L.postExportMaterialAdditionalTextures&&n.push(...L.postExportMaterialAdditionalTextures(v,d,Q))}return n}_extensionsPostExportTextures(v,d,Q){for(const n of sv._ExtensionNames){const T=this._extensions[n];T.postExportTexture&&T.postExportTexture(v,d,Q)}}_extensionsPostExportMeshPrimitive(v){for(const d of sv._ExtensionNames){const Q=this._extensions[d];Q.postExportMeshPrimitive&&Q.postExportMeshPrimitive(v,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const v of sv._ExtensionNames){const d=this._extensions[v];d.preGenerateBinaryAsync&&await d.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(v){for(const d of sv._ExtensionNames){const Q=this._extensions[d];Q.enabled&&v(Q)}}_extensionsOnExporting(){this._forEachExtensions((v=>{var d,Q,n;v.wasUsed&&((d=this._glTF).extensionsUsed||(d.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(v.name)&&this._glTF.extensionsUsed.push(v.name),v.required&&((Q=this._glTF).extensionsRequired||(Q.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(v.name)&&this._glTF.extensionsRequired.push(v.name)),(n=this._glTF).extensions||(n.extensions={}),v.onExporting&&v.onExporting())}))}_loadExtensions(){for(const v of sv._ExtensionNames){const d=sv._ExtensionFactories[v](this);this._extensions[v]=d}}constructor(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:m.c.LastCreatedScene,d=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${X.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new k(this),this._extensions={},this._bufferManager=new uv,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!v)throw new Error("No scene available to export");this._babylonScene=v,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:v=>{var d;return null===v||void 0===v||null===(d=v.Qk)||void 0===d?void 0:d.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...d},this._loadExtensions()}dispose(){for(const v in this._extensions){this._extensions[v].dispose()}}get options(){return this._options}static RegisterExtension(v,d){sv.UnregisterExtension(v)&&T.e.Warn(`Extension with the name ${v} already exists`),sv._ExtensionFactories[v]=d,sv._ExtensionNames.push(v)}static UnregisterExtension(v){if(!sv._ExtensionFactories[v])return!1;delete sv._ExtensionFactories[v];const d=sv._ExtensionNames.indexOf(v);return-1!==d&&sv._ExtensionNames.splice(d,1),!0}_generateJSON(v,d,Q){const n={byteLength:v};return n.byteLength&&(this._glTF.buffers=[n]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.yd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(n.uri=d+".bin"),Q?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(v){const d=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(d.byteLength,v,!0),n=new Blob([d],{type:"application/octet-stream"}),T=v+".gltf",L=v+".bin",e=new C;if(e.files[T]=Q,e.files[L]=n,this._imageData)for(const F in this._imageData)e.files[F]=new Blob([this._imageData[F].data],{type:this._imageData[F].mimeType});return e}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(v){const d=v%4;return 0===d?d:4-d}async generateGLBAsync(v){this._shouldUseGlb=!0;const d=await this._generateBinaryAsync();this._extensionsOnExporting();const Q=this._generateJSON(d.byteLength),n=v+".glb";let T,L=Q.length;if("undefined"!==typeof TextEncoder){T=(new TextEncoder).encode(Q),L=T.length}const e=this._getPadding(L),F=this._getPadding(d.byteLength),r=28+L+e+d.byteLength+F,u=new rv(r);if(u.writeUInt32(1179937895),u.writeUInt32(2),u.writeUInt32(r),u.writeUInt32(L+e),u.writeUInt32(1313821514),T)u.writeTypedArray(T);else{const v="_".charCodeAt(0);for(let d=0;d<L;++d){const n=Q.charCodeAt(d);n!=Q.codePointAt(d)?u.writeUInt8(v):u.writeUInt8(n)}}for(let C=0;C<e;++C)u.writeUInt8(32);u.writeUInt32(d.byteLength+F),u.writeUInt32(5130562),u.writeTypedArray(d);for(let C=0;C<F;++C)u.writeUInt8(0);const y=new C;return y.files[n]=new Blob([u.getOutputData()],{type:"application/octet-stream"}),y}_setNodeTransformation(v,d,Q){if(d.getPivotPoint().equalsWithEpsilon(b,q.b)||T.e.Warn("Pivot points are not supported in the glTF serializer"),!d.position.equalsWithEpsilon(b,q.b)){const T=n.g.fk[0].p(d.position);Q&&E(T),v.translation=T.mk()}d.md.equalsWithEpsilon(s,q.b)||(v.scale=d.md.mk());const L=d.rotationQuaternion||n.c.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);L.equalsWithEpsilon(H,q.b)||(Q&&N(L),v.rotation=L.normalize().mk())}_setCameraTransformation(v,d,Q){if(!d.position.equalsWithEpsilon(b,q.b)){const T=n.g.fk[0].p(d.position);Q&&E(T),v.translation=T.mk()}const T=d.rotationQuaternion||n.c.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);Q&&N(T),this._babylonScene.useRightHandedSystem||l(T),T.equalsWithEpsilon(H,q.b)||(v.rotation=T.mk())}_listAvailableCameras(){for(const v of this._babylonScene.cameras){const d={type:v.mode===zv.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(v.name&&(d.name=v.name),"perspective"===d.type)d.perspective={aspectRatio:v.getEngine().getAspectRatio(v),yfov:v.fovMode===zv.c.FOVMODE_VERTICAL_FIXED?v.fov:v.fov*v.getEngine().getAspectRatio(v),znear:v.$j,zfar:v.maxZ};else if("orthographic"===d.type){const Q=v.orthoLeft&&v.orthoRight?.5*(v.orthoRight-v.orthoLeft):.5*v.getEngine().getRenderWidth(),n=v.orthoBottom&&v.orthoTop?.5*(v.orthoTop-v.orthoBottom):.5*v.getEngine().getRenderHeight();d.orthographic={xmag:Q,ymag:n,znear:v.$j,zfar:v.maxZ}}this._camerasMap.set(v,d)}}_exportAndAssignCameras(){const v=Array.from(this._camerasMap.values());for(const d of v){const v=this._nodesCameraMap.get(d);if(void 0!==v){this._cameras.push(d);for(const d of v)d.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const v of this._babylonScene.skeletons){if(v.bones.length<=0)continue;const d={joints:[]};this._skinMap.set(v,d)}}_exportAndAssignSkeletons(){for(const v of this._babylonScene.skeletons){if(v.bones.length<=0)continue;const d=this._skinMap.get(v);if(void 0==d)continue;const Q={},n=[];let L=-1;for(let T=0;T<v.bones.length;++T){const d=v.bones[T],n=d.getIndex()??T;-1!==n&&(Q[n]=d,n>L&&(L=n))}for(let v=0;v<=L;++v){const L=Q[v];n.push(L.getAbsoluteInverseBindMatrix());const e=L.getTransformNode();if(null!==e){const v=this._nodeMap.get(e);e&&null!==v&&void 0!==v?d.joints.push(v):T.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else T.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const e=this._nodesSkinMap.get(d);if(d.joints.length>0&&void 0!==e){const v=64*n.length,Q=new Float32Array(v/4);n.forEach(((v,d)=>{Q.set(v.m,16*d)}));const T=this._bufferManager.createBufferView(Q);this._accessors.push(this._bufferManager.createAccessor(T,"MAT4",5126,n.length)),d.inverseBindMatrices=this._accessors.length-1,this._skins.push(d);for(const d of e)d.skin=this._skins.length-1}}}async _exportSceneAsync(){const v={nodes:[]};if(this._babylonScene.metadata){const d=this._options.metadataSelector(this._babylonScene.metadata);d&&(v.extras=d)}const d=new Array,Q=new Array,n=new Array;for(const F of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&ev(F,this._babylonScene.useRightHandedSystem)?n.push(...F.getChildren()):this._babylonScene.useRightHandedSystem?d.push(F):Q.push(F);this._listAvailableCameras(),this._listAvailableSkeletons();const T=new Hv(!0,!1);v.nodes.push(...await this._exportNodesAsync(Q,T));const L=new Hv(!1,!1);v.nodes.push(...await this._exportNodesAsync(d,L));const e=new Hv(!1,!0);v.nodes.push(...await this._exportNodesAsync(n,e)),v.nodes.length&&this._scenes.push(v),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fv._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(v){let d=this._shouldExportNodeMap.get(v);return void 0===d&&(d=this._options.shouldExportNode(v),this._shouldExportNodeMap.set(v,d)),d}async _exportNodesAsync(v,d){const Q=new Array;this._exportBuffers(v,d);for(const n of v)await this._exportNodeAsync(n,Q,d);return Q}_collectBuffers(v,d,Q,n,T){if(this._shouldExportNode(v)&&v instanceof z.d&&v.sk){const L=v.sk.getVertexBuffers();if(L)for(const n in L){if(!c(n))continue;const e=L[n];T.setHasVertexColorAlpha(e,v.hasVertexAlpha);const F=e._buffer,r=d.get(F)||[];d.set(F,r),-1===r.indexOf(e)&&r.push(e);const C=Q.get(e)||[];Q.set(e,C),-1===C.indexOf(v)&&C.push(v)}const e=v.morphTargetManager;if(e)for(let d=0;d<e.numTargets;d++){const Q=e.getTarget(d),T=n.get(Q)||[];n.set(Q,T),-1===T.indexOf(v)&&T.push(v)}}for(const L of v.getChildren())this._collectBuffers(L,d,Q,n,T)}_exportBuffers(v,d){const Q=new Map,n=new Map,T=new Map;for(const F of v)this._collectBuffers(F,Q,n,T,d);const L=Array.from(Q.keys());for(const F of L){const v=F.getData();if(!v)throw new Error("Buffer data is not available");const T=Q.get(F);if(!T)continue;const L=T[0].byteStride;if(T.some((v=>v.byteStride!==L)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const e=Qv(v).slice();for(const d of T){const v=n.get(d),{byteOffset:Q,byteStride:T,componentCount:L,type:F,count:r,normalized:C,kind:y}=I(d,v);switch(y){case u.e.NormalKind:case u.e.TangentKind:(0,t.l)(e,Q,T,L,F,r,C,(v=>{const d=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);if(d>0){const Q=1/d;v[0]*=Q,v[1]*=Q,v[2]*=Q}}));break;case u.e.ColorKind:{const d=v.filter((v=>v.material instanceof mv.e||null==v.material)).length;if(0==d)break;if(d!=v.length){p.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}F==u.e.UNSIGNED_BYTE&&p.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const n=new V.c,y=new V.f,z=this._babylonScene.getEngine().useExactSrgbConversions;(0,t.l)(e,Q,T,L,F,r,C,(v=>{3===v.length?(n.Yd(v,0),n.toLinearSpaceToRef(n,z),n.toArray(v,0)):(y.Yd(v,0),y.toLinearSpaceToRef(y,z),y.toArray(v,0))}))}}}if(d.convertToRightHanded){for(const v of T){const d=n.get(v),{byteOffset:Q,byteStride:T,componentCount:L,type:F,count:r,normalized:C,kind:y}=I(v,d);switch(y){case u.e.PositionKind:case u.e.NormalKind:case u.e.TangentKind:(0,t.l)(e,Q,T,L,F,r,C,(v=>{v[0]=-v[0]}))}}d.convertedToRightHandedBuffers.set(F,e)}const r=this._bufferManager.createBufferView(e,L);d.setVertexBufferView(F,r);const C=new Map;for(const d of T){const v=n.get(d),{kind:Q,totalVertices:T}=I(d,v);switch(Q){case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:if(d.type==u.e.FLOAT){const v=d.getFloatData(T);null!==v&&C.set(d,v)}}}0!==C.size&&p.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const y=Array.from(C.keys());for(const Q of y){const v=C.get(Q);if(!v)continue;const n=v.some((v=>v>=256)),T=new(n?Uint16Array:Uint8Array)(v.length);for(let d=0;d<v.length;d++)T[d]=v[d];const L=this._bufferManager.createBufferView(T,4*(n?2:1));d.setRemappedBufferView(F,Q,L)}}const e=Array.from(T.keys());for(const F of e){const v=T.get(F);if(!v)continue;const Q=Pv(F,v[0],this._bufferManager,this._bufferViews,this._accessors,d.convertToRightHanded);for(const n of v)d.bindMorphDataToMesh(n,Q)}}async _exportNodeAsync(v,d,Q){let n=this._nodeMap.get(v);if(void 0!==n)return void(d.includes(n)||d.push(n));const T=await this._createNodeAsync(v,Q);if(T){n=this._nodes.length,this._nodes.push(T),this._nodeMap.set(v,n),Q.pushExportedNode(v),d.push(n);const L={name:"runtime animations",channels:[],samplers:[]},e=[];this._babylonScene.animationGroups.length||(fv._CreateMorphTargetAnimationFromMorphTargetAnimations(v,L,e,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation),v.animations.length&&fv._CreateNodeAnimationFromNodeAnimations(v,L,e,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.convertToRightHanded,this._options.shouldExportAnimation)),L.channels.length&&L.samplers.length&&this._animations.push(L),e.forEach((v=>{v.channels.length&&v.samplers.length&&this._animations.push(v)}))}const L=T?[]:d;for(const e of v.getChildren())await this._exportNodeAsync(e,L,Q);T&&L.length&&(T.children=L)}async _createNodeAsync(v,d){if(!this._shouldExportNode(v))return null;const Q={};if(v.name&&(Q.name=v.name),v.metadata){const d=this._options.metadataSelector(v.metadata);d&&(Q.extras=d)}if(v instanceof y.d&&(this._setNodeTransformation(Q,v,d.convertToRightHanded),v instanceof z.d)){const T=v instanceof B.b?v.sourceMesh:v;if(T.rk&&T.rk.length>0&&(Q.mesh=await this._exportMeshAsync(T,d)),v.skeleton){const d=this._skinMap.get(v.skeleton);var n;if(void 0!==d)void 0===this._nodesSkinMap.get(d)&&this._nodesSkinMap.set(d,[]),null===(n=this._nodesSkinMap.get(d))||void 0===n||n.push(Q)}}if(v instanceof W.e){const n=this._camerasMap.get(v);if(n){var T;void 0===this._nodesCameraMap.get(n)&&this._nodesCameraMap.set(n,[]),this._setCameraTransformation(Q,v,d.convertToRightHanded);const e=v.parent;if(null!==e&&dv(v,e)){const v=this._nodeMap.get(e);if(void 0!==v){var L;const d=this._nodes[v];return vv(Q,d),null===(L=this._nodesCameraMap.get(n))||void 0===L||L.push(d),null}}null===(T=this._nodesCameraMap.get(n))||void 0===T||T.push(Q)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",Q,v,this._nodeMap,d.convertToRightHanded)?Q:(p.d.Warn(`Not exporting node ${v.name}`),null)}_exportIndices(v,d,Q,n,T,e,F,r,C){let u=v;C.mode=w(e);const y=F!==L.c.CounterClockWiseSideOrientation,z=!r.wasAddedByNoopNode&&y,B=function(v){switch(v){case L.c.TriangleFillMode:case L.c.TriangleStripDrawMode:case L.c.TriangleFanDrawMode:return!0}return!1}(e)&&z;if(B){if(e===L.c.TriangleStripDrawMode||e===L.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=w(e);const F=d?new Uint32Array(n):new Uint16Array(n);if(v)for(let d=0;d+2<n;d+=3)F[d]=v[Q+d]+T,F[d+1]=v[Q+d+2]+T,F[d+2]=v[Q+d+1]+T;else for(let v=0;v+2<n;v+=3)F[v]=v,F[v+1]=v+2,F[v+2]=v+1;u=F}else if(v&&0!==T){const L=d?new Uint32Array(n):new Uint16Array(n);for(let d=0;d<n;d++)L[d]=v[Q+d]+T;u=L}if(u){let L=r.getIndicesAccessor(v,Q,n,T,B);if(void 0===L){const e=function(v,d,Q,n){if(v instanceof Uint16Array||v instanceof Uint32Array)return v;if(v instanceof Int32Array)return new Uint32Array(v.buffer,v.byteOffset,v.length);const T=v.slice(d,d+Q);return n?new Uint32Array(T):new Uint16Array(T)}(u,0,n,d),F=this._bufferManager.createBufferView(e),C=d?5125:5123;this._accessors.push(this._bufferManager.createAccessor(F,"SCALAR",C,n,0)),L=this._accessors.length-1,r.setIndicesAccessor(v,Q,n,T,B,L)}C.indices=L}}_exportVertexBuffer(v,d,Q,n,T,L){const e=v.getKind();if(!c(e))return;if(e.startsWith("uv")&&!this._options.exportUnusedUVs&&(!d||!this._materialNeedsUVsSet.has(d)))return;let F=T.getVertexAccessor(v,Q,n);if(void 0===F){const d=T.convertedToRightHandedBuffers.get(v._buffer)||v._buffer.getData(),L=e===u.e.PositionKind?function(v,d,Q,n){const{byteOffset:T,byteStride:L,type:e,normalized:F}=d,r=d.getSize(),C=new Array(r).fill(1/0),u=new Array(r).fill(-1/0);return(0,t.l)(v,T+Q*L,L,r,e,n*r,F,(v=>{for(let d=0;d<r;d++)C[d]=Math.min(C[d],v[d]),u[d]=Math.max(u[d],v[d])})),{min:C,max:u}}(d,v,Q,n):void 0,r=(e===u.e.MatricesIndicesKind||e===u.e.MatricesIndicesExtraKind)&&v.type===u.e.FLOAT,C=r?u.e.UNSIGNED_BYTE:v.type,y=r?void 0:v.normalized,z=r?T.getRemappedBufferView(v._buffer,v):T.getVertexBufferView(v._buffer),B=v.byteOffset+Q*v.byteStride;this._accessors.push(this._bufferManager.createAccessor(z,function(v,d){if(v==u.e.ColorKind)return d?"VEC4":"VEC3";switch(v){case u.e.PositionKind:case u.e.NormalKind:return"VEC3";case u.e.TangentKind:case u.e.MatricesIndicesKind:case u.e.MatricesIndicesExtraKind:case u.e.MatricesWeightsKind:case u.e.MatricesWeightsExtraKind:return"VEC4";case u.e.UVKind:case u.e.UV2Kind:case u.e.UV3Kind:case u.e.UV4Kind:case u.e.UV5Kind:case u.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${v}`)}(e,T.hasVertexColorAlpha(v)),C,n,B,L,y)),F=this._accessors.length-1,T.setVertexAccessor(v,Q,n,F)}L.attributes[function(v){switch(v){case u.e.PositionKind:return"POSITION";case u.e.NormalKind:return"NORMAL";case u.e.TangentKind:return"TANGENT";case u.e.ColorKind:return"COLOR_0";case u.e.UVKind:return"TEXCOORD_0";case u.e.UV2Kind:return"TEXCOORD_1";case u.e.UV3Kind:return"TEXCOORD_2";case u.e.UV4Kind:return"TEXCOORD_3";case u.e.UV5Kind:return"TEXCOORD_4";case u.e.UV6Kind:return"TEXCOORD_5";case u.e.MatricesIndicesKind:return"JOINTS_0";case u.e.MatricesIndicesExtraKind:return"JOINTS_1";case u.e.MatricesWeightsKind:return"WEIGHTS_0";case u.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${v}`)}(e)]=F}async _exportMaterialAsync(v,d,Q,n){let T=this._materialMap.get(v);if(void 0===T){const n=d&&Object.keys(d).some((v=>v.startsWith("uv")));if((v=v instanceof Bv.e?v.vk[Q.materialIndex]:v)instanceof Xv.d)T=await this._materialExporter.exportPBRMaterialAsync(v,"image/png",n);else{if(!(v instanceof mv.e))return void p.d.Warn(`Unsupported material '${v.name}' with type ${v.getClassName()}`);T=await this._materialExporter.exportStandardMaterialAsync(v,"image/png",n)}this._materialMap.set(v,T)}n.material=T}async _exportMeshAsync(v,d){var Q;let n=d.getMesh(v);if(void 0!==n)return n;const T={primitives:[]};n=this._meshes.length,this._meshes.push(T),d.setMesh(v,n);const e=v.isUnIndexed?null:v.ek(),F=null===(Q=v.sk)||void 0===Q?void 0:Q.getVertexBuffers(),r=d.getMorphTargetsFromMesh(v),C=v instanceof Ov.b,u=v instanceof bv,y=v.rk;if(F&&y&&y.length>0)for(const X of y){const Q={attributes:{}},n=X.Ha()||this._babylonScene.defaultMaterial;if(u){var z,B;const d={name:n.name},T=v,L=V.c.White(),e=(null===(z=T.material)||void 0===z?void 0:z.alpha)??1,F=(null===(B=T.greasedLineMaterial)||void 0===B?void 0:B.color)??L;(!F.equalsWithEpsilon(L,q.b)||e<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...F.mk(),e]}),this._materials.push(d),Q.material=this._materials.length-1}else if(C){const d={name:n.name},T=v;(!T.color.equalsWithEpsilon(V.c.White(),q.b)||T.alpha<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...T.color.mk(),T.alpha]}),this._materials.push(d),Q.material=this._materials.length-1}else await this._exportMaterialAsync(n,F,X,Q);const y=C||u?L.c.LineListDrawMode:v.overrideRenderingFillMode??n.fillMode,m=n._getEffectiveOrientation(v);this._exportIndices(e,e?(0,t.d)(e,X.indexCount,X.indexStart,X.verticesStart):X.verticesCount>65535,e?X.indexStart:X.verticesStart,e?X.indexCount:X.verticesCount,-X.verticesStart,y,m,d,Q);for(const v of Object.values(F))this._exportVertexBuffer(v,n,X.verticesStart,X.verticesCount,d,Q);if(r){Q.targets=[];for(const v of r)Q.targets.push(v.attributes)}T.primitives.push(Q),this._extensionsPostExportMeshPrimitive(Q)}if(r){T.weights=[],T.extras||(T.extras={}),T.extras.targetNames=[];for(const v of r)T.weights.push(v.influence),T.extras.targetNames.push(v.name)}return n}}sv._ExtensionNames=new Array,sv._ExtensionFactories={};class av{static async GLTFAsync(v,d,Q){Q&&Q.exportWithoutWaitingForScene||await v.whenReadyAsync();const n=new sv(v,Q),T=await n.generateGLTFAsync(d.replace(/\.[^/.]+$/,""));return n.dispose(),T}static async GLBAsync(v,d,Q){Q&&Q.exportWithoutWaitingForScene||await v.whenReadyAsync();const n=new sv(v,Q),T=await n.generateGLBAsync(d.replace(/\.[^/.]+$/,""));return n.dispose(),T}}Q(462);const Iv="EXT_mesh_gpu_instancing";class Uv{constructor(v){this.name=Iv,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(v,d,Q,T,L,e){return await new Promise((v=>{if(d&&Q instanceof Sv.b&&Q.hasThinInstances&&this._exporter){this._wasUsed=!0;const v=n.j.Zero(),T=n.c.Identity(),F=n.j.One(),r=Q.thinInstanceGetWorldMatrices(),C=n.g.fk[2],u=n.g.Quaternion[1],y=n.g.fk[3];let z=!1,B=!1,X=!1;const m=new Float32Array(3*Q.Mk),V=new Float32Array(4*Q.Mk),h=new Float32Array(3*Q.Mk);let S=0;for(const d of r)d.decompose(y,u,C),L&&(E(C),N(u)),m.set(C.mk(),3*S),V.set(u.normalize().mk(),4*S),h.set(y.mk(),3*S),z=z||!C.equalsWithEpsilon(v),B=B||!u.equalsWithEpsilon(T),X=X||!y.equalsWithEpsilon(F),S++;const A={attributes:{}};z&&(A.attributes.TRANSLATION=this._buildAccessor(m,"VEC3",Q.Mk,e)),B&&(A.attributes.ROTATION=this._buildAccessor(V,"VEC4",Q.Mk,e)),X&&(A.attributes.SCALE=this._buildAccessor(h,"VEC3",Q.Mk,e)),d.extensions=d.extensions||{},d.extensions[Iv]=A}v(d)}))}_buildAccessor(v,d,Q,n){const T=n.createBufferView(v),L=n.createAccessor(T,d,5126,Q);return this._exporter._accessors.push(L),this._exporter._accessors.length-1}}sv.RegisterExtension(Iv,(v=>new Uv(v)));var cv=Q(12052),wv=Q(12059),Gv=Q(12061),Ev=Q(12070);function Nv(v){return v===Gv.c.PositionKind?"POSITION":v===Gv.c.NormalKind?"NORMAL":v===Gv.c.ColorKind?"COLOR":v.startsWith(Gv.c.UVKind)?"TEX_COORD":"GENERIC"}const lv={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class vd extends cv.d{static get DefaultAvailable(){return(0,cv.h)(vd.DefaultConfiguration)}static get Default(){return vd._Default??(vd._Default=new vd),vd._Default}static ResetDefault(v){vd._Default&&(v||vd._Default.dispose(),vd._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(v,d){return{module:await(d||DracoEncoderModule)({wasmBinary:v})}}_getWorkerContent(){return`${wv.g}(${wv.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:vd.DefaultConfiguration)}async _encodeAsync(v,d,Q){const n=Q?(0,Ev.d)(lv,Q):lv;if(this._workerPoolPromise){const Q=await this._workerPoolPromise;return await new Promise(((T,L)=>{Q.push(((Q,e)=>{const F=v=>{Q.removeEventListener("error",F),Q.removeEventListener("message",r),L(v),e()},r=v=>{"encodeMeshDone"===v.data.id&&(Q.removeEventListener("error",F),Q.removeEventListener("message",r),T(v.data.encodedMeshData),e())};Q.addEventListener("error",F),Q.addEventListener("message",r);const C=[];for(const d of v)C.push(d.data.buffer);d&&C.push(d.buffer),Q.postMessage({id:"encodeMesh",attributes:v,indices:d,options:n},C)}))}))}if(this._modulePromise){const Q=await this._modulePromise;return(0,wv.g)(Q.module,v,d,n)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(v,d){if(0==v.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");v instanceof Sv.b&&v.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===d||void 0===d?void 0:d.method)&&(p.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),d.method="MESH_SEQUENTIAL_ENCODING");const Q=function(v){let d=v.ek(void 0,!0);return!d||d instanceof Uint32Array||d instanceof Uint16Array||(d=((0,t.d)(d,d.length)?Uint32Array:Uint16Array).from(d)),d}(v),n=function(v,d){const Q=[];for(const n of v.getVerticesDataKinds()){if(null!==d&&void 0!==d&&d.includes(n)){if(n===Gv.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const T=v.getVertexBuffer(n),L=T.getSize(),e=(0,t.t)(T.getData(),L,T.type,T.byteOffset,T.byteStride,T.normalized,v.getTotalVertices(),!0);Q.push({kind:n,dracoName:Nv(n),size:L,data:e})}return Q}(v,null===d||void 0===d?void 0:d.excludedAttributes);return await this._encodeAsync(n,Q,d)}}vd.DefaultConfiguration={wasmUrl:`${T.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${T.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${T.e._DefaultCdnUrl}/draco_encoder.js`},vd._Default=null;const dd="KHR_draco_mesh_compression";class Qd{get wasUsed(){return this._wasUsed}constructor(v){this.name=dd,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===v.options.meshCompressionMethod&&vd.DefaultAvailable}dispose(){}postExportMeshPrimitive(v,d,Q){if(!this.enabled)return;if(4!==v.mode&&5!==v.mode)return void p.d.Warn("Cannot compress primitive with mode "+v.mode+".");const n=[],T=[];let L=null;if(void 0!==v.indices){const e=Q[v.indices],F=d.getBufferView(e);L=d.getData(F).slice(),n.push(F),T.push(e)}const e=[];for(const[u,y]of Object.entries(v.attributes)){const v=Q[y],L=d.getBufferView(v),r=U(v.type),C=(0,t.t)(d.getData(L),r,v.componentType,v.byteOffset||0,L.byteStride||(0,t.q)(v.componentType)*r,v.normalized||!1,v.count,!0);e.push({kind:u,dracoName:(F=u,"POSITION"===F?"POSITION":"NORMAL"===F?"NORMAL":F.startsWith("COLOR")?"COLOR":F.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:U(v.type),data:C}),n.push(L),T.push(v)}var F;const r={method:v.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=vd.Default._encodeAsync(e,L,r).then((Q=>{if(!Q)return void p.d.Error("Draco encoding failed for primitive.");const L={bufferView:-1,attributes:Q.attributeIds},e=d.createBufferView(Q.data);d.setBufferView(L,e);for(const v of n)this._bufferViewsUsed.add(v);for(const v of T)this._accessorsUsed.add(v);v.extensions||(v.extensions={}),v.extensions[dd]=L})).catch((v=>{p.d.Error("Draco encoding failed for primitive: "+v)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(v){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((d=>{v.getPropertiesWithBufferView(d).every((v=>this._accessorsUsed.has(v)))&&v.removeBufferView(d)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}sv.RegisterExtension(dd,(v=>new Qd(v)));var nd=Q(12074);const Td="KHR_lights_punctual",Ld={name:"",color:[1,1,1],o:1,range:Number.MAX_VALUE},ed={innerConeAngle:0,outerConeAngle:Math.PI/4},Fd=n.j.Backward();class rd{constructor(v){this.name=Td,this.enabled=!0,this.required=!1,this._exporter=v}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Td]=this._lights}async postExportNodeAsync(v,d,Q,T,L){return await new Promise((e=>{if(!(Q instanceof Av.d))return void e(d);const F=Q.getTypeID()==Av.d.LIGHTTYPEID_POINTLIGHT?"point":Q.getTypeID()==Av.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":Q.getTypeID()==Av.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!F||!(Q instanceof nd.e))return p.d.Warn(`${v}: Light ${Q.name} is not supported in ${Td}`),void e(d);if(Q.falloffType!==Av.d.FALLOFF_GLTF&&p.d.Warn(`${v}: Light falloff for ${Q.name} does not match the ${Td} specification!`),!Q.position.equalsToFloats(0,0,0)){const v=n.g.fk[0].p(Q.position);L&&E(v),d.translation=v.mk()}if("point"!==F){const v=Q.direction.normalizeToRef(n.g.fk[0]);L&&E(v);const T=n.c.FromUnitVectorsToRef(Fd,v,n.g.Quaternion[0]);n.c.IsIdentity(T)||(d.rotation=T.mk())}const r={type:F,name:Q.name,color:Q.cb.mk(),o:Q.o,range:Q.range};if(nv(r,Ld),"spot"===F){const v=Q;r.spot={innerConeAngle:v.innerAngle/2,outerConeAngle:v.angle/2},nv(r.spot,ed)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(r);const C={ab:this._lights.lights.length-1},u=Q.parent;if(u&&dv(Q,u)){const v=T.get(u);if(v){const Q=this._exporter._nodes[v];return vv(d,Q),Q.extensions||(Q.extensions={}),Q.extensions[Td]=C,void e(null)}}d.extensions||(d.extensions={}),d.extensions[Td]=C,e(d)}))}}sv.RegisterExtension(Td,(v=>new rd(v)));var Cd=Q(11930);const ud="KHR_materials_anisotropy";class yd{constructor(v){this.name=ud,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Cd.e&&Q.anisotropy.isEnabled&&!Q.anisotropy.legacy?(Q.anisotropy.texture&&n.push(Q.anisotropy.texture),n):[]}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Cd.e){if(!Q.anisotropy.isEnabled||Q.anisotropy.legacy)return void v(d);this._wasUsed=!0,d.extensions=d.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(Q.anisotropy.texture),T={anisotropyStrength:Q.anisotropy.o,anisotropyRotation:Q.anisotropy.angle,anisotropyTexture:n??void 0};null!==T.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(Q),d.extensions[ud]=T}v(d)}))}}sv.RegisterExtension(ud,(v=>new yd(v)));const zd="KHR_materials_clearcoat";class Bd{constructor(v){this.name=zd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Cd.e&&Q.clearCoat.isEnabled?(Q.clearCoat.texture&&n.push(Q.clearCoat.texture),!Q.clearCoat.useRoughnessFromMainTexture&&Q.clearCoat.textureRoughness&&n.push(Q.clearCoat.textureRoughness),Q.clearCoat.bumpTexture&&n.push(Q.clearCoat.bumpTexture),n):[]}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Cd.e){if(!Q.clearCoat.isEnabled)return void v(d);this._wasUsed=!0,d.extensions=d.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture);let L;L=Q.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(Q.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(Q.clearCoat.textureRoughness),Q.clearCoat.isTintEnabled&&T.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${Q.name}`),Q.clearCoat.remapF0OnInterfaceChange&&T.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${Q.name}`);const e=this._exporter._materialExporter.getTextureInfo(Q.clearCoat.bumpTexture),F={clearcoatFactor:Q.clearCoat.o,clearcoatTexture:n??void 0,clearcoatRoughnessFactor:Q.clearCoat.roughness,clearcoatRoughnessTexture:L??void 0,clearcoatNormalTexture:e??void 0};null===F.clearcoatTexture&&null===F.clearcoatRoughnessTexture&&null===F.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),d.extensions[zd]=F}v(d)}))}}sv.RegisterExtension(zd,(v=>new Bd(v)));const Xd="KHR_materials_diffuse_transmission";function md(v,d){const Q=d.subSurface;let n=null;return Q.translucencyIntensityTexture?n=Q.translucencyIntensityTexture:Q.thicknessTexture&&Q.useMaskFromThicknessTexture&&(n=Q.thicknessTexture),n&&!Q.useGltfStyleTextures?(p.d.Warn(`${v}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${d.name}`,1),null):n}class Vd{constructor(v){this.name=Xd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){const d=md(v,Q);return d&&n.push(d),Q.subSurface.translucencyColorTexture&&n.push(Q.subSurface.translucencyColorTexture),n}return n}_isExtensionEnabled(v){if(v.unlit)return!1;const d=v.subSurface;return!!d.isTranslucencyEnabled&&(!v.unlit&&!d.useAlbedoToTintTranslucency&&d.useGltfStyleTextures&&1===d.volumeIndexOfRefraction&&0===d.minimumThickness&&0===d.maximumThickness)}postExportMaterialAsync(v,d,Q){return new Promise((n=>{if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const n=Q.subSurface,T=md(v,Q),L=0==n.translucencyIntensity?void 0:n.translucencyIntensity,e=this._exporter._materialExporter.getTextureInfo(T)??void 0,F=!n.translucencyColor||n.translucencyColor.equalsFloats(1,1,1)?void 0:n.translucencyColor.mk(),r=this._exporter._materialExporter.getTextureInfo(n.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:L,diffuseTransmissionTexture:e,diffuseTransmissionColorFactor:F,diffuseTransmissionColorTexture:r};(e||r)&&this._exporter._materialNeedsUVsSet.add(Q),d.extensions=d.extensions||{},d.extensions[Xd]=C}n(d)}))}}sv.RegisterExtension(Xd,(v=>new Vd(v)));const hd="KHR_materials_dispersion";class Sd{constructor(){this.name=hd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(v){if(v.unlit)return!1;const d=v.subSurface;return!(!d.isRefractionEnabled&&!d.isDispersionEnabled)}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const v={dispersion:Q.subSurface.dispersion};d.extensions=d.extensions||{},d.extensions[hd]=v}v(d)}))}}sv.RegisterExtension(hd,(()=>new Sd));const Ad="KHR_materials_emissive_strength";class fd{constructor(){this.name=Ad,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(v,d,Q){return await new Promise((v=>{if(!(Q instanceof Xv.d))return v(d);const n=Q.emissiveColor.mk(),T=Math.max(...n);if(T>1){this._wasUsed=!0,d.extensions||(d.extensions={});const v={emissiveStrength:T},n=Q.emissiveColor.scale(1/v.emissiveStrength);d.emissiveFactor=n.mk(),d.extensions[Ad]=v}return v(d)}))}}sv.RegisterExtension(Ad,(v=>new fd));const Pd="KHR_materials_ior";class Od{constructor(){this.name=Pd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(v){return!v.unlit&&(void 0!=v.indexOfRefraction&&1.5!=v.indexOfRefraction)}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const v={ior:Q.indexOfRefraction};d.extensions=d.extensions||{},d.extensions[Pd]=v}v(d)}))}}sv.RegisterExtension(Pd,(v=>new Od));const Jd="KHR_materials_iridescence";class Kd{constructor(v){this.name=Jd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Cd.e&&Q.iridescence.isEnabled?(Q.iridescence.texture&&n.push(Q.iridescence.texture),Q.iridescence.thicknessTexture&&Q.iridescence.thicknessTexture!==Q.iridescence.texture&&n.push(Q.iridescence.thicknessTexture),n):[]}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Cd.e){if(!Q.iridescence.isEnabled)return void v(d);this._wasUsed=!0,d.extensions=d.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(Q.iridescence.texture),T=this._exporter._materialExporter.getTextureInfo(Q.iridescence.thicknessTexture),L={iridescenceFactor:Q.iridescence.o,iridescenceIor:Q.iridescence.indexOfRefraction,iridescenceThicknessMinimum:Q.iridescence.minimumThickness,iridescenceThicknessMaximum:Q.iridescence.maximumThickness,iridescenceTexture:n??void 0,iridescenceThicknessTexture:T??void 0};null===L.iridescenceTexture&&null===L.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(Q),d.extensions[Jd]=L}v(d)}))}}sv.RegisterExtension(Jd,(v=>new Kd(v)));const od="KHR_materials_sheen";class gd{constructor(v){this.name=od,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){return Q instanceof Xv.d&&Q.sheen.isEnabled&&Q.sheen.texture?[Q.sheen.texture]:[]}async postExportMaterialAsync(v,d,Q){return await new Promise((v=>{if(Q instanceof Xv.d){if(!Q.sheen.isEnabled)return void v(d);this._wasUsed=!0,null==d.extensions&&(d.extensions={});const n={sheenColorFactor:Q.sheen.color.mk(),sheenRoughnessFactor:Q.sheen.roughness??0};null===n.sheenColorTexture&&null===n.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(Q),Q.sheen.texture&&(n.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),Q.sheen.textureRoughness&&!Q.sheen.useRoughnessFromMainTexture?n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.textureRoughness)??void 0:Q.sheen.texture&&Q.sheen.useRoughnessFromMainTexture&&(n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(Q.sheen.texture)??void 0),d.extensions[od]=n}v(d)}))}}sv.RegisterExtension(od,(v=>new gd(v)));const Rd="KHR_materials_specular";class Md{constructor(v){this.name=Rd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Xv.d&&this._isExtensionEnabled(Q)?(Q.metallicReflectanceTexture&&n.push(Q.metallicReflectanceTexture),Q.reflectanceTexture&&n.push(Q.reflectanceTexture),n):n}_isExtensionEnabled(v){return!v.unlit&&(void 0!=v.metallicF0Factor&&1!=v.metallicF0Factor||void 0!=v.metallicReflectanceColor&&!v.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(v))}_hasTexturesExtension(v){return null!=v.metallicReflectanceTexture||null!=v.reflectanceTexture}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0,d.extensions=d.extensions||{};const v=this._exporter._materialExporter.getTextureInfo(Q.metallicReflectanceTexture)??void 0,n=this._exporter._materialExporter.getTextureInfo(Q.reflectanceTexture)??void 0,T={specularFactor:1==Q.metallicF0Factor?void 0:Q.metallicF0Factor,specularTexture:v,specularColorFactor:Q.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:Q.metallicReflectanceColor.mk(),specularColorTexture:n};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),d.extensions[Rd]=T}v(d)}))}}sv.RegisterExtension(Rd,(v=>new Md(v)));const Yd="KHR_materials_transmission";class Dd{constructor(v){this.name=Yd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Xv.d&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&n.push(Q.subSurface.thicknessTexture),n):n}_isExtensionEnabled(v){if(v.unlit)return!1;const d=v.subSurface;return d.isRefractionEnabled&&void 0!=d.refractionIntensity&&0!=d.refractionIntensity||this._hasTexturesExtension(v)}_hasTexturesExtension(v){return null!=v.subSurface.refractionIntensityTexture}async postExportMaterialAsync(v,d,Q){if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const n=Q.subSurface,T={transmissionFactor:0===n.refractionIntensity?void 0:n.refractionIntensity};if(this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),n.refractionIntensityTexture)if(n.useGltfStyleTextures){const v=await this._exporter._materialExporter.exportTextureAsync(n.refractionIntensityTexture,"image/png");v&&(T.transmissionTexture=v)}else p.d.Warn(`${v}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);d.extensions||(d.extensions={}),d.extensions[Yd]=T}return d}}sv.RegisterExtension(Yd,(v=>new Dd(v)));const id="KHR_materials_unlit";class Zd{constructor(){this.name=id,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(v,d,Q){return new Promise((v=>{let n=!1;Q instanceof Xv.d?n=Q.unlit:Q instanceof mv.e&&(n=Q.disableLighting),n&&(this._wasUsed=!0,null==d.extensions&&(d.extensions={}),d.extensions[id]={}),v(d)}))}}sv.RegisterExtension(id,(()=>new Zd));const jd="KHR_materials_volume";class xd{constructor(v){this.name=jd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Xv.d&&this._isExtensionEnabled(Q)?(Q.subSurface.thicknessTexture&&n.push(Q.subSurface.thicknessTexture),n):n}_isExtensionEnabled(v){if(v.unlit)return!1;const d=v.subSurface;return!(!d.isRefractionEnabled&&!d.isTranslucencyEnabled)&&(void 0!=d.maximumThickness&&0!=d.maximumThickness||void 0!=d.tintColorAtDistance&&d.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=d.tintColor&&d.tintColor!=V.c.White()||this._hasTexturesExtension(v))}_hasTexturesExtension(v){return null!=v.subSurface.thicknessTexture}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Xv.d&&this._isExtensionEnabled(Q)){this._wasUsed=!0;const v=Q.subSurface,n={thicknessFactor:0==v.maximumThickness?void 0:v.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(v.thicknessTexture)??void 0,attenuationDistance:v.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:v.tintColorAtDistance,attenuationColor:v.tintColor.equalsFloats(1,1,1)?void 0:v.tintColor.mk()};this._hasTexturesExtension(Q)&&this._exporter._materialNeedsUVsSet.add(Q),d.extensions=d.extensions||{},d.extensions[jd]=n}v(d)}))}}sv.RegisterExtension(jd,(v=>new xd(v)));const kd="EXT_materials_diffuse_roughness";class td{constructor(v){this.name=kd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=v}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(v,d,Q){const n=[];return Q instanceof Cd.e&&Q._baseDiffuseRoughness?(Q._baseDiffuseRoughnessTexture&&n.push(Q._baseDiffuseRoughnessTexture),n):[]}postExportMaterialAsync(v,d,Q){return new Promise((v=>{if(Q instanceof Cd.e){if(!Q._baseDiffuseRoughness)return void v(d);this._wasUsed=!0,d.extensions=d.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(Q._baseDiffuseRoughnessTexture),T={diffuseRoughnessFactor:Q._baseDiffuseRoughness,diffuseRoughnessTexture:n??void 0};null!==T.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(Q),d.extensions[kd]=T}v(d)}))}}sv.RegisterExtension(kd,(v=>new td(v)));const pd="KHR_texture_transform";class Wd{constructor(){this.name=pd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(v,d,Q){if(Q.va()||T.e.Warn(`${v}: /*@__KEY__*/"scene" is not defined for Babylon texture ${Q.name}!`),(0!==Q.uAng||0!==Q.vAng)&&(T.e.Warn(`${v}: Texture ${Q.name} with rotation in the u or v axis is not supported in glTF.`),0!==Q.uRotationCenter||0!==Q.vRotationCenter))return;const n={};let L=!1;if(0===Q.uOffset&&0===Q.vOffset||(n.offset=[Q.uOffset,Q.vOffset],L=!0),1===Q.uScale&&1===Q.vScale||(n.scale=[Q.uScale,Q.vScale],L=!0),0!==Q.wAng){if(0!==Q.uRotationCenter||0!==Q.vRotationCenter){if(Q.homogeneousRotationInUVTransform&&Q.uScale!==Q.vScale)return void T.e.Warn(`${v}: Texture ${Q.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${pd}.`);T.e.Warn(`${v}: Texture ${Q.name} with non-origin rotation center will be exported using an adjusted offset with ${pd}.`),n.offset=function(v){const{uOffset:d,vOffset:Q,uRotationCenter:n,vRotationCenter:T,uScale:L,vScale:e,wAng:F}=v,r=Math.cos(F),C=Math.sin(F),u=n*L,y=T*e;return[d+(u*(1-r)+y*C),Q+(y*(1-r)-u*C)]}(Q)}n.rotation=-Q.wAng,L=!0}0!==Q.coordinatesIndex&&(n.texCoord=Q.coordinatesIndex,L=!0),L&&(this._wasUsed=!0,d.extensions||(d.extensions={}),d.extensions[pd]=n)}}sv.RegisterExtension(pd,(()=>new Wd));class qd{static CreateSTL(v){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",T=arguments.length>3&&void 0!==arguments[3]&&arguments[3],L=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],e=arguments.length>5&&void 0!==arguments[5]&&arguments[5],F=arguments.length>6&&void 0!==arguments[6]&&arguments[6],r=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(v,d,Q){const T=[3*v[Q],3*v[Q+1],3*v[Q+2]],L=[new n.j(d[T[0]],d[T[0]+2],d[T[0]+1]),new n.j(d[T[1]],d[T[1]+2],d[T[1]+1]),new n.j(d[T[2]],d[T[2]+2],d[T[2]+1])],e=L[0].Wd(L[1]),F=L[2].Wd(L[1]);return{v:L,n:n.j.Cross(F,e).normalize()}},y=function(v,d,Q,n){return d=z(v,d,Q.x,n),d=z(v,d,Q.y,n),z(v,d,Q.z,n)},z=function(v,d,Q,n){return v.setFloat32(d,Q,n),d+4},X=function(v){if(F){let d=v;v instanceof B.b&&(d=v.sourceMesh);const Q=d.getVerticesData(u.e.PositionKind,!0,!0);if(!Q)return[];const T=n.j.Zero();let L;for(L=0;L<Q.length;L+=3)n.j.TransformCoordinatesFromFloatsToRef(Q[L],Q[L+1],Q[L+2],v.ck(!0),T).toArray(Q,L);return Q}return v.getVerticesData(u.e.PositionKind)||[]};F&&(e=!0);let m="",V=0,h=0;if(T){for(let Q=0;Q<v.length;Q++){const d=v[Q].ek();V+=d?d.length/3:0}const d=new ArrayBuffer(84+50*V);m=new DataView(d),h+=80,m.setUint32(h,V,L),h+=4}else r||(m="solid stlmesh\r\n");for(let n=0;n<v.length;n++){const d=v[n];!T&&r&&(m+="solid "+d.name+"\r\n"),!e&&d instanceof Sv.b&&d.bakeCurrentTransformIntoVertices();const Q=X(d),F=d.ek()||[];for(let v=0;v<F.length;v+=3){const d=C(F,Q,v);T?(h=y(m,h,d.n,L),h=y(m,h,d.v[0],L),h=y(m,h,d.v[1],L),h=y(m,h,d.v[2],L),h+=2):(m+="\tfacet normal "+d.n.x+" "+d.n.y+" "+d.n.z+"\r\n",m+="\t\touter loop\r\n",m+="\t\t\tvertex "+d.v[0].x+" "+d.v[0].y+" "+d.v[0].z+"\r\n",m+="\t\t\tvertex "+d.v[1].x+" "+d.v[1].y+" "+d.v[1].z+"\r\n",m+="\t\t\tvertex "+d.v[2].x+" "+d.v[2].y+" "+d.v[2].z+"\r\n",m+="\t\tendloop\r\n",m+="\tendfacet\r\n")}!T&&r&&(m+="endsolid "+name+"\r\n")}if(T||r||(m+="endsolid stlmesh"),d){const v=document.createElement("a"),d=new Blob([m],{type:"application/octet-stream"});v.href=window.URL.createObjectURL(d),v.download=Q+".stl",v.click()}return m}}function bd(v,d){let Q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const n=[];for(let T=0;T<v.length/Q;T++){const L=v[T*Q],e=v[T*Q+1],F=v[T*Q+2];n.push(`(${L.toPrecision(d.precision)}, ${e.toPrecision(d.precision)}, ${F.toPrecision(d.precision)})`)}return n.join(", ")}function Hd(v,d){const Q=[];for(let n=0;n<v.length/2;n++){const T=v[2*n],L=v[2*n+1];Q.push(`(${T.toPrecision(d.precision)}, ${(1-L).toPrecision(d.precision)})`)}return Q.join(", ")}function sd(v,d){const Q=v.getVerticesData(u.e.PositionKind),n=v.getVerticesData(u.e.NormalKind);if(Q&&n)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(v){var d;const Q=null!==(d=v.ek())&&void 0!==d&&d.length?v.getTotalIndices():v.getTotalVertices();return Array(Q/3).fill(3).join(", ")}(v)}]\n\t\tint[] faceVertexIndices = [${function(v){const d=v.ek(),Q=[];if(null!==d)for(let n=0;n<d.length;n++)Q.push(d[n]);else{const d=v.getTotalVertices();for(let v=0;v<d;v++)Q.push(v)}return Q.join(", ")}(v)}]\n\t\tnormal3f[] normals = [${bd(n,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${bd(Q,d)}]\n        ${function(v,d){let Q="";for(let T=0;T<4;T++){const n=T>0?T:"",L=v.getVerticesData(u.e.UVKind+(n?n+1:""));L&&(Q+=`\n\t\ttexCoord2f[] primvars:st${n} = [${Hd(L,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=v.getVerticesData(u.e.ColorKind);return n&&(Q+=`\n\tcolor3f[] primvars:displayColor = [${bd(n,d,n.length/v.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),Q}(v,d)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ad(v,d){return`\n        def "Geometry"\n        {\n        ${sd(v,d)}\n        }\n        `}function Id(v){let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return d+=v,fflate.strToU8(d)}function Ud(v){const d=v.m;return`( ${cd(d,0)}, ${cd(d,4)}, ${cd(d,8)}, ${cd(d,12)} )`}function cd(v,d){return`(${v[d+0]}, ${v[d+1]}, ${v[d+2]}, ${v[d+3]})`}function wd(v){const d="Object_"+v.uniqueId,Q=function(v){const d=v.getWorldMatrix().clone(),Q=v.va().useRightHandedSystem;if(!Q){let n=v.parent;for(;n;){if(ev(n,Q)){d.multiplyToRef(n.getWorldMatrix().invert(),d);break}n=n.parent}}return d.determinant()<0&&T.e.Warn(`Exporting mesh ${v.name} with negative scale. Result may look incorrect in destination engine.`),d}(v),n=Ud(Q);return`def Xform "${d}" (\n\tprepend references = @./geometries/Geometry_${v.sk.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${n}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${v.material.uniqueId}>\n}\n\n`}function Gd(v){switch(v){case J.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case J.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case J.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ed(v){return`(${v.x}, ${v.y})`}function Nd(v){return`(${v.r}, ${v.g}, ${v.b})`}function ld(v,d,Q,T,L,e){const F=v.getInternalTexture().uniqueId+"_"+v.invertY;L[F]=v;const r=v.coordinatesIndex>0?"st"+v.coordinatesIndex:"st",C=new n.i(v.uScale,v.vScale),u=new n.i(v.uOffset,v.vOffset),y=v.wAng,z=Math.sin(y),B=Math.cos(y);return u.y=1-u.y-C.y,u.x+=z*C.x,u.y+=(1-B)*C.y,`\n    def Shader "PrimvarReader_${Q}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${r}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${Q}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${d.uniqueId}/PrimvarReader_${Q}.outputs:result>\n        float inputs:rotation = ${(y*(180/Math.PI)).toFixed(e.precision)}\n        float2 inputs:scale = ${Ed(C)}\n        float2 inputs:translation = ${Ed(u)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${v.uniqueId}_${Q}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${F}.png@\n        float2 inputs:st.connect = </Materials/Material_${d.uniqueId}/Transform2d_${Q}.outputs:result>\n        ${T?"float4 inputs:scale = "+function(v){return`(${v.r}, ${v.g}, ${v.b}, 1.0)`}(T):""}\n        token inputs:sourceColorSpace = "${v.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Gd(v.wrapU)}"\n        token inputs:wrapT = "${Gd(v.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${d.needAlphaBlending()?"float outputs:a":""}\n    }`}function vQ(v,d,Q){const n="\t\t\t",T=[],L=[],{diffuseMap:e,cb:F,alphaCutOff:r,emissiveMap:C,emissive:u,normalMap:y,roughnessMap:z,roughnessChannel:B,roughness:X,metalnessMap:m,metalnessChannel:h,metalness:S,aoMap:A,aoMapChannel:f,aoMapIntensity:P,alphaMap:O,ior:J,clearCoatEnabled:K,clearCoat:o,clearCoatMap:g,clearCoatRoughness:R,clearCoatRoughnessMap:M}=function(v){const d={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return v instanceof mv.e?{...d,diffuseMap:v.diffuseTexture,cb:v.diffuseColor,alphaCutOff:v.alphaCutOff,emissiveMap:v.emissiveTexture,emissive:v.emissiveColor,roughness:1,alphaMap:v.opacityTexture}:v instanceof Cd.e?{...d,diffuseMap:v._albedoTexture,cb:v._albedoColor,alphaCutOff:v._alphaCutOff,emissiveMap:v._emissiveTexture,emissive:v._emissiveColor,normalMap:v._bumpTexture,roughnessMap:v._metallicTexture,roughnessChannel:v._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:v._roughness??1,metalnessMap:v._metallicTexture,metalnessChannel:v._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:v._metallic??0,aoMap:v._ambientTexture,aoMapChannel:v._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:v._ambientTextureStrength,alphaMap:v._opacityTexture,ior:v.subSurface.indexOfRefraction,clearCoatEnabled:v.clearCoat.isEnabled,clearCoat:v.clearCoat.o,clearCoatMap:v.clearCoat.texture,clearCoatRoughness:v.clearCoat.roughness,clearCoatRoughnessMap:v.clearCoat.useRoughnessFromMainTexture?v.clearCoat.texture:v.clearCoat.textureRoughness}:d}(v);return null!==e?(T.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${v.uniqueId}/Texture_${e.uniqueId}_diffuse.outputs:rgb>`),v.needAlphaBlending()?T.push(`${n}float inputs:opacity.connect = </Materials/Material_${v.uniqueId}/Texture_${e.uniqueId}_diffuse.outputs:a>`):v.needAlphaTesting()&&(T.push(`${n}float inputs:opacity.connect = </Materials/Material_${v.uniqueId}/Texture_${e.uniqueId}_diffuse.outputs:a>`),T.push(`${n}float inputs:opacityThreshold = ${r}`)),L.push(ld(e,v,"diffuse",F,d,Q))):T.push(`${n}color3f inputs:diffuseColor = ${Nd(F||V.c.White())}`),null!==C?(T.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${v.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),L.push(ld(C,v,"emissive",u,d,Q))):u&&u.toLuminance()>0&&T.push(`${n}color3f inputs:emissiveColor = ${Nd(u)}`),null!==y&&(T.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${v.uniqueId}/Texture_${y.uniqueId}_normal.outputs:rgb>`),L.push(ld(y,v,"nk",null,d,Q))),null!==A&&(T.push(`${n}float inputs:occlusion.connect = </Materials/Material_${v.uniqueId}/Texture_${A.uniqueId}_occlusion.outputs:${f}>`),L.push(ld(A,v,"occlusion",new V.c(P,P,P),d,Q))),null!==z?(T.push(`${n}float inputs:roughness.connect = </Materials/Material_${v.uniqueId}/Texture_${z.uniqueId}_roughness.outputs:${B}>`),L.push(ld(z,v,"roughness",new V.c(X,X,X),d,Q))):T.push(`${n}float inputs:roughness = ${X}`),null!==m?(T.push(`${n}float inputs:metallic.connect = </Materials/Material_${v.uniqueId}/Texture_${m.uniqueId}_metallic.outputs:${h}>`),L.push(ld(m,v,"metallic",new V.c(S,S,S),d,Q))):T.push(`${n}float inputs:metallic = ${S}`),null!==O?(T.push(`${n}float inputs:opacity.connect = </Materials/Material_${v.uniqueId}/Texture_${O.uniqueId}_opacity.outputs:r>`),T.push(`${n}float inputs:opacityThreshold = 0.0001`),L.push(ld(O,v,"opacity",null,d,Q))):T.push(`${n}float inputs:opacity = ${v.alpha}`),K&&(null!==g?(T.push(`${n}float inputs:clearcoat.connect = </Materials/Material_${v.uniqueId}/Texture_${g.uniqueId}_clearcoat.outputs:r>`),L.push(ld(g,v,"clearcoat",new V.c(o,o,o),d,Q))):T.push(`${n}float inputs:clearcoat = ${o}`),null!==M?(T.push(`${n}float inputs:clearcoatRoughness.connect = </Materials/Material_${v.uniqueId}/Texture_${M.uniqueId}_clearcoatRoughness.outputs:g>`),L.push(ld(M,v,"clearcoatRoughness",new V.c(R,R,R),d,Q))):T.push(`${n}float inputs:clearcoatRoughness = ${R}`)),T.push(`${n}float inputs:ior = ${J}`),`\n\tdef Material "Material_${v.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${T.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${v.uniqueId}/PreviewSurface.outputs:surface>\n\n${L.join("\n")}\n\n\t}\n`}async function dQ(v,d,Q){const L={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...d};"undefined"===typeof fflate&&await T.e.LoadScriptAsync(L.fflateUrl);const e={};e[L.modelFileName]=null;let F='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';F+=function(v){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===v.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${v.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${v.planeAnchoringAlignment}"`:""}\n            `}(L);const r={};for(const n of v.meshes){if(0===n.getTotalVertices())continue;const v=n,d=v.sk,C=v.material;if(!C||!d||Q&&!Q(v))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const Q="geometries/Geometry_"+d.uniqueId+".usda";if(!(Q in e)){const v=ad(d,L);e[Q]=Id(v)}C.uniqueId in r||(r[C.uniqueId]=C),F+=wd(v)}else T.e.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}v.activeCamera&&L.exportCamera&&(F+=function(v,d){const Q="Camera_"+v.uniqueId,T=Ud(n.b.RotationY(Math.PI).multiply(v.getWorldMatrix()));if(v.mode===J.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${T}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${v.$j.toPrecision(d.precision)}, ${v.maxZ.toPrecision(d.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(v.orthoLeft||1)+Math.abs(v.orthoRight||1))).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(v.orthoTop||1)+Math.abs(v.orthoBottom||1))).toPrecision(d.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const n=v.getEngine().getAspectRatio(v),L=d.cameraSensorWidth||35;return`def Camera "${Q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${T}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${v.$j.toPrecision(d.precision)}, ${v.maxZ.toPrecision(d.precision)})\n\t\t\tfloat focalLength = ${(L/(2*Math.tan(.5*v.fov))).toPrecision(d.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(L*n).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(L/n).toPrecision(d.precision)}            \n\t\t}\n\t\n\t`}}(v.activeCamera,L)),F+="\n            }\n        }\n    }";const C={};F+=function(v,d,Q){const n=[];for(const T in v){const L=v[T];n.push(vQ(L,d,Q))}return`\n    def "Materials"\n{\n${n.join("")}\n}\n\n`}(r,C,L),e[L.modelFileName]=fflate.strToU8(F);for(const n in C){const v=C[n],d=v.getSize(),Q=await v.readPixels();if(!Q)throw new Error("Texture data is not available");const T=await K.DumpTools.DumpDataAsync(d.width,d.height,Q,"image/png",void 0,!1,!0);e[`textures/Texture_${n}.png`]=new Uint8Array(T).slice()}let u=0;for(const n in e){const v=e[n];if(!v)continue;u+=34+n.length;const d=63&u;if(4!==d){const Q=new Uint8Array(64-d);e[n]=[v,{extra:{12345:Q}}]}u=v.length}return fflate.zipSync(e,{level:0})}}}]);