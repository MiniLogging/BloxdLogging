"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{12229:(R,x,H)=>{H.r(x),H.d(x,{EXT_materials_diffuse_roughness:()=>Wx,EXT_mesh_gpu_instancing:()=>jR,GLTF2Export:()=>rR,GLTFData:()=>J,KHR_draco_mesh_compression:()=>Hx,KHR_lights_punctual:()=>Ux,KHR_materials_anisotropy:()=>nx,KHR_materials_clearcoat:()=>Ix,KHR_materials_diffuse_transmission:()=>Sx,KHR_materials_dispersion:()=>bx,KHR_materials_emissive_strength:()=>Fx,KHR_materials_ior:()=>Px,KHR_materials_iridescence:()=>Xx,KHR_materials_sheen:()=>Bx,KHR_materials_specular:()=>Zx,KHR_materials_transmission:()=>sx,KHR_materials_unlit:()=>wx,KHR_materials_volume:()=>fx,KHR_texture_transform:()=>Qx,OBJExport:()=>A,STLExport:()=>Gx,USDZExportAsync:()=>xH,_ConvertToGLTFPBRMetallicRoughness:()=>E,_SolveMetallic:()=>s,__IGLTFExporterExtension:()=>D});var k=H(661),c=H(485),t=H(837);class A{static OBJ(R,x,H,A){const D=[];let U=1,J=1;x&&(H||(H="mat"),D.push("mtllib "+H+".mtl"));for(let V=0;V<R.length;V++){const H=R[V],n=H.name||`mesh${V}}`;D.push(`o ${n}`);let g=null;if(A){const R=H.Fi(!0);g=new k.e,R.invertToRef(g),H.bakeTransformIntoVertices(R)}if(x){const R=H.material;R&&D.push("usemtl "+R.id)}const I=H.Ci;if(!I){c.e.Warn("No geometry is present on the mesh");continue}const i=I.getVerticesData("position"),q=I.getVerticesData("dj"),S=I.getVerticesData("uv"),L=I.Gi();let b=0,C=0;if(!i||!L){c.e.Warn("There are no position vertices or indices on the mesh!");continue}const F=R[0].va().useRightHandedSystem?1:-1;for(let R=0;R<i.length;R+=3)D.push("v "+i[R]*F+" "+i[R+1]+" "+i[R+2]),b++;if(null!=q)for(let R=0;R<q.length;R+=3)D.push("vn "+q[R]*F+" "+q[R+1]+" "+q[R+2]);if(null!=S)for(let R=0;R<S.length;R+=2)D.push("vt "+S[R]+" "+S[R+1]),C++;const d=["","",""],P=(H.material||H.va().defaultMaterial)._getEffectiveOrientation(H),[a,X]=P===t.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let R=0;R<L.length;R+=3){const x=[String(L[R]+U),String(L[R+a]+U),String(L[R+X]+U)],H=[String(L[R]+J),String(L[R+a]+J),String(L[R+X]+J)],k=x,c=null!=S?H:d,t=null!=q?x:d;D.push("f "+k[0]+"/"+c[0]+"/"+t[0]+" "+k[1]+"/"+c[1]+"/"+t[1]+" "+k[2]+"/"+c[2]+"/"+t[2])}A&&g&&H.bakeTransformIntoVertices(g),U+=b,J+=C}return D.join("\n")}static MTL(R){const x=[],H=R.material;x.push("newmtl mat1"),x.push("  Ns "+H.specularPower.toFixed(4)),x.push("  Ni 1.5000"),x.push("  d "+H.alpha.toFixed(4)),x.push("  Tr 0.0000"),x.push("  Tf 1.0000 1.0000 1.0000"),x.push("  illum 2"),x.push("  Ka "+H.ambientColor.r.toFixed(4)+" "+H.ambientColor.g.toFixed(4)+" "+H.ambientColor.b.toFixed(4)),x.push("  Kd "+H.diffuseColor.r.toFixed(4)+" "+H.diffuseColor.g.toFixed(4)+" "+H.diffuseColor.b.toFixed(4)),x.push("  Ks "+H.specularColor.r.toFixed(4)+" "+H.specularColor.g.toFixed(4)+" "+H.specularColor.b.toFixed(4)),x.push("  Ke "+H.emissiveColor.r.toFixed(4)+" "+H.emissiveColor.g.toFixed(4)+" "+H.emissiveColor.b.toFixed(4));H.ambientTexture&&x.push("  map_Ka "+H.ambientTexture.name),H.diffuseTexture&&x.push("  map_Kd "+H.diffuseTexture.name),H.specularTexture&&x.push("  map_Ks "+H.specularTexture.name),H.bumpTexture&&x.push("  map_bump -imfchan z "+H.bumpTexture.name),H.opacityTexture&&x.push("  map_d "+H.opacityTexture.name);return x.join("\n")}}var D=0,U=H(517);class J{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const R in this.files){const x=this.files[R],H=new Blob([x],{type:(0,U.j)(R)});c.e.Download(H,R)}}}var V=H(724),n=H(819),g=H(813),I=H(12238),i=H(2349),q=H(513),S=H(695),L=H(681);const b=L.HighestCommonFactor,C={...L,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:b};var F=H(2306),d=H(2311),P=H(12246),a=H(12251),X=H(2498);const M=1e-6,B=new S.c(.04,.04,.04),o=1024,Z=S.c.White(),y=S.c.Black();function s(R,x,H){if(x<B.r)return 0;const k=B.r,c=R*H/(1-B.r)+x-2*B.r,t=c*c-4*k*(B.r-x);return C.Clamp((-c+Math.sqrt(t))/(2*k),0,1)}function E(R){const x=R.diffuseColor.toLinearSpace(R.va().getEngine().useExactSrgbConversions).scale(.5),H=R.alpha,c=function(R){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new k.k(0,1),H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new k.k(0,.1),c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new k.k(0,.1),t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new k.k(1300,.1);return function(R,x,H,k,c){return(1-R)*(1-R)*(1-R)*x+3*(1-R)*(1-R)*R*H+3*(1-R)*R*R*k+R*R*R*c}(Math.pow(R/t.x,.333333),x.y,H.y,c.y,t.y)}(C.Clamp(R.specularPower,0,o));return{baseColorFactor:[x.r,x.g,x.b,H],metallicFactor:0,roughnessFactor:c}}function w(R,x){x.needAlphaBlending()?R.alphaMode="BLEND":x.needAlphaTesting()&&(R.alphaMode="MASK",R.alphaCutoff=x.alphaCutOff)}function h(R,x,H){const k=new Uint8Array(R*x*4);for(let c=0;c<k.length;c+=4)k[c]=k[c+1]=k[c+2]=k[c+3]=255;return P.b.CreateRGBATexture(k,R,x,H)}function f(R){if(R instanceof Uint8Array){const x=R.length,H=new Float32Array(R.length);for(let k=0;k<x;++k)H[k]=R[k]/255;return H}if(R instanceof Float32Array)return R;throw new Error("Unsupported pixel format!")}class N{constructor(R){this._exporter=R,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(R){return R?this._textureMap.get(R)??null:null}async exportStandardMaterialAsync(R,x,H){const k=E(R),t={name:R.name};if(null==R.Ki||R.Ki||(R.twoSidedLighting||c.e.Warn(R.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),t.doubleSided=!0),H){const H=[],c=R.diffuseTexture;c&&H.push(this.exportTextureAsync(c,x).then((R=>{R&&(k.baseColorTexture=R)})));const A=R.bumpTexture;A&&H.push(this.exportTextureAsync(A,x).then((R=>{R&&(t.normalTexture=R,1!==A.level&&(t.normalTexture.scale=A.level))})));const D=R.emissiveTexture;D&&(t.emissiveFactor=[1,1,1],H.push(this.exportTextureAsync(D,x).then((R=>{R&&(t.emissiveTexture=R)}))));const U=R.ambientTexture;U&&H.push(this.exportTextureAsync(U,x).then((R=>{if(R){const x={index:R.index};t.occlusionTexture=x}}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(H))}(R.alpha<1||R.opacityTexture)&&(R.alphaMode===a.d.ALPHA_COMBINE?t.alphaMode="BLEND":c.e.Warn(R.name+": glTF 2.0 does not support alpha mode: "+R.alphaMode.toString())),R.emissiveColor&&!R.emissiveColor.equalsWithEpsilon(y,M)&&(t.emissiveFactor=R.emissiveColor.Li()),t.pbrMetallicRoughness=k,w(t,R),await this._finishMaterialAsync(t,R,x);const A=this._exporter._materials;return A.push(t),A.length-1}async _finishMaterialAsync(R,x,H){const k=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",R,x),c=[];for(const t of k)c.push(this.exportTextureAsync(t,H));await Promise.all(c),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",R,x)}async _getImageDataAsync(R,x,k,c){const t=a.d.TEXTURETYPE_UNSIGNED_BYTE,A=this._exporter._babylonScene,D=A.getEngine(),U=D.createRawTexture(R,x,k,a.d.TEXTUREFORMAT_RGBA,!1,!0,d.d.NEAREST_SAMPLINGMODE,null,t);D.isWebGPU?await H.e(45).then(H.bind(H,13796)):await H.e(46).then(H.bind(H,13804)),await F.j.ApplyPostProcess("pass",U,A,t,a.d.TEXTURE_NEAREST_SAMPLINGMODE,a.d.TEXTUREFORMAT_RGBA);const J=await D._readTexturePixels(U,x,k);return await X.DumpTools.DumpDataAsync(x,k,J,c,void 0,!0,!0)}_resizeTexturesToSameDimensions(R,x,H){const k=R?R.getSize():{width:0,height:0},c=x?x.getSize():{width:0,height:0};let t,A;return k.width<c.width?(t=R&&R instanceof d.d?F.j.CreateResizedCopy(R,c.width,c.height,!0):h(c.width,c.height,H),A=x):k.width>c.width?(A=x&&x instanceof d.d?F.j.CreateResizedCopy(x,k.width,k.height,!0):h(k.width,k.height,H),t=R):(t=R,A=x),{texture1:t,texture2:A}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(R,x,H,k){const c=new Array;if(!R&&!x)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const t=R?R.va():x?x.va():null;if(t){var A;const D=this._resizeTexturesToSameDimensions(R,x,t),U=null===(A=D.texture1)||void 0===A?void 0:A.getSize();let J,V;const n=U.width,g=U.height,I=await D.texture1.readPixels(),i=await D.texture2.readPixels();if(!I)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(J=f(I),!i)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");V=f(i);const q=V.byteLength,L=new Uint8Array(q),b=new Uint8Array(q),C=4,F=y;let d=0,P=0;for(let R=0;R<g;++R)for(let x=0;x<n;++x){const k=(n*R+x)*C,c={diffuseColor:new S.c(J[k],J[k+1],J[k+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(H.diffuseColor),specularColor:new S.c(V[k],V[k+1],V[k+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(H.specularColor),glossiness:V[k+3]*H.glossiness},A=this._convertSpecularGlossinessToMetallicRoughness(c);F.r=Math.max(F.r,A.baseColor.r),F.g=Math.max(F.g,A.baseColor.g),F.b=Math.max(F.b,A.baseColor.b),d=Math.max(d,A.metallic),P=Math.max(P,A.roughness),b[k]=255*A.baseColor.r,b[k+1]=255*A.baseColor.g,b[k+2]=255*A.baseColor.b,b[k+3]=D.texture1.Qj?255*J[k+3]:255,L[k]=0,L[k+1]=255*A.roughness,L[k+2]=255*A.metallic,L[k+3]=255}const a={baseColor:F,metallic:d,roughness:P};let X=!1,B=!1;for(let R=0;R<g;++R)for(let x=0;x<n;++x){const H=(n*R+x)*C;b[H]/=a.baseColor.r>M?a.baseColor.r:1,b[H+1]/=a.baseColor.g>M?a.baseColor.g:1,b[H+2]/=a.baseColor.b>M?a.baseColor.b:1;const k=S.c.FromInts(b[H],b[H+1],b[H+2]).toGammaSpace(t.getEngine().useExactSrgbConversions);b[H]=255*k.r,b[H+1]=255*k.g,b[H+2]=255*k.b,k.equalsWithEpsilon(Z,M)||(B=!0),L[H+1]/=a.roughness>M?a.roughness:1,L[H+2]/=a.metallic>M?a.metallic:1;S.c.FromInts(255,L[H+1],L[H+2]).equalsWithEpsilon(Z,M)||(X=!0)}return X&&c.push(this._getImageDataAsync(L,n,g,k).then((R=>{a.metallicRoughnessTextureData=R}))),B&&c.push(this._getImageDataAsync(b,n,g,k).then((R=>{a.baseColorTextureData=R}))),await Promise.all(c).then((()=>a))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(R){const x=this._getPerceivedBrightness(R.diffuseColor),H=this._getPerceivedBrightness(R.specularColor),k=1-this._getMaxComponent(R.specularColor),c=s(x,H,k),t=R.diffuseColor.scale(k/(1-B.r)/Math.max(1-c)),A=R.specularColor.Pg(B.scale(1-c)).scale(1/Math.max(c));let D=S.c.Lerp(t,A,c*c);D=D.clampToRef(0,1,D);return{baseColor:D,metallic:c,roughness:1-R.glossiness}}_getPerceivedBrightness(R){return R?Math.sqrt(.299*R.r*R.r+.587*R.g*R.g+.114*R.b*R.b):0}_getMaxComponent(R){return R?Math.max(R.r,Math.max(R.g,R.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(R,x,H,k){const c=[],t={baseColor:R._albedoColor,metallic:R._metallic,roughness:R._roughness};if(k){R._albedoTexture&&c.push(this.exportTextureAsync(R._albedoTexture,x).then((R=>{R&&(H.baseColorTexture=R)})));const k=R._metallicTexture;k&&c.push(this.exportTextureAsync(k,x).then((R=>{R&&(H.metallicRoughnessTexture=R)})))}return c.length>0&&(this._exporter._materialNeedsUVsSet.add(R),await Promise.all(c)),t}_getTextureSampler(R){const x={};if(!R||!(R instanceof d.d))return x;const H=this._getGLTFTextureWrapMode(R.wrapU);10497!==H&&(x.wrapS=H);const k=this._getGLTFTextureWrapMode(R.wrapV);switch(10497!==k&&(x.wrapT=k),R.samplingMode){case d.d.LINEAR_LINEAR:x.magFilter=9729,x.minFilter=9729;break;case d.d.LINEAR_NEAREST:x.magFilter=9729,x.minFilter=9728;break;case d.d.NEAREST_LINEAR:x.magFilter=9728,x.minFilter=9729;break;case d.d.NEAREST_LINEAR_MIPLINEAR:x.magFilter=9728,x.minFilter=9987;break;case d.d.NEAREST_NEAREST:x.magFilter=9728,x.minFilter=9728;break;case d.d.NEAREST_LINEAR_MIPNEAREST:x.magFilter=9728,x.minFilter=9985;break;case d.d.LINEAR_NEAREST_MIPNEAREST:x.magFilter=9729,x.minFilter=9984;break;case d.d.LINEAR_NEAREST_MIPLINEAR:x.magFilter=9729,x.minFilter=9986;break;case d.d.NEAREST_NEAREST_MIPLINEAR:x.magFilter=9728,x.minFilter=9986;break;case d.d.LINEAR_LINEAR_MIPLINEAR:x.magFilter=9729,x.minFilter=9987;break;case d.d.LINEAR_LINEAR_MIPNEAREST:x.magFilter=9729,x.minFilter=9985;break;case d.d.NEAREST_NEAREST_MIPNEAREST:x.magFilter=9728,x.minFilter=9984}return x}_getGLTFTextureWrapMode(R){switch(R){case d.d.WRAP_ADDRESSMODE:return 10497;case d.d.CLAMP_ADDRESSMODE:return 33071;case d.d.MIRROR_ADDRESSMODE:return 33648;default:return c.e.Error(`Unsupported Texture Wrap Mode ${R}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(R,x,H,k){const c={diffuseColor:R._albedoColor,specularColor:R._reflectivityColor,glossiness:R._microSurface},t=R._albedoTexture,A=R._reflectivityTexture,D=R._useMicroSurfaceFromReflectivityMapAlpha;if(A&&!D)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((t||A)&&k){this._exporter._materialNeedsUVsSet.add(R);const k=this._exportTextureSampler(t||A),D=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,A,c,x),U=this._exporter._textures;if(D.baseColorTextureData){const R=this._exportImage(`baseColor${U.length}`,x,D.baseColorTextureData);H.baseColorTexture=this._exportTextureInfo(R,k,null===t||void 0===t?void 0:t.coordinatesIndex)}if(D.metallicRoughnessTextureData){const R=this._exportImage(`metallicRoughness${U.length}`,x,D.metallicRoughnessTextureData);H.metallicRoughnessTexture=this._exportTextureInfo(R,k,null===A||void 0===A?void 0:A.coordinatesIndex)}return D}return this._convertSpecularGlossinessToMetallicRoughness(c)}async exportPBRMaterialAsync(R,x,H){const k={},c={name:R.name},t=R.isMetallicWorkflow();if(t){const x=R._albedoColor,H=R.alpha;x&&(k.baseColorFactor=[x.r,x.g,x.b,H])}const A=t?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(R,x,k,H):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(R,x,k,H);await this._setMetallicRoughnessPbrMaterialAsync(A,R,c,k,x,H),await this._finishMaterialAsync(c,R,x);const D=this._exporter._materials;return D.push(c),D.length-1}async _setMetallicRoughnessPbrMaterialAsync(R,x,H,k,t,A){if(w(H,x),R.baseColor.equalsWithEpsilon(Z,M)&&C.WithinEpsilon(x.alpha,1,M)||(k.baseColorFactor=[R.baseColor.r,R.baseColor.g,R.baseColor.b,x.alpha]),null!=R.metallic&&1!==R.metallic&&(k.metallicFactor=R.metallic),null!=R.roughness&&1!==R.roughness&&(k.roughnessFactor=R.roughness),null==x.Ki||x.Ki||(x._twoSidedLighting||c.e.Warn(x.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),H.doubleSided=!0),A){const R=[],k=x._bumpTexture;k&&R.push(this.exportTextureAsync(k,t).then((R=>{R&&(H.normalTexture=R,1!==k.level&&(H.normalTexture.scale=k.level))})));const c=x._ambientTexture;c&&R.push(this.exportTextureAsync(c,t).then((R=>{if(R){const k={index:R.index,texCoord:R.texCoord,extensions:R.extensions};H.occlusionTexture=k;const c=x._ambientTextureStrength;c&&(k.strength=c)}})));const A=x._emissiveTexture;A&&R.push(this.exportTextureAsync(A,t).then((R=>{R&&(H.emissiveTexture=R)}))),R.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(R))}const D=x._emissiveColor;D.equalsWithEpsilon(y,M)||(H.emissiveFactor=D.Li()),H.pbrMetallicRoughness=k}_getPixelsFromTextureAsync(R){return function(R){switch(R){case a.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case a.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case a.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case a.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case a.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case a.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case a.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case a.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case a.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case a.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case a.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case a.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case a.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(R.textureFormat)?(0,F.g)(R,R._texture.width,R._texture.height):(R.textureType,a.d.TEXTURETYPE_UNSIGNED_BYTE,R.readPixels())}async exportTextureAsync(R,x){const H=this._exporter._extensionsPreExportTextureAsync("exporter",R,x);return H?await H.then((async H=>H?await this._exportTextureInfoAsync(H,x):await this._exportTextureInfoAsync(R,x))):await this._exportTextureInfoAsync(R,x)}async _exportTextureInfoAsync(R,x){let H=this._textureMap.get(R);if(!H){const k=await this._getPixelsFromTextureAsync(R);if(!k)return null;const t=this._exportTextureSampler(R),A=R.mimeType;if(A)switch(A){case"image/jpeg":case"image/png":case"image/webp":x=A;break;default:c.e.Warn(`Unsupported media type: ${A}. Exporting texture as PNG.`)}const D=this._internalTextureToImage,U=R.getInternalTexture().uniqueId;D[U]||(D[U]={});let J=D[U][x];if(void 0===J){const H=R.getSize();J=(async()=>{const c=await this._getImageDataAsync(k,H.width,H.height,x);return this._exportImage(R.name,x,c)})(),D[U][x]=J}H=this._exportTextureInfo(await J,t,R.coordinatesIndex),this._textureMap.set(R,H),this._exporter._extensionsPostExportTextures("exporter",H,R)}return H}_exportImage(R,x,H){const k=this._exporter._images;let t;if(this._exporter._shouldUseGlb){t={name:R,mimeType:x,bufferView:void 0};const k=this._exporter._bufferManager.createBufferView(new Uint8Array(H));this._exporter._bufferManager.setBufferView(t,k)}else{const A=R.replace(/\.\/|\/|\.\\|\\/g,"_"),D=function(R){switch(R){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(x);let U=A+D;k.some((R=>R.uri===U))&&(U=`${A}_${c.e.RandomId()}${D}`),t={name:R,uri:U},this._exporter._imageData[U]={data:H,mimeType:x}}return k.push(t),k.length-1}_exportTextureInfo(R,x,H){const k=this._exporter._textures;let c=k.findIndex((H=>H.sampler==x&&H.source===R));-1===c&&(c=k.length,k.push({source:R,sampler:x}));const t={index:c};return H&&(t.texCoord=H),t}_exportTextureSampler(R){const x=this._getTextureSampler(R),H=this._exporter._samplers,k=H.findIndex((R=>R.minFilter===x.minFilter&&R.magFilter===x.magFilter&&R.wrapS===x.wrapS&&R.wrapT===x.wrapT));return-1!==k?k:(H.push(x),H.length-1)}}var W=H(735),K=H(493),Q=H(12255),G=H(668);const T=k.o.Zero(),v=k.f.Identity(),p=k.o.One(),r=new k.o(-1,1,1);function z(R,x){const{byteOffset:H,byteStride:k,type:c,normalized:t}=R,A=R.getSize(),D=x.reduce(((R,x)=>x.getTotalVertices()>R?x.getTotalVertices():R),-Number.MAX_VALUE);return{byteOffset:H,byteStride:k,componentCount:A,type:c,count:D*A,normalized:t,totalVertices:D,kind:R.getKind()}}function j(R){switch(R){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function m(R){switch(R){case V.g.PositionKind:case V.g.NormalKind:case V.g.TangentKind:case V.g.ColorKind:case V.g.MatricesIndicesKind:case V.g.MatricesIndicesExtraKind:case V.g.MatricesWeightsKind:case V.g.MatricesWeightsExtraKind:case V.g.UVKind:case V.g.UV2Kind:case V.g.UV3Kind:case V.g.UV4Kind:case V.g.UV5Kind:case V.g.UV6Kind:return!0}return!1}function O(R){switch(R){case t.b.TriangleFillMode:return 4;case t.b.TriangleStripDrawMode:return 5;case t.b.TriangleFanDrawMode:return 6;case t.b.PointListDrawMode:case t.b.PointFillMode:return 0;case t.b.LineLoopDrawMode:return 2;case t.b.LineListDrawMode:return 1;case t.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${R}`)}function l(R){const x=Math.sqrt(R.x*R.x+R.y*R.y+R.z*R.z);x>0&&(R.x/=x,R.y/=x,R.z/=x)}function e(R){return R.x*=-1,R}function u(R){if(R.x*R.x+R.y*R.y>.5){const x=Math.abs(R.x),H=Math.abs(R.y);if(x>H){const H=Math.sign(R.x);R.x=x,R.y*=-H,R.z*=-H,R.w*=H}else{const x=Math.sign(R.y);R.x*=-x,R.y=H,R.z*=x,R.w*=-x}}else{const x=Math.abs(R.z),H=Math.abs(R.w);if(x>H){const H=Math.sign(R.z);R.x*=-H,R.y*=H,R.z=x,R.w*=-H}else{const x=Math.sign(R.w);R.x*=x,R.y*=-x,R.z*=-x,R.w=H}}return R}function Y(R){R.si(-R.z,R.w,R.x,-R.y)}function RR(R,x){const H=k.o.FromArrayToRef(x.translation||[0,0,0],0,k.g.Bi[0]),c=k.f.FromArrayToRef(x.rotation||[0,0,0,1],0,k.g.Quaternion[0]),t=k.e.ComposeToRef(p,c,H,k.g.Matrix[0]),A=k.o.FromArrayToRef(R.translation||[0,0,0],0,k.g.Bi[2]),D=k.f.FromArrayToRef(R.rotation||[0,0,0,1],0,k.g.Quaternion[1]),U=k.e.ComposeToRef(p,D,A,k.g.Matrix[1]);t.multiplyToRef(U,U),U.decompose(void 0,c,H),H.equalsWithEpsilon(T,G.e)?delete x.translation:x.translation=H.Li(),c.equalsWithEpsilon(v,G.e)?delete x.rotation:x.rotation=c.Li(),x.scale&&delete x.scale}function xR(R,x){if(!(x instanceof n.e))return!1;if(!(1===x.getChildren().length&&0===R.getChildren().length&&R.parent===x))return!1;const H=R.va(),k=R instanceof Q.b&&!H.useRightHandedSystem?r:p;return!!x.ti.equalsWithEpsilon(k,G.e)||(K.c.Warn(`Cannot collapse node ${R.name} into parent node ${x.name} with modified scaling.`),!1)}function HR(R){if(R instanceof Array){const x=new Float32Array(R);return new Uint8Array(x.buffer,x.byteOffset,x.byteLength)}return ArrayBuffer.isView(R)?new Uint8Array(R.buffer,R.byteOffset,R.byteLength):new Uint8Array(R)}function kR(R,x){for(const[H,k]of Object.entries(R)){const c=x[H];(Array.isArray(k)&&Array.isArray(c)&&cR(k,c)||k===c)&&delete R[H]}return R}function cR(R,x){return R.length===x.length&&R.every(((R,H)=>R===x[H]))}const tR=k.e.Compose(new k.o(-1,1,1),k.f.Identity(),k.o.Zero());function AR(R,x){if(!(R instanceof n.e))return!1;if(x){if(!R.getWorldMatrix().equalsWithEpsilon(k.e.IdentityReadOnly,G.e))return!1}else{if(!R.getWorldMatrix().multiplyToRef(tR,k.g.Matrix[0]).equalsWithEpsilon(k.e.IdentityReadOnly,G.e))return!1}return!(R instanceof g.b&&R.Ci)}const DR=new Map([[Int8Array,(R,x,H)=>R.setInt8(x,H)],[Uint8Array,(R,x,H)=>R.setUint8(x,H)],[Uint8ClampedArray,(R,x,H)=>R.setUint8(x,H)],[Int16Array,(R,x,H)=>R.setInt16(x,H,!0)],[Uint16Array,(R,x,H)=>R.setUint16(x,H,!0)],[Int32Array,(R,x,H)=>R.setInt32(x,H,!0)],[Uint32Array,(R,x,H)=>R.setUint32(x,H,!0)],[Float32Array,(R,x,H)=>R.setFloat32(x,H,!0)],[Float64Array,(R,x,H)=>R.setFloat64(x,H,!0)]]);class UR{writeTypedArray(R){this._checkGrowBuffer(R.byteLength);const x=DR.get(R.constructor);for(let H=0;H<R.length;H++)x(this._dataView,this._byteOffset,R[H]),this._byteOffset+=R.BYTES_PER_ELEMENT}constructor(R){this._data=new Uint8Array(R),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(R){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,R),this._byteOffset++}writeInt8(R){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,R),this._byteOffset++}writeInt16(R){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,R,!0),this._byteOffset+=2}writeUInt16(R){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,R,!0),this._byteOffset+=2}writeInt32(R){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,R,!0),this._byteOffset+=4}writeUInt32(R){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,R,!0),this._byteOffset+=4}writeFloat32(R){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,R,!0),this._byteOffset+=4}writeFloat64(R){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,R,!0),this._byteOffset+=8}_checkGrowBuffer(R){const x=this.byteOffset+R;if(x>this._data.byteLength){const R=new Uint8Array(2*x);R.set(this._data),this._data=R,this._dataView=new DataView(this._data.buffer)}}}function JR(R){return R%4===0?4:R%2===0?2:1}class VR{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(R){let x=0;this._bufferViewToData.forEach((R=>{x+=R.byteLength}));const H=new UR(x),k=Array.from(this._bufferViewToData.keys()).sort(((R,x)=>JR(x.byteLength)-JR(R.byteLength)));for(const c of k){c.byteOffset=H.byteOffset,R.push(c);const x=R.length-1,k=this.getPropertiesWithBufferView(c);for(const R of k)R.bufferView=x;H.writeTypedArray(this._bufferViewToData.get(c)),this._bufferViewToData.delete(c)}return H.getOutputData()}createBufferView(R,x){const H={buffer:0,byteOffset:void 0,byteLength:R.byteLength,byteStride:x};return this._bufferViewToData.set(H,R),H}createAccessor(R,x,H,k,c,t,A){this._verifyBufferView(R);const D={bufferView:void 0,componentType:H,count:k,type:x,min:null===t||void 0===t?void 0:t.min,max:null===t||void 0===t?void 0:t.max,normalized:A,byteOffset:c};return this.setBufferView(D,R),this._accessorToBufferView.set(D,R),D}setBufferView(R,x){this._verifyBufferView(x);this.getPropertiesWithBufferView(x).push(R)}removeBufferView(R){const x=this.getPropertiesWithBufferView(R);for(const H of x)void 0!==H.bufferView&&delete H.bufferView;this._bufferViewToData.delete(R),this._bufferViewToProperties.delete(R),this._accessorToBufferView.forEach(((x,H)=>{x===R&&(void 0!==H.byteOffset&&delete H.byteOffset,this._accessorToBufferView.delete(H))}))}getBufferView(R){const x=this._accessorToBufferView.get(R);return this._verifyBufferView(x),x}getPropertiesWithBufferView(R){return this._verifyBufferView(R),this._bufferViewToProperties.set(R,this._bufferViewToProperties.get(R)??[]),this._bufferViewToProperties.get(R)}getData(R){return this._verifyBufferView(R),this._bufferViewToData.get(R)}_verifyBufferView(R){if(void 0===R||!this._bufferViewToData.has(R))throw new Error(`BufferView ${R} not found in BufferManager.`)}}var nR,gR=H(637),IR=H(853),iR=H(12264),qR=H(12328),SR=H(12331),LR=H(12340),bR=H(471),CR=H(12348);!function(R){R[R.INTANGENT=0]="INTANGENT",R[R.OUTTANGENT=1]="OUTTANGENT"}(nR||(nR={}));class FR{static _IsTransformable(R){return R&&(R instanceof n.e||R instanceof gR.b||R instanceof CR.b)}static _CreateNodeAnimation(R,x,H,k,t){if(this._IsTransformable(R)){const A=[],D=[],U=x.getKeys(),J=FR._CalculateMinMaxKeyFrames(U),V=FR._DeduceInterpolation(U,H,k),n=V.interpolationType,g=V.shouldBakeAnimation;if(g?FR._CreateBakedAnimation(R,x,H,J.min,J.max,x.framePerSecond,t,A,D,J,k):"LINEAR"===n||"STEP"===n?FR._CreateLinearOrStepAnimation(R,x,H,A,D,k):"CUBICSPLINE"===n?FR._CreateCubicSplineAnimation(R,x,H,A,D,k):FR._CreateBakedAnimation(R,x,H,J.min,J.max,x.framePerSecond,t,A,D,J,k),A.length&&D.length){return{inputs:A,outputs:D,samplerInterpolation:n,inputsMin:g?J.min:c.e.FloatRound(J.min/x.framePerSecond),inputsMax:g?J.max:c.e.FloatRound(J.max/x.framePerSecond)}}}return null}static _DeduceAnimationInfo(R){let x=null,H="VEC3",k=!1;const t=R.targetProperty.split(".");switch(t[0]){case"ti":x="scale";break;case"position":x="translation";break;case"rotation":H="VEC4",x="rotation";break;case"rotationQuaternion":H="VEC4",k=!0,x="rotation";break;case"influence":H="SCALAR",x="weights";break;default:c.e.Error(`Unsupported animatable property ${t[0]}`)}return x?{animationChannelTargetPath:x,dataAccessorType:H,useQuaternion:k}:(c.e.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(R,x,H,k,c,t,A,D,U,J,V){let n;if(FR._IsTransformable(R)&&R.animations)for(const g of R.animations){if(V&&!V(g))continue;const c=FR._DeduceAnimationInfo(g);c&&(n={name:g.name,samplers:[],channels:[]},FR._AddAnimation(`${g.name}`,g.hasRunningRuntimeAnimations?x:n,R,g,c.dataAccessorType,c.animationChannelTargetPath,k,t,A,D,c.useQuaternion,U,J),n.samplers.length&&n.channels.length&&H.push(n))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(R,x,H,k,c,t,A,D,U,J,V){let n;if(R instanceof bR.d){const c=R.morphTargetManager;if(c)for(let g=0;g<c.numTargets;++g){const I=c.getTarget(g);for(const i of I.animations){if(V&&!V(i))continue;const I=new SR.c(`${i.name}`,"influence",i.framePerSecond,i.dataType,i.loopMode,i.enableBlending),q=[],S=i.getKeys();for(let R=0;R<S.length;++R){const x=S[R];for(let R=0;R<c.numTargets;++R)R==g?q.push(x):q.push({frame:x.frame,value:0})}I.setKeys(q);const L=FR._DeduceAnimationInfo(I);L&&(n={name:I.name,samplers:[],channels:[]},FR._AddAnimation(i.name,i.hasRunningRuntimeAnimations?x:n,R,I,L.dataAccessorType,L.animationChannelTargetPath,k,t,A,D,L.useQuaternion,U,J,c.numTargets),n.samplers.length&&n.channels.length&&H.push(n))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(R,x,H,k,c,t,A,D,U){let J;if(R.animationGroups){const n=R.animationGroups;for(const g of n){const n=new Map,I=new Map,i=new Set,q=g.to-g.from;J={name:g.name,channels:[],samplers:[]};for(let x=0;x<g.targetedAnimations.length;++x){const q=g.targetedAnimations[x],S=q.target,L=q.animation;if(U&&!U(L))continue;const b=D.has(S);if(this._IsTransformable(S)||1===S.length&&this._IsTransformable(S[0])){const R=FR._DeduceAnimationInfo(q.animation);if(R){const x=this._IsTransformable(S)?S:this._IsTransformable(S[0])?S[0]:null;x&&FR._AddAnimation(`${L.name}`,J,x,L,R.dataAccessorType,R.animationChannelTargetPath,H,k,c,t,R.useQuaternion,A,b)}}else if(S instanceof LR.e||1===S.length&&S[0]instanceof LR.e){if(FR._DeduceAnimationInfo(q.animation)){const x=S instanceof LR.e?S:S[0];if(x){const H=R.morphTargetManagers.find((R=>{for(let H=0;H<R.numTargets;++H)if(R.getTarget(H)===x)return!0;return!1}));if(H){const k=R.meshes.find((R=>R.morphTargetManager===H));var V;if(k)n.has(k)||n.set(k,new Map),null===(V=n.get(k))||void 0===V||V.set(x,L),i.add(k),I.set(k,L)}}}}}i.forEach((R=>{const x=R.morphTargetManager;let D=null;const U=[],V=I.get(R).getKeys(),i=V.length;for(let H=0;H<i;++H)for(let k=0;k<x.numTargets;++k){const c=x.getTarget(k),t=n.get(R);if(t){const x=t.get(c);x?(D||(D=new SR.c(`${g.name}_${R.name}_MorphWeightAnimation`,"influence",x.framePerSecond,SR.c.ANIMATIONTYPE_FLOAT,x.loopMode,x.enableBlending)),U.push(x.getKeys()[H])):U.push({frame:g.from+q/i*H,value:c.influence,inTangent:V[0].inTangent?0:void 0,outTangent:V[0].outTangent?0:void 0})}}D.setKeys(U);const S=FR._DeduceAnimationInfo(D);S&&FR._AddAnimation(`${g.name}_${R.name}_MorphWeightAnimation`,J,R,D,S.dataAccessorType,S.animationChannelTargetPath,H,k,c,t,S.useQuaternion,A,!1,null===x||void 0===x?void 0:x.numTargets)})),J.channels.length&&J.samplers.length&&x.push(J)}}}static _AddAnimation(R,x,H,c,t,A,D,U,J,V,n,g,I,i){const q=FR._CreateNodeAnimation(H,c,A,n,g);let S,L,b,C,F,d;if(q){if(i){let R=0,x=0;const H=[];for(;q.inputs.length>0;)x=q.inputs.shift(),R%i==0&&H.push(x),R++;q.inputs=H}const R=D.get(H),c=new Float32Array(q.inputs);S=U.createBufferView(c),L=U.createAccessor(S,"SCALAR",5126,q.inputs.length,void 0,{min:[q.inputsMin],max:[q.inputsMax]}),V.push(L),b=V.length-1;const J=new k.f,n=new k.o,g=new k.o,P=H instanceof gR.b,a=j(t),X=new Float32Array(q.outputs.length*a);q.outputs.forEach((function(R,x){let H=R;switch(A){case"translation":I&&(k.o.FromArrayToRef(R,0,g),e(g),g.toArray(H));break;case"rotation":4===R.length?k.f.FromArrayToRef(R,0,J):(H=new Array(4),k.o.FromArrayToRef(R,0,n),k.f.FromEulerVectorToRef(n,J)),I&&(u(J),P&&Y(J)),J.toArray(H)}X.set(H,x*a)})),S=U.createBufferView(X),L=U.createAccessor(S,t,5126,q.outputs.length),V.push(L),C=V.length-1,F={interpolation:q.samplerInterpolation,input:b,output:C},x.samplers.push(F),d={sampler:x.samplers.length-1,target:{node:R,path:A}},x.channels.push(d)}}static _CreateBakedAnimation(R,x,H,t,A,D,U,J,V,n,g){let I;const i=k.f.Identity();let q,S=null,L=null,b=null,C=null,F=null,d=null;n.min=c.e.FloatRound(t/D);const P=x.getKeys();for(let k=0,a=P.length;k<a;++k){if(d=null,b=P[k],k+1<a)if(C=P[k+1],b.value.equals&&b.value.equals(C.value)||b.value===C.value){if(0!==k)continue;d=b.frame}else d=C.frame;else{if(F=P[k-1],b.value.equals&&b.value.equals(F.value)||b.value===F.value)continue;d=A}if(d)for(let k=b.frame;k<=d;k+=U){if(q=c.e.FloatRound(k/D),q===S)continue;S=q,L=q;const t={key:0,repeatCount:0,loopMode:x.loopMode};I=x._interpolate(k,t),FR._SetInterpolatedValue(R,I,q,x,H,i,J,V,g)}}L&&(n.max=L)}static _ConvertFactorToVector3OrQuaternion(R,x,H,t,A){const D=FR._GetBasePositionRotationOrScale(x,t,A),U=H.targetProperty.split("."),J=U?U[1]:"",V=A?k.f.zi(D).normalize():k.o.zi(D);switch(J){case"x":case"y":case"z":V[J]=R;break;case"w":V.w=R;break;default:c.e.Error(`glTFAnimation: Unsupported component name "${J}"!`)}return V}static _SetInterpolatedValue(R,x,H,c,t,A,D,U,J){let V;D.push(H),"weights"!==t?(c.dataType===SR.c.ANIMATIONTYPE_FLOAT&&(x=this._ConvertFactorToVector3OrQuaternion(x,R,c,t,J)),"rotation"===t?(J?A=x:(V=x,k.f.RotationYawPitchRollToRef(V.y,V.x,V.z,A)),U.push(A.Li())):(V=x,U.push(V.Li()))):U.push([x])}static _CreateLinearOrStepAnimation(R,x,H,k,c,t){for(const A of x.getKeys())k.push(A.frame/x.framePerSecond),FR._AddKeyframeValue(A,x,c,H,R,t)}static _CreateCubicSplineAnimation(R,x,H,k,c,t){x.getKeys().forEach((function(A){k.push(A.frame/x.framePerSecond),FR._AddSplineTangent(nR.INTANGENT,c,H,"CUBICSPLINE",A,t),FR._AddKeyframeValue(A,x,c,H,R,t),FR._AddSplineTangent(nR.OUTTANGENT,c,H,"CUBICSPLINE",A,t)}))}static _GetBasePositionRotationOrScale(R,x,H){let c;if("rotation"===x)if(H){c=(R.rotationQuaternion??k.f.Identity()).Li()}else{c=(R.rotation??k.o.Zero()).Li()}else if("translation"===x){c=(R.position??k.o.Zero()).Li()}else{c=(R.ti??k.o.One()).Li()}return c}static _AddKeyframeValue(R,x,H,t,A,D){let U;const J=x.dataType;if(J===SR.c.ANIMATIONTYPE_VECTOR3){let x=R.value.Li();if("rotation"===t){const R=k.o.zi(x);x=k.f.RotationYawPitchRoll(R.y,R.x,R.z).Li()}H.push(x)}else if(J===SR.c.ANIMATIONTYPE_FLOAT){if("weights"===t)H.push([R.value]);else if(U=this._ConvertFactorToVector3OrQuaternion(R.value,A,x,t,D),U){if("rotation"===t){const R=D?U:k.f.RotationYawPitchRoll(U.y,U.x,U.z).normalize();H.push(R.Li())}H.push(U.Li())}}else J===SR.c.ANIMATIONTYPE_QUATERNION?H.push(R.value.normalize().Li()):c.e.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(R,x,H){let k,c,t=!1;if("rotation"===x&&!H)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let A=0,D=R.length;A<D;++A)if(c=R[A],c.inTangent||c.outTangent)if(k){if("CUBICSPLINE"!==k){k="LINEAR",t=!0;break}}else k="CUBICSPLINE";else if(k){if("CUBICSPLINE"===k||c.interpolation&&1===c.interpolation&&"STEP"!==k){k="LINEAR",t=!0;break}}else k=c.interpolation&&1===c.interpolation?"STEP":"LINEAR";return k||(k="LINEAR"),{interpolationType:k,shouldBakeAnimation:t}}static _AddSplineTangent(R,x,H,c,t,A){let D;const U=R===nR.INTANGENT?t.inTangent:t.outTangent;if("CUBICSPLINE"===c){if("rotation"===H)if(U)if(A)D=U.Li();else{const R=U;D=k.f.RotationYawPitchRoll(R.y,R.x,R.z).Li()}else D=[0,0,0,0];else D="weights"===H?U?[U]:[0]:U?U.Li():[0,0,0];x.push(D)}}static _CalculateMinMaxKeyFrames(R){let x=1/0,H=-1/0;return R.forEach((function(R){x=Math.min(x,R.frame),H=Math.max(H,R.frame)})),{min:x,max:H}}}function dR(R,x,H,t,A,D){const U={attributes:{},influence:R.influence,name:R.name},J=x.Ci;if(!J)return c.e.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),U;const n=D?-1:1,g=k.o.Zero();let I=0,i=0;if(R.hasPositions){const t=R.getPositions(),D=J.getVerticesData(V.g.PositionKind);if(D){const R=new Float32Array(D.length),x=[1/0,1/0,1/0],c=[-1/0,-1/0,-1/0];i=D.length/3,I=0;for(let H=I;H<i;++H){const A=k.o.zi(D,3*H);k.o.zi(t,3*H).subtractToRef(A,g),g.x*=n,x[0]=Math.min(x[0],g.x),c[0]=Math.max(c[0],g.x),x[1]=Math.min(x[1],g.y),c[1]=Math.max(c[1],g.y),x[2]=Math.min(x[2],g.z),c[2]=Math.max(c[2],g.z),R[3*H]=g.x,R[3*H+1]=g.y,R[3*H+2]=g.z}const J=H.createBufferView(R,12),V=H.createAccessor(J,"VEC3",5126,t.length/3,0,{min:x,max:c});A.push(V),U.attributes.POSITION=A.length-1}else c.e.Warn(`Morph target positions for mesh ${x.name} were not exported. Mesh does not have position vertex data`)}if(R.hasNormals){const t=R.getNormals(),D=J.getVerticesData(V.g.NormalKind);if(D){const R=new Float32Array(D.length);i=D.length/3,I=0;for(let H=I;H<i;++H){const x=k.o.zi(D,3*H).normalize();k.o.zi(t,3*H).normalize().subtractToRef(x,g),R[3*H]=g.x*n,R[3*H+1]=g.y,R[3*H+2]=g.z}const x=H.createBufferView(R,12),c=H.createAccessor(x,"VEC3",5126,t.length/3,0);A.push(c),U.attributes.NORMAL=A.length-1}else c.e.Warn(`Morph target normals for mesh ${x.name} were not exported. Mesh does not have normals vertex data`)}if(R.hasTangents){const t=R.getTangents(),D=J.getVerticesData(V.g.TangentKind);if(D){i=D.length/4;const R=new Float32Array(3*i);I=0;for(let H=I;H<i;++H){const x=k.o.zi(D,4*H);l(x);const c=k.o.zi(t,3*H);l(c),c.subtractToRef(x,g),R[3*H]=g.x*n,R[3*H+1]=g.y,R[3*H+2]=g.z}const x=H.createBufferView(R,12),c=H.createAccessor(x,"VEC3",5126,i,0);A.push(c),U.attributes.TANGENT=A.length-1}else c.e.Warn(`Morph target tangents for mesh ${x.name} were not exported. Mesh does not have tangents vertex data`)}if(R.hasColors){const t=R.getColors(),D=J.getVerticesData(V.g.ColorKind),n=J.getVertexBuffer(V.g.ColorKind);if(D&&n){const R=n.getSize();i=D.length/R;const x=new Float32Array(i*R);I=0;for(let H=I;H<i;++H)if(3===R){const c=k.o.zi(D,H*R);k.o.zi(t,H*R).subtractToRef(c,g),x[3*H]=g.x,x[3*H+1]=g.y,x[3*H+2]=g.z}else if(4===R){const c=new k.p,A=k.p.zi(D,H*R);k.p.zi(t,H*R).subtractToRef(A,c),x[4*H]=c.x,x[4*H+1]=c.y,x[4*H+2]=c.z,x[4*H+3]=c.w}else c.e.Warn(`Unsupported number of components for color attribute: ${R}`);const J=H.createBufferView(x,4*R),V=H.createAccessor(J,3===R?"VEC3":"VEC4",5126,i,0);A.push(V),U.attributes.COLOR_0=A.length-1}else c.e.Warn(`Morph target colors for mesh ${x.name} were not exported. Mesh does not have colors vertex data`)}return U}var PR=H(12356),aR=H(12281),XR=H(12276),MR=H(610);class BR{}BR.DEFAULT_COLOR=S.c.White(),BR.DEFAULT_WIDTH_ATTENUATED=1,BR.DEFAULT_WIDTH=.1;var oR=H(2288),ZR=H(12370);class yR{static ConvertPoints(R,x){if(R.length&&Array.isArray(R)&&"number"===typeof R[0])return[R];if(R.length&&Array.isArray(R[0])&&"number"===typeof R[0][0])return R;if(R.length&&!Array.isArray(R[0])&&R[0]instanceof k.o){const x=[];for(let H=0;H<R.length;H++){const k=R[H];x.push(k.x,k.y,k.z)}return[x]}if(R.length>0&&Array.isArray(R[0])&&R[0].length>0&&R[0][0]instanceof k.o){const x=[],H=R;for(const R of H)x.push(R.flatMap((R=>[R.x,R.y,R.z])));return x}if(R instanceof Float32Array){if(null!==x&&void 0!==x&&x.floatArrayStride){const H=[],k=3*x.floatArrayStride;for(let x=0;x<R.length;x+=k){const c=new Array(k);for(let H=0;H<k;H++)c[H]=R[x+H];H.push(c)}return H}return[Array.from(R)]}if(R.length&&R[0]instanceof Float32Array){const x=[];for(const H of R)x.push(Array.from(H));return x}return[]}static OmitZeroLengthPredicate(R,x,H){const k=[];return x.Pg(R).lengthSquared()>0&&k.push([R,x]),H.Pg(x).lengthSquared()>0&&k.push([x,H]),R.Pg(H).lengthSquared()>0&&k.push([H,R]),0===k.length?null:k}static OmitDuplicatesPredicate(R,x,H,k){const c=[];return yR._SearchInPoints(R,x,k)||c.push([R,x]),yR._SearchInPoints(x,H,k)||c.push([x,H]),yR._SearchInPoints(H,R,k)||c.push([H,R]),0===c.length?null:c}static _SearchInPoints(R,x,H){for(const A of H)for(let H=0;H<A.length;H++){var k,c,t;if(null!==(k=A[H])&&void 0!==k&&k.equals(R))if(null!==(c=A[H+1])&&void 0!==c&&c.equals(x)||null!==(t=A[H-1])&&void 0!==t&&t.equals(x))return!0}return!1}static MeshesToLines(R,x){const H=[];for(let c=0;c<R.length;c++){const t=R[c],A=t.getVerticesData(V.g.PositionKind),D=t.Gi();if(A&&D)for(let R=0,U=0;R<D.length;R++){const J=3*D[U++],V=3*D[U++],n=3*D[U++],g=new k.o(A[J],A[J+1],A[J+2]),I=new k.o(A[V],A[V+1],A[V+2]),i=new k.o(A[n],A[n+1],A[n+2]);if(x){const k=x(g,I,i,H,R,J,t,c,A,D);if(k)for(const R of k)H.push(R)}else H.push([g,I],[I,i],[i,g])}}return H}static ToVector3Array(R){if(Array.isArray(R[0])){const x=[],H=R;for(const R of H){const H=[];for(let x=0;x<R.length;x+=3)H.push(new k.o(R[x],R[x+1],R[x+2]));x.push(H)}return x}const x=R,H=[];for(let c=0;c<x.length;c+=3)H.push(new k.o(x[c],x[c+1],x[c+2]));return H}static ToNumberArray(R){return R.flatMap((R=>[R.x,R.y,R.z]))}static GetPointsCountInfo(R){const x=new Array(R.length);let H=0;for(let k=R.length;k--;)x[k]=R[k].length/3,H+=x[k];return{total:H,counts:x}}static GetLineLength(R){if(0===R.length)return 0;let x;x="number"===typeof R[0]?yR.ToVector3Array(R):R;const H=k.g.Bi[0];let c=0;for(let k=0;k<x.length-1;k++){const R=x[k];c+=x[k+1].subtractToRef(R,H).length()}return c}static GetLineLengthArray(R){const x=new Float32Array(R.length/3);let H=0;for(let k=0,c=R.length/3-1;k<c;k++){let c=R[3*k+0],t=R[3*k+1],A=R[3*k+2];c-=R[3*k+3],t-=R[3*k+4],A-=R[3*k+5];H+=Math.sqrt(c*c+t*t+A*A),x[k+1]=H}return x}static SegmentizeSegmentByCount(R,x,H){const c=[],t=x.Pg(R),A=k.g.Bi[0];A.Ai(H);const D=k.g.Bi[1];t.divideToRef(A,D);let U=R.clone();c.push(U);for(let k=0;k<H;k++)U=U.clone(),c.push(U.addInPlace(D));return c}static SegmentizeLineBySegmentLength(R,x){const H=R[0]instanceof k.o?yR.GetLineSegments(R):"number"===typeof R[0]?yR.GetLineSegments(yR.ToVector3Array(R)):R,c=[];for(const k of H)if(k.length>x){const R=yR.SegmentizeSegmentByCount(k.point1,k.point2,Math.ceil(k.length/x));for(const x of R)c.push(x)}else c.push(k.point1),c.push(k.point2);return c}static SegmentizeLineBySegmentCount(R,x){const H="number"===typeof R[0]?yR.ToVector3Array(R):R,k=yR.GetLineLength(H)/x;return yR.SegmentizeLineBySegmentLength(H,k)}static GetLineSegments(R){const x=[];for(let H=0;H<R.length-1;H++){const k=R[H],c=R[H+1],t=c.Pg(k).length();x.push({point1:k,point2:c,length:t})}return x}static GetMinMaxSegmentLength(R){const x=yR.GetLineSegments(R).sort((R=>R.length));return{min:x[0].length,max:x[x.length-1].length}}static GetPositionOnLineByVisibility(R,x,H){let c=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=x*H;let A=0,D=0;const U=R.length;for(let k=0;k<U;k++){if(t<=A+R[k].length){D=k;break}A+=R[k].length}const J=(t-A)/R[D].length;return R[D].point2.subtractToRef(R[D].point1,k.g.Bi[0]),k.g.Bi[1]=k.g.Bi[0].multiplyByFloats(J,J,J),c||k.g.Bi[1].addInPlace(R[D].point1),k.g.Bi[1].clone()}static GetCircleLinePoints(R,x){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,c=arguments.length>3&&void 0!==arguments[3]?arguments[3]:R,t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/x;const A=[];for(let D=0;D<=x;D++)A.push(new k.o(Math.cos(D*t)*R,Math.sin(D*t)*c,H));return A}static GetBezierLinePoints(R,x,H,k){return oR.e.CreateQuadraticBezier(R,x,H,k).getPoints().flatMap((R=>[R.x,R.y,R.z]))}static GetArrowCap(R,x,H,k,c){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,A=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[R.clone(),R.add(x.multiplyByFloats(H,H,H))],widths:[k,c,t,A]}}static GetPointsFromText(R,x,H,k){let c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const A=[],D=(0,ZR.d)(R,x,H,k);for(const U of D){for(const R of U.paths){const x=[],H=R.getPoints();for(const R of H)x.push(R.x,R.y,c);A.push(x)}if(t)for(const R of U.holes){const x=[],H=R.getPoints();for(const R of H)x.push(R.x,R.y,c);A.push(x)}}return A}static Color3toRGBAUint8(R){const x=new Uint8Array(4*R.length);for(let H=0,k=0;H<R.length;H++)x[k++]=255*R[H].r,x[k++]=255*R[H].g,x[k++]=255*R[H].b,x[k++]=255;return x}static CreateColorsTexture(R,x,H,k){const c=k.getEngine().getCaps().maxTextureSize??1,t=x.length>c?c:x.length,A=Math.ceil(x.length/c);A>1&&(x=[...x,...Array(t*A-x.length).fill(x[0])]);const D=yR.Color3toRGBAUint8(x),U=new P.b(D,t,A,i.b.TEXTUREFORMAT_RGBA,k,!1,!0,H);return U.name=R,U}static PrepareEmptyColorsTexture(R){if(!BR.EmptyColorsTexture){const x=new Uint8Array(4);BR.EmptyColorsTexture=new P.b(x,1,1,i.b.TEXTUREFORMAT_RGBA,R,!1,!1,P.b.NEAREST_NEAREST),BR.EmptyColorsTexture.name="grlEmptyColorsTexture"}return BR.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var R;null===(R=BR.EmptyColorsTexture)||void 0===R||R.dispose(),BR.EmptyColorsTexture=null}static BooleanToNumber(R){return R?1:0}}class sR extends XR.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class ER extends aR.e{isCompatible(R){return!0}constructor(R,x,H){var c;H=H||{color:BR.DEFAULT_COLOR};const t=new sR;t.GREASED_LINE_HAS_COLOR=!!H.color&&!H.useColors,t.GREASED_LINE_SIZE_ATTENUATION=H.sizeAttenuation??!1,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===H.colorDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(x??R.va()).useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=H.cameraFacing??!0,super(R,ER.GREASED_LINE_MATERIAL_NAME,200,t,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(c=H)||void 0===c?void 0:c.forceGLSL)||ER.ForceGLSL,this._scene=x??R.va(),this._engine=this._scene.getEngine(),this._cameraFacing=H.cameraFacing??!0,this.visibility=H.visibility??1,this.useDash=H.useDash??!1,this.dashRatio=H.dashRatio??.5,this.dashOffset=H.dashOffset??0,this.width=H.width?H.width:H.sizeAttenuation?BR.DEFAULT_WIDTH_ATTENUATED:BR.DEFAULT_WIDTH,this._sizeAttenuation=H.sizeAttenuation??!1,this.colorMode=H.colorMode??0,this._color=H.color??null,this.useColors=H.useColors??!1,this._colorsDistributionType=H.colorDistributionType??0,this.colorsSampling=H.colorsSampling??P.b.NEAREST_NEAREST,this._colors=H.za??null,this.dashCount=H.dashCount??1,this.resolution=H.resolution??new k.k(this._engine.getRenderWidth(),this._engine.getRenderHeight()),H.colorsTexture?this.colorsTexture=H.colorsTexture:this._colors?this.colorsTexture=yR.CreateColorsTexture(`${R.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??BR.DEFAULT_COLOR,yR.PrepareEmptyColorsTexture(this._scene)),this._engine.Vi.add((()=>{yR.DisposeEmptyColorsTexture()}))}getAttributes(R){R.push("grl_offsets"),R.push("grl_widths"),R.push("grl_colorPointers"),R.push("grl_counters"),this._cameraFacing?(R.push("grl_previousAndSide"),R.push("grl_nextAndCounters")):R.push("grl_slopes")}getSamplers(R){R.push("grl_colors")}getActiveTextures(R){this.colorsTexture&&R.push(this.colorsTexture)}getUniforms(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const x=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&x.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===R&&x.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:x,vertex:this._cameraFacing&&this._isGLSL(R)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(R)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(R){if(this._cameraFacing){R.jj("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||R.jj("viewProjection",this._scene.getTransformMatrix());const x=k.g.Vector4[0];x.x=this._aspect,x.y=this._resolution.x,x.z=this._resolution.y,x.w=this.width,R.updateVector4("grl_aspect_resolution_lineWidth",x)}const x=k.g.Vector4[0];x.x=yR.BooleanToNumber(this.useDash),x.y=this._dashArray,x.z=this.dashOffset,x.w=this.dashRatio,R.updateVector4("grl_dashOptions",x);const H=k.g.Vector4[1];H.x=this.colorMode,H.y=this.visibility,H.z=this.colorsTexture?this.colorsTexture.getSize().width:0,H.w=yR.BooleanToNumber(this.useColors),R.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",H),this._color&&R.updateColor3("grl_singleColor",this._color);const c=this.colorsTexture??BR.EmptyColorsTexture;R.setTexture("grl_colors",c),R.updateFloat2("grl_textureSize",(null===c||void 0===c?void 0:c.getSize().width)??1,(null===c||void 0===c?void 0:c.getSize().height)??1)}prepareDefines(R,x,H){R.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,R.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,R.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,R.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=x.useRightHandedSystem,R.GREASED_LINE_CAMERA_FACING=this._cameraFacing,R.GREASED_LINE_USE_OFFSETS=!!H.offsets}getClassName(){return ER.GREASED_LINE_MATERIAL_NAME}getCustomCode(R){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(x)?function(R,x){if("vertex"===R){const R={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return x&&(R["!gl_Position\\=viewProjection\\*worldPos;"]="//"),R}return"fragment"===R?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(R,this._cameraFacing):function(R,x){if("vertex"===R){const R={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return x&&(R["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),R}return"fragment"===R?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(R,this._cameraFacing)}dispose(){var R;null===(R=this.colorsTexture)||void 0===R||R.dispose(),super.dispose()}get za(){return this._colors}set za(R){this.setColors(R)}setColors(R){var x;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var t;if(this._colors=R,null!==R&&0!==R.length){if(!H||k)if(this.colorsTexture&&c===R.length&&!k){const x=yR.Color3toRGBAUint8(R);this.colorsTexture.update(x)}else{var A;null===(A=this.colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=yR.CreateColorsTexture(`${this._material.name}-colors-texture`,R,this.colorsSampling,this._scene)}}else null===(t=this.colorsTexture)||void 0===t||t.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(R){this._dashCount=R,this._dashArray=1/R}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(R){this._sizeAttenuation=R,this.markAllDefinesAsDirty()}get color(){return this._color}set color(R){this.setColor(R)}setColor(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==R||null!==this._color&&null===R?(this._color=R,x||this.markAllDefinesAsDirty()):this._color=R}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(R){this._colorsDistributionType=R,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(R){this._aspect=R.x/R.y,this._resolution=R}serialize(){const R=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(x.za=this._colors),this._color&&(x.color=this._color),R.greasedLineMaterialOptions=x,R}parse(R,x,H){var k;super.parse(R,x,H);const c=R.greasedLineMaterialOptions;null===(k=this.colorsTexture)||void 0===k||k.dispose(),c.color&&this.setColor(c.color,!0),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.za&&(this.za=c.za),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),this.za?this.colorsTexture=yR.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,x):yR.PrepareEmptyColorsTexture(x),this.markAllDefinesAsDirty()}copyTo(R){var x;const H=R;null===(x=H.colorsTexture)||void 0===x||x.dispose(),this._colors&&(H.colorsTexture=yR.CreateColorsTexture(`${H._material.name}-colors-texture`,this._colors,H.colorsSampling,this._scene)),H.setColor(this.color,!0),H.colorsDistributionType=this.colorsDistributionType,H.colorsSampling=this.colorsSampling,H.colorMode=this.colorMode,H.useColors=this.useColors,H.visibility=this.visibility,H.useDash=this.useDash,H.dashCount=this.dashCount,H.dashRatio=this.dashRatio,H.dashOffset=this.dashOffset,H.width=this.width,H.sizeAttenuation=this.sizeAttenuation,H.resolution=this.resolution,H.markAllDefinesAsDirty()}_isGLSL(R){return 0===R||this._forceGLSL}}ER.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",ER.ForceGLSL=!1,(0,MR.h)(`BABYLON.${ER.GREASED_LINE_MATERIAL_NAME}`,ER);var wR=H(744),hR=H(497),fR=H(12364),NR=H(596);class WR extends fR.c{constructor(R,x,c){const t=x.getEngine(),A=t.isWebGPU&&!(c.forceGLSL||WR.ForceGLSL),D=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];x.useRightHandedSystem&&D.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const U=["position","grl_widths","grl_offsets","grl_colorPointers"];c.cameraFacing?(D.push("GREASED_LINE_CAMERA_FACING"),U.push("grl_previousAndSide","grl_nextAndCounters")):(U.push("grl_slopes"),U.push("grl_counters"));const J=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(A||J.push("world","viewProjection","view","projection"),super(R,x,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:A?["Scene","Mesh"]:void 0,attributes:U,uniforms:J,samplers:A?[]:["grlColors"],defines:D,extraInitializationsAsync:async()=>{A?await Promise.all([H.e(51).then(H.bind(H,14376)),H.e(59).then(H.bind(H,14378))]):await Promise.all([H.e(54).then(H.bind(H,14387)),H.e(60).then(H.bind(H,14393))])},shaderLanguage:A?1:0}),this._color=S.c.White(),this._colorsDistributionType=0,this._colorsTexture=null,c=c||{color:BR.DEFAULT_COLOR},this.visibility=c.visibility??1,this.useDash=c.useDash??!1,this.dashRatio=c.dashRatio??.5,this.dashOffset=c.dashOffset??0,this.dashCount=c.dashCount??1,this.width=c.width?c.width:c.sizeAttenuation&&c.cameraFacing?BR.DEFAULT_WIDTH_ATTENUATED:BR.DEFAULT_WIDTH,this.sizeAttenuation=c.sizeAttenuation??!1,this.color=c.color??S.c.White(),this.useColors=c.useColors??!1,this.colorsDistributionType=c.colorDistributionType??0,this.colorsSampling=c.colorsSampling??P.b.NEAREST_NEAREST,this.colorMode=c.colorMode??0,this._colors=c.za??null,this._cameraFacing=c.cameraFacing??!0,this.resolution=c.resolution??new k.k(t.getRenderWidth(),t.getRenderHeight()),c.colorsTexture?this.colorsTexture=c.colorsTexture:this._colors?this.colorsTexture=yR.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,x):(this._color=this._color??BR.DEFAULT_COLOR,this.colorsTexture=yR.PrepareEmptyColorsTexture(x)),A){const R=new NR.d;R.setParameters(),R.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",R)}t.Vi.add((()=>{yR.DisposeEmptyColorsTexture()}))}dispose(){var R;null===(R=this._colorsTexture)||void 0===R||R.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new k.k(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(R){this.setColors(R)}setColors(R){var x;let H=arguments.length>1&&void 0!==arguments[1]&&arguments[1],k=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const c=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var t;if(this._colors=R,null!==R&&0!==R.length){if(!H||k)if(this._colorsTexture&&c===R.length&&!k){const x=yR.Color3toRGBAUint8(R);this._colorsTexture.update(x)}else{var A;null===(A=this._colorsTexture)||void 0===A||A.dispose(),this.colorsTexture=yR.CreateColorsTexture(`${this.name}-colors-texture`,R,this.colorsSampling,this.va())}}else null===(t=this._colorsTexture)||void 0===t||t.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(R){this._colorsTexture=R,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(R){this._width=R,this.setFloat("grlWidth",R)}get useColors(){return this._useColors}set useColors(R){this._useColors=R,this.setFloat("grlUseColors",yR.BooleanToNumber(R))}get colorsSampling(){return this._colorsSampling}set colorsSampling(R){this._colorsSampling=R}get visibility(){return this._visibility}set visibility(R){this._visibility=R,this.setFloat("grlVisibility",R)}get useDash(){return this._useDash}set useDash(R){this._useDash=R,this.setFloat("grlUseDash",yR.BooleanToNumber(R))}get dashOffset(){return this._dashOffset}set dashOffset(R){this._dashOffset=R,this.setFloat("grlDashOffset",R)}get dashRatio(){return this._dashRatio}set dashRatio(R){this._dashRatio=R,this.setFloat("grlDashRatio",R)}get dashCount(){return this._dashCount}set dashCount(R){this._dashCount=R,this._dashArray=1/R,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(R){this._sizeAttenuation=R,this.setFloat("grlSizeAttenuation",yR.BooleanToNumber(R))}get color(){return this._color}set color(R){this.setColor(R)}setColor(R){R=R??BR.DEFAULT_COLOR,this._color=R,this.setColor3("grlColor",R)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(R){this._colorsDistributionType=R,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(R){this._colorMode=R,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(R){this._resolution=R,this.setVector2("grlResolution",R),this.setFloat("grlAspect",R.x/R.y)}serialize(){const R=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(x.za=this._colors),R.greasedLineMaterialOptions=x,R}parse(R,x,H){var k;const c=R.greasedLineMaterialOptions;null===(k=this._colorsTexture)||void 0===k||k.dispose(),c.color&&(this.color=c.color),c.colorDistributionType&&(this.colorsDistributionType=c.colorDistributionType),c.colorsSampling&&(this.colorsSampling=c.colorsSampling),c.colorMode&&(this.colorMode=c.colorMode),c.useColors&&(this.useColors=c.useColors),c.visibility&&(this.visibility=c.visibility),c.useDash&&(this.useDash=c.useDash),c.dashCount&&(this.dashCount=c.dashCount),c.dashRatio&&(this.dashRatio=c.dashRatio),c.dashOffset&&(this.dashOffset=c.dashOffset),c.width&&(this.width=c.width),c.sizeAttenuation&&(this.sizeAttenuation=c.sizeAttenuation),c.resolution&&(this.resolution=c.resolution),c.za?this.colorsTexture=yR.CreateColorsTexture(`${this.name}-colors-texture`,c.za,this.colorsSampling,this.va()):this.colorsTexture=yR.PrepareEmptyColorsTexture(x),this._cameraFacing=c.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var KR,QR,GR;WR.ForceGLSL=!1,function(R){R[R.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",R[R.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(KR||(KR={})),function(R){R[R.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",R[R.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",R[R.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(QR||(QR={})),function(R){R[R.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",R[R.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",R[R.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",R[R.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",R[R.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(GR||(GR={}));class TR extends bR.d{constructor(R,x,H){super(R,x,null,null,!1,!1),this.name=R,this._options=H,this._lazy=!1,this._updatable=!1,this._engine=x.getEngine(),this._lazy=H.lazy??!1,this._updatable=H.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=H.colorPointers??[],this._widths=H.widths??new Array(H.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(R){let x=0;for(const k of this._points)x+=k.length;const H=x/3*2-this._widths.length;for(let k=0;k<H;k++)this._widths.push(R)}updateLazy(){var R,x;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(R=this._options.ribbonOptions)||void 0===R?void 0:R.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(x=this.greasedLineMaterial)||void 0===x||x.updateLazy()}addPoints(R,x){for(const H of R)this._points.push(H);this._lazy||this.setPoints(this._points,x)}dispose(R){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(R,x)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(R){this._uvs=R instanceof Float32Array?R:new Float32Array(R),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(R){this.material instanceof WR&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===R||void 0===R?void 0:R.length)>0),this._offsets=R,this._offsetsBuffer?this._offsetsBuffer.update(R):this._createOffsetsBuffer(R)}get widths(){return this._widths}set widths(R){this._widths=R,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(R)}get colorPointers(){return this._colorPointers}set colorPointers(R){this._colorPointers=R,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(R)}get greasedLineMaterial(){var R,x;if(this.material&&this.material instanceof WR)return this.material;const H=null===(R=this.material)||void 0===R||null===(x=R.pluginManager)||void 0===x?void 0:x.getPlugin(ER.GREASED_LINE_MATERIAL_NAME);return H||void 0}get points(){const R=[];return hR.b.DeepCopy(this._points,R),R}setPoints(R,x){this._points=yR.ConvertPoints(R,(null===x||void 0===x?void 0:x.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==x&&void 0!==x&&x.colorPointers||this._updateColorPointers(),this._setPoints(this._points,x)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(R){super.serialize(R),R.type=this.getClassName(),R.lineOptions=this._createLineOptions()}_createVertexBuffers(){let R=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new wR.d;return x.xa=this._vertexPositions,x.indices=this._indices,x.Aa=this._uvs,R&&(x.ya=[],wR.d.ComputeNormals(this._vertexPositions,this._indices,x.ya)),x.Ca(this,this._options.updatable),x}_createOffsetsBuffer(R){const x=this._scene.getEngine(),H=new V.d(x,R,this._updatable,3);this.setVerticesBuffer(H.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=H}}class vR{constructor(R,x){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=R,this.wasAddedByNoopNode=x}getIndicesAccessor(R,x,H,k,c){var t,A,D,U;return null===(t=this._indicesAccessorMap.get(R))||void 0===t||null===(A=t.get(x))||void 0===A||null===(D=A.get(H))||void 0===D||null===(U=D.get(k))||void 0===U?void 0:U.get(c)}setIndicesAccessor(R,x,H,k,c,t){let A=this._indicesAccessorMap.get(R);A||(A=new Map,this._indicesAccessorMap.set(R,A));let D=A.get(x);D||(D=new Map,A.set(x,D));let U=D.get(H);U||(U=new Map,D.set(H,U));let J=U.get(k);J||(J=new Map,U.set(k,J)),J.set(c,t)}pushExportedNode(R){this._exportedNodes.has(R)||this._exportedNodes.add(R)}getNodesSet(){return this._exportedNodes}getVertexBufferView(R){return this._vertexBufferViewMap.get(R)}setVertexBufferView(R,x){this._vertexBufferViewMap.set(R,x)}setRemappedBufferView(R,x,H){this._remappedBufferView.set(R,new Map),this._remappedBufferView.get(R).set(x,H)}getRemappedBufferView(R,x){var H;return null===(H=this._remappedBufferView.get(R))||void 0===H?void 0:H.get(x)}getVertexAccessor(R,x,H){var k,c;return null===(k=this._vertexAccessorMap.get(R))||void 0===k||null===(c=k.get(x))||void 0===c?void 0:c.get(H)}setVertexAccessor(R,x,H,k){let c=this._vertexAccessorMap.get(R);c||(c=new Map,this._vertexAccessorMap.set(R,c));let t=c.get(x);t||(t=new Map,c.set(x,t)),t.set(H,k)}hasVertexColorAlpha(R){return this._vertexMapColorAlpha.get(R)||!1}setHasVertexColorAlpha(R,x){return this._vertexMapColorAlpha.set(R,x)}getMesh(R){return this._meshMap.get(R)}setMesh(R,x){this._meshMap.set(R,x)}bindMorphDataToMesh(R,x){const H=this._meshMorphTargetMap.get(R)||[];this._meshMorphTargetMap.set(R,H),-1===H.indexOf(x)&&H.push(x)}getMorphTargetsFromMesh(R){return this._meshMorphTargetMap.get(R)}}class pR{_ApplyExtension(R,x,H,k){if(H>=x.length)return Promise.resolve(R);const c=k(x[H],R);return c?c.then((async R=>R?await this._ApplyExtension(R,x,H+1,k):null)):this._ApplyExtension(R,x,H+1,k)}_ApplyExtensions(R,x){const H=[];for(const k of pR._ExtensionNames)H.push(this._extensions[k]);return this._ApplyExtension(R,H,0,x)}_extensionsPreExportTextureAsync(R,x,H){return this._ApplyExtensions(x,((x,k)=>x.preExportTextureAsync&&x.preExportTextureAsync(R,k,H)))}_extensionsPostExportNodeAsync(R,x,H,k,c){return this._ApplyExtensions(x,((x,t)=>x.postExportNodeAsync&&x.postExportNodeAsync(R,t,H,k,c,this._bufferManager)))}_extensionsPostExportMaterialAsync(R,x,H){return this._ApplyExtensions(x,((x,k)=>x.postExportMaterialAsync&&x.postExportMaterialAsync(R,k,H)))}_extensionsPostExportMaterialAdditionalTextures(R,x,H){const k=[];for(const c of pR._ExtensionNames){const t=this._extensions[c];t.postExportMaterialAdditionalTextures&&k.push(...t.postExportMaterialAdditionalTextures(R,x,H))}return k}_extensionsPostExportTextures(R,x,H){for(const k of pR._ExtensionNames){const c=this._extensions[k];c.postExportTexture&&c.postExportTexture(R,x,H)}}_extensionsPostExportMeshPrimitive(R){for(const x of pR._ExtensionNames){const H=this._extensions[x];H.postExportMeshPrimitive&&H.postExportMeshPrimitive(R,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const R of pR._ExtensionNames){const x=this._extensions[R];x.preGenerateBinaryAsync&&await x.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(R){for(const x of pR._ExtensionNames){const H=this._extensions[x];H.enabled&&R(H)}}_extensionsOnExporting(){this._forEachExtensions((R=>{var x,H,k;R.wasUsed&&((x=this._glTF).extensionsUsed||(x.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(R.name)&&this._glTF.extensionsUsed.push(R.name),R.required&&((H=this._glTF).extensionsRequired||(H.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(R.name)&&this._glTF.extensionsRequired.push(R.name)),(k=this._glTF).extensions||(k.extensions={}),R.onExporting&&R.onExporting())}))}_loadExtensions(){for(const R of pR._ExtensionNames){const x=pR._ExtensionFactories[R](this);this._extensions[R]=x}}constructor(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:q.c.LastCreatedScene,x=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${i.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new N(this),this._extensions={},this._bufferManager=new VR,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!R)throw new Error("No scene available to export");this._babylonScene=R,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:R=>{var x;return null===R||void 0===R||null===(x=R.Si)||void 0===x?void 0:x.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...x},this._loadExtensions()}dispose(){for(const R in this._extensions){this._extensions[R].dispose()}}get options(){return this._options}static RegisterExtension(R,x){pR.UnregisterExtension(R)&&c.e.Warn(`Extension with the name ${R} already exists`),pR._ExtensionFactories[R]=x,pR._ExtensionNames.push(R)}static UnregisterExtension(R){if(!pR._ExtensionFactories[R])return!1;delete pR._ExtensionFactories[R];const x=pR._ExtensionNames.indexOf(R);return-1!==x&&pR._ExtensionNames.splice(x,1),!0}_generateJSON(R,x,H){const k={byteLength:R};return k.byteLength&&(this._glTF.buffers=[k]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Yk=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(k.uri=x+".bin"),H?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(R){const x=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(x.byteLength,R,!0),k=new Blob([x],{type:"application/octet-stream"}),c=R+".gltf",t=R+".bin",A=new J;if(A.files[c]=H,A.files[t]=k,this._imageData)for(const D in this._imageData)A.files[D]=new Blob([this._imageData[D].data],{type:this._imageData[D].mimeType});return A}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(R){const x=R%4;return 0===x?x:4-x}async generateGLBAsync(R){this._shouldUseGlb=!0;const x=await this._generateBinaryAsync();this._extensionsOnExporting();const H=this._generateJSON(x.byteLength),k=R+".glb";let c,t=H.length;if("undefined"!==typeof TextEncoder){c=(new TextEncoder).encode(H),t=c.length}const A=this._getPadding(t),D=this._getPadding(x.byteLength),U=28+t+A+x.byteLength+D,V=new UR(U);if(V.writeUInt32(1179937895),V.writeUInt32(2),V.writeUInt32(U),V.writeUInt32(t+A),V.writeUInt32(1313821514),c)V.writeTypedArray(c);else{const R="_".charCodeAt(0);for(let x=0;x<t;++x){const k=H.charCodeAt(x);k!=H.codePointAt(x)?V.writeUInt8(R):V.writeUInt8(k)}}for(let J=0;J<A;++J)V.writeUInt8(32);V.writeUInt32(x.byteLength+D),V.writeUInt32(5130562),V.writeTypedArray(x);for(let J=0;J<D;++J)V.writeUInt8(0);const n=new J;return n.files[k]=new Blob([V.getOutputData()],{type:"application/octet-stream"}),n}_setNodeTransformation(R,x,H){if(x.getPivotPoint().equalsWithEpsilon(T,G.e)||c.e.Warn("Pivot points are not supported in the glTF serializer"),!x.position.equalsWithEpsilon(T,G.e)){const c=k.g.Bi[0].p(x.position);H&&e(c),R.translation=c.Li()}x.ti.equalsWithEpsilon(p,G.e)||(R.scale=x.ti.Li());const t=x.rotationQuaternion||k.f.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);t.equalsWithEpsilon(v,G.e)||(H&&u(t),R.rotation=t.normalize().Li())}_setCameraTransformation(R,x,H){if(!x.position.equalsWithEpsilon(T,G.e)){const c=k.g.Bi[0].p(x.position);H&&e(c),R.translation=c.Li()}const c=x.rotationQuaternion||k.f.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);H&&u(c),this._babylonScene.useRightHandedSystem||Y(c),c.equalsWithEpsilon(v,G.e)||(R.rotation=c.Li())}_listAvailableCameras(){for(const R of this._babylonScene.cameras){const x={type:R.mode===gR.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(R.name&&(x.name=R.name),"perspective"===x.type)x.perspective={aspectRatio:R.getEngine().getAspectRatio(R),yfov:R.fovMode===gR.b.FOVMODE_VERTICAL_FIXED?R.fov:R.fov*R.getEngine().getAspectRatio(R),znear:R.Hi,zfar:R.maxZ};else if("orthographic"===x.type){const H=R.orthoLeft&&R.orthoRight?.5*(R.orthoRight-R.orthoLeft):.5*R.getEngine().getRenderWidth(),k=R.orthoBottom&&R.orthoTop?.5*(R.orthoTop-R.orthoBottom):.5*R.getEngine().getRenderHeight();x.orthographic={xmag:H,ymag:k,znear:R.Hi,zfar:R.maxZ}}this._camerasMap.set(R,x)}}_exportAndAssignCameras(){const R=Array.from(this._camerasMap.values());for(const x of R){const R=this._nodesCameraMap.get(x);if(void 0!==R){this._cameras.push(x);for(const x of R)x.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const R of this._babylonScene.skeletons){if(R.bones.length<=0)continue;const x={joints:[]};this._skinMap.set(R,x)}}_exportAndAssignSkeletons(){for(const R of this._babylonScene.skeletons){if(R.bones.length<=0)continue;const x=this._skinMap.get(R);if(void 0==x)continue;const H={},k=[];let t=-1;for(let c=0;c<R.bones.length;++c){const x=R.bones[c],k=x.getIndex()??c;-1!==k&&(H[k]=x,k>t&&(t=k))}for(let R=0;R<=t;++R){const t=H[R];k.push(t.getAbsoluteInverseBindMatrix());const A=t.getTransformNode();if(null!==A){const R=this._nodeMap.get(A);A&&null!==R&&void 0!==R?x.joints.push(R):c.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}else c.e.Warn("Exporting a bone without a linked transform node is currently unsupported")}const A=this._nodesSkinMap.get(x);if(x.joints.length>0&&void 0!==A){const R=64*k.length,H=new Float32Array(R/4);k.forEach(((R,x)=>{H.set(R.m,16*x)}));const c=this._bufferManager.createBufferView(H);this._accessors.push(this._bufferManager.createAccessor(c,"MAT4",5126,k.length)),x.inverseBindMatrices=this._accessors.length-1,this._skins.push(x);for(const x of A)x.skin=this._skins.length-1}}}async _exportSceneAsync(){const R={nodes:[]};if(this._babylonScene.metadata){const x=this._options.metadataSelector(this._babylonScene.metadata);x&&(R.extras=x)}const x=new Array,H=new Array,k=new Array;for(const D of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&AR(D,this._babylonScene.useRightHandedSystem)?k.push(...D.getChildren()):this._babylonScene.useRightHandedSystem?x.push(D):H.push(D);this._listAvailableCameras(),this._listAvailableSkeletons();const c=new vR(!0,!1);R.nodes.push(...await this._exportNodesAsync(H,c));const t=new vR(!1,!1);R.nodes.push(...await this._exportNodesAsync(x,t));const A=new vR(!1,!0);R.nodes.push(...await this._exportNodesAsync(k,A)),R.nodes.length&&this._scenes.push(R),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&FR._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,c.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(R){let x=this._shouldExportNodeMap.get(R);return void 0===x&&(x=this._options.shouldExportNode(R),this._shouldExportNodeMap.set(R,x)),x}async _exportNodesAsync(R,x){const H=new Array;this._exportBuffers(R,x);for(const k of R)await this._exportNodeAsync(k,H,x);return H}_collectBuffers(R,x,H,k,c){if(this._shouldExportNode(R)&&R instanceof g.b&&R.Ci){const t=R.Ci.getVertexBuffers();if(t)for(const k in t){if(!m(k))continue;const A=t[k];c.setHasVertexColorAlpha(A,R.hasVertexAlpha);const D=A._buffer,U=x.get(D)||[];x.set(D,U),-1===U.indexOf(A)&&U.push(A);const J=H.get(A)||[];H.set(A,J),-1===J.indexOf(R)&&J.push(R)}const A=R.morphTargetManager;if(A)for(let x=0;x<A.numTargets;x++){const H=A.getTarget(x),c=k.get(H)||[];k.set(H,c),-1===c.indexOf(R)&&c.push(R)}}for(const t of R.getChildren())this._collectBuffers(t,x,H,k,c)}_exportBuffers(R,x){const H=new Map,k=new Map,c=new Map;for(const D of R)this._collectBuffers(D,H,k,c,x);const t=Array.from(H.keys());for(const D of t){const R=D.getData();if(!R)throw new Error("Buffer data is not available");const c=H.get(D);if(!c)continue;const t=c[0].byteStride;if(c.some((R=>R.byteStride!==t)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const A=HR(R).slice();for(const x of c){const R=k.get(x),{byteOffset:H,byteStride:c,componentCount:t,type:D,count:U,normalized:J,kind:n}=z(x,R);switch(n){case V.g.NormalKind:case V.g.TangentKind:(0,W.i)(A,H,c,t,D,U,J,(R=>{const x=Math.sqrt(R[0]*R[0]+R[1]*R[1]+R[2]*R[2]);if(x>0){const H=1/x;R[0]*=H,R[1]*=H,R[2]*=H}}));break;case V.g.ColorKind:{const x=R.filter((R=>R.material instanceof qR.d||null==R.material)).length;if(0==x)break;if(x!=R.length){K.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}D==V.g.UNSIGNED_BYTE&&K.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const k=new S.c,n=new S.d,g=this._babylonScene.getEngine().useExactSrgbConversions;(0,W.i)(A,H,c,t,D,U,J,(R=>{3===R.length?(k.bj(R,0),k.toLinearSpaceToRef(k,g),k.toArray(R,0)):(n.bj(R,0),n.toLinearSpaceToRef(n,g),n.toArray(R,0))}))}}}if(x.convertToRightHanded){for(const R of c){const x=k.get(R),{byteOffset:H,byteStride:c,componentCount:t,type:D,count:U,normalized:J,kind:n}=z(R,x);switch(n){case V.g.PositionKind:case V.g.NormalKind:case V.g.TangentKind:(0,W.i)(A,H,c,t,D,U,J,(R=>{R[0]=-R[0]}))}}x.convertedToRightHandedBuffers.set(D,A)}const U=this._bufferManager.createBufferView(A,t);x.setVertexBufferView(D,U);const J=new Map;for(const x of c){const R=k.get(x),{kind:H,totalVertices:c}=z(x,R);switch(H){case V.g.MatricesIndicesKind:case V.g.MatricesIndicesExtraKind:if(x.type==V.g.FLOAT){const R=x.getFloatData(c);null!==R&&J.set(x,R)}}}0!==J.size&&K.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const n=Array.from(J.keys());for(const H of n){const R=J.get(H);if(!R)continue;const k=R.some((R=>R>=256)),c=new(k?Uint16Array:Uint8Array)(R.length);for(let x=0;x<R.length;x++)c[x]=R[x];const t=this._bufferManager.createBufferView(c,4*(k?2:1));x.setRemappedBufferView(D,H,t)}}const A=Array.from(c.keys());for(const D of A){const R=c.get(D);if(!R)continue;const H=dR(D,R[0],this._bufferManager,this._bufferViews,this._accessors,x.convertToRightHanded);for(const k of R)x.bindMorphDataToMesh(k,H)}}async _exportNodeAsync(R,x,H){let k=this._nodeMap.get(R);if(void 0!==k)return void(x.includes(k)||x.push(k));const c=await this._createNodeAsync(R,H);if(c){k=this._nodes.length,this._nodes.push(c),this._nodeMap.set(R,k),H.pushExportedNode(R),x.push(k);const t={name:"runtime animations",channels:[],samplers:[]},A=[];this._babylonScene.animationGroups.length||(FR._CreateMorphTargetAnimationFromMorphTargetAnimations(R,t,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation),R.animations.length&&FR._CreateNodeAnimationFromNodeAnimations(R,t,A,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,H.convertToRightHanded,this._options.shouldExportAnimation)),t.channels.length&&t.samplers.length&&this._animations.push(t),A.forEach((R=>{R.channels.length&&R.samplers.length&&this._animations.push(R)}))}const t=c?[]:x;for(const A of R.getChildren())await this._exportNodeAsync(A,t,H);c&&t.length&&(c.children=t)}async _createNodeAsync(R,x){if(!this._shouldExportNode(R))return null;const H={};if(R.name&&(H.name=R.name),R.metadata){const x=this._options.metadataSelector(R.metadata);x&&(H.extras=x)}if(R instanceof n.e&&(this._setNodeTransformation(H,R,x.convertToRightHanded),R instanceof g.b)){const c=R instanceof I.d?R.sourceMesh:R;if(c.Ii&&c.Ii.length>0&&(H.mesh=await this._exportMeshAsync(c,x)),R.skeleton){const x=this._skinMap.get(R.skeleton);var k;if(void 0!==x)void 0===this._nodesSkinMap.get(x)&&this._nodesSkinMap.set(x,[]),null===(k=this._nodesSkinMap.get(x))||void 0===k||k.push(H)}}if(R instanceof Q.b){const k=this._camerasMap.get(R);if(k){var c;void 0===this._nodesCameraMap.get(k)&&this._nodesCameraMap.set(k,[]),this._setCameraTransformation(H,R,x.convertToRightHanded);const A=R.parent;if(null!==A&&xR(R,A)){const R=this._nodeMap.get(A);if(void 0!==R){var t;const x=this._nodes[R];return RR(H,x),null===(t=this._nodesCameraMap.get(k))||void 0===t||t.push(x),null}}null===(c=this._nodesCameraMap.get(k))||void 0===c||c.push(H)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",H,R,this._nodeMap,x.convertToRightHanded)?H:(K.c.Warn(`Not exporting node ${R.name}`),null)}_exportIndices(R,x,H,k,c,A,D,U,J){let V=R;J.mode=O(A);const n=D!==t.b.CounterClockWiseSideOrientation,g=!U.wasAddedByNoopNode&&n,I=function(R){switch(R){case t.b.TriangleFillMode:case t.b.TriangleStripDrawMode:case t.b.TriangleFanDrawMode:return!0}return!1}(A)&&g;if(I){if(A===t.b.TriangleStripDrawMode||A===t.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");J.mode=O(A);const D=x?new Uint32Array(k):new Uint16Array(k);if(R)for(let x=0;x+2<k;x+=3)D[x]=R[H+x]+c,D[x+1]=R[H+x+2]+c,D[x+2]=R[H+x+1]+c;else for(let R=0;R+2<k;R+=3)D[R]=R,D[R+1]=R+2,D[R+2]=R+1;V=D}else if(R&&0!==c){const t=x?new Uint32Array(k):new Uint16Array(k);for(let x=0;x<k;x++)t[x]=R[H+x]+c;V=t}if(V){let t=U.getIndicesAccessor(R,H,k,c,I);if(void 0===t){const A=function(R,x,H,k){if(R instanceof Uint16Array||R instanceof Uint32Array)return R;if(R instanceof Int32Array)return new Uint32Array(R.buffer,R.byteOffset,R.length);const c=R.slice(x,x+H);return k?new Uint32Array(c):new Uint16Array(c)}(V,0,k,x),D=this._bufferManager.createBufferView(A),J=x?5125:5123;this._accessors.push(this._bufferManager.createAccessor(D,"SCALAR",J,k,0)),t=this._accessors.length-1,U.setIndicesAccessor(R,H,k,c,I,t)}J.indices=t}}_exportVertexBuffer(R,x,H,k,c,t){const A=R.getKind();if(!m(A))return;if(A.startsWith("uv")&&!this._options.exportUnusedUVs&&(!x||!this._materialNeedsUVsSet.has(x)))return;let D=c.getVertexAccessor(R,H,k);if(void 0===D){const x=c.convertedToRightHandedBuffers.get(R._buffer)||R._buffer.getData(),t=A===V.g.PositionKind?function(R,x,H,k){const{byteOffset:c,byteStride:t,type:A,normalized:D}=x,U=x.getSize(),J=new Array(U).fill(1/0),V=new Array(U).fill(-1/0);return(0,W.i)(R,c+H*t,t,U,A,k*U,D,(R=>{for(let x=0;x<U;x++)J[x]=Math.min(J[x],R[x]),V[x]=Math.max(V[x],R[x])})),{min:J,max:V}}(x,R,H,k):void 0,U=(A===V.g.MatricesIndicesKind||A===V.g.MatricesIndicesExtraKind)&&R.type===V.g.FLOAT,J=U?V.g.UNSIGNED_BYTE:R.type,n=U?void 0:R.normalized,g=U?c.getRemappedBufferView(R._buffer,R):c.getVertexBufferView(R._buffer),I=R.byteOffset+H*R.byteStride;this._accessors.push(this._bufferManager.createAccessor(g,function(R,x){if(R==V.g.ColorKind)return x?"VEC4":"VEC3";switch(R){case V.g.PositionKind:case V.g.NormalKind:return"VEC3";case V.g.TangentKind:case V.g.MatricesIndicesKind:case V.g.MatricesIndicesExtraKind:case V.g.MatricesWeightsKind:case V.g.MatricesWeightsExtraKind:return"VEC4";case V.g.UVKind:case V.g.UV2Kind:case V.g.UV3Kind:case V.g.UV4Kind:case V.g.UV5Kind:case V.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${R}`)}(A,c.hasVertexColorAlpha(R)),J,k,I,t,n)),D=this._accessors.length-1,c.setVertexAccessor(R,H,k,D)}t.attributes[function(R){switch(R){case V.g.PositionKind:return"POSITION";case V.g.NormalKind:return"NORMAL";case V.g.TangentKind:return"TANGENT";case V.g.ColorKind:return"COLOR_0";case V.g.UVKind:return"TEXCOORD_0";case V.g.UV2Kind:return"TEXCOORD_1";case V.g.UV3Kind:return"TEXCOORD_2";case V.g.UV4Kind:return"TEXCOORD_3";case V.g.UV5Kind:return"TEXCOORD_4";case V.g.UV6Kind:return"TEXCOORD_5";case V.g.MatricesIndicesKind:return"JOINTS_0";case V.g.MatricesIndicesExtraKind:return"JOINTS_1";case V.g.MatricesWeightsKind:return"WEIGHTS_0";case V.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${R}`)}(A)]=D}async _exportMaterialAsync(R,x,H,k){let c=this._materialMap.get(R);if(void 0===c){const k=x&&Object.keys(x).some((R=>R.startsWith("uv")));if((R=R instanceof IR.e?R.Ni[H.materialIndex]:R)instanceof iR.e)c=await this._materialExporter.exportPBRMaterialAsync(R,"image/png",k);else{if(!(R instanceof qR.d))return void K.c.Warn(`Unsupported material '${R.name}' with type ${R.getClassName()}`);c=await this._materialExporter.exportStandardMaterialAsync(R,"image/png",k)}this._materialMap.set(R,c)}k.material=c}async _exportMeshAsync(R,x){var H;let k=x.getMesh(R);if(void 0!==k)return k;const c={primitives:[]};k=this._meshes.length,this._meshes.push(c),x.setMesh(R,k);const A=R.isUnIndexed?null:R.Gi(),D=null===(H=R.Ci)||void 0===H?void 0:H.getVertexBuffers(),U=x.getMorphTargetsFromMesh(R),J=R instanceof PR.e,V=R instanceof TR,n=R.Ii;if(D&&n&&n.length>0)for(const i of n){const H={attributes:{}},k=i.Ha()||this._babylonScene.defaultMaterial;if(V){var g,I;const x={name:k.name},c=R,t=S.c.White(),A=(null===(g=c.material)||void 0===g?void 0:g.alpha)??1,D=(null===(I=c.greasedLineMaterial)||void 0===I?void 0:I.color)??t;(!D.equalsWithEpsilon(t,G.e)||A<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...D.Li(),A]}),this._materials.push(x),H.material=this._materials.length-1}else if(J){const x={name:k.name},c=R;(!c.color.equalsWithEpsilon(S.c.White(),G.e)||c.alpha<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...c.color.Li(),c.alpha]}),this._materials.push(x),H.material=this._materials.length-1}else await this._exportMaterialAsync(k,D,i,H);const n=J||V?t.b.LineListDrawMode:R.overrideRenderingFillMode??k.fillMode,q=k._getEffectiveOrientation(R);this._exportIndices(A,A?(0,W.c)(A,i.indexCount,i.indexStart,i.verticesStart):i.verticesCount>65535,A?i.indexStart:i.verticesStart,A?i.indexCount:i.verticesCount,-i.verticesStart,n,q,x,H);for(const R of Object.values(D))this._exportVertexBuffer(R,k,i.verticesStart,i.verticesCount,x,H);if(U){H.targets=[];for(const R of U)H.targets.push(R.attributes)}c.primitives.push(H),this._extensionsPostExportMeshPrimitive(H)}if(U){c.weights=[],c.extras||(c.extras={}),c.extras.targetNames=[];for(const R of U)c.weights.push(R.influence),c.extras.targetNames.push(R.name)}return k}}pR._ExtensionNames=new Array,pR._ExtensionFactories={};class rR{static async GLTFAsync(R,x,H){H&&H.exportWithoutWaitingForScene||await R.whenReadyAsync();const k=new pR(R,H),c=await k.generateGLTFAsync(x.replace(/\.[^/.]+$/,""));return k.dispose(),c}static async GLBAsync(R,x,H){H&&H.exportWithoutWaitingForScene||await R.whenReadyAsync();const k=new pR(R,H),c=await k.generateGLBAsync(x.replace(/\.[^/.]+$/,""));return k.dispose(),c}}H(465);const zR="EXT_mesh_gpu_instancing";class jR{constructor(R){this.name=zR,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(R,x,H,c,t,A){return await new Promise((R=>{if(x&&H instanceof bR.d&&H.hasThinInstances&&this._exporter){this._wasUsed=!0;const R=k.o.Zero(),c=k.f.Identity(),D=k.o.One(),U=H.thinInstanceGetWorldMatrices(),J=k.g.Bi[2],V=k.g.Quaternion[1],n=k.g.Bi[3];let g=!1,I=!1,i=!1;const q=new Float32Array(3*H.wi),S=new Float32Array(4*H.wi),L=new Float32Array(3*H.wi);let b=0;for(const x of U)x.decompose(n,V,J),t&&(e(J),u(V)),q.set(J.Li(),3*b),S.set(V.normalize().Li(),4*b),L.set(n.Li(),3*b),g=g||!J.equalsWithEpsilon(R),I=I||!V.equalsWithEpsilon(c),i=i||!n.equalsWithEpsilon(D),b++;const C={attributes:{}};g&&(C.attributes.TRANSLATION=this._buildAccessor(q,"VEC3",H.wi,A)),I&&(C.attributes.ROTATION=this._buildAccessor(S,"VEC4",H.wi,A)),i&&(C.attributes.SCALE=this._buildAccessor(L,"VEC3",H.wi,A)),x.extensions=x.extensions||{},x.extensions[zR]=C}R(x)}))}_buildAccessor(R,x,H,k){const c=k.createBufferView(R),t=k.createAccessor(c,x,5126,H);return this._exporter._accessors.push(t),this._exporter._accessors.length-1}}pR.RegisterExtension(zR,(R=>new jR(R)));var mR=H(12380),OR=H(12385),lR=H(12391),eR=H(12393);function uR(R){return R===lR.e.PositionKind?"POSITION":R===lR.e.NormalKind?"NORMAL":R===lR.e.ColorKind?"COLOR":R.startsWith(lR.e.UVKind)?"TEX_COORD":"GENERIC"}const YR={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Rx extends mR.b{static get DefaultAvailable(){return(0,mR.g)(Rx.DefaultConfiguration)}static get Default(){return Rx._Default??(Rx._Default=new Rx),Rx._Default}static ResetDefault(R){Rx._Default&&(R||Rx._Default.dispose(),Rx._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(R,x){return{module:await(x||DracoEncoderModule)({wasmBinary:R})}}_getWorkerContent(){return`${OR.j}(${OR.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Rx.DefaultConfiguration)}async _encodeAsync(R,x,H){const k=H?(0,eR.e)(YR,H):YR;if(this._workerPoolPromise){const H=await this._workerPoolPromise;return await new Promise(((c,t)=>{H.push(((H,A)=>{const D=R=>{H.removeEventListener("error",D),H.removeEventListener("message",U),t(R),A()},U=R=>{"encodeMeshDone"===R.data.id&&(H.removeEventListener("error",D),H.removeEventListener("message",U),c(R.data.encodedMeshData),A())};H.addEventListener("error",D),H.addEventListener("message",U);const J=[];for(const x of R)J.push(x.data.buffer);x&&J.push(x.buffer),H.postMessage({id:"encodeMesh",attributes:R,indices:x,options:k},J)}))}))}if(this._modulePromise){const H=await this._modulePromise;return(0,OR.j)(H.module,R,x,k)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(R,x){if(0==R.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");R instanceof bR.d&&R.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===x||void 0===x?void 0:x.method)&&(K.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),x.method="MESH_SEQUENTIAL_ENCODING");const H=function(R){let x=R.Gi(void 0,!0);return!x||x instanceof Uint32Array||x instanceof Uint16Array||(x=((0,W.c)(x,x.length)?Uint32Array:Uint16Array).from(x)),x}(R),k=function(R,x){const H=[];for(const k of R.getVerticesDataKinds()){if(null!==x&&void 0!==x&&x.includes(k)){if(k===lR.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const c=R.getVertexBuffer(k),t=c.getSize(),A=(0,W.p)(c.getData(),t,c.type,c.byteOffset,c.byteStride,c.normalized,R.getTotalVertices(),!0);H.push({kind:k,dracoName:uR(k),size:t,data:A})}return H}(R,null===x||void 0===x?void 0:x.excludedAttributes);return await this._encodeAsync(k,H,x)}}Rx.DefaultConfiguration={wasmUrl:`${c.e._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${c.e._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${c.e._DefaultCdnUrl}/draco_encoder.js`},Rx._Default=null;const xx="KHR_draco_mesh_compression";class Hx{get wasUsed(){return this._wasUsed}constructor(R){this.name=xx,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===R.options.meshCompressionMethod&&Rx.DefaultAvailable}dispose(){}postExportMeshPrimitive(R,x,H){if(!this.enabled)return;if(4!==R.mode&&5!==R.mode)return void K.c.Warn("Cannot compress primitive with mode "+R.mode+".");const k=[],c=[];let t=null;if(void 0!==R.indices){const A=H[R.indices],D=x.getBufferView(A);t=x.getData(D).slice(),k.push(D),c.push(A)}const A=[];for(const[V,n]of Object.entries(R.attributes)){const R=H[n],t=x.getBufferView(R),U=j(R.type),J=(0,W.p)(x.getData(t),U,R.componentType,R.byteOffset||0,t.byteStride||(0,W.k)(R.componentType)*U,R.normalized||!1,R.count,!0);A.push({kind:V,dracoName:(D=V,"POSITION"===D?"POSITION":"NORMAL"===D?"NORMAL":D.startsWith("COLOR")?"COLOR":D.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:j(R.type),data:J}),k.push(t),c.push(R)}var D;const U={method:R.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},J=Rx.Default._encodeAsync(A,t,U).then((H=>{if(!H)return void K.c.Error("Draco encoding failed for primitive.");const t={bufferView:-1,attributes:H.attributeIds},A=x.createBufferView(H.data);x.setBufferView(t,A);for(const R of k)this._bufferViewsUsed.add(R);for(const R of c)this._accessorsUsed.add(R);R.extensions||(R.extensions={}),R.extensions[xx]=t})).catch((R=>{K.c.Error("Draco encoding failed for primitive: "+R)}));this._encodePromises.push(J),this._wasUsed=!0}async preGenerateBinaryAsync(R){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((x=>{R.getPropertiesWithBufferView(x).every((R=>this._accessorsUsed.has(R)))&&R.removeBufferView(x)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}pR.RegisterExtension(xx,(R=>new Hx(R)));var kx=H(12395);const cx="KHR_lights_punctual",tx={name:"",color:[1,1,1],bb:1,range:Number.MAX_VALUE},Ax={innerConeAngle:0,outerConeAngle:Math.PI/4},Dx=k.o.Backward();class Ux{constructor(R){this.name=cx,this.enabled=!0,this.required=!1,this._exporter=R}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[cx]=this._lights}async postExportNodeAsync(R,x,H,c,t){return await new Promise((A=>{if(!(H instanceof CR.b))return void A(x);const D=H.getTypeID()==CR.b.LIGHTTYPEID_POINTLIGHT?"point":H.getTypeID()==CR.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":H.getTypeID()==CR.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!D||!(H instanceof kx.e))return K.c.Warn(`${R}: Light ${H.name} is not supported in ${cx}`),void A(x);if(H.falloffType!==CR.b.FALLOFF_GLTF&&K.c.Warn(`${R}: Light falloff for ${H.name} does not match the ${cx} specification!`),!H.position.equalsToFloats(0,0,0)){const R=k.g.Bi[0].p(H.position);t&&e(R),x.translation=R.Li()}if("point"!==D){const R=H.direction.normalizeToRef(k.g.Bi[0]);t&&e(R);const c=k.f.FromUnitVectorsToRef(Dx,R,k.g.Quaternion[0]);k.f.IsIdentity(c)||(x.rotation=c.Li())}const U={type:D,name:H.name,color:H.cb.Li(),bb:H.bb,range:H.range};if(kR(U,tx),"spot"===D){const R=H;U.spot={innerConeAngle:R.innerAngle/2,outerConeAngle:R.angle/2},kR(U.spot,Ax)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(U);const J={ab:this._lights.lights.length-1},V=H.parent;if(V&&xR(H,V)){const R=c.get(V);if(R){const H=this._exporter._nodes[R];return RR(x,H),H.extensions||(H.extensions={}),H.extensions[cx]=J,void A(null)}}x.extensions||(x.extensions={}),x.extensions[cx]=J,A(x)}))}}pR.RegisterExtension(cx,(R=>new Ux(R)));var Jx=H(12268);const Vx="KHR_materials_anisotropy";class nx{constructor(R){this.name=Vx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof Jx.b&&H.anisotropy.isEnabled&&!H.anisotropy.legacy?(H.anisotropy.texture&&k.push(H.anisotropy.texture),k):[]}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof Jx.b){if(!H.anisotropy.isEnabled||H.anisotropy.legacy)return void R(x);this._wasUsed=!0,x.extensions=x.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(H.anisotropy.texture),c={anisotropyStrength:H.anisotropy.bb,anisotropyRotation:H.anisotropy.angle,anisotropyTexture:k??void 0};null!==c.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(H),x.extensions[Vx]=c}R(x)}))}}pR.RegisterExtension(Vx,(R=>new nx(R)));const gx="KHR_materials_clearcoat";class Ix{constructor(R){this.name=gx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof Jx.b&&H.clearCoat.isEnabled?(H.clearCoat.texture&&k.push(H.clearCoat.texture),!H.clearCoat.useRoughnessFromMainTexture&&H.clearCoat.textureRoughness&&k.push(H.clearCoat.textureRoughness),H.clearCoat.bumpTexture&&k.push(H.clearCoat.bumpTexture),k):[]}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof Jx.b){if(!H.clearCoat.isEnabled)return void R(x);this._wasUsed=!0,x.extensions=x.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture);let t;t=H.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(H.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(H.clearCoat.textureRoughness),H.clearCoat.isTintEnabled&&c.e.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${H.name}`),H.clearCoat.remapF0OnInterfaceChange&&c.e.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${H.name}`);const A=this._exporter._materialExporter.getTextureInfo(H.clearCoat.bumpTexture),D={clearcoatFactor:H.clearCoat.bb,clearcoatTexture:k??void 0,clearcoatRoughnessFactor:H.clearCoat.roughness,clearcoatRoughnessTexture:t??void 0,clearcoatNormalTexture:A??void 0};null===D.clearcoatTexture&&null===D.clearcoatRoughnessTexture&&null===D.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),x.extensions[gx]=D}R(x)}))}}pR.RegisterExtension(gx,(R=>new Ix(R)));const ix="KHR_materials_diffuse_transmission";function qx(R,x){const H=x.subSurface;let k=null;return H.translucencyIntensityTexture?k=H.translucencyIntensityTexture:H.thicknessTexture&&H.useMaskFromThicknessTexture&&(k=H.thicknessTexture),k&&!H.useGltfStyleTextures?(K.c.Warn(`${R}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${x.name}`,1),null):k}class Sx{constructor(R){this.name=ix,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];if(H instanceof iR.e&&this._isExtensionEnabled(H)){const x=qx(R,H);return x&&k.push(x),H.subSurface.translucencyColorTexture&&k.push(H.subSurface.translucencyColorTexture),k}return k}_isExtensionEnabled(R){if(R.unlit)return!1;const x=R.subSurface;return!!x.isTranslucencyEnabled&&(!R.unlit&&!x.useAlbedoToTintTranslucency&&x.useGltfStyleTextures&&1===x.volumeIndexOfRefraction&&0===x.minimumThickness&&0===x.maximumThickness)}postExportMaterialAsync(R,x,H){return new Promise((k=>{if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const k=H.subSurface,c=qx(R,H),t=0==k.translucencyIntensity?void 0:k.translucencyIntensity,A=this._exporter._materialExporter.getTextureInfo(c)??void 0,D=!k.translucencyColor||k.translucencyColor.equalsFloats(1,1,1)?void 0:k.translucencyColor.Li(),U=this._exporter._materialExporter.getTextureInfo(k.translucencyColorTexture)??void 0,J={diffuseTransmissionFactor:t,diffuseTransmissionTexture:A,diffuseTransmissionColorFactor:D,diffuseTransmissionColorTexture:U};(A||U)&&this._exporter._materialNeedsUVsSet.add(H),x.extensions=x.extensions||{},x.extensions[ix]=J}k(x)}))}}pR.RegisterExtension(ix,(R=>new Sx(R)));const Lx="KHR_materials_dispersion";class bx{constructor(){this.name=Lx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(R){if(R.unlit)return!1;const x=R.subSurface;return!(!x.isRefractionEnabled&&!x.isDispersionEnabled)}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const R={dispersion:H.subSurface.dispersion};x.extensions=x.extensions||{},x.extensions[Lx]=R}R(x)}))}}pR.RegisterExtension(Lx,(()=>new bx));const Cx="KHR_materials_emissive_strength";class Fx{constructor(){this.name=Cx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(R,x,H){return await new Promise((R=>{if(!(H instanceof iR.e))return R(x);const k=H.emissiveColor.Li(),c=Math.max(...k);if(c>1){this._wasUsed=!0,x.extensions||(x.extensions={});const R={emissiveStrength:c},k=H.emissiveColor.scale(1/R.emissiveStrength);x.emissiveFactor=k.Li(),x.extensions[Cx]=R}return R(x)}))}}pR.RegisterExtension(Cx,(R=>new Fx));const dx="KHR_materials_ior";class Px{constructor(){this.name=dx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(R){return!R.unlit&&(void 0!=R.indexOfRefraction&&1.5!=R.indexOfRefraction)}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const R={ior:H.indexOfRefraction};x.extensions=x.extensions||{},x.extensions[dx]=R}R(x)}))}}pR.RegisterExtension(dx,(R=>new Px));const ax="KHR_materials_iridescence";class Xx{constructor(R){this.name=ax,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof Jx.b&&H.iridescence.isEnabled?(H.iridescence.texture&&k.push(H.iridescence.texture),H.iridescence.thicknessTexture&&H.iridescence.thicknessTexture!==H.iridescence.texture&&k.push(H.iridescence.thicknessTexture),k):[]}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof Jx.b){if(!H.iridescence.isEnabled)return void R(x);this._wasUsed=!0,x.extensions=x.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(H.iridescence.texture),c=this._exporter._materialExporter.getTextureInfo(H.iridescence.thicknessTexture),t={iridescenceFactor:H.iridescence.bb,iridescenceIor:H.iridescence.indexOfRefraction,iridescenceThicknessMinimum:H.iridescence.minimumThickness,iridescenceThicknessMaximum:H.iridescence.maximumThickness,iridescenceTexture:k??void 0,iridescenceThicknessTexture:c??void 0};null===t.iridescenceTexture&&null===t.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(H),x.extensions[ax]=t}R(x)}))}}pR.RegisterExtension(ax,(R=>new Xx(R)));const Mx="KHR_materials_sheen";class Bx{constructor(R){this.name=Mx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){return H instanceof iR.e&&H.sheen.isEnabled&&H.sheen.texture?[H.sheen.texture]:[]}async postExportMaterialAsync(R,x,H){return await new Promise((R=>{if(H instanceof iR.e){if(!H.sheen.isEnabled)return void R(x);this._wasUsed=!0,null==x.extensions&&(x.extensions={});const k={sheenColorFactor:H.sheen.color.Li(),sheenRoughnessFactor:H.sheen.roughness??0};null===k.sheenColorTexture&&null===k.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(H),H.sheen.texture&&(k.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),H.sheen.textureRoughness&&!H.sheen.useRoughnessFromMainTexture?k.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.textureRoughness)??void 0:H.sheen.texture&&H.sheen.useRoughnessFromMainTexture&&(k.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(H.sheen.texture)??void 0),x.extensions[Mx]=k}R(x)}))}}pR.RegisterExtension(Mx,(R=>new Bx(R)));const ox="KHR_materials_specular";class Zx{constructor(R){this.name=ox,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof iR.e&&this._isExtensionEnabled(H)?(H.metallicReflectanceTexture&&k.push(H.metallicReflectanceTexture),H.reflectanceTexture&&k.push(H.reflectanceTexture),k):k}_isExtensionEnabled(R){return!R.unlit&&(void 0!=R.metallicF0Factor&&1!=R.metallicF0Factor||void 0!=R.metallicReflectanceColor&&!R.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(R))}_hasTexturesExtension(R){return null!=R.metallicReflectanceTexture||null!=R.reflectanceTexture}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0,x.extensions=x.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(H.metallicReflectanceTexture)??void 0,k=this._exporter._materialExporter.getTextureInfo(H.reflectanceTexture)??void 0,c={specularFactor:1==H.metallicF0Factor?void 0:H.metallicF0Factor,specularTexture:R,specularColorFactor:H.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:H.metallicReflectanceColor.Li(),specularColorTexture:k};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),x.extensions[ox]=c}R(x)}))}}pR.RegisterExtension(ox,(R=>new Zx(R)));const yx="KHR_materials_transmission";class sx{constructor(R){this.name=yx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof iR.e&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&k.push(H.subSurface.thicknessTexture),k):k}_isExtensionEnabled(R){if(R.unlit)return!1;const x=R.subSurface;return x.isRefractionEnabled&&void 0!=x.refractionIntensity&&0!=x.refractionIntensity||this._hasTexturesExtension(R)}_hasTexturesExtension(R){return null!=R.subSurface.refractionIntensityTexture}async postExportMaterialAsync(R,x,H){if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const k=H.subSurface,c={transmissionFactor:0===k.refractionIntensity?void 0:k.refractionIntensity};if(this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),k.refractionIntensityTexture)if(k.useGltfStyleTextures){const R=await this._exporter._materialExporter.exportTextureAsync(k.refractionIntensityTexture,"image/png");R&&(c.transmissionTexture=R)}else K.c.Warn(`${R}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);x.extensions||(x.extensions={}),x.extensions[yx]=c}return x}}pR.RegisterExtension(yx,(R=>new sx(R)));const Ex="KHR_materials_unlit";class wx{constructor(){this.name=Ex,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(R,x,H){return new Promise((R=>{let k=!1;H instanceof iR.e?k=H.unlit:H instanceof qR.d&&(k=H.disableLighting),k&&(this._wasUsed=!0,null==x.extensions&&(x.extensions={}),x.extensions[Ex]={}),R(x)}))}}pR.RegisterExtension(Ex,(()=>new wx));const hx="KHR_materials_volume";class fx{constructor(R){this.name=hx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof iR.e&&this._isExtensionEnabled(H)?(H.subSurface.thicknessTexture&&k.push(H.subSurface.thicknessTexture),k):k}_isExtensionEnabled(R){if(R.unlit)return!1;const x=R.subSurface;return!(!x.isRefractionEnabled&&!x.isTranslucencyEnabled)&&(void 0!=x.maximumThickness&&0!=x.maximumThickness||void 0!=x.tintColorAtDistance&&x.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=x.tintColor&&x.tintColor!=S.c.White()||this._hasTexturesExtension(R))}_hasTexturesExtension(R){return null!=R.subSurface.thicknessTexture}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof iR.e&&this._isExtensionEnabled(H)){this._wasUsed=!0;const R=H.subSurface,k={thicknessFactor:0==R.maximumThickness?void 0:R.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(R.thicknessTexture)??void 0,attenuationDistance:R.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:R.tintColorAtDistance,attenuationColor:R.tintColor.equalsFloats(1,1,1)?void 0:R.tintColor.Li()};this._hasTexturesExtension(H)&&this._exporter._materialNeedsUVsSet.add(H),x.extensions=x.extensions||{},x.extensions[hx]=k}R(x)}))}}pR.RegisterExtension(hx,(R=>new fx(R)));const Nx="EXT_materials_diffuse_roughness";class Wx{constructor(R){this.name=Nx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=R}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(R,x,H){const k=[];return H instanceof Jx.b&&H._baseDiffuseRoughness?(H._baseDiffuseRoughnessTexture&&k.push(H._baseDiffuseRoughnessTexture),k):[]}postExportMaterialAsync(R,x,H){return new Promise((R=>{if(H instanceof Jx.b){if(!H._baseDiffuseRoughness)return void R(x);this._wasUsed=!0,x.extensions=x.extensions||{};const k=this._exporter._materialExporter.getTextureInfo(H._baseDiffuseRoughnessTexture),c={diffuseRoughnessFactor:H._baseDiffuseRoughness,diffuseRoughnessTexture:k??void 0};null!==c.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(H),x.extensions[Nx]=c}R(x)}))}}pR.RegisterExtension(Nx,(R=>new Wx(R)));const Kx="KHR_texture_transform";class Qx{constructor(){this.name=Kx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(R,x,H){if(H.va()||c.e.Warn(`${R}: /*@__KEY__*/"scene" is not defined for Babylon texture ${H.name}!`),(0!==H.uAng||0!==H.vAng)&&(c.e.Warn(`${R}: Texture ${H.name} with rotation in the u or v axis is not supported in glTF.`),0!==H.uRotationCenter||0!==H.vRotationCenter))return;const k={};let t=!1;if(0===H.uOffset&&0===H.vOffset||(k.offset=[H.uOffset,H.vOffset],t=!0),1===H.uScale&&1===H.vScale||(k.scale=[H.uScale,H.vScale],t=!0),0!==H.wAng){if(0!==H.uRotationCenter||0!==H.vRotationCenter){if(H.homogeneousRotationInUVTransform&&H.uScale!==H.vScale)return void c.e.Warn(`${R}: Texture ${H.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Kx}.`);c.e.Warn(`${R}: Texture ${H.name} with non-origin rotation center will be exported using an adjusted offset with ${Kx}.`),k.offset=function(R){const{uOffset:x,vOffset:H,uRotationCenter:k,vRotationCenter:c,uScale:t,vScale:A,wAng:D}=R,U=Math.cos(D),J=Math.sin(D),V=k*t,n=c*A;return[x+(V*(1-U)+n*J),H+(n*(1-U)-V*J)]}(H)}k.rotation=-H.wAng,t=!0}0!==H.coordinatesIndex&&(k.texCoord=H.coordinatesIndex,t=!0),t&&(this._wasUsed=!0,x.extensions||(x.extensions={}),x.extensions[Kx]=k)}}pR.RegisterExtension(Kx,(()=>new Qx));class Gx{static CreateSTL(R){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",c=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],A=arguments.length>5&&void 0!==arguments[5]&&arguments[5],D=arguments.length>6&&void 0!==arguments[6]&&arguments[6],U=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const J=function(R,x,H){const c=[3*R[H],3*R[H+1],3*R[H+2]],t=[new k.o(x[c[0]],x[c[0]+2],x[c[0]+1]),new k.o(x[c[1]],x[c[1]+2],x[c[1]+1]),new k.o(x[c[2]],x[c[2]+2],x[c[2]+1])],A=t[0].Pg(t[1]),D=t[2].Pg(t[1]);return{v:t,n:k.o.Cross(D,A).normalize()}},n=function(R,x,H,k){return x=g(R,x,H.x,k),x=g(R,x,H.y,k),g(R,x,H.z,k)},g=function(R,x,H,k){return R.setFloat32(x,H,k),x+4},i=function(R){if(D){let x=R;R instanceof I.d&&(x=R.sourceMesh);const H=x.getVerticesData(V.g.PositionKind,!0,!0);if(!H)return[];const c=k.o.Zero();let t;for(t=0;t<H.length;t+=3)k.o.TransformCoordinatesFromFloatsToRef(H[t],H[t+1],H[t+2],R.Fi(!0),c).toArray(H,t);return H}return R.getVerticesData(V.g.PositionKind)||[]};D&&(A=!0);let q="",S=0,L=0;if(c){for(let H=0;H<R.length;H++){const x=R[H].Gi();S+=x?x.length/3:0}const x=new ArrayBuffer(84+50*S);q=new DataView(x),L+=80,q.setUint32(L,S,t),L+=4}else U||(q="solid stlmesh\r\n");for(let k=0;k<R.length;k++){const x=R[k];!c&&U&&(q+="solid "+x.name+"\r\n"),!A&&x instanceof bR.d&&x.bakeCurrentTransformIntoVertices();const H=i(x),D=x.Gi()||[];for(let R=0;R<D.length;R+=3){const x=J(D,H,R);c?(L=n(q,L,x.n,t),L=n(q,L,x.v[0],t),L=n(q,L,x.v[1],t),L=n(q,L,x.v[2],t),L+=2):(q+="\tfacet normal "+x.n.x+" "+x.n.y+" "+x.n.z+"\r\n",q+="\t\touter loop\r\n",q+="\t\t\tvertex "+x.v[0].x+" "+x.v[0].y+" "+x.v[0].z+"\r\n",q+="\t\t\tvertex "+x.v[1].x+" "+x.v[1].y+" "+x.v[1].z+"\r\n",q+="\t\t\tvertex "+x.v[2].x+" "+x.v[2].y+" "+x.v[2].z+"\r\n",q+="\t\tendloop\r\n",q+="\tendfacet\r\n")}!c&&U&&(q+="endsolid "+name+"\r\n")}if(c||U||(q+="endsolid stlmesh"),x){const R=document.createElement("a"),x=new Blob([q],{type:"application/octet-stream"});R.href=window.URL.createObjectURL(x),R.download=H+".stl",R.click()}return q}}function Tx(R,x){let H=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const k=[];for(let c=0;c<R.length/H;c++){const t=R[c*H],A=R[c*H+1],D=R[c*H+2];k.push(`(${t.toPrecision(x.precision)}, ${A.toPrecision(x.precision)}, ${D.toPrecision(x.precision)})`)}return k.join(", ")}function vx(R,x){const H=[];for(let k=0;k<R.length/2;k++){const c=R[2*k],t=R[2*k+1];H.push(`(${c.toPrecision(x.precision)}, ${(1-t).toPrecision(x.precision)})`)}return H.join(", ")}function px(R,x){const H=R.getVerticesData(V.g.PositionKind),k=R.getVerticesData(V.g.NormalKind);if(H&&k)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(R){var x;const H=null!==(x=R.Gi())&&void 0!==x&&x.length?R.getTotalIndices():R.getTotalVertices();return Array(H/3).fill(3).join(", ")}(R)}]\n\t\tint[] faceVertexIndices = [${function(R){const x=R.Gi(),H=[];if(null!==x)for(let k=0;k<x.length;k++)H.push(x[k]);else{const x=R.getTotalVertices();for(let R=0;R<x;R++)H.push(R)}return H.join(", ")}(R)}]\n\t\tnormal3f[] normals = [${Tx(k,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Tx(H,x)}]\n        ${function(R,x){let H="";for(let c=0;c<4;c++){const k=c>0?c:"",t=R.getVerticesData(V.g.UVKind+(k?k+1:""));t&&(H+=`\n\t\ttexCoord2f[] primvars:st${k} = [${vx(t,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const k=R.getVerticesData(V.g.ColorKind);return k&&(H+=`\n\tcolor3f[] primvars:displayColor = [${Tx(k,x,k.length/R.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),H}(R,x)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function rx(R,x){return`\n        def "Geometry"\n        {\n        ${px(R,x)}\n        }\n        `}function zx(R){let x='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return x+=R,fflate.strToU8(x)}function jx(R){const x=R.m;return`( ${mx(x,0)}, ${mx(x,4)}, ${mx(x,8)}, ${mx(x,12)} )`}function mx(R,x){return`(${R[x+0]}, ${R[x+1]}, ${R[x+2]}, ${R[x+3]})`}function Ox(R){const x="Object_"+R.uniqueId,H=function(R){const x=R.getWorldMatrix().clone(),H=R.va().useRightHandedSystem;if(!H){let k=R.parent;for(;k;){if(AR(k,H)){x.multiplyToRef(k.getWorldMatrix().invert(),x);break}k=k.parent}}return x.determinant()<0&&c.e.Warn(`Exporting mesh ${R.name} with negative scale. Result may look incorrect in destination engine.`),x}(R),k=jx(H);return`def Xform "${x}" (\n\tprepend references = @./geometries/Geometry_${R.Ci.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${k}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${R.material.uniqueId}>\n}\n\n`}function lx(R){switch(R){case a.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case a.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case a.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ex(R){return`(${R.x}, ${R.y})`}function ux(R){return`(${R.r}, ${R.g}, ${R.b})`}function Yx(R,x,H,c,t,A){const D=R.getInternalTexture().uniqueId+"_"+R.invertY;t[D]=R;const U=R.coordinatesIndex>0?"st"+R.coordinatesIndex:"st",J=new k.k(R.uScale,R.vScale),V=new k.k(R.uOffset,R.vOffset),n=R.wAng,g=Math.sin(n),I=Math.cos(n);return V.y=1-V.y-J.y,V.x+=g*J.x,V.y+=(1-I)*J.y,`\n    def Shader "PrimvarReader_${H}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${U}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${H}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${x.uniqueId}/PrimvarReader_${H}.outputs:result>\n        float inputs:rotation = ${(n*(180/Math.PI)).toFixed(A.precision)}\n        float2 inputs:scale = ${ex(J)}\n        float2 inputs:translation = ${ex(V)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${R.uniqueId}_${H}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${D}.png@\n        float2 inputs:st.connect = </Materials/Material_${x.uniqueId}/Transform2d_${H}.outputs:result>\n        ${c?"float4 inputs:scale = "+function(R){return`(${R.r}, ${R.g}, ${R.b}, 1.0)`}(c):""}\n        token inputs:sourceColorSpace = "${R.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${lx(R.wrapU)}"\n        token inputs:wrapT = "${lx(R.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${x.needAlphaBlending()?"float outputs:a":""}\n    }`}function RH(R,x,H){const k="\t\t\t",c=[],t=[],{diffuseMap:A,cb:D,alphaCutOff:U,emissiveMap:J,emissive:V,normalMap:n,roughnessMap:g,roughnessChannel:I,roughness:i,metalnessMap:q,metalnessChannel:L,metalness:b,aoMap:C,aoMapChannel:F,aoMapIntensity:d,alphaMap:P,ior:a,clearCoatEnabled:X,clearCoat:M,clearCoatMap:B,clearCoatRoughness:o,clearCoatRoughnessMap:Z}=function(R){const x={diffuseMap:null,cb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return R instanceof qR.d?{...x,diffuseMap:R.diffuseTexture,cb:R.diffuseColor,alphaCutOff:R.alphaCutOff,emissiveMap:R.emissiveTexture,emissive:R.emissiveColor,roughness:1,alphaMap:R.opacityTexture}:R instanceof Jx.b?{...x,diffuseMap:R._albedoTexture,cb:R._albedoColor,alphaCutOff:R._alphaCutOff,emissiveMap:R._emissiveTexture,emissive:R._emissiveColor,normalMap:R._bumpTexture,roughnessMap:R._metallicTexture,roughnessChannel:R._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:R._roughness??1,metalnessMap:R._metallicTexture,metalnessChannel:R._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:R._metallic??0,aoMap:R._ambientTexture,aoMapChannel:R._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:R._ambientTextureStrength,alphaMap:R._opacityTexture,ior:R.subSurface.indexOfRefraction,clearCoatEnabled:R.clearCoat.isEnabled,clearCoat:R.clearCoat.bb,clearCoatMap:R.clearCoat.texture,clearCoatRoughness:R.clearCoat.roughness,clearCoatRoughnessMap:R.clearCoat.useRoughnessFromMainTexture?R.clearCoat.texture:R.clearCoat.textureRoughness}:x}(R);return null!==A?(c.push(`${k}color3f inputs:diffuseColor.connect = </Materials/Material_${R.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:rgb>`),R.needAlphaBlending()?c.push(`${k}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`):R.needAlphaTesting()&&(c.push(`${k}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${A.uniqueId}_diffuse.outputs:a>`),c.push(`${k}float inputs:opacityThreshold = ${U}`)),t.push(Yx(A,R,"diffuse",D,x,H))):c.push(`${k}color3f inputs:diffuseColor = ${ux(D||S.c.White())}`),null!==J?(c.push(`${k}color3f inputs:emissiveColor.connect = </Materials/Material_${R.uniqueId}/Texture_${J.uniqueId}_emissive.outputs:rgb>`),t.push(Yx(J,R,"emissive",V,x,H))):V&&V.toLuminance()>0&&c.push(`${k}color3f inputs:emissiveColor = ${ux(V)}`),null!==n&&(c.push(`${k}normal3f inputs:normal.connect = </Materials/Material_${R.uniqueId}/Texture_${n.uniqueId}_normal.outputs:rgb>`),t.push(Yx(n,R,"dj",null,x,H))),null!==C&&(c.push(`${k}float inputs:occlusion.connect = </Materials/Material_${R.uniqueId}/Texture_${C.uniqueId}_occlusion.outputs:${F}>`),t.push(Yx(C,R,"occlusion",new S.c(d,d,d),x,H))),null!==g?(c.push(`${k}float inputs:roughness.connect = </Materials/Material_${R.uniqueId}/Texture_${g.uniqueId}_roughness.outputs:${I}>`),t.push(Yx(g,R,"roughness",new S.c(i,i,i),x,H))):c.push(`${k}float inputs:roughness = ${i}`),null!==q?(c.push(`${k}float inputs:metallic.connect = </Materials/Material_${R.uniqueId}/Texture_${q.uniqueId}_metallic.outputs:${L}>`),t.push(Yx(q,R,"metallic",new S.c(b,b,b),x,H))):c.push(`${k}float inputs:metallic = ${b}`),null!==P?(c.push(`${k}float inputs:opacity.connect = </Materials/Material_${R.uniqueId}/Texture_${P.uniqueId}_opacity.outputs:r>`),c.push(`${k}float inputs:opacityThreshold = 0.0001`),t.push(Yx(P,R,"opacity",null,x,H))):c.push(`${k}float inputs:opacity = ${R.alpha}`),X&&(null!==B?(c.push(`${k}float inputs:clearcoat.connect = </Materials/Material_${R.uniqueId}/Texture_${B.uniqueId}_clearcoat.outputs:r>`),t.push(Yx(B,R,"clearcoat",new S.c(M,M,M),x,H))):c.push(`${k}float inputs:clearcoat = ${M}`),null!==Z?(c.push(`${k}float inputs:clearcoatRoughness.connect = </Materials/Material_${R.uniqueId}/Texture_${Z.uniqueId}_clearcoatRoughness.outputs:g>`),t.push(Yx(Z,R,"clearcoatRoughness",new S.c(o,o,o),x,H))):c.push(`${k}float inputs:clearcoatRoughness = ${o}`)),c.push(`${k}float inputs:ior = ${a}`),`\n\tdef Material "Material_${R.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${c.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${R.uniqueId}/PreviewSurface.outputs:surface>\n\n${t.join("\n")}\n\n\t}\n`}async function xH(R,x,H){const t={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...x};"undefined"===typeof fflate&&await c.e.LoadScriptAsync(t.fflateUrl);const A={};A[t.modelFileName]=null;let D='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';D+=function(R){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===R.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${R.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${R.planeAnchoringAlignment}"`:""}\n            `}(t);const U={};for(const k of R.meshes){if(0===k.getTotalVertices())continue;const R=k,x=R.Ci,J=R.material;if(!J||!x||H&&!H(R))continue;if(-1!==["eb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(J.getClassName())){const H="geometries/Geometry_"+x.uniqueId+".usda";if(!(H in A)){const R=rx(x,t);A[H]=zx(R)}J.uniqueId in U||(U[J.uniqueId]=J),D+=Ox(R)}else c.e.Warn("USDZExportAsync does not support this material type: "+J.getClassName())}R.activeCamera&&t.exportCamera&&(D+=function(R,x){const H="Camera_"+R.uniqueId,c=jx(k.e.RotationY(Math.PI).multiply(R.getWorldMatrix()));if(R.mode===a.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${R.Hi.toPrecision(x.precision)}, ${R.maxZ.toPrecision(x.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(R.orthoLeft||1)+Math.abs(R.orthoRight||1))).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(R.orthoTop||1)+Math.abs(R.orthoBottom||1))).toPrecision(x.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const k=R.getEngine().getAspectRatio(R),t=x.cameraSensorWidth||35;return`def Camera "${H}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${c}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${R.Hi.toPrecision(x.precision)}, ${R.maxZ.toPrecision(x.precision)})\n\t\t\tfloat focalLength = ${(t/(2*Math.tan(.5*R.fov))).toPrecision(x.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(t*k).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(t/k).toPrecision(x.precision)}            \n\t\t}\n\t\n\t`}}(R.activeCamera,t)),D+="\n            }\n        }\n    }";const J={};D+=function(R,x,H){const k=[];for(const c in R){const t=R[c];k.push(RH(t,x,H))}return`\n    def "Materials"\n{\n${k.join("")}\n}\n\n`}(U,J,t),A[t.modelFileName]=fflate.strToU8(D);for(const k in J){const R=J[k],x=R.getSize(),H=await R.readPixels();if(!H)throw new Error("Texture data is not available");const c=await X.DumpTools.DumpDataAsync(x.width,x.height,H,"image/png",void 0,!1,!0);A[`textures/Texture_${k}.png`]=new Uint8Array(c).slice()}let V=0;for(const k in A){const R=A[k];if(!R)continue;V+=34+k.length;const x=63&V;if(4!==x){const H=new Uint8Array(64-x);A[k]=[R,{extra:{12345:H}}]}V=R.length}return fflate.zipSync(A,{level:0})}}}]);