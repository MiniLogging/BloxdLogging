"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25,26],{13039:(G,V,W)=>{var J=W(11285),R=W(11201),d=W(11227),k=W(11304),z=W(11262),X=W(11298);z.b.prototype._partialLoadFile=function(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(G,(G=>{W[V]=G,W._internalCount++,6===W._internalCount&&J(W)}),void 0,void 0,!0,((G,V)=>{R&&G&&R(G.status+" "+G.statusText,V)}))},z.b.prototype._cascadeLoadFiles=function(G,V,W){let J=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const R=[];R._internalCount=0;for(let d=0;d<6;d++)this._partialLoadFile(W[d],d,R,V,J)},z.b.prototype._cascadeLoadImgs=function(G,V,W,J){let R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,d=arguments.length>5?arguments[5]:void 0;const k=[];k._internalCount=0;for(let z=0;z<6;z++)this._partialLoadImg(J[z],z,k,G,V,W,R,d)},z.b.prototype._partialLoadImg=function(G,V,W,J,R,z){let X=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,P=arguments.length>7?arguments[7]:void 0;const A=(0,k.b)();(0,d.p)(G,(G=>{W[V]=G,W._internalCount++,J&&J.removePendingData(A),6===W._internalCount&&z&&z(R,W)}),((G,V)=>{J&&J.removePendingData(A),X&&X(G,V)}),J?J.offlineProvider:null,P),J&&J.addPendingData(A)},z.b.prototype.createCubeTextureBase=function(G,V,W,d){let k=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,z=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,P=arguments.length>6?arguments[6]:void 0,A=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,x=arguments.length>8&&void 0!==arguments[8]&&arguments[8],q=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,L=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,t=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,Y=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,g=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,B=arguments.length>14&&void 0!==arguments[14]&&arguments[14],S=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const p=t||new J.d(this,7);p.isCube=!0,p.url=G,p.generateMipMaps=!d,p._lodGenerationScale=q,p._lodGenerationOffset=L,p._useSRGBBuffer=!!B&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!d),p!==t&&(p.label=G.substring(0,60)),this._doNotHandleContextLost||(p._extension=A,p._files=W,p._buffer=S);const b=G;this._transformTextureUrl&&!t&&(G=this._transformTextureUrl(G));const r=A??function(G){const V=G.split("?")[0],W=V.lastIndexOf(".");return W>-1?V.substring(W).toLowerCase():""}(G),y=(0,X.b)(r),u=(G,V)=>{p.dispose(),z?z(G,V):G&&R.c.Warn(G)},H=(J,z)=>{G===b?J&&u(J.status+" "+J.statusText,z):(R.c.Warn(`Failed to load ${G}, falling back to the ${b}`),this.createCubeTextureBase(b,V,W,!!d,k,u,P,A,x,q,L,p,Y,g,B,S))};if(y)y.then((J=>{const R=G=>{Y&&Y(p,G),J.loadCubeData(G,p,x,k,((G,V)=>{u(G,V)}))};S?R(S):W&&6===W.length?J.supportCascades?this._cascadeLoadFiles(V,(G=>R(G.map((G=>new Uint8Array(G))))),W,u):u("Textures type does not support cascades."):this._loadFile(G,(G=>R(new Uint8Array(G))),void 0,void 0,!0,H)}));else{if(!W||0===W.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(V,p,((G,V)=>{g&&g(G,V)}),W,u)}return this._internalTexturesCache.push(p),p}},13765:(G,V,W)=>{W.r(V),W.d(V,{_DDSTextureLoader:()=>d});var J=W(11620),R=W(13772);class d{constructor(){this.supportCascades=!0}loadCubeData(G,V,W,d){const k=V.getEngine();let z,X=!1,P=1e3;if(Array.isArray(G))for(let J=0;J<G.length;J++){const W=G[J];z=R.DDSTools.GetDDSInfo(W),V.width=z.width,V.height=z.height,X=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&V.generateMipMaps,k._unpackFlipY(z.isCompressed),R.DDSTools.UploadDDSLevels(k,V,W,z,X,6,-1,J),z.isFourCC||1!==z.mipmapCount?P=z.mipmapCount-1:k.generateMipMapsForCubemap(V)}else{const d=G;z=R.DDSTools.GetDDSInfo(d),V.width=z.width,V.height=z.height,W&&(z.sphericalPolynomial=new J.g),X=(z.isRGB||z.isLuminance||z.mipmapCount>1)&&V.generateMipMaps,k._unpackFlipY(z.isCompressed),R.DDSTools.UploadDDSLevels(k,V,d,z,X,6),z.isFourCC||1!==z.mipmapCount?P=z.mipmapCount-1:k.generateMipMapsForCubemap(V,!1)}k._setCubeMapTextureParams(V,X,P),V.isReady=!0,V.onLoadedObservable.notifyObservers(V),V.onLoadedObservable.clear(),d&&d({isDDS:!0,width:V.width,info:z,data:G,texture:V})}loadData(G,V,W){const J=R.DDSTools.GetDDSInfo(G),d=(J.isRGB||J.isLuminance||J.mipmapCount>1)&&V.generateMipMaps&&Math.max(J.width,J.height)>>J.mipmapCount-1===1;W(J.width,J.height,d,J.isFourCC,(()=>{R.DDSTools.UploadDDSLevels(V.getEngine(),V,G,J,d,1)}))}}},13772:(G,V,W)=>{W.d(V,{DDSTools:()=>t});var J=W(11182),R=W(11201),d=W(11827),k=W(11663);W(13039);const z=131072,X=131072;function P(G){return G.charCodeAt(0)+(G.charCodeAt(1)<<8)+(G.charCodeAt(2)<<16)+(G.charCodeAt(3)<<24)}const A=P("DXT1"),x=P("DXT3"),q=P("DXT5"),L=P("DX10");class t{static GetDDSInfo(G){const V=new Int32Array(G.buffer,G.byteOffset,31),W=new Int32Array(G.buffer,G.byteOffset,35);let J=1;V[2]&z&&(J=Math.max(1,V[7]));const R=V[21],d=R===L?W[32]:0;let k=0;switch(R){case 113:k=2;break;case 116:k=1;break;case L:if(10===d){k=2;break}if(2===d){k=1;break}}return{width:V[4],height:V[3],mipmapCount:J,isFourCC:4===(4&V[20]),isRGB:64===(64&V[20]),isLuminance:(V[20]&X)===X,isCube:512===(512&V[28]),isCompressed:R===A||R===x||R===q,dxgiFormat:d,textureType:k}}static _GetHalfFloatAsFloatRGBAArrayBuffer(G,V,W,J,R,d){const z=new Float32Array(J),X=new Uint16Array(R,W);let P=0;for(let A=0;A<V;A++)for(let V=0;V<G;V++){const W=4*(V+A*G);z[P]=(0,k.h)(X[W]),z[P+1]=(0,k.h)(X[W+1]),z[P+2]=(0,k.h)(X[W+2]),t.StoreLODInAlphaChannel?z[P+3]=d:z[P+3]=(0,k.h)(X[W+3]),P+=4}return z}static _GetHalfFloatRGBAArrayBuffer(G,V,W,J,R,d){if(t.StoreLODInAlphaChannel){const z=new Uint16Array(J),X=new Uint16Array(R,W);let P=0;for(let W=0;W<V;W++)for(let V=0;V<G;V++){const J=4*(V+W*G);z[P]=X[J],z[P+1]=X[J+1],z[P+2]=X[J+2],z[P+3]=(0,k.o)(d),P+=4}return z}return new Uint16Array(R,W,J)}static _GetFloatRGBAArrayBuffer(G,V,W,J,R,d){if(t.StoreLODInAlphaChannel){const k=new Float32Array(J),z=new Float32Array(R,W);let X=0;for(let W=0;W<V;W++)for(let V=0;V<G;V++){const J=4*(V+W*G);k[X]=z[J],k[X+1]=z[J+1],k[X+2]=z[J+2],k[X+3]=d,X+=4}return k}return new Float32Array(R,W,J)}static _GetFloatAsHalfFloatRGBAArrayBuffer(G,V,W,J,R,d){const z=new Uint16Array(J),X=new Float32Array(R,W);let P=0;for(let A=0;A<V;A++)for(let V=0;V<G;V++)z[P]=(0,k.o)(X[P]),z[P+1]=(0,k.o)(X[P+1]),z[P+2]=(0,k.o)(X[P+2]),t.StoreLODInAlphaChannel?z[P+3]=(0,k.o)(d):z[P+3]=(0,k.o)(X[P+3]),P+=4;return z}static _GetFloatAsUIntRGBAArrayBuffer(G,V,W,R,d,k){const z=new Uint8Array(R),X=new Float32Array(d,W);let P=0;for(let A=0;A<V;A++)for(let V=0;V<G;V++){const W=4*(V+A*G);z[P]=255*(0,J.Clamp)(X[W]),z[P+1]=255*(0,J.Clamp)(X[W+1]),z[P+2]=255*(0,J.Clamp)(X[W+2]),t.StoreLODInAlphaChannel?z[P+3]=k:z[P+3]=255*(0,J.Clamp)(X[W+3]),P+=4}return z}static _GetHalfFloatAsUIntRGBAArrayBuffer(G,V,W,R,d,z){const X=new Uint8Array(R),P=new Uint16Array(d,W);let A=0;for(let x=0;x<V;x++)for(let V=0;V<G;V++){const W=4*(V+x*G);X[A]=255*(0,J.Clamp)((0,k.h)(P[W])),X[A+1]=255*(0,J.Clamp)((0,k.h)(P[W+1])),X[A+2]=255*(0,J.Clamp)((0,k.h)(P[W+2])),t.StoreLODInAlphaChannel?X[A+3]=z:X[A+3]=255*(0,J.Clamp)((0,k.h)(P[W+3])),A+=4}return X}static _GetRGBAArrayBuffer(G,V,W,J,R,d,k,z,X){const P=new Uint8Array(J),A=new Uint8Array(R,W);let x=0;for(let q=0;q<V;q++)for(let V=0;V<G;V++){const W=4*(V+q*G);P[x]=A[W+d],P[x+1]=A[W+k],P[x+2]=A[W+z],P[x+3]=A[W+X],x+=4}return P}static _ExtractLongWordOrder(G){return 0===G||255===G||-16777216===G?0:1+t._ExtractLongWordOrder(G>>8)}static _GetRGBArrayBuffer(G,V,W,J,R,d,k,z){const X=new Uint8Array(J),P=new Uint8Array(R,W);let A=0;for(let x=0;x<V;x++)for(let V=0;V<G;V++){const W=3*(V+x*G);X[A]=P[W+d],X[A+1]=P[W+k],X[A+2]=P[W+z],A+=3}return X}static _GetLuminanceArrayBuffer(G,V,W,J,R){const d=new Uint8Array(J),k=new Uint8Array(R,W);let z=0;for(let X=0;X<V;X++)for(let V=0;V<G;V++){const W=V+X*G;d[z]=k[W],z++}return d}static UploadDDSLevels(G,V,W,J,k,X){let P=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,Y=arguments.length>7?arguments[7]:void 0,g=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],B=null;J.sphericalPolynomial&&(B=[]);const S=!!G.getCaps().s3tc;V.generateMipMaps=k;const p=new Int32Array(W.buffer,W.byteOffset,31);let b,r,y,u,H,n,D,i=0,e=0,F=1;if(542327876!==p[0])return void R.c.Error("Invalid magic number in DDS header");if(!J.isFourCC&&!J.isRGB&&!J.isLuminance)return void R.c.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(J.isCompressed&&!S)return void R.c.Error("Compressed textures are not supported on this platform.");let f=p[22];u=p[1]+4;let v=!1;if(J.isFourCC)switch(b=p[21],b){case A:F=8,e=33777;break;case x:F=16,e=33778;break;case q:F=16,e=33779;break;case 113:v=!0,f=64;break;case 116:v=!0,f=128;break;case L:{u+=20;let G=!1;switch(J.dxgiFormat){case 10:v=!0,f=64,G=!0;break;case 2:v=!0,f=128,G=!0;break;case 88:J.isRGB=!0,J.isFourCC=!1,f=32,G=!0}if(G)break}default:return void R.c.Error(["Unsupported FourCC code:",(C=b,String.fromCharCode(255&C,C>>8&255,C>>16&255,C>>24&255))])}var C;const l=t._ExtractLongWordOrder(p[23]),m=t._ExtractLongWordOrder(p[24]),w=t._ExtractLongWordOrder(p[25]),N=t._ExtractLongWordOrder(p[26]);v&&(e=G._getRGBABufferInternalSizedFormat(J.textureType)),n=1,p[2]&z&&!1!==k&&(n=Math.max(1,p[7]));const U=Y||0,a=G.getCaps();for(let R=U;R<X;R++){for(r=p[4],y=p[3],D=0;D<n;++D){if(-1===P||P===D){const d=-1===P?D:0;if(!J.isCompressed&&J.isFourCC){V.format=5,i=r*y*4;let J=null;if(G._badOS||G._badDesktopOS||!a.textureHalfFloat&&!a.textureFloat)128===f?(J=t._GetFloatAsUIntRGBAArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,d),B&&0==d&&B.push(t._GetFloatRGBAArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,d))):64===f&&(J=t._GetHalfFloatAsUIntRGBAArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,d),B&&0==d&&B.push(t._GetHalfFloatAsFloatRGBAArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,d))),V.type=0;else{const G=a.textureFloat&&(g&&a.textureFloatLinearFiltering||!g),R=a.textureHalfFloat&&(g&&a.textureHalfFloatLinearFiltering||!g),k=(128===f||64===f&&!R)&&G?1:(64===f||128===f&&!G)&&R?2:0;let z,X=null;if(128===f)switch(k){case 1:z=t._GetFloatRGBAArrayBuffer,X=null;break;case 2:z=t._GetFloatAsHalfFloatRGBAArrayBuffer,X=t._GetFloatRGBAArrayBuffer;break;case 0:z=t._GetFloatAsUIntRGBAArrayBuffer,X=t._GetFloatRGBAArrayBuffer}else switch(k){case 1:z=t._GetHalfFloatAsFloatRGBAArrayBuffer,X=null;break;case 2:z=t._GetHalfFloatRGBAArrayBuffer,X=t._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:z=t._GetHalfFloatAsUIntRGBAArrayBuffer,X=t._GetHalfFloatAsFloatRGBAArrayBuffer}V.type=k,J=z(r,y,W.byteOffset+u,i,W.buffer,d),B&&0==d&&B.push(X?X(r,y,W.byteOffset+u,i,W.buffer,d):J)}J&&G._uploadDataToTextureDirectly(V,J,R,d)}else if(J.isRGB)V.type=0,24===f?(V.format=4,i=r*y*3,H=t._GetRGBArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,l,m,w),G._uploadDataToTextureDirectly(V,H,R,d)):(V.format=5,i=r*y*4,H=t._GetRGBAArrayBuffer(r,y,W.byteOffset+u,i,W.buffer,l,m,w,N),G._uploadDataToTextureDirectly(V,H,R,d));else if(J.isLuminance){const J=G._getUnpackAlignement(),k=r;i=Math.floor((r+J-1)/J)*J*(y-1)+k,H=t._GetLuminanceArrayBuffer(r,y,W.byteOffset+u,i,W.buffer),V.format=1,V.type=0,G._uploadDataToTextureDirectly(V,H,R,d)}else i=Math.max(4,r)/4*Math.max(4,y)/4*F,H=new Uint8Array(W.buffer,W.byteOffset+u,i),V.type=0,G._uploadCompressedDataToTextureDirectly(V,e,r,y,H,R,d)}u+=f?r*y*(f/8):i,r*=.5,y*=.5,r=Math.max(1,r),y=Math.max(1,y)}if(void 0!==Y)break}B&&B.length>0?J.sphericalPolynomial=d.b.ConvertCubeMapToSphericalPolynomial({size:p[4],right:B[0],left:B[1],up:B[2],down:B[3],front:B[4],back:B[5],format:5,type:1,gammaSpace:!1}):J.sphericalPolynomial=void 0}}t.StoreLODInAlphaChannel=!1}}]);