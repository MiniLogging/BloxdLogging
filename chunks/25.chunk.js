"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[25],{12134:(Q,X,C)=>{C.r(X),C.d(X,{EXT_materials_diffuse_roughness:()=>qX,EXT_mesh_gpu_instancing:()=>tQ,GLTF2Export:()=>pQ,GLTFData:()=>W,KHR_draco_mesh_compression:()=>CX,KHR_lights_punctual:()=>mX,KHR_materials_anisotropy:()=>LX,KHR_materials_clearcoat:()=>iX,KHR_materials_diffuse_transmission:()=>sX,KHR_materials_dispersion:()=>xX,KHR_materials_emissive_strength:()=>PX,KHR_materials_ior:()=>vX,KHR_materials_iridescence:()=>gX,KHR_materials_sheen:()=>eX,KHR_materials_specular:()=>RX,KHR_materials_transmission:()=>oX,KHR_materials_unlit:()=>YX,KHR_materials_volume:()=>KX,KHR_texture_transform:()=>cX,OBJExport:()=>f,STLExport:()=>EX,USDZExportAsync:()=>XC,_ConvertToGLTFPBRMetallicRoughness:()=>T,_SolveMetallic:()=>o,__IGLTFExporterExtension:()=>O});var l=C(668),h=C(487),M=C(837);class f{static OBJ(Q,X,C,f){const O=[];let m=1,W=1;X&&(C||(C="mat"),O.push("mtllib "+C+".mtl"));for(let U=0;U<Q.length;U++){const C=Q[U],L=C.name||`mesh${U}}`;O.push(`o ${L}`);let w=null;if(f){const Q=C.Vj(!0);w=new l.b,Q.invertToRef(w),C.bakeTransformIntoVertices(Q)}if(X){const Q=C.material;Q&&O.push("usemtl "+Q.id)}const i=C.ik;if(!i){h.i.Warn("No geometry is present on the mesh");continue}const a=i.getVerticesData("position"),F=i.getVerticesData("ek"),s=i.getVerticesData("uv"),z=i.Xj();let x=0,r=0;if(!a||!z){h.i.Warn("There are no position vertices or indices on the mesh!");continue}const P=Q[0].va().useRightHandedSystem?1:-1;for(let Q=0;Q<a.length;Q+=3)O.push("v "+a[Q]*P+" "+a[Q+1]+" "+a[Q+2]),x++;if(null!=F)for(let Q=0;Q<F.length;Q+=3)O.push("vn "+F[Q]*P+" "+F[Q+1]+" "+F[Q+2]);if(null!=s)for(let Q=0;Q<s.length;Q+=2)O.push("vt "+s[Q]+" "+s[Q+1]),r++;const j=["","",""],v=(C.material||C.va().defaultMaterial)._getEffectiveOrientation(C),[Z,g]=v===M.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let Q=0;Q<z.length;Q+=3){const X=[String(z[Q]+m),String(z[Q+Z]+m),String(z[Q+g]+m)],C=[String(z[Q]+W),String(z[Q+Z]+W),String(z[Q+g]+W)],l=X,h=null!=s?C:j,M=null!=F?X:j;O.push("f "+l[0]+"/"+h[0]+"/"+M[0]+" "+l[1]+"/"+h[1]+"/"+M[1]+" "+l[2]+"/"+h[2]+"/"+M[2])}f&&w&&C.bakeTransformIntoVertices(w),m+=x,W+=r}return O.join("\n")}static MTL(Q){const X=[],C=Q.material;X.push("newmtl mat1"),X.push("  Ns "+C.specularPower.toFixed(4)),X.push("  Ni 1.5000"),X.push("  d "+C.alpha.toFixed(4)),X.push("  Tr 0.0000"),X.push("  Tf 1.0000 1.0000 1.0000"),X.push("  illum 2"),X.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),X.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),X.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),X.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&X.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&X.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&X.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&X.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&X.push("  map_d "+C.opacityTexture.name);return X.join("\n")}}var O=0,m=C(526);class W{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Q in this.files){const X=this.files[Q],C=new Blob([X],{type:(0,m.g)(Q)});h.i.Download(C,Q)}}}var U=C(722),L=C(806),w=C(800),i=C(12137),a=C(2443),F=C(524),s=C(702),z=C(690);const x=z.HighestCommonFactor,r={...z,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:x};var P=C(2394),j=C(2397),v=C(12142),Z=C(12145),g=C(2578);const S=1e-6,e=new s.b(.04,.04,.04),k=1024,R=s.b.White(),H=s.b.Black();function o(Q,X,C){if(X<e.r)return 0;const l=e.r,h=Q*C/(1-e.r)+X-2*e.r,M=h*h-4*l*(e.r-X);return r.Clamp((-h+Math.sqrt(M))/(2*l),0,1)}function T(Q){const X=Q.diffuseColor.toLinearSpace(Q.va().getEngine().useExactSrgbConversions).scale(.5),C=Q.alpha,h=function(Q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.h(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new l.h(0,.1),h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new l.h(0,.1),M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new l.h(1300,.1);return function(Q,X,C,l,h){return(1-Q)*(1-Q)*(1-Q)*X+3*(1-Q)*(1-Q)*Q*C+3*(1-Q)*Q*Q*l+Q*Q*Q*h}(Math.pow(Q/M.x,.333333),X.y,C.y,h.y,M.y)}(r.Clamp(Q.specularPower,0,k));return{baseColorFactor:[X.r,X.g,X.b,C],metallicFactor:0,roughnessFactor:h}}function Y(Q,X){X.needAlphaBlending()?Q.alphaMode="BLEND":X.needAlphaTesting()&&(Q.alphaMode="MASK",Q.alphaCutoff=X.alphaCutOff)}function J(Q,X,C){const l=new Uint8Array(Q*X*4);for(let h=0;h<l.length;h+=4)l[h]=l[h+1]=l[h+2]=l[h+3]=255;return v.b.CreateRGBATexture(l,Q,X,C)}function K(Q){if(Q instanceof Uint8Array){const X=Q.length,C=new Float32Array(Q.length);for(let l=0;l<X;++l)C[l]=Q[l]/255;return C}if(Q instanceof Float32Array)return Q;throw new Error("Unsupported pixel format!")}class N{constructor(Q){this._exporter=Q,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Q){return Q?this._textureMap.get(Q)??null:null}async exportStandardMaterialAsync(Q,X,C){const l=T(Q),M={name:Q.name};if(null==Q.fk||Q.fk||(Q.twoSidedLighting||h.i.Warn(Q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),M.doubleSided=!0),C){const C=[],h=Q.diffuseTexture;h&&C.push(this.exportTextureAsync(h,X).then((Q=>{Q&&(l.baseColorTexture=Q)})));const f=Q.bumpTexture;f&&C.push(this.exportTextureAsync(f,X).then((Q=>{Q&&(M.normalTexture=Q,1!==f.level&&(M.normalTexture.scale=f.level))})));const O=Q.emissiveTexture;O&&(M.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(O,X).then((Q=>{Q&&(M.emissiveTexture=Q)}))));const m=Q.ambientTexture;m&&C.push(this.exportTextureAsync(m,X).then((Q=>{if(Q){const X={index:Q.index};M.occlusionTexture=X}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(Q),await Promise.all(C))}(Q.alpha<1||Q.opacityTexture)&&(Q.alphaMode===Z.c.ALPHA_COMBINE?M.alphaMode="BLEND":h.i.Warn(Q.name+": glTF 2.0 does not support alpha mode: "+Q.alphaMode.toString())),Q.emissiveColor&&!Q.emissiveColor.equalsWithEpsilon(H,S)&&(M.emissiveFactor=Q.emissiveColor.dk()),M.pbrMetallicRoughness=l,Y(M,Q),await this._finishMaterialAsync(M,Q,X);const f=this._exporter._materials;return f.push(M),f.length-1}async _finishMaterialAsync(Q,X,C){const l=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Q,X),h=[];for(const M of l)h.push(this.exportTextureAsync(M,C));await Promise.all(h),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Q,X)}async _getImageDataAsync(Q,X,l,h){const M=Z.c.TEXTURETYPE_UNSIGNED_BYTE,f=this._exporter._babylonScene,O=f.getEngine(),m=O.createRawTexture(Q,X,l,Z.c.TEXTUREFORMAT_RGBA,!1,!0,j.e.NEAREST_SAMPLINGMODE,null,M);O.isWebGPU?await C.e(45).then(C.bind(C,13666)):await C.e(46).then(C.bind(C,13675)),await P.j.ApplyPostProcess("pass",m,f,M,Z.c.TEXTURE_NEAREST_SAMPLINGMODE,Z.c.TEXTUREFORMAT_RGBA);const W=await O._readTexturePixels(m,X,l);return await g.DumpTools.DumpDataAsync(X,l,W,h,void 0,!0,!0)}_resizeTexturesToSameDimensions(Q,X,C){const l=Q?Q.getSize():{width:0,height:0},h=X?X.getSize():{width:0,height:0};let M,f;return l.width<h.width?(M=Q&&Q instanceof j.e?P.j.CreateResizedCopy(Q,h.width,h.height,!0):J(h.width,h.height,C),f=X):l.width>h.width?(f=X&&X instanceof j.e?P.j.CreateResizedCopy(X,l.width,l.height,!0):J(l.width,l.height,C),M=Q):(M=Q,f=X),{texture1:M,texture2:f}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Q,X,C,l){const h=new Array;if(!Q&&!X)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const M=Q?Q.va():X?X.va():null;if(M){var f;const O=this._resizeTexturesToSameDimensions(Q,X,M),m=null===(f=O.texture1)||void 0===f?void 0:f.getSize();let W,U;const L=m.width,w=m.height,i=await O.texture1.readPixels(),a=await O.texture2.readPixels();if(!i)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(W=K(i),!a)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");U=K(a);const F=U.byteLength,z=new Uint8Array(F),x=new Uint8Array(F),r=4,P=H;let j=0,v=0;for(let Q=0;Q<w;++Q)for(let X=0;X<L;++X){const l=(L*Q+X)*r,h={diffuseColor:new s.b(W[l],W[l+1],W[l+2]).toLinearSpace(M.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new s.b(U[l],U[l+1],U[l+2]).toLinearSpace(M.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:U[l+3]*C.glossiness},f=this._convertSpecularGlossinessToMetallicRoughness(h);P.r=Math.max(P.r,f.baseColor.r),P.g=Math.max(P.g,f.baseColor.g),P.b=Math.max(P.b,f.baseColor.b),j=Math.max(j,f.metallic),v=Math.max(v,f.roughness),x[l]=255*f.baseColor.r,x[l+1]=255*f.baseColor.g,x[l+2]=255*f.baseColor.b,x[l+3]=O.texture1.mi?255*W[l+3]:255,z[l]=0,z[l+1]=255*f.roughness,z[l+2]=255*f.metallic,z[l+3]=255}const Z={baseColor:P,metallic:j,roughness:v};let g=!1,e=!1;for(let Q=0;Q<w;++Q)for(let X=0;X<L;++X){const C=(L*Q+X)*r;x[C]/=Z.baseColor.r>S?Z.baseColor.r:1,x[C+1]/=Z.baseColor.g>S?Z.baseColor.g:1,x[C+2]/=Z.baseColor.b>S?Z.baseColor.b:1;const l=s.b.FromInts(x[C],x[C+1],x[C+2]).toGammaSpace(M.getEngine().useExactSrgbConversions);x[C]=255*l.r,x[C+1]=255*l.g,x[C+2]=255*l.b,l.equalsWithEpsilon(R,S)||(e=!0),z[C+1]/=Z.roughness>S?Z.roughness:1,z[C+2]/=Z.metallic>S?Z.metallic:1;s.b.FromInts(255,z[C+1],z[C+2]).equalsWithEpsilon(R,S)||(g=!0)}return g&&h.push(this._getImageDataAsync(z,L,w,l).then((Q=>{Z.metallicRoughnessTextureData=Q}))),e&&h.push(this._getImageDataAsync(x,L,w,l).then((Q=>{Z.baseColorTextureData=Q}))),await Promise.all(h).then((()=>Z))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Q){const X=this._getPerceivedBrightness(Q.diffuseColor),C=this._getPerceivedBrightness(Q.specularColor),l=1-this._getMaxComponent(Q.specularColor),h=o(X,C,l),M=Q.diffuseColor.scale(l/(1-e.r)/Math.max(1-h)),f=Q.specularColor.Od(e.scale(1-h)).scale(1/Math.max(h));let O=s.b.Lerp(M,f,h*h);O=O.clampToRef(0,1,O);return{baseColor:O,metallic:h,roughness:1-Q.glossiness}}_getPerceivedBrightness(Q){return Q?Math.sqrt(.299*Q.r*Q.r+.587*Q.g*Q.g+.114*Q.b*Q.b):0}_getMaxComponent(Q){return Q?Math.max(Q.r,Math.max(Q.g,Q.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Q,X,C,l){const h=[],M={baseColor:Q._albedoColor,metallic:Q._metallic,roughness:Q._roughness};if(l){Q._albedoTexture&&h.push(this.exportTextureAsync(Q._albedoTexture,X).then((Q=>{Q&&(C.baseColorTexture=Q)})));const l=Q._metallicTexture;l&&h.push(this.exportTextureAsync(l,X).then((Q=>{Q&&(C.metallicRoughnessTexture=Q)})))}return h.length>0&&(this._exporter._materialNeedsUVsSet.add(Q),await Promise.all(h)),M}_getTextureSampler(Q){const X={};if(!Q||!(Q instanceof j.e))return X;const C=this._getGLTFTextureWrapMode(Q.wrapU);10497!==C&&(X.wrapS=C);const l=this._getGLTFTextureWrapMode(Q.wrapV);switch(10497!==l&&(X.wrapT=l),Q.samplingMode){case j.e.LINEAR_LINEAR:X.magFilter=9729,X.minFilter=9729;break;case j.e.LINEAR_NEAREST:X.magFilter=9729,X.minFilter=9728;break;case j.e.NEAREST_LINEAR:X.magFilter=9728,X.minFilter=9729;break;case j.e.NEAREST_LINEAR_MIPLINEAR:X.magFilter=9728,X.minFilter=9987;break;case j.e.NEAREST_NEAREST:X.magFilter=9728,X.minFilter=9728;break;case j.e.NEAREST_LINEAR_MIPNEAREST:X.magFilter=9728,X.minFilter=9985;break;case j.e.LINEAR_NEAREST_MIPNEAREST:X.magFilter=9729,X.minFilter=9984;break;case j.e.LINEAR_NEAREST_MIPLINEAR:X.magFilter=9729,X.minFilter=9986;break;case j.e.NEAREST_NEAREST_MIPLINEAR:X.magFilter=9728,X.minFilter=9986;break;case j.e.LINEAR_LINEAR_MIPLINEAR:X.magFilter=9729,X.minFilter=9987;break;case j.e.LINEAR_LINEAR_MIPNEAREST:X.magFilter=9729,X.minFilter=9985;break;case j.e.NEAREST_NEAREST_MIPNEAREST:X.magFilter=9728,X.minFilter=9984}return X}_getGLTFTextureWrapMode(Q){switch(Q){case j.e.WRAP_ADDRESSMODE:return 10497;case j.e.CLAMP_ADDRESSMODE:return 33071;case j.e.MIRROR_ADDRESSMODE:return 33648;default:return h.i.Error(`Unsupported Texture Wrap Mode ${Q}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Q,X,C,l){const h={diffuseColor:Q._albedoColor,specularColor:Q._reflectivityColor,glossiness:Q._microSurface},M=Q._albedoTexture,f=Q._reflectivityTexture,O=Q._useMicroSurfaceFromReflectivityMapAlpha;if(f&&!O)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((M||f)&&l){this._exporter._materialNeedsUVsSet.add(Q);const l=this._exportTextureSampler(M||f),O=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(M,f,h,X),m=this._exporter._textures;if(O.baseColorTextureData){const Q=this._exportImage(`baseColor${m.length}`,X,O.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(Q,l,null===M||void 0===M?void 0:M.coordinatesIndex)}if(O.metallicRoughnessTextureData){const Q=this._exportImage(`metallicRoughness${m.length}`,X,O.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(Q,l,null===f||void 0===f?void 0:f.coordinatesIndex)}return O}return this._convertSpecularGlossinessToMetallicRoughness(h)}async exportPBRMaterialAsync(Q,X,C){const l={},h={name:Q.name},M=Q.isMetallicWorkflow();if(M){const X=Q._albedoColor,C=Q.alpha;X&&(l.baseColorFactor=[X.r,X.g,X.b,C])}const f=M?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Q,X,l,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Q,X,l,C);await this._setMetallicRoughnessPbrMaterialAsync(f,Q,h,l,X,C),await this._finishMaterialAsync(h,Q,X);const O=this._exporter._materials;return O.push(h),O.length-1}async _setMetallicRoughnessPbrMaterialAsync(Q,X,C,l,M,f){if(Y(C,X),Q.baseColor.equalsWithEpsilon(R,S)&&r.WithinEpsilon(X.alpha,1,S)||(l.baseColorFactor=[Q.baseColor.r,Q.baseColor.g,Q.baseColor.b,X.alpha]),null!=Q.metallic&&1!==Q.metallic&&(l.metallicFactor=Q.metallic),null!=Q.roughness&&1!==Q.roughness&&(l.roughnessFactor=Q.roughness),null==X.fk||X.fk||(X._twoSidedLighting||h.i.Warn(X.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),f){const Q=[],l=X._bumpTexture;l&&Q.push(this.exportTextureAsync(l,M).then((Q=>{Q&&(C.normalTexture=Q,1!==l.level&&(C.normalTexture.scale=l.level))})));const h=X._ambientTexture;h&&Q.push(this.exportTextureAsync(h,M).then((Q=>{if(Q){const l={index:Q.index,texCoord:Q.texCoord,extensions:Q.extensions};C.occlusionTexture=l;const h=X._ambientTextureStrength;h&&(l.strength=h)}})));const f=X._emissiveTexture;f&&Q.push(this.exportTextureAsync(f,M).then((Q=>{Q&&(C.emissiveTexture=Q)}))),Q.length>0&&(this._exporter._materialNeedsUVsSet.add(X),await Promise.all(Q))}const O=X._emissiveColor;O.equalsWithEpsilon(H,S)||(C.emissiveFactor=O.dk()),C.pbrMetallicRoughness=l}_getPixelsFromTextureAsync(Q){return function(Q){switch(Q){case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Z.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Z.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Q.textureFormat)?(0,P.i)(Q,Q._texture.width,Q._texture.height):(Q.textureType,Z.c.TEXTURETYPE_UNSIGNED_BYTE,Q.readPixels())}async exportTextureAsync(Q,X){const C=this._exporter._extensionsPreExportTextureAsync("exporter",Q,X);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,X):await this._exportTextureInfoAsync(Q,X))):await this._exportTextureInfoAsync(Q,X)}async _exportTextureInfoAsync(Q,X){let C=this._textureMap.get(Q);if(!C){const l=await this._getPixelsFromTextureAsync(Q);if(!l)return null;const M=this._exportTextureSampler(Q),f=Q.mimeType;if(f)switch(f){case"image/jpeg":case"image/png":case"image/webp":X=f;break;default:h.i.Warn(`Unsupported media type: ${f}. Exporting texture as PNG.`)}const O=this._internalTextureToImage,m=Q.getInternalTexture().uniqueId;O[m]||(O[m]={});let W=O[m][X];if(void 0===W){const C=Q.getSize();W=(async()=>{const h=await this._getImageDataAsync(l,C.width,C.height,X);return this._exportImage(Q.name,X,h)})(),O[m][X]=W}C=this._exportTextureInfo(await W,M,Q.coordinatesIndex),this._textureMap.set(Q,C),this._exporter._extensionsPostExportTextures("exporter",C,Q)}return C}_exportImage(Q,X,C){const l=this._exporter._images;let M;if(this._exporter._shouldUseGlb){M={name:Q,mimeType:X,bufferView:void 0};const l=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(M,l)}else{const f=Q.replace(/\.\/|\/|\.\\|\\/g,"_"),O=function(Q){switch(Q){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(X);let m=f+O;l.some((Q=>Q.uri===m))&&(m=`${f}_${h.i.RandomId()}${O}`),M={name:Q,uri:m},this._exporter._imageData[m]={data:C,mimeType:X}}return l.push(M),l.length-1}_exportTextureInfo(Q,X,C){const l=this._exporter._textures;let h=l.findIndex((C=>C.sampler==X&&C.source===Q));-1===h&&(h=l.length,l.push({source:Q,sampler:X}));const M={index:h};return C&&(M.texCoord=C),M}_exportTextureSampler(Q){const X=this._getTextureSampler(Q),C=this._exporter._samplers,l=C.findIndex((Q=>Q.minFilter===X.minFilter&&Q.magFilter===X.magFilter&&Q.wrapS===X.wrapS&&Q.wrapT===X.wrapT));return-1!==l?l:(C.push(X),C.length-1)}}var q=C(730),n=C(501),c=C(12149),E=C(677);const B=l.k.Zero(),G=l.c.Identity(),b=l.k.One(),p=new l.k(-1,1,1);function I(Q,X){const{byteOffset:C,byteStride:l,type:h,normalized:M}=Q,f=Q.getSize(),O=X.reduce(((Q,X)=>X.getTotalVertices()>Q?X.getTotalVertices():Q),-Number.MAX_VALUE);return{byteOffset:C,byteStride:l,componentCount:f,type:h,count:O*f,normalized:M,totalVertices:O,kind:Q.getKind()}}function t(Q){switch(Q){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function y(Q){switch(Q){case U.g.PositionKind:case U.g.NormalKind:case U.g.TangentKind:case U.g.ColorKind:case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:case U.g.MatricesWeightsKind:case U.g.MatricesWeightsExtraKind:case U.g.UVKind:case U.g.UV2Kind:case U.g.UV3Kind:case U.g.UV4Kind:case U.g.UV5Kind:case U.g.UV6Kind:return!0}return!1}function A(Q){switch(Q){case M.e.TriangleFillMode:return 4;case M.e.TriangleStripDrawMode:return 5;case M.e.TriangleFanDrawMode:return 6;case M.e.PointListDrawMode:case M.e.PointFillMode:return 0;case M.e.LineLoopDrawMode:return 2;case M.e.LineListDrawMode:return 1;case M.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Q}`)}function D(Q){const X=Math.sqrt(Q.x*Q.x+Q.y*Q.y+Q.z*Q.z);X>0&&(Q.x/=X,Q.y/=X,Q.z/=X)}function u(Q){return Q.x*=-1,Q}function V(Q){if(Q.x*Q.x+Q.y*Q.y>.5){const X=Math.abs(Q.x),C=Math.abs(Q.y);if(X>C){const C=Math.sign(Q.x);Q.x=X,Q.y*=-C,Q.z*=-C,Q.w*=C}else{const X=Math.sign(Q.y);Q.x*=-X,Q.y=C,Q.z*=X,Q.w*=-X}}else{const X=Math.abs(Q.z),C=Math.abs(Q.w);if(X>C){const C=Math.sign(Q.z);Q.x*=-C,Q.y*=C,Q.z=X,Q.w*=-C}else{const X=Math.sign(Q.w);Q.x*=X,Q.y*=-X,Q.z*=-X,Q.w=C}}return Q}function d(Q){Q.Yc(-Q.z,Q.w,Q.x,-Q.y)}function QQ(Q,X){const C=l.k.FromArrayToRef(X.translation||[0,0,0],0,l.e.Yj[0]),h=l.c.FromArrayToRef(X.rotation||[0,0,0,1],0,l.e.Quaternion[0]),M=l.b.ComposeToRef(b,h,C,l.e.Matrix[0]),f=l.k.FromArrayToRef(Q.translation||[0,0,0],0,l.e.Yj[2]),O=l.c.FromArrayToRef(Q.rotation||[0,0,0,1],0,l.e.Quaternion[1]),m=l.b.ComposeToRef(b,O,f,l.e.Matrix[1]);M.multiplyToRef(m,m),m.decompose(void 0,h,C),C.equalsWithEpsilon(B,E.b)?delete X.translation:X.translation=C.dk(),h.equalsWithEpsilon(G,E.b)?delete X.rotation:X.rotation=h.dk(),X.scale&&delete X.scale}function XQ(Q,X){if(!(X instanceof L.e))return!1;if(!(1===X.getChildren().length&&0===Q.getChildren().length&&Q.parent===X))return!1;const C=Q.va(),l=Q instanceof c.e&&!C.useRightHandedSystem?p:b;return!!X._c.equalsWithEpsilon(l,E.b)||(n.c.Warn(`Cannot collapse node ${Q.name} into parent node ${X.name} with modified scaling.`),!1)}function CQ(Q){if(Q instanceof Array){const X=new Float32Array(Q);return new Uint8Array(X.buffer,X.byteOffset,X.byteLength)}return ArrayBuffer.isView(Q)?new Uint8Array(Q.buffer,Q.byteOffset,Q.byteLength):new Uint8Array(Q)}function lQ(Q,X){for(const[C,l]of Object.entries(Q)){const h=X[C];(Array.isArray(l)&&Array.isArray(h)&&hQ(l,h)||l===h)&&delete Q[C]}return Q}function hQ(Q,X){return Q.length===X.length&&Q.every(((Q,C)=>Q===X[C]))}const MQ=l.b.Compose(new l.k(-1,1,1),l.c.Identity(),l.k.Zero());function fQ(Q,X){if(!(Q instanceof L.e))return!1;if(X){if(!Q.getWorldMatrix().equalsWithEpsilon(l.b.IdentityReadOnly,E.b))return!1}else{if(!Q.getWorldMatrix().multiplyToRef(MQ,l.e.Matrix[0]).equalsWithEpsilon(l.b.IdentityReadOnly,E.b))return!1}return!(Q instanceof w.d&&Q.ik)}const OQ=new Map([[Int8Array,(Q,X,C)=>Q.setInt8(X,C)],[Uint8Array,(Q,X,C)=>Q.setUint8(X,C)],[Uint8ClampedArray,(Q,X,C)=>Q.setUint8(X,C)],[Int16Array,(Q,X,C)=>Q.setInt16(X,C,!0)],[Uint16Array,(Q,X,C)=>Q.setUint16(X,C,!0)],[Int32Array,(Q,X,C)=>Q.setInt32(X,C,!0)],[Uint32Array,(Q,X,C)=>Q.setUint32(X,C,!0)],[Float32Array,(Q,X,C)=>Q.setFloat32(X,C,!0)],[Float64Array,(Q,X,C)=>Q.setFloat64(X,C,!0)]]);class mQ{writeTypedArray(Q){this._checkGrowBuffer(Q.byteLength);const X=OQ.get(Q.constructor);for(let C=0;C<Q.length;C++)X(this._dataView,this._byteOffset,Q[C]),this._byteOffset+=Q.BYTES_PER_ELEMENT}constructor(Q){this._data=new Uint8Array(Q),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Q){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Q),this._byteOffset++}writeInt8(Q){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Q),this._byteOffset++}writeInt16(Q){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Q,!0),this._byteOffset+=2}writeUInt16(Q){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Q,!0),this._byteOffset+=2}writeInt32(Q){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Q,!0),this._byteOffset+=4}writeUInt32(Q){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Q,!0),this._byteOffset+=4}writeFloat32(Q){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Q,!0),this._byteOffset+=4}writeFloat64(Q){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Q,!0),this._byteOffset+=8}_checkGrowBuffer(Q){const X=this.byteOffset+Q;if(X>this._data.byteLength){const Q=new Uint8Array(2*X);Q.set(this._data),this._data=Q,this._dataView=new DataView(this._data.buffer)}}}function WQ(Q){return Q%4===0?4:Q%2===0?2:1}class UQ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Q){let X=0;this._bufferViewToData.forEach((Q=>{X+=Q.byteLength}));const C=new mQ(X),l=Array.from(this._bufferViewToData.keys()).sort(((Q,X)=>WQ(X.byteLength)-WQ(Q.byteLength)));for(const h of l){h.byteOffset=C.byteOffset,Q.push(h);const X=Q.length-1,l=this.getPropertiesWithBufferView(h);for(const Q of l)Q.bufferView=X;C.writeTypedArray(this._bufferViewToData.get(h)),this._bufferViewToData.delete(h)}return C.getOutputData()}createBufferView(Q,X){const C={buffer:0,byteOffset:void 0,byteLength:Q.byteLength,byteStride:X};return this._bufferViewToData.set(C,Q),C}createAccessor(Q,X,C,l,h,M,f){this._verifyBufferView(Q);const O={bufferView:void 0,componentType:C,count:l,type:X,min:null===M||void 0===M?void 0:M.min,max:null===M||void 0===M?void 0:M.max,normalized:f,byteOffset:h};return this.setBufferView(O,Q),this._accessorToBufferView.set(O,Q),O}setBufferView(Q,X){this._verifyBufferView(X);this.getPropertiesWithBufferView(X).push(Q)}removeBufferView(Q){const X=this.getPropertiesWithBufferView(Q);for(const C of X)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(Q),this._bufferViewToProperties.delete(Q),this._accessorToBufferView.forEach(((X,C)=>{X===Q&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(Q){const X=this._accessorToBufferView.get(Q);return this._verifyBufferView(X),X}getPropertiesWithBufferView(Q){return this._verifyBufferView(Q),this._bufferViewToProperties.set(Q,this._bufferViewToProperties.get(Q)??[]),this._bufferViewToProperties.get(Q)}getData(Q){return this._verifyBufferView(Q),this._bufferViewToData.get(Q)}_verifyBufferView(Q){if(void 0===Q||!this._bufferViewToData.has(Q))throw new Error(`BufferView ${Q} not found in BufferManager.`)}}var LQ,wQ=C(642),iQ=C(858),aQ=C(12157),FQ=C(12222),sQ=C(12229),zQ=C(12237),xQ=C(477),rQ=C(12240);!function(Q){Q[Q.INTANGENT=0]="INTANGENT",Q[Q.OUTTANGENT=1]="OUTTANGENT"}(LQ||(LQ={}));class PQ{static _IsTransformable(Q){return Q&&(Q instanceof L.e||Q instanceof wQ.d||Q instanceof rQ.b)}static _CreateNodeAnimation(Q,X,C,l,M){if(this._IsTransformable(Q)){const f=[],O=[],m=X.getKeys(),W=PQ._CalculateMinMaxKeyFrames(m),U=PQ._DeduceInterpolation(m,C,l),L=U.interpolationType,w=U.shouldBakeAnimation;if(w?PQ._CreateBakedAnimation(Q,X,C,W.min,W.max,X.framePerSecond,M,f,O,W,l):"LINEAR"===L||"STEP"===L?PQ._CreateLinearOrStepAnimation(Q,X,C,f,O,l):"CUBICSPLINE"===L?PQ._CreateCubicSplineAnimation(Q,X,C,f,O,l):PQ._CreateBakedAnimation(Q,X,C,W.min,W.max,X.framePerSecond,M,f,O,W,l),f.length&&O.length){return{inputs:f,outputs:O,samplerInterpolation:L,inputsMin:w?W.min:h.i.FloatRound(W.min/X.framePerSecond),inputsMax:w?W.max:h.i.FloatRound(W.max/X.framePerSecond)}}}return null}static _DeduceAnimationInfo(Q){let X=null,C="VEC3",l=!1;const M=Q.targetProperty.split(".");switch(M[0]){case"_c":X="scale";break;case"position":X="translation";break;case"rotation":C="VEC4",X="rotation";break;case"rotationQuaternion":C="VEC4",l=!0,X="rotation";break;case"influence":C="SCALAR",X="weights";break;default:h.i.Error(`Unsupported animatable property ${M[0]}`)}return X?{animationChannelTargetPath:X,dataAccessorType:C,useQuaternion:l}:(h.i.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Q,X,C,l,h,M,f,O,m,W,U){let L;if(PQ._IsTransformable(Q)&&Q.animations)for(const w of Q.animations){if(U&&!U(w))continue;const h=PQ._DeduceAnimationInfo(w);h&&(L={name:w.name,samplers:[],channels:[]},PQ._AddAnimation(`${w.name}`,w.hasRunningRuntimeAnimations?X:L,Q,w,h.dataAccessorType,h.animationChannelTargetPath,l,M,f,O,h.useQuaternion,m,W),L.samplers.length&&L.channels.length&&C.push(L))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Q,X,C,l,h,M,f,O,m,W,U){let L;if(Q instanceof xQ.c){const h=Q.morphTargetManager;if(h)for(let w=0;w<h.numTargets;++w){const i=h.getTarget(w);for(const a of i.animations){if(U&&!U(a))continue;const i=new sQ.e(`${a.name}`,"influence",a.framePerSecond,a.dataType,a.loopMode,a.enableBlending),F=[],s=a.getKeys();for(let Q=0;Q<s.length;++Q){const X=s[Q];for(let Q=0;Q<h.numTargets;++Q)Q==w?F.push(X):F.push({frame:X.frame,value:0})}i.setKeys(F);const z=PQ._DeduceAnimationInfo(i);z&&(L={name:i.name,samplers:[],channels:[]},PQ._AddAnimation(a.name,a.hasRunningRuntimeAnimations?X:L,Q,i,z.dataAccessorType,z.animationChannelTargetPath,l,M,f,O,z.useQuaternion,m,W,h.numTargets),L.samplers.length&&L.channels.length&&C.push(L))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Q,X,C,l,h,M,f,O,m){let W;if(Q.animationGroups){const L=Q.animationGroups;for(const w of L){const L=new Map,i=new Map,a=new Set,F=w.to-w.from;W={name:w.name,channels:[],samplers:[]};for(let X=0;X<w.targetedAnimations.length;++X){const F=w.targetedAnimations[X],s=F.target,z=F.animation;if(m&&!m(z))continue;const x=O.has(s);if(this._IsTransformable(s)||1===s.length&&this._IsTransformable(s[0])){const Q=PQ._DeduceAnimationInfo(F.animation);if(Q){const X=this._IsTransformable(s)?s:this._IsTransformable(s[0])?s[0]:null;X&&PQ._AddAnimation(`${z.name}`,W,X,z,Q.dataAccessorType,Q.animationChannelTargetPath,C,l,h,M,Q.useQuaternion,f,x)}}else if(s instanceof zQ.c||1===s.length&&s[0]instanceof zQ.c){if(PQ._DeduceAnimationInfo(F.animation)){const X=s instanceof zQ.c?s:s[0];if(X){const C=Q.morphTargetManagers.find((Q=>{for(let C=0;C<Q.numTargets;++C)if(Q.getTarget(C)===X)return!0;return!1}));if(C){const l=Q.meshes.find((Q=>Q.morphTargetManager===C));var U;if(l)L.has(l)||L.set(l,new Map),null===(U=L.get(l))||void 0===U||U.set(X,z),a.add(l),i.set(l,z)}}}}}a.forEach((Q=>{const X=Q.morphTargetManager;let O=null;const m=[],U=i.get(Q).getKeys(),a=U.length;for(let C=0;C<a;++C)for(let l=0;l<X.numTargets;++l){const h=X.getTarget(l),M=L.get(Q);if(M){const X=M.get(h);X?(O||(O=new sQ.e(`${w.name}_${Q.name}_MorphWeightAnimation`,"influence",X.framePerSecond,sQ.e.ANIMATIONTYPE_FLOAT,X.loopMode,X.enableBlending)),m.push(X.getKeys()[C])):m.push({frame:w.from+F/a*C,value:h.influence,inTangent:U[0].inTangent?0:void 0,outTangent:U[0].outTangent?0:void 0})}}O.setKeys(m);const s=PQ._DeduceAnimationInfo(O);s&&PQ._AddAnimation(`${w.name}_${Q.name}_MorphWeightAnimation`,W,Q,O,s.dataAccessorType,s.animationChannelTargetPath,C,l,h,M,s.useQuaternion,f,!1,null===X||void 0===X?void 0:X.numTargets)})),W.channels.length&&W.samplers.length&&X.push(W)}}}static _AddAnimation(Q,X,C,h,M,f,O,m,W,U,L,w,i,a){const F=PQ._CreateNodeAnimation(C,h,f,L,w);let s,z,x,r,P,j;if(F){if(a){let Q=0,X=0;const C=[];for(;F.inputs.length>0;)X=F.inputs.shift(),Q%a==0&&C.push(X),Q++;F.inputs=C}const Q=O.get(C),h=new Float32Array(F.inputs);s=m.createBufferView(h),z=m.createAccessor(s,"SCALAR",5126,F.inputs.length,void 0,{min:[F.inputsMin],max:[F.inputsMax]}),U.push(z),x=U.length-1;const W=new l.c,L=new l.k,w=new l.k,v=C instanceof wQ.d,Z=t(M),g=new Float32Array(F.outputs.length*Z);F.outputs.forEach((function(Q,X){let C=Q;switch(f){case"translation":i&&(l.k.FromArrayToRef(Q,0,w),u(w),w.toArray(C));break;case"rotation":4===Q.length?l.c.FromArrayToRef(Q,0,W):(C=new Array(4),l.k.FromArrayToRef(Q,0,L),l.c.FromEulerVectorToRef(L,W)),i&&(V(W),v&&d(W)),W.toArray(C)}g.set(C,X*Z)})),s=m.createBufferView(g),z=m.createAccessor(s,M,5126,F.outputs.length),U.push(z),r=U.length-1,P={interpolation:F.samplerInterpolation,input:x,output:r},X.samplers.push(P),j={sampler:X.samplers.length-1,target:{node:Q,path:f}},X.channels.push(j)}}static _CreateBakedAnimation(Q,X,C,M,f,O,m,W,U,L,w){let i;const a=l.c.Identity();let F,s=null,z=null,x=null,r=null,P=null,j=null;L.min=h.i.FloatRound(M/O);const v=X.getKeys();for(let l=0,Z=v.length;l<Z;++l){if(j=null,x=v[l],l+1<Z)if(r=v[l+1],x.value.equals&&x.value.equals(r.value)||x.value===r.value){if(0!==l)continue;j=x.frame}else j=r.frame;else{if(P=v[l-1],x.value.equals&&x.value.equals(P.value)||x.value===P.value)continue;j=f}if(j)for(let l=x.frame;l<=j;l+=m){if(F=h.i.FloatRound(l/O),F===s)continue;s=F,z=F;const M={key:0,repeatCount:0,loopMode:X.loopMode};i=X._interpolate(l,M),PQ._SetInterpolatedValue(Q,i,F,X,C,a,W,U,w)}}z&&(L.max=z)}static _ConvertFactorToVector3OrQuaternion(Q,X,C,M,f){const O=PQ._GetBasePositionRotationOrScale(X,M,f),m=C.targetProperty.split("."),W=m?m[1]:"",U=f?l.c.Wj(O).normalize():l.k.Wj(O);switch(W){case"x":case"y":case"z":U[W]=Q;break;case"w":U.w=Q;break;default:h.i.Error(`glTFAnimation: Unsupported component name "${W}"!`)}return U}static _SetInterpolatedValue(Q,X,C,h,M,f,O,m,W){let U;O.push(C),"weights"!==M?(h.dataType===sQ.e.ANIMATIONTYPE_FLOAT&&(X=this._ConvertFactorToVector3OrQuaternion(X,Q,h,M,W)),"rotation"===M?(W?f=X:(U=X,l.c.RotationYawPitchRollToRef(U.y,U.x,U.z,f)),m.push(f.dk())):(U=X,m.push(U.dk()))):m.push([X])}static _CreateLinearOrStepAnimation(Q,X,C,l,h,M){for(const f of X.getKeys())l.push(f.frame/X.framePerSecond),PQ._AddKeyframeValue(f,X,h,C,Q,M)}static _CreateCubicSplineAnimation(Q,X,C,l,h,M){X.getKeys().forEach((function(f){l.push(f.frame/X.framePerSecond),PQ._AddSplineTangent(LQ.INTANGENT,h,C,"CUBICSPLINE",f,M),PQ._AddKeyframeValue(f,X,h,C,Q,M),PQ._AddSplineTangent(LQ.OUTTANGENT,h,C,"CUBICSPLINE",f,M)}))}static _GetBasePositionRotationOrScale(Q,X,C){let h;if("rotation"===X)if(C){h=(Q.rotationQuaternion??l.c.Identity()).dk()}else{h=(Q.rotation??l.k.Zero()).dk()}else if("translation"===X){h=(Q.position??l.k.Zero()).dk()}else{h=(Q._c??l.k.One()).dk()}return h}static _AddKeyframeValue(Q,X,C,M,f,O){let m;const W=X.dataType;if(W===sQ.e.ANIMATIONTYPE_VECTOR3){let X=Q.value.dk();if("rotation"===M){const Q=l.k.Wj(X);X=l.c.RotationYawPitchRoll(Q.y,Q.x,Q.z).dk()}C.push(X)}else if(W===sQ.e.ANIMATIONTYPE_FLOAT){if("weights"===M)C.push([Q.value]);else if(m=this._ConvertFactorToVector3OrQuaternion(Q.value,f,X,M,O),m){if("rotation"===M){const Q=O?m:l.c.RotationYawPitchRoll(m.y,m.x,m.z).normalize();C.push(Q.dk())}C.push(m.dk())}}else W===sQ.e.ANIMATIONTYPE_QUATERNION?C.push(Q.value.normalize().dk()):h.i.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Q,X,C){let l,h,M=!1;if("rotation"===X&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let f=0,O=Q.length;f<O;++f)if(h=Q[f],h.inTangent||h.outTangent)if(l){if("CUBICSPLINE"!==l){l="LINEAR",M=!0;break}}else l="CUBICSPLINE";else if(l){if("CUBICSPLINE"===l||h.interpolation&&1===h.interpolation&&"STEP"!==l){l="LINEAR",M=!0;break}}else l=h.interpolation&&1===h.interpolation?"STEP":"LINEAR";return l||(l="LINEAR"),{interpolationType:l,shouldBakeAnimation:M}}static _AddSplineTangent(Q,X,C,h,M,f){let O;const m=Q===LQ.INTANGENT?M.inTangent:M.outTangent;if("CUBICSPLINE"===h){if("rotation"===C)if(m)if(f)O=m.dk();else{const Q=m;O=l.c.RotationYawPitchRoll(Q.y,Q.x,Q.z).dk()}else O=[0,0,0,0];else O="weights"===C?m?[m]:[0]:m?m.dk():[0,0,0];X.push(O)}}static _CalculateMinMaxKeyFrames(Q){let X=1/0,C=-1/0;return Q.forEach((function(Q){X=Math.min(X,Q.frame),C=Math.max(C,Q.frame)})),{min:X,max:C}}}function jQ(Q,X,C,M,f,O){const m={attributes:{},influence:Q.influence,name:Q.name},W=X.ik;if(!W)return h.i.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),m;const L=O?-1:1,w=l.k.Zero();let i=0,a=0;if(Q.hasPositions){const M=Q.getPositions(),O=W.getVerticesData(U.g.PositionKind);if(O){const Q=new Float32Array(O.length),X=[1/0,1/0,1/0],h=[-1/0,-1/0,-1/0];a=O.length/3,i=0;for(let C=i;C<a;++C){const f=l.k.Wj(O,3*C);l.k.Wj(M,3*C).subtractToRef(f,w),w.x*=L,X[0]=Math.min(X[0],w.x),h[0]=Math.max(h[0],w.x),X[1]=Math.min(X[1],w.y),h[1]=Math.max(h[1],w.y),X[2]=Math.min(X[2],w.z),h[2]=Math.max(h[2],w.z),Q[3*C]=w.x,Q[3*C+1]=w.y,Q[3*C+2]=w.z}const W=C.createBufferView(Q,12),U=C.createAccessor(W,"VEC3",5126,M.length/3,0,{min:X,max:h});f.push(U),m.attributes.POSITION=f.length-1}else h.i.Warn(`Morph target positions for mesh ${X.name} were not exported. Mesh does not have position vertex data`)}if(Q.hasNormals){const M=Q.getNormals(),O=W.getVerticesData(U.g.NormalKind);if(O){const Q=new Float32Array(O.length);a=O.length/3,i=0;for(let C=i;C<a;++C){const X=l.k.Wj(O,3*C).normalize();l.k.Wj(M,3*C).normalize().subtractToRef(X,w),Q[3*C]=w.x*L,Q[3*C+1]=w.y,Q[3*C+2]=w.z}const X=C.createBufferView(Q,12),h=C.createAccessor(X,"VEC3",5126,M.length/3,0);f.push(h),m.attributes.NORMAL=f.length-1}else h.i.Warn(`Morph target normals for mesh ${X.name} were not exported. Mesh does not have normals vertex data`)}if(Q.hasTangents){const M=Q.getTangents(),O=W.getVerticesData(U.g.TangentKind);if(O){a=O.length/4;const Q=new Float32Array(3*a);i=0;for(let C=i;C<a;++C){const X=l.k.Wj(O,4*C);D(X);const h=l.k.Wj(M,3*C);D(h),h.subtractToRef(X,w),Q[3*C]=w.x*L,Q[3*C+1]=w.y,Q[3*C+2]=w.z}const X=C.createBufferView(Q,12),h=C.createAccessor(X,"VEC3",5126,a,0);f.push(h),m.attributes.TANGENT=f.length-1}else h.i.Warn(`Morph target tangents for mesh ${X.name} were not exported. Mesh does not have tangents vertex data`)}if(Q.hasColors){const M=Q.getColors(),O=W.getVerticesData(U.g.ColorKind),L=W.getVertexBuffer(U.g.ColorKind);if(O&&L){const Q=L.getSize();a=O.length/Q;const X=new Float32Array(a*Q);i=0;for(let C=i;C<a;++C)if(3===Q){const h=l.k.Wj(O,C*Q);l.k.Wj(M,C*Q).subtractToRef(h,w),X[3*C]=w.x,X[3*C+1]=w.y,X[3*C+2]=w.z}else if(4===Q){const h=new l.o,f=l.o.Wj(O,C*Q);l.o.Wj(M,C*Q).subtractToRef(f,h),X[4*C]=h.x,X[4*C+1]=h.y,X[4*C+2]=h.z,X[4*C+3]=h.w}else h.i.Warn(`Unsupported number of components for color attribute: ${Q}`);const W=C.createBufferView(X,4*Q),U=C.createAccessor(W,3===Q?"VEC3":"VEC4",5126,a,0);f.push(U),m.attributes.COLOR_0=f.length-1}else h.i.Warn(`Morph target colors for mesh ${X.name} were not exported. Mesh does not have colors vertex data`)}return m}var vQ=C(12244),ZQ=C(12179),gQ=C(12174),SQ=C(620);class eQ{}eQ.DEFAULT_COLOR=s.b.White(),eQ.DEFAULT_WIDTH_ATTENUATED=1,eQ.DEFAULT_WIDTH=.1;var kQ=C(2365),RQ=C(12253);class HQ{static ConvertPoints(Q,X){if(Q.length&&Array.isArray(Q)&&"number"===typeof Q[0])return[Q];if(Q.length&&Array.isArray(Q[0])&&"number"===typeof Q[0][0])return Q;if(Q.length&&!Array.isArray(Q[0])&&Q[0]instanceof l.k){const X=[];for(let C=0;C<Q.length;C++){const l=Q[C];X.push(l.x,l.y,l.z)}return[X]}if(Q.length>0&&Array.isArray(Q[0])&&Q[0].length>0&&Q[0][0]instanceof l.k){const X=[],C=Q;for(const Q of C)X.push(Q.flatMap((Q=>[Q.x,Q.y,Q.z])));return X}if(Q instanceof Float32Array){if(null!==X&&void 0!==X&&X.floatArrayStride){const C=[],l=3*X.floatArrayStride;for(let X=0;X<Q.length;X+=l){const h=new Array(l);for(let C=0;C<l;C++)h[C]=Q[X+C];C.push(h)}return C}return[Array.from(Q)]}if(Q.length&&Q[0]instanceof Float32Array){const X=[];for(const C of Q)X.push(Array.from(C));return X}return[]}static OmitZeroLengthPredicate(Q,X,C){const l=[];return X.Od(Q).lengthSquared()>0&&l.push([Q,X]),C.Od(X).lengthSquared()>0&&l.push([X,C]),Q.Od(C).lengthSquared()>0&&l.push([C,Q]),0===l.length?null:l}static OmitDuplicatesPredicate(Q,X,C,l){const h=[];return HQ._SearchInPoints(Q,X,l)||h.push([Q,X]),HQ._SearchInPoints(X,C,l)||h.push([X,C]),HQ._SearchInPoints(C,Q,l)||h.push([C,Q]),0===h.length?null:h}static _SearchInPoints(Q,X,C){for(const f of C)for(let C=0;C<f.length;C++){var l,h,M;if(null!==(l=f[C])&&void 0!==l&&l.equals(Q))if(null!==(h=f[C+1])&&void 0!==h&&h.equals(X)||null!==(M=f[C-1])&&void 0!==M&&M.equals(X))return!0}return!1}static MeshesToLines(Q,X){const C=[];for(let h=0;h<Q.length;h++){const M=Q[h],f=M.getVerticesData(U.g.PositionKind),O=M.Xj();if(f&&O)for(let Q=0,m=0;Q<O.length;Q++){const W=3*O[m++],U=3*O[m++],L=3*O[m++],w=new l.k(f[W],f[W+1],f[W+2]),i=new l.k(f[U],f[U+1],f[U+2]),a=new l.k(f[L],f[L+1],f[L+2]);if(X){const l=X(w,i,a,C,Q,W,M,h,f,O);if(l)for(const Q of l)C.push(Q)}else C.push([w,i],[i,a],[a,w])}}return C}static ToVector3Array(Q){if(Array.isArray(Q[0])){const X=[],C=Q;for(const Q of C){const C=[];for(let X=0;X<Q.length;X+=3)C.push(new l.k(Q[X],Q[X+1],Q[X+2]));X.push(C)}return X}const X=Q,C=[];for(let h=0;h<X.length;h+=3)C.push(new l.k(X[h],X[h+1],X[h+2]));return C}static ToNumberArray(Q){return Q.flatMap((Q=>[Q.x,Q.y,Q.z]))}static GetPointsCountInfo(Q){const X=new Array(Q.length);let C=0;for(let l=Q.length;l--;)X[l]=Q[l].length/3,C+=X[l];return{total:C,counts:X}}static GetLineLength(Q){if(0===Q.length)return 0;let X;X="number"===typeof Q[0]?HQ.ToVector3Array(Q):Q;const C=l.e.Yj[0];let h=0;for(let l=0;l<X.length-1;l++){const Q=X[l];h+=X[l+1].subtractToRef(Q,C).length()}return h}static GetLineLengthArray(Q){const X=new Float32Array(Q.length/3);let C=0;for(let l=0,h=Q.length/3-1;l<h;l++){let h=Q[3*l+0],M=Q[3*l+1],f=Q[3*l+2];h-=Q[3*l+3],M-=Q[3*l+4],f-=Q[3*l+5];C+=Math.sqrt(h*h+M*M+f*f),X[l+1]=C}return X}static SegmentizeSegmentByCount(Q,X,C){const h=[],M=X.Od(Q),f=l.e.Yj[0];f.Zj(C);const O=l.e.Yj[1];M.divideToRef(f,O);let m=Q.clone();h.push(m);for(let l=0;l<C;l++)m=m.clone(),h.push(m.addInPlace(O));return h}static SegmentizeLineBySegmentLength(Q,X){const C=Q[0]instanceof l.k?HQ.GetLineSegments(Q):"number"===typeof Q[0]?HQ.GetLineSegments(HQ.ToVector3Array(Q)):Q,h=[];for(const l of C)if(l.length>X){const Q=HQ.SegmentizeSegmentByCount(l.point1,l.point2,Math.ceil(l.length/X));for(const X of Q)h.push(X)}else h.push(l.point1),h.push(l.point2);return h}static SegmentizeLineBySegmentCount(Q,X){const C="number"===typeof Q[0]?HQ.ToVector3Array(Q):Q,l=HQ.GetLineLength(C)/X;return HQ.SegmentizeLineBySegmentLength(C,l)}static GetLineSegments(Q){const X=[];for(let C=0;C<Q.length-1;C++){const l=Q[C],h=Q[C+1],M=h.Od(l).length();X.push({point1:l,point2:h,length:M})}return X}static GetMinMaxSegmentLength(Q){const X=HQ.GetLineSegments(Q).sort((Q=>Q.length));return{min:X[0].length,max:X[X.length-1].length}}static GetPositionOnLineByVisibility(Q,X,C){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const M=X*C;let f=0,O=0;const m=Q.length;for(let l=0;l<m;l++){if(M<=f+Q[l].length){O=l;break}f+=Q[l].length}const W=(M-f)/Q[O].length;return Q[O].point2.subtractToRef(Q[O].point1,l.e.Yj[0]),l.e.Yj[1]=l.e.Yj[0].multiplyByFloats(W,W,W),h||l.e.Yj[1].addInPlace(Q[O].point1),l.e.Yj[1].clone()}static GetCircleLinePoints(Q,X){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Q,M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/X;const f=[];for(let O=0;O<=X;O++)f.push(new l.k(Math.cos(O*M)*Q,Math.sin(O*M)*h,C));return f}static GetBezierLinePoints(Q,X,C,l){return kQ.g.CreateQuadraticBezier(Q,X,C,l).getPoints().flatMap((Q=>[Q.x,Q.y,Q.z]))}static GetArrowCap(Q,X,C,l,h){let M=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Q.clone(),Q.add(X.multiplyByFloats(C,C,C))],widths:[l,h,M,f]}}static GetPointsFromText(Q,X,C,l){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,M=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const f=[],O=(0,RQ.e)(Q,X,C,l);for(const m of O){for(const Q of m.paths){const X=[],C=Q.getPoints();for(const Q of C)X.push(Q.x,Q.y,h);f.push(X)}if(M)for(const Q of m.holes){const X=[],C=Q.getPoints();for(const Q of C)X.push(Q.x,Q.y,h);f.push(X)}}return f}static Color3toRGBAUint8(Q){const X=new Uint8Array(4*Q.length);for(let C=0,l=0;C<Q.length;C++)X[l++]=255*Q[C].r,X[l++]=255*Q[C].g,X[l++]=255*Q[C].b,X[l++]=255;return X}static CreateColorsTexture(Q,X,C,l){const h=l.getEngine().getCaps().maxTextureSize??1,M=X.length>h?h:X.length,f=Math.ceil(X.length/h);f>1&&(X=[...X,...Array(M*f-X.length).fill(X[0])]);const O=HQ.Color3toRGBAUint8(X),m=new v.b(O,M,f,a.e.TEXTUREFORMAT_RGBA,l,!1,!0,C);return m.name=Q,m}static PrepareEmptyColorsTexture(Q){if(!eQ.EmptyColorsTexture){const X=new Uint8Array(4);eQ.EmptyColorsTexture=new v.b(X,1,1,a.e.TEXTUREFORMAT_RGBA,Q,!1,!1,v.b.NEAREST_NEAREST),eQ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return eQ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Q;null===(Q=eQ.EmptyColorsTexture)||void 0===Q||Q.dispose(),eQ.EmptyColorsTexture=null}static BooleanToNumber(Q){return Q?1:0}}class oQ extends gQ.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class TQ extends ZQ.d{isCompatible(Q){return!0}constructor(Q,X,C){var h;C=C||{color:eQ.DEFAULT_COLOR};const M=new oQ;M.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,M.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,M.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,M.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(X??Q.va()).useRightHandedSystem,M.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(Q,TQ.GREASED_LINE_MATERIAL_NAME,200,M,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(h=C)||void 0===h?void 0:h.forceGLSL)||TQ.ForceGLSL,this._scene=X??Q.va(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?eQ.DEFAULT_WIDTH_ATTENUATED:eQ.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??v.b.NEAREST_NEAREST,this._colors=C.za??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new l.h(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=HQ.CreateColorsTexture(`${Q.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??eQ.DEFAULT_COLOR,HQ.PrepareEmptyColorsTexture(this._scene)),this._engine.bk.add((()=>{HQ.DisposeEmptyColorsTexture()}))}getAttributes(Q){Q.push("grl_offsets"),Q.push("grl_widths"),Q.push("grl_colorPointers"),Q.push("grl_counters"),this._cameraFacing?(Q.push("grl_previousAndSide"),Q.push("grl_nextAndCounters")):Q.push("grl_slopes")}getSamplers(Q){Q.push("grl_colors")}getActiveTextures(Q){this.colorsTexture&&Q.push(this.colorsTexture)}getUniforms(){let Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const X=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&X.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Q&&X.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:X,vertex:this._cameraFacing&&this._isGLSL(Q)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Q)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Q){if(this._cameraFacing){Q.jk("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Q.jk("viewProjection",this._scene.getTransformMatrix());const X=l.e.Vector4[0];X.x=this._aspect,X.y=this._resolution.x,X.z=this._resolution.y,X.w=this.width,Q.updateVector4("grl_aspect_resolution_lineWidth",X)}const X=l.e.Vector4[0];X.x=HQ.BooleanToNumber(this.useDash),X.y=this._dashArray,X.z=this.dashOffset,X.w=this.dashRatio,Q.updateVector4("grl_dashOptions",X);const C=l.e.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=HQ.BooleanToNumber(this.useColors),Q.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&Q.updateColor3("grl_singleColor",this._color);const h=this.colorsTexture??eQ.EmptyColorsTexture;Q.setTexture("grl_colors",h),Q.updateFloat2("grl_textureSize",(null===h||void 0===h?void 0:h.getSize().width)??1,(null===h||void 0===h?void 0:h.getSize().height)??1)}prepareDefines(Q,X,C){Q.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Q.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=X.useRightHandedSystem,Q.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Q.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return TQ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Q){let X=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(X)?function(Q,X){if("vertex"===Q){const Q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return X&&(Q["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Q}return"fragment"===Q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Q,this._cameraFacing):function(Q,X){if("vertex"===Q){const Q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return X&&(Q["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Q}return"fragment"===Q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Q,this._cameraFacing)}dispose(){var Q;null===(Q=this.colorsTexture)||void 0===Q||Q.dispose(),super.dispose()}get za(){return this._colors}set za(Q){this.setColors(Q)}setColors(Q){var X;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var M;if(this._colors=Q,null!==Q&&0!==Q.length){if(!C||l)if(this.colorsTexture&&h===Q.length&&!l){const X=HQ.Color3toRGBAUint8(Q);this.colorsTexture.update(X)}else{var f;null===(f=this.colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=HQ.CreateColorsTexture(`${this._material.name}-colors-texture`,Q,this.colorsSampling,this._scene)}}else null===(M=this.colorsTexture)||void 0===M||M.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Q){this._dashCount=Q,this._dashArray=1/Q}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Q){this._sizeAttenuation=Q,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Q){this.setColor(Q)}setColor(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Q||null!==this._color&&null===Q?(this._color=Q,X||this.markAllDefinesAsDirty()):this._color=Q}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Q){this._colorsDistributionType=Q,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Q){this._aspect=Q.x/Q.y,this._resolution=Q}serialize(){const Q=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(X.za=this._colors),this._color&&(X.color=this._color),Q.greasedLineMaterialOptions=X,Q}parse(Q,X,C){var l;super.parse(Q,X,C);const h=Q.greasedLineMaterialOptions;null===(l=this.colorsTexture)||void 0===l||l.dispose(),h.color&&this.setColor(h.color,!0),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.za&&(this.za=h.za),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),this.za?this.colorsTexture=HQ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.za,this.colorsSampling,X):HQ.PrepareEmptyColorsTexture(X),this.markAllDefinesAsDirty()}copyTo(Q){var X;const C=Q;null===(X=C.colorsTexture)||void 0===X||X.dispose(),this._colors&&(C.colorsTexture=HQ.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(Q){return 0===Q||this._forceGLSL}}TQ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",TQ.ForceGLSL=!1,(0,SQ.g)(`BABYLON.${TQ.GREASED_LINE_MATERIAL_NAME}`,TQ);var YQ=C(735),JQ=C(504),KQ=C(12249),NQ=C(602);class qQ extends KQ.c{constructor(Q,X,h){const M=X.getEngine(),f=M.isWebGPU&&!(h.forceGLSL||qQ.ForceGLSL),O=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];X.useRightHandedSystem&&O.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const m=["position","grl_widths","grl_offsets","grl_colorPointers"];h.cameraFacing?(O.push("GREASED_LINE_CAMERA_FACING"),m.push("grl_previousAndSide","grl_nextAndCounters")):(m.push("grl_slopes"),m.push("grl_counters"));const W=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(f||W.push("world","viewProjection","view","projection"),super(Q,X,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:f?["Scene","Mesh"]:void 0,attributes:m,uniforms:W,samplers:f?[]:["grlColors"],defines:O,extraInitializationsAsync:async()=>{f?await Promise.all([C.e(51).then(C.bind(C,14212)),C.e(59).then(C.bind(C,14218))]):await Promise.all([C.e(54).then(C.bind(C,14223)),C.e(60).then(C.bind(C,14226))])},shaderLanguage:f?1:0}),this._color=s.b.White(),this._colorsDistributionType=0,this._colorsTexture=null,h=h||{color:eQ.DEFAULT_COLOR},this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.dashCount=h.dashCount??1,this.width=h.width?h.width:h.sizeAttenuation&&h.cameraFacing?eQ.DEFAULT_WIDTH_ATTENUATED:eQ.DEFAULT_WIDTH,this.sizeAttenuation=h.sizeAttenuation??!1,this.color=h.color??s.b.White(),this.useColors=h.useColors??!1,this.colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??v.b.NEAREST_NEAREST,this.colorMode=h.colorMode??0,this._colors=h.za??null,this._cameraFacing=h.cameraFacing??!0,this.resolution=h.resolution??new l.h(M.getRenderWidth(),M.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=HQ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,X):(this._color=this._color??eQ.DEFAULT_COLOR,this.colorsTexture=HQ.PrepareEmptyColorsTexture(X)),f){const Q=new NQ.c;Q.setParameters(),Q.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Q)}M.bk.add((()=>{HQ.DisposeEmptyColorsTexture()}))}dispose(){var Q;null===(Q=this._colorsTexture)||void 0===Q||Q.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new l.h(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get za(){return this._colors}set za(Q){this.setColors(Q)}setColors(Q){var X;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(X=this._colors)||void 0===X?void 0:X.length)??0;var M;if(this._colors=Q,null!==Q&&0!==Q.length){if(!C||l)if(this._colorsTexture&&h===Q.length&&!l){const X=HQ.Color3toRGBAUint8(Q);this._colorsTexture.update(X)}else{var f;null===(f=this._colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=HQ.CreateColorsTexture(`${this.name}-colors-texture`,Q,this.colorsSampling,this.va())}}else null===(M=this._colorsTexture)||void 0===M||M.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Q){this._colorsTexture=Q,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Q){this._width=Q,this.setFloat("grlWidth",Q)}get useColors(){return this._useColors}set useColors(Q){this._useColors=Q,this.setFloat("grlUseColors",HQ.BooleanToNumber(Q))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Q){this._colorsSampling=Q}get visibility(){return this._visibility}set visibility(Q){this._visibility=Q,this.setFloat("grlVisibility",Q)}get useDash(){return this._useDash}set useDash(Q){this._useDash=Q,this.setFloat("grlUseDash",HQ.BooleanToNumber(Q))}get dashOffset(){return this._dashOffset}set dashOffset(Q){this._dashOffset=Q,this.setFloat("grlDashOffset",Q)}get dashRatio(){return this._dashRatio}set dashRatio(Q){this._dashRatio=Q,this.setFloat("grlDashRatio",Q)}get dashCount(){return this._dashCount}set dashCount(Q){this._dashCount=Q,this._dashArray=1/Q,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Q){this._sizeAttenuation=Q,this.setFloat("grlSizeAttenuation",HQ.BooleanToNumber(Q))}get color(){return this._color}set color(Q){this.setColor(Q)}setColor(Q){Q=Q??eQ.DEFAULT_COLOR,this._color=Q,this.setColor3("grlColor",Q)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Q){this._colorsDistributionType=Q,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Q){this._colorMode=Q,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Q){this._resolution=Q,this.setVector2("grlResolution",Q),this.setFloat("grlAspect",Q.x/Q.y)}serialize(){const Q=super.serialize(),X={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(X.za=this._colors),Q.greasedLineMaterialOptions=X,Q}parse(Q,X,C){var l;const h=Q.greasedLineMaterialOptions;null===(l=this._colorsTexture)||void 0===l||l.dispose(),h.color&&(this.color=h.color),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),h.za?this.colorsTexture=HQ.CreateColorsTexture(`${this.name}-colors-texture`,h.za,this.colorsSampling,this.va()):this.colorsTexture=HQ.PrepareEmptyColorsTexture(X),this._cameraFacing=h.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var nQ,cQ,EQ;qQ.ForceGLSL=!1,function(Q){Q[Q.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Q[Q.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(nQ||(nQ={})),function(Q){Q[Q.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Q[Q.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Q[Q.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(cQ||(cQ={})),function(Q){Q[Q.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Q[Q.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Q[Q.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Q[Q.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Q[Q.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(EQ||(EQ={}));class BQ extends xQ.c{constructor(Q,X,C){super(Q,X,null,null,!1,!1),this.name=Q,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=X.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Q){let X=0;for(const l of this._points)X+=l.length;const C=X/3*2-this._widths.length;for(let l=0;l<C;l++)this._widths.push(Q)}updateLazy(){var Q,X;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Q=this._options.ribbonOptions)||void 0===Q?void 0:Q.smoothShading),!this.Da&&this.refreshBoundingInfo(),null===(X=this.greasedLineMaterial)||void 0===X||X.updateLazy()}addPoints(Q,X){for(const C of Q)this._points.push(C);this._lazy||this.setPoints(this._points,X)}dispose(Q){let X=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Q,X)}isLazy(){return this._lazy}get Aa(){return this._uvs}set Aa(Q){this._uvs=Q instanceof Float32Array?Q:new Float32Array(Q),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Q){this.material instanceof qQ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Q||void 0===Q?void 0:Q.length)>0),this._offsets=Q,this._offsetsBuffer?this._offsetsBuffer.update(Q):this._createOffsetsBuffer(Q)}get widths(){return this._widths}set widths(Q){this._widths=Q,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Q)}get colorPointers(){return this._colorPointers}set colorPointers(Q){this._colorPointers=Q,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Q)}get greasedLineMaterial(){var Q,X;if(this.material&&this.material instanceof qQ)return this.material;const C=null===(Q=this.material)||void 0===Q||null===(X=Q.pluginManager)||void 0===X?void 0:X.getPlugin(TQ.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const Q=[];return JQ.c.DeepCopy(this._points,Q),Q}setPoints(Q,X){this._points=HQ.ConvertPoints(Q,(null===X||void 0===X?void 0:X.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==X&&void 0!==X&&X.colorPointers||this._updateColorPointers(),this._setPoints(this._points,X)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Aa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Q){super.serialize(Q),Q.type=this.getClassName(),Q.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const X=new YQ.b;return X.xa=this._vertexPositions,X.indices=this._indices,X.Aa=this._uvs,Q&&(X.ya=[],YQ.b.ComputeNormals(this._vertexPositions,this._indices,X.ya)),X.Ca(this,this._options.updatable),X}_createOffsetsBuffer(Q){const X=this._scene.getEngine(),C=new U.e(X,Q,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class GQ{constructor(Q,X){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Q,this.wasAddedByNoopNode=X}getIndicesAccessor(Q,X,C,l,h){var M,f,O,m;return null===(M=this._indicesAccessorMap.get(Q))||void 0===M||null===(f=M.get(X))||void 0===f||null===(O=f.get(C))||void 0===O||null===(m=O.get(l))||void 0===m?void 0:m.get(h)}setIndicesAccessor(Q,X,C,l,h,M){let f=this._indicesAccessorMap.get(Q);f||(f=new Map,this._indicesAccessorMap.set(Q,f));let O=f.get(X);O||(O=new Map,f.set(X,O));let m=O.get(C);m||(m=new Map,O.set(C,m));let W=m.get(l);W||(W=new Map,m.set(l,W)),W.set(h,M)}pushExportedNode(Q){this._exportedNodes.has(Q)||this._exportedNodes.add(Q)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Q){return this._vertexBufferViewMap.get(Q)}setVertexBufferView(Q,X){this._vertexBufferViewMap.set(Q,X)}setRemappedBufferView(Q,X,C){this._remappedBufferView.set(Q,new Map),this._remappedBufferView.get(Q).set(X,C)}getRemappedBufferView(Q,X){var C;return null===(C=this._remappedBufferView.get(Q))||void 0===C?void 0:C.get(X)}getVertexAccessor(Q,X,C){var l,h;return null===(l=this._vertexAccessorMap.get(Q))||void 0===l||null===(h=l.get(X))||void 0===h?void 0:h.get(C)}setVertexAccessor(Q,X,C,l){let h=this._vertexAccessorMap.get(Q);h||(h=new Map,this._vertexAccessorMap.set(Q,h));let M=h.get(X);M||(M=new Map,h.set(X,M)),M.set(C,l)}hasVertexColorAlpha(Q){return this._vertexMapColorAlpha.get(Q)||!1}setHasVertexColorAlpha(Q,X){return this._vertexMapColorAlpha.set(Q,X)}getMesh(Q){return this._meshMap.get(Q)}setMesh(Q,X){this._meshMap.set(Q,X)}bindMorphDataToMesh(Q,X){const C=this._meshMorphTargetMap.get(Q)||[];this._meshMorphTargetMap.set(Q,C),-1===C.indexOf(X)&&C.push(X)}getMorphTargetsFromMesh(Q){return this._meshMorphTargetMap.get(Q)}}class bQ{_ApplyExtension(Q,X,C,l){if(C>=X.length)return Promise.resolve(Q);const h=l(X[C],Q);return h?h.then((async Q=>Q?await this._ApplyExtension(Q,X,C+1,l):null)):this._ApplyExtension(Q,X,C+1,l)}_ApplyExtensions(Q,X){const C=[];for(const l of bQ._ExtensionNames)C.push(this._extensions[l]);return this._ApplyExtension(Q,C,0,X)}_extensionsPreExportTextureAsync(Q,X,C){return this._ApplyExtensions(X,((X,l)=>X.preExportTextureAsync&&X.preExportTextureAsync(Q,l,C)))}_extensionsPostExportNodeAsync(Q,X,C,l,h){return this._ApplyExtensions(X,((X,M)=>X.postExportNodeAsync&&X.postExportNodeAsync(Q,M,C,l,h,this._bufferManager)))}_extensionsPostExportMaterialAsync(Q,X,C){return this._ApplyExtensions(X,((X,l)=>X.postExportMaterialAsync&&X.postExportMaterialAsync(Q,l,C)))}_extensionsPostExportMaterialAdditionalTextures(Q,X,C){const l=[];for(const h of bQ._ExtensionNames){const M=this._extensions[h];M.postExportMaterialAdditionalTextures&&l.push(...M.postExportMaterialAdditionalTextures(Q,X,C))}return l}_extensionsPostExportTextures(Q,X,C){for(const l of bQ._ExtensionNames){const h=this._extensions[l];h.postExportTexture&&h.postExportTexture(Q,X,C)}}_extensionsPostExportMeshPrimitive(Q){for(const X of bQ._ExtensionNames){const C=this._extensions[X];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(Q,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Q of bQ._ExtensionNames){const X=this._extensions[Q];X.preGenerateBinaryAsync&&await X.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Q){for(const X of bQ._ExtensionNames){const C=this._extensions[X];C.enabled&&Q(C)}}_extensionsOnExporting(){this._forEachExtensions((Q=>{var X,C,l;Q.wasUsed&&((X=this._glTF).extensionsUsed||(X.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Q.name)&&this._glTF.extensionsUsed.push(Q.name),Q.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Q.name)&&this._glTF.extensionsRequired.push(Q.name)),(l=this._glTF).extensions||(l.extensions={}),Q.onExporting&&Q.onExporting())}))}_loadExtensions(){for(const Q of bQ._ExtensionNames){const X=bQ._ExtensionFactories[Q](this);this._extensions[Q]=X}}constructor(){let Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:F.b.LastCreatedScene,X=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${a.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new N(this),this._extensions={},this._bufferManager=new UQ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Q)throw new Error("No scene available to export");this._babylonScene=Q,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Q=>{var X;return null===Q||void 0===Q||null===(X=Q.Hk)||void 0===X?void 0:X.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...X},this._loadExtensions()}dispose(){for(const Q in this._extensions){this._extensions[Q].dispose()}}get options(){return this._options}static RegisterExtension(Q,X){bQ.UnregisterExtension(Q)&&h.i.Warn(`Extension with the name ${Q} already exists`),bQ._ExtensionFactories[Q]=X,bQ._ExtensionNames.push(Q)}static UnregisterExtension(Q){if(!bQ._ExtensionFactories[Q])return!1;delete bQ._ExtensionFactories[Q];const X=bQ._ExtensionNames.indexOf(Q);return-1!==X&&bQ._ExtensionNames.splice(X,1),!0}_generateJSON(Q,X,C){const l={byteLength:Q};return l.byteLength&&(this._glTF.buffers=[l]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ld=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(l.uri=X+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Q){const X=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(X.byteLength,Q,!0),l=new Blob([X],{type:"application/octet-stream"}),h=Q+".gltf",M=Q+".bin",f=new W;if(f.files[h]=C,f.files[M]=l,this._imageData)for(const O in this._imageData)f.files[O]=new Blob([this._imageData[O].data],{type:this._imageData[O].mimeType});return f}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Q){const X=Q%4;return 0===X?X:4-X}async generateGLBAsync(Q){this._shouldUseGlb=!0;const X=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(X.byteLength),l=Q+".glb";let h,M=C.length;if("undefined"!==typeof TextEncoder){h=(new TextEncoder).encode(C),M=h.length}const f=this._getPadding(M),O=this._getPadding(X.byteLength),m=28+M+f+X.byteLength+O,U=new mQ(m);if(U.writeUInt32(1179937895),U.writeUInt32(2),U.writeUInt32(m),U.writeUInt32(M+f),U.writeUInt32(1313821514),h)U.writeTypedArray(h);else{const Q="_".charCodeAt(0);for(let X=0;X<M;++X){const l=C.charCodeAt(X);l!=C.codePointAt(X)?U.writeUInt8(Q):U.writeUInt8(l)}}for(let W=0;W<f;++W)U.writeUInt8(32);U.writeUInt32(X.byteLength+O),U.writeUInt32(5130562),U.writeTypedArray(X);for(let W=0;W<O;++W)U.writeUInt8(0);const L=new W;return L.files[l]=new Blob([U.getOutputData()],{type:"application/octet-stream"}),L}_setNodeTransformation(Q,X,C){if(X.getPivotPoint().equalsWithEpsilon(B,E.b)||h.i.Warn("Pivot points are not supported in the glTF serializer"),!X.position.equalsWithEpsilon(B,E.b)){const h=l.e.Yj[0].p(X.position);C&&u(h),Q.translation=h.dk()}X._c.equalsWithEpsilon(b,E.b)||(Q.scale=X._c.dk());const M=X.rotationQuaternion||l.c.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);M.equalsWithEpsilon(G,E.b)||(C&&V(M),Q.rotation=M.normalize().dk())}_setCameraTransformation(Q,X,C){if(!X.position.equalsWithEpsilon(B,E.b)){const h=l.e.Yj[0].p(X.position);C&&u(h),Q.translation=h.dk()}const h=X.rotationQuaternion||l.c.FromEulerAngles(X.rotation.x,X.rotation.y,X.rotation.z);C&&V(h),this._babylonScene.useRightHandedSystem||d(h),h.equalsWithEpsilon(G,E.b)||(Q.rotation=h.dk())}_listAvailableCameras(){for(const Q of this._babylonScene.cameras){const X={type:Q.mode===wQ.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Q.name&&(X.name=Q.name),"perspective"===X.type)X.perspective={aspectRatio:Q.getEngine().getAspectRatio(Q),yfov:Q.fovMode===wQ.d.FOVMODE_VERTICAL_FIXED?Q.fov:Q.fov*Q.getEngine().getAspectRatio(Q),znear:Q.Rj,zfar:Q.maxZ};else if("orthographic"===X.type){const C=Q.orthoLeft&&Q.orthoRight?.5*(Q.orthoRight-Q.orthoLeft):.5*Q.getEngine().getRenderWidth(),l=Q.orthoBottom&&Q.orthoTop?.5*(Q.orthoTop-Q.orthoBottom):.5*Q.getEngine().getRenderHeight();X.orthographic={xmag:C,ymag:l,znear:Q.Rj,zfar:Q.maxZ}}this._camerasMap.set(Q,X)}}_exportAndAssignCameras(){const Q=Array.from(this._camerasMap.values());for(const X of Q){const Q=this._nodesCameraMap.get(X);if(void 0!==Q){this._cameras.push(X);for(const X of Q)X.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Q of this._babylonScene.skeletons){if(Q.bones.length<=0)continue;const X={joints:[]};this._skinMap.set(Q,X)}}_exportAndAssignSkeletons(){for(const Q of this._babylonScene.skeletons){if(Q.bones.length<=0)continue;const X=this._skinMap.get(Q);if(void 0==X)continue;const C={},l=[];let M=-1;for(let h=0;h<Q.bones.length;++h){const X=Q.bones[h],l=X.getIndex()??h;-1!==l&&(C[l]=X,l>M&&(M=l))}for(let Q=0;Q<=M;++Q){const M=C[Q];l.push(M.getAbsoluteInverseBindMatrix());const f=M.getTransformNode();if(null!==f){const Q=this._nodeMap.get(f);f&&null!==Q&&void 0!==Q?X.joints.push(Q):h.i.Warn("Exporting a bone without a linked transform node is currently unsupported")}else h.i.Warn("Exporting a bone without a linked transform node is currently unsupported")}const f=this._nodesSkinMap.get(X);if(X.joints.length>0&&void 0!==f){const Q=64*l.length,C=new Float32Array(Q/4);l.forEach(((Q,X)=>{C.set(Q.m,16*X)}));const h=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(h,"MAT4",5126,l.length)),X.inverseBindMatrices=this._accessors.length-1,this._skins.push(X);for(const X of f)X.skin=this._skins.length-1}}}async _exportSceneAsync(){const Q={nodes:[]};if(this._babylonScene.metadata){const X=this._options.metadataSelector(this._babylonScene.metadata);X&&(Q.extras=X)}const X=new Array,C=new Array,l=new Array;for(const O of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&fQ(O,this._babylonScene.useRightHandedSystem)?l.push(...O.getChildren()):this._babylonScene.useRightHandedSystem?X.push(O):C.push(O);this._listAvailableCameras(),this._listAvailableSkeletons();const h=new GQ(!0,!1);Q.nodes.push(...await this._exportNodesAsync(C,h));const M=new GQ(!1,!1);Q.nodes.push(...await this._exportNodesAsync(X,M));const f=new GQ(!1,!0);Q.nodes.push(...await this._exportNodesAsync(l,f)),Q.nodes.length&&this._scenes.push(Q),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&PQ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Q){let X=this._shouldExportNodeMap.get(Q);return void 0===X&&(X=this._options.shouldExportNode(Q),this._shouldExportNodeMap.set(Q,X)),X}async _exportNodesAsync(Q,X){const C=new Array;this._exportBuffers(Q,X);for(const l of Q)await this._exportNodeAsync(l,C,X);return C}_collectBuffers(Q,X,C,l,h){if(this._shouldExportNode(Q)&&Q instanceof w.d&&Q.ik){const M=Q.ik.getVertexBuffers();if(M)for(const l in M){if(!y(l))continue;const f=M[l];h.setHasVertexColorAlpha(f,Q.hasVertexAlpha);const O=f._buffer,m=X.get(O)||[];X.set(O,m),-1===m.indexOf(f)&&m.push(f);const W=C.get(f)||[];C.set(f,W),-1===W.indexOf(Q)&&W.push(Q)}const f=Q.morphTargetManager;if(f)for(let X=0;X<f.numTargets;X++){const C=f.getTarget(X),h=l.get(C)||[];l.set(C,h),-1===h.indexOf(Q)&&h.push(Q)}}for(const M of Q.getChildren())this._collectBuffers(M,X,C,l,h)}_exportBuffers(Q,X){const C=new Map,l=new Map,h=new Map;for(const O of Q)this._collectBuffers(O,C,l,h,X);const M=Array.from(C.keys());for(const O of M){const Q=O.getData();if(!Q)throw new Error("Buffer data is not available");const h=C.get(O);if(!h)continue;const M=h[0].byteStride;if(h.some((Q=>Q.byteStride!==M)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const f=CQ(Q).slice();for(const X of h){const Q=l.get(X),{byteOffset:C,byteStride:h,componentCount:M,type:O,count:m,normalized:W,kind:L}=I(X,Q);switch(L){case U.g.NormalKind:case U.g.TangentKind:(0,q.j)(f,C,h,M,O,m,W,(Q=>{const X=Math.sqrt(Q[0]*Q[0]+Q[1]*Q[1]+Q[2]*Q[2]);if(X>0){const C=1/X;Q[0]*=C,Q[1]*=C,Q[2]*=C}}));break;case U.g.ColorKind:{const X=Q.filter((Q=>Q.material instanceof FQ.b||null==Q.material)).length;if(0==X)break;if(X!=Q.length){n.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}O==U.g.UNSIGNED_BYTE&&n.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const l=new s.b,L=new s.d,w=this._babylonScene.getEngine().useExactSrgbConversions;(0,q.j)(f,C,h,M,O,m,W,(Q=>{3===Q.length?(l.Pd(Q,0),l.toLinearSpaceToRef(l,w),l.toArray(Q,0)):(L.Pd(Q,0),L.toLinearSpaceToRef(L,w),L.toArray(Q,0))}))}}}if(X.convertToRightHanded){for(const Q of h){const X=l.get(Q),{byteOffset:C,byteStride:h,componentCount:M,type:O,count:m,normalized:W,kind:L}=I(Q,X);switch(L){case U.g.PositionKind:case U.g.NormalKind:case U.g.TangentKind:(0,q.j)(f,C,h,M,O,m,W,(Q=>{Q[0]=-Q[0]}))}}X.convertedToRightHandedBuffers.set(O,f)}const m=this._bufferManager.createBufferView(f,M);X.setVertexBufferView(O,m);const W=new Map;for(const X of h){const Q=l.get(X),{kind:C,totalVertices:h}=I(X,Q);switch(C){case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:if(X.type==U.g.FLOAT){const Q=X.getFloatData(h);null!==Q&&W.set(X,Q)}}}0!==W.size&&n.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const L=Array.from(W.keys());for(const C of L){const Q=W.get(C);if(!Q)continue;const l=Q.some((Q=>Q>=256)),h=new(l?Uint16Array:Uint8Array)(Q.length);for(let X=0;X<Q.length;X++)h[X]=Q[X];const M=this._bufferManager.createBufferView(h,4*(l?2:1));X.setRemappedBufferView(O,C,M)}}const f=Array.from(h.keys());for(const O of f){const Q=h.get(O);if(!Q)continue;const C=jQ(O,Q[0],this._bufferManager,this._bufferViews,this._accessors,X.convertToRightHanded);for(const l of Q)X.bindMorphDataToMesh(l,C)}}async _exportNodeAsync(Q,X,C){let l=this._nodeMap.get(Q);if(void 0!==l)return void(X.includes(l)||X.push(l));const h=await this._createNodeAsync(Q,C);if(h){l=this._nodes.length,this._nodes.push(h),this._nodeMap.set(Q,l),C.pushExportedNode(Q),X.push(l);const M={name:"runtime animations",channels:[],samplers:[]},f=[];this._babylonScene.animationGroups.length||(PQ._CreateMorphTargetAnimationFromMorphTargetAnimations(Q,M,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),Q.animations.length&&PQ._CreateNodeAnimationFromNodeAnimations(Q,M,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),M.channels.length&&M.samplers.length&&this._animations.push(M),f.forEach((Q=>{Q.channels.length&&Q.samplers.length&&this._animations.push(Q)}))}const M=h?[]:X;for(const f of Q.getChildren())await this._exportNodeAsync(f,M,C);h&&M.length&&(h.children=M)}async _createNodeAsync(Q,X){if(!this._shouldExportNode(Q))return null;const C={};if(Q.name&&(C.name=Q.name),Q.metadata){const X=this._options.metadataSelector(Q.metadata);X&&(C.extras=X)}if(Q instanceof L.e&&(this._setNodeTransformation(C,Q,X.convertToRightHanded),Q instanceof w.d)){const h=Q instanceof i.d?Q.sourceMesh:Q;if(h.hk&&h.hk.length>0&&(C.mesh=await this._exportMeshAsync(h,X)),Q.skeleton){const X=this._skinMap.get(Q.skeleton);var l;if(void 0!==X)void 0===this._nodesSkinMap.get(X)&&this._nodesSkinMap.set(X,[]),null===(l=this._nodesSkinMap.get(X))||void 0===l||l.push(C)}}if(Q instanceof c.e){const l=this._camerasMap.get(Q);if(l){var h;void 0===this._nodesCameraMap.get(l)&&this._nodesCameraMap.set(l,[]),this._setCameraTransformation(C,Q,X.convertToRightHanded);const f=Q.parent;if(null!==f&&XQ(Q,f)){const Q=this._nodeMap.get(f);if(void 0!==Q){var M;const X=this._nodes[Q];return QQ(C,X),null===(M=this._nodesCameraMap.get(l))||void 0===M||M.push(X),null}}null===(h=this._nodesCameraMap.get(l))||void 0===h||h.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,Q,this._nodeMap,X.convertToRightHanded)?C:(n.c.Warn(`Not exporting node ${Q.name}`),null)}_exportIndices(Q,X,C,l,h,f,O,m,W){let U=Q;W.mode=A(f);const L=O!==M.e.CounterClockWiseSideOrientation,w=!m.wasAddedByNoopNode&&L,i=function(Q){switch(Q){case M.e.TriangleFillMode:case M.e.TriangleStripDrawMode:case M.e.TriangleFanDrawMode:return!0}return!1}(f)&&w;if(i){if(f===M.e.TriangleStripDrawMode||f===M.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");W.mode=A(f);const O=X?new Uint32Array(l):new Uint16Array(l);if(Q)for(let X=0;X+2<l;X+=3)O[X]=Q[C+X]+h,O[X+1]=Q[C+X+2]+h,O[X+2]=Q[C+X+1]+h;else for(let Q=0;Q+2<l;Q+=3)O[Q]=Q,O[Q+1]=Q+2,O[Q+2]=Q+1;U=O}else if(Q&&0!==h){const M=X?new Uint32Array(l):new Uint16Array(l);for(let X=0;X<l;X++)M[X]=Q[C+X]+h;U=M}if(U){let M=m.getIndicesAccessor(Q,C,l,h,i);if(void 0===M){const f=function(Q,X,C,l){if(Q instanceof Uint16Array||Q instanceof Uint32Array)return Q;if(Q instanceof Int32Array)return new Uint32Array(Q.buffer,Q.byteOffset,Q.length);const h=Q.slice(X,X+C);return l?new Uint32Array(h):new Uint16Array(h)}(U,0,l,X),O=this._bufferManager.createBufferView(f),W=X?5125:5123;this._accessors.push(this._bufferManager.createAccessor(O,"SCALAR",W,l,0)),M=this._accessors.length-1,m.setIndicesAccessor(Q,C,l,h,i,M)}W.indices=M}}_exportVertexBuffer(Q,X,C,l,h,M){const f=Q.getKind();if(!y(f))return;if(f.startsWith("uv")&&!this._options.exportUnusedUVs&&(!X||!this._materialNeedsUVsSet.has(X)))return;let O=h.getVertexAccessor(Q,C,l);if(void 0===O){const X=h.convertedToRightHandedBuffers.get(Q._buffer)||Q._buffer.getData(),M=f===U.g.PositionKind?function(Q,X,C,l){const{byteOffset:h,byteStride:M,type:f,normalized:O}=X,m=X.getSize(),W=new Array(m).fill(1/0),U=new Array(m).fill(-1/0);return(0,q.j)(Q,h+C*M,M,m,f,l*m,O,(Q=>{for(let X=0;X<m;X++)W[X]=Math.min(W[X],Q[X]),U[X]=Math.max(U[X],Q[X])})),{min:W,max:U}}(X,Q,C,l):void 0,m=(f===U.g.MatricesIndicesKind||f===U.g.MatricesIndicesExtraKind)&&Q.type===U.g.FLOAT,W=m?U.g.UNSIGNED_BYTE:Q.type,L=m?void 0:Q.normalized,w=m?h.getRemappedBufferView(Q._buffer,Q):h.getVertexBufferView(Q._buffer),i=Q.byteOffset+C*Q.byteStride;this._accessors.push(this._bufferManager.createAccessor(w,function(Q,X){if(Q==U.g.ColorKind)return X?"VEC4":"VEC3";switch(Q){case U.g.PositionKind:case U.g.NormalKind:return"VEC3";case U.g.TangentKind:case U.g.MatricesIndicesKind:case U.g.MatricesIndicesExtraKind:case U.g.MatricesWeightsKind:case U.g.MatricesWeightsExtraKind:return"VEC4";case U.g.UVKind:case U.g.UV2Kind:case U.g.UV3Kind:case U.g.UV4Kind:case U.g.UV5Kind:case U.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Q}`)}(f,h.hasVertexColorAlpha(Q)),W,l,i,M,L)),O=this._accessors.length-1,h.setVertexAccessor(Q,C,l,O)}M.attributes[function(Q){switch(Q){case U.g.PositionKind:return"POSITION";case U.g.NormalKind:return"NORMAL";case U.g.TangentKind:return"TANGENT";case U.g.ColorKind:return"COLOR_0";case U.g.UVKind:return"TEXCOORD_0";case U.g.UV2Kind:return"TEXCOORD_1";case U.g.UV3Kind:return"TEXCOORD_2";case U.g.UV4Kind:return"TEXCOORD_3";case U.g.UV5Kind:return"TEXCOORD_4";case U.g.UV6Kind:return"TEXCOORD_5";case U.g.MatricesIndicesKind:return"JOINTS_0";case U.g.MatricesIndicesExtraKind:return"JOINTS_1";case U.g.MatricesWeightsKind:return"WEIGHTS_0";case U.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Q}`)}(f)]=O}async _exportMaterialAsync(Q,X,C,l){let h=this._materialMap.get(Q);if(void 0===h){const l=X&&Object.keys(X).some((Q=>Q.startsWith("uv")));if((Q=Q instanceof iQ.e?Q.lk[C.materialIndex]:Q)instanceof aQ.b)h=await this._materialExporter.exportPBRMaterialAsync(Q,"image/png",l);else{if(!(Q instanceof FQ.b))return void n.c.Warn(`Unsupported material '${Q.name}' with type ${Q.getClassName()}`);h=await this._materialExporter.exportStandardMaterialAsync(Q,"image/png",l)}this._materialMap.set(Q,h)}l.material=h}async _exportMeshAsync(Q,X){var C;let l=X.getMesh(Q);if(void 0!==l)return l;const h={primitives:[]};l=this._meshes.length,this._meshes.push(h),X.setMesh(Q,l);const f=Q.isUnIndexed?null:Q.Xj(),O=null===(C=Q.ik)||void 0===C?void 0:C.getVertexBuffers(),m=X.getMorphTargetsFromMesh(Q),W=Q instanceof vQ.e,U=Q instanceof BQ,L=Q.hk;if(O&&L&&L.length>0)for(const a of L){const C={attributes:{}},l=a.Ha()||this._babylonScene.defaultMaterial;if(U){var w,i;const X={name:l.name},h=Q,M=s.b.White(),f=(null===(w=h.material)||void 0===w?void 0:w.alpha)??1,O=(null===(i=h.greasedLineMaterial)||void 0===i?void 0:i.color)??M;(!O.equalsWithEpsilon(M,E.b)||f<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...O.dk(),f]}),this._materials.push(X),C.material=this._materials.length-1}else if(W){const X={name:l.name},h=Q;(!h.color.equalsWithEpsilon(s.b.White(),E.b)||h.alpha<1)&&(X.pbrMetallicRoughness={baseColorFactor:[...h.color.dk(),h.alpha]}),this._materials.push(X),C.material=this._materials.length-1}else await this._exportMaterialAsync(l,O,a,C);const L=W||U?M.e.LineListDrawMode:Q.overrideRenderingFillMode??l.fillMode,F=l._getEffectiveOrientation(Q);this._exportIndices(f,f?(0,q.e)(f,a.indexCount,a.indexStart,a.verticesStart):a.verticesCount>65535,f?a.indexStart:a.verticesStart,f?a.indexCount:a.verticesCount,-a.verticesStart,L,F,X,C);for(const Q of Object.values(O))this._exportVertexBuffer(Q,l,a.verticesStart,a.verticesCount,X,C);if(m){C.targets=[];for(const Q of m)C.targets.push(Q.attributes)}h.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(m){h.weights=[],h.extras||(h.extras={}),h.extras.targetNames=[];for(const Q of m)h.weights.push(Q.influence),h.extras.targetNames.push(Q.name)}return l}}bQ._ExtensionNames=new Array,bQ._ExtensionFactories={};class pQ{static async GLTFAsync(Q,X,C){C&&C.exportWithoutWaitingForScene||await Q.whenReadyAsync();const l=new bQ(Q,C),h=await l.generateGLTFAsync(X.replace(/\.[^/.]+$/,""));return l.dispose(),h}static async GLBAsync(Q,X,C){C&&C.exportWithoutWaitingForScene||await Q.whenReadyAsync();const l=new bQ(Q,C),h=await l.generateGLBAsync(X.replace(/\.[^/.]+$/,""));return l.dispose(),h}}C(471);const IQ="EXT_mesh_gpu_instancing";class tQ{constructor(Q){this.name=IQ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Q,X,C,h,M,f){return await new Promise((Q=>{if(X&&C instanceof xQ.c&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const Q=l.k.Zero(),h=l.c.Identity(),O=l.k.One(),m=C.thinInstanceGetWorldMatrices(),W=l.e.Yj[2],U=l.e.Quaternion[1],L=l.e.Yj[3];let w=!1,i=!1,a=!1;const F=new Float32Array(3*C.Dk),s=new Float32Array(4*C.Dk),z=new Float32Array(3*C.Dk);let x=0;for(const X of m)X.decompose(L,U,W),M&&(u(W),V(U)),F.set(W.dk(),3*x),s.set(U.normalize().dk(),4*x),z.set(L.dk(),3*x),w=w||!W.equalsWithEpsilon(Q),i=i||!U.equalsWithEpsilon(h),a=a||!L.equalsWithEpsilon(O),x++;const r={attributes:{}};w&&(r.attributes.TRANSLATION=this._buildAccessor(F,"VEC3",C.Dk,f)),i&&(r.attributes.ROTATION=this._buildAccessor(s,"VEC4",C.Dk,f)),a&&(r.attributes.SCALE=this._buildAccessor(z,"VEC3",C.Dk,f)),X.extensions=X.extensions||{},X.extensions[IQ]=r}Q(X)}))}_buildAccessor(Q,X,C,l){const h=l.createBufferView(Q),M=l.createAccessor(h,X,5126,C);return this._exporter._accessors.push(M),this._exporter._accessors.length-1}}bQ.RegisterExtension(IQ,(Q=>new tQ(Q)));var yQ=C(12267),AQ=C(12270),DQ=C(12273),uQ=C(12279);function VQ(Q){return Q===DQ.d.PositionKind?"POSITION":Q===DQ.d.NormalKind?"NORMAL":Q===DQ.d.ColorKind?"COLOR":Q.startsWith(DQ.d.UVKind)?"TEX_COORD":"GENERIC"}const dQ={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class QX extends yQ.c{static get DefaultAvailable(){return(0,yQ.i)(QX.DefaultConfiguration)}static get Default(){return QX._Default??(QX._Default=new QX),QX._Default}static ResetDefault(Q){QX._Default&&(Q||QX._Default.dispose(),QX._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Q,X){return{module:await(X||DracoEncoderModule)({wasmBinary:Q})}}_getWorkerContent(){return`${AQ.j}(${AQ.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:QX.DefaultConfiguration)}async _encodeAsync(Q,X,C){const l=C?(0,uQ.d)(dQ,C):dQ;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((h,M)=>{C.push(((C,f)=>{const O=Q=>{C.removeEventListener("error",O),C.removeEventListener("message",m),M(Q),f()},m=Q=>{"encodeMeshDone"===Q.data.id&&(C.removeEventListener("error",O),C.removeEventListener("message",m),h(Q.data.encodedMeshData),f())};C.addEventListener("error",O),C.addEventListener("message",m);const W=[];for(const X of Q)W.push(X.data.buffer);X&&W.push(X.buffer),C.postMessage({id:"encodeMesh",attributes:Q,indices:X,options:l},W)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,AQ.j)(C.module,Q,X,l)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Q,X){if(0==Q.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Q instanceof xQ.c&&Q.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===X||void 0===X?void 0:X.method)&&(n.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),X.method="MESH_SEQUENTIAL_ENCODING");const C=function(Q){let X=Q.Xj(void 0,!0);return!X||X instanceof Uint32Array||X instanceof Uint16Array||(X=((0,q.e)(X,X.length)?Uint32Array:Uint16Array).from(X)),X}(Q),l=function(Q,X){const C=[];for(const l of Q.getVerticesDataKinds()){if(null!==X&&void 0!==X&&X.includes(l)){if(l===DQ.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const h=Q.getVertexBuffer(l),M=h.getSize(),f=(0,q.s)(h.getData(),M,h.type,h.byteOffset,h.byteStride,h.normalized,Q.getTotalVertices(),!0);C.push({kind:l,dracoName:VQ(l),size:M,data:f})}return C}(Q,null===X||void 0===X?void 0:X.excludedAttributes);return await this._encodeAsync(l,C,X)}}QX.DefaultConfiguration={wasmUrl:`${h.i._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${h.i._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${h.i._DefaultCdnUrl}/draco_encoder.js`},QX._Default=null;const XX="KHR_draco_mesh_compression";class CX{get wasUsed(){return this._wasUsed}constructor(Q){this.name=XX,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Q.options.meshCompressionMethod&&QX.DefaultAvailable}dispose(){}postExportMeshPrimitive(Q,X,C){if(!this.enabled)return;if(4!==Q.mode&&5!==Q.mode)return void n.c.Warn("Cannot compress primitive with mode "+Q.mode+".");const l=[],h=[];let M=null;if(void 0!==Q.indices){const f=C[Q.indices],O=X.getBufferView(f);M=X.getData(O).slice(),l.push(O),h.push(f)}const f=[];for(const[U,L]of Object.entries(Q.attributes)){const Q=C[L],M=X.getBufferView(Q),m=t(Q.type),W=(0,q.s)(X.getData(M),m,Q.componentType,Q.byteOffset||0,M.byteStride||(0,q.n)(Q.componentType)*m,Q.normalized||!1,Q.count,!0);f.push({kind:U,dracoName:(O=U,"POSITION"===O?"POSITION":"NORMAL"===O?"NORMAL":O.startsWith("COLOR")?"COLOR":O.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:t(Q.type),data:W}),l.push(M),h.push(Q)}var O;const m={method:Q.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},W=QX.Default._encodeAsync(f,M,m).then((C=>{if(!C)return void n.c.Error("Draco encoding failed for primitive.");const M={bufferView:-1,attributes:C.attributeIds},f=X.createBufferView(C.data);X.setBufferView(M,f);for(const Q of l)this._bufferViewsUsed.add(Q);for(const Q of h)this._accessorsUsed.add(Q);Q.extensions||(Q.extensions={}),Q.extensions[XX]=M})).catch((Q=>{n.c.Error("Draco encoding failed for primitive: "+Q)}));this._encodePromises.push(W),this._wasUsed=!0}async preGenerateBinaryAsync(Q){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((X=>{Q.getPropertiesWithBufferView(X).every((Q=>this._accessorsUsed.has(Q)))&&Q.removeBufferView(X)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}bQ.RegisterExtension(XX,(Q=>new CX(Q)));var lX=C(12282);const hX="KHR_lights_punctual",MX={name:"",color:[1,1,1],cb:1,range:Number.MAX_VALUE},fX={innerConeAngle:0,outerConeAngle:Math.PI/4},OX=l.k.Backward();class mX{constructor(Q){this.name=hX,this.enabled=!0,this.required=!1,this._exporter=Q}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[hX]=this._lights}async postExportNodeAsync(Q,X,C,h,M){return await new Promise((f=>{if(!(C instanceof rQ.b))return void f(X);const O=C.getTypeID()==rQ.b.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==rQ.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==rQ.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!O||!(C instanceof lX.c))return n.c.Warn(`${Q}: Light ${C.name} is not supported in ${hX}`),void f(X);if(C.falloffType!==rQ.b.FALLOFF_GLTF&&n.c.Warn(`${Q}: Light falloff for ${C.name} does not match the ${hX} specification!`),!C.position.equalsToFloats(0,0,0)){const Q=l.e.Yj[0].p(C.position);M&&u(Q),X.translation=Q.dk()}if("point"!==O){const Q=C.direction.normalizeToRef(l.e.Yj[0]);M&&u(Q);const h=l.c.FromUnitVectorsToRef(OX,Q,l.e.Quaternion[0]);l.c.IsIdentity(h)||(X.rotation=h.dk())}const m={type:O,name:C.name,color:C.eb.dk(),cb:C.cb,range:C.range};if(lQ(m,MX),"spot"===O){const Q=C;m.spot={innerConeAngle:Q.innerAngle/2,outerConeAngle:Q.angle/2},lQ(m.spot,fX)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(m);const W={ab:this._lights.lights.length-1},U=C.parent;if(U&&XQ(C,U)){const Q=h.get(U);if(Q){const C=this._exporter._nodes[Q];return QQ(X,C),C.extensions||(C.extensions={}),C.extensions[hX]=W,void f(null)}}X.extensions||(X.extensions={}),X.extensions[hX]=W,f(X)}))}}bQ.RegisterExtension(hX,(Q=>new mX(Q)));var WX=C(12168);const UX="KHR_materials_anisotropy";class LX{constructor(Q){this.name=UX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof WX.c&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&l.push(C.anisotropy.texture),l):[]}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof WX.c){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void Q(X);this._wasUsed=!0,X.extensions=X.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),h={anisotropyStrength:C.anisotropy.cb,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:l??void 0};null!==h.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),X.extensions[UX]=h}Q(X)}))}}bQ.RegisterExtension(UX,(Q=>new LX(Q)));const wX="KHR_materials_clearcoat";class iX{constructor(Q){this.name=wX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof WX.c&&C.clearCoat.isEnabled?(C.clearCoat.texture&&l.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&l.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&l.push(C.clearCoat.bumpTexture),l):[]}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof WX.c){if(!C.clearCoat.isEnabled)return void Q(X);this._wasUsed=!0,X.extensions=X.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let M;M=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&h.i.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&h.i.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const f=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),O={clearcoatFactor:C.clearCoat.cb,clearcoatTexture:l??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:M??void 0,clearcoatNormalTexture:f??void 0};null===O.clearcoatTexture&&null===O.clearcoatRoughnessTexture&&null===O.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),X.extensions[wX]=O}Q(X)}))}}bQ.RegisterExtension(wX,(Q=>new iX(Q)));const aX="KHR_materials_diffuse_transmission";function FX(Q,X){const C=X.subSurface;let l=null;return C.translucencyIntensityTexture?l=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(l=C.thicknessTexture),l&&!C.useGltfStyleTextures?(n.c.Warn(`${Q}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${X.name}`,1),null):l}class sX{constructor(Q){this.name=aX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];if(C instanceof aQ.b&&this._isExtensionEnabled(C)){const X=FX(Q,C);return X&&l.push(X),C.subSurface.translucencyColorTexture&&l.push(C.subSurface.translucencyColorTexture),l}return l}_isExtensionEnabled(Q){if(Q.unlit)return!1;const X=Q.subSurface;return!!X.isTranslucencyEnabled&&(!Q.unlit&&!X.useAlbedoToTintTranslucency&&X.useGltfStyleTextures&&1===X.volumeIndexOfRefraction&&0===X.minimumThickness&&0===X.maximumThickness)}postExportMaterialAsync(Q,X,C){return new Promise((l=>{if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const l=C.subSurface,h=FX(Q,C),M=0==l.translucencyIntensity?void 0:l.translucencyIntensity,f=this._exporter._materialExporter.getTextureInfo(h)??void 0,O=!l.translucencyColor||l.translucencyColor.equalsFloats(1,1,1)?void 0:l.translucencyColor.dk(),m=this._exporter._materialExporter.getTextureInfo(l.translucencyColorTexture)??void 0,W={diffuseTransmissionFactor:M,diffuseTransmissionTexture:f,diffuseTransmissionColorFactor:O,diffuseTransmissionColorTexture:m};(f||m)&&this._exporter._materialNeedsUVsSet.add(C),X.extensions=X.extensions||{},X.extensions[aX]=W}l(X)}))}}bQ.RegisterExtension(aX,(Q=>new sX(Q)));const zX="KHR_materials_dispersion";class xX{constructor(){this.name=zX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Q){if(Q.unlit)return!1;const X=Q.subSurface;return!(!X.isRefractionEnabled&&!X.isDispersionEnabled)}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Q={dispersion:C.subSurface.dispersion};X.extensions=X.extensions||{},X.extensions[zX]=Q}Q(X)}))}}bQ.RegisterExtension(zX,(()=>new xX));const rX="KHR_materials_emissive_strength";class PX{constructor(){this.name=rX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Q,X,C){return await new Promise((Q=>{if(!(C instanceof aQ.b))return Q(X);const l=C.emissiveColor.dk(),h=Math.max(...l);if(h>1){this._wasUsed=!0,X.extensions||(X.extensions={});const Q={emissiveStrength:h},l=C.emissiveColor.scale(1/Q.emissiveStrength);X.emissiveFactor=l.dk(),X.extensions[rX]=Q}return Q(X)}))}}bQ.RegisterExtension(rX,(Q=>new PX));const jX="KHR_materials_ior";class vX{constructor(){this.name=jX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Q){return!Q.unlit&&(void 0!=Q.indexOfRefraction&&1.5!=Q.indexOfRefraction)}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Q={ior:C.indexOfRefraction};X.extensions=X.extensions||{},X.extensions[jX]=Q}Q(X)}))}}bQ.RegisterExtension(jX,(Q=>new vX));const ZX="KHR_materials_iridescence";class gX{constructor(Q){this.name=ZX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof WX.c&&C.iridescence.isEnabled?(C.iridescence.texture&&l.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&l.push(C.iridescence.thicknessTexture),l):[]}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof WX.c){if(!C.iridescence.isEnabled)return void Q(X);this._wasUsed=!0,X.extensions=X.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),h=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),M={iridescenceFactor:C.iridescence.cb,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:l??void 0,iridescenceThicknessTexture:h??void 0};null===M.iridescenceTexture&&null===M.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),X.extensions[ZX]=M}Q(X)}))}}bQ.RegisterExtension(ZX,(Q=>new gX(Q)));const SX="KHR_materials_sheen";class eX{constructor(Q){this.name=SX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){return C instanceof aQ.b&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(Q,X,C){return await new Promise((Q=>{if(C instanceof aQ.b){if(!C.sheen.isEnabled)return void Q(X);this._wasUsed=!0,null==X.extensions&&(X.extensions={});const l={sheenColorFactor:C.sheen.color.dk(),sheenRoughnessFactor:C.sheen.roughness??0};null===l.sheenColorTexture&&null===l.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(l.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),X.extensions[SX]=l}Q(X)}))}}bQ.RegisterExtension(SX,(Q=>new eX(Q)));const kX="KHR_materials_specular";class RX{constructor(Q){this.name=kX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof aQ.b&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&l.push(C.metallicReflectanceTexture),C.reflectanceTexture&&l.push(C.reflectanceTexture),l):l}_isExtensionEnabled(Q){return!Q.unlit&&(void 0!=Q.metallicF0Factor&&1!=Q.metallicF0Factor||void 0!=Q.metallicReflectanceColor&&!Q.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Q))}_hasTexturesExtension(Q){return null!=Q.metallicReflectanceTexture||null!=Q.reflectanceTexture}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0,X.extensions=X.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,l=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,h={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:Q,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.dk(),specularColorTexture:l};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),X.extensions[kX]=h}Q(X)}))}}bQ.RegisterExtension(kX,(Q=>new RX(Q)));const HX="KHR_materials_transmission";class oX{constructor(Q){this.name=HX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof aQ.b&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&l.push(C.subSurface.thicknessTexture),l):l}_isExtensionEnabled(Q){if(Q.unlit)return!1;const X=Q.subSurface;return X.isRefractionEnabled&&void 0!=X.refractionIntensity&&0!=X.refractionIntensity||this._hasTexturesExtension(Q)}_hasTexturesExtension(Q){return null!=Q.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Q,X,C){if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const l=C.subSurface,h={transmissionFactor:0===l.refractionIntensity?void 0:l.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),l.refractionIntensityTexture)if(l.useGltfStyleTextures){const Q=await this._exporter._materialExporter.exportTextureAsync(l.refractionIntensityTexture,"image/png");Q&&(h.transmissionTexture=Q)}else n.c.Warn(`${Q}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);X.extensions||(X.extensions={}),X.extensions[HX]=h}return X}}bQ.RegisterExtension(HX,(Q=>new oX(Q)));const TX="KHR_materials_unlit";class YX{constructor(){this.name=TX,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{let l=!1;C instanceof aQ.b?l=C.unlit:C instanceof FQ.b&&(l=C.disableLighting),l&&(this._wasUsed=!0,null==X.extensions&&(X.extensions={}),X.extensions[TX]={}),Q(X)}))}}bQ.RegisterExtension(TX,(()=>new YX));const JX="KHR_materials_volume";class KX{constructor(Q){this.name=JX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof aQ.b&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&l.push(C.subSurface.thicknessTexture),l):l}_isExtensionEnabled(Q){if(Q.unlit)return!1;const X=Q.subSurface;return!(!X.isRefractionEnabled&&!X.isTranslucencyEnabled)&&(void 0!=X.maximumThickness&&0!=X.maximumThickness||void 0!=X.tintColorAtDistance&&X.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=X.tintColor&&X.tintColor!=s.b.White()||this._hasTexturesExtension(Q))}_hasTexturesExtension(Q){return null!=Q.subSurface.thicknessTexture}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof aQ.b&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Q=C.subSurface,l={thicknessFactor:0==Q.maximumThickness?void 0:Q.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Q.thicknessTexture)??void 0,attenuationDistance:Q.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Q.tintColorAtDistance,attenuationColor:Q.tintColor.equalsFloats(1,1,1)?void 0:Q.tintColor.dk()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),X.extensions=X.extensions||{},X.extensions[JX]=l}Q(X)}))}}bQ.RegisterExtension(JX,(Q=>new KX(Q)));const NX="EXT_materials_diffuse_roughness";class qX{constructor(Q){this.name=NX,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Q,X,C){const l=[];return C instanceof WX.c&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&l.push(C._baseDiffuseRoughnessTexture),l):[]}postExportMaterialAsync(Q,X,C){return new Promise((Q=>{if(C instanceof WX.c){if(!C._baseDiffuseRoughness)return void Q(X);this._wasUsed=!0,X.extensions=X.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),h={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:l??void 0};null!==h.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),X.extensions[NX]=h}Q(X)}))}}bQ.RegisterExtension(NX,(Q=>new qX(Q)));const nX="KHR_texture_transform";class cX{constructor(){this.name=nX,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Q,X,C){if(C.va()||h.i.Warn(`${Q}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(h.i.Warn(`${Q}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const l={};let M=!1;if(0===C.uOffset&&0===C.vOffset||(l.offset=[C.uOffset,C.vOffset],M=!0),1===C.uScale&&1===C.vScale||(l.scale=[C.uScale,C.vScale],M=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void h.i.Warn(`${Q}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${nX}.`);h.i.Warn(`${Q}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${nX}.`),l.offset=function(Q){const{uOffset:X,vOffset:C,uRotationCenter:l,vRotationCenter:h,uScale:M,vScale:f,wAng:O}=Q,m=Math.cos(O),W=Math.sin(O),U=l*M,L=h*f;return[X+(U*(1-m)+L*W),C+(L*(1-m)-U*W)]}(C)}l.rotation=-C.wAng,M=!0}0!==C.coordinatesIndex&&(l.texCoord=C.coordinatesIndex,M=!0),M&&(this._wasUsed=!0,X.extensions||(X.extensions={}),X.extensions[nX]=l)}}bQ.RegisterExtension(nX,(()=>new cX));class EX{static CreateSTL(Q){let X=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],M=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],f=arguments.length>5&&void 0!==arguments[5]&&arguments[5],O=arguments.length>6&&void 0!==arguments[6]&&arguments[6],m=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const W=function(Q,X,C){const h=[3*Q[C],3*Q[C+1],3*Q[C+2]],M=[new l.k(X[h[0]],X[h[0]+2],X[h[0]+1]),new l.k(X[h[1]],X[h[1]+2],X[h[1]+1]),new l.k(X[h[2]],X[h[2]+2],X[h[2]+1])],f=M[0].Od(M[1]),O=M[2].Od(M[1]);return{v:M,n:l.k.Cross(O,f).normalize()}},L=function(Q,X,C,l){return X=w(Q,X,C.x,l),X=w(Q,X,C.y,l),w(Q,X,C.z,l)},w=function(Q,X,C,l){return Q.setFloat32(X,C,l),X+4},a=function(Q){if(O){let X=Q;Q instanceof i.d&&(X=Q.sourceMesh);const C=X.getVerticesData(U.g.PositionKind,!0,!0);if(!C)return[];const h=l.k.Zero();let M;for(M=0;M<C.length;M+=3)l.k.TransformCoordinatesFromFloatsToRef(C[M],C[M+1],C[M+2],Q.Vj(!0),h).toArray(C,M);return C}return Q.getVerticesData(U.g.PositionKind)||[]};O&&(f=!0);let F="",s=0,z=0;if(h){for(let C=0;C<Q.length;C++){const X=Q[C].Xj();s+=X?X.length/3:0}const X=new ArrayBuffer(84+50*s);F=new DataView(X),z+=80,F.setUint32(z,s,M),z+=4}else m||(F="solid stlmesh\r\n");for(let l=0;l<Q.length;l++){const X=Q[l];!h&&m&&(F+="solid "+X.name+"\r\n"),!f&&X instanceof xQ.c&&X.bakeCurrentTransformIntoVertices();const C=a(X),O=X.Xj()||[];for(let Q=0;Q<O.length;Q+=3){const X=W(O,C,Q);h?(z=L(F,z,X.n,M),z=L(F,z,X.v[0],M),z=L(F,z,X.v[1],M),z=L(F,z,X.v[2],M),z+=2):(F+="\tfacet normal "+X.n.x+" "+X.n.y+" "+X.n.z+"\r\n",F+="\t\touter loop\r\n",F+="\t\t\tvertex "+X.v[0].x+" "+X.v[0].y+" "+X.v[0].z+"\r\n",F+="\t\t\tvertex "+X.v[1].x+" "+X.v[1].y+" "+X.v[1].z+"\r\n",F+="\t\t\tvertex "+X.v[2].x+" "+X.v[2].y+" "+X.v[2].z+"\r\n",F+="\t\tendloop\r\n",F+="\tendfacet\r\n")}!h&&m&&(F+="endsolid "+name+"\r\n")}if(h||m||(F+="endsolid stlmesh"),X){const Q=document.createElement("a"),X=new Blob([F],{type:"application/octet-stream"});Q.href=window.URL.createObjectURL(X),Q.download=C+".stl",Q.click()}return F}}function BX(Q,X){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const l=[];for(let h=0;h<Q.length/C;h++){const M=Q[h*C],f=Q[h*C+1],O=Q[h*C+2];l.push(`(${M.toPrecision(X.precision)}, ${f.toPrecision(X.precision)}, ${O.toPrecision(X.precision)})`)}return l.join(", ")}function GX(Q,X){const C=[];for(let l=0;l<Q.length/2;l++){const h=Q[2*l],M=Q[2*l+1];C.push(`(${h.toPrecision(X.precision)}, ${(1-M).toPrecision(X.precision)})`)}return C.join(", ")}function bX(Q,X){const C=Q.getVerticesData(U.g.PositionKind),l=Q.getVerticesData(U.g.NormalKind);if(C&&l)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Q){var X;const C=null!==(X=Q.Xj())&&void 0!==X&&X.length?Q.getTotalIndices():Q.getTotalVertices();return Array(C/3).fill(3).join(", ")}(Q)}]\n\t\tint[] faceVertexIndices = [${function(Q){const X=Q.Xj(),C=[];if(null!==X)for(let l=0;l<X.length;l++)C.push(X[l]);else{const X=Q.getTotalVertices();for(let Q=0;Q<X;Q++)C.push(Q)}return C.join(", ")}(Q)}]\n\t\tnormal3f[] normals = [${BX(l,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${BX(C,X)}]\n        ${function(Q,X){let C="";for(let h=0;h<4;h++){const l=h>0?h:"",M=Q.getVerticesData(U.g.UVKind+(l?l+1:""));M&&(C+=`\n\t\ttexCoord2f[] primvars:st${l} = [${GX(M,X)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const l=Q.getVerticesData(U.g.ColorKind);return l&&(C+=`\n\tcolor3f[] primvars:displayColor = [${BX(l,X,l.length/Q.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(Q,X)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function pX(Q,X){return`\n        def "Geometry"\n        {\n        ${bX(Q,X)}\n        }\n        `}function IX(Q){let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return X+=Q,fflate.strToU8(X)}function tX(Q){const X=Q.m;return`( ${yX(X,0)}, ${yX(X,4)}, ${yX(X,8)}, ${yX(X,12)} )`}function yX(Q,X){return`(${Q[X+0]}, ${Q[X+1]}, ${Q[X+2]}, ${Q[X+3]})`}function AX(Q){const X="Object_"+Q.uniqueId,C=function(Q){const X=Q.getWorldMatrix().clone(),C=Q.va().useRightHandedSystem;if(!C){let l=Q.parent;for(;l;){if(fQ(l,C)){X.multiplyToRef(l.getWorldMatrix().invert(),X);break}l=l.parent}}return X.determinant()<0&&h.i.Warn(`Exporting mesh ${Q.name} with negative scale. Result may look incorrect in destination engine.`),X}(Q),l=tX(C);return`def Xform "${X}" (\n\tprepend references = @./geometries/Geometry_${Q.ik.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${l}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Q.material.uniqueId}>\n}\n\n`}function DX(Q){switch(Q){case Z.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Z.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Z.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function uX(Q){return`(${Q.x}, ${Q.y})`}function VX(Q){return`(${Q.r}, ${Q.g}, ${Q.b})`}function dX(Q,X,C,h,M,f){const O=Q.getInternalTexture().uniqueId+"_"+Q.invertY;M[O]=Q;const m=Q.coordinatesIndex>0?"st"+Q.coordinatesIndex:"st",W=new l.h(Q.uScale,Q.vScale),U=new l.h(Q.uOffset,Q.vOffset),L=Q.wAng,w=Math.sin(L),i=Math.cos(L);return U.y=1-U.y-W.y,U.x+=w*W.x,U.y+=(1-i)*W.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${m}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${X.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(L*(180/Math.PI)).toFixed(f.precision)}\n        float2 inputs:scale = ${uX(W)}\n        float2 inputs:translation = ${uX(U)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Q.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${O}.png@\n        float2 inputs:st.connect = </Materials/Material_${X.uniqueId}/Transform2d_${C}.outputs:result>\n        ${h?"float4 inputs:scale = "+function(Q){return`(${Q.r}, ${Q.g}, ${Q.b}, 1.0)`}(h):""}\n        token inputs:sourceColorSpace = "${Q.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${DX(Q.wrapU)}"\n        token inputs:wrapT = "${DX(Q.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${X.needAlphaBlending()?"float outputs:a":""}\n    }`}function QC(Q,X,C){const l="\t\t\t",h=[],M=[],{diffuseMap:f,eb:O,alphaCutOff:m,emissiveMap:W,emissive:U,normalMap:L,roughnessMap:w,roughnessChannel:i,roughness:a,metalnessMap:F,metalnessChannel:z,metalness:x,aoMap:r,aoMapChannel:P,aoMapIntensity:j,alphaMap:v,ior:Z,clearCoatEnabled:g,clearCoat:S,clearCoatMap:e,clearCoatRoughness:k,clearCoatRoughnessMap:R}=function(Q){const X={diffuseMap:null,eb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Q instanceof FQ.b?{...X,diffuseMap:Q.diffuseTexture,eb:Q.diffuseColor,alphaCutOff:Q.alphaCutOff,emissiveMap:Q.emissiveTexture,emissive:Q.emissiveColor,roughness:1,alphaMap:Q.opacityTexture}:Q instanceof WX.c?{...X,diffuseMap:Q._albedoTexture,eb:Q._albedoColor,alphaCutOff:Q._alphaCutOff,emissiveMap:Q._emissiveTexture,emissive:Q._emissiveColor,normalMap:Q._bumpTexture,roughnessMap:Q._metallicTexture,roughnessChannel:Q._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Q._roughness??1,metalnessMap:Q._metallicTexture,metalnessChannel:Q._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Q._metallic??0,aoMap:Q._ambientTexture,aoMapChannel:Q._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Q._ambientTextureStrength,alphaMap:Q._opacityTexture,ior:Q.subSurface.indexOfRefraction,clearCoatEnabled:Q.clearCoat.isEnabled,clearCoat:Q.clearCoat.cb,clearCoatMap:Q.clearCoat.texture,clearCoatRoughness:Q.clearCoat.roughness,clearCoatRoughnessMap:Q.clearCoat.useRoughnessFromMainTexture?Q.clearCoat.texture:Q.clearCoat.textureRoughness}:X}(Q);return null!==f?(h.push(`${l}color3f inputs:diffuseColor.connect = </Materials/Material_${Q.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:rgb>`),Q.needAlphaBlending()?h.push(`${l}float inputs:opacity.connect = </Materials/Material_${Q.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`):Q.needAlphaTesting()&&(h.push(`${l}float inputs:opacity.connect = </Materials/Material_${Q.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`),h.push(`${l}float inputs:opacityThreshold = ${m}`)),M.push(dX(f,Q,"diffuse",O,X,C))):h.push(`${l}color3f inputs:diffuseColor = ${VX(O||s.b.White())}`),null!==W?(h.push(`${l}color3f inputs:emissiveColor.connect = </Materials/Material_${Q.uniqueId}/Texture_${W.uniqueId}_emissive.outputs:rgb>`),M.push(dX(W,Q,"emissive",U,X,C))):U&&U.toLuminance()>0&&h.push(`${l}color3f inputs:emissiveColor = ${VX(U)}`),null!==L&&(h.push(`${l}normal3f inputs:normal.connect = </Materials/Material_${Q.uniqueId}/Texture_${L.uniqueId}_normal.outputs:rgb>`),M.push(dX(L,Q,"ek",null,X,C))),null!==r&&(h.push(`${l}float inputs:occlusion.connect = </Materials/Material_${Q.uniqueId}/Texture_${r.uniqueId}_occlusion.outputs:${P}>`),M.push(dX(r,Q,"occlusion",new s.b(j,j,j),X,C))),null!==w?(h.push(`${l}float inputs:roughness.connect = </Materials/Material_${Q.uniqueId}/Texture_${w.uniqueId}_roughness.outputs:${i}>`),M.push(dX(w,Q,"roughness",new s.b(a,a,a),X,C))):h.push(`${l}float inputs:roughness = ${a}`),null!==F?(h.push(`${l}float inputs:metallic.connect = </Materials/Material_${Q.uniqueId}/Texture_${F.uniqueId}_metallic.outputs:${z}>`),M.push(dX(F,Q,"metallic",new s.b(x,x,x),X,C))):h.push(`${l}float inputs:metallic = ${x}`),null!==v?(h.push(`${l}float inputs:opacity.connect = </Materials/Material_${Q.uniqueId}/Texture_${v.uniqueId}_opacity.outputs:r>`),h.push(`${l}float inputs:opacityThreshold = 0.0001`),M.push(dX(v,Q,"opacity",null,X,C))):h.push(`${l}float inputs:opacity = ${Q.alpha}`),g&&(null!==e?(h.push(`${l}float inputs:clearcoat.connect = </Materials/Material_${Q.uniqueId}/Texture_${e.uniqueId}_clearcoat.outputs:r>`),M.push(dX(e,Q,"clearcoat",new s.b(S,S,S),X,C))):h.push(`${l}float inputs:clearcoat = ${S}`),null!==R?(h.push(`${l}float inputs:clearcoatRoughness.connect = </Materials/Material_${Q.uniqueId}/Texture_${R.uniqueId}_clearcoatRoughness.outputs:g>`),M.push(dX(R,Q,"clearcoatRoughness",new s.b(k,k,k),X,C))):h.push(`${l}float inputs:clearcoatRoughness = ${k}`)),h.push(`${l}float inputs:ior = ${Z}`),`\n\tdef Material "Material_${Q.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${h.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Q.uniqueId}/PreviewSurface.outputs:surface>\n\n${M.join("\n")}\n\n\t}\n`}async function XC(Q,X,C){const M={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...X};"undefined"===typeof fflate&&await h.i.LoadScriptAsync(M.fflateUrl);const f={};f[M.modelFileName]=null;let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';O+=function(Q){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Q.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Q.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Q.planeAnchoringAlignment}"`:""}\n            `}(M);const m={};for(const l of Q.meshes){if(0===l.getTotalVertices())continue;const Q=l,X=Q.ik,W=Q.material;if(!W||!X||C&&!C(Q))continue;if(-1!==["fb","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(W.getClassName())){const C="geometries/Geometry_"+X.uniqueId+".usda";if(!(C in f)){const Q=pX(X,M);f[C]=IX(Q)}W.uniqueId in m||(m[W.uniqueId]=W),O+=AX(Q)}else h.i.Warn("USDZExportAsync does not support this material type: "+W.getClassName())}Q.activeCamera&&M.exportCamera&&(O+=function(Q,X){const C="Camera_"+Q.uniqueId,h=tX(l.b.RotationY(Math.PI).multiply(Q.getWorldMatrix()));if(Q.mode===Z.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Q.Rj.toPrecision(X.precision)}, ${Q.maxZ.toPrecision(X.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Q.orthoLeft||1)+Math.abs(Q.orthoRight||1))).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Q.orthoTop||1)+Math.abs(Q.orthoBottom||1))).toPrecision(X.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const l=Q.getEngine().getAspectRatio(Q),M=X.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Q.Rj.toPrecision(X.precision)}, ${Q.maxZ.toPrecision(X.precision)})\n\t\t\tfloat focalLength = ${(M/(2*Math.tan(.5*Q.fov))).toPrecision(X.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(M*l).toPrecision(X.precision)}\n\t\t\tfloat verticalAperture = ${(M/l).toPrecision(X.precision)}            \n\t\t}\n\t\n\t`}}(Q.activeCamera,M)),O+="\n            }\n        }\n    }";const W={};O+=function(Q,X,C){const l=[];for(const h in Q){const M=Q[h];l.push(QC(M,X,C))}return`\n    def "Materials"\n{\n${l.join("")}\n}\n\n`}(m,W,M),f[M.modelFileName]=fflate.strToU8(O);for(const l in W){const Q=W[l],X=Q.getSize(),C=await Q.readPixels();if(!C)throw new Error("Texture data is not available");const h=await g.DumpTools.DumpDataAsync(X.width,X.height,C,"image/png",void 0,!1,!0);f[`textures/Texture_${l}.png`]=new Uint8Array(h).slice()}let U=0;for(const l in f){const Q=f[l];if(!Q)continue;U+=34+l.length;const X=63&U;if(4!==X){const C=new Uint8Array(64-X);f[l]=[Q,{extra:{12345:C}}]}U=Q.length}return fflate.zipSync(f,{level:0})}}}]);