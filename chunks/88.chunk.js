"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{14397:(Q,X,C)=>{C.r(X),C.d(X,{FlowGraphMultiGateBlock:()=>O});var l=C(620),h=C(13083),M=C(13063),f=C(13060);class O extends h.b{constructor(Q){super(Q),this.config=Q,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",M.f,new f.d(-1)),this.setNumberOfOutputSignals(null===Q||void 0===Q?void 0:Q.outputSignalCount)}_getNextIndex(Q){if(Q.includes(!1)||this.config.isLoop&&Q.fill(!1),this.config.isRandom){const X=Q.map(((Q,X)=>Q?-1:X)).filter((Q=>-1!==Q));return X.length?X[Math.floor(Math.random()*X.length)]:-1}return Q.indexOf(!1)}setNumberOfOutputSignals(){let Q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>Q;){const Q=this.outputSignals.pop();Q&&(Q.disconnectFromAll(),this._unregisterSignalOutput(Q.name))}for(;this.outputSignals.length<Q;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(Q,X){if(Q._hasExecutionVariable(this,"indexesUsed")||Q._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),X===this.reset)return Q._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new f.d(-1),Q);const C=Q._getExecutionVariable(this,"indexesUsed",[]),l=this._getNextIndex(C);l>-1&&(this.lastIndex.setValue(new f.d(l),Q),C[l]=!0,Q._setExecutionVariable(this,"indexesUsed",C),this.outputSignals[l]._activateSignal(Q))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(Q){super.serialize(Q),Q.config.outputSignalCount=this.config.outputSignalCount,Q.config.isRandom=this.config.isRandom,Q.config.loop=this.config.isLoop,Q.config.startIndex=this.config.startIndex}}(0,l.g)("FlowGraphMultiGateBlock",O)}}]);