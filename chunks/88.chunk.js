"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{14547:(R,x,H)=>{H.r(x),H.d(x,{FlowGraphMultiGateBlock:()=>D});var k=H(610),c=H(13262),t=H(13246),A=H(13244);class D extends c.d{constructor(R){super(R),this.config=R,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",t.d,new A.e(-1)),this.setNumberOfOutputSignals(null===R||void 0===R?void 0:R.outputSignalCount)}_getNextIndex(R){if(R.includes(!1)||this.config.isLoop&&R.fill(!1),this.config.isRandom){const x=R.map(((R,x)=>R?-1:x)).filter((R=>-1!==R));return x.length?x[Math.floor(Math.random()*x.length)]:-1}return R.indexOf(!1)}setNumberOfOutputSignals(){let R=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>R;){const R=this.outputSignals.pop();R&&(R.disconnectFromAll(),this._unregisterSignalOutput(R.name))}for(;this.outputSignals.length<R;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(R,x){if(R._hasExecutionVariable(this,"indexesUsed")||R._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),x===this.reset)return R._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new A.e(-1),R);const H=R._getExecutionVariable(this,"indexesUsed",[]),k=this._getNextIndex(H);k>-1&&(this.lastIndex.setValue(new A.e(k),R),H[k]=!0,R._setExecutionVariable(this,"indexesUsed",H),this.outputSignals[k]._activateSignal(R))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(R){super.serialize(R),R.config.outputSignalCount=this.config.outputSignalCount,R.config.isRandom=this.config.isRandom,R.config.loop=this.config.isLoop,R.config.startIndex=this.config.startIndex}}(0,k.h)("FlowGraphMultiGateBlock",D)}}]);