"use strict";(self.jr1pmf6bwuf=self.jr1pmf6bwuf||[]).push([[88],{16189:(Y,c,h)=>{h.r(c),h.d(c,{FlowGraphAbsBlock:()=>a,FlowGraphAcosBlock:()=>NY,FlowGraphAcoshBlock:()=>kY,FlowGraphAddBlock:()=>p,FlowGraphAsinBlock:()=>EY,FlowGraphAsinhBlock:()=>qY,FlowGraphAtan2Block:()=>bY,FlowGraphAtanBlock:()=>QY,FlowGraphAtanhBlock:()=>MY,FlowGraphBitwiseAndBlock:()=>XY,FlowGraphBitwiseLeftShiftBlock:()=>GY,FlowGraphBitwiseNotBlock:()=>rY,FlowGraphBitwiseOrBlock:()=>ZY,FlowGraphBitwiseRightShiftBlock:()=>KY,FlowGraphBitwiseXorBlock:()=>aY,FlowGraphCeilBlock:()=>s,FlowGraphClampBlock:()=>O,FlowGraphCosBlock:()=>hY,FlowGraphCoshBlock:()=>wY,FlowGraphCubeRootBlock:()=>TY,FlowGraphDegToRadBlock:()=>mY,FlowGraphDivideBlock:()=>d,FlowGraphEBlock:()=>T,FlowGraphEqualityBlock:()=>i,FlowGraphExpBlock:()=>pY,FlowGraphFloorBlock:()=>I,FlowGraphFractionBlock:()=>A,FlowGraphGreaterThanBlock:()=>F,FlowGraphGreaterThanOrEqualBlock:()=>J,FlowGraphInfBlock:()=>r,FlowGraphIsInfinityBlock:()=>S,FlowGraphIsNanBlock:()=>j,FlowGraphLeadingZerosBlock:()=>IY,FlowGraphLessThanBlock:()=>B,FlowGraphLessThanOrEqualBlock:()=>t,FlowGraphLog10Block:()=>dY,FlowGraphLog2Block:()=>yY,FlowGraphLogBlock:()=>PY,FlowGraphMathInterpolationBlock:()=>u,FlowGraphMaxBlock:()=>v,FlowGraphMinBlock:()=>n,FlowGraphModuloBlock:()=>l,FlowGraphMultiplyBlock:()=>y,FlowGraphNaNBlock:()=>X,FlowGraphNegationBlock:()=>V,FlowGraphOneBitsCounterBlock:()=>xY,FlowGraphPiBlock:()=>e,FlowGraphPowerBlock:()=>eY,FlowGraphRadToDegBlock:()=>YY,FlowGraphRandomBlock:()=>D,FlowGraphRoundBlock:()=>x,FlowGraphSaturateBlock:()=>f,FlowGraphSignBlock:()=>G,FlowGraphSinBlock:()=>cY,FlowGraphSinhBlock:()=>HY,FlowGraphSquareRootBlock:()=>DY,FlowGraphSubtractBlock:()=>P,FlowGraphTanBlock:()=>CY,FlowGraphTanhBlock:()=>WY,FlowGraphTrailingZerosBlock:()=>sY,FlowGraphTruncBlock:()=>K});var C=h(12825),E=h(14459),N=h(16197),Q=h(16201);class b extends Q.d{constructor(Y,c,h,C){super(Y,C),this._operation=c,this._className=h}_doOperation(Y){return this._operation(Y)}getClassName(){return this._className}}var H=h(12869),w=h(16204);class W extends Q.d{constructor(Y,c,h,C,E,N,Q){super(C,Q),this._operation=E,this._className=N,this.a=this.registerDataInput("a",Y),this.b=this.registerDataInput("b",c),this.c=this.registerDataInput("c",h)}_doOperation(Y){return this._operation(this.a.getValue(Y),this.b.getValue(Y),this.c.getValue(Y))}getClassName(){return this._className}}var q=h(14450),k=h(14463),M=h(14493);class p extends N.c{constructor(Y){super((0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),((Y,c)=>this._polymorphicAdd(Y,c)),"FlowGraphAddBlock",Y)}_polymorphicAdd(Y,c){const h=(0,M.h)(Y),C=(0,M.h)(c);if((0,M.d)(h,C)||(0,M.c)(h,C)||(0,M.b)(h,C))return Y.add(c);if("Quaternion"===h||"Vector4"===C)return new H.Vector4(Y.x,Y.y,Y.z,Y.w).addInPlace(c);if("Vector4"===h||"Quaternion"===C)return Y.add(c);var E;if(null!==(E=this.config)&&void 0!==E&&E.preventIntegerFloatArithmetic&&typeof Y!==typeof c)throw new Error("Cannot add different types of numbers.");return(0,M.m)(Y)+(0,M.m)(c)}}(0,C.e)("FlowGraphAddBlock",p);class P extends N.c{constructor(Y){super((0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),((Y,c)=>this._polymorphicSubtract(Y,c)),"FlowGraphSubtractBlock",Y)}_polymorphicSubtract(Y,c){const h=(0,M.h)(Y),C=(0,M.h)(c);if((0,M.d)(h,C)||(0,M.b)(h,C)||(0,M.c)(h,C))return Y.Hh(c);if("Quaternion"===h||"Vector4"===C)return new H.Vector4(Y.x,Y.y,Y.z,Y.w).Lk(c);if("Vector4"===h||"Quaternion"===C)return Y.Hh(c);var E;if(null!==(E=this.config)&&void 0!==E&&E.preventIntegerFloatArithmetic&&typeof Y!==typeof c)throw new Error("Cannot add different types of numbers.");return(0,M.m)(Y)-(0,M.m)(c)}}(0,C.e)("FlowGraphSubtractBlock",P);class y extends N.c{constructor(Y){super((0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),((Y,c)=>this._polymorphicMultiply(Y,c)),"FlowGraphMultiplyBlock",Y)}_polymorphicMultiply(Y,c){const h=(0,M.h)(Y),C=(0,M.h)(c);if((0,M.d)(h,C)||(0,M.b)(h,C))return Y.multiply(c);if("Quaternion"===h||"Vector4"===C)return new H.Vector4(Y.x,Y.y,Y.z,Y.w).multiplyInPlace(c);if("Vector4"===h||"Quaternion"===C)return Y.multiply(c);if((0,M.c)(h,C)){var E;if(null!==(E=this.config)&&void 0!==E&&E.useMatrixPerComponent){const C=Y.m;for(let Y=0;Y<C.length;Y++)C[Y]*=c.m[Y];return"Matrix2D"===h?new k.c(C):"Matrix3D"===h?new k.d(C):H.Matrix.dh(C)}return c.multiply(Y)}var N;if(null!==(N=this.config)&&void 0!==N&&N.preventIntegerFloatArithmetic&&typeof Y!==typeof c)throw new Error("Cannot add different types of numbers.");return(0,M.m)(Y)*(0,M.m)(c)}}(0,C.e)("FlowGraphMultiplyBlock",y);class d extends N.c{constructor(Y){super((0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),(0,E.H)(null===Y||void 0===Y?void 0:Y.type),((Y,c)=>this._polymorphicDivide(Y,c)),"FlowGraphDivideBlock",Y)}_polymorphicDivide(Y,c){const h=(0,M.h)(Y),C=(0,M.h)(c);if((0,M.d)(h,C)||(0,M.b)(h,C))return Y.divide(c);if("Quaternion"===h||"Quaternion"===C){const h=Y.clone();return h.x/=c.x,h.y/=c.y,h.z/=c.z,h.w/=c.w,h}if("Quaternion"===h||"Vector4"===C)return new H.Vector4(Y.x,Y.y,Y.z,Y.w).divideInPlace(c);if("Vector4"===h||"Quaternion"===C)return Y.divide(c);if((0,M.c)(h,C)){var E;if(null!==(E=this.config)&&void 0!==E&&E.useMatrixPerComponent){const C=Y.m;for(let Y=0;Y<C.length;Y++)C[Y]/=c.m[Y];return"Matrix2D"===h?new k.c(C):"Matrix3D"===h?new k.d(C):H.Matrix.dh(C)}return Y.divide(c)}var N;if(null!==(N=this.config)&&void 0!==N&&N.preventIntegerFloatArithmetic&&typeof Y!==typeof c)throw new Error("Cannot add different types of numbers.");return(0,M.m)(Y)/(0,M.m)(c)}}(0,C.e)("FlowGraphDivideBlock",d);class D extends b{constructor(Y){super(E.n,(Y=>this._random(Y)),"FlowGraphRandomBlock",Y),this.min=this.registerDataInput("min",E.n,(null===Y||void 0===Y?void 0:Y.min)??0),this.max=this.registerDataInput("max",E.n,(null===Y||void 0===Y?void 0:Y.max)??1),null!==Y&&void 0!==Y&&Y.seed&&(this._seed=Y.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const Y=1e4*Math.sin(this._seed++);return Y-Math.floor(Y)}return Math.random()}_random(Y){const c=this.min.getValue(Y),h=this.max.getValue(Y);return this._getRandomValue()*(h-c)+c}}(0,C.e)("FlowGraphRandomBlock",D);class T extends b{constructor(Y){super(E.n,(()=>Math.E),"FlowGraphEBlock",Y)}}(0,C.e)("FlowGraphEBlock",T);class e extends b{constructor(Y){super(E.n,(()=>Math.PI),"FlowGraphPIBlock",Y)}}(0,C.e)("FlowGraphPIBlock",e);class r extends b{constructor(Y){super(E.n,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",Y)}}(0,C.e)("FlowGraphInfBlock",r);class X extends b{constructor(Y){super(E.n,(()=>Number.NaN),"FlowGraphNaNBlock",Y)}}function Z(Y,c){switch((0,M.h)(Y)){case"FlowGraphInteger":return new q.c(c(Y.value));case"Vector2":return new H.Vector2(c(Y.x),c(Y.y));case"bh":return new H.bh(c(Y.x),c(Y.y),c(Y.z));case"Vector4":return new H.Vector4(c(Y.x),c(Y.y),c(Y.z),c(Y.w));case"Quaternion":return new H.Quaternion(c(Y.x),c(Y.y),c(Y.z),c(Y.w));case"Matrix":return H.Matrix.dh(Y.m.map(c));case"Matrix2D":return new k.c(Y.m.map(c));case"Matrix3D":return new k.d(Y.m.map(c));default:return c(Y)}}(0,C.e)("FlowGraphNaNBlock",X);class a extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicAbs(Y)),"FlowGraphAbsBlock",Y)}_polymorphicAbs(Y){return Z(Y,Math.abs)}}(0,C.e)("FlowGraphAbsBlock",a);class G extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicSign(Y)),"FlowGraphSignBlock",Y)}_polymorphicSign(Y){return Z(Y,Math.sign)}}(0,C.e)("FlowGraphSignBlock",G);class K extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicTrunc(Y)),"FlowGraphTruncBlock",Y)}_polymorphicTrunc(Y){return Z(Y,Math.trunc)}}(0,C.e)("FlowGraphTruncBlock",K);class I extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicFloor(Y)),"FlowGraphFloorBlock",Y)}_polymorphicFloor(Y){return Z(Y,Math.floor)}}(0,C.e)("FlowGraphFloorBlock",I);class s extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicCeiling(Y)),"FlowGraphCeilBlock",Y)}_polymorphicCeiling(Y){return Z(Y,Math.ceil)}}(0,C.e)("FlowGraphCeilBlock",s);class x extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicRound(Y)),"FlowGraphRoundBlock",Y)}_polymorphicRound(Y){return Z(Y,(Y=>{var c;return Y<0&&null!==(c=this.config)&&void 0!==c&&c.roundHalfAwayFromZero?-Math.round(-Y):Math.round(Y)}))}}(0,C.e)("FlowGraphRoundBlock",x);class A extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicFraction(Y)),"FlowGraphFractBlock",Y)}_polymorphicFraction(Y){return Z(Y,(Y=>Y-Math.floor(Y)))}}(0,C.e)("FlowGraphFractBlock",A);class V extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicNeg(Y)),"FlowGraphNegationBlock",Y)}_polymorphicNeg(Y){return Z(Y,(Y=>-Y))}}function U(Y,c,h){switch((0,M.h)(Y)){case"FlowGraphInteger":return new q.c(h(Y.value,c.value));case"Vector2":return new H.Vector2(h(Y.x,c.x),h(Y.y,c.y));case"bh":return new H.bh(h(Y.x,c.x),h(Y.y,c.y),h(Y.z,c.z));case"Vector4":return new H.Vector4(h(Y.x,c.x),h(Y.y,c.y),h(Y.z,c.z),h(Y.w,c.w));case"Quaternion":return new H.Quaternion(h(Y.x,c.x),h(Y.y,c.y),h(Y.z,c.z),h(Y.w,c.w));case"Matrix":return H.Matrix.dh(Y.m.map(((Y,C)=>h(Y,c.m[C]))));case"Matrix2D":return new k.c(Y.m.map(((Y,C)=>h(Y,c.m[C]))));case"Matrix3D":return new k.d(Y.m.map(((Y,C)=>h(Y,c.m[C]))));default:return h((0,M.m)(Y),(0,M.m)(c))}}(0,C.e)("FlowGraphNegationBlock",V);class l extends N.c{constructor(Y){super(E.c,E.c,E.c,((Y,c)=>this._polymorphicRemainder(Y,c)),"FlowGraphModuloBlock",Y)}_polymorphicRemainder(Y,c){return U(Y,c,((Y,c)=>Y%c))}}(0,C.e)("FlowGraphModuloBlock",l);class n extends N.c{constructor(Y){super(E.c,E.c,E.c,((Y,c)=>this._polymorphicMin(Y,c)),"FlowGraphMinBlock",Y)}_polymorphicMin(Y,c){return U(Y,c,Math.min)}}(0,C.e)("FlowGraphMinBlock",n);class v extends N.c{constructor(Y){super(E.c,E.c,E.c,((Y,c)=>this._polymorphicMax(Y,c)),"FlowGraphMaxBlock",Y)}_polymorphicMax(Y,c){return U(Y,c,Math.max)}}function g(Y,c,h){return Math.min(Math.max(Y,Math.min(c,h)),Math.max(c,h))}function z(Y,c,h,C){switch((0,M.h)(Y)){case"FlowGraphInteger":return new q.c(C(Y.value,c.value,h.value));case"Vector2":return new H.Vector2(C(Y.x,c.x,h.x),C(Y.y,c.y,h.y));case"bh":return new H.bh(C(Y.x,c.x,h.x),C(Y.y,c.y,h.y),C(Y.z,c.z,h.z));case"Vector4":return new H.Vector4(C(Y.x,c.x,h.x),C(Y.y,c.y,h.y),C(Y.z,c.z,h.z),C(Y.w,c.w,h.w));case"Quaternion":return new H.Quaternion(C(Y.x,c.x,h.x),C(Y.y,c.y,h.y),C(Y.z,c.z,h.z),C(Y.w,c.w,h.w));case"Matrix":return H.Matrix.dh(Y.m.map(((Y,E)=>C(Y,c.m[E],h.m[E]))));case"Matrix2D":return new k.c(Y.m.map(((Y,E)=>C(Y,c.m[E],h.m[E]))));case"Matrix3D":return new k.d(Y.m.map(((Y,E)=>C(Y,c.m[E],h.m[E]))));default:return C((0,M.m)(Y),(0,M.m)(c),(0,M.m)(h))}}(0,C.e)("FlowGraphMaxBlock",v);class O extends W{constructor(Y){super(E.c,E.c,E.c,E.c,((Y,c,h)=>this._polymorphicClamp(Y,c,h)),"FlowGraphClampBlock",Y)}_polymorphicClamp(Y,c,h){return z(Y,c,h,g)}}function o(Y){return Math.min(Math.max(Y,0),1)}(0,C.e)("FlowGraphClampBlock",O);class f extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicSaturate(Y)),"FlowGraphSaturateBlock",Y)}_polymorphicSaturate(Y){return Z(Y,o)}}function L(Y,c,h){return(1-h)*Y+h*c}(0,C.e)("FlowGraphSaturateBlock",f);class u extends W{constructor(Y){super(E.c,E.c,E.c,E.c,((Y,c,h)=>this._polymorphicInterpolate(Y,c,h)),"FlowGraphMathInterpolationBlock",Y)}_polymorphicInterpolate(Y,c,h){return z(Y,c,h,L)}}(0,C.e)("FlowGraphMathInterpolationBlock",u);class i extends N.c{constructor(Y){super(E.c,E.c,E.d,((Y,c)=>this._polymorphicEq(Y,c)),"FlowGraphEqualityBlock",Y)}_polymorphicEq(Y,c){const h=(0,M.h)(Y),C=(0,M.h)(c);return typeof Y===typeof c&&((0,M.d)(h,C)||(0,M.c)(h,C)||(0,M.b)(h,C)?Y.equals(c):Y===c)}}function R(Y,c,h){if((0,M.q)(Y)&&(0,M.q)(c))return h((0,M.m)(Y),(0,M.m)(c));throw new Error(`Cannot compare ${Y} and ${c}`)}(0,C.e)("FlowGraphEqualityBlock",i);class B extends N.c{constructor(Y){super(E.c,E.c,E.d,((Y,c)=>this._polymorphicLessThan(Y,c)),"FlowGraphLessThanBlock",Y)}_polymorphicLessThan(Y,c){return R(Y,c,((Y,c)=>Y<c))}}(0,C.e)("FlowGraphLessThanBlock",B);class t extends N.c{constructor(Y){super(E.c,E.c,E.d,((Y,c)=>this._polymorphicLessThanOrEqual(Y,c)),"FlowGraphLessThanOrEqualBlock",Y)}_polymorphicLessThanOrEqual(Y,c){return R(Y,c,((Y,c)=>Y<=c))}}(0,C.e)("FlowGraphLessThanOrEqualBlock",t);class F extends N.c{constructor(Y){super(E.c,E.c,E.d,((Y,c)=>this._polymorphicGreaterThan(Y,c)),"FlowGraphGreaterThanBlock",Y)}_polymorphicGreaterThan(Y,c){return R(Y,c,((Y,c)=>Y>c))}}(0,C.e)("FlowGraphGreaterThanBlock",F);class J extends N.c{constructor(Y){super(E.c,E.c,E.d,((Y,c)=>this._polymorphicGreaterThanOrEqual(Y,c)),"FlowGraphGreaterThanOrEqualBlock",Y)}_polymorphicGreaterThanOrEqual(Y,c){return R(Y,c,((Y,c)=>Y>=c))}}(0,C.e)("FlowGraphGreaterThanOrEqualBlock",J);class j extends w.e{constructor(Y){super(E.c,E.d,(Y=>this._polymorphicIsNan(Y)),"FlowGraphIsNaNBlock",Y)}_polymorphicIsNan(Y){if((0,M.q)(Y,!0))return isNaN((0,M.m)(Y));throw new Error(`Cannot get NaN of ${Y}`)}}(0,C.e)("FlowGraphIsNaNBlock",j);class S extends w.e{constructor(Y){super(E.c,E.d,(Y=>this._polymorphicIsInf(Y)),"FlowGraphIsInfBlock",Y)}_polymorphicIsInf(Y){if((0,M.q)(Y))return!isFinite((0,M.m)(Y));throw new Error(`Cannot get isInf of ${Y}`)}}(0,C.e)("FlowGraphIsInfBlock",S);class mY extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicDegToRad(Y)),"FlowGraphDegToRadBlock",Y)}_degToRad(Y){return Y*Math.PI/180}_polymorphicDegToRad(Y){return Z(Y,this._degToRad)}}(0,C.e)("FlowGraphDegToRadBlock",mY);class YY extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicRadToDeg(Y)),"FlowGraphRadToDegBlock",Y)}_radToDeg(Y){return 180*Y/Math.PI}_polymorphicRadToDeg(Y){return Z(Y,this._radToDeg)}}(0,C.e)("FlowGraphRadToDegBlock",YY);class cY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicSin(Y)),"FlowGraphSinBlock",Y)}_polymorphicSin(Y){return Z(Y,Math.sin)}}class hY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicCos(Y)),"FlowGraphCosBlock",Y)}_polymorphicCos(Y){return Z(Y,Math.cos)}}class CY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicTan(Y)),"FlowGraphTanBlock",Y)}_polymorphicTan(Y){return Z(Y,Math.tan)}}class EY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicAsin(Y)),"FlowGraphASinBlock",Y)}_polymorphicAsin(Y){return Z(Y,Math.asin)}}(0,C.e)("FlowGraphASinBlock",EY);class NY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicAcos(Y)),"FlowGraphACosBlock",Y)}_polymorphicAcos(Y){return Z(Y,Math.acos)}}(0,C.e)("FlowGraphACosBlock",NY);class QY extends w.e{constructor(Y){super(E.n,E.n,(Y=>this._polymorphicAtan(Y)),"FlowGraphATanBlock",Y)}_polymorphicAtan(Y){return Z(Y,Math.atan)}}(0,C.e)("FlowGraphATanBlock",QY);class bY extends N.c{constructor(Y){super(E.c,E.c,E.c,((Y,c)=>this._polymorphicAtan2(Y,c)),"FlowGraphATan2Block",Y)}_polymorphicAtan2(Y,c){return U(Y,c,Math.atan2)}}(0,C.e)("FlowGraphATan2Block",bY);class HY extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicSinh(Y)),"FlowGraphSinhBlock",Y)}_polymorphicSinh(Y){return Z(Y,Math.sinh)}}(0,C.e)("FlowGraphSinhBlock",HY);class wY extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicCosh(Y)),"FlowGraphCoshBlock",Y)}_polymorphicCosh(Y){return Z(Y,Math.cosh)}}(0,C.e)("FlowGraphCoshBlock",wY);class WY extends w.e{constructor(Y){super(E.c,E.c,(Y=>this._polymorphicTanh(Y)),"FlowGraphTanhBlock",Y)}_polymorphicTanh(Y){return Z(Y,Math.tanh)}}(0,C.e)("FlowGraphTanhBlock",WY);class qY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicAsinh(Y)),"FlowGraphASinhBlock",Y)}_polymorphicAsinh(Y){return Z(Y,Math.asinh)}}(0,C.e)("FlowGraphASinhBlock",qY);class kY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicAcosh(Y)),"FlowGraphACoshBlock",Y)}_polymorphicAcosh(Y){return Z(Y,Math.acosh)}}(0,C.e)("FlowGraphACoshBlock",kY);class MY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicAtanh(Y)),"FlowGraphATanhBlock",Y)}_polymorphicAtanh(Y){return Z(Y,Math.atanh)}}(0,C.e)("FlowGraphATanhBlock",MY);class pY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicExp(Y)),"FlowGraphExponentialBlock",Y)}_polymorphicExp(Y){return Z(Y,Math.exp)}}(0,C.e)("FlowGraphExponentialBlock",pY);class PY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicLog(Y)),"FlowGraphLogBlock",Y)}_polymorphicLog(Y){return Z(Y,Math.log)}}(0,C.e)("FlowGraphLogBlock",PY);class yY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicLog2(Y)),"FlowGraphLog2Block",Y)}_polymorphicLog2(Y){return Z(Y,Math.log2)}}(0,C.e)("FlowGraphLog2Block",yY);class dY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicLog10(Y)),"FlowGraphLog10Block",Y)}_polymorphicLog10(Y){return Z(Y,Math.log10)}}(0,C.e)("FlowGraphLog10Block",dY);class DY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicSqrt(Y)),"FlowGraphSquareRootBlock",Y)}_polymorphicSqrt(Y){return Z(Y,Math.sqrt)}}(0,C.e)("FlowGraphSquareRootBlock",DY);class TY extends w.e{constructor(Y){super(E.c,E.n,(Y=>this._polymorphicCubeRoot(Y)),"FlowGraphCubeRootBlock",Y)}_polymorphicCubeRoot(Y){return Z(Y,Math.cbrt)}}(0,C.e)("FlowGraphCubeRootBlock",TY);class eY extends N.c{constructor(Y){super(E.c,E.n,E.n,((Y,c)=>this._polymorphicPow(Y,c)),"FlowGraphPowerBlock",Y)}_polymorphicPow(Y,c){return U(Y,c,Math.pow)}}(0,C.e)("FlowGraphPowerBlock",eY);class rY extends w.e{constructor(Y){super((0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(Y=>"boolean"===typeof Y?!Y:"number"===typeof Y?~Y:new q.c(~Y.value)),"FlowGraphBitwiseNotBlock",Y)}}(0,C.e)("FlowGraphBitwiseNotBlock",rY);class XY extends N.c{constructor(Y){super((0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),((Y,c)=>{if("boolean"===typeof Y&&"boolean"===typeof c)return Y&&c;if("number"===typeof Y&&"number"===typeof c)return Y&c;if("object"===typeof Y&&"object"===typeof c)return new q.c(Y.value&c.value);throw new Error(`Cannot perform bitwise AND on ${Y} and ${c}`)}),"FlowGraphBitwiseAndBlock",Y)}}(0,C.e)("FlowGraphBitwiseAndBlock",XY);class ZY extends N.c{constructor(Y){super((0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),((Y,c)=>{if("boolean"===typeof Y&&"boolean"===typeof c)return Y||c;if("number"===typeof Y&&"number"===typeof c)return Y|c;if("object"===typeof Y&&"object"===typeof c)return new q.c(Y.value|c.value);throw new Error(`Cannot perform bitwise OR on ${Y} and ${c}`)}),"FlowGraphBitwiseOrBlock",Y)}}(0,C.e)("FlowGraphBitwiseOrBlock",ZY);class aY extends N.c{constructor(Y){super((0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),(0,E.H)((null===Y||void 0===Y?void 0:Y.valueType)||"FlowGraphInteger"),((Y,c)=>{if("boolean"===typeof Y&&"boolean"===typeof c)return Y!==c;if("number"===typeof Y&&"number"===typeof c)return Y^c;if("object"===typeof Y&&"object"===typeof c)return new q.c(Y.value^c.value);throw new Error(`Cannot perform bitwise XOR on ${Y} and ${c}`)}),"FlowGraphBitwiseXorBlock",Y)}}(0,C.e)("FlowGraphBitwiseXorBlock",aY);class GY extends N.c{constructor(Y){super(E.h,E.h,E.h,((Y,c)=>new q.c(Y.value<<c.value)),"FlowGraphBitwiseLeftShiftBlock",Y)}}(0,C.e)("FlowGraphBitwiseLeftShiftBlock",GY);class KY extends N.c{constructor(Y){super(E.h,E.h,E.h,((Y,c)=>new q.c(Y.value>>c.value)),"FlowGraphBitwiseRightShiftBlock",Y)}}(0,C.e)("FlowGraphBitwiseRightShiftBlock",KY);class IY extends w.e{constructor(Y){super(E.h,E.h,(Y=>new q.c(Math.clz32(Y.value))),"FlowGraphLeadingZerosBlock",Y)}}(0,C.e)("FlowGraphLeadingZerosBlock",IY);class sY extends w.e{constructor(Y){super(E.h,E.h,(Y=>new q.c(Y.value?31-Math.clz32(Y.value&-Y.value):32)),"FlowGraphTrailingZerosBlock",Y)}}(0,C.e)("FlowGraphTrailingZerosBlock",sY);class xY extends w.e{constructor(Y){super(E.h,E.h,(Y=>new q.c(function(Y){let c=0;for(;Y;)c+=1&Y,Y>>=1;return c}(Y.value))),"FlowGraphOneBitsCounterBlock",Y)}}(0,C.e)("FlowGraphOneBitsCounterBlock",xY)},16197:(Y,c,h)=>{h.d(c,{c:()=>E});var C=h(16201);class E extends C.d{constructor(Y,c,h,C,E,N){super(h,N),this._operation=C,this._className=E,this.a=this.registerDataInput("a",Y),this.b=this.registerDataInput("b",c)}_doOperation(Y){const c=this.a.getValue(Y),h=this.b.getValue(Y);return this._operation(c,h)}getClassName(){return this._className}}},16201:(Y,c,h)=>{h.d(c,{d:()=>b});var C=h(14482),E=h(14459);const N="cachedOperationValue",Q="cachedExecutionId";class b extends C.b{constructor(Y,c){super(c),this.value=this.registerDataOutput("value",Y),this.isValid=this.registerDataOutput("isValid",E.d)}_updateOutputs(Y){const c=Y._getExecutionVariable(this,Q,-1),h=Y._getExecutionVariable(this,N,null);if(void 0!==h&&null!==h&&c===Y.executionId)this.isValid.setValue(!0,Y),this.value.setValue(h,Y);else try{const c=this._doOperation(Y);if(void 0===c||null===c)return void this.isValid.setValue(!1,Y);Y._setExecutionVariable(this,N,c),Y._setExecutionVariable(this,Q,Y.executionId),this.value.setValue(c,Y),this.isValid.setValue(!0,Y)}catch(C){this.isValid.setValue(!1,Y)}}}},16204:(Y,c,h)=>{h.d(c,{e:()=>E});var C=h(16201);class E extends C.d{constructor(Y,c,h,C,E){super(c,E),this._operation=h,this._className=C,this.a=this.registerDataInput("a",Y)}_doOperation(Y){return this._operation(this.a.getValue(Y))}getClassName(){return this._className}}}}]);