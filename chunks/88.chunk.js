"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[88],{14966:(E,t,z)=>{z.r(t),z.d(t,{FlowGraphAbsBlock:()=>l,FlowGraphAcosBlock:()=>RE,FlowGraphAcoshBlock:()=>dE,FlowGraphAddBlock:()=>O,FlowGraphAsinBlock:()=>XE,FlowGraphAsinhBlock:()=>hE,FlowGraphAtan2Block:()=>pE,FlowGraphAtanBlock:()=>uE,FlowGraphAtanhBlock:()=>yE,FlowGraphBitwiseAndBlock:()=>DE,FlowGraphBitwiseLeftShiftBlock:()=>fE,FlowGraphBitwiseNotBlock:()=>eE,FlowGraphBitwiseOrBlock:()=>SE,FlowGraphBitwiseRightShiftBlock:()=>KE,FlowGraphBitwiseXorBlock:()=>lE,FlowGraphCeilBlock:()=>B,FlowGraphClampBlock:()=>T,FlowGraphCosBlock:()=>zE,FlowGraphCoshBlock:()=>ZE,FlowGraphCubeRootBlock:()=>WE,FlowGraphDegToRadBlock:()=>P,FlowGraphDivideBlock:()=>L,FlowGraphEBlock:()=>W,FlowGraphEqualityBlock:()=>s,FlowGraphExpBlock:()=>OE,FlowGraphFloorBlock:()=>F,FlowGraphFractionBlock:()=>x,FlowGraphGreaterThanBlock:()=>v,FlowGraphGreaterThanOrEqualBlock:()=>Y,FlowGraphInfBlock:()=>e,FlowGraphIsInfinityBlock:()=>N,FlowGraphIsNanBlock:()=>G,FlowGraphLeadingZerosBlock:()=>FE,FlowGraphLessThanBlock:()=>U,FlowGraphLessThanOrEqualBlock:()=>k,FlowGraphLog10Block:()=>LE,FlowGraphLog2Block:()=>aE,FlowGraphLogBlock:()=>cE,FlowGraphMathInterpolationBlock:()=>n,FlowGraphMaxBlock:()=>g,FlowGraphMinBlock:()=>i,FlowGraphModuloBlock:()=>r,FlowGraphMultiplyBlock:()=>a,FlowGraphNaNBlock:()=>D,FlowGraphNegationBlock:()=>J,FlowGraphOneBitsCounterBlock:()=>bE,FlowGraphPiBlock:()=>I,FlowGraphPowerBlock:()=>IE,FlowGraphRadToDegBlock:()=>EE,FlowGraphRandomBlock:()=>mE,FlowGraphRoundBlock:()=>b,FlowGraphSaturateBlock:()=>M,FlowGraphSignBlock:()=>f,FlowGraphSinBlock:()=>tE,FlowGraphSinhBlock:()=>CE,FlowGraphSquareRootBlock:()=>mt,FlowGraphSubtractBlock:()=>c,FlowGraphTanBlock:()=>AE,FlowGraphTanhBlock:()=>HE,FlowGraphTrailingZerosBlock:()=>BE,FlowGraphTruncBlock:()=>K});var A=z(11766),X=z(13458),R=z(14970),u=z(14978);class p extends u.b{constructor(E,t,z,A){super(E,A),this._operation=t,this._className=z}_doOperation(E){return this._operation(E)}getClassName(){return this._className}}var C=z(11812),Z=z(14980);class H extends u.b{constructor(E,t,z,A,X,R,u){super(A,u),this._operation=X,this._className=R,this.a=this.registerDataInput("a",E),this.b=this.registerDataInput("b",t),this.c=this.registerDataInput("c",z)}_doOperation(E){return this._operation(this.a.getValue(E),this.b.getValue(E),this.c.getValue(E))}getClassName(){return this._className}}var h=z(13456),d=z(13466),y=z(13494);class O extends R.b{constructor(E){super((0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),((E,t)=>this._polymorphicAdd(E,t)),"FlowGraphAddBlock",E)}_polymorphicAdd(E,t){const z=(0,y.m)(E),A=(0,y.m)(t);if((0,y.i)(z,A)||(0,y.e)(z,A)||(0,y.c)(z,A))return E.add(t);if("Quaternion"===z||"Vector4"===A)return new C.Vector4(E.x,E.y,E.z,E.w).addInPlace(t);if("Vector4"===z||"Quaternion"===A)return E.add(t);var X;if(null!==(X=this.config)&&void 0!==X&&X.preventIntegerFloatArithmetic&&typeof E!==typeof t)throw new Error("Cannot add different types of numbers.");return(0,y.s)(E)+(0,y.s)(t)}}(0,A.f)("FlowGraphAddBlock",O);class c extends R.b{constructor(E){super((0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),((E,t)=>this._polymorphicSubtract(E,t)),"FlowGraphSubtractBlock",E)}_polymorphicSubtract(E,t){const z=(0,y.m)(E),A=(0,y.m)(t);if((0,y.i)(z,A)||(0,y.c)(z,A)||(0,y.e)(z,A))return E.Wt(t);if("Quaternion"===z||"Vector4"===A)return new C.Vector4(E.x,E.y,E.z,E.w).kH(t);if("Vector4"===z||"Quaternion"===A)return E.Wt(t);var X;if(null!==(X=this.config)&&void 0!==X&&X.preventIntegerFloatArithmetic&&typeof E!==typeof t)throw new Error("Cannot add different types of numbers.");return(0,y.s)(E)-(0,y.s)(t)}}(0,A.f)("FlowGraphSubtractBlock",c);class a extends R.b{constructor(E){super((0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),((E,t)=>this._polymorphicMultiply(E,t)),"FlowGraphMultiplyBlock",E)}_polymorphicMultiply(E,t){const z=(0,y.m)(E),A=(0,y.m)(t);if((0,y.i)(z,A)||(0,y.c)(z,A))return E.multiply(t);if("Quaternion"===z||"Vector4"===A)return new C.Vector4(E.x,E.y,E.z,E.w).multiplyInPlace(t);if("Vector4"===z||"Quaternion"===A)return E.multiply(t);if((0,y.e)(z,A)){var X;if(null!==(X=this.config)&&void 0!==X&&X.useMatrixPerComponent){const A=E.m;for(let E=0;E<A.length;E++)A[E]*=t.m[E];return"Matrix2D"===z?new d.d(A):"Matrix3D"===z?new d.f(A):C.Matrix.St(A)}return t.multiply(E)}var R;if(null!==(R=this.config)&&void 0!==R&&R.preventIntegerFloatArithmetic&&typeof E!==typeof t)throw new Error("Cannot add different types of numbers.");return(0,y.s)(E)*(0,y.s)(t)}}(0,A.f)("FlowGraphMultiplyBlock",a);class L extends R.b{constructor(E){super((0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),(0,X.J)(null===E||void 0===E?void 0:E.type),((E,t)=>this._polymorphicDivide(E,t)),"FlowGraphDivideBlock",E)}_polymorphicDivide(E,t){const z=(0,y.m)(E),A=(0,y.m)(t);if((0,y.i)(z,A)||(0,y.c)(z,A))return E.divide(t);if("Quaternion"===z||"Quaternion"===A){const z=E.clone();return z.x/=t.x,z.y/=t.y,z.z/=t.z,z.w/=t.w,z}if("Quaternion"===z||"Vector4"===A)return new C.Vector4(E.x,E.y,E.z,E.w).divideInPlace(t);if("Vector4"===z||"Quaternion"===A)return E.divide(t);if((0,y.e)(z,A)){var X;if(null!==(X=this.config)&&void 0!==X&&X.useMatrixPerComponent){const A=E.m;for(let E=0;E<A.length;E++)A[E]/=t.m[E];return"Matrix2D"===z?new d.d(A):"Matrix3D"===z?new d.f(A):C.Matrix.St(A)}return E.divide(t)}var R;if(null!==(R=this.config)&&void 0!==R&&R.preventIntegerFloatArithmetic&&typeof E!==typeof t)throw new Error("Cannot add different types of numbers.");return(0,y.s)(E)/(0,y.s)(t)}}(0,A.f)("FlowGraphDivideBlock",L);class mE extends p{constructor(E){super(X.p,(E=>this._random(E)),"FlowGraphRandomBlock",E),this.min=this.registerDataInput("min",X.p,(null===E||void 0===E?void 0:E.min)??0),this.max=this.registerDataInput("max",X.p,(null===E||void 0===E?void 0:E.max)??1),null!==E&&void 0!==E&&E.seed&&(this._seed=E.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const E=1e4*Math.sin(this._seed++);return E-Math.floor(E)}return Math.random()}_random(E){const t=this.min.getValue(E),z=this.max.getValue(E);return this._getRandomValue()*(z-t)+t}}(0,A.f)("FlowGraphRandomBlock",mE);class W extends p{constructor(E){super(X.p,(()=>Math.E),"FlowGraphEBlock",E)}}(0,A.f)("FlowGraphEBlock",W);class I extends p{constructor(E){super(X.p,(()=>Math.PI),"FlowGraphPIBlock",E)}}(0,A.f)("FlowGraphPIBlock",I);class e extends p{constructor(E){super(X.p,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",E)}}(0,A.f)("FlowGraphInfBlock",e);class D extends p{constructor(E){super(X.p,(()=>Number.NaN),"FlowGraphNaNBlock",E)}}function S(E,t){switch((0,y.m)(E)){case"FlowGraphInteger":return new h.e(t(E.value));case"Vector2":return new C.Vector2(t(E.x),t(E.y));case"Lt":return new C.Lt(t(E.x),t(E.y),t(E.z));case"Vector4":return new C.Vector4(t(E.x),t(E.y),t(E.z),t(E.w));case"Quaternion":return new C.Quaternion(t(E.x),t(E.y),t(E.z),t(E.w));case"Matrix":return C.Matrix.St(E.m.map(t));case"Matrix2D":return new d.d(E.m.map(t));case"Matrix3D":return new d.f(E.m.map(t));default:return t(E)}}(0,A.f)("FlowGraphNaNBlock",D);class l extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicAbs(E)),"FlowGraphAbsBlock",E)}_polymorphicAbs(E){return S(E,Math.abs)}}(0,A.f)("FlowGraphAbsBlock",l);class f extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicSign(E)),"FlowGraphSignBlock",E)}_polymorphicSign(E){return S(E,Math.sign)}}(0,A.f)("FlowGraphSignBlock",f);class K extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicTrunc(E)),"FlowGraphTruncBlock",E)}_polymorphicTrunc(E){return S(E,Math.trunc)}}(0,A.f)("FlowGraphTruncBlock",K);class F extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicFloor(E)),"FlowGraphFloorBlock",E)}_polymorphicFloor(E){return S(E,Math.floor)}}(0,A.f)("FlowGraphFloorBlock",F);class B extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicCeiling(E)),"FlowGraphCeilBlock",E)}_polymorphicCeiling(E){return S(E,Math.ceil)}}(0,A.f)("FlowGraphCeilBlock",B);class b extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicRound(E)),"FlowGraphRoundBlock",E)}_polymorphicRound(E){return S(E,(E=>{var t;return E<0&&null!==(t=this.config)&&void 0!==t&&t.roundHalfAwayFromZero?-Math.round(-E):Math.round(E)}))}}(0,A.f)("FlowGraphRoundBlock",b);class x extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicFraction(E)),"FlowGraphFractBlock",E)}_polymorphicFraction(E){return S(E,(E=>E-Math.floor(E)))}}(0,A.f)("FlowGraphFractBlock",x);class J extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicNeg(E)),"FlowGraphNegationBlock",E)}_polymorphicNeg(E){return S(E,(E=>-E))}}function V(E,t,z){switch((0,y.m)(E)){case"FlowGraphInteger":return new h.e(z(E.value,t.value));case"Vector2":return new C.Vector2(z(E.x,t.x),z(E.y,t.y));case"Lt":return new C.Lt(z(E.x,t.x),z(E.y,t.y),z(E.z,t.z));case"Vector4":return new C.Vector4(z(E.x,t.x),z(E.y,t.y),z(E.z,t.z),z(E.w,t.w));case"Quaternion":return new C.Quaternion(z(E.x,t.x),z(E.y,t.y),z(E.z,t.z),z(E.w,t.w));case"Matrix":return C.Matrix.St(E.m.map(((E,A)=>z(E,t.m[A]))));case"Matrix2D":return new d.d(E.m.map(((E,A)=>z(E,t.m[A]))));case"Matrix3D":return new d.f(E.m.map(((E,A)=>z(E,t.m[A]))));default:return z((0,y.s)(E),(0,y.s)(t))}}(0,A.f)("FlowGraphNegationBlock",J);class r extends R.b{constructor(E){super(X.c,X.c,X.c,((E,t)=>this._polymorphicRemainder(E,t)),"FlowGraphModuloBlock",E)}_polymorphicRemainder(E,t){return V(E,t,((E,t)=>E%t))}}(0,A.f)("FlowGraphModuloBlock",r);class i extends R.b{constructor(E){super(X.c,X.c,X.c,((E,t)=>this._polymorphicMin(E,t)),"FlowGraphMinBlock",E)}_polymorphicMin(E,t){return V(E,t,Math.min)}}(0,A.f)("FlowGraphMinBlock",i);class g extends R.b{constructor(E){super(X.c,X.c,X.c,((E,t)=>this._polymorphicMax(E,t)),"FlowGraphMaxBlock",E)}_polymorphicMax(E,t){return V(E,t,Math.max)}}function o(E,t,z){return Math.min(Math.max(E,Math.min(t,z)),Math.max(t,z))}function Q(E,t,z,A){switch((0,y.m)(E)){case"FlowGraphInteger":return new h.e(A(E.value,t.value,z.value));case"Vector2":return new C.Vector2(A(E.x,t.x,z.x),A(E.y,t.y,z.y));case"Lt":return new C.Lt(A(E.x,t.x,z.x),A(E.y,t.y,z.y),A(E.z,t.z,z.z));case"Vector4":return new C.Vector4(A(E.x,t.x,z.x),A(E.y,t.y,z.y),A(E.z,t.z,z.z),A(E.w,t.w,z.w));case"Quaternion":return new C.Quaternion(A(E.x,t.x,z.x),A(E.y,t.y,z.y),A(E.z,t.z,z.z),A(E.w,t.w,z.w));case"Matrix":return C.Matrix.St(E.m.map(((E,X)=>A(E,t.m[X],z.m[X]))));case"Matrix2D":return new d.d(E.m.map(((E,X)=>A(E,t.m[X],z.m[X]))));case"Matrix3D":return new d.f(E.m.map(((E,X)=>A(E,t.m[X],z.m[X]))));default:return A((0,y.s)(E),(0,y.s)(t),(0,y.s)(z))}}(0,A.f)("FlowGraphMaxBlock",g);class T extends H{constructor(E){super(X.c,X.c,X.c,X.c,((E,t,z)=>this._polymorphicClamp(E,t,z)),"FlowGraphClampBlock",E)}_polymorphicClamp(E,t,z){return Q(E,t,z,o)}}function q(E){return Math.min(Math.max(E,0),1)}(0,A.f)("FlowGraphClampBlock",T);class M extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicSaturate(E)),"FlowGraphSaturateBlock",E)}_polymorphicSaturate(E){return S(E,q)}}function w(E,t,z){return(1-z)*E+z*t}(0,A.f)("FlowGraphSaturateBlock",M);class n extends H{constructor(E){super(X.c,X.c,X.c,X.c,((E,t,z)=>this._polymorphicInterpolate(E,t,z)),"FlowGraphMathInterpolationBlock",E)}_polymorphicInterpolate(E,t,z){return Q(E,t,z,w)}}(0,A.f)("FlowGraphMathInterpolationBlock",n);class s extends R.b{constructor(E){super(X.c,X.c,X.d,((E,t)=>this._polymorphicEq(E,t)),"FlowGraphEqualityBlock",E)}_polymorphicEq(E,t){const z=(0,y.m)(E),A=(0,y.m)(t);return typeof E===typeof t&&((0,y.i)(z,A)||(0,y.e)(z,A)||(0,y.c)(z,A)?E.equals(t):E===t)}}function j(E,t,z){if((0,y.u)(E)&&(0,y.u)(t))return z((0,y.s)(E),(0,y.s)(t));throw new Error(`Cannot compare ${E} and ${t}`)}(0,A.f)("FlowGraphEqualityBlock",s);class U extends R.b{constructor(E){super(X.c,X.c,X.d,((E,t)=>this._polymorphicLessThan(E,t)),"FlowGraphLessThanBlock",E)}_polymorphicLessThan(E,t){return j(E,t,((E,t)=>E<t))}}(0,A.f)("FlowGraphLessThanBlock",U);class k extends R.b{constructor(E){super(X.c,X.c,X.d,((E,t)=>this._polymorphicLessThanOrEqual(E,t)),"FlowGraphLessThanOrEqualBlock",E)}_polymorphicLessThanOrEqual(E,t){return j(E,t,((E,t)=>E<=t))}}(0,A.f)("FlowGraphLessThanOrEqualBlock",k);class v extends R.b{constructor(E){super(X.c,X.c,X.d,((E,t)=>this._polymorphicGreaterThan(E,t)),"FlowGraphGreaterThanBlock",E)}_polymorphicGreaterThan(E,t){return j(E,t,((E,t)=>E>t))}}(0,A.f)("FlowGraphGreaterThanBlock",v);class Y extends R.b{constructor(E){super(X.c,X.c,X.d,((E,t)=>this._polymorphicGreaterThanOrEqual(E,t)),"FlowGraphGreaterThanOrEqualBlock",E)}_polymorphicGreaterThanOrEqual(E,t){return j(E,t,((E,t)=>E>=t))}}(0,A.f)("FlowGraphGreaterThanOrEqualBlock",Y);class G extends Z.c{constructor(E){super(X.c,X.d,(E=>this._polymorphicIsNan(E)),"FlowGraphIsNaNBlock",E)}_polymorphicIsNan(E){if((0,y.u)(E,!0))return isNaN((0,y.s)(E));throw new Error(`Cannot get NaN of ${E}`)}}(0,A.f)("FlowGraphIsNaNBlock",G);class N extends Z.c{constructor(E){super(X.c,X.d,(E=>this._polymorphicIsInf(E)),"FlowGraphIsInfBlock",E)}_polymorphicIsInf(E){if((0,y.u)(E))return!isFinite((0,y.s)(E));throw new Error(`Cannot get isInf of ${E}`)}}(0,A.f)("FlowGraphIsInfBlock",N);class P extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicDegToRad(E)),"FlowGraphDegToRadBlock",E)}_degToRad(E){return E*Math.PI/180}_polymorphicDegToRad(E){return S(E,this._degToRad)}}(0,A.f)("FlowGraphDegToRadBlock",P);class EE extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicRadToDeg(E)),"FlowGraphRadToDegBlock",E)}_radToDeg(E){return 180*E/Math.PI}_polymorphicRadToDeg(E){return S(E,this._radToDeg)}}(0,A.f)("FlowGraphRadToDegBlock",EE);class tE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicSin(E)),"FlowGraphSinBlock",E)}_polymorphicSin(E){return S(E,Math.sin)}}class zE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicCos(E)),"FlowGraphCosBlock",E)}_polymorphicCos(E){return S(E,Math.cos)}}class AE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicTan(E)),"FlowGraphTanBlock",E)}_polymorphicTan(E){return S(E,Math.tan)}}class XE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicAsin(E)),"FlowGraphASinBlock",E)}_polymorphicAsin(E){return S(E,Math.asin)}}(0,A.f)("FlowGraphASinBlock",XE);class RE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicAcos(E)),"FlowGraphACosBlock",E)}_polymorphicAcos(E){return S(E,Math.acos)}}(0,A.f)("FlowGraphACosBlock",RE);class uE extends Z.c{constructor(E){super(X.p,X.p,(E=>this._polymorphicAtan(E)),"FlowGraphATanBlock",E)}_polymorphicAtan(E){return S(E,Math.atan)}}(0,A.f)("FlowGraphATanBlock",uE);class pE extends R.b{constructor(E){super(X.c,X.c,X.c,((E,t)=>this._polymorphicAtan2(E,t)),"FlowGraphATan2Block",E)}_polymorphicAtan2(E,t){return V(E,t,Math.atan2)}}(0,A.f)("FlowGraphATan2Block",pE);class CE extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicSinh(E)),"FlowGraphSinhBlock",E)}_polymorphicSinh(E){return S(E,Math.sinh)}}(0,A.f)("FlowGraphSinhBlock",CE);class ZE extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicCosh(E)),"FlowGraphCoshBlock",E)}_polymorphicCosh(E){return S(E,Math.cosh)}}(0,A.f)("FlowGraphCoshBlock",ZE);class HE extends Z.c{constructor(E){super(X.c,X.c,(E=>this._polymorphicTanh(E)),"FlowGraphTanhBlock",E)}_polymorphicTanh(E){return S(E,Math.tanh)}}(0,A.f)("FlowGraphTanhBlock",HE);class hE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicAsinh(E)),"FlowGraphASinhBlock",E)}_polymorphicAsinh(E){return S(E,Math.asinh)}}(0,A.f)("FlowGraphASinhBlock",hE);class dE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicAcosh(E)),"FlowGraphACoshBlock",E)}_polymorphicAcosh(E){return S(E,Math.acosh)}}(0,A.f)("FlowGraphACoshBlock",dE);class yE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicAtanh(E)),"FlowGraphATanhBlock",E)}_polymorphicAtanh(E){return S(E,Math.atanh)}}(0,A.f)("FlowGraphATanhBlock",yE);class OE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicExp(E)),"FlowGraphExponentialBlock",E)}_polymorphicExp(E){return S(E,Math.exp)}}(0,A.f)("FlowGraphExponentialBlock",OE);class cE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicLog(E)),"FlowGraphLogBlock",E)}_polymorphicLog(E){return S(E,Math.log)}}(0,A.f)("FlowGraphLogBlock",cE);class aE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicLog2(E)),"FlowGraphLog2Block",E)}_polymorphicLog2(E){return S(E,Math.log2)}}(0,A.f)("FlowGraphLog2Block",aE);class LE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicLog10(E)),"FlowGraphLog10Block",E)}_polymorphicLog10(E){return S(E,Math.log10)}}(0,A.f)("FlowGraphLog10Block",LE);class mt extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicSqrt(E)),"FlowGraphSquareRootBlock",E)}_polymorphicSqrt(E){return S(E,Math.sqrt)}}(0,A.f)("FlowGraphSquareRootBlock",mt);class WE extends Z.c{constructor(E){super(X.c,X.p,(E=>this._polymorphicCubeRoot(E)),"FlowGraphCubeRootBlock",E)}_polymorphicCubeRoot(E){return S(E,Math.cbrt)}}(0,A.f)("FlowGraphCubeRootBlock",WE);class IE extends R.b{constructor(E){super(X.c,X.p,X.p,((E,t)=>this._polymorphicPow(E,t)),"FlowGraphPowerBlock",E)}_polymorphicPow(E,t){return V(E,t,Math.pow)}}(0,A.f)("FlowGraphPowerBlock",IE);class eE extends Z.c{constructor(E){super((0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(E=>"boolean"===typeof E?!E:"number"===typeof E?~E:new h.e(~E.value)),"FlowGraphBitwiseNotBlock",E)}}(0,A.f)("FlowGraphBitwiseNotBlock",eE);class DE extends R.b{constructor(E){super((0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),((E,t)=>{if("boolean"===typeof E&&"boolean"===typeof t)return E&&t;if("number"===typeof E&&"number"===typeof t)return E&t;if("object"===typeof E&&"object"===typeof t)return new h.e(E.value&t.value);throw new Error(`Cannot perform bitwise AND on ${E} and ${t}`)}),"FlowGraphBitwiseAndBlock",E)}}(0,A.f)("FlowGraphBitwiseAndBlock",DE);class SE extends R.b{constructor(E){super((0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),((E,t)=>{if("boolean"===typeof E&&"boolean"===typeof t)return E||t;if("number"===typeof E&&"number"===typeof t)return E|t;if("object"===typeof E&&"object"===typeof t)return new h.e(E.value|t.value);throw new Error(`Cannot perform bitwise OR on ${E} and ${t}`)}),"FlowGraphBitwiseOrBlock",E)}}(0,A.f)("FlowGraphBitwiseOrBlock",SE);class lE extends R.b{constructor(E){super((0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),(0,X.J)((null===E||void 0===E?void 0:E.valueType)||"FlowGraphInteger"),((E,t)=>{if("boolean"===typeof E&&"boolean"===typeof t)return E!==t;if("number"===typeof E&&"number"===typeof t)return E^t;if("object"===typeof E&&"object"===typeof t)return new h.e(E.value^t.value);throw new Error(`Cannot perform bitwise XOR on ${E} and ${t}`)}),"FlowGraphBitwiseXorBlock",E)}}(0,A.f)("FlowGraphBitwiseXorBlock",lE);class fE extends R.b{constructor(E){super(X.e,X.e,X.e,((E,t)=>new h.e(E.value<<t.value)),"FlowGraphBitwiseLeftShiftBlock",E)}}(0,A.f)("FlowGraphBitwiseLeftShiftBlock",fE);class KE extends R.b{constructor(E){super(X.e,X.e,X.e,((E,t)=>new h.e(E.value>>t.value)),"FlowGraphBitwiseRightShiftBlock",E)}}(0,A.f)("FlowGraphBitwiseRightShiftBlock",KE);class FE extends Z.c{constructor(E){super(X.e,X.e,(E=>new h.e(Math.clz32(E.value))),"FlowGraphLeadingZerosBlock",E)}}(0,A.f)("FlowGraphLeadingZerosBlock",FE);class BE extends Z.c{constructor(E){super(X.e,X.e,(E=>new h.e(E.value?31-Math.clz32(E.value&-E.value):32)),"FlowGraphTrailingZerosBlock",E)}}(0,A.f)("FlowGraphTrailingZerosBlock",BE);class bE extends Z.c{constructor(E){super(X.e,X.e,(E=>new h.e(function(E){let t=0;for(;E;)t+=1&E,E>>=1;return t}(E.value))),"FlowGraphOneBitsCounterBlock",E)}}(0,A.f)("FlowGraphOneBitsCounterBlock",bE)},14970:(E,t,z)=>{z.d(t,{b:()=>X});var A=z(14978);class X extends A.b{constructor(E,t,z,A,X,R){super(z,R),this._operation=A,this._className=X,this.a=this.registerDataInput("a",E),this.b=this.registerDataInput("b",t)}_doOperation(E){const t=this.a.getValue(E),z=this.b.getValue(E);return this._operation(t,z)}getClassName(){return this._className}}},14978:(E,t,z)=>{z.d(t,{b:()=>p});var A=z(13480),X=z(13458);const R="cachedOperationValue",u="cachedExecutionId";class p extends A.c{constructor(E,t){super(t),this.value=this.registerDataOutput("value",E),this.isValid=this.registerDataOutput("isValid",X.d)}_updateOutputs(E){const t=E._getExecutionVariable(this,u,-1),z=E._getExecutionVariable(this,R,null);if(void 0!==z&&null!==z&&t===E.executionId)this.isValid.setValue(!0,E),this.value.setValue(z,E);else try{const t=this._doOperation(E);if(void 0===t||null===t)return void this.isValid.setValue(!1,E);E._setExecutionVariable(this,R,t),E._setExecutionVariable(this,u,E.executionId),this.value.setValue(t,E),this.isValid.setValue(!0,E)}catch(A){this.isValid.setValue(!1,E)}}}},14980:(E,t,z)=>{z.d(t,{c:()=>X});var A=z(14978);class X extends A.b{constructor(E,t,z,A,X){super(t,X),this._operation=z,this._className=A,this.a=this.registerDataInput("a",E)}_doOperation(E){return this._operation(this.a.getValue(E))}getClassName(){return this._className}}}}]);