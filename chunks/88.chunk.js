"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[88],{15005:(Z,h,V)=>{V.r(h),V.d(h,{FlowGraphAbsBlock:()=>l,FlowGraphAcosBlock:()=>HZ,FlowGraphAcoshBlock:()=>DZ,FlowGraphAddBlock:()=>u,FlowGraphAsinBlock:()=>AZ,FlowGraphAsinhBlock:()=>NZ,FlowGraphAtan2Block:()=>dZ,FlowGraphAtanBlock:()=>KZ,FlowGraphAtanhBlock:()=>kZ,FlowGraphBitwiseAndBlock:()=>PZ,FlowGraphBitwiseLeftShiftBlock:()=>BZ,FlowGraphBitwiseNotBlock:()=>jZ,FlowGraphBitwiseOrBlock:()=>CZ,FlowGraphBitwiseRightShiftBlock:()=>SZ,FlowGraphBitwiseXorBlock:()=>lZ,FlowGraphCeilBlock:()=>L,FlowGraphClampBlock:()=>Q,FlowGraphCosBlock:()=>VZ,FlowGraphCoshBlock:()=>nZ,FlowGraphCubeRootBlock:()=>XZ,FlowGraphDegToRadBlock:()=>G,FlowGraphDivideBlock:()=>o,FlowGraphEBlock:()=>X,FlowGraphEqualityBlock:()=>i,FlowGraphExpBlock:()=>uZ,FlowGraphFloorBlock:()=>r,FlowGraphFractionBlock:()=>W,FlowGraphGreaterThanBlock:()=>J,FlowGraphGreaterThanOrEqualBlock:()=>f,FlowGraphInfBlock:()=>j,FlowGraphIsInfinityBlock:()=>Y,FlowGraphIsNanBlock:()=>p,FlowGraphLeadingZerosBlock:()=>rZ,FlowGraphLessThanBlock:()=>O,FlowGraphLessThanOrEqualBlock:()=>s,FlowGraphLog10Block:()=>oZ,FlowGraphLog2Block:()=>bZ,FlowGraphLogBlock:()=>FZ,FlowGraphMathInterpolationBlock:()=>c,FlowGraphMaxBlock:()=>e,FlowGraphMinBlock:()=>I,FlowGraphModuloBlock:()=>g,FlowGraphMultiplyBlock:()=>b,FlowGraphNaNBlock:()=>P,FlowGraphNegationBlock:()=>z,FlowGraphOneBitsCounterBlock:()=>yZ,FlowGraphPiBlock:()=>E,FlowGraphPowerBlock:()=>EZ,FlowGraphRadToDegBlock:()=>ZZ,FlowGraphRandomBlock:()=>q,FlowGraphRoundBlock:()=>y,FlowGraphSaturateBlock:()=>T,FlowGraphSignBlock:()=>B,FlowGraphSinBlock:()=>hZ,FlowGraphSinhBlock:()=>aZ,FlowGraphSquareRootBlock:()=>qZ,FlowGraphSubtractBlock:()=>F,FlowGraphTanBlock:()=>vZ,FlowGraphTanhBlock:()=>xZ,FlowGraphTrailingZerosBlock:()=>LZ,FlowGraphTruncBlock:()=>S});var v=V(11691),A=V(13459),H=V(15012),K=V(15015);class d extends K.c{constructor(Z,h,V,v){super(Z,v),this._operation=h,this._className=V}_doOperation(Z){return this._operation(Z)}getClassName(){return this._className}}var a=V(11729),n=V(15024);class x extends K.c{constructor(Z,h,V,v,A,H,K){super(v,K),this._operation=A,this._className=H,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",h),this.c=this.registerDataInput("c",V)}_doOperation(Z){return this._operation(this.a.getValue(Z),this.b.getValue(Z),this.c.getValue(Z))}getClassName(){return this._className}}var N=V(13450),D=V(13466),k=V(13491);class u extends H.d{constructor(Z){super((0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),((Z,h)=>this._polymorphicAdd(Z,h)),"FlowGraphAddBlock",Z)}_polymorphicAdd(Z,h){const V=(0,k.l)(Z),v=(0,k.l)(h);if((0,k.k)(V,v)||(0,k.g)(V,v)||(0,k.d)(V,v))return Z.add(h);if("Quaternion"===V||"Vector4"===v)return new a.Vector4(Z.x,Z.y,Z.z,Z.w).addInPlace(h);if("Vector4"===V||"Quaternion"===v)return Z.add(h);var A;if(null!==(A=this.config)&&void 0!==A&&A.preventIntegerFloatArithmetic&&typeof Z!==typeof h)throw new Error("Cannot add different types of numbers.");return(0,k.q)(Z)+(0,k.q)(h)}}(0,v.i)("FlowGraphAddBlock",u);class F extends H.d{constructor(Z){super((0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),((Z,h)=>this._polymorphicSubtract(Z,h)),"FlowGraphSubtractBlock",Z)}_polymorphicSubtract(Z,h){const V=(0,k.l)(Z),v=(0,k.l)(h);if((0,k.k)(V,v)||(0,k.d)(V,v)||(0,k.g)(V,v))return Z.rh(h);if("Quaternion"===V||"Vector4"===v)return new a.Vector4(Z.x,Z.y,Z.z,Z.w).EN(h);if("Vector4"===V||"Quaternion"===v)return Z.rh(h);var A;if(null!==(A=this.config)&&void 0!==A&&A.preventIntegerFloatArithmetic&&typeof Z!==typeof h)throw new Error("Cannot add different types of numbers.");return(0,k.q)(Z)-(0,k.q)(h)}}(0,v.i)("FlowGraphSubtractBlock",F);class b extends H.d{constructor(Z){super((0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),((Z,h)=>this._polymorphicMultiply(Z,h)),"FlowGraphMultiplyBlock",Z)}_polymorphicMultiply(Z,h){const V=(0,k.l)(Z),v=(0,k.l)(h);if((0,k.k)(V,v)||(0,k.d)(V,v))return Z.multiply(h);if("Quaternion"===V||"Vector4"===v)return new a.Vector4(Z.x,Z.y,Z.z,Z.w).multiplyInPlace(h);if("Vector4"===V||"Quaternion"===v)return Z.multiply(h);if((0,k.g)(V,v)){var A;if(null!==(A=this.config)&&void 0!==A&&A.useMatrixPerComponent){const v=Z.m;for(let Z=0;Z<v.length;Z++)v[Z]*=h.m[Z];return"Matrix2D"===V?new D.c(v):"Matrix3D"===V?new D.f(v):a.Matrix.eh(v)}return h.multiply(Z)}var H;if(null!==(H=this.config)&&void 0!==H&&H.preventIntegerFloatArithmetic&&typeof Z!==typeof h)throw new Error("Cannot add different types of numbers.");return(0,k.q)(Z)*(0,k.q)(h)}}(0,v.i)("FlowGraphMultiplyBlock",b);class o extends H.d{constructor(Z){super((0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),(0,A.S)(null===Z||void 0===Z?void 0:Z.type),((Z,h)=>this._polymorphicDivide(Z,h)),"FlowGraphDivideBlock",Z)}_polymorphicDivide(Z,h){const V=(0,k.l)(Z),v=(0,k.l)(h);if((0,k.k)(V,v)||(0,k.d)(V,v))return Z.divide(h);if("Quaternion"===V||"Quaternion"===v){const V=Z.clone();return V.x/=h.x,V.y/=h.y,V.z/=h.z,V.w/=h.w,V}if("Quaternion"===V||"Vector4"===v)return new a.Vector4(Z.x,Z.y,Z.z,Z.w).divideInPlace(h);if("Vector4"===V||"Quaternion"===v)return Z.divide(h);if((0,k.g)(V,v)){var A;if(null!==(A=this.config)&&void 0!==A&&A.useMatrixPerComponent){const v=Z.m;for(let Z=0;Z<v.length;Z++)v[Z]/=h.m[Z];return"Matrix2D"===V?new D.c(v):"Matrix3D"===V?new D.f(v):a.Matrix.eh(v)}return Z.divide(h)}var H;if(null!==(H=this.config)&&void 0!==H&&H.preventIntegerFloatArithmetic&&typeof Z!==typeof h)throw new Error("Cannot add different types of numbers.");return(0,k.q)(Z)/(0,k.q)(h)}}(0,v.i)("FlowGraphDivideBlock",o);class q extends d{constructor(Z){super(A.t,(Z=>this._random(Z)),"FlowGraphRandomBlock",Z),this.min=this.registerDataInput("min",A.t,(null===Z||void 0===Z?void 0:Z.min)??0),this.max=this.registerDataInput("max",A.t,(null===Z||void 0===Z?void 0:Z.max)??1),null!==Z&&void 0!==Z&&Z.seed&&(this._seed=Z.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const Z=1e4*Math.sin(this._seed++);return Z-Math.floor(Z)}return Math.random()}_random(Z){const h=this.min.getValue(Z),V=this.max.getValue(Z);return this._getRandomValue()*(V-h)+h}}(0,v.i)("FlowGraphRandomBlock",q);class X extends d{constructor(Z){super(A.t,(()=>Math.E),"FlowGraphEBlock",Z)}}(0,v.i)("FlowGraphEBlock",X);class E extends d{constructor(Z){super(A.t,(()=>Math.PI),"FlowGraphPIBlock",Z)}}(0,v.i)("FlowGraphPIBlock",E);class j extends d{constructor(Z){super(A.t,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",Z)}}(0,v.i)("FlowGraphInfBlock",j);class P extends d{constructor(Z){super(A.t,(()=>Number.NaN),"FlowGraphNaNBlock",Z)}}function C(Z,h){switch((0,k.l)(Z)){case"FlowGraphInteger":return new N.b(h(Z.value));case"Vector2":return new a.Vector2(h(Z.x),h(Z.y));case"Ch":return new a.Ch(h(Z.x),h(Z.y),h(Z.z));case"Vector4":return new a.Vector4(h(Z.x),h(Z.y),h(Z.z),h(Z.w));case"Quaternion":return new a.Quaternion(h(Z.x),h(Z.y),h(Z.z),h(Z.w));case"Matrix":return a.Matrix.eh(Z.m.map(h));case"Matrix2D":return new D.c(Z.m.map(h));case"Matrix3D":return new D.f(Z.m.map(h));default:return h(Z)}}(0,v.i)("FlowGraphNaNBlock",P);class l extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicAbs(Z)),"FlowGraphAbsBlock",Z)}_polymorphicAbs(Z){return C(Z,Math.abs)}}(0,v.i)("FlowGraphAbsBlock",l);class B extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicSign(Z)),"FlowGraphSignBlock",Z)}_polymorphicSign(Z){return C(Z,Math.sign)}}(0,v.i)("FlowGraphSignBlock",B);class S extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicTrunc(Z)),"FlowGraphTruncBlock",Z)}_polymorphicTrunc(Z){return C(Z,Math.trunc)}}(0,v.i)("FlowGraphTruncBlock",S);class r extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicFloor(Z)),"FlowGraphFloorBlock",Z)}_polymorphicFloor(Z){return C(Z,Math.floor)}}(0,v.i)("FlowGraphFloorBlock",r);class L extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicCeiling(Z)),"FlowGraphCeilBlock",Z)}_polymorphicCeiling(Z){return C(Z,Math.ceil)}}(0,v.i)("FlowGraphCeilBlock",L);class y extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicRound(Z)),"FlowGraphRoundBlock",Z)}_polymorphicRound(Z){return C(Z,(Z=>{var h;return Z<0&&null!==(h=this.config)&&void 0!==h&&h.roundHalfAwayFromZero?-Math.round(-Z):Math.round(Z)}))}}(0,v.i)("FlowGraphRoundBlock",y);class W extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicFraction(Z)),"FlowGraphFractBlock",Z)}_polymorphicFraction(Z){return C(Z,(Z=>Z-Math.floor(Z)))}}(0,v.i)("FlowGraphFractBlock",W);class z extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicNeg(Z)),"FlowGraphNegationBlock",Z)}_polymorphicNeg(Z){return C(Z,(Z=>-Z))}}function m(Z,h,V){switch((0,k.l)(Z)){case"FlowGraphInteger":return new N.b(V(Z.value,h.value));case"Vector2":return new a.Vector2(V(Z.x,h.x),V(Z.y,h.y));case"Ch":return new a.Ch(V(Z.x,h.x),V(Z.y,h.y),V(Z.z,h.z));case"Vector4":return new a.Vector4(V(Z.x,h.x),V(Z.y,h.y),V(Z.z,h.z),V(Z.w,h.w));case"Quaternion":return new a.Quaternion(V(Z.x,h.x),V(Z.y,h.y),V(Z.z,h.z),V(Z.w,h.w));case"Matrix":return a.Matrix.eh(Z.m.map(((Z,v)=>V(Z,h.m[v]))));case"Matrix2D":return new D.c(Z.m.map(((Z,v)=>V(Z,h.m[v]))));case"Matrix3D":return new D.f(Z.m.map(((Z,v)=>V(Z,h.m[v]))));default:return V((0,k.q)(Z),(0,k.q)(h))}}(0,v.i)("FlowGraphNegationBlock",z);class g extends H.d{constructor(Z){super(A.c,A.c,A.c,((Z,h)=>this._polymorphicRemainder(Z,h)),"FlowGraphModuloBlock",Z)}_polymorphicRemainder(Z,h){return m(Z,h,((Z,h)=>Z%h))}}(0,v.i)("FlowGraphModuloBlock",g);class I extends H.d{constructor(Z){super(A.c,A.c,A.c,((Z,h)=>this._polymorphicMin(Z,h)),"FlowGraphMinBlock",Z)}_polymorphicMin(Z,h){return m(Z,h,Math.min)}}(0,v.i)("FlowGraphMinBlock",I);class e extends H.d{constructor(Z){super(A.c,A.c,A.c,((Z,h)=>this._polymorphicMax(Z,h)),"FlowGraphMaxBlock",Z)}_polymorphicMax(Z,h){return m(Z,h,Math.max)}}function U(Z,h,V){return Math.min(Math.max(Z,Math.min(h,V)),Math.max(h,V))}function R(Z,h,V,v){switch((0,k.l)(Z)){case"FlowGraphInteger":return new N.b(v(Z.value,h.value,V.value));case"Vector2":return new a.Vector2(v(Z.x,h.x,V.x),v(Z.y,h.y,V.y));case"Ch":return new a.Ch(v(Z.x,h.x,V.x),v(Z.y,h.y,V.y),v(Z.z,h.z,V.z));case"Vector4":return new a.Vector4(v(Z.x,h.x,V.x),v(Z.y,h.y,V.y),v(Z.z,h.z,V.z),v(Z.w,h.w,V.w));case"Quaternion":return new a.Quaternion(v(Z.x,h.x,V.x),v(Z.y,h.y,V.y),v(Z.z,h.z,V.z),v(Z.w,h.w,V.w));case"Matrix":return a.Matrix.eh(Z.m.map(((Z,A)=>v(Z,h.m[A],V.m[A]))));case"Matrix2D":return new D.c(Z.m.map(((Z,A)=>v(Z,h.m[A],V.m[A]))));case"Matrix3D":return new D.f(Z.m.map(((Z,A)=>v(Z,h.m[A],V.m[A]))));default:return v((0,k.q)(Z),(0,k.q)(h),(0,k.q)(V))}}(0,v.i)("FlowGraphMaxBlock",e);class Q extends x{constructor(Z){super(A.c,A.c,A.c,A.c,((Z,h,V)=>this._polymorphicClamp(Z,h,V)),"FlowGraphClampBlock",Z)}_polymorphicClamp(Z,h,V){return R(Z,h,V,U)}}function w(Z){return Math.min(Math.max(Z,0),1)}(0,v.i)("FlowGraphClampBlock",Q);class T extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicSaturate(Z)),"FlowGraphSaturateBlock",Z)}_polymorphicSaturate(Z){return C(Z,w)}}function t(Z,h,V){return(1-V)*Z+V*h}(0,v.i)("FlowGraphSaturateBlock",T);class c extends x{constructor(Z){super(A.c,A.c,A.c,A.c,((Z,h,V)=>this._polymorphicInterpolate(Z,h,V)),"FlowGraphMathInterpolationBlock",Z)}_polymorphicInterpolate(Z,h,V){return R(Z,h,V,t)}}(0,v.i)("FlowGraphMathInterpolationBlock",c);class i extends H.d{constructor(Z){super(A.c,A.c,A.f,((Z,h)=>this._polymorphicEq(Z,h)),"FlowGraphEqualityBlock",Z)}_polymorphicEq(Z,h){const V=(0,k.l)(Z),v=(0,k.l)(h);return typeof Z===typeof h&&((0,k.k)(V,v)||(0,k.g)(V,v)||(0,k.d)(V,v)?Z.equals(h):Z===h)}}function M(Z,h,V){if((0,k.u)(Z)&&(0,k.u)(h))return V((0,k.q)(Z),(0,k.q)(h));throw new Error(`Cannot compare ${Z} and ${h}`)}(0,v.i)("FlowGraphEqualityBlock",i);class O extends H.d{constructor(Z){super(A.c,A.c,A.f,((Z,h)=>this._polymorphicLessThan(Z,h)),"FlowGraphLessThanBlock",Z)}_polymorphicLessThan(Z,h){return M(Z,h,((Z,h)=>Z<h))}}(0,v.i)("FlowGraphLessThanBlock",O);class s extends H.d{constructor(Z){super(A.c,A.c,A.f,((Z,h)=>this._polymorphicLessThanOrEqual(Z,h)),"FlowGraphLessThanOrEqualBlock",Z)}_polymorphicLessThanOrEqual(Z,h){return M(Z,h,((Z,h)=>Z<=h))}}(0,v.i)("FlowGraphLessThanOrEqualBlock",s);class J extends H.d{constructor(Z){super(A.c,A.c,A.f,((Z,h)=>this._polymorphicGreaterThan(Z,h)),"FlowGraphGreaterThanBlock",Z)}_polymorphicGreaterThan(Z,h){return M(Z,h,((Z,h)=>Z>h))}}(0,v.i)("FlowGraphGreaterThanBlock",J);class f extends H.d{constructor(Z){super(A.c,A.c,A.f,((Z,h)=>this._polymorphicGreaterThanOrEqual(Z,h)),"FlowGraphGreaterThanOrEqualBlock",Z)}_polymorphicGreaterThanOrEqual(Z,h){return M(Z,h,((Z,h)=>Z>=h))}}(0,v.i)("FlowGraphGreaterThanOrEqualBlock",f);class p extends n.e{constructor(Z){super(A.c,A.f,(Z=>this._polymorphicIsNan(Z)),"FlowGraphIsNaNBlock",Z)}_polymorphicIsNan(Z){if((0,k.u)(Z,!0))return isNaN((0,k.q)(Z));throw new Error(`Cannot get NaN of ${Z}`)}}(0,v.i)("FlowGraphIsNaNBlock",p);class Y extends n.e{constructor(Z){super(A.c,A.f,(Z=>this._polymorphicIsInf(Z)),"FlowGraphIsInfBlock",Z)}_polymorphicIsInf(Z){if((0,k.u)(Z))return!isFinite((0,k.q)(Z));throw new Error(`Cannot get isInf of ${Z}`)}}(0,v.i)("FlowGraphIsInfBlock",Y);class G extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicDegToRad(Z)),"FlowGraphDegToRadBlock",Z)}_degToRad(Z){return Z*Math.PI/180}_polymorphicDegToRad(Z){return C(Z,this._degToRad)}}(0,v.i)("FlowGraphDegToRadBlock",G);class ZZ extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicRadToDeg(Z)),"FlowGraphRadToDegBlock",Z)}_radToDeg(Z){return 180*Z/Math.PI}_polymorphicRadToDeg(Z){return C(Z,this._radToDeg)}}(0,v.i)("FlowGraphRadToDegBlock",ZZ);class hZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicSin(Z)),"FlowGraphSinBlock",Z)}_polymorphicSin(Z){return C(Z,Math.sin)}}class VZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicCos(Z)),"FlowGraphCosBlock",Z)}_polymorphicCos(Z){return C(Z,Math.cos)}}class vZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicTan(Z)),"FlowGraphTanBlock",Z)}_polymorphicTan(Z){return C(Z,Math.tan)}}class AZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicAsin(Z)),"FlowGraphASinBlock",Z)}_polymorphicAsin(Z){return C(Z,Math.asin)}}(0,v.i)("FlowGraphASinBlock",AZ);class HZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicAcos(Z)),"FlowGraphACosBlock",Z)}_polymorphicAcos(Z){return C(Z,Math.acos)}}(0,v.i)("FlowGraphACosBlock",HZ);class KZ extends n.e{constructor(Z){super(A.t,A.t,(Z=>this._polymorphicAtan(Z)),"FlowGraphATanBlock",Z)}_polymorphicAtan(Z){return C(Z,Math.atan)}}(0,v.i)("FlowGraphATanBlock",KZ);class dZ extends H.d{constructor(Z){super(A.c,A.c,A.c,((Z,h)=>this._polymorphicAtan2(Z,h)),"FlowGraphATan2Block",Z)}_polymorphicAtan2(Z,h){return m(Z,h,Math.atan2)}}(0,v.i)("FlowGraphATan2Block",dZ);class aZ extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicSinh(Z)),"FlowGraphSinhBlock",Z)}_polymorphicSinh(Z){return C(Z,Math.sinh)}}(0,v.i)("FlowGraphSinhBlock",aZ);class nZ extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicCosh(Z)),"FlowGraphCoshBlock",Z)}_polymorphicCosh(Z){return C(Z,Math.cosh)}}(0,v.i)("FlowGraphCoshBlock",nZ);class xZ extends n.e{constructor(Z){super(A.c,A.c,(Z=>this._polymorphicTanh(Z)),"FlowGraphTanhBlock",Z)}_polymorphicTanh(Z){return C(Z,Math.tanh)}}(0,v.i)("FlowGraphTanhBlock",xZ);class NZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicAsinh(Z)),"FlowGraphASinhBlock",Z)}_polymorphicAsinh(Z){return C(Z,Math.asinh)}}(0,v.i)("FlowGraphASinhBlock",NZ);class DZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicAcosh(Z)),"FlowGraphACoshBlock",Z)}_polymorphicAcosh(Z){return C(Z,Math.acosh)}}(0,v.i)("FlowGraphACoshBlock",DZ);class kZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicAtanh(Z)),"FlowGraphATanhBlock",Z)}_polymorphicAtanh(Z){return C(Z,Math.atanh)}}(0,v.i)("FlowGraphATanhBlock",kZ);class uZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicExp(Z)),"FlowGraphExponentialBlock",Z)}_polymorphicExp(Z){return C(Z,Math.exp)}}(0,v.i)("FlowGraphExponentialBlock",uZ);class FZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicLog(Z)),"FlowGraphLogBlock",Z)}_polymorphicLog(Z){return C(Z,Math.log)}}(0,v.i)("FlowGraphLogBlock",FZ);class bZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicLog2(Z)),"FlowGraphLog2Block",Z)}_polymorphicLog2(Z){return C(Z,Math.log2)}}(0,v.i)("FlowGraphLog2Block",bZ);class oZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicLog10(Z)),"FlowGraphLog10Block",Z)}_polymorphicLog10(Z){return C(Z,Math.log10)}}(0,v.i)("FlowGraphLog10Block",oZ);class qZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicSqrt(Z)),"FlowGraphSquareRootBlock",Z)}_polymorphicSqrt(Z){return C(Z,Math.sqrt)}}(0,v.i)("FlowGraphSquareRootBlock",qZ);class XZ extends n.e{constructor(Z){super(A.c,A.t,(Z=>this._polymorphicCubeRoot(Z)),"FlowGraphCubeRootBlock",Z)}_polymorphicCubeRoot(Z){return C(Z,Math.cbrt)}}(0,v.i)("FlowGraphCubeRootBlock",XZ);class EZ extends H.d{constructor(Z){super(A.c,A.t,A.t,((Z,h)=>this._polymorphicPow(Z,h)),"FlowGraphPowerBlock",Z)}_polymorphicPow(Z,h){return m(Z,h,Math.pow)}}(0,v.i)("FlowGraphPowerBlock",EZ);class jZ extends n.e{constructor(Z){super((0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(Z=>"boolean"===typeof Z?!Z:"number"===typeof Z?~Z:new N.b(~Z.value)),"FlowGraphBitwiseNotBlock",Z)}}(0,v.i)("FlowGraphBitwiseNotBlock",jZ);class PZ extends H.d{constructor(Z){super((0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,h)=>{if("boolean"===typeof Z&&"boolean"===typeof h)return Z&&h;if("number"===typeof Z&&"number"===typeof h)return Z&h;if("object"===typeof Z&&"object"===typeof h)return new N.b(Z.value&h.value);throw new Error(`Cannot perform bitwise AND on ${Z} and ${h}`)}),"FlowGraphBitwiseAndBlock",Z)}}(0,v.i)("FlowGraphBitwiseAndBlock",PZ);class CZ extends H.d{constructor(Z){super((0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,h)=>{if("boolean"===typeof Z&&"boolean"===typeof h)return Z||h;if("number"===typeof Z&&"number"===typeof h)return Z|h;if("object"===typeof Z&&"object"===typeof h)return new N.b(Z.value|h.value);throw new Error(`Cannot perform bitwise OR on ${Z} and ${h}`)}),"FlowGraphBitwiseOrBlock",Z)}}(0,v.i)("FlowGraphBitwiseOrBlock",CZ);class lZ extends H.d{constructor(Z){super((0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,A.S)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,h)=>{if("boolean"===typeof Z&&"boolean"===typeof h)return Z!==h;if("number"===typeof Z&&"number"===typeof h)return Z^h;if("object"===typeof Z&&"object"===typeof h)return new N.b(Z.value^h.value);throw new Error(`Cannot perform bitwise XOR on ${Z} and ${h}`)}),"FlowGraphBitwiseXorBlock",Z)}}(0,v.i)("FlowGraphBitwiseXorBlock",lZ);class BZ extends H.d{constructor(Z){super(A.h,A.h,A.h,((Z,h)=>new N.b(Z.value<<h.value)),"FlowGraphBitwiseLeftShiftBlock",Z)}}(0,v.i)("FlowGraphBitwiseLeftShiftBlock",BZ);class SZ extends H.d{constructor(Z){super(A.h,A.h,A.h,((Z,h)=>new N.b(Z.value>>h.value)),"FlowGraphBitwiseRightShiftBlock",Z)}}(0,v.i)("FlowGraphBitwiseRightShiftBlock",SZ);class rZ extends n.e{constructor(Z){super(A.h,A.h,(Z=>new N.b(Math.clz32(Z.value))),"FlowGraphLeadingZerosBlock",Z)}}(0,v.i)("FlowGraphLeadingZerosBlock",rZ);class LZ extends n.e{constructor(Z){super(A.h,A.h,(Z=>new N.b(Z.value?31-Math.clz32(Z.value&-Z.value):32)),"FlowGraphTrailingZerosBlock",Z)}}(0,v.i)("FlowGraphTrailingZerosBlock",LZ);class yZ extends n.e{constructor(Z){super(A.h,A.h,(Z=>new N.b(function(Z){let h=0;for(;Z;)h+=1&Z,Z>>=1;return h}(Z.value))),"FlowGraphOneBitsCounterBlock",Z)}}(0,v.i)("FlowGraphOneBitsCounterBlock",yZ)},15012:(Z,h,V)=>{V.d(h,{d:()=>A});var v=V(15015);class A extends v.c{constructor(Z,h,V,v,A,H){super(V,H),this._operation=v,this._className=A,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",h)}_doOperation(Z){const h=this.a.getValue(Z),V=this.b.getValue(Z);return this._operation(h,V)}getClassName(){return this._className}}},15015:(Z,h,V)=>{V.d(h,{c:()=>d});var v=V(13480),A=V(13459);const H="cachedOperationValue",K="cachedExecutionId";class d extends v.d{constructor(Z,h){super(h),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",A.f)}_updateOutputs(Z){const h=Z._getExecutionVariable(this,K,-1),V=Z._getExecutionVariable(this,H,null);if(void 0!==V&&null!==V&&h===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(V,Z);else try{const h=this._doOperation(Z);if(void 0===h||null===h)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,H,h),Z._setExecutionVariable(this,K,Z.executionId),this.value.setValue(h,Z),this.isValid.setValue(!0,Z)}catch(v){this.isValid.setValue(!1,Z)}}}},15024:(Z,h,V)=>{V.d(h,{e:()=>A});var v=V(15015);class A extends v.c{constructor(Z,h,V,v,A){super(h,A),this._operation=V,this._className=v,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);