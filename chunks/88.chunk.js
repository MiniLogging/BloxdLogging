"use strict";(self.isj1uwvwrek=self.isj1uwvwrek||[]).push([[88],{16068:(I,x,L)=>{L.r(x),L.d(x,{FlowGraphAbsBlock:()=>f,FlowGraphAcosBlock:()=>GI,FlowGraphAcoshBlock:()=>eI,FlowGraphAddBlock:()=>v,FlowGraphAsinBlock:()=>XI,FlowGraphAsinhBlock:()=>QI,FlowGraphAtan2Block:()=>pI,FlowGraphAtanBlock:()=>YI,FlowGraphAtanhBlock:()=>gI,FlowGraphBitwiseAndBlock:()=>ZI,FlowGraphBitwiseLeftShiftBlock:()=>RI,FlowGraphBitwiseNotBlock:()=>TI,FlowGraphBitwiseOrBlock:()=>tI,FlowGraphBitwiseRightShiftBlock:()=>nI,FlowGraphBitwiseXorBlock:()=>fI,FlowGraphCeilBlock:()=>d,FlowGraphClampBlock:()=>D,FlowGraphCosBlock:()=>LI,FlowGraphCoshBlock:()=>lI,FlowGraphCubeRootBlock:()=>qI,FlowGraphDegToRadBlock:()=>b,FlowGraphDivideBlock:()=>s,FlowGraphEBlock:()=>q,FlowGraphEqualityBlock:()=>o,FlowGraphExpBlock:()=>vI,FlowGraphFloorBlock:()=>P,FlowGraphFractionBlock:()=>K,FlowGraphGreaterThanBlock:()=>i,FlowGraphGreaterThanOrEqualBlock:()=>V,FlowGraphInfBlock:()=>T,FlowGraphIsInfinityBlock:()=>C,FlowGraphIsNanBlock:()=>j,FlowGraphLeadingZerosBlock:()=>PI,FlowGraphLessThanBlock:()=>h,FlowGraphLessThanOrEqualBlock:()=>E,FlowGraphLog10Block:()=>sI,FlowGraphLog2Block:()=>HI,FlowGraphLogBlock:()=>zI,FlowGraphMathInterpolationBlock:()=>c,FlowGraphMaxBlock:()=>w,FlowGraphMinBlock:()=>O,FlowGraphModuloBlock:()=>mI,FlowGraphMultiplyBlock:()=>H,FlowGraphNaNBlock:()=>Z,FlowGraphNegationBlock:()=>u,FlowGraphOneBitsCounterBlock:()=>MI,FlowGraphPiBlock:()=>y,FlowGraphPowerBlock:()=>yI,FlowGraphRadToDegBlock:()=>II,FlowGraphRandomBlock:()=>U,FlowGraphRoundBlock:()=>M,FlowGraphSaturateBlock:()=>N,FlowGraphSignBlock:()=>R,FlowGraphSinBlock:()=>xI,FlowGraphSinhBlock:()=>BI,FlowGraphSquareRootBlock:()=>UI,FlowGraphSubtractBlock:()=>z,FlowGraphTanBlock:()=>FI,FlowGraphTanhBlock:()=>WI,FlowGraphTrailingZerosBlock:()=>dI,FlowGraphTruncBlock:()=>n});var F=L(12938),X=L(14498),G=L(16075),Y=L(16077);class p extends Y.c{constructor(I,x,L,F){super(I,F),this._operation=x,this._className=L}_doOperation(I){return this._operation(I)}getClassName(){return this._className}}var B=L(12983),l=L(16084);class W extends Y.c{constructor(I,x,L,F,X,G,Y){super(F,Y),this._operation=X,this._className=G,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",x),this.c=this.registerDataInput("c",L)}_doOperation(I){return this._operation(this.a.getValue(I),this.b.getValue(I),this.c.getValue(I))}getClassName(){return this._className}}var Q=L(14493),e=L(14501),g=L(14522);class v extends G.c{constructor(I){super((0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),((I,x)=>this._polymorphicAdd(I,x)),"FlowGraphAddBlock",I)}_polymorphicAdd(I,x){const L=(0,g.m)(I),F=(0,g.m)(x);if((0,g.j)(L,F)||(0,g.f)(L,F)||(0,g.c)(L,F))return I.add(x);if("Quaternion"===L||"Vector4"===F)return new B.Vector4(I.x,I.y,I.z,I.w).addInPlace(x);if("Vector4"===L||"Quaternion"===F)return I.add(x);var X;if(null!==(X=this.config)&&void 0!==X&&X.preventIntegerFloatArithmetic&&typeof I!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,g.r)(I)+(0,g.r)(x)}}(0,F.d)("FlowGraphAddBlock",v);class z extends G.c{constructor(I){super((0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),((I,x)=>this._polymorphicSubtract(I,x)),"FlowGraphSubtractBlock",I)}_polymorphicSubtract(I,x){const L=(0,g.m)(I),F=(0,g.m)(x);if((0,g.j)(L,F)||(0,g.c)(L,F)||(0,g.f)(L,F))return I.Ux(x);if("Quaternion"===L||"Vector4"===F)return new B.Vector4(I.x,I.y,I.z,I.w).aQ(x);if("Vector4"===L||"Quaternion"===F)return I.Ux(x);var X;if(null!==(X=this.config)&&void 0!==X&&X.preventIntegerFloatArithmetic&&typeof I!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,g.r)(I)-(0,g.r)(x)}}(0,F.d)("FlowGraphSubtractBlock",z);class H extends G.c{constructor(I){super((0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),((I,x)=>this._polymorphicMultiply(I,x)),"FlowGraphMultiplyBlock",I)}_polymorphicMultiply(I,x){const L=(0,g.m)(I),F=(0,g.m)(x);if((0,g.j)(L,F)||(0,g.c)(L,F))return I.multiply(x);if("Quaternion"===L||"Vector4"===F)return new B.Vector4(I.x,I.y,I.z,I.w).multiplyInPlace(x);if("Vector4"===L||"Quaternion"===F)return I.multiply(x);if((0,g.f)(L,F)){var X;if(null!==(X=this.config)&&void 0!==X&&X.useMatrixPerComponent){const F=I.m;for(let I=0;I<F.length;I++)F[I]*=x.m[I];return"Matrix2D"===L?new e.c(F):"Matrix3D"===L?new e.f(F):B.Matrix.tx(F)}return x.multiply(I)}var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof I!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,g.r)(I)*(0,g.r)(x)}}(0,F.d)("FlowGraphMultiplyBlock",H);class s extends G.c{constructor(I){super((0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),(0,X.S)(null===I||void 0===I?void 0:I.type),((I,x)=>this._polymorphicDivide(I,x)),"FlowGraphDivideBlock",I)}_polymorphicDivide(I,x){const L=(0,g.m)(I),F=(0,g.m)(x);if((0,g.j)(L,F)||(0,g.c)(L,F))return I.divide(x);if("Quaternion"===L||"Quaternion"===F){const L=I.clone();return L.x/=x.x,L.y/=x.y,L.z/=x.z,L.w/=x.w,L}if("Quaternion"===L||"Vector4"===F)return new B.Vector4(I.x,I.y,I.z,I.w).divideInPlace(x);if("Vector4"===L||"Quaternion"===F)return I.divide(x);if((0,g.f)(L,F)){var X;if(null!==(X=this.config)&&void 0!==X&&X.useMatrixPerComponent){const F=I.m;for(let I=0;I<F.length;I++)F[I]/=x.m[I];return"Matrix2D"===L?new e.c(F):"Matrix3D"===L?new e.f(F):B.Matrix.tx(F)}return I.divide(x)}var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof I!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,g.r)(I)/(0,g.r)(x)}}(0,F.d)("FlowGraphDivideBlock",s);class U extends p{constructor(I){super(X.x,(I=>this._random(I)),"FlowGraphRandomBlock",I),this.min=this.registerDataInput("min",X.x,(null===I||void 0===I?void 0:I.min)??0),this.max=this.registerDataInput("max",X.x,(null===I||void 0===I?void 0:I.max)??1),null!==I&&void 0!==I&&I.seed&&(this._seed=I.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const I=1e4*Math.sin(this._seed++);return I-Math.floor(I)}return Math.random()}_random(I){const x=this.min.getValue(I),L=this.max.getValue(I);return this._getRandomValue()*(L-x)+x}}(0,F.d)("FlowGraphRandomBlock",U);class q extends p{constructor(I){super(X.x,(()=>Math.E),"FlowGraphEBlock",I)}}(0,F.d)("FlowGraphEBlock",q);class y extends p{constructor(I){super(X.x,(()=>Math.PI),"FlowGraphPIBlock",I)}}(0,F.d)("FlowGraphPIBlock",y);class T extends p{constructor(I){super(X.x,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",I)}}(0,F.d)("FlowGraphInfBlock",T);class Z extends p{constructor(I){super(X.x,(()=>Number.NaN),"FlowGraphNaNBlock",I)}}function t(I,x){switch((0,g.m)(I)){case"FlowGraphInteger":return new Q.b(x(I.value));case"Vector2":return new B.Vector2(x(I.x),x(I.y));case"sx":return new B.sx(x(I.x),x(I.y),x(I.z));case"Vector4":return new B.Vector4(x(I.x),x(I.y),x(I.z),x(I.w));case"Quaternion":return new B.Quaternion(x(I.x),x(I.y),x(I.z),x(I.w));case"Matrix":return B.Matrix.tx(I.m.map(x));case"Matrix2D":return new e.c(I.m.map(x));case"Matrix3D":return new e.f(I.m.map(x));default:return x(I)}}(0,F.d)("FlowGraphNaNBlock",Z);class f extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicAbs(I)),"FlowGraphAbsBlock",I)}_polymorphicAbs(I){return t(I,Math.abs)}}(0,F.d)("FlowGraphAbsBlock",f);class R extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicSign(I)),"FlowGraphSignBlock",I)}_polymorphicSign(I){return t(I,Math.sign)}}(0,F.d)("FlowGraphSignBlock",R);class n extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicTrunc(I)),"FlowGraphTruncBlock",I)}_polymorphicTrunc(I){return t(I,Math.trunc)}}(0,F.d)("FlowGraphTruncBlock",n);class P extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicFloor(I)),"FlowGraphFloorBlock",I)}_polymorphicFloor(I){return t(I,Math.floor)}}(0,F.d)("FlowGraphFloorBlock",P);class d extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicCeiling(I)),"FlowGraphCeilBlock",I)}_polymorphicCeiling(I){return t(I,Math.ceil)}}(0,F.d)("FlowGraphCeilBlock",d);class M extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicRound(I)),"FlowGraphRoundBlock",I)}_polymorphicRound(I){return t(I,(I=>{var x;return I<0&&null!==(x=this.config)&&void 0!==x&&x.roundHalfAwayFromZero?-Math.round(-I):Math.round(I)}))}}(0,F.d)("FlowGraphRoundBlock",M);class K extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicFraction(I)),"FlowGraphFractBlock",I)}_polymorphicFraction(I){return t(I,(I=>I-Math.floor(I)))}}(0,F.d)("FlowGraphFractBlock",K);class u extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicNeg(I)),"FlowGraphNegationBlock",I)}_polymorphicNeg(I){return t(I,(I=>-I))}}function A(I,x,L){switch((0,g.m)(I)){case"FlowGraphInteger":return new Q.b(L(I.value,x.value));case"Vector2":return new B.Vector2(L(I.x,x.x),L(I.y,x.y));case"sx":return new B.sx(L(I.x,x.x),L(I.y,x.y),L(I.z,x.z));case"Vector4":return new B.Vector4(L(I.x,x.x),L(I.y,x.y),L(I.z,x.z),L(I.w,x.w));case"Quaternion":return new B.Quaternion(L(I.x,x.x),L(I.y,x.y),L(I.z,x.z),L(I.w,x.w));case"Matrix":return B.Matrix.tx(I.m.map(((I,F)=>L(I,x.m[F]))));case"Matrix2D":return new e.c(I.m.map(((I,F)=>L(I,x.m[F]))));case"Matrix3D":return new e.f(I.m.map(((I,F)=>L(I,x.m[F]))));default:return L((0,g.r)(I),(0,g.r)(x))}}(0,F.d)("FlowGraphNegationBlock",u);class mI extends G.c{constructor(I){super(X.e,X.e,X.e,((I,x)=>this._polymorphicRemainder(I,x)),"FlowGraphModuloBlock",I)}_polymorphicRemainder(I,x){return A(I,x,((I,x)=>I%x))}}(0,F.d)("FlowGraphModuloBlock",mI);class O extends G.c{constructor(I){super(X.e,X.e,X.e,((I,x)=>this._polymorphicMin(I,x)),"FlowGraphMinBlock",I)}_polymorphicMin(I,x){return A(I,x,Math.min)}}(0,F.d)("FlowGraphMinBlock",O);class w extends G.c{constructor(I){super(X.e,X.e,X.e,((I,x)=>this._polymorphicMax(I,x)),"FlowGraphMaxBlock",I)}_polymorphicMax(I,x){return A(I,x,Math.max)}}function k(I,x,L){return Math.min(Math.max(I,Math.min(x,L)),Math.max(x,L))}function a(I,x,L,F){switch((0,g.m)(I)){case"FlowGraphInteger":return new Q.b(F(I.value,x.value,L.value));case"Vector2":return new B.Vector2(F(I.x,x.x,L.x),F(I.y,x.y,L.y));case"sx":return new B.sx(F(I.x,x.x,L.x),F(I.y,x.y,L.y),F(I.z,x.z,L.z));case"Vector4":return new B.Vector4(F(I.x,x.x,L.x),F(I.y,x.y,L.y),F(I.z,x.z,L.z),F(I.w,x.w,L.w));case"Quaternion":return new B.Quaternion(F(I.x,x.x,L.x),F(I.y,x.y,L.y),F(I.z,x.z,L.z),F(I.w,x.w,L.w));case"Matrix":return B.Matrix.tx(I.m.map(((I,X)=>F(I,x.m[X],L.m[X]))));case"Matrix2D":return new e.c(I.m.map(((I,X)=>F(I,x.m[X],L.m[X]))));case"Matrix3D":return new e.f(I.m.map(((I,X)=>F(I,x.m[X],L.m[X]))));default:return F((0,g.r)(I),(0,g.r)(x),(0,g.r)(L))}}(0,F.d)("FlowGraphMaxBlock",w);class D extends W{constructor(I){super(X.e,X.e,X.e,X.e,((I,x,L)=>this._polymorphicClamp(I,x,L)),"FlowGraphClampBlock",I)}_polymorphicClamp(I,x,L){return a(I,x,L,k)}}function r(I){return Math.min(Math.max(I,0),1)}(0,F.d)("FlowGraphClampBlock",D);class N extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicSaturate(I)),"FlowGraphSaturateBlock",I)}_polymorphicSaturate(I){return t(I,r)}}function S(I,x,L){return(1-L)*I+L*x}(0,F.d)("FlowGraphSaturateBlock",N);class c extends W{constructor(I){super(X.e,X.e,X.e,X.e,((I,x,L)=>this._polymorphicInterpolate(I,x,L)),"FlowGraphMathInterpolationBlock",I)}_polymorphicInterpolate(I,x,L){return a(I,x,L,S)}}(0,F.d)("FlowGraphMathInterpolationBlock",c);class o extends G.c{constructor(I){super(X.e,X.e,X.i,((I,x)=>this._polymorphicEq(I,x)),"FlowGraphEqualityBlock",I)}_polymorphicEq(I,x){const L=(0,g.m)(I),F=(0,g.m)(x);return typeof I===typeof x&&((0,g.j)(L,F)||(0,g.f)(L,F)||(0,g.c)(L,F)?I.equals(x):I===x)}}function J(I,x,L){if((0,g.u)(I)&&(0,g.u)(x))return L((0,g.r)(I),(0,g.r)(x));throw new Error(`Cannot compare ${I} and ${x}`)}(0,F.d)("FlowGraphEqualityBlock",o);class h extends G.c{constructor(I){super(X.e,X.e,X.i,((I,x)=>this._polymorphicLessThan(I,x)),"FlowGraphLessThanBlock",I)}_polymorphicLessThan(I,x){return J(I,x,((I,x)=>I<x))}}(0,F.d)("FlowGraphLessThanBlock",h);class E extends G.c{constructor(I){super(X.e,X.e,X.i,((I,x)=>this._polymorphicLessThanOrEqual(I,x)),"FlowGraphLessThanOrEqualBlock",I)}_polymorphicLessThanOrEqual(I,x){return J(I,x,((I,x)=>I<=x))}}(0,F.d)("FlowGraphLessThanOrEqualBlock",E);class i extends G.c{constructor(I){super(X.e,X.e,X.i,((I,x)=>this._polymorphicGreaterThan(I,x)),"FlowGraphGreaterThanBlock",I)}_polymorphicGreaterThan(I,x){return J(I,x,((I,x)=>I>x))}}(0,F.d)("FlowGraphGreaterThanBlock",i);class V extends G.c{constructor(I){super(X.e,X.e,X.i,((I,x)=>this._polymorphicGreaterThanOrEqual(I,x)),"FlowGraphGreaterThanOrEqualBlock",I)}_polymorphicGreaterThanOrEqual(I,x){return J(I,x,((I,x)=>I>=x))}}(0,F.d)("FlowGraphGreaterThanOrEqualBlock",V);class j extends l.c{constructor(I){super(X.e,X.i,(I=>this._polymorphicIsNan(I)),"FlowGraphIsNaNBlock",I)}_polymorphicIsNan(I){if((0,g.u)(I,!0))return isNaN((0,g.r)(I));throw new Error(`Cannot get NaN of ${I}`)}}(0,F.d)("FlowGraphIsNaNBlock",j);class C extends l.c{constructor(I){super(X.e,X.i,(I=>this._polymorphicIsInf(I)),"FlowGraphIsInfBlock",I)}_polymorphicIsInf(I){if((0,g.u)(I))return!isFinite((0,g.r)(I));throw new Error(`Cannot get isInf of ${I}`)}}(0,F.d)("FlowGraphIsInfBlock",C);class b extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicDegToRad(I)),"FlowGraphDegToRadBlock",I)}_degToRad(I){return I*Math.PI/180}_polymorphicDegToRad(I){return t(I,this._degToRad)}}(0,F.d)("FlowGraphDegToRadBlock",b);class II extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicRadToDeg(I)),"FlowGraphRadToDegBlock",I)}_radToDeg(I){return 180*I/Math.PI}_polymorphicRadToDeg(I){return t(I,this._radToDeg)}}(0,F.d)("FlowGraphRadToDegBlock",II);class xI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicSin(I)),"FlowGraphSinBlock",I)}_polymorphicSin(I){return t(I,Math.sin)}}class LI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicCos(I)),"FlowGraphCosBlock",I)}_polymorphicCos(I){return t(I,Math.cos)}}class FI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicTan(I)),"FlowGraphTanBlock",I)}_polymorphicTan(I){return t(I,Math.tan)}}class XI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicAsin(I)),"FlowGraphASinBlock",I)}_polymorphicAsin(I){return t(I,Math.asin)}}(0,F.d)("FlowGraphASinBlock",XI);class GI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicAcos(I)),"FlowGraphACosBlock",I)}_polymorphicAcos(I){return t(I,Math.acos)}}(0,F.d)("FlowGraphACosBlock",GI);class YI extends l.c{constructor(I){super(X.x,X.x,(I=>this._polymorphicAtan(I)),"FlowGraphATanBlock",I)}_polymorphicAtan(I){return t(I,Math.atan)}}(0,F.d)("FlowGraphATanBlock",YI);class pI extends G.c{constructor(I){super(X.e,X.e,X.e,((I,x)=>this._polymorphicAtan2(I,x)),"FlowGraphATan2Block",I)}_polymorphicAtan2(I,x){return A(I,x,Math.atan2)}}(0,F.d)("FlowGraphATan2Block",pI);class BI extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicSinh(I)),"FlowGraphSinhBlock",I)}_polymorphicSinh(I){return t(I,Math.sinh)}}(0,F.d)("FlowGraphSinhBlock",BI);class lI extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicCosh(I)),"FlowGraphCoshBlock",I)}_polymorphicCosh(I){return t(I,Math.cosh)}}(0,F.d)("FlowGraphCoshBlock",lI);class WI extends l.c{constructor(I){super(X.e,X.e,(I=>this._polymorphicTanh(I)),"FlowGraphTanhBlock",I)}_polymorphicTanh(I){return t(I,Math.tanh)}}(0,F.d)("FlowGraphTanhBlock",WI);class QI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicAsinh(I)),"FlowGraphASinhBlock",I)}_polymorphicAsinh(I){return t(I,Math.asinh)}}(0,F.d)("FlowGraphASinhBlock",QI);class eI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicAcosh(I)),"FlowGraphACoshBlock",I)}_polymorphicAcosh(I){return t(I,Math.acosh)}}(0,F.d)("FlowGraphACoshBlock",eI);class gI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicAtanh(I)),"FlowGraphATanhBlock",I)}_polymorphicAtanh(I){return t(I,Math.atanh)}}(0,F.d)("FlowGraphATanhBlock",gI);class vI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicExp(I)),"FlowGraphExponentialBlock",I)}_polymorphicExp(I){return t(I,Math.exp)}}(0,F.d)("FlowGraphExponentialBlock",vI);class zI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicLog(I)),"FlowGraphLogBlock",I)}_polymorphicLog(I){return t(I,Math.log)}}(0,F.d)("FlowGraphLogBlock",zI);class HI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicLog2(I)),"FlowGraphLog2Block",I)}_polymorphicLog2(I){return t(I,Math.log2)}}(0,F.d)("FlowGraphLog2Block",HI);class sI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicLog10(I)),"FlowGraphLog10Block",I)}_polymorphicLog10(I){return t(I,Math.log10)}}(0,F.d)("FlowGraphLog10Block",sI);class UI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicSqrt(I)),"FlowGraphSquareRootBlock",I)}_polymorphicSqrt(I){return t(I,Math.sqrt)}}(0,F.d)("FlowGraphSquareRootBlock",UI);class qI extends l.c{constructor(I){super(X.e,X.x,(I=>this._polymorphicCubeRoot(I)),"FlowGraphCubeRootBlock",I)}_polymorphicCubeRoot(I){return t(I,Math.cbrt)}}(0,F.d)("FlowGraphCubeRootBlock",qI);class yI extends G.c{constructor(I){super(X.e,X.x,X.x,((I,x)=>this._polymorphicPow(I,x)),"FlowGraphPowerBlock",I)}_polymorphicPow(I,x){return A(I,x,Math.pow)}}(0,F.d)("FlowGraphPowerBlock",yI);class TI extends l.c{constructor(I){super((0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(I=>"boolean"===typeof I?!I:"number"===typeof I?~I:new Q.b(~I.value)),"FlowGraphBitwiseNotBlock",I)}}(0,F.d)("FlowGraphBitwiseNotBlock",TI);class ZI extends G.c{constructor(I){super((0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),((I,x)=>{if("boolean"===typeof I&&"boolean"===typeof x)return I&&x;if("number"===typeof I&&"number"===typeof x)return I&x;if("object"===typeof I&&"object"===typeof x)return new Q.b(I.value&x.value);throw new Error(`Cannot perform bitwise AND on ${I} and ${x}`)}),"FlowGraphBitwiseAndBlock",I)}}(0,F.d)("FlowGraphBitwiseAndBlock",ZI);class tI extends G.c{constructor(I){super((0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),((I,x)=>{if("boolean"===typeof I&&"boolean"===typeof x)return I||x;if("number"===typeof I&&"number"===typeof x)return I|x;if("object"===typeof I&&"object"===typeof x)return new Q.b(I.value|x.value);throw new Error(`Cannot perform bitwise OR on ${I} and ${x}`)}),"FlowGraphBitwiseOrBlock",I)}}(0,F.d)("FlowGraphBitwiseOrBlock",tI);class fI extends G.c{constructor(I){super((0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),(0,X.S)((null===I||void 0===I?void 0:I.valueType)||"FlowGraphInteger"),((I,x)=>{if("boolean"===typeof I&&"boolean"===typeof x)return I!==x;if("number"===typeof I&&"number"===typeof x)return I^x;if("object"===typeof I&&"object"===typeof x)return new Q.b(I.value^x.value);throw new Error(`Cannot perform bitwise XOR on ${I} and ${x}`)}),"FlowGraphBitwiseXorBlock",I)}}(0,F.d)("FlowGraphBitwiseXorBlock",fI);class RI extends G.c{constructor(I){super(X.l,X.l,X.l,((I,x)=>new Q.b(I.value<<x.value)),"FlowGraphBitwiseLeftShiftBlock",I)}}(0,F.d)("FlowGraphBitwiseLeftShiftBlock",RI);class nI extends G.c{constructor(I){super(X.l,X.l,X.l,((I,x)=>new Q.b(I.value>>x.value)),"FlowGraphBitwiseRightShiftBlock",I)}}(0,F.d)("FlowGraphBitwiseRightShiftBlock",nI);class PI extends l.c{constructor(I){super(X.l,X.l,(I=>new Q.b(Math.clz32(I.value))),"FlowGraphLeadingZerosBlock",I)}}(0,F.d)("FlowGraphLeadingZerosBlock",PI);class dI extends l.c{constructor(I){super(X.l,X.l,(I=>new Q.b(I.value?31-Math.clz32(I.value&-I.value):32)),"FlowGraphTrailingZerosBlock",I)}}(0,F.d)("FlowGraphTrailingZerosBlock",dI);class MI extends l.c{constructor(I){super(X.l,X.l,(I=>new Q.b(function(I){let x=0;for(;I;)x+=1&I,I>>=1;return x}(I.value))),"FlowGraphOneBitsCounterBlock",I)}}(0,F.d)("FlowGraphOneBitsCounterBlock",MI)},16075:(I,x,L)=>{L.d(x,{c:()=>X});var F=L(16077);class X extends F.c{constructor(I,x,L,F,X,G){super(L,G),this._operation=F,this._className=X,this.a=this.registerDataInput("a",I),this.b=this.registerDataInput("b",x)}_doOperation(I){const x=this.a.getValue(I),L=this.b.getValue(I);return this._operation(x,L)}getClassName(){return this._className}}},16077:(I,x,L)=>{L.d(x,{c:()=>p});var F=L(14514),X=L(14498);const G="cachedOperationValue",Y="cachedExecutionId";class p extends F.e{constructor(I,x){super(x),this.value=this.registerDataOutput("value",I),this.isValid=this.registerDataOutput("isValid",X.i)}_updateOutputs(I){const x=I._getExecutionVariable(this,Y,-1),L=I._getExecutionVariable(this,G,null);if(void 0!==L&&null!==L&&x===I.executionId)this.isValid.setValue(!0,I),this.value.setValue(L,I);else try{const x=this._doOperation(I);if(void 0===x||null===x)return void this.isValid.setValue(!1,I);I._setExecutionVariable(this,G,x),I._setExecutionVariable(this,Y,I.executionId),this.value.setValue(x,I),this.isValid.setValue(!0,I)}catch(F){this.isValid.setValue(!1,I)}}}},16084:(I,x,L)=>{L.d(x,{c:()=>X});var F=L(16077);class X extends F.c{constructor(I,x,L,F,X){super(x,X),this._operation=L,this._className=F,this.a=this.registerDataInput("a",I)}_doOperation(I){return this._operation(this.a.getValue(I))}getClassName(){return this._className}}}}]);