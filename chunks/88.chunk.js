"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{14402:(B,I,C)=>{C.r(I),C.d(I,{FlowGraphAbsBlock:()=>A,FlowGraphAcosBlock:()=>yB,FlowGraphAcoshBlock:()=>HB,FlowGraphAddBlock:()=>k,FlowGraphAsinBlock:()=>xB,FlowGraphAsinhBlock:()=>RB,FlowGraphAtan2Block:()=>LB,FlowGraphAtanBlock:()=>fB,FlowGraphAtanhBlock:()=>FB,FlowGraphBitwiseAndBlock:()=>tB,FlowGraphBitwiseLeftShiftBlock:()=>DB,FlowGraphBitwiseNotBlock:()=>cB,FlowGraphBitwiseOrBlock:()=>rB,FlowGraphBitwiseRightShiftBlock:()=>JB,FlowGraphBitwiseXorBlock:()=>AB,FlowGraphCeilBlock:()=>u,FlowGraphClampBlock:()=>Z,FlowGraphCosBlock:()=>CB,FlowGraphCoshBlock:()=>gB,FlowGraphCubeRootBlock:()=>GB,FlowGraphDegToRadBlock:()=>m,FlowGraphDivideBlock:()=>o,FlowGraphEBlock:()=>G,FlowGraphEqualityBlock:()=>s,FlowGraphExpBlock:()=>kB,FlowGraphFloorBlock:()=>i,FlowGraphFractionBlock:()=>n,FlowGraphGreaterThanBlock:()=>h,FlowGraphGreaterThanOrEqualBlock:()=>j,FlowGraphInfBlock:()=>c,FlowGraphIsInfinityBlock:()=>K,FlowGraphIsNanBlock:()=>w,FlowGraphLeadingZerosBlock:()=>iB,FlowGraphLessThanBlock:()=>T,FlowGraphLessThanOrEqualBlock:()=>P,FlowGraphLog10Block:()=>oB,FlowGraphLog2Block:()=>SB,FlowGraphLogBlock:()=>qB,FlowGraphMathInterpolationBlock:()=>v,FlowGraphMaxBlock:()=>l,FlowGraphMinBlock:()=>d,FlowGraphModuloBlock:()=>W,FlowGraphMultiplyBlock:()=>S,FlowGraphNaNBlock:()=>t,FlowGraphNegationBlock:()=>O,FlowGraphOneBitsCounterBlock:()=>pB,FlowGraphPiBlock:()=>V,FlowGraphPowerBlock:()=>VB,FlowGraphRadToDegBlock:()=>BB,FlowGraphRandomBlock:()=>U,FlowGraphRoundBlock:()=>p,FlowGraphSaturateBlock:()=>b,FlowGraphSignBlock:()=>D,FlowGraphSinBlock:()=>IB,FlowGraphSinhBlock:()=>eB,FlowGraphSquareRootBlock:()=>UB,FlowGraphSubtractBlock:()=>q,FlowGraphTanBlock:()=>MB,FlowGraphTanhBlock:()=>NB,FlowGraphTrailingZerosBlock:()=>uB,FlowGraphTruncBlock:()=>J});var M=C(11149),x=C(12901),y=C(14404),f=C(14408);class L extends f.b{constructor(B,I,C,M){super(B,M),this._operation=I,this._className=C}_doOperation(B){return this._operation(B)}getClassName(){return this._className}}var e=C(11194),g=C(14415);class N extends f.b{constructor(B,I,C,M,x,y,f){super(M,f),this._operation=x,this._className=y,this.a=this.registerDataInput("a",B),this.b=this.registerDataInput("b",I),this.c=this.registerDataInput("c",C)}_doOperation(B){return this._operation(this.a.getValue(B),this.b.getValue(B),this.c.getValue(B))}getClassName(){return this._className}}var R=C(12895),H=C(12908),F=C(12939);class k extends y.d{constructor(B){super((0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),((B,I)=>this._polymorphicAdd(B,I)),"FlowGraphAddBlock",B)}_polymorphicAdd(B,I){const C=(0,F.n)(B),M=(0,F.n)(I);if((0,F.l)(C,M)||(0,F.h)(C,M)||(0,F.e)(C,M))return B.add(I);if("Quaternion"===C||"Vector4"===M)return new e.Vector4(B.x,B.y,B.z,B.w).addInPlace(I);if("Vector4"===C||"Quaternion"===M)return B.add(I);var x;if(null!==(x=this.config)&&void 0!==x&&x.preventIntegerFloatArithmetic&&typeof B!==typeof I)throw new Error("Cannot add different types of numbers.");return(0,F.s)(B)+(0,F.s)(I)}}(0,M.h)("FlowGraphAddBlock",k);class q extends y.d{constructor(B){super((0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),((B,I)=>this._polymorphicSubtract(B,I)),"FlowGraphSubtractBlock",B)}_polymorphicSubtract(B,I){const C=(0,F.n)(B),M=(0,F.n)(I);if((0,F.l)(C,M)||(0,F.e)(C,M)||(0,F.h)(C,M))return B.FI(I);if("Quaternion"===C||"Vector4"===M)return new e.Vector4(B.x,B.y,B.z,B.w).cR(I);if("Vector4"===C||"Quaternion"===M)return B.FI(I);var x;if(null!==(x=this.config)&&void 0!==x&&x.preventIntegerFloatArithmetic&&typeof B!==typeof I)throw new Error("Cannot add different types of numbers.");return(0,F.s)(B)-(0,F.s)(I)}}(0,M.h)("FlowGraphSubtractBlock",q);class S extends y.d{constructor(B){super((0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),((B,I)=>this._polymorphicMultiply(B,I)),"FlowGraphMultiplyBlock",B)}_polymorphicMultiply(B,I){const C=(0,F.n)(B),M=(0,F.n)(I);if((0,F.l)(C,M)||(0,F.e)(C,M))return B.multiply(I);if("Quaternion"===C||"Vector4"===M)return new e.Vector4(B.x,B.y,B.z,B.w).multiplyInPlace(I);if("Vector4"===C||"Quaternion"===M)return B.multiply(I);if((0,F.h)(C,M)){var x;if(null!==(x=this.config)&&void 0!==x&&x.useMatrixPerComponent){const M=B.m;for(let B=0;B<M.length;B++)M[B]*=I.m[B];return"Matrix2D"===C?new H.c(M):"Matrix3D"===C?new H.e(M):e.Matrix.oI(M)}return I.multiply(B)}var y;if(null!==(y=this.config)&&void 0!==y&&y.preventIntegerFloatArithmetic&&typeof B!==typeof I)throw new Error("Cannot add different types of numbers.");return(0,F.s)(B)*(0,F.s)(I)}}(0,M.h)("FlowGraphMultiplyBlock",S);class o extends y.d{constructor(B){super((0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),(0,x.H)(null===B||void 0===B?void 0:B.type),((B,I)=>this._polymorphicDivide(B,I)),"FlowGraphDivideBlock",B)}_polymorphicDivide(B,I){const C=(0,F.n)(B),M=(0,F.n)(I);if((0,F.l)(C,M)||(0,F.e)(C,M))return B.divide(I);if("Quaternion"===C||"Quaternion"===M){const C=B.clone();return C.x/=I.x,C.y/=I.y,C.z/=I.z,C.w/=I.w,C}if("Quaternion"===C||"Vector4"===M)return new e.Vector4(B.x,B.y,B.z,B.w).divideInPlace(I);if("Vector4"===C||"Quaternion"===M)return B.divide(I);if((0,F.h)(C,M)){var x;if(null!==(x=this.config)&&void 0!==x&&x.useMatrixPerComponent){const M=B.m;for(let B=0;B<M.length;B++)M[B]/=I.m[B];return"Matrix2D"===C?new H.c(M):"Matrix3D"===C?new H.e(M):e.Matrix.oI(M)}return B.divide(I)}var y;if(null!==(y=this.config)&&void 0!==y&&y.preventIntegerFloatArithmetic&&typeof B!==typeof I)throw new Error("Cannot add different types of numbers.");return(0,F.s)(B)/(0,F.s)(I)}}(0,M.h)("FlowGraphDivideBlock",o);class U extends L{constructor(B){super(x.m,(B=>this._random(B)),"FlowGraphRandomBlock",B),this.min=this.registerDataInput("min",x.m,(null===B||void 0===B?void 0:B.min)??0),this.max=this.registerDataInput("max",x.m,(null===B||void 0===B?void 0:B.max)??1),null!==B&&void 0!==B&&B.seed&&(this._seed=B.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const B=1e4*Math.sin(this._seed++);return B-Math.floor(B)}return Math.random()}_random(B){const I=this.min.getValue(B),C=this.max.getValue(B);return this._getRandomValue()*(C-I)+I}}(0,M.h)("FlowGraphRandomBlock",U);class G extends L{constructor(B){super(x.m,(()=>Math.E),"FlowGraphEBlock",B)}}(0,M.h)("FlowGraphEBlock",G);class V extends L{constructor(B){super(x.m,(()=>Math.PI),"FlowGraphPIBlock",B)}}(0,M.h)("FlowGraphPIBlock",V);class c extends L{constructor(B){super(x.m,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",B)}}(0,M.h)("FlowGraphInfBlock",c);class t extends L{constructor(B){super(x.m,(()=>Number.NaN),"FlowGraphNaNBlock",B)}}function r(B,I){switch((0,F.n)(B)){case"FlowGraphInteger":return new R.b(I(B.value));case"Vector2":return new e.Vector2(I(B.x),I(B.y));case"HI":return new e.HI(I(B.x),I(B.y),I(B.z));case"Vector4":return new e.Vector4(I(B.x),I(B.y),I(B.z),I(B.w));case"Quaternion":return new e.Quaternion(I(B.x),I(B.y),I(B.z),I(B.w));case"Matrix":return e.Matrix.oI(B.m.map(I));case"Matrix2D":return new H.c(B.m.map(I));case"Matrix3D":return new H.e(B.m.map(I));default:return I(B)}}(0,M.h)("FlowGraphNaNBlock",t);class A extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicAbs(B)),"FlowGraphAbsBlock",B)}_polymorphicAbs(B){return r(B,Math.abs)}}(0,M.h)("FlowGraphAbsBlock",A);class D extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicSign(B)),"FlowGraphSignBlock",B)}_polymorphicSign(B){return r(B,Math.sign)}}(0,M.h)("FlowGraphSignBlock",D);class J extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicTrunc(B)),"FlowGraphTruncBlock",B)}_polymorphicTrunc(B){return r(B,Math.trunc)}}(0,M.h)("FlowGraphTruncBlock",J);class i extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicFloor(B)),"FlowGraphFloorBlock",B)}_polymorphicFloor(B){return r(B,Math.floor)}}(0,M.h)("FlowGraphFloorBlock",i);class u extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicCeiling(B)),"FlowGraphCeilBlock",B)}_polymorphicCeiling(B){return r(B,Math.ceil)}}(0,M.h)("FlowGraphCeilBlock",u);class p extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicRound(B)),"FlowGraphRoundBlock",B)}_polymorphicRound(B){return r(B,(B=>{var I;return B<0&&null!==(I=this.config)&&void 0!==I&&I.roundHalfAwayFromZero?-Math.round(-B):Math.round(B)}))}}(0,M.h)("FlowGraphRoundBlock",p);class n extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicFraction(B)),"FlowGraphFractBlock",B)}_polymorphicFraction(B){return r(B,(B=>B-Math.floor(B)))}}(0,M.h)("FlowGraphFractBlock",n);class O extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicNeg(B)),"FlowGraphNegationBlock",B)}_polymorphicNeg(B){return r(B,(B=>-B))}}function a(B,I,C){switch((0,F.n)(B)){case"FlowGraphInteger":return new R.b(C(B.value,I.value));case"Vector2":return new e.Vector2(C(B.x,I.x),C(B.y,I.y));case"HI":return new e.HI(C(B.x,I.x),C(B.y,I.y),C(B.z,I.z));case"Vector4":return new e.Vector4(C(B.x,I.x),C(B.y,I.y),C(B.z,I.z),C(B.w,I.w));case"Quaternion":return new e.Quaternion(C(B.x,I.x),C(B.y,I.y),C(B.z,I.z),C(B.w,I.w));case"Matrix":return e.Matrix.oI(B.m.map(((B,M)=>C(B,I.m[M]))));case"Matrix2D":return new H.c(B.m.map(((B,M)=>C(B,I.m[M]))));case"Matrix3D":return new H.e(B.m.map(((B,M)=>C(B,I.m[M]))));default:return C((0,F.s)(B),(0,F.s)(I))}}(0,M.h)("FlowGraphNegationBlock",O);class W extends y.d{constructor(B){super(x.b,x.b,x.b,((B,I)=>this._polymorphicRemainder(B,I)),"FlowGraphModuloBlock",B)}_polymorphicRemainder(B,I){return a(B,I,((B,I)=>B%I))}}(0,M.h)("FlowGraphModuloBlock",W);class d extends y.d{constructor(B){super(x.b,x.b,x.b,((B,I)=>this._polymorphicMin(B,I)),"FlowGraphMinBlock",B)}_polymorphicMin(B,I){return a(B,I,Math.min)}}(0,M.h)("FlowGraphMinBlock",d);class l extends y.d{constructor(B){super(x.b,x.b,x.b,((B,I)=>this._polymorphicMax(B,I)),"FlowGraphMaxBlock",B)}_polymorphicMax(B,I){return a(B,I,Math.max)}}function E(B,I,C){return Math.min(Math.max(B,Math.min(I,C)),Math.max(I,C))}function Q(B,I,C,M){switch((0,F.n)(B)){case"FlowGraphInteger":return new R.b(M(B.value,I.value,C.value));case"Vector2":return new e.Vector2(M(B.x,I.x,C.x),M(B.y,I.y,C.y));case"HI":return new e.HI(M(B.x,I.x,C.x),M(B.y,I.y,C.y),M(B.z,I.z,C.z));case"Vector4":return new e.Vector4(M(B.x,I.x,C.x),M(B.y,I.y,C.y),M(B.z,I.z,C.z),M(B.w,I.w,C.w));case"Quaternion":return new e.Quaternion(M(B.x,I.x,C.x),M(B.y,I.y,C.y),M(B.z,I.z,C.z),M(B.w,I.w,C.w));case"Matrix":return e.Matrix.oI(B.m.map(((B,x)=>M(B,I.m[x],C.m[x]))));case"Matrix2D":return new H.c(B.m.map(((B,x)=>M(B,I.m[x],C.m[x]))));case"Matrix3D":return new H.e(B.m.map(((B,x)=>M(B,I.m[x],C.m[x]))));default:return M((0,F.s)(B),(0,F.s)(I),(0,F.s)(C))}}(0,M.h)("FlowGraphMaxBlock",l);class Z extends N{constructor(B){super(x.b,x.b,x.b,x.b,((B,I,C)=>this._polymorphicClamp(B,I,C)),"FlowGraphClampBlock",B)}_polymorphicClamp(B,I,C){return Q(B,I,C,E)}}function z(B){return Math.min(Math.max(B,0),1)}(0,M.h)("FlowGraphClampBlock",Z);class b extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicSaturate(B)),"FlowGraphSaturateBlock",B)}_polymorphicSaturate(B){return r(B,z)}}function Y(B,I,C){return(1-C)*B+C*I}(0,M.h)("FlowGraphSaturateBlock",b);class v extends N{constructor(B){super(x.b,x.b,x.b,x.b,((B,I,C)=>this._polymorphicInterpolate(B,I,C)),"FlowGraphMathInterpolationBlock",B)}_polymorphicInterpolate(B,I,C){return Q(B,I,C,Y)}}(0,M.h)("FlowGraphMathInterpolationBlock",v);class s extends y.d{constructor(B){super(x.b,x.b,x.e,((B,I)=>this._polymorphicEq(B,I)),"FlowGraphEqualityBlock",B)}_polymorphicEq(B,I){const C=(0,F.n)(B),M=(0,F.n)(I);return typeof B===typeof I&&((0,F.l)(C,M)||(0,F.h)(C,M)||(0,F.e)(C,M)?B.equals(I):B===I)}}function X(B,I,C){if((0,F.t)(B)&&(0,F.t)(I))return C((0,F.s)(B),(0,F.s)(I));throw new Error(`Cannot compare ${B} and ${I}`)}(0,M.h)("FlowGraphEqualityBlock",s);class T extends y.d{constructor(B){super(x.b,x.b,x.e,((B,I)=>this._polymorphicLessThan(B,I)),"FlowGraphLessThanBlock",B)}_polymorphicLessThan(B,I){return X(B,I,((B,I)=>B<I))}}(0,M.h)("FlowGraphLessThanBlock",T);class P extends y.d{constructor(B){super(x.b,x.b,x.e,((B,I)=>this._polymorphicLessThanOrEqual(B,I)),"FlowGraphLessThanOrEqualBlock",B)}_polymorphicLessThanOrEqual(B,I){return X(B,I,((B,I)=>B<=I))}}(0,M.h)("FlowGraphLessThanOrEqualBlock",P);class h extends y.d{constructor(B){super(x.b,x.b,x.e,((B,I)=>this._polymorphicGreaterThan(B,I)),"FlowGraphGreaterThanBlock",B)}_polymorphicGreaterThan(B,I){return X(B,I,((B,I)=>B>I))}}(0,M.h)("FlowGraphGreaterThanBlock",h);class j extends y.d{constructor(B){super(x.b,x.b,x.e,((B,I)=>this._polymorphicGreaterThanOrEqual(B,I)),"FlowGraphGreaterThanOrEqualBlock",B)}_polymorphicGreaterThanOrEqual(B,I){return X(B,I,((B,I)=>B>=I))}}(0,M.h)("FlowGraphGreaterThanOrEqualBlock",j);class w extends g.e{constructor(B){super(x.b,x.e,(B=>this._polymorphicIsNan(B)),"FlowGraphIsNaNBlock",B)}_polymorphicIsNan(B){if((0,F.t)(B,!0))return isNaN((0,F.s)(B));throw new Error(`Cannot get NaN of ${B}`)}}(0,M.h)("FlowGraphIsNaNBlock",w);class K extends g.e{constructor(B){super(x.b,x.e,(B=>this._polymorphicIsInf(B)),"FlowGraphIsInfBlock",B)}_polymorphicIsInf(B){if((0,F.t)(B))return!isFinite((0,F.s)(B));throw new Error(`Cannot get isInf of ${B}`)}}(0,M.h)("FlowGraphIsInfBlock",K);class m extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicDegToRad(B)),"FlowGraphDegToRadBlock",B)}_degToRad(B){return B*Math.PI/180}_polymorphicDegToRad(B){return r(B,this._degToRad)}}(0,M.h)("FlowGraphDegToRadBlock",m);class BB extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicRadToDeg(B)),"FlowGraphRadToDegBlock",B)}_radToDeg(B){return 180*B/Math.PI}_polymorphicRadToDeg(B){return r(B,this._radToDeg)}}(0,M.h)("FlowGraphRadToDegBlock",BB);class IB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicSin(B)),"FlowGraphSinBlock",B)}_polymorphicSin(B){return r(B,Math.sin)}}class CB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicCos(B)),"FlowGraphCosBlock",B)}_polymorphicCos(B){return r(B,Math.cos)}}class MB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicTan(B)),"FlowGraphTanBlock",B)}_polymorphicTan(B){return r(B,Math.tan)}}class xB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicAsin(B)),"FlowGraphASinBlock",B)}_polymorphicAsin(B){return r(B,Math.asin)}}(0,M.h)("FlowGraphASinBlock",xB);class yB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicAcos(B)),"FlowGraphACosBlock",B)}_polymorphicAcos(B){return r(B,Math.acos)}}(0,M.h)("FlowGraphACosBlock",yB);class fB extends g.e{constructor(B){super(x.m,x.m,(B=>this._polymorphicAtan(B)),"FlowGraphATanBlock",B)}_polymorphicAtan(B){return r(B,Math.atan)}}(0,M.h)("FlowGraphATanBlock",fB);class LB extends y.d{constructor(B){super(x.b,x.b,x.b,((B,I)=>this._polymorphicAtan2(B,I)),"FlowGraphATan2Block",B)}_polymorphicAtan2(B,I){return a(B,I,Math.atan2)}}(0,M.h)("FlowGraphATan2Block",LB);class eB extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicSinh(B)),"FlowGraphSinhBlock",B)}_polymorphicSinh(B){return r(B,Math.sinh)}}(0,M.h)("FlowGraphSinhBlock",eB);class gB extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicCosh(B)),"FlowGraphCoshBlock",B)}_polymorphicCosh(B){return r(B,Math.cosh)}}(0,M.h)("FlowGraphCoshBlock",gB);class NB extends g.e{constructor(B){super(x.b,x.b,(B=>this._polymorphicTanh(B)),"FlowGraphTanhBlock",B)}_polymorphicTanh(B){return r(B,Math.tanh)}}(0,M.h)("FlowGraphTanhBlock",NB);class RB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicAsinh(B)),"FlowGraphASinhBlock",B)}_polymorphicAsinh(B){return r(B,Math.asinh)}}(0,M.h)("FlowGraphASinhBlock",RB);class HB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicAcosh(B)),"FlowGraphACoshBlock",B)}_polymorphicAcosh(B){return r(B,Math.acosh)}}(0,M.h)("FlowGraphACoshBlock",HB);class FB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicAtanh(B)),"FlowGraphATanhBlock",B)}_polymorphicAtanh(B){return r(B,Math.atanh)}}(0,M.h)("FlowGraphATanhBlock",FB);class kB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicExp(B)),"FlowGraphExponentialBlock",B)}_polymorphicExp(B){return r(B,Math.exp)}}(0,M.h)("FlowGraphExponentialBlock",kB);class qB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicLog(B)),"FlowGraphLogBlock",B)}_polymorphicLog(B){return r(B,Math.log)}}(0,M.h)("FlowGraphLogBlock",qB);class SB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicLog2(B)),"FlowGraphLog2Block",B)}_polymorphicLog2(B){return r(B,Math.log2)}}(0,M.h)("FlowGraphLog2Block",SB);class oB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicLog10(B)),"FlowGraphLog10Block",B)}_polymorphicLog10(B){return r(B,Math.log10)}}(0,M.h)("FlowGraphLog10Block",oB);class UB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicSqrt(B)),"FlowGraphSquareRootBlock",B)}_polymorphicSqrt(B){return r(B,Math.sqrt)}}(0,M.h)("FlowGraphSquareRootBlock",UB);class GB extends g.e{constructor(B){super(x.b,x.m,(B=>this._polymorphicCubeRoot(B)),"FlowGraphCubeRootBlock",B)}_polymorphicCubeRoot(B){return r(B,Math.cbrt)}}(0,M.h)("FlowGraphCubeRootBlock",GB);class VB extends y.d{constructor(B){super(x.b,x.m,x.m,((B,I)=>this._polymorphicPow(B,I)),"FlowGraphPowerBlock",B)}_polymorphicPow(B,I){return a(B,I,Math.pow)}}(0,M.h)("FlowGraphPowerBlock",VB);class cB extends g.e{constructor(B){super((0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(B=>"boolean"===typeof B?!B:"number"===typeof B?~B:new R.b(~B.value)),"FlowGraphBitwiseNotBlock",B)}}(0,M.h)("FlowGraphBitwiseNotBlock",cB);class tB extends y.d{constructor(B){super((0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),((B,I)=>{if("boolean"===typeof B&&"boolean"===typeof I)return B&&I;if("number"===typeof B&&"number"===typeof I)return B&I;if("object"===typeof B&&"object"===typeof I)return new R.b(B.value&I.value);throw new Error(`Cannot perform bitwise AND on ${B} and ${I}`)}),"FlowGraphBitwiseAndBlock",B)}}(0,M.h)("FlowGraphBitwiseAndBlock",tB);class rB extends y.d{constructor(B){super((0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),((B,I)=>{if("boolean"===typeof B&&"boolean"===typeof I)return B||I;if("number"===typeof B&&"number"===typeof I)return B|I;if("object"===typeof B&&"object"===typeof I)return new R.b(B.value|I.value);throw new Error(`Cannot perform bitwise OR on ${B} and ${I}`)}),"FlowGraphBitwiseOrBlock",B)}}(0,M.h)("FlowGraphBitwiseOrBlock",rB);class AB extends y.d{constructor(B){super((0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),(0,x.H)((null===B||void 0===B?void 0:B.valueType)||"FlowGraphInteger"),((B,I)=>{if("boolean"===typeof B&&"boolean"===typeof I)return B!==I;if("number"===typeof B&&"number"===typeof I)return B^I;if("object"===typeof B&&"object"===typeof I)return new R.b(B.value^I.value);throw new Error(`Cannot perform bitwise XOR on ${B} and ${I}`)}),"FlowGraphBitwiseXorBlock",B)}}(0,M.h)("FlowGraphBitwiseXorBlock",AB);class DB extends y.d{constructor(B){super(x.f,x.f,x.f,((B,I)=>new R.b(B.value<<I.value)),"FlowGraphBitwiseLeftShiftBlock",B)}}(0,M.h)("FlowGraphBitwiseLeftShiftBlock",DB);class JB extends y.d{constructor(B){super(x.f,x.f,x.f,((B,I)=>new R.b(B.value>>I.value)),"FlowGraphBitwiseRightShiftBlock",B)}}(0,M.h)("FlowGraphBitwiseRightShiftBlock",JB);class iB extends g.e{constructor(B){super(x.f,x.f,(B=>new R.b(Math.clz32(B.value))),"FlowGraphLeadingZerosBlock",B)}}(0,M.h)("FlowGraphLeadingZerosBlock",iB);class uB extends g.e{constructor(B){super(x.f,x.f,(B=>new R.b(B.value?31-Math.clz32(B.value&-B.value):32)),"FlowGraphTrailingZerosBlock",B)}}(0,M.h)("FlowGraphTrailingZerosBlock",uB);class pB extends g.e{constructor(B){super(x.f,x.f,(B=>new R.b(function(B){let I=0;for(;B;)I+=1&B,B>>=1;return I}(B.value))),"FlowGraphOneBitsCounterBlock",B)}}(0,M.h)("FlowGraphOneBitsCounterBlock",pB)},14404:(B,I,C)=>{C.d(I,{d:()=>x});var M=C(14408);class x extends M.b{constructor(B,I,C,M,x,y){super(C,y),this._operation=M,this._className=x,this.a=this.registerDataInput("a",B),this.b=this.registerDataInput("b",I)}_doOperation(B){const I=this.a.getValue(B),C=this.b.getValue(B);return this._operation(I,C)}getClassName(){return this._className}}},14408:(B,I,C)=>{C.d(I,{b:()=>L});var M=C(12927),x=C(12901);const y="cachedOperationValue",f="cachedExecutionId";class L extends M.e{constructor(B,I){super(I),this.value=this.registerDataOutput("value",B),this.isValid=this.registerDataOutput("isValid",x.e)}_updateOutputs(B){const I=B._getExecutionVariable(this,f,-1),C=B._getExecutionVariable(this,y,null);if(void 0!==C&&null!==C&&I===B.executionId)this.isValid.setValue(!0,B),this.value.setValue(C,B);else try{const I=this._doOperation(B);if(void 0===I||null===I)return void this.isValid.setValue(!1,B);B._setExecutionVariable(this,y,I),B._setExecutionVariable(this,f,B.executionId),this.value.setValue(I,B),this.isValid.setValue(!0,B)}catch(M){this.isValid.setValue(!1,B)}}}},14415:(B,I,C)=>{C.d(I,{e:()=>x});var M=C(14408);class x extends M.b{constructor(B,I,C,M,x){super(I,x),this._operation=C,this._className=M,this.a=this.registerDataInput("a",B)}_doOperation(B){return this._operation(this.a.getValue(B))}getClassName(){return this._className}}}}]);