"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{13835:(L,j,P)=>{P.r(j),P.d(j,{FlowGraphMultiGateBlock:()=>u});var A=P(606),R=P(12521),o=P(12510),Y=P(12506);class u extends R.d{constructor(L){super(L),this.config=L,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",o.f,new Y.b(-1)),this.setNumberOfOutputSignals(null===L||void 0===L?void 0:L.outputSignalCount)}_getNextIndex(L){if(L.includes(!1)||this.config.isLoop&&L.fill(!1),this.config.isRandom){const j=L.map(((L,j)=>L?-1:j)).filter((L=>-1!==L));return j.length?j[Math.floor(Math.random()*j.length)]:-1}return L.indexOf(!1)}setNumberOfOutputSignals(){let L=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>L;){const L=this.outputSignals.pop();L&&(L.disconnectFromAll(),this._unregisterSignalOutput(L.name))}for(;this.outputSignals.length<L;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(L,j){if(L._hasExecutionVariable(this,"indexesUsed")||L._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),j===this.reset)return L._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new Y.b(-1),L);const P=L._getExecutionVariable(this,"indexesUsed",[]),A=this._getNextIndex(P);A>-1&&(this.lastIndex.setValue(new Y.b(A),L),P[A]=!0,L._setExecutionVariable(this,"indexesUsed",P),this.outputSignals[A]._activateSignal(L))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(L){super.serialize(L),L.config.outputSignalCount=this.config.outputSignalCount,L.config.isRandom=this.config.isRandom,L.config.loop=this.config.isLoop,L.config.startIndex=this.config.startIndex}}(0,A.h)("FlowGraphMultiGateBlock",u)}}]);