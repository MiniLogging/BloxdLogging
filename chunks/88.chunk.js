"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{14464:(Z,x,F)=>{F.r(x),F.d(x,{FlowGraphAbsBlock:()=>y,FlowGraphAcosBlock:()=>fZ,FlowGraphAcoshBlock:()=>sZ,FlowGraphAddBlock:()=>p,FlowGraphAsinBlock:()=>GZ,FlowGraphAsinhBlock:()=>cZ,FlowGraphAtan2Block:()=>jZ,FlowGraphAtanBlock:()=>YZ,FlowGraphAtanhBlock:()=>JZ,FlowGraphBitwiseAndBlock:()=>SZ,FlowGraphBitwiseLeftShiftBlock:()=>qZ,FlowGraphBitwiseNotBlock:()=>HZ,FlowGraphBitwiseOrBlock:()=>KZ,FlowGraphBitwiseRightShiftBlock:()=>RZ,FlowGraphBitwiseXorBlock:()=>yZ,FlowGraphCeilBlock:()=>v,FlowGraphClampBlock:()=>A,FlowGraphCosBlock:()=>FZ,FlowGraphCoshBlock:()=>tZ,FlowGraphCubeRootBlock:()=>CZ,FlowGraphDegToRadBlock:()=>P,FlowGraphDivideBlock:()=>M,FlowGraphEBlock:()=>C,FlowGraphEqualityBlock:()=>g,FlowGraphExpBlock:()=>pZ,FlowGraphFloorBlock:()=>B,FlowGraphFractionBlock:()=>i,FlowGraphGreaterThanBlock:()=>a,FlowGraphGreaterThanOrEqualBlock:()=>I,FlowGraphInfBlock:()=>H,FlowGraphIsInfinityBlock:()=>z,FlowGraphIsNanBlock:()=>r,FlowGraphLeadingZerosBlock:()=>BZ,FlowGraphLessThanBlock:()=>n,FlowGraphLessThanOrEqualBlock:()=>V,FlowGraphLog10Block:()=>MZ,FlowGraphLog2Block:()=>kZ,FlowGraphLogBlock:()=>UZ,FlowGraphMathInterpolationBlock:()=>Q,FlowGraphMaxBlock:()=>T,FlowGraphMinBlock:()=>w,FlowGraphModuloBlock:()=>E,FlowGraphMultiplyBlock:()=>k,FlowGraphNaNBlock:()=>S,FlowGraphNegationBlock:()=>e,FlowGraphOneBitsCounterBlock:()=>lZ,FlowGraphPiBlock:()=>L,FlowGraphPowerBlock:()=>LZ,FlowGraphRadToDegBlock:()=>ZZ,FlowGraphRandomBlock:()=>m,FlowGraphRoundBlock:()=>l,FlowGraphSaturateBlock:()=>X,FlowGraphSignBlock:()=>q,FlowGraphSinBlock:()=>xZ,FlowGraphSinhBlock:()=>dZ,FlowGraphSquareRootBlock:()=>mZ,FlowGraphSubtractBlock:()=>U,FlowGraphTanBlock:()=>uZ,FlowGraphTanhBlock:()=>oZ,FlowGraphTrailingZerosBlock:()=>vZ,FlowGraphTruncBlock:()=>R});var u=F(11136),G=F(12954),f=F(14469),Y=F(14476);class j extends Y.c{constructor(Z,x,F,u){super(Z,u),this._operation=x,this._className=F}_doOperation(Z){return this._operation(Z)}getClassName(){return this._className}}var d=F(11179),t=F(14478);class o extends Y.c{constructor(Z,x,F,u,G,f,Y){super(u,Y),this._operation=G,this._className=f,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",x),this.c=this.registerDataInput("c",F)}_doOperation(Z){return this._operation(this.a.getValue(Z),this.b.getValue(Z),this.c.getValue(Z))}getClassName(){return this._className}}var c=F(12949),s=F(12957),J=F(12990);class p extends f.c{constructor(Z){super((0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),((Z,x)=>this._polymorphicAdd(Z,x)),"FlowGraphAddBlock",Z)}_polymorphicAdd(Z,x){const F=(0,J.o)(Z),u=(0,J.o)(x);if((0,J.k)(F,u)||(0,J.h)(F,u)||(0,J.e)(F,u))return Z.add(x);if("Quaternion"===F||"Vector4"===u)return new d.Vector4(Z.x,Z.y,Z.z,Z.w).addInPlace(x);if("Vector4"===F||"Quaternion"===u)return Z.add(x);var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof Z!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,J.u)(Z)+(0,J.u)(x)}}(0,u.g)("FlowGraphAddBlock",p);class U extends f.c{constructor(Z){super((0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),((Z,x)=>this._polymorphicSubtract(Z,x)),"FlowGraphSubtractBlock",Z)}_polymorphicSubtract(Z,x){const F=(0,J.o)(Z),u=(0,J.o)(x);if((0,J.k)(F,u)||(0,J.e)(F,u)||(0,J.h)(F,u))return Z.Mx(x);if("Quaternion"===F||"Vector4"===u)return new d.Vector4(Z.x,Z.y,Z.z,Z.w).Dc(x);if("Vector4"===F||"Quaternion"===u)return Z.Mx(x);var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof Z!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,J.u)(Z)-(0,J.u)(x)}}(0,u.g)("FlowGraphSubtractBlock",U);class k extends f.c{constructor(Z){super((0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),((Z,x)=>this._polymorphicMultiply(Z,x)),"FlowGraphMultiplyBlock",Z)}_polymorphicMultiply(Z,x){const F=(0,J.o)(Z),u=(0,J.o)(x);if((0,J.k)(F,u)||(0,J.e)(F,u))return Z.multiply(x);if("Quaternion"===F||"Vector4"===u)return new d.Vector4(Z.x,Z.y,Z.z,Z.w).multiplyInPlace(x);if("Vector4"===F||"Quaternion"===u)return Z.multiply(x);if((0,J.h)(F,u)){var G;if(null!==(G=this.config)&&void 0!==G&&G.useMatrixPerComponent){const u=Z.m;for(let Z=0;Z<u.length;Z++)u[Z]*=x.m[Z];return"Matrix2D"===F?new s.c(u):"Matrix3D"===F?new s.e(u):d.Matrix.Hx(u)}return x.multiply(Z)}var f;if(null!==(f=this.config)&&void 0!==f&&f.preventIntegerFloatArithmetic&&typeof Z!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,J.u)(Z)*(0,J.u)(x)}}(0,u.g)("FlowGraphMultiplyBlock",k);class M extends f.c{constructor(Z){super((0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),(0,G.Q)(null===Z||void 0===Z?void 0:Z.type),((Z,x)=>this._polymorphicDivide(Z,x)),"FlowGraphDivideBlock",Z)}_polymorphicDivide(Z,x){const F=(0,J.o)(Z),u=(0,J.o)(x);if((0,J.k)(F,u)||(0,J.e)(F,u))return Z.divide(x);if("Quaternion"===F||"Quaternion"===u){const F=Z.clone();return F.x/=x.x,F.y/=x.y,F.z/=x.z,F.w/=x.w,F}if("Quaternion"===F||"Vector4"===u)return new d.Vector4(Z.x,Z.y,Z.z,Z.w).divideInPlace(x);if("Vector4"===F||"Quaternion"===u)return Z.divide(x);if((0,J.h)(F,u)){var G;if(null!==(G=this.config)&&void 0!==G&&G.useMatrixPerComponent){const u=Z.m;for(let Z=0;Z<u.length;Z++)u[Z]/=x.m[Z];return"Matrix2D"===F?new s.c(u):"Matrix3D"===F?new s.e(u):d.Matrix.Hx(u)}return Z.divide(x)}var f;if(null!==(f=this.config)&&void 0!==f&&f.preventIntegerFloatArithmetic&&typeof Z!==typeof x)throw new Error("Cannot add different types of numbers.");return(0,J.u)(Z)/(0,J.u)(x)}}(0,u.g)("FlowGraphDivideBlock",M);class m extends j{constructor(Z){super(G.u,(Z=>this._random(Z)),"FlowGraphRandomBlock",Z),this.min=this.registerDataInput("min",G.u,(null===Z||void 0===Z?void 0:Z.min)??0),this.max=this.registerDataInput("max",G.u,(null===Z||void 0===Z?void 0:Z.max)??1),null!==Z&&void 0!==Z&&Z.seed&&(this._seed=Z.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const Z=1e4*Math.sin(this._seed++);return Z-Math.floor(Z)}return Math.random()}_random(Z){const x=this.min.getValue(Z),F=this.max.getValue(Z);return this._getRandomValue()*(F-x)+x}}(0,u.g)("FlowGraphRandomBlock",m);class C extends j{constructor(Z){super(G.u,(()=>Math.E),"FlowGraphEBlock",Z)}}(0,u.g)("FlowGraphEBlock",C);class L extends j{constructor(Z){super(G.u,(()=>Math.PI),"FlowGraphPIBlock",Z)}}(0,u.g)("FlowGraphPIBlock",L);class H extends j{constructor(Z){super(G.u,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",Z)}}(0,u.g)("FlowGraphInfBlock",H);class S extends j{constructor(Z){super(G.u,(()=>Number.NaN),"FlowGraphNaNBlock",Z)}}function K(Z,x){switch((0,J.o)(Z)){case"FlowGraphInteger":return new c.d(x(Z.value));case"Vector2":return new d.Vector2(x(Z.x),x(Z.y));case"kx":return new d.kx(x(Z.x),x(Z.y),x(Z.z));case"Vector4":return new d.Vector4(x(Z.x),x(Z.y),x(Z.z),x(Z.w));case"Quaternion":return new d.Quaternion(x(Z.x),x(Z.y),x(Z.z),x(Z.w));case"Matrix":return d.Matrix.Hx(Z.m.map(x));case"Matrix2D":return new s.c(Z.m.map(x));case"Matrix3D":return new s.e(Z.m.map(x));default:return x(Z)}}(0,u.g)("FlowGraphNaNBlock",S);class y extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicAbs(Z)),"FlowGraphAbsBlock",Z)}_polymorphicAbs(Z){return K(Z,Math.abs)}}(0,u.g)("FlowGraphAbsBlock",y);class q extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicSign(Z)),"FlowGraphSignBlock",Z)}_polymorphicSign(Z){return K(Z,Math.sign)}}(0,u.g)("FlowGraphSignBlock",q);class R extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicTrunc(Z)),"FlowGraphTruncBlock",Z)}_polymorphicTrunc(Z){return K(Z,Math.trunc)}}(0,u.g)("FlowGraphTruncBlock",R);class B extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicFloor(Z)),"FlowGraphFloorBlock",Z)}_polymorphicFloor(Z){return K(Z,Math.floor)}}(0,u.g)("FlowGraphFloorBlock",B);class v extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicCeiling(Z)),"FlowGraphCeilBlock",Z)}_polymorphicCeiling(Z){return K(Z,Math.ceil)}}(0,u.g)("FlowGraphCeilBlock",v);class l extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicRound(Z)),"FlowGraphRoundBlock",Z)}_polymorphicRound(Z){return K(Z,(Z=>{var x;return Z<0&&null!==(x=this.config)&&void 0!==x&&x.roundHalfAwayFromZero?-Math.round(-Z):Math.round(Z)}))}}(0,u.g)("FlowGraphRoundBlock",l);class i extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicFraction(Z)),"FlowGraphFractBlock",Z)}_polymorphicFraction(Z){return K(Z,(Z=>Z-Math.floor(Z)))}}(0,u.g)("FlowGraphFractBlock",i);class e extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicNeg(Z)),"FlowGraphNegationBlock",Z)}_polymorphicNeg(Z){return K(Z,(Z=>-Z))}}function b(Z,x,F){switch((0,J.o)(Z)){case"FlowGraphInteger":return new c.d(F(Z.value,x.value));case"Vector2":return new d.Vector2(F(Z.x,x.x),F(Z.y,x.y));case"kx":return new d.kx(F(Z.x,x.x),F(Z.y,x.y),F(Z.z,x.z));case"Vector4":return new d.Vector4(F(Z.x,x.x),F(Z.y,x.y),F(Z.z,x.z),F(Z.w,x.w));case"Quaternion":return new d.Quaternion(F(Z.x,x.x),F(Z.y,x.y),F(Z.z,x.z),F(Z.w,x.w));case"Matrix":return d.Matrix.Hx(Z.m.map(((Z,u)=>F(Z,x.m[u]))));case"Matrix2D":return new s.c(Z.m.map(((Z,u)=>F(Z,x.m[u]))));case"Matrix3D":return new s.e(Z.m.map(((Z,u)=>F(Z,x.m[u]))));default:return F((0,J.u)(Z),(0,J.u)(x))}}(0,u.g)("FlowGraphNegationBlock",e);class E extends f.c{constructor(Z){super(G.d,G.d,G.d,((Z,x)=>this._polymorphicRemainder(Z,x)),"FlowGraphModuloBlock",Z)}_polymorphicRemainder(Z,x){return b(Z,x,((Z,x)=>Z%x))}}(0,u.g)("FlowGraphModuloBlock",E);class w extends f.c{constructor(Z){super(G.d,G.d,G.d,((Z,x)=>this._polymorphicMin(Z,x)),"FlowGraphMinBlock",Z)}_polymorphicMin(Z,x){return b(Z,x,Math.min)}}(0,u.g)("FlowGraphMinBlock",w);class T extends f.c{constructor(Z){super(G.d,G.d,G.d,((Z,x)=>this._polymorphicMax(Z,x)),"FlowGraphMaxBlock",Z)}_polymorphicMax(Z,x){return b(Z,x,Math.max)}}function N(Z,x,F){return Math.min(Math.max(Z,Math.min(x,F)),Math.max(x,F))}function W(Z,x,F,u){switch((0,J.o)(Z)){case"FlowGraphInteger":return new c.d(u(Z.value,x.value,F.value));case"Vector2":return new d.Vector2(u(Z.x,x.x,F.x),u(Z.y,x.y,F.y));case"kx":return new d.kx(u(Z.x,x.x,F.x),u(Z.y,x.y,F.y),u(Z.z,x.z,F.z));case"Vector4":return new d.Vector4(u(Z.x,x.x,F.x),u(Z.y,x.y,F.y),u(Z.z,x.z,F.z),u(Z.w,x.w,F.w));case"Quaternion":return new d.Quaternion(u(Z.x,x.x,F.x),u(Z.y,x.y,F.y),u(Z.z,x.z,F.z),u(Z.w,x.w,F.w));case"Matrix":return d.Matrix.Hx(Z.m.map(((Z,G)=>u(Z,x.m[G],F.m[G]))));case"Matrix2D":return new s.c(Z.m.map(((Z,G)=>u(Z,x.m[G],F.m[G]))));case"Matrix3D":return new s.e(Z.m.map(((Z,G)=>u(Z,x.m[G],F.m[G]))));default:return u((0,J.u)(Z),(0,J.u)(x),(0,J.u)(F))}}(0,u.g)("FlowGraphMaxBlock",T);class A extends o{constructor(Z){super(G.d,G.d,G.d,G.d,((Z,x,F)=>this._polymorphicClamp(Z,x,F)),"FlowGraphClampBlock",Z)}_polymorphicClamp(Z,x,F){return W(Z,x,F,N)}}function h(Z){return Math.min(Math.max(Z,0),1)}(0,u.g)("FlowGraphClampBlock",A);class X extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicSaturate(Z)),"FlowGraphSaturateBlock",Z)}_polymorphicSaturate(Z){return K(Z,h)}}function D(Z,x,F){return(1-F)*Z+F*x}(0,u.g)("FlowGraphSaturateBlock",X);class Q extends o{constructor(Z){super(G.d,G.d,G.d,G.d,((Z,x,F)=>this._polymorphicInterpolate(Z,x,F)),"FlowGraphMathInterpolationBlock",Z)}_polymorphicInterpolate(Z,x,F){return W(Z,x,F,D)}}(0,u.g)("FlowGraphMathInterpolationBlock",Q);class g extends f.c{constructor(Z){super(G.d,G.d,G.f,((Z,x)=>this._polymorphicEq(Z,x)),"FlowGraphEqualityBlock",Z)}_polymorphicEq(Z,x){const F=(0,J.o)(Z),u=(0,J.o)(x);return typeof Z===typeof x&&((0,J.k)(F,u)||(0,J.h)(F,u)||(0,J.e)(F,u)?Z.equals(x):Z===x)}}function O(Z,x,F){if((0,J.w)(Z)&&(0,J.w)(x))return F((0,J.u)(Z),(0,J.u)(x));throw new Error(`Cannot compare ${Z} and ${x}`)}(0,u.g)("FlowGraphEqualityBlock",g);class n extends f.c{constructor(Z){super(G.d,G.d,G.f,((Z,x)=>this._polymorphicLessThan(Z,x)),"FlowGraphLessThanBlock",Z)}_polymorphicLessThan(Z,x){return O(Z,x,((Z,x)=>Z<x))}}(0,u.g)("FlowGraphLessThanBlock",n);class V extends f.c{constructor(Z){super(G.d,G.d,G.f,((Z,x)=>this._polymorphicLessThanOrEqual(Z,x)),"FlowGraphLessThanOrEqualBlock",Z)}_polymorphicLessThanOrEqual(Z,x){return O(Z,x,((Z,x)=>Z<=x))}}(0,u.g)("FlowGraphLessThanOrEqualBlock",V);class a extends f.c{constructor(Z){super(G.d,G.d,G.f,((Z,x)=>this._polymorphicGreaterThan(Z,x)),"FlowGraphGreaterThanBlock",Z)}_polymorphicGreaterThan(Z,x){return O(Z,x,((Z,x)=>Z>x))}}(0,u.g)("FlowGraphGreaterThanBlock",a);class I extends f.c{constructor(Z){super(G.d,G.d,G.f,((Z,x)=>this._polymorphicGreaterThanOrEqual(Z,x)),"FlowGraphGreaterThanOrEqualBlock",Z)}_polymorphicGreaterThanOrEqual(Z,x){return O(Z,x,((Z,x)=>Z>=x))}}(0,u.g)("FlowGraphGreaterThanOrEqualBlock",I);class r extends t.d{constructor(Z){super(G.d,G.f,(Z=>this._polymorphicIsNan(Z)),"FlowGraphIsNaNBlock",Z)}_polymorphicIsNan(Z){if((0,J.w)(Z,!0))return isNaN((0,J.u)(Z));throw new Error(`Cannot get NaN of ${Z}`)}}(0,u.g)("FlowGraphIsNaNBlock",r);class z extends t.d{constructor(Z){super(G.d,G.f,(Z=>this._polymorphicIsInf(Z)),"FlowGraphIsInfBlock",Z)}_polymorphicIsInf(Z){if((0,J.w)(Z))return!isFinite((0,J.u)(Z));throw new Error(`Cannot get isInf of ${Z}`)}}(0,u.g)("FlowGraphIsInfBlock",z);class P extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicDegToRad(Z)),"FlowGraphDegToRadBlock",Z)}_degToRad(Z){return Z*Math.PI/180}_polymorphicDegToRad(Z){return K(Z,this._degToRad)}}(0,u.g)("FlowGraphDegToRadBlock",P);class ZZ extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicRadToDeg(Z)),"FlowGraphRadToDegBlock",Z)}_radToDeg(Z){return 180*Z/Math.PI}_polymorphicRadToDeg(Z){return K(Z,this._radToDeg)}}(0,u.g)("FlowGraphRadToDegBlock",ZZ);class xZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicSin(Z)),"FlowGraphSinBlock",Z)}_polymorphicSin(Z){return K(Z,Math.sin)}}class FZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicCos(Z)),"FlowGraphCosBlock",Z)}_polymorphicCos(Z){return K(Z,Math.cos)}}class uZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicTan(Z)),"FlowGraphTanBlock",Z)}_polymorphicTan(Z){return K(Z,Math.tan)}}class GZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicAsin(Z)),"FlowGraphASinBlock",Z)}_polymorphicAsin(Z){return K(Z,Math.asin)}}(0,u.g)("FlowGraphASinBlock",GZ);class fZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicAcos(Z)),"FlowGraphACosBlock",Z)}_polymorphicAcos(Z){return K(Z,Math.acos)}}(0,u.g)("FlowGraphACosBlock",fZ);class YZ extends t.d{constructor(Z){super(G.u,G.u,(Z=>this._polymorphicAtan(Z)),"FlowGraphATanBlock",Z)}_polymorphicAtan(Z){return K(Z,Math.atan)}}(0,u.g)("FlowGraphATanBlock",YZ);class jZ extends f.c{constructor(Z){super(G.d,G.d,G.d,((Z,x)=>this._polymorphicAtan2(Z,x)),"FlowGraphATan2Block",Z)}_polymorphicAtan2(Z,x){return b(Z,x,Math.atan2)}}(0,u.g)("FlowGraphATan2Block",jZ);class dZ extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicSinh(Z)),"FlowGraphSinhBlock",Z)}_polymorphicSinh(Z){return K(Z,Math.sinh)}}(0,u.g)("FlowGraphSinhBlock",dZ);class tZ extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicCosh(Z)),"FlowGraphCoshBlock",Z)}_polymorphicCosh(Z){return K(Z,Math.cosh)}}(0,u.g)("FlowGraphCoshBlock",tZ);class oZ extends t.d{constructor(Z){super(G.d,G.d,(Z=>this._polymorphicTanh(Z)),"FlowGraphTanhBlock",Z)}_polymorphicTanh(Z){return K(Z,Math.tanh)}}(0,u.g)("FlowGraphTanhBlock",oZ);class cZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicAsinh(Z)),"FlowGraphASinhBlock",Z)}_polymorphicAsinh(Z){return K(Z,Math.asinh)}}(0,u.g)("FlowGraphASinhBlock",cZ);class sZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicAcosh(Z)),"FlowGraphACoshBlock",Z)}_polymorphicAcosh(Z){return K(Z,Math.acosh)}}(0,u.g)("FlowGraphACoshBlock",sZ);class JZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicAtanh(Z)),"FlowGraphATanhBlock",Z)}_polymorphicAtanh(Z){return K(Z,Math.atanh)}}(0,u.g)("FlowGraphATanhBlock",JZ);class pZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicExp(Z)),"FlowGraphExponentialBlock",Z)}_polymorphicExp(Z){return K(Z,Math.exp)}}(0,u.g)("FlowGraphExponentialBlock",pZ);class UZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicLog(Z)),"FlowGraphLogBlock",Z)}_polymorphicLog(Z){return K(Z,Math.log)}}(0,u.g)("FlowGraphLogBlock",UZ);class kZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicLog2(Z)),"FlowGraphLog2Block",Z)}_polymorphicLog2(Z){return K(Z,Math.log2)}}(0,u.g)("FlowGraphLog2Block",kZ);class MZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicLog10(Z)),"FlowGraphLog10Block",Z)}_polymorphicLog10(Z){return K(Z,Math.log10)}}(0,u.g)("FlowGraphLog10Block",MZ);class mZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicSqrt(Z)),"FlowGraphSquareRootBlock",Z)}_polymorphicSqrt(Z){return K(Z,Math.sqrt)}}(0,u.g)("FlowGraphSquareRootBlock",mZ);class CZ extends t.d{constructor(Z){super(G.d,G.u,(Z=>this._polymorphicCubeRoot(Z)),"FlowGraphCubeRootBlock",Z)}_polymorphicCubeRoot(Z){return K(Z,Math.cbrt)}}(0,u.g)("FlowGraphCubeRootBlock",CZ);class LZ extends f.c{constructor(Z){super(G.d,G.u,G.u,((Z,x)=>this._polymorphicPow(Z,x)),"FlowGraphPowerBlock",Z)}_polymorphicPow(Z,x){return b(Z,x,Math.pow)}}(0,u.g)("FlowGraphPowerBlock",LZ);class HZ extends t.d{constructor(Z){super((0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(Z=>"boolean"===typeof Z?!Z:"number"===typeof Z?~Z:new c.d(~Z.value)),"FlowGraphBitwiseNotBlock",Z)}}(0,u.g)("FlowGraphBitwiseNotBlock",HZ);class SZ extends f.c{constructor(Z){super((0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,x)=>{if("boolean"===typeof Z&&"boolean"===typeof x)return Z&&x;if("number"===typeof Z&&"number"===typeof x)return Z&x;if("object"===typeof Z&&"object"===typeof x)return new c.d(Z.value&x.value);throw new Error(`Cannot perform bitwise AND on ${Z} and ${x}`)}),"FlowGraphBitwiseAndBlock",Z)}}(0,u.g)("FlowGraphBitwiseAndBlock",SZ);class KZ extends f.c{constructor(Z){super((0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,x)=>{if("boolean"===typeof Z&&"boolean"===typeof x)return Z||x;if("number"===typeof Z&&"number"===typeof x)return Z|x;if("object"===typeof Z&&"object"===typeof x)return new c.d(Z.value|x.value);throw new Error(`Cannot perform bitwise OR on ${Z} and ${x}`)}),"FlowGraphBitwiseOrBlock",Z)}}(0,u.g)("FlowGraphBitwiseOrBlock",KZ);class yZ extends f.c{constructor(Z){super((0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),(0,G.Q)((null===Z||void 0===Z?void 0:Z.valueType)||"FlowGraphInteger"),((Z,x)=>{if("boolean"===typeof Z&&"boolean"===typeof x)return Z!==x;if("number"===typeof Z&&"number"===typeof x)return Z^x;if("object"===typeof Z&&"object"===typeof x)return new c.d(Z.value^x.value);throw new Error(`Cannot perform bitwise XOR on ${Z} and ${x}`)}),"FlowGraphBitwiseXorBlock",Z)}}(0,u.g)("FlowGraphBitwiseXorBlock",yZ);class qZ extends f.c{constructor(Z){super(G.g,G.g,G.g,((Z,x)=>new c.d(Z.value<<x.value)),"FlowGraphBitwiseLeftShiftBlock",Z)}}(0,u.g)("FlowGraphBitwiseLeftShiftBlock",qZ);class RZ extends f.c{constructor(Z){super(G.g,G.g,G.g,((Z,x)=>new c.d(Z.value>>x.value)),"FlowGraphBitwiseRightShiftBlock",Z)}}(0,u.g)("FlowGraphBitwiseRightShiftBlock",RZ);class BZ extends t.d{constructor(Z){super(G.g,G.g,(Z=>new c.d(Math.clz32(Z.value))),"FlowGraphLeadingZerosBlock",Z)}}(0,u.g)("FlowGraphLeadingZerosBlock",BZ);class vZ extends t.d{constructor(Z){super(G.g,G.g,(Z=>new c.d(Z.value?31-Math.clz32(Z.value&-Z.value):32)),"FlowGraphTrailingZerosBlock",Z)}}(0,u.g)("FlowGraphTrailingZerosBlock",vZ);class lZ extends t.d{constructor(Z){super(G.g,G.g,(Z=>new c.d(function(Z){let x=0;for(;Z;)x+=1&Z,Z>>=1;return x}(Z.value))),"FlowGraphOneBitsCounterBlock",Z)}}(0,u.g)("FlowGraphOneBitsCounterBlock",lZ)},14469:(Z,x,F)=>{F.d(x,{c:()=>G});var u=F(14476);class G extends u.c{constructor(Z,x,F,u,G,f){super(F,f),this._operation=u,this._className=G,this.a=this.registerDataInput("a",Z),this.b=this.registerDataInput("b",x)}_doOperation(Z){const x=this.a.getValue(Z),F=this.b.getValue(Z);return this._operation(x,F)}getClassName(){return this._className}}},14476:(Z,x,F)=>{F.d(x,{c:()=>j});var u=F(12977),G=F(12954);const f="cachedOperationValue",Y="cachedExecutionId";class j extends u.e{constructor(Z,x){super(x),this.value=this.registerDataOutput("value",Z),this.isValid=this.registerDataOutput("isValid",G.f)}_updateOutputs(Z){const x=Z._getExecutionVariable(this,Y,-1),F=Z._getExecutionVariable(this,f,null);if(void 0!==F&&null!==F&&x===Z.executionId)this.isValid.setValue(!0,Z),this.value.setValue(F,Z);else try{const x=this._doOperation(Z);if(void 0===x||null===x)return void this.isValid.setValue(!1,Z);Z._setExecutionVariable(this,f,x),Z._setExecutionVariable(this,Y,Z.executionId),this.value.setValue(x,Z),this.isValid.setValue(!0,Z)}catch(u){this.isValid.setValue(!1,Z)}}}},14478:(Z,x,F)=>{F.d(x,{d:()=>G});var u=F(14476);class G extends u.c{constructor(Z,x,F,u,G){super(x,G),this._operation=F,this._className=u,this.a=this.registerDataInput("a",Z)}_doOperation(Z){return this._operation(this.a.getValue(Z))}getClassName(){return this._className}}}}]);