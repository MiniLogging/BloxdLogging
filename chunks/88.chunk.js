"use strict";(self.yg1iw12lizp=self.yg1iw12lizp||[]).push([[88],{15869:(L,U,x)=>{x.r(U),x.d(U,{FlowGraphAbsBlock:()=>d,FlowGraphAcosBlock:()=>GL,FlowGraphAcoshBlock:()=>bL,FlowGraphAddBlock:()=>Y,FlowGraphAsinBlock:()=>pL,FlowGraphAsinhBlock:()=>hL,FlowGraphAtan2Block:()=>aL,FlowGraphAtanBlock:()=>FL,FlowGraphAtanhBlock:()=>EL,FlowGraphBitwiseAndBlock:()=>DL,FlowGraphBitwiseLeftShiftBlock:()=>KL,FlowGraphBitwiseNotBlock:()=>vL,FlowGraphBitwiseOrBlock:()=>PL,FlowGraphBitwiseRightShiftBlock:()=>lL,FlowGraphBitwiseXorBlock:()=>dL,FlowGraphCeilBlock:()=>X,FlowGraphClampBlock:()=>M,FlowGraphCosBlock:()=>xL,FlowGraphCoshBlock:()=>AL,FlowGraphCubeRootBlock:()=>qL,FlowGraphDegToRadBlock:()=>O,FlowGraphDivideBlock:()=>H,FlowGraphEBlock:()=>q,FlowGraphEqualityBlock:()=>W,FlowGraphExpBlock:()=>YL,FlowGraphFloorBlock:()=>i,FlowGraphFractionBlock:()=>y,FlowGraphGreaterThanBlock:()=>s,FlowGraphGreaterThanOrEqualBlock:()=>C,FlowGraphInfBlock:()=>v,FlowGraphIsInfinityBlock:()=>T,FlowGraphIsNanBlock:()=>k,FlowGraphLeadingZerosBlock:()=>iL,FlowGraphLessThanBlock:()=>w,FlowGraphLessThanOrEqualBlock:()=>B,FlowGraphLog10Block:()=>HL,FlowGraphLog2Block:()=>VL,FlowGraphLogBlock:()=>SL,FlowGraphMathInterpolationBlock:()=>c,FlowGraphMaxBlock:()=>Z,FlowGraphMinBlock:()=>u,FlowGraphModuloBlock:()=>e,FlowGraphMultiplyBlock:()=>V,FlowGraphNaNBlock:()=>D,FlowGraphNegationBlock:()=>n,FlowGraphOneBitsCounterBlock:()=>tL,FlowGraphPiBlock:()=>f,FlowGraphPowerBlock:()=>fL,FlowGraphRadToDegBlock:()=>LL,FlowGraphRandomBlock:()=>Q,FlowGraphRoundBlock:()=>t,FlowGraphSaturateBlock:()=>j,FlowGraphSignBlock:()=>K,FlowGraphSinBlock:()=>UL,FlowGraphSinhBlock:()=>oL,FlowGraphSquareRootBlock:()=>QL,FlowGraphSubtractBlock:()=>S,FlowGraphTanBlock:()=>mU,FlowGraphTanhBlock:()=>rL,FlowGraphTrailingZerosBlock:()=>XL,FlowGraphTruncBlock:()=>l});var mL=x(12547),p=x(14348),G=x(15874),F=x(15876);class a extends F.e{constructor(L,U,x,mL){super(L,mL),this._operation=U,this._className=x}_doOperation(L){return this._operation(L)}getClassName(){return this._className}}var o=x(12589),A=x(15881);class r extends F.e{constructor(L,U,x,mL,p,G,F){super(mL,F),this._operation=p,this._className=G,this.a=this.registerDataInput("a",L),this.b=this.registerDataInput("b",U),this.c=this.registerDataInput("c",x)}_doOperation(L){return this._operation(this.a.getValue(L),this.b.getValue(L),this.c.getValue(L))}getClassName(){return this._className}}var h=x(14343),b=x(14351),E=x(14379);class Y extends G.c{constructor(L){super((0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),((L,U)=>this._polymorphicAdd(L,U)),"FlowGraphAddBlock",L)}_polymorphicAdd(L,U){const x=(0,E.l)(L),mL=(0,E.l)(U);if((0,E.j)(x,mL)||(0,E.f)(x,mL)||(0,E.e)(x,mL))return L.add(U);if("Quaternion"===x||"Vector4"===mL)return new o.Vector4(L.x,L.y,L.z,L.w).addInPlace(U);if("Vector4"===x||"Quaternion"===mL)return L.add(U);var p;if(null!==(p=this.config)&&void 0!==p&&p.preventIntegerFloatArithmetic&&typeof L!==typeof U)throw new Error("Cannot add different types of numbers.");return(0,E.s)(L)+(0,E.s)(U)}}(0,mL.d)("FlowGraphAddBlock",Y);class S extends G.c{constructor(L){super((0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),((L,U)=>this._polymorphicSubtract(L,U)),"FlowGraphSubtractBlock",L)}_polymorphicSubtract(L,U){const x=(0,E.l)(L),mL=(0,E.l)(U);if((0,E.j)(x,mL)||(0,E.e)(x,mL)||(0,E.f)(x,mL))return L.SU(U);if("Quaternion"===x||"Vector4"===mL)return new o.Vector4(L.x,L.y,L.z,L.w).dh(U);if("Vector4"===x||"Quaternion"===mL)return L.SU(U);var p;if(null!==(p=this.config)&&void 0!==p&&p.preventIntegerFloatArithmetic&&typeof L!==typeof U)throw new Error("Cannot add different types of numbers.");return(0,E.s)(L)-(0,E.s)(U)}}(0,mL.d)("FlowGraphSubtractBlock",S);class V extends G.c{constructor(L){super((0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),((L,U)=>this._polymorphicMultiply(L,U)),"FlowGraphMultiplyBlock",L)}_polymorphicMultiply(L,U){const x=(0,E.l)(L),mL=(0,E.l)(U);if((0,E.j)(x,mL)||(0,E.e)(x,mL))return L.multiply(U);if("Quaternion"===x||"Vector4"===mL)return new o.Vector4(L.x,L.y,L.z,L.w).multiplyInPlace(U);if("Vector4"===x||"Quaternion"===mL)return L.multiply(U);if((0,E.f)(x,mL)){var p;if(null!==(p=this.config)&&void 0!==p&&p.useMatrixPerComponent){const mL=L.m;for(let L=0;L<mL.length;L++)mL[L]*=U.m[L];return"Matrix2D"===x?new b.e(mL):"Matrix3D"===x?new b.f(mL):o.Matrix.qU(mL)}return U.multiply(L)}var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof L!==typeof U)throw new Error("Cannot add different types of numbers.");return(0,E.s)(L)*(0,E.s)(U)}}(0,mL.d)("FlowGraphMultiplyBlock",V);class H extends G.c{constructor(L){super((0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),(0,p.I)(null===L||void 0===L?void 0:L.type),((L,U)=>this._polymorphicDivide(L,U)),"FlowGraphDivideBlock",L)}_polymorphicDivide(L,U){const x=(0,E.l)(L),mL=(0,E.l)(U);if((0,E.j)(x,mL)||(0,E.e)(x,mL))return L.divide(U);if("Quaternion"===x||"Quaternion"===mL){const x=L.clone();return x.x/=U.x,x.y/=U.y,x.z/=U.z,x.w/=U.w,x}if("Quaternion"===x||"Vector4"===mL)return new o.Vector4(L.x,L.y,L.z,L.w).divideInPlace(U);if("Vector4"===x||"Quaternion"===mL)return L.divide(U);if((0,E.f)(x,mL)){var p;if(null!==(p=this.config)&&void 0!==p&&p.useMatrixPerComponent){const mL=L.m;for(let L=0;L<mL.length;L++)mL[L]/=U.m[L];return"Matrix2D"===x?new b.e(mL):"Matrix3D"===x?new b.f(mL):o.Matrix.qU(mL)}return L.divide(U)}var G;if(null!==(G=this.config)&&void 0!==G&&G.preventIntegerFloatArithmetic&&typeof L!==typeof U)throw new Error("Cannot add different types of numbers.");return(0,E.s)(L)/(0,E.s)(U)}}(0,mL.d)("FlowGraphDivideBlock",H);class Q extends a{constructor(L){super(p.u,(L=>this._random(L)),"FlowGraphRandomBlock",L),this.min=this.registerDataInput("min",p.u,(null===L||void 0===L?void 0:L.min)??0),this.max=this.registerDataInput("max",p.u,(null===L||void 0===L?void 0:L.max)??1),null!==L&&void 0!==L&&L.seed&&(this._seed=L.seed)}_isSeed(){return void 0!==(arguments.length>0&&void 0!==arguments[0]?arguments[0]:this._seed)}_getRandomValue(){if(this._isSeed(this._seed)){const L=1e4*Math.sin(this._seed++);return L-Math.floor(L)}return Math.random()}_random(L){const U=this.min.getValue(L),x=this.max.getValue(L);return this._getRandomValue()*(x-U)+U}}(0,mL.d)("FlowGraphRandomBlock",Q);class q extends a{constructor(L){super(p.u,(()=>Math.E),"FlowGraphEBlock",L)}}(0,mL.d)("FlowGraphEBlock",q);class f extends a{constructor(L){super(p.u,(()=>Math.PI),"FlowGraphPIBlock",L)}}(0,mL.d)("FlowGraphPIBlock",f);class v extends a{constructor(L){super(p.u,(()=>Number.POSITIVE_INFINITY),"FlowGraphInfBlock",L)}}(0,mL.d)("FlowGraphInfBlock",v);class D extends a{constructor(L){super(p.u,(()=>Number.NaN),"FlowGraphNaNBlock",L)}}function P(L,U){switch((0,E.l)(L)){case"FlowGraphInteger":return new h.b(U(L.value));case"Vector2":return new o.Vector2(U(L.x),U(L.y));case"YU":return new o.YU(U(L.x),U(L.y),U(L.z));case"Vector4":return new o.Vector4(U(L.x),U(L.y),U(L.z),U(L.w));case"Quaternion":return new o.Quaternion(U(L.x),U(L.y),U(L.z),U(L.w));case"Matrix":return o.Matrix.qU(L.m.map(U));case"Matrix2D":return new b.e(L.m.map(U));case"Matrix3D":return new b.f(L.m.map(U));default:return U(L)}}(0,mL.d)("FlowGraphNaNBlock",D);class d extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicAbs(L)),"FlowGraphAbsBlock",L)}_polymorphicAbs(L){return P(L,Math.abs)}}(0,mL.d)("FlowGraphAbsBlock",d);class K extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicSign(L)),"FlowGraphSignBlock",L)}_polymorphicSign(L){return P(L,Math.sign)}}(0,mL.d)("FlowGraphSignBlock",K);class l extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicTrunc(L)),"FlowGraphTruncBlock",L)}_polymorphicTrunc(L){return P(L,Math.trunc)}}(0,mL.d)("FlowGraphTruncBlock",l);class i extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicFloor(L)),"FlowGraphFloorBlock",L)}_polymorphicFloor(L){return P(L,Math.floor)}}(0,mL.d)("FlowGraphFloorBlock",i);class X extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicCeiling(L)),"FlowGraphCeilBlock",L)}_polymorphicCeiling(L){return P(L,Math.ceil)}}(0,mL.d)("FlowGraphCeilBlock",X);class t extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicRound(L)),"FlowGraphRoundBlock",L)}_polymorphicRound(L){return P(L,(L=>{var U;return L<0&&null!==(U=this.config)&&void 0!==U&&U.roundHalfAwayFromZero?-Math.round(-L):Math.round(L)}))}}(0,mL.d)("FlowGraphRoundBlock",t);class y extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicFraction(L)),"FlowGraphFractBlock",L)}_polymorphicFraction(L){return P(L,(L=>L-Math.floor(L)))}}(0,mL.d)("FlowGraphFractBlock",y);class n extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicNeg(L)),"FlowGraphNegationBlock",L)}_polymorphicNeg(L){return P(L,(L=>-L))}}function N(L,U,x){switch((0,E.l)(L)){case"FlowGraphInteger":return new h.b(x(L.value,U.value));case"Vector2":return new o.Vector2(x(L.x,U.x),x(L.y,U.y));case"YU":return new o.YU(x(L.x,U.x),x(L.y,U.y),x(L.z,U.z));case"Vector4":return new o.Vector4(x(L.x,U.x),x(L.y,U.y),x(L.z,U.z),x(L.w,U.w));case"Quaternion":return new o.Quaternion(x(L.x,U.x),x(L.y,U.y),x(L.z,U.z),x(L.w,U.w));case"Matrix":return o.Matrix.qU(L.m.map(((L,mL)=>x(L,U.m[mL]))));case"Matrix2D":return new b.e(L.m.map(((L,mL)=>x(L,U.m[mL]))));case"Matrix3D":return new b.f(L.m.map(((L,mL)=>x(L,U.m[mL]))));default:return x((0,E.s)(L),(0,E.s)(U))}}(0,mL.d)("FlowGraphNegationBlock",n);class e extends G.c{constructor(L){super(p.c,p.c,p.c,((L,U)=>this._polymorphicRemainder(L,U)),"FlowGraphModuloBlock",L)}_polymorphicRemainder(L,U){return N(L,U,((L,U)=>L%U))}}(0,mL.d)("FlowGraphModuloBlock",e);class u extends G.c{constructor(L){super(p.c,p.c,p.c,((L,U)=>this._polymorphicMin(L,U)),"FlowGraphMinBlock",L)}_polymorphicMin(L,U){return N(L,U,Math.min)}}(0,mL.d)("FlowGraphMinBlock",u);class Z extends G.c{constructor(L){super(p.c,p.c,p.c,((L,U)=>this._polymorphicMax(L,U)),"FlowGraphMaxBlock",L)}_polymorphicMax(L,U){return N(L,U,Math.max)}}function g(L,U,x){return Math.min(Math.max(L,Math.min(U,x)),Math.max(U,x))}function z(L,U,x,mL){switch((0,E.l)(L)){case"FlowGraphInteger":return new h.b(mL(L.value,U.value,x.value));case"Vector2":return new o.Vector2(mL(L.x,U.x,x.x),mL(L.y,U.y,x.y));case"YU":return new o.YU(mL(L.x,U.x,x.x),mL(L.y,U.y,x.y),mL(L.z,U.z,x.z));case"Vector4":return new o.Vector4(mL(L.x,U.x,x.x),mL(L.y,U.y,x.y),mL(L.z,U.z,x.z),mL(L.w,U.w,x.w));case"Quaternion":return new o.Quaternion(mL(L.x,U.x,x.x),mL(L.y,U.y,x.y),mL(L.z,U.z,x.z),mL(L.w,U.w,x.w));case"Matrix":return o.Matrix.qU(L.m.map(((L,p)=>mL(L,U.m[p],x.m[p]))));case"Matrix2D":return new b.e(L.m.map(((L,p)=>mL(L,U.m[p],x.m[p]))));case"Matrix3D":return new b.f(L.m.map(((L,p)=>mL(L,U.m[p],x.m[p]))));default:return mL((0,E.s)(L),(0,E.s)(U),(0,E.s)(x))}}(0,mL.d)("FlowGraphMaxBlock",Z);class M extends r{constructor(L){super(p.c,p.c,p.c,p.c,((L,U,x)=>this._polymorphicClamp(L,U,x)),"FlowGraphClampBlock",L)}_polymorphicClamp(L,U,x){return z(L,U,x,g)}}function J(L){return Math.min(Math.max(L,0),1)}(0,mL.d)("FlowGraphClampBlock",M);class j extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicSaturate(L)),"FlowGraphSaturateBlock",L)}_polymorphicSaturate(L){return P(L,J)}}function R(L,U,x){return(1-x)*L+x*U}(0,mL.d)("FlowGraphSaturateBlock",j);class c extends r{constructor(L){super(p.c,p.c,p.c,p.c,((L,U,x)=>this._polymorphicInterpolate(L,U,x)),"FlowGraphMathInterpolationBlock",L)}_polymorphicInterpolate(L,U,x){return z(L,U,x,R)}}(0,mL.d)("FlowGraphMathInterpolationBlock",c);class W extends G.c{constructor(L){super(p.c,p.c,p.e,((L,U)=>this._polymorphicEq(L,U)),"FlowGraphEqualityBlock",L)}_polymorphicEq(L,U){const x=(0,E.l)(L),mL=(0,E.l)(U);return typeof L===typeof U&&((0,E.j)(x,mL)||(0,E.f)(x,mL)||(0,E.e)(x,mL)?L.equals(U):L===U)}}function I(L,U,x){if((0,E.u)(L)&&(0,E.u)(U))return x((0,E.s)(L),(0,E.s)(U));throw new Error(`Cannot compare ${L} and ${U}`)}(0,mL.d)("FlowGraphEqualityBlock",W);class w extends G.c{constructor(L){super(p.c,p.c,p.e,((L,U)=>this._polymorphicLessThan(L,U)),"FlowGraphLessThanBlock",L)}_polymorphicLessThan(L,U){return I(L,U,((L,U)=>L<U))}}(0,mL.d)("FlowGraphLessThanBlock",w);class B extends G.c{constructor(L){super(p.c,p.c,p.e,((L,U)=>this._polymorphicLessThanOrEqual(L,U)),"FlowGraphLessThanOrEqualBlock",L)}_polymorphicLessThanOrEqual(L,U){return I(L,U,((L,U)=>L<=U))}}(0,mL.d)("FlowGraphLessThanOrEqualBlock",B);class s extends G.c{constructor(L){super(p.c,p.c,p.e,((L,U)=>this._polymorphicGreaterThan(L,U)),"FlowGraphGreaterThanBlock",L)}_polymorphicGreaterThan(L,U){return I(L,U,((L,U)=>L>U))}}(0,mL.d)("FlowGraphGreaterThanBlock",s);class C extends G.c{constructor(L){super(p.c,p.c,p.e,((L,U)=>this._polymorphicGreaterThanOrEqual(L,U)),"FlowGraphGreaterThanOrEqualBlock",L)}_polymorphicGreaterThanOrEqual(L,U){return I(L,U,((L,U)=>L>=U))}}(0,mL.d)("FlowGraphGreaterThanOrEqualBlock",C);class k extends A.d{constructor(L){super(p.c,p.e,(L=>this._polymorphicIsNan(L)),"FlowGraphIsNaNBlock",L)}_polymorphicIsNan(L){if((0,E.u)(L,!0))return isNaN((0,E.s)(L));throw new Error(`Cannot get NaN of ${L}`)}}(0,mL.d)("FlowGraphIsNaNBlock",k);class T extends A.d{constructor(L){super(p.c,p.e,(L=>this._polymorphicIsInf(L)),"FlowGraphIsInfBlock",L)}_polymorphicIsInf(L){if((0,E.u)(L))return!isFinite((0,E.s)(L));throw new Error(`Cannot get isInf of ${L}`)}}(0,mL.d)("FlowGraphIsInfBlock",T);class O extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicDegToRad(L)),"FlowGraphDegToRadBlock",L)}_degToRad(L){return L*Math.PI/180}_polymorphicDegToRad(L){return P(L,this._degToRad)}}(0,mL.d)("FlowGraphDegToRadBlock",O);class LL extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicRadToDeg(L)),"FlowGraphRadToDegBlock",L)}_radToDeg(L){return 180*L/Math.PI}_polymorphicRadToDeg(L){return P(L,this._radToDeg)}}(0,mL.d)("FlowGraphRadToDegBlock",LL);class UL extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicSin(L)),"FlowGraphSinBlock",L)}_polymorphicSin(L){return P(L,Math.sin)}}class xL extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicCos(L)),"FlowGraphCosBlock",L)}_polymorphicCos(L){return P(L,Math.cos)}}class mU extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicTan(L)),"FlowGraphTanBlock",L)}_polymorphicTan(L){return P(L,Math.tan)}}class pL extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicAsin(L)),"FlowGraphASinBlock",L)}_polymorphicAsin(L){return P(L,Math.asin)}}(0,mL.d)("FlowGraphASinBlock",pL);class GL extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicAcos(L)),"FlowGraphACosBlock",L)}_polymorphicAcos(L){return P(L,Math.acos)}}(0,mL.d)("FlowGraphACosBlock",GL);class FL extends A.d{constructor(L){super(p.u,p.u,(L=>this._polymorphicAtan(L)),"FlowGraphATanBlock",L)}_polymorphicAtan(L){return P(L,Math.atan)}}(0,mL.d)("FlowGraphATanBlock",FL);class aL extends G.c{constructor(L){super(p.c,p.c,p.c,((L,U)=>this._polymorphicAtan2(L,U)),"FlowGraphATan2Block",L)}_polymorphicAtan2(L,U){return N(L,U,Math.atan2)}}(0,mL.d)("FlowGraphATan2Block",aL);class oL extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicSinh(L)),"FlowGraphSinhBlock",L)}_polymorphicSinh(L){return P(L,Math.sinh)}}(0,mL.d)("FlowGraphSinhBlock",oL);class AL extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicCosh(L)),"FlowGraphCoshBlock",L)}_polymorphicCosh(L){return P(L,Math.cosh)}}(0,mL.d)("FlowGraphCoshBlock",AL);class rL extends A.d{constructor(L){super(p.c,p.c,(L=>this._polymorphicTanh(L)),"FlowGraphTanhBlock",L)}_polymorphicTanh(L){return P(L,Math.tanh)}}(0,mL.d)("FlowGraphTanhBlock",rL);class hL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicAsinh(L)),"FlowGraphASinhBlock",L)}_polymorphicAsinh(L){return P(L,Math.asinh)}}(0,mL.d)("FlowGraphASinhBlock",hL);class bL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicAcosh(L)),"FlowGraphACoshBlock",L)}_polymorphicAcosh(L){return P(L,Math.acosh)}}(0,mL.d)("FlowGraphACoshBlock",bL);class EL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicAtanh(L)),"FlowGraphATanhBlock",L)}_polymorphicAtanh(L){return P(L,Math.atanh)}}(0,mL.d)("FlowGraphATanhBlock",EL);class YL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicExp(L)),"FlowGraphExponentialBlock",L)}_polymorphicExp(L){return P(L,Math.exp)}}(0,mL.d)("FlowGraphExponentialBlock",YL);class SL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicLog(L)),"FlowGraphLogBlock",L)}_polymorphicLog(L){return P(L,Math.log)}}(0,mL.d)("FlowGraphLogBlock",SL);class VL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicLog2(L)),"FlowGraphLog2Block",L)}_polymorphicLog2(L){return P(L,Math.log2)}}(0,mL.d)("FlowGraphLog2Block",VL);class HL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicLog10(L)),"FlowGraphLog10Block",L)}_polymorphicLog10(L){return P(L,Math.log10)}}(0,mL.d)("FlowGraphLog10Block",HL);class QL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicSqrt(L)),"FlowGraphSquareRootBlock",L)}_polymorphicSqrt(L){return P(L,Math.sqrt)}}(0,mL.d)("FlowGraphSquareRootBlock",QL);class qL extends A.d{constructor(L){super(p.c,p.u,(L=>this._polymorphicCubeRoot(L)),"FlowGraphCubeRootBlock",L)}_polymorphicCubeRoot(L){return P(L,Math.cbrt)}}(0,mL.d)("FlowGraphCubeRootBlock",qL);class fL extends G.c{constructor(L){super(p.c,p.u,p.u,((L,U)=>this._polymorphicPow(L,U)),"FlowGraphPowerBlock",L)}_polymorphicPow(L,U){return N(L,U,Math.pow)}}(0,mL.d)("FlowGraphPowerBlock",fL);class vL extends A.d{constructor(L){super((0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(L=>"boolean"===typeof L?!L:"number"===typeof L?~L:new h.b(~L.value)),"FlowGraphBitwiseNotBlock",L)}}(0,mL.d)("FlowGraphBitwiseNotBlock",vL);class DL extends G.c{constructor(L){super((0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),((L,U)=>{if("boolean"===typeof L&&"boolean"===typeof U)return L&&U;if("number"===typeof L&&"number"===typeof U)return L&U;if("object"===typeof L&&"object"===typeof U)return new h.b(L.value&U.value);throw new Error(`Cannot perform bitwise AND on ${L} and ${U}`)}),"FlowGraphBitwiseAndBlock",L)}}(0,mL.d)("FlowGraphBitwiseAndBlock",DL);class PL extends G.c{constructor(L){super((0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),((L,U)=>{if("boolean"===typeof L&&"boolean"===typeof U)return L||U;if("number"===typeof L&&"number"===typeof U)return L|U;if("object"===typeof L&&"object"===typeof U)return new h.b(L.value|U.value);throw new Error(`Cannot perform bitwise OR on ${L} and ${U}`)}),"FlowGraphBitwiseOrBlock",L)}}(0,mL.d)("FlowGraphBitwiseOrBlock",PL);class dL extends G.c{constructor(L){super((0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),(0,p.I)((null===L||void 0===L?void 0:L.valueType)||"FlowGraphInteger"),((L,U)=>{if("boolean"===typeof L&&"boolean"===typeof U)return L!==U;if("number"===typeof L&&"number"===typeof U)return L^U;if("object"===typeof L&&"object"===typeof U)return new h.b(L.value^U.value);throw new Error(`Cannot perform bitwise XOR on ${L} and ${U}`)}),"FlowGraphBitwiseXorBlock",L)}}(0,mL.d)("FlowGraphBitwiseXorBlock",dL);class KL extends G.c{constructor(L){super(p.i,p.i,p.i,((L,U)=>new h.b(L.value<<U.value)),"FlowGraphBitwiseLeftShiftBlock",L)}}(0,mL.d)("FlowGraphBitwiseLeftShiftBlock",KL);class lL extends G.c{constructor(L){super(p.i,p.i,p.i,((L,U)=>new h.b(L.value>>U.value)),"FlowGraphBitwiseRightShiftBlock",L)}}(0,mL.d)("FlowGraphBitwiseRightShiftBlock",lL);class iL extends A.d{constructor(L){super(p.i,p.i,(L=>new h.b(Math.clz32(L.value))),"FlowGraphLeadingZerosBlock",L)}}(0,mL.d)("FlowGraphLeadingZerosBlock",iL);class XL extends A.d{constructor(L){super(p.i,p.i,(L=>new h.b(L.value?31-Math.clz32(L.value&-L.value):32)),"FlowGraphTrailingZerosBlock",L)}}(0,mL.d)("FlowGraphTrailingZerosBlock",XL);class tL extends A.d{constructor(L){super(p.i,p.i,(L=>new h.b(function(L){let U=0;for(;L;)U+=1&L,L>>=1;return U}(L.value))),"FlowGraphOneBitsCounterBlock",L)}}(0,mL.d)("FlowGraphOneBitsCounterBlock",tL)},15874:(L,U,x)=>{x.d(U,{c:()=>p});var mL=x(15876);class p extends mL.e{constructor(L,U,x,mL,p,G){super(x,G),this._operation=mL,this._className=p,this.a=this.registerDataInput("a",L),this.b=this.registerDataInput("b",U)}_doOperation(L){const U=this.a.getValue(L),x=this.b.getValue(L);return this._operation(U,x)}getClassName(){return this._className}}},15876:(L,U,x)=>{x.d(U,{e:()=>a});var mL=x(14371),p=x(14348);const G="cachedOperationValue",F="cachedExecutionId";class a extends mL.e{constructor(L,U){super(U),this.value=this.registerDataOutput("value",L),this.isValid=this.registerDataOutput("isValid",p.e)}_updateOutputs(L){const U=L._getExecutionVariable(this,F,-1),x=L._getExecutionVariable(this,G,null);if(void 0!==x&&null!==x&&U===L.executionId)this.isValid.setValue(!0,L),this.value.setValue(x,L);else try{const U=this._doOperation(L);if(void 0===U||null===U)return void this.isValid.setValue(!1,L);L._setExecutionVariable(this,G,U),L._setExecutionVariable(this,F,L.executionId),this.value.setValue(U,L),this.isValid.setValue(!0,L)}catch(mL){this.isValid.setValue(!1,L)}}}},15881:(L,U,x)=>{x.d(U,{d:()=>p});var mL=x(15876);class p extends mL.e{constructor(L,U,x,mL,p){super(U,p),this._operation=x,this._className=mL,this.a=this.registerDataInput("a",L)}_doOperation(L){return this._operation(this.a.getValue(L))}getClassName(){return this._className}}}}]);