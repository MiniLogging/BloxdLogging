"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[88],{14274:(v,d,Q)=>{Q.r(d),Q.d(d,{FlowGraphMultiGateBlock:()=>F});var n=Q(591),T=Q(12929),L=Q(12908),e=Q(12904);class F extends T.b{constructor(v){super(v),this.config=v,this.outputSignals=[],this.reset=this._registerSignalInput("reset"),this.lastIndex=this.registerDataOutput("lastIndex",L.h,new e.b(-1)),this.setNumberOfOutputSignals(null===v||void 0===v?void 0:v.outputSignalCount)}_getNextIndex(v){if(v.includes(!1)||this.config.isLoop&&v.fill(!1),this.config.isRandom){const d=v.map(((v,d)=>v?-1:d)).filter((v=>-1!==v));return d.length?d[Math.floor(Math.random()*d.length)]:-1}return v.indexOf(!1)}setNumberOfOutputSignals(){let v=arguments.length>0&&void 0!==arguments[0]?arguments[0]:1;for(;this.outputSignals.length>v;){const v=this.outputSignals.pop();v&&(v.disconnectFromAll(),this._unregisterSignalOutput(v.name))}for(;this.outputSignals.length<v;)this.outputSignals.push(this._registerSignalOutput(`out_${this.outputSignals.length}`))}_execute(v,d){if(v._hasExecutionVariable(this,"indexesUsed")||v._setExecutionVariable(this,"indexesUsed",this.outputSignals.map((()=>!1))),d===this.reset)return v._deleteExecutionVariable(this,"indexesUsed"),void this.lastIndex.setValue(new e.b(-1),v);const Q=v._getExecutionVariable(this,"indexesUsed",[]),n=this._getNextIndex(Q);n>-1&&(this.lastIndex.setValue(new e.b(n),v),Q[n]=!0,v._setExecutionVariable(this,"indexesUsed",Q),this.outputSignals[n]._activateSignal(v))}getClassName(){return"FlowGraphMultiGateBlock"}serialize(v){super.serialize(v),v.config.outputSignalCount=this.config.outputSignalCount,v.config.isRandom=this.config.isRandom,v.config.loop=this.config.isLoop,v.config.startIndex=this.config.startIndex}}(0,n.f)("FlowGraphMultiGateBlock",F)}}]);