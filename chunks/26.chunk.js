"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11549:(h,V,i)=>{i.r(V),i.d(V,{EXT_materials_diffuse_roughness:()=>kV,EXT_mesh_gpu_instancing:()=>bh,GLTF2Export:()=>Qh,GLTFData:()=>J,KHR_draco_mesh_compression:()=>iV,KHR_lights_punctual:()=>BV,KHR_materials_anisotropy:()=>vV,KHR_materials_clearcoat:()=>tV,KHR_materials_diffuse_transmission:()=>nV,KHR_materials_dispersion:()=>fV,KHR_materials_emissive_strength:()=>LV,KHR_materials_ior:()=>XV,KHR_materials_iridescence:()=>OV,KHR_materials_sheen:()=>MV,KHR_materials_specular:()=>EV,KHR_materials_transmission:()=>jV,KHR_materials_unlit:()=>GV,KHR_materials_volume:()=>NV,KHR_texture_transform:()=>ZV,OBJExport:()=>g,STLExport:()=>zV,USDZExportAsync:()=>Vi,_ConvertToGLTFPBRMetallicRoughness:()=>m,_SolveMetallic:()=>j,__IGLTFExporterExtension:()=>q});var S=i(11138),l=i(10952),Y=i(11459);class g{static OBJ(h,V,i,g){const q=[];let B=1,J=1;V&&(i||(i="mat"),q.push("mtllib "+i+".mtl"));for(let I=0;I<h.length;I++){const i=h[I],v=i.name||`mesh${I}}`;q.push(`o ${v}`);let s=null;if(g){const h=i.Ag(!0);s=new S.Matrix,h.invertToRef(s),i.bakeTransformIntoVertices(h)}if(V){const h=i.material;h&&q.push("usemtl "+h.id)}const t=i.bg;if(!t){l.Tools.Warn("No geometry is present on the mesh");continue}const T=t.getVerticesData("position"),e=t.getVerticesData("normal"),n=t.getVerticesData("uv"),c=t.ug();let f=0,P=0;if(!T||!c){l.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const L=h[0].Mh().useRightHandedSystem?1:-1;for(let h=0;h<T.length;h+=3)q.push("v "+T[h]*L+" "+T[h+1]+" "+T[h+2]),f++;if(null!=e)for(let h=0;h<e.length;h+=3)q.push("vn "+e[h]*L+" "+e[h+1]+" "+e[h+2]);if(null!=n)for(let h=0;h<n.length;h+=2)q.push("vt "+n[h]+" "+n[h+1]),P++;const U=["","",""],X=(i.material||i.Mh().defaultMaterial)._getEffectiveOrientation(i),[D,O]=X===Y.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let h=0;h<c.length;h+=3){const V=[String(c[h]+B),String(c[h+D]+B),String(c[h+O]+B)],i=[String(c[h]+J),String(c[h+D]+J),String(c[h+O]+J)],S=V,l=null!=n?i:U,Y=null!=e?V:U;q.push("f "+S[0]+"/"+l[0]+"/"+Y[0]+" "+S[1]+"/"+l[1]+"/"+Y[1]+" "+S[2]+"/"+l[2]+"/"+Y[2])}g&&s&&i.bakeTransformIntoVertices(s),B+=f,J+=P}return q.join("\n")}static MTL(h){const V=[],i=h.material;V.push("newmtl mat1"),V.push("  Ns "+i.specularPower.toFixed(4)),V.push("  Ni 1.5000"),V.push("  d "+i.alpha.toFixed(4)),V.push("  Tr 0.0000"),V.push("  Tf 1.0000 1.0000 1.0000"),V.push("  illum 2"),V.push("  Ka "+i.ambientColor.r.toFixed(4)+" "+i.ambientColor.g.toFixed(4)+" "+i.ambientColor.b.toFixed(4)),V.push("  Kd "+i.diffuseColor.r.toFixed(4)+" "+i.diffuseColor.g.toFixed(4)+" "+i.diffuseColor.b.toFixed(4)),V.push("  Ks "+i.specularColor.r.toFixed(4)+" "+i.specularColor.g.toFixed(4)+" "+i.specularColor.b.toFixed(4)),V.push("  Ke "+i.emissiveColor.r.toFixed(4)+" "+i.emissiveColor.g.toFixed(4)+" "+i.emissiveColor.b.toFixed(4));i.ambientTexture&&V.push("  map_Ka "+i.ambientTexture.name),i.diffuseTexture&&V.push("  map_Kd "+i.diffuseTexture.name),i.specularTexture&&V.push("  map_Ks "+i.specularTexture.name),i.bumpTexture&&V.push("  map_bump -imfchan z "+i.bumpTexture.name),i.opacityTexture&&V.push("  map_d "+i.opacityTexture.name);return V.join("\n")}}var q=0,B=i(10993);class J{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const h in this.files){const V=this.files[h],i=new Blob([V],{type:(0,B.i)(h)});l.Tools.Download(i,h)}}}var I=i(11220),v=i(11556),s=i(11570),t=i(11586),T=i(11280),e=i(10988),n=i(11189),c=i(11162);const f=c.HighestCommonFactor,P={...c,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:f};var L=i(11371),U=i(11117),X=i(11613),D=i(11620),O=i(11362);const o=1e-6,M=new n.LV(.04,.04,.04),F=1024,E=n.LV.White(),H=n.LV.Black();function j(h,V,i){if(V<M.r)return 0;const S=M.r,l=h*i/(1-M.r)+V-2*M.r,Y=l*l-4*S*(M.r-V);return P.Clamp((-l+Math.sqrt(Y))/(2*S),0,1)}function m(h){const V=h.diffuseColor.toLinearSpace(h.Mh().getEngine().useExactSrgbConversions).scale(.5),i=h.alpha,l=function(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new S.Vector2(0,1),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new S.Vector2(0,.1),l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new S.Vector2(0,.1),Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new S.Vector2(1300,.1);return function(h,V,i,S,l){return(1-h)*(1-h)*(1-h)*V+3*(1-h)*(1-h)*h*i+3*(1-h)*h*h*S+h*h*h*l}(Math.pow(h/Y.x,.333333),V.y,i.y,l.y,Y.y)}(P.Clamp(h.specularPower,0,F));return{baseColorFactor:[V.r,V.g,V.b,i],metallicFactor:0,roughnessFactor:l}}function G(h,V){V.needAlphaBlending()?h.alphaMode="BLEND":V.needAlphaTesting()&&(h.alphaMode="MASK",h.alphaCutoff=V.alphaCutOff)}function w(h,V,i){const S=new Uint8Array(h*V*4);for(let l=0;l<S.length;l+=4)S[l]=S[l+1]=S[l+2]=S[l+3]=255;return X.d.CreateRGBATexture(S,h,V,i)}function N(h){if(h instanceof Uint8Array){const V=h.length,i=new Float32Array(h.length);for(let S=0;S<V;++S)i[S]=h[S]/255;return i}if(h instanceof Float32Array)return h;throw new Error("Unsupported pixel format!")}class r{constructor(h){this._exporter=h,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(h){return h?this._textureMap.get(h)??null:null}async exportStandardMaterialAsync(h,V,i){const S=m(h),Y={name:h.name};if(null==h.Kg||h.Kg||(h.twoSidedLighting||l.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Y.doubleSided=!0),i){const i=[],l=h.diffuseTexture;l&&i.push(this.exportTextureAsync(l,V).then((h=>{h&&(S.baseColorTexture=h)})));const g=h.bumpTexture;g&&i.push(this.exportTextureAsync(g,V).then((h=>{h&&(Y.normalTexture=h,1!==g.level&&(Y.normalTexture.scale=g.level))})));const q=h.emissiveTexture;q&&(Y.emissiveFactor=[1,1,1],i.push(this.exportTextureAsync(q,V).then((h=>{h&&(Y.emissiveTexture=h)}))));const B=h.ambientTexture;B&&i.push(this.exportTextureAsync(B,V).then((h=>{if(h){const V={index:h.index};Y.occlusionTexture=V}}))),i.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(i))}(h.alpha<1||h.opacityTexture)&&(h.alphaMode===D.e.ALPHA_COMBINE?Y.alphaMode="BLEND":l.Tools.Warn(h.name+": glTF 2.0 does not support alpha mode: "+h.alphaMode.toString())),h.emissiveColor&&!h.emissiveColor.equalsWithEpsilon(H,o)&&(Y.emissiveFactor=h.emissiveColor.Ng()),Y.pbrMetallicRoughness=S,G(Y,h),await this._finishMaterialAsync(Y,h,V);const g=this._exporter._materials;return g.push(Y),g.length-1}async _finishMaterialAsync(h,V,i){const S=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",h,V),l=[];for(const Y of S)l.push(this.exportTextureAsync(Y,i));await Promise.all(l),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",h,V)}async _getImageDataAsync(h,V,S,l){const Y=D.e.TEXTURETYPE_UNSIGNED_BYTE,g=this._exporter._babylonScene,q=g.getEngine(),B=q.createRawTexture(h,V,S,D.e.TEXTUREFORMAT_RGBA,!1,!0,U.d.NEAREST_SAMPLINGMODE,null,Y);q.isWebGPU?await i.e(51).then(i.bind(i,13573)):await i.e(52).then(i.bind(i,13576)),await L.k.ApplyPostProcess("pass",B,g,Y,D.e.TEXTURE_NEAREST_SAMPLINGMODE,D.e.TEXTUREFORMAT_RGBA);const J=await q._readTexturePixels(B,V,S);return await O.DumpTools.DumpDataAsync(V,S,J,l,void 0,!0,!0)}_resizeTexturesToSameDimensions(h,V,i){const S=h?h.getSize():{width:0,height:0},l=V?V.getSize():{width:0,height:0};let Y,g;return S.width<l.width?(Y=h&&h instanceof U.d?L.k.CreateResizedCopy(h,l.width,l.height,!0):w(l.width,l.height,i),g=V):S.width>l.width?(g=V&&V instanceof U.d?L.k.CreateResizedCopy(V,S.width,S.height,!0):w(S.width,S.height,i),Y=h):(Y=h,g=V),{texture1:Y,texture2:g}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,V,i,S){const l=new Array;if(!h&&!V)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const Y=h?h.Mh():V?V.Mh():null;if(Y){var g;const q=this._resizeTexturesToSameDimensions(h,V,Y),B=null===(g=q.texture1)||void 0===g?void 0:g.getSize();let J,I;const v=B.width,s=B.height,t=await q.texture1.readPixels(),T=await q.texture2.readPixels();if(!t)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(J=N(t),!T)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");I=N(T);const e=I.byteLength,c=new Uint8Array(e),f=new Uint8Array(e),P=4,L=H;let U=0,X=0;for(let h=0;h<s;++h)for(let V=0;V<v;++V){const S=(v*h+V)*P,l={diffuseColor:new n.LV(J[S],J[S+1],J[S+2]).toLinearSpace(Y.getEngine().useExactSrgbConversions).multiply(i.diffuseColor),specularColor:new n.LV(I[S],I[S+1],I[S+2]).toLinearSpace(Y.getEngine().useExactSrgbConversions).multiply(i.specularColor),glossiness:I[S+3]*i.glossiness},g=this._convertSpecularGlossinessToMetallicRoughness(l);L.r=Math.max(L.r,g.baseColor.r),L.g=Math.max(L.g,g.baseColor.g),L.b=Math.max(L.b,g.baseColor.b),U=Math.max(U,g.metallic),X=Math.max(X,g.roughness),f[S]=255*g.baseColor.r,f[S+1]=255*g.baseColor.g,f[S+2]=255*g.baseColor.b,f[S+3]=q.texture1.Rg?255*J[S+3]:255,c[S]=0,c[S+1]=255*g.roughness,c[S+2]=255*g.metallic,c[S+3]=255}const D={baseColor:L,metallic:U,roughness:X};let O=!1,M=!1;for(let h=0;h<s;++h)for(let V=0;V<v;++V){const i=(v*h+V)*P;f[i]/=D.baseColor.r>o?D.baseColor.r:1,f[i+1]/=D.baseColor.g>o?D.baseColor.g:1,f[i+2]/=D.baseColor.b>o?D.baseColor.b:1;const S=n.LV.FromInts(f[i],f[i+1],f[i+2]).toGammaSpace(Y.getEngine().useExactSrgbConversions);f[i]=255*S.r,f[i+1]=255*S.g,f[i+2]=255*S.b,S.equalsWithEpsilon(E,o)||(M=!0),c[i+1]/=D.roughness>o?D.roughness:1,c[i+2]/=D.metallic>o?D.metallic:1;n.LV.FromInts(255,c[i+1],c[i+2]).equalsWithEpsilon(E,o)||(O=!0)}return O&&l.push(this._getImageDataAsync(c,v,s,S).then((h=>{D.metallicRoughnessTextureData=h}))),M&&l.push(this._getImageDataAsync(f,v,s,S).then((h=>{D.baseColorTextureData=h}))),await Promise.all(l).then((()=>D))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(h){const V=this._getPerceivedBrightness(h.diffuseColor),i=this._getPerceivedBrightness(h.specularColor),S=1-this._getMaxComponent(h.specularColor),l=j(V,i,S),Y=h.diffuseColor.scale(S/(1-M.r)/Math.max(1-l)),g=h.specularColor.cV(M.scale(1-l)).scale(1/Math.max(l));let q=n.LV.Lerp(Y,g,l*l);q=q.clampToRef(0,1,q);return{baseColor:q,metallic:l,roughness:1-h.glossiness}}_getPerceivedBrightness(h){return h?Math.sqrt(.299*h.r*h.r+.587*h.g*h.g+.114*h.b*h.b):0}_getMaxComponent(h){return h?Math.max(h.r,Math.max(h.g,h.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(h,V,i,S){const l=[],Y={baseColor:h._albedoColor,metallic:h._metallic,roughness:h._roughness};if(S){h._albedoTexture&&l.push(this.exportTextureAsync(h._albedoTexture,V).then((h=>{h&&(i.baseColorTexture=h)})));const S=h._metallicTexture;S&&l.push(this.exportTextureAsync(S,V).then((h=>{h&&(i.metallicRoughnessTexture=h)})))}return l.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(l)),Y}_getTextureSampler(h){const V={};if(!h||!(h instanceof U.d))return V;const i=this._getGLTFTextureWrapMode(h.wrapU);10497!==i&&(V.wrapS=i);const S=this._getGLTFTextureWrapMode(h.wrapV);switch(10497!==S&&(V.wrapT=S),h.samplingMode){case U.d.LINEAR_LINEAR:V.magFilter=9729,V.minFilter=9729;break;case U.d.LINEAR_NEAREST:V.magFilter=9729,V.minFilter=9728;break;case U.d.NEAREST_LINEAR:V.magFilter=9728,V.minFilter=9729;break;case U.d.NEAREST_LINEAR_MIPLINEAR:V.magFilter=9728,V.minFilter=9987;break;case U.d.NEAREST_NEAREST:V.magFilter=9728,V.minFilter=9728;break;case U.d.NEAREST_LINEAR_MIPNEAREST:V.magFilter=9728,V.minFilter=9985;break;case U.d.LINEAR_NEAREST_MIPNEAREST:V.magFilter=9729,V.minFilter=9984;break;case U.d.LINEAR_NEAREST_MIPLINEAR:V.magFilter=9729,V.minFilter=9986;break;case U.d.NEAREST_NEAREST_MIPLINEAR:V.magFilter=9728,V.minFilter=9986;break;case U.d.LINEAR_LINEAR_MIPLINEAR:V.magFilter=9729,V.minFilter=9987;break;case U.d.LINEAR_LINEAR_MIPNEAREST:V.magFilter=9729,V.minFilter=9985;break;case U.d.NEAREST_NEAREST_MIPNEAREST:V.magFilter=9728,V.minFilter=9984}return V}_getGLTFTextureWrapMode(h){switch(h){case U.d.WRAP_ADDRESSMODE:return 10497;case U.d.CLAMP_ADDRESSMODE:return 33071;case U.d.MIRROR_ADDRESSMODE:return 33648;default:return l.Tools.Error(`Unsupported Texture Wrap Mode ${h}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(h,V,i,S){const l={diffuseColor:h._albedoColor,specularColor:h._reflectivityColor,glossiness:h._microSurface},Y=h._albedoTexture,g=h._reflectivityTexture,q=h._useMicroSurfaceFromReflectivityMapAlpha;if(g&&!q)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((Y||g)&&S){this._exporter._materialNeedsUVsSet.add(h);const S=this._exportTextureSampler(Y||g),q=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Y,g,l,V),B=this._exporter._textures;if(q.baseColorTextureData){const h=this._exportImage(`baseColor${B.length}`,V,q.baseColorTextureData);i.baseColorTexture=this._exportTextureInfo(h,S,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}if(q.metallicRoughnessTextureData){const h=this._exportImage(`metallicRoughness${B.length}`,V,q.metallicRoughnessTextureData);i.metallicRoughnessTexture=this._exportTextureInfo(h,S,null===g||void 0===g?void 0:g.coordinatesIndex)}return q}return this._convertSpecularGlossinessToMetallicRoughness(l)}async exportPBRMaterialAsync(h,V,i){const S={},l={name:h.name},Y=h.isMetallicWorkflow();if(Y){const V=h._albedoColor,i=h.alpha;V&&(S.baseColorFactor=[V.r,V.g,V.b,i])}const g=Y?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(h,V,S,i):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(h,V,S,i);await this._setMetallicRoughnessPbrMaterialAsync(g,h,l,S,V,i),await this._finishMaterialAsync(l,h,V);const q=this._exporter._materials;return q.push(l),q.length-1}async _setMetallicRoughnessPbrMaterialAsync(h,V,i,S,Y,g){if(G(i,V),h.baseColor.equalsWithEpsilon(E,o)&&P.WithinEpsilon(V.alpha,1,o)||(S.baseColorFactor=[h.baseColor.r,h.baseColor.g,h.baseColor.b,V.alpha]),null!=h.metallic&&1!==h.metallic&&(S.metallicFactor=h.metallic),null!=h.roughness&&1!==h.roughness&&(S.roughnessFactor=h.roughness),null==V.Kg||V.Kg||(V._twoSidedLighting||l.Tools.Warn(V.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),g){const h=[],S=V._bumpTexture;S&&h.push(this.exportTextureAsync(S,Y).then((h=>{h&&(i.normalTexture=h,1!==S.level&&(i.normalTexture.scale=S.level))})));const l=V._ambientTexture;l&&h.push(this.exportTextureAsync(l,Y).then((h=>{if(h){const S={index:h.index,texCoord:h.texCoord,extensions:h.extensions};i.occlusionTexture=S;const l=V._ambientTextureStrength;l&&(S.strength=l)}})));const g=V._emissiveTexture;g&&h.push(this.exportTextureAsync(g,Y).then((h=>{h&&(i.emissiveTexture=h)}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(V),await Promise.all(h))}const q=V._emissiveColor;q.equalsWithEpsilon(H,o)||(i.emissiveFactor=q.Ng()),i.pbrMetallicRoughness=S}_getPixelsFromTextureAsync(h){return function(h){switch(h){case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case D.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case D.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case D.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case D.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(h.textureFormat)?(0,L.h)(h,h._texture.width,h._texture.height):(h.textureType,D.e.TEXTURETYPE_UNSIGNED_BYTE,h.readPixels())}async exportTextureAsync(h,V){const i=this._exporter._extensionsPreExportTextureAsync("exporter",h,V);return i?await i.then((async i=>i?await this._exportTextureInfoAsync(i,V):await this._exportTextureInfoAsync(h,V))):await this._exportTextureInfoAsync(h,V)}async _exportTextureInfoAsync(h,V){let i=this._textureMap.get(h);if(!i){const S=await this._getPixelsFromTextureAsync(h);if(!S)return null;const Y=this._exportTextureSampler(h),g=h.mimeType;if(g)switch(g){case"image/jpeg":case"image/png":case"image/webp":V=g;break;default:l.Tools.Warn(`Unsupported media type: ${g}. Exporting texture as PNG.`)}const q=this._internalTextureToImage,B=h.getInternalTexture().uniqueId;q[B]||(q[B]={});let J=q[B][V];if(void 0===J){const i=h.getSize();J=(async()=>{const l=await this._getImageDataAsync(S,i.width,i.height,V);return this._exportImage(h.name,V,l)})(),q[B][V]=J}i=this._exportTextureInfo(await J,Y,h.coordinatesIndex),this._textureMap.set(h,i),this._exporter._extensionsPostExportTextures("exporter",i,h)}return i}_exportImage(h,V,i){const S=this._exporter._images;let Y;if(this._exporter._shouldUseGlb){Y={name:h,mimeType:V,bufferView:void 0};const S=this._exporter._bufferManager.createBufferView(new Uint8Array(i));this._exporter._bufferManager.setBufferView(Y,S)}else{const g=h.replace(/\.\/|\/|\.\\|\\/g,"_"),q=function(h){switch(h){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(V);let B=g+q;S.some((h=>h.uri===B))&&(B=`${g}_${l.Tools.RandomId()}${q}`),Y={name:h,uri:B},this._exporter._imageData[B]={data:i,mimeType:V}}return S.push(Y),S.length-1}_exportTextureInfo(h,V,i){const S=this._exporter._textures;let l=S.findIndex((i=>i.sampler==V&&i.source===h));-1===l&&(l=S.length,S.push({source:h,sampler:V}));const Y={index:l};return i&&(Y.texCoord=i),Y}_exportTextureSampler(h){const V=this._getTextureSampler(h),i=this._exporter._samplers,S=i.findIndex((h=>h.minFilter===V.minFilter&&h.magFilter===V.magFilter&&h.wrapS===V.wrapS&&h.wrapT===V.wrapT));return-1!==S?S:(i.push(V),i.length-1)}}var k=i(11230),R=i(10967),Z=i(11623),z=i(11147);const d=S.nV.Zero(),x=S.Quaternion.Identity(),y=S.nV.One(),Q=new S.nV(-1,1,1);function A(h,V){const{byteOffset:i,byteStride:S,type:l,normalized:Y}=h,g=h.getSize(),q=V.reduce(((h,V)=>V.getTotalVertices()>h?V.getTotalVertices():h),-Number.MAX_VALUE);return{byteOffset:i,byteStride:S,componentCount:g,type:l,count:q*g,normalized:Y,totalVertices:q,kind:h.getKind()}}function b(h){switch(h){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function C(h){switch(h){case I.h.PositionKind:case I.h.NormalKind:case I.h.TangentKind:case I.h.ColorKind:case I.h.MatricesIndicesKind:case I.h.MatricesIndicesExtraKind:case I.h.MatricesWeightsKind:case I.h.MatricesWeightsExtraKind:case I.h.UVKind:case I.h.UV2Kind:case I.h.UV3Kind:case I.h.UV4Kind:case I.h.UV5Kind:case I.h.UV6Kind:return!0}return!1}function u(h){switch(h){case Y.e.TriangleFillMode:return 4;case Y.e.TriangleStripDrawMode:return 5;case Y.e.TriangleFanDrawMode:return 6;case Y.e.PointListDrawMode:case Y.e.PointFillMode:return 0;case Y.e.LineLoopDrawMode:return 2;case Y.e.LineListDrawMode:return 1;case Y.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${h}`)}function p(h){const V=Math.sqrt(h.x*h.x+h.y*h.y+h.z*h.z);V>0&&(h.x/=V,h.y/=V,h.z/=V)}function W(h){return h.x*=-1,h}function a(h){if(h.x*h.x+h.y*h.y>.5){const V=Math.abs(h.x),i=Math.abs(h.y);if(V>i){const i=Math.sign(h.x);h.x=V,h.y*=-i,h.z*=-i,h.w*=i}else{const V=Math.sign(h.y);h.x*=-V,h.y=i,h.z*=V,h.w*=-V}}else{const V=Math.abs(h.z),i=Math.abs(h.w);if(V>i){const i=Math.sign(h.z);h.x*=-i,h.y*=i,h.z=V,h.w*=-i}else{const V=Math.sign(h.w);h.x*=V,h.y*=-V,h.z*=-V,h.w=i}}return h}function K(h){h.qq(-h.z,h.w,h.x,-h.y)}function hh(h,V){const i=S.nV.FromArrayToRef(V.translation||[0,0,0],0,S.TmpVectors.nV[0]),l=S.Quaternion.FromArrayToRef(V.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[0]),Y=S.Matrix.ComposeToRef(y,l,i,S.TmpVectors.Matrix[0]),g=S.nV.FromArrayToRef(h.translation||[0,0,0],0,S.TmpVectors.nV[2]),q=S.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[1]),B=S.Matrix.ComposeToRef(y,q,g,S.TmpVectors.Matrix[1]);Y.multiplyToRef(B,B),B.decompose(void 0,l,i),i.equalsWithEpsilon(d,z.c)?delete V.translation:V.translation=i.Ng(),l.equalsWithEpsilon(x,z.c)?delete V.rotation:V.rotation=l.Ng(),V.scale&&delete V.scale}function Vh(h,V){if(!(V instanceof v.e))return!1;if(!(1===V.getChildren().length&&0===h.getChildren().length&&h.parent===V))return!1;const i=h.Mh(),S=h instanceof Z.c&&!i.useRightHandedSystem?Q:y;return!!V.Jq.equalsWithEpsilon(S,z.c)||(R.d.Warn(`Cannot collapse node ${h.name} into parent node ${V.name} with modified scaling.`),!1)}function ih(h){if(h instanceof Array){const V=new Float32Array(h);return new Uint8Array(V.buffer,V.byteOffset,V.byteLength)}return ArrayBuffer.isView(h)?new Uint8Array(h.buffer,h.byteOffset,h.byteLength):new Uint8Array(h)}function Sh(h,V){for(const[i,S]of Object.entries(h)){const l=V[i];(Array.isArray(S)&&Array.isArray(l)&&lh(S,l)||S===l)&&delete h[i]}return h}function lh(h,V){return h.length===V.length&&h.every(((h,i)=>h===V[i]))}const Yh=S.Matrix.Compose(new S.nV(-1,1,1),S.Quaternion.Identity(),S.nV.Zero());function gh(h,V){if(!(h instanceof v.e))return!1;if(V){if(!h.getWorldMatrix().equalsWithEpsilon(S.Matrix.IdentityReadOnly,z.c))return!1}else{if(!h.getWorldMatrix().multiplyToRef(Yh,S.TmpVectors.Matrix[0]).equalsWithEpsilon(S.Matrix.IdentityReadOnly,z.c))return!1}return!(h instanceof s.c&&h.bg)}const qh=new Map([[Int8Array,(h,V,i)=>h.setInt8(V,i)],[Uint8Array,(h,V,i)=>h.setUint8(V,i)],[Uint8ClampedArray,(h,V,i)=>h.setUint8(V,i)],[Int16Array,(h,V,i)=>h.setInt16(V,i,!0)],[Uint16Array,(h,V,i)=>h.setUint16(V,i,!0)],[Int32Array,(h,V,i)=>h.setInt32(V,i,!0)],[Uint32Array,(h,V,i)=>h.setUint32(V,i,!0)],[Float32Array,(h,V,i)=>h.setFloat32(V,i,!0)],[Float64Array,(h,V,i)=>h.setFloat64(V,i,!0)]]);class Bh{writeTypedArray(h){this._checkGrowBuffer(h.byteLength);const V=qh.get(h.constructor);for(let i=0;i<h.length;i++)V(this._dataView,this._byteOffset,h[i]),this._byteOffset+=h.BYTES_PER_ELEMENT}constructor(h){this._data=new Uint8Array(h),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(h){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,h),this._byteOffset++}writeInt8(h){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,h),this._byteOffset++}writeInt16(h){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,h,!0),this._byteOffset+=2}writeUInt16(h){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,h,!0),this._byteOffset+=2}writeInt32(h){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,h,!0),this._byteOffset+=4}writeUInt32(h){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat32(h){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat64(h){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,h,!0),this._byteOffset+=8}_checkGrowBuffer(h){const V=this.byteOffset+h;if(V>this._data.byteLength){const h=new Uint8Array(2*V);h.set(this._data),this._data=h,this._dataView=new DataView(this._data.buffer)}}}function Jh(h){return h%4===0?4:h%2===0?2:1}class Ih{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(h){let V=0;this._bufferViewToData.forEach((h=>{V+=h.byteLength}));const i=new Bh(V),S=Array.from(this._bufferViewToData.keys()).sort(((h,V)=>Jh(V.byteLength)-Jh(h.byteLength)));for(const l of S){l.byteOffset=i.byteOffset,h.push(l);const V=h.length-1,S=this.getPropertiesWithBufferView(l);for(const h of S)h.bufferView=V;i.writeTypedArray(this._bufferViewToData.get(l)),this._bufferViewToData.delete(l)}return i.getOutputData()}createBufferView(h,V){const i={buffer:0,byteOffset:void 0,byteLength:h.byteLength,byteStride:V};return this._bufferViewToData.set(i,h),i}createAccessor(h,V,i,S,l,Y,g){this._verifyBufferView(h);const q={bufferView:void 0,componentType:i,count:S,type:V,min:null===Y||void 0===Y?void 0:Y.min,max:null===Y||void 0===Y?void 0:Y.max,normalized:g,byteOffset:l};return this.setBufferView(q,h),this._accessorToBufferView.set(q,h),q}setBufferView(h,V){this._verifyBufferView(V);this.getPropertiesWithBufferView(V).push(h)}removeBufferView(h){const V=this.getPropertiesWithBufferView(h);for(const i of V)void 0!==i.bufferView&&delete i.bufferView;this._bufferViewToData.delete(h),this._bufferViewToProperties.delete(h),this._accessorToBufferView.forEach(((V,i)=>{V===h&&(void 0!==i.byteOffset&&delete i.byteOffset,this._accessorToBufferView.delete(i))}))}getBufferView(h){const V=this._accessorToBufferView.get(h);return this._verifyBufferView(V),V}getPropertiesWithBufferView(h){return this._verifyBufferView(h),this._bufferViewToProperties.set(h,this._bufferViewToProperties.get(h)??[]),this._bufferViewToProperties.get(h)}getData(h){return this._verifyBufferView(h),this._bufferViewToData.get(h)}_verifyBufferView(h){if(void 0===h||!this._bufferViewToData.has(h))throw new Error(`BufferView ${h} not found in BufferManager.`)}}var vh,sh=i(11598),th=i(11607),Th=i(11629),eh=i(11509),nh=i(11665),ch=i(11672),fh=i(11590),Ph=i(11681);!function(h){h[h.INTANGENT=0]="INTANGENT",h[h.OUTTANGENT=1]="OUTTANGENT"}(vh||(vh={}));class Lh{static _IsTransformable(h){return h&&(h instanceof v.e||h instanceof sh.b||h instanceof Ph.b)}static _CreateNodeAnimation(h,V,i,S,Y){if(this._IsTransformable(h)){const g=[],q=[],B=V.getKeys(),J=Lh._CalculateMinMaxKeyFrames(B),I=Lh._DeduceInterpolation(B,i,S),v=I.interpolationType,s=I.shouldBakeAnimation;if(s?Lh._CreateBakedAnimation(h,V,i,J.min,J.max,V.framePerSecond,Y,g,q,J,S):"LINEAR"===v||"STEP"===v?Lh._CreateLinearOrStepAnimation(h,V,i,g,q,S):"CUBICSPLINE"===v?Lh._CreateCubicSplineAnimation(h,V,i,g,q,S):Lh._CreateBakedAnimation(h,V,i,J.min,J.max,V.framePerSecond,Y,g,q,J,S),g.length&&q.length){return{inputs:g,outputs:q,samplerInterpolation:v,inputsMin:s?J.min:l.Tools.FloatRound(J.min/V.framePerSecond),inputsMax:s?J.max:l.Tools.FloatRound(J.max/V.framePerSecond)}}}return null}static _DeduceAnimationInfo(h){let V=null,i="VEC3",S=!1;const Y=h.targetProperty.split(".");switch(Y[0]){case"Jq":V="scale";break;case"position":V="translation";break;case"rotation":i="VEC4",V="rotation";break;case"rotationQuaternion":i="VEC4",S=!0,V="rotation";break;case"influence":i="SCALAR",V="weights";break;default:l.Tools.Error(`Unsupported animatable property ${Y[0]}`)}return V?{animationChannelTargetPath:V,dataAccessorType:i,useQuaternion:S}:(l.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(h,V,i,S,l,Y,g,q,B,J,I){let v;if(Lh._IsTransformable(h)&&h.animations)for(const s of h.animations){if(I&&!I(s))continue;const l=Lh._DeduceAnimationInfo(s);l&&(v={name:s.name,samplers:[],channels:[]},Lh._AddAnimation(`${s.name}`,s.hasRunningRuntimeAnimations?V:v,h,s,l.dataAccessorType,l.animationChannelTargetPath,S,Y,g,q,l.useQuaternion,B,J),v.samplers.length&&v.channels.length&&i.push(v))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(h,V,i,S,l,Y,g,q,B,J,I){let v;if(h instanceof fh.e){const l=h.morphTargetManager;if(l)for(let s=0;s<l.numTargets;++s){const t=l.getTarget(s);for(const T of t.animations){if(I&&!I(T))continue;const t=new nh.d(`${T.name}`,"influence",T.framePerSecond,T.dataType,T.loopMode,T.enableBlending),e=[],n=T.getKeys();for(let h=0;h<n.length;++h){const V=n[h];for(let h=0;h<l.numTargets;++h)h==s?e.push(V):e.push({frame:V.frame,value:0})}t.setKeys(e);const c=Lh._DeduceAnimationInfo(t);c&&(v={name:t.name,samplers:[],channels:[]},Lh._AddAnimation(T.name,T.hasRunningRuntimeAnimations?V:v,h,t,c.dataAccessorType,c.animationChannelTargetPath,S,Y,g,q,c.useQuaternion,B,J,l.numTargets),v.samplers.length&&v.channels.length&&i.push(v))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(h,V,i,S,l,Y,g,q,B){let J;if(h.animationGroups){const v=h.animationGroups;for(const s of v){const v=new Map,t=new Map,T=new Set,e=s.to-s.from;J={name:s.name,channels:[],samplers:[]};for(let V=0;V<s.targetedAnimations.length;++V){const e=s.targetedAnimations[V],n=e.target,c=e.animation;if(B&&!B(c))continue;const f=q.has(n);if(this._IsTransformable(n)||1===n.length&&this._IsTransformable(n[0])){const h=Lh._DeduceAnimationInfo(e.animation);if(h){const V=this._IsTransformable(n)?n:this._IsTransformable(n[0])?n[0]:null;V&&Lh._AddAnimation(`${c.name}`,J,V,c,h.dataAccessorType,h.animationChannelTargetPath,i,S,l,Y,h.useQuaternion,g,f)}}else if(n instanceof ch.d||1===n.length&&n[0]instanceof ch.d){if(Lh._DeduceAnimationInfo(e.animation)){const V=n instanceof ch.d?n:n[0];if(V){const i=h.morphTargetManagers.find((h=>{for(let i=0;i<h.numTargets;++i)if(h.getTarget(i)===V)return!0;return!1}));if(i){const S=h.meshes.find((h=>h.morphTargetManager===i));var I;if(S)v.has(S)||v.set(S,new Map),null===(I=v.get(S))||void 0===I||I.set(V,c),T.add(S),t.set(S,c)}}}}}T.forEach((h=>{const V=h.morphTargetManager;let q=null;const B=[],I=t.get(h).getKeys(),T=I.length;for(let i=0;i<T;++i)for(let S=0;S<V.numTargets;++S){const l=V.getTarget(S),Y=v.get(h);if(Y){const V=Y.get(l);V?(q||(q=new nh.d(`${s.name}_${h.name}_MorphWeightAnimation`,"influence",V.framePerSecond,nh.d.ANIMATIONTYPE_FLOAT,V.loopMode,V.enableBlending)),B.push(V.getKeys()[i])):B.push({frame:s.from+e/T*i,value:l.influence,inTangent:I[0].inTangent?0:void 0,outTangent:I[0].outTangent?0:void 0})}}q.setKeys(B);const n=Lh._DeduceAnimationInfo(q);n&&Lh._AddAnimation(`${s.name}_${h.name}_MorphWeightAnimation`,J,h,q,n.dataAccessorType,n.animationChannelTargetPath,i,S,l,Y,n.useQuaternion,g,!1,null===V||void 0===V?void 0:V.numTargets)})),J.channels.length&&J.samplers.length&&V.push(J)}}}static _AddAnimation(h,V,i,l,Y,g,q,B,J,I,v,s,t,T){const e=Lh._CreateNodeAnimation(i,l,g,v,s);let n,c,f,P,L,U;if(e){if(T){let h=0,V=0;const i=[];for(;e.inputs.length>0;)V=e.inputs.shift(),h%T==0&&i.push(V),h++;e.inputs=i}const h=q.get(i),l=new Float32Array(e.inputs);n=B.createBufferView(l),c=B.createAccessor(n,"SCALAR",5126,e.inputs.length,void 0,{min:[e.inputsMin],max:[e.inputsMax]}),I.push(c),f=I.length-1;const J=new S.Quaternion,v=new S.nV,s=new S.nV,X=i instanceof sh.b,D=b(Y),O=new Float32Array(e.outputs.length*D);e.outputs.forEach((function(h,V){let i=h;switch(g){case"translation":t&&(S.nV.FromArrayToRef(h,0,s),W(s),s.toArray(i));break;case"rotation":4===h.length?S.Quaternion.FromArrayToRef(h,0,J):(i=new Array(4),S.nV.FromArrayToRef(h,0,v),S.Quaternion.FromEulerVectorToRef(v,J)),t&&(a(J),X&&K(J)),J.toArray(i)}O.set(i,V*D)})),n=B.createBufferView(O),c=B.createAccessor(n,Y,5126,e.outputs.length),I.push(c),P=I.length-1,L={interpolation:e.samplerInterpolation,input:f,output:P},V.samplers.push(L),U={sampler:V.samplers.length-1,target:{node:h,path:g}},V.channels.push(U)}}static _CreateBakedAnimation(h,V,i,Y,g,q,B,J,I,v,s){let t;const T=S.Quaternion.Identity();let e,n=null,c=null,f=null,P=null,L=null,U=null;v.min=l.Tools.FloatRound(Y/q);const X=V.getKeys();for(let S=0,D=X.length;S<D;++S){if(U=null,f=X[S],S+1<D)if(P=X[S+1],f.value.equals&&f.value.equals(P.value)||f.value===P.value){if(0!==S)continue;U=f.frame}else U=P.frame;else{if(L=X[S-1],f.value.equals&&f.value.equals(L.value)||f.value===L.value)continue;U=g}if(U)for(let S=f.frame;S<=U;S+=B){if(e=l.Tools.FloatRound(S/q),e===n)continue;n=e,c=e;const Y={key:0,repeatCount:0,loopMode:V.loopMode};t=V._interpolate(S,Y),Lh._SetInterpolatedValue(h,t,e,V,i,T,J,I,s)}}c&&(v.max=c)}static _ConvertFactorToVector3OrQuaternion(h,V,i,Y,g){const q=Lh._GetBasePositionRotationOrScale(V,Y,g),B=i.targetProperty.split("."),J=B?B[1]:"",I=g?S.Quaternion.UV(q).normalize():S.nV.UV(q);switch(J){case"x":case"y":case"z":I[J]=h;break;case"w":I.w=h;break;default:l.Tools.Error(`glTFAnimation: Unsupported component name "${J}"!`)}return I}static _SetInterpolatedValue(h,V,i,l,Y,g,q,B,J){let I;q.push(i),"weights"!==Y?(l.dataType===nh.d.ANIMATIONTYPE_FLOAT&&(V=this._ConvertFactorToVector3OrQuaternion(V,h,l,Y,J)),"rotation"===Y?(J?g=V:(I=V,S.Quaternion.RotationYawPitchRollToRef(I.y,I.x,I.z,g)),B.push(g.Ng())):(I=V,B.push(I.Ng()))):B.push([V])}static _CreateLinearOrStepAnimation(h,V,i,S,l,Y){for(const g of V.getKeys())S.push(g.frame/V.framePerSecond),Lh._AddKeyframeValue(g,V,l,i,h,Y)}static _CreateCubicSplineAnimation(h,V,i,S,l,Y){V.getKeys().forEach((function(g){S.push(g.frame/V.framePerSecond),Lh._AddSplineTangent(vh.INTANGENT,l,i,"CUBICSPLINE",g,Y),Lh._AddKeyframeValue(g,V,l,i,h,Y),Lh._AddSplineTangent(vh.OUTTANGENT,l,i,"CUBICSPLINE",g,Y)}))}static _GetBasePositionRotationOrScale(h,V,i){let l;if("rotation"===V)if(i){l=(h.rotationQuaternion??S.Quaternion.Identity()).Ng()}else{l=(h.rotation??S.nV.Zero()).Ng()}else if("translation"===V){l=(h.position??S.nV.Zero()).Ng()}else{l=(h.Jq??S.nV.One()).Ng()}return l}static _AddKeyframeValue(h,V,i,Y,g,q){let B;const J=V.dataType;if(J===nh.d.ANIMATIONTYPE_VECTOR3){let V=h.value.Ng();if("rotation"===Y){const h=S.nV.UV(V);V=S.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).Ng()}i.push(V)}else if(J===nh.d.ANIMATIONTYPE_FLOAT){if("weights"===Y)i.push([h.value]);else if(B=this._ConvertFactorToVector3OrQuaternion(h.value,g,V,Y,q),B){if("rotation"===Y){const h=q?B:S.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).normalize();i.push(h.Ng())}i.push(B.Ng())}}else J===nh.d.ANIMATIONTYPE_QUATERNION?i.push(h.value.normalize().Ng()):l.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(h,V,i){let S,l,Y=!1;if("rotation"===V&&!i)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let g=0,q=h.length;g<q;++g)if(l=h[g],l.inTangent||l.outTangent)if(S){if("CUBICSPLINE"!==S){S="LINEAR",Y=!0;break}}else S="CUBICSPLINE";else if(S){if("CUBICSPLINE"===S||l.interpolation&&1===l.interpolation&&"STEP"!==S){S="LINEAR",Y=!0;break}}else S=l.interpolation&&1===l.interpolation?"STEP":"LINEAR";return S||(S="LINEAR"),{interpolationType:S,shouldBakeAnimation:Y}}static _AddSplineTangent(h,V,i,l,Y,g){let q;const B=h===vh.INTANGENT?Y.inTangent:Y.outTangent;if("CUBICSPLINE"===l){if("rotation"===i)if(B)if(g)q=B.Ng();else{const h=B;q=S.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).Ng()}else q=[0,0,0,0];else q="weights"===i?B?[B]:[0]:B?B.Ng():[0,0,0];V.push(q)}}static _CalculateMinMaxKeyFrames(h){let V=1/0,i=-1/0;return h.forEach((function(h){V=Math.min(V,h.frame),i=Math.max(i,h.frame)})),{min:V,max:i}}}function Uh(h,V,i,Y,g,q){const B={attributes:{},influence:h.influence,name:h.name},J=V.bg;if(!J)return l.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),B;const v=q?-1:1,s=S.nV.Zero();let t=0,T=0;if(h.hasPositions){const Y=h.getPositions(),q=J.getVerticesData(I.h.PositionKind);if(q){const h=new Float32Array(q.length),V=[1/0,1/0,1/0],l=[-1/0,-1/0,-1/0];T=q.length/3,t=0;for(let i=t;i<T;++i){const g=S.nV.UV(q,3*i);S.nV.UV(Y,3*i).subtractToRef(g,s),s.x*=v,V[0]=Math.min(V[0],s.x),l[0]=Math.max(l[0],s.x),V[1]=Math.min(V[1],s.y),l[1]=Math.max(l[1],s.y),V[2]=Math.min(V[2],s.z),l[2]=Math.max(l[2],s.z),h[3*i]=s.x,h[3*i+1]=s.y,h[3*i+2]=s.z}const J=i.createBufferView(h,12),I=i.createAccessor(J,"VEC3",5126,Y.length/3,0,{min:V,max:l});g.push(I),B.attributes.POSITION=g.length-1}else l.Tools.Warn(`Morph target positions for mesh ${V.name} were not exported. Mesh does not have position vertex data`)}if(h.hasNormals){const Y=h.getNormals(),q=J.getVerticesData(I.h.NormalKind);if(q){const h=new Float32Array(q.length);T=q.length/3,t=0;for(let i=t;i<T;++i){const V=S.nV.UV(q,3*i).normalize();S.nV.UV(Y,3*i).normalize().subtractToRef(V,s),h[3*i]=s.x*v,h[3*i+1]=s.y,h[3*i+2]=s.z}const V=i.createBufferView(h,12),l=i.createAccessor(V,"VEC3",5126,Y.length/3,0);g.push(l),B.attributes.NORMAL=g.length-1}else l.Tools.Warn(`Morph target normals for mesh ${V.name} were not exported. Mesh does not have normals vertex data`)}if(h.hasTangents){const Y=h.getTangents(),q=J.getVerticesData(I.h.TangentKind);if(q){T=q.length/4;const h=new Float32Array(3*T);t=0;for(let i=t;i<T;++i){const V=S.nV.UV(q,4*i);p(V);const l=S.nV.UV(Y,3*i);p(l),l.subtractToRef(V,s),h[3*i]=s.x*v,h[3*i+1]=s.y,h[3*i+2]=s.z}const V=i.createBufferView(h,12),l=i.createAccessor(V,"VEC3",5126,T,0);g.push(l),B.attributes.TANGENT=g.length-1}else l.Tools.Warn(`Morph target tangents for mesh ${V.name} were not exported. Mesh does not have tangents vertex data`)}if(h.hasColors){const Y=h.getColors(),q=J.getVerticesData(I.h.ColorKind),v=J.getVertexBuffer(I.h.ColorKind);if(q&&v){const h=v.getSize();T=q.length/h;const V=new Float32Array(T*h);t=0;for(let i=t;i<T;++i)if(3===h){const l=S.nV.UV(q,i*h);S.nV.UV(Y,i*h).subtractToRef(l,s),V[3*i]=s.x,V[3*i+1]=s.y,V[3*i+2]=s.z}else if(4===h){const l=new S.Vector4,g=S.Vector4.UV(q,i*h);S.Vector4.UV(Y,i*h).subtractToRef(g,l),V[4*i]=l.x,V[4*i+1]=l.y,V[4*i+2]=l.z,V[4*i+3]=l.w}else l.Tools.Warn(`Unsupported number of components for color attribute: ${h}`);const J=i.createBufferView(V,4*h),I=i.createAccessor(J,3===h?"VEC3":"VEC4",5126,T,0);g.push(I),B.attributes.COLOR_0=g.length-1}else l.Tools.Warn(`Morph target colors for mesh ${V.name} were not exported. Mesh does not have colors vertex data`)}return B}var Xh=i(11687),Dh=i(11532),Oh=i(11520),oh=i(11091);class Mh{}Mh.DEFAULT_COLOR=n.LV.White(),Mh.DEFAULT_WIDTH_ATTENUATED=1,Mh.DEFAULT_WIDTH=.1;var Fh=i(11352),Eh=i(11691);class Hh{static ConvertPoints(h,V){if(h.length&&Array.isArray(h)&&"number"===typeof h[0])return[h];if(h.length&&Array.isArray(h[0])&&"number"===typeof h[0][0])return h;if(h.length&&!Array.isArray(h[0])&&h[0]instanceof S.nV){const V=[];for(let i=0;i<h.length;i++){const S=h[i];V.push(S.x,S.y,S.z)}return[V]}if(h.length>0&&Array.isArray(h[0])&&h[0].length>0&&h[0][0]instanceof S.nV){const V=[],i=h;for(const h of i)V.push(h.flatMap((h=>[h.x,h.y,h.z])));return V}if(h instanceof Float32Array){if(null!==V&&void 0!==V&&V.floatArrayStride){const i=[],S=3*V.floatArrayStride;for(let V=0;V<h.length;V+=S){const l=new Array(S);for(let i=0;i<S;i++)l[i]=h[V+i];i.push(l)}return i}return[Array.from(h)]}if(h.length&&h[0]instanceof Float32Array){const V=[];for(const i of h)V.push(Array.from(i));return V}return[]}static OmitZeroLengthPredicate(h,V,i){const S=[];return V.cV(h).lengthSquared()>0&&S.push([h,V]),i.cV(V).lengthSquared()>0&&S.push([V,i]),h.cV(i).lengthSquared()>0&&S.push([i,h]),0===S.length?null:S}static OmitDuplicatesPredicate(h,V,i,S){const l=[];return Hh._SearchInPoints(h,V,S)||l.push([h,V]),Hh._SearchInPoints(V,i,S)||l.push([V,i]),Hh._SearchInPoints(i,h,S)||l.push([i,h]),0===l.length?null:l}static _SearchInPoints(h,V,i){for(const g of i)for(let i=0;i<g.length;i++){var S,l,Y;if(null!==(S=g[i])&&void 0!==S&&S.equals(h))if(null!==(l=g[i+1])&&void 0!==l&&l.equals(V)||null!==(Y=g[i-1])&&void 0!==Y&&Y.equals(V))return!0}return!1}static MeshesToLines(h,V){const i=[];for(let l=0;l<h.length;l++){const Y=h[l],g=Y.getVerticesData(I.h.PositionKind),q=Y.ug();if(g&&q)for(let h=0,B=0;h<q.length;h++){const J=3*q[B++],I=3*q[B++],v=3*q[B++],s=new S.nV(g[J],g[J+1],g[J+2]),t=new S.nV(g[I],g[I+1],g[I+2]),T=new S.nV(g[v],g[v+1],g[v+2]);if(V){const S=V(s,t,T,i,h,J,Y,l,g,q);if(S)for(const h of S)i.push(h)}else i.push([s,t],[t,T],[T,s])}}return i}static ToVector3Array(h){if(Array.isArray(h[0])){const V=[],i=h;for(const h of i){const i=[];for(let V=0;V<h.length;V+=3)i.push(new S.nV(h[V],h[V+1],h[V+2]));V.push(i)}return V}const V=h,i=[];for(let l=0;l<V.length;l+=3)i.push(new S.nV(V[l],V[l+1],V[l+2]));return i}static ToNumberArray(h){return h.flatMap((h=>[h.x,h.y,h.z]))}static GetPointsCountInfo(h){const V=new Array(h.length);let i=0;for(let S=h.length;S--;)V[S]=h[S].length/3,i+=V[S];return{total:i,counts:V}}static GetLineLength(h){if(0===h.length)return 0;let V;V="number"===typeof h[0]?Hh.ToVector3Array(h):h;const i=S.TmpVectors.nV[0];let l=0;for(let S=0;S<V.length-1;S++){const h=V[S];l+=V[S+1].subtractToRef(h,i).length()}return l}static GetLineLengthArray(h){const V=new Float32Array(h.length/3);let i=0;for(let S=0,l=h.length/3-1;S<l;S++){let l=h[3*S+0],Y=h[3*S+1],g=h[3*S+2];l-=h[3*S+3],Y-=h[3*S+4],g-=h[3*S+5];i+=Math.sqrt(l*l+Y*Y+g*g),V[S+1]=i}return V}static SegmentizeSegmentByCount(h,V,i){const l=[],Y=V.cV(h),g=S.TmpVectors.nV[0];g.Iq(i);const q=S.TmpVectors.nV[1];Y.divideToRef(g,q);let B=h.clone();l.push(B);for(let S=0;S<i;S++)B=B.clone(),l.push(B.addInPlace(q));return l}static SegmentizeLineBySegmentLength(h,V){const i=h[0]instanceof S.nV?Hh.GetLineSegments(h):"number"===typeof h[0]?Hh.GetLineSegments(Hh.ToVector3Array(h)):h,l=[];for(const S of i)if(S.length>V){const h=Hh.SegmentizeSegmentByCount(S.point1,S.point2,Math.ceil(S.length/V));for(const V of h)l.push(V)}else l.push(S.point1),l.push(S.point2);return l}static SegmentizeLineBySegmentCount(h,V){const i="number"===typeof h[0]?Hh.ToVector3Array(h):h,S=Hh.GetLineLength(i)/V;return Hh.SegmentizeLineBySegmentLength(i,S)}static GetLineSegments(h){const V=[];for(let i=0;i<h.length-1;i++){const S=h[i],l=h[i+1],Y=l.cV(S).length();V.push({point1:S,point2:l,length:Y})}return V}static GetMinMaxSegmentLength(h){const V=Hh.GetLineSegments(h).sort((h=>h.length));return{min:V[0].length,max:V[V.length-1].length}}static GetPositionOnLineByVisibility(h,V,i){let l=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Y=V*i;let g=0,q=0;const B=h.length;for(let S=0;S<B;S++){if(Y<=g+h[S].length){q=S;break}g+=h[S].length}const J=(Y-g)/h[q].length;return h[q].point2.subtractToRef(h[q].point1,S.TmpVectors.nV[0]),S.TmpVectors.nV[1]=S.TmpVectors.nV[0].multiplyByFloats(J,J,J),l||S.TmpVectors.nV[1].addInPlace(h[q].point1),S.TmpVectors.nV[1].clone()}static GetCircleLinePoints(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,l=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h,Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/V;const g=[];for(let q=0;q<=V;q++)g.push(new S.nV(Math.cos(q*Y)*h,Math.sin(q*Y)*l,i));return g}static GetBezierLinePoints(h,V,i,S){return Fh.e.CreateQuadraticBezier(h,V,i,S).getPoints().flatMap((h=>[h.x,h.y,h.z]))}static GetArrowCap(h,V,i,S,l){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,g=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[h.clone(),h.add(V.multiplyByFloats(i,i,i))],widths:[S,l,Y,g]}}static GetPointsFromText(h,V,i,S){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const g=[],q=(0,Eh.e)(h,V,i,S);for(const B of q){for(const h of B.paths){const V=[],i=h.getPoints();for(const h of i)V.push(h.x,h.y,l);g.push(V)}if(Y)for(const h of B.holes){const V=[],i=h.getPoints();for(const h of i)V.push(h.x,h.y,l);g.push(V)}}return g}static Color3toRGBAUint8(h){const V=new Uint8Array(4*h.length);for(let i=0,S=0;i<h.length;i++)V[S++]=255*h[i].r,V[S++]=255*h[i].g,V[S++]=255*h[i].b,V[S++]=255;return V}static CreateColorsTexture(h,V,i,S){const l=S.getEngine().getCaps().maxTextureSize??1,Y=V.length>l?l:V.length,g=Math.ceil(V.length/l);g>1&&(V=[...V,...Array(Y*g-V.length).fill(V[0])]);const q=Hh.Color3toRGBAUint8(V),B=new X.d(q,Y,g,T.b.TEXTUREFORMAT_RGBA,S,!1,!0,i);return B.name=h,B}static PrepareEmptyColorsTexture(h){if(!Mh.EmptyColorsTexture){const V=new Uint8Array(4);Mh.EmptyColorsTexture=new X.d(V,1,1,T.b.TEXTUREFORMAT_RGBA,h,!1,!1,X.d.NEAREST_NEAREST),Mh.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Mh.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var h;null===(h=Mh.EmptyColorsTexture)||void 0===h||h.dispose(),Mh.EmptyColorsTexture=null}static BooleanToNumber(h){return h?1:0}}class jh extends Oh.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class mh extends Dh.b{isCompatible(h){return!0}constructor(h,V,i){var l;i=i||{color:Mh.DEFAULT_COLOR};const Y=new jh;Y.GREASED_LINE_HAS_COLOR=!!i.color&&!i.useColors,Y.GREASED_LINE_SIZE_ATTENUATION=i.sizeAttenuation??!1,Y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===i.colorDistributionType,Y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(V??h.Mh()).useRightHandedSystem,Y.GREASED_LINE_CAMERA_FACING=i.cameraFacing??!0,super(h,mh.GREASED_LINE_MATERIAL_NAME,200,Y,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(l=i)||void 0===l?void 0:l.forceGLSL)||mh.ForceGLSL,this._scene=V??h.Mh(),this._engine=this._scene.getEngine(),this._cameraFacing=i.cameraFacing??!0,this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.width=i.width?i.width:i.sizeAttenuation?Mh.DEFAULT_WIDTH_ATTENUATED:Mh.DEFAULT_WIDTH,this._sizeAttenuation=i.sizeAttenuation??!1,this.colorMode=i.colorMode??0,this._color=i.color??null,this.useColors=i.useColors??!1,this._colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??X.d.NEAREST_NEAREST,this._colors=i.jh??null,this.dashCount=i.dashCount??1,this.resolution=i.resolution??new S.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Hh.CreateColorsTexture(`${h.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Mh.DEFAULT_COLOR,Hh.PrepareEmptyColorsTexture(this._scene)),this._engine.Ig.add((()=>{Hh.DisposeEmptyColorsTexture()}))}getAttributes(h){h.push("grl_offsets"),h.push("grl_widths"),h.push("grl_colorPointers"),h.push("grl_counters"),this._cameraFacing?(h.push("grl_previousAndSide"),h.push("grl_nextAndCounters")):h.push("grl_slopes")}getSamplers(h){h.push("grl_colors")}getActiveTextures(h){this.colorsTexture&&h.push(this.colorsTexture)}getUniforms(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const V=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&V.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===h&&V.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:V,vertex:this._cameraFacing&&this._isGLSL(h)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(h)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(h){if(this._cameraFacing){h.xg("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||h.xg("viewProjection",this._scene.getTransformMatrix());const V=S.TmpVectors.Vector4[0];V.x=this._aspect,V.y=this._resolution.x,V.z=this._resolution.y,V.w=this.width,h.updateVector4("grl_aspect_resolution_lineWidth",V)}const V=S.TmpVectors.Vector4[0];V.x=Hh.BooleanToNumber(this.useDash),V.y=this._dashArray,V.z=this.dashOffset,V.w=this.dashRatio,h.updateVector4("grl_dashOptions",V);const i=S.TmpVectors.Vector4[1];i.x=this.colorMode,i.y=this.visibility,i.z=this.colorsTexture?this.colorsTexture.getSize().width:0,i.w=Hh.BooleanToNumber(this.useColors),h.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",i),this._color&&h.updateColor3("grl_singleColor",this._color);const l=this.colorsTexture??Mh.EmptyColorsTexture;h.setTexture("grl_colors",l),h.updateFloat2("grl_textureSize",(null===l||void 0===l?void 0:l.getSize().width)??1,(null===l||void 0===l?void 0:l.getSize().height)??1)}prepareDefines(h,V,i){h.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,h.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=V.useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=this._cameraFacing,h.GREASED_LINE_USE_OFFSETS=!!i.offsets}getClassName(){return mh.GREASED_LINE_MATERIAL_NAME}getCustomCode(h){let V=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(V)?function(h,V){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return V&&(h["!gl_Position\\=viewProjection\\*worldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(h,this._cameraFacing):function(h,V){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return V&&(h["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(h,this._cameraFacing)}dispose(){var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),super.dispose()}get jh(){return this._colors}set jh(h){this.setColors(h)}setColors(h){var V;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=(null===(V=this._colors)||void 0===V?void 0:V.length)??0;var Y;if(this._colors=h,null!==h&&0!==h.length){if(!i||S)if(this.colorsTexture&&l===h.length&&!S){const V=Hh.Color3toRGBAUint8(h);this.colorsTexture.update(V)}else{var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=Hh.CreateColorsTexture(`${this._material.name}-colors-texture`,h,this.colorsSampling,this._scene)}}else null===(Y=this.colorsTexture)||void 0===Y||Y.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.markAllDefinesAsDirty()}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==h||null!==this._color&&null===h?(this._color=h,V||this.markAllDefinesAsDirty()):this._color=h}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(h){this._aspect=h.x/h.y,this._resolution=h}serialize(){const h=super.serialize(),V={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(V.jh=this._colors),this._color&&(V.color=this._color),h.greasedLineMaterialOptions=V,h}parse(h,V,i){var S;super.parse(h,V,i);const l=h.greasedLineMaterialOptions;null===(S=this.colorsTexture)||void 0===S||S.dispose(),l.color&&this.setColor(l.color,!0),l.colorDistributionType&&(this.colorsDistributionType=l.colorDistributionType),l.jh&&(this.jh=l.jh),l.colorsSampling&&(this.colorsSampling=l.colorsSampling),l.colorMode&&(this.colorMode=l.colorMode),l.useColors&&(this.useColors=l.useColors),l.visibility&&(this.visibility=l.visibility),l.useDash&&(this.useDash=l.useDash),l.dashCount&&(this.dashCount=l.dashCount),l.dashRatio&&(this.dashRatio=l.dashRatio),l.dashOffset&&(this.dashOffset=l.dashOffset),l.width&&(this.width=l.width),l.sizeAttenuation&&(this.sizeAttenuation=l.sizeAttenuation),l.resolution&&(this.resolution=l.resolution),this.jh?this.colorsTexture=Hh.CreateColorsTexture(`${this._material.name}-colors-texture`,this.jh,this.colorsSampling,V):Hh.PrepareEmptyColorsTexture(V),this.markAllDefinesAsDirty()}copyTo(h){var V;const i=h;null===(V=i.colorsTexture)||void 0===V||V.dispose(),this._colors&&(i.colorsTexture=Hh.CreateColorsTexture(`${i._material.name}-colors-texture`,this._colors,i.colorsSampling,this._scene)),i.setColor(this.color,!0),i.colorsDistributionType=this.colorsDistributionType,i.colorsSampling=this.colorsSampling,i.colorMode=this.colorMode,i.useColors=this.useColors,i.visibility=this.visibility,i.useDash=this.useDash,i.dashCount=this.dashCount,i.dashRatio=this.dashRatio,i.dashOffset=this.dashOffset,i.width=this.width,i.sizeAttenuation=this.sizeAttenuation,i.resolution=this.resolution,i.markAllDefinesAsDirty()}_isGLSL(h){return 0===h||this._forceGLSL}}mh.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",mh.ForceGLSL=!1,(0,oh.f)(`BABYLON.${mh.GREASED_LINE_MATERIAL_NAME}`,mh);var Gh=i(11579),wh=i(10972),Nh=i(11375),rh=i(11072);class kh extends Nh.ShaderMaterial{constructor(h,V,l){const Y=V.getEngine(),g=Y.isWebGPU&&!(l.forceGLSL||kh.ForceGLSL),q=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];V.useRightHandedSystem&&q.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const B=["position","grl_widths","grl_offsets","grl_colorPointers"];l.cameraFacing?(q.push("GREASED_LINE_CAMERA_FACING"),B.push("grl_previousAndSide","grl_nextAndCounters")):(B.push("grl_slopes"),B.push("grl_counters"));const J=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(g||J.push("world","viewProjection","view","projection"),super(h,V,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:g?["Scene","Mesh"]:void 0,attributes:B,uniforms:J,samplers:g?[]:["grlColors"],defines:q,extraInitializationsAsync:async()=>{g?await Promise.all([i.e(66).then(i.bind(i,14274)),i.e(75).then(i.bind(i,14282))]):await Promise.all([i.e(69).then(i.bind(i,14285)),i.e(76).then(i.bind(i,14290))])},shaderLanguage:g?1:0}),this._color=n.LV.White(),this._colorsDistributionType=0,this._colorsTexture=null,l=l||{color:Mh.DEFAULT_COLOR},this.visibility=l.visibility??1,this.useDash=l.useDash??!1,this.dashRatio=l.dashRatio??.5,this.dashOffset=l.dashOffset??0,this.dashCount=l.dashCount??1,this.width=l.width?l.width:l.sizeAttenuation&&l.cameraFacing?Mh.DEFAULT_WIDTH_ATTENUATED:Mh.DEFAULT_WIDTH,this.sizeAttenuation=l.sizeAttenuation??!1,this.color=l.color??n.LV.White(),this.useColors=l.useColors??!1,this.colorsDistributionType=l.colorDistributionType??0,this.colorsSampling=l.colorsSampling??X.d.NEAREST_NEAREST,this.colorMode=l.colorMode??0,this._colors=l.jh??null,this._cameraFacing=l.cameraFacing??!0,this.resolution=l.resolution??new S.Vector2(Y.getRenderWidth(),Y.getRenderHeight()),l.colorsTexture?this.colorsTexture=l.colorsTexture:this._colors?this.colorsTexture=Hh.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,V):(this._color=this._color??Mh.DEFAULT_COLOR,this.colorsTexture=Hh.PrepareEmptyColorsTexture(V)),g){const h=new rh.c;h.setParameters(),h.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",h)}Y.Ig.add((()=>{Hh.DisposeEmptyColorsTexture()}))}dispose(){var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new S.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get jh(){return this._colors}set jh(h){this.setColors(h)}setColors(h){var V;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],S=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const l=(null===(V=this._colors)||void 0===V?void 0:V.length)??0;var Y;if(this._colors=h,null!==h&&0!==h.length){if(!i||S)if(this._colorsTexture&&l===h.length&&!S){const V=Hh.Color3toRGBAUint8(h);this._colorsTexture.update(V)}else{var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),this.colorsTexture=Hh.CreateColorsTexture(`${this.name}-colors-texture`,h,this.colorsSampling,this.Mh())}}else null===(Y=this._colorsTexture)||void 0===Y||Y.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(h){this._colorsTexture=h,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(h){this._width=h,this.setFloat("grlWidth",h)}get useColors(){return this._useColors}set useColors(h){this._useColors=h,this.setFloat("grlUseColors",Hh.BooleanToNumber(h))}get colorsSampling(){return this._colorsSampling}set colorsSampling(h){this._colorsSampling=h}get visibility(){return this._visibility}set visibility(h){this._visibility=h,this.setFloat("grlVisibility",h)}get useDash(){return this._useDash}set useDash(h){this._useDash=h,this.setFloat("grlUseDash",Hh.BooleanToNumber(h))}get dashOffset(){return this._dashOffset}set dashOffset(h){this._dashOffset=h,this.setFloat("grlDashOffset",h)}get dashRatio(){return this._dashRatio}set dashRatio(h){this._dashRatio=h,this.setFloat("grlDashRatio",h)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.setFloat("grlSizeAttenuation",Hh.BooleanToNumber(h))}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){h=h??Mh.DEFAULT_COLOR,this._color=h,this.setColor3("grlColor",h)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(h){this._colorMode=h,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(h){this._resolution=h,this.setVector2("grlResolution",h),this.setFloat("grlAspect",h.x/h.y)}serialize(){const h=super.serialize(),V={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(V.jh=this._colors),h.greasedLineMaterialOptions=V,h}parse(h,V,i){var S;const l=h.greasedLineMaterialOptions;null===(S=this._colorsTexture)||void 0===S||S.dispose(),l.color&&(this.color=l.color),l.colorDistributionType&&(this.colorsDistributionType=l.colorDistributionType),l.colorsSampling&&(this.colorsSampling=l.colorsSampling),l.colorMode&&(this.colorMode=l.colorMode),l.useColors&&(this.useColors=l.useColors),l.visibility&&(this.visibility=l.visibility),l.useDash&&(this.useDash=l.useDash),l.dashCount&&(this.dashCount=l.dashCount),l.dashRatio&&(this.dashRatio=l.dashRatio),l.dashOffset&&(this.dashOffset=l.dashOffset),l.width&&(this.width=l.width),l.sizeAttenuation&&(this.sizeAttenuation=l.sizeAttenuation),l.resolution&&(this.resolution=l.resolution),l.jh?this.colorsTexture=Hh.CreateColorsTexture(`${this.name}-colors-texture`,l.jh,this.colorsSampling,this.Mh()):this.colorsTexture=Hh.PrepareEmptyColorsTexture(V),this._cameraFacing=l.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Rh,Zh,zh;kh.ForceGLSL=!1,function(h){h[h.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",h[h.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Rh||(Rh={})),function(h){h[h.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",h[h.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",h[h.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Zh||(Zh={})),function(h){h[h.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",h[h.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",h[h.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",h[h.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",h[h.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(zh||(zh={}));class dh extends fh.e{constructor(h,V,i){super(h,V,null,null,!1,!1),this.name=h,this._options=i,this._lazy=!1,this._updatable=!1,this._engine=V.getEngine(),this._lazy=i.lazy??!1,this._updatable=i.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=i.colorPointers??[],this._widths=i.widths??new Array(i.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(h){let V=0;for(const S of this._points)V+=S.length;const i=V/3*2-this._widths.length;for(let S=0;S<i;S++)this._widths.push(h)}updateLazy(){var h,V;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(h=this._options.ribbonOptions)||void 0===h?void 0:h.smoothShading),!this.Nh&&this.refreshBoundingInfo(),null===(V=this.greasedLineMaterial)||void 0===V||V.updateLazy()}addPoints(h,V){for(const i of h)this._points.push(i);this._lazy||this.setPoints(this._points,V)}dispose(h){let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(h,V)}isLazy(){return this._lazy}get mh(){return this._uvs}set mh(h){this._uvs=h instanceof Float32Array?h:new Float32Array(h),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(h){this.material instanceof kh&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===h||void 0===h?void 0:h.length)>0),this._offsets=h,this._offsetsBuffer?this._offsetsBuffer.update(h):this._createOffsetsBuffer(h)}get widths(){return this._widths}set widths(h){this._widths=h,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(h)}get colorPointers(){return this._colorPointers}set colorPointers(h){this._colorPointers=h,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(h)}get greasedLineMaterial(){var h,V;if(this.material&&this.material instanceof kh)return this.material;const i=null===(h=this.material)||void 0===h||null===(V=h.pluginManager)||void 0===V?void 0:V.getPlugin(mh.GREASED_LINE_MATERIAL_NAME);return i||void 0}get points(){const h=[];return wh.d.DeepCopy(this._points,h),h}setPoints(h,V){this._points=Hh.ConvertPoints(h,(null===V||void 0===V?void 0:V.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==V&&void 0!==V&&V.colorPointers||this._updateColorPointers(),this._setPoints(this._points,V)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,mh:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(h){super.serialize(h),h.type=this.getClassName(),h.lineOptions=this._createLineOptions()}_createVertexBuffers(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const V=new Gh.d;return V.Eh=this._vertexPositions,V.indices=this._indices,V.mh=this._uvs,h&&(V.Hh=[],Gh.d.ComputeNormals(this._vertexPositions,this._indices,V.Hh)),V.wh(this,this._options.updatable),V}_createOffsetsBuffer(h){const V=this._scene.getEngine(),i=new I.e(V,h,this._updatable,3);this.setVerticesBuffer(i.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=i}}class xh{constructor(h,V){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=h,this.wasAddedByNoopNode=V}getIndicesAccessor(h,V,i,S,l){var Y,g,q,B;return null===(Y=this._indicesAccessorMap.get(h))||void 0===Y||null===(g=Y.get(V))||void 0===g||null===(q=g.get(i))||void 0===q||null===(B=q.get(S))||void 0===B?void 0:B.get(l)}setIndicesAccessor(h,V,i,S,l,Y){let g=this._indicesAccessorMap.get(h);g||(g=new Map,this._indicesAccessorMap.set(h,g));let q=g.get(V);q||(q=new Map,g.set(V,q));let B=q.get(i);B||(B=new Map,q.set(i,B));let J=B.get(S);J||(J=new Map,B.set(S,J)),J.set(l,Y)}pushExportedNode(h){this._exportedNodes.has(h)||this._exportedNodes.add(h)}getNodesSet(){return this._exportedNodes}getVertexBufferView(h){return this._vertexBufferViewMap.get(h)}setVertexBufferView(h,V){this._vertexBufferViewMap.set(h,V)}setRemappedBufferView(h,V,i){this._remappedBufferView.set(h,new Map),this._remappedBufferView.get(h).set(V,i)}getRemappedBufferView(h,V){var i;return null===(i=this._remappedBufferView.get(h))||void 0===i?void 0:i.get(V)}getVertexAccessor(h,V,i){var S,l;return null===(S=this._vertexAccessorMap.get(h))||void 0===S||null===(l=S.get(V))||void 0===l?void 0:l.get(i)}setVertexAccessor(h,V,i,S){let l=this._vertexAccessorMap.get(h);l||(l=new Map,this._vertexAccessorMap.set(h,l));let Y=l.get(V);Y||(Y=new Map,l.set(V,Y)),Y.set(i,S)}hasVertexColorAlpha(h){return this._vertexMapColorAlpha.get(h)||!1}setHasVertexColorAlpha(h,V){return this._vertexMapColorAlpha.set(h,V)}getMesh(h){return this._meshMap.get(h)}setMesh(h,V){this._meshMap.set(h,V)}bindMorphDataToMesh(h,V){const i=this._meshMorphTargetMap.get(h)||[];this._meshMorphTargetMap.set(h,i),-1===i.indexOf(V)&&i.push(V)}getMorphTargetsFromMesh(h){return this._meshMorphTargetMap.get(h)}}class yh{_ApplyExtension(h,V,i,S){if(i>=V.length)return Promise.resolve(h);const l=S(V[i],h);return l?l.then((async h=>h?await this._ApplyExtension(h,V,i+1,S):null)):this._ApplyExtension(h,V,i+1,S)}_ApplyExtensions(h,V){const i=[];for(const S of yh._ExtensionNames)i.push(this._extensions[S]);return this._ApplyExtension(h,i,0,V)}_extensionsPreExportTextureAsync(h,V,i){return this._ApplyExtensions(V,((V,S)=>V.preExportTextureAsync&&V.preExportTextureAsync(h,S,i)))}_extensionsPostExportNodeAsync(h,V,i,S,l){return this._ApplyExtensions(V,((V,Y)=>V.postExportNodeAsync&&V.postExportNodeAsync(h,Y,i,S,l,this._bufferManager)))}_extensionsPostExportMaterialAsync(h,V,i){return this._ApplyExtensions(V,((V,S)=>V.postExportMaterialAsync&&V.postExportMaterialAsync(h,S,i)))}_extensionsPostExportMaterialAdditionalTextures(h,V,i){const S=[];for(const l of yh._ExtensionNames){const Y=this._extensions[l];Y.postExportMaterialAdditionalTextures&&S.push(...Y.postExportMaterialAdditionalTextures(h,V,i))}return S}_extensionsPostExportTextures(h,V,i){for(const S of yh._ExtensionNames){const l=this._extensions[S];l.postExportTexture&&l.postExportTexture(h,V,i)}}_extensionsPostExportMeshPrimitive(h){for(const V of yh._ExtensionNames){const i=this._extensions[V];i.postExportMeshPrimitive&&i.postExportMeshPrimitive(h,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const h of yh._ExtensionNames){const V=this._extensions[h];V.preGenerateBinaryAsync&&await V.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(h){for(const V of yh._ExtensionNames){const i=this._extensions[V];i.enabled&&h(i)}}_extensionsOnExporting(){this._forEachExtensions((h=>{var V,i,S;h.wasUsed&&((V=this._glTF).extensionsUsed||(V.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(h.name)&&this._glTF.extensionsUsed.push(h.name),h.required&&((i=this._glTF).extensionsRequired||(i.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(h.name)&&this._glTF.extensionsRequired.push(h.name)),(S=this._glTF).extensions||(S.extensions={}),h.onExporting&&h.onExporting())}))}_loadExtensions(){for(const h of yh._ExtensionNames){const V=yh._ExtensionFactories[h](this);this._extensions[h]=V}}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:e.d.LastCreatedScene,V=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${T.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new r(this),this._extensions={},this._bufferManager=new Ih,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!h)throw new Error("No scene available to export");this._babylonScene=h,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:h=>{var V;return null===h||void 0===h||null===(V=h.fg)||void 0===V?void 0:V.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...V},this._loadExtensions()}dispose(){for(const h in this._extensions){this._extensions[h].dispose()}}get options(){return this._options}static RegisterExtension(h,V){yh.UnregisterExtension(h)&&l.Tools.Warn(`Extension with the name ${h} already exists`),yh._ExtensionFactories[h]=V,yh._ExtensionNames.push(h)}static UnregisterExtension(h){if(!yh._ExtensionFactories[h])return!1;delete yh._ExtensionFactories[h];const V=yh._ExtensionNames.indexOf(h);return-1!==V&&yh._ExtensionNames.splice(V,1),!0}_generateJSON(h,V,i){const S={byteLength:h};return S.byteLength&&(this._glTF.buffers=[S]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.fV=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(S.uri=V+".bin"),i?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(h){const V=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(V.byteLength,h,!0),S=new Blob([V],{type:"application/octet-stream"}),l=h+".gltf",Y=h+".bin",g=new J;if(g.files[l]=i,g.files[Y]=S,this._imageData)for(const q in this._imageData)g.files[q]=new Blob([this._imageData[q].data],{type:this._imageData[q].mimeType});return g}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(h){const V=h%4;return 0===V?V:4-V}async generateGLBAsync(h){this._shouldUseGlb=!0;const V=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(V.byteLength),S=h+".glb";let l,Y=i.length;if("undefined"!==typeof TextEncoder){l=(new TextEncoder).encode(i),Y=l.length}const g=this._getPadding(Y),q=this._getPadding(V.byteLength),B=28+Y+g+V.byteLength+q,I=new Bh(B);if(I.writeUInt32(1179937895),I.writeUInt32(2),I.writeUInt32(B),I.writeUInt32(Y+g),I.writeUInt32(1313821514),l)I.writeTypedArray(l);else{const h="_".charCodeAt(0);for(let V=0;V<Y;++V){const S=i.charCodeAt(V);S!=i.codePointAt(V)?I.writeUInt8(h):I.writeUInt8(S)}}for(let J=0;J<g;++J)I.writeUInt8(32);I.writeUInt32(V.byteLength+q),I.writeUInt32(5130562),I.writeTypedArray(V);for(let J=0;J<q;++J)I.writeUInt8(0);const v=new J;return v.files[S]=new Blob([I.getOutputData()],{type:"application/octet-stream"}),v}_setNodeTransformation(h,V,i){if(V.getPivotPoint().equalsWithEpsilon(d,z.c)||l.Tools.Warn("Pivot points are not supported in the glTF serializer"),!V.position.equalsWithEpsilon(d,z.c)){const l=S.TmpVectors.nV[0].l(V.position);i&&W(l),h.translation=l.Ng()}V.Jq.equalsWithEpsilon(y,z.c)||(h.scale=V.Jq.Ng());const Y=V.rotationQuaternion||S.Quaternion.FromEulerAngles(V.rotation.x,V.rotation.y,V.rotation.z);Y.equalsWithEpsilon(x,z.c)||(i&&a(Y),h.rotation=Y.normalize().Ng())}_setCameraTransformation(h,V,i){if(!V.position.equalsWithEpsilon(d,z.c)){const l=S.TmpVectors.nV[0].l(V.position);i&&W(l),h.translation=l.Ng()}const l=V.rotationQuaternion||S.Quaternion.FromEulerAngles(V.rotation.x,V.rotation.y,V.rotation.z);i&&a(l),this._babylonScene.useRightHandedSystem||K(l),l.equalsWithEpsilon(x,z.c)||(h.rotation=l.Ng())}_listAvailableCameras(){for(const h of this._babylonScene.cameras){const V={type:h.mode===sh.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(h.name&&(V.name=h.name),"perspective"===V.type)V.perspective={aspectRatio:h.getEngine().getAspectRatio(h),yfov:h.fovMode===sh.b.FOVMODE_VERTICAL_FIXED?h.fov:h.fov*h.getEngine().getAspectRatio(h),znear:h.Zg,zfar:h.maxZ};else if("orthographic"===V.type){const i=h.orthoLeft&&h.orthoRight?.5*(h.orthoRight-h.orthoLeft):.5*h.getEngine().getRenderWidth(),S=h.orthoBottom&&h.orthoTop?.5*(h.orthoTop-h.orthoBottom):.5*h.getEngine().getRenderHeight();V.orthographic={xmag:i,ymag:S,znear:h.Zg,zfar:h.maxZ}}this._camerasMap.set(h,V)}}_exportAndAssignCameras(){const h=Array.from(this._camerasMap.values());for(const V of h){const h=this._nodesCameraMap.get(V);if(void 0!==h){this._cameras.push(V);for(const V of h)V.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const V={joints:[]};this._skinMap.set(h,V)}}_exportAndAssignSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const V=this._skinMap.get(h);if(void 0==V)continue;const i={},S=[];let Y=-1;for(let l=0;l<h.bones.length;++l){const V=h.bones[l],S=V.getIndex()??l;-1!==S&&(i[S]=V,S>Y&&(Y=S))}for(let h=0;h<=Y;++h){const Y=i[h];S.push(Y.getAbsoluteInverseBindMatrix());const g=Y.getTransformNode();if(null!==g){const h=this._nodeMap.get(g);g&&null!==h&&void 0!==h?V.joints.push(h):l.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else l.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const g=this._nodesSkinMap.get(V);if(V.joints.length>0&&void 0!==g){const h=64*S.length,i=new Float32Array(h/4);S.forEach(((h,V)=>{i.set(h.m,16*V)}));const l=this._bufferManager.createBufferView(i);this._accessors.push(this._bufferManager.createAccessor(l,"MAT4",5126,S.length)),V.inverseBindMatrices=this._accessors.length-1,this._skins.push(V);for(const V of g)V.skin=this._skins.length-1}}}async _exportSceneAsync(){const h={nodes:[]};if(this._babylonScene.metadata){const V=this._options.metadataSelector(this._babylonScene.metadata);V&&(h.extras=V)}const V=new Array,i=new Array,S=new Array;for(const q of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&gh(q,this._babylonScene.useRightHandedSystem)?S.push(...q.getChildren()):this._babylonScene.useRightHandedSystem?V.push(q):i.push(q);this._listAvailableCameras(),this._listAvailableSkeletons();const l=new xh(!0,!1);h.nodes.push(...await this._exportNodesAsync(i,l));const Y=new xh(!1,!1);h.nodes.push(...await this._exportNodesAsync(V,Y));const g=new xh(!1,!0);h.nodes.push(...await this._exportNodesAsync(S,g)),h.nodes.length&&this._scenes.push(h),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Lh._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,l.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(h){let V=this._shouldExportNodeMap.get(h);return void 0===V&&(V=this._options.shouldExportNode(h),this._shouldExportNodeMap.set(h,V)),V}async _exportNodesAsync(h,V){const i=new Array;this._exportBuffers(h,V);for(const S of h)await this._exportNodeAsync(S,i,V);return i}_collectBuffers(h,V,i,S,l){if(this._shouldExportNode(h)&&h instanceof s.c&&h.bg){const Y=h.bg.getVertexBuffers();if(Y)for(const S in Y){if(!C(S))continue;const g=Y[S];l.setHasVertexColorAlpha(g,h.hasVertexAlpha);const q=g._buffer,B=V.get(q)||[];V.set(q,B),-1===B.indexOf(g)&&B.push(g);const J=i.get(g)||[];i.set(g,J),-1===J.indexOf(h)&&J.push(h)}const g=h.morphTargetManager;if(g)for(let V=0;V<g.numTargets;V++){const i=g.getTarget(V),l=S.get(i)||[];S.set(i,l),-1===l.indexOf(h)&&l.push(h)}}for(const Y of h.getChildren())this._collectBuffers(Y,V,i,S,l)}_exportBuffers(h,V){const i=new Map,S=new Map,l=new Map;for(const q of h)this._collectBuffers(q,i,S,l,V);const Y=Array.from(i.keys());for(const q of Y){const h=q.getData();if(!h)throw new Error("Buffer data is not available");const l=i.get(q);if(!l)continue;const Y=l[0].byteStride;if(l.some((h=>h.byteStride!==Y)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const g=ih(h).slice();for(const V of l){const h=S.get(V),{byteOffset:i,byteStride:l,componentCount:Y,type:q,count:B,normalized:J,kind:v}=A(V,h);switch(v){case I.h.NormalKind:case I.h.TangentKind:(0,k.j)(g,i,l,Y,q,B,J,(h=>{const V=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]);if(V>0){const i=1/V;h[0]*=i,h[1]*=i,h[2]*=i}}));break;case I.h.ColorKind:{const V=h.filter((h=>h.material instanceof eh.PV||null==h.material)).length;if(0==V)break;if(V!=h.length){R.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}q==I.h.UNSIGNED_BYTE&&R.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const S=new n.LV,v=new n.vq,s=this._babylonScene.getEngine().useExactSrgbConversions;(0,k.j)(g,i,l,Y,q,B,J,(h=>{3===h.length?(S.ei(h,0),S.toLinearSpaceToRef(S,s),S.toArray(h,0)):(v.ei(h,0),v.toLinearSpaceToRef(v,s),v.toArray(h,0))}))}}}if(V.convertToRightHanded){for(const h of l){const V=S.get(h),{byteOffset:i,byteStride:l,componentCount:Y,type:q,count:B,normalized:J,kind:v}=A(h,V);switch(v){case I.h.PositionKind:case I.h.NormalKind:case I.h.TangentKind:(0,k.j)(g,i,l,Y,q,B,J,(h=>{h[0]=-h[0]}))}}V.convertedToRightHandedBuffers.set(q,g)}const B=this._bufferManager.createBufferView(g,Y);V.setVertexBufferView(q,B);const J=new Map;for(const V of l){const h=S.get(V),{kind:i,totalVertices:l}=A(V,h);switch(i){case I.h.MatricesIndicesKind:case I.h.MatricesIndicesExtraKind:if(V.type==I.h.FLOAT){const h=V.getFloatData(l);null!==h&&J.set(V,h)}}}0!==J.size&&R.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const v=Array.from(J.keys());for(const i of v){const h=J.get(i);if(!h)continue;const S=h.some((h=>h>=256)),l=new(S?Uint16Array:Uint8Array)(h.length);for(let V=0;V<h.length;V++)l[V]=h[V];const Y=this._bufferManager.createBufferView(l,4*(S?2:1));V.setRemappedBufferView(q,i,Y)}}const g=Array.from(l.keys());for(const q of g){const h=l.get(q);if(!h)continue;const i=Uh(q,h[0],this._bufferManager,this._bufferViews,this._accessors,V.convertToRightHanded);for(const S of h)V.bindMorphDataToMesh(S,i)}}async _exportNodeAsync(h,V,i){let S=this._nodeMap.get(h);if(void 0!==S)return void(V.includes(S)||V.push(S));const l=await this._createNodeAsync(h,i);if(l){S=this._nodes.length,this._nodes.push(l),this._nodeMap.set(h,S),i.pushExportedNode(h),V.push(S);const Y={name:"runtime animations",channels:[],samplers:[]},g=[];this._babylonScene.animationGroups.length||(Lh._CreateMorphTargetAnimationFromMorphTargetAnimations(h,Y,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation),h.animations.length&&Lh._CreateNodeAnimationFromNodeAnimations(h,Y,g,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation)),Y.channels.length&&Y.samplers.length&&this._animations.push(Y),g.forEach((h=>{h.channels.length&&h.samplers.length&&this._animations.push(h)}))}const Y=l?[]:V;for(const g of h.getChildren())await this._exportNodeAsync(g,Y,i);l&&Y.length&&(l.children=Y)}async _createNodeAsync(h,V){if(!this._shouldExportNode(h))return null;const i={};if(h.name&&(i.name=h.name),h.metadata){const V=this._options.metadataSelector(h.metadata);V&&(i.extras=V)}if(h instanceof v.e&&(this._setNodeTransformation(i,h,V.convertToRightHanded),h instanceof s.c)){const l=h instanceof t.e?h.sourceMesh:h;if(l.Gg&&l.Gg.length>0&&(i.mesh=await this._exportMeshAsync(l,V)),h.skeleton){const V=this._skinMap.get(h.skeleton);var S;if(void 0!==V)void 0===this._nodesSkinMap.get(V)&&this._nodesSkinMap.set(V,[]),null===(S=this._nodesSkinMap.get(V))||void 0===S||S.push(i)}}if(h instanceof Z.c){const S=this._camerasMap.get(h);if(S){var l;void 0===this._nodesCameraMap.get(S)&&this._nodesCameraMap.set(S,[]),this._setCameraTransformation(i,h,V.convertToRightHanded);const g=h.parent;if(null!==g&&Vh(h,g)){const h=this._nodeMap.get(g);if(void 0!==h){var Y;const V=this._nodes[h];return hh(i,V),null===(Y=this._nodesCameraMap.get(S))||void 0===Y||Y.push(V),null}}null===(l=this._nodesCameraMap.get(S))||void 0===l||l.push(i)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",i,h,this._nodeMap,V.convertToRightHanded)?i:(R.d.Warn(`Not exporting node ${h.name}`),null)}_exportIndices(h,V,i,S,l,g,q,B,J){let I=h;J.mode=u(g);const v=q!==Y.e.CounterClockWiseSideOrientation,s=!B.wasAddedByNoopNode&&v,t=function(h){switch(h){case Y.e.TriangleFillMode:case Y.e.TriangleStripDrawMode:case Y.e.TriangleFanDrawMode:return!0}return!1}(g)&&s;if(t){if(g===Y.e.TriangleStripDrawMode||g===Y.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");J.mode=u(g);const q=V?new Uint32Array(S):new Uint16Array(S);if(h)for(let V=0;V+2<S;V+=3)q[V]=h[i+V]+l,q[V+1]=h[i+V+2]+l,q[V+2]=h[i+V+1]+l;else for(let h=0;h+2<S;h+=3)q[h]=h,q[h+1]=h+2,q[h+2]=h+1;I=q}else if(h&&0!==l){const Y=V?new Uint32Array(S):new Uint16Array(S);for(let V=0;V<S;V++)Y[V]=h[i+V]+l;I=Y}if(I){let Y=B.getIndicesAccessor(h,i,S,l,t);if(void 0===Y){const g=function(h,V,i,S){if(h instanceof Uint16Array||h instanceof Uint32Array)return h;if(h instanceof Int32Array)return new Uint32Array(h.buffer,h.byteOffset,h.length);const l=h.slice(V,V+i);return S?new Uint32Array(l):new Uint16Array(l)}(I,0,S,V),q=this._bufferManager.createBufferView(g),J=V?5125:5123;this._accessors.push(this._bufferManager.createAccessor(q,"SCALAR",J,S,0)),Y=this._accessors.length-1,B.setIndicesAccessor(h,i,S,l,t,Y)}J.indices=Y}}_exportVertexBuffer(h,V,i,S,l,Y){const g=h.getKind();if(!C(g))return;if(g.startsWith("uv")&&!this._options.exportUnusedUVs&&(!V||!this._materialNeedsUVsSet.has(V)))return;let q=l.getVertexAccessor(h,i,S);if(void 0===q){const V=l.convertedToRightHandedBuffers.get(h._buffer)||h._buffer.getData(),Y=g===I.h.PositionKind?function(h,V,i,S){const{byteOffset:l,byteStride:Y,type:g,normalized:q}=V,B=V.getSize(),J=new Array(B).fill(1/0),I=new Array(B).fill(-1/0);return(0,k.j)(h,l+i*Y,Y,B,g,S*B,q,(h=>{for(let V=0;V<B;V++)J[V]=Math.min(J[V],h[V]),I[V]=Math.max(I[V],h[V])})),{min:J,max:I}}(V,h,i,S):void 0,B=(g===I.h.MatricesIndicesKind||g===I.h.MatricesIndicesExtraKind)&&h.type===I.h.FLOAT,J=B?I.h.UNSIGNED_BYTE:h.type,v=B?void 0:h.normalized,s=B?l.getRemappedBufferView(h._buffer,h):l.getVertexBufferView(h._buffer),t=h.byteOffset+i*h.byteStride;this._accessors.push(this._bufferManager.createAccessor(s,function(h,V){if(h==I.h.ColorKind)return V?"VEC4":"VEC3";switch(h){case I.h.PositionKind:case I.h.NormalKind:return"VEC3";case I.h.TangentKind:case I.h.MatricesIndicesKind:case I.h.MatricesIndicesExtraKind:case I.h.MatricesWeightsKind:case I.h.MatricesWeightsExtraKind:return"VEC4";case I.h.UVKind:case I.h.UV2Kind:case I.h.UV3Kind:case I.h.UV4Kind:case I.h.UV5Kind:case I.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${h}`)}(g,l.hasVertexColorAlpha(h)),J,S,t,Y,v)),q=this._accessors.length-1,l.setVertexAccessor(h,i,S,q)}Y.attributes[function(h){switch(h){case I.h.PositionKind:return"POSITION";case I.h.NormalKind:return"NORMAL";case I.h.TangentKind:return"TANGENT";case I.h.ColorKind:return"COLOR_0";case I.h.UVKind:return"TEXCOORD_0";case I.h.UV2Kind:return"TEXCOORD_1";case I.h.UV3Kind:return"TEXCOORD_2";case I.h.UV4Kind:return"TEXCOORD_3";case I.h.UV5Kind:return"TEXCOORD_4";case I.h.UV6Kind:return"TEXCOORD_5";case I.h.MatricesIndicesKind:return"JOINTS_0";case I.h.MatricesIndicesExtraKind:return"JOINTS_1";case I.h.MatricesWeightsKind:return"WEIGHTS_0";case I.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${h}`)}(g)]=q}async _exportMaterialAsync(h,V,i,S){let l=this._materialMap.get(h);if(void 0===l){const S=V&&Object.keys(V).some((h=>h.startsWith("uv")));if((h=h instanceof th.e?h.sq[i.materialIndex]:h)instanceof Th.e)l=await this._materialExporter.exportPBRMaterialAsync(h,"image/png",S);else{if(!(h instanceof eh.PV))return void R.d.Warn(`Unsupported material '${h.name}' with type ${h.getClassName()}`);l=await this._materialExporter.exportStandardMaterialAsync(h,"image/png",S)}this._materialMap.set(h,l)}S.material=l}async _exportMeshAsync(h,V){var i;let S=V.getMesh(h);if(void 0!==S)return S;const l={primitives:[]};S=this._meshes.length,this._meshes.push(l),V.setMesh(h,S);const g=h.isUnIndexed?null:h.ug(),q=null===(i=h.bg)||void 0===i?void 0:i.getVertexBuffers(),B=V.getMorphTargetsFromMesh(h),J=h instanceof Xh.d,I=h instanceof dh,v=h.Gg;if(q&&v&&v.length>0)for(const T of v){const i={attributes:{}},S=T.Zh()||this._babylonScene.defaultMaterial;if(I){var s,t;const V={name:S.name},l=h,Y=n.LV.White(),g=(null===(s=l.material)||void 0===s?void 0:s.alpha)??1,q=(null===(t=l.greasedLineMaterial)||void 0===t?void 0:t.color)??Y;(!q.equalsWithEpsilon(Y,z.c)||g<1)&&(V.pbrMetallicRoughness={baseColorFactor:[...q.Ng(),g]}),this._materials.push(V),i.material=this._materials.length-1}else if(J){const V={name:S.name},l=h;(!l.color.equalsWithEpsilon(n.LV.White(),z.c)||l.alpha<1)&&(V.pbrMetallicRoughness={baseColorFactor:[...l.color.Ng(),l.alpha]}),this._materials.push(V),i.material=this._materials.length-1}else await this._exportMaterialAsync(S,q,T,i);const v=J||I?Y.e.LineListDrawMode:h.overrideRenderingFillMode??S.fillMode,e=S._getEffectiveOrientation(h);this._exportIndices(g,g?(0,k.e)(g,T.indexCount,T.indexStart,T.verticesStart):T.verticesCount>65535,g?T.indexStart:T.verticesStart,g?T.indexCount:T.verticesCount,-T.verticesStart,v,e,V,i);for(const h of Object.values(q))this._exportVertexBuffer(h,S,T.verticesStart,T.verticesCount,V,i);if(B){i.targets=[];for(const h of B)i.targets.push(h.attributes)}l.primitives.push(i),this._extensionsPostExportMeshPrimitive(i)}if(B){l.weights=[],l.extras||(l.extras={}),l.extras.targetNames=[];for(const h of B)l.weights.push(h.influence),l.extras.targetNames.push(h.name)}return S}}yh._ExtensionNames=new Array,yh._ExtensionFactories={};class Qh{static async GLTFAsync(h,V,i){i&&i.exportWithoutWaitingForScene||await h.whenReadyAsync();const S=new yh(h,i),l=await S.generateGLTFAsync(V.replace(/\.[^/.]+$/,""));return S.dispose(),l}static async GLBAsync(h,V,i){i&&i.exportWithoutWaitingForScene||await h.whenReadyAsync();const S=new yh(h,i),l=await S.generateGLBAsync(V.replace(/\.[^/.]+$/,""));return S.dispose(),l}}i(11708);const Ah="EXT_mesh_gpu_instancing";class bh{constructor(h){this.name=Ah,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(h,V,i,l,Y,g){return await new Promise((h=>{if(V&&i instanceof fh.e&&i.hasThinInstances&&this._exporter){this._wasUsed=!0;const h=S.nV.Zero(),l=S.Quaternion.Identity(),q=S.nV.One(),B=i.thinInstanceGetWorldMatrices(),J=S.TmpVectors.nV[2],I=S.TmpVectors.Quaternion[1],v=S.TmpVectors.nV[3];let s=!1,t=!1,T=!1;const e=new Float32Array(3*i.tq),n=new Float32Array(4*i.tq),c=new Float32Array(3*i.tq);let f=0;for(const V of B)V.decompose(v,I,J),Y&&(W(J),a(I)),e.set(J.Ng(),3*f),n.set(I.normalize().Ng(),4*f),c.set(v.Ng(),3*f),s=s||!J.equalsWithEpsilon(h),t=t||!I.equalsWithEpsilon(l),T=T||!v.equalsWithEpsilon(q),f++;const P={attributes:{}};s&&(P.attributes.TRANSLATION=this._buildAccessor(e,"VEC3",i.tq,g)),t&&(P.attributes.ROTATION=this._buildAccessor(n,"VEC4",i.tq,g)),T&&(P.attributes.SCALE=this._buildAccessor(c,"VEC3",i.tq,g)),V.extensions=V.extensions||{},V.extensions[Ah]=P}h(V)}))}_buildAccessor(h,V,i,S){const l=S.createBufferView(h),Y=S.createAccessor(l,V,5126,i);return this._exporter._accessors.push(Y),this._exporter._accessors.length-1}}yh.RegisterExtension(Ah,(h=>new bh(h)));var Ch=i(11712),uh=i(11721),ph=i(11728),Wh=i(11732);function ah(h){return h===ph.c.PositionKind?"POSITION":h===ph.c.NormalKind?"NORMAL":h===ph.c.ColorKind?"COLOR":h.startsWith(ph.c.UVKind)?"TEX_COORD":"GENERIC"}const Kh={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class hV extends Ch.c{static get DefaultAvailable(){return(0,Ch.g)(hV.DefaultConfiguration)}static get Default(){return hV._Default??(hV._Default=new hV),hV._Default}static ResetDefault(h){hV._Default&&(h||hV._Default.dispose(),hV._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(h,V){return{module:await(V||DracoEncoderModule)({wasmBinary:h})}}_getWorkerContent(){return`${uh.f}(${uh.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:hV.DefaultConfiguration)}async _encodeAsync(h,V,i){const S=i?(0,Wh.e)(Kh,i):Kh;if(this._workerPoolPromise){const i=await this._workerPoolPromise;return await new Promise(((l,Y)=>{i.push(((i,g)=>{const q=h=>{i.removeEventListener("error",q),i.removeEventListener("message",B),Y(h),g()},B=h=>{"encodeMeshDone"===h.data.id&&(i.removeEventListener("error",q),i.removeEventListener("message",B),l(h.data.encodedMeshData),g())};i.addEventListener("error",q),i.addEventListener("message",B);const J=[];for(const V of h)J.push(V.data.buffer);V&&J.push(V.buffer),i.postMessage({id:"encodeMesh",attributes:h,indices:V,options:S},J)}))}))}if(this._modulePromise){const i=await this._modulePromise;return(0,uh.f)(i.module,h,V,S)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(h,V){if(0==h.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");h instanceof fh.e&&h.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===V||void 0===V?void 0:V.method)&&(R.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),V.method="MESH_SEQUENTIAL_ENCODING");const i=function(h){let V=h.ug(void 0,!0);return!V||V instanceof Uint32Array||V instanceof Uint16Array||(V=((0,k.e)(V,V.length)?Uint32Array:Uint16Array).from(V)),V}(h),S=function(h,V){const i=[];for(const S of h.getVerticesDataKinds()){if(null!==V&&void 0!==V&&V.includes(S)){if(S===ph.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const l=h.getVertexBuffer(S),Y=l.getSize(),g=(0,k.w)(l.getData(),Y,l.type,l.byteOffset,l.byteStride,l.normalized,h.getTotalVertices(),!0);i.push({kind:S,dracoName:ah(S),size:Y,data:g})}return i}(h,null===V||void 0===V?void 0:V.excludedAttributes);return await this._encodeAsync(S,i,V)}}hV.DefaultConfiguration={wasmUrl:`${l.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${l.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${l.Tools._DefaultCdnUrl}/draco_encoder.js`},hV._Default=null;const VV="KHR_draco_mesh_compression";class iV{get wasUsed(){return this._wasUsed}constructor(h){this.name=VV,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===h.options.meshCompressionMethod&&hV.DefaultAvailable}dispose(){}postExportMeshPrimitive(h,V,i){if(!this.enabled)return;if(4!==h.mode&&5!==h.mode)return void R.d.Warn("Cannot compress primitive with mode "+h.mode+".");const S=[],l=[];let Y=null;if(void 0!==h.indices){const g=i[h.indices],q=V.getBufferView(g);Y=V.getData(q).slice(),S.push(q),l.push(g)}const g=[];for(const[I,v]of Object.entries(h.attributes)){const h=i[v],Y=V.getBufferView(h),B=b(h.type),J=(0,k.w)(V.getData(Y),B,h.componentType,h.byteOffset||0,Y.byteStride||(0,k.q)(h.componentType)*B,h.normalized||!1,h.count,!0);g.push({kind:I,dracoName:(q=I,"POSITION"===q?"POSITION":"NORMAL"===q?"NORMAL":q.startsWith("COLOR")?"COLOR":q.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:b(h.type),data:J}),S.push(Y),l.push(h)}var q;const B={method:h.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},J=hV.Default._encodeAsync(g,Y,B).then((i=>{if(!i)return void R.d.Error("Draco encoding failed for primitive.");const Y={bufferView:-1,attributes:i.attributeIds},g=V.createBufferView(i.data);V.setBufferView(Y,g);for(const h of S)this._bufferViewsUsed.add(h);for(const h of l)this._accessorsUsed.add(h);h.extensions||(h.extensions={}),h.extensions[VV]=Y})).catch((h=>{R.d.Error("Draco encoding failed for primitive: "+h)}));this._encodePromises.push(J),this._wasUsed=!0}async preGenerateBinaryAsync(h){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((V=>{h.getPropertiesWithBufferView(V).every((h=>this._accessorsUsed.has(h)))&&h.removeBufferView(V)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}yh.RegisterExtension(VV,(h=>new iV(h)));var SV=i(11741);const lV="KHR_lights_punctual",YV={name:"",color:[1,1,1],Tq:1,range:Number.MAX_VALUE},gV={innerConeAngle:0,outerConeAngle:Math.PI/4},qV=S.nV.Backward();class BV{constructor(h){this.name=lV,this.enabled=!0,this.required=!1,this._exporter=h}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[lV]=this._lights}async postExportNodeAsync(h,V,i,l,Y){return await new Promise((g=>{if(!(i instanceof Ph.b))return void g(V);const q=i.getTypeID()==Ph.b.LIGHTTYPEID_POINTLIGHT?"point":i.getTypeID()==Ph.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":i.getTypeID()==Ph.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!q||!(i instanceof SV.c))return R.d.Warn(`${h}: Light ${i.name} is not supported in ${lV}`),void g(V);if(i.falloffType!==Ph.b.FALLOFF_GLTF&&R.d.Warn(`${h}: Light falloff for ${i.name} does not match the ${lV} specification!`),!i.position.equalsToFloats(0,0,0)){const h=S.TmpVectors.nV[0].l(i.position);Y&&W(h),V.translation=h.Ng()}if("point"!==q){const h=i.direction.normalizeToRef(S.TmpVectors.nV[0]);Y&&W(h);const l=S.Quaternion.FromUnitVectorsToRef(qV,h,S.TmpVectors.Quaternion[0]);S.Quaternion.IsIdentity(l)||(V.rotation=l.Ng())}const B={type:q,name:i.name,color:i.eq.Ng(),Tq:i.Tq,range:i.range};if(Sh(B,YV),"spot"===q){const h=i;B.spot={innerConeAngle:h.innerAngle/2,outerConeAngle:h.angle/2},Sh(B.spot,gV)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(B);const J={Yg:this._lights.lights.length-1},I=i.parent;if(I&&Vh(i,I)){const h=l.get(I);if(h){const i=this._exporter._nodes[h];return hh(V,i),i.extensions||(i.extensions={}),i.extensions[lV]=J,void g(null)}}V.extensions||(V.extensions={}),V.extensions[lV]=J,g(V)}))}}yh.RegisterExtension(lV,(h=>new BV(h)));var JV=i(11647);const IV="KHR_materials_anisotropy";class vV{constructor(h){this.name=IV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof JV.b&&i.anisotropy.isEnabled&&!i.anisotropy.legacy?(i.anisotropy.texture&&S.push(i.anisotropy.texture),S):[]}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof JV.b){if(!i.anisotropy.isEnabled||i.anisotropy.legacy)return void h(V);this._wasUsed=!0,V.extensions=V.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(i.anisotropy.texture),l={anisotropyStrength:i.anisotropy.Tq,anisotropyRotation:i.anisotropy.angle,anisotropyTexture:S??void 0};null!==l.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(i),V.extensions[IV]=l}h(V)}))}}yh.RegisterExtension(IV,(h=>new vV(h)));const sV="KHR_materials_clearcoat";class tV{constructor(h){this.name=sV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof JV.b&&i.clearCoat.isEnabled?(i.clearCoat.texture&&S.push(i.clearCoat.texture),!i.clearCoat.useRoughnessFromMainTexture&&i.clearCoat.textureRoughness&&S.push(i.clearCoat.textureRoughness),i.clearCoat.bumpTexture&&S.push(i.clearCoat.bumpTexture),S):[]}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof JV.b){if(!i.clearCoat.isEnabled)return void h(V);this._wasUsed=!0,V.extensions=V.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture);let Y;Y=i.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(i.clearCoat.textureRoughness),i.clearCoat.isTintEnabled&&l.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${i.name}`),i.clearCoat.remapF0OnInterfaceChange&&l.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${i.name}`);const g=this._exporter._materialExporter.getTextureInfo(i.clearCoat.bumpTexture),q={clearcoatFactor:i.clearCoat.Tq,clearcoatTexture:S??void 0,clearcoatRoughnessFactor:i.clearCoat.roughness,clearcoatRoughnessTexture:Y??void 0,clearcoatNormalTexture:g??void 0};null===q.clearcoatTexture&&null===q.clearcoatRoughnessTexture&&null===q.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),V.extensions[sV]=q}h(V)}))}}yh.RegisterExtension(sV,(h=>new tV(h)));const TV="KHR_materials_diffuse_transmission";function eV(h,V){const i=V.subSurface;let S=null;return i.translucencyIntensityTexture?S=i.translucencyIntensityTexture:i.thicknessTexture&&i.useMaskFromThicknessTexture&&(S=i.thicknessTexture),S&&!i.useGltfStyleTextures?(R.d.Warn(`${h}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${V.name}`,1),null):S}class nV{constructor(h){this.name=TV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];if(i instanceof Th.e&&this._isExtensionEnabled(i)){const V=eV(h,i);return V&&S.push(V),i.subSurface.translucencyColorTexture&&S.push(i.subSurface.translucencyColorTexture),S}return S}_isExtensionEnabled(h){if(h.unlit)return!1;const V=h.subSurface;return!!V.isTranslucencyEnabled&&(!h.unlit&&!V.useAlbedoToTintTranslucency&&V.useGltfStyleTextures&&1===V.volumeIndexOfRefraction&&0===V.minimumThickness&&0===V.maximumThickness)}postExportMaterialAsync(h,V,i){return new Promise((S=>{if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const S=i.subSurface,l=eV(h,i),Y=0==S.translucencyIntensity?void 0:S.translucencyIntensity,g=this._exporter._materialExporter.getTextureInfo(l)??void 0,q=!S.translucencyColor||S.translucencyColor.equalsFloats(1,1,1)?void 0:S.translucencyColor.Ng(),B=this._exporter._materialExporter.getTextureInfo(S.translucencyColorTexture)??void 0,J={diffuseTransmissionFactor:Y,diffuseTransmissionTexture:g,diffuseTransmissionColorFactor:q,diffuseTransmissionColorTexture:B};(g||B)&&this._exporter._materialNeedsUVsSet.add(i),V.extensions=V.extensions||{},V.extensions[TV]=J}S(V)}))}}yh.RegisterExtension(TV,(h=>new nV(h)));const cV="KHR_materials_dispersion";class fV{constructor(){this.name=cV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){if(h.unlit)return!1;const V=h.subSurface;return!(!V.isRefractionEnabled&&!V.isDispersionEnabled)}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const h={dispersion:i.subSurface.dispersion};V.extensions=V.extensions||{},V.extensions[cV]=h}h(V)}))}}yh.RegisterExtension(cV,(()=>new fV));const PV="KHR_materials_emissive_strength";class LV{constructor(){this.name=PV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(h,V,i){return await new Promise((h=>{if(!(i instanceof Th.e))return h(V);const S=i.emissiveColor.Ng(),l=Math.max(...S);if(l>1){this._wasUsed=!0,V.extensions||(V.extensions={});const h={emissiveStrength:l},S=i.emissiveColor.scale(1/h.emissiveStrength);V.emissiveFactor=S.Ng(),V.extensions[PV]=h}return h(V)}))}}yh.RegisterExtension(PV,(h=>new LV));const UV="KHR_materials_ior";class XV{constructor(){this.name=UV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.indexOfRefraction&&1.5!=h.indexOfRefraction)}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const h={ior:i.indexOfRefraction};V.extensions=V.extensions||{},V.extensions[UV]=h}h(V)}))}}yh.RegisterExtension(UV,(h=>new XV));const DV="KHR_materials_iridescence";class OV{constructor(h){this.name=DV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof JV.b&&i.iridescence.isEnabled?(i.iridescence.texture&&S.push(i.iridescence.texture),i.iridescence.thicknessTexture&&i.iridescence.thicknessTexture!==i.iridescence.texture&&S.push(i.iridescence.thicknessTexture),S):[]}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof JV.b){if(!i.iridescence.isEnabled)return void h(V);this._wasUsed=!0,V.extensions=V.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(i.iridescence.texture),l=this._exporter._materialExporter.getTextureInfo(i.iridescence.thicknessTexture),Y={iridescenceFactor:i.iridescence.Tq,iridescenceIor:i.iridescence.indexOfRefraction,iridescenceThicknessMinimum:i.iridescence.minimumThickness,iridescenceThicknessMaximum:i.iridescence.maximumThickness,iridescenceTexture:S??void 0,iridescenceThicknessTexture:l??void 0};null===Y.iridescenceTexture&&null===Y.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(i),V.extensions[DV]=Y}h(V)}))}}yh.RegisterExtension(DV,(h=>new OV(h)));const oV="KHR_materials_sheen";class MV{constructor(h){this.name=oV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){return i instanceof Th.e&&i.sheen.isEnabled&&i.sheen.texture?[i.sheen.texture]:[]}async postExportMaterialAsync(h,V,i){return await new Promise((h=>{if(i instanceof Th.e){if(!i.sheen.isEnabled)return void h(V);this._wasUsed=!0,null==V.extensions&&(V.extensions={});const S={sheenColorFactor:i.sheen.color.Ng(),sheenRoughnessFactor:i.sheen.roughness??0};null===S.sheenColorTexture&&null===S.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),i.sheen.texture&&(S.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),i.sheen.textureRoughness&&!i.sheen.useRoughnessFromMainTexture?S.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.textureRoughness)??void 0:i.sheen.texture&&i.sheen.useRoughnessFromMainTexture&&(S.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),V.extensions[oV]=S}h(V)}))}}yh.RegisterExtension(oV,(h=>new MV(h)));const FV="KHR_materials_specular";class EV{constructor(h){this.name=FV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof Th.e&&this._isExtensionEnabled(i)?(i.metallicReflectanceTexture&&S.push(i.metallicReflectanceTexture),i.reflectanceTexture&&S.push(i.reflectanceTexture),S):S}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.metallicF0Factor&&1!=h.metallicF0Factor||void 0!=h.metallicReflectanceColor&&!h.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.metallicReflectanceTexture||null!=h.reflectanceTexture}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0,V.extensions=V.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(i.metallicReflectanceTexture)??void 0,S=this._exporter._materialExporter.getTextureInfo(i.reflectanceTexture)??void 0,l={specularFactor:1==i.metallicF0Factor?void 0:i.metallicF0Factor,specularTexture:h,specularColorFactor:i.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:i.metallicReflectanceColor.Ng(),specularColorTexture:S};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),V.extensions[FV]=l}h(V)}))}}yh.RegisterExtension(FV,(h=>new EV(h)));const HV="KHR_materials_transmission";class jV{constructor(h){this.name=HV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof Th.e&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&S.push(i.subSurface.thicknessTexture),S):S}_isExtensionEnabled(h){if(h.unlit)return!1;const V=h.subSurface;return V.isRefractionEnabled&&void 0!=V.refractionIntensity&&0!=V.refractionIntensity||this._hasTexturesExtension(h)}_hasTexturesExtension(h){return null!=h.subSurface.refractionIntensityTexture}async postExportMaterialAsync(h,V,i){if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const S=i.subSurface,l={transmissionFactor:0===S.refractionIntensity?void 0:S.refractionIntensity};if(this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),S.refractionIntensityTexture)if(S.useGltfStyleTextures){const h=await this._exporter._materialExporter.exportTextureAsync(S.refractionIntensityTexture,"image/png");h&&(l.transmissionTexture=h)}else R.d.Warn(`${h}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);V.extensions||(V.extensions={}),V.extensions[HV]=l}return V}}yh.RegisterExtension(HV,(h=>new jV(h)));const mV="KHR_materials_unlit";class GV{constructor(){this.name=mV,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(h,V,i){return new Promise((h=>{let S=!1;i instanceof Th.e?S=i.unlit:i instanceof eh.PV&&(S=i.disableLighting),S&&(this._wasUsed=!0,null==V.extensions&&(V.extensions={}),V.extensions[mV]={}),h(V)}))}}yh.RegisterExtension(mV,(()=>new GV));const wV="KHR_materials_volume";class NV{constructor(h){this.name=wV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof Th.e&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&S.push(i.subSurface.thicknessTexture),S):S}_isExtensionEnabled(h){if(h.unlit)return!1;const V=h.subSurface;return!(!V.isRefractionEnabled&&!V.isTranslucencyEnabled)&&(void 0!=V.maximumThickness&&0!=V.maximumThickness||void 0!=V.tintColorAtDistance&&V.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=V.tintColor&&V.tintColor!=n.LV.White()||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.subSurface.thicknessTexture}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof Th.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const h=i.subSurface,S={thicknessFactor:0==h.maximumThickness?void 0:h.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(h.thicknessTexture)??void 0,attenuationDistance:h.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:h.tintColorAtDistance,attenuationColor:h.tintColor.equalsFloats(1,1,1)?void 0:h.tintColor.Ng()};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),V.extensions=V.extensions||{},V.extensions[wV]=S}h(V)}))}}yh.RegisterExtension(wV,(h=>new NV(h)));const rV="EXT_materials_diffuse_roughness";class kV{constructor(h){this.name=rV,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,V,i){const S=[];return i instanceof JV.b&&i._baseDiffuseRoughness?(i._baseDiffuseRoughnessTexture&&S.push(i._baseDiffuseRoughnessTexture),S):[]}postExportMaterialAsync(h,V,i){return new Promise((h=>{if(i instanceof JV.b){if(!i._baseDiffuseRoughness)return void h(V);this._wasUsed=!0,V.extensions=V.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(i._baseDiffuseRoughnessTexture),l={diffuseRoughnessFactor:i._baseDiffuseRoughness,diffuseRoughnessTexture:S??void 0};null!==l.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(i),V.extensions[rV]=l}h(V)}))}}yh.RegisterExtension(rV,(h=>new kV(h)));const RV="KHR_texture_transform";class ZV{constructor(){this.name=RV,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(h,V,i){if(i.Mh()||l.Tools.Warn(`${h}: /*@__KEY__*/"scene" is not defined for Babylon texture ${i.name}!`),(0!==i.uAng||0!==i.vAng)&&(l.Tools.Warn(`${h}: Texture ${i.name} with rotation in the u or v axis is not supported in glTF.`),0!==i.uRotationCenter||0!==i.vRotationCenter))return;const S={};let Y=!1;if(0===i.uOffset&&0===i.vOffset||(S.offset=[i.uOffset,i.vOffset],Y=!0),1===i.uScale&&1===i.vScale||(S.scale=[i.uScale,i.vScale],Y=!0),0!==i.wAng){if(0!==i.uRotationCenter||0!==i.vRotationCenter){if(i.homogeneousRotationInUVTransform&&i.uScale!==i.vScale)return void l.Tools.Warn(`${h}: Texture ${i.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${RV}.`);l.Tools.Warn(`${h}: Texture ${i.name} with non-origin rotation center will be exported using an adjusted offset with ${RV}.`),S.offset=function(h){const{uOffset:V,vOffset:i,uRotationCenter:S,vRotationCenter:l,uScale:Y,vScale:g,wAng:q}=h,B=Math.cos(q),J=Math.sin(q),I=S*Y,v=l*g;return[V+(I*(1-B)+v*J),i+(v*(1-B)-I*J)]}(i)}S.rotation=-i.wAng,Y=!0}0!==i.coordinatesIndex&&(S.texCoord=i.coordinatesIndex,Y=!0),Y&&(this._wasUsed=!0,V.extensions||(V.extensions={}),V.extensions[RV]=S)}}yh.RegisterExtension(RV,(()=>new ZV));class zV{static CreateSTL(h){let V=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",l=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Y=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],g=arguments.length>5&&void 0!==arguments[5]&&arguments[5],q=arguments.length>6&&void 0!==arguments[6]&&arguments[6],B=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const J=function(h,V,i){const l=[3*h[i],3*h[i+1],3*h[i+2]],Y=[new S.nV(V[l[0]],V[l[0]+2],V[l[0]+1]),new S.nV(V[l[1]],V[l[1]+2],V[l[1]+1]),new S.nV(V[l[2]],V[l[2]+2],V[l[2]+1])],g=Y[0].cV(Y[1]),q=Y[2].cV(Y[1]);return{v:Y,n:S.nV.Cross(q,g).normalize()}},v=function(h,V,i,S){return V=s(h,V,i.x,S),V=s(h,V,i.y,S),s(h,V,i.z,S)},s=function(h,V,i,S){return h.setFloat32(V,i,S),V+4},T=function(h){if(q){let V=h;h instanceof t.e&&(V=h.sourceMesh);const i=V.getVerticesData(I.h.PositionKind,!0,!0);if(!i)return[];const l=S.nV.Zero();let Y;for(Y=0;Y<i.length;Y+=3)S.nV.TransformCoordinatesFromFloatsToRef(i[Y],i[Y+1],i[Y+2],h.Ag(!0),l).toArray(i,Y);return i}return h.getVerticesData(I.h.PositionKind)||[]};q&&(g=!0);let e="",n=0,c=0;if(l){for(let i=0;i<h.length;i++){const V=h[i].ug();n+=V?V.length/3:0}const V=new ArrayBuffer(84+50*n);e=new DataView(V),c+=80,e.setUint32(c,n,Y),c+=4}else B||(e="solid stlmesh\r\n");for(let S=0;S<h.length;S++){const V=h[S];!l&&B&&(e+="solid "+V.name+"\r\n"),!g&&V instanceof fh.e&&V.bakeCurrentTransformIntoVertices();const i=T(V),q=V.ug()||[];for(let h=0;h<q.length;h+=3){const V=J(q,i,h);l?(c=v(e,c,V.n,Y),c=v(e,c,V.v[0],Y),c=v(e,c,V.v[1],Y),c=v(e,c,V.v[2],Y),c+=2):(e+="\tfacet normal "+V.n.x+" "+V.n.y+" "+V.n.z+"\r\n",e+="\t\touter loop\r\n",e+="\t\t\tvertex "+V.v[0].x+" "+V.v[0].y+" "+V.v[0].z+"\r\n",e+="\t\t\tvertex "+V.v[1].x+" "+V.v[1].y+" "+V.v[1].z+"\r\n",e+="\t\t\tvertex "+V.v[2].x+" "+V.v[2].y+" "+V.v[2].z+"\r\n",e+="\t\tendloop\r\n",e+="\tendfacet\r\n")}!l&&B&&(e+="endsolid "+name+"\r\n")}if(l||B||(e+="endsolid stlmesh"),V){const h=document.createElement("a"),V=new Blob([e],{type:"application/octet-stream"});h.href=window.URL.createObjectURL(V),h.download=i+".stl",h.click()}return e}}function dV(h,V){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const S=[];for(let l=0;l<h.length/i;l++){const Y=h[l*i],g=h[l*i+1],q=h[l*i+2];S.push(`(${Y.toPrecision(V.precision)}, ${g.toPrecision(V.precision)}, ${q.toPrecision(V.precision)})`)}return S.join(", ")}function xV(h,V){const i=[];for(let S=0;S<h.length/2;S++){const l=h[2*S],Y=h[2*S+1];i.push(`(${l.toPrecision(V.precision)}, ${(1-Y).toPrecision(V.precision)})`)}return i.join(", ")}function yV(h,V){const i=h.getVerticesData(I.h.PositionKind),S=h.getVerticesData(I.h.NormalKind);if(i&&S)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(h){var V;const i=null!==(V=h.ug())&&void 0!==V&&V.length?h.getTotalIndices():h.getTotalVertices();return Array(i/3).fill(3).join(", ")}(h)}]\n\t\tint[] faceVertexIndices = [${function(h){const V=h.ug(),i=[];if(null!==V)for(let S=0;S<V.length;S++)i.push(V[S]);else{const V=h.getTotalVertices();for(let h=0;h<V;h++)i.push(h)}return i.join(", ")}(h)}]\n\t\tnormal3f[] normals = [${dV(S,V)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${dV(i,V)}]\n        ${function(h,V){let i="";for(let l=0;l<4;l++){const S=l>0?l:"",Y=h.getVerticesData(I.h.UVKind+(S?S+1:""));Y&&(i+=`\n\t\ttexCoord2f[] primvars:st${S} = [${xV(Y,V)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const S=h.getVerticesData(I.h.ColorKind);return S&&(i+=`\n\tcolor3f[] primvars:displayColor = [${dV(S,V,S.length/h.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),i}(h,V)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function QV(h,V){return`\n        def "Geometry"\n        {\n        ${yV(h,V)}\n        }\n        `}function AV(h){let V='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return V+=h,fflate.strToU8(V)}function bV(h){const V=h.m;return`( ${CV(V,0)}, ${CV(V,4)}, ${CV(V,8)}, ${CV(V,12)} )`}function CV(h,V){return`(${h[V+0]}, ${h[V+1]}, ${h[V+2]}, ${h[V+3]})`}function uV(h){const V="Object_"+h.uniqueId,i=function(h){const V=h.getWorldMatrix().clone(),i=h.Mh().useRightHandedSystem;if(!i){let S=h.parent;for(;S;){if(gh(S,i)){V.multiplyToRef(S.getWorldMatrix().invert(),V);break}S=S.parent}}return V.determinant()<0&&l.Tools.Warn(`Exporting mesh ${h.name} with negative scale. Result may look incorrect in destination engine.`),V}(h),S=bV(i);return`def Xform "${V}" (\n\tprepend references = @./geometries/Geometry_${h.bg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${S}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${h.material.uniqueId}>\n}\n\n`}function pV(h){switch(h){case D.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case D.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case D.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function WV(h){return`(${h.x}, ${h.y})`}function aV(h){return`(${h.r}, ${h.g}, ${h.b})`}function KV(h,V,i,l,Y,g){const q=h.getInternalTexture().uniqueId+"_"+h.invertY;Y[q]=h;const B=h.coordinatesIndex>0?"st"+h.coordinatesIndex:"st",J=new S.Vector2(h.uScale,h.vScale),I=new S.Vector2(h.uOffset,h.vOffset),v=h.wAng,s=Math.sin(v),t=Math.cos(v);return I.y=1-I.y-J.y,I.x+=s*J.x,I.y+=(1-t)*J.y,`\n    def Shader "PrimvarReader_${i}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${B}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${i}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${V.uniqueId}/PrimvarReader_${i}.outputs:result>\n        float inputs:rotation = ${(v*(180/Math.PI)).toFixed(g.precision)}\n        float2 inputs:scale = ${WV(J)}\n        float2 inputs:translation = ${WV(I)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${h.uniqueId}_${i}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${q}.png@\n        float2 inputs:st.connect = </Materials/Material_${V.uniqueId}/Transform2d_${i}.outputs:result>\n        ${l?"float4 inputs:scale = "+function(h){return`(${h.r}, ${h.g}, ${h.b}, 1.0)`}(l):""}\n        token inputs:sourceColorSpace = "${h.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pV(h.wrapU)}"\n        token inputs:wrapT = "${pV(h.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${V.needAlphaBlending()?"float outputs:a":""}\n    }`}function hi(h,V,i){const S="\t\t\t",l=[],Y=[],{diffuseMap:g,eq:q,alphaCutOff:B,emissiveMap:J,emissive:I,normalMap:v,roughnessMap:s,roughnessChannel:t,roughness:T,metalnessMap:e,metalnessChannel:c,metalness:f,aoMap:P,aoMapChannel:L,aoMapIntensity:U,alphaMap:X,ior:D,clearCoatEnabled:O,clearCoat:o,clearCoatMap:M,clearCoatRoughness:F,clearCoatRoughnessMap:E}=function(h){const V={diffuseMap:null,eq:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return h instanceof eh.PV?{...V,diffuseMap:h.diffuseTexture,eq:h.diffuseColor,alphaCutOff:h.alphaCutOff,emissiveMap:h.emissiveTexture,emissive:h.emissiveColor,roughness:1,alphaMap:h.opacityTexture}:h instanceof JV.b?{...V,diffuseMap:h._albedoTexture,eq:h._albedoColor,alphaCutOff:h._alphaCutOff,emissiveMap:h._emissiveTexture,emissive:h._emissiveColor,normalMap:h._bumpTexture,roughnessMap:h._metallicTexture,roughnessChannel:h._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:h._roughness??1,metalnessMap:h._metallicTexture,metalnessChannel:h._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:h._metallic??0,aoMap:h._ambientTexture,aoMapChannel:h._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:h._ambientTextureStrength,alphaMap:h._opacityTexture,ior:h.subSurface.indexOfRefraction,clearCoatEnabled:h.clearCoat.isEnabled,clearCoat:h.clearCoat.Tq,clearCoatMap:h.clearCoat.texture,clearCoatRoughness:h.clearCoat.roughness,clearCoatRoughnessMap:h.clearCoat.useRoughnessFromMainTexture?h.clearCoat.texture:h.clearCoat.textureRoughness}:V}(h);return null!==g?(l.push(`${S}color3f inputs:diffuseColor.connect = </Materials/Material_${h.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:rgb>`),h.needAlphaBlending()?l.push(`${S}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`):h.needAlphaTesting()&&(l.push(`${S}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${g.uniqueId}_diffuse.outputs:a>`),l.push(`${S}float inputs:opacityThreshold = ${B}`)),Y.push(KV(g,h,"diffuse",q,V,i))):l.push(`${S}color3f inputs:diffuseColor = ${aV(q||n.LV.White())}`),null!==J?(l.push(`${S}color3f inputs:emissiveColor.connect = </Materials/Material_${h.uniqueId}/Texture_${J.uniqueId}_emissive.outputs:rgb>`),Y.push(KV(J,h,"emissive",I,V,i))):I&&I.toLuminance()>0&&l.push(`${S}color3f inputs:emissiveColor = ${aV(I)}`),null!==v&&(l.push(`${S}normal3f inputs:normal.connect = </Materials/Material_${h.uniqueId}/Texture_${v.uniqueId}_normal.outputs:rgb>`),Y.push(KV(v,h,"normal",null,V,i))),null!==P&&(l.push(`${S}float inputs:occlusion.connect = </Materials/Material_${h.uniqueId}/Texture_${P.uniqueId}_occlusion.outputs:${L}>`),Y.push(KV(P,h,"occlusion",new n.LV(U,U,U),V,i))),null!==s?(l.push(`${S}float inputs:roughness.connect = </Materials/Material_${h.uniqueId}/Texture_${s.uniqueId}_roughness.outputs:${t}>`),Y.push(KV(s,h,"roughness",new n.LV(T,T,T),V,i))):l.push(`${S}float inputs:roughness = ${T}`),null!==e?(l.push(`${S}float inputs:metallic.connect = </Materials/Material_${h.uniqueId}/Texture_${e.uniqueId}_metallic.outputs:${c}>`),Y.push(KV(e,h,"metallic",new n.LV(f,f,f),V,i))):l.push(`${S}float inputs:metallic = ${f}`),null!==X?(l.push(`${S}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${X.uniqueId}_opacity.outputs:r>`),l.push(`${S}float inputs:opacityThreshold = 0.0001`),Y.push(KV(X,h,"opacity",null,V,i))):l.push(`${S}float inputs:opacity = ${h.alpha}`),O&&(null!==M?(l.push(`${S}float inputs:clearcoat.connect = </Materials/Material_${h.uniqueId}/Texture_${M.uniqueId}_clearcoat.outputs:r>`),Y.push(KV(M,h,"clearcoat",new n.LV(o,o,o),V,i))):l.push(`${S}float inputs:clearcoat = ${o}`),null!==E?(l.push(`${S}float inputs:clearcoatRoughness.connect = </Materials/Material_${h.uniqueId}/Texture_${E.uniqueId}_clearcoatRoughness.outputs:g>`),Y.push(KV(E,h,"clearcoatRoughness",new n.LV(F,F,F),V,i))):l.push(`${S}float inputs:clearcoatRoughness = ${F}`)),l.push(`${S}float inputs:ior = ${D}`),`\n\tdef Material "Material_${h.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${l.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${h.uniqueId}/PreviewSurface.outputs:surface>\n\n${Y.join("\n")}\n\n\t}\n`}async function Vi(h,V,i){const Y={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...V};"undefined"===typeof fflate&&await l.Tools.LoadScriptAsync(Y.fflateUrl);const g={};g[Y.modelFileName]=null;let q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';q+=function(h){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===h.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${h.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${h.planeAnchoringAlignment}"`:""}\n            `}(Y);const B={};for(const S of h.meshes){if(0===S.getTotalVertices())continue;const h=S,V=h.bg,J=h.material;if(!J||!V||i&&!i(h))continue;if(-1!==["PV","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(J.getClassName())){const i="geometries/Geometry_"+V.uniqueId+".usda";if(!(i in g)){const h=QV(V,Y);g[i]=AV(h)}J.uniqueId in B||(B[J.uniqueId]=J),q+=uV(h)}else l.Tools.Warn("USDZExportAsync does not support this material type: "+J.getClassName())}h.activeCamera&&Y.exportCamera&&(q+=function(h,V){const i="Camera_"+h.uniqueId,l=bV(S.Matrix.RotationY(Math.PI).multiply(h.getWorldMatrix()));if(h.mode===D.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${l}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.Zg.toPrecision(V.precision)}, ${h.maxZ.toPrecision(V.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(h.orthoLeft||1)+Math.abs(h.orthoRight||1))).toPrecision(V.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(h.orthoTop||1)+Math.abs(h.orthoBottom||1))).toPrecision(V.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const S=h.getEngine().getAspectRatio(h),Y=V.cameraSensorWidth||35;return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${l}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.Zg.toPrecision(V.precision)}, ${h.maxZ.toPrecision(V.precision)})\n\t\t\tfloat focalLength = ${(Y/(2*Math.tan(.5*h.fov))).toPrecision(V.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(Y*S).toPrecision(V.precision)}\n\t\t\tfloat verticalAperture = ${(Y/S).toPrecision(V.precision)}            \n\t\t}\n\t\n\t`}}(h.activeCamera,Y)),q+="\n            }\n        }\n    }";const J={};q+=function(h,V,i){const S=[];for(const l in h){const Y=h[l];S.push(hi(Y,V,i))}return`\n    def "Materials"\n{\n${S.join("")}\n}\n\n`}(B,J,Y),g[Y.modelFileName]=fflate.strToU8(q);for(const S in J){const h=J[S],V=h.getSize(),i=await h.readPixels();if(!i)throw new Error("Texture data is not available");const l=await O.DumpTools.DumpDataAsync(V.width,V.height,i,"image/png",void 0,!1,!0);g[`textures/Texture_${S}.png`]=new Uint8Array(l).slice()}let I=0;for(const S in g){const h=g[S];if(!h)continue;I+=34+S.length;const V=63&I;if(4!==V){const i=new Uint8Array(64-V);g[S]=[h,{extra:{12345:i}}]}I=h.length}return fflate.zipSync(g,{level:0})}}}]);