"use strict";(self.wx5iyvo7rvn=self.wx5iyvo7rvn||[]).push([[26],{11520:(P,e,n)=>{n.r(e),n.d(e,{EXT_materials_diffuse_roughness:()=>fe,EXT_mesh_gpu_instancing:()=>EP,GLTF2Export:()=>LP,GLTFData:()=>C,KHR_draco_mesh_compression:()=>ne,KHR_lights_punctual:()=>te,KHR_materials_anisotropy:()=>qe,KHR_materials_clearcoat:()=>Fe,KHR_materials_diffuse_transmission:()=>ze,KHR_materials_dispersion:()=>Je,KHR_materials_emissive_strength:()=>Oe,KHR_materials_ior:()=>ie,KHR_materials_iridescence:()=>le,KHR_materials_sheen:()=>Te,KHR_materials_specular:()=>Ne,KHR_materials_transmission:()=>ce,KHR_materials_unlit:()=>oe,KHR_materials_volume:()=>ge,KHR_texture_transform:()=>ve,OBJExport:()=>k,STLExport:()=>ue,USDZExportAsync:()=>en,_ConvertToGLTFPBRMetallicRoughness:()=>r,_SolveMetallic:()=>c,__IGLTFExporterExtension:()=>m});var H=n(11133),S=n(10972),p=n(11438);class k{static OBJ(P,e,n,k){const m=[];let t=1,C=1;e&&(n||(n="mat"),m.push("mtllib "+n+".mtl"));for(let R=0;R<P.length;R++){const n=P[R],q=n.name||`mesh${R}}`;m.push(`o ${q}`);let A=null;if(k){const P=n.De(!0);A=new H.Matrix,P.invertToRef(A),n.bakeTransformIntoVertices(P)}if(e){const P=n.material;P&&m.push("usemtl "+P.id)}const F=n.en;if(!F){S.Tools.Warn("No geometry is present on the mesh");continue}const Y=F.getVerticesData("position"),j=F.getVerticesData("normal"),z=F.getVerticesData("uv"),w=F.ln();let J=0,I=0;if(!Y||!w){S.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const O=P[0].BP().useRightHandedSystem?1:-1;for(let P=0;P<Y.length;P+=3)m.push("v "+Y[P]*O+" "+Y[P+1]+" "+Y[P+2]),J++;if(null!=j)for(let P=0;P<j.length;P+=3)m.push("vn "+j[P]*O+" "+j[P+1]+" "+j[P+2]);if(null!=z)for(let P=0;P<z.length;P+=2)m.push("vt "+z[P]+" "+z[P+1]),I++;const V=["","",""],i=(n.material||n.BP().defaultMaterial)._getEffectiveOrientation(n),[B,l]=i===p.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let P=0;P<w.length;P+=3){const e=[String(w[P]+t),String(w[P+B]+t),String(w[P+l]+t)],n=[String(w[P]+C),String(w[P+B]+C),String(w[P+l]+C)],H=e,S=null!=z?n:V,p=null!=j?e:V;m.push("f "+H[0]+"/"+S[0]+"/"+p[0]+" "+H[1]+"/"+S[1]+"/"+p[1]+" "+H[2]+"/"+S[2]+"/"+p[2])}k&&A&&n.bakeTransformIntoVertices(A),t+=J,C+=I}return m.join("\n")}static MTL(P){const e=[],n=P.material;e.push("newmtl mat1"),e.push("  Ns "+n.specularPower.toFixed(4)),e.push("  Ni 1.5000"),e.push("  d "+n.alpha.toFixed(4)),e.push("  Tr 0.0000"),e.push("  Tf 1.0000 1.0000 1.0000"),e.push("  illum 2"),e.push("  Ka "+n.ambientColor.r.toFixed(4)+" "+n.ambientColor.g.toFixed(4)+" "+n.ambientColor.b.toFixed(4)),e.push("  Kd "+n.diffuseColor.r.toFixed(4)+" "+n.diffuseColor.g.toFixed(4)+" "+n.diffuseColor.b.toFixed(4)),e.push("  Ks "+n.specularColor.r.toFixed(4)+" "+n.specularColor.g.toFixed(4)+" "+n.specularColor.b.toFixed(4)),e.push("  Ke "+n.emissiveColor.r.toFixed(4)+" "+n.emissiveColor.g.toFixed(4)+" "+n.emissiveColor.b.toFixed(4));n.ambientTexture&&e.push("  map_Ka "+n.ambientTexture.name),n.diffuseTexture&&e.push("  map_Kd "+n.diffuseTexture.name),n.specularTexture&&e.push("  map_Ks "+n.specularTexture.name),n.bumpTexture&&e.push("  map_bump -imfchan z "+n.bumpTexture.name),n.opacityTexture&&e.push("  map_d "+n.opacityTexture.name);return e.join("\n")}}var m=0,t=n(11019);class C{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const P in this.files){const e=this.files[P],n=new Blob([e],{type:(0,t.g)(P)});S.Tools.Download(n,P)}}}var R=n(11213),q=n(11528),A=n(11535),F=n(11548),Y=n(11271),j=n(11017),z=n(11183),w=n(11148);const J=w.HighestCommonFactor,I={...w,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:J};var O=n(11364),V=n(11119),i=n(11591),B=n(11599),l=n(11360);const b=1e-6,T=new z.Ne(.04,.04,.04),d=1024,N=z.Ne.White(),Q=z.Ne.Black();function c(P,e,n){if(e<T.r)return 0;const H=T.r,S=P*n/(1-T.r)+e-2*T.r,p=S*S-4*H*(T.r-e);return I.Clamp((-S+Math.sqrt(p))/(2*H),0,1)}function r(P){const e=P.diffuseColor.toLinearSpace(P.BP().getEngine().useExactSrgbConversions).scale(.5),n=P.alpha,S=function(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new H.Vector2(0,1),n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new H.Vector2(0,.1),S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new H.Vector2(0,.1),p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new H.Vector2(1300,.1);return function(P,e,n,H,S){return(1-P)*(1-P)*(1-P)*e+3*(1-P)*(1-P)*P*n+3*(1-P)*P*P*H+P*P*P*S}(Math.pow(P/p.x,.333333),e.y,n.y,S.y,p.y)}(I.Clamp(P.specularPower,0,d));return{baseColorFactor:[e.r,e.g,e.b,n],metallicFactor:0,roughnessFactor:S}}function o(P,e){e.needAlphaBlending()?P.alphaMode="BLEND":e.needAlphaTesting()&&(P.alphaMode="MASK",P.alphaCutoff=e.alphaCutOff)}function G(P,e,n){const H=new Uint8Array(P*e*4);for(let S=0;S<H.length;S+=4)H[S]=H[S+1]=H[S+2]=H[S+3]=255;return i.e.CreateRGBATexture(H,P,e,n)}function g(P){if(P instanceof Uint8Array){const e=P.length,n=new Float32Array(P.length);for(let H=0;H<e;++H)n[H]=P[H]/255;return n}if(P instanceof Float32Array)return P;throw new Error("Unsupported pixel format!")}class y{constructor(P){this._exporter=P,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(P){return P?this._textureMap.get(P)??null:null}async exportStandardMaterialAsync(P,e,n){const H=r(P),p={name:P.name};if(null==P.ip||P.ip||(P.twoSidedLighting||S.Tools.Warn(P.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),p.doubleSided=!0),n){const n=[],S=P.diffuseTexture;S&&n.push(this.exportTextureAsync(S,e).then((P=>{P&&(H.baseColorTexture=P)})));const k=P.bumpTexture;k&&n.push(this.exportTextureAsync(k,e).then((P=>{P&&(p.normalTexture=P,1!==k.level&&(p.normalTexture.scale=k.level))})));const m=P.emissiveTexture;m&&(p.emissiveFactor=[1,1,1],n.push(this.exportTextureAsync(m,e).then((P=>{P&&(p.emissiveTexture=P)}))));const t=P.ambientTexture;t&&n.push(this.exportTextureAsync(t,e).then((P=>{if(P){const e={index:P.index};p.occlusionTexture=e}}))),n.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(n))}(P.alpha<1||P.opacityTexture)&&(P.alphaMode===B.c.ALPHA_COMBINE?p.alphaMode="BLEND":S.Tools.Warn(P.name+": glTF 2.0 does not support alpha mode: "+P.alphaMode.toString())),P.emissiveColor&&!P.emissiveColor.equalsWithEpsilon(Q,b)&&(p.emissiveFactor=P.emissiveColor.fe()),p.pbrMetallicRoughness=H,o(p,P),await this._finishMaterialAsync(p,P,e);const k=this._exporter._materials;return k.push(p),k.length-1}async _finishMaterialAsync(P,e,n){const H=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",P,e),S=[];for(const p of H)S.push(this.exportTextureAsync(p,n));await Promise.all(S),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",P,e)}async _getImageDataAsync(P,e,H,S){const p=B.c.TEXTURETYPE_UNSIGNED_BYTE,k=this._exporter._babylonScene,m=k.getEngine(),t=m.createRawTexture(P,e,H,B.c.TEXTUREFORMAT_RGBA,!1,!0,V.e.NEAREST_SAMPLINGMODE,null,p);m.isWebGPU?await n.e(51).then(n.bind(n,13563)):await n.e(52).then(n.bind(n,13572)),await O.k.ApplyPostProcess("pass",t,k,p,B.c.TEXTURE_NEAREST_SAMPLINGMODE,B.c.TEXTUREFORMAT_RGBA);const C=await m._readTexturePixels(t,e,H);return await l.DumpTools.DumpDataAsync(e,H,C,S,void 0,!0,!0)}_resizeTexturesToSameDimensions(P,e,n){const H=P?P.getSize():{width:0,height:0},S=e?e.getSize():{width:0,height:0};let p,k;return H.width<S.width?(p=P&&P instanceof V.e?O.k.CreateResizedCopy(P,S.width,S.height,!0):G(S.width,S.height,n),k=e):H.width>S.width?(k=e&&e instanceof V.e?O.k.CreateResizedCopy(e,H.width,H.height,!0):G(H.width,H.height,n),p=P):(p=P,k=e),{texture1:p,texture2:k}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(P,e,n,H){const S=new Array;if(!P&&!e)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const p=P?P.BP():e?e.BP():null;if(p){var k;const m=this._resizeTexturesToSameDimensions(P,e,p),t=null===(k=m.texture1)||void 0===k?void 0:k.getSize();let C,R;const q=t.width,A=t.height,F=await m.texture1.readPixels(),Y=await m.texture2.readPixels();if(!F)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(C=g(F),!Y)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");R=g(Y);const j=R.byteLength,w=new Uint8Array(j),J=new Uint8Array(j),I=4,O=Q;let V=0,i=0;for(let P=0;P<A;++P)for(let e=0;e<q;++e){const H=(q*P+e)*I,S={diffuseColor:new z.Ne(C[H],C[H+1],C[H+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(n.diffuseColor),specularColor:new z.Ne(R[H],R[H+1],R[H+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(n.specularColor),glossiness:R[H+3]*n.glossiness},k=this._convertSpecularGlossinessToMetallicRoughness(S);O.r=Math.max(O.r,k.baseColor.r),O.g=Math.max(O.g,k.baseColor.g),O.b=Math.max(O.b,k.baseColor.b),V=Math.max(V,k.metallic),i=Math.max(i,k.roughness),J[H]=255*k.baseColor.r,J[H+1]=255*k.baseColor.g,J[H+2]=255*k.baseColor.b,J[H+3]=m.texture1.We?255*C[H+3]:255,w[H]=0,w[H+1]=255*k.roughness,w[H+2]=255*k.metallic,w[H+3]=255}const B={baseColor:O,metallic:V,roughness:i};let l=!1,T=!1;for(let P=0;P<A;++P)for(let e=0;e<q;++e){const n=(q*P+e)*I;J[n]/=B.baseColor.r>b?B.baseColor.r:1,J[n+1]/=B.baseColor.g>b?B.baseColor.g:1,J[n+2]/=B.baseColor.b>b?B.baseColor.b:1;const H=z.Ne.FromInts(J[n],J[n+1],J[n+2]).toGammaSpace(p.getEngine().useExactSrgbConversions);J[n]=255*H.r,J[n+1]=255*H.g,J[n+2]=255*H.b,H.equalsWithEpsilon(N,b)||(T=!0),w[n+1]/=B.roughness>b?B.roughness:1,w[n+2]/=B.metallic>b?B.metallic:1;z.Ne.FromInts(255,w[n+1],w[n+2]).equalsWithEpsilon(N,b)||(l=!0)}return l&&S.push(this._getImageDataAsync(w,q,A,H).then((P=>{B.metallicRoughnessTextureData=P}))),T&&S.push(this._getImageDataAsync(J,q,A,H).then((P=>{B.baseColorTextureData=P}))),await Promise.all(S).then((()=>B))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(P){const e=this._getPerceivedBrightness(P.diffuseColor),n=this._getPerceivedBrightness(P.specularColor),H=1-this._getMaxComponent(P.specularColor),S=c(e,n,H),p=P.diffuseColor.scale(H/(1-T.r)/Math.max(1-S)),k=P.specularColor.be(T.scale(1-S)).scale(1/Math.max(S));let m=z.Ne.Lerp(p,k,S*S);m=m.clampToRef(0,1,m);return{baseColor:m,metallic:S,roughness:1-P.glossiness}}_getPerceivedBrightness(P){return P?Math.sqrt(.299*P.r*P.r+.587*P.g*P.g+.114*P.b*P.b):0}_getMaxComponent(P){return P?Math.max(P.r,Math.max(P.g,P.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(P,e,n,H){const S=[],p={baseColor:P._albedoColor,metallic:P._metallic,roughness:P._roughness};if(H){P._albedoTexture&&S.push(this.exportTextureAsync(P._albedoTexture,e).then((P=>{P&&(n.baseColorTexture=P)})));const H=P._metallicTexture;H&&S.push(this.exportTextureAsync(H,e).then((P=>{P&&(n.metallicRoughnessTexture=P)})))}return S.length>0&&(this._exporter._materialNeedsUVsSet.add(P),await Promise.all(S)),p}_getTextureSampler(P){const e={};if(!P||!(P instanceof V.e))return e;const n=this._getGLTFTextureWrapMode(P.wrapU);10497!==n&&(e.wrapS=n);const H=this._getGLTFTextureWrapMode(P.wrapV);switch(10497!==H&&(e.wrapT=H),P.samplingMode){case V.e.LINEAR_LINEAR:e.magFilter=9729,e.minFilter=9729;break;case V.e.LINEAR_NEAREST:e.magFilter=9729,e.minFilter=9728;break;case V.e.NEAREST_LINEAR:e.magFilter=9728,e.minFilter=9729;break;case V.e.NEAREST_LINEAR_MIPLINEAR:e.magFilter=9728,e.minFilter=9987;break;case V.e.NEAREST_NEAREST:e.magFilter=9728,e.minFilter=9728;break;case V.e.NEAREST_LINEAR_MIPNEAREST:e.magFilter=9728,e.minFilter=9985;break;case V.e.LINEAR_NEAREST_MIPNEAREST:e.magFilter=9729,e.minFilter=9984;break;case V.e.LINEAR_NEAREST_MIPLINEAR:e.magFilter=9729,e.minFilter=9986;break;case V.e.NEAREST_NEAREST_MIPLINEAR:e.magFilter=9728,e.minFilter=9986;break;case V.e.LINEAR_LINEAR_MIPLINEAR:e.magFilter=9729,e.minFilter=9987;break;case V.e.LINEAR_LINEAR_MIPNEAREST:e.magFilter=9729,e.minFilter=9985;break;case V.e.NEAREST_NEAREST_MIPNEAREST:e.magFilter=9728,e.minFilter=9984}return e}_getGLTFTextureWrapMode(P){switch(P){case V.e.WRAP_ADDRESSMODE:return 10497;case V.e.CLAMP_ADDRESSMODE:return 33071;case V.e.MIRROR_ADDRESSMODE:return 33648;default:return S.Tools.Error(`Unsupported Texture Wrap Mode ${P}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(P,e,n,H){const S={diffuseColor:P._albedoColor,specularColor:P._reflectivityColor,glossiness:P._microSurface},p=P._albedoTexture,k=P._reflectivityTexture,m=P._useMicroSurfaceFromReflectivityMapAlpha;if(k&&!m)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((p||k)&&H){this._exporter._materialNeedsUVsSet.add(P);const H=this._exportTextureSampler(p||k),m=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(p,k,S,e),t=this._exporter._textures;if(m.baseColorTextureData){const P=this._exportImage(`baseColor${t.length}`,e,m.baseColorTextureData);n.baseColorTexture=this._exportTextureInfo(P,H,null===p||void 0===p?void 0:p.coordinatesIndex)}if(m.metallicRoughnessTextureData){const P=this._exportImage(`metallicRoughness${t.length}`,e,m.metallicRoughnessTextureData);n.metallicRoughnessTexture=this._exportTextureInfo(P,H,null===k||void 0===k?void 0:k.coordinatesIndex)}return m}return this._convertSpecularGlossinessToMetallicRoughness(S)}async exportPBRMaterialAsync(P,e,n){const H={},S={name:P.name},p=P.isMetallicWorkflow();if(p){const e=P._albedoColor,n=P.alpha;e&&(H.baseColorFactor=[e.r,e.g,e.b,n])}const k=p?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(P,e,H,n):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(P,e,H,n);await this._setMetallicRoughnessPbrMaterialAsync(k,P,S,H,e,n),await this._finishMaterialAsync(S,P,e);const m=this._exporter._materials;return m.push(S),m.length-1}async _setMetallicRoughnessPbrMaterialAsync(P,e,n,H,p,k){if(o(n,e),P.baseColor.equalsWithEpsilon(N,b)&&I.WithinEpsilon(e.alpha,1,b)||(H.baseColorFactor=[P.baseColor.r,P.baseColor.g,P.baseColor.b,e.alpha]),null!=P.metallic&&1!==P.metallic&&(H.metallicFactor=P.metallic),null!=P.roughness&&1!==P.roughness&&(H.roughnessFactor=P.roughness),null==e.ip||e.ip||(e._twoSidedLighting||S.Tools.Warn(e.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),n.doubleSided=!0),k){const P=[],H=e._bumpTexture;H&&P.push(this.exportTextureAsync(H,p).then((P=>{P&&(n.normalTexture=P,1!==H.level&&(n.normalTexture.scale=H.level))})));const S=e._ambientTexture;S&&P.push(this.exportTextureAsync(S,p).then((P=>{if(P){const H={index:P.index,texCoord:P.texCoord,extensions:P.extensions};n.occlusionTexture=H;const S=e._ambientTextureStrength;S&&(H.strength=S)}})));const k=e._emissiveTexture;k&&P.push(this.exportTextureAsync(k,p).then((P=>{P&&(n.emissiveTexture=P)}))),P.length>0&&(this._exporter._materialNeedsUVsSet.add(e),await Promise.all(P))}const m=e._emissiveColor;m.equalsWithEpsilon(Q,b)||(n.emissiveFactor=m.fe()),n.pbrMetallicRoughness=H}_getPixelsFromTextureAsync(P){return function(P){switch(P){case B.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case B.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case B.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case B.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case B.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case B.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case B.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case B.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case B.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case B.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case B.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case B.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case B.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(P.textureFormat)?(0,O.g)(P,P._texture.width,P._texture.height):(P.textureType,B.c.TEXTURETYPE_UNSIGNED_BYTE,P.readPixels())}async exportTextureAsync(P,e){const n=this._exporter._extensionsPreExportTextureAsync("exporter",P,e);return n?await n.then((async n=>n?await this._exportTextureInfoAsync(n,e):await this._exportTextureInfoAsync(P,e))):await this._exportTextureInfoAsync(P,e)}async _exportTextureInfoAsync(P,e){let n=this._textureMap.get(P);if(!n){const H=await this._getPixelsFromTextureAsync(P);if(!H)return null;const p=this._exportTextureSampler(P),k=P.mimeType;if(k)switch(k){case"image/jpeg":case"image/png":case"image/webp":e=k;break;default:S.Tools.Warn(`Unsupported media type: ${k}. Exporting texture as PNG.`)}const m=this._internalTextureToImage,t=P.getInternalTexture().uniqueId;m[t]||(m[t]={});let C=m[t][e];if(void 0===C){const n=P.getSize();C=(async()=>{const S=await this._getImageDataAsync(H,n.width,n.height,e);return this._exportImage(P.name,e,S)})(),m[t][e]=C}n=this._exportTextureInfo(await C,p,P.coordinatesIndex),this._textureMap.set(P,n),this._exporter._extensionsPostExportTextures("exporter",n,P)}return n}_exportImage(P,e,n){const H=this._exporter._images;let p;if(this._exporter._shouldUseGlb){p={name:P,mimeType:e,bufferView:void 0};const H=this._exporter._bufferManager.createBufferView(new Uint8Array(n));this._exporter._bufferManager.setBufferView(p,H)}else{const k=P.replace(/\.\/|\/|\.\\|\\/g,"_"),m=function(P){switch(P){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(e);let t=k+m;H.some((P=>P.uri===t))&&(t=`${k}_${S.Tools.RandomId()}${m}`),p={name:P,uri:t},this._exporter._imageData[t]={data:n,mimeType:e}}return H.push(p),H.length-1}_exportTextureInfo(P,e,n){const H=this._exporter._textures;let S=H.findIndex((n=>n.sampler==e&&n.source===P));-1===S&&(S=H.length,H.push({source:P,sampler:e}));const p={index:S};return n&&(p.texCoord=n),p}_exportTextureSampler(P){const e=this._getTextureSampler(P),n=this._exporter._samplers,H=n.findIndex((P=>P.minFilter===e.minFilter&&P.magFilter===e.magFilter&&P.wrapS===e.wrapS&&P.wrapT===e.wrapT));return-1!==H?H:(n.push(e),n.length-1)}}var f=n(11225),Z=n(10988),v=n(11603),u=n(11140);const W=H.Ie.Zero(),U=H.Quaternion.Identity(),a=H.Ie.One(),L=new H.Ie(-1,1,1);function s(P,e){const{byteOffset:n,byteStride:H,type:S,normalized:p}=P,k=P.getSize(),m=e.reduce(((P,e)=>e.getTotalVertices()>P?e.getTotalVertices():P),-Number.MAX_VALUE);return{byteOffset:n,byteStride:H,componentCount:k,type:S,count:m*k,normalized:p,totalVertices:m,kind:P.getKind()}}function E(P){switch(P){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function X(P){switch(P){case R.g.PositionKind:case R.g.NormalKind:case R.g.TangentKind:case R.g.ColorKind:case R.g.MatricesIndicesKind:case R.g.MatricesIndicesExtraKind:case R.g.MatricesWeightsKind:case R.g.MatricesWeightsExtraKind:case R.g.UVKind:case R.g.UV2Kind:case R.g.UV3Kind:case R.g.UV4Kind:case R.g.UV5Kind:case R.g.UV6Kind:return!0}return!1}function x(P){switch(P){case p.c.TriangleFillMode:return 4;case p.c.TriangleStripDrawMode:return 5;case p.c.TriangleFanDrawMode:return 6;case p.c.PointListDrawMode:case p.c.PointFillMode:return 0;case p.c.LineLoopDrawMode:return 2;case p.c.LineListDrawMode:return 1;case p.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${P}`)}function M(P){const e=Math.sqrt(P.x*P.x+P.y*P.y+P.z*P.z);e>0&&(P.x/=e,P.y/=e,P.z/=e)}function K(P){return P.x*=-1,P}function h(P){if(P.x*P.x+P.y*P.y>.5){const e=Math.abs(P.x),n=Math.abs(P.y);if(e>n){const n=Math.sign(P.x);P.x=e,P.y*=-n,P.z*=-n,P.w*=n}else{const e=Math.sign(P.y);P.x*=-e,P.y=n,P.z*=e,P.w*=-e}}else{const e=Math.abs(P.z),n=Math.abs(P.w);if(e>n){const n=Math.sign(P.z);P.x*=-n,P.y*=n,P.z=e,P.w*=-n}else{const e=Math.sign(P.w);P.x*=e,P.y*=-e,P.z*=-e,P.w=n}}return P}function D(P){P.dp(-P.z,P.w,P.x,-P.y)}function PP(P,e){const n=H.Ie.FromArrayToRef(e.translation||[0,0,0],0,H.TmpVectors.Ie[0]),S=H.Quaternion.FromArrayToRef(e.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[0]),p=H.Matrix.ComposeToRef(a,S,n,H.TmpVectors.Matrix[0]),k=H.Ie.FromArrayToRef(P.translation||[0,0,0],0,H.TmpVectors.Ie[2]),m=H.Quaternion.FromArrayToRef(P.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[1]),t=H.Matrix.ComposeToRef(a,m,k,H.TmpVectors.Matrix[1]);p.multiplyToRef(t,t),t.decompose(void 0,S,n),n.equalsWithEpsilon(W,u.c)?delete e.translation:e.translation=n.fe(),S.equalsWithEpsilon(U,u.c)?delete e.rotation:e.rotation=S.fe(),e.scale&&delete e.scale}function eP(P,e){if(!(e instanceof q.e))return!1;if(!(1===e.getChildren().length&&0===P.getChildren().length&&P.parent===e))return!1;const n=P.BP(),H=P instanceof v.e&&!n.useRightHandedSystem?L:a;return!!e.Up.equalsWithEpsilon(H,u.c)||(Z.c.Warn(`Cannot collapse node ${P.name} into parent node ${e.name} with modified scaling.`),!1)}function nP(P){if(P instanceof Array){const e=new Float32Array(P);return new Uint8Array(e.buffer,e.byteOffset,e.byteLength)}return ArrayBuffer.isView(P)?new Uint8Array(P.buffer,P.byteOffset,P.byteLength):new Uint8Array(P)}function HP(P,e){for(const[n,H]of Object.entries(P)){const S=e[n];(Array.isArray(H)&&Array.isArray(S)&&SP(H,S)||H===S)&&delete P[n]}return P}function SP(P,e){return P.length===e.length&&P.every(((P,n)=>P===e[n]))}const pP=H.Matrix.Compose(new H.Ie(-1,1,1),H.Quaternion.Identity(),H.Ie.Zero());function kP(P,e){if(!(P instanceof q.e))return!1;if(e){if(!P.getWorldMatrix().equalsWithEpsilon(H.Matrix.IdentityReadOnly,u.c))return!1}else{if(!P.getWorldMatrix().multiplyToRef(pP,H.TmpVectors.Matrix[0]).equalsWithEpsilon(H.Matrix.IdentityReadOnly,u.c))return!1}return!(P instanceof A.c&&P.en)}const mP=new Map([[Int8Array,(P,e,n)=>P.setInt8(e,n)],[Uint8Array,(P,e,n)=>P.setUint8(e,n)],[Uint8ClampedArray,(P,e,n)=>P.setUint8(e,n)],[Int16Array,(P,e,n)=>P.setInt16(e,n,!0)],[Uint16Array,(P,e,n)=>P.setUint16(e,n,!0)],[Int32Array,(P,e,n)=>P.setInt32(e,n,!0)],[Uint32Array,(P,e,n)=>P.setUint32(e,n,!0)],[Float32Array,(P,e,n)=>P.setFloat32(e,n,!0)],[Float64Array,(P,e,n)=>P.setFloat64(e,n,!0)]]);class tP{writeTypedArray(P){this._checkGrowBuffer(P.byteLength);const e=mP.get(P.constructor);for(let n=0;n<P.length;n++)e(this._dataView,this._byteOffset,P[n]),this._byteOffset+=P.BYTES_PER_ELEMENT}constructor(P){this._data=new Uint8Array(P),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(P){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,P),this._byteOffset++}writeInt8(P){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,P),this._byteOffset++}writeInt16(P){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,P,!0),this._byteOffset+=2}writeUInt16(P){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,P,!0),this._byteOffset+=2}writeInt32(P){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,P,!0),this._byteOffset+=4}writeUInt32(P){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat32(P){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,P,!0),this._byteOffset+=4}writeFloat64(P){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,P,!0),this._byteOffset+=8}_checkGrowBuffer(P){const e=this.byteOffset+P;if(e>this._data.byteLength){const P=new Uint8Array(2*e);P.set(this._data),this._data=P,this._dataView=new DataView(this._data.buffer)}}}function CP(P){return P%4===0?4:P%2===0?2:1}class RP{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(P){let e=0;this._bufferViewToData.forEach((P=>{e+=P.byteLength}));const n=new tP(e),H=Array.from(this._bufferViewToData.keys()).sort(((P,e)=>CP(e.byteLength)-CP(P.byteLength)));for(const S of H){S.byteOffset=n.byteOffset,P.push(S);const e=P.length-1,H=this.getPropertiesWithBufferView(S);for(const P of H)P.bufferView=e;n.writeTypedArray(this._bufferViewToData.get(S)),this._bufferViewToData.delete(S)}return n.getOutputData()}createBufferView(P,e){const n={buffer:0,byteOffset:void 0,byteLength:P.byteLength,byteStride:e};return this._bufferViewToData.set(n,P),n}createAccessor(P,e,n,H,S,p,k){this._verifyBufferView(P);const m={bufferView:void 0,componentType:n,count:H,type:e,min:null===p||void 0===p?void 0:p.min,max:null===p||void 0===p?void 0:p.max,normalized:k,byteOffset:S};return this.setBufferView(m,P),this._accessorToBufferView.set(m,P),m}setBufferView(P,e){this._verifyBufferView(e);this.getPropertiesWithBufferView(e).push(P)}removeBufferView(P){const e=this.getPropertiesWithBufferView(P);for(const n of e)void 0!==n.bufferView&&delete n.bufferView;this._bufferViewToData.delete(P),this._bufferViewToProperties.delete(P),this._accessorToBufferView.forEach(((e,n)=>{e===P&&(void 0!==n.byteOffset&&delete n.byteOffset,this._accessorToBufferView.delete(n))}))}getBufferView(P){const e=this._accessorToBufferView.get(P);return this._verifyBufferView(e),e}getPropertiesWithBufferView(P){return this._verifyBufferView(P),this._bufferViewToProperties.set(P,this._bufferViewToProperties.get(P)??[]),this._bufferViewToProperties.get(P)}getData(P){return this._verifyBufferView(P),this._bufferViewToData.get(P)}_verifyBufferView(P){if(void 0===P||!this._bufferViewToData.has(P))throw new Error(`BufferView ${P} not found in BufferManager.`)}}var qP,AP=n(11558),FP=n(11582),YP=n(11605),jP=n(11490),zP=n(11641),wP=n(11656),JP=n(11552),IP=n(11658);!function(P){P[P.INTANGENT=0]="INTANGENT",P[P.OUTTANGENT=1]="OUTTANGENT"}(qP||(qP={}));class OP{static _IsTransformable(P){return P&&(P instanceof q.e||P instanceof AP.d||P instanceof IP.c)}static _CreateNodeAnimation(P,e,n,H,p){if(this._IsTransformable(P)){const k=[],m=[],t=e.getKeys(),C=OP._CalculateMinMaxKeyFrames(t),R=OP._DeduceInterpolation(t,n,H),q=R.interpolationType,A=R.shouldBakeAnimation;if(A?OP._CreateBakedAnimation(P,e,n,C.min,C.max,e.framePerSecond,p,k,m,C,H):"LINEAR"===q||"STEP"===q?OP._CreateLinearOrStepAnimation(P,e,n,k,m,H):"CUBICSPLINE"===q?OP._CreateCubicSplineAnimation(P,e,n,k,m,H):OP._CreateBakedAnimation(P,e,n,C.min,C.max,e.framePerSecond,p,k,m,C,H),k.length&&m.length){return{inputs:k,outputs:m,samplerInterpolation:q,inputsMin:A?C.min:S.Tools.FloatRound(C.min/e.framePerSecond),inputsMax:A?C.max:S.Tools.FloatRound(C.max/e.framePerSecond)}}}return null}static _DeduceAnimationInfo(P){let e=null,n="VEC3",H=!1;const p=P.targetProperty.split(".");switch(p[0]){case"Up":e="scale";break;case"position":e="translation";break;case"rotation":n="VEC4",e="rotation";break;case"rotationQuaternion":n="VEC4",H=!0,e="rotation";break;case"influence":n="SCALAR",e="weights";break;default:S.Tools.Error(`Unsupported animatable property ${p[0]}`)}return e?{animationChannelTargetPath:e,dataAccessorType:n,useQuaternion:H}:(S.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(P,e,n,H,S,p,k,m,t,C,R){let q;if(OP._IsTransformable(P)&&P.animations)for(const A of P.animations){if(R&&!R(A))continue;const S=OP._DeduceAnimationInfo(A);S&&(q={name:A.name,samplers:[],channels:[]},OP._AddAnimation(`${A.name}`,A.hasRunningRuntimeAnimations?e:q,P,A,S.dataAccessorType,S.animationChannelTargetPath,H,p,k,m,S.useQuaternion,t,C),q.samplers.length&&q.channels.length&&n.push(q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(P,e,n,H,S,p,k,m,t,C,R){let q;if(P instanceof JP.b){const S=P.morphTargetManager;if(S)for(let A=0;A<S.numTargets;++A){const F=S.getTarget(A);for(const Y of F.animations){if(R&&!R(Y))continue;const F=new zP.e(`${Y.name}`,"influence",Y.framePerSecond,Y.dataType,Y.loopMode,Y.enableBlending),j=[],z=Y.getKeys();for(let P=0;P<z.length;++P){const e=z[P];for(let P=0;P<S.numTargets;++P)P==A?j.push(e):j.push({frame:e.frame,value:0})}F.setKeys(j);const w=OP._DeduceAnimationInfo(F);w&&(q={name:F.name,samplers:[],channels:[]},OP._AddAnimation(Y.name,Y.hasRunningRuntimeAnimations?e:q,P,F,w.dataAccessorType,w.animationChannelTargetPath,H,p,k,m,w.useQuaternion,t,C,S.numTargets),q.samplers.length&&q.channels.length&&n.push(q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(P,e,n,H,S,p,k,m,t){let C;if(P.animationGroups){const q=P.animationGroups;for(const A of q){const q=new Map,F=new Map,Y=new Set,j=A.to-A.from;C={name:A.name,channels:[],samplers:[]};for(let e=0;e<A.targetedAnimations.length;++e){const j=A.targetedAnimations[e],z=j.target,w=j.animation;if(t&&!t(w))continue;const J=m.has(z);if(this._IsTransformable(z)||1===z.length&&this._IsTransformable(z[0])){const P=OP._DeduceAnimationInfo(j.animation);if(P){const e=this._IsTransformable(z)?z:this._IsTransformable(z[0])?z[0]:null;e&&OP._AddAnimation(`${w.name}`,C,e,w,P.dataAccessorType,P.animationChannelTargetPath,n,H,S,p,P.useQuaternion,k,J)}}else if(z instanceof wP.b||1===z.length&&z[0]instanceof wP.b){if(OP._DeduceAnimationInfo(j.animation)){const e=z instanceof wP.b?z:z[0];if(e){const n=P.morphTargetManagers.find((P=>{for(let n=0;n<P.numTargets;++n)if(P.getTarget(n)===e)return!0;return!1}));if(n){const H=P.meshes.find((P=>P.morphTargetManager===n));var R;if(H)q.has(H)||q.set(H,new Map),null===(R=q.get(H))||void 0===R||R.set(e,w),Y.add(H),F.set(H,w)}}}}}Y.forEach((P=>{const e=P.morphTargetManager;let m=null;const t=[],R=F.get(P).getKeys(),Y=R.length;for(let n=0;n<Y;++n)for(let H=0;H<e.numTargets;++H){const S=e.getTarget(H),p=q.get(P);if(p){const e=p.get(S);e?(m||(m=new zP.e(`${A.name}_${P.name}_MorphWeightAnimation`,"influence",e.framePerSecond,zP.e.ANIMATIONTYPE_FLOAT,e.loopMode,e.enableBlending)),t.push(e.getKeys()[n])):t.push({frame:A.from+j/Y*n,value:S.influence,inTangent:R[0].inTangent?0:void 0,outTangent:R[0].outTangent?0:void 0})}}m.setKeys(t);const z=OP._DeduceAnimationInfo(m);z&&OP._AddAnimation(`${A.name}_${P.name}_MorphWeightAnimation`,C,P,m,z.dataAccessorType,z.animationChannelTargetPath,n,H,S,p,z.useQuaternion,k,!1,null===e||void 0===e?void 0:e.numTargets)})),C.channels.length&&C.samplers.length&&e.push(C)}}}static _AddAnimation(P,e,n,S,p,k,m,t,C,R,q,A,F,Y){const j=OP._CreateNodeAnimation(n,S,k,q,A);let z,w,J,I,O,V;if(j){if(Y){let P=0,e=0;const n=[];for(;j.inputs.length>0;)e=j.inputs.shift(),P%Y==0&&n.push(e),P++;j.inputs=n}const P=m.get(n),S=new Float32Array(j.inputs);z=t.createBufferView(S),w=t.createAccessor(z,"SCALAR",5126,j.inputs.length,void 0,{min:[j.inputsMin],max:[j.inputsMax]}),R.push(w),J=R.length-1;const C=new H.Quaternion,q=new H.Ie,A=new H.Ie,i=n instanceof AP.d,B=E(p),l=new Float32Array(j.outputs.length*B);j.outputs.forEach((function(P,e){let n=P;switch(k){case"translation":F&&(H.Ie.FromArrayToRef(P,0,A),K(A),A.toArray(n));break;case"rotation":4===P.length?H.Quaternion.FromArrayToRef(P,0,C):(n=new Array(4),H.Ie.FromArrayToRef(P,0,q),H.Quaternion.FromEulerVectorToRef(q,C)),F&&(h(C),i&&D(C)),C.toArray(n)}l.set(n,e*B)})),z=t.createBufferView(l),w=t.createAccessor(z,p,5126,j.outputs.length),R.push(w),I=R.length-1,O={interpolation:j.samplerInterpolation,input:J,output:I},e.samplers.push(O),V={sampler:e.samplers.length-1,target:{node:P,path:k}},e.channels.push(V)}}static _CreateBakedAnimation(P,e,n,p,k,m,t,C,R,q,A){let F;const Y=H.Quaternion.Identity();let j,z=null,w=null,J=null,I=null,O=null,V=null;q.min=S.Tools.FloatRound(p/m);const i=e.getKeys();for(let H=0,B=i.length;H<B;++H){if(V=null,J=i[H],H+1<B)if(I=i[H+1],J.value.equals&&J.value.equals(I.value)||J.value===I.value){if(0!==H)continue;V=J.frame}else V=I.frame;else{if(O=i[H-1],J.value.equals&&J.value.equals(O.value)||J.value===O.value)continue;V=k}if(V)for(let H=J.frame;H<=V;H+=t){if(j=S.Tools.FloatRound(H/m),j===z)continue;z=j,w=j;const p={key:0,repeatCount:0,loopMode:e.loopMode};F=e._interpolate(H,p),OP._SetInterpolatedValue(P,F,j,e,n,Y,C,R,A)}}w&&(q.max=w)}static _ConvertFactorToVector3OrQuaternion(P,e,n,p,k){const m=OP._GetBasePositionRotationOrScale(e,p,k),t=n.targetProperty.split("."),C=t?t[1]:"",R=k?H.Quaternion.Qe(m).normalize():H.Ie.Qe(m);switch(C){case"x":case"y":case"z":R[C]=P;break;case"w":R.w=P;break;default:S.Tools.Error(`glTFAnimation: Unsupported component name "${C}"!`)}return R}static _SetInterpolatedValue(P,e,n,S,p,k,m,t,C){let R;m.push(n),"weights"!==p?(S.dataType===zP.e.ANIMATIONTYPE_FLOAT&&(e=this._ConvertFactorToVector3OrQuaternion(e,P,S,p,C)),"rotation"===p?(C?k=e:(R=e,H.Quaternion.RotationYawPitchRollToRef(R.y,R.x,R.z,k)),t.push(k.fe())):(R=e,t.push(R.fe()))):t.push([e])}static _CreateLinearOrStepAnimation(P,e,n,H,S,p){for(const k of e.getKeys())H.push(k.frame/e.framePerSecond),OP._AddKeyframeValue(k,e,S,n,P,p)}static _CreateCubicSplineAnimation(P,e,n,H,S,p){e.getKeys().forEach((function(k){H.push(k.frame/e.framePerSecond),OP._AddSplineTangent(qP.INTANGENT,S,n,"CUBICSPLINE",k,p),OP._AddKeyframeValue(k,e,S,n,P,p),OP._AddSplineTangent(qP.OUTTANGENT,S,n,"CUBICSPLINE",k,p)}))}static _GetBasePositionRotationOrScale(P,e,n){let S;if("rotation"===e)if(n){S=(P.rotationQuaternion??H.Quaternion.Identity()).fe()}else{S=(P.rotation??H.Ie.Zero()).fe()}else if("translation"===e){S=(P.position??H.Ie.Zero()).fe()}else{S=(P.Up??H.Ie.One()).fe()}return S}static _AddKeyframeValue(P,e,n,p,k,m){let t;const C=e.dataType;if(C===zP.e.ANIMATIONTYPE_VECTOR3){let e=P.value.fe();if("rotation"===p){const P=H.Ie.Qe(e);e=H.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).fe()}n.push(e)}else if(C===zP.e.ANIMATIONTYPE_FLOAT){if("weights"===p)n.push([P.value]);else if(t=this._ConvertFactorToVector3OrQuaternion(P.value,k,e,p,m),t){if("rotation"===p){const P=m?t:H.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).normalize();n.push(P.fe())}n.push(t.fe())}}else C===zP.e.ANIMATIONTYPE_QUATERNION?n.push(P.value.normalize().fe()):S.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(P,e,n){let H,S,p=!1;if("rotation"===e&&!n)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let k=0,m=P.length;k<m;++k)if(S=P[k],S.inTangent||S.outTangent)if(H){if("CUBICSPLINE"!==H){H="LINEAR",p=!0;break}}else H="CUBICSPLINE";else if(H){if("CUBICSPLINE"===H||S.interpolation&&1===S.interpolation&&"STEP"!==H){H="LINEAR",p=!0;break}}else H=S.interpolation&&1===S.interpolation?"STEP":"LINEAR";return H||(H="LINEAR"),{interpolationType:H,shouldBakeAnimation:p}}static _AddSplineTangent(P,e,n,S,p,k){let m;const t=P===qP.INTANGENT?p.inTangent:p.outTangent;if("CUBICSPLINE"===S){if("rotation"===n)if(t)if(k)m=t.fe();else{const P=t;m=H.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).fe()}else m=[0,0,0,0];else m="weights"===n?t?[t]:[0]:t?t.fe():[0,0,0];e.push(m)}}static _CalculateMinMaxKeyFrames(P){let e=1/0,n=-1/0;return P.forEach((function(P){e=Math.min(e,P.frame),n=Math.max(n,P.frame)})),{min:e,max:n}}}function VP(P,e,n,p,k,m){const t={attributes:{},influence:P.influence,name:P.name},C=e.en;if(!C)return S.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),t;const q=m?-1:1,A=H.Ie.Zero();let F=0,Y=0;if(P.hasPositions){const p=P.getPositions(),m=C.getVerticesData(R.g.PositionKind);if(m){const P=new Float32Array(m.length),e=[1/0,1/0,1/0],S=[-1/0,-1/0,-1/0];Y=m.length/3,F=0;for(let n=F;n<Y;++n){const k=H.Ie.Qe(m,3*n);H.Ie.Qe(p,3*n).subtractToRef(k,A),A.x*=q,e[0]=Math.min(e[0],A.x),S[0]=Math.max(S[0],A.x),e[1]=Math.min(e[1],A.y),S[1]=Math.max(S[1],A.y),e[2]=Math.min(e[2],A.z),S[2]=Math.max(S[2],A.z),P[3*n]=A.x,P[3*n+1]=A.y,P[3*n+2]=A.z}const C=n.createBufferView(P,12),R=n.createAccessor(C,"VEC3",5126,p.length/3,0,{min:e,max:S});k.push(R),t.attributes.POSITION=k.length-1}else S.Tools.Warn(`Morph target positions for mesh ${e.name} were not exported. Mesh does not have position vertex data`)}if(P.hasNormals){const p=P.getNormals(),m=C.getVerticesData(R.g.NormalKind);if(m){const P=new Float32Array(m.length);Y=m.length/3,F=0;for(let n=F;n<Y;++n){const e=H.Ie.Qe(m,3*n).normalize();H.Ie.Qe(p,3*n).normalize().subtractToRef(e,A),P[3*n]=A.x*q,P[3*n+1]=A.y,P[3*n+2]=A.z}const e=n.createBufferView(P,12),S=n.createAccessor(e,"VEC3",5126,p.length/3,0);k.push(S),t.attributes.NORMAL=k.length-1}else S.Tools.Warn(`Morph target normals for mesh ${e.name} were not exported. Mesh does not have normals vertex data`)}if(P.hasTangents){const p=P.getTangents(),m=C.getVerticesData(R.g.TangentKind);if(m){Y=m.length/4;const P=new Float32Array(3*Y);F=0;for(let n=F;n<Y;++n){const e=H.Ie.Qe(m,4*n);M(e);const S=H.Ie.Qe(p,3*n);M(S),S.subtractToRef(e,A),P[3*n]=A.x*q,P[3*n+1]=A.y,P[3*n+2]=A.z}const e=n.createBufferView(P,12),S=n.createAccessor(e,"VEC3",5126,Y,0);k.push(S),t.attributes.TANGENT=k.length-1}else S.Tools.Warn(`Morph target tangents for mesh ${e.name} were not exported. Mesh does not have tangents vertex data`)}if(P.hasColors){const p=P.getColors(),m=C.getVerticesData(R.g.ColorKind),q=C.getVertexBuffer(R.g.ColorKind);if(m&&q){const P=q.getSize();Y=m.length/P;const e=new Float32Array(Y*P);F=0;for(let n=F;n<Y;++n)if(3===P){const S=H.Ie.Qe(m,n*P);H.Ie.Qe(p,n*P).subtractToRef(S,A),e[3*n]=A.x,e[3*n+1]=A.y,e[3*n+2]=A.z}else if(4===P){const S=new H.Vector4,k=H.Vector4.Qe(m,n*P);H.Vector4.Qe(p,n*P).subtractToRef(k,S),e[4*n]=S.x,e[4*n+1]=S.y,e[4*n+2]=S.z,e[4*n+3]=S.w}else S.Tools.Warn(`Unsupported number of components for color attribute: ${P}`);const C=n.createBufferView(e,4*P),R=n.createAccessor(C,3===P?"VEC3":"VEC4",5126,Y,0);k.push(R),t.attributes.COLOR_0=k.length-1}else S.Tools.Warn(`Morph target colors for mesh ${e.name} were not exported. Mesh does not have colors vertex data`)}return t}var iP=n(11664),BP=n(11511),lP=n(11499),bP=n(11096);class TP{}TP.DEFAULT_COLOR=z.Ne.White(),TP.DEFAULT_WIDTH_ATTENUATED=1,TP.DEFAULT_WIDTH=.1;var dP=n(11354),NP=n(11670);class QP{static ConvertPoints(P,e){if(P.length&&Array.isArray(P)&&"number"===typeof P[0])return[P];if(P.length&&Array.isArray(P[0])&&"number"===typeof P[0][0])return P;if(P.length&&!Array.isArray(P[0])&&P[0]instanceof H.Ie){const e=[];for(let n=0;n<P.length;n++){const H=P[n];e.push(H.x,H.y,H.z)}return[e]}if(P.length>0&&Array.isArray(P[0])&&P[0].length>0&&P[0][0]instanceof H.Ie){const e=[],n=P;for(const P of n)e.push(P.flatMap((P=>[P.x,P.y,P.z])));return e}if(P instanceof Float32Array){if(null!==e&&void 0!==e&&e.floatArrayStride){const n=[],H=3*e.floatArrayStride;for(let e=0;e<P.length;e+=H){const S=new Array(H);for(let n=0;n<H;n++)S[n]=P[e+n];n.push(S)}return n}return[Array.from(P)]}if(P.length&&P[0]instanceof Float32Array){const e=[];for(const n of P)e.push(Array.from(n));return e}return[]}static OmitZeroLengthPredicate(P,e,n){const H=[];return e.be(P).lengthSquared()>0&&H.push([P,e]),n.be(e).lengthSquared()>0&&H.push([e,n]),P.be(n).lengthSquared()>0&&H.push([n,P]),0===H.length?null:H}static OmitDuplicatesPredicate(P,e,n,H){const S=[];return QP._SearchInPoints(P,e,H)||S.push([P,e]),QP._SearchInPoints(e,n,H)||S.push([e,n]),QP._SearchInPoints(n,P,H)||S.push([n,P]),0===S.length?null:S}static _SearchInPoints(P,e,n){for(const k of n)for(let n=0;n<k.length;n++){var H,S,p;if(null!==(H=k[n])&&void 0!==H&&H.equals(P))if(null!==(S=k[n+1])&&void 0!==S&&S.equals(e)||null!==(p=k[n-1])&&void 0!==p&&p.equals(e))return!0}return!1}static MeshesToLines(P,e){const n=[];for(let S=0;S<P.length;S++){const p=P[S],k=p.getVerticesData(R.g.PositionKind),m=p.ln();if(k&&m)for(let P=0,t=0;P<m.length;P++){const C=3*m[t++],R=3*m[t++],q=3*m[t++],A=new H.Ie(k[C],k[C+1],k[C+2]),F=new H.Ie(k[R],k[R+1],k[R+2]),Y=new H.Ie(k[q],k[q+1],k[q+2]);if(e){const H=e(A,F,Y,n,P,C,p,S,k,m);if(H)for(const P of H)n.push(P)}else n.push([A,F],[F,Y],[Y,A])}}return n}static ToVector3Array(P){if(Array.isArray(P[0])){const e=[],n=P;for(const P of n){const n=[];for(let e=0;e<P.length;e+=3)n.push(new H.Ie(P[e],P[e+1],P[e+2]));e.push(n)}return e}const e=P,n=[];for(let S=0;S<e.length;S+=3)n.push(new H.Ie(e[S],e[S+1],e[S+2]));return n}static ToNumberArray(P){return P.flatMap((P=>[P.x,P.y,P.z]))}static GetPointsCountInfo(P){const e=new Array(P.length);let n=0;for(let H=P.length;H--;)e[H]=P[H].length/3,n+=e[H];return{total:n,counts:e}}static GetLineLength(P){if(0===P.length)return 0;let e;e="number"===typeof P[0]?QP.ToVector3Array(P):P;const n=H.TmpVectors.Ie[0];let S=0;for(let H=0;H<e.length-1;H++){const P=e[H];S+=e[H+1].subtractToRef(P,n).length()}return S}static GetLineLengthArray(P){const e=new Float32Array(P.length/3);let n=0;for(let H=0,S=P.length/3-1;H<S;H++){let S=P[3*H+0],p=P[3*H+1],k=P[3*H+2];S-=P[3*H+3],p-=P[3*H+4],k-=P[3*H+5];n+=Math.sqrt(S*S+p*p+k*k),e[H+1]=n}return e}static SegmentizeSegmentByCount(P,e,n){const S=[],p=e.be(P),k=H.TmpVectors.Ie[0];k.zm(n);const m=H.TmpVectors.Ie[1];p.divideToRef(k,m);let t=P.clone();S.push(t);for(let H=0;H<n;H++)t=t.clone(),S.push(t.addInPlace(m));return S}static SegmentizeLineBySegmentLength(P,e){const n=P[0]instanceof H.Ie?QP.GetLineSegments(P):"number"===typeof P[0]?QP.GetLineSegments(QP.ToVector3Array(P)):P,S=[];for(const H of n)if(H.length>e){const P=QP.SegmentizeSegmentByCount(H.point1,H.point2,Math.ceil(H.length/e));for(const e of P)S.push(e)}else S.push(H.point1),S.push(H.point2);return S}static SegmentizeLineBySegmentCount(P,e){const n="number"===typeof P[0]?QP.ToVector3Array(P):P,H=QP.GetLineLength(n)/e;return QP.SegmentizeLineBySegmentLength(n,H)}static GetLineSegments(P){const e=[];for(let n=0;n<P.length-1;n++){const H=P[n],S=P[n+1],p=S.be(H).length();e.push({point1:H,point2:S,length:p})}return e}static GetMinMaxSegmentLength(P){const e=QP.GetLineSegments(P).sort((P=>P.length));return{min:e[0].length,max:e[e.length-1].length}}static GetPositionOnLineByVisibility(P,e,n){let S=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=e*n;let k=0,m=0;const t=P.length;for(let H=0;H<t;H++){if(p<=k+P[H].length){m=H;break}k+=P[H].length}const C=(p-k)/P[m].length;return P[m].point2.subtractToRef(P[m].point1,H.TmpVectors.Ie[0]),H.TmpVectors.Ie[1]=H.TmpVectors.Ie[0].multiplyByFloats(C,C,C),S||H.TmpVectors.Ie[1].addInPlace(P[m].point1),H.TmpVectors.Ie[1].clone()}static GetCircleLinePoints(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,S=arguments.length>3&&void 0!==arguments[3]?arguments[3]:P,p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/e;const k=[];for(let m=0;m<=e;m++)k.push(new H.Ie(Math.cos(m*p)*P,Math.sin(m*p)*S,n));return k}static GetBezierLinePoints(P,e,n,H){return dP.g.CreateQuadraticBezier(P,e,n,H).getPoints().flatMap((P=>[P.x,P.y,P.z]))}static GetArrowCap(P,e,n,H,S){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,k=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[P.clone(),P.add(e.multiplyByFloats(n,n,n))],widths:[H,S,p,k]}}static GetPointsFromText(P,e,n,H){let S=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const k=[],m=(0,NP.b)(P,e,n,H);for(const t of m){for(const P of t.paths){const e=[],n=P.getPoints();for(const P of n)e.push(P.x,P.y,S);k.push(e)}if(p)for(const P of t.holes){const e=[],n=P.getPoints();for(const P of n)e.push(P.x,P.y,S);k.push(e)}}return k}static Color3toRGBAUint8(P){const e=new Uint8Array(4*P.length);for(let n=0,H=0;n<P.length;n++)e[H++]=255*P[n].r,e[H++]=255*P[n].g,e[H++]=255*P[n].b,e[H++]=255;return e}static CreateColorsTexture(P,e,n,H){const S=H.getEngine().getCaps().maxTextureSize??1,p=e.length>S?S:e.length,k=Math.ceil(e.length/S);k>1&&(e=[...e,...Array(p*k-e.length).fill(e[0])]);const m=QP.Color3toRGBAUint8(e),t=new i.e(m,p,k,Y.b.TEXTUREFORMAT_RGBA,H,!1,!0,n);return t.name=P,t}static PrepareEmptyColorsTexture(P){if(!TP.EmptyColorsTexture){const e=new Uint8Array(4);TP.EmptyColorsTexture=new i.e(e,1,1,Y.b.TEXTUREFORMAT_RGBA,P,!1,!1,i.e.NEAREST_NEAREST),TP.EmptyColorsTexture.name="grlEmptyColorsTexture"}return TP.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var P;null===(P=TP.EmptyColorsTexture)||void 0===P||P.dispose(),TP.EmptyColorsTexture=null}static BooleanToNumber(P){return P?1:0}}class cP extends lP.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class rP extends BP.c{isCompatible(P){return!0}constructor(P,e,n){var S;n=n||{color:TP.DEFAULT_COLOR};const p=new cP;p.GREASED_LINE_HAS_COLOR=!!n.color&&!n.useColors,p.GREASED_LINE_SIZE_ATTENUATION=n.sizeAttenuation??!1,p.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===n.colorDistributionType,p.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(e??P.BP()).useRightHandedSystem,p.GREASED_LINE_CAMERA_FACING=n.cameraFacing??!0,super(P,rP.GREASED_LINE_MATERIAL_NAME,200,p,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(S=n)||void 0===S?void 0:S.forceGLSL)||rP.ForceGLSL,this._scene=e??P.BP(),this._engine=this._scene.getEngine(),this._cameraFacing=n.cameraFacing??!0,this.visibility=n.visibility??1,this.useDash=n.useDash??!1,this.dashRatio=n.dashRatio??.5,this.dashOffset=n.dashOffset??0,this.width=n.width?n.width:n.sizeAttenuation?TP.DEFAULT_WIDTH_ATTENUATED:TP.DEFAULT_WIDTH,this._sizeAttenuation=n.sizeAttenuation??!1,this.colorMode=n.colorMode??0,this._color=n.color??null,this.useColors=n.useColors??!1,this._colorsDistributionType=n.colorDistributionType??0,this.colorsSampling=n.colorsSampling??i.e.NEAREST_NEAREST,this._colors=n.dP??null,this.dashCount=n.dashCount??1,this.resolution=n.resolution??new H.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),n.colorsTexture?this.colorsTexture=n.colorsTexture:this._colors?this.colorsTexture=QP.CreateColorsTexture(`${P.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??TP.DEFAULT_COLOR,QP.PrepareEmptyColorsTexture(this._scene)),this._engine.ie.add((()=>{QP.DisposeEmptyColorsTexture()}))}getAttributes(P){P.push("grl_offsets"),P.push("grl_widths"),P.push("grl_colorPointers"),P.push("grl_counters"),this._cameraFacing?(P.push("grl_previousAndSide"),P.push("grl_nextAndCounters")):P.push("grl_slopes")}getSamplers(P){P.push("grl_colors")}getActiveTextures(P){this.colorsTexture&&P.push(this.colorsTexture)}getUniforms(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const e=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&e.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===P&&e.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:e,vertex:this._cameraFacing&&this._isGLSL(P)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(P)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(P){if(this._cameraFacing){P.he("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||P.he("viewProjection",this._scene.getTransformMatrix());const e=H.TmpVectors.Vector4[0];e.x=this._aspect,e.y=this._resolution.x,e.z=this._resolution.y,e.w=this.width,P.updateVector4("grl_aspect_resolution_lineWidth",e)}const e=H.TmpVectors.Vector4[0];e.x=QP.BooleanToNumber(this.useDash),e.y=this._dashArray,e.z=this.dashOffset,e.w=this.dashRatio,P.updateVector4("grl_dashOptions",e);const n=H.TmpVectors.Vector4[1];n.x=this.colorMode,n.y=this.visibility,n.z=this.colorsTexture?this.colorsTexture.getSize().width:0,n.w=QP.BooleanToNumber(this.useColors),P.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",n),this._color&&P.updateColor3("grl_singleColor",this._color);const S=this.colorsTexture??TP.EmptyColorsTexture;P.setTexture("grl_colors",S),P.updateFloat2("grl_textureSize",(null===S||void 0===S?void 0:S.getSize().width)??1,(null===S||void 0===S?void 0:S.getSize().height)??1)}prepareDefines(P,e,n){P.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,P.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,P.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,P.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=e.useRightHandedSystem,P.GREASED_LINE_CAMERA_FACING=this._cameraFacing,P.GREASED_LINE_USE_OFFSETS=!!n.offsets}getClassName(){return rP.GREASED_LINE_MATERIAL_NAME}getCustomCode(P){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(e)?function(P,e){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return e&&(P["!gl_Position\\=viewProjection\\*worldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(P,this._cameraFacing):function(P,e){if("vertex"===P){const P={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return e&&(P["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),P}return"fragment"===P?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(P,this._cameraFacing)}dispose(){var P;null===(P=this.colorsTexture)||void 0===P||P.dispose(),super.dispose()}get dP(){return this._colors}set dP(P){this.setColors(P)}setColors(P){var e;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(e=this._colors)||void 0===e?void 0:e.length)??0;var p;if(this._colors=P,null!==P&&0!==P.length){if(!n||H)if(this.colorsTexture&&S===P.length&&!H){const e=QP.Color3toRGBAUint8(P);this.colorsTexture.update(e)}else{var k;null===(k=this.colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=QP.CreateColorsTexture(`${this._material.name}-colors-texture`,P,this.colorsSampling,this._scene)}}else null===(p=this.colorsTexture)||void 0===p||p.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.markAllDefinesAsDirty()}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==P||null!==this._color&&null===P?(this._color=P,e||this.markAllDefinesAsDirty()):this._color=P}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(P){this._aspect=P.x/P.y,this._resolution=P}serialize(){const P=super.serialize(),e={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(e.dP=this._colors),this._color&&(e.color=this._color),P.greasedLineMaterialOptions=e,P}parse(P,e,n){var H;super.parse(P,e,n);const S=P.greasedLineMaterialOptions;null===(H=this.colorsTexture)||void 0===H||H.dispose(),S.color&&this.setColor(S.color,!0),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.dP&&(this.dP=S.dP),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),this.dP?this.colorsTexture=QP.CreateColorsTexture(`${this._material.name}-colors-texture`,this.dP,this.colorsSampling,e):QP.PrepareEmptyColorsTexture(e),this.markAllDefinesAsDirty()}copyTo(P){var e;const n=P;null===(e=n.colorsTexture)||void 0===e||e.dispose(),this._colors&&(n.colorsTexture=QP.CreateColorsTexture(`${n._material.name}-colors-texture`,this._colors,n.colorsSampling,this._scene)),n.setColor(this.color,!0),n.colorsDistributionType=this.colorsDistributionType,n.colorsSampling=this.colorsSampling,n.colorMode=this.colorMode,n.useColors=this.useColors,n.visibility=this.visibility,n.useDash=this.useDash,n.dashCount=this.dashCount,n.dashRatio=this.dashRatio,n.dashOffset=this.dashOffset,n.width=this.width,n.sizeAttenuation=this.sizeAttenuation,n.resolution=this.resolution,n.markAllDefinesAsDirty()}_isGLSL(P){return 0===P||this._forceGLSL}}rP.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",rP.ForceGLSL=!1,(0,bP.h)(`BABYLON.${rP.GREASED_LINE_MATERIAL_NAME}`,rP);var oP=n(11539),GP=n(10995),gP=n(11373),yP=n(11083);class fP extends gP.ShaderMaterial{constructor(P,e,S){const p=e.getEngine(),k=p.isWebGPU&&!(S.forceGLSL||fP.ForceGLSL),m=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];e.useRightHandedSystem&&m.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const t=["position","grl_widths","grl_offsets","grl_colorPointers"];S.cameraFacing?(m.push("GREASED_LINE_CAMERA_FACING"),t.push("grl_previousAndSide","grl_nextAndCounters")):(t.push("grl_slopes"),t.push("grl_counters"));const C=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(k||C.push("world","viewProjection","view","projection"),super(P,e,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:k?["Scene","Mesh"]:void 0,attributes:t,uniforms:C,samplers:k?[]:["grlColors"],defines:m,extraInitializationsAsync:async()=>{k?await Promise.all([n.e(66).then(n.bind(n,14194)),n.e(75).then(n.bind(n,14199))]):await Promise.all([n.e(69).then(n.bind(n,14203)),n.e(76).then(n.bind(n,14210))])},shaderLanguage:k?1:0}),this._color=z.Ne.White(),this._colorsDistributionType=0,this._colorsTexture=null,S=S||{color:TP.DEFAULT_COLOR},this.visibility=S.visibility??1,this.useDash=S.useDash??!1,this.dashRatio=S.dashRatio??.5,this.dashOffset=S.dashOffset??0,this.dashCount=S.dashCount??1,this.width=S.width?S.width:S.sizeAttenuation&&S.cameraFacing?TP.DEFAULT_WIDTH_ATTENUATED:TP.DEFAULT_WIDTH,this.sizeAttenuation=S.sizeAttenuation??!1,this.color=S.color??z.Ne.White(),this.useColors=S.useColors??!1,this.colorsDistributionType=S.colorDistributionType??0,this.colorsSampling=S.colorsSampling??i.e.NEAREST_NEAREST,this.colorMode=S.colorMode??0,this._colors=S.dP??null,this._cameraFacing=S.cameraFacing??!0,this.resolution=S.resolution??new H.Vector2(p.getRenderWidth(),p.getRenderHeight()),S.colorsTexture?this.colorsTexture=S.colorsTexture:this._colors?this.colorsTexture=QP.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,e):(this._color=this._color??TP.DEFAULT_COLOR,this.colorsTexture=QP.PrepareEmptyColorsTexture(e)),k){const P=new yP.d;P.setParameters(),P.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",P)}p.ie.add((()=>{QP.DisposeEmptyColorsTexture()}))}dispose(){var P;null===(P=this._colorsTexture)||void 0===P||P.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new H.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dP(){return this._colors}set dP(P){this.setColors(P)}setColors(P){var e;let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const S=(null===(e=this._colors)||void 0===e?void 0:e.length)??0;var p;if(this._colors=P,null!==P&&0!==P.length){if(!n||H)if(this._colorsTexture&&S===P.length&&!H){const e=QP.Color3toRGBAUint8(P);this._colorsTexture.update(e)}else{var k;null===(k=this._colorsTexture)||void 0===k||k.dispose(),this.colorsTexture=QP.CreateColorsTexture(`${this.name}-colors-texture`,P,this.colorsSampling,this.BP())}}else null===(p=this._colorsTexture)||void 0===p||p.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(P){this._colorsTexture=P,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(P){this._width=P,this.setFloat("grlWidth",P)}get useColors(){return this._useColors}set useColors(P){this._useColors=P,this.setFloat("grlUseColors",QP.BooleanToNumber(P))}get colorsSampling(){return this._colorsSampling}set colorsSampling(P){this._colorsSampling=P}get visibility(){return this._visibility}set visibility(P){this._visibility=P,this.setFloat("grlVisibility",P)}get useDash(){return this._useDash}set useDash(P){this._useDash=P,this.setFloat("grlUseDash",QP.BooleanToNumber(P))}get dashOffset(){return this._dashOffset}set dashOffset(P){this._dashOffset=P,this.setFloat("grlDashOffset",P)}get dashRatio(){return this._dashRatio}set dashRatio(P){this._dashRatio=P,this.setFloat("grlDashRatio",P)}get dashCount(){return this._dashCount}set dashCount(P){this._dashCount=P,this._dashArray=1/P,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(P){this._sizeAttenuation=P,this.setFloat("grlSizeAttenuation",QP.BooleanToNumber(P))}get color(){return this._color}set color(P){this.setColor(P)}setColor(P){P=P??TP.DEFAULT_COLOR,this._color=P,this.setColor3("grlColor",P)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(P){this._colorsDistributionType=P,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(P){this._colorMode=P,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(P){this._resolution=P,this.setVector2("grlResolution",P),this.setFloat("grlAspect",P.x/P.y)}serialize(){const P=super.serialize(),e={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(e.dP=this._colors),P.greasedLineMaterialOptions=e,P}parse(P,e,n){var H;const S=P.greasedLineMaterialOptions;null===(H=this._colorsTexture)||void 0===H||H.dispose(),S.color&&(this.color=S.color),S.colorDistributionType&&(this.colorsDistributionType=S.colorDistributionType),S.colorsSampling&&(this.colorsSampling=S.colorsSampling),S.colorMode&&(this.colorMode=S.colorMode),S.useColors&&(this.useColors=S.useColors),S.visibility&&(this.visibility=S.visibility),S.useDash&&(this.useDash=S.useDash),S.dashCount&&(this.dashCount=S.dashCount),S.dashRatio&&(this.dashRatio=S.dashRatio),S.dashOffset&&(this.dashOffset=S.dashOffset),S.width&&(this.width=S.width),S.sizeAttenuation&&(this.sizeAttenuation=S.sizeAttenuation),S.resolution&&(this.resolution=S.resolution),S.dP?this.colorsTexture=QP.CreateColorsTexture(`${this.name}-colors-texture`,S.dP,this.colorsSampling,this.BP()):this.colorsTexture=QP.PrepareEmptyColorsTexture(e),this._cameraFacing=S.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var ZP,vP,uP;fP.ForceGLSL=!1,function(P){P[P.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",P[P.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(ZP||(ZP={})),function(P){P[P.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",P[P.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",P[P.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vP||(vP={})),function(P){P[P.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",P[P.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",P[P.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",P[P.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",P[P.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(uP||(uP={}));class WP extends JP.b{constructor(P,e,n){super(P,e,null,null,!1,!1),this.name=P,this._options=n,this._lazy=!1,this._updatable=!1,this._engine=e.getEngine(),this._lazy=n.lazy??!1,this._updatable=n.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=n.colorPointers??[],this._widths=n.widths??new Array(n.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(P){let e=0;for(const H of this._points)e+=H.length;const n=e/3*2-this._widths.length;for(let H=0;H<n;H++)this._widths.push(P)}updateLazy(){var P,e;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(P=this._options.ribbonOptions)||void 0===P?void 0:P.smoothShading),!this.rP&&this.refreshBoundingInfo(),null===(e=this.greasedLineMaterial)||void 0===e||e.updateLazy()}addPoints(P,e){for(const n of P)this._points.push(n);this._lazy||this.setPoints(this._points,e)}dispose(P){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(P,e)}isLazy(){return this._lazy}get NP(){return this._uvs}set NP(P){this._uvs=P instanceof Float32Array?P:new Float32Array(P),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(P){this.material instanceof fP&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===P||void 0===P?void 0:P.length)>0),this._offsets=P,this._offsetsBuffer?this._offsetsBuffer.update(P):this._createOffsetsBuffer(P)}get widths(){return this._widths}set widths(P){this._widths=P,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(P)}get colorPointers(){return this._colorPointers}set colorPointers(P){this._colorPointers=P,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(P)}get greasedLineMaterial(){var P,e;if(this.material&&this.material instanceof fP)return this.material;const n=null===(P=this.material)||void 0===P||null===(e=P.pluginManager)||void 0===e?void 0:e.getPlugin(rP.GREASED_LINE_MATERIAL_NAME);return n||void 0}get points(){const P=[];return GP.e.DeepCopy(this._points,P),P}setPoints(P,e){this._points=QP.ConvertPoints(P,(null===e||void 0===e?void 0:e.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==e&&void 0!==e&&e.colorPointers||this._updateColorPointers(),this._setPoints(this._points,e)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,NP:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(P){super.serialize(P),P.type=this.getClassName(),P.lineOptions=this._createLineOptions()}_createVertexBuffers(){let P=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const e=new oP.e;return e.bP=this._vertexPositions,e.indices=this._indices,e.NP=this._uvs,P&&(e.TP=[],oP.e.ComputeNormals(this._vertexPositions,this._indices,e.TP)),e.cP(this,this._options.updatable),e}_createOffsetsBuffer(P){const e=this._scene.getEngine(),n=new R.d(e,P,this._updatable,3);this.setVerticesBuffer(n.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=n}}class UP{constructor(P,e){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=P,this.wasAddedByNoopNode=e}getIndicesAccessor(P,e,n,H,S){var p,k,m,t;return null===(p=this._indicesAccessorMap.get(P))||void 0===p||null===(k=p.get(e))||void 0===k||null===(m=k.get(n))||void 0===m||null===(t=m.get(H))||void 0===t?void 0:t.get(S)}setIndicesAccessor(P,e,n,H,S,p){let k=this._indicesAccessorMap.get(P);k||(k=new Map,this._indicesAccessorMap.set(P,k));let m=k.get(e);m||(m=new Map,k.set(e,m));let t=m.get(n);t||(t=new Map,m.set(n,t));let C=t.get(H);C||(C=new Map,t.set(H,C)),C.set(S,p)}pushExportedNode(P){this._exportedNodes.has(P)||this._exportedNodes.add(P)}getNodesSet(){return this._exportedNodes}getVertexBufferView(P){return this._vertexBufferViewMap.get(P)}setVertexBufferView(P,e){this._vertexBufferViewMap.set(P,e)}setRemappedBufferView(P,e,n){this._remappedBufferView.set(P,new Map),this._remappedBufferView.get(P).set(e,n)}getRemappedBufferView(P,e){var n;return null===(n=this._remappedBufferView.get(P))||void 0===n?void 0:n.get(e)}getVertexAccessor(P,e,n){var H,S;return null===(H=this._vertexAccessorMap.get(P))||void 0===H||null===(S=H.get(e))||void 0===S?void 0:S.get(n)}setVertexAccessor(P,e,n,H){let S=this._vertexAccessorMap.get(P);S||(S=new Map,this._vertexAccessorMap.set(P,S));let p=S.get(e);p||(p=new Map,S.set(e,p)),p.set(n,H)}hasVertexColorAlpha(P){return this._vertexMapColorAlpha.get(P)||!1}setHasVertexColorAlpha(P,e){return this._vertexMapColorAlpha.set(P,e)}getMesh(P){return this._meshMap.get(P)}setMesh(P,e){this._meshMap.set(P,e)}bindMorphDataToMesh(P,e){const n=this._meshMorphTargetMap.get(P)||[];this._meshMorphTargetMap.set(P,n),-1===n.indexOf(e)&&n.push(e)}getMorphTargetsFromMesh(P){return this._meshMorphTargetMap.get(P)}}class aP{_ApplyExtension(P,e,n,H){if(n>=e.length)return Promise.resolve(P);const S=H(e[n],P);return S?S.then((async P=>P?await this._ApplyExtension(P,e,n+1,H):null)):this._ApplyExtension(P,e,n+1,H)}_ApplyExtensions(P,e){const n=[];for(const H of aP._ExtensionNames)n.push(this._extensions[H]);return this._ApplyExtension(P,n,0,e)}_extensionsPreExportTextureAsync(P,e,n){return this._ApplyExtensions(e,((e,H)=>e.preExportTextureAsync&&e.preExportTextureAsync(P,H,n)))}_extensionsPostExportNodeAsync(P,e,n,H,S){return this._ApplyExtensions(e,((e,p)=>e.postExportNodeAsync&&e.postExportNodeAsync(P,p,n,H,S,this._bufferManager)))}_extensionsPostExportMaterialAsync(P,e,n){return this._ApplyExtensions(e,((e,H)=>e.postExportMaterialAsync&&e.postExportMaterialAsync(P,H,n)))}_extensionsPostExportMaterialAdditionalTextures(P,e,n){const H=[];for(const S of aP._ExtensionNames){const p=this._extensions[S];p.postExportMaterialAdditionalTextures&&H.push(...p.postExportMaterialAdditionalTextures(P,e,n))}return H}_extensionsPostExportTextures(P,e,n){for(const H of aP._ExtensionNames){const S=this._extensions[H];S.postExportTexture&&S.postExportTexture(P,e,n)}}_extensionsPostExportMeshPrimitive(P){for(const e of aP._ExtensionNames){const n=this._extensions[e];n.postExportMeshPrimitive&&n.postExportMeshPrimitive(P,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const P of aP._ExtensionNames){const e=this._extensions[P];e.preGenerateBinaryAsync&&await e.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(P){for(const e of aP._ExtensionNames){const n=this._extensions[e];n.enabled&&P(n)}}_extensionsOnExporting(){this._forEachExtensions((P=>{var e,n,H;P.wasUsed&&((e=this._glTF).extensionsUsed||(e.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(P.name)&&this._glTF.extensionsUsed.push(P.name),P.required&&((n=this._glTF).extensionsRequired||(n.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(P.name)&&this._glTF.extensionsRequired.push(P.name)),(H=this._glTF).extensions||(H.extensions={}),P.onExporting&&P.onExporting())}))}_loadExtensions(){for(const P of aP._ExtensionNames){const e=aP._ExtensionFactories[P](this);this._extensions[P]=e}}constructor(){let P=arguments.length>0&&void 0!==arguments[0]?arguments[0]:j.d.LastCreatedScene,e=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Y.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new y(this),this._extensions={},this._bufferManager=new RP,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!P)throw new Error("No scene available to export");this._babylonScene=P,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:P=>{var e;return null===P||void 0===P||null===(e=P.ce)||void 0===e?void 0:e.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...e},this._loadExtensions()}dispose(){for(const P in this._extensions){this._extensions[P].dispose()}}get options(){return this._options}static RegisterExtension(P,e){aP.UnregisterExtension(P)&&S.Tools.Warn(`Extension with the name ${P} already exists`),aP._ExtensionFactories[P]=e,aP._ExtensionNames.push(P)}static UnregisterExtension(P){if(!aP._ExtensionFactories[P])return!1;delete aP._ExtensionFactories[P];const e=aP._ExtensionNames.indexOf(P);return-1!==e&&aP._ExtensionNames.splice(e,1),!0}_generateJSON(P,e,n){const H={byteLength:P};return H.byteLength&&(this._glTF.buffers=[H]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Te=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(H.uri=e+".bin"),n?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(P){const e=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(e.byteLength,P,!0),H=new Blob([e],{type:"application/octet-stream"}),S=P+".gltf",p=P+".bin",k=new C;if(k.files[S]=n,k.files[p]=H,this._imageData)for(const m in this._imageData)k.files[m]=new Blob([this._imageData[m].data],{type:this._imageData[m].mimeType});return k}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(P){const e=P%4;return 0===e?e:4-e}async generateGLBAsync(P){this._shouldUseGlb=!0;const e=await this._generateBinaryAsync();this._extensionsOnExporting();const n=this._generateJSON(e.byteLength),H=P+".glb";let S,p=n.length;if("undefined"!==typeof TextEncoder){S=(new TextEncoder).encode(n),p=S.length}const k=this._getPadding(p),m=this._getPadding(e.byteLength),t=28+p+k+e.byteLength+m,R=new tP(t);if(R.writeUInt32(1179937895),R.writeUInt32(2),R.writeUInt32(t),R.writeUInt32(p+k),R.writeUInt32(1313821514),S)R.writeTypedArray(S);else{const P="_".charCodeAt(0);for(let e=0;e<p;++e){const H=n.charCodeAt(e);H!=n.codePointAt(e)?R.writeUInt8(P):R.writeUInt8(H)}}for(let C=0;C<k;++C)R.writeUInt8(32);R.writeUInt32(e.byteLength+m),R.writeUInt32(5130562),R.writeTypedArray(e);for(let C=0;C<m;++C)R.writeUInt8(0);const q=new C;return q.files[H]=new Blob([R.getOutputData()],{type:"application/octet-stream"}),q}_setNodeTransformation(P,e,n){if(e.getPivotPoint().equalsWithEpsilon(W,u.c)||S.Tools.Warn("Pivot points are not supported in the glTF serializer"),!e.position.equalsWithEpsilon(W,u.c)){const S=H.TmpVectors.Ie[0].p(e.position);n&&K(S),P.translation=S.fe()}e.Up.equalsWithEpsilon(a,u.c)||(P.scale=e.Up.fe());const p=e.rotationQuaternion||H.Quaternion.FromEulerAngles(e.rotation.x,e.rotation.y,e.rotation.z);p.equalsWithEpsilon(U,u.c)||(n&&h(p),P.rotation=p.normalize().fe())}_setCameraTransformation(P,e,n){if(!e.position.equalsWithEpsilon(W,u.c)){const S=H.TmpVectors.Ie[0].p(e.position);n&&K(S),P.translation=S.fe()}const S=e.rotationQuaternion||H.Quaternion.FromEulerAngles(e.rotation.x,e.rotation.y,e.rotation.z);n&&h(S),this._babylonScene.useRightHandedSystem||D(S),S.equalsWithEpsilon(U,u.c)||(P.rotation=S.fe())}_listAvailableCameras(){for(const P of this._babylonScene.cameras){const e={type:P.mode===AP.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(P.name&&(e.name=P.name),"perspective"===e.type)e.perspective={aspectRatio:P.getEngine().getAspectRatio(P),yfov:P.fovMode===AP.d.FOVMODE_VERTICAL_FIXED?P.fov:P.fov*P.getEngine().getAspectRatio(P),znear:P.Le,zfar:P.maxZ};else if("orthographic"===e.type){const n=P.orthoLeft&&P.orthoRight?.5*(P.orthoRight-P.orthoLeft):.5*P.getEngine().getRenderWidth(),H=P.orthoBottom&&P.orthoTop?.5*(P.orthoTop-P.orthoBottom):.5*P.getEngine().getRenderHeight();e.orthographic={xmag:n,ymag:H,znear:P.Le,zfar:P.maxZ}}this._camerasMap.set(P,e)}}_exportAndAssignCameras(){const P=Array.from(this._camerasMap.values());for(const e of P){const P=this._nodesCameraMap.get(e);if(void 0!==P){this._cameras.push(e);for(const e of P)e.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const e={joints:[]};this._skinMap.set(P,e)}}_exportAndAssignSkeletons(){for(const P of this._babylonScene.skeletons){if(P.bones.length<=0)continue;const e=this._skinMap.get(P);if(void 0==e)continue;const n={},H=[];let p=-1;for(let S=0;S<P.bones.length;++S){const e=P.bones[S],H=e.getIndex()??S;-1!==H&&(n[H]=e,H>p&&(p=H))}for(let P=0;P<=p;++P){const p=n[P];H.push(p.getAbsoluteInverseBindMatrix());const k=p.getTransformNode();if(null!==k){const P=this._nodeMap.get(k);k&&null!==P&&void 0!==P?e.joints.push(P):S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else S.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const k=this._nodesSkinMap.get(e);if(e.joints.length>0&&void 0!==k){const P=64*H.length,n=new Float32Array(P/4);H.forEach(((P,e)=>{n.set(P.m,16*e)}));const S=this._bufferManager.createBufferView(n);this._accessors.push(this._bufferManager.createAccessor(S,"MAT4",5126,H.length)),e.inverseBindMatrices=this._accessors.length-1,this._skins.push(e);for(const e of k)e.skin=this._skins.length-1}}}async _exportSceneAsync(){const P={nodes:[]};if(this._babylonScene.metadata){const e=this._options.metadataSelector(this._babylonScene.metadata);e&&(P.extras=e)}const e=new Array,n=new Array,H=new Array;for(const m of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&kP(m,this._babylonScene.useRightHandedSystem)?H.push(...m.getChildren()):this._babylonScene.useRightHandedSystem?e.push(m):n.push(m);this._listAvailableCameras(),this._listAvailableSkeletons();const S=new UP(!0,!1);P.nodes.push(...await this._exportNodesAsync(n,S));const p=new UP(!1,!1);P.nodes.push(...await this._exportNodesAsync(e,p));const k=new UP(!1,!0);P.nodes.push(...await this._exportNodesAsync(H,k)),P.nodes.length&&this._scenes.push(P),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&OP._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(P){let e=this._shouldExportNodeMap.get(P);return void 0===e&&(e=this._options.shouldExportNode(P),this._shouldExportNodeMap.set(P,e)),e}async _exportNodesAsync(P,e){const n=new Array;this._exportBuffers(P,e);for(const H of P)await this._exportNodeAsync(H,n,e);return n}_collectBuffers(P,e,n,H,S){if(this._shouldExportNode(P)&&P instanceof A.c&&P.en){const p=P.en.getVertexBuffers();if(p)for(const H in p){if(!X(H))continue;const k=p[H];S.setHasVertexColorAlpha(k,P.hasVertexAlpha);const m=k._buffer,t=e.get(m)||[];e.set(m,t),-1===t.indexOf(k)&&t.push(k);const C=n.get(k)||[];n.set(k,C),-1===C.indexOf(P)&&C.push(P)}const k=P.morphTargetManager;if(k)for(let e=0;e<k.numTargets;e++){const n=k.getTarget(e),S=H.get(n)||[];H.set(n,S),-1===S.indexOf(P)&&S.push(P)}}for(const p of P.getChildren())this._collectBuffers(p,e,n,H,S)}_exportBuffers(P,e){const n=new Map,H=new Map,S=new Map;for(const m of P)this._collectBuffers(m,n,H,S,e);const p=Array.from(n.keys());for(const m of p){const P=m.getData();if(!P)throw new Error("Buffer data is not available");const S=n.get(m);if(!S)continue;const p=S[0].byteStride;if(S.some((P=>P.byteStride!==p)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const k=nP(P).slice();for(const e of S){const P=H.get(e),{byteOffset:n,byteStride:S,componentCount:p,type:m,count:t,normalized:C,kind:q}=s(e,P);switch(q){case R.g.NormalKind:case R.g.TangentKind:(0,f.h)(k,n,S,p,m,t,C,(P=>{const e=Math.sqrt(P[0]*P[0]+P[1]*P[1]+P[2]*P[2]);if(e>0){const n=1/e;P[0]*=n,P[1]*=n,P[2]*=n}}));break;case R.g.ColorKind:{const e=P.filter((P=>P.material instanceof jP.de||null==P.material)).length;if(0==e)break;if(e!=P.length){Z.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}m==R.g.UNSIGNED_BYTE&&Z.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const H=new z.Ne,q=new z.wm,A=this._babylonScene.getEngine().useExactSrgbConversions;(0,f.h)(k,n,S,p,m,t,C,(P=>{3===P.length?(H.yn(P,0),H.toLinearSpaceToRef(H,A),H.toArray(P,0)):(q.yn(P,0),q.toLinearSpaceToRef(q,A),q.toArray(P,0))}))}}}if(e.convertToRightHanded){for(const P of S){const e=H.get(P),{byteOffset:n,byteStride:S,componentCount:p,type:m,count:t,normalized:C,kind:q}=s(P,e);switch(q){case R.g.PositionKind:case R.g.NormalKind:case R.g.TangentKind:(0,f.h)(k,n,S,p,m,t,C,(P=>{P[0]=-P[0]}))}}e.convertedToRightHandedBuffers.set(m,k)}const t=this._bufferManager.createBufferView(k,p);e.setVertexBufferView(m,t);const C=new Map;for(const e of S){const P=H.get(e),{kind:n,totalVertices:S}=s(e,P);switch(n){case R.g.MatricesIndicesKind:case R.g.MatricesIndicesExtraKind:if(e.type==R.g.FLOAT){const P=e.getFloatData(S);null!==P&&C.set(e,P)}}}0!==C.size&&Z.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const q=Array.from(C.keys());for(const n of q){const P=C.get(n);if(!P)continue;const H=P.some((P=>P>=256)),S=new(H?Uint16Array:Uint8Array)(P.length);for(let e=0;e<P.length;e++)S[e]=P[e];const p=this._bufferManager.createBufferView(S,4*(H?2:1));e.setRemappedBufferView(m,n,p)}}const k=Array.from(S.keys());for(const m of k){const P=S.get(m);if(!P)continue;const n=VP(m,P[0],this._bufferManager,this._bufferViews,this._accessors,e.convertToRightHanded);for(const H of P)e.bindMorphDataToMesh(H,n)}}async _exportNodeAsync(P,e,n){let H=this._nodeMap.get(P);if(void 0!==H)return void(e.includes(H)||e.push(H));const S=await this._createNodeAsync(P,n);if(S){H=this._nodes.length,this._nodes.push(S),this._nodeMap.set(P,H),n.pushExportedNode(P),e.push(H);const p={name:"runtime animations",channels:[],samplers:[]},k=[];this._babylonScene.animationGroups.length||(OP._CreateMorphTargetAnimationFromMorphTargetAnimations(P,p,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation),P.animations.length&&OP._CreateNodeAnimationFromNodeAnimations(P,p,k,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,n.convertToRightHanded,this._options.shouldExportAnimation)),p.channels.length&&p.samplers.length&&this._animations.push(p),k.forEach((P=>{P.channels.length&&P.samplers.length&&this._animations.push(P)}))}const p=S?[]:e;for(const k of P.getChildren())await this._exportNodeAsync(k,p,n);S&&p.length&&(S.children=p)}async _createNodeAsync(P,e){if(!this._shouldExportNode(P))return null;const n={};if(P.name&&(n.name=P.name),P.metadata){const e=this._options.metadataSelector(P.metadata);e&&(n.extras=e)}if(P instanceof q.e&&(this._setNodeTransformation(n,P,e.convertToRightHanded),P instanceof A.c)){const S=P instanceof F.b?P.sourceMesh:P;if(S.ye&&S.ye.length>0&&(n.mesh=await this._exportMeshAsync(S,e)),P.skeleton){const e=this._skinMap.get(P.skeleton);var H;if(void 0!==e)void 0===this._nodesSkinMap.get(e)&&this._nodesSkinMap.set(e,[]),null===(H=this._nodesSkinMap.get(e))||void 0===H||H.push(n)}}if(P instanceof v.e){const H=this._camerasMap.get(P);if(H){var S;void 0===this._nodesCameraMap.get(H)&&this._nodesCameraMap.set(H,[]),this._setCameraTransformation(n,P,e.convertToRightHanded);const k=P.parent;if(null!==k&&eP(P,k)){const P=this._nodeMap.get(k);if(void 0!==P){var p;const e=this._nodes[P];return PP(n,e),null===(p=this._nodesCameraMap.get(H))||void 0===p||p.push(e),null}}null===(S=this._nodesCameraMap.get(H))||void 0===S||S.push(n)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",n,P,this._nodeMap,e.convertToRightHanded)?n:(Z.c.Warn(`Not exporting node ${P.name}`),null)}_exportIndices(P,e,n,H,S,k,m,t,C){let R=P;C.mode=x(k);const q=m!==p.c.CounterClockWiseSideOrientation,A=!t.wasAddedByNoopNode&&q,F=function(P){switch(P){case p.c.TriangleFillMode:case p.c.TriangleStripDrawMode:case p.c.TriangleFanDrawMode:return!0}return!1}(k)&&A;if(F){if(k===p.c.TriangleStripDrawMode||k===p.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");C.mode=x(k);const m=e?new Uint32Array(H):new Uint16Array(H);if(P)for(let e=0;e+2<H;e+=3)m[e]=P[n+e]+S,m[e+1]=P[n+e+2]+S,m[e+2]=P[n+e+1]+S;else for(let P=0;P+2<H;P+=3)m[P]=P,m[P+1]=P+2,m[P+2]=P+1;R=m}else if(P&&0!==S){const p=e?new Uint32Array(H):new Uint16Array(H);for(let e=0;e<H;e++)p[e]=P[n+e]+S;R=p}if(R){let p=t.getIndicesAccessor(P,n,H,S,F);if(void 0===p){const k=function(P,e,n,H){if(P instanceof Uint16Array||P instanceof Uint32Array)return P;if(P instanceof Int32Array)return new Uint32Array(P.buffer,P.byteOffset,P.length);const S=P.slice(e,e+n);return H?new Uint32Array(S):new Uint16Array(S)}(R,0,H,e),m=this._bufferManager.createBufferView(k),C=e?5125:5123;this._accessors.push(this._bufferManager.createAccessor(m,"SCALAR",C,H,0)),p=this._accessors.length-1,t.setIndicesAccessor(P,n,H,S,F,p)}C.indices=p}}_exportVertexBuffer(P,e,n,H,S,p){const k=P.getKind();if(!X(k))return;if(k.startsWith("uv")&&!this._options.exportUnusedUVs&&(!e||!this._materialNeedsUVsSet.has(e)))return;let m=S.getVertexAccessor(P,n,H);if(void 0===m){const e=S.convertedToRightHandedBuffers.get(P._buffer)||P._buffer.getData(),p=k===R.g.PositionKind?function(P,e,n,H){const{byteOffset:S,byteStride:p,type:k,normalized:m}=e,t=e.getSize(),C=new Array(t).fill(1/0),R=new Array(t).fill(-1/0);return(0,f.h)(P,S+n*p,p,t,k,H*t,m,(P=>{for(let e=0;e<t;e++)C[e]=Math.min(C[e],P[e]),R[e]=Math.max(R[e],P[e])})),{min:C,max:R}}(e,P,n,H):void 0,t=(k===R.g.MatricesIndicesKind||k===R.g.MatricesIndicesExtraKind)&&P.type===R.g.FLOAT,C=t?R.g.UNSIGNED_BYTE:P.type,q=t?void 0:P.normalized,A=t?S.getRemappedBufferView(P._buffer,P):S.getVertexBufferView(P._buffer),F=P.byteOffset+n*P.byteStride;this._accessors.push(this._bufferManager.createAccessor(A,function(P,e){if(P==R.g.ColorKind)return e?"VEC4":"VEC3";switch(P){case R.g.PositionKind:case R.g.NormalKind:return"VEC3";case R.g.TangentKind:case R.g.MatricesIndicesKind:case R.g.MatricesIndicesExtraKind:case R.g.MatricesWeightsKind:case R.g.MatricesWeightsExtraKind:return"VEC4";case R.g.UVKind:case R.g.UV2Kind:case R.g.UV3Kind:case R.g.UV4Kind:case R.g.UV5Kind:case R.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${P}`)}(k,S.hasVertexColorAlpha(P)),C,H,F,p,q)),m=this._accessors.length-1,S.setVertexAccessor(P,n,H,m)}p.attributes[function(P){switch(P){case R.g.PositionKind:return"POSITION";case R.g.NormalKind:return"NORMAL";case R.g.TangentKind:return"TANGENT";case R.g.ColorKind:return"COLOR_0";case R.g.UVKind:return"TEXCOORD_0";case R.g.UV2Kind:return"TEXCOORD_1";case R.g.UV3Kind:return"TEXCOORD_2";case R.g.UV4Kind:return"TEXCOORD_3";case R.g.UV5Kind:return"TEXCOORD_4";case R.g.UV6Kind:return"TEXCOORD_5";case R.g.MatricesIndicesKind:return"JOINTS_0";case R.g.MatricesIndicesExtraKind:return"JOINTS_1";case R.g.MatricesWeightsKind:return"WEIGHTS_0";case R.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${P}`)}(k)]=m}async _exportMaterialAsync(P,e,n,H){let S=this._materialMap.get(P);if(void 0===S){const H=e&&Object.keys(e).some((P=>P.startsWith("uv")));if((P=P instanceof FP.c?P.Jm[n.materialIndex]:P)instanceof YP.b)S=await this._materialExporter.exportPBRMaterialAsync(P,"image/png",H);else{if(!(P instanceof jP.de))return void Z.c.Warn(`Unsupported material '${P.name}' with type ${P.getClassName()}`);S=await this._materialExporter.exportStandardMaterialAsync(P,"image/png",H)}this._materialMap.set(P,S)}H.material=S}async _exportMeshAsync(P,e){var n;let H=e.getMesh(P);if(void 0!==H)return H;const S={primitives:[]};H=this._meshes.length,this._meshes.push(S),e.setMesh(P,H);const k=P.isUnIndexed?null:P.ln(),m=null===(n=P.en)||void 0===n?void 0:n.getVertexBuffers(),t=e.getMorphTargetsFromMesh(P),C=P instanceof iP.d,R=P instanceof WP,q=P.ye;if(m&&q&&q.length>0)for(const Y of q){const n={attributes:{}},H=Y.yP()||this._babylonScene.defaultMaterial;if(R){var A,F;const e={name:H.name},S=P,p=z.Ne.White(),k=(null===(A=S.material)||void 0===A?void 0:A.alpha)??1,m=(null===(F=S.greasedLineMaterial)||void 0===F?void 0:F.color)??p;(!m.equalsWithEpsilon(p,u.c)||k<1)&&(e.pbrMetallicRoughness={baseColorFactor:[...m.fe(),k]}),this._materials.push(e),n.material=this._materials.length-1}else if(C){const e={name:H.name},S=P;(!S.color.equalsWithEpsilon(z.Ne.White(),u.c)||S.alpha<1)&&(e.pbrMetallicRoughness={baseColorFactor:[...S.color.fe(),S.alpha]}),this._materials.push(e),n.material=this._materials.length-1}else await this._exportMaterialAsync(H,m,Y,n);const q=C||R?p.c.LineListDrawMode:P.overrideRenderingFillMode??H.fillMode,j=H._getEffectiveOrientation(P);this._exportIndices(k,k?(0,f.c)(k,Y.indexCount,Y.indexStart,Y.verticesStart):Y.verticesCount>65535,k?Y.indexStart:Y.verticesStart,k?Y.indexCount:Y.verticesCount,-Y.verticesStart,q,j,e,n);for(const P of Object.values(m))this._exportVertexBuffer(P,H,Y.verticesStart,Y.verticesCount,e,n);if(t){n.targets=[];for(const P of t)n.targets.push(P.attributes)}S.primitives.push(n),this._extensionsPostExportMeshPrimitive(n)}if(t){S.weights=[],S.extras||(S.extras={}),S.extras.targetNames=[];for(const P of t)S.weights.push(P.influence),S.extras.targetNames.push(P.name)}return H}}aP._ExtensionNames=new Array,aP._ExtensionFactories={};class LP{static async GLTFAsync(P,e,n){n&&n.exportWithoutWaitingForScene||await P.whenReadyAsync();const H=new aP(P,n),S=await H.generateGLTFAsync(e.replace(/\.[^/.]+$/,""));return H.dispose(),S}static async GLBAsync(P,e,n){n&&n.exportWithoutWaitingForScene||await P.whenReadyAsync();const H=new aP(P,n),S=await H.generateGLBAsync(e.replace(/\.[^/.]+$/,""));return H.dispose(),S}}n(11684);const sP="EXT_mesh_gpu_instancing";class EP{constructor(P){this.name=sP,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(P,e,n,S,p,k){return await new Promise((P=>{if(e&&n instanceof JP.b&&n.hasThinInstances&&this._exporter){this._wasUsed=!0;const P=H.Ie.Zero(),S=H.Quaternion.Identity(),m=H.Ie.One(),t=n.thinInstanceGetWorldMatrices(),C=H.TmpVectors.Ie[2],R=H.TmpVectors.Quaternion[1],q=H.TmpVectors.Ie[3];let A=!1,F=!1,Y=!1;const j=new Float32Array(3*n.Im),z=new Float32Array(4*n.Im),w=new Float32Array(3*n.Im);let J=0;for(const e of t)e.decompose(q,R,C),p&&(K(C),h(R)),j.set(C.fe(),3*J),z.set(R.normalize().fe(),4*J),w.set(q.fe(),3*J),A=A||!C.equalsWithEpsilon(P),F=F||!R.equalsWithEpsilon(S),Y=Y||!q.equalsWithEpsilon(m),J++;const I={attributes:{}};A&&(I.attributes.TRANSLATION=this._buildAccessor(j,"VEC3",n.Im,k)),F&&(I.attributes.ROTATION=this._buildAccessor(z,"VEC4",n.Im,k)),Y&&(I.attributes.SCALE=this._buildAccessor(w,"VEC3",n.Im,k)),e.extensions=e.extensions||{},e.extensions[sP]=I}P(e)}))}_buildAccessor(P,e,n,H){const S=H.createBufferView(P),p=H.createAccessor(S,e,5126,n);return this._exporter._accessors.push(p),this._exporter._accessors.length-1}}aP.RegisterExtension(sP,(P=>new EP(P)));var XP=n(11693),xP=n(11699),MP=n(11704),KP=n(11711);function hP(P){return P===MP.c.PositionKind?"POSITION":P===MP.c.NormalKind?"NORMAL":P===MP.c.ColorKind?"COLOR":P.startsWith(MP.c.UVKind)?"TEX_COORD":"GENERIC"}const DP={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Pe extends XP.b{static get DefaultAvailable(){return(0,XP.i)(Pe.DefaultConfiguration)}static get Default(){return Pe._Default??(Pe._Default=new Pe),Pe._Default}static ResetDefault(P){Pe._Default&&(P||Pe._Default.dispose(),Pe._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(P,e){return{module:await(e||DracoEncoderModule)({wasmBinary:P})}}_getWorkerContent(){return`${xP.j}(${xP.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Pe.DefaultConfiguration)}async _encodeAsync(P,e,n){const H=n?(0,KP.e)(DP,n):DP;if(this._workerPoolPromise){const n=await this._workerPoolPromise;return await new Promise(((S,p)=>{n.push(((n,k)=>{const m=P=>{n.removeEventListener("error",m),n.removeEventListener("message",t),p(P),k()},t=P=>{"encodeMeshDone"===P.data.id&&(n.removeEventListener("error",m),n.removeEventListener("message",t),S(P.data.encodedMeshData),k())};n.addEventListener("error",m),n.addEventListener("message",t);const C=[];for(const e of P)C.push(e.data.buffer);e&&C.push(e.buffer),n.postMessage({id:"encodeMesh",attributes:P,indices:e,options:H},C)}))}))}if(this._modulePromise){const n=await this._modulePromise;return(0,xP.j)(n.module,P,e,H)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(P,e){if(0==P.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");P instanceof JP.b&&P.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===e||void 0===e?void 0:e.method)&&(Z.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),e.method="MESH_SEQUENTIAL_ENCODING");const n=function(P){let e=P.ln(void 0,!0);return!e||e instanceof Uint32Array||e instanceof Uint16Array||(e=((0,f.c)(e,e.length)?Uint32Array:Uint16Array).from(e)),e}(P),H=function(P,e){const n=[];for(const H of P.getVerticesDataKinds()){if(null!==e&&void 0!==e&&e.includes(H)){if(H===MP.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const S=P.getVertexBuffer(H),p=S.getSize(),k=(0,f.o)(S.getData(),p,S.type,S.byteOffset,S.byteStride,S.normalized,P.getTotalVertices(),!0);n.push({kind:H,dracoName:hP(H),size:p,data:k})}return n}(P,null===e||void 0===e?void 0:e.excludedAttributes);return await this._encodeAsync(H,n,e)}}Pe.DefaultConfiguration={wasmUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${S.Tools._DefaultCdnUrl}/draco_encoder.js`},Pe._Default=null;const ee="KHR_draco_mesh_compression";class ne{get wasUsed(){return this._wasUsed}constructor(P){this.name=ee,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===P.options.meshCompressionMethod&&Pe.DefaultAvailable}dispose(){}postExportMeshPrimitive(P,e,n){if(!this.enabled)return;if(4!==P.mode&&5!==P.mode)return void Z.c.Warn("Cannot compress primitive with mode "+P.mode+".");const H=[],S=[];let p=null;if(void 0!==P.indices){const k=n[P.indices],m=e.getBufferView(k);p=e.getData(m).slice(),H.push(m),S.push(k)}const k=[];for(const[R,q]of Object.entries(P.attributes)){const P=n[q],p=e.getBufferView(P),t=E(P.type),C=(0,f.o)(e.getData(p),t,P.componentType,P.byteOffset||0,p.byteStride||(0,f.j)(P.componentType)*t,P.normalized||!1,P.count,!0);k.push({kind:R,dracoName:(m=R,"POSITION"===m?"POSITION":"NORMAL"===m?"NORMAL":m.startsWith("COLOR")?"COLOR":m.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:E(P.type),data:C}),H.push(p),S.push(P)}var m;const t={method:P.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},C=Pe.Default._encodeAsync(k,p,t).then((n=>{if(!n)return void Z.c.Error("Draco encoding failed for primitive.");const p={bufferView:-1,attributes:n.attributeIds},k=e.createBufferView(n.data);e.setBufferView(p,k);for(const P of H)this._bufferViewsUsed.add(P);for(const P of S)this._accessorsUsed.add(P);P.extensions||(P.extensions={}),P.extensions[ee]=p})).catch((P=>{Z.c.Error("Draco encoding failed for primitive: "+P)}));this._encodePromises.push(C),this._wasUsed=!0}async preGenerateBinaryAsync(P){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((e=>{P.getPropertiesWithBufferView(e).every((P=>this._accessorsUsed.has(P)))&&P.removeBufferView(e)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}aP.RegisterExtension(ee,(P=>new ne(P)));var He=n(11716);const Se="KHR_lights_punctual",pe={name:"",color:[1,1,1],Om:1,range:Number.MAX_VALUE},ke={innerConeAngle:0,outerConeAngle:Math.PI/4},me=H.Ie.Backward();class te{constructor(P){this.name=Se,this.enabled=!0,this.required=!1,this._exporter=P}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Se]=this._lights}async postExportNodeAsync(P,e,n,S,p){return await new Promise((k=>{if(!(n instanceof IP.c))return void k(e);const m=n.getTypeID()==IP.c.LIGHTTYPEID_POINTLIGHT?"point":n.getTypeID()==IP.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":n.getTypeID()==IP.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!m||!(n instanceof He.b))return Z.c.Warn(`${P}: Light ${n.name} is not supported in ${Se}`),void k(e);if(n.falloffType!==IP.c.FALLOFF_GLTF&&Z.c.Warn(`${P}: Light falloff for ${n.name} does not match the ${Se} specification!`),!n.position.equalsToFloats(0,0,0)){const P=H.TmpVectors.Ie[0].p(n.position);p&&K(P),e.translation=P.fe()}if("point"!==m){const P=n.direction.normalizeToRef(H.TmpVectors.Ie[0]);p&&K(P);const S=H.Quaternion.FromUnitVectorsToRef(me,P,H.TmpVectors.Quaternion[0]);H.Quaternion.IsIdentity(S)||(e.rotation=S.fe())}const t={type:m,name:n.name,color:n.Vm.fe(),Om:n.Om,range:n.range};if(HP(t,pe),"spot"===m){const P=n;t.spot={innerConeAngle:P.innerAngle/2,outerConeAngle:P.angle/2},HP(t.spot,ke)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(t);const C={je:this._lights.lights.length-1},R=n.parent;if(R&&eP(n,R)){const P=S.get(R);if(P){const n=this._exporter._nodes[P];return PP(e,n),n.extensions||(n.extensions={}),n.extensions[Se]=C,void k(null)}}e.extensions||(e.extensions={}),e.extensions[Se]=C,k(e)}))}}aP.RegisterExtension(Se,(P=>new te(P)));var Ce=n(11623);const Re="KHR_materials_anisotropy";class qe{constructor(P){this.name=Re,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof Ce.d&&n.anisotropy.isEnabled&&!n.anisotropy.legacy?(n.anisotropy.texture&&H.push(n.anisotropy.texture),H):[]}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof Ce.d){if(!n.anisotropy.isEnabled||n.anisotropy.legacy)return void P(e);this._wasUsed=!0,e.extensions=e.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(n.anisotropy.texture),S={anisotropyStrength:n.anisotropy.Om,anisotropyRotation:n.anisotropy.angle,anisotropyTexture:H??void 0};null!==S.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(n),e.extensions[Re]=S}P(e)}))}}aP.RegisterExtension(Re,(P=>new qe(P)));const Ae="KHR_materials_clearcoat";class Fe{constructor(P){this.name=Ae,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof Ce.d&&n.clearCoat.isEnabled?(n.clearCoat.texture&&H.push(n.clearCoat.texture),!n.clearCoat.useRoughnessFromMainTexture&&n.clearCoat.textureRoughness&&H.push(n.clearCoat.textureRoughness),n.clearCoat.bumpTexture&&H.push(n.clearCoat.bumpTexture),H):[]}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof Ce.d){if(!n.clearCoat.isEnabled)return void P(e);this._wasUsed=!0,e.extensions=e.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture);let p;p=n.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(n.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(n.clearCoat.textureRoughness),n.clearCoat.isTintEnabled&&S.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${n.name}`),n.clearCoat.remapF0OnInterfaceChange&&S.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${n.name}`);const k=this._exporter._materialExporter.getTextureInfo(n.clearCoat.bumpTexture),m={clearcoatFactor:n.clearCoat.Om,clearcoatTexture:H??void 0,clearcoatRoughnessFactor:n.clearCoat.roughness,clearcoatRoughnessTexture:p??void 0,clearcoatNormalTexture:k??void 0};null===m.clearcoatTexture&&null===m.clearcoatRoughnessTexture&&null===m.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),e.extensions[Ae]=m}P(e)}))}}aP.RegisterExtension(Ae,(P=>new Fe(P)));const Ye="KHR_materials_diffuse_transmission";function je(P,e){const n=e.subSurface;let H=null;return n.translucencyIntensityTexture?H=n.translucencyIntensityTexture:n.thicknessTexture&&n.useMaskFromThicknessTexture&&(H=n.thicknessTexture),H&&!n.useGltfStyleTextures?(Z.c.Warn(`${P}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${e.name}`,1),null):H}class ze{constructor(P){this.name=Ye,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];if(n instanceof YP.b&&this._isExtensionEnabled(n)){const e=je(P,n);return e&&H.push(e),n.subSurface.translucencyColorTexture&&H.push(n.subSurface.translucencyColorTexture),H}return H}_isExtensionEnabled(P){if(P.unlit)return!1;const e=P.subSurface;return!!e.isTranslucencyEnabled&&(!P.unlit&&!e.useAlbedoToTintTranslucency&&e.useGltfStyleTextures&&1===e.volumeIndexOfRefraction&&0===e.minimumThickness&&0===e.maximumThickness)}postExportMaterialAsync(P,e,n){return new Promise((H=>{if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0;const H=n.subSurface,S=je(P,n),p=0==H.translucencyIntensity?void 0:H.translucencyIntensity,k=this._exporter._materialExporter.getTextureInfo(S)??void 0,m=!H.translucencyColor||H.translucencyColor.equalsFloats(1,1,1)?void 0:H.translucencyColor.fe(),t=this._exporter._materialExporter.getTextureInfo(H.translucencyColorTexture)??void 0,C={diffuseTransmissionFactor:p,diffuseTransmissionTexture:k,diffuseTransmissionColorFactor:m,diffuseTransmissionColorTexture:t};(k||t)&&this._exporter._materialNeedsUVsSet.add(n),e.extensions=e.extensions||{},e.extensions[Ye]=C}H(e)}))}}aP.RegisterExtension(Ye,(P=>new ze(P)));const we="KHR_materials_dispersion";class Je{constructor(){this.name=we,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){if(P.unlit)return!1;const e=P.subSurface;return!(!e.isRefractionEnabled&&!e.isDispersionEnabled)}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0;const P={dispersion:n.subSurface.dispersion};e.extensions=e.extensions||{},e.extensions[we]=P}P(e)}))}}aP.RegisterExtension(we,(()=>new Je));const Ie="KHR_materials_emissive_strength";class Oe{constructor(){this.name=Ie,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(P,e,n){return await new Promise((P=>{if(!(n instanceof YP.b))return P(e);const H=n.emissiveColor.fe(),S=Math.max(...H);if(S>1){this._wasUsed=!0,e.extensions||(e.extensions={});const P={emissiveStrength:S},H=n.emissiveColor.scale(1/P.emissiveStrength);e.emissiveFactor=H.fe(),e.extensions[Ie]=P}return P(e)}))}}aP.RegisterExtension(Ie,(P=>new Oe));const Ve="KHR_materials_ior";class ie{constructor(){this.name=Ve,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.indexOfRefraction&&1.5!=P.indexOfRefraction)}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0;const P={ior:n.indexOfRefraction};e.extensions=e.extensions||{},e.extensions[Ve]=P}P(e)}))}}aP.RegisterExtension(Ve,(P=>new ie));const Be="KHR_materials_iridescence";class le{constructor(P){this.name=Be,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof Ce.d&&n.iridescence.isEnabled?(n.iridescence.texture&&H.push(n.iridescence.texture),n.iridescence.thicknessTexture&&n.iridescence.thicknessTexture!==n.iridescence.texture&&H.push(n.iridescence.thicknessTexture),H):[]}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof Ce.d){if(!n.iridescence.isEnabled)return void P(e);this._wasUsed=!0,e.extensions=e.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(n.iridescence.texture),S=this._exporter._materialExporter.getTextureInfo(n.iridescence.thicknessTexture),p={iridescenceFactor:n.iridescence.Om,iridescenceIor:n.iridescence.indexOfRefraction,iridescenceThicknessMinimum:n.iridescence.minimumThickness,iridescenceThicknessMaximum:n.iridescence.maximumThickness,iridescenceTexture:H??void 0,iridescenceThicknessTexture:S??void 0};null===p.iridescenceTexture&&null===p.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(n),e.extensions[Be]=p}P(e)}))}}aP.RegisterExtension(Be,(P=>new le(P)));const be="KHR_materials_sheen";class Te{constructor(P){this.name=be,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){return n instanceof YP.b&&n.sheen.isEnabled&&n.sheen.texture?[n.sheen.texture]:[]}async postExportMaterialAsync(P,e,n){return await new Promise((P=>{if(n instanceof YP.b){if(!n.sheen.isEnabled)return void P(e);this._wasUsed=!0,null==e.extensions&&(e.extensions={});const H={sheenColorFactor:n.sheen.color.fe(),sheenRoughnessFactor:n.sheen.roughness??0};null===H.sheenColorTexture&&null===H.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(n),n.sheen.texture&&(H.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),n.sheen.textureRoughness&&!n.sheen.useRoughnessFromMainTexture?H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.textureRoughness)??void 0:n.sheen.texture&&n.sheen.useRoughnessFromMainTexture&&(H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(n.sheen.texture)??void 0),e.extensions[be]=H}P(e)}))}}aP.RegisterExtension(be,(P=>new Te(P)));const de="KHR_materials_specular";class Ne{constructor(P){this.name=de,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof YP.b&&this._isExtensionEnabled(n)?(n.metallicReflectanceTexture&&H.push(n.metallicReflectanceTexture),n.reflectanceTexture&&H.push(n.reflectanceTexture),H):H}_isExtensionEnabled(P){return!P.unlit&&(void 0!=P.metallicF0Factor&&1!=P.metallicF0Factor||void 0!=P.metallicReflectanceColor&&!P.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.metallicReflectanceTexture||null!=P.reflectanceTexture}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0,e.extensions=e.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(n.metallicReflectanceTexture)??void 0,H=this._exporter._materialExporter.getTextureInfo(n.reflectanceTexture)??void 0,S={specularFactor:1==n.metallicF0Factor?void 0:n.metallicF0Factor,specularTexture:P,specularColorFactor:n.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:n.metallicReflectanceColor.fe(),specularColorTexture:H};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),e.extensions[de]=S}P(e)}))}}aP.RegisterExtension(de,(P=>new Ne(P)));const Qe="KHR_materials_transmission";class ce{constructor(P){this.name=Qe,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof YP.b&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&H.push(n.subSurface.thicknessTexture),H):H}_isExtensionEnabled(P){if(P.unlit)return!1;const e=P.subSurface;return e.isRefractionEnabled&&void 0!=e.refractionIntensity&&0!=e.refractionIntensity||this._hasTexturesExtension(P)}_hasTexturesExtension(P){return null!=P.subSurface.refractionIntensityTexture}async postExportMaterialAsync(P,e,n){if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0;const H=n.subSurface,S={transmissionFactor:0===H.refractionIntensity?void 0:H.refractionIntensity};if(this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),H.refractionIntensityTexture)if(H.useGltfStyleTextures){const P=await this._exporter._materialExporter.exportTextureAsync(H.refractionIntensityTexture,"image/png");P&&(S.transmissionTexture=P)}else Z.c.Warn(`${P}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);e.extensions||(e.extensions={}),e.extensions[Qe]=S}return e}}aP.RegisterExtension(Qe,(P=>new ce(P)));const re="KHR_materials_unlit";class oe{constructor(){this.name=re,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(P,e,n){return new Promise((P=>{let H=!1;n instanceof YP.b?H=n.unlit:n instanceof jP.de&&(H=n.disableLighting),H&&(this._wasUsed=!0,null==e.extensions&&(e.extensions={}),e.extensions[re]={}),P(e)}))}}aP.RegisterExtension(re,(()=>new oe));const Ge="KHR_materials_volume";class ge{constructor(P){this.name=Ge,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof YP.b&&this._isExtensionEnabled(n)?(n.subSurface.thicknessTexture&&H.push(n.subSurface.thicknessTexture),H):H}_isExtensionEnabled(P){if(P.unlit)return!1;const e=P.subSurface;return!(!e.isRefractionEnabled&&!e.isTranslucencyEnabled)&&(void 0!=e.maximumThickness&&0!=e.maximumThickness||void 0!=e.tintColorAtDistance&&e.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=e.tintColor&&e.tintColor!=z.Ne.White()||this._hasTexturesExtension(P))}_hasTexturesExtension(P){return null!=P.subSurface.thicknessTexture}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof YP.b&&this._isExtensionEnabled(n)){this._wasUsed=!0;const P=n.subSurface,H={thicknessFactor:0==P.maximumThickness?void 0:P.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(P.thicknessTexture)??void 0,attenuationDistance:P.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:P.tintColorAtDistance,attenuationColor:P.tintColor.equalsFloats(1,1,1)?void 0:P.tintColor.fe()};this._hasTexturesExtension(n)&&this._exporter._materialNeedsUVsSet.add(n),e.extensions=e.extensions||{},e.extensions[Ge]=H}P(e)}))}}aP.RegisterExtension(Ge,(P=>new ge(P)));const ye="EXT_materials_diffuse_roughness";class fe{constructor(P){this.name=ye,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=P}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(P,e,n){const H=[];return n instanceof Ce.d&&n._baseDiffuseRoughness?(n._baseDiffuseRoughnessTexture&&H.push(n._baseDiffuseRoughnessTexture),H):[]}postExportMaterialAsync(P,e,n){return new Promise((P=>{if(n instanceof Ce.d){if(!n._baseDiffuseRoughness)return void P(e);this._wasUsed=!0,e.extensions=e.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(n._baseDiffuseRoughnessTexture),S={diffuseRoughnessFactor:n._baseDiffuseRoughness,diffuseRoughnessTexture:H??void 0};null!==S.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(n),e.extensions[ye]=S}P(e)}))}}aP.RegisterExtension(ye,(P=>new fe(P)));const Ze="KHR_texture_transform";class ve{constructor(){this.name=Ze,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(P,e,n){if(n.BP()||S.Tools.Warn(`${P}: /*@__KEY__*/"scene" is not defined for Babylon texture ${n.name}!`),(0!==n.uAng||0!==n.vAng)&&(S.Tools.Warn(`${P}: Texture ${n.name} with rotation in the u or v axis is not supported in glTF.`),0!==n.uRotationCenter||0!==n.vRotationCenter))return;const H={};let p=!1;if(0===n.uOffset&&0===n.vOffset||(H.offset=[n.uOffset,n.vOffset],p=!0),1===n.uScale&&1===n.vScale||(H.scale=[n.uScale,n.vScale],p=!0),0!==n.wAng){if(0!==n.uRotationCenter||0!==n.vRotationCenter){if(n.homogeneousRotationInUVTransform&&n.uScale!==n.vScale)return void S.Tools.Warn(`${P}: Texture ${n.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Ze}.`);S.Tools.Warn(`${P}: Texture ${n.name} with non-origin rotation center will be exported using an adjusted offset with ${Ze}.`),H.offset=function(P){const{uOffset:e,vOffset:n,uRotationCenter:H,vRotationCenter:S,uScale:p,vScale:k,wAng:m}=P,t=Math.cos(m),C=Math.sin(m),R=H*p,q=S*k;return[e+(R*(1-t)+q*C),n+(q*(1-t)-R*C)]}(n)}H.rotation=-n.wAng,p=!0}0!==n.coordinatesIndex&&(H.texCoord=n.coordinatesIndex,p=!0),p&&(this._wasUsed=!0,e.extensions||(e.extensions={}),e.extensions[Ze]=H)}}aP.RegisterExtension(Ze,(()=>new ve));class ue{static CreateSTL(P){let e=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",S=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],k=arguments.length>5&&void 0!==arguments[5]&&arguments[5],m=arguments.length>6&&void 0!==arguments[6]&&arguments[6],t=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const C=function(P,e,n){const S=[3*P[n],3*P[n+1],3*P[n+2]],p=[new H.Ie(e[S[0]],e[S[0]+2],e[S[0]+1]),new H.Ie(e[S[1]],e[S[1]+2],e[S[1]+1]),new H.Ie(e[S[2]],e[S[2]+2],e[S[2]+1])],k=p[0].be(p[1]),m=p[2].be(p[1]);return{v:p,n:H.Ie.Cross(m,k).normalize()}},q=function(P,e,n,H){return e=A(P,e,n.x,H),e=A(P,e,n.y,H),A(P,e,n.z,H)},A=function(P,e,n,H){return P.setFloat32(e,n,H),e+4},Y=function(P){if(m){let e=P;P instanceof F.b&&(e=P.sourceMesh);const n=e.getVerticesData(R.g.PositionKind,!0,!0);if(!n)return[];const S=H.Ie.Zero();let p;for(p=0;p<n.length;p+=3)H.Ie.TransformCoordinatesFromFloatsToRef(n[p],n[p+1],n[p+2],P.De(!0),S).toArray(n,p);return n}return P.getVerticesData(R.g.PositionKind)||[]};m&&(k=!0);let j="",z=0,w=0;if(S){for(let n=0;n<P.length;n++){const e=P[n].ln();z+=e?e.length/3:0}const e=new ArrayBuffer(84+50*z);j=new DataView(e),w+=80,j.setUint32(w,z,p),w+=4}else t||(j="solid stlmesh\r\n");for(let H=0;H<P.length;H++){const e=P[H];!S&&t&&(j+="solid "+e.name+"\r\n"),!k&&e instanceof JP.b&&e.bakeCurrentTransformIntoVertices();const n=Y(e),m=e.ln()||[];for(let P=0;P<m.length;P+=3){const e=C(m,n,P);S?(w=q(j,w,e.n,p),w=q(j,w,e.v[0],p),w=q(j,w,e.v[1],p),w=q(j,w,e.v[2],p),w+=2):(j+="\tfacet normal "+e.n.x+" "+e.n.y+" "+e.n.z+"\r\n",j+="\t\touter loop\r\n",j+="\t\t\tvertex "+e.v[0].x+" "+e.v[0].y+" "+e.v[0].z+"\r\n",j+="\t\t\tvertex "+e.v[1].x+" "+e.v[1].y+" "+e.v[1].z+"\r\n",j+="\t\t\tvertex "+e.v[2].x+" "+e.v[2].y+" "+e.v[2].z+"\r\n",j+="\t\tendloop\r\n",j+="\tendfacet\r\n")}!S&&t&&(j+="endsolid "+name+"\r\n")}if(S||t||(j+="endsolid stlmesh"),e){const P=document.createElement("a"),e=new Blob([j],{type:"application/octet-stream"});P.href=window.URL.createObjectURL(e),P.download=n+".stl",P.click()}return j}}function We(P,e){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const H=[];for(let S=0;S<P.length/n;S++){const p=P[S*n],k=P[S*n+1],m=P[S*n+2];H.push(`(${p.toPrecision(e.precision)}, ${k.toPrecision(e.precision)}, ${m.toPrecision(e.precision)})`)}return H.join(", ")}function Ue(P,e){const n=[];for(let H=0;H<P.length/2;H++){const S=P[2*H],p=P[2*H+1];n.push(`(${S.toPrecision(e.precision)}, ${(1-p).toPrecision(e.precision)})`)}return n.join(", ")}function ae(P,e){const n=P.getVerticesData(R.g.PositionKind),H=P.getVerticesData(R.g.NormalKind);if(n&&H)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(P){var e;const n=null!==(e=P.ln())&&void 0!==e&&e.length?P.getTotalIndices():P.getTotalVertices();return Array(n/3).fill(3).join(", ")}(P)}]\n\t\tint[] faceVertexIndices = [${function(P){const e=P.ln(),n=[];if(null!==e)for(let H=0;H<e.length;H++)n.push(e[H]);else{const e=P.getTotalVertices();for(let P=0;P<e;P++)n.push(P)}return n.join(", ")}(P)}]\n\t\tnormal3f[] normals = [${We(H,e)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${We(n,e)}]\n        ${function(P,e){let n="";for(let S=0;S<4;S++){const H=S>0?S:"",p=P.getVerticesData(R.g.UVKind+(H?H+1:""));p&&(n+=`\n\t\ttexCoord2f[] primvars:st${H} = [${Ue(p,e)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const H=P.getVerticesData(R.g.ColorKind);return H&&(n+=`\n\tcolor3f[] primvars:displayColor = [${We(H,e,H.length/P.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),n}(P,e)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Le(P,e){return`\n        def "Geometry"\n        {\n        ${ae(P,e)}\n        }\n        `}function se(P){let e='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return e+=P,fflate.strToU8(e)}function Ee(P){const e=P.m;return`( ${Xe(e,0)}, ${Xe(e,4)}, ${Xe(e,8)}, ${Xe(e,12)} )`}function Xe(P,e){return`(${P[e+0]}, ${P[e+1]}, ${P[e+2]}, ${P[e+3]})`}function xe(P){const e="Object_"+P.uniqueId,n=function(P){const e=P.getWorldMatrix().clone(),n=P.BP().useRightHandedSystem;if(!n){let H=P.parent;for(;H;){if(kP(H,n)){e.multiplyToRef(H.getWorldMatrix().invert(),e);break}H=H.parent}}return e.determinant()<0&&S.Tools.Warn(`Exporting mesh ${P.name} with negative scale. Result may look incorrect in destination engine.`),e}(P),H=Ee(n);return`def Xform "${e}" (\n\tprepend references = @./geometries/Geometry_${P.en.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${H}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${P.material.uniqueId}>\n}\n\n`}function Me(P){switch(P){case B.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case B.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case B.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ke(P){return`(${P.x}, ${P.y})`}function he(P){return`(${P.r}, ${P.g}, ${P.b})`}function De(P,e,n,S,p,k){const m=P.getInternalTexture().uniqueId+"_"+P.invertY;p[m]=P;const t=P.coordinatesIndex>0?"st"+P.coordinatesIndex:"st",C=new H.Vector2(P.uScale,P.vScale),R=new H.Vector2(P.uOffset,P.vOffset),q=P.wAng,A=Math.sin(q),F=Math.cos(q);return R.y=1-R.y-C.y,R.x+=A*C.x,R.y+=(1-F)*C.y,`\n    def Shader "PrimvarReader_${n}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${t}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${n}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${e.uniqueId}/PrimvarReader_${n}.outputs:result>\n        float inputs:rotation = ${(q*(180/Math.PI)).toFixed(k.precision)}\n        float2 inputs:scale = ${Ke(C)}\n        float2 inputs:translation = ${Ke(R)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${P.uniqueId}_${n}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${m}.png@\n        float2 inputs:st.connect = </Materials/Material_${e.uniqueId}/Transform2d_${n}.outputs:result>\n        ${S?"float4 inputs:scale = "+function(P){return`(${P.r}, ${P.g}, ${P.b}, 1.0)`}(S):""}\n        token inputs:sourceColorSpace = "${P.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Me(P.wrapU)}"\n        token inputs:wrapT = "${Me(P.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${e.needAlphaBlending()?"float outputs:a":""}\n    }`}function Pn(P,e,n){const H="\t\t\t",S=[],p=[],{diffuseMap:k,Vm:m,alphaCutOff:t,emissiveMap:C,emissive:R,normalMap:q,roughnessMap:A,roughnessChannel:F,roughness:Y,metalnessMap:j,metalnessChannel:w,metalness:J,aoMap:I,aoMapChannel:O,aoMapIntensity:V,alphaMap:i,ior:B,clearCoatEnabled:l,clearCoat:b,clearCoatMap:T,clearCoatRoughness:d,clearCoatRoughnessMap:N}=function(P){const e={diffuseMap:null,Vm:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return P instanceof jP.de?{...e,diffuseMap:P.diffuseTexture,Vm:P.diffuseColor,alphaCutOff:P.alphaCutOff,emissiveMap:P.emissiveTexture,emissive:P.emissiveColor,roughness:1,alphaMap:P.opacityTexture}:P instanceof Ce.d?{...e,diffuseMap:P._albedoTexture,Vm:P._albedoColor,alphaCutOff:P._alphaCutOff,emissiveMap:P._emissiveTexture,emissive:P._emissiveColor,normalMap:P._bumpTexture,roughnessMap:P._metallicTexture,roughnessChannel:P._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:P._roughness??1,metalnessMap:P._metallicTexture,metalnessChannel:P._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:P._metallic??0,aoMap:P._ambientTexture,aoMapChannel:P._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:P._ambientTextureStrength,alphaMap:P._opacityTexture,ior:P.subSurface.indexOfRefraction,clearCoatEnabled:P.clearCoat.isEnabled,clearCoat:P.clearCoat.Om,clearCoatMap:P.clearCoat.texture,clearCoatRoughness:P.clearCoat.roughness,clearCoatRoughnessMap:P.clearCoat.useRoughnessFromMainTexture?P.clearCoat.texture:P.clearCoat.textureRoughness}:e}(P);return null!==k?(S.push(`${H}color3f inputs:diffuseColor.connect = </Materials/Material_${P.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:rgb>`),P.needAlphaBlending()?S.push(`${H}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`):P.needAlphaTesting()&&(S.push(`${H}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${k.uniqueId}_diffuse.outputs:a>`),S.push(`${H}float inputs:opacityThreshold = ${t}`)),p.push(De(k,P,"diffuse",m,e,n))):S.push(`${H}color3f inputs:diffuseColor = ${he(m||z.Ne.White())}`),null!==C?(S.push(`${H}color3f inputs:emissiveColor.connect = </Materials/Material_${P.uniqueId}/Texture_${C.uniqueId}_emissive.outputs:rgb>`),p.push(De(C,P,"emissive",R,e,n))):R&&R.toLuminance()>0&&S.push(`${H}color3f inputs:emissiveColor = ${he(R)}`),null!==q&&(S.push(`${H}normal3f inputs:normal.connect = </Materials/Material_${P.uniqueId}/Texture_${q.uniqueId}_normal.outputs:rgb>`),p.push(De(q,P,"normal",null,e,n))),null!==I&&(S.push(`${H}float inputs:occlusion.connect = </Materials/Material_${P.uniqueId}/Texture_${I.uniqueId}_occlusion.outputs:${O}>`),p.push(De(I,P,"occlusion",new z.Ne(V,V,V),e,n))),null!==A?(S.push(`${H}float inputs:roughness.connect = </Materials/Material_${P.uniqueId}/Texture_${A.uniqueId}_roughness.outputs:${F}>`),p.push(De(A,P,"roughness",new z.Ne(Y,Y,Y),e,n))):S.push(`${H}float inputs:roughness = ${Y}`),null!==j?(S.push(`${H}float inputs:metallic.connect = </Materials/Material_${P.uniqueId}/Texture_${j.uniqueId}_metallic.outputs:${w}>`),p.push(De(j,P,"metallic",new z.Ne(J,J,J),e,n))):S.push(`${H}float inputs:metallic = ${J}`),null!==i?(S.push(`${H}float inputs:opacity.connect = </Materials/Material_${P.uniqueId}/Texture_${i.uniqueId}_opacity.outputs:r>`),S.push(`${H}float inputs:opacityThreshold = 0.0001`),p.push(De(i,P,"opacity",null,e,n))):S.push(`${H}float inputs:opacity = ${P.alpha}`),l&&(null!==T?(S.push(`${H}float inputs:clearcoat.connect = </Materials/Material_${P.uniqueId}/Texture_${T.uniqueId}_clearcoat.outputs:r>`),p.push(De(T,P,"clearcoat",new z.Ne(b,b,b),e,n))):S.push(`${H}float inputs:clearcoat = ${b}`),null!==N?(S.push(`${H}float inputs:clearcoatRoughness.connect = </Materials/Material_${P.uniqueId}/Texture_${N.uniqueId}_clearcoatRoughness.outputs:g>`),p.push(De(N,P,"clearcoatRoughness",new z.Ne(d,d,d),e,n))):S.push(`${H}float inputs:clearcoatRoughness = ${d}`)),S.push(`${H}float inputs:ior = ${B}`),`\n\tdef Material "Material_${P.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${S.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${P.uniqueId}/PreviewSurface.outputs:surface>\n\n${p.join("\n")}\n\n\t}\n`}async function en(P,e,n){const p={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...e};"undefined"===typeof fflate&&await S.Tools.LoadScriptAsync(p.fflateUrl);const k={};k[p.modelFileName]=null;let m='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';m+=function(P){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===P.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${P.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${P.planeAnchoringAlignment}"`:""}\n            `}(p);const t={};for(const H of P.meshes){if(0===H.getTotalVertices())continue;const P=H,e=P.en,C=P.material;if(!C||!e||n&&!n(P))continue;if(-1!==["de","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(C.getClassName())){const n="geometries/Geometry_"+e.uniqueId+".usda";if(!(n in k)){const P=Le(e,p);k[n]=se(P)}C.uniqueId in t||(t[C.uniqueId]=C),m+=xe(P)}else S.Tools.Warn("USDZExportAsync does not support this material type: "+C.getClassName())}P.activeCamera&&p.exportCamera&&(m+=function(P,e){const n="Camera_"+P.uniqueId,S=Ee(H.Matrix.RotationY(Math.PI).multiply(P.getWorldMatrix()));if(P.mode===B.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.Le.toPrecision(e.precision)}, ${P.maxZ.toPrecision(e.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(P.orthoLeft||1)+Math.abs(P.orthoRight||1))).toPrecision(e.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(P.orthoTop||1)+Math.abs(P.orthoBottom||1))).toPrecision(e.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const H=P.getEngine().getAspectRatio(P),p=e.cameraSensorWidth||35;return`def Camera "${n}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${S}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${P.Le.toPrecision(e.precision)}, ${P.maxZ.toPrecision(e.precision)})\n\t\t\tfloat focalLength = ${(p/(2*Math.tan(.5*P.fov))).toPrecision(e.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(p*H).toPrecision(e.precision)}\n\t\t\tfloat verticalAperture = ${(p/H).toPrecision(e.precision)}            \n\t\t}\n\t\n\t`}}(P.activeCamera,p)),m+="\n            }\n        }\n    }";const C={};m+=function(P,e,n){const H=[];for(const S in P){const p=P[S];H.push(Pn(p,e,n))}return`\n    def "Materials"\n{\n${H.join("")}\n}\n\n`}(t,C,p),k[p.modelFileName]=fflate.strToU8(m);for(const H in C){const P=C[H],e=P.getSize(),n=await P.readPixels();if(!n)throw new Error("Texture data is not available");const S=await l.DumpTools.DumpDataAsync(e.width,e.height,n,"image/png",void 0,!1,!0);k[`textures/Texture_${H}.png`]=new Uint8Array(S).slice()}let R=0;for(const H in k){const P=k[H];if(!P)continue;R+=34+H.length;const e=63&R;if(4!==e){const n=new Uint8Array(64-e);k[H]=[P,{extra:{12345:n}}]}R=P.length}return fflate.zipSync(k,{level:0})}}}]);