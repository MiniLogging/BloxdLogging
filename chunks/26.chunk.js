"use strict";(self.qbp2s7qydk=self.qbp2s7qydk||[]).push([[26],{13379:(M,A,O)=>{O.r(A),O.d(A,{EXT_materials_diffuse_roughness:()=>oA,EXT_mesh_gpu_instancing:()=>PM,GLTF2Export:()=>VM,GLTFData:()=>B,KHR_draco_mesh_compression:()=>SA,KHR_lights_punctual:()=>BA,KHR_materials_anisotropy:()=>TA,KHR_materials_clearcoat:()=>KA,KHR_materials_diffuse_transmission:()=>wA,KHR_materials_dispersion:()=>bA,KHR_materials_emissive_strength:()=>YA,KHR_materials_ior:()=>HA,KHR_materials_iridescence:()=>fA,KHR_materials_sheen:()=>FA,KHR_materials_specular:()=>yA,KHR_materials_transmission:()=>uA,KHR_materials_unlit:()=>UA,KHR_materials_volume:()=>tA,KHR_texture_transform:()=>vA,OBJExport:()=>X,STLExport:()=>qA,USDZExportAsync:()=>OO,_ConvertToGLTFPBRMetallicRoughness:()=>i,_SolveMetallic:()=>u,__IGLTFExporterExtension:()=>c});var S=O(12970),z=O(12768),Q=O(13286);class X{static OBJ(M,A,O,X){const c=[];let j=1,B=1;A&&(O||(O="mat"),c.push("mtllib "+O+".mtl"));for(let g=0;g<M.length;g++){const O=M[g],e=O.name||"mesh".concat(g,"}");c.push("o ".concat(e));let T=null;if(X){const M=O.Gc(!0);T=new S.Matrix,M.invertToRef(T),O.bakeTransformIntoVertices(M)}if(A){const M=O.material;M&&c.push("usemtl "+M.id)}const J=O.wc;if(!J){z.Tools.Warn("No geometry is present on the mesh");continue}const K=J.getVerticesData("position"),G=J.getVerticesData("normal"),d=J.getVerticesData("uv"),w=J.Ic();let I=0,b=0;if(!K||!w){z.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=M[0].HM().useRightHandedSystem?1:-1;for(let M=0;M<K.length;M+=3)c.push("v "+K[M]*s+" "+K[M+1]+" "+K[M+2]),I++;if(null!=G)for(let M=0;M<G.length;M+=3)c.push("vn "+G[M]*s+" "+G[M+1]+" "+G[M+2]);if(null!=d)for(let M=0;M<d.length;M+=2)c.push("vt "+d[M]+" "+d[M+1]),b++;const Y=["","",""],E=(O.material||O.HM().defaultMaterial)._getEffectiveOrientation(O),[H,C]=E===Q.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let M=0;M<w.length;M+=3){const A=[String(w[M]+j),String(w[M+H]+j),String(w[M+C]+j)],O=[String(w[M]+B),String(w[M+H]+B),String(w[M+C]+B)],S=A,z=null!=d?O:Y,Q=null!=G?A:Y;c.push("f "+S[0]+"/"+z[0]+"/"+Q[0]+" "+S[1]+"/"+z[1]+"/"+Q[1]+" "+S[2]+"/"+z[2]+"/"+Q[2])}X&&T&&O.bakeTransformIntoVertices(T),j+=I,B+=b}return c.join("\n")}static MTL(M){const A=[],O=M.material;A.push("newmtl mat1"),A.push("  Ns "+O.specularPower.toFixed(4)),A.push("  Ni 1.5000"),A.push("  d "+O.alpha.toFixed(4)),A.push("  Tr 0.0000"),A.push("  Tf 1.0000 1.0000 1.0000"),A.push("  illum 2"),A.push("  Ka "+O.ambientColor.r.toFixed(4)+" "+O.ambientColor.g.toFixed(4)+" "+O.ambientColor.b.toFixed(4)),A.push("  Kd "+O.diffuseColor.r.toFixed(4)+" "+O.diffuseColor.g.toFixed(4)+" "+O.diffuseColor.b.toFixed(4)),A.push("  Ks "+O.specularColor.r.toFixed(4)+" "+O.specularColor.g.toFixed(4)+" "+O.specularColor.b.toFixed(4)),A.push("  Ke "+O.emissiveColor.r.toFixed(4)+" "+O.emissiveColor.g.toFixed(4)+" "+O.emissiveColor.b.toFixed(4));O.ambientTexture&&A.push("  map_Ka "+O.ambientTexture.name),O.diffuseTexture&&A.push("  map_Kd "+O.diffuseTexture.name),O.specularTexture&&A.push("  map_Ks "+O.specularTexture.name),O.bumpTexture&&A.push("  map_bump -imfchan z "+O.bumpTexture.name),O.opacityTexture&&A.push("  map_d "+O.opacityTexture.name);return A.join("\n")}}var c=0,j=O(12813);class B{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const M in this.files){const A=this.files[M],O=new Blob([A],{type:(0,j.j)(M)});z.Tools.Download(O,M)}}}var g=O(22),e=O(13043),T=O(13385),J=O(13398),K=O(13415),G=O(13110),d=O(12811),w=O(13010),I=O(12980);const b=I.HighestCommonFactor,s=(0,g.d)((0,g.d)({},I),{},{TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:b});var Y=O(13203),E=O(12949),H=O(13447),C=O(13455),f=O(13196);const D=1e-6,F=new w.bA(.04,.04,.04),N=1024,y=w.bA.White(),h=w.bA.Black();function u(M,A,O){if(A<F.r)return 0;const S=F.r,z=M*O/(1-F.r)+A-2*F.r,Q=z*z-4*S*(F.r-A);return s.Clamp((-z+Math.sqrt(Q))/(2*S),0,1)}function i(M){const A=M.diffuseColor.toLinearSpace(M.HM().getEngine().useExactSrgbConversions).scale(.5),O=M.alpha,z=function(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new S.Vector2(0,1),O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new S.Vector2(0,.1),z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new S.Vector2(0,.1),Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new S.Vector2(1300,.1);return function(M,A,O,S,z){return(1-M)*(1-M)*(1-M)*A+3*(1-M)*(1-M)*M*O+3*(1-M)*M*M*S+M*M*M*z}(Math.pow(M/Q.x,.333333),A.y,O.y,z.y,Q.y)}(s.Clamp(M.specularPower,0,N));return{baseColorFactor:[A.r,A.g,A.b,O],metallicFactor:0,roughnessFactor:z}}function U(M,A){A.needAlphaBlending()?M.alphaMode="BLEND":A.needAlphaTesting()&&(M.alphaMode="MASK",M.alphaCutoff=A.alphaCutOff)}function L(M,A,O){const S=new Uint8Array(M*A*4);for(let z=0;z<S.length;z+=4)S[z]=S[z+1]=S[z+2]=S[z+3]=255;return H.d.CreateRGBATexture(S,M,A,O)}function t(M){if(M instanceof Uint8Array){const A=M.length,O=new Float32Array(M.length);for(let S=0;S<A;++S)O[S]=M[S]/255;return O}if(M instanceof Float32Array)return M;throw new Error("Unsupported pixel format!")}class x{constructor(M){this._exporter=M,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(M){var A;return M&&null!==(A=this._textureMap.get(M))&&void 0!==A?A:null}async exportStandardMaterialAsync(M,A,O){const S=i(M),Q={name:M.name};if(null==M.bc||M.bc||(M.twoSidedLighting||z.Tools.Warn(M.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Q.doubleSided=!0),O){const O=[],z=M.diffuseTexture;z&&O.push(this.exportTextureAsync(z,A).then((M=>{M&&(S.baseColorTexture=M)})));const X=M.bumpTexture;X&&O.push(this.exportTextureAsync(X,A).then((M=>{M&&(Q.normalTexture=M,1!==X.level&&(Q.normalTexture.scale=X.level))})));const c=M.emissiveTexture;c&&(Q.emissiveFactor=[1,1,1],O.push(this.exportTextureAsync(c,A).then((M=>{M&&(Q.emissiveTexture=M)}))));const j=M.ambientTexture;j&&O.push(this.exportTextureAsync(j,A).then((M=>{if(M){const A={index:M.index};Q.occlusionTexture=A}}))),O.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(O))}(M.alpha<1||M.opacityTexture)&&(M.alphaMode===C.d.ALPHA_COMBINE?Q.alphaMode="BLEND":z.Tools.Warn(M.name+": glTF 2.0 does not support alpha mode: "+M.alphaMode.toString())),M.emissiveColor&&!M.emissiveColor.equalsWithEpsilon(h,D)&&(Q.emissiveFactor=M.emissiveColor.gc()),Q.pbrMetallicRoughness=S,U(Q,M),await this._finishMaterialAsync(Q,M,A);const X=this._exporter._materials;return X.push(Q),X.length-1}async _finishMaterialAsync(M,A,O){const S=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",M,A),z=[];for(const Q of S)z.push(this.exportTextureAsync(Q,O));await Promise.all(z),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",M,A)}async _getImageDataAsync(M,A,S,z){const Q=C.d.TEXTURETYPE_UNSIGNED_BYTE,X=this._exporter._babylonScene,c=X.getEngine(),j=c.createRawTexture(M,A,S,C.d.TEXTUREFORMAT_RGBA,!1,!0,E.c.NEAREST_SAMPLINGMODE,null,Q);c.isWebGPU?await O.e(51).then(O.bind(O,15121)):await O.e(52).then(O.bind(O,15129)),await Y.m.ApplyPostProcess("pass",j,X,Q,C.d.TEXTURE_NEAREST_SAMPLINGMODE,C.d.TEXTUREFORMAT_RGBA);const B=await c._readTexturePixels(j,A,S);return await f.DumpTools.DumpDataAsync(A,S,B,z,void 0,!0,!0)}_resizeTexturesToSameDimensions(M,A,O){const S=M?M.getSize():{width:0,height:0},z=A?A.getSize():{width:0,height:0};let Q,X;return S.width<z.width?(Q=M&&M instanceof E.c?Y.m.CreateResizedCopy(M,z.width,z.height,!0):L(z.width,z.height,O),X=A):S.width>z.width?(X=A&&A instanceof E.c?Y.m.CreateResizedCopy(A,S.width,S.height,!0):L(S.width,S.height,O),Q=M):(Q=M,X=A),{texture1:Q,texture2:X}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(M,A,O,S){const z=new Array;if(!M&&!A)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const Q=M?M.HM():A?A.HM():null;if(Q){var X;const c=this._resizeTexturesToSameDimensions(M,A,Q),j=null===(X=c.texture1)||void 0===X?void 0:X.getSize();let B,g;const e=j.width,T=j.height,J=await c.texture1.readPixels(),K=await c.texture2.readPixels();if(!J)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(B=t(J),!K)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");g=t(K);const G=g.byteLength,d=new Uint8Array(G),I=new Uint8Array(G),b=4,s=h;let Y=0,E=0;for(let M=0;M<T;++M)for(let A=0;A<e;++A){const S=(e*M+A)*b,z={diffuseColor:new w.bA(B[S],B[S+1],B[S+2]).toLinearSpace(Q.getEngine().useExactSrgbConversions).multiply(O.diffuseColor),specularColor:new w.bA(g[S],g[S+1],g[S+2]).toLinearSpace(Q.getEngine().useExactSrgbConversions).multiply(O.specularColor),glossiness:g[S+3]*O.glossiness},X=this._convertSpecularGlossinessToMetallicRoughness(z);s.r=Math.max(s.r,X.baseColor.r),s.g=Math.max(s.g,X.baseColor.g),s.b=Math.max(s.b,X.baseColor.b),Y=Math.max(Y,X.metallic),E=Math.max(E,X.roughness),I[S]=255*X.baseColor.r,I[S+1]=255*X.baseColor.g,I[S+2]=255*X.baseColor.b,I[S+3]=c.texture1.ec?255*B[S+3]:255,d[S]=0,d[S+1]=255*X.roughness,d[S+2]=255*X.metallic,d[S+3]=255}const H={baseColor:s,metallic:Y,roughness:E};let C=!1,f=!1;for(let M=0;M<T;++M)for(let A=0;A<e;++A){const O=(e*M+A)*b;I[O]/=H.baseColor.r>D?H.baseColor.r:1,I[O+1]/=H.baseColor.g>D?H.baseColor.g:1,I[O+2]/=H.baseColor.b>D?H.baseColor.b:1;const S=w.bA.FromInts(I[O],I[O+1],I[O+2]).toGammaSpace(Q.getEngine().useExactSrgbConversions);I[O]=255*S.r,I[O+1]=255*S.g,I[O+2]=255*S.b,S.equalsWithEpsilon(y,D)||(f=!0),d[O+1]/=H.roughness>D?H.roughness:1,d[O+2]/=H.metallic>D?H.metallic:1;w.bA.FromInts(255,d[O+1],d[O+2]).equalsWithEpsilon(y,D)||(C=!0)}return C&&z.push(this._getImageDataAsync(d,e,T,S).then((M=>{H.metallicRoughnessTextureData=M}))),f&&z.push(this._getImageDataAsync(I,e,T,S).then((M=>{H.baseColorTextureData=M}))),await Promise.all(z).then((()=>H))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(M){const A=this._getPerceivedBrightness(M.diffuseColor),O=this._getPerceivedBrightness(M.specularColor),S=1-this._getMaxComponent(M.specularColor),z=u(A,O,S),Q=M.diffuseColor.scale(S/(1-F.r)/Math.max(1-z)),X=M.specularColor.dA(F.scale(1-z)).scale(1/Math.max(z));let c=w.bA.Lerp(Q,X,z*z);c=c.clampToRef(0,1,c);return{baseColor:c,metallic:z,roughness:1-M.glossiness}}_getPerceivedBrightness(M){return M?Math.sqrt(.299*M.r*M.r+.587*M.g*M.g+.114*M.b*M.b):0}_getMaxComponent(M){return M?Math.max(M.r,Math.max(M.g,M.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(M,A,O,S){const z=[],Q={baseColor:M._albedoColor,metallic:M._metallic,roughness:M._roughness};if(S){M._albedoTexture&&z.push(this.exportTextureAsync(M._albedoTexture,A).then((M=>{M&&(O.baseColorTexture=M)})));const S=M._metallicTexture;S&&z.push(this.exportTextureAsync(S,A).then((M=>{M&&(O.metallicRoughnessTexture=M)})))}return z.length>0&&(this._exporter._materialNeedsUVsSet.add(M),await Promise.all(z)),Q}_getTextureSampler(M){const A={};if(!M||!(M instanceof E.c))return A;const O=this._getGLTFTextureWrapMode(M.wrapU);10497!==O&&(A.wrapS=O);const S=this._getGLTFTextureWrapMode(M.wrapV);switch(10497!==S&&(A.wrapT=S),M.samplingMode){case E.c.LINEAR_LINEAR:A.magFilter=9729,A.minFilter=9729;break;case E.c.LINEAR_NEAREST:A.magFilter=9729,A.minFilter=9728;break;case E.c.NEAREST_LINEAR:A.magFilter=9728,A.minFilter=9729;break;case E.c.NEAREST_LINEAR_MIPLINEAR:A.magFilter=9728,A.minFilter=9987;break;case E.c.NEAREST_NEAREST:A.magFilter=9728,A.minFilter=9728;break;case E.c.NEAREST_LINEAR_MIPNEAREST:A.magFilter=9728,A.minFilter=9985;break;case E.c.LINEAR_NEAREST_MIPNEAREST:A.magFilter=9729,A.minFilter=9984;break;case E.c.LINEAR_NEAREST_MIPLINEAR:A.magFilter=9729,A.minFilter=9986;break;case E.c.NEAREST_NEAREST_MIPLINEAR:A.magFilter=9728,A.minFilter=9986;break;case E.c.LINEAR_LINEAR_MIPLINEAR:A.magFilter=9729,A.minFilter=9987;break;case E.c.LINEAR_LINEAR_MIPNEAREST:A.magFilter=9729,A.minFilter=9985;break;case E.c.NEAREST_NEAREST_MIPNEAREST:A.magFilter=9728,A.minFilter=9984}return A}_getGLTFTextureWrapMode(M){switch(M){case E.c.WRAP_ADDRESSMODE:return 10497;case E.c.CLAMP_ADDRESSMODE:return 33071;case E.c.MIRROR_ADDRESSMODE:return 33648;default:return z.Tools.Error("Unsupported Texture Wrap Mode ".concat(M,"!")),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(M,A,O,S){const z={diffuseColor:M._albedoColor,specularColor:M._reflectivityColor,glossiness:M._microSurface},Q=M._albedoTexture,X=M._reflectivityTexture,c=M._useMicroSurfaceFromReflectivityMapAlpha;if(X&&!c)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((Q||X)&&S){this._exporter._materialNeedsUVsSet.add(M);const S=this._exportTextureSampler(Q||X),c=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Q,X,z,A),j=this._exporter._textures;if(c.baseColorTextureData){const M=this._exportImage("baseColor".concat(j.length),A,c.baseColorTextureData);O.baseColorTexture=this._exportTextureInfo(M,S,null===Q||void 0===Q?void 0:Q.coordinatesIndex)}if(c.metallicRoughnessTextureData){const M=this._exportImage("metallicRoughness".concat(j.length),A,c.metallicRoughnessTextureData);O.metallicRoughnessTexture=this._exportTextureInfo(M,S,null===X||void 0===X?void 0:X.coordinatesIndex)}return c}return this._convertSpecularGlossinessToMetallicRoughness(z)}async exportPBRMaterialAsync(M,A,O){const S={},z={name:M.name},Q=M.isMetallicWorkflow();if(Q){const A=M._albedoColor,O=M.alpha;A&&(S.baseColorFactor=[A.r,A.g,A.b,O])}const X=Q?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(M,A,S,O):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(M,A,S,O);await this._setMetallicRoughnessPbrMaterialAsync(X,M,z,S,A,O),await this._finishMaterialAsync(z,M,A);const c=this._exporter._materials;return c.push(z),c.length-1}async _setMetallicRoughnessPbrMaterialAsync(M,A,O,S,Q,X){if(U(O,A),M.baseColor.equalsWithEpsilon(y,D)&&s.WithinEpsilon(A.alpha,1,D)||(S.baseColorFactor=[M.baseColor.r,M.baseColor.g,M.baseColor.b,A.alpha]),null!=M.metallic&&1!==M.metallic&&(S.metallicFactor=M.metallic),null!=M.roughness&&1!==M.roughness&&(S.roughnessFactor=M.roughness),null==A.bc||A.bc||(A._twoSidedLighting||z.Tools.Warn(A.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),O.doubleSided=!0),X){const M=[],S=A._bumpTexture;S&&M.push(this.exportTextureAsync(S,Q).then((M=>{M&&(O.normalTexture=M,1!==S.level&&(O.normalTexture.scale=S.level))})));const z=A._ambientTexture;z&&M.push(this.exportTextureAsync(z,Q).then((M=>{if(M){const S={index:M.index,texCoord:M.texCoord,extensions:M.extensions};O.occlusionTexture=S;const z=A._ambientTextureStrength;z&&(S.strength=z)}})));const X=A._emissiveTexture;X&&M.push(this.exportTextureAsync(X,Q).then((M=>{M&&(O.emissiveTexture=M)}))),M.length>0&&(this._exporter._materialNeedsUVsSet.add(A),await Promise.all(M))}const c=A._emissiveColor;c.equalsWithEpsilon(h,D)||(O.emissiveFactor=c.gc()),O.pbrMetallicRoughness=S}_getPixelsFromTextureAsync(M){return function(M){switch(M){case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case C.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case C.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case C.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(M.textureFormat)?(0,Y.i)(M,M._texture.width,M._texture.height):(M.textureType,C.d.TEXTURETYPE_UNSIGNED_BYTE,M.readPixels())}async exportTextureAsync(M,A){const O=this._exporter._extensionsPreExportTextureAsync("exporter",M,A);return O?await O.then((async O=>O?await this._exportTextureInfoAsync(O,A):await this._exportTextureInfoAsync(M,A))):await this._exportTextureInfoAsync(M,A)}async _exportTextureInfoAsync(M,A){let O=this._textureMap.get(M);if(!O){const S=await this._getPixelsFromTextureAsync(M);if(!S)return null;const Q=this._exportTextureSampler(M),X=M.mimeType;if(X)switch(X){case"image/jpeg":case"image/png":case"image/webp":A=X;break;default:z.Tools.Warn("Unsupported media type: ".concat(X,". Exporting texture as PNG."))}const c=this._internalTextureToImage,j=M.getInternalTexture().uniqueId;c[j]||(c[j]={});let B=c[j][A];if(void 0===B){const O=M.getSize();B=(async()=>{const z=await this._getImageDataAsync(S,O.width,O.height,A);return this._exportImage(M.name,A,z)})(),c[j][A]=B}O=this._exportTextureInfo(await B,Q,M.coordinatesIndex),this._textureMap.set(M,O),this._exporter._extensionsPostExportTextures("exporter",O,M)}return O}_exportImage(M,A,O){const S=this._exporter._images;let Q;if(this._exporter._shouldUseGlb){Q={name:M,mimeType:A,bufferView:void 0};const S=this._exporter._bufferManager.createBufferView(new Uint8Array(O));this._exporter._bufferManager.setBufferView(Q,S)}else{const X=M.replace(/\.\/|\/|\.\\|\\/g,"_"),c=function(M){switch(M){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(A);let j=X+c;S.some((M=>M.uri===j))&&(j="".concat(X,"_").concat(z.Tools.RandomId()).concat(c)),Q={name:M,uri:j},this._exporter._imageData[j]={data:O,mimeType:A}}return S.push(Q),S.length-1}_exportTextureInfo(M,A,O){const S=this._exporter._textures;let z=S.findIndex((O=>O.sampler==A&&O.source===M));-1===z&&(z=S.length,S.push({source:M,sampler:A}));const Q={index:z};return O&&(Q.texCoord=O),Q}_exportTextureSampler(M){const A=this._getTextureSampler(M),O=this._exporter._samplers,S=O.findIndex((M=>M.minFilter===A.minFilter&&M.magFilter===A.magFilter&&M.wrapS===A.wrapS&&M.wrapT===A.wrapT));return-1!==S?S:(O.push(A),O.length-1)}}var o=O(13059),p=O(12783),v=O(13460),q=O(12974);const r=S.GA.Zero(),n=S.Quaternion.Identity(),a=S.GA.One(),V=new S.GA(-1,1,1);function Z(M,A){const{byteOffset:O,byteStride:S,type:z,normalized:Q}=M,X=M.getSize(),c=A.reduce(((M,A)=>A.getTotalVertices()>M?A.getTotalVertices():M),-Number.MAX_VALUE);return{byteOffset:O,byteStride:S,componentCount:X,type:z,count:c*X,normalized:Q,totalVertices:c,kind:M.getKind()}}function P(M){switch(M){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function mM(M){switch(M){case e.c.PositionKind:case e.c.NormalKind:case e.c.TangentKind:case e.c.ColorKind:case e.c.MatricesIndicesKind:case e.c.MatricesIndicesExtraKind:case e.c.MatricesWeightsKind:case e.c.MatricesWeightsExtraKind:case e.c.UVKind:case e.c.UV2Kind:case e.c.UV3Kind:case e.c.UV4Kind:case e.c.UV5Kind:case e.c.UV6Kind:return!0}return!1}function R(M){switch(M){case Q.b.TriangleFillMode:return 4;case Q.b.TriangleStripDrawMode:return 5;case Q.b.TriangleFanDrawMode:return 6;case Q.b.PointListDrawMode:case Q.b.PointFillMode:return 0;case Q.b.LineLoopDrawMode:return 2;case Q.b.LineListDrawMode:return 1;case Q.b.LineStripDrawMode:return 3}throw new Error("Unknown fill mode: ".concat(M))}function k(M){const A=Math.sqrt(M.x*M.x+M.y*M.y+M.z*M.z);A>0&&(M.x/=A,M.y/=A,M.z/=A)}function W(M){return M.x*=-1,M}function l(M){if(M.x*M.x+M.y*M.y>.5){const A=Math.abs(M.x),O=Math.abs(M.y);if(A>O){const O=Math.sign(M.x);M.x=A,M.y*=-O,M.z*=-O,M.w*=O}else{const A=Math.sign(M.y);M.x*=-A,M.y=O,M.z*=A,M.w*=-A}}else{const A=Math.abs(M.z),O=Math.abs(M.w);if(A>O){const O=Math.sign(M.z);M.x*=-O,M.y*=O,M.z=A,M.w*=-O}else{const A=Math.sign(M.w);M.x*=A,M.y*=-A,M.z*=-A,M.w=O}}return M}function MM(M){M.Yc(-M.z,M.w,M.x,-M.y)}function AM(M,A){const O=S.GA.FromArrayToRef(A.translation||[0,0,0],0,S.TmpVectors.GA[0]),z=S.Quaternion.FromArrayToRef(A.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[0]),Q=S.Matrix.ComposeToRef(a,z,O,S.TmpVectors.Matrix[0]),X=S.GA.FromArrayToRef(M.translation||[0,0,0],0,S.TmpVectors.GA[2]),c=S.Quaternion.FromArrayToRef(M.rotation||[0,0,0,1],0,S.TmpVectors.Quaternion[1]),j=S.Matrix.ComposeToRef(a,c,X,S.TmpVectors.Matrix[1]);Q.multiplyToRef(j,j),j.decompose(void 0,z,O),O.equalsWithEpsilon(r,q.e)?delete A.translation:A.translation=O.gc(),z.equalsWithEpsilon(n,q.e)?delete A.rotation:A.rotation=z.gc(),A.scale&&delete A.scale}function OM(M,A){if(!(A instanceof T.e))return!1;if(!(1===A.getChildren().length&&0===M.getChildren().length&&M.parent===A))return!1;const O=M.HM(),S=M instanceof v.b&&!O.useRightHandedSystem?V:a;return!!A.Ec.equalsWithEpsilon(S,q.e)||(p.c.Warn("Cannot collapse node ".concat(M.name," into parent node ").concat(A.name," with modified scaling.")),!1)}function SM(M){if(M instanceof Array){const A=new Float32Array(M);return new Uint8Array(A.buffer,A.byteOffset,A.byteLength)}return ArrayBuffer.isView(M)?new Uint8Array(M.buffer,M.byteOffset,M.byteLength):new Uint8Array(M)}function zM(M,A){for(const[O,S]of Object.entries(M)){const z=A[O];(Array.isArray(S)&&Array.isArray(z)&&QM(S,z)||S===z)&&delete M[O]}return M}function QM(M,A){return M.length===A.length&&M.every(((M,O)=>M===A[O]))}const XM=S.Matrix.Compose(new S.GA(-1,1,1),S.Quaternion.Identity(),S.GA.Zero());function cM(M,A){if(!(M instanceof T.e))return!1;if(A){if(!M.getWorldMatrix().equalsWithEpsilon(S.Matrix.IdentityReadOnly,q.e))return!1}else{if(!M.getWorldMatrix().multiplyToRef(XM,S.TmpVectors.Matrix[0]).equalsWithEpsilon(S.Matrix.IdentityReadOnly,q.e))return!1}return!(M instanceof J.d&&M.wc)}const jM=new Map([[Int8Array,(M,A,O)=>M.setInt8(A,O)],[Uint8Array,(M,A,O)=>M.setUint8(A,O)],[Uint8ClampedArray,(M,A,O)=>M.setUint8(A,O)],[Int16Array,(M,A,O)=>M.setInt16(A,O,!0)],[Uint16Array,(M,A,O)=>M.setUint16(A,O,!0)],[Int32Array,(M,A,O)=>M.setInt32(A,O,!0)],[Uint32Array,(M,A,O)=>M.setUint32(A,O,!0)],[Float32Array,(M,A,O)=>M.setFloat32(A,O,!0)],[Float64Array,(M,A,O)=>M.setFloat64(A,O,!0)]]);class BM{writeTypedArray(M){this._checkGrowBuffer(M.byteLength);const A=jM.get(M.constructor);for(let O=0;O<M.length;O++)A(this._dataView,this._byteOffset,M[O]),this._byteOffset+=M.BYTES_PER_ELEMENT}constructor(M){this._data=new Uint8Array(M),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(M){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,M),this._byteOffset++}writeInt8(M){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,M),this._byteOffset++}writeInt16(M){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,M,!0),this._byteOffset+=2}writeUInt16(M){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,M,!0),this._byteOffset+=2}writeInt32(M){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,M,!0),this._byteOffset+=4}writeUInt32(M){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat32(M){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,M,!0),this._byteOffset+=4}writeFloat64(M){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,M,!0),this._byteOffset+=8}_checkGrowBuffer(M){const A=this.byteOffset+M;if(A>this._data.byteLength){const M=new Uint8Array(2*A);M.set(this._data),this._data=M,this._dataView=new DataView(this._data.buffer)}}}function gM(M){return M%4===0?4:M%2===0?2:1}class eM{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(M){let A=0;this._bufferViewToData.forEach((M=>{A+=M.byteLength}));const O=new BM(A),S=Array.from(this._bufferViewToData.keys()).sort(((M,A)=>gM(A.byteLength)-gM(M.byteLength)));for(const z of S){z.byteOffset=O.byteOffset,M.push(z);const A=M.length-1,S=this.getPropertiesWithBufferView(z);for(const M of S)M.bufferView=A;O.writeTypedArray(this._bufferViewToData.get(z)),this._bufferViewToData.delete(z)}return O.getOutputData()}createBufferView(M,A){const O={buffer:0,byteOffset:void 0,byteLength:M.byteLength,byteStride:A};return this._bufferViewToData.set(O,M),O}createAccessor(M,A,O,S,z,Q,X){this._verifyBufferView(M);const c={bufferView:void 0,componentType:O,count:S,type:A,min:null===Q||void 0===Q?void 0:Q.min,max:null===Q||void 0===Q?void 0:Q.max,normalized:X,byteOffset:z};return this.setBufferView(c,M),this._accessorToBufferView.set(c,M),c}setBufferView(M,A){this._verifyBufferView(A);this.getPropertiesWithBufferView(A).push(M)}removeBufferView(M){const A=this.getPropertiesWithBufferView(M);for(const O of A)void 0!==O.bufferView&&delete O.bufferView;this._bufferViewToData.delete(M),this._bufferViewToProperties.delete(M),this._accessorToBufferView.forEach(((A,O)=>{A===M&&(void 0!==O.byteOffset&&delete O.byteOffset,this._accessorToBufferView.delete(O))}))}getBufferView(M){const A=this._accessorToBufferView.get(M);return this._verifyBufferView(A),A}getPropertiesWithBufferView(M){var A;return this._verifyBufferView(M),this._bufferViewToProperties.set(M,null!==(A=this._bufferViewToProperties.get(M))&&void 0!==A?A:[]),this._bufferViewToProperties.get(M)}getData(M){return this._verifyBufferView(M),this._bufferViewToData.get(M)}_verifyBufferView(M){if(void 0===M||!this._bufferViewToData.has(M))throw new Error("BufferView ".concat(M," not found in BufferManager."))}}var TM,JM=O(13428),KM=O(13440),GM=O(13467),dM=O(13338),wM=O(13499),IM=O(13513),bM=O(13422),sM=O(13522);!function(M){M[M.INTANGENT=0]="INTANGENT",M[M.OUTTANGENT=1]="OUTTANGENT"}(TM||(TM={}));class YM{static _IsTransformable(M){return M&&(M instanceof T.e||M instanceof JM.c||M instanceof sM.d)}static _CreateNodeAnimation(M,A,O,S,Q){if(this._IsTransformable(M)){const X=[],c=[],j=A.getKeys(),B=YM._CalculateMinMaxKeyFrames(j),g=YM._DeduceInterpolation(j,O,S),e=g.interpolationType,T=g.shouldBakeAnimation;if(T?YM._CreateBakedAnimation(M,A,O,B.min,B.max,A.framePerSecond,Q,X,c,B,S):"LINEAR"===e||"STEP"===e?YM._CreateLinearOrStepAnimation(M,A,O,X,c,S):"CUBICSPLINE"===e?YM._CreateCubicSplineAnimation(M,A,O,X,c,S):YM._CreateBakedAnimation(M,A,O,B.min,B.max,A.framePerSecond,Q,X,c,B,S),X.length&&c.length){return{inputs:X,outputs:c,samplerInterpolation:e,inputsMin:T?B.min:z.Tools.FloatRound(B.min/A.framePerSecond),inputsMax:T?B.max:z.Tools.FloatRound(B.max/A.framePerSecond)}}}return null}static _DeduceAnimationInfo(M){let A=null,O="VEC3",S=!1;const Q=M.targetProperty.split(".");switch(Q[0]){case"Ec":A="scale";break;case"position":A="translation";break;case"rotation":O="VEC4",A="rotation";break;case"rotationQuaternion":O="VEC4",S=!0,A="rotation";break;case"influence":O="SCALAR",A="weights";break;default:z.Tools.Error("Unsupported animatable property ".concat(Q[0]))}return A?{animationChannelTargetPath:A,dataAccessorType:O,useQuaternion:S}:(z.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(M,A,O,S,z,Q,X,c,j,B,g){let e;if(YM._IsTransformable(M)&&M.animations)for(const T of M.animations){if(g&&!g(T))continue;const z=YM._DeduceAnimationInfo(T);z&&(e={name:T.name,samplers:[],channels:[]},YM._AddAnimation("".concat(T.name),T.hasRunningRuntimeAnimations?A:e,M,T,z.dataAccessorType,z.animationChannelTargetPath,S,Q,X,c,z.useQuaternion,j,B),e.samplers.length&&e.channels.length&&O.push(e))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(M,A,O,S,z,Q,X,c,j,B,g){let e;if(M instanceof bM.d){const z=M.morphTargetManager;if(z)for(let T=0;T<z.numTargets;++T){const J=z.getTarget(T);for(const K of J.animations){if(g&&!g(K))continue;const J=new wM.b("".concat(K.name),"influence",K.framePerSecond,K.dataType,K.loopMode,K.enableBlending),G=[],d=K.getKeys();for(let M=0;M<d.length;++M){const A=d[M];for(let M=0;M<z.numTargets;++M)M==T?G.push(A):G.push({frame:A.frame,value:0})}J.setKeys(G);const w=YM._DeduceAnimationInfo(J);w&&(e={name:J.name,samplers:[],channels:[]},YM._AddAnimation(K.name,K.hasRunningRuntimeAnimations?A:e,M,J,w.dataAccessorType,w.animationChannelTargetPath,S,Q,X,c,w.useQuaternion,j,B,z.numTargets),e.samplers.length&&e.channels.length&&O.push(e))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(M,A,O,S,z,Q,X,c,j){let B;if(M.animationGroups){const e=M.animationGroups;for(const T of e){const e=new Map,J=new Map,K=new Set,G=T.to-T.from;B={name:T.name,channels:[],samplers:[]};for(let A=0;A<T.targetedAnimations.length;++A){const G=T.targetedAnimations[A],d=G.target,w=G.animation;if(j&&!j(w))continue;const I=c.has(d);if(this._IsTransformable(d)||1===d.length&&this._IsTransformable(d[0])){const M=YM._DeduceAnimationInfo(G.animation);if(M){const A=this._IsTransformable(d)?d:this._IsTransformable(d[0])?d[0]:null;A&&YM._AddAnimation("".concat(w.name),B,A,w,M.dataAccessorType,M.animationChannelTargetPath,O,S,z,Q,M.useQuaternion,X,I)}}else if(d instanceof IM.c||1===d.length&&d[0]instanceof IM.c){if(YM._DeduceAnimationInfo(G.animation)){const A=d instanceof IM.c?d:d[0];if(A){const O=M.morphTargetManagers.find((M=>{for(let O=0;O<M.numTargets;++O)if(M.getTarget(O)===A)return!0;return!1}));if(O){const S=M.meshes.find((M=>M.morphTargetManager===O));var g;if(S)e.has(S)||e.set(S,new Map),null===(g=e.get(S))||void 0===g||g.set(A,w),K.add(S),J.set(S,w)}}}}}K.forEach((M=>{const A=M.morphTargetManager;let c=null;const j=[],g=J.get(M).getKeys(),K=g.length;for(let O=0;O<K;++O)for(let S=0;S<A.numTargets;++S){const z=A.getTarget(S),Q=e.get(M);if(Q){const A=Q.get(z);A?(c||(c=new wM.b("".concat(T.name,"_").concat(M.name,"_MorphWeightAnimation"),"influence",A.framePerSecond,wM.b.ANIMATIONTYPE_FLOAT,A.loopMode,A.enableBlending)),j.push(A.getKeys()[O])):j.push({frame:T.from+G/K*O,value:z.influence,inTangent:g[0].inTangent?0:void 0,outTangent:g[0].outTangent?0:void 0})}}c.setKeys(j);const d=YM._DeduceAnimationInfo(c);d&&YM._AddAnimation("".concat(T.name,"_").concat(M.name,"_MorphWeightAnimation"),B,M,c,d.dataAccessorType,d.animationChannelTargetPath,O,S,z,Q,d.useQuaternion,X,!1,null===A||void 0===A?void 0:A.numTargets)})),B.channels.length&&B.samplers.length&&A.push(B)}}}static _AddAnimation(M,A,O,z,Q,X,c,j,B,g,e,T,J,K){const G=YM._CreateNodeAnimation(O,z,X,e,T);let d,w,I,b,s,Y;if(G){if(K){let M=0,A=0;const O=[];for(;G.inputs.length>0;)A=G.inputs.shift(),M%K==0&&O.push(A),M++;G.inputs=O}const M=c.get(O),z=new Float32Array(G.inputs);d=j.createBufferView(z),w=j.createAccessor(d,"SCALAR",5126,G.inputs.length,void 0,{min:[G.inputsMin],max:[G.inputsMax]}),g.push(w),I=g.length-1;const B=new S.Quaternion,e=new S.GA,T=new S.GA,E=O instanceof JM.c,H=P(Q),C=new Float32Array(G.outputs.length*H);G.outputs.forEach((function(M,A){let O=M;switch(X){case"translation":J&&(S.GA.FromArrayToRef(M,0,T),W(T),T.toArray(O));break;case"rotation":4===M.length?S.Quaternion.FromArrayToRef(M,0,B):(O=new Array(4),S.GA.FromArrayToRef(M,0,e),S.Quaternion.FromEulerVectorToRef(e,B)),J&&(l(B),E&&MM(B)),B.toArray(O)}C.set(O,A*H)})),d=j.createBufferView(C),w=j.createAccessor(d,Q,5126,G.outputs.length),g.push(w),b=g.length-1,s={interpolation:G.samplerInterpolation,input:I,output:b},A.samplers.push(s),Y={sampler:A.samplers.length-1,target:{node:M,path:X}},A.channels.push(Y)}}static _CreateBakedAnimation(M,A,O,Q,X,c,j,B,g,e,T){let J;const K=S.Quaternion.Identity();let G,d=null,w=null,I=null,b=null,s=null,Y=null;e.min=z.Tools.FloatRound(Q/c);const E=A.getKeys();for(let S=0,H=E.length;S<H;++S){if(Y=null,I=E[S],S+1<H)if(b=E[S+1],I.value.equals&&I.value.equals(b.value)||I.value===b.value){if(0!==S)continue;Y=I.frame}else Y=b.frame;else{if(s=E[S-1],I.value.equals&&I.value.equals(s.value)||I.value===s.value)continue;Y=X}if(Y)for(let S=I.frame;S<=Y;S+=j){if(G=z.Tools.FloatRound(S/c),G===d)continue;d=G,w=G;const Q={key:0,repeatCount:0,loopMode:A.loopMode};J=A._interpolate(S,Q),YM._SetInterpolatedValue(M,J,G,A,O,K,B,g,T)}}w&&(e.max=w)}static _ConvertFactorToVector3OrQuaternion(M,A,O,Q,X){const c=YM._GetBasePositionRotationOrScale(A,Q,X),j=O.targetProperty.split("."),B=j?j[1]:"",g=X?S.Quaternion.sA(c).normalize():S.GA.sA(c);switch(B){case"x":case"y":case"z":g[B]=M;break;case"w":g.w=M;break;default:z.Tools.Error('glTFAnimation: Unsupported component name "'.concat(B,'"!'))}return g}static _SetInterpolatedValue(M,A,O,z,Q,X,c,j,B){let g;c.push(O),"weights"!==Q?(z.dataType===wM.b.ANIMATIONTYPE_FLOAT&&(A=this._ConvertFactorToVector3OrQuaternion(A,M,z,Q,B)),"rotation"===Q?(B?X=A:(g=A,S.Quaternion.RotationYawPitchRollToRef(g.y,g.x,g.z,X)),j.push(X.gc())):(g=A,j.push(g.gc()))):j.push([A])}static _CreateLinearOrStepAnimation(M,A,O,S,z,Q){for(const X of A.getKeys())S.push(X.frame/A.framePerSecond),YM._AddKeyframeValue(X,A,z,O,M,Q)}static _CreateCubicSplineAnimation(M,A,O,S,z,Q){A.getKeys().forEach((function(X){S.push(X.frame/A.framePerSecond),YM._AddSplineTangent(TM.INTANGENT,z,O,"CUBICSPLINE",X,Q),YM._AddKeyframeValue(X,A,z,O,M,Q),YM._AddSplineTangent(TM.OUTTANGENT,z,O,"CUBICSPLINE",X,Q)}))}static _GetBasePositionRotationOrScale(M,A,O){let z;if("rotation"===A)if(O){const A=M.rotationQuaternion;z=(null!==A&&void 0!==A?A:S.Quaternion.Identity()).gc()}else{const A=M.rotation;z=(null!==A&&void 0!==A?A:S.GA.Zero()).gc()}else if("translation"===A){const A=M.position;z=(null!==A&&void 0!==A?A:S.GA.Zero()).gc()}else{const A=M.Ec;z=(null!==A&&void 0!==A?A:S.GA.One()).gc()}return z}static _AddKeyframeValue(M,A,O,Q,X,c){let j;const B=A.dataType;if(B===wM.b.ANIMATIONTYPE_VECTOR3){let A=M.value.gc();if("rotation"===Q){const M=S.GA.sA(A);A=S.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).gc()}O.push(A)}else if(B===wM.b.ANIMATIONTYPE_FLOAT){if("weights"===Q)O.push([M.value]);else if(j=this._ConvertFactorToVector3OrQuaternion(M.value,X,A,Q,c),j){if("rotation"===Q){const M=c?j:S.Quaternion.RotationYawPitchRoll(j.y,j.x,j.z).normalize();O.push(M.gc())}O.push(j.gc())}}else B===wM.b.ANIMATIONTYPE_QUATERNION?O.push(M.value.normalize().gc()):z.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(M,A,O){let S,z,Q=!1;if("rotation"===A&&!O)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let X=0,c=M.length;X<c;++X)if(z=M[X],z.inTangent||z.outTangent)if(S){if("CUBICSPLINE"!==S){S="LINEAR",Q=!0;break}}else S="CUBICSPLINE";else if(S){if("CUBICSPLINE"===S||z.interpolation&&1===z.interpolation&&"STEP"!==S){S="LINEAR",Q=!0;break}}else S=z.interpolation&&1===z.interpolation?"STEP":"LINEAR";return S||(S="LINEAR"),{interpolationType:S,shouldBakeAnimation:Q}}static _AddSplineTangent(M,A,O,z,Q,X){let c;const j=M===TM.INTANGENT?Q.inTangent:Q.outTangent;if("CUBICSPLINE"===z){if("rotation"===O)if(j)if(X)c=j.gc();else{const M=j;c=S.Quaternion.RotationYawPitchRoll(M.y,M.x,M.z).gc()}else c=[0,0,0,0];else c="weights"===O?j?[j]:[0]:j?j.gc():[0,0,0];A.push(c)}}static _CalculateMinMaxKeyFrames(M){let A=1/0,O=-1/0;return M.forEach((function(M){A=Math.min(A,M.frame),O=Math.max(O,M.frame)})),{min:A,max:O}}}function EM(M,A,O,Q,X,c){const j={attributes:{},influence:M.influence,name:M.name},B=A.wc;if(!B)return z.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),j;const g=c?-1:1,T=S.GA.Zero();let J=0,K=0;if(M.hasPositions){const Q=M.getPositions(),c=B.getVerticesData(e.c.PositionKind);if(c){const M=new Float32Array(c.length),A=[1/0,1/0,1/0],z=[-1/0,-1/0,-1/0];K=c.length/3,J=0;for(let O=J;O<K;++O){const X=S.GA.sA(c,3*O);S.GA.sA(Q,3*O).subtractToRef(X,T),T.x*=g,A[0]=Math.min(A[0],T.x),z[0]=Math.max(z[0],T.x),A[1]=Math.min(A[1],T.y),z[1]=Math.max(z[1],T.y),A[2]=Math.min(A[2],T.z),z[2]=Math.max(z[2],T.z),M[3*O]=T.x,M[3*O+1]=T.y,M[3*O+2]=T.z}const B=O.createBufferView(M,12),e=O.createAccessor(B,"VEC3",5126,Q.length/3,0,{min:A,max:z});X.push(e),j.attributes.POSITION=X.length-1}else z.Tools.Warn("Morph target positions for mesh ".concat(A.name," were not exported. Mesh does not have position vertex data"))}if(M.hasNormals){const Q=M.getNormals(),c=B.getVerticesData(e.c.NormalKind);if(c){const M=new Float32Array(c.length);K=c.length/3,J=0;for(let O=J;O<K;++O){const A=S.GA.sA(c,3*O).normalize();S.GA.sA(Q,3*O).normalize().subtractToRef(A,T),M[3*O]=T.x*g,M[3*O+1]=T.y,M[3*O+2]=T.z}const A=O.createBufferView(M,12),z=O.createAccessor(A,"VEC3",5126,Q.length/3,0);X.push(z),j.attributes.NORMAL=X.length-1}else z.Tools.Warn("Morph target normals for mesh ".concat(A.name," were not exported. Mesh does not have normals vertex data"))}if(M.hasTangents){const Q=M.getTangents(),c=B.getVerticesData(e.c.TangentKind);if(c){K=c.length/4;const M=new Float32Array(3*K);J=0;for(let O=J;O<K;++O){const A=S.GA.sA(c,4*O);k(A);const z=S.GA.sA(Q,3*O);k(z),z.subtractToRef(A,T),M[3*O]=T.x*g,M[3*O+1]=T.y,M[3*O+2]=T.z}const A=O.createBufferView(M,12),z=O.createAccessor(A,"VEC3",5126,K,0);X.push(z),j.attributes.TANGENT=X.length-1}else z.Tools.Warn("Morph target tangents for mesh ".concat(A.name," were not exported. Mesh does not have tangents vertex data"))}if(M.hasColors){const Q=M.getColors(),c=B.getVerticesData(e.c.ColorKind),g=B.getVertexBuffer(e.c.ColorKind);if(c&&g){const M=g.getSize();K=c.length/M;const A=new Float32Array(K*M);J=0;for(let O=J;O<K;++O)if(3===M){const z=S.GA.sA(c,O*M);S.GA.sA(Q,O*M).subtractToRef(z,T),A[3*O]=T.x,A[3*O+1]=T.y,A[3*O+2]=T.z}else if(4===M){const z=new S.Vector4,X=S.Vector4.sA(c,O*M);S.Vector4.sA(Q,O*M).subtractToRef(X,z),A[4*O]=z.x,A[4*O+1]=z.y,A[4*O+2]=z.z,A[4*O+3]=z.w}else z.Tools.Warn("Unsupported number of components for color attribute: ".concat(M));const B=O.createBufferView(A,4*M),e=O.createAccessor(B,3===M?"VEC3":"VEC4",5126,K,0);X.push(e),j.attributes.COLOR_0=X.length-1}else z.Tools.Warn("Morph target colors for mesh ".concat(A.name," were not exported. Mesh does not have colors vertex data"))}return j}var HM=O(13526),CM=O(13367),fM=O(13350),DM=O(12919);class FM{}FM.DEFAULT_COLOR=w.bA.White(),FM.DEFAULT_WIDTH_ATTENUATED=1,FM.DEFAULT_WIDTH=.1;var NM=O(13189),yM=O(13530);class hM{static ConvertPoints(M,A){if(M.length&&Array.isArray(M)&&"number"===typeof M[0])return[M];if(M.length&&Array.isArray(M[0])&&"number"===typeof M[0][0])return M;if(M.length&&!Array.isArray(M[0])&&M[0]instanceof S.GA){const A=[];for(let O=0;O<M.length;O++){const S=M[O];A.push(S.x,S.y,S.z)}return[A]}if(M.length>0&&Array.isArray(M[0])&&M[0].length>0&&M[0][0]instanceof S.GA){const A=[],O=M;for(const M of O)A.push(M.flatMap((M=>[M.x,M.y,M.z])));return A}if(M instanceof Float32Array){if(null!==A&&void 0!==A&&A.floatArrayStride){const O=[],S=3*A.floatArrayStride;for(let A=0;A<M.length;A+=S){const z=new Array(S);for(let O=0;O<S;O++)z[O]=M[A+O];O.push(z)}return O}return[Array.from(M)]}if(M.length&&M[0]instanceof Float32Array){const A=[];for(const O of M)A.push(Array.from(O));return A}return[]}static OmitZeroLengthPredicate(M,A,O){const S=[];return A.dA(M).lengthSquared()>0&&S.push([M,A]),O.dA(A).lengthSquared()>0&&S.push([A,O]),M.dA(O).lengthSquared()>0&&S.push([O,M]),0===S.length?null:S}static OmitDuplicatesPredicate(M,A,O,S){const z=[];return hM._SearchInPoints(M,A,S)||z.push([M,A]),hM._SearchInPoints(A,O,S)||z.push([A,O]),hM._SearchInPoints(O,M,S)||z.push([O,M]),0===z.length?null:z}static _SearchInPoints(M,A,O){for(const X of O)for(let O=0;O<X.length;O++){var S,z,Q;if(null!==(S=X[O])&&void 0!==S&&S.equals(M))if(null!==(z=X[O+1])&&void 0!==z&&z.equals(A)||null!==(Q=X[O-1])&&void 0!==Q&&Q.equals(A))return!0}return!1}static MeshesToLines(M,A){const O=[];for(let z=0;z<M.length;z++){const Q=M[z],X=Q.getVerticesData(e.c.PositionKind),c=Q.Ic();if(X&&c)for(let M=0,j=0;M<c.length;M++){const B=3*c[j++],g=3*c[j++],e=3*c[j++],T=new S.GA(X[B],X[B+1],X[B+2]),J=new S.GA(X[g],X[g+1],X[g+2]),K=new S.GA(X[e],X[e+1],X[e+2]);if(A){const S=A(T,J,K,O,M,B,Q,z,X,c);if(S)for(const M of S)O.push(M)}else O.push([T,J],[J,K],[K,T])}}return O}static ToVector3Array(M){if(Array.isArray(M[0])){const A=[],O=M;for(const M of O){const O=[];for(let A=0;A<M.length;A+=3)O.push(new S.GA(M[A],M[A+1],M[A+2]));A.push(O)}return A}const A=M,O=[];for(let z=0;z<A.length;z+=3)O.push(new S.GA(A[z],A[z+1],A[z+2]));return O}static ToNumberArray(M){return M.flatMap((M=>[M.x,M.y,M.z]))}static GetPointsCountInfo(M){const A=new Array(M.length);let O=0;for(let S=M.length;S--;)A[S]=M[S].length/3,O+=A[S];return{total:O,counts:A}}static GetLineLength(M){if(0===M.length)return 0;let A;A="number"===typeof M[0]?hM.ToVector3Array(M):M;const O=S.TmpVectors.GA[0];let z=0;for(let S=0;S<A.length-1;S++){const M=A[S];z+=A[S+1].subtractToRef(M,O).length()}return z}static GetLineLengthArray(M){const A=new Float32Array(M.length/3);let O=0;for(let S=0,z=M.length/3-1;S<z;S++){let z=M[3*S+0],Q=M[3*S+1],X=M[3*S+2];z-=M[3*S+3],Q-=M[3*S+4],X-=M[3*S+5];O+=Math.sqrt(z*z+Q*Q+X*X),A[S+1]=O}return A}static SegmentizeSegmentByCount(M,A,O){const z=[],Q=A.dA(M),X=S.TmpVectors.GA[0];X.Hc(O);const c=S.TmpVectors.GA[1];Q.divideToRef(X,c);let j=M.clone();z.push(j);for(let S=0;S<O;S++)j=j.clone(),z.push(j.addInPlace(c));return z}static SegmentizeLineBySegmentLength(M,A){const O=M[0]instanceof S.GA?hM.GetLineSegments(M):"number"===typeof M[0]?hM.GetLineSegments(hM.ToVector3Array(M)):M,z=[];for(const S of O)if(S.length>A){const M=hM.SegmentizeSegmentByCount(S.point1,S.point2,Math.ceil(S.length/A));for(const A of M)z.push(A)}else z.push(S.point1),z.push(S.point2);return z}static SegmentizeLineBySegmentCount(M,A){const O="number"===typeof M[0]?hM.ToVector3Array(M):M,S=hM.GetLineLength(O)/A;return hM.SegmentizeLineBySegmentLength(O,S)}static GetLineSegments(M){const A=[];for(let O=0;O<M.length-1;O++){const S=M[O],z=M[O+1],Q=z.dA(S).length();A.push({point1:S,point2:z,length:Q})}return A}static GetMinMaxSegmentLength(M){const A=hM.GetLineSegments(M).sort((M=>M.length));return{min:A[0].length,max:A[A.length-1].length}}static GetPositionOnLineByVisibility(M,A,O){let z=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Q=A*O;let X=0,c=0;const j=M.length;for(let S=0;S<j;S++){if(Q<=X+M[S].length){c=S;break}X+=M[S].length}const B=(Q-X)/M[c].length;return M[c].point2.subtractToRef(M[c].point1,S.TmpVectors.GA[0]),S.TmpVectors.GA[1]=S.TmpVectors.GA[0].multiplyByFloats(B,B,B),z||S.TmpVectors.GA[1].addInPlace(M[c].point1),S.TmpVectors.GA[1].clone()}static GetCircleLinePoints(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,z=arguments.length>3&&void 0!==arguments[3]?arguments[3]:M,Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/A;const X=[];for(let c=0;c<=A;c++)X.push(new S.GA(Math.cos(c*Q)*M,Math.sin(c*Q)*z,O));return X}static GetBezierLinePoints(M,A,O,S){return NM.i.CreateQuadraticBezier(M,A,O,S).getPoints().flatMap((M=>[M.x,M.y,M.z]))}static GetArrowCap(M,A,O,S,z){let Q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,X=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[M.clone(),M.add(A.multiplyByFloats(O,O,O))],widths:[S,z,Q,X]}}static GetPointsFromText(M,A,O,S){let z=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,Q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const X=[],c=(0,yM.c)(M,A,O,S);for(const j of c){for(const M of j.paths){const A=[],O=M.getPoints();for(const M of O)A.push(M.x,M.y,z);X.push(A)}if(Q)for(const M of j.holes){const A=[],O=M.getPoints();for(const M of O)A.push(M.x,M.y,z);X.push(A)}}return X}static Color3toRGBAUint8(M){const A=new Uint8Array(4*M.length);for(let O=0,S=0;O<M.length;O++)A[S++]=255*M[O].r,A[S++]=255*M[O].g,A[S++]=255*M[O].b,A[S++]=255;return A}static CreateColorsTexture(M,A,O,S){var z;const Q=null!==(z=S.getEngine().getCaps().maxTextureSize)&&void 0!==z?z:1,X=A.length>Q?Q:A.length,c=Math.ceil(A.length/Q);c>1&&(A=[...A,...Array(X*c-A.length).fill(A[0])]);const j=hM.Color3toRGBAUint8(A),B=new H.d(j,X,c,G.b.TEXTUREFORMAT_RGBA,S,!1,!0,O);return B.name=M,B}static PrepareEmptyColorsTexture(M){if(!FM.EmptyColorsTexture){const A=new Uint8Array(4);FM.EmptyColorsTexture=new H.d(A,1,1,G.b.TEXTUREFORMAT_RGBA,M,!1,!1,H.d.NEAREST_NEAREST),FM.EmptyColorsTexture.name="grlEmptyColorsTexture"}return FM.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var M;null===(M=FM.EmptyColorsTexture)||void 0===M||M.dispose(),FM.EmptyColorsTexture=null}static BooleanToNumber(M){return M?1:0}}class uM extends fM.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class iM extends CM.d{isCompatible(M){return!0}constructor(M,A,O){var z,Q,X,c,j,B,g,e,T,J,K,G,d,w,I,b,s;O=O||{color:FM.DEFAULT_COLOR};const Y=new uM;var E;(Y.GREASED_LINE_HAS_COLOR=!!O.color&&!O.useColors,Y.GREASED_LINE_SIZE_ATTENUATION=null!==(z=O.sizeAttenuation)&&void 0!==z&&z,Y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===O.colorDistributionType,Y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(null!==A&&void 0!==A?A:M.HM()).useRightHandedSystem,Y.GREASED_LINE_CAMERA_FACING=null===(Q=O.cameraFacing)||void 0===Q||Q,super(M,iM.GREASED_LINE_MATERIAL_NAME,200,Y,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(X=O)||void 0===X?void 0:X.forceGLSL)||iM.ForceGLSL,this._scene=null!==A&&void 0!==A?A:M.HM(),this._engine=this._scene.getEngine(),this._cameraFacing=null===(c=O.cameraFacing)||void 0===c||c,this.visibility=null!==(j=O.visibility)&&void 0!==j?j:1,this.useDash=null!==(B=O.useDash)&&void 0!==B&&B,this.dashRatio=null!==(g=O.dashRatio)&&void 0!==g?g:.5,this.dashOffset=null!==(e=O.dashOffset)&&void 0!==e?e:0,this.width=O.width?O.width:O.sizeAttenuation?FM.DEFAULT_WIDTH_ATTENUATED:FM.DEFAULT_WIDTH,this._sizeAttenuation=null!==(T=O.sizeAttenuation)&&void 0!==T&&T,this.colorMode=null!==(J=O.colorMode)&&void 0!==J?J:0,this._color=null!==(K=O.color)&&void 0!==K?K:null,this.useColors=null!==(G=O.useColors)&&void 0!==G&&G,this._colorsDistributionType=null!==(d=O.colorDistributionType)&&void 0!==d?d:0,this.colorsSampling=null!==(w=O.colorsSampling)&&void 0!==w?w:H.d.NEAREST_NEAREST,this._colors=null!==(I=O.FM)&&void 0!==I?I:null,this.dashCount=null!==(b=O.dashCount)&&void 0!==b?b:1,this.resolution=null!==(s=O.resolution)&&void 0!==s?s:new S.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),O.colorsTexture)?this.colorsTexture=O.colorsTexture:this._colors?this.colorsTexture=hM.CreateColorsTexture("".concat(M.name,"-colors-texture"),this._colors,this.colorsSampling,this._scene):(this._color=null!==(E=this._color)&&void 0!==E?E:FM.DEFAULT_COLOR,hM.PrepareEmptyColorsTexture(this._scene));this._engine.Ac.add((()=>{hM.DisposeEmptyColorsTexture()}))}getAttributes(M){M.push("grl_offsets"),M.push("grl_widths"),M.push("grl_colorPointers"),M.push("grl_counters"),this._cameraFacing?(M.push("grl_previousAndSide"),M.push("grl_nextAndCounters")):M.push("grl_slopes")}getSamplers(M){M.push("grl_colors")}getActiveTextures(M){this.colorsTexture&&M.push(this.colorsTexture)}getUniforms(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const A=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&A.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===M&&A.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:A,vertex:this._cameraFacing&&this._isGLSL(M)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(M)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(M){var A,O,z;if(this._cameraFacing){M.Kc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||M.Kc("viewProjection",this._scene.getTransformMatrix());const A=S.TmpVectors.Vector4[0];A.x=this._aspect,A.y=this._resolution.x,A.z=this._resolution.y,A.w=this.width,M.updateVector4("grl_aspect_resolution_lineWidth",A)}const Q=S.TmpVectors.Vector4[0];Q.x=hM.BooleanToNumber(this.useDash),Q.y=this._dashArray,Q.z=this.dashOffset,Q.w=this.dashRatio,M.updateVector4("grl_dashOptions",Q);const X=S.TmpVectors.Vector4[1];X.x=this.colorMode,X.y=this.visibility,X.z=this.colorsTexture?this.colorsTexture.getSize().width:0,X.w=hM.BooleanToNumber(this.useColors),M.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",X),this._color&&M.updateColor3("grl_singleColor",this._color);const c=null!==(A=this.colorsTexture)&&void 0!==A?A:FM.EmptyColorsTexture;M.setTexture("grl_colors",c),M.updateFloat2("grl_textureSize",null!==(O=null===c||void 0===c?void 0:c.getSize().width)&&void 0!==O?O:1,null!==(z=null===c||void 0===c?void 0:c.getSize().height)&&void 0!==z?z:1)}prepareDefines(M,A,O){M.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,M.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,M.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,M.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=A.useRightHandedSystem,M.GREASED_LINE_CAMERA_FACING=this._cameraFacing,M.GREASED_LINE_USE_OFFSETS=!!O.offsets}getClassName(){return iM.GREASED_LINE_MATERIAL_NAME}getCustomCode(M){let A=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(A)?function(M,A){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return A&&(M["!gl_Position\\=viewProjection\\*worldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                ")}:null}(M,this._cameraFacing):function(M,A){if("vertex"===M){const M={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return A&&(M["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),M}return"fragment"===M?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == ".concat(0,".) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",1,".) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == ",2,".) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == ",0,".) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == ",1,".) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == ",2,".) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                ")}:null}(M,this._cameraFacing)}dispose(){var M;null===(M=this.colorsTexture)||void 0===M||M.dispose(),super.dispose()}get FM(){return this._colors}set FM(M){this.setColors(M)}setColors(M){var A,O;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=null!==(A=null===(O=this._colors)||void 0===O?void 0:O.length)&&void 0!==A?A:0;var X;if(this._colors=M,null!==M&&0!==M.length){if(!S||z)if(this.colorsTexture&&Q===M.length&&!z){const A=hM.Color3toRGBAUint8(M);this.colorsTexture.update(A)}else{var c;null===(c=this.colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=hM.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),M,this.colorsSampling,this._scene)}}else null===(X=this.colorsTexture)||void 0===X||X.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.markAllDefinesAsDirty()}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==M||null!==this._color&&null===M?(this._color=M,A||this.markAllDefinesAsDirty()):this._color=M}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(M){this._aspect=M.x/M.y,this._resolution=M}serialize(){const M=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(A.FM=this._colors),this._color&&(A.color=this._color),M.greasedLineMaterialOptions=A,M}parse(M,A,O){var S;super.parse(M,A,O);const z=M.greasedLineMaterialOptions;null===(S=this.colorsTexture)||void 0===S||S.dispose(),z.color&&this.setColor(z.color,!0),z.colorDistributionType&&(this.colorsDistributionType=z.colorDistributionType),z.FM&&(this.FM=z.FM),z.colorsSampling&&(this.colorsSampling=z.colorsSampling),z.colorMode&&(this.colorMode=z.colorMode),z.useColors&&(this.useColors=z.useColors),z.visibility&&(this.visibility=z.visibility),z.useDash&&(this.useDash=z.useDash),z.dashCount&&(this.dashCount=z.dashCount),z.dashRatio&&(this.dashRatio=z.dashRatio),z.dashOffset&&(this.dashOffset=z.dashOffset),z.width&&(this.width=z.width),z.sizeAttenuation&&(this.sizeAttenuation=z.sizeAttenuation),z.resolution&&(this.resolution=z.resolution),this.FM?this.colorsTexture=hM.CreateColorsTexture("".concat(this._material.name,"-colors-texture"),this.FM,this.colorsSampling,A):hM.PrepareEmptyColorsTexture(A),this.markAllDefinesAsDirty()}copyTo(M){var A;const O=M;null===(A=O.colorsTexture)||void 0===A||A.dispose(),this._colors&&(O.colorsTexture=hM.CreateColorsTexture("".concat(O._material.name,"-colors-texture"),this._colors,O.colorsSampling,this._scene)),O.setColor(this.color,!0),O.colorsDistributionType=this.colorsDistributionType,O.colorsSampling=this.colorsSampling,O.colorMode=this.colorMode,O.useColors=this.useColors,O.visibility=this.visibility,O.useDash=this.useDash,O.dashCount=this.dashCount,O.dashRatio=this.dashRatio,O.dashOffset=this.dashOffset,O.width=this.width,O.sizeAttenuation=this.sizeAttenuation,O.resolution=this.resolution,O.markAllDefinesAsDirty()}_isGLSL(M){return 0===M||this._forceGLSL}}iM.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",iM.ForceGLSL=!1,(0,DM.g)("BABYLON.".concat(iM.GREASED_LINE_MATERIAL_NAME),iM);var UM=O(13405),LM=O(12786),tM=O(13208),xM=O(12897);class oM extends tM.ShaderMaterial{constructor(M,A,z){var Q,X,c,j,B,g,e,T,J,K,G,d,I,b;const s=A.getEngine(),Y=s.isWebGPU&&!(z.forceGLSL||oM.ForceGLSL),E=["COLOR_DISTRIBUTION_TYPE_LINE ".concat(1,"."),"COLOR_DISTRIBUTION_TYPE_SEGMENT ".concat(0,"."),"COLOR_MODE_SET ".concat(0,"."),"COLOR_MODE_ADD ".concat(1,"."),"COLOR_MODE_MULTIPLY ".concat(2,".")];A.useRightHandedSystem&&E.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];z.cameraFacing?(E.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const f=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];var D;(Y||f.push("world","viewProjection","view","projection"),super(M,A,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:C,uniforms:f,samplers:Y?[]:["grlColors"],defines:E,extraInitializationsAsync:async()=>{Y?await Promise.all([O.e(66).then(O.bind(O,15749)),O.e(75).then(O.bind(O,15751))]):await Promise.all([O.e(69).then(O.bind(O,15759)),O.e(76).then(O.bind(O,15762))])},shaderLanguage:Y?1:0}),this._color=w.bA.White(),this._colorsDistributionType=0,this._colorsTexture=null,z=z||{color:FM.DEFAULT_COLOR},this.visibility=null!==(Q=z.visibility)&&void 0!==Q?Q:1,this.useDash=null!==(X=z.useDash)&&void 0!==X&&X,this.dashRatio=null!==(c=z.dashRatio)&&void 0!==c?c:.5,this.dashOffset=null!==(j=z.dashOffset)&&void 0!==j?j:0,this.dashCount=null!==(B=z.dashCount)&&void 0!==B?B:1,this.width=z.width?z.width:z.sizeAttenuation&&z.cameraFacing?FM.DEFAULT_WIDTH_ATTENUATED:FM.DEFAULT_WIDTH,this.sizeAttenuation=null!==(g=z.sizeAttenuation)&&void 0!==g&&g,this.color=null!==(e=z.color)&&void 0!==e?e:w.bA.White(),this.useColors=null!==(T=z.useColors)&&void 0!==T&&T,this.colorsDistributionType=null!==(J=z.colorDistributionType)&&void 0!==J?J:0,this.colorsSampling=null!==(K=z.colorsSampling)&&void 0!==K?K:H.d.NEAREST_NEAREST,this.colorMode=null!==(G=z.colorMode)&&void 0!==G?G:0,this._colors=null!==(d=z.FM)&&void 0!==d?d:null,this._cameraFacing=null===(I=z.cameraFacing)||void 0===I||I,this.resolution=null!==(b=z.resolution)&&void 0!==b?b:new S.Vector2(s.getRenderWidth(),s.getRenderHeight()),z.colorsTexture)?this.colorsTexture=z.colorsTexture:this._colors?this.colorsTexture=hM.CreateColorsTexture("".concat(this.name,"-colors-texture"),this._colors,this.colorsSampling,A):(this._color=null!==(D=this._color)&&void 0!==D?D:FM.DEFAULT_COLOR,this.colorsTexture=hM.PrepareEmptyColorsTexture(A));if(Y){const M=new xM.d;M.setParameters(),M.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",M)}s.Ac.add((()=>{hM.DisposeEmptyColorsTexture()}))}dispose(){var M;null===(M=this._colorsTexture)||void 0===M||M.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new S.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get FM(){return this._colors}set FM(M){this.setColors(M)}setColors(M){var A,O;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=null!==(A=null===(O=this._colors)||void 0===O?void 0:O.length)&&void 0!==A?A:0;var X;if(this._colors=M,null!==M&&0!==M.length){if(!S||z)if(this._colorsTexture&&Q===M.length&&!z){const A=hM.Color3toRGBAUint8(M);this._colorsTexture.update(A)}else{var c;null===(c=this._colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=hM.CreateColorsTexture("".concat(this.name,"-colors-texture"),M,this.colorsSampling,this.HM())}}else null===(X=this._colorsTexture)||void 0===X||X.dispose()}get colorsTexture(){var M;return null!==(M=this._colorsTexture)&&void 0!==M?M:null}set colorsTexture(M){this._colorsTexture=M,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(M){this._width=M,this.setFloat("grlWidth",M)}get useColors(){return this._useColors}set useColors(M){this._useColors=M,this.setFloat("grlUseColors",hM.BooleanToNumber(M))}get colorsSampling(){return this._colorsSampling}set colorsSampling(M){this._colorsSampling=M}get visibility(){return this._visibility}set visibility(M){this._visibility=M,this.setFloat("grlVisibility",M)}get useDash(){return this._useDash}set useDash(M){this._useDash=M,this.setFloat("grlUseDash",hM.BooleanToNumber(M))}get dashOffset(){return this._dashOffset}set dashOffset(M){this._dashOffset=M,this.setFloat("grlDashOffset",M)}get dashRatio(){return this._dashRatio}set dashRatio(M){this._dashRatio=M,this.setFloat("grlDashRatio",M)}get dashCount(){return this._dashCount}set dashCount(M){this._dashCount=M,this._dashArray=1/M,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(M){this._sizeAttenuation=M,this.setFloat("grlSizeAttenuation",hM.BooleanToNumber(M))}get color(){return this._color}set color(M){this.setColor(M)}setColor(M){var A;M=null!==(A=M)&&void 0!==A?A:FM.DEFAULT_COLOR,this._color=M,this.setColor3("grlColor",M)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(M){this._colorsDistributionType=M,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(M){this._colorMode=M,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(M){this._resolution=M,this.setVector2("grlResolution",M),this.setFloat("grlAspect",M.x/M.y)}serialize(){const M=super.serialize(),A={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(A.FM=this._colors),M.greasedLineMaterialOptions=A,M}parse(M,A,O){var S,z;const Q=M.greasedLineMaterialOptions;null===(S=this._colorsTexture)||void 0===S||S.dispose(),Q.color&&(this.color=Q.color),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),Q.FM?this.colorsTexture=hM.CreateColorsTexture("".concat(this.name,"-colors-texture"),Q.FM,this.colorsSampling,this.HM()):this.colorsTexture=hM.PrepareEmptyColorsTexture(A),this._cameraFacing=null===(z=Q.cameraFacing)||void 0===z||z,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var pM,vM,qM;oM.ForceGLSL=!1,function(M){M[M.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",M[M.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(pM||(pM={})),function(M){M[M.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",M[M.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",M[M.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vM||(vM={})),function(M){M[M.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",M[M.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",M[M.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",M[M.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",M[M.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(qM||(qM={}));class rM extends bM.d{constructor(M,A,O){var S,z,Q,X;super(M,A,null,null,!1,!1),this.name=M,this._options=O,this._lazy=!1,this._updatable=!1,this._engine=A.getEngine(),this._lazy=null!==(S=O.lazy)&&void 0!==S&&S,this._updatable=null!==(z=O.updatable)&&void 0!==z&&z,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=null!==(Q=O.colorPointers)&&void 0!==Q?Q:[],this._widths=null!==(X=O.widths)&&void 0!==X?X:new Array(O.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(M){let A=0;for(const S of this._points)A+=S.length;const O=A/3*2-this._widths.length;for(let S=0;S<O;S++)this._widths.push(M)}updateLazy(){var M,A;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(M=this._options.ribbonOptions)||void 0===M?void 0:M.smoothShading),!this.uM&&this.refreshBoundingInfo(),null===(A=this.greasedLineMaterial)||void 0===A||A.updateLazy()}addPoints(M,A){for(const O of M)this._points.push(O);this._lazy||this.setPoints(this._points,A)}dispose(M){let A=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(M,A)}isLazy(){return this._lazy}get NM(){return this._uvs}set NM(M){this._uvs=M instanceof Float32Array?M:new Float32Array(M),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(M){this.material instanceof oM&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===M||void 0===M?void 0:M.length)>0),this._offsets=M,this._offsetsBuffer?this._offsetsBuffer.update(M):this._createOffsetsBuffer(M)}get widths(){return this._widths}set widths(M){this._widths=M,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(M)}get colorPointers(){return this._colorPointers}set colorPointers(M){this._colorPointers=M,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(M)}get greasedLineMaterial(){var M,A;if(this.material&&this.material instanceof oM)return this.material;const O=null===(M=this.material)||void 0===M||null===(A=M.pluginManager)||void 0===A?void 0:A.getPlugin(iM.GREASED_LINE_MATERIAL_NAME);return O||void 0}get points(){const M=[];return LM.c.DeepCopy(this._points,M),M}setPoints(M,A){var O;this._points=hM.ConvertPoints(M,null!==(O=null===A||void 0===A?void 0:A.pointsOptions)&&void 0!==O?O:this._options.pointsOptions),this._updateWidths(),null!==A&&void 0!==A&&A.colorPointers||this._updateColorPointers(),this._setPoints(this._points,A)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,NM:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(M){super.serialize(M),M.type=this.getClassName(),M.lineOptions=this._createLineOptions()}_createVertexBuffers(){let M=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const A=new UM.e;return A.fM=this._vertexPositions,A.indices=this._indices,A.NM=this._uvs,M&&(A.DM=[],UM.e.ComputeNormals(this._vertexPositions,this._indices,A.DM)),A.hM(this,this._options.updatable),A}_createOffsetsBuffer(M){const A=this._scene.getEngine(),O=new e.b(A,M,this._updatable,3);this.setVerticesBuffer(O.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=O}}class nM{constructor(M,A){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=M,this.wasAddedByNoopNode=A}getIndicesAccessor(M,A,O,S,z){var Q,X,c,j;return null===(Q=this._indicesAccessorMap.get(M))||void 0===Q||null===(X=Q.get(A))||void 0===X||null===(c=X.get(O))||void 0===c||null===(j=c.get(S))||void 0===j?void 0:j.get(z)}setIndicesAccessor(M,A,O,S,z,Q){let X=this._indicesAccessorMap.get(M);X||(X=new Map,this._indicesAccessorMap.set(M,X));let c=X.get(A);c||(c=new Map,X.set(A,c));let j=c.get(O);j||(j=new Map,c.set(O,j));let B=j.get(S);B||(B=new Map,j.set(S,B)),B.set(z,Q)}pushExportedNode(M){this._exportedNodes.has(M)||this._exportedNodes.add(M)}getNodesSet(){return this._exportedNodes}getVertexBufferView(M){return this._vertexBufferViewMap.get(M)}setVertexBufferView(M,A){this._vertexBufferViewMap.set(M,A)}setRemappedBufferView(M,A,O){this._remappedBufferView.set(M,new Map),this._remappedBufferView.get(M).set(A,O)}getRemappedBufferView(M,A){var O;return null===(O=this._remappedBufferView.get(M))||void 0===O?void 0:O.get(A)}getVertexAccessor(M,A,O){var S,z;return null===(S=this._vertexAccessorMap.get(M))||void 0===S||null===(z=S.get(A))||void 0===z?void 0:z.get(O)}setVertexAccessor(M,A,O,S){let z=this._vertexAccessorMap.get(M);z||(z=new Map,this._vertexAccessorMap.set(M,z));let Q=z.get(A);Q||(Q=new Map,z.set(A,Q)),Q.set(O,S)}hasVertexColorAlpha(M){return this._vertexMapColorAlpha.get(M)||!1}setHasVertexColorAlpha(M,A){return this._vertexMapColorAlpha.set(M,A)}getMesh(M){return this._meshMap.get(M)}setMesh(M,A){this._meshMap.set(M,A)}bindMorphDataToMesh(M,A){const O=this._meshMorphTargetMap.get(M)||[];this._meshMorphTargetMap.set(M,O),-1===O.indexOf(A)&&O.push(A)}getMorphTargetsFromMesh(M){return this._meshMorphTargetMap.get(M)}}class aM{_ApplyExtension(M,A,O,S){if(O>=A.length)return Promise.resolve(M);const z=S(A[O],M);return z?z.then((async M=>M?await this._ApplyExtension(M,A,O+1,S):null)):this._ApplyExtension(M,A,O+1,S)}_ApplyExtensions(M,A){const O=[];for(const S of aM._ExtensionNames)O.push(this._extensions[S]);return this._ApplyExtension(M,O,0,A)}_extensionsPreExportTextureAsync(M,A,O){return this._ApplyExtensions(A,((A,S)=>A.preExportTextureAsync&&A.preExportTextureAsync(M,S,O)))}_extensionsPostExportNodeAsync(M,A,O,S,z){return this._ApplyExtensions(A,((A,Q)=>A.postExportNodeAsync&&A.postExportNodeAsync(M,Q,O,S,z,this._bufferManager)))}_extensionsPostExportMaterialAsync(M,A,O){return this._ApplyExtensions(A,((A,S)=>A.postExportMaterialAsync&&A.postExportMaterialAsync(M,S,O)))}_extensionsPostExportMaterialAdditionalTextures(M,A,O){const S=[];for(const z of aM._ExtensionNames){const Q=this._extensions[z];Q.postExportMaterialAdditionalTextures&&S.push(...Q.postExportMaterialAdditionalTextures(M,A,O))}return S}_extensionsPostExportTextures(M,A,O){for(const S of aM._ExtensionNames){const z=this._extensions[S];z.postExportTexture&&z.postExportTexture(M,A,O)}}_extensionsPostExportMeshPrimitive(M){for(const A of aM._ExtensionNames){const O=this._extensions[A];O.postExportMeshPrimitive&&O.postExportMeshPrimitive(M,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const M of aM._ExtensionNames){const A=this._extensions[M];A.preGenerateBinaryAsync&&await A.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(M){for(const A of aM._ExtensionNames){const O=this._extensions[A];O.enabled&&M(O)}}_extensionsOnExporting(){this._forEachExtensions((M=>{var A,O,S;M.wasUsed&&((A=this._glTF).extensionsUsed||(A.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(M.name)&&this._glTF.extensionsUsed.push(M.name),M.required&&((O=this._glTF).extensionsRequired||(O.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(M.name)&&this._glTF.extensionsRequired.push(M.name)),(S=this._glTF).extensions||(S.extensions={}),M.onExporting&&M.onExporting())}))}_loadExtensions(){for(const M of aM._ExtensionNames){const A=aM._ExtensionFactories[M](this);this._extensions[M]=A}}constructor(){let M=arguments.length>0&&void 0!==arguments[0]?arguments[0]:d.d.LastCreatedScene,A=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:"Babylon.js v".concat(G.b.Version),version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new x(this),this._extensions={},this._bufferManager=new eM,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!M)throw new Error("No scene available to export");this._babylonScene=M,this._options=(0,g.d)({shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:M=>{var A;return null===M||void 0===M||null===(A=M.Xc)||void 0===A?void 0:A.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None"},A),this._loadExtensions()}dispose(){for(const M in this._extensions){this._extensions[M].dispose()}}get options(){return this._options}static RegisterExtension(M,A){aM.UnregisterExtension(M)&&z.Tools.Warn("Extension with the name ".concat(M," already exists")),aM._ExtensionFactories[M]=A,aM._ExtensionNames.push(M)}static UnregisterExtension(M){if(!aM._ExtensionFactories[M])return!1;delete aM._ExtensionFactories[M];const A=aM._ExtensionNames.indexOf(M);return-1!==A&&aM._ExtensionNames.splice(A,1),!0}_generateJSON(M,A,O){const S={byteLength:M};return S.byteLength&&(this._glTF.buffers=[S]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.wA=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(S.uri=A+".bin"),O?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(M){const A=await this._generateBinaryAsync();this._extensionsOnExporting();const O=this._generateJSON(A.byteLength,M,!0),S=new Blob([A],{type:"application/octet-stream"}),z=M+".gltf",Q=M+".bin",X=new B;if(X.files[z]=O,X.files[Q]=S,this._imageData)for(const c in this._imageData)X.files[c]=new Blob([this._imageData[c].data],{type:this._imageData[c].mimeType});return X}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(M){const A=M%4;return 0===A?A:4-A}async generateGLBAsync(M){this._shouldUseGlb=!0;const A=await this._generateBinaryAsync();this._extensionsOnExporting();const O=this._generateJSON(A.byteLength),S=M+".glb";let z,Q=O.length;if("undefined"!==typeof TextEncoder){z=(new TextEncoder).encode(O),Q=z.length}const X=this._getPadding(Q),c=this._getPadding(A.byteLength),j=28+Q+X+A.byteLength+c,g=new BM(j);if(g.writeUInt32(1179937895),g.writeUInt32(2),g.writeUInt32(j),g.writeUInt32(Q+X),g.writeUInt32(1313821514),z)g.writeTypedArray(z);else{const M="_".charCodeAt(0);for(let A=0;A<Q;++A){const S=O.charCodeAt(A);S!=O.codePointAt(A)?g.writeUInt8(M):g.writeUInt8(S)}}for(let B=0;B<X;++B)g.writeUInt8(32);g.writeUInt32(A.byteLength+c),g.writeUInt32(5130562),g.writeTypedArray(A);for(let B=0;B<c;++B)g.writeUInt8(0);const e=new B;return e.files[S]=new Blob([g.getOutputData()],{type:"application/octet-stream"}),e}_setNodeTransformation(M,A,O){if(A.getPivotPoint().equalsWithEpsilon(r,q.e)||z.Tools.Warn("Pivot points are not supported in the glTF serializer"),!A.position.equalsWithEpsilon(r,q.e)){const z=S.TmpVectors.GA[0].S(A.position);O&&W(z),M.translation=z.gc()}A.Ec.equalsWithEpsilon(a,q.e)||(M.scale=A.Ec.gc());const Q=A.rotationQuaternion||S.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);Q.equalsWithEpsilon(n,q.e)||(O&&l(Q),M.rotation=Q.normalize().gc())}_setCameraTransformation(M,A,O){if(!A.position.equalsWithEpsilon(r,q.e)){const z=S.TmpVectors.GA[0].S(A.position);O&&W(z),M.translation=z.gc()}const z=A.rotationQuaternion||S.Quaternion.FromEulerAngles(A.rotation.x,A.rotation.y,A.rotation.z);O&&l(z),this._babylonScene.useRightHandedSystem||MM(z),z.equalsWithEpsilon(n,q.e)||(M.rotation=z.gc())}_listAvailableCameras(){for(const M of this._babylonScene.cameras){const A={type:M.mode===JM.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(M.name&&(A.name=M.name),"perspective"===A.type)A.perspective={aspectRatio:M.getEngine().getAspectRatio(M),yfov:M.fovMode===JM.c.FOVMODE_VERTICAL_FIXED?M.fov:M.fov*M.getEngine().getAspectRatio(M),znear:M.Tc,zfar:M.maxZ};else if("orthographic"===A.type){const O=M.orthoLeft&&M.orthoRight?.5*(M.orthoRight-M.orthoLeft):.5*M.getEngine().getRenderWidth(),S=M.orthoBottom&&M.orthoTop?.5*(M.orthoTop-M.orthoBottom):.5*M.getEngine().getRenderHeight();A.orthographic={xmag:O,ymag:S,znear:M.Tc,zfar:M.maxZ}}this._camerasMap.set(M,A)}}_exportAndAssignCameras(){const M=Array.from(this._camerasMap.values());for(const A of M){const M=this._nodesCameraMap.get(A);if(void 0!==M){this._cameras.push(A);for(const A of M)A.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const M of this._babylonScene.skeletons){if(M.bones.length<=0)continue;const A={joints:[]};this._skinMap.set(M,A)}}_exportAndAssignSkeletons(){for(const A of this._babylonScene.skeletons){if(A.bones.length<=0)continue;const O=this._skinMap.get(A);if(void 0==O)continue;const S={},Q=[];let X=-1;for(let z=0;z<A.bones.length;++z){var M;const O=A.bones[z],Q=null!==(M=O.getIndex())&&void 0!==M?M:z;-1!==Q&&(S[Q]=O,Q>X&&(X=Q))}for(let M=0;M<=X;++M){const A=S[M];Q.push(A.getAbsoluteInverseBindMatrix());const X=A.getTransformNode();if(null!==X){const M=this._nodeMap.get(X);X&&null!==M&&void 0!==M?O.joints.push(M):z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else z.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const c=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==c){const M=64*Q.length,A=new Float32Array(M/4);Q.forEach(((M,O)=>{A.set(M.m,16*O)}));const S=this._bufferManager.createBufferView(A);this._accessors.push(this._bufferManager.createAccessor(S,"MAT4",5126,Q.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of c)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const M={nodes:[]};if(this._babylonScene.metadata){const A=this._options.metadataSelector(this._babylonScene.metadata);A&&(M.extras=A)}const A=new Array,O=new Array,S=new Array;for(const c of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&cM(c,this._babylonScene.useRightHandedSystem)?S.push(...c.getChildren()):this._babylonScene.useRightHandedSystem?A.push(c):O.push(c);this._listAvailableCameras(),this._listAvailableSkeletons();const z=new nM(!0,!1);M.nodes.push(...await this._exportNodesAsync(O,z));const Q=new nM(!1,!1);M.nodes.push(...await this._exportNodesAsync(A,Q));const X=new nM(!1,!0);M.nodes.push(...await this._exportNodesAsync(S,X)),M.nodes.length&&this._scenes.push(M),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&YM._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,z.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(M){let A=this._shouldExportNodeMap.get(M);return void 0===A&&(A=this._options.shouldExportNode(M),this._shouldExportNodeMap.set(M,A)),A}async _exportNodesAsync(M,A){const O=new Array;this._exportBuffers(M,A);for(const S of M)await this._exportNodeAsync(S,O,A);return O}_collectBuffers(M,A,O,S,z){if(this._shouldExportNode(M)&&M instanceof J.d&&M.wc){const Q=M.wc.getVertexBuffers();if(Q)for(const S in Q){if(!mM(S))continue;const X=Q[S];z.setHasVertexColorAlpha(X,M.hasVertexAlpha);const c=X._buffer,j=A.get(c)||[];A.set(c,j),-1===j.indexOf(X)&&j.push(X);const B=O.get(X)||[];O.set(X,B),-1===B.indexOf(M)&&B.push(M)}const X=M.morphTargetManager;if(X)for(let A=0;A<X.numTargets;A++){const O=X.getTarget(A),z=S.get(O)||[];S.set(O,z),-1===z.indexOf(M)&&z.push(M)}}for(const Q of M.getChildren())this._collectBuffers(Q,A,O,S,z)}_exportBuffers(M,A){const O=new Map,S=new Map,z=new Map;for(const c of M)this._collectBuffers(c,O,S,z,A);const Q=Array.from(O.keys());for(const c of Q){const M=c.getData();if(!M)throw new Error("Buffer data is not available");const z=O.get(c);if(!z)continue;const Q=z[0].byteStride;if(z.some((M=>M.byteStride!==Q)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const X=SM(M).slice();for(const A of z){const M=S.get(A),{byteOffset:O,byteStride:z,componentCount:Q,type:c,count:j,normalized:B,kind:g}=Z(A,M);switch(g){case e.c.NormalKind:case e.c.TangentKind:(0,o.g)(X,O,z,Q,c,j,B,(M=>{const A=Math.sqrt(M[0]*M[0]+M[1]*M[1]+M[2]*M[2]);if(A>0){const O=1/A;M[0]*=O,M[1]*=O,M[2]*=O}}));break;case e.c.ColorKind:{const A=M.filter((M=>M.material instanceof dM.IA||null==M.material)).length;if(0==A)break;if(A!=M.length){p.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}c==e.c.UNSIGNED_BYTE&&p.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const S=new w.bA,g=new w.Cc,T=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.g)(X,O,z,Q,c,j,B,(M=>{3===M.length?(S.GO(M,0),S.toLinearSpaceToRef(S,T),S.toArray(M,0)):(g.GO(M,0),g.toLinearSpaceToRef(g,T),g.toArray(M,0))}))}}}if(A.convertToRightHanded){for(const M of z){const A=S.get(M),{byteOffset:O,byteStride:z,componentCount:Q,type:c,count:j,normalized:B,kind:g}=Z(M,A);switch(g){case e.c.PositionKind:case e.c.NormalKind:case e.c.TangentKind:(0,o.g)(X,O,z,Q,c,j,B,(M=>{M[0]=-M[0]}))}}A.convertedToRightHandedBuffers.set(c,X)}const j=this._bufferManager.createBufferView(X,Q);A.setVertexBufferView(c,j);const B=new Map;for(const A of z){const M=S.get(A),{kind:O,totalVertices:z}=Z(A,M);switch(O){case e.c.MatricesIndicesKind:case e.c.MatricesIndicesExtraKind:if(A.type==e.c.FLOAT){const M=A.getFloatData(z);null!==M&&B.set(A,M)}}}0!==B.size&&p.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const g=Array.from(B.keys());for(const O of g){const M=B.get(O);if(!M)continue;const S=M.some((M=>M>=256)),z=new(S?Uint16Array:Uint8Array)(M.length);for(let A=0;A<M.length;A++)z[A]=M[A];const Q=this._bufferManager.createBufferView(z,4*(S?2:1));A.setRemappedBufferView(c,O,Q)}}const X=Array.from(z.keys());for(const c of X){const M=z.get(c);if(!M)continue;const O=EM(c,M[0],this._bufferManager,this._bufferViews,this._accessors,A.convertToRightHanded);for(const S of M)A.bindMorphDataToMesh(S,O)}}async _exportNodeAsync(M,A,O){let S=this._nodeMap.get(M);if(void 0!==S)return void(A.includes(S)||A.push(S));const z=await this._createNodeAsync(M,O);if(z){S=this._nodes.length,this._nodes.push(z),this._nodeMap.set(M,S),O.pushExportedNode(M),A.push(S);const Q={name:"runtime animations",channels:[],samplers:[]},X=[];this._babylonScene.animationGroups.length||(YM._CreateMorphTargetAnimationFromMorphTargetAnimations(M,Q,X,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,O.convertToRightHanded,this._options.shouldExportAnimation),M.animations.length&&YM._CreateNodeAnimationFromNodeAnimations(M,Q,X,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,O.convertToRightHanded,this._options.shouldExportAnimation)),Q.channels.length&&Q.samplers.length&&this._animations.push(Q),X.forEach((M=>{M.channels.length&&M.samplers.length&&this._animations.push(M)}))}const Q=z?[]:A;for(const X of M.getChildren())await this._exportNodeAsync(X,Q,O);z&&Q.length&&(z.children=Q)}async _createNodeAsync(M,A){if(!this._shouldExportNode(M))return null;const O={};if(M.name&&(O.name=M.name),M.metadata){const A=this._options.metadataSelector(M.metadata);A&&(O.extras=A)}if(M instanceof T.e&&(this._setNodeTransformation(O,M,A.convertToRightHanded),M instanceof J.d)){const z=M instanceof K.e?M.sourceMesh:M;if(z.Bc&&z.Bc.length>0&&(O.mesh=await this._exportMeshAsync(z,A)),M.skeleton){const A=this._skinMap.get(M.skeleton);var S;if(void 0!==A)void 0===this._nodesSkinMap.get(A)&&this._nodesSkinMap.set(A,[]),null===(S=this._nodesSkinMap.get(A))||void 0===S||S.push(O)}}if(M instanceof v.b){const S=this._camerasMap.get(M);if(S){var z;void 0===this._nodesCameraMap.get(S)&&this._nodesCameraMap.set(S,[]),this._setCameraTransformation(O,M,A.convertToRightHanded);const X=M.parent;if(null!==X&&OM(M,X)){const M=this._nodeMap.get(X);if(void 0!==M){var Q;const A=this._nodes[M];return AM(O,A),null===(Q=this._nodesCameraMap.get(S))||void 0===Q||Q.push(A),null}}null===(z=this._nodesCameraMap.get(S))||void 0===z||z.push(O)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",O,M,this._nodeMap,A.convertToRightHanded)?O:(p.c.Warn("Not exporting node ".concat(M.name)),null)}_exportIndices(M,A,O,S,z,X,c,j,B){let g=M;B.mode=R(X);const e=c!==Q.b.CounterClockWiseSideOrientation,T=!j.wasAddedByNoopNode&&e,J=function(M){switch(M){case Q.b.TriangleFillMode:case Q.b.TriangleStripDrawMode:case Q.b.TriangleFanDrawMode:return!0}return!1}(X)&&T;if(J){if(X===Q.b.TriangleStripDrawMode||X===Q.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");B.mode=R(X);const c=A?new Uint32Array(S):new Uint16Array(S);if(M)for(let A=0;A+2<S;A+=3)c[A]=M[O+A]+z,c[A+1]=M[O+A+2]+z,c[A+2]=M[O+A+1]+z;else for(let M=0;M+2<S;M+=3)c[M]=M,c[M+1]=M+2,c[M+2]=M+1;g=c}else if(M&&0!==z){const Q=A?new Uint32Array(S):new Uint16Array(S);for(let A=0;A<S;A++)Q[A]=M[O+A]+z;g=Q}if(g){let Q=j.getIndicesAccessor(M,O,S,z,J);if(void 0===Q){const X=function(M,A,O,S){if(M instanceof Uint16Array||M instanceof Uint32Array)return M;if(M instanceof Int32Array)return new Uint32Array(M.buffer,M.byteOffset,M.length);const z=M.slice(A,A+O);return S?new Uint32Array(z):new Uint16Array(z)}(g,0,S,A),c=this._bufferManager.createBufferView(X),B=A?5125:5123;this._accessors.push(this._bufferManager.createAccessor(c,"SCALAR",B,S,0)),Q=this._accessors.length-1,j.setIndicesAccessor(M,O,S,z,J,Q)}B.indices=Q}}_exportVertexBuffer(M,A,O,S,z,Q){const X=M.getKind();if(!mM(X))return;if(X.startsWith("uv")&&!this._options.exportUnusedUVs&&(!A||!this._materialNeedsUVsSet.has(A)))return;let c=z.getVertexAccessor(M,O,S);if(void 0===c){const A=z.convertedToRightHandedBuffers.get(M._buffer)||M._buffer.getData(),Q=X===e.c.PositionKind?function(M,A,O,S){const{byteOffset:z,byteStride:Q,type:X,normalized:c}=A,j=A.getSize(),B=new Array(j).fill(1/0),g=new Array(j).fill(-1/0);return(0,o.g)(M,z+O*Q,Q,j,X,S*j,c,(M=>{for(let A=0;A<j;A++)B[A]=Math.min(B[A],M[A]),g[A]=Math.max(g[A],M[A])})),{min:B,max:g}}(A,M,O,S):void 0,j=(X===e.c.MatricesIndicesKind||X===e.c.MatricesIndicesExtraKind)&&M.type===e.c.FLOAT,B=j?e.c.UNSIGNED_BYTE:M.type,g=j?void 0:M.normalized,T=j?z.getRemappedBufferView(M._buffer,M):z.getVertexBufferView(M._buffer),J=M.byteOffset+O*M.byteStride;this._accessors.push(this._bufferManager.createAccessor(T,function(M,A){if(M==e.c.ColorKind)return A?"VEC4":"VEC3";switch(M){case e.c.PositionKind:case e.c.NormalKind:return"VEC3";case e.c.TangentKind:case e.c.MatricesIndicesKind:case e.c.MatricesIndicesExtraKind:case e.c.MatricesWeightsKind:case e.c.MatricesWeightsExtraKind:return"VEC4";case e.c.UVKind:case e.c.UV2Kind:case e.c.UV3Kind:case e.c.UV4Kind:case e.c.UV5Kind:case e.c.UV6Kind:return"VEC2"}throw new Error("Unknown kind ".concat(M))}(X,z.hasVertexColorAlpha(M)),B,S,J,Q,g)),c=this._accessors.length-1,z.setVertexAccessor(M,O,S,c)}Q.attributes[function(M){switch(M){case e.c.PositionKind:return"POSITION";case e.c.NormalKind:return"NORMAL";case e.c.TangentKind:return"TANGENT";case e.c.ColorKind:return"COLOR_0";case e.c.UVKind:return"TEXCOORD_0";case e.c.UV2Kind:return"TEXCOORD_1";case e.c.UV3Kind:return"TEXCOORD_2";case e.c.UV4Kind:return"TEXCOORD_3";case e.c.UV5Kind:return"TEXCOORD_4";case e.c.UV6Kind:return"TEXCOORD_5";case e.c.MatricesIndicesKind:return"JOINTS_0";case e.c.MatricesIndicesExtraKind:return"JOINTS_1";case e.c.MatricesWeightsKind:return"WEIGHTS_0";case e.c.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error("Unknown kind: ".concat(M))}(X)]=c}async _exportMaterialAsync(M,A,O,S){let z=this._materialMap.get(M);if(void 0===z){const S=A&&Object.keys(A).some((M=>M.startsWith("uv")));if((M=M instanceof KM.b?M.fc[O.materialIndex]:M)instanceof GM.e)z=await this._materialExporter.exportPBRMaterialAsync(M,"image/png",S);else{if(!(M instanceof dM.IA))return void p.c.Warn("Unsupported material '".concat(M.name,"' with type ").concat(M.getClassName()));z=await this._materialExporter.exportStandardMaterialAsync(M,"image/png",S)}this._materialMap.set(M,z)}S.material=z}async _exportMeshAsync(M,A){var O;let S=A.getMesh(M);if(void 0!==S)return S;const z={primitives:[]};S=this._meshes.length,this._meshes.push(z),A.setMesh(M,S);const X=M.isUnIndexed?null:M.Ic(),c=null===(O=M.wc)||void 0===O?void 0:O.getVertexBuffers(),j=A.getMorphTargetsFromMesh(M),B=M instanceof HM.d,g=M instanceof rM,e=M.Bc;if(c&&e&&e.length>0)for(const I of e){var T;const O={attributes:{}},S=I.tM()||this._babylonScene.defaultMaterial;if(g){var J,K,G,d;const A={name:S.name},z=M,Q=w.bA.White(),X=null!==(J=null===(K=z.material)||void 0===K?void 0:K.alpha)&&void 0!==J?J:1,c=null!==(G=null===(d=z.greasedLineMaterial)||void 0===d?void 0:d.color)&&void 0!==G?G:Q;(!c.equalsWithEpsilon(Q,q.e)||X<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...c.gc(),X]}),this._materials.push(A),O.material=this._materials.length-1}else if(B){const A={name:S.name},z=M;(!z.color.equalsWithEpsilon(w.bA.White(),q.e)||z.alpha<1)&&(A.pbrMetallicRoughness={baseColorFactor:[...z.color.gc(),z.alpha]}),this._materials.push(A),O.material=this._materials.length-1}else await this._exportMaterialAsync(S,c,I,O);const e=B||g?Q.b.LineListDrawMode:null!==(T=M.overrideRenderingFillMode)&&void 0!==T?T:S.fillMode,b=S._getEffectiveOrientation(M);this._exportIndices(X,X?(0,o.b)(X,I.indexCount,I.indexStart,I.verticesStart):I.verticesCount>65535,X?I.indexStart:I.verticesStart,X?I.indexCount:I.verticesCount,-I.verticesStart,e,b,A,O);for(const M of Object.values(c))this._exportVertexBuffer(M,S,I.verticesStart,I.verticesCount,A,O);if(j){O.targets=[];for(const M of j)O.targets.push(M.attributes)}z.primitives.push(O),this._extensionsPostExportMeshPrimitive(O)}if(j){z.weights=[],z.extras||(z.extras={}),z.extras.targetNames=[];for(const M of j)z.weights.push(M.influence),z.extras.targetNames.push(M.name)}return S}}aM._ExtensionNames=new Array,aM._ExtensionFactories={};class VM{static async GLTFAsync(M,A,O){O&&O.exportWithoutWaitingForScene||await M.whenReadyAsync();const S=new aM(M,O),z=await S.generateGLTFAsync(A.replace(/\.[^/.]+$/,""));return S.dispose(),z}static async GLBAsync(M,A,O){O&&O.exportWithoutWaitingForScene||await M.whenReadyAsync();const S=new aM(M,O),z=await S.generateGLBAsync(A.replace(/\.[^/.]+$/,""));return S.dispose(),z}}O(13537);const ZM="EXT_mesh_gpu_instancing";class PM{constructor(M){this.name=ZM,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(M,A,O,z,Q,X){return await new Promise((M=>{if(A&&O instanceof bM.d&&O.hasThinInstances&&this._exporter){this._wasUsed=!0;const M=S.GA.Zero(),z=S.Quaternion.Identity(),c=S.GA.One(),j=O.thinInstanceGetWorldMatrices(),B=S.TmpVectors.GA[2],g=S.TmpVectors.Quaternion[1],e=S.TmpVectors.GA[3];let T=!1,J=!1,K=!1;const G=new Float32Array(3*O.Dc),d=new Float32Array(4*O.Dc),w=new Float32Array(3*O.Dc);let I=0;for(const A of j)A.decompose(e,g,B),Q&&(W(B),l(g)),G.set(B.gc(),3*I),d.set(g.normalize().gc(),4*I),w.set(e.gc(),3*I),T=T||!B.equalsWithEpsilon(M),J=J||!g.equalsWithEpsilon(z),K=K||!e.equalsWithEpsilon(c),I++;const b={attributes:{}};T&&(b.attributes.TRANSLATION=this._buildAccessor(G,"VEC3",O.Dc,X)),J&&(b.attributes.ROTATION=this._buildAccessor(d,"VEC4",O.Dc,X)),K&&(b.attributes.SCALE=this._buildAccessor(w,"VEC3",O.Dc,X)),A.extensions=A.extensions||{},A.extensions[ZM]=b}M(A)}))}_buildAccessor(M,A,O,S){const z=S.createBufferView(M),Q=S.createAccessor(z,A,5126,O);return this._exporter._accessors.push(Q),this._exporter._accessors.length-1}}aM.RegisterExtension(ZM,(M=>new PM(M)));var mA=O(13539),RM=O(13552),kM=O(13559),WM=O(13563);function lM(M){return M===kM.b.PositionKind?"POSITION":M===kM.b.NormalKind?"NORMAL":M===kM.b.ColorKind?"COLOR":M.startsWith(kM.b.UVKind)?"TEX_COORD":"GENERIC"}const MA={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class AA extends mA.b{static get DefaultAvailable(){return(0,mA.h)(AA.DefaultConfiguration)}static get Default(){var M;return null!==(M=AA._Default)&&void 0!==M||(AA._Default=new AA),AA._Default}static ResetDefault(M){AA._Default&&(M||AA._Default.dispose(),AA._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(M,A){return{module:await(A||DracoEncoderModule)({wasmBinary:M})}}_getWorkerContent(){return"".concat(RM.i,"(").concat(RM.k,")()")}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:AA.DefaultConfiguration)}async _encodeAsync(M,A,O){const S=O?(0,WM.d)(MA,O):MA;if(this._workerPoolPromise){const O=await this._workerPoolPromise;return await new Promise(((z,Q)=>{O.push(((O,X)=>{const c=M=>{O.removeEventListener("error",c),O.removeEventListener("message",j),Q(M),X()},j=M=>{"encodeMeshDone"===M.data.id&&(O.removeEventListener("error",c),O.removeEventListener("message",j),z(M.data.encodedMeshData),X())};O.addEventListener("error",c),O.addEventListener("message",j);const B=[];for(const A of M)B.push(A.data.buffer);A&&B.push(A.buffer),O.postMessage({id:"encodeMesh",attributes:M,indices:A,options:S},B)}))}))}if(this._modulePromise){const O=await this._modulePromise;return(0,RM.i)(O.module,M,A,S)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(M,A){if(0==M.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");M instanceof bM.d&&M.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===A||void 0===A?void 0:A.method)&&(p.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),A.method="MESH_SEQUENTIAL_ENCODING");const O=function(M){let A=M.Ic(void 0,!0);return!A||A instanceof Uint32Array||A instanceof Uint16Array||(A=((0,o.b)(A,A.length)?Uint32Array:Uint16Array).from(A)),A}(M),S=function(M,A){const O=[];for(const S of M.getVerticesDataKinds()){if(null!==A&&void 0!==A&&A.includes(S)){if(S===kM.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const z=M.getVertexBuffer(S),Q=z.getSize(),X=(0,o.t)(z.getData(),Q,z.type,z.byteOffset,z.byteStride,z.normalized,M.getTotalVertices(),!0);O.push({kind:S,dracoName:lM(S),size:Q,data:X})}return O}(M,null===A||void 0===A?void 0:A.excludedAttributes);return await this._encodeAsync(S,O,A)}}AA.DefaultConfiguration={wasmUrl:"".concat(z.Tools._DefaultCdnUrl,"/draco_encoder_wasm_wrapper.js"),wasmBinaryUrl:"".concat(z.Tools._DefaultCdnUrl,"/draco_encoder.wasm"),fallbackUrl:"".concat(z.Tools._DefaultCdnUrl,"/draco_encoder.js")},AA._Default=null;const OA="KHR_draco_mesh_compression";class SA{get wasUsed(){return this._wasUsed}constructor(M){this.name=OA,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===M.options.meshCompressionMethod&&AA.DefaultAvailable}dispose(){}postExportMeshPrimitive(M,A,O){if(!this.enabled)return;if(4!==M.mode&&5!==M.mode)return void p.c.Warn("Cannot compress primitive with mode "+M.mode+".");const S=[],z=[];let Q=null;if(void 0!==M.indices){const X=O[M.indices],c=A.getBufferView(X);Q=A.getData(c).slice(),S.push(c),z.push(X)}const X=[];for(const[g,e]of Object.entries(M.attributes)){const M=O[e],Q=A.getBufferView(M),j=P(M.type),B=(0,o.t)(A.getData(Q),j,M.componentType,M.byteOffset||0,Q.byteStride||(0,o.o)(M.componentType)*j,M.normalized||!1,M.count,!0);X.push({kind:g,dracoName:(c=g,"POSITION"===c?"POSITION":"NORMAL"===c?"NORMAL":c.startsWith("COLOR")?"COLOR":c.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:P(M.type),data:B}),S.push(Q),z.push(M)}var c;const j={method:M.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},B=AA.Default._encodeAsync(X,Q,j).then((O=>{if(!O)return void p.c.Error("Draco encoding failed for primitive.");const Q={bufferView:-1,attributes:O.attributeIds},X=A.createBufferView(O.data);A.setBufferView(Q,X);for(const M of S)this._bufferViewsUsed.add(M);for(const M of z)this._accessorsUsed.add(M);M.extensions||(M.extensions={}),M.extensions[OA]=Q})).catch((M=>{p.c.Error("Draco encoding failed for primitive: "+M)}));this._encodePromises.push(B),this._wasUsed=!0}async preGenerateBinaryAsync(M){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((A=>{M.getPropertiesWithBufferView(A).every((M=>this._accessorsUsed.has(M)))&&M.removeBufferView(A)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}aM.RegisterExtension(OA,(M=>new SA(M)));var zA=O(13568);const QA="KHR_lights_punctual",XA={name:"",color:[1,1,1],Fc:1,range:Number.MAX_VALUE},cA={innerConeAngle:0,outerConeAngle:Math.PI/4},jA=S.GA.Backward();class BA{constructor(M){this.name=QA,this.enabled=!0,this.required=!1,this._exporter=M}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[QA]=this._lights}async postExportNodeAsync(M,A,O,z,Q){return await new Promise((X=>{if(!(O instanceof sM.d))return void X(A);const c=O.getTypeID()==sM.d.LIGHTTYPEID_POINTLIGHT?"point":O.getTypeID()==sM.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":O.getTypeID()==sM.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!c||!(O instanceof zA.b))return p.c.Warn("".concat(M,": Light ").concat(O.name," is not supported in ").concat(QA)),void X(A);if(O.falloffType!==sM.d.FALLOFF_GLTF&&p.c.Warn("".concat(M,": Light falloff for ").concat(O.name," does not match the ").concat(QA," specification!")),!O.position.equalsToFloats(0,0,0)){const M=S.TmpVectors.GA[0].S(O.position);Q&&W(M),A.translation=M.gc()}if("point"!==c){const M=O.direction.normalizeToRef(S.TmpVectors.GA[0]);Q&&W(M);const z=S.Quaternion.FromUnitVectorsToRef(jA,M,S.TmpVectors.Quaternion[0]);S.Quaternion.IsIdentity(z)||(A.rotation=z.gc())}const j={type:c,name:O.name,color:O.Nc.gc(),Fc:O.Fc,range:O.range};if(zM(j,XA),"spot"===c){const M=O;j.spot={innerConeAngle:M.innerAngle/2,outerConeAngle:M.angle/2},zM(j.spot,cA)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(j);const B={nz:this._lights.lights.length-1},g=O.parent;if(g&&OM(O,g)){const M=z.get(g);if(M){const O=this._exporter._nodes[M];return AM(A,O),O.extensions||(O.extensions={}),O.extensions[QA]=B,void X(null)}}A.extensions||(A.extensions={}),A.extensions[QA]=B,X(A)}))}}aM.RegisterExtension(QA,(M=>new BA(M)));var gA=O(13485);const eA="KHR_materials_anisotropy";class TA{constructor(M){this.name=eA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof gA.e&&O.anisotropy.isEnabled&&!O.anisotropy.legacy?(O.anisotropy.texture&&S.push(O.anisotropy.texture),S):[]}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof gA.e){if(!O.anisotropy.isEnabled||O.anisotropy.legacy)return void M(A);this._wasUsed=!0,A.extensions=A.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(O.anisotropy.texture),z={anisotropyStrength:O.anisotropy.Fc,anisotropyRotation:O.anisotropy.angle,anisotropyTexture:null!==S&&void 0!==S?S:void 0};null!==z.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(O),A.extensions[eA]=z}M(A)}))}}aM.RegisterExtension(eA,(M=>new TA(M)));const JA="KHR_materials_clearcoat";class KA{constructor(M){this.name=JA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof gA.e&&O.clearCoat.isEnabled?(O.clearCoat.texture&&S.push(O.clearCoat.texture),!O.clearCoat.useRoughnessFromMainTexture&&O.clearCoat.textureRoughness&&S.push(O.clearCoat.textureRoughness),O.clearCoat.bumpTexture&&S.push(O.clearCoat.bumpTexture),S):[]}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof gA.e){var S;if(!O.clearCoat.isEnabled)return void M(A);this._wasUsed=!0,A.extensions=A.extensions||{};const Q=this._exporter._materialExporter.getTextureInfo(O.clearCoat.texture);let X;X=O.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(O.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(O.clearCoat.textureRoughness),O.clearCoat.isTintEnabled&&z.Tools.Warn("Clear Color tint is not supported for glTF export. Ignoring for: ".concat(O.name)),O.clearCoat.remapF0OnInterfaceChange&&z.Tools.Warn("Clear Color F0 remapping is not supported for glTF export. Ignoring for: ".concat(O.name));const c=this._exporter._materialExporter.getTextureInfo(O.clearCoat.bumpTexture),j={clearcoatFactor:O.clearCoat.Fc,clearcoatTexture:null!==Q&&void 0!==Q?Q:void 0,clearcoatRoughnessFactor:O.clearCoat.roughness,clearcoatRoughnessTexture:null!==(S=X)&&void 0!==S?S:void 0,clearcoatNormalTexture:null!==c&&void 0!==c?c:void 0};null===j.clearcoatTexture&&null===j.clearcoatRoughnessTexture&&null===j.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(O),A.extensions[JA]=j}M(A)}))}}aM.RegisterExtension(JA,(M=>new KA(M)));const GA="KHR_materials_diffuse_transmission";function dA(M,A){const O=A.subSurface;let S=null;return O.translucencyIntensityTexture?S=O.translucencyIntensityTexture:O.thicknessTexture&&O.useMaskFromThicknessTexture&&(S=O.thicknessTexture),S&&!O.useGltfStyleTextures?(p.c.Warn("".concat(M,": Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ").concat(A.name),1),null):S}class wA{constructor(M){this.name=GA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];if(O instanceof GM.e&&this._isExtensionEnabled(O)){const A=dA(M,O);return A&&S.push(A),O.subSurface.translucencyColorTexture&&S.push(O.subSurface.translucencyColorTexture),S}return S}_isExtensionEnabled(M){if(M.unlit)return!1;const A=M.subSurface;return!!A.isTranslucencyEnabled&&(!M.unlit&&!A.useAlbedoToTintTranslucency&&A.useGltfStyleTextures&&1===A.volumeIndexOfRefraction&&0===A.minimumThickness&&0===A.maximumThickness)}postExportMaterialAsync(M,A,O){return new Promise((S=>{if(O instanceof GM.e&&this._isExtensionEnabled(O)){var z,Q;this._wasUsed=!0;const S=O.subSurface,X=dA(M,O),c=0==S.translucencyIntensity?void 0:S.translucencyIntensity,j=null!==(z=this._exporter._materialExporter.getTextureInfo(X))&&void 0!==z?z:void 0,B=!S.translucencyColor||S.translucencyColor.equalsFloats(1,1,1)?void 0:S.translucencyColor.gc(),g=null!==(Q=this._exporter._materialExporter.getTextureInfo(S.translucencyColorTexture))&&void 0!==Q?Q:void 0,e={diffuseTransmissionFactor:c,diffuseTransmissionTexture:j,diffuseTransmissionColorFactor:B,diffuseTransmissionColorTexture:g};(j||g)&&this._exporter._materialNeedsUVsSet.add(O),A.extensions=A.extensions||{},A.extensions[GA]=e}S(A)}))}}aM.RegisterExtension(GA,(M=>new wA(M)));const IA="KHR_materials_dispersion";class bA{constructor(){this.name=IA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){if(M.unlit)return!1;const A=M.subSurface;return!(!A.isRefractionEnabled&&!A.isDispersionEnabled)}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof GM.e&&this._isExtensionEnabled(O)){this._wasUsed=!0;const M={dispersion:O.subSurface.dispersion};A.extensions=A.extensions||{},A.extensions[IA]=M}M(A)}))}}aM.RegisterExtension(IA,(()=>new bA));const sA="KHR_materials_emissive_strength";class YA{constructor(){this.name=sA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(M,A,O){return await new Promise((M=>{if(!(O instanceof GM.e))return M(A);const S=O.emissiveColor.gc(),z=Math.max(...S);if(z>1){this._wasUsed=!0,A.extensions||(A.extensions={});const M={emissiveStrength:z},S=O.emissiveColor.scale(1/M.emissiveStrength);A.emissiveFactor=S.gc(),A.extensions[sA]=M}return M(A)}))}}aM.RegisterExtension(sA,(M=>new YA));const EA="KHR_materials_ior";class HA{constructor(){this.name=EA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.indexOfRefraction&&1.5!=M.indexOfRefraction)}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof GM.e&&this._isExtensionEnabled(O)){this._wasUsed=!0;const M={ior:O.indexOfRefraction};A.extensions=A.extensions||{},A.extensions[EA]=M}M(A)}))}}aM.RegisterExtension(EA,(M=>new HA));const CA="KHR_materials_iridescence";class fA{constructor(M){this.name=CA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof gA.e&&O.iridescence.isEnabled?(O.iridescence.texture&&S.push(O.iridescence.texture),O.iridescence.thicknessTexture&&O.iridescence.thicknessTexture!==O.iridescence.texture&&S.push(O.iridescence.thicknessTexture),S):[]}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof gA.e){if(!O.iridescence.isEnabled)return void M(A);this._wasUsed=!0,A.extensions=A.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(O.iridescence.texture),z=this._exporter._materialExporter.getTextureInfo(O.iridescence.thicknessTexture),Q={iridescenceFactor:O.iridescence.Fc,iridescenceIor:O.iridescence.indexOfRefraction,iridescenceThicknessMinimum:O.iridescence.minimumThickness,iridescenceThicknessMaximum:O.iridescence.maximumThickness,iridescenceTexture:null!==S&&void 0!==S?S:void 0,iridescenceThicknessTexture:null!==z&&void 0!==z?z:void 0};null===Q.iridescenceTexture&&null===Q.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(O),A.extensions[CA]=Q}M(A)}))}}aM.RegisterExtension(CA,(M=>new fA(M)));const DA="KHR_materials_sheen";class FA{constructor(M){this.name=DA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){return O instanceof GM.e&&O.sheen.isEnabled&&O.sheen.texture?[O.sheen.texture]:[]}async postExportMaterialAsync(M,A,O){return await new Promise((M=>{if(O instanceof GM.e){var S;if(!O.sheen.isEnabled)return void M(A);this._wasUsed=!0,null==A.extensions&&(A.extensions={});const c={sheenColorFactor:O.sheen.color.gc(),sheenRoughnessFactor:null!==(S=O.sheen.roughness)&&void 0!==S?S:0};var z,Q;if(null===c.sheenColorTexture&&null===c.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(O),O.sheen.texture)c.sheenColorTexture=null!==(z=this._exporter._materialExporter.getTextureInfo(O.sheen.texture))&&void 0!==z?z:void 0;if(O.sheen.textureRoughness&&!O.sheen.useRoughnessFromMainTexture)c.sheenRoughnessTexture=null!==(Q=this._exporter._materialExporter.getTextureInfo(O.sheen.textureRoughness))&&void 0!==Q?Q:void 0;else if(O.sheen.texture&&O.sheen.useRoughnessFromMainTexture){var X;c.sheenRoughnessTexture=null!==(X=this._exporter._materialExporter.getTextureInfo(O.sheen.texture))&&void 0!==X?X:void 0}A.extensions[DA]=c}M(A)}))}}aM.RegisterExtension(DA,(M=>new FA(M)));const NA="KHR_materials_specular";class yA{constructor(M){this.name=NA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof GM.e&&this._isExtensionEnabled(O)?(O.metallicReflectanceTexture&&S.push(O.metallicReflectanceTexture),O.reflectanceTexture&&S.push(O.reflectanceTexture),S):S}_isExtensionEnabled(M){return!M.unlit&&(void 0!=M.metallicF0Factor&&1!=M.metallicF0Factor||void 0!=M.metallicReflectanceColor&&!M.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.metallicReflectanceTexture||null!=M.reflectanceTexture}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof GM.e&&this._isExtensionEnabled(O)){var S,z;this._wasUsed=!0,A.extensions=A.extensions||{};const M=null!==(S=this._exporter._materialExporter.getTextureInfo(O.metallicReflectanceTexture))&&void 0!==S?S:void 0,Q=null!==(z=this._exporter._materialExporter.getTextureInfo(O.reflectanceTexture))&&void 0!==z?z:void 0,X={specularFactor:1==O.metallicF0Factor?void 0:O.metallicF0Factor,specularTexture:M,specularColorFactor:O.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:O.metallicReflectanceColor.gc(),specularColorTexture:Q};this._hasTexturesExtension(O)&&this._exporter._materialNeedsUVsSet.add(O),A.extensions[NA]=X}M(A)}))}}aM.RegisterExtension(NA,(M=>new yA(M)));const hA="KHR_materials_transmission";class uA{constructor(M){this.name=hA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof GM.e&&this._isExtensionEnabled(O)?(O.subSurface.thicknessTexture&&S.push(O.subSurface.thicknessTexture),S):S}_isExtensionEnabled(M){if(M.unlit)return!1;const A=M.subSurface;return A.isRefractionEnabled&&void 0!=A.refractionIntensity&&0!=A.refractionIntensity||this._hasTexturesExtension(M)}_hasTexturesExtension(M){return null!=M.subSurface.refractionIntensityTexture}async postExportMaterialAsync(M,A,O){if(O instanceof GM.e&&this._isExtensionEnabled(O)){this._wasUsed=!0;const S=O.subSurface,z={transmissionFactor:0===S.refractionIntensity?void 0:S.refractionIntensity};if(this._hasTexturesExtension(O)&&this._exporter._materialNeedsUVsSet.add(O),S.refractionIntensityTexture)if(S.useGltfStyleTextures){const M=await this._exporter._materialExporter.exportTextureAsync(S.refractionIntensityTexture,"image/png");M&&(z.transmissionTexture=M)}else p.c.Warn("".concat(M,": Exporting a subsurface refraction intensity texture without `useGltfStyleTextures` is not supported"));A.extensions||(A.extensions={}),A.extensions[hA]=z}return A}}aM.RegisterExtension(hA,(M=>new uA(M)));const iA="KHR_materials_unlit";class UA{constructor(){this.name=iA,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(M,A,O){return new Promise((M=>{let S=!1;O instanceof GM.e?S=O.unlit:O instanceof dM.IA&&(S=O.disableLighting),S&&(this._wasUsed=!0,null==A.extensions&&(A.extensions={}),A.extensions[iA]={}),M(A)}))}}aM.RegisterExtension(iA,(()=>new UA));const LA="KHR_materials_volume";class tA{constructor(M){this.name=LA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof GM.e&&this._isExtensionEnabled(O)?(O.subSurface.thicknessTexture&&S.push(O.subSurface.thicknessTexture),S):S}_isExtensionEnabled(M){if(M.unlit)return!1;const A=M.subSurface;return!(!A.isRefractionEnabled&&!A.isTranslucencyEnabled)&&(void 0!=A.maximumThickness&&0!=A.maximumThickness||void 0!=A.tintColorAtDistance&&A.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=A.tintColor&&A.tintColor!=w.bA.White()||this._hasTexturesExtension(M))}_hasTexturesExtension(M){return null!=M.subSurface.thicknessTexture}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof GM.e&&this._isExtensionEnabled(O)){var S;this._wasUsed=!0;const M=O.subSurface,z={thicknessFactor:0==M.maximumThickness?void 0:M.maximumThickness,thicknessTexture:null!==(S=this._exporter._materialExporter.getTextureInfo(M.thicknessTexture))&&void 0!==S?S:void 0,attenuationDistance:M.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:M.tintColorAtDistance,attenuationColor:M.tintColor.equalsFloats(1,1,1)?void 0:M.tintColor.gc()};this._hasTexturesExtension(O)&&this._exporter._materialNeedsUVsSet.add(O),A.extensions=A.extensions||{},A.extensions[LA]=z}M(A)}))}}aM.RegisterExtension(LA,(M=>new tA(M)));const xA="EXT_materials_diffuse_roughness";class oA{constructor(M){this.name=xA,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=M}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(M,A,O){const S=[];return O instanceof gA.e&&O._baseDiffuseRoughness?(O._baseDiffuseRoughnessTexture&&S.push(O._baseDiffuseRoughnessTexture),S):[]}postExportMaterialAsync(M,A,O){return new Promise((M=>{if(O instanceof gA.e){if(!O._baseDiffuseRoughness)return void M(A);this._wasUsed=!0,A.extensions=A.extensions||{};const S=this._exporter._materialExporter.getTextureInfo(O._baseDiffuseRoughnessTexture),z={diffuseRoughnessFactor:O._baseDiffuseRoughness,diffuseRoughnessTexture:null!==S&&void 0!==S?S:void 0};null!==z.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(O),A.extensions[xA]=z}M(A)}))}}aM.RegisterExtension(xA,(M=>new oA(M)));const pA="KHR_texture_transform";class vA{constructor(){this.name=pA,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(M,A,O){if(O.HM()||z.Tools.Warn("".concat(M,': "scene" is not defined for Babylon texture ').concat(O.name,"!")),(0!==O.uAng||0!==O.vAng)&&(z.Tools.Warn("".concat(M,": Texture ").concat(O.name," with rotation in the u or v axis is not supported in glTF.")),0!==O.uRotationCenter||0!==O.vRotationCenter))return;const S={};let Q=!1;if(0===O.uOffset&&0===O.vOffset||(S.offset=[O.uOffset,O.vOffset],Q=!0),1===O.uScale&&1===O.vScale||(S.scale=[O.uScale,O.vScale],Q=!0),0!==O.wAng){if(0!==O.uRotationCenter||0!==O.vRotationCenter){if(O.homogeneousRotationInUVTransform&&O.uScale!==O.vScale)return void z.Tools.Warn("".concat(M,": Texture ").concat(O.name," with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ").concat(pA,"."));z.Tools.Warn("".concat(M,": Texture ").concat(O.name," with non-origin rotation center will be exported using an adjusted offset with ").concat(pA,".")),S.offset=function(M){const{uOffset:A,vOffset:O,uRotationCenter:S,vRotationCenter:z,uScale:Q,vScale:X,wAng:c}=M,j=Math.cos(c),B=Math.sin(c),g=S*Q,e=z*X;return[A+(g*(1-j)+e*B),O+(e*(1-j)-g*B)]}(O)}S.rotation=-O.wAng,Q=!0}0!==O.coordinatesIndex&&(S.texCoord=O.coordinatesIndex,Q=!0),Q&&(this._wasUsed=!0,A.extensions||(A.extensions={}),A.extensions[pA]=S)}}aM.RegisterExtension(pA,(()=>new vA));class qA{static CreateSTL(M){let A=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",z=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],X=arguments.length>5&&void 0!==arguments[5]&&arguments[5],c=arguments.length>6&&void 0!==arguments[6]&&arguments[6],j=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const B=function(M,A,O){const z=[3*M[O],3*M[O+1],3*M[O+2]],Q=[new S.GA(A[z[0]],A[z[0]+2],A[z[0]+1]),new S.GA(A[z[1]],A[z[1]+2],A[z[1]+1]),new S.GA(A[z[2]],A[z[2]+2],A[z[2]+1])],X=Q[0].dA(Q[1]),c=Q[2].dA(Q[1]);return{v:Q,n:S.GA.Cross(c,X).normalize()}},g=function(M,A,O,S){return A=T(M,A,O.x,S),A=T(M,A,O.y,S),T(M,A,O.z,S)},T=function(M,A,O,S){return M.setFloat32(A,O,S),A+4},J=function(M){if(c){let A=M;M instanceof K.e&&(A=M.sourceMesh);const O=A.getVerticesData(e.c.PositionKind,!0,!0);if(!O)return[];const z=S.GA.Zero();let Q;for(Q=0;Q<O.length;Q+=3)S.GA.TransformCoordinatesFromFloatsToRef(O[Q],O[Q+1],O[Q+2],M.Gc(!0),z).toArray(O,Q);return O}return M.getVerticesData(e.c.PositionKind)||[]};c&&(X=!0);let G="",d=0,w=0;if(z){for(let O=0;O<M.length;O++){const A=M[O].Ic();d+=A?A.length/3:0}const A=new ArrayBuffer(84+50*d);G=new DataView(A),w+=80,G.setUint32(w,d,Q),w+=4}else j||(G="solid stlmesh\r\n");for(let S=0;S<M.length;S++){const A=M[S];!z&&j&&(G+="solid "+A.name+"\r\n"),!X&&A instanceof bM.d&&A.bakeCurrentTransformIntoVertices();const O=J(A),c=A.Ic()||[];for(let M=0;M<c.length;M+=3){const A=B(c,O,M);z?(w=g(G,w,A.n,Q),w=g(G,w,A.v[0],Q),w=g(G,w,A.v[1],Q),w=g(G,w,A.v[2],Q),w+=2):(G+="\tfacet normal "+A.n.x+" "+A.n.y+" "+A.n.z+"\r\n",G+="\t\touter loop\r\n",G+="\t\t\tvertex "+A.v[0].x+" "+A.v[0].y+" "+A.v[0].z+"\r\n",G+="\t\t\tvertex "+A.v[1].x+" "+A.v[1].y+" "+A.v[1].z+"\r\n",G+="\t\t\tvertex "+A.v[2].x+" "+A.v[2].y+" "+A.v[2].z+"\r\n",G+="\t\tendloop\r\n",G+="\tendfacet\r\n")}!z&&j&&(G+="endsolid "+name+"\r\n")}if(z||j||(G+="endsolid stlmesh"),A){const M=document.createElement("a"),A=new Blob([G],{type:"application/octet-stream"});M.href=window.URL.createObjectURL(A),M.download=O+".stl",M.click()}return G}}function rA(M,A){let O=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const S=[];for(let z=0;z<M.length/O;z++){const Q=M[z*O],X=M[z*O+1],c=M[z*O+2];S.push("(".concat(Q.toPrecision(A.precision),", ").concat(X.toPrecision(A.precision),", ").concat(c.toPrecision(A.precision),")"))}return S.join(", ")}function nA(M,A){const O=[];for(let S=0;S<M.length/2;S++){const z=M[2*S],Q=M[2*S+1];O.push("(".concat(z.toPrecision(A.precision),", ").concat((1-Q).toPrecision(A.precision),")"))}return O.join(", ")}function aA(M,A){const O=M.getVerticesData(e.c.PositionKind),S=M.getVerticesData(e.c.NormalKind);if(O&&S)return'\n\tdef Mesh "'.concat("Geometry",'"\n\t{\n\t\tint[] faceVertexCounts = [').concat(function(M){var A;const O=null!==(A=M.Ic())&&void 0!==A&&A.length?M.getTotalIndices():M.getTotalVertices();return Array(O/3).fill(3).join(", ")}(M),"]\n\t\tint[] faceVertexIndices = [").concat(function(M){const A=M.Ic(),O=[];if(null!==A)for(let S=0;S<A.length;S++)O.push(A[S]);else{const A=M.getTotalVertices();for(let M=0;M<A;M++)O.push(M)}return O.join(", ")}(M),"]\n\t\tnormal3f[] normals = [").concat(rA(S,A),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [').concat(rA(O,A),"]\n        ").concat(function(M,A){let O="";for(let z=0;z<4;z++){const S=z>0?z:"",Q=M.getVerticesData(e.c.UVKind+(S?S+1:""));Q&&(O+="\n\t\ttexCoord2f[] primvars:st".concat(S," = [").concat(nA(Q,A),'] (\n\t\t\tinterpolation = "vertex"\n\t\t)'))}const S=M.getVerticesData(e.c.ColorKind);return S&&(O+="\n\tcolor3f[] primvars:displayColor = [".concat(rA(S,A,S.length/M.getTotalVertices()),'] (\n\t\tinterpolation = "vertex"\n\t\t)')),O}(M,A),'\n\t\tuniform token subdivisionScheme = "none"\n\t}\n')}function VA(M,A){const O=aA(M,A);return'\n        def "Geometry"\n        {\n        '.concat(O,"\n        }\n        ")}function ZA(M){let A='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return A+=M,fflate.strToU8(A)}function PA(M){const A=M.m;return"( ".concat(mO(A,0),", ").concat(mO(A,4),", ").concat(mO(A,8),", ").concat(mO(A,12)," )")}function mO(M,A){return"(".concat(M[A+0],", ").concat(M[A+1],", ").concat(M[A+2],", ").concat(M[A+3],")")}function RA(M){const A="Object_"+M.uniqueId,O=function(M){const A=M.getWorldMatrix().clone(),O=M.HM().useRightHandedSystem;if(!O){let S=M.parent;for(;S;){if(cM(S,O)){A.multiplyToRef(S.getWorldMatrix().invert(),A);break}S=S.parent}}return A.determinant()<0&&z.Tools.Warn("Exporting mesh ".concat(M.name," with negative scale. Result may look incorrect in destination engine.")),A}(M),S=PA(O);return'def Xform "'.concat(A,'" (\n\tprepend references = @./geometries/Geometry_').concat(M.wc.uniqueId,'.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ').concat(S,'\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_').concat(M.material.uniqueId,">\n}\n\n")}function kA(M){switch(M){case C.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case C.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case C.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function WA(M){return"(".concat(M.x,", ").concat(M.y,")")}function lA(M){return"(".concat(M.r,", ").concat(M.g,", ").concat(M.b,")")}function MO(M,A,O,z,Q,X){const c=M.getInternalTexture().uniqueId+"_"+M.invertY;Q[c]=M;const j=M.coordinatesIndex>0?"st"+M.coordinatesIndex:"st",B=new S.Vector2(M.uScale,M.vScale),g=new S.Vector2(M.uOffset,M.vOffset),e=M.wAng,T=Math.sin(e),J=Math.cos(e);return g.y=1-g.y-B.y,g.x+=T*B.x,g.y+=(1-J)*B.y,'\n    def Shader "PrimvarReader_'.concat(O,'"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "').concat(j,'"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_').concat(O,'"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_').concat(A.uniqueId,"/PrimvarReader_").concat(O,".outputs:result>\n        float inputs:rotation = ").concat((e*(180/Math.PI)).toFixed(X.precision),"\n        float2 inputs:scale = ").concat(WA(B),"\n        float2 inputs:translation = ").concat(WA(g),'\n        float2 outputs:result\n    }\n\n    def Shader "Texture_').concat(M.uniqueId,"_").concat(O,'"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_').concat(c,".png@\n        float2 inputs:st.connect = </Materials/Material_").concat(A.uniqueId,"/Transform2d_").concat(O,".outputs:result>\n        ").concat(z?"float4 inputs:scale = "+function(M){return"(".concat(M.r,", ").concat(M.g,", ").concat(M.b,", 1.0)")}(z):"",'\n        token inputs:sourceColorSpace = "').concat(M.gammaSpace?"raw":"sRGB",'"\n        token inputs:wrapS = "').concat(kA(M.wrapU),'"\n        token inputs:wrapT = "').concat(kA(M.wrapV),'"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ').concat(A.needAlphaBlending()?"float outputs:a":"","\n    }")}function AO(M,A,O){const S="\t\t\t",z=[],Q=[],{diffuseMap:X,Nc:c,alphaCutOff:j,emissiveMap:B,emissive:e,normalMap:T,roughnessMap:J,roughnessChannel:K,roughness:G,metalnessMap:d,metalnessChannel:I,metalness:b,aoMap:s,aoMapChannel:Y,aoMapIntensity:E,alphaMap:H,ior:C,clearCoatEnabled:f,clearCoat:D,clearCoatMap:F,clearCoatRoughness:N,clearCoatRoughnessMap:y}=function(M){const A={diffuseMap:null,Nc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return M instanceof dM.IA?(0,g.d)((0,g.d)({},A),{},{diffuseMap:M.diffuseTexture,Nc:M.diffuseColor,alphaCutOff:M.alphaCutOff,emissiveMap:M.emissiveTexture,emissive:M.emissiveColor,roughness:1,alphaMap:M.opacityTexture}):M instanceof gA.e?(0,g.d)((0,g.d)({},A),{},{diffuseMap:M._albedoTexture,Nc:M._albedoColor,alphaCutOff:M._alphaCutOff,emissiveMap:M._emissiveTexture,emissive:M._emissiveColor,normalMap:M._bumpTexture,roughnessMap:M._metallicTexture,roughnessChannel:M._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:null!==(O=M._roughness)&&void 0!==O?O:1,metalnessMap:M._metallicTexture,metalnessChannel:M._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:null!==(S=M._metallic)&&void 0!==S?S:0,aoMap:M._ambientTexture,aoMapChannel:M._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:M._ambientTextureStrength,alphaMap:M._opacityTexture,ior:M.subSurface.indexOfRefraction,clearCoatEnabled:M.clearCoat.isEnabled,clearCoat:M.clearCoat.Fc,clearCoatMap:M.clearCoat.texture,clearCoatRoughness:M.clearCoat.roughness,clearCoatRoughnessMap:M.clearCoat.useRoughnessFromMainTexture?M.clearCoat.texture:M.clearCoat.textureRoughness}):A;var O,S}(M);return null!==X?(z.push("".concat(S,"color3f inputs:diffuseColor.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(X.uniqueId,"_diffuse.outputs:rgb>")),M.needAlphaBlending()?z.push("".concat(S,"float inputs:opacity.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(X.uniqueId,"_diffuse.outputs:a>")):M.needAlphaTesting()&&(z.push("".concat(S,"float inputs:opacity.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(X.uniqueId,"_diffuse.outputs:a>")),z.push("".concat(S,"float inputs:opacityThreshold = ").concat(j))),Q.push(MO(X,M,"diffuse",c,A,O))):z.push("".concat(S,"color3f inputs:diffuseColor = ").concat(lA(c||w.bA.White()))),null!==B?(z.push("".concat(S,"color3f inputs:emissiveColor.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(B.uniqueId,"_emissive.outputs:rgb>")),Q.push(MO(B,M,"emissive",e,A,O))):e&&e.toLuminance()>0&&z.push("".concat(S,"color3f inputs:emissiveColor = ").concat(lA(e))),null!==T&&(z.push("".concat(S,"normal3f inputs:normal.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(T.uniqueId,"_normal.outputs:rgb>")),Q.push(MO(T,M,"normal",null,A,O))),null!==s&&(z.push("".concat(S,"float inputs:occlusion.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(s.uniqueId,"_occlusion.outputs:").concat(Y,">")),Q.push(MO(s,M,"occlusion",new w.bA(E,E,E),A,O))),null!==J?(z.push("".concat(S,"float inputs:roughness.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(J.uniqueId,"_roughness.outputs:").concat(K,">")),Q.push(MO(J,M,"roughness",new w.bA(G,G,G),A,O))):z.push("".concat(S,"float inputs:roughness = ").concat(G)),null!==d?(z.push("".concat(S,"float inputs:metallic.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(d.uniqueId,"_metallic.outputs:").concat(I,">")),Q.push(MO(d,M,"metallic",new w.bA(b,b,b),A,O))):z.push("".concat(S,"float inputs:metallic = ").concat(b)),null!==H?(z.push("".concat(S,"float inputs:opacity.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(H.uniqueId,"_opacity.outputs:r>")),z.push("".concat(S,"float inputs:opacityThreshold = 0.0001")),Q.push(MO(H,M,"opacity",null,A,O))):z.push("".concat(S,"float inputs:opacity = ").concat(M.alpha)),f&&(null!==F?(z.push("".concat(S,"float inputs:clearcoat.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(F.uniqueId,"_clearcoat.outputs:r>")),Q.push(MO(F,M,"clearcoat",new w.bA(D,D,D),A,O))):z.push("".concat(S,"float inputs:clearcoat = ").concat(D)),null!==y?(z.push("".concat(S,"float inputs:clearcoatRoughness.connect = </Materials/Material_").concat(M.uniqueId,"/Texture_").concat(y.uniqueId,"_clearcoatRoughness.outputs:g>")),Q.push(MO(y,M,"clearcoatRoughness",new w.bA(N,N,N),A,O))):z.push("".concat(S,"float inputs:clearcoatRoughness = ").concat(N))),z.push("".concat(S,"float inputs:ior = ").concat(C)),'\n\tdef Material "Material_'.concat(M.uniqueId,'"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n').concat(z.join("\n"),"\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_").concat(M.uniqueId,"/PreviewSurface.outputs:surface>\n\n").concat(Q.join("\n"),"\n\n\t}\n")}async function OO(M,A,O){const Q=(0,g.d)({fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35},A);"undefined"===typeof fflate&&await z.Tools.LoadScriptAsync(Q.fflateUrl);const X={};X[Q.modelFileName]=null;let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';c+=function(M){const A=!0===M.includeAnchoringProperties?'\n\t\ttoken preliminary:anchoring:type = "'.concat(M.anchoringType,'"\n\t\ttoken preliminary:planeAnchoring:alignment = "').concat(M.planeAnchoringAlignment,'"'):"";return'def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {'.concat(A,"\n            ")}(Q);const j={};for(const S of M.meshes){if(0===S.getTotalVertices())continue;const M=S,A=M.wc,B=M.material;if(!B||!A||O&&!O(M))continue;if(-1!==["IA","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(B.getClassName())){const O="geometries/Geometry_"+A.uniqueId+".usda";if(!(O in X)){const M=VA(A,Q);X[O]=ZA(M)}B.uniqueId in j||(j[B.uniqueId]=B),c+=RA(M)}else z.Tools.Warn("USDZExportAsync does not support this material type: "+B.getClassName())}M.activeCamera&&Q.exportCamera&&(c+=function(M,A){const O="Camera_"+M.uniqueId,z=PA(S.Matrix.RotationY(Math.PI).multiply(M.getWorldMatrix()));if(M.mode===C.d.ORTHOGRAPHIC_CAMERA)return'def Camera "'.concat(O,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(z,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(M.Tc.toPrecision(A.precision),", ").concat(M.maxZ.toPrecision(A.precision),")\n\t\t\tfloat horizontalAperture = ").concat((10*(Math.abs(M.orthoLeft||1)+Math.abs(M.orthoRight||1))).toPrecision(A.precision),"\n\t\t\tfloat verticalAperture = ").concat((10*(Math.abs(M.orthoTop||1)+Math.abs(M.orthoBottom||1))).toPrecision(A.precision),'\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t');{const S=M.getEngine().getAspectRatio(M),Q=A.cameraSensorWidth||35;return'def Camera "'.concat(O,'"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ').concat(z,'\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (').concat(M.Tc.toPrecision(A.precision),", ").concat(M.maxZ.toPrecision(A.precision),")\n\t\t\tfloat focalLength = ").concat((Q/(2*Math.tan(.5*M.fov))).toPrecision(A.precision),'\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ').concat((Q*S).toPrecision(A.precision),"\n\t\t\tfloat verticalAperture = ").concat((Q/S).toPrecision(A.precision),"            \n\t\t}\n\t\n\t")}}(M.activeCamera,Q)),c+="\n            }\n        }\n    }";const B={};c+=function(M,A,O){const S=[];for(const z in M){const Q=M[z];S.push(AO(Q,A,O))}return'\n    def "Materials"\n{\n'.concat(S.join(""),"\n}\n\n")}(j,B,Q),X[Q.modelFileName]=fflate.strToU8(c);for(const S in B){const M=B[S],A=M.getSize(),O=await M.readPixels();if(!O)throw new Error("Texture data is not available");const z=await f.DumpTools.DumpDataAsync(A.width,A.height,O,"image/png",void 0,!1,!0);X["textures/Texture_".concat(S,".png")]=new Uint8Array(z).slice()}let e=0;for(const S in X){const M=X[S];if(!M)continue;e+=34+S.length;const A=63&e;if(4!==A){const O=new Uint8Array(64-A);X[S]=[M,{extra:{12345:O}}]}e=M.length}return fflate.zipSync(X,{level:0})}}}]);