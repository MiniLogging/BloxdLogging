"use strict";(self["1xyrlsr8vb9"]=self["1xyrlsr8vb9"]||[]).push([[26],{12640:(I,O,C)=>{C.r(O),C.d(O,{EXT_materials_diffuse_roughness:()=>tO,EXT_mesh_gpu_instancing:()=>AI,GLTF2Export:()=>zI,GLTFData:()=>p,KHR_draco_mesh_compression:()=>CO,KHR_lights_punctual:()=>UO,KHR_materials_anisotropy:()=>QO,KHR_materials_clearcoat:()=>ZO,KHR_materials_diffuse_transmission:()=>EO,KHR_materials_dispersion:()=>rO,KHR_materials_emissive_strength:()=>YO,KHR_materials_ior:()=>cO,KHR_materials_iridescence:()=>XO,KHR_materials_sheen:()=>HO,KHR_materials_specular:()=>aO,KHR_materials_transmission:()=>uO,KHR_materials_unlit:()=>fO,KHR_materials_volume:()=>xO,KHR_texture_transform:()=>wO,OBJExport:()=>y,STLExport:()=>gO,USDZExportAsync:()=>OC,_ConvertToGLTFPBRMetallicRoughness:()=>J,_SolveMetallic:()=>u,__IGLTFExporterExtension:()=>S});var j=C(12272),K=C(12083),i=C(12568);class y{static OBJ(I,O,C,y){const S=[];let U=1,p=1;O&&(C||(C="mat"),S.push("mtllib "+C+".mtl"));for(let N=0;N<I.length;N++){const C=I[N],Q=C.name||`mesh${N}}`;S.push(`o ${Q}`);let s=null;if(y){const I=C.rS(!0);s=new j.Matrix,I.invertToRef(s),C.bakeTransformIntoVertices(I)}if(O){const I=C.material;I&&S.push("usemtl "+I.id)}const Z=C.WS;if(!Z){K.Tools.Warn("No geometry is present on the mesh");continue}const q=Z.getVerticesData("position"),mI=Z.getVerticesData("normal"),E=Z.getVerticesData("uv"),h=Z.YS();let r=0,W=0;if(!q||!h){K.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const Y=I[0].nI().useRightHandedSystem?1:-1;for(let I=0;I<q.length;I+=3)S.push("v "+q[I]*Y+" "+q[I+1]+" "+q[I+2]),r++;if(null!=mI)for(let I=0;I<mI.length;I+=3)S.push("vn "+mI[I]*Y+" "+mI[I+1]+" "+mI[I+2]);if(null!=E)for(let I=0;I<E.length;I+=2)S.push("vt "+E[I]+" "+E[I+1]),W++;const o=["","",""],c=(C.material||C.nI().defaultMaterial)._getEffectiveOrientation(C),[n,X]=c===i.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let I=0;I<h.length;I+=3){const O=[String(h[I]+U),String(h[I+n]+U),String(h[I+X]+U)],C=[String(h[I]+p),String(h[I+n]+p),String(h[I+X]+p)],j=O,K=null!=E?C:o,i=null!=mI?O:o;S.push("f "+j[0]+"/"+K[0]+"/"+i[0]+" "+j[1]+"/"+K[1]+"/"+i[1]+" "+j[2]+"/"+K[2]+"/"+i[2])}y&&s&&C.bakeTransformIntoVertices(s),U+=r,p+=W}return S.join("\n")}static MTL(I){const O=[],C=I.material;O.push("newmtl mat1"),O.push("  Ns "+C.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+C.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),O.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),O.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),O.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&O.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&O.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&O.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&O.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&O.push("  map_d "+C.opacityTexture.name);return O.join("\n")}}var S=0,U=C(12139);class p{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const I in this.files){const O=this.files[I],C=new Blob([O],{type:(0,U.i)(I)});K.Tools.Download(C,I)}}}var N=C(12329),Q=C(12645),s=C(12660),Z=C(12669),q=C(12396),mI=C(12132),E=C(12307),h=C(12282);const r=h.HighestCommonFactor,W={...h,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:r};var Y=C(12476),o=C(12245),c=C(12703),n=C(12708),X=C(12468);const T=1e-6,H=new E.WO(.04,.04,.04),b=1024,a=E.WO.White(),M=E.WO.Black();function u(I,O,C){if(O<H.r)return 0;const j=H.r,K=I*C/(1-H.r)+O-2*H.r,i=K*K-4*j*(H.r-O);return W.Clamp((-K+Math.sqrt(i))/(2*j),0,1)}function J(I){const O=I.diffuseColor.toLinearSpace(I.nI().getEngine().useExactSrgbConversions).scale(.5),C=I.alpha,K=function(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new j.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new j.Vector2(0,.1),K=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new j.Vector2(0,.1),i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new j.Vector2(1300,.1);return function(I,O,C,j,K){return(1-I)*(1-I)*(1-I)*O+3*(1-I)*(1-I)*I*C+3*(1-I)*I*I*j+I*I*I*K}(Math.pow(I/i.x,.333333),O.y,C.y,K.y,i.y)}(W.Clamp(I.specularPower,0,b));return{baseColorFactor:[O.r,O.g,O.b,C],metallicFactor:0,roughnessFactor:K}}function f(I,O){O.needAlphaBlending()?I.alphaMode="BLEND":O.needAlphaTesting()&&(I.alphaMode="MASK",I.alphaCutoff=O.alphaCutOff)}function l(I,O,C){const j=new Uint8Array(I*O*4);for(let K=0;K<j.length;K+=4)j[K]=j[K+1]=j[K+2]=j[K+3]=255;return c.d.CreateRGBATexture(j,I,O,C)}function x(I){if(I instanceof Uint8Array){const O=I.length,C=new Float32Array(I.length);for(let j=0;j<O;++j)C[j]=I[j]/255;return C}if(I instanceof Float32Array)return I;throw new Error("Unsupported pixel format!")}class D{constructor(I){this._exporter=I,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(I){return I?this._textureMap.get(I)??null:null}async exportStandardMaterialAsync(I,O,C){const j=J(I),i={name:I.name};if(null==I.oS||I.oS||(I.twoSidedLighting||K.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),C){const C=[],K=I.diffuseTexture;K&&C.push(this.exportTextureAsync(K,O).then((I=>{I&&(j.baseColorTexture=I)})));const y=I.bumpTexture;y&&C.push(this.exportTextureAsync(y,O).then((I=>{I&&(i.normalTexture=I,1!==y.level&&(i.normalTexture.scale=y.level))})));const S=I.emissiveTexture;S&&(i.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(S,O).then((I=>{I&&(i.emissiveTexture=I)}))));const U=I.ambientTexture;U&&C.push(this.exportTextureAsync(U,O).then((I=>{if(I){const O={index:I.index};i.occlusionTexture=O}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(C))}(I.alpha<1||I.opacityTexture)&&(I.alphaMode===n.e.ALPHA_COMBINE?i.alphaMode="BLEND":K.Tools.Warn(I.name+": glTF 2.0 does not support alpha mode: "+I.alphaMode.toString())),I.emissiveColor&&!I.emissiveColor.equalsWithEpsilon(M,T)&&(i.emissiveFactor=I.emissiveColor.qS()),i.pbrMetallicRoughness=j,f(i,I),await this._finishMaterialAsync(i,I,O);const y=this._exporter._materials;return y.push(i),y.length-1}async _finishMaterialAsync(I,O,C){const j=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",I,O),K=[];for(const i of j)K.push(this.exportTextureAsync(i,C));await Promise.all(K),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",I,O)}async _getImageDataAsync(I,O,j,K){const i=n.e.TEXTURETYPE_UNSIGNED_BYTE,y=this._exporter._babylonScene,S=y.getEngine(),U=S.createRawTexture(I,O,j,n.e.TEXTUREFORMAT_RGBA,!1,!0,o.e.NEAREST_SAMPLINGMODE,null,i);S.isWebGPU?await C.e(51).then(C.bind(C,14660)):await C.e(52).then(C.bind(C,14669)),await Y.k.ApplyPostProcess("pass",U,y,i,n.e.TEXTURE_NEAREST_SAMPLINGMODE,n.e.TEXTUREFORMAT_RGBA);const p=await S._readTexturePixels(U,O,j);return await X.DumpTools.DumpDataAsync(O,j,p,K,void 0,!0,!0)}_resizeTexturesToSameDimensions(I,O,C){const j=I?I.getSize():{width:0,height:0},K=O?O.getSize():{width:0,height:0};let i,y;return j.width<K.width?(i=I&&I instanceof o.e?Y.k.CreateResizedCopy(I,K.width,K.height,!0):l(K.width,K.height,C),y=O):j.width>K.width?(y=O&&O instanceof o.e?Y.k.CreateResizedCopy(O,j.width,j.height,!0):l(j.width,j.height,C),i=I):(i=I,y=O),{texture1:i,texture2:y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(I,O,C,j){const K=new Array;if(!I&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const i=I?I.nI():O?O.nI():null;if(i){var y;const S=this._resizeTexturesToSameDimensions(I,O,i),U=null===(y=S.texture1)||void 0===y?void 0:y.getSize();let p,N;const Q=U.width,s=U.height,Z=await S.texture1.readPixels(),q=await S.texture2.readPixels();if(!Z)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(p=x(Z),!q)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");N=x(q);const mI=N.byteLength,h=new Uint8Array(mI),r=new Uint8Array(mI),W=4,Y=M;let o=0,c=0;for(let I=0;I<s;++I)for(let O=0;O<Q;++O){const j=(Q*I+O)*W,K={diffuseColor:new E.WO(p[j],p[j+1],p[j+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new E.WO(N[j],N[j+1],N[j+2]).toLinearSpace(i.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:N[j+3]*C.glossiness},y=this._convertSpecularGlossinessToMetallicRoughness(K);Y.r=Math.max(Y.r,y.baseColor.r),Y.g=Math.max(Y.g,y.baseColor.g),Y.b=Math.max(Y.b,y.baseColor.b),o=Math.max(o,y.metallic),c=Math.max(c,y.roughness),r[j]=255*y.baseColor.r,r[j+1]=255*y.baseColor.g,r[j+2]=255*y.baseColor.b,r[j+3]=S.texture1.mU?255*p[j+3]:255,h[j]=0,h[j+1]=255*y.roughness,h[j+2]=255*y.metallic,h[j+3]=255}const n={baseColor:Y,metallic:o,roughness:c};let X=!1,H=!1;for(let I=0;I<s;++I)for(let O=0;O<Q;++O){const C=(Q*I+O)*W;r[C]/=n.baseColor.r>T?n.baseColor.r:1,r[C+1]/=n.baseColor.g>T?n.baseColor.g:1,r[C+2]/=n.baseColor.b>T?n.baseColor.b:1;const j=E.WO.FromInts(r[C],r[C+1],r[C+2]).toGammaSpace(i.getEngine().useExactSrgbConversions);r[C]=255*j.r,r[C+1]=255*j.g,r[C+2]=255*j.b,j.equalsWithEpsilon(a,T)||(H=!0),h[C+1]/=n.roughness>T?n.roughness:1,h[C+2]/=n.metallic>T?n.metallic:1;E.WO.FromInts(255,h[C+1],h[C+2]).equalsWithEpsilon(a,T)||(X=!0)}return X&&K.push(this._getImageDataAsync(h,Q,s,j).then((I=>{n.metallicRoughnessTextureData=I}))),H&&K.push(this._getImageDataAsync(r,Q,s,j).then((I=>{n.baseColorTextureData=I}))),await Promise.all(K).then((()=>n))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(I){const O=this._getPerceivedBrightness(I.diffuseColor),C=this._getPerceivedBrightness(I.specularColor),j=1-this._getMaxComponent(I.specularColor),K=u(O,C,j),i=I.diffuseColor.scale(j/(1-H.r)/Math.max(1-K)),y=I.specularColor.EO(H.scale(1-K)).scale(1/Math.max(K));let S=E.WO.Lerp(i,y,K*K);S=S.clampToRef(0,1,S);return{baseColor:S,metallic:K,roughness:1-I.glossiness}}_getPerceivedBrightness(I){return I?Math.sqrt(.299*I.r*I.r+.587*I.g*I.g+.114*I.b*I.b):0}_getMaxComponent(I){return I?Math.max(I.r,Math.max(I.g,I.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(I,O,C,j){const K=[],i={baseColor:I._albedoColor,metallic:I._metallic,roughness:I._roughness};if(j){I._albedoTexture&&K.push(this.exportTextureAsync(I._albedoTexture,O).then((I=>{I&&(C.baseColorTexture=I)})));const j=I._metallicTexture;j&&K.push(this.exportTextureAsync(j,O).then((I=>{I&&(C.metallicRoughnessTexture=I)})))}return K.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(K)),i}_getTextureSampler(I){const O={};if(!I||!(I instanceof o.e))return O;const C=this._getGLTFTextureWrapMode(I.wrapU);10497!==C&&(O.wrapS=C);const j=this._getGLTFTextureWrapMode(I.wrapV);switch(10497!==j&&(O.wrapT=j),I.samplingMode){case o.e.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case o.e.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case o.e.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case o.e.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case o.e.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case o.e.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case o.e.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case o.e.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case o.e.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case o.e.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case o.e.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case o.e.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(I){switch(I){case o.e.WRAP_ADDRESSMODE:return 10497;case o.e.CLAMP_ADDRESSMODE:return 33071;case o.e.MIRROR_ADDRESSMODE:return 33648;default:return K.Tools.Error(`Unsupported Texture Wrap Mode ${I}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(I,O,C,j){const K={diffuseColor:I._albedoColor,specularColor:I._reflectivityColor,glossiness:I._microSurface},i=I._albedoTexture,y=I._reflectivityTexture,S=I._useMicroSurfaceFromReflectivityMapAlpha;if(y&&!S)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((i||y)&&j){this._exporter._materialNeedsUVsSet.add(I);const j=this._exportTextureSampler(i||y),S=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(i,y,K,O),U=this._exporter._textures;if(S.baseColorTextureData){const I=this._exportImage(`baseColor${U.length}`,O,S.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(I,j,null===i||void 0===i?void 0:i.coordinatesIndex)}if(S.metallicRoughnessTextureData){const I=this._exportImage(`metallicRoughness${U.length}`,O,S.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(I,j,null===y||void 0===y?void 0:y.coordinatesIndex)}return S}return this._convertSpecularGlossinessToMetallicRoughness(K)}async exportPBRMaterialAsync(I,O,C){const j={},K={name:I.name},i=I.isMetallicWorkflow();if(i){const O=I._albedoColor,C=I.alpha;O&&(j.baseColorFactor=[O.r,O.g,O.b,C])}const y=i?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(I,O,j,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(I,O,j,C);await this._setMetallicRoughnessPbrMaterialAsync(y,I,K,j,O,C),await this._finishMaterialAsync(K,I,O);const S=this._exporter._materials;return S.push(K),S.length-1}async _setMetallicRoughnessPbrMaterialAsync(I,O,C,j,i,y){if(f(C,O),I.baseColor.equalsWithEpsilon(a,T)&&W.WithinEpsilon(O.alpha,1,T)||(j.baseColorFactor=[I.baseColor.r,I.baseColor.g,I.baseColor.b,O.alpha]),null!=I.metallic&&1!==I.metallic&&(j.metallicFactor=I.metallic),null!=I.roughness&&1!==I.roughness&&(j.roughnessFactor=I.roughness),null==O.oS||O.oS||(O._twoSidedLighting||K.Tools.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),y){const I=[],j=O._bumpTexture;j&&I.push(this.exportTextureAsync(j,i).then((I=>{I&&(C.normalTexture=I,1!==j.level&&(C.normalTexture.scale=j.level))})));const K=O._ambientTexture;K&&I.push(this.exportTextureAsync(K,i).then((I=>{if(I){const j={index:I.index,texCoord:I.texCoord,extensions:I.extensions};C.occlusionTexture=j;const K=O._ambientTextureStrength;K&&(j.strength=K)}})));const y=O._emissiveTexture;y&&I.push(this.exportTextureAsync(y,i).then((I=>{I&&(C.emissiveTexture=I)}))),I.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(I))}const S=O._emissiveColor;S.equalsWithEpsilon(M,T)||(C.emissiveFactor=S.qS()),C.pbrMetallicRoughness=j}_getPixelsFromTextureAsync(I){return function(I){switch(I){case n.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case n.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case n.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case n.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case n.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case n.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case n.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case n.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case n.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case n.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case n.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case n.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case n.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(I.textureFormat)?(0,Y.i)(I,I._texture.width,I._texture.height):(I.textureType,n.e.TEXTURETYPE_UNSIGNED_BYTE,I.readPixels())}async exportTextureAsync(I,O){const C=this._exporter._extensionsPreExportTextureAsync("exporter",I,O);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,O):await this._exportTextureInfoAsync(I,O))):await this._exportTextureInfoAsync(I,O)}async _exportTextureInfoAsync(I,O){let C=this._textureMap.get(I);if(!C){const j=await this._getPixelsFromTextureAsync(I);if(!j)return null;const i=this._exportTextureSampler(I),y=I.mimeType;if(y)switch(y){case"image/jpeg":case"image/png":case"image/webp":O=y;break;default:K.Tools.Warn(`Unsupported media type: ${y}. Exporting texture as PNG.`)}const S=this._internalTextureToImage,U=I.getInternalTexture().uniqueId;S[U]||(S[U]={});let p=S[U][O];if(void 0===p){const C=I.getSize();p=(async()=>{const K=await this._getImageDataAsync(j,C.width,C.height,O);return this._exportImage(I.name,O,K)})(),S[U][O]=p}C=this._exportTextureInfo(await p,i,I.coordinatesIndex),this._textureMap.set(I,C),this._exporter._extensionsPostExportTextures("exporter",C,I)}return C}_exportImage(I,O,C){const j=this._exporter._images;let i;if(this._exporter._shouldUseGlb){i={name:I,mimeType:O,bufferView:void 0};const j=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(i,j)}else{const y=I.replace(/\.\/|\/|\.\\|\\/g,"_"),S=function(I){switch(I){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let U=y+S;j.some((I=>I.uri===U))&&(U=`${y}_${K.Tools.RandomId()}${S}`),i={name:I,uri:U},this._exporter._imageData[U]={data:C,mimeType:O}}return j.push(i),j.length-1}_exportTextureInfo(I,O,C){const j=this._exporter._textures;let K=j.findIndex((C=>C.sampler==O&&C.source===I));-1===K&&(K=j.length,j.push({source:I,sampler:O}));const i={index:K};return C&&(i.texCoord=C),i}_exportTextureSampler(I){const O=this._getTextureSampler(I),C=this._exporter._samplers,j=C.findIndex((I=>I.minFilter===O.minFilter&&I.magFilter===O.magFilter&&I.wrapS===O.wrapS&&I.wrapT===O.wrapT));return-1!==j?j:(C.push(O),C.length-1)}}var t=C(12340),d=C(12103),w=C(12712),g=C(12274);const V=j.mC.Zero(),e=j.Quaternion.Identity(),L=j.mC.One(),z=new j.mC(-1,1,1);function k(I,O){const{byteOffset:C,byteStride:j,type:K,normalized:i}=I,y=I.getSize(),S=O.reduce(((I,O)=>O.getTotalVertices()>I?O.getTotalVertices():I),-Number.MAX_VALUE);return{byteOffset:C,byteStride:j,componentCount:y,type:K,count:S*y,normalized:i,totalVertices:S,kind:I.getKind()}}function A(I){switch(I){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function P(I){switch(I){case N.e.PositionKind:case N.e.NormalKind:case N.e.TangentKind:case N.e.ColorKind:case N.e.MatricesIndicesKind:case N.e.MatricesIndicesExtraKind:case N.e.MatricesWeightsKind:case N.e.MatricesWeightsExtraKind:case N.e.UVKind:case N.e.UV2Kind:case N.e.UV3Kind:case N.e.UV4Kind:case N.e.UV5Kind:case N.e.UV6Kind:return!0}return!1}function v(I){switch(I){case i.e.TriangleFillMode:return 4;case i.e.TriangleStripDrawMode:return 5;case i.e.TriangleFanDrawMode:return 6;case i.e.PointListDrawMode:case i.e.PointFillMode:return 0;case i.e.LineLoopDrawMode:return 2;case i.e.LineListDrawMode:return 1;case i.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${I}`)}function B(I){const O=Math.sqrt(I.x*I.x+I.y*I.y+I.z*I.z);O>0&&(I.x/=O,I.y/=O,I.z/=O)}function F(I){return I.x*=-1,I}function R(I){if(I.x*I.x+I.y*I.y>.5){const O=Math.abs(I.x),C=Math.abs(I.y);if(O>C){const C=Math.sign(I.x);I.x=O,I.y*=-C,I.z*=-C,I.w*=C}else{const O=Math.sign(I.y);I.x*=-O,I.y=C,I.z*=O,I.w*=-O}}else{const O=Math.abs(I.z),C=Math.abs(I.w);if(O>C){const C=Math.sign(I.z);I.x*=-C,I.y*=C,I.z=O,I.w*=-C}else{const O=Math.sign(I.w);I.x*=O,I.y*=-O,I.z*=-O,I.w=C}}return I}function G(I){I.cS(-I.z,I.w,I.x,-I.y)}function II(I,O){const C=j.mC.FromArrayToRef(O.translation||[0,0,0],0,j.TmpVectors.mC[0]),K=j.Quaternion.FromArrayToRef(O.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[0]),i=j.Matrix.ComposeToRef(L,K,C,j.TmpVectors.Matrix[0]),y=j.mC.FromArrayToRef(I.translation||[0,0,0],0,j.TmpVectors.mC[2]),S=j.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,j.TmpVectors.Quaternion[1]),U=j.Matrix.ComposeToRef(L,S,y,j.TmpVectors.Matrix[1]);i.multiplyToRef(U,U),U.decompose(void 0,K,C),C.equalsWithEpsilon(V,g.d)?delete O.translation:O.translation=C.qS(),K.equalsWithEpsilon(e,g.d)?delete O.rotation:O.rotation=K.qS(),O.scale&&delete O.scale}function OI(I,O){if(!(O instanceof Q.d))return!1;if(!(1===O.getChildren().length&&0===I.getChildren().length&&I.parent===O))return!1;const C=I.nI(),j=I instanceof w.d&&!C.useRightHandedSystem?z:L;return!!O.nS.equalsWithEpsilon(j,g.d)||(d.c.Warn(`Cannot collapse node ${I.name} into parent node ${O.name} with modified scaling.`),!1)}function CI(I){if(I instanceof Array){const O=new Float32Array(I);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(I)?new Uint8Array(I.buffer,I.byteOffset,I.byteLength):new Uint8Array(I)}function jI(I,O){for(const[C,j]of Object.entries(I)){const K=O[C];(Array.isArray(j)&&Array.isArray(K)&&KI(j,K)||j===K)&&delete I[C]}return I}function KI(I,O){return I.length===O.length&&I.every(((I,C)=>I===O[C]))}const iI=j.Matrix.Compose(new j.mC(-1,1,1),j.Quaternion.Identity(),j.mC.Zero());function yI(I,O){if(!(I instanceof Q.d))return!1;if(O){if(!I.getWorldMatrix().equalsWithEpsilon(j.Matrix.IdentityReadOnly,g.d))return!1}else{if(!I.getWorldMatrix().multiplyToRef(iI,j.TmpVectors.Matrix[0]).equalsWithEpsilon(j.Matrix.IdentityReadOnly,g.d))return!1}return!(I instanceof s.e&&I.WS)}const SI=new Map([[Int8Array,(I,O,C)=>I.setInt8(O,C)],[Uint8Array,(I,O,C)=>I.setUint8(O,C)],[Uint8ClampedArray,(I,O,C)=>I.setUint8(O,C)],[Int16Array,(I,O,C)=>I.setInt16(O,C,!0)],[Uint16Array,(I,O,C)=>I.setUint16(O,C,!0)],[Int32Array,(I,O,C)=>I.setInt32(O,C,!0)],[Uint32Array,(I,O,C)=>I.setUint32(O,C,!0)],[Float32Array,(I,O,C)=>I.setFloat32(O,C,!0)],[Float64Array,(I,O,C)=>I.setFloat64(O,C,!0)]]);class UI{writeTypedArray(I){this._checkGrowBuffer(I.byteLength);const O=SI.get(I.constructor);for(let C=0;C<I.length;C++)O(this._dataView,this._byteOffset,I[C]),this._byteOffset+=I.BYTES_PER_ELEMENT}constructor(I){this._data=new Uint8Array(I),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(I){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,I),this._byteOffset++}writeInt8(I){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,I),this._byteOffset++}writeInt16(I){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,I,!0),this._byteOffset+=2}writeUInt16(I){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,I,!0),this._byteOffset+=2}writeInt32(I){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,I,!0),this._byteOffset+=4}writeUInt32(I){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat32(I){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,I,!0),this._byteOffset+=4}writeFloat64(I){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,I,!0),this._byteOffset+=8}_checkGrowBuffer(I){const O=this.byteOffset+I;if(O>this._data.byteLength){const I=new Uint8Array(2*O);I.set(this._data),this._data=I,this._dataView=new DataView(this._data.buffer)}}}function pI(I){return I%4===0?4:I%2===0?2:1}class NI{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(I){let O=0;this._bufferViewToData.forEach((I=>{O+=I.byteLength}));const C=new UI(O),j=Array.from(this._bufferViewToData.keys()).sort(((I,O)=>pI(O.byteLength)-pI(I.byteLength)));for(const K of j){K.byteOffset=C.byteOffset,I.push(K);const O=I.length-1,j=this.getPropertiesWithBufferView(K);for(const I of j)I.bufferView=O;C.writeTypedArray(this._bufferViewToData.get(K)),this._bufferViewToData.delete(K)}return C.getOutputData()}createBufferView(I,O){const C={buffer:0,byteOffset:void 0,byteLength:I.byteLength,byteStride:O};return this._bufferViewToData.set(C,I),C}createAccessor(I,O,C,j,K,i,y){this._verifyBufferView(I);const S={bufferView:void 0,componentType:C,count:j,type:O,min:null===i||void 0===i?void 0:i.min,max:null===i||void 0===i?void 0:i.max,normalized:y,byteOffset:K};return this.setBufferView(S,I),this._accessorToBufferView.set(S,I),S}setBufferView(I,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(I)}removeBufferView(I){const O=this.getPropertiesWithBufferView(I);for(const C of O)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(I),this._bufferViewToProperties.delete(I),this._accessorToBufferView.forEach(((O,C)=>{O===I&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(I){const O=this._accessorToBufferView.get(I);return this._verifyBufferView(O),O}getPropertiesWithBufferView(I){return this._verifyBufferView(I),this._bufferViewToProperties.set(I,this._bufferViewToProperties.get(I)??[]),this._bufferViewToProperties.get(I)}getData(I){return this._verifyBufferView(I),this._bufferViewToData.get(I)}_verifyBufferView(I){if(void 0===I||!this._bufferViewToData.has(I))throw new Error(`BufferView ${I} not found in BufferManager.`)}}var QI,sI=C(12677),ZI=C(12697),qI=C(12720),mO=C(12604),EI=C(12759),hI=C(12766),rI=C(12671),WI=C(12772);!function(I){I[I.INTANGENT=0]="INTANGENT",I[I.OUTTANGENT=1]="OUTTANGENT"}(QI||(QI={}));class YI{static _IsTransformable(I){return I&&(I instanceof Q.d||I instanceof sI.e||I instanceof WI.d)}static _CreateNodeAnimation(I,O,C,j,i){if(this._IsTransformable(I)){const y=[],S=[],U=O.getKeys(),p=YI._CalculateMinMaxKeyFrames(U),N=YI._DeduceInterpolation(U,C,j),Q=N.interpolationType,s=N.shouldBakeAnimation;if(s?YI._CreateBakedAnimation(I,O,C,p.min,p.max,O.framePerSecond,i,y,S,p,j):"LINEAR"===Q||"STEP"===Q?YI._CreateLinearOrStepAnimation(I,O,C,y,S,j):"CUBICSPLINE"===Q?YI._CreateCubicSplineAnimation(I,O,C,y,S,j):YI._CreateBakedAnimation(I,O,C,p.min,p.max,O.framePerSecond,i,y,S,p,j),y.length&&S.length){return{inputs:y,outputs:S,samplerInterpolation:Q,inputsMin:s?p.min:K.Tools.FloatRound(p.min/O.framePerSecond),inputsMax:s?p.max:K.Tools.FloatRound(p.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(I){let O=null,C="VEC3",j=!1;const i=I.targetProperty.split(".");switch(i[0]){case"nS":O="scale";break;case"position":O="translation";break;case"rotation":C="VEC4",O="rotation";break;case"rotationQuaternion":C="VEC4",j=!0,O="rotation";break;case"influence":C="SCALAR",O="weights";break;default:K.Tools.Error(`Unsupported animatable property ${i[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:C,useQuaternion:j}:(K.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(I,O,C,j,K,i,y,S,U,p,N){let Q;if(YI._IsTransformable(I)&&I.animations)for(const s of I.animations){if(N&&!N(s))continue;const K=YI._DeduceAnimationInfo(s);K&&(Q={name:s.name,samplers:[],channels:[]},YI._AddAnimation(`${s.name}`,s.hasRunningRuntimeAnimations?O:Q,I,s,K.dataAccessorType,K.animationChannelTargetPath,j,i,y,S,K.useQuaternion,U,p),Q.samplers.length&&Q.channels.length&&C.push(Q))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(I,O,C,j,K,i,y,S,U,p,N){let Q;if(I instanceof rI.c){const K=I.morphTargetManager;if(K)for(let s=0;s<K.numTargets;++s){const Z=K.getTarget(s);for(const q of Z.animations){if(N&&!N(q))continue;const Z=new EI.d(`${q.name}`,"influence",q.framePerSecond,q.dataType,q.loopMode,q.enableBlending),mI=[],E=q.getKeys();for(let I=0;I<E.length;++I){const O=E[I];for(let I=0;I<K.numTargets;++I)I==s?mI.push(O):mI.push({frame:O.frame,value:0})}Z.setKeys(mI);const h=YI._DeduceAnimationInfo(Z);h&&(Q={name:Z.name,samplers:[],channels:[]},YI._AddAnimation(q.name,q.hasRunningRuntimeAnimations?O:Q,I,Z,h.dataAccessorType,h.animationChannelTargetPath,j,i,y,S,h.useQuaternion,U,p,K.numTargets),Q.samplers.length&&Q.channels.length&&C.push(Q))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(I,O,C,j,K,i,y,S,U){let p;if(I.animationGroups){const Q=I.animationGroups;for(const s of Q){const Q=new Map,Z=new Map,q=new Set,mI=s.to-s.from;p={name:s.name,channels:[],samplers:[]};for(let O=0;O<s.targetedAnimations.length;++O){const mI=s.targetedAnimations[O],E=mI.target,h=mI.animation;if(U&&!U(h))continue;const r=S.has(E);if(this._IsTransformable(E)||1===E.length&&this._IsTransformable(E[0])){const I=YI._DeduceAnimationInfo(mI.animation);if(I){const O=this._IsTransformable(E)?E:this._IsTransformable(E[0])?E[0]:null;O&&YI._AddAnimation(`${h.name}`,p,O,h,I.dataAccessorType,I.animationChannelTargetPath,C,j,K,i,I.useQuaternion,y,r)}}else if(E instanceof hI.e||1===E.length&&E[0]instanceof hI.e){if(YI._DeduceAnimationInfo(mI.animation)){const O=E instanceof hI.e?E:E[0];if(O){const C=I.morphTargetManagers.find((I=>{for(let C=0;C<I.numTargets;++C)if(I.getTarget(C)===O)return!0;return!1}));if(C){const j=I.meshes.find((I=>I.morphTargetManager===C));var N;if(j)Q.has(j)||Q.set(j,new Map),null===(N=Q.get(j))||void 0===N||N.set(O,h),q.add(j),Z.set(j,h)}}}}}q.forEach((I=>{const O=I.morphTargetManager;let S=null;const U=[],N=Z.get(I).getKeys(),q=N.length;for(let C=0;C<q;++C)for(let j=0;j<O.numTargets;++j){const K=O.getTarget(j),i=Q.get(I);if(i){const O=i.get(K);O?(S||(S=new EI.d(`${s.name}_${I.name}_MorphWeightAnimation`,"influence",O.framePerSecond,EI.d.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),U.push(O.getKeys()[C])):U.push({frame:s.from+mI/q*C,value:K.influence,inTangent:N[0].inTangent?0:void 0,outTangent:N[0].outTangent?0:void 0})}}S.setKeys(U);const E=YI._DeduceAnimationInfo(S);E&&YI._AddAnimation(`${s.name}_${I.name}_MorphWeightAnimation`,p,I,S,E.dataAccessorType,E.animationChannelTargetPath,C,j,K,i,E.useQuaternion,y,!1,null===O||void 0===O?void 0:O.numTargets)})),p.channels.length&&p.samplers.length&&O.push(p)}}}static _AddAnimation(I,O,C,K,i,y,S,U,p,N,Q,s,Z,q){const mI=YI._CreateNodeAnimation(C,K,y,Q,s);let E,h,r,W,Y,o;if(mI){if(q){let I=0,O=0;const C=[];for(;mI.inputs.length>0;)O=mI.inputs.shift(),I%q==0&&C.push(O),I++;mI.inputs=C}const I=S.get(C),K=new Float32Array(mI.inputs);E=U.createBufferView(K),h=U.createAccessor(E,"SCALAR",5126,mI.inputs.length,void 0,{min:[mI.inputsMin],max:[mI.inputsMax]}),N.push(h),r=N.length-1;const p=new j.Quaternion,Q=new j.mC,s=new j.mC,c=C instanceof sI.e,n=A(i),X=new Float32Array(mI.outputs.length*n);mI.outputs.forEach((function(I,O){let C=I;switch(y){case"translation":Z&&(j.mC.FromArrayToRef(I,0,s),F(s),s.toArray(C));break;case"rotation":4===I.length?j.Quaternion.FromArrayToRef(I,0,p):(C=new Array(4),j.mC.FromArrayToRef(I,0,Q),j.Quaternion.FromEulerVectorToRef(Q,p)),Z&&(R(p),c&&G(p)),p.toArray(C)}X.set(C,O*n)})),E=U.createBufferView(X),h=U.createAccessor(E,i,5126,mI.outputs.length),N.push(h),W=N.length-1,Y={interpolation:mI.samplerInterpolation,input:r,output:W},O.samplers.push(Y),o={sampler:O.samplers.length-1,target:{node:I,path:y}},O.channels.push(o)}}static _CreateBakedAnimation(I,O,C,i,y,S,U,p,N,Q,s){let Z;const q=j.Quaternion.Identity();let mI,E=null,h=null,r=null,W=null,Y=null,o=null;Q.min=K.Tools.FloatRound(i/S);const c=O.getKeys();for(let j=0,n=c.length;j<n;++j){if(o=null,r=c[j],j+1<n)if(W=c[j+1],r.value.equals&&r.value.equals(W.value)||r.value===W.value){if(0!==j)continue;o=r.frame}else o=W.frame;else{if(Y=c[j-1],r.value.equals&&r.value.equals(Y.value)||r.value===Y.value)continue;o=y}if(o)for(let j=r.frame;j<=o;j+=U){if(mI=K.Tools.FloatRound(j/S),mI===E)continue;E=mI,h=mI;const i={key:0,repeatCount:0,loopMode:O.loopMode};Z=O._interpolate(j,i),YI._SetInterpolatedValue(I,Z,mI,O,C,q,p,N,s)}}h&&(Q.max=h)}static _ConvertFactorToVector3OrQuaternion(I,O,C,i,y){const S=YI._GetBasePositionRotationOrScale(O,i,y),U=C.targetProperty.split("."),p=U?U[1]:"",N=y?j.Quaternion.YO(S).normalize():j.mC.YO(S);switch(p){case"x":case"y":case"z":N[p]=I;break;case"w":N.w=I;break;default:K.Tools.Error(`glTFAnimation: Unsupported component name "${p}"!`)}return N}static _SetInterpolatedValue(I,O,C,K,i,y,S,U,p){let N;S.push(C),"weights"!==i?(K.dataType===EI.d.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,I,K,i,p)),"rotation"===i?(p?y=O:(N=O,j.Quaternion.RotationYawPitchRollToRef(N.y,N.x,N.z,y)),U.push(y.qS())):(N=O,U.push(N.qS()))):U.push([O])}static _CreateLinearOrStepAnimation(I,O,C,j,K,i){for(const y of O.getKeys())j.push(y.frame/O.framePerSecond),YI._AddKeyframeValue(y,O,K,C,I,i)}static _CreateCubicSplineAnimation(I,O,C,j,K,i){O.getKeys().forEach((function(y){j.push(y.frame/O.framePerSecond),YI._AddSplineTangent(QI.INTANGENT,K,C,"CUBICSPLINE",y,i),YI._AddKeyframeValue(y,O,K,C,I,i),YI._AddSplineTangent(QI.OUTTANGENT,K,C,"CUBICSPLINE",y,i)}))}static _GetBasePositionRotationOrScale(I,O,C){let K;if("rotation"===O)if(C){K=(I.rotationQuaternion??j.Quaternion.Identity()).qS()}else{K=(I.rotation??j.mC.Zero()).qS()}else if("translation"===O){K=(I.position??j.mC.Zero()).qS()}else{K=(I.nS??j.mC.One()).qS()}return K}static _AddKeyframeValue(I,O,C,i,y,S){let U;const p=O.dataType;if(p===EI.d.ANIMATIONTYPE_VECTOR3){let O=I.value.qS();if("rotation"===i){const I=j.mC.YO(O);O=j.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).qS()}C.push(O)}else if(p===EI.d.ANIMATIONTYPE_FLOAT){if("weights"===i)C.push([I.value]);else if(U=this._ConvertFactorToVector3OrQuaternion(I.value,y,O,i,S),U){if("rotation"===i){const I=S?U:j.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).normalize();C.push(I.qS())}C.push(U.qS())}}else p===EI.d.ANIMATIONTYPE_QUATERNION?C.push(I.value.normalize().qS()):K.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(I,O,C){let j,K,i=!1;if("rotation"===O&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let y=0,S=I.length;y<S;++y)if(K=I[y],K.inTangent||K.outTangent)if(j){if("CUBICSPLINE"!==j){j="LINEAR",i=!0;break}}else j="CUBICSPLINE";else if(j){if("CUBICSPLINE"===j||K.interpolation&&1===K.interpolation&&"STEP"!==j){j="LINEAR",i=!0;break}}else j=K.interpolation&&1===K.interpolation?"STEP":"LINEAR";return j||(j="LINEAR"),{interpolationType:j,shouldBakeAnimation:i}}static _AddSplineTangent(I,O,C,K,i,y){let S;const U=I===QI.INTANGENT?i.inTangent:i.outTangent;if("CUBICSPLINE"===K){if("rotation"===C)if(U)if(y)S=U.qS();else{const I=U;S=j.Quaternion.RotationYawPitchRoll(I.y,I.x,I.z).qS()}else S=[0,0,0,0];else S="weights"===C?U?[U]:[0]:U?U.qS():[0,0,0];O.push(S)}}static _CalculateMinMaxKeyFrames(I){let O=1/0,C=-1/0;return I.forEach((function(I){O=Math.min(O,I.frame),C=Math.max(C,I.frame)})),{min:O,max:C}}}function oI(I,O,C,i,y,S){const U={attributes:{},influence:I.influence,name:I.name},p=O.WS;if(!p)return K.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),U;const Q=S?-1:1,s=j.mC.Zero();let Z=0,q=0;if(I.hasPositions){const i=I.getPositions(),S=p.getVerticesData(N.e.PositionKind);if(S){const I=new Float32Array(S.length),O=[1/0,1/0,1/0],K=[-1/0,-1/0,-1/0];q=S.length/3,Z=0;for(let C=Z;C<q;++C){const y=j.mC.YO(S,3*C);j.mC.YO(i,3*C).subtractToRef(y,s),s.x*=Q,O[0]=Math.min(O[0],s.x),K[0]=Math.max(K[0],s.x),O[1]=Math.min(O[1],s.y),K[1]=Math.max(K[1],s.y),O[2]=Math.min(O[2],s.z),K[2]=Math.max(K[2],s.z),I[3*C]=s.x,I[3*C+1]=s.y,I[3*C+2]=s.z}const p=C.createBufferView(I,12),N=C.createAccessor(p,"VEC3",5126,i.length/3,0,{min:O,max:K});y.push(N),U.attributes.POSITION=y.length-1}else K.Tools.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(I.hasNormals){const i=I.getNormals(),S=p.getVerticesData(N.e.NormalKind);if(S){const I=new Float32Array(S.length);q=S.length/3,Z=0;for(let C=Z;C<q;++C){const O=j.mC.YO(S,3*C).normalize();j.mC.YO(i,3*C).normalize().subtractToRef(O,s),I[3*C]=s.x*Q,I[3*C+1]=s.y,I[3*C+2]=s.z}const O=C.createBufferView(I,12),K=C.createAccessor(O,"VEC3",5126,i.length/3,0);y.push(K),U.attributes.NORMAL=y.length-1}else K.Tools.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(I.hasTangents){const i=I.getTangents(),S=p.getVerticesData(N.e.TangentKind);if(S){q=S.length/4;const I=new Float32Array(3*q);Z=0;for(let C=Z;C<q;++C){const O=j.mC.YO(S,4*C);B(O);const K=j.mC.YO(i,3*C);B(K),K.subtractToRef(O,s),I[3*C]=s.x*Q,I[3*C+1]=s.y,I[3*C+2]=s.z}const O=C.createBufferView(I,12),K=C.createAccessor(O,"VEC3",5126,q,0);y.push(K),U.attributes.TANGENT=y.length-1}else K.Tools.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(I.hasColors){const i=I.getColors(),S=p.getVerticesData(N.e.ColorKind),Q=p.getVertexBuffer(N.e.ColorKind);if(S&&Q){const I=Q.getSize();q=S.length/I;const O=new Float32Array(q*I);Z=0;for(let C=Z;C<q;++C)if(3===I){const K=j.mC.YO(S,C*I);j.mC.YO(i,C*I).subtractToRef(K,s),O[3*C]=s.x,O[3*C+1]=s.y,O[3*C+2]=s.z}else if(4===I){const K=new j.Vector4,y=j.Vector4.YO(S,C*I);j.Vector4.YO(i,C*I).subtractToRef(y,K),O[4*C]=K.x,O[4*C+1]=K.y,O[4*C+2]=K.z,O[4*C+3]=K.w}else K.Tools.Warn(`Unsupported number of components for color attribute: ${I}`);const p=C.createBufferView(O,4*I),N=C.createAccessor(p,3===I?"VEC3":"VEC4",5126,q,0);y.push(N),U.attributes.COLOR_0=y.length-1}else K.Tools.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return U}var cI=C(12781),nI=C(12628),XI=C(12612),TI=C(12226);class HI{}HI.DEFAULT_COLOR=E.WO.White(),HI.DEFAULT_WIDTH_ATTENUATED=1,HI.DEFAULT_WIDTH=.1;var bI=C(12460),aI=C(12786);class MI{static ConvertPoints(I,O){if(I.length&&Array.isArray(I)&&"number"===typeof I[0])return[I];if(I.length&&Array.isArray(I[0])&&"number"===typeof I[0][0])return I;if(I.length&&!Array.isArray(I[0])&&I[0]instanceof j.mC){const O=[];for(let C=0;C<I.length;C++){const j=I[C];O.push(j.x,j.y,j.z)}return[O]}if(I.length>0&&Array.isArray(I[0])&&I[0].length>0&&I[0][0]instanceof j.mC){const O=[],C=I;for(const I of C)O.push(I.flatMap((I=>[I.x,I.y,I.z])));return O}if(I instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const C=[],j=3*O.floatArrayStride;for(let O=0;O<I.length;O+=j){const K=new Array(j);for(let C=0;C<j;C++)K[C]=I[O+C];C.push(K)}return C}return[Array.from(I)]}if(I.length&&I[0]instanceof Float32Array){const O=[];for(const C of I)O.push(Array.from(C));return O}return[]}static OmitZeroLengthPredicate(I,O,C){const j=[];return O.EO(I).lengthSquared()>0&&j.push([I,O]),C.EO(O).lengthSquared()>0&&j.push([O,C]),I.EO(C).lengthSquared()>0&&j.push([C,I]),0===j.length?null:j}static OmitDuplicatesPredicate(I,O,C,j){const K=[];return MI._SearchInPoints(I,O,j)||K.push([I,O]),MI._SearchInPoints(O,C,j)||K.push([O,C]),MI._SearchInPoints(C,I,j)||K.push([C,I]),0===K.length?null:K}static _SearchInPoints(I,O,C){for(const y of C)for(let C=0;C<y.length;C++){var j,K,i;if(null!==(j=y[C])&&void 0!==j&&j.equals(I))if(null!==(K=y[C+1])&&void 0!==K&&K.equals(O)||null!==(i=y[C-1])&&void 0!==i&&i.equals(O))return!0}return!1}static MeshesToLines(I,O){const C=[];for(let K=0;K<I.length;K++){const i=I[K],y=i.getVerticesData(N.e.PositionKind),S=i.YS();if(y&&S)for(let I=0,U=0;I<S.length;I++){const p=3*S[U++],N=3*S[U++],Q=3*S[U++],s=new j.mC(y[p],y[p+1],y[p+2]),Z=new j.mC(y[N],y[N+1],y[N+2]),q=new j.mC(y[Q],y[Q+1],y[Q+2]);if(O){const j=O(s,Z,q,C,I,p,i,K,y,S);if(j)for(const I of j)C.push(I)}else C.push([s,Z],[Z,q],[q,s])}}return C}static ToVector3Array(I){if(Array.isArray(I[0])){const O=[],C=I;for(const I of C){const C=[];for(let O=0;O<I.length;O+=3)C.push(new j.mC(I[O],I[O+1],I[O+2]));O.push(C)}return O}const O=I,C=[];for(let K=0;K<O.length;K+=3)C.push(new j.mC(O[K],O[K+1],O[K+2]));return C}static ToNumberArray(I){return I.flatMap((I=>[I.x,I.y,I.z]))}static GetPointsCountInfo(I){const O=new Array(I.length);let C=0;for(let j=I.length;j--;)O[j]=I[j].length/3,C+=O[j];return{total:C,counts:O}}static GetLineLength(I){if(0===I.length)return 0;let O;O="number"===typeof I[0]?MI.ToVector3Array(I):I;const C=j.TmpVectors.mC[0];let K=0;for(let j=0;j<O.length-1;j++){const I=O[j];K+=O[j+1].subtractToRef(I,C).length()}return K}static GetLineLengthArray(I){const O=new Float32Array(I.length/3);let C=0;for(let j=0,K=I.length/3-1;j<K;j++){let K=I[3*j+0],i=I[3*j+1],y=I[3*j+2];K-=I[3*j+3],i-=I[3*j+4],y-=I[3*j+5];C+=Math.sqrt(K*K+i*i+y*y),O[j+1]=C}return O}static SegmentizeSegmentByCount(I,O,C){const K=[],i=O.EO(I),y=j.TmpVectors.mC[0];y.XS(C);const S=j.TmpVectors.mC[1];i.divideToRef(y,S);let U=I.clone();K.push(U);for(let j=0;j<C;j++)U=U.clone(),K.push(U.addInPlace(S));return K}static SegmentizeLineBySegmentLength(I,O){const C=I[0]instanceof j.mC?MI.GetLineSegments(I):"number"===typeof I[0]?MI.GetLineSegments(MI.ToVector3Array(I)):I,K=[];for(const j of C)if(j.length>O){const I=MI.SegmentizeSegmentByCount(j.point1,j.point2,Math.ceil(j.length/O));for(const O of I)K.push(O)}else K.push(j.point1),K.push(j.point2);return K}static SegmentizeLineBySegmentCount(I,O){const C="number"===typeof I[0]?MI.ToVector3Array(I):I,j=MI.GetLineLength(C)/O;return MI.SegmentizeLineBySegmentLength(C,j)}static GetLineSegments(I){const O=[];for(let C=0;C<I.length-1;C++){const j=I[C],K=I[C+1],i=K.EO(j).length();O.push({point1:j,point2:K,length:i})}return O}static GetMinMaxSegmentLength(I){const O=MI.GetLineSegments(I).sort((I=>I.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(I,O,C){let K=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const i=O*C;let y=0,S=0;const U=I.length;for(let j=0;j<U;j++){if(i<=y+I[j].length){S=j;break}y+=I[j].length}const p=(i-y)/I[S].length;return I[S].point2.subtractToRef(I[S].point1,j.TmpVectors.mC[0]),j.TmpVectors.mC[1]=j.TmpVectors.mC[0].multiplyByFloats(p,p,p),K||j.TmpVectors.mC[1].addInPlace(I[S].point1),j.TmpVectors.mC[1].clone()}static GetCircleLinePoints(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,K=arguments.length>3&&void 0!==arguments[3]?arguments[3]:I,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const y=[];for(let S=0;S<=O;S++)y.push(new j.mC(Math.cos(S*i)*I,Math.sin(S*i)*K,C));return y}static GetBezierLinePoints(I,O,C,j){return bI.e.CreateQuadraticBezier(I,O,C,j).getPoints().flatMap((I=>[I.x,I.y,I.z]))}static GetArrowCap(I,O,C,j,K){let i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[I.clone(),I.add(O.multiplyByFloats(C,C,C))],widths:[j,K,i,y]}}static GetPointsFromText(I,O,C,j){let K=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,i=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const y=[],S=(0,aI.b)(I,O,C,j);for(const U of S){for(const I of U.paths){const O=[],C=I.getPoints();for(const I of C)O.push(I.x,I.y,K);y.push(O)}if(i)for(const I of U.holes){const O=[],C=I.getPoints();for(const I of C)O.push(I.x,I.y,K);y.push(O)}}return y}static Color3toRGBAUint8(I){const O=new Uint8Array(4*I.length);for(let C=0,j=0;C<I.length;C++)O[j++]=255*I[C].r,O[j++]=255*I[C].g,O[j++]=255*I[C].b,O[j++]=255;return O}static CreateColorsTexture(I,O,C,j){const K=j.getEngine().getCaps().maxTextureSize??1,i=O.length>K?K:O.length,y=Math.ceil(O.length/K);y>1&&(O=[...O,...Array(i*y-O.length).fill(O[0])]);const S=MI.Color3toRGBAUint8(O),U=new c.d(S,i,y,q.c.TEXTUREFORMAT_RGBA,j,!1,!0,C);return U.name=I,U}static PrepareEmptyColorsTexture(I){if(!HI.EmptyColorsTexture){const O=new Uint8Array(4);HI.EmptyColorsTexture=new c.d(O,1,1,q.c.TEXTUREFORMAT_RGBA,I,!1,!1,c.d.NEAREST_NEAREST),HI.EmptyColorsTexture.name="grlEmptyColorsTexture"}return HI.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var I;null===(I=HI.EmptyColorsTexture)||void 0===I||I.dispose(),HI.EmptyColorsTexture=null}static BooleanToNumber(I){return I?1:0}}class uI extends XI.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class JI extends nI.b{isCompatible(I){return!0}constructor(I,O,C){var K;C=C||{color:HI.DEFAULT_COLOR};const i=new uI;i.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,i.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,i.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,i.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??I.nI()).useRightHandedSystem,i.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(I,JI.GREASED_LINE_MATERIAL_NAME,200,i,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(K=C)||void 0===K?void 0:K.forceGLSL)||JI.ForceGLSL,this._scene=O??I.nI(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?HI.DEFAULT_WIDTH_ATTENUATED:HI.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??c.d.NEAREST_NEAREST,this._colors=C.bI??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new j.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=MI.CreateColorsTexture(`${I.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??HI.DEFAULT_COLOR,MI.PrepareEmptyColorsTexture(this._scene)),this._engine.yS.add((()=>{MI.DisposeEmptyColorsTexture()}))}getAttributes(I){I.push("grl_offsets"),I.push("grl_widths"),I.push("grl_colorPointers"),I.push("grl_counters"),this._cameraFacing?(I.push("grl_previousAndSide"),I.push("grl_nextAndCounters")):I.push("grl_slopes")}getSamplers(I){I.push("grl_colors")}getActiveTextures(I){this.colorsTexture&&I.push(this.colorsTexture)}getUniforms(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===I&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(I)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(I)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(I){if(this._cameraFacing){I.hS("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||I.hS("viewProjection",this._scene.getTransformMatrix());const O=j.TmpVectors.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,I.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=j.TmpVectors.Vector4[0];O.x=MI.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,I.updateVector4("grl_dashOptions",O);const C=j.TmpVectors.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=MI.BooleanToNumber(this.useColors),I.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&I.updateColor3("grl_singleColor",this._color);const K=this.colorsTexture??HI.EmptyColorsTexture;I.setTexture("grl_colors",K),I.updateFloat2("grl_textureSize",(null===K||void 0===K?void 0:K.getSize().width)??1,(null===K||void 0===K?void 0:K.getSize().height)??1)}prepareDefines(I,O,C){I.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,I.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,I.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,I.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,I.GREASED_LINE_CAMERA_FACING=this._cameraFacing,I.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return JI.GREASED_LINE_MATERIAL_NAME}getCustomCode(I){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(I,O){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(I["!gl_Position\\=viewProjection\\*worldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(I,this._cameraFacing):function(I,O){if("vertex"===I){const I={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(I["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),I}return"fragment"===I?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(I,this._cameraFacing)}dispose(){var I;null===(I=this.colorsTexture)||void 0===I||I.dispose(),super.dispose()}get bI(){return this._colors}set bI(I){this.setColors(I)}setColors(I){var O;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const K=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var i;if(this._colors=I,null!==I&&0!==I.length){if(!C||j)if(this.colorsTexture&&K===I.length&&!j){const O=MI.Color3toRGBAUint8(I);this.colorsTexture.update(O)}else{var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=MI.CreateColorsTexture(`${this._material.name}-colors-texture`,I,this.colorsSampling,this._scene)}}else null===(i=this.colorsTexture)||void 0===i||i.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.markAllDefinesAsDirty()}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==I||null!==this._color&&null===I?(this._color=I,O||this.markAllDefinesAsDirty()):this._color=I}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(I){this._aspect=I.x/I.y,this._resolution=I}serialize(){const I=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.bI=this._colors),this._color&&(O.color=this._color),I.greasedLineMaterialOptions=O,I}parse(I,O,C){var j;super.parse(I,O,C);const K=I.greasedLineMaterialOptions;null===(j=this.colorsTexture)||void 0===j||j.dispose(),K.color&&this.setColor(K.color,!0),K.colorDistributionType&&(this.colorsDistributionType=K.colorDistributionType),K.bI&&(this.bI=K.bI),K.colorsSampling&&(this.colorsSampling=K.colorsSampling),K.colorMode&&(this.colorMode=K.colorMode),K.useColors&&(this.useColors=K.useColors),K.visibility&&(this.visibility=K.visibility),K.useDash&&(this.useDash=K.useDash),K.dashCount&&(this.dashCount=K.dashCount),K.dashRatio&&(this.dashRatio=K.dashRatio),K.dashOffset&&(this.dashOffset=K.dashOffset),K.width&&(this.width=K.width),K.sizeAttenuation&&(this.sizeAttenuation=K.sizeAttenuation),K.resolution&&(this.resolution=K.resolution),this.bI?this.colorsTexture=MI.CreateColorsTexture(`${this._material.name}-colors-texture`,this.bI,this.colorsSampling,O):MI.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(I){var O;const C=I;null===(O=C.colorsTexture)||void 0===O||O.dispose(),this._colors&&(C.colorsTexture=MI.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(I){return 0===I||this._forceGLSL}}JI.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",JI.ForceGLSL=!1,(0,TI.e)(`BABYLON.${JI.GREASED_LINE_MATERIAL_NAME}`,JI);var fI=C(12665),lI=C(12112),xI=C(12480),DI=C(12208);class tI extends xI.ShaderMaterial{constructor(I,O,K){const i=O.getEngine(),y=i.isWebGPU&&!(K.forceGLSL||tI.ForceGLSL),S=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&S.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const U=["position","grl_widths","grl_offsets","grl_colorPointers"];K.cameraFacing?(S.push("GREASED_LINE_CAMERA_FACING"),U.push("grl_previousAndSide","grl_nextAndCounters")):(U.push("grl_slopes"),U.push("grl_counters"));const p=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(y||p.push("world","viewProjection","view","projection"),super(I,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:y?["Scene","Mesh"]:void 0,attributes:U,uniforms:p,samplers:y?[]:["grlColors"],defines:S,extraInitializationsAsync:async()=>{y?await Promise.all([C.e(66).then(C.bind(C,15276)),C.e(75).then(C.bind(C,15285))]):await Promise.all([C.e(69).then(C.bind(C,15291)),C.e(76).then(C.bind(C,15297))])},shaderLanguage:y?1:0}),this._color=E.WO.White(),this._colorsDistributionType=0,this._colorsTexture=null,K=K||{color:HI.DEFAULT_COLOR},this.visibility=K.visibility??1,this.useDash=K.useDash??!1,this.dashRatio=K.dashRatio??.5,this.dashOffset=K.dashOffset??0,this.dashCount=K.dashCount??1,this.width=K.width?K.width:K.sizeAttenuation&&K.cameraFacing?HI.DEFAULT_WIDTH_ATTENUATED:HI.DEFAULT_WIDTH,this.sizeAttenuation=K.sizeAttenuation??!1,this.color=K.color??E.WO.White(),this.useColors=K.useColors??!1,this.colorsDistributionType=K.colorDistributionType??0,this.colorsSampling=K.colorsSampling??c.d.NEAREST_NEAREST,this.colorMode=K.colorMode??0,this._colors=K.bI??null,this._cameraFacing=K.cameraFacing??!0,this.resolution=K.resolution??new j.Vector2(i.getRenderWidth(),i.getRenderHeight()),K.colorsTexture?this.colorsTexture=K.colorsTexture:this._colors?this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??HI.DEFAULT_COLOR,this.colorsTexture=MI.PrepareEmptyColorsTexture(O)),y){const I=new DI.c;I.setParameters(),I.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",I)}i.yS.add((()=>{MI.DisposeEmptyColorsTexture()}))}dispose(){var I;null===(I=this._colorsTexture)||void 0===I||I.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new j.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get bI(){return this._colors}set bI(I){this.setColors(I)}setColors(I){var O;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],j=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const K=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var i;if(this._colors=I,null!==I&&0!==I.length){if(!C||j)if(this._colorsTexture&&K===I.length&&!j){const O=MI.Color3toRGBAUint8(I);this._colorsTexture.update(O)}else{var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,I,this.colorsSampling,this.nI())}}else null===(i=this._colorsTexture)||void 0===i||i.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(I){this._colorsTexture=I,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(I){this._width=I,this.setFloat("grlWidth",I)}get useColors(){return this._useColors}set useColors(I){this._useColors=I,this.setFloat("grlUseColors",MI.BooleanToNumber(I))}get colorsSampling(){return this._colorsSampling}set colorsSampling(I){this._colorsSampling=I}get visibility(){return this._visibility}set visibility(I){this._visibility=I,this.setFloat("grlVisibility",I)}get useDash(){return this._useDash}set useDash(I){this._useDash=I,this.setFloat("grlUseDash",MI.BooleanToNumber(I))}get dashOffset(){return this._dashOffset}set dashOffset(I){this._dashOffset=I,this.setFloat("grlDashOffset",I)}get dashRatio(){return this._dashRatio}set dashRatio(I){this._dashRatio=I,this.setFloat("grlDashRatio",I)}get dashCount(){return this._dashCount}set dashCount(I){this._dashCount=I,this._dashArray=1/I,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(I){this._sizeAttenuation=I,this.setFloat("grlSizeAttenuation",MI.BooleanToNumber(I))}get color(){return this._color}set color(I){this.setColor(I)}setColor(I){I=I??HI.DEFAULT_COLOR,this._color=I,this.setColor3("grlColor",I)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(I){this._colorsDistributionType=I,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(I){this._colorMode=I,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(I){this._resolution=I,this.setVector2("grlResolution",I),this.setFloat("grlAspect",I.x/I.y)}serialize(){const I=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.bI=this._colors),I.greasedLineMaterialOptions=O,I}parse(I,O,C){var j;const K=I.greasedLineMaterialOptions;null===(j=this._colorsTexture)||void 0===j||j.dispose(),K.color&&(this.color=K.color),K.colorDistributionType&&(this.colorsDistributionType=K.colorDistributionType),K.colorsSampling&&(this.colorsSampling=K.colorsSampling),K.colorMode&&(this.colorMode=K.colorMode),K.useColors&&(this.useColors=K.useColors),K.visibility&&(this.visibility=K.visibility),K.useDash&&(this.useDash=K.useDash),K.dashCount&&(this.dashCount=K.dashCount),K.dashRatio&&(this.dashRatio=K.dashRatio),K.dashOffset&&(this.dashOffset=K.dashOffset),K.width&&(this.width=K.width),K.sizeAttenuation&&(this.sizeAttenuation=K.sizeAttenuation),K.resolution&&(this.resolution=K.resolution),K.bI?this.colorsTexture=MI.CreateColorsTexture(`${this.name}-colors-texture`,K.bI,this.colorsSampling,this.nI()):this.colorsTexture=MI.PrepareEmptyColorsTexture(O),this._cameraFacing=K.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var dI,wI,gI;tI.ForceGLSL=!1,function(I){I[I.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",I[I.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(dI||(dI={})),function(I){I[I.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",I[I.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",I[I.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(wI||(wI={})),function(I){I[I.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",I[I.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",I[I.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",I[I.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",I[I.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(gI||(gI={}));class VI extends rI.c{constructor(I,O,C){super(I,O,null,null,!1,!1),this.name=I,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(I){let O=0;for(const j of this._points)O+=j.length;const C=O/3*2-this._widths.length;for(let j=0;j<C;j++)this._widths.push(I)}updateLazy(){var I,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(I=this._options.ribbonOptions)||void 0===I?void 0:I.smoothShading),!this.JI&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(I,O){for(const C of I)this._points.push(C);this._lazy||this.setPoints(this._points,O)}dispose(I){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(I,O)}isLazy(){return this._lazy}get aI(){return this._uvs}set aI(I){this._uvs=I instanceof Float32Array?I:new Float32Array(I),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(I){this.material instanceof tI&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===I||void 0===I?void 0:I.length)>0),this._offsets=I,this._offsetsBuffer?this._offsetsBuffer.update(I):this._createOffsetsBuffer(I)}get widths(){return this._widths}set widths(I){this._widths=I,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(I)}get colorPointers(){return this._colorPointers}set colorPointers(I){this._colorPointers=I,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(I)}get greasedLineMaterial(){var I,O;if(this.material&&this.material instanceof tI)return this.material;const C=null===(I=this.material)||void 0===I||null===(O=I.pluginManager)||void 0===O?void 0:O.getPlugin(JI.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const I=[];return lI.b.DeepCopy(this._points,I),I}setPoints(I,O){this._points=MI.ConvertPoints(I,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,aI:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(I){super.serialize(I),I.type=this.getClassName(),I.lineOptions=this._createLineOptions()}_createVertexBuffers(){let I=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new fI.e;return O.TI=this._vertexPositions,O.indices=this._indices,O.aI=this._uvs,I&&(O.HI=[],fI.e.ComputeNormals(this._vertexPositions,this._indices,O.HI)),O.uI(this,this._options.updatable),O}_createOffsetsBuffer(I){const O=this._scene.getEngine(),C=new N.c(O,I,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class eI{constructor(I,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=I,this.wasAddedByNoopNode=O}getIndicesAccessor(I,O,C,j,K){var i,y,S,U;return null===(i=this._indicesAccessorMap.get(I))||void 0===i||null===(y=i.get(O))||void 0===y||null===(S=y.get(C))||void 0===S||null===(U=S.get(j))||void 0===U?void 0:U.get(K)}setIndicesAccessor(I,O,C,j,K,i){let y=this._indicesAccessorMap.get(I);y||(y=new Map,this._indicesAccessorMap.set(I,y));let S=y.get(O);S||(S=new Map,y.set(O,S));let U=S.get(C);U||(U=new Map,S.set(C,U));let p=U.get(j);p||(p=new Map,U.set(j,p)),p.set(K,i)}pushExportedNode(I){this._exportedNodes.has(I)||this._exportedNodes.add(I)}getNodesSet(){return this._exportedNodes}getVertexBufferView(I){return this._vertexBufferViewMap.get(I)}setVertexBufferView(I,O){this._vertexBufferViewMap.set(I,O)}setRemappedBufferView(I,O,C){this._remappedBufferView.set(I,new Map),this._remappedBufferView.get(I).set(O,C)}getRemappedBufferView(I,O){var C;return null===(C=this._remappedBufferView.get(I))||void 0===C?void 0:C.get(O)}getVertexAccessor(I,O,C){var j,K;return null===(j=this._vertexAccessorMap.get(I))||void 0===j||null===(K=j.get(O))||void 0===K?void 0:K.get(C)}setVertexAccessor(I,O,C,j){let K=this._vertexAccessorMap.get(I);K||(K=new Map,this._vertexAccessorMap.set(I,K));let i=K.get(O);i||(i=new Map,K.set(O,i)),i.set(C,j)}hasVertexColorAlpha(I){return this._vertexMapColorAlpha.get(I)||!1}setHasVertexColorAlpha(I,O){return this._vertexMapColorAlpha.set(I,O)}getMesh(I){return this._meshMap.get(I)}setMesh(I,O){this._meshMap.set(I,O)}bindMorphDataToMesh(I,O){const C=this._meshMorphTargetMap.get(I)||[];this._meshMorphTargetMap.set(I,C),-1===C.indexOf(O)&&C.push(O)}getMorphTargetsFromMesh(I){return this._meshMorphTargetMap.get(I)}}class LI{_ApplyExtension(I,O,C,j){if(C>=O.length)return Promise.resolve(I);const K=j(O[C],I);return K?K.then((async I=>I?await this._ApplyExtension(I,O,C+1,j):null)):this._ApplyExtension(I,O,C+1,j)}_ApplyExtensions(I,O){const C=[];for(const j of LI._ExtensionNames)C.push(this._extensions[j]);return this._ApplyExtension(I,C,0,O)}_extensionsPreExportTextureAsync(I,O,C){return this._ApplyExtensions(O,((O,j)=>O.preExportTextureAsync&&O.preExportTextureAsync(I,j,C)))}_extensionsPostExportNodeAsync(I,O,C,j,K){return this._ApplyExtensions(O,((O,i)=>O.postExportNodeAsync&&O.postExportNodeAsync(I,i,C,j,K,this._bufferManager)))}_extensionsPostExportMaterialAsync(I,O,C){return this._ApplyExtensions(O,((O,j)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(I,j,C)))}_extensionsPostExportMaterialAdditionalTextures(I,O,C){const j=[];for(const K of LI._ExtensionNames){const i=this._extensions[K];i.postExportMaterialAdditionalTextures&&j.push(...i.postExportMaterialAdditionalTextures(I,O,C))}return j}_extensionsPostExportTextures(I,O,C){for(const j of LI._ExtensionNames){const K=this._extensions[j];K.postExportTexture&&K.postExportTexture(I,O,C)}}_extensionsPostExportMeshPrimitive(I){for(const O of LI._ExtensionNames){const C=this._extensions[O];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(I,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const I of LI._ExtensionNames){const O=this._extensions[I];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(I){for(const O of LI._ExtensionNames){const C=this._extensions[O];C.enabled&&I(C)}}_extensionsOnExporting(){this._forEachExtensions((I=>{var O,C,j;I.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(I.name)&&this._glTF.extensionsUsed.push(I.name),I.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(I.name)&&this._glTF.extensionsRequired.push(I.name)),(j=this._glTF).extensions||(j.extensions={}),I.onExporting&&I.onExporting())}))}_loadExtensions(){for(const I of LI._ExtensionNames){const O=LI._ExtensionFactories[I](this);this._extensions[I]=O}}constructor(){let I=arguments.length>0&&void 0!==arguments[0]?arguments[0]:mI.e.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${q.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new D(this),this._extensions={},this._bufferManager=new NI,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!I)throw new Error("No scene available to export");this._babylonScene=I,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:I=>{var O;return null===I||void 0===I||null===(O=I.NS)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const I in this._extensions){this._extensions[I].dispose()}}get options(){return this._options}static RegisterExtension(I,O){LI.UnregisterExtension(I)&&K.Tools.Warn(`Extension with the name ${I} already exists`),LI._ExtensionFactories[I]=O,LI._ExtensionNames.push(I)}static UnregisterExtension(I){if(!LI._ExtensionFactories[I])return!1;delete LI._ExtensionFactories[I];const O=LI._ExtensionNames.indexOf(I);return-1!==O&&LI._ExtensionNames.splice(O,1),!0}_generateJSON(I,O,C){const j={byteLength:I};return j.byteLength&&(this._glTF.buffers=[j]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.hO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(j.uri=O+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(I){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(O.byteLength,I,!0),j=new Blob([O],{type:"application/octet-stream"}),K=I+".gltf",i=I+".bin",y=new p;if(y.files[K]=C,y.files[i]=j,this._imageData)for(const S in this._imageData)y.files[S]=new Blob([this._imageData[S].data],{type:this._imageData[S].mimeType});return y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(I){const O=I%4;return 0===O?O:4-O}async generateGLBAsync(I){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(O.byteLength),j=I+".glb";let K,i=C.length;if("undefined"!==typeof TextEncoder){K=(new TextEncoder).encode(C),i=K.length}const y=this._getPadding(i),S=this._getPadding(O.byteLength),U=28+i+y+O.byteLength+S,N=new UI(U);if(N.writeUInt32(1179937895),N.writeUInt32(2),N.writeUInt32(U),N.writeUInt32(i+y),N.writeUInt32(1313821514),K)N.writeTypedArray(K);else{const I="_".charCodeAt(0);for(let O=0;O<i;++O){const j=C.charCodeAt(O);j!=C.codePointAt(O)?N.writeUInt8(I):N.writeUInt8(j)}}for(let p=0;p<y;++p)N.writeUInt8(32);N.writeUInt32(O.byteLength+S),N.writeUInt32(5130562),N.writeTypedArray(O);for(let p=0;p<S;++p)N.writeUInt8(0);const Q=new p;return Q.files[j]=new Blob([N.getOutputData()],{type:"application/octet-stream"}),Q}_setNodeTransformation(I,O,C){if(O.getPivotPoint().equalsWithEpsilon(V,g.d)||K.Tools.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(V,g.d)){const K=j.TmpVectors.mC[0].K(O.position);C&&F(K),I.translation=K.qS()}O.nS.equalsWithEpsilon(L,g.d)||(I.scale=O.nS.qS());const i=O.rotationQuaternion||j.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);i.equalsWithEpsilon(e,g.d)||(C&&R(i),I.rotation=i.normalize().qS())}_setCameraTransformation(I,O,C){if(!O.position.equalsWithEpsilon(V,g.d)){const K=j.TmpVectors.mC[0].K(O.position);C&&F(K),I.translation=K.qS()}const K=O.rotationQuaternion||j.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);C&&R(K),this._babylonScene.useRightHandedSystem||G(K),K.equalsWithEpsilon(e,g.d)||(I.rotation=K.qS())}_listAvailableCameras(){for(const I of this._babylonScene.cameras){const O={type:I.mode===sI.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(I.name&&(O.name=I.name),"perspective"===O.type)O.perspective={aspectRatio:I.getEngine().getAspectRatio(I),yfov:I.fovMode===sI.e.FOVMODE_VERTICAL_FIXED?I.fov:I.fov*I.getEngine().getAspectRatio(I),znear:I.ES,zfar:I.maxZ};else if("orthographic"===O.type){const C=I.orthoLeft&&I.orthoRight?.5*(I.orthoRight-I.orthoLeft):.5*I.getEngine().getRenderWidth(),j=I.orthoBottom&&I.orthoTop?.5*(I.orthoTop-I.orthoBottom):.5*I.getEngine().getRenderHeight();O.orthographic={xmag:C,ymag:j,znear:I.ES,zfar:I.maxZ}}this._camerasMap.set(I,O)}}_exportAndAssignCameras(){const I=Array.from(this._camerasMap.values());for(const O of I){const I=this._nodesCameraMap.get(O);if(void 0!==I){this._cameras.push(O);for(const O of I)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(I,O)}}_exportAndAssignSkeletons(){for(const I of this._babylonScene.skeletons){if(I.bones.length<=0)continue;const O=this._skinMap.get(I);if(void 0==O)continue;const C={},j=[];let i=-1;for(let K=0;K<I.bones.length;++K){const O=I.bones[K],j=O.getIndex()??K;-1!==j&&(C[j]=O,j>i&&(i=j))}for(let I=0;I<=i;++I){const i=C[I];j.push(i.getAbsoluteInverseBindMatrix());const y=i.getTransformNode();if(null!==y){const I=this._nodeMap.get(y);y&&null!==I&&void 0!==I?O.joints.push(I):K.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else K.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const y=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==y){const I=64*j.length,C=new Float32Array(I/4);j.forEach(((I,O)=>{C.set(I.m,16*O)}));const K=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(K,"MAT4",5126,j.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of y)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const I={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(I.extras=O)}const O=new Array,C=new Array,j=new Array;for(const S of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&yI(S,this._babylonScene.useRightHandedSystem)?j.push(...S.getChildren()):this._babylonScene.useRightHandedSystem?O.push(S):C.push(S);this._listAvailableCameras(),this._listAvailableSkeletons();const K=new eI(!0,!1);I.nodes.push(...await this._exportNodesAsync(C,K));const i=new eI(!1,!1);I.nodes.push(...await this._exportNodesAsync(O,i));const y=new eI(!1,!0);I.nodes.push(...await this._exportNodesAsync(j,y)),I.nodes.length&&this._scenes.push(I),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&YI._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,K.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(I){let O=this._shouldExportNodeMap.get(I);return void 0===O&&(O=this._options.shouldExportNode(I),this._shouldExportNodeMap.set(I,O)),O}async _exportNodesAsync(I,O){const C=new Array;this._exportBuffers(I,O);for(const j of I)await this._exportNodeAsync(j,C,O);return C}_collectBuffers(I,O,C,j,K){if(this._shouldExportNode(I)&&I instanceof s.e&&I.WS){const i=I.WS.getVertexBuffers();if(i)for(const j in i){if(!P(j))continue;const y=i[j];K.setHasVertexColorAlpha(y,I.hasVertexAlpha);const S=y._buffer,U=O.get(S)||[];O.set(S,U),-1===U.indexOf(y)&&U.push(y);const p=C.get(y)||[];C.set(y,p),-1===p.indexOf(I)&&p.push(I)}const y=I.morphTargetManager;if(y)for(let O=0;O<y.numTargets;O++){const C=y.getTarget(O),K=j.get(C)||[];j.set(C,K),-1===K.indexOf(I)&&K.push(I)}}for(const i of I.getChildren())this._collectBuffers(i,O,C,j,K)}_exportBuffers(I,O){const C=new Map,j=new Map,K=new Map;for(const S of I)this._collectBuffers(S,C,j,K,O);const i=Array.from(C.keys());for(const S of i){const I=S.getData();if(!I)throw new Error("Buffer data is not available");const K=C.get(S);if(!K)continue;const i=K[0].byteStride;if(K.some((I=>I.byteStride!==i)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const y=CI(I).slice();for(const O of K){const I=j.get(O),{byteOffset:C,byteStride:K,componentCount:i,type:S,count:U,normalized:p,kind:Q}=k(O,I);switch(Q){case N.e.NormalKind:case N.e.TangentKind:(0,t.f)(y,C,K,i,S,U,p,(I=>{const O=Math.sqrt(I[0]*I[0]+I[1]*I[1]+I[2]*I[2]);if(O>0){const C=1/O;I[0]*=C,I[1]*=C,I[2]*=C}}));break;case N.e.ColorKind:{const O=I.filter((I=>I.material instanceof mO.rO||null==I.material)).length;if(0==O)break;if(O!=I.length){d.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}S==N.e.UNSIGNED_BYTE&&d.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const j=new E.WO,Q=new E.TS,s=this._babylonScene.getEngine().useExactSrgbConversions;(0,t.f)(y,C,K,i,S,U,p,(I=>{3===I.length?(j.qC(I,0),j.toLinearSpaceToRef(j,s),j.toArray(I,0)):(Q.qC(I,0),Q.toLinearSpaceToRef(Q,s),Q.toArray(I,0))}))}}}if(O.convertToRightHanded){for(const I of K){const O=j.get(I),{byteOffset:C,byteStride:K,componentCount:i,type:S,count:U,normalized:p,kind:Q}=k(I,O);switch(Q){case N.e.PositionKind:case N.e.NormalKind:case N.e.TangentKind:(0,t.f)(y,C,K,i,S,U,p,(I=>{I[0]=-I[0]}))}}O.convertedToRightHandedBuffers.set(S,y)}const U=this._bufferManager.createBufferView(y,i);O.setVertexBufferView(S,U);const p=new Map;for(const O of K){const I=j.get(O),{kind:C,totalVertices:K}=k(O,I);switch(C){case N.e.MatricesIndicesKind:case N.e.MatricesIndicesExtraKind:if(O.type==N.e.FLOAT){const I=O.getFloatData(K);null!==I&&p.set(O,I)}}}0!==p.size&&d.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const Q=Array.from(p.keys());for(const C of Q){const I=p.get(C);if(!I)continue;const j=I.some((I=>I>=256)),K=new(j?Uint16Array:Uint8Array)(I.length);for(let O=0;O<I.length;O++)K[O]=I[O];const i=this._bufferManager.createBufferView(K,4*(j?2:1));O.setRemappedBufferView(S,C,i)}}const y=Array.from(K.keys());for(const S of y){const I=K.get(S);if(!I)continue;const C=oI(S,I[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const j of I)O.bindMorphDataToMesh(j,C)}}async _exportNodeAsync(I,O,C){let j=this._nodeMap.get(I);if(void 0!==j)return void(O.includes(j)||O.push(j));const K=await this._createNodeAsync(I,C);if(K){j=this._nodes.length,this._nodes.push(K),this._nodeMap.set(I,j),C.pushExportedNode(I),O.push(j);const i={name:"runtime animations",channels:[],samplers:[]},y=[];this._babylonScene.animationGroups.length||(YI._CreateMorphTargetAnimationFromMorphTargetAnimations(I,i,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),I.animations.length&&YI._CreateNodeAnimationFromNodeAnimations(I,i,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),i.channels.length&&i.samplers.length&&this._animations.push(i),y.forEach((I=>{I.channels.length&&I.samplers.length&&this._animations.push(I)}))}const i=K?[]:O;for(const y of I.getChildren())await this._exportNodeAsync(y,i,C);K&&i.length&&(K.children=i)}async _createNodeAsync(I,O){if(!this._shouldExportNode(I))return null;const C={};if(I.name&&(C.name=I.name),I.metadata){const O=this._options.metadataSelector(I.metadata);O&&(C.extras=O)}if(I instanceof Q.d&&(this._setNodeTransformation(C,I,O.convertToRightHanded),I instanceof s.e)){const K=I instanceof Z.e?I.sourceMesh:I;if(K.ZS&&K.ZS.length>0&&(C.mesh=await this._exportMeshAsync(K,O)),I.skeleton){const O=this._skinMap.get(I.skeleton);var j;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(j=this._nodesSkinMap.get(O))||void 0===j||j.push(C)}}if(I instanceof w.d){const j=this._camerasMap.get(I);if(j){var K;void 0===this._nodesCameraMap.get(j)&&this._nodesCameraMap.set(j,[]),this._setCameraTransformation(C,I,O.convertToRightHanded);const y=I.parent;if(null!==y&&OI(I,y)){const I=this._nodeMap.get(y);if(void 0!==I){var i;const O=this._nodes[I];return II(C,O),null===(i=this._nodesCameraMap.get(j))||void 0===i||i.push(O),null}}null===(K=this._nodesCameraMap.get(j))||void 0===K||K.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,I,this._nodeMap,O.convertToRightHanded)?C:(d.c.Warn(`Not exporting node ${I.name}`),null)}_exportIndices(I,O,C,j,K,y,S,U,p){let N=I;p.mode=v(y);const Q=S!==i.e.CounterClockWiseSideOrientation,s=!U.wasAddedByNoopNode&&Q,Z=function(I){switch(I){case i.e.TriangleFillMode:case i.e.TriangleStripDrawMode:case i.e.TriangleFanDrawMode:return!0}return!1}(y)&&s;if(Z){if(y===i.e.TriangleStripDrawMode||y===i.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");p.mode=v(y);const S=O?new Uint32Array(j):new Uint16Array(j);if(I)for(let O=0;O+2<j;O+=3)S[O]=I[C+O]+K,S[O+1]=I[C+O+2]+K,S[O+2]=I[C+O+1]+K;else for(let I=0;I+2<j;I+=3)S[I]=I,S[I+1]=I+2,S[I+2]=I+1;N=S}else if(I&&0!==K){const i=O?new Uint32Array(j):new Uint16Array(j);for(let O=0;O<j;O++)i[O]=I[C+O]+K;N=i}if(N){let i=U.getIndicesAccessor(I,C,j,K,Z);if(void 0===i){const y=function(I,O,C,j){if(I instanceof Uint16Array||I instanceof Uint32Array)return I;if(I instanceof Int32Array)return new Uint32Array(I.buffer,I.byteOffset,I.length);const K=I.slice(O,O+C);return j?new Uint32Array(K):new Uint16Array(K)}(N,0,j,O),S=this._bufferManager.createBufferView(y),p=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(S,"SCALAR",p,j,0)),i=this._accessors.length-1,U.setIndicesAccessor(I,C,j,K,Z,i)}p.indices=i}}_exportVertexBuffer(I,O,C,j,K,i){const y=I.getKind();if(!P(y))return;if(y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let S=K.getVertexAccessor(I,C,j);if(void 0===S){const O=K.convertedToRightHandedBuffers.get(I._buffer)||I._buffer.getData(),i=y===N.e.PositionKind?function(I,O,C,j){const{byteOffset:K,byteStride:i,type:y,normalized:S}=O,U=O.getSize(),p=new Array(U).fill(1/0),N=new Array(U).fill(-1/0);return(0,t.f)(I,K+C*i,i,U,y,j*U,S,(I=>{for(let O=0;O<U;O++)p[O]=Math.min(p[O],I[O]),N[O]=Math.max(N[O],I[O])})),{min:p,max:N}}(O,I,C,j):void 0,U=(y===N.e.MatricesIndicesKind||y===N.e.MatricesIndicesExtraKind)&&I.type===N.e.FLOAT,p=U?N.e.UNSIGNED_BYTE:I.type,Q=U?void 0:I.normalized,s=U?K.getRemappedBufferView(I._buffer,I):K.getVertexBufferView(I._buffer),Z=I.byteOffset+C*I.byteStride;this._accessors.push(this._bufferManager.createAccessor(s,function(I,O){if(I==N.e.ColorKind)return O?"VEC4":"VEC3";switch(I){case N.e.PositionKind:case N.e.NormalKind:return"VEC3";case N.e.TangentKind:case N.e.MatricesIndicesKind:case N.e.MatricesIndicesExtraKind:case N.e.MatricesWeightsKind:case N.e.MatricesWeightsExtraKind:return"VEC4";case N.e.UVKind:case N.e.UV2Kind:case N.e.UV3Kind:case N.e.UV4Kind:case N.e.UV5Kind:case N.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${I}`)}(y,K.hasVertexColorAlpha(I)),p,j,Z,i,Q)),S=this._accessors.length-1,K.setVertexAccessor(I,C,j,S)}i.attributes[function(I){switch(I){case N.e.PositionKind:return"POSITION";case N.e.NormalKind:return"NORMAL";case N.e.TangentKind:return"TANGENT";case N.e.ColorKind:return"COLOR_0";case N.e.UVKind:return"TEXCOORD_0";case N.e.UV2Kind:return"TEXCOORD_1";case N.e.UV3Kind:return"TEXCOORD_2";case N.e.UV4Kind:return"TEXCOORD_3";case N.e.UV5Kind:return"TEXCOORD_4";case N.e.UV6Kind:return"TEXCOORD_5";case N.e.MatricesIndicesKind:return"JOINTS_0";case N.e.MatricesIndicesExtraKind:return"JOINTS_1";case N.e.MatricesWeightsKind:return"WEIGHTS_0";case N.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${I}`)}(y)]=S}async _exportMaterialAsync(I,O,C,j){let K=this._materialMap.get(I);if(void 0===K){const j=O&&Object.keys(O).some((I=>I.startsWith("uv")));if((I=I instanceof ZI.c?I.HS[C.materialIndex]:I)instanceof qI.c)K=await this._materialExporter.exportPBRMaterialAsync(I,"image/png",j);else{if(!(I instanceof mO.rO))return void d.c.Warn(`Unsupported material '${I.name}' with type ${I.getClassName()}`);K=await this._materialExporter.exportStandardMaterialAsync(I,"image/png",j)}this._materialMap.set(I,K)}j.material=K}async _exportMeshAsync(I,O){var C;let j=O.getMesh(I);if(void 0!==j)return j;const K={primitives:[]};j=this._meshes.length,this._meshes.push(K),O.setMesh(I,j);const y=I.isUnIndexed?null:I.YS(),S=null===(C=I.WS)||void 0===C?void 0:C.getVertexBuffers(),U=O.getMorphTargetsFromMesh(I),p=I instanceof cI.c,N=I instanceof VI,Q=I.ZS;if(S&&Q&&Q.length>0)for(const q of Q){const C={attributes:{}},j=q.DI()||this._babylonScene.defaultMaterial;if(N){var s,Z;const O={name:j.name},K=I,i=E.WO.White(),y=(null===(s=K.material)||void 0===s?void 0:s.alpha)??1,S=(null===(Z=K.greasedLineMaterial)||void 0===Z?void 0:Z.color)??i;(!S.equalsWithEpsilon(i,g.d)||y<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...S.qS(),y]}),this._materials.push(O),C.material=this._materials.length-1}else if(p){const O={name:j.name},K=I;(!K.color.equalsWithEpsilon(E.WO.White(),g.d)||K.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...K.color.qS(),K.alpha]}),this._materials.push(O),C.material=this._materials.length-1}else await this._exportMaterialAsync(j,S,q,C);const Q=p||N?i.e.LineListDrawMode:I.overrideRenderingFillMode??j.fillMode,mI=j._getEffectiveOrientation(I);this._exportIndices(y,y?(0,t.b)(y,q.indexCount,q.indexStart,q.verticesStart):q.verticesCount>65535,y?q.indexStart:q.verticesStart,y?q.indexCount:q.verticesCount,-q.verticesStart,Q,mI,O,C);for(const I of Object.values(S))this._exportVertexBuffer(I,j,q.verticesStart,q.verticesCount,O,C);if(U){C.targets=[];for(const I of U)C.targets.push(I.attributes)}K.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(U){K.weights=[],K.extras||(K.extras={}),K.extras.targetNames=[];for(const I of U)K.weights.push(I.influence),K.extras.targetNames.push(I.name)}return j}}LI._ExtensionNames=new Array,LI._ExtensionFactories={};class zI{static async GLTFAsync(I,O,C){C&&C.exportWithoutWaitingForScene||await I.whenReadyAsync();const j=new LI(I,C),K=await j.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return j.dispose(),K}static async GLBAsync(I,O,C){C&&C.exportWithoutWaitingForScene||await I.whenReadyAsync();const j=new LI(I,C),K=await j.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return j.dispose(),K}}C(12797);const kI="EXT_mesh_gpu_instancing";class AI{constructor(I){this.name=kI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(I,O,C,K,i,y){return await new Promise((I=>{if(O&&C instanceof rI.c&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const I=j.mC.Zero(),K=j.Quaternion.Identity(),S=j.mC.One(),U=C.thinInstanceGetWorldMatrices(),p=j.TmpVectors.mC[2],N=j.TmpVectors.Quaternion[1],Q=j.TmpVectors.mC[3];let s=!1,Z=!1,q=!1;const mI=new Float32Array(3*C.bS),E=new Float32Array(4*C.bS),h=new Float32Array(3*C.bS);let r=0;for(const O of U)O.decompose(Q,N,p),i&&(F(p),R(N)),mI.set(p.qS(),3*r),E.set(N.normalize().qS(),4*r),h.set(Q.qS(),3*r),s=s||!p.equalsWithEpsilon(I),Z=Z||!N.equalsWithEpsilon(K),q=q||!Q.equalsWithEpsilon(S),r++;const W={attributes:{}};s&&(W.attributes.TRANSLATION=this._buildAccessor(mI,"VEC3",C.bS,y)),Z&&(W.attributes.ROTATION=this._buildAccessor(E,"VEC4",C.bS,y)),q&&(W.attributes.SCALE=this._buildAccessor(h,"VEC3",C.bS,y)),O.extensions=O.extensions||{},O.extensions[kI]=W}I(O)}))}_buildAccessor(I,O,C,j){const K=j.createBufferView(I),i=j.createAccessor(K,O,5126,C);return this._exporter._accessors.push(i),this._exporter._accessors.length-1}}LI.RegisterExtension(kI,(I=>new AI(I)));var PI=C(12805),vI=C(12816),BI=C(12819),FI=C(12824);function RI(I){return I===BI.d.PositionKind?"POSITION":I===BI.d.NormalKind?"NORMAL":I===BI.d.ColorKind?"COLOR":I.startsWith(BI.d.UVKind)?"TEX_COORD":"GENERIC"}const GI={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class IO extends PI.d{static get DefaultAvailable(){return(0,PI.g)(IO.DefaultConfiguration)}static get Default(){return IO._Default??(IO._Default=new IO),IO._Default}static ResetDefault(I){IO._Default&&(I||IO._Default.dispose(),IO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(I,O){return{module:await(O||DracoEncoderModule)({wasmBinary:I})}}_getWorkerContent(){return`${vI.h}(${vI.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:IO.DefaultConfiguration)}async _encodeAsync(I,O,C){const j=C?(0,FI.e)(GI,C):GI;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((K,i)=>{C.push(((C,y)=>{const S=I=>{C.removeEventListener("error",S),C.removeEventListener("message",U),i(I),y()},U=I=>{"encodeMeshDone"===I.data.id&&(C.removeEventListener("error",S),C.removeEventListener("message",U),K(I.data.encodedMeshData),y())};C.addEventListener("error",S),C.addEventListener("message",U);const p=[];for(const O of I)p.push(O.data.buffer);O&&p.push(O.buffer),C.postMessage({id:"encodeMesh",attributes:I,indices:O,options:j},p)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,vI.h)(C.module,I,O,j)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(I,O){if(0==I.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");I instanceof rI.c&&I.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(d.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const C=function(I){let O=I.YS(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,t.b)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(I),j=function(I,O){const C=[];for(const j of I.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(j)){if(j===BI.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const K=I.getVertexBuffer(j),i=K.getSize(),y=(0,t.p)(K.getData(),i,K.type,K.byteOffset,K.byteStride,K.normalized,I.getTotalVertices(),!0);C.push({kind:j,dracoName:RI(j),size:i,data:y})}return C}(I,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(j,C,O)}}IO.DefaultConfiguration={wasmUrl:`${K.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${K.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${K.Tools._DefaultCdnUrl}/draco_encoder.js`},IO._Default=null;const OO="KHR_draco_mesh_compression";class CO{get wasUsed(){return this._wasUsed}constructor(I){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===I.options.meshCompressionMethod&&IO.DefaultAvailable}dispose(){}postExportMeshPrimitive(I,O,C){if(!this.enabled)return;if(4!==I.mode&&5!==I.mode)return void d.c.Warn("Cannot compress primitive with mode "+I.mode+".");const j=[],K=[];let i=null;if(void 0!==I.indices){const y=C[I.indices],S=O.getBufferView(y);i=O.getData(S).slice(),j.push(S),K.push(y)}const y=[];for(const[N,Q]of Object.entries(I.attributes)){const I=C[Q],i=O.getBufferView(I),U=A(I.type),p=(0,t.p)(O.getData(i),U,I.componentType,I.byteOffset||0,i.byteStride||(0,t.k)(I.componentType)*U,I.normalized||!1,I.count,!0);y.push({kind:N,dracoName:(S=N,"POSITION"===S?"POSITION":"NORMAL"===S?"NORMAL":S.startsWith("COLOR")?"COLOR":S.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:A(I.type),data:p}),j.push(i),K.push(I)}var S;const U={method:I.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},p=IO.Default._encodeAsync(y,i,U).then((C=>{if(!C)return void d.c.Error("Draco encoding failed for primitive.");const i={bufferView:-1,attributes:C.attributeIds},y=O.createBufferView(C.data);O.setBufferView(i,y);for(const I of j)this._bufferViewsUsed.add(I);for(const I of K)this._accessorsUsed.add(I);I.extensions||(I.extensions={}),I.extensions[OO]=i})).catch((I=>{d.c.Error("Draco encoding failed for primitive: "+I)}));this._encodePromises.push(p),this._wasUsed=!0}async preGenerateBinaryAsync(I){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{I.getPropertiesWithBufferView(O).every((I=>this._accessorsUsed.has(I)))&&I.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}LI.RegisterExtension(OO,(I=>new CO(I)));var jO=C(12833);const KO="KHR_lights_punctual",iO={name:"",color:[1,1,1],aS:1,range:Number.MAX_VALUE},yO={innerConeAngle:0,outerConeAngle:Math.PI/4},SO=j.mC.Backward();class UO{constructor(I){this.name=KO,this.enabled=!0,this.required=!1,this._exporter=I}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[KO]=this._lights}async postExportNodeAsync(I,O,C,K,i){return await new Promise((y=>{if(!(C instanceof WI.d))return void y(O);const S=C.getTypeID()==WI.d.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==WI.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==WI.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!S||!(C instanceof jO.d))return d.c.Warn(`${I}: Light ${C.name} is not supported in ${KO}`),void y(O);if(C.falloffType!==WI.d.FALLOFF_GLTF&&d.c.Warn(`${I}: Light falloff for ${C.name} does not match the ${KO} specification!`),!C.position.equalsToFloats(0,0,0)){const I=j.TmpVectors.mC[0].K(C.position);i&&F(I),O.translation=I.qS()}if("point"!==S){const I=C.direction.normalizeToRef(j.TmpVectors.mC[0]);i&&F(I);const K=j.Quaternion.FromUnitVectorsToRef(SO,I,j.TmpVectors.Quaternion[0]);j.Quaternion.IsIdentity(K)||(O.rotation=K.qS())}const U={type:S,name:C.name,color:C.MS.qS(),aS:C.aS,range:C.range};if(jI(U,iO),"spot"===S){const I=C;U.spot={innerConeAngle:I.innerAngle/2,outerConeAngle:I.angle/2},jI(U.spot,yO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(U);const p={CS:this._lights.lights.length-1},N=C.parent;if(N&&OI(C,N)){const I=K.get(N);if(I){const C=this._exporter._nodes[I];return II(O,C),C.extensions||(C.extensions={}),C.extensions[KO]=p,void y(null)}}O.extensions||(O.extensions={}),O.extensions[KO]=p,y(O)}))}}LI.RegisterExtension(KO,(I=>new UO(I)));var pO=C(12741);const NO="KHR_materials_anisotropy";class QO{constructor(I){this.name=NO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof pO.b&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&j.push(C.anisotropy.texture),j):[]}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof pO.b){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void I(O);this._wasUsed=!0,O.extensions=O.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),K={anisotropyStrength:C.anisotropy.aS,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:j??void 0};null!==K.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),O.extensions[NO]=K}I(O)}))}}LI.RegisterExtension(NO,(I=>new QO(I)));const sO="KHR_materials_clearcoat";class ZO{constructor(I){this.name=sO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof pO.b&&C.clearCoat.isEnabled?(C.clearCoat.texture&&j.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&j.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&j.push(C.clearCoat.bumpTexture),j):[]}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof pO.b){if(!C.clearCoat.isEnabled)return void I(O);this._wasUsed=!0,O.extensions=O.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let i;i=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&K.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&K.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const y=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),S={clearcoatFactor:C.clearCoat.aS,clearcoatTexture:j??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:i??void 0,clearcoatNormalTexture:y??void 0};null===S.clearcoatTexture&&null===S.clearcoatRoughnessTexture&&null===S.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),O.extensions[sO]=S}I(O)}))}}LI.RegisterExtension(sO,(I=>new ZO(I)));const qO="KHR_materials_diffuse_transmission";function mC(I,O){const C=O.subSurface;let j=null;return C.translucencyIntensityTexture?j=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(j=C.thicknessTexture),j&&!C.useGltfStyleTextures?(d.c.Warn(`${I}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):j}class EO{constructor(I){this.name=qO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];if(C instanceof qI.c&&this._isExtensionEnabled(C)){const O=mC(I,C);return O&&j.push(O),C.subSurface.translucencyColorTexture&&j.push(C.subSurface.translucencyColorTexture),j}return j}_isExtensionEnabled(I){if(I.unlit)return!1;const O=I.subSurface;return!!O.isTranslucencyEnabled&&(!I.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(I,O,C){return new Promise((j=>{if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const j=C.subSurface,K=mC(I,C),i=0==j.translucencyIntensity?void 0:j.translucencyIntensity,y=this._exporter._materialExporter.getTextureInfo(K)??void 0,S=!j.translucencyColor||j.translucencyColor.equalsFloats(1,1,1)?void 0:j.translucencyColor.qS(),U=this._exporter._materialExporter.getTextureInfo(j.translucencyColorTexture)??void 0,p={diffuseTransmissionFactor:i,diffuseTransmissionTexture:y,diffuseTransmissionColorFactor:S,diffuseTransmissionColorTexture:U};(y||U)&&this._exporter._materialNeedsUVsSet.add(C),O.extensions=O.extensions||{},O.extensions[qO]=p}j(O)}))}}LI.RegisterExtension(qO,(I=>new EO(I)));const hO="KHR_materials_dispersion";class rO{constructor(){this.name=hO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){if(I.unlit)return!1;const O=I.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const I={dispersion:C.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[hO]=I}I(O)}))}}LI.RegisterExtension(hO,(()=>new rO));const WO="KHR_materials_emissive_strength";class YO{constructor(){this.name=WO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(I,O,C){return await new Promise((I=>{if(!(C instanceof qI.c))return I(O);const j=C.emissiveColor.qS(),K=Math.max(...j);if(K>1){this._wasUsed=!0,O.extensions||(O.extensions={});const I={emissiveStrength:K},j=C.emissiveColor.scale(1/I.emissiveStrength);O.emissiveFactor=j.qS(),O.extensions[WO]=I}return I(O)}))}}LI.RegisterExtension(WO,(I=>new YO));const oO="KHR_materials_ior";class cO{constructor(){this.name=oO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.indexOfRefraction&&1.5!=I.indexOfRefraction)}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const I={ior:C.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[oO]=I}I(O)}))}}LI.RegisterExtension(oO,(I=>new cO));const nO="KHR_materials_iridescence";class XO{constructor(I){this.name=nO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof pO.b&&C.iridescence.isEnabled?(C.iridescence.texture&&j.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&j.push(C.iridescence.thicknessTexture),j):[]}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof pO.b){if(!C.iridescence.isEnabled)return void I(O);this._wasUsed=!0,O.extensions=O.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),K=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),i={iridescenceFactor:C.iridescence.aS,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:j??void 0,iridescenceThicknessTexture:K??void 0};null===i.iridescenceTexture&&null===i.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),O.extensions[nO]=i}I(O)}))}}LI.RegisterExtension(nO,(I=>new XO(I)));const TO="KHR_materials_sheen";class HO{constructor(I){this.name=TO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){return C instanceof qI.c&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(I,O,C){return await new Promise((I=>{if(C instanceof qI.c){if(!C.sheen.isEnabled)return void I(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const j={sheenColorFactor:C.sheen.color.qS(),sheenRoughnessFactor:C.sheen.roughness??0};null===j.sheenColorTexture&&null===j.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(j.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(j.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),O.extensions[TO]=j}I(O)}))}}LI.RegisterExtension(TO,(I=>new HO(I)));const bO="KHR_materials_specular";class aO{constructor(I){this.name=bO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof qI.c&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&j.push(C.metallicReflectanceTexture),C.reflectanceTexture&&j.push(C.reflectanceTexture),j):j}_isExtensionEnabled(I){return!I.unlit&&(void 0!=I.metallicF0Factor&&1!=I.metallicF0Factor||void 0!=I.metallicReflectanceColor&&!I.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.metallicReflectanceTexture||null!=I.reflectanceTexture}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0,O.extensions=O.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,j=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,K={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:I,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.qS(),specularColorTexture:j};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),O.extensions[bO]=K}I(O)}))}}LI.RegisterExtension(bO,(I=>new aO(I)));const MO="KHR_materials_transmission";class uO{constructor(I){this.name=MO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof qI.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&j.push(C.subSurface.thicknessTexture),j):j}_isExtensionEnabled(I){if(I.unlit)return!1;const O=I.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(I)}_hasTexturesExtension(I){return null!=I.subSurface.refractionIntensityTexture}async postExportMaterialAsync(I,O,C){if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const j=C.subSurface,K={transmissionFactor:0===j.refractionIntensity?void 0:j.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),j.refractionIntensityTexture)if(j.useGltfStyleTextures){const I=await this._exporter._materialExporter.exportTextureAsync(j.refractionIntensityTexture,"image/png");I&&(K.transmissionTexture=I)}else d.c.Warn(`${I}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[MO]=K}return O}}LI.RegisterExtension(MO,(I=>new uO(I)));const JO="KHR_materials_unlit";class fO{constructor(){this.name=JO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(I,O,C){return new Promise((I=>{let j=!1;C instanceof qI.c?j=C.unlit:C instanceof mO.rO&&(j=C.disableLighting),j&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[JO]={}),I(O)}))}}LI.RegisterExtension(JO,(()=>new fO));const lO="KHR_materials_volume";class xO{constructor(I){this.name=lO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof qI.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&j.push(C.subSurface.thicknessTexture),j):j}_isExtensionEnabled(I){if(I.unlit)return!1;const O=I.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=E.WO.White()||this._hasTexturesExtension(I))}_hasTexturesExtension(I){return null!=I.subSurface.thicknessTexture}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof qI.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const I=C.subSurface,j={thicknessFactor:0==I.maximumThickness?void 0:I.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(I.thicknessTexture)??void 0,attenuationDistance:I.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:I.tintColorAtDistance,attenuationColor:I.tintColor.equalsFloats(1,1,1)?void 0:I.tintColor.qS()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),O.extensions=O.extensions||{},O.extensions[lO]=j}I(O)}))}}LI.RegisterExtension(lO,(I=>new xO(I)));const DO="EXT_materials_diffuse_roughness";class tO{constructor(I){this.name=DO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=I}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(I,O,C){const j=[];return C instanceof pO.b&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&j.push(C._baseDiffuseRoughnessTexture),j):[]}postExportMaterialAsync(I,O,C){return new Promise((I=>{if(C instanceof pO.b){if(!C._baseDiffuseRoughness)return void I(O);this._wasUsed=!0,O.extensions=O.extensions||{};const j=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),K={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:j??void 0};null!==K.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),O.extensions[DO]=K}I(O)}))}}LI.RegisterExtension(DO,(I=>new tO(I)));const dO="KHR_texture_transform";class wO{constructor(){this.name=dO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(I,O,C){if(C.nI()||K.Tools.Warn(`${I}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(K.Tools.Warn(`${I}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const j={};let i=!1;if(0===C.uOffset&&0===C.vOffset||(j.offset=[C.uOffset,C.vOffset],i=!0),1===C.uScale&&1===C.vScale||(j.scale=[C.uScale,C.vScale],i=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void K.Tools.Warn(`${I}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${dO}.`);K.Tools.Warn(`${I}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${dO}.`),j.offset=function(I){const{uOffset:O,vOffset:C,uRotationCenter:j,vRotationCenter:K,uScale:i,vScale:y,wAng:S}=I,U=Math.cos(S),p=Math.sin(S),N=j*i,Q=K*y;return[O+(N*(1-U)+Q*p),C+(Q*(1-U)-N*p)]}(C)}j.rotation=-C.wAng,i=!0}0!==C.coordinatesIndex&&(j.texCoord=C.coordinatesIndex,i=!0),i&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[dO]=j)}}LI.RegisterExtension(dO,(()=>new wO));class gO{static CreateSTL(I){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",K=arguments.length>3&&void 0!==arguments[3]&&arguments[3],i=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],S=arguments.length>6&&void 0!==arguments[6]&&arguments[6],U=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const p=function(I,O,C){const K=[3*I[C],3*I[C+1],3*I[C+2]],i=[new j.mC(O[K[0]],O[K[0]+2],O[K[0]+1]),new j.mC(O[K[1]],O[K[1]+2],O[K[1]+1]),new j.mC(O[K[2]],O[K[2]+2],O[K[2]+1])],y=i[0].EO(i[1]),S=i[2].EO(i[1]);return{v:i,n:j.mC.Cross(S,y).normalize()}},Q=function(I,O,C,j){return O=s(I,O,C.x,j),O=s(I,O,C.y,j),s(I,O,C.z,j)},s=function(I,O,C,j){return I.setFloat32(O,C,j),O+4},q=function(I){if(S){let O=I;I instanceof Z.e&&(O=I.sourceMesh);const C=O.getVerticesData(N.e.PositionKind,!0,!0);if(!C)return[];const K=j.mC.Zero();let i;for(i=0;i<C.length;i+=3)j.mC.TransformCoordinatesFromFloatsToRef(C[i],C[i+1],C[i+2],I.rS(!0),K).toArray(C,i);return C}return I.getVerticesData(N.e.PositionKind)||[]};S&&(y=!0);let mI="",E=0,h=0;if(K){for(let C=0;C<I.length;C++){const O=I[C].YS();E+=O?O.length/3:0}const O=new ArrayBuffer(84+50*E);mI=new DataView(O),h+=80,mI.setUint32(h,E,i),h+=4}else U||(mI="solid stlmesh\r\n");for(let j=0;j<I.length;j++){const O=I[j];!K&&U&&(mI+="solid "+O.name+"\r\n"),!y&&O instanceof rI.c&&O.bakeCurrentTransformIntoVertices();const C=q(O),S=O.YS()||[];for(let I=0;I<S.length;I+=3){const O=p(S,C,I);K?(h=Q(mI,h,O.n,i),h=Q(mI,h,O.v[0],i),h=Q(mI,h,O.v[1],i),h=Q(mI,h,O.v[2],i),h+=2):(mI+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",mI+="\t\touter loop\r\n",mI+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",mI+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",mI+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",mI+="\t\tendloop\r\n",mI+="\tendfacet\r\n")}!K&&U&&(mI+="endsolid "+name+"\r\n")}if(K||U||(mI+="endsolid stlmesh"),O){const I=document.createElement("a"),O=new Blob([mI],{type:"application/octet-stream"});I.href=window.URL.createObjectURL(O),I.download=C+".stl",I.click()}return mI}}function VO(I,O){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const j=[];for(let K=0;K<I.length/C;K++){const i=I[K*C],y=I[K*C+1],S=I[K*C+2];j.push(`(${i.toPrecision(O.precision)}, ${y.toPrecision(O.precision)}, ${S.toPrecision(O.precision)})`)}return j.join(", ")}function eO(I,O){const C=[];for(let j=0;j<I.length/2;j++){const K=I[2*j],i=I[2*j+1];C.push(`(${K.toPrecision(O.precision)}, ${(1-i).toPrecision(O.precision)})`)}return C.join(", ")}function LO(I,O){const C=I.getVerticesData(N.e.PositionKind),j=I.getVerticesData(N.e.NormalKind);if(C&&j)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(I){var O;const C=null!==(O=I.YS())&&void 0!==O&&O.length?I.getTotalIndices():I.getTotalVertices();return Array(C/3).fill(3).join(", ")}(I)}]\n\t\tint[] faceVertexIndices = [${function(I){const O=I.YS(),C=[];if(null!==O)for(let j=0;j<O.length;j++)C.push(O[j]);else{const O=I.getTotalVertices();for(let I=0;I<O;I++)C.push(I)}return C.join(", ")}(I)}]\n\t\tnormal3f[] normals = [${VO(j,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${VO(C,O)}]\n        ${function(I,O){let C="";for(let K=0;K<4;K++){const j=K>0?K:"",i=I.getVerticesData(N.e.UVKind+(j?j+1:""));i&&(C+=`\n\t\ttexCoord2f[] primvars:st${j} = [${eO(i,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const j=I.getVerticesData(N.e.ColorKind);return j&&(C+=`\n\tcolor3f[] primvars:displayColor = [${VO(j,O,j.length/I.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(I,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function zO(I,O){return`\n        def "Geometry"\n        {\n        ${LO(I,O)}\n        }\n        `}function kO(I){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=I,fflate.strToU8(O)}function AO(I){const O=I.m;return`( ${PO(O,0)}, ${PO(O,4)}, ${PO(O,8)}, ${PO(O,12)} )`}function PO(I,O){return`(${I[O+0]}, ${I[O+1]}, ${I[O+2]}, ${I[O+3]})`}function vO(I){const O="Object_"+I.uniqueId,C=function(I){const O=I.getWorldMatrix().clone(),C=I.nI().useRightHandedSystem;if(!C){let j=I.parent;for(;j;){if(yI(j,C)){O.multiplyToRef(j.getWorldMatrix().invert(),O);break}j=j.parent}}return O.determinant()<0&&K.Tools.Warn(`Exporting mesh ${I.name} with negative scale. Result may look incorrect in destination engine.`),O}(I),j=AO(C);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${I.WS.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${j}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${I.material.uniqueId}>\n}\n\n`}function BO(I){switch(I){case n.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case n.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case n.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function FO(I){return`(${I.x}, ${I.y})`}function RO(I){return`(${I.r}, ${I.g}, ${I.b})`}function GO(I,O,C,K,i,y){const S=I.getInternalTexture().uniqueId+"_"+I.invertY;i[S]=I;const U=I.coordinatesIndex>0?"st"+I.coordinatesIndex:"st",p=new j.Vector2(I.uScale,I.vScale),N=new j.Vector2(I.uOffset,I.vOffset),Q=I.wAng,s=Math.sin(Q),Z=Math.cos(Q);return N.y=1-N.y-p.y,N.x+=s*p.x,N.y+=(1-Z)*p.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${U}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(Q*(180/Math.PI)).toFixed(y.precision)}\n        float2 inputs:scale = ${FO(p)}\n        float2 inputs:translation = ${FO(N)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${I.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${S}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${C}.outputs:result>\n        ${K?"float4 inputs:scale = "+function(I){return`(${I.r}, ${I.g}, ${I.b}, 1.0)`}(K):""}\n        token inputs:sourceColorSpace = "${I.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${BO(I.wrapU)}"\n        token inputs:wrapT = "${BO(I.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function IC(I,O,C){const j="\t\t\t",K=[],i=[],{diffuseMap:y,MS:S,alphaCutOff:U,emissiveMap:p,emissive:N,normalMap:Q,roughnessMap:s,roughnessChannel:Z,roughness:q,metalnessMap:mI,metalnessChannel:h,metalness:r,aoMap:W,aoMapChannel:Y,aoMapIntensity:o,alphaMap:c,ior:n,clearCoatEnabled:X,clearCoat:T,clearCoatMap:H,clearCoatRoughness:b,clearCoatRoughnessMap:a}=function(I){const O={diffuseMap:null,MS:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return I instanceof mO.rO?{...O,diffuseMap:I.diffuseTexture,MS:I.diffuseColor,alphaCutOff:I.alphaCutOff,emissiveMap:I.emissiveTexture,emissive:I.emissiveColor,roughness:1,alphaMap:I.opacityTexture}:I instanceof pO.b?{...O,diffuseMap:I._albedoTexture,MS:I._albedoColor,alphaCutOff:I._alphaCutOff,emissiveMap:I._emissiveTexture,emissive:I._emissiveColor,normalMap:I._bumpTexture,roughnessMap:I._metallicTexture,roughnessChannel:I._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:I._roughness??1,metalnessMap:I._metallicTexture,metalnessChannel:I._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:I._metallic??0,aoMap:I._ambientTexture,aoMapChannel:I._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:I._ambientTextureStrength,alphaMap:I._opacityTexture,ior:I.subSurface.indexOfRefraction,clearCoatEnabled:I.clearCoat.isEnabled,clearCoat:I.clearCoat.aS,clearCoatMap:I.clearCoat.texture,clearCoatRoughness:I.clearCoat.roughness,clearCoatRoughnessMap:I.clearCoat.useRoughnessFromMainTexture?I.clearCoat.texture:I.clearCoat.textureRoughness}:O}(I);return null!==y?(K.push(`${j}color3f inputs:diffuseColor.connect = </Materials/Material_${I.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:rgb>`),I.needAlphaBlending()?K.push(`${j}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`):I.needAlphaTesting()&&(K.push(`${j}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`),K.push(`${j}float inputs:opacityThreshold = ${U}`)),i.push(GO(y,I,"diffuse",S,O,C))):K.push(`${j}color3f inputs:diffuseColor = ${RO(S||E.WO.White())}`),null!==p?(K.push(`${j}color3f inputs:emissiveColor.connect = </Materials/Material_${I.uniqueId}/Texture_${p.uniqueId}_emissive.outputs:rgb>`),i.push(GO(p,I,"emissive",N,O,C))):N&&N.toLuminance()>0&&K.push(`${j}color3f inputs:emissiveColor = ${RO(N)}`),null!==Q&&(K.push(`${j}normal3f inputs:normal.connect = </Materials/Material_${I.uniqueId}/Texture_${Q.uniqueId}_normal.outputs:rgb>`),i.push(GO(Q,I,"normal",null,O,C))),null!==W&&(K.push(`${j}float inputs:occlusion.connect = </Materials/Material_${I.uniqueId}/Texture_${W.uniqueId}_occlusion.outputs:${Y}>`),i.push(GO(W,I,"occlusion",new E.WO(o,o,o),O,C))),null!==s?(K.push(`${j}float inputs:roughness.connect = </Materials/Material_${I.uniqueId}/Texture_${s.uniqueId}_roughness.outputs:${Z}>`),i.push(GO(s,I,"roughness",new E.WO(q,q,q),O,C))):K.push(`${j}float inputs:roughness = ${q}`),null!==mI?(K.push(`${j}float inputs:metallic.connect = </Materials/Material_${I.uniqueId}/Texture_${mI.uniqueId}_metallic.outputs:${h}>`),i.push(GO(mI,I,"metallic",new E.WO(r,r,r),O,C))):K.push(`${j}float inputs:metallic = ${r}`),null!==c?(K.push(`${j}float inputs:opacity.connect = </Materials/Material_${I.uniqueId}/Texture_${c.uniqueId}_opacity.outputs:r>`),K.push(`${j}float inputs:opacityThreshold = 0.0001`),i.push(GO(c,I,"opacity",null,O,C))):K.push(`${j}float inputs:opacity = ${I.alpha}`),X&&(null!==H?(K.push(`${j}float inputs:clearcoat.connect = </Materials/Material_${I.uniqueId}/Texture_${H.uniqueId}_clearcoat.outputs:r>`),i.push(GO(H,I,"clearcoat",new E.WO(T,T,T),O,C))):K.push(`${j}float inputs:clearcoat = ${T}`),null!==a?(K.push(`${j}float inputs:clearcoatRoughness.connect = </Materials/Material_${I.uniqueId}/Texture_${a.uniqueId}_clearcoatRoughness.outputs:g>`),i.push(GO(a,I,"clearcoatRoughness",new E.WO(b,b,b),O,C))):K.push(`${j}float inputs:clearcoatRoughness = ${b}`)),K.push(`${j}float inputs:ior = ${n}`),`\n\tdef Material "Material_${I.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${K.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${I.uniqueId}/PreviewSurface.outputs:surface>\n\n${i.join("\n")}\n\n\t}\n`}async function OC(I,O,C){const i={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await K.Tools.LoadScriptAsync(i.fflateUrl);const y={};y[i.modelFileName]=null;let S='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';S+=function(I){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===I.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${I.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${I.planeAnchoringAlignment}"`:""}\n            `}(i);const U={};for(const j of I.meshes){if(0===j.getTotalVertices())continue;const I=j,O=I.WS,p=I.material;if(!p||!O||C&&!C(I))continue;if(-1!==["rO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(p.getClassName())){const C="geometries/Geometry_"+O.uniqueId+".usda";if(!(C in y)){const I=zO(O,i);y[C]=kO(I)}p.uniqueId in U||(U[p.uniqueId]=p),S+=vO(I)}else K.Tools.Warn("USDZExportAsync does not support this material type: "+p.getClassName())}I.activeCamera&&i.exportCamera&&(S+=function(I,O){const C="Camera_"+I.uniqueId,K=AO(j.Matrix.RotationY(Math.PI).multiply(I.getWorldMatrix()));if(I.mode===n.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${K}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.ES.toPrecision(O.precision)}, ${I.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(I.orthoLeft||1)+Math.abs(I.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(I.orthoTop||1)+Math.abs(I.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const j=I.getEngine().getAspectRatio(I),i=O.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${K}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${I.ES.toPrecision(O.precision)}, ${I.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(i/(2*Math.tan(.5*I.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(i*j).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(i/j).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(I.activeCamera,i)),S+="\n            }\n        }\n    }";const p={};S+=function(I,O,C){const j=[];for(const K in I){const i=I[K];j.push(IC(i,O,C))}return`\n    def "Materials"\n{\n${j.join("")}\n}\n\n`}(U,p,i),y[i.modelFileName]=fflate.strToU8(S);for(const j in p){const I=p[j],O=I.getSize(),C=await I.readPixels();if(!C)throw new Error("Texture data is not available");const K=await X.DumpTools.DumpDataAsync(O.width,O.height,C,"image/png",void 0,!1,!0);y[`textures/Texture_${j}.png`]=new Uint8Array(K).slice()}let N=0;for(const j in y){const I=y[j];if(!I)continue;N+=34+j.length;const O=63&N;if(4!==O){const C=new Uint8Array(64-O);y[j]=[I,{extra:{12345:C}}]}N=I.length}return fflate.zipSync(y,{level:0})}}}]);