"use strict";(self.fjf2z1c8il8=self.fjf2z1c8il8||[]).push([[26],{12874:(g,i,a)=>{a.r(i),a.d(i,{EXT_materials_diffuse_roughness:()=>ti,EXT_mesh_gpu_instancing:()=>ug,GLTF2Export:()=>Qg,GLTFData:()=>N,KHR_draco_mesh_compression:()=>ai,KHR_lights_punctual:()=>ei,KHR_materials_anisotropy:()=>Ii,KHR_materials_clearcoat:()=>yi,KHR_materials_diffuse_transmission:()=>Di,KHR_materials_dispersion:()=>Ri,KHR_materials_emissive_strength:()=>Ei,KHR_materials_ior:()=>vi,KHR_materials_iridescence:()=>Yi,KHR_materials_sheen:()=>Ci,KHR_materials_specular:()=>Si,KHR_materials_transmission:()=>Ki,KHR_materials_unlit:()=>li,KHR_materials_volume:()=>hi,KHR_texture_transform:()=>Oi,OBJExport:()=>b,STLExport:()=>zi,USDZExportAsync:()=>ia,_ConvertToGLTFPBRMetallicRoughness:()=>T,_SolveMetallic:()=>K,__IGLTFExporterExtension:()=>k});var n=a(12452),L=a(12277),d=a(12778);class b{static OBJ(g,i,a,b){const k=[];let e=1,N=1;i&&(a||(a="mat"),k.push("mtllib "+a+".mtl"));for(let F=0;F<g.length;F++){const a=g[F],I=a.name||`mesh${F}}`;k.push(`o ${I}`);let j=null;if(b){const g=a.Zd(!0);j=new n.Matrix,g.invertToRef(j),a.bakeTransformIntoVertices(g)}if(i){const g=a.material;g&&k.push("usemtl "+g.id)}const y=a.wd;if(!y){L.Tools.Warn("No geometry is present on the mesh");continue}const B=y.getVerticesData("position"),c=y.getVerticesData("normal"),D=y.getVerticesData("uv"),p=y.Ad();let R=0,x=0;if(!B||!p){L.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const E=g[0].Pg().useRightHandedSystem?1:-1;for(let g=0;g<B.length;g+=3)k.push("v "+B[g]*E+" "+B[g+1]+" "+B[g+2]),R++;if(null!=c)for(let g=0;g<c.length;g+=3)k.push("vn "+c[g]*E+" "+c[g+1]+" "+c[g+2]);if(null!=D)for(let g=0;g<D.length;g+=2)k.push("vt "+D[g]+" "+D[g+1]),x++;const X=["","",""],v=(a.material||a.Pg().defaultMaterial)._getEffectiveOrientation(a),[P,Y]=v===d.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let g=0;g<p.length;g+=3){const i=[String(p[g]+e),String(p[g+P]+e),String(p[g+Y]+e)],a=[String(p[g]+N),String(p[g+P]+N),String(p[g+Y]+N)],n=i,L=null!=D?a:X,d=null!=c?i:X;k.push("f "+n[0]+"/"+L[0]+"/"+d[0]+" "+n[1]+"/"+L[1]+"/"+d[1]+" "+n[2]+"/"+L[2]+"/"+d[2])}b&&j&&a.bakeTransformIntoVertices(j),e+=R,N+=x}return k.join("\n")}static MTL(g){const i=[],a=g.material;i.push("newmtl mat1"),i.push("  Ns "+a.specularPower.toFixed(4)),i.push("  Ni 1.5000"),i.push("  d "+a.alpha.toFixed(4)),i.push("  Tr 0.0000"),i.push("  Tf 1.0000 1.0000 1.0000"),i.push("  illum 2"),i.push("  Ka "+a.ambientColor.r.toFixed(4)+" "+a.ambientColor.g.toFixed(4)+" "+a.ambientColor.b.toFixed(4)),i.push("  Kd "+a.diffuseColor.r.toFixed(4)+" "+a.diffuseColor.g.toFixed(4)+" "+a.diffuseColor.b.toFixed(4)),i.push("  Ks "+a.specularColor.r.toFixed(4)+" "+a.specularColor.g.toFixed(4)+" "+a.specularColor.b.toFixed(4)),i.push("  Ke "+a.emissiveColor.r.toFixed(4)+" "+a.emissiveColor.g.toFixed(4)+" "+a.emissiveColor.b.toFixed(4));a.ambientTexture&&i.push("  map_Ka "+a.ambientTexture.name),a.diffuseTexture&&i.push("  map_Kd "+a.diffuseTexture.name),a.specularTexture&&i.push("  map_Ks "+a.specularTexture.name),a.bumpTexture&&i.push("  map_bump -imfchan z "+a.bumpTexture.name),a.opacityTexture&&i.push("  map_d "+a.opacityTexture.name);return i.join("\n")}}var k=0,e=a(12324);class N{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const g in this.files){const i=this.files[g],a=new Blob([i],{type:(0,e.h)(g)});L.Tools.Download(a,g)}}}var F=a(12526),I=a(12879),j=a(12894),y=a(12906),B=a(12571),c=a(12316),D=a(12496),p=a(12466);const R=p.HighestCommonFactor,x={...p,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:R};var E=a(12684),X=a(12436),v=a(12943),P=a(12950),Y=a(12681);const f=1e-6,C=new D.Ri(.04,.04,.04),U=1024,S=D.Ri.White(),V=D.Ri.Black();function K(g,i,a){if(i<C.r)return 0;const n=C.r,L=g*a/(1-C.r)+i-2*C.r,d=L*L-4*n*(C.r-i);return x.Clamp((-L+Math.sqrt(d))/(2*n),0,1)}function T(g){const i=g.diffuseColor.toLinearSpace(g.Pg().getEngine().useExactSrgbConversions).scale(.5),a=g.alpha,L=function(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new n.Vector2(0,1),a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new n.Vector2(0,.1),L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new n.Vector2(0,.1),d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new n.Vector2(1300,.1);return function(g,i,a,n,L){return(1-g)*(1-g)*(1-g)*i+3*(1-g)*(1-g)*g*a+3*(1-g)*g*g*n+g*g*g*L}(Math.pow(g/d.x,.333333),i.y,a.y,L.y,d.y)}(x.Clamp(g.specularPower,0,U));return{baseColorFactor:[i.r,i.g,i.b,a],metallicFactor:0,roughnessFactor:L}}function l(g,i){i.needAlphaBlending()?g.alphaMode="BLEND":i.needAlphaTesting()&&(g.alphaMode="MASK",g.alphaCutoff=i.alphaCutOff)}function Z(g,i,a){const n=new Uint8Array(g*i*4);for(let L=0;L<n.length;L+=4)n[L]=n[L+1]=n[L+2]=n[L+3]=255;return v.b.CreateRGBATexture(n,g,i,a)}function h(g){if(g instanceof Uint8Array){const i=g.length,a=new Float32Array(g.length);for(let n=0;n<i;++n)a[n]=g[n]/255;return a}if(g instanceof Float32Array)return g;throw new Error("Unsupported pixel format!")}class w{constructor(g){this._exporter=g,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(g){return g?this._textureMap.get(g)??null:null}async exportStandardMaterialAsync(g,i,a){const n=T(g),d={name:g.name};if(null==g.zd||g.zd||(g.twoSidedLighting||L.Tools.Warn(g.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),d.doubleSided=!0),a){const a=[],L=g.diffuseTexture;L&&a.push(this.exportTextureAsync(L,i).then((g=>{g&&(n.baseColorTexture=g)})));const b=g.bumpTexture;b&&a.push(this.exportTextureAsync(b,i).then((g=>{g&&(d.normalTexture=g,1!==b.level&&(d.normalTexture.scale=b.level))})));const k=g.emissiveTexture;k&&(d.emissiveFactor=[1,1,1],a.push(this.exportTextureAsync(k,i).then((g=>{g&&(d.emissiveTexture=g)}))));const e=g.ambientTexture;e&&a.push(this.exportTextureAsync(e,i).then((g=>{if(g){const i={index:g.index};d.occlusionTexture=i}}))),a.length>0&&(this._exporter._materialNeedsUVsSet.add(g),await Promise.all(a))}(g.alpha<1||g.opacityTexture)&&(g.alphaMode===P.b.ALPHA_COMBINE?d.alphaMode="BLEND":L.Tools.Warn(g.name+": glTF 2.0 does not support alpha mode: "+g.alphaMode.toString())),g.emissiveColor&&!g.emissiveColor.equalsWithEpsilon(V,f)&&(d.emissiveFactor=g.emissiveColor.fd()),d.pbrMetallicRoughness=n,l(d,g),await this._finishMaterialAsync(d,g,i);const b=this._exporter._materials;return b.push(d),b.length-1}async _finishMaterialAsync(g,i,a){const n=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",g,i),L=[];for(const d of n)L.push(this.exportTextureAsync(d,a));await Promise.all(L),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",g,i)}async _getImageDataAsync(g,i,n,L){const d=P.b.TEXTURETYPE_UNSIGNED_BYTE,b=this._exporter._babylonScene,k=b.getEngine(),e=k.createRawTexture(g,i,n,P.b.TEXTUREFORMAT_RGBA,!1,!0,X.c.NEAREST_SAMPLINGMODE,null,d);k.isWebGPU?await a.e(51).then(a.bind(a,15018)):await a.e(52).then(a.bind(a,15022)),await E.m.ApplyPostProcess("pass",e,b,d,P.b.TEXTURE_NEAREST_SAMPLINGMODE,P.b.TEXTUREFORMAT_RGBA);const N=await k._readTexturePixels(e,i,n);return await Y.DumpTools.DumpDataAsync(i,n,N,L,void 0,!0,!0)}_resizeTexturesToSameDimensions(g,i,a){const n=g?g.getSize():{width:0,height:0},L=i?i.getSize():{width:0,height:0};let d,b;return n.width<L.width?(d=g&&g instanceof X.c?E.m.CreateResizedCopy(g,L.width,L.height,!0):Z(L.width,L.height,a),b=i):n.width>L.width?(b=i&&i instanceof X.c?E.m.CreateResizedCopy(i,n.width,n.height,!0):Z(n.width,n.height,a),d=g):(d=g,b=i),{texture1:d,texture2:b}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(g,i,a,n){const L=new Array;if(!g&&!i)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const d=g?g.Pg():i?i.Pg():null;if(d){var b;const k=this._resizeTexturesToSameDimensions(g,i,d),e=null===(b=k.texture1)||void 0===b?void 0:b.getSize();let N,F;const I=e.width,j=e.height,y=await k.texture1.readPixels(),B=await k.texture2.readPixels();if(!y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(N=h(y),!B)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");F=h(B);const c=F.byteLength,p=new Uint8Array(c),R=new Uint8Array(c),x=4,E=V;let X=0,v=0;for(let g=0;g<j;++g)for(let i=0;i<I;++i){const n=(I*g+i)*x,L={diffuseColor:new D.Ri(N[n],N[n+1],N[n+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(a.diffuseColor),specularColor:new D.Ri(F[n],F[n+1],F[n+2]).toLinearSpace(d.getEngine().useExactSrgbConversions).multiply(a.specularColor),glossiness:F[n+3]*a.glossiness},b=this._convertSpecularGlossinessToMetallicRoughness(L);E.r=Math.max(E.r,b.baseColor.r),E.g=Math.max(E.g,b.baseColor.g),E.b=Math.max(E.b,b.baseColor.b),X=Math.max(X,b.metallic),v=Math.max(v,b.roughness),R[n]=255*b.baseColor.r,R[n+1]=255*b.baseColor.g,R[n+2]=255*b.baseColor.b,R[n+3]=k.texture1.Ud?255*N[n+3]:255,p[n]=0,p[n+1]=255*b.roughness,p[n+2]=255*b.metallic,p[n+3]=255}const P={baseColor:E,metallic:X,roughness:v};let Y=!1,C=!1;for(let g=0;g<j;++g)for(let i=0;i<I;++i){const a=(I*g+i)*x;R[a]/=P.baseColor.r>f?P.baseColor.r:1,R[a+1]/=P.baseColor.g>f?P.baseColor.g:1,R[a+2]/=P.baseColor.b>f?P.baseColor.b:1;const n=D.Ri.FromInts(R[a],R[a+1],R[a+2]).toGammaSpace(d.getEngine().useExactSrgbConversions);R[a]=255*n.r,R[a+1]=255*n.g,R[a+2]=255*n.b,n.equalsWithEpsilon(S,f)||(C=!0),p[a+1]/=P.roughness>f?P.roughness:1,p[a+2]/=P.metallic>f?P.metallic:1;D.Ri.FromInts(255,p[a+1],p[a+2]).equalsWithEpsilon(S,f)||(Y=!0)}return Y&&L.push(this._getImageDataAsync(p,I,j,n).then((g=>{P.metallicRoughnessTextureData=g}))),C&&L.push(this._getImageDataAsync(R,I,j,n).then((g=>{P.baseColorTextureData=g}))),await Promise.all(L).then((()=>P))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(g){const i=this._getPerceivedBrightness(g.diffuseColor),a=this._getPerceivedBrightness(g.specularColor),n=1-this._getMaxComponent(g.specularColor),L=K(i,a,n),d=g.diffuseColor.scale(n/(1-C.r)/Math.max(1-L)),b=g.specularColor.ci(C.scale(1-L)).scale(1/Math.max(L));let k=D.Ri.Lerp(d,b,L*L);k=k.clampToRef(0,1,k);return{baseColor:k,metallic:L,roughness:1-g.glossiness}}_getPerceivedBrightness(g){return g?Math.sqrt(.299*g.r*g.r+.587*g.g*g.g+.114*g.b*g.b):0}_getMaxComponent(g){return g?Math.max(g.r,Math.max(g.g,g.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(g,i,a,n){const L=[],d={baseColor:g._albedoColor,metallic:g._metallic,roughness:g._roughness};if(n){g._albedoTexture&&L.push(this.exportTextureAsync(g._albedoTexture,i).then((g=>{g&&(a.baseColorTexture=g)})));const n=g._metallicTexture;n&&L.push(this.exportTextureAsync(n,i).then((g=>{g&&(a.metallicRoughnessTexture=g)})))}return L.length>0&&(this._exporter._materialNeedsUVsSet.add(g),await Promise.all(L)),d}_getTextureSampler(g){const i={};if(!g||!(g instanceof X.c))return i;const a=this._getGLTFTextureWrapMode(g.wrapU);10497!==a&&(i.wrapS=a);const n=this._getGLTFTextureWrapMode(g.wrapV);switch(10497!==n&&(i.wrapT=n),g.samplingMode){case X.c.LINEAR_LINEAR:i.magFilter=9729,i.minFilter=9729;break;case X.c.LINEAR_NEAREST:i.magFilter=9729,i.minFilter=9728;break;case X.c.NEAREST_LINEAR:i.magFilter=9728,i.minFilter=9729;break;case X.c.NEAREST_LINEAR_MIPLINEAR:i.magFilter=9728,i.minFilter=9987;break;case X.c.NEAREST_NEAREST:i.magFilter=9728,i.minFilter=9728;break;case X.c.NEAREST_LINEAR_MIPNEAREST:i.magFilter=9728,i.minFilter=9985;break;case X.c.LINEAR_NEAREST_MIPNEAREST:i.magFilter=9729,i.minFilter=9984;break;case X.c.LINEAR_NEAREST_MIPLINEAR:i.magFilter=9729,i.minFilter=9986;break;case X.c.NEAREST_NEAREST_MIPLINEAR:i.magFilter=9728,i.minFilter=9986;break;case X.c.LINEAR_LINEAR_MIPLINEAR:i.magFilter=9729,i.minFilter=9987;break;case X.c.LINEAR_LINEAR_MIPNEAREST:i.magFilter=9729,i.minFilter=9985;break;case X.c.NEAREST_NEAREST_MIPNEAREST:i.magFilter=9728,i.minFilter=9984}return i}_getGLTFTextureWrapMode(g){switch(g){case X.c.WRAP_ADDRESSMODE:return 10497;case X.c.CLAMP_ADDRESSMODE:return 33071;case X.c.MIRROR_ADDRESSMODE:return 33648;default:return L.Tools.Error(`Unsupported Texture Wrap Mode ${g}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(g,i,a,n){const L={diffuseColor:g._albedoColor,specularColor:g._reflectivityColor,glossiness:g._microSurface},d=g._albedoTexture,b=g._reflectivityTexture,k=g._useMicroSurfaceFromReflectivityMapAlpha;if(b&&!k)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((d||b)&&n){this._exporter._materialNeedsUVsSet.add(g);const n=this._exportTextureSampler(d||b),k=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(d,b,L,i),e=this._exporter._textures;if(k.baseColorTextureData){const g=this._exportImage(`baseColor${e.length}`,i,k.baseColorTextureData);a.baseColorTexture=this._exportTextureInfo(g,n,null===d||void 0===d?void 0:d.coordinatesIndex)}if(k.metallicRoughnessTextureData){const g=this._exportImage(`metallicRoughness${e.length}`,i,k.metallicRoughnessTextureData);a.metallicRoughnessTexture=this._exportTextureInfo(g,n,null===b||void 0===b?void 0:b.coordinatesIndex)}return k}return this._convertSpecularGlossinessToMetallicRoughness(L)}async exportPBRMaterialAsync(g,i,a){const n={},L={name:g.name},d=g.isMetallicWorkflow();if(d){const i=g._albedoColor,a=g.alpha;i&&(n.baseColorFactor=[i.r,i.g,i.b,a])}const b=d?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(g,i,n,a):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(g,i,n,a);await this._setMetallicRoughnessPbrMaterialAsync(b,g,L,n,i,a),await this._finishMaterialAsync(L,g,i);const k=this._exporter._materials;return k.push(L),k.length-1}async _setMetallicRoughnessPbrMaterialAsync(g,i,a,n,d,b){if(l(a,i),g.baseColor.equalsWithEpsilon(S,f)&&x.WithinEpsilon(i.alpha,1,f)||(n.baseColorFactor=[g.baseColor.r,g.baseColor.g,g.baseColor.b,i.alpha]),null!=g.metallic&&1!==g.metallic&&(n.metallicFactor=g.metallic),null!=g.roughness&&1!==g.roughness&&(n.roughnessFactor=g.roughness),null==i.zd||i.zd||(i._twoSidedLighting||L.Tools.Warn(i.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),a.doubleSided=!0),b){const g=[],n=i._bumpTexture;n&&g.push(this.exportTextureAsync(n,d).then((g=>{g&&(a.normalTexture=g,1!==n.level&&(a.normalTexture.scale=n.level))})));const L=i._ambientTexture;L&&g.push(this.exportTextureAsync(L,d).then((g=>{if(g){const n={index:g.index,texCoord:g.texCoord,extensions:g.extensions};a.occlusionTexture=n;const L=i._ambientTextureStrength;L&&(n.strength=L)}})));const b=i._emissiveTexture;b&&g.push(this.exportTextureAsync(b,d).then((g=>{g&&(a.emissiveTexture=g)}))),g.length>0&&(this._exporter._materialNeedsUVsSet.add(i),await Promise.all(g))}const k=i._emissiveColor;k.equalsWithEpsilon(V,f)||(a.emissiveFactor=k.fd()),a.pbrMetallicRoughness=n}_getPixelsFromTextureAsync(g){return function(g){switch(g){case P.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case P.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case P.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case P.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case P.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case P.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case P.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case P.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case P.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case P.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case P.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case P.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case P.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(g.textureFormat)?(0,E.i)(g,g._texture.width,g._texture.height):(g.textureType,P.b.TEXTURETYPE_UNSIGNED_BYTE,g.readPixels())}async exportTextureAsync(g,i){const a=this._exporter._extensionsPreExportTextureAsync("exporter",g,i);return a?await a.then((async a=>a?await this._exportTextureInfoAsync(a,i):await this._exportTextureInfoAsync(g,i))):await this._exportTextureInfoAsync(g,i)}async _exportTextureInfoAsync(g,i){let a=this._textureMap.get(g);if(!a){const n=await this._getPixelsFromTextureAsync(g);if(!n)return null;const d=this._exportTextureSampler(g),b=g.mimeType;if(b)switch(b){case"image/jpeg":case"image/png":case"image/webp":i=b;break;default:L.Tools.Warn(`Unsupported media type: ${b}. Exporting texture as PNG.`)}const k=this._internalTextureToImage,e=g.getInternalTexture().uniqueId;k[e]||(k[e]={});let N=k[e][i];if(void 0===N){const a=g.getSize();N=(async()=>{const L=await this._getImageDataAsync(n,a.width,a.height,i);return this._exportImage(g.name,i,L)})(),k[e][i]=N}a=this._exportTextureInfo(await N,d,g.coordinatesIndex),this._textureMap.set(g,a),this._exporter._extensionsPostExportTextures("exporter",a,g)}return a}_exportImage(g,i,a){const n=this._exporter._images;let d;if(this._exporter._shouldUseGlb){d={name:g,mimeType:i,bufferView:void 0};const n=this._exporter._bufferManager.createBufferView(new Uint8Array(a));this._exporter._bufferManager.setBufferView(d,n)}else{const b=g.replace(/\.\/|\/|\.\\|\\/g,"_"),k=function(g){switch(g){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(i);let e=b+k;n.some((g=>g.uri===e))&&(e=`${b}_${L.Tools.RandomId()}${k}`),d={name:g,uri:e},this._exporter._imageData[e]={data:a,mimeType:i}}return n.push(d),n.length-1}_exportTextureInfo(g,i,a){const n=this._exporter._textures;let L=n.findIndex((a=>a.sampler==i&&a.source===g));-1===L&&(L=n.length,n.push({source:g,sampler:i}));const d={index:L};return a&&(d.texCoord=a),d}_exportTextureSampler(g){const i=this._getTextureSampler(g),a=this._exporter._samplers,n=a.findIndex((g=>g.minFilter===i.minFilter&&g.magFilter===i.magFilter&&g.wrapS===i.wrapS&&g.wrapT===i.wrapT));return-1!==n?n:(a.push(i),a.length-1)}}var t=a(12534),A=a(12292),O=a(12956),z=a(12454);const s=n.Bi.Zero(),mg=n.Quaternion.Identity(),r=n.Bi.One(),Q=new n.Bi(-1,1,1);function o(g,i){const{byteOffset:a,byteStride:n,type:L,normalized:d}=g,b=g.getSize(),k=i.reduce(((g,i)=>i.getTotalVertices()>g?i.getTotalVertices():g),-Number.MAX_VALUE);return{byteOffset:a,byteStride:n,componentCount:b,type:L,count:k*b,normalized:d,totalVertices:k,kind:g.getKind()}}function u(g){switch(g){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function H(g){switch(g){case F.g.PositionKind:case F.g.NormalKind:case F.g.TangentKind:case F.g.ColorKind:case F.g.MatricesIndicesKind:case F.g.MatricesIndicesExtraKind:case F.g.MatricesWeightsKind:case F.g.MatricesWeightsExtraKind:case F.g.UVKind:case F.g.UV2Kind:case F.g.UV3Kind:case F.g.UV4Kind:case F.g.UV5Kind:case F.g.UV6Kind:return!0}return!1}function M(g){switch(g){case d.c.TriangleFillMode:return 4;case d.c.TriangleStripDrawMode:return 5;case d.c.TriangleFanDrawMode:return 6;case d.c.PointListDrawMode:case d.c.PointFillMode:return 0;case d.c.LineLoopDrawMode:return 2;case d.c.LineListDrawMode:return 1;case d.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${g}`)}function q(g){const i=Math.sqrt(g.x*g.x+g.y*g.y+g.z*g.z);i>0&&(g.x/=i,g.y/=i,g.z/=i)}function W(g){return g.x*=-1,g}function G(g){if(g.x*g.x+g.y*g.y>.5){const i=Math.abs(g.x),a=Math.abs(g.y);if(i>a){const a=Math.sign(g.x);g.x=i,g.y*=-a,g.z*=-a,g.w*=a}else{const i=Math.sign(g.y);g.x*=-i,g.y=a,g.z*=i,g.w*=-i}}else{const i=Math.abs(g.z),a=Math.abs(g.w);if(i>a){const a=Math.sign(g.z);g.x*=-a,g.y*=a,g.z=i,g.w*=-a}else{const i=Math.sign(g.w);g.x*=i,g.y*=-i,g.z*=-i,g.w=a}}return g}function J(g){g.sd(-g.z,g.w,g.x,-g.y)}function gg(g,i){const a=n.Bi.FromArrayToRef(i.translation||[0,0,0],0,n.TmpVectors.Bi[0]),L=n.Quaternion.FromArrayToRef(i.rotation||[0,0,0,1],0,n.TmpVectors.Quaternion[0]),d=n.Matrix.ComposeToRef(r,L,a,n.TmpVectors.Matrix[0]),b=n.Bi.FromArrayToRef(g.translation||[0,0,0],0,n.TmpVectors.Bi[2]),k=n.Quaternion.FromArrayToRef(g.rotation||[0,0,0,1],0,n.TmpVectors.Quaternion[1]),e=n.Matrix.ComposeToRef(r,k,b,n.TmpVectors.Matrix[1]);d.multiplyToRef(e,e),e.decompose(void 0,L,a),a.equalsWithEpsilon(s,z.b)?delete i.translation:i.translation=a.fd(),L.equalsWithEpsilon(mg,z.b)?delete i.rotation:i.rotation=L.fd(),i.scale&&delete i.scale}function ig(g,i){if(!(i instanceof I.c))return!1;if(!(1===i.getChildren().length&&0===g.getChildren().length&&g.parent===i))return!1;const a=g.Pg(),n=g instanceof O.c&&!a.useRightHandedSystem?Q:r;return!!i.rd.equalsWithEpsilon(n,z.b)||(A.b.Warn(`Cannot collapse node ${g.name} into parent node ${i.name} with modified scaling.`),!1)}function ag(g){if(g instanceof Array){const i=new Float32Array(g);return new Uint8Array(i.buffer,i.byteOffset,i.byteLength)}return ArrayBuffer.isView(g)?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(g)}function ng(g,i){for(const[a,n]of Object.entries(g)){const L=i[a];(Array.isArray(n)&&Array.isArray(L)&&Lg(n,L)||n===L)&&delete g[a]}return g}function Lg(g,i){return g.length===i.length&&g.every(((g,a)=>g===i[a]))}const dg=n.Matrix.Compose(new n.Bi(-1,1,1),n.Quaternion.Identity(),n.Bi.Zero());function bg(g,i){if(!(g instanceof I.c))return!1;if(i){if(!g.getWorldMatrix().equalsWithEpsilon(n.Matrix.IdentityReadOnly,z.b))return!1}else{if(!g.getWorldMatrix().multiplyToRef(dg,n.TmpVectors.Matrix[0]).equalsWithEpsilon(n.Matrix.IdentityReadOnly,z.b))return!1}return!(g instanceof j.d&&g.wd)}const kg=new Map([[Int8Array,(g,i,a)=>g.setInt8(i,a)],[Uint8Array,(g,i,a)=>g.setUint8(i,a)],[Uint8ClampedArray,(g,i,a)=>g.setUint8(i,a)],[Int16Array,(g,i,a)=>g.setInt16(i,a,!0)],[Uint16Array,(g,i,a)=>g.setUint16(i,a,!0)],[Int32Array,(g,i,a)=>g.setInt32(i,a,!0)],[Uint32Array,(g,i,a)=>g.setUint32(i,a,!0)],[Float32Array,(g,i,a)=>g.setFloat32(i,a,!0)],[Float64Array,(g,i,a)=>g.setFloat64(i,a,!0)]]);class eg{writeTypedArray(g){this._checkGrowBuffer(g.byteLength);const i=kg.get(g.constructor);for(let a=0;a<g.length;a++)i(this._dataView,this._byteOffset,g[a]),this._byteOffset+=g.BYTES_PER_ELEMENT}constructor(g){this._data=new Uint8Array(g),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(g){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,g),this._byteOffset++}writeInt8(g){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,g),this._byteOffset++}writeInt16(g){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,g,!0),this._byteOffset+=2}writeUInt16(g){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,g,!0),this._byteOffset+=2}writeInt32(g){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,g,!0),this._byteOffset+=4}writeUInt32(g){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,g,!0),this._byteOffset+=4}writeFloat32(g){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,g,!0),this._byteOffset+=4}writeFloat64(g){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,g,!0),this._byteOffset+=8}_checkGrowBuffer(g){const i=this.byteOffset+g;if(i>this._data.byteLength){const g=new Uint8Array(2*i);g.set(this._data),this._data=g,this._dataView=new DataView(this._data.buffer)}}}function Ng(g){return g%4===0?4:g%2===0?2:1}class Fg{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(g){let i=0;this._bufferViewToData.forEach((g=>{i+=g.byteLength}));const a=new eg(i),n=Array.from(this._bufferViewToData.keys()).sort(((g,i)=>Ng(i.byteLength)-Ng(g.byteLength)));for(const L of n){L.byteOffset=a.byteOffset,g.push(L);const i=g.length-1,n=this.getPropertiesWithBufferView(L);for(const g of n)g.bufferView=i;a.writeTypedArray(this._bufferViewToData.get(L)),this._bufferViewToData.delete(L)}return a.getOutputData()}createBufferView(g,i){const a={buffer:0,byteOffset:void 0,byteLength:g.byteLength,byteStride:i};return this._bufferViewToData.set(a,g),a}createAccessor(g,i,a,n,L,d,b){this._verifyBufferView(g);const k={bufferView:void 0,componentType:a,count:n,type:i,min:null===d||void 0===d?void 0:d.min,max:null===d||void 0===d?void 0:d.max,normalized:b,byteOffset:L};return this.setBufferView(k,g),this._accessorToBufferView.set(k,g),k}setBufferView(g,i){this._verifyBufferView(i);this.getPropertiesWithBufferView(i).push(g)}removeBufferView(g){const i=this.getPropertiesWithBufferView(g);for(const a of i)void 0!==a.bufferView&&delete a.bufferView;this._bufferViewToData.delete(g),this._bufferViewToProperties.delete(g),this._accessorToBufferView.forEach(((i,a)=>{i===g&&(void 0!==a.byteOffset&&delete a.byteOffset,this._accessorToBufferView.delete(a))}))}getBufferView(g){const i=this._accessorToBufferView.get(g);return this._verifyBufferView(i),i}getPropertiesWithBufferView(g){return this._verifyBufferView(g),this._bufferViewToProperties.set(g,this._bufferViewToProperties.get(g)??[]),this._bufferViewToProperties.get(g)}getData(g){return this._verifyBufferView(g),this._bufferViewToData.get(g)}_verifyBufferView(g){if(void 0===g||!this._bufferViewToData.has(g))throw new Error(`BufferView ${g} not found in BufferManager.`)}}var Ig,jg=a(12916),yg=a(12935),Bg=a(12959),cg=a(12831),Dg=a(12994),pg=a(12998),Rg=a(12910),xg=a(13004);!function(g){g[g.INTANGENT=0]="INTANGENT",g[g.OUTTANGENT=1]="OUTTANGENT"}(Ig||(Ig={}));class Eg{static _IsTransformable(g){return g&&(g instanceof I.c||g instanceof jg.b||g instanceof xg.e)}static _CreateNodeAnimation(g,i,a,n,d){if(this._IsTransformable(g)){const b=[],k=[],e=i.getKeys(),N=Eg._CalculateMinMaxKeyFrames(e),F=Eg._DeduceInterpolation(e,a,n),I=F.interpolationType,j=F.shouldBakeAnimation;if(j?Eg._CreateBakedAnimation(g,i,a,N.min,N.max,i.framePerSecond,d,b,k,N,n):"LINEAR"===I||"STEP"===I?Eg._CreateLinearOrStepAnimation(g,i,a,b,k,n):"CUBICSPLINE"===I?Eg._CreateCubicSplineAnimation(g,i,a,b,k,n):Eg._CreateBakedAnimation(g,i,a,N.min,N.max,i.framePerSecond,d,b,k,N,n),b.length&&k.length){return{inputs:b,outputs:k,samplerInterpolation:I,inputsMin:j?N.min:L.Tools.FloatRound(N.min/i.framePerSecond),inputsMax:j?N.max:L.Tools.FloatRound(N.max/i.framePerSecond)}}}return null}static _DeduceAnimationInfo(g){let i=null,a="VEC3",n=!1;const d=g.targetProperty.split(".");switch(d[0]){case"rd":i="scale";break;case"position":i="translation";break;case"rotation":a="VEC4",i="rotation";break;case"rotationQuaternion":a="VEC4",n=!0,i="rotation";break;case"influence":a="SCALAR",i="weights";break;default:L.Tools.Error(`Unsupported animatable property ${d[0]}`)}return i?{animationChannelTargetPath:i,dataAccessorType:a,useQuaternion:n}:(L.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(g,i,a,n,L,d,b,k,e,N,F){let I;if(Eg._IsTransformable(g)&&g.animations)for(const j of g.animations){if(F&&!F(j))continue;const L=Eg._DeduceAnimationInfo(j);L&&(I={name:j.name,samplers:[],channels:[]},Eg._AddAnimation(`${j.name}`,j.hasRunningRuntimeAnimations?i:I,g,j,L.dataAccessorType,L.animationChannelTargetPath,n,d,b,k,L.useQuaternion,e,N),I.samplers.length&&I.channels.length&&a.push(I))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(g,i,a,n,L,d,b,k,e,N,F){let I;if(g instanceof Rg.e){const L=g.morphTargetManager;if(L)for(let j=0;j<L.numTargets;++j){const y=L.getTarget(j);for(const B of y.animations){if(F&&!F(B))continue;const y=new Dg.b(`${B.name}`,"influence",B.framePerSecond,B.dataType,B.loopMode,B.enableBlending),c=[],D=B.getKeys();for(let g=0;g<D.length;++g){const i=D[g];for(let g=0;g<L.numTargets;++g)g==j?c.push(i):c.push({frame:i.frame,value:0})}y.setKeys(c);const p=Eg._DeduceAnimationInfo(y);p&&(I={name:y.name,samplers:[],channels:[]},Eg._AddAnimation(B.name,B.hasRunningRuntimeAnimations?i:I,g,y,p.dataAccessorType,p.animationChannelTargetPath,n,d,b,k,p.useQuaternion,e,N,L.numTargets),I.samplers.length&&I.channels.length&&a.push(I))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(g,i,a,n,L,d,b,k,e){let N;if(g.animationGroups){const I=g.animationGroups;for(const j of I){const I=new Map,y=new Map,B=new Set,c=j.to-j.from;N={name:j.name,channels:[],samplers:[]};for(let i=0;i<j.targetedAnimations.length;++i){const c=j.targetedAnimations[i],D=c.target,p=c.animation;if(e&&!e(p))continue;const R=k.has(D);if(this._IsTransformable(D)||1===D.length&&this._IsTransformable(D[0])){const g=Eg._DeduceAnimationInfo(c.animation);if(g){const i=this._IsTransformable(D)?D:this._IsTransformable(D[0])?D[0]:null;i&&Eg._AddAnimation(`${p.name}`,N,i,p,g.dataAccessorType,g.animationChannelTargetPath,a,n,L,d,g.useQuaternion,b,R)}}else if(D instanceof pg.c||1===D.length&&D[0]instanceof pg.c){if(Eg._DeduceAnimationInfo(c.animation)){const i=D instanceof pg.c?D:D[0];if(i){const a=g.morphTargetManagers.find((g=>{for(let a=0;a<g.numTargets;++a)if(g.getTarget(a)===i)return!0;return!1}));if(a){const n=g.meshes.find((g=>g.morphTargetManager===a));var F;if(n)I.has(n)||I.set(n,new Map),null===(F=I.get(n))||void 0===F||F.set(i,p),B.add(n),y.set(n,p)}}}}}B.forEach((g=>{const i=g.morphTargetManager;let k=null;const e=[],F=y.get(g).getKeys(),B=F.length;for(let a=0;a<B;++a)for(let n=0;n<i.numTargets;++n){const L=i.getTarget(n),d=I.get(g);if(d){const i=d.get(L);i?(k||(k=new Dg.b(`${j.name}_${g.name}_MorphWeightAnimation`,"influence",i.framePerSecond,Dg.b.ANIMATIONTYPE_FLOAT,i.loopMode,i.enableBlending)),e.push(i.getKeys()[a])):e.push({frame:j.from+c/B*a,value:L.influence,inTangent:F[0].inTangent?0:void 0,outTangent:F[0].outTangent?0:void 0})}}k.setKeys(e);const D=Eg._DeduceAnimationInfo(k);D&&Eg._AddAnimation(`${j.name}_${g.name}_MorphWeightAnimation`,N,g,k,D.dataAccessorType,D.animationChannelTargetPath,a,n,L,d,D.useQuaternion,b,!1,null===i||void 0===i?void 0:i.numTargets)})),N.channels.length&&N.samplers.length&&i.push(N)}}}static _AddAnimation(g,i,a,L,d,b,k,e,N,F,I,j,y,B){const c=Eg._CreateNodeAnimation(a,L,b,I,j);let D,p,R,x,E,X;if(c){if(B){let g=0,i=0;const a=[];for(;c.inputs.length>0;)i=c.inputs.shift(),g%B==0&&a.push(i),g++;c.inputs=a}const g=k.get(a),L=new Float32Array(c.inputs);D=e.createBufferView(L),p=e.createAccessor(D,"SCALAR",5126,c.inputs.length,void 0,{min:[c.inputsMin],max:[c.inputsMax]}),F.push(p),R=F.length-1;const N=new n.Quaternion,I=new n.Bi,j=new n.Bi,v=a instanceof jg.b,P=u(d),Y=new Float32Array(c.outputs.length*P);c.outputs.forEach((function(g,i){let a=g;switch(b){case"translation":y&&(n.Bi.FromArrayToRef(g,0,j),W(j),j.toArray(a));break;case"rotation":4===g.length?n.Quaternion.FromArrayToRef(g,0,N):(a=new Array(4),n.Bi.FromArrayToRef(g,0,I),n.Quaternion.FromEulerVectorToRef(I,N)),y&&(G(N),v&&J(N)),N.toArray(a)}Y.set(a,i*P)})),D=e.createBufferView(Y),p=e.createAccessor(D,d,5126,c.outputs.length),F.push(p),x=F.length-1,E={interpolation:c.samplerInterpolation,input:R,output:x},i.samplers.push(E),X={sampler:i.samplers.length-1,target:{node:g,path:b}},i.channels.push(X)}}static _CreateBakedAnimation(g,i,a,d,b,k,e,N,F,I,j){let y;const B=n.Quaternion.Identity();let c,D=null,p=null,R=null,x=null,E=null,X=null;I.min=L.Tools.FloatRound(d/k);const v=i.getKeys();for(let n=0,P=v.length;n<P;++n){if(X=null,R=v[n],n+1<P)if(x=v[n+1],R.value.equals&&R.value.equals(x.value)||R.value===x.value){if(0!==n)continue;X=R.frame}else X=x.frame;else{if(E=v[n-1],R.value.equals&&R.value.equals(E.value)||R.value===E.value)continue;X=b}if(X)for(let n=R.frame;n<=X;n+=e){if(c=L.Tools.FloatRound(n/k),c===D)continue;D=c,p=c;const d={key:0,repeatCount:0,loopMode:i.loopMode};y=i._interpolate(n,d),Eg._SetInterpolatedValue(g,y,c,i,a,B,N,F,j)}}p&&(I.max=p)}static _ConvertFactorToVector3OrQuaternion(g,i,a,d,b){const k=Eg._GetBasePositionRotationOrScale(i,d,b),e=a.targetProperty.split("."),N=e?e[1]:"",F=b?n.Quaternion.xi(k).normalize():n.Bi.xi(k);switch(N){case"x":case"y":case"z":F[N]=g;break;case"w":F.w=g;break;default:L.Tools.Error(`glTFAnimation: Unsupported component name "${N}"!`)}return F}static _SetInterpolatedValue(g,i,a,L,d,b,k,e,N){let F;k.push(a),"weights"!==d?(L.dataType===Dg.b.ANIMATIONTYPE_FLOAT&&(i=this._ConvertFactorToVector3OrQuaternion(i,g,L,d,N)),"rotation"===d?(N?b=i:(F=i,n.Quaternion.RotationYawPitchRollToRef(F.y,F.x,F.z,b)),e.push(b.fd())):(F=i,e.push(F.fd()))):e.push([i])}static _CreateLinearOrStepAnimation(g,i,a,n,L,d){for(const b of i.getKeys())n.push(b.frame/i.framePerSecond),Eg._AddKeyframeValue(b,i,L,a,g,d)}static _CreateCubicSplineAnimation(g,i,a,n,L,d){i.getKeys().forEach((function(b){n.push(b.frame/i.framePerSecond),Eg._AddSplineTangent(Ig.INTANGENT,L,a,"CUBICSPLINE",b,d),Eg._AddKeyframeValue(b,i,L,a,g,d),Eg._AddSplineTangent(Ig.OUTTANGENT,L,a,"CUBICSPLINE",b,d)}))}static _GetBasePositionRotationOrScale(g,i,a){let L;if("rotation"===i)if(a){L=(g.rotationQuaternion??n.Quaternion.Identity()).fd()}else{L=(g.rotation??n.Bi.Zero()).fd()}else if("translation"===i){L=(g.position??n.Bi.Zero()).fd()}else{L=(g.rd??n.Bi.One()).fd()}return L}static _AddKeyframeValue(g,i,a,d,b,k){let e;const N=i.dataType;if(N===Dg.b.ANIMATIONTYPE_VECTOR3){let i=g.value.fd();if("rotation"===d){const g=n.Bi.xi(i);i=n.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).fd()}a.push(i)}else if(N===Dg.b.ANIMATIONTYPE_FLOAT){if("weights"===d)a.push([g.value]);else if(e=this._ConvertFactorToVector3OrQuaternion(g.value,b,i,d,k),e){if("rotation"===d){const g=k?e:n.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).normalize();a.push(g.fd())}a.push(e.fd())}}else N===Dg.b.ANIMATIONTYPE_QUATERNION?a.push(g.value.normalize().fd()):L.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(g,i,a){let n,L,d=!1;if("rotation"===i&&!a)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let b=0,k=g.length;b<k;++b)if(L=g[b],L.inTangent||L.outTangent)if(n){if("CUBICSPLINE"!==n){n="LINEAR",d=!0;break}}else n="CUBICSPLINE";else if(n){if("CUBICSPLINE"===n||L.interpolation&&1===L.interpolation&&"STEP"!==n){n="LINEAR",d=!0;break}}else n=L.interpolation&&1===L.interpolation?"STEP":"LINEAR";return n||(n="LINEAR"),{interpolationType:n,shouldBakeAnimation:d}}static _AddSplineTangent(g,i,a,L,d,b){let k;const e=g===Ig.INTANGENT?d.inTangent:d.outTangent;if("CUBICSPLINE"===L){if("rotation"===a)if(e)if(b)k=e.fd();else{const g=e;k=n.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).fd()}else k=[0,0,0,0];else k="weights"===a?e?[e]:[0]:e?e.fd():[0,0,0];i.push(k)}}static _CalculateMinMaxKeyFrames(g){let i=1/0,a=-1/0;return g.forEach((function(g){i=Math.min(i,g.frame),a=Math.max(a,g.frame)})),{min:i,max:a}}}function Xg(g,i,a,d,b,k){const e={attributes:{},influence:g.influence,name:g.name},N=i.wd;if(!N)return L.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),e;const I=k?-1:1,j=n.Bi.Zero();let y=0,B=0;if(g.hasPositions){const d=g.getPositions(),k=N.getVerticesData(F.g.PositionKind);if(k){const g=new Float32Array(k.length),i=[1/0,1/0,1/0],L=[-1/0,-1/0,-1/0];B=k.length/3,y=0;for(let a=y;a<B;++a){const b=n.Bi.xi(k,3*a);n.Bi.xi(d,3*a).subtractToRef(b,j),j.x*=I,i[0]=Math.min(i[0],j.x),L[0]=Math.max(L[0],j.x),i[1]=Math.min(i[1],j.y),L[1]=Math.max(L[1],j.y),i[2]=Math.min(i[2],j.z),L[2]=Math.max(L[2],j.z),g[3*a]=j.x,g[3*a+1]=j.y,g[3*a+2]=j.z}const N=a.createBufferView(g,12),F=a.createAccessor(N,"VEC3",5126,d.length/3,0,{min:i,max:L});b.push(F),e.attributes.POSITION=b.length-1}else L.Tools.Warn(`Morph target positions for mesh ${i.name} were not exported. Mesh does not have position vertex data`)}if(g.hasNormals){const d=g.getNormals(),k=N.getVerticesData(F.g.NormalKind);if(k){const g=new Float32Array(k.length);B=k.length/3,y=0;for(let a=y;a<B;++a){const i=n.Bi.xi(k,3*a).normalize();n.Bi.xi(d,3*a).normalize().subtractToRef(i,j),g[3*a]=j.x*I,g[3*a+1]=j.y,g[3*a+2]=j.z}const i=a.createBufferView(g,12),L=a.createAccessor(i,"VEC3",5126,d.length/3,0);b.push(L),e.attributes.NORMAL=b.length-1}else L.Tools.Warn(`Morph target normals for mesh ${i.name} were not exported. Mesh does not have normals vertex data`)}if(g.hasTangents){const d=g.getTangents(),k=N.getVerticesData(F.g.TangentKind);if(k){B=k.length/4;const g=new Float32Array(3*B);y=0;for(let a=y;a<B;++a){const i=n.Bi.xi(k,4*a);q(i);const L=n.Bi.xi(d,3*a);q(L),L.subtractToRef(i,j),g[3*a]=j.x*I,g[3*a+1]=j.y,g[3*a+2]=j.z}const i=a.createBufferView(g,12),L=a.createAccessor(i,"VEC3",5126,B,0);b.push(L),e.attributes.TANGENT=b.length-1}else L.Tools.Warn(`Morph target tangents for mesh ${i.name} were not exported. Mesh does not have tangents vertex data`)}if(g.hasColors){const d=g.getColors(),k=N.getVerticesData(F.g.ColorKind),I=N.getVertexBuffer(F.g.ColorKind);if(k&&I){const g=I.getSize();B=k.length/g;const i=new Float32Array(B*g);y=0;for(let a=y;a<B;++a)if(3===g){const L=n.Bi.xi(k,a*g);n.Bi.xi(d,a*g).subtractToRef(L,j),i[3*a]=j.x,i[3*a+1]=j.y,i[3*a+2]=j.z}else if(4===g){const L=new n.Vector4,b=n.Vector4.xi(k,a*g);n.Vector4.xi(d,a*g).subtractToRef(b,L),i[4*a]=L.x,i[4*a+1]=L.y,i[4*a+2]=L.z,i[4*a+3]=L.w}else L.Tools.Warn(`Unsupported number of components for color attribute: ${g}`);const N=a.createBufferView(i,4*g),F=a.createAccessor(N,3===g?"VEC3":"VEC4",5126,B,0);b.push(F),e.attributes.COLOR_0=b.length-1}else L.Tools.Warn(`Morph target colors for mesh ${i.name} were not exported. Mesh does not have colors vertex data`)}return e}var vg=a(13011),Pg=a(12861),Yg=a(12843),fg=a(12415);class Cg{}Cg.DEFAULT_COLOR=D.Ri.White(),Cg.DEFAULT_WIDTH_ATTENUATED=1,Cg.DEFAULT_WIDTH=.1;var Ug=a(12671),Sg=a(13017);class Vg{static ConvertPoints(g,i){if(g.length&&Array.isArray(g)&&"number"===typeof g[0])return[g];if(g.length&&Array.isArray(g[0])&&"number"===typeof g[0][0])return g;if(g.length&&!Array.isArray(g[0])&&g[0]instanceof n.Bi){const i=[];for(let a=0;a<g.length;a++){const n=g[a];i.push(n.x,n.y,n.z)}return[i]}if(g.length>0&&Array.isArray(g[0])&&g[0].length>0&&g[0][0]instanceof n.Bi){const i=[],a=g;for(const g of a)i.push(g.flatMap((g=>[g.x,g.y,g.z])));return i}if(g instanceof Float32Array){if(null!==i&&void 0!==i&&i.floatArrayStride){const a=[],n=3*i.floatArrayStride;for(let i=0;i<g.length;i+=n){const L=new Array(n);for(let a=0;a<n;a++)L[a]=g[i+a];a.push(L)}return a}return[Array.from(g)]}if(g.length&&g[0]instanceof Float32Array){const i=[];for(const a of g)i.push(Array.from(a));return i}return[]}static OmitZeroLengthPredicate(g,i,a){const n=[];return i.ci(g).lengthSquared()>0&&n.push([g,i]),a.ci(i).lengthSquared()>0&&n.push([i,a]),g.ci(a).lengthSquared()>0&&n.push([a,g]),0===n.length?null:n}static OmitDuplicatesPredicate(g,i,a,n){const L=[];return Vg._SearchInPoints(g,i,n)||L.push([g,i]),Vg._SearchInPoints(i,a,n)||L.push([i,a]),Vg._SearchInPoints(a,g,n)||L.push([a,g]),0===L.length?null:L}static _SearchInPoints(g,i,a){for(const b of a)for(let a=0;a<b.length;a++){var n,L,d;if(null!==(n=b[a])&&void 0!==n&&n.equals(g))if(null!==(L=b[a+1])&&void 0!==L&&L.equals(i)||null!==(d=b[a-1])&&void 0!==d&&d.equals(i))return!0}return!1}static MeshesToLines(g,i){const a=[];for(let L=0;L<g.length;L++){const d=g[L],b=d.getVerticesData(F.g.PositionKind),k=d.Ad();if(b&&k)for(let g=0,e=0;g<k.length;g++){const N=3*k[e++],F=3*k[e++],I=3*k[e++],j=new n.Bi(b[N],b[N+1],b[N+2]),y=new n.Bi(b[F],b[F+1],b[F+2]),B=new n.Bi(b[I],b[I+1],b[I+2]);if(i){const n=i(j,y,B,a,g,N,d,L,b,k);if(n)for(const g of n)a.push(g)}else a.push([j,y],[y,B],[B,j])}}return a}static ToVector3Array(g){if(Array.isArray(g[0])){const i=[],a=g;for(const g of a){const a=[];for(let i=0;i<g.length;i+=3)a.push(new n.Bi(g[i],g[i+1],g[i+2]));i.push(a)}return i}const i=g,a=[];for(let L=0;L<i.length;L+=3)a.push(new n.Bi(i[L],i[L+1],i[L+2]));return a}static ToNumberArray(g){return g.flatMap((g=>[g.x,g.y,g.z]))}static GetPointsCountInfo(g){const i=new Array(g.length);let a=0;for(let n=g.length;n--;)i[n]=g[n].length/3,a+=i[n];return{total:a,counts:i}}static GetLineLength(g){if(0===g.length)return 0;let i;i="number"===typeof g[0]?Vg.ToVector3Array(g):g;const a=n.TmpVectors.Bi[0];let L=0;for(let n=0;n<i.length-1;n++){const g=i[n];L+=i[n+1].subtractToRef(g,a).length()}return L}static GetLineLengthArray(g){const i=new Float32Array(g.length/3);let a=0;for(let n=0,L=g.length/3-1;n<L;n++){let L=g[3*n+0],d=g[3*n+1],b=g[3*n+2];L-=g[3*n+3],d-=g[3*n+4],b-=g[3*n+5];a+=Math.sqrt(L*L+d*d+b*b),i[n+1]=a}return i}static SegmentizeSegmentByCount(g,i,a){const L=[],d=i.ci(g),b=n.TmpVectors.Bi[0];b.Qd(a);const k=n.TmpVectors.Bi[1];d.divideToRef(b,k);let e=g.clone();L.push(e);for(let n=0;n<a;n++)e=e.clone(),L.push(e.addInPlace(k));return L}static SegmentizeLineBySegmentLength(g,i){const a=g[0]instanceof n.Bi?Vg.GetLineSegments(g):"number"===typeof g[0]?Vg.GetLineSegments(Vg.ToVector3Array(g)):g,L=[];for(const n of a)if(n.length>i){const g=Vg.SegmentizeSegmentByCount(n.point1,n.point2,Math.ceil(n.length/i));for(const i of g)L.push(i)}else L.push(n.point1),L.push(n.point2);return L}static SegmentizeLineBySegmentCount(g,i){const a="number"===typeof g[0]?Vg.ToVector3Array(g):g,n=Vg.GetLineLength(a)/i;return Vg.SegmentizeLineBySegmentLength(a,n)}static GetLineSegments(g){const i=[];for(let a=0;a<g.length-1;a++){const n=g[a],L=g[a+1],d=L.ci(n).length();i.push({point1:n,point2:L,length:d})}return i}static GetMinMaxSegmentLength(g){const i=Vg.GetLineSegments(g).sort((g=>g.length));return{min:i[0].length,max:i[i.length-1].length}}static GetPositionOnLineByVisibility(g,i,a){let L=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const d=i*a;let b=0,k=0;const e=g.length;for(let n=0;n<e;n++){if(d<=b+g[n].length){k=n;break}b+=g[n].length}const N=(d-b)/g[k].length;return g[k].point2.subtractToRef(g[k].point1,n.TmpVectors.Bi[0]),n.TmpVectors.Bi[1]=n.TmpVectors.Bi[0].multiplyByFloats(N,N,N),L||n.TmpVectors.Bi[1].addInPlace(g[k].point1),n.TmpVectors.Bi[1].clone()}static GetCircleLinePoints(g,i){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,L=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g,d=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/i;const b=[];for(let k=0;k<=i;k++)b.push(new n.Bi(Math.cos(k*d)*g,Math.sin(k*d)*L,a));return b}static GetBezierLinePoints(g,i,a,n){return Ug.e.CreateQuadraticBezier(g,i,a,n).getPoints().flatMap((g=>[g.x,g.y,g.z]))}static GetArrowCap(g,i,a,n,L){let d=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,b=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[g.clone(),g.add(i.multiplyByFloats(a,a,a))],widths:[n,L,d,b]}}static GetPointsFromText(g,i,a,n){let L=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,d=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const b=[],k=(0,Sg.d)(g,i,a,n);for(const e of k){for(const g of e.paths){const i=[],a=g.getPoints();for(const g of a)i.push(g.x,g.y,L);b.push(i)}if(d)for(const g of e.holes){const i=[],a=g.getPoints();for(const g of a)i.push(g.x,g.y,L);b.push(i)}}return b}static Color3toRGBAUint8(g){const i=new Uint8Array(4*g.length);for(let a=0,n=0;a<g.length;a++)i[n++]=255*g[a].r,i[n++]=255*g[a].g,i[n++]=255*g[a].b,i[n++]=255;return i}static CreateColorsTexture(g,i,a,n){const L=n.getEngine().getCaps().maxTextureSize??1,d=i.length>L?L:i.length,b=Math.ceil(i.length/L);b>1&&(i=[...i,...Array(d*b-i.length).fill(i[0])]);const k=Vg.Color3toRGBAUint8(i),e=new v.b(k,d,b,B.b.TEXTUREFORMAT_RGBA,n,!1,!0,a);return e.name=g,e}static PrepareEmptyColorsTexture(g){if(!Cg.EmptyColorsTexture){const i=new Uint8Array(4);Cg.EmptyColorsTexture=new v.b(i,1,1,B.b.TEXTUREFORMAT_RGBA,g,!1,!1,v.b.NEAREST_NEAREST),Cg.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Cg.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var g;null===(g=Cg.EmptyColorsTexture)||void 0===g||g.dispose(),Cg.EmptyColorsTexture=null}static BooleanToNumber(g){return g?1:0}}class Kg extends Yg.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Tg extends Pg.b{isCompatible(g){return!0}constructor(g,i,a){var L;a=a||{color:Cg.DEFAULT_COLOR};const d=new Kg;d.GREASED_LINE_HAS_COLOR=!!a.color&&!a.useColors,d.GREASED_LINE_SIZE_ATTENUATION=a.sizeAttenuation??!1,d.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===a.colorDistributionType,d.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(i??g.Pg()).useRightHandedSystem,d.GREASED_LINE_CAMERA_FACING=a.cameraFacing??!0,super(g,Tg.GREASED_LINE_MATERIAL_NAME,200,d,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(L=a)||void 0===L?void 0:L.forceGLSL)||Tg.ForceGLSL,this._scene=i??g.Pg(),this._engine=this._scene.getEngine(),this._cameraFacing=a.cameraFacing??!0,this.visibility=a.visibility??1,this.useDash=a.useDash??!1,this.dashRatio=a.dashRatio??.5,this.dashOffset=a.dashOffset??0,this.width=a.width?a.width:a.sizeAttenuation?Cg.DEFAULT_WIDTH_ATTENUATED:Cg.DEFAULT_WIDTH,this._sizeAttenuation=a.sizeAttenuation??!1,this.colorMode=a.colorMode??0,this._color=a.color??null,this.useColors=a.useColors??!1,this._colorsDistributionType=a.colorDistributionType??0,this.colorsSampling=a.colorsSampling??v.b.NEAREST_NEAREST,this._colors=a.Ug??null,this.dashCount=a.dashCount??1,this.resolution=a.resolution??new n.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),a.colorsTexture?this.colorsTexture=a.colorsTexture:this._colors?this.colorsTexture=Vg.CreateColorsTexture(`${g.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Cg.DEFAULT_COLOR,Vg.PrepareEmptyColorsTexture(this._scene)),this._engine.dd.add((()=>{Vg.DisposeEmptyColorsTexture()}))}getAttributes(g){g.push("grl_offsets"),g.push("grl_widths"),g.push("grl_colorPointers"),g.push("grl_counters"),this._cameraFacing?(g.push("grl_previousAndSide"),g.push("grl_nextAndCounters")):g.push("grl_slopes")}getSamplers(g){g.push("grl_colors")}getActiveTextures(g){this.colorsTexture&&g.push(this.colorsTexture)}getUniforms(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const i=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&i.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===g&&i.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:i,vertex:this._cameraFacing&&this._isGLSL(g)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(g)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(g){if(this._cameraFacing){g.ld("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||g.ld("viewProjection",this._scene.getTransformMatrix());const i=n.TmpVectors.Vector4[0];i.x=this._aspect,i.y=this._resolution.x,i.z=this._resolution.y,i.w=this.width,g.updateVector4("grl_aspect_resolution_lineWidth",i)}const i=n.TmpVectors.Vector4[0];i.x=Vg.BooleanToNumber(this.useDash),i.y=this._dashArray,i.z=this.dashOffset,i.w=this.dashRatio,g.updateVector4("grl_dashOptions",i);const a=n.TmpVectors.Vector4[1];a.x=this.colorMode,a.y=this.visibility,a.z=this.colorsTexture?this.colorsTexture.getSize().width:0,a.w=Vg.BooleanToNumber(this.useColors),g.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",a),this._color&&g.updateColor3("grl_singleColor",this._color);const L=this.colorsTexture??Cg.EmptyColorsTexture;g.setTexture("grl_colors",L),g.updateFloat2("grl_textureSize",(null===L||void 0===L?void 0:L.getSize().width)??1,(null===L||void 0===L?void 0:L.getSize().height)??1)}prepareDefines(g,i,a){g.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,g.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,g.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,g.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=i.useRightHandedSystem,g.GREASED_LINE_CAMERA_FACING=this._cameraFacing,g.GREASED_LINE_USE_OFFSETS=!!a.offsets}getClassName(){return Tg.GREASED_LINE_MATERIAL_NAME}getCustomCode(g){let i=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(i)?function(g,i){if("vertex"===g){const g={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return i&&(g["!gl_Position\\=viewProjection\\*worldPos;"]="//"),g}return"fragment"===g?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(g,this._cameraFacing):function(g,i){if("vertex"===g){const g={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return i&&(g["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),g}return"fragment"===g?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(g,this._cameraFacing)}dispose(){var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),super.dispose()}get Ug(){return this._colors}set Ug(g){this.setColors(g)}setColors(g){var i;let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(i=this._colors)||void 0===i?void 0:i.length)??0;var d;if(this._colors=g,null!==g&&0!==g.length){if(!a||n)if(this.colorsTexture&&L===g.length&&!n){const i=Vg.Color3toRGBAUint8(g);this.colorsTexture.update(i)}else{var b;null===(b=this.colorsTexture)||void 0===b||b.dispose(),this.colorsTexture=Vg.CreateColorsTexture(`${this._material.name}-colors-texture`,g,this.colorsSampling,this._scene)}}else null===(d=this.colorsTexture)||void 0===d||d.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(g){this._dashCount=g,this._dashArray=1/g}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(g){this._sizeAttenuation=g,this.markAllDefinesAsDirty()}get color(){return this._color}set color(g){this.setColor(g)}setColor(g){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==g||null!==this._color&&null===g?(this._color=g,i||this.markAllDefinesAsDirty()):this._color=g}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(g){this._colorsDistributionType=g,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(g){this._aspect=g.x/g.y,this._resolution=g}serialize(){const g=super.serialize(),i={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(i.Ug=this._colors),this._color&&(i.color=this._color),g.greasedLineMaterialOptions=i,g}parse(g,i,a){var n;super.parse(g,i,a);const L=g.greasedLineMaterialOptions;null===(n=this.colorsTexture)||void 0===n||n.dispose(),L.color&&this.setColor(L.color,!0),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.Ug&&(this.Ug=L.Ug),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),this.Ug?this.colorsTexture=Vg.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Ug,this.colorsSampling,i):Vg.PrepareEmptyColorsTexture(i),this.markAllDefinesAsDirty()}copyTo(g){var i;const a=g;null===(i=a.colorsTexture)||void 0===i||i.dispose(),this._colors&&(a.colorsTexture=Vg.CreateColorsTexture(`${a._material.name}-colors-texture`,this._colors,a.colorsSampling,this._scene)),a.setColor(this.color,!0),a.colorsDistributionType=this.colorsDistributionType,a.colorsSampling=this.colorsSampling,a.colorMode=this.colorMode,a.useColors=this.useColors,a.visibility=this.visibility,a.useDash=this.useDash,a.dashCount=this.dashCount,a.dashRatio=this.dashRatio,a.dashOffset=this.dashOffset,a.width=this.width,a.sizeAttenuation=this.sizeAttenuation,a.resolution=this.resolution,a.markAllDefinesAsDirty()}_isGLSL(g){return 0===g||this._forceGLSL}}Tg.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Tg.ForceGLSL=!1,(0,fg.e)(`BABYLON.${Tg.GREASED_LINE_MATERIAL_NAME}`,Tg);var lg=a(12896),Zg=a(12296),hg=a(12690),wg=a(12400);class tg extends hg.ShaderMaterial{constructor(g,i,L){const d=i.getEngine(),b=d.isWebGPU&&!(L.forceGLSL||tg.ForceGLSL),k=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];i.useRightHandedSystem&&k.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const e=["position","grl_widths","grl_offsets","grl_colorPointers"];L.cameraFacing?(k.push("GREASED_LINE_CAMERA_FACING"),e.push("grl_previousAndSide","grl_nextAndCounters")):(e.push("grl_slopes"),e.push("grl_counters"));const N=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(b||N.push("world","viewProjection","view","projection"),super(g,i,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:b?["Scene","Mesh"]:void 0,attributes:e,uniforms:N,samplers:b?[]:["grlColors"],defines:k,extraInitializationsAsync:async()=>{b?await Promise.all([a.e(66).then(a.bind(a,15667)),a.e(75).then(a.bind(a,15674))]):await Promise.all([a.e(69).then(a.bind(a,15677)),a.e(76).then(a.bind(a,15681))])},shaderLanguage:b?1:0}),this._color=D.Ri.White(),this._colorsDistributionType=0,this._colorsTexture=null,L=L||{color:Cg.DEFAULT_COLOR},this.visibility=L.visibility??1,this.useDash=L.useDash??!1,this.dashRatio=L.dashRatio??.5,this.dashOffset=L.dashOffset??0,this.dashCount=L.dashCount??1,this.width=L.width?L.width:L.sizeAttenuation&&L.cameraFacing?Cg.DEFAULT_WIDTH_ATTENUATED:Cg.DEFAULT_WIDTH,this.sizeAttenuation=L.sizeAttenuation??!1,this.color=L.color??D.Ri.White(),this.useColors=L.useColors??!1,this.colorsDistributionType=L.colorDistributionType??0,this.colorsSampling=L.colorsSampling??v.b.NEAREST_NEAREST,this.colorMode=L.colorMode??0,this._colors=L.Ug??null,this._cameraFacing=L.cameraFacing??!0,this.resolution=L.resolution??new n.Vector2(d.getRenderWidth(),d.getRenderHeight()),L.colorsTexture?this.colorsTexture=L.colorsTexture:this._colors?this.colorsTexture=Vg.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,i):(this._color=this._color??Cg.DEFAULT_COLOR,this.colorsTexture=Vg.PrepareEmptyColorsTexture(i)),b){const g=new wg.c;g.setParameters(),g.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",g)}d.dd.add((()=>{Vg.DisposeEmptyColorsTexture()}))}dispose(){var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new n.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Ug(){return this._colors}set Ug(g){this.setColors(g)}setColors(g){var i;let a=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const L=(null===(i=this._colors)||void 0===i?void 0:i.length)??0;var d;if(this._colors=g,null!==g&&0!==g.length){if(!a||n)if(this._colorsTexture&&L===g.length&&!n){const i=Vg.Color3toRGBAUint8(g);this._colorsTexture.update(i)}else{var b;null===(b=this._colorsTexture)||void 0===b||b.dispose(),this.colorsTexture=Vg.CreateColorsTexture(`${this.name}-colors-texture`,g,this.colorsSampling,this.Pg())}}else null===(d=this._colorsTexture)||void 0===d||d.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(g){this._colorsTexture=g,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(g){this._width=g,this.setFloat("grlWidth",g)}get useColors(){return this._useColors}set useColors(g){this._useColors=g,this.setFloat("grlUseColors",Vg.BooleanToNumber(g))}get colorsSampling(){return this._colorsSampling}set colorsSampling(g){this._colorsSampling=g}get visibility(){return this._visibility}set visibility(g){this._visibility=g,this.setFloat("grlVisibility",g)}get useDash(){return this._useDash}set useDash(g){this._useDash=g,this.setFloat("grlUseDash",Vg.BooleanToNumber(g))}get dashOffset(){return this._dashOffset}set dashOffset(g){this._dashOffset=g,this.setFloat("grlDashOffset",g)}get dashRatio(){return this._dashRatio}set dashRatio(g){this._dashRatio=g,this.setFloat("grlDashRatio",g)}get dashCount(){return this._dashCount}set dashCount(g){this._dashCount=g,this._dashArray=1/g,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(g){this._sizeAttenuation=g,this.setFloat("grlSizeAttenuation",Vg.BooleanToNumber(g))}get color(){return this._color}set color(g){this.setColor(g)}setColor(g){g=g??Cg.DEFAULT_COLOR,this._color=g,this.setColor3("grlColor",g)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(g){this._colorsDistributionType=g,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(g){this._colorMode=g,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(g){this._resolution=g,this.setVector2("grlResolution",g),this.setFloat("grlAspect",g.x/g.y)}serialize(){const g=super.serialize(),i={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(i.Ug=this._colors),g.greasedLineMaterialOptions=i,g}parse(g,i,a){var n;const L=g.greasedLineMaterialOptions;null===(n=this._colorsTexture)||void 0===n||n.dispose(),L.color&&(this.color=L.color),L.colorDistributionType&&(this.colorsDistributionType=L.colorDistributionType),L.colorsSampling&&(this.colorsSampling=L.colorsSampling),L.colorMode&&(this.colorMode=L.colorMode),L.useColors&&(this.useColors=L.useColors),L.visibility&&(this.visibility=L.visibility),L.useDash&&(this.useDash=L.useDash),L.dashCount&&(this.dashCount=L.dashCount),L.dashRatio&&(this.dashRatio=L.dashRatio),L.dashOffset&&(this.dashOffset=L.dashOffset),L.width&&(this.width=L.width),L.sizeAttenuation&&(this.sizeAttenuation=L.sizeAttenuation),L.resolution&&(this.resolution=L.resolution),L.Ug?this.colorsTexture=Vg.CreateColorsTexture(`${this.name}-colors-texture`,L.Ug,this.colorsSampling,this.Pg()):this.colorsTexture=Vg.PrepareEmptyColorsTexture(i),this._cameraFacing=L.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Ag,Og,zg;tg.ForceGLSL=!1,function(g){g[g.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",g[g.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Ag||(Ag={})),function(g){g[g.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",g[g.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",g[g.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Og||(Og={})),function(g){g[g.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",g[g.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",g[g.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",g[g.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",g[g.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(zg||(zg={}));class sg extends Rg.e{constructor(g,i,a){super(g,i,null,null,!1,!1),this.name=g,this._options=a,this._lazy=!1,this._updatable=!1,this._engine=i.getEngine(),this._lazy=a.lazy??!1,this._updatable=a.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=a.colorPointers??[],this._widths=a.widths??new Array(a.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(g){let i=0;for(const n of this._points)i+=n.length;const a=i/3*2-this._widths.length;for(let n=0;n<a;n++)this._widths.push(g)}updateLazy(){var g,i;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(g=this._options.ribbonOptions)||void 0===g?void 0:g.smoothShading),!this.Tg&&this.refreshBoundingInfo(),null===(i=this.greasedLineMaterial)||void 0===i||i.updateLazy()}addPoints(g,i){for(const a of g)this._points.push(a);this._lazy||this.setPoints(this._points,i)}dispose(g){let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(g,i)}isLazy(){return this._lazy}get Sg(){return this._uvs}set Sg(g){this._uvs=g instanceof Float32Array?g:new Float32Array(g),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(g){this.material instanceof tg&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===g||void 0===g?void 0:g.length)>0),this._offsets=g,this._offsetsBuffer?this._offsetsBuffer.update(g):this._createOffsetsBuffer(g)}get widths(){return this._widths}set widths(g){this._widths=g,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(g)}get colorPointers(){return this._colorPointers}set colorPointers(g){this._colorPointers=g,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(g)}get greasedLineMaterial(){var g,i;if(this.material&&this.material instanceof tg)return this.material;const a=null===(g=this.material)||void 0===g||null===(i=g.pluginManager)||void 0===i?void 0:i.getPlugin(Tg.GREASED_LINE_MATERIAL_NAME);return a||void 0}get points(){const g=[];return Zg.c.DeepCopy(this._points,g),g}setPoints(g,i){this._points=Vg.ConvertPoints(g,(null===i||void 0===i?void 0:i.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==i&&void 0!==i&&i.colorPointers||this._updateColorPointers(),this._setPoints(this._points,i)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Sg:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(g){super.serialize(g),g.type=this.getClassName(),g.lineOptions=this._createLineOptions()}_createVertexBuffers(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const i=new lg.c;return i.fg=this._vertexPositions,i.indices=this._indices,i.Sg=this._uvs,g&&(i.Cg=[],lg.c.ComputeNormals(this._vertexPositions,this._indices,i.Cg)),i.Kg(this,this._options.updatable),i}_createOffsetsBuffer(g){const i=this._scene.getEngine(),a=new F.c(i,g,this._updatable,3);this.setVerticesBuffer(a.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=a}}class mi{constructor(g,i){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=g,this.wasAddedByNoopNode=i}getIndicesAccessor(g,i,a,n,L){var d,b,k,e;return null===(d=this._indicesAccessorMap.get(g))||void 0===d||null===(b=d.get(i))||void 0===b||null===(k=b.get(a))||void 0===k||null===(e=k.get(n))||void 0===e?void 0:e.get(L)}setIndicesAccessor(g,i,a,n,L,d){let b=this._indicesAccessorMap.get(g);b||(b=new Map,this._indicesAccessorMap.set(g,b));let k=b.get(i);k||(k=new Map,b.set(i,k));let e=k.get(a);e||(e=new Map,k.set(a,e));let N=e.get(n);N||(N=new Map,e.set(n,N)),N.set(L,d)}pushExportedNode(g){this._exportedNodes.has(g)||this._exportedNodes.add(g)}getNodesSet(){return this._exportedNodes}getVertexBufferView(g){return this._vertexBufferViewMap.get(g)}setVertexBufferView(g,i){this._vertexBufferViewMap.set(g,i)}setRemappedBufferView(g,i,a){this._remappedBufferView.set(g,new Map),this._remappedBufferView.get(g).set(i,a)}getRemappedBufferView(g,i){var a;return null===(a=this._remappedBufferView.get(g))||void 0===a?void 0:a.get(i)}getVertexAccessor(g,i,a){var n,L;return null===(n=this._vertexAccessorMap.get(g))||void 0===n||null===(L=n.get(i))||void 0===L?void 0:L.get(a)}setVertexAccessor(g,i,a,n){let L=this._vertexAccessorMap.get(g);L||(L=new Map,this._vertexAccessorMap.set(g,L));let d=L.get(i);d||(d=new Map,L.set(i,d)),d.set(a,n)}hasVertexColorAlpha(g){return this._vertexMapColorAlpha.get(g)||!1}setHasVertexColorAlpha(g,i){return this._vertexMapColorAlpha.set(g,i)}getMesh(g){return this._meshMap.get(g)}setMesh(g,i){this._meshMap.set(g,i)}bindMorphDataToMesh(g,i){const a=this._meshMorphTargetMap.get(g)||[];this._meshMorphTargetMap.set(g,a),-1===a.indexOf(i)&&a.push(i)}getMorphTargetsFromMesh(g){return this._meshMorphTargetMap.get(g)}}class rg{_ApplyExtension(g,i,a,n){if(a>=i.length)return Promise.resolve(g);const L=n(i[a],g);return L?L.then((async g=>g?await this._ApplyExtension(g,i,a+1,n):null)):this._ApplyExtension(g,i,a+1,n)}_ApplyExtensions(g,i){const a=[];for(const n of rg._ExtensionNames)a.push(this._extensions[n]);return this._ApplyExtension(g,a,0,i)}_extensionsPreExportTextureAsync(g,i,a){return this._ApplyExtensions(i,((i,n)=>i.preExportTextureAsync&&i.preExportTextureAsync(g,n,a)))}_extensionsPostExportNodeAsync(g,i,a,n,L){return this._ApplyExtensions(i,((i,d)=>i.postExportNodeAsync&&i.postExportNodeAsync(g,d,a,n,L,this._bufferManager)))}_extensionsPostExportMaterialAsync(g,i,a){return this._ApplyExtensions(i,((i,n)=>i.postExportMaterialAsync&&i.postExportMaterialAsync(g,n,a)))}_extensionsPostExportMaterialAdditionalTextures(g,i,a){const n=[];for(const L of rg._ExtensionNames){const d=this._extensions[L];d.postExportMaterialAdditionalTextures&&n.push(...d.postExportMaterialAdditionalTextures(g,i,a))}return n}_extensionsPostExportTextures(g,i,a){for(const n of rg._ExtensionNames){const L=this._extensions[n];L.postExportTexture&&L.postExportTexture(g,i,a)}}_extensionsPostExportMeshPrimitive(g){for(const i of rg._ExtensionNames){const a=this._extensions[i];a.postExportMeshPrimitive&&a.postExportMeshPrimitive(g,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const g of rg._ExtensionNames){const i=this._extensions[g];i.preGenerateBinaryAsync&&await i.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(g){for(const i of rg._ExtensionNames){const a=this._extensions[i];a.enabled&&g(a)}}_extensionsOnExporting(){this._forEachExtensions((g=>{var i,a,n;g.wasUsed&&((i=this._glTF).extensionsUsed||(i.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(g.name)&&this._glTF.extensionsUsed.push(g.name),g.required&&((a=this._glTF).extensionsRequired||(a.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(g.name)&&this._glTF.extensionsRequired.push(g.name)),(n=this._glTF).extensions||(n.extensions={}),g.onExporting&&g.onExporting())}))}_loadExtensions(){for(const g of rg._ExtensionNames){const i=rg._ExtensionFactories[g](this);this._extensions[g]=i}}constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:c.c.LastCreatedScene,i=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${B.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new w(this),this._extensions={},this._bufferManager=new Fg,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!g)throw new Error("No scene available to export");this._babylonScene=g,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:g=>{var i;return null===g||void 0===g||null===(i=g.Dd)||void 0===i?void 0:i.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...i},this._loadExtensions()}dispose(){for(const g in this._extensions){this._extensions[g].dispose()}}get options(){return this._options}static RegisterExtension(g,i){rg.UnregisterExtension(g)&&L.Tools.Warn(`Extension with the name ${g} already exists`),rg._ExtensionFactories[g]=i,rg._ExtensionNames.push(g)}static UnregisterExtension(g){if(!rg._ExtensionFactories[g])return!1;delete rg._ExtensionFactories[g];const i=rg._ExtensionNames.indexOf(g);return-1!==i&&rg._ExtensionNames.splice(i,1),!0}_generateJSON(g,i,a){const n={byteLength:g};return n.byteLength&&(this._glTF.buffers=[n]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Di=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(n.uri=i+".bin"),a?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(g){const i=await this._generateBinaryAsync();this._extensionsOnExporting();const a=this._generateJSON(i.byteLength,g,!0),n=new Blob([i],{type:"application/octet-stream"}),L=g+".gltf",d=g+".bin",b=new N;if(b.files[L]=a,b.files[d]=n,this._imageData)for(const k in this._imageData)b.files[k]=new Blob([this._imageData[k].data],{type:this._imageData[k].mimeType});return b}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(g){const i=g%4;return 0===i?i:4-i}async generateGLBAsync(g){this._shouldUseGlb=!0;const i=await this._generateBinaryAsync();this._extensionsOnExporting();const a=this._generateJSON(i.byteLength),n=g+".glb";let L,d=a.length;if("undefined"!==typeof TextEncoder){L=(new TextEncoder).encode(a),d=L.length}const b=this._getPadding(d),k=this._getPadding(i.byteLength),e=28+d+b+i.byteLength+k,F=new eg(e);if(F.writeUInt32(1179937895),F.writeUInt32(2),F.writeUInt32(e),F.writeUInt32(d+b),F.writeUInt32(1313821514),L)F.writeTypedArray(L);else{const g="_".charCodeAt(0);for(let i=0;i<d;++i){const n=a.charCodeAt(i);n!=a.codePointAt(i)?F.writeUInt8(g):F.writeUInt8(n)}}for(let N=0;N<b;++N)F.writeUInt8(32);F.writeUInt32(i.byteLength+k),F.writeUInt32(5130562),F.writeTypedArray(i);for(let N=0;N<k;++N)F.writeUInt8(0);const I=new N;return I.files[n]=new Blob([F.getOutputData()],{type:"application/octet-stream"}),I}_setNodeTransformation(g,i,a){if(i.getPivotPoint().equalsWithEpsilon(s,z.b)||L.Tools.Warn("Pivot points are not supported in the glTF serializer"),!i.position.equalsWithEpsilon(s,z.b)){const L=n.TmpVectors.Bi[0].I(i.position);a&&W(L),g.translation=L.fd()}i.rd.equalsWithEpsilon(r,z.b)||(g.scale=i.rd.fd());const d=i.rotationQuaternion||n.Quaternion.FromEulerAngles(i.rotation.x,i.rotation.y,i.rotation.z);d.equalsWithEpsilon(mg,z.b)||(a&&G(d),g.rotation=d.normalize().fd())}_setCameraTransformation(g,i,a){if(!i.position.equalsWithEpsilon(s,z.b)){const L=n.TmpVectors.Bi[0].I(i.position);a&&W(L),g.translation=L.fd()}const L=i.rotationQuaternion||n.Quaternion.FromEulerAngles(i.rotation.x,i.rotation.y,i.rotation.z);a&&G(L),this._babylonScene.useRightHandedSystem||J(L),L.equalsWithEpsilon(mg,z.b)||(g.rotation=L.fd())}_listAvailableCameras(){for(const g of this._babylonScene.cameras){const i={type:g.mode===jg.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(g.name&&(i.name=g.name),"perspective"===i.type)i.perspective={aspectRatio:g.getEngine().getAspectRatio(g),yfov:g.fovMode===jg.b.FOVMODE_VERTICAL_FIXED?g.fov:g.fov*g.getEngine().getAspectRatio(g),znear:g.Vd,zfar:g.maxZ};else if("orthographic"===i.type){const a=g.orthoLeft&&g.orthoRight?.5*(g.orthoRight-g.orthoLeft):.5*g.getEngine().getRenderWidth(),n=g.orthoBottom&&g.orthoTop?.5*(g.orthoTop-g.orthoBottom):.5*g.getEngine().getRenderHeight();i.orthographic={xmag:a,ymag:n,znear:g.Vd,zfar:g.maxZ}}this._camerasMap.set(g,i)}}_exportAndAssignCameras(){const g=Array.from(this._camerasMap.values());for(const i of g){const g=this._nodesCameraMap.get(i);if(void 0!==g){this._cameras.push(i);for(const i of g)i.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const g of this._babylonScene.skeletons){if(g.bones.length<=0)continue;const i={joints:[]};this._skinMap.set(g,i)}}_exportAndAssignSkeletons(){for(const g of this._babylonScene.skeletons){if(g.bones.length<=0)continue;const i=this._skinMap.get(g);if(void 0==i)continue;const a={},n=[];let d=-1;for(let L=0;L<g.bones.length;++L){const i=g.bones[L],n=i.getIndex()??L;-1!==n&&(a[n]=i,n>d&&(d=n))}for(let g=0;g<=d;++g){const d=a[g];n.push(d.getAbsoluteInverseBindMatrix());const b=d.getTransformNode();if(null!==b){const g=this._nodeMap.get(b);b&&null!==g&&void 0!==g?i.joints.push(g):L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else L.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const b=this._nodesSkinMap.get(i);if(i.joints.length>0&&void 0!==b){const g=64*n.length,a=new Float32Array(g/4);n.forEach(((g,i)=>{a.set(g.m,16*i)}));const L=this._bufferManager.createBufferView(a);this._accessors.push(this._bufferManager.createAccessor(L,"MAT4",5126,n.length)),i.inverseBindMatrices=this._accessors.length-1,this._skins.push(i);for(const i of b)i.skin=this._skins.length-1}}}async _exportSceneAsync(){const g={nodes:[]};if(this._babylonScene.metadata){const i=this._options.metadataSelector(this._babylonScene.metadata);i&&(g.extras=i)}const i=new Array,a=new Array,n=new Array;for(const k of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&bg(k,this._babylonScene.useRightHandedSystem)?n.push(...k.getChildren()):this._babylonScene.useRightHandedSystem?i.push(k):a.push(k);this._listAvailableCameras(),this._listAvailableSkeletons();const L=new mi(!0,!1);g.nodes.push(...await this._exportNodesAsync(a,L));const d=new mi(!1,!1);g.nodes.push(...await this._exportNodesAsync(i,d));const b=new mi(!1,!0);g.nodes.push(...await this._exportNodesAsync(n,b)),g.nodes.length&&this._scenes.push(g),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Eg._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,L.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(g){let i=this._shouldExportNodeMap.get(g);return void 0===i&&(i=this._options.shouldExportNode(g),this._shouldExportNodeMap.set(g,i)),i}async _exportNodesAsync(g,i){const a=new Array;this._exportBuffers(g,i);for(const n of g)await this._exportNodeAsync(n,a,i);return a}_collectBuffers(g,i,a,n,L){if(this._shouldExportNode(g)&&g instanceof j.d&&g.wd){const d=g.wd.getVertexBuffers();if(d)for(const n in d){if(!H(n))continue;const b=d[n];L.setHasVertexColorAlpha(b,g.hasVertexAlpha);const k=b._buffer,e=i.get(k)||[];i.set(k,e),-1===e.indexOf(b)&&e.push(b);const N=a.get(b)||[];a.set(b,N),-1===N.indexOf(g)&&N.push(g)}const b=g.morphTargetManager;if(b)for(let i=0;i<b.numTargets;i++){const a=b.getTarget(i),L=n.get(a)||[];n.set(a,L),-1===L.indexOf(g)&&L.push(g)}}for(const d of g.getChildren())this._collectBuffers(d,i,a,n,L)}_exportBuffers(g,i){const a=new Map,n=new Map,L=new Map;for(const k of g)this._collectBuffers(k,a,n,L,i);const d=Array.from(a.keys());for(const k of d){const g=k.getData();if(!g)throw new Error("Buffer data is not available");const L=a.get(k);if(!L)continue;const d=L[0].byteStride;if(L.some((g=>g.byteStride!==d)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const b=ag(g).slice();for(const i of L){const g=n.get(i),{byteOffset:a,byteStride:L,componentCount:d,type:k,count:e,normalized:N,kind:I}=o(i,g);switch(I){case F.g.NormalKind:case F.g.TangentKind:(0,t.j)(b,a,L,d,k,e,N,(g=>{const i=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]);if(i>0){const a=1/i;g[0]*=a,g[1]*=a,g[2]*=a}}));break;case F.g.ColorKind:{const i=g.filter((g=>g.material instanceof cg.pi||null==g.material)).length;if(0==i)break;if(i!=g.length){A.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}k==F.g.UNSIGNED_BYTE&&A.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const n=new D.Ri,I=new D.Hd,j=this._babylonScene.getEngine().useExactSrgbConversions;(0,t.j)(b,a,L,d,k,e,N,(g=>{3===g.length?(n.ya(g,0),n.toLinearSpaceToRef(n,j),n.toArray(g,0)):(I.ya(g,0),I.toLinearSpaceToRef(I,j),I.toArray(g,0))}))}}}if(i.convertToRightHanded){for(const g of L){const i=n.get(g),{byteOffset:a,byteStride:L,componentCount:d,type:k,count:e,normalized:N,kind:I}=o(g,i);switch(I){case F.g.PositionKind:case F.g.NormalKind:case F.g.TangentKind:(0,t.j)(b,a,L,d,k,e,N,(g=>{g[0]=-g[0]}))}}i.convertedToRightHandedBuffers.set(k,b)}const e=this._bufferManager.createBufferView(b,d);i.setVertexBufferView(k,e);const N=new Map;for(const i of L){const g=n.get(i),{kind:a,totalVertices:L}=o(i,g);switch(a){case F.g.MatricesIndicesKind:case F.g.MatricesIndicesExtraKind:if(i.type==F.g.FLOAT){const g=i.getFloatData(L);null!==g&&N.set(i,g)}}}0!==N.size&&A.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const I=Array.from(N.keys());for(const a of I){const g=N.get(a);if(!g)continue;const n=g.some((g=>g>=256)),L=new(n?Uint16Array:Uint8Array)(g.length);for(let i=0;i<g.length;i++)L[i]=g[i];const d=this._bufferManager.createBufferView(L,4*(n?2:1));i.setRemappedBufferView(k,a,d)}}const b=Array.from(L.keys());for(const k of b){const g=L.get(k);if(!g)continue;const a=Xg(k,g[0],this._bufferManager,this._bufferViews,this._accessors,i.convertToRightHanded);for(const n of g)i.bindMorphDataToMesh(n,a)}}async _exportNodeAsync(g,i,a){let n=this._nodeMap.get(g);if(void 0!==n)return void(i.includes(n)||i.push(n));const L=await this._createNodeAsync(g,a);if(L){n=this._nodes.length,this._nodes.push(L),this._nodeMap.set(g,n),a.pushExportedNode(g),i.push(n);const d={name:"runtime animations",channels:[],samplers:[]},b=[];this._babylonScene.animationGroups.length||(Eg._CreateMorphTargetAnimationFromMorphTargetAnimations(g,d,b,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,a.convertToRightHanded,this._options.shouldExportAnimation),g.animations.length&&Eg._CreateNodeAnimationFromNodeAnimations(g,d,b,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,a.convertToRightHanded,this._options.shouldExportAnimation)),d.channels.length&&d.samplers.length&&this._animations.push(d),b.forEach((g=>{g.channels.length&&g.samplers.length&&this._animations.push(g)}))}const d=L?[]:i;for(const b of g.getChildren())await this._exportNodeAsync(b,d,a);L&&d.length&&(L.children=d)}async _createNodeAsync(g,i){if(!this._shouldExportNode(g))return null;const a={};if(g.name&&(a.name=g.name),g.metadata){const i=this._options.metadataSelector(g.metadata);i&&(a.extras=i)}if(g instanceof I.c&&(this._setNodeTransformation(a,g,i.convertToRightHanded),g instanceof j.d)){const L=g instanceof y.d?g.sourceMesh:g;if(L.Yd&&L.Yd.length>0&&(a.mesh=await this._exportMeshAsync(L,i)),g.skeleton){const i=this._skinMap.get(g.skeleton);var n;if(void 0!==i)void 0===this._nodesSkinMap.get(i)&&this._nodesSkinMap.set(i,[]),null===(n=this._nodesSkinMap.get(i))||void 0===n||n.push(a)}}if(g instanceof O.c){const n=this._camerasMap.get(g);if(n){var L;void 0===this._nodesCameraMap.get(n)&&this._nodesCameraMap.set(n,[]),this._setCameraTransformation(a,g,i.convertToRightHanded);const b=g.parent;if(null!==b&&ig(g,b)){const g=this._nodeMap.get(b);if(void 0!==g){var d;const i=this._nodes[g];return gg(a,i),null===(d=this._nodesCameraMap.get(n))||void 0===d||d.push(i),null}}null===(L=this._nodesCameraMap.get(n))||void 0===L||L.push(a)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",a,g,this._nodeMap,i.convertToRightHanded)?a:(A.b.Warn(`Not exporting node ${g.name}`),null)}_exportIndices(g,i,a,n,L,b,k,e,N){let F=g;N.mode=M(b);const I=k!==d.c.CounterClockWiseSideOrientation,j=!e.wasAddedByNoopNode&&I,y=function(g){switch(g){case d.c.TriangleFillMode:case d.c.TriangleStripDrawMode:case d.c.TriangleFanDrawMode:return!0}return!1}(b)&&j;if(y){if(b===d.c.TriangleStripDrawMode||b===d.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");N.mode=M(b);const k=i?new Uint32Array(n):new Uint16Array(n);if(g)for(let i=0;i+2<n;i+=3)k[i]=g[a+i]+L,k[i+1]=g[a+i+2]+L,k[i+2]=g[a+i+1]+L;else for(let g=0;g+2<n;g+=3)k[g]=g,k[g+1]=g+2,k[g+2]=g+1;F=k}else if(g&&0!==L){const d=i?new Uint32Array(n):new Uint16Array(n);for(let i=0;i<n;i++)d[i]=g[a+i]+L;F=d}if(F){let d=e.getIndicesAccessor(g,a,n,L,y);if(void 0===d){const b=function(g,i,a,n){if(g instanceof Uint16Array||g instanceof Uint32Array)return g;if(g instanceof Int32Array)return new Uint32Array(g.buffer,g.byteOffset,g.length);const L=g.slice(i,i+a);return n?new Uint32Array(L):new Uint16Array(L)}(F,0,n,i),k=this._bufferManager.createBufferView(b),N=i?5125:5123;this._accessors.push(this._bufferManager.createAccessor(k,"SCALAR",N,n,0)),d=this._accessors.length-1,e.setIndicesAccessor(g,a,n,L,y,d)}N.indices=d}}_exportVertexBuffer(g,i,a,n,L,d){const b=g.getKind();if(!H(b))return;if(b.startsWith("uv")&&!this._options.exportUnusedUVs&&(!i||!this._materialNeedsUVsSet.has(i)))return;let k=L.getVertexAccessor(g,a,n);if(void 0===k){const i=L.convertedToRightHandedBuffers.get(g._buffer)||g._buffer.getData(),d=b===F.g.PositionKind?function(g,i,a,n){const{byteOffset:L,byteStride:d,type:b,normalized:k}=i,e=i.getSize(),N=new Array(e).fill(1/0),F=new Array(e).fill(-1/0);return(0,t.j)(g,L+a*d,d,e,b,n*e,k,(g=>{for(let i=0;i<e;i++)N[i]=Math.min(N[i],g[i]),F[i]=Math.max(F[i],g[i])})),{min:N,max:F}}(i,g,a,n):void 0,e=(b===F.g.MatricesIndicesKind||b===F.g.MatricesIndicesExtraKind)&&g.type===F.g.FLOAT,N=e?F.g.UNSIGNED_BYTE:g.type,I=e?void 0:g.normalized,j=e?L.getRemappedBufferView(g._buffer,g):L.getVertexBufferView(g._buffer),y=g.byteOffset+a*g.byteStride;this._accessors.push(this._bufferManager.createAccessor(j,function(g,i){if(g==F.g.ColorKind)return i?"VEC4":"VEC3";switch(g){case F.g.PositionKind:case F.g.NormalKind:return"VEC3";case F.g.TangentKind:case F.g.MatricesIndicesKind:case F.g.MatricesIndicesExtraKind:case F.g.MatricesWeightsKind:case F.g.MatricesWeightsExtraKind:return"VEC4";case F.g.UVKind:case F.g.UV2Kind:case F.g.UV3Kind:case F.g.UV4Kind:case F.g.UV5Kind:case F.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${g}`)}(b,L.hasVertexColorAlpha(g)),N,n,y,d,I)),k=this._accessors.length-1,L.setVertexAccessor(g,a,n,k)}d.attributes[function(g){switch(g){case F.g.PositionKind:return"POSITION";case F.g.NormalKind:return"NORMAL";case F.g.TangentKind:return"TANGENT";case F.g.ColorKind:return"COLOR_0";case F.g.UVKind:return"TEXCOORD_0";case F.g.UV2Kind:return"TEXCOORD_1";case F.g.UV3Kind:return"TEXCOORD_2";case F.g.UV4Kind:return"TEXCOORD_3";case F.g.UV5Kind:return"TEXCOORD_4";case F.g.UV6Kind:return"TEXCOORD_5";case F.g.MatricesIndicesKind:return"JOINTS_0";case F.g.MatricesIndicesExtraKind:return"JOINTS_1";case F.g.MatricesWeightsKind:return"WEIGHTS_0";case F.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${g}`)}(b)]=k}async _exportMaterialAsync(g,i,a,n){let L=this._materialMap.get(g);if(void 0===L){const n=i&&Object.keys(i).some((g=>g.startsWith("uv")));if((g=g instanceof yg.d?g.Wd[a.materialIndex]:g)instanceof Bg.b)L=await this._materialExporter.exportPBRMaterialAsync(g,"image/png",n);else{if(!(g instanceof cg.pi))return void A.b.Warn(`Unsupported material '${g.name}' with type ${g.getClassName()}`);L=await this._materialExporter.exportStandardMaterialAsync(g,"image/png",n)}this._materialMap.set(g,L)}n.material=L}async _exportMeshAsync(g,i){var a;let n=i.getMesh(g);if(void 0!==n)return n;const L={primitives:[]};n=this._meshes.length,this._meshes.push(L),i.setMesh(g,n);const b=g.isUnIndexed?null:g.Ad(),k=null===(a=g.wd)||void 0===a?void 0:a.getVertexBuffers(),e=i.getMorphTargetsFromMesh(g),N=g instanceof vg.d,F=g instanceof sg,I=g.Yd;if(k&&I&&I.length>0)for(const B of I){const a={attributes:{}},n=B.wg()||this._babylonScene.defaultMaterial;if(F){var j,y;const i={name:n.name},L=g,d=D.Ri.White(),b=(null===(j=L.material)||void 0===j?void 0:j.alpha)??1,k=(null===(y=L.greasedLineMaterial)||void 0===y?void 0:y.color)??d;(!k.equalsWithEpsilon(d,z.b)||b<1)&&(i.pbrMetallicRoughness={baseColorFactor:[...k.fd(),b]}),this._materials.push(i),a.material=this._materials.length-1}else if(N){const i={name:n.name},L=g;(!L.color.equalsWithEpsilon(D.Ri.White(),z.b)||L.alpha<1)&&(i.pbrMetallicRoughness={baseColorFactor:[...L.color.fd(),L.alpha]}),this._materials.push(i),a.material=this._materials.length-1}else await this._exportMaterialAsync(n,k,B,a);const I=N||F?d.c.LineListDrawMode:g.overrideRenderingFillMode??n.fillMode,c=n._getEffectiveOrientation(g);this._exportIndices(b,b?(0,t.e)(b,B.indexCount,B.indexStart,B.verticesStart):B.verticesCount>65535,b?B.indexStart:B.verticesStart,b?B.indexCount:B.verticesCount,-B.verticesStart,I,c,i,a);for(const g of Object.values(k))this._exportVertexBuffer(g,n,B.verticesStart,B.verticesCount,i,a);if(e){a.targets=[];for(const g of e)a.targets.push(g.attributes)}L.primitives.push(a),this._extensionsPostExportMeshPrimitive(a)}if(e){L.weights=[],L.extras||(L.extras={}),L.extras.targetNames=[];for(const g of e)L.weights.push(g.influence),L.extras.targetNames.push(g.name)}return n}}rg._ExtensionNames=new Array,rg._ExtensionFactories={};class Qg{static async GLTFAsync(g,i,a){a&&a.exportWithoutWaitingForScene||await g.whenReadyAsync();const n=new rg(g,a),L=await n.generateGLTFAsync(i.replace(/\.[^/.]+$/,""));return n.dispose(),L}static async GLBAsync(g,i,a){a&&a.exportWithoutWaitingForScene||await g.whenReadyAsync();const n=new rg(g,a),L=await n.generateGLBAsync(i.replace(/\.[^/.]+$/,""));return n.dispose(),L}}a(13031);const og="EXT_mesh_gpu_instancing";class ug{constructor(g){this.name=og,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(g,i,a,L,d,b){return await new Promise((g=>{if(i&&a instanceof Rg.e&&a.hasThinInstances&&this._exporter){this._wasUsed=!0;const g=n.Bi.Zero(),L=n.Quaternion.Identity(),k=n.Bi.One(),e=a.thinInstanceGetWorldMatrices(),N=n.TmpVectors.Bi[2],F=n.TmpVectors.Quaternion[1],I=n.TmpVectors.Bi[3];let j=!1,y=!1,B=!1;const c=new Float32Array(3*a.gb),D=new Float32Array(4*a.gb),p=new Float32Array(3*a.gb);let R=0;for(const i of e)i.decompose(I,F,N),d&&(W(N),G(F)),c.set(N.fd(),3*R),D.set(F.normalize().fd(),4*R),p.set(I.fd(),3*R),j=j||!N.equalsWithEpsilon(g),y=y||!F.equalsWithEpsilon(L),B=B||!I.equalsWithEpsilon(k),R++;const x={attributes:{}};j&&(x.attributes.TRANSLATION=this._buildAccessor(c,"VEC3",a.gb,b)),y&&(x.attributes.ROTATION=this._buildAccessor(D,"VEC4",a.gb,b)),B&&(x.attributes.SCALE=this._buildAccessor(p,"VEC3",a.gb,b)),i.extensions=i.extensions||{},i.extensions[og]=x}g(i)}))}_buildAccessor(g,i,a,n){const L=n.createBufferView(g),d=n.createAccessor(L,i,5126,a);return this._exporter._accessors.push(d),this._exporter._accessors.length-1}}rg.RegisterExtension(og,(g=>new ug(g)));var Hg=a(13040),Mg=a(13053),qg=a(13058),Wg=a(13061);function Gg(g){return g===qg.e.PositionKind?"POSITION":g===qg.e.NormalKind?"NORMAL":g===qg.e.ColorKind?"COLOR":g.startsWith(qg.e.UVKind)?"TEX_COORD":"GENERIC"}const Jg={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class gi extends Hg.d{static get DefaultAvailable(){return(0,Hg.h)(gi.DefaultConfiguration)}static get Default(){return gi._Default??(gi._Default=new gi),gi._Default}static ResetDefault(g){gi._Default&&(g||gi._Default.dispose(),gi._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(g,i){return{module:await(i||DracoEncoderModule)({wasmBinary:g})}}_getWorkerContent(){return`${Mg.i}(${Mg.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:gi.DefaultConfiguration)}async _encodeAsync(g,i,a){const n=a?(0,Wg.d)(Jg,a):Jg;if(this._workerPoolPromise){const a=await this._workerPoolPromise;return await new Promise(((L,d)=>{a.push(((a,b)=>{const k=g=>{a.removeEventListener("error",k),a.removeEventListener("message",e),d(g),b()},e=g=>{"encodeMeshDone"===g.data.id&&(a.removeEventListener("error",k),a.removeEventListener("message",e),L(g.data.encodedMeshData),b())};a.addEventListener("error",k),a.addEventListener("message",e);const N=[];for(const i of g)N.push(i.data.buffer);i&&N.push(i.buffer),a.postMessage({id:"encodeMesh",attributes:g,indices:i,options:n},N)}))}))}if(this._modulePromise){const a=await this._modulePromise;return(0,Mg.i)(a.module,g,i,n)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(g,i){if(0==g.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");g instanceof Rg.e&&g.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===i||void 0===i?void 0:i.method)&&(A.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),i.method="MESH_SEQUENTIAL_ENCODING");const a=function(g){let i=g.Ad(void 0,!0);return!i||i instanceof Uint32Array||i instanceof Uint16Array||(i=((0,t.e)(i,i.length)?Uint32Array:Uint16Array).from(i)),i}(g),n=function(g,i){const a=[];for(const n of g.getVerticesDataKinds()){if(null!==i&&void 0!==i&&i.includes(n)){if(n===qg.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const L=g.getVertexBuffer(n),d=L.getSize(),b=(0,t.t)(L.getData(),d,L.type,L.byteOffset,L.byteStride,L.normalized,g.getTotalVertices(),!0);a.push({kind:n,dracoName:Gg(n),size:d,data:b})}return a}(g,null===i||void 0===i?void 0:i.excludedAttributes);return await this._encodeAsync(n,a,i)}}gi.DefaultConfiguration={wasmUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${L.Tools._DefaultCdnUrl}/draco_encoder.js`},gi._Default=null;const ii="KHR_draco_mesh_compression";class ai{get wasUsed(){return this._wasUsed}constructor(g){this.name=ii,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===g.options.meshCompressionMethod&&gi.DefaultAvailable}dispose(){}postExportMeshPrimitive(g,i,a){if(!this.enabled)return;if(4!==g.mode&&5!==g.mode)return void A.b.Warn("Cannot compress primitive with mode "+g.mode+".");const n=[],L=[];let d=null;if(void 0!==g.indices){const b=a[g.indices],k=i.getBufferView(b);d=i.getData(k).slice(),n.push(k),L.push(b)}const b=[];for(const[F,I]of Object.entries(g.attributes)){const g=a[I],d=i.getBufferView(g),e=u(g.type),N=(0,t.t)(i.getData(d),e,g.componentType,g.byteOffset||0,d.byteStride||(0,t.r)(g.componentType)*e,g.normalized||!1,g.count,!0);b.push({kind:F,dracoName:(k=F,"POSITION"===k?"POSITION":"NORMAL"===k?"NORMAL":k.startsWith("COLOR")?"COLOR":k.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:u(g.type),data:N}),n.push(d),L.push(g)}var k;const e={method:g.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},N=gi.Default._encodeAsync(b,d,e).then((a=>{if(!a)return void A.b.Error("Draco encoding failed for primitive.");const d={bufferView:-1,attributes:a.attributeIds},b=i.createBufferView(a.data);i.setBufferView(d,b);for(const g of n)this._bufferViewsUsed.add(g);for(const g of L)this._accessorsUsed.add(g);g.extensions||(g.extensions={}),g.extensions[ii]=d})).catch((g=>{A.b.Error("Draco encoding failed for primitive: "+g)}));this._encodePromises.push(N),this._wasUsed=!0}async preGenerateBinaryAsync(g){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((i=>{g.getPropertiesWithBufferView(i).every((g=>this._accessorsUsed.has(g)))&&g.removeBufferView(i)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}rg.RegisterExtension(ii,(g=>new ai(g)));var ni=a(13065);const Li="KHR_lights_punctual",di={name:"",color:[1,1,1],ib:1,range:Number.MAX_VALUE},bi={innerConeAngle:0,outerConeAngle:Math.PI/4},ki=n.Bi.Backward();class ei{constructor(g){this.name=Li,this.enabled=!0,this.required=!1,this._exporter=g}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Li]=this._lights}async postExportNodeAsync(g,i,a,L,d){return await new Promise((b=>{if(!(a instanceof xg.e))return void b(i);const k=a.getTypeID()==xg.e.LIGHTTYPEID_POINTLIGHT?"point":a.getTypeID()==xg.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":a.getTypeID()==xg.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!k||!(a instanceof ni.c))return A.b.Warn(`${g}: Light ${a.name} is not supported in ${Li}`),void b(i);if(a.falloffType!==xg.e.FALLOFF_GLTF&&A.b.Warn(`${g}: Light falloff for ${a.name} does not match the ${Li} specification!`),!a.position.equalsToFloats(0,0,0)){const g=n.TmpVectors.Bi[0].I(a.position);d&&W(g),i.translation=g.fd()}if("point"!==k){const g=a.direction.normalizeToRef(n.TmpVectors.Bi[0]);d&&W(g);const L=n.Quaternion.FromUnitVectorsToRef(ki,g,n.TmpVectors.Quaternion[0]);n.Quaternion.IsIdentity(L)||(i.rotation=L.fd())}const e={type:k,name:a.name,color:a.ab.fd(),ib:a.ib,range:a.range};if(ng(e,di),"spot"===k){const g=a;e.spot={innerConeAngle:g.innerAngle/2,outerConeAngle:g.angle/2},ng(e.spot,bi)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(e);const N={gd:this._lights.lights.length-1},F=a.parent;if(F&&ig(a,F)){const g=L.get(F);if(g){const a=this._exporter._nodes[g];return gg(i,a),a.extensions||(a.extensions={}),a.extensions[Li]=N,void b(null)}}i.extensions||(i.extensions={}),i.extensions[Li]=N,b(i)}))}}rg.RegisterExtension(Li,(g=>new ei(g)));var Ni=a(12983);const Fi="KHR_materials_anisotropy";class Ii{constructor(g){this.name=Fi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Ni.e&&a.anisotropy.isEnabled&&!a.anisotropy.legacy?(a.anisotropy.texture&&n.push(a.anisotropy.texture),n):[]}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Ni.e){if(!a.anisotropy.isEnabled||a.anisotropy.legacy)return void g(i);this._wasUsed=!0,i.extensions=i.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(a.anisotropy.texture),L={anisotropyStrength:a.anisotropy.ib,anisotropyRotation:a.anisotropy.angle,anisotropyTexture:n??void 0};null!==L.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(a),i.extensions[Fi]=L}g(i)}))}}rg.RegisterExtension(Fi,(g=>new Ii(g)));const ji="KHR_materials_clearcoat";class yi{constructor(g){this.name=ji,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Ni.e&&a.clearCoat.isEnabled?(a.clearCoat.texture&&n.push(a.clearCoat.texture),!a.clearCoat.useRoughnessFromMainTexture&&a.clearCoat.textureRoughness&&n.push(a.clearCoat.textureRoughness),a.clearCoat.bumpTexture&&n.push(a.clearCoat.bumpTexture),n):[]}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Ni.e){if(!a.clearCoat.isEnabled)return void g(i);this._wasUsed=!0,i.extensions=i.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(a.clearCoat.texture);let d;d=a.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(a.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(a.clearCoat.textureRoughness),a.clearCoat.isTintEnabled&&L.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${a.name}`),a.clearCoat.remapF0OnInterfaceChange&&L.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${a.name}`);const b=this._exporter._materialExporter.getTextureInfo(a.clearCoat.bumpTexture),k={clearcoatFactor:a.clearCoat.ib,clearcoatTexture:n??void 0,clearcoatRoughnessFactor:a.clearCoat.roughness,clearcoatRoughnessTexture:d??void 0,clearcoatNormalTexture:b??void 0};null===k.clearcoatTexture&&null===k.clearcoatRoughnessTexture&&null===k.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(a),i.extensions[ji]=k}g(i)}))}}rg.RegisterExtension(ji,(g=>new yi(g)));const Bi="KHR_materials_diffuse_transmission";function ci(g,i){const a=i.subSurface;let n=null;return a.translucencyIntensityTexture?n=a.translucencyIntensityTexture:a.thicknessTexture&&a.useMaskFromThicknessTexture&&(n=a.thicknessTexture),n&&!a.useGltfStyleTextures?(A.b.Warn(`${g}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${i.name}`,1),null):n}class Di{constructor(g){this.name=Bi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];if(a instanceof Bg.b&&this._isExtensionEnabled(a)){const i=ci(g,a);return i&&n.push(i),a.subSurface.translucencyColorTexture&&n.push(a.subSurface.translucencyColorTexture),n}return n}_isExtensionEnabled(g){if(g.unlit)return!1;const i=g.subSurface;return!!i.isTranslucencyEnabled&&(!g.unlit&&!i.useAlbedoToTintTranslucency&&i.useGltfStyleTextures&&1===i.volumeIndexOfRefraction&&0===i.minimumThickness&&0===i.maximumThickness)}postExportMaterialAsync(g,i,a){return new Promise((n=>{if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0;const n=a.subSurface,L=ci(g,a),d=0==n.translucencyIntensity?void 0:n.translucencyIntensity,b=this._exporter._materialExporter.getTextureInfo(L)??void 0,k=!n.translucencyColor||n.translucencyColor.equalsFloats(1,1,1)?void 0:n.translucencyColor.fd(),e=this._exporter._materialExporter.getTextureInfo(n.translucencyColorTexture)??void 0,N={diffuseTransmissionFactor:d,diffuseTransmissionTexture:b,diffuseTransmissionColorFactor:k,diffuseTransmissionColorTexture:e};(b||e)&&this._exporter._materialNeedsUVsSet.add(a),i.extensions=i.extensions||{},i.extensions[Bi]=N}n(i)}))}}rg.RegisterExtension(Bi,(g=>new Di(g)));const pi="KHR_materials_dispersion";class Ri{constructor(){this.name=pi,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(g){if(g.unlit)return!1;const i=g.subSurface;return!(!i.isRefractionEnabled&&!i.isDispersionEnabled)}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0;const g={dispersion:a.subSurface.dispersion};i.extensions=i.extensions||{},i.extensions[pi]=g}g(i)}))}}rg.RegisterExtension(pi,(()=>new Ri));const xi="KHR_materials_emissive_strength";class Ei{constructor(){this.name=xi,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(g,i,a){return await new Promise((g=>{if(!(a instanceof Bg.b))return g(i);const n=a.emissiveColor.fd(),L=Math.max(...n);if(L>1){this._wasUsed=!0,i.extensions||(i.extensions={});const g={emissiveStrength:L},n=a.emissiveColor.scale(1/g.emissiveStrength);i.emissiveFactor=n.fd(),i.extensions[xi]=g}return g(i)}))}}rg.RegisterExtension(xi,(g=>new Ei));const Xi="KHR_materials_ior";class vi{constructor(){this.name=Xi,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(g){return!g.unlit&&(void 0!=g.indexOfRefraction&&1.5!=g.indexOfRefraction)}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0;const g={ior:a.indexOfRefraction};i.extensions=i.extensions||{},i.extensions[Xi]=g}g(i)}))}}rg.RegisterExtension(Xi,(g=>new vi));const Pi="KHR_materials_iridescence";class Yi{constructor(g){this.name=Pi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Ni.e&&a.iridescence.isEnabled?(a.iridescence.texture&&n.push(a.iridescence.texture),a.iridescence.thicknessTexture&&a.iridescence.thicknessTexture!==a.iridescence.texture&&n.push(a.iridescence.thicknessTexture),n):[]}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Ni.e){if(!a.iridescence.isEnabled)return void g(i);this._wasUsed=!0,i.extensions=i.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(a.iridescence.texture),L=this._exporter._materialExporter.getTextureInfo(a.iridescence.thicknessTexture),d={iridescenceFactor:a.iridescence.ib,iridescenceIor:a.iridescence.indexOfRefraction,iridescenceThicknessMinimum:a.iridescence.minimumThickness,iridescenceThicknessMaximum:a.iridescence.maximumThickness,iridescenceTexture:n??void 0,iridescenceThicknessTexture:L??void 0};null===d.iridescenceTexture&&null===d.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(a),i.extensions[Pi]=d}g(i)}))}}rg.RegisterExtension(Pi,(g=>new Yi(g)));const fi="KHR_materials_sheen";class Ci{constructor(g){this.name=fi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){return a instanceof Bg.b&&a.sheen.isEnabled&&a.sheen.texture?[a.sheen.texture]:[]}async postExportMaterialAsync(g,i,a){return await new Promise((g=>{if(a instanceof Bg.b){if(!a.sheen.isEnabled)return void g(i);this._wasUsed=!0,null==i.extensions&&(i.extensions={});const n={sheenColorFactor:a.sheen.color.fd(),sheenRoughnessFactor:a.sheen.roughness??0};null===n.sheenColorTexture&&null===n.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(a),a.sheen.texture&&(n.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(a.sheen.texture)??void 0),a.sheen.textureRoughness&&!a.sheen.useRoughnessFromMainTexture?n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(a.sheen.textureRoughness)??void 0:a.sheen.texture&&a.sheen.useRoughnessFromMainTexture&&(n.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(a.sheen.texture)??void 0),i.extensions[fi]=n}g(i)}))}}rg.RegisterExtension(fi,(g=>new Ci(g)));const Ui="KHR_materials_specular";class Si{constructor(g){this.name=Ui,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Bg.b&&this._isExtensionEnabled(a)?(a.metallicReflectanceTexture&&n.push(a.metallicReflectanceTexture),a.reflectanceTexture&&n.push(a.reflectanceTexture),n):n}_isExtensionEnabled(g){return!g.unlit&&(void 0!=g.metallicF0Factor&&1!=g.metallicF0Factor||void 0!=g.metallicReflectanceColor&&!g.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(g))}_hasTexturesExtension(g){return null!=g.metallicReflectanceTexture||null!=g.reflectanceTexture}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0,i.extensions=i.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(a.metallicReflectanceTexture)??void 0,n=this._exporter._materialExporter.getTextureInfo(a.reflectanceTexture)??void 0,L={specularFactor:1==a.metallicF0Factor?void 0:a.metallicF0Factor,specularTexture:g,specularColorFactor:a.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:a.metallicReflectanceColor.fd(),specularColorTexture:n};this._hasTexturesExtension(a)&&this._exporter._materialNeedsUVsSet.add(a),i.extensions[Ui]=L}g(i)}))}}rg.RegisterExtension(Ui,(g=>new Si(g)));const Vi="KHR_materials_transmission";class Ki{constructor(g){this.name=Vi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Bg.b&&this._isExtensionEnabled(a)?(a.subSurface.thicknessTexture&&n.push(a.subSurface.thicknessTexture),n):n}_isExtensionEnabled(g){if(g.unlit)return!1;const i=g.subSurface;return i.isRefractionEnabled&&void 0!=i.refractionIntensity&&0!=i.refractionIntensity||this._hasTexturesExtension(g)}_hasTexturesExtension(g){return null!=g.subSurface.refractionIntensityTexture}async postExportMaterialAsync(g,i,a){if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0;const n=a.subSurface,L={transmissionFactor:0===n.refractionIntensity?void 0:n.refractionIntensity};if(this._hasTexturesExtension(a)&&this._exporter._materialNeedsUVsSet.add(a),n.refractionIntensityTexture)if(n.useGltfStyleTextures){const g=await this._exporter._materialExporter.exportTextureAsync(n.refractionIntensityTexture,"image/png");g&&(L.transmissionTexture=g)}else A.b.Warn(`${g}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);i.extensions||(i.extensions={}),i.extensions[Vi]=L}return i}}rg.RegisterExtension(Vi,(g=>new Ki(g)));const Ti="KHR_materials_unlit";class li{constructor(){this.name=Ti,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(g,i,a){return new Promise((g=>{let n=!1;a instanceof Bg.b?n=a.unlit:a instanceof cg.pi&&(n=a.disableLighting),n&&(this._wasUsed=!0,null==i.extensions&&(i.extensions={}),i.extensions[Ti]={}),g(i)}))}}rg.RegisterExtension(Ti,(()=>new li));const Zi="KHR_materials_volume";class hi{constructor(g){this.name=Zi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Bg.b&&this._isExtensionEnabled(a)?(a.subSurface.thicknessTexture&&n.push(a.subSurface.thicknessTexture),n):n}_isExtensionEnabled(g){if(g.unlit)return!1;const i=g.subSurface;return!(!i.isRefractionEnabled&&!i.isTranslucencyEnabled)&&(void 0!=i.maximumThickness&&0!=i.maximumThickness||void 0!=i.tintColorAtDistance&&i.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=i.tintColor&&i.tintColor!=D.Ri.White()||this._hasTexturesExtension(g))}_hasTexturesExtension(g){return null!=g.subSurface.thicknessTexture}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Bg.b&&this._isExtensionEnabled(a)){this._wasUsed=!0;const g=a.subSurface,n={thicknessFactor:0==g.maximumThickness?void 0:g.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(g.thicknessTexture)??void 0,attenuationDistance:g.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:g.tintColorAtDistance,attenuationColor:g.tintColor.equalsFloats(1,1,1)?void 0:g.tintColor.fd()};this._hasTexturesExtension(a)&&this._exporter._materialNeedsUVsSet.add(a),i.extensions=i.extensions||{},i.extensions[Zi]=n}g(i)}))}}rg.RegisterExtension(Zi,(g=>new hi(g)));const wi="EXT_materials_diffuse_roughness";class ti{constructor(g){this.name=wi,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,i,a){const n=[];return a instanceof Ni.e&&a._baseDiffuseRoughness?(a._baseDiffuseRoughnessTexture&&n.push(a._baseDiffuseRoughnessTexture),n):[]}postExportMaterialAsync(g,i,a){return new Promise((g=>{if(a instanceof Ni.e){if(!a._baseDiffuseRoughness)return void g(i);this._wasUsed=!0,i.extensions=i.extensions||{};const n=this._exporter._materialExporter.getTextureInfo(a._baseDiffuseRoughnessTexture),L={diffuseRoughnessFactor:a._baseDiffuseRoughness,diffuseRoughnessTexture:n??void 0};null!==L.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(a),i.extensions[wi]=L}g(i)}))}}rg.RegisterExtension(wi,(g=>new ti(g)));const Ai="KHR_texture_transform";class Oi{constructor(){this.name=Ai,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(g,i,a){if(a.Pg()||L.Tools.Warn(`${g}: /*@__KEY__*/"scene" is not defined for Babylon texture ${a.name}!`),(0!==a.uAng||0!==a.vAng)&&(L.Tools.Warn(`${g}: Texture ${a.name} with rotation in the u or v axis is not supported in glTF.`),0!==a.uRotationCenter||0!==a.vRotationCenter))return;const n={};let d=!1;if(0===a.uOffset&&0===a.vOffset||(n.offset=[a.uOffset,a.vOffset],d=!0),1===a.uScale&&1===a.vScale||(n.scale=[a.uScale,a.vScale],d=!0),0!==a.wAng){if(0!==a.uRotationCenter||0!==a.vRotationCenter){if(a.homogeneousRotationInUVTransform&&a.uScale!==a.vScale)return void L.Tools.Warn(`${g}: Texture ${a.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Ai}.`);L.Tools.Warn(`${g}: Texture ${a.name} with non-origin rotation center will be exported using an adjusted offset with ${Ai}.`),n.offset=function(g){const{uOffset:i,vOffset:a,uRotationCenter:n,vRotationCenter:L,uScale:d,vScale:b,wAng:k}=g,e=Math.cos(k),N=Math.sin(k),F=n*d,I=L*b;return[i+(F*(1-e)+I*N),a+(I*(1-e)-F*N)]}(a)}n.rotation=-a.wAng,d=!0}0!==a.coordinatesIndex&&(n.texCoord=a.coordinatesIndex,d=!0),d&&(this._wasUsed=!0,i.extensions||(i.extensions={}),i.extensions[Ai]=n)}}rg.RegisterExtension(Ai,(()=>new Oi));class zi{static CreateSTL(g){let i=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",L=arguments.length>3&&void 0!==arguments[3]&&arguments[3],d=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],b=arguments.length>5&&void 0!==arguments[5]&&arguments[5],k=arguments.length>6&&void 0!==arguments[6]&&arguments[6],e=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const N=function(g,i,a){const L=[3*g[a],3*g[a+1],3*g[a+2]],d=[new n.Bi(i[L[0]],i[L[0]+2],i[L[0]+1]),new n.Bi(i[L[1]],i[L[1]+2],i[L[1]+1]),new n.Bi(i[L[2]],i[L[2]+2],i[L[2]+1])],b=d[0].ci(d[1]),k=d[2].ci(d[1]);return{v:d,n:n.Bi.Cross(k,b).normalize()}},I=function(g,i,a,n){return i=j(g,i,a.x,n),i=j(g,i,a.y,n),j(g,i,a.z,n)},j=function(g,i,a,n){return g.setFloat32(i,a,n),i+4},B=function(g){if(k){let i=g;g instanceof y.d&&(i=g.sourceMesh);const a=i.getVerticesData(F.g.PositionKind,!0,!0);if(!a)return[];const L=n.Bi.Zero();let d;for(d=0;d<a.length;d+=3)n.Bi.TransformCoordinatesFromFloatsToRef(a[d],a[d+1],a[d+2],g.Zd(!0),L).toArray(a,d);return a}return g.getVerticesData(F.g.PositionKind)||[]};k&&(b=!0);let c="",D=0,p=0;if(L){for(let a=0;a<g.length;a++){const i=g[a].Ad();D+=i?i.length/3:0}const i=new ArrayBuffer(84+50*D);c=new DataView(i),p+=80,c.setUint32(p,D,d),p+=4}else e||(c="solid stlmesh\r\n");for(let n=0;n<g.length;n++){const i=g[n];!L&&e&&(c+="solid "+i.name+"\r\n"),!b&&i instanceof Rg.e&&i.bakeCurrentTransformIntoVertices();const a=B(i),k=i.Ad()||[];for(let g=0;g<k.length;g+=3){const i=N(k,a,g);L?(p=I(c,p,i.n,d),p=I(c,p,i.v[0],d),p=I(c,p,i.v[1],d),p=I(c,p,i.v[2],d),p+=2):(c+="\tfacet normal "+i.n.x+" "+i.n.y+" "+i.n.z+"\r\n",c+="\t\touter loop\r\n",c+="\t\t\tvertex "+i.v[0].x+" "+i.v[0].y+" "+i.v[0].z+"\r\n",c+="\t\t\tvertex "+i.v[1].x+" "+i.v[1].y+" "+i.v[1].z+"\r\n",c+="\t\t\tvertex "+i.v[2].x+" "+i.v[2].y+" "+i.v[2].z+"\r\n",c+="\t\tendloop\r\n",c+="\tendfacet\r\n")}!L&&e&&(c+="endsolid "+name+"\r\n")}if(L||e||(c+="endsolid stlmesh"),i){const g=document.createElement("a"),i=new Blob([c],{type:"application/octet-stream"});g.href=window.URL.createObjectURL(i),g.download=a+".stl",g.click()}return c}}function si(g,i){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const n=[];for(let L=0;L<g.length/a;L++){const d=g[L*a],b=g[L*a+1],k=g[L*a+2];n.push(`(${d.toPrecision(i.precision)}, ${b.toPrecision(i.precision)}, ${k.toPrecision(i.precision)})`)}return n.join(", ")}function ma(g,i){const a=[];for(let n=0;n<g.length/2;n++){const L=g[2*n],d=g[2*n+1];a.push(`(${L.toPrecision(i.precision)}, ${(1-d).toPrecision(i.precision)})`)}return a.join(", ")}function ri(g,i){const a=g.getVerticesData(F.g.PositionKind),n=g.getVerticesData(F.g.NormalKind);if(a&&n)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(g){var i;const a=null!==(i=g.Ad())&&void 0!==i&&i.length?g.getTotalIndices():g.getTotalVertices();return Array(a/3).fill(3).join(", ")}(g)}]\n\t\tint[] faceVertexIndices = [${function(g){const i=g.Ad(),a=[];if(null!==i)for(let n=0;n<i.length;n++)a.push(i[n]);else{const i=g.getTotalVertices();for(let g=0;g<i;g++)a.push(g)}return a.join(", ")}(g)}]\n\t\tnormal3f[] normals = [${si(n,i)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${si(a,i)}]\n        ${function(g,i){let a="";for(let L=0;L<4;L++){const n=L>0?L:"",d=g.getVerticesData(F.g.UVKind+(n?n+1:""));d&&(a+=`\n\t\ttexCoord2f[] primvars:st${n} = [${ma(d,i)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const n=g.getVerticesData(F.g.ColorKind);return n&&(a+=`\n\tcolor3f[] primvars:displayColor = [${si(n,i,n.length/g.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),a}(g,i)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Qi(g,i){return`\n        def "Geometry"\n        {\n        ${ri(g,i)}\n        }\n        `}function oi(g){let i='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return i+=g,fflate.strToU8(i)}function ui(g){const i=g.m;return`( ${Hi(i,0)}, ${Hi(i,4)}, ${Hi(i,8)}, ${Hi(i,12)} )`}function Hi(g,i){return`(${g[i+0]}, ${g[i+1]}, ${g[i+2]}, ${g[i+3]})`}function Mi(g){const i="Object_"+g.uniqueId,a=function(g){const i=g.getWorldMatrix().clone(),a=g.Pg().useRightHandedSystem;if(!a){let n=g.parent;for(;n;){if(bg(n,a)){i.multiplyToRef(n.getWorldMatrix().invert(),i);break}n=n.parent}}return i.determinant()<0&&L.Tools.Warn(`Exporting mesh ${g.name} with negative scale. Result may look incorrect in destination engine.`),i}(g),n=ui(a);return`def Xform "${i}" (\n\tprepend references = @./geometries/Geometry_${g.wd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${n}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${g.material.uniqueId}>\n}\n\n`}function qi(g){switch(g){case P.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case P.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case P.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Wi(g){return`(${g.x}, ${g.y})`}function Gi(g){return`(${g.r}, ${g.g}, ${g.b})`}function Ji(g,i,a,L,d,b){const k=g.getInternalTexture().uniqueId+"_"+g.invertY;d[k]=g;const e=g.coordinatesIndex>0?"st"+g.coordinatesIndex:"st",N=new n.Vector2(g.uScale,g.vScale),F=new n.Vector2(g.uOffset,g.vOffset),I=g.wAng,j=Math.sin(I),y=Math.cos(I);return F.y=1-F.y-N.y,F.x+=j*N.x,F.y+=(1-y)*N.y,`\n    def Shader "PrimvarReader_${a}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${e}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${a}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${i.uniqueId}/PrimvarReader_${a}.outputs:result>\n        float inputs:rotation = ${(I*(180/Math.PI)).toFixed(b.precision)}\n        float2 inputs:scale = ${Wi(N)}\n        float2 inputs:translation = ${Wi(F)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${g.uniqueId}_${a}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${k}.png@\n        float2 inputs:st.connect = </Materials/Material_${i.uniqueId}/Transform2d_${a}.outputs:result>\n        ${L?"float4 inputs:scale = "+function(g){return`(${g.r}, ${g.g}, ${g.b}, 1.0)`}(L):""}\n        token inputs:sourceColorSpace = "${g.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${qi(g.wrapU)}"\n        token inputs:wrapT = "${qi(g.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${i.needAlphaBlending()?"float outputs:a":""}\n    }`}function ga(g,i,a){const n="\t\t\t",L=[],d=[],{diffuseMap:b,ab:k,alphaCutOff:e,emissiveMap:N,emissive:F,normalMap:I,roughnessMap:j,roughnessChannel:y,roughness:B,metalnessMap:c,metalnessChannel:p,metalness:R,aoMap:x,aoMapChannel:E,aoMapIntensity:X,alphaMap:v,ior:P,clearCoatEnabled:Y,clearCoat:f,clearCoatMap:C,clearCoatRoughness:U,clearCoatRoughnessMap:S}=function(g){const i={diffuseMap:null,ab:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return g instanceof cg.pi?{...i,diffuseMap:g.diffuseTexture,ab:g.diffuseColor,alphaCutOff:g.alphaCutOff,emissiveMap:g.emissiveTexture,emissive:g.emissiveColor,roughness:1,alphaMap:g.opacityTexture}:g instanceof Ni.e?{...i,diffuseMap:g._albedoTexture,ab:g._albedoColor,alphaCutOff:g._alphaCutOff,emissiveMap:g._emissiveTexture,emissive:g._emissiveColor,normalMap:g._bumpTexture,roughnessMap:g._metallicTexture,roughnessChannel:g._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:g._roughness??1,metalnessMap:g._metallicTexture,metalnessChannel:g._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:g._metallic??0,aoMap:g._ambientTexture,aoMapChannel:g._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:g._ambientTextureStrength,alphaMap:g._opacityTexture,ior:g.subSurface.indexOfRefraction,clearCoatEnabled:g.clearCoat.isEnabled,clearCoat:g.clearCoat.ib,clearCoatMap:g.clearCoat.texture,clearCoatRoughness:g.clearCoat.roughness,clearCoatRoughnessMap:g.clearCoat.useRoughnessFromMainTexture?g.clearCoat.texture:g.clearCoat.textureRoughness}:i}(g);return null!==b?(L.push(`${n}color3f inputs:diffuseColor.connect = </Materials/Material_${g.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:rgb>`),g.needAlphaBlending()?L.push(`${n}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:a>`):g.needAlphaTesting()&&(L.push(`${n}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${b.uniqueId}_diffuse.outputs:a>`),L.push(`${n}float inputs:opacityThreshold = ${e}`)),d.push(Ji(b,g,"diffuse",k,i,a))):L.push(`${n}color3f inputs:diffuseColor = ${Gi(k||D.Ri.White())}`),null!==N?(L.push(`${n}color3f inputs:emissiveColor.connect = </Materials/Material_${g.uniqueId}/Texture_${N.uniqueId}_emissive.outputs:rgb>`),d.push(Ji(N,g,"emissive",F,i,a))):F&&F.toLuminance()>0&&L.push(`${n}color3f inputs:emissiveColor = ${Gi(F)}`),null!==I&&(L.push(`${n}normal3f inputs:normal.connect = </Materials/Material_${g.uniqueId}/Texture_${I.uniqueId}_normal.outputs:rgb>`),d.push(Ji(I,g,"normal",null,i,a))),null!==x&&(L.push(`${n}float inputs:occlusion.connect = </Materials/Material_${g.uniqueId}/Texture_${x.uniqueId}_occlusion.outputs:${E}>`),d.push(Ji(x,g,"occlusion",new D.Ri(X,X,X),i,a))),null!==j?(L.push(`${n}float inputs:roughness.connect = </Materials/Material_${g.uniqueId}/Texture_${j.uniqueId}_roughness.outputs:${y}>`),d.push(Ji(j,g,"roughness",new D.Ri(B,B,B),i,a))):L.push(`${n}float inputs:roughness = ${B}`),null!==c?(L.push(`${n}float inputs:metallic.connect = </Materials/Material_${g.uniqueId}/Texture_${c.uniqueId}_metallic.outputs:${p}>`),d.push(Ji(c,g,"metallic",new D.Ri(R,R,R),i,a))):L.push(`${n}float inputs:metallic = ${R}`),null!==v?(L.push(`${n}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${v.uniqueId}_opacity.outputs:r>`),L.push(`${n}float inputs:opacityThreshold = 0.0001`),d.push(Ji(v,g,"opacity",null,i,a))):L.push(`${n}float inputs:opacity = ${g.alpha}`),Y&&(null!==C?(L.push(`${n}float inputs:clearcoat.connect = </Materials/Material_${g.uniqueId}/Texture_${C.uniqueId}_clearcoat.outputs:r>`),d.push(Ji(C,g,"clearcoat",new D.Ri(f,f,f),i,a))):L.push(`${n}float inputs:clearcoat = ${f}`),null!==S?(L.push(`${n}float inputs:clearcoatRoughness.connect = </Materials/Material_${g.uniqueId}/Texture_${S.uniqueId}_clearcoatRoughness.outputs:g>`),d.push(Ji(S,g,"clearcoatRoughness",new D.Ri(U,U,U),i,a))):L.push(`${n}float inputs:clearcoatRoughness = ${U}`)),L.push(`${n}float inputs:ior = ${P}`),`\n\tdef Material "Material_${g.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${L.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${g.uniqueId}/PreviewSurface.outputs:surface>\n\n${d.join("\n")}\n\n\t}\n`}async function ia(g,i,a){const d={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...i};"undefined"===typeof fflate&&await L.Tools.LoadScriptAsync(d.fflateUrl);const b={};b[d.modelFileName]=null;let k='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';k+=function(g){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===g.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${g.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${g.planeAnchoringAlignment}"`:""}\n            `}(d);const e={};for(const n of g.meshes){if(0===n.getTotalVertices())continue;const g=n,i=g.wd,N=g.material;if(!N||!i||a&&!a(g))continue;if(-1!==["pi","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(N.getClassName())){const a="geometries/Geometry_"+i.uniqueId+".usda";if(!(a in b)){const g=Qi(i,d);b[a]=oi(g)}N.uniqueId in e||(e[N.uniqueId]=N),k+=Mi(g)}else L.Tools.Warn("USDZExportAsync does not support this material type: "+N.getClassName())}g.activeCamera&&d.exportCamera&&(k+=function(g,i){const a="Camera_"+g.uniqueId,L=ui(n.Matrix.RotationY(Math.PI).multiply(g.getWorldMatrix()));if(g.mode===P.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${a}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${g.Vd.toPrecision(i.precision)}, ${g.maxZ.toPrecision(i.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(g.orthoLeft||1)+Math.abs(g.orthoRight||1))).toPrecision(i.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(g.orthoTop||1)+Math.abs(g.orthoBottom||1))).toPrecision(i.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const n=g.getEngine().getAspectRatio(g),d=i.cameraSensorWidth||35;return`def Camera "${a}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${L}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${g.Vd.toPrecision(i.precision)}, ${g.maxZ.toPrecision(i.precision)})\n\t\t\tfloat focalLength = ${(d/(2*Math.tan(.5*g.fov))).toPrecision(i.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(d*n).toPrecision(i.precision)}\n\t\t\tfloat verticalAperture = ${(d/n).toPrecision(i.precision)}            \n\t\t}\n\t\n\t`}}(g.activeCamera,d)),k+="\n            }\n        }\n    }";const N={};k+=function(g,i,a){const n=[];for(const L in g){const d=g[L];n.push(ga(d,i,a))}return`\n    def "Materials"\n{\n${n.join("")}\n}\n\n`}(e,N,d),b[d.modelFileName]=fflate.strToU8(k);for(const n in N){const g=N[n],i=g.getSize(),a=await g.readPixels();if(!a)throw new Error("Texture data is not available");const L=await Y.DumpTools.DumpDataAsync(i.width,i.height,a,"image/png",void 0,!1,!0);b[`textures/Texture_${n}.png`]=new Uint8Array(L).slice()}let F=0;for(const n in b){const g=b[n];if(!g)continue;F+=34+n.length;const i=63&F;if(4!==i){const a=new Uint8Array(64-i);b[n]=[g,{extra:{12345:a}}]}F=g.length}return fflate.zipSync(b,{level:0})}}}]);