"use strict";(self.r00gjvkwa6=self.r00gjvkwa6||[]).push([[26],{11714:(H,O,S)=>{S.r(O),S.d(O,{EXT_materials_diffuse_roughness:()=>uO,EXT_mesh_gpu_instancing:()=>sH,GLTF2Export:()=>ZH,GLTFData:()=>w,KHR_draco_mesh_compression:()=>SO,KHR_lights_punctual:()=>VO,KHR_materials_anisotropy:()=>hO,KHR_materials_clearcoat:()=>jO,KHR_materials_diffuse_transmission:()=>EO,KHR_materials_dispersion:()=>TO,KHR_materials_emissive_strength:()=>bO,KHR_materials_ior:()=>FO,KHR_materials_iridescence:()=>lO,KHR_materials_sheen:()=>vO,KHR_materials_specular:()=>mO,KHR_materials_transmission:()=>WO,KHR_materials_unlit:()=>NO,KHR_materials_volume:()=>kO,KHR_texture_transform:()=>PO,OBJExport:()=>G,STLExport:()=>fO,USDZExportAsync:()=>OS,_ConvertToGLTFPBRMetallicRoughness:()=>g,_SolveMetallic:()=>W,__IGLTFExporterExtension:()=>U});var t=S(11301),q=S(11131),p=S(11624);class G{static OBJ(H,O,S,G){const U=[];let V=1,w=1;O&&(S||(S="mat"),U.push("mtllib "+S+".mtl"));for(let o=0;o<H.length;o++){const S=H[o],h=S.name||`mesh${o}}`;U.push(`o ${h}`);let a=null;if(G){const H=S.wU(!0);a=new t.Matrix,H.invertToRef(a),S.bakeTransformIntoVertices(H)}if(O){const H=S.material;H&&U.push("usemtl "+H.id)}const j=S.oU;if(!j){q.Tools.Warn("No geometry is present on the mesh");continue}const e=j.getVerticesData("position"),X=j.getVerticesData("normal"),E=j.getVerticesData("uv"),y=j.hU();let T=0,K=0;if(!e||!y){q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const b=H[0].YH().useRightHandedSystem?1:-1;for(let H=0;H<e.length;H+=3)U.push("v "+e[H]*b+" "+e[H+1]+" "+e[H+2]),T++;if(null!=X)for(let H=0;H<X.length;H+=3)U.push("vn "+X[H]*b+" "+X[H+1]+" "+X[H+2]);if(null!=E)for(let H=0;H<E.length;H+=2)U.push("vt "+E[H]+" "+E[H+1]),K++;const D=["","",""],F=(S.material||S.YH().defaultMaterial)._getEffectiveOrientation(S),[Y,l]=F===p.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let H=0;H<y.length;H+=3){const O=[String(y[H]+V),String(y[H+Y]+V),String(y[H+l]+V)],S=[String(y[H]+w),String(y[H+Y]+w),String(y[H+l]+w)],t=O,q=null!=E?S:D,p=null!=X?O:D;U.push("f "+t[0]+"/"+q[0]+"/"+p[0]+" "+t[1]+"/"+q[1]+"/"+p[1]+" "+t[2]+"/"+q[2]+"/"+p[2])}G&&a&&S.bakeTransformIntoVertices(a),V+=T,w+=K}return U.join("\n")}static MTL(H){const O=[],S=H.material;O.push("newmtl mat1"),O.push("  Ns "+S.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+S.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+S.ambientColor.r.toFixed(4)+" "+S.ambientColor.g.toFixed(4)+" "+S.ambientColor.b.toFixed(4)),O.push("  Kd "+S.diffuseColor.r.toFixed(4)+" "+S.diffuseColor.g.toFixed(4)+" "+S.diffuseColor.b.toFixed(4)),O.push("  Ks "+S.specularColor.r.toFixed(4)+" "+S.specularColor.g.toFixed(4)+" "+S.specularColor.b.toFixed(4)),O.push("  Ke "+S.emissiveColor.r.toFixed(4)+" "+S.emissiveColor.g.toFixed(4)+" "+S.emissiveColor.b.toFixed(4));S.ambientTexture&&O.push("  map_Ka "+S.ambientTexture.name),S.diffuseTexture&&O.push("  map_Kd "+S.diffuseTexture.name),S.specularTexture&&O.push("  map_Ks "+S.specularTexture.name),S.bumpTexture&&O.push("  map_bump -imfchan z "+S.bumpTexture.name),S.opacityTexture&&O.push("  map_d "+S.opacityTexture.name);return O.join("\n")}}var U=0,V=S(11188);class w{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const H in this.files){const O=this.files[H],S=new Blob([O],{type:(0,V.i)(H)});q.Tools.Download(S,H)}}}var o=S(11378),h=S(11718),a=S(11734),j=S(11749),e=S(11436),X=S(11180),E=S(11355),y=S(11317);const T=y.HighestCommonFactor,K={...y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:T};var b=S(11534),D=S(11279),F=S(11781),Y=S(11783),l=S(11532);const d=1e-6,v=new E.TO(.04,.04,.04),z=1024,m=E.TO.White(),r=E.TO.Black();function W(H,O,S){if(O<v.r)return 0;const t=v.r,q=H*S/(1-v.r)+O-2*v.r,p=q*q-4*t*(v.r-O);return K.Clamp((-q+Math.sqrt(p))/(2*t),0,1)}function g(H){const O=H.diffuseColor.toLinearSpace(H.YH().getEngine().useExactSrgbConversions).scale(.5),S=H.alpha,q=function(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new t.Vector2(0,1),S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new t.Vector2(0,.1),q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new t.Vector2(0,.1),p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new t.Vector2(1300,.1);return function(H,O,S,t,q){return(1-H)*(1-H)*(1-H)*O+3*(1-H)*(1-H)*H*S+3*(1-H)*H*H*t+H*H*H*q}(Math.pow(H/p.x,.333333),O.y,S.y,q.y,p.y)}(K.Clamp(H.specularPower,0,z));return{baseColorFactor:[O.r,O.g,O.b,S],metallicFactor:0,roughnessFactor:q}}function N(H,O){O.needAlphaBlending()?H.alphaMode="BLEND":O.needAlphaTesting()&&(H.alphaMode="MASK",H.alphaCutoff=O.alphaCutOff)}function x(H,O,S){const t=new Uint8Array(H*O*4);for(let q=0;q<t.length;q+=4)t[q]=t[q+1]=t[q+2]=t[q+3]=255;return F.b.CreateRGBATexture(t,H,O,S)}function k(H){if(H instanceof Uint8Array){const O=H.length,S=new Float32Array(H.length);for(let t=0;t<O;++t)S[t]=H[t]/255;return S}if(H instanceof Float32Array)return H;throw new Error("Unsupported pixel format!")}class A{constructor(H){this._exporter=H,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(H){return H?this._textureMap.get(H)??null:null}async exportStandardMaterialAsync(H,O,S){const t=g(H),p={name:H.name};if(null==H.aU||H.aU||(H.twoSidedLighting||q.Tools.Warn(H.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),p.doubleSided=!0),S){const S=[],q=H.diffuseTexture;q&&S.push(this.exportTextureAsync(q,O).then((H=>{H&&(t.baseColorTexture=H)})));const G=H.bumpTexture;G&&S.push(this.exportTextureAsync(G,O).then((H=>{H&&(p.normalTexture=H,1!==G.level&&(p.normalTexture.scale=G.level))})));const U=H.emissiveTexture;U&&(p.emissiveFactor=[1,1,1],S.push(this.exportTextureAsync(U,O).then((H=>{H&&(p.emissiveTexture=H)}))));const V=H.ambientTexture;V&&S.push(this.exportTextureAsync(V,O).then((H=>{if(H){const O={index:H.index};p.occlusionTexture=O}}))),S.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(S))}(H.alpha<1||H.opacityTexture)&&(H.alphaMode===Y.b.ALPHA_COMBINE?p.alphaMode="BLEND":q.Tools.Warn(H.name+": glTF 2.0 does not support alpha mode: "+H.alphaMode.toString())),H.emissiveColor&&!H.emissiveColor.equalsWithEpsilon(r,d)&&(p.emissiveFactor=H.emissiveColor.pU()),p.pbrMetallicRoughness=t,N(p,H),await this._finishMaterialAsync(p,H,O);const G=this._exporter._materials;return G.push(p),G.length-1}async _finishMaterialAsync(H,O,S){const t=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",H,O),q=[];for(const p of t)q.push(this.exportTextureAsync(p,S));await Promise.all(q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",H,O)}async _getImageDataAsync(H,O,t,q){const p=Y.b.TEXTURETYPE_UNSIGNED_BYTE,G=this._exporter._babylonScene,U=G.getEngine(),V=U.createRawTexture(H,O,t,Y.b.TEXTUREFORMAT_RGBA,!1,!0,D.b.NEAREST_SAMPLINGMODE,null,p);U.isWebGPU?await S.e(51).then(S.bind(S,13782)):await S.e(52).then(S.bind(S,13786)),await b.l.ApplyPostProcess("pass",V,G,p,Y.b.TEXTURE_NEAREST_SAMPLINGMODE,Y.b.TEXTUREFORMAT_RGBA);const w=await U._readTexturePixels(V,O,t);return await l.DumpTools.DumpDataAsync(O,t,w,q,void 0,!0,!0)}_resizeTexturesToSameDimensions(H,O,S){const t=H?H.getSize():{width:0,height:0},q=O?O.getSize():{width:0,height:0};let p,G;return t.width<q.width?(p=H&&H instanceof D.b?b.l.CreateResizedCopy(H,q.width,q.height,!0):x(q.width,q.height,S),G=O):t.width>q.width?(G=O&&O instanceof D.b?b.l.CreateResizedCopy(O,t.width,t.height,!0):x(t.width,t.height,S),p=H):(p=H,G=O),{texture1:p,texture2:G}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(H,O,S,t){const q=new Array;if(!H&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const p=H?H.YH():O?O.YH():null;if(p){var G;const U=this._resizeTexturesToSameDimensions(H,O,p),V=null===(G=U.texture1)||void 0===G?void 0:G.getSize();let w,o;const h=V.width,a=V.height,j=await U.texture1.readPixels(),e=await U.texture2.readPixels();if(!j)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(w=k(j),!e)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");o=k(e);const X=o.byteLength,y=new Uint8Array(X),T=new Uint8Array(X),K=4,b=r;let D=0,F=0;for(let H=0;H<a;++H)for(let O=0;O<h;++O){const t=(h*H+O)*K,q={diffuseColor:new E.TO(w[t],w[t+1],w[t+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(S.diffuseColor),specularColor:new E.TO(o[t],o[t+1],o[t+2]).toLinearSpace(p.getEngine().useExactSrgbConversions).multiply(S.specularColor),glossiness:o[t+3]*S.glossiness},G=this._convertSpecularGlossinessToMetallicRoughness(q);b.r=Math.max(b.r,G.baseColor.r),b.g=Math.max(b.g,G.baseColor.g),b.b=Math.max(b.b,G.baseColor.b),D=Math.max(D,G.metallic),F=Math.max(F,G.roughness),T[t]=255*G.baseColor.r,T[t+1]=255*G.baseColor.g,T[t+2]=255*G.baseColor.b,T[t+3]=U.texture1.GU?255*w[t+3]:255,y[t]=0,y[t+1]=255*G.roughness,y[t+2]=255*G.metallic,y[t+3]=255}const Y={baseColor:b,metallic:D,roughness:F};let l=!1,v=!1;for(let H=0;H<a;++H)for(let O=0;O<h;++O){const S=(h*H+O)*K;T[S]/=Y.baseColor.r>d?Y.baseColor.r:1,T[S+1]/=Y.baseColor.g>d?Y.baseColor.g:1,T[S+2]/=Y.baseColor.b>d?Y.baseColor.b:1;const t=E.TO.FromInts(T[S],T[S+1],T[S+2]).toGammaSpace(p.getEngine().useExactSrgbConversions);T[S]=255*t.r,T[S+1]=255*t.g,T[S+2]=255*t.b,t.equalsWithEpsilon(m,d)||(v=!0),y[S+1]/=Y.roughness>d?Y.roughness:1,y[S+2]/=Y.metallic>d?Y.metallic:1;E.TO.FromInts(255,y[S+1],y[S+2]).equalsWithEpsilon(m,d)||(l=!0)}return l&&q.push(this._getImageDataAsync(y,h,a,t).then((H=>{Y.metallicRoughnessTextureData=H}))),v&&q.push(this._getImageDataAsync(T,h,a,t).then((H=>{Y.baseColorTextureData=H}))),await Promise.all(q).then((()=>Y))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(H){const O=this._getPerceivedBrightness(H.diffuseColor),S=this._getPerceivedBrightness(H.specularColor),t=1-this._getMaxComponent(H.specularColor),q=W(O,S,t),p=H.diffuseColor.scale(t/(1-v.r)/Math.max(1-q)),G=H.specularColor.XO(v.scale(1-q)).scale(1/Math.max(q));let U=E.TO.Lerp(p,G,q*q);U=U.clampToRef(0,1,U);return{baseColor:U,metallic:q,roughness:1-H.glossiness}}_getPerceivedBrightness(H){return H?Math.sqrt(.299*H.r*H.r+.587*H.g*H.g+.114*H.b*H.b):0}_getMaxComponent(H){return H?Math.max(H.r,Math.max(H.g,H.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(H,O,S,t){const q=[],p={baseColor:H._albedoColor,metallic:H._metallic,roughness:H._roughness};if(t){H._albedoTexture&&q.push(this.exportTextureAsync(H._albedoTexture,O).then((H=>{H&&(S.baseColorTexture=H)})));const t=H._metallicTexture;t&&q.push(this.exportTextureAsync(t,O).then((H=>{H&&(S.metallicRoughnessTexture=H)})))}return q.length>0&&(this._exporter._materialNeedsUVsSet.add(H),await Promise.all(q)),p}_getTextureSampler(H){const O={};if(!H||!(H instanceof D.b))return O;const S=this._getGLTFTextureWrapMode(H.wrapU);10497!==S&&(O.wrapS=S);const t=this._getGLTFTextureWrapMode(H.wrapV);switch(10497!==t&&(O.wrapT=t),H.samplingMode){case D.b.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case D.b.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case D.b.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case D.b.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case D.b.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case D.b.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case D.b.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case D.b.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case D.b.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case D.b.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case D.b.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case D.b.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(H){switch(H){case D.b.WRAP_ADDRESSMODE:return 10497;case D.b.CLAMP_ADDRESSMODE:return 33071;case D.b.MIRROR_ADDRESSMODE:return 33648;default:return q.Tools.Error(`Unsupported Texture Wrap Mode ${H}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(H,O,S,t){const q={diffuseColor:H._albedoColor,specularColor:H._reflectivityColor,glossiness:H._microSurface},p=H._albedoTexture,G=H._reflectivityTexture,U=H._useMicroSurfaceFromReflectivityMapAlpha;if(G&&!U)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((p||G)&&t){this._exporter._materialNeedsUVsSet.add(H);const t=this._exportTextureSampler(p||G),U=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(p,G,q,O),V=this._exporter._textures;if(U.baseColorTextureData){const H=this._exportImage(`baseColor${V.length}`,O,U.baseColorTextureData);S.baseColorTexture=this._exportTextureInfo(H,t,null===p||void 0===p?void 0:p.coordinatesIndex)}if(U.metallicRoughnessTextureData){const H=this._exportImage(`metallicRoughness${V.length}`,O,U.metallicRoughnessTextureData);S.metallicRoughnessTexture=this._exportTextureInfo(H,t,null===G||void 0===G?void 0:G.coordinatesIndex)}return U}return this._convertSpecularGlossinessToMetallicRoughness(q)}async exportPBRMaterialAsync(H,O,S){const t={},q={name:H.name},p=H.isMetallicWorkflow();if(p){const O=H._albedoColor,S=H.alpha;O&&(t.baseColorFactor=[O.r,O.g,O.b,S])}const G=p?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(H,O,t,S):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(H,O,t,S);await this._setMetallicRoughnessPbrMaterialAsync(G,H,q,t,O,S),await this._finishMaterialAsync(q,H,O);const U=this._exporter._materials;return U.push(q),U.length-1}async _setMetallicRoughnessPbrMaterialAsync(H,O,S,t,p,G){if(N(S,O),H.baseColor.equalsWithEpsilon(m,d)&&K.WithinEpsilon(O.alpha,1,d)||(t.baseColorFactor=[H.baseColor.r,H.baseColor.g,H.baseColor.b,O.alpha]),null!=H.metallic&&1!==H.metallic&&(t.metallicFactor=H.metallic),null!=H.roughness&&1!==H.roughness&&(t.roughnessFactor=H.roughness),null==O.aU||O.aU||(O._twoSidedLighting||q.Tools.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),S.doubleSided=!0),G){const H=[],t=O._bumpTexture;t&&H.push(this.exportTextureAsync(t,p).then((H=>{H&&(S.normalTexture=H,1!==t.level&&(S.normalTexture.scale=t.level))})));const q=O._ambientTexture;q&&H.push(this.exportTextureAsync(q,p).then((H=>{if(H){const t={index:H.index,texCoord:H.texCoord,extensions:H.extensions};S.occlusionTexture=t;const q=O._ambientTextureStrength;q&&(t.strength=q)}})));const G=O._emissiveTexture;G&&H.push(this.exportTextureAsync(G,p).then((H=>{H&&(S.emissiveTexture=H)}))),H.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(H))}const U=O._emissiveColor;U.equalsWithEpsilon(r,d)||(S.emissiveFactor=U.pU()),S.pbrMetallicRoughness=t}_getPixelsFromTextureAsync(H){return function(H){switch(H){case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Y.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Y.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(H.textureFormat)?(0,b.k)(H,H._texture.width,H._texture.height):(H.textureType,Y.b.TEXTURETYPE_UNSIGNED_BYTE,H.readPixels())}async exportTextureAsync(H,O){const S=this._exporter._extensionsPreExportTextureAsync("exporter",H,O);return S?await S.then((async S=>S?await this._exportTextureInfoAsync(S,O):await this._exportTextureInfoAsync(H,O))):await this._exportTextureInfoAsync(H,O)}async _exportTextureInfoAsync(H,O){let S=this._textureMap.get(H);if(!S){const t=await this._getPixelsFromTextureAsync(H);if(!t)return null;const p=this._exportTextureSampler(H),G=H.mimeType;if(G)switch(G){case"image/jpeg":case"image/png":case"image/webp":O=G;break;default:q.Tools.Warn(`Unsupported media type: ${G}. Exporting texture as PNG.`)}const U=this._internalTextureToImage,V=H.getInternalTexture().uniqueId;U[V]||(U[V]={});let w=U[V][O];if(void 0===w){const S=H.getSize();w=(async()=>{const q=await this._getImageDataAsync(t,S.width,S.height,O);return this._exportImage(H.name,O,q)})(),U[V][O]=w}S=this._exportTextureInfo(await w,p,H.coordinatesIndex),this._textureMap.set(H,S),this._exporter._extensionsPostExportTextures("exporter",S,H)}return S}_exportImage(H,O,S){const t=this._exporter._images;let p;if(this._exporter._shouldUseGlb){p={name:H,mimeType:O,bufferView:void 0};const t=this._exporter._bufferManager.createBufferView(new Uint8Array(S));this._exporter._bufferManager.setBufferView(p,t)}else{const G=H.replace(/\.\/|\/|\.\\|\\/g,"_"),U=function(H){switch(H){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let V=G+U;t.some((H=>H.uri===V))&&(V=`${G}_${q.Tools.RandomId()}${U}`),p={name:H,uri:V},this._exporter._imageData[V]={data:S,mimeType:O}}return t.push(p),t.length-1}_exportTextureInfo(H,O,S){const t=this._exporter._textures;let q=t.findIndex((S=>S.sampler==O&&S.source===H));-1===q&&(q=t.length,t.push({source:H,sampler:O}));const p={index:q};return S&&(p.texCoord=S),p}_exportTextureSampler(H){const O=this._getTextureSampler(H),S=this._exporter._samplers,t=S.findIndex((H=>H.minFilter===O.minFilter&&H.magFilter===O.magFilter&&H.wrapS===O.wrapS&&H.wrapT===O.wrapT));return-1!==t?t:(S.push(O),S.length-1)}}var u=S(11386),J=S(11151),P=S(11788),f=S(11307);const c=t.eO.Zero(),R=t.Quaternion.Identity(),B=t.eO.One(),Z=new t.eO(-1,1,1);function I(H,O){const{byteOffset:S,byteStride:t,type:q,normalized:p}=H,G=H.getSize(),U=O.reduce(((H,O)=>O.getTotalVertices()>H?O.getTotalVertices():H),-Number.MAX_VALUE);return{byteOffset:S,byteStride:t,componentCount:G,type:q,count:U*G,normalized:p,totalVertices:U,kind:H.getKind()}}function s(H){switch(H){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function i(H){switch(H){case o.h.PositionKind:case o.h.NormalKind:case o.h.TangentKind:case o.h.ColorKind:case o.h.MatricesIndicesKind:case o.h.MatricesIndicesExtraKind:case o.h.MatricesWeightsKind:case o.h.MatricesWeightsExtraKind:case o.h.UVKind:case o.h.UV2Kind:case o.h.UV3Kind:case o.h.UV4Kind:case o.h.UV5Kind:case o.h.UV6Kind:return!0}return!1}function M(H){switch(H){case p.e.TriangleFillMode:return 4;case p.e.TriangleStripDrawMode:return 5;case p.e.TriangleFanDrawMode:return 6;case p.e.PointListDrawMode:case p.e.PointFillMode:return 0;case p.e.LineLoopDrawMode:return 2;case p.e.LineListDrawMode:return 1;case p.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${H}`)}function C(H){const O=Math.sqrt(H.x*H.x+H.y*H.y+H.z*H.z);O>0&&(H.x/=O,H.y/=O,H.z/=O)}function n(H){return H.x*=-1,H}function Q(H){if(H.x*H.x+H.y*H.y>.5){const O=Math.abs(H.x),S=Math.abs(H.y);if(O>S){const S=Math.sign(H.x);H.x=O,H.y*=-S,H.z*=-S,H.w*=S}else{const O=Math.sign(H.y);H.x*=-O,H.y=S,H.z*=O,H.w*=-O}}else{const O=Math.abs(H.z),S=Math.abs(H.w);if(O>S){const S=Math.sign(H.z);H.x*=-S,H.y*=S,H.z=O,H.w*=-S}else{const O=Math.sign(H.w);H.x*=O,H.y*=-O,H.z*=-O,H.w=S}}return H}function L(H){H.jU(-H.z,H.w,H.x,-H.y)}function HH(H,O){const S=t.eO.FromArrayToRef(O.translation||[0,0,0],0,t.TmpVectors.eO[0]),q=t.Quaternion.FromArrayToRef(O.rotation||[0,0,0,1],0,t.TmpVectors.Quaternion[0]),p=t.Matrix.ComposeToRef(B,q,S,t.TmpVectors.Matrix[0]),G=t.eO.FromArrayToRef(H.translation||[0,0,0],0,t.TmpVectors.eO[2]),U=t.Quaternion.FromArrayToRef(H.rotation||[0,0,0,1],0,t.TmpVectors.Quaternion[1]),V=t.Matrix.ComposeToRef(B,U,G,t.TmpVectors.Matrix[1]);p.multiplyToRef(V,V),V.decompose(void 0,q,S),S.equalsWithEpsilon(c,f.e)?delete O.translation:O.translation=S.pU(),q.equalsWithEpsilon(R,f.e)?delete O.rotation:O.rotation=q.pU(),O.scale&&delete O.scale}function OH(H,O){if(!(O instanceof h.e))return!1;if(!(1===O.getChildren().length&&0===H.getChildren().length&&H.parent===O))return!1;const S=H.YH(),t=H instanceof P.b&&!S.useRightHandedSystem?Z:B;return!!O.eU.equalsWithEpsilon(t,f.e)||(J.b.Warn(`Cannot collapse node ${H.name} into parent node ${O.name} with modified scaling.`),!1)}function SH(H){if(H instanceof Array){const O=new Float32Array(H);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(H)?new Uint8Array(H.buffer,H.byteOffset,H.byteLength):new Uint8Array(H)}function tH(H,O){for(const[S,t]of Object.entries(H)){const q=O[S];(Array.isArray(t)&&Array.isArray(q)&&qH(t,q)||t===q)&&delete H[S]}return H}function qH(H,O){return H.length===O.length&&H.every(((H,S)=>H===O[S]))}const pH=t.Matrix.Compose(new t.eO(-1,1,1),t.Quaternion.Identity(),t.eO.Zero());function GH(H,O){if(!(H instanceof h.e))return!1;if(O){if(!H.getWorldMatrix().equalsWithEpsilon(t.Matrix.IdentityReadOnly,f.e))return!1}else{if(!H.getWorldMatrix().multiplyToRef(pH,t.TmpVectors.Matrix[0]).equalsWithEpsilon(t.Matrix.IdentityReadOnly,f.e))return!1}return!(H instanceof a.e&&H.oU)}const UH=new Map([[Int8Array,(H,O,S)=>H.setInt8(O,S)],[Uint8Array,(H,O,S)=>H.setUint8(O,S)],[Uint8ClampedArray,(H,O,S)=>H.setUint8(O,S)],[Int16Array,(H,O,S)=>H.setInt16(O,S,!0)],[Uint16Array,(H,O,S)=>H.setUint16(O,S,!0)],[Int32Array,(H,O,S)=>H.setInt32(O,S,!0)],[Uint32Array,(H,O,S)=>H.setUint32(O,S,!0)],[Float32Array,(H,O,S)=>H.setFloat32(O,S,!0)],[Float64Array,(H,O,S)=>H.setFloat64(O,S,!0)]]);class VH{writeTypedArray(H){this._checkGrowBuffer(H.byteLength);const O=UH.get(H.constructor);for(let S=0;S<H.length;S++)O(this._dataView,this._byteOffset,H[S]),this._byteOffset+=H.BYTES_PER_ELEMENT}constructor(H){this._data=new Uint8Array(H),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(H){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,H),this._byteOffset++}writeInt8(H){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,H),this._byteOffset++}writeInt16(H){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,H,!0),this._byteOffset+=2}writeUInt16(H){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,H,!0),this._byteOffset+=2}writeInt32(H){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,H,!0),this._byteOffset+=4}writeUInt32(H){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,H,!0),this._byteOffset+=4}writeFloat32(H){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,H,!0),this._byteOffset+=4}writeFloat64(H){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,H,!0),this._byteOffset+=8}_checkGrowBuffer(H){const O=this.byteOffset+H;if(O>this._data.byteLength){const H=new Uint8Array(2*O);H.set(this._data),this._data=H,this._dataView=new DataView(this._data.buffer)}}}function wH(H){return H%4===0?4:H%2===0?2:1}class oH{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(H){let O=0;this._bufferViewToData.forEach((H=>{O+=H.byteLength}));const S=new VH(O),t=Array.from(this._bufferViewToData.keys()).sort(((H,O)=>wH(O.byteLength)-wH(H.byteLength)));for(const q of t){q.byteOffset=S.byteOffset,H.push(q);const O=H.length-1,t=this.getPropertiesWithBufferView(q);for(const H of t)H.bufferView=O;S.writeTypedArray(this._bufferViewToData.get(q)),this._bufferViewToData.delete(q)}return S.getOutputData()}createBufferView(H,O){const S={buffer:0,byteOffset:void 0,byteLength:H.byteLength,byteStride:O};return this._bufferViewToData.set(S,H),S}createAccessor(H,O,S,t,q,p,G){this._verifyBufferView(H);const U={bufferView:void 0,componentType:S,count:t,type:O,min:null===p||void 0===p?void 0:p.min,max:null===p||void 0===p?void 0:p.max,normalized:G,byteOffset:q};return this.setBufferView(U,H),this._accessorToBufferView.set(U,H),U}setBufferView(H,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(H)}removeBufferView(H){const O=this.getPropertiesWithBufferView(H);for(const S of O)void 0!==S.bufferView&&delete S.bufferView;this._bufferViewToData.delete(H),this._bufferViewToProperties.delete(H),this._accessorToBufferView.forEach(((O,S)=>{O===H&&(void 0!==S.byteOffset&&delete S.byteOffset,this._accessorToBufferView.delete(S))}))}getBufferView(H){const O=this._accessorToBufferView.get(H);return this._verifyBufferView(O),O}getPropertiesWithBufferView(H){return this._verifyBufferView(H),this._bufferViewToProperties.set(H,this._bufferViewToProperties.get(H)??[]),this._bufferViewToProperties.get(H)}getData(H){return this._verifyBufferView(H),this._bufferViewToData.get(H)}_verifyBufferView(H){if(void 0===H||!this._bufferViewToData.has(H))throw new Error(`BufferView ${H} not found in BufferManager.`)}}var hH,aH=S(11764),jH=S(11776),eH=S(11791),XH=S(11675),EH=S(11831),yH=S(11842),TH=S(11757),KH=S(11851);!function(H){H[H.INTANGENT=0]="INTANGENT",H[H.OUTTANGENT=1]="OUTTANGENT"}(hH||(hH={}));class bH{static _IsTransformable(H){return H&&(H instanceof h.e||H instanceof aH.d||H instanceof KH.b)}static _CreateNodeAnimation(H,O,S,t,p){if(this._IsTransformable(H)){const G=[],U=[],V=O.getKeys(),w=bH._CalculateMinMaxKeyFrames(V),o=bH._DeduceInterpolation(V,S,t),h=o.interpolationType,a=o.shouldBakeAnimation;if(a?bH._CreateBakedAnimation(H,O,S,w.min,w.max,O.framePerSecond,p,G,U,w,t):"LINEAR"===h||"STEP"===h?bH._CreateLinearOrStepAnimation(H,O,S,G,U,t):"CUBICSPLINE"===h?bH._CreateCubicSplineAnimation(H,O,S,G,U,t):bH._CreateBakedAnimation(H,O,S,w.min,w.max,O.framePerSecond,p,G,U,w,t),G.length&&U.length){return{inputs:G,outputs:U,samplerInterpolation:h,inputsMin:a?w.min:q.Tools.FloatRound(w.min/O.framePerSecond),inputsMax:a?w.max:q.Tools.FloatRound(w.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(H){let O=null,S="VEC3",t=!1;const p=H.targetProperty.split(".");switch(p[0]){case"eU":O="scale";break;case"position":O="translation";break;case"rotation":S="VEC4",O="rotation";break;case"rotationQuaternion":S="VEC4",t=!0,O="rotation";break;case"influence":S="SCALAR",O="weights";break;default:q.Tools.Error(`Unsupported animatable property ${p[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:S,useQuaternion:t}:(q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(H,O,S,t,q,p,G,U,V,w,o){let h;if(bH._IsTransformable(H)&&H.animations)for(const a of H.animations){if(o&&!o(a))continue;const q=bH._DeduceAnimationInfo(a);q&&(h={name:a.name,samplers:[],channels:[]},bH._AddAnimation(`${a.name}`,a.hasRunningRuntimeAnimations?O:h,H,a,q.dataAccessorType,q.animationChannelTargetPath,t,p,G,U,q.useQuaternion,V,w),h.samplers.length&&h.channels.length&&S.push(h))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(H,O,S,t,q,p,G,U,V,w,o){let h;if(H instanceof TH.d){const q=H.morphTargetManager;if(q)for(let a=0;a<q.numTargets;++a){const j=q.getTarget(a);for(const e of j.animations){if(o&&!o(e))continue;const j=new EH.d(`${e.name}`,"influence",e.framePerSecond,e.dataType,e.loopMode,e.enableBlending),X=[],E=e.getKeys();for(let H=0;H<E.length;++H){const O=E[H];for(let H=0;H<q.numTargets;++H)H==a?X.push(O):X.push({frame:O.frame,value:0})}j.setKeys(X);const y=bH._DeduceAnimationInfo(j);y&&(h={name:j.name,samplers:[],channels:[]},bH._AddAnimation(e.name,e.hasRunningRuntimeAnimations?O:h,H,j,y.dataAccessorType,y.animationChannelTargetPath,t,p,G,U,y.useQuaternion,V,w,q.numTargets),h.samplers.length&&h.channels.length&&S.push(h))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(H,O,S,t,q,p,G,U,V){let w;if(H.animationGroups){const h=H.animationGroups;for(const a of h){const h=new Map,j=new Map,e=new Set,X=a.to-a.from;w={name:a.name,channels:[],samplers:[]};for(let O=0;O<a.targetedAnimations.length;++O){const X=a.targetedAnimations[O],E=X.target,y=X.animation;if(V&&!V(y))continue;const T=U.has(E);if(this._IsTransformable(E)||1===E.length&&this._IsTransformable(E[0])){const H=bH._DeduceAnimationInfo(X.animation);if(H){const O=this._IsTransformable(E)?E:this._IsTransformable(E[0])?E[0]:null;O&&bH._AddAnimation(`${y.name}`,w,O,y,H.dataAccessorType,H.animationChannelTargetPath,S,t,q,p,H.useQuaternion,G,T)}}else if(E instanceof yH.c||1===E.length&&E[0]instanceof yH.c){if(bH._DeduceAnimationInfo(X.animation)){const O=E instanceof yH.c?E:E[0];if(O){const S=H.morphTargetManagers.find((H=>{for(let S=0;S<H.numTargets;++S)if(H.getTarget(S)===O)return!0;return!1}));if(S){const t=H.meshes.find((H=>H.morphTargetManager===S));var o;if(t)h.has(t)||h.set(t,new Map),null===(o=h.get(t))||void 0===o||o.set(O,y),e.add(t),j.set(t,y)}}}}}e.forEach((H=>{const O=H.morphTargetManager;let U=null;const V=[],o=j.get(H).getKeys(),e=o.length;for(let S=0;S<e;++S)for(let t=0;t<O.numTargets;++t){const q=O.getTarget(t),p=h.get(H);if(p){const O=p.get(q);O?(U||(U=new EH.d(`${a.name}_${H.name}_MorphWeightAnimation`,"influence",O.framePerSecond,EH.d.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),V.push(O.getKeys()[S])):V.push({frame:a.from+X/e*S,value:q.influence,inTangent:o[0].inTangent?0:void 0,outTangent:o[0].outTangent?0:void 0})}}U.setKeys(V);const E=bH._DeduceAnimationInfo(U);E&&bH._AddAnimation(`${a.name}_${H.name}_MorphWeightAnimation`,w,H,U,E.dataAccessorType,E.animationChannelTargetPath,S,t,q,p,E.useQuaternion,G,!1,null===O||void 0===O?void 0:O.numTargets)})),w.channels.length&&w.samplers.length&&O.push(w)}}}static _AddAnimation(H,O,S,q,p,G,U,V,w,o,h,a,j,e){const X=bH._CreateNodeAnimation(S,q,G,h,a);let E,y,T,K,b,D;if(X){if(e){let H=0,O=0;const S=[];for(;X.inputs.length>0;)O=X.inputs.shift(),H%e==0&&S.push(O),H++;X.inputs=S}const H=U.get(S),q=new Float32Array(X.inputs);E=V.createBufferView(q),y=V.createAccessor(E,"SCALAR",5126,X.inputs.length,void 0,{min:[X.inputsMin],max:[X.inputsMax]}),o.push(y),T=o.length-1;const w=new t.Quaternion,h=new t.eO,a=new t.eO,F=S instanceof aH.d,Y=s(p),l=new Float32Array(X.outputs.length*Y);X.outputs.forEach((function(H,O){let S=H;switch(G){case"translation":j&&(t.eO.FromArrayToRef(H,0,a),n(a),a.toArray(S));break;case"rotation":4===H.length?t.Quaternion.FromArrayToRef(H,0,w):(S=new Array(4),t.eO.FromArrayToRef(H,0,h),t.Quaternion.FromEulerVectorToRef(h,w)),j&&(Q(w),F&&L(w)),w.toArray(S)}l.set(S,O*Y)})),E=V.createBufferView(l),y=V.createAccessor(E,p,5126,X.outputs.length),o.push(y),K=o.length-1,b={interpolation:X.samplerInterpolation,input:T,output:K},O.samplers.push(b),D={sampler:O.samplers.length-1,target:{node:H,path:G}},O.channels.push(D)}}static _CreateBakedAnimation(H,O,S,p,G,U,V,w,o,h,a){let j;const e=t.Quaternion.Identity();let X,E=null,y=null,T=null,K=null,b=null,D=null;h.min=q.Tools.FloatRound(p/U);const F=O.getKeys();for(let t=0,Y=F.length;t<Y;++t){if(D=null,T=F[t],t+1<Y)if(K=F[t+1],T.value.equals&&T.value.equals(K.value)||T.value===K.value){if(0!==t)continue;D=T.frame}else D=K.frame;else{if(b=F[t-1],T.value.equals&&T.value.equals(b.value)||T.value===b.value)continue;D=G}if(D)for(let t=T.frame;t<=D;t+=V){if(X=q.Tools.FloatRound(t/U),X===E)continue;E=X,y=X;const p={key:0,repeatCount:0,loopMode:O.loopMode};j=O._interpolate(t,p),bH._SetInterpolatedValue(H,j,X,O,S,e,w,o,a)}}y&&(h.max=y)}static _ConvertFactorToVector3OrQuaternion(H,O,S,p,G){const U=bH._GetBasePositionRotationOrScale(O,p,G),V=S.targetProperty.split("."),w=V?V[1]:"",o=G?t.Quaternion.KO(U).normalize():t.eO.KO(U);switch(w){case"x":case"y":case"z":o[w]=H;break;case"w":o.w=H;break;default:q.Tools.Error(`glTFAnimation: Unsupported component name "${w}"!`)}return o}static _SetInterpolatedValue(H,O,S,q,p,G,U,V,w){let o;U.push(S),"weights"!==p?(q.dataType===EH.d.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,H,q,p,w)),"rotation"===p?(w?G=O:(o=O,t.Quaternion.RotationYawPitchRollToRef(o.y,o.x,o.z,G)),V.push(G.pU())):(o=O,V.push(o.pU()))):V.push([O])}static _CreateLinearOrStepAnimation(H,O,S,t,q,p){for(const G of O.getKeys())t.push(G.frame/O.framePerSecond),bH._AddKeyframeValue(G,O,q,S,H,p)}static _CreateCubicSplineAnimation(H,O,S,t,q,p){O.getKeys().forEach((function(G){t.push(G.frame/O.framePerSecond),bH._AddSplineTangent(hH.INTANGENT,q,S,"CUBICSPLINE",G,p),bH._AddKeyframeValue(G,O,q,S,H,p),bH._AddSplineTangent(hH.OUTTANGENT,q,S,"CUBICSPLINE",G,p)}))}static _GetBasePositionRotationOrScale(H,O,S){let q;if("rotation"===O)if(S){q=(H.rotationQuaternion??t.Quaternion.Identity()).pU()}else{q=(H.rotation??t.eO.Zero()).pU()}else if("translation"===O){q=(H.position??t.eO.Zero()).pU()}else{q=(H.eU??t.eO.One()).pU()}return q}static _AddKeyframeValue(H,O,S,p,G,U){let V;const w=O.dataType;if(w===EH.d.ANIMATIONTYPE_VECTOR3){let O=H.value.pU();if("rotation"===p){const H=t.eO.KO(O);O=t.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).pU()}S.push(O)}else if(w===EH.d.ANIMATIONTYPE_FLOAT){if("weights"===p)S.push([H.value]);else if(V=this._ConvertFactorToVector3OrQuaternion(H.value,G,O,p,U),V){if("rotation"===p){const H=U?V:t.Quaternion.RotationYawPitchRoll(V.y,V.x,V.z).normalize();S.push(H.pU())}S.push(V.pU())}}else w===EH.d.ANIMATIONTYPE_QUATERNION?S.push(H.value.normalize().pU()):q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(H,O,S){let t,q,p=!1;if("rotation"===O&&!S)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let G=0,U=H.length;G<U;++G)if(q=H[G],q.inTangent||q.outTangent)if(t){if("CUBICSPLINE"!==t){t="LINEAR",p=!0;break}}else t="CUBICSPLINE";else if(t){if("CUBICSPLINE"===t||q.interpolation&&1===q.interpolation&&"STEP"!==t){t="LINEAR",p=!0;break}}else t=q.interpolation&&1===q.interpolation?"STEP":"LINEAR";return t||(t="LINEAR"),{interpolationType:t,shouldBakeAnimation:p}}static _AddSplineTangent(H,O,S,q,p,G){let U;const V=H===hH.INTANGENT?p.inTangent:p.outTangent;if("CUBICSPLINE"===q){if("rotation"===S)if(V)if(G)U=V.pU();else{const H=V;U=t.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).pU()}else U=[0,0,0,0];else U="weights"===S?V?[V]:[0]:V?V.pU():[0,0,0];O.push(U)}}static _CalculateMinMaxKeyFrames(H){let O=1/0,S=-1/0;return H.forEach((function(H){O=Math.min(O,H.frame),S=Math.max(S,H.frame)})),{min:O,max:S}}}function DH(H,O,S,p,G,U){const V={attributes:{},influence:H.influence,name:H.name},w=O.oU;if(!w)return q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),V;const h=U?-1:1,a=t.eO.Zero();let j=0,e=0;if(H.hasPositions){const p=H.getPositions(),U=w.getVerticesData(o.h.PositionKind);if(U){const H=new Float32Array(U.length),O=[1/0,1/0,1/0],q=[-1/0,-1/0,-1/0];e=U.length/3,j=0;for(let S=j;S<e;++S){const G=t.eO.KO(U,3*S);t.eO.KO(p,3*S).subtractToRef(G,a),a.x*=h,O[0]=Math.min(O[0],a.x),q[0]=Math.max(q[0],a.x),O[1]=Math.min(O[1],a.y),q[1]=Math.max(q[1],a.y),O[2]=Math.min(O[2],a.z),q[2]=Math.max(q[2],a.z),H[3*S]=a.x,H[3*S+1]=a.y,H[3*S+2]=a.z}const w=S.createBufferView(H,12),o=S.createAccessor(w,"VEC3",5126,p.length/3,0,{min:O,max:q});G.push(o),V.attributes.POSITION=G.length-1}else q.Tools.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(H.hasNormals){const p=H.getNormals(),U=w.getVerticesData(o.h.NormalKind);if(U){const H=new Float32Array(U.length);e=U.length/3,j=0;for(let S=j;S<e;++S){const O=t.eO.KO(U,3*S).normalize();t.eO.KO(p,3*S).normalize().subtractToRef(O,a),H[3*S]=a.x*h,H[3*S+1]=a.y,H[3*S+2]=a.z}const O=S.createBufferView(H,12),q=S.createAccessor(O,"VEC3",5126,p.length/3,0);G.push(q),V.attributes.NORMAL=G.length-1}else q.Tools.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(H.hasTangents){const p=H.getTangents(),U=w.getVerticesData(o.h.TangentKind);if(U){e=U.length/4;const H=new Float32Array(3*e);j=0;for(let S=j;S<e;++S){const O=t.eO.KO(U,4*S);C(O);const q=t.eO.KO(p,3*S);C(q),q.subtractToRef(O,a),H[3*S]=a.x*h,H[3*S+1]=a.y,H[3*S+2]=a.z}const O=S.createBufferView(H,12),q=S.createAccessor(O,"VEC3",5126,e,0);G.push(q),V.attributes.TANGENT=G.length-1}else q.Tools.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(H.hasColors){const p=H.getColors(),U=w.getVerticesData(o.h.ColorKind),h=w.getVertexBuffer(o.h.ColorKind);if(U&&h){const H=h.getSize();e=U.length/H;const O=new Float32Array(e*H);j=0;for(let S=j;S<e;++S)if(3===H){const q=t.eO.KO(U,S*H);t.eO.KO(p,S*H).subtractToRef(q,a),O[3*S]=a.x,O[3*S+1]=a.y,O[3*S+2]=a.z}else if(4===H){const q=new t.Vector4,G=t.Vector4.KO(U,S*H);t.Vector4.KO(p,S*H).subtractToRef(G,q),O[4*S]=q.x,O[4*S+1]=q.y,O[4*S+2]=q.z,O[4*S+3]=q.w}else q.Tools.Warn(`Unsupported number of components for color attribute: ${H}`);const w=S.createBufferView(O,4*H),o=S.createAccessor(w,3===H?"VEC3":"VEC4",5126,e,0);G.push(o),V.attributes.COLOR_0=G.length-1}else q.Tools.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return V}var FH=S(11855),YH=S(11704),lH=S(11689),dH=S(11262);class vH{}vH.DEFAULT_COLOR=E.TO.White(),vH.DEFAULT_WIDTH_ATTENUATED=1,vH.DEFAULT_WIDTH=.1;var zH=S(11524),mH=S(11858);class rH{static ConvertPoints(H,O){if(H.length&&Array.isArray(H)&&"number"===typeof H[0])return[H];if(H.length&&Array.isArray(H[0])&&"number"===typeof H[0][0])return H;if(H.length&&!Array.isArray(H[0])&&H[0]instanceof t.eO){const O=[];for(let S=0;S<H.length;S++){const t=H[S];O.push(t.x,t.y,t.z)}return[O]}if(H.length>0&&Array.isArray(H[0])&&H[0].length>0&&H[0][0]instanceof t.eO){const O=[],S=H;for(const H of S)O.push(H.flatMap((H=>[H.x,H.y,H.z])));return O}if(H instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const S=[],t=3*O.floatArrayStride;for(let O=0;O<H.length;O+=t){const q=new Array(t);for(let S=0;S<t;S++)q[S]=H[O+S];S.push(q)}return S}return[Array.from(H)]}if(H.length&&H[0]instanceof Float32Array){const O=[];for(const S of H)O.push(Array.from(S));return O}return[]}static OmitZeroLengthPredicate(H,O,S){const t=[];return O.XO(H).lengthSquared()>0&&t.push([H,O]),S.XO(O).lengthSquared()>0&&t.push([O,S]),H.XO(S).lengthSquared()>0&&t.push([S,H]),0===t.length?null:t}static OmitDuplicatesPredicate(H,O,S,t){const q=[];return rH._SearchInPoints(H,O,t)||q.push([H,O]),rH._SearchInPoints(O,S,t)||q.push([O,S]),rH._SearchInPoints(S,H,t)||q.push([S,H]),0===q.length?null:q}static _SearchInPoints(H,O,S){for(const G of S)for(let S=0;S<G.length;S++){var t,q,p;if(null!==(t=G[S])&&void 0!==t&&t.equals(H))if(null!==(q=G[S+1])&&void 0!==q&&q.equals(O)||null!==(p=G[S-1])&&void 0!==p&&p.equals(O))return!0}return!1}static MeshesToLines(H,O){const S=[];for(let q=0;q<H.length;q++){const p=H[q],G=p.getVerticesData(o.h.PositionKind),U=p.hU();if(G&&U)for(let H=0,V=0;H<U.length;H++){const w=3*U[V++],o=3*U[V++],h=3*U[V++],a=new t.eO(G[w],G[w+1],G[w+2]),j=new t.eO(G[o],G[o+1],G[o+2]),e=new t.eO(G[h],G[h+1],G[h+2]);if(O){const t=O(a,j,e,S,H,w,p,q,G,U);if(t)for(const H of t)S.push(H)}else S.push([a,j],[j,e],[e,a])}}return S}static ToVector3Array(H){if(Array.isArray(H[0])){const O=[],S=H;for(const H of S){const S=[];for(let O=0;O<H.length;O+=3)S.push(new t.eO(H[O],H[O+1],H[O+2]));O.push(S)}return O}const O=H,S=[];for(let q=0;q<O.length;q+=3)S.push(new t.eO(O[q],O[q+1],O[q+2]));return S}static ToNumberArray(H){return H.flatMap((H=>[H.x,H.y,H.z]))}static GetPointsCountInfo(H){const O=new Array(H.length);let S=0;for(let t=H.length;t--;)O[t]=H[t].length/3,S+=O[t];return{total:S,counts:O}}static GetLineLength(H){if(0===H.length)return 0;let O;O="number"===typeof H[0]?rH.ToVector3Array(H):H;const S=t.TmpVectors.eO[0];let q=0;for(let t=0;t<O.length-1;t++){const H=O[t];q+=O[t+1].subtractToRef(H,S).length()}return q}static GetLineLengthArray(H){const O=new Float32Array(H.length/3);let S=0;for(let t=0,q=H.length/3-1;t<q;t++){let q=H[3*t+0],p=H[3*t+1],G=H[3*t+2];q-=H[3*t+3],p-=H[3*t+4],G-=H[3*t+5];S+=Math.sqrt(q*q+p*p+G*G),O[t+1]=S}return O}static SegmentizeSegmentByCount(H,O,S){const q=[],p=O.XO(H),G=t.TmpVectors.eO[0];G.XU(S);const U=t.TmpVectors.eO[1];p.divideToRef(G,U);let V=H.clone();q.push(V);for(let t=0;t<S;t++)V=V.clone(),q.push(V.addInPlace(U));return q}static SegmentizeLineBySegmentLength(H,O){const S=H[0]instanceof t.eO?rH.GetLineSegments(H):"number"===typeof H[0]?rH.GetLineSegments(rH.ToVector3Array(H)):H,q=[];for(const t of S)if(t.length>O){const H=rH.SegmentizeSegmentByCount(t.point1,t.point2,Math.ceil(t.length/O));for(const O of H)q.push(O)}else q.push(t.point1),q.push(t.point2);return q}static SegmentizeLineBySegmentCount(H,O){const S="number"===typeof H[0]?rH.ToVector3Array(H):H,t=rH.GetLineLength(S)/O;return rH.SegmentizeLineBySegmentLength(S,t)}static GetLineSegments(H){const O=[];for(let S=0;S<H.length-1;S++){const t=H[S],q=H[S+1],p=q.XO(t).length();O.push({point1:t,point2:q,length:p})}return O}static GetMinMaxSegmentLength(H){const O=rH.GetLineSegments(H).sort((H=>H.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(H,O,S){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const p=O*S;let G=0,U=0;const V=H.length;for(let t=0;t<V;t++){if(p<=G+H[t].length){U=t;break}G+=H[t].length}const w=(p-G)/H[U].length;return H[U].point2.subtractToRef(H[U].point1,t.TmpVectors.eO[0]),t.TmpVectors.eO[1]=t.TmpVectors.eO[0].multiplyByFloats(w,w,w),q||t.TmpVectors.eO[1].addInPlace(H[U].point1),t.TmpVectors.eO[1].clone()}static GetCircleLinePoints(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:H,p=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const G=[];for(let U=0;U<=O;U++)G.push(new t.eO(Math.cos(U*p)*H,Math.sin(U*p)*q,S));return G}static GetBezierLinePoints(H,O,S,t){return zH.e.CreateQuadraticBezier(H,O,S,t).getPoints().flatMap((H=>[H.x,H.y,H.z]))}static GetArrowCap(H,O,S,t,q){let p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,G=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[H.clone(),H.add(O.multiplyByFloats(S,S,S))],widths:[t,q,p,G]}}static GetPointsFromText(H,O,S,t){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,p=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const G=[],U=(0,mH.c)(H,O,S,t);for(const V of U){for(const H of V.paths){const O=[],S=H.getPoints();for(const H of S)O.push(H.x,H.y,q);G.push(O)}if(p)for(const H of V.holes){const O=[],S=H.getPoints();for(const H of S)O.push(H.x,H.y,q);G.push(O)}}return G}static Color3toRGBAUint8(H){const O=new Uint8Array(4*H.length);for(let S=0,t=0;S<H.length;S++)O[t++]=255*H[S].r,O[t++]=255*H[S].g,O[t++]=255*H[S].b,O[t++]=255;return O}static CreateColorsTexture(H,O,S,t){const q=t.getEngine().getCaps().maxTextureSize??1,p=O.length>q?q:O.length,G=Math.ceil(O.length/q);G>1&&(O=[...O,...Array(p*G-O.length).fill(O[0])]);const U=rH.Color3toRGBAUint8(O),V=new F.b(U,p,G,e.c.TEXTUREFORMAT_RGBA,t,!1,!0,S);return V.name=H,V}static PrepareEmptyColorsTexture(H){if(!vH.EmptyColorsTexture){const O=new Uint8Array(4);vH.EmptyColorsTexture=new F.b(O,1,1,e.c.TEXTUREFORMAT_RGBA,H,!1,!1,F.b.NEAREST_NEAREST),vH.EmptyColorsTexture.name="grlEmptyColorsTexture"}return vH.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var H;null===(H=vH.EmptyColorsTexture)||void 0===H||H.dispose(),vH.EmptyColorsTexture=null}static BooleanToNumber(H){return H?1:0}}class WH extends lH.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class gH extends YH.d{isCompatible(H){return!0}constructor(H,O,S){var q;S=S||{color:vH.DEFAULT_COLOR};const p=new WH;p.GREASED_LINE_HAS_COLOR=!!S.color&&!S.useColors,p.GREASED_LINE_SIZE_ATTENUATION=S.sizeAttenuation??!1,p.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===S.colorDistributionType,p.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??H.YH()).useRightHandedSystem,p.GREASED_LINE_CAMERA_FACING=S.cameraFacing??!0,super(H,gH.GREASED_LINE_MATERIAL_NAME,200,p,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(q=S)||void 0===q?void 0:q.forceGLSL)||gH.ForceGLSL,this._scene=O??H.YH(),this._engine=this._scene.getEngine(),this._cameraFacing=S.cameraFacing??!0,this.visibility=S.visibility??1,this.useDash=S.useDash??!1,this.dashRatio=S.dashRatio??.5,this.dashOffset=S.dashOffset??0,this.width=S.width?S.width:S.sizeAttenuation?vH.DEFAULT_WIDTH_ATTENUATED:vH.DEFAULT_WIDTH,this._sizeAttenuation=S.sizeAttenuation??!1,this.colorMode=S.colorMode??0,this._color=S.color??null,this.useColors=S.useColors??!1,this._colorsDistributionType=S.colorDistributionType??0,this.colorsSampling=S.colorsSampling??F.b.NEAREST_NEAREST,this._colors=S.zH??null,this.dashCount=S.dashCount??1,this.resolution=S.resolution??new t.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),S.colorsTexture?this.colorsTexture=S.colorsTexture:this._colors?this.colorsTexture=rH.CreateColorsTexture(`${H.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??vH.DEFAULT_COLOR,rH.PrepareEmptyColorsTexture(this._scene)),this._engine.up.add((()=>{rH.DisposeEmptyColorsTexture()}))}getAttributes(H){H.push("grl_offsets"),H.push("grl_widths"),H.push("grl_colorPointers"),H.push("grl_counters"),this._cameraFacing?(H.push("grl_previousAndSide"),H.push("grl_nextAndCounters")):H.push("grl_slopes")}getSamplers(H){H.push("grl_colors")}getActiveTextures(H){this.colorsTexture&&H.push(this.colorsTexture)}getUniforms(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===H&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(H)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(H)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(H){if(this._cameraFacing){H.VU("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||H.VU("viewProjection",this._scene.getTransformMatrix());const O=t.TmpVectors.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,H.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=t.TmpVectors.Vector4[0];O.x=rH.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,H.updateVector4("grl_dashOptions",O);const S=t.TmpVectors.Vector4[1];S.x=this.colorMode,S.y=this.visibility,S.z=this.colorsTexture?this.colorsTexture.getSize().width:0,S.w=rH.BooleanToNumber(this.useColors),H.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",S),this._color&&H.updateColor3("grl_singleColor",this._color);const q=this.colorsTexture??vH.EmptyColorsTexture;H.setTexture("grl_colors",q),H.updateFloat2("grl_textureSize",(null===q||void 0===q?void 0:q.getSize().width)??1,(null===q||void 0===q?void 0:q.getSize().height)??1)}prepareDefines(H,O,S){H.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,H.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,H.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,H.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,H.GREASED_LINE_CAMERA_FACING=this._cameraFacing,H.GREASED_LINE_USE_OFFSETS=!!S.offsets}getClassName(){return gH.GREASED_LINE_MATERIAL_NAME}getCustomCode(H){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(H,O){if("vertex"===H){const H={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(H["!gl_Position\\=viewProjection\\*worldPos;"]="//"),H}return"fragment"===H?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(H,this._cameraFacing):function(H,O){if("vertex"===H){const H={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(H["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),H}return"fragment"===H?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(H,this._cameraFacing)}dispose(){var H;null===(H=this.colorsTexture)||void 0===H||H.dispose(),super.dispose()}get zH(){return this._colors}set zH(H){this.setColors(H)}setColors(H){var O;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var p;if(this._colors=H,null!==H&&0!==H.length){if(!S||t)if(this.colorsTexture&&q===H.length&&!t){const O=rH.Color3toRGBAUint8(H);this.colorsTexture.update(O)}else{var G;null===(G=this.colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=rH.CreateColorsTexture(`${this._material.name}-colors-texture`,H,this.colorsSampling,this._scene)}}else null===(p=this.colorsTexture)||void 0===p||p.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(H){this._dashCount=H,this._dashArray=1/H}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(H){this._sizeAttenuation=H,this.markAllDefinesAsDirty()}get color(){return this._color}set color(H){this.setColor(H)}setColor(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==H||null!==this._color&&null===H?(this._color=H,O||this.markAllDefinesAsDirty()):this._color=H}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(H){this._colorsDistributionType=H,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(H){this._aspect=H.x/H.y,this._resolution=H}serialize(){const H=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.zH=this._colors),this._color&&(O.color=this._color),H.greasedLineMaterialOptions=O,H}parse(H,O,S){var t;super.parse(H,O,S);const q=H.greasedLineMaterialOptions;null===(t=this.colorsTexture)||void 0===t||t.dispose(),q.color&&this.setColor(q.color,!0),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.zH&&(this.zH=q.zH),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),this.zH?this.colorsTexture=rH.CreateColorsTexture(`${this._material.name}-colors-texture`,this.zH,this.colorsSampling,O):rH.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(H){var O;const S=H;null===(O=S.colorsTexture)||void 0===O||O.dispose(),this._colors&&(S.colorsTexture=rH.CreateColorsTexture(`${S._material.name}-colors-texture`,this._colors,S.colorsSampling,this._scene)),S.setColor(this.color,!0),S.colorsDistributionType=this.colorsDistributionType,S.colorsSampling=this.colorsSampling,S.colorMode=this.colorMode,S.useColors=this.useColors,S.visibility=this.visibility,S.useDash=this.useDash,S.dashCount=this.dashCount,S.dashRatio=this.dashRatio,S.dashOffset=this.dashOffset,S.width=this.width,S.sizeAttenuation=this.sizeAttenuation,S.resolution=this.resolution,S.markAllDefinesAsDirty()}_isGLSL(H){return 0===H||this._forceGLSL}}gH.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",gH.ForceGLSL=!1,(0,dH.g)(`BABYLON.${gH.GREASED_LINE_MATERIAL_NAME}`,gH);var NH=S(11736),xH=S(11160),kH=S(11539),AH=S(11242);class uH extends kH.ShaderMaterial{constructor(H,O,q){const p=O.getEngine(),G=p.isWebGPU&&!(q.forceGLSL||uH.ForceGLSL),U=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&U.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const V=["position","grl_widths","grl_offsets","grl_colorPointers"];q.cameraFacing?(U.push("GREASED_LINE_CAMERA_FACING"),V.push("grl_previousAndSide","grl_nextAndCounters")):(V.push("grl_slopes"),V.push("grl_counters"));const w=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(G||w.push("world","viewProjection","view","projection"),super(H,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:G?["Scene","Mesh"]:void 0,attributes:V,uniforms:w,samplers:G?[]:["grlColors"],defines:U,extraInitializationsAsync:async()=>{G?await Promise.all([S.e(66).then(S.bind(S,14417)),S.e(75).then(S.bind(S,14422))]):await Promise.all([S.e(69).then(S.bind(S,14430)),S.e(76).then(S.bind(S,14435))])},shaderLanguage:G?1:0}),this._color=E.TO.White(),this._colorsDistributionType=0,this._colorsTexture=null,q=q||{color:vH.DEFAULT_COLOR},this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.dashCount=q.dashCount??1,this.width=q.width?q.width:q.sizeAttenuation&&q.cameraFacing?vH.DEFAULT_WIDTH_ATTENUATED:vH.DEFAULT_WIDTH,this.sizeAttenuation=q.sizeAttenuation??!1,this.color=q.color??E.TO.White(),this.useColors=q.useColors??!1,this.colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??F.b.NEAREST_NEAREST,this.colorMode=q.colorMode??0,this._colors=q.zH??null,this._cameraFacing=q.cameraFacing??!0,this.resolution=q.resolution??new t.Vector2(p.getRenderWidth(),p.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=rH.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??vH.DEFAULT_COLOR,this.colorsTexture=rH.PrepareEmptyColorsTexture(O)),G){const H=new AH.d;H.setParameters(),H.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",H)}p.up.add((()=>{rH.DisposeEmptyColorsTexture()}))}dispose(){var H;null===(H=this._colorsTexture)||void 0===H||H.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new t.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get zH(){return this._colors}set zH(H){this.setColors(H)}setColors(H){var O;let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1],t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var p;if(this._colors=H,null!==H&&0!==H.length){if(!S||t)if(this._colorsTexture&&q===H.length&&!t){const O=rH.Color3toRGBAUint8(H);this._colorsTexture.update(O)}else{var G;null===(G=this._colorsTexture)||void 0===G||G.dispose(),this.colorsTexture=rH.CreateColorsTexture(`${this.name}-colors-texture`,H,this.colorsSampling,this.YH())}}else null===(p=this._colorsTexture)||void 0===p||p.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(H){this._colorsTexture=H,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(H){this._width=H,this.setFloat("grlWidth",H)}get useColors(){return this._useColors}set useColors(H){this._useColors=H,this.setFloat("grlUseColors",rH.BooleanToNumber(H))}get colorsSampling(){return this._colorsSampling}set colorsSampling(H){this._colorsSampling=H}get visibility(){return this._visibility}set visibility(H){this._visibility=H,this.setFloat("grlVisibility",H)}get useDash(){return this._useDash}set useDash(H){this._useDash=H,this.setFloat("grlUseDash",rH.BooleanToNumber(H))}get dashOffset(){return this._dashOffset}set dashOffset(H){this._dashOffset=H,this.setFloat("grlDashOffset",H)}get dashRatio(){return this._dashRatio}set dashRatio(H){this._dashRatio=H,this.setFloat("grlDashRatio",H)}get dashCount(){return this._dashCount}set dashCount(H){this._dashCount=H,this._dashArray=1/H,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(H){this._sizeAttenuation=H,this.setFloat("grlSizeAttenuation",rH.BooleanToNumber(H))}get color(){return this._color}set color(H){this.setColor(H)}setColor(H){H=H??vH.DEFAULT_COLOR,this._color=H,this.setColor3("grlColor",H)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(H){this._colorsDistributionType=H,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(H){this._colorMode=H,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(H){this._resolution=H,this.setVector2("grlResolution",H),this.setFloat("grlAspect",H.x/H.y)}serialize(){const H=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.zH=this._colors),H.greasedLineMaterialOptions=O,H}parse(H,O,S){var t;const q=H.greasedLineMaterialOptions;null===(t=this._colorsTexture)||void 0===t||t.dispose(),q.color&&(this.color=q.color),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),q.zH?this.colorsTexture=rH.CreateColorsTexture(`${this.name}-colors-texture`,q.zH,this.colorsSampling,this.YH()):this.colorsTexture=rH.PrepareEmptyColorsTexture(O),this._cameraFacing=q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var JH,PH,fH;uH.ForceGLSL=!1,function(H){H[H.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",H[H.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(JH||(JH={})),function(H){H[H.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",H[H.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",H[H.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(PH||(PH={})),function(H){H[H.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",H[H.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",H[H.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",H[H.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",H[H.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(fH||(fH={}));class cH extends TH.d{constructor(H,O,S){super(H,O,null,null,!1,!1),this.name=H,this._options=S,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=S.lazy??!1,this._updatable=S.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=S.colorPointers??[],this._widths=S.widths??new Array(S.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(H){let O=0;for(const t of this._points)O+=t.length;const S=O/3*2-this._widths.length;for(let t=0;t<S;t++)this._widths.push(H)}updateLazy(){var H,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(H=this._options.ribbonOptions)||void 0===H?void 0:H.smoothShading),!this.gH&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(H,O){for(const S of H)this._points.push(S);this._lazy||this.setPoints(this._points,O)}dispose(H){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(H,O)}isLazy(){return this._lazy}get mH(){return this._uvs}set mH(H){this._uvs=H instanceof Float32Array?H:new Float32Array(H),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(H){this.material instanceof uH&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===H||void 0===H?void 0:H.length)>0),this._offsets=H,this._offsetsBuffer?this._offsetsBuffer.update(H):this._createOffsetsBuffer(H)}get widths(){return this._widths}set widths(H){this._widths=H,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(H)}get colorPointers(){return this._colorPointers}set colorPointers(H){this._colorPointers=H,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(H)}get greasedLineMaterial(){var H,O;if(this.material&&this.material instanceof uH)return this.material;const S=null===(H=this.material)||void 0===H||null===(O=H.pluginManager)||void 0===O?void 0:O.getPlugin(gH.GREASED_LINE_MATERIAL_NAME);return S||void 0}get points(){const H=[];return xH.e.DeepCopy(this._points,H),H}setPoints(H,O){this._points=rH.ConvertPoints(H,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,mH:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(H){super.serialize(H),H.type=this.getClassName(),H.lineOptions=this._createLineOptions()}_createVertexBuffers(){let H=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new NH.c;return O.dH=this._vertexPositions,O.indices=this._indices,O.mH=this._uvs,H&&(O.vH=[],NH.c.ComputeNormals(this._vertexPositions,this._indices,O.vH)),O.WH(this,this._options.updatable),O}_createOffsetsBuffer(H){const O=this._scene.getEngine(),S=new o.d(O,H,this._updatable,3);this.setVerticesBuffer(S.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=S}}class RH{constructor(H,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=H,this.wasAddedByNoopNode=O}getIndicesAccessor(H,O,S,t,q){var p,G,U,V;return null===(p=this._indicesAccessorMap.get(H))||void 0===p||null===(G=p.get(O))||void 0===G||null===(U=G.get(S))||void 0===U||null===(V=U.get(t))||void 0===V?void 0:V.get(q)}setIndicesAccessor(H,O,S,t,q,p){let G=this._indicesAccessorMap.get(H);G||(G=new Map,this._indicesAccessorMap.set(H,G));let U=G.get(O);U||(U=new Map,G.set(O,U));let V=U.get(S);V||(V=new Map,U.set(S,V));let w=V.get(t);w||(w=new Map,V.set(t,w)),w.set(q,p)}pushExportedNode(H){this._exportedNodes.has(H)||this._exportedNodes.add(H)}getNodesSet(){return this._exportedNodes}getVertexBufferView(H){return this._vertexBufferViewMap.get(H)}setVertexBufferView(H,O){this._vertexBufferViewMap.set(H,O)}setRemappedBufferView(H,O,S){this._remappedBufferView.set(H,new Map),this._remappedBufferView.get(H).set(O,S)}getRemappedBufferView(H,O){var S;return null===(S=this._remappedBufferView.get(H))||void 0===S?void 0:S.get(O)}getVertexAccessor(H,O,S){var t,q;return null===(t=this._vertexAccessorMap.get(H))||void 0===t||null===(q=t.get(O))||void 0===q?void 0:q.get(S)}setVertexAccessor(H,O,S,t){let q=this._vertexAccessorMap.get(H);q||(q=new Map,this._vertexAccessorMap.set(H,q));let p=q.get(O);p||(p=new Map,q.set(O,p)),p.set(S,t)}hasVertexColorAlpha(H){return this._vertexMapColorAlpha.get(H)||!1}setHasVertexColorAlpha(H,O){return this._vertexMapColorAlpha.set(H,O)}getMesh(H){return this._meshMap.get(H)}setMesh(H,O){this._meshMap.set(H,O)}bindMorphDataToMesh(H,O){const S=this._meshMorphTargetMap.get(H)||[];this._meshMorphTargetMap.set(H,S),-1===S.indexOf(O)&&S.push(O)}getMorphTargetsFromMesh(H){return this._meshMorphTargetMap.get(H)}}class BH{_ApplyExtension(H,O,S,t){if(S>=O.length)return Promise.resolve(H);const q=t(O[S],H);return q?q.then((async H=>H?await this._ApplyExtension(H,O,S+1,t):null)):this._ApplyExtension(H,O,S+1,t)}_ApplyExtensions(H,O){const S=[];for(const t of BH._ExtensionNames)S.push(this._extensions[t]);return this._ApplyExtension(H,S,0,O)}_extensionsPreExportTextureAsync(H,O,S){return this._ApplyExtensions(O,((O,t)=>O.preExportTextureAsync&&O.preExportTextureAsync(H,t,S)))}_extensionsPostExportNodeAsync(H,O,S,t,q){return this._ApplyExtensions(O,((O,p)=>O.postExportNodeAsync&&O.postExportNodeAsync(H,p,S,t,q,this._bufferManager)))}_extensionsPostExportMaterialAsync(H,O,S){return this._ApplyExtensions(O,((O,t)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(H,t,S)))}_extensionsPostExportMaterialAdditionalTextures(H,O,S){const t=[];for(const q of BH._ExtensionNames){const p=this._extensions[q];p.postExportMaterialAdditionalTextures&&t.push(...p.postExportMaterialAdditionalTextures(H,O,S))}return t}_extensionsPostExportTextures(H,O,S){for(const t of BH._ExtensionNames){const q=this._extensions[t];q.postExportTexture&&q.postExportTexture(H,O,S)}}_extensionsPostExportMeshPrimitive(H){for(const O of BH._ExtensionNames){const S=this._extensions[O];S.postExportMeshPrimitive&&S.postExportMeshPrimitive(H,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const H of BH._ExtensionNames){const O=this._extensions[H];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(H){for(const O of BH._ExtensionNames){const S=this._extensions[O];S.enabled&&H(S)}}_extensionsOnExporting(){this._forEachExtensions((H=>{var O,S,t;H.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(H.name)&&this._glTF.extensionsUsed.push(H.name),H.required&&((S=this._glTF).extensionsRequired||(S.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(H.name)&&this._glTF.extensionsRequired.push(H.name)),(t=this._glTF).extensions||(t.extensions={}),H.onExporting&&H.onExporting())}))}_loadExtensions(){for(const H of BH._ExtensionNames){const O=BH._ExtensionFactories[H](this);this._extensions[H]=O}}constructor(){let H=arguments.length>0&&void 0!==arguments[0]?arguments[0]:X.c.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${e.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new A(this),this._extensions={},this._bufferManager=new oH,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!H)throw new Error("No scene available to export");this._babylonScene=H,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:H=>{var O;return null===H||void 0===H||null===(O=H.OU)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const H in this._extensions){this._extensions[H].dispose()}}get options(){return this._options}static RegisterExtension(H,O){BH.UnregisterExtension(H)&&q.Tools.Warn(`Extension with the name ${H} already exists`),BH._ExtensionFactories[H]=O,BH._ExtensionNames.push(H)}static UnregisterExtension(H){if(!BH._ExtensionFactories[H])return!1;delete BH._ExtensionFactories[H];const O=BH._ExtensionNames.indexOf(H);return-1!==O&&BH._ExtensionNames.splice(O,1),!0}_generateJSON(H,O,S){const t={byteLength:H};return t.byteLength&&(this._glTF.buffers=[t]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.EO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(t.uri=O+".bin"),S?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(H){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const S=this._generateJSON(O.byteLength,H,!0),t=new Blob([O],{type:"application/octet-stream"}),q=H+".gltf",p=H+".bin",G=new w;if(G.files[q]=S,G.files[p]=t,this._imageData)for(const U in this._imageData)G.files[U]=new Blob([this._imageData[U].data],{type:this._imageData[U].mimeType});return G}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(H){const O=H%4;return 0===O?O:4-O}async generateGLBAsync(H){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const S=this._generateJSON(O.byteLength),t=H+".glb";let q,p=S.length;if("undefined"!==typeof TextEncoder){q=(new TextEncoder).encode(S),p=q.length}const G=this._getPadding(p),U=this._getPadding(O.byteLength),V=28+p+G+O.byteLength+U,o=new VH(V);if(o.writeUInt32(1179937895),o.writeUInt32(2),o.writeUInt32(V),o.writeUInt32(p+G),o.writeUInt32(1313821514),q)o.writeTypedArray(q);else{const H="_".charCodeAt(0);for(let O=0;O<p;++O){const t=S.charCodeAt(O);t!=S.codePointAt(O)?o.writeUInt8(H):o.writeUInt8(t)}}for(let w=0;w<G;++w)o.writeUInt8(32);o.writeUInt32(O.byteLength+U),o.writeUInt32(5130562),o.writeTypedArray(O);for(let w=0;w<U;++w)o.writeUInt8(0);const h=new w;return h.files[t]=new Blob([o.getOutputData()],{type:"application/octet-stream"}),h}_setNodeTransformation(H,O,S){if(O.getPivotPoint().equalsWithEpsilon(c,f.e)||q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(c,f.e)){const q=t.TmpVectors.eO[0].t(O.position);S&&n(q),H.translation=q.pU()}O.eU.equalsWithEpsilon(B,f.e)||(H.scale=O.eU.pU());const p=O.rotationQuaternion||t.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);p.equalsWithEpsilon(R,f.e)||(S&&Q(p),H.rotation=p.normalize().pU())}_setCameraTransformation(H,O,S){if(!O.position.equalsWithEpsilon(c,f.e)){const q=t.TmpVectors.eO[0].t(O.position);S&&n(q),H.translation=q.pU()}const q=O.rotationQuaternion||t.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);S&&Q(q),this._babylonScene.useRightHandedSystem||L(q),q.equalsWithEpsilon(R,f.e)||(H.rotation=q.pU())}_listAvailableCameras(){for(const H of this._babylonScene.cameras){const O={type:H.mode===aH.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(H.name&&(O.name=H.name),"perspective"===O.type)O.perspective={aspectRatio:H.getEngine().getAspectRatio(H),yfov:H.fovMode===aH.d.FOVMODE_VERTICAL_FIXED?H.fov:H.fov*H.getEngine().getAspectRatio(H),znear:H.UU,zfar:H.maxZ};else if("orthographic"===O.type){const S=H.orthoLeft&&H.orthoRight?.5*(H.orthoRight-H.orthoLeft):.5*H.getEngine().getRenderWidth(),t=H.orthoBottom&&H.orthoTop?.5*(H.orthoTop-H.orthoBottom):.5*H.getEngine().getRenderHeight();O.orthographic={xmag:S,ymag:t,znear:H.UU,zfar:H.maxZ}}this._camerasMap.set(H,O)}}_exportAndAssignCameras(){const H=Array.from(this._camerasMap.values());for(const O of H){const H=this._nodesCameraMap.get(O);if(void 0!==H){this._cameras.push(O);for(const O of H)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const H of this._babylonScene.skeletons){if(H.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(H,O)}}_exportAndAssignSkeletons(){for(const H of this._babylonScene.skeletons){if(H.bones.length<=0)continue;const O=this._skinMap.get(H);if(void 0==O)continue;const S={},t=[];let p=-1;for(let q=0;q<H.bones.length;++q){const O=H.bones[q],t=O.getIndex()??q;-1!==t&&(S[t]=O,t>p&&(p=t))}for(let H=0;H<=p;++H){const p=S[H];t.push(p.getAbsoluteInverseBindMatrix());const G=p.getTransformNode();if(null!==G){const H=this._nodeMap.get(G);G&&null!==H&&void 0!==H?O.joints.push(H):q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const G=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==G){const H=64*t.length,S=new Float32Array(H/4);t.forEach(((H,O)=>{S.set(H.m,16*O)}));const q=this._bufferManager.createBufferView(S);this._accessors.push(this._bufferManager.createAccessor(q,"MAT4",5126,t.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of G)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const H={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(H.extras=O)}const O=new Array,S=new Array,t=new Array;for(const U of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&GH(U,this._babylonScene.useRightHandedSystem)?t.push(...U.getChildren()):this._babylonScene.useRightHandedSystem?O.push(U):S.push(U);this._listAvailableCameras(),this._listAvailableSkeletons();const q=new RH(!0,!1);H.nodes.push(...await this._exportNodesAsync(S,q));const p=new RH(!1,!1);H.nodes.push(...await this._exportNodesAsync(O,p));const G=new RH(!1,!0);H.nodes.push(...await this._exportNodesAsync(t,G)),H.nodes.length&&this._scenes.push(H),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&bH._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(H){let O=this._shouldExportNodeMap.get(H);return void 0===O&&(O=this._options.shouldExportNode(H),this._shouldExportNodeMap.set(H,O)),O}async _exportNodesAsync(H,O){const S=new Array;this._exportBuffers(H,O);for(const t of H)await this._exportNodeAsync(t,S,O);return S}_collectBuffers(H,O,S,t,q){if(this._shouldExportNode(H)&&H instanceof a.e&&H.oU){const p=H.oU.getVertexBuffers();if(p)for(const t in p){if(!i(t))continue;const G=p[t];q.setHasVertexColorAlpha(G,H.hasVertexAlpha);const U=G._buffer,V=O.get(U)||[];O.set(U,V),-1===V.indexOf(G)&&V.push(G);const w=S.get(G)||[];S.set(G,w),-1===w.indexOf(H)&&w.push(H)}const G=H.morphTargetManager;if(G)for(let O=0;O<G.numTargets;O++){const S=G.getTarget(O),q=t.get(S)||[];t.set(S,q),-1===q.indexOf(H)&&q.push(H)}}for(const p of H.getChildren())this._collectBuffers(p,O,S,t,q)}_exportBuffers(H,O){const S=new Map,t=new Map,q=new Map;for(const U of H)this._collectBuffers(U,S,t,q,O);const p=Array.from(S.keys());for(const U of p){const H=U.getData();if(!H)throw new Error("Buffer data is not available");const q=S.get(U);if(!q)continue;const p=q[0].byteStride;if(q.some((H=>H.byteStride!==p)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const G=SH(H).slice();for(const O of q){const H=t.get(O),{byteOffset:S,byteStride:q,componentCount:p,type:U,count:V,normalized:w,kind:h}=I(O,H);switch(h){case o.h.NormalKind:case o.h.TangentKind:(0,u.i)(G,S,q,p,U,V,w,(H=>{const O=Math.sqrt(H[0]*H[0]+H[1]*H[1]+H[2]*H[2]);if(O>0){const S=1/O;H[0]*=S,H[1]*=S,H[2]*=S}}));break;case o.h.ColorKind:{const O=H.filter((H=>H.material instanceof XH.yO||null==H.material)).length;if(0==O)break;if(O!=H.length){J.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}U==o.h.UNSIGNED_BYTE&&J.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const t=new E.TO,h=new E.EU,a=this._babylonScene.getEngine().useExactSrgbConversions;(0,u.i)(G,S,q,p,U,V,w,(H=>{3===H.length?(t.jS(H,0),t.toLinearSpaceToRef(t,a),t.toArray(H,0)):(h.jS(H,0),h.toLinearSpaceToRef(h,a),h.toArray(H,0))}))}}}if(O.convertToRightHanded){for(const H of q){const O=t.get(H),{byteOffset:S,byteStride:q,componentCount:p,type:U,count:V,normalized:w,kind:h}=I(H,O);switch(h){case o.h.PositionKind:case o.h.NormalKind:case o.h.TangentKind:(0,u.i)(G,S,q,p,U,V,w,(H=>{H[0]=-H[0]}))}}O.convertedToRightHandedBuffers.set(U,G)}const V=this._bufferManager.createBufferView(G,p);O.setVertexBufferView(U,V);const w=new Map;for(const O of q){const H=t.get(O),{kind:S,totalVertices:q}=I(O,H);switch(S){case o.h.MatricesIndicesKind:case o.h.MatricesIndicesExtraKind:if(O.type==o.h.FLOAT){const H=O.getFloatData(q);null!==H&&w.set(O,H)}}}0!==w.size&&J.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const h=Array.from(w.keys());for(const S of h){const H=w.get(S);if(!H)continue;const t=H.some((H=>H>=256)),q=new(t?Uint16Array:Uint8Array)(H.length);for(let O=0;O<H.length;O++)q[O]=H[O];const p=this._bufferManager.createBufferView(q,4*(t?2:1));O.setRemappedBufferView(U,S,p)}}const G=Array.from(q.keys());for(const U of G){const H=q.get(U);if(!H)continue;const S=DH(U,H[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const t of H)O.bindMorphDataToMesh(t,S)}}async _exportNodeAsync(H,O,S){let t=this._nodeMap.get(H);if(void 0!==t)return void(O.includes(t)||O.push(t));const q=await this._createNodeAsync(H,S);if(q){t=this._nodes.length,this._nodes.push(q),this._nodeMap.set(H,t),S.pushExportedNode(H),O.push(t);const p={name:"runtime animations",channels:[],samplers:[]},G=[];this._babylonScene.animationGroups.length||(bH._CreateMorphTargetAnimationFromMorphTargetAnimations(H,p,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.convertToRightHanded,this._options.shouldExportAnimation),H.animations.length&&bH._CreateNodeAnimationFromNodeAnimations(H,p,G,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,S.convertToRightHanded,this._options.shouldExportAnimation)),p.channels.length&&p.samplers.length&&this._animations.push(p),G.forEach((H=>{H.channels.length&&H.samplers.length&&this._animations.push(H)}))}const p=q?[]:O;for(const G of H.getChildren())await this._exportNodeAsync(G,p,S);q&&p.length&&(q.children=p)}async _createNodeAsync(H,O){if(!this._shouldExportNode(H))return null;const S={};if(H.name&&(S.name=H.name),H.metadata){const O=this._options.metadataSelector(H.metadata);O&&(S.extras=O)}if(H instanceof h.e&&(this._setNodeTransformation(S,H,O.convertToRightHanded),H instanceof a.e)){const q=H instanceof j.c?H.sourceMesh:H;if(q.qU&&q.qU.length>0&&(S.mesh=await this._exportMeshAsync(q,O)),H.skeleton){const O=this._skinMap.get(H.skeleton);var t;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(t=this._nodesSkinMap.get(O))||void 0===t||t.push(S)}}if(H instanceof P.b){const t=this._camerasMap.get(H);if(t){var q;void 0===this._nodesCameraMap.get(t)&&this._nodesCameraMap.set(t,[]),this._setCameraTransformation(S,H,O.convertToRightHanded);const G=H.parent;if(null!==G&&OH(H,G)){const H=this._nodeMap.get(G);if(void 0!==H){var p;const O=this._nodes[H];return HH(S,O),null===(p=this._nodesCameraMap.get(t))||void 0===p||p.push(O),null}}null===(q=this._nodesCameraMap.get(t))||void 0===q||q.push(S)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",S,H,this._nodeMap,O.convertToRightHanded)?S:(J.b.Warn(`Not exporting node ${H.name}`),null)}_exportIndices(H,O,S,t,q,G,U,V,w){let o=H;w.mode=M(G);const h=U!==p.e.CounterClockWiseSideOrientation,a=!V.wasAddedByNoopNode&&h,j=function(H){switch(H){case p.e.TriangleFillMode:case p.e.TriangleStripDrawMode:case p.e.TriangleFanDrawMode:return!0}return!1}(G)&&a;if(j){if(G===p.e.TriangleStripDrawMode||G===p.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");w.mode=M(G);const U=O?new Uint32Array(t):new Uint16Array(t);if(H)for(let O=0;O+2<t;O+=3)U[O]=H[S+O]+q,U[O+1]=H[S+O+2]+q,U[O+2]=H[S+O+1]+q;else for(let H=0;H+2<t;H+=3)U[H]=H,U[H+1]=H+2,U[H+2]=H+1;o=U}else if(H&&0!==q){const p=O?new Uint32Array(t):new Uint16Array(t);for(let O=0;O<t;O++)p[O]=H[S+O]+q;o=p}if(o){let p=V.getIndicesAccessor(H,S,t,q,j);if(void 0===p){const G=function(H,O,S,t){if(H instanceof Uint16Array||H instanceof Uint32Array)return H;if(H instanceof Int32Array)return new Uint32Array(H.buffer,H.byteOffset,H.length);const q=H.slice(O,O+S);return t?new Uint32Array(q):new Uint16Array(q)}(o,0,t,O),U=this._bufferManager.createBufferView(G),w=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(U,"SCALAR",w,t,0)),p=this._accessors.length-1,V.setIndicesAccessor(H,S,t,q,j,p)}w.indices=p}}_exportVertexBuffer(H,O,S,t,q,p){const G=H.getKind();if(!i(G))return;if(G.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let U=q.getVertexAccessor(H,S,t);if(void 0===U){const O=q.convertedToRightHandedBuffers.get(H._buffer)||H._buffer.getData(),p=G===o.h.PositionKind?function(H,O,S,t){const{byteOffset:q,byteStride:p,type:G,normalized:U}=O,V=O.getSize(),w=new Array(V).fill(1/0),o=new Array(V).fill(-1/0);return(0,u.i)(H,q+S*p,p,V,G,t*V,U,(H=>{for(let O=0;O<V;O++)w[O]=Math.min(w[O],H[O]),o[O]=Math.max(o[O],H[O])})),{min:w,max:o}}(O,H,S,t):void 0,V=(G===o.h.MatricesIndicesKind||G===o.h.MatricesIndicesExtraKind)&&H.type===o.h.FLOAT,w=V?o.h.UNSIGNED_BYTE:H.type,h=V?void 0:H.normalized,a=V?q.getRemappedBufferView(H._buffer,H):q.getVertexBufferView(H._buffer),j=H.byteOffset+S*H.byteStride;this._accessors.push(this._bufferManager.createAccessor(a,function(H,O){if(H==o.h.ColorKind)return O?"VEC4":"VEC3";switch(H){case o.h.PositionKind:case o.h.NormalKind:return"VEC3";case o.h.TangentKind:case o.h.MatricesIndicesKind:case o.h.MatricesIndicesExtraKind:case o.h.MatricesWeightsKind:case o.h.MatricesWeightsExtraKind:return"VEC4";case o.h.UVKind:case o.h.UV2Kind:case o.h.UV3Kind:case o.h.UV4Kind:case o.h.UV5Kind:case o.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${H}`)}(G,q.hasVertexColorAlpha(H)),w,t,j,p,h)),U=this._accessors.length-1,q.setVertexAccessor(H,S,t,U)}p.attributes[function(H){switch(H){case o.h.PositionKind:return"POSITION";case o.h.NormalKind:return"NORMAL";case o.h.TangentKind:return"TANGENT";case o.h.ColorKind:return"COLOR_0";case o.h.UVKind:return"TEXCOORD_0";case o.h.UV2Kind:return"TEXCOORD_1";case o.h.UV3Kind:return"TEXCOORD_2";case o.h.UV4Kind:return"TEXCOORD_3";case o.h.UV5Kind:return"TEXCOORD_4";case o.h.UV6Kind:return"TEXCOORD_5";case o.h.MatricesIndicesKind:return"JOINTS_0";case o.h.MatricesIndicesExtraKind:return"JOINTS_1";case o.h.MatricesWeightsKind:return"WEIGHTS_0";case o.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${H}`)}(G)]=U}async _exportMaterialAsync(H,O,S,t){let q=this._materialMap.get(H);if(void 0===q){const t=O&&Object.keys(O).some((H=>H.startsWith("uv")));if((H=H instanceof jH.b?H.yU[S.materialIndex]:H)instanceof eH.c)q=await this._materialExporter.exportPBRMaterialAsync(H,"image/png",t);else{if(!(H instanceof XH.yO))return void J.b.Warn(`Unsupported material '${H.name}' with type ${H.getClassName()}`);q=await this._materialExporter.exportStandardMaterialAsync(H,"image/png",t)}this._materialMap.set(H,q)}t.material=q}async _exportMeshAsync(H,O){var S;let t=O.getMesh(H);if(void 0!==t)return t;const q={primitives:[]};t=this._meshes.length,this._meshes.push(q),O.setMesh(H,t);const G=H.isUnIndexed?null:H.hU(),U=null===(S=H.oU)||void 0===S?void 0:S.getVertexBuffers(),V=O.getMorphTargetsFromMesh(H),w=H instanceof FH.d,o=H instanceof cH,h=H.qU;if(U&&h&&h.length>0)for(const e of h){const S={attributes:{}},t=e.AH()||this._babylonScene.defaultMaterial;if(o){var a,j;const O={name:t.name},q=H,p=E.TO.White(),G=(null===(a=q.material)||void 0===a?void 0:a.alpha)??1,U=(null===(j=q.greasedLineMaterial)||void 0===j?void 0:j.color)??p;(!U.equalsWithEpsilon(p,f.e)||G<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...U.pU(),G]}),this._materials.push(O),S.material=this._materials.length-1}else if(w){const O={name:t.name},q=H;(!q.color.equalsWithEpsilon(E.TO.White(),f.e)||q.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...q.color.pU(),q.alpha]}),this._materials.push(O),S.material=this._materials.length-1}else await this._exportMaterialAsync(t,U,e,S);const h=w||o?p.e.LineListDrawMode:H.overrideRenderingFillMode??t.fillMode,X=t._getEffectiveOrientation(H);this._exportIndices(G,G?(0,u.e)(G,e.indexCount,e.indexStart,e.verticesStart):e.verticesCount>65535,G?e.indexStart:e.verticesStart,G?e.indexCount:e.verticesCount,-e.verticesStart,h,X,O,S);for(const H of Object.values(U))this._exportVertexBuffer(H,t,e.verticesStart,e.verticesCount,O,S);if(V){S.targets=[];for(const H of V)S.targets.push(H.attributes)}q.primitives.push(S),this._extensionsPostExportMeshPrimitive(S)}if(V){q.weights=[],q.extras||(q.extras={}),q.extras.targetNames=[];for(const H of V)q.weights.push(H.influence),q.extras.targetNames.push(H.name)}return t}}BH._ExtensionNames=new Array,BH._ExtensionFactories={};class ZH{static async GLTFAsync(H,O,S){S&&S.exportWithoutWaitingForScene||await H.whenReadyAsync();const t=new BH(H,S),q=await t.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return t.dispose(),q}static async GLBAsync(H,O,S){S&&S.exportWithoutWaitingForScene||await H.whenReadyAsync();const t=new BH(H,S),q=await t.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return t.dispose(),q}}S(11866);const IH="EXT_mesh_gpu_instancing";class sH{constructor(H){this.name=IH,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(H,O,S,q,p,G){return await new Promise((H=>{if(O&&S instanceof TH.d&&S.hasThinInstances&&this._exporter){this._wasUsed=!0;const H=t.eO.Zero(),q=t.Quaternion.Identity(),U=t.eO.One(),V=S.thinInstanceGetWorldMatrices(),w=t.TmpVectors.eO[2],o=t.TmpVectors.Quaternion[1],h=t.TmpVectors.eO[3];let a=!1,j=!1,e=!1;const X=new Float32Array(3*S.TU),E=new Float32Array(4*S.TU),y=new Float32Array(3*S.TU);let T=0;for(const O of V)O.decompose(h,o,w),p&&(n(w),Q(o)),X.set(w.pU(),3*T),E.set(o.normalize().pU(),4*T),y.set(h.pU(),3*T),a=a||!w.equalsWithEpsilon(H),j=j||!o.equalsWithEpsilon(q),e=e||!h.equalsWithEpsilon(U),T++;const K={attributes:{}};a&&(K.attributes.TRANSLATION=this._buildAccessor(X,"VEC3",S.TU,G)),j&&(K.attributes.ROTATION=this._buildAccessor(E,"VEC4",S.TU,G)),e&&(K.attributes.SCALE=this._buildAccessor(y,"VEC3",S.TU,G)),O.extensions=O.extensions||{},O.extensions[IH]=K}H(O)}))}_buildAccessor(H,O,S,t){const q=t.createBufferView(H),p=t.createAccessor(q,O,5126,S);return this._exporter._accessors.push(p),this._exporter._accessors.length-1}}BH.RegisterExtension(IH,(H=>new sH(H)));var iH=S(11873),MH=S(11884),CH=S(11893),nH=S(11895);function QH(H){return H===CH.d.PositionKind?"POSITION":H===CH.d.NormalKind?"NORMAL":H===CH.d.ColorKind?"COLOR":H.startsWith(CH.d.UVKind)?"TEX_COORD":"GENERIC"}const LH={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class HO extends iH.e{static get DefaultAvailable(){return(0,iH.h)(HO.DefaultConfiguration)}static get Default(){return HO._Default??(HO._Default=new HO),HO._Default}static ResetDefault(H){HO._Default&&(H||HO._Default.dispose(),HO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(H,O){return{module:await(O||DracoEncoderModule)({wasmBinary:H})}}_getWorkerContent(){return`${MH.i}(${MH.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:HO.DefaultConfiguration)}async _encodeAsync(H,O,S){const t=S?(0,nH.c)(LH,S):LH;if(this._workerPoolPromise){const S=await this._workerPoolPromise;return await new Promise(((q,p)=>{S.push(((S,G)=>{const U=H=>{S.removeEventListener("error",U),S.removeEventListener("message",V),p(H),G()},V=H=>{"encodeMeshDone"===H.data.id&&(S.removeEventListener("error",U),S.removeEventListener("message",V),q(H.data.encodedMeshData),G())};S.addEventListener("error",U),S.addEventListener("message",V);const w=[];for(const O of H)w.push(O.data.buffer);O&&w.push(O.buffer),S.postMessage({id:"encodeMesh",attributes:H,indices:O,options:t},w)}))}))}if(this._modulePromise){const S=await this._modulePromise;return(0,MH.i)(S.module,H,O,t)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(H,O){if(0==H.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");H instanceof TH.d&&H.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(J.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const S=function(H){let O=H.hU(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,u.e)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(H),t=function(H,O){const S=[];for(const t of H.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(t)){if(t===CH.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const q=H.getVertexBuffer(t),p=q.getSize(),G=(0,u.u)(q.getData(),p,q.type,q.byteOffset,q.byteStride,q.normalized,H.getTotalVertices(),!0);S.push({kind:t,dracoName:QH(t),size:p,data:G})}return S}(H,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(t,S,O)}}HO.DefaultConfiguration={wasmUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.js`},HO._Default=null;const OO="KHR_draco_mesh_compression";class SO{get wasUsed(){return this._wasUsed}constructor(H){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===H.options.meshCompressionMethod&&HO.DefaultAvailable}dispose(){}postExportMeshPrimitive(H,O,S){if(!this.enabled)return;if(4!==H.mode&&5!==H.mode)return void J.b.Warn("Cannot compress primitive with mode "+H.mode+".");const t=[],q=[];let p=null;if(void 0!==H.indices){const G=S[H.indices],U=O.getBufferView(G);p=O.getData(U).slice(),t.push(U),q.push(G)}const G=[];for(const[o,h]of Object.entries(H.attributes)){const H=S[h],p=O.getBufferView(H),V=s(H.type),w=(0,u.u)(O.getData(p),V,H.componentType,H.byteOffset||0,p.byteStride||(0,u.o)(H.componentType)*V,H.normalized||!1,H.count,!0);G.push({kind:o,dracoName:(U=o,"POSITION"===U?"POSITION":"NORMAL"===U?"NORMAL":U.startsWith("COLOR")?"COLOR":U.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:s(H.type),data:w}),t.push(p),q.push(H)}var U;const V={method:H.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},w=HO.Default._encodeAsync(G,p,V).then((S=>{if(!S)return void J.b.Error("Draco encoding failed for primitive.");const p={bufferView:-1,attributes:S.attributeIds},G=O.createBufferView(S.data);O.setBufferView(p,G);for(const H of t)this._bufferViewsUsed.add(H);for(const H of q)this._accessorsUsed.add(H);H.extensions||(H.extensions={}),H.extensions[OO]=p})).catch((H=>{J.b.Error("Draco encoding failed for primitive: "+H)}));this._encodePromises.push(w),this._wasUsed=!0}async preGenerateBinaryAsync(H){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{H.getPropertiesWithBufferView(O).every((H=>this._accessorsUsed.has(H)))&&H.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}BH.RegisterExtension(OO,(H=>new SO(H)));var tO=S(11904);const qO="KHR_lights_punctual",pO={name:"",color:[1,1,1],KU:1,range:Number.MAX_VALUE},GO={innerConeAngle:0,outerConeAngle:Math.PI/4},UO=t.eO.Backward();class VO{constructor(H){this.name=qO,this.enabled=!0,this.required=!1,this._exporter=H}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[qO]=this._lights}async postExportNodeAsync(H,O,S,q,p){return await new Promise((G=>{if(!(S instanceof KH.b))return void G(O);const U=S.getTypeID()==KH.b.LIGHTTYPEID_POINTLIGHT?"point":S.getTypeID()==KH.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":S.getTypeID()==KH.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!U||!(S instanceof tO.c))return J.b.Warn(`${H}: Light ${S.name} is not supported in ${qO}`),void G(O);if(S.falloffType!==KH.b.FALLOFF_GLTF&&J.b.Warn(`${H}: Light falloff for ${S.name} does not match the ${qO} specification!`),!S.position.equalsToFloats(0,0,0)){const H=t.TmpVectors.eO[0].t(S.position);p&&n(H),O.translation=H.pU()}if("point"!==U){const H=S.direction.normalizeToRef(t.TmpVectors.eO[0]);p&&n(H);const q=t.Quaternion.FromUnitVectorsToRef(UO,H,t.TmpVectors.Quaternion[0]);t.Quaternion.IsIdentity(q)||(O.rotation=q.pU())}const V={type:U,name:S.name,color:S.bU.pU(),KU:S.KU,range:S.range};if(tH(V,pO),"spot"===U){const H=S;V.spot={innerConeAngle:H.innerAngle/2,outerConeAngle:H.angle/2},tH(V.spot,GO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(V);const w={eq:this._lights.lights.length-1},o=S.parent;if(o&&OH(S,o)){const H=q.get(o);if(H){const S=this._exporter._nodes[H];return HH(O,S),S.extensions||(S.extensions={}),S.extensions[qO]=w,void G(null)}}O.extensions||(O.extensions={}),O.extensions[qO]=w,G(O)}))}}BH.RegisterExtension(qO,(H=>new VO(H)));var wO=S(11811);const oO="KHR_materials_anisotropy";class hO{constructor(H){this.name=oO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof wO.c&&S.anisotropy.isEnabled&&!S.anisotropy.legacy?(S.anisotropy.texture&&t.push(S.anisotropy.texture),t):[]}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof wO.c){if(!S.anisotropy.isEnabled||S.anisotropy.legacy)return void H(O);this._wasUsed=!0,O.extensions=O.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(S.anisotropy.texture),q={anisotropyStrength:S.anisotropy.KU,anisotropyRotation:S.anisotropy.angle,anisotropyTexture:t??void 0};null!==q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(S),O.extensions[oO]=q}H(O)}))}}BH.RegisterExtension(oO,(H=>new hO(H)));const aO="KHR_materials_clearcoat";class jO{constructor(H){this.name=aO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof wO.c&&S.clearCoat.isEnabled?(S.clearCoat.texture&&t.push(S.clearCoat.texture),!S.clearCoat.useRoughnessFromMainTexture&&S.clearCoat.textureRoughness&&t.push(S.clearCoat.textureRoughness),S.clearCoat.bumpTexture&&t.push(S.clearCoat.bumpTexture),t):[]}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof wO.c){if(!S.clearCoat.isEnabled)return void H(O);this._wasUsed=!0,O.extensions=O.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(S.clearCoat.texture);let p;p=S.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(S.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(S.clearCoat.textureRoughness),S.clearCoat.isTintEnabled&&q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${S.name}`),S.clearCoat.remapF0OnInterfaceChange&&q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${S.name}`);const G=this._exporter._materialExporter.getTextureInfo(S.clearCoat.bumpTexture),U={clearcoatFactor:S.clearCoat.KU,clearcoatTexture:t??void 0,clearcoatRoughnessFactor:S.clearCoat.roughness,clearcoatRoughnessTexture:p??void 0,clearcoatNormalTexture:G??void 0};null===U.clearcoatTexture&&null===U.clearcoatRoughnessTexture&&null===U.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(S),O.extensions[aO]=U}H(O)}))}}BH.RegisterExtension(aO,(H=>new jO(H)));const eO="KHR_materials_diffuse_transmission";function XO(H,O){const S=O.subSurface;let t=null;return S.translucencyIntensityTexture?t=S.translucencyIntensityTexture:S.thicknessTexture&&S.useMaskFromThicknessTexture&&(t=S.thicknessTexture),t&&!S.useGltfStyleTextures?(J.b.Warn(`${H}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):t}class EO{constructor(H){this.name=eO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];if(S instanceof eH.c&&this._isExtensionEnabled(S)){const O=XO(H,S);return O&&t.push(O),S.subSurface.translucencyColorTexture&&t.push(S.subSurface.translucencyColorTexture),t}return t}_isExtensionEnabled(H){if(H.unlit)return!1;const O=H.subSurface;return!!O.isTranslucencyEnabled&&(!H.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(H,O,S){return new Promise((t=>{if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0;const t=S.subSurface,q=XO(H,S),p=0==t.translucencyIntensity?void 0:t.translucencyIntensity,G=this._exporter._materialExporter.getTextureInfo(q)??void 0,U=!t.translucencyColor||t.translucencyColor.equalsFloats(1,1,1)?void 0:t.translucencyColor.pU(),V=this._exporter._materialExporter.getTextureInfo(t.translucencyColorTexture)??void 0,w={diffuseTransmissionFactor:p,diffuseTransmissionTexture:G,diffuseTransmissionColorFactor:U,diffuseTransmissionColorTexture:V};(G||V)&&this._exporter._materialNeedsUVsSet.add(S),O.extensions=O.extensions||{},O.extensions[eO]=w}t(O)}))}}BH.RegisterExtension(eO,(H=>new EO(H)));const yO="KHR_materials_dispersion";class TO{constructor(){this.name=yO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(H){if(H.unlit)return!1;const O=H.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0;const H={dispersion:S.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[yO]=H}H(O)}))}}BH.RegisterExtension(yO,(()=>new TO));const KO="KHR_materials_emissive_strength";class bO{constructor(){this.name=KO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(H,O,S){return await new Promise((H=>{if(!(S instanceof eH.c))return H(O);const t=S.emissiveColor.pU(),q=Math.max(...t);if(q>1){this._wasUsed=!0,O.extensions||(O.extensions={});const H={emissiveStrength:q},t=S.emissiveColor.scale(1/H.emissiveStrength);O.emissiveFactor=t.pU(),O.extensions[KO]=H}return H(O)}))}}BH.RegisterExtension(KO,(H=>new bO));const DO="KHR_materials_ior";class FO{constructor(){this.name=DO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(H){return!H.unlit&&(void 0!=H.indexOfRefraction&&1.5!=H.indexOfRefraction)}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0;const H={ior:S.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[DO]=H}H(O)}))}}BH.RegisterExtension(DO,(H=>new FO));const YO="KHR_materials_iridescence";class lO{constructor(H){this.name=YO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof wO.c&&S.iridescence.isEnabled?(S.iridescence.texture&&t.push(S.iridescence.texture),S.iridescence.thicknessTexture&&S.iridescence.thicknessTexture!==S.iridescence.texture&&t.push(S.iridescence.thicknessTexture),t):[]}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof wO.c){if(!S.iridescence.isEnabled)return void H(O);this._wasUsed=!0,O.extensions=O.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(S.iridescence.texture),q=this._exporter._materialExporter.getTextureInfo(S.iridescence.thicknessTexture),p={iridescenceFactor:S.iridescence.KU,iridescenceIor:S.iridescence.indexOfRefraction,iridescenceThicknessMinimum:S.iridescence.minimumThickness,iridescenceThicknessMaximum:S.iridescence.maximumThickness,iridescenceTexture:t??void 0,iridescenceThicknessTexture:q??void 0};null===p.iridescenceTexture&&null===p.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(S),O.extensions[YO]=p}H(O)}))}}BH.RegisterExtension(YO,(H=>new lO(H)));const dO="KHR_materials_sheen";class vO{constructor(H){this.name=dO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){return S instanceof eH.c&&S.sheen.isEnabled&&S.sheen.texture?[S.sheen.texture]:[]}async postExportMaterialAsync(H,O,S){return await new Promise((H=>{if(S instanceof eH.c){if(!S.sheen.isEnabled)return void H(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const t={sheenColorFactor:S.sheen.color.pU(),sheenRoughnessFactor:S.sheen.roughness??0};null===t.sheenColorTexture&&null===t.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(S),S.sheen.texture&&(t.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.texture)??void 0),S.sheen.textureRoughness&&!S.sheen.useRoughnessFromMainTexture?t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.textureRoughness)??void 0:S.sheen.texture&&S.sheen.useRoughnessFromMainTexture&&(t.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(S.sheen.texture)??void 0),O.extensions[dO]=t}H(O)}))}}BH.RegisterExtension(dO,(H=>new vO(H)));const zO="KHR_materials_specular";class mO{constructor(H){this.name=zO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof eH.c&&this._isExtensionEnabled(S)?(S.metallicReflectanceTexture&&t.push(S.metallicReflectanceTexture),S.reflectanceTexture&&t.push(S.reflectanceTexture),t):t}_isExtensionEnabled(H){return!H.unlit&&(void 0!=H.metallicF0Factor&&1!=H.metallicF0Factor||void 0!=H.metallicReflectanceColor&&!H.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(H))}_hasTexturesExtension(H){return null!=H.metallicReflectanceTexture||null!=H.reflectanceTexture}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0,O.extensions=O.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(S.metallicReflectanceTexture)??void 0,t=this._exporter._materialExporter.getTextureInfo(S.reflectanceTexture)??void 0,q={specularFactor:1==S.metallicF0Factor?void 0:S.metallicF0Factor,specularTexture:H,specularColorFactor:S.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:S.metallicReflectanceColor.pU(),specularColorTexture:t};this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),O.extensions[zO]=q}H(O)}))}}BH.RegisterExtension(zO,(H=>new mO(H)));const rO="KHR_materials_transmission";class WO{constructor(H){this.name=rO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof eH.c&&this._isExtensionEnabled(S)?(S.subSurface.thicknessTexture&&t.push(S.subSurface.thicknessTexture),t):t}_isExtensionEnabled(H){if(H.unlit)return!1;const O=H.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(H)}_hasTexturesExtension(H){return null!=H.subSurface.refractionIntensityTexture}async postExportMaterialAsync(H,O,S){if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0;const t=S.subSurface,q={transmissionFactor:0===t.refractionIntensity?void 0:t.refractionIntensity};if(this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),t.refractionIntensityTexture)if(t.useGltfStyleTextures){const H=await this._exporter._materialExporter.exportTextureAsync(t.refractionIntensityTexture,"image/png");H&&(q.transmissionTexture=H)}else J.b.Warn(`${H}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[rO]=q}return O}}BH.RegisterExtension(rO,(H=>new WO(H)));const gO="KHR_materials_unlit";class NO{constructor(){this.name=gO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(H,O,S){return new Promise((H=>{let t=!1;S instanceof eH.c?t=S.unlit:S instanceof XH.yO&&(t=S.disableLighting),t&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[gO]={}),H(O)}))}}BH.RegisterExtension(gO,(()=>new NO));const xO="KHR_materials_volume";class kO{constructor(H){this.name=xO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof eH.c&&this._isExtensionEnabled(S)?(S.subSurface.thicknessTexture&&t.push(S.subSurface.thicknessTexture),t):t}_isExtensionEnabled(H){if(H.unlit)return!1;const O=H.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=E.TO.White()||this._hasTexturesExtension(H))}_hasTexturesExtension(H){return null!=H.subSurface.thicknessTexture}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof eH.c&&this._isExtensionEnabled(S)){this._wasUsed=!0;const H=S.subSurface,t={thicknessFactor:0==H.maximumThickness?void 0:H.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(H.thicknessTexture)??void 0,attenuationDistance:H.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:H.tintColorAtDistance,attenuationColor:H.tintColor.equalsFloats(1,1,1)?void 0:H.tintColor.pU()};this._hasTexturesExtension(S)&&this._exporter._materialNeedsUVsSet.add(S),O.extensions=O.extensions||{},O.extensions[xO]=t}H(O)}))}}BH.RegisterExtension(xO,(H=>new kO(H)));const AO="EXT_materials_diffuse_roughness";class uO{constructor(H){this.name=AO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=H}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(H,O,S){const t=[];return S instanceof wO.c&&S._baseDiffuseRoughness?(S._baseDiffuseRoughnessTexture&&t.push(S._baseDiffuseRoughnessTexture),t):[]}postExportMaterialAsync(H,O,S){return new Promise((H=>{if(S instanceof wO.c){if(!S._baseDiffuseRoughness)return void H(O);this._wasUsed=!0,O.extensions=O.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(S._baseDiffuseRoughnessTexture),q={diffuseRoughnessFactor:S._baseDiffuseRoughness,diffuseRoughnessTexture:t??void 0};null!==q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(S),O.extensions[AO]=q}H(O)}))}}BH.RegisterExtension(AO,(H=>new uO(H)));const JO="KHR_texture_transform";class PO{constructor(){this.name=JO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(H,O,S){if(S.YH()||q.Tools.Warn(`${H}: /*@__KEY__*/"scene" is not defined for Babylon texture ${S.name}!`),(0!==S.uAng||0!==S.vAng)&&(q.Tools.Warn(`${H}: Texture ${S.name} with rotation in the u or v axis is not supported in glTF.`),0!==S.uRotationCenter||0!==S.vRotationCenter))return;const t={};let p=!1;if(0===S.uOffset&&0===S.vOffset||(t.offset=[S.uOffset,S.vOffset],p=!0),1===S.uScale&&1===S.vScale||(t.scale=[S.uScale,S.vScale],p=!0),0!==S.wAng){if(0!==S.uRotationCenter||0!==S.vRotationCenter){if(S.homogeneousRotationInUVTransform&&S.uScale!==S.vScale)return void q.Tools.Warn(`${H}: Texture ${S.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${JO}.`);q.Tools.Warn(`${H}: Texture ${S.name} with non-origin rotation center will be exported using an adjusted offset with ${JO}.`),t.offset=function(H){const{uOffset:O,vOffset:S,uRotationCenter:t,vRotationCenter:q,uScale:p,vScale:G,wAng:U}=H,V=Math.cos(U),w=Math.sin(U),o=t*p,h=q*G;return[O+(o*(1-V)+h*w),S+(h*(1-V)-o*w)]}(S)}t.rotation=-S.wAng,p=!0}0!==S.coordinatesIndex&&(t.texCoord=S.coordinatesIndex,p=!0),p&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[JO]=t)}}BH.RegisterExtension(JO,(()=>new PO));class fO{static CreateSTL(H){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],p=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],G=arguments.length>5&&void 0!==arguments[5]&&arguments[5],U=arguments.length>6&&void 0!==arguments[6]&&arguments[6],V=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const w=function(H,O,S){const q=[3*H[S],3*H[S+1],3*H[S+2]],p=[new t.eO(O[q[0]],O[q[0]+2],O[q[0]+1]),new t.eO(O[q[1]],O[q[1]+2],O[q[1]+1]),new t.eO(O[q[2]],O[q[2]+2],O[q[2]+1])],G=p[0].XO(p[1]),U=p[2].XO(p[1]);return{v:p,n:t.eO.Cross(U,G).normalize()}},h=function(H,O,S,t){return O=a(H,O,S.x,t),O=a(H,O,S.y,t),a(H,O,S.z,t)},a=function(H,O,S,t){return H.setFloat32(O,S,t),O+4},e=function(H){if(U){let O=H;H instanceof j.c&&(O=H.sourceMesh);const S=O.getVerticesData(o.h.PositionKind,!0,!0);if(!S)return[];const q=t.eO.Zero();let p;for(p=0;p<S.length;p+=3)t.eO.TransformCoordinatesFromFloatsToRef(S[p],S[p+1],S[p+2],H.wU(!0),q).toArray(S,p);return S}return H.getVerticesData(o.h.PositionKind)||[]};U&&(G=!0);let X="",E=0,y=0;if(q){for(let S=0;S<H.length;S++){const O=H[S].hU();E+=O?O.length/3:0}const O=new ArrayBuffer(84+50*E);X=new DataView(O),y+=80,X.setUint32(y,E,p),y+=4}else V||(X="solid stlmesh\r\n");for(let t=0;t<H.length;t++){const O=H[t];!q&&V&&(X+="solid "+O.name+"\r\n"),!G&&O instanceof TH.d&&O.bakeCurrentTransformIntoVertices();const S=e(O),U=O.hU()||[];for(let H=0;H<U.length;H+=3){const O=w(U,S,H);q?(y=h(X,y,O.n,p),y=h(X,y,O.v[0],p),y=h(X,y,O.v[1],p),y=h(X,y,O.v[2],p),y+=2):(X+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",X+="\t\touter loop\r\n",X+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",X+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",X+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",X+="\t\tendloop\r\n",X+="\tendfacet\r\n")}!q&&V&&(X+="endsolid "+name+"\r\n")}if(q||V||(X+="endsolid stlmesh"),O){const H=document.createElement("a"),O=new Blob([X],{type:"application/octet-stream"});H.href=window.URL.createObjectURL(O),H.download=S+".stl",H.click()}return X}}function cO(H,O){let S=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const t=[];for(let q=0;q<H.length/S;q++){const p=H[q*S],G=H[q*S+1],U=H[q*S+2];t.push(`(${p.toPrecision(O.precision)}, ${G.toPrecision(O.precision)}, ${U.toPrecision(O.precision)})`)}return t.join(", ")}function RO(H,O){const S=[];for(let t=0;t<H.length/2;t++){const q=H[2*t],p=H[2*t+1];S.push(`(${q.toPrecision(O.precision)}, ${(1-p).toPrecision(O.precision)})`)}return S.join(", ")}function BO(H,O){const S=H.getVerticesData(o.h.PositionKind),t=H.getVerticesData(o.h.NormalKind);if(S&&t)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(H){var O;const S=null!==(O=H.hU())&&void 0!==O&&O.length?H.getTotalIndices():H.getTotalVertices();return Array(S/3).fill(3).join(", ")}(H)}]\n\t\tint[] faceVertexIndices = [${function(H){const O=H.hU(),S=[];if(null!==O)for(let t=0;t<O.length;t++)S.push(O[t]);else{const O=H.getTotalVertices();for(let H=0;H<O;H++)S.push(H)}return S.join(", ")}(H)}]\n\t\tnormal3f[] normals = [${cO(t,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${cO(S,O)}]\n        ${function(H,O){let S="";for(let q=0;q<4;q++){const t=q>0?q:"",p=H.getVerticesData(o.h.UVKind+(t?t+1:""));p&&(S+=`\n\t\ttexCoord2f[] primvars:st${t} = [${RO(p,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const t=H.getVerticesData(o.h.ColorKind);return t&&(S+=`\n\tcolor3f[] primvars:displayColor = [${cO(t,O,t.length/H.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),S}(H,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ZO(H,O){return`\n        def "Geometry"\n        {\n        ${BO(H,O)}\n        }\n        `}function IO(H){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=H,fflate.strToU8(O)}function sO(H){const O=H.m;return`( ${iO(O,0)}, ${iO(O,4)}, ${iO(O,8)}, ${iO(O,12)} )`}function iO(H,O){return`(${H[O+0]}, ${H[O+1]}, ${H[O+2]}, ${H[O+3]})`}function MO(H){const O="Object_"+H.uniqueId,S=function(H){const O=H.getWorldMatrix().clone(),S=H.YH().useRightHandedSystem;if(!S){let t=H.parent;for(;t;){if(GH(t,S)){O.multiplyToRef(t.getWorldMatrix().invert(),O);break}t=t.parent}}return O.determinant()<0&&q.Tools.Warn(`Exporting mesh ${H.name} with negative scale. Result may look incorrect in destination engine.`),O}(H),t=sO(S);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${H.oU.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${t}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${H.material.uniqueId}>\n}\n\n`}function CO(H){switch(H){case Y.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Y.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Y.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function nO(H){return`(${H.x}, ${H.y})`}function QO(H){return`(${H.r}, ${H.g}, ${H.b})`}function LO(H,O,S,q,p,G){const U=H.getInternalTexture().uniqueId+"_"+H.invertY;p[U]=H;const V=H.coordinatesIndex>0?"st"+H.coordinatesIndex:"st",w=new t.Vector2(H.uScale,H.vScale),o=new t.Vector2(H.uOffset,H.vOffset),h=H.wAng,a=Math.sin(h),j=Math.cos(h);return o.y=1-o.y-w.y,o.x+=a*w.x,o.y+=(1-j)*w.y,`\n    def Shader "PrimvarReader_${S}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${V}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${S}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${S}.outputs:result>\n        float inputs:rotation = ${(h*(180/Math.PI)).toFixed(G.precision)}\n        float2 inputs:scale = ${nO(w)}\n        float2 inputs:translation = ${nO(o)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${H.uniqueId}_${S}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${U}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${S}.outputs:result>\n        ${q?"float4 inputs:scale = "+function(H){return`(${H.r}, ${H.g}, ${H.b}, 1.0)`}(q):""}\n        token inputs:sourceColorSpace = "${H.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${CO(H.wrapU)}"\n        token inputs:wrapT = "${CO(H.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function HS(H,O,S){const t="\t\t\t",q=[],p=[],{diffuseMap:G,bU:U,alphaCutOff:V,emissiveMap:w,emissive:o,normalMap:h,roughnessMap:a,roughnessChannel:j,roughness:e,metalnessMap:X,metalnessChannel:y,metalness:T,aoMap:K,aoMapChannel:b,aoMapIntensity:D,alphaMap:F,ior:Y,clearCoatEnabled:l,clearCoat:d,clearCoatMap:v,clearCoatRoughness:z,clearCoatRoughnessMap:m}=function(H){const O={diffuseMap:null,bU:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return H instanceof XH.yO?{...O,diffuseMap:H.diffuseTexture,bU:H.diffuseColor,alphaCutOff:H.alphaCutOff,emissiveMap:H.emissiveTexture,emissive:H.emissiveColor,roughness:1,alphaMap:H.opacityTexture}:H instanceof wO.c?{...O,diffuseMap:H._albedoTexture,bU:H._albedoColor,alphaCutOff:H._alphaCutOff,emissiveMap:H._emissiveTexture,emissive:H._emissiveColor,normalMap:H._bumpTexture,roughnessMap:H._metallicTexture,roughnessChannel:H._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:H._roughness??1,metalnessMap:H._metallicTexture,metalnessChannel:H._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:H._metallic??0,aoMap:H._ambientTexture,aoMapChannel:H._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:H._ambientTextureStrength,alphaMap:H._opacityTexture,ior:H.subSurface.indexOfRefraction,clearCoatEnabled:H.clearCoat.isEnabled,clearCoat:H.clearCoat.KU,clearCoatMap:H.clearCoat.texture,clearCoatRoughness:H.clearCoat.roughness,clearCoatRoughnessMap:H.clearCoat.useRoughnessFromMainTexture?H.clearCoat.texture:H.clearCoat.textureRoughness}:O}(H);return null!==G?(q.push(`${t}color3f inputs:diffuseColor.connect = </Materials/Material_${H.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:rgb>`),H.needAlphaBlending()?q.push(`${t}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`):H.needAlphaTesting()&&(q.push(`${t}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${G.uniqueId}_diffuse.outputs:a>`),q.push(`${t}float inputs:opacityThreshold = ${V}`)),p.push(LO(G,H,"diffuse",U,O,S))):q.push(`${t}color3f inputs:diffuseColor = ${QO(U||E.TO.White())}`),null!==w?(q.push(`${t}color3f inputs:emissiveColor.connect = </Materials/Material_${H.uniqueId}/Texture_${w.uniqueId}_emissive.outputs:rgb>`),p.push(LO(w,H,"emissive",o,O,S))):o&&o.toLuminance()>0&&q.push(`${t}color3f inputs:emissiveColor = ${QO(o)}`),null!==h&&(q.push(`${t}normal3f inputs:normal.connect = </Materials/Material_${H.uniqueId}/Texture_${h.uniqueId}_normal.outputs:rgb>`),p.push(LO(h,H,"normal",null,O,S))),null!==K&&(q.push(`${t}float inputs:occlusion.connect = </Materials/Material_${H.uniqueId}/Texture_${K.uniqueId}_occlusion.outputs:${b}>`),p.push(LO(K,H,"occlusion",new E.TO(D,D,D),O,S))),null!==a?(q.push(`${t}float inputs:roughness.connect = </Materials/Material_${H.uniqueId}/Texture_${a.uniqueId}_roughness.outputs:${j}>`),p.push(LO(a,H,"roughness",new E.TO(e,e,e),O,S))):q.push(`${t}float inputs:roughness = ${e}`),null!==X?(q.push(`${t}float inputs:metallic.connect = </Materials/Material_${H.uniqueId}/Texture_${X.uniqueId}_metallic.outputs:${y}>`),p.push(LO(X,H,"metallic",new E.TO(T,T,T),O,S))):q.push(`${t}float inputs:metallic = ${T}`),null!==F?(q.push(`${t}float inputs:opacity.connect = </Materials/Material_${H.uniqueId}/Texture_${F.uniqueId}_opacity.outputs:r>`),q.push(`${t}float inputs:opacityThreshold = 0.0001`),p.push(LO(F,H,"opacity",null,O,S))):q.push(`${t}float inputs:opacity = ${H.alpha}`),l&&(null!==v?(q.push(`${t}float inputs:clearcoat.connect = </Materials/Material_${H.uniqueId}/Texture_${v.uniqueId}_clearcoat.outputs:r>`),p.push(LO(v,H,"clearcoat",new E.TO(d,d,d),O,S))):q.push(`${t}float inputs:clearcoat = ${d}`),null!==m?(q.push(`${t}float inputs:clearcoatRoughness.connect = </Materials/Material_${H.uniqueId}/Texture_${m.uniqueId}_clearcoatRoughness.outputs:g>`),p.push(LO(m,H,"clearcoatRoughness",new E.TO(z,z,z),O,S))):q.push(`${t}float inputs:clearcoatRoughness = ${z}`)),q.push(`${t}float inputs:ior = ${Y}`),`\n\tdef Material "Material_${H.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${H.uniqueId}/PreviewSurface.outputs:surface>\n\n${p.join("\n")}\n\n\t}\n`}async function OS(H,O,S){const p={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await q.Tools.LoadScriptAsync(p.fflateUrl);const G={};G[p.modelFileName]=null;let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';U+=function(H){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===H.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${H.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${H.planeAnchoringAlignment}"`:""}\n            `}(p);const V={};for(const t of H.meshes){if(0===t.getTotalVertices())continue;const H=t,O=H.oU,w=H.material;if(!w||!O||S&&!S(H))continue;if(-1!==["yO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(w.getClassName())){const S="geometries/Geometry_"+O.uniqueId+".usda";if(!(S in G)){const H=ZO(O,p);G[S]=IO(H)}w.uniqueId in V||(V[w.uniqueId]=w),U+=MO(H)}else q.Tools.Warn("USDZExportAsync does not support this material type: "+w.getClassName())}H.activeCamera&&p.exportCamera&&(U+=function(H,O){const S="Camera_"+H.uniqueId,q=sO(t.Matrix.RotationY(Math.PI).multiply(H.getWorldMatrix()));if(H.mode===Y.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${S}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${H.UU.toPrecision(O.precision)}, ${H.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(H.orthoLeft||1)+Math.abs(H.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(H.orthoTop||1)+Math.abs(H.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const t=H.getEngine().getAspectRatio(H),p=O.cameraSensorWidth||35;return`def Camera "${S}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${H.UU.toPrecision(O.precision)}, ${H.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(p/(2*Math.tan(.5*H.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(p*t).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(p/t).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(H.activeCamera,p)),U+="\n            }\n        }\n    }";const w={};U+=function(H,O,S){const t=[];for(const q in H){const p=H[q];t.push(HS(p,O,S))}return`\n    def "Materials"\n{\n${t.join("")}\n}\n\n`}(V,w,p),G[p.modelFileName]=fflate.strToU8(U);for(const t in w){const H=w[t],O=H.getSize(),S=await H.readPixels();if(!S)throw new Error("Texture data is not available");const q=await l.DumpTools.DumpDataAsync(O.width,O.height,S,"image/png",void 0,!1,!0);G[`textures/Texture_${t}.png`]=new Uint8Array(q).slice()}let o=0;for(const t in G){const H=G[t];if(!H)continue;o+=34+t.length;const O=63&o;if(4!==O){const S=new Uint8Array(64-O);G[t]=[H,{extra:{12345:S}}]}o=H.length}return fflate.zipSync(G,{level:0})}}}]);