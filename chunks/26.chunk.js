"use strict";(self["9s4i8ue3jq"]=self["9s4i8ue3jq"]||[]).push([[26],{13206:(a,c,o)=>{o.r(c),o.d(c,{EXT_materials_diffuse_roughness:()=>uc,EXT_mesh_gpu_instancing:()=>Ha,GLTF2Export:()=>Va,GLTFData:()=>T,KHR_draco_mesh_compression:()=>oc,KHR_lights_punctual:()=>Gc,KHR_materials_anisotropy:()=>jc,KHR_materials_clearcoat:()=>ec,KHR_materials_diffuse_transmission:()=>Nc,KHR_materials_dispersion:()=>kc,KHR_materials_emissive_strength:()=>fc,KHR_materials_ior:()=>wc,KHR_materials_iridescence:()=>hc,KHR_materials_sheen:()=>Sc,KHR_materials_specular:()=>xc,KHR_materials_transmission:()=>dc,KHR_materials_unlit:()=>Wc,KHR_materials_volume:()=>Oc,KHR_texture_transform:()=>Dc,OBJExport:()=>i,STLExport:()=>Ic,USDZExportAsync:()=>co,_ConvertToGLTFPBRMetallicRoughness:()=>X,_SolveMetallic:()=>d,__IGLTFExporterExtension:()=>p});var s=o(12810),q=o(12637),t=o(13127);class i{static OBJ(a,c,o,i){const p=[];let G=1,T=1;c&&(o||(o="mat"),p.push("mtllib "+o+".mtl"));for(let C=0;C<a.length;C++){const o=a[C],j=o.name||`mesh${C}}`;p.push(`o ${j}`);let L=null;if(i){const a=o.Rc(!0);L=new s.Matrix,a.invertToRef(L),o.bakeTransformIntoVertices(a)}if(c){const a=o.material;a&&p.push("usemtl "+a.id)}const e=o.dc;if(!e){q.Tools.Warn("No geometry is present on the mesh");continue}const g=e.getVerticesData("position"),M=e.getVerticesData("normal"),N=e.getVerticesData("uv"),y=e.Wc();let k=0,n=0;if(!g||!y){q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const f=a[0].Za().useRightHandedSystem?1:-1;for(let a=0;a<g.length;a+=3)p.push("v "+g[a]*f+" "+g[a+1]+" "+g[a+2]),k++;if(null!=M)for(let a=0;a<M.length;a+=3)p.push("vn "+M[a]*f+" "+M[a+1]+" "+M[a+2]);if(null!=N)for(let a=0;a<N.length;a+=2)p.push("vt "+N[a]+" "+N[a+1]),n++;const J=["","",""],w=(o.material||o.Za().defaultMaterial)._getEffectiveOrientation(o),[Z,h]=w===t.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let a=0;a<y.length;a+=3){const c=[String(y[a]+G),String(y[a+Z]+G),String(y[a+h]+G)],o=[String(y[a]+T),String(y[a+Z]+T),String(y[a+h]+T)],s=c,q=null!=N?o:J,t=null!=M?c:J;p.push("f "+s[0]+"/"+q[0]+"/"+t[0]+" "+s[1]+"/"+q[1]+"/"+t[1]+" "+s[2]+"/"+q[2]+"/"+t[2])}i&&L&&o.bakeTransformIntoVertices(L),G+=k,T+=n}return p.join("\n")}static MTL(a){const c=[],o=a.material;c.push("newmtl mat1"),c.push("  Ns "+o.specularPower.toFixed(4)),c.push("  Ni 1.5000"),c.push("  d "+o.alpha.toFixed(4)),c.push("  Tr 0.0000"),c.push("  Tf 1.0000 1.0000 1.0000"),c.push("  illum 2"),c.push("  Ka "+o.ambientColor.r.toFixed(4)+" "+o.ambientColor.g.toFixed(4)+" "+o.ambientColor.b.toFixed(4)),c.push("  Kd "+o.diffuseColor.r.toFixed(4)+" "+o.diffuseColor.g.toFixed(4)+" "+o.diffuseColor.b.toFixed(4)),c.push("  Ks "+o.specularColor.r.toFixed(4)+" "+o.specularColor.g.toFixed(4)+" "+o.specularColor.b.toFixed(4)),c.push("  Ke "+o.emissiveColor.r.toFixed(4)+" "+o.emissiveColor.g.toFixed(4)+" "+o.emissiveColor.b.toFixed(4));o.ambientTexture&&c.push("  map_Ka "+o.ambientTexture.name),o.diffuseTexture&&c.push("  map_Kd "+o.diffuseTexture.name),o.specularTexture&&c.push("  map_Ks "+o.specularTexture.name),o.bumpTexture&&c.push("  map_bump -imfchan z "+o.bumpTexture.name),o.opacityTexture&&c.push("  map_d "+o.opacityTexture.name);return c.join("\n")}}var p=0,G=o(12689);class T{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const a in this.files){const c=this.files[a],o=new Blob([c],{type:(0,G.e)(a)});q.Tools.Download(o,a)}}}var C=o(12882),j=o(13209),L=o(13220),e=o(13237),g=o(12936),M=o(12680),N=o(12858),y=o(12824);const k=y.HighestCommonFactor,n={...y,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:k};var f=o(13035),J=o(12796),w=o(13263),Z=o(13269),h=o(13027);const U=1e-6,S=new N.oo(.04,.04,.04),r=1024,x=N.oo.White(),R=N.oo.Black();function d(a,c,o){if(c<S.r)return 0;const s=S.r,q=a*o/(1-S.r)+c-2*S.r,t=q*q-4*s*(S.r-c);return n.Clamp((-q+Math.sqrt(t))/(2*s),0,1)}function X(a){const c=a.diffuseColor.toLinearSpace(a.Za().getEngine().useExactSrgbConversions).scale(.5),o=a.alpha,q=function(a){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new s.Vector2(0,1),o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new s.Vector2(0,.1),q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new s.Vector2(0,.1),t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new s.Vector2(1300,.1);return function(a,c,o,s,q){return(1-a)*(1-a)*(1-a)*c+3*(1-a)*(1-a)*a*o+3*(1-a)*a*a*s+a*a*a*q}(Math.pow(a/t.x,.333333),c.y,o.y,q.y,t.y)}(n.Clamp(a.specularPower,0,r));return{baseColorFactor:[c.r,c.g,c.b,o],metallicFactor:0,roughnessFactor:q}}function W(a,c){c.needAlphaBlending()?a.alphaMode="BLEND":c.needAlphaTesting()&&(a.alphaMode="MASK",a.alphaCutoff=c.alphaCutOff)}function F(a,c,o){const s=new Uint8Array(a*c*4);for(let q=0;q<s.length;q+=4)s[q]=s[q+1]=s[q+2]=s[q+3]=255;return w.b.CreateRGBATexture(s,a,c,o)}function O(a){if(a instanceof Uint8Array){const c=a.length,o=new Float32Array(a.length);for(let s=0;s<c;++s)o[s]=a[s]/255;return o}if(a instanceof Float32Array)return a;throw new Error("Unsupported pixel format!")}class B{constructor(a){this._exporter=a,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(a){return a?this._textureMap.get(a)??null:null}async exportStandardMaterialAsync(a,c,o){const s=X(a),t={name:a.name};if(null==a.Fc||a.Fc||(a.twoSidedLighting||q.Tools.Warn(a.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),t.doubleSided=!0),o){const o=[],q=a.diffuseTexture;q&&o.push(this.exportTextureAsync(q,c).then((a=>{a&&(s.baseColorTexture=a)})));const i=a.bumpTexture;i&&o.push(this.exportTextureAsync(i,c).then((a=>{a&&(t.normalTexture=a,1!==i.level&&(t.normalTexture.scale=i.level))})));const p=a.emissiveTexture;p&&(t.emissiveFactor=[1,1,1],o.push(this.exportTextureAsync(p,c).then((a=>{a&&(t.emissiveTexture=a)}))));const G=a.ambientTexture;G&&o.push(this.exportTextureAsync(G,c).then((a=>{if(a){const c={index:a.index};t.occlusionTexture=c}}))),o.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(o))}(a.alpha<1||a.opacityTexture)&&(a.alphaMode===Z.e.ALPHA_COMBINE?t.alphaMode="BLEND":q.Tools.Warn(a.name+": glTF 2.0 does not support alpha mode: "+a.alphaMode.toString())),a.emissiveColor&&!a.emissiveColor.equalsWithEpsilon(R,U)&&(t.emissiveFactor=a.emissiveColor.hc()),t.pbrMetallicRoughness=s,W(t,a),await this._finishMaterialAsync(t,a,c);const i=this._exporter._materials;return i.push(t),i.length-1}async _finishMaterialAsync(a,c,o){const s=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",a,c),q=[];for(const t of s)q.push(this.exportTextureAsync(t,o));await Promise.all(q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",a,c)}async _getImageDataAsync(a,c,s,q){const t=Z.e.TEXTURETYPE_UNSIGNED_BYTE,i=this._exporter._babylonScene,p=i.getEngine(),G=p.createRawTexture(a,c,s,Z.e.TEXTUREFORMAT_RGBA,!1,!0,J.e.NEAREST_SAMPLINGMODE,null,t);p.isWebGPU?await o.e(51).then(o.bind(o,15253)):await o.e(52).then(o.bind(o,15260)),await f.o.ApplyPostProcess("pass",G,i,t,Z.e.TEXTURE_NEAREST_SAMPLINGMODE,Z.e.TEXTUREFORMAT_RGBA);const T=await p._readTexturePixels(G,c,s);return await h.DumpTools.DumpDataAsync(c,s,T,q,void 0,!0,!0)}_resizeTexturesToSameDimensions(a,c,o){const s=a?a.getSize():{width:0,height:0},q=c?c.getSize():{width:0,height:0};let t,i;return s.width<q.width?(t=a&&a instanceof J.e?f.o.CreateResizedCopy(a,q.width,q.height,!0):F(q.width,q.height,o),i=c):s.width>q.width?(i=c&&c instanceof J.e?f.o.CreateResizedCopy(c,s.width,s.height,!0):F(s.width,s.height,o),t=a):(t=a,i=c),{texture1:t,texture2:i}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(a,c,o,s){const q=new Array;if(!a&&!c)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const t=a?a.Za():c?c.Za():null;if(t){var i;const p=this._resizeTexturesToSameDimensions(a,c,t),G=null===(i=p.texture1)||void 0===i?void 0:i.getSize();let T,C;const j=G.width,L=G.height,e=await p.texture1.readPixels(),g=await p.texture2.readPixels();if(!e)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(T=O(e),!g)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");C=O(g);const M=C.byteLength,y=new Uint8Array(M),k=new Uint8Array(M),n=4,f=R;let J=0,w=0;for(let a=0;a<L;++a)for(let c=0;c<j;++c){const s=(j*a+c)*n,q={diffuseColor:new N.oo(T[s],T[s+1],T[s+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(o.diffuseColor),specularColor:new N.oo(C[s],C[s+1],C[s+2]).toLinearSpace(t.getEngine().useExactSrgbConversions).multiply(o.specularColor),glossiness:C[s+3]*o.glossiness},i=this._convertSpecularGlossinessToMetallicRoughness(q);f.r=Math.max(f.r,i.baseColor.r),f.g=Math.max(f.g,i.baseColor.g),f.b=Math.max(f.b,i.baseColor.b),J=Math.max(J,i.metallic),w=Math.max(w,i.roughness),k[s]=255*i.baseColor.r,k[s+1]=255*i.baseColor.g,k[s+2]=255*i.baseColor.b,k[s+3]=p.texture1.Uc?255*T[s+3]:255,y[s]=0,y[s+1]=255*i.roughness,y[s+2]=255*i.metallic,y[s+3]=255}const Z={baseColor:f,metallic:J,roughness:w};let h=!1,S=!1;for(let a=0;a<L;++a)for(let c=0;c<j;++c){const o=(j*a+c)*n;k[o]/=Z.baseColor.r>U?Z.baseColor.r:1,k[o+1]/=Z.baseColor.g>U?Z.baseColor.g:1,k[o+2]/=Z.baseColor.b>U?Z.baseColor.b:1;const s=N.oo.FromInts(k[o],k[o+1],k[o+2]).toGammaSpace(t.getEngine().useExactSrgbConversions);k[o]=255*s.r,k[o+1]=255*s.g,k[o+2]=255*s.b,s.equalsWithEpsilon(x,U)||(S=!0),y[o+1]/=Z.roughness>U?Z.roughness:1,y[o+2]/=Z.metallic>U?Z.metallic:1;N.oo.FromInts(255,y[o+1],y[o+2]).equalsWithEpsilon(x,U)||(h=!0)}return h&&q.push(this._getImageDataAsync(y,j,L,s).then((a=>{Z.metallicRoughnessTextureData=a}))),S&&q.push(this._getImageDataAsync(k,j,L,s).then((a=>{Z.baseColorTextureData=a}))),await Promise.all(q).then((()=>Z))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(a){const c=this._getPerceivedBrightness(a.diffuseColor),o=this._getPerceivedBrightness(a.specularColor),s=1-this._getMaxComponent(a.specularColor),q=d(c,o,s),t=a.diffuseColor.scale(s/(1-S.r)/Math.max(1-q)),i=a.specularColor.vc(S.scale(1-q)).scale(1/Math.max(q));let p=N.oo.Lerp(t,i,q*q);p=p.clampToRef(0,1,p);return{baseColor:p,metallic:q,roughness:1-a.glossiness}}_getPerceivedBrightness(a){return a?Math.sqrt(.299*a.r*a.r+.587*a.g*a.g+.114*a.b*a.b):0}_getMaxComponent(a){return a?Math.max(a.r,Math.max(a.g,a.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(a,c,o,s){const q=[],t={baseColor:a._albedoColor,metallic:a._metallic,roughness:a._roughness};if(s){a._albedoTexture&&q.push(this.exportTextureAsync(a._albedoTexture,c).then((a=>{a&&(o.baseColorTexture=a)})));const s=a._metallicTexture;s&&q.push(this.exportTextureAsync(s,c).then((a=>{a&&(o.metallicRoughnessTexture=a)})))}return q.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(q)),t}_getTextureSampler(a){const c={};if(!a||!(a instanceof J.e))return c;const o=this._getGLTFTextureWrapMode(a.wrapU);10497!==o&&(c.wrapS=o);const s=this._getGLTFTextureWrapMode(a.wrapV);switch(10497!==s&&(c.wrapT=s),a.samplingMode){case J.e.LINEAR_LINEAR:c.magFilter=9729,c.minFilter=9729;break;case J.e.LINEAR_NEAREST:c.magFilter=9729,c.minFilter=9728;break;case J.e.NEAREST_LINEAR:c.magFilter=9728,c.minFilter=9729;break;case J.e.NEAREST_LINEAR_MIPLINEAR:c.magFilter=9728,c.minFilter=9987;break;case J.e.NEAREST_NEAREST:c.magFilter=9728,c.minFilter=9728;break;case J.e.NEAREST_LINEAR_MIPNEAREST:c.magFilter=9728,c.minFilter=9985;break;case J.e.LINEAR_NEAREST_MIPNEAREST:c.magFilter=9729,c.minFilter=9984;break;case J.e.LINEAR_NEAREST_MIPLINEAR:c.magFilter=9729,c.minFilter=9986;break;case J.e.NEAREST_NEAREST_MIPLINEAR:c.magFilter=9728,c.minFilter=9986;break;case J.e.LINEAR_LINEAR_MIPLINEAR:c.magFilter=9729,c.minFilter=9987;break;case J.e.LINEAR_LINEAR_MIPNEAREST:c.magFilter=9729,c.minFilter=9985;break;case J.e.NEAREST_NEAREST_MIPNEAREST:c.magFilter=9728,c.minFilter=9984}return c}_getGLTFTextureWrapMode(a){switch(a){case J.e.WRAP_ADDRESSMODE:return 10497;case J.e.CLAMP_ADDRESSMODE:return 33071;case J.e.MIRROR_ADDRESSMODE:return 33648;default:return q.Tools.Error(`Unsupported Texture Wrap Mode ${a}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(a,c,o,s){const q={diffuseColor:a._albedoColor,specularColor:a._reflectivityColor,glossiness:a._microSurface},t=a._albedoTexture,i=a._reflectivityTexture,p=a._useMicroSurfaceFromReflectivityMapAlpha;if(i&&!p)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((t||i)&&s){this._exporter._materialNeedsUVsSet.add(a);const s=this._exportTextureSampler(t||i),p=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,i,q,c),G=this._exporter._textures;if(p.baseColorTextureData){const a=this._exportImage(`baseColor${G.length}`,c,p.baseColorTextureData);o.baseColorTexture=this._exportTextureInfo(a,s,null===t||void 0===t?void 0:t.coordinatesIndex)}if(p.metallicRoughnessTextureData){const a=this._exportImage(`metallicRoughness${G.length}`,c,p.metallicRoughnessTextureData);o.metallicRoughnessTexture=this._exportTextureInfo(a,s,null===i||void 0===i?void 0:i.coordinatesIndex)}return p}return this._convertSpecularGlossinessToMetallicRoughness(q)}async exportPBRMaterialAsync(a,c,o){const s={},q={name:a.name},t=a.isMetallicWorkflow();if(t){const c=a._albedoColor,o=a.alpha;c&&(s.baseColorFactor=[c.r,c.g,c.b,o])}const i=t?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(a,c,s,o):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(a,c,s,o);await this._setMetallicRoughnessPbrMaterialAsync(i,a,q,s,c,o),await this._finishMaterialAsync(q,a,c);const p=this._exporter._materials;return p.push(q),p.length-1}async _setMetallicRoughnessPbrMaterialAsync(a,c,o,s,t,i){if(W(o,c),a.baseColor.equalsWithEpsilon(x,U)&&n.WithinEpsilon(c.alpha,1,U)||(s.baseColorFactor=[a.baseColor.r,a.baseColor.g,a.baseColor.b,c.alpha]),null!=a.metallic&&1!==a.metallic&&(s.metallicFactor=a.metallic),null!=a.roughness&&1!==a.roughness&&(s.roughnessFactor=a.roughness),null==c.Fc||c.Fc||(c._twoSidedLighting||q.Tools.Warn(c.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),o.doubleSided=!0),i){const a=[],s=c._bumpTexture;s&&a.push(this.exportTextureAsync(s,t).then((a=>{a&&(o.normalTexture=a,1!==s.level&&(o.normalTexture.scale=s.level))})));const q=c._ambientTexture;q&&a.push(this.exportTextureAsync(q,t).then((a=>{if(a){const s={index:a.index,texCoord:a.texCoord,extensions:a.extensions};o.occlusionTexture=s;const q=c._ambientTextureStrength;q&&(s.strength=q)}})));const i=c._emissiveTexture;i&&a.push(this.exportTextureAsync(i,t).then((a=>{a&&(o.emissiveTexture=a)}))),a.length>0&&(this._exporter._materialNeedsUVsSet.add(c),await Promise.all(a))}const p=c._emissiveColor;p.equalsWithEpsilon(R,U)||(o.emissiveFactor=p.hc()),o.pbrMetallicRoughness=s}_getPixelsFromTextureAsync(a){return function(a){switch(a){case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case Z.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case Z.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(a.textureFormat)?(0,f.k)(a,a._texture.width,a._texture.height):(a.textureType,Z.e.TEXTURETYPE_UNSIGNED_BYTE,a.readPixels())}async exportTextureAsync(a,c){const o=this._exporter._extensionsPreExportTextureAsync("exporter",a,c);return o?await o.then((async o=>o?await this._exportTextureInfoAsync(o,c):await this._exportTextureInfoAsync(a,c))):await this._exportTextureInfoAsync(a,c)}async _exportTextureInfoAsync(a,c){let o=this._textureMap.get(a);if(!o){const s=await this._getPixelsFromTextureAsync(a);if(!s)return null;const t=this._exportTextureSampler(a),i=a.mimeType;if(i)switch(i){case"image/jpeg":case"image/png":case"image/webp":c=i;break;default:q.Tools.Warn(`Unsupported media type: ${i}. Exporting texture as PNG.`)}const p=this._internalTextureToImage,G=a.getInternalTexture().uniqueId;p[G]||(p[G]={});let T=p[G][c];if(void 0===T){const o=a.getSize();T=(async()=>{const q=await this._getImageDataAsync(s,o.width,o.height,c);return this._exportImage(a.name,c,q)})(),p[G][c]=T}o=this._exportTextureInfo(await T,t,a.coordinatesIndex),this._textureMap.set(a,o),this._exporter._extensionsPostExportTextures("exporter",o,a)}return o}_exportImage(a,c,o){const s=this._exporter._images;let t;if(this._exporter._shouldUseGlb){t={name:a,mimeType:c,bufferView:void 0};const s=this._exporter._bufferManager.createBufferView(new Uint8Array(o));this._exporter._bufferManager.setBufferView(t,s)}else{const i=a.replace(/\.\/|\/|\.\\|\\/g,"_"),p=function(a){switch(a){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(c);let G=i+p;s.some((a=>a.uri===G))&&(G=`${i}_${q.Tools.RandomId()}${p}`),t={name:a,uri:G},this._exporter._imageData[G]={data:o,mimeType:c}}return s.push(t),s.length-1}_exportTextureInfo(a,c,o){const s=this._exporter._textures;let q=s.findIndex((o=>o.sampler==c&&o.source===a));-1===q&&(q=s.length,s.push({source:a,sampler:c}));const t={index:q};return o&&(t.texCoord=o),t}_exportTextureSampler(a){const c=this._getTextureSampler(a),o=this._exporter._samplers,s=o.findIndex((a=>a.minFilter===c.minFilter&&a.magFilter===c.magFilter&&a.wrapS===c.wrapS&&a.wrapT===c.wrapT));return-1!==s?s:(o.push(c),o.length-1)}}var u=o(12894),K=o(12649),D=o(13278),I=o(12812);const Y=s.Hc.Zero(),P=s.Quaternion.Identity(),ma=s.Hc.One(),V=new s.Hc(-1,1,1);function E(a,c){const{byteOffset:o,byteStride:s,type:q,normalized:t}=a,i=a.getSize(),p=c.reduce(((a,c)=>c.getTotalVertices()>a?c.getTotalVertices():a),-Number.MAX_VALUE);return{byteOffset:o,byteStride:s,componentCount:i,type:q,count:p*i,normalized:t,totalVertices:p,kind:a.getKind()}}function H(a){switch(a){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function b(a){switch(a){case C.g.PositionKind:case C.g.NormalKind:case C.g.TangentKind:case C.g.ColorKind:case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:case C.g.MatricesWeightsKind:case C.g.MatricesWeightsExtraKind:case C.g.UVKind:case C.g.UV2Kind:case C.g.UV3Kind:case C.g.UV4Kind:case C.g.UV5Kind:case C.g.UV6Kind:return!0}return!1}function A(a){switch(a){case t.b.TriangleFillMode:return 4;case t.b.TriangleStripDrawMode:return 5;case t.b.TriangleFanDrawMode:return 6;case t.b.PointListDrawMode:case t.b.PointFillMode:return 0;case t.b.LineLoopDrawMode:return 2;case t.b.LineListDrawMode:return 1;case t.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${a}`)}function v(a){const c=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);c>0&&(a.x/=c,a.y/=c,a.z/=c)}function l(a){return a.x*=-1,a}function Q(a){if(a.x*a.x+a.y*a.y>.5){const c=Math.abs(a.x),o=Math.abs(a.y);if(c>o){const o=Math.sign(a.x);a.x=c,a.y*=-o,a.z*=-o,a.w*=o}else{const c=Math.sign(a.y);a.x*=-c,a.y=o,a.z*=c,a.w*=-c}}else{const c=Math.abs(a.z),o=Math.abs(a.w);if(c>o){const o=Math.sign(a.z);a.x*=-o,a.y*=o,a.z=c,a.w*=-o}else{const c=Math.sign(a.w);a.x*=c,a.y*=-c,a.z*=-c,a.w=o}}return a}function z(a){a.Bc(-a.z,a.w,a.x,-a.y)}function aa(a,c){const o=s.Hc.FromArrayToRef(c.translation||[0,0,0],0,s.TmpVectors.Hc[0]),q=s.Quaternion.FromArrayToRef(c.rotation||[0,0,0,1],0,s.TmpVectors.Quaternion[0]),t=s.Matrix.ComposeToRef(ma,q,o,s.TmpVectors.Matrix[0]),i=s.Hc.FromArrayToRef(a.translation||[0,0,0],0,s.TmpVectors.Hc[2]),p=s.Quaternion.FromArrayToRef(a.rotation||[0,0,0,1],0,s.TmpVectors.Quaternion[1]),G=s.Matrix.ComposeToRef(ma,p,i,s.TmpVectors.Matrix[1]);t.multiplyToRef(G,G),G.decompose(void 0,q,o),o.equalsWithEpsilon(Y,I.b)?delete c.translation:c.translation=o.hc(),q.equalsWithEpsilon(P,I.b)?delete c.rotation:c.rotation=q.hc(),c.scale&&delete c.scale}function ca(a,c){if(!(c instanceof j.b))return!1;if(!(1===c.getChildren().length&&0===a.getChildren().length&&a.parent===c))return!1;const o=a.Za(),s=a instanceof D.b&&!o.useRightHandedSystem?V:ma;return!!c.uc.equalsWithEpsilon(s,I.b)||(K.c.Warn(`Cannot collapse node ${a.name} into parent node ${c.name} with modified scaling.`),!1)}function oa(a){if(a instanceof Array){const c=new Float32Array(a);return new Uint8Array(c.buffer,c.byteOffset,c.byteLength)}return ArrayBuffer.isView(a)?new Uint8Array(a.buffer,a.byteOffset,a.byteLength):new Uint8Array(a)}function sa(a,c){for(const[o,s]of Object.entries(a)){const q=c[o];(Array.isArray(s)&&Array.isArray(q)&&qa(s,q)||s===q)&&delete a[o]}return a}function qa(a,c){return a.length===c.length&&a.every(((a,o)=>a===c[o]))}const ta=s.Matrix.Compose(new s.Hc(-1,1,1),s.Quaternion.Identity(),s.Hc.Zero());function ia(a,c){if(!(a instanceof j.b))return!1;if(c){if(!a.getWorldMatrix().equalsWithEpsilon(s.Matrix.IdentityReadOnly,I.b))return!1}else{if(!a.getWorldMatrix().multiplyToRef(ta,s.TmpVectors.Matrix[0]).equalsWithEpsilon(s.Matrix.IdentityReadOnly,I.b))return!1}return!(a instanceof L.e&&a.dc)}const pa=new Map([[Int8Array,(a,c,o)=>a.setInt8(c,o)],[Uint8Array,(a,c,o)=>a.setUint8(c,o)],[Uint8ClampedArray,(a,c,o)=>a.setUint8(c,o)],[Int16Array,(a,c,o)=>a.setInt16(c,o,!0)],[Uint16Array,(a,c,o)=>a.setUint16(c,o,!0)],[Int32Array,(a,c,o)=>a.setInt32(c,o,!0)],[Uint32Array,(a,c,o)=>a.setUint32(c,o,!0)],[Float32Array,(a,c,o)=>a.setFloat32(c,o,!0)],[Float64Array,(a,c,o)=>a.setFloat64(c,o,!0)]]);class Ga{writeTypedArray(a){this._checkGrowBuffer(a.byteLength);const c=pa.get(a.constructor);for(let o=0;o<a.length;o++)c(this._dataView,this._byteOffset,a[o]),this._byteOffset+=a.BYTES_PER_ELEMENT}constructor(a){this._data=new Uint8Array(a),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(a){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,a),this._byteOffset++}writeInt8(a){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,a),this._byteOffset++}writeInt16(a){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,a,!0),this._byteOffset+=2}writeUInt16(a){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,a,!0),this._byteOffset+=2}writeInt32(a){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,a,!0),this._byteOffset+=4}writeUInt32(a){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,a,!0),this._byteOffset+=4}writeFloat32(a){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,a,!0),this._byteOffset+=4}writeFloat64(a){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,a,!0),this._byteOffset+=8}_checkGrowBuffer(a){const c=this.byteOffset+a;if(c>this._data.byteLength){const a=new Uint8Array(2*c);a.set(this._data),this._data=a,this._dataView=new DataView(this._data.buffer)}}}function Ta(a){return a%4===0?4:a%2===0?2:1}class Ca{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(a){let c=0;this._bufferViewToData.forEach((a=>{c+=a.byteLength}));const o=new Ga(c),s=Array.from(this._bufferViewToData.keys()).sort(((a,c)=>Ta(c.byteLength)-Ta(a.byteLength)));for(const q of s){q.byteOffset=o.byteOffset,a.push(q);const c=a.length-1,s=this.getPropertiesWithBufferView(q);for(const a of s)a.bufferView=c;o.writeTypedArray(this._bufferViewToData.get(q)),this._bufferViewToData.delete(q)}return o.getOutputData()}createBufferView(a,c){const o={buffer:0,byteOffset:void 0,byteLength:a.byteLength,byteStride:c};return this._bufferViewToData.set(o,a),o}createAccessor(a,c,o,s,q,t,i){this._verifyBufferView(a);const p={bufferView:void 0,componentType:o,count:s,type:c,min:null===t||void 0===t?void 0:t.min,max:null===t||void 0===t?void 0:t.max,normalized:i,byteOffset:q};return this.setBufferView(p,a),this._accessorToBufferView.set(p,a),p}setBufferView(a,c){this._verifyBufferView(c);this.getPropertiesWithBufferView(c).push(a)}removeBufferView(a){const c=this.getPropertiesWithBufferView(a);for(const o of c)void 0!==o.bufferView&&delete o.bufferView;this._bufferViewToData.delete(a),this._bufferViewToProperties.delete(a),this._accessorToBufferView.forEach(((c,o)=>{c===a&&(void 0!==o.byteOffset&&delete o.byteOffset,this._accessorToBufferView.delete(o))}))}getBufferView(a){const c=this._accessorToBufferView.get(a);return this._verifyBufferView(c),c}getPropertiesWithBufferView(a){return this._verifyBufferView(a),this._bufferViewToProperties.set(a,this._bufferViewToProperties.get(a)??[]),this._bufferViewToProperties.get(a)}getData(a){return this._verifyBufferView(a),this._bufferViewToData.get(a)}_verifyBufferView(a){if(void 0===a||!this._bufferViewToData.has(a))throw new Error(`BufferView ${a} not found in BufferManager.`)}}var ja,La=o(13246),ea=o(13261),ga=o(13286),Ma=o(13166),Na=o(13322),ya=o(13335),ka=o(13241),na=o(13344);!function(a){a[a.INTANGENT=0]="INTANGENT",a[a.OUTTANGENT=1]="OUTTANGENT"}(ja||(ja={}));class fa{static _IsTransformable(a){return a&&(a instanceof j.b||a instanceof La.b||a instanceof na.e)}static _CreateNodeAnimation(a,c,o,s,t){if(this._IsTransformable(a)){const i=[],p=[],G=c.getKeys(),T=fa._CalculateMinMaxKeyFrames(G),C=fa._DeduceInterpolation(G,o,s),j=C.interpolationType,L=C.shouldBakeAnimation;if(L?fa._CreateBakedAnimation(a,c,o,T.min,T.max,c.framePerSecond,t,i,p,T,s):"LINEAR"===j||"STEP"===j?fa._CreateLinearOrStepAnimation(a,c,o,i,p,s):"CUBICSPLINE"===j?fa._CreateCubicSplineAnimation(a,c,o,i,p,s):fa._CreateBakedAnimation(a,c,o,T.min,T.max,c.framePerSecond,t,i,p,T,s),i.length&&p.length){return{inputs:i,outputs:p,samplerInterpolation:j,inputsMin:L?T.min:q.Tools.FloatRound(T.min/c.framePerSecond),inputsMax:L?T.max:q.Tools.FloatRound(T.max/c.framePerSecond)}}}return null}static _DeduceAnimationInfo(a){let c=null,o="VEC3",s=!1;const t=a.targetProperty.split(".");switch(t[0]){case"uc":c="scale";break;case"position":c="translation";break;case"rotation":o="VEC4",c="rotation";break;case"rotationQuaternion":o="VEC4",s=!0,c="rotation";break;case"influence":o="SCALAR",c="weights";break;default:q.Tools.Error(`Unsupported animatable property ${t[0]}`)}return c?{animationChannelTargetPath:c,dataAccessorType:o,useQuaternion:s}:(q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(a,c,o,s,q,t,i,p,G,T,C){let j;if(fa._IsTransformable(a)&&a.animations)for(const L of a.animations){if(C&&!C(L))continue;const q=fa._DeduceAnimationInfo(L);q&&(j={name:L.name,samplers:[],channels:[]},fa._AddAnimation(`${L.name}`,L.hasRunningRuntimeAnimations?c:j,a,L,q.dataAccessorType,q.animationChannelTargetPath,s,t,i,p,q.useQuaternion,G,T),j.samplers.length&&j.channels.length&&o.push(j))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(a,c,o,s,q,t,i,p,G,T,C){let j;if(a instanceof ka.c){const q=a.morphTargetManager;if(q)for(let L=0;L<q.numTargets;++L){const e=q.getTarget(L);for(const g of e.animations){if(C&&!C(g))continue;const e=new Na.b(`${g.name}`,"influence",g.framePerSecond,g.dataType,g.loopMode,g.enableBlending),M=[],N=g.getKeys();for(let a=0;a<N.length;++a){const c=N[a];for(let a=0;a<q.numTargets;++a)a==L?M.push(c):M.push({frame:c.frame,value:0})}e.setKeys(M);const y=fa._DeduceAnimationInfo(e);y&&(j={name:e.name,samplers:[],channels:[]},fa._AddAnimation(g.name,g.hasRunningRuntimeAnimations?c:j,a,e,y.dataAccessorType,y.animationChannelTargetPath,s,t,i,p,y.useQuaternion,G,T,q.numTargets),j.samplers.length&&j.channels.length&&o.push(j))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(a,c,o,s,q,t,i,p,G){let T;if(a.animationGroups){const j=a.animationGroups;for(const L of j){const j=new Map,e=new Map,g=new Set,M=L.to-L.from;T={name:L.name,channels:[],samplers:[]};for(let c=0;c<L.targetedAnimations.length;++c){const M=L.targetedAnimations[c],N=M.target,y=M.animation;if(G&&!G(y))continue;const k=p.has(N);if(this._IsTransformable(N)||1===N.length&&this._IsTransformable(N[0])){const a=fa._DeduceAnimationInfo(M.animation);if(a){const c=this._IsTransformable(N)?N:this._IsTransformable(N[0])?N[0]:null;c&&fa._AddAnimation(`${y.name}`,T,c,y,a.dataAccessorType,a.animationChannelTargetPath,o,s,q,t,a.useQuaternion,i,k)}}else if(N instanceof ya.c||1===N.length&&N[0]instanceof ya.c){if(fa._DeduceAnimationInfo(M.animation)){const c=N instanceof ya.c?N:N[0];if(c){const o=a.morphTargetManagers.find((a=>{for(let o=0;o<a.numTargets;++o)if(a.getTarget(o)===c)return!0;return!1}));if(o){const s=a.meshes.find((a=>a.morphTargetManager===o));var C;if(s)j.has(s)||j.set(s,new Map),null===(C=j.get(s))||void 0===C||C.set(c,y),g.add(s),e.set(s,y)}}}}}g.forEach((a=>{const c=a.morphTargetManager;let p=null;const G=[],C=e.get(a).getKeys(),g=C.length;for(let o=0;o<g;++o)for(let s=0;s<c.numTargets;++s){const q=c.getTarget(s),t=j.get(a);if(t){const c=t.get(q);c?(p||(p=new Na.b(`${L.name}_${a.name}_MorphWeightAnimation`,"influence",c.framePerSecond,Na.b.ANIMATIONTYPE_FLOAT,c.loopMode,c.enableBlending)),G.push(c.getKeys()[o])):G.push({frame:L.from+M/g*o,value:q.influence,inTangent:C[0].inTangent?0:void 0,outTangent:C[0].outTangent?0:void 0})}}p.setKeys(G);const N=fa._DeduceAnimationInfo(p);N&&fa._AddAnimation(`${L.name}_${a.name}_MorphWeightAnimation`,T,a,p,N.dataAccessorType,N.animationChannelTargetPath,o,s,q,t,N.useQuaternion,i,!1,null===c||void 0===c?void 0:c.numTargets)})),T.channels.length&&T.samplers.length&&c.push(T)}}}static _AddAnimation(a,c,o,q,t,i,p,G,T,C,j,L,e,g){const M=fa._CreateNodeAnimation(o,q,i,j,L);let N,y,k,n,f,J;if(M){if(g){let a=0,c=0;const o=[];for(;M.inputs.length>0;)c=M.inputs.shift(),a%g==0&&o.push(c),a++;M.inputs=o}const a=p.get(o),q=new Float32Array(M.inputs);N=G.createBufferView(q),y=G.createAccessor(N,"SCALAR",5126,M.inputs.length,void 0,{min:[M.inputsMin],max:[M.inputsMax]}),C.push(y),k=C.length-1;const T=new s.Quaternion,j=new s.Hc,L=new s.Hc,w=o instanceof La.b,Z=H(t),h=new Float32Array(M.outputs.length*Z);M.outputs.forEach((function(a,c){let o=a;switch(i){case"translation":e&&(s.Hc.FromArrayToRef(a,0,L),l(L),L.toArray(o));break;case"rotation":4===a.length?s.Quaternion.FromArrayToRef(a,0,T):(o=new Array(4),s.Hc.FromArrayToRef(a,0,j),s.Quaternion.FromEulerVectorToRef(j,T)),e&&(Q(T),w&&z(T)),T.toArray(o)}h.set(o,c*Z)})),N=G.createBufferView(h),y=G.createAccessor(N,t,5126,M.outputs.length),C.push(y),n=C.length-1,f={interpolation:M.samplerInterpolation,input:k,output:n},c.samplers.push(f),J={sampler:c.samplers.length-1,target:{node:a,path:i}},c.channels.push(J)}}static _CreateBakedAnimation(a,c,o,t,i,p,G,T,C,j,L){let e;const g=s.Quaternion.Identity();let M,N=null,y=null,k=null,n=null,f=null,J=null;j.min=q.Tools.FloatRound(t/p);const w=c.getKeys();for(let s=0,Z=w.length;s<Z;++s){if(J=null,k=w[s],s+1<Z)if(n=w[s+1],k.value.equals&&k.value.equals(n.value)||k.value===n.value){if(0!==s)continue;J=k.frame}else J=n.frame;else{if(f=w[s-1],k.value.equals&&k.value.equals(f.value)||k.value===f.value)continue;J=i}if(J)for(let s=k.frame;s<=J;s+=G){if(M=q.Tools.FloatRound(s/p),M===N)continue;N=M,y=M;const t={key:0,repeatCount:0,loopMode:c.loopMode};e=c._interpolate(s,t),fa._SetInterpolatedValue(a,e,M,c,o,g,T,C,L)}}y&&(j.max=y)}static _ConvertFactorToVector3OrQuaternion(a,c,o,t,i){const p=fa._GetBasePositionRotationOrScale(c,t,i),G=o.targetProperty.split("."),T=G?G[1]:"",C=i?s.Quaternion.qo(p).normalize():s.Hc.qo(p);switch(T){case"x":case"y":case"z":C[T]=a;break;case"w":C.w=a;break;default:q.Tools.Error(`glTFAnimation: Unsupported component name "${T}"!`)}return C}static _SetInterpolatedValue(a,c,o,q,t,i,p,G,T){let C;p.push(o),"weights"!==t?(q.dataType===Na.b.ANIMATIONTYPE_FLOAT&&(c=this._ConvertFactorToVector3OrQuaternion(c,a,q,t,T)),"rotation"===t?(T?i=c:(C=c,s.Quaternion.RotationYawPitchRollToRef(C.y,C.x,C.z,i)),G.push(i.hc())):(C=c,G.push(C.hc()))):G.push([c])}static _CreateLinearOrStepAnimation(a,c,o,s,q,t){for(const i of c.getKeys())s.push(i.frame/c.framePerSecond),fa._AddKeyframeValue(i,c,q,o,a,t)}static _CreateCubicSplineAnimation(a,c,o,s,q,t){c.getKeys().forEach((function(i){s.push(i.frame/c.framePerSecond),fa._AddSplineTangent(ja.INTANGENT,q,o,"CUBICSPLINE",i,t),fa._AddKeyframeValue(i,c,q,o,a,t),fa._AddSplineTangent(ja.OUTTANGENT,q,o,"CUBICSPLINE",i,t)}))}static _GetBasePositionRotationOrScale(a,c,o){let q;if("rotation"===c)if(o){q=(a.rotationQuaternion??s.Quaternion.Identity()).hc()}else{q=(a.rotation??s.Hc.Zero()).hc()}else if("translation"===c){q=(a.position??s.Hc.Zero()).hc()}else{q=(a.uc??s.Hc.One()).hc()}return q}static _AddKeyframeValue(a,c,o,t,i,p){let G;const T=c.dataType;if(T===Na.b.ANIMATIONTYPE_VECTOR3){let c=a.value.hc();if("rotation"===t){const a=s.Hc.qo(c);c=s.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).hc()}o.push(c)}else if(T===Na.b.ANIMATIONTYPE_FLOAT){if("weights"===t)o.push([a.value]);else if(G=this._ConvertFactorToVector3OrQuaternion(a.value,i,c,t,p),G){if("rotation"===t){const a=p?G:s.Quaternion.RotationYawPitchRoll(G.y,G.x,G.z).normalize();o.push(a.hc())}o.push(G.hc())}}else T===Na.b.ANIMATIONTYPE_QUATERNION?o.push(a.value.normalize().hc()):q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(a,c,o){let s,q,t=!1;if("rotation"===c&&!o)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let i=0,p=a.length;i<p;++i)if(q=a[i],q.inTangent||q.outTangent)if(s){if("CUBICSPLINE"!==s){s="LINEAR",t=!0;break}}else s="CUBICSPLINE";else if(s){if("CUBICSPLINE"===s||q.interpolation&&1===q.interpolation&&"STEP"!==s){s="LINEAR",t=!0;break}}else s=q.interpolation&&1===q.interpolation?"STEP":"LINEAR";return s||(s="LINEAR"),{interpolationType:s,shouldBakeAnimation:t}}static _AddSplineTangent(a,c,o,q,t,i){let p;const G=a===ja.INTANGENT?t.inTangent:t.outTangent;if("CUBICSPLINE"===q){if("rotation"===o)if(G)if(i)p=G.hc();else{const a=G;p=s.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).hc()}else p=[0,0,0,0];else p="weights"===o?G?[G]:[0]:G?G.hc():[0,0,0];c.push(p)}}static _CalculateMinMaxKeyFrames(a){let c=1/0,o=-1/0;return a.forEach((function(a){c=Math.min(c,a.frame),o=Math.max(o,a.frame)})),{min:c,max:o}}}function Ja(a,c,o,t,i,p){const G={attributes:{},influence:a.influence,name:a.name},T=c.dc;if(!T)return q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),G;const j=p?-1:1,L=s.Hc.Zero();let e=0,g=0;if(a.hasPositions){const t=a.getPositions(),p=T.getVerticesData(C.g.PositionKind);if(p){const a=new Float32Array(p.length),c=[1/0,1/0,1/0],q=[-1/0,-1/0,-1/0];g=p.length/3,e=0;for(let o=e;o<g;++o){const i=s.Hc.qo(p,3*o);s.Hc.qo(t,3*o).subtractToRef(i,L),L.x*=j,c[0]=Math.min(c[0],L.x),q[0]=Math.max(q[0],L.x),c[1]=Math.min(c[1],L.y),q[1]=Math.max(q[1],L.y),c[2]=Math.min(c[2],L.z),q[2]=Math.max(q[2],L.z),a[3*o]=L.x,a[3*o+1]=L.y,a[3*o+2]=L.z}const T=o.createBufferView(a,12),C=o.createAccessor(T,"VEC3",5126,t.length/3,0,{min:c,max:q});i.push(C),G.attributes.POSITION=i.length-1}else q.Tools.Warn(`Morph target positions for mesh ${c.name} were not exported. Mesh does not have position vertex data`)}if(a.hasNormals){const t=a.getNormals(),p=T.getVerticesData(C.g.NormalKind);if(p){const a=new Float32Array(p.length);g=p.length/3,e=0;for(let o=e;o<g;++o){const c=s.Hc.qo(p,3*o).normalize();s.Hc.qo(t,3*o).normalize().subtractToRef(c,L),a[3*o]=L.x*j,a[3*o+1]=L.y,a[3*o+2]=L.z}const c=o.createBufferView(a,12),q=o.createAccessor(c,"VEC3",5126,t.length/3,0);i.push(q),G.attributes.NORMAL=i.length-1}else q.Tools.Warn(`Morph target normals for mesh ${c.name} were not exported. Mesh does not have normals vertex data`)}if(a.hasTangents){const t=a.getTangents(),p=T.getVerticesData(C.g.TangentKind);if(p){g=p.length/4;const a=new Float32Array(3*g);e=0;for(let o=e;o<g;++o){const c=s.Hc.qo(p,4*o);v(c);const q=s.Hc.qo(t,3*o);v(q),q.subtractToRef(c,L),a[3*o]=L.x*j,a[3*o+1]=L.y,a[3*o+2]=L.z}const c=o.createBufferView(a,12),q=o.createAccessor(c,"VEC3",5126,g,0);i.push(q),G.attributes.TANGENT=i.length-1}else q.Tools.Warn(`Morph target tangents for mesh ${c.name} were not exported. Mesh does not have tangents vertex data`)}if(a.hasColors){const t=a.getColors(),p=T.getVerticesData(C.g.ColorKind),j=T.getVertexBuffer(C.g.ColorKind);if(p&&j){const a=j.getSize();g=p.length/a;const c=new Float32Array(g*a);e=0;for(let o=e;o<g;++o)if(3===a){const q=s.Hc.qo(p,o*a);s.Hc.qo(t,o*a).subtractToRef(q,L),c[3*o]=L.x,c[3*o+1]=L.y,c[3*o+2]=L.z}else if(4===a){const q=new s.Vector4,i=s.Vector4.qo(p,o*a);s.Vector4.qo(t,o*a).subtractToRef(i,q),c[4*o]=q.x,c[4*o+1]=q.y,c[4*o+2]=q.z,c[4*o+3]=q.w}else q.Tools.Warn(`Unsupported number of components for color attribute: ${a}`);const T=o.createBufferView(c,4*a),C=o.createAccessor(T,3===a?"VEC3":"VEC4",5126,g,0);i.push(C),G.attributes.COLOR_0=i.length-1}else q.Tools.Warn(`Morph target colors for mesh ${c.name} were not exported. Mesh does not have colors vertex data`)}return G}var wa=o(13348),Za=o(13193),ha=o(13173),Ua=o(12776);class Sa{}Sa.DEFAULT_COLOR=N.oo.White(),Sa.DEFAULT_WIDTH_ATTENUATED=1,Sa.DEFAULT_WIDTH=.1;var ra=o(13016),xa=o(13352);class Ra{static ConvertPoints(a,c){if(a.length&&Array.isArray(a)&&"number"===typeof a[0])return[a];if(a.length&&Array.isArray(a[0])&&"number"===typeof a[0][0])return a;if(a.length&&!Array.isArray(a[0])&&a[0]instanceof s.Hc){const c=[];for(let o=0;o<a.length;o++){const s=a[o];c.push(s.x,s.y,s.z)}return[c]}if(a.length>0&&Array.isArray(a[0])&&a[0].length>0&&a[0][0]instanceof s.Hc){const c=[],o=a;for(const a of o)c.push(a.flatMap((a=>[a.x,a.y,a.z])));return c}if(a instanceof Float32Array){if(null!==c&&void 0!==c&&c.floatArrayStride){const o=[],s=3*c.floatArrayStride;for(let c=0;c<a.length;c+=s){const q=new Array(s);for(let o=0;o<s;o++)q[o]=a[c+o];o.push(q)}return o}return[Array.from(a)]}if(a.length&&a[0]instanceof Float32Array){const c=[];for(const o of a)c.push(Array.from(o));return c}return[]}static OmitZeroLengthPredicate(a,c,o){const s=[];return c.vc(a).lengthSquared()>0&&s.push([a,c]),o.vc(c).lengthSquared()>0&&s.push([c,o]),a.vc(o).lengthSquared()>0&&s.push([o,a]),0===s.length?null:s}static OmitDuplicatesPredicate(a,c,o,s){const q=[];return Ra._SearchInPoints(a,c,s)||q.push([a,c]),Ra._SearchInPoints(c,o,s)||q.push([c,o]),Ra._SearchInPoints(o,a,s)||q.push([o,a]),0===q.length?null:q}static _SearchInPoints(a,c,o){for(const i of o)for(let o=0;o<i.length;o++){var s,q,t;if(null!==(s=i[o])&&void 0!==s&&s.equals(a))if(null!==(q=i[o+1])&&void 0!==q&&q.equals(c)||null!==(t=i[o-1])&&void 0!==t&&t.equals(c))return!0}return!1}static MeshesToLines(a,c){const o=[];for(let q=0;q<a.length;q++){const t=a[q],i=t.getVerticesData(C.g.PositionKind),p=t.Wc();if(i&&p)for(let a=0,G=0;a<p.length;a++){const T=3*p[G++],C=3*p[G++],j=3*p[G++],L=new s.Hc(i[T],i[T+1],i[T+2]),e=new s.Hc(i[C],i[C+1],i[C+2]),g=new s.Hc(i[j],i[j+1],i[j+2]);if(c){const s=c(L,e,g,o,a,T,t,q,i,p);if(s)for(const a of s)o.push(a)}else o.push([L,e],[e,g],[g,L])}}return o}static ToVector3Array(a){if(Array.isArray(a[0])){const c=[],o=a;for(const a of o){const o=[];for(let c=0;c<a.length;c+=3)o.push(new s.Hc(a[c],a[c+1],a[c+2]));c.push(o)}return c}const c=a,o=[];for(let q=0;q<c.length;q+=3)o.push(new s.Hc(c[q],c[q+1],c[q+2]));return o}static ToNumberArray(a){return a.flatMap((a=>[a.x,a.y,a.z]))}static GetPointsCountInfo(a){const c=new Array(a.length);let o=0;for(let s=a.length;s--;)c[s]=a[s].length/3,o+=c[s];return{total:o,counts:c}}static GetLineLength(a){if(0===a.length)return 0;let c;c="number"===typeof a[0]?Ra.ToVector3Array(a):a;const o=s.TmpVectors.Hc[0];let q=0;for(let s=0;s<c.length-1;s++){const a=c[s];q+=c[s+1].subtractToRef(a,o).length()}return q}static GetLineLengthArray(a){const c=new Float32Array(a.length/3);let o=0;for(let s=0,q=a.length/3-1;s<q;s++){let q=a[3*s+0],t=a[3*s+1],i=a[3*s+2];q-=a[3*s+3],t-=a[3*s+4],i-=a[3*s+5];o+=Math.sqrt(q*q+t*t+i*i),c[s+1]=o}return c}static SegmentizeSegmentByCount(a,c,o){const q=[],t=c.vc(a),i=s.TmpVectors.Hc[0];i.Dc(o);const p=s.TmpVectors.Hc[1];t.divideToRef(i,p);let G=a.clone();q.push(G);for(let s=0;s<o;s++)G=G.clone(),q.push(G.addInPlace(p));return q}static SegmentizeLineBySegmentLength(a,c){const o=a[0]instanceof s.Hc?Ra.GetLineSegments(a):"number"===typeof a[0]?Ra.GetLineSegments(Ra.ToVector3Array(a)):a,q=[];for(const s of o)if(s.length>c){const a=Ra.SegmentizeSegmentByCount(s.point1,s.point2,Math.ceil(s.length/c));for(const c of a)q.push(c)}else q.push(s.point1),q.push(s.point2);return q}static SegmentizeLineBySegmentCount(a,c){const o="number"===typeof a[0]?Ra.ToVector3Array(a):a,s=Ra.GetLineLength(o)/c;return Ra.SegmentizeLineBySegmentLength(o,s)}static GetLineSegments(a){const c=[];for(let o=0;o<a.length-1;o++){const s=a[o],q=a[o+1],t=q.vc(s).length();c.push({point1:s,point2:q,length:t})}return c}static GetMinMaxSegmentLength(a){const c=Ra.GetLineSegments(a).sort((a=>a.length));return{min:c[0].length,max:c[c.length-1].length}}static GetPositionOnLineByVisibility(a,c,o){let q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const t=c*o;let i=0,p=0;const G=a.length;for(let s=0;s<G;s++){if(t<=i+a[s].length){p=s;break}i+=a[s].length}const T=(t-i)/a[p].length;return a[p].point2.subtractToRef(a[p].point1,s.TmpVectors.Hc[0]),s.TmpVectors.Hc[1]=s.TmpVectors.Hc[0].multiplyByFloats(T,T,T),q||s.TmpVectors.Hc[1].addInPlace(a[p].point1),s.TmpVectors.Hc[1].clone()}static GetCircleLinePoints(a,c){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a,t=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/c;const i=[];for(let p=0;p<=c;p++)i.push(new s.Hc(Math.cos(p*t)*a,Math.sin(p*t)*q,o));return i}static GetBezierLinePoints(a,c,o,s){return ra.f.CreateQuadraticBezier(a,c,o,s).getPoints().flatMap((a=>[a.x,a.y,a.z]))}static GetArrowCap(a,c,o,s,q){let t=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[a.clone(),a.add(c.multiplyByFloats(o,o,o))],widths:[s,q,t,i]}}static GetPointsFromText(a,c,o,s){let q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,t=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i=[],p=(0,xa.c)(a,c,o,s);for(const G of p){for(const a of G.paths){const c=[],o=a.getPoints();for(const a of o)c.push(a.x,a.y,q);i.push(c)}if(t)for(const a of G.holes){const c=[],o=a.getPoints();for(const a of o)c.push(a.x,a.y,q);i.push(c)}}return i}static Color3toRGBAUint8(a){const c=new Uint8Array(4*a.length);for(let o=0,s=0;o<a.length;o++)c[s++]=255*a[o].r,c[s++]=255*a[o].g,c[s++]=255*a[o].b,c[s++]=255;return c}static CreateColorsTexture(a,c,o,s){const q=s.getEngine().getCaps().maxTextureSize??1,t=c.length>q?q:c.length,i=Math.ceil(c.length/q);i>1&&(c=[...c,...Array(t*i-c.length).fill(c[0])]);const p=Ra.Color3toRGBAUint8(c),G=new w.b(p,t,i,g.e.TEXTUREFORMAT_RGBA,s,!1,!0,o);return G.name=a,G}static PrepareEmptyColorsTexture(a){if(!Sa.EmptyColorsTexture){const c=new Uint8Array(4);Sa.EmptyColorsTexture=new w.b(c,1,1,g.e.TEXTUREFORMAT_RGBA,a,!1,!1,w.b.NEAREST_NEAREST),Sa.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Sa.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var a;null===(a=Sa.EmptyColorsTexture)||void 0===a||a.dispose(),Sa.EmptyColorsTexture=null}static BooleanToNumber(a){return a?1:0}}class da extends ha.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Xa extends Za.b{isCompatible(a){return!0}constructor(a,c,o){var q;o=o||{color:Sa.DEFAULT_COLOR};const t=new da;t.GREASED_LINE_HAS_COLOR=!!o.color&&!o.useColors,t.GREASED_LINE_SIZE_ATTENUATION=o.sizeAttenuation??!1,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===o.colorDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(c??a.Za()).useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=o.cameraFacing??!0,super(a,Xa.GREASED_LINE_MATERIAL_NAME,200,t,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(q=o)||void 0===q?void 0:q.forceGLSL)||Xa.ForceGLSL,this._scene=c??a.Za(),this._engine=this._scene.getEngine(),this._cameraFacing=o.cameraFacing??!0,this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.width=o.width?o.width:o.sizeAttenuation?Sa.DEFAULT_WIDTH_ATTENUATED:Sa.DEFAULT_WIDTH,this._sizeAttenuation=o.sizeAttenuation??!1,this.colorMode=o.colorMode??0,this._color=o.color??null,this.useColors=o.useColors??!1,this._colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??w.b.NEAREST_NEAREST,this._colors=o.ra??null,this.dashCount=o.dashCount??1,this.resolution=o.resolution??new s.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=Ra.CreateColorsTexture(`${a.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Sa.DEFAULT_COLOR,Ra.PrepareEmptyColorsTexture(this._scene)),this._engine.gc.add((()=>{Ra.DisposeEmptyColorsTexture()}))}getAttributes(a){a.push("grl_offsets"),a.push("grl_widths"),a.push("grl_colorPointers"),a.push("grl_counters"),this._cameraFacing?(a.push("grl_previousAndSide"),a.push("grl_nextAndCounters")):a.push("grl_slopes")}getSamplers(a){a.push("grl_colors")}getActiveTextures(a){this.colorsTexture&&a.push(this.colorsTexture)}getUniforms(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const c=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&c.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===a&&c.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:c,vertex:this._cameraFacing&&this._isGLSL(a)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(a)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(a){if(this._cameraFacing){a.xc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||a.xc("viewProjection",this._scene.getTransformMatrix());const c=s.TmpVectors.Vector4[0];c.x=this._aspect,c.y=this._resolution.x,c.z=this._resolution.y,c.w=this.width,a.updateVector4("grl_aspect_resolution_lineWidth",c)}const c=s.TmpVectors.Vector4[0];c.x=Ra.BooleanToNumber(this.useDash),c.y=this._dashArray,c.z=this.dashOffset,c.w=this.dashRatio,a.updateVector4("grl_dashOptions",c);const o=s.TmpVectors.Vector4[1];o.x=this.colorMode,o.y=this.visibility,o.z=this.colorsTexture?this.colorsTexture.getSize().width:0,o.w=Ra.BooleanToNumber(this.useColors),a.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",o),this._color&&a.updateColor3("grl_singleColor",this._color);const q=this.colorsTexture??Sa.EmptyColorsTexture;a.setTexture("grl_colors",q),a.updateFloat2("grl_textureSize",(null===q||void 0===q?void 0:q.getSize().width)??1,(null===q||void 0===q?void 0:q.getSize().height)??1)}prepareDefines(a,c,o){a.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,a.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,a.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,a.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=c.useRightHandedSystem,a.GREASED_LINE_CAMERA_FACING=this._cameraFacing,a.GREASED_LINE_USE_OFFSETS=!!o.offsets}getClassName(){return Xa.GREASED_LINE_MATERIAL_NAME}getCustomCode(a){let c=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(c)?function(a,c){if("vertex"===a){const a={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return c&&(a["!gl_Position\\=viewProjection\\*worldPos;"]="//"),a}return"fragment"===a?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(a,this._cameraFacing):function(a,c){if("vertex"===a){const a={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return c&&(a["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),a}return"fragment"===a?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(a,this._cameraFacing)}dispose(){var a;null===(a=this.colorsTexture)||void 0===a||a.dispose(),super.dispose()}get ra(){return this._colors}set ra(a){this.setColors(a)}setColors(a){var c;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var t;if(this._colors=a,null!==a&&0!==a.length){if(!o||s)if(this.colorsTexture&&q===a.length&&!s){const c=Ra.Color3toRGBAUint8(a);this.colorsTexture.update(c)}else{var i;null===(i=this.colorsTexture)||void 0===i||i.dispose(),this.colorsTexture=Ra.CreateColorsTexture(`${this._material.name}-colors-texture`,a,this.colorsSampling,this._scene)}}else null===(t=this.colorsTexture)||void 0===t||t.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(a){this._dashCount=a,this._dashArray=1/a}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(a){this._sizeAttenuation=a,this.markAllDefinesAsDirty()}get color(){return this._color}set color(a){this.setColor(a)}setColor(a){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==a||null!==this._color&&null===a?(this._color=a,c||this.markAllDefinesAsDirty()):this._color=a}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(a){this._colorsDistributionType=a,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(a){this._aspect=a.x/a.y,this._resolution=a}serialize(){const a=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(c.ra=this._colors),this._color&&(c.color=this._color),a.greasedLineMaterialOptions=c,a}parse(a,c,o){var s;super.parse(a,c,o);const q=a.greasedLineMaterialOptions;null===(s=this.colorsTexture)||void 0===s||s.dispose(),q.color&&this.setColor(q.color,!0),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.ra&&(this.ra=q.ra),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),this.ra?this.colorsTexture=Ra.CreateColorsTexture(`${this._material.name}-colors-texture`,this.ra,this.colorsSampling,c):Ra.PrepareEmptyColorsTexture(c),this.markAllDefinesAsDirty()}copyTo(a){var c;const o=a;null===(c=o.colorsTexture)||void 0===c||c.dispose(),this._colors&&(o.colorsTexture=Ra.CreateColorsTexture(`${o._material.name}-colors-texture`,this._colors,o.colorsSampling,this._scene)),o.setColor(this.color,!0),o.colorsDistributionType=this.colorsDistributionType,o.colorsSampling=this.colorsSampling,o.colorMode=this.colorMode,o.useColors=this.useColors,o.visibility=this.visibility,o.useDash=this.useDash,o.dashCount=this.dashCount,o.dashRatio=this.dashRatio,o.dashOffset=this.dashOffset,o.width=this.width,o.sizeAttenuation=this.sizeAttenuation,o.resolution=this.resolution,o.markAllDefinesAsDirty()}_isGLSL(a){return 0===a||this._forceGLSL}}Xa.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Xa.ForceGLSL=!1,(0,Ua.d)(`BABYLON.${Xa.GREASED_LINE_MATERIAL_NAME}`,Xa);var Wa=o(13224),Fa=o(12657),Oa=o(13037),Ba=o(12763);class ua extends Oa.ShaderMaterial{constructor(a,c,q){const t=c.getEngine(),i=t.isWebGPU&&!(q.forceGLSL||ua.ForceGLSL),p=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];c.useRightHandedSystem&&p.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const G=["position","grl_widths","grl_offsets","grl_colorPointers"];q.cameraFacing?(p.push("GREASED_LINE_CAMERA_FACING"),G.push("grl_previousAndSide","grl_nextAndCounters")):(G.push("grl_slopes"),G.push("grl_counters"));const T=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(i||T.push("world","viewProjection","view","projection"),super(a,c,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:i?["Scene","Mesh"]:void 0,attributes:G,uniforms:T,samplers:i?[]:["grlColors"],defines:p,extraInitializationsAsync:async()=>{i?await Promise.all([o.e(66).then(o.bind(o,15910)),o.e(75).then(o.bind(o,15916))]):await Promise.all([o.e(69).then(o.bind(o,15925)),o.e(76).then(o.bind(o,15933))])},shaderLanguage:i?1:0}),this._color=N.oo.White(),this._colorsDistributionType=0,this._colorsTexture=null,q=q||{color:Sa.DEFAULT_COLOR},this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.dashCount=q.dashCount??1,this.width=q.width?q.width:q.sizeAttenuation&&q.cameraFacing?Sa.DEFAULT_WIDTH_ATTENUATED:Sa.DEFAULT_WIDTH,this.sizeAttenuation=q.sizeAttenuation??!1,this.color=q.color??N.oo.White(),this.useColors=q.useColors??!1,this.colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??w.b.NEAREST_NEAREST,this.colorMode=q.colorMode??0,this._colors=q.ra??null,this._cameraFacing=q.cameraFacing??!0,this.resolution=q.resolution??new s.Vector2(t.getRenderWidth(),t.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=Ra.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,c):(this._color=this._color??Sa.DEFAULT_COLOR,this.colorsTexture=Ra.PrepareEmptyColorsTexture(c)),i){const a=new Ba.b;a.setParameters(),a.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",a)}t.gc.add((()=>{Ra.DisposeEmptyColorsTexture()}))}dispose(){var a;null===(a=this._colorsTexture)||void 0===a||a.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new s.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get ra(){return this._colors}set ra(a){this.setColors(a)}setColors(a){var c;let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1],s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const q=(null===(c=this._colors)||void 0===c?void 0:c.length)??0;var t;if(this._colors=a,null!==a&&0!==a.length){if(!o||s)if(this._colorsTexture&&q===a.length&&!s){const c=Ra.Color3toRGBAUint8(a);this._colorsTexture.update(c)}else{var i;null===(i=this._colorsTexture)||void 0===i||i.dispose(),this.colorsTexture=Ra.CreateColorsTexture(`${this.name}-colors-texture`,a,this.colorsSampling,this.Za())}}else null===(t=this._colorsTexture)||void 0===t||t.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(a){this._colorsTexture=a,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(a){this._width=a,this.setFloat("grlWidth",a)}get useColors(){return this._useColors}set useColors(a){this._useColors=a,this.setFloat("grlUseColors",Ra.BooleanToNumber(a))}get colorsSampling(){return this._colorsSampling}set colorsSampling(a){this._colorsSampling=a}get visibility(){return this._visibility}set visibility(a){this._visibility=a,this.setFloat("grlVisibility",a)}get useDash(){return this._useDash}set useDash(a){this._useDash=a,this.setFloat("grlUseDash",Ra.BooleanToNumber(a))}get dashOffset(){return this._dashOffset}set dashOffset(a){this._dashOffset=a,this.setFloat("grlDashOffset",a)}get dashRatio(){return this._dashRatio}set dashRatio(a){this._dashRatio=a,this.setFloat("grlDashRatio",a)}get dashCount(){return this._dashCount}set dashCount(a){this._dashCount=a,this._dashArray=1/a,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(a){this._sizeAttenuation=a,this.setFloat("grlSizeAttenuation",Ra.BooleanToNumber(a))}get color(){return this._color}set color(a){this.setColor(a)}setColor(a){a=a??Sa.DEFAULT_COLOR,this._color=a,this.setColor3("grlColor",a)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(a){this._colorsDistributionType=a,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(a){this._colorMode=a,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(a){this._resolution=a,this.setVector2("grlResolution",a),this.setFloat("grlAspect",a.x/a.y)}serialize(){const a=super.serialize(),c={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(c.ra=this._colors),a.greasedLineMaterialOptions=c,a}parse(a,c,o){var s;const q=a.greasedLineMaterialOptions;null===(s=this._colorsTexture)||void 0===s||s.dispose(),q.color&&(this.color=q.color),q.colorDistributionType&&(this.colorsDistributionType=q.colorDistributionType),q.colorsSampling&&(this.colorsSampling=q.colorsSampling),q.colorMode&&(this.colorMode=q.colorMode),q.useColors&&(this.useColors=q.useColors),q.visibility&&(this.visibility=q.visibility),q.useDash&&(this.useDash=q.useDash),q.dashCount&&(this.dashCount=q.dashCount),q.dashRatio&&(this.dashRatio=q.dashRatio),q.dashOffset&&(this.dashOffset=q.dashOffset),q.width&&(this.width=q.width),q.sizeAttenuation&&(this.sizeAttenuation=q.sizeAttenuation),q.resolution&&(this.resolution=q.resolution),q.ra?this.colorsTexture=Ra.CreateColorsTexture(`${this.name}-colors-texture`,q.ra,this.colorsSampling,this.Za()):this.colorsTexture=Ra.PrepareEmptyColorsTexture(c),this._cameraFacing=q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Ka,Da,Ia;ua.ForceGLSL=!1,function(a){a[a.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",a[a.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Ka||(Ka={})),function(a){a[a.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",a[a.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",a[a.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Da||(Da={})),function(a){a[a.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",a[a.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",a[a.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",a[a.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",a[a.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Ia||(Ia={}));class Ya extends ka.c{constructor(a,c,o){super(a,c,null,null,!1,!1),this.name=a,this._options=o,this._lazy=!1,this._updatable=!1,this._engine=c.getEngine(),this._lazy=o.lazy??!1,this._updatable=o.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=o.colorPointers??[],this._widths=o.widths??new Array(o.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(a){let c=0;for(const s of this._points)c+=s.length;const o=c/3*2-this._widths.length;for(let s=0;s<o;s++)this._widths.push(a)}updateLazy(){var a,c;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(a=this._options.ribbonOptions)||void 0===a?void 0:a.smoothShading),!this.Xa&&this.refreshBoundingInfo(),null===(c=this.greasedLineMaterial)||void 0===c||c.updateLazy()}addPoints(a,c){for(const o of a)this._points.push(o);this._lazy||this.setPoints(this._points,c)}dispose(a){let c=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(a,c)}isLazy(){return this._lazy}get xa(){return this._uvs}set xa(a){this._uvs=a instanceof Float32Array?a:new Float32Array(a),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(a){this.material instanceof ua&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===a||void 0===a?void 0:a.length)>0),this._offsets=a,this._offsetsBuffer?this._offsetsBuffer.update(a):this._createOffsetsBuffer(a)}get widths(){return this._widths}set widths(a){this._widths=a,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(a)}get colorPointers(){return this._colorPointers}set colorPointers(a){this._colorPointers=a,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(a)}get greasedLineMaterial(){var a,c;if(this.material&&this.material instanceof ua)return this.material;const o=null===(a=this.material)||void 0===a||null===(c=a.pluginManager)||void 0===c?void 0:c.getPlugin(Xa.GREASED_LINE_MATERIAL_NAME);return o||void 0}get points(){const a=[];return Fa.b.DeepCopy(this._points,a),a}setPoints(a,c){this._points=Ra.ConvertPoints(a,(null===c||void 0===c?void 0:c.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==c&&void 0!==c&&c.colorPointers||this._updateColorPointers(),this._setPoints(this._points,c)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,xa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(a){super.serialize(a),a.type=this.getClassName(),a.lineOptions=this._createLineOptions()}_createVertexBuffers(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const c=new Wa.e;return c.Ua=this._vertexPositions,c.indices=this._indices,c.xa=this._uvs,a&&(c.Sa=[],Wa.e.ComputeNormals(this._vertexPositions,this._indices,c.Sa)),c.da(this,this._options.updatable),c}_createOffsetsBuffer(a){const c=this._scene.getEngine(),o=new C.d(c,a,this._updatable,3);this.setVerticesBuffer(o.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=o}}class Pa{constructor(a,c){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=a,this.wasAddedByNoopNode=c}getIndicesAccessor(a,c,o,s,q){var t,i,p,G;return null===(t=this._indicesAccessorMap.get(a))||void 0===t||null===(i=t.get(c))||void 0===i||null===(p=i.get(o))||void 0===p||null===(G=p.get(s))||void 0===G?void 0:G.get(q)}setIndicesAccessor(a,c,o,s,q,t){let i=this._indicesAccessorMap.get(a);i||(i=new Map,this._indicesAccessorMap.set(a,i));let p=i.get(c);p||(p=new Map,i.set(c,p));let G=p.get(o);G||(G=new Map,p.set(o,G));let T=G.get(s);T||(T=new Map,G.set(s,T)),T.set(q,t)}pushExportedNode(a){this._exportedNodes.has(a)||this._exportedNodes.add(a)}getNodesSet(){return this._exportedNodes}getVertexBufferView(a){return this._vertexBufferViewMap.get(a)}setVertexBufferView(a,c){this._vertexBufferViewMap.set(a,c)}setRemappedBufferView(a,c,o){this._remappedBufferView.set(a,new Map),this._remappedBufferView.get(a).set(c,o)}getRemappedBufferView(a,c){var o;return null===(o=this._remappedBufferView.get(a))||void 0===o?void 0:o.get(c)}getVertexAccessor(a,c,o){var s,q;return null===(s=this._vertexAccessorMap.get(a))||void 0===s||null===(q=s.get(c))||void 0===q?void 0:q.get(o)}setVertexAccessor(a,c,o,s){let q=this._vertexAccessorMap.get(a);q||(q=new Map,this._vertexAccessorMap.set(a,q));let t=q.get(c);t||(t=new Map,q.set(c,t)),t.set(o,s)}hasVertexColorAlpha(a){return this._vertexMapColorAlpha.get(a)||!1}setHasVertexColorAlpha(a,c){return this._vertexMapColorAlpha.set(a,c)}getMesh(a){return this._meshMap.get(a)}setMesh(a,c){this._meshMap.set(a,c)}bindMorphDataToMesh(a,c){const o=this._meshMorphTargetMap.get(a)||[];this._meshMorphTargetMap.set(a,o),-1===o.indexOf(c)&&o.push(c)}getMorphTargetsFromMesh(a){return this._meshMorphTargetMap.get(a)}}class mc{_ApplyExtension(a,c,o,s){if(o>=c.length)return Promise.resolve(a);const q=s(c[o],a);return q?q.then((async a=>a?await this._ApplyExtension(a,c,o+1,s):null)):this._ApplyExtension(a,c,o+1,s)}_ApplyExtensions(a,c){const o=[];for(const s of mc._ExtensionNames)o.push(this._extensions[s]);return this._ApplyExtension(a,o,0,c)}_extensionsPreExportTextureAsync(a,c,o){return this._ApplyExtensions(c,((c,s)=>c.preExportTextureAsync&&c.preExportTextureAsync(a,s,o)))}_extensionsPostExportNodeAsync(a,c,o,s,q){return this._ApplyExtensions(c,((c,t)=>c.postExportNodeAsync&&c.postExportNodeAsync(a,t,o,s,q,this._bufferManager)))}_extensionsPostExportMaterialAsync(a,c,o){return this._ApplyExtensions(c,((c,s)=>c.postExportMaterialAsync&&c.postExportMaterialAsync(a,s,o)))}_extensionsPostExportMaterialAdditionalTextures(a,c,o){const s=[];for(const q of mc._ExtensionNames){const t=this._extensions[q];t.postExportMaterialAdditionalTextures&&s.push(...t.postExportMaterialAdditionalTextures(a,c,o))}return s}_extensionsPostExportTextures(a,c,o){for(const s of mc._ExtensionNames){const q=this._extensions[s];q.postExportTexture&&q.postExportTexture(a,c,o)}}_extensionsPostExportMeshPrimitive(a){for(const c of mc._ExtensionNames){const o=this._extensions[c];o.postExportMeshPrimitive&&o.postExportMeshPrimitive(a,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const a of mc._ExtensionNames){const c=this._extensions[a];c.preGenerateBinaryAsync&&await c.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(a){for(const c of mc._ExtensionNames){const o=this._extensions[c];o.enabled&&a(o)}}_extensionsOnExporting(){this._forEachExtensions((a=>{var c,o,s;a.wasUsed&&((c=this._glTF).extensionsUsed||(c.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(a.name)&&this._glTF.extensionsUsed.push(a.name),a.required&&((o=this._glTF).extensionsRequired||(o.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(a.name)&&this._glTF.extensionsRequired.push(a.name)),(s=this._glTF).extensions||(s.extensions={}),a.onExporting&&a.onExporting())}))}_loadExtensions(){for(const a of mc._ExtensionNames){const c=mc._ExtensionFactories[a](this);this._extensions[a]=c}}constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:M.b.LastCreatedScene,c=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${g.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new B(this),this._extensions={},this._bufferManager=new Ca,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!a)throw new Error("No scene available to export");this._babylonScene=a,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:a=>{var c;return null===a||void 0===a||null===(c=a.nc)||void 0===c?void 0:c.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...c},this._loadExtensions()}dispose(){for(const a in this._extensions){this._extensions[a].dispose()}}get options(){return this._options}static RegisterExtension(a,c){mc.UnregisterExtension(a)&&q.Tools.Warn(`Extension with the name ${a} already exists`),mc._ExtensionFactories[a]=c,mc._ExtensionNames.push(a)}static UnregisterExtension(a){if(!mc._ExtensionFactories[a])return!1;delete mc._ExtensionFactories[a];const c=mc._ExtensionNames.indexOf(a);return-1!==c&&mc._ExtensionNames.splice(c,1),!0}_generateJSON(a,c,o){const s={byteLength:a};return s.byteLength&&(this._glTF.buffers=[s]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ao=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(s.uri=c+".bin"),o?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(a){const c=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(c.byteLength,a,!0),s=new Blob([c],{type:"application/octet-stream"}),q=a+".gltf",t=a+".bin",i=new T;if(i.files[q]=o,i.files[t]=s,this._imageData)for(const p in this._imageData)i.files[p]=new Blob([this._imageData[p].data],{type:this._imageData[p].mimeType});return i}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(a){const c=a%4;return 0===c?c:4-c}async generateGLBAsync(a){this._shouldUseGlb=!0;const c=await this._generateBinaryAsync();this._extensionsOnExporting();const o=this._generateJSON(c.byteLength),s=a+".glb";let q,t=o.length;if("undefined"!==typeof TextEncoder){q=(new TextEncoder).encode(o),t=q.length}const i=this._getPadding(t),p=this._getPadding(c.byteLength),G=28+t+i+c.byteLength+p,C=new Ga(G);if(C.writeUInt32(1179937895),C.writeUInt32(2),C.writeUInt32(G),C.writeUInt32(t+i),C.writeUInt32(1313821514),q)C.writeTypedArray(q);else{const a="_".charCodeAt(0);for(let c=0;c<t;++c){const s=o.charCodeAt(c);s!=o.codePointAt(c)?C.writeUInt8(a):C.writeUInt8(s)}}for(let T=0;T<i;++T)C.writeUInt8(32);C.writeUInt32(c.byteLength+p),C.writeUInt32(5130562),C.writeTypedArray(c);for(let T=0;T<p;++T)C.writeUInt8(0);const j=new T;return j.files[s]=new Blob([C.getOutputData()],{type:"application/octet-stream"}),j}_setNodeTransformation(a,c,o){if(c.getPivotPoint().equalsWithEpsilon(Y,I.b)||q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!c.position.equalsWithEpsilon(Y,I.b)){const q=s.TmpVectors.Hc[0].G(c.position);o&&l(q),a.translation=q.hc()}c.uc.equalsWithEpsilon(ma,I.b)||(a.scale=c.uc.hc());const t=c.rotationQuaternion||s.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);t.equalsWithEpsilon(P,I.b)||(o&&Q(t),a.rotation=t.normalize().hc())}_setCameraTransformation(a,c,o){if(!c.position.equalsWithEpsilon(Y,I.b)){const q=s.TmpVectors.Hc[0].G(c.position);o&&l(q),a.translation=q.hc()}const q=c.rotationQuaternion||s.Quaternion.FromEulerAngles(c.rotation.x,c.rotation.y,c.rotation.z);o&&Q(q),this._babylonScene.useRightHandedSystem||z(q),q.equalsWithEpsilon(P,I.b)||(a.rotation=q.hc())}_listAvailableCameras(){for(const a of this._babylonScene.cameras){const c={type:a.mode===La.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(a.name&&(c.name=a.name),"perspective"===c.type)c.perspective={aspectRatio:a.getEngine().getAspectRatio(a),yfov:a.fovMode===La.b.FOVMODE_VERTICAL_FIXED?a.fov:a.fov*a.getEngine().getAspectRatio(a),znear:a.rc,zfar:a.maxZ};else if("orthographic"===c.type){const o=a.orthoLeft&&a.orthoRight?.5*(a.orthoRight-a.orthoLeft):.5*a.getEngine().getRenderWidth(),s=a.orthoBottom&&a.orthoTop?.5*(a.orthoTop-a.orthoBottom):.5*a.getEngine().getRenderHeight();c.orthographic={xmag:o,ymag:s,znear:a.rc,zfar:a.maxZ}}this._camerasMap.set(a,c)}}_exportAndAssignCameras(){const a=Array.from(this._camerasMap.values());for(const c of a){const a=this._nodesCameraMap.get(c);if(void 0!==a){this._cameras.push(c);for(const c of a)c.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const a of this._babylonScene.skeletons){if(a.bones.length<=0)continue;const c={joints:[]};this._skinMap.set(a,c)}}_exportAndAssignSkeletons(){for(const a of this._babylonScene.skeletons){if(a.bones.length<=0)continue;const c=this._skinMap.get(a);if(void 0==c)continue;const o={},s=[];let t=-1;for(let q=0;q<a.bones.length;++q){const c=a.bones[q],s=c.getIndex()??q;-1!==s&&(o[s]=c,s>t&&(t=s))}for(let a=0;a<=t;++a){const t=o[a];s.push(t.getAbsoluteInverseBindMatrix());const i=t.getTransformNode();if(null!==i){const a=this._nodeMap.get(i);i&&null!==a&&void 0!==a?c.joints.push(a):q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const i=this._nodesSkinMap.get(c);if(c.joints.length>0&&void 0!==i){const a=64*s.length,o=new Float32Array(a/4);s.forEach(((a,c)=>{o.set(a.m,16*c)}));const q=this._bufferManager.createBufferView(o);this._accessors.push(this._bufferManager.createAccessor(q,"MAT4",5126,s.length)),c.inverseBindMatrices=this._accessors.length-1,this._skins.push(c);for(const c of i)c.skin=this._skins.length-1}}}async _exportSceneAsync(){const a={nodes:[]};if(this._babylonScene.metadata){const c=this._options.metadataSelector(this._babylonScene.metadata);c&&(a.extras=c)}const c=new Array,o=new Array,s=new Array;for(const p of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&ia(p,this._babylonScene.useRightHandedSystem)?s.push(...p.getChildren()):this._babylonScene.useRightHandedSystem?c.push(p):o.push(p);this._listAvailableCameras(),this._listAvailableSkeletons();const q=new Pa(!0,!1);a.nodes.push(...await this._exportNodesAsync(o,q));const t=new Pa(!1,!1);a.nodes.push(...await this._exportNodesAsync(c,t));const i=new Pa(!1,!0);a.nodes.push(...await this._exportNodesAsync(s,i)),a.nodes.length&&this._scenes.push(a),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&fa._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(a){let c=this._shouldExportNodeMap.get(a);return void 0===c&&(c=this._options.shouldExportNode(a),this._shouldExportNodeMap.set(a,c)),c}async _exportNodesAsync(a,c){const o=new Array;this._exportBuffers(a,c);for(const s of a)await this._exportNodeAsync(s,o,c);return o}_collectBuffers(a,c,o,s,q){if(this._shouldExportNode(a)&&a instanceof L.e&&a.dc){const t=a.dc.getVertexBuffers();if(t)for(const s in t){if(!b(s))continue;const i=t[s];q.setHasVertexColorAlpha(i,a.hasVertexAlpha);const p=i._buffer,G=c.get(p)||[];c.set(p,G),-1===G.indexOf(i)&&G.push(i);const T=o.get(i)||[];o.set(i,T),-1===T.indexOf(a)&&T.push(a)}const i=a.morphTargetManager;if(i)for(let c=0;c<i.numTargets;c++){const o=i.getTarget(c),q=s.get(o)||[];s.set(o,q),-1===q.indexOf(a)&&q.push(a)}}for(const t of a.getChildren())this._collectBuffers(t,c,o,s,q)}_exportBuffers(a,c){const o=new Map,s=new Map,q=new Map;for(const p of a)this._collectBuffers(p,o,s,q,c);const t=Array.from(o.keys());for(const p of t){const a=p.getData();if(!a)throw new Error("Buffer data is not available");const q=o.get(p);if(!q)continue;const t=q[0].byteStride;if(q.some((a=>a.byteStride!==t)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const i=oa(a).slice();for(const c of q){const a=s.get(c),{byteOffset:o,byteStride:q,componentCount:t,type:p,count:G,normalized:T,kind:j}=E(c,a);switch(j){case C.g.NormalKind:case C.g.TangentKind:(0,u.k)(i,o,q,t,p,G,T,(a=>{const c=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);if(c>0){const o=1/c;a[0]*=o,a[1]*=o,a[2]*=o}}));break;case C.g.ColorKind:{const c=a.filter((a=>a.material instanceof Ma.co||null==a.material)).length;if(0==c)break;if(c!=a.length){K.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}p==C.g.UNSIGNED_BYTE&&K.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const s=new N.oo,j=new N.Yc,L=this._babylonScene.getEngine().useExactSrgbConversions;(0,u.k)(i,o,q,t,p,G,T,(a=>{3===a.length?(s.ts(a,0),s.toLinearSpaceToRef(s,L),s.toArray(a,0)):(j.ts(a,0),j.toLinearSpaceToRef(j,L),j.toArray(a,0))}))}}}if(c.convertToRightHanded){for(const a of q){const c=s.get(a),{byteOffset:o,byteStride:q,componentCount:t,type:p,count:G,normalized:T,kind:j}=E(a,c);switch(j){case C.g.PositionKind:case C.g.NormalKind:case C.g.TangentKind:(0,u.k)(i,o,q,t,p,G,T,(a=>{a[0]=-a[0]}))}}c.convertedToRightHandedBuffers.set(p,i)}const G=this._bufferManager.createBufferView(i,t);c.setVertexBufferView(p,G);const T=new Map;for(const c of q){const a=s.get(c),{kind:o,totalVertices:q}=E(c,a);switch(o){case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:if(c.type==C.g.FLOAT){const a=c.getFloatData(q);null!==a&&T.set(c,a)}}}0!==T.size&&K.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const j=Array.from(T.keys());for(const o of j){const a=T.get(o);if(!a)continue;const s=a.some((a=>a>=256)),q=new(s?Uint16Array:Uint8Array)(a.length);for(let c=0;c<a.length;c++)q[c]=a[c];const t=this._bufferManager.createBufferView(q,4*(s?2:1));c.setRemappedBufferView(p,o,t)}}const i=Array.from(q.keys());for(const p of i){const a=q.get(p);if(!a)continue;const o=Ja(p,a[0],this._bufferManager,this._bufferViews,this._accessors,c.convertToRightHanded);for(const s of a)c.bindMorphDataToMesh(s,o)}}async _exportNodeAsync(a,c,o){let s=this._nodeMap.get(a);if(void 0!==s)return void(c.includes(s)||c.push(s));const q=await this._createNodeAsync(a,o);if(q){s=this._nodes.length,this._nodes.push(q),this._nodeMap.set(a,s),o.pushExportedNode(a),c.push(s);const t={name:"runtime animations",channels:[],samplers:[]},i=[];this._babylonScene.animationGroups.length||(fa._CreateMorphTargetAnimationFromMorphTargetAnimations(a,t,i,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation),a.animations.length&&fa._CreateNodeAnimationFromNodeAnimations(a,t,i,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.convertToRightHanded,this._options.shouldExportAnimation)),t.channels.length&&t.samplers.length&&this._animations.push(t),i.forEach((a=>{a.channels.length&&a.samplers.length&&this._animations.push(a)}))}const t=q?[]:c;for(const i of a.getChildren())await this._exportNodeAsync(i,t,o);q&&t.length&&(q.children=t)}async _createNodeAsync(a,c){if(!this._shouldExportNode(a))return null;const o={};if(a.name&&(o.name=a.name),a.metadata){const c=this._options.metadataSelector(a.metadata);c&&(o.extras=c)}if(a instanceof j.b&&(this._setNodeTransformation(o,a,c.convertToRightHanded),a instanceof L.e)){const q=a instanceof e.d?a.sourceMesh:a;if(q.wc&&q.wc.length>0&&(o.mesh=await this._exportMeshAsync(q,c)),a.skeleton){const c=this._skinMap.get(a.skeleton);var s;if(void 0!==c)void 0===this._nodesSkinMap.get(c)&&this._nodesSkinMap.set(c,[]),null===(s=this._nodesSkinMap.get(c))||void 0===s||s.push(o)}}if(a instanceof D.b){const s=this._camerasMap.get(a);if(s){var q;void 0===this._nodesCameraMap.get(s)&&this._nodesCameraMap.set(s,[]),this._setCameraTransformation(o,a,c.convertToRightHanded);const i=a.parent;if(null!==i&&ca(a,i)){const a=this._nodeMap.get(i);if(void 0!==a){var t;const c=this._nodes[a];return aa(o,c),null===(t=this._nodesCameraMap.get(s))||void 0===t||t.push(c),null}}null===(q=this._nodesCameraMap.get(s))||void 0===q||q.push(o)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",o,a,this._nodeMap,c.convertToRightHanded)?o:(K.c.Warn(`Not exporting node ${a.name}`),null)}_exportIndices(a,c,o,s,q,i,p,G,T){let C=a;T.mode=A(i);const j=p!==t.b.CounterClockWiseSideOrientation,L=!G.wasAddedByNoopNode&&j,e=function(a){switch(a){case t.b.TriangleFillMode:case t.b.TriangleStripDrawMode:case t.b.TriangleFanDrawMode:return!0}return!1}(i)&&L;if(e){if(i===t.b.TriangleStripDrawMode||i===t.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");T.mode=A(i);const p=c?new Uint32Array(s):new Uint16Array(s);if(a)for(let c=0;c+2<s;c+=3)p[c]=a[o+c]+q,p[c+1]=a[o+c+2]+q,p[c+2]=a[o+c+1]+q;else for(let a=0;a+2<s;a+=3)p[a]=a,p[a+1]=a+2,p[a+2]=a+1;C=p}else if(a&&0!==q){const t=c?new Uint32Array(s):new Uint16Array(s);for(let c=0;c<s;c++)t[c]=a[o+c]+q;C=t}if(C){let t=G.getIndicesAccessor(a,o,s,q,e);if(void 0===t){const i=function(a,c,o,s){if(a instanceof Uint16Array||a instanceof Uint32Array)return a;if(a instanceof Int32Array)return new Uint32Array(a.buffer,a.byteOffset,a.length);const q=a.slice(c,c+o);return s?new Uint32Array(q):new Uint16Array(q)}(C,0,s,c),p=this._bufferManager.createBufferView(i),T=c?5125:5123;this._accessors.push(this._bufferManager.createAccessor(p,"SCALAR",T,s,0)),t=this._accessors.length-1,G.setIndicesAccessor(a,o,s,q,e,t)}T.indices=t}}_exportVertexBuffer(a,c,o,s,q,t){const i=a.getKind();if(!b(i))return;if(i.startsWith("uv")&&!this._options.exportUnusedUVs&&(!c||!this._materialNeedsUVsSet.has(c)))return;let p=q.getVertexAccessor(a,o,s);if(void 0===p){const c=q.convertedToRightHandedBuffers.get(a._buffer)||a._buffer.getData(),t=i===C.g.PositionKind?function(a,c,o,s){const{byteOffset:q,byteStride:t,type:i,normalized:p}=c,G=c.getSize(),T=new Array(G).fill(1/0),C=new Array(G).fill(-1/0);return(0,u.k)(a,q+o*t,t,G,i,s*G,p,(a=>{for(let c=0;c<G;c++)T[c]=Math.min(T[c],a[c]),C[c]=Math.max(C[c],a[c])})),{min:T,max:C}}(c,a,o,s):void 0,G=(i===C.g.MatricesIndicesKind||i===C.g.MatricesIndicesExtraKind)&&a.type===C.g.FLOAT,T=G?C.g.UNSIGNED_BYTE:a.type,j=G?void 0:a.normalized,L=G?q.getRemappedBufferView(a._buffer,a):q.getVertexBufferView(a._buffer),e=a.byteOffset+o*a.byteStride;this._accessors.push(this._bufferManager.createAccessor(L,function(a,c){if(a==C.g.ColorKind)return c?"VEC4":"VEC3";switch(a){case C.g.PositionKind:case C.g.NormalKind:return"VEC3";case C.g.TangentKind:case C.g.MatricesIndicesKind:case C.g.MatricesIndicesExtraKind:case C.g.MatricesWeightsKind:case C.g.MatricesWeightsExtraKind:return"VEC4";case C.g.UVKind:case C.g.UV2Kind:case C.g.UV3Kind:case C.g.UV4Kind:case C.g.UV5Kind:case C.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${a}`)}(i,q.hasVertexColorAlpha(a)),T,s,e,t,j)),p=this._accessors.length-1,q.setVertexAccessor(a,o,s,p)}t.attributes[function(a){switch(a){case C.g.PositionKind:return"POSITION";case C.g.NormalKind:return"NORMAL";case C.g.TangentKind:return"TANGENT";case C.g.ColorKind:return"COLOR_0";case C.g.UVKind:return"TEXCOORD_0";case C.g.UV2Kind:return"TEXCOORD_1";case C.g.UV3Kind:return"TEXCOORD_2";case C.g.UV4Kind:return"TEXCOORD_3";case C.g.UV5Kind:return"TEXCOORD_4";case C.g.UV6Kind:return"TEXCOORD_5";case C.g.MatricesIndicesKind:return"JOINTS_0";case C.g.MatricesIndicesExtraKind:return"JOINTS_1";case C.g.MatricesWeightsKind:return"WEIGHTS_0";case C.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${a}`)}(i)]=p}async _exportMaterialAsync(a,c,o,s){let q=this._materialMap.get(a);if(void 0===q){const s=c&&Object.keys(c).some((a=>a.startsWith("uv")));if((a=a instanceof ea.e?a.Vc[o.materialIndex]:a)instanceof ga.b)q=await this._materialExporter.exportPBRMaterialAsync(a,"image/png",s);else{if(!(a instanceof Ma.co))return void K.c.Warn(`Unsupported material '${a.name}' with type ${a.getClassName()}`);q=await this._materialExporter.exportStandardMaterialAsync(a,"image/png",s)}this._materialMap.set(a,q)}s.material=q}async _exportMeshAsync(a,c){var o;let s=c.getMesh(a);if(void 0!==s)return s;const q={primitives:[]};s=this._meshes.length,this._meshes.push(q),c.setMesh(a,s);const i=a.isUnIndexed?null:a.Wc(),p=null===(o=a.dc)||void 0===o?void 0:o.getVertexBuffers(),G=c.getMorphTargetsFromMesh(a),T=a instanceof wa.b,C=a instanceof Ya,j=a.wc;if(p&&j&&j.length>0)for(const g of j){const o={attributes:{}},s=g.Ba()||this._babylonScene.defaultMaterial;if(C){var L,e;const c={name:s.name},q=a,t=N.oo.White(),i=(null===(L=q.material)||void 0===L?void 0:L.alpha)??1,p=(null===(e=q.greasedLineMaterial)||void 0===e?void 0:e.color)??t;(!p.equalsWithEpsilon(t,I.b)||i<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...p.hc(),i]}),this._materials.push(c),o.material=this._materials.length-1}else if(T){const c={name:s.name},q=a;(!q.color.equalsWithEpsilon(N.oo.White(),I.b)||q.alpha<1)&&(c.pbrMetallicRoughness={baseColorFactor:[...q.color.hc(),q.alpha]}),this._materials.push(c),o.material=this._materials.length-1}else await this._exportMaterialAsync(s,p,g,o);const j=T||C?t.b.LineListDrawMode:a.overrideRenderingFillMode??s.fillMode,M=s._getEffectiveOrientation(a);this._exportIndices(i,i?(0,u.c)(i,g.indexCount,g.indexStart,g.verticesStart):g.verticesCount>65535,i?g.indexStart:g.verticesStart,i?g.indexCount:g.verticesCount,-g.verticesStart,j,M,c,o);for(const a of Object.values(p))this._exportVertexBuffer(a,s,g.verticesStart,g.verticesCount,c,o);if(G){o.targets=[];for(const a of G)o.targets.push(a.attributes)}q.primitives.push(o),this._extensionsPostExportMeshPrimitive(o)}if(G){q.weights=[],q.extras||(q.extras={}),q.extras.targetNames=[];for(const a of G)q.weights.push(a.influence),q.extras.targetNames.push(a.name)}return s}}mc._ExtensionNames=new Array,mc._ExtensionFactories={};class Va{static async GLTFAsync(a,c,o){o&&o.exportWithoutWaitingForScene||await a.whenReadyAsync();const s=new mc(a,o),q=await s.generateGLTFAsync(c.replace(/\.[^/.]+$/,""));return s.dispose(),q}static async GLBAsync(a,c,o){o&&o.exportWithoutWaitingForScene||await a.whenReadyAsync();const s=new mc(a,o),q=await s.generateGLBAsync(c.replace(/\.[^/.]+$/,""));return s.dispose(),q}}o(13363);const Ea="EXT_mesh_gpu_instancing";class Ha{constructor(a){this.name=Ea,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(a,c,o,q,t,i){return await new Promise((a=>{if(c&&o instanceof ka.c&&o.hasThinInstances&&this._exporter){this._wasUsed=!0;const a=s.Hc.Zero(),q=s.Quaternion.Identity(),p=s.Hc.One(),G=o.thinInstanceGetWorldMatrices(),T=s.TmpVectors.Hc[2],C=s.TmpVectors.Quaternion[1],j=s.TmpVectors.Hc[3];let L=!1,e=!1,g=!1;const M=new Float32Array(3*o.Ec),N=new Float32Array(4*o.Ec),y=new Float32Array(3*o.Ec);let k=0;for(const c of G)c.decompose(j,C,T),t&&(l(T),Q(C)),M.set(T.hc(),3*k),N.set(C.normalize().hc(),4*k),y.set(j.hc(),3*k),L=L||!T.equalsWithEpsilon(a),e=e||!C.equalsWithEpsilon(q),g=g||!j.equalsWithEpsilon(p),k++;const n={attributes:{}};L&&(n.attributes.TRANSLATION=this._buildAccessor(M,"VEC3",o.Ec,i)),e&&(n.attributes.ROTATION=this._buildAccessor(N,"VEC4",o.Ec,i)),g&&(n.attributes.SCALE=this._buildAccessor(y,"VEC3",o.Ec,i)),c.extensions=c.extensions||{},c.extensions[Ea]=n}a(c)}))}_buildAccessor(a,c,o,s){const q=s.createBufferView(a),t=s.createAccessor(q,c,5126,o);return this._exporter._accessors.push(t),this._exporter._accessors.length-1}}mc.RegisterExtension(Ea,(a=>new Ha(a)));var ba=o(13368),Aa=o(13378),va=o(13386),la=o(13389);function Qa(a){return a===va.b.PositionKind?"POSITION":a===va.b.NormalKind?"NORMAL":a===va.b.ColorKind?"COLOR":a.startsWith(va.b.UVKind)?"TEX_COORD":"GENERIC"}const za={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class ac extends ba.d{static get DefaultAvailable(){return(0,ba.f)(ac.DefaultConfiguration)}static get Default(){return ac._Default??(ac._Default=new ac),ac._Default}static ResetDefault(a){ac._Default&&(a||ac._Default.dispose(),ac._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(a,c){return{module:await(c||DracoEncoderModule)({wasmBinary:a})}}_getWorkerContent(){return`${Aa.i}(${Aa.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:ac.DefaultConfiguration)}async _encodeAsync(a,c,o){const s=o?(0,la.e)(za,o):za;if(this._workerPoolPromise){const o=await this._workerPoolPromise;return await new Promise(((q,t)=>{o.push(((o,i)=>{const p=a=>{o.removeEventListener("error",p),o.removeEventListener("message",G),t(a),i()},G=a=>{"encodeMeshDone"===a.data.id&&(o.removeEventListener("error",p),o.removeEventListener("message",G),q(a.data.encodedMeshData),i())};o.addEventListener("error",p),o.addEventListener("message",G);const T=[];for(const c of a)T.push(c.data.buffer);c&&T.push(c.buffer),o.postMessage({id:"encodeMesh",attributes:a,indices:c,options:s},T)}))}))}if(this._modulePromise){const o=await this._modulePromise;return(0,Aa.i)(o.module,a,c,s)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(a,c){if(0==a.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");a instanceof ka.c&&a.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===c||void 0===c?void 0:c.method)&&(K.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),c.method="MESH_SEQUENTIAL_ENCODING");const o=function(a){let c=a.Wc(void 0,!0);return!c||c instanceof Uint32Array||c instanceof Uint16Array||(c=((0,u.c)(c,c.length)?Uint32Array:Uint16Array).from(c)),c}(a),s=function(a,c){const o=[];for(const s of a.getVerticesDataKinds()){if(null!==c&&void 0!==c&&c.includes(s)){if(s===va.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const q=a.getVertexBuffer(s),t=q.getSize(),i=(0,u.x)(q.getData(),t,q.type,q.byteOffset,q.byteStride,q.normalized,a.getTotalVertices(),!0);o.push({kind:s,dracoName:Qa(s),size:t,data:i})}return o}(a,null===c||void 0===c?void 0:c.excludedAttributes);return await this._encodeAsync(s,o,c)}}ac.DefaultConfiguration={wasmUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${q.Tools._DefaultCdnUrl}/draco_encoder.js`},ac._Default=null;const cc="KHR_draco_mesh_compression";class oc{get wasUsed(){return this._wasUsed}constructor(a){this.name=cc,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===a.options.meshCompressionMethod&&ac.DefaultAvailable}dispose(){}postExportMeshPrimitive(a,c,o){if(!this.enabled)return;if(4!==a.mode&&5!==a.mode)return void K.c.Warn("Cannot compress primitive with mode "+a.mode+".");const s=[],q=[];let t=null;if(void 0!==a.indices){const i=o[a.indices],p=c.getBufferView(i);t=c.getData(p).slice(),s.push(p),q.push(i)}const i=[];for(const[C,j]of Object.entries(a.attributes)){const a=o[j],t=c.getBufferView(a),G=H(a.type),T=(0,u.x)(c.getData(t),G,a.componentType,a.byteOffset||0,t.byteStride||(0,u.q)(a.componentType)*G,a.normalized||!1,a.count,!0);i.push({kind:C,dracoName:(p=C,"POSITION"===p?"POSITION":"NORMAL"===p?"NORMAL":p.startsWith("COLOR")?"COLOR":p.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:H(a.type),data:T}),s.push(t),q.push(a)}var p;const G={method:a.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},T=ac.Default._encodeAsync(i,t,G).then((o=>{if(!o)return void K.c.Error("Draco encoding failed for primitive.");const t={bufferView:-1,attributes:o.attributeIds},i=c.createBufferView(o.data);c.setBufferView(t,i);for(const a of s)this._bufferViewsUsed.add(a);for(const a of q)this._accessorsUsed.add(a);a.extensions||(a.extensions={}),a.extensions[cc]=t})).catch((a=>{K.c.Error("Draco encoding failed for primitive: "+a)}));this._encodePromises.push(T),this._wasUsed=!0}async preGenerateBinaryAsync(a){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((c=>{a.getPropertiesWithBufferView(c).every((a=>this._accessorsUsed.has(a)))&&a.removeBufferView(c)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}mc.RegisterExtension(cc,(a=>new oc(a)));var sc=o(13392);const qc="KHR_lights_punctual",tc={name:"",color:[1,1,1],bc:1,range:Number.MAX_VALUE},ic={innerConeAngle:0,outerConeAngle:Math.PI/4},pc=s.Hc.Backward();class Gc{constructor(a){this.name=qc,this.enabled=!0,this.required=!1,this._exporter=a}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[qc]=this._lights}async postExportNodeAsync(a,c,o,q,t){return await new Promise((i=>{if(!(o instanceof na.e))return void i(c);const p=o.getTypeID()==na.e.LIGHTTYPEID_POINTLIGHT?"point":o.getTypeID()==na.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":o.getTypeID()==na.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!p||!(o instanceof sc.b))return K.c.Warn(`${a}: Light ${o.name} is not supported in ${qc}`),void i(c);if(o.falloffType!==na.e.FALLOFF_GLTF&&K.c.Warn(`${a}: Light falloff for ${o.name} does not match the ${qc} specification!`),!o.position.equalsToFloats(0,0,0)){const a=s.TmpVectors.Hc[0].G(o.position);t&&l(a),c.translation=a.hc()}if("point"!==p){const a=o.direction.normalizeToRef(s.TmpVectors.Hc[0]);t&&l(a);const q=s.Quaternion.FromUnitVectorsToRef(pc,a,s.TmpVectors.Quaternion[0]);s.Quaternion.IsIdentity(q)||(c.rotation=q.hc())}const G={type:p,name:o.name,color:o.Ac.hc(),bc:o.bc,range:o.range};if(sa(G,tc),"spot"===p){const a=o;G.spot={innerConeAngle:a.innerAngle/2,outerConeAngle:a.angle/2},sa(G.spot,ic)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(G);const T={Cc:this._lights.lights.length-1},C=o.parent;if(C&&ca(o,C)){const a=q.get(C);if(a){const o=this._exporter._nodes[a];return aa(c,o),o.extensions||(o.extensions={}),o.extensions[qc]=T,void i(null)}}c.extensions||(c.extensions={}),c.extensions[qc]=T,i(c)}))}}mc.RegisterExtension(qc,(a=>new Gc(a)));var Tc=o(13298);const Cc="KHR_materials_anisotropy";class jc{constructor(a){this.name=Cc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof Tc.e&&o.anisotropy.isEnabled&&!o.anisotropy.legacy?(o.anisotropy.texture&&s.push(o.anisotropy.texture),s):[]}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof Tc.e){if(!o.anisotropy.isEnabled||o.anisotropy.legacy)return void a(c);this._wasUsed=!0,c.extensions=c.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(o.anisotropy.texture),q={anisotropyStrength:o.anisotropy.bc,anisotropyRotation:o.anisotropy.angle,anisotropyTexture:s??void 0};null!==q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(o),c.extensions[Cc]=q}a(c)}))}}mc.RegisterExtension(Cc,(a=>new jc(a)));const Lc="KHR_materials_clearcoat";class ec{constructor(a){this.name=Lc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof Tc.e&&o.clearCoat.isEnabled?(o.clearCoat.texture&&s.push(o.clearCoat.texture),!o.clearCoat.useRoughnessFromMainTexture&&o.clearCoat.textureRoughness&&s.push(o.clearCoat.textureRoughness),o.clearCoat.bumpTexture&&s.push(o.clearCoat.bumpTexture),s):[]}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof Tc.e){if(!o.clearCoat.isEnabled)return void a(c);this._wasUsed=!0,c.extensions=c.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture);let t;t=o.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(o.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(o.clearCoat.textureRoughness),o.clearCoat.isTintEnabled&&q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${o.name}`),o.clearCoat.remapF0OnInterfaceChange&&q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${o.name}`);const i=this._exporter._materialExporter.getTextureInfo(o.clearCoat.bumpTexture),p={clearcoatFactor:o.clearCoat.bc,clearcoatTexture:s??void 0,clearcoatRoughnessFactor:o.clearCoat.roughness,clearcoatRoughnessTexture:t??void 0,clearcoatNormalTexture:i??void 0};null===p.clearcoatTexture&&null===p.clearcoatRoughnessTexture&&null===p.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),c.extensions[Lc]=p}a(c)}))}}mc.RegisterExtension(Lc,(a=>new ec(a)));const gc="KHR_materials_diffuse_transmission";function Mc(a,c){const o=c.subSurface;let s=null;return o.translucencyIntensityTexture?s=o.translucencyIntensityTexture:o.thicknessTexture&&o.useMaskFromThicknessTexture&&(s=o.thicknessTexture),s&&!o.useGltfStyleTextures?(K.c.Warn(`${a}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${c.name}`,1),null):s}class Nc{constructor(a){this.name=gc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];if(o instanceof ga.b&&this._isExtensionEnabled(o)){const c=Mc(a,o);return c&&s.push(c),o.subSurface.translucencyColorTexture&&s.push(o.subSurface.translucencyColorTexture),s}return s}_isExtensionEnabled(a){if(a.unlit)return!1;const c=a.subSurface;return!!c.isTranslucencyEnabled&&(!a.unlit&&!c.useAlbedoToTintTranslucency&&c.useGltfStyleTextures&&1===c.volumeIndexOfRefraction&&0===c.minimumThickness&&0===c.maximumThickness)}postExportMaterialAsync(a,c,o){return new Promise((s=>{if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const s=o.subSurface,q=Mc(a,o),t=0==s.translucencyIntensity?void 0:s.translucencyIntensity,i=this._exporter._materialExporter.getTextureInfo(q)??void 0,p=!s.translucencyColor||s.translucencyColor.equalsFloats(1,1,1)?void 0:s.translucencyColor.hc(),G=this._exporter._materialExporter.getTextureInfo(s.translucencyColorTexture)??void 0,T={diffuseTransmissionFactor:t,diffuseTransmissionTexture:i,diffuseTransmissionColorFactor:p,diffuseTransmissionColorTexture:G};(i||G)&&this._exporter._materialNeedsUVsSet.add(o),c.extensions=c.extensions||{},c.extensions[gc]=T}s(c)}))}}mc.RegisterExtension(gc,(a=>new Nc(a)));const yc="KHR_materials_dispersion";class kc{constructor(){this.name=yc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(a){if(a.unlit)return!1;const c=a.subSurface;return!(!c.isRefractionEnabled&&!c.isDispersionEnabled)}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const a={dispersion:o.subSurface.dispersion};c.extensions=c.extensions||{},c.extensions[yc]=a}a(c)}))}}mc.RegisterExtension(yc,(()=>new kc));const nc="KHR_materials_emissive_strength";class fc{constructor(){this.name=nc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(a,c,o){return await new Promise((a=>{if(!(o instanceof ga.b))return a(c);const s=o.emissiveColor.hc(),q=Math.max(...s);if(q>1){this._wasUsed=!0,c.extensions||(c.extensions={});const a={emissiveStrength:q},s=o.emissiveColor.scale(1/a.emissiveStrength);c.emissiveFactor=s.hc(),c.extensions[nc]=a}return a(c)}))}}mc.RegisterExtension(nc,(a=>new fc));const Jc="KHR_materials_ior";class wc{constructor(){this.name=Jc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(a){return!a.unlit&&(void 0!=a.indexOfRefraction&&1.5!=a.indexOfRefraction)}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const a={ior:o.indexOfRefraction};c.extensions=c.extensions||{},c.extensions[Jc]=a}a(c)}))}}mc.RegisterExtension(Jc,(a=>new wc));const Zc="KHR_materials_iridescence";class hc{constructor(a){this.name=Zc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof Tc.e&&o.iridescence.isEnabled?(o.iridescence.texture&&s.push(o.iridescence.texture),o.iridescence.thicknessTexture&&o.iridescence.thicknessTexture!==o.iridescence.texture&&s.push(o.iridescence.thicknessTexture),s):[]}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof Tc.e){if(!o.iridescence.isEnabled)return void a(c);this._wasUsed=!0,c.extensions=c.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(o.iridescence.texture),q=this._exporter._materialExporter.getTextureInfo(o.iridescence.thicknessTexture),t={iridescenceFactor:o.iridescence.bc,iridescenceIor:o.iridescence.indexOfRefraction,iridescenceThicknessMinimum:o.iridescence.minimumThickness,iridescenceThicknessMaximum:o.iridescence.maximumThickness,iridescenceTexture:s??void 0,iridescenceThicknessTexture:q??void 0};null===t.iridescenceTexture&&null===t.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(o),c.extensions[Zc]=t}a(c)}))}}mc.RegisterExtension(Zc,(a=>new hc(a)));const Uc="KHR_materials_sheen";class Sc{constructor(a){this.name=Uc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){return o instanceof ga.b&&o.sheen.isEnabled&&o.sheen.texture?[o.sheen.texture]:[]}async postExportMaterialAsync(a,c,o){return await new Promise((a=>{if(o instanceof ga.b){if(!o.sheen.isEnabled)return void a(c);this._wasUsed=!0,null==c.extensions&&(c.extensions={});const s={sheenColorFactor:o.sheen.color.hc(),sheenRoughnessFactor:o.sheen.roughness??0};null===s.sheenColorTexture&&null===s.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(o),o.sheen.texture&&(s.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),o.sheen.textureRoughness&&!o.sheen.useRoughnessFromMainTexture?s.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.textureRoughness)??void 0:o.sheen.texture&&o.sheen.useRoughnessFromMainTexture&&(s.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(o.sheen.texture)??void 0),c.extensions[Uc]=s}a(c)}))}}mc.RegisterExtension(Uc,(a=>new Sc(a)));const rc="KHR_materials_specular";class xc{constructor(a){this.name=rc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof ga.b&&this._isExtensionEnabled(o)?(o.metallicReflectanceTexture&&s.push(o.metallicReflectanceTexture),o.reflectanceTexture&&s.push(o.reflectanceTexture),s):s}_isExtensionEnabled(a){return!a.unlit&&(void 0!=a.metallicF0Factor&&1!=a.metallicF0Factor||void 0!=a.metallicReflectanceColor&&!a.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(a))}_hasTexturesExtension(a){return null!=a.metallicReflectanceTexture||null!=a.reflectanceTexture}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0,c.extensions=c.extensions||{};const a=this._exporter._materialExporter.getTextureInfo(o.metallicReflectanceTexture)??void 0,s=this._exporter._materialExporter.getTextureInfo(o.reflectanceTexture)??void 0,q={specularFactor:1==o.metallicF0Factor?void 0:o.metallicF0Factor,specularTexture:a,specularColorFactor:o.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:o.metallicReflectanceColor.hc(),specularColorTexture:s};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),c.extensions[rc]=q}a(c)}))}}mc.RegisterExtension(rc,(a=>new xc(a)));const Rc="KHR_materials_transmission";class dc{constructor(a){this.name=Rc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof ga.b&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&s.push(o.subSurface.thicknessTexture),s):s}_isExtensionEnabled(a){if(a.unlit)return!1;const c=a.subSurface;return c.isRefractionEnabled&&void 0!=c.refractionIntensity&&0!=c.refractionIntensity||this._hasTexturesExtension(a)}_hasTexturesExtension(a){return null!=a.subSurface.refractionIntensityTexture}async postExportMaterialAsync(a,c,o){if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const s=o.subSurface,q={transmissionFactor:0===s.refractionIntensity?void 0:s.refractionIntensity};if(this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),s.refractionIntensityTexture)if(s.useGltfStyleTextures){const a=await this._exporter._materialExporter.exportTextureAsync(s.refractionIntensityTexture,"image/png");a&&(q.transmissionTexture=a)}else K.c.Warn(`${a}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);c.extensions||(c.extensions={}),c.extensions[Rc]=q}return c}}mc.RegisterExtension(Rc,(a=>new dc(a)));const Xc="KHR_materials_unlit";class Wc{constructor(){this.name=Xc,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(a,c,o){return new Promise((a=>{let s=!1;o instanceof ga.b?s=o.unlit:o instanceof Ma.co&&(s=o.so),s&&(this._wasUsed=!0,null==c.extensions&&(c.extensions={}),c.extensions[Xc]={}),a(c)}))}}mc.RegisterExtension(Xc,(()=>new Wc));const Fc="KHR_materials_volume";class Oc{constructor(a){this.name=Fc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof ga.b&&this._isExtensionEnabled(o)?(o.subSurface.thicknessTexture&&s.push(o.subSurface.thicknessTexture),s):s}_isExtensionEnabled(a){if(a.unlit)return!1;const c=a.subSurface;return!(!c.isRefractionEnabled&&!c.isTranslucencyEnabled)&&(void 0!=c.maximumThickness&&0!=c.maximumThickness||void 0!=c.tintColorAtDistance&&c.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=c.tintColor&&c.tintColor!=N.oo.White()||this._hasTexturesExtension(a))}_hasTexturesExtension(a){return null!=a.subSurface.thicknessTexture}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof ga.b&&this._isExtensionEnabled(o)){this._wasUsed=!0;const a=o.subSurface,s={thicknessFactor:0==a.maximumThickness?void 0:a.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(a.thicknessTexture)??void 0,attenuationDistance:a.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:a.tintColorAtDistance,attenuationColor:a.tintColor.equalsFloats(1,1,1)?void 0:a.tintColor.hc()};this._hasTexturesExtension(o)&&this._exporter._materialNeedsUVsSet.add(o),c.extensions=c.extensions||{},c.extensions[Fc]=s}a(c)}))}}mc.RegisterExtension(Fc,(a=>new Oc(a)));const Bc="EXT_materials_diffuse_roughness";class uc{constructor(a){this.name=Bc,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,c,o){const s=[];return o instanceof Tc.e&&o._baseDiffuseRoughness?(o._baseDiffuseRoughnessTexture&&s.push(o._baseDiffuseRoughnessTexture),s):[]}postExportMaterialAsync(a,c,o){return new Promise((a=>{if(o instanceof Tc.e){if(!o._baseDiffuseRoughness)return void a(c);this._wasUsed=!0,c.extensions=c.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(o._baseDiffuseRoughnessTexture),q={diffuseRoughnessFactor:o._baseDiffuseRoughness,diffuseRoughnessTexture:s??void 0};null!==q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(o),c.extensions[Bc]=q}a(c)}))}}mc.RegisterExtension(Bc,(a=>new uc(a)));const Kc="KHR_texture_transform";class Dc{constructor(){this.name=Kc,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(a,c,o){if(o.Za()||q.Tools.Warn(`${a}: /*@__KEY__*/"scene" is not defined for Babylon texture ${o.name}!`),(0!==o.uAng||0!==o.vAng)&&(q.Tools.Warn(`${a}: Texture ${o.name} with rotation in the u or v axis is not supported in glTF.`),0!==o.uRotationCenter||0!==o.vRotationCenter))return;const s={};let t=!1;if(0===o.uOffset&&0===o.vOffset||(s.offset=[o.uOffset,o.vOffset],t=!0),1===o.uScale&&1===o.vScale||(s.scale=[o.uScale,o.vScale],t=!0),0!==o.wAng){if(0!==o.uRotationCenter||0!==o.vRotationCenter){if(o.homogeneousRotationInUVTransform&&o.uScale!==o.vScale)return void q.Tools.Warn(`${a}: Texture ${o.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Kc}.`);q.Tools.Warn(`${a}: Texture ${o.name} with non-origin rotation center will be exported using an adjusted offset with ${Kc}.`),s.offset=function(a){const{uOffset:c,vOffset:o,uRotationCenter:s,vRotationCenter:q,uScale:t,vScale:i,wAng:p}=a,G=Math.cos(p),T=Math.sin(p),C=s*t,j=q*i;return[c+(C*(1-G)+j*T),o+(j*(1-G)-C*T)]}(o)}s.rotation=-o.wAng,t=!0}0!==o.coordinatesIndex&&(s.texCoord=o.coordinatesIndex,t=!0),t&&(this._wasUsed=!0,c.extensions||(c.extensions={}),c.extensions[Kc]=s)}}mc.RegisterExtension(Kc,(()=>new Dc));class Ic{static CreateSTL(a){let c=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],t=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],p=arguments.length>6&&void 0!==arguments[6]&&arguments[6],G=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const T=function(a,c,o){const q=[3*a[o],3*a[o+1],3*a[o+2]],t=[new s.Hc(c[q[0]],c[q[0]+2],c[q[0]+1]),new s.Hc(c[q[1]],c[q[1]+2],c[q[1]+1]),new s.Hc(c[q[2]],c[q[2]+2],c[q[2]+1])],i=t[0].vc(t[1]),p=t[2].vc(t[1]);return{v:t,n:s.Hc.Cross(p,i).normalize()}},j=function(a,c,o,s){return c=L(a,c,o.x,s),c=L(a,c,o.y,s),L(a,c,o.z,s)},L=function(a,c,o,s){return a.setFloat32(c,o,s),c+4},g=function(a){if(p){let c=a;a instanceof e.d&&(c=a.sourceMesh);const o=c.getVerticesData(C.g.PositionKind,!0,!0);if(!o)return[];const q=s.Hc.Zero();let t;for(t=0;t<o.length;t+=3)s.Hc.TransformCoordinatesFromFloatsToRef(o[t],o[t+1],o[t+2],a.Rc(!0),q).toArray(o,t);return o}return a.getVerticesData(C.g.PositionKind)||[]};p&&(i=!0);let M="",N=0,y=0;if(q){for(let o=0;o<a.length;o++){const c=a[o].Wc();N+=c?c.length/3:0}const c=new ArrayBuffer(84+50*N);M=new DataView(c),y+=80,M.setUint32(y,N,t),y+=4}else G||(M="solid stlmesh\r\n");for(let s=0;s<a.length;s++){const c=a[s];!q&&G&&(M+="solid "+c.name+"\r\n"),!i&&c instanceof ka.c&&c.bakeCurrentTransformIntoVertices();const o=g(c),p=c.Wc()||[];for(let a=0;a<p.length;a+=3){const c=T(p,o,a);q?(y=j(M,y,c.n,t),y=j(M,y,c.v[0],t),y=j(M,y,c.v[1],t),y=j(M,y,c.v[2],t),y+=2):(M+="\tfacet normal "+c.n.x+" "+c.n.y+" "+c.n.z+"\r\n",M+="\t\touter loop\r\n",M+="\t\t\tvertex "+c.v[0].x+" "+c.v[0].y+" "+c.v[0].z+"\r\n",M+="\t\t\tvertex "+c.v[1].x+" "+c.v[1].y+" "+c.v[1].z+"\r\n",M+="\t\t\tvertex "+c.v[2].x+" "+c.v[2].y+" "+c.v[2].z+"\r\n",M+="\t\tendloop\r\n",M+="\tendfacet\r\n")}!q&&G&&(M+="endsolid "+name+"\r\n")}if(q||G||(M+="endsolid stlmesh"),c){const a=document.createElement("a"),c=new Blob([M],{type:"application/octet-stream"});a.href=window.URL.createObjectURL(c),a.download=o+".stl",a.click()}return M}}function Yc(a,c){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const s=[];for(let q=0;q<a.length/o;q++){const t=a[q*o],i=a[q*o+1],p=a[q*o+2];s.push(`(${t.toPrecision(c.precision)}, ${i.toPrecision(c.precision)}, ${p.toPrecision(c.precision)})`)}return s.join(", ")}function Pc(a,c){const o=[];for(let s=0;s<a.length/2;s++){const q=a[2*s],t=a[2*s+1];o.push(`(${q.toPrecision(c.precision)}, ${(1-t).toPrecision(c.precision)})`)}return o.join(", ")}function mo(a,c){const o=a.getVerticesData(C.g.PositionKind),s=a.getVerticesData(C.g.NormalKind);if(o&&s)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(a){var c;const o=null!==(c=a.Wc())&&void 0!==c&&c.length?a.getTotalIndices():a.getTotalVertices();return Array(o/3).fill(3).join(", ")}(a)}]\n\t\tint[] faceVertexIndices = [${function(a){const c=a.Wc(),o=[];if(null!==c)for(let s=0;s<c.length;s++)o.push(c[s]);else{const c=a.getTotalVertices();for(let a=0;a<c;a++)o.push(a)}return o.join(", ")}(a)}]\n\t\tnormal3f[] normals = [${Yc(s,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Yc(o,c)}]\n        ${function(a,c){let o="";for(let q=0;q<4;q++){const s=q>0?q:"",t=a.getVerticesData(C.g.UVKind+(s?s+1:""));t&&(o+=`\n\t\ttexCoord2f[] primvars:st${s} = [${Pc(t,c)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const s=a.getVerticesData(C.g.ColorKind);return s&&(o+=`\n\tcolor3f[] primvars:displayColor = [${Yc(s,c,s.length/a.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),o}(a,c)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Vc(a,c){return`\n        def "Geometry"\n        {\n        ${mo(a,c)}\n        }\n        `}function Ec(a){let c='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return c+=a,fflate.strToU8(c)}function Hc(a){const c=a.m;return`( ${bc(c,0)}, ${bc(c,4)}, ${bc(c,8)}, ${bc(c,12)} )`}function bc(a,c){return`(${a[c+0]}, ${a[c+1]}, ${a[c+2]}, ${a[c+3]})`}function Ac(a){const c="Object_"+a.uniqueId,o=function(a){const c=a.getWorldMatrix().clone(),o=a.Za().useRightHandedSystem;if(!o){let s=a.parent;for(;s;){if(ia(s,o)){c.multiplyToRef(s.getWorldMatrix().invert(),c);break}s=s.parent}}return c.determinant()<0&&q.Tools.Warn(`Exporting mesh ${a.name} with negative scale. Result may look incorrect in destination engine.`),c}(a),s=Hc(o);return`def Xform "${c}" (\n\tprepend references = @./geometries/Geometry_${a.dc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${s}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${a.material.uniqueId}>\n}\n\n`}function vc(a){switch(a){case Z.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case Z.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case Z.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function lc(a){return`(${a.x}, ${a.y})`}function Qc(a){return`(${a.r}, ${a.g}, ${a.b})`}function zc(a,c,o,q,t,i){const p=a.getInternalTexture().uniqueId+"_"+a.invertY;t[p]=a;const G=a.coordinatesIndex>0?"st"+a.coordinatesIndex:"st",T=new s.Vector2(a.uScale,a.vScale),C=new s.Vector2(a.uOffset,a.vOffset),j=a.wAng,L=Math.sin(j),e=Math.cos(j);return C.y=1-C.y-T.y,C.x+=L*T.x,C.y+=(1-e)*T.y,`\n    def Shader "PrimvarReader_${o}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${G}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${o}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${c.uniqueId}/PrimvarReader_${o}.outputs:result>\n        float inputs:rotation = ${(j*(180/Math.PI)).toFixed(i.precision)}\n        float2 inputs:scale = ${lc(T)}\n        float2 inputs:translation = ${lc(C)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${a.uniqueId}_${o}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${p}.png@\n        float2 inputs:st.connect = </Materials/Material_${c.uniqueId}/Transform2d_${o}.outputs:result>\n        ${q?"float4 inputs:scale = "+function(a){return`(${a.r}, ${a.g}, ${a.b}, 1.0)`}(q):""}\n        token inputs:sourceColorSpace = "${a.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${vc(a.wrapU)}"\n        token inputs:wrapT = "${vc(a.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${c.needAlphaBlending()?"float outputs:a":""}\n    }`}function ao(a,c,o){const s="\t\t\t",q=[],t=[],{diffuseMap:i,Ac:p,alphaCutOff:G,emissiveMap:T,emissive:C,normalMap:j,roughnessMap:L,roughnessChannel:e,roughness:g,metalnessMap:M,metalnessChannel:y,metalness:k,aoMap:n,aoMapChannel:f,aoMapIntensity:J,alphaMap:w,ior:Z,clearCoatEnabled:h,clearCoat:U,clearCoatMap:S,clearCoatRoughness:r,clearCoatRoughnessMap:x}=function(a){const c={diffuseMap:null,Ac:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return a instanceof Ma.co?{...c,diffuseMap:a.diffuseTexture,Ac:a.diffuseColor,alphaCutOff:a.alphaCutOff,emissiveMap:a.emissiveTexture,emissive:a.emissiveColor,roughness:1,alphaMap:a.opacityTexture}:a instanceof Tc.e?{...c,diffuseMap:a._albedoTexture,Ac:a._albedoColor,alphaCutOff:a._alphaCutOff,emissiveMap:a._emissiveTexture,emissive:a._emissiveColor,normalMap:a._bumpTexture,roughnessMap:a._metallicTexture,roughnessChannel:a._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:a._roughness??1,metalnessMap:a._metallicTexture,metalnessChannel:a._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:a._metallic??0,aoMap:a._ambientTexture,aoMapChannel:a._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:a._ambientTextureStrength,alphaMap:a._opacityTexture,ior:a.subSurface.indexOfRefraction,clearCoatEnabled:a.clearCoat.isEnabled,clearCoat:a.clearCoat.bc,clearCoatMap:a.clearCoat.texture,clearCoatRoughness:a.clearCoat.roughness,clearCoatRoughnessMap:a.clearCoat.useRoughnessFromMainTexture?a.clearCoat.texture:a.clearCoat.textureRoughness}:c}(a);return null!==i?(q.push(`${s}color3f inputs:diffuseColor.connect = </Materials/Material_${a.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:rgb>`),a.needAlphaBlending()?q.push(`${s}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:a>`):a.needAlphaTesting()&&(q.push(`${s}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:a>`),q.push(`${s}float inputs:opacityThreshold = ${G}`)),t.push(zc(i,a,"diffuse",p,c,o))):q.push(`${s}color3f inputs:diffuseColor = ${Qc(p||N.oo.White())}`),null!==T?(q.push(`${s}color3f inputs:emissiveColor.connect = </Materials/Material_${a.uniqueId}/Texture_${T.uniqueId}_emissive.outputs:rgb>`),t.push(zc(T,a,"emissive",C,c,o))):C&&C.toLuminance()>0&&q.push(`${s}color3f inputs:emissiveColor = ${Qc(C)}`),null!==j&&(q.push(`${s}normal3f inputs:normal.connect = </Materials/Material_${a.uniqueId}/Texture_${j.uniqueId}_normal.outputs:rgb>`),t.push(zc(j,a,"normal",null,c,o))),null!==n&&(q.push(`${s}float inputs:occlusion.connect = </Materials/Material_${a.uniqueId}/Texture_${n.uniqueId}_occlusion.outputs:${f}>`),t.push(zc(n,a,"occlusion",new N.oo(J,J,J),c,o))),null!==L?(q.push(`${s}float inputs:roughness.connect = </Materials/Material_${a.uniqueId}/Texture_${L.uniqueId}_roughness.outputs:${e}>`),t.push(zc(L,a,"roughness",new N.oo(g,g,g),c,o))):q.push(`${s}float inputs:roughness = ${g}`),null!==M?(q.push(`${s}float inputs:metallic.connect = </Materials/Material_${a.uniqueId}/Texture_${M.uniqueId}_metallic.outputs:${y}>`),t.push(zc(M,a,"metallic",new N.oo(k,k,k),c,o))):q.push(`${s}float inputs:metallic = ${k}`),null!==w?(q.push(`${s}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${w.uniqueId}_opacity.outputs:r>`),q.push(`${s}float inputs:opacityThreshold = 0.0001`),t.push(zc(w,a,"opacity",null,c,o))):q.push(`${s}float inputs:opacity = ${a.alpha}`),h&&(null!==S?(q.push(`${s}float inputs:clearcoat.connect = </Materials/Material_${a.uniqueId}/Texture_${S.uniqueId}_clearcoat.outputs:r>`),t.push(zc(S,a,"clearcoat",new N.oo(U,U,U),c,o))):q.push(`${s}float inputs:clearcoat = ${U}`),null!==x?(q.push(`${s}float inputs:clearcoatRoughness.connect = </Materials/Material_${a.uniqueId}/Texture_${x.uniqueId}_clearcoatRoughness.outputs:g>`),t.push(zc(x,a,"clearcoatRoughness",new N.oo(r,r,r),c,o))):q.push(`${s}float inputs:clearcoatRoughness = ${r}`)),q.push(`${s}float inputs:ior = ${Z}`),`\n\tdef Material "Material_${a.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${a.uniqueId}/PreviewSurface.outputs:surface>\n\n${t.join("\n")}\n\n\t}\n`}async function co(a,c,o){const t={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...c};"undefined"===typeof fflate&&await q.Tools.LoadScriptAsync(t.fflateUrl);const i={};i[t.modelFileName]=null;let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';p+=function(a){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===a.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${a.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${a.planeAnchoringAlignment}"`:""}\n            `}(t);const G={};for(const s of a.meshes){if(0===s.getTotalVertices())continue;const a=s,c=a.dc,T=a.material;if(!T||!c||o&&!o(a))continue;if(-1!==["co","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(T.getClassName())){const o="geometries/Geometry_"+c.uniqueId+".usda";if(!(o in i)){const a=Vc(c,t);i[o]=Ec(a)}T.uniqueId in G||(G[T.uniqueId]=T),p+=Ac(a)}else q.Tools.Warn("USDZExportAsync does not support this material type: "+T.getClassName())}a.activeCamera&&t.exportCamera&&(p+=function(a,c){const o="Camera_"+a.uniqueId,q=Hc(s.Matrix.RotationY(Math.PI).multiply(a.getWorldMatrix()));if(a.mode===Z.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${a.rc.toPrecision(c.precision)}, ${a.maxZ.toPrecision(c.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(a.orthoLeft||1)+Math.abs(a.orthoRight||1))).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(a.orthoTop||1)+Math.abs(a.orthoBottom||1))).toPrecision(c.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const s=a.getEngine().getAspectRatio(a),t=c.cameraSensorWidth||35;return`def Camera "${o}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${a.rc.toPrecision(c.precision)}, ${a.maxZ.toPrecision(c.precision)})\n\t\t\tfloat focalLength = ${(t/(2*Math.tan(.5*a.fov))).toPrecision(c.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(t*s).toPrecision(c.precision)}\n\t\t\tfloat verticalAperture = ${(t/s).toPrecision(c.precision)}            \n\t\t}\n\t\n\t`}}(a.activeCamera,t)),p+="\n            }\n        }\n    }";const T={};p+=function(a,c,o){const s=[];for(const q in a){const t=a[q];s.push(ao(t,c,o))}return`\n    def "Materials"\n{\n${s.join("")}\n}\n\n`}(G,T,t),i[t.modelFileName]=fflate.strToU8(p);for(const s in T){const a=T[s],c=a.getSize(),o=await a.readPixels();if(!o)throw new Error("Texture data is not available");const q=await h.DumpTools.DumpDataAsync(c.width,c.height,o,"image/png",void 0,!1,!0);i[`textures/Texture_${s}.png`]=new Uint8Array(q).slice()}let C=0;for(const s in i){const a=i[s];if(!a)continue;C+=34+s.length;const c=63&C;if(4!==c){const o=new Uint8Array(64-c);i[s]=[a,{extra:{12345:o}}]}C=a.length}return fflate.zipSync(i,{level:0})}}}]);