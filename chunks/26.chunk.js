"use strict";(self.gpkvekif0vo=self.gpkvekif0vo||[]).push([[26],{12808:(a,O,i)=>{i.r(O),i.d(O,{EXT_materials_diffuse_roughness:()=>cO,EXT_mesh_gpu_instancing:()=>oa,GLTF2Export:()=>Xa,GLTFData:()=>I,KHR_draco_mesh_compression:()=>iO,KHR_lights_punctual:()=>kO,KHR_materials_anisotropy:()=>eO,KHR_materials_clearcoat:()=>jO,KHR_materials_diffuse_transmission:()=>rO,KHR_materials_dispersion:()=>mi,KHR_materials_emissive_strength:()=>CO,KHR_materials_ior:()=>DO,KHR_materials_iridescence:()=>yO,KHR_materials_sheen:()=>KO,KHR_materials_specular:()=>fO,KHR_materials_transmission:()=>TO,KHR_materials_unlit:()=>EO,KHR_materials_volume:()=>WO,KHR_texture_transform:()=>zO,OBJExport:()=>q,STLExport:()=>xO,USDZExportAsync:()=>Oi,_ConvertToGLTFPBRMetallicRoughness:()=>A,_SolveMetallic:()=>T,__IGLTFExporterExtension:()=>Q});var H=i(12395),b=i(12184),G=i(12730);class q{static OBJ(a,O,i,q){const Q=[];let k=1,I=1;O&&(i||(i="mat"),Q.push("mtllib "+i+".mtl"));for(let P=0;P<a.length;P++){const i=a[P],e=i.name||`mesh${P}}`;Q.push(`o ${e}`);let h=null;if(q){const a=i.yb(!0);h=new H.Matrix,a.invertToRef(h),i.bakeTransformIntoVertices(a)}if(O){const a=i.material;a&&Q.push("usemtl "+a.id)}const j=i.wb;if(!j){b.Tools.Warn("No geometry is present on the mesh");continue}const Z=j.getVerticesData("position"),F=j.getVerticesData("normal"),r=j.getVerticesData("uv"),J=j.Kb();let ma=0,M=0;if(!Z||!J){b.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const C=a[0].Ua().useRightHandedSystem?1:-1;for(let a=0;a<Z.length;a+=3)Q.push("v "+Z[a]*C+" "+Z[a+1]+" "+Z[a+2]),ma++;if(null!=F)for(let a=0;a<F.length;a+=3)Q.push("vn "+F[a]*C+" "+F[a+1]+" "+F[a+2]);if(null!=r)for(let a=0;a<r.length;a+=2)Q.push("vt "+r[a]+" "+r[a+1]),M++;const n=["","",""],D=(i.material||i.Ua().defaultMaterial)._getEffectiveOrientation(i),[U,y]=D===G.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let a=0;a<J.length;a+=3){const O=[String(J[a]+k),String(J[a+U]+k),String(J[a+y]+k)],i=[String(J[a]+I),String(J[a+U]+I),String(J[a+y]+I)],H=O,b=null!=r?i:n,G=null!=F?O:n;Q.push("f "+H[0]+"/"+b[0]+"/"+G[0]+" "+H[1]+"/"+b[1]+"/"+G[1]+" "+H[2]+"/"+b[2]+"/"+G[2])}q&&h&&i.bakeTransformIntoVertices(h),k+=ma,I+=M}return Q.join("\n")}static MTL(a){const O=[],i=a.material;O.push("newmtl mat1"),O.push("  Ns "+i.specularPower.toFixed(4)),O.push("  Ni 1.5000"),O.push("  d "+i.alpha.toFixed(4)),O.push("  Tr 0.0000"),O.push("  Tf 1.0000 1.0000 1.0000"),O.push("  illum 2"),O.push("  Ka "+i.ambientColor.r.toFixed(4)+" "+i.ambientColor.g.toFixed(4)+" "+i.ambientColor.b.toFixed(4)),O.push("  Kd "+i.diffuseColor.r.toFixed(4)+" "+i.diffuseColor.g.toFixed(4)+" "+i.diffuseColor.b.toFixed(4)),O.push("  Ks "+i.specularColor.r.toFixed(4)+" "+i.specularColor.g.toFixed(4)+" "+i.specularColor.b.toFixed(4)),O.push("  Ke "+i.emissiveColor.r.toFixed(4)+" "+i.emissiveColor.g.toFixed(4)+" "+i.emissiveColor.b.toFixed(4));i.ambientTexture&&O.push("  map_Ka "+i.ambientTexture.name),i.diffuseTexture&&O.push("  map_Kd "+i.diffuseTexture.name),i.specularTexture&&O.push("  map_Ks "+i.specularTexture.name),i.bumpTexture&&O.push("  map_bump -imfchan z "+i.bumpTexture.name),i.opacityTexture&&O.push("  map_d "+i.opacityTexture.name);return O.join("\n")}}var Q=0,k=i(12243);class I{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const a in this.files){const O=this.files[a],i=new Blob([O],{type:(0,k.j)(a)});b.Tools.Download(i,a)}}}var P=i(12470),e=i(12813),h=i(12826),j=i(12837),Z=i(12528),F=i(12236),r=i(12436),J=i(12412);const ma=J.HighestCommonFactor,M={...J,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:ma};var C=i(12638),n=i(12370),D=i(12869),U=i(12878),y=i(12631);const w=1e-6,K=new r.mi(.04,.04,.04),S=1024,f=r.mi.White(),B=r.mi.Black();function T(a,O,i){if(O<K.r)return 0;const H=K.r,b=a*i/(1-K.r)+O-2*K.r,G=b*b-4*H*(K.r-O);return M.Clamp((-b+Math.sqrt(G))/(2*H),0,1)}function A(a){const O=a.diffuseColor.toLinearSpace(a.Ua().getEngine().useExactSrgbConversions).scale(.5),i=a.alpha,b=function(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new H.Vector2(0,1),i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new H.Vector2(0,.1),b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new H.Vector2(0,.1),G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new H.Vector2(1300,.1);return function(a,O,i,H,b){return(1-a)*(1-a)*(1-a)*O+3*(1-a)*(1-a)*a*i+3*(1-a)*a*a*H+a*a*a*b}(Math.pow(a/G.x,.333333),O.y,i.y,b.y,G.y)}(M.Clamp(a.specularPower,0,S));return{baseColorFactor:[O.r,O.g,O.b,i],metallicFactor:0,roughnessFactor:b}}function E(a,O){O.needAlphaBlending()?a.alphaMode="BLEND":O.needAlphaTesting()&&(a.alphaMode="MASK",a.alphaCutoff=O.alphaCutOff)}function l(a,O,i){const H=new Uint8Array(a*O*4);for(let b=0;b<H.length;b+=4)H[b]=H[b+1]=H[b+2]=H[b+3]=255;return D.d.CreateRGBATexture(H,a,O,i)}function W(a){if(a instanceof Uint8Array){const O=a.length,i=new Float32Array(a.length);for(let H=0;H<O;++H)i[H]=a[H]/255;return i}if(a instanceof Float32Array)return a;throw new Error("Unsupported pixel format!")}class u{constructor(a){this._exporter=a,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(a){return a?this._textureMap.get(a)??null:null}async exportStandardMaterialAsync(a,O,i){const H=A(a),G={name:a.name};if(null==a.Sb||a.Sb||(a.twoSidedLighting||b.Tools.Warn(a.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),G.doubleSided=!0),i){const i=[],b=a.diffuseTexture;b&&i.push(this.exportTextureAsync(b,O).then((a=>{a&&(H.baseColorTexture=a)})));const q=a.bumpTexture;q&&i.push(this.exportTextureAsync(q,O).then((a=>{a&&(G.normalTexture=a,1!==q.level&&(G.normalTexture.scale=q.level))})));const Q=a.emissiveTexture;Q&&(G.emissiveFactor=[1,1,1],i.push(this.exportTextureAsync(Q,O).then((a=>{a&&(G.emissiveTexture=a)}))));const k=a.ambientTexture;k&&i.push(this.exportTextureAsync(k,O).then((a=>{if(a){const O={index:a.index};G.occlusionTexture=O}}))),i.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(i))}(a.alpha<1||a.opacityTexture)&&(a.alphaMode===U.d.ALPHA_COMBINE?G.alphaMode="BLEND":b.Tools.Warn(a.name+": glTF 2.0 does not support alpha mode: "+a.alphaMode.toString())),a.emissiveColor&&!a.emissiveColor.equalsWithEpsilon(B,w)&&(G.emissiveFactor=a.emissiveColor.Cb()),G.pbrMetallicRoughness=H,E(G,a),await this._finishMaterialAsync(G,a,O);const q=this._exporter._materials;return q.push(G),q.length-1}async _finishMaterialAsync(a,O,i){const H=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",a,O),b=[];for(const G of H)b.push(this.exportTextureAsync(G,i));await Promise.all(b),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",a,O)}async _getImageDataAsync(a,O,H,b){const G=U.d.TEXTURETYPE_UNSIGNED_BYTE,q=this._exporter._babylonScene,Q=q.getEngine(),k=Q.createRawTexture(a,O,H,U.d.TEXTUREFORMAT_RGBA,!1,!0,n.e.NEAREST_SAMPLINGMODE,null,G);Q.isWebGPU?await i.e(51).then(i.bind(i,14887)):await i.e(52).then(i.bind(i,14893)),await C.j.ApplyPostProcess("pass",k,q,G,U.d.TEXTURE_NEAREST_SAMPLINGMODE,U.d.TEXTUREFORMAT_RGBA);const I=await Q._readTexturePixels(k,O,H);return await y.DumpTools.DumpDataAsync(O,H,I,b,void 0,!0,!0)}_resizeTexturesToSameDimensions(a,O,i){const H=a?a.getSize():{width:0,height:0},b=O?O.getSize():{width:0,height:0};let G,q;return H.width<b.width?(G=a&&a instanceof n.e?C.j.CreateResizedCopy(a,b.width,b.height,!0):l(b.width,b.height,i),q=O):H.width>b.width?(q=O&&O instanceof n.e?C.j.CreateResizedCopy(O,H.width,H.height,!0):l(H.width,H.height,i),G=a):(G=a,q=O),{texture1:G,texture2:q}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(a,O,i,H){const b=new Array;if(!a&&!O)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const G=a?a.Ua():O?O.Ua():null;if(G){var q;const Q=this._resizeTexturesToSameDimensions(a,O,G),k=null===(q=Q.texture1)||void 0===q?void 0:q.getSize();let I,P;const e=k.width,h=k.height,j=await Q.texture1.readPixels(),Z=await Q.texture2.readPixels();if(!j)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(I=W(j),!Z)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");P=W(Z);const F=P.byteLength,J=new Uint8Array(F),ma=new Uint8Array(F),M=4,C=B;let n=0,D=0;for(let a=0;a<h;++a)for(let O=0;O<e;++O){const H=(e*a+O)*M,b={diffuseColor:new r.mi(I[H],I[H+1],I[H+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(i.diffuseColor),specularColor:new r.mi(P[H],P[H+1],P[H+2]).toLinearSpace(G.getEngine().useExactSrgbConversions).multiply(i.specularColor),glossiness:P[H+3]*i.glossiness},q=this._convertSpecularGlossinessToMetallicRoughness(b);C.r=Math.max(C.r,q.baseColor.r),C.g=Math.max(C.g,q.baseColor.g),C.b=Math.max(C.b,q.baseColor.b),n=Math.max(n,q.metallic),D=Math.max(D,q.roughness),ma[H]=255*q.baseColor.r,ma[H+1]=255*q.baseColor.g,ma[H+2]=255*q.baseColor.b,ma[H+3]=Q.texture1.nb?255*I[H+3]:255,J[H]=0,J[H+1]=255*q.roughness,J[H+2]=255*q.metallic,J[H+3]=255}const U={baseColor:C,metallic:n,roughness:D};let y=!1,K=!1;for(let a=0;a<h;++a)for(let O=0;O<e;++O){const i=(e*a+O)*M;ma[i]/=U.baseColor.r>w?U.baseColor.r:1,ma[i+1]/=U.baseColor.g>w?U.baseColor.g:1,ma[i+2]/=U.baseColor.b>w?U.baseColor.b:1;const H=r.mi.FromInts(ma[i],ma[i+1],ma[i+2]).toGammaSpace(G.getEngine().useExactSrgbConversions);ma[i]=255*H.r,ma[i+1]=255*H.g,ma[i+2]=255*H.b,H.equalsWithEpsilon(f,w)||(K=!0),J[i+1]/=U.roughness>w?U.roughness:1,J[i+2]/=U.metallic>w?U.metallic:1;r.mi.FromInts(255,J[i+1],J[i+2]).equalsWithEpsilon(f,w)||(y=!0)}return y&&b.push(this._getImageDataAsync(J,e,h,H).then((a=>{U.metallicRoughnessTextureData=a}))),K&&b.push(this._getImageDataAsync(ma,e,h,H).then((a=>{U.baseColorTextureData=a}))),await Promise.all(b).then((()=>U))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(a){const O=this._getPerceivedBrightness(a.diffuseColor),i=this._getPerceivedBrightness(a.specularColor),H=1-this._getMaxComponent(a.specularColor),b=T(O,i,H),G=a.diffuseColor.scale(H/(1-K.r)/Math.max(1-b)),q=a.specularColor.FO(K.scale(1-b)).scale(1/Math.max(b));let Q=r.mi.Lerp(G,q,b*b);Q=Q.clampToRef(0,1,Q);return{baseColor:Q,metallic:b,roughness:1-a.glossiness}}_getPerceivedBrightness(a){return a?Math.sqrt(.299*a.r*a.r+.587*a.g*a.g+.114*a.b*a.b):0}_getMaxComponent(a){return a?Math.max(a.r,Math.max(a.g,a.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(a,O,i,H){const b=[],G={baseColor:a._albedoColor,metallic:a._metallic,roughness:a._roughness};if(H){a._albedoTexture&&b.push(this.exportTextureAsync(a._albedoTexture,O).then((a=>{a&&(i.baseColorTexture=a)})));const H=a._metallicTexture;H&&b.push(this.exportTextureAsync(H,O).then((a=>{a&&(i.metallicRoughnessTexture=a)})))}return b.length>0&&(this._exporter._materialNeedsUVsSet.add(a),await Promise.all(b)),G}_getTextureSampler(a){const O={};if(!a||!(a instanceof n.e))return O;const i=this._getGLTFTextureWrapMode(a.wrapU);10497!==i&&(O.wrapS=i);const H=this._getGLTFTextureWrapMode(a.wrapV);switch(10497!==H&&(O.wrapT=H),a.samplingMode){case n.e.LINEAR_LINEAR:O.magFilter=9729,O.minFilter=9729;break;case n.e.LINEAR_NEAREST:O.magFilter=9729,O.minFilter=9728;break;case n.e.NEAREST_LINEAR:O.magFilter=9728,O.minFilter=9729;break;case n.e.NEAREST_LINEAR_MIPLINEAR:O.magFilter=9728,O.minFilter=9987;break;case n.e.NEAREST_NEAREST:O.magFilter=9728,O.minFilter=9728;break;case n.e.NEAREST_LINEAR_MIPNEAREST:O.magFilter=9728,O.minFilter=9985;break;case n.e.LINEAR_NEAREST_MIPNEAREST:O.magFilter=9729,O.minFilter=9984;break;case n.e.LINEAR_NEAREST_MIPLINEAR:O.magFilter=9729,O.minFilter=9986;break;case n.e.NEAREST_NEAREST_MIPLINEAR:O.magFilter=9728,O.minFilter=9986;break;case n.e.LINEAR_LINEAR_MIPLINEAR:O.magFilter=9729,O.minFilter=9987;break;case n.e.LINEAR_LINEAR_MIPNEAREST:O.magFilter=9729,O.minFilter=9985;break;case n.e.NEAREST_NEAREST_MIPNEAREST:O.magFilter=9728,O.minFilter=9984}return O}_getGLTFTextureWrapMode(a){switch(a){case n.e.WRAP_ADDRESSMODE:return 10497;case n.e.CLAMP_ADDRESSMODE:return 33071;case n.e.MIRROR_ADDRESSMODE:return 33648;default:return b.Tools.Error(`Unsupported Texture Wrap Mode ${a}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(a,O,i,H){const b={diffuseColor:a._albedoColor,specularColor:a._reflectivityColor,glossiness:a._microSurface},G=a._albedoTexture,q=a._reflectivityTexture,Q=a._useMicroSurfaceFromReflectivityMapAlpha;if(q&&!Q)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((G||q)&&H){this._exporter._materialNeedsUVsSet.add(a);const H=this._exportTextureSampler(G||q),Q=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(G,q,b,O),k=this._exporter._textures;if(Q.baseColorTextureData){const a=this._exportImage(`baseColor${k.length}`,O,Q.baseColorTextureData);i.baseColorTexture=this._exportTextureInfo(a,H,null===G||void 0===G?void 0:G.coordinatesIndex)}if(Q.metallicRoughnessTextureData){const a=this._exportImage(`metallicRoughness${k.length}`,O,Q.metallicRoughnessTextureData);i.metallicRoughnessTexture=this._exportTextureInfo(a,H,null===q||void 0===q?void 0:q.coordinatesIndex)}return Q}return this._convertSpecularGlossinessToMetallicRoughness(b)}async exportPBRMaterialAsync(a,O,i){const H={},b={name:a.name},G=a.isMetallicWorkflow();if(G){const O=a._albedoColor,i=a.alpha;O&&(H.baseColorFactor=[O.r,O.g,O.b,i])}const q=G?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(a,O,H,i):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(a,O,H,i);await this._setMetallicRoughnessPbrMaterialAsync(q,a,b,H,O,i),await this._finishMaterialAsync(b,a,O);const Q=this._exporter._materials;return Q.push(b),Q.length-1}async _setMetallicRoughnessPbrMaterialAsync(a,O,i,H,G,q){if(E(i,O),a.baseColor.equalsWithEpsilon(f,w)&&M.WithinEpsilon(O.alpha,1,w)||(H.baseColorFactor=[a.baseColor.r,a.baseColor.g,a.baseColor.b,O.alpha]),null!=a.metallic&&1!==a.metallic&&(H.metallicFactor=a.metallic),null!=a.roughness&&1!==a.roughness&&(H.roughnessFactor=a.roughness),null==O.Sb||O.Sb||(O._twoSidedLighting||b.Tools.Warn(O.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),i.doubleSided=!0),q){const a=[],H=O._bumpTexture;H&&a.push(this.exportTextureAsync(H,G).then((a=>{a&&(i.normalTexture=a,1!==H.level&&(i.normalTexture.scale=H.level))})));const b=O._ambientTexture;b&&a.push(this.exportTextureAsync(b,G).then((a=>{if(a){const H={index:a.index,texCoord:a.texCoord,extensions:a.extensions};i.occlusionTexture=H;const b=O._ambientTextureStrength;b&&(H.strength=b)}})));const q=O._emissiveTexture;q&&a.push(this.exportTextureAsync(q,G).then((a=>{a&&(i.emissiveTexture=a)}))),a.length>0&&(this._exporter._materialNeedsUVsSet.add(O),await Promise.all(a))}const Q=O._emissiveColor;Q.equalsWithEpsilon(B,w)||(i.emissiveFactor=Q.Cb()),i.pbrMetallicRoughness=H}_getPixelsFromTextureAsync(a){return function(a){switch(a){case U.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case U.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case U.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case U.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case U.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case U.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case U.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case U.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case U.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case U.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case U.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case U.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case U.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(a.textureFormat)?(0,C.h)(a,a._texture.width,a._texture.height):(a.textureType,U.d.TEXTURETYPE_UNSIGNED_BYTE,a.readPixels())}async exportTextureAsync(a,O){const i=this._exporter._extensionsPreExportTextureAsync("exporter",a,O);return i?await i.then((async i=>i?await this._exportTextureInfoAsync(i,O):await this._exportTextureInfoAsync(a,O))):await this._exportTextureInfoAsync(a,O)}async _exportTextureInfoAsync(a,O){let i=this._textureMap.get(a);if(!i){const H=await this._getPixelsFromTextureAsync(a);if(!H)return null;const G=this._exportTextureSampler(a),q=a.mimeType;if(q)switch(q){case"image/jpeg":case"image/png":case"image/webp":O=q;break;default:b.Tools.Warn(`Unsupported media type: ${q}. Exporting texture as PNG.`)}const Q=this._internalTextureToImage,k=a.getInternalTexture().uniqueId;Q[k]||(Q[k]={});let I=Q[k][O];if(void 0===I){const i=a.getSize();I=(async()=>{const b=await this._getImageDataAsync(H,i.width,i.height,O);return this._exportImage(a.name,O,b)})(),Q[k][O]=I}i=this._exportTextureInfo(await I,G,a.coordinatesIndex),this._textureMap.set(a,i),this._exporter._extensionsPostExportTextures("exporter",i,a)}return i}_exportImage(a,O,i){const H=this._exporter._images;let G;if(this._exporter._shouldUseGlb){G={name:a,mimeType:O,bufferView:void 0};const H=this._exporter._bufferManager.createBufferView(new Uint8Array(i));this._exporter._bufferManager.setBufferView(G,H)}else{const q=a.replace(/\.\/|\/|\.\\|\\/g,"_"),Q=function(a){switch(a){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(O);let k=q+Q;H.some((a=>a.uri===k))&&(k=`${q}_${b.Tools.RandomId()}${Q}`),G={name:a,uri:k},this._exporter._imageData[k]={data:i,mimeType:O}}return H.push(G),H.length-1}_exportTextureInfo(a,O,i){const H=this._exporter._textures;let b=H.findIndex((i=>i.sampler==O&&i.source===a));-1===b&&(b=H.length,H.push({source:a,sampler:O}));const G={index:b};return i&&(G.texCoord=i),G}_exportTextureSampler(a){const O=this._getTextureSampler(a),i=this._exporter._samplers,H=i.findIndex((a=>a.minFilter===O.minFilter&&a.magFilter===O.magFilter&&a.wrapS===O.wrapS&&a.wrapT===O.wrapT));return-1!==H?H:(i.push(O),i.length-1)}}var c=i(12482),R=i(12209),z=i(12880),x=i(12397);const g=H.ZO.Zero(),N=H.Quaternion.Identity(),v=H.ZO.One(),X=new H.ZO(-1,1,1);function p(a,O){const{byteOffset:i,byteStride:H,type:b,normalized:G}=a,q=a.getSize(),Q=O.reduce(((a,O)=>O.getTotalVertices()>a?O.getTotalVertices():a),-Number.MAX_VALUE);return{byteOffset:i,byteStride:H,componentCount:q,type:b,count:Q*q,normalized:G,totalVertices:Q,kind:a.getKind()}}function o(a){switch(a){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function d(a){switch(a){case P.c.PositionKind:case P.c.NormalKind:case P.c.TangentKind:case P.c.ColorKind:case P.c.MatricesIndicesKind:case P.c.MatricesIndicesExtraKind:case P.c.MatricesWeightsKind:case P.c.MatricesWeightsExtraKind:case P.c.UVKind:case P.c.UV2Kind:case P.c.UV3Kind:case P.c.UV4Kind:case P.c.UV5Kind:case P.c.UV6Kind:return!0}return!1}function Y(a){switch(a){case G.b.TriangleFillMode:return 4;case G.b.TriangleStripDrawMode:return 5;case G.b.TriangleFanDrawMode:return 6;case G.b.PointListDrawMode:case G.b.PointFillMode:return 0;case G.b.LineLoopDrawMode:return 2;case G.b.LineListDrawMode:return 1;case G.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${a}`)}function L(a){const O=Math.sqrt(a.x*a.x+a.y*a.y+a.z*a.z);O>0&&(a.x/=O,a.y/=O,a.z/=O)}function s(a){return a.x*=-1,a}function t(a){if(a.x*a.x+a.y*a.y>.5){const O=Math.abs(a.x),i=Math.abs(a.y);if(O>i){const i=Math.sign(a.x);a.x=O,a.y*=-i,a.z*=-i,a.w*=i}else{const O=Math.sign(a.y);a.x*=-O,a.y=i,a.z*=O,a.w*=-O}}else{const O=Math.abs(a.z),i=Math.abs(a.w);if(O>i){const i=Math.sign(a.z);a.x*=-i,a.y*=i,a.z=O,a.w*=-i}else{const O=Math.sign(a.w);a.x*=O,a.y*=-O,a.z*=-O,a.w=i}}return a}function V(a){a.fb(-a.z,a.w,a.x,-a.y)}function aa(a,O){const i=H.ZO.FromArrayToRef(O.translation||[0,0,0],0,H.TmpVectors.ZO[0]),b=H.Quaternion.FromArrayToRef(O.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[0]),G=H.Matrix.ComposeToRef(v,b,i,H.TmpVectors.Matrix[0]),q=H.ZO.FromArrayToRef(a.translation||[0,0,0],0,H.TmpVectors.ZO[2]),Q=H.Quaternion.FromArrayToRef(a.rotation||[0,0,0,1],0,H.TmpVectors.Quaternion[1]),k=H.Matrix.ComposeToRef(v,Q,q,H.TmpVectors.Matrix[1]);G.multiplyToRef(k,k),k.decompose(void 0,b,i),i.equalsWithEpsilon(g,x.e)?delete O.translation:O.translation=i.Cb(),b.equalsWithEpsilon(N,x.e)?delete O.rotation:O.rotation=b.Cb(),O.scale&&delete O.scale}function Oa(a,O){if(!(O instanceof e.d))return!1;if(!(1===O.getChildren().length&&0===a.getChildren().length&&a.parent===O))return!1;const i=a.Ua(),H=a instanceof z.c&&!i.useRightHandedSystem?X:v;return!!O.Bb.equalsWithEpsilon(H,x.e)||(R.c.Warn(`Cannot collapse node ${a.name} into parent node ${O.name} with modified scaling.`),!1)}function ia(a){if(a instanceof Array){const O=new Float32Array(a);return new Uint8Array(O.buffer,O.byteOffset,O.byteLength)}return ArrayBuffer.isView(a)?new Uint8Array(a.buffer,a.byteOffset,a.byteLength):new Uint8Array(a)}function Ha(a,O){for(const[i,H]of Object.entries(a)){const b=O[i];(Array.isArray(H)&&Array.isArray(b)&&ba(H,b)||H===b)&&delete a[i]}return a}function ba(a,O){return a.length===O.length&&a.every(((a,i)=>a===O[i]))}const Ga=H.Matrix.Compose(new H.ZO(-1,1,1),H.Quaternion.Identity(),H.ZO.Zero());function qa(a,O){if(!(a instanceof e.d))return!1;if(O){if(!a.getWorldMatrix().equalsWithEpsilon(H.Matrix.IdentityReadOnly,x.e))return!1}else{if(!a.getWorldMatrix().multiplyToRef(Ga,H.TmpVectors.Matrix[0]).equalsWithEpsilon(H.Matrix.IdentityReadOnly,x.e))return!1}return!(a instanceof h.e&&a.wb)}const Qa=new Map([[Int8Array,(a,O,i)=>a.setInt8(O,i)],[Uint8Array,(a,O,i)=>a.setUint8(O,i)],[Uint8ClampedArray,(a,O,i)=>a.setUint8(O,i)],[Int16Array,(a,O,i)=>a.setInt16(O,i,!0)],[Uint16Array,(a,O,i)=>a.setUint16(O,i,!0)],[Int32Array,(a,O,i)=>a.setInt32(O,i,!0)],[Uint32Array,(a,O,i)=>a.setUint32(O,i,!0)],[Float32Array,(a,O,i)=>a.setFloat32(O,i,!0)],[Float64Array,(a,O,i)=>a.setFloat64(O,i,!0)]]);class ka{writeTypedArray(a){this._checkGrowBuffer(a.byteLength);const O=Qa.get(a.constructor);for(let i=0;i<a.length;i++)O(this._dataView,this._byteOffset,a[i]),this._byteOffset+=a.BYTES_PER_ELEMENT}constructor(a){this._data=new Uint8Array(a),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(a){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,a),this._byteOffset++}writeInt8(a){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,a),this._byteOffset++}writeInt16(a){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,a,!0),this._byteOffset+=2}writeUInt16(a){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,a,!0),this._byteOffset+=2}writeInt32(a){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,a,!0),this._byteOffset+=4}writeUInt32(a){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,a,!0),this._byteOffset+=4}writeFloat32(a){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,a,!0),this._byteOffset+=4}writeFloat64(a){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,a,!0),this._byteOffset+=8}_checkGrowBuffer(a){const O=this.byteOffset+a;if(O>this._data.byteLength){const a=new Uint8Array(2*O);a.set(this._data),this._data=a,this._dataView=new DataView(this._data.buffer)}}}function Ia(a){return a%4===0?4:a%2===0?2:1}class Pa{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(a){let O=0;this._bufferViewToData.forEach((a=>{O+=a.byteLength}));const i=new ka(O),H=Array.from(this._bufferViewToData.keys()).sort(((a,O)=>Ia(O.byteLength)-Ia(a.byteLength)));for(const b of H){b.byteOffset=i.byteOffset,a.push(b);const O=a.length-1,H=this.getPropertiesWithBufferView(b);for(const a of H)a.bufferView=O;i.writeTypedArray(this._bufferViewToData.get(b)),this._bufferViewToData.delete(b)}return i.getOutputData()}createBufferView(a,O){const i={buffer:0,byteOffset:void 0,byteLength:a.byteLength,byteStride:O};return this._bufferViewToData.set(i,a),i}createAccessor(a,O,i,H,b,G,q){this._verifyBufferView(a);const Q={bufferView:void 0,componentType:i,count:H,type:O,min:null===G||void 0===G?void 0:G.min,max:null===G||void 0===G?void 0:G.max,normalized:q,byteOffset:b};return this.setBufferView(Q,a),this._accessorToBufferView.set(Q,a),Q}setBufferView(a,O){this._verifyBufferView(O);this.getPropertiesWithBufferView(O).push(a)}removeBufferView(a){const O=this.getPropertiesWithBufferView(a);for(const i of O)void 0!==i.bufferView&&delete i.bufferView;this._bufferViewToData.delete(a),this._bufferViewToProperties.delete(a),this._accessorToBufferView.forEach(((O,i)=>{O===a&&(void 0!==i.byteOffset&&delete i.byteOffset,this._accessorToBufferView.delete(i))}))}getBufferView(a){const O=this._accessorToBufferView.get(a);return this._verifyBufferView(O),O}getPropertiesWithBufferView(a){return this._verifyBufferView(a),this._bufferViewToProperties.set(a,this._bufferViewToProperties.get(a)??[]),this._bufferViewToProperties.get(a)}getData(a){return this._verifyBufferView(a),this._bufferViewToData.get(a)}_verifyBufferView(a){if(void 0===a||!this._bufferViewToData.has(a))throw new Error(`BufferView ${a} not found in BufferManager.`)}}var ea,ha=i(12846),ja=i(12866),Za=i(12884),Fa=i(12777),ra=i(12916),Ja=i(12933),mO=i(12841),Ma=i(12936);!function(a){a[a.INTANGENT=0]="INTANGENT",a[a.OUTTANGENT=1]="OUTTANGENT"}(ea||(ea={}));class Ca{static _IsTransformable(a){return a&&(a instanceof e.d||a instanceof ha.e||a instanceof Ma.b)}static _CreateNodeAnimation(a,O,i,H,G){if(this._IsTransformable(a)){const q=[],Q=[],k=O.getKeys(),I=Ca._CalculateMinMaxKeyFrames(k),P=Ca._DeduceInterpolation(k,i,H),e=P.interpolationType,h=P.shouldBakeAnimation;if(h?Ca._CreateBakedAnimation(a,O,i,I.min,I.max,O.framePerSecond,G,q,Q,I,H):"LINEAR"===e||"STEP"===e?Ca._CreateLinearOrStepAnimation(a,O,i,q,Q,H):"CUBICSPLINE"===e?Ca._CreateCubicSplineAnimation(a,O,i,q,Q,H):Ca._CreateBakedAnimation(a,O,i,I.min,I.max,O.framePerSecond,G,q,Q,I,H),q.length&&Q.length){return{inputs:q,outputs:Q,samplerInterpolation:e,inputsMin:h?I.min:b.Tools.FloatRound(I.min/O.framePerSecond),inputsMax:h?I.max:b.Tools.FloatRound(I.max/O.framePerSecond)}}}return null}static _DeduceAnimationInfo(a){let O=null,i="VEC3",H=!1;const G=a.targetProperty.split(".");switch(G[0]){case"Bb":O="scale";break;case"position":O="translation";break;case"rotation":i="VEC4",O="rotation";break;case"rotationQuaternion":i="VEC4",H=!0,O="rotation";break;case"influence":i="SCALAR",O="weights";break;default:b.Tools.Error(`Unsupported animatable property ${G[0]}`)}return O?{animationChannelTargetPath:O,dataAccessorType:i,useQuaternion:H}:(b.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(a,O,i,H,b,G,q,Q,k,I,P){let e;if(Ca._IsTransformable(a)&&a.animations)for(const h of a.animations){if(P&&!P(h))continue;const b=Ca._DeduceAnimationInfo(h);b&&(e={name:h.name,samplers:[],channels:[]},Ca._AddAnimation(`${h.name}`,h.hasRunningRuntimeAnimations?O:e,a,h,b.dataAccessorType,b.animationChannelTargetPath,H,G,q,Q,b.useQuaternion,k,I),e.samplers.length&&e.channels.length&&i.push(e))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(a,O,i,H,b,G,q,Q,k,I,P){let e;if(a instanceof mO.d){const b=a.morphTargetManager;if(b)for(let h=0;h<b.numTargets;++h){const j=b.getTarget(h);for(const Z of j.animations){if(P&&!P(Z))continue;const j=new ra.b(`${Z.name}`,"influence",Z.framePerSecond,Z.dataType,Z.loopMode,Z.enableBlending),F=[],r=Z.getKeys();for(let a=0;a<r.length;++a){const O=r[a];for(let a=0;a<b.numTargets;++a)a==h?F.push(O):F.push({frame:O.frame,value:0})}j.setKeys(F);const J=Ca._DeduceAnimationInfo(j);J&&(e={name:j.name,samplers:[],channels:[]},Ca._AddAnimation(Z.name,Z.hasRunningRuntimeAnimations?O:e,a,j,J.dataAccessorType,J.animationChannelTargetPath,H,G,q,Q,J.useQuaternion,k,I,b.numTargets),e.samplers.length&&e.channels.length&&i.push(e))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(a,O,i,H,b,G,q,Q,k){let I;if(a.animationGroups){const e=a.animationGroups;for(const h of e){const e=new Map,j=new Map,Z=new Set,F=h.to-h.from;I={name:h.name,channels:[],samplers:[]};for(let O=0;O<h.targetedAnimations.length;++O){const F=h.targetedAnimations[O],r=F.target,J=F.animation;if(k&&!k(J))continue;const ma=Q.has(r);if(this._IsTransformable(r)||1===r.length&&this._IsTransformable(r[0])){const a=Ca._DeduceAnimationInfo(F.animation);if(a){const O=this._IsTransformable(r)?r:this._IsTransformable(r[0])?r[0]:null;O&&Ca._AddAnimation(`${J.name}`,I,O,J,a.dataAccessorType,a.animationChannelTargetPath,i,H,b,G,a.useQuaternion,q,ma)}}else if(r instanceof Ja.b||1===r.length&&r[0]instanceof Ja.b){if(Ca._DeduceAnimationInfo(F.animation)){const O=r instanceof Ja.b?r:r[0];if(O){const i=a.morphTargetManagers.find((a=>{for(let i=0;i<a.numTargets;++i)if(a.getTarget(i)===O)return!0;return!1}));if(i){const H=a.meshes.find((a=>a.morphTargetManager===i));var P;if(H)e.has(H)||e.set(H,new Map),null===(P=e.get(H))||void 0===P||P.set(O,J),Z.add(H),j.set(H,J)}}}}}Z.forEach((a=>{const O=a.morphTargetManager;let Q=null;const k=[],P=j.get(a).getKeys(),Z=P.length;for(let i=0;i<Z;++i)for(let H=0;H<O.numTargets;++H){const b=O.getTarget(H),G=e.get(a);if(G){const O=G.get(b);O?(Q||(Q=new ra.b(`${h.name}_${a.name}_MorphWeightAnimation`,"influence",O.framePerSecond,ra.b.ANIMATIONTYPE_FLOAT,O.loopMode,O.enableBlending)),k.push(O.getKeys()[i])):k.push({frame:h.from+F/Z*i,value:b.influence,inTangent:P[0].inTangent?0:void 0,outTangent:P[0].outTangent?0:void 0})}}Q.setKeys(k);const r=Ca._DeduceAnimationInfo(Q);r&&Ca._AddAnimation(`${h.name}_${a.name}_MorphWeightAnimation`,I,a,Q,r.dataAccessorType,r.animationChannelTargetPath,i,H,b,G,r.useQuaternion,q,!1,null===O||void 0===O?void 0:O.numTargets)})),I.channels.length&&I.samplers.length&&O.push(I)}}}static _AddAnimation(a,O,i,b,G,q,Q,k,I,P,e,h,j,Z){const F=Ca._CreateNodeAnimation(i,b,q,e,h);let r,J,ma,M,C,n;if(F){if(Z){let a=0,O=0;const i=[];for(;F.inputs.length>0;)O=F.inputs.shift(),a%Z==0&&i.push(O),a++;F.inputs=i}const a=Q.get(i),b=new Float32Array(F.inputs);r=k.createBufferView(b),J=k.createAccessor(r,"SCALAR",5126,F.inputs.length,void 0,{min:[F.inputsMin],max:[F.inputsMax]}),P.push(J),ma=P.length-1;const I=new H.Quaternion,e=new H.ZO,h=new H.ZO,D=i instanceof ha.e,U=o(G),y=new Float32Array(F.outputs.length*U);F.outputs.forEach((function(a,O){let i=a;switch(q){case"translation":j&&(H.ZO.FromArrayToRef(a,0,h),s(h),h.toArray(i));break;case"rotation":4===a.length?H.Quaternion.FromArrayToRef(a,0,I):(i=new Array(4),H.ZO.FromArrayToRef(a,0,e),H.Quaternion.FromEulerVectorToRef(e,I)),j&&(t(I),D&&V(I)),I.toArray(i)}y.set(i,O*U)})),r=k.createBufferView(y),J=k.createAccessor(r,G,5126,F.outputs.length),P.push(J),M=P.length-1,C={interpolation:F.samplerInterpolation,input:ma,output:M},O.samplers.push(C),n={sampler:O.samplers.length-1,target:{node:a,path:q}},O.channels.push(n)}}static _CreateBakedAnimation(a,O,i,G,q,Q,k,I,P,e,h){let j;const Z=H.Quaternion.Identity();let F,r=null,J=null,ma=null,M=null,C=null,n=null;e.min=b.Tools.FloatRound(G/Q);const D=O.getKeys();for(let H=0,U=D.length;H<U;++H){if(n=null,ma=D[H],H+1<U)if(M=D[H+1],ma.value.equals&&ma.value.equals(M.value)||ma.value===M.value){if(0!==H)continue;n=ma.frame}else n=M.frame;else{if(C=D[H-1],ma.value.equals&&ma.value.equals(C.value)||ma.value===C.value)continue;n=q}if(n)for(let H=ma.frame;H<=n;H+=k){if(F=b.Tools.FloatRound(H/Q),F===r)continue;r=F,J=F;const G={key:0,repeatCount:0,loopMode:O.loopMode};j=O._interpolate(H,G),Ca._SetInterpolatedValue(a,j,F,O,i,Z,I,P,h)}}J&&(e.max=J)}static _ConvertFactorToVector3OrQuaternion(a,O,i,G,q){const Q=Ca._GetBasePositionRotationOrScale(O,G,q),k=i.targetProperty.split("."),I=k?k[1]:"",P=q?H.Quaternion.MO(Q).normalize():H.ZO.MO(Q);switch(I){case"x":case"y":case"z":P[I]=a;break;case"w":P.w=a;break;default:b.Tools.Error(`glTFAnimation: Unsupported component name "${I}"!`)}return P}static _SetInterpolatedValue(a,O,i,b,G,q,Q,k,I){let P;Q.push(i),"weights"!==G?(b.dataType===ra.b.ANIMATIONTYPE_FLOAT&&(O=this._ConvertFactorToVector3OrQuaternion(O,a,b,G,I)),"rotation"===G?(I?q=O:(P=O,H.Quaternion.RotationYawPitchRollToRef(P.y,P.x,P.z,q)),k.push(q.Cb())):(P=O,k.push(P.Cb()))):k.push([O])}static _CreateLinearOrStepAnimation(a,O,i,H,b,G){for(const q of O.getKeys())H.push(q.frame/O.framePerSecond),Ca._AddKeyframeValue(q,O,b,i,a,G)}static _CreateCubicSplineAnimation(a,O,i,H,b,G){O.getKeys().forEach((function(q){H.push(q.frame/O.framePerSecond),Ca._AddSplineTangent(ea.INTANGENT,b,i,"CUBICSPLINE",q,G),Ca._AddKeyframeValue(q,O,b,i,a,G),Ca._AddSplineTangent(ea.OUTTANGENT,b,i,"CUBICSPLINE",q,G)}))}static _GetBasePositionRotationOrScale(a,O,i){let b;if("rotation"===O)if(i){b=(a.rotationQuaternion??H.Quaternion.Identity()).Cb()}else{b=(a.rotation??H.ZO.Zero()).Cb()}else if("translation"===O){b=(a.position??H.ZO.Zero()).Cb()}else{b=(a.Bb??H.ZO.One()).Cb()}return b}static _AddKeyframeValue(a,O,i,G,q,Q){let k;const I=O.dataType;if(I===ra.b.ANIMATIONTYPE_VECTOR3){let O=a.value.Cb();if("rotation"===G){const a=H.ZO.MO(O);O=H.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).Cb()}i.push(O)}else if(I===ra.b.ANIMATIONTYPE_FLOAT){if("weights"===G)i.push([a.value]);else if(k=this._ConvertFactorToVector3OrQuaternion(a.value,q,O,G,Q),k){if("rotation"===G){const a=Q?k:H.Quaternion.RotationYawPitchRoll(k.y,k.x,k.z).normalize();i.push(a.Cb())}i.push(k.Cb())}}else I===ra.b.ANIMATIONTYPE_QUATERNION?i.push(a.value.normalize().Cb()):b.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(a,O,i){let H,b,G=!1;if("rotation"===O&&!i)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let q=0,Q=a.length;q<Q;++q)if(b=a[q],b.inTangent||b.outTangent)if(H){if("CUBICSPLINE"!==H){H="LINEAR",G=!0;break}}else H="CUBICSPLINE";else if(H){if("CUBICSPLINE"===H||b.interpolation&&1===b.interpolation&&"STEP"!==H){H="LINEAR",G=!0;break}}else H=b.interpolation&&1===b.interpolation?"STEP":"LINEAR";return H||(H="LINEAR"),{interpolationType:H,shouldBakeAnimation:G}}static _AddSplineTangent(a,O,i,b,G,q){let Q;const k=a===ea.INTANGENT?G.inTangent:G.outTangent;if("CUBICSPLINE"===b){if("rotation"===i)if(k)if(q)Q=k.Cb();else{const a=k;Q=H.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).Cb()}else Q=[0,0,0,0];else Q="weights"===i?k?[k]:[0]:k?k.Cb():[0,0,0];O.push(Q)}}static _CalculateMinMaxKeyFrames(a){let O=1/0,i=-1/0;return a.forEach((function(a){O=Math.min(O,a.frame),i=Math.max(i,a.frame)})),{min:O,max:i}}}function na(a,O,i,G,q,Q){const k={attributes:{},influence:a.influence,name:a.name},I=O.wb;if(!I)return b.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),k;const e=Q?-1:1,h=H.ZO.Zero();let j=0,Z=0;if(a.hasPositions){const G=a.getPositions(),Q=I.getVerticesData(P.c.PositionKind);if(Q){const a=new Float32Array(Q.length),O=[1/0,1/0,1/0],b=[-1/0,-1/0,-1/0];Z=Q.length/3,j=0;for(let i=j;i<Z;++i){const q=H.ZO.MO(Q,3*i);H.ZO.MO(G,3*i).subtractToRef(q,h),h.x*=e,O[0]=Math.min(O[0],h.x),b[0]=Math.max(b[0],h.x),O[1]=Math.min(O[1],h.y),b[1]=Math.max(b[1],h.y),O[2]=Math.min(O[2],h.z),b[2]=Math.max(b[2],h.z),a[3*i]=h.x,a[3*i+1]=h.y,a[3*i+2]=h.z}const I=i.createBufferView(a,12),P=i.createAccessor(I,"VEC3",5126,G.length/3,0,{min:O,max:b});q.push(P),k.attributes.POSITION=q.length-1}else b.Tools.Warn(`Morph target positions for mesh ${O.name} were not exported. Mesh does not have position vertex data`)}if(a.hasNormals){const G=a.getNormals(),Q=I.getVerticesData(P.c.NormalKind);if(Q){const a=new Float32Array(Q.length);Z=Q.length/3,j=0;for(let i=j;i<Z;++i){const O=H.ZO.MO(Q,3*i).normalize();H.ZO.MO(G,3*i).normalize().subtractToRef(O,h),a[3*i]=h.x*e,a[3*i+1]=h.y,a[3*i+2]=h.z}const O=i.createBufferView(a,12),b=i.createAccessor(O,"VEC3",5126,G.length/3,0);q.push(b),k.attributes.NORMAL=q.length-1}else b.Tools.Warn(`Morph target normals for mesh ${O.name} were not exported. Mesh does not have normals vertex data`)}if(a.hasTangents){const G=a.getTangents(),Q=I.getVerticesData(P.c.TangentKind);if(Q){Z=Q.length/4;const a=new Float32Array(3*Z);j=0;for(let i=j;i<Z;++i){const O=H.ZO.MO(Q,4*i);L(O);const b=H.ZO.MO(G,3*i);L(b),b.subtractToRef(O,h),a[3*i]=h.x*e,a[3*i+1]=h.y,a[3*i+2]=h.z}const O=i.createBufferView(a,12),b=i.createAccessor(O,"VEC3",5126,Z,0);q.push(b),k.attributes.TANGENT=q.length-1}else b.Tools.Warn(`Morph target tangents for mesh ${O.name} were not exported. Mesh does not have tangents vertex data`)}if(a.hasColors){const G=a.getColors(),Q=I.getVerticesData(P.c.ColorKind),e=I.getVertexBuffer(P.c.ColorKind);if(Q&&e){const a=e.getSize();Z=Q.length/a;const O=new Float32Array(Z*a);j=0;for(let i=j;i<Z;++i)if(3===a){const b=H.ZO.MO(Q,i*a);H.ZO.MO(G,i*a).subtractToRef(b,h),O[3*i]=h.x,O[3*i+1]=h.y,O[3*i+2]=h.z}else if(4===a){const b=new H.Vector4,q=H.Vector4.MO(Q,i*a);H.Vector4.MO(G,i*a).subtractToRef(q,b),O[4*i]=b.x,O[4*i+1]=b.y,O[4*i+2]=b.z,O[4*i+3]=b.w}else b.Tools.Warn(`Unsupported number of components for color attribute: ${a}`);const I=i.createBufferView(O,4*a),P=i.createAccessor(I,3===a?"VEC3":"VEC4",5126,Z,0);q.push(P),k.attributes.COLOR_0=q.length-1}else b.Tools.Warn(`Morph target colors for mesh ${O.name} were not exported. Mesh does not have colors vertex data`)}return k}var Da=i(12942),Ua=i(12802),ya=i(12783),wa=i(12346);class Ka{}Ka.DEFAULT_COLOR=r.mi.White(),Ka.DEFAULT_WIDTH_ATTENUATED=1,Ka.DEFAULT_WIDTH=.1;var Sa=i(12613),fa=i(12946);class Ba{static ConvertPoints(a,O){if(a.length&&Array.isArray(a)&&"number"===typeof a[0])return[a];if(a.length&&Array.isArray(a[0])&&"number"===typeof a[0][0])return a;if(a.length&&!Array.isArray(a[0])&&a[0]instanceof H.ZO){const O=[];for(let i=0;i<a.length;i++){const H=a[i];O.push(H.x,H.y,H.z)}return[O]}if(a.length>0&&Array.isArray(a[0])&&a[0].length>0&&a[0][0]instanceof H.ZO){const O=[],i=a;for(const a of i)O.push(a.flatMap((a=>[a.x,a.y,a.z])));return O}if(a instanceof Float32Array){if(null!==O&&void 0!==O&&O.floatArrayStride){const i=[],H=3*O.floatArrayStride;for(let O=0;O<a.length;O+=H){const b=new Array(H);for(let i=0;i<H;i++)b[i]=a[O+i];i.push(b)}return i}return[Array.from(a)]}if(a.length&&a[0]instanceof Float32Array){const O=[];for(const i of a)O.push(Array.from(i));return O}return[]}static OmitZeroLengthPredicate(a,O,i){const H=[];return O.FO(a).lengthSquared()>0&&H.push([a,O]),i.FO(O).lengthSquared()>0&&H.push([O,i]),a.FO(i).lengthSquared()>0&&H.push([i,a]),0===H.length?null:H}static OmitDuplicatesPredicate(a,O,i,H){const b=[];return Ba._SearchInPoints(a,O,H)||b.push([a,O]),Ba._SearchInPoints(O,i,H)||b.push([O,i]),Ba._SearchInPoints(i,a,H)||b.push([i,a]),0===b.length?null:b}static _SearchInPoints(a,O,i){for(const q of i)for(let i=0;i<q.length;i++){var H,b,G;if(null!==(H=q[i])&&void 0!==H&&H.equals(a))if(null!==(b=q[i+1])&&void 0!==b&&b.equals(O)||null!==(G=q[i-1])&&void 0!==G&&G.equals(O))return!0}return!1}static MeshesToLines(a,O){const i=[];for(let b=0;b<a.length;b++){const G=a[b],q=G.getVerticesData(P.c.PositionKind),Q=G.Kb();if(q&&Q)for(let a=0,k=0;a<Q.length;a++){const I=3*Q[k++],P=3*Q[k++],e=3*Q[k++],h=new H.ZO(q[I],q[I+1],q[I+2]),j=new H.ZO(q[P],q[P+1],q[P+2]),Z=new H.ZO(q[e],q[e+1],q[e+2]);if(O){const H=O(h,j,Z,i,a,I,G,b,q,Q);if(H)for(const a of H)i.push(a)}else i.push([h,j],[j,Z],[Z,h])}}return i}static ToVector3Array(a){if(Array.isArray(a[0])){const O=[],i=a;for(const a of i){const i=[];for(let O=0;O<a.length;O+=3)i.push(new H.ZO(a[O],a[O+1],a[O+2]));O.push(i)}return O}const O=a,i=[];for(let b=0;b<O.length;b+=3)i.push(new H.ZO(O[b],O[b+1],O[b+2]));return i}static ToNumberArray(a){return a.flatMap((a=>[a.x,a.y,a.z]))}static GetPointsCountInfo(a){const O=new Array(a.length);let i=0;for(let H=a.length;H--;)O[H]=a[H].length/3,i+=O[H];return{total:i,counts:O}}static GetLineLength(a){if(0===a.length)return 0;let O;O="number"===typeof a[0]?Ba.ToVector3Array(a):a;const i=H.TmpVectors.ZO[0];let b=0;for(let H=0;H<O.length-1;H++){const a=O[H];b+=O[H+1].subtractToRef(a,i).length()}return b}static GetLineLengthArray(a){const O=new Float32Array(a.length/3);let i=0;for(let H=0,b=a.length/3-1;H<b;H++){let b=a[3*H+0],G=a[3*H+1],q=a[3*H+2];b-=a[3*H+3],G-=a[3*H+4],q-=a[3*H+5];i+=Math.sqrt(b*b+G*G+q*q),O[H+1]=i}return O}static SegmentizeSegmentByCount(a,O,i){const b=[],G=O.FO(a),q=H.TmpVectors.ZO[0];q.Tb(i);const Q=H.TmpVectors.ZO[1];G.divideToRef(q,Q);let k=a.clone();b.push(k);for(let H=0;H<i;H++)k=k.clone(),b.push(k.addInPlace(Q));return b}static SegmentizeLineBySegmentLength(a,O){const i=a[0]instanceof H.ZO?Ba.GetLineSegments(a):"number"===typeof a[0]?Ba.GetLineSegments(Ba.ToVector3Array(a)):a,b=[];for(const H of i)if(H.length>O){const a=Ba.SegmentizeSegmentByCount(H.point1,H.point2,Math.ceil(H.length/O));for(const O of a)b.push(O)}else b.push(H.point1),b.push(H.point2);return b}static SegmentizeLineBySegmentCount(a,O){const i="number"===typeof a[0]?Ba.ToVector3Array(a):a,H=Ba.GetLineLength(i)/O;return Ba.SegmentizeLineBySegmentLength(i,H)}static GetLineSegments(a){const O=[];for(let i=0;i<a.length-1;i++){const H=a[i],b=a[i+1],G=b.FO(H).length();O.push({point1:H,point2:b,length:G})}return O}static GetMinMaxSegmentLength(a){const O=Ba.GetLineSegments(a).sort((a=>a.length));return{min:O[0].length,max:O[O.length-1].length}}static GetPositionOnLineByVisibility(a,O,i){let b=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const G=O*i;let q=0,Q=0;const k=a.length;for(let H=0;H<k;H++){if(G<=q+a[H].length){Q=H;break}q+=a[H].length}const I=(G-q)/a[Q].length;return a[Q].point2.subtractToRef(a[Q].point1,H.TmpVectors.ZO[0]),H.TmpVectors.ZO[1]=H.TmpVectors.ZO[0].multiplyByFloats(I,I,I),b||H.TmpVectors.ZO[1].addInPlace(a[Q].point1),H.TmpVectors.ZO[1].clone()}static GetCircleLinePoints(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,b=arguments.length>3&&void 0!==arguments[3]?arguments[3]:a,G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/O;const q=[];for(let Q=0;Q<=O;Q++)q.push(new H.ZO(Math.cos(Q*G)*a,Math.sin(Q*G)*b,i));return q}static GetBezierLinePoints(a,O,i,H){return Sa.g.CreateQuadraticBezier(a,O,i,H).getPoints().flatMap((a=>[a.x,a.y,a.z]))}static GetArrowCap(a,O,i,H,b){let G=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,q=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[a.clone(),a.add(O.multiplyByFloats(i,i,i))],widths:[H,b,G,q]}}static GetPointsFromText(a,O,i,H){let b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,G=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const q=[],Q=(0,fa.c)(a,O,i,H);for(const k of Q){for(const a of k.paths){const O=[],i=a.getPoints();for(const a of i)O.push(a.x,a.y,b);q.push(O)}if(G)for(const a of k.holes){const O=[],i=a.getPoints();for(const a of i)O.push(a.x,a.y,b);q.push(O)}}return q}static Color3toRGBAUint8(a){const O=new Uint8Array(4*a.length);for(let i=0,H=0;i<a.length;i++)O[H++]=255*a[i].r,O[H++]=255*a[i].g,O[H++]=255*a[i].b,O[H++]=255;return O}static CreateColorsTexture(a,O,i,H){const b=H.getEngine().getCaps().maxTextureSize??1,G=O.length>b?b:O.length,q=Math.ceil(O.length/b);q>1&&(O=[...O,...Array(G*q-O.length).fill(O[0])]);const Q=Ba.Color3toRGBAUint8(O),k=new D.d(Q,G,q,Z.b.TEXTUREFORMAT_RGBA,H,!1,!0,i);return k.name=a,k}static PrepareEmptyColorsTexture(a){if(!Ka.EmptyColorsTexture){const O=new Uint8Array(4);Ka.EmptyColorsTexture=new D.d(O,1,1,Z.b.TEXTUREFORMAT_RGBA,a,!1,!1,D.d.NEAREST_NEAREST),Ka.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Ka.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var a;null===(a=Ka.EmptyColorsTexture)||void 0===a||a.dispose(),Ka.EmptyColorsTexture=null}static BooleanToNumber(a){return a?1:0}}class Ta extends ya.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Aa extends Ua.b{isCompatible(a){return!0}constructor(a,O,i){var b;i=i||{color:Ka.DEFAULT_COLOR};const G=new Ta;G.GREASED_LINE_HAS_COLOR=!!i.color&&!i.useColors,G.GREASED_LINE_SIZE_ATTENUATION=i.sizeAttenuation??!1,G.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===i.colorDistributionType,G.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(O??a.Ua()).useRightHandedSystem,G.GREASED_LINE_CAMERA_FACING=i.cameraFacing??!0,super(a,Aa.GREASED_LINE_MATERIAL_NAME,200,G,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(b=i)||void 0===b?void 0:b.forceGLSL)||Aa.ForceGLSL,this._scene=O??a.Ua(),this._engine=this._scene.getEngine(),this._cameraFacing=i.cameraFacing??!0,this.visibility=i.visibility??1,this.useDash=i.useDash??!1,this.dashRatio=i.dashRatio??.5,this.dashOffset=i.dashOffset??0,this.width=i.width?i.width:i.sizeAttenuation?Ka.DEFAULT_WIDTH_ATTENUATED:Ka.DEFAULT_WIDTH,this._sizeAttenuation=i.sizeAttenuation??!1,this.colorMode=i.colorMode??0,this._color=i.color??null,this.useColors=i.useColors??!1,this._colorsDistributionType=i.colorDistributionType??0,this.colorsSampling=i.colorsSampling??D.d.NEAREST_NEAREST,this._colors=i.Sa??null,this.dashCount=i.dashCount??1,this.resolution=i.resolution??new H.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),i.colorsTexture?this.colorsTexture=i.colorsTexture:this._colors?this.colorsTexture=Ba.CreateColorsTexture(`${a.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Ka.DEFAULT_COLOR,Ba.PrepareEmptyColorsTexture(this._scene)),this._engine.Pb.add((()=>{Ba.DisposeEmptyColorsTexture()}))}getAttributes(a){a.push("grl_offsets"),a.push("grl_widths"),a.push("grl_colorPointers"),a.push("grl_counters"),this._cameraFacing?(a.push("grl_previousAndSide"),a.push("grl_nextAndCounters")):a.push("grl_slopes")}getSamplers(a){a.push("grl_colors")}getActiveTextures(a){this.colorsTexture&&a.push(this.colorsTexture)}getUniforms(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const O=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&O.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===a&&O.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:O,vertex:this._cameraFacing&&this._isGLSL(a)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(a)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(a){if(this._cameraFacing){a.Ub("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||a.Ub("viewProjection",this._scene.getTransformMatrix());const O=H.TmpVectors.Vector4[0];O.x=this._aspect,O.y=this._resolution.x,O.z=this._resolution.y,O.w=this.width,a.updateVector4("grl_aspect_resolution_lineWidth",O)}const O=H.TmpVectors.Vector4[0];O.x=Ba.BooleanToNumber(this.useDash),O.y=this._dashArray,O.z=this.dashOffset,O.w=this.dashRatio,a.updateVector4("grl_dashOptions",O);const i=H.TmpVectors.Vector4[1];i.x=this.colorMode,i.y=this.visibility,i.z=this.colorsTexture?this.colorsTexture.getSize().width:0,i.w=Ba.BooleanToNumber(this.useColors),a.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",i),this._color&&a.updateColor3("grl_singleColor",this._color);const b=this.colorsTexture??Ka.EmptyColorsTexture;a.setTexture("grl_colors",b),a.updateFloat2("grl_textureSize",(null===b||void 0===b?void 0:b.getSize().width)??1,(null===b||void 0===b?void 0:b.getSize().height)??1)}prepareDefines(a,O,i){a.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,a.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,a.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,a.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=O.useRightHandedSystem,a.GREASED_LINE_CAMERA_FACING=this._cameraFacing,a.GREASED_LINE_USE_OFFSETS=!!i.offsets}getClassName(){return Aa.GREASED_LINE_MATERIAL_NAME}getCustomCode(a){let O=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(O)?function(a,O){if("vertex"===a){const a={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return O&&(a["!gl_Position\\=viewProjection\\*worldPos;"]="//"),a}return"fragment"===a?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(a,this._cameraFacing):function(a,O){if("vertex"===a){const a={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return O&&(a["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),a}return"fragment"===a?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(a,this._cameraFacing)}dispose(){var a;null===(a=this.colorsTexture)||void 0===a||a.dispose(),super.dispose()}get Sa(){return this._colors}set Sa(a){this.setColors(a)}setColors(a){var O;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var G;if(this._colors=a,null!==a&&0!==a.length){if(!i||H)if(this.colorsTexture&&b===a.length&&!H){const O=Ba.Color3toRGBAUint8(a);this.colorsTexture.update(O)}else{var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=Ba.CreateColorsTexture(`${this._material.name}-colors-texture`,a,this.colorsSampling,this._scene)}}else null===(G=this.colorsTexture)||void 0===G||G.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(a){this._dashCount=a,this._dashArray=1/a}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(a){this._sizeAttenuation=a,this.markAllDefinesAsDirty()}get color(){return this._color}set color(a){this.setColor(a)}setColor(a){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==a||null!==this._color&&null===a?(this._color=a,O||this.markAllDefinesAsDirty()):this._color=a}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(a){this._colorsDistributionType=a,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(a){this._aspect=a.x/a.y,this._resolution=a}serialize(){const a=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(O.Sa=this._colors),this._color&&(O.color=this._color),a.greasedLineMaterialOptions=O,a}parse(a,O,i){var H;super.parse(a,O,i);const b=a.greasedLineMaterialOptions;null===(H=this.colorsTexture)||void 0===H||H.dispose(),b.color&&this.setColor(b.color,!0),b.colorDistributionType&&(this.colorsDistributionType=b.colorDistributionType),b.Sa&&(this.Sa=b.Sa),b.colorsSampling&&(this.colorsSampling=b.colorsSampling),b.colorMode&&(this.colorMode=b.colorMode),b.useColors&&(this.useColors=b.useColors),b.visibility&&(this.visibility=b.visibility),b.useDash&&(this.useDash=b.useDash),b.dashCount&&(this.dashCount=b.dashCount),b.dashRatio&&(this.dashRatio=b.dashRatio),b.dashOffset&&(this.dashOffset=b.dashOffset),b.width&&(this.width=b.width),b.sizeAttenuation&&(this.sizeAttenuation=b.sizeAttenuation),b.resolution&&(this.resolution=b.resolution),this.Sa?this.colorsTexture=Ba.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Sa,this.colorsSampling,O):Ba.PrepareEmptyColorsTexture(O),this.markAllDefinesAsDirty()}copyTo(a){var O;const i=a;null===(O=i.colorsTexture)||void 0===O||O.dispose(),this._colors&&(i.colorsTexture=Ba.CreateColorsTexture(`${i._material.name}-colors-texture`,this._colors,i.colorsSampling,this._scene)),i.setColor(this.color,!0),i.colorsDistributionType=this.colorsDistributionType,i.colorsSampling=this.colorsSampling,i.colorMode=this.colorMode,i.useColors=this.useColors,i.visibility=this.visibility,i.useDash=this.useDash,i.dashCount=this.dashCount,i.dashRatio=this.dashRatio,i.dashOffset=this.dashOffset,i.width=this.width,i.sizeAttenuation=this.sizeAttenuation,i.resolution=this.resolution,i.markAllDefinesAsDirty()}_isGLSL(a){return 0===a||this._forceGLSL}}Aa.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Aa.ForceGLSL=!1,(0,wa.h)(`BABYLON.${Aa.GREASED_LINE_MATERIAL_NAME}`,Aa);var Ea=i(12829),la=i(12211),Wa=i(12646),ua=i(12326);class ca extends Wa.ShaderMaterial{constructor(a,O,b){const G=O.getEngine(),q=G.isWebGPU&&!(b.forceGLSL||ca.ForceGLSL),Q=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];O.useRightHandedSystem&&Q.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const k=["position","grl_widths","grl_offsets","grl_colorPointers"];b.cameraFacing?(Q.push("GREASED_LINE_CAMERA_FACING"),k.push("grl_previousAndSide","grl_nextAndCounters")):(k.push("grl_slopes"),k.push("grl_counters"));const I=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(q||I.push("world","viewProjection","view","projection"),super(a,O,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:q?["Scene","Mesh"]:void 0,attributes:k,uniforms:I,samplers:q?[]:["grlColors"],defines:Q,extraInitializationsAsync:async()=>{q?await Promise.all([i.e(66).then(i.bind(i,15544)),i.e(75).then(i.bind(i,15553))]):await Promise.all([i.e(69).then(i.bind(i,15556)),i.e(76).then(i.bind(i,15560))])},shaderLanguage:q?1:0}),this._color=r.mi.White(),this._colorsDistributionType=0,this._colorsTexture=null,b=b||{color:Ka.DEFAULT_COLOR},this.visibility=b.visibility??1,this.useDash=b.useDash??!1,this.dashRatio=b.dashRatio??.5,this.dashOffset=b.dashOffset??0,this.dashCount=b.dashCount??1,this.width=b.width?b.width:b.sizeAttenuation&&b.cameraFacing?Ka.DEFAULT_WIDTH_ATTENUATED:Ka.DEFAULT_WIDTH,this.sizeAttenuation=b.sizeAttenuation??!1,this.color=b.color??r.mi.White(),this.useColors=b.useColors??!1,this.colorsDistributionType=b.colorDistributionType??0,this.colorsSampling=b.colorsSampling??D.d.NEAREST_NEAREST,this.colorMode=b.colorMode??0,this._colors=b.Sa??null,this._cameraFacing=b.cameraFacing??!0,this.resolution=b.resolution??new H.Vector2(G.getRenderWidth(),G.getRenderHeight()),b.colorsTexture?this.colorsTexture=b.colorsTexture:this._colors?this.colorsTexture=Ba.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,O):(this._color=this._color??Ka.DEFAULT_COLOR,this.colorsTexture=Ba.PrepareEmptyColorsTexture(O)),q){const a=new ua.c;a.setParameters(),a.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",a)}G.Pb.add((()=>{Ba.DisposeEmptyColorsTexture()}))}dispose(){var a;null===(a=this._colorsTexture)||void 0===a||a.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new H.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Sa(){return this._colors}set Sa(a){this.setColors(a)}setColors(a){var O;let i=arguments.length>1&&void 0!==arguments[1]&&arguments[1],H=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const b=(null===(O=this._colors)||void 0===O?void 0:O.length)??0;var G;if(this._colors=a,null!==a&&0!==a.length){if(!i||H)if(this._colorsTexture&&b===a.length&&!H){const O=Ba.Color3toRGBAUint8(a);this._colorsTexture.update(O)}else{var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),this.colorsTexture=Ba.CreateColorsTexture(`${this.name}-colors-texture`,a,this.colorsSampling,this.Ua())}}else null===(G=this._colorsTexture)||void 0===G||G.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(a){this._colorsTexture=a,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(a){this._width=a,this.setFloat("grlWidth",a)}get useColors(){return this._useColors}set useColors(a){this._useColors=a,this.setFloat("grlUseColors",Ba.BooleanToNumber(a))}get colorsSampling(){return this._colorsSampling}set colorsSampling(a){this._colorsSampling=a}get visibility(){return this._visibility}set visibility(a){this._visibility=a,this.setFloat("grlVisibility",a)}get useDash(){return this._useDash}set useDash(a){this._useDash=a,this.setFloat("grlUseDash",Ba.BooleanToNumber(a))}get dashOffset(){return this._dashOffset}set dashOffset(a){this._dashOffset=a,this.setFloat("grlDashOffset",a)}get dashRatio(){return this._dashRatio}set dashRatio(a){this._dashRatio=a,this.setFloat("grlDashRatio",a)}get dashCount(){return this._dashCount}set dashCount(a){this._dashCount=a,this._dashArray=1/a,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(a){this._sizeAttenuation=a,this.setFloat("grlSizeAttenuation",Ba.BooleanToNumber(a))}get color(){return this._color}set color(a){this.setColor(a)}setColor(a){a=a??Ka.DEFAULT_COLOR,this._color=a,this.setColor3("grlColor",a)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(a){this._colorsDistributionType=a,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(a){this._colorMode=a,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(a){this._resolution=a,this.setVector2("grlResolution",a),this.setFloat("grlAspect",a.x/a.y)}serialize(){const a=super.serialize(),O={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(O.Sa=this._colors),a.greasedLineMaterialOptions=O,a}parse(a,O,i){var H;const b=a.greasedLineMaterialOptions;null===(H=this._colorsTexture)||void 0===H||H.dispose(),b.color&&(this.color=b.color),b.colorDistributionType&&(this.colorsDistributionType=b.colorDistributionType),b.colorsSampling&&(this.colorsSampling=b.colorsSampling),b.colorMode&&(this.colorMode=b.colorMode),b.useColors&&(this.useColors=b.useColors),b.visibility&&(this.visibility=b.visibility),b.useDash&&(this.useDash=b.useDash),b.dashCount&&(this.dashCount=b.dashCount),b.dashRatio&&(this.dashRatio=b.dashRatio),b.dashOffset&&(this.dashOffset=b.dashOffset),b.width&&(this.width=b.width),b.sizeAttenuation&&(this.sizeAttenuation=b.sizeAttenuation),b.resolution&&(this.resolution=b.resolution),b.Sa?this.colorsTexture=Ba.CreateColorsTexture(`${this.name}-colors-texture`,b.Sa,this.colorsSampling,this.Ua()):this.colorsTexture=Ba.PrepareEmptyColorsTexture(O),this._cameraFacing=b.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Ra,za,xa;ca.ForceGLSL=!1,function(a){a[a.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",a[a.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Ra||(Ra={})),function(a){a[a.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",a[a.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",a[a.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(za||(za={})),function(a){a[a.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",a[a.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",a[a.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",a[a.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",a[a.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(xa||(xa={}));class ga extends mO.d{constructor(a,O,i){super(a,O,null,null,!1,!1),this.name=a,this._options=i,this._lazy=!1,this._updatable=!1,this._engine=O.getEngine(),this._lazy=i.lazy??!1,this._updatable=i.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=i.colorPointers??[],this._widths=i.widths??new Array(i.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(a){let O=0;for(const H of this._points)O+=H.length;const i=O/3*2-this._widths.length;for(let H=0;H<i;H++)this._widths.push(a)}updateLazy(){var a,O;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(a=this._options.ribbonOptions)||void 0===a?void 0:a.smoothShading),!this.Aa&&this.refreshBoundingInfo(),null===(O=this.greasedLineMaterial)||void 0===O||O.updateLazy()}addPoints(a,O){for(const i of a)this._points.push(i);this._lazy||this.setPoints(this._points,O)}dispose(a){let O=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(a,O)}isLazy(){return this._lazy}get fa(){return this._uvs}set fa(a){this._uvs=a instanceof Float32Array?a:new Float32Array(a),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(a){this.material instanceof ca&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===a||void 0===a?void 0:a.length)>0),this._offsets=a,this._offsetsBuffer?this._offsetsBuffer.update(a):this._createOffsetsBuffer(a)}get widths(){return this._widths}set widths(a){this._widths=a,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(a)}get colorPointers(){return this._colorPointers}set colorPointers(a){this._colorPointers=a,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(a)}get greasedLineMaterial(){var a,O;if(this.material&&this.material instanceof ca)return this.material;const i=null===(a=this.material)||void 0===a||null===(O=a.pluginManager)||void 0===O?void 0:O.getPlugin(Aa.GREASED_LINE_MATERIAL_NAME);return i||void 0}get points(){const a=[];return la.c.DeepCopy(this._points,a),a}setPoints(a,O){this._points=Ba.ConvertPoints(a,(null===O||void 0===O?void 0:O.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==O&&void 0!==O&&O.colorPointers||this._updateColorPointers(),this._setPoints(this._points,O)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,fa:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(a){super.serialize(a),a.type=this.getClassName(),a.lineOptions=this._createLineOptions()}_createVertexBuffers(){let a=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const O=new Ea.d;return O.wa=this._vertexPositions,O.indices=this._indices,O.fa=this._uvs,a&&(O.Ka=[],Ea.d.ComputeNormals(this._vertexPositions,this._indices,O.Ka)),O.Ta(this,this._options.updatable),O}_createOffsetsBuffer(a){const O=this._scene.getEngine(),i=new P.b(O,a,this._updatable,3);this.setVerticesBuffer(i.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=i}}class Na{constructor(a,O){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=a,this.wasAddedByNoopNode=O}getIndicesAccessor(a,O,i,H,b){var G,q,Q,k;return null===(G=this._indicesAccessorMap.get(a))||void 0===G||null===(q=G.get(O))||void 0===q||null===(Q=q.get(i))||void 0===Q||null===(k=Q.get(H))||void 0===k?void 0:k.get(b)}setIndicesAccessor(a,O,i,H,b,G){let q=this._indicesAccessorMap.get(a);q||(q=new Map,this._indicesAccessorMap.set(a,q));let Q=q.get(O);Q||(Q=new Map,q.set(O,Q));let k=Q.get(i);k||(k=new Map,Q.set(i,k));let I=k.get(H);I||(I=new Map,k.set(H,I)),I.set(b,G)}pushExportedNode(a){this._exportedNodes.has(a)||this._exportedNodes.add(a)}getNodesSet(){return this._exportedNodes}getVertexBufferView(a){return this._vertexBufferViewMap.get(a)}setVertexBufferView(a,O){this._vertexBufferViewMap.set(a,O)}setRemappedBufferView(a,O,i){this._remappedBufferView.set(a,new Map),this._remappedBufferView.get(a).set(O,i)}getRemappedBufferView(a,O){var i;return null===(i=this._remappedBufferView.get(a))||void 0===i?void 0:i.get(O)}getVertexAccessor(a,O,i){var H,b;return null===(H=this._vertexAccessorMap.get(a))||void 0===H||null===(b=H.get(O))||void 0===b?void 0:b.get(i)}setVertexAccessor(a,O,i,H){let b=this._vertexAccessorMap.get(a);b||(b=new Map,this._vertexAccessorMap.set(a,b));let G=b.get(O);G||(G=new Map,b.set(O,G)),G.set(i,H)}hasVertexColorAlpha(a){return this._vertexMapColorAlpha.get(a)||!1}setHasVertexColorAlpha(a,O){return this._vertexMapColorAlpha.set(a,O)}getMesh(a){return this._meshMap.get(a)}setMesh(a,O){this._meshMap.set(a,O)}bindMorphDataToMesh(a,O){const i=this._meshMorphTargetMap.get(a)||[];this._meshMorphTargetMap.set(a,i),-1===i.indexOf(O)&&i.push(O)}getMorphTargetsFromMesh(a){return this._meshMorphTargetMap.get(a)}}class va{_ApplyExtension(a,O,i,H){if(i>=O.length)return Promise.resolve(a);const b=H(O[i],a);return b?b.then((async a=>a?await this._ApplyExtension(a,O,i+1,H):null)):this._ApplyExtension(a,O,i+1,H)}_ApplyExtensions(a,O){const i=[];for(const H of va._ExtensionNames)i.push(this._extensions[H]);return this._ApplyExtension(a,i,0,O)}_extensionsPreExportTextureAsync(a,O,i){return this._ApplyExtensions(O,((O,H)=>O.preExportTextureAsync&&O.preExportTextureAsync(a,H,i)))}_extensionsPostExportNodeAsync(a,O,i,H,b){return this._ApplyExtensions(O,((O,G)=>O.postExportNodeAsync&&O.postExportNodeAsync(a,G,i,H,b,this._bufferManager)))}_extensionsPostExportMaterialAsync(a,O,i){return this._ApplyExtensions(O,((O,H)=>O.postExportMaterialAsync&&O.postExportMaterialAsync(a,H,i)))}_extensionsPostExportMaterialAdditionalTextures(a,O,i){const H=[];for(const b of va._ExtensionNames){const G=this._extensions[b];G.postExportMaterialAdditionalTextures&&H.push(...G.postExportMaterialAdditionalTextures(a,O,i))}return H}_extensionsPostExportTextures(a,O,i){for(const H of va._ExtensionNames){const b=this._extensions[H];b.postExportTexture&&b.postExportTexture(a,O,i)}}_extensionsPostExportMeshPrimitive(a){for(const O of va._ExtensionNames){const i=this._extensions[O];i.postExportMeshPrimitive&&i.postExportMeshPrimitive(a,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const a of va._ExtensionNames){const O=this._extensions[a];O.preGenerateBinaryAsync&&await O.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(a){for(const O of va._ExtensionNames){const i=this._extensions[O];i.enabled&&a(i)}}_extensionsOnExporting(){this._forEachExtensions((a=>{var O,i,H;a.wasUsed&&((O=this._glTF).extensionsUsed||(O.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(a.name)&&this._glTF.extensionsUsed.push(a.name),a.required&&((i=this._glTF).extensionsRequired||(i.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(a.name)&&this._glTF.extensionsRequired.push(a.name)),(H=this._glTF).extensions||(H.extensions={}),a.onExporting&&a.onExporting())}))}_loadExtensions(){for(const a of va._ExtensionNames){const O=va._ExtensionFactories[a](this);this._extensions[a]=O}}constructor(){let a=arguments.length>0&&void 0!==arguments[0]?arguments[0]:F.b.LastCreatedScene,O=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${Z.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new u(this),this._extensions={},this._bufferManager=new Pa,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!a)throw new Error("No scene available to export");this._babylonScene=a,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:a=>{var O;return null===a||void 0===a||null===(O=a.Fb)||void 0===O?void 0:O.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...O},this._loadExtensions()}dispose(){for(const a in this._extensions){this._extensions[a].dispose()}}get options(){return this._options}static RegisterExtension(a,O){va.UnregisterExtension(a)&&b.Tools.Warn(`Extension with the name ${a} already exists`),va._ExtensionFactories[a]=O,va._ExtensionNames.push(a)}static UnregisterExtension(a){if(!va._ExtensionFactories[a])return!1;delete va._ExtensionFactories[a];const O=va._ExtensionNames.indexOf(a);return-1!==O&&va._ExtensionNames.splice(O,1),!0}_generateJSON(a,O,i){const H={byteLength:a};return H.byteLength&&(this._glTF.buffers=[H]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.rO=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(H.uri=O+".bin"),i?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(a){const O=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(O.byteLength,a,!0),H=new Blob([O],{type:"application/octet-stream"}),b=a+".gltf",G=a+".bin",q=new I;if(q.files[b]=i,q.files[G]=H,this._imageData)for(const Q in this._imageData)q.files[Q]=new Blob([this._imageData[Q].data],{type:this._imageData[Q].mimeType});return q}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(a){const O=a%4;return 0===O?O:4-O}async generateGLBAsync(a){this._shouldUseGlb=!0;const O=await this._generateBinaryAsync();this._extensionsOnExporting();const i=this._generateJSON(O.byteLength),H=a+".glb";let b,G=i.length;if("undefined"!==typeof TextEncoder){b=(new TextEncoder).encode(i),G=b.length}const q=this._getPadding(G),Q=this._getPadding(O.byteLength),k=28+G+q+O.byteLength+Q,P=new ka(k);if(P.writeUInt32(1179937895),P.writeUInt32(2),P.writeUInt32(k),P.writeUInt32(G+q),P.writeUInt32(1313821514),b)P.writeTypedArray(b);else{const a="_".charCodeAt(0);for(let O=0;O<G;++O){const H=i.charCodeAt(O);H!=i.codePointAt(O)?P.writeUInt8(a):P.writeUInt8(H)}}for(let I=0;I<q;++I)P.writeUInt8(32);P.writeUInt32(O.byteLength+Q),P.writeUInt32(5130562),P.writeTypedArray(O);for(let I=0;I<Q;++I)P.writeUInt8(0);const e=new I;return e.files[H]=new Blob([P.getOutputData()],{type:"application/octet-stream"}),e}_setNodeTransformation(a,O,i){if(O.getPivotPoint().equalsWithEpsilon(g,x.e)||b.Tools.Warn("Pivot points are not supported in the glTF serializer"),!O.position.equalsWithEpsilon(g,x.e)){const b=H.TmpVectors.ZO[0].q(O.position);i&&s(b),a.translation=b.Cb()}O.Bb.equalsWithEpsilon(v,x.e)||(a.scale=O.Bb.Cb());const G=O.rotationQuaternion||H.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);G.equalsWithEpsilon(N,x.e)||(i&&t(G),a.rotation=G.normalize().Cb())}_setCameraTransformation(a,O,i){if(!O.position.equalsWithEpsilon(g,x.e)){const b=H.TmpVectors.ZO[0].q(O.position);i&&s(b),a.translation=b.Cb()}const b=O.rotationQuaternion||H.Quaternion.FromEulerAngles(O.rotation.x,O.rotation.y,O.rotation.z);i&&t(b),this._babylonScene.useRightHandedSystem||V(b),b.equalsWithEpsilon(N,x.e)||(a.rotation=b.Cb())}_listAvailableCameras(){for(const a of this._babylonScene.cameras){const O={type:a.mode===ha.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(a.name&&(O.name=a.name),"perspective"===O.type)O.perspective={aspectRatio:a.getEngine().getAspectRatio(a),yfov:a.fovMode===ha.e.FOVMODE_VERTICAL_FIXED?a.fov:a.fov*a.getEngine().getAspectRatio(a),znear:a.Db,zfar:a.maxZ};else if("orthographic"===O.type){const i=a.orthoLeft&&a.orthoRight?.5*(a.orthoRight-a.orthoLeft):.5*a.getEngine().getRenderWidth(),H=a.orthoBottom&&a.orthoTop?.5*(a.orthoTop-a.orthoBottom):.5*a.getEngine().getRenderHeight();O.orthographic={xmag:i,ymag:H,znear:a.Db,zfar:a.maxZ}}this._camerasMap.set(a,O)}}_exportAndAssignCameras(){const a=Array.from(this._camerasMap.values());for(const O of a){const a=this._nodesCameraMap.get(O);if(void 0!==a){this._cameras.push(O);for(const O of a)O.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const a of this._babylonScene.skeletons){if(a.bones.length<=0)continue;const O={joints:[]};this._skinMap.set(a,O)}}_exportAndAssignSkeletons(){for(const a of this._babylonScene.skeletons){if(a.bones.length<=0)continue;const O=this._skinMap.get(a);if(void 0==O)continue;const i={},H=[];let G=-1;for(let b=0;b<a.bones.length;++b){const O=a.bones[b],H=O.getIndex()??b;-1!==H&&(i[H]=O,H>G&&(G=H))}for(let a=0;a<=G;++a){const G=i[a];H.push(G.getAbsoluteInverseBindMatrix());const q=G.getTransformNode();if(null!==q){const a=this._nodeMap.get(q);q&&null!==a&&void 0!==a?O.joints.push(a):b.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else b.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const q=this._nodesSkinMap.get(O);if(O.joints.length>0&&void 0!==q){const a=64*H.length,i=new Float32Array(a/4);H.forEach(((a,O)=>{i.set(a.m,16*O)}));const b=this._bufferManager.createBufferView(i);this._accessors.push(this._bufferManager.createAccessor(b,"MAT4",5126,H.length)),O.inverseBindMatrices=this._accessors.length-1,this._skins.push(O);for(const O of q)O.skin=this._skins.length-1}}}async _exportSceneAsync(){const a={nodes:[]};if(this._babylonScene.metadata){const O=this._options.metadataSelector(this._babylonScene.metadata);O&&(a.extras=O)}const O=new Array,i=new Array,H=new Array;for(const Q of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&qa(Q,this._babylonScene.useRightHandedSystem)?H.push(...Q.getChildren()):this._babylonScene.useRightHandedSystem?O.push(Q):i.push(Q);this._listAvailableCameras(),this._listAvailableSkeletons();const b=new Na(!0,!1);a.nodes.push(...await this._exportNodesAsync(i,b));const G=new Na(!1,!1);a.nodes.push(...await this._exportNodesAsync(O,G));const q=new Na(!1,!0);a.nodes.push(...await this._exportNodesAsync(H,q)),a.nodes.length&&this._scenes.push(a),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Ca._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(a){let O=this._shouldExportNodeMap.get(a);return void 0===O&&(O=this._options.shouldExportNode(a),this._shouldExportNodeMap.set(a,O)),O}async _exportNodesAsync(a,O){const i=new Array;this._exportBuffers(a,O);for(const H of a)await this._exportNodeAsync(H,i,O);return i}_collectBuffers(a,O,i,H,b){if(this._shouldExportNode(a)&&a instanceof h.e&&a.wb){const G=a.wb.getVertexBuffers();if(G)for(const H in G){if(!d(H))continue;const q=G[H];b.setHasVertexColorAlpha(q,a.hasVertexAlpha);const Q=q._buffer,k=O.get(Q)||[];O.set(Q,k),-1===k.indexOf(q)&&k.push(q);const I=i.get(q)||[];i.set(q,I),-1===I.indexOf(a)&&I.push(a)}const q=a.morphTargetManager;if(q)for(let O=0;O<q.numTargets;O++){const i=q.getTarget(O),b=H.get(i)||[];H.set(i,b),-1===b.indexOf(a)&&b.push(a)}}for(const G of a.getChildren())this._collectBuffers(G,O,i,H,b)}_exportBuffers(a,O){const i=new Map,H=new Map,b=new Map;for(const Q of a)this._collectBuffers(Q,i,H,b,O);const G=Array.from(i.keys());for(const Q of G){const a=Q.getData();if(!a)throw new Error("Buffer data is not available");const b=i.get(Q);if(!b)continue;const G=b[0].byteStride;if(b.some((a=>a.byteStride!==G)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const q=ia(a).slice();for(const O of b){const a=H.get(O),{byteOffset:i,byteStride:b,componentCount:G,type:Q,count:k,normalized:I,kind:e}=p(O,a);switch(e){case P.c.NormalKind:case P.c.TangentKind:(0,c.f)(q,i,b,G,Q,k,I,(a=>{const O=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);if(O>0){const i=1/O;a[0]*=i,a[1]*=i,a[2]*=i}}));break;case P.c.ColorKind:{const O=a.filter((a=>a.material instanceof Fa.JO||null==a.material)).length;if(0==O)break;if(O!=a.length){R.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}Q==P.c.UNSIGNED_BYTE&&R.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const H=new r.mi,e=new r.Ab,h=this._babylonScene.getEngine().useExactSrgbConversions;(0,c.f)(q,i,b,G,Q,k,I,(a=>{3===a.length?(H.hi(a,0),H.toLinearSpaceToRef(H,h),H.toArray(a,0)):(e.hi(a,0),e.toLinearSpaceToRef(e,h),e.toArray(a,0))}))}}}if(O.convertToRightHanded){for(const a of b){const O=H.get(a),{byteOffset:i,byteStride:b,componentCount:G,type:Q,count:k,normalized:I,kind:e}=p(a,O);switch(e){case P.c.PositionKind:case P.c.NormalKind:case P.c.TangentKind:(0,c.f)(q,i,b,G,Q,k,I,(a=>{a[0]=-a[0]}))}}O.convertedToRightHandedBuffers.set(Q,q)}const k=this._bufferManager.createBufferView(q,G);O.setVertexBufferView(Q,k);const I=new Map;for(const O of b){const a=H.get(O),{kind:i,totalVertices:b}=p(O,a);switch(i){case P.c.MatricesIndicesKind:case P.c.MatricesIndicesExtraKind:if(O.type==P.c.FLOAT){const a=O.getFloatData(b);null!==a&&I.set(O,a)}}}0!==I.size&&R.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const e=Array.from(I.keys());for(const i of e){const a=I.get(i);if(!a)continue;const H=a.some((a=>a>=256)),b=new(H?Uint16Array:Uint8Array)(a.length);for(let O=0;O<a.length;O++)b[O]=a[O];const G=this._bufferManager.createBufferView(b,4*(H?2:1));O.setRemappedBufferView(Q,i,G)}}const q=Array.from(b.keys());for(const Q of q){const a=b.get(Q);if(!a)continue;const i=na(Q,a[0],this._bufferManager,this._bufferViews,this._accessors,O.convertToRightHanded);for(const H of a)O.bindMorphDataToMesh(H,i)}}async _exportNodeAsync(a,O,i){let H=this._nodeMap.get(a);if(void 0!==H)return void(O.includes(H)||O.push(H));const b=await this._createNodeAsync(a,i);if(b){H=this._nodes.length,this._nodes.push(b),this._nodeMap.set(a,H),i.pushExportedNode(a),O.push(H);const G={name:"runtime animations",channels:[],samplers:[]},q=[];this._babylonScene.animationGroups.length||(Ca._CreateMorphTargetAnimationFromMorphTargetAnimations(a,G,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation),a.animations.length&&Ca._CreateNodeAnimationFromNodeAnimations(a,G,q,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,i.convertToRightHanded,this._options.shouldExportAnimation)),G.channels.length&&G.samplers.length&&this._animations.push(G),q.forEach((a=>{a.channels.length&&a.samplers.length&&this._animations.push(a)}))}const G=b?[]:O;for(const q of a.getChildren())await this._exportNodeAsync(q,G,i);b&&G.length&&(b.children=G)}async _createNodeAsync(a,O){if(!this._shouldExportNode(a))return null;const i={};if(a.name&&(i.name=a.name),a.metadata){const O=this._options.metadataSelector(a.metadata);O&&(i.extras=O)}if(a instanceof e.d&&(this._setNodeTransformation(i,a,O.convertToRightHanded),a instanceof h.e)){const b=a instanceof j.b?a.sourceMesh:a;if(b.Mb&&b.Mb.length>0&&(i.mesh=await this._exportMeshAsync(b,O)),a.skeleton){const O=this._skinMap.get(a.skeleton);var H;if(void 0!==O)void 0===this._nodesSkinMap.get(O)&&this._nodesSkinMap.set(O,[]),null===(H=this._nodesSkinMap.get(O))||void 0===H||H.push(i)}}if(a instanceof z.c){const H=this._camerasMap.get(a);if(H){var b;void 0===this._nodesCameraMap.get(H)&&this._nodesCameraMap.set(H,[]),this._setCameraTransformation(i,a,O.convertToRightHanded);const q=a.parent;if(null!==q&&Oa(a,q)){const a=this._nodeMap.get(q);if(void 0!==a){var G;const O=this._nodes[a];return aa(i,O),null===(G=this._nodesCameraMap.get(H))||void 0===G||G.push(O),null}}null===(b=this._nodesCameraMap.get(H))||void 0===b||b.push(i)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",i,a,this._nodeMap,O.convertToRightHanded)?i:(R.c.Warn(`Not exporting node ${a.name}`),null)}_exportIndices(a,O,i,H,b,q,Q,k,I){let P=a;I.mode=Y(q);const e=Q!==G.b.CounterClockWiseSideOrientation,h=!k.wasAddedByNoopNode&&e,j=function(a){switch(a){case G.b.TriangleFillMode:case G.b.TriangleStripDrawMode:case G.b.TriangleFanDrawMode:return!0}return!1}(q)&&h;if(j){if(q===G.b.TriangleStripDrawMode||q===G.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");I.mode=Y(q);const Q=O?new Uint32Array(H):new Uint16Array(H);if(a)for(let O=0;O+2<H;O+=3)Q[O]=a[i+O]+b,Q[O+1]=a[i+O+2]+b,Q[O+2]=a[i+O+1]+b;else for(let a=0;a+2<H;a+=3)Q[a]=a,Q[a+1]=a+2,Q[a+2]=a+1;P=Q}else if(a&&0!==b){const G=O?new Uint32Array(H):new Uint16Array(H);for(let O=0;O<H;O++)G[O]=a[i+O]+b;P=G}if(P){let G=k.getIndicesAccessor(a,i,H,b,j);if(void 0===G){const q=function(a,O,i,H){if(a instanceof Uint16Array||a instanceof Uint32Array)return a;if(a instanceof Int32Array)return new Uint32Array(a.buffer,a.byteOffset,a.length);const b=a.slice(O,O+i);return H?new Uint32Array(b):new Uint16Array(b)}(P,0,H,O),Q=this._bufferManager.createBufferView(q),I=O?5125:5123;this._accessors.push(this._bufferManager.createAccessor(Q,"SCALAR",I,H,0)),G=this._accessors.length-1,k.setIndicesAccessor(a,i,H,b,j,G)}I.indices=G}}_exportVertexBuffer(a,O,i,H,b,G){const q=a.getKind();if(!d(q))return;if(q.startsWith("uv")&&!this._options.exportUnusedUVs&&(!O||!this._materialNeedsUVsSet.has(O)))return;let Q=b.getVertexAccessor(a,i,H);if(void 0===Q){const O=b.convertedToRightHandedBuffers.get(a._buffer)||a._buffer.getData(),G=q===P.c.PositionKind?function(a,O,i,H){const{byteOffset:b,byteStride:G,type:q,normalized:Q}=O,k=O.getSize(),I=new Array(k).fill(1/0),P=new Array(k).fill(-1/0);return(0,c.f)(a,b+i*G,G,k,q,H*k,Q,(a=>{for(let O=0;O<k;O++)I[O]=Math.min(I[O],a[O]),P[O]=Math.max(P[O],a[O])})),{min:I,max:P}}(O,a,i,H):void 0,k=(q===P.c.MatricesIndicesKind||q===P.c.MatricesIndicesExtraKind)&&a.type===P.c.FLOAT,I=k?P.c.UNSIGNED_BYTE:a.type,e=k?void 0:a.normalized,h=k?b.getRemappedBufferView(a._buffer,a):b.getVertexBufferView(a._buffer),j=a.byteOffset+i*a.byteStride;this._accessors.push(this._bufferManager.createAccessor(h,function(a,O){if(a==P.c.ColorKind)return O?"VEC4":"VEC3";switch(a){case P.c.PositionKind:case P.c.NormalKind:return"VEC3";case P.c.TangentKind:case P.c.MatricesIndicesKind:case P.c.MatricesIndicesExtraKind:case P.c.MatricesWeightsKind:case P.c.MatricesWeightsExtraKind:return"VEC4";case P.c.UVKind:case P.c.UV2Kind:case P.c.UV3Kind:case P.c.UV4Kind:case P.c.UV5Kind:case P.c.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${a}`)}(q,b.hasVertexColorAlpha(a)),I,H,j,G,e)),Q=this._accessors.length-1,b.setVertexAccessor(a,i,H,Q)}G.attributes[function(a){switch(a){case P.c.PositionKind:return"POSITION";case P.c.NormalKind:return"NORMAL";case P.c.TangentKind:return"TANGENT";case P.c.ColorKind:return"COLOR_0";case P.c.UVKind:return"TEXCOORD_0";case P.c.UV2Kind:return"TEXCOORD_1";case P.c.UV3Kind:return"TEXCOORD_2";case P.c.UV4Kind:return"TEXCOORD_3";case P.c.UV5Kind:return"TEXCOORD_4";case P.c.UV6Kind:return"TEXCOORD_5";case P.c.MatricesIndicesKind:return"JOINTS_0";case P.c.MatricesIndicesExtraKind:return"JOINTS_1";case P.c.MatricesWeightsKind:return"WEIGHTS_0";case P.c.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${a}`)}(q)]=Q}async _exportMaterialAsync(a,O,i,H){let b=this._materialMap.get(a);if(void 0===b){const H=O&&Object.keys(O).some((a=>a.startsWith("uv")));if((a=a instanceof ja.e?a.Eb[i.materialIndex]:a)instanceof Za.e)b=await this._materialExporter.exportPBRMaterialAsync(a,"image/png",H);else{if(!(a instanceof Fa.JO))return void R.c.Warn(`Unsupported material '${a.name}' with type ${a.getClassName()}`);b=await this._materialExporter.exportStandardMaterialAsync(a,"image/png",H)}this._materialMap.set(a,b)}H.material=b}async _exportMeshAsync(a,O){var i;let H=O.getMesh(a);if(void 0!==H)return H;const b={primitives:[]};H=this._meshes.length,this._meshes.push(b),O.setMesh(a,H);const q=a.isUnIndexed?null:a.Kb(),Q=null===(i=a.wb)||void 0===i?void 0:i.getVertexBuffers(),k=O.getMorphTargetsFromMesh(a),I=a instanceof Da.e,P=a instanceof ga,e=a.Mb;if(Q&&e&&e.length>0)for(const Z of e){const i={attributes:{}},H=Z.ua()||this._babylonScene.defaultMaterial;if(P){var h,j;const O={name:H.name},b=a,G=r.mi.White(),q=(null===(h=b.material)||void 0===h?void 0:h.alpha)??1,Q=(null===(j=b.greasedLineMaterial)||void 0===j?void 0:j.color)??G;(!Q.equalsWithEpsilon(G,x.e)||q<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...Q.Cb(),q]}),this._materials.push(O),i.material=this._materials.length-1}else if(I){const O={name:H.name},b=a;(!b.color.equalsWithEpsilon(r.mi.White(),x.e)||b.alpha<1)&&(O.pbrMetallicRoughness={baseColorFactor:[...b.color.Cb(),b.alpha]}),this._materials.push(O),i.material=this._materials.length-1}else await this._exportMaterialAsync(H,Q,Z,i);const e=I||P?G.b.LineListDrawMode:a.overrideRenderingFillMode??H.fillMode,F=H._getEffectiveOrientation(a);this._exportIndices(q,q?(0,c.b)(q,Z.indexCount,Z.indexStart,Z.verticesStart):Z.verticesCount>65535,q?Z.indexStart:Z.verticesStart,q?Z.indexCount:Z.verticesCount,-Z.verticesStart,e,F,O,i);for(const a of Object.values(Q))this._exportVertexBuffer(a,H,Z.verticesStart,Z.verticesCount,O,i);if(k){i.targets=[];for(const a of k)i.targets.push(a.attributes)}b.primitives.push(i),this._extensionsPostExportMeshPrimitive(i)}if(k){b.weights=[],b.extras||(b.extras={}),b.extras.targetNames=[];for(const a of k)b.weights.push(a.influence),b.extras.targetNames.push(a.name)}return H}}va._ExtensionNames=new Array,va._ExtensionFactories={};class Xa{static async GLTFAsync(a,O,i){i&&i.exportWithoutWaitingForScene||await a.whenReadyAsync();const H=new va(a,i),b=await H.generateGLTFAsync(O.replace(/\.[^/.]+$/,""));return H.dispose(),b}static async GLBAsync(a,O,i){i&&i.exportWithoutWaitingForScene||await a.whenReadyAsync();const H=new va(a,i),b=await H.generateGLBAsync(O.replace(/\.[^/.]+$/,""));return H.dispose(),b}}i(12961);const pa="EXT_mesh_gpu_instancing";class oa{constructor(a){this.name=pa,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(a,O,i,b,G,q){return await new Promise((a=>{if(O&&i instanceof mO.d&&i.hasThinInstances&&this._exporter){this._wasUsed=!0;const a=H.ZO.Zero(),b=H.Quaternion.Identity(),Q=H.ZO.One(),k=i.thinInstanceGetWorldMatrices(),I=H.TmpVectors.ZO[2],P=H.TmpVectors.Quaternion[1],e=H.TmpVectors.ZO[3];let h=!1,j=!1,Z=!1;const F=new Float32Array(3*i.lb),r=new Float32Array(4*i.lb),J=new Float32Array(3*i.lb);let ma=0;for(const O of k)O.decompose(e,P,I),G&&(s(I),t(P)),F.set(I.Cb(),3*ma),r.set(P.normalize().Cb(),4*ma),J.set(e.Cb(),3*ma),h=h||!I.equalsWithEpsilon(a),j=j||!P.equalsWithEpsilon(b),Z=Z||!e.equalsWithEpsilon(Q),ma++;const M={attributes:{}};h&&(M.attributes.TRANSLATION=this._buildAccessor(F,"VEC3",i.lb,q)),j&&(M.attributes.ROTATION=this._buildAccessor(r,"VEC4",i.lb,q)),Z&&(M.attributes.SCALE=this._buildAccessor(J,"VEC3",i.lb,q)),O.extensions=O.extensions||{},O.extensions[pa]=M}a(O)}))}_buildAccessor(a,O,i,H){const b=H.createBufferView(a),G=H.createAccessor(b,O,5126,i);return this._exporter._accessors.push(G),this._exporter._accessors.length-1}}va.RegisterExtension(pa,(a=>new oa(a)));var da=i(12966),Ya=i(12982),La=i(12985),sa=i(12988);function ta(a){return a===La.c.PositionKind?"POSITION":a===La.c.NormalKind?"NORMAL":a===La.c.ColorKind?"COLOR":a.startsWith(La.c.UVKind)?"TEX_COORD":"GENERIC"}const Va={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class aO extends da.c{static get DefaultAvailable(){return(0,da.e)(aO.DefaultConfiguration)}static get Default(){return aO._Default??(aO._Default=new aO),aO._Default}static ResetDefault(a){aO._Default&&(a||aO._Default.dispose(),aO._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(a,O){return{module:await(O||DracoEncoderModule)({wasmBinary:a})}}_getWorkerContent(){return`${Ya.g}(${Ya.i})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:aO.DefaultConfiguration)}async _encodeAsync(a,O,i){const H=i?(0,sa.c)(Va,i):Va;if(this._workerPoolPromise){const i=await this._workerPoolPromise;return await new Promise(((b,G)=>{i.push(((i,q)=>{const Q=a=>{i.removeEventListener("error",Q),i.removeEventListener("message",k),G(a),q()},k=a=>{"encodeMeshDone"===a.data.id&&(i.removeEventListener("error",Q),i.removeEventListener("message",k),b(a.data.encodedMeshData),q())};i.addEventListener("error",Q),i.addEventListener("message",k);const I=[];for(const O of a)I.push(O.data.buffer);O&&I.push(O.buffer),i.postMessage({id:"encodeMesh",attributes:a,indices:O,options:H},I)}))}))}if(this._modulePromise){const i=await this._modulePromise;return(0,Ya.g)(i.module,a,O,H)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(a,O){if(0==a.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");a instanceof mO.d&&a.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===O||void 0===O?void 0:O.method)&&(R.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),O.method="MESH_SEQUENTIAL_ENCODING");const i=function(a){let O=a.Kb(void 0,!0);return!O||O instanceof Uint32Array||O instanceof Uint16Array||(O=((0,c.b)(O,O.length)?Uint32Array:Uint16Array).from(O)),O}(a),H=function(a,O){const i=[];for(const H of a.getVerticesDataKinds()){if(null!==O&&void 0!==O&&O.includes(H)){if(H===La.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const b=a.getVertexBuffer(H),G=b.getSize(),q=(0,c.n)(b.getData(),G,b.type,b.byteOffset,b.byteStride,b.normalized,a.getTotalVertices(),!0);i.push({kind:H,dracoName:ta(H),size:G,data:q})}return i}(a,null===O||void 0===O?void 0:O.excludedAttributes);return await this._encodeAsync(H,i,O)}}aO.DefaultConfiguration={wasmUrl:`${b.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${b.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${b.Tools._DefaultCdnUrl}/draco_encoder.js`},aO._Default=null;const OO="KHR_draco_mesh_compression";class iO{get wasUsed(){return this._wasUsed}constructor(a){this.name=OO,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===a.options.meshCompressionMethod&&aO.DefaultAvailable}dispose(){}postExportMeshPrimitive(a,O,i){if(!this.enabled)return;if(4!==a.mode&&5!==a.mode)return void R.c.Warn("Cannot compress primitive with mode "+a.mode+".");const H=[],b=[];let G=null;if(void 0!==a.indices){const q=i[a.indices],Q=O.getBufferView(q);G=O.getData(Q).slice(),H.push(Q),b.push(q)}const q=[];for(const[P,e]of Object.entries(a.attributes)){const a=i[e],G=O.getBufferView(a),k=o(a.type),I=(0,c.n)(O.getData(G),k,a.componentType,a.byteOffset||0,G.byteStride||(0,c.l)(a.componentType)*k,a.normalized||!1,a.count,!0);q.push({kind:P,dracoName:(Q=P,"POSITION"===Q?"POSITION":"NORMAL"===Q?"NORMAL":Q.startsWith("COLOR")?"COLOR":Q.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:o(a.type),data:I}),H.push(G),b.push(a)}var Q;const k={method:a.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},I=aO.Default._encodeAsync(q,G,k).then((i=>{if(!i)return void R.c.Error("Draco encoding failed for primitive.");const G={bufferView:-1,attributes:i.attributeIds},q=O.createBufferView(i.data);O.setBufferView(G,q);for(const a of H)this._bufferViewsUsed.add(a);for(const a of b)this._accessorsUsed.add(a);a.extensions||(a.extensions={}),a.extensions[OO]=G})).catch((a=>{R.c.Error("Draco encoding failed for primitive: "+a)}));this._encodePromises.push(I),this._wasUsed=!0}async preGenerateBinaryAsync(a){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((O=>{a.getPropertiesWithBufferView(O).every((a=>this._accessorsUsed.has(a)))&&a.removeBufferView(O)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}va.RegisterExtension(OO,(a=>new iO(a)));var HO=i(12994);const bO="KHR_lights_punctual",GO={name:"",color:[1,1,1],Wb:1,range:Number.MAX_VALUE},qO={innerConeAngle:0,outerConeAngle:Math.PI/4},QO=H.ZO.Backward();class kO{constructor(a){this.name=bO,this.enabled=!0,this.required=!1,this._exporter=a}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[bO]=this._lights}async postExportNodeAsync(a,O,i,b,G){return await new Promise((q=>{if(!(i instanceof Ma.b))return void q(O);const Q=i.getTypeID()==Ma.b.LIGHTTYPEID_POINTLIGHT?"point":i.getTypeID()==Ma.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":i.getTypeID()==Ma.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!Q||!(i instanceof HO.c))return R.c.Warn(`${a}: Light ${i.name} is not supported in ${bO}`),void q(O);if(i.falloffType!==Ma.b.FALLOFF_GLTF&&R.c.Warn(`${a}: Light falloff for ${i.name} does not match the ${bO} specification!`),!i.position.equalsToFloats(0,0,0)){const a=H.TmpVectors.ZO[0].q(i.position);G&&s(a),O.translation=a.Cb()}if("point"!==Q){const a=i.direction.normalizeToRef(H.TmpVectors.ZO[0]);G&&s(a);const b=H.Quaternion.FromUnitVectorsToRef(QO,a,H.TmpVectors.Quaternion[0]);H.Quaternion.IsIdentity(b)||(O.rotation=b.Cb())}const k={type:Q,name:i.name,color:i.ub.Cb(),Wb:i.Wb,range:i.range};if(Ha(k,GO),"spot"===Q){const a=i;k.spot={innerConeAngle:a.innerAngle/2,outerConeAngle:a.angle/2},Ha(k.spot,qO)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(k);const I={bb:this._lights.lights.length-1},P=i.parent;if(P&&Oa(i,P)){const a=b.get(P);if(a){const i=this._exporter._nodes[a];return aa(O,i),i.extensions||(i.extensions={}),i.extensions[bO]=I,void q(null)}}O.extensions||(O.extensions={}),O.extensions[bO]=I,q(O)}))}}va.RegisterExtension(bO,(a=>new kO(a)));var IO=i(12901);const PO="KHR_materials_anisotropy";class eO{constructor(a){this.name=PO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof IO.d&&i.anisotropy.isEnabled&&!i.anisotropy.legacy?(i.anisotropy.texture&&H.push(i.anisotropy.texture),H):[]}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof IO.d){if(!i.anisotropy.isEnabled||i.anisotropy.legacy)return void a(O);this._wasUsed=!0,O.extensions=O.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(i.anisotropy.texture),b={anisotropyStrength:i.anisotropy.Wb,anisotropyRotation:i.anisotropy.angle,anisotropyTexture:H??void 0};null!==b.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(i),O.extensions[PO]=b}a(O)}))}}va.RegisterExtension(PO,(a=>new eO(a)));const hO="KHR_materials_clearcoat";class jO{constructor(a){this.name=hO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof IO.d&&i.clearCoat.isEnabled?(i.clearCoat.texture&&H.push(i.clearCoat.texture),!i.clearCoat.useRoughnessFromMainTexture&&i.clearCoat.textureRoughness&&H.push(i.clearCoat.textureRoughness),i.clearCoat.bumpTexture&&H.push(i.clearCoat.bumpTexture),H):[]}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof IO.d){if(!i.clearCoat.isEnabled)return void a(O);this._wasUsed=!0,O.extensions=O.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture);let G;G=i.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(i.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(i.clearCoat.textureRoughness),i.clearCoat.isTintEnabled&&b.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${i.name}`),i.clearCoat.remapF0OnInterfaceChange&&b.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${i.name}`);const q=this._exporter._materialExporter.getTextureInfo(i.clearCoat.bumpTexture),Q={clearcoatFactor:i.clearCoat.Wb,clearcoatTexture:H??void 0,clearcoatRoughnessFactor:i.clearCoat.roughness,clearcoatRoughnessTexture:G??void 0,clearcoatNormalTexture:q??void 0};null===Q.clearcoatTexture&&null===Q.clearcoatRoughnessTexture&&null===Q.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),O.extensions[hO]=Q}a(O)}))}}va.RegisterExtension(hO,(a=>new jO(a)));const ZO="KHR_materials_diffuse_transmission";function FO(a,O){const i=O.subSurface;let H=null;return i.translucencyIntensityTexture?H=i.translucencyIntensityTexture:i.thicknessTexture&&i.useMaskFromThicknessTexture&&(H=i.thicknessTexture),H&&!i.useGltfStyleTextures?(R.c.Warn(`${a}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${O.name}`,1),null):H}class rO{constructor(a){this.name=ZO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];if(i instanceof Za.e&&this._isExtensionEnabled(i)){const O=FO(a,i);return O&&H.push(O),i.subSurface.translucencyColorTexture&&H.push(i.subSurface.translucencyColorTexture),H}return H}_isExtensionEnabled(a){if(a.unlit)return!1;const O=a.subSurface;return!!O.isTranslucencyEnabled&&(!a.unlit&&!O.useAlbedoToTintTranslucency&&O.useGltfStyleTextures&&1===O.volumeIndexOfRefraction&&0===O.minimumThickness&&0===O.maximumThickness)}postExportMaterialAsync(a,O,i){return new Promise((H=>{if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const H=i.subSurface,b=FO(a,i),G=0==H.translucencyIntensity?void 0:H.translucencyIntensity,q=this._exporter._materialExporter.getTextureInfo(b)??void 0,Q=!H.translucencyColor||H.translucencyColor.equalsFloats(1,1,1)?void 0:H.translucencyColor.Cb(),k=this._exporter._materialExporter.getTextureInfo(H.translucencyColorTexture)??void 0,I={diffuseTransmissionFactor:G,diffuseTransmissionTexture:q,diffuseTransmissionColorFactor:Q,diffuseTransmissionColorTexture:k};(q||k)&&this._exporter._materialNeedsUVsSet.add(i),O.extensions=O.extensions||{},O.extensions[ZO]=I}H(O)}))}}va.RegisterExtension(ZO,(a=>new rO(a)));const JO="KHR_materials_dispersion";class mi{constructor(){this.name=JO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(a){if(a.unlit)return!1;const O=a.subSurface;return!(!O.isRefractionEnabled&&!O.isDispersionEnabled)}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const a={dispersion:i.subSurface.dispersion};O.extensions=O.extensions||{},O.extensions[JO]=a}a(O)}))}}va.RegisterExtension(JO,(()=>new mi));const MO="KHR_materials_emissive_strength";class CO{constructor(){this.name=MO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(a,O,i){return await new Promise((a=>{if(!(i instanceof Za.e))return a(O);const H=i.emissiveColor.Cb(),b=Math.max(...H);if(b>1){this._wasUsed=!0,O.extensions||(O.extensions={});const a={emissiveStrength:b},H=i.emissiveColor.scale(1/a.emissiveStrength);O.emissiveFactor=H.Cb(),O.extensions[MO]=a}return a(O)}))}}va.RegisterExtension(MO,(a=>new CO));const nO="KHR_materials_ior";class DO{constructor(){this.name=nO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(a){return!a.unlit&&(void 0!=a.indexOfRefraction&&1.5!=a.indexOfRefraction)}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const a={ior:i.indexOfRefraction};O.extensions=O.extensions||{},O.extensions[nO]=a}a(O)}))}}va.RegisterExtension(nO,(a=>new DO));const UO="KHR_materials_iridescence";class yO{constructor(a){this.name=UO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof IO.d&&i.iridescence.isEnabled?(i.iridescence.texture&&H.push(i.iridescence.texture),i.iridescence.thicknessTexture&&i.iridescence.thicknessTexture!==i.iridescence.texture&&H.push(i.iridescence.thicknessTexture),H):[]}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof IO.d){if(!i.iridescence.isEnabled)return void a(O);this._wasUsed=!0,O.extensions=O.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(i.iridescence.texture),b=this._exporter._materialExporter.getTextureInfo(i.iridescence.thicknessTexture),G={iridescenceFactor:i.iridescence.Wb,iridescenceIor:i.iridescence.indexOfRefraction,iridescenceThicknessMinimum:i.iridescence.minimumThickness,iridescenceThicknessMaximum:i.iridescence.maximumThickness,iridescenceTexture:H??void 0,iridescenceThicknessTexture:b??void 0};null===G.iridescenceTexture&&null===G.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(i),O.extensions[UO]=G}a(O)}))}}va.RegisterExtension(UO,(a=>new yO(a)));const wO="KHR_materials_sheen";class KO{constructor(a){this.name=wO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){return i instanceof Za.e&&i.sheen.isEnabled&&i.sheen.texture?[i.sheen.texture]:[]}async postExportMaterialAsync(a,O,i){return await new Promise((a=>{if(i instanceof Za.e){if(!i.sheen.isEnabled)return void a(O);this._wasUsed=!0,null==O.extensions&&(O.extensions={});const H={sheenColorFactor:i.sheen.color.Cb(),sheenRoughnessFactor:i.sheen.roughness??0};null===H.sheenColorTexture&&null===H.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(i),i.sheen.texture&&(H.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),i.sheen.textureRoughness&&!i.sheen.useRoughnessFromMainTexture?H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.textureRoughness)??void 0:i.sheen.texture&&i.sheen.useRoughnessFromMainTexture&&(H.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(i.sheen.texture)??void 0),O.extensions[wO]=H}a(O)}))}}va.RegisterExtension(wO,(a=>new KO(a)));const SO="KHR_materials_specular";class fO{constructor(a){this.name=SO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof Za.e&&this._isExtensionEnabled(i)?(i.metallicReflectanceTexture&&H.push(i.metallicReflectanceTexture),i.reflectanceTexture&&H.push(i.reflectanceTexture),H):H}_isExtensionEnabled(a){return!a.unlit&&(void 0!=a.metallicF0Factor&&1!=a.metallicF0Factor||void 0!=a.metallicReflectanceColor&&!a.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(a))}_hasTexturesExtension(a){return null!=a.metallicReflectanceTexture||null!=a.reflectanceTexture}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0,O.extensions=O.extensions||{};const a=this._exporter._materialExporter.getTextureInfo(i.metallicReflectanceTexture)??void 0,H=this._exporter._materialExporter.getTextureInfo(i.reflectanceTexture)??void 0,b={specularFactor:1==i.metallicF0Factor?void 0:i.metallicF0Factor,specularTexture:a,specularColorFactor:i.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:i.metallicReflectanceColor.Cb(),specularColorTexture:H};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),O.extensions[SO]=b}a(O)}))}}va.RegisterExtension(SO,(a=>new fO(a)));const BO="KHR_materials_transmission";class TO{constructor(a){this.name=BO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof Za.e&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&H.push(i.subSurface.thicknessTexture),H):H}_isExtensionEnabled(a){if(a.unlit)return!1;const O=a.subSurface;return O.isRefractionEnabled&&void 0!=O.refractionIntensity&&0!=O.refractionIntensity||this._hasTexturesExtension(a)}_hasTexturesExtension(a){return null!=a.subSurface.refractionIntensityTexture}async postExportMaterialAsync(a,O,i){if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const H=i.subSurface,b={transmissionFactor:0===H.refractionIntensity?void 0:H.refractionIntensity};if(this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),H.refractionIntensityTexture)if(H.useGltfStyleTextures){const a=await this._exporter._materialExporter.exportTextureAsync(H.refractionIntensityTexture,"image/png");a&&(b.transmissionTexture=a)}else R.c.Warn(`${a}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);O.extensions||(O.extensions={}),O.extensions[BO]=b}return O}}va.RegisterExtension(BO,(a=>new TO(a)));const AO="KHR_materials_unlit";class EO{constructor(){this.name=AO,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(a,O,i){return new Promise((a=>{let H=!1;i instanceof Za.e?H=i.unlit:i instanceof Fa.JO&&(H=i.disableLighting),H&&(this._wasUsed=!0,null==O.extensions&&(O.extensions={}),O.extensions[AO]={}),a(O)}))}}va.RegisterExtension(AO,(()=>new EO));const lO="KHR_materials_volume";class WO{constructor(a){this.name=lO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof Za.e&&this._isExtensionEnabled(i)?(i.subSurface.thicknessTexture&&H.push(i.subSurface.thicknessTexture),H):H}_isExtensionEnabled(a){if(a.unlit)return!1;const O=a.subSurface;return!(!O.isRefractionEnabled&&!O.isTranslucencyEnabled)&&(void 0!=O.maximumThickness&&0!=O.maximumThickness||void 0!=O.tintColorAtDistance&&O.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=O.tintColor&&O.tintColor!=r.mi.White()||this._hasTexturesExtension(a))}_hasTexturesExtension(a){return null!=a.subSurface.thicknessTexture}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof Za.e&&this._isExtensionEnabled(i)){this._wasUsed=!0;const a=i.subSurface,H={thicknessFactor:0==a.maximumThickness?void 0:a.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(a.thicknessTexture)??void 0,attenuationDistance:a.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:a.tintColorAtDistance,attenuationColor:a.tintColor.equalsFloats(1,1,1)?void 0:a.tintColor.Cb()};this._hasTexturesExtension(i)&&this._exporter._materialNeedsUVsSet.add(i),O.extensions=O.extensions||{},O.extensions[lO]=H}a(O)}))}}va.RegisterExtension(lO,(a=>new WO(a)));const uO="EXT_materials_diffuse_roughness";class cO{constructor(a){this.name=uO,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=a}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(a,O,i){const H=[];return i instanceof IO.d&&i._baseDiffuseRoughness?(i._baseDiffuseRoughnessTexture&&H.push(i._baseDiffuseRoughnessTexture),H):[]}postExportMaterialAsync(a,O,i){return new Promise((a=>{if(i instanceof IO.d){if(!i._baseDiffuseRoughness)return void a(O);this._wasUsed=!0,O.extensions=O.extensions||{};const H=this._exporter._materialExporter.getTextureInfo(i._baseDiffuseRoughnessTexture),b={diffuseRoughnessFactor:i._baseDiffuseRoughness,diffuseRoughnessTexture:H??void 0};null!==b.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(i),O.extensions[uO]=b}a(O)}))}}va.RegisterExtension(uO,(a=>new cO(a)));const RO="KHR_texture_transform";class zO{constructor(){this.name=RO,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(a,O,i){if(i.Ua()||b.Tools.Warn(`${a}: /*@__KEY__*/"scene" is not defined for Babylon texture ${i.name}!`),(0!==i.uAng||0!==i.vAng)&&(b.Tools.Warn(`${a}: Texture ${i.name} with rotation in the u or v axis is not supported in glTF.`),0!==i.uRotationCenter||0!==i.vRotationCenter))return;const H={};let G=!1;if(0===i.uOffset&&0===i.vOffset||(H.offset=[i.uOffset,i.vOffset],G=!0),1===i.uScale&&1===i.vScale||(H.scale=[i.uScale,i.vScale],G=!0),0!==i.wAng){if(0!==i.uRotationCenter||0!==i.vRotationCenter){if(i.homogeneousRotationInUVTransform&&i.uScale!==i.vScale)return void b.Tools.Warn(`${a}: Texture ${i.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${RO}.`);b.Tools.Warn(`${a}: Texture ${i.name} with non-origin rotation center will be exported using an adjusted offset with ${RO}.`),H.offset=function(a){const{uOffset:O,vOffset:i,uRotationCenter:H,vRotationCenter:b,uScale:G,vScale:q,wAng:Q}=a,k=Math.cos(Q),I=Math.sin(Q),P=H*G,e=b*q;return[O+(P*(1-k)+e*I),i+(e*(1-k)-P*I)]}(i)}H.rotation=-i.wAng,G=!0}0!==i.coordinatesIndex&&(H.texCoord=i.coordinatesIndex,G=!0),G&&(this._wasUsed=!0,O.extensions||(O.extensions={}),O.extensions[RO]=H)}}va.RegisterExtension(RO,(()=>new zO));class xO{static CreateSTL(a){let O=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",b=arguments.length>3&&void 0!==arguments[3]&&arguments[3],G=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],q=arguments.length>5&&void 0!==arguments[5]&&arguments[5],Q=arguments.length>6&&void 0!==arguments[6]&&arguments[6],k=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const I=function(a,O,i){const b=[3*a[i],3*a[i+1],3*a[i+2]],G=[new H.ZO(O[b[0]],O[b[0]+2],O[b[0]+1]),new H.ZO(O[b[1]],O[b[1]+2],O[b[1]+1]),new H.ZO(O[b[2]],O[b[2]+2],O[b[2]+1])],q=G[0].FO(G[1]),Q=G[2].FO(G[1]);return{v:G,n:H.ZO.Cross(Q,q).normalize()}},e=function(a,O,i,H){return O=h(a,O,i.x,H),O=h(a,O,i.y,H),h(a,O,i.z,H)},h=function(a,O,i,H){return a.setFloat32(O,i,H),O+4},Z=function(a){if(Q){let O=a;a instanceof j.b&&(O=a.sourceMesh);const i=O.getVerticesData(P.c.PositionKind,!0,!0);if(!i)return[];const b=H.ZO.Zero();let G;for(G=0;G<i.length;G+=3)H.ZO.TransformCoordinatesFromFloatsToRef(i[G],i[G+1],i[G+2],a.yb(!0),b).toArray(i,G);return i}return a.getVerticesData(P.c.PositionKind)||[]};Q&&(q=!0);let F="",r=0,J=0;if(b){for(let i=0;i<a.length;i++){const O=a[i].Kb();r+=O?O.length/3:0}const O=new ArrayBuffer(84+50*r);F=new DataView(O),J+=80,F.setUint32(J,r,G),J+=4}else k||(F="solid stlmesh\r\n");for(let H=0;H<a.length;H++){const O=a[H];!b&&k&&(F+="solid "+O.name+"\r\n"),!q&&O instanceof mO.d&&O.bakeCurrentTransformIntoVertices();const i=Z(O),Q=O.Kb()||[];for(let a=0;a<Q.length;a+=3){const O=I(Q,i,a);b?(J=e(F,J,O.n,G),J=e(F,J,O.v[0],G),J=e(F,J,O.v[1],G),J=e(F,J,O.v[2],G),J+=2):(F+="\tfacet normal "+O.n.x+" "+O.n.y+" "+O.n.z+"\r\n",F+="\t\touter loop\r\n",F+="\t\t\tvertex "+O.v[0].x+" "+O.v[0].y+" "+O.v[0].z+"\r\n",F+="\t\t\tvertex "+O.v[1].x+" "+O.v[1].y+" "+O.v[1].z+"\r\n",F+="\t\t\tvertex "+O.v[2].x+" "+O.v[2].y+" "+O.v[2].z+"\r\n",F+="\t\tendloop\r\n",F+="\tendfacet\r\n")}!b&&k&&(F+="endsolid "+name+"\r\n")}if(b||k||(F+="endsolid stlmesh"),O){const a=document.createElement("a"),O=new Blob([F],{type:"application/octet-stream"});a.href=window.URL.createObjectURL(O),a.download=i+".stl",a.click()}return F}}function gO(a,O){let i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const H=[];for(let b=0;b<a.length/i;b++){const G=a[b*i],q=a[b*i+1],Q=a[b*i+2];H.push(`(${G.toPrecision(O.precision)}, ${q.toPrecision(O.precision)}, ${Q.toPrecision(O.precision)})`)}return H.join(", ")}function NO(a,O){const i=[];for(let H=0;H<a.length/2;H++){const b=a[2*H],G=a[2*H+1];i.push(`(${b.toPrecision(O.precision)}, ${(1-G).toPrecision(O.precision)})`)}return i.join(", ")}function vO(a,O){const i=a.getVerticesData(P.c.PositionKind),H=a.getVerticesData(P.c.NormalKind);if(i&&H)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(a){var O;const i=null!==(O=a.Kb())&&void 0!==O&&O.length?a.getTotalIndices():a.getTotalVertices();return Array(i/3).fill(3).join(", ")}(a)}]\n\t\tint[] faceVertexIndices = [${function(a){const O=a.Kb(),i=[];if(null!==O)for(let H=0;H<O.length;H++)i.push(O[H]);else{const O=a.getTotalVertices();for(let a=0;a<O;a++)i.push(a)}return i.join(", ")}(a)}]\n\t\tnormal3f[] normals = [${gO(H,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${gO(i,O)}]\n        ${function(a,O){let i="";for(let b=0;b<4;b++){const H=b>0?b:"",G=a.getVerticesData(P.c.UVKind+(H?H+1:""));G&&(i+=`\n\t\ttexCoord2f[] primvars:st${H} = [${NO(G,O)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const H=a.getVerticesData(P.c.ColorKind);return H&&(i+=`\n\tcolor3f[] primvars:displayColor = [${gO(H,O,H.length/a.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),i}(a,O)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function XO(a,O){return`\n        def "Geometry"\n        {\n        ${vO(a,O)}\n        }\n        `}function pO(a){let O='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return O+=a,fflate.strToU8(O)}function oO(a){const O=a.m;return`( ${dO(O,0)}, ${dO(O,4)}, ${dO(O,8)}, ${dO(O,12)} )`}function dO(a,O){return`(${a[O+0]}, ${a[O+1]}, ${a[O+2]}, ${a[O+3]})`}function YO(a){const O="Object_"+a.uniqueId,i=function(a){const O=a.getWorldMatrix().clone(),i=a.Ua().useRightHandedSystem;if(!i){let H=a.parent;for(;H;){if(qa(H,i)){O.multiplyToRef(H.getWorldMatrix().invert(),O);break}H=H.parent}}return O.determinant()<0&&b.Tools.Warn(`Exporting mesh ${a.name} with negative scale. Result may look incorrect in destination engine.`),O}(a),H=oO(i);return`def Xform "${O}" (\n\tprepend references = @./geometries/Geometry_${a.wb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${H}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${a.material.uniqueId}>\n}\n\n`}function LO(a){switch(a){case U.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case U.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case U.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function sO(a){return`(${a.x}, ${a.y})`}function tO(a){return`(${a.r}, ${a.g}, ${a.b})`}function VO(a,O,i,b,G,q){const Q=a.getInternalTexture().uniqueId+"_"+a.invertY;G[Q]=a;const k=a.coordinatesIndex>0?"st"+a.coordinatesIndex:"st",I=new H.Vector2(a.uScale,a.vScale),P=new H.Vector2(a.uOffset,a.vOffset),e=a.wAng,h=Math.sin(e),j=Math.cos(e);return P.y=1-P.y-I.y,P.x+=h*I.x,P.y+=(1-j)*I.y,`\n    def Shader "PrimvarReader_${i}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${k}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${i}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${O.uniqueId}/PrimvarReader_${i}.outputs:result>\n        float inputs:rotation = ${(e*(180/Math.PI)).toFixed(q.precision)}\n        float2 inputs:scale = ${sO(I)}\n        float2 inputs:translation = ${sO(P)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${a.uniqueId}_${i}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${Q}.png@\n        float2 inputs:st.connect = </Materials/Material_${O.uniqueId}/Transform2d_${i}.outputs:result>\n        ${b?"float4 inputs:scale = "+function(a){return`(${a.r}, ${a.g}, ${a.b}, 1.0)`}(b):""}\n        token inputs:sourceColorSpace = "${a.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${LO(a.wrapU)}"\n        token inputs:wrapT = "${LO(a.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${O.needAlphaBlending()?"float outputs:a":""}\n    }`}function ai(a,O,i){const H="\t\t\t",b=[],G=[],{diffuseMap:q,ub:Q,alphaCutOff:k,emissiveMap:I,emissive:P,normalMap:e,roughnessMap:h,roughnessChannel:j,roughness:Z,metalnessMap:F,metalnessChannel:J,metalness:ma,aoMap:M,aoMapChannel:C,aoMapIntensity:n,alphaMap:D,ior:U,clearCoatEnabled:y,clearCoat:w,clearCoatMap:K,clearCoatRoughness:S,clearCoatRoughnessMap:f}=function(a){const O={diffuseMap:null,ub:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return a instanceof Fa.JO?{...O,diffuseMap:a.diffuseTexture,ub:a.diffuseColor,alphaCutOff:a.alphaCutOff,emissiveMap:a.emissiveTexture,emissive:a.emissiveColor,roughness:1,alphaMap:a.opacityTexture}:a instanceof IO.d?{...O,diffuseMap:a._albedoTexture,ub:a._albedoColor,alphaCutOff:a._alphaCutOff,emissiveMap:a._emissiveTexture,emissive:a._emissiveColor,normalMap:a._bumpTexture,roughnessMap:a._metallicTexture,roughnessChannel:a._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:a._roughness??1,metalnessMap:a._metallicTexture,metalnessChannel:a._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:a._metallic??0,aoMap:a._ambientTexture,aoMapChannel:a._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:a._ambientTextureStrength,alphaMap:a._opacityTexture,ior:a.subSurface.indexOfRefraction,clearCoatEnabled:a.clearCoat.isEnabled,clearCoat:a.clearCoat.Wb,clearCoatMap:a.clearCoat.texture,clearCoatRoughness:a.clearCoat.roughness,clearCoatRoughnessMap:a.clearCoat.useRoughnessFromMainTexture?a.clearCoat.texture:a.clearCoat.textureRoughness}:O}(a);return null!==q?(b.push(`${H}color3f inputs:diffuseColor.connect = </Materials/Material_${a.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:rgb>`),a.needAlphaBlending()?b.push(`${H}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`):a.needAlphaTesting()&&(b.push(`${H}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${q.uniqueId}_diffuse.outputs:a>`),b.push(`${H}float inputs:opacityThreshold = ${k}`)),G.push(VO(q,a,"diffuse",Q,O,i))):b.push(`${H}color3f inputs:diffuseColor = ${tO(Q||r.mi.White())}`),null!==I?(b.push(`${H}color3f inputs:emissiveColor.connect = </Materials/Material_${a.uniqueId}/Texture_${I.uniqueId}_emissive.outputs:rgb>`),G.push(VO(I,a,"emissive",P,O,i))):P&&P.toLuminance()>0&&b.push(`${H}color3f inputs:emissiveColor = ${tO(P)}`),null!==e&&(b.push(`${H}normal3f inputs:normal.connect = </Materials/Material_${a.uniqueId}/Texture_${e.uniqueId}_normal.outputs:rgb>`),G.push(VO(e,a,"normal",null,O,i))),null!==M&&(b.push(`${H}float inputs:occlusion.connect = </Materials/Material_${a.uniqueId}/Texture_${M.uniqueId}_occlusion.outputs:${C}>`),G.push(VO(M,a,"occlusion",new r.mi(n,n,n),O,i))),null!==h?(b.push(`${H}float inputs:roughness.connect = </Materials/Material_${a.uniqueId}/Texture_${h.uniqueId}_roughness.outputs:${j}>`),G.push(VO(h,a,"roughness",new r.mi(Z,Z,Z),O,i))):b.push(`${H}float inputs:roughness = ${Z}`),null!==F?(b.push(`${H}float inputs:metallic.connect = </Materials/Material_${a.uniqueId}/Texture_${F.uniqueId}_metallic.outputs:${J}>`),G.push(VO(F,a,"metallic",new r.mi(ma,ma,ma),O,i))):b.push(`${H}float inputs:metallic = ${ma}`),null!==D?(b.push(`${H}float inputs:opacity.connect = </Materials/Material_${a.uniqueId}/Texture_${D.uniqueId}_opacity.outputs:r>`),b.push(`${H}float inputs:opacityThreshold = 0.0001`),G.push(VO(D,a,"opacity",null,O,i))):b.push(`${H}float inputs:opacity = ${a.alpha}`),y&&(null!==K?(b.push(`${H}float inputs:clearcoat.connect = </Materials/Material_${a.uniqueId}/Texture_${K.uniqueId}_clearcoat.outputs:r>`),G.push(VO(K,a,"clearcoat",new r.mi(w,w,w),O,i))):b.push(`${H}float inputs:clearcoat = ${w}`),null!==f?(b.push(`${H}float inputs:clearcoatRoughness.connect = </Materials/Material_${a.uniqueId}/Texture_${f.uniqueId}_clearcoatRoughness.outputs:g>`),G.push(VO(f,a,"clearcoatRoughness",new r.mi(S,S,S),O,i))):b.push(`${H}float inputs:clearcoatRoughness = ${S}`)),b.push(`${H}float inputs:ior = ${U}`),`\n\tdef Material "Material_${a.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${b.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${a.uniqueId}/PreviewSurface.outputs:surface>\n\n${G.join("\n")}\n\n\t}\n`}async function Oi(a,O,i){const G={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...O};"undefined"===typeof fflate&&await b.Tools.LoadScriptAsync(G.fflateUrl);const q={};q[G.modelFileName]=null;let Q='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';Q+=function(a){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===a.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${a.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${a.planeAnchoringAlignment}"`:""}\n            `}(G);const k={};for(const H of a.meshes){if(0===H.getTotalVertices())continue;const a=H,O=a.wb,I=a.material;if(!I||!O||i&&!i(a))continue;if(-1!==["JO","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(I.getClassName())){const i="geometries/Geometry_"+O.uniqueId+".usda";if(!(i in q)){const a=XO(O,G);q[i]=pO(a)}I.uniqueId in k||(k[I.uniqueId]=I),Q+=YO(a)}else b.Tools.Warn("USDZExportAsync does not support this material type: "+I.getClassName())}a.activeCamera&&G.exportCamera&&(Q+=function(a,O){const i="Camera_"+a.uniqueId,b=oO(H.Matrix.RotationY(Math.PI).multiply(a.getWorldMatrix()));if(a.mode===U.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${b}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${a.Db.toPrecision(O.precision)}, ${a.maxZ.toPrecision(O.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(a.orthoLeft||1)+Math.abs(a.orthoRight||1))).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(a.orthoTop||1)+Math.abs(a.orthoBottom||1))).toPrecision(O.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const H=a.getEngine().getAspectRatio(a),G=O.cameraSensorWidth||35;return`def Camera "${i}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${b}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${a.Db.toPrecision(O.precision)}, ${a.maxZ.toPrecision(O.precision)})\n\t\t\tfloat focalLength = ${(G/(2*Math.tan(.5*a.fov))).toPrecision(O.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(G*H).toPrecision(O.precision)}\n\t\t\tfloat verticalAperture = ${(G/H).toPrecision(O.precision)}            \n\t\t}\n\t\n\t`}}(a.activeCamera,G)),Q+="\n            }\n        }\n    }";const I={};Q+=function(a,O,i){const H=[];for(const b in a){const G=a[b];H.push(ai(G,O,i))}return`\n    def "Materials"\n{\n${H.join("")}\n}\n\n`}(k,I,G),q[G.modelFileName]=fflate.strToU8(Q);for(const H in I){const a=I[H],O=a.getSize(),i=await a.readPixels();if(!i)throw new Error("Texture data is not available");const b=await y.DumpTools.DumpDataAsync(O.width,O.height,i,"image/png",void 0,!1,!0);q[`textures/Texture_${H}.png`]=new Uint8Array(b).slice()}let P=0;for(const H in q){const a=q[H];if(!a)continue;P+=34+H.length;const O=63&P;if(4!==O){const i=new Uint8Array(64-O);q[H]=[a,{extra:{12345:i}}]}P=a.length}return fflate.zipSync(q,{level:0})}}}]);