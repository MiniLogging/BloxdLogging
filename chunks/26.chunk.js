"use strict";(self.lfntwv94xlc=self.lfntwv94xlc||[]).push([[26],{11710:(m,S,h)=>{h.r(S),h.d(S,{EXT_materials_diffuse_roughness:()=>NS,EXT_mesh_gpu_instancing:()=>Qm,GLTF2Export:()=>rm,GLTFData:()=>Y,KHR_draco_mesh_compression:()=>hS,KHR_lights_punctual:()=>qS,KHR_materials_anisotropy:()=>IS,KHR_materials_clearcoat:()=>CS,KHR_materials_diffuse_transmission:()=>ES,KHR_materials_dispersion:()=>LS,KHR_materials_emissive_strength:()=>HS,KHR_materials_ior:()=>yS,KHR_materials_iridescence:()=>sS,KHR_materials_sheen:()=>TS,KHR_materials_specular:()=>gS,KHR_materials_transmission:()=>eS,KHR_materials_unlit:()=>xS,KHR_materials_volume:()=>dS,KHR_texture_transform:()=>KS,OBJExport:()=>u,STLExport:()=>cS,USDZExportAsync:()=>Sh,_ConvertToGLTFPBRMetallicRoughness:()=>a,_SolveMetallic:()=>e,__IGLTFExporterExtension:()=>b});var l=h(11347),M=h(11156),O=h(11629);class u{static OBJ(m,S,h,u){const b=[];let q=1,Y=1;S&&(h||(h="mat"),b.push("mtllib "+h+".mtl"));for(let V=0;V<m.length;V++){const h=m[V],I=h.name||`mesh${V}}`;b.push(`o ${I}`);let Z=null;if(u){const m=h.Mb(!0);Z=new l.Matrix,m.invertToRef(Z),h.bakeTransformIntoVertices(m)}if(S){const m=h.material;m&&b.push("usemtl "+m.id)}const C=h.ub;if(!C){M.Tools.Warn("No geometry is present on the mesh");continue}const B=C.getVerticesData("position"),D=C.getVerticesData("normal"),E=C.getVerticesData("uv"),n=C.bb();let L=0,U=0;if(!B||!n){M.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const H=m[0].sm().useRightHandedSystem?1:-1;for(let m=0;m<B.length;m+=3)b.push("v "+B[m]*H+" "+B[m+1]+" "+B[m+2]),L++;if(null!=D)for(let m=0;m<D.length;m+=3)b.push("vn "+D[m]*H+" "+D[m+1]+" "+D[m+2]);if(null!=E)for(let m=0;m<E.length;m+=2)b.push("vt "+E[m]+" "+E[m+1]),U++;const R=["","",""],y=(h.material||h.sm().defaultMaterial)._getEffectiveOrientation(h),[o,s]=y===O.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let m=0;m<n.length;m+=3){const S=[String(n[m]+q),String(n[m+o]+q),String(n[m+s]+q)],h=[String(n[m]+Y),String(n[m+o]+Y),String(n[m+s]+Y)],l=S,M=null!=E?h:R,O=null!=D?S:R;b.push("f "+l[0]+"/"+M[0]+"/"+O[0]+" "+l[1]+"/"+M[1]+"/"+O[1]+" "+l[2]+"/"+M[2]+"/"+O[2])}u&&Z&&h.bakeTransformIntoVertices(Z),q+=L,Y+=U}return b.join("\n")}static MTL(m){const S=[],h=m.material;S.push("newmtl mat1"),S.push("  Ns "+h.specularPower.toFixed(4)),S.push("  Ni 1.5000"),S.push("  d "+h.alpha.toFixed(4)),S.push("  Tr 0.0000"),S.push("  Tf 1.0000 1.0000 1.0000"),S.push("  illum 2"),S.push("  Ka "+h.ambientColor.r.toFixed(4)+" "+h.ambientColor.g.toFixed(4)+" "+h.ambientColor.b.toFixed(4)),S.push("  Kd "+h.diffuseColor.r.toFixed(4)+" "+h.diffuseColor.g.toFixed(4)+" "+h.diffuseColor.b.toFixed(4)),S.push("  Ks "+h.specularColor.r.toFixed(4)+" "+h.specularColor.g.toFixed(4)+" "+h.specularColor.b.toFixed(4)),S.push("  Ke "+h.emissiveColor.r.toFixed(4)+" "+h.emissiveColor.g.toFixed(4)+" "+h.emissiveColor.b.toFixed(4));h.ambientTexture&&S.push("  map_Ka "+h.ambientTexture.name),h.diffuseTexture&&S.push("  map_Kd "+h.diffuseTexture.name),h.specularTexture&&S.push("  map_Ks "+h.specularTexture.name),h.bumpTexture&&S.push("  map_bump -imfchan z "+h.bumpTexture.name),h.opacityTexture&&S.push("  map_d "+h.opacityTexture.name);return S.join("\n")}}var b=0,q=h(11205);class Y{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const m in this.files){const S=this.files[m],h=new Blob([S],{type:(0,q.h)(m)});M.Tools.Download(h,m)}}}var V=h(11410),I=h(11712),Z=h(11726),C=h(11745),B=h(11456),D=h(11196),E=h(11387),n=h(11359);const L=n.HighestCommonFactor,U={...n,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:L};var H=h(11556),R=h(11321),y=h(11782),o=h(11785),s=h(11550);const v=1e-6,T=new E.RS(.04,.04,.04),X=1024,g=E.RS.White(),G=E.RS.Black();function e(m,S,h){if(S<T.r)return 0;const l=T.r,M=m*h/(1-T.r)+S-2*T.r,O=M*M-4*l*(T.r-S);return U.Clamp((-M+Math.sqrt(O))/(2*l),0,1)}function a(m){const S=m.diffuseColor.toLinearSpace(m.sm().getEngine().useExactSrgbConversions).scale(.5),h=m.alpha,M=function(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new l.Vector2(0,1),h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new l.Vector2(0,.1),M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new l.Vector2(0,.1),O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new l.Vector2(1300,.1);return function(m,S,h,l,M){return(1-m)*(1-m)*(1-m)*S+3*(1-m)*(1-m)*m*h+3*(1-m)*m*m*l+m*m*m*M}(Math.pow(m/O.x,.333333),S.y,h.y,M.y,O.y)}(U.Clamp(m.specularPower,0,X));return{baseColorFactor:[S.r,S.g,S.b,h],metallicFactor:0,roughnessFactor:M}}function x(m,S){S.needAlphaBlending()?m.alphaMode="BLEND":S.needAlphaTesting()&&(m.alphaMode="MASK",m.alphaCutoff=S.alphaCutOff)}function P(m,S,h){const l=new Uint8Array(m*S*4);for(let M=0;M<l.length;M+=4)l[M]=l[M+1]=l[M+2]=l[M+3]=255;return y.d.CreateRGBATexture(l,m,S,h)}function d(m){if(m instanceof Uint8Array){const S=m.length,h=new Float32Array(m.length);for(let l=0;l<S;++l)h[l]=m[l]/255;return h}if(m instanceof Float32Array)return m;throw new Error("Unsupported pixel format!")}class J{constructor(m){this._exporter=m,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(m){return m?this._textureMap.get(m)??null:null}async exportStandardMaterialAsync(m,S,h){const l=a(m),O={name:m.name};if(null==m.qb||m.qb||(m.twoSidedLighting||M.Tools.Warn(m.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),O.doubleSided=!0),h){const h=[],M=m.diffuseTexture;M&&h.push(this.exportTextureAsync(M,S).then((m=>{m&&(l.baseColorTexture=m)})));const u=m.bumpTexture;u&&h.push(this.exportTextureAsync(u,S).then((m=>{m&&(O.normalTexture=m,1!==u.level&&(O.normalTexture.scale=u.level))})));const b=m.emissiveTexture;b&&(O.emissiveFactor=[1,1,1],h.push(this.exportTextureAsync(b,S).then((m=>{m&&(O.emissiveTexture=m)}))));const q=m.ambientTexture;q&&h.push(this.exportTextureAsync(q,S).then((m=>{if(m){const S={index:m.index};O.occlusionTexture=S}}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(m),await Promise.all(h))}(m.alpha<1||m.opacityTexture)&&(m.alphaMode===o.c.ALPHA_COMBINE?O.alphaMode="BLEND":M.Tools.Warn(m.name+": glTF 2.0 does not support alpha mode: "+m.alphaMode.toString())),m.emissiveColor&&!m.emissiveColor.equalsWithEpsilon(G,v)&&(O.emissiveFactor=m.emissiveColor.DM()),O.pbrMetallicRoughness=l,x(O,m),await this._finishMaterialAsync(O,m,S);const u=this._exporter._materials;return u.push(O),u.length-1}async _finishMaterialAsync(m,S,h){const l=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",m,S),M=[];for(const O of l)M.push(this.exportTextureAsync(O,h));await Promise.all(M),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",m,S)}async _getImageDataAsync(m,S,l,M){const O=o.c.TEXTURETYPE_UNSIGNED_BYTE,u=this._exporter._babylonScene,b=u.getEngine(),q=b.createRawTexture(m,S,l,o.c.TEXTUREFORMAT_RGBA,!1,!0,R.e.NEAREST_SAMPLINGMODE,null,O);b.isWebGPU?await h.e(51).then(h.bind(h,13858)):await h.e(52).then(h.bind(h,13867)),await H.l.ApplyPostProcess("pass",q,u,O,o.c.TEXTURE_NEAREST_SAMPLINGMODE,o.c.TEXTUREFORMAT_RGBA);const Y=await b._readTexturePixels(q,S,l);return await s.DumpTools.DumpDataAsync(S,l,Y,M,void 0,!0,!0)}_resizeTexturesToSameDimensions(m,S,h){const l=m?m.getSize():{width:0,height:0},M=S?S.getSize():{width:0,height:0};let O,u;return l.width<M.width?(O=m&&m instanceof R.e?H.l.CreateResizedCopy(m,M.width,M.height,!0):P(M.width,M.height,h),u=S):l.width>M.width?(u=S&&S instanceof R.e?H.l.CreateResizedCopy(S,l.width,l.height,!0):P(l.width,l.height,h),O=m):(O=m,u=S),{texture1:O,texture2:u}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(m,S,h,l){const M=new Array;if(!m&&!S)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const O=m?m.sm():S?S.sm():null;if(O){var u;const b=this._resizeTexturesToSameDimensions(m,S,O),q=null===(u=b.texture1)||void 0===u?void 0:u.getSize();let Y,V;const I=q.width,Z=q.height,C=await b.texture1.readPixels(),B=await b.texture2.readPixels();if(!C)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(Y=d(C),!B)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");V=d(B);const D=V.byteLength,n=new Uint8Array(D),L=new Uint8Array(D),U=4,H=G;let R=0,y=0;for(let m=0;m<Z;++m)for(let S=0;S<I;++S){const l=(I*m+S)*U,M={diffuseColor:new E.RS(Y[l],Y[l+1],Y[l+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(h.diffuseColor),specularColor:new E.RS(V[l],V[l+1],V[l+2]).toLinearSpace(O.getEngine().useExactSrgbConversions).multiply(h.specularColor),glossiness:V[l+3]*h.glossiness},u=this._convertSpecularGlossinessToMetallicRoughness(M);H.r=Math.max(H.r,u.baseColor.r),H.g=Math.max(H.g,u.baseColor.g),H.b=Math.max(H.b,u.baseColor.b),R=Math.max(R,u.metallic),y=Math.max(y,u.roughness),L[l]=255*u.baseColor.r,L[l+1]=255*u.baseColor.g,L[l+2]=255*u.baseColor.b,L[l+3]=b.texture1.Sb?255*Y[l+3]:255,n[l]=0,n[l+1]=255*u.roughness,n[l+2]=255*u.metallic,n[l+3]=255}const o={baseColor:H,metallic:R,roughness:y};let s=!1,T=!1;for(let m=0;m<Z;++m)for(let S=0;S<I;++S){const h=(I*m+S)*U;L[h]/=o.baseColor.r>v?o.baseColor.r:1,L[h+1]/=o.baseColor.g>v?o.baseColor.g:1,L[h+2]/=o.baseColor.b>v?o.baseColor.b:1;const l=E.RS.FromInts(L[h],L[h+1],L[h+2]).toGammaSpace(O.getEngine().useExactSrgbConversions);L[h]=255*l.r,L[h+1]=255*l.g,L[h+2]=255*l.b,l.equalsWithEpsilon(g,v)||(T=!0),n[h+1]/=o.roughness>v?o.roughness:1,n[h+2]/=o.metallic>v?o.metallic:1;E.RS.FromInts(255,n[h+1],n[h+2]).equalsWithEpsilon(g,v)||(s=!0)}return s&&M.push(this._getImageDataAsync(n,I,Z,l).then((m=>{o.metallicRoughnessTextureData=m}))),T&&M.push(this._getImageDataAsync(L,I,Z,l).then((m=>{o.baseColorTextureData=m}))),await Promise.all(M).then((()=>o))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(m){const S=this._getPerceivedBrightness(m.diffuseColor),h=this._getPerceivedBrightness(m.specularColor),l=1-this._getMaxComponent(m.specularColor),M=e(S,h,l),O=m.diffuseColor.scale(l/(1-T.r)/Math.max(1-M)),u=m.specularColor.LS(T.scale(1-M)).scale(1/Math.max(M));let b=E.RS.Lerp(O,u,M*M);b=b.clampToRef(0,1,b);return{baseColor:b,metallic:M,roughness:1-m.glossiness}}_getPerceivedBrightness(m){return m?Math.sqrt(.299*m.r*m.r+.587*m.g*m.g+.114*m.b*m.b):0}_getMaxComponent(m){return m?Math.max(m.r,Math.max(m.g,m.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(m,S,h,l){const M=[],O={baseColor:m._albedoColor,metallic:m._metallic,roughness:m._roughness};if(l){m._albedoTexture&&M.push(this.exportTextureAsync(m._albedoTexture,S).then((m=>{m&&(h.baseColorTexture=m)})));const l=m._metallicTexture;l&&M.push(this.exportTextureAsync(l,S).then((m=>{m&&(h.metallicRoughnessTexture=m)})))}return M.length>0&&(this._exporter._materialNeedsUVsSet.add(m),await Promise.all(M)),O}_getTextureSampler(m){const S={};if(!m||!(m instanceof R.e))return S;const h=this._getGLTFTextureWrapMode(m.wrapU);10497!==h&&(S.wrapS=h);const l=this._getGLTFTextureWrapMode(m.wrapV);switch(10497!==l&&(S.wrapT=l),m.samplingMode){case R.e.LINEAR_LINEAR:S.magFilter=9729,S.minFilter=9729;break;case R.e.LINEAR_NEAREST:S.magFilter=9729,S.minFilter=9728;break;case R.e.NEAREST_LINEAR:S.magFilter=9728,S.minFilter=9729;break;case R.e.NEAREST_LINEAR_MIPLINEAR:S.magFilter=9728,S.minFilter=9987;break;case R.e.NEAREST_NEAREST:S.magFilter=9728,S.minFilter=9728;break;case R.e.NEAREST_LINEAR_MIPNEAREST:S.magFilter=9728,S.minFilter=9985;break;case R.e.LINEAR_NEAREST_MIPNEAREST:S.magFilter=9729,S.minFilter=9984;break;case R.e.LINEAR_NEAREST_MIPLINEAR:S.magFilter=9729,S.minFilter=9986;break;case R.e.NEAREST_NEAREST_MIPLINEAR:S.magFilter=9728,S.minFilter=9986;break;case R.e.LINEAR_LINEAR_MIPLINEAR:S.magFilter=9729,S.minFilter=9987;break;case R.e.LINEAR_LINEAR_MIPNEAREST:S.magFilter=9729,S.minFilter=9985;break;case R.e.NEAREST_NEAREST_MIPNEAREST:S.magFilter=9728,S.minFilter=9984}return S}_getGLTFTextureWrapMode(m){switch(m){case R.e.WRAP_ADDRESSMODE:return 10497;case R.e.CLAMP_ADDRESSMODE:return 33071;case R.e.MIRROR_ADDRESSMODE:return 33648;default:return M.Tools.Error(`Unsupported Texture Wrap Mode ${m}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(m,S,h,l){const M={diffuseColor:m._albedoColor,specularColor:m._reflectivityColor,glossiness:m._microSurface},O=m._albedoTexture,u=m._reflectivityTexture,b=m._useMicroSurfaceFromReflectivityMapAlpha;if(u&&!b)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((O||u)&&l){this._exporter._materialNeedsUVsSet.add(m);const l=this._exportTextureSampler(O||u),b=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(O,u,M,S),q=this._exporter._textures;if(b.baseColorTextureData){const m=this._exportImage(`baseColor${q.length}`,S,b.baseColorTextureData);h.baseColorTexture=this._exportTextureInfo(m,l,null===O||void 0===O?void 0:O.coordinatesIndex)}if(b.metallicRoughnessTextureData){const m=this._exportImage(`metallicRoughness${q.length}`,S,b.metallicRoughnessTextureData);h.metallicRoughnessTexture=this._exportTextureInfo(m,l,null===u||void 0===u?void 0:u.coordinatesIndex)}return b}return this._convertSpecularGlossinessToMetallicRoughness(M)}async exportPBRMaterialAsync(m,S,h){const l={},M={name:m.name},O=m.isMetallicWorkflow();if(O){const S=m._albedoColor,h=m.alpha;S&&(l.baseColorFactor=[S.r,S.g,S.b,h])}const u=O?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(m,S,l,h):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(m,S,l,h);await this._setMetallicRoughnessPbrMaterialAsync(u,m,M,l,S,h),await this._finishMaterialAsync(M,m,S);const b=this._exporter._materials;return b.push(M),b.length-1}async _setMetallicRoughnessPbrMaterialAsync(m,S,h,l,O,u){if(x(h,S),m.baseColor.equalsWithEpsilon(g,v)&&U.WithinEpsilon(S.alpha,1,v)||(l.baseColorFactor=[m.baseColor.r,m.baseColor.g,m.baseColor.b,S.alpha]),null!=m.metallic&&1!==m.metallic&&(l.metallicFactor=m.metallic),null!=m.roughness&&1!==m.roughness&&(l.roughnessFactor=m.roughness),null==S.qb||S.qb||(S._twoSidedLighting||M.Tools.Warn(S.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),u){const m=[],l=S._bumpTexture;l&&m.push(this.exportTextureAsync(l,O).then((m=>{m&&(h.normalTexture=m,1!==l.level&&(h.normalTexture.scale=l.level))})));const M=S._ambientTexture;M&&m.push(this.exportTextureAsync(M,O).then((m=>{if(m){const l={index:m.index,texCoord:m.texCoord,extensions:m.extensions};h.occlusionTexture=l;const M=S._ambientTextureStrength;M&&(l.strength=M)}})));const u=S._emissiveTexture;u&&m.push(this.exportTextureAsync(u,O).then((m=>{m&&(h.emissiveTexture=m)}))),m.length>0&&(this._exporter._materialNeedsUVsSet.add(S),await Promise.all(m))}const b=S._emissiveColor;b.equalsWithEpsilon(G,v)||(h.emissiveFactor=b.DM()),h.pbrMetallicRoughness=l}_getPixelsFromTextureAsync(m){return function(m){switch(m){case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case o.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case o.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case o.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case o.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(m.textureFormat)?(0,H.j)(m,m._texture.width,m._texture.height):(m.textureType,o.c.TEXTURETYPE_UNSIGNED_BYTE,m.readPixels())}async exportTextureAsync(m,S){const h=this._exporter._extensionsPreExportTextureAsync("exporter",m,S);return h?await h.then((async h=>h?await this._exportTextureInfoAsync(h,S):await this._exportTextureInfoAsync(m,S))):await this._exportTextureInfoAsync(m,S)}async _exportTextureInfoAsync(m,S){let h=this._textureMap.get(m);if(!h){const l=await this._getPixelsFromTextureAsync(m);if(!l)return null;const O=this._exportTextureSampler(m),u=m.mimeType;if(u)switch(u){case"image/jpeg":case"image/png":case"image/webp":S=u;break;default:M.Tools.Warn(`Unsupported media type: ${u}. Exporting texture as PNG.`)}const b=this._internalTextureToImage,q=m.getInternalTexture().uniqueId;b[q]||(b[q]={});let Y=b[q][S];if(void 0===Y){const h=m.getSize();Y=(async()=>{const M=await this._getImageDataAsync(l,h.width,h.height,S);return this._exportImage(m.name,S,M)})(),b[q][S]=Y}h=this._exportTextureInfo(await Y,O,m.coordinatesIndex),this._textureMap.set(m,h),this._exporter._extensionsPostExportTextures("exporter",h,m)}return h}_exportImage(m,S,h){const l=this._exporter._images;let O;if(this._exporter._shouldUseGlb){O={name:m,mimeType:S,bufferView:void 0};const l=this._exporter._bufferManager.createBufferView(new Uint8Array(h));this._exporter._bufferManager.setBufferView(O,l)}else{const u=m.replace(/\.\/|\/|\.\\|\\/g,"_"),b=function(m){switch(m){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(S);let q=u+b;l.some((m=>m.uri===q))&&(q=`${u}_${M.Tools.RandomId()}${b}`),O={name:m,uri:q},this._exporter._imageData[q]={data:h,mimeType:S}}return l.push(O),l.length-1}_exportTextureInfo(m,S,h){const l=this._exporter._textures;let M=l.findIndex((h=>h.sampler==S&&h.source===m));-1===M&&(M=l.length,l.push({source:m,sampler:S}));const O={index:M};return h&&(O.texCoord=h),O}_exportTextureSampler(m){const S=this._getTextureSampler(m),h=this._exporter._samplers,l=h.findIndex((m=>m.minFilter===S.minFilter&&m.magFilter===S.magFilter&&m.wrapS===S.wrapS&&m.wrapT===S.wrapT));return-1!==l?l:(h.push(S),h.length-1)}}var N=h(11419),j=h(11173),K=h(11791),c=h(11350);const f=l.nS.Zero(),p=l.Quaternion.Identity(),k=l.nS.One(),r=new l.nS(-1,1,1);function z(m,S){const{byteOffset:h,byteStride:l,type:M,normalized:O}=m,u=m.getSize(),b=S.reduce(((m,S)=>S.getTotalVertices()>m?S.getTotalVertices():m),-Number.MAX_VALUE);return{byteOffset:h,byteStride:l,componentCount:u,type:M,count:b*u,normalized:O,totalVertices:b,kind:m.getKind()}}function Q(m){switch(m){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function F(m){switch(m){case V.f.PositionKind:case V.f.NormalKind:case V.f.TangentKind:case V.f.ColorKind:case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:case V.f.MatricesWeightsKind:case V.f.MatricesWeightsExtraKind:case V.f.UVKind:case V.f.UV2Kind:case V.f.UV3Kind:case V.f.UV4Kind:case V.f.UV5Kind:case V.f.UV6Kind:return!0}return!1}function w(m){switch(m){case O.e.TriangleFillMode:return 4;case O.e.TriangleStripDrawMode:return 5;case O.e.TriangleFanDrawMode:return 6;case O.e.PointListDrawMode:case O.e.PointFillMode:return 0;case O.e.LineLoopDrawMode:return 2;case O.e.LineListDrawMode:return 1;case O.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${m}`)}function t(m){const S=Math.sqrt(m.x*m.x+m.y*m.y+m.z*m.z);S>0&&(m.x/=S,m.y/=S,m.z/=S)}function A(m){return m.x*=-1,m}function i(m){if(m.x*m.x+m.y*m.y>.5){const S=Math.abs(m.x),h=Math.abs(m.y);if(S>h){const h=Math.sign(m.x);m.x=S,m.y*=-h,m.z*=-h,m.w*=h}else{const S=Math.sign(m.y);m.x*=-S,m.y=h,m.z*=S,m.w*=-S}}else{const S=Math.abs(m.z),h=Math.abs(m.w);if(S>h){const h=Math.sign(m.z);m.x*=-h,m.y*=h,m.z=S,m.w*=-h}else{const S=Math.sign(m.w);m.x*=S,m.y*=-S,m.z*=-S,m.w=h}}return m}function W(m){m.Yb(-m.z,m.w,m.x,-m.y)}function mm(m,S){const h=l.nS.FromArrayToRef(S.translation||[0,0,0],0,l.TmpVectors.nS[0]),M=l.Quaternion.FromArrayToRef(S.rotation||[0,0,0,1],0,l.TmpVectors.Quaternion[0]),O=l.Matrix.ComposeToRef(k,M,h,l.TmpVectors.Matrix[0]),u=l.nS.FromArrayToRef(m.translation||[0,0,0],0,l.TmpVectors.nS[2]),b=l.Quaternion.FromArrayToRef(m.rotation||[0,0,0,1],0,l.TmpVectors.Quaternion[1]),q=l.Matrix.ComposeToRef(k,b,u,l.TmpVectors.Matrix[1]);O.multiplyToRef(q,q),q.decompose(void 0,M,h),h.equalsWithEpsilon(f,c.d)?delete S.translation:S.translation=h.DM(),M.equalsWithEpsilon(p,c.d)?delete S.rotation:S.rotation=M.DM(),S.scale&&delete S.scale}function Sm(m,S){if(!(S instanceof I.d))return!1;if(!(1===S.getChildren().length&&0===m.getChildren().length&&m.parent===S))return!1;const h=m.sm(),l=m instanceof K.c&&!h.useRightHandedSystem?r:k;return!!S.Ib.equalsWithEpsilon(l,c.d)||(j.e.Warn(`Cannot collapse node ${m.name} into parent node ${S.name} with modified scaling.`),!1)}function hm(m){if(m instanceof Array){const S=new Float32Array(m);return new Uint8Array(S.buffer,S.byteOffset,S.byteLength)}return ArrayBuffer.isView(m)?new Uint8Array(m.buffer,m.byteOffset,m.byteLength):new Uint8Array(m)}function lm(m,S){for(const[h,l]of Object.entries(m)){const M=S[h];(Array.isArray(l)&&Array.isArray(M)&&Mm(l,M)||l===M)&&delete m[h]}return m}function Mm(m,S){return m.length===S.length&&m.every(((m,h)=>m===S[h]))}const Om=l.Matrix.Compose(new l.nS(-1,1,1),l.Quaternion.Identity(),l.nS.Zero());function um(m,S){if(!(m instanceof I.d))return!1;if(S){if(!m.getWorldMatrix().equalsWithEpsilon(l.Matrix.IdentityReadOnly,c.d))return!1}else{if(!m.getWorldMatrix().multiplyToRef(Om,l.TmpVectors.Matrix[0]).equalsWithEpsilon(l.Matrix.IdentityReadOnly,c.d))return!1}return!(m instanceof Z.e&&m.ub)}const bm=new Map([[Int8Array,(m,S,h)=>m.setInt8(S,h)],[Uint8Array,(m,S,h)=>m.setUint8(S,h)],[Uint8ClampedArray,(m,S,h)=>m.setUint8(S,h)],[Int16Array,(m,S,h)=>m.setInt16(S,h,!0)],[Uint16Array,(m,S,h)=>m.setUint16(S,h,!0)],[Int32Array,(m,S,h)=>m.setInt32(S,h,!0)],[Uint32Array,(m,S,h)=>m.setUint32(S,h,!0)],[Float32Array,(m,S,h)=>m.setFloat32(S,h,!0)],[Float64Array,(m,S,h)=>m.setFloat64(S,h,!0)]]);class qm{writeTypedArray(m){this._checkGrowBuffer(m.byteLength);const S=bm.get(m.constructor);for(let h=0;h<m.length;h++)S(this._dataView,this._byteOffset,m[h]),this._byteOffset+=m.BYTES_PER_ELEMENT}constructor(m){this._data=new Uint8Array(m),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(m){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,m),this._byteOffset++}writeInt8(m){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,m),this._byteOffset++}writeInt16(m){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,m,!0),this._byteOffset+=2}writeUInt16(m){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,m,!0),this._byteOffset+=2}writeInt32(m){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,m,!0),this._byteOffset+=4}writeUInt32(m){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,m,!0),this._byteOffset+=4}writeFloat32(m){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,m,!0),this._byteOffset+=4}writeFloat64(m){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,m,!0),this._byteOffset+=8}_checkGrowBuffer(m){const S=this.byteOffset+m;if(S>this._data.byteLength){const m=new Uint8Array(2*S);m.set(this._data),this._data=m,this._dataView=new DataView(this._data.buffer)}}}function Ym(m){return m%4===0?4:m%2===0?2:1}class Vm{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(m){let S=0;this._bufferViewToData.forEach((m=>{S+=m.byteLength}));const h=new qm(S),l=Array.from(this._bufferViewToData.keys()).sort(((m,S)=>Ym(S.byteLength)-Ym(m.byteLength)));for(const M of l){M.byteOffset=h.byteOffset,m.push(M);const S=m.length-1,l=this.getPropertiesWithBufferView(M);for(const m of l)m.bufferView=S;h.writeTypedArray(this._bufferViewToData.get(M)),this._bufferViewToData.delete(M)}return h.getOutputData()}createBufferView(m,S){const h={buffer:0,byteOffset:void 0,byteLength:m.byteLength,byteStride:S};return this._bufferViewToData.set(h,m),h}createAccessor(m,S,h,l,M,O,u){this._verifyBufferView(m);const b={bufferView:void 0,componentType:h,count:l,type:S,min:null===O||void 0===O?void 0:O.min,max:null===O||void 0===O?void 0:O.max,normalized:u,byteOffset:M};return this.setBufferView(b,m),this._accessorToBufferView.set(b,m),b}setBufferView(m,S){this._verifyBufferView(S);this.getPropertiesWithBufferView(S).push(m)}removeBufferView(m){const S=this.getPropertiesWithBufferView(m);for(const h of S)void 0!==h.bufferView&&delete h.bufferView;this._bufferViewToData.delete(m),this._bufferViewToProperties.delete(m),this._accessorToBufferView.forEach(((S,h)=>{S===m&&(void 0!==h.byteOffset&&delete h.byteOffset,this._accessorToBufferView.delete(h))}))}getBufferView(m){const S=this._accessorToBufferView.get(m);return this._verifyBufferView(S),S}getPropertiesWithBufferView(m){return this._verifyBufferView(m),this._bufferViewToProperties.set(m,this._bufferViewToProperties.get(m)??[]),this._bufferViewToProperties.get(m)}getData(m){return this._verifyBufferView(m),this._bufferViewToData.get(m)}_verifyBufferView(m){if(void 0===m||!this._bufferViewToData.has(m))throw new Error(`BufferView ${m} not found in BufferManager.`)}}var Im,Zm=h(11759),Cm=h(11773),Bm=h(11798),Dm=h(11674),Em=h(11838),nm=h(11850),Lm=h(11751),Um=h(11855);!function(m){m[m.INTANGENT=0]="INTANGENT",m[m.OUTTANGENT=1]="OUTTANGENT"}(Im||(Im={}));class Hm{static _IsTransformable(m){return m&&(m instanceof I.d||m instanceof Zm.d||m instanceof Um.b)}static _CreateNodeAnimation(m,S,h,l,O){if(this._IsTransformable(m)){const u=[],b=[],q=S.getKeys(),Y=Hm._CalculateMinMaxKeyFrames(q),V=Hm._DeduceInterpolation(q,h,l),I=V.interpolationType,Z=V.shouldBakeAnimation;if(Z?Hm._CreateBakedAnimation(m,S,h,Y.min,Y.max,S.framePerSecond,O,u,b,Y,l):"LINEAR"===I||"STEP"===I?Hm._CreateLinearOrStepAnimation(m,S,h,u,b,l):"CUBICSPLINE"===I?Hm._CreateCubicSplineAnimation(m,S,h,u,b,l):Hm._CreateBakedAnimation(m,S,h,Y.min,Y.max,S.framePerSecond,O,u,b,Y,l),u.length&&b.length){return{inputs:u,outputs:b,samplerInterpolation:I,inputsMin:Z?Y.min:M.Tools.FloatRound(Y.min/S.framePerSecond),inputsMax:Z?Y.max:M.Tools.FloatRound(Y.max/S.framePerSecond)}}}return null}static _DeduceAnimationInfo(m){let S=null,h="VEC3",l=!1;const O=m.targetProperty.split(".");switch(O[0]){case"Ib":S="scale";break;case"position":S="translation";break;case"rotation":h="VEC4",S="rotation";break;case"rotationQuaternion":h="VEC4",l=!0,S="rotation";break;case"influence":h="SCALAR",S="weights";break;default:M.Tools.Error(`Unsupported animatable property ${O[0]}`)}return S?{animationChannelTargetPath:S,dataAccessorType:h,useQuaternion:l}:(M.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(m,S,h,l,M,O,u,b,q,Y,V){let I;if(Hm._IsTransformable(m)&&m.animations)for(const Z of m.animations){if(V&&!V(Z))continue;const M=Hm._DeduceAnimationInfo(Z);M&&(I={name:Z.name,samplers:[],channels:[]},Hm._AddAnimation(`${Z.name}`,Z.hasRunningRuntimeAnimations?S:I,m,Z,M.dataAccessorType,M.animationChannelTargetPath,l,O,u,b,M.useQuaternion,q,Y),I.samplers.length&&I.channels.length&&h.push(I))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(m,S,h,l,M,O,u,b,q,Y,V){let I;if(m instanceof Lm.c){const M=m.morphTargetManager;if(M)for(let Z=0;Z<M.numTargets;++Z){const C=M.getTarget(Z);for(const B of C.animations){if(V&&!V(B))continue;const C=new Em.e(`${B.name}`,"influence",B.framePerSecond,B.dataType,B.loopMode,B.enableBlending),D=[],E=B.getKeys();for(let m=0;m<E.length;++m){const S=E[m];for(let m=0;m<M.numTargets;++m)m==Z?D.push(S):D.push({frame:S.frame,value:0})}C.setKeys(D);const n=Hm._DeduceAnimationInfo(C);n&&(I={name:C.name,samplers:[],channels:[]},Hm._AddAnimation(B.name,B.hasRunningRuntimeAnimations?S:I,m,C,n.dataAccessorType,n.animationChannelTargetPath,l,O,u,b,n.useQuaternion,q,Y,M.numTargets),I.samplers.length&&I.channels.length&&h.push(I))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(m,S,h,l,M,O,u,b,q){let Y;if(m.animationGroups){const I=m.animationGroups;for(const Z of I){const I=new Map,C=new Map,B=new Set,D=Z.to-Z.from;Y={name:Z.name,channels:[],samplers:[]};for(let S=0;S<Z.targetedAnimations.length;++S){const D=Z.targetedAnimations[S],E=D.target,n=D.animation;if(q&&!q(n))continue;const L=b.has(E);if(this._IsTransformable(E)||1===E.length&&this._IsTransformable(E[0])){const m=Hm._DeduceAnimationInfo(D.animation);if(m){const S=this._IsTransformable(E)?E:this._IsTransformable(E[0])?E[0]:null;S&&Hm._AddAnimation(`${n.name}`,Y,S,n,m.dataAccessorType,m.animationChannelTargetPath,h,l,M,O,m.useQuaternion,u,L)}}else if(E instanceof nm.c||1===E.length&&E[0]instanceof nm.c){if(Hm._DeduceAnimationInfo(D.animation)){const S=E instanceof nm.c?E:E[0];if(S){const h=m.morphTargetManagers.find((m=>{for(let h=0;h<m.numTargets;++h)if(m.getTarget(h)===S)return!0;return!1}));if(h){const l=m.meshes.find((m=>m.morphTargetManager===h));var V;if(l)I.has(l)||I.set(l,new Map),null===(V=I.get(l))||void 0===V||V.set(S,n),B.add(l),C.set(l,n)}}}}}B.forEach((m=>{const S=m.morphTargetManager;let b=null;const q=[],V=C.get(m).getKeys(),B=V.length;for(let h=0;h<B;++h)for(let l=0;l<S.numTargets;++l){const M=S.getTarget(l),O=I.get(m);if(O){const S=O.get(M);S?(b||(b=new Em.e(`${Z.name}_${m.name}_MorphWeightAnimation`,"influence",S.framePerSecond,Em.e.ANIMATIONTYPE_FLOAT,S.loopMode,S.enableBlending)),q.push(S.getKeys()[h])):q.push({frame:Z.from+D/B*h,value:M.influence,inTangent:V[0].inTangent?0:void 0,outTangent:V[0].outTangent?0:void 0})}}b.setKeys(q);const E=Hm._DeduceAnimationInfo(b);E&&Hm._AddAnimation(`${Z.name}_${m.name}_MorphWeightAnimation`,Y,m,b,E.dataAccessorType,E.animationChannelTargetPath,h,l,M,O,E.useQuaternion,u,!1,null===S||void 0===S?void 0:S.numTargets)})),Y.channels.length&&Y.samplers.length&&S.push(Y)}}}static _AddAnimation(m,S,h,M,O,u,b,q,Y,V,I,Z,C,B){const D=Hm._CreateNodeAnimation(h,M,u,I,Z);let E,n,L,U,H,R;if(D){if(B){let m=0,S=0;const h=[];for(;D.inputs.length>0;)S=D.inputs.shift(),m%B==0&&h.push(S),m++;D.inputs=h}const m=b.get(h),M=new Float32Array(D.inputs);E=q.createBufferView(M),n=q.createAccessor(E,"SCALAR",5126,D.inputs.length,void 0,{min:[D.inputsMin],max:[D.inputsMax]}),V.push(n),L=V.length-1;const Y=new l.Quaternion,I=new l.nS,Z=new l.nS,y=h instanceof Zm.d,o=Q(O),s=new Float32Array(D.outputs.length*o);D.outputs.forEach((function(m,S){let h=m;switch(u){case"translation":C&&(l.nS.FromArrayToRef(m,0,Z),A(Z),Z.toArray(h));break;case"rotation":4===m.length?l.Quaternion.FromArrayToRef(m,0,Y):(h=new Array(4),l.nS.FromArrayToRef(m,0,I),l.Quaternion.FromEulerVectorToRef(I,Y)),C&&(i(Y),y&&W(Y)),Y.toArray(h)}s.set(h,S*o)})),E=q.createBufferView(s),n=q.createAccessor(E,O,5126,D.outputs.length),V.push(n),U=V.length-1,H={interpolation:D.samplerInterpolation,input:L,output:U},S.samplers.push(H),R={sampler:S.samplers.length-1,target:{node:m,path:u}},S.channels.push(R)}}static _CreateBakedAnimation(m,S,h,O,u,b,q,Y,V,I,Z){let C;const B=l.Quaternion.Identity();let D,E=null,n=null,L=null,U=null,H=null,R=null;I.min=M.Tools.FloatRound(O/b);const y=S.getKeys();for(let l=0,o=y.length;l<o;++l){if(R=null,L=y[l],l+1<o)if(U=y[l+1],L.value.equals&&L.value.equals(U.value)||L.value===U.value){if(0!==l)continue;R=L.frame}else R=U.frame;else{if(H=y[l-1],L.value.equals&&L.value.equals(H.value)||L.value===H.value)continue;R=u}if(R)for(let l=L.frame;l<=R;l+=q){if(D=M.Tools.FloatRound(l/b),D===E)continue;E=D,n=D;const O={key:0,repeatCount:0,loopMode:S.loopMode};C=S._interpolate(l,O),Hm._SetInterpolatedValue(m,C,D,S,h,B,Y,V,Z)}}n&&(I.max=n)}static _ConvertFactorToVector3OrQuaternion(m,S,h,O,u){const b=Hm._GetBasePositionRotationOrScale(S,O,u),q=h.targetProperty.split("."),Y=q?q[1]:"",V=u?l.Quaternion.yS(b).normalize():l.nS.yS(b);switch(Y){case"x":case"y":case"z":V[Y]=m;break;case"w":V.w=m;break;default:M.Tools.Error(`glTFAnimation: Unsupported component name "${Y}"!`)}return V}static _SetInterpolatedValue(m,S,h,M,O,u,b,q,Y){let V;b.push(h),"weights"!==O?(M.dataType===Em.e.ANIMATIONTYPE_FLOAT&&(S=this._ConvertFactorToVector3OrQuaternion(S,m,M,O,Y)),"rotation"===O?(Y?u=S:(V=S,l.Quaternion.RotationYawPitchRollToRef(V.y,V.x,V.z,u)),q.push(u.DM())):(V=S,q.push(V.DM()))):q.push([S])}static _CreateLinearOrStepAnimation(m,S,h,l,M,O){for(const u of S.getKeys())l.push(u.frame/S.framePerSecond),Hm._AddKeyframeValue(u,S,M,h,m,O)}static _CreateCubicSplineAnimation(m,S,h,l,M,O){S.getKeys().forEach((function(u){l.push(u.frame/S.framePerSecond),Hm._AddSplineTangent(Im.INTANGENT,M,h,"CUBICSPLINE",u,O),Hm._AddKeyframeValue(u,S,M,h,m,O),Hm._AddSplineTangent(Im.OUTTANGENT,M,h,"CUBICSPLINE",u,O)}))}static _GetBasePositionRotationOrScale(m,S,h){let M;if("rotation"===S)if(h){M=(m.rotationQuaternion??l.Quaternion.Identity()).DM()}else{M=(m.rotation??l.nS.Zero()).DM()}else if("translation"===S){M=(m.position??l.nS.Zero()).DM()}else{M=(m.Ib??l.nS.One()).DM()}return M}static _AddKeyframeValue(m,S,h,O,u,b){let q;const Y=S.dataType;if(Y===Em.e.ANIMATIONTYPE_VECTOR3){let S=m.value.DM();if("rotation"===O){const m=l.nS.yS(S);S=l.Quaternion.RotationYawPitchRoll(m.y,m.x,m.z).DM()}h.push(S)}else if(Y===Em.e.ANIMATIONTYPE_FLOAT){if("weights"===O)h.push([m.value]);else if(q=this._ConvertFactorToVector3OrQuaternion(m.value,u,S,O,b),q){if("rotation"===O){const m=b?q:l.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).normalize();h.push(m.DM())}h.push(q.DM())}}else Y===Em.e.ANIMATIONTYPE_QUATERNION?h.push(m.value.normalize().DM()):M.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(m,S,h){let l,M,O=!1;if("rotation"===S&&!h)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let u=0,b=m.length;u<b;++u)if(M=m[u],M.inTangent||M.outTangent)if(l){if("CUBICSPLINE"!==l){l="LINEAR",O=!0;break}}else l="CUBICSPLINE";else if(l){if("CUBICSPLINE"===l||M.interpolation&&1===M.interpolation&&"STEP"!==l){l="LINEAR",O=!0;break}}else l=M.interpolation&&1===M.interpolation?"STEP":"LINEAR";return l||(l="LINEAR"),{interpolationType:l,shouldBakeAnimation:O}}static _AddSplineTangent(m,S,h,M,O,u){let b;const q=m===Im.INTANGENT?O.inTangent:O.outTangent;if("CUBICSPLINE"===M){if("rotation"===h)if(q)if(u)b=q.DM();else{const m=q;b=l.Quaternion.RotationYawPitchRoll(m.y,m.x,m.z).DM()}else b=[0,0,0,0];else b="weights"===h?q?[q]:[0]:q?q.DM():[0,0,0];S.push(b)}}static _CalculateMinMaxKeyFrames(m){let S=1/0,h=-1/0;return m.forEach((function(m){S=Math.min(S,m.frame),h=Math.max(h,m.frame)})),{min:S,max:h}}}function Rm(m,S,h,O,u,b){const q={attributes:{},influence:m.influence,name:m.name},Y=S.ub;if(!Y)return M.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),q;const I=b?-1:1,Z=l.nS.Zero();let C=0,B=0;if(m.hasPositions){const O=m.getPositions(),b=Y.getVerticesData(V.f.PositionKind);if(b){const m=new Float32Array(b.length),S=[1/0,1/0,1/0],M=[-1/0,-1/0,-1/0];B=b.length/3,C=0;for(let h=C;h<B;++h){const u=l.nS.yS(b,3*h);l.nS.yS(O,3*h).subtractToRef(u,Z),Z.x*=I,S[0]=Math.min(S[0],Z.x),M[0]=Math.max(M[0],Z.x),S[1]=Math.min(S[1],Z.y),M[1]=Math.max(M[1],Z.y),S[2]=Math.min(S[2],Z.z),M[2]=Math.max(M[2],Z.z),m[3*h]=Z.x,m[3*h+1]=Z.y,m[3*h+2]=Z.z}const Y=h.createBufferView(m,12),V=h.createAccessor(Y,"VEC3",5126,O.length/3,0,{min:S,max:M});u.push(V),q.attributes.POSITION=u.length-1}else M.Tools.Warn(`Morph target positions for mesh ${S.name} were not exported. Mesh does not have position vertex data`)}if(m.hasNormals){const O=m.getNormals(),b=Y.getVerticesData(V.f.NormalKind);if(b){const m=new Float32Array(b.length);B=b.length/3,C=0;for(let h=C;h<B;++h){const S=l.nS.yS(b,3*h).normalize();l.nS.yS(O,3*h).normalize().subtractToRef(S,Z),m[3*h]=Z.x*I,m[3*h+1]=Z.y,m[3*h+2]=Z.z}const S=h.createBufferView(m,12),M=h.createAccessor(S,"VEC3",5126,O.length/3,0);u.push(M),q.attributes.NORMAL=u.length-1}else M.Tools.Warn(`Morph target normals for mesh ${S.name} were not exported. Mesh does not have normals vertex data`)}if(m.hasTangents){const O=m.getTangents(),b=Y.getVerticesData(V.f.TangentKind);if(b){B=b.length/4;const m=new Float32Array(3*B);C=0;for(let h=C;h<B;++h){const S=l.nS.yS(b,4*h);t(S);const M=l.nS.yS(O,3*h);t(M),M.subtractToRef(S,Z),m[3*h]=Z.x*I,m[3*h+1]=Z.y,m[3*h+2]=Z.z}const S=h.createBufferView(m,12),M=h.createAccessor(S,"VEC3",5126,B,0);u.push(M),q.attributes.TANGENT=u.length-1}else M.Tools.Warn(`Morph target tangents for mesh ${S.name} were not exported. Mesh does not have tangents vertex data`)}if(m.hasColors){const O=m.getColors(),b=Y.getVerticesData(V.f.ColorKind),I=Y.getVertexBuffer(V.f.ColorKind);if(b&&I){const m=I.getSize();B=b.length/m;const S=new Float32Array(B*m);C=0;for(let h=C;h<B;++h)if(3===m){const M=l.nS.yS(b,h*m);l.nS.yS(O,h*m).subtractToRef(M,Z),S[3*h]=Z.x,S[3*h+1]=Z.y,S[3*h+2]=Z.z}else if(4===m){const M=new l.Vector4,u=l.Vector4.yS(b,h*m);l.Vector4.yS(O,h*m).subtractToRef(u,M),S[4*h]=M.x,S[4*h+1]=M.y,S[4*h+2]=M.z,S[4*h+3]=M.w}else M.Tools.Warn(`Unsupported number of components for color attribute: ${m}`);const Y=h.createBufferView(S,4*m),V=h.createAccessor(Y,3===m?"VEC3":"VEC4",5126,B,0);u.push(V),q.attributes.COLOR_0=u.length-1}else M.Tools.Warn(`Morph target colors for mesh ${S.name} were not exported. Mesh does not have colors vertex data`)}return q}var ym=h(11857),om=h(11700),sm=h(11682),vm=h(11293);class Tm{}Tm.DEFAULT_COLOR=E.RS.White(),Tm.DEFAULT_WIDTH_ATTENUATED=1,Tm.DEFAULT_WIDTH=.1;var Xm=h(11541),gm=h(11866);class Gm{static ConvertPoints(m,S){if(m.length&&Array.isArray(m)&&"number"===typeof m[0])return[m];if(m.length&&Array.isArray(m[0])&&"number"===typeof m[0][0])return m;if(m.length&&!Array.isArray(m[0])&&m[0]instanceof l.nS){const S=[];for(let h=0;h<m.length;h++){const l=m[h];S.push(l.x,l.y,l.z)}return[S]}if(m.length>0&&Array.isArray(m[0])&&m[0].length>0&&m[0][0]instanceof l.nS){const S=[],h=m;for(const m of h)S.push(m.flatMap((m=>[m.x,m.y,m.z])));return S}if(m instanceof Float32Array){if(null!==S&&void 0!==S&&S.floatArrayStride){const h=[],l=3*S.floatArrayStride;for(let S=0;S<m.length;S+=l){const M=new Array(l);for(let h=0;h<l;h++)M[h]=m[S+h];h.push(M)}return h}return[Array.from(m)]}if(m.length&&m[0]instanceof Float32Array){const S=[];for(const h of m)S.push(Array.from(h));return S}return[]}static OmitZeroLengthPredicate(m,S,h){const l=[];return S.LS(m).lengthSquared()>0&&l.push([m,S]),h.LS(S).lengthSquared()>0&&l.push([S,h]),m.LS(h).lengthSquared()>0&&l.push([h,m]),0===l.length?null:l}static OmitDuplicatesPredicate(m,S,h,l){const M=[];return Gm._SearchInPoints(m,S,l)||M.push([m,S]),Gm._SearchInPoints(S,h,l)||M.push([S,h]),Gm._SearchInPoints(h,m,l)||M.push([h,m]),0===M.length?null:M}static _SearchInPoints(m,S,h){for(const u of h)for(let h=0;h<u.length;h++){var l,M,O;if(null!==(l=u[h])&&void 0!==l&&l.equals(m))if(null!==(M=u[h+1])&&void 0!==M&&M.equals(S)||null!==(O=u[h-1])&&void 0!==O&&O.equals(S))return!0}return!1}static MeshesToLines(m,S){const h=[];for(let M=0;M<m.length;M++){const O=m[M],u=O.getVerticesData(V.f.PositionKind),b=O.bb();if(u&&b)for(let m=0,q=0;m<b.length;m++){const Y=3*b[q++],V=3*b[q++],I=3*b[q++],Z=new l.nS(u[Y],u[Y+1],u[Y+2]),C=new l.nS(u[V],u[V+1],u[V+2]),B=new l.nS(u[I],u[I+1],u[I+2]);if(S){const l=S(Z,C,B,h,m,Y,O,M,u,b);if(l)for(const m of l)h.push(m)}else h.push([Z,C],[C,B],[B,Z])}}return h}static ToVector3Array(m){if(Array.isArray(m[0])){const S=[],h=m;for(const m of h){const h=[];for(let S=0;S<m.length;S+=3)h.push(new l.nS(m[S],m[S+1],m[S+2]));S.push(h)}return S}const S=m,h=[];for(let M=0;M<S.length;M+=3)h.push(new l.nS(S[M],S[M+1],S[M+2]));return h}static ToNumberArray(m){return m.flatMap((m=>[m.x,m.y,m.z]))}static GetPointsCountInfo(m){const S=new Array(m.length);let h=0;for(let l=m.length;l--;)S[l]=m[l].length/3,h+=S[l];return{total:h,counts:S}}static GetLineLength(m){if(0===m.length)return 0;let S;S="number"===typeof m[0]?Gm.ToVector3Array(m):m;const h=l.TmpVectors.nS[0];let M=0;for(let l=0;l<S.length-1;l++){const m=S[l];M+=S[l+1].subtractToRef(m,h).length()}return M}static GetLineLengthArray(m){const S=new Float32Array(m.length/3);let h=0;for(let l=0,M=m.length/3-1;l<M;l++){let M=m[3*l+0],O=m[3*l+1],u=m[3*l+2];M-=m[3*l+3],O-=m[3*l+4],u-=m[3*l+5];h+=Math.sqrt(M*M+O*O+u*u),S[l+1]=h}return S}static SegmentizeSegmentByCount(m,S,h){const M=[],O=S.LS(m),u=l.TmpVectors.nS[0];u.Zb(h);const b=l.TmpVectors.nS[1];O.divideToRef(u,b);let q=m.clone();M.push(q);for(let l=0;l<h;l++)q=q.clone(),M.push(q.addInPlace(b));return M}static SegmentizeLineBySegmentLength(m,S){const h=m[0]instanceof l.nS?Gm.GetLineSegments(m):"number"===typeof m[0]?Gm.GetLineSegments(Gm.ToVector3Array(m)):m,M=[];for(const l of h)if(l.length>S){const m=Gm.SegmentizeSegmentByCount(l.point1,l.point2,Math.ceil(l.length/S));for(const S of m)M.push(S)}else M.push(l.point1),M.push(l.point2);return M}static SegmentizeLineBySegmentCount(m,S){const h="number"===typeof m[0]?Gm.ToVector3Array(m):m,l=Gm.GetLineLength(h)/S;return Gm.SegmentizeLineBySegmentLength(h,l)}static GetLineSegments(m){const S=[];for(let h=0;h<m.length-1;h++){const l=m[h],M=m[h+1],O=M.LS(l).length();S.push({point1:l,point2:M,length:O})}return S}static GetMinMaxSegmentLength(m){const S=Gm.GetLineSegments(m).sort((m=>m.length));return{min:S[0].length,max:S[S.length-1].length}}static GetPositionOnLineByVisibility(m,S,h){let M=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const O=S*h;let u=0,b=0;const q=m.length;for(let l=0;l<q;l++){if(O<=u+m[l].length){b=l;break}u+=m[l].length}const Y=(O-u)/m[b].length;return m[b].point2.subtractToRef(m[b].point1,l.TmpVectors.nS[0]),l.TmpVectors.nS[1]=l.TmpVectors.nS[0].multiplyByFloats(Y,Y,Y),M||l.TmpVectors.nS[1].addInPlace(m[b].point1),l.TmpVectors.nS[1].clone()}static GetCircleLinePoints(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,M=arguments.length>3&&void 0!==arguments[3]?arguments[3]:m,O=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/S;const u=[];for(let b=0;b<=S;b++)u.push(new l.nS(Math.cos(b*O)*m,Math.sin(b*O)*M,h));return u}static GetBezierLinePoints(m,S,h,l){return Xm.d.CreateQuadraticBezier(m,S,h,l).getPoints().flatMap((m=>[m.x,m.y,m.z]))}static GetArrowCap(m,S,h,l,M){let O=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[m.clone(),m.add(S.multiplyByFloats(h,h,h))],widths:[l,M,O,u]}}static GetPointsFromText(m,S,h,l){let M=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,O=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const u=[],b=(0,gm.b)(m,S,h,l);for(const q of b){for(const m of q.paths){const S=[],h=m.getPoints();for(const m of h)S.push(m.x,m.y,M);u.push(S)}if(O)for(const m of q.holes){const S=[],h=m.getPoints();for(const m of h)S.push(m.x,m.y,M);u.push(S)}}return u}static Color3toRGBAUint8(m){const S=new Uint8Array(4*m.length);for(let h=0,l=0;h<m.length;h++)S[l++]=255*m[h].r,S[l++]=255*m[h].g,S[l++]=255*m[h].b,S[l++]=255;return S}static CreateColorsTexture(m,S,h,l){const M=l.getEngine().getCaps().maxTextureSize??1,O=S.length>M?M:S.length,u=Math.ceil(S.length/M);u>1&&(S=[...S,...Array(O*u-S.length).fill(S[0])]);const b=Gm.Color3toRGBAUint8(S),q=new y.d(b,O,u,B.d.TEXTUREFORMAT_RGBA,l,!1,!0,h);return q.name=m,q}static PrepareEmptyColorsTexture(m){if(!Tm.EmptyColorsTexture){const S=new Uint8Array(4);Tm.EmptyColorsTexture=new y.d(S,1,1,B.d.TEXTUREFORMAT_RGBA,m,!1,!1,y.d.NEAREST_NEAREST),Tm.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Tm.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var m;null===(m=Tm.EmptyColorsTexture)||void 0===m||m.dispose(),Tm.EmptyColorsTexture=null}static BooleanToNumber(m){return m?1:0}}class em extends sm.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class am extends om.d{isCompatible(m){return!0}constructor(m,S,h){var M;h=h||{color:Tm.DEFAULT_COLOR};const O=new em;O.GREASED_LINE_HAS_COLOR=!!h.color&&!h.useColors,O.GREASED_LINE_SIZE_ATTENUATION=h.sizeAttenuation??!1,O.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===h.colorDistributionType,O.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(S??m.sm()).useRightHandedSystem,O.GREASED_LINE_CAMERA_FACING=h.cameraFacing??!0,super(m,am.GREASED_LINE_MATERIAL_NAME,200,O,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(M=h)||void 0===M?void 0:M.forceGLSL)||am.ForceGLSL,this._scene=S??m.sm(),this._engine=this._scene.getEngine(),this._cameraFacing=h.cameraFacing??!0,this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.width=h.width?h.width:h.sizeAttenuation?Tm.DEFAULT_WIDTH_ATTENUATED:Tm.DEFAULT_WIDTH,this._sizeAttenuation=h.sizeAttenuation??!1,this.colorMode=h.colorMode??0,this._color=h.color??null,this.useColors=h.useColors??!1,this._colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??y.d.NEAREST_NEAREST,this._colors=h.gm??null,this.dashCount=h.dashCount??1,this.resolution=h.resolution??new l.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=Gm.CreateColorsTexture(`${m.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Tm.DEFAULT_COLOR,Gm.PrepareEmptyColorsTexture(this._scene)),this._engine.Jh.add((()=>{Gm.DisposeEmptyColorsTexture()}))}getAttributes(m){m.push("grl_offsets"),m.push("grl_widths"),m.push("grl_colorPointers"),m.push("grl_counters"),this._cameraFacing?(m.push("grl_previousAndSide"),m.push("grl_nextAndCounters")):m.push("grl_slopes")}getSamplers(m){m.push("grl_colors")}getActiveTextures(m){this.colorsTexture&&m.push(this.colorsTexture)}getUniforms(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const S=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&S.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===m&&S.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:S,vertex:this._cameraFacing&&this._isGLSL(m)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(m)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(m){if(this._cameraFacing){m.lb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||m.lb("viewProjection",this._scene.getTransformMatrix());const S=l.TmpVectors.Vector4[0];S.x=this._aspect,S.y=this._resolution.x,S.z=this._resolution.y,S.w=this.width,m.updateVector4("grl_aspect_resolution_lineWidth",S)}const S=l.TmpVectors.Vector4[0];S.x=Gm.BooleanToNumber(this.useDash),S.y=this._dashArray,S.z=this.dashOffset,S.w=this.dashRatio,m.updateVector4("grl_dashOptions",S);const h=l.TmpVectors.Vector4[1];h.x=this.colorMode,h.y=this.visibility,h.z=this.colorsTexture?this.colorsTexture.getSize().width:0,h.w=Gm.BooleanToNumber(this.useColors),m.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",h),this._color&&m.updateColor3("grl_singleColor",this._color);const M=this.colorsTexture??Tm.EmptyColorsTexture;m.setTexture("grl_colors",M),m.updateFloat2("grl_textureSize",(null===M||void 0===M?void 0:M.getSize().width)??1,(null===M||void 0===M?void 0:M.getSize().height)??1)}prepareDefines(m,S,h){m.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,m.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,m.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,m.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=S.useRightHandedSystem,m.GREASED_LINE_CAMERA_FACING=this._cameraFacing,m.GREASED_LINE_USE_OFFSETS=!!h.offsets}getClassName(){return am.GREASED_LINE_MATERIAL_NAME}getCustomCode(m){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(S)?function(m,S){if("vertex"===m){const m={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return S&&(m["!gl_Position\\=viewProjection\\*worldPos;"]="//"),m}return"fragment"===m?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(m,this._cameraFacing):function(m,S){if("vertex"===m){const m={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return S&&(m["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),m}return"fragment"===m?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(m,this._cameraFacing)}dispose(){var m;null===(m=this.colorsTexture)||void 0===m||m.dispose(),super.dispose()}get gm(){return this._colors}set gm(m){this.setColors(m)}setColors(m){var S;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const M=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var O;if(this._colors=m,null!==m&&0!==m.length){if(!h||l)if(this.colorsTexture&&M===m.length&&!l){const S=Gm.Color3toRGBAUint8(m);this.colorsTexture.update(S)}else{var u;null===(u=this.colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=Gm.CreateColorsTexture(`${this._material.name}-colors-texture`,m,this.colorsSampling,this._scene)}}else null===(O=this.colorsTexture)||void 0===O||O.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(m){this._dashCount=m,this._dashArray=1/m}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(m){this._sizeAttenuation=m,this.markAllDefinesAsDirty()}get color(){return this._color}set color(m){this.setColor(m)}setColor(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==m||null!==this._color&&null===m?(this._color=m,S||this.markAllDefinesAsDirty()):this._color=m}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(m){this._colorsDistributionType=m,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(m){this._aspect=m.x/m.y,this._resolution=m}serialize(){const m=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(S.gm=this._colors),this._color&&(S.color=this._color),m.greasedLineMaterialOptions=S,m}parse(m,S,h){var l;super.parse(m,S,h);const M=m.greasedLineMaterialOptions;null===(l=this.colorsTexture)||void 0===l||l.dispose(),M.color&&this.setColor(M.color,!0),M.colorDistributionType&&(this.colorsDistributionType=M.colorDistributionType),M.gm&&(this.gm=M.gm),M.colorsSampling&&(this.colorsSampling=M.colorsSampling),M.colorMode&&(this.colorMode=M.colorMode),M.useColors&&(this.useColors=M.useColors),M.visibility&&(this.visibility=M.visibility),M.useDash&&(this.useDash=M.useDash),M.dashCount&&(this.dashCount=M.dashCount),M.dashRatio&&(this.dashRatio=M.dashRatio),M.dashOffset&&(this.dashOffset=M.dashOffset),M.width&&(this.width=M.width),M.sizeAttenuation&&(this.sizeAttenuation=M.sizeAttenuation),M.resolution&&(this.resolution=M.resolution),this.gm?this.colorsTexture=Gm.CreateColorsTexture(`${this._material.name}-colors-texture`,this.gm,this.colorsSampling,S):Gm.PrepareEmptyColorsTexture(S),this.markAllDefinesAsDirty()}copyTo(m){var S;const h=m;null===(S=h.colorsTexture)||void 0===S||S.dispose(),this._colors&&(h.colorsTexture=Gm.CreateColorsTexture(`${h._material.name}-colors-texture`,this._colors,h.colorsSampling,this._scene)),h.setColor(this.color,!0),h.colorsDistributionType=this.colorsDistributionType,h.colorsSampling=this.colorsSampling,h.colorMode=this.colorMode,h.useColors=this.useColors,h.visibility=this.visibility,h.useDash=this.useDash,h.dashCount=this.dashCount,h.dashRatio=this.dashRatio,h.dashOffset=this.dashOffset,h.width=this.width,h.sizeAttenuation=this.sizeAttenuation,h.resolution=this.resolution,h.markAllDefinesAsDirty()}_isGLSL(m){return 0===m||this._forceGLSL}}am.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",am.ForceGLSL=!1,(0,vm.e)(`BABYLON.${am.GREASED_LINE_MATERIAL_NAME}`,am);var xm=h(11734),Pm=h(11179),dm=h(11562),Jm=h(11270);class Nm extends dm.ShaderMaterial{constructor(m,S,M){const O=S.getEngine(),u=O.isWebGPU&&!(M.forceGLSL||Nm.ForceGLSL),b=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];S.useRightHandedSystem&&b.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const q=["position","grl_widths","grl_offsets","grl_colorPointers"];M.cameraFacing?(b.push("GREASED_LINE_CAMERA_FACING"),q.push("grl_previousAndSide","grl_nextAndCounters")):(q.push("grl_slopes"),q.push("grl_counters"));const Y=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(u||Y.push("world","viewProjection","view","projection"),super(m,S,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:u?["Scene","Mesh"]:void 0,attributes:q,uniforms:Y,samplers:u?[]:["grlColors"],defines:b,extraInitializationsAsync:async()=>{u?await Promise.all([h.e(66).then(h.bind(h,14520)),h.e(75).then(h.bind(h,14527))]):await Promise.all([h.e(69).then(h.bind(h,14532)),h.e(76).then(h.bind(h,14539))])},shaderLanguage:u?1:0}),this._color=E.RS.White(),this._colorsDistributionType=0,this._colorsTexture=null,M=M||{color:Tm.DEFAULT_COLOR},this.visibility=M.visibility??1,this.useDash=M.useDash??!1,this.dashRatio=M.dashRatio??.5,this.dashOffset=M.dashOffset??0,this.dashCount=M.dashCount??1,this.width=M.width?M.width:M.sizeAttenuation&&M.cameraFacing?Tm.DEFAULT_WIDTH_ATTENUATED:Tm.DEFAULT_WIDTH,this.sizeAttenuation=M.sizeAttenuation??!1,this.color=M.color??E.RS.White(),this.useColors=M.useColors??!1,this.colorsDistributionType=M.colorDistributionType??0,this.colorsSampling=M.colorsSampling??y.d.NEAREST_NEAREST,this.colorMode=M.colorMode??0,this._colors=M.gm??null,this._cameraFacing=M.cameraFacing??!0,this.resolution=M.resolution??new l.Vector2(O.getRenderWidth(),O.getRenderHeight()),M.colorsTexture?this.colorsTexture=M.colorsTexture:this._colors?this.colorsTexture=Gm.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,S):(this._color=this._color??Tm.DEFAULT_COLOR,this.colorsTexture=Gm.PrepareEmptyColorsTexture(S)),u){const m=new Jm.b;m.setParameters(),m.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",m)}O.Jh.add((()=>{Gm.DisposeEmptyColorsTexture()}))}dispose(){var m;null===(m=this._colorsTexture)||void 0===m||m.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new l.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get gm(){return this._colors}set gm(m){this.setColors(m)}setColors(m){var S;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],l=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const M=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var O;if(this._colors=m,null!==m&&0!==m.length){if(!h||l)if(this._colorsTexture&&M===m.length&&!l){const S=Gm.Color3toRGBAUint8(m);this._colorsTexture.update(S)}else{var u;null===(u=this._colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=Gm.CreateColorsTexture(`${this.name}-colors-texture`,m,this.colorsSampling,this.sm())}}else null===(O=this._colorsTexture)||void 0===O||O.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(m){this._colorsTexture=m,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(m){this._width=m,this.setFloat("grlWidth",m)}get useColors(){return this._useColors}set useColors(m){this._useColors=m,this.setFloat("grlUseColors",Gm.BooleanToNumber(m))}get colorsSampling(){return this._colorsSampling}set colorsSampling(m){this._colorsSampling=m}get visibility(){return this._visibility}set visibility(m){this._visibility=m,this.setFloat("grlVisibility",m)}get useDash(){return this._useDash}set useDash(m){this._useDash=m,this.setFloat("grlUseDash",Gm.BooleanToNumber(m))}get dashOffset(){return this._dashOffset}set dashOffset(m){this._dashOffset=m,this.setFloat("grlDashOffset",m)}get dashRatio(){return this._dashRatio}set dashRatio(m){this._dashRatio=m,this.setFloat("grlDashRatio",m)}get dashCount(){return this._dashCount}set dashCount(m){this._dashCount=m,this._dashArray=1/m,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(m){this._sizeAttenuation=m,this.setFloat("grlSizeAttenuation",Gm.BooleanToNumber(m))}get color(){return this._color}set color(m){this.setColor(m)}setColor(m){m=m??Tm.DEFAULT_COLOR,this._color=m,this.setColor3("grlColor",m)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(m){this._colorsDistributionType=m,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(m){this._colorMode=m,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(m){this._resolution=m,this.setVector2("grlResolution",m),this.setFloat("grlAspect",m.x/m.y)}serialize(){const m=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(S.gm=this._colors),m.greasedLineMaterialOptions=S,m}parse(m,S,h){var l;const M=m.greasedLineMaterialOptions;null===(l=this._colorsTexture)||void 0===l||l.dispose(),M.color&&(this.color=M.color),M.colorDistributionType&&(this.colorsDistributionType=M.colorDistributionType),M.colorsSampling&&(this.colorsSampling=M.colorsSampling),M.colorMode&&(this.colorMode=M.colorMode),M.useColors&&(this.useColors=M.useColors),M.visibility&&(this.visibility=M.visibility),M.useDash&&(this.useDash=M.useDash),M.dashCount&&(this.dashCount=M.dashCount),M.dashRatio&&(this.dashRatio=M.dashRatio),M.dashOffset&&(this.dashOffset=M.dashOffset),M.width&&(this.width=M.width),M.sizeAttenuation&&(this.sizeAttenuation=M.sizeAttenuation),M.resolution&&(this.resolution=M.resolution),M.gm?this.colorsTexture=Gm.CreateColorsTexture(`${this.name}-colors-texture`,M.gm,this.colorsSampling,this.sm()):this.colorsTexture=Gm.PrepareEmptyColorsTexture(S),this._cameraFacing=M.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var jm,Km,cm;Nm.ForceGLSL=!1,function(m){m[m.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",m[m.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(jm||(jm={})),function(m){m[m.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",m[m.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",m[m.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Km||(Km={})),function(m){m[m.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",m[m.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",m[m.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",m[m.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",m[m.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(cm||(cm={}));class fm extends Lm.c{constructor(m,S,h){super(m,S,null,null,!1,!1),this.name=m,this._options=h,this._lazy=!1,this._updatable=!1,this._engine=S.getEngine(),this._lazy=h.lazy??!1,this._updatable=h.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=h.colorPointers??[],this._widths=h.widths??new Array(h.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(m){let S=0;for(const l of this._points)S+=l.length;const h=S/3*2-this._widths.length;for(let l=0;l<h;l++)this._widths.push(m)}updateLazy(){var m,S;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(m=this._options.ribbonOptions)||void 0===m?void 0:m.smoothShading),!this.Pm&&this.refreshBoundingInfo(),null===(S=this.greasedLineMaterial)||void 0===S||S.updateLazy()}addPoints(m,S){for(const h of m)this._points.push(h);this._lazy||this.setPoints(this._points,S)}dispose(m){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(m,S)}isLazy(){return this._lazy}get Gm(){return this._uvs}set Gm(m){this._uvs=m instanceof Float32Array?m:new Float32Array(m),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(m){this.material instanceof Nm&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===m||void 0===m?void 0:m.length)>0),this._offsets=m,this._offsetsBuffer?this._offsetsBuffer.update(m):this._createOffsetsBuffer(m)}get widths(){return this._widths}set widths(m){this._widths=m,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(m)}get colorPointers(){return this._colorPointers}set colorPointers(m){this._colorPointers=m,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(m)}get greasedLineMaterial(){var m,S;if(this.material&&this.material instanceof Nm)return this.material;const h=null===(m=this.material)||void 0===m||null===(S=m.pluginManager)||void 0===S?void 0:S.getPlugin(am.GREASED_LINE_MATERIAL_NAME);return h||void 0}get points(){const m=[];return Pm.e.DeepCopy(this._points,m),m}setPoints(m,S){this._points=Gm.ConvertPoints(m,(null===S||void 0===S?void 0:S.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==S&&void 0!==S&&S.colorPointers||this._updateColorPointers(),this._setPoints(this._points,S)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Gm:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(m){super.serialize(m),m.type=this.getClassName(),m.lineOptions=this._createLineOptions()}_createVertexBuffers(){let m=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new xm.c;return S.Tm=this._vertexPositions,S.indices=this._indices,S.Gm=this._uvs,m&&(S.Xm=[],xm.c.ComputeNormals(this._vertexPositions,this._indices,S.Xm)),S.xm(this,this._options.updatable),S}_createOffsetsBuffer(m){const S=this._scene.getEngine(),h=new V.b(S,m,this._updatable,3);this.setVerticesBuffer(h.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=h}}class pm{constructor(m,S){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=m,this.wasAddedByNoopNode=S}getIndicesAccessor(m,S,h,l,M){var O,u,b,q;return null===(O=this._indicesAccessorMap.get(m))||void 0===O||null===(u=O.get(S))||void 0===u||null===(b=u.get(h))||void 0===b||null===(q=b.get(l))||void 0===q?void 0:q.get(M)}setIndicesAccessor(m,S,h,l,M,O){let u=this._indicesAccessorMap.get(m);u||(u=new Map,this._indicesAccessorMap.set(m,u));let b=u.get(S);b||(b=new Map,u.set(S,b));let q=b.get(h);q||(q=new Map,b.set(h,q));let Y=q.get(l);Y||(Y=new Map,q.set(l,Y)),Y.set(M,O)}pushExportedNode(m){this._exportedNodes.has(m)||this._exportedNodes.add(m)}getNodesSet(){return this._exportedNodes}getVertexBufferView(m){return this._vertexBufferViewMap.get(m)}setVertexBufferView(m,S){this._vertexBufferViewMap.set(m,S)}setRemappedBufferView(m,S,h){this._remappedBufferView.set(m,new Map),this._remappedBufferView.get(m).set(S,h)}getRemappedBufferView(m,S){var h;return null===(h=this._remappedBufferView.get(m))||void 0===h?void 0:h.get(S)}getVertexAccessor(m,S,h){var l,M;return null===(l=this._vertexAccessorMap.get(m))||void 0===l||null===(M=l.get(S))||void 0===M?void 0:M.get(h)}setVertexAccessor(m,S,h,l){let M=this._vertexAccessorMap.get(m);M||(M=new Map,this._vertexAccessorMap.set(m,M));let O=M.get(S);O||(O=new Map,M.set(S,O)),O.set(h,l)}hasVertexColorAlpha(m){return this._vertexMapColorAlpha.get(m)||!1}setHasVertexColorAlpha(m,S){return this._vertexMapColorAlpha.set(m,S)}getMesh(m){return this._meshMap.get(m)}setMesh(m,S){this._meshMap.set(m,S)}bindMorphDataToMesh(m,S){const h=this._meshMorphTargetMap.get(m)||[];this._meshMorphTargetMap.set(m,h),-1===h.indexOf(S)&&h.push(S)}getMorphTargetsFromMesh(m){return this._meshMorphTargetMap.get(m)}}class km{_ApplyExtension(m,S,h,l){if(h>=S.length)return Promise.resolve(m);const M=l(S[h],m);return M?M.then((async m=>m?await this._ApplyExtension(m,S,h+1,l):null)):this._ApplyExtension(m,S,h+1,l)}_ApplyExtensions(m,S){const h=[];for(const l of km._ExtensionNames)h.push(this._extensions[l]);return this._ApplyExtension(m,h,0,S)}_extensionsPreExportTextureAsync(m,S,h){return this._ApplyExtensions(S,((S,l)=>S.preExportTextureAsync&&S.preExportTextureAsync(m,l,h)))}_extensionsPostExportNodeAsync(m,S,h,l,M){return this._ApplyExtensions(S,((S,O)=>S.postExportNodeAsync&&S.postExportNodeAsync(m,O,h,l,M,this._bufferManager)))}_extensionsPostExportMaterialAsync(m,S,h){return this._ApplyExtensions(S,((S,l)=>S.postExportMaterialAsync&&S.postExportMaterialAsync(m,l,h)))}_extensionsPostExportMaterialAdditionalTextures(m,S,h){const l=[];for(const M of km._ExtensionNames){const O=this._extensions[M];O.postExportMaterialAdditionalTextures&&l.push(...O.postExportMaterialAdditionalTextures(m,S,h))}return l}_extensionsPostExportTextures(m,S,h){for(const l of km._ExtensionNames){const M=this._extensions[l];M.postExportTexture&&M.postExportTexture(m,S,h)}}_extensionsPostExportMeshPrimitive(m){for(const S of km._ExtensionNames){const h=this._extensions[S];h.postExportMeshPrimitive&&h.postExportMeshPrimitive(m,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const m of km._ExtensionNames){const S=this._extensions[m];S.preGenerateBinaryAsync&&await S.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(m){for(const S of km._ExtensionNames){const h=this._extensions[S];h.enabled&&m(h)}}_extensionsOnExporting(){this._forEachExtensions((m=>{var S,h,l;m.wasUsed&&((S=this._glTF).extensionsUsed||(S.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(m.name)&&this._glTF.extensionsUsed.push(m.name),m.required&&((h=this._glTF).extensionsRequired||(h.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(m.name)&&this._glTF.extensionsRequired.push(m.name)),(l=this._glTF).extensions||(l.extensions={}),m.onExporting&&m.onExporting())}))}_loadExtensions(){for(const m of km._ExtensionNames){const S=km._ExtensionFactories[m](this);this._extensions[m]=S}}constructor(){let m=arguments.length>0&&void 0!==arguments[0]?arguments[0]:D.d.LastCreatedScene,S=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${B.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new J(this),this._extensions={},this._bufferManager=new Vm,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!m)throw new Error("No scene available to export");this._babylonScene=m,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:m=>{var S;return null===m||void 0===m||null===(S=m.th)||void 0===S?void 0:S.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...S},this._loadExtensions()}dispose(){for(const m in this._extensions){this._extensions[m].dispose()}}get options(){return this._options}static RegisterExtension(m,S){km.UnregisterExtension(m)&&M.Tools.Warn(`Extension with the name ${m} already exists`),km._ExtensionFactories[m]=S,km._ExtensionNames.push(m)}static UnregisterExtension(m){if(!km._ExtensionFactories[m])return!1;delete km._ExtensionFactories[m];const S=km._ExtensionNames.indexOf(m);return-1!==S&&km._ExtensionNames.splice(S,1),!0}_generateJSON(m,S,h){const l={byteLength:m};return l.byteLength&&(this._glTF.buffers=[l]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.US=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(l.uri=S+".bin"),h?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(m){const S=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(S.byteLength,m,!0),l=new Blob([S],{type:"application/octet-stream"}),M=m+".gltf",O=m+".bin",u=new Y;if(u.files[M]=h,u.files[O]=l,this._imageData)for(const b in this._imageData)u.files[b]=new Blob([this._imageData[b].data],{type:this._imageData[b].mimeType});return u}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(m){const S=m%4;return 0===S?S:4-S}async generateGLBAsync(m){this._shouldUseGlb=!0;const S=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(S.byteLength),l=m+".glb";let M,O=h.length;if("undefined"!==typeof TextEncoder){M=(new TextEncoder).encode(h),O=M.length}const u=this._getPadding(O),b=this._getPadding(S.byteLength),q=28+O+u+S.byteLength+b,V=new qm(q);if(V.writeUInt32(1179937895),V.writeUInt32(2),V.writeUInt32(q),V.writeUInt32(O+u),V.writeUInt32(1313821514),M)V.writeTypedArray(M);else{const m="_".charCodeAt(0);for(let S=0;S<O;++S){const l=h.charCodeAt(S);l!=h.codePointAt(S)?V.writeUInt8(m):V.writeUInt8(l)}}for(let Y=0;Y<u;++Y)V.writeUInt8(32);V.writeUInt32(S.byteLength+b),V.writeUInt32(5130562),V.writeTypedArray(S);for(let Y=0;Y<b;++Y)V.writeUInt8(0);const I=new Y;return I.files[l]=new Blob([V.getOutputData()],{type:"application/octet-stream"}),I}_setNodeTransformation(m,S,h){if(S.getPivotPoint().equalsWithEpsilon(f,c.d)||M.Tools.Warn("Pivot points are not supported in the glTF serializer"),!S.position.equalsWithEpsilon(f,c.d)){const M=l.TmpVectors.nS[0].l(S.position);h&&A(M),m.translation=M.DM()}S.Ib.equalsWithEpsilon(k,c.d)||(m.scale=S.Ib.DM());const O=S.rotationQuaternion||l.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);O.equalsWithEpsilon(p,c.d)||(h&&i(O),m.rotation=O.normalize().DM())}_setCameraTransformation(m,S,h){if(!S.position.equalsWithEpsilon(f,c.d)){const M=l.TmpVectors.nS[0].l(S.position);h&&A(M),m.translation=M.DM()}const M=S.rotationQuaternion||l.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);h&&i(M),this._babylonScene.useRightHandedSystem||W(M),M.equalsWithEpsilon(p,c.d)||(m.rotation=M.DM())}_listAvailableCameras(){for(const m of this._babylonScene.cameras){const S={type:m.mode===Zm.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(m.name&&(S.name=m.name),"perspective"===S.type)S.perspective={aspectRatio:m.getEngine().getAspectRatio(m),yfov:m.fovMode===Zm.d.FOVMODE_VERTICAL_FIXED?m.fov:m.fov*m.getEngine().getAspectRatio(m),znear:m.hb,zfar:m.maxZ};else if("orthographic"===S.type){const h=m.orthoLeft&&m.orthoRight?.5*(m.orthoRight-m.orthoLeft):.5*m.getEngine().getRenderWidth(),l=m.orthoBottom&&m.orthoTop?.5*(m.orthoTop-m.orthoBottom):.5*m.getEngine().getRenderHeight();S.orthographic={xmag:h,ymag:l,znear:m.hb,zfar:m.maxZ}}this._camerasMap.set(m,S)}}_exportAndAssignCameras(){const m=Array.from(this._camerasMap.values());for(const S of m){const m=this._nodesCameraMap.get(S);if(void 0!==m){this._cameras.push(S);for(const S of m)S.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const m of this._babylonScene.skeletons){if(m.bones.length<=0)continue;const S={joints:[]};this._skinMap.set(m,S)}}_exportAndAssignSkeletons(){for(const m of this._babylonScene.skeletons){if(m.bones.length<=0)continue;const S=this._skinMap.get(m);if(void 0==S)continue;const h={},l=[];let O=-1;for(let M=0;M<m.bones.length;++M){const S=m.bones[M],l=S.getIndex()??M;-1!==l&&(h[l]=S,l>O&&(O=l))}for(let m=0;m<=O;++m){const O=h[m];l.push(O.getAbsoluteInverseBindMatrix());const u=O.getTransformNode();if(null!==u){const m=this._nodeMap.get(u);u&&null!==m&&void 0!==m?S.joints.push(m):M.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else M.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const u=this._nodesSkinMap.get(S);if(S.joints.length>0&&void 0!==u){const m=64*l.length,h=new Float32Array(m/4);l.forEach(((m,S)=>{h.set(m.m,16*S)}));const M=this._bufferManager.createBufferView(h);this._accessors.push(this._bufferManager.createAccessor(M,"MAT4",5126,l.length)),S.inverseBindMatrices=this._accessors.length-1,this._skins.push(S);for(const S of u)S.skin=this._skins.length-1}}}async _exportSceneAsync(){const m={nodes:[]};if(this._babylonScene.metadata){const S=this._options.metadataSelector(this._babylonScene.metadata);S&&(m.extras=S)}const S=new Array,h=new Array,l=new Array;for(const b of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&um(b,this._babylonScene.useRightHandedSystem)?l.push(...b.getChildren()):this._babylonScene.useRightHandedSystem?S.push(b):h.push(b);this._listAvailableCameras(),this._listAvailableSkeletons();const M=new pm(!0,!1);m.nodes.push(...await this._exportNodesAsync(h,M));const O=new pm(!1,!1);m.nodes.push(...await this._exportNodesAsync(S,O));const u=new pm(!1,!0);m.nodes.push(...await this._exportNodesAsync(l,u)),m.nodes.length&&this._scenes.push(m),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Hm._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,M.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(m){let S=this._shouldExportNodeMap.get(m);return void 0===S&&(S=this._options.shouldExportNode(m),this._shouldExportNodeMap.set(m,S)),S}async _exportNodesAsync(m,S){const h=new Array;this._exportBuffers(m,S);for(const l of m)await this._exportNodeAsync(l,h,S);return h}_collectBuffers(m,S,h,l,M){if(this._shouldExportNode(m)&&m instanceof Z.e&&m.ub){const O=m.ub.getVertexBuffers();if(O)for(const l in O){if(!F(l))continue;const u=O[l];M.setHasVertexColorAlpha(u,m.hasVertexAlpha);const b=u._buffer,q=S.get(b)||[];S.set(b,q),-1===q.indexOf(u)&&q.push(u);const Y=h.get(u)||[];h.set(u,Y),-1===Y.indexOf(m)&&Y.push(m)}const u=m.morphTargetManager;if(u)for(let S=0;S<u.numTargets;S++){const h=u.getTarget(S),M=l.get(h)||[];l.set(h,M),-1===M.indexOf(m)&&M.push(m)}}for(const O of m.getChildren())this._collectBuffers(O,S,h,l,M)}_exportBuffers(m,S){const h=new Map,l=new Map,M=new Map;for(const b of m)this._collectBuffers(b,h,l,M,S);const O=Array.from(h.keys());for(const b of O){const m=b.getData();if(!m)throw new Error("Buffer data is not available");const M=h.get(b);if(!M)continue;const O=M[0].byteStride;if(M.some((m=>m.byteStride!==O)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const u=hm(m).slice();for(const S of M){const m=l.get(S),{byteOffset:h,byteStride:M,componentCount:O,type:b,count:q,normalized:Y,kind:I}=z(S,m);switch(I){case V.f.NormalKind:case V.f.TangentKind:(0,N.h)(u,h,M,O,b,q,Y,(m=>{const S=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);if(S>0){const h=1/S;m[0]*=h,m[1]*=h,m[2]*=h}}));break;case V.f.ColorKind:{const S=m.filter((m=>m.material instanceof Dm.HS||null==m.material)).length;if(0==S)break;if(S!=m.length){j.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}b==V.f.UNSIGNED_BYTE&&j.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const l=new E.RS,I=new E.Bb,Z=this._babylonScene.getEngine().useExactSrgbConversions;(0,N.h)(u,h,M,O,b,q,Y,(m=>{3===m.length?(l.yh(m,0),l.toLinearSpaceToRef(l,Z),l.toArray(m,0)):(I.yh(m,0),I.toLinearSpaceToRef(I,Z),I.toArray(m,0))}))}}}if(S.convertToRightHanded){for(const m of M){const S=l.get(m),{byteOffset:h,byteStride:M,componentCount:O,type:b,count:q,normalized:Y,kind:I}=z(m,S);switch(I){case V.f.PositionKind:case V.f.NormalKind:case V.f.TangentKind:(0,N.h)(u,h,M,O,b,q,Y,(m=>{m[0]=-m[0]}))}}S.convertedToRightHandedBuffers.set(b,u)}const q=this._bufferManager.createBufferView(u,O);S.setVertexBufferView(b,q);const Y=new Map;for(const S of M){const m=l.get(S),{kind:h,totalVertices:M}=z(S,m);switch(h){case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:if(S.type==V.f.FLOAT){const m=S.getFloatData(M);null!==m&&Y.set(S,m)}}}0!==Y.size&&j.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const I=Array.from(Y.keys());for(const h of I){const m=Y.get(h);if(!m)continue;const l=m.some((m=>m>=256)),M=new(l?Uint16Array:Uint8Array)(m.length);for(let S=0;S<m.length;S++)M[S]=m[S];const O=this._bufferManager.createBufferView(M,4*(l?2:1));S.setRemappedBufferView(b,h,O)}}const u=Array.from(M.keys());for(const b of u){const m=M.get(b);if(!m)continue;const h=Rm(b,m[0],this._bufferManager,this._bufferViews,this._accessors,S.convertToRightHanded);for(const l of m)S.bindMorphDataToMesh(l,h)}}async _exportNodeAsync(m,S,h){let l=this._nodeMap.get(m);if(void 0!==l)return void(S.includes(l)||S.push(l));const M=await this._createNodeAsync(m,h);if(M){l=this._nodes.length,this._nodes.push(M),this._nodeMap.set(m,l),h.pushExportedNode(m),S.push(l);const O={name:"runtime animations",channels:[],samplers:[]},u=[];this._babylonScene.animationGroups.length||(Hm._CreateMorphTargetAnimationFromMorphTargetAnimations(m,O,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation),m.animations.length&&Hm._CreateNodeAnimationFromNodeAnimations(m,O,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation)),O.channels.length&&O.samplers.length&&this._animations.push(O),u.forEach((m=>{m.channels.length&&m.samplers.length&&this._animations.push(m)}))}const O=M?[]:S;for(const u of m.getChildren())await this._exportNodeAsync(u,O,h);M&&O.length&&(M.children=O)}async _createNodeAsync(m,S){if(!this._shouldExportNode(m))return null;const h={};if(m.name&&(h.name=m.name),m.metadata){const S=this._options.metadataSelector(m.metadata);S&&(h.extras=S)}if(m instanceof I.d&&(this._setNodeTransformation(h,m,S.convertToRightHanded),m instanceof Z.e)){const M=m instanceof C.c?m.sourceMesh:m;if(M.CM&&M.CM.length>0&&(h.mesh=await this._exportMeshAsync(M,S)),m.skeleton){const S=this._skinMap.get(m.skeleton);var l;if(void 0!==S)void 0===this._nodesSkinMap.get(S)&&this._nodesSkinMap.set(S,[]),null===(l=this._nodesSkinMap.get(S))||void 0===l||l.push(h)}}if(m instanceof K.c){const l=this._camerasMap.get(m);if(l){var M;void 0===this._nodesCameraMap.get(l)&&this._nodesCameraMap.set(l,[]),this._setCameraTransformation(h,m,S.convertToRightHanded);const u=m.parent;if(null!==u&&Sm(m,u)){const m=this._nodeMap.get(u);if(void 0!==m){var O;const S=this._nodes[m];return mm(h,S),null===(O=this._nodesCameraMap.get(l))||void 0===O||O.push(S),null}}null===(M=this._nodesCameraMap.get(l))||void 0===M||M.push(h)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",h,m,this._nodeMap,S.convertToRightHanded)?h:(j.e.Warn(`Not exporting node ${m.name}`),null)}_exportIndices(m,S,h,l,M,u,b,q,Y){let V=m;Y.mode=w(u);const I=b!==O.e.CounterClockWiseSideOrientation,Z=!q.wasAddedByNoopNode&&I,C=function(m){switch(m){case O.e.TriangleFillMode:case O.e.TriangleStripDrawMode:case O.e.TriangleFanDrawMode:return!0}return!1}(u)&&Z;if(C){if(u===O.e.TriangleStripDrawMode||u===O.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");Y.mode=w(u);const b=S?new Uint32Array(l):new Uint16Array(l);if(m)for(let S=0;S+2<l;S+=3)b[S]=m[h+S]+M,b[S+1]=m[h+S+2]+M,b[S+2]=m[h+S+1]+M;else for(let m=0;m+2<l;m+=3)b[m]=m,b[m+1]=m+2,b[m+2]=m+1;V=b}else if(m&&0!==M){const O=S?new Uint32Array(l):new Uint16Array(l);for(let S=0;S<l;S++)O[S]=m[h+S]+M;V=O}if(V){let O=q.getIndicesAccessor(m,h,l,M,C);if(void 0===O){const u=function(m,S,h,l){if(m instanceof Uint16Array||m instanceof Uint32Array)return m;if(m instanceof Int32Array)return new Uint32Array(m.buffer,m.byteOffset,m.length);const M=m.slice(S,S+h);return l?new Uint32Array(M):new Uint16Array(M)}(V,0,l,S),b=this._bufferManager.createBufferView(u),Y=S?5125:5123;this._accessors.push(this._bufferManager.createAccessor(b,"SCALAR",Y,l,0)),O=this._accessors.length-1,q.setIndicesAccessor(m,h,l,M,C,O)}Y.indices=O}}_exportVertexBuffer(m,S,h,l,M,O){const u=m.getKind();if(!F(u))return;if(u.startsWith("uv")&&!this._options.exportUnusedUVs&&(!S||!this._materialNeedsUVsSet.has(S)))return;let b=M.getVertexAccessor(m,h,l);if(void 0===b){const S=M.convertedToRightHandedBuffers.get(m._buffer)||m._buffer.getData(),O=u===V.f.PositionKind?function(m,S,h,l){const{byteOffset:M,byteStride:O,type:u,normalized:b}=S,q=S.getSize(),Y=new Array(q).fill(1/0),V=new Array(q).fill(-1/0);return(0,N.h)(m,M+h*O,O,q,u,l*q,b,(m=>{for(let S=0;S<q;S++)Y[S]=Math.min(Y[S],m[S]),V[S]=Math.max(V[S],m[S])})),{min:Y,max:V}}(S,m,h,l):void 0,q=(u===V.f.MatricesIndicesKind||u===V.f.MatricesIndicesExtraKind)&&m.type===V.f.FLOAT,Y=q?V.f.UNSIGNED_BYTE:m.type,I=q?void 0:m.normalized,Z=q?M.getRemappedBufferView(m._buffer,m):M.getVertexBufferView(m._buffer),C=m.byteOffset+h*m.byteStride;this._accessors.push(this._bufferManager.createAccessor(Z,function(m,S){if(m==V.f.ColorKind)return S?"VEC4":"VEC3";switch(m){case V.f.PositionKind:case V.f.NormalKind:return"VEC3";case V.f.TangentKind:case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:case V.f.MatricesWeightsKind:case V.f.MatricesWeightsExtraKind:return"VEC4";case V.f.UVKind:case V.f.UV2Kind:case V.f.UV3Kind:case V.f.UV4Kind:case V.f.UV5Kind:case V.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${m}`)}(u,M.hasVertexColorAlpha(m)),Y,l,C,O,I)),b=this._accessors.length-1,M.setVertexAccessor(m,h,l,b)}O.attributes[function(m){switch(m){case V.f.PositionKind:return"POSITION";case V.f.NormalKind:return"NORMAL";case V.f.TangentKind:return"TANGENT";case V.f.ColorKind:return"COLOR_0";case V.f.UVKind:return"TEXCOORD_0";case V.f.UV2Kind:return"TEXCOORD_1";case V.f.UV3Kind:return"TEXCOORD_2";case V.f.UV4Kind:return"TEXCOORD_3";case V.f.UV5Kind:return"TEXCOORD_4";case V.f.UV6Kind:return"TEXCOORD_5";case V.f.MatricesIndicesKind:return"JOINTS_0";case V.f.MatricesIndicesExtraKind:return"JOINTS_1";case V.f.MatricesWeightsKind:return"WEIGHTS_0";case V.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${m}`)}(u)]=b}async _exportMaterialAsync(m,S,h,l){let M=this._materialMap.get(m);if(void 0===M){const l=S&&Object.keys(S).some((m=>m.startsWith("uv")));if((m=m instanceof Cm.d?m.Db[h.materialIndex]:m)instanceof Bm.c)M=await this._materialExporter.exportPBRMaterialAsync(m,"image/png",l);else{if(!(m instanceof Dm.HS))return void j.e.Warn(`Unsupported material '${m.name}' with type ${m.getClassName()}`);M=await this._materialExporter.exportStandardMaterialAsync(m,"image/png",l)}this._materialMap.set(m,M)}l.material=M}async _exportMeshAsync(m,S){var h;let l=S.getMesh(m);if(void 0!==l)return l;const M={primitives:[]};l=this._meshes.length,this._meshes.push(M),S.setMesh(m,l);const u=m.isUnIndexed?null:m.bb(),b=null===(h=m.ub)||void 0===h?void 0:h.getVertexBuffers(),q=S.getMorphTargetsFromMesh(m),Y=m instanceof ym.c,V=m instanceof fm,I=m.CM;if(b&&I&&I.length>0)for(const B of I){const h={attributes:{}},l=B.jm()||this._babylonScene.defaultMaterial;if(V){var Z,C;const S={name:l.name},M=m,O=E.RS.White(),u=(null===(Z=M.material)||void 0===Z?void 0:Z.alpha)??1,b=(null===(C=M.greasedLineMaterial)||void 0===C?void 0:C.color)??O;(!b.equalsWithEpsilon(O,c.d)||u<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...b.DM(),u]}),this._materials.push(S),h.material=this._materials.length-1}else if(Y){const S={name:l.name},M=m;(!M.color.equalsWithEpsilon(E.RS.White(),c.d)||M.alpha<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...M.color.DM(),M.alpha]}),this._materials.push(S),h.material=this._materials.length-1}else await this._exportMaterialAsync(l,b,B,h);const I=Y||V?O.e.LineListDrawMode:m.overrideRenderingFillMode??l.fillMode,D=l._getEffectiveOrientation(m);this._exportIndices(u,u?(0,N.b)(u,B.indexCount,B.indexStart,B.verticesStart):B.verticesCount>65535,u?B.indexStart:B.verticesStart,u?B.indexCount:B.verticesCount,-B.verticesStart,I,D,S,h);for(const m of Object.values(b))this._exportVertexBuffer(m,l,B.verticesStart,B.verticesCount,S,h);if(q){h.targets=[];for(const m of q)h.targets.push(m.attributes)}M.primitives.push(h),this._extensionsPostExportMeshPrimitive(h)}if(q){M.weights=[],M.extras||(M.extras={}),M.extras.targetNames=[];for(const m of q)M.weights.push(m.influence),M.extras.targetNames.push(m.name)}return l}}km._ExtensionNames=new Array,km._ExtensionFactories={};class rm{static async GLTFAsync(m,S,h){h&&h.exportWithoutWaitingForScene||await m.whenReadyAsync();const l=new km(m,h),M=await l.generateGLTFAsync(S.replace(/\.[^/.]+$/,""));return l.dispose(),M}static async GLBAsync(m,S,h){h&&h.exportWithoutWaitingForScene||await m.whenReadyAsync();const l=new km(m,h),M=await l.generateGLBAsync(S.replace(/\.[^/.]+$/,""));return l.dispose(),M}}h(11877);const zm="EXT_mesh_gpu_instancing";class Qm{constructor(m){this.name=zm,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(m,S,h,M,O,u){return await new Promise((m=>{if(S&&h instanceof Lm.c&&h.hasThinInstances&&this._exporter){this._wasUsed=!0;const m=l.nS.Zero(),M=l.Quaternion.Identity(),b=l.nS.One(),q=h.thinInstanceGetWorldMatrices(),Y=l.TmpVectors.nS[2],V=l.TmpVectors.Quaternion[1],I=l.TmpVectors.nS[3];let Z=!1,C=!1,B=!1;const D=new Float32Array(3*h.Eb),E=new Float32Array(4*h.Eb),n=new Float32Array(3*h.Eb);let L=0;for(const S of q)S.decompose(I,V,Y),O&&(A(Y),i(V)),D.set(Y.DM(),3*L),E.set(V.normalize().DM(),4*L),n.set(I.DM(),3*L),Z=Z||!Y.equalsWithEpsilon(m),C=C||!V.equalsWithEpsilon(M),B=B||!I.equalsWithEpsilon(b),L++;const U={attributes:{}};Z&&(U.attributes.TRANSLATION=this._buildAccessor(D,"VEC3",h.Eb,u)),C&&(U.attributes.ROTATION=this._buildAccessor(E,"VEC4",h.Eb,u)),B&&(U.attributes.SCALE=this._buildAccessor(n,"VEC3",h.Eb,u)),S.extensions=S.extensions||{},S.extensions[zm]=U}m(S)}))}_buildAccessor(m,S,h,l){const M=l.createBufferView(m),O=l.createAccessor(M,S,5126,h);return this._exporter._accessors.push(O),this._exporter._accessors.length-1}}km.RegisterExtension(zm,(m=>new Qm(m)));var Fm=h(11886),wm=h(11900),tm=h(11907),Am=h(11912);function im(m){return m===tm.c.PositionKind?"POSITION":m===tm.c.NormalKind?"NORMAL":m===tm.c.ColorKind?"COLOR":m.startsWith(tm.c.UVKind)?"TEX_COORD":"GENERIC"}const Wm={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class mS extends Fm.c{static get DefaultAvailable(){return(0,Fm.g)(mS.DefaultConfiguration)}static get Default(){return mS._Default??(mS._Default=new mS),mS._Default}static ResetDefault(m){mS._Default&&(m||mS._Default.dispose(),mS._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(m,S){return{module:await(S||DracoEncoderModule)({wasmBinary:m})}}_getWorkerContent(){return`${wm.j}(${wm.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:mS.DefaultConfiguration)}async _encodeAsync(m,S,h){const l=h?(0,Am.b)(Wm,h):Wm;if(this._workerPoolPromise){const h=await this._workerPoolPromise;return await new Promise(((M,O)=>{h.push(((h,u)=>{const b=m=>{h.removeEventListener("error",b),h.removeEventListener("message",q),O(m),u()},q=m=>{"encodeMeshDone"===m.data.id&&(h.removeEventListener("error",b),h.removeEventListener("message",q),M(m.data.encodedMeshData),u())};h.addEventListener("error",b),h.addEventListener("message",q);const Y=[];for(const S of m)Y.push(S.data.buffer);S&&Y.push(S.buffer),h.postMessage({id:"encodeMesh",attributes:m,indices:S,options:l},Y)}))}))}if(this._modulePromise){const h=await this._modulePromise;return(0,wm.j)(h.module,m,S,l)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(m,S){if(0==m.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");m instanceof Lm.c&&m.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===S||void 0===S?void 0:S.method)&&(j.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),S.method="MESH_SEQUENTIAL_ENCODING");const h=function(m){let S=m.bb(void 0,!0);return!S||S instanceof Uint32Array||S instanceof Uint16Array||(S=((0,N.b)(S,S.length)?Uint32Array:Uint16Array).from(S)),S}(m),l=function(m,S){const h=[];for(const l of m.getVerticesDataKinds()){if(null!==S&&void 0!==S&&S.includes(l)){if(l===tm.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const M=m.getVertexBuffer(l),O=M.getSize(),u=(0,N.u)(M.getData(),O,M.type,M.byteOffset,M.byteStride,M.normalized,m.getTotalVertices(),!0);h.push({kind:l,dracoName:im(l),size:O,data:u})}return h}(m,null===S||void 0===S?void 0:S.excludedAttributes);return await this._encodeAsync(l,h,S)}}mS.DefaultConfiguration={wasmUrl:`${M.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${M.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${M.Tools._DefaultCdnUrl}/draco_encoder.js`},mS._Default=null;const SS="KHR_draco_mesh_compression";class hS{get wasUsed(){return this._wasUsed}constructor(m){this.name=SS,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===m.options.meshCompressionMethod&&mS.DefaultAvailable}dispose(){}postExportMeshPrimitive(m,S,h){if(!this.enabled)return;if(4!==m.mode&&5!==m.mode)return void j.e.Warn("Cannot compress primitive with mode "+m.mode+".");const l=[],M=[];let O=null;if(void 0!==m.indices){const u=h[m.indices],b=S.getBufferView(u);O=S.getData(b).slice(),l.push(b),M.push(u)}const u=[];for(const[V,I]of Object.entries(m.attributes)){const m=h[I],O=S.getBufferView(m),q=Q(m.type),Y=(0,N.u)(S.getData(O),q,m.componentType,m.byteOffset||0,O.byteStride||(0,N.n)(m.componentType)*q,m.normalized||!1,m.count,!0);u.push({kind:V,dracoName:(b=V,"POSITION"===b?"POSITION":"NORMAL"===b?"NORMAL":b.startsWith("COLOR")?"COLOR":b.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Q(m.type),data:Y}),l.push(O),M.push(m)}var b;const q={method:m.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},Y=mS.Default._encodeAsync(u,O,q).then((h=>{if(!h)return void j.e.Error("Draco encoding failed for primitive.");const O={bufferView:-1,attributes:h.attributeIds},u=S.createBufferView(h.data);S.setBufferView(O,u);for(const m of l)this._bufferViewsUsed.add(m);for(const m of M)this._accessorsUsed.add(m);m.extensions||(m.extensions={}),m.extensions[SS]=O})).catch((m=>{j.e.Error("Draco encoding failed for primitive: "+m)}));this._encodePromises.push(Y),this._wasUsed=!0}async preGenerateBinaryAsync(m){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((S=>{m.getPropertiesWithBufferView(S).every((m=>this._accessorsUsed.has(m)))&&m.removeBufferView(S)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}km.RegisterExtension(SS,(m=>new hS(m)));var lS=h(11916);const MS="KHR_lights_punctual",OS={name:"",color:[1,1,1],nb:1,range:Number.MAX_VALUE},uS={innerConeAngle:0,outerConeAngle:Math.PI/4},bS=l.nS.Backward();class qS{constructor(m){this.name=MS,this.enabled=!0,this.required=!1,this._exporter=m}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[MS]=this._lights}async postExportNodeAsync(m,S,h,M,O){return await new Promise((u=>{if(!(h instanceof Um.b))return void u(S);const b=h.getTypeID()==Um.b.LIGHTTYPEID_POINTLIGHT?"point":h.getTypeID()==Um.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":h.getTypeID()==Um.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!b||!(h instanceof lS.c))return j.e.Warn(`${m}: Light ${h.name} is not supported in ${MS}`),void u(S);if(h.falloffType!==Um.b.FALLOFF_GLTF&&j.e.Warn(`${m}: Light falloff for ${h.name} does not match the ${MS} specification!`),!h.position.equalsToFloats(0,0,0)){const m=l.TmpVectors.nS[0].l(h.position);O&&A(m),S.translation=m.DM()}if("point"!==b){const m=h.direction.normalizeToRef(l.TmpVectors.nS[0]);O&&A(m);const M=l.Quaternion.FromUnitVectorsToRef(bS,m,l.TmpVectors.Quaternion[0]);l.Quaternion.IsIdentity(M)||(S.rotation=M.DM())}const q={type:b,name:h.name,color:h.Lb.DM(),nb:h.nb,range:h.range};if(lm(q,OS),"spot"===b){const m=h;q.spot={innerConeAngle:m.innerAngle/2,outerConeAngle:m.angle/2},lm(q.spot,uS)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(q);const Y={Dh:this._lights.lights.length-1},V=h.parent;if(V&&Sm(h,V)){const m=M.get(V);if(m){const h=this._exporter._nodes[m];return mm(S,h),h.extensions||(h.extensions={}),h.extensions[MS]=Y,void u(null)}}S.extensions||(S.extensions={}),S.extensions[MS]=Y,u(S)}))}}km.RegisterExtension(MS,(m=>new qS(m)));var YS=h(11814);const VS="KHR_materials_anisotropy";class IS{constructor(m){this.name=VS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof YS.e&&h.anisotropy.isEnabled&&!h.anisotropy.legacy?(h.anisotropy.texture&&l.push(h.anisotropy.texture),l):[]}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof YS.e){if(!h.anisotropy.isEnabled||h.anisotropy.legacy)return void m(S);this._wasUsed=!0,S.extensions=S.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(h.anisotropy.texture),M={anisotropyStrength:h.anisotropy.nb,anisotropyRotation:h.anisotropy.angle,anisotropyTexture:l??void 0};null!==M.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(h),S.extensions[VS]=M}m(S)}))}}km.RegisterExtension(VS,(m=>new IS(m)));const ZS="KHR_materials_clearcoat";class CS{constructor(m){this.name=ZS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof YS.e&&h.clearCoat.isEnabled?(h.clearCoat.texture&&l.push(h.clearCoat.texture),!h.clearCoat.useRoughnessFromMainTexture&&h.clearCoat.textureRoughness&&l.push(h.clearCoat.textureRoughness),h.clearCoat.bumpTexture&&l.push(h.clearCoat.bumpTexture),l):[]}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof YS.e){if(!h.clearCoat.isEnabled)return void m(S);this._wasUsed=!0,S.extensions=S.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture);let O;O=h.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(h.clearCoat.textureRoughness),h.clearCoat.isTintEnabled&&M.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${h.name}`),h.clearCoat.remapF0OnInterfaceChange&&M.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${h.name}`);const u=this._exporter._materialExporter.getTextureInfo(h.clearCoat.bumpTexture),b={clearcoatFactor:h.clearCoat.nb,clearcoatTexture:l??void 0,clearcoatRoughnessFactor:h.clearCoat.roughness,clearcoatRoughnessTexture:O??void 0,clearcoatNormalTexture:u??void 0};null===b.clearcoatTexture&&null===b.clearcoatRoughnessTexture&&null===b.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),S.extensions[ZS]=b}m(S)}))}}km.RegisterExtension(ZS,(m=>new CS(m)));const BS="KHR_materials_diffuse_transmission";function DS(m,S){const h=S.subSurface;let l=null;return h.translucencyIntensityTexture?l=h.translucencyIntensityTexture:h.thicknessTexture&&h.useMaskFromThicknessTexture&&(l=h.thicknessTexture),l&&!h.useGltfStyleTextures?(j.e.Warn(`${m}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${S.name}`,1),null):l}class ES{constructor(m){this.name=BS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];if(h instanceof Bm.c&&this._isExtensionEnabled(h)){const S=DS(m,h);return S&&l.push(S),h.subSurface.translucencyColorTexture&&l.push(h.subSurface.translucencyColorTexture),l}return l}_isExtensionEnabled(m){if(m.unlit)return!1;const S=m.subSurface;return!!S.isTranslucencyEnabled&&(!m.unlit&&!S.useAlbedoToTintTranslucency&&S.useGltfStyleTextures&&1===S.volumeIndexOfRefraction&&0===S.minimumThickness&&0===S.maximumThickness)}postExportMaterialAsync(m,S,h){return new Promise((l=>{if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const l=h.subSurface,M=DS(m,h),O=0==l.translucencyIntensity?void 0:l.translucencyIntensity,u=this._exporter._materialExporter.getTextureInfo(M)??void 0,b=!l.translucencyColor||l.translucencyColor.equalsFloats(1,1,1)?void 0:l.translucencyColor.DM(),q=this._exporter._materialExporter.getTextureInfo(l.translucencyColorTexture)??void 0,Y={diffuseTransmissionFactor:O,diffuseTransmissionTexture:u,diffuseTransmissionColorFactor:b,diffuseTransmissionColorTexture:q};(u||q)&&this._exporter._materialNeedsUVsSet.add(h),S.extensions=S.extensions||{},S.extensions[BS]=Y}l(S)}))}}km.RegisterExtension(BS,(m=>new ES(m)));const nS="KHR_materials_dispersion";class LS{constructor(){this.name=nS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(m){if(m.unlit)return!1;const S=m.subSurface;return!(!S.isRefractionEnabled&&!S.isDispersionEnabled)}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const m={dispersion:h.subSurface.dispersion};S.extensions=S.extensions||{},S.extensions[nS]=m}m(S)}))}}km.RegisterExtension(nS,(()=>new LS));const US="KHR_materials_emissive_strength";class HS{constructor(){this.name=US,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(m,S,h){return await new Promise((m=>{if(!(h instanceof Bm.c))return m(S);const l=h.emissiveColor.DM(),M=Math.max(...l);if(M>1){this._wasUsed=!0,S.extensions||(S.extensions={});const m={emissiveStrength:M},l=h.emissiveColor.scale(1/m.emissiveStrength);S.emissiveFactor=l.DM(),S.extensions[US]=m}return m(S)}))}}km.RegisterExtension(US,(m=>new HS));const RS="KHR_materials_ior";class yS{constructor(){this.name=RS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(m){return!m.unlit&&(void 0!=m.indexOfRefraction&&1.5!=m.indexOfRefraction)}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const m={ior:h.indexOfRefraction};S.extensions=S.extensions||{},S.extensions[RS]=m}m(S)}))}}km.RegisterExtension(RS,(m=>new yS));const oS="KHR_materials_iridescence";class sS{constructor(m){this.name=oS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof YS.e&&h.iridescence.isEnabled?(h.iridescence.texture&&l.push(h.iridescence.texture),h.iridescence.thicknessTexture&&h.iridescence.thicknessTexture!==h.iridescence.texture&&l.push(h.iridescence.thicknessTexture),l):[]}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof YS.e){if(!h.iridescence.isEnabled)return void m(S);this._wasUsed=!0,S.extensions=S.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(h.iridescence.texture),M=this._exporter._materialExporter.getTextureInfo(h.iridescence.thicknessTexture),O={iridescenceFactor:h.iridescence.nb,iridescenceIor:h.iridescence.indexOfRefraction,iridescenceThicknessMinimum:h.iridescence.minimumThickness,iridescenceThicknessMaximum:h.iridescence.maximumThickness,iridescenceTexture:l??void 0,iridescenceThicknessTexture:M??void 0};null===O.iridescenceTexture&&null===O.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(h),S.extensions[oS]=O}m(S)}))}}km.RegisterExtension(oS,(m=>new sS(m)));const vS="KHR_materials_sheen";class TS{constructor(m){this.name=vS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){return h instanceof Bm.c&&h.sheen.isEnabled&&h.sheen.texture?[h.sheen.texture]:[]}async postExportMaterialAsync(m,S,h){return await new Promise((m=>{if(h instanceof Bm.c){if(!h.sheen.isEnabled)return void m(S);this._wasUsed=!0,null==S.extensions&&(S.extensions={});const l={sheenColorFactor:h.sheen.color.DM(),sheenRoughnessFactor:h.sheen.roughness??0};null===l.sheenColorTexture&&null===l.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),h.sheen.texture&&(l.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),h.sheen.textureRoughness&&!h.sheen.useRoughnessFromMainTexture?l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.textureRoughness)??void 0:h.sheen.texture&&h.sheen.useRoughnessFromMainTexture&&(l.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),S.extensions[vS]=l}m(S)}))}}km.RegisterExtension(vS,(m=>new TS(m)));const XS="KHR_materials_specular";class gS{constructor(m){this.name=XS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof Bm.c&&this._isExtensionEnabled(h)?(h.metallicReflectanceTexture&&l.push(h.metallicReflectanceTexture),h.reflectanceTexture&&l.push(h.reflectanceTexture),l):l}_isExtensionEnabled(m){return!m.unlit&&(void 0!=m.metallicF0Factor&&1!=m.metallicF0Factor||void 0!=m.metallicReflectanceColor&&!m.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(m))}_hasTexturesExtension(m){return null!=m.metallicReflectanceTexture||null!=m.reflectanceTexture}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0,S.extensions=S.extensions||{};const m=this._exporter._materialExporter.getTextureInfo(h.metallicReflectanceTexture)??void 0,l=this._exporter._materialExporter.getTextureInfo(h.reflectanceTexture)??void 0,M={specularFactor:1==h.metallicF0Factor?void 0:h.metallicF0Factor,specularTexture:m,specularColorFactor:h.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:h.metallicReflectanceColor.DM(),specularColorTexture:l};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),S.extensions[XS]=M}m(S)}))}}km.RegisterExtension(XS,(m=>new gS(m)));const GS="KHR_materials_transmission";class eS{constructor(m){this.name=GS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof Bm.c&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&l.push(h.subSurface.thicknessTexture),l):l}_isExtensionEnabled(m){if(m.unlit)return!1;const S=m.subSurface;return S.isRefractionEnabled&&void 0!=S.refractionIntensity&&0!=S.refractionIntensity||this._hasTexturesExtension(m)}_hasTexturesExtension(m){return null!=m.subSurface.refractionIntensityTexture}async postExportMaterialAsync(m,S,h){if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const l=h.subSurface,M={transmissionFactor:0===l.refractionIntensity?void 0:l.refractionIntensity};if(this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),l.refractionIntensityTexture)if(l.useGltfStyleTextures){const m=await this._exporter._materialExporter.exportTextureAsync(l.refractionIntensityTexture,"image/png");m&&(M.transmissionTexture=m)}else j.e.Warn(`${m}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);S.extensions||(S.extensions={}),S.extensions[GS]=M}return S}}km.RegisterExtension(GS,(m=>new eS(m)));const aS="KHR_materials_unlit";class xS{constructor(){this.name=aS,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(m,S,h){return new Promise((m=>{let l=!1;h instanceof Bm.c?l=h.unlit:h instanceof Dm.HS&&(l=h.disableLighting),l&&(this._wasUsed=!0,null==S.extensions&&(S.extensions={}),S.extensions[aS]={}),m(S)}))}}km.RegisterExtension(aS,(()=>new xS));const PS="KHR_materials_volume";class dS{constructor(m){this.name=PS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof Bm.c&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&l.push(h.subSurface.thicknessTexture),l):l}_isExtensionEnabled(m){if(m.unlit)return!1;const S=m.subSurface;return!(!S.isRefractionEnabled&&!S.isTranslucencyEnabled)&&(void 0!=S.maximumThickness&&0!=S.maximumThickness||void 0!=S.tintColorAtDistance&&S.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=S.tintColor&&S.tintColor!=E.RS.White()||this._hasTexturesExtension(m))}_hasTexturesExtension(m){return null!=m.subSurface.thicknessTexture}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof Bm.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const m=h.subSurface,l={thicknessFactor:0==m.maximumThickness?void 0:m.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(m.thicknessTexture)??void 0,attenuationDistance:m.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:m.tintColorAtDistance,attenuationColor:m.tintColor.equalsFloats(1,1,1)?void 0:m.tintColor.DM()};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),S.extensions=S.extensions||{},S.extensions[PS]=l}m(S)}))}}km.RegisterExtension(PS,(m=>new dS(m)));const JS="EXT_materials_diffuse_roughness";class NS{constructor(m){this.name=JS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=m}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(m,S,h){const l=[];return h instanceof YS.e&&h._baseDiffuseRoughness?(h._baseDiffuseRoughnessTexture&&l.push(h._baseDiffuseRoughnessTexture),l):[]}postExportMaterialAsync(m,S,h){return new Promise((m=>{if(h instanceof YS.e){if(!h._baseDiffuseRoughness)return void m(S);this._wasUsed=!0,S.extensions=S.extensions||{};const l=this._exporter._materialExporter.getTextureInfo(h._baseDiffuseRoughnessTexture),M={diffuseRoughnessFactor:h._baseDiffuseRoughness,diffuseRoughnessTexture:l??void 0};null!==M.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(h),S.extensions[JS]=M}m(S)}))}}km.RegisterExtension(JS,(m=>new NS(m)));const jS="KHR_texture_transform";class KS{constructor(){this.name=jS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(m,S,h){if(h.sm()||M.Tools.Warn(`${m}: /*@__KEY__*/"scene" is not defined for Babylon texture ${h.name}!`),(0!==h.uAng||0!==h.vAng)&&(M.Tools.Warn(`${m}: Texture ${h.name} with rotation in the u or v axis is not supported in glTF.`),0!==h.uRotationCenter||0!==h.vRotationCenter))return;const l={};let O=!1;if(0===h.uOffset&&0===h.vOffset||(l.offset=[h.uOffset,h.vOffset],O=!0),1===h.uScale&&1===h.vScale||(l.scale=[h.uScale,h.vScale],O=!0),0!==h.wAng){if(0!==h.uRotationCenter||0!==h.vRotationCenter){if(h.homogeneousRotationInUVTransform&&h.uScale!==h.vScale)return void M.Tools.Warn(`${m}: Texture ${h.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${jS}.`);M.Tools.Warn(`${m}: Texture ${h.name} with non-origin rotation center will be exported using an adjusted offset with ${jS}.`),l.offset=function(m){const{uOffset:S,vOffset:h,uRotationCenter:l,vRotationCenter:M,uScale:O,vScale:u,wAng:b}=m,q=Math.cos(b),Y=Math.sin(b),V=l*O,I=M*u;return[S+(V*(1-q)+I*Y),h+(I*(1-q)-V*Y)]}(h)}l.rotation=-h.wAng,O=!0}0!==h.coordinatesIndex&&(l.texCoord=h.coordinatesIndex,O=!0),O&&(this._wasUsed=!0,S.extensions||(S.extensions={}),S.extensions[jS]=l)}}km.RegisterExtension(jS,(()=>new KS));class cS{static CreateSTL(m){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",M=arguments.length>3&&void 0!==arguments[3]&&arguments[3],O=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],u=arguments.length>5&&void 0!==arguments[5]&&arguments[5],b=arguments.length>6&&void 0!==arguments[6]&&arguments[6],q=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const Y=function(m,S,h){const M=[3*m[h],3*m[h+1],3*m[h+2]],O=[new l.nS(S[M[0]],S[M[0]+2],S[M[0]+1]),new l.nS(S[M[1]],S[M[1]+2],S[M[1]+1]),new l.nS(S[M[2]],S[M[2]+2],S[M[2]+1])],u=O[0].LS(O[1]),b=O[2].LS(O[1]);return{v:O,n:l.nS.Cross(b,u).normalize()}},I=function(m,S,h,l){return S=Z(m,S,h.x,l),S=Z(m,S,h.y,l),Z(m,S,h.z,l)},Z=function(m,S,h,l){return m.setFloat32(S,h,l),S+4},B=function(m){if(b){let S=m;m instanceof C.c&&(S=m.sourceMesh);const h=S.getVerticesData(V.f.PositionKind,!0,!0);if(!h)return[];const M=l.nS.Zero();let O;for(O=0;O<h.length;O+=3)l.nS.TransformCoordinatesFromFloatsToRef(h[O],h[O+1],h[O+2],m.Mb(!0),M).toArray(h,O);return h}return m.getVerticesData(V.f.PositionKind)||[]};b&&(u=!0);let D="",E=0,n=0;if(M){for(let h=0;h<m.length;h++){const S=m[h].bb();E+=S?S.length/3:0}const S=new ArrayBuffer(84+50*E);D=new DataView(S),n+=80,D.setUint32(n,E,O),n+=4}else q||(D="solid stlmesh\r\n");for(let l=0;l<m.length;l++){const S=m[l];!M&&q&&(D+="solid "+S.name+"\r\n"),!u&&S instanceof Lm.c&&S.bakeCurrentTransformIntoVertices();const h=B(S),b=S.bb()||[];for(let m=0;m<b.length;m+=3){const S=Y(b,h,m);M?(n=I(D,n,S.n,O),n=I(D,n,S.v[0],O),n=I(D,n,S.v[1],O),n=I(D,n,S.v[2],O),n+=2):(D+="\tfacet normal "+S.n.x+" "+S.n.y+" "+S.n.z+"\r\n",D+="\t\touter loop\r\n",D+="\t\t\tvertex "+S.v[0].x+" "+S.v[0].y+" "+S.v[0].z+"\r\n",D+="\t\t\tvertex "+S.v[1].x+" "+S.v[1].y+" "+S.v[1].z+"\r\n",D+="\t\t\tvertex "+S.v[2].x+" "+S.v[2].y+" "+S.v[2].z+"\r\n",D+="\t\tendloop\r\n",D+="\tendfacet\r\n")}!M&&q&&(D+="endsolid "+name+"\r\n")}if(M||q||(D+="endsolid stlmesh"),S){const m=document.createElement("a"),S=new Blob([D],{type:"application/octet-stream"});m.href=window.URL.createObjectURL(S),m.download=h+".stl",m.click()}return D}}function fS(m,S){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const l=[];for(let M=0;M<m.length/h;M++){const O=m[M*h],u=m[M*h+1],b=m[M*h+2];l.push(`(${O.toPrecision(S.precision)}, ${u.toPrecision(S.precision)}, ${b.toPrecision(S.precision)})`)}return l.join(", ")}function pS(m,S){const h=[];for(let l=0;l<m.length/2;l++){const M=m[2*l],O=m[2*l+1];h.push(`(${M.toPrecision(S.precision)}, ${(1-O).toPrecision(S.precision)})`)}return h.join(", ")}function kS(m,S){const h=m.getVerticesData(V.f.PositionKind),l=m.getVerticesData(V.f.NormalKind);if(h&&l)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(m){var S;const h=null!==(S=m.bb())&&void 0!==S&&S.length?m.getTotalIndices():m.getTotalVertices();return Array(h/3).fill(3).join(", ")}(m)}]\n\t\tint[] faceVertexIndices = [${function(m){const S=m.bb(),h=[];if(null!==S)for(let l=0;l<S.length;l++)h.push(S[l]);else{const S=m.getTotalVertices();for(let m=0;m<S;m++)h.push(m)}return h.join(", ")}(m)}]\n\t\tnormal3f[] normals = [${fS(l,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${fS(h,S)}]\n        ${function(m,S){let h="";for(let M=0;M<4;M++){const l=M>0?M:"",O=m.getVerticesData(V.f.UVKind+(l?l+1:""));O&&(h+=`\n\t\ttexCoord2f[] primvars:st${l} = [${pS(O,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const l=m.getVerticesData(V.f.ColorKind);return l&&(h+=`\n\tcolor3f[] primvars:displayColor = [${fS(l,S,l.length/m.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),h}(m,S)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function rS(m,S){return`\n        def "Geometry"\n        {\n        ${kS(m,S)}\n        }\n        `}function zS(m){let S='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return S+=m,fflate.strToU8(S)}function QS(m){const S=m.m;return`( ${FS(S,0)}, ${FS(S,4)}, ${FS(S,8)}, ${FS(S,12)} )`}function FS(m,S){return`(${m[S+0]}, ${m[S+1]}, ${m[S+2]}, ${m[S+3]})`}function wS(m){const S="Object_"+m.uniqueId,h=function(m){const S=m.getWorldMatrix().clone(),h=m.sm().useRightHandedSystem;if(!h){let l=m.parent;for(;l;){if(um(l,h)){S.multiplyToRef(l.getWorldMatrix().invert(),S);break}l=l.parent}}return S.determinant()<0&&M.Tools.Warn(`Exporting mesh ${m.name} with negative scale. Result may look incorrect in destination engine.`),S}(m),l=QS(h);return`def Xform "${S}" (\n\tprepend references = @./geometries/Geometry_${m.ub.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${l}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${m.material.uniqueId}>\n}\n\n`}function tS(m){switch(m){case o.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case o.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case o.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function AS(m){return`(${m.x}, ${m.y})`}function iS(m){return`(${m.r}, ${m.g}, ${m.b})`}function WS(m,S,h,M,O,u){const b=m.getInternalTexture().uniqueId+"_"+m.invertY;O[b]=m;const q=m.coordinatesIndex>0?"st"+m.coordinatesIndex:"st",Y=new l.Vector2(m.uScale,m.vScale),V=new l.Vector2(m.uOffset,m.vOffset),I=m.wAng,Z=Math.sin(I),C=Math.cos(I);return V.y=1-V.y-Y.y,V.x+=Z*Y.x,V.y+=(1-C)*Y.y,`\n    def Shader "PrimvarReader_${h}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${q}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${h}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${S.uniqueId}/PrimvarReader_${h}.outputs:result>\n        float inputs:rotation = ${(I*(180/Math.PI)).toFixed(u.precision)}\n        float2 inputs:scale = ${AS(Y)}\n        float2 inputs:translation = ${AS(V)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${m.uniqueId}_${h}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${b}.png@\n        float2 inputs:st.connect = </Materials/Material_${S.uniqueId}/Transform2d_${h}.outputs:result>\n        ${M?"float4 inputs:scale = "+function(m){return`(${m.r}, ${m.g}, ${m.b}, 1.0)`}(M):""}\n        token inputs:sourceColorSpace = "${m.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${tS(m.wrapU)}"\n        token inputs:wrapT = "${tS(m.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${S.needAlphaBlending()?"float outputs:a":""}\n    }`}function mh(m,S,h){const l="\t\t\t",M=[],O=[],{diffuseMap:u,Lb:b,alphaCutOff:q,emissiveMap:Y,emissive:V,normalMap:I,roughnessMap:Z,roughnessChannel:C,roughness:B,metalnessMap:D,metalnessChannel:n,metalness:L,aoMap:U,aoMapChannel:H,aoMapIntensity:R,alphaMap:y,ior:o,clearCoatEnabled:s,clearCoat:v,clearCoatMap:T,clearCoatRoughness:X,clearCoatRoughnessMap:g}=function(m){const S={diffuseMap:null,Lb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return m instanceof Dm.HS?{...S,diffuseMap:m.diffuseTexture,Lb:m.diffuseColor,alphaCutOff:m.alphaCutOff,emissiveMap:m.emissiveTexture,emissive:m.emissiveColor,roughness:1,alphaMap:m.opacityTexture}:m instanceof YS.e?{...S,diffuseMap:m._albedoTexture,Lb:m._albedoColor,alphaCutOff:m._alphaCutOff,emissiveMap:m._emissiveTexture,emissive:m._emissiveColor,normalMap:m._bumpTexture,roughnessMap:m._metallicTexture,roughnessChannel:m._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:m._roughness??1,metalnessMap:m._metallicTexture,metalnessChannel:m._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:m._metallic??0,aoMap:m._ambientTexture,aoMapChannel:m._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:m._ambientTextureStrength,alphaMap:m._opacityTexture,ior:m.subSurface.indexOfRefraction,clearCoatEnabled:m.clearCoat.isEnabled,clearCoat:m.clearCoat.nb,clearCoatMap:m.clearCoat.texture,clearCoatRoughness:m.clearCoat.roughness,clearCoatRoughnessMap:m.clearCoat.useRoughnessFromMainTexture?m.clearCoat.texture:m.clearCoat.textureRoughness}:S}(m);return null!==u?(M.push(`${l}color3f inputs:diffuseColor.connect = </Materials/Material_${m.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:rgb>`),m.needAlphaBlending()?M.push(`${l}float inputs:opacity.connect = </Materials/Material_${m.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`):m.needAlphaTesting()&&(M.push(`${l}float inputs:opacity.connect = </Materials/Material_${m.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`),M.push(`${l}float inputs:opacityThreshold = ${q}`)),O.push(WS(u,m,"diffuse",b,S,h))):M.push(`${l}color3f inputs:diffuseColor = ${iS(b||E.RS.White())}`),null!==Y?(M.push(`${l}color3f inputs:emissiveColor.connect = </Materials/Material_${m.uniqueId}/Texture_${Y.uniqueId}_emissive.outputs:rgb>`),O.push(WS(Y,m,"emissive",V,S,h))):V&&V.toLuminance()>0&&M.push(`${l}color3f inputs:emissiveColor = ${iS(V)}`),null!==I&&(M.push(`${l}normal3f inputs:normal.connect = </Materials/Material_${m.uniqueId}/Texture_${I.uniqueId}_normal.outputs:rgb>`),O.push(WS(I,m,"normal",null,S,h))),null!==U&&(M.push(`${l}float inputs:occlusion.connect = </Materials/Material_${m.uniqueId}/Texture_${U.uniqueId}_occlusion.outputs:${H}>`),O.push(WS(U,m,"occlusion",new E.RS(R,R,R),S,h))),null!==Z?(M.push(`${l}float inputs:roughness.connect = </Materials/Material_${m.uniqueId}/Texture_${Z.uniqueId}_roughness.outputs:${C}>`),O.push(WS(Z,m,"roughness",new E.RS(B,B,B),S,h))):M.push(`${l}float inputs:roughness = ${B}`),null!==D?(M.push(`${l}float inputs:metallic.connect = </Materials/Material_${m.uniqueId}/Texture_${D.uniqueId}_metallic.outputs:${n}>`),O.push(WS(D,m,"metallic",new E.RS(L,L,L),S,h))):M.push(`${l}float inputs:metallic = ${L}`),null!==y?(M.push(`${l}float inputs:opacity.connect = </Materials/Material_${m.uniqueId}/Texture_${y.uniqueId}_opacity.outputs:r>`),M.push(`${l}float inputs:opacityThreshold = 0.0001`),O.push(WS(y,m,"opacity",null,S,h))):M.push(`${l}float inputs:opacity = ${m.alpha}`),s&&(null!==T?(M.push(`${l}float inputs:clearcoat.connect = </Materials/Material_${m.uniqueId}/Texture_${T.uniqueId}_clearcoat.outputs:r>`),O.push(WS(T,m,"clearcoat",new E.RS(v,v,v),S,h))):M.push(`${l}float inputs:clearcoat = ${v}`),null!==g?(M.push(`${l}float inputs:clearcoatRoughness.connect = </Materials/Material_${m.uniqueId}/Texture_${g.uniqueId}_clearcoatRoughness.outputs:g>`),O.push(WS(g,m,"clearcoatRoughness",new E.RS(X,X,X),S,h))):M.push(`${l}float inputs:clearcoatRoughness = ${X}`)),M.push(`${l}float inputs:ior = ${o}`),`\n\tdef Material "Material_${m.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${M.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${m.uniqueId}/PreviewSurface.outputs:surface>\n\n${O.join("\n")}\n\n\t}\n`}async function Sh(m,S,h){const O={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...S};"undefined"===typeof fflate&&await M.Tools.LoadScriptAsync(O.fflateUrl);const u={};u[O.modelFileName]=null;let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';b+=function(m){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===m.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${m.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${m.planeAnchoringAlignment}"`:""}\n            `}(O);const q={};for(const l of m.meshes){if(0===l.getTotalVertices())continue;const m=l,S=m.ub,Y=m.material;if(!Y||!S||h&&!h(m))continue;if(-1!==["HS","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(Y.getClassName())){const h="geometries/Geometry_"+S.uniqueId+".usda";if(!(h in u)){const m=rS(S,O);u[h]=zS(m)}Y.uniqueId in q||(q[Y.uniqueId]=Y),b+=wS(m)}else M.Tools.Warn("USDZExportAsync does not support this material type: "+Y.getClassName())}m.activeCamera&&O.exportCamera&&(b+=function(m,S){const h="Camera_"+m.uniqueId,M=QS(l.Matrix.RotationY(Math.PI).multiply(m.getWorldMatrix()));if(m.mode===o.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${M}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${m.hb.toPrecision(S.precision)}, ${m.maxZ.toPrecision(S.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(m.orthoLeft||1)+Math.abs(m.orthoRight||1))).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(m.orthoTop||1)+Math.abs(m.orthoBottom||1))).toPrecision(S.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const l=m.getEngine().getAspectRatio(m),O=S.cameraSensorWidth||35;return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${M}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${m.hb.toPrecision(S.precision)}, ${m.maxZ.toPrecision(S.precision)})\n\t\t\tfloat focalLength = ${(O/(2*Math.tan(.5*m.fov))).toPrecision(S.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(O*l).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(O/l).toPrecision(S.precision)}            \n\t\t}\n\t\n\t`}}(m.activeCamera,O)),b+="\n            }\n        }\n    }";const Y={};b+=function(m,S,h){const l=[];for(const M in m){const O=m[M];l.push(mh(O,S,h))}return`\n    def "Materials"\n{\n${l.join("")}\n}\n\n`}(q,Y,O),u[O.modelFileName]=fflate.strToU8(b);for(const l in Y){const m=Y[l],S=m.getSize(),h=await m.readPixels();if(!h)throw new Error("Texture data is not available");const M=await s.DumpTools.DumpDataAsync(S.width,S.height,h,"image/png",void 0,!1,!0);u[`textures/Texture_${l}.png`]=new Uint8Array(M).slice()}let V=0;for(const l in u){const m=u[l];if(!m)continue;V+=34+l.length;const S=63&V;if(4!==S){const h=new Uint8Array(64-S);u[l]=[m,{extra:{12345:h}}]}V=m.length}return fflate.zipSync(u,{level:0})}}}]);