"use strict";(self.b15p7b72fr8=self.b15p7b72fr8||[]).push([[26],{13032:(s,k,h)=>{h.r(k),h.d(k,{EXT_materials_diffuse_roughness:()=>Uk,EXT_mesh_gpu_instancing:()=>Ws,GLTF2Export:()=>xs,GLTFData:()=>O,KHR_draco_mesh_compression:()=>hk,KHR_lights_punctual:()=>Hk,KHR_materials_anisotropy:()=>Sk,KHR_materials_clearcoat:()=>rk,KHR_materials_diffuse_transmission:()=>jk,KHR_materials_dispersion:()=>Rk,KHR_materials_emissive_strength:()=>wk,KHR_materials_ior:()=>uk,KHR_materials_iridescence:()=>Qk,KHR_materials_sheen:()=>Ik,KHR_materials_specular:()=>bk,KHR_materials_transmission:()=>zk,KHR_materials_unlit:()=>vk,KHR_materials_volume:()=>nk,KHR_texture_transform:()=>Mk,OBJExport:()=>i,STLExport:()=>Vk,USDZExportAsync:()=>kh,_ConvertToGLTFPBRMetallicRoughness:()=>C,_SolveMetallic:()=>z,__IGLTFExporterExtension:()=>K});var A=h(12590),g=h(12402),ms=h(12916);class i{static OBJ(s,k,h,i){const K=[];let H=1,O=1;k&&(h||(h="mat"),K.push("mtllib "+h+".mtl"));for(let c=0;c<s.length;c++){const h=s[c],S=h.name||`mesh${c}}`;K.push(`o ${S}`);let a=null;if(i){const s=h.fh(!0);a=new A.Matrix,s.invertToRef(a),h.bakeTransformIntoVertices(s)}if(k){const s=h.material;s&&K.push("usemtl "+s.id)}const r=h.mg;if(!r){g.Tools.Warn("No geometry is present on the mesh");continue}const d=r.getVerticesData("position"),E=r.getVerticesData("normal"),j=r.getVerticesData("uv"),P=r.sg();let R=0,D=0;if(!d||!P){g.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const w=s[0].Is().useRightHandedSystem?1:-1;for(let s=0;s<d.length;s+=3)K.push("v "+d[s]*w+" "+d[s+1]+" "+d[s+2]),R++;if(null!=E)for(let s=0;s<E.length;s+=3)K.push("vn "+E[s]*w+" "+E[s+1]+" "+E[s+2]);if(null!=j)for(let s=0;s<j.length;s+=2)K.push("vt "+j[s]+" "+j[s+1]),D++;const B=["","",""],u=(h.material||h.Is().defaultMaterial)._getEffectiveOrientation(h),[G,Q]=u===ms.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let s=0;s<P.length;s+=3){const k=[String(P[s]+H),String(P[s+G]+H),String(P[s+Q]+H)],h=[String(P[s]+O),String(P[s+G]+O),String(P[s+Q]+O)],A=k,g=null!=j?h:B,ms=null!=E?k:B;K.push("f "+A[0]+"/"+g[0]+"/"+ms[0]+" "+A[1]+"/"+g[1]+"/"+ms[1]+" "+A[2]+"/"+g[2]+"/"+ms[2])}i&&a&&h.bakeTransformIntoVertices(a),H+=R,O+=D}return K.join("\n")}static MTL(s){const k=[],h=s.material;k.push("newmtl mat1"),k.push("  Ns "+h.specularPower.toFixed(4)),k.push("  Ni 1.5000"),k.push("  d "+h.alpha.toFixed(4)),k.push("  Tr 0.0000"),k.push("  Tf 1.0000 1.0000 1.0000"),k.push("  illum 2"),k.push("  Ka "+h.ambientColor.r.toFixed(4)+" "+h.ambientColor.g.toFixed(4)+" "+h.ambientColor.b.toFixed(4)),k.push("  Kd "+h.diffuseColor.r.toFixed(4)+" "+h.diffuseColor.g.toFixed(4)+" "+h.diffuseColor.b.toFixed(4)),k.push("  Ks "+h.specularColor.r.toFixed(4)+" "+h.specularColor.g.toFixed(4)+" "+h.specularColor.b.toFixed(4)),k.push("  Ke "+h.emissiveColor.r.toFixed(4)+" "+h.emissiveColor.g.toFixed(4)+" "+h.emissiveColor.b.toFixed(4));h.ambientTexture&&k.push("  map_Ka "+h.ambientTexture.name),h.diffuseTexture&&k.push("  map_Kd "+h.diffuseTexture.name),h.specularTexture&&k.push("  map_Ks "+h.specularTexture.name),h.bumpTexture&&k.push("  map_bump -imfchan z "+h.bumpTexture.name),h.opacityTexture&&k.push("  map_d "+h.opacityTexture.name);return k.join("\n")}}var K=0,H=h(12448);class O{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const s in this.files){const k=this.files[s],h=new Blob([k],{type:(0,H.f)(s)});g.Tools.Download(h,s)}}}var c=h(12664),S=h(13038),a=h(13043),r=h(13056),d=h(12722),E=h(12445),j=h(12636),P=h(12607);const R=P.HighestCommonFactor,D={...P,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:R};var w=h(12823),B=h(12567),u=h(13084),G=h(13093),Q=h(12817);const p=1e-6,I=new j.Bk(.04,.04,.04),N=1024,b=j.Bk.White(),t=j.Bk.Black();function z(s,k,h){if(k<I.r)return 0;const A=I.r,g=s*h/(1-I.r)+k-2*I.r,ms=g*g-4*A*(I.r-k);return D.Clamp((-g+Math.sqrt(ms))/(2*A),0,1)}function C(s){const k=s.diffuseColor.toLinearSpace(s.Is().getEngine().useExactSrgbConversions).scale(.5),h=s.alpha,g=function(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new A.Vector2(0,1),h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new A.Vector2(0,.1),g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new A.Vector2(0,.1),ms=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new A.Vector2(1300,.1);return function(s,k,h,A,g){return(1-s)*(1-s)*(1-s)*k+3*(1-s)*(1-s)*s*h+3*(1-s)*s*s*A+s*s*s*g}(Math.pow(s/ms.x,.333333),k.y,h.y,g.y,ms.y)}(D.Clamp(s.specularPower,0,N));return{baseColorFactor:[k.r,k.g,k.b,h],metallicFactor:0,roughnessFactor:g}}function v(s,k){k.needAlphaBlending()?s.alphaMode="BLEND":k.needAlphaTesting()&&(s.alphaMode="MASK",s.alphaCutoff=k.alphaCutOff)}function Y(s,k,h){const A=new Uint8Array(s*k*4);for(let g=0;g<A.length;g+=4)A[g]=A[g+1]=A[g+2]=A[g+3]=255;return u.e.CreateRGBATexture(A,s,k,h)}function n(s){if(s instanceof Uint8Array){const k=s.length,h=new Float32Array(s.length);for(let A=0;A<k;++A)h[A]=s[A]/255;return h}if(s instanceof Float32Array)return s;throw new Error("Unsupported pixel format!")}class T{constructor(s){this._exporter=s,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(s){return s?this._textureMap.get(s)??null:null}async exportStandardMaterialAsync(s,k,h){const A=C(s),ms={name:s.name};if(null==s.Hg||s.Hg||(s.twoSidedLighting||g.Tools.Warn(s.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),ms.doubleSided=!0),h){const h=[],g=s.diffuseTexture;g&&h.push(this.exportTextureAsync(g,k).then((s=>{s&&(A.baseColorTexture=s)})));const i=s.bumpTexture;i&&h.push(this.exportTextureAsync(i,k).then((s=>{s&&(ms.normalTexture=s,1!==i.level&&(ms.normalTexture.scale=i.level))})));const K=s.emissiveTexture;K&&(ms.emissiveFactor=[1,1,1],h.push(this.exportTextureAsync(K,k).then((s=>{s&&(ms.emissiveTexture=s)}))));const H=s.ambientTexture;H&&h.push(this.exportTextureAsync(H,k).then((s=>{if(s){const k={index:s.index};ms.occlusionTexture=k}}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(s),await Promise.all(h))}(s.alpha<1||s.opacityTexture)&&(s.alphaMode===G.b.ALPHA_COMBINE?ms.alphaMode="BLEND":g.Tools.Warn(s.name+": glTF 2.0 does not support alpha mode: "+s.alphaMode.toString())),s.emissiveColor&&!s.emissiveColor.equalsWithEpsilon(t,p)&&(ms.emissiveFactor=s.emissiveColor.yh()),ms.pbrMetallicRoughness=A,v(ms,s),await this._finishMaterialAsync(ms,s,k);const i=this._exporter._materials;return i.push(ms),i.length-1}async _finishMaterialAsync(s,k,h){const A=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",s,k),g=[];for(const ms of A)g.push(this.exportTextureAsync(ms,h));await Promise.all(g),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",s,k)}async _getImageDataAsync(s,k,A,g){const ms=G.b.TEXTURETYPE_UNSIGNED_BYTE,i=this._exporter._babylonScene,K=i.getEngine(),H=K.createRawTexture(s,k,A,G.b.TEXTUREFORMAT_RGBA,!1,!0,B.b.NEAREST_SAMPLINGMODE,null,ms);K.isWebGPU?await h.e(51).then(h.bind(h,15075)):await h.e(52).then(h.bind(h,15084)),await w.n.ApplyPostProcess("pass",H,i,ms,G.b.TEXTURE_NEAREST_SAMPLINGMODE,G.b.TEXTUREFORMAT_RGBA);const O=await K._readTexturePixels(H,k,A);return await Q.DumpTools.DumpDataAsync(k,A,O,g,void 0,!0,!0)}_resizeTexturesToSameDimensions(s,k,h){const A=s?s.getSize():{width:0,height:0},g=k?k.getSize():{width:0,height:0};let ms,i;return A.width<g.width?(ms=s&&s instanceof B.b?w.n.CreateResizedCopy(s,g.width,g.height,!0):Y(g.width,g.height,h),i=k):A.width>g.width?(i=k&&k instanceof B.b?w.n.CreateResizedCopy(k,A.width,A.height,!0):Y(A.width,A.height,h),ms=s):(ms=s,i=k),{texture1:ms,texture2:i}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(s,k,h,A){const g=new Array;if(!s&&!k)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const ms=s?s.Is():k?k.Is():null;if(ms){var i;const K=this._resizeTexturesToSameDimensions(s,k,ms),H=null===(i=K.texture1)||void 0===i?void 0:i.getSize();let O,c;const S=H.width,a=H.height,r=await K.texture1.readPixels(),d=await K.texture2.readPixels();if(!r)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(O=n(r),!d)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");c=n(d);const E=c.byteLength,P=new Uint8Array(E),R=new Uint8Array(E),D=4,w=t;let B=0,u=0;for(let s=0;s<a;++s)for(let k=0;k<S;++k){const A=(S*s+k)*D,g={diffuseColor:new j.Bk(O[A],O[A+1],O[A+2]).toLinearSpace(ms.getEngine().useExactSrgbConversions).multiply(h.diffuseColor),specularColor:new j.Bk(c[A],c[A+1],c[A+2]).toLinearSpace(ms.getEngine().useExactSrgbConversions).multiply(h.specularColor),glossiness:c[A+3]*h.glossiness},i=this._convertSpecularGlossinessToMetallicRoughness(g);w.r=Math.max(w.r,i.baseColor.r),w.g=Math.max(w.g,i.baseColor.g),w.b=Math.max(w.b,i.baseColor.b),B=Math.max(B,i.metallic),u=Math.max(u,i.roughness),R[A]=255*i.baseColor.r,R[A+1]=255*i.baseColor.g,R[A+2]=255*i.baseColor.b,R[A+3]=K.texture1.Wh?255*O[A+3]:255,P[A]=0,P[A+1]=255*i.roughness,P[A+2]=255*i.metallic,P[A+3]=255}const G={baseColor:w,metallic:B,roughness:u};let Q=!1,I=!1;for(let s=0;s<a;++s)for(let k=0;k<S;++k){const h=(S*s+k)*D;R[h]/=G.baseColor.r>p?G.baseColor.r:1,R[h+1]/=G.baseColor.g>p?G.baseColor.g:1,R[h+2]/=G.baseColor.b>p?G.baseColor.b:1;const A=j.Bk.FromInts(R[h],R[h+1],R[h+2]).toGammaSpace(ms.getEngine().useExactSrgbConversions);R[h]=255*A.r,R[h+1]=255*A.g,R[h+2]=255*A.b,A.equalsWithEpsilon(b,p)||(I=!0),P[h+1]/=G.roughness>p?G.roughness:1,P[h+2]/=G.metallic>p?G.metallic:1;j.Bk.FromInts(255,P[h+1],P[h+2]).equalsWithEpsilon(b,p)||(Q=!0)}return Q&&g.push(this._getImageDataAsync(P,S,a,A).then((s=>{G.metallicRoughnessTextureData=s}))),I&&g.push(this._getImageDataAsync(R,S,a,A).then((s=>{G.baseColorTextureData=s}))),await Promise.all(g).then((()=>G))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(s){const k=this._getPerceivedBrightness(s.diffuseColor),h=this._getPerceivedBrightness(s.specularColor),A=1-this._getMaxComponent(s.specularColor),g=z(k,h,A),ms=s.diffuseColor.scale(A/(1-I.r)/Math.max(1-g)),i=s.specularColor.Rk(I.scale(1-g)).scale(1/Math.max(g));let K=j.Bk.Lerp(ms,i,g*g);K=K.clampToRef(0,1,K);return{baseColor:K,metallic:g,roughness:1-s.glossiness}}_getPerceivedBrightness(s){return s?Math.sqrt(.299*s.r*s.r+.587*s.g*s.g+.114*s.b*s.b):0}_getMaxComponent(s){return s?Math.max(s.r,Math.max(s.g,s.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(s,k,h,A){const g=[],ms={baseColor:s._albedoColor,metallic:s._metallic,roughness:s._roughness};if(A){s._albedoTexture&&g.push(this.exportTextureAsync(s._albedoTexture,k).then((s=>{s&&(h.baseColorTexture=s)})));const A=s._metallicTexture;A&&g.push(this.exportTextureAsync(A,k).then((s=>{s&&(h.metallicRoughnessTexture=s)})))}return g.length>0&&(this._exporter._materialNeedsUVsSet.add(s),await Promise.all(g)),ms}_getTextureSampler(s){const k={};if(!s||!(s instanceof B.b))return k;const h=this._getGLTFTextureWrapMode(s.wrapU);10497!==h&&(k.wrapS=h);const A=this._getGLTFTextureWrapMode(s.wrapV);switch(10497!==A&&(k.wrapT=A),s.samplingMode){case B.b.LINEAR_LINEAR:k.magFilter=9729,k.minFilter=9729;break;case B.b.LINEAR_NEAREST:k.magFilter=9729,k.minFilter=9728;break;case B.b.NEAREST_LINEAR:k.magFilter=9728,k.minFilter=9729;break;case B.b.NEAREST_LINEAR_MIPLINEAR:k.magFilter=9728,k.minFilter=9987;break;case B.b.NEAREST_NEAREST:k.magFilter=9728,k.minFilter=9728;break;case B.b.NEAREST_LINEAR_MIPNEAREST:k.magFilter=9728,k.minFilter=9985;break;case B.b.LINEAR_NEAREST_MIPNEAREST:k.magFilter=9729,k.minFilter=9984;break;case B.b.LINEAR_NEAREST_MIPLINEAR:k.magFilter=9729,k.minFilter=9986;break;case B.b.NEAREST_NEAREST_MIPLINEAR:k.magFilter=9728,k.minFilter=9986;break;case B.b.LINEAR_LINEAR_MIPLINEAR:k.magFilter=9729,k.minFilter=9987;break;case B.b.LINEAR_LINEAR_MIPNEAREST:k.magFilter=9729,k.minFilter=9985;break;case B.b.NEAREST_NEAREST_MIPNEAREST:k.magFilter=9728,k.minFilter=9984}return k}_getGLTFTextureWrapMode(s){switch(s){case B.b.WRAP_ADDRESSMODE:return 10497;case B.b.CLAMP_ADDRESSMODE:return 33071;case B.b.MIRROR_ADDRESSMODE:return 33648;default:return g.Tools.Error(`Unsupported Texture Wrap Mode ${s}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(s,k,h,A){const g={diffuseColor:s._albedoColor,specularColor:s._reflectivityColor,glossiness:s._microSurface},ms=s._albedoTexture,i=s._reflectivityTexture,K=s._useMicroSurfaceFromReflectivityMapAlpha;if(i&&!K)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((ms||i)&&A){this._exporter._materialNeedsUVsSet.add(s);const A=this._exportTextureSampler(ms||i),K=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(ms,i,g,k),H=this._exporter._textures;if(K.baseColorTextureData){const s=this._exportImage(`baseColor${H.length}`,k,K.baseColorTextureData);h.baseColorTexture=this._exportTextureInfo(s,A,null===ms||void 0===ms?void 0:ms.coordinatesIndex)}if(K.metallicRoughnessTextureData){const s=this._exportImage(`metallicRoughness${H.length}`,k,K.metallicRoughnessTextureData);h.metallicRoughnessTexture=this._exportTextureInfo(s,A,null===i||void 0===i?void 0:i.coordinatesIndex)}return K}return this._convertSpecularGlossinessToMetallicRoughness(g)}async exportPBRMaterialAsync(s,k,h){const A={},g={name:s.name},ms=s.isMetallicWorkflow();if(ms){const k=s._albedoColor,h=s.alpha;k&&(A.baseColorFactor=[k.r,k.g,k.b,h])}const i=ms?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(s,k,A,h):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(s,k,A,h);await this._setMetallicRoughnessPbrMaterialAsync(i,s,g,A,k,h),await this._finishMaterialAsync(g,s,k);const K=this._exporter._materials;return K.push(g),K.length-1}async _setMetallicRoughnessPbrMaterialAsync(s,k,h,A,ms,i){if(v(h,k),s.baseColor.equalsWithEpsilon(b,p)&&D.WithinEpsilon(k.alpha,1,p)||(A.baseColorFactor=[s.baseColor.r,s.baseColor.g,s.baseColor.b,k.alpha]),null!=s.metallic&&1!==s.metallic&&(A.metallicFactor=s.metallic),null!=s.roughness&&1!==s.roughness&&(A.roughnessFactor=s.roughness),null==k.Hg||k.Hg||(k._twoSidedLighting||g.Tools.Warn(k.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),h.doubleSided=!0),i){const s=[],A=k._bumpTexture;A&&s.push(this.exportTextureAsync(A,ms).then((s=>{s&&(h.normalTexture=s,1!==A.level&&(h.normalTexture.scale=A.level))})));const g=k._ambientTexture;g&&s.push(this.exportTextureAsync(g,ms).then((s=>{if(s){const A={index:s.index,texCoord:s.texCoord,extensions:s.extensions};h.occlusionTexture=A;const g=k._ambientTextureStrength;g&&(A.strength=g)}})));const i=k._emissiveTexture;i&&s.push(this.exportTextureAsync(i,ms).then((s=>{s&&(h.emissiveTexture=s)}))),s.length>0&&(this._exporter._materialNeedsUVsSet.add(k),await Promise.all(s))}const K=k._emissiveColor;K.equalsWithEpsilon(t,p)||(h.emissiveFactor=K.yh()),h.pbrMetallicRoughness=A}_getPixelsFromTextureAsync(s){return function(s){switch(s){case G.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case G.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case G.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case G.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case G.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case G.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case G.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case G.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case G.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case G.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case G.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case G.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case G.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(s.textureFormat)?(0,w.k)(s,s._texture.width,s._texture.height):(s.textureType,G.b.TEXTURETYPE_UNSIGNED_BYTE,s.readPixels())}async exportTextureAsync(s,k){const h=this._exporter._extensionsPreExportTextureAsync("exporter",s,k);return h?await h.then((async h=>h?await this._exportTextureInfoAsync(h,k):await this._exportTextureInfoAsync(s,k))):await this._exportTextureInfoAsync(s,k)}async _exportTextureInfoAsync(s,k){let h=this._textureMap.get(s);if(!h){const A=await this._getPixelsFromTextureAsync(s);if(!A)return null;const ms=this._exportTextureSampler(s),i=s.mimeType;if(i)switch(i){case"image/jpeg":case"image/png":case"image/webp":k=i;break;default:g.Tools.Warn(`Unsupported media type: ${i}. Exporting texture as PNG.`)}const K=this._internalTextureToImage,H=s.getInternalTexture().uniqueId;K[H]||(K[H]={});let O=K[H][k];if(void 0===O){const h=s.getSize();O=(async()=>{const g=await this._getImageDataAsync(A,h.width,h.height,k);return this._exportImage(s.name,k,g)})(),K[H][k]=O}h=this._exportTextureInfo(await O,ms,s.coordinatesIndex),this._textureMap.set(s,h),this._exporter._extensionsPostExportTextures("exporter",h,s)}return h}_exportImage(s,k,h){const A=this._exporter._images;let ms;if(this._exporter._shouldUseGlb){ms={name:s,mimeType:k,bufferView:void 0};const A=this._exporter._bufferManager.createBufferView(new Uint8Array(h));this._exporter._bufferManager.setBufferView(ms,A)}else{const i=s.replace(/\.\/|\/|\.\\|\\/g,"_"),K=function(s){switch(s){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(k);let H=i+K;A.some((s=>s.uri===H))&&(H=`${i}_${g.Tools.RandomId()}${K}`),ms={name:s,uri:H},this._exporter._imageData[H]={data:h,mimeType:k}}return A.push(ms),A.length-1}_exportTextureInfo(s,k,h){const A=this._exporter._textures;let g=A.findIndex((h=>h.sampler==k&&h.source===s));-1===g&&(g=A.length,A.push({source:s,sampler:k}));const ms={index:g};return h&&(ms.texCoord=h),ms}_exportTextureSampler(s){const k=this._getTextureSampler(s),h=this._exporter._samplers,A=h.findIndex((s=>s.minFilter===k.minFilter&&s.magFilter===k.magFilter&&s.wrapS===k.wrapS&&s.wrapT===k.wrapT));return-1!==A?A:(h.push(k),h.length-1)}}var U=h(12675),q=h(12422),M=h(13096),V=h(12598);const X=A.Pk.Zero(),L=A.Quaternion.Identity(),Z=A.Pk.One(),x=new A.Pk(-1,1,1);function y(s,k){const{byteOffset:h,byteStride:A,type:g,normalized:ms}=s,i=s.getSize(),K=k.reduce(((s,k)=>k.getTotalVertices()>s?k.getTotalVertices():s),-Number.MAX_VALUE);return{byteOffset:h,byteStride:A,componentCount:i,type:g,count:K*i,normalized:ms,totalVertices:K,kind:s.getKind()}}function W(s){switch(s){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function J(s){switch(s){case c.e.PositionKind:case c.e.NormalKind:case c.e.TangentKind:case c.e.ColorKind:case c.e.MatricesIndicesKind:case c.e.MatricesIndicesExtraKind:case c.e.MatricesWeightsKind:case c.e.MatricesWeightsExtraKind:case c.e.UVKind:case c.e.UV2Kind:case c.e.UV3Kind:case c.e.UV4Kind:case c.e.UV5Kind:case c.e.UV6Kind:return!0}return!1}function F(s){switch(s){case ms.b.TriangleFillMode:return 4;case ms.b.TriangleStripDrawMode:return 5;case ms.b.TriangleFanDrawMode:return 6;case ms.b.PointListDrawMode:case ms.b.PointFillMode:return 0;case ms.b.LineLoopDrawMode:return 2;case ms.b.LineListDrawMode:return 1;case ms.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${s}`)}function o(s){const k=Math.sqrt(s.x*s.x+s.y*s.y+s.z*s.z);k>0&&(s.x/=k,s.y/=k,s.z/=k)}function l(s){return s.x*=-1,s}function f(s){if(s.x*s.x+s.y*s.y>.5){const k=Math.abs(s.x),h=Math.abs(s.y);if(k>h){const h=Math.sign(s.x);s.x=k,s.y*=-h,s.z*=-h,s.w*=h}else{const k=Math.sign(s.y);s.x*=-k,s.y=h,s.z*=k,s.w*=-k}}else{const k=Math.abs(s.z),h=Math.abs(s.w);if(k>h){const h=Math.sign(s.z);s.x*=-h,s.y*=h,s.z=k,s.w*=-h}else{const k=Math.sign(s.w);s.x*=k,s.y*=-k,s.z*=-k,s.w=h}}return s}function e(s){s.cg(-s.z,s.w,s.x,-s.y)}function ss(s,k){const h=A.Pk.FromArrayToRef(k.translation||[0,0,0],0,A.TmpVectors.Pk[0]),g=A.Quaternion.FromArrayToRef(k.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[0]),ms=A.Matrix.ComposeToRef(Z,g,h,A.TmpVectors.Matrix[0]),i=A.Pk.FromArrayToRef(s.translation||[0,0,0],0,A.TmpVectors.Pk[2]),K=A.Quaternion.FromArrayToRef(s.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[1]),H=A.Matrix.ComposeToRef(Z,K,i,A.TmpVectors.Matrix[1]);ms.multiplyToRef(H,H),H.decompose(void 0,g,h),h.equalsWithEpsilon(X,V.c)?delete k.translation:k.translation=h.yh(),g.equalsWithEpsilon(L,V.c)?delete k.rotation:k.rotation=g.yh(),k.scale&&delete k.scale}function ks(s,k){if(!(k instanceof S.b))return!1;if(!(1===k.getChildren().length&&0===s.getChildren().length&&s.parent===k))return!1;const h=s.Is(),A=s instanceof M.c&&!h.useRightHandedSystem?x:Z;return!!k.Sg.equalsWithEpsilon(A,V.c)||(q.c.Warn(`Cannot collapse node ${s.name} into parent node ${k.name} with modified scaling.`),!1)}function hs(s){if(s instanceof Array){const k=new Float32Array(s);return new Uint8Array(k.buffer,k.byteOffset,k.byteLength)}return ArrayBuffer.isView(s)?new Uint8Array(s.buffer,s.byteOffset,s.byteLength):new Uint8Array(s)}function As(s,k){for(const[h,A]of Object.entries(s)){const g=k[h];(Array.isArray(A)&&Array.isArray(g)&&gs(A,g)||A===g)&&delete s[h]}return s}function gs(s,k){return s.length===k.length&&s.every(((s,h)=>s===k[h]))}const mk=A.Matrix.Compose(new A.Pk(-1,1,1),A.Quaternion.Identity(),A.Pk.Zero());function is(s,k){if(!(s instanceof S.b))return!1;if(k){if(!s.getWorldMatrix().equalsWithEpsilon(A.Matrix.IdentityReadOnly,V.c))return!1}else{if(!s.getWorldMatrix().multiplyToRef(mk,A.TmpVectors.Matrix[0]).equalsWithEpsilon(A.Matrix.IdentityReadOnly,V.c))return!1}return!(s instanceof a.e&&s.mg)}const Ks=new Map([[Int8Array,(s,k,h)=>s.setInt8(k,h)],[Uint8Array,(s,k,h)=>s.setUint8(k,h)],[Uint8ClampedArray,(s,k,h)=>s.setUint8(k,h)],[Int16Array,(s,k,h)=>s.setInt16(k,h,!0)],[Uint16Array,(s,k,h)=>s.setUint16(k,h,!0)],[Int32Array,(s,k,h)=>s.setInt32(k,h,!0)],[Uint32Array,(s,k,h)=>s.setUint32(k,h,!0)],[Float32Array,(s,k,h)=>s.setFloat32(k,h,!0)],[Float64Array,(s,k,h)=>s.setFloat64(k,h,!0)]]);class Hs{writeTypedArray(s){this._checkGrowBuffer(s.byteLength);const k=Ks.get(s.constructor);for(let h=0;h<s.length;h++)k(this._dataView,this._byteOffset,s[h]),this._byteOffset+=s.BYTES_PER_ELEMENT}constructor(s){this._data=new Uint8Array(s),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(s){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,s),this._byteOffset++}writeInt8(s){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,s),this._byteOffset++}writeInt16(s){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,s,!0),this._byteOffset+=2}writeUInt16(s){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,s,!0),this._byteOffset+=2}writeInt32(s){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,s,!0),this._byteOffset+=4}writeUInt32(s){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,s,!0),this._byteOffset+=4}writeFloat32(s){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,s,!0),this._byteOffset+=4}writeFloat64(s){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,s,!0),this._byteOffset+=8}_checkGrowBuffer(s){const k=this.byteOffset+s;if(k>this._data.byteLength){const s=new Uint8Array(2*k);s.set(this._data),this._data=s,this._dataView=new DataView(this._data.buffer)}}}function Os(s){return s%4===0?4:s%2===0?2:1}class cs{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(s){let k=0;this._bufferViewToData.forEach((s=>{k+=s.byteLength}));const h=new Hs(k),A=Array.from(this._bufferViewToData.keys()).sort(((s,k)=>Os(k.byteLength)-Os(s.byteLength)));for(const g of A){g.byteOffset=h.byteOffset,s.push(g);const k=s.length-1,A=this.getPropertiesWithBufferView(g);for(const s of A)s.bufferView=k;h.writeTypedArray(this._bufferViewToData.get(g)),this._bufferViewToData.delete(g)}return h.getOutputData()}createBufferView(s,k){const h={buffer:0,byteOffset:void 0,byteLength:s.byteLength,byteStride:k};return this._bufferViewToData.set(h,s),h}createAccessor(s,k,h,A,g,ms,i){this._verifyBufferView(s);const K={bufferView:void 0,componentType:h,count:A,type:k,min:null===ms||void 0===ms?void 0:ms.min,max:null===ms||void 0===ms?void 0:ms.max,normalized:i,byteOffset:g};return this.setBufferView(K,s),this._accessorToBufferView.set(K,s),K}setBufferView(s,k){this._verifyBufferView(k);this.getPropertiesWithBufferView(k).push(s)}removeBufferView(s){const k=this.getPropertiesWithBufferView(s);for(const h of k)void 0!==h.bufferView&&delete h.bufferView;this._bufferViewToData.delete(s),this._bufferViewToProperties.delete(s),this._accessorToBufferView.forEach(((k,h)=>{k===s&&(void 0!==h.byteOffset&&delete h.byteOffset,this._accessorToBufferView.delete(h))}))}getBufferView(s){const k=this._accessorToBufferView.get(s);return this._verifyBufferView(k),k}getPropertiesWithBufferView(s){return this._verifyBufferView(s),this._bufferViewToProperties.set(s,this._bufferViewToProperties.get(s)??[]),this._bufferViewToProperties.get(s)}getData(s){return this._verifyBufferView(s),this._bufferViewToData.get(s)}_verifyBufferView(s){if(void 0===s||!this._bufferViewToData.has(s))throw new Error(`BufferView ${s} not found in BufferManager.`)}}var Ss,as=h(13067),rs=h(13081),ds=h(13099),Es=h(12984),js=h(13128),Ps=h(13143),Rs=h(13061),Ds=h(13147);!function(s){s[s.INTANGENT=0]="INTANGENT",s[s.OUTTANGENT=1]="OUTTANGENT"}(Ss||(Ss={}));class ws{static _IsTransformable(s){return s&&(s instanceof S.b||s instanceof as.d||s instanceof Ds.e)}static _CreateNodeAnimation(s,k,h,A,ms){if(this._IsTransformable(s)){const i=[],K=[],H=k.getKeys(),O=ws._CalculateMinMaxKeyFrames(H),c=ws._DeduceInterpolation(H,h,A),S=c.interpolationType,a=c.shouldBakeAnimation;if(a?ws._CreateBakedAnimation(s,k,h,O.min,O.max,k.framePerSecond,ms,i,K,O,A):"LINEAR"===S||"STEP"===S?ws._CreateLinearOrStepAnimation(s,k,h,i,K,A):"CUBICSPLINE"===S?ws._CreateCubicSplineAnimation(s,k,h,i,K,A):ws._CreateBakedAnimation(s,k,h,O.min,O.max,k.framePerSecond,ms,i,K,O,A),i.length&&K.length){return{inputs:i,outputs:K,samplerInterpolation:S,inputsMin:a?O.min:g.Tools.FloatRound(O.min/k.framePerSecond),inputsMax:a?O.max:g.Tools.FloatRound(O.max/k.framePerSecond)}}}return null}static _DeduceAnimationInfo(s){let k=null,h="VEC3",A=!1;const ms=s.targetProperty.split(".");switch(ms[0]){case"Sg":k="scale";break;case"position":k="translation";break;case"rotation":h="VEC4",k="rotation";break;case"rotationQuaternion":h="VEC4",A=!0,k="rotation";break;case"influence":h="SCALAR",k="weights";break;default:g.Tools.Error(`Unsupported animatable property ${ms[0]}`)}return k?{animationChannelTargetPath:k,dataAccessorType:h,useQuaternion:A}:(g.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(s,k,h,A,g,ms,i,K,H,O,c){let S;if(ws._IsTransformable(s)&&s.animations)for(const a of s.animations){if(c&&!c(a))continue;const g=ws._DeduceAnimationInfo(a);g&&(S={name:a.name,samplers:[],channels:[]},ws._AddAnimation(`${a.name}`,a.hasRunningRuntimeAnimations?k:S,s,a,g.dataAccessorType,g.animationChannelTargetPath,A,ms,i,K,g.useQuaternion,H,O),S.samplers.length&&S.channels.length&&h.push(S))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(s,k,h,A,g,ms,i,K,H,O,c){let S;if(s instanceof Rs.e){const g=s.morphTargetManager;if(g)for(let a=0;a<g.numTargets;++a){const r=g.getTarget(a);for(const d of r.animations){if(c&&!c(d))continue;const r=new js.c(`${d.name}`,"influence",d.framePerSecond,d.dataType,d.loopMode,d.enableBlending),E=[],j=d.getKeys();for(let s=0;s<j.length;++s){const k=j[s];for(let s=0;s<g.numTargets;++s)s==a?E.push(k):E.push({frame:k.frame,value:0})}r.setKeys(E);const P=ws._DeduceAnimationInfo(r);P&&(S={name:r.name,samplers:[],channels:[]},ws._AddAnimation(d.name,d.hasRunningRuntimeAnimations?k:S,s,r,P.dataAccessorType,P.animationChannelTargetPath,A,ms,i,K,P.useQuaternion,H,O,g.numTargets),S.samplers.length&&S.channels.length&&h.push(S))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(s,k,h,A,g,ms,i,K,H){let O;if(s.animationGroups){const S=s.animationGroups;for(const a of S){const S=new Map,r=new Map,d=new Set,E=a.to-a.from;O={name:a.name,channels:[],samplers:[]};for(let k=0;k<a.targetedAnimations.length;++k){const E=a.targetedAnimations[k],j=E.target,P=E.animation;if(H&&!H(P))continue;const R=K.has(j);if(this._IsTransformable(j)||1===j.length&&this._IsTransformable(j[0])){const s=ws._DeduceAnimationInfo(E.animation);if(s){const k=this._IsTransformable(j)?j:this._IsTransformable(j[0])?j[0]:null;k&&ws._AddAnimation(`${P.name}`,O,k,P,s.dataAccessorType,s.animationChannelTargetPath,h,A,g,ms,s.useQuaternion,i,R)}}else if(j instanceof Ps.b||1===j.length&&j[0]instanceof Ps.b){if(ws._DeduceAnimationInfo(E.animation)){const k=j instanceof Ps.b?j:j[0];if(k){const h=s.morphTargetManagers.find((s=>{for(let h=0;h<s.numTargets;++h)if(s.getTarget(h)===k)return!0;return!1}));if(h){const A=s.meshes.find((s=>s.morphTargetManager===h));var c;if(A)S.has(A)||S.set(A,new Map),null===(c=S.get(A))||void 0===c||c.set(k,P),d.add(A),r.set(A,P)}}}}}d.forEach((s=>{const k=s.morphTargetManager;let K=null;const H=[],c=r.get(s).getKeys(),d=c.length;for(let h=0;h<d;++h)for(let A=0;A<k.numTargets;++A){const g=k.getTarget(A),ms=S.get(s);if(ms){const k=ms.get(g);k?(K||(K=new js.c(`${a.name}_${s.name}_MorphWeightAnimation`,"influence",k.framePerSecond,js.c.ANIMATIONTYPE_FLOAT,k.loopMode,k.enableBlending)),H.push(k.getKeys()[h])):H.push({frame:a.from+E/d*h,value:g.influence,inTangent:c[0].inTangent?0:void 0,outTangent:c[0].outTangent?0:void 0})}}K.setKeys(H);const j=ws._DeduceAnimationInfo(K);j&&ws._AddAnimation(`${a.name}_${s.name}_MorphWeightAnimation`,O,s,K,j.dataAccessorType,j.animationChannelTargetPath,h,A,g,ms,j.useQuaternion,i,!1,null===k||void 0===k?void 0:k.numTargets)})),O.channels.length&&O.samplers.length&&k.push(O)}}}static _AddAnimation(s,k,h,g,ms,i,K,H,O,c,S,a,r,d){const E=ws._CreateNodeAnimation(h,g,i,S,a);let j,P,R,D,w,B;if(E){if(d){let s=0,k=0;const h=[];for(;E.inputs.length>0;)k=E.inputs.shift(),s%d==0&&h.push(k),s++;E.inputs=h}const s=K.get(h),g=new Float32Array(E.inputs);j=H.createBufferView(g),P=H.createAccessor(j,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),c.push(P),R=c.length-1;const O=new A.Quaternion,S=new A.Pk,a=new A.Pk,u=h instanceof as.d,G=W(ms),Q=new Float32Array(E.outputs.length*G);E.outputs.forEach((function(s,k){let h=s;switch(i){case"translation":r&&(A.Pk.FromArrayToRef(s,0,a),l(a),a.toArray(h));break;case"rotation":4===s.length?A.Quaternion.FromArrayToRef(s,0,O):(h=new Array(4),A.Pk.FromArrayToRef(s,0,S),A.Quaternion.FromEulerVectorToRef(S,O)),r&&(f(O),u&&e(O)),O.toArray(h)}Q.set(h,k*G)})),j=H.createBufferView(Q),P=H.createAccessor(j,ms,5126,E.outputs.length),c.push(P),D=c.length-1,w={interpolation:E.samplerInterpolation,input:R,output:D},k.samplers.push(w),B={sampler:k.samplers.length-1,target:{node:s,path:i}},k.channels.push(B)}}static _CreateBakedAnimation(s,k,h,ms,i,K,H,O,c,S,a){let r;const d=A.Quaternion.Identity();let E,j=null,P=null,R=null,D=null,w=null,B=null;S.min=g.Tools.FloatRound(ms/K);const u=k.getKeys();for(let A=0,G=u.length;A<G;++A){if(B=null,R=u[A],A+1<G)if(D=u[A+1],R.value.equals&&R.value.equals(D.value)||R.value===D.value){if(0!==A)continue;B=R.frame}else B=D.frame;else{if(w=u[A-1],R.value.equals&&R.value.equals(w.value)||R.value===w.value)continue;B=i}if(B)for(let A=R.frame;A<=B;A+=H){if(E=g.Tools.FloatRound(A/K),E===j)continue;j=E,P=E;const ms={key:0,repeatCount:0,loopMode:k.loopMode};r=k._interpolate(A,ms),ws._SetInterpolatedValue(s,r,E,k,h,d,O,c,a)}}P&&(S.max=P)}static _ConvertFactorToVector3OrQuaternion(s,k,h,ms,i){const K=ws._GetBasePositionRotationOrScale(k,ms,i),H=h.targetProperty.split("."),O=H?H[1]:"",c=i?A.Quaternion.uk(K).normalize():A.Pk.uk(K);switch(O){case"x":case"y":case"z":c[O]=s;break;case"w":c.w=s;break;default:g.Tools.Error(`glTFAnimation: Unsupported component name "${O}"!`)}return c}static _SetInterpolatedValue(s,k,h,g,ms,i,K,H,O){let c;K.push(h),"weights"!==ms?(g.dataType===js.c.ANIMATIONTYPE_FLOAT&&(k=this._ConvertFactorToVector3OrQuaternion(k,s,g,ms,O)),"rotation"===ms?(O?i=k:(c=k,A.Quaternion.RotationYawPitchRollToRef(c.y,c.x,c.z,i)),H.push(i.yh())):(c=k,H.push(c.yh()))):H.push([k])}static _CreateLinearOrStepAnimation(s,k,h,A,g,ms){for(const i of k.getKeys())A.push(i.frame/k.framePerSecond),ws._AddKeyframeValue(i,k,g,h,s,ms)}static _CreateCubicSplineAnimation(s,k,h,A,g,ms){k.getKeys().forEach((function(i){A.push(i.frame/k.framePerSecond),ws._AddSplineTangent(Ss.INTANGENT,g,h,"CUBICSPLINE",i,ms),ws._AddKeyframeValue(i,k,g,h,s,ms),ws._AddSplineTangent(Ss.OUTTANGENT,g,h,"CUBICSPLINE",i,ms)}))}static _GetBasePositionRotationOrScale(s,k,h){let g;if("rotation"===k)if(h){g=(s.rotationQuaternion??A.Quaternion.Identity()).yh()}else{g=(s.rotation??A.Pk.Zero()).yh()}else if("translation"===k){g=(s.position??A.Pk.Zero()).yh()}else{g=(s.Sg??A.Pk.One()).yh()}return g}static _AddKeyframeValue(s,k,h,ms,i,K){let H;const O=k.dataType;if(O===js.c.ANIMATIONTYPE_VECTOR3){let k=s.value.yh();if("rotation"===ms){const s=A.Pk.uk(k);k=A.Quaternion.RotationYawPitchRoll(s.y,s.x,s.z).yh()}h.push(k)}else if(O===js.c.ANIMATIONTYPE_FLOAT){if("weights"===ms)h.push([s.value]);else if(H=this._ConvertFactorToVector3OrQuaternion(s.value,i,k,ms,K),H){if("rotation"===ms){const s=K?H:A.Quaternion.RotationYawPitchRoll(H.y,H.x,H.z).normalize();h.push(s.yh())}h.push(H.yh())}}else O===js.c.ANIMATIONTYPE_QUATERNION?h.push(s.value.normalize().yh()):g.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(s,k,h){let A,g,ms=!1;if("rotation"===k&&!h)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let i=0,K=s.length;i<K;++i)if(g=s[i],g.inTangent||g.outTangent)if(A){if("CUBICSPLINE"!==A){A="LINEAR",ms=!0;break}}else A="CUBICSPLINE";else if(A){if("CUBICSPLINE"===A||g.interpolation&&1===g.interpolation&&"STEP"!==A){A="LINEAR",ms=!0;break}}else A=g.interpolation&&1===g.interpolation?"STEP":"LINEAR";return A||(A="LINEAR"),{interpolationType:A,shouldBakeAnimation:ms}}static _AddSplineTangent(s,k,h,g,ms,i){let K;const H=s===Ss.INTANGENT?ms.inTangent:ms.outTangent;if("CUBICSPLINE"===g){if("rotation"===h)if(H)if(i)K=H.yh();else{const s=H;K=A.Quaternion.RotationYawPitchRoll(s.y,s.x,s.z).yh()}else K=[0,0,0,0];else K="weights"===h?H?[H]:[0]:H?H.yh():[0,0,0];k.push(K)}}static _CalculateMinMaxKeyFrames(s){let k=1/0,h=-1/0;return s.forEach((function(s){k=Math.min(k,s.frame),h=Math.max(h,s.frame)})),{min:k,max:h}}}function Bs(s,k,h,ms,i,K){const H={attributes:{},influence:s.influence,name:s.name},O=k.mg;if(!O)return g.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),H;const S=K?-1:1,a=A.Pk.Zero();let r=0,d=0;if(s.hasPositions){const ms=s.getPositions(),K=O.getVerticesData(c.e.PositionKind);if(K){const s=new Float32Array(K.length),k=[1/0,1/0,1/0],g=[-1/0,-1/0,-1/0];d=K.length/3,r=0;for(let h=r;h<d;++h){const i=A.Pk.uk(K,3*h);A.Pk.uk(ms,3*h).subtractToRef(i,a),a.x*=S,k[0]=Math.min(k[0],a.x),g[0]=Math.max(g[0],a.x),k[1]=Math.min(k[1],a.y),g[1]=Math.max(g[1],a.y),k[2]=Math.min(k[2],a.z),g[2]=Math.max(g[2],a.z),s[3*h]=a.x,s[3*h+1]=a.y,s[3*h+2]=a.z}const O=h.createBufferView(s,12),c=h.createAccessor(O,"VEC3",5126,ms.length/3,0,{min:k,max:g});i.push(c),H.attributes.POSITION=i.length-1}else g.Tools.Warn(`Morph target positions for mesh ${k.name} were not exported. Mesh does not have position vertex data`)}if(s.hasNormals){const ms=s.getNormals(),K=O.getVerticesData(c.e.NormalKind);if(K){const s=new Float32Array(K.length);d=K.length/3,r=0;for(let h=r;h<d;++h){const k=A.Pk.uk(K,3*h).normalize();A.Pk.uk(ms,3*h).normalize().subtractToRef(k,a),s[3*h]=a.x*S,s[3*h+1]=a.y,s[3*h+2]=a.z}const k=h.createBufferView(s,12),g=h.createAccessor(k,"VEC3",5126,ms.length/3,0);i.push(g),H.attributes.NORMAL=i.length-1}else g.Tools.Warn(`Morph target normals for mesh ${k.name} were not exported. Mesh does not have normals vertex data`)}if(s.hasTangents){const ms=s.getTangents(),K=O.getVerticesData(c.e.TangentKind);if(K){d=K.length/4;const s=new Float32Array(3*d);r=0;for(let h=r;h<d;++h){const k=A.Pk.uk(K,4*h);o(k);const g=A.Pk.uk(ms,3*h);o(g),g.subtractToRef(k,a),s[3*h]=a.x*S,s[3*h+1]=a.y,s[3*h+2]=a.z}const k=h.createBufferView(s,12),g=h.createAccessor(k,"VEC3",5126,d,0);i.push(g),H.attributes.TANGENT=i.length-1}else g.Tools.Warn(`Morph target tangents for mesh ${k.name} were not exported. Mesh does not have tangents vertex data`)}if(s.hasColors){const ms=s.getColors(),K=O.getVerticesData(c.e.ColorKind),S=O.getVertexBuffer(c.e.ColorKind);if(K&&S){const s=S.getSize();d=K.length/s;const k=new Float32Array(d*s);r=0;for(let h=r;h<d;++h)if(3===s){const g=A.Pk.uk(K,h*s);A.Pk.uk(ms,h*s).subtractToRef(g,a),k[3*h]=a.x,k[3*h+1]=a.y,k[3*h+2]=a.z}else if(4===s){const g=new A.Vector4,i=A.Vector4.uk(K,h*s);A.Vector4.uk(ms,h*s).subtractToRef(i,g),k[4*h]=g.x,k[4*h+1]=g.y,k[4*h+2]=g.z,k[4*h+3]=g.w}else g.Tools.Warn(`Unsupported number of components for color attribute: ${s}`);const O=h.createBufferView(k,4*s),c=h.createAccessor(O,3===s?"VEC3":"VEC4",5126,d,0);i.push(c),H.attributes.COLOR_0=i.length-1}else g.Tools.Warn(`Morph target colors for mesh ${k.name} were not exported. Mesh does not have colors vertex data`)}return H}var us=h(13150),Gs=h(13019),Qs=h(13001),ps=h(12543);class Is{}Is.DEFAULT_COLOR=j.Bk.White(),Is.DEFAULT_WIDTH_ATTENUATED=1,Is.DEFAULT_WIDTH=.1;var Ns=h(12802),bs=h(13158);class ts{static ConvertPoints(s,k){if(s.length&&Array.isArray(s)&&"number"===typeof s[0])return[s];if(s.length&&Array.isArray(s[0])&&"number"===typeof s[0][0])return s;if(s.length&&!Array.isArray(s[0])&&s[0]instanceof A.Pk){const k=[];for(let h=0;h<s.length;h++){const A=s[h];k.push(A.x,A.y,A.z)}return[k]}if(s.length>0&&Array.isArray(s[0])&&s[0].length>0&&s[0][0]instanceof A.Pk){const k=[],h=s;for(const s of h)k.push(s.flatMap((s=>[s.x,s.y,s.z])));return k}if(s instanceof Float32Array){if(null!==k&&void 0!==k&&k.floatArrayStride){const h=[],A=3*k.floatArrayStride;for(let k=0;k<s.length;k+=A){const g=new Array(A);for(let h=0;h<A;h++)g[h]=s[k+h];h.push(g)}return h}return[Array.from(s)]}if(s.length&&s[0]instanceof Float32Array){const k=[];for(const h of s)k.push(Array.from(h));return k}return[]}static OmitZeroLengthPredicate(s,k,h){const A=[];return k.Rk(s).lengthSquared()>0&&A.push([s,k]),h.Rk(k).lengthSquared()>0&&A.push([k,h]),s.Rk(h).lengthSquared()>0&&A.push([h,s]),0===A.length?null:A}static OmitDuplicatesPredicate(s,k,h,A){const g=[];return ts._SearchInPoints(s,k,A)||g.push([s,k]),ts._SearchInPoints(k,h,A)||g.push([k,h]),ts._SearchInPoints(h,s,A)||g.push([h,s]),0===g.length?null:g}static _SearchInPoints(s,k,h){for(const i of h)for(let h=0;h<i.length;h++){var A,g,ms;if(null!==(A=i[h])&&void 0!==A&&A.equals(s))if(null!==(g=i[h+1])&&void 0!==g&&g.equals(k)||null!==(ms=i[h-1])&&void 0!==ms&&ms.equals(k))return!0}return!1}static MeshesToLines(s,k){const h=[];for(let g=0;g<s.length;g++){const ms=s[g],i=ms.getVerticesData(c.e.PositionKind),K=ms.sg();if(i&&K)for(let s=0,H=0;s<K.length;s++){const O=3*K[H++],c=3*K[H++],S=3*K[H++],a=new A.Pk(i[O],i[O+1],i[O+2]),r=new A.Pk(i[c],i[c+1],i[c+2]),d=new A.Pk(i[S],i[S+1],i[S+2]);if(k){const A=k(a,r,d,h,s,O,ms,g,i,K);if(A)for(const s of A)h.push(s)}else h.push([a,r],[r,d],[d,a])}}return h}static ToVector3Array(s){if(Array.isArray(s[0])){const k=[],h=s;for(const s of h){const h=[];for(let k=0;k<s.length;k+=3)h.push(new A.Pk(s[k],s[k+1],s[k+2]));k.push(h)}return k}const k=s,h=[];for(let g=0;g<k.length;g+=3)h.push(new A.Pk(k[g],k[g+1],k[g+2]));return h}static ToNumberArray(s){return s.flatMap((s=>[s.x,s.y,s.z]))}static GetPointsCountInfo(s){const k=new Array(s.length);let h=0;for(let A=s.length;A--;)k[A]=s[A].length/3,h+=k[A];return{total:h,counts:k}}static GetLineLength(s){if(0===s.length)return 0;let k;k="number"===typeof s[0]?ts.ToVector3Array(s):s;const h=A.TmpVectors.Pk[0];let g=0;for(let A=0;A<k.length-1;A++){const s=k[A];g+=k[A+1].subtractToRef(s,h).length()}return g}static GetLineLengthArray(s){const k=new Float32Array(s.length/3);let h=0;for(let A=0,g=s.length/3-1;A<g;A++){let g=s[3*A+0],ms=s[3*A+1],i=s[3*A+2];g-=s[3*A+3],ms-=s[3*A+4],i-=s[3*A+5];h+=Math.sqrt(g*g+ms*ms+i*i),k[A+1]=h}return k}static SegmentizeSegmentByCount(s,k,h){const g=[],ms=k.Rk(s),i=A.TmpVectors.Pk[0];i.Eg(h);const K=A.TmpVectors.Pk[1];ms.divideToRef(i,K);let H=s.clone();g.push(H);for(let A=0;A<h;A++)H=H.clone(),g.push(H.addInPlace(K));return g}static SegmentizeLineBySegmentLength(s,k){const h=s[0]instanceof A.Pk?ts.GetLineSegments(s):"number"===typeof s[0]?ts.GetLineSegments(ts.ToVector3Array(s)):s,g=[];for(const A of h)if(A.length>k){const s=ts.SegmentizeSegmentByCount(A.point1,A.point2,Math.ceil(A.length/k));for(const k of s)g.push(k)}else g.push(A.point1),g.push(A.point2);return g}static SegmentizeLineBySegmentCount(s,k){const h="number"===typeof s[0]?ts.ToVector3Array(s):s,A=ts.GetLineLength(h)/k;return ts.SegmentizeLineBySegmentLength(h,A)}static GetLineSegments(s){const k=[];for(let h=0;h<s.length-1;h++){const A=s[h],g=s[h+1],ms=g.Rk(A).length();k.push({point1:A,point2:g,length:ms})}return k}static GetMinMaxSegmentLength(s){const k=ts.GetLineSegments(s).sort((s=>s.length));return{min:k[0].length,max:k[k.length-1].length}}static GetPositionOnLineByVisibility(s,k,h){let g=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const ms=k*h;let i=0,K=0;const H=s.length;for(let A=0;A<H;A++){if(ms<=i+s[A].length){K=A;break}i+=s[A].length}const O=(ms-i)/s[K].length;return s[K].point2.subtractToRef(s[K].point1,A.TmpVectors.Pk[0]),A.TmpVectors.Pk[1]=A.TmpVectors.Pk[0].multiplyByFloats(O,O,O),g||A.TmpVectors.Pk[1].addInPlace(s[K].point1),A.TmpVectors.Pk[1].clone()}static GetCircleLinePoints(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,g=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s,ms=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/k;const i=[];for(let K=0;K<=k;K++)i.push(new A.Pk(Math.cos(K*ms)*s,Math.sin(K*ms)*g,h));return i}static GetBezierLinePoints(s,k,h,A){return Ns.e.CreateQuadraticBezier(s,k,h,A).getPoints().flatMap((s=>[s.x,s.y,s.z]))}static GetArrowCap(s,k,h,A,g){let ms=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[s.clone(),s.add(k.multiplyByFloats(h,h,h))],widths:[A,g,ms,i]}}static GetPointsFromText(s,k,h,A){let g=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,ms=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const i=[],K=(0,bs.b)(s,k,h,A);for(const H of K){for(const s of H.paths){const k=[],h=s.getPoints();for(const s of h)k.push(s.x,s.y,g);i.push(k)}if(ms)for(const s of H.holes){const k=[],h=s.getPoints();for(const s of h)k.push(s.x,s.y,g);i.push(k)}}return i}static Color3toRGBAUint8(s){const k=new Uint8Array(4*s.length);for(let h=0,A=0;h<s.length;h++)k[A++]=255*s[h].r,k[A++]=255*s[h].g,k[A++]=255*s[h].b,k[A++]=255;return k}static CreateColorsTexture(s,k,h,A){const g=A.getEngine().getCaps().maxTextureSize??1,ms=k.length>g?g:k.length,i=Math.ceil(k.length/g);i>1&&(k=[...k,...Array(ms*i-k.length).fill(k[0])]);const K=ts.Color3toRGBAUint8(k),H=new u.e(K,ms,i,d.b.TEXTUREFORMAT_RGBA,A,!1,!0,h);return H.name=s,H}static PrepareEmptyColorsTexture(s){if(!Is.EmptyColorsTexture){const k=new Uint8Array(4);Is.EmptyColorsTexture=new u.e(k,1,1,d.b.TEXTUREFORMAT_RGBA,s,!1,!1,u.e.NEAREST_NEAREST),Is.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Is.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var s;null===(s=Is.EmptyColorsTexture)||void 0===s||s.dispose(),Is.EmptyColorsTexture=null}static BooleanToNumber(s){return s?1:0}}class zs extends Qs.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Cs extends Gs.b{isCompatible(s){return!0}constructor(s,k,h){var g;h=h||{color:Is.DEFAULT_COLOR};const ms=new zs;ms.GREASED_LINE_HAS_COLOR=!!h.color&&!h.useColors,ms.GREASED_LINE_SIZE_ATTENUATION=h.sizeAttenuation??!1,ms.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===h.colorDistributionType,ms.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(k??s.Is()).useRightHandedSystem,ms.GREASED_LINE_CAMERA_FACING=h.cameraFacing??!0,super(s,Cs.GREASED_LINE_MATERIAL_NAME,200,ms,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(g=h)||void 0===g?void 0:g.forceGLSL)||Cs.ForceGLSL,this._scene=k??s.Is(),this._engine=this._scene.getEngine(),this._cameraFacing=h.cameraFacing??!0,this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.width=h.width?h.width:h.sizeAttenuation?Is.DEFAULT_WIDTH_ATTENUATED:Is.DEFAULT_WIDTH,this._sizeAttenuation=h.sizeAttenuation??!1,this.colorMode=h.colorMode??0,this._color=h.color??null,this.useColors=h.useColors??!1,this._colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??u.e.NEAREST_NEAREST,this._colors=h.zs??null,this.dashCount=h.dashCount??1,this.resolution=h.resolution??new A.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=ts.CreateColorsTexture(`${s.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Is.DEFAULT_COLOR,ts.PrepareEmptyColorsTexture(this._scene)),this._engine.Dh.add((()=>{ts.DisposeEmptyColorsTexture()}))}getAttributes(s){s.push("grl_offsets"),s.push("grl_widths"),s.push("grl_colorPointers"),s.push("grl_counters"),this._cameraFacing?(s.push("grl_previousAndSide"),s.push("grl_nextAndCounters")):s.push("grl_slopes")}getSamplers(s){s.push("grl_colors")}getActiveTextures(s){this.colorsTexture&&s.push(this.colorsTexture)}getUniforms(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const k=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&k.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===s&&k.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:k,vertex:this._cameraFacing&&this._isGLSL(s)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(s)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(s){if(this._cameraFacing){s.Fh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||s.Fh("viewProjection",this._scene.getTransformMatrix());const k=A.TmpVectors.Vector4[0];k.x=this._aspect,k.y=this._resolution.x,k.z=this._resolution.y,k.w=this.width,s.updateVector4("grl_aspect_resolution_lineWidth",k)}const k=A.TmpVectors.Vector4[0];k.x=ts.BooleanToNumber(this.useDash),k.y=this._dashArray,k.z=this.dashOffset,k.w=this.dashRatio,s.updateVector4("grl_dashOptions",k);const h=A.TmpVectors.Vector4[1];h.x=this.colorMode,h.y=this.visibility,h.z=this.colorsTexture?this.colorsTexture.getSize().width:0,h.w=ts.BooleanToNumber(this.useColors),s.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",h),this._color&&s.updateColor3("grl_singleColor",this._color);const g=this.colorsTexture??Is.EmptyColorsTexture;s.setTexture("grl_colors",g),s.updateFloat2("grl_textureSize",(null===g||void 0===g?void 0:g.getSize().width)??1,(null===g||void 0===g?void 0:g.getSize().height)??1)}prepareDefines(s,k,h){s.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,s.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,s.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,s.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=k.useRightHandedSystem,s.GREASED_LINE_CAMERA_FACING=this._cameraFacing,s.GREASED_LINE_USE_OFFSETS=!!h.offsets}getClassName(){return Cs.GREASED_LINE_MATERIAL_NAME}getCustomCode(s){let k=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(k)?function(s,k){if("vertex"===s){const s={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return k&&(s["!gl_Position\\=viewProjection\\*worldPos;"]="//"),s}return"fragment"===s?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(s,this._cameraFacing):function(s,k){if("vertex"===s){const s={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return k&&(s["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),s}return"fragment"===s?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(s,this._cameraFacing)}dispose(){var s;null===(s=this.colorsTexture)||void 0===s||s.dispose(),super.dispose()}get zs(){return this._colors}set zs(s){this.setColors(s)}setColors(s){var k;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(k=this._colors)||void 0===k?void 0:k.length)??0;var ms;if(this._colors=s,null!==s&&0!==s.length){if(!h||A)if(this.colorsTexture&&g===s.length&&!A){const k=ts.Color3toRGBAUint8(s);this.colorsTexture.update(k)}else{var i;null===(i=this.colorsTexture)||void 0===i||i.dispose(),this.colorsTexture=ts.CreateColorsTexture(`${this._material.name}-colors-texture`,s,this.colorsSampling,this._scene)}}else null===(ms=this.colorsTexture)||void 0===ms||ms.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(s){this._dashCount=s,this._dashArray=1/s}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(s){this._sizeAttenuation=s,this.markAllDefinesAsDirty()}get color(){return this._color}set color(s){this.setColor(s)}setColor(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==s||null!==this._color&&null===s?(this._color=s,k||this.markAllDefinesAsDirty()):this._color=s}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(s){this._colorsDistributionType=s,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(s){this._aspect=s.x/s.y,this._resolution=s}serialize(){const s=super.serialize(),k={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(k.zs=this._colors),this._color&&(k.color=this._color),s.greasedLineMaterialOptions=k,s}parse(s,k,h){var A;super.parse(s,k,h);const g=s.greasedLineMaterialOptions;null===(A=this.colorsTexture)||void 0===A||A.dispose(),g.color&&this.setColor(g.color,!0),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.zs&&(this.zs=g.zs),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),this.zs?this.colorsTexture=ts.CreateColorsTexture(`${this._material.name}-colors-texture`,this.zs,this.colorsSampling,k):ts.PrepareEmptyColorsTexture(k),this.markAllDefinesAsDirty()}copyTo(s){var k;const h=s;null===(k=h.colorsTexture)||void 0===k||k.dispose(),this._colors&&(h.colorsTexture=ts.CreateColorsTexture(`${h._material.name}-colors-texture`,this._colors,h.colorsSampling,this._scene)),h.setColor(this.color,!0),h.colorsDistributionType=this.colorsDistributionType,h.colorsSampling=this.colorsSampling,h.colorMode=this.colorMode,h.useColors=this.useColors,h.visibility=this.visibility,h.useDash=this.useDash,h.dashCount=this.dashCount,h.dashRatio=this.dashRatio,h.dashOffset=this.dashOffset,h.width=this.width,h.sizeAttenuation=this.sizeAttenuation,h.resolution=this.resolution,h.markAllDefinesAsDirty()}_isGLSL(s){return 0===s||this._forceGLSL}}Cs.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Cs.ForceGLSL=!1,(0,ps.f)(`BABYLON.${Cs.GREASED_LINE_MATERIAL_NAME}`,Cs);var vs=h(13047),Ys=h(12429),ns=h(12827),Ts=h(12523);class Us extends ns.ShaderMaterial{constructor(s,k,g){const ms=k.getEngine(),i=ms.isWebGPU&&!(g.forceGLSL||Us.ForceGLSL),K=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];k.useRightHandedSystem&&K.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const H=["position","grl_widths","grl_offsets","grl_colorPointers"];g.cameraFacing?(K.push("GREASED_LINE_CAMERA_FACING"),H.push("grl_previousAndSide","grl_nextAndCounters")):(H.push("grl_slopes"),H.push("grl_counters"));const O=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(i||O.push("world","viewProjection","view","projection"),super(s,k,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:i?["Scene","Mesh"]:void 0,attributes:H,uniforms:O,samplers:i?[]:["grlColors"],defines:K,extraInitializationsAsync:async()=>{i?await Promise.all([h.e(66).then(h.bind(h,15759)),h.e(75).then(h.bind(h,15764))]):await Promise.all([h.e(69).then(h.bind(h,15773)),h.e(76).then(h.bind(h,15781))])},shaderLanguage:i?1:0}),this._color=j.Bk.White(),this._colorsDistributionType=0,this._colorsTexture=null,g=g||{color:Is.DEFAULT_COLOR},this.visibility=g.visibility??1,this.useDash=g.useDash??!1,this.dashRatio=g.dashRatio??.5,this.dashOffset=g.dashOffset??0,this.dashCount=g.dashCount??1,this.width=g.width?g.width:g.sizeAttenuation&&g.cameraFacing?Is.DEFAULT_WIDTH_ATTENUATED:Is.DEFAULT_WIDTH,this.sizeAttenuation=g.sizeAttenuation??!1,this.color=g.color??j.Bk.White(),this.useColors=g.useColors??!1,this.colorsDistributionType=g.colorDistributionType??0,this.colorsSampling=g.colorsSampling??u.e.NEAREST_NEAREST,this.colorMode=g.colorMode??0,this._colors=g.zs??null,this._cameraFacing=g.cameraFacing??!0,this.resolution=g.resolution??new A.Vector2(ms.getRenderWidth(),ms.getRenderHeight()),g.colorsTexture?this.colorsTexture=g.colorsTexture:this._colors?this.colorsTexture=ts.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,k):(this._color=this._color??Is.DEFAULT_COLOR,this.colorsTexture=ts.PrepareEmptyColorsTexture(k)),i){const s=new Ts.c;s.setParameters(),s.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",s)}ms.Dh.add((()=>{ts.DisposeEmptyColorsTexture()}))}dispose(){var s;null===(s=this._colorsTexture)||void 0===s||s.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new A.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get zs(){return this._colors}set zs(s){this.setColors(s)}setColors(s){var k;let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const g=(null===(k=this._colors)||void 0===k?void 0:k.length)??0;var ms;if(this._colors=s,null!==s&&0!==s.length){if(!h||A)if(this._colorsTexture&&g===s.length&&!A){const k=ts.Color3toRGBAUint8(s);this._colorsTexture.update(k)}else{var i;null===(i=this._colorsTexture)||void 0===i||i.dispose(),this.colorsTexture=ts.CreateColorsTexture(`${this.name}-colors-texture`,s,this.colorsSampling,this.Is())}}else null===(ms=this._colorsTexture)||void 0===ms||ms.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(s){this._colorsTexture=s,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(s){this._width=s,this.setFloat("grlWidth",s)}get useColors(){return this._useColors}set useColors(s){this._useColors=s,this.setFloat("grlUseColors",ts.BooleanToNumber(s))}get colorsSampling(){return this._colorsSampling}set colorsSampling(s){this._colorsSampling=s}get visibility(){return this._visibility}set visibility(s){this._visibility=s,this.setFloat("grlVisibility",s)}get useDash(){return this._useDash}set useDash(s){this._useDash=s,this.setFloat("grlUseDash",ts.BooleanToNumber(s))}get dashOffset(){return this._dashOffset}set dashOffset(s){this._dashOffset=s,this.setFloat("grlDashOffset",s)}get dashRatio(){return this._dashRatio}set dashRatio(s){this._dashRatio=s,this.setFloat("grlDashRatio",s)}get dashCount(){return this._dashCount}set dashCount(s){this._dashCount=s,this._dashArray=1/s,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(s){this._sizeAttenuation=s,this.setFloat("grlSizeAttenuation",ts.BooleanToNumber(s))}get color(){return this._color}set color(s){this.setColor(s)}setColor(s){s=s??Is.DEFAULT_COLOR,this._color=s,this.setColor3("grlColor",s)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(s){this._colorsDistributionType=s,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(s){this._colorMode=s,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(s){this._resolution=s,this.setVector2("grlResolution",s),this.setFloat("grlAspect",s.x/s.y)}serialize(){const s=super.serialize(),k={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(k.zs=this._colors),s.greasedLineMaterialOptions=k,s}parse(s,k,h){var A;const g=s.greasedLineMaterialOptions;null===(A=this._colorsTexture)||void 0===A||A.dispose(),g.color&&(this.color=g.color),g.colorDistributionType&&(this.colorsDistributionType=g.colorDistributionType),g.colorsSampling&&(this.colorsSampling=g.colorsSampling),g.colorMode&&(this.colorMode=g.colorMode),g.useColors&&(this.useColors=g.useColors),g.visibility&&(this.visibility=g.visibility),g.useDash&&(this.useDash=g.useDash),g.dashCount&&(this.dashCount=g.dashCount),g.dashRatio&&(this.dashRatio=g.dashRatio),g.dashOffset&&(this.dashOffset=g.dashOffset),g.width&&(this.width=g.width),g.sizeAttenuation&&(this.sizeAttenuation=g.sizeAttenuation),g.resolution&&(this.resolution=g.resolution),g.zs?this.colorsTexture=ts.CreateColorsTexture(`${this.name}-colors-texture`,g.zs,this.colorsSampling,this.Is()):this.colorsTexture=ts.PrepareEmptyColorsTexture(k),this._cameraFacing=g.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var qs,Ms,Vs;Us.ForceGLSL=!1,function(s){s[s.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",s[s.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(qs||(qs={})),function(s){s[s.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",s[s.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",s[s.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ms||(Ms={})),function(s){s[s.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",s[s.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",s[s.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",s[s.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",s[s.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Vs||(Vs={}));class Xs extends Rs.e{constructor(s,k,h){super(s,k,null,null,!1,!1),this.name=s,this._options=h,this._lazy=!1,this._updatable=!1,this._engine=k.getEngine(),this._lazy=h.lazy??!1,this._updatable=h.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=h.colorPointers??[],this._widths=h.widths??new Array(h.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(s){let k=0;for(const A of this._points)k+=A.length;const h=k/3*2-this._widths.length;for(let A=0;A<h;A++)this._widths.push(s)}updateLazy(){var s,k;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(s=this._options.ribbonOptions)||void 0===s?void 0:s.smoothShading),!this.ns&&this.refreshBoundingInfo(),null===(k=this.greasedLineMaterial)||void 0===k||k.updateLazy()}addPoints(s,k){for(const h of s)this._points.push(h);this._lazy||this.setPoints(this._points,k)}dispose(s){let k=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(s,k)}isLazy(){return this._lazy}get Cs(){return this._uvs}set Cs(s){this._uvs=s instanceof Float32Array?s:new Float32Array(s),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(s){this.material instanceof Us&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===s||void 0===s?void 0:s.length)>0),this._offsets=s,this._offsetsBuffer?this._offsetsBuffer.update(s):this._createOffsetsBuffer(s)}get widths(){return this._widths}set widths(s){this._widths=s,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(s)}get colorPointers(){return this._colorPointers}set colorPointers(s){this._colorPointers=s,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(s)}get greasedLineMaterial(){var s,k;if(this.material&&this.material instanceof Us)return this.material;const h=null===(s=this.material)||void 0===s||null===(k=s.pluginManager)||void 0===k?void 0:k.getPlugin(Cs.GREASED_LINE_MATERIAL_NAME);return h||void 0}get points(){const s=[];return Ys.e.DeepCopy(this._points,s),s}setPoints(s,k){this._points=ts.ConvertPoints(s,(null===k||void 0===k?void 0:k.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==k&&void 0!==k&&k.colorPointers||this._updateColorPointers(),this._setPoints(this._points,k)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Cs:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(s){super.serialize(s),s.type=this.getClassName(),s.lineOptions=this._createLineOptions()}_createVertexBuffers(){let s=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const k=new vs.c;return k.bs=this._vertexPositions,k.indices=this._indices,k.Cs=this._uvs,s&&(k.ts=[],vs.c.ComputeNormals(this._vertexPositions,this._indices,k.ts)),k.Ys(this,this._options.updatable),k}_createOffsetsBuffer(s){const k=this._scene.getEngine(),h=new c.b(k,s,this._updatable,3);this.setVerticesBuffer(h.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=h}}class Ls{constructor(s,k){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=s,this.wasAddedByNoopNode=k}getIndicesAccessor(s,k,h,A,g){var ms,i,K,H;return null===(ms=this._indicesAccessorMap.get(s))||void 0===ms||null===(i=ms.get(k))||void 0===i||null===(K=i.get(h))||void 0===K||null===(H=K.get(A))||void 0===H?void 0:H.get(g)}setIndicesAccessor(s,k,h,A,g,ms){let i=this._indicesAccessorMap.get(s);i||(i=new Map,this._indicesAccessorMap.set(s,i));let K=i.get(k);K||(K=new Map,i.set(k,K));let H=K.get(h);H||(H=new Map,K.set(h,H));let O=H.get(A);O||(O=new Map,H.set(A,O)),O.set(g,ms)}pushExportedNode(s){this._exportedNodes.has(s)||this._exportedNodes.add(s)}getNodesSet(){return this._exportedNodes}getVertexBufferView(s){return this._vertexBufferViewMap.get(s)}setVertexBufferView(s,k){this._vertexBufferViewMap.set(s,k)}setRemappedBufferView(s,k,h){this._remappedBufferView.set(s,new Map),this._remappedBufferView.get(s).set(k,h)}getRemappedBufferView(s,k){var h;return null===(h=this._remappedBufferView.get(s))||void 0===h?void 0:h.get(k)}getVertexAccessor(s,k,h){var A,g;return null===(A=this._vertexAccessorMap.get(s))||void 0===A||null===(g=A.get(k))||void 0===g?void 0:g.get(h)}setVertexAccessor(s,k,h,A){let g=this._vertexAccessorMap.get(s);g||(g=new Map,this._vertexAccessorMap.set(s,g));let ms=g.get(k);ms||(ms=new Map,g.set(k,ms)),ms.set(h,A)}hasVertexColorAlpha(s){return this._vertexMapColorAlpha.get(s)||!1}setHasVertexColorAlpha(s,k){return this._vertexMapColorAlpha.set(s,k)}getMesh(s){return this._meshMap.get(s)}setMesh(s,k){this._meshMap.set(s,k)}bindMorphDataToMesh(s,k){const h=this._meshMorphTargetMap.get(s)||[];this._meshMorphTargetMap.set(s,h),-1===h.indexOf(k)&&h.push(k)}getMorphTargetsFromMesh(s){return this._meshMorphTargetMap.get(s)}}class Zs{_ApplyExtension(s,k,h,A){if(h>=k.length)return Promise.resolve(s);const g=A(k[h],s);return g?g.then((async s=>s?await this._ApplyExtension(s,k,h+1,A):null)):this._ApplyExtension(s,k,h+1,A)}_ApplyExtensions(s,k){const h=[];for(const A of Zs._ExtensionNames)h.push(this._extensions[A]);return this._ApplyExtension(s,h,0,k)}_extensionsPreExportTextureAsync(s,k,h){return this._ApplyExtensions(k,((k,A)=>k.preExportTextureAsync&&k.preExportTextureAsync(s,A,h)))}_extensionsPostExportNodeAsync(s,k,h,A,g){return this._ApplyExtensions(k,((k,ms)=>k.postExportNodeAsync&&k.postExportNodeAsync(s,ms,h,A,g,this._bufferManager)))}_extensionsPostExportMaterialAsync(s,k,h){return this._ApplyExtensions(k,((k,A)=>k.postExportMaterialAsync&&k.postExportMaterialAsync(s,A,h)))}_extensionsPostExportMaterialAdditionalTextures(s,k,h){const A=[];for(const g of Zs._ExtensionNames){const ms=this._extensions[g];ms.postExportMaterialAdditionalTextures&&A.push(...ms.postExportMaterialAdditionalTextures(s,k,h))}return A}_extensionsPostExportTextures(s,k,h){for(const A of Zs._ExtensionNames){const g=this._extensions[A];g.postExportTexture&&g.postExportTexture(s,k,h)}}_extensionsPostExportMeshPrimitive(s){for(const k of Zs._ExtensionNames){const h=this._extensions[k];h.postExportMeshPrimitive&&h.postExportMeshPrimitive(s,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const s of Zs._ExtensionNames){const k=this._extensions[s];k.preGenerateBinaryAsync&&await k.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(s){for(const k of Zs._ExtensionNames){const h=this._extensions[k];h.enabled&&s(h)}}_extensionsOnExporting(){this._forEachExtensions((s=>{var k,h,A;s.wasUsed&&((k=this._glTF).extensionsUsed||(k.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(s.name)&&this._glTF.extensionsUsed.push(s.name),s.required&&((h=this._glTF).extensionsRequired||(h.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(s.name)&&this._glTF.extensionsRequired.push(s.name)),(A=this._glTF).extensions||(A.extensions={}),s.onExporting&&s.onExporting())}))}_loadExtensions(){for(const s of Zs._ExtensionNames){const k=Zs._ExtensionFactories[s](this);this._extensions[s]=k}}constructor(){let s=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.b.LastCreatedScene,k=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${d.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new T(this),this._extensions={},this._bufferManager=new cs,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!s)throw new Error("No scene available to export");this._babylonScene=s,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:s=>{var k;return null===s||void 0===s||null===(k=s.th)||void 0===k?void 0:k.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...k},this._loadExtensions()}dispose(){for(const s in this._extensions){this._extensions[s].dispose()}}get options(){return this._options}static RegisterExtension(s,k){Zs.UnregisterExtension(s)&&g.Tools.Warn(`Extension with the name ${s} already exists`),Zs._ExtensionFactories[s]=k,Zs._ExtensionNames.push(s)}static UnregisterExtension(s){if(!Zs._ExtensionFactories[s])return!1;delete Zs._ExtensionFactories[s];const k=Zs._ExtensionNames.indexOf(s);return-1!==k&&Zs._ExtensionNames.splice(k,1),!0}_generateJSON(s,k,h){const A={byteLength:s};return A.byteLength&&(this._glTF.buffers=[A]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Dk=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(A.uri=k+".bin"),h?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(s){const k=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(k.byteLength,s,!0),A=new Blob([k],{type:"application/octet-stream"}),g=s+".gltf",ms=s+".bin",i=new O;if(i.files[g]=h,i.files[ms]=A,this._imageData)for(const K in this._imageData)i.files[K]=new Blob([this._imageData[K].data],{type:this._imageData[K].mimeType});return i}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(s){const k=s%4;return 0===k?k:4-k}async generateGLBAsync(s){this._shouldUseGlb=!0;const k=await this._generateBinaryAsync();this._extensionsOnExporting();const h=this._generateJSON(k.byteLength),A=s+".glb";let g,ms=h.length;if("undefined"!==typeof TextEncoder){g=(new TextEncoder).encode(h),ms=g.length}const i=this._getPadding(ms),K=this._getPadding(k.byteLength),H=28+ms+i+k.byteLength+K,c=new Hs(H);if(c.writeUInt32(1179937895),c.writeUInt32(2),c.writeUInt32(H),c.writeUInt32(ms+i),c.writeUInt32(1313821514),g)c.writeTypedArray(g);else{const s="_".charCodeAt(0);for(let k=0;k<ms;++k){const A=h.charCodeAt(k);A!=h.codePointAt(k)?c.writeUInt8(s):c.writeUInt8(A)}}for(let O=0;O<i;++O)c.writeUInt8(32);c.writeUInt32(k.byteLength+K),c.writeUInt32(5130562),c.writeTypedArray(k);for(let O=0;O<K;++O)c.writeUInt8(0);const S=new O;return S.files[A]=new Blob([c.getOutputData()],{type:"application/octet-stream"}),S}_setNodeTransformation(s,k,h){if(k.getPivotPoint().equalsWithEpsilon(X,V.c)||g.Tools.Warn("Pivot points are not supported in the glTF serializer"),!k.position.equalsWithEpsilon(X,V.c)){const g=A.TmpVectors.Pk[0].H(k.position);h&&l(g),s.translation=g.yh()}k.Sg.equalsWithEpsilon(Z,V.c)||(s.scale=k.Sg.yh());const ms=k.rotationQuaternion||A.Quaternion.FromEulerAngles(k.rotation.x,k.rotation.y,k.rotation.z);ms.equalsWithEpsilon(L,V.c)||(h&&f(ms),s.rotation=ms.normalize().yh())}_setCameraTransformation(s,k,h){if(!k.position.equalsWithEpsilon(X,V.c)){const g=A.TmpVectors.Pk[0].H(k.position);h&&l(g),s.translation=g.yh()}const g=k.rotationQuaternion||A.Quaternion.FromEulerAngles(k.rotation.x,k.rotation.y,k.rotation.z);h&&f(g),this._babylonScene.useRightHandedSystem||e(g),g.equalsWithEpsilon(L,V.c)||(s.rotation=g.yh())}_listAvailableCameras(){for(const s of this._babylonScene.cameras){const k={type:s.mode===as.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(s.name&&(k.name=s.name),"perspective"===k.type)k.perspective={aspectRatio:s.getEngine().getAspectRatio(s),yfov:s.fovMode===as.d.FOVMODE_VERTICAL_FIXED?s.fov:s.fov*s.getEngine().getAspectRatio(s),znear:s.Jh,zfar:s.maxZ};else if("orthographic"===k.type){const h=s.orthoLeft&&s.orthoRight?.5*(s.orthoRight-s.orthoLeft):.5*s.getEngine().getRenderWidth(),A=s.orthoBottom&&s.orthoTop?.5*(s.orthoTop-s.orthoBottom):.5*s.getEngine().getRenderHeight();k.orthographic={xmag:h,ymag:A,znear:s.Jh,zfar:s.maxZ}}this._camerasMap.set(s,k)}}_exportAndAssignCameras(){const s=Array.from(this._camerasMap.values());for(const k of s){const s=this._nodesCameraMap.get(k);if(void 0!==s){this._cameras.push(k);for(const k of s)k.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const s of this._babylonScene.skeletons){if(s.bones.length<=0)continue;const k={joints:[]};this._skinMap.set(s,k)}}_exportAndAssignSkeletons(){for(const s of this._babylonScene.skeletons){if(s.bones.length<=0)continue;const k=this._skinMap.get(s);if(void 0==k)continue;const h={},A=[];let ms=-1;for(let g=0;g<s.bones.length;++g){const k=s.bones[g],A=k.getIndex()??g;-1!==A&&(h[A]=k,A>ms&&(ms=A))}for(let s=0;s<=ms;++s){const ms=h[s];A.push(ms.getAbsoluteInverseBindMatrix());const i=ms.getTransformNode();if(null!==i){const s=this._nodeMap.get(i);i&&null!==s&&void 0!==s?k.joints.push(s):g.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else g.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const i=this._nodesSkinMap.get(k);if(k.joints.length>0&&void 0!==i){const s=64*A.length,h=new Float32Array(s/4);A.forEach(((s,k)=>{h.set(s.m,16*k)}));const g=this._bufferManager.createBufferView(h);this._accessors.push(this._bufferManager.createAccessor(g,"MAT4",5126,A.length)),k.inverseBindMatrices=this._accessors.length-1,this._skins.push(k);for(const k of i)k.skin=this._skins.length-1}}}async _exportSceneAsync(){const s={nodes:[]};if(this._babylonScene.metadata){const k=this._options.metadataSelector(this._babylonScene.metadata);k&&(s.extras=k)}const k=new Array,h=new Array,A=new Array;for(const K of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&is(K,this._babylonScene.useRightHandedSystem)?A.push(...K.getChildren()):this._babylonScene.useRightHandedSystem?k.push(K):h.push(K);this._listAvailableCameras(),this._listAvailableSkeletons();const g=new Ls(!0,!1);s.nodes.push(...await this._exportNodesAsync(h,g));const ms=new Ls(!1,!1);s.nodes.push(...await this._exportNodesAsync(k,ms));const i=new Ls(!1,!0);s.nodes.push(...await this._exportNodesAsync(A,i)),s.nodes.length&&this._scenes.push(s),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&ws._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,g.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(s){let k=this._shouldExportNodeMap.get(s);return void 0===k&&(k=this._options.shouldExportNode(s),this._shouldExportNodeMap.set(s,k)),k}async _exportNodesAsync(s,k){const h=new Array;this._exportBuffers(s,k);for(const A of s)await this._exportNodeAsync(A,h,k);return h}_collectBuffers(s,k,h,A,g){if(this._shouldExportNode(s)&&s instanceof a.e&&s.mg){const ms=s.mg.getVertexBuffers();if(ms)for(const A in ms){if(!J(A))continue;const i=ms[A];g.setHasVertexColorAlpha(i,s.hasVertexAlpha);const K=i._buffer,H=k.get(K)||[];k.set(K,H),-1===H.indexOf(i)&&H.push(i);const O=h.get(i)||[];h.set(i,O),-1===O.indexOf(s)&&O.push(s)}const i=s.morphTargetManager;if(i)for(let k=0;k<i.numTargets;k++){const h=i.getTarget(k),g=A.get(h)||[];A.set(h,g),-1===g.indexOf(s)&&g.push(s)}}for(const ms of s.getChildren())this._collectBuffers(ms,k,h,A,g)}_exportBuffers(s,k){const h=new Map,A=new Map,g=new Map;for(const K of s)this._collectBuffers(K,h,A,g,k);const ms=Array.from(h.keys());for(const K of ms){const s=K.getData();if(!s)throw new Error("Buffer data is not available");const g=h.get(K);if(!g)continue;const ms=g[0].byteStride;if(g.some((s=>s.byteStride!==ms)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const i=hs(s).slice();for(const k of g){const s=A.get(k),{byteOffset:h,byteStride:g,componentCount:ms,type:K,count:H,normalized:O,kind:S}=y(k,s);switch(S){case c.e.NormalKind:case c.e.TangentKind:(0,U.h)(i,h,g,ms,K,H,O,(s=>{const k=Math.sqrt(s[0]*s[0]+s[1]*s[1]+s[2]*s[2]);if(k>0){const h=1/k;s[0]*=h,s[1]*=h,s[2]*=h}}));break;case c.e.ColorKind:{const k=s.filter((s=>s.material instanceof Es.wk||null==s.material)).length;if(0==k)break;if(k!=s.length){q.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}K==c.e.UNSIGNED_BYTE&&q.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const A=new j.Bk,S=new j.jg,a=this._babylonScene.getEngine().useExactSrgbConversions;(0,U.h)(i,h,g,ms,K,H,O,(s=>{3===s.length?(A.Nh(s,0),A.toLinearSpaceToRef(A,a),A.toArray(s,0)):(S.Nh(s,0),S.toLinearSpaceToRef(S,a),S.toArray(s,0))}))}}}if(k.convertToRightHanded){for(const s of g){const k=A.get(s),{byteOffset:h,byteStride:g,componentCount:ms,type:K,count:H,normalized:O,kind:S}=y(s,k);switch(S){case c.e.PositionKind:case c.e.NormalKind:case c.e.TangentKind:(0,U.h)(i,h,g,ms,K,H,O,(s=>{s[0]=-s[0]}))}}k.convertedToRightHandedBuffers.set(K,i)}const H=this._bufferManager.createBufferView(i,ms);k.setVertexBufferView(K,H);const O=new Map;for(const k of g){const s=A.get(k),{kind:h,totalVertices:g}=y(k,s);switch(h){case c.e.MatricesIndicesKind:case c.e.MatricesIndicesExtraKind:if(k.type==c.e.FLOAT){const s=k.getFloatData(g);null!==s&&O.set(k,s)}}}0!==O.size&&q.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const S=Array.from(O.keys());for(const h of S){const s=O.get(h);if(!s)continue;const A=s.some((s=>s>=256)),g=new(A?Uint16Array:Uint8Array)(s.length);for(let k=0;k<s.length;k++)g[k]=s[k];const ms=this._bufferManager.createBufferView(g,4*(A?2:1));k.setRemappedBufferView(K,h,ms)}}const i=Array.from(g.keys());for(const K of i){const s=g.get(K);if(!s)continue;const h=Bs(K,s[0],this._bufferManager,this._bufferViews,this._accessors,k.convertToRightHanded);for(const A of s)k.bindMorphDataToMesh(A,h)}}async _exportNodeAsync(s,k,h){let A=this._nodeMap.get(s);if(void 0!==A)return void(k.includes(A)||k.push(A));const g=await this._createNodeAsync(s,h);if(g){A=this._nodes.length,this._nodes.push(g),this._nodeMap.set(s,A),h.pushExportedNode(s),k.push(A);const ms={name:"runtime animations",channels:[],samplers:[]},i=[];this._babylonScene.animationGroups.length||(ws._CreateMorphTargetAnimationFromMorphTargetAnimations(s,ms,i,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation),s.animations.length&&ws._CreateNodeAnimationFromNodeAnimations(s,ms,i,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.convertToRightHanded,this._options.shouldExportAnimation)),ms.channels.length&&ms.samplers.length&&this._animations.push(ms),i.forEach((s=>{s.channels.length&&s.samplers.length&&this._animations.push(s)}))}const ms=g?[]:k;for(const i of s.getChildren())await this._exportNodeAsync(i,ms,h);g&&ms.length&&(g.children=ms)}async _createNodeAsync(s,k){if(!this._shouldExportNode(s))return null;const h={};if(s.name&&(h.name=s.name),s.metadata){const k=this._options.metadataSelector(s.metadata);k&&(h.extras=k)}if(s instanceof S.b&&(this._setNodeTransformation(h,s,k.convertToRightHanded),s instanceof a.e)){const g=s instanceof r.e?s.sourceMesh:s;if(g.Lh&&g.Lh.length>0&&(h.mesh=await this._exportMeshAsync(g,k)),s.skeleton){const k=this._skinMap.get(s.skeleton);var A;if(void 0!==k)void 0===this._nodesSkinMap.get(k)&&this._nodesSkinMap.set(k,[]),null===(A=this._nodesSkinMap.get(k))||void 0===A||A.push(h)}}if(s instanceof M.c){const A=this._camerasMap.get(s);if(A){var g;void 0===this._nodesCameraMap.get(A)&&this._nodesCameraMap.set(A,[]),this._setCameraTransformation(h,s,k.convertToRightHanded);const i=s.parent;if(null!==i&&ks(s,i)){const s=this._nodeMap.get(i);if(void 0!==s){var ms;const k=this._nodes[s];return ss(h,k),null===(ms=this._nodesCameraMap.get(A))||void 0===ms||ms.push(k),null}}null===(g=this._nodesCameraMap.get(A))||void 0===g||g.push(h)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",h,s,this._nodeMap,k.convertToRightHanded)?h:(q.c.Warn(`Not exporting node ${s.name}`),null)}_exportIndices(s,k,h,A,g,i,K,H,O){let c=s;O.mode=F(i);const S=K!==ms.b.CounterClockWiseSideOrientation,a=!H.wasAddedByNoopNode&&S,r=function(s){switch(s){case ms.b.TriangleFillMode:case ms.b.TriangleStripDrawMode:case ms.b.TriangleFanDrawMode:return!0}return!1}(i)&&a;if(r){if(i===ms.b.TriangleStripDrawMode||i===ms.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");O.mode=F(i);const K=k?new Uint32Array(A):new Uint16Array(A);if(s)for(let k=0;k+2<A;k+=3)K[k]=s[h+k]+g,K[k+1]=s[h+k+2]+g,K[k+2]=s[h+k+1]+g;else for(let s=0;s+2<A;s+=3)K[s]=s,K[s+1]=s+2,K[s+2]=s+1;c=K}else if(s&&0!==g){const ms=k?new Uint32Array(A):new Uint16Array(A);for(let k=0;k<A;k++)ms[k]=s[h+k]+g;c=ms}if(c){let ms=H.getIndicesAccessor(s,h,A,g,r);if(void 0===ms){const i=function(s,k,h,A){if(s instanceof Uint16Array||s instanceof Uint32Array)return s;if(s instanceof Int32Array)return new Uint32Array(s.buffer,s.byteOffset,s.length);const g=s.slice(k,k+h);return A?new Uint32Array(g):new Uint16Array(g)}(c,0,A,k),K=this._bufferManager.createBufferView(i),O=k?5125:5123;this._accessors.push(this._bufferManager.createAccessor(K,"SCALAR",O,A,0)),ms=this._accessors.length-1,H.setIndicesAccessor(s,h,A,g,r,ms)}O.indices=ms}}_exportVertexBuffer(s,k,h,A,g,ms){const i=s.getKind();if(!J(i))return;if(i.startsWith("uv")&&!this._options.exportUnusedUVs&&(!k||!this._materialNeedsUVsSet.has(k)))return;let K=g.getVertexAccessor(s,h,A);if(void 0===K){const k=g.convertedToRightHandedBuffers.get(s._buffer)||s._buffer.getData(),ms=i===c.e.PositionKind?function(s,k,h,A){const{byteOffset:g,byteStride:ms,type:i,normalized:K}=k,H=k.getSize(),O=new Array(H).fill(1/0),c=new Array(H).fill(-1/0);return(0,U.h)(s,g+h*ms,ms,H,i,A*H,K,(s=>{for(let k=0;k<H;k++)O[k]=Math.min(O[k],s[k]),c[k]=Math.max(c[k],s[k])})),{min:O,max:c}}(k,s,h,A):void 0,H=(i===c.e.MatricesIndicesKind||i===c.e.MatricesIndicesExtraKind)&&s.type===c.e.FLOAT,O=H?c.e.UNSIGNED_BYTE:s.type,S=H?void 0:s.normalized,a=H?g.getRemappedBufferView(s._buffer,s):g.getVertexBufferView(s._buffer),r=s.byteOffset+h*s.byteStride;this._accessors.push(this._bufferManager.createAccessor(a,function(s,k){if(s==c.e.ColorKind)return k?"VEC4":"VEC3";switch(s){case c.e.PositionKind:case c.e.NormalKind:return"VEC3";case c.e.TangentKind:case c.e.MatricesIndicesKind:case c.e.MatricesIndicesExtraKind:case c.e.MatricesWeightsKind:case c.e.MatricesWeightsExtraKind:return"VEC4";case c.e.UVKind:case c.e.UV2Kind:case c.e.UV3Kind:case c.e.UV4Kind:case c.e.UV5Kind:case c.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${s}`)}(i,g.hasVertexColorAlpha(s)),O,A,r,ms,S)),K=this._accessors.length-1,g.setVertexAccessor(s,h,A,K)}ms.attributes[function(s){switch(s){case c.e.PositionKind:return"POSITION";case c.e.NormalKind:return"NORMAL";case c.e.TangentKind:return"TANGENT";case c.e.ColorKind:return"COLOR_0";case c.e.UVKind:return"TEXCOORD_0";case c.e.UV2Kind:return"TEXCOORD_1";case c.e.UV3Kind:return"TEXCOORD_2";case c.e.UV4Kind:return"TEXCOORD_3";case c.e.UV5Kind:return"TEXCOORD_4";case c.e.UV6Kind:return"TEXCOORD_5";case c.e.MatricesIndicesKind:return"JOINTS_0";case c.e.MatricesIndicesExtraKind:return"JOINTS_1";case c.e.MatricesWeightsKind:return"WEIGHTS_0";case c.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${s}`)}(i)]=K}async _exportMaterialAsync(s,k,h,A){let g=this._materialMap.get(s);if(void 0===g){const A=k&&Object.keys(k).some((s=>s.startsWith("uv")));if((s=s instanceof rs.b?s.Pg[h.materialIndex]:s)instanceof ds.c)g=await this._materialExporter.exportPBRMaterialAsync(s,"image/png",A);else{if(!(s instanceof Es.wk))return void q.c.Warn(`Unsupported material '${s.name}' with type ${s.getClassName()}`);g=await this._materialExporter.exportStandardMaterialAsync(s,"image/png",A)}this._materialMap.set(s,g)}A.material=g}async _exportMeshAsync(s,k){var h;let A=k.getMesh(s);if(void 0!==A)return A;const g={primitives:[]};A=this._meshes.length,this._meshes.push(g),k.setMesh(s,A);const i=s.isUnIndexed?null:s.sg(),K=null===(h=s.mg)||void 0===h?void 0:h.getVertexBuffers(),H=k.getMorphTargetsFromMesh(s),O=s instanceof us.e,c=s instanceof Xs,S=s.Lh;if(K&&S&&S.length>0)for(const d of S){const h={attributes:{}},A=d.Ms()||this._babylonScene.defaultMaterial;if(c){var a,r;const k={name:A.name},g=s,ms=j.Bk.White(),i=(null===(a=g.material)||void 0===a?void 0:a.alpha)??1,K=(null===(r=g.greasedLineMaterial)||void 0===r?void 0:r.color)??ms;(!K.equalsWithEpsilon(ms,V.c)||i<1)&&(k.pbrMetallicRoughness={baseColorFactor:[...K.yh(),i]}),this._materials.push(k),h.material=this._materials.length-1}else if(O){const k={name:A.name},g=s;(!g.color.equalsWithEpsilon(j.Bk.White(),V.c)||g.alpha<1)&&(k.pbrMetallicRoughness={baseColorFactor:[...g.color.yh(),g.alpha]}),this._materials.push(k),h.material=this._materials.length-1}else await this._exportMaterialAsync(A,K,d,h);const S=O||c?ms.b.LineListDrawMode:s.overrideRenderingFillMode??A.fillMode,E=A._getEffectiveOrientation(s);this._exportIndices(i,i?(0,U.c)(i,d.indexCount,d.indexStart,d.verticesStart):d.verticesCount>65535,i?d.indexStart:d.verticesStart,i?d.indexCount:d.verticesCount,-d.verticesStart,S,E,k,h);for(const s of Object.values(K))this._exportVertexBuffer(s,A,d.verticesStart,d.verticesCount,k,h);if(H){h.targets=[];for(const s of H)h.targets.push(s.attributes)}g.primitives.push(h),this._extensionsPostExportMeshPrimitive(h)}if(H){g.weights=[],g.extras||(g.extras={}),g.extras.targetNames=[];for(const s of H)g.weights.push(s.influence),g.extras.targetNames.push(s.name)}return A}}Zs._ExtensionNames=new Array,Zs._ExtensionFactories={};class xs{static async GLTFAsync(s,k,h){h&&h.exportWithoutWaitingForScene||await s.whenReadyAsync();const A=new Zs(s,h),g=await A.generateGLTFAsync(k.replace(/\.[^/.]+$/,""));return A.dispose(),g}static async GLBAsync(s,k,h){h&&h.exportWithoutWaitingForScene||await s.whenReadyAsync();const A=new Zs(s,h),g=await A.generateGLBAsync(k.replace(/\.[^/.]+$/,""));return A.dispose(),g}}h(13170);const ys="EXT_mesh_gpu_instancing";class Ws{constructor(s){this.name=ys,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(s,k,h,g,ms,i){return await new Promise((s=>{if(k&&h instanceof Rs.e&&h.hasThinInstances&&this._exporter){this._wasUsed=!0;const s=A.Pk.Zero(),g=A.Quaternion.Identity(),K=A.Pk.One(),H=h.thinInstanceGetWorldMatrices(),O=A.TmpVectors.Pk[2],c=A.TmpVectors.Quaternion[1],S=A.TmpVectors.Pk[3];let a=!1,r=!1,d=!1;const E=new Float32Array(3*h.Gg),j=new Float32Array(4*h.Gg),P=new Float32Array(3*h.Gg);let R=0;for(const k of H)k.decompose(S,c,O),ms&&(l(O),f(c)),E.set(O.yh(),3*R),j.set(c.normalize().yh(),4*R),P.set(S.yh(),3*R),a=a||!O.equalsWithEpsilon(s),r=r||!c.equalsWithEpsilon(g),d=d||!S.equalsWithEpsilon(K),R++;const D={attributes:{}};a&&(D.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",h.Gg,i)),r&&(D.attributes.ROTATION=this._buildAccessor(j,"VEC4",h.Gg,i)),d&&(D.attributes.SCALE=this._buildAccessor(P,"VEC3",h.Gg,i)),k.extensions=k.extensions||{},k.extensions[ys]=D}s(k)}))}_buildAccessor(s,k,h,A){const g=A.createBufferView(s),ms=A.createAccessor(g,k,5126,h);return this._exporter._accessors.push(ms),this._exporter._accessors.length-1}}Zs.RegisterExtension(ys,(s=>new Ws(s)));var Js=h(13179),Fs=h(13186),os=h(13194),ls=h(13197);function fs(s){return s===os.d.PositionKind?"POSITION":s===os.d.NormalKind?"NORMAL":s===os.d.ColorKind?"COLOR":s.startsWith(os.d.UVKind)?"TEX_COORD":"GENERIC"}const es={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class sk extends Js.c{static get DefaultAvailable(){return(0,Js.h)(sk.DefaultConfiguration)}static get Default(){return sk._Default??(sk._Default=new sk),sk._Default}static ResetDefault(s){sk._Default&&(s||sk._Default.dispose(),sk._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(s,k){return{module:await(k||DracoEncoderModule)({wasmBinary:s})}}_getWorkerContent(){return`${Fs.k}(${Fs.m})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:sk.DefaultConfiguration)}async _encodeAsync(s,k,h){const A=h?(0,ls.c)(es,h):es;if(this._workerPoolPromise){const h=await this._workerPoolPromise;return await new Promise(((g,ms)=>{h.push(((h,i)=>{const K=s=>{h.removeEventListener("error",K),h.removeEventListener("message",H),ms(s),i()},H=s=>{"encodeMeshDone"===s.data.id&&(h.removeEventListener("error",K),h.removeEventListener("message",H),g(s.data.encodedMeshData),i())};h.addEventListener("error",K),h.addEventListener("message",H);const O=[];for(const k of s)O.push(k.data.buffer);k&&O.push(k.buffer),h.postMessage({id:"encodeMesh",attributes:s,indices:k,options:A},O)}))}))}if(this._modulePromise){const h=await this._modulePromise;return(0,Fs.k)(h.module,s,k,A)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(s,k){if(0==s.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");s instanceof Rs.e&&s.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===k||void 0===k?void 0:k.method)&&(q.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),k.method="MESH_SEQUENTIAL_ENCODING");const h=function(s){let k=s.sg(void 0,!0);return!k||k instanceof Uint32Array||k instanceof Uint16Array||(k=((0,U.c)(k,k.length)?Uint32Array:Uint16Array).from(k)),k}(s),A=function(s,k){const h=[];for(const A of s.getVerticesDataKinds()){if(null!==k&&void 0!==k&&k.includes(A)){if(A===os.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const g=s.getVertexBuffer(A),ms=g.getSize(),i=(0,U.p)(g.getData(),ms,g.type,g.byteOffset,g.byteStride,g.normalized,s.getTotalVertices(),!0);h.push({kind:A,dracoName:fs(A),size:ms,data:i})}return h}(s,null===k||void 0===k?void 0:k.excludedAttributes);return await this._encodeAsync(A,h,k)}}sk.DefaultConfiguration={wasmUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${g.Tools._DefaultCdnUrl}/draco_encoder.js`},sk._Default=null;const kk="KHR_draco_mesh_compression";class hk{get wasUsed(){return this._wasUsed}constructor(s){this.name=kk,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===s.options.meshCompressionMethod&&sk.DefaultAvailable}dispose(){}postExportMeshPrimitive(s,k,h){if(!this.enabled)return;if(4!==s.mode&&5!==s.mode)return void q.c.Warn("Cannot compress primitive with mode "+s.mode+".");const A=[],g=[];let ms=null;if(void 0!==s.indices){const i=h[s.indices],K=k.getBufferView(i);ms=k.getData(K).slice(),A.push(K),g.push(i)}const i=[];for(const[c,S]of Object.entries(s.attributes)){const s=h[S],ms=k.getBufferView(s),H=W(s.type),O=(0,U.p)(k.getData(ms),H,s.componentType,s.byteOffset||0,ms.byteStride||(0,U.m)(s.componentType)*H,s.normalized||!1,s.count,!0);i.push({kind:c,dracoName:(K=c,"POSITION"===K?"POSITION":"NORMAL"===K?"NORMAL":K.startsWith("COLOR")?"COLOR":K.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:W(s.type),data:O}),A.push(ms),g.push(s)}var K;const H={method:s.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},O=sk.Default._encodeAsync(i,ms,H).then((h=>{if(!h)return void q.c.Error("Draco encoding failed for primitive.");const ms={bufferView:-1,attributes:h.attributeIds},i=k.createBufferView(h.data);k.setBufferView(ms,i);for(const s of A)this._bufferViewsUsed.add(s);for(const s of g)this._accessorsUsed.add(s);s.extensions||(s.extensions={}),s.extensions[kk]=ms})).catch((s=>{q.c.Error("Draco encoding failed for primitive: "+s)}));this._encodePromises.push(O),this._wasUsed=!0}async preGenerateBinaryAsync(s){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((k=>{s.getPropertiesWithBufferView(k).every((s=>this._accessorsUsed.has(s)))&&s.removeBufferView(k)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Zs.RegisterExtension(kk,(s=>new hk(s)));var Ak=h(13199);const gk="KHR_lights_punctual",mh={name:"",color:[1,1,1],Ng:1,range:Number.MAX_VALUE},ik={innerConeAngle:0,outerConeAngle:Math.PI/4},Kk=A.Pk.Backward();class Hk{constructor(s){this.name=gk,this.enabled=!0,this.required=!1,this._exporter=s}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[gk]=this._lights}async postExportNodeAsync(s,k,h,g,ms){return await new Promise((i=>{if(!(h instanceof Ds.e))return void i(k);const K=h.getTypeID()==Ds.e.LIGHTTYPEID_POINTLIGHT?"point":h.getTypeID()==Ds.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":h.getTypeID()==Ds.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!K||!(h instanceof Ak.c))return q.c.Warn(`${s}: Light ${h.name} is not supported in ${gk}`),void i(k);if(h.falloffType!==Ds.e.FALLOFF_GLTF&&q.c.Warn(`${s}: Light falloff for ${h.name} does not match the ${gk} specification!`),!h.position.equalsToFloats(0,0,0)){const s=A.TmpVectors.Pk[0].H(h.position);ms&&l(s),k.translation=s.yh()}if("point"!==K){const s=h.direction.normalizeToRef(A.TmpVectors.Pk[0]);ms&&l(s);const g=A.Quaternion.FromUnitVectorsToRef(Kk,s,A.TmpVectors.Quaternion[0]);A.Quaternion.IsIdentity(g)||(k.rotation=g.yh())}const H={type:K,name:h.name,color:h.zg.yh(),Ng:h.Ng,range:h.range};if(As(H,mh),"spot"===K){const s=h;H.spot={innerConeAngle:s.innerAngle/2,outerConeAngle:s.angle/2},As(H.spot,ik)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(H);const O={Sh:this._lights.lights.length-1},c=h.parent;if(c&&ks(h,c)){const s=g.get(c);if(s){const h=this._exporter._nodes[s];return ss(k,h),h.extensions||(h.extensions={}),h.extensions[gk]=O,void i(null)}}k.extensions||(k.extensions={}),k.extensions[gk]=O,i(k)}))}}Zs.RegisterExtension(gk,(s=>new Hk(s)));var Ok=h(13106);const ck="KHR_materials_anisotropy";class Sk{constructor(s){this.name=ck,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof Ok.e&&h.anisotropy.isEnabled&&!h.anisotropy.legacy?(h.anisotropy.texture&&A.push(h.anisotropy.texture),A):[]}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof Ok.e){if(!h.anisotropy.isEnabled||h.anisotropy.legacy)return void s(k);this._wasUsed=!0,k.extensions=k.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(h.anisotropy.texture),g={anisotropyStrength:h.anisotropy.Ng,anisotropyRotation:h.anisotropy.angle,anisotropyTexture:A??void 0};null!==g.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(h),k.extensions[ck]=g}s(k)}))}}Zs.RegisterExtension(ck,(s=>new Sk(s)));const ak="KHR_materials_clearcoat";class rk{constructor(s){this.name=ak,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof Ok.e&&h.clearCoat.isEnabled?(h.clearCoat.texture&&A.push(h.clearCoat.texture),!h.clearCoat.useRoughnessFromMainTexture&&h.clearCoat.textureRoughness&&A.push(h.clearCoat.textureRoughness),h.clearCoat.bumpTexture&&A.push(h.clearCoat.bumpTexture),A):[]}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof Ok.e){if(!h.clearCoat.isEnabled)return void s(k);this._wasUsed=!0,k.extensions=k.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture);let ms;ms=h.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(h.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(h.clearCoat.textureRoughness),h.clearCoat.isTintEnabled&&g.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${h.name}`),h.clearCoat.remapF0OnInterfaceChange&&g.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${h.name}`);const i=this._exporter._materialExporter.getTextureInfo(h.clearCoat.bumpTexture),K={clearcoatFactor:h.clearCoat.Ng,clearcoatTexture:A??void 0,clearcoatRoughnessFactor:h.clearCoat.roughness,clearcoatRoughnessTexture:ms??void 0,clearcoatNormalTexture:i??void 0};null===K.clearcoatTexture&&null===K.clearcoatRoughnessTexture&&null===K.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),k.extensions[ak]=K}s(k)}))}}Zs.RegisterExtension(ak,(s=>new rk(s)));const dk="KHR_materials_diffuse_transmission";function Ek(s,k){const h=k.subSurface;let A=null;return h.translucencyIntensityTexture?A=h.translucencyIntensityTexture:h.thicknessTexture&&h.useMaskFromThicknessTexture&&(A=h.thicknessTexture),A&&!h.useGltfStyleTextures?(q.c.Warn(`${s}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${k.name}`,1),null):A}class jk{constructor(s){this.name=dk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];if(h instanceof ds.c&&this._isExtensionEnabled(h)){const k=Ek(s,h);return k&&A.push(k),h.subSurface.translucencyColorTexture&&A.push(h.subSurface.translucencyColorTexture),A}return A}_isExtensionEnabled(s){if(s.unlit)return!1;const k=s.subSurface;return!!k.isTranslucencyEnabled&&(!s.unlit&&!k.useAlbedoToTintTranslucency&&k.useGltfStyleTextures&&1===k.volumeIndexOfRefraction&&0===k.minimumThickness&&0===k.maximumThickness)}postExportMaterialAsync(s,k,h){return new Promise((A=>{if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const A=h.subSurface,g=Ek(s,h),ms=0==A.translucencyIntensity?void 0:A.translucencyIntensity,i=this._exporter._materialExporter.getTextureInfo(g)??void 0,K=!A.translucencyColor||A.translucencyColor.equalsFloats(1,1,1)?void 0:A.translucencyColor.yh(),H=this._exporter._materialExporter.getTextureInfo(A.translucencyColorTexture)??void 0,O={diffuseTransmissionFactor:ms,diffuseTransmissionTexture:i,diffuseTransmissionColorFactor:K,diffuseTransmissionColorTexture:H};(i||H)&&this._exporter._materialNeedsUVsSet.add(h),k.extensions=k.extensions||{},k.extensions[dk]=O}A(k)}))}}Zs.RegisterExtension(dk,(s=>new jk(s)));const Pk="KHR_materials_dispersion";class Rk{constructor(){this.name=Pk,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(s){if(s.unlit)return!1;const k=s.subSurface;return!(!k.isRefractionEnabled&&!k.isDispersionEnabled)}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const s={dispersion:h.subSurface.dispersion};k.extensions=k.extensions||{},k.extensions[Pk]=s}s(k)}))}}Zs.RegisterExtension(Pk,(()=>new Rk));const Dk="KHR_materials_emissive_strength";class wk{constructor(){this.name=Dk,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(s,k,h){return await new Promise((s=>{if(!(h instanceof ds.c))return s(k);const A=h.emissiveColor.yh(),g=Math.max(...A);if(g>1){this._wasUsed=!0,k.extensions||(k.extensions={});const s={emissiveStrength:g},A=h.emissiveColor.scale(1/s.emissiveStrength);k.emissiveFactor=A.yh(),k.extensions[Dk]=s}return s(k)}))}}Zs.RegisterExtension(Dk,(s=>new wk));const Bk="KHR_materials_ior";class uk{constructor(){this.name=Bk,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(s){return!s.unlit&&(void 0!=s.indexOfRefraction&&1.5!=s.indexOfRefraction)}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const s={ior:h.indexOfRefraction};k.extensions=k.extensions||{},k.extensions[Bk]=s}s(k)}))}}Zs.RegisterExtension(Bk,(s=>new uk));const Gk="KHR_materials_iridescence";class Qk{constructor(s){this.name=Gk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof Ok.e&&h.iridescence.isEnabled?(h.iridescence.texture&&A.push(h.iridescence.texture),h.iridescence.thicknessTexture&&h.iridescence.thicknessTexture!==h.iridescence.texture&&A.push(h.iridescence.thicknessTexture),A):[]}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof Ok.e){if(!h.iridescence.isEnabled)return void s(k);this._wasUsed=!0,k.extensions=k.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(h.iridescence.texture),g=this._exporter._materialExporter.getTextureInfo(h.iridescence.thicknessTexture),ms={iridescenceFactor:h.iridescence.Ng,iridescenceIor:h.iridescence.indexOfRefraction,iridescenceThicknessMinimum:h.iridescence.minimumThickness,iridescenceThicknessMaximum:h.iridescence.maximumThickness,iridescenceTexture:A??void 0,iridescenceThicknessTexture:g??void 0};null===ms.iridescenceTexture&&null===ms.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(h),k.extensions[Gk]=ms}s(k)}))}}Zs.RegisterExtension(Gk,(s=>new Qk(s)));const pk="KHR_materials_sheen";class Ik{constructor(s){this.name=pk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){return h instanceof ds.c&&h.sheen.isEnabled&&h.sheen.texture?[h.sheen.texture]:[]}async postExportMaterialAsync(s,k,h){return await new Promise((s=>{if(h instanceof ds.c){if(!h.sheen.isEnabled)return void s(k);this._wasUsed=!0,null==k.extensions&&(k.extensions={});const A={sheenColorFactor:h.sheen.color.yh(),sheenRoughnessFactor:h.sheen.roughness??0};null===A.sheenColorTexture&&null===A.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(h),h.sheen.texture&&(A.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),h.sheen.textureRoughness&&!h.sheen.useRoughnessFromMainTexture?A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.textureRoughness)??void 0:h.sheen.texture&&h.sheen.useRoughnessFromMainTexture&&(A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(h.sheen.texture)??void 0),k.extensions[pk]=A}s(k)}))}}Zs.RegisterExtension(pk,(s=>new Ik(s)));const Nk="KHR_materials_specular";class bk{constructor(s){this.name=Nk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof ds.c&&this._isExtensionEnabled(h)?(h.metallicReflectanceTexture&&A.push(h.metallicReflectanceTexture),h.reflectanceTexture&&A.push(h.reflectanceTexture),A):A}_isExtensionEnabled(s){return!s.unlit&&(void 0!=s.metallicF0Factor&&1!=s.metallicF0Factor||void 0!=s.metallicReflectanceColor&&!s.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(s))}_hasTexturesExtension(s){return null!=s.metallicReflectanceTexture||null!=s.reflectanceTexture}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0,k.extensions=k.extensions||{};const s=this._exporter._materialExporter.getTextureInfo(h.metallicReflectanceTexture)??void 0,A=this._exporter._materialExporter.getTextureInfo(h.reflectanceTexture)??void 0,g={specularFactor:1==h.metallicF0Factor?void 0:h.metallicF0Factor,specularTexture:s,specularColorFactor:h.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:h.metallicReflectanceColor.yh(),specularColorTexture:A};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),k.extensions[Nk]=g}s(k)}))}}Zs.RegisterExtension(Nk,(s=>new bk(s)));const tk="KHR_materials_transmission";class zk{constructor(s){this.name=tk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof ds.c&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&A.push(h.subSurface.thicknessTexture),A):A}_isExtensionEnabled(s){if(s.unlit)return!1;const k=s.subSurface;return k.isRefractionEnabled&&void 0!=k.refractionIntensity&&0!=k.refractionIntensity||this._hasTexturesExtension(s)}_hasTexturesExtension(s){return null!=s.subSurface.refractionIntensityTexture}async postExportMaterialAsync(s,k,h){if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const A=h.subSurface,g={transmissionFactor:0===A.refractionIntensity?void 0:A.refractionIntensity};if(this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),A.refractionIntensityTexture)if(A.useGltfStyleTextures){const s=await this._exporter._materialExporter.exportTextureAsync(A.refractionIntensityTexture,"image/png");s&&(g.transmissionTexture=s)}else q.c.Warn(`${s}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);k.extensions||(k.extensions={}),k.extensions[tk]=g}return k}}Zs.RegisterExtension(tk,(s=>new zk(s)));const Ck="KHR_materials_unlit";class vk{constructor(){this.name=Ck,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(s,k,h){return new Promise((s=>{let A=!1;h instanceof ds.c?A=h.unlit:h instanceof Es.wk&&(A=h.disableLighting),A&&(this._wasUsed=!0,null==k.extensions&&(k.extensions={}),k.extensions[Ck]={}),s(k)}))}}Zs.RegisterExtension(Ck,(()=>new vk));const Yk="KHR_materials_volume";class nk{constructor(s){this.name=Yk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof ds.c&&this._isExtensionEnabled(h)?(h.subSurface.thicknessTexture&&A.push(h.subSurface.thicknessTexture),A):A}_isExtensionEnabled(s){if(s.unlit)return!1;const k=s.subSurface;return!(!k.isRefractionEnabled&&!k.isTranslucencyEnabled)&&(void 0!=k.maximumThickness&&0!=k.maximumThickness||void 0!=k.tintColorAtDistance&&k.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=k.tintColor&&k.tintColor!=j.Bk.White()||this._hasTexturesExtension(s))}_hasTexturesExtension(s){return null!=s.subSurface.thicknessTexture}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof ds.c&&this._isExtensionEnabled(h)){this._wasUsed=!0;const s=h.subSurface,A={thicknessFactor:0==s.maximumThickness?void 0:s.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(s.thicknessTexture)??void 0,attenuationDistance:s.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:s.tintColorAtDistance,attenuationColor:s.tintColor.equalsFloats(1,1,1)?void 0:s.tintColor.yh()};this._hasTexturesExtension(h)&&this._exporter._materialNeedsUVsSet.add(h),k.extensions=k.extensions||{},k.extensions[Yk]=A}s(k)}))}}Zs.RegisterExtension(Yk,(s=>new nk(s)));const Tk="EXT_materials_diffuse_roughness";class Uk{constructor(s){this.name=Tk,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=s}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(s,k,h){const A=[];return h instanceof Ok.e&&h._baseDiffuseRoughness?(h._baseDiffuseRoughnessTexture&&A.push(h._baseDiffuseRoughnessTexture),A):[]}postExportMaterialAsync(s,k,h){return new Promise((s=>{if(h instanceof Ok.e){if(!h._baseDiffuseRoughness)return void s(k);this._wasUsed=!0,k.extensions=k.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(h._baseDiffuseRoughnessTexture),g={diffuseRoughnessFactor:h._baseDiffuseRoughness,diffuseRoughnessTexture:A??void 0};null!==g.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(h),k.extensions[Tk]=g}s(k)}))}}Zs.RegisterExtension(Tk,(s=>new Uk(s)));const qk="KHR_texture_transform";class Mk{constructor(){this.name=qk,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(s,k,h){if(h.Is()||g.Tools.Warn(`${s}: /*@__KEY__*/"scene" is not defined for Babylon texture ${h.name}!`),(0!==h.uAng||0!==h.vAng)&&(g.Tools.Warn(`${s}: Texture ${h.name} with rotation in the u or v axis is not supported in glTF.`),0!==h.uRotationCenter||0!==h.vRotationCenter))return;const A={};let ms=!1;if(0===h.uOffset&&0===h.vOffset||(A.offset=[h.uOffset,h.vOffset],ms=!0),1===h.uScale&&1===h.vScale||(A.scale=[h.uScale,h.vScale],ms=!0),0!==h.wAng){if(0!==h.uRotationCenter||0!==h.vRotationCenter){if(h.homogeneousRotationInUVTransform&&h.uScale!==h.vScale)return void g.Tools.Warn(`${s}: Texture ${h.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${qk}.`);g.Tools.Warn(`${s}: Texture ${h.name} with non-origin rotation center will be exported using an adjusted offset with ${qk}.`),A.offset=function(s){const{uOffset:k,vOffset:h,uRotationCenter:A,vRotationCenter:g,uScale:ms,vScale:i,wAng:K}=s,H=Math.cos(K),O=Math.sin(K),c=A*ms,S=g*i;return[k+(c*(1-H)+S*O),h+(S*(1-H)-c*O)]}(h)}A.rotation=-h.wAng,ms=!0}0!==h.coordinatesIndex&&(A.texCoord=h.coordinatesIndex,ms=!0),ms&&(this._wasUsed=!0,k.extensions||(k.extensions={}),k.extensions[qk]=A)}}Zs.RegisterExtension(qk,(()=>new Mk));class Vk{static CreateSTL(s){let k=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",g=arguments.length>3&&void 0!==arguments[3]&&arguments[3],ms=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],i=arguments.length>5&&void 0!==arguments[5]&&arguments[5],K=arguments.length>6&&void 0!==arguments[6]&&arguments[6],H=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const O=function(s,k,h){const g=[3*s[h],3*s[h+1],3*s[h+2]],ms=[new A.Pk(k[g[0]],k[g[0]+2],k[g[0]+1]),new A.Pk(k[g[1]],k[g[1]+2],k[g[1]+1]),new A.Pk(k[g[2]],k[g[2]+2],k[g[2]+1])],i=ms[0].Rk(ms[1]),K=ms[2].Rk(ms[1]);return{v:ms,n:A.Pk.Cross(K,i).normalize()}},S=function(s,k,h,A){return k=a(s,k,h.x,A),k=a(s,k,h.y,A),a(s,k,h.z,A)},a=function(s,k,h,A){return s.setFloat32(k,h,A),k+4},d=function(s){if(K){let k=s;s instanceof r.e&&(k=s.sourceMesh);const h=k.getVerticesData(c.e.PositionKind,!0,!0);if(!h)return[];const g=A.Pk.Zero();let ms;for(ms=0;ms<h.length;ms+=3)A.Pk.TransformCoordinatesFromFloatsToRef(h[ms],h[ms+1],h[ms+2],s.fh(!0),g).toArray(h,ms);return h}return s.getVerticesData(c.e.PositionKind)||[]};K&&(i=!0);let E="",j=0,P=0;if(g){for(let h=0;h<s.length;h++){const k=s[h].sg();j+=k?k.length/3:0}const k=new ArrayBuffer(84+50*j);E=new DataView(k),P+=80,E.setUint32(P,j,ms),P+=4}else H||(E="solid stlmesh\r\n");for(let A=0;A<s.length;A++){const k=s[A];!g&&H&&(E+="solid "+k.name+"\r\n"),!i&&k instanceof Rs.e&&k.bakeCurrentTransformIntoVertices();const h=d(k),K=k.sg()||[];for(let s=0;s<K.length;s+=3){const k=O(K,h,s);g?(P=S(E,P,k.n,ms),P=S(E,P,k.v[0],ms),P=S(E,P,k.v[1],ms),P=S(E,P,k.v[2],ms),P+=2):(E+="\tfacet normal "+k.n.x+" "+k.n.y+" "+k.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+k.v[0].x+" "+k.v[0].y+" "+k.v[0].z+"\r\n",E+="\t\t\tvertex "+k.v[1].x+" "+k.v[1].y+" "+k.v[1].z+"\r\n",E+="\t\t\tvertex "+k.v[2].x+" "+k.v[2].y+" "+k.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!g&&H&&(E+="endsolid "+name+"\r\n")}if(g||H||(E+="endsolid stlmesh"),k){const s=document.createElement("a"),k=new Blob([E],{type:"application/octet-stream"});s.href=window.URL.createObjectURL(k),s.download=h+".stl",s.click()}return E}}function Xk(s,k){let h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const A=[];for(let g=0;g<s.length/h;g++){const ms=s[g*h],i=s[g*h+1],K=s[g*h+2];A.push(`(${ms.toPrecision(k.precision)}, ${i.toPrecision(k.precision)}, ${K.toPrecision(k.precision)})`)}return A.join(", ")}function Lk(s,k){const h=[];for(let A=0;A<s.length/2;A++){const g=s[2*A],ms=s[2*A+1];h.push(`(${g.toPrecision(k.precision)}, ${(1-ms).toPrecision(k.precision)})`)}return h.join(", ")}function Zk(s,k){const h=s.getVerticesData(c.e.PositionKind),A=s.getVerticesData(c.e.NormalKind);if(h&&A)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(s){var k;const h=null!==(k=s.sg())&&void 0!==k&&k.length?s.getTotalIndices():s.getTotalVertices();return Array(h/3).fill(3).join(", ")}(s)}]\n\t\tint[] faceVertexIndices = [${function(s){const k=s.sg(),h=[];if(null!==k)for(let A=0;A<k.length;A++)h.push(k[A]);else{const k=s.getTotalVertices();for(let s=0;s<k;s++)h.push(s)}return h.join(", ")}(s)}]\n\t\tnormal3f[] normals = [${Xk(A,k)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Xk(h,k)}]\n        ${function(s,k){let h="";for(let g=0;g<4;g++){const A=g>0?g:"",ms=s.getVerticesData(c.e.UVKind+(A?A+1:""));ms&&(h+=`\n\t\ttexCoord2f[] primvars:st${A} = [${Lk(ms,k)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const A=s.getVerticesData(c.e.ColorKind);return A&&(h+=`\n\tcolor3f[] primvars:displayColor = [${Xk(A,k,A.length/s.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),h}(s,k)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function xk(s,k){return`\n        def "Geometry"\n        {\n        ${Zk(s,k)}\n        }\n        `}function yk(s){let k='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return k+=s,fflate.strToU8(k)}function Wk(s){const k=s.m;return`( ${Jk(k,0)}, ${Jk(k,4)}, ${Jk(k,8)}, ${Jk(k,12)} )`}function Jk(s,k){return`(${s[k+0]}, ${s[k+1]}, ${s[k+2]}, ${s[k+3]})`}function Fk(s){const k="Object_"+s.uniqueId,h=function(s){const k=s.getWorldMatrix().clone(),h=s.Is().useRightHandedSystem;if(!h){let A=s.parent;for(;A;){if(is(A,h)){k.multiplyToRef(A.getWorldMatrix().invert(),k);break}A=A.parent}}return k.determinant()<0&&g.Tools.Warn(`Exporting mesh ${s.name} with negative scale. Result may look incorrect in destination engine.`),k}(s),A=Wk(h);return`def Xform "${k}" (\n\tprepend references = @./geometries/Geometry_${s.mg.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${A}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${s.material.uniqueId}>\n}\n\n`}function ok(s){switch(s){case G.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case G.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case G.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function lk(s){return`(${s.x}, ${s.y})`}function fk(s){return`(${s.r}, ${s.g}, ${s.b})`}function ek(s,k,h,g,ms,i){const K=s.getInternalTexture().uniqueId+"_"+s.invertY;ms[K]=s;const H=s.coordinatesIndex>0?"st"+s.coordinatesIndex:"st",O=new A.Vector2(s.uScale,s.vScale),c=new A.Vector2(s.uOffset,s.vOffset),S=s.wAng,a=Math.sin(S),r=Math.cos(S);return c.y=1-c.y-O.y,c.x+=a*O.x,c.y+=(1-r)*O.y,`\n    def Shader "PrimvarReader_${h}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${H}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${h}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${k.uniqueId}/PrimvarReader_${h}.outputs:result>\n        float inputs:rotation = ${(S*(180/Math.PI)).toFixed(i.precision)}\n        float2 inputs:scale = ${lk(O)}\n        float2 inputs:translation = ${lk(c)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${s.uniqueId}_${h}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${K}.png@\n        float2 inputs:st.connect = </Materials/Material_${k.uniqueId}/Transform2d_${h}.outputs:result>\n        ${g?"float4 inputs:scale = "+function(s){return`(${s.r}, ${s.g}, ${s.b}, 1.0)`}(g):""}\n        token inputs:sourceColorSpace = "${s.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${ok(s.wrapU)}"\n        token inputs:wrapT = "${ok(s.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${k.needAlphaBlending()?"float outputs:a":""}\n    }`}function sh(s,k,h){const A="\t\t\t",g=[],ms=[],{diffuseMap:i,zg:K,alphaCutOff:H,emissiveMap:O,emissive:c,normalMap:S,roughnessMap:a,roughnessChannel:r,roughness:d,metalnessMap:E,metalnessChannel:P,metalness:R,aoMap:D,aoMapChannel:w,aoMapIntensity:B,alphaMap:u,ior:G,clearCoatEnabled:Q,clearCoat:p,clearCoatMap:I,clearCoatRoughness:N,clearCoatRoughnessMap:b}=function(s){const k={diffuseMap:null,zg:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return s instanceof Es.wk?{...k,diffuseMap:s.diffuseTexture,zg:s.diffuseColor,alphaCutOff:s.alphaCutOff,emissiveMap:s.emissiveTexture,emissive:s.emissiveColor,roughness:1,alphaMap:s.opacityTexture}:s instanceof Ok.e?{...k,diffuseMap:s._albedoTexture,zg:s._albedoColor,alphaCutOff:s._alphaCutOff,emissiveMap:s._emissiveTexture,emissive:s._emissiveColor,normalMap:s._bumpTexture,roughnessMap:s._metallicTexture,roughnessChannel:s._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:s._roughness??1,metalnessMap:s._metallicTexture,metalnessChannel:s._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:s._metallic??0,aoMap:s._ambientTexture,aoMapChannel:s._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:s._ambientTextureStrength,alphaMap:s._opacityTexture,ior:s.subSurface.indexOfRefraction,clearCoatEnabled:s.clearCoat.isEnabled,clearCoat:s.clearCoat.Ng,clearCoatMap:s.clearCoat.texture,clearCoatRoughness:s.clearCoat.roughness,clearCoatRoughnessMap:s.clearCoat.useRoughnessFromMainTexture?s.clearCoat.texture:s.clearCoat.textureRoughness}:k}(s);return null!==i?(g.push(`${A}color3f inputs:diffuseColor.connect = </Materials/Material_${s.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:rgb>`),s.needAlphaBlending()?g.push(`${A}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:a>`):s.needAlphaTesting()&&(g.push(`${A}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${i.uniqueId}_diffuse.outputs:a>`),g.push(`${A}float inputs:opacityThreshold = ${H}`)),ms.push(ek(i,s,"diffuse",K,k,h))):g.push(`${A}color3f inputs:diffuseColor = ${fk(K||j.Bk.White())}`),null!==O?(g.push(`${A}color3f inputs:emissiveColor.connect = </Materials/Material_${s.uniqueId}/Texture_${O.uniqueId}_emissive.outputs:rgb>`),ms.push(ek(O,s,"emissive",c,k,h))):c&&c.toLuminance()>0&&g.push(`${A}color3f inputs:emissiveColor = ${fk(c)}`),null!==S&&(g.push(`${A}normal3f inputs:normal.connect = </Materials/Material_${s.uniqueId}/Texture_${S.uniqueId}_normal.outputs:rgb>`),ms.push(ek(S,s,"normal",null,k,h))),null!==D&&(g.push(`${A}float inputs:occlusion.connect = </Materials/Material_${s.uniqueId}/Texture_${D.uniqueId}_occlusion.outputs:${w}>`),ms.push(ek(D,s,"occlusion",new j.Bk(B,B,B),k,h))),null!==a?(g.push(`${A}float inputs:roughness.connect = </Materials/Material_${s.uniqueId}/Texture_${a.uniqueId}_roughness.outputs:${r}>`),ms.push(ek(a,s,"roughness",new j.Bk(d,d,d),k,h))):g.push(`${A}float inputs:roughness = ${d}`),null!==E?(g.push(`${A}float inputs:metallic.connect = </Materials/Material_${s.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${P}>`),ms.push(ek(E,s,"metallic",new j.Bk(R,R,R),k,h))):g.push(`${A}float inputs:metallic = ${R}`),null!==u?(g.push(`${A}float inputs:opacity.connect = </Materials/Material_${s.uniqueId}/Texture_${u.uniqueId}_opacity.outputs:r>`),g.push(`${A}float inputs:opacityThreshold = 0.0001`),ms.push(ek(u,s,"opacity",null,k,h))):g.push(`${A}float inputs:opacity = ${s.alpha}`),Q&&(null!==I?(g.push(`${A}float inputs:clearcoat.connect = </Materials/Material_${s.uniqueId}/Texture_${I.uniqueId}_clearcoat.outputs:r>`),ms.push(ek(I,s,"clearcoat",new j.Bk(p,p,p),k,h))):g.push(`${A}float inputs:clearcoat = ${p}`),null!==b?(g.push(`${A}float inputs:clearcoatRoughness.connect = </Materials/Material_${s.uniqueId}/Texture_${b.uniqueId}_clearcoatRoughness.outputs:g>`),ms.push(ek(b,s,"clearcoatRoughness",new j.Bk(N,N,N),k,h))):g.push(`${A}float inputs:clearcoatRoughness = ${N}`)),g.push(`${A}float inputs:ior = ${G}`),`\n\tdef Material "Material_${s.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${g.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${s.uniqueId}/PreviewSurface.outputs:surface>\n\n${ms.join("\n")}\n\n\t}\n`}async function kh(s,k,h){const ms={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...k};"undefined"===typeof fflate&&await g.Tools.LoadScriptAsync(ms.fflateUrl);const i={};i[ms.modelFileName]=null;let K='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';K+=function(s){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===s.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${s.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${s.planeAnchoringAlignment}"`:""}\n            `}(ms);const H={};for(const A of s.meshes){if(0===A.getTotalVertices())continue;const s=A,k=s.mg,O=s.material;if(!O||!k||h&&!h(s))continue;if(-1!==["wk","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(O.getClassName())){const h="geometries/Geometry_"+k.uniqueId+".usda";if(!(h in i)){const s=xk(k,ms);i[h]=yk(s)}O.uniqueId in H||(H[O.uniqueId]=O),K+=Fk(s)}else g.Tools.Warn("USDZExportAsync does not support this material type: "+O.getClassName())}s.activeCamera&&ms.exportCamera&&(K+=function(s,k){const h="Camera_"+s.uniqueId,g=Wk(A.Matrix.RotationY(Math.PI).multiply(s.getWorldMatrix()));if(s.mode===G.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${s.Jh.toPrecision(k.precision)}, ${s.maxZ.toPrecision(k.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(s.orthoLeft||1)+Math.abs(s.orthoRight||1))).toPrecision(k.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(s.orthoTop||1)+Math.abs(s.orthoBottom||1))).toPrecision(k.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const A=s.getEngine().getAspectRatio(s),ms=k.cameraSensorWidth||35;return`def Camera "${h}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${g}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${s.Jh.toPrecision(k.precision)}, ${s.maxZ.toPrecision(k.precision)})\n\t\t\tfloat focalLength = ${(ms/(2*Math.tan(.5*s.fov))).toPrecision(k.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(ms*A).toPrecision(k.precision)}\n\t\t\tfloat verticalAperture = ${(ms/A).toPrecision(k.precision)}            \n\t\t}\n\t\n\t`}}(s.activeCamera,ms)),K+="\n            }\n        }\n    }";const O={};K+=function(s,k,h){const A=[];for(const g in s){const ms=s[g];A.push(sh(ms,k,h))}return`\n    def "Materials"\n{\n${A.join("")}\n}\n\n`}(H,O,ms),i[ms.modelFileName]=fflate.strToU8(K);for(const A in O){const s=O[A],k=s.getSize(),h=await s.readPixels();if(!h)throw new Error("Texture data is not available");const g=await Q.DumpTools.DumpDataAsync(k.width,k.height,h,"image/png",void 0,!1,!0);i[`textures/Texture_${A}.png`]=new Uint8Array(g).slice()}let c=0;for(const A in i){const s=i[A];if(!s)continue;c+=34+A.length;const k=63&c;if(4!==k){const h=new Uint8Array(64-k);i[A]=[s,{extra:{12345:h}}]}c=s.length}return fflate.zipSync(i,{level:0})}}}]);