"use strict";(self.irtrrknfyfo=self.irtrrknfyfo||[]).push([[26],{11800:(B,E,v)=>{v.r(E),v.d(E,{EXT_materials_diffuse_roughness:()=>jE,EXT_mesh_gpu_instancing:()=>JB,GLTF2Export:()=>UB,GLTFData:()=>D,KHR_draco_mesh_compression:()=>vE,KHR_lights_punctual:()=>xE,KHR_materials_anisotropy:()=>yE,KHR_materials_clearcoat:()=>PE,KHR_materials_diffuse_transmission:()=>aE,KHR_materials_dispersion:()=>gE,KHR_materials_emissive_strength:()=>TE,KHR_materials_ior:()=>XE,KHR_materials_iridescence:()=>iE,KHR_materials_sheen:()=>IE,KHR_materials_specular:()=>CE,KHR_materials_transmission:()=>AE,KHR_materials_unlit:()=>dE,KHR_materials_volume:()=>pE,KHR_texture_transform:()=>bE,OBJExport:()=>c,STLExport:()=>FE,USDZExportAsync:()=>Ev,_ConvertToGLTFPBRMetallicRoughness:()=>l,_SolveMetallic:()=>A,__IGLTFExporterExtension:()=>S});var z=v(11380),o=v(11193),q=v(11706);class c{static OBJ(B,E,v,c){const S=[];let x=1,D=1;E&&(v||(v="mat"),S.push("mtllib "+v+".mtl"));for(let h=0;h<B.length;h++){const v=B[h],y=v.name||`mesh${h}}`;S.push(`o ${y}`);let Q=null;if(c){const B=v.yc(!0);Q=new z.Matrix,B.invertToRef(Q),v.bakeTransformIntoVertices(B)}if(E){const B=v.material;B&&S.push("usemtl "+B.id)}const P=v.Qc;if(!P){o.Tools.Warn("No geometry is present on the mesh");continue}const G=P.getVerticesData("position"),Y=P.getVerticesData("normal"),a=P.getVerticesData("uv"),m=P.Pc();let g=0,V=0;if(!G||!m){o.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const T=B[0].rB().useRightHandedSystem?1:-1;for(let B=0;B<G.length;B+=3)S.push("v "+G[B]*T+" "+G[B+1]+" "+G[B+2]),g++;if(null!=Y)for(let B=0;B<Y.length;B+=3)S.push("vn "+Y[B]*T+" "+Y[B+1]+" "+Y[B+2]);if(null!=a)for(let B=0;B<a.length;B+=2)S.push("vt "+a[B]+" "+a[B+1]),V++;const N=["","",""],X=(v.material||v.rB().defaultMaterial)._getEffectiveOrientation(v),[r,i]=X===q.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let B=0;B<m.length;B+=3){const E=[String(m[B]+x),String(m[B+r]+x),String(m[B+i]+x)],v=[String(m[B]+D),String(m[B+r]+D),String(m[B+i]+D)],z=E,o=null!=a?v:N,q=null!=Y?E:N;S.push("f "+z[0]+"/"+o[0]+"/"+q[0]+" "+z[1]+"/"+o[1]+"/"+q[1]+" "+z[2]+"/"+o[2]+"/"+q[2])}c&&Q&&v.bakeTransformIntoVertices(Q),x+=g,D+=V}return S.join("\n")}static MTL(B){const E=[],v=B.material;E.push("newmtl mat1"),E.push("  Ns "+v.specularPower.toFixed(4)),E.push("  Ni 1.5000"),E.push("  d "+v.alpha.toFixed(4)),E.push("  Tr 0.0000"),E.push("  Tf 1.0000 1.0000 1.0000"),E.push("  illum 2"),E.push("  Ka "+v.ambientColor.r.toFixed(4)+" "+v.ambientColor.g.toFixed(4)+" "+v.ambientColor.b.toFixed(4)),E.push("  Kd "+v.diffuseColor.r.toFixed(4)+" "+v.diffuseColor.g.toFixed(4)+" "+v.diffuseColor.b.toFixed(4)),E.push("  Ks "+v.specularColor.r.toFixed(4)+" "+v.specularColor.g.toFixed(4)+" "+v.specularColor.b.toFixed(4)),E.push("  Ke "+v.emissiveColor.r.toFixed(4)+" "+v.emissiveColor.g.toFixed(4)+" "+v.emissiveColor.b.toFixed(4));v.ambientTexture&&E.push("  map_Ka "+v.ambientTexture.name),v.diffuseTexture&&E.push("  map_Kd "+v.diffuseTexture.name),v.specularTexture&&E.push("  map_Ks "+v.specularTexture.name),v.bumpTexture&&E.push("  map_bump -imfchan z "+v.bumpTexture.name),v.opacityTexture&&E.push("  map_d "+v.opacityTexture.name);return E.join("\n")}}var S=0,x=v(11249);class D{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const B in this.files){const E=this.files[B],v=new Blob([E],{type:(0,x.j)(B)});o.Tools.Download(v,B)}}}var h=v(11442),y=v(11802),Q=v(11815),P=v(11831),G=v(11492),Y=v(11242),a=v(11417),m=v(11394);const g=m.HighestCommonFactor,V={...m,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:g};var T=v(11594),N=v(11361),X=v(11863),r=v(11865),i=v(11589);const u=1e-6,I=new a.gE(.04,.04,.04),K=1024,C=a.gE.White(),f=a.gE.Black();function A(B,E,v){if(E<I.r)return 0;const z=I.r,o=B*v/(1-I.r)+E-2*I.r,q=o*o-4*z*(I.r-E);return V.Clamp((-o+Math.sqrt(q))/(2*z),0,1)}function l(B){const E=B.diffuseColor.toLinearSpace(B.rB().getEngine().useExactSrgbConversions).scale(.5),v=B.alpha,o=function(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new z.Vector2(0,1),v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new z.Vector2(0,.1),o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new z.Vector2(0,.1),q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new z.Vector2(1300,.1);return function(B,E,v,z,o){return(1-B)*(1-B)*(1-B)*E+3*(1-B)*(1-B)*B*v+3*(1-B)*B*B*z+B*B*B*o}(Math.pow(B/q.x,.333333),E.y,v.y,o.y,q.y)}(V.Clamp(B.specularPower,0,K));return{baseColorFactor:[E.r,E.g,E.b,v],metallicFactor:0,roughnessFactor:o}}function d(B,E){E.needAlphaBlending()?B.alphaMode="BLEND":E.needAlphaTesting()&&(B.alphaMode="MASK",B.alphaCutoff=E.alphaCutOff)}function t(B,E,v){const z=new Uint8Array(B*E*4);for(let o=0;o<z.length;o+=4)z[o]=z[o+1]=z[o+2]=z[o+3]=255;return X.d.CreateRGBATexture(z,B,E,v)}function p(B){if(B instanceof Uint8Array){const E=B.length,v=new Float32Array(B.length);for(let z=0;z<E;++z)v[z]=B[z]/255;return v}if(B instanceof Float32Array)return B;throw new Error("Unsupported pixel format!")}class H{constructor(B){this._exporter=B,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(B){return B?this._textureMap.get(B)??null:null}async exportStandardMaterialAsync(B,E,v){const z=l(B),q={name:B.name};if(null==B.Gc||B.Gc||(B.twoSidedLighting||o.Tools.Warn(B.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),q.doubleSided=!0),v){const v=[],o=B.diffuseTexture;o&&v.push(this.exportTextureAsync(o,E).then((B=>{B&&(z.baseColorTexture=B)})));const c=B.bumpTexture;c&&v.push(this.exportTextureAsync(c,E).then((B=>{B&&(q.normalTexture=B,1!==c.level&&(q.normalTexture.scale=c.level))})));const S=B.emissiveTexture;S&&(q.emissiveFactor=[1,1,1],v.push(this.exportTextureAsync(S,E).then((B=>{B&&(q.emissiveTexture=B)}))));const x=B.ambientTexture;x&&v.push(this.exportTextureAsync(x,E).then((B=>{if(B){const E={index:B.index};q.occlusionTexture=E}}))),v.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(v))}(B.alpha<1||B.opacityTexture)&&(B.alphaMode===r.d.ALPHA_COMBINE?q.alphaMode="BLEND":o.Tools.Warn(B.name+": glTF 2.0 does not support alpha mode: "+B.alphaMode.toString())),B.emissiveColor&&!B.emissiveColor.equalsWithEpsilon(f,u)&&(q.emissiveFactor=B.emissiveColor.cc()),q.pbrMetallicRoughness=z,d(q,B),await this._finishMaterialAsync(q,B,E);const c=this._exporter._materials;return c.push(q),c.length-1}async _finishMaterialAsync(B,E,v){const z=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",B,E),o=[];for(const q of z)o.push(this.exportTextureAsync(q,v));await Promise.all(o),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",B,E)}async _getImageDataAsync(B,E,z,o){const q=r.d.TEXTURETYPE_UNSIGNED_BYTE,c=this._exporter._babylonScene,S=c.getEngine(),x=S.createRawTexture(B,E,z,r.d.TEXTUREFORMAT_RGBA,!1,!0,N.b.NEAREST_SAMPLINGMODE,null,q);S.isWebGPU?await v.e(51).then(v.bind(v,13836)):await v.e(52).then(v.bind(v,13842)),await T.i.ApplyPostProcess("pass",x,c,q,r.d.TEXTURE_NEAREST_SAMPLINGMODE,r.d.TEXTUREFORMAT_RGBA);const D=await S._readTexturePixels(x,E,z);return await i.DumpTools.DumpDataAsync(E,z,D,o,void 0,!0,!0)}_resizeTexturesToSameDimensions(B,E,v){const z=B?B.getSize():{width:0,height:0},o=E?E.getSize():{width:0,height:0};let q,c;return z.width<o.width?(q=B&&B instanceof N.b?T.i.CreateResizedCopy(B,o.width,o.height,!0):t(o.width,o.height,v),c=E):z.width>o.width?(c=E&&E instanceof N.b?T.i.CreateResizedCopy(E,z.width,z.height,!0):t(z.width,z.height,v),q=B):(q=B,c=E),{texture1:q,texture2:c}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,E,v,z){const o=new Array;if(!B&&!E)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const q=B?B.rB():E?E.rB():null;if(q){var c;const S=this._resizeTexturesToSameDimensions(B,E,q),x=null===(c=S.texture1)||void 0===c?void 0:c.getSize();let D,h;const y=x.width,Q=x.height,P=await S.texture1.readPixels(),G=await S.texture2.readPixels();if(!P)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(D=p(P),!G)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");h=p(G);const Y=h.byteLength,m=new Uint8Array(Y),g=new Uint8Array(Y),V=4,T=f;let N=0,X=0;for(let B=0;B<Q;++B)for(let E=0;E<y;++E){const z=(y*B+E)*V,o={diffuseColor:new a.gE(D[z],D[z+1],D[z+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(v.diffuseColor),specularColor:new a.gE(h[z],h[z+1],h[z+2]).toLinearSpace(q.getEngine().useExactSrgbConversions).multiply(v.specularColor),glossiness:h[z+3]*v.glossiness},c=this._convertSpecularGlossinessToMetallicRoughness(o);T.r=Math.max(T.r,c.baseColor.r),T.g=Math.max(T.g,c.baseColor.g),T.b=Math.max(T.b,c.baseColor.b),N=Math.max(N,c.metallic),X=Math.max(X,c.roughness),g[z]=255*c.baseColor.r,g[z+1]=255*c.baseColor.g,g[z+2]=255*c.baseColor.b,g[z+3]=S.texture1.Sc?255*D[z+3]:255,m[z]=0,m[z+1]=255*c.roughness,m[z+2]=255*c.metallic,m[z+3]=255}const r={baseColor:T,metallic:N,roughness:X};let i=!1,I=!1;for(let B=0;B<Q;++B)for(let E=0;E<y;++E){const v=(y*B+E)*V;g[v]/=r.baseColor.r>u?r.baseColor.r:1,g[v+1]/=r.baseColor.g>u?r.baseColor.g:1,g[v+2]/=r.baseColor.b>u?r.baseColor.b:1;const z=a.gE.FromInts(g[v],g[v+1],g[v+2]).toGammaSpace(q.getEngine().useExactSrgbConversions);g[v]=255*z.r,g[v+1]=255*z.g,g[v+2]=255*z.b,z.equalsWithEpsilon(C,u)||(I=!0),m[v+1]/=r.roughness>u?r.roughness:1,m[v+2]/=r.metallic>u?r.metallic:1;a.gE.FromInts(255,m[v+1],m[v+2]).equalsWithEpsilon(C,u)||(i=!0)}return i&&o.push(this._getImageDataAsync(m,y,Q,z).then((B=>{r.metallicRoughnessTextureData=B}))),I&&o.push(this._getImageDataAsync(g,y,Q,z).then((B=>{r.baseColorTextureData=B}))),await Promise.all(o).then((()=>r))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(B){const E=this._getPerceivedBrightness(B.diffuseColor),v=this._getPerceivedBrightness(B.specularColor),z=1-this._getMaxComponent(B.specularColor),o=A(E,v,z),q=B.diffuseColor.scale(z/(1-I.r)/Math.max(1-o)),c=B.specularColor.YE(I.scale(1-o)).scale(1/Math.max(o));let S=a.gE.Lerp(q,c,o*o);S=S.clampToRef(0,1,S);return{baseColor:S,metallic:o,roughness:1-B.glossiness}}_getPerceivedBrightness(B){return B?Math.sqrt(.299*B.r*B.r+.587*B.g*B.g+.114*B.b*B.b):0}_getMaxComponent(B){return B?Math.max(B.r,Math.max(B.g,B.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(B,E,v,z){const o=[],q={baseColor:B._albedoColor,metallic:B._metallic,roughness:B._roughness};if(z){B._albedoTexture&&o.push(this.exportTextureAsync(B._albedoTexture,E).then((B=>{B&&(v.baseColorTexture=B)})));const z=B._metallicTexture;z&&o.push(this.exportTextureAsync(z,E).then((B=>{B&&(v.metallicRoughnessTexture=B)})))}return o.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(o)),q}_getTextureSampler(B){const E={};if(!B||!(B instanceof N.b))return E;const v=this._getGLTFTextureWrapMode(B.wrapU);10497!==v&&(E.wrapS=v);const z=this._getGLTFTextureWrapMode(B.wrapV);switch(10497!==z&&(E.wrapT=z),B.samplingMode){case N.b.LINEAR_LINEAR:E.magFilter=9729,E.minFilter=9729;break;case N.b.LINEAR_NEAREST:E.magFilter=9729,E.minFilter=9728;break;case N.b.NEAREST_LINEAR:E.magFilter=9728,E.minFilter=9729;break;case N.b.NEAREST_LINEAR_MIPLINEAR:E.magFilter=9728,E.minFilter=9987;break;case N.b.NEAREST_NEAREST:E.magFilter=9728,E.minFilter=9728;break;case N.b.NEAREST_LINEAR_MIPNEAREST:E.magFilter=9728,E.minFilter=9985;break;case N.b.LINEAR_NEAREST_MIPNEAREST:E.magFilter=9729,E.minFilter=9984;break;case N.b.LINEAR_NEAREST_MIPLINEAR:E.magFilter=9729,E.minFilter=9986;break;case N.b.NEAREST_NEAREST_MIPLINEAR:E.magFilter=9728,E.minFilter=9986;break;case N.b.LINEAR_LINEAR_MIPLINEAR:E.magFilter=9729,E.minFilter=9987;break;case N.b.LINEAR_LINEAR_MIPNEAREST:E.magFilter=9729,E.minFilter=9985;break;case N.b.NEAREST_NEAREST_MIPNEAREST:E.magFilter=9728,E.minFilter=9984}return E}_getGLTFTextureWrapMode(B){switch(B){case N.b.WRAP_ADDRESSMODE:return 10497;case N.b.CLAMP_ADDRESSMODE:return 33071;case N.b.MIRROR_ADDRESSMODE:return 33648;default:return o.Tools.Error(`Unsupported Texture Wrap Mode ${B}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(B,E,v,z){const o={diffuseColor:B._albedoColor,specularColor:B._reflectivityColor,glossiness:B._microSurface},q=B._albedoTexture,c=B._reflectivityTexture,S=B._useMicroSurfaceFromReflectivityMapAlpha;if(c&&!S)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((q||c)&&z){this._exporter._materialNeedsUVsSet.add(B);const z=this._exportTextureSampler(q||c),S=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,c,o,E),x=this._exporter._textures;if(S.baseColorTextureData){const B=this._exportImage(`baseColor${x.length}`,E,S.baseColorTextureData);v.baseColorTexture=this._exportTextureInfo(B,z,null===q||void 0===q?void 0:q.coordinatesIndex)}if(S.metallicRoughnessTextureData){const B=this._exportImage(`metallicRoughness${x.length}`,E,S.metallicRoughnessTextureData);v.metallicRoughnessTexture=this._exportTextureInfo(B,z,null===c||void 0===c?void 0:c.coordinatesIndex)}return S}return this._convertSpecularGlossinessToMetallicRoughness(o)}async exportPBRMaterialAsync(B,E,v){const z={},o={name:B.name},q=B.isMetallicWorkflow();if(q){const E=B._albedoColor,v=B.alpha;E&&(z.baseColorFactor=[E.r,E.g,E.b,v])}const c=q?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(B,E,z,v):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(B,E,z,v);await this._setMetallicRoughnessPbrMaterialAsync(c,B,o,z,E,v),await this._finishMaterialAsync(o,B,E);const S=this._exporter._materials;return S.push(o),S.length-1}async _setMetallicRoughnessPbrMaterialAsync(B,E,v,z,q,c){if(d(v,E),B.baseColor.equalsWithEpsilon(C,u)&&V.WithinEpsilon(E.alpha,1,u)||(z.baseColorFactor=[B.baseColor.r,B.baseColor.g,B.baseColor.b,E.alpha]),null!=B.metallic&&1!==B.metallic&&(z.metallicFactor=B.metallic),null!=B.roughness&&1!==B.roughness&&(z.roughnessFactor=B.roughness),null==E.Gc||E.Gc||(E._twoSidedLighting||o.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),v.doubleSided=!0),c){const B=[],z=E._bumpTexture;z&&B.push(this.exportTextureAsync(z,q).then((B=>{B&&(v.normalTexture=B,1!==z.level&&(v.normalTexture.scale=z.level))})));const o=E._ambientTexture;o&&B.push(this.exportTextureAsync(o,q).then((B=>{if(B){const z={index:B.index,texCoord:B.texCoord,extensions:B.extensions};v.occlusionTexture=z;const o=E._ambientTextureStrength;o&&(z.strength=o)}})));const c=E._emissiveTexture;c&&B.push(this.exportTextureAsync(c,q).then((B=>{B&&(v.emissiveTexture=B)}))),B.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(B))}const S=E._emissiveColor;S.equalsWithEpsilon(f,u)||(v.emissiveFactor=S.cc()),v.pbrMetallicRoughness=z}_getPixelsFromTextureAsync(B){return function(B){switch(B){case r.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case r.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case r.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case r.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case r.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case r.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case r.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case r.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case r.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case r.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case r.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case r.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(B.textureFormat)?(0,T.g)(B,B._texture.width,B._texture.height):(B.textureType,r.d.TEXTURETYPE_UNSIGNED_BYTE,B.readPixels())}async exportTextureAsync(B,E){const v=this._exporter._extensionsPreExportTextureAsync("exporter",B,E);return v?await v.then((async v=>v?await this._exportTextureInfoAsync(v,E):await this._exportTextureInfoAsync(B,E))):await this._exportTextureInfoAsync(B,E)}async _exportTextureInfoAsync(B,E){let v=this._textureMap.get(B);if(!v){const z=await this._getPixelsFromTextureAsync(B);if(!z)return null;const q=this._exportTextureSampler(B),c=B.mimeType;if(c)switch(c){case"image/jpeg":case"image/png":case"image/webp":E=c;break;default:o.Tools.Warn(`Unsupported media type: ${c}. Exporting texture as PNG.`)}const S=this._internalTextureToImage,x=B.getInternalTexture().uniqueId;S[x]||(S[x]={});let D=S[x][E];if(void 0===D){const v=B.getSize();D=(async()=>{const o=await this._getImageDataAsync(z,v.width,v.height,E);return this._exportImage(B.name,E,o)})(),S[x][E]=D}v=this._exportTextureInfo(await D,q,B.coordinatesIndex),this._textureMap.set(B,v),this._exporter._extensionsPostExportTextures("exporter",v,B)}return v}_exportImage(B,E,v){const z=this._exporter._images;let q;if(this._exporter._shouldUseGlb){q={name:B,mimeType:E,bufferView:void 0};const z=this._exporter._bufferManager.createBufferView(new Uint8Array(v));this._exporter._bufferManager.setBufferView(q,z)}else{const c=B.replace(/\.\/|\/|\.\\|\\/g,"_"),S=function(B){switch(B){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(E);let x=c+S;z.some((B=>B.uri===x))&&(x=`${c}_${o.Tools.RandomId()}${S}`),q={name:B,uri:x},this._exporter._imageData[x]={data:v,mimeType:E}}return z.push(q),z.length-1}_exportTextureInfo(B,E,v){const z=this._exporter._textures;let o=z.findIndex((v=>v.sampler==E&&v.source===B));-1===o&&(o=z.length,z.push({source:B,sampler:E}));const q={index:o};return v&&(q.texCoord=v),q}_exportTextureSampler(B){const E=this._getTextureSampler(B),v=this._exporter._samplers,z=v.findIndex((B=>B.minFilter===E.minFilter&&B.magFilter===E.magFilter&&B.wrapS===E.wrapS&&B.wrapT===E.wrapT));return-1!==z?z:(v.push(E),v.length-1)}}var j=v(11453),R=v(11213),b=v(11870),F=v(11382);const W=z.GE.Zero(),w=z.Quaternion.Identity(),n=z.GE.One(),U=new z.GE(-1,1,1);function s(B,E){const{byteOffset:v,byteStride:z,type:o,normalized:q}=B,c=B.getSize(),S=E.reduce(((B,E)=>E.getTotalVertices()>B?E.getTotalVertices():B),-Number.MAX_VALUE);return{byteOffset:v,byteStride:z,componentCount:c,type:o,count:S*c,normalized:q,totalVertices:S,kind:B.getKind()}}function J(B){switch(B){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function O(B){switch(B){case h.e.PositionKind:case h.e.NormalKind:case h.e.TangentKind:case h.e.ColorKind:case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:case h.e.MatricesWeightsKind:case h.e.MatricesWeightsExtraKind:case h.e.UVKind:case h.e.UV2Kind:case h.e.UV3Kind:case h.e.UV4Kind:case h.e.UV5Kind:case h.e.UV6Kind:return!0}return!1}function e(B){switch(B){case q.c.TriangleFillMode:return 4;case q.c.TriangleStripDrawMode:return 5;case q.c.TriangleFanDrawMode:return 6;case q.c.PointListDrawMode:case q.c.PointFillMode:return 0;case q.c.LineLoopDrawMode:return 2;case q.c.LineListDrawMode:return 1;case q.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${B}`)}function k(B){const E=Math.sqrt(B.x*B.x+B.y*B.y+B.z*B.z);E>0&&(B.x/=E,B.y/=E,B.z/=E)}function L(B){return B.x*=-1,B}function M(B){if(B.x*B.x+B.y*B.y>.5){const E=Math.abs(B.x),v=Math.abs(B.y);if(E>v){const v=Math.sign(B.x);B.x=E,B.y*=-v,B.z*=-v,B.w*=v}else{const E=Math.sign(B.y);B.x*=-E,B.y=v,B.z*=E,B.w*=-E}}else{const E=Math.abs(B.z),v=Math.abs(B.w);if(E>v){const v=Math.sign(B.z);B.x*=-v,B.y*=v,B.z=E,B.w*=-v}else{const E=Math.sign(B.w);B.x*=E,B.y*=-E,B.z*=-E,B.w=v}}return B}function Z(B){B.Yc(-B.z,B.w,B.x,-B.y)}function BB(B,E){const v=z.GE.FromArrayToRef(E.translation||[0,0,0],0,z.TmpVectors.GE[0]),o=z.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[0]),q=z.Matrix.ComposeToRef(n,o,v,z.TmpVectors.Matrix[0]),c=z.GE.FromArrayToRef(B.translation||[0,0,0],0,z.TmpVectors.GE[2]),S=z.Quaternion.FromArrayToRef(B.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[1]),x=z.Matrix.ComposeToRef(n,S,c,z.TmpVectors.Matrix[1]);q.multiplyToRef(x,x),x.decompose(void 0,o,v),v.equalsWithEpsilon(W,F.e)?delete E.translation:E.translation=v.cc(),o.equalsWithEpsilon(w,F.e)?delete E.rotation:E.rotation=o.cc(),E.scale&&delete E.scale}function EB(B,E){if(!(E instanceof y.e))return!1;if(!(1===E.getChildren().length&&0===B.getChildren().length&&B.parent===E))return!1;const v=B.rB(),z=B instanceof b.d&&!v.useRightHandedSystem?U:n;return!!E.ac.equalsWithEpsilon(z,F.e)||(R.c.Warn(`Cannot collapse node ${B.name} into parent node ${E.name} with modified scaling.`),!1)}function vB(B){if(B instanceof Array){const E=new Float32Array(B);return new Uint8Array(E.buffer,E.byteOffset,E.byteLength)}return ArrayBuffer.isView(B)?new Uint8Array(B.buffer,B.byteOffset,B.byteLength):new Uint8Array(B)}function zB(B,E){for(const[v,z]of Object.entries(B)){const o=E[v];(Array.isArray(z)&&Array.isArray(o)&&oB(z,o)||z===o)&&delete B[v]}return B}function oB(B,E){return B.length===E.length&&B.every(((B,v)=>B===E[v]))}const qB=z.Matrix.Compose(new z.GE(-1,1,1),z.Quaternion.Identity(),z.GE.Zero());function cB(B,E){if(!(B instanceof y.e))return!1;if(E){if(!B.getWorldMatrix().equalsWithEpsilon(z.Matrix.IdentityReadOnly,F.e))return!1}else{if(!B.getWorldMatrix().multiplyToRef(qB,z.TmpVectors.Matrix[0]).equalsWithEpsilon(z.Matrix.IdentityReadOnly,F.e))return!1}return!(B instanceof Q.e&&B.Qc)}const SB=new Map([[Int8Array,(B,E,v)=>B.setInt8(E,v)],[Uint8Array,(B,E,v)=>B.setUint8(E,v)],[Uint8ClampedArray,(B,E,v)=>B.setUint8(E,v)],[Int16Array,(B,E,v)=>B.setInt16(E,v,!0)],[Uint16Array,(B,E,v)=>B.setUint16(E,v,!0)],[Int32Array,(B,E,v)=>B.setInt32(E,v,!0)],[Uint32Array,(B,E,v)=>B.setUint32(E,v,!0)],[Float32Array,(B,E,v)=>B.setFloat32(E,v,!0)],[Float64Array,(B,E,v)=>B.setFloat64(E,v,!0)]]);class xB{writeTypedArray(B){this._checkGrowBuffer(B.byteLength);const E=SB.get(B.constructor);for(let v=0;v<B.length;v++)E(this._dataView,this._byteOffset,B[v]),this._byteOffset+=B.BYTES_PER_ELEMENT}constructor(B){this._data=new Uint8Array(B),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(B){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,B),this._byteOffset++}writeInt8(B){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,B),this._byteOffset++}writeInt16(B){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,B,!0),this._byteOffset+=2}writeUInt16(B){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,B,!0),this._byteOffset+=2}writeInt32(B){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,B,!0),this._byteOffset+=4}writeUInt32(B){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat32(B){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat64(B){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,B,!0),this._byteOffset+=8}_checkGrowBuffer(B){const E=this.byteOffset+B;if(E>this._data.byteLength){const B=new Uint8Array(2*E);B.set(this._data),this._data=B,this._dataView=new DataView(this._data.buffer)}}}function DB(B){return B%4===0?4:B%2===0?2:1}class hB{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(B){let E=0;this._bufferViewToData.forEach((B=>{E+=B.byteLength}));const v=new xB(E),z=Array.from(this._bufferViewToData.keys()).sort(((B,E)=>DB(E.byteLength)-DB(B.byteLength)));for(const o of z){o.byteOffset=v.byteOffset,B.push(o);const E=B.length-1,z=this.getPropertiesWithBufferView(o);for(const B of z)B.bufferView=E;v.writeTypedArray(this._bufferViewToData.get(o)),this._bufferViewToData.delete(o)}return v.getOutputData()}createBufferView(B,E){const v={buffer:0,byteOffset:void 0,byteLength:B.byteLength,byteStride:E};return this._bufferViewToData.set(v,B),v}createAccessor(B,E,v,z,o,q,c){this._verifyBufferView(B);const S={bufferView:void 0,componentType:v,count:z,type:E,min:null===q||void 0===q?void 0:q.min,max:null===q||void 0===q?void 0:q.max,normalized:c,byteOffset:o};return this.setBufferView(S,B),this._accessorToBufferView.set(S,B),S}setBufferView(B,E){this._verifyBufferView(E);this.getPropertiesWithBufferView(E).push(B)}removeBufferView(B){const E=this.getPropertiesWithBufferView(B);for(const v of E)void 0!==v.bufferView&&delete v.bufferView;this._bufferViewToData.delete(B),this._bufferViewToProperties.delete(B),this._accessorToBufferView.forEach(((E,v)=>{E===B&&(void 0!==v.byteOffset&&delete v.byteOffset,this._accessorToBufferView.delete(v))}))}getBufferView(B){const E=this._accessorToBufferView.get(B);return this._verifyBufferView(E),E}getPropertiesWithBufferView(B){return this._verifyBufferView(B),this._bufferViewToProperties.set(B,this._bufferViewToProperties.get(B)??[]),this._bufferViewToProperties.get(B)}getData(B){return this._verifyBufferView(B),this._bufferViewToData.get(B)}_verifyBufferView(B){if(void 0===B||!this._bufferViewToData.has(B))throw new Error(`BufferView ${B} not found in BufferManager.`)}}var yB,QB=v(11841),PB=v(11858),GB=v(11874),YB=v(11756),aB=v(11908),mB=v(11917),gB=v(11833),VB=v(11920);!function(B){B[B.INTANGENT=0]="INTANGENT",B[B.OUTTANGENT=1]="OUTTANGENT"}(yB||(yB={}));class TB{static _IsTransformable(B){return B&&(B instanceof y.e||B instanceof QB.c||B instanceof VB.c)}static _CreateNodeAnimation(B,E,v,z,q){if(this._IsTransformable(B)){const c=[],S=[],x=E.getKeys(),D=TB._CalculateMinMaxKeyFrames(x),h=TB._DeduceInterpolation(x,v,z),y=h.interpolationType,Q=h.shouldBakeAnimation;if(Q?TB._CreateBakedAnimation(B,E,v,D.min,D.max,E.framePerSecond,q,c,S,D,z):"LINEAR"===y||"STEP"===y?TB._CreateLinearOrStepAnimation(B,E,v,c,S,z):"CUBICSPLINE"===y?TB._CreateCubicSplineAnimation(B,E,v,c,S,z):TB._CreateBakedAnimation(B,E,v,D.min,D.max,E.framePerSecond,q,c,S,D,z),c.length&&S.length){return{inputs:c,outputs:S,samplerInterpolation:y,inputsMin:Q?D.min:o.Tools.FloatRound(D.min/E.framePerSecond),inputsMax:Q?D.max:o.Tools.FloatRound(D.max/E.framePerSecond)}}}return null}static _DeduceAnimationInfo(B){let E=null,v="VEC3",z=!1;const q=B.targetProperty.split(".");switch(q[0]){case"ac":E="scale";break;case"position":E="translation";break;case"rotation":v="VEC4",E="rotation";break;case"rotationQuaternion":v="VEC4",z=!0,E="rotation";break;case"influence":v="SCALAR",E="weights";break;default:o.Tools.Error(`Unsupported animatable property ${q[0]}`)}return E?{animationChannelTargetPath:E,dataAccessorType:v,useQuaternion:z}:(o.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(B,E,v,z,o,q,c,S,x,D,h){let y;if(TB._IsTransformable(B)&&B.animations)for(const Q of B.animations){if(h&&!h(Q))continue;const o=TB._DeduceAnimationInfo(Q);o&&(y={name:Q.name,samplers:[],channels:[]},TB._AddAnimation(`${Q.name}`,Q.hasRunningRuntimeAnimations?E:y,B,Q,o.dataAccessorType,o.animationChannelTargetPath,z,q,c,S,o.useQuaternion,x,D),y.samplers.length&&y.channels.length&&v.push(y))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(B,E,v,z,o,q,c,S,x,D,h){let y;if(B instanceof gB.e){const o=B.morphTargetManager;if(o)for(let Q=0;Q<o.numTargets;++Q){const P=o.getTarget(Q);for(const G of P.animations){if(h&&!h(G))continue;const P=new aB.c(`${G.name}`,"influence",G.framePerSecond,G.dataType,G.loopMode,G.enableBlending),Y=[],a=G.getKeys();for(let B=0;B<a.length;++B){const E=a[B];for(let B=0;B<o.numTargets;++B)B==Q?Y.push(E):Y.push({frame:E.frame,value:0})}P.setKeys(Y);const m=TB._DeduceAnimationInfo(P);m&&(y={name:P.name,samplers:[],channels:[]},TB._AddAnimation(G.name,G.hasRunningRuntimeAnimations?E:y,B,P,m.dataAccessorType,m.animationChannelTargetPath,z,q,c,S,m.useQuaternion,x,D,o.numTargets),y.samplers.length&&y.channels.length&&v.push(y))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(B,E,v,z,o,q,c,S,x){let D;if(B.animationGroups){const y=B.animationGroups;for(const Q of y){const y=new Map,P=new Map,G=new Set,Y=Q.to-Q.from;D={name:Q.name,channels:[],samplers:[]};for(let E=0;E<Q.targetedAnimations.length;++E){const Y=Q.targetedAnimations[E],a=Y.target,m=Y.animation;if(x&&!x(m))continue;const g=S.has(a);if(this._IsTransformable(a)||1===a.length&&this._IsTransformable(a[0])){const B=TB._DeduceAnimationInfo(Y.animation);if(B){const E=this._IsTransformable(a)?a:this._IsTransformable(a[0])?a[0]:null;E&&TB._AddAnimation(`${m.name}`,D,E,m,B.dataAccessorType,B.animationChannelTargetPath,v,z,o,q,B.useQuaternion,c,g)}}else if(a instanceof mB.d||1===a.length&&a[0]instanceof mB.d){if(TB._DeduceAnimationInfo(Y.animation)){const E=a instanceof mB.d?a:a[0];if(E){const v=B.morphTargetManagers.find((B=>{for(let v=0;v<B.numTargets;++v)if(B.getTarget(v)===E)return!0;return!1}));if(v){const z=B.meshes.find((B=>B.morphTargetManager===v));var h;if(z)y.has(z)||y.set(z,new Map),null===(h=y.get(z))||void 0===h||h.set(E,m),G.add(z),P.set(z,m)}}}}}G.forEach((B=>{const E=B.morphTargetManager;let S=null;const x=[],h=P.get(B).getKeys(),G=h.length;for(let v=0;v<G;++v)for(let z=0;z<E.numTargets;++z){const o=E.getTarget(z),q=y.get(B);if(q){const E=q.get(o);E?(S||(S=new aB.c(`${Q.name}_${B.name}_MorphWeightAnimation`,"influence",E.framePerSecond,aB.c.ANIMATIONTYPE_FLOAT,E.loopMode,E.enableBlending)),x.push(E.getKeys()[v])):x.push({frame:Q.from+Y/G*v,value:o.influence,inTangent:h[0].inTangent?0:void 0,outTangent:h[0].outTangent?0:void 0})}}S.setKeys(x);const a=TB._DeduceAnimationInfo(S);a&&TB._AddAnimation(`${Q.name}_${B.name}_MorphWeightAnimation`,D,B,S,a.dataAccessorType,a.animationChannelTargetPath,v,z,o,q,a.useQuaternion,c,!1,null===E||void 0===E?void 0:E.numTargets)})),D.channels.length&&D.samplers.length&&E.push(D)}}}static _AddAnimation(B,E,v,o,q,c,S,x,D,h,y,Q,P,G){const Y=TB._CreateNodeAnimation(v,o,c,y,Q);let a,m,g,V,T,N;if(Y){if(G){let B=0,E=0;const v=[];for(;Y.inputs.length>0;)E=Y.inputs.shift(),B%G==0&&v.push(E),B++;Y.inputs=v}const B=S.get(v),o=new Float32Array(Y.inputs);a=x.createBufferView(o),m=x.createAccessor(a,"SCALAR",5126,Y.inputs.length,void 0,{min:[Y.inputsMin],max:[Y.inputsMax]}),h.push(m),g=h.length-1;const D=new z.Quaternion,y=new z.GE,Q=new z.GE,X=v instanceof QB.c,r=J(q),i=new Float32Array(Y.outputs.length*r);Y.outputs.forEach((function(B,E){let v=B;switch(c){case"translation":P&&(z.GE.FromArrayToRef(B,0,Q),L(Q),Q.toArray(v));break;case"rotation":4===B.length?z.Quaternion.FromArrayToRef(B,0,D):(v=new Array(4),z.GE.FromArrayToRef(B,0,y),z.Quaternion.FromEulerVectorToRef(y,D)),P&&(M(D),X&&Z(D)),D.toArray(v)}i.set(v,E*r)})),a=x.createBufferView(i),m=x.createAccessor(a,q,5126,Y.outputs.length),h.push(m),V=h.length-1,T={interpolation:Y.samplerInterpolation,input:g,output:V},E.samplers.push(T),N={sampler:E.samplers.length-1,target:{node:B,path:c}},E.channels.push(N)}}static _CreateBakedAnimation(B,E,v,q,c,S,x,D,h,y,Q){let P;const G=z.Quaternion.Identity();let Y,a=null,m=null,g=null,V=null,T=null,N=null;y.min=o.Tools.FloatRound(q/S);const X=E.getKeys();for(let z=0,r=X.length;z<r;++z){if(N=null,g=X[z],z+1<r)if(V=X[z+1],g.value.equals&&g.value.equals(V.value)||g.value===V.value){if(0!==z)continue;N=g.frame}else N=V.frame;else{if(T=X[z-1],g.value.equals&&g.value.equals(T.value)||g.value===T.value)continue;N=c}if(N)for(let z=g.frame;z<=N;z+=x){if(Y=o.Tools.FloatRound(z/S),Y===a)continue;a=Y,m=Y;const q={key:0,repeatCount:0,loopMode:E.loopMode};P=E._interpolate(z,q),TB._SetInterpolatedValue(B,P,Y,E,v,G,D,h,Q)}}m&&(y.max=m)}static _ConvertFactorToVector3OrQuaternion(B,E,v,q,c){const S=TB._GetBasePositionRotationOrScale(E,q,c),x=v.targetProperty.split("."),D=x?x[1]:"",h=c?z.Quaternion.VE(S).normalize():z.GE.VE(S);switch(D){case"x":case"y":case"z":h[D]=B;break;case"w":h.w=B;break;default:o.Tools.Error(`glTFAnimation: Unsupported component name "${D}"!`)}return h}static _SetInterpolatedValue(B,E,v,o,q,c,S,x,D){let h;S.push(v),"weights"!==q?(o.dataType===aB.c.ANIMATIONTYPE_FLOAT&&(E=this._ConvertFactorToVector3OrQuaternion(E,B,o,q,D)),"rotation"===q?(D?c=E:(h=E,z.Quaternion.RotationYawPitchRollToRef(h.y,h.x,h.z,c)),x.push(c.cc())):(h=E,x.push(h.cc()))):x.push([E])}static _CreateLinearOrStepAnimation(B,E,v,z,o,q){for(const c of E.getKeys())z.push(c.frame/E.framePerSecond),TB._AddKeyframeValue(c,E,o,v,B,q)}static _CreateCubicSplineAnimation(B,E,v,z,o,q){E.getKeys().forEach((function(c){z.push(c.frame/E.framePerSecond),TB._AddSplineTangent(yB.INTANGENT,o,v,"CUBICSPLINE",c,q),TB._AddKeyframeValue(c,E,o,v,B,q),TB._AddSplineTangent(yB.OUTTANGENT,o,v,"CUBICSPLINE",c,q)}))}static _GetBasePositionRotationOrScale(B,E,v){let o;if("rotation"===E)if(v){o=(B.rotationQuaternion??z.Quaternion.Identity()).cc()}else{o=(B.rotation??z.GE.Zero()).cc()}else if("translation"===E){o=(B.position??z.GE.Zero()).cc()}else{o=(B.ac??z.GE.One()).cc()}return o}static _AddKeyframeValue(B,E,v,q,c,S){let x;const D=E.dataType;if(D===aB.c.ANIMATIONTYPE_VECTOR3){let E=B.value.cc();if("rotation"===q){const B=z.GE.VE(E);E=z.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).cc()}v.push(E)}else if(D===aB.c.ANIMATIONTYPE_FLOAT){if("weights"===q)v.push([B.value]);else if(x=this._ConvertFactorToVector3OrQuaternion(B.value,c,E,q,S),x){if("rotation"===q){const B=S?x:z.Quaternion.RotationYawPitchRoll(x.y,x.x,x.z).normalize();v.push(B.cc())}v.push(x.cc())}}else D===aB.c.ANIMATIONTYPE_QUATERNION?v.push(B.value.normalize().cc()):o.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(B,E,v){let z,o,q=!1;if("rotation"===E&&!v)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let c=0,S=B.length;c<S;++c)if(o=B[c],o.inTangent||o.outTangent)if(z){if("CUBICSPLINE"!==z){z="LINEAR",q=!0;break}}else z="CUBICSPLINE";else if(z){if("CUBICSPLINE"===z||o.interpolation&&1===o.interpolation&&"STEP"!==z){z="LINEAR",q=!0;break}}else z=o.interpolation&&1===o.interpolation?"STEP":"LINEAR";return z||(z="LINEAR"),{interpolationType:z,shouldBakeAnimation:q}}static _AddSplineTangent(B,E,v,o,q,c){let S;const x=B===yB.INTANGENT?q.inTangent:q.outTangent;if("CUBICSPLINE"===o){if("rotation"===v)if(x)if(c)S=x.cc();else{const B=x;S=z.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).cc()}else S=[0,0,0,0];else S="weights"===v?x?[x]:[0]:x?x.cc():[0,0,0];E.push(S)}}static _CalculateMinMaxKeyFrames(B){let E=1/0,v=-1/0;return B.forEach((function(B){E=Math.min(E,B.frame),v=Math.max(v,B.frame)})),{min:E,max:v}}}function NB(B,E,v,q,c,S){const x={attributes:{},influence:B.influence,name:B.name},D=E.Qc;if(!D)return o.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),x;const y=S?-1:1,Q=z.GE.Zero();let P=0,G=0;if(B.hasPositions){const q=B.getPositions(),S=D.getVerticesData(h.e.PositionKind);if(S){const B=new Float32Array(S.length),E=[1/0,1/0,1/0],o=[-1/0,-1/0,-1/0];G=S.length/3,P=0;for(let v=P;v<G;++v){const c=z.GE.VE(S,3*v);z.GE.VE(q,3*v).subtractToRef(c,Q),Q.x*=y,E[0]=Math.min(E[0],Q.x),o[0]=Math.max(o[0],Q.x),E[1]=Math.min(E[1],Q.y),o[1]=Math.max(o[1],Q.y),E[2]=Math.min(E[2],Q.z),o[2]=Math.max(o[2],Q.z),B[3*v]=Q.x,B[3*v+1]=Q.y,B[3*v+2]=Q.z}const D=v.createBufferView(B,12),h=v.createAccessor(D,"VEC3",5126,q.length/3,0,{min:E,max:o});c.push(h),x.attributes.POSITION=c.length-1}else o.Tools.Warn(`Morph target positions for mesh ${E.name} were not exported. Mesh does not have position vertex data`)}if(B.hasNormals){const q=B.getNormals(),S=D.getVerticesData(h.e.NormalKind);if(S){const B=new Float32Array(S.length);G=S.length/3,P=0;for(let v=P;v<G;++v){const E=z.GE.VE(S,3*v).normalize();z.GE.VE(q,3*v).normalize().subtractToRef(E,Q),B[3*v]=Q.x*y,B[3*v+1]=Q.y,B[3*v+2]=Q.z}const E=v.createBufferView(B,12),o=v.createAccessor(E,"VEC3",5126,q.length/3,0);c.push(o),x.attributes.NORMAL=c.length-1}else o.Tools.Warn(`Morph target normals for mesh ${E.name} were not exported. Mesh does not have normals vertex data`)}if(B.hasTangents){const q=B.getTangents(),S=D.getVerticesData(h.e.TangentKind);if(S){G=S.length/4;const B=new Float32Array(3*G);P=0;for(let v=P;v<G;++v){const E=z.GE.VE(S,4*v);k(E);const o=z.GE.VE(q,3*v);k(o),o.subtractToRef(E,Q),B[3*v]=Q.x*y,B[3*v+1]=Q.y,B[3*v+2]=Q.z}const E=v.createBufferView(B,12),o=v.createAccessor(E,"VEC3",5126,G,0);c.push(o),x.attributes.TANGENT=c.length-1}else o.Tools.Warn(`Morph target tangents for mesh ${E.name} were not exported. Mesh does not have tangents vertex data`)}if(B.hasColors){const q=B.getColors(),S=D.getVerticesData(h.e.ColorKind),y=D.getVertexBuffer(h.e.ColorKind);if(S&&y){const B=y.getSize();G=S.length/B;const E=new Float32Array(G*B);P=0;for(let v=P;v<G;++v)if(3===B){const o=z.GE.VE(S,v*B);z.GE.VE(q,v*B).subtractToRef(o,Q),E[3*v]=Q.x,E[3*v+1]=Q.y,E[3*v+2]=Q.z}else if(4===B){const o=new z.Vector4,c=z.Vector4.VE(S,v*B);z.Vector4.VE(q,v*B).subtractToRef(c,o),E[4*v]=o.x,E[4*v+1]=o.y,E[4*v+2]=o.z,E[4*v+3]=o.w}else o.Tools.Warn(`Unsupported number of components for color attribute: ${B}`);const D=v.createBufferView(E,4*B),h=v.createAccessor(D,3===B?"VEC3":"VEC4",5126,G,0);c.push(h),x.attributes.COLOR_0=c.length-1}else o.Tools.Warn(`Morph target colors for mesh ${E.name} were not exported. Mesh does not have colors vertex data`)}return x}var XB=v(11929),rB=v(11789),iB=v(11772),uB=v(11345);class IB{}IB.DEFAULT_COLOR=a.gE.White(),IB.DEFAULT_WIDTH_ATTENUATED=1,IB.DEFAULT_WIDTH=.1;var KB=v(11578),CB=v(11934);class fB{static ConvertPoints(B,E){if(B.length&&Array.isArray(B)&&"number"===typeof B[0])return[B];if(B.length&&Array.isArray(B[0])&&"number"===typeof B[0][0])return B;if(B.length&&!Array.isArray(B[0])&&B[0]instanceof z.GE){const E=[];for(let v=0;v<B.length;v++){const z=B[v];E.push(z.x,z.y,z.z)}return[E]}if(B.length>0&&Array.isArray(B[0])&&B[0].length>0&&B[0][0]instanceof z.GE){const E=[],v=B;for(const B of v)E.push(B.flatMap((B=>[B.x,B.y,B.z])));return E}if(B instanceof Float32Array){if(null!==E&&void 0!==E&&E.floatArrayStride){const v=[],z=3*E.floatArrayStride;for(let E=0;E<B.length;E+=z){const o=new Array(z);for(let v=0;v<z;v++)o[v]=B[E+v];v.push(o)}return v}return[Array.from(B)]}if(B.length&&B[0]instanceof Float32Array){const E=[];for(const v of B)E.push(Array.from(v));return E}return[]}static OmitZeroLengthPredicate(B,E,v){const z=[];return E.YE(B).lengthSquared()>0&&z.push([B,E]),v.YE(E).lengthSquared()>0&&z.push([E,v]),B.YE(v).lengthSquared()>0&&z.push([v,B]),0===z.length?null:z}static OmitDuplicatesPredicate(B,E,v,z){const o=[];return fB._SearchInPoints(B,E,z)||o.push([B,E]),fB._SearchInPoints(E,v,z)||o.push([E,v]),fB._SearchInPoints(v,B,z)||o.push([v,B]),0===o.length?null:o}static _SearchInPoints(B,E,v){for(const c of v)for(let v=0;v<c.length;v++){var z,o,q;if(null!==(z=c[v])&&void 0!==z&&z.equals(B))if(null!==(o=c[v+1])&&void 0!==o&&o.equals(E)||null!==(q=c[v-1])&&void 0!==q&&q.equals(E))return!0}return!1}static MeshesToLines(B,E){const v=[];for(let o=0;o<B.length;o++){const q=B[o],c=q.getVerticesData(h.e.PositionKind),S=q.Pc();if(c&&S)for(let B=0,x=0;B<S.length;B++){const D=3*S[x++],h=3*S[x++],y=3*S[x++],Q=new z.GE(c[D],c[D+1],c[D+2]),P=new z.GE(c[h],c[h+1],c[h+2]),G=new z.GE(c[y],c[y+1],c[y+2]);if(E){const z=E(Q,P,G,v,B,D,q,o,c,S);if(z)for(const B of z)v.push(B)}else v.push([Q,P],[P,G],[G,Q])}}return v}static ToVector3Array(B){if(Array.isArray(B[0])){const E=[],v=B;for(const B of v){const v=[];for(let E=0;E<B.length;E+=3)v.push(new z.GE(B[E],B[E+1],B[E+2]));E.push(v)}return E}const E=B,v=[];for(let o=0;o<E.length;o+=3)v.push(new z.GE(E[o],E[o+1],E[o+2]));return v}static ToNumberArray(B){return B.flatMap((B=>[B.x,B.y,B.z]))}static GetPointsCountInfo(B){const E=new Array(B.length);let v=0;for(let z=B.length;z--;)E[z]=B[z].length/3,v+=E[z];return{total:v,counts:E}}static GetLineLength(B){if(0===B.length)return 0;let E;E="number"===typeof B[0]?fB.ToVector3Array(B):B;const v=z.TmpVectors.GE[0];let o=0;for(let z=0;z<E.length-1;z++){const B=E[z];o+=E[z+1].subtractToRef(B,v).length()}return o}static GetLineLengthArray(B){const E=new Float32Array(B.length/3);let v=0;for(let z=0,o=B.length/3-1;z<o;z++){let o=B[3*z+0],q=B[3*z+1],c=B[3*z+2];o-=B[3*z+3],q-=B[3*z+4],c-=B[3*z+5];v+=Math.sqrt(o*o+q*q+c*c),E[z+1]=v}return E}static SegmentizeSegmentByCount(B,E,v){const o=[],q=E.YE(B),c=z.TmpVectors.GE[0];c.mc(v);const S=z.TmpVectors.GE[1];q.divideToRef(c,S);let x=B.clone();o.push(x);for(let z=0;z<v;z++)x=x.clone(),o.push(x.addInPlace(S));return o}static SegmentizeLineBySegmentLength(B,E){const v=B[0]instanceof z.GE?fB.GetLineSegments(B):"number"===typeof B[0]?fB.GetLineSegments(fB.ToVector3Array(B)):B,o=[];for(const z of v)if(z.length>E){const B=fB.SegmentizeSegmentByCount(z.point1,z.point2,Math.ceil(z.length/E));for(const E of B)o.push(E)}else o.push(z.point1),o.push(z.point2);return o}static SegmentizeLineBySegmentCount(B,E){const v="number"===typeof B[0]?fB.ToVector3Array(B):B,z=fB.GetLineLength(v)/E;return fB.SegmentizeLineBySegmentLength(v,z)}static GetLineSegments(B){const E=[];for(let v=0;v<B.length-1;v++){const z=B[v],o=B[v+1],q=o.YE(z).length();E.push({point1:z,point2:o,length:q})}return E}static GetMinMaxSegmentLength(B){const E=fB.GetLineSegments(B).sort((B=>B.length));return{min:E[0].length,max:E[E.length-1].length}}static GetPositionOnLineByVisibility(B,E,v){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const q=E*v;let c=0,S=0;const x=B.length;for(let z=0;z<x;z++){if(q<=c+B[z].length){S=z;break}c+=B[z].length}const D=(q-c)/B[S].length;return B[S].point2.subtractToRef(B[S].point1,z.TmpVectors.GE[0]),z.TmpVectors.GE[1]=z.TmpVectors.GE[0].multiplyByFloats(D,D,D),o||z.TmpVectors.GE[1].addInPlace(B[S].point1),z.TmpVectors.GE[1].clone()}static GetCircleLinePoints(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B,q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/E;const c=[];for(let S=0;S<=E;S++)c.push(new z.GE(Math.cos(S*q)*B,Math.sin(S*q)*o,v));return c}static GetBezierLinePoints(B,E,v,z){return KB.f.CreateQuadraticBezier(B,E,v,z).getPoints().flatMap((B=>[B.x,B.y,B.z]))}static GetArrowCap(B,E,v,z,o){let q=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,c=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[B.clone(),B.add(E.multiplyByFloats(v,v,v))],widths:[z,o,q,c]}}static GetPointsFromText(B,E,v,z){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,q=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const c=[],S=(0,CB.c)(B,E,v,z);for(const x of S){for(const B of x.paths){const E=[],v=B.getPoints();for(const B of v)E.push(B.x,B.y,o);c.push(E)}if(q)for(const B of x.holes){const E=[],v=B.getPoints();for(const B of v)E.push(B.x,B.y,o);c.push(E)}}return c}static Color3toRGBAUint8(B){const E=new Uint8Array(4*B.length);for(let v=0,z=0;v<B.length;v++)E[z++]=255*B[v].r,E[z++]=255*B[v].g,E[z++]=255*B[v].b,E[z++]=255;return E}static CreateColorsTexture(B,E,v,z){const o=z.getEngine().getCaps().maxTextureSize??1,q=E.length>o?o:E.length,c=Math.ceil(E.length/o);c>1&&(E=[...E,...Array(q*c-E.length).fill(E[0])]);const S=fB.Color3toRGBAUint8(E),x=new X.d(S,q,c,G.c.TEXTUREFORMAT_RGBA,z,!1,!0,v);return x.name=B,x}static PrepareEmptyColorsTexture(B){if(!IB.EmptyColorsTexture){const E=new Uint8Array(4);IB.EmptyColorsTexture=new X.d(E,1,1,G.c.TEXTUREFORMAT_RGBA,B,!1,!1,X.d.NEAREST_NEAREST),IB.EmptyColorsTexture.name="grlEmptyColorsTexture"}return IB.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var B;null===(B=IB.EmptyColorsTexture)||void 0===B||B.dispose(),IB.EmptyColorsTexture=null}static BooleanToNumber(B){return B?1:0}}class AB extends iB.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class lB extends rB.c{isCompatible(B){return!0}constructor(B,E,v){var o;v=v||{color:IB.DEFAULT_COLOR};const q=new AB;q.GREASED_LINE_HAS_COLOR=!!v.color&&!v.useColors,q.GREASED_LINE_SIZE_ATTENUATION=v.sizeAttenuation??!1,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===v.colorDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(E??B.rB()).useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=v.cameraFacing??!0,super(B,lB.GREASED_LINE_MATERIAL_NAME,200,q,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(o=v)||void 0===o?void 0:o.forceGLSL)||lB.ForceGLSL,this._scene=E??B.rB(),this._engine=this._scene.getEngine(),this._cameraFacing=v.cameraFacing??!0,this.visibility=v.visibility??1,this.useDash=v.useDash??!1,this.dashRatio=v.dashRatio??.5,this.dashOffset=v.dashOffset??0,this.width=v.width?v.width:v.sizeAttenuation?IB.DEFAULT_WIDTH_ATTENUATED:IB.DEFAULT_WIDTH,this._sizeAttenuation=v.sizeAttenuation??!1,this.colorMode=v.colorMode??0,this._color=v.color??null,this.useColors=v.useColors??!1,this._colorsDistributionType=v.colorDistributionType??0,this.colorsSampling=v.colorsSampling??X.d.NEAREST_NEAREST,this._colors=v.KB??null,this.dashCount=v.dashCount??1,this.resolution=v.resolution??new z.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),v.colorsTexture?this.colorsTexture=v.colorsTexture:this._colors?this.colorsTexture=fB.CreateColorsTexture(`${B.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??IB.DEFAULT_COLOR,fB.PrepareEmptyColorsTexture(this._scene)),this._engine.eq.add((()=>{fB.DisposeEmptyColorsTexture()}))}getAttributes(B){B.push("grl_offsets"),B.push("grl_widths"),B.push("grl_colorPointers"),B.push("grl_counters"),this._cameraFacing?(B.push("grl_previousAndSide"),B.push("grl_nextAndCounters")):B.push("grl_slopes")}getSamplers(B){B.push("grl_colors")}getActiveTextures(B){this.colorsTexture&&B.push(this.colorsTexture)}getUniforms(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&E.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===B&&E.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:E,vertex:this._cameraFacing&&this._isGLSL(B)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(B)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(B){if(this._cameraFacing){B.hc("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||B.hc("viewProjection",this._scene.getTransformMatrix());const E=z.TmpVectors.Vector4[0];E.x=this._aspect,E.y=this._resolution.x,E.z=this._resolution.y,E.w=this.width,B.updateVector4("grl_aspect_resolution_lineWidth",E)}const E=z.TmpVectors.Vector4[0];E.x=fB.BooleanToNumber(this.useDash),E.y=this._dashArray,E.z=this.dashOffset,E.w=this.dashRatio,B.updateVector4("grl_dashOptions",E);const v=z.TmpVectors.Vector4[1];v.x=this.colorMode,v.y=this.visibility,v.z=this.colorsTexture?this.colorsTexture.getSize().width:0,v.w=fB.BooleanToNumber(this.useColors),B.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",v),this._color&&B.updateColor3("grl_singleColor",this._color);const o=this.colorsTexture??IB.EmptyColorsTexture;B.setTexture("grl_colors",o),B.updateFloat2("grl_textureSize",(null===o||void 0===o?void 0:o.getSize().width)??1,(null===o||void 0===o?void 0:o.getSize().height)??1)}prepareDefines(B,E,v){B.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,B.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=E.useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=this._cameraFacing,B.GREASED_LINE_USE_OFFSETS=!!v.offsets}getClassName(){return lB.GREASED_LINE_MATERIAL_NAME}getCustomCode(B){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(E)?function(B,E){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return E&&(B["!gl_Position\\=viewProjection\\*worldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(B,this._cameraFacing):function(B,E){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return E&&(B["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(B,this._cameraFacing)}dispose(){var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),super.dispose()}get KB(){return this._colors}set KB(B){this.setColors(B)}setColors(B){var E;let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var q;if(this._colors=B,null!==B&&0!==B.length){if(!v||z)if(this.colorsTexture&&o===B.length&&!z){const E=fB.Color3toRGBAUint8(B);this.colorsTexture.update(E)}else{var c;null===(c=this.colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=fB.CreateColorsTexture(`${this._material.name}-colors-texture`,B,this.colorsSampling,this._scene)}}else null===(q=this.colorsTexture)||void 0===q||q.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.markAllDefinesAsDirty()}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==B||null!==this._color&&null===B?(this._color=B,E||this.markAllDefinesAsDirty()):this._color=B}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(B){this._aspect=B.x/B.y,this._resolution=B}serialize(){const B=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(E.KB=this._colors),this._color&&(E.color=this._color),B.greasedLineMaterialOptions=E,B}parse(B,E,v){var z;super.parse(B,E,v);const o=B.greasedLineMaterialOptions;null===(z=this.colorsTexture)||void 0===z||z.dispose(),o.color&&this.setColor(o.color,!0),o.colorDistributionType&&(this.colorsDistributionType=o.colorDistributionType),o.KB&&(this.KB=o.KB),o.colorsSampling&&(this.colorsSampling=o.colorsSampling),o.colorMode&&(this.colorMode=o.colorMode),o.useColors&&(this.useColors=o.useColors),o.visibility&&(this.visibility=o.visibility),o.useDash&&(this.useDash=o.useDash),o.dashCount&&(this.dashCount=o.dashCount),o.dashRatio&&(this.dashRatio=o.dashRatio),o.dashOffset&&(this.dashOffset=o.dashOffset),o.width&&(this.width=o.width),o.sizeAttenuation&&(this.sizeAttenuation=o.sizeAttenuation),o.resolution&&(this.resolution=o.resolution),this.KB?this.colorsTexture=fB.CreateColorsTexture(`${this._material.name}-colors-texture`,this.KB,this.colorsSampling,E):fB.PrepareEmptyColorsTexture(E),this.markAllDefinesAsDirty()}copyTo(B){var E;const v=B;null===(E=v.colorsTexture)||void 0===E||E.dispose(),this._colors&&(v.colorsTexture=fB.CreateColorsTexture(`${v._material.name}-colors-texture`,this._colors,v.colorsSampling,this._scene)),v.setColor(this.color,!0),v.colorsDistributionType=this.colorsDistributionType,v.colorsSampling=this.colorsSampling,v.colorMode=this.colorMode,v.useColors=this.useColors,v.visibility=this.visibility,v.useDash=this.useDash,v.dashCount=this.dashCount,v.dashRatio=this.dashRatio,v.dashOffset=this.dashOffset,v.width=this.width,v.sizeAttenuation=this.sizeAttenuation,v.resolution=this.resolution,v.markAllDefinesAsDirty()}_isGLSL(B){return 0===B||this._forceGLSL}}lB.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",lB.ForceGLSL=!1,(0,uB.f)(`BABYLON.${lB.GREASED_LINE_MATERIAL_NAME}`,lB);var dB=v(11822),tB=v(11222),pB=v(11599),HB=v(11331);class jB extends pB.ShaderMaterial{constructor(B,E,o){const q=E.getEngine(),c=q.isWebGPU&&!(o.forceGLSL||jB.ForceGLSL),S=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];E.useRightHandedSystem&&S.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const x=["position","grl_widths","grl_offsets","grl_colorPointers"];o.cameraFacing?(S.push("GREASED_LINE_CAMERA_FACING"),x.push("grl_previousAndSide","grl_nextAndCounters")):(x.push("grl_slopes"),x.push("grl_counters"));const D=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(c||D.push("world","viewProjection","view","projection"),super(B,E,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:c?["Scene","Mesh"]:void 0,attributes:x,uniforms:D,samplers:c?[]:["grlColors"],defines:S,extraInitializationsAsync:async()=>{c?await Promise.all([v.e(66).then(v.bind(v,14488)),v.e(75).then(v.bind(v,14493))]):await Promise.all([v.e(69).then(v.bind(v,14495)),v.e(76).then(v.bind(v,14497))])},shaderLanguage:c?1:0}),this._color=a.gE.White(),this._colorsDistributionType=0,this._colorsTexture=null,o=o||{color:IB.DEFAULT_COLOR},this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.dashCount=o.dashCount??1,this.width=o.width?o.width:o.sizeAttenuation&&o.cameraFacing?IB.DEFAULT_WIDTH_ATTENUATED:IB.DEFAULT_WIDTH,this.sizeAttenuation=o.sizeAttenuation??!1,this.color=o.color??a.gE.White(),this.useColors=o.useColors??!1,this.colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??X.d.NEAREST_NEAREST,this.colorMode=o.colorMode??0,this._colors=o.KB??null,this._cameraFacing=o.cameraFacing??!0,this.resolution=o.resolution??new z.Vector2(q.getRenderWidth(),q.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=fB.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,E):(this._color=this._color??IB.DEFAULT_COLOR,this.colorsTexture=fB.PrepareEmptyColorsTexture(E)),c){const B=new HB.d;B.setParameters(),B.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",B)}q.eq.add((()=>{fB.DisposeEmptyColorsTexture()}))}dispose(){var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new z.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get KB(){return this._colors}set KB(B){this.setColors(B)}setColors(B){var E;let v=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var q;if(this._colors=B,null!==B&&0!==B.length){if(!v||z)if(this._colorsTexture&&o===B.length&&!z){const E=fB.Color3toRGBAUint8(B);this._colorsTexture.update(E)}else{var c;null===(c=this._colorsTexture)||void 0===c||c.dispose(),this.colorsTexture=fB.CreateColorsTexture(`${this.name}-colors-texture`,B,this.colorsSampling,this.rB())}}else null===(q=this._colorsTexture)||void 0===q||q.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(B){this._colorsTexture=B,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(B){this._width=B,this.setFloat("grlWidth",B)}get useColors(){return this._useColors}set useColors(B){this._useColors=B,this.setFloat("grlUseColors",fB.BooleanToNumber(B))}get colorsSampling(){return this._colorsSampling}set colorsSampling(B){this._colorsSampling=B}get visibility(){return this._visibility}set visibility(B){this._visibility=B,this.setFloat("grlVisibility",B)}get useDash(){return this._useDash}set useDash(B){this._useDash=B,this.setFloat("grlUseDash",fB.BooleanToNumber(B))}get dashOffset(){return this._dashOffset}set dashOffset(B){this._dashOffset=B,this.setFloat("grlDashOffset",B)}get dashRatio(){return this._dashRatio}set dashRatio(B){this._dashRatio=B,this.setFloat("grlDashRatio",B)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.setFloat("grlSizeAttenuation",fB.BooleanToNumber(B))}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){B=B??IB.DEFAULT_COLOR,this._color=B,this.setColor3("grlColor",B)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(B){this._colorMode=B,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(B){this._resolution=B,this.setVector2("grlResolution",B),this.setFloat("grlAspect",B.x/B.y)}serialize(){const B=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(E.KB=this._colors),B.greasedLineMaterialOptions=E,B}parse(B,E,v){var z;const o=B.greasedLineMaterialOptions;null===(z=this._colorsTexture)||void 0===z||z.dispose(),o.color&&(this.color=o.color),o.colorDistributionType&&(this.colorsDistributionType=o.colorDistributionType),o.colorsSampling&&(this.colorsSampling=o.colorsSampling),o.colorMode&&(this.colorMode=o.colorMode),o.useColors&&(this.useColors=o.useColors),o.visibility&&(this.visibility=o.visibility),o.useDash&&(this.useDash=o.useDash),o.dashCount&&(this.dashCount=o.dashCount),o.dashRatio&&(this.dashRatio=o.dashRatio),o.dashOffset&&(this.dashOffset=o.dashOffset),o.width&&(this.width=o.width),o.sizeAttenuation&&(this.sizeAttenuation=o.sizeAttenuation),o.resolution&&(this.resolution=o.resolution),o.KB?this.colorsTexture=fB.CreateColorsTexture(`${this.name}-colors-texture`,o.KB,this.colorsSampling,this.rB()):this.colorsTexture=fB.PrepareEmptyColorsTexture(E),this._cameraFacing=o.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var RB,bB,FB;jB.ForceGLSL=!1,function(B){B[B.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",B[B.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(RB||(RB={})),function(B){B[B.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",B[B.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",B[B.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(bB||(bB={})),function(B){B[B.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",B[B.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",B[B.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",B[B.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",B[B.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(FB||(FB={}));class WB extends gB.e{constructor(B,E,v){super(B,E,null,null,!1,!1),this.name=B,this._options=v,this._lazy=!1,this._updatable=!1,this._engine=E.getEngine(),this._lazy=v.lazy??!1,this._updatable=v.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=v.colorPointers??[],this._widths=v.widths??new Array(v.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(B){let E=0;for(const z of this._points)E+=z.length;const v=E/3*2-this._widths.length;for(let z=0;z<v;z++)this._widths.push(B)}updateLazy(){var B,E;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(B=this._options.ribbonOptions)||void 0===B?void 0:B.smoothShading),!this.lB&&this.refreshBoundingInfo(),null===(E=this.greasedLineMaterial)||void 0===E||E.updateLazy()}addPoints(B,E){for(const v of B)this._points.push(v);this._lazy||this.setPoints(this._points,E)}dispose(B){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(B,E)}isLazy(){return this._lazy}get CB(){return this._uvs}set CB(B){this._uvs=B instanceof Float32Array?B:new Float32Array(B),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(B){this.material instanceof jB&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===B||void 0===B?void 0:B.length)>0),this._offsets=B,this._offsetsBuffer?this._offsetsBuffer.update(B):this._createOffsetsBuffer(B)}get widths(){return this._widths}set widths(B){this._widths=B,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(B)}get colorPointers(){return this._colorPointers}set colorPointers(B){this._colorPointers=B,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(B)}get greasedLineMaterial(){var B,E;if(this.material&&this.material instanceof jB)return this.material;const v=null===(B=this.material)||void 0===B||null===(E=B.pluginManager)||void 0===E?void 0:E.getPlugin(lB.GREASED_LINE_MATERIAL_NAME);return v||void 0}get points(){const B=[];return tB.d.DeepCopy(this._points,B),B}setPoints(B,E){this._points=fB.ConvertPoints(B,(null===E||void 0===E?void 0:E.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==E&&void 0!==E&&E.colorPointers||this._updateColorPointers(),this._setPoints(this._points,E)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,CB:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(B){super.serialize(B),B.type=this.getClassName(),B.lineOptions=this._createLineOptions()}_createVertexBuffers(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new dB.c;return E.uB=this._vertexPositions,E.indices=this._indices,E.CB=this._uvs,B&&(E.IB=[],dB.c.ComputeNormals(this._vertexPositions,this._indices,E.IB)),E.AB(this,this._options.updatable),E}_createOffsetsBuffer(B){const E=this._scene.getEngine(),v=new h.d(E,B,this._updatable,3);this.setVerticesBuffer(v.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=v}}class wB{constructor(B,E){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=B,this.wasAddedByNoopNode=E}getIndicesAccessor(B,E,v,z,o){var q,c,S,x;return null===(q=this._indicesAccessorMap.get(B))||void 0===q||null===(c=q.get(E))||void 0===c||null===(S=c.get(v))||void 0===S||null===(x=S.get(z))||void 0===x?void 0:x.get(o)}setIndicesAccessor(B,E,v,z,o,q){let c=this._indicesAccessorMap.get(B);c||(c=new Map,this._indicesAccessorMap.set(B,c));let S=c.get(E);S||(S=new Map,c.set(E,S));let x=S.get(v);x||(x=new Map,S.set(v,x));let D=x.get(z);D||(D=new Map,x.set(z,D)),D.set(o,q)}pushExportedNode(B){this._exportedNodes.has(B)||this._exportedNodes.add(B)}getNodesSet(){return this._exportedNodes}getVertexBufferView(B){return this._vertexBufferViewMap.get(B)}setVertexBufferView(B,E){this._vertexBufferViewMap.set(B,E)}setRemappedBufferView(B,E,v){this._remappedBufferView.set(B,new Map),this._remappedBufferView.get(B).set(E,v)}getRemappedBufferView(B,E){var v;return null===(v=this._remappedBufferView.get(B))||void 0===v?void 0:v.get(E)}getVertexAccessor(B,E,v){var z,o;return null===(z=this._vertexAccessorMap.get(B))||void 0===z||null===(o=z.get(E))||void 0===o?void 0:o.get(v)}setVertexAccessor(B,E,v,z){let o=this._vertexAccessorMap.get(B);o||(o=new Map,this._vertexAccessorMap.set(B,o));let q=o.get(E);q||(q=new Map,o.set(E,q)),q.set(v,z)}hasVertexColorAlpha(B){return this._vertexMapColorAlpha.get(B)||!1}setHasVertexColorAlpha(B,E){return this._vertexMapColorAlpha.set(B,E)}getMesh(B){return this._meshMap.get(B)}setMesh(B,E){this._meshMap.set(B,E)}bindMorphDataToMesh(B,E){const v=this._meshMorphTargetMap.get(B)||[];this._meshMorphTargetMap.set(B,v),-1===v.indexOf(E)&&v.push(E)}getMorphTargetsFromMesh(B){return this._meshMorphTargetMap.get(B)}}class nB{_ApplyExtension(B,E,v,z){if(v>=E.length)return Promise.resolve(B);const o=z(E[v],B);return o?o.then((async B=>B?await this._ApplyExtension(B,E,v+1,z):null)):this._ApplyExtension(B,E,v+1,z)}_ApplyExtensions(B,E){const v=[];for(const z of nB._ExtensionNames)v.push(this._extensions[z]);return this._ApplyExtension(B,v,0,E)}_extensionsPreExportTextureAsync(B,E,v){return this._ApplyExtensions(E,((E,z)=>E.preExportTextureAsync&&E.preExportTextureAsync(B,z,v)))}_extensionsPostExportNodeAsync(B,E,v,z,o){return this._ApplyExtensions(E,((E,q)=>E.postExportNodeAsync&&E.postExportNodeAsync(B,q,v,z,o,this._bufferManager)))}_extensionsPostExportMaterialAsync(B,E,v){return this._ApplyExtensions(E,((E,z)=>E.postExportMaterialAsync&&E.postExportMaterialAsync(B,z,v)))}_extensionsPostExportMaterialAdditionalTextures(B,E,v){const z=[];for(const o of nB._ExtensionNames){const q=this._extensions[o];q.postExportMaterialAdditionalTextures&&z.push(...q.postExportMaterialAdditionalTextures(B,E,v))}return z}_extensionsPostExportTextures(B,E,v){for(const z of nB._ExtensionNames){const o=this._extensions[z];o.postExportTexture&&o.postExportTexture(B,E,v)}}_extensionsPostExportMeshPrimitive(B){for(const E of nB._ExtensionNames){const v=this._extensions[E];v.postExportMeshPrimitive&&v.postExportMeshPrimitive(B,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const B of nB._ExtensionNames){const E=this._extensions[B];E.preGenerateBinaryAsync&&await E.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(B){for(const E of nB._ExtensionNames){const v=this._extensions[E];v.enabled&&B(v)}}_extensionsOnExporting(){this._forEachExtensions((B=>{var E,v,z;B.wasUsed&&((E=this._glTF).extensionsUsed||(E.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(B.name)&&this._glTF.extensionsUsed.push(B.name),B.required&&((v=this._glTF).extensionsRequired||(v.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(B.name)&&this._glTF.extensionsRequired.push(B.name)),(z=this._glTF).extensions||(z.extensions={}),B.onExporting&&B.onExporting())}))}_loadExtensions(){for(const B of nB._ExtensionNames){const E=nB._ExtensionFactories[B](this);this._extensions[B]=E}}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Y.b.LastCreatedScene,E=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${G.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new H(this),this._extensions={},this._bufferManager=new hB,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!B)throw new Error("No scene available to export");this._babylonScene=B,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:B=>{var E;return null===B||void 0===B||null===(E=B.vc)||void 0===E?void 0:E.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...E},this._loadExtensions()}dispose(){for(const B in this._extensions){this._extensions[B].dispose()}}get options(){return this._options}static RegisterExtension(B,E){nB.UnregisterExtension(B)&&o.Tools.Warn(`Extension with the name ${B} already exists`),nB._ExtensionFactories[B]=E,nB._ExtensionNames.push(B)}static UnregisterExtension(B){if(!nB._ExtensionFactories[B])return!1;delete nB._ExtensionFactories[B];const E=nB._ExtensionNames.indexOf(B);return-1!==E&&nB._ExtensionNames.splice(E,1),!0}_generateJSON(B,E,v){const z={byteLength:B};return z.byteLength&&(this._glTF.buffers=[z]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.aE=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(z.uri=E+".bin"),v?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(B){const E=await this._generateBinaryAsync();this._extensionsOnExporting();const v=this._generateJSON(E.byteLength,B,!0),z=new Blob([E],{type:"application/octet-stream"}),o=B+".gltf",q=B+".bin",c=new D;if(c.files[o]=v,c.files[q]=z,this._imageData)for(const S in this._imageData)c.files[S]=new Blob([this._imageData[S].data],{type:this._imageData[S].mimeType});return c}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(B){const E=B%4;return 0===E?E:4-E}async generateGLBAsync(B){this._shouldUseGlb=!0;const E=await this._generateBinaryAsync();this._extensionsOnExporting();const v=this._generateJSON(E.byteLength),z=B+".glb";let o,q=v.length;if("undefined"!==typeof TextEncoder){o=(new TextEncoder).encode(v),q=o.length}const c=this._getPadding(q),S=this._getPadding(E.byteLength),x=28+q+c+E.byteLength+S,h=new xB(x);if(h.writeUInt32(1179937895),h.writeUInt32(2),h.writeUInt32(x),h.writeUInt32(q+c),h.writeUInt32(1313821514),o)h.writeTypedArray(o);else{const B="_".charCodeAt(0);for(let E=0;E<q;++E){const z=v.charCodeAt(E);z!=v.codePointAt(E)?h.writeUInt8(B):h.writeUInt8(z)}}for(let D=0;D<c;++D)h.writeUInt8(32);h.writeUInt32(E.byteLength+S),h.writeUInt32(5130562),h.writeTypedArray(E);for(let D=0;D<S;++D)h.writeUInt8(0);const y=new D;return y.files[z]=new Blob([h.getOutputData()],{type:"application/octet-stream"}),y}_setNodeTransformation(B,E,v){if(E.getPivotPoint().equalsWithEpsilon(W,F.e)||o.Tools.Warn("Pivot points are not supported in the glTF serializer"),!E.position.equalsWithEpsilon(W,F.e)){const o=z.TmpVectors.GE[0].S(E.position);v&&L(o),B.translation=o.cc()}E.ac.equalsWithEpsilon(n,F.e)||(B.scale=E.ac.cc());const q=E.rotationQuaternion||z.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);q.equalsWithEpsilon(w,F.e)||(v&&M(q),B.rotation=q.normalize().cc())}_setCameraTransformation(B,E,v){if(!E.position.equalsWithEpsilon(W,F.e)){const o=z.TmpVectors.GE[0].S(E.position);v&&L(o),B.translation=o.cc()}const o=E.rotationQuaternion||z.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);v&&M(o),this._babylonScene.useRightHandedSystem||Z(o),o.equalsWithEpsilon(w,F.e)||(B.rotation=o.cc())}_listAvailableCameras(){for(const B of this._babylonScene.cameras){const E={type:B.mode===QB.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(B.name&&(E.name=B.name),"perspective"===E.type)E.perspective={aspectRatio:B.getEngine().getAspectRatio(B),yfov:B.fovMode===QB.c.FOVMODE_VERTICAL_FIXED?B.fov:B.fov*B.getEngine().getAspectRatio(B),znear:B.xc,zfar:B.maxZ};else if("orthographic"===E.type){const v=B.orthoLeft&&B.orthoRight?.5*(B.orthoRight-B.orthoLeft):.5*B.getEngine().getRenderWidth(),z=B.orthoBottom&&B.orthoTop?.5*(B.orthoTop-B.orthoBottom):.5*B.getEngine().getRenderHeight();E.orthographic={xmag:v,ymag:z,znear:B.xc,zfar:B.maxZ}}this._camerasMap.set(B,E)}}_exportAndAssignCameras(){const B=Array.from(this._camerasMap.values());for(const E of B){const B=this._nodesCameraMap.get(E);if(void 0!==B){this._cameras.push(E);for(const E of B)E.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const E={joints:[]};this._skinMap.set(B,E)}}_exportAndAssignSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const E=this._skinMap.get(B);if(void 0==E)continue;const v={},z=[];let q=-1;for(let o=0;o<B.bones.length;++o){const E=B.bones[o],z=E.getIndex()??o;-1!==z&&(v[z]=E,z>q&&(q=z))}for(let B=0;B<=q;++B){const q=v[B];z.push(q.getAbsoluteInverseBindMatrix());const c=q.getTransformNode();if(null!==c){const B=this._nodeMap.get(c);c&&null!==B&&void 0!==B?E.joints.push(B):o.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else o.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const c=this._nodesSkinMap.get(E);if(E.joints.length>0&&void 0!==c){const B=64*z.length,v=new Float32Array(B/4);z.forEach(((B,E)=>{v.set(B.m,16*E)}));const o=this._bufferManager.createBufferView(v);this._accessors.push(this._bufferManager.createAccessor(o,"MAT4",5126,z.length)),E.inverseBindMatrices=this._accessors.length-1,this._skins.push(E);for(const E of c)E.skin=this._skins.length-1}}}async _exportSceneAsync(){const B={nodes:[]};if(this._babylonScene.metadata){const E=this._options.metadataSelector(this._babylonScene.metadata);E&&(B.extras=E)}const E=new Array,v=new Array,z=new Array;for(const S of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&cB(S,this._babylonScene.useRightHandedSystem)?z.push(...S.getChildren()):this._babylonScene.useRightHandedSystem?E.push(S):v.push(S);this._listAvailableCameras(),this._listAvailableSkeletons();const o=new wB(!0,!1);B.nodes.push(...await this._exportNodesAsync(v,o));const q=new wB(!1,!1);B.nodes.push(...await this._exportNodesAsync(E,q));const c=new wB(!1,!0);B.nodes.push(...await this._exportNodesAsync(z,c)),B.nodes.length&&this._scenes.push(B),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&TB._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(B){let E=this._shouldExportNodeMap.get(B);return void 0===E&&(E=this._options.shouldExportNode(B),this._shouldExportNodeMap.set(B,E)),E}async _exportNodesAsync(B,E){const v=new Array;this._exportBuffers(B,E);for(const z of B)await this._exportNodeAsync(z,v,E);return v}_collectBuffers(B,E,v,z,o){if(this._shouldExportNode(B)&&B instanceof Q.e&&B.Qc){const q=B.Qc.getVertexBuffers();if(q)for(const z in q){if(!O(z))continue;const c=q[z];o.setHasVertexColorAlpha(c,B.hasVertexAlpha);const S=c._buffer,x=E.get(S)||[];E.set(S,x),-1===x.indexOf(c)&&x.push(c);const D=v.get(c)||[];v.set(c,D),-1===D.indexOf(B)&&D.push(B)}const c=B.morphTargetManager;if(c)for(let E=0;E<c.numTargets;E++){const v=c.getTarget(E),o=z.get(v)||[];z.set(v,o),-1===o.indexOf(B)&&o.push(B)}}for(const q of B.getChildren())this._collectBuffers(q,E,v,z,o)}_exportBuffers(B,E){const v=new Map,z=new Map,o=new Map;for(const S of B)this._collectBuffers(S,v,z,o,E);const q=Array.from(v.keys());for(const S of q){const B=S.getData();if(!B)throw new Error("Buffer data is not available");const o=v.get(S);if(!o)continue;const q=o[0].byteStride;if(o.some((B=>B.byteStride!==q)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const c=vB(B).slice();for(const E of o){const B=z.get(E),{byteOffset:v,byteStride:o,componentCount:q,type:S,count:x,normalized:D,kind:y}=s(E,B);switch(y){case h.e.NormalKind:case h.e.TangentKind:(0,j.i)(c,v,o,q,S,x,D,(B=>{const E=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);if(E>0){const v=1/E;B[0]*=v,B[1]*=v,B[2]*=v}}));break;case h.e.ColorKind:{const E=B.filter((B=>B.material instanceof YB.mE||null==B.material)).length;if(0==E)break;if(E!=B.length){R.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}S==h.e.UNSIGNED_BYTE&&R.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const z=new a.gE,y=new a.gc,Q=this._babylonScene.getEngine().useExactSrgbConversions;(0,j.i)(c,v,o,q,S,x,D,(B=>{3===B.length?(z.Qv(B,0),z.toLinearSpaceToRef(z,Q),z.toArray(B,0)):(y.Qv(B,0),y.toLinearSpaceToRef(y,Q),y.toArray(B,0))}))}}}if(E.convertToRightHanded){for(const B of o){const E=z.get(B),{byteOffset:v,byteStride:o,componentCount:q,type:S,count:x,normalized:D,kind:y}=s(B,E);switch(y){case h.e.PositionKind:case h.e.NormalKind:case h.e.TangentKind:(0,j.i)(c,v,o,q,S,x,D,(B=>{B[0]=-B[0]}))}}E.convertedToRightHandedBuffers.set(S,c)}const x=this._bufferManager.createBufferView(c,q);E.setVertexBufferView(S,x);const D=new Map;for(const E of o){const B=z.get(E),{kind:v,totalVertices:o}=s(E,B);switch(v){case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:if(E.type==h.e.FLOAT){const B=E.getFloatData(o);null!==B&&D.set(E,B)}}}0!==D.size&&R.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const y=Array.from(D.keys());for(const v of y){const B=D.get(v);if(!B)continue;const z=B.some((B=>B>=256)),o=new(z?Uint16Array:Uint8Array)(B.length);for(let E=0;E<B.length;E++)o[E]=B[E];const q=this._bufferManager.createBufferView(o,4*(z?2:1));E.setRemappedBufferView(S,v,q)}}const c=Array.from(o.keys());for(const S of c){const B=o.get(S);if(!B)continue;const v=NB(S,B[0],this._bufferManager,this._bufferViews,this._accessors,E.convertToRightHanded);for(const z of B)E.bindMorphDataToMesh(z,v)}}async _exportNodeAsync(B,E,v){let z=this._nodeMap.get(B);if(void 0!==z)return void(E.includes(z)||E.push(z));const o=await this._createNodeAsync(B,v);if(o){z=this._nodes.length,this._nodes.push(o),this._nodeMap.set(B,z),v.pushExportedNode(B),E.push(z);const q={name:"runtime animations",channels:[],samplers:[]},c=[];this._babylonScene.animationGroups.length||(TB._CreateMorphTargetAnimationFromMorphTargetAnimations(B,q,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,v.convertToRightHanded,this._options.shouldExportAnimation),B.animations.length&&TB._CreateNodeAnimationFromNodeAnimations(B,q,c,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,v.convertToRightHanded,this._options.shouldExportAnimation)),q.channels.length&&q.samplers.length&&this._animations.push(q),c.forEach((B=>{B.channels.length&&B.samplers.length&&this._animations.push(B)}))}const q=o?[]:E;for(const c of B.getChildren())await this._exportNodeAsync(c,q,v);o&&q.length&&(o.children=q)}async _createNodeAsync(B,E){if(!this._shouldExportNode(B))return null;const v={};if(B.name&&(v.name=B.name),B.metadata){const E=this._options.metadataSelector(B.metadata);E&&(v.extras=E)}if(B instanceof y.e&&(this._setNodeTransformation(v,B,E.convertToRightHanded),B instanceof Q.e)){const o=B instanceof P.b?B.sourceMesh:B;if(o.qc&&o.qc.length>0&&(v.mesh=await this._exportMeshAsync(o,E)),B.skeleton){const E=this._skinMap.get(B.skeleton);var z;if(void 0!==E)void 0===this._nodesSkinMap.get(E)&&this._nodesSkinMap.set(E,[]),null===(z=this._nodesSkinMap.get(E))||void 0===z||z.push(v)}}if(B instanceof b.d){const z=this._camerasMap.get(B);if(z){var o;void 0===this._nodesCameraMap.get(z)&&this._nodesCameraMap.set(z,[]),this._setCameraTransformation(v,B,E.convertToRightHanded);const c=B.parent;if(null!==c&&EB(B,c)){const B=this._nodeMap.get(c);if(void 0!==B){var q;const E=this._nodes[B];return BB(v,E),null===(q=this._nodesCameraMap.get(z))||void 0===q||q.push(E),null}}null===(o=this._nodesCameraMap.get(z))||void 0===o||o.push(v)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",v,B,this._nodeMap,E.convertToRightHanded)?v:(R.c.Warn(`Not exporting node ${B.name}`),null)}_exportIndices(B,E,v,z,o,c,S,x,D){let h=B;D.mode=e(c);const y=S!==q.c.CounterClockWiseSideOrientation,Q=!x.wasAddedByNoopNode&&y,P=function(B){switch(B){case q.c.TriangleFillMode:case q.c.TriangleStripDrawMode:case q.c.TriangleFanDrawMode:return!0}return!1}(c)&&Q;if(P){if(c===q.c.TriangleStripDrawMode||c===q.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");D.mode=e(c);const S=E?new Uint32Array(z):new Uint16Array(z);if(B)for(let E=0;E+2<z;E+=3)S[E]=B[v+E]+o,S[E+1]=B[v+E+2]+o,S[E+2]=B[v+E+1]+o;else for(let B=0;B+2<z;B+=3)S[B]=B,S[B+1]=B+2,S[B+2]=B+1;h=S}else if(B&&0!==o){const q=E?new Uint32Array(z):new Uint16Array(z);for(let E=0;E<z;E++)q[E]=B[v+E]+o;h=q}if(h){let q=x.getIndicesAccessor(B,v,z,o,P);if(void 0===q){const c=function(B,E,v,z){if(B instanceof Uint16Array||B instanceof Uint32Array)return B;if(B instanceof Int32Array)return new Uint32Array(B.buffer,B.byteOffset,B.length);const o=B.slice(E,E+v);return z?new Uint32Array(o):new Uint16Array(o)}(h,0,z,E),S=this._bufferManager.createBufferView(c),D=E?5125:5123;this._accessors.push(this._bufferManager.createAccessor(S,"SCALAR",D,z,0)),q=this._accessors.length-1,x.setIndicesAccessor(B,v,z,o,P,q)}D.indices=q}}_exportVertexBuffer(B,E,v,z,o,q){const c=B.getKind();if(!O(c))return;if(c.startsWith("uv")&&!this._options.exportUnusedUVs&&(!E||!this._materialNeedsUVsSet.has(E)))return;let S=o.getVertexAccessor(B,v,z);if(void 0===S){const E=o.convertedToRightHandedBuffers.get(B._buffer)||B._buffer.getData(),q=c===h.e.PositionKind?function(B,E,v,z){const{byteOffset:o,byteStride:q,type:c,normalized:S}=E,x=E.getSize(),D=new Array(x).fill(1/0),h=new Array(x).fill(-1/0);return(0,j.i)(B,o+v*q,q,x,c,z*x,S,(B=>{for(let E=0;E<x;E++)D[E]=Math.min(D[E],B[E]),h[E]=Math.max(h[E],B[E])})),{min:D,max:h}}(E,B,v,z):void 0,x=(c===h.e.MatricesIndicesKind||c===h.e.MatricesIndicesExtraKind)&&B.type===h.e.FLOAT,D=x?h.e.UNSIGNED_BYTE:B.type,y=x?void 0:B.normalized,Q=x?o.getRemappedBufferView(B._buffer,B):o.getVertexBufferView(B._buffer),P=B.byteOffset+v*B.byteStride;this._accessors.push(this._bufferManager.createAccessor(Q,function(B,E){if(B==h.e.ColorKind)return E?"VEC4":"VEC3";switch(B){case h.e.PositionKind:case h.e.NormalKind:return"VEC3";case h.e.TangentKind:case h.e.MatricesIndicesKind:case h.e.MatricesIndicesExtraKind:case h.e.MatricesWeightsKind:case h.e.MatricesWeightsExtraKind:return"VEC4";case h.e.UVKind:case h.e.UV2Kind:case h.e.UV3Kind:case h.e.UV4Kind:case h.e.UV5Kind:case h.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${B}`)}(c,o.hasVertexColorAlpha(B)),D,z,P,q,y)),S=this._accessors.length-1,o.setVertexAccessor(B,v,z,S)}q.attributes[function(B){switch(B){case h.e.PositionKind:return"POSITION";case h.e.NormalKind:return"NORMAL";case h.e.TangentKind:return"TANGENT";case h.e.ColorKind:return"COLOR_0";case h.e.UVKind:return"TEXCOORD_0";case h.e.UV2Kind:return"TEXCOORD_1";case h.e.UV3Kind:return"TEXCOORD_2";case h.e.UV4Kind:return"TEXCOORD_3";case h.e.UV5Kind:return"TEXCOORD_4";case h.e.UV6Kind:return"TEXCOORD_5";case h.e.MatricesIndicesKind:return"JOINTS_0";case h.e.MatricesIndicesExtraKind:return"JOINTS_1";case h.e.MatricesWeightsKind:return"WEIGHTS_0";case h.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${B}`)}(c)]=S}async _exportMaterialAsync(B,E,v,z){let o=this._materialMap.get(B);if(void 0===o){const z=E&&Object.keys(E).some((B=>B.startsWith("uv")));if((B=B instanceof PB.e?B.Vc[v.materialIndex]:B)instanceof GB.c)o=await this._materialExporter.exportPBRMaterialAsync(B,"image/png",z);else{if(!(B instanceof YB.mE))return void R.c.Warn(`Unsupported material '${B.name}' with type ${B.getClassName()}`);o=await this._materialExporter.exportStandardMaterialAsync(B,"image/png",z)}this._materialMap.set(B,o)}z.material=o}async _exportMeshAsync(B,E){var v;let z=E.getMesh(B);if(void 0!==z)return z;const o={primitives:[]};z=this._meshes.length,this._meshes.push(o),E.setMesh(B,z);const c=B.isUnIndexed?null:B.Pc(),S=null===(v=B.Qc)||void 0===v?void 0:v.getVertexBuffers(),x=E.getMorphTargetsFromMesh(B),D=B instanceof XB.b,h=B instanceof WB,y=B.qc;if(S&&y&&y.length>0)for(const G of y){const v={attributes:{}},z=G.HB()||this._babylonScene.defaultMaterial;if(h){var Q,P;const E={name:z.name},o=B,q=a.gE.White(),c=(null===(Q=o.material)||void 0===Q?void 0:Q.alpha)??1,S=(null===(P=o.greasedLineMaterial)||void 0===P?void 0:P.color)??q;(!S.equalsWithEpsilon(q,F.e)||c<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...S.cc(),c]}),this._materials.push(E),v.material=this._materials.length-1}else if(D){const E={name:z.name},o=B;(!o.color.equalsWithEpsilon(a.gE.White(),F.e)||o.alpha<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...o.color.cc(),o.alpha]}),this._materials.push(E),v.material=this._materials.length-1}else await this._exportMaterialAsync(z,S,G,v);const y=D||h?q.c.LineListDrawMode:B.overrideRenderingFillMode??z.fillMode,Y=z._getEffectiveOrientation(B);this._exportIndices(c,c?(0,j.c)(c,G.indexCount,G.indexStart,G.verticesStart):G.verticesCount>65535,c?G.indexStart:G.verticesStart,c?G.indexCount:G.verticesCount,-G.verticesStart,y,Y,E,v);for(const B of Object.values(S))this._exportVertexBuffer(B,z,G.verticesStart,G.verticesCount,E,v);if(x){v.targets=[];for(const B of x)v.targets.push(B.attributes)}o.primitives.push(v),this._extensionsPostExportMeshPrimitive(v)}if(x){o.weights=[],o.extras||(o.extras={}),o.extras.targetNames=[];for(const B of x)o.weights.push(B.influence),o.extras.targetNames.push(B.name)}return z}}nB._ExtensionNames=new Array,nB._ExtensionFactories={};class UB{static async GLTFAsync(B,E,v){v&&v.exportWithoutWaitingForScene||await B.whenReadyAsync();const z=new nB(B,v),o=await z.generateGLTFAsync(E.replace(/\.[^/.]+$/,""));return z.dispose(),o}static async GLBAsync(B,E,v){v&&v.exportWithoutWaitingForScene||await B.whenReadyAsync();const z=new nB(B,v),o=await z.generateGLBAsync(E.replace(/\.[^/.]+$/,""));return z.dispose(),o}}v(11952);const sB="EXT_mesh_gpu_instancing";class JB{constructor(B){this.name=sB,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(B,E,v,o,q,c){return await new Promise((B=>{if(E&&v instanceof gB.e&&v.hasThinInstances&&this._exporter){this._wasUsed=!0;const B=z.GE.Zero(),o=z.Quaternion.Identity(),S=z.GE.One(),x=v.thinInstanceGetWorldMatrices(),D=z.TmpVectors.GE[2],h=z.TmpVectors.Quaternion[1],y=z.TmpVectors.GE[3];let Q=!1,P=!1,G=!1;const Y=new Float32Array(3*v.Tc),a=new Float32Array(4*v.Tc),m=new Float32Array(3*v.Tc);let g=0;for(const E of x)E.decompose(y,h,D),q&&(L(D),M(h)),Y.set(D.cc(),3*g),a.set(h.normalize().cc(),4*g),m.set(y.cc(),3*g),Q=Q||!D.equalsWithEpsilon(B),P=P||!h.equalsWithEpsilon(o),G=G||!y.equalsWithEpsilon(S),g++;const V={attributes:{}};Q&&(V.attributes.TRANSLATION=this._buildAccessor(Y,"VEC3",v.Tc,c)),P&&(V.attributes.ROTATION=this._buildAccessor(a,"VEC4",v.Tc,c)),G&&(V.attributes.SCALE=this._buildAccessor(m,"VEC3",v.Tc,c)),E.extensions=E.extensions||{},E.extensions[sB]=V}B(E)}))}_buildAccessor(B,E,v,z){const o=z.createBufferView(B),q=z.createAccessor(o,E,5126,v);return this._exporter._accessors.push(q),this._exporter._accessors.length-1}}nB.RegisterExtension(sB,(B=>new JB(B)));var OB=v(11958),eB=v(11976),kB=v(11980),LB=v(11989);function MB(B){return B===kB.e.PositionKind?"POSITION":B===kB.e.NormalKind?"NORMAL":B===kB.e.ColorKind?"COLOR":B.startsWith(kB.e.UVKind)?"TEX_COORD":"GENERIC"}const ZB={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class BE extends OB.b{static get DefaultAvailable(){return(0,OB.j)(BE.DefaultConfiguration)}static get Default(){return BE._Default??(BE._Default=new BE),BE._Default}static ResetDefault(B){BE._Default&&(B||BE._Default.dispose(),BE._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(B,E){return{module:await(E||DracoEncoderModule)({wasmBinary:B})}}_getWorkerContent(){return`${eB.i}(${eB.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:BE.DefaultConfiguration)}async _encodeAsync(B,E,v){const z=v?(0,LB.b)(ZB,v):ZB;if(this._workerPoolPromise){const v=await this._workerPoolPromise;return await new Promise(((o,q)=>{v.push(((v,c)=>{const S=B=>{v.removeEventListener("error",S),v.removeEventListener("message",x),q(B),c()},x=B=>{"encodeMeshDone"===B.data.id&&(v.removeEventListener("error",S),v.removeEventListener("message",x),o(B.data.encodedMeshData),c())};v.addEventListener("error",S),v.addEventListener("message",x);const D=[];for(const E of B)D.push(E.data.buffer);E&&D.push(E.buffer),v.postMessage({id:"encodeMesh",attributes:B,indices:E,options:z},D)}))}))}if(this._modulePromise){const v=await this._modulePromise;return(0,eB.i)(v.module,B,E,z)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(B,E){if(0==B.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");B instanceof gB.e&&B.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===E||void 0===E?void 0:E.method)&&(R.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),E.method="MESH_SEQUENTIAL_ENCODING");const v=function(B){let E=B.Pc(void 0,!0);return!E||E instanceof Uint32Array||E instanceof Uint16Array||(E=((0,j.c)(E,E.length)?Uint32Array:Uint16Array).from(E)),E}(B),z=function(B,E){const v=[];for(const z of B.getVerticesDataKinds()){if(null!==E&&void 0!==E&&E.includes(z)){if(z===kB.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const o=B.getVertexBuffer(z),q=o.getSize(),c=(0,j.r)(o.getData(),q,o.type,o.byteOffset,o.byteStride,o.normalized,B.getTotalVertices(),!0);v.push({kind:z,dracoName:MB(z),size:q,data:c})}return v}(B,null===E||void 0===E?void 0:E.excludedAttributes);return await this._encodeAsync(z,v,E)}}BE.DefaultConfiguration={wasmUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder.js`},BE._Default=null;const EE="KHR_draco_mesh_compression";class vE{get wasUsed(){return this._wasUsed}constructor(B){this.name=EE,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===B.options.meshCompressionMethod&&BE.DefaultAvailable}dispose(){}postExportMeshPrimitive(B,E,v){if(!this.enabled)return;if(4!==B.mode&&5!==B.mode)return void R.c.Warn("Cannot compress primitive with mode "+B.mode+".");const z=[],o=[];let q=null;if(void 0!==B.indices){const c=v[B.indices],S=E.getBufferView(c);q=E.getData(S).slice(),z.push(S),o.push(c)}const c=[];for(const[h,y]of Object.entries(B.attributes)){const B=v[y],q=E.getBufferView(B),x=J(B.type),D=(0,j.r)(E.getData(q),x,B.componentType,B.byteOffset||0,q.byteStride||(0,j.k)(B.componentType)*x,B.normalized||!1,B.count,!0);c.push({kind:h,dracoName:(S=h,"POSITION"===S?"POSITION":"NORMAL"===S?"NORMAL":S.startsWith("COLOR")?"COLOR":S.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:J(B.type),data:D}),z.push(q),o.push(B)}var S;const x={method:B.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},D=BE.Default._encodeAsync(c,q,x).then((v=>{if(!v)return void R.c.Error("Draco encoding failed for primitive.");const q={bufferView:-1,attributes:v.attributeIds},c=E.createBufferView(v.data);E.setBufferView(q,c);for(const B of z)this._bufferViewsUsed.add(B);for(const B of o)this._accessorsUsed.add(B);B.extensions||(B.extensions={}),B.extensions[EE]=q})).catch((B=>{R.c.Error("Draco encoding failed for primitive: "+B)}));this._encodePromises.push(D),this._wasUsed=!0}async preGenerateBinaryAsync(B){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((E=>{B.getPropertiesWithBufferView(E).every((B=>this._accessorsUsed.has(B)))&&B.removeBufferView(E)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}nB.RegisterExtension(EE,(B=>new vE(B)));var zE=v(11991);const oE="KHR_lights_punctual",qE={name:"",color:[1,1,1],Nc:1,range:Number.MAX_VALUE},cE={innerConeAngle:0,outerConeAngle:Math.PI/4},SE=z.GE.Backward();class xE{constructor(B){this.name=oE,this.enabled=!0,this.required=!1,this._exporter=B}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[oE]=this._lights}async postExportNodeAsync(B,E,v,o,q){return await new Promise((c=>{if(!(v instanceof VB.c))return void c(E);const S=v.getTypeID()==VB.c.LIGHTTYPEID_POINTLIGHT?"point":v.getTypeID()==VB.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":v.getTypeID()==VB.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!S||!(v instanceof zE.c))return R.c.Warn(`${B}: Light ${v.name} is not supported in ${oE}`),void c(E);if(v.falloffType!==VB.c.FALLOFF_GLTF&&R.c.Warn(`${B}: Light falloff for ${v.name} does not match the ${oE} specification!`),!v.position.equalsToFloats(0,0,0)){const B=z.TmpVectors.GE[0].S(v.position);q&&L(B),E.translation=B.cc()}if("point"!==S){const B=v.direction.normalizeToRef(z.TmpVectors.GE[0]);q&&L(B);const o=z.Quaternion.FromUnitVectorsToRef(SE,B,z.TmpVectors.Quaternion[0]);z.Quaternion.IsIdentity(o)||(E.rotation=o.cc())}const x={type:S,name:v.name,color:v.Xc.cc(),Nc:v.Nc,range:v.range};if(zB(x,qE),"spot"===S){const B=v;x.spot={innerConeAngle:B.innerAngle/2,outerConeAngle:B.angle/2},zB(x.spot,cE)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(x);const D={pz:this._lights.lights.length-1},h=v.parent;if(h&&EB(v,h)){const B=o.get(h);if(B){const v=this._exporter._nodes[B];return BB(E,v),v.extensions||(v.extensions={}),v.extensions[oE]=D,void c(null)}}E.extensions||(E.extensions={}),E.extensions[oE]=D,c(E)}))}}nB.RegisterExtension(oE,(B=>new xE(B)));var DE=v(11892);const hE="KHR_materials_anisotropy";class yE{constructor(B){this.name=hE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof DE.e&&v.anisotropy.isEnabled&&!v.anisotropy.legacy?(v.anisotropy.texture&&z.push(v.anisotropy.texture),z):[]}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof DE.e){if(!v.anisotropy.isEnabled||v.anisotropy.legacy)return void B(E);this._wasUsed=!0,E.extensions=E.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(v.anisotropy.texture),o={anisotropyStrength:v.anisotropy.Nc,anisotropyRotation:v.anisotropy.angle,anisotropyTexture:z??void 0};null!==o.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(v),E.extensions[hE]=o}B(E)}))}}nB.RegisterExtension(hE,(B=>new yE(B)));const QE="KHR_materials_clearcoat";class PE{constructor(B){this.name=QE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof DE.e&&v.clearCoat.isEnabled?(v.clearCoat.texture&&z.push(v.clearCoat.texture),!v.clearCoat.useRoughnessFromMainTexture&&v.clearCoat.textureRoughness&&z.push(v.clearCoat.textureRoughness),v.clearCoat.bumpTexture&&z.push(v.clearCoat.bumpTexture),z):[]}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof DE.e){if(!v.clearCoat.isEnabled)return void B(E);this._wasUsed=!0,E.extensions=E.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(v.clearCoat.texture);let q;q=v.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(v.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(v.clearCoat.textureRoughness),v.clearCoat.isTintEnabled&&o.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${v.name}`),v.clearCoat.remapF0OnInterfaceChange&&o.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${v.name}`);const c=this._exporter._materialExporter.getTextureInfo(v.clearCoat.bumpTexture),S={clearcoatFactor:v.clearCoat.Nc,clearcoatTexture:z??void 0,clearcoatRoughnessFactor:v.clearCoat.roughness,clearcoatRoughnessTexture:q??void 0,clearcoatNormalTexture:c??void 0};null===S.clearcoatTexture&&null===S.clearcoatRoughnessTexture&&null===S.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(v),E.extensions[QE]=S}B(E)}))}}nB.RegisterExtension(QE,(B=>new PE(B)));const GE="KHR_materials_diffuse_transmission";function YE(B,E){const v=E.subSurface;let z=null;return v.translucencyIntensityTexture?z=v.translucencyIntensityTexture:v.thicknessTexture&&v.useMaskFromThicknessTexture&&(z=v.thicknessTexture),z&&!v.useGltfStyleTextures?(R.c.Warn(`${B}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${E.name}`,1),null):z}class aE{constructor(B){this.name=GE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];if(v instanceof GB.c&&this._isExtensionEnabled(v)){const E=YE(B,v);return E&&z.push(E),v.subSurface.translucencyColorTexture&&z.push(v.subSurface.translucencyColorTexture),z}return z}_isExtensionEnabled(B){if(B.unlit)return!1;const E=B.subSurface;return!!E.isTranslucencyEnabled&&(!B.unlit&&!E.useAlbedoToTintTranslucency&&E.useGltfStyleTextures&&1===E.volumeIndexOfRefraction&&0===E.minimumThickness&&0===E.maximumThickness)}postExportMaterialAsync(B,E,v){return new Promise((z=>{if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0;const z=v.subSurface,o=YE(B,v),q=0==z.translucencyIntensity?void 0:z.translucencyIntensity,c=this._exporter._materialExporter.getTextureInfo(o)??void 0,S=!z.translucencyColor||z.translucencyColor.equalsFloats(1,1,1)?void 0:z.translucencyColor.cc(),x=this._exporter._materialExporter.getTextureInfo(z.translucencyColorTexture)??void 0,D={diffuseTransmissionFactor:q,diffuseTransmissionTexture:c,diffuseTransmissionColorFactor:S,diffuseTransmissionColorTexture:x};(c||x)&&this._exporter._materialNeedsUVsSet.add(v),E.extensions=E.extensions||{},E.extensions[GE]=D}z(E)}))}}nB.RegisterExtension(GE,(B=>new aE(B)));const mE="KHR_materials_dispersion";class gE{constructor(){this.name=mE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){if(B.unlit)return!1;const E=B.subSurface;return!(!E.isRefractionEnabled&&!E.isDispersionEnabled)}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0;const B={dispersion:v.subSurface.dispersion};E.extensions=E.extensions||{},E.extensions[mE]=B}B(E)}))}}nB.RegisterExtension(mE,(()=>new gE));const VE="KHR_materials_emissive_strength";class TE{constructor(){this.name=VE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(B,E,v){return await new Promise((B=>{if(!(v instanceof GB.c))return B(E);const z=v.emissiveColor.cc(),o=Math.max(...z);if(o>1){this._wasUsed=!0,E.extensions||(E.extensions={});const B={emissiveStrength:o},z=v.emissiveColor.scale(1/B.emissiveStrength);E.emissiveFactor=z.cc(),E.extensions[VE]=B}return B(E)}))}}nB.RegisterExtension(VE,(B=>new TE));const NE="KHR_materials_ior";class XE{constructor(){this.name=NE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.indexOfRefraction&&1.5!=B.indexOfRefraction)}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0;const B={ior:v.indexOfRefraction};E.extensions=E.extensions||{},E.extensions[NE]=B}B(E)}))}}nB.RegisterExtension(NE,(B=>new XE));const rE="KHR_materials_iridescence";class iE{constructor(B){this.name=rE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof DE.e&&v.iridescence.isEnabled?(v.iridescence.texture&&z.push(v.iridescence.texture),v.iridescence.thicknessTexture&&v.iridescence.thicknessTexture!==v.iridescence.texture&&z.push(v.iridescence.thicknessTexture),z):[]}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof DE.e){if(!v.iridescence.isEnabled)return void B(E);this._wasUsed=!0,E.extensions=E.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(v.iridescence.texture),o=this._exporter._materialExporter.getTextureInfo(v.iridescence.thicknessTexture),q={iridescenceFactor:v.iridescence.Nc,iridescenceIor:v.iridescence.indexOfRefraction,iridescenceThicknessMinimum:v.iridescence.minimumThickness,iridescenceThicknessMaximum:v.iridescence.maximumThickness,iridescenceTexture:z??void 0,iridescenceThicknessTexture:o??void 0};null===q.iridescenceTexture&&null===q.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(v),E.extensions[rE]=q}B(E)}))}}nB.RegisterExtension(rE,(B=>new iE(B)));const uE="KHR_materials_sheen";class IE{constructor(B){this.name=uE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){return v instanceof GB.c&&v.sheen.isEnabled&&v.sheen.texture?[v.sheen.texture]:[]}async postExportMaterialAsync(B,E,v){return await new Promise((B=>{if(v instanceof GB.c){if(!v.sheen.isEnabled)return void B(E);this._wasUsed=!0,null==E.extensions&&(E.extensions={});const z={sheenColorFactor:v.sheen.color.cc(),sheenRoughnessFactor:v.sheen.roughness??0};null===z.sheenColorTexture&&null===z.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(v),v.sheen.texture&&(z.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.texture)??void 0),v.sheen.textureRoughness&&!v.sheen.useRoughnessFromMainTexture?z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.textureRoughness)??void 0:v.sheen.texture&&v.sheen.useRoughnessFromMainTexture&&(z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(v.sheen.texture)??void 0),E.extensions[uE]=z}B(E)}))}}nB.RegisterExtension(uE,(B=>new IE(B)));const KE="KHR_materials_specular";class CE{constructor(B){this.name=KE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof GB.c&&this._isExtensionEnabled(v)?(v.metallicReflectanceTexture&&z.push(v.metallicReflectanceTexture),v.reflectanceTexture&&z.push(v.reflectanceTexture),z):z}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.metallicF0Factor&&1!=B.metallicF0Factor||void 0!=B.metallicReflectanceColor&&!B.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.metallicReflectanceTexture||null!=B.reflectanceTexture}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0,E.extensions=E.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(v.metallicReflectanceTexture)??void 0,z=this._exporter._materialExporter.getTextureInfo(v.reflectanceTexture)??void 0,o={specularFactor:1==v.metallicF0Factor?void 0:v.metallicF0Factor,specularTexture:B,specularColorFactor:v.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:v.metallicReflectanceColor.cc(),specularColorTexture:z};this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),E.extensions[KE]=o}B(E)}))}}nB.RegisterExtension(KE,(B=>new CE(B)));const fE="KHR_materials_transmission";class AE{constructor(B){this.name=fE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof GB.c&&this._isExtensionEnabled(v)?(v.subSurface.thicknessTexture&&z.push(v.subSurface.thicknessTexture),z):z}_isExtensionEnabled(B){if(B.unlit)return!1;const E=B.subSurface;return E.isRefractionEnabled&&void 0!=E.refractionIntensity&&0!=E.refractionIntensity||this._hasTexturesExtension(B)}_hasTexturesExtension(B){return null!=B.subSurface.refractionIntensityTexture}async postExportMaterialAsync(B,E,v){if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0;const z=v.subSurface,o={transmissionFactor:0===z.refractionIntensity?void 0:z.refractionIntensity};if(this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),z.refractionIntensityTexture)if(z.useGltfStyleTextures){const B=await this._exporter._materialExporter.exportTextureAsync(z.refractionIntensityTexture,"image/png");B&&(o.transmissionTexture=B)}else R.c.Warn(`${B}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);E.extensions||(E.extensions={}),E.extensions[fE]=o}return E}}nB.RegisterExtension(fE,(B=>new AE(B)));const lE="KHR_materials_unlit";class dE{constructor(){this.name=lE,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(B,E,v){return new Promise((B=>{let z=!1;v instanceof GB.c?z=v.unlit:v instanceof YB.mE&&(z=v.disableLighting),z&&(this._wasUsed=!0,null==E.extensions&&(E.extensions={}),E.extensions[lE]={}),B(E)}))}}nB.RegisterExtension(lE,(()=>new dE));const tE="KHR_materials_volume";class pE{constructor(B){this.name=tE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof GB.c&&this._isExtensionEnabled(v)?(v.subSurface.thicknessTexture&&z.push(v.subSurface.thicknessTexture),z):z}_isExtensionEnabled(B){if(B.unlit)return!1;const E=B.subSurface;return!(!E.isRefractionEnabled&&!E.isTranslucencyEnabled)&&(void 0!=E.maximumThickness&&0!=E.maximumThickness||void 0!=E.tintColorAtDistance&&E.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=E.tintColor&&E.tintColor!=a.gE.White()||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.subSurface.thicknessTexture}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof GB.c&&this._isExtensionEnabled(v)){this._wasUsed=!0;const B=v.subSurface,z={thicknessFactor:0==B.maximumThickness?void 0:B.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(B.thicknessTexture)??void 0,attenuationDistance:B.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:B.tintColorAtDistance,attenuationColor:B.tintColor.equalsFloats(1,1,1)?void 0:B.tintColor.cc()};this._hasTexturesExtension(v)&&this._exporter._materialNeedsUVsSet.add(v),E.extensions=E.extensions||{},E.extensions[tE]=z}B(E)}))}}nB.RegisterExtension(tE,(B=>new pE(B)));const HE="EXT_materials_diffuse_roughness";class jE{constructor(B){this.name=HE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,E,v){const z=[];return v instanceof DE.e&&v._baseDiffuseRoughness?(v._baseDiffuseRoughnessTexture&&z.push(v._baseDiffuseRoughnessTexture),z):[]}postExportMaterialAsync(B,E,v){return new Promise((B=>{if(v instanceof DE.e){if(!v._baseDiffuseRoughness)return void B(E);this._wasUsed=!0,E.extensions=E.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(v._baseDiffuseRoughnessTexture),o={diffuseRoughnessFactor:v._baseDiffuseRoughness,diffuseRoughnessTexture:z??void 0};null!==o.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(v),E.extensions[HE]=o}B(E)}))}}nB.RegisterExtension(HE,(B=>new jE(B)));const RE="KHR_texture_transform";class bE{constructor(){this.name=RE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(B,E,v){if(v.rB()||o.Tools.Warn(`${B}: /*@__KEY__*/"scene" is not defined for Babylon texture ${v.name}!`),(0!==v.uAng||0!==v.vAng)&&(o.Tools.Warn(`${B}: Texture ${v.name} with rotation in the u or v axis is not supported in glTF.`),0!==v.uRotationCenter||0!==v.vRotationCenter))return;const z={};let q=!1;if(0===v.uOffset&&0===v.vOffset||(z.offset=[v.uOffset,v.vOffset],q=!0),1===v.uScale&&1===v.vScale||(z.scale=[v.uScale,v.vScale],q=!0),0!==v.wAng){if(0!==v.uRotationCenter||0!==v.vRotationCenter){if(v.homogeneousRotationInUVTransform&&v.uScale!==v.vScale)return void o.Tools.Warn(`${B}: Texture ${v.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${RE}.`);o.Tools.Warn(`${B}: Texture ${v.name} with non-origin rotation center will be exported using an adjusted offset with ${RE}.`),z.offset=function(B){const{uOffset:E,vOffset:v,uRotationCenter:z,vRotationCenter:o,uScale:q,vScale:c,wAng:S}=B,x=Math.cos(S),D=Math.sin(S),h=z*q,y=o*c;return[E+(h*(1-x)+y*D),v+(y*(1-x)-h*D)]}(v)}z.rotation=-v.wAng,q=!0}0!==v.coordinatesIndex&&(z.texCoord=v.coordinatesIndex,q=!0),q&&(this._wasUsed=!0,E.extensions||(E.extensions={}),E.extensions[RE]=z)}}nB.RegisterExtension(RE,(()=>new bE));class FE{static CreateSTL(B){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],q=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],c=arguments.length>5&&void 0!==arguments[5]&&arguments[5],S=arguments.length>6&&void 0!==arguments[6]&&arguments[6],x=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const D=function(B,E,v){const o=[3*B[v],3*B[v+1],3*B[v+2]],q=[new z.GE(E[o[0]],E[o[0]+2],E[o[0]+1]),new z.GE(E[o[1]],E[o[1]+2],E[o[1]+1]),new z.GE(E[o[2]],E[o[2]+2],E[o[2]+1])],c=q[0].YE(q[1]),S=q[2].YE(q[1]);return{v:q,n:z.GE.Cross(S,c).normalize()}},y=function(B,E,v,z){return E=Q(B,E,v.x,z),E=Q(B,E,v.y,z),Q(B,E,v.z,z)},Q=function(B,E,v,z){return B.setFloat32(E,v,z),E+4},G=function(B){if(S){let E=B;B instanceof P.b&&(E=B.sourceMesh);const v=E.getVerticesData(h.e.PositionKind,!0,!0);if(!v)return[];const o=z.GE.Zero();let q;for(q=0;q<v.length;q+=3)z.GE.TransformCoordinatesFromFloatsToRef(v[q],v[q+1],v[q+2],B.yc(!0),o).toArray(v,q);return v}return B.getVerticesData(h.e.PositionKind)||[]};S&&(c=!0);let Y="",a=0,m=0;if(o){for(let v=0;v<B.length;v++){const E=B[v].Pc();a+=E?E.length/3:0}const E=new ArrayBuffer(84+50*a);Y=new DataView(E),m+=80,Y.setUint32(m,a,q),m+=4}else x||(Y="solid stlmesh\r\n");for(let z=0;z<B.length;z++){const E=B[z];!o&&x&&(Y+="solid "+E.name+"\r\n"),!c&&E instanceof gB.e&&E.bakeCurrentTransformIntoVertices();const v=G(E),S=E.Pc()||[];for(let B=0;B<S.length;B+=3){const E=D(S,v,B);o?(m=y(Y,m,E.n,q),m=y(Y,m,E.v[0],q),m=y(Y,m,E.v[1],q),m=y(Y,m,E.v[2],q),m+=2):(Y+="\tfacet normal "+E.n.x+" "+E.n.y+" "+E.n.z+"\r\n",Y+="\t\touter loop\r\n",Y+="\t\t\tvertex "+E.v[0].x+" "+E.v[0].y+" "+E.v[0].z+"\r\n",Y+="\t\t\tvertex "+E.v[1].x+" "+E.v[1].y+" "+E.v[1].z+"\r\n",Y+="\t\t\tvertex "+E.v[2].x+" "+E.v[2].y+" "+E.v[2].z+"\r\n",Y+="\t\tendloop\r\n",Y+="\tendfacet\r\n")}!o&&x&&(Y+="endsolid "+name+"\r\n")}if(o||x||(Y+="endsolid stlmesh"),E){const B=document.createElement("a"),E=new Blob([Y],{type:"application/octet-stream"});B.href=window.URL.createObjectURL(E),B.download=v+".stl",B.click()}return Y}}function WE(B,E){let v=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const z=[];for(let o=0;o<B.length/v;o++){const q=B[o*v],c=B[o*v+1],S=B[o*v+2];z.push(`(${q.toPrecision(E.precision)}, ${c.toPrecision(E.precision)}, ${S.toPrecision(E.precision)})`)}return z.join(", ")}function wE(B,E){const v=[];for(let z=0;z<B.length/2;z++){const o=B[2*z],q=B[2*z+1];v.push(`(${o.toPrecision(E.precision)}, ${(1-q).toPrecision(E.precision)})`)}return v.join(", ")}function nE(B,E){const v=B.getVerticesData(h.e.PositionKind),z=B.getVerticesData(h.e.NormalKind);if(v&&z)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(B){var E;const v=null!==(E=B.Pc())&&void 0!==E&&E.length?B.getTotalIndices():B.getTotalVertices();return Array(v/3).fill(3).join(", ")}(B)}]\n\t\tint[] faceVertexIndices = [${function(B){const E=B.Pc(),v=[];if(null!==E)for(let z=0;z<E.length;z++)v.push(E[z]);else{const E=B.getTotalVertices();for(let B=0;B<E;B++)v.push(B)}return v.join(", ")}(B)}]\n\t\tnormal3f[] normals = [${WE(z,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${WE(v,E)}]\n        ${function(B,E){let v="";for(let o=0;o<4;o++){const z=o>0?o:"",q=B.getVerticesData(h.e.UVKind+(z?z+1:""));q&&(v+=`\n\t\ttexCoord2f[] primvars:st${z} = [${wE(q,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const z=B.getVerticesData(h.e.ColorKind);return z&&(v+=`\n\tcolor3f[] primvars:displayColor = [${WE(z,E,z.length/B.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),v}(B,E)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function UE(B,E){return`\n        def "Geometry"\n        {\n        ${nE(B,E)}\n        }\n        `}function sE(B){let E='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return E+=B,fflate.strToU8(E)}function JE(B){const E=B.m;return`( ${OE(E,0)}, ${OE(E,4)}, ${OE(E,8)}, ${OE(E,12)} )`}function OE(B,E){return`(${B[E+0]}, ${B[E+1]}, ${B[E+2]}, ${B[E+3]})`}function eE(B){const E="Object_"+B.uniqueId,v=function(B){const E=B.getWorldMatrix().clone(),v=B.rB().useRightHandedSystem;if(!v){let z=B.parent;for(;z;){if(cB(z,v)){E.multiplyToRef(z.getWorldMatrix().invert(),E);break}z=z.parent}}return E.determinant()<0&&o.Tools.Warn(`Exporting mesh ${B.name} with negative scale. Result may look incorrect in destination engine.`),E}(B),z=JE(v);return`def Xform "${E}" (\n\tprepend references = @./geometries/Geometry_${B.Qc.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${z}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${B.material.uniqueId}>\n}\n\n`}function kE(B){switch(B){case r.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case r.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case r.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function LE(B){return`(${B.x}, ${B.y})`}function ME(B){return`(${B.r}, ${B.g}, ${B.b})`}function ZE(B,E,v,o,q,c){const S=B.getInternalTexture().uniqueId+"_"+B.invertY;q[S]=B;const x=B.coordinatesIndex>0?"st"+B.coordinatesIndex:"st",D=new z.Vector2(B.uScale,B.vScale),h=new z.Vector2(B.uOffset,B.vOffset),y=B.wAng,Q=Math.sin(y),P=Math.cos(y);return h.y=1-h.y-D.y,h.x+=Q*D.x,h.y+=(1-P)*D.y,`\n    def Shader "PrimvarReader_${v}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${x}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${v}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${E.uniqueId}/PrimvarReader_${v}.outputs:result>\n        float inputs:rotation = ${(y*(180/Math.PI)).toFixed(c.precision)}\n        float2 inputs:scale = ${LE(D)}\n        float2 inputs:translation = ${LE(h)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${B.uniqueId}_${v}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${S}.png@\n        float2 inputs:st.connect = </Materials/Material_${E.uniqueId}/Transform2d_${v}.outputs:result>\n        ${o?"float4 inputs:scale = "+function(B){return`(${B.r}, ${B.g}, ${B.b}, 1.0)`}(o):""}\n        token inputs:sourceColorSpace = "${B.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${kE(B.wrapU)}"\n        token inputs:wrapT = "${kE(B.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${E.needAlphaBlending()?"float outputs:a":""}\n    }`}function Bv(B,E,v){const z="\t\t\t",o=[],q=[],{diffuseMap:c,Xc:S,alphaCutOff:x,emissiveMap:D,emissive:h,normalMap:y,roughnessMap:Q,roughnessChannel:P,roughness:G,metalnessMap:Y,metalnessChannel:m,metalness:g,aoMap:V,aoMapChannel:T,aoMapIntensity:N,alphaMap:X,ior:r,clearCoatEnabled:i,clearCoat:u,clearCoatMap:I,clearCoatRoughness:K,clearCoatRoughnessMap:C}=function(B){const E={diffuseMap:null,Xc:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return B instanceof YB.mE?{...E,diffuseMap:B.diffuseTexture,Xc:B.diffuseColor,alphaCutOff:B.alphaCutOff,emissiveMap:B.emissiveTexture,emissive:B.emissiveColor,roughness:1,alphaMap:B.opacityTexture}:B instanceof DE.e?{...E,diffuseMap:B._albedoTexture,Xc:B._albedoColor,alphaCutOff:B._alphaCutOff,emissiveMap:B._emissiveTexture,emissive:B._emissiveColor,normalMap:B._bumpTexture,roughnessMap:B._metallicTexture,roughnessChannel:B._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:B._roughness??1,metalnessMap:B._metallicTexture,metalnessChannel:B._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:B._metallic??0,aoMap:B._ambientTexture,aoMapChannel:B._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:B._ambientTextureStrength,alphaMap:B._opacityTexture,ior:B.subSurface.indexOfRefraction,clearCoatEnabled:B.clearCoat.isEnabled,clearCoat:B.clearCoat.Nc,clearCoatMap:B.clearCoat.texture,clearCoatRoughness:B.clearCoat.roughness,clearCoatRoughnessMap:B.clearCoat.useRoughnessFromMainTexture?B.clearCoat.texture:B.clearCoat.textureRoughness}:E}(B);return null!==c?(o.push(`${z}color3f inputs:diffuseColor.connect = </Materials/Material_${B.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:rgb>`),B.needAlphaBlending()?o.push(`${z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:a>`):B.needAlphaTesting()&&(o.push(`${z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${c.uniqueId}_diffuse.outputs:a>`),o.push(`${z}float inputs:opacityThreshold = ${x}`)),q.push(ZE(c,B,"diffuse",S,E,v))):o.push(`${z}color3f inputs:diffuseColor = ${ME(S||a.gE.White())}`),null!==D?(o.push(`${z}color3f inputs:emissiveColor.connect = </Materials/Material_${B.uniqueId}/Texture_${D.uniqueId}_emissive.outputs:rgb>`),q.push(ZE(D,B,"emissive",h,E,v))):h&&h.toLuminance()>0&&o.push(`${z}color3f inputs:emissiveColor = ${ME(h)}`),null!==y&&(o.push(`${z}normal3f inputs:normal.connect = </Materials/Material_${B.uniqueId}/Texture_${y.uniqueId}_normal.outputs:rgb>`),q.push(ZE(y,B,"normal",null,E,v))),null!==V&&(o.push(`${z}float inputs:occlusion.connect = </Materials/Material_${B.uniqueId}/Texture_${V.uniqueId}_occlusion.outputs:${T}>`),q.push(ZE(V,B,"occlusion",new a.gE(N,N,N),E,v))),null!==Q?(o.push(`${z}float inputs:roughness.connect = </Materials/Material_${B.uniqueId}/Texture_${Q.uniqueId}_roughness.outputs:${P}>`),q.push(ZE(Q,B,"roughness",new a.gE(G,G,G),E,v))):o.push(`${z}float inputs:roughness = ${G}`),null!==Y?(o.push(`${z}float inputs:metallic.connect = </Materials/Material_${B.uniqueId}/Texture_${Y.uniqueId}_metallic.outputs:${m}>`),q.push(ZE(Y,B,"metallic",new a.gE(g,g,g),E,v))):o.push(`${z}float inputs:metallic = ${g}`),null!==X?(o.push(`${z}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${X.uniqueId}_opacity.outputs:r>`),o.push(`${z}float inputs:opacityThreshold = 0.0001`),q.push(ZE(X,B,"opacity",null,E,v))):o.push(`${z}float inputs:opacity = ${B.alpha}`),i&&(null!==I?(o.push(`${z}float inputs:clearcoat.connect = </Materials/Material_${B.uniqueId}/Texture_${I.uniqueId}_clearcoat.outputs:r>`),q.push(ZE(I,B,"clearcoat",new a.gE(u,u,u),E,v))):o.push(`${z}float inputs:clearcoat = ${u}`),null!==C?(o.push(`${z}float inputs:clearcoatRoughness.connect = </Materials/Material_${B.uniqueId}/Texture_${C.uniqueId}_clearcoatRoughness.outputs:g>`),q.push(ZE(C,B,"clearcoatRoughness",new a.gE(K,K,K),E,v))):o.push(`${z}float inputs:clearcoatRoughness = ${K}`)),o.push(`${z}float inputs:ior = ${r}`),`\n\tdef Material "Material_${B.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${B.uniqueId}/PreviewSurface.outputs:surface>\n\n${q.join("\n")}\n\n\t}\n`}async function Ev(B,E,v){const q={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...E};"undefined"===typeof fflate&&await o.Tools.LoadScriptAsync(q.fflateUrl);const c={};c[q.modelFileName]=null;let S='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';S+=function(B){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===B.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${B.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${B.planeAnchoringAlignment}"`:""}\n            `}(q);const x={};for(const z of B.meshes){if(0===z.getTotalVertices())continue;const B=z,E=B.Qc,D=B.material;if(!D||!E||v&&!v(B))continue;if(-1!==["mE","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(D.getClassName())){const v="geometries/Geometry_"+E.uniqueId+".usda";if(!(v in c)){const B=UE(E,q);c[v]=sE(B)}D.uniqueId in x||(x[D.uniqueId]=D),S+=eE(B)}else o.Tools.Warn("USDZExportAsync does not support this material type: "+D.getClassName())}B.activeCamera&&q.exportCamera&&(S+=function(B,E){const v="Camera_"+B.uniqueId,o=JE(z.Matrix.RotationY(Math.PI).multiply(B.getWorldMatrix()));if(B.mode===r.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${v}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${o}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.xc.toPrecision(E.precision)}, ${B.maxZ.toPrecision(E.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(B.orthoLeft||1)+Math.abs(B.orthoRight||1))).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(B.orthoTop||1)+Math.abs(B.orthoBottom||1))).toPrecision(E.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const z=B.getEngine().getAspectRatio(B),q=E.cameraSensorWidth||35;return`def Camera "${v}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${o}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.xc.toPrecision(E.precision)}, ${B.maxZ.toPrecision(E.precision)})\n\t\t\tfloat focalLength = ${(q/(2*Math.tan(.5*B.fov))).toPrecision(E.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(q*z).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(q/z).toPrecision(E.precision)}            \n\t\t}\n\t\n\t`}}(B.activeCamera,q)),S+="\n            }\n        }\n    }";const D={};S+=function(B,E,v){const z=[];for(const o in B){const q=B[o];z.push(Bv(q,E,v))}return`\n    def "Materials"\n{\n${z.join("")}\n}\n\n`}(x,D,q),c[q.modelFileName]=fflate.strToU8(S);for(const z in D){const B=D[z],E=B.getSize(),v=await B.readPixels();if(!v)throw new Error("Texture data is not available");const o=await i.DumpTools.DumpDataAsync(E.width,E.height,v,"image/png",void 0,!1,!0);c[`textures/Texture_${z}.png`]=new Uint8Array(o).slice()}let h=0;for(const z in c){const B=c[z];if(!B)continue;h+=34+z.length;const E=63&h;if(4!==E){const v=new Uint8Array(64-E);c[z]=[B,{extra:{12345:v}}]}h=B.length}return fflate.zipSync(c,{level:0})}}}]);