"use strict";(self["3b8bnhi4gzj"]=self["3b8bnhi4gzj"]||[]).push([[26],{12143:(Z,h,V)=>{V.r(h),V.d(h,{EXT_materials_diffuse_roughness:()=>Uh,EXT_mesh_gpu_instancing:()=>OZ,GLTF2Export:()=>iZ,GLTFData:()=>n,KHR_draco_mesh_compression:()=>Vh,KHR_lights_punctual:()=>ah,KHR_materials_anisotropy:()=>Nh,KHR_materials_clearcoat:()=>kh,KHR_materials_diffuse_transmission:()=>bh,KHR_materials_dispersion:()=>qh,KHR_materials_emissive_strength:()=>Eh,KHR_materials_ior:()=>Ph,KHR_materials_iridescence:()=>lh,KHR_materials_sheen:()=>Sh,KHR_materials_specular:()=>Lh,KHR_materials_transmission:()=>Wh,KHR_materials_unlit:()=>mh,KHR_materials_volume:()=>Ih,KHR_texture_transform:()=>Qh,OBJExport:()=>K,STLExport:()=>wh,USDZExportAsync:()=>hV,_ConvertToGLTFPBRMetallicRoughness:()=>z,_SolveMetallic:()=>W,__IGLTFExporterExtension:()=>d});var v=V(11729),A=V(11564),H=V(12062);class K{static OBJ(Z,h,V,K){const d=[];let a=1,n=1;h&&(V||(V="mat"),d.push("mtllib "+V+".mtl"));for(let x=0;x<Z.length;x++){const V=Z[x],N=V.name||`mesh${x}}`;d.push(`o ${N}`);let D=null;if(K){const Z=V.sh(!0);D=new v.Matrix,Z.invertToRef(D),V.bakeTransformIntoVertices(Z)}if(h){const Z=V.material;Z&&d.push("usemtl "+Z.id)}const k=V.Jh;if(!k){A.Tools.Warn("No geometry is present on the mesh");continue}const u=k.getVerticesData("position"),F=k.getVerticesData("normal"),b=k.getVerticesData("uv"),o=k.fh();let q=0,X=0;if(!u||!o){A.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const E=Z[0].CZ().useRightHandedSystem?1:-1;for(let Z=0;Z<u.length;Z+=3)d.push("v "+u[Z]*E+" "+u[Z+1]+" "+u[Z+2]),q++;if(null!=F)for(let Z=0;Z<F.length;Z+=3)d.push("vn "+F[Z]*E+" "+F[Z+1]+" "+F[Z+2]);if(null!=b)for(let Z=0;Z<b.length;Z+=2)d.push("vt "+b[Z]+" "+b[Z+1]),X++;const j=["","",""],P=(V.material||V.CZ().defaultMaterial)._getEffectiveOrientation(V),[C,l]=P===H.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let Z=0;Z<o.length;Z+=3){const h=[String(o[Z]+a),String(o[Z+C]+a),String(o[Z+l]+a)],V=[String(o[Z]+n),String(o[Z+C]+n),String(o[Z+l]+n)],v=h,A=null!=b?V:j,H=null!=F?h:j;d.push("f "+v[0]+"/"+A[0]+"/"+H[0]+" "+v[1]+"/"+A[1]+"/"+H[1]+" "+v[2]+"/"+A[2]+"/"+H[2])}K&&D&&V.bakeTransformIntoVertices(D),a+=q,n+=X}return d.join("\n")}static MTL(Z){const h=[],V=Z.material;h.push("newmtl mat1"),h.push("  Ns "+V.specularPower.toFixed(4)),h.push("  Ni 1.5000"),h.push("  d "+V.alpha.toFixed(4)),h.push("  Tr 0.0000"),h.push("  Tf 1.0000 1.0000 1.0000"),h.push("  illum 2"),h.push("  Ka "+V.ambientColor.r.toFixed(4)+" "+V.ambientColor.g.toFixed(4)+" "+V.ambientColor.b.toFixed(4)),h.push("  Kd "+V.diffuseColor.r.toFixed(4)+" "+V.diffuseColor.g.toFixed(4)+" "+V.diffuseColor.b.toFixed(4)),h.push("  Ks "+V.specularColor.r.toFixed(4)+" "+V.specularColor.g.toFixed(4)+" "+V.specularColor.b.toFixed(4)),h.push("  Ke "+V.emissiveColor.r.toFixed(4)+" "+V.emissiveColor.g.toFixed(4)+" "+V.emissiveColor.b.toFixed(4));V.ambientTexture&&h.push("  map_Ka "+V.ambientTexture.name),V.diffuseTexture&&h.push("  map_Kd "+V.diffuseTexture.name),V.specularTexture&&h.push("  map_Ks "+V.specularTexture.name),V.bumpTexture&&h.push("  map_bump -imfchan z "+V.bumpTexture.name),V.opacityTexture&&h.push("  map_d "+V.opacityTexture.name);return h.join("\n")}}var d=0,a=V(11602);class n{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Z in this.files){const h=this.files[Z],V=new Blob([h],{type:(0,a.j)(Z)});A.Tools.Download(V,Z)}}}var x=V(11805),N=V(12146),D=V(12157),k=V(12176),u=V(11870),F=V(11599),b=V(11781),o=V(11748);const q=o.HighestCommonFactor,X={...o,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:q};var E=V(11975),j=V(11713),P=V(12211),C=V(12218),l=V(11971);const B=1e-6,S=new b.Ih(.04,.04,.04),r=1024,L=b.Ih.White(),y=b.Ih.Black();function W(Z,h,V){if(h<S.r)return 0;const v=S.r,A=Z*V/(1-S.r)+h-2*S.r,H=A*A-4*v*(S.r-h);return X.Clamp((-A+Math.sqrt(H))/(2*v),0,1)}function z(Z){const h=Z.diffuseColor.toLinearSpace(Z.CZ().getEngine().useExactSrgbConversions).scale(.5),V=Z.alpha,A=function(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new v.Vector2(0,1),V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new v.Vector2(0,.1),A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new v.Vector2(0,.1),H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new v.Vector2(1300,.1);return function(Z,h,V,v,A){return(1-Z)*(1-Z)*(1-Z)*h+3*(1-Z)*(1-Z)*Z*V+3*(1-Z)*Z*Z*v+Z*Z*Z*A}(Math.pow(Z/H.x,.333333),h.y,V.y,A.y,H.y)}(X.Clamp(Z.specularPower,0,r));return{baseColorFactor:[h.r,h.g,h.b,V],metallicFactor:0,roughnessFactor:A}}function m(Z,h){h.needAlphaBlending()?Z.alphaMode="BLEND":h.needAlphaTesting()&&(Z.alphaMode="MASK",Z.alphaCutoff=h.alphaCutOff)}function g(Z,h,V){const v=new Uint8Array(Z*h*4);for(let A=0;A<v.length;A+=4)v[A]=v[A+1]=v[A+2]=v[A+3]=255;return P.d.CreateRGBATexture(v,Z,h,V)}function I(Z){if(Z instanceof Uint8Array){const h=Z.length,V=new Float32Array(Z.length);for(let v=0;v<h;++v)V[v]=Z[v]/255;return V}if(Z instanceof Float32Array)return Z;throw new Error("Unsupported pixel format!")}class e{constructor(Z){this._exporter=Z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Z){return Z?this._textureMap.get(Z)??null:null}async exportStandardMaterialAsync(Z,h,V){const v=z(Z),H={name:Z.name};if(null==Z.Gh||Z.Gh||(Z.twoSidedLighting||A.Tools.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),H.doubleSided=!0),V){const V=[],A=Z.diffuseTexture;A&&V.push(this.exportTextureAsync(A,h).then((Z=>{Z&&(v.baseColorTexture=Z)})));const K=Z.bumpTexture;K&&V.push(this.exportTextureAsync(K,h).then((Z=>{Z&&(H.normalTexture=Z,1!==K.level&&(H.normalTexture.scale=K.level))})));const d=Z.emissiveTexture;d&&(H.emissiveFactor=[1,1,1],V.push(this.exportTextureAsync(d,h).then((Z=>{Z&&(H.emissiveTexture=Z)}))));const a=Z.ambientTexture;a&&V.push(this.exportTextureAsync(a,h).then((Z=>{if(Z){const h={index:Z.index};H.occlusionTexture=h}}))),V.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(V))}(Z.alpha<1||Z.opacityTexture)&&(Z.alphaMode===C.e.ALPHA_COMBINE?H.alphaMode="BLEND":A.Tools.Warn(Z.name+": glTF 2.0 does not support alpha mode: "+Z.alphaMode.toString())),Z.emissiveColor&&!Z.emissiveColor.equalsWithEpsilon(y,B)&&(H.emissiveFactor=Z.emissiveColor.mh()),H.pbrMetallicRoughness=v,m(H,Z),await this._finishMaterialAsync(H,Z,h);const K=this._exporter._materials;return K.push(H),K.length-1}async _finishMaterialAsync(Z,h,V){const v=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Z,h),A=[];for(const H of v)A.push(this.exportTextureAsync(H,V));await Promise.all(A),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Z,h)}async _getImageDataAsync(Z,h,v,A){const H=C.e.TEXTURETYPE_UNSIGNED_BYTE,K=this._exporter._babylonScene,d=K.getEngine(),a=d.createRawTexture(Z,h,v,C.e.TEXTUREFORMAT_RGBA,!1,!0,j.e.NEAREST_SAMPLINGMODE,null,H);d.isWebGPU?await V.e(51).then(V.bind(V,14277)):await V.e(52).then(V.bind(V,14279)),await E.h.ApplyPostProcess("pass",a,K,H,C.e.TEXTURE_NEAREST_SAMPLINGMODE,C.e.TEXTUREFORMAT_RGBA);const n=await d._readTexturePixels(a,h,v);return await l.DumpTools.DumpDataAsync(h,v,n,A,void 0,!0,!0)}_resizeTexturesToSameDimensions(Z,h,V){const v=Z?Z.getSize():{width:0,height:0},A=h?h.getSize():{width:0,height:0};let H,K;return v.width<A.width?(H=Z&&Z instanceof j.e?E.h.CreateResizedCopy(Z,A.width,A.height,!0):g(A.width,A.height,V),K=h):v.width>A.width?(K=h&&h instanceof j.e?E.h.CreateResizedCopy(h,v.width,v.height,!0):g(v.width,v.height,V),H=Z):(H=Z,K=h),{texture1:H,texture2:K}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,h,V,v){const A=new Array;if(!Z&&!h)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const H=Z?Z.CZ():h?h.CZ():null;if(H){var K;const d=this._resizeTexturesToSameDimensions(Z,h,H),a=null===(K=d.texture1)||void 0===K?void 0:K.getSize();let n,x;const N=a.width,D=a.height,k=await d.texture1.readPixels(),u=await d.texture2.readPixels();if(!k)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(n=I(k),!u)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");x=I(u);const F=x.byteLength,o=new Uint8Array(F),q=new Uint8Array(F),X=4,E=y;let j=0,P=0;for(let Z=0;Z<D;++Z)for(let h=0;h<N;++h){const v=(N*Z+h)*X,A={diffuseColor:new b.Ih(n[v],n[v+1],n[v+2]).toLinearSpace(H.getEngine().useExactSrgbConversions).multiply(V.diffuseColor),specularColor:new b.Ih(x[v],x[v+1],x[v+2]).toLinearSpace(H.getEngine().useExactSrgbConversions).multiply(V.specularColor),glossiness:x[v+3]*V.glossiness},K=this._convertSpecularGlossinessToMetallicRoughness(A);E.r=Math.max(E.r,K.baseColor.r),E.g=Math.max(E.g,K.baseColor.g),E.b=Math.max(E.b,K.baseColor.b),j=Math.max(j,K.metallic),P=Math.max(P,K.roughness),q[v]=255*K.baseColor.r,q[v+1]=255*K.baseColor.g,q[v+2]=255*K.baseColor.b,q[v+3]=d.texture1.Uh?255*n[v+3]:255,o[v]=0,o[v+1]=255*K.roughness,o[v+2]=255*K.metallic,o[v+3]=255}const C={baseColor:E,metallic:j,roughness:P};let l=!1,S=!1;for(let Z=0;Z<D;++Z)for(let h=0;h<N;++h){const V=(N*Z+h)*X;q[V]/=C.baseColor.r>B?C.baseColor.r:1,q[V+1]/=C.baseColor.g>B?C.baseColor.g:1,q[V+2]/=C.baseColor.b>B?C.baseColor.b:1;const v=b.Ih.FromInts(q[V],q[V+1],q[V+2]).toGammaSpace(H.getEngine().useExactSrgbConversions);q[V]=255*v.r,q[V+1]=255*v.g,q[V+2]=255*v.b,v.equalsWithEpsilon(L,B)||(S=!0),o[V+1]/=C.roughness>B?C.roughness:1,o[V+2]/=C.metallic>B?C.metallic:1;b.Ih.FromInts(255,o[V+1],o[V+2]).equalsWithEpsilon(L,B)||(l=!0)}return l&&A.push(this._getImageDataAsync(o,N,D,v).then((Z=>{C.metallicRoughnessTextureData=Z}))),S&&A.push(this._getImageDataAsync(q,N,D,v).then((Z=>{C.baseColorTextureData=Z}))),await Promise.all(A).then((()=>C))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Z){const h=this._getPerceivedBrightness(Z.diffuseColor),V=this._getPerceivedBrightness(Z.specularColor),v=1-this._getMaxComponent(Z.specularColor),A=W(h,V,v),H=Z.diffuseColor.scale(v/(1-S.r)/Math.max(1-A)),K=Z.specularColor.rh(S.scale(1-A)).scale(1/Math.max(A));let d=b.Ih.Lerp(H,K,A*A);d=d.clampToRef(0,1,d);return{baseColor:d,metallic:A,roughness:1-Z.glossiness}}_getPerceivedBrightness(Z){return Z?Math.sqrt(.299*Z.r*Z.r+.587*Z.g*Z.g+.114*Z.b*Z.b):0}_getMaxComponent(Z){return Z?Math.max(Z.r,Math.max(Z.g,Z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Z,h,V,v){const A=[],H={baseColor:Z._albedoColor,metallic:Z._metallic,roughness:Z._roughness};if(v){Z._albedoTexture&&A.push(this.exportTextureAsync(Z._albedoTexture,h).then((Z=>{Z&&(V.baseColorTexture=Z)})));const v=Z._metallicTexture;v&&A.push(this.exportTextureAsync(v,h).then((Z=>{Z&&(V.metallicRoughnessTexture=Z)})))}return A.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(A)),H}_getTextureSampler(Z){const h={};if(!Z||!(Z instanceof j.e))return h;const V=this._getGLTFTextureWrapMode(Z.wrapU);10497!==V&&(h.wrapS=V);const v=this._getGLTFTextureWrapMode(Z.wrapV);switch(10497!==v&&(h.wrapT=v),Z.samplingMode){case j.e.LINEAR_LINEAR:h.magFilter=9729,h.minFilter=9729;break;case j.e.LINEAR_NEAREST:h.magFilter=9729,h.minFilter=9728;break;case j.e.NEAREST_LINEAR:h.magFilter=9728,h.minFilter=9729;break;case j.e.NEAREST_LINEAR_MIPLINEAR:h.magFilter=9728,h.minFilter=9987;break;case j.e.NEAREST_NEAREST:h.magFilter=9728,h.minFilter=9728;break;case j.e.NEAREST_LINEAR_MIPNEAREST:h.magFilter=9728,h.minFilter=9985;break;case j.e.LINEAR_NEAREST_MIPNEAREST:h.magFilter=9729,h.minFilter=9984;break;case j.e.LINEAR_NEAREST_MIPLINEAR:h.magFilter=9729,h.minFilter=9986;break;case j.e.NEAREST_NEAREST_MIPLINEAR:h.magFilter=9728,h.minFilter=9986;break;case j.e.LINEAR_LINEAR_MIPLINEAR:h.magFilter=9729,h.minFilter=9987;break;case j.e.LINEAR_LINEAR_MIPNEAREST:h.magFilter=9729,h.minFilter=9985;break;case j.e.NEAREST_NEAREST_MIPNEAREST:h.magFilter=9728,h.minFilter=9984}return h}_getGLTFTextureWrapMode(Z){switch(Z){case j.e.WRAP_ADDRESSMODE:return 10497;case j.e.CLAMP_ADDRESSMODE:return 33071;case j.e.MIRROR_ADDRESSMODE:return 33648;default:return A.Tools.Error(`Unsupported Texture Wrap Mode ${Z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Z,h,V,v){const A={diffuseColor:Z._albedoColor,specularColor:Z._reflectivityColor,glossiness:Z._microSurface},H=Z._albedoTexture,K=Z._reflectivityTexture,d=Z._useMicroSurfaceFromReflectivityMapAlpha;if(K&&!d)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((H||K)&&v){this._exporter._materialNeedsUVsSet.add(Z);const v=this._exportTextureSampler(H||K),d=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(H,K,A,h),a=this._exporter._textures;if(d.baseColorTextureData){const Z=this._exportImage(`baseColor${a.length}`,h,d.baseColorTextureData);V.baseColorTexture=this._exportTextureInfo(Z,v,null===H||void 0===H?void 0:H.coordinatesIndex)}if(d.metallicRoughnessTextureData){const Z=this._exportImage(`metallicRoughness${a.length}`,h,d.metallicRoughnessTextureData);V.metallicRoughnessTexture=this._exportTextureInfo(Z,v,null===K||void 0===K?void 0:K.coordinatesIndex)}return d}return this._convertSpecularGlossinessToMetallicRoughness(A)}async exportPBRMaterialAsync(Z,h,V){const v={},A={name:Z.name},H=Z.isMetallicWorkflow();if(H){const h=Z._albedoColor,V=Z.alpha;h&&(v.baseColorFactor=[h.r,h.g,h.b,V])}const K=H?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Z,h,v,V):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Z,h,v,V);await this._setMetallicRoughnessPbrMaterialAsync(K,Z,A,v,h,V),await this._finishMaterialAsync(A,Z,h);const d=this._exporter._materials;return d.push(A),d.length-1}async _setMetallicRoughnessPbrMaterialAsync(Z,h,V,v,H,K){if(m(V,h),Z.baseColor.equalsWithEpsilon(L,B)&&X.WithinEpsilon(h.alpha,1,B)||(v.baseColorFactor=[Z.baseColor.r,Z.baseColor.g,Z.baseColor.b,h.alpha]),null!=Z.metallic&&1!==Z.metallic&&(v.metallicFactor=Z.metallic),null!=Z.roughness&&1!==Z.roughness&&(v.roughnessFactor=Z.roughness),null==h.Gh||h.Gh||(h._twoSidedLighting||A.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),V.doubleSided=!0),K){const Z=[],v=h._bumpTexture;v&&Z.push(this.exportTextureAsync(v,H).then((Z=>{Z&&(V.normalTexture=Z,1!==v.level&&(V.normalTexture.scale=v.level))})));const A=h._ambientTexture;A&&Z.push(this.exportTextureAsync(A,H).then((Z=>{if(Z){const v={index:Z.index,texCoord:Z.texCoord,extensions:Z.extensions};V.occlusionTexture=v;const A=h._ambientTextureStrength;A&&(v.strength=A)}})));const K=h._emissiveTexture;K&&Z.push(this.exportTextureAsync(K,H).then((Z=>{Z&&(V.emissiveTexture=Z)}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(Z))}const d=h._emissiveColor;d.equalsWithEpsilon(y,B)||(V.emissiveFactor=d.mh()),V.pbrMetallicRoughness=v}_getPixelsFromTextureAsync(Z){return function(Z){switch(Z){case C.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case C.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case C.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case C.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case C.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case C.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case C.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case C.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case C.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case C.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case C.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case C.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case C.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Z.textureFormat)?(0,E.f)(Z,Z._texture.width,Z._texture.height):(Z.textureType,C.e.TEXTURETYPE_UNSIGNED_BYTE,Z.readPixels())}async exportTextureAsync(Z,h){const V=this._exporter._extensionsPreExportTextureAsync("exporter",Z,h);return V?await V.then((async V=>V?await this._exportTextureInfoAsync(V,h):await this._exportTextureInfoAsync(Z,h))):await this._exportTextureInfoAsync(Z,h)}async _exportTextureInfoAsync(Z,h){let V=this._textureMap.get(Z);if(!V){const v=await this._getPixelsFromTextureAsync(Z);if(!v)return null;const H=this._exportTextureSampler(Z),K=Z.mimeType;if(K)switch(K){case"image/jpeg":case"image/png":case"image/webp":h=K;break;default:A.Tools.Warn(`Unsupported media type: ${K}. Exporting texture as PNG.`)}const d=this._internalTextureToImage,a=Z.getInternalTexture().uniqueId;d[a]||(d[a]={});let n=d[a][h];if(void 0===n){const V=Z.getSize();n=(async()=>{const A=await this._getImageDataAsync(v,V.width,V.height,h);return this._exportImage(Z.name,h,A)})(),d[a][h]=n}V=this._exportTextureInfo(await n,H,Z.coordinatesIndex),this._textureMap.set(Z,V),this._exporter._extensionsPostExportTextures("exporter",V,Z)}return V}_exportImage(Z,h,V){const v=this._exporter._images;let H;if(this._exporter._shouldUseGlb){H={name:Z,mimeType:h,bufferView:void 0};const v=this._exporter._bufferManager.createBufferView(new Uint8Array(V));this._exporter._bufferManager.setBufferView(H,v)}else{const K=Z.replace(/\.\/|\/|\.\\|\\/g,"_"),d=function(Z){switch(Z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(h);let a=K+d;v.some((Z=>Z.uri===a))&&(a=`${K}_${A.Tools.RandomId()}${d}`),H={name:Z,uri:a},this._exporter._imageData[a]={data:V,mimeType:h}}return v.push(H),v.length-1}_exportTextureInfo(Z,h,V){const v=this._exporter._textures;let A=v.findIndex((V=>V.sampler==h&&V.source===Z));-1===A&&(A=v.length,v.push({source:Z,sampler:h}));const H={index:A};return V&&(H.texCoord=V),H}_exportTextureSampler(Z){const h=this._getTextureSampler(Z),V=this._exporter._samplers,v=V.findIndex((Z=>Z.minFilter===h.minFilter&&Z.magFilter===h.magFilter&&Z.wrapS===h.wrapS&&Z.wrapT===h.wrapT));return-1!==v?v:(V.push(h),V.length-1)}}var U=V(11822),R=V(11580),Q=V(12222),w=V(11737);const T=v.Ch.Zero(),t=v.Quaternion.Identity(),c=v.Ch.One(),i=new v.Ch(-1,1,1);function M(Z,h){const{byteOffset:V,byteStride:v,type:A,normalized:H}=Z,K=Z.getSize(),d=h.reduce(((Z,h)=>h.getTotalVertices()>Z?h.getTotalVertices():Z),-Number.MAX_VALUE);return{byteOffset:V,byteStride:v,componentCount:K,type:A,count:d*K,normalized:H,totalVertices:d,kind:Z.getKind()}}function O(Z){switch(Z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function s(Z){switch(Z){case x.f.PositionKind:case x.f.NormalKind:case x.f.TangentKind:case x.f.ColorKind:case x.f.MatricesIndicesKind:case x.f.MatricesIndicesExtraKind:case x.f.MatricesWeightsKind:case x.f.MatricesWeightsExtraKind:case x.f.UVKind:case x.f.UV2Kind:case x.f.UV3Kind:case x.f.UV4Kind:case x.f.UV5Kind:case x.f.UV6Kind:return!0}return!1}function J(Z){switch(Z){case H.b.TriangleFillMode:return 4;case H.b.TriangleStripDrawMode:return 5;case H.b.TriangleFanDrawMode:return 6;case H.b.PointListDrawMode:case H.b.PointFillMode:return 0;case H.b.LineLoopDrawMode:return 2;case H.b.LineListDrawMode:return 1;case H.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Z}`)}function f(Z){const h=Math.sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);h>0&&(Z.x/=h,Z.y/=h,Z.z/=h)}function p(Z){return Z.x*=-1,Z}function Y(Z){if(Z.x*Z.x+Z.y*Z.y>.5){const h=Math.abs(Z.x),V=Math.abs(Z.y);if(h>V){const V=Math.sign(Z.x);Z.x=h,Z.y*=-V,Z.z*=-V,Z.w*=V}else{const h=Math.sign(Z.y);Z.x*=-h,Z.y=V,Z.z*=h,Z.w*=-h}}else{const h=Math.abs(Z.z),V=Math.abs(Z.w);if(h>V){const V=Math.sign(Z.z);Z.x*=-V,Z.y*=V,Z.z=h,Z.w*=-V}else{const h=Math.sign(Z.w);Z.x*=h,Z.y*=-h,Z.z*=-h,Z.w=V}}return Z}function G(Z){Z.IV(-Z.z,Z.w,Z.x,-Z.y)}function ZZ(Z,h){const V=v.Ch.FromArrayToRef(h.translation||[0,0,0],0,v.TmpVectors.Ch[0]),A=v.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,v.TmpVectors.Quaternion[0]),H=v.Matrix.ComposeToRef(c,A,V,v.TmpVectors.Matrix[0]),K=v.Ch.FromArrayToRef(Z.translation||[0,0,0],0,v.TmpVectors.Ch[2]),d=v.Quaternion.FromArrayToRef(Z.rotation||[0,0,0,1],0,v.TmpVectors.Quaternion[1]),a=v.Matrix.ComposeToRef(c,d,K,v.TmpVectors.Matrix[1]);H.multiplyToRef(a,a),a.decompose(void 0,A,V),V.equalsWithEpsilon(T,w.c)?delete h.translation:h.translation=V.mh(),A.equalsWithEpsilon(t,w.c)?delete h.rotation:h.rotation=A.mh(),h.scale&&delete h.scale}function hZ(Z,h){if(!(h instanceof N.d))return!1;if(!(1===h.getChildren().length&&0===Z.getChildren().length&&Z.parent===h))return!1;const V=Z.CZ(),v=Z instanceof Q.e&&!V.useRightHandedSystem?i:c;return!!h.tv.equalsWithEpsilon(v,w.c)||(R.b.Warn(`Cannot collapse node ${Z.name} into parent node ${h.name} with modified scaling.`),!1)}function VZ(Z){if(Z instanceof Array){const h=new Float32Array(Z);return new Uint8Array(h.buffer,h.byteOffset,h.byteLength)}return ArrayBuffer.isView(Z)?new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength):new Uint8Array(Z)}function vZ(Z,h){for(const[V,v]of Object.entries(Z)){const A=h[V];(Array.isArray(v)&&Array.isArray(A)&&AZ(v,A)||v===A)&&delete Z[V]}return Z}function AZ(Z,h){return Z.length===h.length&&Z.every(((Z,V)=>Z===h[V]))}const HZ=v.Matrix.Compose(new v.Ch(-1,1,1),v.Quaternion.Identity(),v.Ch.Zero());function KZ(Z,h){if(!(Z instanceof N.d))return!1;if(h){if(!Z.getWorldMatrix().equalsWithEpsilon(v.Matrix.IdentityReadOnly,w.c))return!1}else{if(!Z.getWorldMatrix().multiplyToRef(HZ,v.TmpVectors.Matrix[0]).equalsWithEpsilon(v.Matrix.IdentityReadOnly,w.c))return!1}return!(Z instanceof D.e&&Z.Jh)}const dZ=new Map([[Int8Array,(Z,h,V)=>Z.setInt8(h,V)],[Uint8Array,(Z,h,V)=>Z.setUint8(h,V)],[Uint8ClampedArray,(Z,h,V)=>Z.setUint8(h,V)],[Int16Array,(Z,h,V)=>Z.setInt16(h,V,!0)],[Uint16Array,(Z,h,V)=>Z.setUint16(h,V,!0)],[Int32Array,(Z,h,V)=>Z.setInt32(h,V,!0)],[Uint32Array,(Z,h,V)=>Z.setUint32(h,V,!0)],[Float32Array,(Z,h,V)=>Z.setFloat32(h,V,!0)],[Float64Array,(Z,h,V)=>Z.setFloat64(h,V,!0)]]);class aZ{writeTypedArray(Z){this._checkGrowBuffer(Z.byteLength);const h=dZ.get(Z.constructor);for(let V=0;V<Z.length;V++)h(this._dataView,this._byteOffset,Z[V]),this._byteOffset+=Z.BYTES_PER_ELEMENT}constructor(Z){this._data=new Uint8Array(Z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Z),this._byteOffset++}writeInt8(Z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Z),this._byteOffset++}writeInt16(Z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Z,!0),this._byteOffset+=2}writeUInt16(Z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Z,!0),this._byteOffset+=2}writeInt32(Z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Z,!0),this._byteOffset+=4}writeUInt32(Z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat32(Z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat64(Z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Z,!0),this._byteOffset+=8}_checkGrowBuffer(Z){const h=this.byteOffset+Z;if(h>this._data.byteLength){const Z=new Uint8Array(2*h);Z.set(this._data),this._data=Z,this._dataView=new DataView(this._data.buffer)}}}function nZ(Z){return Z%4===0?4:Z%2===0?2:1}class xZ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Z){let h=0;this._bufferViewToData.forEach((Z=>{h+=Z.byteLength}));const V=new aZ(h),v=Array.from(this._bufferViewToData.keys()).sort(((Z,h)=>nZ(h.byteLength)-nZ(Z.byteLength)));for(const A of v){A.byteOffset=V.byteOffset,Z.push(A);const h=Z.length-1,v=this.getPropertiesWithBufferView(A);for(const Z of v)Z.bufferView=h;V.writeTypedArray(this._bufferViewToData.get(A)),this._bufferViewToData.delete(A)}return V.getOutputData()}createBufferView(Z,h){const V={buffer:0,byteOffset:void 0,byteLength:Z.byteLength,byteStride:h};return this._bufferViewToData.set(V,Z),V}createAccessor(Z,h,V,v,A,H,K){this._verifyBufferView(Z);const d={bufferView:void 0,componentType:V,count:v,type:h,min:null===H||void 0===H?void 0:H.min,max:null===H||void 0===H?void 0:H.max,normalized:K,byteOffset:A};return this.setBufferView(d,Z),this._accessorToBufferView.set(d,Z),d}setBufferView(Z,h){this._verifyBufferView(h);this.getPropertiesWithBufferView(h).push(Z)}removeBufferView(Z){const h=this.getPropertiesWithBufferView(Z);for(const V of h)void 0!==V.bufferView&&delete V.bufferView;this._bufferViewToData.delete(Z),this._bufferViewToProperties.delete(Z),this._accessorToBufferView.forEach(((h,V)=>{h===Z&&(void 0!==V.byteOffset&&delete V.byteOffset,this._accessorToBufferView.delete(V))}))}getBufferView(Z){const h=this._accessorToBufferView.get(Z);return this._verifyBufferView(h),h}getPropertiesWithBufferView(Z){return this._verifyBufferView(Z),this._bufferViewToProperties.set(Z,this._bufferViewToProperties.get(Z)??[]),this._bufferViewToProperties.get(Z)}getData(Z){return this._verifyBufferView(Z),this._bufferViewToData.get(Z)}_verifyBufferView(Z){if(void 0===Z||!this._bufferViewToData.has(Z))throw new Error(`BufferView ${Z} not found in BufferManager.`)}}var NZ,DZ=V(12192),kZ=V(12207),uZ=V(12230),FZ=V(12102),bZ=V(12268),oZ=V(12278),qZ=V(12184),XZ=V(12281);!function(Z){Z[Z.INTANGENT=0]="INTANGENT",Z[Z.OUTTANGENT=1]="OUTTANGENT"}(NZ||(NZ={}));class EZ{static _IsTransformable(Z){return Z&&(Z instanceof N.d||Z instanceof DZ.e||Z instanceof XZ.c)}static _CreateNodeAnimation(Z,h,V,v,H){if(this._IsTransformable(Z)){const K=[],d=[],a=h.getKeys(),n=EZ._CalculateMinMaxKeyFrames(a),x=EZ._DeduceInterpolation(a,V,v),N=x.interpolationType,D=x.shouldBakeAnimation;if(D?EZ._CreateBakedAnimation(Z,h,V,n.min,n.max,h.framePerSecond,H,K,d,n,v):"LINEAR"===N||"STEP"===N?EZ._CreateLinearOrStepAnimation(Z,h,V,K,d,v):"CUBICSPLINE"===N?EZ._CreateCubicSplineAnimation(Z,h,V,K,d,v):EZ._CreateBakedAnimation(Z,h,V,n.min,n.max,h.framePerSecond,H,K,d,n,v),K.length&&d.length){return{inputs:K,outputs:d,samplerInterpolation:N,inputsMin:D?n.min:A.Tools.FloatRound(n.min/h.framePerSecond),inputsMax:D?n.max:A.Tools.FloatRound(n.max/h.framePerSecond)}}}return null}static _DeduceAnimationInfo(Z){let h=null,V="VEC3",v=!1;const H=Z.targetProperty.split(".");switch(H[0]){case"tv":h="scale";break;case"position":h="translation";break;case"rotation":V="VEC4",h="rotation";break;case"rotationQuaternion":V="VEC4",v=!0,h="rotation";break;case"influence":V="SCALAR",h="weights";break;default:A.Tools.Error(`Unsupported animatable property ${H[0]}`)}return h?{animationChannelTargetPath:h,dataAccessorType:V,useQuaternion:v}:(A.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Z,h,V,v,A,H,K,d,a,n,x){let N;if(EZ._IsTransformable(Z)&&Z.animations)for(const D of Z.animations){if(x&&!x(D))continue;const A=EZ._DeduceAnimationInfo(D);A&&(N={name:D.name,samplers:[],channels:[]},EZ._AddAnimation(`${D.name}`,D.hasRunningRuntimeAnimations?h:N,Z,D,A.dataAccessorType,A.animationChannelTargetPath,v,H,K,d,A.useQuaternion,a,n),N.samplers.length&&N.channels.length&&V.push(N))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Z,h,V,v,A,H,K,d,a,n,x){let N;if(Z instanceof qZ.c){const A=Z.morphTargetManager;if(A)for(let D=0;D<A.numTargets;++D){const k=A.getTarget(D);for(const u of k.animations){if(x&&!x(u))continue;const k=new bZ.c(`${u.name}`,"influence",u.framePerSecond,u.dataType,u.loopMode,u.enableBlending),F=[],b=u.getKeys();for(let Z=0;Z<b.length;++Z){const h=b[Z];for(let Z=0;Z<A.numTargets;++Z)Z==D?F.push(h):F.push({frame:h.frame,value:0})}k.setKeys(F);const o=EZ._DeduceAnimationInfo(k);o&&(N={name:k.name,samplers:[],channels:[]},EZ._AddAnimation(u.name,u.hasRunningRuntimeAnimations?h:N,Z,k,o.dataAccessorType,o.animationChannelTargetPath,v,H,K,d,o.useQuaternion,a,n,A.numTargets),N.samplers.length&&N.channels.length&&V.push(N))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Z,h,V,v,A,H,K,d,a){let n;if(Z.animationGroups){const N=Z.animationGroups;for(const D of N){const N=new Map,k=new Map,u=new Set,F=D.to-D.from;n={name:D.name,channels:[],samplers:[]};for(let h=0;h<D.targetedAnimations.length;++h){const F=D.targetedAnimations[h],b=F.target,o=F.animation;if(a&&!a(o))continue;const q=d.has(b);if(this._IsTransformable(b)||1===b.length&&this._IsTransformable(b[0])){const Z=EZ._DeduceAnimationInfo(F.animation);if(Z){const h=this._IsTransformable(b)?b:this._IsTransformable(b[0])?b[0]:null;h&&EZ._AddAnimation(`${o.name}`,n,h,o,Z.dataAccessorType,Z.animationChannelTargetPath,V,v,A,H,Z.useQuaternion,K,q)}}else if(b instanceof oZ.c||1===b.length&&b[0]instanceof oZ.c){if(EZ._DeduceAnimationInfo(F.animation)){const h=b instanceof oZ.c?b:b[0];if(h){const V=Z.morphTargetManagers.find((Z=>{for(let V=0;V<Z.numTargets;++V)if(Z.getTarget(V)===h)return!0;return!1}));if(V){const v=Z.meshes.find((Z=>Z.morphTargetManager===V));var x;if(v)N.has(v)||N.set(v,new Map),null===(x=N.get(v))||void 0===x||x.set(h,o),u.add(v),k.set(v,o)}}}}}u.forEach((Z=>{const h=Z.morphTargetManager;let d=null;const a=[],x=k.get(Z).getKeys(),u=x.length;for(let V=0;V<u;++V)for(let v=0;v<h.numTargets;++v){const A=h.getTarget(v),H=N.get(Z);if(H){const h=H.get(A);h?(d||(d=new bZ.c(`${D.name}_${Z.name}_MorphWeightAnimation`,"influence",h.framePerSecond,bZ.c.ANIMATIONTYPE_FLOAT,h.loopMode,h.enableBlending)),a.push(h.getKeys()[V])):a.push({frame:D.from+F/u*V,value:A.influence,inTangent:x[0].inTangent?0:void 0,outTangent:x[0].outTangent?0:void 0})}}d.setKeys(a);const b=EZ._DeduceAnimationInfo(d);b&&EZ._AddAnimation(`${D.name}_${Z.name}_MorphWeightAnimation`,n,Z,d,b.dataAccessorType,b.animationChannelTargetPath,V,v,A,H,b.useQuaternion,K,!1,null===h||void 0===h?void 0:h.numTargets)})),n.channels.length&&n.samplers.length&&h.push(n)}}}static _AddAnimation(Z,h,V,A,H,K,d,a,n,x,N,D,k,u){const F=EZ._CreateNodeAnimation(V,A,K,N,D);let b,o,q,X,E,j;if(F){if(u){let Z=0,h=0;const V=[];for(;F.inputs.length>0;)h=F.inputs.shift(),Z%u==0&&V.push(h),Z++;F.inputs=V}const Z=d.get(V),A=new Float32Array(F.inputs);b=a.createBufferView(A),o=a.createAccessor(b,"SCALAR",5126,F.inputs.length,void 0,{min:[F.inputsMin],max:[F.inputsMax]}),x.push(o),q=x.length-1;const n=new v.Quaternion,N=new v.Ch,D=new v.Ch,P=V instanceof DZ.e,C=O(H),l=new Float32Array(F.outputs.length*C);F.outputs.forEach((function(Z,h){let V=Z;switch(K){case"translation":k&&(v.Ch.FromArrayToRef(Z,0,D),p(D),D.toArray(V));break;case"rotation":4===Z.length?v.Quaternion.FromArrayToRef(Z,0,n):(V=new Array(4),v.Ch.FromArrayToRef(Z,0,N),v.Quaternion.FromEulerVectorToRef(N,n)),k&&(Y(n),P&&G(n)),n.toArray(V)}l.set(V,h*C)})),b=a.createBufferView(l),o=a.createAccessor(b,H,5126,F.outputs.length),x.push(o),X=x.length-1,E={interpolation:F.samplerInterpolation,input:q,output:X},h.samplers.push(E),j={sampler:h.samplers.length-1,target:{node:Z,path:K}},h.channels.push(j)}}static _CreateBakedAnimation(Z,h,V,H,K,d,a,n,x,N,D){let k;const u=v.Quaternion.Identity();let F,b=null,o=null,q=null,X=null,E=null,j=null;N.min=A.Tools.FloatRound(H/d);const P=h.getKeys();for(let v=0,C=P.length;v<C;++v){if(j=null,q=P[v],v+1<C)if(X=P[v+1],q.value.equals&&q.value.equals(X.value)||q.value===X.value){if(0!==v)continue;j=q.frame}else j=X.frame;else{if(E=P[v-1],q.value.equals&&q.value.equals(E.value)||q.value===E.value)continue;j=K}if(j)for(let v=q.frame;v<=j;v+=a){if(F=A.Tools.FloatRound(v/d),F===b)continue;b=F,o=F;const H={key:0,repeatCount:0,loopMode:h.loopMode};k=h._interpolate(v,H),EZ._SetInterpolatedValue(Z,k,F,h,V,u,n,x,D)}}o&&(N.max=o)}static _ConvertFactorToVector3OrQuaternion(Z,h,V,H,K){const d=EZ._GetBasePositionRotationOrScale(h,H,K),a=V.targetProperty.split("."),n=a?a[1]:"",x=K?v.Quaternion.eh(d).normalize():v.Ch.eh(d);switch(n){case"x":case"y":case"z":x[n]=Z;break;case"w":x.w=Z;break;default:A.Tools.Error(`glTFAnimation: Unsupported component name "${n}"!`)}return x}static _SetInterpolatedValue(Z,h,V,A,H,K,d,a,n){let x;d.push(V),"weights"!==H?(A.dataType===bZ.c.ANIMATIONTYPE_FLOAT&&(h=this._ConvertFactorToVector3OrQuaternion(h,Z,A,H,n)),"rotation"===H?(n?K=h:(x=h,v.Quaternion.RotationYawPitchRollToRef(x.y,x.x,x.z,K)),a.push(K.mh())):(x=h,a.push(x.mh()))):a.push([h])}static _CreateLinearOrStepAnimation(Z,h,V,v,A,H){for(const K of h.getKeys())v.push(K.frame/h.framePerSecond),EZ._AddKeyframeValue(K,h,A,V,Z,H)}static _CreateCubicSplineAnimation(Z,h,V,v,A,H){h.getKeys().forEach((function(K){v.push(K.frame/h.framePerSecond),EZ._AddSplineTangent(NZ.INTANGENT,A,V,"CUBICSPLINE",K,H),EZ._AddKeyframeValue(K,h,A,V,Z,H),EZ._AddSplineTangent(NZ.OUTTANGENT,A,V,"CUBICSPLINE",K,H)}))}static _GetBasePositionRotationOrScale(Z,h,V){let A;if("rotation"===h)if(V){A=(Z.rotationQuaternion??v.Quaternion.Identity()).mh()}else{A=(Z.rotation??v.Ch.Zero()).mh()}else if("translation"===h){A=(Z.position??v.Ch.Zero()).mh()}else{A=(Z.tv??v.Ch.One()).mh()}return A}static _AddKeyframeValue(Z,h,V,H,K,d){let a;const n=h.dataType;if(n===bZ.c.ANIMATIONTYPE_VECTOR3){let h=Z.value.mh();if("rotation"===H){const Z=v.Ch.eh(h);h=v.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).mh()}V.push(h)}else if(n===bZ.c.ANIMATIONTYPE_FLOAT){if("weights"===H)V.push([Z.value]);else if(a=this._ConvertFactorToVector3OrQuaternion(Z.value,K,h,H,d),a){if("rotation"===H){const Z=d?a:v.Quaternion.RotationYawPitchRoll(a.y,a.x,a.z).normalize();V.push(Z.mh())}V.push(a.mh())}}else n===bZ.c.ANIMATIONTYPE_QUATERNION?V.push(Z.value.normalize().mh()):A.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Z,h,V){let v,A,H=!1;if("rotation"===h&&!V)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let K=0,d=Z.length;K<d;++K)if(A=Z[K],A.inTangent||A.outTangent)if(v){if("CUBICSPLINE"!==v){v="LINEAR",H=!0;break}}else v="CUBICSPLINE";else if(v){if("CUBICSPLINE"===v||A.interpolation&&1===A.interpolation&&"STEP"!==v){v="LINEAR",H=!0;break}}else v=A.interpolation&&1===A.interpolation?"STEP":"LINEAR";return v||(v="LINEAR"),{interpolationType:v,shouldBakeAnimation:H}}static _AddSplineTangent(Z,h,V,A,H,K){let d;const a=Z===NZ.INTANGENT?H.inTangent:H.outTangent;if("CUBICSPLINE"===A){if("rotation"===V)if(a)if(K)d=a.mh();else{const Z=a;d=v.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).mh()}else d=[0,0,0,0];else d="weights"===V?a?[a]:[0]:a?a.mh():[0,0,0];h.push(d)}}static _CalculateMinMaxKeyFrames(Z){let h=1/0,V=-1/0;return Z.forEach((function(Z){h=Math.min(h,Z.frame),V=Math.max(V,Z.frame)})),{min:h,max:V}}}function jZ(Z,h,V,H,K,d){const a={attributes:{},influence:Z.influence,name:Z.name},n=h.Jh;if(!n)return A.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),a;const N=d?-1:1,D=v.Ch.Zero();let k=0,u=0;if(Z.hasPositions){const H=Z.getPositions(),d=n.getVerticesData(x.f.PositionKind);if(d){const Z=new Float32Array(d.length),h=[1/0,1/0,1/0],A=[-1/0,-1/0,-1/0];u=d.length/3,k=0;for(let V=k;V<u;++V){const K=v.Ch.eh(d,3*V);v.Ch.eh(H,3*V).subtractToRef(K,D),D.x*=N,h[0]=Math.min(h[0],D.x),A[0]=Math.max(A[0],D.x),h[1]=Math.min(h[1],D.y),A[1]=Math.max(A[1],D.y),h[2]=Math.min(h[2],D.z),A[2]=Math.max(A[2],D.z),Z[3*V]=D.x,Z[3*V+1]=D.y,Z[3*V+2]=D.z}const n=V.createBufferView(Z,12),x=V.createAccessor(n,"VEC3",5126,H.length/3,0,{min:h,max:A});K.push(x),a.attributes.POSITION=K.length-1}else A.Tools.Warn(`Morph target positions for mesh ${h.name} were not exported. Mesh does not have position vertex data`)}if(Z.hasNormals){const H=Z.getNormals(),d=n.getVerticesData(x.f.NormalKind);if(d){const Z=new Float32Array(d.length);u=d.length/3,k=0;for(let V=k;V<u;++V){const h=v.Ch.eh(d,3*V).normalize();v.Ch.eh(H,3*V).normalize().subtractToRef(h,D),Z[3*V]=D.x*N,Z[3*V+1]=D.y,Z[3*V+2]=D.z}const h=V.createBufferView(Z,12),A=V.createAccessor(h,"VEC3",5126,H.length/3,0);K.push(A),a.attributes.NORMAL=K.length-1}else A.Tools.Warn(`Morph target normals for mesh ${h.name} were not exported. Mesh does not have normals vertex data`)}if(Z.hasTangents){const H=Z.getTangents(),d=n.getVerticesData(x.f.TangentKind);if(d){u=d.length/4;const Z=new Float32Array(3*u);k=0;for(let V=k;V<u;++V){const h=v.Ch.eh(d,4*V);f(h);const A=v.Ch.eh(H,3*V);f(A),A.subtractToRef(h,D),Z[3*V]=D.x*N,Z[3*V+1]=D.y,Z[3*V+2]=D.z}const h=V.createBufferView(Z,12),A=V.createAccessor(h,"VEC3",5126,u,0);K.push(A),a.attributes.TANGENT=K.length-1}else A.Tools.Warn(`Morph target tangents for mesh ${h.name} were not exported. Mesh does not have tangents vertex data`)}if(Z.hasColors){const H=Z.getColors(),d=n.getVerticesData(x.f.ColorKind),N=n.getVertexBuffer(x.f.ColorKind);if(d&&N){const Z=N.getSize();u=d.length/Z;const h=new Float32Array(u*Z);k=0;for(let V=k;V<u;++V)if(3===Z){const A=v.Ch.eh(d,V*Z);v.Ch.eh(H,V*Z).subtractToRef(A,D),h[3*V]=D.x,h[3*V+1]=D.y,h[3*V+2]=D.z}else if(4===Z){const A=new v.Vector4,K=v.Vector4.eh(d,V*Z);v.Vector4.eh(H,V*Z).subtractToRef(K,A),h[4*V]=A.x,h[4*V+1]=A.y,h[4*V+2]=A.z,h[4*V+3]=A.w}else A.Tools.Warn(`Unsupported number of components for color attribute: ${Z}`);const n=V.createBufferView(h,4*Z),x=V.createAccessor(n,3===Z?"VEC3":"VEC4",5126,u,0);K.push(x),a.attributes.COLOR_0=K.length-1}else A.Tools.Warn(`Morph target colors for mesh ${h.name} were not exported. Mesh does not have colors vertex data`)}return a}var PZ=V(12287),CZ=V(12131),lZ=V(12115),BZ=V(11691);class SZ{}SZ.DEFAULT_COLOR=b.Ih.White(),SZ.DEFAULT_WIDTH_ATTENUATED=1,SZ.DEFAULT_WIDTH=.1;var rZ=V(11954),LZ=V(12295);class yZ{static ConvertPoints(Z,h){if(Z.length&&Array.isArray(Z)&&"number"===typeof Z[0])return[Z];if(Z.length&&Array.isArray(Z[0])&&"number"===typeof Z[0][0])return Z;if(Z.length&&!Array.isArray(Z[0])&&Z[0]instanceof v.Ch){const h=[];for(let V=0;V<Z.length;V++){const v=Z[V];h.push(v.x,v.y,v.z)}return[h]}if(Z.length>0&&Array.isArray(Z[0])&&Z[0].length>0&&Z[0][0]instanceof v.Ch){const h=[],V=Z;for(const Z of V)h.push(Z.flatMap((Z=>[Z.x,Z.y,Z.z])));return h}if(Z instanceof Float32Array){if(null!==h&&void 0!==h&&h.floatArrayStride){const V=[],v=3*h.floatArrayStride;for(let h=0;h<Z.length;h+=v){const A=new Array(v);for(let V=0;V<v;V++)A[V]=Z[h+V];V.push(A)}return V}return[Array.from(Z)]}if(Z.length&&Z[0]instanceof Float32Array){const h=[];for(const V of Z)h.push(Array.from(V));return h}return[]}static OmitZeroLengthPredicate(Z,h,V){const v=[];return h.rh(Z).lengthSquared()>0&&v.push([Z,h]),V.rh(h).lengthSquared()>0&&v.push([h,V]),Z.rh(V).lengthSquared()>0&&v.push([V,Z]),0===v.length?null:v}static OmitDuplicatesPredicate(Z,h,V,v){const A=[];return yZ._SearchInPoints(Z,h,v)||A.push([Z,h]),yZ._SearchInPoints(h,V,v)||A.push([h,V]),yZ._SearchInPoints(V,Z,v)||A.push([V,Z]),0===A.length?null:A}static _SearchInPoints(Z,h,V){for(const K of V)for(let V=0;V<K.length;V++){var v,A,H;if(null!==(v=K[V])&&void 0!==v&&v.equals(Z))if(null!==(A=K[V+1])&&void 0!==A&&A.equals(h)||null!==(H=K[V-1])&&void 0!==H&&H.equals(h))return!0}return!1}static MeshesToLines(Z,h){const V=[];for(let A=0;A<Z.length;A++){const H=Z[A],K=H.getVerticesData(x.f.PositionKind),d=H.fh();if(K&&d)for(let Z=0,a=0;Z<d.length;Z++){const n=3*d[a++],x=3*d[a++],N=3*d[a++],D=new v.Ch(K[n],K[n+1],K[n+2]),k=new v.Ch(K[x],K[x+1],K[x+2]),u=new v.Ch(K[N],K[N+1],K[N+2]);if(h){const v=h(D,k,u,V,Z,n,H,A,K,d);if(v)for(const Z of v)V.push(Z)}else V.push([D,k],[k,u],[u,D])}}return V}static ToVector3Array(Z){if(Array.isArray(Z[0])){const h=[],V=Z;for(const Z of V){const V=[];for(let h=0;h<Z.length;h+=3)V.push(new v.Ch(Z[h],Z[h+1],Z[h+2]));h.push(V)}return h}const h=Z,V=[];for(let A=0;A<h.length;A+=3)V.push(new v.Ch(h[A],h[A+1],h[A+2]));return V}static ToNumberArray(Z){return Z.flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetPointsCountInfo(Z){const h=new Array(Z.length);let V=0;for(let v=Z.length;v--;)h[v]=Z[v].length/3,V+=h[v];return{total:V,counts:h}}static GetLineLength(Z){if(0===Z.length)return 0;let h;h="number"===typeof Z[0]?yZ.ToVector3Array(Z):Z;const V=v.TmpVectors.Ch[0];let A=0;for(let v=0;v<h.length-1;v++){const Z=h[v];A+=h[v+1].subtractToRef(Z,V).length()}return A}static GetLineLengthArray(Z){const h=new Float32Array(Z.length/3);let V=0;for(let v=0,A=Z.length/3-1;v<A;v++){let A=Z[3*v+0],H=Z[3*v+1],K=Z[3*v+2];A-=Z[3*v+3],H-=Z[3*v+4],K-=Z[3*v+5];V+=Math.sqrt(A*A+H*H+K*K),h[v+1]=V}return h}static SegmentizeSegmentByCount(Z,h,V){const A=[],H=h.rh(Z),K=v.TmpVectors.Ch[0];K.vd(V);const d=v.TmpVectors.Ch[1];H.divideToRef(K,d);let a=Z.clone();A.push(a);for(let v=0;v<V;v++)a=a.clone(),A.push(a.addInPlace(d));return A}static SegmentizeLineBySegmentLength(Z,h){const V=Z[0]instanceof v.Ch?yZ.GetLineSegments(Z):"number"===typeof Z[0]?yZ.GetLineSegments(yZ.ToVector3Array(Z)):Z,A=[];for(const v of V)if(v.length>h){const Z=yZ.SegmentizeSegmentByCount(v.point1,v.point2,Math.ceil(v.length/h));for(const h of Z)A.push(h)}else A.push(v.point1),A.push(v.point2);return A}static SegmentizeLineBySegmentCount(Z,h){const V="number"===typeof Z[0]?yZ.ToVector3Array(Z):Z,v=yZ.GetLineLength(V)/h;return yZ.SegmentizeLineBySegmentLength(V,v)}static GetLineSegments(Z){const h=[];for(let V=0;V<Z.length-1;V++){const v=Z[V],A=Z[V+1],H=A.rh(v).length();h.push({point1:v,point2:A,length:H})}return h}static GetMinMaxSegmentLength(Z){const h=yZ.GetLineSegments(Z).sort((Z=>Z.length));return{min:h[0].length,max:h[h.length-1].length}}static GetPositionOnLineByVisibility(Z,h,V){let A=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const H=h*V;let K=0,d=0;const a=Z.length;for(let v=0;v<a;v++){if(H<=K+Z[v].length){d=v;break}K+=Z[v].length}const n=(H-K)/Z[d].length;return Z[d].point2.subtractToRef(Z[d].point1,v.TmpVectors.Ch[0]),v.TmpVectors.Ch[1]=v.TmpVectors.Ch[0].multiplyByFloats(n,n,n),A||v.TmpVectors.Ch[1].addInPlace(Z[d].point1),v.TmpVectors.Ch[1].clone()}static GetCircleLinePoints(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,A=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,H=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/h;const K=[];for(let d=0;d<=h;d++)K.push(new v.Ch(Math.cos(d*H)*Z,Math.sin(d*H)*A,V));return K}static GetBezierLinePoints(Z,h,V,v){return rZ.g.CreateQuadraticBezier(Z,h,V,v).getPoints().flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetArrowCap(Z,h,V,v,A){let H=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Z.clone(),Z.add(h.multiplyByFloats(V,V,V))],widths:[v,A,H,K]}}static GetPointsFromText(Z,h,V,v){let A=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,H=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const K=[],d=(0,LZ.d)(Z,h,V,v);for(const a of d){for(const Z of a.paths){const h=[],V=Z.getPoints();for(const Z of V)h.push(Z.x,Z.y,A);K.push(h)}if(H)for(const Z of a.holes){const h=[],V=Z.getPoints();for(const Z of V)h.push(Z.x,Z.y,A);K.push(h)}}return K}static Color3toRGBAUint8(Z){const h=new Uint8Array(4*Z.length);for(let V=0,v=0;V<Z.length;V++)h[v++]=255*Z[V].r,h[v++]=255*Z[V].g,h[v++]=255*Z[V].b,h[v++]=255;return h}static CreateColorsTexture(Z,h,V,v){const A=v.getEngine().getCaps().maxTextureSize??1,H=h.length>A?A:h.length,K=Math.ceil(h.length/A);K>1&&(h=[...h,...Array(H*K-h.length).fill(h[0])]);const d=yZ.Color3toRGBAUint8(h),a=new P.d(d,H,K,u.b.TEXTUREFORMAT_RGBA,v,!1,!0,V);return a.name=Z,a}static PrepareEmptyColorsTexture(Z){if(!SZ.EmptyColorsTexture){const h=new Uint8Array(4);SZ.EmptyColorsTexture=new P.d(h,1,1,u.b.TEXTUREFORMAT_RGBA,Z,!1,!1,P.d.NEAREST_NEAREST),SZ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return SZ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Z;null===(Z=SZ.EmptyColorsTexture)||void 0===Z||Z.dispose(),SZ.EmptyColorsTexture=null}static BooleanToNumber(Z){return Z?1:0}}class WZ extends lZ.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class zZ extends CZ.d{isCompatible(Z){return!0}constructor(Z,h,V){var A;V=V||{color:SZ.DEFAULT_COLOR};const H=new WZ;H.GREASED_LINE_HAS_COLOR=!!V.color&&!V.useColors,H.GREASED_LINE_SIZE_ATTENUATION=V.sizeAttenuation??!1,H.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===V.colorDistributionType,H.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(h??Z.CZ()).useRightHandedSystem,H.GREASED_LINE_CAMERA_FACING=V.cameraFacing??!0,super(Z,zZ.GREASED_LINE_MATERIAL_NAME,200,H,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(A=V)||void 0===A?void 0:A.forceGLSL)||zZ.ForceGLSL,this._scene=h??Z.CZ(),this._engine=this._scene.getEngine(),this._cameraFacing=V.cameraFacing??!0,this.visibility=V.visibility??1,this.useDash=V.useDash??!1,this.dashRatio=V.dashRatio??.5,this.dashOffset=V.dashOffset??0,this.width=V.width?V.width:V.sizeAttenuation?SZ.DEFAULT_WIDTH_ATTENUATED:SZ.DEFAULT_WIDTH,this._sizeAttenuation=V.sizeAttenuation??!1,this.colorMode=V.colorMode??0,this._color=V.color??null,this.useColors=V.useColors??!1,this._colorsDistributionType=V.colorDistributionType??0,this.colorsSampling=V.colorsSampling??P.d.NEAREST_NEAREST,this._colors=V.rZ??null,this.dashCount=V.dashCount??1,this.resolution=V.resolution??new v.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),V.colorsTexture?this.colorsTexture=V.colorsTexture:this._colors?this.colorsTexture=yZ.CreateColorsTexture(`${Z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??SZ.DEFAULT_COLOR,yZ.PrepareEmptyColorsTexture(this._scene)),this._engine.jh.add((()=>{yZ.DisposeEmptyColorsTexture()}))}getAttributes(Z){Z.push("grl_offsets"),Z.push("grl_widths"),Z.push("grl_colorPointers"),Z.push("grl_counters"),this._cameraFacing?(Z.push("grl_previousAndSide"),Z.push("grl_nextAndCounters")):Z.push("grl_slopes")}getSamplers(Z){Z.push("grl_colors")}getActiveTextures(Z){this.colorsTexture&&Z.push(this.colorsTexture)}getUniforms(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const h=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&h.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Z&&h.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:h,vertex:this._cameraFacing&&this._isGLSL(Z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Z){if(this._cameraFacing){Z.wh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Z.wh("viewProjection",this._scene.getTransformMatrix());const h=v.TmpVectors.Vector4[0];h.x=this._aspect,h.y=this._resolution.x,h.z=this._resolution.y,h.w=this.width,Z.updateVector4("grl_aspect_resolution_lineWidth",h)}const h=v.TmpVectors.Vector4[0];h.x=yZ.BooleanToNumber(this.useDash),h.y=this._dashArray,h.z=this.dashOffset,h.w=this.dashRatio,Z.updateVector4("grl_dashOptions",h);const V=v.TmpVectors.Vector4[1];V.x=this.colorMode,V.y=this.visibility,V.z=this.colorsTexture?this.colorsTexture.getSize().width:0,V.w=yZ.BooleanToNumber(this.useColors),Z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",V),this._color&&Z.updateColor3("grl_singleColor",this._color);const A=this.colorsTexture??SZ.EmptyColorsTexture;Z.setTexture("grl_colors",A),Z.updateFloat2("grl_textureSize",(null===A||void 0===A?void 0:A.getSize().width)??1,(null===A||void 0===A?void 0:A.getSize().height)??1)}prepareDefines(Z,h,V){Z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=h.useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Z.GREASED_LINE_USE_OFFSETS=!!V.offsets}getClassName(){return zZ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Z){let h=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(h)?function(Z,h){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return h&&(Z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Z,this._cameraFacing):function(Z,h){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return h&&(Z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Z,this._cameraFacing)}dispose(){var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}get rZ(){return this._colors}set rZ(Z){this.setColors(Z)}setColors(Z){var h;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var H;if(this._colors=Z,null!==Z&&0!==Z.length){if(!V||v)if(this.colorsTexture&&A===Z.length&&!v){const h=yZ.Color3toRGBAUint8(Z);this.colorsTexture.update(h)}else{var K;null===(K=this.colorsTexture)||void 0===K||K.dispose(),this.colorsTexture=yZ.CreateColorsTexture(`${this._material.name}-colors-texture`,Z,this.colorsSampling,this._scene)}}else null===(H=this.colorsTexture)||void 0===H||H.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Z||null!==this._color&&null===Z?(this._color=Z,h||this.markAllDefinesAsDirty()):this._color=Z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Z){this._aspect=Z.x/Z.y,this._resolution=Z}serialize(){const Z=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(h.rZ=this._colors),this._color&&(h.color=this._color),Z.greasedLineMaterialOptions=h,Z}parse(Z,h,V){var v;super.parse(Z,h,V);const A=Z.greasedLineMaterialOptions;null===(v=this.colorsTexture)||void 0===v||v.dispose(),A.color&&this.setColor(A.color,!0),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.rZ&&(this.rZ=A.rZ),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),this.rZ?this.colorsTexture=yZ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.rZ,this.colorsSampling,h):yZ.PrepareEmptyColorsTexture(h),this.markAllDefinesAsDirty()}copyTo(Z){var h;const V=Z;null===(h=V.colorsTexture)||void 0===h||h.dispose(),this._colors&&(V.colorsTexture=yZ.CreateColorsTexture(`${V._material.name}-colors-texture`,this._colors,V.colorsSampling,this._scene)),V.setColor(this.color,!0),V.colorsDistributionType=this.colorsDistributionType,V.colorsSampling=this.colorsSampling,V.colorMode=this.colorMode,V.useColors=this.useColors,V.visibility=this.visibility,V.useDash=this.useDash,V.dashCount=this.dashCount,V.dashRatio=this.dashRatio,V.dashOffset=this.dashOffset,V.width=this.width,V.sizeAttenuation=this.sizeAttenuation,V.resolution=this.resolution,V.markAllDefinesAsDirty()}_isGLSL(Z){return 0===Z||this._forceGLSL}}zZ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",zZ.ForceGLSL=!1,(0,BZ.i)(`BABYLON.${zZ.GREASED_LINE_MATERIAL_NAME}`,zZ);var mZ=V(12161),gZ=V(11582),IZ=V(11981),eZ=V(11679);class UZ extends IZ.ShaderMaterial{constructor(Z,h,A){const H=h.getEngine(),K=H.isWebGPU&&!(A.forceGLSL||UZ.ForceGLSL),d=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];h.useRightHandedSystem&&d.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const a=["position","grl_widths","grl_offsets","grl_colorPointers"];A.cameraFacing?(d.push("GREASED_LINE_CAMERA_FACING"),a.push("grl_previousAndSide","grl_nextAndCounters")):(a.push("grl_slopes"),a.push("grl_counters"));const n=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(K||n.push("world","viewProjection","view","projection"),super(Z,h,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:K?["Scene","Mesh"]:void 0,attributes:a,uniforms:n,samplers:K?[]:["grlColors"],defines:d,extraInitializationsAsync:async()=>{K?await Promise.all([V.e(66).then(V.bind(V,14923)),V.e(75).then(V.bind(V,14927))]):await Promise.all([V.e(69).then(V.bind(V,14933)),V.e(76).then(V.bind(V,14941))])},shaderLanguage:K?1:0}),this._color=b.Ih.White(),this._colorsDistributionType=0,this._colorsTexture=null,A=A||{color:SZ.DEFAULT_COLOR},this.visibility=A.visibility??1,this.useDash=A.useDash??!1,this.dashRatio=A.dashRatio??.5,this.dashOffset=A.dashOffset??0,this.dashCount=A.dashCount??1,this.width=A.width?A.width:A.sizeAttenuation&&A.cameraFacing?SZ.DEFAULT_WIDTH_ATTENUATED:SZ.DEFAULT_WIDTH,this.sizeAttenuation=A.sizeAttenuation??!1,this.color=A.color??b.Ih.White(),this.useColors=A.useColors??!1,this.colorsDistributionType=A.colorDistributionType??0,this.colorsSampling=A.colorsSampling??P.d.NEAREST_NEAREST,this.colorMode=A.colorMode??0,this._colors=A.rZ??null,this._cameraFacing=A.cameraFacing??!0,this.resolution=A.resolution??new v.Vector2(H.getRenderWidth(),H.getRenderHeight()),A.colorsTexture?this.colorsTexture=A.colorsTexture:this._colors?this.colorsTexture=yZ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,h):(this._color=this._color??SZ.DEFAULT_COLOR,this.colorsTexture=yZ.PrepareEmptyColorsTexture(h)),K){const Z=new eZ.d;Z.setParameters(),Z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Z)}H.jh.add((()=>{yZ.DisposeEmptyColorsTexture()}))}dispose(){var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new v.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get rZ(){return this._colors}set rZ(Z){this.setColors(Z)}setColors(Z){var h;let V=arguments.length>1&&void 0!==arguments[1]&&arguments[1],v=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const A=(null===(h=this._colors)||void 0===h?void 0:h.length)??0;var H;if(this._colors=Z,null!==Z&&0!==Z.length){if(!V||v)if(this._colorsTexture&&A===Z.length&&!v){const h=yZ.Color3toRGBAUint8(Z);this._colorsTexture.update(h)}else{var K;null===(K=this._colorsTexture)||void 0===K||K.dispose(),this.colorsTexture=yZ.CreateColorsTexture(`${this.name}-colors-texture`,Z,this.colorsSampling,this.CZ())}}else null===(H=this._colorsTexture)||void 0===H||H.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Z){this._colorsTexture=Z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Z){this._width=Z,this.setFloat("grlWidth",Z)}get useColors(){return this._useColors}set useColors(Z){this._useColors=Z,this.setFloat("grlUseColors",yZ.BooleanToNumber(Z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Z){this._colorsSampling=Z}get visibility(){return this._visibility}set visibility(Z){this._visibility=Z,this.setFloat("grlVisibility",Z)}get useDash(){return this._useDash}set useDash(Z){this._useDash=Z,this.setFloat("grlUseDash",yZ.BooleanToNumber(Z))}get dashOffset(){return this._dashOffset}set dashOffset(Z){this._dashOffset=Z,this.setFloat("grlDashOffset",Z)}get dashRatio(){return this._dashRatio}set dashRatio(Z){this._dashRatio=Z,this.setFloat("grlDashRatio",Z)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.setFloat("grlSizeAttenuation",yZ.BooleanToNumber(Z))}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){Z=Z??SZ.DEFAULT_COLOR,this._color=Z,this.setColor3("grlColor",Z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Z){this._colorMode=Z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Z){this._resolution=Z,this.setVector2("grlResolution",Z),this.setFloat("grlAspect",Z.x/Z.y)}serialize(){const Z=super.serialize(),h={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(h.rZ=this._colors),Z.greasedLineMaterialOptions=h,Z}parse(Z,h,V){var v;const A=Z.greasedLineMaterialOptions;null===(v=this._colorsTexture)||void 0===v||v.dispose(),A.color&&(this.color=A.color),A.colorDistributionType&&(this.colorsDistributionType=A.colorDistributionType),A.colorsSampling&&(this.colorsSampling=A.colorsSampling),A.colorMode&&(this.colorMode=A.colorMode),A.useColors&&(this.useColors=A.useColors),A.visibility&&(this.visibility=A.visibility),A.useDash&&(this.useDash=A.useDash),A.dashCount&&(this.dashCount=A.dashCount),A.dashRatio&&(this.dashRatio=A.dashRatio),A.dashOffset&&(this.dashOffset=A.dashOffset),A.width&&(this.width=A.width),A.sizeAttenuation&&(this.sizeAttenuation=A.sizeAttenuation),A.resolution&&(this.resolution=A.resolution),A.rZ?this.colorsTexture=yZ.CreateColorsTexture(`${this.name}-colors-texture`,A.rZ,this.colorsSampling,this.CZ()):this.colorsTexture=yZ.PrepareEmptyColorsTexture(h),this._cameraFacing=A.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var RZ,QZ,wZ;UZ.ForceGLSL=!1,function(Z){Z[Z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Z[Z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(RZ||(RZ={})),function(Z){Z[Z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Z[Z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Z[Z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(QZ||(QZ={})),function(Z){Z[Z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Z[Z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Z[Z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Z[Z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Z[Z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(wZ||(wZ={}));class TZ extends qZ.c{constructor(Z,h,V){super(Z,h,null,null,!1,!1),this.name=Z,this._options=V,this._lazy=!1,this._updatable=!1,this._engine=h.getEngine(),this._lazy=V.lazy??!1,this._updatable=V.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=V.colorPointers??[],this._widths=V.widths??new Array(V.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Z){let h=0;for(const v of this._points)h+=v.length;const V=h/3*2-this._widths.length;for(let v=0;v<V;v++)this._widths.push(Z)}updateLazy(){var Z,h;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Z=this._options.ribbonOptions)||void 0===Z?void 0:Z.smoothShading),!this.zZ&&this.refreshBoundingInfo(),null===(h=this.greasedLineMaterial)||void 0===h||h.updateLazy()}addPoints(Z,h){for(const V of Z)this._points.push(V);this._lazy||this.setPoints(this._points,h)}dispose(Z){let h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Z,h)}isLazy(){return this._lazy}get LZ(){return this._uvs}set LZ(Z){this._uvs=Z instanceof Float32Array?Z:new Float32Array(Z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Z){this.material instanceof UZ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Z||void 0===Z?void 0:Z.length)>0),this._offsets=Z,this._offsetsBuffer?this._offsetsBuffer.update(Z):this._createOffsetsBuffer(Z)}get widths(){return this._widths}set widths(Z){this._widths=Z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Z)}get colorPointers(){return this._colorPointers}set colorPointers(Z){this._colorPointers=Z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Z)}get greasedLineMaterial(){var Z,h;if(this.material&&this.material instanceof UZ)return this.material;const V=null===(Z=this.material)||void 0===Z||null===(h=Z.pluginManager)||void 0===h?void 0:h.getPlugin(zZ.GREASED_LINE_MATERIAL_NAME);return V||void 0}get points(){const Z=[];return gZ.b.DeepCopy(this._points,Z),Z}setPoints(Z,h){this._points=yZ.ConvertPoints(Z,(null===h||void 0===h?void 0:h.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==h&&void 0!==h&&h.colorPointers||this._updateColorPointers(),this._setPoints(this._points,h)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,LZ:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Z){super.serialize(Z),Z.type=this.getClassName(),Z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const h=new mZ.e;return h.BZ=this._vertexPositions,h.indices=this._indices,h.LZ=this._uvs,Z&&(h.SZ=[],mZ.e.ComputeNormals(this._vertexPositions,this._indices,h.SZ)),h.WZ(this,this._options.updatable),h}_createOffsetsBuffer(Z){const h=this._scene.getEngine(),V=new x.b(h,Z,this._updatable,3);this.setVerticesBuffer(V.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=V}}class tZ{constructor(Z,h){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Z,this.wasAddedByNoopNode=h}getIndicesAccessor(Z,h,V,v,A){var H,K,d,a;return null===(H=this._indicesAccessorMap.get(Z))||void 0===H||null===(K=H.get(h))||void 0===K||null===(d=K.get(V))||void 0===d||null===(a=d.get(v))||void 0===a?void 0:a.get(A)}setIndicesAccessor(Z,h,V,v,A,H){let K=this._indicesAccessorMap.get(Z);K||(K=new Map,this._indicesAccessorMap.set(Z,K));let d=K.get(h);d||(d=new Map,K.set(h,d));let a=d.get(V);a||(a=new Map,d.set(V,a));let n=a.get(v);n||(n=new Map,a.set(v,n)),n.set(A,H)}pushExportedNode(Z){this._exportedNodes.has(Z)||this._exportedNodes.add(Z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Z){return this._vertexBufferViewMap.get(Z)}setVertexBufferView(Z,h){this._vertexBufferViewMap.set(Z,h)}setRemappedBufferView(Z,h,V){this._remappedBufferView.set(Z,new Map),this._remappedBufferView.get(Z).set(h,V)}getRemappedBufferView(Z,h){var V;return null===(V=this._remappedBufferView.get(Z))||void 0===V?void 0:V.get(h)}getVertexAccessor(Z,h,V){var v,A;return null===(v=this._vertexAccessorMap.get(Z))||void 0===v||null===(A=v.get(h))||void 0===A?void 0:A.get(V)}setVertexAccessor(Z,h,V,v){let A=this._vertexAccessorMap.get(Z);A||(A=new Map,this._vertexAccessorMap.set(Z,A));let H=A.get(h);H||(H=new Map,A.set(h,H)),H.set(V,v)}hasVertexColorAlpha(Z){return this._vertexMapColorAlpha.get(Z)||!1}setHasVertexColorAlpha(Z,h){return this._vertexMapColorAlpha.set(Z,h)}getMesh(Z){return this._meshMap.get(Z)}setMesh(Z,h){this._meshMap.set(Z,h)}bindMorphDataToMesh(Z,h){const V=this._meshMorphTargetMap.get(Z)||[];this._meshMorphTargetMap.set(Z,V),-1===V.indexOf(h)&&V.push(h)}getMorphTargetsFromMesh(Z){return this._meshMorphTargetMap.get(Z)}}class cZ{_ApplyExtension(Z,h,V,v){if(V>=h.length)return Promise.resolve(Z);const A=v(h[V],Z);return A?A.then((async Z=>Z?await this._ApplyExtension(Z,h,V+1,v):null)):this._ApplyExtension(Z,h,V+1,v)}_ApplyExtensions(Z,h){const V=[];for(const v of cZ._ExtensionNames)V.push(this._extensions[v]);return this._ApplyExtension(Z,V,0,h)}_extensionsPreExportTextureAsync(Z,h,V){return this._ApplyExtensions(h,((h,v)=>h.preExportTextureAsync&&h.preExportTextureAsync(Z,v,V)))}_extensionsPostExportNodeAsync(Z,h,V,v,A){return this._ApplyExtensions(h,((h,H)=>h.postExportNodeAsync&&h.postExportNodeAsync(Z,H,V,v,A,this._bufferManager)))}_extensionsPostExportMaterialAsync(Z,h,V){return this._ApplyExtensions(h,((h,v)=>h.postExportMaterialAsync&&h.postExportMaterialAsync(Z,v,V)))}_extensionsPostExportMaterialAdditionalTextures(Z,h,V){const v=[];for(const A of cZ._ExtensionNames){const H=this._extensions[A];H.postExportMaterialAdditionalTextures&&v.push(...H.postExportMaterialAdditionalTextures(Z,h,V))}return v}_extensionsPostExportTextures(Z,h,V){for(const v of cZ._ExtensionNames){const A=this._extensions[v];A.postExportTexture&&A.postExportTexture(Z,h,V)}}_extensionsPostExportMeshPrimitive(Z){for(const h of cZ._ExtensionNames){const V=this._extensions[h];V.postExportMeshPrimitive&&V.postExportMeshPrimitive(Z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Z of cZ._ExtensionNames){const h=this._extensions[Z];h.preGenerateBinaryAsync&&await h.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Z){for(const h of cZ._ExtensionNames){const V=this._extensions[h];V.enabled&&Z(V)}}_extensionsOnExporting(){this._forEachExtensions((Z=>{var h,V,v;Z.wasUsed&&((h=this._glTF).extensionsUsed||(h.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Z.name)&&this._glTF.extensionsUsed.push(Z.name),Z.required&&((V=this._glTF).extensionsRequired||(V.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Z.name)&&this._glTF.extensionsRequired.push(Z.name)),(v=this._glTF).extensions||(v.extensions={}),Z.onExporting&&Z.onExporting())}))}_loadExtensions(){for(const Z of cZ._ExtensionNames){const h=cZ._ExtensionFactories[Z](this);this._extensions[Z]=h}}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:F.b.LastCreatedScene,h=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${u.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new e(this),this._extensions={},this._bufferManager=new xZ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Z)throw new Error("No scene available to export");this._babylonScene=Z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Z=>{var h;return null===Z||void 0===Z||null===(h=Z.Lh)||void 0===h?void 0:h.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...h},this._loadExtensions()}dispose(){for(const Z in this._extensions){this._extensions[Z].dispose()}}get options(){return this._options}static RegisterExtension(Z,h){cZ.UnregisterExtension(Z)&&A.Tools.Warn(`Extension with the name ${Z} already exists`),cZ._ExtensionFactories[Z]=h,cZ._ExtensionNames.push(Z)}static UnregisterExtension(Z){if(!cZ._ExtensionFactories[Z])return!1;delete cZ._ExtensionFactories[Z];const h=cZ._ExtensionNames.indexOf(Z);return-1!==h&&cZ._ExtensionNames.splice(h,1),!0}_generateJSON(Z,h,V){const v={byteLength:Z};return v.byteLength&&(this._glTF.buffers=[v]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Wh=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(v.uri=h+".bin"),V?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Z){const h=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(h.byteLength,Z,!0),v=new Blob([h],{type:"application/octet-stream"}),A=Z+".gltf",H=Z+".bin",K=new n;if(K.files[A]=V,K.files[H]=v,this._imageData)for(const d in this._imageData)K.files[d]=new Blob([this._imageData[d].data],{type:this._imageData[d].mimeType});return K}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Z){const h=Z%4;return 0===h?h:4-h}async generateGLBAsync(Z){this._shouldUseGlb=!0;const h=await this._generateBinaryAsync();this._extensionsOnExporting();const V=this._generateJSON(h.byteLength),v=Z+".glb";let A,H=V.length;if("undefined"!==typeof TextEncoder){A=(new TextEncoder).encode(V),H=A.length}const K=this._getPadding(H),d=this._getPadding(h.byteLength),a=28+H+K+h.byteLength+d,x=new aZ(a);if(x.writeUInt32(1179937895),x.writeUInt32(2),x.writeUInt32(a),x.writeUInt32(H+K),x.writeUInt32(1313821514),A)x.writeTypedArray(A);else{const Z="_".charCodeAt(0);for(let h=0;h<H;++h){const v=V.charCodeAt(h);v!=V.codePointAt(h)?x.writeUInt8(Z):x.writeUInt8(v)}}for(let n=0;n<K;++n)x.writeUInt8(32);x.writeUInt32(h.byteLength+d),x.writeUInt32(5130562),x.writeTypedArray(h);for(let n=0;n<d;++n)x.writeUInt8(0);const N=new n;return N.files[v]=new Blob([x.getOutputData()],{type:"application/octet-stream"}),N}_setNodeTransformation(Z,h,V){if(h.getPivotPoint().equalsWithEpsilon(T,w.c)||A.Tools.Warn("Pivot points are not supported in the glTF serializer"),!h.position.equalsWithEpsilon(T,w.c)){const A=v.TmpVectors.Ch[0].v(h.position);V&&p(A),Z.translation=A.mh()}h.tv.equalsWithEpsilon(c,w.c)||(Z.scale=h.tv.mh());const H=h.rotationQuaternion||v.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);H.equalsWithEpsilon(t,w.c)||(V&&Y(H),Z.rotation=H.normalize().mh())}_setCameraTransformation(Z,h,V){if(!h.position.equalsWithEpsilon(T,w.c)){const A=v.TmpVectors.Ch[0].v(h.position);V&&p(A),Z.translation=A.mh()}const A=h.rotationQuaternion||v.Quaternion.FromEulerAngles(h.rotation.x,h.rotation.y,h.rotation.z);V&&Y(A),this._babylonScene.useRightHandedSystem||G(A),A.equalsWithEpsilon(t,w.c)||(Z.rotation=A.mh())}_listAvailableCameras(){for(const Z of this._babylonScene.cameras){const h={type:Z.mode===DZ.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Z.name&&(h.name=Z.name),"perspective"===h.type)h.perspective={aspectRatio:Z.getEngine().getAspectRatio(Z),yfov:Z.fovMode===DZ.e.FOVMODE_VERTICAL_FIXED?Z.fov:Z.fov*Z.getEngine().getAspectRatio(Z),znear:Z.Rh,zfar:Z.maxZ};else if("orthographic"===h.type){const V=Z.orthoLeft&&Z.orthoRight?.5*(Z.orthoRight-Z.orthoLeft):.5*Z.getEngine().getRenderWidth(),v=Z.orthoBottom&&Z.orthoTop?.5*(Z.orthoTop-Z.orthoBottom):.5*Z.getEngine().getRenderHeight();h.orthographic={xmag:V,ymag:v,znear:Z.Rh,zfar:Z.maxZ}}this._camerasMap.set(Z,h)}}_exportAndAssignCameras(){const Z=Array.from(this._camerasMap.values());for(const h of Z){const Z=this._nodesCameraMap.get(h);if(void 0!==Z){this._cameras.push(h);for(const h of Z)h.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const h={joints:[]};this._skinMap.set(Z,h)}}_exportAndAssignSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const h=this._skinMap.get(Z);if(void 0==h)continue;const V={},v=[];let H=-1;for(let A=0;A<Z.bones.length;++A){const h=Z.bones[A],v=h.getIndex()??A;-1!==v&&(V[v]=h,v>H&&(H=v))}for(let Z=0;Z<=H;++Z){const H=V[Z];v.push(H.getAbsoluteInverseBindMatrix());const K=H.getTransformNode();if(null!==K){const Z=this._nodeMap.get(K);K&&null!==Z&&void 0!==Z?h.joints.push(Z):A.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else A.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const K=this._nodesSkinMap.get(h);if(h.joints.length>0&&void 0!==K){const Z=64*v.length,V=new Float32Array(Z/4);v.forEach(((Z,h)=>{V.set(Z.m,16*h)}));const A=this._bufferManager.createBufferView(V);this._accessors.push(this._bufferManager.createAccessor(A,"MAT4",5126,v.length)),h.inverseBindMatrices=this._accessors.length-1,this._skins.push(h);for(const h of K)h.skin=this._skins.length-1}}}async _exportSceneAsync(){const Z={nodes:[]};if(this._babylonScene.metadata){const h=this._options.metadataSelector(this._babylonScene.metadata);h&&(Z.extras=h)}const h=new Array,V=new Array,v=new Array;for(const d of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&KZ(d,this._babylonScene.useRightHandedSystem)?v.push(...d.getChildren()):this._babylonScene.useRightHandedSystem?h.push(d):V.push(d);this._listAvailableCameras(),this._listAvailableSkeletons();const A=new tZ(!0,!1);Z.nodes.push(...await this._exportNodesAsync(V,A));const H=new tZ(!1,!1);Z.nodes.push(...await this._exportNodesAsync(h,H));const K=new tZ(!1,!0);Z.nodes.push(...await this._exportNodesAsync(v,K)),Z.nodes.length&&this._scenes.push(Z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&EZ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,A.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Z){let h=this._shouldExportNodeMap.get(Z);return void 0===h&&(h=this._options.shouldExportNode(Z),this._shouldExportNodeMap.set(Z,h)),h}async _exportNodesAsync(Z,h){const V=new Array;this._exportBuffers(Z,h);for(const v of Z)await this._exportNodeAsync(v,V,h);return V}_collectBuffers(Z,h,V,v,A){if(this._shouldExportNode(Z)&&Z instanceof D.e&&Z.Jh){const H=Z.Jh.getVertexBuffers();if(H)for(const v in H){if(!s(v))continue;const K=H[v];A.setHasVertexColorAlpha(K,Z.hasVertexAlpha);const d=K._buffer,a=h.get(d)||[];h.set(d,a),-1===a.indexOf(K)&&a.push(K);const n=V.get(K)||[];V.set(K,n),-1===n.indexOf(Z)&&n.push(Z)}const K=Z.morphTargetManager;if(K)for(let h=0;h<K.numTargets;h++){const V=K.getTarget(h),A=v.get(V)||[];v.set(V,A),-1===A.indexOf(Z)&&A.push(Z)}}for(const H of Z.getChildren())this._collectBuffers(H,h,V,v,A)}_exportBuffers(Z,h){const V=new Map,v=new Map,A=new Map;for(const d of Z)this._collectBuffers(d,V,v,A,h);const H=Array.from(V.keys());for(const d of H){const Z=d.getData();if(!Z)throw new Error("Buffer data is not available");const A=V.get(d);if(!A)continue;const H=A[0].byteStride;if(A.some((Z=>Z.byteStride!==H)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const K=VZ(Z).slice();for(const h of A){const Z=v.get(h),{byteOffset:V,byteStride:A,componentCount:H,type:d,count:a,normalized:n,kind:N}=M(h,Z);switch(N){case x.f.NormalKind:case x.f.TangentKind:(0,U.g)(K,V,A,H,d,a,n,(Z=>{const h=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]);if(h>0){const V=1/h;Z[0]*=V,Z[1]*=V,Z[2]*=V}}));break;case x.f.ColorKind:{const h=Z.filter((Z=>Z.material instanceof FZ.gh||null==Z.material)).length;if(0==h)break;if(h!=Z.length){R.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}d==x.f.UNSIGNED_BYTE&&R.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const v=new b.Ih,N=new b.nd,D=this._babylonScene.getEngine().useExactSrgbConversions;(0,U.g)(K,V,A,H,d,a,n,(Z=>{3===Z.length?(v.QV(Z,0),v.toLinearSpaceToRef(v,D),v.toArray(Z,0)):(N.QV(Z,0),N.toLinearSpaceToRef(N,D),N.toArray(Z,0))}))}}}if(h.convertToRightHanded){for(const Z of A){const h=v.get(Z),{byteOffset:V,byteStride:A,componentCount:H,type:d,count:a,normalized:n,kind:N}=M(Z,h);switch(N){case x.f.PositionKind:case x.f.NormalKind:case x.f.TangentKind:(0,U.g)(K,V,A,H,d,a,n,(Z=>{Z[0]=-Z[0]}))}}h.convertedToRightHandedBuffers.set(d,K)}const a=this._bufferManager.createBufferView(K,H);h.setVertexBufferView(d,a);const n=new Map;for(const h of A){const Z=v.get(h),{kind:V,totalVertices:A}=M(h,Z);switch(V){case x.f.MatricesIndicesKind:case x.f.MatricesIndicesExtraKind:if(h.type==x.f.FLOAT){const Z=h.getFloatData(A);null!==Z&&n.set(h,Z)}}}0!==n.size&&R.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const N=Array.from(n.keys());for(const V of N){const Z=n.get(V);if(!Z)continue;const v=Z.some((Z=>Z>=256)),A=new(v?Uint16Array:Uint8Array)(Z.length);for(let h=0;h<Z.length;h++)A[h]=Z[h];const H=this._bufferManager.createBufferView(A,4*(v?2:1));h.setRemappedBufferView(d,V,H)}}const K=Array.from(A.keys());for(const d of K){const Z=A.get(d);if(!Z)continue;const V=jZ(d,Z[0],this._bufferManager,this._bufferViews,this._accessors,h.convertToRightHanded);for(const v of Z)h.bindMorphDataToMesh(v,V)}}async _exportNodeAsync(Z,h,V){let v=this._nodeMap.get(Z);if(void 0!==v)return void(h.includes(v)||h.push(v));const A=await this._createNodeAsync(Z,V);if(A){v=this._nodes.length,this._nodes.push(A),this._nodeMap.set(Z,v),V.pushExportedNode(Z),h.push(v);const H={name:"runtime animations",channels:[],samplers:[]},K=[];this._babylonScene.animationGroups.length||(EZ._CreateMorphTargetAnimationFromMorphTargetAnimations(Z,H,K,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation),Z.animations.length&&EZ._CreateNodeAnimationFromNodeAnimations(Z,H,K,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,V.convertToRightHanded,this._options.shouldExportAnimation)),H.channels.length&&H.samplers.length&&this._animations.push(H),K.forEach((Z=>{Z.channels.length&&Z.samplers.length&&this._animations.push(Z)}))}const H=A?[]:h;for(const K of Z.getChildren())await this._exportNodeAsync(K,H,V);A&&H.length&&(A.children=H)}async _createNodeAsync(Z,h){if(!this._shouldExportNode(Z))return null;const V={};if(Z.name&&(V.name=Z.name),Z.metadata){const h=this._options.metadataSelector(Z.metadata);h&&(V.extras=h)}if(Z instanceof N.d&&(this._setNodeTransformation(V,Z,h.convertToRightHanded),Z instanceof D.e)){const A=Z instanceof k.d?Z.sourceMesh:Z;if(A.zh&&A.zh.length>0&&(V.mesh=await this._exportMeshAsync(A,h)),Z.skeleton){const h=this._skinMap.get(Z.skeleton);var v;if(void 0!==h)void 0===this._nodesSkinMap.get(h)&&this._nodesSkinMap.set(h,[]),null===(v=this._nodesSkinMap.get(h))||void 0===v||v.push(V)}}if(Z instanceof Q.e){const v=this._camerasMap.get(Z);if(v){var A;void 0===this._nodesCameraMap.get(v)&&this._nodesCameraMap.set(v,[]),this._setCameraTransformation(V,Z,h.convertToRightHanded);const K=Z.parent;if(null!==K&&hZ(Z,K)){const Z=this._nodeMap.get(K);if(void 0!==Z){var H;const h=this._nodes[Z];return ZZ(V,h),null===(H=this._nodesCameraMap.get(v))||void 0===H||H.push(h),null}}null===(A=this._nodesCameraMap.get(v))||void 0===A||A.push(V)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",V,Z,this._nodeMap,h.convertToRightHanded)?V:(R.b.Warn(`Not exporting node ${Z.name}`),null)}_exportIndices(Z,h,V,v,A,K,d,a,n){let x=Z;n.mode=J(K);const N=d!==H.b.CounterClockWiseSideOrientation,D=!a.wasAddedByNoopNode&&N,k=function(Z){switch(Z){case H.b.TriangleFillMode:case H.b.TriangleStripDrawMode:case H.b.TriangleFanDrawMode:return!0}return!1}(K)&&D;if(k){if(K===H.b.TriangleStripDrawMode||K===H.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");n.mode=J(K);const d=h?new Uint32Array(v):new Uint16Array(v);if(Z)for(let h=0;h+2<v;h+=3)d[h]=Z[V+h]+A,d[h+1]=Z[V+h+2]+A,d[h+2]=Z[V+h+1]+A;else for(let Z=0;Z+2<v;Z+=3)d[Z]=Z,d[Z+1]=Z+2,d[Z+2]=Z+1;x=d}else if(Z&&0!==A){const H=h?new Uint32Array(v):new Uint16Array(v);for(let h=0;h<v;h++)H[h]=Z[V+h]+A;x=H}if(x){let H=a.getIndicesAccessor(Z,V,v,A,k);if(void 0===H){const K=function(Z,h,V,v){if(Z instanceof Uint16Array||Z instanceof Uint32Array)return Z;if(Z instanceof Int32Array)return new Uint32Array(Z.buffer,Z.byteOffset,Z.length);const A=Z.slice(h,h+V);return v?new Uint32Array(A):new Uint16Array(A)}(x,0,v,h),d=this._bufferManager.createBufferView(K),n=h?5125:5123;this._accessors.push(this._bufferManager.createAccessor(d,"SCALAR",n,v,0)),H=this._accessors.length-1,a.setIndicesAccessor(Z,V,v,A,k,H)}n.indices=H}}_exportVertexBuffer(Z,h,V,v,A,H){const K=Z.getKind();if(!s(K))return;if(K.startsWith("uv")&&!this._options.exportUnusedUVs&&(!h||!this._materialNeedsUVsSet.has(h)))return;let d=A.getVertexAccessor(Z,V,v);if(void 0===d){const h=A.convertedToRightHandedBuffers.get(Z._buffer)||Z._buffer.getData(),H=K===x.f.PositionKind?function(Z,h,V,v){const{byteOffset:A,byteStride:H,type:K,normalized:d}=h,a=h.getSize(),n=new Array(a).fill(1/0),x=new Array(a).fill(-1/0);return(0,U.g)(Z,A+V*H,H,a,K,v*a,d,(Z=>{for(let h=0;h<a;h++)n[h]=Math.min(n[h],Z[h]),x[h]=Math.max(x[h],Z[h])})),{min:n,max:x}}(h,Z,V,v):void 0,a=(K===x.f.MatricesIndicesKind||K===x.f.MatricesIndicesExtraKind)&&Z.type===x.f.FLOAT,n=a?x.f.UNSIGNED_BYTE:Z.type,N=a?void 0:Z.normalized,D=a?A.getRemappedBufferView(Z._buffer,Z):A.getVertexBufferView(Z._buffer),k=Z.byteOffset+V*Z.byteStride;this._accessors.push(this._bufferManager.createAccessor(D,function(Z,h){if(Z==x.f.ColorKind)return h?"VEC4":"VEC3";switch(Z){case x.f.PositionKind:case x.f.NormalKind:return"VEC3";case x.f.TangentKind:case x.f.MatricesIndicesKind:case x.f.MatricesIndicesExtraKind:case x.f.MatricesWeightsKind:case x.f.MatricesWeightsExtraKind:return"VEC4";case x.f.UVKind:case x.f.UV2Kind:case x.f.UV3Kind:case x.f.UV4Kind:case x.f.UV5Kind:case x.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Z}`)}(K,A.hasVertexColorAlpha(Z)),n,v,k,H,N)),d=this._accessors.length-1,A.setVertexAccessor(Z,V,v,d)}H.attributes[function(Z){switch(Z){case x.f.PositionKind:return"POSITION";case x.f.NormalKind:return"NORMAL";case x.f.TangentKind:return"TANGENT";case x.f.ColorKind:return"COLOR_0";case x.f.UVKind:return"TEXCOORD_0";case x.f.UV2Kind:return"TEXCOORD_1";case x.f.UV3Kind:return"TEXCOORD_2";case x.f.UV4Kind:return"TEXCOORD_3";case x.f.UV5Kind:return"TEXCOORD_4";case x.f.UV6Kind:return"TEXCOORD_5";case x.f.MatricesIndicesKind:return"JOINTS_0";case x.f.MatricesIndicesExtraKind:return"JOINTS_1";case x.f.MatricesWeightsKind:return"WEIGHTS_0";case x.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Z}`)}(K)]=d}async _exportMaterialAsync(Z,h,V,v){let A=this._materialMap.get(Z);if(void 0===A){const v=h&&Object.keys(h).some((Z=>Z.startsWith("uv")));if((Z=Z instanceof kZ.d?Z.xd[V.materialIndex]:Z)instanceof uZ.c)A=await this._materialExporter.exportPBRMaterialAsync(Z,"image/png",v);else{if(!(Z instanceof FZ.gh))return void R.b.Warn(`Unsupported material '${Z.name}' with type ${Z.getClassName()}`);A=await this._materialExporter.exportStandardMaterialAsync(Z,"image/png",v)}this._materialMap.set(Z,A)}v.material=A}async _exportMeshAsync(Z,h){var V;let v=h.getMesh(Z);if(void 0!==v)return v;const A={primitives:[]};v=this._meshes.length,this._meshes.push(A),h.setMesh(Z,v);const K=Z.isUnIndexed?null:Z.fh(),d=null===(V=Z.Jh)||void 0===V?void 0:V.getVertexBuffers(),a=h.getMorphTargetsFromMesh(Z),n=Z instanceof PZ.e,x=Z instanceof TZ,N=Z.zh;if(d&&N&&N.length>0)for(const u of N){const V={attributes:{}},v=u.eZ()||this._babylonScene.defaultMaterial;if(x){var D,k;const h={name:v.name},A=Z,H=b.Ih.White(),K=(null===(D=A.material)||void 0===D?void 0:D.alpha)??1,d=(null===(k=A.greasedLineMaterial)||void 0===k?void 0:k.color)??H;(!d.equalsWithEpsilon(H,w.c)||K<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...d.mh(),K]}),this._materials.push(h),V.material=this._materials.length-1}else if(n){const h={name:v.name},A=Z;(!A.color.equalsWithEpsilon(b.Ih.White(),w.c)||A.alpha<1)&&(h.pbrMetallicRoughness={baseColorFactor:[...A.color.mh(),A.alpha]}),this._materials.push(h),V.material=this._materials.length-1}else await this._exportMaterialAsync(v,d,u,V);const N=n||x?H.b.LineListDrawMode:Z.overrideRenderingFillMode??v.fillMode,F=v._getEffectiveOrientation(Z);this._exportIndices(K,K?(0,U.b)(K,u.indexCount,u.indexStart,u.verticesStart):u.verticesCount>65535,K?u.indexStart:u.verticesStart,K?u.indexCount:u.verticesCount,-u.verticesStart,N,F,h,V);for(const Z of Object.values(d))this._exportVertexBuffer(Z,v,u.verticesStart,u.verticesCount,h,V);if(a){V.targets=[];for(const Z of a)V.targets.push(Z.attributes)}A.primitives.push(V),this._extensionsPostExportMeshPrimitive(V)}if(a){A.weights=[],A.extras||(A.extras={}),A.extras.targetNames=[];for(const Z of a)A.weights.push(Z.influence),A.extras.targetNames.push(Z.name)}return v}}cZ._ExtensionNames=new Array,cZ._ExtensionFactories={};class iZ{static async GLTFAsync(Z,h,V){V&&V.exportWithoutWaitingForScene||await Z.whenReadyAsync();const v=new cZ(Z,V),A=await v.generateGLTFAsync(h.replace(/\.[^/.]+$/,""));return v.dispose(),A}static async GLBAsync(Z,h,V){V&&V.exportWithoutWaitingForScene||await Z.whenReadyAsync();const v=new cZ(Z,V),A=await v.generateGLBAsync(h.replace(/\.[^/.]+$/,""));return v.dispose(),A}}V(12305);const MZ="EXT_mesh_gpu_instancing";class OZ{constructor(Z){this.name=MZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Z,h,V,A,H,K){return await new Promise((Z=>{if(h&&V instanceof qZ.c&&V.hasThinInstances&&this._exporter){this._wasUsed=!0;const Z=v.Ch.Zero(),A=v.Quaternion.Identity(),d=v.Ch.One(),a=V.thinInstanceGetWorldMatrices(),n=v.TmpVectors.Ch[2],x=v.TmpVectors.Quaternion[1],N=v.TmpVectors.Ch[3];let D=!1,k=!1,u=!1;const F=new Float32Array(3*V.kd),b=new Float32Array(4*V.kd),o=new Float32Array(3*V.kd);let q=0;for(const h of a)h.decompose(N,x,n),H&&(p(n),Y(x)),F.set(n.mh(),3*q),b.set(x.normalize().mh(),4*q),o.set(N.mh(),3*q),D=D||!n.equalsWithEpsilon(Z),k=k||!x.equalsWithEpsilon(A),u=u||!N.equalsWithEpsilon(d),q++;const X={attributes:{}};D&&(X.attributes.TRANSLATION=this._buildAccessor(F,"VEC3",V.kd,K)),k&&(X.attributes.ROTATION=this._buildAccessor(b,"VEC4",V.kd,K)),u&&(X.attributes.SCALE=this._buildAccessor(o,"VEC3",V.kd,K)),h.extensions=h.extensions||{},h.extensions[MZ]=X}Z(h)}))}_buildAccessor(Z,h,V,v){const A=v.createBufferView(Z),H=v.createAccessor(A,h,5126,V);return this._exporter._accessors.push(H),this._exporter._accessors.length-1}}cZ.RegisterExtension(MZ,(Z=>new OZ(Z)));var sZ=V(12311),JZ=V(12315),fZ=V(12322),pZ=V(12326);function YZ(Z){return Z===fZ.d.PositionKind?"POSITION":Z===fZ.d.NormalKind?"NORMAL":Z===fZ.d.ColorKind?"COLOR":Z.startsWith(fZ.d.UVKind)?"TEX_COORD":"GENERIC"}const GZ={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Zh extends sZ.d{static get DefaultAvailable(){return(0,sZ.j)(Zh.DefaultConfiguration)}static get Default(){return Zh._Default??(Zh._Default=new Zh),Zh._Default}static ResetDefault(Z){Zh._Default&&(Z||Zh._Default.dispose(),Zh._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Z,h){return{module:await(h||DracoEncoderModule)({wasmBinary:Z})}}_getWorkerContent(){return`${JZ.i}(${JZ.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zh.DefaultConfiguration)}async _encodeAsync(Z,h,V){const v=V?(0,pZ.d)(GZ,V):GZ;if(this._workerPoolPromise){const V=await this._workerPoolPromise;return await new Promise(((A,H)=>{V.push(((V,K)=>{const d=Z=>{V.removeEventListener("error",d),V.removeEventListener("message",a),H(Z),K()},a=Z=>{"encodeMeshDone"===Z.data.id&&(V.removeEventListener("error",d),V.removeEventListener("message",a),A(Z.data.encodedMeshData),K())};V.addEventListener("error",d),V.addEventListener("message",a);const n=[];for(const h of Z)n.push(h.data.buffer);h&&n.push(h.buffer),V.postMessage({id:"encodeMesh",attributes:Z,indices:h,options:v},n)}))}))}if(this._modulePromise){const V=await this._modulePromise;return(0,JZ.i)(V.module,Z,h,v)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Z,h){if(0==Z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Z instanceof qZ.c&&Z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===h||void 0===h?void 0:h.method)&&(R.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),h.method="MESH_SEQUENTIAL_ENCODING");const V=function(Z){let h=Z.fh(void 0,!0);return!h||h instanceof Uint32Array||h instanceof Uint16Array||(h=((0,U.b)(h,h.length)?Uint32Array:Uint16Array).from(h)),h}(Z),v=function(Z,h){const V=[];for(const v of Z.getVerticesDataKinds()){if(null!==h&&void 0!==h&&h.includes(v)){if(v===fZ.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const A=Z.getVertexBuffer(v),H=A.getSize(),K=(0,U.r)(A.getData(),H,A.type,A.byteOffset,A.byteStride,A.normalized,Z.getTotalVertices(),!0);V.push({kind:v,dracoName:YZ(v),size:H,data:K})}return V}(Z,null===h||void 0===h?void 0:h.excludedAttributes);return await this._encodeAsync(v,V,h)}}Zh.DefaultConfiguration={wasmUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${A.Tools._DefaultCdnUrl}/draco_encoder.js`},Zh._Default=null;const hh="KHR_draco_mesh_compression";class Vh{get wasUsed(){return this._wasUsed}constructor(Z){this.name=hh,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Z.options.meshCompressionMethod&&Zh.DefaultAvailable}dispose(){}postExportMeshPrimitive(Z,h,V){if(!this.enabled)return;if(4!==Z.mode&&5!==Z.mode)return void R.b.Warn("Cannot compress primitive with mode "+Z.mode+".");const v=[],A=[];let H=null;if(void 0!==Z.indices){const K=V[Z.indices],d=h.getBufferView(K);H=h.getData(d).slice(),v.push(d),A.push(K)}const K=[];for(const[x,N]of Object.entries(Z.attributes)){const Z=V[N],H=h.getBufferView(Z),a=O(Z.type),n=(0,U.r)(h.getData(H),a,Z.componentType,Z.byteOffset||0,H.byteStride||(0,U.k)(Z.componentType)*a,Z.normalized||!1,Z.count,!0);K.push({kind:x,dracoName:(d=x,"POSITION"===d?"POSITION":"NORMAL"===d?"NORMAL":d.startsWith("COLOR")?"COLOR":d.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:O(Z.type),data:n}),v.push(H),A.push(Z)}var d;const a={method:Z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},n=Zh.Default._encodeAsync(K,H,a).then((V=>{if(!V)return void R.b.Error("Draco encoding failed for primitive.");const H={bufferView:-1,attributes:V.attributeIds},K=h.createBufferView(V.data);h.setBufferView(H,K);for(const Z of v)this._bufferViewsUsed.add(Z);for(const Z of A)this._accessorsUsed.add(Z);Z.extensions||(Z.extensions={}),Z.extensions[hh]=H})).catch((Z=>{R.b.Error("Draco encoding failed for primitive: "+Z)}));this._encodePromises.push(n),this._wasUsed=!0}async preGenerateBinaryAsync(Z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((h=>{Z.getPropertiesWithBufferView(h).every((Z=>this._accessorsUsed.has(Z)))&&Z.removeBufferView(h)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}cZ.RegisterExtension(hh,(Z=>new Vh(Z)));var vh=V(12333);const Ah="KHR_lights_punctual",Hh={name:"",color:[1,1,1],Fd:1,range:Number.MAX_VALUE},Kh={innerConeAngle:0,outerConeAngle:Math.PI/4},dh=v.Ch.Backward();class ah{constructor(Z){this.name=Ah,this.enabled=!0,this.required=!1,this._exporter=Z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Ah]=this._lights}async postExportNodeAsync(Z,h,V,A,H){return await new Promise((K=>{if(!(V instanceof XZ.c))return void K(h);const d=V.getTypeID()==XZ.c.LIGHTTYPEID_POINTLIGHT?"point":V.getTypeID()==XZ.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":V.getTypeID()==XZ.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!d||!(V instanceof vh.d))return R.b.Warn(`${Z}: Light ${V.name} is not supported in ${Ah}`),void K(h);if(V.falloffType!==XZ.c.FALLOFF_GLTF&&R.b.Warn(`${Z}: Light falloff for ${V.name} does not match the ${Ah} specification!`),!V.position.equalsToFloats(0,0,0)){const Z=v.TmpVectors.Ch[0].v(V.position);H&&p(Z),h.translation=Z.mh()}if("point"!==d){const Z=V.direction.normalizeToRef(v.TmpVectors.Ch[0]);H&&p(Z);const A=v.Quaternion.FromUnitVectorsToRef(dh,Z,v.TmpVectors.Quaternion[0]);v.Quaternion.IsIdentity(A)||(h.rotation=A.mh())}const a={type:d,name:V.name,color:V.bd.mh(),Fd:V.Fd,range:V.range};if(vZ(a,Hh),"spot"===d){const Z=V;a.spot={innerConeAngle:Z.innerAngle/2,outerConeAngle:Z.angle/2},vZ(a.spot,Kh)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(a);const n={Dh:this._lights.lights.length-1},x=V.parent;if(x&&hZ(V,x)){const Z=A.get(x);if(Z){const V=this._exporter._nodes[Z];return ZZ(h,V),V.extensions||(V.extensions={}),V.extensions[Ah]=n,void K(null)}}h.extensions||(h.extensions={}),h.extensions[Ah]=n,K(h)}))}}cZ.RegisterExtension(Ah,(Z=>new ah(Z)));var nh=V(12246);const xh="KHR_materials_anisotropy";class Nh{constructor(Z){this.name=xh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof nh.e&&V.anisotropy.isEnabled&&!V.anisotropy.legacy?(V.anisotropy.texture&&v.push(V.anisotropy.texture),v):[]}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof nh.e){if(!V.anisotropy.isEnabled||V.anisotropy.legacy)return void Z(h);this._wasUsed=!0,h.extensions=h.extensions||{};const v=this._exporter._materialExporter.getTextureInfo(V.anisotropy.texture),A={anisotropyStrength:V.anisotropy.Fd,anisotropyRotation:V.anisotropy.angle,anisotropyTexture:v??void 0};null!==A.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(V),h.extensions[xh]=A}Z(h)}))}}cZ.RegisterExtension(xh,(Z=>new Nh(Z)));const Dh="KHR_materials_clearcoat";class kh{constructor(Z){this.name=Dh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof nh.e&&V.clearCoat.isEnabled?(V.clearCoat.texture&&v.push(V.clearCoat.texture),!V.clearCoat.useRoughnessFromMainTexture&&V.clearCoat.textureRoughness&&v.push(V.clearCoat.textureRoughness),V.clearCoat.bumpTexture&&v.push(V.clearCoat.bumpTexture),v):[]}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof nh.e){if(!V.clearCoat.isEnabled)return void Z(h);this._wasUsed=!0,h.extensions=h.extensions||{};const v=this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture);let H;H=V.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(V.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(V.clearCoat.textureRoughness),V.clearCoat.isTintEnabled&&A.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${V.name}`),V.clearCoat.remapF0OnInterfaceChange&&A.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${V.name}`);const K=this._exporter._materialExporter.getTextureInfo(V.clearCoat.bumpTexture),d={clearcoatFactor:V.clearCoat.Fd,clearcoatTexture:v??void 0,clearcoatRoughnessFactor:V.clearCoat.roughness,clearcoatRoughnessTexture:H??void 0,clearcoatNormalTexture:K??void 0};null===d.clearcoatTexture&&null===d.clearcoatRoughnessTexture&&null===d.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),h.extensions[Dh]=d}Z(h)}))}}cZ.RegisterExtension(Dh,(Z=>new kh(Z)));const uh="KHR_materials_diffuse_transmission";function Fh(Z,h){const V=h.subSurface;let v=null;return V.translucencyIntensityTexture?v=V.translucencyIntensityTexture:V.thicknessTexture&&V.useMaskFromThicknessTexture&&(v=V.thicknessTexture),v&&!V.useGltfStyleTextures?(R.b.Warn(`${Z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${h.name}`,1),null):v}class bh{constructor(Z){this.name=uh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];if(V instanceof uZ.c&&this._isExtensionEnabled(V)){const h=Fh(Z,V);return h&&v.push(h),V.subSurface.translucencyColorTexture&&v.push(V.subSurface.translucencyColorTexture),v}return v}_isExtensionEnabled(Z){if(Z.unlit)return!1;const h=Z.subSurface;return!!h.isTranslucencyEnabled&&(!Z.unlit&&!h.useAlbedoToTintTranslucency&&h.useGltfStyleTextures&&1===h.volumeIndexOfRefraction&&0===h.minimumThickness&&0===h.maximumThickness)}postExportMaterialAsync(Z,h,V){return new Promise((v=>{if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0;const v=V.subSurface,A=Fh(Z,V),H=0==v.translucencyIntensity?void 0:v.translucencyIntensity,K=this._exporter._materialExporter.getTextureInfo(A)??void 0,d=!v.translucencyColor||v.translucencyColor.equalsFloats(1,1,1)?void 0:v.translucencyColor.mh(),a=this._exporter._materialExporter.getTextureInfo(v.translucencyColorTexture)??void 0,n={diffuseTransmissionFactor:H,diffuseTransmissionTexture:K,diffuseTransmissionColorFactor:d,diffuseTransmissionColorTexture:a};(K||a)&&this._exporter._materialNeedsUVsSet.add(V),h.extensions=h.extensions||{},h.extensions[uh]=n}v(h)}))}}cZ.RegisterExtension(uh,(Z=>new bh(Z)));const oh="KHR_materials_dispersion";class qh{constructor(){this.name=oh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){if(Z.unlit)return!1;const h=Z.subSurface;return!(!h.isRefractionEnabled&&!h.isDispersionEnabled)}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0;const Z={dispersion:V.subSurface.dispersion};h.extensions=h.extensions||{},h.extensions[oh]=Z}Z(h)}))}}cZ.RegisterExtension(oh,(()=>new qh));const Xh="KHR_materials_emissive_strength";class Eh{constructor(){this.name=Xh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Z,h,V){return await new Promise((Z=>{if(!(V instanceof uZ.c))return Z(h);const v=V.emissiveColor.mh(),A=Math.max(...v);if(A>1){this._wasUsed=!0,h.extensions||(h.extensions={});const Z={emissiveStrength:A},v=V.emissiveColor.scale(1/Z.emissiveStrength);h.emissiveFactor=v.mh(),h.extensions[Xh]=Z}return Z(h)}))}}cZ.RegisterExtension(Xh,(Z=>new Eh));const jh="KHR_materials_ior";class Ph{constructor(){this.name=jh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.indexOfRefraction&&1.5!=Z.indexOfRefraction)}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0;const Z={ior:V.indexOfRefraction};h.extensions=h.extensions||{},h.extensions[jh]=Z}Z(h)}))}}cZ.RegisterExtension(jh,(Z=>new Ph));const Ch="KHR_materials_iridescence";class lh{constructor(Z){this.name=Ch,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof nh.e&&V.iridescence.isEnabled?(V.iridescence.texture&&v.push(V.iridescence.texture),V.iridescence.thicknessTexture&&V.iridescence.thicknessTexture!==V.iridescence.texture&&v.push(V.iridescence.thicknessTexture),v):[]}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof nh.e){if(!V.iridescence.isEnabled)return void Z(h);this._wasUsed=!0,h.extensions=h.extensions||{};const v=this._exporter._materialExporter.getTextureInfo(V.iridescence.texture),A=this._exporter._materialExporter.getTextureInfo(V.iridescence.thicknessTexture),H={iridescenceFactor:V.iridescence.Fd,iridescenceIor:V.iridescence.indexOfRefraction,iridescenceThicknessMinimum:V.iridescence.minimumThickness,iridescenceThicknessMaximum:V.iridescence.maximumThickness,iridescenceTexture:v??void 0,iridescenceThicknessTexture:A??void 0};null===H.iridescenceTexture&&null===H.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(V),h.extensions[Ch]=H}Z(h)}))}}cZ.RegisterExtension(Ch,(Z=>new lh(Z)));const Bh="KHR_materials_sheen";class Sh{constructor(Z){this.name=Bh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){return V instanceof uZ.c&&V.sheen.isEnabled&&V.sheen.texture?[V.sheen.texture]:[]}async postExportMaterialAsync(Z,h,V){return await new Promise((Z=>{if(V instanceof uZ.c){if(!V.sheen.isEnabled)return void Z(h);this._wasUsed=!0,null==h.extensions&&(h.extensions={});const v={sheenColorFactor:V.sheen.color.mh(),sheenRoughnessFactor:V.sheen.roughness??0};null===v.sheenColorTexture&&null===v.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(V),V.sheen.texture&&(v.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),V.sheen.textureRoughness&&!V.sheen.useRoughnessFromMainTexture?v.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.textureRoughness)??void 0:V.sheen.texture&&V.sheen.useRoughnessFromMainTexture&&(v.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(V.sheen.texture)??void 0),h.extensions[Bh]=v}Z(h)}))}}cZ.RegisterExtension(Bh,(Z=>new Sh(Z)));const rh="KHR_materials_specular";class Lh{constructor(Z){this.name=rh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof uZ.c&&this._isExtensionEnabled(V)?(V.metallicReflectanceTexture&&v.push(V.metallicReflectanceTexture),V.reflectanceTexture&&v.push(V.reflectanceTexture),v):v}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.metallicF0Factor&&1!=Z.metallicF0Factor||void 0!=Z.metallicReflectanceColor&&!Z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.metallicReflectanceTexture||null!=Z.reflectanceTexture}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0,h.extensions=h.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(V.metallicReflectanceTexture)??void 0,v=this._exporter._materialExporter.getTextureInfo(V.reflectanceTexture)??void 0,A={specularFactor:1==V.metallicF0Factor?void 0:V.metallicF0Factor,specularTexture:Z,specularColorFactor:V.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:V.metallicReflectanceColor.mh(),specularColorTexture:v};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),h.extensions[rh]=A}Z(h)}))}}cZ.RegisterExtension(rh,(Z=>new Lh(Z)));const yh="KHR_materials_transmission";class Wh{constructor(Z){this.name=yh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof uZ.c&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&v.push(V.subSurface.thicknessTexture),v):v}_isExtensionEnabled(Z){if(Z.unlit)return!1;const h=Z.subSurface;return h.isRefractionEnabled&&void 0!=h.refractionIntensity&&0!=h.refractionIntensity||this._hasTexturesExtension(Z)}_hasTexturesExtension(Z){return null!=Z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Z,h,V){if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0;const v=V.subSurface,A={transmissionFactor:0===v.refractionIntensity?void 0:v.refractionIntensity};if(this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),v.refractionIntensityTexture)if(v.useGltfStyleTextures){const Z=await this._exporter._materialExporter.exportTextureAsync(v.refractionIntensityTexture,"image/png");Z&&(A.transmissionTexture=Z)}else R.b.Warn(`${Z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);h.extensions||(h.extensions={}),h.extensions[yh]=A}return h}}cZ.RegisterExtension(yh,(Z=>new Wh(Z)));const zh="KHR_materials_unlit";class mh{constructor(){this.name=zh,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{let v=!1;V instanceof uZ.c?v=V.unlit:V instanceof FZ.gh&&(v=V.disableLighting),v&&(this._wasUsed=!0,null==h.extensions&&(h.extensions={}),h.extensions[zh]={}),Z(h)}))}}cZ.RegisterExtension(zh,(()=>new mh));const gh="KHR_materials_volume";class Ih{constructor(Z){this.name=gh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof uZ.c&&this._isExtensionEnabled(V)?(V.subSurface.thicknessTexture&&v.push(V.subSurface.thicknessTexture),v):v}_isExtensionEnabled(Z){if(Z.unlit)return!1;const h=Z.subSurface;return!(!h.isRefractionEnabled&&!h.isTranslucencyEnabled)&&(void 0!=h.maximumThickness&&0!=h.maximumThickness||void 0!=h.tintColorAtDistance&&h.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=h.tintColor&&h.tintColor!=b.Ih.White()||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.subSurface.thicknessTexture}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof uZ.c&&this._isExtensionEnabled(V)){this._wasUsed=!0;const Z=V.subSurface,v={thicknessFactor:0==Z.maximumThickness?void 0:Z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Z.thicknessTexture)??void 0,attenuationDistance:Z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Z.tintColorAtDistance,attenuationColor:Z.tintColor.equalsFloats(1,1,1)?void 0:Z.tintColor.mh()};this._hasTexturesExtension(V)&&this._exporter._materialNeedsUVsSet.add(V),h.extensions=h.extensions||{},h.extensions[gh]=v}Z(h)}))}}cZ.RegisterExtension(gh,(Z=>new Ih(Z)));const eh="EXT_materials_diffuse_roughness";class Uh{constructor(Z){this.name=eh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,h,V){const v=[];return V instanceof nh.e&&V._baseDiffuseRoughness?(V._baseDiffuseRoughnessTexture&&v.push(V._baseDiffuseRoughnessTexture),v):[]}postExportMaterialAsync(Z,h,V){return new Promise((Z=>{if(V instanceof nh.e){if(!V._baseDiffuseRoughness)return void Z(h);this._wasUsed=!0,h.extensions=h.extensions||{};const v=this._exporter._materialExporter.getTextureInfo(V._baseDiffuseRoughnessTexture),A={diffuseRoughnessFactor:V._baseDiffuseRoughness,diffuseRoughnessTexture:v??void 0};null!==A.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(V),h.extensions[eh]=A}Z(h)}))}}cZ.RegisterExtension(eh,(Z=>new Uh(Z)));const Rh="KHR_texture_transform";class Qh{constructor(){this.name=Rh,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Z,h,V){if(V.CZ()||A.Tools.Warn(`${Z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${V.name}!`),(0!==V.uAng||0!==V.vAng)&&(A.Tools.Warn(`${Z}: Texture ${V.name} with rotation in the u or v axis is not supported in glTF.`),0!==V.uRotationCenter||0!==V.vRotationCenter))return;const v={};let H=!1;if(0===V.uOffset&&0===V.vOffset||(v.offset=[V.uOffset,V.vOffset],H=!0),1===V.uScale&&1===V.vScale||(v.scale=[V.uScale,V.vScale],H=!0),0!==V.wAng){if(0!==V.uRotationCenter||0!==V.vRotationCenter){if(V.homogeneousRotationInUVTransform&&V.uScale!==V.vScale)return void A.Tools.Warn(`${Z}: Texture ${V.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Rh}.`);A.Tools.Warn(`${Z}: Texture ${V.name} with non-origin rotation center will be exported using an adjusted offset with ${Rh}.`),v.offset=function(Z){const{uOffset:h,vOffset:V,uRotationCenter:v,vRotationCenter:A,uScale:H,vScale:K,wAng:d}=Z,a=Math.cos(d),n=Math.sin(d),x=v*H,N=A*K;return[h+(x*(1-a)+N*n),V+(N*(1-a)-x*n)]}(V)}v.rotation=-V.wAng,H=!0}0!==V.coordinatesIndex&&(v.texCoord=V.coordinatesIndex,H=!0),H&&(this._wasUsed=!0,h.extensions||(h.extensions={}),h.extensions[Rh]=v)}}cZ.RegisterExtension(Rh,(()=>new Qh));class wh{static CreateSTL(Z){let h=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",A=arguments.length>3&&void 0!==arguments[3]&&arguments[3],H=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],K=arguments.length>5&&void 0!==arguments[5]&&arguments[5],d=arguments.length>6&&void 0!==arguments[6]&&arguments[6],a=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const n=function(Z,h,V){const A=[3*Z[V],3*Z[V+1],3*Z[V+2]],H=[new v.Ch(h[A[0]],h[A[0]+2],h[A[0]+1]),new v.Ch(h[A[1]],h[A[1]+2],h[A[1]+1]),new v.Ch(h[A[2]],h[A[2]+2],h[A[2]+1])],K=H[0].rh(H[1]),d=H[2].rh(H[1]);return{v:H,n:v.Ch.Cross(d,K).normalize()}},N=function(Z,h,V,v){return h=D(Z,h,V.x,v),h=D(Z,h,V.y,v),D(Z,h,V.z,v)},D=function(Z,h,V,v){return Z.setFloat32(h,V,v),h+4},u=function(Z){if(d){let h=Z;Z instanceof k.d&&(h=Z.sourceMesh);const V=h.getVerticesData(x.f.PositionKind,!0,!0);if(!V)return[];const A=v.Ch.Zero();let H;for(H=0;H<V.length;H+=3)v.Ch.TransformCoordinatesFromFloatsToRef(V[H],V[H+1],V[H+2],Z.sh(!0),A).toArray(V,H);return V}return Z.getVerticesData(x.f.PositionKind)||[]};d&&(K=!0);let F="",b=0,o=0;if(A){for(let V=0;V<Z.length;V++){const h=Z[V].fh();b+=h?h.length/3:0}const h=new ArrayBuffer(84+50*b);F=new DataView(h),o+=80,F.setUint32(o,b,H),o+=4}else a||(F="solid stlmesh\r\n");for(let v=0;v<Z.length;v++){const h=Z[v];!A&&a&&(F+="solid "+h.name+"\r\n"),!K&&h instanceof qZ.c&&h.bakeCurrentTransformIntoVertices();const V=u(h),d=h.fh()||[];for(let Z=0;Z<d.length;Z+=3){const h=n(d,V,Z);A?(o=N(F,o,h.n,H),o=N(F,o,h.v[0],H),o=N(F,o,h.v[1],H),o=N(F,o,h.v[2],H),o+=2):(F+="\tfacet normal "+h.n.x+" "+h.n.y+" "+h.n.z+"\r\n",F+="\t\touter loop\r\n",F+="\t\t\tvertex "+h.v[0].x+" "+h.v[0].y+" "+h.v[0].z+"\r\n",F+="\t\t\tvertex "+h.v[1].x+" "+h.v[1].y+" "+h.v[1].z+"\r\n",F+="\t\t\tvertex "+h.v[2].x+" "+h.v[2].y+" "+h.v[2].z+"\r\n",F+="\t\tendloop\r\n",F+="\tendfacet\r\n")}!A&&a&&(F+="endsolid "+name+"\r\n")}if(A||a||(F+="endsolid stlmesh"),h){const Z=document.createElement("a"),h=new Blob([F],{type:"application/octet-stream"});Z.href=window.URL.createObjectURL(h),Z.download=V+".stl",Z.click()}return F}}function Th(Z,h){let V=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const v=[];for(let A=0;A<Z.length/V;A++){const H=Z[A*V],K=Z[A*V+1],d=Z[A*V+2];v.push(`(${H.toPrecision(h.precision)}, ${K.toPrecision(h.precision)}, ${d.toPrecision(h.precision)})`)}return v.join(", ")}function th(Z,h){const V=[];for(let v=0;v<Z.length/2;v++){const A=Z[2*v],H=Z[2*v+1];V.push(`(${A.toPrecision(h.precision)}, ${(1-H).toPrecision(h.precision)})`)}return V.join(", ")}function ch(Z,h){const V=Z.getVerticesData(x.f.PositionKind),v=Z.getVerticesData(x.f.NormalKind);if(V&&v)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Z){var h;const V=null!==(h=Z.fh())&&void 0!==h&&h.length?Z.getTotalIndices():Z.getTotalVertices();return Array(V/3).fill(3).join(", ")}(Z)}]\n\t\tint[] faceVertexIndices = [${function(Z){const h=Z.fh(),V=[];if(null!==h)for(let v=0;v<h.length;v++)V.push(h[v]);else{const h=Z.getTotalVertices();for(let Z=0;Z<h;Z++)V.push(Z)}return V.join(", ")}(Z)}]\n\t\tnormal3f[] normals = [${Th(v,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Th(V,h)}]\n        ${function(Z,h){let V="";for(let A=0;A<4;A++){const v=A>0?A:"",H=Z.getVerticesData(x.f.UVKind+(v?v+1:""));H&&(V+=`\n\t\ttexCoord2f[] primvars:st${v} = [${th(H,h)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const v=Z.getVerticesData(x.f.ColorKind);return v&&(V+=`\n\tcolor3f[] primvars:displayColor = [${Th(v,h,v.length/Z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),V}(Z,h)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ih(Z,h){return`\n        def "Geometry"\n        {\n        ${ch(Z,h)}\n        }\n        `}function Mh(Z){let h='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return h+=Z,fflate.strToU8(h)}function Oh(Z){const h=Z.m;return`( ${sh(h,0)}, ${sh(h,4)}, ${sh(h,8)}, ${sh(h,12)} )`}function sh(Z,h){return`(${Z[h+0]}, ${Z[h+1]}, ${Z[h+2]}, ${Z[h+3]})`}function Jh(Z){const h="Object_"+Z.uniqueId,V=function(Z){const h=Z.getWorldMatrix().clone(),V=Z.CZ().useRightHandedSystem;if(!V){let v=Z.parent;for(;v;){if(KZ(v,V)){h.multiplyToRef(v.getWorldMatrix().invert(),h);break}v=v.parent}}return h.determinant()<0&&A.Tools.Warn(`Exporting mesh ${Z.name} with negative scale. Result may look incorrect in destination engine.`),h}(Z),v=Oh(V);return`def Xform "${h}" (\n\tprepend references = @./geometries/Geometry_${Z.Jh.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${v}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Z.material.uniqueId}>\n}\n\n`}function fh(Z){switch(Z){case C.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case C.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case C.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function ph(Z){return`(${Z.x}, ${Z.y})`}function Yh(Z){return`(${Z.r}, ${Z.g}, ${Z.b})`}function Gh(Z,h,V,A,H,K){const d=Z.getInternalTexture().uniqueId+"_"+Z.invertY;H[d]=Z;const a=Z.coordinatesIndex>0?"st"+Z.coordinatesIndex:"st",n=new v.Vector2(Z.uScale,Z.vScale),x=new v.Vector2(Z.uOffset,Z.vOffset),N=Z.wAng,D=Math.sin(N),k=Math.cos(N);return x.y=1-x.y-n.y,x.x+=D*n.x,x.y+=(1-k)*n.y,`\n    def Shader "PrimvarReader_${V}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${a}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${V}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${h.uniqueId}/PrimvarReader_${V}.outputs:result>\n        float inputs:rotation = ${(N*(180/Math.PI)).toFixed(K.precision)}\n        float2 inputs:scale = ${ph(n)}\n        float2 inputs:translation = ${ph(x)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Z.uniqueId}_${V}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${d}.png@\n        float2 inputs:st.connect = </Materials/Material_${h.uniqueId}/Transform2d_${V}.outputs:result>\n        ${A?"float4 inputs:scale = "+function(Z){return`(${Z.r}, ${Z.g}, ${Z.b}, 1.0)`}(A):""}\n        token inputs:sourceColorSpace = "${Z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${fh(Z.wrapU)}"\n        token inputs:wrapT = "${fh(Z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${h.needAlphaBlending()?"float outputs:a":""}\n    }`}function ZV(Z,h,V){const v="\t\t\t",A=[],H=[],{diffuseMap:K,bd:d,alphaCutOff:a,emissiveMap:n,emissive:x,normalMap:N,roughnessMap:D,roughnessChannel:k,roughness:u,metalnessMap:F,metalnessChannel:o,metalness:q,aoMap:X,aoMapChannel:E,aoMapIntensity:j,alphaMap:P,ior:C,clearCoatEnabled:l,clearCoat:B,clearCoatMap:S,clearCoatRoughness:r,clearCoatRoughnessMap:L}=function(Z){const h={diffuseMap:null,bd:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Z instanceof FZ.gh?{...h,diffuseMap:Z.diffuseTexture,bd:Z.diffuseColor,alphaCutOff:Z.alphaCutOff,emissiveMap:Z.emissiveTexture,emissive:Z.emissiveColor,roughness:1,alphaMap:Z.opacityTexture}:Z instanceof nh.e?{...h,diffuseMap:Z._albedoTexture,bd:Z._albedoColor,alphaCutOff:Z._alphaCutOff,emissiveMap:Z._emissiveTexture,emissive:Z._emissiveColor,normalMap:Z._bumpTexture,roughnessMap:Z._metallicTexture,roughnessChannel:Z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Z._roughness??1,metalnessMap:Z._metallicTexture,metalnessChannel:Z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Z._metallic??0,aoMap:Z._ambientTexture,aoMapChannel:Z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Z._ambientTextureStrength,alphaMap:Z._opacityTexture,ior:Z.subSurface.indexOfRefraction,clearCoatEnabled:Z.clearCoat.isEnabled,clearCoat:Z.clearCoat.Fd,clearCoatMap:Z.clearCoat.texture,clearCoatRoughness:Z.clearCoat.roughness,clearCoatRoughnessMap:Z.clearCoat.useRoughnessFromMainTexture?Z.clearCoat.texture:Z.clearCoat.textureRoughness}:h}(Z);return null!==K?(A.push(`${v}color3f inputs:diffuseColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:rgb>`),Z.needAlphaBlending()?A.push(`${v}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:a>`):Z.needAlphaTesting()&&(A.push(`${v}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:a>`),A.push(`${v}float inputs:opacityThreshold = ${a}`)),H.push(Gh(K,Z,"diffuse",d,h,V))):A.push(`${v}color3f inputs:diffuseColor = ${Yh(d||b.Ih.White())}`),null!==n?(A.push(`${v}color3f inputs:emissiveColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${n.uniqueId}_emissive.outputs:rgb>`),H.push(Gh(n,Z,"emissive",x,h,V))):x&&x.toLuminance()>0&&A.push(`${v}color3f inputs:emissiveColor = ${Yh(x)}`),null!==N&&(A.push(`${v}normal3f inputs:normal.connect = </Materials/Material_${Z.uniqueId}/Texture_${N.uniqueId}_normal.outputs:rgb>`),H.push(Gh(N,Z,"normal",null,h,V))),null!==X&&(A.push(`${v}float inputs:occlusion.connect = </Materials/Material_${Z.uniqueId}/Texture_${X.uniqueId}_occlusion.outputs:${E}>`),H.push(Gh(X,Z,"occlusion",new b.Ih(j,j,j),h,V))),null!==D?(A.push(`${v}float inputs:roughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${D.uniqueId}_roughness.outputs:${k}>`),H.push(Gh(D,Z,"roughness",new b.Ih(u,u,u),h,V))):A.push(`${v}float inputs:roughness = ${u}`),null!==F?(A.push(`${v}float inputs:metallic.connect = </Materials/Material_${Z.uniqueId}/Texture_${F.uniqueId}_metallic.outputs:${o}>`),H.push(Gh(F,Z,"metallic",new b.Ih(q,q,q),h,V))):A.push(`${v}float inputs:metallic = ${q}`),null!==P?(A.push(`${v}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${P.uniqueId}_opacity.outputs:r>`),A.push(`${v}float inputs:opacityThreshold = 0.0001`),H.push(Gh(P,Z,"opacity",null,h,V))):A.push(`${v}float inputs:opacity = ${Z.alpha}`),l&&(null!==S?(A.push(`${v}float inputs:clearcoat.connect = </Materials/Material_${Z.uniqueId}/Texture_${S.uniqueId}_clearcoat.outputs:r>`),H.push(Gh(S,Z,"clearcoat",new b.Ih(B,B,B),h,V))):A.push(`${v}float inputs:clearcoat = ${B}`),null!==L?(A.push(`${v}float inputs:clearcoatRoughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${L.uniqueId}_clearcoatRoughness.outputs:g>`),H.push(Gh(L,Z,"clearcoatRoughness",new b.Ih(r,r,r),h,V))):A.push(`${v}float inputs:clearcoatRoughness = ${r}`)),A.push(`${v}float inputs:ior = ${C}`),`\n\tdef Material "Material_${Z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${A.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Z.uniqueId}/PreviewSurface.outputs:surface>\n\n${H.join("\n")}\n\n\t}\n`}async function hV(Z,h,V){const H={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...h};"undefined"===typeof fflate&&await A.Tools.LoadScriptAsync(H.fflateUrl);const K={};K[H.modelFileName]=null;let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';d+=function(Z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Z.planeAnchoringAlignment}"`:""}\n            `}(H);const a={};for(const v of Z.meshes){if(0===v.getTotalVertices())continue;const Z=v,h=Z.Jh,n=Z.material;if(!n||!h||V&&!V(Z))continue;if(-1!==["gh","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(n.getClassName())){const V="geometries/Geometry_"+h.uniqueId+".usda";if(!(V in K)){const Z=ih(h,H);K[V]=Mh(Z)}n.uniqueId in a||(a[n.uniqueId]=n),d+=Jh(Z)}else A.Tools.Warn("USDZExportAsync does not support this material type: "+n.getClassName())}Z.activeCamera&&H.exportCamera&&(d+=function(Z,h){const V="Camera_"+Z.uniqueId,A=Oh(v.Matrix.RotationY(Math.PI).multiply(Z.getWorldMatrix()));if(Z.mode===C.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Rh.toPrecision(h.precision)}, ${Z.maxZ.toPrecision(h.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Z.orthoLeft||1)+Math.abs(Z.orthoRight||1))).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Z.orthoTop||1)+Math.abs(Z.orthoBottom||1))).toPrecision(h.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const v=Z.getEngine().getAspectRatio(Z),H=h.cameraSensorWidth||35;return`def Camera "${V}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${A}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.Rh.toPrecision(h.precision)}, ${Z.maxZ.toPrecision(h.precision)})\n\t\t\tfloat focalLength = ${(H/(2*Math.tan(.5*Z.fov))).toPrecision(h.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(H*v).toPrecision(h.precision)}\n\t\t\tfloat verticalAperture = ${(H/v).toPrecision(h.precision)}            \n\t\t}\n\t\n\t`}}(Z.activeCamera,H)),d+="\n            }\n        }\n    }";const n={};d+=function(Z,h,V){const v=[];for(const A in Z){const H=Z[A];v.push(ZV(H,h,V))}return`\n    def "Materials"\n{\n${v.join("")}\n}\n\n`}(a,n,H),K[H.modelFileName]=fflate.strToU8(d);for(const v in n){const Z=n[v],h=Z.getSize(),V=await Z.readPixels();if(!V)throw new Error("Texture data is not available");const A=await l.DumpTools.DumpDataAsync(h.width,h.height,V,"image/png",void 0,!1,!0);K[`textures/Texture_${v}.png`]=new Uint8Array(A).slice()}let x=0;for(const v in K){const Z=K[v];if(!Z)continue;x+=34+v.length;const h=63&x;if(4!==h){const V=new Uint8Array(64-h);K[v]=[Z,{extra:{12345:V}}]}x=Z.length}return fflate.zipSync(K,{level:0})}}}]);