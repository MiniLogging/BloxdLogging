"use strict";(self["686i8587bmi"]=self["686i8587bmi"]||[]).push([[26],{13189:(h,d,T)=>{T.r(d),T.d(d,{EXT_materials_diffuse_roughness:()=>qd,EXT_mesh_gpu_instancing:()=>md,GLTF2Export:()=>Bh,GLTFData:()=>U,KHR_draco_mesh_compression:()=>Td,KHR_lights_punctual:()=>Fd,KHR_materials_anisotropy:()=>Sd,KHR_materials_clearcoat:()=>cd,KHR_materials_diffuse_transmission:()=>Jd,KHR_materials_dispersion:()=>Ld,KHR_materials_emissive_strength:()=>Vd,KHR_materials_ior:()=>wd,KHR_materials_iridescence:()=>Ed,KHR_materials_sheen:()=>xd,KHR_materials_specular:()=>Hd,KHR_materials_transmission:()=>kd,KHR_materials_unlit:()=>ud,KHR_materials_volume:()=>Kd,KHR_texture_transform:()=>ad,OBJExport:()=>n,STLExport:()=>ed,USDZExportAsync:()=>dT,_ConvertToGLTFPBRMetallicRoughness:()=>o,_SolveMetallic:()=>k,__IGLTFExporterExtension:()=>X});var Y=T(12765),y=T(12574),C=T(13089);class n{static OBJ(h,d,T,n){const X=[];let F=1,U=1;d&&(T||(T="mat"),X.push("mtllib "+T+".mtl"));for(let Z=0;Z<h.length;Z++){const T=h[Z],S=T.name||`mesh${Z}}`;X.push(`o ${S}`);let r=null;if(n){const h=T.Md(!0);r=new Y.Matrix,h.invertToRef(r),T.bakeTransformIntoVertices(h)}if(d){const h=T.material;h&&X.push("usemtl "+h.id)}const c=T.Rd;if(!c){y.Tools.Warn("No geometry is present on the mesh");continue}const O=c.getVerticesData("position"),f=c.getVerticesData("normal"),J=c.getVerticesData("uv"),W=c.Pd();let L=0,D=0;if(!O||!W){y.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const V=h[0].Eh().useRightHandedSystem?1:-1;for(let h=0;h<O.length;h+=3)X.push("v "+O[h]*V+" "+O[h+1]+" "+O[h+2]),L++;if(null!=f)for(let h=0;h<f.length;h+=3)X.push("vn "+f[h]*V+" "+f[h+1]+" "+f[h+2]);if(null!=J)for(let h=0;h<J.length;h+=2)X.push("vt "+J[h]+" "+J[h+1]),D++;const i=["","",""],w=(T.material||T.Eh().defaultMaterial)._getEffectiveOrientation(T),[s,E]=w===C.d.ClockWiseSideOrientation?[2,1]:[1,2];for(let h=0;h<W.length;h+=3){const d=[String(W[h]+F),String(W[h+s]+F),String(W[h+E]+F)],T=[String(W[h]+U),String(W[h+s]+U),String(W[h+E]+U)],Y=d,y=null!=J?T:i,C=null!=f?d:i;X.push("f "+Y[0]+"/"+y[0]+"/"+C[0]+" "+Y[1]+"/"+y[1]+"/"+C[1]+" "+Y[2]+"/"+y[2]+"/"+C[2])}n&&r&&T.bakeTransformIntoVertices(r),F+=L,U+=D}return X.join("\n")}static MTL(h){const d=[],T=h.material;d.push("newmtl mat1"),d.push("  Ns "+T.specularPower.toFixed(4)),d.push("  Ni 1.5000"),d.push("  d "+T.alpha.toFixed(4)),d.push("  Tr 0.0000"),d.push("  Tf 1.0000 1.0000 1.0000"),d.push("  illum 2"),d.push("  Ka "+T.ambientColor.r.toFixed(4)+" "+T.ambientColor.g.toFixed(4)+" "+T.ambientColor.b.toFixed(4)),d.push("  Kd "+T.diffuseColor.r.toFixed(4)+" "+T.diffuseColor.g.toFixed(4)+" "+T.diffuseColor.b.toFixed(4)),d.push("  Ks "+T.specularColor.r.toFixed(4)+" "+T.specularColor.g.toFixed(4)+" "+T.specularColor.b.toFixed(4)),d.push("  Ke "+T.emissiveColor.r.toFixed(4)+" "+T.emissiveColor.g.toFixed(4)+" "+T.emissiveColor.b.toFixed(4));T.ambientTexture&&d.push("  map_Ka "+T.ambientTexture.name),T.diffuseTexture&&d.push("  map_Kd "+T.diffuseTexture.name),T.specularTexture&&d.push("  map_Ks "+T.specularTexture.name),T.bumpTexture&&d.push("  map_bump -imfchan z "+T.bumpTexture.name),T.opacityTexture&&d.push("  map_d "+T.opacityTexture.name);return d.join("\n")}}var X=0,F=T(12627);class U{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const h in this.files){const d=this.files[h],T=new Blob([d],{type:(0,F.i)(h)});y.Tools.Download(T,h)}}}var Z=T(12835),S=T(13192),r=T(13198),c=T(13211),O=T(12885),f=T(12625),J=T(12812),W=T(12787);const L=W.HighestCommonFactor,D={...W,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:L};var V=T(12979),i=T(12741),w=T(13238),s=T(13243),E=T(12972);const z=1e-6,x=new J.ed(.04,.04,.04),g=1024,H=J.ed.White(),p=J.ed.Black();function k(h,d,T){if(d<x.r)return 0;const Y=x.r,y=h*T/(1-x.r)+d-2*x.r,C=y*y-4*Y*(x.r-d);return D.Clamp((-y+Math.sqrt(C))/(2*Y),0,1)}function o(h){const d=h.diffuseColor.toLinearSpace(h.Eh().getEngine().useExactSrgbConversions).scale(.5),T=h.alpha,y=function(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new Y.Vector2(0,1),T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Y.Vector2(0,.1),y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Y.Vector2(0,.1),C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new Y.Vector2(1300,.1);return function(h,d,T,Y,y){return(1-h)*(1-h)*(1-h)*d+3*(1-h)*(1-h)*h*T+3*(1-h)*h*h*Y+h*h*h*y}(Math.pow(h/C.x,.333333),d.y,T.y,y.y,C.y)}(D.Clamp(h.specularPower,0,g));return{baseColorFactor:[d.r,d.g,d.b,T],metallicFactor:0,roughnessFactor:y}}function u(h,d){d.needAlphaBlending()?h.alphaMode="BLEND":d.needAlphaTesting()&&(h.alphaMode="MASK",h.alphaCutoff=d.alphaCutOff)}function N(h,d,T){const Y=new Uint8Array(h*d*4);for(let y=0;y<Y.length;y+=4)Y[y]=Y[y+1]=Y[y+2]=Y[y+3]=255;return w.b.CreateRGBATexture(Y,h,d,T)}function K(h){if(h instanceof Uint8Array){const d=h.length,T=new Float32Array(h.length);for(let Y=0;Y<d;++Y)T[Y]=h[Y]/255;return T}if(h instanceof Float32Array)return h;throw new Error("Unsupported pixel format!")}class l{constructor(h){this._exporter=h,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(h){return h?this._textureMap.get(h)??null:null}async exportStandardMaterialAsync(h,d,T){const Y=o(h),C={name:h.name};if(null==h.td||h.td||(h.twoSidedLighting||y.Tools.Warn(h.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),T){const T=[],y=h.diffuseTexture;y&&T.push(this.exportTextureAsync(y,d).then((h=>{h&&(Y.baseColorTexture=h)})));const n=h.bumpTexture;n&&T.push(this.exportTextureAsync(n,d).then((h=>{h&&(C.normalTexture=h,1!==n.level&&(C.normalTexture.scale=n.level))})));const X=h.emissiveTexture;X&&(C.emissiveFactor=[1,1,1],T.push(this.exportTextureAsync(X,d).then((h=>{h&&(C.emissiveTexture=h)}))));const F=h.ambientTexture;F&&T.push(this.exportTextureAsync(F,d).then((h=>{if(h){const d={index:h.index};C.occlusionTexture=d}}))),T.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(T))}(h.alpha<1||h.opacityTexture)&&(h.alphaMode===s.b.ALPHA_COMBINE?C.alphaMode="BLEND":y.Tools.Warn(h.name+": glTF 2.0 does not support alpha mode: "+h.alphaMode.toString())),h.emissiveColor&&!h.emissiveColor.equalsWithEpsilon(p,z)&&(C.emissiveFactor=h.emissiveColor.ad()),C.pbrMetallicRoughness=Y,u(C,h),await this._finishMaterialAsync(C,h,d);const n=this._exporter._materials;return n.push(C),n.length-1}async _finishMaterialAsync(h,d,T){const Y=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",h,d),y=[];for(const C of Y)y.push(this.exportTextureAsync(C,T));await Promise.all(y),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",h,d)}async _getImageDataAsync(h,d,Y,y){const C=s.b.TEXTURETYPE_UNSIGNED_BYTE,n=this._exporter._babylonScene,X=n.getEngine(),F=X.createRawTexture(h,d,Y,s.b.TEXTUREFORMAT_RGBA,!1,!0,i.c.NEAREST_SAMPLINGMODE,null,C);X.isWebGPU?await T.e(51).then(T.bind(T,15280)):await T.e(52).then(T.bind(T,15286)),await V.g.ApplyPostProcess("pass",F,n,C,s.b.TEXTURE_NEAREST_SAMPLINGMODE,s.b.TEXTUREFORMAT_RGBA);const U=await X._readTexturePixels(F,d,Y);return await E.DumpTools.DumpDataAsync(d,Y,U,y,void 0,!0,!0)}_resizeTexturesToSameDimensions(h,d,T){const Y=h?h.getSize():{width:0,height:0},y=d?d.getSize():{width:0,height:0};let C,n;return Y.width<y.width?(C=h&&h instanceof i.c?V.g.CreateResizedCopy(h,y.width,y.height,!0):N(y.width,y.height,T),n=d):Y.width>y.width?(n=d&&d instanceof i.c?V.g.CreateResizedCopy(d,Y.width,Y.height,!0):N(Y.width,Y.height,T),C=h):(C=h,n=d),{texture1:C,texture2:n}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(h,d,T,Y){const y=new Array;if(!h&&!d)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const C=h?h.Eh():d?d.Eh():null;if(C){var n;const X=this._resizeTexturesToSameDimensions(h,d,C),F=null===(n=X.texture1)||void 0===n?void 0:n.getSize();let U,Z;const S=F.width,r=F.height,c=await X.texture1.readPixels(),O=await X.texture2.readPixels();if(!c)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(U=K(c),!O)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");Z=K(O);const f=Z.byteLength,W=new Uint8Array(f),L=new Uint8Array(f),D=4,V=p;let i=0,w=0;for(let h=0;h<r;++h)for(let d=0;d<S;++d){const Y=(S*h+d)*D,y={diffuseColor:new J.ed(U[Y],U[Y+1],U[Y+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(T.diffuseColor),specularColor:new J.ed(Z[Y],Z[Y+1],Z[Y+2]).toLinearSpace(C.getEngine().useExactSrgbConversions).multiply(T.specularColor),glossiness:Z[Y+3]*T.glossiness},n=this._convertSpecularGlossinessToMetallicRoughness(y);V.r=Math.max(V.r,n.baseColor.r),V.g=Math.max(V.g,n.baseColor.g),V.b=Math.max(V.b,n.baseColor.b),i=Math.max(i,n.metallic),w=Math.max(w,n.roughness),L[Y]=255*n.baseColor.r,L[Y+1]=255*n.baseColor.g,L[Y+2]=255*n.baseColor.b,L[Y+3]=X.texture1.vd?255*U[Y+3]:255,W[Y]=0,W[Y+1]=255*n.roughness,W[Y+2]=255*n.metallic,W[Y+3]=255}const s={baseColor:V,metallic:i,roughness:w};let E=!1,x=!1;for(let h=0;h<r;++h)for(let d=0;d<S;++d){const T=(S*h+d)*D;L[T]/=s.baseColor.r>z?s.baseColor.r:1,L[T+1]/=s.baseColor.g>z?s.baseColor.g:1,L[T+2]/=s.baseColor.b>z?s.baseColor.b:1;const Y=J.ed.FromInts(L[T],L[T+1],L[T+2]).toGammaSpace(C.getEngine().useExactSrgbConversions);L[T]=255*Y.r,L[T+1]=255*Y.g,L[T+2]=255*Y.b,Y.equalsWithEpsilon(H,z)||(x=!0),W[T+1]/=s.roughness>z?s.roughness:1,W[T+2]/=s.metallic>z?s.metallic:1;J.ed.FromInts(255,W[T+1],W[T+2]).equalsWithEpsilon(H,z)||(E=!0)}return E&&y.push(this._getImageDataAsync(W,S,r,Y).then((h=>{s.metallicRoughnessTextureData=h}))),x&&y.push(this._getImageDataAsync(L,S,r,Y).then((h=>{s.baseColorTextureData=h}))),await Promise.all(y).then((()=>s))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(h){const d=this._getPerceivedBrightness(h.diffuseColor),T=this._getPerceivedBrightness(h.specularColor),Y=1-this._getMaxComponent(h.specularColor),y=k(d,T,Y),C=h.diffuseColor.scale(Y/(1-x.r)/Math.max(1-y)),n=h.specularColor.Nd(x.scale(1-y)).scale(1/Math.max(y));let X=J.ed.Lerp(C,n,y*y);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:y,roughness:1-h.glossiness}}_getPerceivedBrightness(h){return h?Math.sqrt(.299*h.r*h.r+.587*h.g*h.g+.114*h.b*h.b):0}_getMaxComponent(h){return h?Math.max(h.r,Math.max(h.g,h.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(h,d,T,Y){const y=[],C={baseColor:h._albedoColor,metallic:h._metallic,roughness:h._roughness};if(Y){h._albedoTexture&&y.push(this.exportTextureAsync(h._albedoTexture,d).then((h=>{h&&(T.baseColorTexture=h)})));const Y=h._metallicTexture;Y&&y.push(this.exportTextureAsync(Y,d).then((h=>{h&&(T.metallicRoughnessTexture=h)})))}return y.length>0&&(this._exporter._materialNeedsUVsSet.add(h),await Promise.all(y)),C}_getTextureSampler(h){const d={};if(!h||!(h instanceof i.c))return d;const T=this._getGLTFTextureWrapMode(h.wrapU);10497!==T&&(d.wrapS=T);const Y=this._getGLTFTextureWrapMode(h.wrapV);switch(10497!==Y&&(d.wrapT=Y),h.samplingMode){case i.c.LINEAR_LINEAR:d.magFilter=9729,d.minFilter=9729;break;case i.c.LINEAR_NEAREST:d.magFilter=9729,d.minFilter=9728;break;case i.c.NEAREST_LINEAR:d.magFilter=9728,d.minFilter=9729;break;case i.c.NEAREST_LINEAR_MIPLINEAR:d.magFilter=9728,d.minFilter=9987;break;case i.c.NEAREST_NEAREST:d.magFilter=9728,d.minFilter=9728;break;case i.c.NEAREST_LINEAR_MIPNEAREST:d.magFilter=9728,d.minFilter=9985;break;case i.c.LINEAR_NEAREST_MIPNEAREST:d.magFilter=9729,d.minFilter=9984;break;case i.c.LINEAR_NEAREST_MIPLINEAR:d.magFilter=9729,d.minFilter=9986;break;case i.c.NEAREST_NEAREST_MIPLINEAR:d.magFilter=9728,d.minFilter=9986;break;case i.c.LINEAR_LINEAR_MIPLINEAR:d.magFilter=9729,d.minFilter=9987;break;case i.c.LINEAR_LINEAR_MIPNEAREST:d.magFilter=9729,d.minFilter=9985;break;case i.c.NEAREST_NEAREST_MIPNEAREST:d.magFilter=9728,d.minFilter=9984}return d}_getGLTFTextureWrapMode(h){switch(h){case i.c.WRAP_ADDRESSMODE:return 10497;case i.c.CLAMP_ADDRESSMODE:return 33071;case i.c.MIRROR_ADDRESSMODE:return 33648;default:return y.Tools.Error(`Unsupported Texture Wrap Mode ${h}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(h,d,T,Y){const y={diffuseColor:h._albedoColor,specularColor:h._reflectivityColor,glossiness:h._microSurface},C=h._albedoTexture,n=h._reflectivityTexture,X=h._useMicroSurfaceFromReflectivityMapAlpha;if(n&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((C||n)&&Y){this._exporter._materialNeedsUVsSet.add(h);const Y=this._exportTextureSampler(C||n),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(C,n,y,d),F=this._exporter._textures;if(X.baseColorTextureData){const h=this._exportImage(`baseColor${F.length}`,d,X.baseColorTextureData);T.baseColorTexture=this._exportTextureInfo(h,Y,null===C||void 0===C?void 0:C.coordinatesIndex)}if(X.metallicRoughnessTextureData){const h=this._exportImage(`metallicRoughness${F.length}`,d,X.metallicRoughnessTextureData);T.metallicRoughnessTexture=this._exportTextureInfo(h,Y,null===n||void 0===n?void 0:n.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(y)}async exportPBRMaterialAsync(h,d,T){const Y={},y={name:h.name},C=h.isMetallicWorkflow();if(C){const d=h._albedoColor,T=h.alpha;d&&(Y.baseColorFactor=[d.r,d.g,d.b,T])}const n=C?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(h,d,Y,T):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(h,d,Y,T);await this._setMetallicRoughnessPbrMaterialAsync(n,h,y,Y,d,T),await this._finishMaterialAsync(y,h,d);const X=this._exporter._materials;return X.push(y),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(h,d,T,Y,C,n){if(u(T,d),h.baseColor.equalsWithEpsilon(H,z)&&D.WithinEpsilon(d.alpha,1,z)||(Y.baseColorFactor=[h.baseColor.r,h.baseColor.g,h.baseColor.b,d.alpha]),null!=h.metallic&&1!==h.metallic&&(Y.metallicFactor=h.metallic),null!=h.roughness&&1!==h.roughness&&(Y.roughnessFactor=h.roughness),null==d.td||d.td||(d._twoSidedLighting||y.Tools.Warn(d.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),T.doubleSided=!0),n){const h=[],Y=d._bumpTexture;Y&&h.push(this.exportTextureAsync(Y,C).then((h=>{h&&(T.normalTexture=h,1!==Y.level&&(T.normalTexture.scale=Y.level))})));const y=d._ambientTexture;y&&h.push(this.exportTextureAsync(y,C).then((h=>{if(h){const Y={index:h.index,texCoord:h.texCoord,extensions:h.extensions};T.occlusionTexture=Y;const y=d._ambientTextureStrength;y&&(Y.strength=y)}})));const n=d._emissiveTexture;n&&h.push(this.exportTextureAsync(n,C).then((h=>{h&&(T.emissiveTexture=h)}))),h.length>0&&(this._exporter._materialNeedsUVsSet.add(d),await Promise.all(h))}const X=d._emissiveColor;X.equalsWithEpsilon(p,z)||(T.emissiveFactor=X.ad()),T.pbrMetallicRoughness=Y}_getPixelsFromTextureAsync(h){return function(h){switch(h){case s.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case s.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case s.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case s.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case s.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case s.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case s.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case s.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case s.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case s.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case s.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case s.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case s.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(h.textureFormat)?(0,V.f)(h,h._texture.width,h._texture.height):(h.textureType,s.b.TEXTURETYPE_UNSIGNED_BYTE,h.readPixels())}async exportTextureAsync(h,d){const T=this._exporter._extensionsPreExportTextureAsync("exporter",h,d);return T?await T.then((async T=>T?await this._exportTextureInfoAsync(T,d):await this._exportTextureInfoAsync(h,d))):await this._exportTextureInfoAsync(h,d)}async _exportTextureInfoAsync(h,d){let T=this._textureMap.get(h);if(!T){const Y=await this._getPixelsFromTextureAsync(h);if(!Y)return null;const C=this._exportTextureSampler(h),n=h.mimeType;if(n)switch(n){case"image/jpeg":case"image/png":case"image/webp":d=n;break;default:y.Tools.Warn(`Unsupported media type: ${n}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,F=h.getInternalTexture().uniqueId;X[F]||(X[F]={});let U=X[F][d];if(void 0===U){const T=h.getSize();U=(async()=>{const y=await this._getImageDataAsync(Y,T.width,T.height,d);return this._exportImage(h.name,d,y)})(),X[F][d]=U}T=this._exportTextureInfo(await U,C,h.coordinatesIndex),this._textureMap.set(h,T),this._exporter._extensionsPostExportTextures("exporter",T,h)}return T}_exportImage(h,d,T){const Y=this._exporter._images;let C;if(this._exporter._shouldUseGlb){C={name:h,mimeType:d,bufferView:void 0};const Y=this._exporter._bufferManager.createBufferView(new Uint8Array(T));this._exporter._bufferManager.setBufferView(C,Y)}else{const n=h.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(h){switch(h){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(d);let F=n+X;Y.some((h=>h.uri===F))&&(F=`${n}_${y.Tools.RandomId()}${X}`),C={name:h,uri:F},this._exporter._imageData[F]={data:T,mimeType:d}}return Y.push(C),Y.length-1}_exportTextureInfo(h,d,T){const Y=this._exporter._textures;let y=Y.findIndex((T=>T.sampler==d&&T.source===h));-1===y&&(y=Y.length,Y.push({source:h,sampler:d}));const C={index:y};return T&&(C.texCoord=T),C}_exportTextureSampler(h){const d=this._getTextureSampler(h),T=this._exporter._samplers,Y=T.findIndex((h=>h.minFilter===d.minFilter&&h.magFilter===d.magFilter&&h.wrapS===d.wrapS&&h.wrapT===d.wrapT));return-1!==Y?Y:(T.push(d),T.length-1)}}var q=T(12850),j=T(12596),a=T(13252),e=T(12772);const v=Y.pd.Zero(),G=Y.Quaternion.Identity(),b=Y.pd.One(),B=new Y.pd(-1,1,1);function M(h,d){const{byteOffset:T,byteStride:Y,type:y,normalized:C}=h,n=h.getSize(),X=d.reduce(((h,d)=>d.getTotalVertices()>h?d.getTotalVertices():h),-Number.MAX_VALUE);return{byteOffset:T,byteStride:Y,componentCount:n,type:y,count:X*n,normalized:C,totalVertices:X,kind:h.getKind()}}function mh(h){switch(h){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function R(h){switch(h){case Z.g.PositionKind:case Z.g.NormalKind:case Z.g.TangentKind:case Z.g.ColorKind:case Z.g.MatricesIndicesKind:case Z.g.MatricesIndicesExtraKind:case Z.g.MatricesWeightsKind:case Z.g.MatricesWeightsExtraKind:case Z.g.UVKind:case Z.g.UV2Kind:case Z.g.UV3Kind:case Z.g.UV4Kind:case Z.g.UV5Kind:case Z.g.UV6Kind:return!0}return!1}function Q(h){switch(h){case C.d.TriangleFillMode:return 4;case C.d.TriangleStripDrawMode:return 5;case C.d.TriangleFanDrawMode:return 6;case C.d.PointListDrawMode:case C.d.PointFillMode:return 0;case C.d.LineLoopDrawMode:return 2;case C.d.LineListDrawMode:return 1;case C.d.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${h}`)}function I(h){const d=Math.sqrt(h.x*h.x+h.y*h.y+h.z*h.z);d>0&&(h.x/=d,h.y/=d,h.z/=d)}function A(h){return h.x*=-1,h}function P(h){if(h.x*h.x+h.y*h.y>.5){const d=Math.abs(h.x),T=Math.abs(h.y);if(d>T){const T=Math.sign(h.x);h.x=d,h.y*=-T,h.z*=-T,h.w*=T}else{const d=Math.sign(h.y);h.x*=-d,h.y=T,h.z*=d,h.w*=-d}}else{const d=Math.abs(h.z),T=Math.abs(h.w);if(d>T){const T=Math.sign(h.z);h.x*=-T,h.y*=T,h.z=d,h.w*=-T}else{const d=Math.sign(h.w);h.x*=d,h.y*=-d,h.z*=-d,h.w=T}}return h}function t(h){h.ny(-h.z,h.w,h.x,-h.y)}function hh(h,d){const T=Y.pd.FromArrayToRef(d.translation||[0,0,0],0,Y.TmpVectors.pd[0]),y=Y.Quaternion.FromArrayToRef(d.rotation||[0,0,0,1],0,Y.TmpVectors.Quaternion[0]),C=Y.Matrix.ComposeToRef(b,y,T,Y.TmpVectors.Matrix[0]),n=Y.pd.FromArrayToRef(h.translation||[0,0,0],0,Y.TmpVectors.pd[2]),X=Y.Quaternion.FromArrayToRef(h.rotation||[0,0,0,1],0,Y.TmpVectors.Quaternion[1]),F=Y.Matrix.ComposeToRef(b,X,n,Y.TmpVectors.Matrix[1]);C.multiplyToRef(F,F),F.decompose(void 0,y,T),T.equalsWithEpsilon(v,e.d)?delete d.translation:d.translation=T.ad(),y.equalsWithEpsilon(G,e.d)?delete d.rotation:d.rotation=y.ad(),d.scale&&delete d.scale}function dh(h,d){if(!(d instanceof S.e))return!1;if(!(1===d.getChildren().length&&0===h.getChildren().length&&h.parent===d))return!1;const T=h.Eh(),Y=h instanceof a.d&&!T.useRightHandedSystem?B:b;return!!d.py.equalsWithEpsilon(Y,e.d)||(j.c.Warn(`Cannot collapse node ${h.name} into parent node ${d.name} with modified scaling.`),!1)}function Th(h){if(h instanceof Array){const d=new Float32Array(h);return new Uint8Array(d.buffer,d.byteOffset,d.byteLength)}return ArrayBuffer.isView(h)?new Uint8Array(h.buffer,h.byteOffset,h.byteLength):new Uint8Array(h)}function Yh(h,d){for(const[T,Y]of Object.entries(h)){const y=d[T];(Array.isArray(Y)&&Array.isArray(y)&&yh(Y,y)||Y===y)&&delete h[T]}return h}function yh(h,d){return h.length===d.length&&h.every(((h,T)=>h===d[T]))}const Ch=Y.Matrix.Compose(new Y.pd(-1,1,1),Y.Quaternion.Identity(),Y.pd.Zero());function nh(h,d){if(!(h instanceof S.e))return!1;if(d){if(!h.getWorldMatrix().equalsWithEpsilon(Y.Matrix.IdentityReadOnly,e.d))return!1}else{if(!h.getWorldMatrix().multiplyToRef(Ch,Y.TmpVectors.Matrix[0]).equalsWithEpsilon(Y.Matrix.IdentityReadOnly,e.d))return!1}return!(h instanceof r.b&&h.Rd)}const Xh=new Map([[Int8Array,(h,d,T)=>h.setInt8(d,T)],[Uint8Array,(h,d,T)=>h.setUint8(d,T)],[Uint8ClampedArray,(h,d,T)=>h.setUint8(d,T)],[Int16Array,(h,d,T)=>h.setInt16(d,T,!0)],[Uint16Array,(h,d,T)=>h.setUint16(d,T,!0)],[Int32Array,(h,d,T)=>h.setInt32(d,T,!0)],[Uint32Array,(h,d,T)=>h.setUint32(d,T,!0)],[Float32Array,(h,d,T)=>h.setFloat32(d,T,!0)],[Float64Array,(h,d,T)=>h.setFloat64(d,T,!0)]]);class Fh{writeTypedArray(h){this._checkGrowBuffer(h.byteLength);const d=Xh.get(h.constructor);for(let T=0;T<h.length;T++)d(this._dataView,this._byteOffset,h[T]),this._byteOffset+=h.BYTES_PER_ELEMENT}constructor(h){this._data=new Uint8Array(h),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(h){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,h),this._byteOffset++}writeInt8(h){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,h),this._byteOffset++}writeInt16(h){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,h,!0),this._byteOffset+=2}writeUInt16(h){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,h,!0),this._byteOffset+=2}writeInt32(h){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,h,!0),this._byteOffset+=4}writeUInt32(h){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat32(h){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,h,!0),this._byteOffset+=4}writeFloat64(h){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,h,!0),this._byteOffset+=8}_checkGrowBuffer(h){const d=this.byteOffset+h;if(d>this._data.byteLength){const h=new Uint8Array(2*d);h.set(this._data),this._data=h,this._dataView=new DataView(this._data.buffer)}}}function Uh(h){return h%4===0?4:h%2===0?2:1}class Zh{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(h){let d=0;this._bufferViewToData.forEach((h=>{d+=h.byteLength}));const T=new Fh(d),Y=Array.from(this._bufferViewToData.keys()).sort(((h,d)=>Uh(d.byteLength)-Uh(h.byteLength)));for(const y of Y){y.byteOffset=T.byteOffset,h.push(y);const d=h.length-1,Y=this.getPropertiesWithBufferView(y);for(const h of Y)h.bufferView=d;T.writeTypedArray(this._bufferViewToData.get(y)),this._bufferViewToData.delete(y)}return T.getOutputData()}createBufferView(h,d){const T={buffer:0,byteOffset:void 0,byteLength:h.byteLength,byteStride:d};return this._bufferViewToData.set(T,h),T}createAccessor(h,d,T,Y,y,C,n){this._verifyBufferView(h);const X={bufferView:void 0,componentType:T,count:Y,type:d,min:null===C||void 0===C?void 0:C.min,max:null===C||void 0===C?void 0:C.max,normalized:n,byteOffset:y};return this.setBufferView(X,h),this._accessorToBufferView.set(X,h),X}setBufferView(h,d){this._verifyBufferView(d);this.getPropertiesWithBufferView(d).push(h)}removeBufferView(h){const d=this.getPropertiesWithBufferView(h);for(const T of d)void 0!==T.bufferView&&delete T.bufferView;this._bufferViewToData.delete(h),this._bufferViewToProperties.delete(h),this._accessorToBufferView.forEach(((d,T)=>{d===h&&(void 0!==T.byteOffset&&delete T.byteOffset,this._accessorToBufferView.delete(T))}))}getBufferView(h){const d=this._accessorToBufferView.get(h);return this._verifyBufferView(d),d}getPropertiesWithBufferView(h){return this._verifyBufferView(h),this._bufferViewToProperties.set(h,this._bufferViewToProperties.get(h)??[]),this._bufferViewToProperties.get(h)}getData(h){return this._verifyBufferView(h),this._bufferViewToData.get(h)}_verifyBufferView(h){if(void 0===h||!this._bufferViewToData.has(h))throw new Error(`BufferView ${h} not found in BufferManager.`)}}var Sh,rh=T(13222),ch=T(13236),Oh=T(13259),fh=T(13140),Jh=T(13301),Wh=T(13315),Lh=T(13213),Dh=T(13322);!function(h){h[h.INTANGENT=0]="INTANGENT",h[h.OUTTANGENT=1]="OUTTANGENT"}(Sh||(Sh={}));class Vh{static _IsTransformable(h){return h&&(h instanceof S.e||h instanceof rh.e||h instanceof Dh.d)}static _CreateNodeAnimation(h,d,T,Y,C){if(this._IsTransformable(h)){const n=[],X=[],F=d.getKeys(),U=Vh._CalculateMinMaxKeyFrames(F),Z=Vh._DeduceInterpolation(F,T,Y),S=Z.interpolationType,r=Z.shouldBakeAnimation;if(r?Vh._CreateBakedAnimation(h,d,T,U.min,U.max,d.framePerSecond,C,n,X,U,Y):"LINEAR"===S||"STEP"===S?Vh._CreateLinearOrStepAnimation(h,d,T,n,X,Y):"CUBICSPLINE"===S?Vh._CreateCubicSplineAnimation(h,d,T,n,X,Y):Vh._CreateBakedAnimation(h,d,T,U.min,U.max,d.framePerSecond,C,n,X,U,Y),n.length&&X.length){return{inputs:n,outputs:X,samplerInterpolation:S,inputsMin:r?U.min:y.Tools.FloatRound(U.min/d.framePerSecond),inputsMax:r?U.max:y.Tools.FloatRound(U.max/d.framePerSecond)}}}return null}static _DeduceAnimationInfo(h){let d=null,T="VEC3",Y=!1;const C=h.targetProperty.split(".");switch(C[0]){case"py":d="scale";break;case"position":d="translation";break;case"rotation":T="VEC4",d="rotation";break;case"rotationQuaternion":T="VEC4",Y=!0,d="rotation";break;case"influence":T="SCALAR",d="weights";break;default:y.Tools.Error(`Unsupported animatable property ${C[0]}`)}return d?{animationChannelTargetPath:d,dataAccessorType:T,useQuaternion:Y}:(y.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(h,d,T,Y,y,C,n,X,F,U,Z){let S;if(Vh._IsTransformable(h)&&h.animations)for(const r of h.animations){if(Z&&!Z(r))continue;const y=Vh._DeduceAnimationInfo(r);y&&(S={name:r.name,samplers:[],channels:[]},Vh._AddAnimation(`${r.name}`,r.hasRunningRuntimeAnimations?d:S,h,r,y.dataAccessorType,y.animationChannelTargetPath,Y,C,n,X,y.useQuaternion,F,U),S.samplers.length&&S.channels.length&&T.push(S))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(h,d,T,Y,y,C,n,X,F,U,Z){let S;if(h instanceof Lh.d){const y=h.morphTargetManager;if(y)for(let r=0;r<y.numTargets;++r){const c=y.getTarget(r);for(const O of c.animations){if(Z&&!Z(O))continue;const c=new Jh.c(`${O.name}`,"influence",O.framePerSecond,O.dataType,O.loopMode,O.enableBlending),f=[],J=O.getKeys();for(let h=0;h<J.length;++h){const d=J[h];for(let h=0;h<y.numTargets;++h)h==r?f.push(d):f.push({frame:d.frame,value:0})}c.setKeys(f);const W=Vh._DeduceAnimationInfo(c);W&&(S={name:c.name,samplers:[],channels:[]},Vh._AddAnimation(O.name,O.hasRunningRuntimeAnimations?d:S,h,c,W.dataAccessorType,W.animationChannelTargetPath,Y,C,n,X,W.useQuaternion,F,U,y.numTargets),S.samplers.length&&S.channels.length&&T.push(S))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(h,d,T,Y,y,C,n,X,F){let U;if(h.animationGroups){const S=h.animationGroups;for(const r of S){const S=new Map,c=new Map,O=new Set,f=r.to-r.from;U={name:r.name,channels:[],samplers:[]};for(let d=0;d<r.targetedAnimations.length;++d){const f=r.targetedAnimations[d],J=f.target,W=f.animation;if(F&&!F(W))continue;const L=X.has(J);if(this._IsTransformable(J)||1===J.length&&this._IsTransformable(J[0])){const h=Vh._DeduceAnimationInfo(f.animation);if(h){const d=this._IsTransformable(J)?J:this._IsTransformable(J[0])?J[0]:null;d&&Vh._AddAnimation(`${W.name}`,U,d,W,h.dataAccessorType,h.animationChannelTargetPath,T,Y,y,C,h.useQuaternion,n,L)}}else if(J instanceof Wh.d||1===J.length&&J[0]instanceof Wh.d){if(Vh._DeduceAnimationInfo(f.animation)){const d=J instanceof Wh.d?J:J[0];if(d){const T=h.morphTargetManagers.find((h=>{for(let T=0;T<h.numTargets;++T)if(h.getTarget(T)===d)return!0;return!1}));if(T){const Y=h.meshes.find((h=>h.morphTargetManager===T));var Z;if(Y)S.has(Y)||S.set(Y,new Map),null===(Z=S.get(Y))||void 0===Z||Z.set(d,W),O.add(Y),c.set(Y,W)}}}}}O.forEach((h=>{const d=h.morphTargetManager;let X=null;const F=[],Z=c.get(h).getKeys(),O=Z.length;for(let T=0;T<O;++T)for(let Y=0;Y<d.numTargets;++Y){const y=d.getTarget(Y),C=S.get(h);if(C){const d=C.get(y);d?(X||(X=new Jh.c(`${r.name}_${h.name}_MorphWeightAnimation`,"influence",d.framePerSecond,Jh.c.ANIMATIONTYPE_FLOAT,d.loopMode,d.enableBlending)),F.push(d.getKeys()[T])):F.push({frame:r.from+f/O*T,value:y.influence,inTangent:Z[0].inTangent?0:void 0,outTangent:Z[0].outTangent?0:void 0})}}X.setKeys(F);const J=Vh._DeduceAnimationInfo(X);J&&Vh._AddAnimation(`${r.name}_${h.name}_MorphWeightAnimation`,U,h,X,J.dataAccessorType,J.animationChannelTargetPath,T,Y,y,C,J.useQuaternion,n,!1,null===d||void 0===d?void 0:d.numTargets)})),U.channels.length&&U.samplers.length&&d.push(U)}}}static _AddAnimation(h,d,T,y,C,n,X,F,U,Z,S,r,c,O){const f=Vh._CreateNodeAnimation(T,y,n,S,r);let J,W,L,D,V,i;if(f){if(O){let h=0,d=0;const T=[];for(;f.inputs.length>0;)d=f.inputs.shift(),h%O==0&&T.push(d),h++;f.inputs=T}const h=X.get(T),y=new Float32Array(f.inputs);J=F.createBufferView(y),W=F.createAccessor(J,"SCALAR",5126,f.inputs.length,void 0,{min:[f.inputsMin],max:[f.inputsMax]}),Z.push(W),L=Z.length-1;const U=new Y.Quaternion,S=new Y.pd,r=new Y.pd,w=T instanceof rh.e,s=mh(C),E=new Float32Array(f.outputs.length*s);f.outputs.forEach((function(h,d){let T=h;switch(n){case"translation":c&&(Y.pd.FromArrayToRef(h,0,r),A(r),r.toArray(T));break;case"rotation":4===h.length?Y.Quaternion.FromArrayToRef(h,0,U):(T=new Array(4),Y.pd.FromArrayToRef(h,0,S),Y.Quaternion.FromEulerVectorToRef(S,U)),c&&(P(U),w&&t(U)),U.toArray(T)}E.set(T,d*s)})),J=F.createBufferView(E),W=F.createAccessor(J,C,5126,f.outputs.length),Z.push(W),D=Z.length-1,V={interpolation:f.samplerInterpolation,input:L,output:D},d.samplers.push(V),i={sampler:d.samplers.length-1,target:{node:h,path:n}},d.channels.push(i)}}static _CreateBakedAnimation(h,d,T,C,n,X,F,U,Z,S,r){let c;const O=Y.Quaternion.Identity();let f,J=null,W=null,L=null,D=null,V=null,i=null;S.min=y.Tools.FloatRound(C/X);const w=d.getKeys();for(let Y=0,s=w.length;Y<s;++Y){if(i=null,L=w[Y],Y+1<s)if(D=w[Y+1],L.value.equals&&L.value.equals(D.value)||L.value===D.value){if(0!==Y)continue;i=L.frame}else i=D.frame;else{if(V=w[Y-1],L.value.equals&&L.value.equals(V.value)||L.value===V.value)continue;i=n}if(i)for(let Y=L.frame;Y<=i;Y+=F){if(f=y.Tools.FloatRound(Y/X),f===J)continue;J=f,W=f;const C={key:0,repeatCount:0,loopMode:d.loopMode};c=d._interpolate(Y,C),Vh._SetInterpolatedValue(h,c,f,d,T,O,U,Z,r)}}W&&(S.max=W)}static _ConvertFactorToVector3OrQuaternion(h,d,T,C,n){const X=Vh._GetBasePositionRotationOrScale(d,C,n),F=T.targetProperty.split("."),U=F?F[1]:"",Z=n?Y.Quaternion.Bd(X).normalize():Y.pd.Bd(X);switch(U){case"x":case"y":case"z":Z[U]=h;break;case"w":Z.w=h;break;default:y.Tools.Error(`glTFAnimation: Unsupported component name "${U}"!`)}return Z}static _SetInterpolatedValue(h,d,T,y,C,n,X,F,U){let Z;X.push(T),"weights"!==C?(y.dataType===Jh.c.ANIMATIONTYPE_FLOAT&&(d=this._ConvertFactorToVector3OrQuaternion(d,h,y,C,U)),"rotation"===C?(U?n=d:(Z=d,Y.Quaternion.RotationYawPitchRollToRef(Z.y,Z.x,Z.z,n)),F.push(n.ad())):(Z=d,F.push(Z.ad()))):F.push([d])}static _CreateLinearOrStepAnimation(h,d,T,Y,y,C){for(const n of d.getKeys())Y.push(n.frame/d.framePerSecond),Vh._AddKeyframeValue(n,d,y,T,h,C)}static _CreateCubicSplineAnimation(h,d,T,Y,y,C){d.getKeys().forEach((function(n){Y.push(n.frame/d.framePerSecond),Vh._AddSplineTangent(Sh.INTANGENT,y,T,"CUBICSPLINE",n,C),Vh._AddKeyframeValue(n,d,y,T,h,C),Vh._AddSplineTangent(Sh.OUTTANGENT,y,T,"CUBICSPLINE",n,C)}))}static _GetBasePositionRotationOrScale(h,d,T){let y;if("rotation"===d)if(T){y=(h.rotationQuaternion??Y.Quaternion.Identity()).ad()}else{y=(h.rotation??Y.pd.Zero()).ad()}else if("translation"===d){y=(h.position??Y.pd.Zero()).ad()}else{y=(h.py??Y.pd.One()).ad()}return y}static _AddKeyframeValue(h,d,T,C,n,X){let F;const U=d.dataType;if(U===Jh.c.ANIMATIONTYPE_VECTOR3){let d=h.value.ad();if("rotation"===C){const h=Y.pd.Bd(d);d=Y.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).ad()}T.push(d)}else if(U===Jh.c.ANIMATIONTYPE_FLOAT){if("weights"===C)T.push([h.value]);else if(F=this._ConvertFactorToVector3OrQuaternion(h.value,n,d,C,X),F){if("rotation"===C){const h=X?F:Y.Quaternion.RotationYawPitchRoll(F.y,F.x,F.z).normalize();T.push(h.ad())}T.push(F.ad())}}else U===Jh.c.ANIMATIONTYPE_QUATERNION?T.push(h.value.normalize().ad()):y.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(h,d,T){let Y,y,C=!1;if("rotation"===d&&!T)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let n=0,X=h.length;n<X;++n)if(y=h[n],y.inTangent||y.outTangent)if(Y){if("CUBICSPLINE"!==Y){Y="LINEAR",C=!0;break}}else Y="CUBICSPLINE";else if(Y){if("CUBICSPLINE"===Y||y.interpolation&&1===y.interpolation&&"STEP"!==Y){Y="LINEAR",C=!0;break}}else Y=y.interpolation&&1===y.interpolation?"STEP":"LINEAR";return Y||(Y="LINEAR"),{interpolationType:Y,shouldBakeAnimation:C}}static _AddSplineTangent(h,d,T,y,C,n){let X;const F=h===Sh.INTANGENT?C.inTangent:C.outTangent;if("CUBICSPLINE"===y){if("rotation"===T)if(F)if(n)X=F.ad();else{const h=F;X=Y.Quaternion.RotationYawPitchRoll(h.y,h.x,h.z).ad()}else X=[0,0,0,0];else X="weights"===T?F?[F]:[0]:F?F.ad():[0,0,0];d.push(X)}}static _CalculateMinMaxKeyFrames(h){let d=1/0,T=-1/0;return h.forEach((function(h){d=Math.min(d,h.frame),T=Math.max(T,h.frame)})),{min:d,max:T}}}function ih(h,d,T,C,n,X){const F={attributes:{},influence:h.influence,name:h.name},U=d.Rd;if(!U)return y.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),F;const S=X?-1:1,r=Y.pd.Zero();let c=0,O=0;if(h.hasPositions){const C=h.getPositions(),X=U.getVerticesData(Z.g.PositionKind);if(X){const h=new Float32Array(X.length),d=[1/0,1/0,1/0],y=[-1/0,-1/0,-1/0];O=X.length/3,c=0;for(let T=c;T<O;++T){const n=Y.pd.Bd(X,3*T);Y.pd.Bd(C,3*T).subtractToRef(n,r),r.x*=S,d[0]=Math.min(d[0],r.x),y[0]=Math.max(y[0],r.x),d[1]=Math.min(d[1],r.y),y[1]=Math.max(y[1],r.y),d[2]=Math.min(d[2],r.z),y[2]=Math.max(y[2],r.z),h[3*T]=r.x,h[3*T+1]=r.y,h[3*T+2]=r.z}const U=T.createBufferView(h,12),Z=T.createAccessor(U,"VEC3",5126,C.length/3,0,{min:d,max:y});n.push(Z),F.attributes.POSITION=n.length-1}else y.Tools.Warn(`Morph target positions for mesh ${d.name} were not exported. Mesh does not have position vertex data`)}if(h.hasNormals){const C=h.getNormals(),X=U.getVerticesData(Z.g.NormalKind);if(X){const h=new Float32Array(X.length);O=X.length/3,c=0;for(let T=c;T<O;++T){const d=Y.pd.Bd(X,3*T).normalize();Y.pd.Bd(C,3*T).normalize().subtractToRef(d,r),h[3*T]=r.x*S,h[3*T+1]=r.y,h[3*T+2]=r.z}const d=T.createBufferView(h,12),y=T.createAccessor(d,"VEC3",5126,C.length/3,0);n.push(y),F.attributes.NORMAL=n.length-1}else y.Tools.Warn(`Morph target normals for mesh ${d.name} were not exported. Mesh does not have normals vertex data`)}if(h.hasTangents){const C=h.getTangents(),X=U.getVerticesData(Z.g.TangentKind);if(X){O=X.length/4;const h=new Float32Array(3*O);c=0;for(let T=c;T<O;++T){const d=Y.pd.Bd(X,4*T);I(d);const y=Y.pd.Bd(C,3*T);I(y),y.subtractToRef(d,r),h[3*T]=r.x*S,h[3*T+1]=r.y,h[3*T+2]=r.z}const d=T.createBufferView(h,12),y=T.createAccessor(d,"VEC3",5126,O,0);n.push(y),F.attributes.TANGENT=n.length-1}else y.Tools.Warn(`Morph target tangents for mesh ${d.name} were not exported. Mesh does not have tangents vertex data`)}if(h.hasColors){const C=h.getColors(),X=U.getVerticesData(Z.g.ColorKind),S=U.getVertexBuffer(Z.g.ColorKind);if(X&&S){const h=S.getSize();O=X.length/h;const d=new Float32Array(O*h);c=0;for(let T=c;T<O;++T)if(3===h){const y=Y.pd.Bd(X,T*h);Y.pd.Bd(C,T*h).subtractToRef(y,r),d[3*T]=r.x,d[3*T+1]=r.y,d[3*T+2]=r.z}else if(4===h){const y=new Y.Vector4,n=Y.Vector4.Bd(X,T*h);Y.Vector4.Bd(C,T*h).subtractToRef(n,y),d[4*T]=y.x,d[4*T+1]=y.y,d[4*T+2]=y.z,d[4*T+3]=y.w}else y.Tools.Warn(`Unsupported number of components for color attribute: ${h}`);const U=T.createBufferView(d,4*h),Z=T.createAccessor(U,3===h?"VEC3":"VEC4",5126,O,0);n.push(Z),F.attributes.COLOR_0=n.length-1}else y.Tools.Warn(`Morph target colors for mesh ${d.name} were not exported. Mesh does not have colors vertex data`)}return F}var wh=T(13328),sh=T(13175),Eh=T(13155),zh=T(12714);class xh{}xh.DEFAULT_COLOR=J.ed.White(),xh.DEFAULT_WIDTH_ATTENUATED=1,xh.DEFAULT_WIDTH=.1;var gh=T(12963),Hh=T(13334);class ph{static ConvertPoints(h,d){if(h.length&&Array.isArray(h)&&"number"===typeof h[0])return[h];if(h.length&&Array.isArray(h[0])&&"number"===typeof h[0][0])return h;if(h.length&&!Array.isArray(h[0])&&h[0]instanceof Y.pd){const d=[];for(let T=0;T<h.length;T++){const Y=h[T];d.push(Y.x,Y.y,Y.z)}return[d]}if(h.length>0&&Array.isArray(h[0])&&h[0].length>0&&h[0][0]instanceof Y.pd){const d=[],T=h;for(const h of T)d.push(h.flatMap((h=>[h.x,h.y,h.z])));return d}if(h instanceof Float32Array){if(null!==d&&void 0!==d&&d.floatArrayStride){const T=[],Y=3*d.floatArrayStride;for(let d=0;d<h.length;d+=Y){const y=new Array(Y);for(let T=0;T<Y;T++)y[T]=h[d+T];T.push(y)}return T}return[Array.from(h)]}if(h.length&&h[0]instanceof Float32Array){const d=[];for(const T of h)d.push(Array.from(T));return d}return[]}static OmitZeroLengthPredicate(h,d,T){const Y=[];return d.Nd(h).lengthSquared()>0&&Y.push([h,d]),T.Nd(d).lengthSquared()>0&&Y.push([d,T]),h.Nd(T).lengthSquared()>0&&Y.push([T,h]),0===Y.length?null:Y}static OmitDuplicatesPredicate(h,d,T,Y){const y=[];return ph._SearchInPoints(h,d,Y)||y.push([h,d]),ph._SearchInPoints(d,T,Y)||y.push([d,T]),ph._SearchInPoints(T,h,Y)||y.push([T,h]),0===y.length?null:y}static _SearchInPoints(h,d,T){for(const n of T)for(let T=0;T<n.length;T++){var Y,y,C;if(null!==(Y=n[T])&&void 0!==Y&&Y.equals(h))if(null!==(y=n[T+1])&&void 0!==y&&y.equals(d)||null!==(C=n[T-1])&&void 0!==C&&C.equals(d))return!0}return!1}static MeshesToLines(h,d){const T=[];for(let y=0;y<h.length;y++){const C=h[y],n=C.getVerticesData(Z.g.PositionKind),X=C.Pd();if(n&&X)for(let h=0,F=0;h<X.length;h++){const U=3*X[F++],Z=3*X[F++],S=3*X[F++],r=new Y.pd(n[U],n[U+1],n[U+2]),c=new Y.pd(n[Z],n[Z+1],n[Z+2]),O=new Y.pd(n[S],n[S+1],n[S+2]);if(d){const Y=d(r,c,O,T,h,U,C,y,n,X);if(Y)for(const h of Y)T.push(h)}else T.push([r,c],[c,O],[O,r])}}return T}static ToVector3Array(h){if(Array.isArray(h[0])){const d=[],T=h;for(const h of T){const T=[];for(let d=0;d<h.length;d+=3)T.push(new Y.pd(h[d],h[d+1],h[d+2]));d.push(T)}return d}const d=h,T=[];for(let y=0;y<d.length;y+=3)T.push(new Y.pd(d[y],d[y+1],d[y+2]));return T}static ToNumberArray(h){return h.flatMap((h=>[h.x,h.y,h.z]))}static GetPointsCountInfo(h){const d=new Array(h.length);let T=0;for(let Y=h.length;Y--;)d[Y]=h[Y].length/3,T+=d[Y];return{total:T,counts:d}}static GetLineLength(h){if(0===h.length)return 0;let d;d="number"===typeof h[0]?ph.ToVector3Array(h):h;const T=Y.TmpVectors.pd[0];let y=0;for(let Y=0;Y<d.length-1;Y++){const h=d[Y];y+=d[Y+1].subtractToRef(h,T).length()}return y}static GetLineLengthArray(h){const d=new Float32Array(h.length/3);let T=0;for(let Y=0,y=h.length/3-1;Y<y;Y++){let y=h[3*Y+0],C=h[3*Y+1],n=h[3*Y+2];y-=h[3*Y+3],C-=h[3*Y+4],n-=h[3*Y+5];T+=Math.sqrt(y*y+C*C+n*n),d[Y+1]=T}return d}static SegmentizeSegmentByCount(h,d,T){const y=[],C=d.Nd(h),n=Y.TmpVectors.pd[0];n.XC(T);const X=Y.TmpVectors.pd[1];C.divideToRef(n,X);let F=h.clone();y.push(F);for(let Y=0;Y<T;Y++)F=F.clone(),y.push(F.addInPlace(X));return y}static SegmentizeLineBySegmentLength(h,d){const T=h[0]instanceof Y.pd?ph.GetLineSegments(h):"number"===typeof h[0]?ph.GetLineSegments(ph.ToVector3Array(h)):h,y=[];for(const Y of T)if(Y.length>d){const h=ph.SegmentizeSegmentByCount(Y.point1,Y.point2,Math.ceil(Y.length/d));for(const d of h)y.push(d)}else y.push(Y.point1),y.push(Y.point2);return y}static SegmentizeLineBySegmentCount(h,d){const T="number"===typeof h[0]?ph.ToVector3Array(h):h,Y=ph.GetLineLength(T)/d;return ph.SegmentizeLineBySegmentLength(T,Y)}static GetLineSegments(h){const d=[];for(let T=0;T<h.length-1;T++){const Y=h[T],y=h[T+1],C=y.Nd(Y).length();d.push({point1:Y,point2:y,length:C})}return d}static GetMinMaxSegmentLength(h){const d=ph.GetLineSegments(h).sort((h=>h.length));return{min:d[0].length,max:d[d.length-1].length}}static GetPositionOnLineByVisibility(h,d,T){let y=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const C=d*T;let n=0,X=0;const F=h.length;for(let Y=0;Y<F;Y++){if(C<=n+h[Y].length){X=Y;break}n+=h[Y].length}const U=(C-n)/h[X].length;return h[X].point2.subtractToRef(h[X].point1,Y.TmpVectors.pd[0]),Y.TmpVectors.pd[1]=Y.TmpVectors.pd[0].multiplyByFloats(U,U,U),y||Y.TmpVectors.pd[1].addInPlace(h[X].point1),Y.TmpVectors.pd[1].clone()}static GetCircleLinePoints(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,y=arguments.length>3&&void 0!==arguments[3]?arguments[3]:h,C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/d;const n=[];for(let X=0;X<=d;X++)n.push(new Y.pd(Math.cos(X*C)*h,Math.sin(X*C)*y,T));return n}static GetBezierLinePoints(h,d,T,Y){return gh.g.CreateQuadraticBezier(h,d,T,Y).getPoints().flatMap((h=>[h.x,h.y,h.z]))}static GetArrowCap(h,d,T,Y,y){let C=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,n=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[h.clone(),h.add(d.multiplyByFloats(T,T,T))],widths:[Y,y,C,n]}}static GetPointsFromText(h,d,T,Y){let y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,C=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const n=[],X=(0,Hh.c)(h,d,T,Y);for(const F of X){for(const h of F.paths){const d=[],T=h.getPoints();for(const h of T)d.push(h.x,h.y,y);n.push(d)}if(C)for(const h of F.holes){const d=[],T=h.getPoints();for(const h of T)d.push(h.x,h.y,y);n.push(d)}}return n}static Color3toRGBAUint8(h){const d=new Uint8Array(4*h.length);for(let T=0,Y=0;T<h.length;T++)d[Y++]=255*h[T].r,d[Y++]=255*h[T].g,d[Y++]=255*h[T].b,d[Y++]=255;return d}static CreateColorsTexture(h,d,T,Y){const y=Y.getEngine().getCaps().maxTextureSize??1,C=d.length>y?y:d.length,n=Math.ceil(d.length/y);n>1&&(d=[...d,...Array(C*n-d.length).fill(d[0])]);const X=ph.Color3toRGBAUint8(d),F=new w.b(X,C,n,O.b.TEXTUREFORMAT_RGBA,Y,!1,!0,T);return F.name=h,F}static PrepareEmptyColorsTexture(h){if(!xh.EmptyColorsTexture){const d=new Uint8Array(4);xh.EmptyColorsTexture=new w.b(d,1,1,O.b.TEXTUREFORMAT_RGBA,h,!1,!1,w.b.NEAREST_NEAREST),xh.EmptyColorsTexture.name="grlEmptyColorsTexture"}return xh.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var h;null===(h=xh.EmptyColorsTexture)||void 0===h||h.dispose(),xh.EmptyColorsTexture=null}static BooleanToNumber(h){return h?1:0}}class kh extends Eh.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class oh extends sh.e{isCompatible(h){return!0}constructor(h,d,T){var y;T=T||{color:xh.DEFAULT_COLOR};const C=new kh;C.GREASED_LINE_HAS_COLOR=!!T.color&&!T.useColors,C.GREASED_LINE_SIZE_ATTENUATION=T.sizeAttenuation??!1,C.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===T.colorDistributionType,C.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(d??h.Eh()).useRightHandedSystem,C.GREASED_LINE_CAMERA_FACING=T.cameraFacing??!0,super(h,oh.GREASED_LINE_MATERIAL_NAME,200,C,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(y=T)||void 0===y?void 0:y.forceGLSL)||oh.ForceGLSL,this._scene=d??h.Eh(),this._engine=this._scene.getEngine(),this._cameraFacing=T.cameraFacing??!0,this.visibility=T.visibility??1,this.useDash=T.useDash??!1,this.dashRatio=T.dashRatio??.5,this.dashOffset=T.dashOffset??0,this.width=T.width?T.width:T.sizeAttenuation?xh.DEFAULT_WIDTH_ATTENUATED:xh.DEFAULT_WIDTH,this._sizeAttenuation=T.sizeAttenuation??!1,this.colorMode=T.colorMode??0,this._color=T.color??null,this.useColors=T.useColors??!1,this._colorsDistributionType=T.colorDistributionType??0,this.colorsSampling=T.colorsSampling??w.b.NEAREST_NEAREST,this._colors=T.Hh??null,this.dashCount=T.dashCount??1,this.resolution=T.resolution??new Y.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),T.colorsTexture?this.colorsTexture=T.colorsTexture:this._colors?this.colorsTexture=ph.CreateColorsTexture(`${h.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??xh.DEFAULT_COLOR,ph.PrepareEmptyColorsTexture(this._scene)),this._engine.zd.add((()=>{ph.DisposeEmptyColorsTexture()}))}getAttributes(h){h.push("grl_offsets"),h.push("grl_widths"),h.push("grl_colorPointers"),h.push("grl_counters"),this._cameraFacing?(h.push("grl_previousAndSide"),h.push("grl_nextAndCounters")):h.push("grl_slopes")}getSamplers(h){h.push("grl_colors")}getActiveTextures(h){this.colorsTexture&&h.push(this.colorsTexture)}getUniforms(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const d=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&d.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===h&&d.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:d,vertex:this._cameraFacing&&this._isGLSL(h)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(h)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(h){if(this._cameraFacing){h.bd("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||h.bd("viewProjection",this._scene.getTransformMatrix());const d=Y.TmpVectors.Vector4[0];d.x=this._aspect,d.y=this._resolution.x,d.z=this._resolution.y,d.w=this.width,h.updateVector4("grl_aspect_resolution_lineWidth",d)}const d=Y.TmpVectors.Vector4[0];d.x=ph.BooleanToNumber(this.useDash),d.y=this._dashArray,d.z=this.dashOffset,d.w=this.dashRatio,h.updateVector4("grl_dashOptions",d);const T=Y.TmpVectors.Vector4[1];T.x=this.colorMode,T.y=this.visibility,T.z=this.colorsTexture?this.colorsTexture.getSize().width:0,T.w=ph.BooleanToNumber(this.useColors),h.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",T),this._color&&h.updateColor3("grl_singleColor",this._color);const y=this.colorsTexture??xh.EmptyColorsTexture;h.setTexture("grl_colors",y),h.updateFloat2("grl_textureSize",(null===y||void 0===y?void 0:y.getSize().width)??1,(null===y||void 0===y?void 0:y.getSize().height)??1)}prepareDefines(h,d,T){h.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,h.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,h.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,h.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=d.useRightHandedSystem,h.GREASED_LINE_CAMERA_FACING=this._cameraFacing,h.GREASED_LINE_USE_OFFSETS=!!T.offsets}getClassName(){return oh.GREASED_LINE_MATERIAL_NAME}getCustomCode(h){let d=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(d)?function(h,d){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return d&&(h["!gl_Position\\=viewProjection\\*worldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(h,this._cameraFacing):function(h,d){if("vertex"===h){const h={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return d&&(h["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),h}return"fragment"===h?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(h,this._cameraFacing)}dispose(){var h;null===(h=this.colorsTexture)||void 0===h||h.dispose(),super.dispose()}get Hh(){return this._colors}set Hh(h){this.setColors(h)}setColors(h){var d;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const y=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var C;if(this._colors=h,null!==h&&0!==h.length){if(!T||Y)if(this.colorsTexture&&y===h.length&&!Y){const d=ph.Color3toRGBAUint8(h);this.colorsTexture.update(d)}else{var n;null===(n=this.colorsTexture)||void 0===n||n.dispose(),this.colorsTexture=ph.CreateColorsTexture(`${this._material.name}-colors-texture`,h,this.colorsSampling,this._scene)}}else null===(C=this.colorsTexture)||void 0===C||C.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.markAllDefinesAsDirty()}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==h||null!==this._color&&null===h?(this._color=h,d||this.markAllDefinesAsDirty()):this._color=h}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(h){this._aspect=h.x/h.y,this._resolution=h}serialize(){const h=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(d.Hh=this._colors),this._color&&(d.color=this._color),h.greasedLineMaterialOptions=d,h}parse(h,d,T){var Y;super.parse(h,d,T);const y=h.greasedLineMaterialOptions;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),y.color&&this.setColor(y.color,!0),y.colorDistributionType&&(this.colorsDistributionType=y.colorDistributionType),y.Hh&&(this.Hh=y.Hh),y.colorsSampling&&(this.colorsSampling=y.colorsSampling),y.colorMode&&(this.colorMode=y.colorMode),y.useColors&&(this.useColors=y.useColors),y.visibility&&(this.visibility=y.visibility),y.useDash&&(this.useDash=y.useDash),y.dashCount&&(this.dashCount=y.dashCount),y.dashRatio&&(this.dashRatio=y.dashRatio),y.dashOffset&&(this.dashOffset=y.dashOffset),y.width&&(this.width=y.width),y.sizeAttenuation&&(this.sizeAttenuation=y.sizeAttenuation),y.resolution&&(this.resolution=y.resolution),this.Hh?this.colorsTexture=ph.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Hh,this.colorsSampling,d):ph.PrepareEmptyColorsTexture(d),this.markAllDefinesAsDirty()}copyTo(h){var d;const T=h;null===(d=T.colorsTexture)||void 0===d||d.dispose(),this._colors&&(T.colorsTexture=ph.CreateColorsTexture(`${T._material.name}-colors-texture`,this._colors,T.colorsSampling,this._scene)),T.setColor(this.color,!0),T.colorsDistributionType=this.colorsDistributionType,T.colorsSampling=this.colorsSampling,T.colorMode=this.colorMode,T.useColors=this.useColors,T.visibility=this.visibility,T.useDash=this.useDash,T.dashCount=this.dashCount,T.dashRatio=this.dashRatio,T.dashOffset=this.dashOffset,T.width=this.width,T.sizeAttenuation=this.sizeAttenuation,T.resolution=this.resolution,T.markAllDefinesAsDirty()}_isGLSL(h){return 0===h||this._forceGLSL}}oh.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",oh.ForceGLSL=!1,(0,zh.e)(`BABYLON.${oh.GREASED_LINE_MATERIAL_NAME}`,oh);var uh=T(13200),Nh=T(12604),Kh=T(12982),lh=T(12692);class qh extends Kh.ShaderMaterial{constructor(h,d,y){const C=d.getEngine(),n=C.isWebGPU&&!(y.forceGLSL||qh.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];d.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const F=["position","grl_widths","grl_offsets","grl_colorPointers"];y.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),F.push("grl_previousAndSide","grl_nextAndCounters")):(F.push("grl_slopes"),F.push("grl_counters"));const U=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(n||U.push("world","viewProjection","view","projection"),super(h,d,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:n?["Scene","Mesh"]:void 0,attributes:F,uniforms:U,samplers:n?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{n?await Promise.all([T.e(66).then(T.bind(T,15978)),T.e(75).then(T.bind(T,15980))]):await Promise.all([T.e(69).then(T.bind(T,15986)),T.e(76).then(T.bind(T,15994))])},shaderLanguage:n?1:0}),this._color=J.ed.White(),this._colorsDistributionType=0,this._colorsTexture=null,y=y||{color:xh.DEFAULT_COLOR},this.visibility=y.visibility??1,this.useDash=y.useDash??!1,this.dashRatio=y.dashRatio??.5,this.dashOffset=y.dashOffset??0,this.dashCount=y.dashCount??1,this.width=y.width?y.width:y.sizeAttenuation&&y.cameraFacing?xh.DEFAULT_WIDTH_ATTENUATED:xh.DEFAULT_WIDTH,this.sizeAttenuation=y.sizeAttenuation??!1,this.color=y.color??J.ed.White(),this.useColors=y.useColors??!1,this.colorsDistributionType=y.colorDistributionType??0,this.colorsSampling=y.colorsSampling??w.b.NEAREST_NEAREST,this.colorMode=y.colorMode??0,this._colors=y.Hh??null,this._cameraFacing=y.cameraFacing??!0,this.resolution=y.resolution??new Y.Vector2(C.getRenderWidth(),C.getRenderHeight()),y.colorsTexture?this.colorsTexture=y.colorsTexture:this._colors?this.colorsTexture=ph.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,d):(this._color=this._color??xh.DEFAULT_COLOR,this.colorsTexture=ph.PrepareEmptyColorsTexture(d)),n){const h=new lh.b;h.setParameters(),h.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",h)}C.zd.add((()=>{ph.DisposeEmptyColorsTexture()}))}dispose(){var h;null===(h=this._colorsTexture)||void 0===h||h.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new Y.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Hh(){return this._colors}set Hh(h){this.setColors(h)}setColors(h){var d;let T=arguments.length>1&&void 0!==arguments[1]&&arguments[1],Y=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const y=(null===(d=this._colors)||void 0===d?void 0:d.length)??0;var C;if(this._colors=h,null!==h&&0!==h.length){if(!T||Y)if(this._colorsTexture&&y===h.length&&!Y){const d=ph.Color3toRGBAUint8(h);this._colorsTexture.update(d)}else{var n;null===(n=this._colorsTexture)||void 0===n||n.dispose(),this.colorsTexture=ph.CreateColorsTexture(`${this.name}-colors-texture`,h,this.colorsSampling,this.Eh())}}else null===(C=this._colorsTexture)||void 0===C||C.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(h){this._colorsTexture=h,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(h){this._width=h,this.setFloat("grlWidth",h)}get useColors(){return this._useColors}set useColors(h){this._useColors=h,this.setFloat("grlUseColors",ph.BooleanToNumber(h))}get colorsSampling(){return this._colorsSampling}set colorsSampling(h){this._colorsSampling=h}get visibility(){return this._visibility}set visibility(h){this._visibility=h,this.setFloat("grlVisibility",h)}get useDash(){return this._useDash}set useDash(h){this._useDash=h,this.setFloat("grlUseDash",ph.BooleanToNumber(h))}get dashOffset(){return this._dashOffset}set dashOffset(h){this._dashOffset=h,this.setFloat("grlDashOffset",h)}get dashRatio(){return this._dashRatio}set dashRatio(h){this._dashRatio=h,this.setFloat("grlDashRatio",h)}get dashCount(){return this._dashCount}set dashCount(h){this._dashCount=h,this._dashArray=1/h,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(h){this._sizeAttenuation=h,this.setFloat("grlSizeAttenuation",ph.BooleanToNumber(h))}get color(){return this._color}set color(h){this.setColor(h)}setColor(h){h=h??xh.DEFAULT_COLOR,this._color=h,this.setColor3("grlColor",h)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(h){this._colorsDistributionType=h,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(h){this._colorMode=h,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(h){this._resolution=h,this.setVector2("grlResolution",h),this.setFloat("grlAspect",h.x/h.y)}serialize(){const h=super.serialize(),d={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(d.Hh=this._colors),h.greasedLineMaterialOptions=d,h}parse(h,d,T){var Y;const y=h.greasedLineMaterialOptions;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),y.color&&(this.color=y.color),y.colorDistributionType&&(this.colorsDistributionType=y.colorDistributionType),y.colorsSampling&&(this.colorsSampling=y.colorsSampling),y.colorMode&&(this.colorMode=y.colorMode),y.useColors&&(this.useColors=y.useColors),y.visibility&&(this.visibility=y.visibility),y.useDash&&(this.useDash=y.useDash),y.dashCount&&(this.dashCount=y.dashCount),y.dashRatio&&(this.dashRatio=y.dashRatio),y.dashOffset&&(this.dashOffset=y.dashOffset),y.width&&(this.width=y.width),y.sizeAttenuation&&(this.sizeAttenuation=y.sizeAttenuation),y.resolution&&(this.resolution=y.resolution),y.Hh?this.colorsTexture=ph.CreateColorsTexture(`${this.name}-colors-texture`,y.Hh,this.colorsSampling,this.Eh()):this.colorsTexture=ph.PrepareEmptyColorsTexture(d),this._cameraFacing=y.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var jh,ah,eh;qh.ForceGLSL=!1,function(h){h[h.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",h[h.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(jh||(jh={})),function(h){h[h.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",h[h.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",h[h.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ah||(ah={})),function(h){h[h.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",h[h.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",h[h.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",h[h.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",h[h.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(eh||(eh={}));class vh extends Lh.d{constructor(h,d,T){super(h,d,null,null,!1,!1),this.name=h,this._options=T,this._lazy=!1,this._updatable=!1,this._engine=d.getEngine(),this._lazy=T.lazy??!1,this._updatable=T.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=T.colorPointers??[],this._widths=T.widths??new Array(T.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(h){let d=0;for(const Y of this._points)d+=Y.length;const T=d/3*2-this._widths.length;for(let Y=0;Y<T;Y++)this._widths.push(h)}updateLazy(){var h,d;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(h=this._options.ribbonOptions)||void 0===h?void 0:h.smoothShading),!this.uh&&this.refreshBoundingInfo(),null===(d=this.greasedLineMaterial)||void 0===d||d.updateLazy()}addPoints(h,d){for(const T of h)this._points.push(T);this._lazy||this.setPoints(this._points,d)}dispose(h){let d=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(h,d)}isLazy(){return this._lazy}get ph(){return this._uvs}set ph(h){this._uvs=h instanceof Float32Array?h:new Float32Array(h),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(h){this.material instanceof qh&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===h||void 0===h?void 0:h.length)>0),this._offsets=h,this._offsetsBuffer?this._offsetsBuffer.update(h):this._createOffsetsBuffer(h)}get widths(){return this._widths}set widths(h){this._widths=h,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(h)}get colorPointers(){return this._colorPointers}set colorPointers(h){this._colorPointers=h,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(h)}get greasedLineMaterial(){var h,d;if(this.material&&this.material instanceof qh)return this.material;const T=null===(h=this.material)||void 0===h||null===(d=h.pluginManager)||void 0===d?void 0:d.getPlugin(oh.GREASED_LINE_MATERIAL_NAME);return T||void 0}get points(){const h=[];return Nh.d.DeepCopy(this._points,h),h}setPoints(h,d){this._points=ph.ConvertPoints(h,(null===d||void 0===d?void 0:d.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==d&&void 0!==d&&d.colorPointers||this._updateColorPointers(),this._setPoints(this._points,d)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ph:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(h){super.serialize(h),h.type=this.getClassName(),h.lineOptions=this._createLineOptions()}_createVertexBuffers(){let h=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const d=new uh.c;return d.xh=this._vertexPositions,d.indices=this._indices,d.ph=this._uvs,h&&(d.gh=[],uh.c.ComputeNormals(this._vertexPositions,this._indices,d.gh)),d.oh(this,this._options.updatable),d}_createOffsetsBuffer(h){const d=this._scene.getEngine(),T=new Z.e(d,h,this._updatable,3);this.setVerticesBuffer(T.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=T}}class Gh{constructor(h,d){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=h,this.wasAddedByNoopNode=d}getIndicesAccessor(h,d,T,Y,y){var C,n,X,F;return null===(C=this._indicesAccessorMap.get(h))||void 0===C||null===(n=C.get(d))||void 0===n||null===(X=n.get(T))||void 0===X||null===(F=X.get(Y))||void 0===F?void 0:F.get(y)}setIndicesAccessor(h,d,T,Y,y,C){let n=this._indicesAccessorMap.get(h);n||(n=new Map,this._indicesAccessorMap.set(h,n));let X=n.get(d);X||(X=new Map,n.set(d,X));let F=X.get(T);F||(F=new Map,X.set(T,F));let U=F.get(Y);U||(U=new Map,F.set(Y,U)),U.set(y,C)}pushExportedNode(h){this._exportedNodes.has(h)||this._exportedNodes.add(h)}getNodesSet(){return this._exportedNodes}getVertexBufferView(h){return this._vertexBufferViewMap.get(h)}setVertexBufferView(h,d){this._vertexBufferViewMap.set(h,d)}setRemappedBufferView(h,d,T){this._remappedBufferView.set(h,new Map),this._remappedBufferView.get(h).set(d,T)}getRemappedBufferView(h,d){var T;return null===(T=this._remappedBufferView.get(h))||void 0===T?void 0:T.get(d)}getVertexAccessor(h,d,T){var Y,y;return null===(Y=this._vertexAccessorMap.get(h))||void 0===Y||null===(y=Y.get(d))||void 0===y?void 0:y.get(T)}setVertexAccessor(h,d,T,Y){let y=this._vertexAccessorMap.get(h);y||(y=new Map,this._vertexAccessorMap.set(h,y));let C=y.get(d);C||(C=new Map,y.set(d,C)),C.set(T,Y)}hasVertexColorAlpha(h){return this._vertexMapColorAlpha.get(h)||!1}setHasVertexColorAlpha(h,d){return this._vertexMapColorAlpha.set(h,d)}getMesh(h){return this._meshMap.get(h)}setMesh(h,d){this._meshMap.set(h,d)}bindMorphDataToMesh(h,d){const T=this._meshMorphTargetMap.get(h)||[];this._meshMorphTargetMap.set(h,T),-1===T.indexOf(d)&&T.push(d)}getMorphTargetsFromMesh(h){return this._meshMorphTargetMap.get(h)}}class bh{_ApplyExtension(h,d,T,Y){if(T>=d.length)return Promise.resolve(h);const y=Y(d[T],h);return y?y.then((async h=>h?await this._ApplyExtension(h,d,T+1,Y):null)):this._ApplyExtension(h,d,T+1,Y)}_ApplyExtensions(h,d){const T=[];for(const Y of bh._ExtensionNames)T.push(this._extensions[Y]);return this._ApplyExtension(h,T,0,d)}_extensionsPreExportTextureAsync(h,d,T){return this._ApplyExtensions(d,((d,Y)=>d.preExportTextureAsync&&d.preExportTextureAsync(h,Y,T)))}_extensionsPostExportNodeAsync(h,d,T,Y,y){return this._ApplyExtensions(d,((d,C)=>d.postExportNodeAsync&&d.postExportNodeAsync(h,C,T,Y,y,this._bufferManager)))}_extensionsPostExportMaterialAsync(h,d,T){return this._ApplyExtensions(d,((d,Y)=>d.postExportMaterialAsync&&d.postExportMaterialAsync(h,Y,T)))}_extensionsPostExportMaterialAdditionalTextures(h,d,T){const Y=[];for(const y of bh._ExtensionNames){const C=this._extensions[y];C.postExportMaterialAdditionalTextures&&Y.push(...C.postExportMaterialAdditionalTextures(h,d,T))}return Y}_extensionsPostExportTextures(h,d,T){for(const Y of bh._ExtensionNames){const y=this._extensions[Y];y.postExportTexture&&y.postExportTexture(h,d,T)}}_extensionsPostExportMeshPrimitive(h){for(const d of bh._ExtensionNames){const T=this._extensions[d];T.postExportMeshPrimitive&&T.postExportMeshPrimitive(h,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const h of bh._ExtensionNames){const d=this._extensions[h];d.preGenerateBinaryAsync&&await d.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(h){for(const d of bh._ExtensionNames){const T=this._extensions[d];T.enabled&&h(T)}}_extensionsOnExporting(){this._forEachExtensions((h=>{var d,T,Y;h.wasUsed&&((d=this._glTF).extensionsUsed||(d.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(h.name)&&this._glTF.extensionsUsed.push(h.name),h.required&&((T=this._glTF).extensionsRequired||(T.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(h.name)&&this._glTF.extensionsRequired.push(h.name)),(Y=this._glTF).extensions||(Y.extensions={}),h.onExporting&&h.onExporting())}))}_loadExtensions(){for(const h of bh._ExtensionNames){const d=bh._ExtensionFactories[h](this);this._extensions[h]=d}}constructor(){let h=arguments.length>0&&void 0!==arguments[0]?arguments[0]:f.d.LastCreatedScene,d=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${O.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new l(this),this._extensions={},this._bufferManager=new Zh,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!h)throw new Error("No scene available to export");this._babylonScene=h,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:h=>{var d;return null===h||void 0===h||null===(d=h.ud)||void 0===d?void 0:d.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...d},this._loadExtensions()}dispose(){for(const h in this._extensions){this._extensions[h].dispose()}}get options(){return this._options}static RegisterExtension(h,d){bh.UnregisterExtension(h)&&y.Tools.Warn(`Extension with the name ${h} already exists`),bh._ExtensionFactories[h]=d,bh._ExtensionNames.push(h)}static UnregisterExtension(h){if(!bh._ExtensionFactories[h])return!1;delete bh._ExtensionFactories[h];const d=bh._ExtensionNames.indexOf(h);return-1!==d&&bh._ExtensionNames.splice(d,1),!0}_generateJSON(h,d,T){const Y={byteLength:h};return Y.byteLength&&(this._glTF.buffers=[Y]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.qd=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(Y.uri=d+".bin"),T?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(h){const d=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(d.byteLength,h,!0),Y=new Blob([d],{type:"application/octet-stream"}),y=h+".gltf",C=h+".bin",n=new U;if(n.files[y]=T,n.files[C]=Y,this._imageData)for(const X in this._imageData)n.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return n}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(h){const d=h%4;return 0===d?d:4-d}async generateGLBAsync(h){this._shouldUseGlb=!0;const d=await this._generateBinaryAsync();this._extensionsOnExporting();const T=this._generateJSON(d.byteLength),Y=h+".glb";let y,C=T.length;if("undefined"!==typeof TextEncoder){y=(new TextEncoder).encode(T),C=y.length}const n=this._getPadding(C),X=this._getPadding(d.byteLength),F=28+C+n+d.byteLength+X,Z=new Fh(F);if(Z.writeUInt32(1179937895),Z.writeUInt32(2),Z.writeUInt32(F),Z.writeUInt32(C+n),Z.writeUInt32(1313821514),y)Z.writeTypedArray(y);else{const h="_".charCodeAt(0);for(let d=0;d<C;++d){const Y=T.charCodeAt(d);Y!=T.codePointAt(d)?Z.writeUInt8(h):Z.writeUInt8(Y)}}for(let U=0;U<n;++U)Z.writeUInt8(32);Z.writeUInt32(d.byteLength+X),Z.writeUInt32(5130562),Z.writeTypedArray(d);for(let U=0;U<X;++U)Z.writeUInt8(0);const S=new U;return S.files[Y]=new Blob([Z.getOutputData()],{type:"application/octet-stream"}),S}_setNodeTransformation(h,d,T){if(d.getPivotPoint().equalsWithEpsilon(v,e.d)||y.Tools.Warn("Pivot points are not supported in the glTF serializer"),!d.position.equalsWithEpsilon(v,e.d)){const y=Y.TmpVectors.pd[0].C(d.position);T&&A(y),h.translation=y.ad()}d.py.equalsWithEpsilon(b,e.d)||(h.scale=d.py.ad());const C=d.rotationQuaternion||Y.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);C.equalsWithEpsilon(G,e.d)||(T&&P(C),h.rotation=C.normalize().ad())}_setCameraTransformation(h,d,T){if(!d.position.equalsWithEpsilon(v,e.d)){const y=Y.TmpVectors.pd[0].C(d.position);T&&A(y),h.translation=y.ad()}const y=d.rotationQuaternion||Y.Quaternion.FromEulerAngles(d.rotation.x,d.rotation.y,d.rotation.z);T&&P(y),this._babylonScene.useRightHandedSystem||t(y),y.equalsWithEpsilon(G,e.d)||(h.rotation=y.ad())}_listAvailableCameras(){for(const h of this._babylonScene.cameras){const d={type:h.mode===rh.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(h.name&&(d.name=h.name),"perspective"===d.type)d.perspective={aspectRatio:h.getEngine().getAspectRatio(h),yfov:h.fovMode===rh.e.FOVMODE_VERTICAL_FIXED?h.fov:h.fov*h.getEngine().getAspectRatio(h),znear:h.Gd,zfar:h.maxZ};else if("orthographic"===d.type){const T=h.orthoLeft&&h.orthoRight?.5*(h.orthoRight-h.orthoLeft):.5*h.getEngine().getRenderWidth(),Y=h.orthoBottom&&h.orthoTop?.5*(h.orthoTop-h.orthoBottom):.5*h.getEngine().getRenderHeight();d.orthographic={xmag:T,ymag:Y,znear:h.Gd,zfar:h.maxZ}}this._camerasMap.set(h,d)}}_exportAndAssignCameras(){const h=Array.from(this._camerasMap.values());for(const d of h){const h=this._nodesCameraMap.get(d);if(void 0!==h){this._cameras.push(d);for(const d of h)d.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const d={joints:[]};this._skinMap.set(h,d)}}_exportAndAssignSkeletons(){for(const h of this._babylonScene.skeletons){if(h.bones.length<=0)continue;const d=this._skinMap.get(h);if(void 0==d)continue;const T={},Y=[];let C=-1;for(let y=0;y<h.bones.length;++y){const d=h.bones[y],Y=d.getIndex()??y;-1!==Y&&(T[Y]=d,Y>C&&(C=Y))}for(let h=0;h<=C;++h){const C=T[h];Y.push(C.getAbsoluteInverseBindMatrix());const n=C.getTransformNode();if(null!==n){const h=this._nodeMap.get(n);n&&null!==h&&void 0!==h?d.joints.push(h):y.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else y.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const n=this._nodesSkinMap.get(d);if(d.joints.length>0&&void 0!==n){const h=64*Y.length,T=new Float32Array(h/4);Y.forEach(((h,d)=>{T.set(h.m,16*d)}));const y=this._bufferManager.createBufferView(T);this._accessors.push(this._bufferManager.createAccessor(y,"MAT4",5126,Y.length)),d.inverseBindMatrices=this._accessors.length-1,this._skins.push(d);for(const d of n)d.skin=this._skins.length-1}}}async _exportSceneAsync(){const h={nodes:[]};if(this._babylonScene.metadata){const d=this._options.metadataSelector(this._babylonScene.metadata);d&&(h.extras=d)}const d=new Array,T=new Array,Y=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&nh(X,this._babylonScene.useRightHandedSystem)?Y.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?d.push(X):T.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const y=new Gh(!0,!1);h.nodes.push(...await this._exportNodesAsync(T,y));const C=new Gh(!1,!1);h.nodes.push(...await this._exportNodesAsync(d,C));const n=new Gh(!1,!0);h.nodes.push(...await this._exportNodesAsync(Y,n)),h.nodes.length&&this._scenes.push(h),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Vh._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,y.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(h){let d=this._shouldExportNodeMap.get(h);return void 0===d&&(d=this._options.shouldExportNode(h),this._shouldExportNodeMap.set(h,d)),d}async _exportNodesAsync(h,d){const T=new Array;this._exportBuffers(h,d);for(const Y of h)await this._exportNodeAsync(Y,T,d);return T}_collectBuffers(h,d,T,Y,y){if(this._shouldExportNode(h)&&h instanceof r.b&&h.Rd){const C=h.Rd.getVertexBuffers();if(C)for(const Y in C){if(!R(Y))continue;const n=C[Y];y.setHasVertexColorAlpha(n,h.hasVertexAlpha);const X=n._buffer,F=d.get(X)||[];d.set(X,F),-1===F.indexOf(n)&&F.push(n);const U=T.get(n)||[];T.set(n,U),-1===U.indexOf(h)&&U.push(h)}const n=h.morphTargetManager;if(n)for(let d=0;d<n.numTargets;d++){const T=n.getTarget(d),y=Y.get(T)||[];Y.set(T,y),-1===y.indexOf(h)&&y.push(h)}}for(const C of h.getChildren())this._collectBuffers(C,d,T,Y,y)}_exportBuffers(h,d){const T=new Map,Y=new Map,y=new Map;for(const X of h)this._collectBuffers(X,T,Y,y,d);const C=Array.from(T.keys());for(const X of C){const h=X.getData();if(!h)throw new Error("Buffer data is not available");const y=T.get(X);if(!y)continue;const C=y[0].byteStride;if(y.some((h=>h.byteStride!==C)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const n=Th(h).slice();for(const d of y){const h=Y.get(d),{byteOffset:T,byteStride:y,componentCount:C,type:X,count:F,normalized:U,kind:S}=M(d,h);switch(S){case Z.g.NormalKind:case Z.g.TangentKind:(0,q.k)(n,T,y,C,X,F,U,(h=>{const d=Math.sqrt(h[0]*h[0]+h[1]*h[1]+h[2]*h[2]);if(d>0){const T=1/d;h[0]*=T,h[1]*=T,h[2]*=T}}));break;case Z.g.ColorKind:{const d=h.filter((h=>h.material instanceof fh.jd||null==h.material)).length;if(0==d)break;if(d!=h.length){j.c.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==Z.g.UNSIGNED_BYTE&&j.c.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const Y=new J.ed,S=new J.ln,r=this._babylonScene.getEngine().useExactSrgbConversions;(0,q.k)(n,T,y,C,X,F,U,(h=>{3===h.length?(Y.vT(h,0),Y.toLinearSpaceToRef(Y,r),Y.toArray(h,0)):(S.vT(h,0),S.toLinearSpaceToRef(S,r),S.toArray(h,0))}))}}}if(d.convertToRightHanded){for(const h of y){const d=Y.get(h),{byteOffset:T,byteStride:y,componentCount:C,type:X,count:F,normalized:U,kind:S}=M(h,d);switch(S){case Z.g.PositionKind:case Z.g.NormalKind:case Z.g.TangentKind:(0,q.k)(n,T,y,C,X,F,U,(h=>{h[0]=-h[0]}))}}d.convertedToRightHandedBuffers.set(X,n)}const F=this._bufferManager.createBufferView(n,C);d.setVertexBufferView(X,F);const U=new Map;for(const d of y){const h=Y.get(d),{kind:T,totalVertices:y}=M(d,h);switch(T){case Z.g.MatricesIndicesKind:case Z.g.MatricesIndicesExtraKind:if(d.type==Z.g.FLOAT){const h=d.getFloatData(y);null!==h&&U.set(d,h)}}}0!==U.size&&j.c.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const S=Array.from(U.keys());for(const T of S){const h=U.get(T);if(!h)continue;const Y=h.some((h=>h>=256)),y=new(Y?Uint16Array:Uint8Array)(h.length);for(let d=0;d<h.length;d++)y[d]=h[d];const C=this._bufferManager.createBufferView(y,4*(Y?2:1));d.setRemappedBufferView(X,T,C)}}const n=Array.from(y.keys());for(const X of n){const h=y.get(X);if(!h)continue;const T=ih(X,h[0],this._bufferManager,this._bufferViews,this._accessors,d.convertToRightHanded);for(const Y of h)d.bindMorphDataToMesh(Y,T)}}async _exportNodeAsync(h,d,T){let Y=this._nodeMap.get(h);if(void 0!==Y)return void(d.includes(Y)||d.push(Y));const y=await this._createNodeAsync(h,T);if(y){Y=this._nodes.length,this._nodes.push(y),this._nodeMap.set(h,Y),T.pushExportedNode(h),d.push(Y);const C={name:"runtime animations",channels:[],samplers:[]},n=[];this._babylonScene.animationGroups.length||(Vh._CreateMorphTargetAnimationFromMorphTargetAnimations(h,C,n,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation),h.animations.length&&Vh._CreateNodeAnimationFromNodeAnimations(h,C,n,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,T.convertToRightHanded,this._options.shouldExportAnimation)),C.channels.length&&C.samplers.length&&this._animations.push(C),n.forEach((h=>{h.channels.length&&h.samplers.length&&this._animations.push(h)}))}const C=y?[]:d;for(const n of h.getChildren())await this._exportNodeAsync(n,C,T);y&&C.length&&(y.children=C)}async _createNodeAsync(h,d){if(!this._shouldExportNode(h))return null;const T={};if(h.name&&(T.name=h.name),h.metadata){const d=this._options.metadataSelector(h.metadata);d&&(T.extras=d)}if(h instanceof S.e&&(this._setNodeTransformation(T,h,d.convertToRightHanded),h instanceof r.b)){const y=h instanceof c.e?h.sourceMesh:h;if(y.ld&&y.ld.length>0&&(T.mesh=await this._exportMeshAsync(y,d)),h.skeleton){const d=this._skinMap.get(h.skeleton);var Y;if(void 0!==d)void 0===this._nodesSkinMap.get(d)&&this._nodesSkinMap.set(d,[]),null===(Y=this._nodesSkinMap.get(d))||void 0===Y||Y.push(T)}}if(h instanceof a.d){const Y=this._camerasMap.get(h);if(Y){var y;void 0===this._nodesCameraMap.get(Y)&&this._nodesCameraMap.set(Y,[]),this._setCameraTransformation(T,h,d.convertToRightHanded);const n=h.parent;if(null!==n&&dh(h,n)){const h=this._nodeMap.get(n);if(void 0!==h){var C;const d=this._nodes[h];return hh(T,d),null===(C=this._nodesCameraMap.get(Y))||void 0===C||C.push(d),null}}null===(y=this._nodesCameraMap.get(Y))||void 0===y||y.push(T)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",T,h,this._nodeMap,d.convertToRightHanded)?T:(j.c.Warn(`Not exporting node ${h.name}`),null)}_exportIndices(h,d,T,Y,y,n,X,F,U){let Z=h;U.mode=Q(n);const S=X!==C.d.CounterClockWiseSideOrientation,r=!F.wasAddedByNoopNode&&S,c=function(h){switch(h){case C.d.TriangleFillMode:case C.d.TriangleStripDrawMode:case C.d.TriangleFanDrawMode:return!0}return!1}(n)&&r;if(c){if(n===C.d.TriangleStripDrawMode||n===C.d.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");U.mode=Q(n);const X=d?new Uint32Array(Y):new Uint16Array(Y);if(h)for(let d=0;d+2<Y;d+=3)X[d]=h[T+d]+y,X[d+1]=h[T+d+2]+y,X[d+2]=h[T+d+1]+y;else for(let h=0;h+2<Y;h+=3)X[h]=h,X[h+1]=h+2,X[h+2]=h+1;Z=X}else if(h&&0!==y){const C=d?new Uint32Array(Y):new Uint16Array(Y);for(let d=0;d<Y;d++)C[d]=h[T+d]+y;Z=C}if(Z){let C=F.getIndicesAccessor(h,T,Y,y,c);if(void 0===C){const n=function(h,d,T,Y){if(h instanceof Uint16Array||h instanceof Uint32Array)return h;if(h instanceof Int32Array)return new Uint32Array(h.buffer,h.byteOffset,h.length);const y=h.slice(d,d+T);return Y?new Uint32Array(y):new Uint16Array(y)}(Z,0,Y,d),X=this._bufferManager.createBufferView(n),U=d?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",U,Y,0)),C=this._accessors.length-1,F.setIndicesAccessor(h,T,Y,y,c,C)}U.indices=C}}_exportVertexBuffer(h,d,T,Y,y,C){const n=h.getKind();if(!R(n))return;if(n.startsWith("uv")&&!this._options.exportUnusedUVs&&(!d||!this._materialNeedsUVsSet.has(d)))return;let X=y.getVertexAccessor(h,T,Y);if(void 0===X){const d=y.convertedToRightHandedBuffers.get(h._buffer)||h._buffer.getData(),C=n===Z.g.PositionKind?function(h,d,T,Y){const{byteOffset:y,byteStride:C,type:n,normalized:X}=d,F=d.getSize(),U=new Array(F).fill(1/0),Z=new Array(F).fill(-1/0);return(0,q.k)(h,y+T*C,C,F,n,Y*F,X,(h=>{for(let d=0;d<F;d++)U[d]=Math.min(U[d],h[d]),Z[d]=Math.max(Z[d],h[d])})),{min:U,max:Z}}(d,h,T,Y):void 0,F=(n===Z.g.MatricesIndicesKind||n===Z.g.MatricesIndicesExtraKind)&&h.type===Z.g.FLOAT,U=F?Z.g.UNSIGNED_BYTE:h.type,S=F?void 0:h.normalized,r=F?y.getRemappedBufferView(h._buffer,h):y.getVertexBufferView(h._buffer),c=h.byteOffset+T*h.byteStride;this._accessors.push(this._bufferManager.createAccessor(r,function(h,d){if(h==Z.g.ColorKind)return d?"VEC4":"VEC3";switch(h){case Z.g.PositionKind:case Z.g.NormalKind:return"VEC3";case Z.g.TangentKind:case Z.g.MatricesIndicesKind:case Z.g.MatricesIndicesExtraKind:case Z.g.MatricesWeightsKind:case Z.g.MatricesWeightsExtraKind:return"VEC4";case Z.g.UVKind:case Z.g.UV2Kind:case Z.g.UV3Kind:case Z.g.UV4Kind:case Z.g.UV5Kind:case Z.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${h}`)}(n,y.hasVertexColorAlpha(h)),U,Y,c,C,S)),X=this._accessors.length-1,y.setVertexAccessor(h,T,Y,X)}C.attributes[function(h){switch(h){case Z.g.PositionKind:return"POSITION";case Z.g.NormalKind:return"NORMAL";case Z.g.TangentKind:return"TANGENT";case Z.g.ColorKind:return"COLOR_0";case Z.g.UVKind:return"TEXCOORD_0";case Z.g.UV2Kind:return"TEXCOORD_1";case Z.g.UV3Kind:return"TEXCOORD_2";case Z.g.UV4Kind:return"TEXCOORD_3";case Z.g.UV5Kind:return"TEXCOORD_4";case Z.g.UV6Kind:return"TEXCOORD_5";case Z.g.MatricesIndicesKind:return"JOINTS_0";case Z.g.MatricesIndicesExtraKind:return"JOINTS_1";case Z.g.MatricesWeightsKind:return"WEIGHTS_0";case Z.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${h}`)}(n)]=X}async _exportMaterialAsync(h,d,T,Y){let y=this._materialMap.get(h);if(void 0===y){const Y=d&&Object.keys(d).some((h=>h.startsWith("uv")));if((h=h instanceof ch.c?h.en[T.materialIndex]:h)instanceof Oh.d)y=await this._materialExporter.exportPBRMaterialAsync(h,"image/png",Y);else{if(!(h instanceof fh.jd))return void j.c.Warn(`Unsupported material '${h.name}' with type ${h.getClassName()}`);y=await this._materialExporter.exportStandardMaterialAsync(h,"image/png",Y)}this._materialMap.set(h,y)}Y.material=y}async _exportMeshAsync(h,d){var T;let Y=d.getMesh(h);if(void 0!==Y)return Y;const y={primitives:[]};Y=this._meshes.length,this._meshes.push(y),d.setMesh(h,Y);const n=h.isUnIndexed?null:h.Pd(),X=null===(T=h.Rd)||void 0===T?void 0:T.getVertexBuffers(),F=d.getMorphTargetsFromMesh(h),U=h instanceof wh.d,Z=h instanceof vh,S=h.ld;if(X&&S&&S.length>0)for(const O of S){const T={attributes:{}},Y=O.jh()||this._babylonScene.defaultMaterial;if(Z){var r,c;const d={name:Y.name},y=h,C=J.ed.White(),n=(null===(r=y.material)||void 0===r?void 0:r.alpha)??1,X=(null===(c=y.greasedLineMaterial)||void 0===c?void 0:c.color)??C;(!X.equalsWithEpsilon(C,e.d)||n<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...X.ad(),n]}),this._materials.push(d),T.material=this._materials.length-1}else if(U){const d={name:Y.name},y=h;(!y.color.equalsWithEpsilon(J.ed.White(),e.d)||y.alpha<1)&&(d.pbrMetallicRoughness={baseColorFactor:[...y.color.ad(),y.alpha]}),this._materials.push(d),T.material=this._materials.length-1}else await this._exportMaterialAsync(Y,X,O,T);const S=U||Z?C.d.LineListDrawMode:h.overrideRenderingFillMode??Y.fillMode,f=Y._getEffectiveOrientation(h);this._exportIndices(n,n?(0,q.d)(n,O.indexCount,O.indexStart,O.verticesStart):O.verticesCount>65535,n?O.indexStart:O.verticesStart,n?O.indexCount:O.verticesCount,-O.verticesStart,S,f,d,T);for(const h of Object.values(X))this._exportVertexBuffer(h,Y,O.verticesStart,O.verticesCount,d,T);if(F){T.targets=[];for(const h of F)T.targets.push(h.attributes)}y.primitives.push(T),this._extensionsPostExportMeshPrimitive(T)}if(F){y.weights=[],y.extras||(y.extras={}),y.extras.targetNames=[];for(const h of F)y.weights.push(h.influence),y.extras.targetNames.push(h.name)}return Y}}bh._ExtensionNames=new Array,bh._ExtensionFactories={};class Bh{static async GLTFAsync(h,d,T){T&&T.exportWithoutWaitingForScene||await h.whenReadyAsync();const Y=new bh(h,T),y=await Y.generateGLTFAsync(d.replace(/\.[^/.]+$/,""));return Y.dispose(),y}static async GLBAsync(h,d,T){T&&T.exportWithoutWaitingForScene||await h.whenReadyAsync();const Y=new bh(h,T),y=await Y.generateGLBAsync(d.replace(/\.[^/.]+$/,""));return Y.dispose(),y}}T(13344);const Mh="EXT_mesh_gpu_instancing";class md{constructor(h){this.name=Mh,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(h,d,T,y,C,n){return await new Promise((h=>{if(d&&T instanceof Lh.d&&T.hasThinInstances&&this._exporter){this._wasUsed=!0;const h=Y.pd.Zero(),y=Y.Quaternion.Identity(),X=Y.pd.One(),F=T.thinInstanceGetWorldMatrices(),U=Y.TmpVectors.pd[2],Z=Y.TmpVectors.Quaternion[1],S=Y.TmpVectors.pd[3];let r=!1,c=!1,O=!1;const f=new Float32Array(3*T.jX),J=new Float32Array(4*T.jX),W=new Float32Array(3*T.jX);let L=0;for(const d of F)d.decompose(S,Z,U),C&&(A(U),P(Z)),f.set(U.ad(),3*L),J.set(Z.normalize().ad(),4*L),W.set(S.ad(),3*L),r=r||!U.equalsWithEpsilon(h),c=c||!Z.equalsWithEpsilon(y),O=O||!S.equalsWithEpsilon(X),L++;const D={attributes:{}};r&&(D.attributes.TRANSLATION=this._buildAccessor(f,"VEC3",T.jX,n)),c&&(D.attributes.ROTATION=this._buildAccessor(J,"VEC4",T.jX,n)),O&&(D.attributes.SCALE=this._buildAccessor(W,"VEC3",T.jX,n)),d.extensions=d.extensions||{},d.extensions[Mh]=D}h(d)}))}_buildAccessor(h,d,T,Y){const y=Y.createBufferView(h),C=Y.createAccessor(y,d,5126,T);return this._exporter._accessors.push(C),this._exporter._accessors.length-1}}bh.RegisterExtension(Mh,(h=>new md(h)));var Rh=T(13350),Qh=T(13365),Ih=T(13374),Ah=T(13381);function Ph(h){return h===Ih.c.PositionKind?"POSITION":h===Ih.c.NormalKind?"NORMAL":h===Ih.c.ColorKind?"COLOR":h.startsWith(Ih.c.UVKind)?"TEX_COORD":"GENERIC"}const th={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class hd extends Rh.c{static get DefaultAvailable(){return(0,Rh.h)(hd.DefaultConfiguration)}static get Default(){return hd._Default??(hd._Default=new hd),hd._Default}static ResetDefault(h){hd._Default&&(h||hd._Default.dispose(),hd._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(h,d){return{module:await(d||DracoEncoderModule)({wasmBinary:h})}}_getWorkerContent(){return`${Qh.h}(${Qh.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:hd.DefaultConfiguration)}async _encodeAsync(h,d,T){const Y=T?(0,Ah.b)(th,T):th;if(this._workerPoolPromise){const T=await this._workerPoolPromise;return await new Promise(((y,C)=>{T.push(((T,n)=>{const X=h=>{T.removeEventListener("error",X),T.removeEventListener("message",F),C(h),n()},F=h=>{"encodeMeshDone"===h.data.id&&(T.removeEventListener("error",X),T.removeEventListener("message",F),y(h.data.encodedMeshData),n())};T.addEventListener("error",X),T.addEventListener("message",F);const U=[];for(const d of h)U.push(d.data.buffer);d&&U.push(d.buffer),T.postMessage({id:"encodeMesh",attributes:h,indices:d,options:Y},U)}))}))}if(this._modulePromise){const T=await this._modulePromise;return(0,Qh.h)(T.module,h,d,Y)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(h,d){if(0==h.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");h instanceof Lh.d&&h.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===d||void 0===d?void 0:d.method)&&(j.c.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),d.method="MESH_SEQUENTIAL_ENCODING");const T=function(h){let d=h.Pd(void 0,!0);return!d||d instanceof Uint32Array||d instanceof Uint16Array||(d=((0,q.d)(d,d.length)?Uint32Array:Uint16Array).from(d)),d}(h),Y=function(h,d){const T=[];for(const Y of h.getVerticesDataKinds()){if(null!==d&&void 0!==d&&d.includes(Y)){if(Y===Ih.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const y=h.getVertexBuffer(Y),C=y.getSize(),n=(0,q.v)(y.getData(),C,y.type,y.byteOffset,y.byteStride,y.normalized,h.getTotalVertices(),!0);T.push({kind:Y,dracoName:Ph(Y),size:C,data:n})}return T}(h,null===d||void 0===d?void 0:d.excludedAttributes);return await this._encodeAsync(Y,T,d)}}hd.DefaultConfiguration={wasmUrl:`${y.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${y.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${y.Tools._DefaultCdnUrl}/draco_encoder.js`},hd._Default=null;const dd="KHR_draco_mesh_compression";class Td{get wasUsed(){return this._wasUsed}constructor(h){this.name=dd,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===h.options.meshCompressionMethod&&hd.DefaultAvailable}dispose(){}postExportMeshPrimitive(h,d,T){if(!this.enabled)return;if(4!==h.mode&&5!==h.mode)return void j.c.Warn("Cannot compress primitive with mode "+h.mode+".");const Y=[],y=[];let C=null;if(void 0!==h.indices){const n=T[h.indices],X=d.getBufferView(n);C=d.getData(X).slice(),Y.push(X),y.push(n)}const n=[];for(const[Z,S]of Object.entries(h.attributes)){const h=T[S],C=d.getBufferView(h),F=mh(h.type),U=(0,q.v)(d.getData(C),F,h.componentType,h.byteOffset||0,C.byteStride||(0,q.q)(h.componentType)*F,h.normalized||!1,h.count,!0);n.push({kind:Z,dracoName:(X=Z,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:mh(h.type),data:U}),Y.push(C),y.push(h)}var X;const F={method:h.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},U=hd.Default._encodeAsync(n,C,F).then((T=>{if(!T)return void j.c.Error("Draco encoding failed for primitive.");const C={bufferView:-1,attributes:T.attributeIds},n=d.createBufferView(T.data);d.setBufferView(C,n);for(const h of Y)this._bufferViewsUsed.add(h);for(const h of y)this._accessorsUsed.add(h);h.extensions||(h.extensions={}),h.extensions[dd]=C})).catch((h=>{j.c.Error("Draco encoding failed for primitive: "+h)}));this._encodePromises.push(U),this._wasUsed=!0}async preGenerateBinaryAsync(h){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((d=>{h.getPropertiesWithBufferView(d).every((h=>this._accessorsUsed.has(h)))&&h.removeBufferView(d)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}bh.RegisterExtension(dd,(h=>new Td(h)));var Yd=T(13385);const yd="KHR_lights_punctual",Cd={name:"",color:[1,1,1],aX:1,range:Number.MAX_VALUE},nd={innerConeAngle:0,outerConeAngle:Math.PI/4},Xd=Y.pd.Backward();class Fd{constructor(h){this.name=yd,this.enabled=!0,this.required=!1,this._exporter=h}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[yd]=this._lights}async postExportNodeAsync(h,d,T,y,C){return await new Promise((n=>{if(!(T instanceof Dh.d))return void n(d);const X=T.getTypeID()==Dh.d.LIGHTTYPEID_POINTLIGHT?"point":T.getTypeID()==Dh.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":T.getTypeID()==Dh.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(T instanceof Yd.d))return j.c.Warn(`${h}: Light ${T.name} is not supported in ${yd}`),void n(d);if(T.falloffType!==Dh.d.FALLOFF_GLTF&&j.c.Warn(`${h}: Light falloff for ${T.name} does not match the ${yd} specification!`),!T.position.equalsToFloats(0,0,0)){const h=Y.TmpVectors.pd[0].C(T.position);C&&A(h),d.translation=h.ad()}if("point"!==X){const h=T.direction.normalizeToRef(Y.TmpVectors.pd[0]);C&&A(h);const y=Y.Quaternion.FromUnitVectorsToRef(Xd,h,Y.TmpVectors.Quaternion[0]);Y.Quaternion.IsIdentity(y)||(d.rotation=y.ad())}const F={type:X,name:T.name,color:T.eX.ad(),aX:T.aX,range:T.range};if(Yh(F,Cd),"spot"===X){const h=T;F.spot={innerConeAngle:h.innerAngle/2,outerConeAngle:h.angle/2},Yh(F.spot,nd)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(F);const U={fd:this._lights.lights.length-1},Z=T.parent;if(Z&&dh(T,Z)){const h=y.get(Z);if(h){const T=this._exporter._nodes[h];return hh(d,T),T.extensions||(T.extensions={}),T.extensions[yd]=U,void n(null)}}d.extensions||(d.extensions={}),d.extensions[yd]=U,n(d)}))}}bh.RegisterExtension(yd,(h=>new Fd(h)));var Ud=T(13281);const Zd="KHR_materials_anisotropy";class Sd{constructor(h){this.name=Zd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Ud.e&&T.anisotropy.isEnabled&&!T.anisotropy.legacy?(T.anisotropy.texture&&Y.push(T.anisotropy.texture),Y):[]}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Ud.e){if(!T.anisotropy.isEnabled||T.anisotropy.legacy)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(T.anisotropy.texture),y={anisotropyStrength:T.anisotropy.aX,anisotropyRotation:T.anisotropy.angle,anisotropyTexture:Y??void 0};null!==y.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(T),d.extensions[Zd]=y}h(d)}))}}bh.RegisterExtension(Zd,(h=>new Sd(h)));const rd="KHR_materials_clearcoat";class cd{constructor(h){this.name=rd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Ud.e&&T.clearCoat.isEnabled?(T.clearCoat.texture&&Y.push(T.clearCoat.texture),!T.clearCoat.useRoughnessFromMainTexture&&T.clearCoat.textureRoughness&&Y.push(T.clearCoat.textureRoughness),T.clearCoat.bumpTexture&&Y.push(T.clearCoat.bumpTexture),Y):[]}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Ud.e){if(!T.clearCoat.isEnabled)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture);let C;C=T.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(T.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(T.clearCoat.textureRoughness),T.clearCoat.isTintEnabled&&y.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${T.name}`),T.clearCoat.remapF0OnInterfaceChange&&y.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${T.name}`);const n=this._exporter._materialExporter.getTextureInfo(T.clearCoat.bumpTexture),X={clearcoatFactor:T.clearCoat.aX,clearcoatTexture:Y??void 0,clearcoatRoughnessFactor:T.clearCoat.roughness,clearcoatRoughnessTexture:C??void 0,clearcoatNormalTexture:n??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),d.extensions[rd]=X}h(d)}))}}bh.RegisterExtension(rd,(h=>new cd(h)));const Od="KHR_materials_diffuse_transmission";function fd(h,d){const T=d.subSurface;let Y=null;return T.translucencyIntensityTexture?Y=T.translucencyIntensityTexture:T.thicknessTexture&&T.useMaskFromThicknessTexture&&(Y=T.thicknessTexture),Y&&!T.useGltfStyleTextures?(j.c.Warn(`${h}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${d.name}`,1),null):Y}class Jd{constructor(h){this.name=Od,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];if(T instanceof Oh.d&&this._isExtensionEnabled(T)){const d=fd(h,T);return d&&Y.push(d),T.subSurface.translucencyColorTexture&&Y.push(T.subSurface.translucencyColorTexture),Y}return Y}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!!d.isTranslucencyEnabled&&(!h.unlit&&!d.useAlbedoToTintTranslucency&&d.useGltfStyleTextures&&1===d.volumeIndexOfRefraction&&0===d.minimumThickness&&0===d.maximumThickness)}postExportMaterialAsync(h,d,T){return new Promise((Y=>{if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0;const Y=T.subSurface,y=fd(h,T),C=0==Y.translucencyIntensity?void 0:Y.translucencyIntensity,n=this._exporter._materialExporter.getTextureInfo(y)??void 0,X=!Y.translucencyColor||Y.translucencyColor.equalsFloats(1,1,1)?void 0:Y.translucencyColor.ad(),F=this._exporter._materialExporter.getTextureInfo(Y.translucencyColorTexture)??void 0,U={diffuseTransmissionFactor:C,diffuseTransmissionTexture:n,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:F};(n||F)&&this._exporter._materialNeedsUVsSet.add(T),d.extensions=d.extensions||{},d.extensions[Od]=U}Y(d)}))}}bh.RegisterExtension(Od,(h=>new Jd(h)));const Wd="KHR_materials_dispersion";class Ld{constructor(){this.name=Wd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!(!d.isRefractionEnabled&&!d.isDispersionEnabled)}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0;const h={dispersion:T.subSurface.dispersion};d.extensions=d.extensions||{},d.extensions[Wd]=h}h(d)}))}}bh.RegisterExtension(Wd,(()=>new Ld));const Dd="KHR_materials_emissive_strength";class Vd{constructor(){this.name=Dd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(h,d,T){return await new Promise((h=>{if(!(T instanceof Oh.d))return h(d);const Y=T.emissiveColor.ad(),y=Math.max(...Y);if(y>1){this._wasUsed=!0,d.extensions||(d.extensions={});const h={emissiveStrength:y},Y=T.emissiveColor.scale(1/h.emissiveStrength);d.emissiveFactor=Y.ad(),d.extensions[Dd]=h}return h(d)}))}}bh.RegisterExtension(Dd,(h=>new Vd));const id="KHR_materials_ior";class wd{constructor(){this.name=id,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.indexOfRefraction&&1.5!=h.indexOfRefraction)}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0;const h={ior:T.indexOfRefraction};d.extensions=d.extensions||{},d.extensions[id]=h}h(d)}))}}bh.RegisterExtension(id,(h=>new wd));const sd="KHR_materials_iridescence";class Ed{constructor(h){this.name=sd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Ud.e&&T.iridescence.isEnabled?(T.iridescence.texture&&Y.push(T.iridescence.texture),T.iridescence.thicknessTexture&&T.iridescence.thicknessTexture!==T.iridescence.texture&&Y.push(T.iridescence.thicknessTexture),Y):[]}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Ud.e){if(!T.iridescence.isEnabled)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(T.iridescence.texture),y=this._exporter._materialExporter.getTextureInfo(T.iridescence.thicknessTexture),C={iridescenceFactor:T.iridescence.aX,iridescenceIor:T.iridescence.indexOfRefraction,iridescenceThicknessMinimum:T.iridescence.minimumThickness,iridescenceThicknessMaximum:T.iridescence.maximumThickness,iridescenceTexture:Y??void 0,iridescenceThicknessTexture:y??void 0};null===C.iridescenceTexture&&null===C.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(T),d.extensions[sd]=C}h(d)}))}}bh.RegisterExtension(sd,(h=>new Ed(h)));const zd="KHR_materials_sheen";class xd{constructor(h){this.name=zd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){return T instanceof Oh.d&&T.sheen.isEnabled&&T.sheen.texture?[T.sheen.texture]:[]}async postExportMaterialAsync(h,d,T){return await new Promise((h=>{if(T instanceof Oh.d){if(!T.sheen.isEnabled)return void h(d);this._wasUsed=!0,null==d.extensions&&(d.extensions={});const Y={sheenColorFactor:T.sheen.color.ad(),sheenRoughnessFactor:T.sheen.roughness??0};null===Y.sheenColorTexture&&null===Y.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(T),T.sheen.texture&&(Y.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),T.sheen.textureRoughness&&!T.sheen.useRoughnessFromMainTexture?Y.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.textureRoughness)??void 0:T.sheen.texture&&T.sheen.useRoughnessFromMainTexture&&(Y.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(T.sheen.texture)??void 0),d.extensions[zd]=Y}h(d)}))}}bh.RegisterExtension(zd,(h=>new xd(h)));const gd="KHR_materials_specular";class Hd{constructor(h){this.name=gd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Oh.d&&this._isExtensionEnabled(T)?(T.metallicReflectanceTexture&&Y.push(T.metallicReflectanceTexture),T.reflectanceTexture&&Y.push(T.reflectanceTexture),Y):Y}_isExtensionEnabled(h){return!h.unlit&&(void 0!=h.metallicF0Factor&&1!=h.metallicF0Factor||void 0!=h.metallicReflectanceColor&&!h.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.metallicReflectanceTexture||null!=h.reflectanceTexture}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0,d.extensions=d.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(T.metallicReflectanceTexture)??void 0,Y=this._exporter._materialExporter.getTextureInfo(T.reflectanceTexture)??void 0,y={specularFactor:1==T.metallicF0Factor?void 0:T.metallicF0Factor,specularTexture:h,specularColorFactor:T.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:T.metallicReflectanceColor.ad(),specularColorTexture:Y};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),d.extensions[gd]=y}h(d)}))}}bh.RegisterExtension(gd,(h=>new Hd(h)));const pd="KHR_materials_transmission";class kd{constructor(h){this.name=pd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Oh.d&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&Y.push(T.subSurface.thicknessTexture),Y):Y}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return d.isRefractionEnabled&&void 0!=d.refractionIntensity&&0!=d.refractionIntensity||this._hasTexturesExtension(h)}_hasTexturesExtension(h){return null!=h.subSurface.refractionIntensityTexture}async postExportMaterialAsync(h,d,T){if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0;const Y=T.subSurface,y={transmissionFactor:0===Y.refractionIntensity?void 0:Y.refractionIntensity};if(this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),Y.refractionIntensityTexture)if(Y.useGltfStyleTextures){const h=await this._exporter._materialExporter.exportTextureAsync(Y.refractionIntensityTexture,"image/png");h&&(y.transmissionTexture=h)}else j.c.Warn(`${h}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);d.extensions||(d.extensions={}),d.extensions[pd]=y}return d}}bh.RegisterExtension(pd,(h=>new kd(h)));const od="KHR_materials_unlit";class ud{constructor(){this.name=od,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(h,d,T){return new Promise((h=>{let Y=!1;T instanceof Oh.d?Y=T.unlit:T instanceof fh.jd&&(Y=T.disableLighting),Y&&(this._wasUsed=!0,null==d.extensions&&(d.extensions={}),d.extensions[od]={}),h(d)}))}}bh.RegisterExtension(od,(()=>new ud));const Nd="KHR_materials_volume";class Kd{constructor(h){this.name=Nd,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Oh.d&&this._isExtensionEnabled(T)?(T.subSurface.thicknessTexture&&Y.push(T.subSurface.thicknessTexture),Y):Y}_isExtensionEnabled(h){if(h.unlit)return!1;const d=h.subSurface;return!(!d.isRefractionEnabled&&!d.isTranslucencyEnabled)&&(void 0!=d.maximumThickness&&0!=d.maximumThickness||void 0!=d.tintColorAtDistance&&d.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=d.tintColor&&d.tintColor!=J.ed.White()||this._hasTexturesExtension(h))}_hasTexturesExtension(h){return null!=h.subSurface.thicknessTexture}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Oh.d&&this._isExtensionEnabled(T)){this._wasUsed=!0;const h=T.subSurface,Y={thicknessFactor:0==h.maximumThickness?void 0:h.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(h.thicknessTexture)??void 0,attenuationDistance:h.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:h.tintColorAtDistance,attenuationColor:h.tintColor.equalsFloats(1,1,1)?void 0:h.tintColor.ad()};this._hasTexturesExtension(T)&&this._exporter._materialNeedsUVsSet.add(T),d.extensions=d.extensions||{},d.extensions[Nd]=Y}h(d)}))}}bh.RegisterExtension(Nd,(h=>new Kd(h)));const ld="EXT_materials_diffuse_roughness";class qd{constructor(h){this.name=ld,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=h}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(h,d,T){const Y=[];return T instanceof Ud.e&&T._baseDiffuseRoughness?(T._baseDiffuseRoughnessTexture&&Y.push(T._baseDiffuseRoughnessTexture),Y):[]}postExportMaterialAsync(h,d,T){return new Promise((h=>{if(T instanceof Ud.e){if(!T._baseDiffuseRoughness)return void h(d);this._wasUsed=!0,d.extensions=d.extensions||{};const Y=this._exporter._materialExporter.getTextureInfo(T._baseDiffuseRoughnessTexture),y={diffuseRoughnessFactor:T._baseDiffuseRoughness,diffuseRoughnessTexture:Y??void 0};null!==y.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(T),d.extensions[ld]=y}h(d)}))}}bh.RegisterExtension(ld,(h=>new qd(h)));const jd="KHR_texture_transform";class ad{constructor(){this.name=jd,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(h,d,T){if(T.Eh()||y.Tools.Warn(`${h}: /*@__KEY__*/"scene" is not defined for Babylon texture ${T.name}!`),(0!==T.uAng||0!==T.vAng)&&(y.Tools.Warn(`${h}: Texture ${T.name} with rotation in the u or v axis is not supported in glTF.`),0!==T.uRotationCenter||0!==T.vRotationCenter))return;const Y={};let C=!1;if(0===T.uOffset&&0===T.vOffset||(Y.offset=[T.uOffset,T.vOffset],C=!0),1===T.uScale&&1===T.vScale||(Y.scale=[T.uScale,T.vScale],C=!0),0!==T.wAng){if(0!==T.uRotationCenter||0!==T.vRotationCenter){if(T.homogeneousRotationInUVTransform&&T.uScale!==T.vScale)return void y.Tools.Warn(`${h}: Texture ${T.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${jd}.`);y.Tools.Warn(`${h}: Texture ${T.name} with non-origin rotation center will be exported using an adjusted offset with ${jd}.`),Y.offset=function(h){const{uOffset:d,vOffset:T,uRotationCenter:Y,vRotationCenter:y,uScale:C,vScale:n,wAng:X}=h,F=Math.cos(X),U=Math.sin(X),Z=Y*C,S=y*n;return[d+(Z*(1-F)+S*U),T+(S*(1-F)-Z*U)]}(T)}Y.rotation=-T.wAng,C=!0}0!==T.coordinatesIndex&&(Y.texCoord=T.coordinatesIndex,C=!0),C&&(this._wasUsed=!0,d.extensions||(d.extensions={}),d.extensions[jd]=Y)}}bh.RegisterExtension(jd,(()=>new ad));class ed{static CreateSTL(h){let d=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",y=arguments.length>3&&void 0!==arguments[3]&&arguments[3],C=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],n=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],F=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const U=function(h,d,T){const y=[3*h[T],3*h[T+1],3*h[T+2]],C=[new Y.pd(d[y[0]],d[y[0]+2],d[y[0]+1]),new Y.pd(d[y[1]],d[y[1]+2],d[y[1]+1]),new Y.pd(d[y[2]],d[y[2]+2],d[y[2]+1])],n=C[0].Nd(C[1]),X=C[2].Nd(C[1]);return{v:C,n:Y.pd.Cross(X,n).normalize()}},S=function(h,d,T,Y){return d=r(h,d,T.x,Y),d=r(h,d,T.y,Y),r(h,d,T.z,Y)},r=function(h,d,T,Y){return h.setFloat32(d,T,Y),d+4},O=function(h){if(X){let d=h;h instanceof c.e&&(d=h.sourceMesh);const T=d.getVerticesData(Z.g.PositionKind,!0,!0);if(!T)return[];const y=Y.pd.Zero();let C;for(C=0;C<T.length;C+=3)Y.pd.TransformCoordinatesFromFloatsToRef(T[C],T[C+1],T[C+2],h.Md(!0),y).toArray(T,C);return T}return h.getVerticesData(Z.g.PositionKind)||[]};X&&(n=!0);let f="",J=0,W=0;if(y){for(let T=0;T<h.length;T++){const d=h[T].Pd();J+=d?d.length/3:0}const d=new ArrayBuffer(84+50*J);f=new DataView(d),W+=80,f.setUint32(W,J,C),W+=4}else F||(f="solid stlmesh\r\n");for(let Y=0;Y<h.length;Y++){const d=h[Y];!y&&F&&(f+="solid "+d.name+"\r\n"),!n&&d instanceof Lh.d&&d.bakeCurrentTransformIntoVertices();const T=O(d),X=d.Pd()||[];for(let h=0;h<X.length;h+=3){const d=U(X,T,h);y?(W=S(f,W,d.n,C),W=S(f,W,d.v[0],C),W=S(f,W,d.v[1],C),W=S(f,W,d.v[2],C),W+=2):(f+="\tfacet normal "+d.n.x+" "+d.n.y+" "+d.n.z+"\r\n",f+="\t\touter loop\r\n",f+="\t\t\tvertex "+d.v[0].x+" "+d.v[0].y+" "+d.v[0].z+"\r\n",f+="\t\t\tvertex "+d.v[1].x+" "+d.v[1].y+" "+d.v[1].z+"\r\n",f+="\t\t\tvertex "+d.v[2].x+" "+d.v[2].y+" "+d.v[2].z+"\r\n",f+="\t\tendloop\r\n",f+="\tendfacet\r\n")}!y&&F&&(f+="endsolid "+name+"\r\n")}if(y||F||(f+="endsolid stlmesh"),d){const h=document.createElement("a"),d=new Blob([f],{type:"application/octet-stream"});h.href=window.URL.createObjectURL(d),h.download=T+".stl",h.click()}return f}}function vd(h,d){let T=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const Y=[];for(let y=0;y<h.length/T;y++){const C=h[y*T],n=h[y*T+1],X=h[y*T+2];Y.push(`(${C.toPrecision(d.precision)}, ${n.toPrecision(d.precision)}, ${X.toPrecision(d.precision)})`)}return Y.join(", ")}function Gd(h,d){const T=[];for(let Y=0;Y<h.length/2;Y++){const y=h[2*Y],C=h[2*Y+1];T.push(`(${y.toPrecision(d.precision)}, ${(1-C).toPrecision(d.precision)})`)}return T.join(", ")}function bd(h,d){const T=h.getVerticesData(Z.g.PositionKind),Y=h.getVerticesData(Z.g.NormalKind);if(T&&Y)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(h){var d;const T=null!==(d=h.Pd())&&void 0!==d&&d.length?h.getTotalIndices():h.getTotalVertices();return Array(T/3).fill(3).join(", ")}(h)}]\n\t\tint[] faceVertexIndices = [${function(h){const d=h.Pd(),T=[];if(null!==d)for(let Y=0;Y<d.length;Y++)T.push(d[Y]);else{const d=h.getTotalVertices();for(let h=0;h<d;h++)T.push(h)}return T.join(", ")}(h)}]\n\t\tnormal3f[] normals = [${vd(Y,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${vd(T,d)}]\n        ${function(h,d){let T="";for(let y=0;y<4;y++){const Y=y>0?y:"",C=h.getVerticesData(Z.g.UVKind+(Y?Y+1:""));C&&(T+=`\n\t\ttexCoord2f[] primvars:st${Y} = [${Gd(C,d)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const Y=h.getVerticesData(Z.g.ColorKind);return Y&&(T+=`\n\tcolor3f[] primvars:displayColor = [${vd(Y,d,Y.length/h.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),T}(h,d)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Bd(h,d){return`\n        def "Geometry"\n        {\n        ${bd(h,d)}\n        }\n        `}function Md(h){let d='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return d+=h,fflate.strToU8(d)}function mT(h){const d=h.m;return`( ${Rd(d,0)}, ${Rd(d,4)}, ${Rd(d,8)}, ${Rd(d,12)} )`}function Rd(h,d){return`(${h[d+0]}, ${h[d+1]}, ${h[d+2]}, ${h[d+3]})`}function Qd(h){const d="Object_"+h.uniqueId,T=function(h){const d=h.getWorldMatrix().clone(),T=h.Eh().useRightHandedSystem;if(!T){let Y=h.parent;for(;Y;){if(nh(Y,T)){d.multiplyToRef(Y.getWorldMatrix().invert(),d);break}Y=Y.parent}}return d.determinant()<0&&y.Tools.Warn(`Exporting mesh ${h.name} with negative scale. Result may look incorrect in destination engine.`),d}(h),Y=mT(T);return`def Xform "${d}" (\n\tprepend references = @./geometries/Geometry_${h.Rd.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${Y}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${h.material.uniqueId}>\n}\n\n`}function Id(h){switch(h){case s.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case s.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case s.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Ad(h){return`(${h.x}, ${h.y})`}function Pd(h){return`(${h.r}, ${h.g}, ${h.b})`}function td(h,d,T,y,C,n){const X=h.getInternalTexture().uniqueId+"_"+h.invertY;C[X]=h;const F=h.coordinatesIndex>0?"st"+h.coordinatesIndex:"st",U=new Y.Vector2(h.uScale,h.vScale),Z=new Y.Vector2(h.uOffset,h.vOffset),S=h.wAng,r=Math.sin(S),c=Math.cos(S);return Z.y=1-Z.y-U.y,Z.x+=r*U.x,Z.y+=(1-c)*U.y,`\n    def Shader "PrimvarReader_${T}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${F}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${T}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${d.uniqueId}/PrimvarReader_${T}.outputs:result>\n        float inputs:rotation = ${(S*(180/Math.PI)).toFixed(n.precision)}\n        float2 inputs:scale = ${Ad(U)}\n        float2 inputs:translation = ${Ad(Z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${h.uniqueId}_${T}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${d.uniqueId}/Transform2d_${T}.outputs:result>\n        ${y?"float4 inputs:scale = "+function(h){return`(${h.r}, ${h.g}, ${h.b}, 1.0)`}(y):""}\n        token inputs:sourceColorSpace = "${h.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Id(h.wrapU)}"\n        token inputs:wrapT = "${Id(h.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${d.needAlphaBlending()?"float outputs:a":""}\n    }`}function hT(h,d,T){const Y="\t\t\t",y=[],C=[],{diffuseMap:n,eX:X,alphaCutOff:F,emissiveMap:U,emissive:Z,normalMap:S,roughnessMap:r,roughnessChannel:c,roughness:O,metalnessMap:f,metalnessChannel:W,metalness:L,aoMap:D,aoMapChannel:V,aoMapIntensity:i,alphaMap:w,ior:s,clearCoatEnabled:E,clearCoat:z,clearCoatMap:x,clearCoatRoughness:g,clearCoatRoughnessMap:H}=function(h){const d={diffuseMap:null,eX:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return h instanceof fh.jd?{...d,diffuseMap:h.diffuseTexture,eX:h.diffuseColor,alphaCutOff:h.alphaCutOff,emissiveMap:h.emissiveTexture,emissive:h.emissiveColor,roughness:1,alphaMap:h.opacityTexture}:h instanceof Ud.e?{...d,diffuseMap:h._albedoTexture,eX:h._albedoColor,alphaCutOff:h._alphaCutOff,emissiveMap:h._emissiveTexture,emissive:h._emissiveColor,normalMap:h._bumpTexture,roughnessMap:h._metallicTexture,roughnessChannel:h._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:h._roughness??1,metalnessMap:h._metallicTexture,metalnessChannel:h._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:h._metallic??0,aoMap:h._ambientTexture,aoMapChannel:h._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:h._ambientTextureStrength,alphaMap:h._opacityTexture,ior:h.subSurface.indexOfRefraction,clearCoatEnabled:h.clearCoat.isEnabled,clearCoat:h.clearCoat.aX,clearCoatMap:h.clearCoat.texture,clearCoatRoughness:h.clearCoat.roughness,clearCoatRoughnessMap:h.clearCoat.useRoughnessFromMainTexture?h.clearCoat.texture:h.clearCoat.textureRoughness}:d}(h);return null!==n?(y.push(`${Y}color3f inputs:diffuseColor.connect = </Materials/Material_${h.uniqueId}/Texture_${n.uniqueId}_diffuse.outputs:rgb>`),h.needAlphaBlending()?y.push(`${Y}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${n.uniqueId}_diffuse.outputs:a>`):h.needAlphaTesting()&&(y.push(`${Y}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${n.uniqueId}_diffuse.outputs:a>`),y.push(`${Y}float inputs:opacityThreshold = ${F}`)),C.push(td(n,h,"diffuse",X,d,T))):y.push(`${Y}color3f inputs:diffuseColor = ${Pd(X||J.ed.White())}`),null!==U?(y.push(`${Y}color3f inputs:emissiveColor.connect = </Materials/Material_${h.uniqueId}/Texture_${U.uniqueId}_emissive.outputs:rgb>`),C.push(td(U,h,"emissive",Z,d,T))):Z&&Z.toLuminance()>0&&y.push(`${Y}color3f inputs:emissiveColor = ${Pd(Z)}`),null!==S&&(y.push(`${Y}normal3f inputs:normal.connect = </Materials/Material_${h.uniqueId}/Texture_${S.uniqueId}_normal.outputs:rgb>`),C.push(td(S,h,"normal",null,d,T))),null!==D&&(y.push(`${Y}float inputs:occlusion.connect = </Materials/Material_${h.uniqueId}/Texture_${D.uniqueId}_occlusion.outputs:${V}>`),C.push(td(D,h,"occlusion",new J.ed(i,i,i),d,T))),null!==r?(y.push(`${Y}float inputs:roughness.connect = </Materials/Material_${h.uniqueId}/Texture_${r.uniqueId}_roughness.outputs:${c}>`),C.push(td(r,h,"roughness",new J.ed(O,O,O),d,T))):y.push(`${Y}float inputs:roughness = ${O}`),null!==f?(y.push(`${Y}float inputs:metallic.connect = </Materials/Material_${h.uniqueId}/Texture_${f.uniqueId}_metallic.outputs:${W}>`),C.push(td(f,h,"metallic",new J.ed(L,L,L),d,T))):y.push(`${Y}float inputs:metallic = ${L}`),null!==w?(y.push(`${Y}float inputs:opacity.connect = </Materials/Material_${h.uniqueId}/Texture_${w.uniqueId}_opacity.outputs:r>`),y.push(`${Y}float inputs:opacityThreshold = 0.0001`),C.push(td(w,h,"opacity",null,d,T))):y.push(`${Y}float inputs:opacity = ${h.alpha}`),E&&(null!==x?(y.push(`${Y}float inputs:clearcoat.connect = </Materials/Material_${h.uniqueId}/Texture_${x.uniqueId}_clearcoat.outputs:r>`),C.push(td(x,h,"clearcoat",new J.ed(z,z,z),d,T))):y.push(`${Y}float inputs:clearcoat = ${z}`),null!==H?(y.push(`${Y}float inputs:clearcoatRoughness.connect = </Materials/Material_${h.uniqueId}/Texture_${H.uniqueId}_clearcoatRoughness.outputs:g>`),C.push(td(H,h,"clearcoatRoughness",new J.ed(g,g,g),d,T))):y.push(`${Y}float inputs:clearcoatRoughness = ${g}`)),y.push(`${Y}float inputs:ior = ${s}`),`\n\tdef Material "Material_${h.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${y.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${h.uniqueId}/PreviewSurface.outputs:surface>\n\n${C.join("\n")}\n\n\t}\n`}async function dT(h,d,T){const C={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...d};"undefined"===typeof fflate&&await y.Tools.LoadScriptAsync(C.fflateUrl);const n={};n[C.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(h){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===h.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${h.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${h.planeAnchoringAlignment}"`:""}\n            `}(C);const F={};for(const Y of h.meshes){if(0===Y.getTotalVertices())continue;const h=Y,d=h.Rd,U=h.material;if(!U||!d||T&&!T(h))continue;if(-1!==["jd","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(U.getClassName())){const T="geometries/Geometry_"+d.uniqueId+".usda";if(!(T in n)){const h=Bd(d,C);n[T]=Md(h)}U.uniqueId in F||(F[U.uniqueId]=U),X+=Qd(h)}else y.Tools.Warn("USDZExportAsync does not support this material type: "+U.getClassName())}h.activeCamera&&C.exportCamera&&(X+=function(h,d){const T="Camera_"+h.uniqueId,y=mT(Y.Matrix.RotationY(Math.PI).multiply(h.getWorldMatrix()));if(h.mode===s.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${y}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.Gd.toPrecision(d.precision)}, ${h.maxZ.toPrecision(d.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(h.orthoLeft||1)+Math.abs(h.orthoRight||1))).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(h.orthoTop||1)+Math.abs(h.orthoBottom||1))).toPrecision(d.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const Y=h.getEngine().getAspectRatio(h),C=d.cameraSensorWidth||35;return`def Camera "${T}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${y}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${h.Gd.toPrecision(d.precision)}, ${h.maxZ.toPrecision(d.precision)})\n\t\t\tfloat focalLength = ${(C/(2*Math.tan(.5*h.fov))).toPrecision(d.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(C*Y).toPrecision(d.precision)}\n\t\t\tfloat verticalAperture = ${(C/Y).toPrecision(d.precision)}            \n\t\t}\n\t\n\t`}}(h.activeCamera,C)),X+="\n            }\n        }\n    }";const U={};X+=function(h,d,T){const Y=[];for(const y in h){const C=h[y];Y.push(hT(C,d,T))}return`\n    def "Materials"\n{\n${Y.join("")}\n}\n\n`}(F,U,C),n[C.modelFileName]=fflate.strToU8(X);for(const Y in U){const h=U[Y],d=h.getSize(),T=await h.readPixels();if(!T)throw new Error("Texture data is not available");const y=await E.DumpTools.DumpDataAsync(d.width,d.height,T,"image/png",void 0,!1,!0);n[`textures/Texture_${Y}.png`]=new Uint8Array(y).slice()}let Z=0;for(const Y in n){const h=n[Y];if(!h)continue;Z+=34+Y.length;const d=63&Z;if(4!==d){const T=new Uint8Array(64-d);n[Y]=[h,{extra:{12345:T}}]}Z=h.length}return fflate.zipSync(n,{level:0})}}}]);