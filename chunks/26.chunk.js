"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11613:(B,I,C)=>{C.r(I),C.d(I,{EXT_materials_diffuse_roughness:()=>EI,EXT_mesh_gpu_instancing:()=>TB,GLTF2Export:()=>sB,GLTFData:()=>g,KHR_draco_mesh_compression:()=>CI,KHR_lights_punctual:()=>eI,KHR_materials_anisotropy:()=>RI,KHR_materials_clearcoat:()=>FI,KHR_materials_diffuse_transmission:()=>SI,KHR_materials_dispersion:()=>UI,KHR_materials_emissive_strength:()=>VI,KHR_materials_ior:()=>tI,KHR_materials_iridescence:()=>AI,KHR_materials_sheen:()=>JI,KHR_materials_specular:()=>uI,KHR_materials_transmission:()=>nI,KHR_materials_unlit:()=>aI,KHR_materials_volume:()=>dI,KHR_texture_transform:()=>ZI,OBJExport:()=>f,STLExport:()=>zI,USDZExportAsync:()=>IC,_ConvertToGLTFPBRMetallicRoughness:()=>O,_SolveMetallic:()=>n,__IGLTFExporterExtension:()=>L});var M=C(11194),x=C(11018),y=C(11516);class f{static OBJ(B,I,C,f){const L=[];let e=1,g=1;I&&(C||(C="mat"),L.push("mtllib "+C+".mtl"));for(let N=0;N<B.length;N++){const C=B[N],R=C.name||`mesh${N}}`;L.push(`o ${R}`);let H=null;if(f){const B=C.nf(!0);H=new M.Matrix,B.invertToRef(H),C.bakeTransformIntoVertices(B)}if(I){const B=C.material;B&&L.push("usemtl "+B.id)}const F=C.zf;if(!F){x.Tools.Warn("No geometry is present on the mesh");continue}const k=F.getVerticesData("position"),q=F.getVerticesData("normal"),S=F.getVerticesData("uv"),o=F.bf();let U=0,G=0;if(!k||!o){x.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const V=B[0].rB().useRightHandedSystem?1:-1;for(let B=0;B<k.length;B+=3)L.push("v "+k[B]*V+" "+k[B+1]+" "+k[B+2]),U++;if(null!=q)for(let B=0;B<q.length;B+=3)L.push("vn "+q[B]*V+" "+q[B+1]+" "+q[B+2]);if(null!=S)for(let B=0;B<S.length;B+=2)L.push("vt "+S[B]+" "+S[B+1]),G++;const c=["","",""],t=(C.material||C.rB().defaultMaterial)._getEffectiveOrientation(C),[r,A]=t===y.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let B=0;B<o.length;B+=3){const I=[String(o[B]+e),String(o[B+r]+e),String(o[B+A]+e)],C=[String(o[B]+g),String(o[B+r]+g),String(o[B+A]+g)],M=I,x=null!=S?C:c,y=null!=q?I:c;L.push("f "+M[0]+"/"+x[0]+"/"+y[0]+" "+M[1]+"/"+x[1]+"/"+y[1]+" "+M[2]+"/"+x[2]+"/"+y[2])}f&&H&&C.bakeTransformIntoVertices(H),e+=U,g+=G}return L.join("\n")}static MTL(B){const I=[],C=B.material;I.push("newmtl mat1"),I.push("  Ns "+C.specularPower.toFixed(4)),I.push("  Ni 1.5000"),I.push("  d "+C.alpha.toFixed(4)),I.push("  Tr 0.0000"),I.push("  Tf 1.0000 1.0000 1.0000"),I.push("  illum 2"),I.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),I.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),I.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),I.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&I.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&I.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&I.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&I.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&I.push("  map_d "+C.opacityTexture.name);return I.join("\n")}}var L=0,e=C(11062);class g{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const B in this.files){const I=this.files[B],C=new Blob([I],{type:(0,e.j)(B)});x.Tools.Download(C,B)}}}var N=C(11270),R=C(11616),H=C(11625),F=C(11643),k=C(11324),q=C(11056),S=C(11239),o=C(11212);const U=o.HighestCommonFactor,G={...o,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:U};var V=C(11426),c=C(11171),t=C(11659),r=C(11662),A=C(11423);const D=1e-6,J=new S.SI(.04,.04,.04),i=1024,u=S.SI.White(),p=S.SI.Black();function n(B,I,C){if(I<J.r)return 0;const M=J.r,x=B*C/(1-J.r)+I-2*J.r,y=x*x-4*M*(J.r-I);return G.Clamp((-x+Math.sqrt(y))/(2*M),0,1)}function O(B){const I=B.diffuseColor.toLinearSpace(B.rB().getEngine().useExactSrgbConversions).scale(.5),C=B.alpha,x=function(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new M.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new M.Vector2(0,.1),x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new M.Vector2(0,.1),y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new M.Vector2(1300,.1);return function(B,I,C,M,x){return(1-B)*(1-B)*(1-B)*I+3*(1-B)*(1-B)*B*C+3*(1-B)*B*B*M+B*B*B*x}(Math.pow(B/y.x,.333333),I.y,C.y,x.y,y.y)}(G.Clamp(B.specularPower,0,i));return{baseColorFactor:[I.r,I.g,I.b,C],metallicFactor:0,roughnessFactor:x}}function a(B,I){I.needAlphaBlending()?B.alphaMode="BLEND":I.needAlphaTesting()&&(B.alphaMode="MASK",B.alphaCutoff=I.alphaCutOff)}function W(B,I,C){const M=new Uint8Array(B*I*4);for(let x=0;x<M.length;x+=4)M[x]=M[x+1]=M[x+2]=M[x+3]=255;return t.e.CreateRGBATexture(M,B,I,C)}function d(B){if(B instanceof Uint8Array){const I=B.length,C=new Float32Array(B.length);for(let M=0;M<I;++M)C[M]=B[M]/255;return C}if(B instanceof Float32Array)return B;throw new Error("Unsupported pixel format!")}class l{constructor(B){this._exporter=B,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(B){return B?this._textureMap.get(B)??null:null}async exportStandardMaterialAsync(B,I,C){const M=O(B),y={name:B.name};if(null==B.Yf||B.Yf||(B.twoSidedLighting||x.Tools.Warn(B.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),y.doubleSided=!0),C){const C=[],x=B.diffuseTexture;x&&C.push(this.exportTextureAsync(x,I).then((B=>{B&&(M.baseColorTexture=B)})));const f=B.bumpTexture;f&&C.push(this.exportTextureAsync(f,I).then((B=>{B&&(y.normalTexture=B,1!==f.level&&(y.normalTexture.scale=f.level))})));const L=B.emissiveTexture;L&&(y.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(L,I).then((B=>{B&&(y.emissiveTexture=B)}))));const e=B.ambientTexture;e&&C.push(this.exportTextureAsync(e,I).then((B=>{if(B){const I={index:B.index};y.occlusionTexture=I}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(C))}(B.alpha<1||B.opacityTexture)&&(B.alphaMode===r.b.ALPHA_COMBINE?y.alphaMode="BLEND":x.Tools.Warn(B.name+": glTF 2.0 does not support alpha mode: "+B.alphaMode.toString())),B.emissiveColor&&!B.emissiveColor.equalsWithEpsilon(p,D)&&(y.emissiveFactor=B.emissiveColor.Df()),y.pbrMetallicRoughness=M,a(y,B),await this._finishMaterialAsync(y,B,I);const f=this._exporter._materials;return f.push(y),f.length-1}async _finishMaterialAsync(B,I,C){const M=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",B,I),x=[];for(const y of M)x.push(this.exportTextureAsync(y,C));await Promise.all(x),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",B,I)}async _getImageDataAsync(B,I,M,x){const y=r.b.TEXTURETYPE_UNSIGNED_BYTE,f=this._exporter._babylonScene,L=f.getEngine(),e=L.createRawTexture(B,I,M,r.b.TEXTUREFORMAT_RGBA,!1,!0,c.c.NEAREST_SAMPLINGMODE,null,y);L.isWebGPU?await C.e(51).then(C.bind(C,13673)):await C.e(52).then(C.bind(C,13679)),await V.k.ApplyPostProcess("pass",e,f,y,r.b.TEXTURE_NEAREST_SAMPLINGMODE,r.b.TEXTUREFORMAT_RGBA);const g=await L._readTexturePixels(e,I,M);return await A.DumpTools.DumpDataAsync(I,M,g,x,void 0,!0,!0)}_resizeTexturesToSameDimensions(B,I,C){const M=B?B.getSize():{width:0,height:0},x=I?I.getSize():{width:0,height:0};let y,f;return M.width<x.width?(y=B&&B instanceof c.c?V.k.CreateResizedCopy(B,x.width,x.height,!0):W(x.width,x.height,C),f=I):M.width>x.width?(f=I&&I instanceof c.c?V.k.CreateResizedCopy(I,M.width,M.height,!0):W(M.width,M.height,C),y=B):(y=B,f=I),{texture1:y,texture2:f}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,I,C,M){const x=new Array;if(!B&&!I)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const y=B?B.rB():I?I.rB():null;if(y){var f;const L=this._resizeTexturesToSameDimensions(B,I,y),e=null===(f=L.texture1)||void 0===f?void 0:f.getSize();let g,N;const R=e.width,H=e.height,F=await L.texture1.readPixels(),k=await L.texture2.readPixels();if(!F)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(g=d(F),!k)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");N=d(k);const q=N.byteLength,o=new Uint8Array(q),U=new Uint8Array(q),G=4,V=p;let c=0,t=0;for(let B=0;B<H;++B)for(let I=0;I<R;++I){const M=(R*B+I)*G,x={diffuseColor:new S.SI(g[M],g[M+1],g[M+2]).toLinearSpace(y.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new S.SI(N[M],N[M+1],N[M+2]).toLinearSpace(y.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:N[M+3]*C.glossiness},f=this._convertSpecularGlossinessToMetallicRoughness(x);V.r=Math.max(V.r,f.baseColor.r),V.g=Math.max(V.g,f.baseColor.g),V.b=Math.max(V.b,f.baseColor.b),c=Math.max(c,f.metallic),t=Math.max(t,f.roughness),U[M]=255*f.baseColor.r,U[M+1]=255*f.baseColor.g,U[M+2]=255*f.baseColor.b,U[M+3]=L.texture1.if?255*g[M+3]:255,o[M]=0,o[M+1]=255*f.roughness,o[M+2]=255*f.metallic,o[M+3]=255}const r={baseColor:V,metallic:c,roughness:t};let A=!1,J=!1;for(let B=0;B<H;++B)for(let I=0;I<R;++I){const C=(R*B+I)*G;U[C]/=r.baseColor.r>D?r.baseColor.r:1,U[C+1]/=r.baseColor.g>D?r.baseColor.g:1,U[C+2]/=r.baseColor.b>D?r.baseColor.b:1;const M=S.SI.FromInts(U[C],U[C+1],U[C+2]).toGammaSpace(y.getEngine().useExactSrgbConversions);U[C]=255*M.r,U[C+1]=255*M.g,U[C+2]=255*M.b,M.equalsWithEpsilon(u,D)||(J=!0),o[C+1]/=r.roughness>D?r.roughness:1,o[C+2]/=r.metallic>D?r.metallic:1;S.SI.FromInts(255,o[C+1],o[C+2]).equalsWithEpsilon(u,D)||(A=!0)}return A&&x.push(this._getImageDataAsync(o,R,H,M).then((B=>{r.metallicRoughnessTextureData=B}))),J&&x.push(this._getImageDataAsync(U,R,H,M).then((B=>{r.baseColorTextureData=B}))),await Promise.all(x).then((()=>r))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(B){const I=this._getPerceivedBrightness(B.diffuseColor),C=this._getPerceivedBrightness(B.specularColor),M=1-this._getMaxComponent(B.specularColor),x=n(I,C,M),y=B.diffuseColor.scale(M/(1-J.r)/Math.max(1-x)),f=B.specularColor.FI(J.scale(1-x)).scale(1/Math.max(x));let L=S.SI.Lerp(y,f,x*x);L=L.clampToRef(0,1,L);return{baseColor:L,metallic:x,roughness:1-B.glossiness}}_getPerceivedBrightness(B){return B?Math.sqrt(.299*B.r*B.r+.587*B.g*B.g+.114*B.b*B.b):0}_getMaxComponent(B){return B?Math.max(B.r,Math.max(B.g,B.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(B,I,C,M){const x=[],y={baseColor:B._albedoColor,metallic:B._metallic,roughness:B._roughness};if(M){B._albedoTexture&&x.push(this.exportTextureAsync(B._albedoTexture,I).then((B=>{B&&(C.baseColorTexture=B)})));const M=B._metallicTexture;M&&x.push(this.exportTextureAsync(M,I).then((B=>{B&&(C.metallicRoughnessTexture=B)})))}return x.length>0&&(this._exporter._materialNeedsUVsSet.add(B),await Promise.all(x)),y}_getTextureSampler(B){const I={};if(!B||!(B instanceof c.c))return I;const C=this._getGLTFTextureWrapMode(B.wrapU);10497!==C&&(I.wrapS=C);const M=this._getGLTFTextureWrapMode(B.wrapV);switch(10497!==M&&(I.wrapT=M),B.samplingMode){case c.c.LINEAR_LINEAR:I.magFilter=9729,I.minFilter=9729;break;case c.c.LINEAR_NEAREST:I.magFilter=9729,I.minFilter=9728;break;case c.c.NEAREST_LINEAR:I.magFilter=9728,I.minFilter=9729;break;case c.c.NEAREST_LINEAR_MIPLINEAR:I.magFilter=9728,I.minFilter=9987;break;case c.c.NEAREST_NEAREST:I.magFilter=9728,I.minFilter=9728;break;case c.c.NEAREST_LINEAR_MIPNEAREST:I.magFilter=9728,I.minFilter=9985;break;case c.c.LINEAR_NEAREST_MIPNEAREST:I.magFilter=9729,I.minFilter=9984;break;case c.c.LINEAR_NEAREST_MIPLINEAR:I.magFilter=9729,I.minFilter=9986;break;case c.c.NEAREST_NEAREST_MIPLINEAR:I.magFilter=9728,I.minFilter=9986;break;case c.c.LINEAR_LINEAR_MIPLINEAR:I.magFilter=9729,I.minFilter=9987;break;case c.c.LINEAR_LINEAR_MIPNEAREST:I.magFilter=9729,I.minFilter=9985;break;case c.c.NEAREST_NEAREST_MIPNEAREST:I.magFilter=9728,I.minFilter=9984}return I}_getGLTFTextureWrapMode(B){switch(B){case c.c.WRAP_ADDRESSMODE:return 10497;case c.c.CLAMP_ADDRESSMODE:return 33071;case c.c.MIRROR_ADDRESSMODE:return 33648;default:return x.Tools.Error(`Unsupported Texture Wrap Mode ${B}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(B,I,C,M){const x={diffuseColor:B._albedoColor,specularColor:B._reflectivityColor,glossiness:B._microSurface},y=B._albedoTexture,f=B._reflectivityTexture,L=B._useMicroSurfaceFromReflectivityMapAlpha;if(f&&!L)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((y||f)&&M){this._exporter._materialNeedsUVsSet.add(B);const M=this._exportTextureSampler(y||f),L=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(y,f,x,I),e=this._exporter._textures;if(L.baseColorTextureData){const B=this._exportImage(`baseColor${e.length}`,I,L.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(B,M,null===y||void 0===y?void 0:y.coordinatesIndex)}if(L.metallicRoughnessTextureData){const B=this._exportImage(`metallicRoughness${e.length}`,I,L.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(B,M,null===f||void 0===f?void 0:f.coordinatesIndex)}return L}return this._convertSpecularGlossinessToMetallicRoughness(x)}async exportPBRMaterialAsync(B,I,C){const M={},x={name:B.name},y=B.isMetallicWorkflow();if(y){const I=B._albedoColor,C=B.alpha;I&&(M.baseColorFactor=[I.r,I.g,I.b,C])}const f=y?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(B,I,M,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(B,I,M,C);await this._setMetallicRoughnessPbrMaterialAsync(f,B,x,M,I,C),await this._finishMaterialAsync(x,B,I);const L=this._exporter._materials;return L.push(x),L.length-1}async _setMetallicRoughnessPbrMaterialAsync(B,I,C,M,y,f){if(a(C,I),B.baseColor.equalsWithEpsilon(u,D)&&G.WithinEpsilon(I.alpha,1,D)||(M.baseColorFactor=[B.baseColor.r,B.baseColor.g,B.baseColor.b,I.alpha]),null!=B.metallic&&1!==B.metallic&&(M.metallicFactor=B.metallic),null!=B.roughness&&1!==B.roughness&&(M.roughnessFactor=B.roughness),null==I.Yf||I.Yf||(I._twoSidedLighting||x.Tools.Warn(I.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),f){const B=[],M=I._bumpTexture;M&&B.push(this.exportTextureAsync(M,y).then((B=>{B&&(C.normalTexture=B,1!==M.level&&(C.normalTexture.scale=M.level))})));const x=I._ambientTexture;x&&B.push(this.exportTextureAsync(x,y).then((B=>{if(B){const M={index:B.index,texCoord:B.texCoord,extensions:B.extensions};C.occlusionTexture=M;const x=I._ambientTextureStrength;x&&(M.strength=x)}})));const f=I._emissiveTexture;f&&B.push(this.exportTextureAsync(f,y).then((B=>{B&&(C.emissiveTexture=B)}))),B.length>0&&(this._exporter._materialNeedsUVsSet.add(I),await Promise.all(B))}const L=I._emissiveColor;L.equalsWithEpsilon(p,D)||(C.emissiveFactor=L.Df()),C.pbrMetallicRoughness=M}_getPixelsFromTextureAsync(B){return function(B){switch(B){case r.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case r.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case r.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case r.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case r.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case r.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case r.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case r.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case r.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case r.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case r.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case r.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case r.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(B.textureFormat)?(0,V.j)(B,B._texture.width,B._texture.height):(B.textureType,r.b.TEXTURETYPE_UNSIGNED_BYTE,B.readPixels())}async exportTextureAsync(B,I){const C=this._exporter._extensionsPreExportTextureAsync("exporter",B,I);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,I):await this._exportTextureInfoAsync(B,I))):await this._exportTextureInfoAsync(B,I)}async _exportTextureInfoAsync(B,I){let C=this._textureMap.get(B);if(!C){const M=await this._getPixelsFromTextureAsync(B);if(!M)return null;const y=this._exportTextureSampler(B),f=B.mimeType;if(f)switch(f){case"image/jpeg":case"image/png":case"image/webp":I=f;break;default:x.Tools.Warn(`Unsupported media type: ${f}. Exporting texture as PNG.`)}const L=this._internalTextureToImage,e=B.getInternalTexture().uniqueId;L[e]||(L[e]={});let g=L[e][I];if(void 0===g){const C=B.getSize();g=(async()=>{const x=await this._getImageDataAsync(M,C.width,C.height,I);return this._exportImage(B.name,I,x)})(),L[e][I]=g}C=this._exportTextureInfo(await g,y,B.coordinatesIndex),this._textureMap.set(B,C),this._exporter._extensionsPostExportTextures("exporter",C,B)}return C}_exportImage(B,I,C){const M=this._exporter._images;let y;if(this._exporter._shouldUseGlb){y={name:B,mimeType:I,bufferView:void 0};const M=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(y,M)}else{const f=B.replace(/\.\/|\/|\.\\|\\/g,"_"),L=function(B){switch(B){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(I);let e=f+L;M.some((B=>B.uri===e))&&(e=`${f}_${x.Tools.RandomId()}${L}`),y={name:B,uri:e},this._exporter._imageData[e]={data:C,mimeType:I}}return M.push(y),M.length-1}_exportTextureInfo(B,I,C){const M=this._exporter._textures;let x=M.findIndex((C=>C.sampler==I&&C.source===B));-1===x&&(x=M.length,M.push({source:B,sampler:I}));const y={index:x};return C&&(y.texCoord=C),y}_exportTextureSampler(B){const I=this._getTextureSampler(B),C=this._exporter._samplers,M=C.findIndex((B=>B.minFilter===I.minFilter&&B.magFilter===I.magFilter&&B.wrapS===I.wrapS&&B.wrapT===I.wrapT));return-1!==M?M:(C.push(I),C.length-1)}}var E=C(11284),Q=C(11027),Z=C(11671),z=C(11197);const b=M.HI.Zero(),Y=M.Quaternion.Identity(),v=M.HI.One(),s=new M.HI(-1,1,1);function X(B,I){const{byteOffset:C,byteStride:M,type:x,normalized:y}=B,f=B.getSize(),L=I.reduce(((B,I)=>I.getTotalVertices()>B?I.getTotalVertices():B),-Number.MAX_VALUE);return{byteOffset:C,byteStride:M,componentCount:f,type:x,count:L*f,normalized:y,totalVertices:L,kind:B.getKind()}}function T(B){switch(B){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function P(B){switch(B){case N.g.PositionKind:case N.g.NormalKind:case N.g.TangentKind:case N.g.ColorKind:case N.g.MatricesIndicesKind:case N.g.MatricesIndicesExtraKind:case N.g.MatricesWeightsKind:case N.g.MatricesWeightsExtraKind:case N.g.UVKind:case N.g.UV2Kind:case N.g.UV3Kind:case N.g.UV4Kind:case N.g.UV5Kind:case N.g.UV6Kind:return!0}return!1}function h(B){switch(B){case y.c.TriangleFillMode:return 4;case y.c.TriangleStripDrawMode:return 5;case y.c.TriangleFanDrawMode:return 6;case y.c.PointListDrawMode:case y.c.PointFillMode:return 0;case y.c.LineLoopDrawMode:return 2;case y.c.LineListDrawMode:return 1;case y.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${B}`)}function j(B){const I=Math.sqrt(B.x*B.x+B.y*B.y+B.z*B.z);I>0&&(B.x/=I,B.y/=I,B.z/=I)}function w(B){return B.x*=-1,B}function K(B){if(B.x*B.x+B.y*B.y>.5){const I=Math.abs(B.x),C=Math.abs(B.y);if(I>C){const C=Math.sign(B.x);B.x=I,B.y*=-C,B.z*=-C,B.w*=C}else{const I=Math.sign(B.y);B.x*=-I,B.y=C,B.z*=I,B.w*=-I}}else{const I=Math.abs(B.z),C=Math.abs(B.w);if(I>C){const C=Math.sign(B.z);B.x*=-C,B.y*=C,B.z=I,B.w*=-C}else{const I=Math.sign(B.w);B.x*=I,B.y*=-I,B.z*=-I,B.w=C}}return B}function m(B){B.vf(-B.z,B.w,B.x,-B.y)}function BB(B,I){const C=M.HI.FromArrayToRef(I.translation||[0,0,0],0,M.TmpVectors.HI[0]),x=M.Quaternion.FromArrayToRef(I.rotation||[0,0,0,1],0,M.TmpVectors.Quaternion[0]),y=M.Matrix.ComposeToRef(v,x,C,M.TmpVectors.Matrix[0]),f=M.HI.FromArrayToRef(B.translation||[0,0,0],0,M.TmpVectors.HI[2]),L=M.Quaternion.FromArrayToRef(B.rotation||[0,0,0,1],0,M.TmpVectors.Quaternion[1]),e=M.Matrix.ComposeToRef(v,L,f,M.TmpVectors.Matrix[1]);y.multiplyToRef(e,e),e.decompose(void 0,x,C),C.equalsWithEpsilon(b,z.d)?delete I.translation:I.translation=C.Df(),x.equalsWithEpsilon(Y,z.d)?delete I.rotation:I.rotation=x.Df(),I.scale&&delete I.scale}function IB(B,I){if(!(I instanceof R.d))return!1;if(!(1===I.getChildren().length&&0===B.getChildren().length&&B.parent===I))return!1;const C=B.rB(),M=B instanceof Z.e&&!C.useRightHandedSystem?s:v;return!!I.Xf.equalsWithEpsilon(M,z.d)||(Q.b.Warn(`Cannot collapse node ${B.name} into parent node ${I.name} with modified scaling.`),!1)}function CB(B){if(B instanceof Array){const I=new Float32Array(B);return new Uint8Array(I.buffer,I.byteOffset,I.byteLength)}return ArrayBuffer.isView(B)?new Uint8Array(B.buffer,B.byteOffset,B.byteLength):new Uint8Array(B)}function MB(B,I){for(const[C,M]of Object.entries(B)){const x=I[C];(Array.isArray(M)&&Array.isArray(x)&&xB(M,x)||M===x)&&delete B[C]}return B}function xB(B,I){return B.length===I.length&&B.every(((B,C)=>B===I[C]))}const yB=M.Matrix.Compose(new M.HI(-1,1,1),M.Quaternion.Identity(),M.HI.Zero());function fB(B,I){if(!(B instanceof R.d))return!1;if(I){if(!B.getWorldMatrix().equalsWithEpsilon(M.Matrix.IdentityReadOnly,z.d))return!1}else{if(!B.getWorldMatrix().multiplyToRef(yB,M.TmpVectors.Matrix[0]).equalsWithEpsilon(M.Matrix.IdentityReadOnly,z.d))return!1}return!(B instanceof H.e&&B.zf)}const LB=new Map([[Int8Array,(B,I,C)=>B.setInt8(I,C)],[Uint8Array,(B,I,C)=>B.setUint8(I,C)],[Uint8ClampedArray,(B,I,C)=>B.setUint8(I,C)],[Int16Array,(B,I,C)=>B.setInt16(I,C,!0)],[Uint16Array,(B,I,C)=>B.setUint16(I,C,!0)],[Int32Array,(B,I,C)=>B.setInt32(I,C,!0)],[Uint32Array,(B,I,C)=>B.setUint32(I,C,!0)],[Float32Array,(B,I,C)=>B.setFloat32(I,C,!0)],[Float64Array,(B,I,C)=>B.setFloat64(I,C,!0)]]);class eB{writeTypedArray(B){this._checkGrowBuffer(B.byteLength);const I=LB.get(B.constructor);for(let C=0;C<B.length;C++)I(this._dataView,this._byteOffset,B[C]),this._byteOffset+=B.BYTES_PER_ELEMENT}constructor(B){this._data=new Uint8Array(B),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(B){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,B),this._byteOffset++}writeInt8(B){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,B),this._byteOffset++}writeInt16(B){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,B,!0),this._byteOffset+=2}writeUInt16(B){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,B,!0),this._byteOffset+=2}writeInt32(B){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,B,!0),this._byteOffset+=4}writeUInt32(B){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat32(B){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,B,!0),this._byteOffset+=4}writeFloat64(B){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,B,!0),this._byteOffset+=8}_checkGrowBuffer(B){const I=this.byteOffset+B;if(I>this._data.byteLength){const B=new Uint8Array(2*I);B.set(this._data),this._data=B,this._dataView=new DataView(this._data.buffer)}}}function gB(B){return B%4===0?4:B%2===0?2:1}class NB{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(B){let I=0;this._bufferViewToData.forEach((B=>{I+=B.byteLength}));const C=new eB(I),M=Array.from(this._bufferViewToData.keys()).sort(((B,I)=>gB(I.byteLength)-gB(B.byteLength)));for(const x of M){x.byteOffset=C.byteOffset,B.push(x);const I=B.length-1,M=this.getPropertiesWithBufferView(x);for(const B of M)B.bufferView=I;C.writeTypedArray(this._bufferViewToData.get(x)),this._bufferViewToData.delete(x)}return C.getOutputData()}createBufferView(B,I){const C={buffer:0,byteOffset:void 0,byteLength:B.byteLength,byteStride:I};return this._bufferViewToData.set(C,B),C}createAccessor(B,I,C,M,x,y,f){this._verifyBufferView(B);const L={bufferView:void 0,componentType:C,count:M,type:I,min:null===y||void 0===y?void 0:y.min,max:null===y||void 0===y?void 0:y.max,normalized:f,byteOffset:x};return this.setBufferView(L,B),this._accessorToBufferView.set(L,B),L}setBufferView(B,I){this._verifyBufferView(I);this.getPropertiesWithBufferView(I).push(B)}removeBufferView(B){const I=this.getPropertiesWithBufferView(B);for(const C of I)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(B),this._bufferViewToProperties.delete(B),this._accessorToBufferView.forEach(((I,C)=>{I===B&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(B){const I=this._accessorToBufferView.get(B);return this._verifyBufferView(I),I}getPropertiesWithBufferView(B){return this._verifyBufferView(B),this._bufferViewToProperties.set(B,this._bufferViewToProperties.get(B)??[]),this._bufferViewToProperties.get(B)}getData(B){return this._verifyBufferView(B),this._bufferViewToData.get(B)}_verifyBufferView(B){if(void 0===B||!this._bufferViewToData.has(B))throw new Error(`BufferView ${B} not found in BufferManager.`)}}var RB,HB=C(11647),FB=C(11657),kB=C(11677),qB=C(11573),SB=C(11708),oB=C(11720),UB=C(11645),GB=C(11725);!function(B){B[B.INTANGENT=0]="INTANGENT",B[B.OUTTANGENT=1]="OUTTANGENT"}(RB||(RB={}));class VB{static _IsTransformable(B){return B&&(B instanceof R.d||B instanceof HB.e||B instanceof GB.c)}static _CreateNodeAnimation(B,I,C,M,y){if(this._IsTransformable(B)){const f=[],L=[],e=I.getKeys(),g=VB._CalculateMinMaxKeyFrames(e),N=VB._DeduceInterpolation(e,C,M),R=N.interpolationType,H=N.shouldBakeAnimation;if(H?VB._CreateBakedAnimation(B,I,C,g.min,g.max,I.framePerSecond,y,f,L,g,M):"LINEAR"===R||"STEP"===R?VB._CreateLinearOrStepAnimation(B,I,C,f,L,M):"CUBICSPLINE"===R?VB._CreateCubicSplineAnimation(B,I,C,f,L,M):VB._CreateBakedAnimation(B,I,C,g.min,g.max,I.framePerSecond,y,f,L,g,M),f.length&&L.length){return{inputs:f,outputs:L,samplerInterpolation:R,inputsMin:H?g.min:x.Tools.FloatRound(g.min/I.framePerSecond),inputsMax:H?g.max:x.Tools.FloatRound(g.max/I.framePerSecond)}}}return null}static _DeduceAnimationInfo(B){let I=null,C="VEC3",M=!1;const y=B.targetProperty.split(".");switch(y[0]){case"Xf":I="scale";break;case"position":I="translation";break;case"rotation":C="VEC4",I="rotation";break;case"rotationQuaternion":C="VEC4",M=!0,I="rotation";break;case"influence":C="SCALAR",I="weights";break;default:x.Tools.Error(`Unsupported animatable property ${y[0]}`)}return I?{animationChannelTargetPath:I,dataAccessorType:C,useQuaternion:M}:(x.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(B,I,C,M,x,y,f,L,e,g,N){let R;if(VB._IsTransformable(B)&&B.animations)for(const H of B.animations){if(N&&!N(H))continue;const x=VB._DeduceAnimationInfo(H);x&&(R={name:H.name,samplers:[],channels:[]},VB._AddAnimation(`${H.name}`,H.hasRunningRuntimeAnimations?I:R,B,H,x.dataAccessorType,x.animationChannelTargetPath,M,y,f,L,x.useQuaternion,e,g),R.samplers.length&&R.channels.length&&C.push(R))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(B,I,C,M,x,y,f,L,e,g,N){let R;if(B instanceof UB.b){const x=B.morphTargetManager;if(x)for(let H=0;H<x.numTargets;++H){const F=x.getTarget(H);for(const k of F.animations){if(N&&!N(k))continue;const F=new SB.c(`${k.name}`,"influence",k.framePerSecond,k.dataType,k.loopMode,k.enableBlending),q=[],S=k.getKeys();for(let B=0;B<S.length;++B){const I=S[B];for(let B=0;B<x.numTargets;++B)B==H?q.push(I):q.push({frame:I.frame,value:0})}F.setKeys(q);const o=VB._DeduceAnimationInfo(F);o&&(R={name:F.name,samplers:[],channels:[]},VB._AddAnimation(k.name,k.hasRunningRuntimeAnimations?I:R,B,F,o.dataAccessorType,o.animationChannelTargetPath,M,y,f,L,o.useQuaternion,e,g,x.numTargets),R.samplers.length&&R.channels.length&&C.push(R))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(B,I,C,M,x,y,f,L,e){let g;if(B.animationGroups){const R=B.animationGroups;for(const H of R){const R=new Map,F=new Map,k=new Set,q=H.to-H.from;g={name:H.name,channels:[],samplers:[]};for(let I=0;I<H.targetedAnimations.length;++I){const q=H.targetedAnimations[I],S=q.target,o=q.animation;if(e&&!e(o))continue;const U=L.has(S);if(this._IsTransformable(S)||1===S.length&&this._IsTransformable(S[0])){const B=VB._DeduceAnimationInfo(q.animation);if(B){const I=this._IsTransformable(S)?S:this._IsTransformable(S[0])?S[0]:null;I&&VB._AddAnimation(`${o.name}`,g,I,o,B.dataAccessorType,B.animationChannelTargetPath,C,M,x,y,B.useQuaternion,f,U)}}else if(S instanceof oB.b||1===S.length&&S[0]instanceof oB.b){if(VB._DeduceAnimationInfo(q.animation)){const I=S instanceof oB.b?S:S[0];if(I){const C=B.morphTargetManagers.find((B=>{for(let C=0;C<B.numTargets;++C)if(B.getTarget(C)===I)return!0;return!1}));if(C){const M=B.meshes.find((B=>B.morphTargetManager===C));var N;if(M)R.has(M)||R.set(M,new Map),null===(N=R.get(M))||void 0===N||N.set(I,o),k.add(M),F.set(M,o)}}}}}k.forEach((B=>{const I=B.morphTargetManager;let L=null;const e=[],N=F.get(B).getKeys(),k=N.length;for(let C=0;C<k;++C)for(let M=0;M<I.numTargets;++M){const x=I.getTarget(M),y=R.get(B);if(y){const I=y.get(x);I?(L||(L=new SB.c(`${H.name}_${B.name}_MorphWeightAnimation`,"influence",I.framePerSecond,SB.c.ANIMATIONTYPE_FLOAT,I.loopMode,I.enableBlending)),e.push(I.getKeys()[C])):e.push({frame:H.from+q/k*C,value:x.influence,inTangent:N[0].inTangent?0:void 0,outTangent:N[0].outTangent?0:void 0})}}L.setKeys(e);const S=VB._DeduceAnimationInfo(L);S&&VB._AddAnimation(`${H.name}_${B.name}_MorphWeightAnimation`,g,B,L,S.dataAccessorType,S.animationChannelTargetPath,C,M,x,y,S.useQuaternion,f,!1,null===I||void 0===I?void 0:I.numTargets)})),g.channels.length&&g.samplers.length&&I.push(g)}}}static _AddAnimation(B,I,C,x,y,f,L,e,g,N,R,H,F,k){const q=VB._CreateNodeAnimation(C,x,f,R,H);let S,o,U,G,V,c;if(q){if(k){let B=0,I=0;const C=[];for(;q.inputs.length>0;)I=q.inputs.shift(),B%k==0&&C.push(I),B++;q.inputs=C}const B=L.get(C),x=new Float32Array(q.inputs);S=e.createBufferView(x),o=e.createAccessor(S,"SCALAR",5126,q.inputs.length,void 0,{min:[q.inputsMin],max:[q.inputsMax]}),N.push(o),U=N.length-1;const g=new M.Quaternion,R=new M.HI,H=new M.HI,t=C instanceof HB.e,r=T(y),A=new Float32Array(q.outputs.length*r);q.outputs.forEach((function(B,I){let C=B;switch(f){case"translation":F&&(M.HI.FromArrayToRef(B,0,H),w(H),H.toArray(C));break;case"rotation":4===B.length?M.Quaternion.FromArrayToRef(B,0,g):(C=new Array(4),M.HI.FromArrayToRef(B,0,R),M.Quaternion.FromEulerVectorToRef(R,g)),F&&(K(g),t&&m(g)),g.toArray(C)}A.set(C,I*r)})),S=e.createBufferView(A),o=e.createAccessor(S,y,5126,q.outputs.length),N.push(o),G=N.length-1,V={interpolation:q.samplerInterpolation,input:U,output:G},I.samplers.push(V),c={sampler:I.samplers.length-1,target:{node:B,path:f}},I.channels.push(c)}}static _CreateBakedAnimation(B,I,C,y,f,L,e,g,N,R,H){let F;const k=M.Quaternion.Identity();let q,S=null,o=null,U=null,G=null,V=null,c=null;R.min=x.Tools.FloatRound(y/L);const t=I.getKeys();for(let M=0,r=t.length;M<r;++M){if(c=null,U=t[M],M+1<r)if(G=t[M+1],U.value.equals&&U.value.equals(G.value)||U.value===G.value){if(0!==M)continue;c=U.frame}else c=G.frame;else{if(V=t[M-1],U.value.equals&&U.value.equals(V.value)||U.value===V.value)continue;c=f}if(c)for(let M=U.frame;M<=c;M+=e){if(q=x.Tools.FloatRound(M/L),q===S)continue;S=q,o=q;const y={key:0,repeatCount:0,loopMode:I.loopMode};F=I._interpolate(M,y),VB._SetInterpolatedValue(B,F,q,I,C,k,g,N,H)}}o&&(R.max=o)}static _ConvertFactorToVector3OrQuaternion(B,I,C,y,f){const L=VB._GetBasePositionRotationOrScale(I,y,f),e=C.targetProperty.split("."),g=e?e[1]:"",N=f?M.Quaternion.oI(L).normalize():M.HI.oI(L);switch(g){case"x":case"y":case"z":N[g]=B;break;case"w":N.w=B;break;default:x.Tools.Error(`glTFAnimation: Unsupported component name "${g}"!`)}return N}static _SetInterpolatedValue(B,I,C,x,y,f,L,e,g){let N;L.push(C),"weights"!==y?(x.dataType===SB.c.ANIMATIONTYPE_FLOAT&&(I=this._ConvertFactorToVector3OrQuaternion(I,B,x,y,g)),"rotation"===y?(g?f=I:(N=I,M.Quaternion.RotationYawPitchRollToRef(N.y,N.x,N.z,f)),e.push(f.Df())):(N=I,e.push(N.Df()))):e.push([I])}static _CreateLinearOrStepAnimation(B,I,C,M,x,y){for(const f of I.getKeys())M.push(f.frame/I.framePerSecond),VB._AddKeyframeValue(f,I,x,C,B,y)}static _CreateCubicSplineAnimation(B,I,C,M,x,y){I.getKeys().forEach((function(f){M.push(f.frame/I.framePerSecond),VB._AddSplineTangent(RB.INTANGENT,x,C,"CUBICSPLINE",f,y),VB._AddKeyframeValue(f,I,x,C,B,y),VB._AddSplineTangent(RB.OUTTANGENT,x,C,"CUBICSPLINE",f,y)}))}static _GetBasePositionRotationOrScale(B,I,C){let x;if("rotation"===I)if(C){x=(B.rotationQuaternion??M.Quaternion.Identity()).Df()}else{x=(B.rotation??M.HI.Zero()).Df()}else if("translation"===I){x=(B.position??M.HI.Zero()).Df()}else{x=(B.Xf??M.HI.One()).Df()}return x}static _AddKeyframeValue(B,I,C,y,f,L){let e;const g=I.dataType;if(g===SB.c.ANIMATIONTYPE_VECTOR3){let I=B.value.Df();if("rotation"===y){const B=M.HI.oI(I);I=M.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).Df()}C.push(I)}else if(g===SB.c.ANIMATIONTYPE_FLOAT){if("weights"===y)C.push([B.value]);else if(e=this._ConvertFactorToVector3OrQuaternion(B.value,f,I,y,L),e){if("rotation"===y){const B=L?e:M.Quaternion.RotationYawPitchRoll(e.y,e.x,e.z).normalize();C.push(B.Df())}C.push(e.Df())}}else g===SB.c.ANIMATIONTYPE_QUATERNION?C.push(B.value.normalize().Df()):x.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(B,I,C){let M,x,y=!1;if("rotation"===I&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let f=0,L=B.length;f<L;++f)if(x=B[f],x.inTangent||x.outTangent)if(M){if("CUBICSPLINE"!==M){M="LINEAR",y=!0;break}}else M="CUBICSPLINE";else if(M){if("CUBICSPLINE"===M||x.interpolation&&1===x.interpolation&&"STEP"!==M){M="LINEAR",y=!0;break}}else M=x.interpolation&&1===x.interpolation?"STEP":"LINEAR";return M||(M="LINEAR"),{interpolationType:M,shouldBakeAnimation:y}}static _AddSplineTangent(B,I,C,x,y,f){let L;const e=B===RB.INTANGENT?y.inTangent:y.outTangent;if("CUBICSPLINE"===x){if("rotation"===C)if(e)if(f)L=e.Df();else{const B=e;L=M.Quaternion.RotationYawPitchRoll(B.y,B.x,B.z).Df()}else L=[0,0,0,0];else L="weights"===C?e?[e]:[0]:e?e.Df():[0,0,0];I.push(L)}}static _CalculateMinMaxKeyFrames(B){let I=1/0,C=-1/0;return B.forEach((function(B){I=Math.min(I,B.frame),C=Math.max(C,B.frame)})),{min:I,max:C}}}function cB(B,I,C,y,f,L){const e={attributes:{},influence:B.influence,name:B.name},g=I.zf;if(!g)return x.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),e;const R=L?-1:1,H=M.HI.Zero();let F=0,k=0;if(B.hasPositions){const y=B.getPositions(),L=g.getVerticesData(N.g.PositionKind);if(L){const B=new Float32Array(L.length),I=[1/0,1/0,1/0],x=[-1/0,-1/0,-1/0];k=L.length/3,F=0;for(let C=F;C<k;++C){const f=M.HI.oI(L,3*C);M.HI.oI(y,3*C).subtractToRef(f,H),H.x*=R,I[0]=Math.min(I[0],H.x),x[0]=Math.max(x[0],H.x),I[1]=Math.min(I[1],H.y),x[1]=Math.max(x[1],H.y),I[2]=Math.min(I[2],H.z),x[2]=Math.max(x[2],H.z),B[3*C]=H.x,B[3*C+1]=H.y,B[3*C+2]=H.z}const g=C.createBufferView(B,12),N=C.createAccessor(g,"VEC3",5126,y.length/3,0,{min:I,max:x});f.push(N),e.attributes.POSITION=f.length-1}else x.Tools.Warn(`Morph target positions for mesh ${I.name} were not exported. Mesh does not have position vertex data`)}if(B.hasNormals){const y=B.getNormals(),L=g.getVerticesData(N.g.NormalKind);if(L){const B=new Float32Array(L.length);k=L.length/3,F=0;for(let C=F;C<k;++C){const I=M.HI.oI(L,3*C).normalize();M.HI.oI(y,3*C).normalize().subtractToRef(I,H),B[3*C]=H.x*R,B[3*C+1]=H.y,B[3*C+2]=H.z}const I=C.createBufferView(B,12),x=C.createAccessor(I,"VEC3",5126,y.length/3,0);f.push(x),e.attributes.NORMAL=f.length-1}else x.Tools.Warn(`Morph target normals for mesh ${I.name} were not exported. Mesh does not have normals vertex data`)}if(B.hasTangents){const y=B.getTangents(),L=g.getVerticesData(N.g.TangentKind);if(L){k=L.length/4;const B=new Float32Array(3*k);F=0;for(let C=F;C<k;++C){const I=M.HI.oI(L,4*C);j(I);const x=M.HI.oI(y,3*C);j(x),x.subtractToRef(I,H),B[3*C]=H.x*R,B[3*C+1]=H.y,B[3*C+2]=H.z}const I=C.createBufferView(B,12),x=C.createAccessor(I,"VEC3",5126,k,0);f.push(x),e.attributes.TANGENT=f.length-1}else x.Tools.Warn(`Morph target tangents for mesh ${I.name} were not exported. Mesh does not have tangents vertex data`)}if(B.hasColors){const y=B.getColors(),L=g.getVerticesData(N.g.ColorKind),R=g.getVertexBuffer(N.g.ColorKind);if(L&&R){const B=R.getSize();k=L.length/B;const I=new Float32Array(k*B);F=0;for(let C=F;C<k;++C)if(3===B){const x=M.HI.oI(L,C*B);M.HI.oI(y,C*B).subtractToRef(x,H),I[3*C]=H.x,I[3*C+1]=H.y,I[3*C+2]=H.z}else if(4===B){const x=new M.Vector4,f=M.Vector4.oI(L,C*B);M.Vector4.oI(y,C*B).subtractToRef(f,x),I[4*C]=x.x,I[4*C+1]=x.y,I[4*C+2]=x.z,I[4*C+3]=x.w}else x.Tools.Warn(`Unsupported number of components for color attribute: ${B}`);const g=C.createBufferView(I,4*B),N=C.createAccessor(g,3===B?"VEC3":"VEC4",5126,k,0);f.push(N),e.attributes.COLOR_0=f.length-1}else x.Tools.Warn(`Morph target colors for mesh ${I.name} were not exported. Mesh does not have colors vertex data`)}return e}var tB=C(11730),rB=C(11601),AB=C(11586),DB=C(11149);class JB{}JB.DEFAULT_COLOR=S.SI.White(),JB.DEFAULT_WIDTH_ATTENUATED=1,JB.DEFAULT_WIDTH=.1;var iB=C(11409),uB=C(11733);class pB{static ConvertPoints(B,I){if(B.length&&Array.isArray(B)&&"number"===typeof B[0])return[B];if(B.length&&Array.isArray(B[0])&&"number"===typeof B[0][0])return B;if(B.length&&!Array.isArray(B[0])&&B[0]instanceof M.HI){const I=[];for(let C=0;C<B.length;C++){const M=B[C];I.push(M.x,M.y,M.z)}return[I]}if(B.length>0&&Array.isArray(B[0])&&B[0].length>0&&B[0][0]instanceof M.HI){const I=[],C=B;for(const B of C)I.push(B.flatMap((B=>[B.x,B.y,B.z])));return I}if(B instanceof Float32Array){if(null!==I&&void 0!==I&&I.floatArrayStride){const C=[],M=3*I.floatArrayStride;for(let I=0;I<B.length;I+=M){const x=new Array(M);for(let C=0;C<M;C++)x[C]=B[I+C];C.push(x)}return C}return[Array.from(B)]}if(B.length&&B[0]instanceof Float32Array){const I=[];for(const C of B)I.push(Array.from(C));return I}return[]}static OmitZeroLengthPredicate(B,I,C){const M=[];return I.FI(B).lengthSquared()>0&&M.push([B,I]),C.FI(I).lengthSquared()>0&&M.push([I,C]),B.FI(C).lengthSquared()>0&&M.push([C,B]),0===M.length?null:M}static OmitDuplicatesPredicate(B,I,C,M){const x=[];return pB._SearchInPoints(B,I,M)||x.push([B,I]),pB._SearchInPoints(I,C,M)||x.push([I,C]),pB._SearchInPoints(C,B,M)||x.push([C,B]),0===x.length?null:x}static _SearchInPoints(B,I,C){for(const f of C)for(let C=0;C<f.length;C++){var M,x,y;if(null!==(M=f[C])&&void 0!==M&&M.equals(B))if(null!==(x=f[C+1])&&void 0!==x&&x.equals(I)||null!==(y=f[C-1])&&void 0!==y&&y.equals(I))return!0}return!1}static MeshesToLines(B,I){const C=[];for(let x=0;x<B.length;x++){const y=B[x],f=y.getVerticesData(N.g.PositionKind),L=y.bf();if(f&&L)for(let B=0,e=0;B<L.length;B++){const g=3*L[e++],N=3*L[e++],R=3*L[e++],H=new M.HI(f[g],f[g+1],f[g+2]),F=new M.HI(f[N],f[N+1],f[N+2]),k=new M.HI(f[R],f[R+1],f[R+2]);if(I){const M=I(H,F,k,C,B,g,y,x,f,L);if(M)for(const B of M)C.push(B)}else C.push([H,F],[F,k],[k,H])}}return C}static ToVector3Array(B){if(Array.isArray(B[0])){const I=[],C=B;for(const B of C){const C=[];for(let I=0;I<B.length;I+=3)C.push(new M.HI(B[I],B[I+1],B[I+2]));I.push(C)}return I}const I=B,C=[];for(let x=0;x<I.length;x+=3)C.push(new M.HI(I[x],I[x+1],I[x+2]));return C}static ToNumberArray(B){return B.flatMap((B=>[B.x,B.y,B.z]))}static GetPointsCountInfo(B){const I=new Array(B.length);let C=0;for(let M=B.length;M--;)I[M]=B[M].length/3,C+=I[M];return{total:C,counts:I}}static GetLineLength(B){if(0===B.length)return 0;let I;I="number"===typeof B[0]?pB.ToVector3Array(B):B;const C=M.TmpVectors.HI[0];let x=0;for(let M=0;M<I.length-1;M++){const B=I[M];x+=I[M+1].subtractToRef(B,C).length()}return x}static GetLineLengthArray(B){const I=new Float32Array(B.length/3);let C=0;for(let M=0,x=B.length/3-1;M<x;M++){let x=B[3*M+0],y=B[3*M+1],f=B[3*M+2];x-=B[3*M+3],y-=B[3*M+4],f-=B[3*M+5];C+=Math.sqrt(x*x+y*y+f*f),I[M+1]=C}return I}static SegmentizeSegmentByCount(B,I,C){const x=[],y=I.FI(B),f=M.TmpVectors.HI[0];f.Tf(C);const L=M.TmpVectors.HI[1];y.divideToRef(f,L);let e=B.clone();x.push(e);for(let M=0;M<C;M++)e=e.clone(),x.push(e.addInPlace(L));return x}static SegmentizeLineBySegmentLength(B,I){const C=B[0]instanceof M.HI?pB.GetLineSegments(B):"number"===typeof B[0]?pB.GetLineSegments(pB.ToVector3Array(B)):B,x=[];for(const M of C)if(M.length>I){const B=pB.SegmentizeSegmentByCount(M.point1,M.point2,Math.ceil(M.length/I));for(const I of B)x.push(I)}else x.push(M.point1),x.push(M.point2);return x}static SegmentizeLineBySegmentCount(B,I){const C="number"===typeof B[0]?pB.ToVector3Array(B):B,M=pB.GetLineLength(C)/I;return pB.SegmentizeLineBySegmentLength(C,M)}static GetLineSegments(B){const I=[];for(let C=0;C<B.length-1;C++){const M=B[C],x=B[C+1],y=x.FI(M).length();I.push({point1:M,point2:x,length:y})}return I}static GetMinMaxSegmentLength(B){const I=pB.GetLineSegments(B).sort((B=>B.length));return{min:I[0].length,max:I[I.length-1].length}}static GetPositionOnLineByVisibility(B,I,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const y=I*C;let f=0,L=0;const e=B.length;for(let M=0;M<e;M++){if(y<=f+B[M].length){L=M;break}f+=B[M].length}const g=(y-f)/B[L].length;return B[L].point2.subtractToRef(B[L].point1,M.TmpVectors.HI[0]),M.TmpVectors.HI[1]=M.TmpVectors.HI[0].multiplyByFloats(g,g,g),x||M.TmpVectors.HI[1].addInPlace(B[L].point1),M.TmpVectors.HI[1].clone()}static GetCircleLinePoints(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:B,y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/I;const f=[];for(let L=0;L<=I;L++)f.push(new M.HI(Math.cos(L*y)*B,Math.sin(L*y)*x,C));return f}static GetBezierLinePoints(B,I,C,M){return iB.g.CreateQuadraticBezier(B,I,C,M).getPoints().flatMap((B=>[B.x,B.y,B.z]))}static GetArrowCap(B,I,C,M,x){let y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,f=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[B.clone(),B.add(I.multiplyByFloats(C,C,C))],widths:[M,x,y,f]}}static GetPointsFromText(B,I,C,M){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const f=[],L=(0,uB.c)(B,I,C,M);for(const e of L){for(const B of e.paths){const I=[],C=B.getPoints();for(const B of C)I.push(B.x,B.y,x);f.push(I)}if(y)for(const B of e.holes){const I=[],C=B.getPoints();for(const B of C)I.push(B.x,B.y,x);f.push(I)}}return f}static Color3toRGBAUint8(B){const I=new Uint8Array(4*B.length);for(let C=0,M=0;C<B.length;C++)I[M++]=255*B[C].r,I[M++]=255*B[C].g,I[M++]=255*B[C].b,I[M++]=255;return I}static CreateColorsTexture(B,I,C,M){const x=M.getEngine().getCaps().maxTextureSize??1,y=I.length>x?x:I.length,f=Math.ceil(I.length/x);f>1&&(I=[...I,...Array(y*f-I.length).fill(I[0])]);const L=pB.Color3toRGBAUint8(I),e=new t.e(L,y,f,k.d.TEXTUREFORMAT_RGBA,M,!1,!0,C);return e.name=B,e}static PrepareEmptyColorsTexture(B){if(!JB.EmptyColorsTexture){const I=new Uint8Array(4);JB.EmptyColorsTexture=new t.e(I,1,1,k.d.TEXTUREFORMAT_RGBA,B,!1,!1,t.e.NEAREST_NEAREST),JB.EmptyColorsTexture.name="grlEmptyColorsTexture"}return JB.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var B;null===(B=JB.EmptyColorsTexture)||void 0===B||B.dispose(),JB.EmptyColorsTexture=null}static BooleanToNumber(B){return B?1:0}}class nB extends AB.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class OB extends rB.b{isCompatible(B){return!0}constructor(B,I,C){var x;C=C||{color:JB.DEFAULT_COLOR};const y=new nB;y.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,y.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(I??B.rB()).useRightHandedSystem,y.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(B,OB.GREASED_LINE_MATERIAL_NAME,200,y,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(x=C)||void 0===x?void 0:x.forceGLSL)||OB.ForceGLSL,this._scene=I??B.rB(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?JB.DEFAULT_WIDTH_ATTENUATED:JB.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??t.e.NEAREST_NEAREST,this._colors=C.iB??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new M.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=pB.CreateColorsTexture(`${B.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??JB.DEFAULT_COLOR,pB.PrepareEmptyColorsTexture(this._scene)),this._engine.If.add((()=>{pB.DisposeEmptyColorsTexture()}))}getAttributes(B){B.push("grl_offsets"),B.push("grl_widths"),B.push("grl_colorPointers"),B.push("grl_counters"),this._cameraFacing?(B.push("grl_previousAndSide"),B.push("grl_nextAndCounters")):B.push("grl_slopes")}getSamplers(B){B.push("grl_colors")}getActiveTextures(B){this.colorsTexture&&B.push(this.colorsTexture)}getUniforms(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const I=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&I.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===B&&I.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:I,vertex:this._cameraFacing&&this._isGLSL(B)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(B)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(B){if(this._cameraFacing){B.pf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||B.pf("viewProjection",this._scene.getTransformMatrix());const I=M.TmpVectors.Vector4[0];I.x=this._aspect,I.y=this._resolution.x,I.z=this._resolution.y,I.w=this.width,B.updateVector4("grl_aspect_resolution_lineWidth",I)}const I=M.TmpVectors.Vector4[0];I.x=pB.BooleanToNumber(this.useDash),I.y=this._dashArray,I.z=this.dashOffset,I.w=this.dashRatio,B.updateVector4("grl_dashOptions",I);const C=M.TmpVectors.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=pB.BooleanToNumber(this.useColors),B.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&B.updateColor3("grl_singleColor",this._color);const x=this.colorsTexture??JB.EmptyColorsTexture;B.setTexture("grl_colors",x),B.updateFloat2("grl_textureSize",(null===x||void 0===x?void 0:x.getSize().width)??1,(null===x||void 0===x?void 0:x.getSize().height)??1)}prepareDefines(B,I,C){B.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,B.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=I.useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=this._cameraFacing,B.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return OB.GREASED_LINE_MATERIAL_NAME}getCustomCode(B){let I=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(I)?function(B,I){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return I&&(B["!gl_Position\\=viewProjection\\*worldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(B,this._cameraFacing):function(B,I){if("vertex"===B){const B={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return I&&(B["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),B}return"fragment"===B?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(B,this._cameraFacing)}dispose(){var B;null===(B=this.colorsTexture)||void 0===B||B.dispose(),super.dispose()}get iB(){return this._colors}set iB(B){this.setColors(B)}setColors(B){var I;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var y;if(this._colors=B,null!==B&&0!==B.length){if(!C||M)if(this.colorsTexture&&x===B.length&&!M){const I=pB.Color3toRGBAUint8(B);this.colorsTexture.update(I)}else{var f;null===(f=this.colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=pB.CreateColorsTexture(`${this._material.name}-colors-texture`,B,this.colorsSampling,this._scene)}}else null===(y=this.colorsTexture)||void 0===y||y.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.markAllDefinesAsDirty()}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==B||null!==this._color&&null===B?(this._color=B,I||this.markAllDefinesAsDirty()):this._color=B}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(B){this._aspect=B.x/B.y,this._resolution=B}serialize(){const B=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(I.iB=this._colors),this._color&&(I.color=this._color),B.greasedLineMaterialOptions=I,B}parse(B,I,C){var M;super.parse(B,I,C);const x=B.greasedLineMaterialOptions;null===(M=this.colorsTexture)||void 0===M||M.dispose(),x.color&&this.setColor(x.color,!0),x.colorDistributionType&&(this.colorsDistributionType=x.colorDistributionType),x.iB&&(this.iB=x.iB),x.colorsSampling&&(this.colorsSampling=x.colorsSampling),x.colorMode&&(this.colorMode=x.colorMode),x.useColors&&(this.useColors=x.useColors),x.visibility&&(this.visibility=x.visibility),x.useDash&&(this.useDash=x.useDash),x.dashCount&&(this.dashCount=x.dashCount),x.dashRatio&&(this.dashRatio=x.dashRatio),x.dashOffset&&(this.dashOffset=x.dashOffset),x.width&&(this.width=x.width),x.sizeAttenuation&&(this.sizeAttenuation=x.sizeAttenuation),x.resolution&&(this.resolution=x.resolution),this.iB?this.colorsTexture=pB.CreateColorsTexture(`${this._material.name}-colors-texture`,this.iB,this.colorsSampling,I):pB.PrepareEmptyColorsTexture(I),this.markAllDefinesAsDirty()}copyTo(B){var I;const C=B;null===(I=C.colorsTexture)||void 0===I||I.dispose(),this._colors&&(C.colorsTexture=pB.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(B){return 0===B||this._forceGLSL}}OB.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",OB.ForceGLSL=!1,(0,DB.h)(`BABYLON.${OB.GREASED_LINE_MATERIAL_NAME}`,OB);var aB=C(11633),WB=C(11029),dB=C(11432),lB=C(11135);class EB extends dB.ShaderMaterial{constructor(B,I,x){const y=I.getEngine(),f=y.isWebGPU&&!(x.forceGLSL||EB.ForceGLSL),L=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];I.useRightHandedSystem&&L.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const e=["position","grl_widths","grl_offsets","grl_colorPointers"];x.cameraFacing?(L.push("GREASED_LINE_CAMERA_FACING"),e.push("grl_previousAndSide","grl_nextAndCounters")):(e.push("grl_slopes"),e.push("grl_counters"));const g=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(f||g.push("world","viewProjection","view","projection"),super(B,I,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:f?["Scene","Mesh"]:void 0,attributes:e,uniforms:g,samplers:f?[]:["grlColors"],defines:L,extraInitializationsAsync:async()=>{f?await Promise.all([C.e(66).then(C.bind(C,14299)),C.e(75).then(C.bind(C,14307))]):await Promise.all([C.e(69).then(C.bind(C,14313)),C.e(76).then(C.bind(C,14322))])},shaderLanguage:f?1:0}),this._color=S.SI.White(),this._colorsDistributionType=0,this._colorsTexture=null,x=x||{color:JB.DEFAULT_COLOR},this.visibility=x.visibility??1,this.useDash=x.useDash??!1,this.dashRatio=x.dashRatio??.5,this.dashOffset=x.dashOffset??0,this.dashCount=x.dashCount??1,this.width=x.width?x.width:x.sizeAttenuation&&x.cameraFacing?JB.DEFAULT_WIDTH_ATTENUATED:JB.DEFAULT_WIDTH,this.sizeAttenuation=x.sizeAttenuation??!1,this.color=x.color??S.SI.White(),this.useColors=x.useColors??!1,this.colorsDistributionType=x.colorDistributionType??0,this.colorsSampling=x.colorsSampling??t.e.NEAREST_NEAREST,this.colorMode=x.colorMode??0,this._colors=x.iB??null,this._cameraFacing=x.cameraFacing??!0,this.resolution=x.resolution??new M.Vector2(y.getRenderWidth(),y.getRenderHeight()),x.colorsTexture?this.colorsTexture=x.colorsTexture:this._colors?this.colorsTexture=pB.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,I):(this._color=this._color??JB.DEFAULT_COLOR,this.colorsTexture=pB.PrepareEmptyColorsTexture(I)),f){const B=new lB.d;B.setParameters(),B.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",B)}y.If.add((()=>{pB.DisposeEmptyColorsTexture()}))}dispose(){var B;null===(B=this._colorsTexture)||void 0===B||B.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new M.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get iB(){return this._colors}set iB(B){this.setColors(B)}setColors(B){var I;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],M=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=(null===(I=this._colors)||void 0===I?void 0:I.length)??0;var y;if(this._colors=B,null!==B&&0!==B.length){if(!C||M)if(this._colorsTexture&&x===B.length&&!M){const I=pB.Color3toRGBAUint8(B);this._colorsTexture.update(I)}else{var f;null===(f=this._colorsTexture)||void 0===f||f.dispose(),this.colorsTexture=pB.CreateColorsTexture(`${this.name}-colors-texture`,B,this.colorsSampling,this.rB())}}else null===(y=this._colorsTexture)||void 0===y||y.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(B){this._colorsTexture=B,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(B){this._width=B,this.setFloat("grlWidth",B)}get useColors(){return this._useColors}set useColors(B){this._useColors=B,this.setFloat("grlUseColors",pB.BooleanToNumber(B))}get colorsSampling(){return this._colorsSampling}set colorsSampling(B){this._colorsSampling=B}get visibility(){return this._visibility}set visibility(B){this._visibility=B,this.setFloat("grlVisibility",B)}get useDash(){return this._useDash}set useDash(B){this._useDash=B,this.setFloat("grlUseDash",pB.BooleanToNumber(B))}get dashOffset(){return this._dashOffset}set dashOffset(B){this._dashOffset=B,this.setFloat("grlDashOffset",B)}get dashRatio(){return this._dashRatio}set dashRatio(B){this._dashRatio=B,this.setFloat("grlDashRatio",B)}get dashCount(){return this._dashCount}set dashCount(B){this._dashCount=B,this._dashArray=1/B,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(B){this._sizeAttenuation=B,this.setFloat("grlSizeAttenuation",pB.BooleanToNumber(B))}get color(){return this._color}set color(B){this.setColor(B)}setColor(B){B=B??JB.DEFAULT_COLOR,this._color=B,this.setColor3("grlColor",B)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(B){this._colorsDistributionType=B,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(B){this._colorMode=B,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(B){this._resolution=B,this.setVector2("grlResolution",B),this.setFloat("grlAspect",B.x/B.y)}serialize(){const B=super.serialize(),I={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(I.iB=this._colors),B.greasedLineMaterialOptions=I,B}parse(B,I,C){var M;const x=B.greasedLineMaterialOptions;null===(M=this._colorsTexture)||void 0===M||M.dispose(),x.color&&(this.color=x.color),x.colorDistributionType&&(this.colorsDistributionType=x.colorDistributionType),x.colorsSampling&&(this.colorsSampling=x.colorsSampling),x.colorMode&&(this.colorMode=x.colorMode),x.useColors&&(this.useColors=x.useColors),x.visibility&&(this.visibility=x.visibility),x.useDash&&(this.useDash=x.useDash),x.dashCount&&(this.dashCount=x.dashCount),x.dashRatio&&(this.dashRatio=x.dashRatio),x.dashOffset&&(this.dashOffset=x.dashOffset),x.width&&(this.width=x.width),x.sizeAttenuation&&(this.sizeAttenuation=x.sizeAttenuation),x.resolution&&(this.resolution=x.resolution),x.iB?this.colorsTexture=pB.CreateColorsTexture(`${this.name}-colors-texture`,x.iB,this.colorsSampling,this.rB()):this.colorsTexture=pB.PrepareEmptyColorsTexture(I),this._cameraFacing=x.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var QB,ZB,zB;EB.ForceGLSL=!1,function(B){B[B.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",B[B.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(QB||(QB={})),function(B){B[B.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",B[B.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",B[B.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(ZB||(ZB={})),function(B){B[B.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",B[B.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",B[B.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",B[B.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",B[B.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(zB||(zB={}));class bB extends UB.b{constructor(B,I,C){super(B,I,null,null,!1,!1),this.name=B,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=I.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(B){let I=0;for(const M of this._points)I+=M.length;const C=I/3*2-this._widths.length;for(let M=0;M<C;M++)this._widths.push(B)}updateLazy(){var B,I;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(B=this._options.ribbonOptions)||void 0===B?void 0:B.smoothShading),!this.OB&&this.refreshBoundingInfo(),null===(I=this.greasedLineMaterial)||void 0===I||I.updateLazy()}addPoints(B,I){for(const C of B)this._points.push(C);this._lazy||this.setPoints(this._points,I)}dispose(B){let I=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(B,I)}isLazy(){return this._lazy}get uB(){return this._uvs}set uB(B){this._uvs=B instanceof Float32Array?B:new Float32Array(B),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(B){this.material instanceof EB&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===B||void 0===B?void 0:B.length)>0),this._offsets=B,this._offsetsBuffer?this._offsetsBuffer.update(B):this._createOffsetsBuffer(B)}get widths(){return this._widths}set widths(B){this._widths=B,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(B)}get colorPointers(){return this._colorPointers}set colorPointers(B){this._colorPointers=B,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(B)}get greasedLineMaterial(){var B,I;if(this.material&&this.material instanceof EB)return this.material;const C=null===(B=this.material)||void 0===B||null===(I=B.pluginManager)||void 0===I?void 0:I.getPlugin(OB.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const B=[];return WB.d.DeepCopy(this._points,B),B}setPoints(B,I){this._points=pB.ConvertPoints(B,(null===I||void 0===I?void 0:I.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==I&&void 0!==I&&I.colorPointers||this._updateColorPointers(),this._setPoints(this._points,I)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,uB:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(B){super.serialize(B),B.type=this.getClassName(),B.lineOptions=this._createLineOptions()}_createVertexBuffers(){let B=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const I=new aB.e;return I.DB=this._vertexPositions,I.indices=this._indices,I.uB=this._uvs,B&&(I.JB=[],aB.e.ComputeNormals(this._vertexPositions,this._indices,I.JB)),I.nB(this,this._options.updatable),I}_createOffsetsBuffer(B){const I=this._scene.getEngine(),C=new N.d(I,B,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class YB{constructor(B,I){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=B,this.wasAddedByNoopNode=I}getIndicesAccessor(B,I,C,M,x){var y,f,L,e;return null===(y=this._indicesAccessorMap.get(B))||void 0===y||null===(f=y.get(I))||void 0===f||null===(L=f.get(C))||void 0===L||null===(e=L.get(M))||void 0===e?void 0:e.get(x)}setIndicesAccessor(B,I,C,M,x,y){let f=this._indicesAccessorMap.get(B);f||(f=new Map,this._indicesAccessorMap.set(B,f));let L=f.get(I);L||(L=new Map,f.set(I,L));let e=L.get(C);e||(e=new Map,L.set(C,e));let g=e.get(M);g||(g=new Map,e.set(M,g)),g.set(x,y)}pushExportedNode(B){this._exportedNodes.has(B)||this._exportedNodes.add(B)}getNodesSet(){return this._exportedNodes}getVertexBufferView(B){return this._vertexBufferViewMap.get(B)}setVertexBufferView(B,I){this._vertexBufferViewMap.set(B,I)}setRemappedBufferView(B,I,C){this._remappedBufferView.set(B,new Map),this._remappedBufferView.get(B).set(I,C)}getRemappedBufferView(B,I){var C;return null===(C=this._remappedBufferView.get(B))||void 0===C?void 0:C.get(I)}getVertexAccessor(B,I,C){var M,x;return null===(M=this._vertexAccessorMap.get(B))||void 0===M||null===(x=M.get(I))||void 0===x?void 0:x.get(C)}setVertexAccessor(B,I,C,M){let x=this._vertexAccessorMap.get(B);x||(x=new Map,this._vertexAccessorMap.set(B,x));let y=x.get(I);y||(y=new Map,x.set(I,y)),y.set(C,M)}hasVertexColorAlpha(B){return this._vertexMapColorAlpha.get(B)||!1}setHasVertexColorAlpha(B,I){return this._vertexMapColorAlpha.set(B,I)}getMesh(B){return this._meshMap.get(B)}setMesh(B,I){this._meshMap.set(B,I)}bindMorphDataToMesh(B,I){const C=this._meshMorphTargetMap.get(B)||[];this._meshMorphTargetMap.set(B,C),-1===C.indexOf(I)&&C.push(I)}getMorphTargetsFromMesh(B){return this._meshMorphTargetMap.get(B)}}class vB{_ApplyExtension(B,I,C,M){if(C>=I.length)return Promise.resolve(B);const x=M(I[C],B);return x?x.then((async B=>B?await this._ApplyExtension(B,I,C+1,M):null)):this._ApplyExtension(B,I,C+1,M)}_ApplyExtensions(B,I){const C=[];for(const M of vB._ExtensionNames)C.push(this._extensions[M]);return this._ApplyExtension(B,C,0,I)}_extensionsPreExportTextureAsync(B,I,C){return this._ApplyExtensions(I,((I,M)=>I.preExportTextureAsync&&I.preExportTextureAsync(B,M,C)))}_extensionsPostExportNodeAsync(B,I,C,M,x){return this._ApplyExtensions(I,((I,y)=>I.postExportNodeAsync&&I.postExportNodeAsync(B,y,C,M,x,this._bufferManager)))}_extensionsPostExportMaterialAsync(B,I,C){return this._ApplyExtensions(I,((I,M)=>I.postExportMaterialAsync&&I.postExportMaterialAsync(B,M,C)))}_extensionsPostExportMaterialAdditionalTextures(B,I,C){const M=[];for(const x of vB._ExtensionNames){const y=this._extensions[x];y.postExportMaterialAdditionalTextures&&M.push(...y.postExportMaterialAdditionalTextures(B,I,C))}return M}_extensionsPostExportTextures(B,I,C){for(const M of vB._ExtensionNames){const x=this._extensions[M];x.postExportTexture&&x.postExportTexture(B,I,C)}}_extensionsPostExportMeshPrimitive(B){for(const I of vB._ExtensionNames){const C=this._extensions[I];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(B,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const B of vB._ExtensionNames){const I=this._extensions[B];I.preGenerateBinaryAsync&&await I.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(B){for(const I of vB._ExtensionNames){const C=this._extensions[I];C.enabled&&B(C)}}_extensionsOnExporting(){this._forEachExtensions((B=>{var I,C,M;B.wasUsed&&((I=this._glTF).extensionsUsed||(I.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(B.name)&&this._glTF.extensionsUsed.push(B.name),B.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(B.name)&&this._glTF.extensionsRequired.push(B.name)),(M=this._glTF).extensions||(M.extensions={}),B.onExporting&&B.onExporting())}))}_loadExtensions(){for(const B of vB._ExtensionNames){const I=vB._ExtensionFactories[B](this);this._extensions[B]=I}}constructor(){let B=arguments.length>0&&void 0!==arguments[0]?arguments[0]:q.c.LastCreatedScene,I=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${k.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new l(this),this._extensions={},this._bufferManager=new NB,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!B)throw new Error("No scene available to export");this._babylonScene=B,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:B=>{var I;return null===B||void 0===B||null===(I=B.qf)||void 0===I?void 0:I.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...I},this._loadExtensions()}dispose(){for(const B in this._extensions){this._extensions[B].dispose()}}get options(){return this._options}static RegisterExtension(B,I){vB.UnregisterExtension(B)&&x.Tools.Warn(`Extension with the name ${B} already exists`),vB._ExtensionFactories[B]=I,vB._ExtensionNames.push(B)}static UnregisterExtension(B){if(!vB._ExtensionFactories[B])return!1;delete vB._ExtensionFactories[B];const I=vB._ExtensionNames.indexOf(B);return-1!==I&&vB._ExtensionNames.splice(I,1),!0}_generateJSON(B,I,C){const M={byteLength:B};return M.byteLength&&(this._glTF.buffers=[M]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.kI=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(M.uri=I+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(B){const I=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(I.byteLength,B,!0),M=new Blob([I],{type:"application/octet-stream"}),x=B+".gltf",y=B+".bin",f=new g;if(f.files[x]=C,f.files[y]=M,this._imageData)for(const L in this._imageData)f.files[L]=new Blob([this._imageData[L].data],{type:this._imageData[L].mimeType});return f}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(B){const I=B%4;return 0===I?I:4-I}async generateGLBAsync(B){this._shouldUseGlb=!0;const I=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(I.byteLength),M=B+".glb";let x,y=C.length;if("undefined"!==typeof TextEncoder){x=(new TextEncoder).encode(C),y=x.length}const f=this._getPadding(y),L=this._getPadding(I.byteLength),e=28+y+f+I.byteLength+L,N=new eB(e);if(N.writeUInt32(1179937895),N.writeUInt32(2),N.writeUInt32(e),N.writeUInt32(y+f),N.writeUInt32(1313821514),x)N.writeTypedArray(x);else{const B="_".charCodeAt(0);for(let I=0;I<y;++I){const M=C.charCodeAt(I);M!=C.codePointAt(I)?N.writeUInt8(B):N.writeUInt8(M)}}for(let g=0;g<f;++g)N.writeUInt8(32);N.writeUInt32(I.byteLength+L),N.writeUInt32(5130562),N.writeTypedArray(I);for(let g=0;g<L;++g)N.writeUInt8(0);const R=new g;return R.files[M]=new Blob([N.getOutputData()],{type:"application/octet-stream"}),R}_setNodeTransformation(B,I,C){if(I.getPivotPoint().equalsWithEpsilon(b,z.d)||x.Tools.Warn("Pivot points are not supported in the glTF serializer"),!I.position.equalsWithEpsilon(b,z.d)){const x=M.TmpVectors.HI[0].M(I.position);C&&w(x),B.translation=x.Df()}I.Xf.equalsWithEpsilon(v,z.d)||(B.scale=I.Xf.Df());const y=I.rotationQuaternion||M.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);y.equalsWithEpsilon(Y,z.d)||(C&&K(y),B.rotation=y.normalize().Df())}_setCameraTransformation(B,I,C){if(!I.position.equalsWithEpsilon(b,z.d)){const x=M.TmpVectors.HI[0].M(I.position);C&&w(x),B.translation=x.Df()}const x=I.rotationQuaternion||M.Quaternion.FromEulerAngles(I.rotation.x,I.rotation.y,I.rotation.z);C&&K(x),this._babylonScene.useRightHandedSystem||m(x),x.equalsWithEpsilon(Y,z.d)||(B.rotation=x.Df())}_listAvailableCameras(){for(const B of this._babylonScene.cameras){const I={type:B.mode===HB.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(B.name&&(I.name=B.name),"perspective"===I.type)I.perspective={aspectRatio:B.getEngine().getAspectRatio(B),yfov:B.fovMode===HB.e.FOVMODE_VERTICAL_FIXED?B.fov:B.fov*B.getEngine().getAspectRatio(B),znear:B.uf,zfar:B.maxZ};else if("orthographic"===I.type){const C=B.orthoLeft&&B.orthoRight?.5*(B.orthoRight-B.orthoLeft):.5*B.getEngine().getRenderWidth(),M=B.orthoBottom&&B.orthoTop?.5*(B.orthoTop-B.orthoBottom):.5*B.getEngine().getRenderHeight();I.orthographic={xmag:C,ymag:M,znear:B.uf,zfar:B.maxZ}}this._camerasMap.set(B,I)}}_exportAndAssignCameras(){const B=Array.from(this._camerasMap.values());for(const I of B){const B=this._nodesCameraMap.get(I);if(void 0!==B){this._cameras.push(I);for(const I of B)I.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const I={joints:[]};this._skinMap.set(B,I)}}_exportAndAssignSkeletons(){for(const B of this._babylonScene.skeletons){if(B.bones.length<=0)continue;const I=this._skinMap.get(B);if(void 0==I)continue;const C={},M=[];let y=-1;for(let x=0;x<B.bones.length;++x){const I=B.bones[x],M=I.getIndex()??x;-1!==M&&(C[M]=I,M>y&&(y=M))}for(let B=0;B<=y;++B){const y=C[B];M.push(y.getAbsoluteInverseBindMatrix());const f=y.getTransformNode();if(null!==f){const B=this._nodeMap.get(f);f&&null!==B&&void 0!==B?I.joints.push(B):x.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else x.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const f=this._nodesSkinMap.get(I);if(I.joints.length>0&&void 0!==f){const B=64*M.length,C=new Float32Array(B/4);M.forEach(((B,I)=>{C.set(B.m,16*I)}));const x=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(x,"MAT4",5126,M.length)),I.inverseBindMatrices=this._accessors.length-1,this._skins.push(I);for(const I of f)I.skin=this._skins.length-1}}}async _exportSceneAsync(){const B={nodes:[]};if(this._babylonScene.metadata){const I=this._options.metadataSelector(this._babylonScene.metadata);I&&(B.extras=I)}const I=new Array,C=new Array,M=new Array;for(const L of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&fB(L,this._babylonScene.useRightHandedSystem)?M.push(...L.getChildren()):this._babylonScene.useRightHandedSystem?I.push(L):C.push(L);this._listAvailableCameras(),this._listAvailableSkeletons();const x=new YB(!0,!1);B.nodes.push(...await this._exportNodesAsync(C,x));const y=new YB(!1,!1);B.nodes.push(...await this._exportNodesAsync(I,y));const f=new YB(!1,!0);B.nodes.push(...await this._exportNodesAsync(M,f)),B.nodes.length&&this._scenes.push(B),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&VB._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,x.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(B){let I=this._shouldExportNodeMap.get(B);return void 0===I&&(I=this._options.shouldExportNode(B),this._shouldExportNodeMap.set(B,I)),I}async _exportNodesAsync(B,I){const C=new Array;this._exportBuffers(B,I);for(const M of B)await this._exportNodeAsync(M,C,I);return C}_collectBuffers(B,I,C,M,x){if(this._shouldExportNode(B)&&B instanceof H.e&&B.zf){const y=B.zf.getVertexBuffers();if(y)for(const M in y){if(!P(M))continue;const f=y[M];x.setHasVertexColorAlpha(f,B.hasVertexAlpha);const L=f._buffer,e=I.get(L)||[];I.set(L,e),-1===e.indexOf(f)&&e.push(f);const g=C.get(f)||[];C.set(f,g),-1===g.indexOf(B)&&g.push(B)}const f=B.morphTargetManager;if(f)for(let I=0;I<f.numTargets;I++){const C=f.getTarget(I),x=M.get(C)||[];M.set(C,x),-1===x.indexOf(B)&&x.push(B)}}for(const y of B.getChildren())this._collectBuffers(y,I,C,M,x)}_exportBuffers(B,I){const C=new Map,M=new Map,x=new Map;for(const L of B)this._collectBuffers(L,C,M,x,I);const y=Array.from(C.keys());for(const L of y){const B=L.getData();if(!B)throw new Error("Buffer data is not available");const x=C.get(L);if(!x)continue;const y=x[0].byteStride;if(x.some((B=>B.byteStride!==y)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const f=CB(B).slice();for(const I of x){const B=M.get(I),{byteOffset:C,byteStride:x,componentCount:y,type:L,count:e,normalized:g,kind:R}=X(I,B);switch(R){case N.g.NormalKind:case N.g.TangentKind:(0,E.g)(f,C,x,y,L,e,g,(B=>{const I=Math.sqrt(B[0]*B[0]+B[1]*B[1]+B[2]*B[2]);if(I>0){const C=1/I;B[0]*=C,B[1]*=C,B[2]*=C}}));break;case N.g.ColorKind:{const I=B.filter((B=>B.material instanceof qB.qI||null==B.material)).length;if(0==I)break;if(I!=B.length){Q.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}L==N.g.UNSIGNED_BYTE&&Q.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const M=new S.SI,R=new S.Pf,H=this._babylonScene.getEngine().useExactSrgbConversions;(0,E.g)(f,C,x,y,L,e,g,(B=>{3===B.length?(M.RC(B,0),M.toLinearSpaceToRef(M,H),M.toArray(B,0)):(R.RC(B,0),R.toLinearSpaceToRef(R,H),R.toArray(B,0))}))}}}if(I.convertToRightHanded){for(const B of x){const I=M.get(B),{byteOffset:C,byteStride:x,componentCount:y,type:L,count:e,normalized:g,kind:R}=X(B,I);switch(R){case N.g.PositionKind:case N.g.NormalKind:case N.g.TangentKind:(0,E.g)(f,C,x,y,L,e,g,(B=>{B[0]=-B[0]}))}}I.convertedToRightHandedBuffers.set(L,f)}const e=this._bufferManager.createBufferView(f,y);I.setVertexBufferView(L,e);const g=new Map;for(const I of x){const B=M.get(I),{kind:C,totalVertices:x}=X(I,B);switch(C){case N.g.MatricesIndicesKind:case N.g.MatricesIndicesExtraKind:if(I.type==N.g.FLOAT){const B=I.getFloatData(x);null!==B&&g.set(I,B)}}}0!==g.size&&Q.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const R=Array.from(g.keys());for(const C of R){const B=g.get(C);if(!B)continue;const M=B.some((B=>B>=256)),x=new(M?Uint16Array:Uint8Array)(B.length);for(let I=0;I<B.length;I++)x[I]=B[I];const y=this._bufferManager.createBufferView(x,4*(M?2:1));I.setRemappedBufferView(L,C,y)}}const f=Array.from(x.keys());for(const L of f){const B=x.get(L);if(!B)continue;const C=cB(L,B[0],this._bufferManager,this._bufferViews,this._accessors,I.convertToRightHanded);for(const M of B)I.bindMorphDataToMesh(M,C)}}async _exportNodeAsync(B,I,C){let M=this._nodeMap.get(B);if(void 0!==M)return void(I.includes(M)||I.push(M));const x=await this._createNodeAsync(B,C);if(x){M=this._nodes.length,this._nodes.push(x),this._nodeMap.set(B,M),C.pushExportedNode(B),I.push(M);const y={name:"runtime animations",channels:[],samplers:[]},f=[];this._babylonScene.animationGroups.length||(VB._CreateMorphTargetAnimationFromMorphTargetAnimations(B,y,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),B.animations.length&&VB._CreateNodeAnimationFromNodeAnimations(B,y,f,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),y.channels.length&&y.samplers.length&&this._animations.push(y),f.forEach((B=>{B.channels.length&&B.samplers.length&&this._animations.push(B)}))}const y=x?[]:I;for(const f of B.getChildren())await this._exportNodeAsync(f,y,C);x&&y.length&&(x.children=y)}async _createNodeAsync(B,I){if(!this._shouldExportNode(B))return null;const C={};if(B.name&&(C.name=B.name),B.metadata){const I=this._options.metadataSelector(B.metadata);I&&(C.extras=I)}if(B instanceof R.d&&(this._setNodeTransformation(C,B,I.convertToRightHanded),B instanceof H.e)){const x=B instanceof F.d?B.sourceMesh:B;if(x.cf&&x.cf.length>0&&(C.mesh=await this._exportMeshAsync(x,I)),B.skeleton){const I=this._skinMap.get(B.skeleton);var M;if(void 0!==I)void 0===this._nodesSkinMap.get(I)&&this._nodesSkinMap.set(I,[]),null===(M=this._nodesSkinMap.get(I))||void 0===M||M.push(C)}}if(B instanceof Z.e){const M=this._camerasMap.get(B);if(M){var x;void 0===this._nodesCameraMap.get(M)&&this._nodesCameraMap.set(M,[]),this._setCameraTransformation(C,B,I.convertToRightHanded);const f=B.parent;if(null!==f&&IB(B,f)){const B=this._nodeMap.get(f);if(void 0!==B){var y;const I=this._nodes[B];return BB(C,I),null===(y=this._nodesCameraMap.get(M))||void 0===y||y.push(I),null}}null===(x=this._nodesCameraMap.get(M))||void 0===x||x.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,B,this._nodeMap,I.convertToRightHanded)?C:(Q.b.Warn(`Not exporting node ${B.name}`),null)}_exportIndices(B,I,C,M,x,f,L,e,g){let N=B;g.mode=h(f);const R=L!==y.c.CounterClockWiseSideOrientation,H=!e.wasAddedByNoopNode&&R,F=function(B){switch(B){case y.c.TriangleFillMode:case y.c.TriangleStripDrawMode:case y.c.TriangleFanDrawMode:return!0}return!1}(f)&&H;if(F){if(f===y.c.TriangleStripDrawMode||f===y.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");g.mode=h(f);const L=I?new Uint32Array(M):new Uint16Array(M);if(B)for(let I=0;I+2<M;I+=3)L[I]=B[C+I]+x,L[I+1]=B[C+I+2]+x,L[I+2]=B[C+I+1]+x;else for(let B=0;B+2<M;B+=3)L[B]=B,L[B+1]=B+2,L[B+2]=B+1;N=L}else if(B&&0!==x){const y=I?new Uint32Array(M):new Uint16Array(M);for(let I=0;I<M;I++)y[I]=B[C+I]+x;N=y}if(N){let y=e.getIndicesAccessor(B,C,M,x,F);if(void 0===y){const f=function(B,I,C,M){if(B instanceof Uint16Array||B instanceof Uint32Array)return B;if(B instanceof Int32Array)return new Uint32Array(B.buffer,B.byteOffset,B.length);const x=B.slice(I,I+C);return M?new Uint32Array(x):new Uint16Array(x)}(N,0,M,I),L=this._bufferManager.createBufferView(f),g=I?5125:5123;this._accessors.push(this._bufferManager.createAccessor(L,"SCALAR",g,M,0)),y=this._accessors.length-1,e.setIndicesAccessor(B,C,M,x,F,y)}g.indices=y}}_exportVertexBuffer(B,I,C,M,x,y){const f=B.getKind();if(!P(f))return;if(f.startsWith("uv")&&!this._options.exportUnusedUVs&&(!I||!this._materialNeedsUVsSet.has(I)))return;let L=x.getVertexAccessor(B,C,M);if(void 0===L){const I=x.convertedToRightHandedBuffers.get(B._buffer)||B._buffer.getData(),y=f===N.g.PositionKind?function(B,I,C,M){const{byteOffset:x,byteStride:y,type:f,normalized:L}=I,e=I.getSize(),g=new Array(e).fill(1/0),N=new Array(e).fill(-1/0);return(0,E.g)(B,x+C*y,y,e,f,M*e,L,(B=>{for(let I=0;I<e;I++)g[I]=Math.min(g[I],B[I]),N[I]=Math.max(N[I],B[I])})),{min:g,max:N}}(I,B,C,M):void 0,e=(f===N.g.MatricesIndicesKind||f===N.g.MatricesIndicesExtraKind)&&B.type===N.g.FLOAT,g=e?N.g.UNSIGNED_BYTE:B.type,R=e?void 0:B.normalized,H=e?x.getRemappedBufferView(B._buffer,B):x.getVertexBufferView(B._buffer),F=B.byteOffset+C*B.byteStride;this._accessors.push(this._bufferManager.createAccessor(H,function(B,I){if(B==N.g.ColorKind)return I?"VEC4":"VEC3";switch(B){case N.g.PositionKind:case N.g.NormalKind:return"VEC3";case N.g.TangentKind:case N.g.MatricesIndicesKind:case N.g.MatricesIndicesExtraKind:case N.g.MatricesWeightsKind:case N.g.MatricesWeightsExtraKind:return"VEC4";case N.g.UVKind:case N.g.UV2Kind:case N.g.UV3Kind:case N.g.UV4Kind:case N.g.UV5Kind:case N.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${B}`)}(f,x.hasVertexColorAlpha(B)),g,M,F,y,R)),L=this._accessors.length-1,x.setVertexAccessor(B,C,M,L)}y.attributes[function(B){switch(B){case N.g.PositionKind:return"POSITION";case N.g.NormalKind:return"NORMAL";case N.g.TangentKind:return"TANGENT";case N.g.ColorKind:return"COLOR_0";case N.g.UVKind:return"TEXCOORD_0";case N.g.UV2Kind:return"TEXCOORD_1";case N.g.UV3Kind:return"TEXCOORD_2";case N.g.UV4Kind:return"TEXCOORD_3";case N.g.UV5Kind:return"TEXCOORD_4";case N.g.UV6Kind:return"TEXCOORD_5";case N.g.MatricesIndicesKind:return"JOINTS_0";case N.g.MatricesIndicesExtraKind:return"JOINTS_1";case N.g.MatricesWeightsKind:return"WEIGHTS_0";case N.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${B}`)}(f)]=L}async _exportMaterialAsync(B,I,C,M){let x=this._materialMap.get(B);if(void 0===x){const M=I&&Object.keys(I).some((B=>B.startsWith("uv")));if((B=B instanceof FB.d?B.jf[C.materialIndex]:B)instanceof kB.c)x=await this._materialExporter.exportPBRMaterialAsync(B,"image/png",M);else{if(!(B instanceof qB.qI))return void Q.b.Warn(`Unsupported material '${B.name}' with type ${B.getClassName()}`);x=await this._materialExporter.exportStandardMaterialAsync(B,"image/png",M)}this._materialMap.set(B,x)}M.material=x}async _exportMeshAsync(B,I){var C;let M=I.getMesh(B);if(void 0!==M)return M;const x={primitives:[]};M=this._meshes.length,this._meshes.push(x),I.setMesh(B,M);const f=B.isUnIndexed?null:B.bf(),L=null===(C=B.zf)||void 0===C?void 0:C.getVertexBuffers(),e=I.getMorphTargetsFromMesh(B),g=B instanceof tB.d,N=B instanceof bB,R=B.cf;if(L&&R&&R.length>0)for(const k of R){const C={attributes:{}},M=k.lB()||this._babylonScene.defaultMaterial;if(N){var H,F;const I={name:M.name},x=B,y=S.SI.White(),f=(null===(H=x.material)||void 0===H?void 0:H.alpha)??1,L=(null===(F=x.greasedLineMaterial)||void 0===F?void 0:F.color)??y;(!L.equalsWithEpsilon(y,z.d)||f<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...L.Df(),f]}),this._materials.push(I),C.material=this._materials.length-1}else if(g){const I={name:M.name},x=B;(!x.color.equalsWithEpsilon(S.SI.White(),z.d)||x.alpha<1)&&(I.pbrMetallicRoughness={baseColorFactor:[...x.color.Df(),x.alpha]}),this._materials.push(I),C.material=this._materials.length-1}else await this._exportMaterialAsync(M,L,k,C);const R=g||N?y.c.LineListDrawMode:B.overrideRenderingFillMode??M.fillMode,q=M._getEffectiveOrientation(B);this._exportIndices(f,f?(0,E.c)(f,k.indexCount,k.indexStart,k.verticesStart):k.verticesCount>65535,f?k.indexStart:k.verticesStart,f?k.indexCount:k.verticesCount,-k.verticesStart,R,q,I,C);for(const B of Object.values(L))this._exportVertexBuffer(B,M,k.verticesStart,k.verticesCount,I,C);if(e){C.targets=[];for(const B of e)C.targets.push(B.attributes)}x.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(e){x.weights=[],x.extras||(x.extras={}),x.extras.targetNames=[];for(const B of e)x.weights.push(B.influence),x.extras.targetNames.push(B.name)}return M}}vB._ExtensionNames=new Array,vB._ExtensionFactories={};class sB{static async GLTFAsync(B,I,C){C&&C.exportWithoutWaitingForScene||await B.whenReadyAsync();const M=new vB(B,C),x=await M.generateGLTFAsync(I.replace(/\.[^/.]+$/,""));return M.dispose(),x}static async GLBAsync(B,I,C){C&&C.exportWithoutWaitingForScene||await B.whenReadyAsync();const M=new vB(B,C),x=await M.generateGLBAsync(I.replace(/\.[^/.]+$/,""));return M.dispose(),x}}C(11743);const XB="EXT_mesh_gpu_instancing";class TB{constructor(B){this.name=XB,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(B,I,C,x,y,f){return await new Promise((B=>{if(I&&C instanceof UB.b&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const B=M.HI.Zero(),x=M.Quaternion.Identity(),L=M.HI.One(),e=C.thinInstanceGetWorldMatrices(),g=M.TmpVectors.HI[2],N=M.TmpVectors.Quaternion[1],R=M.TmpVectors.HI[3];let H=!1,F=!1,k=!1;const q=new Float32Array(3*C.rL),S=new Float32Array(4*C.rL),o=new Float32Array(3*C.rL);let U=0;for(const I of e)I.decompose(R,N,g),y&&(w(g),K(N)),q.set(g.Df(),3*U),S.set(N.normalize().Df(),4*U),o.set(R.Df(),3*U),H=H||!g.equalsWithEpsilon(B),F=F||!N.equalsWithEpsilon(x),k=k||!R.equalsWithEpsilon(L),U++;const G={attributes:{}};H&&(G.attributes.TRANSLATION=this._buildAccessor(q,"VEC3",C.rL,f)),F&&(G.attributes.ROTATION=this._buildAccessor(S,"VEC4",C.rL,f)),k&&(G.attributes.SCALE=this._buildAccessor(o,"VEC3",C.rL,f)),I.extensions=I.extensions||{},I.extensions[XB]=G}B(I)}))}_buildAccessor(B,I,C,M){const x=M.createBufferView(B),y=M.createAccessor(x,I,5126,C);return this._exporter._accessors.push(y),this._exporter._accessors.length-1}}vB.RegisterExtension(XB,(B=>new TB(B)));var PB=C(11746),hB=C(11759),jB=C(11766),wB=C(11768);function KB(B){return B===jB.b.PositionKind?"POSITION":B===jB.b.NormalKind?"NORMAL":B===jB.b.ColorKind?"COLOR":B.startsWith(jB.b.UVKind)?"TEX_COORD":"GENERIC"}const mB={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class BI extends PB.d{static get DefaultAvailable(){return(0,PB.h)(BI.DefaultConfiguration)}static get Default(){return BI._Default??(BI._Default=new BI),BI._Default}static ResetDefault(B){BI._Default&&(B||BI._Default.dispose(),BI._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(B,I){return{module:await(I||DracoEncoderModule)({wasmBinary:B})}}_getWorkerContent(){return`${hB.j}(${hB.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:BI.DefaultConfiguration)}async _encodeAsync(B,I,C){const M=C?(0,wB.c)(mB,C):mB;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((x,y)=>{C.push(((C,f)=>{const L=B=>{C.removeEventListener("error",L),C.removeEventListener("message",e),y(B),f()},e=B=>{"encodeMeshDone"===B.data.id&&(C.removeEventListener("error",L),C.removeEventListener("message",e),x(B.data.encodedMeshData),f())};C.addEventListener("error",L),C.addEventListener("message",e);const g=[];for(const I of B)g.push(I.data.buffer);I&&g.push(I.buffer),C.postMessage({id:"encodeMesh",attributes:B,indices:I,options:M},g)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,hB.j)(C.module,B,I,M)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(B,I){if(0==B.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");B instanceof UB.b&&B.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===I||void 0===I?void 0:I.method)&&(Q.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),I.method="MESH_SEQUENTIAL_ENCODING");const C=function(B){let I=B.bf(void 0,!0);return!I||I instanceof Uint32Array||I instanceof Uint16Array||(I=((0,E.c)(I,I.length)?Uint32Array:Uint16Array).from(I)),I}(B),M=function(B,I){const C=[];for(const M of B.getVerticesDataKinds()){if(null!==I&&void 0!==I&&I.includes(M)){if(M===jB.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const x=B.getVertexBuffer(M),y=x.getSize(),f=(0,E.o)(x.getData(),y,x.type,x.byteOffset,x.byteStride,x.normalized,B.getTotalVertices(),!0);C.push({kind:M,dracoName:KB(M),size:y,data:f})}return C}(B,null===I||void 0===I?void 0:I.excludedAttributes);return await this._encodeAsync(M,C,I)}}BI.DefaultConfiguration={wasmUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder.js`},BI._Default=null;const II="KHR_draco_mesh_compression";class CI{get wasUsed(){return this._wasUsed}constructor(B){this.name=II,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===B.options.meshCompressionMethod&&BI.DefaultAvailable}dispose(){}postExportMeshPrimitive(B,I,C){if(!this.enabled)return;if(4!==B.mode&&5!==B.mode)return void Q.b.Warn("Cannot compress primitive with mode "+B.mode+".");const M=[],x=[];let y=null;if(void 0!==B.indices){const f=C[B.indices],L=I.getBufferView(f);y=I.getData(L).slice(),M.push(L),x.push(f)}const f=[];for(const[N,R]of Object.entries(B.attributes)){const B=C[R],y=I.getBufferView(B),e=T(B.type),g=(0,E.o)(I.getData(y),e,B.componentType,B.byteOffset||0,y.byteStride||(0,E.j)(B.componentType)*e,B.normalized||!1,B.count,!0);f.push({kind:N,dracoName:(L=N,"POSITION"===L?"POSITION":"NORMAL"===L?"NORMAL":L.startsWith("COLOR")?"COLOR":L.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:T(B.type),data:g}),M.push(y),x.push(B)}var L;const e={method:B.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},g=BI.Default._encodeAsync(f,y,e).then((C=>{if(!C)return void Q.b.Error("Draco encoding failed for primitive.");const y={bufferView:-1,attributes:C.attributeIds},f=I.createBufferView(C.data);I.setBufferView(y,f);for(const B of M)this._bufferViewsUsed.add(B);for(const B of x)this._accessorsUsed.add(B);B.extensions||(B.extensions={}),B.extensions[II]=y})).catch((B=>{Q.b.Error("Draco encoding failed for primitive: "+B)}));this._encodePromises.push(g),this._wasUsed=!0}async preGenerateBinaryAsync(B){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((I=>{B.getPropertiesWithBufferView(I).every((B=>this._accessorsUsed.has(B)))&&B.removeBufferView(I)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}vB.RegisterExtension(II,(B=>new CI(B)));var MI=C(11777);const xI="KHR_lights_punctual",yI={name:"",color:[1,1,1],AL:1,range:Number.MAX_VALUE},fI={innerConeAngle:0,outerConeAngle:Math.PI/4},LI=M.HI.Backward();class eI{constructor(B){this.name=xI,this.enabled=!0,this.required=!1,this._exporter=B}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[xI]=this._lights}async postExportNodeAsync(B,I,C,x,y){return await new Promise((f=>{if(!(C instanceof GB.c))return void f(I);const L=C.getTypeID()==GB.c.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==GB.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==GB.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!L||!(C instanceof MI.e))return Q.b.Warn(`${B}: Light ${C.name} is not supported in ${xI}`),void f(I);if(C.falloffType!==GB.c.FALLOFF_GLTF&&Q.b.Warn(`${B}: Light falloff for ${C.name} does not match the ${xI} specification!`),!C.position.equalsToFloats(0,0,0)){const B=M.TmpVectors.HI[0].M(C.position);y&&w(B),I.translation=B.Df()}if("point"!==L){const B=C.direction.normalizeToRef(M.TmpVectors.HI[0]);y&&w(B);const x=M.Quaternion.FromUnitVectorsToRef(LI,B,M.TmpVectors.Quaternion[0]);M.Quaternion.IsIdentity(x)||(I.rotation=x.Df())}const e={type:L,name:C.name,color:C.DL.Df(),AL:C.AL,range:C.range};if(MB(e,yI),"spot"===L){const B=C;e.spot={innerConeAngle:B.innerAngle/2,outerConeAngle:B.angle/2},MB(e.spot,fI)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(e);const g={nx:this._lights.lights.length-1},N=C.parent;if(N&&IB(C,N)){const B=x.get(N);if(B){const C=this._exporter._nodes[B];return BB(I,C),C.extensions||(C.extensions={}),C.extensions[xI]=g,void f(null)}}I.extensions||(I.extensions={}),I.extensions[xI]=g,f(I)}))}}vB.RegisterExtension(xI,(B=>new eI(B)));var gI=C(11690);const NI="KHR_materials_anisotropy";class RI{constructor(B){this.name=NI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof gI.d&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&M.push(C.anisotropy.texture),M):[]}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof gI.d){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void B(I);this._wasUsed=!0,I.extensions=I.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),x={anisotropyStrength:C.anisotropy.AL,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:M??void 0};null!==x.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),I.extensions[NI]=x}B(I)}))}}vB.RegisterExtension(NI,(B=>new RI(B)));const HI="KHR_materials_clearcoat";class FI{constructor(B){this.name=HI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof gI.d&&C.clearCoat.isEnabled?(C.clearCoat.texture&&M.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&M.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&M.push(C.clearCoat.bumpTexture),M):[]}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof gI.d){if(!C.clearCoat.isEnabled)return void B(I);this._wasUsed=!0,I.extensions=I.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let y;y=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&x.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&x.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const f=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),L={clearcoatFactor:C.clearCoat.AL,clearcoatTexture:M??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:y??void 0,clearcoatNormalTexture:f??void 0};null===L.clearcoatTexture&&null===L.clearcoatRoughnessTexture&&null===L.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),I.extensions[HI]=L}B(I)}))}}vB.RegisterExtension(HI,(B=>new FI(B)));const kI="KHR_materials_diffuse_transmission";function qI(B,I){const C=I.subSurface;let M=null;return C.translucencyIntensityTexture?M=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(M=C.thicknessTexture),M&&!C.useGltfStyleTextures?(Q.b.Warn(`${B}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${I.name}`,1),null):M}class SI{constructor(B){this.name=kI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];if(C instanceof kB.c&&this._isExtensionEnabled(C)){const I=qI(B,C);return I&&M.push(I),C.subSurface.translucencyColorTexture&&M.push(C.subSurface.translucencyColorTexture),M}return M}_isExtensionEnabled(B){if(B.unlit)return!1;const I=B.subSurface;return!!I.isTranslucencyEnabled&&(!B.unlit&&!I.useAlbedoToTintTranslucency&&I.useGltfStyleTextures&&1===I.volumeIndexOfRefraction&&0===I.minimumThickness&&0===I.maximumThickness)}postExportMaterialAsync(B,I,C){return new Promise((M=>{if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const M=C.subSurface,x=qI(B,C),y=0==M.translucencyIntensity?void 0:M.translucencyIntensity,f=this._exporter._materialExporter.getTextureInfo(x)??void 0,L=!M.translucencyColor||M.translucencyColor.equalsFloats(1,1,1)?void 0:M.translucencyColor.Df(),e=this._exporter._materialExporter.getTextureInfo(M.translucencyColorTexture)??void 0,g={diffuseTransmissionFactor:y,diffuseTransmissionTexture:f,diffuseTransmissionColorFactor:L,diffuseTransmissionColorTexture:e};(f||e)&&this._exporter._materialNeedsUVsSet.add(C),I.extensions=I.extensions||{},I.extensions[kI]=g}M(I)}))}}vB.RegisterExtension(kI,(B=>new SI(B)));const oI="KHR_materials_dispersion";class UI{constructor(){this.name=oI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){if(B.unlit)return!1;const I=B.subSurface;return!(!I.isRefractionEnabled&&!I.isDispersionEnabled)}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const B={dispersion:C.subSurface.dispersion};I.extensions=I.extensions||{},I.extensions[oI]=B}B(I)}))}}vB.RegisterExtension(oI,(()=>new UI));const GI="KHR_materials_emissive_strength";class VI{constructor(){this.name=GI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(B,I,C){return await new Promise((B=>{if(!(C instanceof kB.c))return B(I);const M=C.emissiveColor.Df(),x=Math.max(...M);if(x>1){this._wasUsed=!0,I.extensions||(I.extensions={});const B={emissiveStrength:x},M=C.emissiveColor.scale(1/B.emissiveStrength);I.emissiveFactor=M.Df(),I.extensions[GI]=B}return B(I)}))}}vB.RegisterExtension(GI,(B=>new VI));const cI="KHR_materials_ior";class tI{constructor(){this.name=cI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.indexOfRefraction&&1.5!=B.indexOfRefraction)}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const B={ior:C.indexOfRefraction};I.extensions=I.extensions||{},I.extensions[cI]=B}B(I)}))}}vB.RegisterExtension(cI,(B=>new tI));const rI="KHR_materials_iridescence";class AI{constructor(B){this.name=rI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof gI.d&&C.iridescence.isEnabled?(C.iridescence.texture&&M.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&M.push(C.iridescence.thicknessTexture),M):[]}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof gI.d){if(!C.iridescence.isEnabled)return void B(I);this._wasUsed=!0,I.extensions=I.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),x=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),y={iridescenceFactor:C.iridescence.AL,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:M??void 0,iridescenceThicknessTexture:x??void 0};null===y.iridescenceTexture&&null===y.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),I.extensions[rI]=y}B(I)}))}}vB.RegisterExtension(rI,(B=>new AI(B)));const DI="KHR_materials_sheen";class JI{constructor(B){this.name=DI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){return C instanceof kB.c&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(B,I,C){return await new Promise((B=>{if(C instanceof kB.c){if(!C.sheen.isEnabled)return void B(I);this._wasUsed=!0,null==I.extensions&&(I.extensions={});const M={sheenColorFactor:C.sheen.color.Df(),sheenRoughnessFactor:C.sheen.roughness??0};null===M.sheenColorTexture&&null===M.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(M.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?M.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(M.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),I.extensions[DI]=M}B(I)}))}}vB.RegisterExtension(DI,(B=>new JI(B)));const iI="KHR_materials_specular";class uI{constructor(B){this.name=iI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof kB.c&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&M.push(C.metallicReflectanceTexture),C.reflectanceTexture&&M.push(C.reflectanceTexture),M):M}_isExtensionEnabled(B){return!B.unlit&&(void 0!=B.metallicF0Factor&&1!=B.metallicF0Factor||void 0!=B.metallicReflectanceColor&&!B.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.metallicReflectanceTexture||null!=B.reflectanceTexture}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0,I.extensions=I.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,M=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,x={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:B,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.Df(),specularColorTexture:M};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),I.extensions[iI]=x}B(I)}))}}vB.RegisterExtension(iI,(B=>new uI(B)));const pI="KHR_materials_transmission";class nI{constructor(B){this.name=pI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof kB.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&M.push(C.subSurface.thicknessTexture),M):M}_isExtensionEnabled(B){if(B.unlit)return!1;const I=B.subSurface;return I.isRefractionEnabled&&void 0!=I.refractionIntensity&&0!=I.refractionIntensity||this._hasTexturesExtension(B)}_hasTexturesExtension(B){return null!=B.subSurface.refractionIntensityTexture}async postExportMaterialAsync(B,I,C){if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const M=C.subSurface,x={transmissionFactor:0===M.refractionIntensity?void 0:M.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),M.refractionIntensityTexture)if(M.useGltfStyleTextures){const B=await this._exporter._materialExporter.exportTextureAsync(M.refractionIntensityTexture,"image/png");B&&(x.transmissionTexture=B)}else Q.b.Warn(`${B}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);I.extensions||(I.extensions={}),I.extensions[pI]=x}return I}}vB.RegisterExtension(pI,(B=>new nI(B)));const OI="KHR_materials_unlit";class aI{constructor(){this.name=OI,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(B,I,C){return new Promise((B=>{let M=!1;C instanceof kB.c?M=C.unlit:C instanceof qB.qI&&(M=C.disableLighting),M&&(this._wasUsed=!0,null==I.extensions&&(I.extensions={}),I.extensions[OI]={}),B(I)}))}}vB.RegisterExtension(OI,(()=>new aI));const WI="KHR_materials_volume";class dI{constructor(B){this.name=WI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof kB.c&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&M.push(C.subSurface.thicknessTexture),M):M}_isExtensionEnabled(B){if(B.unlit)return!1;const I=B.subSurface;return!(!I.isRefractionEnabled&&!I.isTranslucencyEnabled)&&(void 0!=I.maximumThickness&&0!=I.maximumThickness||void 0!=I.tintColorAtDistance&&I.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=I.tintColor&&I.tintColor!=S.SI.White()||this._hasTexturesExtension(B))}_hasTexturesExtension(B){return null!=B.subSurface.thicknessTexture}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof kB.c&&this._isExtensionEnabled(C)){this._wasUsed=!0;const B=C.subSurface,M={thicknessFactor:0==B.maximumThickness?void 0:B.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(B.thicknessTexture)??void 0,attenuationDistance:B.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:B.tintColorAtDistance,attenuationColor:B.tintColor.equalsFloats(1,1,1)?void 0:B.tintColor.Df()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),I.extensions=I.extensions||{},I.extensions[WI]=M}B(I)}))}}vB.RegisterExtension(WI,(B=>new dI(B)));const lI="EXT_materials_diffuse_roughness";class EI{constructor(B){this.name=lI,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=B}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(B,I,C){const M=[];return C instanceof gI.d&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&M.push(C._baseDiffuseRoughnessTexture),M):[]}postExportMaterialAsync(B,I,C){return new Promise((B=>{if(C instanceof gI.d){if(!C._baseDiffuseRoughness)return void B(I);this._wasUsed=!0,I.extensions=I.extensions||{};const M=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),x={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:M??void 0};null!==x.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),I.extensions[lI]=x}B(I)}))}}vB.RegisterExtension(lI,(B=>new EI(B)));const QI="KHR_texture_transform";class ZI{constructor(){this.name=QI,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(B,I,C){if(C.rB()||x.Tools.Warn(`${B}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(x.Tools.Warn(`${B}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const M={};let y=!1;if(0===C.uOffset&&0===C.vOffset||(M.offset=[C.uOffset,C.vOffset],y=!0),1===C.uScale&&1===C.vScale||(M.scale=[C.uScale,C.vScale],y=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void x.Tools.Warn(`${B}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${QI}.`);x.Tools.Warn(`${B}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${QI}.`),M.offset=function(B){const{uOffset:I,vOffset:C,uRotationCenter:M,vRotationCenter:x,uScale:y,vScale:f,wAng:L}=B,e=Math.cos(L),g=Math.sin(L),N=M*y,R=x*f;return[I+(N*(1-e)+R*g),C+(R*(1-e)-N*g)]}(C)}M.rotation=-C.wAng,y=!0}0!==C.coordinatesIndex&&(M.texCoord=C.coordinatesIndex,y=!0),y&&(this._wasUsed=!0,I.extensions||(I.extensions={}),I.extensions[QI]=M)}}vB.RegisterExtension(QI,(()=>new ZI));class zI{static CreateSTL(B){let I=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],y=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],f=arguments.length>5&&void 0!==arguments[5]&&arguments[5],L=arguments.length>6&&void 0!==arguments[6]&&arguments[6],e=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const g=function(B,I,C){const x=[3*B[C],3*B[C+1],3*B[C+2]],y=[new M.HI(I[x[0]],I[x[0]+2],I[x[0]+1]),new M.HI(I[x[1]],I[x[1]+2],I[x[1]+1]),new M.HI(I[x[2]],I[x[2]+2],I[x[2]+1])],f=y[0].FI(y[1]),L=y[2].FI(y[1]);return{v:y,n:M.HI.Cross(L,f).normalize()}},R=function(B,I,C,M){return I=H(B,I,C.x,M),I=H(B,I,C.y,M),H(B,I,C.z,M)},H=function(B,I,C,M){return B.setFloat32(I,C,M),I+4},k=function(B){if(L){let I=B;B instanceof F.d&&(I=B.sourceMesh);const C=I.getVerticesData(N.g.PositionKind,!0,!0);if(!C)return[];const x=M.HI.Zero();let y;for(y=0;y<C.length;y+=3)M.HI.TransformCoordinatesFromFloatsToRef(C[y],C[y+1],C[y+2],B.nf(!0),x).toArray(C,y);return C}return B.getVerticesData(N.g.PositionKind)||[]};L&&(f=!0);let q="",S=0,o=0;if(x){for(let C=0;C<B.length;C++){const I=B[C].bf();S+=I?I.length/3:0}const I=new ArrayBuffer(84+50*S);q=new DataView(I),o+=80,q.setUint32(o,S,y),o+=4}else e||(q="solid stlmesh\r\n");for(let M=0;M<B.length;M++){const I=B[M];!x&&e&&(q+="solid "+I.name+"\r\n"),!f&&I instanceof UB.b&&I.bakeCurrentTransformIntoVertices();const C=k(I),L=I.bf()||[];for(let B=0;B<L.length;B+=3){const I=g(L,C,B);x?(o=R(q,o,I.n,y),o=R(q,o,I.v[0],y),o=R(q,o,I.v[1],y),o=R(q,o,I.v[2],y),o+=2):(q+="\tfacet normal "+I.n.x+" "+I.n.y+" "+I.n.z+"\r\n",q+="\t\touter loop\r\n",q+="\t\t\tvertex "+I.v[0].x+" "+I.v[0].y+" "+I.v[0].z+"\r\n",q+="\t\t\tvertex "+I.v[1].x+" "+I.v[1].y+" "+I.v[1].z+"\r\n",q+="\t\t\tvertex "+I.v[2].x+" "+I.v[2].y+" "+I.v[2].z+"\r\n",q+="\t\tendloop\r\n",q+="\tendfacet\r\n")}!x&&e&&(q+="endsolid "+name+"\r\n")}if(x||e||(q+="endsolid stlmesh"),I){const B=document.createElement("a"),I=new Blob([q],{type:"application/octet-stream"});B.href=window.URL.createObjectURL(I),B.download=C+".stl",B.click()}return q}}function bI(B,I){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const M=[];for(let x=0;x<B.length/C;x++){const y=B[x*C],f=B[x*C+1],L=B[x*C+2];M.push(`(${y.toPrecision(I.precision)}, ${f.toPrecision(I.precision)}, ${L.toPrecision(I.precision)})`)}return M.join(", ")}function YI(B,I){const C=[];for(let M=0;M<B.length/2;M++){const x=B[2*M],y=B[2*M+1];C.push(`(${x.toPrecision(I.precision)}, ${(1-y).toPrecision(I.precision)})`)}return C.join(", ")}function vI(B,I){const C=B.getVerticesData(N.g.PositionKind),M=B.getVerticesData(N.g.NormalKind);if(C&&M)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(B){var I;const C=null!==(I=B.bf())&&void 0!==I&&I.length?B.getTotalIndices():B.getTotalVertices();return Array(C/3).fill(3).join(", ")}(B)}]\n\t\tint[] faceVertexIndices = [${function(B){const I=B.bf(),C=[];if(null!==I)for(let M=0;M<I.length;M++)C.push(I[M]);else{const I=B.getTotalVertices();for(let B=0;B<I;B++)C.push(B)}return C.join(", ")}(B)}]\n\t\tnormal3f[] normals = [${bI(M,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${bI(C,I)}]\n        ${function(B,I){let C="";for(let x=0;x<4;x++){const M=x>0?x:"",y=B.getVerticesData(N.g.UVKind+(M?M+1:""));y&&(C+=`\n\t\ttexCoord2f[] primvars:st${M} = [${YI(y,I)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const M=B.getVerticesData(N.g.ColorKind);return M&&(C+=`\n\tcolor3f[] primvars:displayColor = [${bI(M,I,M.length/B.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(B,I)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function sI(B,I){return`\n        def "Geometry"\n        {\n        ${vI(B,I)}\n        }\n        `}function XI(B){let I='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return I+=B,fflate.strToU8(I)}function TI(B){const I=B.m;return`( ${PI(I,0)}, ${PI(I,4)}, ${PI(I,8)}, ${PI(I,12)} )`}function PI(B,I){return`(${B[I+0]}, ${B[I+1]}, ${B[I+2]}, ${B[I+3]})`}function hI(B){const I="Object_"+B.uniqueId,C=function(B){const I=B.getWorldMatrix().clone(),C=B.rB().useRightHandedSystem;if(!C){let M=B.parent;for(;M;){if(fB(M,C)){I.multiplyToRef(M.getWorldMatrix().invert(),I);break}M=M.parent}}return I.determinant()<0&&x.Tools.Warn(`Exporting mesh ${B.name} with negative scale. Result may look incorrect in destination engine.`),I}(B),M=TI(C);return`def Xform "${I}" (\n\tprepend references = @./geometries/Geometry_${B.zf.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${M}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${B.material.uniqueId}>\n}\n\n`}function jI(B){switch(B){case r.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case r.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case r.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function wI(B){return`(${B.x}, ${B.y})`}function KI(B){return`(${B.r}, ${B.g}, ${B.b})`}function mI(B,I,C,x,y,f){const L=B.getInternalTexture().uniqueId+"_"+B.invertY;y[L]=B;const e=B.coordinatesIndex>0?"st"+B.coordinatesIndex:"st",g=new M.Vector2(B.uScale,B.vScale),N=new M.Vector2(B.uOffset,B.vOffset),R=B.wAng,H=Math.sin(R),F=Math.cos(R);return N.y=1-N.y-g.y,N.x+=H*g.x,N.y+=(1-F)*g.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${e}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${I.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(R*(180/Math.PI)).toFixed(f.precision)}\n        float2 inputs:scale = ${wI(g)}\n        float2 inputs:translation = ${wI(N)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${B.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${L}.png@\n        float2 inputs:st.connect = </Materials/Material_${I.uniqueId}/Transform2d_${C}.outputs:result>\n        ${x?"float4 inputs:scale = "+function(B){return`(${B.r}, ${B.g}, ${B.b}, 1.0)`}(x):""}\n        token inputs:sourceColorSpace = "${B.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${jI(B.wrapU)}"\n        token inputs:wrapT = "${jI(B.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${I.needAlphaBlending()?"float outputs:a":""}\n    }`}function BC(B,I,C){const M="\t\t\t",x=[],y=[],{diffuseMap:f,DL:L,alphaCutOff:e,emissiveMap:g,emissive:N,normalMap:R,roughnessMap:H,roughnessChannel:F,roughness:k,metalnessMap:q,metalnessChannel:o,metalness:U,aoMap:G,aoMapChannel:V,aoMapIntensity:c,alphaMap:t,ior:r,clearCoatEnabled:A,clearCoat:D,clearCoatMap:J,clearCoatRoughness:i,clearCoatRoughnessMap:u}=function(B){const I={diffuseMap:null,DL:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return B instanceof qB.qI?{...I,diffuseMap:B.diffuseTexture,DL:B.diffuseColor,alphaCutOff:B.alphaCutOff,emissiveMap:B.emissiveTexture,emissive:B.emissiveColor,roughness:1,alphaMap:B.opacityTexture}:B instanceof gI.d?{...I,diffuseMap:B._albedoTexture,DL:B._albedoColor,alphaCutOff:B._alphaCutOff,emissiveMap:B._emissiveTexture,emissive:B._emissiveColor,normalMap:B._bumpTexture,roughnessMap:B._metallicTexture,roughnessChannel:B._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:B._roughness??1,metalnessMap:B._metallicTexture,metalnessChannel:B._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:B._metallic??0,aoMap:B._ambientTexture,aoMapChannel:B._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:B._ambientTextureStrength,alphaMap:B._opacityTexture,ior:B.subSurface.indexOfRefraction,clearCoatEnabled:B.clearCoat.isEnabled,clearCoat:B.clearCoat.AL,clearCoatMap:B.clearCoat.texture,clearCoatRoughness:B.clearCoat.roughness,clearCoatRoughnessMap:B.clearCoat.useRoughnessFromMainTexture?B.clearCoat.texture:B.clearCoat.textureRoughness}:I}(B);return null!==f?(x.push(`${M}color3f inputs:diffuseColor.connect = </Materials/Material_${B.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:rgb>`),B.needAlphaBlending()?x.push(`${M}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`):B.needAlphaTesting()&&(x.push(`${M}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${f.uniqueId}_diffuse.outputs:a>`),x.push(`${M}float inputs:opacityThreshold = ${e}`)),y.push(mI(f,B,"diffuse",L,I,C))):x.push(`${M}color3f inputs:diffuseColor = ${KI(L||S.SI.White())}`),null!==g?(x.push(`${M}color3f inputs:emissiveColor.connect = </Materials/Material_${B.uniqueId}/Texture_${g.uniqueId}_emissive.outputs:rgb>`),y.push(mI(g,B,"emissive",N,I,C))):N&&N.toLuminance()>0&&x.push(`${M}color3f inputs:emissiveColor = ${KI(N)}`),null!==R&&(x.push(`${M}normal3f inputs:normal.connect = </Materials/Material_${B.uniqueId}/Texture_${R.uniqueId}_normal.outputs:rgb>`),y.push(mI(R,B,"normal",null,I,C))),null!==G&&(x.push(`${M}float inputs:occlusion.connect = </Materials/Material_${B.uniqueId}/Texture_${G.uniqueId}_occlusion.outputs:${V}>`),y.push(mI(G,B,"occlusion",new S.SI(c,c,c),I,C))),null!==H?(x.push(`${M}float inputs:roughness.connect = </Materials/Material_${B.uniqueId}/Texture_${H.uniqueId}_roughness.outputs:${F}>`),y.push(mI(H,B,"roughness",new S.SI(k,k,k),I,C))):x.push(`${M}float inputs:roughness = ${k}`),null!==q?(x.push(`${M}float inputs:metallic.connect = </Materials/Material_${B.uniqueId}/Texture_${q.uniqueId}_metallic.outputs:${o}>`),y.push(mI(q,B,"metallic",new S.SI(U,U,U),I,C))):x.push(`${M}float inputs:metallic = ${U}`),null!==t?(x.push(`${M}float inputs:opacity.connect = </Materials/Material_${B.uniqueId}/Texture_${t.uniqueId}_opacity.outputs:r>`),x.push(`${M}float inputs:opacityThreshold = 0.0001`),y.push(mI(t,B,"opacity",null,I,C))):x.push(`${M}float inputs:opacity = ${B.alpha}`),A&&(null!==J?(x.push(`${M}float inputs:clearcoat.connect = </Materials/Material_${B.uniqueId}/Texture_${J.uniqueId}_clearcoat.outputs:r>`),y.push(mI(J,B,"clearcoat",new S.SI(D,D,D),I,C))):x.push(`${M}float inputs:clearcoat = ${D}`),null!==u?(x.push(`${M}float inputs:clearcoatRoughness.connect = </Materials/Material_${B.uniqueId}/Texture_${u.uniqueId}_clearcoatRoughness.outputs:g>`),y.push(mI(u,B,"clearcoatRoughness",new S.SI(i,i,i),I,C))):x.push(`${M}float inputs:clearcoatRoughness = ${i}`)),x.push(`${M}float inputs:ior = ${r}`),`\n\tdef Material "Material_${B.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${x.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${B.uniqueId}/PreviewSurface.outputs:surface>\n\n${y.join("\n")}\n\n\t}\n`}async function IC(B,I,C){const y={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...I};"undefined"===typeof fflate&&await x.Tools.LoadScriptAsync(y.fflateUrl);const f={};f[y.modelFileName]=null;let L='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';L+=function(B){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===B.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${B.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${B.planeAnchoringAlignment}"`:""}\n            `}(y);const e={};for(const M of B.meshes){if(0===M.getTotalVertices())continue;const B=M,I=B.zf,g=B.material;if(!g||!I||C&&!C(B))continue;if(-1!==["qI","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(g.getClassName())){const C="geometries/Geometry_"+I.uniqueId+".usda";if(!(C in f)){const B=sI(I,y);f[C]=XI(B)}g.uniqueId in e||(e[g.uniqueId]=g),L+=hI(B)}else x.Tools.Warn("USDZExportAsync does not support this material type: "+g.getClassName())}B.activeCamera&&y.exportCamera&&(L+=function(B,I){const C="Camera_"+B.uniqueId,x=TI(M.Matrix.RotationY(Math.PI).multiply(B.getWorldMatrix()));if(B.mode===r.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${x}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.uf.toPrecision(I.precision)}, ${B.maxZ.toPrecision(I.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(B.orthoLeft||1)+Math.abs(B.orthoRight||1))).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(B.orthoTop||1)+Math.abs(B.orthoBottom||1))).toPrecision(I.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const M=B.getEngine().getAspectRatio(B),y=I.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${x}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${B.uf.toPrecision(I.precision)}, ${B.maxZ.toPrecision(I.precision)})\n\t\t\tfloat focalLength = ${(y/(2*Math.tan(.5*B.fov))).toPrecision(I.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(y*M).toPrecision(I.precision)}\n\t\t\tfloat verticalAperture = ${(y/M).toPrecision(I.precision)}            \n\t\t}\n\t\n\t`}}(B.activeCamera,y)),L+="\n            }\n        }\n    }";const g={};L+=function(B,I,C){const M=[];for(const x in B){const y=B[x];M.push(BC(y,I,C))}return`\n    def "Materials"\n{\n${M.join("")}\n}\n\n`}(e,g,y),f[y.modelFileName]=fflate.strToU8(L);for(const M in g){const B=g[M],I=B.getSize(),C=await B.readPixels();if(!C)throw new Error("Texture data is not available");const x=await A.DumpTools.DumpDataAsync(I.width,I.height,C,"image/png",void 0,!1,!0);f[`textures/Texture_${M}.png`]=new Uint8Array(x).slice()}let N=0;for(const M in f){const B=f[M];if(!B)continue;N+=34+M.length;const I=63&N;if(4!==I){const C=new Uint8Array(64-I);f[M]=[B,{extra:{12345:C}}]}N=B.length}return fflate.zipSync(f,{level:0})}}}]);