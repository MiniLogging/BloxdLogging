"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11547:(g,w,q)=>{q.r(w),q.d(w,{EXT_materials_diffuse_roughness:()=>Bw,EXT_mesh_gpu_instancing:()=>ug,GLTF2Export:()=>Yg,GLTFData:()=>z,KHR_draco_mesh_compression:()=>qw,KHR_lights_punctual:()=>Tw,KHR_materials_anisotropy:()=>mw,KHR_materials_clearcoat:()=>yw,KHR_materials_diffuse_transmission:()=>lw,KHR_materials_dispersion:()=>xw,KHR_materials_emissive_strength:()=>dw,KHR_materials_ior:()=>Uw,KHR_materials_iridescence:()=>aw,KHR_materials_sheen:()=>Cw,KHR_materials_specular:()=>Pw,KHR_materials_transmission:()=>Mw,KHR_materials_unlit:()=>sw,KHR_materials_volume:()=>vw,KHR_texture_transform:()=>Ow,OBJExport:()=>S,STLExport:()=>Ew,USDZExportAsync:()=>wq,_ConvertToGLTFPBRMetallicRoughness:()=>V,_SolveMetallic:()=>M,__IGLTFExporterExtension:()=>i});var R=q(11180),o=q(10991),r=q(11469);class S{static OBJ(g,w,q,S){const i=[];let T=1,z=1;w&&(q||(q="mat"),i.push("mtllib "+q+".mtl"));for(let t=0;t<g.length;t++){const q=g[t],m=q.name||`mesh${t}}`;i.push(`o ${m}`);let e=null;if(S){const g=q.ii(!0);e=new R.Matrix,g.invertToRef(e),q.bakeTransformIntoVertices(g)}if(w){const g=q.material;g&&i.push("usemtl "+g.id)}const y=q.Ti;if(!y){o.Tools.Warn("No geometry is present on the mesh");continue}const L=y.getVerticesData("position"),A=y.getVerticesData("Lw"),l=y.getVerticesData("uv"),J=y.zi();let x=0,G=0;if(!L||!J){o.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const d=g[0].Ng().useRightHandedSystem?1:-1;for(let g=0;g<L.length;g+=3)i.push("v "+L[g]*d+" "+L[g+1]+" "+L[g+2]),x++;if(null!=A)for(let g=0;g<A.length;g+=3)i.push("vn "+A[g]*d+" "+A[g+1]+" "+A[g+2]);if(null!=l)for(let g=0;g<l.length;g+=2)i.push("vt "+l[g]+" "+l[g+1]),G++;const D=["","",""],U=(q.material||q.Ng().defaultMaterial)._getEffectiveOrientation(q),[N,a]=U===r.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let g=0;g<J.length;g+=3){const w=[String(J[g]+T),String(J[g+N]+T),String(J[g+a]+T)],q=[String(J[g]+z),String(J[g+N]+z),String(J[g+a]+z)],R=w,o=null!=l?q:D,r=null!=A?w:D;i.push("f "+R[0]+"/"+o[0]+"/"+r[0]+" "+R[1]+"/"+o[1]+"/"+r[1]+" "+R[2]+"/"+o[2]+"/"+r[2])}S&&e&&q.bakeTransformIntoVertices(e),T+=x,z+=G}return i.join("\n")}static MTL(g){const w=[],q=g.material;w.push("newmtl mat1"),w.push("  Ns "+q.specularPower.toFixed(4)),w.push("  Ni 1.5000"),w.push("  d "+q.alpha.toFixed(4)),w.push("  Tr 0.0000"),w.push("  Tf 1.0000 1.0000 1.0000"),w.push("  illum 2"),w.push("  Ka "+q.ambientColor.r.toFixed(4)+" "+q.ambientColor.g.toFixed(4)+" "+q.ambientColor.b.toFixed(4)),w.push("  Kd "+q.diffuseColor.r.toFixed(4)+" "+q.diffuseColor.g.toFixed(4)+" "+q.diffuseColor.b.toFixed(4)),w.push("  Ks "+q.specularColor.r.toFixed(4)+" "+q.specularColor.g.toFixed(4)+" "+q.specularColor.b.toFixed(4)),w.push("  Ke "+q.emissiveColor.r.toFixed(4)+" "+q.emissiveColor.g.toFixed(4)+" "+q.emissiveColor.b.toFixed(4));q.ambientTexture&&w.push("  map_Ka "+q.ambientTexture.name),q.diffuseTexture&&w.push("  map_Kd "+q.diffuseTexture.name),q.specularTexture&&w.push("  map_Ks "+q.specularTexture.name),q.bumpTexture&&w.push("  map_bump -imfchan z "+q.bumpTexture.name),q.opacityTexture&&w.push("  map_d "+q.opacityTexture.name);return w.join("\n")}}var i=0,T=q(11043);class z{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const g in this.files){const w=this.files[g],q=new Blob([w],{type:(0,T.g)(g)});o.Tools.Download(q,g)}}}var t=q(11250),m=q(11552),e=q(11567),y=q(11582),L=q(11291),A=q(11034),l=q(11235),J=q(11195);const x=J.HighestCommonFactor,G={...J,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:x};var d=q(11383),D=q(11152),U=q(11612),N=q(11617),a=q(11381);const H=1e-6,C=new l.Jw(.04,.04,.04),c=1024,P=l.Jw.White(),j=l.Jw.Black();function M(g,w,q){if(w<C.r)return 0;const R=C.r,o=g*q/(1-C.r)+w-2*C.r,r=o*o-4*R*(C.r-w);return G.Clamp((-o+Math.sqrt(r))/(2*R),0,1)}function V(g){const w=g.diffuseColor.toLinearSpace(g.Ng().getEngine().useExactSrgbConversions).scale(.5),q=g.alpha,o=function(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new R.Vector2(0,1),q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new R.Vector2(0,.1),o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new R.Vector2(0,.1),r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new R.Vector2(1300,.1);return function(g,w,q,R,o){return(1-g)*(1-g)*(1-g)*w+3*(1-g)*(1-g)*g*q+3*(1-g)*g*g*R+g*g*g*o}(Math.pow(g/r.x,.333333),w.y,q.y,o.y,r.y)}(G.Clamp(g.specularPower,0,c));return{baseColorFactor:[w.r,w.g,w.b,q],metallicFactor:0,roughnessFactor:o}}function s(g,w){w.needAlphaBlending()?g.alphaMode="BLEND":w.needAlphaTesting()&&(g.alphaMode="MASK",g.alphaCutoff=w.alphaCutOff)}function h(g,w,q){const R=new Uint8Array(g*w*4);for(let o=0;o<R.length;o+=4)R[o]=R[o+1]=R[o+2]=R[o+3]=255;return U.d.CreateRGBATexture(R,g,w,q)}function v(g){if(g instanceof Uint8Array){const w=g.length,q=new Float32Array(g.length);for(let R=0;R<w;++R)q[R]=g[R]/255;return q}if(g instanceof Float32Array)return g;throw new Error("Unsupported pixel format!")}class b{constructor(g){this._exporter=g,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(g){return g?this._textureMap.get(g)??null:null}async exportStandardMaterialAsync(g,w,q){const R=V(g),r={name:g.name};if(null==g.ti||g.ti||(g.twoSidedLighting||o.Tools.Warn(g.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),r.doubleSided=!0),q){const q=[],o=g.diffuseTexture;o&&q.push(this.exportTextureAsync(o,w).then((g=>{g&&(R.baseColorTexture=g)})));const S=g.bumpTexture;S&&q.push(this.exportTextureAsync(S,w).then((g=>{g&&(r.normalTexture=g,1!==S.level&&(r.normalTexture.scale=S.level))})));const i=g.emissiveTexture;i&&(r.emissiveFactor=[1,1,1],q.push(this.exportTextureAsync(i,w).then((g=>{g&&(r.emissiveTexture=g)}))));const T=g.ambientTexture;T&&q.push(this.exportTextureAsync(T,w).then((g=>{if(g){const w={index:g.index};r.occlusionTexture=w}}))),q.length>0&&(this._exporter._materialNeedsUVsSet.add(g),await Promise.all(q))}(g.alpha<1||g.opacityTexture)&&(g.alphaMode===N.c.ALPHA_COMBINE?r.alphaMode="BLEND":o.Tools.Warn(g.name+": glTF 2.0 does not support alpha mode: "+g.alphaMode.toString())),g.emissiveColor&&!g.emissiveColor.equalsWithEpsilon(j,H)&&(r.emissiveFactor=g.emissiveColor.qi()),r.pbrMetallicRoughness=R,s(r,g),await this._finishMaterialAsync(r,g,w);const S=this._exporter._materials;return S.push(r),S.length-1}async _finishMaterialAsync(g,w,q){const R=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",g,w),o=[];for(const r of R)o.push(this.exportTextureAsync(r,q));await Promise.all(o),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",g,w)}async _getImageDataAsync(g,w,R,o){const r=N.c.TEXTURETYPE_UNSIGNED_BYTE,S=this._exporter._babylonScene,i=S.getEngine(),T=i.createRawTexture(g,w,R,N.c.TEXTUREFORMAT_RGBA,!1,!0,D.e.NEAREST_SAMPLINGMODE,null,r);i.isWebGPU?await q.e(51).then(q.bind(q,13598)):await q.e(52).then(q.bind(q,13605)),await d.l.ApplyPostProcess("pass",T,S,r,N.c.TEXTURE_NEAREST_SAMPLINGMODE,N.c.TEXTUREFORMAT_RGBA);const z=await i._readTexturePixels(T,w,R);return await a.DumpTools.DumpDataAsync(w,R,z,o,void 0,!0,!0)}_resizeTexturesToSameDimensions(g,w,q){const R=g?g.getSize():{width:0,height:0},o=w?w.getSize():{width:0,height:0};let r,S;return R.width<o.width?(r=g&&g instanceof D.e?d.l.CreateResizedCopy(g,o.width,o.height,!0):h(o.width,o.height,q),S=w):R.width>o.width?(S=w&&w instanceof D.e?d.l.CreateResizedCopy(w,R.width,R.height,!0):h(R.width,R.height,q),r=g):(r=g,S=w),{texture1:r,texture2:S}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(g,w,q,R){const o=new Array;if(!g&&!w)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const r=g?g.Ng():w?w.Ng():null;if(r){var S;const i=this._resizeTexturesToSameDimensions(g,w,r),T=null===(S=i.texture1)||void 0===S?void 0:S.getSize();let z,t;const m=T.width,e=T.height,y=await i.texture1.readPixels(),L=await i.texture2.readPixels();if(!y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(z=v(y),!L)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");t=v(L);const A=t.byteLength,J=new Uint8Array(A),x=new Uint8Array(A),G=4,d=j;let D=0,U=0;for(let g=0;g<e;++g)for(let w=0;w<m;++w){const R=(m*g+w)*G,o={diffuseColor:new l.Jw(z[R],z[R+1],z[R+2]).toLinearSpace(r.getEngine().useExactSrgbConversions).multiply(q.diffuseColor),specularColor:new l.Jw(t[R],t[R+1],t[R+2]).toLinearSpace(r.getEngine().useExactSrgbConversions).multiply(q.specularColor),glossiness:t[R+3]*q.glossiness},S=this._convertSpecularGlossinessToMetallicRoughness(o);d.r=Math.max(d.r,S.baseColor.r),d.g=Math.max(d.g,S.baseColor.g),d.b=Math.max(d.b,S.baseColor.b),D=Math.max(D,S.metallic),U=Math.max(U,S.roughness),x[R]=255*S.baseColor.r,x[R+1]=255*S.baseColor.g,x[R+2]=255*S.baseColor.b,x[R+3]=i.texture1.oi?255*z[R+3]:255,J[R]=0,J[R+1]=255*S.roughness,J[R+2]=255*S.metallic,J[R+3]=255}const N={baseColor:d,metallic:D,roughness:U};let a=!1,C=!1;for(let g=0;g<e;++g)for(let w=0;w<m;++w){const q=(m*g+w)*G;x[q]/=N.baseColor.r>H?N.baseColor.r:1,x[q+1]/=N.baseColor.g>H?N.baseColor.g:1,x[q+2]/=N.baseColor.b>H?N.baseColor.b:1;const R=l.Jw.FromInts(x[q],x[q+1],x[q+2]).toGammaSpace(r.getEngine().useExactSrgbConversions);x[q]=255*R.r,x[q+1]=255*R.g,x[q+2]=255*R.b,R.equalsWithEpsilon(P,H)||(C=!0),J[q+1]/=N.roughness>H?N.roughness:1,J[q+2]/=N.metallic>H?N.metallic:1;l.Jw.FromInts(255,J[q+1],J[q+2]).equalsWithEpsilon(P,H)||(a=!0)}return a&&o.push(this._getImageDataAsync(J,m,e,R).then((g=>{N.metallicRoughnessTextureData=g}))),C&&o.push(this._getImageDataAsync(x,m,e,R).then((g=>{N.baseColorTextureData=g}))),await Promise.all(o).then((()=>N))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(g){const w=this._getPerceivedBrightness(g.diffuseColor),q=this._getPerceivedBrightness(g.specularColor),R=1-this._getMaxComponent(g.specularColor),o=M(w,q,R),r=g.diffuseColor.scale(R/(1-C.r)/Math.max(1-o)),S=g.specularColor.yw(C.scale(1-o)).scale(1/Math.max(o));let i=l.Jw.Lerp(r,S,o*o);i=i.clampToRef(0,1,i);return{baseColor:i,metallic:o,roughness:1-g.glossiness}}_getPerceivedBrightness(g){return g?Math.sqrt(.299*g.r*g.r+.587*g.g*g.g+.114*g.b*g.b):0}_getMaxComponent(g){return g?Math.max(g.r,Math.max(g.g,g.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(g,w,q,R){const o=[],r={baseColor:g._albedoColor,metallic:g._metallic,roughness:g._roughness};if(R){g._albedoTexture&&o.push(this.exportTextureAsync(g._albedoTexture,w).then((g=>{g&&(q.baseColorTexture=g)})));const R=g._metallicTexture;R&&o.push(this.exportTextureAsync(R,w).then((g=>{g&&(q.metallicRoughnessTexture=g)})))}return o.length>0&&(this._exporter._materialNeedsUVsSet.add(g),await Promise.all(o)),r}_getTextureSampler(g){const w={};if(!g||!(g instanceof D.e))return w;const q=this._getGLTFTextureWrapMode(g.wrapU);10497!==q&&(w.wrapS=q);const R=this._getGLTFTextureWrapMode(g.wrapV);switch(10497!==R&&(w.wrapT=R),g.samplingMode){case D.e.LINEAR_LINEAR:w.magFilter=9729,w.minFilter=9729;break;case D.e.LINEAR_NEAREST:w.magFilter=9729,w.minFilter=9728;break;case D.e.NEAREST_LINEAR:w.magFilter=9728,w.minFilter=9729;break;case D.e.NEAREST_LINEAR_MIPLINEAR:w.magFilter=9728,w.minFilter=9987;break;case D.e.NEAREST_NEAREST:w.magFilter=9728,w.minFilter=9728;break;case D.e.NEAREST_LINEAR_MIPNEAREST:w.magFilter=9728,w.minFilter=9985;break;case D.e.LINEAR_NEAREST_MIPNEAREST:w.magFilter=9729,w.minFilter=9984;break;case D.e.LINEAR_NEAREST_MIPLINEAR:w.magFilter=9729,w.minFilter=9986;break;case D.e.NEAREST_NEAREST_MIPLINEAR:w.magFilter=9728,w.minFilter=9986;break;case D.e.LINEAR_LINEAR_MIPLINEAR:w.magFilter=9729,w.minFilter=9987;break;case D.e.LINEAR_LINEAR_MIPNEAREST:w.magFilter=9729,w.minFilter=9985;break;case D.e.NEAREST_NEAREST_MIPNEAREST:w.magFilter=9728,w.minFilter=9984}return w}_getGLTFTextureWrapMode(g){switch(g){case D.e.WRAP_ADDRESSMODE:return 10497;case D.e.CLAMP_ADDRESSMODE:return 33071;case D.e.MIRROR_ADDRESSMODE:return 33648;default:return o.Tools.Error(`Unsupported Texture Wrap Mode ${g}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(g,w,q,R){const o={diffuseColor:g._albedoColor,specularColor:g._reflectivityColor,glossiness:g._microSurface},r=g._albedoTexture,S=g._reflectivityTexture,i=g._useMicroSurfaceFromReflectivityMapAlpha;if(S&&!i)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((r||S)&&R){this._exporter._materialNeedsUVsSet.add(g);const R=this._exportTextureSampler(r||S),i=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(r,S,o,w),T=this._exporter._textures;if(i.baseColorTextureData){const g=this._exportImage(`baseColor${T.length}`,w,i.baseColorTextureData);q.baseColorTexture=this._exportTextureInfo(g,R,null===r||void 0===r?void 0:r.coordinatesIndex)}if(i.metallicRoughnessTextureData){const g=this._exportImage(`metallicRoughness${T.length}`,w,i.metallicRoughnessTextureData);q.metallicRoughnessTexture=this._exportTextureInfo(g,R,null===S||void 0===S?void 0:S.coordinatesIndex)}return i}return this._convertSpecularGlossinessToMetallicRoughness(o)}async exportPBRMaterialAsync(g,w,q){const R={},o={name:g.name},r=g.isMetallicWorkflow();if(r){const w=g._albedoColor,q=g.alpha;w&&(R.baseColorFactor=[w.r,w.g,w.b,q])}const S=r?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(g,w,R,q):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(g,w,R,q);await this._setMetallicRoughnessPbrMaterialAsync(S,g,o,R,w,q),await this._finishMaterialAsync(o,g,w);const i=this._exporter._materials;return i.push(o),i.length-1}async _setMetallicRoughnessPbrMaterialAsync(g,w,q,R,r,S){if(s(q,w),g.baseColor.equalsWithEpsilon(P,H)&&G.WithinEpsilon(w.alpha,1,H)||(R.baseColorFactor=[g.baseColor.r,g.baseColor.g,g.baseColor.b,w.alpha]),null!=g.metallic&&1!==g.metallic&&(R.metallicFactor=g.metallic),null!=g.roughness&&1!==g.roughness&&(R.roughnessFactor=g.roughness),null==w.ti||w.ti||(w._twoSidedLighting||o.Tools.Warn(w.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),q.doubleSided=!0),S){const g=[],R=w._bumpTexture;R&&g.push(this.exportTextureAsync(R,r).then((g=>{g&&(q.normalTexture=g,1!==R.level&&(q.normalTexture.scale=R.level))})));const o=w._ambientTexture;o&&g.push(this.exportTextureAsync(o,r).then((g=>{if(g){const R={index:g.index,texCoord:g.texCoord,extensions:g.extensions};q.occlusionTexture=R;const o=w._ambientTextureStrength;o&&(R.strength=o)}})));const S=w._emissiveTexture;S&&g.push(this.exportTextureAsync(S,r).then((g=>{g&&(q.emissiveTexture=g)}))),g.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(g))}const i=w._emissiveColor;i.equalsWithEpsilon(j,H)||(q.emissiveFactor=i.qi()),q.pbrMetallicRoughness=R}_getPixelsFromTextureAsync(g){return function(g){switch(g){case N.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case N.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case N.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case N.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case N.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case N.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case N.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case N.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case N.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case N.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case N.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case N.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case N.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(g.textureFormat)?(0,d.j)(g,g._texture.width,g._texture.height):(g.textureType,N.c.TEXTURETYPE_UNSIGNED_BYTE,g.readPixels())}async exportTextureAsync(g,w){const q=this._exporter._extensionsPreExportTextureAsync("exporter",g,w);return q?await q.then((async q=>q?await this._exportTextureInfoAsync(q,w):await this._exportTextureInfoAsync(g,w))):await this._exportTextureInfoAsync(g,w)}async _exportTextureInfoAsync(g,w){let q=this._textureMap.get(g);if(!q){const R=await this._getPixelsFromTextureAsync(g);if(!R)return null;const r=this._exportTextureSampler(g),S=g.mimeType;if(S)switch(S){case"image/jpeg":case"image/png":case"image/webp":w=S;break;default:o.Tools.Warn(`Unsupported media type: ${S}. Exporting texture as PNG.`)}const i=this._internalTextureToImage,T=g.getInternalTexture().uniqueId;i[T]||(i[T]={});let z=i[T][w];if(void 0===z){const q=g.getSize();z=(async()=>{const o=await this._getImageDataAsync(R,q.width,q.height,w);return this._exportImage(g.name,w,o)})(),i[T][w]=z}q=this._exportTextureInfo(await z,r,g.coordinatesIndex),this._textureMap.set(g,q),this._exporter._extensionsPostExportTextures("exporter",q,g)}return q}_exportImage(g,w,q){const R=this._exporter._images;let r;if(this._exporter._shouldUseGlb){r={name:g,mimeType:w,bufferView:void 0};const R=this._exporter._bufferManager.createBufferView(new Uint8Array(q));this._exporter._bufferManager.setBufferView(r,R)}else{const S=g.replace(/\.\/|\/|\.\\|\\/g,"_"),i=function(g){switch(g){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(w);let T=S+i;R.some((g=>g.uri===T))&&(T=`${S}_${o.Tools.RandomId()}${i}`),r={name:g,uri:T},this._exporter._imageData[T]={data:q,mimeType:w}}return R.push(r),R.length-1}_exportTextureInfo(g,w,q){const R=this._exporter._textures;let o=R.findIndex((q=>q.sampler==w&&q.source===g));-1===o&&(o=R.length,R.push({source:g,sampler:w}));const r={index:o};return q&&(r.texCoord=q),r}_exportTextureSampler(g){const w=this._getTextureSampler(g),q=this._exporter._samplers,R=q.findIndex((g=>g.minFilter===w.minFilter&&g.magFilter===w.magFilter&&g.wrapS===w.wrapS&&g.wrapT===w.wrapT));return-1!==R?R:(q.push(w),q.length-1)}}var B=q(11262),f=q(11011),O=q(11620),E=q(11188);const Q=R.ew.Zero(),X=R.Quaternion.Identity(),K=R.ew.One(),Y=new R.ew(-1,1,1);function F(g,w){const{byteOffset:q,byteStride:R,type:o,normalized:r}=g,S=g.getSize(),i=w.reduce(((g,w)=>w.getTotalVertices()>g?w.getTotalVertices():g),-Number.MAX_VALUE);return{byteOffset:q,byteStride:R,componentCount:S,type:o,count:i*S,normalized:r,totalVertices:i,kind:g.getKind()}}function u(g){switch(g){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function n(g){switch(g){case t.h.PositionKind:case t.h.NormalKind:case t.h.TangentKind:case t.h.ColorKind:case t.h.MatricesIndicesKind:case t.h.MatricesIndicesExtraKind:case t.h.MatricesWeightsKind:case t.h.MatricesWeightsExtraKind:case t.h.UVKind:case t.h.UV2Kind:case t.h.UV3Kind:case t.h.UV4Kind:case t.h.UV5Kind:case t.h.UV6Kind:return!0}return!1}function W(g){switch(g){case r.e.TriangleFillMode:return 4;case r.e.TriangleStripDrawMode:return 5;case r.e.TriangleFanDrawMode:return 6;case r.e.PointListDrawMode:case r.e.PointFillMode:return 0;case r.e.LineLoopDrawMode:return 2;case r.e.LineListDrawMode:return 1;case r.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${g}`)}function p(g){const w=Math.sqrt(g.x*g.x+g.y*g.y+g.z*g.z);w>0&&(g.x/=w,g.y/=w,g.z/=w)}function Z(g){return g.x*=-1,g}function I(g){if(g.x*g.x+g.y*g.y>.5){const w=Math.abs(g.x),q=Math.abs(g.y);if(w>q){const q=Math.sign(g.x);g.x=w,g.y*=-q,g.z*=-q,g.w*=q}else{const w=Math.sign(g.y);g.x*=-w,g.y=q,g.z*=w,g.w*=-w}}else{const w=Math.abs(g.z),q=Math.abs(g.w);if(w>q){const q=Math.sign(g.z);g.x*=-q,g.y*=q,g.z=w,g.w*=-q}else{const w=Math.sign(g.w);g.x*=w,g.y*=-w,g.z*=-w,g.w=q}}return g}function k(g){g.mi(-g.z,g.w,g.x,-g.y)}function gg(g,w){const q=R.ew.FromArrayToRef(w.translation||[0,0,0],0,R.TmpVectors.ew[0]),o=R.Quaternion.FromArrayToRef(w.rotation||[0,0,0,1],0,R.TmpVectors.Quaternion[0]),r=R.Matrix.ComposeToRef(K,o,q,R.TmpVectors.Matrix[0]),S=R.ew.FromArrayToRef(g.translation||[0,0,0],0,R.TmpVectors.ew[2]),i=R.Quaternion.FromArrayToRef(g.rotation||[0,0,0,1],0,R.TmpVectors.Quaternion[1]),T=R.Matrix.ComposeToRef(K,i,S,R.TmpVectors.Matrix[1]);r.multiplyToRef(T,T),T.decompose(void 0,o,q),q.equalsWithEpsilon(Q,E.c)?delete w.translation:w.translation=q.qi(),o.equalsWithEpsilon(X,E.c)?delete w.rotation:w.rotation=o.qi(),w.scale&&delete w.scale}function wg(g,w){if(!(w instanceof m.d))return!1;if(!(1===w.getChildren().length&&0===g.getChildren().length&&g.parent===w))return!1;const q=g.Ng(),R=g instanceof O.c&&!q.useRightHandedSystem?Y:K;return!!w.ei.equalsWithEpsilon(R,E.c)||(f.d.Warn(`Cannot collapse node ${g.name} into parent node ${w.name} with modified scaling.`),!1)}function qg(g){if(g instanceof Array){const w=new Float32Array(g);return new Uint8Array(w.buffer,w.byteOffset,w.byteLength)}return ArrayBuffer.isView(g)?new Uint8Array(g.buffer,g.byteOffset,g.byteLength):new Uint8Array(g)}function Rg(g,w){for(const[q,R]of Object.entries(g)){const o=w[q];(Array.isArray(R)&&Array.isArray(o)&&og(R,o)||R===o)&&delete g[q]}return g}function og(g,w){return g.length===w.length&&g.every(((g,q)=>g===w[q]))}const rg=R.Matrix.Compose(new R.ew(-1,1,1),R.Quaternion.Identity(),R.ew.Zero());function Sg(g,w){if(!(g instanceof m.d))return!1;if(w){if(!g.getWorldMatrix().equalsWithEpsilon(R.Matrix.IdentityReadOnly,E.c))return!1}else{if(!g.getWorldMatrix().multiplyToRef(rg,R.TmpVectors.Matrix[0]).equalsWithEpsilon(R.Matrix.IdentityReadOnly,E.c))return!1}return!(g instanceof e.c&&g.Ti)}const ig=new Map([[Int8Array,(g,w,q)=>g.setInt8(w,q)],[Uint8Array,(g,w,q)=>g.setUint8(w,q)],[Uint8ClampedArray,(g,w,q)=>g.setUint8(w,q)],[Int16Array,(g,w,q)=>g.setInt16(w,q,!0)],[Uint16Array,(g,w,q)=>g.setUint16(w,q,!0)],[Int32Array,(g,w,q)=>g.setInt32(w,q,!0)],[Uint32Array,(g,w,q)=>g.setUint32(w,q,!0)],[Float32Array,(g,w,q)=>g.setFloat32(w,q,!0)],[Float64Array,(g,w,q)=>g.setFloat64(w,q,!0)]]);class Tg{writeTypedArray(g){this._checkGrowBuffer(g.byteLength);const w=ig.get(g.constructor);for(let q=0;q<g.length;q++)w(this._dataView,this._byteOffset,g[q]),this._byteOffset+=g.BYTES_PER_ELEMENT}constructor(g){this._data=new Uint8Array(g),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(g){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,g),this._byteOffset++}writeInt8(g){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,g),this._byteOffset++}writeInt16(g){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,g,!0),this._byteOffset+=2}writeUInt16(g){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,g,!0),this._byteOffset+=2}writeInt32(g){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,g,!0),this._byteOffset+=4}writeUInt32(g){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,g,!0),this._byteOffset+=4}writeFloat32(g){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,g,!0),this._byteOffset+=4}writeFloat64(g){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,g,!0),this._byteOffset+=8}_checkGrowBuffer(g){const w=this.byteOffset+g;if(w>this._data.byteLength){const g=new Uint8Array(2*w);g.set(this._data),this._data=g,this._dataView=new DataView(this._data.buffer)}}}function zg(g){return g%4===0?4:g%2===0?2:1}class tg{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(g){let w=0;this._bufferViewToData.forEach((g=>{w+=g.byteLength}));const q=new Tg(w),R=Array.from(this._bufferViewToData.keys()).sort(((g,w)=>zg(w.byteLength)-zg(g.byteLength)));for(const o of R){o.byteOffset=q.byteOffset,g.push(o);const w=g.length-1,R=this.getPropertiesWithBufferView(o);for(const g of R)g.bufferView=w;q.writeTypedArray(this._bufferViewToData.get(o)),this._bufferViewToData.delete(o)}return q.getOutputData()}createBufferView(g,w){const q={buffer:0,byteOffset:void 0,byteLength:g.byteLength,byteStride:w};return this._bufferViewToData.set(q,g),q}createAccessor(g,w,q,R,o,r,S){this._verifyBufferView(g);const i={bufferView:void 0,componentType:q,count:R,type:w,min:null===r||void 0===r?void 0:r.min,max:null===r||void 0===r?void 0:r.max,normalized:S,byteOffset:o};return this.setBufferView(i,g),this._accessorToBufferView.set(i,g),i}setBufferView(g,w){this._verifyBufferView(w);this.getPropertiesWithBufferView(w).push(g)}removeBufferView(g){const w=this.getPropertiesWithBufferView(g);for(const q of w)void 0!==q.bufferView&&delete q.bufferView;this._bufferViewToData.delete(g),this._bufferViewToProperties.delete(g),this._accessorToBufferView.forEach(((w,q)=>{w===g&&(void 0!==q.byteOffset&&delete q.byteOffset,this._accessorToBufferView.delete(q))}))}getBufferView(g){const w=this._accessorToBufferView.get(g);return this._verifyBufferView(w),w}getPropertiesWithBufferView(g){return this._verifyBufferView(g),this._bufferViewToProperties.set(g,this._bufferViewToProperties.get(g)??[]),this._bufferViewToProperties.get(g)}getData(g){return this._verifyBufferView(g),this._bufferViewToData.get(g)}_verifyBufferView(g){if(void 0===g||!this._bufferViewToData.has(g))throw new Error(`BufferView ${g} not found in BufferManager.`)}}var mg,eg=q(11593),yg=q(11610),Lg=q(11624),Ag=q(11508),lg=q(11659),Jg=q(11668),xg=q(11586),Gg=q(11670);!function(g){g[g.INTANGENT=0]="INTANGENT",g[g.OUTTANGENT=1]="OUTTANGENT"}(mg||(mg={}));class dg{static _IsTransformable(g){return g&&(g instanceof m.d||g instanceof eg.b||g instanceof Gg.d)}static _CreateNodeAnimation(g,w,q,R,r){if(this._IsTransformable(g)){const S=[],i=[],T=w.getKeys(),z=dg._CalculateMinMaxKeyFrames(T),t=dg._DeduceInterpolation(T,q,R),m=t.interpolationType,e=t.shouldBakeAnimation;if(e?dg._CreateBakedAnimation(g,w,q,z.min,z.max,w.framePerSecond,r,S,i,z,R):"LINEAR"===m||"STEP"===m?dg._CreateLinearOrStepAnimation(g,w,q,S,i,R):"CUBICSPLINE"===m?dg._CreateCubicSplineAnimation(g,w,q,S,i,R):dg._CreateBakedAnimation(g,w,q,z.min,z.max,w.framePerSecond,r,S,i,z,R),S.length&&i.length){return{inputs:S,outputs:i,samplerInterpolation:m,inputsMin:e?z.min:o.Tools.FloatRound(z.min/w.framePerSecond),inputsMax:e?z.max:o.Tools.FloatRound(z.max/w.framePerSecond)}}}return null}static _DeduceAnimationInfo(g){let w=null,q="VEC3",R=!1;const r=g.targetProperty.split(".");switch(r[0]){case"ei":w="scale";break;case"position":w="translation";break;case"rotation":q="VEC4",w="rotation";break;case"rotationQuaternion":q="VEC4",R=!0,w="rotation";break;case"influence":q="SCALAR",w="weights";break;default:o.Tools.Error(`Unsupported animatable property ${r[0]}`)}return w?{animationChannelTargetPath:w,dataAccessorType:q,useQuaternion:R}:(o.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(g,w,q,R,o,r,S,i,T,z,t){let m;if(dg._IsTransformable(g)&&g.animations)for(const e of g.animations){if(t&&!t(e))continue;const o=dg._DeduceAnimationInfo(e);o&&(m={name:e.name,samplers:[],channels:[]},dg._AddAnimation(`${e.name}`,e.hasRunningRuntimeAnimations?w:m,g,e,o.dataAccessorType,o.animationChannelTargetPath,R,r,S,i,o.useQuaternion,T,z),m.samplers.length&&m.channels.length&&q.push(m))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(g,w,q,R,o,r,S,i,T,z,t){let m;if(g instanceof xg.d){const o=g.morphTargetManager;if(o)for(let e=0;e<o.numTargets;++e){const y=o.getTarget(e);for(const L of y.animations){if(t&&!t(L))continue;const y=new lg.c(`${L.name}`,"influence",L.framePerSecond,L.dataType,L.loopMode,L.enableBlending),A=[],l=L.getKeys();for(let g=0;g<l.length;++g){const w=l[g];for(let g=0;g<o.numTargets;++g)g==e?A.push(w):A.push({frame:w.frame,value:0})}y.setKeys(A);const J=dg._DeduceAnimationInfo(y);J&&(m={name:y.name,samplers:[],channels:[]},dg._AddAnimation(L.name,L.hasRunningRuntimeAnimations?w:m,g,y,J.dataAccessorType,J.animationChannelTargetPath,R,r,S,i,J.useQuaternion,T,z,o.numTargets),m.samplers.length&&m.channels.length&&q.push(m))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(g,w,q,R,o,r,S,i,T){let z;if(g.animationGroups){const m=g.animationGroups;for(const e of m){const m=new Map,y=new Map,L=new Set,A=e.to-e.from;z={name:e.name,channels:[],samplers:[]};for(let w=0;w<e.targetedAnimations.length;++w){const A=e.targetedAnimations[w],l=A.target,J=A.animation;if(T&&!T(J))continue;const x=i.has(l);if(this._IsTransformable(l)||1===l.length&&this._IsTransformable(l[0])){const g=dg._DeduceAnimationInfo(A.animation);if(g){const w=this._IsTransformable(l)?l:this._IsTransformable(l[0])?l[0]:null;w&&dg._AddAnimation(`${J.name}`,z,w,J,g.dataAccessorType,g.animationChannelTargetPath,q,R,o,r,g.useQuaternion,S,x)}}else if(l instanceof Jg.d||1===l.length&&l[0]instanceof Jg.d){if(dg._DeduceAnimationInfo(A.animation)){const w=l instanceof Jg.d?l:l[0];if(w){const q=g.morphTargetManagers.find((g=>{for(let q=0;q<g.numTargets;++q)if(g.getTarget(q)===w)return!0;return!1}));if(q){const R=g.meshes.find((g=>g.morphTargetManager===q));var t;if(R)m.has(R)||m.set(R,new Map),null===(t=m.get(R))||void 0===t||t.set(w,J),L.add(R),y.set(R,J)}}}}}L.forEach((g=>{const w=g.morphTargetManager;let i=null;const T=[],t=y.get(g).getKeys(),L=t.length;for(let q=0;q<L;++q)for(let R=0;R<w.numTargets;++R){const o=w.getTarget(R),r=m.get(g);if(r){const w=r.get(o);w?(i||(i=new lg.c(`${e.name}_${g.name}_MorphWeightAnimation`,"influence",w.framePerSecond,lg.c.ANIMATIONTYPE_FLOAT,w.loopMode,w.enableBlending)),T.push(w.getKeys()[q])):T.push({frame:e.from+A/L*q,value:o.influence,inTangent:t[0].inTangent?0:void 0,outTangent:t[0].outTangent?0:void 0})}}i.setKeys(T);const l=dg._DeduceAnimationInfo(i);l&&dg._AddAnimation(`${e.name}_${g.name}_MorphWeightAnimation`,z,g,i,l.dataAccessorType,l.animationChannelTargetPath,q,R,o,r,l.useQuaternion,S,!1,null===w||void 0===w?void 0:w.numTargets)})),z.channels.length&&z.samplers.length&&w.push(z)}}}static _AddAnimation(g,w,q,o,r,S,i,T,z,t,m,e,y,L){const A=dg._CreateNodeAnimation(q,o,S,m,e);let l,J,x,G,d,D;if(A){if(L){let g=0,w=0;const q=[];for(;A.inputs.length>0;)w=A.inputs.shift(),g%L==0&&q.push(w),g++;A.inputs=q}const g=i.get(q),o=new Float32Array(A.inputs);l=T.createBufferView(o),J=T.createAccessor(l,"SCALAR",5126,A.inputs.length,void 0,{min:[A.inputsMin],max:[A.inputsMax]}),t.push(J),x=t.length-1;const z=new R.Quaternion,m=new R.ew,e=new R.ew,U=q instanceof eg.b,N=u(r),a=new Float32Array(A.outputs.length*N);A.outputs.forEach((function(g,w){let q=g;switch(S){case"translation":y&&(R.ew.FromArrayToRef(g,0,e),Z(e),e.toArray(q));break;case"rotation":4===g.length?R.Quaternion.FromArrayToRef(g,0,z):(q=new Array(4),R.ew.FromArrayToRef(g,0,m),R.Quaternion.FromEulerVectorToRef(m,z)),y&&(I(z),U&&k(z)),z.toArray(q)}a.set(q,w*N)})),l=T.createBufferView(a),J=T.createAccessor(l,r,5126,A.outputs.length),t.push(J),G=t.length-1,d={interpolation:A.samplerInterpolation,input:x,output:G},w.samplers.push(d),D={sampler:w.samplers.length-1,target:{node:g,path:S}},w.channels.push(D)}}static _CreateBakedAnimation(g,w,q,r,S,i,T,z,t,m,e){let y;const L=R.Quaternion.Identity();let A,l=null,J=null,x=null,G=null,d=null,D=null;m.min=o.Tools.FloatRound(r/i);const U=w.getKeys();for(let R=0,N=U.length;R<N;++R){if(D=null,x=U[R],R+1<N)if(G=U[R+1],x.value.equals&&x.value.equals(G.value)||x.value===G.value){if(0!==R)continue;D=x.frame}else D=G.frame;else{if(d=U[R-1],x.value.equals&&x.value.equals(d.value)||x.value===d.value)continue;D=S}if(D)for(let R=x.frame;R<=D;R+=T){if(A=o.Tools.FloatRound(R/i),A===l)continue;l=A,J=A;const r={key:0,repeatCount:0,loopMode:w.loopMode};y=w._interpolate(R,r),dg._SetInterpolatedValue(g,y,A,w,q,L,z,t,e)}}J&&(m.max=J)}static _ConvertFactorToVector3OrQuaternion(g,w,q,r,S){const i=dg._GetBasePositionRotationOrScale(w,r,S),T=q.targetProperty.split("."),z=T?T[1]:"",t=S?R.Quaternion.Ri(i).normalize():R.ew.Ri(i);switch(z){case"x":case"y":case"z":t[z]=g;break;case"w":t.w=g;break;default:o.Tools.Error(`glTFAnimation: Unsupported component name "${z}"!`)}return t}static _SetInterpolatedValue(g,w,q,o,r,S,i,T,z){let t;i.push(q),"weights"!==r?(o.dataType===lg.c.ANIMATIONTYPE_FLOAT&&(w=this._ConvertFactorToVector3OrQuaternion(w,g,o,r,z)),"rotation"===r?(z?S=w:(t=w,R.Quaternion.RotationYawPitchRollToRef(t.y,t.x,t.z,S)),T.push(S.qi())):(t=w,T.push(t.qi()))):T.push([w])}static _CreateLinearOrStepAnimation(g,w,q,R,o,r){for(const S of w.getKeys())R.push(S.frame/w.framePerSecond),dg._AddKeyframeValue(S,w,o,q,g,r)}static _CreateCubicSplineAnimation(g,w,q,R,o,r){w.getKeys().forEach((function(S){R.push(S.frame/w.framePerSecond),dg._AddSplineTangent(mg.INTANGENT,o,q,"CUBICSPLINE",S,r),dg._AddKeyframeValue(S,w,o,q,g,r),dg._AddSplineTangent(mg.OUTTANGENT,o,q,"CUBICSPLINE",S,r)}))}static _GetBasePositionRotationOrScale(g,w,q){let o;if("rotation"===w)if(q){o=(g.rotationQuaternion??R.Quaternion.Identity()).qi()}else{o=(g.rotation??R.ew.Zero()).qi()}else if("translation"===w){o=(g.position??R.ew.Zero()).qi()}else{o=(g.ei??R.ew.One()).qi()}return o}static _AddKeyframeValue(g,w,q,r,S,i){let T;const z=w.dataType;if(z===lg.c.ANIMATIONTYPE_VECTOR3){let w=g.value.qi();if("rotation"===r){const g=R.ew.Ri(w);w=R.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).qi()}q.push(w)}else if(z===lg.c.ANIMATIONTYPE_FLOAT){if("weights"===r)q.push([g.value]);else if(T=this._ConvertFactorToVector3OrQuaternion(g.value,S,w,r,i),T){if("rotation"===r){const g=i?T:R.Quaternion.RotationYawPitchRoll(T.y,T.x,T.z).normalize();q.push(g.qi())}q.push(T.qi())}}else z===lg.c.ANIMATIONTYPE_QUATERNION?q.push(g.value.normalize().qi()):o.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(g,w,q){let R,o,r=!1;if("rotation"===w&&!q)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let S=0,i=g.length;S<i;++S)if(o=g[S],o.inTangent||o.outTangent)if(R){if("CUBICSPLINE"!==R){R="LINEAR",r=!0;break}}else R="CUBICSPLINE";else if(R){if("CUBICSPLINE"===R||o.interpolation&&1===o.interpolation&&"STEP"!==R){R="LINEAR",r=!0;break}}else R=o.interpolation&&1===o.interpolation?"STEP":"LINEAR";return R||(R="LINEAR"),{interpolationType:R,shouldBakeAnimation:r}}static _AddSplineTangent(g,w,q,o,r,S){let i;const T=g===mg.INTANGENT?r.inTangent:r.outTangent;if("CUBICSPLINE"===o){if("rotation"===q)if(T)if(S)i=T.qi();else{const g=T;i=R.Quaternion.RotationYawPitchRoll(g.y,g.x,g.z).qi()}else i=[0,0,0,0];else i="weights"===q?T?[T]:[0]:T?T.qi():[0,0,0];w.push(i)}}static _CalculateMinMaxKeyFrames(g){let w=1/0,q=-1/0;return g.forEach((function(g){w=Math.min(w,g.frame),q=Math.max(q,g.frame)})),{min:w,max:q}}}function Dg(g,w,q,r,S,i){const T={attributes:{},influence:g.influence,name:g.name},z=w.Ti;if(!z)return o.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),T;const m=i?-1:1,e=R.ew.Zero();let y=0,L=0;if(g.hasPositions){const r=g.getPositions(),i=z.getVerticesData(t.h.PositionKind);if(i){const g=new Float32Array(i.length),w=[1/0,1/0,1/0],o=[-1/0,-1/0,-1/0];L=i.length/3,y=0;for(let q=y;q<L;++q){const S=R.ew.Ri(i,3*q);R.ew.Ri(r,3*q).subtractToRef(S,e),e.x*=m,w[0]=Math.min(w[0],e.x),o[0]=Math.max(o[0],e.x),w[1]=Math.min(w[1],e.y),o[1]=Math.max(o[1],e.y),w[2]=Math.min(w[2],e.z),o[2]=Math.max(o[2],e.z),g[3*q]=e.x,g[3*q+1]=e.y,g[3*q+2]=e.z}const z=q.createBufferView(g,12),t=q.createAccessor(z,"VEC3",5126,r.length/3,0,{min:w,max:o});S.push(t),T.attributes.POSITION=S.length-1}else o.Tools.Warn(`Morph target positions for mesh ${w.name} were not exported. Mesh does not have position vertex data`)}if(g.hasNormals){const r=g.getNormals(),i=z.getVerticesData(t.h.NormalKind);if(i){const g=new Float32Array(i.length);L=i.length/3,y=0;for(let q=y;q<L;++q){const w=R.ew.Ri(i,3*q).normalize();R.ew.Ri(r,3*q).normalize().subtractToRef(w,e),g[3*q]=e.x*m,g[3*q+1]=e.y,g[3*q+2]=e.z}const w=q.createBufferView(g,12),o=q.createAccessor(w,"VEC3",5126,r.length/3,0);S.push(o),T.attributes.NORMAL=S.length-1}else o.Tools.Warn(`Morph target normals for mesh ${w.name} were not exported. Mesh does not have normals vertex data`)}if(g.hasTangents){const r=g.getTangents(),i=z.getVerticesData(t.h.TangentKind);if(i){L=i.length/4;const g=new Float32Array(3*L);y=0;for(let q=y;q<L;++q){const w=R.ew.Ri(i,4*q);p(w);const o=R.ew.Ri(r,3*q);p(o),o.subtractToRef(w,e),g[3*q]=e.x*m,g[3*q+1]=e.y,g[3*q+2]=e.z}const w=q.createBufferView(g,12),o=q.createAccessor(w,"VEC3",5126,L,0);S.push(o),T.attributes.TANGENT=S.length-1}else o.Tools.Warn(`Morph target tangents for mesh ${w.name} were not exported. Mesh does not have tangents vertex data`)}if(g.hasColors){const r=g.getColors(),i=z.getVerticesData(t.h.ColorKind),m=z.getVertexBuffer(t.h.ColorKind);if(i&&m){const g=m.getSize();L=i.length/g;const w=new Float32Array(L*g);y=0;for(let q=y;q<L;++q)if(3===g){const o=R.ew.Ri(i,q*g);R.ew.Ri(r,q*g).subtractToRef(o,e),w[3*q]=e.x,w[3*q+1]=e.y,w[3*q+2]=e.z}else if(4===g){const o=new R.Vector4,S=R.Vector4.Ri(i,q*g);R.Vector4.Ri(r,q*g).subtractToRef(S,o),w[4*q]=o.x,w[4*q+1]=o.y,w[4*q+2]=o.z,w[4*q+3]=o.w}else o.Tools.Warn(`Unsupported number of components for color attribute: ${g}`);const z=q.createBufferView(w,4*g),t=q.createAccessor(z,3===g?"VEC3":"VEC4",5126,L,0);S.push(t),T.attributes.COLOR_0=S.length-1}else o.Tools.Warn(`Morph target colors for mesh ${w.name} were not exported. Mesh does not have colors vertex data`)}return T}var Ug=q(11678),Ng=q(11537),ag=q(11520),Hg=q(11128);class Cg{}Cg.DEFAULT_COLOR=l.Jw.White(),Cg.DEFAULT_WIDTH_ATTENUATED=1,Cg.DEFAULT_WIDTH=.1;var cg=q(11369),Pg=q(11685);class jg{static ConvertPoints(g,w){if(g.length&&Array.isArray(g)&&"number"===typeof g[0])return[g];if(g.length&&Array.isArray(g[0])&&"number"===typeof g[0][0])return g;if(g.length&&!Array.isArray(g[0])&&g[0]instanceof R.ew){const w=[];for(let q=0;q<g.length;q++){const R=g[q];w.push(R.x,R.y,R.z)}return[w]}if(g.length>0&&Array.isArray(g[0])&&g[0].length>0&&g[0][0]instanceof R.ew){const w=[],q=g;for(const g of q)w.push(g.flatMap((g=>[g.x,g.y,g.z])));return w}if(g instanceof Float32Array){if(null!==w&&void 0!==w&&w.floatArrayStride){const q=[],R=3*w.floatArrayStride;for(let w=0;w<g.length;w+=R){const o=new Array(R);for(let q=0;q<R;q++)o[q]=g[w+q];q.push(o)}return q}return[Array.from(g)]}if(g.length&&g[0]instanceof Float32Array){const w=[];for(const q of g)w.push(Array.from(q));return w}return[]}static OmitZeroLengthPredicate(g,w,q){const R=[];return w.yw(g).lengthSquared()>0&&R.push([g,w]),q.yw(w).lengthSquared()>0&&R.push([w,q]),g.yw(q).lengthSquared()>0&&R.push([q,g]),0===R.length?null:R}static OmitDuplicatesPredicate(g,w,q,R){const o=[];return jg._SearchInPoints(g,w,R)||o.push([g,w]),jg._SearchInPoints(w,q,R)||o.push([w,q]),jg._SearchInPoints(q,g,R)||o.push([q,g]),0===o.length?null:o}static _SearchInPoints(g,w,q){for(const S of q)for(let q=0;q<S.length;q++){var R,o,r;if(null!==(R=S[q])&&void 0!==R&&R.equals(g))if(null!==(o=S[q+1])&&void 0!==o&&o.equals(w)||null!==(r=S[q-1])&&void 0!==r&&r.equals(w))return!0}return!1}static MeshesToLines(g,w){const q=[];for(let o=0;o<g.length;o++){const r=g[o],S=r.getVerticesData(t.h.PositionKind),i=r.zi();if(S&&i)for(let g=0,T=0;g<i.length;g++){const z=3*i[T++],t=3*i[T++],m=3*i[T++],e=new R.ew(S[z],S[z+1],S[z+2]),y=new R.ew(S[t],S[t+1],S[t+2]),L=new R.ew(S[m],S[m+1],S[m+2]);if(w){const R=w(e,y,L,q,g,z,r,o,S,i);if(R)for(const g of R)q.push(g)}else q.push([e,y],[y,L],[L,e])}}return q}static ToVector3Array(g){if(Array.isArray(g[0])){const w=[],q=g;for(const g of q){const q=[];for(let w=0;w<g.length;w+=3)q.push(new R.ew(g[w],g[w+1],g[w+2]));w.push(q)}return w}const w=g,q=[];for(let o=0;o<w.length;o+=3)q.push(new R.ew(w[o],w[o+1],w[o+2]));return q}static ToNumberArray(g){return g.flatMap((g=>[g.x,g.y,g.z]))}static GetPointsCountInfo(g){const w=new Array(g.length);let q=0;for(let R=g.length;R--;)w[R]=g[R].length/3,q+=w[R];return{total:q,counts:w}}static GetLineLength(g){if(0===g.length)return 0;let w;w="number"===typeof g[0]?jg.ToVector3Array(g):g;const q=R.TmpVectors.ew[0];let o=0;for(let R=0;R<w.length-1;R++){const g=w[R];o+=w[R+1].subtractToRef(g,q).length()}return o}static GetLineLengthArray(g){const w=new Float32Array(g.length/3);let q=0;for(let R=0,o=g.length/3-1;R<o;R++){let o=g[3*R+0],r=g[3*R+1],S=g[3*R+2];o-=g[3*R+3],r-=g[3*R+4],S-=g[3*R+5];q+=Math.sqrt(o*o+r*r+S*S),w[R+1]=q}return w}static SegmentizeSegmentByCount(g,w,q){const o=[],r=w.yw(g),S=R.TmpVectors.ew[0];S.yi(q);const i=R.TmpVectors.ew[1];r.divideToRef(S,i);let T=g.clone();o.push(T);for(let R=0;R<q;R++)T=T.clone(),o.push(T.addInPlace(i));return o}static SegmentizeLineBySegmentLength(g,w){const q=g[0]instanceof R.ew?jg.GetLineSegments(g):"number"===typeof g[0]?jg.GetLineSegments(jg.ToVector3Array(g)):g,o=[];for(const R of q)if(R.length>w){const g=jg.SegmentizeSegmentByCount(R.point1,R.point2,Math.ceil(R.length/w));for(const w of g)o.push(w)}else o.push(R.point1),o.push(R.point2);return o}static SegmentizeLineBySegmentCount(g,w){const q="number"===typeof g[0]?jg.ToVector3Array(g):g,R=jg.GetLineLength(q)/w;return jg.SegmentizeLineBySegmentLength(q,R)}static GetLineSegments(g){const w=[];for(let q=0;q<g.length-1;q++){const R=g[q],o=g[q+1],r=o.yw(R).length();w.push({point1:R,point2:o,length:r})}return w}static GetMinMaxSegmentLength(g){const w=jg.GetLineSegments(g).sort((g=>g.length));return{min:w[0].length,max:w[w.length-1].length}}static GetPositionOnLineByVisibility(g,w,q){let o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=w*q;let S=0,i=0;const T=g.length;for(let R=0;R<T;R++){if(r<=S+g[R].length){i=R;break}S+=g[R].length}const z=(r-S)/g[i].length;return g[i].point2.subtractToRef(g[i].point1,R.TmpVectors.ew[0]),R.TmpVectors.ew[1]=R.TmpVectors.ew[0].multiplyByFloats(z,z,z),o||R.TmpVectors.ew[1].addInPlace(g[i].point1),R.TmpVectors.ew[1].clone()}static GetCircleLinePoints(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:g,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/w;const S=[];for(let i=0;i<=w;i++)S.push(new R.ew(Math.cos(i*r)*g,Math.sin(i*r)*o,q));return S}static GetBezierLinePoints(g,w,q,R){return cg.e.CreateQuadraticBezier(g,w,q,R).getPoints().flatMap((g=>[g.x,g.y,g.z]))}static GetArrowCap(g,w,q,R,o){let r=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,S=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[g.clone(),g.add(w.multiplyByFloats(q,q,q))],widths:[R,o,r,S]}}static GetPointsFromText(g,w,q,R){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,r=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const S=[],i=(0,Pg.c)(g,w,q,R);for(const T of i){for(const g of T.paths){const w=[],q=g.getPoints();for(const g of q)w.push(g.x,g.y,o);S.push(w)}if(r)for(const g of T.holes){const w=[],q=g.getPoints();for(const g of q)w.push(g.x,g.y,o);S.push(w)}}return S}static Color3toRGBAUint8(g){const w=new Uint8Array(4*g.length);for(let q=0,R=0;q<g.length;q++)w[R++]=255*g[q].r,w[R++]=255*g[q].g,w[R++]=255*g[q].b,w[R++]=255;return w}static CreateColorsTexture(g,w,q,R){const o=R.getEngine().getCaps().maxTextureSize??1,r=w.length>o?o:w.length,S=Math.ceil(w.length/o);S>1&&(w=[...w,...Array(r*S-w.length).fill(w[0])]);const i=jg.Color3toRGBAUint8(w),T=new U.d(i,r,S,L.c.TEXTUREFORMAT_RGBA,R,!1,!0,q);return T.name=g,T}static PrepareEmptyColorsTexture(g){if(!Cg.EmptyColorsTexture){const w=new Uint8Array(4);Cg.EmptyColorsTexture=new U.d(w,1,1,L.c.TEXTUREFORMAT_RGBA,g,!1,!1,U.d.NEAREST_NEAREST),Cg.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Cg.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var g;null===(g=Cg.EmptyColorsTexture)||void 0===g||g.dispose(),Cg.EmptyColorsTexture=null}static BooleanToNumber(g){return g?1:0}}class Mg extends ag.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Vg extends Ng.e{isCompatible(g){return!0}constructor(g,w,q){var o;q=q||{color:Cg.DEFAULT_COLOR};const r=new Mg;r.GREASED_LINE_HAS_COLOR=!!q.color&&!q.useColors,r.GREASED_LINE_SIZE_ATTENUATION=q.sizeAttenuation??!1,r.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===q.colorDistributionType,r.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(w??g.Ng()).useRightHandedSystem,r.GREASED_LINE_CAMERA_FACING=q.cameraFacing??!0,super(g,Vg.GREASED_LINE_MATERIAL_NAME,200,r,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(o=q)||void 0===o?void 0:o.forceGLSL)||Vg.ForceGLSL,this._scene=w??g.Ng(),this._engine=this._scene.getEngine(),this._cameraFacing=q.cameraFacing??!0,this.visibility=q.visibility??1,this.useDash=q.useDash??!1,this.dashRatio=q.dashRatio??.5,this.dashOffset=q.dashOffset??0,this.width=q.width?q.width:q.sizeAttenuation?Cg.DEFAULT_WIDTH_ATTENUATED:Cg.DEFAULT_WIDTH,this._sizeAttenuation=q.sizeAttenuation??!1,this.colorMode=q.colorMode??0,this._color=q.color??null,this.useColors=q.useColors??!1,this._colorsDistributionType=q.colorDistributionType??0,this.colorsSampling=q.colorsSampling??U.d.NEAREST_NEAREST,this._colors=q.cg??null,this.dashCount=q.dashCount??1,this.resolution=q.resolution??new R.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),q.colorsTexture?this.colorsTexture=q.colorsTexture:this._colors?this.colorsTexture=jg.CreateColorsTexture(`${g.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Cg.DEFAULT_COLOR,jg.PrepareEmptyColorsTexture(this._scene)),this._engine.WS.add((()=>{jg.DisposeEmptyColorsTexture()}))}getAttributes(g){g.push("grl_offsets"),g.push("grl_widths"),g.push("grl_colorPointers"),g.push("grl_counters"),this._cameraFacing?(g.push("grl_previousAndSide"),g.push("grl_nextAndCounters")):g.push("grl_slopes")}getSamplers(g){g.push("grl_colors")}getActiveTextures(g){this.colorsTexture&&g.push(this.colorsTexture)}getUniforms(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const w=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&w.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===g&&w.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:w,vertex:this._cameraFacing&&this._isGLSL(g)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(g)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(g){if(this._cameraFacing){g.Si("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||g.Si("viewProjection",this._scene.getTransformMatrix());const w=R.TmpVectors.Vector4[0];w.x=this._aspect,w.y=this._resolution.x,w.z=this._resolution.y,w.w=this.width,g.updateVector4("grl_aspect_resolution_lineWidth",w)}const w=R.TmpVectors.Vector4[0];w.x=jg.BooleanToNumber(this.useDash),w.y=this._dashArray,w.z=this.dashOffset,w.w=this.dashRatio,g.updateVector4("grl_dashOptions",w);const q=R.TmpVectors.Vector4[1];q.x=this.colorMode,q.y=this.visibility,q.z=this.colorsTexture?this.colorsTexture.getSize().width:0,q.w=jg.BooleanToNumber(this.useColors),g.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",q),this._color&&g.updateColor3("grl_singleColor",this._color);const o=this.colorsTexture??Cg.EmptyColorsTexture;g.setTexture("grl_colors",o),g.updateFloat2("grl_textureSize",(null===o||void 0===o?void 0:o.getSize().width)??1,(null===o||void 0===o?void 0:o.getSize().height)??1)}prepareDefines(g,w,q){g.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,g.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,g.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,g.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=w.useRightHandedSystem,g.GREASED_LINE_CAMERA_FACING=this._cameraFacing,g.GREASED_LINE_USE_OFFSETS=!!q.offsets}getClassName(){return Vg.GREASED_LINE_MATERIAL_NAME}getCustomCode(g){let w=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(w)?function(g,w){if("vertex"===g){const g={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return w&&(g["!gl_Position\\=viewProjection\\*worldPos;"]="//"),g}return"fragment"===g?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(g,this._cameraFacing):function(g,w){if("vertex"===g){const g={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return w&&(g["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),g}return"fragment"===g?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(g,this._cameraFacing)}dispose(){var g;null===(g=this.colorsTexture)||void 0===g||g.dispose(),super.dispose()}get cg(){return this._colors}set cg(g){this.setColors(g)}setColors(g){var w;let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=(null===(w=this._colors)||void 0===w?void 0:w.length)??0;var r;if(this._colors=g,null!==g&&0!==g.length){if(!q||R)if(this.colorsTexture&&o===g.length&&!R){const w=jg.Color3toRGBAUint8(g);this.colorsTexture.update(w)}else{var S;null===(S=this.colorsTexture)||void 0===S||S.dispose(),this.colorsTexture=jg.CreateColorsTexture(`${this._material.name}-colors-texture`,g,this.colorsSampling,this._scene)}}else null===(r=this.colorsTexture)||void 0===r||r.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(g){this._dashCount=g,this._dashArray=1/g}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(g){this._sizeAttenuation=g,this.markAllDefinesAsDirty()}get color(){return this._color}set color(g){this.setColor(g)}setColor(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==g||null!==this._color&&null===g?(this._color=g,w||this.markAllDefinesAsDirty()):this._color=g}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(g){this._colorsDistributionType=g,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(g){this._aspect=g.x/g.y,this._resolution=g}serialize(){const g=super.serialize(),w={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(w.cg=this._colors),this._color&&(w.color=this._color),g.greasedLineMaterialOptions=w,g}parse(g,w,q){var R;super.parse(g,w,q);const o=g.greasedLineMaterialOptions;null===(R=this.colorsTexture)||void 0===R||R.dispose(),o.color&&this.setColor(o.color,!0),o.colorDistributionType&&(this.colorsDistributionType=o.colorDistributionType),o.cg&&(this.cg=o.cg),o.colorsSampling&&(this.colorsSampling=o.colorsSampling),o.colorMode&&(this.colorMode=o.colorMode),o.useColors&&(this.useColors=o.useColors),o.visibility&&(this.visibility=o.visibility),o.useDash&&(this.useDash=o.useDash),o.dashCount&&(this.dashCount=o.dashCount),o.dashRatio&&(this.dashRatio=o.dashRatio),o.dashOffset&&(this.dashOffset=o.dashOffset),o.width&&(this.width=o.width),o.sizeAttenuation&&(this.sizeAttenuation=o.sizeAttenuation),o.resolution&&(this.resolution=o.resolution),this.cg?this.colorsTexture=jg.CreateColorsTexture(`${this._material.name}-colors-texture`,this.cg,this.colorsSampling,w):jg.PrepareEmptyColorsTexture(w),this.markAllDefinesAsDirty()}copyTo(g){var w;const q=g;null===(w=q.colorsTexture)||void 0===w||w.dispose(),this._colors&&(q.colorsTexture=jg.CreateColorsTexture(`${q._material.name}-colors-texture`,this._colors,q.colorsSampling,this._scene)),q.setColor(this.color,!0),q.colorsDistributionType=this.colorsDistributionType,q.colorsSampling=this.colorsSampling,q.colorMode=this.colorMode,q.useColors=this.useColors,q.visibility=this.visibility,q.useDash=this.useDash,q.dashCount=this.dashCount,q.dashRatio=this.dashRatio,q.dashOffset=this.dashOffset,q.width=this.width,q.sizeAttenuation=this.sizeAttenuation,q.resolution=this.resolution,q.markAllDefinesAsDirty()}_isGLSL(g){return 0===g||this._forceGLSL}}Vg.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Vg.ForceGLSL=!1,(0,Hg.g)(`BABYLON.${Vg.GREASED_LINE_MATERIAL_NAME}`,Vg);var sg=q(11572),hg=q(11017),vg=q(11391),bg=q(11110);class Bg extends vg.ShaderMaterial{constructor(g,w,o){const r=w.getEngine(),S=r.isWebGPU&&!(o.forceGLSL||Bg.ForceGLSL),i=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];w.useRightHandedSystem&&i.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const T=["position","grl_widths","grl_offsets","grl_colorPointers"];o.cameraFacing?(i.push("GREASED_LINE_CAMERA_FACING"),T.push("grl_previousAndSide","grl_nextAndCounters")):(T.push("grl_slopes"),T.push("grl_counters"));const z=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(S||z.push("world","viewProjection","view","projection"),super(g,w,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:S?["Scene","Mesh"]:void 0,attributes:T,uniforms:z,samplers:S?[]:["grlColors"],defines:i,extraInitializationsAsync:async()=>{S?await Promise.all([q.e(66).then(q.bind(q,14244)),q.e(75).then(q.bind(q,14246))]):await Promise.all([q.e(69).then(q.bind(q,14250)),q.e(76).then(q.bind(q,14259))])},shaderLanguage:S?1:0}),this._color=l.Jw.White(),this._colorsDistributionType=0,this._colorsTexture=null,o=o||{color:Cg.DEFAULT_COLOR},this.visibility=o.visibility??1,this.useDash=o.useDash??!1,this.dashRatio=o.dashRatio??.5,this.dashOffset=o.dashOffset??0,this.dashCount=o.dashCount??1,this.width=o.width?o.width:o.sizeAttenuation&&o.cameraFacing?Cg.DEFAULT_WIDTH_ATTENUATED:Cg.DEFAULT_WIDTH,this.sizeAttenuation=o.sizeAttenuation??!1,this.color=o.color??l.Jw.White(),this.useColors=o.useColors??!1,this.colorsDistributionType=o.colorDistributionType??0,this.colorsSampling=o.colorsSampling??U.d.NEAREST_NEAREST,this.colorMode=o.colorMode??0,this._colors=o.cg??null,this._cameraFacing=o.cameraFacing??!0,this.resolution=o.resolution??new R.Vector2(r.getRenderWidth(),r.getRenderHeight()),o.colorsTexture?this.colorsTexture=o.colorsTexture:this._colors?this.colorsTexture=jg.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,w):(this._color=this._color??Cg.DEFAULT_COLOR,this.colorsTexture=jg.PrepareEmptyColorsTexture(w)),S){const g=new bg.b;g.setParameters(),g.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",g)}r.WS.add((()=>{jg.DisposeEmptyColorsTexture()}))}dispose(){var g;null===(g=this._colorsTexture)||void 0===g||g.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new R.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get cg(){return this._colors}set cg(g){this.setColors(g)}setColors(g){var w;let q=arguments.length>1&&void 0!==arguments[1]&&arguments[1],R=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const o=(null===(w=this._colors)||void 0===w?void 0:w.length)??0;var r;if(this._colors=g,null!==g&&0!==g.length){if(!q||R)if(this._colorsTexture&&o===g.length&&!R){const w=jg.Color3toRGBAUint8(g);this._colorsTexture.update(w)}else{var S;null===(S=this._colorsTexture)||void 0===S||S.dispose(),this.colorsTexture=jg.CreateColorsTexture(`${this.name}-colors-texture`,g,this.colorsSampling,this.Ng())}}else null===(r=this._colorsTexture)||void 0===r||r.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(g){this._colorsTexture=g,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(g){this._width=g,this.setFloat("grlWidth",g)}get useColors(){return this._useColors}set useColors(g){this._useColors=g,this.setFloat("grlUseColors",jg.BooleanToNumber(g))}get colorsSampling(){return this._colorsSampling}set colorsSampling(g){this._colorsSampling=g}get visibility(){return this._visibility}set visibility(g){this._visibility=g,this.setFloat("grlVisibility",g)}get useDash(){return this._useDash}set useDash(g){this._useDash=g,this.setFloat("grlUseDash",jg.BooleanToNumber(g))}get dashOffset(){return this._dashOffset}set dashOffset(g){this._dashOffset=g,this.setFloat("grlDashOffset",g)}get dashRatio(){return this._dashRatio}set dashRatio(g){this._dashRatio=g,this.setFloat("grlDashRatio",g)}get dashCount(){return this._dashCount}set dashCount(g){this._dashCount=g,this._dashArray=1/g,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(g){this._sizeAttenuation=g,this.setFloat("grlSizeAttenuation",jg.BooleanToNumber(g))}get color(){return this._color}set color(g){this.setColor(g)}setColor(g){g=g??Cg.DEFAULT_COLOR,this._color=g,this.setColor3("grlColor",g)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(g){this._colorsDistributionType=g,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(g){this._colorMode=g,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(g){this._resolution=g,this.setVector2("grlResolution",g),this.setFloat("grlAspect",g.x/g.y)}serialize(){const g=super.serialize(),w={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(w.cg=this._colors),g.greasedLineMaterialOptions=w,g}parse(g,w,q){var R;const o=g.greasedLineMaterialOptions;null===(R=this._colorsTexture)||void 0===R||R.dispose(),o.color&&(this.color=o.color),o.colorDistributionType&&(this.colorsDistributionType=o.colorDistributionType),o.colorsSampling&&(this.colorsSampling=o.colorsSampling),o.colorMode&&(this.colorMode=o.colorMode),o.useColors&&(this.useColors=o.useColors),o.visibility&&(this.visibility=o.visibility),o.useDash&&(this.useDash=o.useDash),o.dashCount&&(this.dashCount=o.dashCount),o.dashRatio&&(this.dashRatio=o.dashRatio),o.dashOffset&&(this.dashOffset=o.dashOffset),o.width&&(this.width=o.width),o.sizeAttenuation&&(this.sizeAttenuation=o.sizeAttenuation),o.resolution&&(this.resolution=o.resolution),o.cg?this.colorsTexture=jg.CreateColorsTexture(`${this.name}-colors-texture`,o.cg,this.colorsSampling,this.Ng()):this.colorsTexture=jg.PrepareEmptyColorsTexture(w),this._cameraFacing=o.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var fg,Og,Eg;Bg.ForceGLSL=!1,function(g){g[g.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",g[g.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(fg||(fg={})),function(g){g[g.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",g[g.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",g[g.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Og||(Og={})),function(g){g[g.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",g[g.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",g[g.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",g[g.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",g[g.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Eg||(Eg={}));class Qg extends xg.d{constructor(g,w,q){super(g,w,null,null,!1,!1),this.name=g,this._options=q,this._lazy=!1,this._updatable=!1,this._engine=w.getEngine(),this._lazy=q.lazy??!1,this._updatable=q.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=q.colorPointers??[],this._widths=q.widths??new Array(q.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(g){let w=0;for(const R of this._points)w+=R.length;const q=w/3*2-this._widths.length;for(let R=0;R<q;R++)this._widths.push(g)}updateLazy(){var g,w;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(g=this._options.ribbonOptions)||void 0===g?void 0:g.smoothShading),!this.Vg&&this.refreshBoundingInfo(),null===(w=this.greasedLineMaterial)||void 0===w||w.updateLazy()}addPoints(g,w){for(const q of g)this._points.push(q);this._lazy||this.setPoints(this._points,w)}dispose(g){let w=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(g,w)}isLazy(){return this._lazy}get Pg(){return this._uvs}set Pg(g){this._uvs=g instanceof Float32Array?g:new Float32Array(g),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(g){this.material instanceof Bg&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===g||void 0===g?void 0:g.length)>0),this._offsets=g,this._offsetsBuffer?this._offsetsBuffer.update(g):this._createOffsetsBuffer(g)}get widths(){return this._widths}set widths(g){this._widths=g,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(g)}get colorPointers(){return this._colorPointers}set colorPointers(g){this._colorPointers=g,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(g)}get greasedLineMaterial(){var g,w;if(this.material&&this.material instanceof Bg)return this.material;const q=null===(g=this.material)||void 0===g||null===(w=g.pluginManager)||void 0===w?void 0:w.getPlugin(Vg.GREASED_LINE_MATERIAL_NAME);return q||void 0}get points(){const g=[];return hg.d.DeepCopy(this._points,g),g}setPoints(g,w){this._points=jg.ConvertPoints(g,(null===w||void 0===w?void 0:w.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==w&&void 0!==w&&w.colorPointers||this._updateColorPointers(),this._setPoints(this._points,w)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Pg:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(g){super.serialize(g),g.type=this.getClassName(),g.lineOptions=this._createLineOptions()}_createVertexBuffers(){let g=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const w=new sg.b;return w.Hg=this._vertexPositions,w.indices=this._indices,w.Pg=this._uvs,g&&(w.Cg=[],sg.b.ComputeNormals(this._vertexPositions,this._indices,w.Cg)),w.Mg(this,this._options.updatable),w}_createOffsetsBuffer(g){const w=this._scene.getEngine(),q=new t.e(w,g,this._updatable,3);this.setVerticesBuffer(q.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=q}}class Xg{constructor(g,w){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=g,this.wasAddedByNoopNode=w}getIndicesAccessor(g,w,q,R,o){var r,S,i,T;return null===(r=this._indicesAccessorMap.get(g))||void 0===r||null===(S=r.get(w))||void 0===S||null===(i=S.get(q))||void 0===i||null===(T=i.get(R))||void 0===T?void 0:T.get(o)}setIndicesAccessor(g,w,q,R,o,r){let S=this._indicesAccessorMap.get(g);S||(S=new Map,this._indicesAccessorMap.set(g,S));let i=S.get(w);i||(i=new Map,S.set(w,i));let T=i.get(q);T||(T=new Map,i.set(q,T));let z=T.get(R);z||(z=new Map,T.set(R,z)),z.set(o,r)}pushExportedNode(g){this._exportedNodes.has(g)||this._exportedNodes.add(g)}getNodesSet(){return this._exportedNodes}getVertexBufferView(g){return this._vertexBufferViewMap.get(g)}setVertexBufferView(g,w){this._vertexBufferViewMap.set(g,w)}setRemappedBufferView(g,w,q){this._remappedBufferView.set(g,new Map),this._remappedBufferView.get(g).set(w,q)}getRemappedBufferView(g,w){var q;return null===(q=this._remappedBufferView.get(g))||void 0===q?void 0:q.get(w)}getVertexAccessor(g,w,q){var R,o;return null===(R=this._vertexAccessorMap.get(g))||void 0===R||null===(o=R.get(w))||void 0===o?void 0:o.get(q)}setVertexAccessor(g,w,q,R){let o=this._vertexAccessorMap.get(g);o||(o=new Map,this._vertexAccessorMap.set(g,o));let r=o.get(w);r||(r=new Map,o.set(w,r)),r.set(q,R)}hasVertexColorAlpha(g){return this._vertexMapColorAlpha.get(g)||!1}setHasVertexColorAlpha(g,w){return this._vertexMapColorAlpha.set(g,w)}getMesh(g){return this._meshMap.get(g)}setMesh(g,w){this._meshMap.set(g,w)}bindMorphDataToMesh(g,w){const q=this._meshMorphTargetMap.get(g)||[];this._meshMorphTargetMap.set(g,q),-1===q.indexOf(w)&&q.push(w)}getMorphTargetsFromMesh(g){return this._meshMorphTargetMap.get(g)}}class Kg{_ApplyExtension(g,w,q,R){if(q>=w.length)return Promise.resolve(g);const o=R(w[q],g);return o?o.then((async g=>g?await this._ApplyExtension(g,w,q+1,R):null)):this._ApplyExtension(g,w,q+1,R)}_ApplyExtensions(g,w){const q=[];for(const R of Kg._ExtensionNames)q.push(this._extensions[R]);return this._ApplyExtension(g,q,0,w)}_extensionsPreExportTextureAsync(g,w,q){return this._ApplyExtensions(w,((w,R)=>w.preExportTextureAsync&&w.preExportTextureAsync(g,R,q)))}_extensionsPostExportNodeAsync(g,w,q,R,o){return this._ApplyExtensions(w,((w,r)=>w.postExportNodeAsync&&w.postExportNodeAsync(g,r,q,R,o,this._bufferManager)))}_extensionsPostExportMaterialAsync(g,w,q){return this._ApplyExtensions(w,((w,R)=>w.postExportMaterialAsync&&w.postExportMaterialAsync(g,R,q)))}_extensionsPostExportMaterialAdditionalTextures(g,w,q){const R=[];for(const o of Kg._ExtensionNames){const r=this._extensions[o];r.postExportMaterialAdditionalTextures&&R.push(...r.postExportMaterialAdditionalTextures(g,w,q))}return R}_extensionsPostExportTextures(g,w,q){for(const R of Kg._ExtensionNames){const o=this._extensions[R];o.postExportTexture&&o.postExportTexture(g,w,q)}}_extensionsPostExportMeshPrimitive(g){for(const w of Kg._ExtensionNames){const q=this._extensions[w];q.postExportMeshPrimitive&&q.postExportMeshPrimitive(g,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const g of Kg._ExtensionNames){const w=this._extensions[g];w.preGenerateBinaryAsync&&await w.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(g){for(const w of Kg._ExtensionNames){const q=this._extensions[w];q.enabled&&g(q)}}_extensionsOnExporting(){this._forEachExtensions((g=>{var w,q,R;g.wasUsed&&((w=this._glTF).extensionsUsed||(w.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(g.name)&&this._glTF.extensionsUsed.push(g.name),g.required&&((q=this._glTF).extensionsRequired||(q.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(g.name)&&this._glTF.extensionsRequired.push(g.name)),(R=this._glTF).extensions||(R.extensions={}),g.onExporting&&g.onExporting())}))}_loadExtensions(){for(const g of Kg._ExtensionNames){const w=Kg._ExtensionFactories[g](this);this._extensions[g]=w}}constructor(){let g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:A.c.LastCreatedScene,w=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${L.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new b(this),this._extensions={},this._bufferManager=new tg,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!g)throw new Error("No scene available to export");this._babylonScene=g,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:g=>{var w;return null===g||void 0===g||null===(w=g.IS)||void 0===w?void 0:w.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...w},this._loadExtensions()}dispose(){for(const g in this._extensions){this._extensions[g].dispose()}}get options(){return this._options}static RegisterExtension(g,w){Kg.UnregisterExtension(g)&&o.Tools.Warn(`Extension with the name ${g} already exists`),Kg._ExtensionFactories[g]=w,Kg._ExtensionNames.push(g)}static UnregisterExtension(g){if(!Kg._ExtensionFactories[g])return!1;delete Kg._ExtensionFactories[g];const w=Kg._ExtensionNames.indexOf(g);return-1!==w&&Kg._ExtensionNames.splice(w,1),!0}_generateJSON(g,w,q){const R={byteLength:g};return R.byteLength&&(this._glTF.buffers=[R]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Aw=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(R.uri=w+".bin"),q?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(g){const w=await this._generateBinaryAsync();this._extensionsOnExporting();const q=this._generateJSON(w.byteLength,g,!0),R=new Blob([w],{type:"application/octet-stream"}),o=g+".gltf",r=g+".bin",S=new z;if(S.files[o]=q,S.files[r]=R,this._imageData)for(const i in this._imageData)S.files[i]=new Blob([this._imageData[i].data],{type:this._imageData[i].mimeType});return S}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(g){const w=g%4;return 0===w?w:4-w}async generateGLBAsync(g){this._shouldUseGlb=!0;const w=await this._generateBinaryAsync();this._extensionsOnExporting();const q=this._generateJSON(w.byteLength),R=g+".glb";let o,r=q.length;if("undefined"!==typeof TextEncoder){o=(new TextEncoder).encode(q),r=o.length}const S=this._getPadding(r),i=this._getPadding(w.byteLength),T=28+r+S+w.byteLength+i,t=new Tg(T);if(t.writeUInt32(1179937895),t.writeUInt32(2),t.writeUInt32(T),t.writeUInt32(r+S),t.writeUInt32(1313821514),o)t.writeTypedArray(o);else{const g="_".charCodeAt(0);for(let w=0;w<r;++w){const R=q.charCodeAt(w);R!=q.codePointAt(w)?t.writeUInt8(g):t.writeUInt8(R)}}for(let z=0;z<S;++z)t.writeUInt8(32);t.writeUInt32(w.byteLength+i),t.writeUInt32(5130562),t.writeTypedArray(w);for(let z=0;z<i;++z)t.writeUInt8(0);const m=new z;return m.files[R]=new Blob([t.getOutputData()],{type:"application/octet-stream"}),m}_setNodeTransformation(g,w,q){if(w.getPivotPoint().equalsWithEpsilon(Q,E.c)||o.Tools.Warn("Pivot points are not supported in the glTF serializer"),!w.position.equalsWithEpsilon(Q,E.c)){const o=R.TmpVectors.ew[0].T(w.position);q&&Z(o),g.translation=o.qi()}w.ei.equalsWithEpsilon(K,E.c)||(g.scale=w.ei.qi());const r=w.rotationQuaternion||R.Quaternion.FromEulerAngles(w.rotation.x,w.rotation.y,w.rotation.z);r.equalsWithEpsilon(X,E.c)||(q&&I(r),g.rotation=r.normalize().qi())}_setCameraTransformation(g,w,q){if(!w.position.equalsWithEpsilon(Q,E.c)){const o=R.TmpVectors.ew[0].T(w.position);q&&Z(o),g.translation=o.qi()}const o=w.rotationQuaternion||R.Quaternion.FromEulerAngles(w.rotation.x,w.rotation.y,w.rotation.z);q&&I(o),this._babylonScene.useRightHandedSystem||k(o),o.equalsWithEpsilon(X,E.c)||(g.rotation=o.qi())}_listAvailableCameras(){for(const g of this._babylonScene.cameras){const w={type:g.mode===eg.b.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(g.name&&(w.name=g.name),"perspective"===w.type)w.perspective={aspectRatio:g.getEngine().getAspectRatio(g),yfov:g.fovMode===eg.b.FOVMODE_VERTICAL_FIXED?g.fov:g.fov*g.getEngine().getAspectRatio(g),znear:g.ri,zfar:g.maxZ};else if("orthographic"===w.type){const q=g.orthoLeft&&g.orthoRight?.5*(g.orthoRight-g.orthoLeft):.5*g.getEngine().getRenderWidth(),R=g.orthoBottom&&g.orthoTop?.5*(g.orthoTop-g.orthoBottom):.5*g.getEngine().getRenderHeight();w.orthographic={xmag:q,ymag:R,znear:g.ri,zfar:g.maxZ}}this._camerasMap.set(g,w)}}_exportAndAssignCameras(){const g=Array.from(this._camerasMap.values());for(const w of g){const g=this._nodesCameraMap.get(w);if(void 0!==g){this._cameras.push(w);for(const w of g)w.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const g of this._babylonScene.skeletons){if(g.bones.length<=0)continue;const w={joints:[]};this._skinMap.set(g,w)}}_exportAndAssignSkeletons(){for(const g of this._babylonScene.skeletons){if(g.bones.length<=0)continue;const w=this._skinMap.get(g);if(void 0==w)continue;const q={},R=[];let r=-1;for(let o=0;o<g.bones.length;++o){const w=g.bones[o],R=w.getIndex()??o;-1!==R&&(q[R]=w,R>r&&(r=R))}for(let g=0;g<=r;++g){const r=q[g];R.push(r.getAbsoluteInverseBindMatrix());const S=r.getTransformNode();if(null!==S){const g=this._nodeMap.get(S);S&&null!==g&&void 0!==g?w.joints.push(g):o.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else o.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const S=this._nodesSkinMap.get(w);if(w.joints.length>0&&void 0!==S){const g=64*R.length,q=new Float32Array(g/4);R.forEach(((g,w)=>{q.set(g.m,16*w)}));const o=this._bufferManager.createBufferView(q);this._accessors.push(this._bufferManager.createAccessor(o,"MAT4",5126,R.length)),w.inverseBindMatrices=this._accessors.length-1,this._skins.push(w);for(const w of S)w.skin=this._skins.length-1}}}async _exportSceneAsync(){const g={nodes:[]};if(this._babylonScene.metadata){const w=this._options.metadataSelector(this._babylonScene.metadata);w&&(g.extras=w)}const w=new Array,q=new Array,R=new Array;for(const i of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Sg(i,this._babylonScene.useRightHandedSystem)?R.push(...i.getChildren()):this._babylonScene.useRightHandedSystem?w.push(i):q.push(i);this._listAvailableCameras(),this._listAvailableSkeletons();const o=new Xg(!0,!1);g.nodes.push(...await this._exportNodesAsync(q,o));const r=new Xg(!1,!1);g.nodes.push(...await this._exportNodesAsync(w,r));const S=new Xg(!1,!0);g.nodes.push(...await this._exportNodesAsync(R,S)),g.nodes.length&&this._scenes.push(g),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&dg._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,o.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(g){let w=this._shouldExportNodeMap.get(g);return void 0===w&&(w=this._options.shouldExportNode(g),this._shouldExportNodeMap.set(g,w)),w}async _exportNodesAsync(g,w){const q=new Array;this._exportBuffers(g,w);for(const R of g)await this._exportNodeAsync(R,q,w);return q}_collectBuffers(g,w,q,R,o){if(this._shouldExportNode(g)&&g instanceof e.c&&g.Ti){const r=g.Ti.getVertexBuffers();if(r)for(const R in r){if(!n(R))continue;const S=r[R];o.setHasVertexColorAlpha(S,g.hasVertexAlpha);const i=S._buffer,T=w.get(i)||[];w.set(i,T),-1===T.indexOf(S)&&T.push(S);const z=q.get(S)||[];q.set(S,z),-1===z.indexOf(g)&&z.push(g)}const S=g.morphTargetManager;if(S)for(let w=0;w<S.numTargets;w++){const q=S.getTarget(w),o=R.get(q)||[];R.set(q,o),-1===o.indexOf(g)&&o.push(g)}}for(const r of g.getChildren())this._collectBuffers(r,w,q,R,o)}_exportBuffers(g,w){const q=new Map,R=new Map,o=new Map;for(const i of g)this._collectBuffers(i,q,R,o,w);const r=Array.from(q.keys());for(const i of r){const g=i.getData();if(!g)throw new Error("Buffer data is not available");const o=q.get(i);if(!o)continue;const r=o[0].byteStride;if(o.some((g=>g.byteStride!==r)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const S=qg(g).slice();for(const w of o){const g=R.get(w),{byteOffset:q,byteStride:o,componentCount:r,type:i,count:T,normalized:z,kind:m}=F(w,g);switch(m){case t.h.NormalKind:case t.h.TangentKind:(0,B.f)(S,q,o,r,i,T,z,(g=>{const w=Math.sqrt(g[0]*g[0]+g[1]*g[1]+g[2]*g[2]);if(w>0){const q=1/w;g[0]*=q,g[1]*=q,g[2]*=q}}));break;case t.h.ColorKind:{const w=g.filter((g=>g.material instanceof Ag.lw||null==g.material)).length;if(0==w)break;if(w!=g.length){f.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}i==t.h.UNSIGNED_BYTE&&f.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const R=new l.Jw,m=new l.d,e=this._babylonScene.getEngine().useExactSrgbConversions;(0,B.f)(S,q,o,r,i,T,z,(g=>{3===g.length?(R.yq(g,0),R.toLinearSpaceToRef(R,e),R.toArray(g,0)):(m.yq(g,0),m.toLinearSpaceToRef(m,e),m.toArray(g,0))}))}}}if(w.convertToRightHanded){for(const g of o){const w=R.get(g),{byteOffset:q,byteStride:o,componentCount:r,type:i,count:T,normalized:z,kind:m}=F(g,w);switch(m){case t.h.PositionKind:case t.h.NormalKind:case t.h.TangentKind:(0,B.f)(S,q,o,r,i,T,z,(g=>{g[0]=-g[0]}))}}w.convertedToRightHandedBuffers.set(i,S)}const T=this._bufferManager.createBufferView(S,r);w.setVertexBufferView(i,T);const z=new Map;for(const w of o){const g=R.get(w),{kind:q,totalVertices:o}=F(w,g);switch(q){case t.h.MatricesIndicesKind:case t.h.MatricesIndicesExtraKind:if(w.type==t.h.FLOAT){const g=w.getFloatData(o);null!==g&&z.set(w,g)}}}0!==z.size&&f.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const m=Array.from(z.keys());for(const q of m){const g=z.get(q);if(!g)continue;const R=g.some((g=>g>=256)),o=new(R?Uint16Array:Uint8Array)(g.length);for(let w=0;w<g.length;w++)o[w]=g[w];const r=this._bufferManager.createBufferView(o,4*(R?2:1));w.setRemappedBufferView(i,q,r)}}const S=Array.from(o.keys());for(const i of S){const g=o.get(i);if(!g)continue;const q=Dg(i,g[0],this._bufferManager,this._bufferViews,this._accessors,w.convertToRightHanded);for(const R of g)w.bindMorphDataToMesh(R,q)}}async _exportNodeAsync(g,w,q){let R=this._nodeMap.get(g);if(void 0!==R)return void(w.includes(R)||w.push(R));const o=await this._createNodeAsync(g,q);if(o){R=this._nodes.length,this._nodes.push(o),this._nodeMap.set(g,R),q.pushExportedNode(g),w.push(R);const r={name:"runtime animations",channels:[],samplers:[]},S=[];this._babylonScene.animationGroups.length||(dg._CreateMorphTargetAnimationFromMorphTargetAnimations(g,r,S,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.convertToRightHanded,this._options.shouldExportAnimation),g.animations.length&&dg._CreateNodeAnimationFromNodeAnimations(g,r,S,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,q.convertToRightHanded,this._options.shouldExportAnimation)),r.channels.length&&r.samplers.length&&this._animations.push(r),S.forEach((g=>{g.channels.length&&g.samplers.length&&this._animations.push(g)}))}const r=o?[]:w;for(const S of g.getChildren())await this._exportNodeAsync(S,r,q);o&&r.length&&(o.children=r)}async _createNodeAsync(g,w){if(!this._shouldExportNode(g))return null;const q={};if(g.name&&(q.name=g.name),g.metadata){const w=this._options.metadataSelector(g.metadata);w&&(q.extras=w)}if(g instanceof m.d&&(this._setNodeTransformation(q,g,w.convertToRightHanded),g instanceof e.c)){const o=g instanceof y.d?g.sourceMesh:g;if(o.wi&&o.wi.length>0&&(q.mesh=await this._exportMeshAsync(o,w)),g.skeleton){const w=this._skinMap.get(g.skeleton);var R;if(void 0!==w)void 0===this._nodesSkinMap.get(w)&&this._nodesSkinMap.set(w,[]),null===(R=this._nodesSkinMap.get(w))||void 0===R||R.push(q)}}if(g instanceof O.c){const R=this._camerasMap.get(g);if(R){var o;void 0===this._nodesCameraMap.get(R)&&this._nodesCameraMap.set(R,[]),this._setCameraTransformation(q,g,w.convertToRightHanded);const S=g.parent;if(null!==S&&wg(g,S)){const g=this._nodeMap.get(S);if(void 0!==g){var r;const w=this._nodes[g];return gg(q,w),null===(r=this._nodesCameraMap.get(R))||void 0===r||r.push(w),null}}null===(o=this._nodesCameraMap.get(R))||void 0===o||o.push(q)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",q,g,this._nodeMap,w.convertToRightHanded)?q:(f.d.Warn(`Not exporting node ${g.name}`),null)}_exportIndices(g,w,q,R,o,S,i,T,z){let t=g;z.mode=W(S);const m=i!==r.e.CounterClockWiseSideOrientation,e=!T.wasAddedByNoopNode&&m,y=function(g){switch(g){case r.e.TriangleFillMode:case r.e.TriangleStripDrawMode:case r.e.TriangleFanDrawMode:return!0}return!1}(S)&&e;if(y){if(S===r.e.TriangleStripDrawMode||S===r.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");z.mode=W(S);const i=w?new Uint32Array(R):new Uint16Array(R);if(g)for(let w=0;w+2<R;w+=3)i[w]=g[q+w]+o,i[w+1]=g[q+w+2]+o,i[w+2]=g[q+w+1]+o;else for(let g=0;g+2<R;g+=3)i[g]=g,i[g+1]=g+2,i[g+2]=g+1;t=i}else if(g&&0!==o){const r=w?new Uint32Array(R):new Uint16Array(R);for(let w=0;w<R;w++)r[w]=g[q+w]+o;t=r}if(t){let r=T.getIndicesAccessor(g,q,R,o,y);if(void 0===r){const S=function(g,w,q,R){if(g instanceof Uint16Array||g instanceof Uint32Array)return g;if(g instanceof Int32Array)return new Uint32Array(g.buffer,g.byteOffset,g.length);const o=g.slice(w,w+q);return R?new Uint32Array(o):new Uint16Array(o)}(t,0,R,w),i=this._bufferManager.createBufferView(S),z=w?5125:5123;this._accessors.push(this._bufferManager.createAccessor(i,"SCALAR",z,R,0)),r=this._accessors.length-1,T.setIndicesAccessor(g,q,R,o,y,r)}z.indices=r}}_exportVertexBuffer(g,w,q,R,o,r){const S=g.getKind();if(!n(S))return;if(S.startsWith("uv")&&!this._options.exportUnusedUVs&&(!w||!this._materialNeedsUVsSet.has(w)))return;let i=o.getVertexAccessor(g,q,R);if(void 0===i){const w=o.convertedToRightHandedBuffers.get(g._buffer)||g._buffer.getData(),r=S===t.h.PositionKind?function(g,w,q,R){const{byteOffset:o,byteStride:r,type:S,normalized:i}=w,T=w.getSize(),z=new Array(T).fill(1/0),t=new Array(T).fill(-1/0);return(0,B.f)(g,o+q*r,r,T,S,R*T,i,(g=>{for(let w=0;w<T;w++)z[w]=Math.min(z[w],g[w]),t[w]=Math.max(t[w],g[w])})),{min:z,max:t}}(w,g,q,R):void 0,T=(S===t.h.MatricesIndicesKind||S===t.h.MatricesIndicesExtraKind)&&g.type===t.h.FLOAT,z=T?t.h.UNSIGNED_BYTE:g.type,m=T?void 0:g.normalized,e=T?o.getRemappedBufferView(g._buffer,g):o.getVertexBufferView(g._buffer),y=g.byteOffset+q*g.byteStride;this._accessors.push(this._bufferManager.createAccessor(e,function(g,w){if(g==t.h.ColorKind)return w?"VEC4":"VEC3";switch(g){case t.h.PositionKind:case t.h.NormalKind:return"VEC3";case t.h.TangentKind:case t.h.MatricesIndicesKind:case t.h.MatricesIndicesExtraKind:case t.h.MatricesWeightsKind:case t.h.MatricesWeightsExtraKind:return"VEC4";case t.h.UVKind:case t.h.UV2Kind:case t.h.UV3Kind:case t.h.UV4Kind:case t.h.UV5Kind:case t.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${g}`)}(S,o.hasVertexColorAlpha(g)),z,R,y,r,m)),i=this._accessors.length-1,o.setVertexAccessor(g,q,R,i)}r.attributes[function(g){switch(g){case t.h.PositionKind:return"POSITION";case t.h.NormalKind:return"NORMAL";case t.h.TangentKind:return"TANGENT";case t.h.ColorKind:return"COLOR_0";case t.h.UVKind:return"TEXCOORD_0";case t.h.UV2Kind:return"TEXCOORD_1";case t.h.UV3Kind:return"TEXCOORD_2";case t.h.UV4Kind:return"TEXCOORD_3";case t.h.UV5Kind:return"TEXCOORD_4";case t.h.UV6Kind:return"TEXCOORD_5";case t.h.MatricesIndicesKind:return"JOINTS_0";case t.h.MatricesIndicesExtraKind:return"JOINTS_1";case t.h.MatricesWeightsKind:return"WEIGHTS_0";case t.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${g}`)}(S)]=i}async _exportMaterialAsync(g,w,q,R){let o=this._materialMap.get(g);if(void 0===o){const R=w&&Object.keys(w).some((g=>g.startsWith("uv")));if((g=g instanceof yg.d?g.Li[q.materialIndex]:g)instanceof Lg.c)o=await this._materialExporter.exportPBRMaterialAsync(g,"image/png",R);else{if(!(g instanceof Ag.lw))return void f.d.Warn(`Unsupported material '${g.name}' with type ${g.getClassName()}`);o=await this._materialExporter.exportStandardMaterialAsync(g,"image/png",R)}this._materialMap.set(g,o)}R.material=o}async _exportMeshAsync(g,w){var q;let R=w.getMesh(g);if(void 0!==R)return R;const o={primitives:[]};R=this._meshes.length,this._meshes.push(o),w.setMesh(g,R);const S=g.isUnIndexed?null:g.zi(),i=null===(q=g.Ti)||void 0===q?void 0:q.getVertexBuffers(),T=w.getMorphTargetsFromMesh(g),z=g instanceof Ug.e,t=g instanceof Qg,m=g.wi;if(i&&m&&m.length>0)for(const L of m){const q={attributes:{}},R=L.bg()||this._babylonScene.defaultMaterial;if(t){var e,y;const w={name:R.name},o=g,r=l.Jw.White(),S=(null===(e=o.material)||void 0===e?void 0:e.alpha)??1,i=(null===(y=o.greasedLineMaterial)||void 0===y?void 0:y.color)??r;(!i.equalsWithEpsilon(r,E.c)||S<1)&&(w.pbrMetallicRoughness={baseColorFactor:[...i.qi(),S]}),this._materials.push(w),q.material=this._materials.length-1}else if(z){const w={name:R.name},o=g;(!o.color.equalsWithEpsilon(l.Jw.White(),E.c)||o.alpha<1)&&(w.pbrMetallicRoughness={baseColorFactor:[...o.color.qi(),o.alpha]}),this._materials.push(w),q.material=this._materials.length-1}else await this._exportMaterialAsync(R,i,L,q);const m=z||t?r.e.LineListDrawMode:g.overrideRenderingFillMode??R.fillMode,A=R._getEffectiveOrientation(g);this._exportIndices(S,S?(0,B.b)(S,L.indexCount,L.indexStart,L.verticesStart):L.verticesCount>65535,S?L.indexStart:L.verticesStart,S?L.indexCount:L.verticesCount,-L.verticesStart,m,A,w,q);for(const g of Object.values(i))this._exportVertexBuffer(g,R,L.verticesStart,L.verticesCount,w,q);if(T){q.targets=[];for(const g of T)q.targets.push(g.attributes)}o.primitives.push(q),this._extensionsPostExportMeshPrimitive(q)}if(T){o.weights=[],o.extras||(o.extras={}),o.extras.targetNames=[];for(const g of T)o.weights.push(g.influence),o.extras.targetNames.push(g.name)}return R}}Kg._ExtensionNames=new Array,Kg._ExtensionFactories={};class Yg{static async GLTFAsync(g,w,q){q&&q.exportWithoutWaitingForScene||await g.whenReadyAsync();const R=new Kg(g,q),o=await R.generateGLTFAsync(w.replace(/\.[^/.]+$/,""));return R.dispose(),o}static async GLBAsync(g,w,q){q&&q.exportWithoutWaitingForScene||await g.whenReadyAsync();const R=new Kg(g,q),o=await R.generateGLBAsync(w.replace(/\.[^/.]+$/,""));return R.dispose(),o}}q(11694);const Fg="EXT_mesh_gpu_instancing";class ug{constructor(g){this.name=Fg,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(g,w,q,o,r,S){return await new Promise((g=>{if(w&&q instanceof xg.d&&q.hasThinInstances&&this._exporter){this._wasUsed=!0;const g=R.ew.Zero(),o=R.Quaternion.Identity(),i=R.ew.One(),T=q.thinInstanceGetWorldMatrices(),z=R.TmpVectors.ew[2],t=R.TmpVectors.Quaternion[1],m=R.TmpVectors.ew[3];let e=!1,y=!1,L=!1;const A=new Float32Array(3*q.Ai),l=new Float32Array(4*q.Ai),J=new Float32Array(3*q.Ai);let x=0;for(const w of T)w.decompose(m,t,z),r&&(Z(z),I(t)),A.set(z.qi(),3*x),l.set(t.normalize().qi(),4*x),J.set(m.qi(),3*x),e=e||!z.equalsWithEpsilon(g),y=y||!t.equalsWithEpsilon(o),L=L||!m.equalsWithEpsilon(i),x++;const G={attributes:{}};e&&(G.attributes.TRANSLATION=this._buildAccessor(A,"VEC3",q.Ai,S)),y&&(G.attributes.ROTATION=this._buildAccessor(l,"VEC4",q.Ai,S)),L&&(G.attributes.SCALE=this._buildAccessor(J,"VEC3",q.Ai,S)),w.extensions=w.extensions||{},w.extensions[Fg]=G}g(w)}))}_buildAccessor(g,w,q,R){const o=R.createBufferView(g),r=R.createAccessor(o,w,5126,q);return this._exporter._accessors.push(r),this._exporter._accessors.length-1}}Kg.RegisterExtension(Fg,(g=>new ug(g)));var ng=q(11702),Wg=q(11712),pg=q(11719),Zg=q(11724);function Ig(g){return g===pg.b.PositionKind?"POSITION":g===pg.b.NormalKind?"NORMAL":g===pg.b.ColorKind?"COLOR":g.startsWith(pg.b.UVKind)?"TEX_COORD":"GENERIC"}const kg={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class gw extends ng.d{static get DefaultAvailable(){return(0,ng.j)(gw.DefaultConfiguration)}static get Default(){return gw._Default??(gw._Default=new gw),gw._Default}static ResetDefault(g){gw._Default&&(g||gw._Default.dispose(),gw._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(g,w){return{module:await(w||DracoEncoderModule)({wasmBinary:g})}}_getWorkerContent(){return`${Wg.g}(${Wg.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:gw.DefaultConfiguration)}async _encodeAsync(g,w,q){const R=q?(0,Zg.e)(kg,q):kg;if(this._workerPoolPromise){const q=await this._workerPoolPromise;return await new Promise(((o,r)=>{q.push(((q,S)=>{const i=g=>{q.removeEventListener("error",i),q.removeEventListener("message",T),r(g),S()},T=g=>{"encodeMeshDone"===g.data.id&&(q.removeEventListener("error",i),q.removeEventListener("message",T),o(g.data.encodedMeshData),S())};q.addEventListener("error",i),q.addEventListener("message",T);const z=[];for(const w of g)z.push(w.data.buffer);w&&z.push(w.buffer),q.postMessage({id:"encodeMesh",attributes:g,indices:w,options:R},z)}))}))}if(this._modulePromise){const q=await this._modulePromise;return(0,Wg.g)(q.module,g,w,R)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(g,w){if(0==g.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");g instanceof xg.d&&g.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===w||void 0===w?void 0:w.method)&&(f.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),w.method="MESH_SEQUENTIAL_ENCODING");const q=function(g){let w=g.zi(void 0,!0);return!w||w instanceof Uint32Array||w instanceof Uint16Array||(w=((0,B.b)(w,w.length)?Uint32Array:Uint16Array).from(w)),w}(g),R=function(g,w){const q=[];for(const R of g.getVerticesDataKinds()){if(null!==w&&void 0!==w&&w.includes(R)){if(R===pg.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const o=g.getVertexBuffer(R),r=o.getSize(),S=(0,B.o)(o.getData(),r,o.type,o.byteOffset,o.byteStride,o.normalized,g.getTotalVertices(),!0);q.push({kind:R,dracoName:Ig(R),size:r,data:S})}return q}(g,null===w||void 0===w?void 0:w.excludedAttributes);return await this._encodeAsync(R,q,w)}}gw.DefaultConfiguration={wasmUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${o.Tools._DefaultCdnUrl}/draco_encoder.js`},gw._Default=null;const ww="KHR_draco_mesh_compression";class qw{get wasUsed(){return this._wasUsed}constructor(g){this.name=ww,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===g.options.meshCompressionMethod&&gw.DefaultAvailable}dispose(){}postExportMeshPrimitive(g,w,q){if(!this.enabled)return;if(4!==g.mode&&5!==g.mode)return void f.d.Warn("Cannot compress primitive with mode "+g.mode+".");const R=[],o=[];let r=null;if(void 0!==g.indices){const S=q[g.indices],i=w.getBufferView(S);r=w.getData(i).slice(),R.push(i),o.push(S)}const S=[];for(const[t,m]of Object.entries(g.attributes)){const g=q[m],r=w.getBufferView(g),T=u(g.type),z=(0,B.o)(w.getData(r),T,g.componentType,g.byteOffset||0,r.byteStride||(0,B.j)(g.componentType)*T,g.normalized||!1,g.count,!0);S.push({kind:t,dracoName:(i=t,"POSITION"===i?"POSITION":"NORMAL"===i?"NORMAL":i.startsWith("COLOR")?"COLOR":i.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:u(g.type),data:z}),R.push(r),o.push(g)}var i;const T={method:g.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},z=gw.Default._encodeAsync(S,r,T).then((q=>{if(!q)return void f.d.Error("Draco encoding failed for primitive.");const r={bufferView:-1,attributes:q.attributeIds},S=w.createBufferView(q.data);w.setBufferView(r,S);for(const g of R)this._bufferViewsUsed.add(g);for(const g of o)this._accessorsUsed.add(g);g.extensions||(g.extensions={}),g.extensions[ww]=r})).catch((g=>{f.d.Error("Draco encoding failed for primitive: "+g)}));this._encodePromises.push(z),this._wasUsed=!0}async preGenerateBinaryAsync(g){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((w=>{g.getPropertiesWithBufferView(w).every((g=>this._accessorsUsed.has(g)))&&g.removeBufferView(w)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Kg.RegisterExtension(ww,(g=>new qw(g)));var Rw=q(11728);const ow="KHR_lights_punctual",rw={name:"",color:[1,1,1],li:1,range:Number.MAX_VALUE},Sw={innerConeAngle:0,outerConeAngle:Math.PI/4},iw=R.ew.Backward();class Tw{constructor(g){this.name=ow,this.enabled=!0,this.required=!1,this._exporter=g}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[ow]=this._lights}async postExportNodeAsync(g,w,q,o,r){return await new Promise((S=>{if(!(q instanceof Gg.d))return void S(w);const i=q.getTypeID()==Gg.d.LIGHTTYPEID_POINTLIGHT?"point":q.getTypeID()==Gg.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":q.getTypeID()==Gg.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!i||!(q instanceof Rw.c))return f.d.Warn(`${g}: Light ${q.name} is not supported in ${ow}`),void S(w);if(q.falloffType!==Gg.d.FALLOFF_GLTF&&f.d.Warn(`${g}: Light falloff for ${q.name} does not match the ${ow} specification!`),!q.position.equalsToFloats(0,0,0)){const g=R.TmpVectors.ew[0].T(q.position);r&&Z(g),w.translation=g.qi()}if("point"!==i){const g=q.direction.normalizeToRef(R.TmpVectors.ew[0]);r&&Z(g);const o=R.Quaternion.FromUnitVectorsToRef(iw,g,R.TmpVectors.Quaternion[0]);R.Quaternion.IsIdentity(o)||(w.rotation=o.qi())}const T={type:i,name:q.name,color:q.Ji.qi(),li:q.li,range:q.range};if(Rg(T,rw),"spot"===i){const g=q;T.spot={innerConeAngle:g.innerAngle/2,outerConeAngle:g.angle/2},Rg(T.spot,Sw)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(T);const z={br:this._lights.lights.length-1},t=q.parent;if(t&&wg(q,t)){const g=o.get(t);if(g){const q=this._exporter._nodes[g];return gg(w,q),q.extensions||(q.extensions={}),q.extensions[ow]=z,void S(null)}}w.extensions||(w.extensions={}),w.extensions[ow]=z,S(w)}))}}Kg.RegisterExtension(ow,(g=>new Tw(g)));var zw=q(11639);const tw="KHR_materials_anisotropy";class mw{constructor(g){this.name=tw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof zw.d&&q.anisotropy.isEnabled&&!q.anisotropy.legacy?(q.anisotropy.texture&&R.push(q.anisotropy.texture),R):[]}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof zw.d){if(!q.anisotropy.isEnabled||q.anisotropy.legacy)return void g(w);this._wasUsed=!0,w.extensions=w.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(q.anisotropy.texture),o={anisotropyStrength:q.anisotropy.li,anisotropyRotation:q.anisotropy.angle,anisotropyTexture:R??void 0};null!==o.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(q),w.extensions[tw]=o}g(w)}))}}Kg.RegisterExtension(tw,(g=>new mw(g)));const ew="KHR_materials_clearcoat";class yw{constructor(g){this.name=ew,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof zw.d&&q.clearCoat.isEnabled?(q.clearCoat.texture&&R.push(q.clearCoat.texture),!q.clearCoat.useRoughnessFromMainTexture&&q.clearCoat.textureRoughness&&R.push(q.clearCoat.textureRoughness),q.clearCoat.bumpTexture&&R.push(q.clearCoat.bumpTexture),R):[]}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof zw.d){if(!q.clearCoat.isEnabled)return void g(w);this._wasUsed=!0,w.extensions=w.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(q.clearCoat.texture);let r;r=q.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(q.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(q.clearCoat.textureRoughness),q.clearCoat.isTintEnabled&&o.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${q.name}`),q.clearCoat.remapF0OnInterfaceChange&&o.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${q.name}`);const S=this._exporter._materialExporter.getTextureInfo(q.clearCoat.bumpTexture),i={clearcoatFactor:q.clearCoat.li,clearcoatTexture:R??void 0,clearcoatRoughnessFactor:q.clearCoat.roughness,clearcoatRoughnessTexture:r??void 0,clearcoatNormalTexture:S??void 0};null===i.clearcoatTexture&&null===i.clearcoatRoughnessTexture&&null===i.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(q),w.extensions[ew]=i}g(w)}))}}Kg.RegisterExtension(ew,(g=>new yw(g)));const Lw="KHR_materials_diffuse_transmission";function Aw(g,w){const q=w.subSurface;let R=null;return q.translucencyIntensityTexture?R=q.translucencyIntensityTexture:q.thicknessTexture&&q.useMaskFromThicknessTexture&&(R=q.thicknessTexture),R&&!q.useGltfStyleTextures?(f.d.Warn(`${g}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${w.name}`,1),null):R}class lw{constructor(g){this.name=Lw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];if(q instanceof Lg.c&&this._isExtensionEnabled(q)){const w=Aw(g,q);return w&&R.push(w),q.subSurface.translucencyColorTexture&&R.push(q.subSurface.translucencyColorTexture),R}return R}_isExtensionEnabled(g){if(g.unlit)return!1;const w=g.subSurface;return!!w.isTranslucencyEnabled&&(!g.unlit&&!w.useAlbedoToTintTranslucency&&w.useGltfStyleTextures&&1===w.volumeIndexOfRefraction&&0===w.minimumThickness&&0===w.maximumThickness)}postExportMaterialAsync(g,w,q){return new Promise((R=>{if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0;const R=q.subSurface,o=Aw(g,q),r=0==R.translucencyIntensity?void 0:R.translucencyIntensity,S=this._exporter._materialExporter.getTextureInfo(o)??void 0,i=!R.translucencyColor||R.translucencyColor.equalsFloats(1,1,1)?void 0:R.translucencyColor.qi(),T=this._exporter._materialExporter.getTextureInfo(R.translucencyColorTexture)??void 0,z={diffuseTransmissionFactor:r,diffuseTransmissionTexture:S,diffuseTransmissionColorFactor:i,diffuseTransmissionColorTexture:T};(S||T)&&this._exporter._materialNeedsUVsSet.add(q),w.extensions=w.extensions||{},w.extensions[Lw]=z}R(w)}))}}Kg.RegisterExtension(Lw,(g=>new lw(g)));const Jw="KHR_materials_dispersion";class xw{constructor(){this.name=Jw,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(g){if(g.unlit)return!1;const w=g.subSurface;return!(!w.isRefractionEnabled&&!w.isDispersionEnabled)}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0;const g={dispersion:q.subSurface.dispersion};w.extensions=w.extensions||{},w.extensions[Jw]=g}g(w)}))}}Kg.RegisterExtension(Jw,(()=>new xw));const Gw="KHR_materials_emissive_strength";class dw{constructor(){this.name=Gw,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(g,w,q){return await new Promise((g=>{if(!(q instanceof Lg.c))return g(w);const R=q.emissiveColor.qi(),o=Math.max(...R);if(o>1){this._wasUsed=!0,w.extensions||(w.extensions={});const g={emissiveStrength:o},R=q.emissiveColor.scale(1/g.emissiveStrength);w.emissiveFactor=R.qi(),w.extensions[Gw]=g}return g(w)}))}}Kg.RegisterExtension(Gw,(g=>new dw));const Dw="KHR_materials_ior";class Uw{constructor(){this.name=Dw,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(g){return!g.unlit&&(void 0!=g.indexOfRefraction&&1.5!=g.indexOfRefraction)}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0;const g={ior:q.indexOfRefraction};w.extensions=w.extensions||{},w.extensions[Dw]=g}g(w)}))}}Kg.RegisterExtension(Dw,(g=>new Uw));const Nw="KHR_materials_iridescence";class aw{constructor(g){this.name=Nw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof zw.d&&q.iridescence.isEnabled?(q.iridescence.texture&&R.push(q.iridescence.texture),q.iridescence.thicknessTexture&&q.iridescence.thicknessTexture!==q.iridescence.texture&&R.push(q.iridescence.thicknessTexture),R):[]}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof zw.d){if(!q.iridescence.isEnabled)return void g(w);this._wasUsed=!0,w.extensions=w.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(q.iridescence.texture),o=this._exporter._materialExporter.getTextureInfo(q.iridescence.thicknessTexture),r={iridescenceFactor:q.iridescence.li,iridescenceIor:q.iridescence.indexOfRefraction,iridescenceThicknessMinimum:q.iridescence.minimumThickness,iridescenceThicknessMaximum:q.iridescence.maximumThickness,iridescenceTexture:R??void 0,iridescenceThicknessTexture:o??void 0};null===r.iridescenceTexture&&null===r.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(q),w.extensions[Nw]=r}g(w)}))}}Kg.RegisterExtension(Nw,(g=>new aw(g)));const Hw="KHR_materials_sheen";class Cw{constructor(g){this.name=Hw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){return q instanceof Lg.c&&q.sheen.isEnabled&&q.sheen.texture?[q.sheen.texture]:[]}async postExportMaterialAsync(g,w,q){return await new Promise((g=>{if(q instanceof Lg.c){if(!q.sheen.isEnabled)return void g(w);this._wasUsed=!0,null==w.extensions&&(w.extensions={});const R={sheenColorFactor:q.sheen.color.qi(),sheenRoughnessFactor:q.sheen.roughness??0};null===R.sheenColorTexture&&null===R.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(q),q.sheen.texture&&(R.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(q.sheen.texture)??void 0),q.sheen.textureRoughness&&!q.sheen.useRoughnessFromMainTexture?R.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(q.sheen.textureRoughness)??void 0:q.sheen.texture&&q.sheen.useRoughnessFromMainTexture&&(R.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(q.sheen.texture)??void 0),w.extensions[Hw]=R}g(w)}))}}Kg.RegisterExtension(Hw,(g=>new Cw(g)));const cw="KHR_materials_specular";class Pw{constructor(g){this.name=cw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof Lg.c&&this._isExtensionEnabled(q)?(q.metallicReflectanceTexture&&R.push(q.metallicReflectanceTexture),q.reflectanceTexture&&R.push(q.reflectanceTexture),R):R}_isExtensionEnabled(g){return!g.unlit&&(void 0!=g.metallicF0Factor&&1!=g.metallicF0Factor||void 0!=g.metallicReflectanceColor&&!g.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(g))}_hasTexturesExtension(g){return null!=g.metallicReflectanceTexture||null!=g.reflectanceTexture}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0,w.extensions=w.extensions||{};const g=this._exporter._materialExporter.getTextureInfo(q.metallicReflectanceTexture)??void 0,R=this._exporter._materialExporter.getTextureInfo(q.reflectanceTexture)??void 0,o={specularFactor:1==q.metallicF0Factor?void 0:q.metallicF0Factor,specularTexture:g,specularColorFactor:q.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:q.metallicReflectanceColor.qi(),specularColorTexture:R};this._hasTexturesExtension(q)&&this._exporter._materialNeedsUVsSet.add(q),w.extensions[cw]=o}g(w)}))}}Kg.RegisterExtension(cw,(g=>new Pw(g)));const jw="KHR_materials_transmission";class Mw{constructor(g){this.name=jw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof Lg.c&&this._isExtensionEnabled(q)?(q.subSurface.thicknessTexture&&R.push(q.subSurface.thicknessTexture),R):R}_isExtensionEnabled(g){if(g.unlit)return!1;const w=g.subSurface;return w.isRefractionEnabled&&void 0!=w.refractionIntensity&&0!=w.refractionIntensity||this._hasTexturesExtension(g)}_hasTexturesExtension(g){return null!=g.subSurface.refractionIntensityTexture}async postExportMaterialAsync(g,w,q){if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0;const R=q.subSurface,o={transmissionFactor:0===R.refractionIntensity?void 0:R.refractionIntensity};if(this._hasTexturesExtension(q)&&this._exporter._materialNeedsUVsSet.add(q),R.refractionIntensityTexture)if(R.useGltfStyleTextures){const g=await this._exporter._materialExporter.exportTextureAsync(R.refractionIntensityTexture,"image/png");g&&(o.transmissionTexture=g)}else f.d.Warn(`${g}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);w.extensions||(w.extensions={}),w.extensions[jw]=o}return w}}Kg.RegisterExtension(jw,(g=>new Mw(g)));const Vw="KHR_materials_unlit";class sw{constructor(){this.name=Vw,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(g,w,q){return new Promise((g=>{let R=!1;q instanceof Lg.c?R=q.unlit:q instanceof Ag.lw&&(R=q.disableLighting),R&&(this._wasUsed=!0,null==w.extensions&&(w.extensions={}),w.extensions[Vw]={}),g(w)}))}}Kg.RegisterExtension(Vw,(()=>new sw));const hw="KHR_materials_volume";class vw{constructor(g){this.name=hw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof Lg.c&&this._isExtensionEnabled(q)?(q.subSurface.thicknessTexture&&R.push(q.subSurface.thicknessTexture),R):R}_isExtensionEnabled(g){if(g.unlit)return!1;const w=g.subSurface;return!(!w.isRefractionEnabled&&!w.isTranslucencyEnabled)&&(void 0!=w.maximumThickness&&0!=w.maximumThickness||void 0!=w.tintColorAtDistance&&w.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=w.tintColor&&w.tintColor!=l.Jw.White()||this._hasTexturesExtension(g))}_hasTexturesExtension(g){return null!=g.subSurface.thicknessTexture}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof Lg.c&&this._isExtensionEnabled(q)){this._wasUsed=!0;const g=q.subSurface,R={thicknessFactor:0==g.maximumThickness?void 0:g.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(g.thicknessTexture)??void 0,attenuationDistance:g.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:g.tintColorAtDistance,attenuationColor:g.tintColor.equalsFloats(1,1,1)?void 0:g.tintColor.qi()};this._hasTexturesExtension(q)&&this._exporter._materialNeedsUVsSet.add(q),w.extensions=w.extensions||{},w.extensions[hw]=R}g(w)}))}}Kg.RegisterExtension(hw,(g=>new vw(g)));const bw="EXT_materials_diffuse_roughness";class Bw{constructor(g){this.name=bw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=g}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(g,w,q){const R=[];return q instanceof zw.d&&q._baseDiffuseRoughness?(q._baseDiffuseRoughnessTexture&&R.push(q._baseDiffuseRoughnessTexture),R):[]}postExportMaterialAsync(g,w,q){return new Promise((g=>{if(q instanceof zw.d){if(!q._baseDiffuseRoughness)return void g(w);this._wasUsed=!0,w.extensions=w.extensions||{};const R=this._exporter._materialExporter.getTextureInfo(q._baseDiffuseRoughnessTexture),o={diffuseRoughnessFactor:q._baseDiffuseRoughness,diffuseRoughnessTexture:R??void 0};null!==o.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(q),w.extensions[bw]=o}g(w)}))}}Kg.RegisterExtension(bw,(g=>new Bw(g)));const fw="KHR_texture_transform";class Ow{constructor(){this.name=fw,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(g,w,q){if(q.Ng()||o.Tools.Warn(`${g}: /*@__KEY__*/"scene" is not defined for Babylon texture ${q.name}!`),(0!==q.uAng||0!==q.vAng)&&(o.Tools.Warn(`${g}: Texture ${q.name} with rotation in the u or v axis is not supported in glTF.`),0!==q.uRotationCenter||0!==q.vRotationCenter))return;const R={};let r=!1;if(0===q.uOffset&&0===q.vOffset||(R.offset=[q.uOffset,q.vOffset],r=!0),1===q.uScale&&1===q.vScale||(R.scale=[q.uScale,q.vScale],r=!0),0!==q.wAng){if(0!==q.uRotationCenter||0!==q.vRotationCenter){if(q.homogeneousRotationInUVTransform&&q.uScale!==q.vScale)return void o.Tools.Warn(`${g}: Texture ${q.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${fw}.`);o.Tools.Warn(`${g}: Texture ${q.name} with non-origin rotation center will be exported using an adjusted offset with ${fw}.`),R.offset=function(g){const{uOffset:w,vOffset:q,uRotationCenter:R,vRotationCenter:o,uScale:r,vScale:S,wAng:i}=g,T=Math.cos(i),z=Math.sin(i),t=R*r,m=o*S;return[w+(t*(1-T)+m*z),q+(m*(1-T)-t*z)]}(q)}R.rotation=-q.wAng,r=!0}0!==q.coordinatesIndex&&(R.texCoord=q.coordinatesIndex,r=!0),r&&(this._wasUsed=!0,w.extensions||(w.extensions={}),w.extensions[fw]=R)}}Kg.RegisterExtension(fw,(()=>new Ow));class Ew{static CreateSTL(g){let w=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",o=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],S=arguments.length>5&&void 0!==arguments[5]&&arguments[5],i=arguments.length>6&&void 0!==arguments[6]&&arguments[6],T=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const z=function(g,w,q){const o=[3*g[q],3*g[q+1],3*g[q+2]],r=[new R.ew(w[o[0]],w[o[0]+2],w[o[0]+1]),new R.ew(w[o[1]],w[o[1]+2],w[o[1]+1]),new R.ew(w[o[2]],w[o[2]+2],w[o[2]+1])],S=r[0].yw(r[1]),i=r[2].yw(r[1]);return{v:r,n:R.ew.Cross(i,S).normalize()}},m=function(g,w,q,R){return w=e(g,w,q.x,R),w=e(g,w,q.y,R),e(g,w,q.z,R)},e=function(g,w,q,R){return g.setFloat32(w,q,R),w+4},L=function(g){if(i){let w=g;g instanceof y.d&&(w=g.sourceMesh);const q=w.getVerticesData(t.h.PositionKind,!0,!0);if(!q)return[];const o=R.ew.Zero();let r;for(r=0;r<q.length;r+=3)R.ew.TransformCoordinatesFromFloatsToRef(q[r],q[r+1],q[r+2],g.ii(!0),o).toArray(q,r);return q}return g.getVerticesData(t.h.PositionKind)||[]};i&&(S=!0);let A="",l=0,J=0;if(o){for(let q=0;q<g.length;q++){const w=g[q].zi();l+=w?w.length/3:0}const w=new ArrayBuffer(84+50*l);A=new DataView(w),J+=80,A.setUint32(J,l,r),J+=4}else T||(A="solid stlmesh\r\n");for(let R=0;R<g.length;R++){const w=g[R];!o&&T&&(A+="solid "+w.name+"\r\n"),!S&&w instanceof xg.d&&w.bakeCurrentTransformIntoVertices();const q=L(w),i=w.zi()||[];for(let g=0;g<i.length;g+=3){const w=z(i,q,g);o?(J=m(A,J,w.n,r),J=m(A,J,w.v[0],r),J=m(A,J,w.v[1],r),J=m(A,J,w.v[2],r),J+=2):(A+="\tfacet normal "+w.n.x+" "+w.n.y+" "+w.n.z+"\r\n",A+="\t\touter loop\r\n",A+="\t\t\tvertex "+w.v[0].x+" "+w.v[0].y+" "+w.v[0].z+"\r\n",A+="\t\t\tvertex "+w.v[1].x+" "+w.v[1].y+" "+w.v[1].z+"\r\n",A+="\t\t\tvertex "+w.v[2].x+" "+w.v[2].y+" "+w.v[2].z+"\r\n",A+="\t\tendloop\r\n",A+="\tendfacet\r\n")}!o&&T&&(A+="endsolid "+name+"\r\n")}if(o||T||(A+="endsolid stlmesh"),w){const g=document.createElement("a"),w=new Blob([A],{type:"application/octet-stream"});g.href=window.URL.createObjectURL(w),g.download=q+".stl",g.click()}return A}}function Qw(g,w){let q=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const R=[];for(let o=0;o<g.length/q;o++){const r=g[o*q],S=g[o*q+1],i=g[o*q+2];R.push(`(${r.toPrecision(w.precision)}, ${S.toPrecision(w.precision)}, ${i.toPrecision(w.precision)})`)}return R.join(", ")}function Xw(g,w){const q=[];for(let R=0;R<g.length/2;R++){const o=g[2*R],r=g[2*R+1];q.push(`(${o.toPrecision(w.precision)}, ${(1-r).toPrecision(w.precision)})`)}return q.join(", ")}function Kw(g,w){const q=g.getVerticesData(t.h.PositionKind),R=g.getVerticesData(t.h.NormalKind);if(q&&R)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(g){var w;const q=null!==(w=g.zi())&&void 0!==w&&w.length?g.getTotalIndices():g.getTotalVertices();return Array(q/3).fill(3).join(", ")}(g)}]\n\t\tint[] faceVertexIndices = [${function(g){const w=g.zi(),q=[];if(null!==w)for(let R=0;R<w.length;R++)q.push(w[R]);else{const w=g.getTotalVertices();for(let g=0;g<w;g++)q.push(g)}return q.join(", ")}(g)}]\n\t\tnormal3f[] normals = [${Qw(R,w)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Qw(q,w)}]\n        ${function(g,w){let q="";for(let o=0;o<4;o++){const R=o>0?o:"",r=g.getVerticesData(t.h.UVKind+(R?R+1:""));r&&(q+=`\n\t\ttexCoord2f[] primvars:st${R} = [${Xw(r,w)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const R=g.getVerticesData(t.h.ColorKind);return R&&(q+=`\n\tcolor3f[] primvars:displayColor = [${Qw(R,w,R.length/g.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),q}(g,w)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Yw(g,w){return`\n        def "Geometry"\n        {\n        ${Kw(g,w)}\n        }\n        `}function Fw(g){let w='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return w+=g,fflate.strToU8(w)}function uw(g){const w=g.m;return`( ${nw(w,0)}, ${nw(w,4)}, ${nw(w,8)}, ${nw(w,12)} )`}function nw(g,w){return`(${g[w+0]}, ${g[w+1]}, ${g[w+2]}, ${g[w+3]})`}function Ww(g){const w="Object_"+g.uniqueId,q=function(g){const w=g.getWorldMatrix().clone(),q=g.Ng().useRightHandedSystem;if(!q){let R=g.parent;for(;R;){if(Sg(R,q)){w.multiplyToRef(R.getWorldMatrix().invert(),w);break}R=R.parent}}return w.determinant()<0&&o.Tools.Warn(`Exporting mesh ${g.name} with negative scale. Result may look incorrect in destination engine.`),w}(g),R=uw(q);return`def Xform "${w}" (\n\tprepend references = @./geometries/Geometry_${g.Ti.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${R}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${g.material.uniqueId}>\n}\n\n`}function pw(g){switch(g){case N.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case N.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case N.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Zw(g){return`(${g.x}, ${g.y})`}function Iw(g){return`(${g.r}, ${g.g}, ${g.b})`}function kw(g,w,q,o,r,S){const i=g.getInternalTexture().uniqueId+"_"+g.invertY;r[i]=g;const T=g.coordinatesIndex>0?"st"+g.coordinatesIndex:"st",z=new R.Vector2(g.uScale,g.vScale),t=new R.Vector2(g.uOffset,g.vOffset),m=g.wAng,e=Math.sin(m),y=Math.cos(m);return t.y=1-t.y-z.y,t.x+=e*z.x,t.y+=(1-y)*z.y,`\n    def Shader "PrimvarReader_${q}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${T}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${q}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${w.uniqueId}/PrimvarReader_${q}.outputs:result>\n        float inputs:rotation = ${(m*(180/Math.PI)).toFixed(S.precision)}\n        float2 inputs:scale = ${Zw(z)}\n        float2 inputs:translation = ${Zw(t)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${g.uniqueId}_${q}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${i}.png@\n        float2 inputs:st.connect = </Materials/Material_${w.uniqueId}/Transform2d_${q}.outputs:result>\n        ${o?"float4 inputs:scale = "+function(g){return`(${g.r}, ${g.g}, ${g.b}, 1.0)`}(o):""}\n        token inputs:sourceColorSpace = "${g.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${pw(g.wrapU)}"\n        token inputs:wrapT = "${pw(g.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${w.needAlphaBlending()?"float outputs:a":""}\n    }`}function gq(g,w,q){const R="\t\t\t",o=[],r=[],{diffuseMap:S,Ji:i,alphaCutOff:T,emissiveMap:z,emissive:t,normalMap:m,roughnessMap:e,roughnessChannel:y,roughness:L,metalnessMap:A,metalnessChannel:J,metalness:x,aoMap:G,aoMapChannel:d,aoMapIntensity:D,alphaMap:U,ior:N,clearCoatEnabled:a,clearCoat:H,clearCoatMap:C,clearCoatRoughness:c,clearCoatRoughnessMap:P}=function(g){const w={diffuseMap:null,Ji:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return g instanceof Ag.lw?{...w,diffuseMap:g.diffuseTexture,Ji:g.diffuseColor,alphaCutOff:g.alphaCutOff,emissiveMap:g.emissiveTexture,emissive:g.emissiveColor,roughness:1,alphaMap:g.opacityTexture}:g instanceof zw.d?{...w,diffuseMap:g._albedoTexture,Ji:g._albedoColor,alphaCutOff:g._alphaCutOff,emissiveMap:g._emissiveTexture,emissive:g._emissiveColor,normalMap:g._bumpTexture,roughnessMap:g._metallicTexture,roughnessChannel:g._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:g._roughness??1,metalnessMap:g._metallicTexture,metalnessChannel:g._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:g._metallic??0,aoMap:g._ambientTexture,aoMapChannel:g._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:g._ambientTextureStrength,alphaMap:g._opacityTexture,ior:g.subSurface.indexOfRefraction,clearCoatEnabled:g.clearCoat.isEnabled,clearCoat:g.clearCoat.li,clearCoatMap:g.clearCoat.texture,clearCoatRoughness:g.clearCoat.roughness,clearCoatRoughnessMap:g.clearCoat.useRoughnessFromMainTexture?g.clearCoat.texture:g.clearCoat.textureRoughness}:w}(g);return null!==S?(o.push(`${R}color3f inputs:diffuseColor.connect = </Materials/Material_${g.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:rgb>`),g.needAlphaBlending()?o.push(`${R}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:a>`):g.needAlphaTesting()&&(o.push(`${R}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${S.uniqueId}_diffuse.outputs:a>`),o.push(`${R}float inputs:opacityThreshold = ${T}`)),r.push(kw(S,g,"diffuse",i,w,q))):o.push(`${R}color3f inputs:diffuseColor = ${Iw(i||l.Jw.White())}`),null!==z?(o.push(`${R}color3f inputs:emissiveColor.connect = </Materials/Material_${g.uniqueId}/Texture_${z.uniqueId}_emissive.outputs:rgb>`),r.push(kw(z,g,"emissive",t,w,q))):t&&t.toLuminance()>0&&o.push(`${R}color3f inputs:emissiveColor = ${Iw(t)}`),null!==m&&(o.push(`${R}normal3f inputs:normal.connect = </Materials/Material_${g.uniqueId}/Texture_${m.uniqueId}_normal.outputs:rgb>`),r.push(kw(m,g,"Lw",null,w,q))),null!==G&&(o.push(`${R}float inputs:occlusion.connect = </Materials/Material_${g.uniqueId}/Texture_${G.uniqueId}_occlusion.outputs:${d}>`),r.push(kw(G,g,"occlusion",new l.Jw(D,D,D),w,q))),null!==e?(o.push(`${R}float inputs:roughness.connect = </Materials/Material_${g.uniqueId}/Texture_${e.uniqueId}_roughness.outputs:${y}>`),r.push(kw(e,g,"roughness",new l.Jw(L,L,L),w,q))):o.push(`${R}float inputs:roughness = ${L}`),null!==A?(o.push(`${R}float inputs:metallic.connect = </Materials/Material_${g.uniqueId}/Texture_${A.uniqueId}_metallic.outputs:${J}>`),r.push(kw(A,g,"metallic",new l.Jw(x,x,x),w,q))):o.push(`${R}float inputs:metallic = ${x}`),null!==U?(o.push(`${R}float inputs:opacity.connect = </Materials/Material_${g.uniqueId}/Texture_${U.uniqueId}_opacity.outputs:r>`),o.push(`${R}float inputs:opacityThreshold = 0.0001`),r.push(kw(U,g,"opacity",null,w,q))):o.push(`${R}float inputs:opacity = ${g.alpha}`),a&&(null!==C?(o.push(`${R}float inputs:clearcoat.connect = </Materials/Material_${g.uniqueId}/Texture_${C.uniqueId}_clearcoat.outputs:r>`),r.push(kw(C,g,"clearcoat",new l.Jw(H,H,H),w,q))):o.push(`${R}float inputs:clearcoat = ${H}`),null!==P?(o.push(`${R}float inputs:clearcoatRoughness.connect = </Materials/Material_${g.uniqueId}/Texture_${P.uniqueId}_clearcoatRoughness.outputs:g>`),r.push(kw(P,g,"clearcoatRoughness",new l.Jw(c,c,c),w,q))):o.push(`${R}float inputs:clearcoatRoughness = ${c}`)),o.push(`${R}float inputs:ior = ${N}`),`\n\tdef Material "Material_${g.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${o.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${g.uniqueId}/PreviewSurface.outputs:surface>\n\n${r.join("\n")}\n\n\t}\n`}async function wq(g,w,q){const r={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...w};"undefined"===typeof fflate&&await o.Tools.LoadScriptAsync(r.fflateUrl);const S={};S[r.modelFileName]=null;let i='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';i+=function(g){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===g.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${g.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${g.planeAnchoringAlignment}"`:""}\n            `}(r);const T={};for(const R of g.meshes){if(0===R.getTotalVertices())continue;const g=R,w=g.Ti,z=g.material;if(!z||!w||q&&!q(g))continue;if(-1!==["lw","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(z.getClassName())){const q="geometries/Geometry_"+w.uniqueId+".usda";if(!(q in S)){const g=Yw(w,r);S[q]=Fw(g)}z.uniqueId in T||(T[z.uniqueId]=z),i+=Ww(g)}else o.Tools.Warn("USDZExportAsync does not support this material type: "+z.getClassName())}g.activeCamera&&r.exportCamera&&(i+=function(g,w){const q="Camera_"+g.uniqueId,o=uw(R.Matrix.RotationY(Math.PI).multiply(g.getWorldMatrix()));if(g.mode===N.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${o}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${g.ri.toPrecision(w.precision)}, ${g.maxZ.toPrecision(w.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(g.orthoLeft||1)+Math.abs(g.orthoRight||1))).toPrecision(w.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(g.orthoTop||1)+Math.abs(g.orthoBottom||1))).toPrecision(w.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const R=g.getEngine().getAspectRatio(g),r=w.cameraSensorWidth||35;return`def Camera "${q}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${o}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${g.ri.toPrecision(w.precision)}, ${g.maxZ.toPrecision(w.precision)})\n\t\t\tfloat focalLength = ${(r/(2*Math.tan(.5*g.fov))).toPrecision(w.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(r*R).toPrecision(w.precision)}\n\t\t\tfloat verticalAperture = ${(r/R).toPrecision(w.precision)}            \n\t\t}\n\t\n\t`}}(g.activeCamera,r)),i+="\n            }\n        }\n    }";const z={};i+=function(g,w,q){const R=[];for(const o in g){const r=g[o];R.push(gq(r,w,q))}return`\n    def "Materials"\n{\n${R.join("")}\n}\n\n`}(T,z,r),S[r.modelFileName]=fflate.strToU8(i);for(const R in z){const g=z[R],w=g.getSize(),q=await g.readPixels();if(!q)throw new Error("Texture data is not available");const o=await a.DumpTools.DumpDataAsync(w.width,w.height,q,"image/png",void 0,!1,!0);S[`textures/Texture_${R}.png`]=new Uint8Array(o).slice()}let t=0;for(const R in S){const g=S[R];if(!g)continue;t+=34+R.length;const w=63&t;if(4!==w){const q=new Uint8Array(64-w);S[R]=[g,{extra:{12345:q}}]}t=g.length}return fflate.zipSync(S,{level:0})}}}]);