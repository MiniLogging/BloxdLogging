"use strict";(self.ra6kpa9z1sg=self.ra6kpa9z1sg||[]).push([[26],{13198:(p,b,M)=>{M.r(b),M.d(b,{EXT_materials_diffuse_roughness:()=>Wb,EXT_mesh_gpu_instancing:()=>Kp,GLTF2Export:()=>Op,GLTFData:()=>t,KHR_draco_mesh_compression:()=>Mb,KHR_lights_punctual:()=>wb,KHR_materials_anisotropy:()=>xb,KHR_materials_clearcoat:()=>Xb,KHR_materials_diffuse_transmission:()=>gb,KHR_materials_dispersion:()=>Yb,KHR_materials_emissive_strength:()=>ob,KHR_materials_ior:()=>Lb,KHR_materials_iridescence:()=>eb,KHR_materials_sheen:()=>Ib,KHR_materials_specular:()=>vb,KHR_materials_transmission:()=>Ub,KHR_materials_unlit:()=>Bb,KHR_materials_volume:()=>ib,KHR_texture_transform:()=>Eb,OBJExport:()=>y,STLExport:()=>jb,USDZExportAsync:()=>bM,_ConvertToGLTFPBRMetallicRoughness:()=>q,_SolveMetallic:()=>U,__IGLTFExporterExtension:()=>P});var h=M(12777),Q=M(12608),mp=M(13097);class y{static OBJ(p,b,M,y){const P=[];let w=1,t=1;b&&(M||(M="mat"),P.push("mtllib "+M+".mtl"));for(let z=0;z<p.length;z++){const M=p[z],x=M.name||`mesh${z}}`;P.push(`o ${x}`);let S=null;if(y){const p=M.Zb(!0);S=new h.Matrix,p.invertToRef(S),M.bakeTransformIntoVertices(p)}if(b){const p=M.material;p&&P.push("usemtl "+p.id)}const X=M.Ub;if(!X){Q.Tools.Warn("No geometry is present on the mesh");continue}const c=X.getVerticesData("position"),J=X.getVerticesData("normal"),g=X.getVerticesData("uv"),f=X.qb();let Y=0,a=0;if(!c||!f){Q.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const o=p[0].upp().useRightHandedSystem?1:-1;for(let p=0;p<c.length;p+=3)P.push("v "+c[p]*o+" "+c[p+1]+" "+c[p+2]),Y++;if(null!=J)for(let p=0;p<J.length;p+=3)P.push("vn "+J[p]*o+" "+J[p+1]+" "+J[p+2]);if(null!=g)for(let p=0;p<g.length;p+=2)P.push("vt "+g[p]+" "+g[p+1]),a++;const l=["","",""],L=(M.material||M.upp().defaultMaterial)._getEffectiveOrientation(M),[u,e]=L===mp.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let p=0;p<f.length;p+=3){const b=[String(f[p]+w),String(f[p+u]+w),String(f[p+e]+w)],M=[String(f[p]+t),String(f[p+u]+t),String(f[p+e]+t)],h=b,Q=null!=g?M:l,mp=null!=J?b:l;P.push("f "+h[0]+"/"+Q[0]+"/"+mp[0]+" "+h[1]+"/"+Q[1]+"/"+mp[1]+" "+h[2]+"/"+Q[2]+"/"+mp[2])}y&&S&&M.bakeTransformIntoVertices(S),w+=Y,t+=a}return P.join("\n")}static MTL(p){const b=[],M=p.material;b.push("newmtl mat1"),b.push("  Ns "+M.specularPower.toFixed(4)),b.push("  Ni 1.5000"),b.push("  d "+M.alpha.toFixed(4)),b.push("  Tr 0.0000"),b.push("  Tf 1.0000 1.0000 1.0000"),b.push("  illum 2"),b.push("  Ka "+M.ambientColor.r.toFixed(4)+" "+M.ambientColor.g.toFixed(4)+" "+M.ambientColor.b.toFixed(4)),b.push("  Kd "+M.diffuseColor.r.toFixed(4)+" "+M.diffuseColor.g.toFixed(4)+" "+M.diffuseColor.b.toFixed(4)),b.push("  Ks "+M.specularColor.r.toFixed(4)+" "+M.specularColor.g.toFixed(4)+" "+M.specularColor.b.toFixed(4)),b.push("  Ke "+M.emissiveColor.r.toFixed(4)+" "+M.emissiveColor.g.toFixed(4)+" "+M.emissiveColor.b.toFixed(4));M.ambientTexture&&b.push("  map_Ka "+M.ambientTexture.name),M.diffuseTexture&&b.push("  map_Kd "+M.diffuseTexture.name),M.specularTexture&&b.push("  map_Ks "+M.specularTexture.name),M.bumpTexture&&b.push("  map_bump -imfchan z "+M.bumpTexture.name),M.opacityTexture&&b.push("  map_d "+M.opacityTexture.name);return b.join("\n")}}var P=0,w=M(12655);class t{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const p in this.files){const b=this.files[p],M=new Blob([b],{type:(0,w.j)(p)});Q.Tools.Download(M,p)}}}var z=M(12847),x=M(13206),S=M(13217),X=M(13229),c=M(12897),J=M(12652),g=M(12820),f=M(12789);const Y=f.HighestCommonFactor,a={...f,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:Y};var o=M(13001),l=M(12753),L=M(13251),u=M(13258),e=M(12997);const d=1e-6,I=new g.wM(.04,.04,.04),G=1024,v=g.wM.White(),Z=g.wM.Black();function U(p,b,M){if(b<I.r)return 0;const h=I.r,Q=p*M/(1-I.r)+b-2*I.r,mp=Q*Q-4*h*(I.r-b);return a.Clamp((-Q+Math.sqrt(mp))/(2*h),0,1)}function q(p){const b=p.diffuseColor.toLinearSpace(p.upp().getEngine().useExactSrgbConversions).scale(.5),M=p.alpha,Q=function(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new h.Vector2(0,1),M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new h.Vector2(0,.1),Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new h.Vector2(0,.1),mp=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new h.Vector2(1300,.1);return function(p,b,M,h,Q){return(1-p)*(1-p)*(1-p)*b+3*(1-p)*(1-p)*p*M+3*(1-p)*p*p*h+p*p*p*Q}(Math.pow(p/mp.x,.333333),b.y,M.y,Q.y,mp.y)}(a.Clamp(p.specularPower,0,G));return{baseColorFactor:[b.r,b.g,b.b,M],metallicFactor:0,roughnessFactor:Q}}function B(p,b){b.needAlphaBlending()?p.alphaMode="BLEND":b.needAlphaTesting()&&(p.alphaMode="MASK",p.alphaCutoff=b.alphaCutOff)}function s(p,b,M){const h=new Uint8Array(p*b*4);for(let Q=0;Q<h.length;Q+=4)h[Q]=h[Q+1]=h[Q+2]=h[Q+3]=255;return L.c.CreateRGBATexture(h,p,b,M)}function i(p){if(p instanceof Uint8Array){const b=p.length,M=new Float32Array(p.length);for(let h=0;h<b;++h)M[h]=p[h]/255;return M}if(p instanceof Float32Array)return p;throw new Error("Unsupported pixel format!")}class T{constructor(p){this._exporter=p,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(p){return p?this._textureMap.get(p)??null:null}async exportStandardMaterialAsync(p,b,M){const h=q(p),mp={name:p.name};if(null==p.Bb||p.Bb||(p.twoSidedLighting||Q.Tools.Warn(p.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),mp.doubleSided=!0),M){const M=[],Q=p.diffuseTexture;Q&&M.push(this.exportTextureAsync(Q,b).then((p=>{p&&(h.baseColorTexture=p)})));const y=p.bumpTexture;y&&M.push(this.exportTextureAsync(y,b).then((p=>{p&&(mp.normalTexture=p,1!==y.level&&(mp.normalTexture.scale=y.level))})));const P=p.emissiveTexture;P&&(mp.emissiveFactor=[1,1,1],M.push(this.exportTextureAsync(P,b).then((p=>{p&&(mp.emissiveTexture=p)}))));const w=p.ambientTexture;w&&M.push(this.exportTextureAsync(w,b).then((p=>{if(p){const b={index:p.index};mp.occlusionTexture=b}}))),M.length>0&&(this._exporter._materialNeedsUVsSet.add(p),await Promise.all(M))}(p.alpha<1||p.opacityTexture)&&(p.alphaMode===u.b.ALPHA_COMBINE?mp.alphaMode="BLEND":Q.Tools.Warn(p.name+": glTF 2.0 does not support alpha mode: "+p.alphaMode.toString())),p.emissiveColor&&!p.emissiveColor.equalsWithEpsilon(Z,d)&&(mp.emissiveFactor=p.emissiveColor.ub()),mp.pbrMetallicRoughness=h,B(mp,p),await this._finishMaterialAsync(mp,p,b);const y=this._exporter._materials;return y.push(mp),y.length-1}async _finishMaterialAsync(p,b,M){const h=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",p,b),Q=[];for(const mp of h)Q.push(this.exportTextureAsync(mp,M));await Promise.all(Q),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",p,b)}async _getImageDataAsync(p,b,h,Q){const mp=u.b.TEXTURETYPE_UNSIGNED_BYTE,y=this._exporter._babylonScene,P=y.getEngine(),w=P.createRawTexture(p,b,h,u.b.TEXTUREFORMAT_RGBA,!1,!0,l.c.NEAREST_SAMPLINGMODE,null,mp);P.isWebGPU?await M.e(51).then(M.bind(M,15259)):await M.e(52).then(M.bind(M,15268)),await o.i.ApplyPostProcess("pass",w,y,mp,u.b.TEXTURE_NEAREST_SAMPLINGMODE,u.b.TEXTUREFORMAT_RGBA);const t=await P._readTexturePixels(w,b,h);return await e.DumpTools.DumpDataAsync(b,h,t,Q,void 0,!0,!0)}_resizeTexturesToSameDimensions(p,b,M){const h=p?p.getSize():{width:0,height:0},Q=b?b.getSize():{width:0,height:0};let mp,y;return h.width<Q.width?(mp=p&&p instanceof l.c?o.i.CreateResizedCopy(p,Q.width,Q.height,!0):s(Q.width,Q.height,M),y=b):h.width>Q.width?(y=b&&b instanceof l.c?o.i.CreateResizedCopy(b,h.width,h.height,!0):s(h.width,h.height,M),mp=p):(mp=p,y=b),{texture1:mp,texture2:y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(p,b,M,h){const Q=new Array;if(!p&&!b)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const mp=p?p.upp():b?b.upp():null;if(mp){var y;const P=this._resizeTexturesToSameDimensions(p,b,mp),w=null===(y=P.texture1)||void 0===y?void 0:y.getSize();let t,z;const x=w.width,S=w.height,X=await P.texture1.readPixels(),c=await P.texture2.readPixels();if(!X)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(t=i(X),!c)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");z=i(c);const J=z.byteLength,f=new Uint8Array(J),Y=new Uint8Array(J),a=4,o=Z;let l=0,L=0;for(let p=0;p<S;++p)for(let b=0;b<x;++b){const h=(x*p+b)*a,Q={diffuseColor:new g.wM(t[h],t[h+1],t[h+2]).toLinearSpace(mp.getEngine().useExactSrgbConversions).multiply(M.diffuseColor),specularColor:new g.wM(z[h],z[h+1],z[h+2]).toLinearSpace(mp.getEngine().useExactSrgbConversions).multiply(M.specularColor),glossiness:z[h+3]*M.glossiness},y=this._convertSpecularGlossinessToMetallicRoughness(Q);o.r=Math.max(o.r,y.baseColor.r),o.g=Math.max(o.g,y.baseColor.g),o.b=Math.max(o.b,y.baseColor.b),l=Math.max(l,y.metallic),L=Math.max(L,y.roughness),Y[h]=255*y.baseColor.r,Y[h+1]=255*y.baseColor.g,Y[h+2]=255*y.baseColor.b,Y[h+3]=P.texture1.lb?255*t[h+3]:255,f[h]=0,f[h+1]=255*y.roughness,f[h+2]=255*y.metallic,f[h+3]=255}const u={baseColor:o,metallic:l,roughness:L};let e=!1,I=!1;for(let p=0;p<S;++p)for(let b=0;b<x;++b){const M=(x*p+b)*a;Y[M]/=u.baseColor.r>d?u.baseColor.r:1,Y[M+1]/=u.baseColor.g>d?u.baseColor.g:1,Y[M+2]/=u.baseColor.b>d?u.baseColor.b:1;const h=g.wM.FromInts(Y[M],Y[M+1],Y[M+2]).toGammaSpace(mp.getEngine().useExactSrgbConversions);Y[M]=255*h.r,Y[M+1]=255*h.g,Y[M+2]=255*h.b,h.equalsWithEpsilon(v,d)||(I=!0),f[M+1]/=u.roughness>d?u.roughness:1,f[M+2]/=u.metallic>d?u.metallic:1;g.wM.FromInts(255,f[M+1],f[M+2]).equalsWithEpsilon(v,d)||(e=!0)}return e&&Q.push(this._getImageDataAsync(f,x,S,h).then((p=>{u.metallicRoughnessTextureData=p}))),I&&Q.push(this._getImageDataAsync(Y,x,S,h).then((p=>{u.baseColorTextureData=p}))),await Promise.all(Q).then((()=>u))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(p){const b=this._getPerceivedBrightness(p.diffuseColor),M=this._getPerceivedBrightness(p.specularColor),h=1-this._getMaxComponent(p.specularColor),Q=U(b,M,h),mp=p.diffuseColor.scale(h/(1-I.r)/Math.max(1-Q)),y=p.specularColor.mh(I.scale(1-Q)).scale(1/Math.max(Q));let P=g.wM.Lerp(mp,y,Q*Q);P=P.clampToRef(0,1,P);return{baseColor:P,metallic:Q,roughness:1-p.glossiness}}_getPerceivedBrightness(p){return p?Math.sqrt(.299*p.r*p.r+.587*p.g*p.g+.114*p.b*p.b):0}_getMaxComponent(p){return p?Math.max(p.r,Math.max(p.g,p.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(p,b,M,h){const Q=[],mp={baseColor:p._albedoColor,metallic:p._metallic,roughness:p._roughness};if(h){p._albedoTexture&&Q.push(this.exportTextureAsync(p._albedoTexture,b).then((p=>{p&&(M.baseColorTexture=p)})));const h=p._metallicTexture;h&&Q.push(this.exportTextureAsync(h,b).then((p=>{p&&(M.metallicRoughnessTexture=p)})))}return Q.length>0&&(this._exporter._materialNeedsUVsSet.add(p),await Promise.all(Q)),mp}_getTextureSampler(p){const b={};if(!p||!(p instanceof l.c))return b;const M=this._getGLTFTextureWrapMode(p.wrapU);10497!==M&&(b.wrapS=M);const h=this._getGLTFTextureWrapMode(p.wrapV);switch(10497!==h&&(b.wrapT=h),p.samplingMode){case l.c.LINEAR_LINEAR:b.magFilter=9729,b.minFilter=9729;break;case l.c.LINEAR_NEAREST:b.magFilter=9729,b.minFilter=9728;break;case l.c.NEAREST_LINEAR:b.magFilter=9728,b.minFilter=9729;break;case l.c.NEAREST_LINEAR_MIPLINEAR:b.magFilter=9728,b.minFilter=9987;break;case l.c.NEAREST_NEAREST:b.magFilter=9728,b.minFilter=9728;break;case l.c.NEAREST_LINEAR_MIPNEAREST:b.magFilter=9728,b.minFilter=9985;break;case l.c.LINEAR_NEAREST_MIPNEAREST:b.magFilter=9729,b.minFilter=9984;break;case l.c.LINEAR_NEAREST_MIPLINEAR:b.magFilter=9729,b.minFilter=9986;break;case l.c.NEAREST_NEAREST_MIPLINEAR:b.magFilter=9728,b.minFilter=9986;break;case l.c.LINEAR_LINEAR_MIPLINEAR:b.magFilter=9729,b.minFilter=9987;break;case l.c.LINEAR_LINEAR_MIPNEAREST:b.magFilter=9729,b.minFilter=9985;break;case l.c.NEAREST_NEAREST_MIPNEAREST:b.magFilter=9728,b.minFilter=9984}return b}_getGLTFTextureWrapMode(p){switch(p){case l.c.WRAP_ADDRESSMODE:return 10497;case l.c.CLAMP_ADDRESSMODE:return 33071;case l.c.MIRROR_ADDRESSMODE:return 33648;default:return Q.Tools.Error(`Unsupported Texture Wrap Mode ${p}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(p,b,M,h){const Q={diffuseColor:p._albedoColor,specularColor:p._reflectivityColor,glossiness:p._microSurface},mp=p._albedoTexture,y=p._reflectivityTexture,P=p._useMicroSurfaceFromReflectivityMapAlpha;if(y&&!P)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((mp||y)&&h){this._exporter._materialNeedsUVsSet.add(p);const h=this._exportTextureSampler(mp||y),P=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(mp,y,Q,b),w=this._exporter._textures;if(P.baseColorTextureData){const p=this._exportImage(`baseColor${w.length}`,b,P.baseColorTextureData);M.baseColorTexture=this._exportTextureInfo(p,h,null===mp||void 0===mp?void 0:mp.coordinatesIndex)}if(P.metallicRoughnessTextureData){const p=this._exportImage(`metallicRoughness${w.length}`,b,P.metallicRoughnessTextureData);M.metallicRoughnessTexture=this._exportTextureInfo(p,h,null===y||void 0===y?void 0:y.coordinatesIndex)}return P}return this._convertSpecularGlossinessToMetallicRoughness(Q)}async exportPBRMaterialAsync(p,b,M){const h={},Q={name:p.name},mp=p.isMetallicWorkflow();if(mp){const b=p._albedoColor,M=p.alpha;b&&(h.baseColorFactor=[b.r,b.g,b.b,M])}const y=mp?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(p,b,h,M):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(p,b,h,M);await this._setMetallicRoughnessPbrMaterialAsync(y,p,Q,h,b,M),await this._finishMaterialAsync(Q,p,b);const P=this._exporter._materials;return P.push(Q),P.length-1}async _setMetallicRoughnessPbrMaterialAsync(p,b,M,h,mp,y){if(B(M,b),p.baseColor.equalsWithEpsilon(v,d)&&a.WithinEpsilon(b.alpha,1,d)||(h.baseColorFactor=[p.baseColor.r,p.baseColor.g,p.baseColor.b,b.alpha]),null!=p.metallic&&1!==p.metallic&&(h.metallicFactor=p.metallic),null!=p.roughness&&1!==p.roughness&&(h.roughnessFactor=p.roughness),null==b.Bb||b.Bb||(b._twoSidedLighting||Q.Tools.Warn(b.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),M.doubleSided=!0),y){const p=[],h=b._bumpTexture;h&&p.push(this.exportTextureAsync(h,mp).then((p=>{p&&(M.normalTexture=p,1!==h.level&&(M.normalTexture.scale=h.level))})));const Q=b._ambientTexture;Q&&p.push(this.exportTextureAsync(Q,mp).then((p=>{if(p){const h={index:p.index,texCoord:p.texCoord,extensions:p.extensions};M.occlusionTexture=h;const Q=b._ambientTextureStrength;Q&&(h.strength=Q)}})));const y=b._emissiveTexture;y&&p.push(this.exportTextureAsync(y,mp).then((p=>{p&&(M.emissiveTexture=p)}))),p.length>0&&(this._exporter._materialNeedsUVsSet.add(b),await Promise.all(p))}const P=b._emissiveColor;P.equalsWithEpsilon(Z,d)||(M.emissiveFactor=P.ub()),M.pbrMetallicRoughness=h}_getPixelsFromTextureAsync(p){return function(p){switch(p){case u.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case u.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case u.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case u.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case u.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case u.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case u.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case u.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case u.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case u.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case u.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case u.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case u.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(p.textureFormat)?(0,o.g)(p,p._texture.width,p._texture.height):(p.textureType,u.b.TEXTURETYPE_UNSIGNED_BYTE,p.readPixels())}async exportTextureAsync(p,b){const M=this._exporter._extensionsPreExportTextureAsync("exporter",p,b);return M?await M.then((async M=>M?await this._exportTextureInfoAsync(M,b):await this._exportTextureInfoAsync(p,b))):await this._exportTextureInfoAsync(p,b)}async _exportTextureInfoAsync(p,b){let M=this._textureMap.get(p);if(!M){const h=await this._getPixelsFromTextureAsync(p);if(!h)return null;const mp=this._exportTextureSampler(p),y=p.mimeType;if(y)switch(y){case"image/jpeg":case"image/png":case"image/webp":b=y;break;default:Q.Tools.Warn(`Unsupported media type: ${y}. Exporting texture as PNG.`)}const P=this._internalTextureToImage,w=p.getInternalTexture().uniqueId;P[w]||(P[w]={});let t=P[w][b];if(void 0===t){const M=p.getSize();t=(async()=>{const Q=await this._getImageDataAsync(h,M.width,M.height,b);return this._exportImage(p.name,b,Q)})(),P[w][b]=t}M=this._exportTextureInfo(await t,mp,p.coordinatesIndex),this._textureMap.set(p,M),this._exporter._extensionsPostExportTextures("exporter",M,p)}return M}_exportImage(p,b,M){const h=this._exporter._images;let mp;if(this._exporter._shouldUseGlb){mp={name:p,mimeType:b,bufferView:void 0};const h=this._exporter._bufferManager.createBufferView(new Uint8Array(M));this._exporter._bufferManager.setBufferView(mp,h)}else{const y=p.replace(/\.\/|\/|\.\\|\\/g,"_"),P=function(p){switch(p){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(b);let w=y+P;h.some((p=>p.uri===w))&&(w=`${y}_${Q.Tools.RandomId()}${P}`),mp={name:p,uri:w},this._exporter._imageData[w]={data:M,mimeType:b}}return h.push(mp),h.length-1}_exportTextureInfo(p,b,M){const h=this._exporter._textures;let Q=h.findIndex((M=>M.sampler==b&&M.source===p));-1===Q&&(Q=h.length,h.push({source:p,sampler:b}));const mp={index:Q};return M&&(mp.texCoord=M),mp}_exportTextureSampler(p){const b=this._getTextureSampler(p),M=this._exporter._samplers,h=M.findIndex((p=>p.minFilter===b.minFilter&&p.magFilter===b.magFilter&&p.wrapS===b.wrapS&&p.wrapT===b.wrapT));return-1!==h?h:(M.push(b),M.length-1)}}var W=M(12860),H=M(12622),E=M(13266),j=M(12779);const V=h.QM.Zero(),D=h.Quaternion.Identity(),N=h.QM.One(),O=new h.QM(-1,1,1);function R(p,b){const{byteOffset:M,byteStride:h,type:Q,normalized:mp}=p,y=p.getSize(),P=b.reduce(((p,b)=>b.getTotalVertices()>p?b.getTotalVertices():p),-Number.MAX_VALUE);return{byteOffset:M,byteStride:h,componentCount:y,type:Q,count:P*y,normalized:mp,totalVertices:P,kind:p.getKind()}}function K(p){switch(p){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function r(p){switch(p){case z.f.PositionKind:case z.f.NormalKind:case z.f.TangentKind:case z.f.ColorKind:case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:case z.f.MatricesWeightsKind:case z.f.MatricesWeightsExtraKind:case z.f.UVKind:case z.f.UV2Kind:case z.f.UV3Kind:case z.f.UV4Kind:case z.f.UV5Kind:case z.f.UV6Kind:return!0}return!1}function k(p){switch(p){case mp.b.TriangleFillMode:return 4;case mp.b.TriangleStripDrawMode:return 5;case mp.b.TriangleFanDrawMode:return 6;case mp.b.PointListDrawMode:case mp.b.PointFillMode:return 0;case mp.b.LineLoopDrawMode:return 2;case mp.b.LineListDrawMode:return 1;case mp.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${p}`)}function A(p){const b=Math.sqrt(p.x*p.x+p.y*p.y+p.z*p.z);b>0&&(p.x/=b,p.y/=b,p.z/=b)}function n(p){return p.x*=-1,p}function C(p){if(p.x*p.x+p.y*p.y>.5){const b=Math.abs(p.x),M=Math.abs(p.y);if(b>M){const M=Math.sign(p.x);p.x=b,p.y*=-M,p.z*=-M,p.w*=M}else{const b=Math.sign(p.y);p.x*=-b,p.y=M,p.z*=b,p.w*=-b}}else{const b=Math.abs(p.z),M=Math.abs(p.w);if(b>M){const M=Math.sign(p.z);p.x*=-M,p.y*=M,p.z=b,p.w*=-M}else{const b=Math.sign(p.w);p.x*=b,p.y*=-b,p.z*=-b,p.w=M}}return p}function F(p){p.sb(-p.z,p.w,p.x,-p.y)}function pp(p,b){const M=h.QM.FromArrayToRef(b.translation||[0,0,0],0,h.TmpVectors.QM[0]),Q=h.Quaternion.FromArrayToRef(b.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[0]),mp=h.Matrix.ComposeToRef(N,Q,M,h.TmpVectors.Matrix[0]),y=h.QM.FromArrayToRef(p.translation||[0,0,0],0,h.TmpVectors.QM[2]),P=h.Quaternion.FromArrayToRef(p.rotation||[0,0,0,1],0,h.TmpVectors.Quaternion[1]),w=h.Matrix.ComposeToRef(N,P,y,h.TmpVectors.Matrix[1]);mp.multiplyToRef(w,w),w.decompose(void 0,Q,M),M.equalsWithEpsilon(V,j.d)?delete b.translation:b.translation=M.ub(),Q.equalsWithEpsilon(D,j.d)?delete b.rotation:b.rotation=Q.ub(),b.scale&&delete b.scale}function bp(p,b){if(!(b instanceof x.c))return!1;if(!(1===b.getChildren().length&&0===p.getChildren().length&&p.parent===b))return!1;const M=p.upp(),h=p instanceof E.e&&!M.useRightHandedSystem?O:N;return!!b.ib.equalsWithEpsilon(h,j.d)||(H.d.Warn(`Cannot collapse node ${p.name} into parent node ${b.name} with modified scaling.`),!1)}function Mp(p){if(p instanceof Array){const b=new Float32Array(p);return new Uint8Array(b.buffer,b.byteOffset,b.byteLength)}return ArrayBuffer.isView(p)?new Uint8Array(p.buffer,p.byteOffset,p.byteLength):new Uint8Array(p)}function hp(p,b){for(const[M,h]of Object.entries(p)){const Q=b[M];(Array.isArray(h)&&Array.isArray(Q)&&Qp(h,Q)||h===Q)&&delete p[M]}return p}function Qp(p,b){return p.length===b.length&&p.every(((p,M)=>p===b[M]))}const mb=h.Matrix.Compose(new h.QM(-1,1,1),h.Quaternion.Identity(),h.QM.Zero());function yp(p,b){if(!(p instanceof x.c))return!1;if(b){if(!p.getWorldMatrix().equalsWithEpsilon(h.Matrix.IdentityReadOnly,j.d))return!1}else{if(!p.getWorldMatrix().multiplyToRef(mb,h.TmpVectors.Matrix[0]).equalsWithEpsilon(h.Matrix.IdentityReadOnly,j.d))return!1}return!(p instanceof S.c&&p.Ub)}const Pp=new Map([[Int8Array,(p,b,M)=>p.setInt8(b,M)],[Uint8Array,(p,b,M)=>p.setUint8(b,M)],[Uint8ClampedArray,(p,b,M)=>p.setUint8(b,M)],[Int16Array,(p,b,M)=>p.setInt16(b,M,!0)],[Uint16Array,(p,b,M)=>p.setUint16(b,M,!0)],[Int32Array,(p,b,M)=>p.setInt32(b,M,!0)],[Uint32Array,(p,b,M)=>p.setUint32(b,M,!0)],[Float32Array,(p,b,M)=>p.setFloat32(b,M,!0)],[Float64Array,(p,b,M)=>p.setFloat64(b,M,!0)]]);class wp{writeTypedArray(p){this._checkGrowBuffer(p.byteLength);const b=Pp.get(p.constructor);for(let M=0;M<p.length;M++)b(this._dataView,this._byteOffset,p[M]),this._byteOffset+=p.BYTES_PER_ELEMENT}constructor(p){this._data=new Uint8Array(p),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(p){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,p),this._byteOffset++}writeInt8(p){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,p),this._byteOffset++}writeInt16(p){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,p,!0),this._byteOffset+=2}writeUInt16(p){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,p,!0),this._byteOffset+=2}writeInt32(p){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,p,!0),this._byteOffset+=4}writeUInt32(p){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,p,!0),this._byteOffset+=4}writeFloat32(p){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,p,!0),this._byteOffset+=4}writeFloat64(p){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,p,!0),this._byteOffset+=8}_checkGrowBuffer(p){const b=this.byteOffset+p;if(b>this._data.byteLength){const p=new Uint8Array(2*b);p.set(this._data),this._data=p,this._dataView=new DataView(this._data.buffer)}}}function tp(p){return p%4===0?4:p%2===0?2:1}class zp{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(p){let b=0;this._bufferViewToData.forEach((p=>{b+=p.byteLength}));const M=new wp(b),h=Array.from(this._bufferViewToData.keys()).sort(((p,b)=>tp(b.byteLength)-tp(p.byteLength)));for(const Q of h){Q.byteOffset=M.byteOffset,p.push(Q);const b=p.length-1,h=this.getPropertiesWithBufferView(Q);for(const p of h)p.bufferView=b;M.writeTypedArray(this._bufferViewToData.get(Q)),this._bufferViewToData.delete(Q)}return M.getOutputData()}createBufferView(p,b){const M={buffer:0,byteOffset:void 0,byteLength:p.byteLength,byteStride:b};return this._bufferViewToData.set(M,p),M}createAccessor(p,b,M,h,Q,mp,y){this._verifyBufferView(p);const P={bufferView:void 0,componentType:M,count:h,type:b,min:null===mp||void 0===mp?void 0:mp.min,max:null===mp||void 0===mp?void 0:mp.max,normalized:y,byteOffset:Q};return this.setBufferView(P,p),this._accessorToBufferView.set(P,p),P}setBufferView(p,b){this._verifyBufferView(b);this.getPropertiesWithBufferView(b).push(p)}removeBufferView(p){const b=this.getPropertiesWithBufferView(p);for(const M of b)void 0!==M.bufferView&&delete M.bufferView;this._bufferViewToData.delete(p),this._bufferViewToProperties.delete(p),this._accessorToBufferView.forEach(((b,M)=>{b===p&&(void 0!==M.byteOffset&&delete M.byteOffset,this._accessorToBufferView.delete(M))}))}getBufferView(p){const b=this._accessorToBufferView.get(p);return this._verifyBufferView(b),b}getPropertiesWithBufferView(p){return this._verifyBufferView(p),this._bufferViewToProperties.set(p,this._bufferViewToProperties.get(p)??[]),this._bufferViewToProperties.get(p)}getData(p){return this._verifyBufferView(p),this._bufferViewToData.get(p)}_verifyBufferView(p){if(void 0===p||!this._bufferViewToData.has(p))throw new Error(`BufferView ${p} not found in BufferManager.`)}}var xp,Sp=M(13235),Xp=M(13245),cp=M(13273),Jp=M(13156),gp=M(13311),fp=M(13318),Yp=M(13231),ap=M(13327);!function(p){p[p.INTANGENT=0]="INTANGENT",p[p.OUTTANGENT=1]="OUTTANGENT"}(xp||(xp={}));class op{static _IsTransformable(p){return p&&(p instanceof x.c||p instanceof Sp.e||p instanceof ap.c)}static _CreateNodeAnimation(p,b,M,h,mp){if(this._IsTransformable(p)){const y=[],P=[],w=b.getKeys(),t=op._CalculateMinMaxKeyFrames(w),z=op._DeduceInterpolation(w,M,h),x=z.interpolationType,S=z.shouldBakeAnimation;if(S?op._CreateBakedAnimation(p,b,M,t.min,t.max,b.framePerSecond,mp,y,P,t,h):"LINEAR"===x||"STEP"===x?op._CreateLinearOrStepAnimation(p,b,M,y,P,h):"CUBICSPLINE"===x?op._CreateCubicSplineAnimation(p,b,M,y,P,h):op._CreateBakedAnimation(p,b,M,t.min,t.max,b.framePerSecond,mp,y,P,t,h),y.length&&P.length){return{inputs:y,outputs:P,samplerInterpolation:x,inputsMin:S?t.min:Q.Tools.FloatRound(t.min/b.framePerSecond),inputsMax:S?t.max:Q.Tools.FloatRound(t.max/b.framePerSecond)}}}return null}static _DeduceAnimationInfo(p){let b=null,M="VEC3",h=!1;const mp=p.targetProperty.split(".");switch(mp[0]){case"ib":b="scale";break;case"position":b="translation";break;case"rotation":M="VEC4",b="rotation";break;case"rotationQuaternion":M="VEC4",h=!0,b="rotation";break;case"influence":M="SCALAR",b="weights";break;default:Q.Tools.Error(`Unsupported animatable property ${mp[0]}`)}return b?{animationChannelTargetPath:b,dataAccessorType:M,useQuaternion:h}:(Q.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(p,b,M,h,Q,mp,y,P,w,t,z){let x;if(op._IsTransformable(p)&&p.animations)for(const S of p.animations){if(z&&!z(S))continue;const Q=op._DeduceAnimationInfo(S);Q&&(x={name:S.name,samplers:[],channels:[]},op._AddAnimation(`${S.name}`,S.hasRunningRuntimeAnimations?b:x,p,S,Q.dataAccessorType,Q.animationChannelTargetPath,h,mp,y,P,Q.useQuaternion,w,t),x.samplers.length&&x.channels.length&&M.push(x))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(p,b,M,h,Q,mp,y,P,w,t,z){let x;if(p instanceof Yp.e){const Q=p.morphTargetManager;if(Q)for(let S=0;S<Q.numTargets;++S){const X=Q.getTarget(S);for(const c of X.animations){if(z&&!z(c))continue;const X=new gp.d(`${c.name}`,"influence",c.framePerSecond,c.dataType,c.loopMode,c.enableBlending),J=[],g=c.getKeys();for(let p=0;p<g.length;++p){const b=g[p];for(let p=0;p<Q.numTargets;++p)p==S?J.push(b):J.push({frame:b.frame,value:0})}X.setKeys(J);const f=op._DeduceAnimationInfo(X);f&&(x={name:X.name,samplers:[],channels:[]},op._AddAnimation(c.name,c.hasRunningRuntimeAnimations?b:x,p,X,f.dataAccessorType,f.animationChannelTargetPath,h,mp,y,P,f.useQuaternion,w,t,Q.numTargets),x.samplers.length&&x.channels.length&&M.push(x))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(p,b,M,h,Q,mp,y,P,w){let t;if(p.animationGroups){const x=p.animationGroups;for(const S of x){const x=new Map,X=new Map,c=new Set,J=S.to-S.from;t={name:S.name,channels:[],samplers:[]};for(let b=0;b<S.targetedAnimations.length;++b){const J=S.targetedAnimations[b],g=J.target,f=J.animation;if(w&&!w(f))continue;const Y=P.has(g);if(this._IsTransformable(g)||1===g.length&&this._IsTransformable(g[0])){const p=op._DeduceAnimationInfo(J.animation);if(p){const b=this._IsTransformable(g)?g:this._IsTransformable(g[0])?g[0]:null;b&&op._AddAnimation(`${f.name}`,t,b,f,p.dataAccessorType,p.animationChannelTargetPath,M,h,Q,mp,p.useQuaternion,y,Y)}}else if(g instanceof fp.c||1===g.length&&g[0]instanceof fp.c){if(op._DeduceAnimationInfo(J.animation)){const b=g instanceof fp.c?g:g[0];if(b){const M=p.morphTargetManagers.find((p=>{for(let M=0;M<p.numTargets;++M)if(p.getTarget(M)===b)return!0;return!1}));if(M){const h=p.meshes.find((p=>p.morphTargetManager===M));var z;if(h)x.has(h)||x.set(h,new Map),null===(z=x.get(h))||void 0===z||z.set(b,f),c.add(h),X.set(h,f)}}}}}c.forEach((p=>{const b=p.morphTargetManager;let P=null;const w=[],z=X.get(p).getKeys(),c=z.length;for(let M=0;M<c;++M)for(let h=0;h<b.numTargets;++h){const Q=b.getTarget(h),mp=x.get(p);if(mp){const b=mp.get(Q);b?(P||(P=new gp.d(`${S.name}_${p.name}_MorphWeightAnimation`,"influence",b.framePerSecond,gp.d.ANIMATIONTYPE_FLOAT,b.loopMode,b.enableBlending)),w.push(b.getKeys()[M])):w.push({frame:S.from+J/c*M,value:Q.influence,inTangent:z[0].inTangent?0:void 0,outTangent:z[0].outTangent?0:void 0})}}P.setKeys(w);const g=op._DeduceAnimationInfo(P);g&&op._AddAnimation(`${S.name}_${p.name}_MorphWeightAnimation`,t,p,P,g.dataAccessorType,g.animationChannelTargetPath,M,h,Q,mp,g.useQuaternion,y,!1,null===b||void 0===b?void 0:b.numTargets)})),t.channels.length&&t.samplers.length&&b.push(t)}}}static _AddAnimation(p,b,M,Q,mp,y,P,w,t,z,x,S,X,c){const J=op._CreateNodeAnimation(M,Q,y,x,S);let g,f,Y,a,o,l;if(J){if(c){let p=0,b=0;const M=[];for(;J.inputs.length>0;)b=J.inputs.shift(),p%c==0&&M.push(b),p++;J.inputs=M}const p=P.get(M),Q=new Float32Array(J.inputs);g=w.createBufferView(Q),f=w.createAccessor(g,"SCALAR",5126,J.inputs.length,void 0,{min:[J.inputsMin],max:[J.inputsMax]}),z.push(f),Y=z.length-1;const t=new h.Quaternion,x=new h.QM,S=new h.QM,L=M instanceof Sp.e,u=K(mp),e=new Float32Array(J.outputs.length*u);J.outputs.forEach((function(p,b){let M=p;switch(y){case"translation":X&&(h.QM.FromArrayToRef(p,0,S),n(S),S.toArray(M));break;case"rotation":4===p.length?h.Quaternion.FromArrayToRef(p,0,t):(M=new Array(4),h.QM.FromArrayToRef(p,0,x),h.Quaternion.FromEulerVectorToRef(x,t)),X&&(C(t),L&&F(t)),t.toArray(M)}e.set(M,b*u)})),g=w.createBufferView(e),f=w.createAccessor(g,mp,5126,J.outputs.length),z.push(f),a=z.length-1,o={interpolation:J.samplerInterpolation,input:Y,output:a},b.samplers.push(o),l={sampler:b.samplers.length-1,target:{node:p,path:y}},b.channels.push(l)}}static _CreateBakedAnimation(p,b,M,mp,y,P,w,t,z,x,S){let X;const c=h.Quaternion.Identity();let J,g=null,f=null,Y=null,a=null,o=null,l=null;x.min=Q.Tools.FloatRound(mp/P);const L=b.getKeys();for(let h=0,u=L.length;h<u;++h){if(l=null,Y=L[h],h+1<u)if(a=L[h+1],Y.value.equals&&Y.value.equals(a.value)||Y.value===a.value){if(0!==h)continue;l=Y.frame}else l=a.frame;else{if(o=L[h-1],Y.value.equals&&Y.value.equals(o.value)||Y.value===o.value)continue;l=y}if(l)for(let h=Y.frame;h<=l;h+=w){if(J=Q.Tools.FloatRound(h/P),J===g)continue;g=J,f=J;const mp={key:0,repeatCount:0,loopMode:b.loopMode};X=b._interpolate(h,mp),op._SetInterpolatedValue(p,X,J,b,M,c,t,z,S)}}f&&(x.max=f)}static _ConvertFactorToVector3OrQuaternion(p,b,M,mp,y){const P=op._GetBasePositionRotationOrScale(b,mp,y),w=M.targetProperty.split("."),t=w?w[1]:"",z=y?h.Quaternion.tM(P).normalize():h.QM.tM(P);switch(t){case"x":case"y":case"z":z[t]=p;break;case"w":z.w=p;break;default:Q.Tools.Error(`glTFAnimation: Unsupported component name "${t}"!`)}return z}static _SetInterpolatedValue(p,b,M,Q,mp,y,P,w,t){let z;P.push(M),"weights"!==mp?(Q.dataType===gp.d.ANIMATIONTYPE_FLOAT&&(b=this._ConvertFactorToVector3OrQuaternion(b,p,Q,mp,t)),"rotation"===mp?(t?y=b:(z=b,h.Quaternion.RotationYawPitchRollToRef(z.y,z.x,z.z,y)),w.push(y.ub())):(z=b,w.push(z.ub()))):w.push([b])}static _CreateLinearOrStepAnimation(p,b,M,h,Q,mp){for(const y of b.getKeys())h.push(y.frame/b.framePerSecond),op._AddKeyframeValue(y,b,Q,M,p,mp)}static _CreateCubicSplineAnimation(p,b,M,h,Q,mp){b.getKeys().forEach((function(y){h.push(y.frame/b.framePerSecond),op._AddSplineTangent(xp.INTANGENT,Q,M,"CUBICSPLINE",y,mp),op._AddKeyframeValue(y,b,Q,M,p,mp),op._AddSplineTangent(xp.OUTTANGENT,Q,M,"CUBICSPLINE",y,mp)}))}static _GetBasePositionRotationOrScale(p,b,M){let Q;if("rotation"===b)if(M){Q=(p.rotationQuaternion??h.Quaternion.Identity()).ub()}else{Q=(p.rotation??h.QM.Zero()).ub()}else if("translation"===b){Q=(p.position??h.QM.Zero()).ub()}else{Q=(p.ib??h.QM.One()).ub()}return Q}static _AddKeyframeValue(p,b,M,mp,y,P){let w;const t=b.dataType;if(t===gp.d.ANIMATIONTYPE_VECTOR3){let b=p.value.ub();if("rotation"===mp){const p=h.QM.tM(b);b=h.Quaternion.RotationYawPitchRoll(p.y,p.x,p.z).ub()}M.push(b)}else if(t===gp.d.ANIMATIONTYPE_FLOAT){if("weights"===mp)M.push([p.value]);else if(w=this._ConvertFactorToVector3OrQuaternion(p.value,y,b,mp,P),w){if("rotation"===mp){const p=P?w:h.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).normalize();M.push(p.ub())}M.push(w.ub())}}else t===gp.d.ANIMATIONTYPE_QUATERNION?M.push(p.value.normalize().ub()):Q.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(p,b,M){let h,Q,mp=!1;if("rotation"===b&&!M)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let y=0,P=p.length;y<P;++y)if(Q=p[y],Q.inTangent||Q.outTangent)if(h){if("CUBICSPLINE"!==h){h="LINEAR",mp=!0;break}}else h="CUBICSPLINE";else if(h){if("CUBICSPLINE"===h||Q.interpolation&&1===Q.interpolation&&"STEP"!==h){h="LINEAR",mp=!0;break}}else h=Q.interpolation&&1===Q.interpolation?"STEP":"LINEAR";return h||(h="LINEAR"),{interpolationType:h,shouldBakeAnimation:mp}}static _AddSplineTangent(p,b,M,Q,mp,y){let P;const w=p===xp.INTANGENT?mp.inTangent:mp.outTangent;if("CUBICSPLINE"===Q){if("rotation"===M)if(w)if(y)P=w.ub();else{const p=w;P=h.Quaternion.RotationYawPitchRoll(p.y,p.x,p.z).ub()}else P=[0,0,0,0];else P="weights"===M?w?[w]:[0]:w?w.ub():[0,0,0];b.push(P)}}static _CalculateMinMaxKeyFrames(p){let b=1/0,M=-1/0;return p.forEach((function(p){b=Math.min(b,p.frame),M=Math.max(M,p.frame)})),{min:b,max:M}}}function lp(p,b,M,mp,y,P){const w={attributes:{},influence:p.influence,name:p.name},t=b.Ub;if(!t)return Q.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),w;const x=P?-1:1,S=h.QM.Zero();let X=0,c=0;if(p.hasPositions){const mp=p.getPositions(),P=t.getVerticesData(z.f.PositionKind);if(P){const p=new Float32Array(P.length),b=[1/0,1/0,1/0],Q=[-1/0,-1/0,-1/0];c=P.length/3,X=0;for(let M=X;M<c;++M){const y=h.QM.tM(P,3*M);h.QM.tM(mp,3*M).subtractToRef(y,S),S.x*=x,b[0]=Math.min(b[0],S.x),Q[0]=Math.max(Q[0],S.x),b[1]=Math.min(b[1],S.y),Q[1]=Math.max(Q[1],S.y),b[2]=Math.min(b[2],S.z),Q[2]=Math.max(Q[2],S.z),p[3*M]=S.x,p[3*M+1]=S.y,p[3*M+2]=S.z}const t=M.createBufferView(p,12),z=M.createAccessor(t,"VEC3",5126,mp.length/3,0,{min:b,max:Q});y.push(z),w.attributes.POSITION=y.length-1}else Q.Tools.Warn(`Morph target positions for mesh ${b.name} were not exported. Mesh does not have position vertex data`)}if(p.hasNormals){const mp=p.getNormals(),P=t.getVerticesData(z.f.NormalKind);if(P){const p=new Float32Array(P.length);c=P.length/3,X=0;for(let M=X;M<c;++M){const b=h.QM.tM(P,3*M).normalize();h.QM.tM(mp,3*M).normalize().subtractToRef(b,S),p[3*M]=S.x*x,p[3*M+1]=S.y,p[3*M+2]=S.z}const b=M.createBufferView(p,12),Q=M.createAccessor(b,"VEC3",5126,mp.length/3,0);y.push(Q),w.attributes.NORMAL=y.length-1}else Q.Tools.Warn(`Morph target normals for mesh ${b.name} were not exported. Mesh does not have normals vertex data`)}if(p.hasTangents){const mp=p.getTangents(),P=t.getVerticesData(z.f.TangentKind);if(P){c=P.length/4;const p=new Float32Array(3*c);X=0;for(let M=X;M<c;++M){const b=h.QM.tM(P,4*M);A(b);const Q=h.QM.tM(mp,3*M);A(Q),Q.subtractToRef(b,S),p[3*M]=S.x*x,p[3*M+1]=S.y,p[3*M+2]=S.z}const b=M.createBufferView(p,12),Q=M.createAccessor(b,"VEC3",5126,c,0);y.push(Q),w.attributes.TANGENT=y.length-1}else Q.Tools.Warn(`Morph target tangents for mesh ${b.name} were not exported. Mesh does not have tangents vertex data`)}if(p.hasColors){const mp=p.getColors(),P=t.getVerticesData(z.f.ColorKind),x=t.getVertexBuffer(z.f.ColorKind);if(P&&x){const p=x.getSize();c=P.length/p;const b=new Float32Array(c*p);X=0;for(let M=X;M<c;++M)if(3===p){const Q=h.QM.tM(P,M*p);h.QM.tM(mp,M*p).subtractToRef(Q,S),b[3*M]=S.x,b[3*M+1]=S.y,b[3*M+2]=S.z}else if(4===p){const Q=new h.Vector4,y=h.Vector4.tM(P,M*p);h.Vector4.tM(mp,M*p).subtractToRef(y,Q),b[4*M]=Q.x,b[4*M+1]=Q.y,b[4*M+2]=Q.z,b[4*M+3]=Q.w}else Q.Tools.Warn(`Unsupported number of components for color attribute: ${p}`);const t=M.createBufferView(b,4*p),z=M.createAccessor(t,3===p?"VEC3":"VEC4",5126,c,0);y.push(z),w.attributes.COLOR_0=y.length-1}else Q.Tools.Warn(`Morph target colors for mesh ${b.name} were not exported. Mesh does not have colors vertex data`)}return w}var Lp=M(13330),upp=M(13183),ep=M(13170),dp=M(12730);class Ip{}Ip.DEFAULT_COLOR=g.wM.White(),Ip.DEFAULT_WIDTH_ATTENUATED=1,Ip.DEFAULT_WIDTH=.1;var Gp=M(12986),vp=M(13335);class Zp{static ConvertPoints(p,b){if(p.length&&Array.isArray(p)&&"number"===typeof p[0])return[p];if(p.length&&Array.isArray(p[0])&&"number"===typeof p[0][0])return p;if(p.length&&!Array.isArray(p[0])&&p[0]instanceof h.QM){const b=[];for(let M=0;M<p.length;M++){const h=p[M];b.push(h.x,h.y,h.z)}return[b]}if(p.length>0&&Array.isArray(p[0])&&p[0].length>0&&p[0][0]instanceof h.QM){const b=[],M=p;for(const p of M)b.push(p.flatMap((p=>[p.x,p.y,p.z])));return b}if(p instanceof Float32Array){if(null!==b&&void 0!==b&&b.floatArrayStride){const M=[],h=3*b.floatArrayStride;for(let b=0;b<p.length;b+=h){const Q=new Array(h);for(let M=0;M<h;M++)Q[M]=p[b+M];M.push(Q)}return M}return[Array.from(p)]}if(p.length&&p[0]instanceof Float32Array){const b=[];for(const M of p)b.push(Array.from(M));return b}return[]}static OmitZeroLengthPredicate(p,b,M){const h=[];return b.mh(p).lengthSquared()>0&&h.push([p,b]),M.mh(b).lengthSquared()>0&&h.push([b,M]),p.mh(M).lengthSquared()>0&&h.push([M,p]),0===h.length?null:h}static OmitDuplicatesPredicate(p,b,M,h){const Q=[];return Zp._SearchInPoints(p,b,h)||Q.push([p,b]),Zp._SearchInPoints(b,M,h)||Q.push([b,M]),Zp._SearchInPoints(M,p,h)||Q.push([M,p]),0===Q.length?null:Q}static _SearchInPoints(p,b,M){for(const y of M)for(let M=0;M<y.length;M++){var h,Q,mp;if(null!==(h=y[M])&&void 0!==h&&h.equals(p))if(null!==(Q=y[M+1])&&void 0!==Q&&Q.equals(b)||null!==(mp=y[M-1])&&void 0!==mp&&mp.equals(b))return!0}return!1}static MeshesToLines(p,b){const M=[];for(let Q=0;Q<p.length;Q++){const mp=p[Q],y=mp.getVerticesData(z.f.PositionKind),P=mp.qb();if(y&&P)for(let p=0,w=0;p<P.length;p++){const t=3*P[w++],z=3*P[w++],x=3*P[w++],S=new h.QM(y[t],y[t+1],y[t+2]),X=new h.QM(y[z],y[z+1],y[z+2]),c=new h.QM(y[x],y[x+1],y[x+2]);if(b){const h=b(S,X,c,M,p,t,mp,Q,y,P);if(h)for(const p of h)M.push(p)}else M.push([S,X],[X,c],[c,S])}}return M}static ToVector3Array(p){if(Array.isArray(p[0])){const b=[],M=p;for(const p of M){const M=[];for(let b=0;b<p.length;b+=3)M.push(new h.QM(p[b],p[b+1],p[b+2]));b.push(M)}return b}const b=p,M=[];for(let Q=0;Q<b.length;Q+=3)M.push(new h.QM(b[Q],b[Q+1],b[Q+2]));return M}static ToNumberArray(p){return p.flatMap((p=>[p.x,p.y,p.z]))}static GetPointsCountInfo(p){const b=new Array(p.length);let M=0;for(let h=p.length;h--;)b[h]=p[h].length/3,M+=b[h];return{total:M,counts:b}}static GetLineLength(p){if(0===p.length)return 0;let b;b="number"===typeof p[0]?Zp.ToVector3Array(p):p;const M=h.TmpVectors.QM[0];let Q=0;for(let h=0;h<b.length-1;h++){const p=b[h];Q+=b[h+1].subtractToRef(p,M).length()}return Q}static GetLineLengthArray(p){const b=new Float32Array(p.length/3);let M=0;for(let h=0,Q=p.length/3-1;h<Q;h++){let Q=p[3*h+0],mp=p[3*h+1],y=p[3*h+2];Q-=p[3*h+3],mp-=p[3*h+4],y-=p[3*h+5];M+=Math.sqrt(Q*Q+mp*mp+y*y),b[h+1]=M}return b}static SegmentizeSegmentByCount(p,b,M){const Q=[],mp=b.mh(p),y=h.TmpVectors.QM[0];y.Tb(M);const P=h.TmpVectors.QM[1];mp.divideToRef(y,P);let w=p.clone();Q.push(w);for(let h=0;h<M;h++)w=w.clone(),Q.push(w.addInPlace(P));return Q}static SegmentizeLineBySegmentLength(p,b){const M=p[0]instanceof h.QM?Zp.GetLineSegments(p):"number"===typeof p[0]?Zp.GetLineSegments(Zp.ToVector3Array(p)):p,Q=[];for(const h of M)if(h.length>b){const p=Zp.SegmentizeSegmentByCount(h.point1,h.point2,Math.ceil(h.length/b));for(const b of p)Q.push(b)}else Q.push(h.point1),Q.push(h.point2);return Q}static SegmentizeLineBySegmentCount(p,b){const M="number"===typeof p[0]?Zp.ToVector3Array(p):p,h=Zp.GetLineLength(M)/b;return Zp.SegmentizeLineBySegmentLength(M,h)}static GetLineSegments(p){const b=[];for(let M=0;M<p.length-1;M++){const h=p[M],Q=p[M+1],mp=Q.mh(h).length();b.push({point1:h,point2:Q,length:mp})}return b}static GetMinMaxSegmentLength(p){const b=Zp.GetLineSegments(p).sort((p=>p.length));return{min:b[0].length,max:b[b.length-1].length}}static GetPositionOnLineByVisibility(p,b,M){let Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const mp=b*M;let y=0,P=0;const w=p.length;for(let h=0;h<w;h++){if(mp<=y+p[h].length){P=h;break}y+=p[h].length}const t=(mp-y)/p[P].length;return p[P].point2.subtractToRef(p[P].point1,h.TmpVectors.QM[0]),h.TmpVectors.QM[1]=h.TmpVectors.QM[0].multiplyByFloats(t,t,t),Q||h.TmpVectors.QM[1].addInPlace(p[P].point1),h.TmpVectors.QM[1].clone()}static GetCircleLinePoints(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,Q=arguments.length>3&&void 0!==arguments[3]?arguments[3]:p,mp=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/b;const y=[];for(let P=0;P<=b;P++)y.push(new h.QM(Math.cos(P*mp)*p,Math.sin(P*mp)*Q,M));return y}static GetBezierLinePoints(p,b,M,h){return Gp.e.CreateQuadraticBezier(p,b,M,h).getPoints().flatMap((p=>[p.x,p.y,p.z]))}static GetArrowCap(p,b,M,h,Q){let mp=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[p.clone(),p.add(b.multiplyByFloats(M,M,M))],widths:[h,Q,mp,y]}}static GetPointsFromText(p,b,M,h){let Q=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,mp=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const y=[],P=(0,vp.c)(p,b,M,h);for(const w of P){for(const p of w.paths){const b=[],M=p.getPoints();for(const p of M)b.push(p.x,p.y,Q);y.push(b)}if(mp)for(const p of w.holes){const b=[],M=p.getPoints();for(const p of M)b.push(p.x,p.y,Q);y.push(b)}}return y}static Color3toRGBAUint8(p){const b=new Uint8Array(4*p.length);for(let M=0,h=0;M<p.length;M++)b[h++]=255*p[M].r,b[h++]=255*p[M].g,b[h++]=255*p[M].b,b[h++]=255;return b}static CreateColorsTexture(p,b,M,h){const Q=h.getEngine().getCaps().maxTextureSize??1,mp=b.length>Q?Q:b.length,y=Math.ceil(b.length/Q);y>1&&(b=[...b,...Array(mp*y-b.length).fill(b[0])]);const P=Zp.Color3toRGBAUint8(b),w=new L.c(P,mp,y,c.e.TEXTUREFORMAT_RGBA,h,!1,!0,M);return w.name=p,w}static PrepareEmptyColorsTexture(p){if(!Ip.EmptyColorsTexture){const b=new Uint8Array(4);Ip.EmptyColorsTexture=new L.c(b,1,1,c.e.TEXTUREFORMAT_RGBA,p,!1,!1,L.c.NEAREST_NEAREST),Ip.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Ip.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var p;null===(p=Ip.EmptyColorsTexture)||void 0===p||p.dispose(),Ip.EmptyColorsTexture=null}static BooleanToNumber(p){return p?1:0}}class Up extends ep.d{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class qp extends upp.e{isCompatible(p){return!0}constructor(p,b,M){var Q;M=M||{color:Ip.DEFAULT_COLOR};const mp=new Up;mp.GREASED_LINE_HAS_COLOR=!!M.color&&!M.useColors,mp.GREASED_LINE_SIZE_ATTENUATION=M.sizeAttenuation??!1,mp.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===M.colorDistributionType,mp.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(b??p.upp()).useRightHandedSystem,mp.GREASED_LINE_CAMERA_FACING=M.cameraFacing??!0,super(p,qp.GREASED_LINE_MATERIAL_NAME,200,mp,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(Q=M)||void 0===Q?void 0:Q.forceGLSL)||qp.ForceGLSL,this._scene=b??p.upp(),this._engine=this._scene.getEngine(),this._cameraFacing=M.cameraFacing??!0,this.visibility=M.visibility??1,this.useDash=M.useDash??!1,this.dashRatio=M.dashRatio??.5,this.dashOffset=M.dashOffset??0,this.width=M.width?M.width:M.sizeAttenuation?Ip.DEFAULT_WIDTH_ATTENUATED:Ip.DEFAULT_WIDTH,this._sizeAttenuation=M.sizeAttenuation??!1,this.colorMode=M.colorMode??0,this._color=M.color??null,this.useColors=M.useColors??!1,this._colorsDistributionType=M.colorDistributionType??0,this.colorsSampling=M.colorsSampling??L.c.NEAREST_NEAREST,this._colors=M.Gp??null,this.dashCount=M.dashCount??1,this.resolution=M.resolution??new h.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),M.colorsTexture?this.colorsTexture=M.colorsTexture:this._colors?this.colorsTexture=Zp.CreateColorsTexture(`${p.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Ip.DEFAULT_COLOR,Zp.PrepareEmptyColorsTexture(this._scene)),this._engine.Xb.add((()=>{Zp.DisposeEmptyColorsTexture()}))}getAttributes(p){p.push("grl_offsets"),p.push("grl_widths"),p.push("grl_colorPointers"),p.push("grl_counters"),this._cameraFacing?(p.push("grl_previousAndSide"),p.push("grl_nextAndCounters")):p.push("grl_slopes")}getSamplers(p){p.push("grl_colors")}getActiveTextures(p){this.colorsTexture&&p.push(this.colorsTexture)}getUniforms(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const b=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&b.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===p&&b.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:b,vertex:this._cameraFacing&&this._isGLSL(p)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(p)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(p){if(this._cameraFacing){p.Gb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||p.Gb("viewProjection",this._scene.getTransformMatrix());const b=h.TmpVectors.Vector4[0];b.x=this._aspect,b.y=this._resolution.x,b.z=this._resolution.y,b.w=this.width,p.updateVector4("grl_aspect_resolution_lineWidth",b)}const b=h.TmpVectors.Vector4[0];b.x=Zp.BooleanToNumber(this.useDash),b.y=this._dashArray,b.z=this.dashOffset,b.w=this.dashRatio,p.updateVector4("grl_dashOptions",b);const M=h.TmpVectors.Vector4[1];M.x=this.colorMode,M.y=this.visibility,M.z=this.colorsTexture?this.colorsTexture.getSize().width:0,M.w=Zp.BooleanToNumber(this.useColors),p.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",M),this._color&&p.updateColor3("grl_singleColor",this._color);const Q=this.colorsTexture??Ip.EmptyColorsTexture;p.setTexture("grl_colors",Q),p.updateFloat2("grl_textureSize",(null===Q||void 0===Q?void 0:Q.getSize().width)??1,(null===Q||void 0===Q?void 0:Q.getSize().height)??1)}prepareDefines(p,b,M){p.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,p.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,p.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,p.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=b.useRightHandedSystem,p.GREASED_LINE_CAMERA_FACING=this._cameraFacing,p.GREASED_LINE_USE_OFFSETS=!!M.offsets}getClassName(){return qp.GREASED_LINE_MATERIAL_NAME}getCustomCode(p){let b=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(b)?function(p,b){if("vertex"===p){const p={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return b&&(p["!gl_Position\\=viewProjection\\*worldPos;"]="//"),p}return"fragment"===p?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(p,this._cameraFacing):function(p,b){if("vertex"===p){const p={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return b&&(p["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),p}return"fragment"===p?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(p,this._cameraFacing)}dispose(){var p;null===(p=this.colorsTexture)||void 0===p||p.dispose(),super.dispose()}get Gp(){return this._colors}set Gp(p){this.setColors(p)}setColors(p){var b;let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var mp;if(this._colors=p,null!==p&&0!==p.length){if(!M||h)if(this.colorsTexture&&Q===p.length&&!h){const b=Zp.Color3toRGBAUint8(p);this.colorsTexture.update(b)}else{var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=Zp.CreateColorsTexture(`${this._material.name}-colors-texture`,p,this.colorsSampling,this._scene)}}else null===(mp=this.colorsTexture)||void 0===mp||mp.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(p){this._dashCount=p,this._dashArray=1/p}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(p){this._sizeAttenuation=p,this.markAllDefinesAsDirty()}get color(){return this._color}set color(p){this.setColor(p)}setColor(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==p||null!==this._color&&null===p?(this._color=p,b||this.markAllDefinesAsDirty()):this._color=p}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(p){this._colorsDistributionType=p,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(p){this._aspect=p.x/p.y,this._resolution=p}serialize(){const p=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(b.Gp=this._colors),this._color&&(b.color=this._color),p.greasedLineMaterialOptions=b,p}parse(p,b,M){var h;super.parse(p,b,M);const Q=p.greasedLineMaterialOptions;null===(h=this.colorsTexture)||void 0===h||h.dispose(),Q.color&&this.setColor(Q.color,!0),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.Gp&&(this.Gp=Q.Gp),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),this.Gp?this.colorsTexture=Zp.CreateColorsTexture(`${this._material.name}-colors-texture`,this.Gp,this.colorsSampling,b):Zp.PrepareEmptyColorsTexture(b),this.markAllDefinesAsDirty()}copyTo(p){var b;const M=p;null===(b=M.colorsTexture)||void 0===b||b.dispose(),this._colors&&(M.colorsTexture=Zp.CreateColorsTexture(`${M._material.name}-colors-texture`,this._colors,M.colorsSampling,this._scene)),M.setColor(this.color,!0),M.colorsDistributionType=this.colorsDistributionType,M.colorsSampling=this.colorsSampling,M.colorMode=this.colorMode,M.useColors=this.useColors,M.visibility=this.visibility,M.useDash=this.useDash,M.dashCount=this.dashCount,M.dashRatio=this.dashRatio,M.dashOffset=this.dashOffset,M.width=this.width,M.sizeAttenuation=this.sizeAttenuation,M.resolution=this.resolution,M.markAllDefinesAsDirty()}_isGLSL(p){return 0===p||this._forceGLSL}}qp.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",qp.ForceGLSL=!1,(0,dp.c)(`BABYLON.${qp.GREASED_LINE_MATERIAL_NAME}`,qp);var Bp=M(13219),sp=M(12624),ip=M(13007),Tp=M(12714);class Wp extends ip.ShaderMaterial{constructor(p,b,Q){const mp=b.getEngine(),y=mp.isWebGPU&&!(Q.forceGLSL||Wp.ForceGLSL),P=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];b.useRightHandedSystem&&P.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const w=["position","grl_widths","grl_offsets","grl_colorPointers"];Q.cameraFacing?(P.push("GREASED_LINE_CAMERA_FACING"),w.push("grl_previousAndSide","grl_nextAndCounters")):(w.push("grl_slopes"),w.push("grl_counters"));const t=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(y||t.push("world","viewProjection","view","projection"),super(p,b,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:y?["Scene","Mesh"]:void 0,attributes:w,uniforms:t,samplers:y?[]:["grlColors"],defines:P,extraInitializationsAsync:async()=>{y?await Promise.all([M.e(66).then(M.bind(M,15921)),M.e(75).then(M.bind(M,15924))]):await Promise.all([M.e(69).then(M.bind(M,15931)),M.e(76).then(M.bind(M,15934))])},shaderLanguage:y?1:0}),this._color=g.wM.White(),this._colorsDistributionType=0,this._colorsTexture=null,Q=Q||{color:Ip.DEFAULT_COLOR},this.visibility=Q.visibility??1,this.useDash=Q.useDash??!1,this.dashRatio=Q.dashRatio??.5,this.dashOffset=Q.dashOffset??0,this.dashCount=Q.dashCount??1,this.width=Q.width?Q.width:Q.sizeAttenuation&&Q.cameraFacing?Ip.DEFAULT_WIDTH_ATTENUATED:Ip.DEFAULT_WIDTH,this.sizeAttenuation=Q.sizeAttenuation??!1,this.color=Q.color??g.wM.White(),this.useColors=Q.useColors??!1,this.colorsDistributionType=Q.colorDistributionType??0,this.colorsSampling=Q.colorsSampling??L.c.NEAREST_NEAREST,this.colorMode=Q.colorMode??0,this._colors=Q.Gp??null,this._cameraFacing=Q.cameraFacing??!0,this.resolution=Q.resolution??new h.Vector2(mp.getRenderWidth(),mp.getRenderHeight()),Q.colorsTexture?this.colorsTexture=Q.colorsTexture:this._colors?this.colorsTexture=Zp.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,b):(this._color=this._color??Ip.DEFAULT_COLOR,this.colorsTexture=Zp.PrepareEmptyColorsTexture(b)),y){const p=new Tp.e;p.setParameters(),p.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",p)}mp.Xb.add((()=>{Zp.DisposeEmptyColorsTexture()}))}dispose(){var p;null===(p=this._colorsTexture)||void 0===p||p.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new h.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get Gp(){return this._colors}set Gp(p){this.setColors(p)}setColors(p){var b;let M=arguments.length>1&&void 0!==arguments[1]&&arguments[1],h=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const Q=(null===(b=this._colors)||void 0===b?void 0:b.length)??0;var mp;if(this._colors=p,null!==p&&0!==p.length){if(!M||h)if(this._colorsTexture&&Q===p.length&&!h){const b=Zp.Color3toRGBAUint8(p);this._colorsTexture.update(b)}else{var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=Zp.CreateColorsTexture(`${this.name}-colors-texture`,p,this.colorsSampling,this.upp())}}else null===(mp=this._colorsTexture)||void 0===mp||mp.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(p){this._colorsTexture=p,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(p){this._width=p,this.setFloat("grlWidth",p)}get useColors(){return this._useColors}set useColors(p){this._useColors=p,this.setFloat("grlUseColors",Zp.BooleanToNumber(p))}get colorsSampling(){return this._colorsSampling}set colorsSampling(p){this._colorsSampling=p}get visibility(){return this._visibility}set visibility(p){this._visibility=p,this.setFloat("grlVisibility",p)}get useDash(){return this._useDash}set useDash(p){this._useDash=p,this.setFloat("grlUseDash",Zp.BooleanToNumber(p))}get dashOffset(){return this._dashOffset}set dashOffset(p){this._dashOffset=p,this.setFloat("grlDashOffset",p)}get dashRatio(){return this._dashRatio}set dashRatio(p){this._dashRatio=p,this.setFloat("grlDashRatio",p)}get dashCount(){return this._dashCount}set dashCount(p){this._dashCount=p,this._dashArray=1/p,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(p){this._sizeAttenuation=p,this.setFloat("grlSizeAttenuation",Zp.BooleanToNumber(p))}get color(){return this._color}set color(p){this.setColor(p)}setColor(p){p=p??Ip.DEFAULT_COLOR,this._color=p,this.setColor3("grlColor",p)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(p){this._colorsDistributionType=p,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(p){this._colorMode=p,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(p){this._resolution=p,this.setVector2("grlResolution",p),this.setFloat("grlAspect",p.x/p.y)}serialize(){const p=super.serialize(),b={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(b.Gp=this._colors),p.greasedLineMaterialOptions=b,p}parse(p,b,M){var h;const Q=p.greasedLineMaterialOptions;null===(h=this._colorsTexture)||void 0===h||h.dispose(),Q.color&&(this.color=Q.color),Q.colorDistributionType&&(this.colorsDistributionType=Q.colorDistributionType),Q.colorsSampling&&(this.colorsSampling=Q.colorsSampling),Q.colorMode&&(this.colorMode=Q.colorMode),Q.useColors&&(this.useColors=Q.useColors),Q.visibility&&(this.visibility=Q.visibility),Q.useDash&&(this.useDash=Q.useDash),Q.dashCount&&(this.dashCount=Q.dashCount),Q.dashRatio&&(this.dashRatio=Q.dashRatio),Q.dashOffset&&(this.dashOffset=Q.dashOffset),Q.width&&(this.width=Q.width),Q.sizeAttenuation&&(this.sizeAttenuation=Q.sizeAttenuation),Q.resolution&&(this.resolution=Q.resolution),Q.Gp?this.colorsTexture=Zp.CreateColorsTexture(`${this.name}-colors-texture`,Q.Gp,this.colorsSampling,this.upp()):this.colorsTexture=Zp.PrepareEmptyColorsTexture(b),this._cameraFacing=Q.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Hp,Ep,jp;Wp.ForceGLSL=!1,function(p){p[p.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",p[p.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Hp||(Hp={})),function(p){p[p.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",p[p.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",p[p.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Ep||(Ep={})),function(p){p[p.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",p[p.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",p[p.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",p[p.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",p[p.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(jp||(jp={}));class Vp extends Yp.e{constructor(p,b,M){super(p,b,null,null,!1,!1),this.name=p,this._options=M,this._lazy=!1,this._updatable=!1,this._engine=b.getEngine(),this._lazy=M.lazy??!1,this._updatable=M.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=M.colorPointers??[],this._widths=M.widths??new Array(M.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(p){let b=0;for(const h of this._points)b+=h.length;const M=b/3*2-this._widths.length;for(let h=0;h<M;h++)this._widths.push(p)}updateLazy(){var p,b;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(p=this._options.ribbonOptions)||void 0===p?void 0:p.smoothShading),!this.qp&&this.refreshBoundingInfo(),null===(b=this.greasedLineMaterial)||void 0===b||b.updateLazy()}addPoints(p,b){for(const M of p)this._points.push(M);this._lazy||this.setPoints(this._points,b)}dispose(p){let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(p,b)}isLazy(){return this._lazy}get vp(){return this._uvs}set vp(p){this._uvs=p instanceof Float32Array?p:new Float32Array(p),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(p){this.material instanceof Wp&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===p||void 0===p?void 0:p.length)>0),this._offsets=p,this._offsetsBuffer?this._offsetsBuffer.update(p):this._createOffsetsBuffer(p)}get widths(){return this._widths}set widths(p){this._widths=p,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(p)}get colorPointers(){return this._colorPointers}set colorPointers(p){this._colorPointers=p,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(p)}get greasedLineMaterial(){var p,b;if(this.material&&this.material instanceof Wp)return this.material;const M=null===(p=this.material)||void 0===p||null===(b=p.pluginManager)||void 0===b?void 0:b.getPlugin(qp.GREASED_LINE_MATERIAL_NAME);return M||void 0}get points(){const p=[];return sp.b.DeepCopy(this._points,p),p}setPoints(p,b){this._points=Zp.ConvertPoints(p,(null===b||void 0===b?void 0:b.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==b&&void 0!==b&&b.colorPointers||this._updateColorPointers(),this._setPoints(this._points,b)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,vp:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(p){super.serialize(p),p.type=this.getClassName(),p.lineOptions=this._createLineOptions()}_createVertexBuffers(){let p=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const b=new Bp.e;return b.dp=this._vertexPositions,b.indices=this._indices,b.vp=this._uvs,p&&(b.Ip=[],Bp.e.ComputeNormals(this._vertexPositions,this._indices,b.Ip)),b.Up(this,this._options.updatable),b}_createOffsetsBuffer(p){const b=this._scene.getEngine(),M=new z.d(b,p,this._updatable,3);this.setVerticesBuffer(M.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=M}}class Dp{constructor(p,b){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=p,this.wasAddedByNoopNode=b}getIndicesAccessor(p,b,M,h,Q){var mp,y,P,w;return null===(mp=this._indicesAccessorMap.get(p))||void 0===mp||null===(y=mp.get(b))||void 0===y||null===(P=y.get(M))||void 0===P||null===(w=P.get(h))||void 0===w?void 0:w.get(Q)}setIndicesAccessor(p,b,M,h,Q,mp){let y=this._indicesAccessorMap.get(p);y||(y=new Map,this._indicesAccessorMap.set(p,y));let P=y.get(b);P||(P=new Map,y.set(b,P));let w=P.get(M);w||(w=new Map,P.set(M,w));let t=w.get(h);t||(t=new Map,w.set(h,t)),t.set(Q,mp)}pushExportedNode(p){this._exportedNodes.has(p)||this._exportedNodes.add(p)}getNodesSet(){return this._exportedNodes}getVertexBufferView(p){return this._vertexBufferViewMap.get(p)}setVertexBufferView(p,b){this._vertexBufferViewMap.set(p,b)}setRemappedBufferView(p,b,M){this._remappedBufferView.set(p,new Map),this._remappedBufferView.get(p).set(b,M)}getRemappedBufferView(p,b){var M;return null===(M=this._remappedBufferView.get(p))||void 0===M?void 0:M.get(b)}getVertexAccessor(p,b,M){var h,Q;return null===(h=this._vertexAccessorMap.get(p))||void 0===h||null===(Q=h.get(b))||void 0===Q?void 0:Q.get(M)}setVertexAccessor(p,b,M,h){let Q=this._vertexAccessorMap.get(p);Q||(Q=new Map,this._vertexAccessorMap.set(p,Q));let mp=Q.get(b);mp||(mp=new Map,Q.set(b,mp)),mp.set(M,h)}hasVertexColorAlpha(p){return this._vertexMapColorAlpha.get(p)||!1}setHasVertexColorAlpha(p,b){return this._vertexMapColorAlpha.set(p,b)}getMesh(p){return this._meshMap.get(p)}setMesh(p,b){this._meshMap.set(p,b)}bindMorphDataToMesh(p,b){const M=this._meshMorphTargetMap.get(p)||[];this._meshMorphTargetMap.set(p,M),-1===M.indexOf(b)&&M.push(b)}getMorphTargetsFromMesh(p){return this._meshMorphTargetMap.get(p)}}class Np{_ApplyExtension(p,b,M,h){if(M>=b.length)return Promise.resolve(p);const Q=h(b[M],p);return Q?Q.then((async p=>p?await this._ApplyExtension(p,b,M+1,h):null)):this._ApplyExtension(p,b,M+1,h)}_ApplyExtensions(p,b){const M=[];for(const h of Np._ExtensionNames)M.push(this._extensions[h]);return this._ApplyExtension(p,M,0,b)}_extensionsPreExportTextureAsync(p,b,M){return this._ApplyExtensions(b,((b,h)=>b.preExportTextureAsync&&b.preExportTextureAsync(p,h,M)))}_extensionsPostExportNodeAsync(p,b,M,h,Q){return this._ApplyExtensions(b,((b,mp)=>b.postExportNodeAsync&&b.postExportNodeAsync(p,mp,M,h,Q,this._bufferManager)))}_extensionsPostExportMaterialAsync(p,b,M){return this._ApplyExtensions(b,((b,h)=>b.postExportMaterialAsync&&b.postExportMaterialAsync(p,h,M)))}_extensionsPostExportMaterialAdditionalTextures(p,b,M){const h=[];for(const Q of Np._ExtensionNames){const mp=this._extensions[Q];mp.postExportMaterialAdditionalTextures&&h.push(...mp.postExportMaterialAdditionalTextures(p,b,M))}return h}_extensionsPostExportTextures(p,b,M){for(const h of Np._ExtensionNames){const Q=this._extensions[h];Q.postExportTexture&&Q.postExportTexture(p,b,M)}}_extensionsPostExportMeshPrimitive(p){for(const b of Np._ExtensionNames){const M=this._extensions[b];M.postExportMeshPrimitive&&M.postExportMeshPrimitive(p,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const p of Np._ExtensionNames){const b=this._extensions[p];b.preGenerateBinaryAsync&&await b.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(p){for(const b of Np._ExtensionNames){const M=this._extensions[b];M.enabled&&p(M)}}_extensionsOnExporting(){this._forEachExtensions((p=>{var b,M,h;p.wasUsed&&((b=this._glTF).extensionsUsed||(b.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(p.name)&&this._glTF.extensionsUsed.push(p.name),p.required&&((M=this._glTF).extensionsRequired||(M.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(p.name)&&this._glTF.extensionsRequired.push(p.name)),(h=this._glTF).extensions||(h.extensions={}),p.onExporting&&p.onExporting())}))}_loadExtensions(){for(const p of Np._ExtensionNames){const b=Np._ExtensionFactories[p](this);this._extensions[p]=b}}constructor(){let p=arguments.length>0&&void 0!==arguments[0]?arguments[0]:J.c.LastCreatedScene,b=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${c.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new T(this),this._extensions={},this._bufferManager=new zp,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!p)throw new Error("No scene available to export");this._babylonScene=p,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:p=>{var b;return null===p||void 0===p||null===(b=p.fb)||void 0===b?void 0:b.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...b},this._loadExtensions()}dispose(){for(const p in this._extensions){this._extensions[p].dispose()}}get options(){return this._options}static RegisterExtension(p,b){Np.UnregisterExtension(p)&&Q.Tools.Warn(`Extension with the name ${p} already exists`),Np._ExtensionFactories[p]=b,Np._ExtensionNames.push(p)}static UnregisterExtension(p){if(!Np._ExtensionFactories[p])return!1;delete Np._ExtensionFactories[p];const b=Np._ExtensionNames.indexOf(p);return-1!==b&&Np._ExtensionNames.splice(b,1),!0}_generateJSON(p,b,M){const h={byteLength:p};return h.byteLength&&(this._glTF.buffers=[h]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.yM=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(h.uri=b+".bin"),M?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(p){const b=await this._generateBinaryAsync();this._extensionsOnExporting();const M=this._generateJSON(b.byteLength,p,!0),h=new Blob([b],{type:"application/octet-stream"}),Q=p+".gltf",mp=p+".bin",y=new t;if(y.files[Q]=M,y.files[mp]=h,this._imageData)for(const P in this._imageData)y.files[P]=new Blob([this._imageData[P].data],{type:this._imageData[P].mimeType});return y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(p){const b=p%4;return 0===b?b:4-b}async generateGLBAsync(p){this._shouldUseGlb=!0;const b=await this._generateBinaryAsync();this._extensionsOnExporting();const M=this._generateJSON(b.byteLength),h=p+".glb";let Q,mp=M.length;if("undefined"!==typeof TextEncoder){Q=(new TextEncoder).encode(M),mp=Q.length}const y=this._getPadding(mp),P=this._getPadding(b.byteLength),w=28+mp+y+b.byteLength+P,z=new wp(w);if(z.writeUInt32(1179937895),z.writeUInt32(2),z.writeUInt32(w),z.writeUInt32(mp+y),z.writeUInt32(1313821514),Q)z.writeTypedArray(Q);else{const p="_".charCodeAt(0);for(let b=0;b<mp;++b){const h=M.charCodeAt(b);h!=M.codePointAt(b)?z.writeUInt8(p):z.writeUInt8(h)}}for(let t=0;t<y;++t)z.writeUInt8(32);z.writeUInt32(b.byteLength+P),z.writeUInt32(5130562),z.writeTypedArray(b);for(let t=0;t<P;++t)z.writeUInt8(0);const x=new t;return x.files[h]=new Blob([z.getOutputData()],{type:"application/octet-stream"}),x}_setNodeTransformation(p,b,M){if(b.getPivotPoint().equalsWithEpsilon(V,j.d)||Q.Tools.Warn("Pivot points are not supported in the glTF serializer"),!b.position.equalsWithEpsilon(V,j.d)){const Q=h.TmpVectors.QM[0].mp(b.position);M&&n(Q),p.translation=Q.ub()}b.ib.equalsWithEpsilon(N,j.d)||(p.scale=b.ib.ub());const mp=b.rotationQuaternion||h.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);mp.equalsWithEpsilon(D,j.d)||(M&&C(mp),p.rotation=mp.normalize().ub())}_setCameraTransformation(p,b,M){if(!b.position.equalsWithEpsilon(V,j.d)){const Q=h.TmpVectors.QM[0].mp(b.position);M&&n(Q),p.translation=Q.ub()}const Q=b.rotationQuaternion||h.Quaternion.FromEulerAngles(b.rotation.x,b.rotation.y,b.rotation.z);M&&C(Q),this._babylonScene.useRightHandedSystem||F(Q),Q.equalsWithEpsilon(D,j.d)||(p.rotation=Q.ub())}_listAvailableCameras(){for(const p of this._babylonScene.cameras){const b={type:p.mode===Sp.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(p.name&&(b.name=p.name),"perspective"===b.type)b.perspective={aspectRatio:p.getEngine().getAspectRatio(p),yfov:p.fovMode===Sp.e.FOVMODE_VERTICAL_FIXED?p.fov:p.fov*p.getEngine().getAspectRatio(p),znear:p.Ib,zfar:p.maxZ};else if("orthographic"===b.type){const M=p.orthoLeft&&p.orthoRight?.5*(p.orthoRight-p.orthoLeft):.5*p.getEngine().getRenderWidth(),h=p.orthoBottom&&p.orthoTop?.5*(p.orthoTop-p.orthoBottom):.5*p.getEngine().getRenderHeight();b.orthographic={xmag:M,ymag:h,znear:p.Ib,zfar:p.maxZ}}this._camerasMap.set(p,b)}}_exportAndAssignCameras(){const p=Array.from(this._camerasMap.values());for(const b of p){const p=this._nodesCameraMap.get(b);if(void 0!==p){this._cameras.push(b);for(const b of p)b.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const p of this._babylonScene.skeletons){if(p.bones.length<=0)continue;const b={joints:[]};this._skinMap.set(p,b)}}_exportAndAssignSkeletons(){for(const p of this._babylonScene.skeletons){if(p.bones.length<=0)continue;const b=this._skinMap.get(p);if(void 0==b)continue;const M={},h=[];let mp=-1;for(let Q=0;Q<p.bones.length;++Q){const b=p.bones[Q],h=b.getIndex()??Q;-1!==h&&(M[h]=b,h>mp&&(mp=h))}for(let p=0;p<=mp;++p){const mp=M[p];h.push(mp.getAbsoluteInverseBindMatrix());const y=mp.getTransformNode();if(null!==y){const p=this._nodeMap.get(y);y&&null!==p&&void 0!==p?b.joints.push(p):Q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else Q.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const y=this._nodesSkinMap.get(b);if(b.joints.length>0&&void 0!==y){const p=64*h.length,M=new Float32Array(p/4);h.forEach(((p,b)=>{M.set(p.m,16*b)}));const Q=this._bufferManager.createBufferView(M);this._accessors.push(this._bufferManager.createAccessor(Q,"MAT4",5126,h.length)),b.inverseBindMatrices=this._accessors.length-1,this._skins.push(b);for(const b of y)b.skin=this._skins.length-1}}}async _exportSceneAsync(){const p={nodes:[]};if(this._babylonScene.metadata){const b=this._options.metadataSelector(this._babylonScene.metadata);b&&(p.extras=b)}const b=new Array,M=new Array,h=new Array;for(const P of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&yp(P,this._babylonScene.useRightHandedSystem)?h.push(...P.getChildren()):this._babylonScene.useRightHandedSystem?b.push(P):M.push(P);this._listAvailableCameras(),this._listAvailableSkeletons();const Q=new Dp(!0,!1);p.nodes.push(...await this._exportNodesAsync(M,Q));const mp=new Dp(!1,!1);p.nodes.push(...await this._exportNodesAsync(b,mp));const y=new Dp(!1,!0);p.nodes.push(...await this._exportNodesAsync(h,y)),p.nodes.length&&this._scenes.push(p),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&op._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,Q.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(p){let b=this._shouldExportNodeMap.get(p);return void 0===b&&(b=this._options.shouldExportNode(p),this._shouldExportNodeMap.set(p,b)),b}async _exportNodesAsync(p,b){const M=new Array;this._exportBuffers(p,b);for(const h of p)await this._exportNodeAsync(h,M,b);return M}_collectBuffers(p,b,M,h,Q){if(this._shouldExportNode(p)&&p instanceof S.c&&p.Ub){const mp=p.Ub.getVertexBuffers();if(mp)for(const h in mp){if(!r(h))continue;const y=mp[h];Q.setHasVertexColorAlpha(y,p.hasVertexAlpha);const P=y._buffer,w=b.get(P)||[];b.set(P,w),-1===w.indexOf(y)&&w.push(y);const t=M.get(y)||[];M.set(y,t),-1===t.indexOf(p)&&t.push(p)}const y=p.morphTargetManager;if(y)for(let b=0;b<y.numTargets;b++){const M=y.getTarget(b),Q=h.get(M)||[];h.set(M,Q),-1===Q.indexOf(p)&&Q.push(p)}}for(const mp of p.getChildren())this._collectBuffers(mp,b,M,h,Q)}_exportBuffers(p,b){const M=new Map,h=new Map,Q=new Map;for(const P of p)this._collectBuffers(P,M,h,Q,b);const mp=Array.from(M.keys());for(const P of mp){const p=P.getData();if(!p)throw new Error("Buffer data is not available");const Q=M.get(P);if(!Q)continue;const mp=Q[0].byteStride;if(Q.some((p=>p.byteStride!==mp)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const y=Mp(p).slice();for(const b of Q){const p=h.get(b),{byteOffset:M,byteStride:Q,componentCount:mp,type:P,count:w,normalized:t,kind:x}=R(b,p);switch(x){case z.f.NormalKind:case z.f.TangentKind:(0,W.h)(y,M,Q,mp,P,w,t,(p=>{const b=Math.sqrt(p[0]*p[0]+p[1]*p[1]+p[2]*p[2]);if(b>0){const M=1/b;p[0]*=M,p[1]*=M,p[2]*=M}}));break;case z.f.ColorKind:{const b=p.filter((p=>p.material instanceof Jp.PM||null==p.material)).length;if(0==b)break;if(b!=p.length){H.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}P==z.f.UNSIGNED_BYTE&&H.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const h=new g.wM,x=new g.Hb,S=this._babylonScene.getEngine().useExactSrgbConversions;(0,W.h)(y,M,Q,mp,P,w,t,(p=>{3===p.length?(h.Jh(p,0),h.toLinearSpaceToRef(h,S),h.toArray(p,0)):(x.Jh(p,0),x.toLinearSpaceToRef(x,S),x.toArray(p,0))}))}}}if(b.convertToRightHanded){for(const p of Q){const b=h.get(p),{byteOffset:M,byteStride:Q,componentCount:mp,type:P,count:w,normalized:t,kind:x}=R(p,b);switch(x){case z.f.PositionKind:case z.f.NormalKind:case z.f.TangentKind:(0,W.h)(y,M,Q,mp,P,w,t,(p=>{p[0]=-p[0]}))}}b.convertedToRightHandedBuffers.set(P,y)}const w=this._bufferManager.createBufferView(y,mp);b.setVertexBufferView(P,w);const t=new Map;for(const b of Q){const p=h.get(b),{kind:M,totalVertices:Q}=R(b,p);switch(M){case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:if(b.type==z.f.FLOAT){const p=b.getFloatData(Q);null!==p&&t.set(b,p)}}}0!==t.size&&H.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const x=Array.from(t.keys());for(const M of x){const p=t.get(M);if(!p)continue;const h=p.some((p=>p>=256)),Q=new(h?Uint16Array:Uint8Array)(p.length);for(let b=0;b<p.length;b++)Q[b]=p[b];const mp=this._bufferManager.createBufferView(Q,4*(h?2:1));b.setRemappedBufferView(P,M,mp)}}const y=Array.from(Q.keys());for(const P of y){const p=Q.get(P);if(!p)continue;const M=lp(P,p[0],this._bufferManager,this._bufferViews,this._accessors,b.convertToRightHanded);for(const h of p)b.bindMorphDataToMesh(h,M)}}async _exportNodeAsync(p,b,M){let h=this._nodeMap.get(p);if(void 0!==h)return void(b.includes(h)||b.push(h));const Q=await this._createNodeAsync(p,M);if(Q){h=this._nodes.length,this._nodes.push(Q),this._nodeMap.set(p,h),M.pushExportedNode(p),b.push(h);const mp={name:"runtime animations",channels:[],samplers:[]},y=[];this._babylonScene.animationGroups.length||(op._CreateMorphTargetAnimationFromMorphTargetAnimations(p,mp,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,M.convertToRightHanded,this._options.shouldExportAnimation),p.animations.length&&op._CreateNodeAnimationFromNodeAnimations(p,mp,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,M.convertToRightHanded,this._options.shouldExportAnimation)),mp.channels.length&&mp.samplers.length&&this._animations.push(mp),y.forEach((p=>{p.channels.length&&p.samplers.length&&this._animations.push(p)}))}const mp=Q?[]:b;for(const y of p.getChildren())await this._exportNodeAsync(y,mp,M);Q&&mp.length&&(Q.children=mp)}async _createNodeAsync(p,b){if(!this._shouldExportNode(p))return null;const M={};if(p.name&&(M.name=p.name),p.metadata){const b=this._options.metadataSelector(p.metadata);b&&(M.extras=b)}if(p instanceof x.c&&(this._setNodeTransformation(M,p,b.convertToRightHanded),p instanceof S.c)){const Q=p instanceof X.b?p.sourceMesh:p;if(Q.Lb&&Q.Lb.length>0&&(M.mesh=await this._exportMeshAsync(Q,b)),p.skeleton){const b=this._skinMap.get(p.skeleton);var h;if(void 0!==b)void 0===this._nodesSkinMap.get(b)&&this._nodesSkinMap.set(b,[]),null===(h=this._nodesSkinMap.get(b))||void 0===h||h.push(M)}}if(p instanceof E.e){const h=this._camerasMap.get(p);if(h){var Q;void 0===this._nodesCameraMap.get(h)&&this._nodesCameraMap.set(h,[]),this._setCameraTransformation(M,p,b.convertToRightHanded);const y=p.parent;if(null!==y&&bp(p,y)){const p=this._nodeMap.get(y);if(void 0!==p){var mp;const b=this._nodes[p];return pp(M,b),null===(mp=this._nodesCameraMap.get(h))||void 0===mp||mp.push(b),null}}null===(Q=this._nodesCameraMap.get(h))||void 0===Q||Q.push(M)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",M,p,this._nodeMap,b.convertToRightHanded)?M:(H.d.Warn(`Not exporting node ${p.name}`),null)}_exportIndices(p,b,M,h,Q,y,P,w,t){let z=p;t.mode=k(y);const x=P!==mp.b.CounterClockWiseSideOrientation,S=!w.wasAddedByNoopNode&&x,X=function(p){switch(p){case mp.b.TriangleFillMode:case mp.b.TriangleStripDrawMode:case mp.b.TriangleFanDrawMode:return!0}return!1}(y)&&S;if(X){if(y===mp.b.TriangleStripDrawMode||y===mp.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");t.mode=k(y);const P=b?new Uint32Array(h):new Uint16Array(h);if(p)for(let b=0;b+2<h;b+=3)P[b]=p[M+b]+Q,P[b+1]=p[M+b+2]+Q,P[b+2]=p[M+b+1]+Q;else for(let p=0;p+2<h;p+=3)P[p]=p,P[p+1]=p+2,P[p+2]=p+1;z=P}else if(p&&0!==Q){const mp=b?new Uint32Array(h):new Uint16Array(h);for(let b=0;b<h;b++)mp[b]=p[M+b]+Q;z=mp}if(z){let mp=w.getIndicesAccessor(p,M,h,Q,X);if(void 0===mp){const y=function(p,b,M,h){if(p instanceof Uint16Array||p instanceof Uint32Array)return p;if(p instanceof Int32Array)return new Uint32Array(p.buffer,p.byteOffset,p.length);const Q=p.slice(b,b+M);return h?new Uint32Array(Q):new Uint16Array(Q)}(z,0,h,b),P=this._bufferManager.createBufferView(y),t=b?5125:5123;this._accessors.push(this._bufferManager.createAccessor(P,"SCALAR",t,h,0)),mp=this._accessors.length-1,w.setIndicesAccessor(p,M,h,Q,X,mp)}t.indices=mp}}_exportVertexBuffer(p,b,M,h,Q,mp){const y=p.getKind();if(!r(y))return;if(y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!b||!this._materialNeedsUVsSet.has(b)))return;let P=Q.getVertexAccessor(p,M,h);if(void 0===P){const b=Q.convertedToRightHandedBuffers.get(p._buffer)||p._buffer.getData(),mp=y===z.f.PositionKind?function(p,b,M,h){const{byteOffset:Q,byteStride:mp,type:y,normalized:P}=b,w=b.getSize(),t=new Array(w).fill(1/0),z=new Array(w).fill(-1/0);return(0,W.h)(p,Q+M*mp,mp,w,y,h*w,P,(p=>{for(let b=0;b<w;b++)t[b]=Math.min(t[b],p[b]),z[b]=Math.max(z[b],p[b])})),{min:t,max:z}}(b,p,M,h):void 0,w=(y===z.f.MatricesIndicesKind||y===z.f.MatricesIndicesExtraKind)&&p.type===z.f.FLOAT,t=w?z.f.UNSIGNED_BYTE:p.type,x=w?void 0:p.normalized,S=w?Q.getRemappedBufferView(p._buffer,p):Q.getVertexBufferView(p._buffer),X=p.byteOffset+M*p.byteStride;this._accessors.push(this._bufferManager.createAccessor(S,function(p,b){if(p==z.f.ColorKind)return b?"VEC4":"VEC3";switch(p){case z.f.PositionKind:case z.f.NormalKind:return"VEC3";case z.f.TangentKind:case z.f.MatricesIndicesKind:case z.f.MatricesIndicesExtraKind:case z.f.MatricesWeightsKind:case z.f.MatricesWeightsExtraKind:return"VEC4";case z.f.UVKind:case z.f.UV2Kind:case z.f.UV3Kind:case z.f.UV4Kind:case z.f.UV5Kind:case z.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${p}`)}(y,Q.hasVertexColorAlpha(p)),t,h,X,mp,x)),P=this._accessors.length-1,Q.setVertexAccessor(p,M,h,P)}mp.attributes[function(p){switch(p){case z.f.PositionKind:return"POSITION";case z.f.NormalKind:return"NORMAL";case z.f.TangentKind:return"TANGENT";case z.f.ColorKind:return"COLOR_0";case z.f.UVKind:return"TEXCOORD_0";case z.f.UV2Kind:return"TEXCOORD_1";case z.f.UV3Kind:return"TEXCOORD_2";case z.f.UV4Kind:return"TEXCOORD_3";case z.f.UV5Kind:return"TEXCOORD_4";case z.f.UV6Kind:return"TEXCOORD_5";case z.f.MatricesIndicesKind:return"JOINTS_0";case z.f.MatricesIndicesExtraKind:return"JOINTS_1";case z.f.MatricesWeightsKind:return"WEIGHTS_0";case z.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${p}`)}(y)]=P}async _exportMaterialAsync(p,b,M,h){let Q=this._materialMap.get(p);if(void 0===Q){const h=b&&Object.keys(b).some((p=>p.startsWith("uv")));if((p=p instanceof Xp.c?p.Eb[M.materialIndex]:p)instanceof cp.c)Q=await this._materialExporter.exportPBRMaterialAsync(p,"image/png",h);else{if(!(p instanceof Jp.PM))return void H.d.Warn(`Unsupported material '${p.name}' with type ${p.getClassName()}`);Q=await this._materialExporter.exportStandardMaterialAsync(p,"image/png",h)}this._materialMap.set(p,Q)}h.material=Q}async _exportMeshAsync(p,b){var M;let h=b.getMesh(p);if(void 0!==h)return h;const Q={primitives:[]};h=this._meshes.length,this._meshes.push(Q),b.setMesh(p,h);const y=p.isUnIndexed?null:p.qb(),P=null===(M=p.Ub)||void 0===M?void 0:M.getVertexBuffers(),w=b.getMorphTargetsFromMesh(p),t=p instanceof Lp.e,z=p instanceof Vp,x=p.Lb;if(P&&x&&x.length>0)for(const c of x){const M={attributes:{}},h=c.Tp()||this._babylonScene.defaultMaterial;if(z){var S,X;const b={name:h.name},Q=p,mp=g.wM.White(),y=(null===(S=Q.material)||void 0===S?void 0:S.alpha)??1,P=(null===(X=Q.greasedLineMaterial)||void 0===X?void 0:X.color)??mp;(!P.equalsWithEpsilon(mp,j.d)||y<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...P.ub(),y]}),this._materials.push(b),M.material=this._materials.length-1}else if(t){const b={name:h.name},Q=p;(!Q.color.equalsWithEpsilon(g.wM.White(),j.d)||Q.alpha<1)&&(b.pbrMetallicRoughness={baseColorFactor:[...Q.color.ub(),Q.alpha]}),this._materials.push(b),M.material=this._materials.length-1}else await this._exportMaterialAsync(h,P,c,M);const x=t||z?mp.b.LineListDrawMode:p.overrideRenderingFillMode??h.fillMode,J=h._getEffectiveOrientation(p);this._exportIndices(y,y?(0,W.b)(y,c.indexCount,c.indexStart,c.verticesStart):c.verticesCount>65535,y?c.indexStart:c.verticesStart,y?c.indexCount:c.verticesCount,-c.verticesStart,x,J,b,M);for(const p of Object.values(P))this._exportVertexBuffer(p,h,c.verticesStart,c.verticesCount,b,M);if(w){M.targets=[];for(const p of w)M.targets.push(p.attributes)}Q.primitives.push(M),this._extensionsPostExportMeshPrimitive(M)}if(w){Q.weights=[],Q.extras||(Q.extras={}),Q.extras.targetNames=[];for(const p of w)Q.weights.push(p.influence),Q.extras.targetNames.push(p.name)}return h}}Np._ExtensionNames=new Array,Np._ExtensionFactories={};class Op{static async GLTFAsync(p,b,M){M&&M.exportWithoutWaitingForScene||await p.whenReadyAsync();const h=new Np(p,M),Q=await h.generateGLTFAsync(b.replace(/\.[^/.]+$/,""));return h.dispose(),Q}static async GLBAsync(p,b,M){M&&M.exportWithoutWaitingForScene||await p.whenReadyAsync();const h=new Np(p,M),Q=await h.generateGLBAsync(b.replace(/\.[^/.]+$/,""));return h.dispose(),Q}}M(13339);const Rp="EXT_mesh_gpu_instancing";class Kp{constructor(p){this.name=Rp,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(p,b,M,Q,mp,y){return await new Promise((p=>{if(b&&M instanceof Yp.e&&M.hasThinInstances&&this._exporter){this._wasUsed=!0;const p=h.QM.Zero(),Q=h.Quaternion.Identity(),P=h.QM.One(),w=M.thinInstanceGetWorldMatrices(),t=h.TmpVectors.QM[2],z=h.TmpVectors.Quaternion[1],x=h.TmpVectors.QM[3];let S=!1,X=!1,c=!1;const J=new Float32Array(3*M.jb),g=new Float32Array(4*M.jb),f=new Float32Array(3*M.jb);let Y=0;for(const b of w)b.decompose(x,z,t),mp&&(n(t),C(z)),J.set(t.ub(),3*Y),g.set(z.normalize().ub(),4*Y),f.set(x.ub(),3*Y),S=S||!t.equalsWithEpsilon(p),X=X||!z.equalsWithEpsilon(Q),c=c||!x.equalsWithEpsilon(P),Y++;const a={attributes:{}};S&&(a.attributes.TRANSLATION=this._buildAccessor(J,"VEC3",M.jb,y)),X&&(a.attributes.ROTATION=this._buildAccessor(g,"VEC4",M.jb,y)),c&&(a.attributes.SCALE=this._buildAccessor(f,"VEC3",M.jb,y)),b.extensions=b.extensions||{},b.extensions[Rp]=a}p(b)}))}_buildAccessor(p,b,M,h){const Q=h.createBufferView(p),mp=h.createAccessor(Q,b,5126,M);return this._exporter._accessors.push(mp),this._exporter._accessors.length-1}}Np.RegisterExtension(Rp,(p=>new Kp(p)));var rp=M(13344),kp=M(13360),Ap=M(13363),np=M(13369);function Cp(p){return p===Ap.e.PositionKind?"POSITION":p===Ap.e.NormalKind?"NORMAL":p===Ap.e.ColorKind?"COLOR":p.startsWith(Ap.e.UVKind)?"TEX_COORD":"GENERIC"}const Fp={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class pb extends rp.e{static get DefaultAvailable(){return(0,rp.j)(pb.DefaultConfiguration)}static get Default(){return pb._Default??(pb._Default=new pb),pb._Default}static ResetDefault(p){pb._Default&&(p||pb._Default.dispose(),pb._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(p,b){return{module:await(b||DracoEncoderModule)({wasmBinary:p})}}_getWorkerContent(){return`${kp.k}(${kp.n})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:pb.DefaultConfiguration)}async _encodeAsync(p,b,M){const h=M?(0,np.e)(Fp,M):Fp;if(this._workerPoolPromise){const M=await this._workerPoolPromise;return await new Promise(((Q,mp)=>{M.push(((M,y)=>{const P=p=>{M.removeEventListener("error",P),M.removeEventListener("message",w),mp(p),y()},w=p=>{"encodeMeshDone"===p.data.id&&(M.removeEventListener("error",P),M.removeEventListener("message",w),Q(p.data.encodedMeshData),y())};M.addEventListener("error",P),M.addEventListener("message",w);const t=[];for(const b of p)t.push(b.data.buffer);b&&t.push(b.buffer),M.postMessage({id:"encodeMesh",attributes:p,indices:b,options:h},t)}))}))}if(this._modulePromise){const M=await this._modulePromise;return(0,kp.k)(M.module,p,b,h)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(p,b){if(0==p.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");p instanceof Yp.e&&p.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===b||void 0===b?void 0:b.method)&&(H.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),b.method="MESH_SEQUENTIAL_ENCODING");const M=function(p){let b=p.qb(void 0,!0);return!b||b instanceof Uint32Array||b instanceof Uint16Array||(b=((0,W.b)(b,b.length)?Uint32Array:Uint16Array).from(b)),b}(p),h=function(p,b){const M=[];for(const h of p.getVerticesDataKinds()){if(null!==b&&void 0!==b&&b.includes(h)){if(h===Ap.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const Q=p.getVertexBuffer(h),mp=Q.getSize(),y=(0,W.o)(Q.getData(),mp,Q.type,Q.byteOffset,Q.byteStride,Q.normalized,p.getTotalVertices(),!0);M.push({kind:h,dracoName:Cp(h),size:mp,data:y})}return M}(p,null===b||void 0===b?void 0:b.excludedAttributes);return await this._encodeAsync(h,M,b)}}pb.DefaultConfiguration={wasmUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${Q.Tools._DefaultCdnUrl}/draco_encoder.js`},pb._Default=null;const bb="KHR_draco_mesh_compression";class Mb{get wasUsed(){return this._wasUsed}constructor(p){this.name=bb,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===p.options.meshCompressionMethod&&pb.DefaultAvailable}dispose(){}postExportMeshPrimitive(p,b,M){if(!this.enabled)return;if(4!==p.mode&&5!==p.mode)return void H.d.Warn("Cannot compress primitive with mode "+p.mode+".");const h=[],Q=[];let mp=null;if(void 0!==p.indices){const y=M[p.indices],P=b.getBufferView(y);mp=b.getData(P).slice(),h.push(P),Q.push(y)}const y=[];for(const[z,x]of Object.entries(p.attributes)){const p=M[x],mp=b.getBufferView(p),w=K(p.type),t=(0,W.o)(b.getData(mp),w,p.componentType,p.byteOffset||0,mp.byteStride||(0,W.l)(p.componentType)*w,p.normalized||!1,p.count,!0);y.push({kind:z,dracoName:(P=z,"POSITION"===P?"POSITION":"NORMAL"===P?"NORMAL":P.startsWith("COLOR")?"COLOR":P.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:K(p.type),data:t}),h.push(mp),Q.push(p)}var P;const w={method:p.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},t=pb.Default._encodeAsync(y,mp,w).then((M=>{if(!M)return void H.d.Error("Draco encoding failed for primitive.");const mp={bufferView:-1,attributes:M.attributeIds},y=b.createBufferView(M.data);b.setBufferView(mp,y);for(const p of h)this._bufferViewsUsed.add(p);for(const p of Q)this._accessorsUsed.add(p);p.extensions||(p.extensions={}),p.extensions[bb]=mp})).catch((p=>{H.d.Error("Draco encoding failed for primitive: "+p)}));this._encodePromises.push(t),this._wasUsed=!0}async preGenerateBinaryAsync(p){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((b=>{p.getPropertiesWithBufferView(b).every((p=>this._accessorsUsed.has(p)))&&p.removeBufferView(b)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Np.RegisterExtension(bb,(p=>new Mb(p)));var hb=M(13376);const Qb="KHR_lights_punctual",mM={name:"",color:[1,1,1],Vb:1,range:Number.MAX_VALUE},yb={innerConeAngle:0,outerConeAngle:Math.PI/4},Pb=h.QM.Backward();class wb{constructor(p){this.name=Qb,this.enabled=!0,this.required=!1,this._exporter=p}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Qb]=this._lights}async postExportNodeAsync(p,b,M,Q,mp){return await new Promise((y=>{if(!(M instanceof ap.c))return void y(b);const P=M.getTypeID()==ap.c.LIGHTTYPEID_POINTLIGHT?"point":M.getTypeID()==ap.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":M.getTypeID()==ap.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!P||!(M instanceof hb.e))return H.d.Warn(`${p}: Light ${M.name} is not supported in ${Qb}`),void y(b);if(M.falloffType!==ap.c.FALLOFF_GLTF&&H.d.Warn(`${p}: Light falloff for ${M.name} does not match the ${Qb} specification!`),!M.position.equalsToFloats(0,0,0)){const p=h.TmpVectors.QM[0].mp(M.position);mp&&n(p),b.translation=p.ub()}if("point"!==P){const p=M.direction.normalizeToRef(h.TmpVectors.QM[0]);mp&&n(p);const Q=h.Quaternion.FromUnitVectorsToRef(Pb,p,h.TmpVectors.Quaternion[0]);h.Quaternion.IsIdentity(Q)||(b.rotation=Q.ub())}const w={type:P,name:M.name,color:M.Db.ub(),Vb:M.Vb,range:M.range};if(hp(w,mM),"spot"===P){const p=M;w.spot={innerConeAngle:p.innerAngle/2,outerConeAngle:p.angle/2},hp(w.spot,yb)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(w);const t={tb:this._lights.lights.length-1},z=M.parent;if(z&&bp(M,z)){const p=Q.get(z);if(p){const M=this._exporter._nodes[p];return pp(b,M),M.extensions||(M.extensions={}),M.extensions[Qb]=t,void y(null)}}b.extensions||(b.extensions={}),b.extensions[Qb]=t,y(b)}))}}Np.RegisterExtension(Qb,(p=>new wb(p)));var tb=M(13291);const zb="KHR_materials_anisotropy";class xb{constructor(p){this.name=zb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof tb.d&&M.anisotropy.isEnabled&&!M.anisotropy.legacy?(M.anisotropy.texture&&h.push(M.anisotropy.texture),h):[]}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof tb.d){if(!M.anisotropy.isEnabled||M.anisotropy.legacy)return void p(b);this._wasUsed=!0,b.extensions=b.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(M.anisotropy.texture),Q={anisotropyStrength:M.anisotropy.Vb,anisotropyRotation:M.anisotropy.angle,anisotropyTexture:h??void 0};null!==Q.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(M),b.extensions[zb]=Q}p(b)}))}}Np.RegisterExtension(zb,(p=>new xb(p)));const Sb="KHR_materials_clearcoat";class Xb{constructor(p){this.name=Sb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof tb.d&&M.clearCoat.isEnabled?(M.clearCoat.texture&&h.push(M.clearCoat.texture),!M.clearCoat.useRoughnessFromMainTexture&&M.clearCoat.textureRoughness&&h.push(M.clearCoat.textureRoughness),M.clearCoat.bumpTexture&&h.push(M.clearCoat.bumpTexture),h):[]}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof tb.d){if(!M.clearCoat.isEnabled)return void p(b);this._wasUsed=!0,b.extensions=b.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(M.clearCoat.texture);let mp;mp=M.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(M.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(M.clearCoat.textureRoughness),M.clearCoat.isTintEnabled&&Q.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${M.name}`),M.clearCoat.remapF0OnInterfaceChange&&Q.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${M.name}`);const y=this._exporter._materialExporter.getTextureInfo(M.clearCoat.bumpTexture),P={clearcoatFactor:M.clearCoat.Vb,clearcoatTexture:h??void 0,clearcoatRoughnessFactor:M.clearCoat.roughness,clearcoatRoughnessTexture:mp??void 0,clearcoatNormalTexture:y??void 0};null===P.clearcoatTexture&&null===P.clearcoatRoughnessTexture&&null===P.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(M),b.extensions[Sb]=P}p(b)}))}}Np.RegisterExtension(Sb,(p=>new Xb(p)));const cb="KHR_materials_diffuse_transmission";function Jb(p,b){const M=b.subSurface;let h=null;return M.translucencyIntensityTexture?h=M.translucencyIntensityTexture:M.thicknessTexture&&M.useMaskFromThicknessTexture&&(h=M.thicknessTexture),h&&!M.useGltfStyleTextures?(H.d.Warn(`${p}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${b.name}`,1),null):h}class gb{constructor(p){this.name=cb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];if(M instanceof cp.c&&this._isExtensionEnabled(M)){const b=Jb(p,M);return b&&h.push(b),M.subSurface.translucencyColorTexture&&h.push(M.subSurface.translucencyColorTexture),h}return h}_isExtensionEnabled(p){if(p.unlit)return!1;const b=p.subSurface;return!!b.isTranslucencyEnabled&&(!p.unlit&&!b.useAlbedoToTintTranslucency&&b.useGltfStyleTextures&&1===b.volumeIndexOfRefraction&&0===b.minimumThickness&&0===b.maximumThickness)}postExportMaterialAsync(p,b,M){return new Promise((h=>{if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0;const h=M.subSurface,Q=Jb(p,M),mp=0==h.translucencyIntensity?void 0:h.translucencyIntensity,y=this._exporter._materialExporter.getTextureInfo(Q)??void 0,P=!h.translucencyColor||h.translucencyColor.equalsFloats(1,1,1)?void 0:h.translucencyColor.ub(),w=this._exporter._materialExporter.getTextureInfo(h.translucencyColorTexture)??void 0,t={diffuseTransmissionFactor:mp,diffuseTransmissionTexture:y,diffuseTransmissionColorFactor:P,diffuseTransmissionColorTexture:w};(y||w)&&this._exporter._materialNeedsUVsSet.add(M),b.extensions=b.extensions||{},b.extensions[cb]=t}h(b)}))}}Np.RegisterExtension(cb,(p=>new gb(p)));const fb="KHR_materials_dispersion";class Yb{constructor(){this.name=fb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(p){if(p.unlit)return!1;const b=p.subSurface;return!(!b.isRefractionEnabled&&!b.isDispersionEnabled)}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0;const p={dispersion:M.subSurface.dispersion};b.extensions=b.extensions||{},b.extensions[fb]=p}p(b)}))}}Np.RegisterExtension(fb,(()=>new Yb));const ab="KHR_materials_emissive_strength";class ob{constructor(){this.name=ab,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(p,b,M){return await new Promise((p=>{if(!(M instanceof cp.c))return p(b);const h=M.emissiveColor.ub(),Q=Math.max(...h);if(Q>1){this._wasUsed=!0,b.extensions||(b.extensions={});const p={emissiveStrength:Q},h=M.emissiveColor.scale(1/p.emissiveStrength);b.emissiveFactor=h.ub(),b.extensions[ab]=p}return p(b)}))}}Np.RegisterExtension(ab,(p=>new ob));const lb="KHR_materials_ior";class Lb{constructor(){this.name=lb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(p){return!p.unlit&&(void 0!=p.indexOfRefraction&&1.5!=p.indexOfRefraction)}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0;const p={ior:M.indexOfRefraction};b.extensions=b.extensions||{},b.extensions[lb]=p}p(b)}))}}Np.RegisterExtension(lb,(p=>new Lb));const ub="KHR_materials_iridescence";class eb{constructor(p){this.name=ub,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof tb.d&&M.iridescence.isEnabled?(M.iridescence.texture&&h.push(M.iridescence.texture),M.iridescence.thicknessTexture&&M.iridescence.thicknessTexture!==M.iridescence.texture&&h.push(M.iridescence.thicknessTexture),h):[]}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof tb.d){if(!M.iridescence.isEnabled)return void p(b);this._wasUsed=!0,b.extensions=b.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(M.iridescence.texture),Q=this._exporter._materialExporter.getTextureInfo(M.iridescence.thicknessTexture),mp={iridescenceFactor:M.iridescence.Vb,iridescenceIor:M.iridescence.indexOfRefraction,iridescenceThicknessMinimum:M.iridescence.minimumThickness,iridescenceThicknessMaximum:M.iridescence.maximumThickness,iridescenceTexture:h??void 0,iridescenceThicknessTexture:Q??void 0};null===mp.iridescenceTexture&&null===mp.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(M),b.extensions[ub]=mp}p(b)}))}}Np.RegisterExtension(ub,(p=>new eb(p)));const db="KHR_materials_sheen";class Ib{constructor(p){this.name=db,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){return M instanceof cp.c&&M.sheen.isEnabled&&M.sheen.texture?[M.sheen.texture]:[]}async postExportMaterialAsync(p,b,M){return await new Promise((p=>{if(M instanceof cp.c){if(!M.sheen.isEnabled)return void p(b);this._wasUsed=!0,null==b.extensions&&(b.extensions={});const h={sheenColorFactor:M.sheen.color.ub(),sheenRoughnessFactor:M.sheen.roughness??0};null===h.sheenColorTexture&&null===h.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(M),M.sheen.texture&&(h.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.texture)??void 0),M.sheen.textureRoughness&&!M.sheen.useRoughnessFromMainTexture?h.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.textureRoughness)??void 0:M.sheen.texture&&M.sheen.useRoughnessFromMainTexture&&(h.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(M.sheen.texture)??void 0),b.extensions[db]=h}p(b)}))}}Np.RegisterExtension(db,(p=>new Ib(p)));const Gb="KHR_materials_specular";class vb{constructor(p){this.name=Gb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof cp.c&&this._isExtensionEnabled(M)?(M.metallicReflectanceTexture&&h.push(M.metallicReflectanceTexture),M.reflectanceTexture&&h.push(M.reflectanceTexture),h):h}_isExtensionEnabled(p){return!p.unlit&&(void 0!=p.metallicF0Factor&&1!=p.metallicF0Factor||void 0!=p.metallicReflectanceColor&&!p.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(p))}_hasTexturesExtension(p){return null!=p.metallicReflectanceTexture||null!=p.reflectanceTexture}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0,b.extensions=b.extensions||{};const p=this._exporter._materialExporter.getTextureInfo(M.metallicReflectanceTexture)??void 0,h=this._exporter._materialExporter.getTextureInfo(M.reflectanceTexture)??void 0,Q={specularFactor:1==M.metallicF0Factor?void 0:M.metallicF0Factor,specularTexture:p,specularColorFactor:M.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:M.metallicReflectanceColor.ub(),specularColorTexture:h};this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),b.extensions[Gb]=Q}p(b)}))}}Np.RegisterExtension(Gb,(p=>new vb(p)));const Zb="KHR_materials_transmission";class Ub{constructor(p){this.name=Zb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof cp.c&&this._isExtensionEnabled(M)?(M.subSurface.thicknessTexture&&h.push(M.subSurface.thicknessTexture),h):h}_isExtensionEnabled(p){if(p.unlit)return!1;const b=p.subSurface;return b.isRefractionEnabled&&void 0!=b.refractionIntensity&&0!=b.refractionIntensity||this._hasTexturesExtension(p)}_hasTexturesExtension(p){return null!=p.subSurface.refractionIntensityTexture}async postExportMaterialAsync(p,b,M){if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0;const h=M.subSurface,Q={transmissionFactor:0===h.refractionIntensity?void 0:h.refractionIntensity};if(this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),h.refractionIntensityTexture)if(h.useGltfStyleTextures){const p=await this._exporter._materialExporter.exportTextureAsync(h.refractionIntensityTexture,"image/png");p&&(Q.transmissionTexture=p)}else H.d.Warn(`${p}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);b.extensions||(b.extensions={}),b.extensions[Zb]=Q}return b}}Np.RegisterExtension(Zb,(p=>new Ub(p)));const qb="KHR_materials_unlit";class Bb{constructor(){this.name=qb,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(p,b,M){return new Promise((p=>{let h=!1;M instanceof cp.c?h=M.unlit:M instanceof Jp.PM&&(h=M.disableLighting),h&&(this._wasUsed=!0,null==b.extensions&&(b.extensions={}),b.extensions[qb]={}),p(b)}))}}Np.RegisterExtension(qb,(()=>new Bb));const sb="KHR_materials_volume";class ib{constructor(p){this.name=sb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof cp.c&&this._isExtensionEnabled(M)?(M.subSurface.thicknessTexture&&h.push(M.subSurface.thicknessTexture),h):h}_isExtensionEnabled(p){if(p.unlit)return!1;const b=p.subSurface;return!(!b.isRefractionEnabled&&!b.isTranslucencyEnabled)&&(void 0!=b.maximumThickness&&0!=b.maximumThickness||void 0!=b.tintColorAtDistance&&b.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=b.tintColor&&b.tintColor!=g.wM.White()||this._hasTexturesExtension(p))}_hasTexturesExtension(p){return null!=p.subSurface.thicknessTexture}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof cp.c&&this._isExtensionEnabled(M)){this._wasUsed=!0;const p=M.subSurface,h={thicknessFactor:0==p.maximumThickness?void 0:p.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(p.thicknessTexture)??void 0,attenuationDistance:p.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:p.tintColorAtDistance,attenuationColor:p.tintColor.equalsFloats(1,1,1)?void 0:p.tintColor.ub()};this._hasTexturesExtension(M)&&this._exporter._materialNeedsUVsSet.add(M),b.extensions=b.extensions||{},b.extensions[sb]=h}p(b)}))}}Np.RegisterExtension(sb,(p=>new ib(p)));const Tb="EXT_materials_diffuse_roughness";class Wb{constructor(p){this.name=Tb,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=p}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(p,b,M){const h=[];return M instanceof tb.d&&M._baseDiffuseRoughness?(M._baseDiffuseRoughnessTexture&&h.push(M._baseDiffuseRoughnessTexture),h):[]}postExportMaterialAsync(p,b,M){return new Promise((p=>{if(M instanceof tb.d){if(!M._baseDiffuseRoughness)return void p(b);this._wasUsed=!0,b.extensions=b.extensions||{};const h=this._exporter._materialExporter.getTextureInfo(M._baseDiffuseRoughnessTexture),Q={diffuseRoughnessFactor:M._baseDiffuseRoughness,diffuseRoughnessTexture:h??void 0};null!==Q.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(M),b.extensions[Tb]=Q}p(b)}))}}Np.RegisterExtension(Tb,(p=>new Wb(p)));const Hb="KHR_texture_transform";class Eb{constructor(){this.name=Hb,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(p,b,M){if(M.upp()||Q.Tools.Warn(`${p}: /*@__KEY__*/"scene" is not defined for Babylon texture ${M.name}!`),(0!==M.uAng||0!==M.vAng)&&(Q.Tools.Warn(`${p}: Texture ${M.name} with rotation in the u or v axis is not supported in glTF.`),0!==M.uRotationCenter||0!==M.vRotationCenter))return;const h={};let mp=!1;if(0===M.uOffset&&0===M.vOffset||(h.offset=[M.uOffset,M.vOffset],mp=!0),1===M.uScale&&1===M.vScale||(h.scale=[M.uScale,M.vScale],mp=!0),0!==M.wAng){if(0!==M.uRotationCenter||0!==M.vRotationCenter){if(M.homogeneousRotationInUVTransform&&M.uScale!==M.vScale)return void Q.Tools.Warn(`${p}: Texture ${M.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Hb}.`);Q.Tools.Warn(`${p}: Texture ${M.name} with non-origin rotation center will be exported using an adjusted offset with ${Hb}.`),h.offset=function(p){const{uOffset:b,vOffset:M,uRotationCenter:h,vRotationCenter:Q,uScale:mp,vScale:y,wAng:P}=p,w=Math.cos(P),t=Math.sin(P),z=h*mp,x=Q*y;return[b+(z*(1-w)+x*t),M+(x*(1-w)-z*t)]}(M)}h.rotation=-M.wAng,mp=!0}0!==M.coordinatesIndex&&(h.texCoord=M.coordinatesIndex,mp=!0),mp&&(this._wasUsed=!0,b.extensions||(b.extensions={}),b.extensions[Hb]=h)}}Np.RegisterExtension(Hb,(()=>new Eb));class jb{static CreateSTL(p){let b=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",Q=arguments.length>3&&void 0!==arguments[3]&&arguments[3],mp=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],P=arguments.length>6&&void 0!==arguments[6]&&arguments[6],w=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const t=function(p,b,M){const Q=[3*p[M],3*p[M+1],3*p[M+2]],mp=[new h.QM(b[Q[0]],b[Q[0]+2],b[Q[0]+1]),new h.QM(b[Q[1]],b[Q[1]+2],b[Q[1]+1]),new h.QM(b[Q[2]],b[Q[2]+2],b[Q[2]+1])],y=mp[0].mh(mp[1]),P=mp[2].mh(mp[1]);return{v:mp,n:h.QM.Cross(P,y).normalize()}},x=function(p,b,M,h){return b=S(p,b,M.x,h),b=S(p,b,M.y,h),S(p,b,M.z,h)},S=function(p,b,M,h){return p.setFloat32(b,M,h),b+4},c=function(p){if(P){let b=p;p instanceof X.b&&(b=p.sourceMesh);const M=b.getVerticesData(z.f.PositionKind,!0,!0);if(!M)return[];const Q=h.QM.Zero();let mp;for(mp=0;mp<M.length;mp+=3)h.QM.TransformCoordinatesFromFloatsToRef(M[mp],M[mp+1],M[mp+2],p.Zb(!0),Q).toArray(M,mp);return M}return p.getVerticesData(z.f.PositionKind)||[]};P&&(y=!0);let J="",g=0,f=0;if(Q){for(let M=0;M<p.length;M++){const b=p[M].qb();g+=b?b.length/3:0}const b=new ArrayBuffer(84+50*g);J=new DataView(b),f+=80,J.setUint32(f,g,mp),f+=4}else w||(J="solid stlmesh\r\n");for(let h=0;h<p.length;h++){const b=p[h];!Q&&w&&(J+="solid "+b.name+"\r\n"),!y&&b instanceof Yp.e&&b.bakeCurrentTransformIntoVertices();const M=c(b),P=b.qb()||[];for(let p=0;p<P.length;p+=3){const b=t(P,M,p);Q?(f=x(J,f,b.n,mp),f=x(J,f,b.v[0],mp),f=x(J,f,b.v[1],mp),f=x(J,f,b.v[2],mp),f+=2):(J+="\tfacet normal "+b.n.x+" "+b.n.y+" "+b.n.z+"\r\n",J+="\t\touter loop\r\n",J+="\t\t\tvertex "+b.v[0].x+" "+b.v[0].y+" "+b.v[0].z+"\r\n",J+="\t\t\tvertex "+b.v[1].x+" "+b.v[1].y+" "+b.v[1].z+"\r\n",J+="\t\t\tvertex "+b.v[2].x+" "+b.v[2].y+" "+b.v[2].z+"\r\n",J+="\t\tendloop\r\n",J+="\tendfacet\r\n")}!Q&&w&&(J+="endsolid "+name+"\r\n")}if(Q||w||(J+="endsolid stlmesh"),b){const p=document.createElement("a"),b=new Blob([J],{type:"application/octet-stream"});p.href=window.URL.createObjectURL(b),p.download=M+".stl",p.click()}return J}}function Vb(p,b){let M=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const h=[];for(let Q=0;Q<p.length/M;Q++){const mp=p[Q*M],y=p[Q*M+1],P=p[Q*M+2];h.push(`(${mp.toPrecision(b.precision)}, ${y.toPrecision(b.precision)}, ${P.toPrecision(b.precision)})`)}return h.join(", ")}function Db(p,b){const M=[];for(let h=0;h<p.length/2;h++){const Q=p[2*h],mp=p[2*h+1];M.push(`(${Q.toPrecision(b.precision)}, ${(1-mp).toPrecision(b.precision)})`)}return M.join(", ")}function Nb(p,b){const M=p.getVerticesData(z.f.PositionKind),h=p.getVerticesData(z.f.NormalKind);if(M&&h)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(p){var b;const M=null!==(b=p.qb())&&void 0!==b&&b.length?p.getTotalIndices():p.getTotalVertices();return Array(M/3).fill(3).join(", ")}(p)}]\n\t\tint[] faceVertexIndices = [${function(p){const b=p.qb(),M=[];if(null!==b)for(let h=0;h<b.length;h++)M.push(b[h]);else{const b=p.getTotalVertices();for(let p=0;p<b;p++)M.push(p)}return M.join(", ")}(p)}]\n\t\tnormal3f[] normals = [${Vb(h,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Vb(M,b)}]\n        ${function(p,b){let M="";for(let Q=0;Q<4;Q++){const h=Q>0?Q:"",mp=p.getVerticesData(z.f.UVKind+(h?h+1:""));mp&&(M+=`\n\t\ttexCoord2f[] primvars:st${h} = [${Db(mp,b)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const h=p.getVerticesData(z.f.ColorKind);return h&&(M+=`\n\tcolor3f[] primvars:displayColor = [${Vb(h,b,h.length/p.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),M}(p,b)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function Ob(p,b){return`\n        def "Geometry"\n        {\n        ${Nb(p,b)}\n        }\n        `}function Rb(p){let b='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return b+=p,fflate.strToU8(b)}function Kb(p){const b=p.m;return`( ${rb(b,0)}, ${rb(b,4)}, ${rb(b,8)}, ${rb(b,12)} )`}function rb(p,b){return`(${p[b+0]}, ${p[b+1]}, ${p[b+2]}, ${p[b+3]})`}function kb(p){const b="Object_"+p.uniqueId,M=function(p){const b=p.getWorldMatrix().clone(),M=p.upp().useRightHandedSystem;if(!M){let h=p.parent;for(;h;){if(yp(h,M)){b.multiplyToRef(h.getWorldMatrix().invert(),b);break}h=h.parent}}return b.determinant()<0&&Q.Tools.Warn(`Exporting mesh ${p.name} with negative scale. Result may look incorrect in destination engine.`),b}(p),h=Kb(M);return`def Xform "${b}" (\n\tprepend references = @./geometries/Geometry_${p.Ub.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${h}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${p.material.uniqueId}>\n}\n\n`}function Ab(p){switch(p){case u.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case u.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case u.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function nb(p){return`(${p.x}, ${p.y})`}function Cb(p){return`(${p.r}, ${p.g}, ${p.b})`}function Fb(p,b,M,Q,mp,y){const P=p.getInternalTexture().uniqueId+"_"+p.invertY;mp[P]=p;const w=p.coordinatesIndex>0?"st"+p.coordinatesIndex:"st",t=new h.Vector2(p.uScale,p.vScale),z=new h.Vector2(p.uOffset,p.vOffset),x=p.wAng,S=Math.sin(x),X=Math.cos(x);return z.y=1-z.y-t.y,z.x+=S*t.x,z.y+=(1-X)*t.y,`\n    def Shader "PrimvarReader_${M}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${w}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${M}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${b.uniqueId}/PrimvarReader_${M}.outputs:result>\n        float inputs:rotation = ${(x*(180/Math.PI)).toFixed(y.precision)}\n        float2 inputs:scale = ${nb(t)}\n        float2 inputs:translation = ${nb(z)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${p.uniqueId}_${M}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${P}.png@\n        float2 inputs:st.connect = </Materials/Material_${b.uniqueId}/Transform2d_${M}.outputs:result>\n        ${Q?"float4 inputs:scale = "+function(p){return`(${p.r}, ${p.g}, ${p.b}, 1.0)`}(Q):""}\n        token inputs:sourceColorSpace = "${p.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ab(p.wrapU)}"\n        token inputs:wrapT = "${Ab(p.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${b.needAlphaBlending()?"float outputs:a":""}\n    }`}function pM(p,b,M){const h="\t\t\t",Q=[],mp=[],{diffuseMap:y,Db:P,alphaCutOff:w,emissiveMap:t,emissive:z,normalMap:x,roughnessMap:S,roughnessChannel:X,roughness:c,metalnessMap:J,metalnessChannel:f,metalness:Y,aoMap:a,aoMapChannel:o,aoMapIntensity:l,alphaMap:L,ior:u,clearCoatEnabled:e,clearCoat:d,clearCoatMap:I,clearCoatRoughness:G,clearCoatRoughnessMap:v}=function(p){const b={diffuseMap:null,Db:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return p instanceof Jp.PM?{...b,diffuseMap:p.diffuseTexture,Db:p.diffuseColor,alphaCutOff:p.alphaCutOff,emissiveMap:p.emissiveTexture,emissive:p.emissiveColor,roughness:1,alphaMap:p.opacityTexture}:p instanceof tb.d?{...b,diffuseMap:p._albedoTexture,Db:p._albedoColor,alphaCutOff:p._alphaCutOff,emissiveMap:p._emissiveTexture,emissive:p._emissiveColor,normalMap:p._bumpTexture,roughnessMap:p._metallicTexture,roughnessChannel:p._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:p._roughness??1,metalnessMap:p._metallicTexture,metalnessChannel:p._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:p._metallic??0,aoMap:p._ambientTexture,aoMapChannel:p._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:p._ambientTextureStrength,alphaMap:p._opacityTexture,ior:p.subSurface.indexOfRefraction,clearCoatEnabled:p.clearCoat.isEnabled,clearCoat:p.clearCoat.Vb,clearCoatMap:p.clearCoat.texture,clearCoatRoughness:p.clearCoat.roughness,clearCoatRoughnessMap:p.clearCoat.useRoughnessFromMainTexture?p.clearCoat.texture:p.clearCoat.textureRoughness}:b}(p);return null!==y?(Q.push(`${h}color3f inputs:diffuseColor.connect = </Materials/Material_${p.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:rgb>`),p.needAlphaBlending()?Q.push(`${h}float inputs:opacity.connect = </Materials/Material_${p.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`):p.needAlphaTesting()&&(Q.push(`${h}float inputs:opacity.connect = </Materials/Material_${p.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`),Q.push(`${h}float inputs:opacityThreshold = ${w}`)),mp.push(Fb(y,p,"diffuse",P,b,M))):Q.push(`${h}color3f inputs:diffuseColor = ${Cb(P||g.wM.White())}`),null!==t?(Q.push(`${h}color3f inputs:emissiveColor.connect = </Materials/Material_${p.uniqueId}/Texture_${t.uniqueId}_emissive.outputs:rgb>`),mp.push(Fb(t,p,"emissive",z,b,M))):z&&z.toLuminance()>0&&Q.push(`${h}color3f inputs:emissiveColor = ${Cb(z)}`),null!==x&&(Q.push(`${h}normal3f inputs:normal.connect = </Materials/Material_${p.uniqueId}/Texture_${x.uniqueId}_normal.outputs:rgb>`),mp.push(Fb(x,p,"normal",null,b,M))),null!==a&&(Q.push(`${h}float inputs:occlusion.connect = </Materials/Material_${p.uniqueId}/Texture_${a.uniqueId}_occlusion.outputs:${o}>`),mp.push(Fb(a,p,"occlusion",new g.wM(l,l,l),b,M))),null!==S?(Q.push(`${h}float inputs:roughness.connect = </Materials/Material_${p.uniqueId}/Texture_${S.uniqueId}_roughness.outputs:${X}>`),mp.push(Fb(S,p,"roughness",new g.wM(c,c,c),b,M))):Q.push(`${h}float inputs:roughness = ${c}`),null!==J?(Q.push(`${h}float inputs:metallic.connect = </Materials/Material_${p.uniqueId}/Texture_${J.uniqueId}_metallic.outputs:${f}>`),mp.push(Fb(J,p,"metallic",new g.wM(Y,Y,Y),b,M))):Q.push(`${h}float inputs:metallic = ${Y}`),null!==L?(Q.push(`${h}float inputs:opacity.connect = </Materials/Material_${p.uniqueId}/Texture_${L.uniqueId}_opacity.outputs:r>`),Q.push(`${h}float inputs:opacityThreshold = 0.0001`),mp.push(Fb(L,p,"opacity",null,b,M))):Q.push(`${h}float inputs:opacity = ${p.alpha}`),e&&(null!==I?(Q.push(`${h}float inputs:clearcoat.connect = </Materials/Material_${p.uniqueId}/Texture_${I.uniqueId}_clearcoat.outputs:r>`),mp.push(Fb(I,p,"clearcoat",new g.wM(d,d,d),b,M))):Q.push(`${h}float inputs:clearcoat = ${d}`),null!==v?(Q.push(`${h}float inputs:clearcoatRoughness.connect = </Materials/Material_${p.uniqueId}/Texture_${v.uniqueId}_clearcoatRoughness.outputs:g>`),mp.push(Fb(v,p,"clearcoatRoughness",new g.wM(G,G,G),b,M))):Q.push(`${h}float inputs:clearcoatRoughness = ${G}`)),Q.push(`${h}float inputs:ior = ${u}`),`\n\tdef Material "Material_${p.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${Q.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${p.uniqueId}/PreviewSurface.outputs:surface>\n\n${mp.join("\n")}\n\n\t}\n`}async function bM(p,b,M){const mp={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...b};"undefined"===typeof fflate&&await Q.Tools.LoadScriptAsync(mp.fflateUrl);const y={};y[mp.modelFileName]=null;let P='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';P+=function(p){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===p.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${p.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${p.planeAnchoringAlignment}"`:""}\n            `}(mp);const w={};for(const h of p.meshes){if(0===h.getTotalVertices())continue;const p=h,b=p.Ub,t=p.material;if(!t||!b||M&&!M(p))continue;if(-1!==["PM","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(t.getClassName())){const M="geometries/Geometry_"+b.uniqueId+".usda";if(!(M in y)){const p=Ob(b,mp);y[M]=Rb(p)}t.uniqueId in w||(w[t.uniqueId]=t),P+=kb(p)}else Q.Tools.Warn("USDZExportAsync does not support this material type: "+t.getClassName())}p.activeCamera&&mp.exportCamera&&(P+=function(p,b){const M="Camera_"+p.uniqueId,Q=Kb(h.Matrix.RotationY(Math.PI).multiply(p.getWorldMatrix()));if(p.mode===u.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${M}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${p.Ib.toPrecision(b.precision)}, ${p.maxZ.toPrecision(b.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(p.orthoLeft||1)+Math.abs(p.orthoRight||1))).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(p.orthoTop||1)+Math.abs(p.orthoBottom||1))).toPrecision(b.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const h=p.getEngine().getAspectRatio(p),mp=b.cameraSensorWidth||35;return`def Camera "${M}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${Q}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${p.Ib.toPrecision(b.precision)}, ${p.maxZ.toPrecision(b.precision)})\n\t\t\tfloat focalLength = ${(mp/(2*Math.tan(.5*p.fov))).toPrecision(b.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(mp*h).toPrecision(b.precision)}\n\t\t\tfloat verticalAperture = ${(mp/h).toPrecision(b.precision)}            \n\t\t}\n\t\n\t`}}(p.activeCamera,mp)),P+="\n            }\n        }\n    }";const t={};P+=function(p,b,M){const h=[];for(const Q in p){const mp=p[Q];h.push(pM(mp,b,M))}return`\n    def "Materials"\n{\n${h.join("")}\n}\n\n`}(w,t,mp),y[mp.modelFileName]=fflate.strToU8(P);for(const h in t){const p=t[h],b=p.getSize(),M=await p.readPixels();if(!M)throw new Error("Texture data is not available");const Q=await e.DumpTools.DumpDataAsync(b.width,b.height,M,"image/png",void 0,!1,!0);y[`textures/Texture_${h}.png`]=new Uint8Array(Q).slice()}let z=0;for(const h in y){const p=y[h];if(!p)continue;z+=34+h.length;const b=63&z;if(4!==b){const M=new Uint8Array(64-b);y[h]=[p,{extra:{12345:M}}]}z=p.length}return fflate.zipSync(y,{level:0})}}}]);