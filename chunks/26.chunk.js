"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11518:(q,S,b)=>{b.r(S),b.d(S,{EXT_materials_diffuse_roughness:()=>xS,EXT_mesh_gpu_instancing:()=>hq,GLTF2Export:()=>wq,GLTFData:()=>I,KHR_draco_mesh_compression:()=>bS,KHR_lights_punctual:()=>rS,KHR_materials_anisotropy:()=>lS,KHR_materials_clearcoat:()=>RS,KHR_materials_diffuse_transmission:()=>HS,KHR_materials_dispersion:()=>kS,KHR_materials_emissive_strength:()=>NS,KHR_materials_ior:()=>XS,KHR_materials_iridescence:()=>BS,KHR_materials_sheen:()=>fS,KHR_materials_specular:()=>ES,KHR_materials_transmission:()=>iS,KHR_materials_unlit:()=>LS,KHR_materials_volume:()=>KS,KHR_texture_transform:()=>aS,OBJExport:()=>U,STLExport:()=>nS,USDZExportAsync:()=>Sb,_ConvertToGLTFPBRMetallicRoughness:()=>J,_SolveMetallic:()=>i,__IGLTFExporterExtension:()=>g});var z=b(11103),C=b(10921),v=b(11423);class U{static OBJ(q,S,b,U){const g=[];let r=1,I=1;S&&(b||(b="mat"),g.push("mtllib "+b+".mtl"));for(let V=0;V<q.length;V++){const b=q[V],l=b.name||`mesh${V}}`;g.push(`o ${l}`);let y=null;if(U){const q=b.Nb(!0);y=new z.Matrix,q.invertToRef(y),b.bakeTransformIntoVertices(q)}if(S){const q=b.material;q&&g.push("usemtl "+q.id)}const R=b.ub;if(!R){C.Tools.Warn("No geometry is present on the mesh");continue}const G=R.getVerticesData("position"),Z=R.getVerticesData("normal"),H=R.getVerticesData("uv"),Q=R.Xb();let k=0,W=0;if(!G||!Q){C.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const N=q[0].Tq().useRightHandedSystem?1:-1;for(let q=0;q<G.length;q+=3)g.push("v "+G[q]*N+" "+G[q+1]+" "+G[q+2]),k++;if(null!=Z)for(let q=0;q<Z.length;q+=3)g.push("vn "+Z[q]*N+" "+Z[q+1]+" "+Z[q+2]);if(null!=H)for(let q=0;q<H.length;q+=2)g.push("vt "+H[q]+" "+H[q+1]),W++;const u=["","",""],X=(b.material||b.Tq().defaultMaterial)._getEffectiveOrientation(b),[T,B]=X===v.c.ClockWiseSideOrientation?[2,1]:[1,2];for(let q=0;q<Q.length;q+=3){const S=[String(Q[q]+r),String(Q[q+T]+r),String(Q[q+B]+r)],b=[String(Q[q]+I),String(Q[q+T]+I),String(Q[q+B]+I)],z=S,C=null!=H?b:u,v=null!=Z?S:u;g.push("f "+z[0]+"/"+C[0]+"/"+v[0]+" "+z[1]+"/"+C[1]+"/"+v[1]+" "+z[2]+"/"+C[2]+"/"+v[2])}U&&y&&b.bakeTransformIntoVertices(y),r+=k,I+=W}return g.join("\n")}static MTL(q){const S=[],b=q.material;S.push("newmtl mat1"),S.push("  Ns "+b.specularPower.toFixed(4)),S.push("  Ni 1.5000"),S.push("  d "+b.alpha.toFixed(4)),S.push("  Tr 0.0000"),S.push("  Tf 1.0000 1.0000 1.0000"),S.push("  illum 2"),S.push("  Ka "+b.ambientColor.r.toFixed(4)+" "+b.ambientColor.g.toFixed(4)+" "+b.ambientColor.b.toFixed(4)),S.push("  Kd "+b.diffuseColor.r.toFixed(4)+" "+b.diffuseColor.g.toFixed(4)+" "+b.diffuseColor.b.toFixed(4)),S.push("  Ks "+b.specularColor.r.toFixed(4)+" "+b.specularColor.g.toFixed(4)+" "+b.specularColor.b.toFixed(4)),S.push("  Ke "+b.emissiveColor.r.toFixed(4)+" "+b.emissiveColor.g.toFixed(4)+" "+b.emissiveColor.b.toFixed(4));b.ambientTexture&&S.push("  map_Ka "+b.ambientTexture.name),b.diffuseTexture&&S.push("  map_Kd "+b.diffuseTexture.name),b.specularTexture&&S.push("  map_Ks "+b.specularTexture.name),b.bumpTexture&&S.push("  map_bump -imfchan z "+b.bumpTexture.name),b.opacityTexture&&S.push("  map_d "+b.opacityTexture.name);return S.join("\n")}}var g=0,r=b(10977);class I{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const q in this.files){const S=this.files[q],b=new Blob([S],{type:(0,r.g)(q)});C.Tools.Download(b,q)}}}var V=b(11172),l=b(11520),y=b(11532),R=b(11549),G=b(11231),Z=b(10975),H=b(11150),Q=b(11121);const k=Q.HighestCommonFactor,W={...Q,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:k};var N=b(11329),u=b(11075),X=b(11573),T=b(11575),B=b(11325);const t=1e-6,f=new H.HS(.04,.04,.04),m=1024,E=H.HS.White(),e=H.HS.Black();function i(q,S,b){if(S<f.r)return 0;const z=f.r,C=q*b/(1-f.r)+S-2*f.r,v=C*C-4*z*(f.r-S);return W.Clamp((-C+Math.sqrt(v))/(2*z),0,1)}function J(q){const S=q.diffuseColor.toLinearSpace(q.Tq().getEngine().useExactSrgbConversions).scale(.5),b=q.alpha,C=function(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new z.Vector2(0,1),b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new z.Vector2(0,.1),C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new z.Vector2(0,.1),v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new z.Vector2(1300,.1);return function(q,S,b,z,C){return(1-q)*(1-q)*(1-q)*S+3*(1-q)*(1-q)*q*b+3*(1-q)*q*q*z+q*q*q*C}(Math.pow(q/v.x,.333333),S.y,b.y,C.y,v.y)}(W.Clamp(q.specularPower,0,m));return{baseColorFactor:[S.r,S.g,S.b,b],metallicFactor:0,roughnessFactor:C}}function L(q,S){S.needAlphaBlending()?q.alphaMode="BLEND":S.needAlphaTesting()&&(q.alphaMode="MASK",q.alphaCutoff=S.alphaCutOff)}function d(q,S,b){const z=new Uint8Array(q*S*4);for(let C=0;C<z.length;C+=4)z[C]=z[C+1]=z[C+2]=z[C+3]=255;return X.c.CreateRGBATexture(z,q,S,b)}function K(q){if(q instanceof Uint8Array){const S=q.length,b=new Float32Array(q.length);for(let z=0;z<S;++z)b[z]=q[z]/255;return b}if(q instanceof Float32Array)return q;throw new Error("Unsupported pixel format!")}class D{constructor(q){this._exporter=q,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(q){return q?this._textureMap.get(q)??null:null}async exportStandardMaterialAsync(q,S,b){const z=J(q),v={name:q.name};if(null==q.Tb||q.Tb||(q.twoSidedLighting||C.Tools.Warn(q.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),v.doubleSided=!0),b){const b=[],C=q.diffuseTexture;C&&b.push(this.exportTextureAsync(C,S).then((q=>{q&&(z.baseColorTexture=q)})));const U=q.bumpTexture;U&&b.push(this.exportTextureAsync(U,S).then((q=>{q&&(v.normalTexture=q,1!==U.level&&(v.normalTexture.scale=U.level))})));const g=q.emissiveTexture;g&&(v.emissiveFactor=[1,1,1],b.push(this.exportTextureAsync(g,S).then((q=>{q&&(v.emissiveTexture=q)}))));const r=q.ambientTexture;r&&b.push(this.exportTextureAsync(r,S).then((q=>{if(q){const S={index:q.index};v.occlusionTexture=S}}))),b.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(b))}(q.alpha<1||q.opacityTexture)&&(q.alphaMode===T.b.ALPHA_COMBINE?v.alphaMode="BLEND":C.Tools.Warn(q.name+": glTF 2.0 does not support alpha mode: "+q.alphaMode.toString())),q.emissiveColor&&!q.emissiveColor.equalsWithEpsilon(e,t)&&(v.emissiveFactor=q.emissiveColor.Zb()),v.pbrMetallicRoughness=z,L(v,q),await this._finishMaterialAsync(v,q,S);const U=this._exporter._materials;return U.push(v),U.length-1}async _finishMaterialAsync(q,S,b){const z=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",q,S),C=[];for(const v of z)C.push(this.exportTextureAsync(v,b));await Promise.all(C),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",q,S)}async _getImageDataAsync(q,S,z,C){const v=T.b.TEXTURETYPE_UNSIGNED_BYTE,U=this._exporter._babylonScene,g=U.getEngine(),r=g.createRawTexture(q,S,z,T.b.TEXTUREFORMAT_RGBA,!1,!0,u.e.NEAREST_SAMPLINGMODE,null,v);g.isWebGPU?await b.e(51).then(b.bind(b,13597)):await b.e(52).then(b.bind(b,13605)),await N.j.ApplyPostProcess("pass",r,U,v,T.b.TEXTURE_NEAREST_SAMPLINGMODE,T.b.TEXTUREFORMAT_RGBA);const I=await g._readTexturePixels(r,S,z);return await B.DumpTools.DumpDataAsync(S,z,I,C,void 0,!0,!0)}_resizeTexturesToSameDimensions(q,S,b){const z=q?q.getSize():{width:0,height:0},C=S?S.getSize():{width:0,height:0};let v,U;return z.width<C.width?(v=q&&q instanceof u.e?N.j.CreateResizedCopy(q,C.width,C.height,!0):d(C.width,C.height,b),U=S):z.width>C.width?(U=S&&S instanceof u.e?N.j.CreateResizedCopy(S,z.width,z.height,!0):d(z.width,z.height,b),v=q):(v=q,U=S),{texture1:v,texture2:U}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(q,S,b,z){const C=new Array;if(!q&&!S)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const v=q?q.Tq():S?S.Tq():null;if(v){var U;const g=this._resizeTexturesToSameDimensions(q,S,v),r=null===(U=g.texture1)||void 0===U?void 0:U.getSize();let I,V;const l=r.width,y=r.height,R=await g.texture1.readPixels(),G=await g.texture2.readPixels();if(!R)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(I=K(R),!G)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");V=K(G);const Z=V.byteLength,Q=new Uint8Array(Z),k=new Uint8Array(Z),W=4,N=e;let u=0,X=0;for(let q=0;q<y;++q)for(let S=0;S<l;++S){const z=(l*q+S)*W,C={diffuseColor:new H.HS(I[z],I[z+1],I[z+2]).toLinearSpace(v.getEngine().useExactSrgbConversions).multiply(b.diffuseColor),specularColor:new H.HS(V[z],V[z+1],V[z+2]).toLinearSpace(v.getEngine().useExactSrgbConversions).multiply(b.specularColor),glossiness:V[z+3]*b.glossiness},U=this._convertSpecularGlossinessToMetallicRoughness(C);N.r=Math.max(N.r,U.baseColor.r),N.g=Math.max(N.g,U.baseColor.g),N.b=Math.max(N.b,U.baseColor.b),u=Math.max(u,U.metallic),X=Math.max(X,U.roughness),k[z]=255*U.baseColor.r,k[z+1]=255*U.baseColor.g,k[z+2]=255*U.baseColor.b,k[z+3]=g.texture1.Qb?255*I[z+3]:255,Q[z]=0,Q[z+1]=255*U.roughness,Q[z+2]=255*U.metallic,Q[z+3]=255}const T={baseColor:N,metallic:u,roughness:X};let B=!1,f=!1;for(let q=0;q<y;++q)for(let S=0;S<l;++S){const b=(l*q+S)*W;k[b]/=T.baseColor.r>t?T.baseColor.r:1,k[b+1]/=T.baseColor.g>t?T.baseColor.g:1,k[b+2]/=T.baseColor.b>t?T.baseColor.b:1;const z=H.HS.FromInts(k[b],k[b+1],k[b+2]).toGammaSpace(v.getEngine().useExactSrgbConversions);k[b]=255*z.r,k[b+1]=255*z.g,k[b+2]=255*z.b,z.equalsWithEpsilon(E,t)||(f=!0),Q[b+1]/=T.roughness>t?T.roughness:1,Q[b+2]/=T.metallic>t?T.metallic:1;H.HS.FromInts(255,Q[b+1],Q[b+2]).equalsWithEpsilon(E,t)||(B=!0)}return B&&C.push(this._getImageDataAsync(Q,l,y,z).then((q=>{T.metallicRoughnessTextureData=q}))),f&&C.push(this._getImageDataAsync(k,l,y,z).then((q=>{T.baseColorTextureData=q}))),await Promise.all(C).then((()=>T))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(q){const S=this._getPerceivedBrightness(q.diffuseColor),b=this._getPerceivedBrightness(q.specularColor),z=1-this._getMaxComponent(q.specularColor),C=i(S,b,z),v=q.diffuseColor.scale(z/(1-f.r)/Math.max(1-C)),U=q.specularColor.RS(f.scale(1-C)).scale(1/Math.max(C));let g=H.HS.Lerp(v,U,C*C);g=g.clampToRef(0,1,g);return{baseColor:g,metallic:C,roughness:1-q.glossiness}}_getPerceivedBrightness(q){return q?Math.sqrt(.299*q.r*q.r+.587*q.g*q.g+.114*q.b*q.b):0}_getMaxComponent(q){return q?Math.max(q.r,Math.max(q.g,q.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(q,S,b,z){const C=[],v={baseColor:q._albedoColor,metallic:q._metallic,roughness:q._roughness};if(z){q._albedoTexture&&C.push(this.exportTextureAsync(q._albedoTexture,S).then((q=>{q&&(b.baseColorTexture=q)})));const z=q._metallicTexture;z&&C.push(this.exportTextureAsync(z,S).then((q=>{q&&(b.metallicRoughnessTexture=q)})))}return C.length>0&&(this._exporter._materialNeedsUVsSet.add(q),await Promise.all(C)),v}_getTextureSampler(q){const S={};if(!q||!(q instanceof u.e))return S;const b=this._getGLTFTextureWrapMode(q.wrapU);10497!==b&&(S.wrapS=b);const z=this._getGLTFTextureWrapMode(q.wrapV);switch(10497!==z&&(S.wrapT=z),q.samplingMode){case u.e.LINEAR_LINEAR:S.magFilter=9729,S.minFilter=9729;break;case u.e.LINEAR_NEAREST:S.magFilter=9729,S.minFilter=9728;break;case u.e.NEAREST_LINEAR:S.magFilter=9728,S.minFilter=9729;break;case u.e.NEAREST_LINEAR_MIPLINEAR:S.magFilter=9728,S.minFilter=9987;break;case u.e.NEAREST_NEAREST:S.magFilter=9728,S.minFilter=9728;break;case u.e.NEAREST_LINEAR_MIPNEAREST:S.magFilter=9728,S.minFilter=9985;break;case u.e.LINEAR_NEAREST_MIPNEAREST:S.magFilter=9729,S.minFilter=9984;break;case u.e.LINEAR_NEAREST_MIPLINEAR:S.magFilter=9729,S.minFilter=9986;break;case u.e.NEAREST_NEAREST_MIPLINEAR:S.magFilter=9728,S.minFilter=9986;break;case u.e.LINEAR_LINEAR_MIPLINEAR:S.magFilter=9729,S.minFilter=9987;break;case u.e.LINEAR_LINEAR_MIPNEAREST:S.magFilter=9729,S.minFilter=9985;break;case u.e.NEAREST_NEAREST_MIPNEAREST:S.magFilter=9728,S.minFilter=9984}return S}_getGLTFTextureWrapMode(q){switch(q){case u.e.WRAP_ADDRESSMODE:return 10497;case u.e.CLAMP_ADDRESSMODE:return 33071;case u.e.MIRROR_ADDRESSMODE:return 33648;default:return C.Tools.Error(`Unsupported Texture Wrap Mode ${q}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(q,S,b,z){const C={diffuseColor:q._albedoColor,specularColor:q._reflectivityColor,glossiness:q._microSurface},v=q._albedoTexture,U=q._reflectivityTexture,g=q._useMicroSurfaceFromReflectivityMapAlpha;if(U&&!g)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((v||U)&&z){this._exporter._materialNeedsUVsSet.add(q);const z=this._exportTextureSampler(v||U),g=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(v,U,C,S),r=this._exporter._textures;if(g.baseColorTextureData){const q=this._exportImage(`baseColor${r.length}`,S,g.baseColorTextureData);b.baseColorTexture=this._exportTextureInfo(q,z,null===v||void 0===v?void 0:v.coordinatesIndex)}if(g.metallicRoughnessTextureData){const q=this._exportImage(`metallicRoughness${r.length}`,S,g.metallicRoughnessTextureData);b.metallicRoughnessTexture=this._exportTextureInfo(q,z,null===U||void 0===U?void 0:U.coordinatesIndex)}return g}return this._convertSpecularGlossinessToMetallicRoughness(C)}async exportPBRMaterialAsync(q,S,b){const z={},C={name:q.name},v=q.isMetallicWorkflow();if(v){const S=q._albedoColor,b=q.alpha;S&&(z.baseColorFactor=[S.r,S.g,S.b,b])}const U=v?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(q,S,z,b):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(q,S,z,b);await this._setMetallicRoughnessPbrMaterialAsync(U,q,C,z,S,b),await this._finishMaterialAsync(C,q,S);const g=this._exporter._materials;return g.push(C),g.length-1}async _setMetallicRoughnessPbrMaterialAsync(q,S,b,z,v,U){if(L(b,S),q.baseColor.equalsWithEpsilon(E,t)&&W.WithinEpsilon(S.alpha,1,t)||(z.baseColorFactor=[q.baseColor.r,q.baseColor.g,q.baseColor.b,S.alpha]),null!=q.metallic&&1!==q.metallic&&(z.metallicFactor=q.metallic),null!=q.roughness&&1!==q.roughness&&(z.roughnessFactor=q.roughness),null==S.Tb||S.Tb||(S._twoSidedLighting||C.Tools.Warn(S.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),U){const q=[],z=S._bumpTexture;z&&q.push(this.exportTextureAsync(z,v).then((q=>{q&&(b.normalTexture=q,1!==z.level&&(b.normalTexture.scale=z.level))})));const C=S._ambientTexture;C&&q.push(this.exportTextureAsync(C,v).then((q=>{if(q){const z={index:q.index,texCoord:q.texCoord,extensions:q.extensions};b.occlusionTexture=z;const C=S._ambientTextureStrength;C&&(z.strength=C)}})));const U=S._emissiveTexture;U&&q.push(this.exportTextureAsync(U,v).then((q=>{q&&(b.emissiveTexture=q)}))),q.length>0&&(this._exporter._materialNeedsUVsSet.add(S),await Promise.all(q))}const g=S._emissiveColor;g.equalsWithEpsilon(e,t)||(b.emissiveFactor=g.Zb()),b.pbrMetallicRoughness=z}_getPixelsFromTextureAsync(q){return function(q){switch(q){case T.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case T.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case T.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case T.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case T.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case T.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case T.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case T.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case T.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case T.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case T.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case T.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case T.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(q.textureFormat)?(0,N.g)(q,q._texture.width,q._texture.height):(q.textureType,T.b.TEXTURETYPE_UNSIGNED_BYTE,q.readPixels())}async exportTextureAsync(q,S){const b=this._exporter._extensionsPreExportTextureAsync("exporter",q,S);return b?await b.then((async b=>b?await this._exportTextureInfoAsync(b,S):await this._exportTextureInfoAsync(q,S))):await this._exportTextureInfoAsync(q,S)}async _exportTextureInfoAsync(q,S){let b=this._textureMap.get(q);if(!b){const z=await this._getPixelsFromTextureAsync(q);if(!z)return null;const v=this._exportTextureSampler(q),U=q.mimeType;if(U)switch(U){case"image/jpeg":case"image/png":case"image/webp":S=U;break;default:C.Tools.Warn(`Unsupported media type: ${U}. Exporting texture as PNG.`)}const g=this._internalTextureToImage,r=q.getInternalTexture().uniqueId;g[r]||(g[r]={});let I=g[r][S];if(void 0===I){const b=q.getSize();I=(async()=>{const C=await this._getImageDataAsync(z,b.width,b.height,S);return this._exportImage(q.name,S,C)})(),g[r][S]=I}b=this._exportTextureInfo(await I,v,q.coordinatesIndex),this._textureMap.set(q,b),this._exporter._extensionsPostExportTextures("exporter",b,q)}return b}_exportImage(q,S,b){const z=this._exporter._images;let v;if(this._exporter._shouldUseGlb){v={name:q,mimeType:S,bufferView:void 0};const z=this._exporter._bufferManager.createBufferView(new Uint8Array(b));this._exporter._bufferManager.setBufferView(v,z)}else{const U=q.replace(/\.\/|\/|\.\\|\\/g,"_"),g=function(q){switch(q){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(S);let r=U+g;z.some((q=>q.uri===r))&&(r=`${U}_${C.Tools.RandomId()}${g}`),v={name:q,uri:r},this._exporter._imageData[r]={data:b,mimeType:S}}return z.push(v),z.length-1}_exportTextureInfo(q,S,b){const z=this._exporter._textures;let C=z.findIndex((b=>b.sampler==S&&b.source===q));-1===C&&(C=z.length,z.push({source:q,sampler:S}));const v={index:C};return b&&(v.texCoord=b),v}_exportTextureSampler(q){const S=this._getTextureSampler(q),b=this._exporter._samplers,z=b.findIndex((q=>q.minFilter===S.minFilter&&q.magFilter===S.magFilter&&q.wrapS===S.wrapS&&q.wrapT===S.wrapT));return-1!==z?z:(b.push(S),b.length-1)}}var x=b(11187),F=b(10943),a=b(11583),n=b(11109);const o=z.yS.Zero(),s=z.Quaternion.Identity(),A=z.yS.One(),w=new z.yS(-1,1,1);function P(q,S){const{byteOffset:b,byteStride:z,type:C,normalized:v}=q,U=q.getSize(),g=S.reduce(((q,S)=>S.getTotalVertices()>q?S.getTotalVertices():q),-Number.MAX_VALUE);return{byteOffset:b,byteStride:z,componentCount:U,type:C,count:g*U,normalized:v,totalVertices:g,kind:q.getKind()}}function h(q){switch(q){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function O(q){switch(q){case V.f.PositionKind:case V.f.NormalKind:case V.f.TangentKind:case V.f.ColorKind:case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:case V.f.MatricesWeightsKind:case V.f.MatricesWeightsExtraKind:case V.f.UVKind:case V.f.UV2Kind:case V.f.UV3Kind:case V.f.UV4Kind:case V.f.UV5Kind:case V.f.UV6Kind:return!0}return!1}function j(q){switch(q){case v.c.TriangleFillMode:return 4;case v.c.TriangleStripDrawMode:return 5;case v.c.TriangleFanDrawMode:return 6;case v.c.PointListDrawMode:case v.c.PointFillMode:return 0;case v.c.LineLoopDrawMode:return 2;case v.c.LineListDrawMode:return 1;case v.c.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${q}`)}function M(q){const S=Math.sqrt(q.x*q.x+q.y*q.y+q.z*q.z);S>0&&(q.x/=S,q.y/=S,q.z/=S)}function p(q){return q.x*=-1,q}function Y(q){if(q.x*q.x+q.y*q.y>.5){const S=Math.abs(q.x),b=Math.abs(q.y);if(S>b){const b=Math.sign(q.x);q.x=S,q.y*=-b,q.z*=-b,q.w*=b}else{const S=Math.sign(q.y);q.x*=-S,q.y=b,q.z*=S,q.w*=-S}}else{const S=Math.abs(q.z),b=Math.abs(q.w);if(S>b){const b=Math.sign(q.z);q.x*=-b,q.y*=b,q.z=S,q.w*=-b}else{const S=Math.sign(q.w);q.x*=S,q.y*=-S,q.z*=-S,q.w=b}}return q}function c(q){q.Bb(-q.z,q.w,q.x,-q.y)}function qq(q,S){const b=z.yS.FromArrayToRef(S.translation||[0,0,0],0,z.TmpVectors.yS[0]),C=z.Quaternion.FromArrayToRef(S.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[0]),v=z.Matrix.ComposeToRef(A,C,b,z.TmpVectors.Matrix[0]),U=z.yS.FromArrayToRef(q.translation||[0,0,0],0,z.TmpVectors.yS[2]),g=z.Quaternion.FromArrayToRef(q.rotation||[0,0,0,1],0,z.TmpVectors.Quaternion[1]),r=z.Matrix.ComposeToRef(A,g,U,z.TmpVectors.Matrix[1]);v.multiplyToRef(r,r),r.decompose(void 0,C,b),b.equalsWithEpsilon(o,n.d)?delete S.translation:S.translation=b.Zb(),C.equalsWithEpsilon(s,n.d)?delete S.rotation:S.rotation=C.Zb(),S.scale&&delete S.scale}function Sq(q,S){if(!(S instanceof l.e))return!1;if(!(1===S.getChildren().length&&0===q.getChildren().length&&q.parent===S))return!1;const b=q.Tq(),z=q instanceof a.d&&!b.useRightHandedSystem?w:A;return!!S.tb.equalsWithEpsilon(z,n.d)||(F.b.Warn(`Cannot collapse node ${q.name} into parent node ${S.name} with modified scaling.`),!1)}function bq(q){if(q instanceof Array){const S=new Float32Array(q);return new Uint8Array(S.buffer,S.byteOffset,S.byteLength)}return ArrayBuffer.isView(q)?new Uint8Array(q.buffer,q.byteOffset,q.byteLength):new Uint8Array(q)}function zq(q,S){for(const[b,z]of Object.entries(q)){const C=S[b];(Array.isArray(z)&&Array.isArray(C)&&Cq(z,C)||z===C)&&delete q[b]}return q}function Cq(q,S){return q.length===S.length&&q.every(((q,b)=>q===S[b]))}const vq=z.Matrix.Compose(new z.yS(-1,1,1),z.Quaternion.Identity(),z.yS.Zero());function Uq(q,S){if(!(q instanceof l.e))return!1;if(S){if(!q.getWorldMatrix().equalsWithEpsilon(z.Matrix.IdentityReadOnly,n.d))return!1}else{if(!q.getWorldMatrix().multiplyToRef(vq,z.TmpVectors.Matrix[0]).equalsWithEpsilon(z.Matrix.IdentityReadOnly,n.d))return!1}return!(q instanceof y.c&&q.ub)}const gq=new Map([[Int8Array,(q,S,b)=>q.setInt8(S,b)],[Uint8Array,(q,S,b)=>q.setUint8(S,b)],[Uint8ClampedArray,(q,S,b)=>q.setUint8(S,b)],[Int16Array,(q,S,b)=>q.setInt16(S,b,!0)],[Uint16Array,(q,S,b)=>q.setUint16(S,b,!0)],[Int32Array,(q,S,b)=>q.setInt32(S,b,!0)],[Uint32Array,(q,S,b)=>q.setUint32(S,b,!0)],[Float32Array,(q,S,b)=>q.setFloat32(S,b,!0)],[Float64Array,(q,S,b)=>q.setFloat64(S,b,!0)]]);class rq{writeTypedArray(q){this._checkGrowBuffer(q.byteLength);const S=gq.get(q.constructor);for(let b=0;b<q.length;b++)S(this._dataView,this._byteOffset,q[b]),this._byteOffset+=q.BYTES_PER_ELEMENT}constructor(q){this._data=new Uint8Array(q),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(q){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,q),this._byteOffset++}writeInt8(q){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,q),this._byteOffset++}writeInt16(q){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,q,!0),this._byteOffset+=2}writeUInt16(q){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,q,!0),this._byteOffset+=2}writeInt32(q){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,q,!0),this._byteOffset+=4}writeUInt32(q){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat32(q){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,q,!0),this._byteOffset+=4}writeFloat64(q){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,q,!0),this._byteOffset+=8}_checkGrowBuffer(q){const S=this.byteOffset+q;if(S>this._data.byteLength){const q=new Uint8Array(2*S);q.set(this._data),this._data=q,this._dataView=new DataView(this._data.buffer)}}}function Iq(q){return q%4===0?4:q%2===0?2:1}class Vq{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(q){let S=0;this._bufferViewToData.forEach((q=>{S+=q.byteLength}));const b=new rq(S),z=Array.from(this._bufferViewToData.keys()).sort(((q,S)=>Iq(S.byteLength)-Iq(q.byteLength)));for(const C of z){C.byteOffset=b.byteOffset,q.push(C);const S=q.length-1,z=this.getPropertiesWithBufferView(C);for(const q of z)q.bufferView=S;b.writeTypedArray(this._bufferViewToData.get(C)),this._bufferViewToData.delete(C)}return b.getOutputData()}createBufferView(q,S){const b={buffer:0,byteOffset:void 0,byteLength:q.byteLength,byteStride:S};return this._bufferViewToData.set(b,q),b}createAccessor(q,S,b,z,C,v,U){this._verifyBufferView(q);const g={bufferView:void 0,componentType:b,count:z,type:S,min:null===v||void 0===v?void 0:v.min,max:null===v||void 0===v?void 0:v.max,normalized:U,byteOffset:C};return this.setBufferView(g,q),this._accessorToBufferView.set(g,q),g}setBufferView(q,S){this._verifyBufferView(S);this.getPropertiesWithBufferView(S).push(q)}removeBufferView(q){const S=this.getPropertiesWithBufferView(q);for(const b of S)void 0!==b.bufferView&&delete b.bufferView;this._bufferViewToData.delete(q),this._bufferViewToProperties.delete(q),this._accessorToBufferView.forEach(((S,b)=>{S===q&&(void 0!==b.byteOffset&&delete b.byteOffset,this._accessorToBufferView.delete(b))}))}getBufferView(q){const S=this._accessorToBufferView.get(q);return this._verifyBufferView(S),S}getPropertiesWithBufferView(q){return this._verifyBufferView(q),this._bufferViewToProperties.set(q,this._bufferViewToProperties.get(q)??[]),this._bufferViewToProperties.get(q)}getData(q){return this._verifyBufferView(q),this._bufferViewToData.get(q)}_verifyBufferView(q){if(void 0===q||!this._bufferViewToData.has(q))throw new Error(`BufferView ${q} not found in BufferManager.`)}}var lq,yq=b(11557),Rq=b(11568),Gq=b(11591),Zq=b(11485),Hq=b(11634),Qq=b(11650),kq=b(11555),Wq=b(11659);!function(q){q[q.INTANGENT=0]="INTANGENT",q[q.OUTTANGENT=1]="OUTTANGENT"}(lq||(lq={}));class Nq{static _IsTransformable(q){return q&&(q instanceof l.e||q instanceof yq.c||q instanceof Wq.b)}static _CreateNodeAnimation(q,S,b,z,v){if(this._IsTransformable(q)){const U=[],g=[],r=S.getKeys(),I=Nq._CalculateMinMaxKeyFrames(r),V=Nq._DeduceInterpolation(r,b,z),l=V.interpolationType,y=V.shouldBakeAnimation;if(y?Nq._CreateBakedAnimation(q,S,b,I.min,I.max,S.framePerSecond,v,U,g,I,z):"LINEAR"===l||"STEP"===l?Nq._CreateLinearOrStepAnimation(q,S,b,U,g,z):"CUBICSPLINE"===l?Nq._CreateCubicSplineAnimation(q,S,b,U,g,z):Nq._CreateBakedAnimation(q,S,b,I.min,I.max,S.framePerSecond,v,U,g,I,z),U.length&&g.length){return{inputs:U,outputs:g,samplerInterpolation:l,inputsMin:y?I.min:C.Tools.FloatRound(I.min/S.framePerSecond),inputsMax:y?I.max:C.Tools.FloatRound(I.max/S.framePerSecond)}}}return null}static _DeduceAnimationInfo(q){let S=null,b="VEC3",z=!1;const v=q.targetProperty.split(".");switch(v[0]){case"tb":S="scale";break;case"position":S="translation";break;case"rotation":b="VEC4",S="rotation";break;case"rotationQuaternion":b="VEC4",z=!0,S="rotation";break;case"influence":b="SCALAR",S="weights";break;default:C.Tools.Error(`Unsupported animatable property ${v[0]}`)}return S?{animationChannelTargetPath:S,dataAccessorType:b,useQuaternion:z}:(C.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(q,S,b,z,C,v,U,g,r,I,V){let l;if(Nq._IsTransformable(q)&&q.animations)for(const y of q.animations){if(V&&!V(y))continue;const C=Nq._DeduceAnimationInfo(y);C&&(l={name:y.name,samplers:[],channels:[]},Nq._AddAnimation(`${y.name}`,y.hasRunningRuntimeAnimations?S:l,q,y,C.dataAccessorType,C.animationChannelTargetPath,z,v,U,g,C.useQuaternion,r,I),l.samplers.length&&l.channels.length&&b.push(l))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(q,S,b,z,C,v,U,g,r,I,V){let l;if(q instanceof kq.d){const C=q.morphTargetManager;if(C)for(let y=0;y<C.numTargets;++y){const R=C.getTarget(y);for(const G of R.animations){if(V&&!V(G))continue;const R=new Hq.d(`${G.name}`,"influence",G.framePerSecond,G.dataType,G.loopMode,G.enableBlending),Z=[],H=G.getKeys();for(let q=0;q<H.length;++q){const S=H[q];for(let q=0;q<C.numTargets;++q)q==y?Z.push(S):Z.push({frame:S.frame,value:0})}R.setKeys(Z);const Q=Nq._DeduceAnimationInfo(R);Q&&(l={name:R.name,samplers:[],channels:[]},Nq._AddAnimation(G.name,G.hasRunningRuntimeAnimations?S:l,q,R,Q.dataAccessorType,Q.animationChannelTargetPath,z,v,U,g,Q.useQuaternion,r,I,C.numTargets),l.samplers.length&&l.channels.length&&b.push(l))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(q,S,b,z,C,v,U,g,r){let I;if(q.animationGroups){const l=q.animationGroups;for(const y of l){const l=new Map,R=new Map,G=new Set,Z=y.to-y.from;I={name:y.name,channels:[],samplers:[]};for(let S=0;S<y.targetedAnimations.length;++S){const Z=y.targetedAnimations[S],H=Z.target,Q=Z.animation;if(r&&!r(Q))continue;const k=g.has(H);if(this._IsTransformable(H)||1===H.length&&this._IsTransformable(H[0])){const q=Nq._DeduceAnimationInfo(Z.animation);if(q){const S=this._IsTransformable(H)?H:this._IsTransformable(H[0])?H[0]:null;S&&Nq._AddAnimation(`${Q.name}`,I,S,Q,q.dataAccessorType,q.animationChannelTargetPath,b,z,C,v,q.useQuaternion,U,k)}}else if(H instanceof Qq.c||1===H.length&&H[0]instanceof Qq.c){if(Nq._DeduceAnimationInfo(Z.animation)){const S=H instanceof Qq.c?H:H[0];if(S){const b=q.morphTargetManagers.find((q=>{for(let b=0;b<q.numTargets;++b)if(q.getTarget(b)===S)return!0;return!1}));if(b){const z=q.meshes.find((q=>q.morphTargetManager===b));var V;if(z)l.has(z)||l.set(z,new Map),null===(V=l.get(z))||void 0===V||V.set(S,Q),G.add(z),R.set(z,Q)}}}}}G.forEach((q=>{const S=q.morphTargetManager;let g=null;const r=[],V=R.get(q).getKeys(),G=V.length;for(let b=0;b<G;++b)for(let z=0;z<S.numTargets;++z){const C=S.getTarget(z),v=l.get(q);if(v){const S=v.get(C);S?(g||(g=new Hq.d(`${y.name}_${q.name}_MorphWeightAnimation`,"influence",S.framePerSecond,Hq.d.ANIMATIONTYPE_FLOAT,S.loopMode,S.enableBlending)),r.push(S.getKeys()[b])):r.push({frame:y.from+Z/G*b,value:C.influence,inTangent:V[0].inTangent?0:void 0,outTangent:V[0].outTangent?0:void 0})}}g.setKeys(r);const H=Nq._DeduceAnimationInfo(g);H&&Nq._AddAnimation(`${y.name}_${q.name}_MorphWeightAnimation`,I,q,g,H.dataAccessorType,H.animationChannelTargetPath,b,z,C,v,H.useQuaternion,U,!1,null===S||void 0===S?void 0:S.numTargets)})),I.channels.length&&I.samplers.length&&S.push(I)}}}static _AddAnimation(q,S,b,C,v,U,g,r,I,V,l,y,R,G){const Z=Nq._CreateNodeAnimation(b,C,U,l,y);let H,Q,k,W,N,u;if(Z){if(G){let q=0,S=0;const b=[];for(;Z.inputs.length>0;)S=Z.inputs.shift(),q%G==0&&b.push(S),q++;Z.inputs=b}const q=g.get(b),C=new Float32Array(Z.inputs);H=r.createBufferView(C),Q=r.createAccessor(H,"SCALAR",5126,Z.inputs.length,void 0,{min:[Z.inputsMin],max:[Z.inputsMax]}),V.push(Q),k=V.length-1;const I=new z.Quaternion,l=new z.yS,y=new z.yS,X=b instanceof yq.c,T=h(v),B=new Float32Array(Z.outputs.length*T);Z.outputs.forEach((function(q,S){let b=q;switch(U){case"translation":R&&(z.yS.FromArrayToRef(q,0,y),p(y),y.toArray(b));break;case"rotation":4===q.length?z.Quaternion.FromArrayToRef(q,0,I):(b=new Array(4),z.yS.FromArrayToRef(q,0,l),z.Quaternion.FromEulerVectorToRef(l,I)),R&&(Y(I),X&&c(I)),I.toArray(b)}B.set(b,S*T)})),H=r.createBufferView(B),Q=r.createAccessor(H,v,5126,Z.outputs.length),V.push(Q),W=V.length-1,N={interpolation:Z.samplerInterpolation,input:k,output:W},S.samplers.push(N),u={sampler:S.samplers.length-1,target:{node:q,path:U}},S.channels.push(u)}}static _CreateBakedAnimation(q,S,b,v,U,g,r,I,V,l,y){let R;const G=z.Quaternion.Identity();let Z,H=null,Q=null,k=null,W=null,N=null,u=null;l.min=C.Tools.FloatRound(v/g);const X=S.getKeys();for(let z=0,T=X.length;z<T;++z){if(u=null,k=X[z],z+1<T)if(W=X[z+1],k.value.equals&&k.value.equals(W.value)||k.value===W.value){if(0!==z)continue;u=k.frame}else u=W.frame;else{if(N=X[z-1],k.value.equals&&k.value.equals(N.value)||k.value===N.value)continue;u=U}if(u)for(let z=k.frame;z<=u;z+=r){if(Z=C.Tools.FloatRound(z/g),Z===H)continue;H=Z,Q=Z;const v={key:0,repeatCount:0,loopMode:S.loopMode};R=S._interpolate(z,v),Nq._SetInterpolatedValue(q,R,Z,S,b,G,I,V,y)}}Q&&(l.max=Q)}static _ConvertFactorToVector3OrQuaternion(q,S,b,v,U){const g=Nq._GetBasePositionRotationOrScale(S,v,U),r=b.targetProperty.split("."),I=r?r[1]:"",V=U?z.Quaternion.Hb(g).normalize():z.yS.Hb(g);switch(I){case"x":case"y":case"z":V[I]=q;break;case"w":V.w=q;break;default:C.Tools.Error(`glTFAnimation: Unsupported component name "${I}"!`)}return V}static _SetInterpolatedValue(q,S,b,C,v,U,g,r,I){let V;g.push(b),"weights"!==v?(C.dataType===Hq.d.ANIMATIONTYPE_FLOAT&&(S=this._ConvertFactorToVector3OrQuaternion(S,q,C,v,I)),"rotation"===v?(I?U=S:(V=S,z.Quaternion.RotationYawPitchRollToRef(V.y,V.x,V.z,U)),r.push(U.Zb())):(V=S,r.push(V.Zb()))):r.push([S])}static _CreateLinearOrStepAnimation(q,S,b,z,C,v){for(const U of S.getKeys())z.push(U.frame/S.framePerSecond),Nq._AddKeyframeValue(U,S,C,b,q,v)}static _CreateCubicSplineAnimation(q,S,b,z,C,v){S.getKeys().forEach((function(U){z.push(U.frame/S.framePerSecond),Nq._AddSplineTangent(lq.INTANGENT,C,b,"CUBICSPLINE",U,v),Nq._AddKeyframeValue(U,S,C,b,q,v),Nq._AddSplineTangent(lq.OUTTANGENT,C,b,"CUBICSPLINE",U,v)}))}static _GetBasePositionRotationOrScale(q,S,b){let C;if("rotation"===S)if(b){C=(q.rotationQuaternion??z.Quaternion.Identity()).Zb()}else{C=(q.rotation??z.yS.Zero()).Zb()}else if("translation"===S){C=(q.position??z.yS.Zero()).Zb()}else{C=(q.tb??z.yS.One()).Zb()}return C}static _AddKeyframeValue(q,S,b,v,U,g){let r;const I=S.dataType;if(I===Hq.d.ANIMATIONTYPE_VECTOR3){let S=q.value.Zb();if("rotation"===v){const q=z.yS.Hb(S);S=z.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).Zb()}b.push(S)}else if(I===Hq.d.ANIMATIONTYPE_FLOAT){if("weights"===v)b.push([q.value]);else if(r=this._ConvertFactorToVector3OrQuaternion(q.value,U,S,v,g),r){if("rotation"===v){const q=g?r:z.Quaternion.RotationYawPitchRoll(r.y,r.x,r.z).normalize();b.push(q.Zb())}b.push(r.Zb())}}else I===Hq.d.ANIMATIONTYPE_QUATERNION?b.push(q.value.normalize().Zb()):C.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(q,S,b){let z,C,v=!1;if("rotation"===S&&!b)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let U=0,g=q.length;U<g;++U)if(C=q[U],C.inTangent||C.outTangent)if(z){if("CUBICSPLINE"!==z){z="LINEAR",v=!0;break}}else z="CUBICSPLINE";else if(z){if("CUBICSPLINE"===z||C.interpolation&&1===C.interpolation&&"STEP"!==z){z="LINEAR",v=!0;break}}else z=C.interpolation&&1===C.interpolation?"STEP":"LINEAR";return z||(z="LINEAR"),{interpolationType:z,shouldBakeAnimation:v}}static _AddSplineTangent(q,S,b,C,v,U){let g;const r=q===lq.INTANGENT?v.inTangent:v.outTangent;if("CUBICSPLINE"===C){if("rotation"===b)if(r)if(U)g=r.Zb();else{const q=r;g=z.Quaternion.RotationYawPitchRoll(q.y,q.x,q.z).Zb()}else g=[0,0,0,0];else g="weights"===b?r?[r]:[0]:r?r.Zb():[0,0,0];S.push(g)}}static _CalculateMinMaxKeyFrames(q){let S=1/0,b=-1/0;return q.forEach((function(q){S=Math.min(S,q.frame),b=Math.max(b,q.frame)})),{min:S,max:b}}}function uq(q,S,b,v,U,g){const r={attributes:{},influence:q.influence,name:q.name},I=S.ub;if(!I)return C.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),r;const l=g?-1:1,y=z.yS.Zero();let R=0,G=0;if(q.hasPositions){const v=q.getPositions(),g=I.getVerticesData(V.f.PositionKind);if(g){const q=new Float32Array(g.length),S=[1/0,1/0,1/0],C=[-1/0,-1/0,-1/0];G=g.length/3,R=0;for(let b=R;b<G;++b){const U=z.yS.Hb(g,3*b);z.yS.Hb(v,3*b).subtractToRef(U,y),y.x*=l,S[0]=Math.min(S[0],y.x),C[0]=Math.max(C[0],y.x),S[1]=Math.min(S[1],y.y),C[1]=Math.max(C[1],y.y),S[2]=Math.min(S[2],y.z),C[2]=Math.max(C[2],y.z),q[3*b]=y.x,q[3*b+1]=y.y,q[3*b+2]=y.z}const I=b.createBufferView(q,12),V=b.createAccessor(I,"VEC3",5126,v.length/3,0,{min:S,max:C});U.push(V),r.attributes.POSITION=U.length-1}else C.Tools.Warn(`Morph target positions for mesh ${S.name} were not exported. Mesh does not have position vertex data`)}if(q.hasNormals){const v=q.getNormals(),g=I.getVerticesData(V.f.NormalKind);if(g){const q=new Float32Array(g.length);G=g.length/3,R=0;for(let b=R;b<G;++b){const S=z.yS.Hb(g,3*b).normalize();z.yS.Hb(v,3*b).normalize().subtractToRef(S,y),q[3*b]=y.x*l,q[3*b+1]=y.y,q[3*b+2]=y.z}const S=b.createBufferView(q,12),C=b.createAccessor(S,"VEC3",5126,v.length/3,0);U.push(C),r.attributes.NORMAL=U.length-1}else C.Tools.Warn(`Morph target normals for mesh ${S.name} were not exported. Mesh does not have normals vertex data`)}if(q.hasTangents){const v=q.getTangents(),g=I.getVerticesData(V.f.TangentKind);if(g){G=g.length/4;const q=new Float32Array(3*G);R=0;for(let b=R;b<G;++b){const S=z.yS.Hb(g,4*b);M(S);const C=z.yS.Hb(v,3*b);M(C),C.subtractToRef(S,y),q[3*b]=y.x*l,q[3*b+1]=y.y,q[3*b+2]=y.z}const S=b.createBufferView(q,12),C=b.createAccessor(S,"VEC3",5126,G,0);U.push(C),r.attributes.TANGENT=U.length-1}else C.Tools.Warn(`Morph target tangents for mesh ${S.name} were not exported. Mesh does not have tangents vertex data`)}if(q.hasColors){const v=q.getColors(),g=I.getVerticesData(V.f.ColorKind),l=I.getVertexBuffer(V.f.ColorKind);if(g&&l){const q=l.getSize();G=g.length/q;const S=new Float32Array(G*q);R=0;for(let b=R;b<G;++b)if(3===q){const C=z.yS.Hb(g,b*q);z.yS.Hb(v,b*q).subtractToRef(C,y),S[3*b]=y.x,S[3*b+1]=y.y,S[3*b+2]=y.z}else if(4===q){const C=new z.Vector4,U=z.Vector4.Hb(g,b*q);z.Vector4.Hb(v,b*q).subtractToRef(U,C),S[4*b]=C.x,S[4*b+1]=C.y,S[4*b+2]=C.z,S[4*b+3]=C.w}else C.Tools.Warn(`Unsupported number of components for color attribute: ${q}`);const I=b.createBufferView(S,4*q),V=b.createAccessor(I,3===q?"VEC3":"VEC4",5126,G,0);U.push(V),r.attributes.COLOR_0=U.length-1}else C.Tools.Warn(`Morph target colors for mesh ${S.name} were not exported. Mesh does not have colors vertex data`)}return r}var Xq=b(11665),Tq=b(11507),Bq=b(11496),tq=b(11058);class fq{}fq.DEFAULT_COLOR=H.HS.White(),fq.DEFAULT_WIDTH_ATTENUATED=1,fq.DEFAULT_WIDTH=.1;var mq=b(11314),Eq=b(11667);class eq{static ConvertPoints(q,S){if(q.length&&Array.isArray(q)&&"number"===typeof q[0])return[q];if(q.length&&Array.isArray(q[0])&&"number"===typeof q[0][0])return q;if(q.length&&!Array.isArray(q[0])&&q[0]instanceof z.yS){const S=[];for(let b=0;b<q.length;b++){const z=q[b];S.push(z.x,z.y,z.z)}return[S]}if(q.length>0&&Array.isArray(q[0])&&q[0].length>0&&q[0][0]instanceof z.yS){const S=[],b=q;for(const q of b)S.push(q.flatMap((q=>[q.x,q.y,q.z])));return S}if(q instanceof Float32Array){if(null!==S&&void 0!==S&&S.floatArrayStride){const b=[],z=3*S.floatArrayStride;for(let S=0;S<q.length;S+=z){const C=new Array(z);for(let b=0;b<z;b++)C[b]=q[S+b];b.push(C)}return b}return[Array.from(q)]}if(q.length&&q[0]instanceof Float32Array){const S=[];for(const b of q)S.push(Array.from(b));return S}return[]}static OmitZeroLengthPredicate(q,S,b){const z=[];return S.RS(q).lengthSquared()>0&&z.push([q,S]),b.RS(S).lengthSquared()>0&&z.push([S,b]),q.RS(b).lengthSquared()>0&&z.push([b,q]),0===z.length?null:z}static OmitDuplicatesPredicate(q,S,b,z){const C=[];return eq._SearchInPoints(q,S,z)||C.push([q,S]),eq._SearchInPoints(S,b,z)||C.push([S,b]),eq._SearchInPoints(b,q,z)||C.push([b,q]),0===C.length?null:C}static _SearchInPoints(q,S,b){for(const U of b)for(let b=0;b<U.length;b++){var z,C,v;if(null!==(z=U[b])&&void 0!==z&&z.equals(q))if(null!==(C=U[b+1])&&void 0!==C&&C.equals(S)||null!==(v=U[b-1])&&void 0!==v&&v.equals(S))return!0}return!1}static MeshesToLines(q,S){const b=[];for(let C=0;C<q.length;C++){const v=q[C],U=v.getVerticesData(V.f.PositionKind),g=v.Xb();if(U&&g)for(let q=0,r=0;q<g.length;q++){const I=3*g[r++],V=3*g[r++],l=3*g[r++],y=new z.yS(U[I],U[I+1],U[I+2]),R=new z.yS(U[V],U[V+1],U[V+2]),G=new z.yS(U[l],U[l+1],U[l+2]);if(S){const z=S(y,R,G,b,q,I,v,C,U,g);if(z)for(const q of z)b.push(q)}else b.push([y,R],[R,G],[G,y])}}return b}static ToVector3Array(q){if(Array.isArray(q[0])){const S=[],b=q;for(const q of b){const b=[];for(let S=0;S<q.length;S+=3)b.push(new z.yS(q[S],q[S+1],q[S+2]));S.push(b)}return S}const S=q,b=[];for(let C=0;C<S.length;C+=3)b.push(new z.yS(S[C],S[C+1],S[C+2]));return b}static ToNumberArray(q){return q.flatMap((q=>[q.x,q.y,q.z]))}static GetPointsCountInfo(q){const S=new Array(q.length);let b=0;for(let z=q.length;z--;)S[z]=q[z].length/3,b+=S[z];return{total:b,counts:S}}static GetLineLength(q){if(0===q.length)return 0;let S;S="number"===typeof q[0]?eq.ToVector3Array(q):q;const b=z.TmpVectors.yS[0];let C=0;for(let z=0;z<S.length-1;z++){const q=S[z];C+=S[z+1].subtractToRef(q,b).length()}return C}static GetLineLengthArray(q){const S=new Float32Array(q.length/3);let b=0;for(let z=0,C=q.length/3-1;z<C;z++){let C=q[3*z+0],v=q[3*z+1],U=q[3*z+2];C-=q[3*z+3],v-=q[3*z+4],U-=q[3*z+5];b+=Math.sqrt(C*C+v*v+U*U),S[z+1]=b}return S}static SegmentizeSegmentByCount(q,S,b){const C=[],v=S.RS(q),U=z.TmpVectors.yS[0];U.fb(b);const g=z.TmpVectors.yS[1];v.divideToRef(U,g);let r=q.clone();C.push(r);for(let z=0;z<b;z++)r=r.clone(),C.push(r.addInPlace(g));return C}static SegmentizeLineBySegmentLength(q,S){const b=q[0]instanceof z.yS?eq.GetLineSegments(q):"number"===typeof q[0]?eq.GetLineSegments(eq.ToVector3Array(q)):q,C=[];for(const z of b)if(z.length>S){const q=eq.SegmentizeSegmentByCount(z.point1,z.point2,Math.ceil(z.length/S));for(const S of q)C.push(S)}else C.push(z.point1),C.push(z.point2);return C}static SegmentizeLineBySegmentCount(q,S){const b="number"===typeof q[0]?eq.ToVector3Array(q):q,z=eq.GetLineLength(b)/S;return eq.SegmentizeLineBySegmentLength(b,z)}static GetLineSegments(q){const S=[];for(let b=0;b<q.length-1;b++){const z=q[b],C=q[b+1],v=C.RS(z).length();S.push({point1:z,point2:C,length:v})}return S}static GetMinMaxSegmentLength(q){const S=eq.GetLineSegments(q).sort((q=>q.length));return{min:S[0].length,max:S[S.length-1].length}}static GetPositionOnLineByVisibility(q,S,b){let C=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const v=S*b;let U=0,g=0;const r=q.length;for(let z=0;z<r;z++){if(v<=U+q[z].length){g=z;break}U+=q[z].length}const I=(v-U)/q[g].length;return q[g].point2.subtractToRef(q[g].point1,z.TmpVectors.yS[0]),z.TmpVectors.yS[1]=z.TmpVectors.yS[0].multiplyByFloats(I,I,I),C||z.TmpVectors.yS[1].addInPlace(q[g].point1),z.TmpVectors.yS[1].clone()}static GetCircleLinePoints(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,C=arguments.length>3&&void 0!==arguments[3]?arguments[3]:q,v=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/S;const U=[];for(let g=0;g<=S;g++)U.push(new z.yS(Math.cos(g*v)*q,Math.sin(g*v)*C,b));return U}static GetBezierLinePoints(q,S,b,z){return mq.f.CreateQuadraticBezier(q,S,b,z).getPoints().flatMap((q=>[q.x,q.y,q.z]))}static GetArrowCap(q,S,b,z,C){let v=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,U=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[q.clone(),q.add(S.multiplyByFloats(b,b,b))],widths:[z,C,v,U]}}static GetPointsFromText(q,S,b,z){let C=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,v=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const U=[],g=(0,Eq.e)(q,S,b,z);for(const r of g){for(const q of r.paths){const S=[],b=q.getPoints();for(const q of b)S.push(q.x,q.y,C);U.push(S)}if(v)for(const q of r.holes){const S=[],b=q.getPoints();for(const q of b)S.push(q.x,q.y,C);U.push(S)}}return U}static Color3toRGBAUint8(q){const S=new Uint8Array(4*q.length);for(let b=0,z=0;b<q.length;b++)S[z++]=255*q[b].r,S[z++]=255*q[b].g,S[z++]=255*q[b].b,S[z++]=255;return S}static CreateColorsTexture(q,S,b,z){const C=z.getEngine().getCaps().maxTextureSize??1,v=S.length>C?C:S.length,U=Math.ceil(S.length/C);U>1&&(S=[...S,...Array(v*U-S.length).fill(S[0])]);const g=eq.Color3toRGBAUint8(S),r=new X.c(g,v,U,G.e.TEXTUREFORMAT_RGBA,z,!1,!0,b);return r.name=q,r}static PrepareEmptyColorsTexture(q){if(!fq.EmptyColorsTexture){const S=new Uint8Array(4);fq.EmptyColorsTexture=new X.c(S,1,1,G.e.TEXTUREFORMAT_RGBA,q,!1,!1,X.c.NEAREST_NEAREST),fq.EmptyColorsTexture.name="grlEmptyColorsTexture"}return fq.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var q;null===(q=fq.EmptyColorsTexture)||void 0===q||q.dispose(),fq.EmptyColorsTexture=null}static BooleanToNumber(q){return q?1:0}}class iq extends Bq.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Jq extends Tq.c{isCompatible(q){return!0}constructor(q,S,b){var C;b=b||{color:fq.DEFAULT_COLOR};const v=new iq;v.GREASED_LINE_HAS_COLOR=!!b.color&&!b.useColors,v.GREASED_LINE_SIZE_ATTENUATION=b.sizeAttenuation??!1,v.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===b.colorDistributionType,v.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(S??q.Tq()).useRightHandedSystem,v.GREASED_LINE_CAMERA_FACING=b.cameraFacing??!0,super(q,Jq.GREASED_LINE_MATERIAL_NAME,200,v,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(C=b)||void 0===C?void 0:C.forceGLSL)||Jq.ForceGLSL,this._scene=S??q.Tq(),this._engine=this._scene.getEngine(),this._cameraFacing=b.cameraFacing??!0,this.visibility=b.visibility??1,this.useDash=b.useDash??!1,this.dashRatio=b.dashRatio??.5,this.dashOffset=b.dashOffset??0,this.width=b.width?b.width:b.sizeAttenuation?fq.DEFAULT_WIDTH_ATTENUATED:fq.DEFAULT_WIDTH,this._sizeAttenuation=b.sizeAttenuation??!1,this.colorMode=b.colorMode??0,this._color=b.color??null,this.useColors=b.useColors??!1,this._colorsDistributionType=b.colorDistributionType??0,this.colorsSampling=b.colorsSampling??X.c.NEAREST_NEAREST,this._colors=b.mq??null,this.dashCount=b.dashCount??1,this.resolution=b.resolution??new z.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),b.colorsTexture?this.colorsTexture=b.colorsTexture:this._colors?this.colorsTexture=eq.CreateColorsTexture(`${q.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??fq.DEFAULT_COLOR,eq.PrepareEmptyColorsTexture(this._scene)),this._engine.gb.add((()=>{eq.DisposeEmptyColorsTexture()}))}getAttributes(q){q.push("grl_offsets"),q.push("grl_widths"),q.push("grl_colorPointers"),q.push("grl_counters"),this._cameraFacing?(q.push("grl_previousAndSide"),q.push("grl_nextAndCounters")):q.push("grl_slopes")}getSamplers(q){q.push("grl_colors")}getActiveTextures(q){this.colorsTexture&&q.push(this.colorsTexture)}getUniforms(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const S=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&S.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===q&&S.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:S,vertex:this._cameraFacing&&this._isGLSL(q)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(q)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(q){if(this._cameraFacing){q.Wb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||q.Wb("viewProjection",this._scene.getTransformMatrix());const S=z.TmpVectors.Vector4[0];S.x=this._aspect,S.y=this._resolution.x,S.z=this._resolution.y,S.w=this.width,q.updateVector4("grl_aspect_resolution_lineWidth",S)}const S=z.TmpVectors.Vector4[0];S.x=eq.BooleanToNumber(this.useDash),S.y=this._dashArray,S.z=this.dashOffset,S.w=this.dashRatio,q.updateVector4("grl_dashOptions",S);const b=z.TmpVectors.Vector4[1];b.x=this.colorMode,b.y=this.visibility,b.z=this.colorsTexture?this.colorsTexture.getSize().width:0,b.w=eq.BooleanToNumber(this.useColors),q.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",b),this._color&&q.updateColor3("grl_singleColor",this._color);const C=this.colorsTexture??fq.EmptyColorsTexture;q.setTexture("grl_colors",C),q.updateFloat2("grl_textureSize",(null===C||void 0===C?void 0:C.getSize().width)??1,(null===C||void 0===C?void 0:C.getSize().height)??1)}prepareDefines(q,S,b){q.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,q.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,q.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,q.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=S.useRightHandedSystem,q.GREASED_LINE_CAMERA_FACING=this._cameraFacing,q.GREASED_LINE_USE_OFFSETS=!!b.offsets}getClassName(){return Jq.GREASED_LINE_MATERIAL_NAME}getCustomCode(q){let S=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(S)?function(q,S){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return S&&(q["!gl_Position\\=viewProjection\\*worldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(q,this._cameraFacing):function(q,S){if("vertex"===q){const q={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return S&&(q["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),q}return"fragment"===q?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(q,this._cameraFacing)}dispose(){var q;null===(q=this.colorsTexture)||void 0===q||q.dispose(),super.dispose()}get mq(){return this._colors}set mq(q){this.setColors(q)}setColors(q){var S;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const C=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var v;if(this._colors=q,null!==q&&0!==q.length){if(!b||z)if(this.colorsTexture&&C===q.length&&!z){const S=eq.Color3toRGBAUint8(q);this.colorsTexture.update(S)}else{var U;null===(U=this.colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=eq.CreateColorsTexture(`${this._material.name}-colors-texture`,q,this.colorsSampling,this._scene)}}else null===(v=this.colorsTexture)||void 0===v||v.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.markAllDefinesAsDirty()}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==q||null!==this._color&&null===q?(this._color=q,S||this.markAllDefinesAsDirty()):this._color=q}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(q){this._aspect=q.x/q.y,this._resolution=q}serialize(){const q=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(S.mq=this._colors),this._color&&(S.color=this._color),q.greasedLineMaterialOptions=S,q}parse(q,S,b){var z;super.parse(q,S,b);const C=q.greasedLineMaterialOptions;null===(z=this.colorsTexture)||void 0===z||z.dispose(),C.color&&this.setColor(C.color,!0),C.colorDistributionType&&(this.colorsDistributionType=C.colorDistributionType),C.mq&&(this.mq=C.mq),C.colorsSampling&&(this.colorsSampling=C.colorsSampling),C.colorMode&&(this.colorMode=C.colorMode),C.useColors&&(this.useColors=C.useColors),C.visibility&&(this.visibility=C.visibility),C.useDash&&(this.useDash=C.useDash),C.dashCount&&(this.dashCount=C.dashCount),C.dashRatio&&(this.dashRatio=C.dashRatio),C.dashOffset&&(this.dashOffset=C.dashOffset),C.width&&(this.width=C.width),C.sizeAttenuation&&(this.sizeAttenuation=C.sizeAttenuation),C.resolution&&(this.resolution=C.resolution),this.mq?this.colorsTexture=eq.CreateColorsTexture(`${this._material.name}-colors-texture`,this.mq,this.colorsSampling,S):eq.PrepareEmptyColorsTexture(S),this.markAllDefinesAsDirty()}copyTo(q){var S;const b=q;null===(S=b.colorsTexture)||void 0===S||S.dispose(),this._colors&&(b.colorsTexture=eq.CreateColorsTexture(`${b._material.name}-colors-texture`,this._colors,b.colorsSampling,this._scene)),b.setColor(this.color,!0),b.colorsDistributionType=this.colorsDistributionType,b.colorsSampling=this.colorsSampling,b.colorMode=this.colorMode,b.useColors=this.useColors,b.visibility=this.visibility,b.useDash=this.useDash,b.dashCount=this.dashCount,b.dashRatio=this.dashRatio,b.dashOffset=this.dashOffset,b.width=this.width,b.sizeAttenuation=this.sizeAttenuation,b.resolution=this.resolution,b.markAllDefinesAsDirty()}_isGLSL(q){return 0===q||this._forceGLSL}}Jq.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Jq.ForceGLSL=!1,(0,tq.f)(`BABYLON.${Jq.GREASED_LINE_MATERIAL_NAME}`,Jq);var Lq=b(11535),dq=b(10948),Kq=b(11336),Dq=b(11039);class xq extends Kq.ShaderMaterial{constructor(q,S,C){const v=S.getEngine(),U=v.isWebGPU&&!(C.forceGLSL||xq.ForceGLSL),g=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];S.useRightHandedSystem&&g.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const r=["position","grl_widths","grl_offsets","grl_colorPointers"];C.cameraFacing?(g.push("GREASED_LINE_CAMERA_FACING"),r.push("grl_previousAndSide","grl_nextAndCounters")):(r.push("grl_slopes"),r.push("grl_counters"));const I=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(U||I.push("world","viewProjection","view","projection"),super(q,S,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:U?["Scene","Mesh"]:void 0,attributes:r,uniforms:I,samplers:U?[]:["grlColors"],defines:g,extraInitializationsAsync:async()=>{U?await Promise.all([b.e(66).then(b.bind(b,14255)),b.e(75).then(b.bind(b,14259))]):await Promise.all([b.e(69).then(b.bind(b,14263)),b.e(76).then(b.bind(b,14267))])},shaderLanguage:U?1:0}),this._color=H.HS.White(),this._colorsDistributionType=0,this._colorsTexture=null,C=C||{color:fq.DEFAULT_COLOR},this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.dashCount=C.dashCount??1,this.width=C.width?C.width:C.sizeAttenuation&&C.cameraFacing?fq.DEFAULT_WIDTH_ATTENUATED:fq.DEFAULT_WIDTH,this.sizeAttenuation=C.sizeAttenuation??!1,this.color=C.color??H.HS.White(),this.useColors=C.useColors??!1,this.colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??X.c.NEAREST_NEAREST,this.colorMode=C.colorMode??0,this._colors=C.mq??null,this._cameraFacing=C.cameraFacing??!0,this.resolution=C.resolution??new z.Vector2(v.getRenderWidth(),v.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=eq.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,S):(this._color=this._color??fq.DEFAULT_COLOR,this.colorsTexture=eq.PrepareEmptyColorsTexture(S)),U){const q=new Dq.b;q.setParameters(),q.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",q)}v.gb.add((()=>{eq.DisposeEmptyColorsTexture()}))}dispose(){var q;null===(q=this._colorsTexture)||void 0===q||q.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new z.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get mq(){return this._colors}set mq(q){this.setColors(q)}setColors(q){var S;let b=arguments.length>1&&void 0!==arguments[1]&&arguments[1],z=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const C=(null===(S=this._colors)||void 0===S?void 0:S.length)??0;var v;if(this._colors=q,null!==q&&0!==q.length){if(!b||z)if(this._colorsTexture&&C===q.length&&!z){const S=eq.Color3toRGBAUint8(q);this._colorsTexture.update(S)}else{var U;null===(U=this._colorsTexture)||void 0===U||U.dispose(),this.colorsTexture=eq.CreateColorsTexture(`${this.name}-colors-texture`,q,this.colorsSampling,this.Tq())}}else null===(v=this._colorsTexture)||void 0===v||v.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(q){this._colorsTexture=q,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(q){this._width=q,this.setFloat("grlWidth",q)}get useColors(){return this._useColors}set useColors(q){this._useColors=q,this.setFloat("grlUseColors",eq.BooleanToNumber(q))}get colorsSampling(){return this._colorsSampling}set colorsSampling(q){this._colorsSampling=q}get visibility(){return this._visibility}set visibility(q){this._visibility=q,this.setFloat("grlVisibility",q)}get useDash(){return this._useDash}set useDash(q){this._useDash=q,this.setFloat("grlUseDash",eq.BooleanToNumber(q))}get dashOffset(){return this._dashOffset}set dashOffset(q){this._dashOffset=q,this.setFloat("grlDashOffset",q)}get dashRatio(){return this._dashRatio}set dashRatio(q){this._dashRatio=q,this.setFloat("grlDashRatio",q)}get dashCount(){return this._dashCount}set dashCount(q){this._dashCount=q,this._dashArray=1/q,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(q){this._sizeAttenuation=q,this.setFloat("grlSizeAttenuation",eq.BooleanToNumber(q))}get color(){return this._color}set color(q){this.setColor(q)}setColor(q){q=q??fq.DEFAULT_COLOR,this._color=q,this.setColor3("grlColor",q)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(q){this._colorsDistributionType=q,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(q){this._colorMode=q,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(q){this._resolution=q,this.setVector2("grlResolution",q),this.setFloat("grlAspect",q.x/q.y)}serialize(){const q=super.serialize(),S={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(S.mq=this._colors),q.greasedLineMaterialOptions=S,q}parse(q,S,b){var z;const C=q.greasedLineMaterialOptions;null===(z=this._colorsTexture)||void 0===z||z.dispose(),C.color&&(this.color=C.color),C.colorDistributionType&&(this.colorsDistributionType=C.colorDistributionType),C.colorsSampling&&(this.colorsSampling=C.colorsSampling),C.colorMode&&(this.colorMode=C.colorMode),C.useColors&&(this.useColors=C.useColors),C.visibility&&(this.visibility=C.visibility),C.useDash&&(this.useDash=C.useDash),C.dashCount&&(this.dashCount=C.dashCount),C.dashRatio&&(this.dashRatio=C.dashRatio),C.dashOffset&&(this.dashOffset=C.dashOffset),C.width&&(this.width=C.width),C.sizeAttenuation&&(this.sizeAttenuation=C.sizeAttenuation),C.resolution&&(this.resolution=C.resolution),C.mq?this.colorsTexture=eq.CreateColorsTexture(`${this.name}-colors-texture`,C.mq,this.colorsSampling,this.Tq()):this.colorsTexture=eq.PrepareEmptyColorsTexture(S),this._cameraFacing=C.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var Fq,aq,nq;xq.ForceGLSL=!1,function(q){q[q.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",q[q.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(Fq||(Fq={})),function(q){q[q.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",q[q.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",q[q.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(aq||(aq={})),function(q){q[q.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",q[q.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",q[q.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",q[q.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",q[q.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(nq||(nq={}));class oq extends kq.d{constructor(q,S,b){super(q,S,null,null,!1,!1),this.name=q,this._options=b,this._lazy=!1,this._updatable=!1,this._engine=S.getEngine(),this._lazy=b.lazy??!1,this._updatable=b.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=b.colorPointers??[],this._widths=b.widths??new Array(b.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(q){let S=0;for(const z of this._points)S+=z.length;const b=S/3*2-this._widths.length;for(let z=0;z<b;z++)this._widths.push(q)}updateLazy(){var q,S;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(q=this._options.ribbonOptions)||void 0===q?void 0:q.smoothShading),!this.Jq&&this.refreshBoundingInfo(),null===(S=this.greasedLineMaterial)||void 0===S||S.updateLazy()}addPoints(q,S){for(const b of q)this._points.push(b);this._lazy||this.setPoints(this._points,S)}dispose(q){let S=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(q,S)}isLazy(){return this._lazy}get Eq(){return this._uvs}set Eq(q){this._uvs=q instanceof Float32Array?q:new Float32Array(q),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(q){this.material instanceof xq&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===q||void 0===q?void 0:q.length)>0),this._offsets=q,this._offsetsBuffer?this._offsetsBuffer.update(q):this._createOffsetsBuffer(q)}get widths(){return this._widths}set widths(q){this._widths=q,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(q)}get colorPointers(){return this._colorPointers}set colorPointers(q){this._colorPointers=q,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(q)}get greasedLineMaterial(){var q,S;if(this.material&&this.material instanceof xq)return this.material;const b=null===(q=this.material)||void 0===q||null===(S=q.pluginManager)||void 0===S?void 0:S.getPlugin(Jq.GREASED_LINE_MATERIAL_NAME);return b||void 0}get points(){const q=[];return dq.d.DeepCopy(this._points,q),q}setPoints(q,S){this._points=eq.ConvertPoints(q,(null===S||void 0===S?void 0:S.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==S&&void 0!==S&&S.colorPointers||this._updateColorPointers(),this._setPoints(this._points,S)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,Eq:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(q){super.serialize(q),q.type=this.getClassName(),q.lineOptions=this._createLineOptions()}_createVertexBuffers(){let q=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const S=new Lq.c;return S.tq=this._vertexPositions,S.indices=this._indices,S.Eq=this._uvs,q&&(S.fq=[],Lq.c.ComputeNormals(this._vertexPositions,this._indices,S.fq)),S.iq(this,this._options.updatable),S}_createOffsetsBuffer(q){const S=this._scene.getEngine(),b=new V.b(S,q,this._updatable,3);this.setVerticesBuffer(b.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=b}}class sq{constructor(q,S){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=q,this.wasAddedByNoopNode=S}getIndicesAccessor(q,S,b,z,C){var v,U,g,r;return null===(v=this._indicesAccessorMap.get(q))||void 0===v||null===(U=v.get(S))||void 0===U||null===(g=U.get(b))||void 0===g||null===(r=g.get(z))||void 0===r?void 0:r.get(C)}setIndicesAccessor(q,S,b,z,C,v){let U=this._indicesAccessorMap.get(q);U||(U=new Map,this._indicesAccessorMap.set(q,U));let g=U.get(S);g||(g=new Map,U.set(S,g));let r=g.get(b);r||(r=new Map,g.set(b,r));let I=r.get(z);I||(I=new Map,r.set(z,I)),I.set(C,v)}pushExportedNode(q){this._exportedNodes.has(q)||this._exportedNodes.add(q)}getNodesSet(){return this._exportedNodes}getVertexBufferView(q){return this._vertexBufferViewMap.get(q)}setVertexBufferView(q,S){this._vertexBufferViewMap.set(q,S)}setRemappedBufferView(q,S,b){this._remappedBufferView.set(q,new Map),this._remappedBufferView.get(q).set(S,b)}getRemappedBufferView(q,S){var b;return null===(b=this._remappedBufferView.get(q))||void 0===b?void 0:b.get(S)}getVertexAccessor(q,S,b){var z,C;return null===(z=this._vertexAccessorMap.get(q))||void 0===z||null===(C=z.get(S))||void 0===C?void 0:C.get(b)}setVertexAccessor(q,S,b,z){let C=this._vertexAccessorMap.get(q);C||(C=new Map,this._vertexAccessorMap.set(q,C));let v=C.get(S);v||(v=new Map,C.set(S,v)),v.set(b,z)}hasVertexColorAlpha(q){return this._vertexMapColorAlpha.get(q)||!1}setHasVertexColorAlpha(q,S){return this._vertexMapColorAlpha.set(q,S)}getMesh(q){return this._meshMap.get(q)}setMesh(q,S){this._meshMap.set(q,S)}bindMorphDataToMesh(q,S){const b=this._meshMorphTargetMap.get(q)||[];this._meshMorphTargetMap.set(q,b),-1===b.indexOf(S)&&b.push(S)}getMorphTargetsFromMesh(q){return this._meshMorphTargetMap.get(q)}}class Aq{_ApplyExtension(q,S,b,z){if(b>=S.length)return Promise.resolve(q);const C=z(S[b],q);return C?C.then((async q=>q?await this._ApplyExtension(q,S,b+1,z):null)):this._ApplyExtension(q,S,b+1,z)}_ApplyExtensions(q,S){const b=[];for(const z of Aq._ExtensionNames)b.push(this._extensions[z]);return this._ApplyExtension(q,b,0,S)}_extensionsPreExportTextureAsync(q,S,b){return this._ApplyExtensions(S,((S,z)=>S.preExportTextureAsync&&S.preExportTextureAsync(q,z,b)))}_extensionsPostExportNodeAsync(q,S,b,z,C){return this._ApplyExtensions(S,((S,v)=>S.postExportNodeAsync&&S.postExportNodeAsync(q,v,b,z,C,this._bufferManager)))}_extensionsPostExportMaterialAsync(q,S,b){return this._ApplyExtensions(S,((S,z)=>S.postExportMaterialAsync&&S.postExportMaterialAsync(q,z,b)))}_extensionsPostExportMaterialAdditionalTextures(q,S,b){const z=[];for(const C of Aq._ExtensionNames){const v=this._extensions[C];v.postExportMaterialAdditionalTextures&&z.push(...v.postExportMaterialAdditionalTextures(q,S,b))}return z}_extensionsPostExportTextures(q,S,b){for(const z of Aq._ExtensionNames){const C=this._extensions[z];C.postExportTexture&&C.postExportTexture(q,S,b)}}_extensionsPostExportMeshPrimitive(q){for(const S of Aq._ExtensionNames){const b=this._extensions[S];b.postExportMeshPrimitive&&b.postExportMeshPrimitive(q,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const q of Aq._ExtensionNames){const S=this._extensions[q];S.preGenerateBinaryAsync&&await S.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(q){for(const S of Aq._ExtensionNames){const b=this._extensions[S];b.enabled&&q(b)}}_extensionsOnExporting(){this._forEachExtensions((q=>{var S,b,z;q.wasUsed&&((S=this._glTF).extensionsUsed||(S.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(q.name)&&this._glTF.extensionsUsed.push(q.name),q.required&&((b=this._glTF).extensionsRequired||(b.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(q.name)&&this._glTF.extensionsRequired.push(q.name)),(z=this._glTF).extensions||(z.extensions={}),q.onExporting&&q.onExporting())}))}_loadExtensions(){for(const q of Aq._ExtensionNames){const S=Aq._ExtensionFactories[q](this);this._extensions[q]=S}}constructor(){let q=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Z.b.LastCreatedScene,S=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${G.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new D(this),this._extensions={},this._bufferManager=new Vq,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!q)throw new Error("No scene available to export");this._babylonScene=q,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:q=>{var S;return null===q||void 0===q||null===(S=q.lb)||void 0===S?void 0:S.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...S},this._loadExtensions()}dispose(){for(const q in this._extensions){this._extensions[q].dispose()}}get options(){return this._options}static RegisterExtension(q,S){Aq.UnregisterExtension(q)&&C.Tools.Warn(`Extension with the name ${q} already exists`),Aq._ExtensionFactories[q]=S,Aq._ExtensionNames.push(q)}static UnregisterExtension(q){if(!Aq._ExtensionFactories[q])return!1;delete Aq._ExtensionFactories[q];const S=Aq._ExtensionNames.indexOf(q);return-1!==S&&Aq._ExtensionNames.splice(S,1),!0}_generateJSON(q,S,b){const z={byteLength:q};return z.byteLength&&(this._glTF.buffers=[z]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.GS=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(z.uri=S+".bin"),b?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(q){const S=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(S.byteLength,q,!0),z=new Blob([S],{type:"application/octet-stream"}),C=q+".gltf",v=q+".bin",U=new I;if(U.files[C]=b,U.files[v]=z,this._imageData)for(const g in this._imageData)U.files[g]=new Blob([this._imageData[g].data],{type:this._imageData[g].mimeType});return U}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(q){const S=q%4;return 0===S?S:4-S}async generateGLBAsync(q){this._shouldUseGlb=!0;const S=await this._generateBinaryAsync();this._extensionsOnExporting();const b=this._generateJSON(S.byteLength),z=q+".glb";let C,v=b.length;if("undefined"!==typeof TextEncoder){C=(new TextEncoder).encode(b),v=C.length}const U=this._getPadding(v),g=this._getPadding(S.byteLength),r=28+v+U+S.byteLength+g,V=new rq(r);if(V.writeUInt32(1179937895),V.writeUInt32(2),V.writeUInt32(r),V.writeUInt32(v+U),V.writeUInt32(1313821514),C)V.writeTypedArray(C);else{const q="_".charCodeAt(0);for(let S=0;S<v;++S){const z=b.charCodeAt(S);z!=b.codePointAt(S)?V.writeUInt8(q):V.writeUInt8(z)}}for(let I=0;I<U;++I)V.writeUInt8(32);V.writeUInt32(S.byteLength+g),V.writeUInt32(5130562),V.writeTypedArray(S);for(let I=0;I<g;++I)V.writeUInt8(0);const l=new I;return l.files[z]=new Blob([V.getOutputData()],{type:"application/octet-stream"}),l}_setNodeTransformation(q,S,b){if(S.getPivotPoint().equalsWithEpsilon(o,n.d)||C.Tools.Warn("Pivot points are not supported in the glTF serializer"),!S.position.equalsWithEpsilon(o,n.d)){const C=z.TmpVectors.yS[0].v(S.position);b&&p(C),q.translation=C.Zb()}S.tb.equalsWithEpsilon(A,n.d)||(q.scale=S.tb.Zb());const v=S.rotationQuaternion||z.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);v.equalsWithEpsilon(s,n.d)||(b&&Y(v),q.rotation=v.normalize().Zb())}_setCameraTransformation(q,S,b){if(!S.position.equalsWithEpsilon(o,n.d)){const C=z.TmpVectors.yS[0].v(S.position);b&&p(C),q.translation=C.Zb()}const C=S.rotationQuaternion||z.Quaternion.FromEulerAngles(S.rotation.x,S.rotation.y,S.rotation.z);b&&Y(C),this._babylonScene.useRightHandedSystem||c(C),C.equalsWithEpsilon(s,n.d)||(q.rotation=C.Zb())}_listAvailableCameras(){for(const q of this._babylonScene.cameras){const S={type:q.mode===yq.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(q.name&&(S.name=q.name),"perspective"===S.type)S.perspective={aspectRatio:q.getEngine().getAspectRatio(q),yfov:q.fovMode===yq.c.FOVMODE_VERTICAL_FIXED?q.fov:q.fov*q.getEngine().getAspectRatio(q),znear:q.kb,zfar:q.maxZ};else if("orthographic"===S.type){const b=q.orthoLeft&&q.orthoRight?.5*(q.orthoRight-q.orthoLeft):.5*q.getEngine().getRenderWidth(),z=q.orthoBottom&&q.orthoTop?.5*(q.orthoTop-q.orthoBottom):.5*q.getEngine().getRenderHeight();S.orthographic={xmag:b,ymag:z,znear:q.kb,zfar:q.maxZ}}this._camerasMap.set(q,S)}}_exportAndAssignCameras(){const q=Array.from(this._camerasMap.values());for(const S of q){const q=this._nodesCameraMap.get(S);if(void 0!==q){this._cameras.push(S);for(const S of q)S.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const S={joints:[]};this._skinMap.set(q,S)}}_exportAndAssignSkeletons(){for(const q of this._babylonScene.skeletons){if(q.bones.length<=0)continue;const S=this._skinMap.get(q);if(void 0==S)continue;const b={},z=[];let v=-1;for(let C=0;C<q.bones.length;++C){const S=q.bones[C],z=S.getIndex()??C;-1!==z&&(b[z]=S,z>v&&(v=z))}for(let q=0;q<=v;++q){const v=b[q];z.push(v.getAbsoluteInverseBindMatrix());const U=v.getTransformNode();if(null!==U){const q=this._nodeMap.get(U);U&&null!==q&&void 0!==q?S.joints.push(q):C.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else C.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const U=this._nodesSkinMap.get(S);if(S.joints.length>0&&void 0!==U){const q=64*z.length,b=new Float32Array(q/4);z.forEach(((q,S)=>{b.set(q.m,16*S)}));const C=this._bufferManager.createBufferView(b);this._accessors.push(this._bufferManager.createAccessor(C,"MAT4",5126,z.length)),S.inverseBindMatrices=this._accessors.length-1,this._skins.push(S);for(const S of U)S.skin=this._skins.length-1}}}async _exportSceneAsync(){const q={nodes:[]};if(this._babylonScene.metadata){const S=this._options.metadataSelector(this._babylonScene.metadata);S&&(q.extras=S)}const S=new Array,b=new Array,z=new Array;for(const g of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&Uq(g,this._babylonScene.useRightHandedSystem)?z.push(...g.getChildren()):this._babylonScene.useRightHandedSystem?S.push(g):b.push(g);this._listAvailableCameras(),this._listAvailableSkeletons();const C=new sq(!0,!1);q.nodes.push(...await this._exportNodesAsync(b,C));const v=new sq(!1,!1);q.nodes.push(...await this._exportNodesAsync(S,v));const U=new sq(!1,!0);q.nodes.push(...await this._exportNodesAsync(z,U)),q.nodes.length&&this._scenes.push(q),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Nq._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(q){let S=this._shouldExportNodeMap.get(q);return void 0===S&&(S=this._options.shouldExportNode(q),this._shouldExportNodeMap.set(q,S)),S}async _exportNodesAsync(q,S){const b=new Array;this._exportBuffers(q,S);for(const z of q)await this._exportNodeAsync(z,b,S);return b}_collectBuffers(q,S,b,z,C){if(this._shouldExportNode(q)&&q instanceof y.c&&q.ub){const v=q.ub.getVertexBuffers();if(v)for(const z in v){if(!O(z))continue;const U=v[z];C.setHasVertexColorAlpha(U,q.hasVertexAlpha);const g=U._buffer,r=S.get(g)||[];S.set(g,r),-1===r.indexOf(U)&&r.push(U);const I=b.get(U)||[];b.set(U,I),-1===I.indexOf(q)&&I.push(q)}const U=q.morphTargetManager;if(U)for(let S=0;S<U.numTargets;S++){const b=U.getTarget(S),C=z.get(b)||[];z.set(b,C),-1===C.indexOf(q)&&C.push(q)}}for(const v of q.getChildren())this._collectBuffers(v,S,b,z,C)}_exportBuffers(q,S){const b=new Map,z=new Map,C=new Map;for(const g of q)this._collectBuffers(g,b,z,C,S);const v=Array.from(b.keys());for(const g of v){const q=g.getData();if(!q)throw new Error("Buffer data is not available");const C=b.get(g);if(!C)continue;const v=C[0].byteStride;if(C.some((q=>q.byteStride!==v)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const U=bq(q).slice();for(const S of C){const q=z.get(S),{byteOffset:b,byteStride:C,componentCount:v,type:g,count:r,normalized:I,kind:l}=P(S,q);switch(l){case V.f.NormalKind:case V.f.TangentKind:(0,x.h)(U,b,C,v,g,r,I,(q=>{const S=Math.sqrt(q[0]*q[0]+q[1]*q[1]+q[2]*q[2]);if(S>0){const b=1/S;q[0]*=b,q[1]*=b,q[2]*=b}}));break;case V.f.ColorKind:{const S=q.filter((q=>q.material instanceof Zq.ZS||null==q.material)).length;if(0==S)break;if(S!=q.length){F.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}g==V.f.UNSIGNED_BYTE&&F.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const z=new H.HS,l=new H.b,y=this._babylonScene.getEngine().useExactSrgbConversions;(0,x.h)(U,b,C,v,g,r,I,(q=>{3===q.length?(z.Uz(q,0),z.toLinearSpaceToRef(z,y),z.toArray(q,0)):(l.Uz(q,0),l.toLinearSpaceToRef(l,y),l.toArray(q,0))}))}}}if(S.convertToRightHanded){for(const q of C){const S=z.get(q),{byteOffset:b,byteStride:C,componentCount:v,type:g,count:r,normalized:I,kind:l}=P(q,S);switch(l){case V.f.PositionKind:case V.f.NormalKind:case V.f.TangentKind:(0,x.h)(U,b,C,v,g,r,I,(q=>{q[0]=-q[0]}))}}S.convertedToRightHandedBuffers.set(g,U)}const r=this._bufferManager.createBufferView(U,v);S.setVertexBufferView(g,r);const I=new Map;for(const S of C){const q=z.get(S),{kind:b,totalVertices:C}=P(S,q);switch(b){case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:if(S.type==V.f.FLOAT){const q=S.getFloatData(C);null!==q&&I.set(S,q)}}}0!==I.size&&F.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const l=Array.from(I.keys());for(const b of l){const q=I.get(b);if(!q)continue;const z=q.some((q=>q>=256)),C=new(z?Uint16Array:Uint8Array)(q.length);for(let S=0;S<q.length;S++)C[S]=q[S];const v=this._bufferManager.createBufferView(C,4*(z?2:1));S.setRemappedBufferView(g,b,v)}}const U=Array.from(C.keys());for(const g of U){const q=C.get(g);if(!q)continue;const b=uq(g,q[0],this._bufferManager,this._bufferViews,this._accessors,S.convertToRightHanded);for(const z of q)S.bindMorphDataToMesh(z,b)}}async _exportNodeAsync(q,S,b){let z=this._nodeMap.get(q);if(void 0!==z)return void(S.includes(z)||S.push(z));const C=await this._createNodeAsync(q,b);if(C){z=this._nodes.length,this._nodes.push(C),this._nodeMap.set(q,z),b.pushExportedNode(q),S.push(z);const v={name:"runtime animations",channels:[],samplers:[]},U=[];this._babylonScene.animationGroups.length||(Nq._CreateMorphTargetAnimationFromMorphTargetAnimations(q,v,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation),q.animations.length&&Nq._CreateNodeAnimationFromNodeAnimations(q,v,U,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,b.convertToRightHanded,this._options.shouldExportAnimation)),v.channels.length&&v.samplers.length&&this._animations.push(v),U.forEach((q=>{q.channels.length&&q.samplers.length&&this._animations.push(q)}))}const v=C?[]:S;for(const U of q.getChildren())await this._exportNodeAsync(U,v,b);C&&v.length&&(C.children=v)}async _createNodeAsync(q,S){if(!this._shouldExportNode(q))return null;const b={};if(q.name&&(b.name=q.name),q.metadata){const S=this._options.metadataSelector(q.metadata);S&&(b.extras=S)}if(q instanceof l.e&&(this._setNodeTransformation(b,q,S.convertToRightHanded),q instanceof y.c)){const C=q instanceof R.d?q.sourceMesh:q;if(C.Gb&&C.Gb.length>0&&(b.mesh=await this._exportMeshAsync(C,S)),q.skeleton){const S=this._skinMap.get(q.skeleton);var z;if(void 0!==S)void 0===this._nodesSkinMap.get(S)&&this._nodesSkinMap.set(S,[]),null===(z=this._nodesSkinMap.get(S))||void 0===z||z.push(b)}}if(q instanceof a.d){const z=this._camerasMap.get(q);if(z){var C;void 0===this._nodesCameraMap.get(z)&&this._nodesCameraMap.set(z,[]),this._setCameraTransformation(b,q,S.convertToRightHanded);const U=q.parent;if(null!==U&&Sq(q,U)){const q=this._nodeMap.get(U);if(void 0!==q){var v;const S=this._nodes[q];return qq(b,S),null===(v=this._nodesCameraMap.get(z))||void 0===v||v.push(S),null}}null===(C=this._nodesCameraMap.get(z))||void 0===C||C.push(b)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",b,q,this._nodeMap,S.convertToRightHanded)?b:(F.b.Warn(`Not exporting node ${q.name}`),null)}_exportIndices(q,S,b,z,C,U,g,r,I){let V=q;I.mode=j(U);const l=g!==v.c.CounterClockWiseSideOrientation,y=!r.wasAddedByNoopNode&&l,R=function(q){switch(q){case v.c.TriangleFillMode:case v.c.TriangleStripDrawMode:case v.c.TriangleFanDrawMode:return!0}return!1}(U)&&y;if(R){if(U===v.c.TriangleStripDrawMode||U===v.c.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");I.mode=j(U);const g=S?new Uint32Array(z):new Uint16Array(z);if(q)for(let S=0;S+2<z;S+=3)g[S]=q[b+S]+C,g[S+1]=q[b+S+2]+C,g[S+2]=q[b+S+1]+C;else for(let q=0;q+2<z;q+=3)g[q]=q,g[q+1]=q+2,g[q+2]=q+1;V=g}else if(q&&0!==C){const v=S?new Uint32Array(z):new Uint16Array(z);for(let S=0;S<z;S++)v[S]=q[b+S]+C;V=v}if(V){let v=r.getIndicesAccessor(q,b,z,C,R);if(void 0===v){const U=function(q,S,b,z){if(q instanceof Uint16Array||q instanceof Uint32Array)return q;if(q instanceof Int32Array)return new Uint32Array(q.buffer,q.byteOffset,q.length);const C=q.slice(S,S+b);return z?new Uint32Array(C):new Uint16Array(C)}(V,0,z,S),g=this._bufferManager.createBufferView(U),I=S?5125:5123;this._accessors.push(this._bufferManager.createAccessor(g,"SCALAR",I,z,0)),v=this._accessors.length-1,r.setIndicesAccessor(q,b,z,C,R,v)}I.indices=v}}_exportVertexBuffer(q,S,b,z,C,v){const U=q.getKind();if(!O(U))return;if(U.startsWith("uv")&&!this._options.exportUnusedUVs&&(!S||!this._materialNeedsUVsSet.has(S)))return;let g=C.getVertexAccessor(q,b,z);if(void 0===g){const S=C.convertedToRightHandedBuffers.get(q._buffer)||q._buffer.getData(),v=U===V.f.PositionKind?function(q,S,b,z){const{byteOffset:C,byteStride:v,type:U,normalized:g}=S,r=S.getSize(),I=new Array(r).fill(1/0),V=new Array(r).fill(-1/0);return(0,x.h)(q,C+b*v,v,r,U,z*r,g,(q=>{for(let S=0;S<r;S++)I[S]=Math.min(I[S],q[S]),V[S]=Math.max(V[S],q[S])})),{min:I,max:V}}(S,q,b,z):void 0,r=(U===V.f.MatricesIndicesKind||U===V.f.MatricesIndicesExtraKind)&&q.type===V.f.FLOAT,I=r?V.f.UNSIGNED_BYTE:q.type,l=r?void 0:q.normalized,y=r?C.getRemappedBufferView(q._buffer,q):C.getVertexBufferView(q._buffer),R=q.byteOffset+b*q.byteStride;this._accessors.push(this._bufferManager.createAccessor(y,function(q,S){if(q==V.f.ColorKind)return S?"VEC4":"VEC3";switch(q){case V.f.PositionKind:case V.f.NormalKind:return"VEC3";case V.f.TangentKind:case V.f.MatricesIndicesKind:case V.f.MatricesIndicesExtraKind:case V.f.MatricesWeightsKind:case V.f.MatricesWeightsExtraKind:return"VEC4";case V.f.UVKind:case V.f.UV2Kind:case V.f.UV3Kind:case V.f.UV4Kind:case V.f.UV5Kind:case V.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${q}`)}(U,C.hasVertexColorAlpha(q)),I,z,R,v,l)),g=this._accessors.length-1,C.setVertexAccessor(q,b,z,g)}v.attributes[function(q){switch(q){case V.f.PositionKind:return"POSITION";case V.f.NormalKind:return"NORMAL";case V.f.TangentKind:return"TANGENT";case V.f.ColorKind:return"COLOR_0";case V.f.UVKind:return"TEXCOORD_0";case V.f.UV2Kind:return"TEXCOORD_1";case V.f.UV3Kind:return"TEXCOORD_2";case V.f.UV4Kind:return"TEXCOORD_3";case V.f.UV5Kind:return"TEXCOORD_4";case V.f.UV6Kind:return"TEXCOORD_5";case V.f.MatricesIndicesKind:return"JOINTS_0";case V.f.MatricesIndicesExtraKind:return"JOINTS_1";case V.f.MatricesWeightsKind:return"WEIGHTS_0";case V.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${q}`)}(U)]=g}async _exportMaterialAsync(q,S,b,z){let C=this._materialMap.get(q);if(void 0===C){const z=S&&Object.keys(S).some((q=>q.startsWith("uv")));if((q=q instanceof Rq.b?q.mb[b.materialIndex]:q)instanceof Gq.b)C=await this._materialExporter.exportPBRMaterialAsync(q,"image/png",z);else{if(!(q instanceof Zq.ZS))return void F.b.Warn(`Unsupported material '${q.name}' with type ${q.getClassName()}`);C=await this._materialExporter.exportStandardMaterialAsync(q,"image/png",z)}this._materialMap.set(q,C)}z.material=C}async _exportMeshAsync(q,S){var b;let z=S.getMesh(q);if(void 0!==z)return z;const C={primitives:[]};z=this._meshes.length,this._meshes.push(C),S.setMesh(q,z);const U=q.isUnIndexed?null:q.Xb(),g=null===(b=q.ub)||void 0===b?void 0:b.getVertexBuffers(),r=S.getMorphTargetsFromMesh(q),I=q instanceof Xq.d,V=q instanceof oq,l=q.Gb;if(g&&l&&l.length>0)for(const G of l){const b={attributes:{}},z=G.Dq()||this._babylonScene.defaultMaterial;if(V){var y,R;const S={name:z.name},C=q,v=H.HS.White(),U=(null===(y=C.material)||void 0===y?void 0:y.alpha)??1,g=(null===(R=C.greasedLineMaterial)||void 0===R?void 0:R.color)??v;(!g.equalsWithEpsilon(v,n.d)||U<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...g.Zb(),U]}),this._materials.push(S),b.material=this._materials.length-1}else if(I){const S={name:z.name},C=q;(!C.color.equalsWithEpsilon(H.HS.White(),n.d)||C.alpha<1)&&(S.pbrMetallicRoughness={baseColorFactor:[...C.color.Zb(),C.alpha]}),this._materials.push(S),b.material=this._materials.length-1}else await this._exportMaterialAsync(z,g,G,b);const l=I||V?v.c.LineListDrawMode:q.overrideRenderingFillMode??z.fillMode,Z=z._getEffectiveOrientation(q);this._exportIndices(U,U?(0,x.c)(U,G.indexCount,G.indexStart,G.verticesStart):G.verticesCount>65535,U?G.indexStart:G.verticesStart,U?G.indexCount:G.verticesCount,-G.verticesStart,l,Z,S,b);for(const q of Object.values(g))this._exportVertexBuffer(q,z,G.verticesStart,G.verticesCount,S,b);if(r){b.targets=[];for(const q of r)b.targets.push(q.attributes)}C.primitives.push(b),this._extensionsPostExportMeshPrimitive(b)}if(r){C.weights=[],C.extras||(C.extras={}),C.extras.targetNames=[];for(const q of r)C.weights.push(q.influence),C.extras.targetNames.push(q.name)}return z}}Aq._ExtensionNames=new Array,Aq._ExtensionFactories={};class wq{static async GLTFAsync(q,S,b){b&&b.exportWithoutWaitingForScene||await q.whenReadyAsync();const z=new Aq(q,b),C=await z.generateGLTFAsync(S.replace(/\.[^/.]+$/,""));return z.dispose(),C}static async GLBAsync(q,S,b){b&&b.exportWithoutWaitingForScene||await q.whenReadyAsync();const z=new Aq(q,b),C=await z.generateGLBAsync(S.replace(/\.[^/.]+$/,""));return z.dispose(),C}}b(11679);const Pq="EXT_mesh_gpu_instancing";class hq{constructor(q){this.name=Pq,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(q,S,b,C,v,U){return await new Promise((q=>{if(S&&b instanceof kq.d&&b.hasThinInstances&&this._exporter){this._wasUsed=!0;const q=z.yS.Zero(),C=z.Quaternion.Identity(),g=z.yS.One(),r=b.thinInstanceGetWorldMatrices(),I=z.TmpVectors.yS[2],V=z.TmpVectors.Quaternion[1],l=z.TmpVectors.yS[3];let y=!1,R=!1,G=!1;const Z=new Float32Array(3*b.Eb),H=new Float32Array(4*b.Eb),Q=new Float32Array(3*b.Eb);let k=0;for(const S of r)S.decompose(l,V,I),v&&(p(I),Y(V)),Z.set(I.Zb(),3*k),H.set(V.normalize().Zb(),4*k),Q.set(l.Zb(),3*k),y=y||!I.equalsWithEpsilon(q),R=R||!V.equalsWithEpsilon(C),G=G||!l.equalsWithEpsilon(g),k++;const W={attributes:{}};y&&(W.attributes.TRANSLATION=this._buildAccessor(Z,"VEC3",b.Eb,U)),R&&(W.attributes.ROTATION=this._buildAccessor(H,"VEC4",b.Eb,U)),G&&(W.attributes.SCALE=this._buildAccessor(Q,"VEC3",b.Eb,U)),S.extensions=S.extensions||{},S.extensions[Pq]=W}q(S)}))}_buildAccessor(q,S,b,z){const C=z.createBufferView(q),v=z.createAccessor(C,S,5126,b);return this._exporter._accessors.push(v),this._exporter._accessors.length-1}}Aq.RegisterExtension(Pq,(q=>new hq(q)));var Oq=b(11684),jq=b(11694),Mq=b(11702),pq=b(11705);function Yq(q){return q===Mq.b.PositionKind?"POSITION":q===Mq.b.NormalKind?"NORMAL":q===Mq.b.ColorKind?"COLOR":q.startsWith(Mq.b.UVKind)?"TEX_COORD":"GENERIC"}const cq={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class qS extends Oq.c{static get DefaultAvailable(){return(0,Oq.h)(qS.DefaultConfiguration)}static get Default(){return qS._Default??(qS._Default=new qS),qS._Default}static ResetDefault(q){qS._Default&&(q||qS._Default.dispose(),qS._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(q,S){return{module:await(S||DracoEncoderModule)({wasmBinary:q})}}_getWorkerContent(){return`${jq.h}(${jq.j})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:qS.DefaultConfiguration)}async _encodeAsync(q,S,b){const z=b?(0,pq.d)(cq,b):cq;if(this._workerPoolPromise){const b=await this._workerPoolPromise;return await new Promise(((C,v)=>{b.push(((b,U)=>{const g=q=>{b.removeEventListener("error",g),b.removeEventListener("message",r),v(q),U()},r=q=>{"encodeMeshDone"===q.data.id&&(b.removeEventListener("error",g),b.removeEventListener("message",r),C(q.data.encodedMeshData),U())};b.addEventListener("error",g),b.addEventListener("message",r);const I=[];for(const S of q)I.push(S.data.buffer);S&&I.push(S.buffer),b.postMessage({id:"encodeMesh",attributes:q,indices:S,options:z},I)}))}))}if(this._modulePromise){const b=await this._modulePromise;return(0,jq.h)(b.module,q,S,z)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(q,S){if(0==q.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");q instanceof kq.d&&q.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===S||void 0===S?void 0:S.method)&&(F.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),S.method="MESH_SEQUENTIAL_ENCODING");const b=function(q){let S=q.Xb(void 0,!0);return!S||S instanceof Uint32Array||S instanceof Uint16Array||(S=((0,x.c)(S,S.length)?Uint32Array:Uint16Array).from(S)),S}(q),z=function(q,S){const b=[];for(const z of q.getVerticesDataKinds()){if(null!==S&&void 0!==S&&S.includes(z)){if(z===Mq.b.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const C=q.getVertexBuffer(z),v=C.getSize(),U=(0,x.r)(C.getData(),v,C.type,C.byteOffset,C.byteStride,C.normalized,q.getTotalVertices(),!0);b.push({kind:z,dracoName:Yq(z),size:v,data:U})}return b}(q,null===S||void 0===S?void 0:S.excludedAttributes);return await this._encodeAsync(z,b,S)}}qS.DefaultConfiguration={wasmUrl:`${C.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${C.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${C.Tools._DefaultCdnUrl}/draco_encoder.js`},qS._Default=null;const SS="KHR_draco_mesh_compression";class bS{get wasUsed(){return this._wasUsed}constructor(q){this.name=SS,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===q.options.meshCompressionMethod&&qS.DefaultAvailable}dispose(){}postExportMeshPrimitive(q,S,b){if(!this.enabled)return;if(4!==q.mode&&5!==q.mode)return void F.b.Warn("Cannot compress primitive with mode "+q.mode+".");const z=[],C=[];let v=null;if(void 0!==q.indices){const U=b[q.indices],g=S.getBufferView(U);v=S.getData(g).slice(),z.push(g),C.push(U)}const U=[];for(const[V,l]of Object.entries(q.attributes)){const q=b[l],v=S.getBufferView(q),r=h(q.type),I=(0,x.r)(S.getData(v),r,q.componentType,q.byteOffset||0,v.byteStride||(0,x.m)(q.componentType)*r,q.normalized||!1,q.count,!0);U.push({kind:V,dracoName:(g=V,"POSITION"===g?"POSITION":"NORMAL"===g?"NORMAL":g.startsWith("COLOR")?"COLOR":g.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:h(q.type),data:I}),z.push(v),C.push(q)}var g;const r={method:q.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},I=qS.Default._encodeAsync(U,v,r).then((b=>{if(!b)return void F.b.Error("Draco encoding failed for primitive.");const v={bufferView:-1,attributes:b.attributeIds},U=S.createBufferView(b.data);S.setBufferView(v,U);for(const q of z)this._bufferViewsUsed.add(q);for(const q of C)this._accessorsUsed.add(q);q.extensions||(q.extensions={}),q.extensions[SS]=v})).catch((q=>{F.b.Error("Draco encoding failed for primitive: "+q)}));this._encodePromises.push(I),this._wasUsed=!0}async preGenerateBinaryAsync(q){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((S=>{q.getPropertiesWithBufferView(S).every((q=>this._accessorsUsed.has(q)))&&q.removeBufferView(S)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}Aq.RegisterExtension(SS,(q=>new bS(q)));var zS=b(11711);const CS="KHR_lights_punctual",vS={name:"",color:[1,1,1],eb:1,range:Number.MAX_VALUE},US={innerConeAngle:0,outerConeAngle:Math.PI/4},gS=z.yS.Backward();class rS{constructor(q){this.name=CS,this.enabled=!0,this.required=!1,this._exporter=q}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[CS]=this._lights}async postExportNodeAsync(q,S,b,C,v){return await new Promise((U=>{if(!(b instanceof Wq.b))return void U(S);const g=b.getTypeID()==Wq.b.LIGHTTYPEID_POINTLIGHT?"point":b.getTypeID()==Wq.b.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":b.getTypeID()==Wq.b.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!g||!(b instanceof zS.b))return F.b.Warn(`${q}: Light ${b.name} is not supported in ${CS}`),void U(S);if(b.falloffType!==Wq.b.FALLOFF_GLTF&&F.b.Warn(`${q}: Light falloff for ${b.name} does not match the ${CS} specification!`),!b.position.equalsToFloats(0,0,0)){const q=z.TmpVectors.yS[0].v(b.position);v&&p(q),S.translation=q.Zb()}if("point"!==g){const q=b.direction.normalizeToRef(z.TmpVectors.yS[0]);v&&p(q);const C=z.Quaternion.FromUnitVectorsToRef(gS,q,z.TmpVectors.Quaternion[0]);z.Quaternion.IsIdentity(C)||(S.rotation=C.Zb())}const r={type:g,name:b.name,color:b.ib.Zb(),eb:b.eb,range:b.range};if(zq(r,vS),"spot"===g){const q=b;r.spot={innerConeAngle:q.innerAngle/2,outerConeAngle:q.angle/2},zq(r.spot,US)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(r);const I={zb:this._lights.lights.length-1},V=b.parent;if(V&&Sq(b,V)){const q=C.get(V);if(q){const b=this._exporter._nodes[q];return qq(S,b),b.extensions||(b.extensions={}),b.extensions[CS]=I,void U(null)}}S.extensions||(S.extensions={}),S.extensions[CS]=I,U(S)}))}}Aq.RegisterExtension(CS,(q=>new rS(q)));var IS=b(11613);const VS="KHR_materials_anisotropy";class lS{constructor(q){this.name=VS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof IS.b&&b.anisotropy.isEnabled&&!b.anisotropy.legacy?(b.anisotropy.texture&&z.push(b.anisotropy.texture),z):[]}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof IS.b){if(!b.anisotropy.isEnabled||b.anisotropy.legacy)return void q(S);this._wasUsed=!0,S.extensions=S.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(b.anisotropy.texture),C={anisotropyStrength:b.anisotropy.eb,anisotropyRotation:b.anisotropy.angle,anisotropyTexture:z??void 0};null!==C.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(b),S.extensions[VS]=C}q(S)}))}}Aq.RegisterExtension(VS,(q=>new lS(q)));const yS="KHR_materials_clearcoat";class RS{constructor(q){this.name=yS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof IS.b&&b.clearCoat.isEnabled?(b.clearCoat.texture&&z.push(b.clearCoat.texture),!b.clearCoat.useRoughnessFromMainTexture&&b.clearCoat.textureRoughness&&z.push(b.clearCoat.textureRoughness),b.clearCoat.bumpTexture&&z.push(b.clearCoat.bumpTexture),z):[]}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof IS.b){if(!b.clearCoat.isEnabled)return void q(S);this._wasUsed=!0,S.extensions=S.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture);let v;v=b.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(b.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(b.clearCoat.textureRoughness),b.clearCoat.isTintEnabled&&C.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${b.name}`),b.clearCoat.remapF0OnInterfaceChange&&C.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${b.name}`);const U=this._exporter._materialExporter.getTextureInfo(b.clearCoat.bumpTexture),g={clearcoatFactor:b.clearCoat.eb,clearcoatTexture:z??void 0,clearcoatRoughnessFactor:b.clearCoat.roughness,clearcoatRoughnessTexture:v??void 0,clearcoatNormalTexture:U??void 0};null===g.clearcoatTexture&&null===g.clearcoatRoughnessTexture&&null===g.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),S.extensions[yS]=g}q(S)}))}}Aq.RegisterExtension(yS,(q=>new RS(q)));const GS="KHR_materials_diffuse_transmission";function ZS(q,S){const b=S.subSurface;let z=null;return b.translucencyIntensityTexture?z=b.translucencyIntensityTexture:b.thicknessTexture&&b.useMaskFromThicknessTexture&&(z=b.thicknessTexture),z&&!b.useGltfStyleTextures?(F.b.Warn(`${q}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${S.name}`,1),null):z}class HS{constructor(q){this.name=GS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];if(b instanceof Gq.b&&this._isExtensionEnabled(b)){const S=ZS(q,b);return S&&z.push(S),b.subSurface.translucencyColorTexture&&z.push(b.subSurface.translucencyColorTexture),z}return z}_isExtensionEnabled(q){if(q.unlit)return!1;const S=q.subSurface;return!!S.isTranslucencyEnabled&&(!q.unlit&&!S.useAlbedoToTintTranslucency&&S.useGltfStyleTextures&&1===S.volumeIndexOfRefraction&&0===S.minimumThickness&&0===S.maximumThickness)}postExportMaterialAsync(q,S,b){return new Promise((z=>{if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const z=b.subSurface,C=ZS(q,b),v=0==z.translucencyIntensity?void 0:z.translucencyIntensity,U=this._exporter._materialExporter.getTextureInfo(C)??void 0,g=!z.translucencyColor||z.translucencyColor.equalsFloats(1,1,1)?void 0:z.translucencyColor.Zb(),r=this._exporter._materialExporter.getTextureInfo(z.translucencyColorTexture)??void 0,I={diffuseTransmissionFactor:v,diffuseTransmissionTexture:U,diffuseTransmissionColorFactor:g,diffuseTransmissionColorTexture:r};(U||r)&&this._exporter._materialNeedsUVsSet.add(b),S.extensions=S.extensions||{},S.extensions[GS]=I}z(S)}))}}Aq.RegisterExtension(GS,(q=>new HS(q)));const QS="KHR_materials_dispersion";class kS{constructor(){this.name=QS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){if(q.unlit)return!1;const S=q.subSurface;return!(!S.isRefractionEnabled&&!S.isDispersionEnabled)}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const q={dispersion:b.subSurface.dispersion};S.extensions=S.extensions||{},S.extensions[QS]=q}q(S)}))}}Aq.RegisterExtension(QS,(()=>new kS));const WS="KHR_materials_emissive_strength";class NS{constructor(){this.name=WS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(q,S,b){return await new Promise((q=>{if(!(b instanceof Gq.b))return q(S);const z=b.emissiveColor.Zb(),C=Math.max(...z);if(C>1){this._wasUsed=!0,S.extensions||(S.extensions={});const q={emissiveStrength:C},z=b.emissiveColor.scale(1/q.emissiveStrength);S.emissiveFactor=z.Zb(),S.extensions[WS]=q}return q(S)}))}}Aq.RegisterExtension(WS,(q=>new NS));const uS="KHR_materials_ior";class XS{constructor(){this.name=uS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.indexOfRefraction&&1.5!=q.indexOfRefraction)}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const q={ior:b.indexOfRefraction};S.extensions=S.extensions||{},S.extensions[uS]=q}q(S)}))}}Aq.RegisterExtension(uS,(q=>new XS));const TS="KHR_materials_iridescence";class BS{constructor(q){this.name=TS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof IS.b&&b.iridescence.isEnabled?(b.iridescence.texture&&z.push(b.iridescence.texture),b.iridescence.thicknessTexture&&b.iridescence.thicknessTexture!==b.iridescence.texture&&z.push(b.iridescence.thicknessTexture),z):[]}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof IS.b){if(!b.iridescence.isEnabled)return void q(S);this._wasUsed=!0,S.extensions=S.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(b.iridescence.texture),C=this._exporter._materialExporter.getTextureInfo(b.iridescence.thicknessTexture),v={iridescenceFactor:b.iridescence.eb,iridescenceIor:b.iridescence.indexOfRefraction,iridescenceThicknessMinimum:b.iridescence.minimumThickness,iridescenceThicknessMaximum:b.iridescence.maximumThickness,iridescenceTexture:z??void 0,iridescenceThicknessTexture:C??void 0};null===v.iridescenceTexture&&null===v.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(b),S.extensions[TS]=v}q(S)}))}}Aq.RegisterExtension(TS,(q=>new BS(q)));const tS="KHR_materials_sheen";class fS{constructor(q){this.name=tS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){return b instanceof Gq.b&&b.sheen.isEnabled&&b.sheen.texture?[b.sheen.texture]:[]}async postExportMaterialAsync(q,S,b){return await new Promise((q=>{if(b instanceof Gq.b){if(!b.sheen.isEnabled)return void q(S);this._wasUsed=!0,null==S.extensions&&(S.extensions={});const z={sheenColorFactor:b.sheen.color.Zb(),sheenRoughnessFactor:b.sheen.roughness??0};null===z.sheenColorTexture&&null===z.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(b),b.sheen.texture&&(z.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),b.sheen.textureRoughness&&!b.sheen.useRoughnessFromMainTexture?z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.textureRoughness)??void 0:b.sheen.texture&&b.sheen.useRoughnessFromMainTexture&&(z.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(b.sheen.texture)??void 0),S.extensions[tS]=z}q(S)}))}}Aq.RegisterExtension(tS,(q=>new fS(q)));const mS="KHR_materials_specular";class ES{constructor(q){this.name=mS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof Gq.b&&this._isExtensionEnabled(b)?(b.metallicReflectanceTexture&&z.push(b.metallicReflectanceTexture),b.reflectanceTexture&&z.push(b.reflectanceTexture),z):z}_isExtensionEnabled(q){return!q.unlit&&(void 0!=q.metallicF0Factor&&1!=q.metallicF0Factor||void 0!=q.metallicReflectanceColor&&!q.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.metallicReflectanceTexture||null!=q.reflectanceTexture}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0,S.extensions=S.extensions||{};const q=this._exporter._materialExporter.getTextureInfo(b.metallicReflectanceTexture)??void 0,z=this._exporter._materialExporter.getTextureInfo(b.reflectanceTexture)??void 0,C={specularFactor:1==b.metallicF0Factor?void 0:b.metallicF0Factor,specularTexture:q,specularColorFactor:b.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:b.metallicReflectanceColor.Zb(),specularColorTexture:z};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),S.extensions[mS]=C}q(S)}))}}Aq.RegisterExtension(mS,(q=>new ES(q)));const eS="KHR_materials_transmission";class iS{constructor(q){this.name=eS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof Gq.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&z.push(b.subSurface.thicknessTexture),z):z}_isExtensionEnabled(q){if(q.unlit)return!1;const S=q.subSurface;return S.isRefractionEnabled&&void 0!=S.refractionIntensity&&0!=S.refractionIntensity||this._hasTexturesExtension(q)}_hasTexturesExtension(q){return null!=q.subSurface.refractionIntensityTexture}async postExportMaterialAsync(q,S,b){if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const z=b.subSurface,C={transmissionFactor:0===z.refractionIntensity?void 0:z.refractionIntensity};if(this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),z.refractionIntensityTexture)if(z.useGltfStyleTextures){const q=await this._exporter._materialExporter.exportTextureAsync(z.refractionIntensityTexture,"image/png");q&&(C.transmissionTexture=q)}else F.b.Warn(`${q}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);S.extensions||(S.extensions={}),S.extensions[eS]=C}return S}}Aq.RegisterExtension(eS,(q=>new iS(q)));const JS="KHR_materials_unlit";class LS{constructor(){this.name=JS,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(q,S,b){return new Promise((q=>{let z=!1;b instanceof Gq.b?z=b.unlit:b instanceof Zq.ZS&&(z=b.disableLighting),z&&(this._wasUsed=!0,null==S.extensions&&(S.extensions={}),S.extensions[JS]={}),q(S)}))}}Aq.RegisterExtension(JS,(()=>new LS));const dS="KHR_materials_volume";class KS{constructor(q){this.name=dS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof Gq.b&&this._isExtensionEnabled(b)?(b.subSurface.thicknessTexture&&z.push(b.subSurface.thicknessTexture),z):z}_isExtensionEnabled(q){if(q.unlit)return!1;const S=q.subSurface;return!(!S.isRefractionEnabled&&!S.isTranslucencyEnabled)&&(void 0!=S.maximumThickness&&0!=S.maximumThickness||void 0!=S.tintColorAtDistance&&S.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=S.tintColor&&S.tintColor!=H.HS.White()||this._hasTexturesExtension(q))}_hasTexturesExtension(q){return null!=q.subSurface.thicknessTexture}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof Gq.b&&this._isExtensionEnabled(b)){this._wasUsed=!0;const q=b.subSurface,z={thicknessFactor:0==q.maximumThickness?void 0:q.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(q.thicknessTexture)??void 0,attenuationDistance:q.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:q.tintColorAtDistance,attenuationColor:q.tintColor.equalsFloats(1,1,1)?void 0:q.tintColor.Zb()};this._hasTexturesExtension(b)&&this._exporter._materialNeedsUVsSet.add(b),S.extensions=S.extensions||{},S.extensions[dS]=z}q(S)}))}}Aq.RegisterExtension(dS,(q=>new KS(q)));const DS="EXT_materials_diffuse_roughness";class xS{constructor(q){this.name=DS,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=q}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(q,S,b){const z=[];return b instanceof IS.b&&b._baseDiffuseRoughness?(b._baseDiffuseRoughnessTexture&&z.push(b._baseDiffuseRoughnessTexture),z):[]}postExportMaterialAsync(q,S,b){return new Promise((q=>{if(b instanceof IS.b){if(!b._baseDiffuseRoughness)return void q(S);this._wasUsed=!0,S.extensions=S.extensions||{};const z=this._exporter._materialExporter.getTextureInfo(b._baseDiffuseRoughnessTexture),C={diffuseRoughnessFactor:b._baseDiffuseRoughness,diffuseRoughnessTexture:z??void 0};null!==C.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(b),S.extensions[DS]=C}q(S)}))}}Aq.RegisterExtension(DS,(q=>new xS(q)));const FS="KHR_texture_transform";class aS{constructor(){this.name=FS,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(q,S,b){if(b.Tq()||C.Tools.Warn(`${q}: /*@__KEY__*/"scene" is not defined for Babylon texture ${b.name}!`),(0!==b.uAng||0!==b.vAng)&&(C.Tools.Warn(`${q}: Texture ${b.name} with rotation in the u or v axis is not supported in glTF.`),0!==b.uRotationCenter||0!==b.vRotationCenter))return;const z={};let v=!1;if(0===b.uOffset&&0===b.vOffset||(z.offset=[b.uOffset,b.vOffset],v=!0),1===b.uScale&&1===b.vScale||(z.scale=[b.uScale,b.vScale],v=!0),0!==b.wAng){if(0!==b.uRotationCenter||0!==b.vRotationCenter){if(b.homogeneousRotationInUVTransform&&b.uScale!==b.vScale)return void C.Tools.Warn(`${q}: Texture ${b.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${FS}.`);C.Tools.Warn(`${q}: Texture ${b.name} with non-origin rotation center will be exported using an adjusted offset with ${FS}.`),z.offset=function(q){const{uOffset:S,vOffset:b,uRotationCenter:z,vRotationCenter:C,uScale:v,vScale:U,wAng:g}=q,r=Math.cos(g),I=Math.sin(g),V=z*v,l=C*U;return[S+(V*(1-r)+l*I),b+(l*(1-r)-V*I)]}(b)}z.rotation=-b.wAng,v=!0}0!==b.coordinatesIndex&&(z.texCoord=b.coordinatesIndex,v=!0),v&&(this._wasUsed=!0,S.extensions||(S.extensions={}),S.extensions[FS]=z)}}Aq.RegisterExtension(FS,(()=>new aS));class nS{static CreateSTL(q){let S=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",C=arguments.length>3&&void 0!==arguments[3]&&arguments[3],v=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],U=arguments.length>5&&void 0!==arguments[5]&&arguments[5],g=arguments.length>6&&void 0!==arguments[6]&&arguments[6],r=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const I=function(q,S,b){const C=[3*q[b],3*q[b+1],3*q[b+2]],v=[new z.yS(S[C[0]],S[C[0]+2],S[C[0]+1]),new z.yS(S[C[1]],S[C[1]+2],S[C[1]+1]),new z.yS(S[C[2]],S[C[2]+2],S[C[2]+1])],U=v[0].RS(v[1]),g=v[2].RS(v[1]);return{v:v,n:z.yS.Cross(g,U).normalize()}},l=function(q,S,b,z){return S=y(q,S,b.x,z),S=y(q,S,b.y,z),y(q,S,b.z,z)},y=function(q,S,b,z){return q.setFloat32(S,b,z),S+4},G=function(q){if(g){let S=q;q instanceof R.d&&(S=q.sourceMesh);const b=S.getVerticesData(V.f.PositionKind,!0,!0);if(!b)return[];const C=z.yS.Zero();let v;for(v=0;v<b.length;v+=3)z.yS.TransformCoordinatesFromFloatsToRef(b[v],b[v+1],b[v+2],q.Nb(!0),C).toArray(b,v);return b}return q.getVerticesData(V.f.PositionKind)||[]};g&&(U=!0);let Z="",H=0,Q=0;if(C){for(let b=0;b<q.length;b++){const S=q[b].Xb();H+=S?S.length/3:0}const S=new ArrayBuffer(84+50*H);Z=new DataView(S),Q+=80,Z.setUint32(Q,H,v),Q+=4}else r||(Z="solid stlmesh\r\n");for(let z=0;z<q.length;z++){const S=q[z];!C&&r&&(Z+="solid "+S.name+"\r\n"),!U&&S instanceof kq.d&&S.bakeCurrentTransformIntoVertices();const b=G(S),g=S.Xb()||[];for(let q=0;q<g.length;q+=3){const S=I(g,b,q);C?(Q=l(Z,Q,S.n,v),Q=l(Z,Q,S.v[0],v),Q=l(Z,Q,S.v[1],v),Q=l(Z,Q,S.v[2],v),Q+=2):(Z+="\tfacet normal "+S.n.x+" "+S.n.y+" "+S.n.z+"\r\n",Z+="\t\touter loop\r\n",Z+="\t\t\tvertex "+S.v[0].x+" "+S.v[0].y+" "+S.v[0].z+"\r\n",Z+="\t\t\tvertex "+S.v[1].x+" "+S.v[1].y+" "+S.v[1].z+"\r\n",Z+="\t\t\tvertex "+S.v[2].x+" "+S.v[2].y+" "+S.v[2].z+"\r\n",Z+="\t\tendloop\r\n",Z+="\tendfacet\r\n")}!C&&r&&(Z+="endsolid "+name+"\r\n")}if(C||r||(Z+="endsolid stlmesh"),S){const q=document.createElement("a"),S=new Blob([Z],{type:"application/octet-stream"});q.href=window.URL.createObjectURL(S),q.download=b+".stl",q.click()}return Z}}function oS(q,S){let b=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const z=[];for(let C=0;C<q.length/b;C++){const v=q[C*b],U=q[C*b+1],g=q[C*b+2];z.push(`(${v.toPrecision(S.precision)}, ${U.toPrecision(S.precision)}, ${g.toPrecision(S.precision)})`)}return z.join(", ")}function sS(q,S){const b=[];for(let z=0;z<q.length/2;z++){const C=q[2*z],v=q[2*z+1];b.push(`(${C.toPrecision(S.precision)}, ${(1-v).toPrecision(S.precision)})`)}return b.join(", ")}function AS(q,S){const b=q.getVerticesData(V.f.PositionKind),z=q.getVerticesData(V.f.NormalKind);if(b&&z)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(q){var S;const b=null!==(S=q.Xb())&&void 0!==S&&S.length?q.getTotalIndices():q.getTotalVertices();return Array(b/3).fill(3).join(", ")}(q)}]\n\t\tint[] faceVertexIndices = [${function(q){const S=q.Xb(),b=[];if(null!==S)for(let z=0;z<S.length;z++)b.push(S[z]);else{const S=q.getTotalVertices();for(let q=0;q<S;q++)b.push(q)}return b.join(", ")}(q)}]\n\t\tnormal3f[] normals = [${oS(z,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${oS(b,S)}]\n        ${function(q,S){let b="";for(let C=0;C<4;C++){const z=C>0?C:"",v=q.getVerticesData(V.f.UVKind+(z?z+1:""));v&&(b+=`\n\t\ttexCoord2f[] primvars:st${z} = [${sS(v,S)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const z=q.getVerticesData(V.f.ColorKind);return z&&(b+=`\n\tcolor3f[] primvars:displayColor = [${oS(z,S,z.length/q.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),b}(q,S)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function wS(q,S){return`\n        def "Geometry"\n        {\n        ${AS(q,S)}\n        }\n        `}function PS(q){let S='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return S+=q,fflate.strToU8(S)}function hS(q){const S=q.m;return`( ${OS(S,0)}, ${OS(S,4)}, ${OS(S,8)}, ${OS(S,12)} )`}function OS(q,S){return`(${q[S+0]}, ${q[S+1]}, ${q[S+2]}, ${q[S+3]})`}function jS(q){const S="Object_"+q.uniqueId,b=function(q){const S=q.getWorldMatrix().clone(),b=q.Tq().useRightHandedSystem;if(!b){let z=q.parent;for(;z;){if(Uq(z,b)){S.multiplyToRef(z.getWorldMatrix().invert(),S);break}z=z.parent}}return S.determinant()<0&&C.Tools.Warn(`Exporting mesh ${q.name} with negative scale. Result may look incorrect in destination engine.`),S}(q),z=hS(b);return`def Xform "${S}" (\n\tprepend references = @./geometries/Geometry_${q.ub.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${z}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${q.material.uniqueId}>\n}\n\n`}function MS(q){switch(q){case T.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case T.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case T.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function pS(q){return`(${q.x}, ${q.y})`}function YS(q){return`(${q.r}, ${q.g}, ${q.b})`}function cS(q,S,b,C,v,U){const g=q.getInternalTexture().uniqueId+"_"+q.invertY;v[g]=q;const r=q.coordinatesIndex>0?"st"+q.coordinatesIndex:"st",I=new z.Vector2(q.uScale,q.vScale),V=new z.Vector2(q.uOffset,q.vOffset),l=q.wAng,y=Math.sin(l),R=Math.cos(l);return V.y=1-V.y-I.y,V.x+=y*I.x,V.y+=(1-R)*I.y,`\n    def Shader "PrimvarReader_${b}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${r}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${b}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${S.uniqueId}/PrimvarReader_${b}.outputs:result>\n        float inputs:rotation = ${(l*(180/Math.PI)).toFixed(U.precision)}\n        float2 inputs:scale = ${pS(I)}\n        float2 inputs:translation = ${pS(V)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${q.uniqueId}_${b}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${g}.png@\n        float2 inputs:st.connect = </Materials/Material_${S.uniqueId}/Transform2d_${b}.outputs:result>\n        ${C?"float4 inputs:scale = "+function(q){return`(${q.r}, ${q.g}, ${q.b}, 1.0)`}(C):""}\n        token inputs:sourceColorSpace = "${q.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${MS(q.wrapU)}"\n        token inputs:wrapT = "${MS(q.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${S.needAlphaBlending()?"float outputs:a":""}\n    }`}function qb(q,S,b){const z="\t\t\t",C=[],v=[],{diffuseMap:U,ib:g,alphaCutOff:r,emissiveMap:I,emissive:V,normalMap:l,roughnessMap:y,roughnessChannel:R,roughness:G,metalnessMap:Z,metalnessChannel:Q,metalness:k,aoMap:W,aoMapChannel:N,aoMapIntensity:u,alphaMap:X,ior:T,clearCoatEnabled:B,clearCoat:t,clearCoatMap:f,clearCoatRoughness:m,clearCoatRoughnessMap:E}=function(q){const S={diffuseMap:null,ib:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return q instanceof Zq.ZS?{...S,diffuseMap:q.diffuseTexture,ib:q.diffuseColor,alphaCutOff:q.alphaCutOff,emissiveMap:q.emissiveTexture,emissive:q.emissiveColor,roughness:1,alphaMap:q.opacityTexture}:q instanceof IS.b?{...S,diffuseMap:q._albedoTexture,ib:q._albedoColor,alphaCutOff:q._alphaCutOff,emissiveMap:q._emissiveTexture,emissive:q._emissiveColor,normalMap:q._bumpTexture,roughnessMap:q._metallicTexture,roughnessChannel:q._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:q._roughness??1,metalnessMap:q._metallicTexture,metalnessChannel:q._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:q._metallic??0,aoMap:q._ambientTexture,aoMapChannel:q._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:q._ambientTextureStrength,alphaMap:q._opacityTexture,ior:q.subSurface.indexOfRefraction,clearCoatEnabled:q.clearCoat.isEnabled,clearCoat:q.clearCoat.eb,clearCoatMap:q.clearCoat.texture,clearCoatRoughness:q.clearCoat.roughness,clearCoatRoughnessMap:q.clearCoat.useRoughnessFromMainTexture?q.clearCoat.texture:q.clearCoat.textureRoughness}:S}(q);return null!==U?(C.push(`${z}color3f inputs:diffuseColor.connect = </Materials/Material_${q.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:rgb>`),q.needAlphaBlending()?C.push(`${z}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`):q.needAlphaTesting()&&(C.push(`${z}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${U.uniqueId}_diffuse.outputs:a>`),C.push(`${z}float inputs:opacityThreshold = ${r}`)),v.push(cS(U,q,"diffuse",g,S,b))):C.push(`${z}color3f inputs:diffuseColor = ${YS(g||H.HS.White())}`),null!==I?(C.push(`${z}color3f inputs:emissiveColor.connect = </Materials/Material_${q.uniqueId}/Texture_${I.uniqueId}_emissive.outputs:rgb>`),v.push(cS(I,q,"emissive",V,S,b))):V&&V.toLuminance()>0&&C.push(`${z}color3f inputs:emissiveColor = ${YS(V)}`),null!==l&&(C.push(`${z}normal3f inputs:normal.connect = </Materials/Material_${q.uniqueId}/Texture_${l.uniqueId}_normal.outputs:rgb>`),v.push(cS(l,q,"normal",null,S,b))),null!==W&&(C.push(`${z}float inputs:occlusion.connect = </Materials/Material_${q.uniqueId}/Texture_${W.uniqueId}_occlusion.outputs:${N}>`),v.push(cS(W,q,"occlusion",new H.HS(u,u,u),S,b))),null!==y?(C.push(`${z}float inputs:roughness.connect = </Materials/Material_${q.uniqueId}/Texture_${y.uniqueId}_roughness.outputs:${R}>`),v.push(cS(y,q,"roughness",new H.HS(G,G,G),S,b))):C.push(`${z}float inputs:roughness = ${G}`),null!==Z?(C.push(`${z}float inputs:metallic.connect = </Materials/Material_${q.uniqueId}/Texture_${Z.uniqueId}_metallic.outputs:${Q}>`),v.push(cS(Z,q,"metallic",new H.HS(k,k,k),S,b))):C.push(`${z}float inputs:metallic = ${k}`),null!==X?(C.push(`${z}float inputs:opacity.connect = </Materials/Material_${q.uniqueId}/Texture_${X.uniqueId}_opacity.outputs:r>`),C.push(`${z}float inputs:opacityThreshold = 0.0001`),v.push(cS(X,q,"opacity",null,S,b))):C.push(`${z}float inputs:opacity = ${q.alpha}`),B&&(null!==f?(C.push(`${z}float inputs:clearcoat.connect = </Materials/Material_${q.uniqueId}/Texture_${f.uniqueId}_clearcoat.outputs:r>`),v.push(cS(f,q,"clearcoat",new H.HS(t,t,t),S,b))):C.push(`${z}float inputs:clearcoat = ${t}`),null!==E?(C.push(`${z}float inputs:clearcoatRoughness.connect = </Materials/Material_${q.uniqueId}/Texture_${E.uniqueId}_clearcoatRoughness.outputs:g>`),v.push(cS(E,q,"clearcoatRoughness",new H.HS(m,m,m),S,b))):C.push(`${z}float inputs:clearcoatRoughness = ${m}`)),C.push(`${z}float inputs:ior = ${T}`),`\n\tdef Material "Material_${q.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${C.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${q.uniqueId}/PreviewSurface.outputs:surface>\n\n${v.join("\n")}\n\n\t}\n`}async function Sb(q,S,b){const v={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...S};"undefined"===typeof fflate&&await C.Tools.LoadScriptAsync(v.fflateUrl);const U={};U[v.modelFileName]=null;let g='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';g+=function(q){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===q.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${q.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${q.planeAnchoringAlignment}"`:""}\n            `}(v);const r={};for(const z of q.meshes){if(0===z.getTotalVertices())continue;const q=z,S=q.ub,I=q.material;if(!I||!S||b&&!b(q))continue;if(-1!==["ZS","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(I.getClassName())){const b="geometries/Geometry_"+S.uniqueId+".usda";if(!(b in U)){const q=wS(S,v);U[b]=PS(q)}I.uniqueId in r||(r[I.uniqueId]=I),g+=jS(q)}else C.Tools.Warn("USDZExportAsync does not support this material type: "+I.getClassName())}q.activeCamera&&v.exportCamera&&(g+=function(q,S){const b="Camera_"+q.uniqueId,C=hS(z.Matrix.RotationY(Math.PI).multiply(q.getWorldMatrix()));if(q.mode===T.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${C}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.kb.toPrecision(S.precision)}, ${q.maxZ.toPrecision(S.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(q.orthoLeft||1)+Math.abs(q.orthoRight||1))).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(q.orthoTop||1)+Math.abs(q.orthoBottom||1))).toPrecision(S.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const z=q.getEngine().getAspectRatio(q),v=S.cameraSensorWidth||35;return`def Camera "${b}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${C}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${q.kb.toPrecision(S.precision)}, ${q.maxZ.toPrecision(S.precision)})\n\t\t\tfloat focalLength = ${(v/(2*Math.tan(.5*q.fov))).toPrecision(S.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(v*z).toPrecision(S.precision)}\n\t\t\tfloat verticalAperture = ${(v/z).toPrecision(S.precision)}            \n\t\t}\n\t\n\t`}}(q.activeCamera,v)),g+="\n            }\n        }\n    }";const I={};g+=function(q,S,b){const z=[];for(const C in q){const v=q[C];z.push(qb(v,S,b))}return`\n    def "Materials"\n{\n${z.join("")}\n}\n\n`}(r,I,v),U[v.modelFileName]=fflate.strToU8(g);for(const z in I){const q=I[z],S=q.getSize(),b=await q.readPixels();if(!b)throw new Error("Texture data is not available");const C=await B.DumpTools.DumpDataAsync(S.width,S.height,b,"image/png",void 0,!1,!0);U[`textures/Texture_${z}.png`]=new Uint8Array(C).slice()}let V=0;for(const z in U){const q=U[z];if(!q)continue;V+=34+z.length;const S=63&V;if(4!==S){const b=new Uint8Array(64-S);U[z]=[q,{extra:{12345:b}}]}V=q.length}return fflate.zipSync(U,{level:0})}}}]);