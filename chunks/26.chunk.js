"use strict";(self.zy41qorie9=self.zy41qorie9||[]).push([[26],{12837:(Z,l,C)=>{C.r(l),C.d(l,{EXT_materials_diffuse_roughness:()=>Il,EXT_mesh_gpu_instancing:()=>QZ,GLTF2Export:()=>uZ,GLTFData:()=>J,KHR_draco_mesh_compression:()=>Cl,KHR_lights_punctual:()=>Wl,KHR_materials_anisotropy:()=>El,KHR_materials_clearcoat:()=>al,KHR_materials_diffuse_transmission:()=>Yl,KHR_materials_dispersion:()=>Sl,KHR_materials_emissive_strength:()=>sl,KHR_materials_ior:()=>nl,KHR_materials_iridescence:()=>Ul,KHR_materials_sheen:()=>rl,KHR_materials_specular:()=>ol,KHR_materials_transmission:()=>Rl,KHR_materials_unlit:()=>Vl,KHR_materials_volume:()=>jl,KHR_texture_transform:()=>Ol,OBJExport:()=>K,STLExport:()=>Dl,USDZExportAsync:()=>lC,_ConvertToGLTFPBRMetallicRoughness:()=>k,_SolveMetallic:()=>R,__IGLTFExporterExtension:()=>f});var B=C(12442),x=C(12248),b=C(12769);class K{static OBJ(Z,l,C,K){const f=[];let W=1,J=1;l&&(C||(C="mat"),f.push("mtllib "+C+".mtl"));for(let d=0;d<Z.length;d++){const C=Z[d],E=C.name||`mesh${d}}`;f.push(`o ${E}`);let G=null;if(K){const Z=C.Fb(!0);G=new B.Matrix,Z.invertToRef(G),C.bakeTransformIntoVertices(Z)}if(l){const Z=C.material;Z&&f.push("usemtl "+Z.id)}const a=C.nb;if(!a){x.Tools.Warn("No geometry is present on the mesh");continue}const q=a.getVerticesData("position"),z=a.getVerticesData("normal"),Y=a.getVerticesData("uv"),P=a.cb();let S=0,i=0;if(!q||!P){x.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const s=Z[0].cZ().useRightHandedSystem?1:-1;for(let Z=0;Z<q.length;Z+=3)f.push("v "+q[Z]*s+" "+q[Z+1]+" "+q[Z+2]),S++;if(null!=z)for(let Z=0;Z<z.length;Z+=3)f.push("vn "+z[Z]*s+" "+z[Z+1]+" "+z[Z+2]);if(null!=Y)for(let Z=0;Z<Y.length;Z+=2)f.push("vt "+Y[Z]+" "+Y[Z+1]),i++;const F=["","",""],n=(C.material||C.cZ().defaultMaterial)._getEffectiveOrientation(C),[c,U]=n===b.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let Z=0;Z<P.length;Z+=3){const l=[String(P[Z]+W),String(P[Z+c]+W),String(P[Z+U]+W)],C=[String(P[Z]+J),String(P[Z+c]+J),String(P[Z+U]+J)],B=l,x=null!=Y?C:F,b=null!=z?l:F;f.push("f "+B[0]+"/"+x[0]+"/"+b[0]+" "+B[1]+"/"+x[1]+"/"+b[1]+" "+B[2]+"/"+x[2]+"/"+b[2])}K&&G&&C.bakeTransformIntoVertices(G),W+=S,J+=i}return f.join("\n")}static MTL(Z){const l=[],C=Z.material;l.push("newmtl mat1"),l.push("  Ns "+C.specularPower.toFixed(4)),l.push("  Ni 1.5000"),l.push("  d "+C.alpha.toFixed(4)),l.push("  Tr 0.0000"),l.push("  Tf 1.0000 1.0000 1.0000"),l.push("  illum 2"),l.push("  Ka "+C.ambientColor.r.toFixed(4)+" "+C.ambientColor.g.toFixed(4)+" "+C.ambientColor.b.toFixed(4)),l.push("  Kd "+C.diffuseColor.r.toFixed(4)+" "+C.diffuseColor.g.toFixed(4)+" "+C.diffuseColor.b.toFixed(4)),l.push("  Ks "+C.specularColor.r.toFixed(4)+" "+C.specularColor.g.toFixed(4)+" "+C.specularColor.b.toFixed(4)),l.push("  Ke "+C.emissiveColor.r.toFixed(4)+" "+C.emissiveColor.g.toFixed(4)+" "+C.emissiveColor.b.toFixed(4));C.ambientTexture&&l.push("  map_Ka "+C.ambientTexture.name),C.diffuseTexture&&l.push("  map_Kd "+C.diffuseTexture.name),C.specularTexture&&l.push("  map_Ks "+C.specularTexture.name),C.bumpTexture&&l.push("  map_bump -imfchan z "+C.bumpTexture.name),C.opacityTexture&&l.push("  map_d "+C.opacityTexture.name);return l.join("\n")}}var f=0,W=C(12298);class J{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Z in this.files){const l=this.files[Z],C=new Blob([l],{type:(0,W.g)(Z)});x.Tools.Download(C,Z)}}}var d=C(12530),E=C(12844),G=C(12855),a=C(12871),q=C(12589),z=C(12295),Y=C(12494),P=C(12460);const S=P.HighestCommonFactor,i={...P,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:S};var s=C(12693),F=C(12423),n=C(12897),c=C(12906),U=C(12689);const t=1e-6,r=new Y.Sl(.04,.04,.04),e=1024,o=Y.Sl.White(),v=Y.Sl.Black();function R(Z,l,C){if(l<r.r)return 0;const B=r.r,x=Z*C/(1-r.r)+l-2*r.r,b=x*x-4*B*(r.r-l);return i.Clamp((-x+Math.sqrt(b))/(2*B),0,1)}function k(Z){const l=Z.diffuseColor.toLinearSpace(Z.cZ().getEngine().useExactSrgbConversions).scale(.5),C=Z.alpha,x=function(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new B.Vector2(0,1),C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new B.Vector2(0,.1),x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new B.Vector2(0,.1),b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new B.Vector2(1300,.1);return function(Z,l,C,B,x){return(1-Z)*(1-Z)*(1-Z)*l+3*(1-Z)*(1-Z)*Z*C+3*(1-Z)*Z*Z*B+Z*Z*Z*x}(Math.pow(Z/b.x,.333333),l.y,C.y,x.y,b.y)}(i.Clamp(Z.specularPower,0,e));return{baseColorFactor:[l.r,l.g,l.b,C],metallicFactor:0,roughnessFactor:x}}function V(Z,l){l.needAlphaBlending()?Z.alphaMode="BLEND":l.needAlphaTesting()&&(Z.alphaMode="MASK",Z.alphaCutoff=l.alphaCutOff)}function g(Z,l,C){const B=new Uint8Array(Z*l*4);for(let x=0;x<B.length;x+=4)B[x]=B[x+1]=B[x+2]=B[x+3]=255;return n.e.CreateRGBATexture(B,Z,l,C)}function j(Z){if(Z instanceof Uint8Array){const l=Z.length,C=new Float32Array(Z.length);for(let B=0;B<l;++B)C[B]=Z[B]/255;return C}if(Z instanceof Float32Array)return Z;throw new Error("Unsupported pixel format!")}class M{constructor(Z){this._exporter=Z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Z){return Z?this._textureMap.get(Z)??null:null}async exportStandardMaterialAsync(Z,l,C){const B=k(Z),b={name:Z.name};if(null==Z.Ub||Z.Ub||(Z.twoSidedLighting||x.Tools.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),b.doubleSided=!0),C){const C=[],x=Z.diffuseTexture;x&&C.push(this.exportTextureAsync(x,l).then((Z=>{Z&&(B.baseColorTexture=Z)})));const K=Z.bumpTexture;K&&C.push(this.exportTextureAsync(K,l).then((Z=>{Z&&(b.normalTexture=Z,1!==K.level&&(b.normalTexture.scale=K.level))})));const f=Z.emissiveTexture;f&&(b.emissiveFactor=[1,1,1],C.push(this.exportTextureAsync(f,l).then((Z=>{Z&&(b.emissiveTexture=Z)}))));const W=Z.ambientTexture;W&&C.push(this.exportTextureAsync(W,l).then((Z=>{if(Z){const l={index:Z.index};b.occlusionTexture=l}}))),C.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(C))}(Z.alpha<1||Z.opacityTexture)&&(Z.alphaMode===c.c.ALPHA_COMBINE?b.alphaMode="BLEND":x.Tools.Warn(Z.name+": glTF 2.0 does not support alpha mode: "+Z.alphaMode.toString())),Z.emissiveColor&&!Z.emissiveColor.equalsWithEpsilon(v,t)&&(b.emissiveFactor=Z.emissiveColor.Yb()),b.pbrMetallicRoughness=B,V(b,Z),await this._finishMaterialAsync(b,Z,l);const K=this._exporter._materials;return K.push(b),K.length-1}async _finishMaterialAsync(Z,l,C){const B=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Z,l),x=[];for(const b of B)x.push(this.exportTextureAsync(b,C));await Promise.all(x),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Z,l)}async _getImageDataAsync(Z,l,B,x){const b=c.c.TEXTURETYPE_UNSIGNED_BYTE,K=this._exporter._babylonScene,f=K.getEngine(),W=f.createRawTexture(Z,l,B,c.c.TEXTUREFORMAT_RGBA,!1,!0,F.c.NEAREST_SAMPLINGMODE,null,b);f.isWebGPU?await C.e(51).then(C.bind(C,14615)):await C.e(52).then(C.bind(C,14623)),await s.l.ApplyPostProcess("pass",W,K,b,c.c.TEXTURE_NEAREST_SAMPLINGMODE,c.c.TEXTUREFORMAT_RGBA);const J=await f._readTexturePixels(W,l,B);return await U.DumpTools.DumpDataAsync(l,B,J,x,void 0,!0,!0)}_resizeTexturesToSameDimensions(Z,l,C){const B=Z?Z.getSize():{width:0,height:0},x=l?l.getSize():{width:0,height:0};let b,K;return B.width<x.width?(b=Z&&Z instanceof F.c?s.l.CreateResizedCopy(Z,x.width,x.height,!0):g(x.width,x.height,C),K=l):B.width>x.width?(K=l&&l instanceof F.c?s.l.CreateResizedCopy(l,B.width,B.height,!0):g(B.width,B.height,C),b=Z):(b=Z,K=l),{texture1:b,texture2:K}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,l,C,B){const x=new Array;if(!Z&&!l)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const b=Z?Z.cZ():l?l.cZ():null;if(b){var K;const f=this._resizeTexturesToSameDimensions(Z,l,b),W=null===(K=f.texture1)||void 0===K?void 0:K.getSize();let J,d;const E=W.width,G=W.height,a=await f.texture1.readPixels(),q=await f.texture2.readPixels();if(!a)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(J=j(a),!q)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");d=j(q);const z=d.byteLength,P=new Uint8Array(z),S=new Uint8Array(z),i=4,s=v;let F=0,n=0;for(let Z=0;Z<G;++Z)for(let l=0;l<E;++l){const B=(E*Z+l)*i,x={diffuseColor:new Y.Sl(J[B],J[B+1],J[B+2]).toLinearSpace(b.getEngine().useExactSrgbConversions).multiply(C.diffuseColor),specularColor:new Y.Sl(d[B],d[B+1],d[B+2]).toLinearSpace(b.getEngine().useExactSrgbConversions).multiply(C.specularColor),glossiness:d[B+3]*C.glossiness},K=this._convertSpecularGlossinessToMetallicRoughness(x);s.r=Math.max(s.r,K.baseColor.r),s.g=Math.max(s.g,K.baseColor.g),s.b=Math.max(s.b,K.baseColor.b),F=Math.max(F,K.metallic),n=Math.max(n,K.roughness),S[B]=255*K.baseColor.r,S[B+1]=255*K.baseColor.g,S[B+2]=255*K.baseColor.b,S[B+3]=f.texture1.Pb?255*J[B+3]:255,P[B]=0,P[B+1]=255*K.roughness,P[B+2]=255*K.metallic,P[B+3]=255}const c={baseColor:s,metallic:F,roughness:n};let U=!1,r=!1;for(let Z=0;Z<G;++Z)for(let l=0;l<E;++l){const C=(E*Z+l)*i;S[C]/=c.baseColor.r>t?c.baseColor.r:1,S[C+1]/=c.baseColor.g>t?c.baseColor.g:1,S[C+2]/=c.baseColor.b>t?c.baseColor.b:1;const B=Y.Sl.FromInts(S[C],S[C+1],S[C+2]).toGammaSpace(b.getEngine().useExactSrgbConversions);S[C]=255*B.r,S[C+1]=255*B.g,S[C+2]=255*B.b,B.equalsWithEpsilon(o,t)||(r=!0),P[C+1]/=c.roughness>t?c.roughness:1,P[C+2]/=c.metallic>t?c.metallic:1;Y.Sl.FromInts(255,P[C+1],P[C+2]).equalsWithEpsilon(o,t)||(U=!0)}return U&&x.push(this._getImageDataAsync(P,E,G,B).then((Z=>{c.metallicRoughnessTextureData=Z}))),r&&x.push(this._getImageDataAsync(S,E,G,B).then((Z=>{c.baseColorTextureData=Z}))),await Promise.all(x).then((()=>c))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Z){const l=this._getPerceivedBrightness(Z.diffuseColor),C=this._getPerceivedBrightness(Z.specularColor),B=1-this._getMaxComponent(Z.specularColor),x=R(l,C,B),b=Z.diffuseColor.scale(B/(1-r.r)/Math.max(1-x)),K=Z.specularColor.zl(r.scale(1-x)).scale(1/Math.max(x));let f=Y.Sl.Lerp(b,K,x*x);f=f.clampToRef(0,1,f);return{baseColor:f,metallic:x,roughness:1-Z.glossiness}}_getPerceivedBrightness(Z){return Z?Math.sqrt(.299*Z.r*Z.r+.587*Z.g*Z.g+.114*Z.b*Z.b):0}_getMaxComponent(Z){return Z?Math.max(Z.r,Math.max(Z.g,Z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Z,l,C,B){const x=[],b={baseColor:Z._albedoColor,metallic:Z._metallic,roughness:Z._roughness};if(B){Z._albedoTexture&&x.push(this.exportTextureAsync(Z._albedoTexture,l).then((Z=>{Z&&(C.baseColorTexture=Z)})));const B=Z._metallicTexture;B&&x.push(this.exportTextureAsync(B,l).then((Z=>{Z&&(C.metallicRoughnessTexture=Z)})))}return x.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(x)),b}_getTextureSampler(Z){const l={};if(!Z||!(Z instanceof F.c))return l;const C=this._getGLTFTextureWrapMode(Z.wrapU);10497!==C&&(l.wrapS=C);const B=this._getGLTFTextureWrapMode(Z.wrapV);switch(10497!==B&&(l.wrapT=B),Z.samplingMode){case F.c.LINEAR_LINEAR:l.magFilter=9729,l.minFilter=9729;break;case F.c.LINEAR_NEAREST:l.magFilter=9729,l.minFilter=9728;break;case F.c.NEAREST_LINEAR:l.magFilter=9728,l.minFilter=9729;break;case F.c.NEAREST_LINEAR_MIPLINEAR:l.magFilter=9728,l.minFilter=9987;break;case F.c.NEAREST_NEAREST:l.magFilter=9728,l.minFilter=9728;break;case F.c.NEAREST_LINEAR_MIPNEAREST:l.magFilter=9728,l.minFilter=9985;break;case F.c.LINEAR_NEAREST_MIPNEAREST:l.magFilter=9729,l.minFilter=9984;break;case F.c.LINEAR_NEAREST_MIPLINEAR:l.magFilter=9729,l.minFilter=9986;break;case F.c.NEAREST_NEAREST_MIPLINEAR:l.magFilter=9728,l.minFilter=9986;break;case F.c.LINEAR_LINEAR_MIPLINEAR:l.magFilter=9729,l.minFilter=9987;break;case F.c.LINEAR_LINEAR_MIPNEAREST:l.magFilter=9729,l.minFilter=9985;break;case F.c.NEAREST_NEAREST_MIPNEAREST:l.magFilter=9728,l.minFilter=9984}return l}_getGLTFTextureWrapMode(Z){switch(Z){case F.c.WRAP_ADDRESSMODE:return 10497;case F.c.CLAMP_ADDRESSMODE:return 33071;case F.c.MIRROR_ADDRESSMODE:return 33648;default:return x.Tools.Error(`Unsupported Texture Wrap Mode ${Z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Z,l,C,B){const x={diffuseColor:Z._albedoColor,specularColor:Z._reflectivityColor,glossiness:Z._microSurface},b=Z._albedoTexture,K=Z._reflectivityTexture,f=Z._useMicroSurfaceFromReflectivityMapAlpha;if(K&&!f)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((b||K)&&B){this._exporter._materialNeedsUVsSet.add(Z);const B=this._exportTextureSampler(b||K),f=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(b,K,x,l),W=this._exporter._textures;if(f.baseColorTextureData){const Z=this._exportImage(`baseColor${W.length}`,l,f.baseColorTextureData);C.baseColorTexture=this._exportTextureInfo(Z,B,null===b||void 0===b?void 0:b.coordinatesIndex)}if(f.metallicRoughnessTextureData){const Z=this._exportImage(`metallicRoughness${W.length}`,l,f.metallicRoughnessTextureData);C.metallicRoughnessTexture=this._exportTextureInfo(Z,B,null===K||void 0===K?void 0:K.coordinatesIndex)}return f}return this._convertSpecularGlossinessToMetallicRoughness(x)}async exportPBRMaterialAsync(Z,l,C){const B={},x={name:Z.name},b=Z.isMetallicWorkflow();if(b){const l=Z._albedoColor,C=Z.alpha;l&&(B.baseColorFactor=[l.r,l.g,l.b,C])}const K=b?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Z,l,B,C):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Z,l,B,C);await this._setMetallicRoughnessPbrMaterialAsync(K,Z,x,B,l,C),await this._finishMaterialAsync(x,Z,l);const f=this._exporter._materials;return f.push(x),f.length-1}async _setMetallicRoughnessPbrMaterialAsync(Z,l,C,B,b,K){if(V(C,l),Z.baseColor.equalsWithEpsilon(o,t)&&i.WithinEpsilon(l.alpha,1,t)||(B.baseColorFactor=[Z.baseColor.r,Z.baseColor.g,Z.baseColor.b,l.alpha]),null!=Z.metallic&&1!==Z.metallic&&(B.metallicFactor=Z.metallic),null!=Z.roughness&&1!==Z.roughness&&(B.roughnessFactor=Z.roughness),null==l.Ub||l.Ub||(l._twoSidedLighting||x.Tools.Warn(l.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),C.doubleSided=!0),K){const Z=[],B=l._bumpTexture;B&&Z.push(this.exportTextureAsync(B,b).then((Z=>{Z&&(C.normalTexture=Z,1!==B.level&&(C.normalTexture.scale=B.level))})));const x=l._ambientTexture;x&&Z.push(this.exportTextureAsync(x,b).then((Z=>{if(Z){const B={index:Z.index,texCoord:Z.texCoord,extensions:Z.extensions};C.occlusionTexture=B;const x=l._ambientTextureStrength;x&&(B.strength=x)}})));const K=l._emissiveTexture;K&&Z.push(this.exportTextureAsync(K,b).then((Z=>{Z&&(C.emissiveTexture=Z)}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(l),await Promise.all(Z))}const f=l._emissiveColor;f.equalsWithEpsilon(v,t)||(C.emissiveFactor=f.Yb()),C.pbrMetallicRoughness=B}_getPixelsFromTextureAsync(Z){return function(Z){switch(Z){case c.c.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case c.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case c.c.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case c.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case c.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case c.c.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case c.c.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case c.c.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case c.c.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case c.c.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case c.c.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.c.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case c.c.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Z.textureFormat)?(0,s.h)(Z,Z._texture.width,Z._texture.height):(Z.textureType,c.c.TEXTURETYPE_UNSIGNED_BYTE,Z.readPixels())}async exportTextureAsync(Z,l){const C=this._exporter._extensionsPreExportTextureAsync("exporter",Z,l);return C?await C.then((async C=>C?await this._exportTextureInfoAsync(C,l):await this._exportTextureInfoAsync(Z,l))):await this._exportTextureInfoAsync(Z,l)}async _exportTextureInfoAsync(Z,l){let C=this._textureMap.get(Z);if(!C){const B=await this._getPixelsFromTextureAsync(Z);if(!B)return null;const b=this._exportTextureSampler(Z),K=Z.mimeType;if(K)switch(K){case"image/jpeg":case"image/png":case"image/webp":l=K;break;default:x.Tools.Warn(`Unsupported media type: ${K}. Exporting texture as PNG.`)}const f=this._internalTextureToImage,W=Z.getInternalTexture().uniqueId;f[W]||(f[W]={});let J=f[W][l];if(void 0===J){const C=Z.getSize();J=(async()=>{const x=await this._getImageDataAsync(B,C.width,C.height,l);return this._exportImage(Z.name,l,x)})(),f[W][l]=J}C=this._exportTextureInfo(await J,b,Z.coordinatesIndex),this._textureMap.set(Z,C),this._exporter._extensionsPostExportTextures("exporter",C,Z)}return C}_exportImage(Z,l,C){const B=this._exporter._images;let b;if(this._exporter._shouldUseGlb){b={name:Z,mimeType:l,bufferView:void 0};const B=this._exporter._bufferManager.createBufferView(new Uint8Array(C));this._exporter._bufferManager.setBufferView(b,B)}else{const K=Z.replace(/\.\/|\/|\.\\|\\/g,"_"),f=function(Z){switch(Z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(l);let W=K+f;B.some((Z=>Z.uri===W))&&(W=`${K}_${x.Tools.RandomId()}${f}`),b={name:Z,uri:W},this._exporter._imageData[W]={data:C,mimeType:l}}return B.push(b),B.length-1}_exportTextureInfo(Z,l,C){const B=this._exporter._textures;let x=B.findIndex((C=>C.sampler==l&&C.source===Z));-1===x&&(x=B.length,B.push({source:Z,sampler:l}));const b={index:x};return C&&(b.texCoord=C),b}_exportTextureSampler(Z){const l=this._getTextureSampler(Z),C=this._exporter._samplers,B=C.findIndex((Z=>Z.minFilter===l.minFilter&&Z.magFilter===l.magFilter&&Z.wrapS===l.wrapS&&Z.wrapT===l.wrapT));return-1!==B?B:(C.push(l),C.length-1)}}var I=C(12544),w=C(12263),O=C(12912),D=C(12451);const y=B.ql.Zero(),X=B.Quaternion.Identity(),T=B.ql.One(),u=new B.ql(-1,1,1);function H(Z,l){const{byteOffset:C,byteStride:B,type:x,normalized:b}=Z,K=Z.getSize(),f=l.reduce(((Z,l)=>l.getTotalVertices()>Z?l.getTotalVertices():Z),-Number.MAX_VALUE);return{byteOffset:C,byteStride:B,componentCount:K,type:x,count:f*K,normalized:b,totalVertices:f,kind:Z.getKind()}}function Q(Z){switch(Z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function h(Z){switch(Z){case d.h.PositionKind:case d.h.NormalKind:case d.h.TangentKind:case d.h.ColorKind:case d.h.MatricesIndicesKind:case d.h.MatricesIndicesExtraKind:case d.h.MatricesWeightsKind:case d.h.MatricesWeightsExtraKind:case d.h.UVKind:case d.h.UV2Kind:case d.h.UV3Kind:case d.h.UV4Kind:case d.h.UV5Kind:case d.h.UV6Kind:return!0}return!1}function A(Z){switch(Z){case b.b.TriangleFillMode:return 4;case b.b.TriangleStripDrawMode:return 5;case b.b.TriangleFanDrawMode:return 6;case b.b.PointListDrawMode:case b.b.PointFillMode:return 0;case b.b.LineLoopDrawMode:return 2;case b.b.LineListDrawMode:return 1;case b.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Z}`)}function L(Z){const l=Math.sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);l>0&&(Z.x/=l,Z.y/=l,Z.z/=l)}function p(Z){return Z.x*=-1,Z}function N(Z){if(Z.x*Z.x+Z.y*Z.y>.5){const l=Math.abs(Z.x),C=Math.abs(Z.y);if(l>C){const C=Math.sign(Z.x);Z.x=l,Z.y*=-C,Z.z*=-C,Z.w*=C}else{const l=Math.sign(Z.y);Z.x*=-l,Z.y=C,Z.z*=l,Z.w*=-l}}else{const l=Math.abs(Z.z),C=Math.abs(Z.w);if(l>C){const C=Math.sign(Z.z);Z.x*=-C,Z.y*=C,Z.z=l,Z.w*=-C}else{const l=Math.sign(Z.w);Z.x*=l,Z.y*=-l,Z.z*=-l,Z.w=C}}return Z}function mZ(Z){Z.rb(-Z.z,Z.w,Z.x,-Z.y)}function ZZ(Z,l){const C=B.ql.FromArrayToRef(l.translation||[0,0,0],0,B.TmpVectors.ql[0]),x=B.Quaternion.FromArrayToRef(l.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[0]),b=B.Matrix.ComposeToRef(T,x,C,B.TmpVectors.Matrix[0]),K=B.ql.FromArrayToRef(Z.translation||[0,0,0],0,B.TmpVectors.ql[2]),f=B.Quaternion.FromArrayToRef(Z.rotation||[0,0,0,1],0,B.TmpVectors.Quaternion[1]),W=B.Matrix.ComposeToRef(T,f,K,B.TmpVectors.Matrix[1]);b.multiplyToRef(W,W),W.decompose(void 0,x,C),C.equalsWithEpsilon(y,D.e)?delete l.translation:l.translation=C.Yb(),x.equalsWithEpsilon(X,D.e)?delete l.rotation:l.rotation=x.Yb(),l.scale&&delete l.scale}function lZ(Z,l){if(!(l instanceof E.e))return!1;if(!(1===l.getChildren().length&&0===Z.getChildren().length&&Z.parent===l))return!1;const C=Z.cZ(),B=Z instanceof O.b&&!C.useRightHandedSystem?u:T;return!!l.eb.equalsWithEpsilon(B,D.e)||(w.e.Warn(`Cannot collapse node ${Z.name} into parent node ${l.name} with modified scaling.`),!1)}function CZ(Z){if(Z instanceof Array){const l=new Float32Array(Z);return new Uint8Array(l.buffer,l.byteOffset,l.byteLength)}return ArrayBuffer.isView(Z)?new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength):new Uint8Array(Z)}function BZ(Z,l){for(const[C,B]of Object.entries(Z)){const x=l[C];(Array.isArray(B)&&Array.isArray(x)&&xZ(B,x)||B===x)&&delete Z[C]}return Z}function xZ(Z,l){return Z.length===l.length&&Z.every(((Z,C)=>Z===l[C]))}const bZ=B.Matrix.Compose(new B.ql(-1,1,1),B.Quaternion.Identity(),B.ql.Zero());function KZ(Z,l){if(!(Z instanceof E.e))return!1;if(l){if(!Z.getWorldMatrix().equalsWithEpsilon(B.Matrix.IdentityReadOnly,D.e))return!1}else{if(!Z.getWorldMatrix().multiplyToRef(bZ,B.TmpVectors.Matrix[0]).equalsWithEpsilon(B.Matrix.IdentityReadOnly,D.e))return!1}return!(Z instanceof G.e&&Z.nb)}const fZ=new Map([[Int8Array,(Z,l,C)=>Z.setInt8(l,C)],[Uint8Array,(Z,l,C)=>Z.setUint8(l,C)],[Uint8ClampedArray,(Z,l,C)=>Z.setUint8(l,C)],[Int16Array,(Z,l,C)=>Z.setInt16(l,C,!0)],[Uint16Array,(Z,l,C)=>Z.setUint16(l,C,!0)],[Int32Array,(Z,l,C)=>Z.setInt32(l,C,!0)],[Uint32Array,(Z,l,C)=>Z.setUint32(l,C,!0)],[Float32Array,(Z,l,C)=>Z.setFloat32(l,C,!0)],[Float64Array,(Z,l,C)=>Z.setFloat64(l,C,!0)]]);class WZ{writeTypedArray(Z){this._checkGrowBuffer(Z.byteLength);const l=fZ.get(Z.constructor);for(let C=0;C<Z.length;C++)l(this._dataView,this._byteOffset,Z[C]),this._byteOffset+=Z.BYTES_PER_ELEMENT}constructor(Z){this._data=new Uint8Array(Z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Z),this._byteOffset++}writeInt8(Z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Z),this._byteOffset++}writeInt16(Z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Z,!0),this._byteOffset+=2}writeUInt16(Z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Z,!0),this._byteOffset+=2}writeInt32(Z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Z,!0),this._byteOffset+=4}writeUInt32(Z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat32(Z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat64(Z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Z,!0),this._byteOffset+=8}_checkGrowBuffer(Z){const l=this.byteOffset+Z;if(l>this._data.byteLength){const Z=new Uint8Array(2*l);Z.set(this._data),this._data=Z,this._dataView=new DataView(this._data.buffer)}}}function JZ(Z){return Z%4===0?4:Z%2===0?2:1}class dZ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Z){let l=0;this._bufferViewToData.forEach((Z=>{l+=Z.byteLength}));const C=new WZ(l),B=Array.from(this._bufferViewToData.keys()).sort(((Z,l)=>JZ(l.byteLength)-JZ(Z.byteLength)));for(const x of B){x.byteOffset=C.byteOffset,Z.push(x);const l=Z.length-1,B=this.getPropertiesWithBufferView(x);for(const Z of B)Z.bufferView=l;C.writeTypedArray(this._bufferViewToData.get(x)),this._bufferViewToData.delete(x)}return C.getOutputData()}createBufferView(Z,l){const C={buffer:0,byteOffset:void 0,byteLength:Z.byteLength,byteStride:l};return this._bufferViewToData.set(C,Z),C}createAccessor(Z,l,C,B,x,b,K){this._verifyBufferView(Z);const f={bufferView:void 0,componentType:C,count:B,type:l,min:null===b||void 0===b?void 0:b.min,max:null===b||void 0===b?void 0:b.max,normalized:K,byteOffset:x};return this.setBufferView(f,Z),this._accessorToBufferView.set(f,Z),f}setBufferView(Z,l){this._verifyBufferView(l);this.getPropertiesWithBufferView(l).push(Z)}removeBufferView(Z){const l=this.getPropertiesWithBufferView(Z);for(const C of l)void 0!==C.bufferView&&delete C.bufferView;this._bufferViewToData.delete(Z),this._bufferViewToProperties.delete(Z),this._accessorToBufferView.forEach(((l,C)=>{l===Z&&(void 0!==C.byteOffset&&delete C.byteOffset,this._accessorToBufferView.delete(C))}))}getBufferView(Z){const l=this._accessorToBufferView.get(Z);return this._verifyBufferView(l),l}getPropertiesWithBufferView(Z){return this._verifyBufferView(Z),this._bufferViewToProperties.set(Z,this._bufferViewToProperties.get(Z)??[]),this._bufferViewToProperties.get(Z)}getData(Z){return this._verifyBufferView(Z),this._bufferViewToData.get(Z)}_verifyBufferView(Z){if(void 0===Z||!this._bufferViewToData.has(Z))throw new Error(`BufferView ${Z} not found in BufferManager.`)}}var EZ,GZ=C(12880),aZ=C(12892),qZ=C(12914),zZ=C(12811),YZ=C(12942),PZ=C(12954),SZ=C(12874),iZ=C(12960);!function(Z){Z[Z.INTANGENT=0]="INTANGENT",Z[Z.OUTTANGENT=1]="OUTTANGENT"}(EZ||(EZ={}));class sZ{static _IsTransformable(Z){return Z&&(Z instanceof E.e||Z instanceof GZ.d||Z instanceof iZ.d)}static _CreateNodeAnimation(Z,l,C,B,b){if(this._IsTransformable(Z)){const K=[],f=[],W=l.getKeys(),J=sZ._CalculateMinMaxKeyFrames(W),d=sZ._DeduceInterpolation(W,C,B),E=d.interpolationType,G=d.shouldBakeAnimation;if(G?sZ._CreateBakedAnimation(Z,l,C,J.min,J.max,l.framePerSecond,b,K,f,J,B):"LINEAR"===E||"STEP"===E?sZ._CreateLinearOrStepAnimation(Z,l,C,K,f,B):"CUBICSPLINE"===E?sZ._CreateCubicSplineAnimation(Z,l,C,K,f,B):sZ._CreateBakedAnimation(Z,l,C,J.min,J.max,l.framePerSecond,b,K,f,J,B),K.length&&f.length){return{inputs:K,outputs:f,samplerInterpolation:E,inputsMin:G?J.min:x.Tools.FloatRound(J.min/l.framePerSecond),inputsMax:G?J.max:x.Tools.FloatRound(J.max/l.framePerSecond)}}}return null}static _DeduceAnimationInfo(Z){let l=null,C="VEC3",B=!1;const b=Z.targetProperty.split(".");switch(b[0]){case"eb":l="scale";break;case"position":l="translation";break;case"rotation":C="VEC4",l="rotation";break;case"rotationQuaternion":C="VEC4",B=!0,l="rotation";break;case"influence":C="SCALAR",l="weights";break;default:x.Tools.Error(`Unsupported animatable property ${b[0]}`)}return l?{animationChannelTargetPath:l,dataAccessorType:C,useQuaternion:B}:(x.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Z,l,C,B,x,b,K,f,W,J,d){let E;if(sZ._IsTransformable(Z)&&Z.animations)for(const G of Z.animations){if(d&&!d(G))continue;const x=sZ._DeduceAnimationInfo(G);x&&(E={name:G.name,samplers:[],channels:[]},sZ._AddAnimation(`${G.name}`,G.hasRunningRuntimeAnimations?l:E,Z,G,x.dataAccessorType,x.animationChannelTargetPath,B,b,K,f,x.useQuaternion,W,J),E.samplers.length&&E.channels.length&&C.push(E))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Z,l,C,B,x,b,K,f,W,J,d){let E;if(Z instanceof SZ.b){const x=Z.morphTargetManager;if(x)for(let G=0;G<x.numTargets;++G){const a=x.getTarget(G);for(const q of a.animations){if(d&&!d(q))continue;const a=new YZ.b(`${q.name}`,"influence",q.framePerSecond,q.dataType,q.loopMode,q.enableBlending),z=[],Y=q.getKeys();for(let Z=0;Z<Y.length;++Z){const l=Y[Z];for(let Z=0;Z<x.numTargets;++Z)Z==G?z.push(l):z.push({frame:l.frame,value:0})}a.setKeys(z);const P=sZ._DeduceAnimationInfo(a);P&&(E={name:a.name,samplers:[],channels:[]},sZ._AddAnimation(q.name,q.hasRunningRuntimeAnimations?l:E,Z,a,P.dataAccessorType,P.animationChannelTargetPath,B,b,K,f,P.useQuaternion,W,J,x.numTargets),E.samplers.length&&E.channels.length&&C.push(E))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Z,l,C,B,x,b,K,f,W){let J;if(Z.animationGroups){const E=Z.animationGroups;for(const G of E){const E=new Map,a=new Map,q=new Set,z=G.to-G.from;J={name:G.name,channels:[],samplers:[]};for(let l=0;l<G.targetedAnimations.length;++l){const z=G.targetedAnimations[l],Y=z.target,P=z.animation;if(W&&!W(P))continue;const S=f.has(Y);if(this._IsTransformable(Y)||1===Y.length&&this._IsTransformable(Y[0])){const Z=sZ._DeduceAnimationInfo(z.animation);if(Z){const l=this._IsTransformable(Y)?Y:this._IsTransformable(Y[0])?Y[0]:null;l&&sZ._AddAnimation(`${P.name}`,J,l,P,Z.dataAccessorType,Z.animationChannelTargetPath,C,B,x,b,Z.useQuaternion,K,S)}}else if(Y instanceof PZ.e||1===Y.length&&Y[0]instanceof PZ.e){if(sZ._DeduceAnimationInfo(z.animation)){const l=Y instanceof PZ.e?Y:Y[0];if(l){const C=Z.morphTargetManagers.find((Z=>{for(let C=0;C<Z.numTargets;++C)if(Z.getTarget(C)===l)return!0;return!1}));if(C){const B=Z.meshes.find((Z=>Z.morphTargetManager===C));var d;if(B)E.has(B)||E.set(B,new Map),null===(d=E.get(B))||void 0===d||d.set(l,P),q.add(B),a.set(B,P)}}}}}q.forEach((Z=>{const l=Z.morphTargetManager;let f=null;const W=[],d=a.get(Z).getKeys(),q=d.length;for(let C=0;C<q;++C)for(let B=0;B<l.numTargets;++B){const x=l.getTarget(B),b=E.get(Z);if(b){const l=b.get(x);l?(f||(f=new YZ.b(`${G.name}_${Z.name}_MorphWeightAnimation`,"influence",l.framePerSecond,YZ.b.ANIMATIONTYPE_FLOAT,l.loopMode,l.enableBlending)),W.push(l.getKeys()[C])):W.push({frame:G.from+z/q*C,value:x.influence,inTangent:d[0].inTangent?0:void 0,outTangent:d[0].outTangent?0:void 0})}}f.setKeys(W);const Y=sZ._DeduceAnimationInfo(f);Y&&sZ._AddAnimation(`${G.name}_${Z.name}_MorphWeightAnimation`,J,Z,f,Y.dataAccessorType,Y.animationChannelTargetPath,C,B,x,b,Y.useQuaternion,K,!1,null===l||void 0===l?void 0:l.numTargets)})),J.channels.length&&J.samplers.length&&l.push(J)}}}static _AddAnimation(Z,l,C,x,b,K,f,W,J,d,E,G,a,q){const z=sZ._CreateNodeAnimation(C,x,K,E,G);let Y,P,S,i,s,F;if(z){if(q){let Z=0,l=0;const C=[];for(;z.inputs.length>0;)l=z.inputs.shift(),Z%q==0&&C.push(l),Z++;z.inputs=C}const Z=f.get(C),x=new Float32Array(z.inputs);Y=W.createBufferView(x),P=W.createAccessor(Y,"SCALAR",5126,z.inputs.length,void 0,{min:[z.inputsMin],max:[z.inputsMax]}),d.push(P),S=d.length-1;const J=new B.Quaternion,E=new B.ql,G=new B.ql,n=C instanceof GZ.d,c=Q(b),U=new Float32Array(z.outputs.length*c);z.outputs.forEach((function(Z,l){let C=Z;switch(K){case"translation":a&&(B.ql.FromArrayToRef(Z,0,G),p(G),G.toArray(C));break;case"rotation":4===Z.length?B.Quaternion.FromArrayToRef(Z,0,J):(C=new Array(4),B.ql.FromArrayToRef(Z,0,E),B.Quaternion.FromEulerVectorToRef(E,J)),a&&(N(J),n&&mZ(J)),J.toArray(C)}U.set(C,l*c)})),Y=W.createBufferView(U),P=W.createAccessor(Y,b,5126,z.outputs.length),d.push(P),i=d.length-1,s={interpolation:z.samplerInterpolation,input:S,output:i},l.samplers.push(s),F={sampler:l.samplers.length-1,target:{node:Z,path:K}},l.channels.push(F)}}static _CreateBakedAnimation(Z,l,C,b,K,f,W,J,d,E,G){let a;const q=B.Quaternion.Identity();let z,Y=null,P=null,S=null,i=null,s=null,F=null;E.min=x.Tools.FloatRound(b/f);const n=l.getKeys();for(let B=0,c=n.length;B<c;++B){if(F=null,S=n[B],B+1<c)if(i=n[B+1],S.value.equals&&S.value.equals(i.value)||S.value===i.value){if(0!==B)continue;F=S.frame}else F=i.frame;else{if(s=n[B-1],S.value.equals&&S.value.equals(s.value)||S.value===s.value)continue;F=K}if(F)for(let B=S.frame;B<=F;B+=W){if(z=x.Tools.FloatRound(B/f),z===Y)continue;Y=z,P=z;const b={key:0,repeatCount:0,loopMode:l.loopMode};a=l._interpolate(B,b),sZ._SetInterpolatedValue(Z,a,z,l,C,q,J,d,G)}}P&&(E.max=P)}static _ConvertFactorToVector3OrQuaternion(Z,l,C,b,K){const f=sZ._GetBasePositionRotationOrScale(l,b,K),W=C.targetProperty.split("."),J=W?W[1]:"",d=K?B.Quaternion.il(f).normalize():B.ql.il(f);switch(J){case"x":case"y":case"z":d[J]=Z;break;case"w":d.w=Z;break;default:x.Tools.Error(`glTFAnimation: Unsupported component name "${J}"!`)}return d}static _SetInterpolatedValue(Z,l,C,x,b,K,f,W,J){let d;f.push(C),"weights"!==b?(x.dataType===YZ.b.ANIMATIONTYPE_FLOAT&&(l=this._ConvertFactorToVector3OrQuaternion(l,Z,x,b,J)),"rotation"===b?(J?K=l:(d=l,B.Quaternion.RotationYawPitchRollToRef(d.y,d.x,d.z,K)),W.push(K.Yb())):(d=l,W.push(d.Yb()))):W.push([l])}static _CreateLinearOrStepAnimation(Z,l,C,B,x,b){for(const K of l.getKeys())B.push(K.frame/l.framePerSecond),sZ._AddKeyframeValue(K,l,x,C,Z,b)}static _CreateCubicSplineAnimation(Z,l,C,B,x,b){l.getKeys().forEach((function(K){B.push(K.frame/l.framePerSecond),sZ._AddSplineTangent(EZ.INTANGENT,x,C,"CUBICSPLINE",K,b),sZ._AddKeyframeValue(K,l,x,C,Z,b),sZ._AddSplineTangent(EZ.OUTTANGENT,x,C,"CUBICSPLINE",K,b)}))}static _GetBasePositionRotationOrScale(Z,l,C){let x;if("rotation"===l)if(C){x=(Z.rotationQuaternion??B.Quaternion.Identity()).Yb()}else{x=(Z.rotation??B.ql.Zero()).Yb()}else if("translation"===l){x=(Z.position??B.ql.Zero()).Yb()}else{x=(Z.eb??B.ql.One()).Yb()}return x}static _AddKeyframeValue(Z,l,C,b,K,f){let W;const J=l.dataType;if(J===YZ.b.ANIMATIONTYPE_VECTOR3){let l=Z.value.Yb();if("rotation"===b){const Z=B.ql.il(l);l=B.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).Yb()}C.push(l)}else if(J===YZ.b.ANIMATIONTYPE_FLOAT){if("weights"===b)C.push([Z.value]);else if(W=this._ConvertFactorToVector3OrQuaternion(Z.value,K,l,b,f),W){if("rotation"===b){const Z=f?W:B.Quaternion.RotationYawPitchRoll(W.y,W.x,W.z).normalize();C.push(Z.Yb())}C.push(W.Yb())}}else J===YZ.b.ANIMATIONTYPE_QUATERNION?C.push(Z.value.normalize().Yb()):x.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Z,l,C){let B,x,b=!1;if("rotation"===l&&!C)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let K=0,f=Z.length;K<f;++K)if(x=Z[K],x.inTangent||x.outTangent)if(B){if("CUBICSPLINE"!==B){B="LINEAR",b=!0;break}}else B="CUBICSPLINE";else if(B){if("CUBICSPLINE"===B||x.interpolation&&1===x.interpolation&&"STEP"!==B){B="LINEAR",b=!0;break}}else B=x.interpolation&&1===x.interpolation?"STEP":"LINEAR";return B||(B="LINEAR"),{interpolationType:B,shouldBakeAnimation:b}}static _AddSplineTangent(Z,l,C,x,b,K){let f;const W=Z===EZ.INTANGENT?b.inTangent:b.outTangent;if("CUBICSPLINE"===x){if("rotation"===C)if(W)if(K)f=W.Yb();else{const Z=W;f=B.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).Yb()}else f=[0,0,0,0];else f="weights"===C?W?[W]:[0]:W?W.Yb():[0,0,0];l.push(f)}}static _CalculateMinMaxKeyFrames(Z){let l=1/0,C=-1/0;return Z.forEach((function(Z){l=Math.min(l,Z.frame),C=Math.max(C,Z.frame)})),{min:l,max:C}}}function FZ(Z,l,C,b,K,f){const W={attributes:{},influence:Z.influence,name:Z.name},J=l.nb;if(!J)return x.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),W;const E=f?-1:1,G=B.ql.Zero();let a=0,q=0;if(Z.hasPositions){const b=Z.getPositions(),f=J.getVerticesData(d.h.PositionKind);if(f){const Z=new Float32Array(f.length),l=[1/0,1/0,1/0],x=[-1/0,-1/0,-1/0];q=f.length/3,a=0;for(let C=a;C<q;++C){const K=B.ql.il(f,3*C);B.ql.il(b,3*C).subtractToRef(K,G),G.x*=E,l[0]=Math.min(l[0],G.x),x[0]=Math.max(x[0],G.x),l[1]=Math.min(l[1],G.y),x[1]=Math.max(x[1],G.y),l[2]=Math.min(l[2],G.z),x[2]=Math.max(x[2],G.z),Z[3*C]=G.x,Z[3*C+1]=G.y,Z[3*C+2]=G.z}const J=C.createBufferView(Z,12),d=C.createAccessor(J,"VEC3",5126,b.length/3,0,{min:l,max:x});K.push(d),W.attributes.POSITION=K.length-1}else x.Tools.Warn(`Morph target positions for mesh ${l.name} were not exported. Mesh does not have position vertex data`)}if(Z.hasNormals){const b=Z.getNormals(),f=J.getVerticesData(d.h.NormalKind);if(f){const Z=new Float32Array(f.length);q=f.length/3,a=0;for(let C=a;C<q;++C){const l=B.ql.il(f,3*C).normalize();B.ql.il(b,3*C).normalize().subtractToRef(l,G),Z[3*C]=G.x*E,Z[3*C+1]=G.y,Z[3*C+2]=G.z}const l=C.createBufferView(Z,12),x=C.createAccessor(l,"VEC3",5126,b.length/3,0);K.push(x),W.attributes.NORMAL=K.length-1}else x.Tools.Warn(`Morph target normals for mesh ${l.name} were not exported. Mesh does not have normals vertex data`)}if(Z.hasTangents){const b=Z.getTangents(),f=J.getVerticesData(d.h.TangentKind);if(f){q=f.length/4;const Z=new Float32Array(3*q);a=0;for(let C=a;C<q;++C){const l=B.ql.il(f,4*C);L(l);const x=B.ql.il(b,3*C);L(x),x.subtractToRef(l,G),Z[3*C]=G.x*E,Z[3*C+1]=G.y,Z[3*C+2]=G.z}const l=C.createBufferView(Z,12),x=C.createAccessor(l,"VEC3",5126,q,0);K.push(x),W.attributes.TANGENT=K.length-1}else x.Tools.Warn(`Morph target tangents for mesh ${l.name} were not exported. Mesh does not have tangents vertex data`)}if(Z.hasColors){const b=Z.getColors(),f=J.getVerticesData(d.h.ColorKind),E=J.getVertexBuffer(d.h.ColorKind);if(f&&E){const Z=E.getSize();q=f.length/Z;const l=new Float32Array(q*Z);a=0;for(let C=a;C<q;++C)if(3===Z){const x=B.ql.il(f,C*Z);B.ql.il(b,C*Z).subtractToRef(x,G),l[3*C]=G.x,l[3*C+1]=G.y,l[3*C+2]=G.z}else if(4===Z){const x=new B.Vector4,K=B.Vector4.il(f,C*Z);B.Vector4.il(b,C*Z).subtractToRef(K,x),l[4*C]=x.x,l[4*C+1]=x.y,l[4*C+2]=x.z,l[4*C+3]=x.w}else x.Tools.Warn(`Unsupported number of components for color attribute: ${Z}`);const J=C.createBufferView(l,4*Z),d=C.createAccessor(J,3===Z?"VEC3":"VEC4",5126,q,0);K.push(d),W.attributes.COLOR_0=K.length-1}else x.Tools.Warn(`Morph target colors for mesh ${l.name} were not exported. Mesh does not have colors vertex data`)}return W}var nZ=C(12968),cZ=C(12831),UZ=C(12820),tZ=C(12400);class rZ{}rZ.DEFAULT_COLOR=Y.Sl.White(),rZ.DEFAULT_WIDTH_ATTENUATED=1,rZ.DEFAULT_WIDTH=.1;var eZ=C(12680),oZ=C(12974);class vZ{static ConvertPoints(Z,l){if(Z.length&&Array.isArray(Z)&&"number"===typeof Z[0])return[Z];if(Z.length&&Array.isArray(Z[0])&&"number"===typeof Z[0][0])return Z;if(Z.length&&!Array.isArray(Z[0])&&Z[0]instanceof B.ql){const l=[];for(let C=0;C<Z.length;C++){const B=Z[C];l.push(B.x,B.y,B.z)}return[l]}if(Z.length>0&&Array.isArray(Z[0])&&Z[0].length>0&&Z[0][0]instanceof B.ql){const l=[],C=Z;for(const Z of C)l.push(Z.flatMap((Z=>[Z.x,Z.y,Z.z])));return l}if(Z instanceof Float32Array){if(null!==l&&void 0!==l&&l.floatArrayStride){const C=[],B=3*l.floatArrayStride;for(let l=0;l<Z.length;l+=B){const x=new Array(B);for(let C=0;C<B;C++)x[C]=Z[l+C];C.push(x)}return C}return[Array.from(Z)]}if(Z.length&&Z[0]instanceof Float32Array){const l=[];for(const C of Z)l.push(Array.from(C));return l}return[]}static OmitZeroLengthPredicate(Z,l,C){const B=[];return l.zl(Z).lengthSquared()>0&&B.push([Z,l]),C.zl(l).lengthSquared()>0&&B.push([l,C]),Z.zl(C).lengthSquared()>0&&B.push([C,Z]),0===B.length?null:B}static OmitDuplicatesPredicate(Z,l,C,B){const x=[];return vZ._SearchInPoints(Z,l,B)||x.push([Z,l]),vZ._SearchInPoints(l,C,B)||x.push([l,C]),vZ._SearchInPoints(C,Z,B)||x.push([C,Z]),0===x.length?null:x}static _SearchInPoints(Z,l,C){for(const K of C)for(let C=0;C<K.length;C++){var B,x,b;if(null!==(B=K[C])&&void 0!==B&&B.equals(Z))if(null!==(x=K[C+1])&&void 0!==x&&x.equals(l)||null!==(b=K[C-1])&&void 0!==b&&b.equals(l))return!0}return!1}static MeshesToLines(Z,l){const C=[];for(let x=0;x<Z.length;x++){const b=Z[x],K=b.getVerticesData(d.h.PositionKind),f=b.cb();if(K&&f)for(let Z=0,W=0;Z<f.length;Z++){const J=3*f[W++],d=3*f[W++],E=3*f[W++],G=new B.ql(K[J],K[J+1],K[J+2]),a=new B.ql(K[d],K[d+1],K[d+2]),q=new B.ql(K[E],K[E+1],K[E+2]);if(l){const B=l(G,a,q,C,Z,J,b,x,K,f);if(B)for(const Z of B)C.push(Z)}else C.push([G,a],[a,q],[q,G])}}return C}static ToVector3Array(Z){if(Array.isArray(Z[0])){const l=[],C=Z;for(const Z of C){const C=[];for(let l=0;l<Z.length;l+=3)C.push(new B.ql(Z[l],Z[l+1],Z[l+2]));l.push(C)}return l}const l=Z,C=[];for(let x=0;x<l.length;x+=3)C.push(new B.ql(l[x],l[x+1],l[x+2]));return C}static ToNumberArray(Z){return Z.flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetPointsCountInfo(Z){const l=new Array(Z.length);let C=0;for(let B=Z.length;B--;)l[B]=Z[B].length/3,C+=l[B];return{total:C,counts:l}}static GetLineLength(Z){if(0===Z.length)return 0;let l;l="number"===typeof Z[0]?vZ.ToVector3Array(Z):Z;const C=B.TmpVectors.ql[0];let x=0;for(let B=0;B<l.length-1;B++){const Z=l[B];x+=l[B+1].subtractToRef(Z,C).length()}return x}static GetLineLengthArray(Z){const l=new Float32Array(Z.length/3);let C=0;for(let B=0,x=Z.length/3-1;B<x;B++){let x=Z[3*B+0],b=Z[3*B+1],K=Z[3*B+2];x-=Z[3*B+3],b-=Z[3*B+4],K-=Z[3*B+5];C+=Math.sqrt(x*x+b*b+K*K),l[B+1]=C}return l}static SegmentizeSegmentByCount(Z,l,C){const x=[],b=l.zl(Z),K=B.TmpVectors.ql[0];K.ob(C);const f=B.TmpVectors.ql[1];b.divideToRef(K,f);let W=Z.clone();x.push(W);for(let B=0;B<C;B++)W=W.clone(),x.push(W.addInPlace(f));return x}static SegmentizeLineBySegmentLength(Z,l){const C=Z[0]instanceof B.ql?vZ.GetLineSegments(Z):"number"===typeof Z[0]?vZ.GetLineSegments(vZ.ToVector3Array(Z)):Z,x=[];for(const B of C)if(B.length>l){const Z=vZ.SegmentizeSegmentByCount(B.point1,B.point2,Math.ceil(B.length/l));for(const l of Z)x.push(l)}else x.push(B.point1),x.push(B.point2);return x}static SegmentizeLineBySegmentCount(Z,l){const C="number"===typeof Z[0]?vZ.ToVector3Array(Z):Z,B=vZ.GetLineLength(C)/l;return vZ.SegmentizeLineBySegmentLength(C,B)}static GetLineSegments(Z){const l=[];for(let C=0;C<Z.length-1;C++){const B=Z[C],x=Z[C+1],b=x.zl(B).length();l.push({point1:B,point2:x,length:b})}return l}static GetMinMaxSegmentLength(Z){const l=vZ.GetLineSegments(Z).sort((Z=>Z.length));return{min:l[0].length,max:l[l.length-1].length}}static GetPositionOnLineByVisibility(Z,l,C){let x=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const b=l*C;let K=0,f=0;const W=Z.length;for(let B=0;B<W;B++){if(b<=K+Z[B].length){f=B;break}K+=Z[B].length}const J=(b-K)/Z[f].length;return Z[f].point2.subtractToRef(Z[f].point1,B.TmpVectors.ql[0]),B.TmpVectors.ql[1]=B.TmpVectors.ql[0].multiplyByFloats(J,J,J),x||B.TmpVectors.ql[1].addInPlace(Z[f].point1),B.TmpVectors.ql[1].clone()}static GetCircleLinePoints(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,x=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,b=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/l;const K=[];for(let f=0;f<=l;f++)K.push(new B.ql(Math.cos(f*b)*Z,Math.sin(f*b)*x,C));return K}static GetBezierLinePoints(Z,l,C,B){return eZ.i.CreateQuadraticBezier(Z,l,C,B).getPoints().flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetArrowCap(Z,l,C,B,x){let b=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,K=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Z.clone(),Z.add(l.multiplyByFloats(C,C,C))],widths:[B,x,b,K]}}static GetPointsFromText(Z,l,C,B){let x=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,b=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const K=[],f=(0,oZ.c)(Z,l,C,B);for(const W of f){for(const Z of W.paths){const l=[],C=Z.getPoints();for(const Z of C)l.push(Z.x,Z.y,x);K.push(l)}if(b)for(const Z of W.holes){const l=[],C=Z.getPoints();for(const Z of C)l.push(Z.x,Z.y,x);K.push(l)}}return K}static Color3toRGBAUint8(Z){const l=new Uint8Array(4*Z.length);for(let C=0,B=0;C<Z.length;C++)l[B++]=255*Z[C].r,l[B++]=255*Z[C].g,l[B++]=255*Z[C].b,l[B++]=255;return l}static CreateColorsTexture(Z,l,C,B){const x=B.getEngine().getCaps().maxTextureSize??1,b=l.length>x?x:l.length,K=Math.ceil(l.length/x);K>1&&(l=[...l,...Array(b*K-l.length).fill(l[0])]);const f=vZ.Color3toRGBAUint8(l),W=new n.e(f,b,K,q.d.TEXTUREFORMAT_RGBA,B,!1,!0,C);return W.name=Z,W}static PrepareEmptyColorsTexture(Z){if(!rZ.EmptyColorsTexture){const l=new Uint8Array(4);rZ.EmptyColorsTexture=new n.e(l,1,1,q.d.TEXTUREFORMAT_RGBA,Z,!1,!1,n.e.NEAREST_NEAREST),rZ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return rZ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Z;null===(Z=rZ.EmptyColorsTexture)||void 0===Z||Z.dispose(),rZ.EmptyColorsTexture=null}static BooleanToNumber(Z){return Z?1:0}}class RZ extends UZ.c{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class kZ extends cZ.b{isCompatible(Z){return!0}constructor(Z,l,C){var x;C=C||{color:rZ.DEFAULT_COLOR};const b=new RZ;b.GREASED_LINE_HAS_COLOR=!!C.color&&!C.useColors,b.GREASED_LINE_SIZE_ATTENUATION=C.sizeAttenuation??!1,b.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===C.colorDistributionType,b.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(l??Z.cZ()).useRightHandedSystem,b.GREASED_LINE_CAMERA_FACING=C.cameraFacing??!0,super(Z,kZ.GREASED_LINE_MATERIAL_NAME,200,b,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(x=C)||void 0===x?void 0:x.forceGLSL)||kZ.ForceGLSL,this._scene=l??Z.cZ(),this._engine=this._scene.getEngine(),this._cameraFacing=C.cameraFacing??!0,this.visibility=C.visibility??1,this.useDash=C.useDash??!1,this.dashRatio=C.dashRatio??.5,this.dashOffset=C.dashOffset??0,this.width=C.width?C.width:C.sizeAttenuation?rZ.DEFAULT_WIDTH_ATTENUATED:rZ.DEFAULT_WIDTH,this._sizeAttenuation=C.sizeAttenuation??!1,this.colorMode=C.colorMode??0,this._color=C.color??null,this.useColors=C.useColors??!1,this._colorsDistributionType=C.colorDistributionType??0,this.colorsSampling=C.colorsSampling??n.e.NEAREST_NEAREST,this._colors=C.eZ??null,this.dashCount=C.dashCount??1,this.resolution=C.resolution??new B.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),C.colorsTexture?this.colorsTexture=C.colorsTexture:this._colors?this.colorsTexture=vZ.CreateColorsTexture(`${Z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??rZ.DEFAULT_COLOR,vZ.PrepareEmptyColorsTexture(this._scene)),this._engine.xb.add((()=>{vZ.DisposeEmptyColorsTexture()}))}getAttributes(Z){Z.push("grl_offsets"),Z.push("grl_widths"),Z.push("grl_colorPointers"),Z.push("grl_counters"),this._cameraFacing?(Z.push("grl_previousAndSide"),Z.push("grl_nextAndCounters")):Z.push("grl_slopes")}getSamplers(Z){Z.push("grl_colors")}getActiveTextures(Z){this.colorsTexture&&Z.push(this.colorsTexture)}getUniforms(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const l=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&l.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Z&&l.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:l,vertex:this._cameraFacing&&this._isGLSL(Z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Z){if(this._cameraFacing){Z.sb("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Z.sb("viewProjection",this._scene.getTransformMatrix());const l=B.TmpVectors.Vector4[0];l.x=this._aspect,l.y=this._resolution.x,l.z=this._resolution.y,l.w=this.width,Z.updateVector4("grl_aspect_resolution_lineWidth",l)}const l=B.TmpVectors.Vector4[0];l.x=vZ.BooleanToNumber(this.useDash),l.y=this._dashArray,l.z=this.dashOffset,l.w=this.dashRatio,Z.updateVector4("grl_dashOptions",l);const C=B.TmpVectors.Vector4[1];C.x=this.colorMode,C.y=this.visibility,C.z=this.colorsTexture?this.colorsTexture.getSize().width:0,C.w=vZ.BooleanToNumber(this.useColors),Z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",C),this._color&&Z.updateColor3("grl_singleColor",this._color);const x=this.colorsTexture??rZ.EmptyColorsTexture;Z.setTexture("grl_colors",x),Z.updateFloat2("grl_textureSize",(null===x||void 0===x?void 0:x.getSize().width)??1,(null===x||void 0===x?void 0:x.getSize().height)??1)}prepareDefines(Z,l,C){Z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=l.useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Z.GREASED_LINE_USE_OFFSETS=!!C.offsets}getClassName(){return kZ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Z){let l=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(l)?function(Z,l){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return l&&(Z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Z,this._cameraFacing):function(Z,l){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return l&&(Z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Z,this._cameraFacing)}dispose(){var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}get eZ(){return this._colors}set eZ(Z){this.setColors(Z)}setColors(Z){var l;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=(null===(l=this._colors)||void 0===l?void 0:l.length)??0;var b;if(this._colors=Z,null!==Z&&0!==Z.length){if(!C||B)if(this.colorsTexture&&x===Z.length&&!B){const l=vZ.Color3toRGBAUint8(Z);this.colorsTexture.update(l)}else{var K;null===(K=this.colorsTexture)||void 0===K||K.dispose(),this.colorsTexture=vZ.CreateColorsTexture(`${this._material.name}-colors-texture`,Z,this.colorsSampling,this._scene)}}else null===(b=this.colorsTexture)||void 0===b||b.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Z||null!==this._color&&null===Z?(this._color=Z,l||this.markAllDefinesAsDirty()):this._color=Z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Z){this._aspect=Z.x/Z.y,this._resolution=Z}serialize(){const Z=super.serialize(),l={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(l.eZ=this._colors),this._color&&(l.color=this._color),Z.greasedLineMaterialOptions=l,Z}parse(Z,l,C){var B;super.parse(Z,l,C);const x=Z.greasedLineMaterialOptions;null===(B=this.colorsTexture)||void 0===B||B.dispose(),x.color&&this.setColor(x.color,!0),x.colorDistributionType&&(this.colorsDistributionType=x.colorDistributionType),x.eZ&&(this.eZ=x.eZ),x.colorsSampling&&(this.colorsSampling=x.colorsSampling),x.colorMode&&(this.colorMode=x.colorMode),x.useColors&&(this.useColors=x.useColors),x.visibility&&(this.visibility=x.visibility),x.useDash&&(this.useDash=x.useDash),x.dashCount&&(this.dashCount=x.dashCount),x.dashRatio&&(this.dashRatio=x.dashRatio),x.dashOffset&&(this.dashOffset=x.dashOffset),x.width&&(this.width=x.width),x.sizeAttenuation&&(this.sizeAttenuation=x.sizeAttenuation),x.resolution&&(this.resolution=x.resolution),this.eZ?this.colorsTexture=vZ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.eZ,this.colorsSampling,l):vZ.PrepareEmptyColorsTexture(l),this.markAllDefinesAsDirty()}copyTo(Z){var l;const C=Z;null===(l=C.colorsTexture)||void 0===l||l.dispose(),this._colors&&(C.colorsTexture=vZ.CreateColorsTexture(`${C._material.name}-colors-texture`,this._colors,C.colorsSampling,this._scene)),C.setColor(this.color,!0),C.colorsDistributionType=this.colorsDistributionType,C.colorsSampling=this.colorsSampling,C.colorMode=this.colorMode,C.useColors=this.useColors,C.visibility=this.visibility,C.useDash=this.useDash,C.dashCount=this.dashCount,C.dashRatio=this.dashRatio,C.dashOffset=this.dashOffset,C.width=this.width,C.sizeAttenuation=this.sizeAttenuation,C.resolution=this.resolution,C.markAllDefinesAsDirty()}_isGLSL(Z){return 0===Z||this._forceGLSL}}kZ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",kZ.ForceGLSL=!1,(0,tZ.c)(`BABYLON.${kZ.GREASED_LINE_MATERIAL_NAME}`,kZ);var VZ=C(12861),gZ=C(12266),jZ=C(12700),MZ=C(12385);class IZ extends jZ.ShaderMaterial{constructor(Z,l,x){const b=l.getEngine(),K=b.isWebGPU&&!(x.forceGLSL||IZ.ForceGLSL),f=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];l.useRightHandedSystem&&f.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const W=["position","grl_widths","grl_offsets","grl_colorPointers"];x.cameraFacing?(f.push("GREASED_LINE_CAMERA_FACING"),W.push("grl_previousAndSide","grl_nextAndCounters")):(W.push("grl_slopes"),W.push("grl_counters"));const J=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(K||J.push("world","viewProjection","view","projection"),super(Z,l,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:K?["Scene","Mesh"]:void 0,attributes:W,uniforms:J,samplers:K?[]:["grlColors"],defines:f,extraInitializationsAsync:async()=>{K?await Promise.all([C.e(66).then(C.bind(C,15268)),C.e(75).then(C.bind(C,15272))]):await Promise.all([C.e(69).then(C.bind(C,15279)),C.e(76).then(C.bind(C,15281))])},shaderLanguage:K?1:0}),this._color=Y.Sl.White(),this._colorsDistributionType=0,this._colorsTexture=null,x=x||{color:rZ.DEFAULT_COLOR},this.visibility=x.visibility??1,this.useDash=x.useDash??!1,this.dashRatio=x.dashRatio??.5,this.dashOffset=x.dashOffset??0,this.dashCount=x.dashCount??1,this.width=x.width?x.width:x.sizeAttenuation&&x.cameraFacing?rZ.DEFAULT_WIDTH_ATTENUATED:rZ.DEFAULT_WIDTH,this.sizeAttenuation=x.sizeAttenuation??!1,this.color=x.color??Y.Sl.White(),this.useColors=x.useColors??!1,this.colorsDistributionType=x.colorDistributionType??0,this.colorsSampling=x.colorsSampling??n.e.NEAREST_NEAREST,this.colorMode=x.colorMode??0,this._colors=x.eZ??null,this._cameraFacing=x.cameraFacing??!0,this.resolution=x.resolution??new B.Vector2(b.getRenderWidth(),b.getRenderHeight()),x.colorsTexture?this.colorsTexture=x.colorsTexture:this._colors?this.colorsTexture=vZ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,l):(this._color=this._color??rZ.DEFAULT_COLOR,this.colorsTexture=vZ.PrepareEmptyColorsTexture(l)),K){const Z=new MZ.d;Z.setParameters(),Z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Z)}b.xb.add((()=>{vZ.DisposeEmptyColorsTexture()}))}dispose(){var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new B.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get eZ(){return this._colors}set eZ(Z){this.setColors(Z)}setColors(Z){var l;let C=arguments.length>1&&void 0!==arguments[1]&&arguments[1],B=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const x=(null===(l=this._colors)||void 0===l?void 0:l.length)??0;var b;if(this._colors=Z,null!==Z&&0!==Z.length){if(!C||B)if(this._colorsTexture&&x===Z.length&&!B){const l=vZ.Color3toRGBAUint8(Z);this._colorsTexture.update(l)}else{var K;null===(K=this._colorsTexture)||void 0===K||K.dispose(),this.colorsTexture=vZ.CreateColorsTexture(`${this.name}-colors-texture`,Z,this.colorsSampling,this.cZ())}}else null===(b=this._colorsTexture)||void 0===b||b.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Z){this._colorsTexture=Z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Z){this._width=Z,this.setFloat("grlWidth",Z)}get useColors(){return this._useColors}set useColors(Z){this._useColors=Z,this.setFloat("grlUseColors",vZ.BooleanToNumber(Z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Z){this._colorsSampling=Z}get visibility(){return this._visibility}set visibility(Z){this._visibility=Z,this.setFloat("grlVisibility",Z)}get useDash(){return this._useDash}set useDash(Z){this._useDash=Z,this.setFloat("grlUseDash",vZ.BooleanToNumber(Z))}get dashOffset(){return this._dashOffset}set dashOffset(Z){this._dashOffset=Z,this.setFloat("grlDashOffset",Z)}get dashRatio(){return this._dashRatio}set dashRatio(Z){this._dashRatio=Z,this.setFloat("grlDashRatio",Z)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.setFloat("grlSizeAttenuation",vZ.BooleanToNumber(Z))}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){Z=Z??rZ.DEFAULT_COLOR,this._color=Z,this.setColor3("grlColor",Z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Z){this._colorMode=Z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Z){this._resolution=Z,this.setVector2("grlResolution",Z),this.setFloat("grlAspect",Z.x/Z.y)}serialize(){const Z=super.serialize(),l={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(l.eZ=this._colors),Z.greasedLineMaterialOptions=l,Z}parse(Z,l,C){var B;const x=Z.greasedLineMaterialOptions;null===(B=this._colorsTexture)||void 0===B||B.dispose(),x.color&&(this.color=x.color),x.colorDistributionType&&(this.colorsDistributionType=x.colorDistributionType),x.colorsSampling&&(this.colorsSampling=x.colorsSampling),x.colorMode&&(this.colorMode=x.colorMode),x.useColors&&(this.useColors=x.useColors),x.visibility&&(this.visibility=x.visibility),x.useDash&&(this.useDash=x.useDash),x.dashCount&&(this.dashCount=x.dashCount),x.dashRatio&&(this.dashRatio=x.dashRatio),x.dashOffset&&(this.dashOffset=x.dashOffset),x.width&&(this.width=x.width),x.sizeAttenuation&&(this.sizeAttenuation=x.sizeAttenuation),x.resolution&&(this.resolution=x.resolution),x.eZ?this.colorsTexture=vZ.CreateColorsTexture(`${this.name}-colors-texture`,x.eZ,this.colorsSampling,this.cZ()):this.colorsTexture=vZ.PrepareEmptyColorsTexture(l),this._cameraFacing=x.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var wZ,OZ,DZ;IZ.ForceGLSL=!1,function(Z){Z[Z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Z[Z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(wZ||(wZ={})),function(Z){Z[Z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Z[Z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Z[Z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(OZ||(OZ={})),function(Z){Z[Z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Z[Z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Z[Z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Z[Z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Z[Z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(DZ||(DZ={}));class yZ extends SZ.b{constructor(Z,l,C){super(Z,l,null,null,!1,!1),this.name=Z,this._options=C,this._lazy=!1,this._updatable=!1,this._engine=l.getEngine(),this._lazy=C.lazy??!1,this._updatable=C.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=C.colorPointers??[],this._widths=C.widths??new Array(C.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Z){let l=0;for(const B of this._points)l+=B.length;const C=l/3*2-this._widths.length;for(let B=0;B<C;B++)this._widths.push(Z)}updateLazy(){var Z,l;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Z=this._options.ribbonOptions)||void 0===Z?void 0:Z.smoothShading),!this.kZ&&this.refreshBoundingInfo(),null===(l=this.greasedLineMaterial)||void 0===l||l.updateLazy()}addPoints(Z,l){for(const C of Z)this._points.push(C);this._lazy||this.setPoints(this._points,l)}dispose(Z){let l=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Z,l)}isLazy(){return this._lazy}get oZ(){return this._uvs}set oZ(Z){this._uvs=Z instanceof Float32Array?Z:new Float32Array(Z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Z){this.material instanceof IZ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Z||void 0===Z?void 0:Z.length)>0),this._offsets=Z,this._offsetsBuffer?this._offsetsBuffer.update(Z):this._createOffsetsBuffer(Z)}get widths(){return this._widths}set widths(Z){this._widths=Z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Z)}get colorPointers(){return this._colorPointers}set colorPointers(Z){this._colorPointers=Z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Z)}get greasedLineMaterial(){var Z,l;if(this.material&&this.material instanceof IZ)return this.material;const C=null===(Z=this.material)||void 0===Z||null===(l=Z.pluginManager)||void 0===l?void 0:l.getPlugin(kZ.GREASED_LINE_MATERIAL_NAME);return C||void 0}get points(){const Z=[];return gZ.d.DeepCopy(this._points,Z),Z}setPoints(Z,l){this._points=vZ.ConvertPoints(Z,(null===l||void 0===l?void 0:l.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==l&&void 0!==l&&l.colorPointers||this._updateColorPointers(),this._setPoints(this._points,l)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,oZ:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Z){super.serialize(Z),Z.type=this.getClassName(),Z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const l=new VZ.e;return l.tZ=this._vertexPositions,l.indices=this._indices,l.oZ=this._uvs,Z&&(l.rZ=[],VZ.e.ComputeNormals(this._vertexPositions,this._indices,l.rZ)),l.RZ(this,this._options.updatable),l}_createOffsetsBuffer(Z){const l=this._scene.getEngine(),C=new d.d(l,Z,this._updatable,3);this.setVerticesBuffer(C.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=C}}class XZ{constructor(Z,l){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Z,this.wasAddedByNoopNode=l}getIndicesAccessor(Z,l,C,B,x){var b,K,f,W;return null===(b=this._indicesAccessorMap.get(Z))||void 0===b||null===(K=b.get(l))||void 0===K||null===(f=K.get(C))||void 0===f||null===(W=f.get(B))||void 0===W?void 0:W.get(x)}setIndicesAccessor(Z,l,C,B,x,b){let K=this._indicesAccessorMap.get(Z);K||(K=new Map,this._indicesAccessorMap.set(Z,K));let f=K.get(l);f||(f=new Map,K.set(l,f));let W=f.get(C);W||(W=new Map,f.set(C,W));let J=W.get(B);J||(J=new Map,W.set(B,J)),J.set(x,b)}pushExportedNode(Z){this._exportedNodes.has(Z)||this._exportedNodes.add(Z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Z){return this._vertexBufferViewMap.get(Z)}setVertexBufferView(Z,l){this._vertexBufferViewMap.set(Z,l)}setRemappedBufferView(Z,l,C){this._remappedBufferView.set(Z,new Map),this._remappedBufferView.get(Z).set(l,C)}getRemappedBufferView(Z,l){var C;return null===(C=this._remappedBufferView.get(Z))||void 0===C?void 0:C.get(l)}getVertexAccessor(Z,l,C){var B,x;return null===(B=this._vertexAccessorMap.get(Z))||void 0===B||null===(x=B.get(l))||void 0===x?void 0:x.get(C)}setVertexAccessor(Z,l,C,B){let x=this._vertexAccessorMap.get(Z);x||(x=new Map,this._vertexAccessorMap.set(Z,x));let b=x.get(l);b||(b=new Map,x.set(l,b)),b.set(C,B)}hasVertexColorAlpha(Z){return this._vertexMapColorAlpha.get(Z)||!1}setHasVertexColorAlpha(Z,l){return this._vertexMapColorAlpha.set(Z,l)}getMesh(Z){return this._meshMap.get(Z)}setMesh(Z,l){this._meshMap.set(Z,l)}bindMorphDataToMesh(Z,l){const C=this._meshMorphTargetMap.get(Z)||[];this._meshMorphTargetMap.set(Z,C),-1===C.indexOf(l)&&C.push(l)}getMorphTargetsFromMesh(Z){return this._meshMorphTargetMap.get(Z)}}class TZ{_ApplyExtension(Z,l,C,B){if(C>=l.length)return Promise.resolve(Z);const x=B(l[C],Z);return x?x.then((async Z=>Z?await this._ApplyExtension(Z,l,C+1,B):null)):this._ApplyExtension(Z,l,C+1,B)}_ApplyExtensions(Z,l){const C=[];for(const B of TZ._ExtensionNames)C.push(this._extensions[B]);return this._ApplyExtension(Z,C,0,l)}_extensionsPreExportTextureAsync(Z,l,C){return this._ApplyExtensions(l,((l,B)=>l.preExportTextureAsync&&l.preExportTextureAsync(Z,B,C)))}_extensionsPostExportNodeAsync(Z,l,C,B,x){return this._ApplyExtensions(l,((l,b)=>l.postExportNodeAsync&&l.postExportNodeAsync(Z,b,C,B,x,this._bufferManager)))}_extensionsPostExportMaterialAsync(Z,l,C){return this._ApplyExtensions(l,((l,B)=>l.postExportMaterialAsync&&l.postExportMaterialAsync(Z,B,C)))}_extensionsPostExportMaterialAdditionalTextures(Z,l,C){const B=[];for(const x of TZ._ExtensionNames){const b=this._extensions[x];b.postExportMaterialAdditionalTextures&&B.push(...b.postExportMaterialAdditionalTextures(Z,l,C))}return B}_extensionsPostExportTextures(Z,l,C){for(const B of TZ._ExtensionNames){const x=this._extensions[B];x.postExportTexture&&x.postExportTexture(Z,l,C)}}_extensionsPostExportMeshPrimitive(Z){for(const l of TZ._ExtensionNames){const C=this._extensions[l];C.postExportMeshPrimitive&&C.postExportMeshPrimitive(Z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Z of TZ._ExtensionNames){const l=this._extensions[Z];l.preGenerateBinaryAsync&&await l.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Z){for(const l of TZ._ExtensionNames){const C=this._extensions[l];C.enabled&&Z(C)}}_extensionsOnExporting(){this._forEachExtensions((Z=>{var l,C,B;Z.wasUsed&&((l=this._glTF).extensionsUsed||(l.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Z.name)&&this._glTF.extensionsUsed.push(Z.name),Z.required&&((C=this._glTF).extensionsRequired||(C.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Z.name)&&this._glTF.extensionsRequired.push(Z.name)),(B=this._glTF).extensions||(B.extensions={}),Z.onExporting&&Z.onExporting())}))}_loadExtensions(){for(const Z of TZ._ExtensionNames){const l=TZ._ExtensionFactories[Z](this);this._extensions[Z]=l}}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:z.b.LastCreatedScene,l=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${q.d.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new M(this),this._extensions={},this._bufferManager=new dZ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Z)throw new Error("No scene available to export");this._babylonScene=Z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Z=>{var l;return null===Z||void 0===Z||null===(l=Z.Eb)||void 0===l?void 0:l.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...l},this._loadExtensions()}dispose(){for(const Z in this._extensions){this._extensions[Z].dispose()}}get options(){return this._options}static RegisterExtension(Z,l){TZ.UnregisterExtension(Z)&&x.Tools.Warn(`Extension with the name ${Z} already exists`),TZ._ExtensionFactories[Z]=l,TZ._ExtensionNames.push(Z)}static UnregisterExtension(Z){if(!TZ._ExtensionFactories[Z])return!1;delete TZ._ExtensionFactories[Z];const l=TZ._ExtensionNames.indexOf(Z);return-1!==l&&TZ._ExtensionNames.splice(l,1),!0}_generateJSON(Z,l,C){const B={byteLength:Z};return B.byteLength&&(this._glTF.buffers=[B]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.Yl=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(B.uri=l+".bin"),C?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Z){const l=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(l.byteLength,Z,!0),B=new Blob([l],{type:"application/octet-stream"}),x=Z+".gltf",b=Z+".bin",K=new J;if(K.files[x]=C,K.files[b]=B,this._imageData)for(const f in this._imageData)K.files[f]=new Blob([this._imageData[f].data],{type:this._imageData[f].mimeType});return K}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Z){const l=Z%4;return 0===l?l:4-l}async generateGLBAsync(Z){this._shouldUseGlb=!0;const l=await this._generateBinaryAsync();this._extensionsOnExporting();const C=this._generateJSON(l.byteLength),B=Z+".glb";let x,b=C.length;if("undefined"!==typeof TextEncoder){x=(new TextEncoder).encode(C),b=x.length}const K=this._getPadding(b),f=this._getPadding(l.byteLength),W=28+b+K+l.byteLength+f,d=new WZ(W);if(d.writeUInt32(1179937895),d.writeUInt32(2),d.writeUInt32(W),d.writeUInt32(b+K),d.writeUInt32(1313821514),x)d.writeTypedArray(x);else{const Z="_".charCodeAt(0);for(let l=0;l<b;++l){const B=C.charCodeAt(l);B!=C.codePointAt(l)?d.writeUInt8(Z):d.writeUInt8(B)}}for(let J=0;J<K;++J)d.writeUInt8(32);d.writeUInt32(l.byteLength+f),d.writeUInt32(5130562),d.writeTypedArray(l);for(let J=0;J<f;++J)d.writeUInt8(0);const E=new J;return E.files[B]=new Blob([d.getOutputData()],{type:"application/octet-stream"}),E}_setNodeTransformation(Z,l,C){if(l.getPivotPoint().equalsWithEpsilon(y,D.e)||x.Tools.Warn("Pivot points are not supported in the glTF serializer"),!l.position.equalsWithEpsilon(y,D.e)){const x=B.TmpVectors.ql[0].B(l.position);C&&p(x),Z.translation=x.Yb()}l.eb.equalsWithEpsilon(T,D.e)||(Z.scale=l.eb.Yb());const b=l.rotationQuaternion||B.Quaternion.FromEulerAngles(l.rotation.x,l.rotation.y,l.rotation.z);b.equalsWithEpsilon(X,D.e)||(C&&N(b),Z.rotation=b.normalize().Yb())}_setCameraTransformation(Z,l,C){if(!l.position.equalsWithEpsilon(y,D.e)){const x=B.TmpVectors.ql[0].B(l.position);C&&p(x),Z.translation=x.Yb()}const x=l.rotationQuaternion||B.Quaternion.FromEulerAngles(l.rotation.x,l.rotation.y,l.rotation.z);C&&N(x),this._babylonScene.useRightHandedSystem||mZ(x),x.equalsWithEpsilon(X,D.e)||(Z.rotation=x.Yb())}_listAvailableCameras(){for(const Z of this._babylonScene.cameras){const l={type:Z.mode===GZ.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Z.name&&(l.name=Z.name),"perspective"===l.type)l.perspective={aspectRatio:Z.getEngine().getAspectRatio(Z),yfov:Z.fovMode===GZ.d.FOVMODE_VERTICAL_FIXED?Z.fov:Z.fov*Z.getEngine().getAspectRatio(Z),znear:Z.ib,zfar:Z.maxZ};else if("orthographic"===l.type){const C=Z.orthoLeft&&Z.orthoRight?.5*(Z.orthoRight-Z.orthoLeft):.5*Z.getEngine().getRenderWidth(),B=Z.orthoBottom&&Z.orthoTop?.5*(Z.orthoTop-Z.orthoBottom):.5*Z.getEngine().getRenderHeight();l.orthographic={xmag:C,ymag:B,znear:Z.ib,zfar:Z.maxZ}}this._camerasMap.set(Z,l)}}_exportAndAssignCameras(){const Z=Array.from(this._camerasMap.values());for(const l of Z){const Z=this._nodesCameraMap.get(l);if(void 0!==Z){this._cameras.push(l);for(const l of Z)l.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const l={joints:[]};this._skinMap.set(Z,l)}}_exportAndAssignSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const l=this._skinMap.get(Z);if(void 0==l)continue;const C={},B=[];let b=-1;for(let x=0;x<Z.bones.length;++x){const l=Z.bones[x],B=l.getIndex()??x;-1!==B&&(C[B]=l,B>b&&(b=B))}for(let Z=0;Z<=b;++Z){const b=C[Z];B.push(b.getAbsoluteInverseBindMatrix());const K=b.getTransformNode();if(null!==K){const Z=this._nodeMap.get(K);K&&null!==Z&&void 0!==Z?l.joints.push(Z):x.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else x.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const K=this._nodesSkinMap.get(l);if(l.joints.length>0&&void 0!==K){const Z=64*B.length,C=new Float32Array(Z/4);B.forEach(((Z,l)=>{C.set(Z.m,16*l)}));const x=this._bufferManager.createBufferView(C);this._accessors.push(this._bufferManager.createAccessor(x,"MAT4",5126,B.length)),l.inverseBindMatrices=this._accessors.length-1,this._skins.push(l);for(const l of K)l.skin=this._skins.length-1}}}async _exportSceneAsync(){const Z={nodes:[]};if(this._babylonScene.metadata){const l=this._options.metadataSelector(this._babylonScene.metadata);l&&(Z.extras=l)}const l=new Array,C=new Array,B=new Array;for(const f of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&KZ(f,this._babylonScene.useRightHandedSystem)?B.push(...f.getChildren()):this._babylonScene.useRightHandedSystem?l.push(f):C.push(f);this._listAvailableCameras(),this._listAvailableSkeletons();const x=new XZ(!0,!1);Z.nodes.push(...await this._exportNodesAsync(C,x));const b=new XZ(!1,!1);Z.nodes.push(...await this._exportNodesAsync(l,b));const K=new XZ(!1,!0);Z.nodes.push(...await this._exportNodesAsync(B,K)),Z.nodes.length&&this._scenes.push(Z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&sZ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,x.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Z){let l=this._shouldExportNodeMap.get(Z);return void 0===l&&(l=this._options.shouldExportNode(Z),this._shouldExportNodeMap.set(Z,l)),l}async _exportNodesAsync(Z,l){const C=new Array;this._exportBuffers(Z,l);for(const B of Z)await this._exportNodeAsync(B,C,l);return C}_collectBuffers(Z,l,C,B,x){if(this._shouldExportNode(Z)&&Z instanceof G.e&&Z.nb){const b=Z.nb.getVertexBuffers();if(b)for(const B in b){if(!h(B))continue;const K=b[B];x.setHasVertexColorAlpha(K,Z.hasVertexAlpha);const f=K._buffer,W=l.get(f)||[];l.set(f,W),-1===W.indexOf(K)&&W.push(K);const J=C.get(K)||[];C.set(K,J),-1===J.indexOf(Z)&&J.push(Z)}const K=Z.morphTargetManager;if(K)for(let l=0;l<K.numTargets;l++){const C=K.getTarget(l),x=B.get(C)||[];B.set(C,x),-1===x.indexOf(Z)&&x.push(Z)}}for(const b of Z.getChildren())this._collectBuffers(b,l,C,B,x)}_exportBuffers(Z,l){const C=new Map,B=new Map,x=new Map;for(const f of Z)this._collectBuffers(f,C,B,x,l);const b=Array.from(C.keys());for(const f of b){const Z=f.getData();if(!Z)throw new Error("Buffer data is not available");const x=C.get(f);if(!x)continue;const b=x[0].byteStride;if(x.some((Z=>Z.byteStride!==b)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const K=CZ(Z).slice();for(const l of x){const Z=B.get(l),{byteOffset:C,byteStride:x,componentCount:b,type:f,count:W,normalized:J,kind:E}=H(l,Z);switch(E){case d.h.NormalKind:case d.h.TangentKind:(0,I.g)(K,C,x,b,f,W,J,(Z=>{const l=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]);if(l>0){const C=1/l;Z[0]*=C,Z[1]*=C,Z[2]*=C}}));break;case d.h.ColorKind:{const l=Z.filter((Z=>Z.material instanceof zZ.Pl||null==Z.material)).length;if(0==l)break;if(l!=Z.length){w.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}f==d.h.UNSIGNED_BYTE&&w.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const B=new Y.Sl,E=new Y.Rb,G=this._babylonScene.getEngine().useExactSrgbConversions;(0,I.g)(K,C,x,b,f,W,J,(Z=>{3===Z.length?(B.aC(Z,0),B.toLinearSpaceToRef(B,G),B.toArray(Z,0)):(E.aC(Z,0),E.toLinearSpaceToRef(E,G),E.toArray(Z,0))}))}}}if(l.convertToRightHanded){for(const Z of x){const l=B.get(Z),{byteOffset:C,byteStride:x,componentCount:b,type:f,count:W,normalized:J,kind:E}=H(Z,l);switch(E){case d.h.PositionKind:case d.h.NormalKind:case d.h.TangentKind:(0,I.g)(K,C,x,b,f,W,J,(Z=>{Z[0]=-Z[0]}))}}l.convertedToRightHandedBuffers.set(f,K)}const W=this._bufferManager.createBufferView(K,b);l.setVertexBufferView(f,W);const J=new Map;for(const l of x){const Z=B.get(l),{kind:C,totalVertices:x}=H(l,Z);switch(C){case d.h.MatricesIndicesKind:case d.h.MatricesIndicesExtraKind:if(l.type==d.h.FLOAT){const Z=l.getFloatData(x);null!==Z&&J.set(l,Z)}}}0!==J.size&&w.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const E=Array.from(J.keys());for(const C of E){const Z=J.get(C);if(!Z)continue;const B=Z.some((Z=>Z>=256)),x=new(B?Uint16Array:Uint8Array)(Z.length);for(let l=0;l<Z.length;l++)x[l]=Z[l];const b=this._bufferManager.createBufferView(x,4*(B?2:1));l.setRemappedBufferView(f,C,b)}}const K=Array.from(x.keys());for(const f of K){const Z=x.get(f);if(!Z)continue;const C=FZ(f,Z[0],this._bufferManager,this._bufferViews,this._accessors,l.convertToRightHanded);for(const B of Z)l.bindMorphDataToMesh(B,C)}}async _exportNodeAsync(Z,l,C){let B=this._nodeMap.get(Z);if(void 0!==B)return void(l.includes(B)||l.push(B));const x=await this._createNodeAsync(Z,C);if(x){B=this._nodes.length,this._nodes.push(x),this._nodeMap.set(Z,B),C.pushExportedNode(Z),l.push(B);const b={name:"runtime animations",channels:[],samplers:[]},K=[];this._babylonScene.animationGroups.length||(sZ._CreateMorphTargetAnimationFromMorphTargetAnimations(Z,b,K,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation),Z.animations.length&&sZ._CreateNodeAnimationFromNodeAnimations(Z,b,K,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,C.convertToRightHanded,this._options.shouldExportAnimation)),b.channels.length&&b.samplers.length&&this._animations.push(b),K.forEach((Z=>{Z.channels.length&&Z.samplers.length&&this._animations.push(Z)}))}const b=x?[]:l;for(const K of Z.getChildren())await this._exportNodeAsync(K,b,C);x&&b.length&&(x.children=b)}async _createNodeAsync(Z,l){if(!this._shouldExportNode(Z))return null;const C={};if(Z.name&&(C.name=Z.name),Z.metadata){const l=this._options.metadataSelector(Z.metadata);l&&(C.extras=l)}if(Z instanceof E.e&&(this._setNodeTransformation(C,Z,l.convertToRightHanded),Z instanceof G.e)){const x=Z instanceof a.e?Z.sourceMesh:Z;if(x.zb&&x.zb.length>0&&(C.mesh=await this._exportMeshAsync(x,l)),Z.skeleton){const l=this._skinMap.get(Z.skeleton);var B;if(void 0!==l)void 0===this._nodesSkinMap.get(l)&&this._nodesSkinMap.set(l,[]),null===(B=this._nodesSkinMap.get(l))||void 0===B||B.push(C)}}if(Z instanceof O.b){const B=this._camerasMap.get(Z);if(B){var x;void 0===this._nodesCameraMap.get(B)&&this._nodesCameraMap.set(B,[]),this._setCameraTransformation(C,Z,l.convertToRightHanded);const K=Z.parent;if(null!==K&&lZ(Z,K)){const Z=this._nodeMap.get(K);if(void 0!==Z){var b;const l=this._nodes[Z];return ZZ(C,l),null===(b=this._nodesCameraMap.get(B))||void 0===b||b.push(l),null}}null===(x=this._nodesCameraMap.get(B))||void 0===x||x.push(C)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",C,Z,this._nodeMap,l.convertToRightHanded)?C:(w.e.Warn(`Not exporting node ${Z.name}`),null)}_exportIndices(Z,l,C,B,x,K,f,W,J){let d=Z;J.mode=A(K);const E=f!==b.b.CounterClockWiseSideOrientation,G=!W.wasAddedByNoopNode&&E,a=function(Z){switch(Z){case b.b.TriangleFillMode:case b.b.TriangleStripDrawMode:case b.b.TriangleFanDrawMode:return!0}return!1}(K)&&G;if(a){if(K===b.b.TriangleStripDrawMode||K===b.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");J.mode=A(K);const f=l?new Uint32Array(B):new Uint16Array(B);if(Z)for(let l=0;l+2<B;l+=3)f[l]=Z[C+l]+x,f[l+1]=Z[C+l+2]+x,f[l+2]=Z[C+l+1]+x;else for(let Z=0;Z+2<B;Z+=3)f[Z]=Z,f[Z+1]=Z+2,f[Z+2]=Z+1;d=f}else if(Z&&0!==x){const b=l?new Uint32Array(B):new Uint16Array(B);for(let l=0;l<B;l++)b[l]=Z[C+l]+x;d=b}if(d){let b=W.getIndicesAccessor(Z,C,B,x,a);if(void 0===b){const K=function(Z,l,C,B){if(Z instanceof Uint16Array||Z instanceof Uint32Array)return Z;if(Z instanceof Int32Array)return new Uint32Array(Z.buffer,Z.byteOffset,Z.length);const x=Z.slice(l,l+C);return B?new Uint32Array(x):new Uint16Array(x)}(d,0,B,l),f=this._bufferManager.createBufferView(K),J=l?5125:5123;this._accessors.push(this._bufferManager.createAccessor(f,"SCALAR",J,B,0)),b=this._accessors.length-1,W.setIndicesAccessor(Z,C,B,x,a,b)}J.indices=b}}_exportVertexBuffer(Z,l,C,B,x,b){const K=Z.getKind();if(!h(K))return;if(K.startsWith("uv")&&!this._options.exportUnusedUVs&&(!l||!this._materialNeedsUVsSet.has(l)))return;let f=x.getVertexAccessor(Z,C,B);if(void 0===f){const l=x.convertedToRightHandedBuffers.get(Z._buffer)||Z._buffer.getData(),b=K===d.h.PositionKind?function(Z,l,C,B){const{byteOffset:x,byteStride:b,type:K,normalized:f}=l,W=l.getSize(),J=new Array(W).fill(1/0),d=new Array(W).fill(-1/0);return(0,I.g)(Z,x+C*b,b,W,K,B*W,f,(Z=>{for(let l=0;l<W;l++)J[l]=Math.min(J[l],Z[l]),d[l]=Math.max(d[l],Z[l])})),{min:J,max:d}}(l,Z,C,B):void 0,W=(K===d.h.MatricesIndicesKind||K===d.h.MatricesIndicesExtraKind)&&Z.type===d.h.FLOAT,J=W?d.h.UNSIGNED_BYTE:Z.type,E=W?void 0:Z.normalized,G=W?x.getRemappedBufferView(Z._buffer,Z):x.getVertexBufferView(Z._buffer),a=Z.byteOffset+C*Z.byteStride;this._accessors.push(this._bufferManager.createAccessor(G,function(Z,l){if(Z==d.h.ColorKind)return l?"VEC4":"VEC3";switch(Z){case d.h.PositionKind:case d.h.NormalKind:return"VEC3";case d.h.TangentKind:case d.h.MatricesIndicesKind:case d.h.MatricesIndicesExtraKind:case d.h.MatricesWeightsKind:case d.h.MatricesWeightsExtraKind:return"VEC4";case d.h.UVKind:case d.h.UV2Kind:case d.h.UV3Kind:case d.h.UV4Kind:case d.h.UV5Kind:case d.h.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Z}`)}(K,x.hasVertexColorAlpha(Z)),J,B,a,b,E)),f=this._accessors.length-1,x.setVertexAccessor(Z,C,B,f)}b.attributes[function(Z){switch(Z){case d.h.PositionKind:return"POSITION";case d.h.NormalKind:return"NORMAL";case d.h.TangentKind:return"TANGENT";case d.h.ColorKind:return"COLOR_0";case d.h.UVKind:return"TEXCOORD_0";case d.h.UV2Kind:return"TEXCOORD_1";case d.h.UV3Kind:return"TEXCOORD_2";case d.h.UV4Kind:return"TEXCOORD_3";case d.h.UV5Kind:return"TEXCOORD_4";case d.h.UV6Kind:return"TEXCOORD_5";case d.h.MatricesIndicesKind:return"JOINTS_0";case d.h.MatricesIndicesExtraKind:return"JOINTS_1";case d.h.MatricesWeightsKind:return"WEIGHTS_0";case d.h.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Z}`)}(K)]=f}async _exportMaterialAsync(Z,l,C,B){let x=this._materialMap.get(Z);if(void 0===x){const B=l&&Object.keys(l).some((Z=>Z.startsWith("uv")));if((Z=Z instanceof aZ.e?Z.kb[C.materialIndex]:Z)instanceof qZ.e)x=await this._materialExporter.exportPBRMaterialAsync(Z,"image/png",B);else{if(!(Z instanceof zZ.Pl))return void w.e.Warn(`Unsupported material '${Z.name}' with type ${Z.getClassName()}`);x=await this._materialExporter.exportStandardMaterialAsync(Z,"image/png",B)}this._materialMap.set(Z,x)}B.material=x}async _exportMeshAsync(Z,l){var C;let B=l.getMesh(Z);if(void 0!==B)return B;const x={primitives:[]};B=this._meshes.length,this._meshes.push(x),l.setMesh(Z,B);const K=Z.isUnIndexed?null:Z.cb(),f=null===(C=Z.nb)||void 0===C?void 0:C.getVertexBuffers(),W=l.getMorphTargetsFromMesh(Z),J=Z instanceof nZ.d,d=Z instanceof yZ,E=Z.zb;if(f&&E&&E.length>0)for(const q of E){const C={attributes:{}},B=q.MZ()||this._babylonScene.defaultMaterial;if(d){var G,a;const l={name:B.name},x=Z,b=Y.Sl.White(),K=(null===(G=x.material)||void 0===G?void 0:G.alpha)??1,f=(null===(a=x.greasedLineMaterial)||void 0===a?void 0:a.color)??b;(!f.equalsWithEpsilon(b,D.e)||K<1)&&(l.pbrMetallicRoughness={baseColorFactor:[...f.Yb(),K]}),this._materials.push(l),C.material=this._materials.length-1}else if(J){const l={name:B.name},x=Z;(!x.color.equalsWithEpsilon(Y.Sl.White(),D.e)||x.alpha<1)&&(l.pbrMetallicRoughness={baseColorFactor:[...x.color.Yb(),x.alpha]}),this._materials.push(l),C.material=this._materials.length-1}else await this._exportMaterialAsync(B,f,q,C);const E=J||d?b.b.LineListDrawMode:Z.overrideRenderingFillMode??B.fillMode,z=B._getEffectiveOrientation(Z);this._exportIndices(K,K?(0,I.b)(K,q.indexCount,q.indexStart,q.verticesStart):q.verticesCount>65535,K?q.indexStart:q.verticesStart,K?q.indexCount:q.verticesCount,-q.verticesStart,E,z,l,C);for(const Z of Object.values(f))this._exportVertexBuffer(Z,B,q.verticesStart,q.verticesCount,l,C);if(W){C.targets=[];for(const Z of W)C.targets.push(Z.attributes)}x.primitives.push(C),this._extensionsPostExportMeshPrimitive(C)}if(W){x.weights=[],x.extras||(x.extras={}),x.extras.targetNames=[];for(const Z of W)x.weights.push(Z.influence),x.extras.targetNames.push(Z.name)}return B}}TZ._ExtensionNames=new Array,TZ._ExtensionFactories={};class uZ{static async GLTFAsync(Z,l,C){C&&C.exportWithoutWaitingForScene||await Z.whenReadyAsync();const B=new TZ(Z,C),x=await B.generateGLTFAsync(l.replace(/\.[^/.]+$/,""));return B.dispose(),x}static async GLBAsync(Z,l,C){C&&C.exportWithoutWaitingForScene||await Z.whenReadyAsync();const B=new TZ(Z,C),x=await B.generateGLBAsync(l.replace(/\.[^/.]+$/,""));return B.dispose(),x}}C(12987);const HZ="EXT_mesh_gpu_instancing";class QZ{constructor(Z){this.name=HZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Z,l,C,x,b,K){return await new Promise((Z=>{if(l&&C instanceof SZ.b&&C.hasThinInstances&&this._exporter){this._wasUsed=!0;const Z=B.ql.Zero(),x=B.Quaternion.Identity(),f=B.ql.One(),W=C.thinInstanceGetWorldMatrices(),J=B.TmpVectors.ql[2],d=B.TmpVectors.Quaternion[1],E=B.TmpVectors.ql[3];let G=!1,a=!1,q=!1;const z=new Float32Array(3*C.Vb),Y=new Float32Array(4*C.Vb),P=new Float32Array(3*C.Vb);let S=0;for(const l of W)l.decompose(E,d,J),b&&(p(J),N(d)),z.set(J.Yb(),3*S),Y.set(d.normalize().Yb(),4*S),P.set(E.Yb(),3*S),G=G||!J.equalsWithEpsilon(Z),a=a||!d.equalsWithEpsilon(x),q=q||!E.equalsWithEpsilon(f),S++;const i={attributes:{}};G&&(i.attributes.TRANSLATION=this._buildAccessor(z,"VEC3",C.Vb,K)),a&&(i.attributes.ROTATION=this._buildAccessor(Y,"VEC4",C.Vb,K)),q&&(i.attributes.SCALE=this._buildAccessor(P,"VEC3",C.Vb,K)),l.extensions=l.extensions||{},l.extensions[HZ]=i}Z(l)}))}_buildAccessor(Z,l,C,B){const x=B.createBufferView(Z),b=B.createAccessor(x,l,5126,C);return this._exporter._accessors.push(b),this._exporter._accessors.length-1}}TZ.RegisterExtension(HZ,(Z=>new QZ(Z)));var hZ=C(12995),AZ=C(13003),LZ=C(13008),pZ=C(13015);function NZ(Z){return Z===LZ.d.PositionKind?"POSITION":Z===LZ.d.NormalKind?"NORMAL":Z===LZ.d.ColorKind?"COLOR":Z.startsWith(LZ.d.UVKind)?"TEX_COORD":"GENERIC"}const ml={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Zl extends hZ.b{static get DefaultAvailable(){return(0,hZ.f)(Zl.DefaultConfiguration)}static get Default(){return Zl._Default??(Zl._Default=new Zl),Zl._Default}static ResetDefault(Z){Zl._Default&&(Z||Zl._Default.dispose(),Zl._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Z,l){return{module:await(l||DracoEncoderModule)({wasmBinary:Z})}}_getWorkerContent(){return`${AZ.k}(${AZ.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zl.DefaultConfiguration)}async _encodeAsync(Z,l,C){const B=C?(0,pZ.c)(ml,C):ml;if(this._workerPoolPromise){const C=await this._workerPoolPromise;return await new Promise(((x,b)=>{C.push(((C,K)=>{const f=Z=>{C.removeEventListener("error",f),C.removeEventListener("message",W),b(Z),K()},W=Z=>{"encodeMeshDone"===Z.data.id&&(C.removeEventListener("error",f),C.removeEventListener("message",W),x(Z.data.encodedMeshData),K())};C.addEventListener("error",f),C.addEventListener("message",W);const J=[];for(const l of Z)J.push(l.data.buffer);l&&J.push(l.buffer),C.postMessage({id:"encodeMesh",attributes:Z,indices:l,options:B},J)}))}))}if(this._modulePromise){const C=await this._modulePromise;return(0,AZ.k)(C.module,Z,l,B)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Z,l){if(0==Z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Z instanceof SZ.b&&Z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===l||void 0===l?void 0:l.method)&&(w.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),l.method="MESH_SEQUENTIAL_ENCODING");const C=function(Z){let l=Z.cb(void 0,!0);return!l||l instanceof Uint32Array||l instanceof Uint16Array||(l=((0,I.b)(l,l.length)?Uint32Array:Uint16Array).from(l)),l}(Z),B=function(Z,l){const C=[];for(const B of Z.getVerticesDataKinds()){if(null!==l&&void 0!==l&&l.includes(B)){if(B===LZ.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const x=Z.getVertexBuffer(B),b=x.getSize(),K=(0,I.p)(x.getData(),b,x.type,x.byteOffset,x.byteStride,x.normalized,Z.getTotalVertices(),!0);C.push({kind:B,dracoName:NZ(B),size:b,data:K})}return C}(Z,null===l||void 0===l?void 0:l.excludedAttributes);return await this._encodeAsync(B,C,l)}}Zl.DefaultConfiguration={wasmUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${x.Tools._DefaultCdnUrl}/draco_encoder.js`},Zl._Default=null;const ll="KHR_draco_mesh_compression";class Cl{get wasUsed(){return this._wasUsed}constructor(Z){this.name=ll,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Z.options.meshCompressionMethod&&Zl.DefaultAvailable}dispose(){}postExportMeshPrimitive(Z,l,C){if(!this.enabled)return;if(4!==Z.mode&&5!==Z.mode)return void w.e.Warn("Cannot compress primitive with mode "+Z.mode+".");const B=[],x=[];let b=null;if(void 0!==Z.indices){const K=C[Z.indices],f=l.getBufferView(K);b=l.getData(f).slice(),B.push(f),x.push(K)}const K=[];for(const[d,E]of Object.entries(Z.attributes)){const Z=C[E],b=l.getBufferView(Z),W=Q(Z.type),J=(0,I.p)(l.getData(b),W,Z.componentType,Z.byteOffset||0,b.byteStride||(0,I.m)(Z.componentType)*W,Z.normalized||!1,Z.count,!0);K.push({kind:d,dracoName:(f=d,"POSITION"===f?"POSITION":"NORMAL"===f?"NORMAL":f.startsWith("COLOR")?"COLOR":f.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:Q(Z.type),data:J}),B.push(b),x.push(Z)}var f;const W={method:Z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},J=Zl.Default._encodeAsync(K,b,W).then((C=>{if(!C)return void w.e.Error("Draco encoding failed for primitive.");const b={bufferView:-1,attributes:C.attributeIds},K=l.createBufferView(C.data);l.setBufferView(b,K);for(const Z of B)this._bufferViewsUsed.add(Z);for(const Z of x)this._accessorsUsed.add(Z);Z.extensions||(Z.extensions={}),Z.extensions[ll]=b})).catch((Z=>{w.e.Error("Draco encoding failed for primitive: "+Z)}));this._encodePromises.push(J),this._wasUsed=!0}async preGenerateBinaryAsync(Z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((l=>{Z.getPropertiesWithBufferView(l).every((Z=>this._accessorsUsed.has(Z)))&&Z.removeBufferView(l)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}TZ.RegisterExtension(ll,(Z=>new Cl(Z)));var Bl=C(13020);const xl="KHR_lights_punctual",bl={name:"",color:[1,1,1],jb:1,range:Number.MAX_VALUE},Kl={innerConeAngle:0,outerConeAngle:Math.PI/4},fl=B.ql.Backward();class Wl{constructor(Z){this.name=xl,this.enabled=!0,this.required=!1,this._exporter=Z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[xl]=this._lights}async postExportNodeAsync(Z,l,C,x,b){return await new Promise((K=>{if(!(C instanceof iZ.d))return void K(l);const f=C.getTypeID()==iZ.d.LIGHTTYPEID_POINTLIGHT?"point":C.getTypeID()==iZ.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":C.getTypeID()==iZ.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!f||!(C instanceof Bl.e))return w.e.Warn(`${Z}: Light ${C.name} is not supported in ${xl}`),void K(l);if(C.falloffType!==iZ.d.FALLOFF_GLTF&&w.e.Warn(`${Z}: Light falloff for ${C.name} does not match the ${xl} specification!`),!C.position.equalsToFloats(0,0,0)){const Z=B.TmpVectors.ql[0].B(C.position);b&&p(Z),l.translation=Z.Yb()}if("point"!==f){const Z=C.direction.normalizeToRef(B.TmpVectors.ql[0]);b&&p(Z);const x=B.Quaternion.FromUnitVectorsToRef(fl,Z,B.TmpVectors.Quaternion[0]);B.Quaternion.IsIdentity(x)||(l.rotation=x.Yb())}const W={type:f,name:C.name,color:C.Mb.Yb(),jb:C.jb,range:C.range};if(BZ(W,bl),"spot"===f){const Z=C;W.spot={innerConeAngle:Z.innerAngle/2,outerConeAngle:Z.angle/2},BZ(W.spot,Kl)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(W);const J={Zb:this._lights.lights.length-1},d=C.parent;if(d&&lZ(C,d)){const Z=x.get(d);if(Z){const C=this._exporter._nodes[Z];return ZZ(l,C),C.extensions||(C.extensions={}),C.extensions[xl]=J,void K(null)}}l.extensions||(l.extensions={}),l.extensions[xl]=J,K(l)}))}}TZ.RegisterExtension(xl,(Z=>new Wl(Z)));var Jl=C(12928);const dl="KHR_materials_anisotropy";class El{constructor(Z){this.name=dl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof Jl.b&&C.anisotropy.isEnabled&&!C.anisotropy.legacy?(C.anisotropy.texture&&B.push(C.anisotropy.texture),B):[]}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof Jl.b){if(!C.anisotropy.isEnabled||C.anisotropy.legacy)return void Z(l);this._wasUsed=!0,l.extensions=l.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(C.anisotropy.texture),x={anisotropyStrength:C.anisotropy.jb,anisotropyRotation:C.anisotropy.angle,anisotropyTexture:B??void 0};null!==x.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(C),l.extensions[dl]=x}Z(l)}))}}TZ.RegisterExtension(dl,(Z=>new El(Z)));const Gl="KHR_materials_clearcoat";class al{constructor(Z){this.name=Gl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof Jl.b&&C.clearCoat.isEnabled?(C.clearCoat.texture&&B.push(C.clearCoat.texture),!C.clearCoat.useRoughnessFromMainTexture&&C.clearCoat.textureRoughness&&B.push(C.clearCoat.textureRoughness),C.clearCoat.bumpTexture&&B.push(C.clearCoat.bumpTexture),B):[]}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof Jl.b){if(!C.clearCoat.isEnabled)return void Z(l);this._wasUsed=!0,l.extensions=l.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture);let b;b=C.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(C.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(C.clearCoat.textureRoughness),C.clearCoat.isTintEnabled&&x.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${C.name}`),C.clearCoat.remapF0OnInterfaceChange&&x.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${C.name}`);const K=this._exporter._materialExporter.getTextureInfo(C.clearCoat.bumpTexture),f={clearcoatFactor:C.clearCoat.jb,clearcoatTexture:B??void 0,clearcoatRoughnessFactor:C.clearCoat.roughness,clearcoatRoughnessTexture:b??void 0,clearcoatNormalTexture:K??void 0};null===f.clearcoatTexture&&null===f.clearcoatRoughnessTexture&&null===f.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),l.extensions[Gl]=f}Z(l)}))}}TZ.RegisterExtension(Gl,(Z=>new al(Z)));const ql="KHR_materials_diffuse_transmission";function zl(Z,l){const C=l.subSurface;let B=null;return C.translucencyIntensityTexture?B=C.translucencyIntensityTexture:C.thicknessTexture&&C.useMaskFromThicknessTexture&&(B=C.thicknessTexture),B&&!C.useGltfStyleTextures?(w.e.Warn(`${Z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${l.name}`,1),null):B}class Yl{constructor(Z){this.name=ql,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];if(C instanceof qZ.e&&this._isExtensionEnabled(C)){const l=zl(Z,C);return l&&B.push(l),C.subSurface.translucencyColorTexture&&B.push(C.subSurface.translucencyColorTexture),B}return B}_isExtensionEnabled(Z){if(Z.unlit)return!1;const l=Z.subSurface;return!!l.isTranslucencyEnabled&&(!Z.unlit&&!l.useAlbedoToTintTranslucency&&l.useGltfStyleTextures&&1===l.volumeIndexOfRefraction&&0===l.minimumThickness&&0===l.maximumThickness)}postExportMaterialAsync(Z,l,C){return new Promise((B=>{if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0;const B=C.subSurface,x=zl(Z,C),b=0==B.translucencyIntensity?void 0:B.translucencyIntensity,K=this._exporter._materialExporter.getTextureInfo(x)??void 0,f=!B.translucencyColor||B.translucencyColor.equalsFloats(1,1,1)?void 0:B.translucencyColor.Yb(),W=this._exporter._materialExporter.getTextureInfo(B.translucencyColorTexture)??void 0,J={diffuseTransmissionFactor:b,diffuseTransmissionTexture:K,diffuseTransmissionColorFactor:f,diffuseTransmissionColorTexture:W};(K||W)&&this._exporter._materialNeedsUVsSet.add(C),l.extensions=l.extensions||{},l.extensions[ql]=J}B(l)}))}}TZ.RegisterExtension(ql,(Z=>new Yl(Z)));const Pl="KHR_materials_dispersion";class Sl{constructor(){this.name=Pl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){if(Z.unlit)return!1;const l=Z.subSurface;return!(!l.isRefractionEnabled&&!l.isDispersionEnabled)}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Z={dispersion:C.subSurface.dispersion};l.extensions=l.extensions||{},l.extensions[Pl]=Z}Z(l)}))}}TZ.RegisterExtension(Pl,(()=>new Sl));const il="KHR_materials_emissive_strength";class sl{constructor(){this.name=il,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Z,l,C){return await new Promise((Z=>{if(!(C instanceof qZ.e))return Z(l);const B=C.emissiveColor.Yb(),x=Math.max(...B);if(x>1){this._wasUsed=!0,l.extensions||(l.extensions={});const Z={emissiveStrength:x},B=C.emissiveColor.scale(1/Z.emissiveStrength);l.emissiveFactor=B.Yb(),l.extensions[il]=Z}return Z(l)}))}}TZ.RegisterExtension(il,(Z=>new sl));const Fl="KHR_materials_ior";class nl{constructor(){this.name=Fl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.indexOfRefraction&&1.5!=Z.indexOfRefraction)}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Z={ior:C.indexOfRefraction};l.extensions=l.extensions||{},l.extensions[Fl]=Z}Z(l)}))}}TZ.RegisterExtension(Fl,(Z=>new nl));const cl="KHR_materials_iridescence";class Ul{constructor(Z){this.name=cl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof Jl.b&&C.iridescence.isEnabled?(C.iridescence.texture&&B.push(C.iridescence.texture),C.iridescence.thicknessTexture&&C.iridescence.thicknessTexture!==C.iridescence.texture&&B.push(C.iridescence.thicknessTexture),B):[]}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof Jl.b){if(!C.iridescence.isEnabled)return void Z(l);this._wasUsed=!0,l.extensions=l.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(C.iridescence.texture),x=this._exporter._materialExporter.getTextureInfo(C.iridescence.thicknessTexture),b={iridescenceFactor:C.iridescence.jb,iridescenceIor:C.iridescence.indexOfRefraction,iridescenceThicknessMinimum:C.iridescence.minimumThickness,iridescenceThicknessMaximum:C.iridescence.maximumThickness,iridescenceTexture:B??void 0,iridescenceThicknessTexture:x??void 0};null===b.iridescenceTexture&&null===b.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(C),l.extensions[cl]=b}Z(l)}))}}TZ.RegisterExtension(cl,(Z=>new Ul(Z)));const tl="KHR_materials_sheen";class rl{constructor(Z){this.name=tl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){return C instanceof qZ.e&&C.sheen.isEnabled&&C.sheen.texture?[C.sheen.texture]:[]}async postExportMaterialAsync(Z,l,C){return await new Promise((Z=>{if(C instanceof qZ.e){if(!C.sheen.isEnabled)return void Z(l);this._wasUsed=!0,null==l.extensions&&(l.extensions={});const B={sheenColorFactor:C.sheen.color.Yb(),sheenRoughnessFactor:C.sheen.roughness??0};null===B.sheenColorTexture&&null===B.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(C),C.sheen.texture&&(B.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),C.sheen.textureRoughness&&!C.sheen.useRoughnessFromMainTexture?B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.textureRoughness)??void 0:C.sheen.texture&&C.sheen.useRoughnessFromMainTexture&&(B.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(C.sheen.texture)??void 0),l.extensions[tl]=B}Z(l)}))}}TZ.RegisterExtension(tl,(Z=>new rl(Z)));const el="KHR_materials_specular";class ol{constructor(Z){this.name=el,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof qZ.e&&this._isExtensionEnabled(C)?(C.metallicReflectanceTexture&&B.push(C.metallicReflectanceTexture),C.reflectanceTexture&&B.push(C.reflectanceTexture),B):B}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.metallicF0Factor&&1!=Z.metallicF0Factor||void 0!=Z.metallicReflectanceColor&&!Z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.metallicReflectanceTexture||null!=Z.reflectanceTexture}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0,l.extensions=l.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(C.metallicReflectanceTexture)??void 0,B=this._exporter._materialExporter.getTextureInfo(C.reflectanceTexture)??void 0,x={specularFactor:1==C.metallicF0Factor?void 0:C.metallicF0Factor,specularTexture:Z,specularColorFactor:C.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:C.metallicReflectanceColor.Yb(),specularColorTexture:B};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),l.extensions[el]=x}Z(l)}))}}TZ.RegisterExtension(el,(Z=>new ol(Z)));const vl="KHR_materials_transmission";class Rl{constructor(Z){this.name=vl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof qZ.e&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&B.push(C.subSurface.thicknessTexture),B):B}_isExtensionEnabled(Z){if(Z.unlit)return!1;const l=Z.subSurface;return l.isRefractionEnabled&&void 0!=l.refractionIntensity&&0!=l.refractionIntensity||this._hasTexturesExtension(Z)}_hasTexturesExtension(Z){return null!=Z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Z,l,C){if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0;const B=C.subSurface,x={transmissionFactor:0===B.refractionIntensity?void 0:B.refractionIntensity};if(this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),B.refractionIntensityTexture)if(B.useGltfStyleTextures){const Z=await this._exporter._materialExporter.exportTextureAsync(B.refractionIntensityTexture,"image/png");Z&&(x.transmissionTexture=Z)}else w.e.Warn(`${Z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);l.extensions||(l.extensions={}),l.extensions[vl]=x}return l}}TZ.RegisterExtension(vl,(Z=>new Rl(Z)));const kl="KHR_materials_unlit";class Vl{constructor(){this.name=kl,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{let B=!1;C instanceof qZ.e?B=C.unlit:C instanceof zZ.Pl&&(B=C.disableLighting),B&&(this._wasUsed=!0,null==l.extensions&&(l.extensions={}),l.extensions[kl]={}),Z(l)}))}}TZ.RegisterExtension(kl,(()=>new Vl));const gl="KHR_materials_volume";class jl{constructor(Z){this.name=gl,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof qZ.e&&this._isExtensionEnabled(C)?(C.subSurface.thicknessTexture&&B.push(C.subSurface.thicknessTexture),B):B}_isExtensionEnabled(Z){if(Z.unlit)return!1;const l=Z.subSurface;return!(!l.isRefractionEnabled&&!l.isTranslucencyEnabled)&&(void 0!=l.maximumThickness&&0!=l.maximumThickness||void 0!=l.tintColorAtDistance&&l.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=l.tintColor&&l.tintColor!=Y.Sl.White()||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.subSurface.thicknessTexture}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof qZ.e&&this._isExtensionEnabled(C)){this._wasUsed=!0;const Z=C.subSurface,B={thicknessFactor:0==Z.maximumThickness?void 0:Z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Z.thicknessTexture)??void 0,attenuationDistance:Z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Z.tintColorAtDistance,attenuationColor:Z.tintColor.equalsFloats(1,1,1)?void 0:Z.tintColor.Yb()};this._hasTexturesExtension(C)&&this._exporter._materialNeedsUVsSet.add(C),l.extensions=l.extensions||{},l.extensions[gl]=B}Z(l)}))}}TZ.RegisterExtension(gl,(Z=>new jl(Z)));const Ml="EXT_materials_diffuse_roughness";class Il{constructor(Z){this.name=Ml,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,l,C){const B=[];return C instanceof Jl.b&&C._baseDiffuseRoughness?(C._baseDiffuseRoughnessTexture&&B.push(C._baseDiffuseRoughnessTexture),B):[]}postExportMaterialAsync(Z,l,C){return new Promise((Z=>{if(C instanceof Jl.b){if(!C._baseDiffuseRoughness)return void Z(l);this._wasUsed=!0,l.extensions=l.extensions||{};const B=this._exporter._materialExporter.getTextureInfo(C._baseDiffuseRoughnessTexture),x={diffuseRoughnessFactor:C._baseDiffuseRoughness,diffuseRoughnessTexture:B??void 0};null!==x.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(C),l.extensions[Ml]=x}Z(l)}))}}TZ.RegisterExtension(Ml,(Z=>new Il(Z)));const wl="KHR_texture_transform";class Ol{constructor(){this.name=wl,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Z,l,C){if(C.cZ()||x.Tools.Warn(`${Z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${C.name}!`),(0!==C.uAng||0!==C.vAng)&&(x.Tools.Warn(`${Z}: Texture ${C.name} with rotation in the u or v axis is not supported in glTF.`),0!==C.uRotationCenter||0!==C.vRotationCenter))return;const B={};let b=!1;if(0===C.uOffset&&0===C.vOffset||(B.offset=[C.uOffset,C.vOffset],b=!0),1===C.uScale&&1===C.vScale||(B.scale=[C.uScale,C.vScale],b=!0),0!==C.wAng){if(0!==C.uRotationCenter||0!==C.vRotationCenter){if(C.homogeneousRotationInUVTransform&&C.uScale!==C.vScale)return void x.Tools.Warn(`${Z}: Texture ${C.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${wl}.`);x.Tools.Warn(`${Z}: Texture ${C.name} with non-origin rotation center will be exported using an adjusted offset with ${wl}.`),B.offset=function(Z){const{uOffset:l,vOffset:C,uRotationCenter:B,vRotationCenter:x,uScale:b,vScale:K,wAng:f}=Z,W=Math.cos(f),J=Math.sin(f),d=B*b,E=x*K;return[l+(d*(1-W)+E*J),C+(E*(1-W)-d*J)]}(C)}B.rotation=-C.wAng,b=!0}0!==C.coordinatesIndex&&(B.texCoord=C.coordinatesIndex,b=!0),b&&(this._wasUsed=!0,l.extensions||(l.extensions={}),l.extensions[wl]=B)}}TZ.RegisterExtension(wl,(()=>new Ol));class Dl{static CreateSTL(Z){let l=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",x=arguments.length>3&&void 0!==arguments[3]&&arguments[3],b=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],K=arguments.length>5&&void 0!==arguments[5]&&arguments[5],f=arguments.length>6&&void 0!==arguments[6]&&arguments[6],W=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const J=function(Z,l,C){const x=[3*Z[C],3*Z[C+1],3*Z[C+2]],b=[new B.ql(l[x[0]],l[x[0]+2],l[x[0]+1]),new B.ql(l[x[1]],l[x[1]+2],l[x[1]+1]),new B.ql(l[x[2]],l[x[2]+2],l[x[2]+1])],K=b[0].zl(b[1]),f=b[2].zl(b[1]);return{v:b,n:B.ql.Cross(f,K).normalize()}},E=function(Z,l,C,B){return l=G(Z,l,C.x,B),l=G(Z,l,C.y,B),G(Z,l,C.z,B)},G=function(Z,l,C,B){return Z.setFloat32(l,C,B),l+4},q=function(Z){if(f){let l=Z;Z instanceof a.e&&(l=Z.sourceMesh);const C=l.getVerticesData(d.h.PositionKind,!0,!0);if(!C)return[];const x=B.ql.Zero();let b;for(b=0;b<C.length;b+=3)B.ql.TransformCoordinatesFromFloatsToRef(C[b],C[b+1],C[b+2],Z.Fb(!0),x).toArray(C,b);return C}return Z.getVerticesData(d.h.PositionKind)||[]};f&&(K=!0);let z="",Y=0,P=0;if(x){for(let C=0;C<Z.length;C++){const l=Z[C].cb();Y+=l?l.length/3:0}const l=new ArrayBuffer(84+50*Y);z=new DataView(l),P+=80,z.setUint32(P,Y,b),P+=4}else W||(z="solid stlmesh\r\n");for(let B=0;B<Z.length;B++){const l=Z[B];!x&&W&&(z+="solid "+l.name+"\r\n"),!K&&l instanceof SZ.b&&l.bakeCurrentTransformIntoVertices();const C=q(l),f=l.cb()||[];for(let Z=0;Z<f.length;Z+=3){const l=J(f,C,Z);x?(P=E(z,P,l.n,b),P=E(z,P,l.v[0],b),P=E(z,P,l.v[1],b),P=E(z,P,l.v[2],b),P+=2):(z+="\tfacet normal "+l.n.x+" "+l.n.y+" "+l.n.z+"\r\n",z+="\t\touter loop\r\n",z+="\t\t\tvertex "+l.v[0].x+" "+l.v[0].y+" "+l.v[0].z+"\r\n",z+="\t\t\tvertex "+l.v[1].x+" "+l.v[1].y+" "+l.v[1].z+"\r\n",z+="\t\t\tvertex "+l.v[2].x+" "+l.v[2].y+" "+l.v[2].z+"\r\n",z+="\t\tendloop\r\n",z+="\tendfacet\r\n")}!x&&W&&(z+="endsolid "+name+"\r\n")}if(x||W||(z+="endsolid stlmesh"),l){const Z=document.createElement("a"),l=new Blob([z],{type:"application/octet-stream"});Z.href=window.URL.createObjectURL(l),Z.download=C+".stl",Z.click()}return z}}function yl(Z,l){let C=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const B=[];for(let x=0;x<Z.length/C;x++){const b=Z[x*C],K=Z[x*C+1],f=Z[x*C+2];B.push(`(${b.toPrecision(l.precision)}, ${K.toPrecision(l.precision)}, ${f.toPrecision(l.precision)})`)}return B.join(", ")}function Xl(Z,l){const C=[];for(let B=0;B<Z.length/2;B++){const x=Z[2*B],b=Z[2*B+1];C.push(`(${x.toPrecision(l.precision)}, ${(1-b).toPrecision(l.precision)})`)}return C.join(", ")}function Tl(Z,l){const C=Z.getVerticesData(d.h.PositionKind),B=Z.getVerticesData(d.h.NormalKind);if(C&&B)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Z){var l;const C=null!==(l=Z.cb())&&void 0!==l&&l.length?Z.getTotalIndices():Z.getTotalVertices();return Array(C/3).fill(3).join(", ")}(Z)}]\n\t\tint[] faceVertexIndices = [${function(Z){const l=Z.cb(),C=[];if(null!==l)for(let B=0;B<l.length;B++)C.push(l[B]);else{const l=Z.getTotalVertices();for(let Z=0;Z<l;Z++)C.push(Z)}return C.join(", ")}(Z)}]\n\t\tnormal3f[] normals = [${yl(B,l)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${yl(C,l)}]\n        ${function(Z,l){let C="";for(let x=0;x<4;x++){const B=x>0?x:"",b=Z.getVerticesData(d.h.UVKind+(B?B+1:""));b&&(C+=`\n\t\ttexCoord2f[] primvars:st${B} = [${Xl(b,l)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const B=Z.getVerticesData(d.h.ColorKind);return B&&(C+=`\n\tcolor3f[] primvars:displayColor = [${yl(B,l,B.length/Z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),C}(Z,l)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ul(Z,l){return`\n        def "Geometry"\n        {\n        ${Tl(Z,l)}\n        }\n        `}function Hl(Z){let l='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return l+=Z,fflate.strToU8(l)}function Ql(Z){const l=Z.m;return`( ${hl(l,0)}, ${hl(l,4)}, ${hl(l,8)}, ${hl(l,12)} )`}function hl(Z,l){return`(${Z[l+0]}, ${Z[l+1]}, ${Z[l+2]}, ${Z[l+3]})`}function Al(Z){const l="Object_"+Z.uniqueId,C=function(Z){const l=Z.getWorldMatrix().clone(),C=Z.cZ().useRightHandedSystem;if(!C){let B=Z.parent;for(;B;){if(KZ(B,C)){l.multiplyToRef(B.getWorldMatrix().invert(),l);break}B=B.parent}}return l.determinant()<0&&x.Tools.Warn(`Exporting mesh ${Z.name} with negative scale. Result may look incorrect in destination engine.`),l}(Z),B=Ql(C);return`def Xform "${l}" (\n\tprepend references = @./geometries/Geometry_${Z.nb.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${B}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Z.material.uniqueId}>\n}\n\n`}function Ll(Z){switch(Z){case c.c.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case c.c.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case c.c.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function pl(Z){return`(${Z.x}, ${Z.y})`}function Nl(Z){return`(${Z.r}, ${Z.g}, ${Z.b})`}function mC(Z,l,C,x,b,K){const f=Z.getInternalTexture().uniqueId+"_"+Z.invertY;b[f]=Z;const W=Z.coordinatesIndex>0?"st"+Z.coordinatesIndex:"st",J=new B.Vector2(Z.uScale,Z.vScale),d=new B.Vector2(Z.uOffset,Z.vOffset),E=Z.wAng,G=Math.sin(E),a=Math.cos(E);return d.y=1-d.y-J.y,d.x+=G*J.x,d.y+=(1-a)*J.y,`\n    def Shader "PrimvarReader_${C}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${W}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${C}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${l.uniqueId}/PrimvarReader_${C}.outputs:result>\n        float inputs:rotation = ${(E*(180/Math.PI)).toFixed(K.precision)}\n        float2 inputs:scale = ${pl(J)}\n        float2 inputs:translation = ${pl(d)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Z.uniqueId}_${C}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${f}.png@\n        float2 inputs:st.connect = </Materials/Material_${l.uniqueId}/Transform2d_${C}.outputs:result>\n        ${x?"float4 inputs:scale = "+function(Z){return`(${Z.r}, ${Z.g}, ${Z.b}, 1.0)`}(x):""}\n        token inputs:sourceColorSpace = "${Z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ll(Z.wrapU)}"\n        token inputs:wrapT = "${Ll(Z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${l.needAlphaBlending()?"float outputs:a":""}\n    }`}function ZC(Z,l,C){const B="\t\t\t",x=[],b=[],{diffuseMap:K,Mb:f,alphaCutOff:W,emissiveMap:J,emissive:d,normalMap:E,roughnessMap:G,roughnessChannel:a,roughness:q,metalnessMap:z,metalnessChannel:P,metalness:S,aoMap:i,aoMapChannel:s,aoMapIntensity:F,alphaMap:n,ior:c,clearCoatEnabled:U,clearCoat:t,clearCoatMap:r,clearCoatRoughness:e,clearCoatRoughnessMap:o}=function(Z){const l={diffuseMap:null,Mb:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Z instanceof zZ.Pl?{...l,diffuseMap:Z.diffuseTexture,Mb:Z.diffuseColor,alphaCutOff:Z.alphaCutOff,emissiveMap:Z.emissiveTexture,emissive:Z.emissiveColor,roughness:1,alphaMap:Z.opacityTexture}:Z instanceof Jl.b?{...l,diffuseMap:Z._albedoTexture,Mb:Z._albedoColor,alphaCutOff:Z._alphaCutOff,emissiveMap:Z._emissiveTexture,emissive:Z._emissiveColor,normalMap:Z._bumpTexture,roughnessMap:Z._metallicTexture,roughnessChannel:Z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Z._roughness??1,metalnessMap:Z._metallicTexture,metalnessChannel:Z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Z._metallic??0,aoMap:Z._ambientTexture,aoMapChannel:Z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Z._ambientTextureStrength,alphaMap:Z._opacityTexture,ior:Z.subSurface.indexOfRefraction,clearCoatEnabled:Z.clearCoat.isEnabled,clearCoat:Z.clearCoat.jb,clearCoatMap:Z.clearCoat.texture,clearCoatRoughness:Z.clearCoat.roughness,clearCoatRoughnessMap:Z.clearCoat.useRoughnessFromMainTexture?Z.clearCoat.texture:Z.clearCoat.textureRoughness}:l}(Z);return null!==K?(x.push(`${B}color3f inputs:diffuseColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:rgb>`),Z.needAlphaBlending()?x.push(`${B}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:a>`):Z.needAlphaTesting()&&(x.push(`${B}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${K.uniqueId}_diffuse.outputs:a>`),x.push(`${B}float inputs:opacityThreshold = ${W}`)),b.push(mC(K,Z,"diffuse",f,l,C))):x.push(`${B}color3f inputs:diffuseColor = ${Nl(f||Y.Sl.White())}`),null!==J?(x.push(`${B}color3f inputs:emissiveColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${J.uniqueId}_emissive.outputs:rgb>`),b.push(mC(J,Z,"emissive",d,l,C))):d&&d.toLuminance()>0&&x.push(`${B}color3f inputs:emissiveColor = ${Nl(d)}`),null!==E&&(x.push(`${B}normal3f inputs:normal.connect = </Materials/Material_${Z.uniqueId}/Texture_${E.uniqueId}_normal.outputs:rgb>`),b.push(mC(E,Z,"normal",null,l,C))),null!==i&&(x.push(`${B}float inputs:occlusion.connect = </Materials/Material_${Z.uniqueId}/Texture_${i.uniqueId}_occlusion.outputs:${s}>`),b.push(mC(i,Z,"occlusion",new Y.Sl(F,F,F),l,C))),null!==G?(x.push(`${B}float inputs:roughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${G.uniqueId}_roughness.outputs:${a}>`),b.push(mC(G,Z,"roughness",new Y.Sl(q,q,q),l,C))):x.push(`${B}float inputs:roughness = ${q}`),null!==z?(x.push(`${B}float inputs:metallic.connect = </Materials/Material_${Z.uniqueId}/Texture_${z.uniqueId}_metallic.outputs:${P}>`),b.push(mC(z,Z,"metallic",new Y.Sl(S,S,S),l,C))):x.push(`${B}float inputs:metallic = ${S}`),null!==n?(x.push(`${B}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${n.uniqueId}_opacity.outputs:r>`),x.push(`${B}float inputs:opacityThreshold = 0.0001`),b.push(mC(n,Z,"opacity",null,l,C))):x.push(`${B}float inputs:opacity = ${Z.alpha}`),U&&(null!==r?(x.push(`${B}float inputs:clearcoat.connect = </Materials/Material_${Z.uniqueId}/Texture_${r.uniqueId}_clearcoat.outputs:r>`),b.push(mC(r,Z,"clearcoat",new Y.Sl(t,t,t),l,C))):x.push(`${B}float inputs:clearcoat = ${t}`),null!==o?(x.push(`${B}float inputs:clearcoatRoughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${o.uniqueId}_clearcoatRoughness.outputs:g>`),b.push(mC(o,Z,"clearcoatRoughness",new Y.Sl(e,e,e),l,C))):x.push(`${B}float inputs:clearcoatRoughness = ${e}`)),x.push(`${B}float inputs:ior = ${c}`),`\n\tdef Material "Material_${Z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${x.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Z.uniqueId}/PreviewSurface.outputs:surface>\n\n${b.join("\n")}\n\n\t}\n`}async function lC(Z,l,C){const b={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...l};"undefined"===typeof fflate&&await x.Tools.LoadScriptAsync(b.fflateUrl);const K={};K[b.modelFileName]=null;let f='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';f+=function(Z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Z.planeAnchoringAlignment}"`:""}\n            `}(b);const W={};for(const B of Z.meshes){if(0===B.getTotalVertices())continue;const Z=B,l=Z.nb,J=Z.material;if(!J||!l||C&&!C(Z))continue;if(-1!==["Pl","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(J.getClassName())){const C="geometries/Geometry_"+l.uniqueId+".usda";if(!(C in K)){const Z=ul(l,b);K[C]=Hl(Z)}J.uniqueId in W||(W[J.uniqueId]=J),f+=Al(Z)}else x.Tools.Warn("USDZExportAsync does not support this material type: "+J.getClassName())}Z.activeCamera&&b.exportCamera&&(f+=function(Z,l){const C="Camera_"+Z.uniqueId,x=Ql(B.Matrix.RotationY(Math.PI).multiply(Z.getWorldMatrix()));if(Z.mode===c.c.ORTHOGRAPHIC_CAMERA)return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${x}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.ib.toPrecision(l.precision)}, ${Z.maxZ.toPrecision(l.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Z.orthoLeft||1)+Math.abs(Z.orthoRight||1))).toPrecision(l.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Z.orthoTop||1)+Math.abs(Z.orthoBottom||1))).toPrecision(l.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const B=Z.getEngine().getAspectRatio(Z),b=l.cameraSensorWidth||35;return`def Camera "${C}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${x}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.ib.toPrecision(l.precision)}, ${Z.maxZ.toPrecision(l.precision)})\n\t\t\tfloat focalLength = ${(b/(2*Math.tan(.5*Z.fov))).toPrecision(l.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(b*B).toPrecision(l.precision)}\n\t\t\tfloat verticalAperture = ${(b/B).toPrecision(l.precision)}            \n\t\t}\n\t\n\t`}}(Z.activeCamera,b)),f+="\n            }\n        }\n    }";const J={};f+=function(Z,l,C){const B=[];for(const x in Z){const b=Z[x];B.push(ZC(b,l,C))}return`\n    def "Materials"\n{\n${B.join("")}\n}\n\n`}(W,J,b),K[b.modelFileName]=fflate.strToU8(f);for(const B in J){const Z=J[B],l=Z.getSize(),C=await Z.readPixels();if(!C)throw new Error("Texture data is not available");const x=await U.DumpTools.DumpDataAsync(l.width,l.height,C,"image/png",void 0,!1,!0);K[`textures/Texture_${B}.png`]=new Uint8Array(x).slice()}let d=0;for(const B in K){const Z=K[B];if(!Z)continue;d+=34+B.length;const l=63&d;if(4!==l){const C=new Uint8Array(64-l);K[B]=[Z,{extra:{12345:C}}]}d=Z.length}return fflate.zipSync(K,{level:0})}}}]);