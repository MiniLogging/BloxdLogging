"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{12497:(z,u,Y)=>{var H=Y(11046),E=Y(10953),J=Y(10980),l=Y(11064),T=Y(11018),b=Y(11058);T.e.prototype._partialLoadFile=function(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this._loadFile(z,(z=>{Y[u]=z,Y._internalCount++,6===Y._internalCount&&H(Y)}),void 0,void 0,!0,((z,u)=>{E&&z&&E(z.status+" "+z.statusText,u)}))},T.e.prototype._cascadeLoadFiles=function(z,u,Y){let H=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const E=[];E._internalCount=0;for(let J=0;J<6;J++)this._partialLoadFile(Y[J],J,E,u,H)},T.e.prototype._cascadeLoadImgs=function(z,u,Y,H){let E=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,J=arguments.length>5?arguments[5]:void 0;const l=[];l._internalCount=0;for(let T=0;T<6;T++)this._partialLoadImg(H[T],T,l,z,u,Y,E,J)},T.e.prototype._partialLoadImg=function(z,u,Y,H,E,T){let b=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,L=arguments.length>7?arguments[7]:void 0;const D=(0,l.b)();(0,J.s)(z,(z=>{Y[u]=z,Y._internalCount++,H&&H.removePendingData(D),6===Y._internalCount&&T&&T(E,Y)}),((z,u)=>{H&&H.removePendingData(D),b&&b(z,u)}),H?H.offlineProvider:null,L),H&&H.addPendingData(D)},T.e.prototype.createCubeTextureBase=function(z,u,Y,J){let l=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null,T=arguments.length>5&&void 0!==arguments[5]?arguments[5]:null,L=arguments.length>6?arguments[6]:void 0,D=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null,g=arguments.length>8&&void 0!==arguments[8]&&arguments[8],M=arguments.length>9&&void 0!==arguments[9]?arguments[9]:0,q=arguments.length>10&&void 0!==arguments[10]?arguments[10]:0,C=arguments.length>11&&void 0!==arguments[11]?arguments[11]:null,K=arguments.length>12&&void 0!==arguments[12]?arguments[12]:null,h=arguments.length>13&&void 0!==arguments[13]?arguments[13]:null,o=arguments.length>14&&void 0!==arguments[14]&&arguments[14],d=arguments.length>15&&void 0!==arguments[15]?arguments[15]:null;const t=C||new H.d(this,7);t.isCube=!0,t.url=z,t.generateMipMaps=!J,t._lodGenerationScale=M,t._lodGenerationOffset=q,t._useSRGBBuffer=!!o&&this._caps.supportSRGBBuffers&&(this.version>1||this.isWebGPU||!!J),t!==C&&(t.label=z.substring(0,60)),this._doNotHandleContextLost||(t._extension=D,t._files=Y,t._buffer=d);const W=z;this._transformTextureUrl&&!C&&(z=this._transformTextureUrl(z));const Z=D??function(z){const u=z.split("?")[0],Y=u.lastIndexOf(".");return Y>-1?u.substring(Y).toLowerCase():""}(z),s=(0,b.d)(Z),v=(z,u)=>{t.dispose(),T?T(z,u):z&&E.b.Warn(z)},i=(H,T)=>{z===W?H&&v(H.status+" "+H.statusText,T):(E.b.Warn(`Failed to load ${z}, falling back to the ${W}`),this.createCubeTextureBase(W,u,Y,!!J,l,v,L,D,g,M,q,t,K,h,o,d))};if(s)s.then((H=>{const E=z=>{K&&K(t,z),H.loadCubeData(z,t,g,l,((z,u)=>{v(z,u)}))};d?E(d):Y&&6===Y.length?H.supportCascades?this._cascadeLoadFiles(u,(z=>E(z.map((z=>new Uint8Array(z))))),Y,v):v("Textures type does not support cascades."):this._loadFile(z,(z=>E(new Uint8Array(z))),void 0,void 0,!0,i)}));else{if(!Y||0===Y.length)throw new Error("Cannot load cubemap because files were not defined, or the correct loader was not found.");this._cascadeLoadImgs(u,t,((z,u)=>{h&&h(z,u)}),Y,v)}return this._internalTexturesCache.push(t),t}},13211:(z,u,Y)=>{Y.d(u,{DDSTools:()=>C});var H=Y(10937),E=Y(10953),J=Y(11595),l=Y(11408);Y(12497);const T=131072,b=131072;function L(z){return z.charCodeAt(0)+(z.charCodeAt(1)<<8)+(z.charCodeAt(2)<<16)+(z.charCodeAt(3)<<24)}const D=L("DXT1"),g=L("DXT3"),M=L("DXT5"),q=L("DX10");class C{static GetDDSInfo(z){const u=new Int32Array(z.buffer,z.byteOffset,31),Y=new Int32Array(z.buffer,z.byteOffset,35);let H=1;u[2]&T&&(H=Math.max(1,u[7]));const E=u[21],J=E===q?Y[32]:0;let l=0;switch(E){case 113:l=2;break;case 116:l=1;break;case q:if(10===J){l=2;break}if(2===J){l=1;break}}return{width:u[4],height:u[3],mipmapCount:H,isFourCC:4===(4&u[20]),isRGB:64===(64&u[20]),isLuminance:(u[20]&b)===b,isCube:512===(512&u[28]),isCompressed:E===D||E===g||E===M,dxgiFormat:J,textureType:l}}static _GetHalfFloatAsFloatRGBAArrayBuffer(z,u,Y,H,E,J){const T=new Float32Array(H),b=new Uint16Array(E,Y);let L=0;for(let D=0;D<u;D++)for(let u=0;u<z;u++){const Y=4*(u+D*z);T[L]=(0,l.f)(b[Y]),T[L+1]=(0,l.f)(b[Y+1]),T[L+2]=(0,l.f)(b[Y+2]),C.StoreLODInAlphaChannel?T[L+3]=J:T[L+3]=(0,l.f)(b[Y+3]),L+=4}return T}static _GetHalfFloatRGBAArrayBuffer(z,u,Y,H,E,J){if(C.StoreLODInAlphaChannel){const T=new Uint16Array(H),b=new Uint16Array(E,Y);let L=0;for(let Y=0;Y<u;Y++)for(let u=0;u<z;u++){const H=4*(u+Y*z);T[L]=b[H],T[L+1]=b[H+1],T[L+2]=b[H+2],T[L+3]=(0,l.n)(J),L+=4}return T}return new Uint16Array(E,Y,H)}static _GetFloatRGBAArrayBuffer(z,u,Y,H,E,J){if(C.StoreLODInAlphaChannel){const l=new Float32Array(H),T=new Float32Array(E,Y);let b=0;for(let Y=0;Y<u;Y++)for(let u=0;u<z;u++){const H=4*(u+Y*z);l[b]=T[H],l[b+1]=T[H+1],l[b+2]=T[H+2],l[b+3]=J,b+=4}return l}return new Float32Array(E,Y,H)}static _GetFloatAsHalfFloatRGBAArrayBuffer(z,u,Y,H,E,J){const T=new Uint16Array(H),b=new Float32Array(E,Y);let L=0;for(let D=0;D<u;D++)for(let u=0;u<z;u++)T[L]=(0,l.n)(b[L]),T[L+1]=(0,l.n)(b[L+1]),T[L+2]=(0,l.n)(b[L+2]),C.StoreLODInAlphaChannel?T[L+3]=(0,l.n)(J):T[L+3]=(0,l.n)(b[L+3]),L+=4;return T}static _GetFloatAsUIntRGBAArrayBuffer(z,u,Y,E,J,l){const T=new Uint8Array(E),b=new Float32Array(J,Y);let L=0;for(let D=0;D<u;D++)for(let u=0;u<z;u++){const Y=4*(u+D*z);T[L]=255*(0,H.Clamp)(b[Y]),T[L+1]=255*(0,H.Clamp)(b[Y+1]),T[L+2]=255*(0,H.Clamp)(b[Y+2]),C.StoreLODInAlphaChannel?T[L+3]=l:T[L+3]=255*(0,H.Clamp)(b[Y+3]),L+=4}return T}static _GetHalfFloatAsUIntRGBAArrayBuffer(z,u,Y,E,J,T){const b=new Uint8Array(E),L=new Uint16Array(J,Y);let D=0;for(let g=0;g<u;g++)for(let u=0;u<z;u++){const Y=4*(u+g*z);b[D]=255*(0,H.Clamp)((0,l.f)(L[Y])),b[D+1]=255*(0,H.Clamp)((0,l.f)(L[Y+1])),b[D+2]=255*(0,H.Clamp)((0,l.f)(L[Y+2])),C.StoreLODInAlphaChannel?b[D+3]=T:b[D+3]=255*(0,H.Clamp)((0,l.f)(L[Y+3])),D+=4}return b}static _GetRGBAArrayBuffer(z,u,Y,H,E,J,l,T,b){const L=new Uint8Array(H),D=new Uint8Array(E,Y);let g=0;for(let M=0;M<u;M++)for(let u=0;u<z;u++){const Y=4*(u+M*z);L[g]=D[Y+J],L[g+1]=D[Y+l],L[g+2]=D[Y+T],L[g+3]=D[Y+b],g+=4}return L}static _ExtractLongWordOrder(z){return 0===z||255===z||-16777216===z?0:1+C._ExtractLongWordOrder(z>>8)}static _GetRGBArrayBuffer(z,u,Y,H,E,J,l,T){const b=new Uint8Array(H),L=new Uint8Array(E,Y);let D=0;for(let g=0;g<u;g++)for(let u=0;u<z;u++){const Y=3*(u+g*z);b[D]=L[Y+J],b[D+1]=L[Y+l],b[D+2]=L[Y+T],D+=3}return b}static _GetLuminanceArrayBuffer(z,u,Y,H,E){const J=new Uint8Array(H),l=new Uint8Array(E,Y);let T=0;for(let b=0;b<u;b++)for(let u=0;u<z;u++){const Y=u+b*z;J[T]=l[Y],T++}return J}static UploadDDSLevels(z,u,Y,H,l,b){let L=arguments.length>6&&void 0!==arguments[6]?arguments[6]:-1,K=arguments.length>7?arguments[7]:void 0,h=!(arguments.length>8&&void 0!==arguments[8])||arguments[8],o=null;H.sphericalPolynomial&&(o=[]);const d=!!z.getCaps().s3tc;u.generateMipMaps=l;const t=new Int32Array(Y.buffer,Y.byteOffset,31);let W,Z,s,v,i,X,Q,V=0,A=0,x=1;if(542327876!==t[0])return void E.b.Error("Invalid magic number in DDS header");if(!H.isFourCC&&!H.isRGB&&!H.isLuminance)return void E.b.Error("Unsupported format, must contain a FourCC, RGB or LUMINANCE code");if(H.isCompressed&&!d)return void E.b.Error("Compressed textures are not supported on this platform.");let G=t[22];v=t[1]+4;let F=!1;if(H.isFourCC)switch(W=t[21],W){case D:x=8,A=33777;break;case g:x=16,A=33778;break;case M:x=16,A=33779;break;case 113:F=!0,G=64;break;case 116:F=!0,G=128;break;case q:{v+=20;let z=!1;switch(H.dxgiFormat){case 10:F=!0,G=64,z=!0;break;case 2:F=!0,G=128,z=!0;break;case 88:H.isRGB=!0,H.isFourCC=!1,G=32,z=!0}if(z)break}default:return void E.b.Error(["Unsupported FourCC code:",(R=W,String.fromCharCode(255&R,R>>8&255,R>>16&255,R>>24&255))])}var R;const w=C._ExtractLongWordOrder(t[23]),c=C._ExtractLongWordOrder(t[24]),U=C._ExtractLongWordOrder(t[25]),O=C._ExtractLongWordOrder(t[26]);F&&(A=z._getRGBABufferInternalSizedFormat(H.textureType)),X=1,t[2]&T&&!1!==l&&(X=Math.max(1,t[7]));const n=K||0,m=z.getCaps();for(let E=n;E<b;E++){for(Z=t[4],s=t[3],Q=0;Q<X;++Q){if(-1===L||L===Q){const J=-1===L?Q:0;if(!H.isCompressed&&H.isFourCC){u.format=5,V=Z*s*4;let H=null;if(z._badOS||z._badDesktopOS||!m.textureHalfFloat&&!m.textureFloat)128===G?(H=C._GetFloatAsUIntRGBAArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,J),o&&0==J&&o.push(C._GetFloatRGBAArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,J))):64===G&&(H=C._GetHalfFloatAsUIntRGBAArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,J),o&&0==J&&o.push(C._GetHalfFloatAsFloatRGBAArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,J))),u.type=0;else{const z=m.textureFloat&&(h&&m.textureFloatLinearFiltering||!h),E=m.textureHalfFloat&&(h&&m.textureHalfFloatLinearFiltering||!h),l=(128===G||64===G&&!E)&&z?1:(64===G||128===G&&!z)&&E?2:0;let T,b=null;if(128===G)switch(l){case 1:T=C._GetFloatRGBAArrayBuffer,b=null;break;case 2:T=C._GetFloatAsHalfFloatRGBAArrayBuffer,b=C._GetFloatRGBAArrayBuffer;break;case 0:T=C._GetFloatAsUIntRGBAArrayBuffer,b=C._GetFloatRGBAArrayBuffer}else switch(l){case 1:T=C._GetHalfFloatAsFloatRGBAArrayBuffer,b=null;break;case 2:T=C._GetHalfFloatRGBAArrayBuffer,b=C._GetHalfFloatAsFloatRGBAArrayBuffer;break;case 0:T=C._GetHalfFloatAsUIntRGBAArrayBuffer,b=C._GetHalfFloatAsFloatRGBAArrayBuffer}u.type=l,H=T(Z,s,Y.byteOffset+v,V,Y.buffer,J),o&&0==J&&o.push(b?b(Z,s,Y.byteOffset+v,V,Y.buffer,J):H)}H&&z._uploadDataToTextureDirectly(u,H,E,J)}else if(H.isRGB)u.type=0,24===G?(u.format=4,V=Z*s*3,i=C._GetRGBArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,w,c,U),z._uploadDataToTextureDirectly(u,i,E,J)):(u.format=5,V=Z*s*4,i=C._GetRGBAArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer,w,c,U,O),z._uploadDataToTextureDirectly(u,i,E,J));else if(H.isLuminance){const H=z._getUnpackAlignement(),l=Z;V=Math.floor((Z+H-1)/H)*H*(s-1)+l,i=C._GetLuminanceArrayBuffer(Z,s,Y.byteOffset+v,V,Y.buffer),u.format=1,u.type=0,z._uploadDataToTextureDirectly(u,i,E,J)}else V=Math.max(4,Z)/4*Math.max(4,s)/4*x,i=new Uint8Array(Y.buffer,Y.byteOffset+v,V),u.type=0,z._uploadCompressedDataToTextureDirectly(u,A,Z,s,i,E,J)}v+=G?Z*s*(G/8):V,Z*=.5,s*=.5,Z=Math.max(1,Z),s=Math.max(1,s)}if(void 0!==K)break}o&&o.length>0?H.sphericalPolynomial=J.c.ConvertCubeMapToSphericalPolynomial({size:t[4],right:o[0],left:o[1],up:o[2],down:o[3],front:o[4],back:o[5],format:5,type:1,gammaSpace:!1}):H.sphericalPolynomial=void 0}}C.StoreLODInAlphaChannel=!1}}]);