"use strict";(self["1kjc9ee3uyt"]=self["1kjc9ee3uyt"]||[]).push([[26],{12075:(w,E,G)=>{G.r(E),G.d(E,{EXT_materials_diffuse_roughness:()=>ME,EXT_mesh_gpu_instancing:()=>nw,GLTF2Export:()=>Lw,GLTFData:()=>l,KHR_draco_mesh_compression:()=>GE,KHR_lights_punctual:()=>UE,KHR_materials_anisotropy:()=>OE,KHR_materials_clearcoat:()=>VE,KHR_materials_diffuse_transmission:()=>cE,KHR_materials_dispersion:()=>JE,KHR_materials_emissive_strength:()=>KE,KHR_materials_ior:()=>qE,KHR_materials_iridescence:()=>TE,KHR_materials_sheen:()=>jE,KHR_materials_specular:()=>oE,KHR_materials_transmission:()=>kE,KHR_materials_unlit:()=>vE,KHR_materials_volume:()=>sE,KHR_texture_transform:()=>DE,OBJExport:()=>y,STLExport:()=>eE,USDZExportAsync:()=>EG,_ConvertToGLTFPBRMetallicRoughness:()=>N,_SolveMetallic:()=>k,__IGLTFExporterExtension:()=>x});var P=G(11679),h=G(11498),B=G(11986);class y{static OBJ(w,E,G,y){const x=[];let U=1,l=1;E&&(G||(G="mat"),x.push("mtllib "+G+".mtl"));for(let i=0;i<w.length;i++){const G=w[i],O=G.name||`mesh${i}}`;x.push(`o ${O}`);let u=null;if(y){const w=G.Ah(!0);u=new P.Matrix,w.invertToRef(u),G.bakeTransformIntoVertices(w)}if(E){const w=G.material;w&&x.push("usemtl "+w.id)}const V=G.py;if(!V){h.Tools.Warn("No geometry is present on the mesh");continue}const a=V.getVerticesData("position"),Q=V.getVerticesData("normal"),c=V.getVerticesData("uv"),Z=V.ny();let J=0,d=0;if(!a||!Z){h.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const K=w[0].Ww().useRightHandedSystem?1:-1;for(let w=0;w<a.length;w+=3)x.push("v "+a[w]*K+" "+a[w+1]+" "+a[w+2]),J++;if(null!=Q)for(let w=0;w<Q.length;w+=3)x.push("vn "+Q[w]*K+" "+Q[w+1]+" "+Q[w+2]);if(null!=c)for(let w=0;w<c.length;w+=2)x.push("vt "+c[w]+" "+c[w+1]),d++;const t=["","",""],q=(G.material||G.Ww().defaultMaterial)._getEffectiveOrientation(G),[W,T]=q===B.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let w=0;w<Z.length;w+=3){const E=[String(Z[w]+U),String(Z[w+W]+U),String(Z[w+T]+U)],G=[String(Z[w]+l),String(Z[w+W]+l),String(Z[w+T]+l)],P=E,h=null!=c?G:t,B=null!=Q?E:t;x.push("f "+P[0]+"/"+h[0]+"/"+B[0]+" "+P[1]+"/"+h[1]+"/"+B[1]+" "+P[2]+"/"+h[2]+"/"+B[2])}y&&u&&G.bakeTransformIntoVertices(u),U+=J,l+=d}return x.join("\n")}static MTL(w){const E=[],G=w.material;E.push("newmtl mat1"),E.push("  Ns "+G.specularPower.toFixed(4)),E.push("  Ni 1.5000"),E.push("  d "+G.alpha.toFixed(4)),E.push("  Tr 0.0000"),E.push("  Tf 1.0000 1.0000 1.0000"),E.push("  illum 2"),E.push("  Ka "+G.ambientColor.r.toFixed(4)+" "+G.ambientColor.g.toFixed(4)+" "+G.ambientColor.b.toFixed(4)),E.push("  Kd "+G.diffuseColor.r.toFixed(4)+" "+G.diffuseColor.g.toFixed(4)+" "+G.diffuseColor.b.toFixed(4)),E.push("  Ks "+G.specularColor.r.toFixed(4)+" "+G.specularColor.g.toFixed(4)+" "+G.specularColor.b.toFixed(4)),E.push("  Ke "+G.emissiveColor.r.toFixed(4)+" "+G.emissiveColor.g.toFixed(4)+" "+G.emissiveColor.b.toFixed(4));G.ambientTexture&&E.push("  map_Ka "+G.ambientTexture.name),G.diffuseTexture&&E.push("  map_Kd "+G.diffuseTexture.name),G.specularTexture&&E.push("  map_Ks "+G.specularTexture.name),G.bumpTexture&&E.push("  map_bump -imfchan z "+G.bumpTexture.name),G.opacityTexture&&E.push("  map_d "+G.opacityTexture.name);return E.join("\n")}}var x=0,U=G(11547);class l{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const w in this.files){const E=this.files[w],G=new Blob([E],{type:(0,U.j)(w)});h.Tools.Download(G,w)}}}var i=G(11748),O=G(12079),u=G(12087),V=G(12098),a=G(11797),Q=G(11543),c=G(11716),Z=G(11689);const J=Z.HighestCommonFactor,d={...Z,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:J};var K=G(11890),t=G(11663),q=G(12132),W=G(12134),T=G(11886);const I=1e-6,j=new c.dE(.04,.04,.04),g=1024,o=c.dE.White(),f=c.dE.Black();function k(w,E,G){if(E<j.r)return 0;const P=j.r,h=w*G/(1-j.r)+E-2*j.r,B=h*h-4*P*(j.r-E);return d.Clamp((-h+Math.sqrt(B))/(2*P),0,1)}function N(w){const E=w.diffuseColor.toLinearSpace(w.Ww().getEngine().useExactSrgbConversions).scale(.5),G=w.alpha,h=function(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new P.Vector2(0,1),G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new P.Vector2(0,.1),h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new P.Vector2(0,.1),B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new P.Vector2(1300,.1);return function(w,E,G,P,h){return(1-w)*(1-w)*(1-w)*E+3*(1-w)*(1-w)*w*G+3*(1-w)*w*w*P+w*w*w*h}(Math.pow(w/B.x,.333333),E.y,G.y,h.y,B.y)}(d.Clamp(w.specularPower,0,g));return{baseColorFactor:[E.r,E.g,E.b,G],metallicFactor:0,roughnessFactor:h}}function v(w,E){E.needAlphaBlending()?w.alphaMode="BLEND":E.needAlphaTesting()&&(w.alphaMode="MASK",w.alphaCutoff=E.alphaCutOff)}function C(w,E,G){const P=new Uint8Array(w*E*4);for(let h=0;h<P.length;h+=4)P[h]=P[h+1]=P[h+2]=P[h+3]=255;return q.e.CreateRGBATexture(P,w,E,G)}function s(w){if(w instanceof Uint8Array){const E=w.length,G=new Float32Array(w.length);for(let P=0;P<E;++P)G[P]=w[P]/255;return G}if(w instanceof Float32Array)return w;throw new Error("Unsupported pixel format!")}class F{constructor(w){this._exporter=w,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(w){return w?this._textureMap.get(w)??null:null}async exportStandardMaterialAsync(w,E,G){const P=N(w),B={name:w.name};if(null==w.Kx||w.Kx||(w.twoSidedLighting||h.Tools.Warn(w.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),B.doubleSided=!0),G){const G=[],h=w.diffuseTexture;h&&G.push(this.exportTextureAsync(h,E).then((w=>{w&&(P.baseColorTexture=w)})));const y=w.bumpTexture;y&&G.push(this.exportTextureAsync(y,E).then((w=>{w&&(B.normalTexture=w,1!==y.level&&(B.normalTexture.scale=y.level))})));const x=w.emissiveTexture;x&&(B.emissiveFactor=[1,1,1],G.push(this.exportTextureAsync(x,E).then((w=>{w&&(B.emissiveTexture=w)}))));const U=w.ambientTexture;U&&G.push(this.exportTextureAsync(U,E).then((w=>{if(w){const E={index:w.index};B.occlusionTexture=E}}))),G.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(G))}(w.alpha<1||w.opacityTexture)&&(w.alphaMode===W.e.ALPHA_COMBINE?B.alphaMode="BLEND":h.Tools.Warn(w.name+": glTF 2.0 does not support alpha mode: "+w.alphaMode.toString())),w.emissiveColor&&!w.emissiveColor.equalsWithEpsilon(f,I)&&(B.emissiveFactor=w.emissiveColor.Lh()),B.pbrMetallicRoughness=P,v(B,w),await this._finishMaterialAsync(B,w,E);const y=this._exporter._materials;return y.push(B),y.length-1}async _finishMaterialAsync(w,E,G){const P=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",w,E),h=[];for(const B of P)h.push(this.exportTextureAsync(B,G));await Promise.all(h),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",w,E)}async _getImageDataAsync(w,E,P,h){const B=W.e.TEXTURETYPE_UNSIGNED_BYTE,y=this._exporter._babylonScene,x=y.getEngine(),U=x.createRawTexture(w,E,P,W.e.TEXTUREFORMAT_RGBA,!1,!0,t.c.NEAREST_SAMPLINGMODE,null,B);x.isWebGPU?await G.e(51).then(G.bind(G,14039)):await G.e(52).then(G.bind(G,14044)),await K.m.ApplyPostProcess("pass",U,y,B,W.e.TEXTURE_NEAREST_SAMPLINGMODE,W.e.TEXTUREFORMAT_RGBA);const l=await x._readTexturePixels(U,E,P);return await T.DumpTools.DumpDataAsync(E,P,l,h,void 0,!0,!0)}_resizeTexturesToSameDimensions(w,E,G){const P=w?w.getSize():{width:0,height:0},h=E?E.getSize():{width:0,height:0};let B,y;return P.width<h.width?(B=w&&w instanceof t.c?K.m.CreateResizedCopy(w,h.width,h.height,!0):C(h.width,h.height,G),y=E):P.width>h.width?(y=E&&E instanceof t.c?K.m.CreateResizedCopy(E,P.width,P.height,!0):C(P.width,P.height,G),B=w):(B=w,y=E),{texture1:B,texture2:y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(w,E,G,P){const h=new Array;if(!w&&!E)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const B=w?w.Ww():E?E.Ww():null;if(B){var y;const x=this._resizeTexturesToSameDimensions(w,E,B),U=null===(y=x.texture1)||void 0===y?void 0:y.getSize();let l,i;const O=U.width,u=U.height,V=await x.texture1.readPixels(),a=await x.texture2.readPixels();if(!V)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(l=s(V),!a)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");i=s(a);const Q=i.byteLength,Z=new Uint8Array(Q),J=new Uint8Array(Q),d=4,K=f;let t=0,q=0;for(let w=0;w<u;++w)for(let E=0;E<O;++E){const P=(O*w+E)*d,h={diffuseColor:new c.dE(l[P],l[P+1],l[P+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(G.diffuseColor),specularColor:new c.dE(i[P],i[P+1],i[P+2]).toLinearSpace(B.getEngine().useExactSrgbConversions).multiply(G.specularColor),glossiness:i[P+3]*G.glossiness},y=this._convertSpecularGlossinessToMetallicRoughness(h);K.r=Math.max(K.r,y.baseColor.r),K.g=Math.max(K.g,y.baseColor.g),K.b=Math.max(K.b,y.baseColor.b),t=Math.max(t,y.metallic),q=Math.max(q,y.roughness),J[P]=255*y.baseColor.r,J[P+1]=255*y.baseColor.g,J[P+2]=255*y.baseColor.b,J[P+3]=x.texture1.mh?255*l[P+3]:255,Z[P]=0,Z[P+1]=255*y.roughness,Z[P+2]=255*y.metallic,Z[P+3]=255}const W={baseColor:K,metallic:t,roughness:q};let T=!1,j=!1;for(let w=0;w<u;++w)for(let E=0;E<O;++E){const G=(O*w+E)*d;J[G]/=W.baseColor.r>I?W.baseColor.r:1,J[G+1]/=W.baseColor.g>I?W.baseColor.g:1,J[G+2]/=W.baseColor.b>I?W.baseColor.b:1;const P=c.dE.FromInts(J[G],J[G+1],J[G+2]).toGammaSpace(B.getEngine().useExactSrgbConversions);J[G]=255*P.r,J[G+1]=255*P.g,J[G+2]=255*P.b,P.equalsWithEpsilon(o,I)||(j=!0),Z[G+1]/=W.roughness>I?W.roughness:1,Z[G+2]/=W.metallic>I?W.metallic:1;c.dE.FromInts(255,Z[G+1],Z[G+2]).equalsWithEpsilon(o,I)||(T=!0)}return T&&h.push(this._getImageDataAsync(Z,O,u,P).then((w=>{W.metallicRoughnessTextureData=w}))),j&&h.push(this._getImageDataAsync(J,O,u,P).then((w=>{W.baseColorTextureData=w}))),await Promise.all(h).then((()=>W))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(w){const E=this._getPerceivedBrightness(w.diffuseColor),G=this._getPerceivedBrightness(w.specularColor),P=1-this._getMaxComponent(w.specularColor),h=k(E,G,P),B=w.diffuseColor.scale(P/(1-j.r)/Math.max(1-h)),y=w.specularColor.cE(j.scale(1-h)).scale(1/Math.max(h));let x=c.dE.Lerp(B,y,h*h);x=x.clampToRef(0,1,x);return{baseColor:x,metallic:h,roughness:1-w.glossiness}}_getPerceivedBrightness(w){return w?Math.sqrt(.299*w.r*w.r+.587*w.g*w.g+.114*w.b*w.b):0}_getMaxComponent(w){return w?Math.max(w.r,Math.max(w.g,w.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(w,E,G,P){const h=[],B={baseColor:w._albedoColor,metallic:w._metallic,roughness:w._roughness};if(P){w._albedoTexture&&h.push(this.exportTextureAsync(w._albedoTexture,E).then((w=>{w&&(G.baseColorTexture=w)})));const P=w._metallicTexture;P&&h.push(this.exportTextureAsync(P,E).then((w=>{w&&(G.metallicRoughnessTexture=w)})))}return h.length>0&&(this._exporter._materialNeedsUVsSet.add(w),await Promise.all(h)),B}_getTextureSampler(w){const E={};if(!w||!(w instanceof t.c))return E;const G=this._getGLTFTextureWrapMode(w.wrapU);10497!==G&&(E.wrapS=G);const P=this._getGLTFTextureWrapMode(w.wrapV);switch(10497!==P&&(E.wrapT=P),w.samplingMode){case t.c.LINEAR_LINEAR:E.magFilter=9729,E.minFilter=9729;break;case t.c.LINEAR_NEAREST:E.magFilter=9729,E.minFilter=9728;break;case t.c.NEAREST_LINEAR:E.magFilter=9728,E.minFilter=9729;break;case t.c.NEAREST_LINEAR_MIPLINEAR:E.magFilter=9728,E.minFilter=9987;break;case t.c.NEAREST_NEAREST:E.magFilter=9728,E.minFilter=9728;break;case t.c.NEAREST_LINEAR_MIPNEAREST:E.magFilter=9728,E.minFilter=9985;break;case t.c.LINEAR_NEAREST_MIPNEAREST:E.magFilter=9729,E.minFilter=9984;break;case t.c.LINEAR_NEAREST_MIPLINEAR:E.magFilter=9729,E.minFilter=9986;break;case t.c.NEAREST_NEAREST_MIPLINEAR:E.magFilter=9728,E.minFilter=9986;break;case t.c.LINEAR_LINEAR_MIPLINEAR:E.magFilter=9729,E.minFilter=9987;break;case t.c.LINEAR_LINEAR_MIPNEAREST:E.magFilter=9729,E.minFilter=9985;break;case t.c.NEAREST_NEAREST_MIPNEAREST:E.magFilter=9728,E.minFilter=9984}return E}_getGLTFTextureWrapMode(w){switch(w){case t.c.WRAP_ADDRESSMODE:return 10497;case t.c.CLAMP_ADDRESSMODE:return 33071;case t.c.MIRROR_ADDRESSMODE:return 33648;default:return h.Tools.Error(`Unsupported Texture Wrap Mode ${w}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(w,E,G,P){const h={diffuseColor:w._albedoColor,specularColor:w._reflectivityColor,glossiness:w._microSurface},B=w._albedoTexture,y=w._reflectivityTexture,x=w._useMicroSurfaceFromReflectivityMapAlpha;if(y&&!x)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((B||y)&&P){this._exporter._materialNeedsUVsSet.add(w);const P=this._exportTextureSampler(B||y),x=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(B,y,h,E),U=this._exporter._textures;if(x.baseColorTextureData){const w=this._exportImage(`baseColor${U.length}`,E,x.baseColorTextureData);G.baseColorTexture=this._exportTextureInfo(w,P,null===B||void 0===B?void 0:B.coordinatesIndex)}if(x.metallicRoughnessTextureData){const w=this._exportImage(`metallicRoughness${U.length}`,E,x.metallicRoughnessTextureData);G.metallicRoughnessTexture=this._exportTextureInfo(w,P,null===y||void 0===y?void 0:y.coordinatesIndex)}return x}return this._convertSpecularGlossinessToMetallicRoughness(h)}async exportPBRMaterialAsync(w,E,G){const P={},h={name:w.name},B=w.isMetallicWorkflow();if(B){const E=w._albedoColor,G=w.alpha;E&&(P.baseColorFactor=[E.r,E.g,E.b,G])}const y=B?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(w,E,P,G):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(w,E,P,G);await this._setMetallicRoughnessPbrMaterialAsync(y,w,h,P,E,G),await this._finishMaterialAsync(h,w,E);const x=this._exporter._materials;return x.push(h),x.length-1}async _setMetallicRoughnessPbrMaterialAsync(w,E,G,P,B,y){if(v(G,E),w.baseColor.equalsWithEpsilon(o,I)&&d.WithinEpsilon(E.alpha,1,I)||(P.baseColorFactor=[w.baseColor.r,w.baseColor.g,w.baseColor.b,E.alpha]),null!=w.metallic&&1!==w.metallic&&(P.metallicFactor=w.metallic),null!=w.roughness&&1!==w.roughness&&(P.roughnessFactor=w.roughness),null==E.Kx||E.Kx||(E._twoSidedLighting||h.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),G.doubleSided=!0),y){const w=[],P=E._bumpTexture;P&&w.push(this.exportTextureAsync(P,B).then((w=>{w&&(G.normalTexture=w,1!==P.level&&(G.normalTexture.scale=P.level))})));const h=E._ambientTexture;h&&w.push(this.exportTextureAsync(h,B).then((w=>{if(w){const P={index:w.index,texCoord:w.texCoord,extensions:w.extensions};G.occlusionTexture=P;const h=E._ambientTextureStrength;h&&(P.strength=h)}})));const y=E._emissiveTexture;y&&w.push(this.exportTextureAsync(y,B).then((w=>{w&&(G.emissiveTexture=w)}))),w.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(w))}const x=E._emissiveColor;x.equalsWithEpsilon(f,I)||(G.emissiveFactor=x.Lh()),G.pbrMetallicRoughness=P}_getPixelsFromTextureAsync(w){return function(w){switch(w){case W.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case W.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case W.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case W.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case W.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case W.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case W.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case W.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case W.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case W.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case W.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case W.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case W.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(w.textureFormat)?(0,K.l)(w,w._texture.width,w._texture.height):(w.textureType,W.e.TEXTURETYPE_UNSIGNED_BYTE,w.readPixels())}async exportTextureAsync(w,E){const G=this._exporter._extensionsPreExportTextureAsync("exporter",w,E);return G?await G.then((async G=>G?await this._exportTextureInfoAsync(G,E):await this._exportTextureInfoAsync(w,E))):await this._exportTextureInfoAsync(w,E)}async _exportTextureInfoAsync(w,E){let G=this._textureMap.get(w);if(!G){const P=await this._getPixelsFromTextureAsync(w);if(!P)return null;const B=this._exportTextureSampler(w),y=w.mimeType;if(y)switch(y){case"image/jpeg":case"image/png":case"image/webp":E=y;break;default:h.Tools.Warn(`Unsupported media type: ${y}. Exporting texture as PNG.`)}const x=this._internalTextureToImage,U=w.getInternalTexture().uniqueId;x[U]||(x[U]={});let l=x[U][E];if(void 0===l){const G=w.getSize();l=(async()=>{const h=await this._getImageDataAsync(P,G.width,G.height,E);return this._exportImage(w.name,E,h)})(),x[U][E]=l}G=this._exportTextureInfo(await l,B,w.coordinatesIndex),this._textureMap.set(w,G),this._exporter._extensionsPostExportTextures("exporter",G,w)}return G}_exportImage(w,E,G){const P=this._exporter._images;let B;if(this._exporter._shouldUseGlb){B={name:w,mimeType:E,bufferView:void 0};const P=this._exporter._bufferManager.createBufferView(new Uint8Array(G));this._exporter._bufferManager.setBufferView(B,P)}else{const y=w.replace(/\.\/|\/|\.\\|\\/g,"_"),x=function(w){switch(w){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(E);let U=y+x;P.some((w=>w.uri===U))&&(U=`${y}_${h.Tools.RandomId()}${x}`),B={name:w,uri:U},this._exporter._imageData[U]={data:G,mimeType:E}}return P.push(B),P.length-1}_exportTextureInfo(w,E,G){const P=this._exporter._textures;let h=P.findIndex((G=>G.sampler==E&&G.source===w));-1===h&&(h=P.length,P.push({source:w,sampler:E}));const B={index:h};return G&&(B.texCoord=G),B}_exportTextureSampler(w){const E=this._getTextureSampler(w),G=this._exporter._samplers,P=G.findIndex((w=>w.minFilter===E.minFilter&&w.magFilter===E.magFilter&&w.wrapS===E.wrapS&&w.wrapT===E.wrapT));return-1!==P?P:(G.push(E),G.length-1)}}var M=G(11760),p=G(11518),D=G(12139),e=G(11681);const R=P.QE.Zero(),H=P.Quaternion.Identity(),z=P.QE.One(),L=new P.QE(-1,1,1);function m(w,E){const{byteOffset:G,byteStride:P,type:h,normalized:B}=w,y=w.getSize(),x=E.reduce(((w,E)=>E.getTotalVertices()>w?E.getTotalVertices():w),-Number.MAX_VALUE);return{byteOffset:G,byteStride:P,componentCount:y,type:h,count:x*y,normalized:B,totalVertices:x,kind:w.getKind()}}function n(w){switch(w){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function r(w){switch(w){case i.g.PositionKind:case i.g.NormalKind:case i.g.TangentKind:case i.g.ColorKind:case i.g.MatricesIndicesKind:case i.g.MatricesIndicesExtraKind:case i.g.MatricesWeightsKind:case i.g.MatricesWeightsExtraKind:case i.g.UVKind:case i.g.UV2Kind:case i.g.UV3Kind:case i.g.UV4Kind:case i.g.UV5Kind:case i.g.UV6Kind:return!0}return!1}function Y(w){switch(w){case B.b.TriangleFillMode:return 4;case B.b.TriangleStripDrawMode:return 5;case B.b.TriangleFanDrawMode:return 6;case B.b.PointListDrawMode:case B.b.PointFillMode:return 0;case B.b.LineLoopDrawMode:return 2;case B.b.LineListDrawMode:return 1;case B.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${w}`)}function S(w){const E=Math.sqrt(w.x*w.x+w.y*w.y+w.z*w.z);E>0&&(w.x/=E,w.y/=E,w.z/=E)}function X(w){return w.x*=-1,w}function b(w){if(w.x*w.x+w.y*w.y>.5){const E=Math.abs(w.x),G=Math.abs(w.y);if(E>G){const G=Math.sign(w.x);w.x=E,w.y*=-G,w.z*=-G,w.w*=G}else{const E=Math.sign(w.y);w.x*=-E,w.y=G,w.z*=E,w.w*=-E}}else{const E=Math.abs(w.z),G=Math.abs(w.w);if(E>G){const G=Math.sign(w.z);w.x*=-G,w.y*=G,w.z=E,w.w*=-G}else{const E=Math.sign(w.w);w.x*=E,w.y*=-E,w.z*=-E,w.w=G}}return w}function A(w){w.tx(-w.z,w.w,w.x,-w.y)}function ww(w,E){const G=P.QE.FromArrayToRef(E.translation||[0,0,0],0,P.TmpVectors.QE[0]),h=P.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,P.TmpVectors.Quaternion[0]),B=P.Matrix.ComposeToRef(z,h,G,P.TmpVectors.Matrix[0]),y=P.QE.FromArrayToRef(w.translation||[0,0,0],0,P.TmpVectors.QE[2]),x=P.Quaternion.FromArrayToRef(w.rotation||[0,0,0,1],0,P.TmpVectors.Quaternion[1]),U=P.Matrix.ComposeToRef(z,x,y,P.TmpVectors.Matrix[1]);B.multiplyToRef(U,U),U.decompose(void 0,h,G),G.equalsWithEpsilon(R,e.d)?delete E.translation:E.translation=G.Lh(),h.equalsWithEpsilon(H,e.d)?delete E.rotation:E.rotation=h.Lh(),E.scale&&delete E.scale}function Ew(w,E){if(!(E instanceof O.e))return!1;if(!(1===E.getChildren().length&&0===w.getChildren().length&&w.parent===E))return!1;const G=w.Ww(),P=w instanceof D.c&&!G.useRightHandedSystem?L:z;return!!E.qx.equalsWithEpsilon(P,e.d)||(p.e.Warn(`Cannot collapse node ${w.name} into parent node ${E.name} with modified scaling.`),!1)}function Gw(w){if(w instanceof Array){const E=new Float32Array(w);return new Uint8Array(E.buffer,E.byteOffset,E.byteLength)}return ArrayBuffer.isView(w)?new Uint8Array(w.buffer,w.byteOffset,w.byteLength):new Uint8Array(w)}function Pw(w,E){for(const[G,P]of Object.entries(w)){const h=E[G];(Array.isArray(P)&&Array.isArray(h)&&hw(P,h)||P===h)&&delete w[G]}return w}function hw(w,E){return w.length===E.length&&w.every(((w,G)=>w===E[G]))}const Bw=P.Matrix.Compose(new P.QE(-1,1,1),P.Quaternion.Identity(),P.QE.Zero());function yw(w,E){if(!(w instanceof O.e))return!1;if(E){if(!w.getWorldMatrix().equalsWithEpsilon(P.Matrix.IdentityReadOnly,e.d))return!1}else{if(!w.getWorldMatrix().multiplyToRef(Bw,P.TmpVectors.Matrix[0]).equalsWithEpsilon(P.Matrix.IdentityReadOnly,e.d))return!1}return!(w instanceof u.b&&w.py)}const xw=new Map([[Int8Array,(w,E,G)=>w.setInt8(E,G)],[Uint8Array,(w,E,G)=>w.setUint8(E,G)],[Uint8ClampedArray,(w,E,G)=>w.setUint8(E,G)],[Int16Array,(w,E,G)=>w.setInt16(E,G,!0)],[Uint16Array,(w,E,G)=>w.setUint16(E,G,!0)],[Int32Array,(w,E,G)=>w.setInt32(E,G,!0)],[Uint32Array,(w,E,G)=>w.setUint32(E,G,!0)],[Float32Array,(w,E,G)=>w.setFloat32(E,G,!0)],[Float64Array,(w,E,G)=>w.setFloat64(E,G,!0)]]);class Uw{writeTypedArray(w){this._checkGrowBuffer(w.byteLength);const E=xw.get(w.constructor);for(let G=0;G<w.length;G++)E(this._dataView,this._byteOffset,w[G]),this._byteOffset+=w.BYTES_PER_ELEMENT}constructor(w){this._data=new Uint8Array(w),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(w){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,w),this._byteOffset++}writeInt8(w){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,w),this._byteOffset++}writeInt16(w){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,w,!0),this._byteOffset+=2}writeUInt16(w){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,w,!0),this._byteOffset+=2}writeInt32(w){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,w,!0),this._byteOffset+=4}writeUInt32(w){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat32(w){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,w,!0),this._byteOffset+=4}writeFloat64(w){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,w,!0),this._byteOffset+=8}_checkGrowBuffer(w){const E=this.byteOffset+w;if(E>this._data.byteLength){const w=new Uint8Array(2*E);w.set(this._data),this._data=w,this._dataView=new DataView(this._data.buffer)}}}function lw(w){return w%4===0?4:w%2===0?2:1}class iw{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(w){let E=0;this._bufferViewToData.forEach((w=>{E+=w.byteLength}));const G=new Uw(E),P=Array.from(this._bufferViewToData.keys()).sort(((w,E)=>lw(E.byteLength)-lw(w.byteLength)));for(const h of P){h.byteOffset=G.byteOffset,w.push(h);const E=w.length-1,P=this.getPropertiesWithBufferView(h);for(const w of P)w.bufferView=E;G.writeTypedArray(this._bufferViewToData.get(h)),this._bufferViewToData.delete(h)}return G.getOutputData()}createBufferView(w,E){const G={buffer:0,byteOffset:void 0,byteLength:w.byteLength,byteStride:E};return this._bufferViewToData.set(G,w),G}createAccessor(w,E,G,P,h,B,y){this._verifyBufferView(w);const x={bufferView:void 0,componentType:G,count:P,type:E,min:null===B||void 0===B?void 0:B.min,max:null===B||void 0===B?void 0:B.max,normalized:y,byteOffset:h};return this.setBufferView(x,w),this._accessorToBufferView.set(x,w),x}setBufferView(w,E){this._verifyBufferView(E);this.getPropertiesWithBufferView(E).push(w)}removeBufferView(w){const E=this.getPropertiesWithBufferView(w);for(const G of E)void 0!==G.bufferView&&delete G.bufferView;this._bufferViewToData.delete(w),this._bufferViewToProperties.delete(w),this._accessorToBufferView.forEach(((E,G)=>{E===w&&(void 0!==G.byteOffset&&delete G.byteOffset,this._accessorToBufferView.delete(G))}))}getBufferView(w){const E=this._accessorToBufferView.get(w);return this._verifyBufferView(E),E}getPropertiesWithBufferView(w){return this._verifyBufferView(w),this._bufferViewToProperties.set(w,this._bufferViewToProperties.get(w)??[]),this._bufferViewToProperties.get(w)}getData(w){return this._verifyBufferView(w),this._bufferViewToData.get(w)}_verifyBufferView(w){if(void 0===w||!this._bufferViewToData.has(w))throw new Error(`BufferView ${w} not found in BufferManager.`)}}var Ow,uw=G(12110),Vw=G(12130),aw=G(12145),Qw=G(12036),cw=G(12181),Zw=G(12191),Jw=G(12103),dw=G(12194);!function(w){w[w.INTANGENT=0]="INTANGENT",w[w.OUTTANGENT=1]="OUTTANGENT"}(Ow||(Ow={}));class Kw{static _IsTransformable(w){return w&&(w instanceof O.e||w instanceof uw.c||w instanceof dw.e)}static _CreateNodeAnimation(w,E,G,P,B){if(this._IsTransformable(w)){const y=[],x=[],U=E.getKeys(),l=Kw._CalculateMinMaxKeyFrames(U),i=Kw._DeduceInterpolation(U,G,P),O=i.interpolationType,u=i.shouldBakeAnimation;if(u?Kw._CreateBakedAnimation(w,E,G,l.min,l.max,E.framePerSecond,B,y,x,l,P):"LINEAR"===O||"STEP"===O?Kw._CreateLinearOrStepAnimation(w,E,G,y,x,P):"CUBICSPLINE"===O?Kw._CreateCubicSplineAnimation(w,E,G,y,x,P):Kw._CreateBakedAnimation(w,E,G,l.min,l.max,E.framePerSecond,B,y,x,l,P),y.length&&x.length){return{inputs:y,outputs:x,samplerInterpolation:O,inputsMin:u?l.min:h.Tools.FloatRound(l.min/E.framePerSecond),inputsMax:u?l.max:h.Tools.FloatRound(l.max/E.framePerSecond)}}}return null}static _DeduceAnimationInfo(w){let E=null,G="VEC3",P=!1;const B=w.targetProperty.split(".");switch(B[0]){case"qx":E="scale";break;case"position":E="translation";break;case"rotation":G="VEC4",E="rotation";break;case"rotationQuaternion":G="VEC4",P=!0,E="rotation";break;case"influence":G="SCALAR",E="weights";break;default:h.Tools.Error(`Unsupported animatable property ${B[0]}`)}return E?{animationChannelTargetPath:E,dataAccessorType:G,useQuaternion:P}:(h.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(w,E,G,P,h,B,y,x,U,l,i){let O;if(Kw._IsTransformable(w)&&w.animations)for(const u of w.animations){if(i&&!i(u))continue;const h=Kw._DeduceAnimationInfo(u);h&&(O={name:u.name,samplers:[],channels:[]},Kw._AddAnimation(`${u.name}`,u.hasRunningRuntimeAnimations?E:O,w,u,h.dataAccessorType,h.animationChannelTargetPath,P,B,y,x,h.useQuaternion,U,l),O.samplers.length&&O.channels.length&&G.push(O))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(w,E,G,P,h,B,y,x,U,l,i){let O;if(w instanceof Jw.c){const h=w.morphTargetManager;if(h)for(let u=0;u<h.numTargets;++u){const V=h.getTarget(u);for(const a of V.animations){if(i&&!i(a))continue;const V=new cw.e(`${a.name}`,"influence",a.framePerSecond,a.dataType,a.loopMode,a.enableBlending),Q=[],c=a.getKeys();for(let w=0;w<c.length;++w){const E=c[w];for(let w=0;w<h.numTargets;++w)w==u?Q.push(E):Q.push({frame:E.frame,value:0})}V.setKeys(Q);const Z=Kw._DeduceAnimationInfo(V);Z&&(O={name:V.name,samplers:[],channels:[]},Kw._AddAnimation(a.name,a.hasRunningRuntimeAnimations?E:O,w,V,Z.dataAccessorType,Z.animationChannelTargetPath,P,B,y,x,Z.useQuaternion,U,l,h.numTargets),O.samplers.length&&O.channels.length&&G.push(O))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(w,E,G,P,h,B,y,x,U){let l;if(w.animationGroups){const O=w.animationGroups;for(const u of O){const O=new Map,V=new Map,a=new Set,Q=u.to-u.from;l={name:u.name,channels:[],samplers:[]};for(let E=0;E<u.targetedAnimations.length;++E){const Q=u.targetedAnimations[E],c=Q.target,Z=Q.animation;if(U&&!U(Z))continue;const J=x.has(c);if(this._IsTransformable(c)||1===c.length&&this._IsTransformable(c[0])){const w=Kw._DeduceAnimationInfo(Q.animation);if(w){const E=this._IsTransformable(c)?c:this._IsTransformable(c[0])?c[0]:null;E&&Kw._AddAnimation(`${Z.name}`,l,E,Z,w.dataAccessorType,w.animationChannelTargetPath,G,P,h,B,w.useQuaternion,y,J)}}else if(c instanceof Zw.b||1===c.length&&c[0]instanceof Zw.b){if(Kw._DeduceAnimationInfo(Q.animation)){const E=c instanceof Zw.b?c:c[0];if(E){const G=w.morphTargetManagers.find((w=>{for(let G=0;G<w.numTargets;++G)if(w.getTarget(G)===E)return!0;return!1}));if(G){const P=w.meshes.find((w=>w.morphTargetManager===G));var i;if(P)O.has(P)||O.set(P,new Map),null===(i=O.get(P))||void 0===i||i.set(E,Z),a.add(P),V.set(P,Z)}}}}}a.forEach((w=>{const E=w.morphTargetManager;let x=null;const U=[],i=V.get(w).getKeys(),a=i.length;for(let G=0;G<a;++G)for(let P=0;P<E.numTargets;++P){const h=E.getTarget(P),B=O.get(w);if(B){const E=B.get(h);E?(x||(x=new cw.e(`${u.name}_${w.name}_MorphWeightAnimation`,"influence",E.framePerSecond,cw.e.ANIMATIONTYPE_FLOAT,E.loopMode,E.enableBlending)),U.push(E.getKeys()[G])):U.push({frame:u.from+Q/a*G,value:h.influence,inTangent:i[0].inTangent?0:void 0,outTangent:i[0].outTangent?0:void 0})}}x.setKeys(U);const c=Kw._DeduceAnimationInfo(x);c&&Kw._AddAnimation(`${u.name}_${w.name}_MorphWeightAnimation`,l,w,x,c.dataAccessorType,c.animationChannelTargetPath,G,P,h,B,c.useQuaternion,y,!1,null===E||void 0===E?void 0:E.numTargets)})),l.channels.length&&l.samplers.length&&E.push(l)}}}static _AddAnimation(w,E,G,h,B,y,x,U,l,i,O,u,V,a){const Q=Kw._CreateNodeAnimation(G,h,y,O,u);let c,Z,J,d,K,t;if(Q){if(a){let w=0,E=0;const G=[];for(;Q.inputs.length>0;)E=Q.inputs.shift(),w%a==0&&G.push(E),w++;Q.inputs=G}const w=x.get(G),h=new Float32Array(Q.inputs);c=U.createBufferView(h),Z=U.createAccessor(c,"SCALAR",5126,Q.inputs.length,void 0,{min:[Q.inputsMin],max:[Q.inputsMax]}),i.push(Z),J=i.length-1;const l=new P.Quaternion,O=new P.QE,u=new P.QE,q=G instanceof uw.c,W=n(B),T=new Float32Array(Q.outputs.length*W);Q.outputs.forEach((function(w,E){let G=w;switch(y){case"translation":V&&(P.QE.FromArrayToRef(w,0,u),X(u),u.toArray(G));break;case"rotation":4===w.length?P.Quaternion.FromArrayToRef(w,0,l):(G=new Array(4),P.QE.FromArrayToRef(w,0,O),P.Quaternion.FromEulerVectorToRef(O,l)),V&&(b(l),q&&A(l)),l.toArray(G)}T.set(G,E*W)})),c=U.createBufferView(T),Z=U.createAccessor(c,B,5126,Q.outputs.length),i.push(Z),d=i.length-1,K={interpolation:Q.samplerInterpolation,input:J,output:d},E.samplers.push(K),t={sampler:E.samplers.length-1,target:{node:w,path:y}},E.channels.push(t)}}static _CreateBakedAnimation(w,E,G,B,y,x,U,l,i,O,u){let V;const a=P.Quaternion.Identity();let Q,c=null,Z=null,J=null,d=null,K=null,t=null;O.min=h.Tools.FloatRound(B/x);const q=E.getKeys();for(let P=0,W=q.length;P<W;++P){if(t=null,J=q[P],P+1<W)if(d=q[P+1],J.value.equals&&J.value.equals(d.value)||J.value===d.value){if(0!==P)continue;t=J.frame}else t=d.frame;else{if(K=q[P-1],J.value.equals&&J.value.equals(K.value)||J.value===K.value)continue;t=y}if(t)for(let P=J.frame;P<=t;P+=U){if(Q=h.Tools.FloatRound(P/x),Q===c)continue;c=Q,Z=Q;const B={key:0,repeatCount:0,loopMode:E.loopMode};V=E._interpolate(P,B),Kw._SetInterpolatedValue(w,V,Q,E,G,a,l,i,u)}}Z&&(O.max=Z)}static _ConvertFactorToVector3OrQuaternion(w,E,G,B,y){const x=Kw._GetBasePositionRotationOrScale(E,B,y),U=G.targetProperty.split("."),l=U?U[1]:"",i=y?P.Quaternion.KE(x).normalize():P.QE.KE(x);switch(l){case"x":case"y":case"z":i[l]=w;break;case"w":i.w=w;break;default:h.Tools.Error(`glTFAnimation: Unsupported component name "${l}"!`)}return i}static _SetInterpolatedValue(w,E,G,h,B,y,x,U,l){let i;x.push(G),"weights"!==B?(h.dataType===cw.e.ANIMATIONTYPE_FLOAT&&(E=this._ConvertFactorToVector3OrQuaternion(E,w,h,B,l)),"rotation"===B?(l?y=E:(i=E,P.Quaternion.RotationYawPitchRollToRef(i.y,i.x,i.z,y)),U.push(y.Lh())):(i=E,U.push(i.Lh()))):U.push([E])}static _CreateLinearOrStepAnimation(w,E,G,P,h,B){for(const y of E.getKeys())P.push(y.frame/E.framePerSecond),Kw._AddKeyframeValue(y,E,h,G,w,B)}static _CreateCubicSplineAnimation(w,E,G,P,h,B){E.getKeys().forEach((function(y){P.push(y.frame/E.framePerSecond),Kw._AddSplineTangent(Ow.INTANGENT,h,G,"CUBICSPLINE",y,B),Kw._AddKeyframeValue(y,E,h,G,w,B),Kw._AddSplineTangent(Ow.OUTTANGENT,h,G,"CUBICSPLINE",y,B)}))}static _GetBasePositionRotationOrScale(w,E,G){let h;if("rotation"===E)if(G){h=(w.rotationQuaternion??P.Quaternion.Identity()).Lh()}else{h=(w.rotation??P.QE.Zero()).Lh()}else if("translation"===E){h=(w.position??P.QE.Zero()).Lh()}else{h=(w.qx??P.QE.One()).Lh()}return h}static _AddKeyframeValue(w,E,G,B,y,x){let U;const l=E.dataType;if(l===cw.e.ANIMATIONTYPE_VECTOR3){let E=w.value.Lh();if("rotation"===B){const w=P.QE.KE(E);E=P.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).Lh()}G.push(E)}else if(l===cw.e.ANIMATIONTYPE_FLOAT){if("weights"===B)G.push([w.value]);else if(U=this._ConvertFactorToVector3OrQuaternion(w.value,y,E,B,x),U){if("rotation"===B){const w=x?U:P.Quaternion.RotationYawPitchRoll(U.y,U.x,U.z).normalize();G.push(w.Lh())}G.push(U.Lh())}}else l===cw.e.ANIMATIONTYPE_QUATERNION?G.push(w.value.normalize().Lh()):h.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(w,E,G){let P,h,B=!1;if("rotation"===E&&!G)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let y=0,x=w.length;y<x;++y)if(h=w[y],h.inTangent||h.outTangent)if(P){if("CUBICSPLINE"!==P){P="LINEAR",B=!0;break}}else P="CUBICSPLINE";else if(P){if("CUBICSPLINE"===P||h.interpolation&&1===h.interpolation&&"STEP"!==P){P="LINEAR",B=!0;break}}else P=h.interpolation&&1===h.interpolation?"STEP":"LINEAR";return P||(P="LINEAR"),{interpolationType:P,shouldBakeAnimation:B}}static _AddSplineTangent(w,E,G,h,B,y){let x;const U=w===Ow.INTANGENT?B.inTangent:B.outTangent;if("CUBICSPLINE"===h){if("rotation"===G)if(U)if(y)x=U.Lh();else{const w=U;x=P.Quaternion.RotationYawPitchRoll(w.y,w.x,w.z).Lh()}else x=[0,0,0,0];else x="weights"===G?U?[U]:[0]:U?U.Lh():[0,0,0];E.push(x)}}static _CalculateMinMaxKeyFrames(w){let E=1/0,G=-1/0;return w.forEach((function(w){E=Math.min(E,w.frame),G=Math.max(G,w.frame)})),{min:E,max:G}}}function tw(w,E,G,B,y,x){const U={attributes:{},influence:w.influence,name:w.name},l=E.py;if(!l)return h.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),U;const O=x?-1:1,u=P.QE.Zero();let V=0,a=0;if(w.hasPositions){const B=w.getPositions(),x=l.getVerticesData(i.g.PositionKind);if(x){const w=new Float32Array(x.length),E=[1/0,1/0,1/0],h=[-1/0,-1/0,-1/0];a=x.length/3,V=0;for(let G=V;G<a;++G){const y=P.QE.KE(x,3*G);P.QE.KE(B,3*G).subtractToRef(y,u),u.x*=O,E[0]=Math.min(E[0],u.x),h[0]=Math.max(h[0],u.x),E[1]=Math.min(E[1],u.y),h[1]=Math.max(h[1],u.y),E[2]=Math.min(E[2],u.z),h[2]=Math.max(h[2],u.z),w[3*G]=u.x,w[3*G+1]=u.y,w[3*G+2]=u.z}const l=G.createBufferView(w,12),i=G.createAccessor(l,"VEC3",5126,B.length/3,0,{min:E,max:h});y.push(i),U.attributes.POSITION=y.length-1}else h.Tools.Warn(`Morph target positions for mesh ${E.name} were not exported. Mesh does not have position vertex data`)}if(w.hasNormals){const B=w.getNormals(),x=l.getVerticesData(i.g.NormalKind);if(x){const w=new Float32Array(x.length);a=x.length/3,V=0;for(let G=V;G<a;++G){const E=P.QE.KE(x,3*G).normalize();P.QE.KE(B,3*G).normalize().subtractToRef(E,u),w[3*G]=u.x*O,w[3*G+1]=u.y,w[3*G+2]=u.z}const E=G.createBufferView(w,12),h=G.createAccessor(E,"VEC3",5126,B.length/3,0);y.push(h),U.attributes.NORMAL=y.length-1}else h.Tools.Warn(`Morph target normals for mesh ${E.name} were not exported. Mesh does not have normals vertex data`)}if(w.hasTangents){const B=w.getTangents(),x=l.getVerticesData(i.g.TangentKind);if(x){a=x.length/4;const w=new Float32Array(3*a);V=0;for(let G=V;G<a;++G){const E=P.QE.KE(x,4*G);S(E);const h=P.QE.KE(B,3*G);S(h),h.subtractToRef(E,u),w[3*G]=u.x*O,w[3*G+1]=u.y,w[3*G+2]=u.z}const E=G.createBufferView(w,12),h=G.createAccessor(E,"VEC3",5126,a,0);y.push(h),U.attributes.TANGENT=y.length-1}else h.Tools.Warn(`Morph target tangents for mesh ${E.name} were not exported. Mesh does not have tangents vertex data`)}if(w.hasColors){const B=w.getColors(),x=l.getVerticesData(i.g.ColorKind),O=l.getVertexBuffer(i.g.ColorKind);if(x&&O){const w=O.getSize();a=x.length/w;const E=new Float32Array(a*w);V=0;for(let G=V;G<a;++G)if(3===w){const h=P.QE.KE(x,G*w);P.QE.KE(B,G*w).subtractToRef(h,u),E[3*G]=u.x,E[3*G+1]=u.y,E[3*G+2]=u.z}else if(4===w){const h=new P.Vector4,y=P.Vector4.KE(x,G*w);P.Vector4.KE(B,G*w).subtractToRef(y,h),E[4*G]=h.x,E[4*G+1]=h.y,E[4*G+2]=h.z,E[4*G+3]=h.w}else h.Tools.Warn(`Unsupported number of components for color attribute: ${w}`);const l=G.createBufferView(E,4*w),i=G.createAccessor(l,3===w?"VEC3":"VEC4",5126,a,0);y.push(i),U.attributes.COLOR_0=y.length-1}else h.Tools.Warn(`Morph target colors for mesh ${E.name} were not exported. Mesh does not have colors vertex data`)}return U}var qw=G(12197),Ww=G(12062),Tw=G(12044),Iw=G(11646);class jw{}jw.DEFAULT_COLOR=c.dE.White(),jw.DEFAULT_WIDTH_ATTENUATED=1,jw.DEFAULT_WIDTH=.1;var gw=G(11874),ow=G(12205);class fw{static ConvertPoints(w,E){if(w.length&&Array.isArray(w)&&"number"===typeof w[0])return[w];if(w.length&&Array.isArray(w[0])&&"number"===typeof w[0][0])return w;if(w.length&&!Array.isArray(w[0])&&w[0]instanceof P.QE){const E=[];for(let G=0;G<w.length;G++){const P=w[G];E.push(P.x,P.y,P.z)}return[E]}if(w.length>0&&Array.isArray(w[0])&&w[0].length>0&&w[0][0]instanceof P.QE){const E=[],G=w;for(const w of G)E.push(w.flatMap((w=>[w.x,w.y,w.z])));return E}if(w instanceof Float32Array){if(null!==E&&void 0!==E&&E.floatArrayStride){const G=[],P=3*E.floatArrayStride;for(let E=0;E<w.length;E+=P){const h=new Array(P);for(let G=0;G<P;G++)h[G]=w[E+G];G.push(h)}return G}return[Array.from(w)]}if(w.length&&w[0]instanceof Float32Array){const E=[];for(const G of w)E.push(Array.from(G));return E}return[]}static OmitZeroLengthPredicate(w,E,G){const P=[];return E.cE(w).lengthSquared()>0&&P.push([w,E]),G.cE(E).lengthSquared()>0&&P.push([E,G]),w.cE(G).lengthSquared()>0&&P.push([G,w]),0===P.length?null:P}static OmitDuplicatesPredicate(w,E,G,P){const h=[];return fw._SearchInPoints(w,E,P)||h.push([w,E]),fw._SearchInPoints(E,G,P)||h.push([E,G]),fw._SearchInPoints(G,w,P)||h.push([G,w]),0===h.length?null:h}static _SearchInPoints(w,E,G){for(const y of G)for(let G=0;G<y.length;G++){var P,h,B;if(null!==(P=y[G])&&void 0!==P&&P.equals(w))if(null!==(h=y[G+1])&&void 0!==h&&h.equals(E)||null!==(B=y[G-1])&&void 0!==B&&B.equals(E))return!0}return!1}static MeshesToLines(w,E){const G=[];for(let h=0;h<w.length;h++){const B=w[h],y=B.getVerticesData(i.g.PositionKind),x=B.ny();if(y&&x)for(let w=0,U=0;w<x.length;w++){const l=3*x[U++],i=3*x[U++],O=3*x[U++],u=new P.QE(y[l],y[l+1],y[l+2]),V=new P.QE(y[i],y[i+1],y[i+2]),a=new P.QE(y[O],y[O+1],y[O+2]);if(E){const P=E(u,V,a,G,w,l,B,h,y,x);if(P)for(const w of P)G.push(w)}else G.push([u,V],[V,a],[a,u])}}return G}static ToVector3Array(w){if(Array.isArray(w[0])){const E=[],G=w;for(const w of G){const G=[];for(let E=0;E<w.length;E+=3)G.push(new P.QE(w[E],w[E+1],w[E+2]));E.push(G)}return E}const E=w,G=[];for(let h=0;h<E.length;h+=3)G.push(new P.QE(E[h],E[h+1],E[h+2]));return G}static ToNumberArray(w){return w.flatMap((w=>[w.x,w.y,w.z]))}static GetPointsCountInfo(w){const E=new Array(w.length);let G=0;for(let P=w.length;P--;)E[P]=w[P].length/3,G+=E[P];return{total:G,counts:E}}static GetLineLength(w){if(0===w.length)return 0;let E;E="number"===typeof w[0]?fw.ToVector3Array(w):w;const G=P.TmpVectors.QE[0];let h=0;for(let P=0;P<E.length-1;P++){const w=E[P];h+=E[P+1].subtractToRef(w,G).length()}return h}static GetLineLengthArray(w){const E=new Float32Array(w.length/3);let G=0;for(let P=0,h=w.length/3-1;P<h;P++){let h=w[3*P+0],B=w[3*P+1],y=w[3*P+2];h-=w[3*P+3],B-=w[3*P+4],y-=w[3*P+5];G+=Math.sqrt(h*h+B*B+y*y),E[P+1]=G}return E}static SegmentizeSegmentByCount(w,E,G){const h=[],B=E.cE(w),y=P.TmpVectors.QE[0];y.Wx(G);const x=P.TmpVectors.QE[1];B.divideToRef(y,x);let U=w.clone();h.push(U);for(let P=0;P<G;P++)U=U.clone(),h.push(U.addInPlace(x));return h}static SegmentizeLineBySegmentLength(w,E){const G=w[0]instanceof P.QE?fw.GetLineSegments(w):"number"===typeof w[0]?fw.GetLineSegments(fw.ToVector3Array(w)):w,h=[];for(const P of G)if(P.length>E){const w=fw.SegmentizeSegmentByCount(P.point1,P.point2,Math.ceil(P.length/E));for(const E of w)h.push(E)}else h.push(P.point1),h.push(P.point2);return h}static SegmentizeLineBySegmentCount(w,E){const G="number"===typeof w[0]?fw.ToVector3Array(w):w,P=fw.GetLineLength(G)/E;return fw.SegmentizeLineBySegmentLength(G,P)}static GetLineSegments(w){const E=[];for(let G=0;G<w.length-1;G++){const P=w[G],h=w[G+1],B=h.cE(P).length();E.push({point1:P,point2:h,length:B})}return E}static GetMinMaxSegmentLength(w){const E=fw.GetLineSegments(w).sort((w=>w.length));return{min:E[0].length,max:E[E.length-1].length}}static GetPositionOnLineByVisibility(w,E,G){let h=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const B=E*G;let y=0,x=0;const U=w.length;for(let P=0;P<U;P++){if(B<=y+w[P].length){x=P;break}y+=w[P].length}const l=(B-y)/w[x].length;return w[x].point2.subtractToRef(w[x].point1,P.TmpVectors.QE[0]),P.TmpVectors.QE[1]=P.TmpVectors.QE[0].multiplyByFloats(l,l,l),h||P.TmpVectors.QE[1].addInPlace(w[x].point1),P.TmpVectors.QE[1].clone()}static GetCircleLinePoints(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,h=arguments.length>3&&void 0!==arguments[3]?arguments[3]:w,B=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/E;const y=[];for(let x=0;x<=E;x++)y.push(new P.QE(Math.cos(x*B)*w,Math.sin(x*B)*h,G));return y}static GetBezierLinePoints(w,E,G,P){return gw.i.CreateQuadraticBezier(w,E,G,P).getPoints().flatMap((w=>[w.x,w.y,w.z]))}static GetArrowCap(w,E,G,P,h){let B=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[w.clone(),w.add(E.multiplyByFloats(G,G,G))],widths:[P,h,B,y]}}static GetPointsFromText(w,E,G,P){let h=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,B=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const y=[],x=(0,ow.b)(w,E,G,P);for(const U of x){for(const w of U.paths){const E=[],G=w.getPoints();for(const w of G)E.push(w.x,w.y,h);y.push(E)}if(B)for(const w of U.holes){const E=[],G=w.getPoints();for(const w of G)E.push(w.x,w.y,h);y.push(E)}}return y}static Color3toRGBAUint8(w){const E=new Uint8Array(4*w.length);for(let G=0,P=0;G<w.length;G++)E[P++]=255*w[G].r,E[P++]=255*w[G].g,E[P++]=255*w[G].b,E[P++]=255;return E}static CreateColorsTexture(w,E,G,P){const h=P.getEngine().getCaps().maxTextureSize??1,B=E.length>h?h:E.length,y=Math.ceil(E.length/h);y>1&&(E=[...E,...Array(B*y-E.length).fill(E[0])]);const x=fw.Color3toRGBAUint8(E),U=new q.e(x,B,y,a.b.TEXTUREFORMAT_RGBA,P,!1,!0,G);return U.name=w,U}static PrepareEmptyColorsTexture(w){if(!jw.EmptyColorsTexture){const E=new Uint8Array(4);jw.EmptyColorsTexture=new q.e(E,1,1,a.b.TEXTUREFORMAT_RGBA,w,!1,!1,q.e.NEAREST_NEAREST),jw.EmptyColorsTexture.name="grlEmptyColorsTexture"}return jw.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var w;null===(w=jw.EmptyColorsTexture)||void 0===w||w.dispose(),jw.EmptyColorsTexture=null}static BooleanToNumber(w){return w?1:0}}class kw extends Tw.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class Nw extends Ww.c{isCompatible(w){return!0}constructor(w,E,G){var h;G=G||{color:jw.DEFAULT_COLOR};const B=new kw;B.GREASED_LINE_HAS_COLOR=!!G.color&&!G.useColors,B.GREASED_LINE_SIZE_ATTENUATION=G.sizeAttenuation??!1,B.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===G.colorDistributionType,B.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(E??w.Ww()).useRightHandedSystem,B.GREASED_LINE_CAMERA_FACING=G.cameraFacing??!0,super(w,Nw.GREASED_LINE_MATERIAL_NAME,200,B,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(h=G)||void 0===h?void 0:h.forceGLSL)||Nw.ForceGLSL,this._scene=E??w.Ww(),this._engine=this._scene.getEngine(),this._cameraFacing=G.cameraFacing??!0,this.visibility=G.visibility??1,this.useDash=G.useDash??!1,this.dashRatio=G.dashRatio??.5,this.dashOffset=G.dashOffset??0,this.width=G.width?G.width:G.sizeAttenuation?jw.DEFAULT_WIDTH_ATTENUATED:jw.DEFAULT_WIDTH,this._sizeAttenuation=G.sizeAttenuation??!1,this.colorMode=G.colorMode??0,this._color=G.color??null,this.useColors=G.useColors??!1,this._colorsDistributionType=G.colorDistributionType??0,this.colorsSampling=G.colorsSampling??q.e.NEAREST_NEAREST,this._colors=G.gw??null,this.dashCount=G.dashCount??1,this.resolution=G.resolution??new P.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),G.colorsTexture?this.colorsTexture=G.colorsTexture:this._colors?this.colorsTexture=fw.CreateColorsTexture(`${w.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??jw.DEFAULT_COLOR,fw.PrepareEmptyColorsTexture(this._scene)),this._engine.qh.add((()=>{fw.DisposeEmptyColorsTexture()}))}getAttributes(w){w.push("grl_offsets"),w.push("grl_widths"),w.push("grl_colorPointers"),w.push("grl_counters"),this._cameraFacing?(w.push("grl_previousAndSide"),w.push("grl_nextAndCounters")):w.push("grl_slopes")}getSamplers(w){w.push("grl_colors")}getActiveTextures(w){this.colorsTexture&&w.push(this.colorsTexture)}getUniforms(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const E=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&E.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===w&&E.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:E,vertex:this._cameraFacing&&this._isGLSL(w)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(w)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(w){if(this._cameraFacing){w.bh("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||w.bh("viewProjection",this._scene.getTransformMatrix());const E=P.TmpVectors.Vector4[0];E.x=this._aspect,E.y=this._resolution.x,E.z=this._resolution.y,E.w=this.width,w.updateVector4("grl_aspect_resolution_lineWidth",E)}const E=P.TmpVectors.Vector4[0];E.x=fw.BooleanToNumber(this.useDash),E.y=this._dashArray,E.z=this.dashOffset,E.w=this.dashRatio,w.updateVector4("grl_dashOptions",E);const G=P.TmpVectors.Vector4[1];G.x=this.colorMode,G.y=this.visibility,G.z=this.colorsTexture?this.colorsTexture.getSize().width:0,G.w=fw.BooleanToNumber(this.useColors),w.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",G),this._color&&w.updateColor3("grl_singleColor",this._color);const h=this.colorsTexture??jw.EmptyColorsTexture;w.setTexture("grl_colors",h),w.updateFloat2("grl_textureSize",(null===h||void 0===h?void 0:h.getSize().width)??1,(null===h||void 0===h?void 0:h.getSize().height)??1)}prepareDefines(w,E,G){w.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,w.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,w.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,w.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=E.useRightHandedSystem,w.GREASED_LINE_CAMERA_FACING=this._cameraFacing,w.GREASED_LINE_USE_OFFSETS=!!G.offsets}getClassName(){return Nw.GREASED_LINE_MATERIAL_NAME}getCustomCode(w){let E=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(E)?function(w,E){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return E&&(w["!gl_Position\\=viewProjection\\*worldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(w,this._cameraFacing):function(w,E){if("vertex"===w){const w={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return E&&(w["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),w}return"fragment"===w?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(w,this._cameraFacing)}dispose(){var w;null===(w=this.colorsTexture)||void 0===w||w.dispose(),super.dispose()}get gw(){return this._colors}set gw(w){this.setColors(w)}setColors(w){var E;let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var B;if(this._colors=w,null!==w&&0!==w.length){if(!G||P)if(this.colorsTexture&&h===w.length&&!P){const E=fw.Color3toRGBAUint8(w);this.colorsTexture.update(E)}else{var y;null===(y=this.colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=fw.CreateColorsTexture(`${this._material.name}-colors-texture`,w,this.colorsSampling,this._scene)}}else null===(B=this.colorsTexture)||void 0===B||B.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.markAllDefinesAsDirty()}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==w||null!==this._color&&null===w?(this._color=w,E||this.markAllDefinesAsDirty()):this._color=w}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(w){this._aspect=w.x/w.y,this._resolution=w}serialize(){const w=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(E.gw=this._colors),this._color&&(E.color=this._color),w.greasedLineMaterialOptions=E,w}parse(w,E,G){var P;super.parse(w,E,G);const h=w.greasedLineMaterialOptions;null===(P=this.colorsTexture)||void 0===P||P.dispose(),h.color&&this.setColor(h.color,!0),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.gw&&(this.gw=h.gw),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),this.gw?this.colorsTexture=fw.CreateColorsTexture(`${this._material.name}-colors-texture`,this.gw,this.colorsSampling,E):fw.PrepareEmptyColorsTexture(E),this.markAllDefinesAsDirty()}copyTo(w){var E;const G=w;null===(E=G.colorsTexture)||void 0===E||E.dispose(),this._colors&&(G.colorsTexture=fw.CreateColorsTexture(`${G._material.name}-colors-texture`,this._colors,G.colorsSampling,this._scene)),G.setColor(this.color,!0),G.colorsDistributionType=this.colorsDistributionType,G.colorsSampling=this.colorsSampling,G.colorMode=this.colorMode,G.useColors=this.useColors,G.visibility=this.visibility,G.useDash=this.useDash,G.dashCount=this.dashCount,G.dashRatio=this.dashRatio,G.dashOffset=this.dashOffset,G.width=this.width,G.sizeAttenuation=this.sizeAttenuation,G.resolution=this.resolution,G.markAllDefinesAsDirty()}_isGLSL(w){return 0===w||this._forceGLSL}}Nw.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",Nw.ForceGLSL=!1,(0,Iw.g)(`BABYLON.${Nw.GREASED_LINE_MATERIAL_NAME}`,Nw);var vw=G(12089),Cw=G(11526),sw=G(11899),Fw=G(11630);class Mw extends sw.ShaderMaterial{constructor(w,E,h){const B=E.getEngine(),y=B.isWebGPU&&!(h.forceGLSL||Mw.ForceGLSL),x=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];E.useRightHandedSystem&&x.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const U=["position","grl_widths","grl_offsets","grl_colorPointers"];h.cameraFacing?(x.push("GREASED_LINE_CAMERA_FACING"),U.push("grl_previousAndSide","grl_nextAndCounters")):(U.push("grl_slopes"),U.push("grl_counters"));const l=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(y||l.push("world","viewProjection","view","projection"),super(w,E,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:y?["Scene","Mesh"]:void 0,attributes:U,uniforms:l,samplers:y?[]:["grlColors"],defines:x,extraInitializationsAsync:async()=>{y?await Promise.all([G.e(66).then(G.bind(G,14671)),G.e(75).then(G.bind(G,14677))]):await Promise.all([G.e(69).then(G.bind(G,14683)),G.e(76).then(G.bind(G,14690))])},shaderLanguage:y?1:0}),this._color=c.dE.White(),this._colorsDistributionType=0,this._colorsTexture=null,h=h||{color:jw.DEFAULT_COLOR},this.visibility=h.visibility??1,this.useDash=h.useDash??!1,this.dashRatio=h.dashRatio??.5,this.dashOffset=h.dashOffset??0,this.dashCount=h.dashCount??1,this.width=h.width?h.width:h.sizeAttenuation&&h.cameraFacing?jw.DEFAULT_WIDTH_ATTENUATED:jw.DEFAULT_WIDTH,this.sizeAttenuation=h.sizeAttenuation??!1,this.color=h.color??c.dE.White(),this.useColors=h.useColors??!1,this.colorsDistributionType=h.colorDistributionType??0,this.colorsSampling=h.colorsSampling??q.e.NEAREST_NEAREST,this.colorMode=h.colorMode??0,this._colors=h.gw??null,this._cameraFacing=h.cameraFacing??!0,this.resolution=h.resolution??new P.Vector2(B.getRenderWidth(),B.getRenderHeight()),h.colorsTexture?this.colorsTexture=h.colorsTexture:this._colors?this.colorsTexture=fw.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,E):(this._color=this._color??jw.DEFAULT_COLOR,this.colorsTexture=fw.PrepareEmptyColorsTexture(E)),y){const w=new Fw.c;w.setParameters(),w.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",w)}B.qh.add((()=>{fw.DisposeEmptyColorsTexture()}))}dispose(){var w;null===(w=this._colorsTexture)||void 0===w||w.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new P.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get gw(){return this._colors}set gw(w){this.setColors(w)}setColors(w){var E;let G=arguments.length>1&&void 0!==arguments[1]&&arguments[1],P=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const h=(null===(E=this._colors)||void 0===E?void 0:E.length)??0;var B;if(this._colors=w,null!==w&&0!==w.length){if(!G||P)if(this._colorsTexture&&h===w.length&&!P){const E=fw.Color3toRGBAUint8(w);this._colorsTexture.update(E)}else{var y;null===(y=this._colorsTexture)||void 0===y||y.dispose(),this.colorsTexture=fw.CreateColorsTexture(`${this.name}-colors-texture`,w,this.colorsSampling,this.Ww())}}else null===(B=this._colorsTexture)||void 0===B||B.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(w){this._colorsTexture=w,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(w){this._width=w,this.setFloat("grlWidth",w)}get useColors(){return this._useColors}set useColors(w){this._useColors=w,this.setFloat("grlUseColors",fw.BooleanToNumber(w))}get colorsSampling(){return this._colorsSampling}set colorsSampling(w){this._colorsSampling=w}get visibility(){return this._visibility}set visibility(w){this._visibility=w,this.setFloat("grlVisibility",w)}get useDash(){return this._useDash}set useDash(w){this._useDash=w,this.setFloat("grlUseDash",fw.BooleanToNumber(w))}get dashOffset(){return this._dashOffset}set dashOffset(w){this._dashOffset=w,this.setFloat("grlDashOffset",w)}get dashRatio(){return this._dashRatio}set dashRatio(w){this._dashRatio=w,this.setFloat("grlDashRatio",w)}get dashCount(){return this._dashCount}set dashCount(w){this._dashCount=w,this._dashArray=1/w,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(w){this._sizeAttenuation=w,this.setFloat("grlSizeAttenuation",fw.BooleanToNumber(w))}get color(){return this._color}set color(w){this.setColor(w)}setColor(w){w=w??jw.DEFAULT_COLOR,this._color=w,this.setColor3("grlColor",w)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(w){this._colorsDistributionType=w,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(w){this._colorMode=w,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(w){this._resolution=w,this.setVector2("grlResolution",w),this.setFloat("grlAspect",w.x/w.y)}serialize(){const w=super.serialize(),E={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(E.gw=this._colors),w.greasedLineMaterialOptions=E,w}parse(w,E,G){var P;const h=w.greasedLineMaterialOptions;null===(P=this._colorsTexture)||void 0===P||P.dispose(),h.color&&(this.color=h.color),h.colorDistributionType&&(this.colorsDistributionType=h.colorDistributionType),h.colorsSampling&&(this.colorsSampling=h.colorsSampling),h.colorMode&&(this.colorMode=h.colorMode),h.useColors&&(this.useColors=h.useColors),h.visibility&&(this.visibility=h.visibility),h.useDash&&(this.useDash=h.useDash),h.dashCount&&(this.dashCount=h.dashCount),h.dashRatio&&(this.dashRatio=h.dashRatio),h.dashOffset&&(this.dashOffset=h.dashOffset),h.width&&(this.width=h.width),h.sizeAttenuation&&(this.sizeAttenuation=h.sizeAttenuation),h.resolution&&(this.resolution=h.resolution),h.gw?this.colorsTexture=fw.CreateColorsTexture(`${this.name}-colors-texture`,h.gw,this.colorsSampling,this.Ww()):this.colorsTexture=fw.PrepareEmptyColorsTexture(E),this._cameraFacing=h.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var pw,Dw,ew;Mw.ForceGLSL=!1,function(w){w[w.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",w[w.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(pw||(pw={})),function(w){w[w.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",w[w.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",w[w.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(Dw||(Dw={})),function(w){w[w.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",w[w.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",w[w.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",w[w.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",w[w.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(ew||(ew={}));class Rw extends Jw.c{constructor(w,E,G){super(w,E,null,null,!1,!1),this.name=w,this._options=G,this._lazy=!1,this._updatable=!1,this._engine=E.getEngine(),this._lazy=G.lazy??!1,this._updatable=G.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=G.colorPointers??[],this._widths=G.widths??new Array(G.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(w){let E=0;for(const P of this._points)E+=P.length;const G=E/3*2-this._widths.length;for(let P=0;P<G;P++)this._widths.push(w)}updateLazy(){var w,E;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(w=this._options.ribbonOptions)||void 0===w?void 0:w.smoothShading),!this.Nw&&this.refreshBoundingInfo(),null===(E=this.greasedLineMaterial)||void 0===E||E.updateLazy()}addPoints(w,E){for(const G of w)this._points.push(G);this._lazy||this.setPoints(this._points,E)}dispose(w){let E=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(w,E)}isLazy(){return this._lazy}get ow(){return this._uvs}set ow(w){this._uvs=w instanceof Float32Array?w:new Float32Array(w),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(w){this.material instanceof Mw&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===w||void 0===w?void 0:w.length)>0),this._offsets=w,this._offsetsBuffer?this._offsetsBuffer.update(w):this._createOffsetsBuffer(w)}get widths(){return this._widths}set widths(w){this._widths=w,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(w)}get colorPointers(){return this._colorPointers}set colorPointers(w){this._colorPointers=w,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(w)}get greasedLineMaterial(){var w,E;if(this.material&&this.material instanceof Mw)return this.material;const G=null===(w=this.material)||void 0===w||null===(E=w.pluginManager)||void 0===E?void 0:E.getPlugin(Nw.GREASED_LINE_MATERIAL_NAME);return G||void 0}get points(){const w=[];return Cw.d.DeepCopy(this._points,w),w}setPoints(w,E){this._points=fw.ConvertPoints(w,(null===E||void 0===E?void 0:E.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==E&&void 0!==E&&E.colorPointers||this._updateColorPointers(),this._setPoints(this._points,E)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,ow:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(w){super.serialize(w),w.type=this.getClassName(),w.lineOptions=this._createLineOptions()}_createVertexBuffers(){let w=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const E=new vw.d;return E.Iw=this._vertexPositions,E.indices=this._indices,E.ow=this._uvs,w&&(E.jw=[],vw.d.ComputeNormals(this._vertexPositions,this._indices,E.jw)),E.kw(this,this._options.updatable),E}_createOffsetsBuffer(w){const E=this._scene.getEngine(),G=new i.d(E,w,this._updatable,3);this.setVerticesBuffer(G.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=G}}class Hw{constructor(w,E){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=w,this.wasAddedByNoopNode=E}getIndicesAccessor(w,E,G,P,h){var B,y,x,U;return null===(B=this._indicesAccessorMap.get(w))||void 0===B||null===(y=B.get(E))||void 0===y||null===(x=y.get(G))||void 0===x||null===(U=x.get(P))||void 0===U?void 0:U.get(h)}setIndicesAccessor(w,E,G,P,h,B){let y=this._indicesAccessorMap.get(w);y||(y=new Map,this._indicesAccessorMap.set(w,y));let x=y.get(E);x||(x=new Map,y.set(E,x));let U=x.get(G);U||(U=new Map,x.set(G,U));let l=U.get(P);l||(l=new Map,U.set(P,l)),l.set(h,B)}pushExportedNode(w){this._exportedNodes.has(w)||this._exportedNodes.add(w)}getNodesSet(){return this._exportedNodes}getVertexBufferView(w){return this._vertexBufferViewMap.get(w)}setVertexBufferView(w,E){this._vertexBufferViewMap.set(w,E)}setRemappedBufferView(w,E,G){this._remappedBufferView.set(w,new Map),this._remappedBufferView.get(w).set(E,G)}getRemappedBufferView(w,E){var G;return null===(G=this._remappedBufferView.get(w))||void 0===G?void 0:G.get(E)}getVertexAccessor(w,E,G){var P,h;return null===(P=this._vertexAccessorMap.get(w))||void 0===P||null===(h=P.get(E))||void 0===h?void 0:h.get(G)}setVertexAccessor(w,E,G,P){let h=this._vertexAccessorMap.get(w);h||(h=new Map,this._vertexAccessorMap.set(w,h));let B=h.get(E);B||(B=new Map,h.set(E,B)),B.set(G,P)}hasVertexColorAlpha(w){return this._vertexMapColorAlpha.get(w)||!1}setHasVertexColorAlpha(w,E){return this._vertexMapColorAlpha.set(w,E)}getMesh(w){return this._meshMap.get(w)}setMesh(w,E){this._meshMap.set(w,E)}bindMorphDataToMesh(w,E){const G=this._meshMorphTargetMap.get(w)||[];this._meshMorphTargetMap.set(w,G),-1===G.indexOf(E)&&G.push(E)}getMorphTargetsFromMesh(w){return this._meshMorphTargetMap.get(w)}}class zw{_ApplyExtension(w,E,G,P){if(G>=E.length)return Promise.resolve(w);const h=P(E[G],w);return h?h.then((async w=>w?await this._ApplyExtension(w,E,G+1,P):null)):this._ApplyExtension(w,E,G+1,P)}_ApplyExtensions(w,E){const G=[];for(const P of zw._ExtensionNames)G.push(this._extensions[P]);return this._ApplyExtension(w,G,0,E)}_extensionsPreExportTextureAsync(w,E,G){return this._ApplyExtensions(E,((E,P)=>E.preExportTextureAsync&&E.preExportTextureAsync(w,P,G)))}_extensionsPostExportNodeAsync(w,E,G,P,h){return this._ApplyExtensions(E,((E,B)=>E.postExportNodeAsync&&E.postExportNodeAsync(w,B,G,P,h,this._bufferManager)))}_extensionsPostExportMaterialAsync(w,E,G){return this._ApplyExtensions(E,((E,P)=>E.postExportMaterialAsync&&E.postExportMaterialAsync(w,P,G)))}_extensionsPostExportMaterialAdditionalTextures(w,E,G){const P=[];for(const h of zw._ExtensionNames){const B=this._extensions[h];B.postExportMaterialAdditionalTextures&&P.push(...B.postExportMaterialAdditionalTextures(w,E,G))}return P}_extensionsPostExportTextures(w,E,G){for(const P of zw._ExtensionNames){const h=this._extensions[P];h.postExportTexture&&h.postExportTexture(w,E,G)}}_extensionsPostExportMeshPrimitive(w){for(const E of zw._ExtensionNames){const G=this._extensions[E];G.postExportMeshPrimitive&&G.postExportMeshPrimitive(w,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const w of zw._ExtensionNames){const E=this._extensions[w];E.preGenerateBinaryAsync&&await E.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(w){for(const E of zw._ExtensionNames){const G=this._extensions[E];G.enabled&&w(G)}}_extensionsOnExporting(){this._forEachExtensions((w=>{var E,G,P;w.wasUsed&&((E=this._glTF).extensionsUsed||(E.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(w.name)&&this._glTF.extensionsUsed.push(w.name),w.required&&((G=this._glTF).extensionsRequired||(G.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(w.name)&&this._glTF.extensionsRequired.push(w.name)),(P=this._glTF).extensions||(P.extensions={}),w.onExporting&&w.onExporting())}))}_loadExtensions(){for(const w of zw._ExtensionNames){const E=zw._ExtensionFactories[w](this);this._extensions[w]=E}}constructor(){let w=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Q.e.LastCreatedScene,E=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${a.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new F(this),this._extensions={},this._bufferManager=new iw,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!w)throw new Error("No scene available to export");this._babylonScene=w,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:w=>{var E;return null===w||void 0===w||null===(E=w.fh)||void 0===E?void 0:E.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...E},this._loadExtensions()}dispose(){for(const w in this._extensions){this._extensions[w].dispose()}}get options(){return this._options}static RegisterExtension(w,E){zw.UnregisterExtension(w)&&h.Tools.Warn(`Extension with the name ${w} already exists`),zw._ExtensionFactories[w]=E,zw._ExtensionNames.push(w)}static UnregisterExtension(w){if(!zw._ExtensionFactories[w])return!1;delete zw._ExtensionFactories[w];const E=zw._ExtensionNames.indexOf(w);return-1!==E&&zw._ExtensionNames.splice(E,1),!0}_generateJSON(w,E,G){const P={byteLength:w};return P.byteLength&&(this._glTF.buffers=[P]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.ZE=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(P.uri=E+".bin"),G?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(w){const E=await this._generateBinaryAsync();this._extensionsOnExporting();const G=this._generateJSON(E.byteLength,w,!0),P=new Blob([E],{type:"application/octet-stream"}),h=w+".gltf",B=w+".bin",y=new l;if(y.files[h]=G,y.files[B]=P,this._imageData)for(const x in this._imageData)y.files[x]=new Blob([this._imageData[x].data],{type:this._imageData[x].mimeType});return y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(w){const E=w%4;return 0===E?E:4-E}async generateGLBAsync(w){this._shouldUseGlb=!0;const E=await this._generateBinaryAsync();this._extensionsOnExporting();const G=this._generateJSON(E.byteLength),P=w+".glb";let h,B=G.length;if("undefined"!==typeof TextEncoder){h=(new TextEncoder).encode(G),B=h.length}const y=this._getPadding(B),x=this._getPadding(E.byteLength),U=28+B+y+E.byteLength+x,i=new Uw(U);if(i.writeUInt32(1179937895),i.writeUInt32(2),i.writeUInt32(U),i.writeUInt32(B+y),i.writeUInt32(1313821514),h)i.writeTypedArray(h);else{const w="_".charCodeAt(0);for(let E=0;E<B;++E){const P=G.charCodeAt(E);P!=G.codePointAt(E)?i.writeUInt8(w):i.writeUInt8(P)}}for(let l=0;l<y;++l)i.writeUInt8(32);i.writeUInt32(E.byteLength+x),i.writeUInt32(5130562),i.writeTypedArray(E);for(let l=0;l<x;++l)i.writeUInt8(0);const O=new l;return O.files[P]=new Blob([i.getOutputData()],{type:"application/octet-stream"}),O}_setNodeTransformation(w,E,G){if(E.getPivotPoint().equalsWithEpsilon(R,e.d)||h.Tools.Warn("Pivot points are not supported in the glTF serializer"),!E.position.equalsWithEpsilon(R,e.d)){const h=P.TmpVectors.QE[0].B(E.position);G&&X(h),w.translation=h.Lh()}E.qx.equalsWithEpsilon(z,e.d)||(w.scale=E.qx.Lh());const B=E.rotationQuaternion||P.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);B.equalsWithEpsilon(H,e.d)||(G&&b(B),w.rotation=B.normalize().Lh())}_setCameraTransformation(w,E,G){if(!E.position.equalsWithEpsilon(R,e.d)){const h=P.TmpVectors.QE[0].B(E.position);G&&X(h),w.translation=h.Lh()}const h=E.rotationQuaternion||P.Quaternion.FromEulerAngles(E.rotation.x,E.rotation.y,E.rotation.z);G&&b(h),this._babylonScene.useRightHandedSystem||A(h),h.equalsWithEpsilon(H,e.d)||(w.rotation=h.Lh())}_listAvailableCameras(){for(const w of this._babylonScene.cameras){const E={type:w.mode===uw.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(w.name&&(E.name=w.name),"perspective"===E.type)E.perspective={aspectRatio:w.getEngine().getAspectRatio(w),yfov:w.fovMode===uw.c.FOVMODE_VERTICAL_FIXED?w.fov:w.fov*w.getEngine().getAspectRatio(w),znear:w.Sh,zfar:w.maxZ};else if("orthographic"===E.type){const G=w.orthoLeft&&w.orthoRight?.5*(w.orthoRight-w.orthoLeft):.5*w.getEngine().getRenderWidth(),P=w.orthoBottom&&w.orthoTop?.5*(w.orthoTop-w.orthoBottom):.5*w.getEngine().getRenderHeight();E.orthographic={xmag:G,ymag:P,znear:w.Sh,zfar:w.maxZ}}this._camerasMap.set(w,E)}}_exportAndAssignCameras(){const w=Array.from(this._camerasMap.values());for(const E of w){const w=this._nodesCameraMap.get(E);if(void 0!==w){this._cameras.push(E);for(const E of w)E.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const E={joints:[]};this._skinMap.set(w,E)}}_exportAndAssignSkeletons(){for(const w of this._babylonScene.skeletons){if(w.bones.length<=0)continue;const E=this._skinMap.get(w);if(void 0==E)continue;const G={},P=[];let B=-1;for(let h=0;h<w.bones.length;++h){const E=w.bones[h],P=E.getIndex()??h;-1!==P&&(G[P]=E,P>B&&(B=P))}for(let w=0;w<=B;++w){const B=G[w];P.push(B.getAbsoluteInverseBindMatrix());const y=B.getTransformNode();if(null!==y){const w=this._nodeMap.get(y);y&&null!==w&&void 0!==w?E.joints.push(w):h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else h.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const y=this._nodesSkinMap.get(E);if(E.joints.length>0&&void 0!==y){const w=64*P.length,G=new Float32Array(w/4);P.forEach(((w,E)=>{G.set(w.m,16*E)}));const h=this._bufferManager.createBufferView(G);this._accessors.push(this._bufferManager.createAccessor(h,"MAT4",5126,P.length)),E.inverseBindMatrices=this._accessors.length-1,this._skins.push(E);for(const E of y)E.skin=this._skins.length-1}}}async _exportSceneAsync(){const w={nodes:[]};if(this._babylonScene.metadata){const E=this._options.metadataSelector(this._babylonScene.metadata);E&&(w.extras=E)}const E=new Array,G=new Array,P=new Array;for(const x of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&yw(x,this._babylonScene.useRightHandedSystem)?P.push(...x.getChildren()):this._babylonScene.useRightHandedSystem?E.push(x):G.push(x);this._listAvailableCameras(),this._listAvailableSkeletons();const h=new Hw(!0,!1);w.nodes.push(...await this._exportNodesAsync(G,h));const B=new Hw(!1,!1);w.nodes.push(...await this._exportNodesAsync(E,B));const y=new Hw(!1,!0);w.nodes.push(...await this._exportNodesAsync(P,y)),w.nodes.length&&this._scenes.push(w),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Kw._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,h.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(w){let E=this._shouldExportNodeMap.get(w);return void 0===E&&(E=this._options.shouldExportNode(w),this._shouldExportNodeMap.set(w,E)),E}async _exportNodesAsync(w,E){const G=new Array;this._exportBuffers(w,E);for(const P of w)await this._exportNodeAsync(P,G,E);return G}_collectBuffers(w,E,G,P,h){if(this._shouldExportNode(w)&&w instanceof u.b&&w.py){const B=w.py.getVertexBuffers();if(B)for(const P in B){if(!r(P))continue;const y=B[P];h.setHasVertexColorAlpha(y,w.hasVertexAlpha);const x=y._buffer,U=E.get(x)||[];E.set(x,U),-1===U.indexOf(y)&&U.push(y);const l=G.get(y)||[];G.set(y,l),-1===l.indexOf(w)&&l.push(w)}const y=w.morphTargetManager;if(y)for(let E=0;E<y.numTargets;E++){const G=y.getTarget(E),h=P.get(G)||[];P.set(G,h),-1===h.indexOf(w)&&h.push(w)}}for(const B of w.getChildren())this._collectBuffers(B,E,G,P,h)}_exportBuffers(w,E){const G=new Map,P=new Map,h=new Map;for(const x of w)this._collectBuffers(x,G,P,h,E);const B=Array.from(G.keys());for(const x of B){const w=x.getData();if(!w)throw new Error("Buffer data is not available");const h=G.get(x);if(!h)continue;const B=h[0].byteStride;if(h.some((w=>w.byteStride!==B)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const y=Gw(w).slice();for(const E of h){const w=P.get(E),{byteOffset:G,byteStride:h,componentCount:B,type:x,count:U,normalized:l,kind:O}=m(E,w);switch(O){case i.g.NormalKind:case i.g.TangentKind:(0,M.j)(y,G,h,B,x,U,l,(w=>{const E=Math.sqrt(w[0]*w[0]+w[1]*w[1]+w[2]*w[2]);if(E>0){const G=1/E;w[0]*=G,w[1]*=G,w[2]*=G}}));break;case i.g.ColorKind:{const E=w.filter((w=>w.material instanceof Qw.JE||null==w.material)).length;if(0==E)break;if(E!=w.length){p.e.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}x==i.g.UNSIGNED_BYTE&&p.e.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const P=new c.dE,O=new c.Tx,u=this._babylonScene.getEngine().useExactSrgbConversions;(0,M.j)(y,G,h,B,x,U,l,(w=>{3===w.length?(P.VG(w,0),P.toLinearSpaceToRef(P,u),P.toArray(w,0)):(O.VG(w,0),O.toLinearSpaceToRef(O,u),O.toArray(w,0))}))}}}if(E.convertToRightHanded){for(const w of h){const E=P.get(w),{byteOffset:G,byteStride:h,componentCount:B,type:x,count:U,normalized:l,kind:O}=m(w,E);switch(O){case i.g.PositionKind:case i.g.NormalKind:case i.g.TangentKind:(0,M.j)(y,G,h,B,x,U,l,(w=>{w[0]=-w[0]}))}}E.convertedToRightHandedBuffers.set(x,y)}const U=this._bufferManager.createBufferView(y,B);E.setVertexBufferView(x,U);const l=new Map;for(const E of h){const w=P.get(E),{kind:G,totalVertices:h}=m(E,w);switch(G){case i.g.MatricesIndicesKind:case i.g.MatricesIndicesExtraKind:if(E.type==i.g.FLOAT){const w=E.getFloatData(h);null!==w&&l.set(E,w)}}}0!==l.size&&p.e.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const O=Array.from(l.keys());for(const G of O){const w=l.get(G);if(!w)continue;const P=w.some((w=>w>=256)),h=new(P?Uint16Array:Uint8Array)(w.length);for(let E=0;E<w.length;E++)h[E]=w[E];const B=this._bufferManager.createBufferView(h,4*(P?2:1));E.setRemappedBufferView(x,G,B)}}const y=Array.from(h.keys());for(const x of y){const w=h.get(x);if(!w)continue;const G=tw(x,w[0],this._bufferManager,this._bufferViews,this._accessors,E.convertToRightHanded);for(const P of w)E.bindMorphDataToMesh(P,G)}}async _exportNodeAsync(w,E,G){let P=this._nodeMap.get(w);if(void 0!==P)return void(E.includes(P)||E.push(P));const h=await this._createNodeAsync(w,G);if(h){P=this._nodes.length,this._nodes.push(h),this._nodeMap.set(w,P),G.pushExportedNode(w),E.push(P);const B={name:"runtime animations",channels:[],samplers:[]},y=[];this._babylonScene.animationGroups.length||(Kw._CreateMorphTargetAnimationFromMorphTargetAnimations(w,B,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.convertToRightHanded,this._options.shouldExportAnimation),w.animations.length&&Kw._CreateNodeAnimationFromNodeAnimations(w,B,y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.convertToRightHanded,this._options.shouldExportAnimation)),B.channels.length&&B.samplers.length&&this._animations.push(B),y.forEach((w=>{w.channels.length&&w.samplers.length&&this._animations.push(w)}))}const B=h?[]:E;for(const y of w.getChildren())await this._exportNodeAsync(y,B,G);h&&B.length&&(h.children=B)}async _createNodeAsync(w,E){if(!this._shouldExportNode(w))return null;const G={};if(w.name&&(G.name=w.name),w.metadata){const E=this._options.metadataSelector(w.metadata);E&&(G.extras=E)}if(w instanceof O.e&&(this._setNodeTransformation(G,w,E.convertToRightHanded),w instanceof u.b)){const h=w instanceof V.b?w.sourceMesh:w;if(h.Dh&&h.Dh.length>0&&(G.mesh=await this._exportMeshAsync(h,E)),w.skeleton){const E=this._skinMap.get(w.skeleton);var P;if(void 0!==E)void 0===this._nodesSkinMap.get(E)&&this._nodesSkinMap.set(E,[]),null===(P=this._nodesSkinMap.get(E))||void 0===P||P.push(G)}}if(w instanceof D.c){const P=this._camerasMap.get(w);if(P){var h;void 0===this._nodesCameraMap.get(P)&&this._nodesCameraMap.set(P,[]),this._setCameraTransformation(G,w,E.convertToRightHanded);const y=w.parent;if(null!==y&&Ew(w,y)){const w=this._nodeMap.get(y);if(void 0!==w){var B;const E=this._nodes[w];return ww(G,E),null===(B=this._nodesCameraMap.get(P))||void 0===B||B.push(E),null}}null===(h=this._nodesCameraMap.get(P))||void 0===h||h.push(G)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",G,w,this._nodeMap,E.convertToRightHanded)?G:(p.e.Warn(`Not exporting node ${w.name}`),null)}_exportIndices(w,E,G,P,h,y,x,U,l){let i=w;l.mode=Y(y);const O=x!==B.b.CounterClockWiseSideOrientation,u=!U.wasAddedByNoopNode&&O,V=function(w){switch(w){case B.b.TriangleFillMode:case B.b.TriangleStripDrawMode:case B.b.TriangleFanDrawMode:return!0}return!1}(y)&&u;if(V){if(y===B.b.TriangleStripDrawMode||y===B.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");l.mode=Y(y);const x=E?new Uint32Array(P):new Uint16Array(P);if(w)for(let E=0;E+2<P;E+=3)x[E]=w[G+E]+h,x[E+1]=w[G+E+2]+h,x[E+2]=w[G+E+1]+h;else for(let w=0;w+2<P;w+=3)x[w]=w,x[w+1]=w+2,x[w+2]=w+1;i=x}else if(w&&0!==h){const B=E?new Uint32Array(P):new Uint16Array(P);for(let E=0;E<P;E++)B[E]=w[G+E]+h;i=B}if(i){let B=U.getIndicesAccessor(w,G,P,h,V);if(void 0===B){const y=function(w,E,G,P){if(w instanceof Uint16Array||w instanceof Uint32Array)return w;if(w instanceof Int32Array)return new Uint32Array(w.buffer,w.byteOffset,w.length);const h=w.slice(E,E+G);return P?new Uint32Array(h):new Uint16Array(h)}(i,0,P,E),x=this._bufferManager.createBufferView(y),l=E?5125:5123;this._accessors.push(this._bufferManager.createAccessor(x,"SCALAR",l,P,0)),B=this._accessors.length-1,U.setIndicesAccessor(w,G,P,h,V,B)}l.indices=B}}_exportVertexBuffer(w,E,G,P,h,B){const y=w.getKind();if(!r(y))return;if(y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!E||!this._materialNeedsUVsSet.has(E)))return;let x=h.getVertexAccessor(w,G,P);if(void 0===x){const E=h.convertedToRightHandedBuffers.get(w._buffer)||w._buffer.getData(),B=y===i.g.PositionKind?function(w,E,G,P){const{byteOffset:h,byteStride:B,type:y,normalized:x}=E,U=E.getSize(),l=new Array(U).fill(1/0),i=new Array(U).fill(-1/0);return(0,M.j)(w,h+G*B,B,U,y,P*U,x,(w=>{for(let E=0;E<U;E++)l[E]=Math.min(l[E],w[E]),i[E]=Math.max(i[E],w[E])})),{min:l,max:i}}(E,w,G,P):void 0,U=(y===i.g.MatricesIndicesKind||y===i.g.MatricesIndicesExtraKind)&&w.type===i.g.FLOAT,l=U?i.g.UNSIGNED_BYTE:w.type,O=U?void 0:w.normalized,u=U?h.getRemappedBufferView(w._buffer,w):h.getVertexBufferView(w._buffer),V=w.byteOffset+G*w.byteStride;this._accessors.push(this._bufferManager.createAccessor(u,function(w,E){if(w==i.g.ColorKind)return E?"VEC4":"VEC3";switch(w){case i.g.PositionKind:case i.g.NormalKind:return"VEC3";case i.g.TangentKind:case i.g.MatricesIndicesKind:case i.g.MatricesIndicesExtraKind:case i.g.MatricesWeightsKind:case i.g.MatricesWeightsExtraKind:return"VEC4";case i.g.UVKind:case i.g.UV2Kind:case i.g.UV3Kind:case i.g.UV4Kind:case i.g.UV5Kind:case i.g.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${w}`)}(y,h.hasVertexColorAlpha(w)),l,P,V,B,O)),x=this._accessors.length-1,h.setVertexAccessor(w,G,P,x)}B.attributes[function(w){switch(w){case i.g.PositionKind:return"POSITION";case i.g.NormalKind:return"NORMAL";case i.g.TangentKind:return"TANGENT";case i.g.ColorKind:return"COLOR_0";case i.g.UVKind:return"TEXCOORD_0";case i.g.UV2Kind:return"TEXCOORD_1";case i.g.UV3Kind:return"TEXCOORD_2";case i.g.UV4Kind:return"TEXCOORD_3";case i.g.UV5Kind:return"TEXCOORD_4";case i.g.UV6Kind:return"TEXCOORD_5";case i.g.MatricesIndicesKind:return"JOINTS_0";case i.g.MatricesIndicesExtraKind:return"JOINTS_1";case i.g.MatricesWeightsKind:return"WEIGHTS_0";case i.g.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${w}`)}(y)]=x}async _exportMaterialAsync(w,E,G,P){let h=this._materialMap.get(w);if(void 0===h){const P=E&&Object.keys(E).some((w=>w.startsWith("uv")));if((w=w instanceof Vw.d?w.Ix[G.materialIndex]:w)instanceof aw.b)h=await this._materialExporter.exportPBRMaterialAsync(w,"image/png",P);else{if(!(w instanceof Qw.JE))return void p.e.Warn(`Unsupported material '${w.name}' with type ${w.getClassName()}`);h=await this._materialExporter.exportStandardMaterialAsync(w,"image/png",P)}this._materialMap.set(w,h)}P.material=h}async _exportMeshAsync(w,E){var G;let P=E.getMesh(w);if(void 0!==P)return P;const h={primitives:[]};P=this._meshes.length,this._meshes.push(h),E.setMesh(w,P);const y=w.isUnIndexed?null:w.ny(),x=null===(G=w.py)||void 0===G?void 0:G.getVertexBuffers(),U=E.getMorphTargetsFromMesh(w),l=w instanceof qw.c,i=w instanceof Rw,O=w.Dh;if(x&&O&&O.length>0)for(const a of O){const G={attributes:{}},P=a.Mw()||this._babylonScene.defaultMaterial;if(i){var u,V;const E={name:P.name},h=w,B=c.dE.White(),y=(null===(u=h.material)||void 0===u?void 0:u.alpha)??1,x=(null===(V=h.greasedLineMaterial)||void 0===V?void 0:V.color)??B;(!x.equalsWithEpsilon(B,e.d)||y<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...x.Lh(),y]}),this._materials.push(E),G.material=this._materials.length-1}else if(l){const E={name:P.name},h=w;(!h.color.equalsWithEpsilon(c.dE.White(),e.d)||h.alpha<1)&&(E.pbrMetallicRoughness={baseColorFactor:[...h.color.Lh(),h.alpha]}),this._materials.push(E),G.material=this._materials.length-1}else await this._exportMaterialAsync(P,x,a,G);const O=l||i?B.b.LineListDrawMode:w.overrideRenderingFillMode??P.fillMode,Q=P._getEffectiveOrientation(w);this._exportIndices(y,y?(0,M.d)(y,a.indexCount,a.indexStart,a.verticesStart):a.verticesCount>65535,y?a.indexStart:a.verticesStart,y?a.indexCount:a.verticesCount,-a.verticesStart,O,Q,E,G);for(const w of Object.values(x))this._exportVertexBuffer(w,P,a.verticesStart,a.verticesCount,E,G);if(U){G.targets=[];for(const w of U)G.targets.push(w.attributes)}h.primitives.push(G),this._extensionsPostExportMeshPrimitive(G)}if(U){h.weights=[],h.extras||(h.extras={}),h.extras.targetNames=[];for(const w of U)h.weights.push(w.influence),h.extras.targetNames.push(w.name)}return P}}zw._ExtensionNames=new Array,zw._ExtensionFactories={};class Lw{static async GLTFAsync(w,E,G){G&&G.exportWithoutWaitingForScene||await w.whenReadyAsync();const P=new zw(w,G),h=await P.generateGLTFAsync(E.replace(/\.[^/.]+$/,""));return P.dispose(),h}static async GLBAsync(w,E,G){G&&G.exportWithoutWaitingForScene||await w.whenReadyAsync();const P=new zw(w,G),h=await P.generateGLBAsync(E.replace(/\.[^/.]+$/,""));return P.dispose(),h}}G(12214);const mw="EXT_mesh_gpu_instancing";class nw{constructor(w){this.name=mw,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(w,E,G,h,B,y){return await new Promise((w=>{if(E&&G instanceof Jw.c&&G.hasThinInstances&&this._exporter){this._wasUsed=!0;const w=P.QE.Zero(),h=P.Quaternion.Identity(),x=P.QE.One(),U=G.thinInstanceGetWorldMatrices(),l=P.TmpVectors.QE[2],i=P.TmpVectors.Quaternion[1],O=P.TmpVectors.QE[3];let u=!1,V=!1,a=!1;const Q=new Float32Array(3*G.jx),c=new Float32Array(4*G.jx),Z=new Float32Array(3*G.jx);let J=0;for(const E of U)E.decompose(O,i,l),B&&(X(l),b(i)),Q.set(l.Lh(),3*J),c.set(i.normalize().Lh(),4*J),Z.set(O.Lh(),3*J),u=u||!l.equalsWithEpsilon(w),V=V||!i.equalsWithEpsilon(h),a=a||!O.equalsWithEpsilon(x),J++;const d={attributes:{}};u&&(d.attributes.TRANSLATION=this._buildAccessor(Q,"VEC3",G.jx,y)),V&&(d.attributes.ROTATION=this._buildAccessor(c,"VEC4",G.jx,y)),a&&(d.attributes.SCALE=this._buildAccessor(Z,"VEC3",G.jx,y)),E.extensions=E.extensions||{},E.extensions[mw]=d}w(E)}))}_buildAccessor(w,E,G,P){const h=P.createBufferView(w),B=P.createAccessor(h,E,5126,G);return this._exporter._accessors.push(B),this._exporter._accessors.length-1}}zw.RegisterExtension(mw,(w=>new nw(w)));var rw=G(12219),Yw=G(12235),Sw=G(12237),Xw=G(12244);function bw(w){return w===Sw.c.PositionKind?"POSITION":w===Sw.c.NormalKind?"NORMAL":w===Sw.c.ColorKind?"COLOR":w.startsWith(Sw.c.UVKind)?"TEX_COORD":"GENERIC"}const Aw={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class wE extends rw.c{static get DefaultAvailable(){return(0,rw.j)(wE.DefaultConfiguration)}static get Default(){return wE._Default??(wE._Default=new wE),wE._Default}static ResetDefault(w){wE._Default&&(w||wE._Default.dispose(),wE._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(w,E){return{module:await(E||DracoEncoderModule)({wasmBinary:w})}}_getWorkerContent(){return`${Yw.g}(${Yw.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:wE.DefaultConfiguration)}async _encodeAsync(w,E,G){const P=G?(0,Xw.c)(Aw,G):Aw;if(this._workerPoolPromise){const G=await this._workerPoolPromise;return await new Promise(((h,B)=>{G.push(((G,y)=>{const x=w=>{G.removeEventListener("error",x),G.removeEventListener("message",U),B(w),y()},U=w=>{"encodeMeshDone"===w.data.id&&(G.removeEventListener("error",x),G.removeEventListener("message",U),h(w.data.encodedMeshData),y())};G.addEventListener("error",x),G.addEventListener("message",U);const l=[];for(const E of w)l.push(E.data.buffer);E&&l.push(E.buffer),G.postMessage({id:"encodeMesh",attributes:w,indices:E,options:P},l)}))}))}if(this._modulePromise){const G=await this._modulePromise;return(0,Yw.g)(G.module,w,E,P)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(w,E){if(0==w.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");w instanceof Jw.c&&w.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===E||void 0===E?void 0:E.method)&&(p.e.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),E.method="MESH_SEQUENTIAL_ENCODING");const G=function(w){let E=w.ny(void 0,!0);return!E||E instanceof Uint32Array||E instanceof Uint16Array||(E=((0,M.d)(E,E.length)?Uint32Array:Uint16Array).from(E)),E}(w),P=function(w,E){const G=[];for(const P of w.getVerticesDataKinds()){if(null!==E&&void 0!==E&&E.includes(P)){if(P===Sw.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const h=w.getVertexBuffer(P),B=h.getSize(),y=(0,M.r)(h.getData(),B,h.type,h.byteOffset,h.byteStride,h.normalized,w.getTotalVertices(),!0);G.push({kind:P,dracoName:bw(P),size:B,data:y})}return G}(w,null===E||void 0===E?void 0:E.excludedAttributes);return await this._encodeAsync(P,G,E)}}wE.DefaultConfiguration={wasmUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${h.Tools._DefaultCdnUrl}/draco_encoder.js`},wE._Default=null;const EE="KHR_draco_mesh_compression";class GE{get wasUsed(){return this._wasUsed}constructor(w){this.name=EE,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===w.options.meshCompressionMethod&&wE.DefaultAvailable}dispose(){}postExportMeshPrimitive(w,E,G){if(!this.enabled)return;if(4!==w.mode&&5!==w.mode)return void p.e.Warn("Cannot compress primitive with mode "+w.mode+".");const P=[],h=[];let B=null;if(void 0!==w.indices){const y=G[w.indices],x=E.getBufferView(y);B=E.getData(x).slice(),P.push(x),h.push(y)}const y=[];for(const[i,O]of Object.entries(w.attributes)){const w=G[O],B=E.getBufferView(w),U=n(w.type),l=(0,M.r)(E.getData(B),U,w.componentType,w.byteOffset||0,B.byteStride||(0,M.m)(w.componentType)*U,w.normalized||!1,w.count,!0);y.push({kind:i,dracoName:(x=i,"POSITION"===x?"POSITION":"NORMAL"===x?"NORMAL":x.startsWith("COLOR")?"COLOR":x.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:n(w.type),data:l}),P.push(B),h.push(w)}var x;const U={method:w.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},l=wE.Default._encodeAsync(y,B,U).then((G=>{if(!G)return void p.e.Error("Draco encoding failed for primitive.");const B={bufferView:-1,attributes:G.attributeIds},y=E.createBufferView(G.data);E.setBufferView(B,y);for(const w of P)this._bufferViewsUsed.add(w);for(const w of h)this._accessorsUsed.add(w);w.extensions||(w.extensions={}),w.extensions[EE]=B})).catch((w=>{p.e.Error("Draco encoding failed for primitive: "+w)}));this._encodePromises.push(l),this._wasUsed=!0}async preGenerateBinaryAsync(w){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((E=>{w.getPropertiesWithBufferView(E).every((w=>this._accessorsUsed.has(w)))&&w.removeBufferView(E)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}zw.RegisterExtension(EE,(w=>new GE(w)));var PE=G(12251);const hE="KHR_lights_punctual",BE={name:"",color:[1,1,1],gx:1,range:Number.MAX_VALUE},yE={innerConeAngle:0,outerConeAngle:Math.PI/4},xE=P.QE.Backward();class UE{constructor(w){this.name=hE,this.enabled=!0,this.required=!1,this._exporter=w}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[hE]=this._lights}async postExportNodeAsync(w,E,G,h,B){return await new Promise((y=>{if(!(G instanceof dw.e))return void y(E);const x=G.getTypeID()==dw.e.LIGHTTYPEID_POINTLIGHT?"point":G.getTypeID()==dw.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":G.getTypeID()==dw.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!x||!(G instanceof PE.c))return p.e.Warn(`${w}: Light ${G.name} is not supported in ${hE}`),void y(E);if(G.falloffType!==dw.e.FALLOFF_GLTF&&p.e.Warn(`${w}: Light falloff for ${G.name} does not match the ${hE} specification!`),!G.position.equalsToFloats(0,0,0)){const w=P.TmpVectors.QE[0].B(G.position);B&&X(w),E.translation=w.Lh()}if("point"!==x){const w=G.direction.normalizeToRef(P.TmpVectors.QE[0]);B&&X(w);const h=P.Quaternion.FromUnitVectorsToRef(xE,w,P.TmpVectors.Quaternion[0]);P.Quaternion.IsIdentity(h)||(E.rotation=h.Lh())}const U={type:x,name:G.name,color:G.ox.Lh(),gx:G.gx,range:G.range};if(Pw(U,BE),"spot"===x){const w=G;U.spot={innerConeAngle:w.innerAngle/2,outerConeAngle:w.angle/2},Pw(U.spot,yE)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(U);const l={ih:this._lights.lights.length-1},i=G.parent;if(i&&Ew(G,i)){const w=h.get(i);if(w){const G=this._exporter._nodes[w];return ww(E,G),G.extensions||(G.extensions={}),G.extensions[hE]=l,void y(null)}}E.extensions||(E.extensions={}),E.extensions[hE]=l,y(E)}))}}zw.RegisterExtension(hE,(w=>new UE(w)));var lE=G(12163);const iE="KHR_materials_anisotropy";class OE{constructor(w){this.name=iE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof lE.d&&G.anisotropy.isEnabled&&!G.anisotropy.legacy?(G.anisotropy.texture&&P.push(G.anisotropy.texture),P):[]}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof lE.d){if(!G.anisotropy.isEnabled||G.anisotropy.legacy)return void w(E);this._wasUsed=!0,E.extensions=E.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(G.anisotropy.texture),h={anisotropyStrength:G.anisotropy.gx,anisotropyRotation:G.anisotropy.angle,anisotropyTexture:P??void 0};null!==h.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(G),E.extensions[iE]=h}w(E)}))}}zw.RegisterExtension(iE,(w=>new OE(w)));const uE="KHR_materials_clearcoat";class VE{constructor(w){this.name=uE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof lE.d&&G.clearCoat.isEnabled?(G.clearCoat.texture&&P.push(G.clearCoat.texture),!G.clearCoat.useRoughnessFromMainTexture&&G.clearCoat.textureRoughness&&P.push(G.clearCoat.textureRoughness),G.clearCoat.bumpTexture&&P.push(G.clearCoat.bumpTexture),P):[]}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof lE.d){if(!G.clearCoat.isEnabled)return void w(E);this._wasUsed=!0,E.extensions=E.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(G.clearCoat.texture);let B;B=G.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(G.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(G.clearCoat.textureRoughness),G.clearCoat.isTintEnabled&&h.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${G.name}`),G.clearCoat.remapF0OnInterfaceChange&&h.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${G.name}`);const y=this._exporter._materialExporter.getTextureInfo(G.clearCoat.bumpTexture),x={clearcoatFactor:G.clearCoat.gx,clearcoatTexture:P??void 0,clearcoatRoughnessFactor:G.clearCoat.roughness,clearcoatRoughnessTexture:B??void 0,clearcoatNormalTexture:y??void 0};null===x.clearcoatTexture&&null===x.clearcoatRoughnessTexture&&null===x.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(G),E.extensions[uE]=x}w(E)}))}}zw.RegisterExtension(uE,(w=>new VE(w)));const aE="KHR_materials_diffuse_transmission";function QE(w,E){const G=E.subSurface;let P=null;return G.translucencyIntensityTexture?P=G.translucencyIntensityTexture:G.thicknessTexture&&G.useMaskFromThicknessTexture&&(P=G.thicknessTexture),P&&!G.useGltfStyleTextures?(p.e.Warn(`${w}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${E.name}`,1),null):P}class cE{constructor(w){this.name=aE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];if(G instanceof aw.b&&this._isExtensionEnabled(G)){const E=QE(w,G);return E&&P.push(E),G.subSurface.translucencyColorTexture&&P.push(G.subSurface.translucencyColorTexture),P}return P}_isExtensionEnabled(w){if(w.unlit)return!1;const E=w.subSurface;return!!E.isTranslucencyEnabled&&(!w.unlit&&!E.useAlbedoToTintTranslucency&&E.useGltfStyleTextures&&1===E.volumeIndexOfRefraction&&0===E.minimumThickness&&0===E.maximumThickness)}postExportMaterialAsync(w,E,G){return new Promise((P=>{if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0;const P=G.subSurface,h=QE(w,G),B=0==P.translucencyIntensity?void 0:P.translucencyIntensity,y=this._exporter._materialExporter.getTextureInfo(h)??void 0,x=!P.translucencyColor||P.translucencyColor.equalsFloats(1,1,1)?void 0:P.translucencyColor.Lh(),U=this._exporter._materialExporter.getTextureInfo(P.translucencyColorTexture)??void 0,l={diffuseTransmissionFactor:B,diffuseTransmissionTexture:y,diffuseTransmissionColorFactor:x,diffuseTransmissionColorTexture:U};(y||U)&&this._exporter._materialNeedsUVsSet.add(G),E.extensions=E.extensions||{},E.extensions[aE]=l}P(E)}))}}zw.RegisterExtension(aE,(w=>new cE(w)));const ZE="KHR_materials_dispersion";class JE{constructor(){this.name=ZE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){if(w.unlit)return!1;const E=w.subSurface;return!(!E.isRefractionEnabled&&!E.isDispersionEnabled)}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0;const w={dispersion:G.subSurface.dispersion};E.extensions=E.extensions||{},E.extensions[ZE]=w}w(E)}))}}zw.RegisterExtension(ZE,(()=>new JE));const dE="KHR_materials_emissive_strength";class KE{constructor(){this.name=dE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(w,E,G){return await new Promise((w=>{if(!(G instanceof aw.b))return w(E);const P=G.emissiveColor.Lh(),h=Math.max(...P);if(h>1){this._wasUsed=!0,E.extensions||(E.extensions={});const w={emissiveStrength:h},P=G.emissiveColor.scale(1/w.emissiveStrength);E.emissiveFactor=P.Lh(),E.extensions[dE]=w}return w(E)}))}}zw.RegisterExtension(dE,(w=>new KE));const tE="KHR_materials_ior";class qE{constructor(){this.name=tE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.indexOfRefraction&&1.5!=w.indexOfRefraction)}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0;const w={ior:G.indexOfRefraction};E.extensions=E.extensions||{},E.extensions[tE]=w}w(E)}))}}zw.RegisterExtension(tE,(w=>new qE));const WE="KHR_materials_iridescence";class TE{constructor(w){this.name=WE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof lE.d&&G.iridescence.isEnabled?(G.iridescence.texture&&P.push(G.iridescence.texture),G.iridescence.thicknessTexture&&G.iridescence.thicknessTexture!==G.iridescence.texture&&P.push(G.iridescence.thicknessTexture),P):[]}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof lE.d){if(!G.iridescence.isEnabled)return void w(E);this._wasUsed=!0,E.extensions=E.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(G.iridescence.texture),h=this._exporter._materialExporter.getTextureInfo(G.iridescence.thicknessTexture),B={iridescenceFactor:G.iridescence.gx,iridescenceIor:G.iridescence.indexOfRefraction,iridescenceThicknessMinimum:G.iridescence.minimumThickness,iridescenceThicknessMaximum:G.iridescence.maximumThickness,iridescenceTexture:P??void 0,iridescenceThicknessTexture:h??void 0};null===B.iridescenceTexture&&null===B.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(G),E.extensions[WE]=B}w(E)}))}}zw.RegisterExtension(WE,(w=>new TE(w)));const IE="KHR_materials_sheen";class jE{constructor(w){this.name=IE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){return G instanceof aw.b&&G.sheen.isEnabled&&G.sheen.texture?[G.sheen.texture]:[]}async postExportMaterialAsync(w,E,G){return await new Promise((w=>{if(G instanceof aw.b){if(!G.sheen.isEnabled)return void w(E);this._wasUsed=!0,null==E.extensions&&(E.extensions={});const P={sheenColorFactor:G.sheen.color.Lh(),sheenRoughnessFactor:G.sheen.roughness??0};null===P.sheenColorTexture&&null===P.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(G),G.sheen.texture&&(P.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.texture)??void 0),G.sheen.textureRoughness&&!G.sheen.useRoughnessFromMainTexture?P.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.textureRoughness)??void 0:G.sheen.texture&&G.sheen.useRoughnessFromMainTexture&&(P.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(G.sheen.texture)??void 0),E.extensions[IE]=P}w(E)}))}}zw.RegisterExtension(IE,(w=>new jE(w)));const gE="KHR_materials_specular";class oE{constructor(w){this.name=gE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof aw.b&&this._isExtensionEnabled(G)?(G.metallicReflectanceTexture&&P.push(G.metallicReflectanceTexture),G.reflectanceTexture&&P.push(G.reflectanceTexture),P):P}_isExtensionEnabled(w){return!w.unlit&&(void 0!=w.metallicF0Factor&&1!=w.metallicF0Factor||void 0!=w.metallicReflectanceColor&&!w.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.metallicReflectanceTexture||null!=w.reflectanceTexture}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0,E.extensions=E.extensions||{};const w=this._exporter._materialExporter.getTextureInfo(G.metallicReflectanceTexture)??void 0,P=this._exporter._materialExporter.getTextureInfo(G.reflectanceTexture)??void 0,h={specularFactor:1==G.metallicF0Factor?void 0:G.metallicF0Factor,specularTexture:w,specularColorFactor:G.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:G.metallicReflectanceColor.Lh(),specularColorTexture:P};this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),E.extensions[gE]=h}w(E)}))}}zw.RegisterExtension(gE,(w=>new oE(w)));const fE="KHR_materials_transmission";class kE{constructor(w){this.name=fE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof aw.b&&this._isExtensionEnabled(G)?(G.subSurface.thicknessTexture&&P.push(G.subSurface.thicknessTexture),P):P}_isExtensionEnabled(w){if(w.unlit)return!1;const E=w.subSurface;return E.isRefractionEnabled&&void 0!=E.refractionIntensity&&0!=E.refractionIntensity||this._hasTexturesExtension(w)}_hasTexturesExtension(w){return null!=w.subSurface.refractionIntensityTexture}async postExportMaterialAsync(w,E,G){if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0;const P=G.subSurface,h={transmissionFactor:0===P.refractionIntensity?void 0:P.refractionIntensity};if(this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),P.refractionIntensityTexture)if(P.useGltfStyleTextures){const w=await this._exporter._materialExporter.exportTextureAsync(P.refractionIntensityTexture,"image/png");w&&(h.transmissionTexture=w)}else p.e.Warn(`${w}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);E.extensions||(E.extensions={}),E.extensions[fE]=h}return E}}zw.RegisterExtension(fE,(w=>new kE(w)));const NE="KHR_materials_unlit";class vE{constructor(){this.name=NE,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(w,E,G){return new Promise((w=>{let P=!1;G instanceof aw.b?P=G.unlit:G instanceof Qw.JE&&(P=G.disableLighting),P&&(this._wasUsed=!0,null==E.extensions&&(E.extensions={}),E.extensions[NE]={}),w(E)}))}}zw.RegisterExtension(NE,(()=>new vE));const CE="KHR_materials_volume";class sE{constructor(w){this.name=CE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof aw.b&&this._isExtensionEnabled(G)?(G.subSurface.thicknessTexture&&P.push(G.subSurface.thicknessTexture),P):P}_isExtensionEnabled(w){if(w.unlit)return!1;const E=w.subSurface;return!(!E.isRefractionEnabled&&!E.isTranslucencyEnabled)&&(void 0!=E.maximumThickness&&0!=E.maximumThickness||void 0!=E.tintColorAtDistance&&E.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=E.tintColor&&E.tintColor!=c.dE.White()||this._hasTexturesExtension(w))}_hasTexturesExtension(w){return null!=w.subSurface.thicknessTexture}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof aw.b&&this._isExtensionEnabled(G)){this._wasUsed=!0;const w=G.subSurface,P={thicknessFactor:0==w.maximumThickness?void 0:w.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(w.thicknessTexture)??void 0,attenuationDistance:w.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:w.tintColorAtDistance,attenuationColor:w.tintColor.equalsFloats(1,1,1)?void 0:w.tintColor.Lh()};this._hasTexturesExtension(G)&&this._exporter._materialNeedsUVsSet.add(G),E.extensions=E.extensions||{},E.extensions[CE]=P}w(E)}))}}zw.RegisterExtension(CE,(w=>new sE(w)));const FE="EXT_materials_diffuse_roughness";class ME{constructor(w){this.name=FE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=w}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(w,E,G){const P=[];return G instanceof lE.d&&G._baseDiffuseRoughness?(G._baseDiffuseRoughnessTexture&&P.push(G._baseDiffuseRoughnessTexture),P):[]}postExportMaterialAsync(w,E,G){return new Promise((w=>{if(G instanceof lE.d){if(!G._baseDiffuseRoughness)return void w(E);this._wasUsed=!0,E.extensions=E.extensions||{};const P=this._exporter._materialExporter.getTextureInfo(G._baseDiffuseRoughnessTexture),h={diffuseRoughnessFactor:G._baseDiffuseRoughness,diffuseRoughnessTexture:P??void 0};null!==h.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(G),E.extensions[FE]=h}w(E)}))}}zw.RegisterExtension(FE,(w=>new ME(w)));const pE="KHR_texture_transform";class DE{constructor(){this.name=pE,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(w,E,G){if(G.Ww()||h.Tools.Warn(`${w}: /*@__KEY__*/"scene" is not defined for Babylon texture ${G.name}!`),(0!==G.uAng||0!==G.vAng)&&(h.Tools.Warn(`${w}: Texture ${G.name} with rotation in the u or v axis is not supported in glTF.`),0!==G.uRotationCenter||0!==G.vRotationCenter))return;const P={};let B=!1;if(0===G.uOffset&&0===G.vOffset||(P.offset=[G.uOffset,G.vOffset],B=!0),1===G.uScale&&1===G.vScale||(P.scale=[G.uScale,G.vScale],B=!0),0!==G.wAng){if(0!==G.uRotationCenter||0!==G.vRotationCenter){if(G.homogeneousRotationInUVTransform&&G.uScale!==G.vScale)return void h.Tools.Warn(`${w}: Texture ${G.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${pE}.`);h.Tools.Warn(`${w}: Texture ${G.name} with non-origin rotation center will be exported using an adjusted offset with ${pE}.`),P.offset=function(w){const{uOffset:E,vOffset:G,uRotationCenter:P,vRotationCenter:h,uScale:B,vScale:y,wAng:x}=w,U=Math.cos(x),l=Math.sin(x),i=P*B,O=h*y;return[E+(i*(1-U)+O*l),G+(O*(1-U)-i*l)]}(G)}P.rotation=-G.wAng,B=!0}0!==G.coordinatesIndex&&(P.texCoord=G.coordinatesIndex,B=!0),B&&(this._wasUsed=!0,E.extensions||(E.extensions={}),E.extensions[pE]=P)}}zw.RegisterExtension(pE,(()=>new DE));class eE{static CreateSTL(w){let E=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",h=arguments.length>3&&void 0!==arguments[3]&&arguments[3],B=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],x=arguments.length>6&&void 0!==arguments[6]&&arguments[6],U=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const l=function(w,E,G){const h=[3*w[G],3*w[G+1],3*w[G+2]],B=[new P.QE(E[h[0]],E[h[0]+2],E[h[0]+1]),new P.QE(E[h[1]],E[h[1]+2],E[h[1]+1]),new P.QE(E[h[2]],E[h[2]+2],E[h[2]+1])],y=B[0].cE(B[1]),x=B[2].cE(B[1]);return{v:B,n:P.QE.Cross(x,y).normalize()}},O=function(w,E,G,P){return E=u(w,E,G.x,P),E=u(w,E,G.y,P),u(w,E,G.z,P)},u=function(w,E,G,P){return w.setFloat32(E,G,P),E+4},a=function(w){if(x){let E=w;w instanceof V.b&&(E=w.sourceMesh);const G=E.getVerticesData(i.g.PositionKind,!0,!0);if(!G)return[];const h=P.QE.Zero();let B;for(B=0;B<G.length;B+=3)P.QE.TransformCoordinatesFromFloatsToRef(G[B],G[B+1],G[B+2],w.Ah(!0),h).toArray(G,B);return G}return w.getVerticesData(i.g.PositionKind)||[]};x&&(y=!0);let Q="",c=0,Z=0;if(h){for(let G=0;G<w.length;G++){const E=w[G].ny();c+=E?E.length/3:0}const E=new ArrayBuffer(84+50*c);Q=new DataView(E),Z+=80,Q.setUint32(Z,c,B),Z+=4}else U||(Q="solid stlmesh\r\n");for(let P=0;P<w.length;P++){const E=w[P];!h&&U&&(Q+="solid "+E.name+"\r\n"),!y&&E instanceof Jw.c&&E.bakeCurrentTransformIntoVertices();const G=a(E),x=E.ny()||[];for(let w=0;w<x.length;w+=3){const E=l(x,G,w);h?(Z=O(Q,Z,E.n,B),Z=O(Q,Z,E.v[0],B),Z=O(Q,Z,E.v[1],B),Z=O(Q,Z,E.v[2],B),Z+=2):(Q+="\tfacet normal "+E.n.x+" "+E.n.y+" "+E.n.z+"\r\n",Q+="\t\touter loop\r\n",Q+="\t\t\tvertex "+E.v[0].x+" "+E.v[0].y+" "+E.v[0].z+"\r\n",Q+="\t\t\tvertex "+E.v[1].x+" "+E.v[1].y+" "+E.v[1].z+"\r\n",Q+="\t\t\tvertex "+E.v[2].x+" "+E.v[2].y+" "+E.v[2].z+"\r\n",Q+="\t\tendloop\r\n",Q+="\tendfacet\r\n")}!h&&U&&(Q+="endsolid "+name+"\r\n")}if(h||U||(Q+="endsolid stlmesh"),E){const w=document.createElement("a"),E=new Blob([Q],{type:"application/octet-stream"});w.href=window.URL.createObjectURL(E),w.download=G+".stl",w.click()}return Q}}function RE(w,E){let G=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const P=[];for(let h=0;h<w.length/G;h++){const B=w[h*G],y=w[h*G+1],x=w[h*G+2];P.push(`(${B.toPrecision(E.precision)}, ${y.toPrecision(E.precision)}, ${x.toPrecision(E.precision)})`)}return P.join(", ")}function HE(w,E){const G=[];for(let P=0;P<w.length/2;P++){const h=w[2*P],B=w[2*P+1];G.push(`(${h.toPrecision(E.precision)}, ${(1-B).toPrecision(E.precision)})`)}return G.join(", ")}function zE(w,E){const G=w.getVerticesData(i.g.PositionKind),P=w.getVerticesData(i.g.NormalKind);if(G&&P)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(w){var E;const G=null!==(E=w.ny())&&void 0!==E&&E.length?w.getTotalIndices():w.getTotalVertices();return Array(G/3).fill(3).join(", ")}(w)}]\n\t\tint[] faceVertexIndices = [${function(w){const E=w.ny(),G=[];if(null!==E)for(let P=0;P<E.length;P++)G.push(E[P]);else{const E=w.getTotalVertices();for(let w=0;w<E;w++)G.push(w)}return G.join(", ")}(w)}]\n\t\tnormal3f[] normals = [${RE(P,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${RE(G,E)}]\n        ${function(w,E){let G="";for(let h=0;h<4;h++){const P=h>0?h:"",B=w.getVerticesData(i.g.UVKind+(P?P+1:""));B&&(G+=`\n\t\ttexCoord2f[] primvars:st${P} = [${HE(B,E)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const P=w.getVerticesData(i.g.ColorKind);return P&&(G+=`\n\tcolor3f[] primvars:displayColor = [${RE(P,E,P.length/w.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),G}(w,E)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function LE(w,E){return`\n        def "Geometry"\n        {\n        ${zE(w,E)}\n        }\n        `}function mE(w){let E='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return E+=w,fflate.strToU8(E)}function nE(w){const E=w.m;return`( ${rE(E,0)}, ${rE(E,4)}, ${rE(E,8)}, ${rE(E,12)} )`}function rE(w,E){return`(${w[E+0]}, ${w[E+1]}, ${w[E+2]}, ${w[E+3]})`}function YE(w){const E="Object_"+w.uniqueId,G=function(w){const E=w.getWorldMatrix().clone(),G=w.Ww().useRightHandedSystem;if(!G){let P=w.parent;for(;P;){if(yw(P,G)){E.multiplyToRef(P.getWorldMatrix().invert(),E);break}P=P.parent}}return E.determinant()<0&&h.Tools.Warn(`Exporting mesh ${w.name} with negative scale. Result may look incorrect in destination engine.`),E}(w),P=nE(G);return`def Xform "${E}" (\n\tprepend references = @./geometries/Geometry_${w.py.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${P}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${w.material.uniqueId}>\n}\n\n`}function SE(w){switch(w){case W.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case W.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case W.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function XE(w){return`(${w.x}, ${w.y})`}function bE(w){return`(${w.r}, ${w.g}, ${w.b})`}function AE(w,E,G,h,B,y){const x=w.getInternalTexture().uniqueId+"_"+w.invertY;B[x]=w;const U=w.coordinatesIndex>0?"st"+w.coordinatesIndex:"st",l=new P.Vector2(w.uScale,w.vScale),i=new P.Vector2(w.uOffset,w.vOffset),O=w.wAng,u=Math.sin(O),V=Math.cos(O);return i.y=1-i.y-l.y,i.x+=u*l.x,i.y+=(1-V)*l.y,`\n    def Shader "PrimvarReader_${G}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${U}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${G}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${E.uniqueId}/PrimvarReader_${G}.outputs:result>\n        float inputs:rotation = ${(O*(180/Math.PI)).toFixed(y.precision)}\n        float2 inputs:scale = ${XE(l)}\n        float2 inputs:translation = ${XE(i)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${w.uniqueId}_${G}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${x}.png@\n        float2 inputs:st.connect = </Materials/Material_${E.uniqueId}/Transform2d_${G}.outputs:result>\n        ${h?"float4 inputs:scale = "+function(w){return`(${w.r}, ${w.g}, ${w.b}, 1.0)`}(h):""}\n        token inputs:sourceColorSpace = "${w.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${SE(w.wrapU)}"\n        token inputs:wrapT = "${SE(w.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${E.needAlphaBlending()?"float outputs:a":""}\n    }`}function wG(w,E,G){const P="\t\t\t",h=[],B=[],{diffuseMap:y,ox:x,alphaCutOff:U,emissiveMap:l,emissive:i,normalMap:O,roughnessMap:u,roughnessChannel:V,roughness:a,metalnessMap:Q,metalnessChannel:Z,metalness:J,aoMap:d,aoMapChannel:K,aoMapIntensity:t,alphaMap:q,ior:W,clearCoatEnabled:T,clearCoat:I,clearCoatMap:j,clearCoatRoughness:g,clearCoatRoughnessMap:o}=function(w){const E={diffuseMap:null,ox:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return w instanceof Qw.JE?{...E,diffuseMap:w.diffuseTexture,ox:w.diffuseColor,alphaCutOff:w.alphaCutOff,emissiveMap:w.emissiveTexture,emissive:w.emissiveColor,roughness:1,alphaMap:w.opacityTexture}:w instanceof lE.d?{...E,diffuseMap:w._albedoTexture,ox:w._albedoColor,alphaCutOff:w._alphaCutOff,emissiveMap:w._emissiveTexture,emissive:w._emissiveColor,normalMap:w._bumpTexture,roughnessMap:w._metallicTexture,roughnessChannel:w._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:w._roughness??1,metalnessMap:w._metallicTexture,metalnessChannel:w._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:w._metallic??0,aoMap:w._ambientTexture,aoMapChannel:w._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:w._ambientTextureStrength,alphaMap:w._opacityTexture,ior:w.subSurface.indexOfRefraction,clearCoatEnabled:w.clearCoat.isEnabled,clearCoat:w.clearCoat.gx,clearCoatMap:w.clearCoat.texture,clearCoatRoughness:w.clearCoat.roughness,clearCoatRoughnessMap:w.clearCoat.useRoughnessFromMainTexture?w.clearCoat.texture:w.clearCoat.textureRoughness}:E}(w);return null!==y?(h.push(`${P}color3f inputs:diffuseColor.connect = </Materials/Material_${w.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:rgb>`),w.needAlphaBlending()?h.push(`${P}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`):w.needAlphaTesting()&&(h.push(`${P}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${y.uniqueId}_diffuse.outputs:a>`),h.push(`${P}float inputs:opacityThreshold = ${U}`)),B.push(AE(y,w,"diffuse",x,E,G))):h.push(`${P}color3f inputs:diffuseColor = ${bE(x||c.dE.White())}`),null!==l?(h.push(`${P}color3f inputs:emissiveColor.connect = </Materials/Material_${w.uniqueId}/Texture_${l.uniqueId}_emissive.outputs:rgb>`),B.push(AE(l,w,"emissive",i,E,G))):i&&i.toLuminance()>0&&h.push(`${P}color3f inputs:emissiveColor = ${bE(i)}`),null!==O&&(h.push(`${P}normal3f inputs:normal.connect = </Materials/Material_${w.uniqueId}/Texture_${O.uniqueId}_normal.outputs:rgb>`),B.push(AE(O,w,"normal",null,E,G))),null!==d&&(h.push(`${P}float inputs:occlusion.connect = </Materials/Material_${w.uniqueId}/Texture_${d.uniqueId}_occlusion.outputs:${K}>`),B.push(AE(d,w,"occlusion",new c.dE(t,t,t),E,G))),null!==u?(h.push(`${P}float inputs:roughness.connect = </Materials/Material_${w.uniqueId}/Texture_${u.uniqueId}_roughness.outputs:${V}>`),B.push(AE(u,w,"roughness",new c.dE(a,a,a),E,G))):h.push(`${P}float inputs:roughness = ${a}`),null!==Q?(h.push(`${P}float inputs:metallic.connect = </Materials/Material_${w.uniqueId}/Texture_${Q.uniqueId}_metallic.outputs:${Z}>`),B.push(AE(Q,w,"metallic",new c.dE(J,J,J),E,G))):h.push(`${P}float inputs:metallic = ${J}`),null!==q?(h.push(`${P}float inputs:opacity.connect = </Materials/Material_${w.uniqueId}/Texture_${q.uniqueId}_opacity.outputs:r>`),h.push(`${P}float inputs:opacityThreshold = 0.0001`),B.push(AE(q,w,"opacity",null,E,G))):h.push(`${P}float inputs:opacity = ${w.alpha}`),T&&(null!==j?(h.push(`${P}float inputs:clearcoat.connect = </Materials/Material_${w.uniqueId}/Texture_${j.uniqueId}_clearcoat.outputs:r>`),B.push(AE(j,w,"clearcoat",new c.dE(I,I,I),E,G))):h.push(`${P}float inputs:clearcoat = ${I}`),null!==o?(h.push(`${P}float inputs:clearcoatRoughness.connect = </Materials/Material_${w.uniqueId}/Texture_${o.uniqueId}_clearcoatRoughness.outputs:g>`),B.push(AE(o,w,"clearcoatRoughness",new c.dE(g,g,g),E,G))):h.push(`${P}float inputs:clearcoatRoughness = ${g}`)),h.push(`${P}float inputs:ior = ${W}`),`\n\tdef Material "Material_${w.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${h.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${w.uniqueId}/PreviewSurface.outputs:surface>\n\n${B.join("\n")}\n\n\t}\n`}async function EG(w,E,G){const B={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...E};"undefined"===typeof fflate&&await h.Tools.LoadScriptAsync(B.fflateUrl);const y={};y[B.modelFileName]=null;let x='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';x+=function(w){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===w.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${w.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${w.planeAnchoringAlignment}"`:""}\n            `}(B);const U={};for(const P of w.meshes){if(0===P.getTotalVertices())continue;const w=P,E=w.py,l=w.material;if(!l||!E||G&&!G(w))continue;if(-1!==["JE","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(l.getClassName())){const G="geometries/Geometry_"+E.uniqueId+".usda";if(!(G in y)){const w=LE(E,B);y[G]=mE(w)}l.uniqueId in U||(U[l.uniqueId]=l),x+=YE(w)}else h.Tools.Warn("USDZExportAsync does not support this material type: "+l.getClassName())}w.activeCamera&&B.exportCamera&&(x+=function(w,E){const G="Camera_"+w.uniqueId,h=nE(P.Matrix.RotationY(Math.PI).multiply(w.getWorldMatrix()));if(w.mode===W.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${G}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.Sh.toPrecision(E.precision)}, ${w.maxZ.toPrecision(E.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(w.orthoLeft||1)+Math.abs(w.orthoRight||1))).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(w.orthoTop||1)+Math.abs(w.orthoBottom||1))).toPrecision(E.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const P=w.getEngine().getAspectRatio(w),B=E.cameraSensorWidth||35;return`def Camera "${G}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${h}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${w.Sh.toPrecision(E.precision)}, ${w.maxZ.toPrecision(E.precision)})\n\t\t\tfloat focalLength = ${(B/(2*Math.tan(.5*w.fov))).toPrecision(E.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(B*P).toPrecision(E.precision)}\n\t\t\tfloat verticalAperture = ${(B/P).toPrecision(E.precision)}            \n\t\t}\n\t\n\t`}}(w.activeCamera,B)),x+="\n            }\n        }\n    }";const l={};x+=function(w,E,G){const P=[];for(const h in w){const B=w[h];P.push(wG(B,E,G))}return`\n    def "Materials"\n{\n${P.join("")}\n}\n\n`}(U,l,B),y[B.modelFileName]=fflate.strToU8(x);for(const P in l){const w=l[P],E=w.getSize(),G=await w.readPixels();if(!G)throw new Error("Texture data is not available");const h=await T.DumpTools.DumpDataAsync(E.width,E.height,G,"image/png",void 0,!1,!0);y[`textures/Texture_${P}.png`]=new Uint8Array(h).slice()}let i=0;for(const P in y){const w=y[P];if(!w)continue;i+=34+P.length;const E=63&i;if(4!==E){const G=new Uint8Array(64-E);y[P]=[w,{extra:{12345:G}}]}i=w.length}return fflate.zipSync(y,{level:0})}}}]);