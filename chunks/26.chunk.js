"use strict";(self.n52dyox90qa=self.n52dyox90qa||[]).push([[26],{12221:(E,t,z)=>{z.r(t),z.d(t,{EXT_materials_diffuse_roughness:()=>ot,EXT_mesh_gpu_instancing:()=>UE,GLTF2Export:()=>sE,GLTFData:()=>Z,KHR_draco_mesh_compression:()=>zt,KHR_lights_punctual:()=>Ct,KHR_materials_anisotropy:()=>ht,KHR_materials_clearcoat:()=>yt,KHR_materials_diffuse_transmission:()=>at,KHR_materials_dispersion:()=>mz,KHR_materials_emissive_strength:()=>It,KHR_materials_ior:()=>Dt,KHR_materials_iridescence:()=>lt,KHR_materials_sheen:()=>Kt,KHR_materials_specular:()=>Bt,KHR_materials_transmission:()=>xt,KHR_materials_unlit:()=>Vt,KHR_materials_volume:()=>it,KHR_texture_transform:()=>Tt,OBJExport:()=>u,STLExport:()=>qt,USDZExportAsync:()=>tz,_ConvertToGLTFPBRMetallicRoughness:()=>J,_SolveMetallic:()=>x,__IGLTFExporterExtension:()=>p});var A=z(11812),X=z(11630),R=z(12121);class u{static OBJ(E,t,z,u){const p=[];let C=1,Z=1;t&&(z||(z="mat"),p.push("mtllib "+z+".mtl"));for(let H=0;H<E.length;H++){const z=E[H],h=z.name||`mesh${H}}`;p.push(`o ${h}`);let d=null;if(u){const E=z.Hp(!0);d=new A.Matrix,E.invertToRef(d),z.bakeTransformIntoVertices(E)}if(t){const E=z.material;E&&p.push("usemtl "+E.id)}const y=z.hp;if(!y){X.Tools.Warn("No geometry is present on the mesh");continue}const O=y.getVerticesData("position"),c=y.getVerticesData("normal"),a=y.getVerticesData("uv"),L=y.dp();let mE=0,W=0;if(!O||!L){X.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const I=E[0].lE().useRightHandedSystem?1:-1;for(let E=0;E<O.length;E+=3)p.push("v "+O[E]*I+" "+O[E+1]+" "+O[E+2]),mE++;if(null!=c)for(let E=0;E<c.length;E+=3)p.push("vn "+c[E]*I+" "+c[E+1]+" "+c[E+2]);if(null!=a)for(let E=0;E<a.length;E+=2)p.push("vt "+a[E]+" "+a[E+1]),W++;const e=["","",""],D=(z.material||z.lE().defaultMaterial)._getEffectiveOrientation(z),[S,l]=D===R.b.ClockWiseSideOrientation?[2,1]:[1,2];for(let E=0;E<L.length;E+=3){const t=[String(L[E]+C),String(L[E+S]+C),String(L[E+l]+C)],z=[String(L[E]+Z),String(L[E+S]+Z),String(L[E+l]+Z)],A=t,X=null!=a?z:e,R=null!=c?t:e;p.push("f "+A[0]+"/"+X[0]+"/"+R[0]+" "+A[1]+"/"+X[1]+"/"+R[1]+" "+A[2]+"/"+X[2]+"/"+R[2])}u&&d&&z.bakeTransformIntoVertices(d),C+=mE,Z+=W}return p.join("\n")}static MTL(E){const t=[],z=E.material;t.push("newmtl mat1"),t.push("  Ns "+z.specularPower.toFixed(4)),t.push("  Ni 1.5000"),t.push("  d "+z.alpha.toFixed(4)),t.push("  Tr 0.0000"),t.push("  Tf 1.0000 1.0000 1.0000"),t.push("  illum 2"),t.push("  Ka "+z.ambientColor.r.toFixed(4)+" "+z.ambientColor.g.toFixed(4)+" "+z.ambientColor.b.toFixed(4)),t.push("  Kd "+z.diffuseColor.r.toFixed(4)+" "+z.diffuseColor.g.toFixed(4)+" "+z.diffuseColor.b.toFixed(4)),t.push("  Ks "+z.specularColor.r.toFixed(4)+" "+z.specularColor.g.toFixed(4)+" "+z.specularColor.b.toFixed(4)),t.push("  Ke "+z.emissiveColor.r.toFixed(4)+" "+z.emissiveColor.g.toFixed(4)+" "+z.emissiveColor.b.toFixed(4));z.ambientTexture&&t.push("  map_Ka "+z.ambientTexture.name),z.diffuseTexture&&t.push("  map_Kd "+z.diffuseTexture.name),z.specularTexture&&t.push("  map_Ks "+z.specularTexture.name),z.bumpTexture&&t.push("  map_bump -imfchan z "+z.bumpTexture.name),z.opacityTexture&&t.push("  map_d "+z.opacityTexture.name);return t.join("\n")}}var p=0,C=z(11674);class Z{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const E in this.files){const t=this.files[E],z=new Blob([t],{type:(0,C.j)(E)});X.Tools.Download(z,E)}}}var H=z(11894),h=z(12224),d=z(12231),y=z(12247),O=z(11956),c=z(11667),a=z(11856),L=z(11834);const mE=L.HighestCommonFactor,W={...L,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:mE};var I=z(12044),e=z(11790),D=z(12279),S=z(12286),l=z(12036);const f=1e-6,K=new a.Dt(.04,.04,.04),F=1024,B=a.Dt.White(),b=a.Dt.Black();function x(E,t,z){if(t<K.r)return 0;const A=K.r,X=E*z/(1-K.r)+t-2*K.r,R=X*X-4*A*(K.r-t);return W.Clamp((-X+Math.sqrt(R))/(2*A),0,1)}function J(E){const t=E.diffuseColor.toLinearSpace(E.lE().getEngine().useExactSrgbConversions).scale(.5),z=E.alpha,X=function(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new A.Vector2(0,1),z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new A.Vector2(0,.1),X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new A.Vector2(0,.1),R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new A.Vector2(1300,.1);return function(E,t,z,A,X){return(1-E)*(1-E)*(1-E)*t+3*(1-E)*(1-E)*E*z+3*(1-E)*E*E*A+E*E*E*X}(Math.pow(E/R.x,.333333),t.y,z.y,X.y,R.y)}(W.Clamp(E.specularPower,0,F));return{baseColorFactor:[t.r,t.g,t.b,z],metallicFactor:0,roughnessFactor:X}}function V(E,t){t.needAlphaBlending()?E.alphaMode="BLEND":t.needAlphaTesting()&&(E.alphaMode="MASK",E.alphaCutoff=t.alphaCutOff)}function r(E,t,z){const A=new Uint8Array(E*t*4);for(let X=0;X<A.length;X+=4)A[X]=A[X+1]=A[X+2]=A[X+3]=255;return D.d.CreateRGBATexture(A,E,t,z)}function i(E){if(E instanceof Uint8Array){const t=E.length,z=new Float32Array(E.length);for(let A=0;A<t;++A)z[A]=E[A]/255;return z}if(E instanceof Float32Array)return E;throw new Error("Unsupported pixel format!")}class g{constructor(E){this._exporter=E,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(E){return E?this._textureMap.get(E)??null:null}async exportStandardMaterialAsync(E,t,z){const A=J(E),R={name:E.name};if(null==E.yp||E.yp||(E.twoSidedLighting||X.Tools.Warn(E.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),R.doubleSided=!0),z){const z=[],X=E.diffuseTexture;X&&z.push(this.exportTextureAsync(X,t).then((E=>{E&&(A.baseColorTexture=E)})));const u=E.bumpTexture;u&&z.push(this.exportTextureAsync(u,t).then((E=>{E&&(R.normalTexture=E,1!==u.level&&(R.normalTexture.scale=u.level))})));const p=E.emissiveTexture;p&&(R.emissiveFactor=[1,1,1],z.push(this.exportTextureAsync(p,t).then((E=>{E&&(R.emissiveTexture=E)}))));const C=E.ambientTexture;C&&z.push(this.exportTextureAsync(C,t).then((E=>{if(E){const t={index:E.index};R.occlusionTexture=t}}))),z.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(z))}(E.alpha<1||E.opacityTexture)&&(E.alphaMode===S.d.ALPHA_COMBINE?R.alphaMode="BLEND":X.Tools.Warn(E.name+": glTF 2.0 does not support alpha mode: "+E.alphaMode.toString())),E.emissiveColor&&!E.emissiveColor.equalsWithEpsilon(b,f)&&(R.emissiveFactor=E.emissiveColor.upE()),R.pbrMetallicRoughness=A,V(R,E),await this._finishMaterialAsync(R,E,t);const u=this._exporter._materials;return u.push(R),u.length-1}async _finishMaterialAsync(E,t,z){const A=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",E,t),X=[];for(const R of A)X.push(this.exportTextureAsync(R,z));await Promise.all(X),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",E,t)}async _getImageDataAsync(E,t,A,X){const R=S.d.TEXTURETYPE_UNSIGNED_BYTE,u=this._exporter._babylonScene,p=u.getEngine(),C=p.createRawTexture(E,t,A,S.d.TEXTUREFORMAT_RGBA,!1,!0,e.d.NEAREST_SAMPLINGMODE,null,R);p.isWebGPU?await z.e(51).then(z.bind(z,14242)):await z.e(52).then(z.bind(z,14245)),await I.l.ApplyPostProcess("pass",C,u,R,S.d.TEXTURE_NEAREST_SAMPLINGMODE,S.d.TEXTUREFORMAT_RGBA);const Z=await p._readTexturePixels(C,t,A);return await l.DumpTools.DumpDataAsync(t,A,Z,X,void 0,!0,!0)}_resizeTexturesToSameDimensions(E,t,z){const A=E?E.getSize():{width:0,height:0},X=t?t.getSize():{width:0,height:0};let R,u;return A.width<X.width?(R=E&&E instanceof e.d?I.l.CreateResizedCopy(E,X.width,X.height,!0):r(X.width,X.height,z),u=t):A.width>X.width?(u=t&&t instanceof e.d?I.l.CreateResizedCopy(t,A.width,A.height,!0):r(A.width,A.height,z),R=E):(R=E,u=t),{texture1:R,texture2:u}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(E,t,z,A){const X=new Array;if(!E&&!t)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const R=E?E.lE():t?t.lE():null;if(R){var u;const p=this._resizeTexturesToSameDimensions(E,t,R),C=null===(u=p.texture1)||void 0===u?void 0:u.getSize();let Z,H;const h=C.width,d=C.height,y=await p.texture1.readPixels(),O=await p.texture2.readPixels();if(!y)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(Z=i(y),!O)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");H=i(O);const c=H.byteLength,L=new Uint8Array(c),mE=new Uint8Array(c),W=4,I=b;let e=0,D=0;for(let E=0;E<d;++E)for(let t=0;t<h;++t){const A=(h*E+t)*W,X={diffuseColor:new a.Dt(Z[A],Z[A+1],Z[A+2]).toLinearSpace(R.getEngine().useExactSrgbConversions).multiply(z.diffuseColor),specularColor:new a.Dt(H[A],H[A+1],H[A+2]).toLinearSpace(R.getEngine().useExactSrgbConversions).multiply(z.specularColor),glossiness:H[A+3]*z.glossiness},u=this._convertSpecularGlossinessToMetallicRoughness(X);I.r=Math.max(I.r,u.baseColor.r),I.g=Math.max(I.g,u.baseColor.g),I.b=Math.max(I.b,u.baseColor.b),e=Math.max(e,u.metallic),D=Math.max(D,u.roughness),mE[A]=255*u.baseColor.r,mE[A+1]=255*u.baseColor.g,mE[A+2]=255*u.baseColor.b,mE[A+3]=p.texture1.pp?255*Z[A+3]:255,L[A]=0,L[A+1]=255*u.roughness,L[A+2]=255*u.metallic,L[A+3]=255}const S={baseColor:I,metallic:e,roughness:D};let l=!1,K=!1;for(let E=0;E<d;++E)for(let t=0;t<h;++t){const z=(h*E+t)*W;mE[z]/=S.baseColor.r>f?S.baseColor.r:1,mE[z+1]/=S.baseColor.g>f?S.baseColor.g:1,mE[z+2]/=S.baseColor.b>f?S.baseColor.b:1;const A=a.Dt.FromInts(mE[z],mE[z+1],mE[z+2]).toGammaSpace(R.getEngine().useExactSrgbConversions);mE[z]=255*A.r,mE[z+1]=255*A.g,mE[z+2]=255*A.b,A.equalsWithEpsilon(B,f)||(K=!0),L[z+1]/=S.roughness>f?S.roughness:1,L[z+2]/=S.metallic>f?S.metallic:1;a.Dt.FromInts(255,L[z+1],L[z+2]).equalsWithEpsilon(B,f)||(l=!0)}return l&&X.push(this._getImageDataAsync(L,h,d,A).then((E=>{S.metallicRoughnessTextureData=E}))),K&&X.push(this._getImageDataAsync(mE,h,d,A).then((E=>{S.baseColorTextureData=E}))),await Promise.all(X).then((()=>S))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(E){const t=this._getPerceivedBrightness(E.diffuseColor),z=this._getPerceivedBrightness(E.specularColor),A=1-this._getMaxComponent(E.specularColor),X=x(t,z,A),R=E.diffuseColor.scale(A/(1-K.r)/Math.max(1-X)),u=E.specularColor.Wt(K.scale(1-X)).scale(1/Math.max(X));let p=a.Dt.Lerp(R,u,X*X);p=p.clampToRef(0,1,p);return{baseColor:p,metallic:X,roughness:1-E.glossiness}}_getPerceivedBrightness(E){return E?Math.sqrt(.299*E.r*E.r+.587*E.g*E.g+.114*E.b*E.b):0}_getMaxComponent(E){return E?Math.max(E.r,Math.max(E.g,E.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(E,t,z,A){const X=[],R={baseColor:E._albedoColor,metallic:E._metallic,roughness:E._roughness};if(A){E._albedoTexture&&X.push(this.exportTextureAsync(E._albedoTexture,t).then((E=>{E&&(z.baseColorTexture=E)})));const A=E._metallicTexture;A&&X.push(this.exportTextureAsync(A,t).then((E=>{E&&(z.metallicRoughnessTexture=E)})))}return X.length>0&&(this._exporter._materialNeedsUVsSet.add(E),await Promise.all(X)),R}_getTextureSampler(E){const t={};if(!E||!(E instanceof e.d))return t;const z=this._getGLTFTextureWrapMode(E.wrapU);10497!==z&&(t.wrapS=z);const A=this._getGLTFTextureWrapMode(E.wrapV);switch(10497!==A&&(t.wrapT=A),E.samplingMode){case e.d.LINEAR_LINEAR:t.magFilter=9729,t.minFilter=9729;break;case e.d.LINEAR_NEAREST:t.magFilter=9729,t.minFilter=9728;break;case e.d.NEAREST_LINEAR:t.magFilter=9728,t.minFilter=9729;break;case e.d.NEAREST_LINEAR_MIPLINEAR:t.magFilter=9728,t.minFilter=9987;break;case e.d.NEAREST_NEAREST:t.magFilter=9728,t.minFilter=9728;break;case e.d.NEAREST_LINEAR_MIPNEAREST:t.magFilter=9728,t.minFilter=9985;break;case e.d.LINEAR_NEAREST_MIPNEAREST:t.magFilter=9729,t.minFilter=9984;break;case e.d.LINEAR_NEAREST_MIPLINEAR:t.magFilter=9729,t.minFilter=9986;break;case e.d.NEAREST_NEAREST_MIPLINEAR:t.magFilter=9728,t.minFilter=9986;break;case e.d.LINEAR_LINEAR_MIPLINEAR:t.magFilter=9729,t.minFilter=9987;break;case e.d.LINEAR_LINEAR_MIPNEAREST:t.magFilter=9729,t.minFilter=9985;break;case e.d.NEAREST_NEAREST_MIPNEAREST:t.magFilter=9728,t.minFilter=9984}return t}_getGLTFTextureWrapMode(E){switch(E){case e.d.WRAP_ADDRESSMODE:return 10497;case e.d.CLAMP_ADDRESSMODE:return 33071;case e.d.MIRROR_ADDRESSMODE:return 33648;default:return X.Tools.Error(`Unsupported Texture Wrap Mode ${E}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(E,t,z,A){const X={diffuseColor:E._albedoColor,specularColor:E._reflectivityColor,glossiness:E._microSurface},R=E._albedoTexture,u=E._reflectivityTexture,p=E._useMicroSurfaceFromReflectivityMapAlpha;if(u&&!p)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((R||u)&&A){this._exporter._materialNeedsUVsSet.add(E);const A=this._exportTextureSampler(R||u),p=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(R,u,X,t),C=this._exporter._textures;if(p.baseColorTextureData){const E=this._exportImage(`baseColor${C.length}`,t,p.baseColorTextureData);z.baseColorTexture=this._exportTextureInfo(E,A,null===R||void 0===R?void 0:R.coordinatesIndex)}if(p.metallicRoughnessTextureData){const E=this._exportImage(`metallicRoughness${C.length}`,t,p.metallicRoughnessTextureData);z.metallicRoughnessTexture=this._exportTextureInfo(E,A,null===u||void 0===u?void 0:u.coordinatesIndex)}return p}return this._convertSpecularGlossinessToMetallicRoughness(X)}async exportPBRMaterialAsync(E,t,z){const A={},X={name:E.name},R=E.isMetallicWorkflow();if(R){const t=E._albedoColor,z=E.alpha;t&&(A.baseColorFactor=[t.r,t.g,t.b,z])}const u=R?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(E,t,A,z):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(E,t,A,z);await this._setMetallicRoughnessPbrMaterialAsync(u,E,X,A,t,z),await this._finishMaterialAsync(X,E,t);const p=this._exporter._materials;return p.push(X),p.length-1}async _setMetallicRoughnessPbrMaterialAsync(E,t,z,A,R,u){if(V(z,t),E.baseColor.equalsWithEpsilon(B,f)&&W.WithinEpsilon(t.alpha,1,f)||(A.baseColorFactor=[E.baseColor.r,E.baseColor.g,E.baseColor.b,t.alpha]),null!=E.metallic&&1!==E.metallic&&(A.metallicFactor=E.metallic),null!=E.roughness&&1!==E.roughness&&(A.roughnessFactor=E.roughness),null==t.yp||t.yp||(t._twoSidedLighting||X.Tools.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),z.doubleSided=!0),u){const E=[],A=t._bumpTexture;A&&E.push(this.exportTextureAsync(A,R).then((E=>{E&&(z.normalTexture=E,1!==A.level&&(z.normalTexture.scale=A.level))})));const X=t._ambientTexture;X&&E.push(this.exportTextureAsync(X,R).then((E=>{if(E){const A={index:E.index,texCoord:E.texCoord,extensions:E.extensions};z.occlusionTexture=A;const X=t._ambientTextureStrength;X&&(A.strength=X)}})));const u=t._emissiveTexture;u&&E.push(this.exportTextureAsync(u,R).then((E=>{E&&(z.emissiveTexture=E)}))),E.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(E))}const p=t._emissiveColor;p.equalsWithEpsilon(b,f)||(z.emissiveFactor=p.upE()),z.pbrMetallicRoughness=A}_getPixelsFromTextureAsync(E){return function(E){switch(E){case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case S.d.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case S.d.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case S.d.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case S.d.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(E.textureFormat)?(0,I.i)(E,E._texture.width,E._texture.height):(E.textureType,S.d.TEXTURETYPE_UNSIGNED_BYTE,E.readPixels())}async exportTextureAsync(E,t){const z=this._exporter._extensionsPreExportTextureAsync("exporter",E,t);return z?await z.then((async z=>z?await this._exportTextureInfoAsync(z,t):await this._exportTextureInfoAsync(E,t))):await this._exportTextureInfoAsync(E,t)}async _exportTextureInfoAsync(E,t){let z=this._textureMap.get(E);if(!z){const A=await this._getPixelsFromTextureAsync(E);if(!A)return null;const R=this._exportTextureSampler(E),u=E.mimeType;if(u)switch(u){case"image/jpeg":case"image/png":case"image/webp":t=u;break;default:X.Tools.Warn(`Unsupported media type: ${u}. Exporting texture as PNG.`)}const p=this._internalTextureToImage,C=E.getInternalTexture().uniqueId;p[C]||(p[C]={});let Z=p[C][t];if(void 0===Z){const z=E.getSize();Z=(async()=>{const X=await this._getImageDataAsync(A,z.width,z.height,t);return this._exportImage(E.name,t,X)})(),p[C][t]=Z}z=this._exportTextureInfo(await Z,R,E.coordinatesIndex),this._textureMap.set(E,z),this._exporter._extensionsPostExportTextures("exporter",z,E)}return z}_exportImage(E,t,z){const A=this._exporter._images;let R;if(this._exporter._shouldUseGlb){R={name:E,mimeType:t,bufferView:void 0};const A=this._exporter._bufferManager.createBufferView(new Uint8Array(z));this._exporter._bufferManager.setBufferView(R,A)}else{const u=E.replace(/\.\/|\/|\.\\|\\/g,"_"),p=function(E){switch(E){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(t);let C=u+p;A.some((E=>E.uri===C))&&(C=`${u}_${X.Tools.RandomId()}${p}`),R={name:E,uri:C},this._exporter._imageData[C]={data:z,mimeType:t}}return A.push(R),A.length-1}_exportTextureInfo(E,t,z){const A=this._exporter._textures;let X=A.findIndex((z=>z.sampler==t&&z.source===E));-1===X&&(X=A.length,A.push({source:E,sampler:t}));const R={index:X};return z&&(R.texCoord=z),R}_exportTextureSampler(E){const t=this._getTextureSampler(E),z=this._exporter._samplers,A=z.findIndex((E=>E.minFilter===t.minFilter&&E.magFilter===t.magFilter&&E.wrapS===t.wrapS&&E.wrapT===t.wrapT));return-1!==A?A:(z.push(t),z.length-1)}}var o=z(11907),Q=z(11640),T=z(12295),q=z(11817);const M=A.Lt.Zero(),w=A.Quaternion.Identity(),n=A.Lt.One(),s=new A.Lt(-1,1,1);function j(E,t){const{byteOffset:z,byteStride:A,type:X,normalized:R}=E,u=E.getSize(),p=t.reduce(((E,t)=>t.getTotalVertices()>E?t.getTotalVertices():E),-Number.MAX_VALUE);return{byteOffset:z,byteStride:A,componentCount:u,type:X,count:p*u,normalized:R,totalVertices:p,kind:E.getKind()}}function U(E){switch(E){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function k(E){switch(E){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:case H.f.ColorKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return!0}return!1}function v(E){switch(E){case R.b.TriangleFillMode:return 4;case R.b.TriangleStripDrawMode:return 5;case R.b.TriangleFanDrawMode:return 6;case R.b.PointListDrawMode:case R.b.PointFillMode:return 0;case R.b.LineLoopDrawMode:return 2;case R.b.LineListDrawMode:return 1;case R.b.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${E}`)}function Y(E){const t=Math.sqrt(E.x*E.x+E.y*E.y+E.z*E.z);t>0&&(E.x/=t,E.y/=t,E.z/=t)}function G(E){return E.x*=-1,E}function N(E){if(E.x*E.x+E.y*E.y>.5){const t=Math.abs(E.x),z=Math.abs(E.y);if(t>z){const z=Math.sign(E.x);E.x=t,E.y*=-z,E.z*=-z,E.w*=z}else{const t=Math.sign(E.y);E.x*=-t,E.y=z,E.z*=t,E.w*=-t}}else{const t=Math.abs(E.z),z=Math.abs(E.w);if(t>z){const z=Math.sign(E.z);E.x*=-z,E.y*=z,E.z=t,E.w*=-z}else{const t=Math.sign(E.w);E.x*=t,E.y*=-t,E.z*=-t,E.w=z}}return E}function P(E){E.Op(-E.z,E.w,E.x,-E.y)}function EE(E,t){const z=A.Lt.FromArrayToRef(t.translation||[0,0,0],0,A.TmpVectors.Lt[0]),X=A.Quaternion.FromArrayToRef(t.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[0]),R=A.Matrix.ComposeToRef(n,X,z,A.TmpVectors.Matrix[0]),u=A.Lt.FromArrayToRef(E.translation||[0,0,0],0,A.TmpVectors.Lt[2]),p=A.Quaternion.FromArrayToRef(E.rotation||[0,0,0,1],0,A.TmpVectors.Quaternion[1]),C=A.Matrix.ComposeToRef(n,p,u,A.TmpVectors.Matrix[1]);R.multiplyToRef(C,C),C.decompose(void 0,X,z),z.equalsWithEpsilon(M,q.c)?delete t.translation:t.translation=z.upE(),X.equalsWithEpsilon(w,q.c)?delete t.rotation:t.rotation=X.upE(),t.scale&&delete t.scale}function tE(E,t){if(!(t instanceof h.d))return!1;if(!(1===t.getChildren().length&&0===E.getChildren().length&&E.parent===t))return!1;const z=E.lE(),A=E instanceof T.e&&!z.useRightHandedSystem?s:n;return!!t.cp.equalsWithEpsilon(A,q.c)||(Q.d.Warn(`Cannot collapse node ${E.name} into parent node ${t.name} with modified scaling.`),!1)}function zE(E){if(E instanceof Array){const t=new Float32Array(E);return new Uint8Array(t.buffer,t.byteOffset,t.byteLength)}return ArrayBuffer.isView(E)?new Uint8Array(E.buffer,E.byteOffset,E.byteLength):new Uint8Array(E)}function AE(E,t){for(const[z,A]of Object.entries(E)){const X=t[z];(Array.isArray(A)&&Array.isArray(X)&&XE(A,X)||A===X)&&delete E[z]}return E}function XE(E,t){return E.length===t.length&&E.every(((E,z)=>E===t[z]))}const RE=A.Matrix.Compose(new A.Lt(-1,1,1),A.Quaternion.Identity(),A.Lt.Zero());function uE(E,t){if(!(E instanceof h.d))return!1;if(t){if(!E.getWorldMatrix().equalsWithEpsilon(A.Matrix.IdentityReadOnly,q.c))return!1}else{if(!E.getWorldMatrix().multiplyToRef(RE,A.TmpVectors.Matrix[0]).equalsWithEpsilon(A.Matrix.IdentityReadOnly,q.c))return!1}return!(E instanceof d.d&&E.hp)}const pE=new Map([[Int8Array,(E,t,z)=>E.setInt8(t,z)],[Uint8Array,(E,t,z)=>E.setUint8(t,z)],[Uint8ClampedArray,(E,t,z)=>E.setUint8(t,z)],[Int16Array,(E,t,z)=>E.setInt16(t,z,!0)],[Uint16Array,(E,t,z)=>E.setUint16(t,z,!0)],[Int32Array,(E,t,z)=>E.setInt32(t,z,!0)],[Uint32Array,(E,t,z)=>E.setUint32(t,z,!0)],[Float32Array,(E,t,z)=>E.setFloat32(t,z,!0)],[Float64Array,(E,t,z)=>E.setFloat64(t,z,!0)]]);class CE{writeTypedArray(E){this._checkGrowBuffer(E.byteLength);const t=pE.get(E.constructor);for(let z=0;z<E.length;z++)t(this._dataView,this._byteOffset,E[z]),this._byteOffset+=E.BYTES_PER_ELEMENT}constructor(E){this._data=new Uint8Array(E),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(E){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,E),this._byteOffset++}writeInt8(E){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,E),this._byteOffset++}writeInt16(E){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,E,!0),this._byteOffset+=2}writeUInt16(E){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,E,!0),this._byteOffset+=2}writeInt32(E){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,E,!0),this._byteOffset+=4}writeUInt32(E){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat32(E){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,E,!0),this._byteOffset+=4}writeFloat64(E){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,E,!0),this._byteOffset+=8}_checkGrowBuffer(E){const t=this.byteOffset+E;if(t>this._data.byteLength){const E=new Uint8Array(2*t);E.set(this._data),this._data=E,this._dataView=new DataView(this._data.buffer)}}}function ZE(E){return E%4===0?4:E%2===0?2:1}class HE{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(E){let t=0;this._bufferViewToData.forEach((E=>{t+=E.byteLength}));const z=new CE(t),A=Array.from(this._bufferViewToData.keys()).sort(((E,t)=>ZE(t.byteLength)-ZE(E.byteLength)));for(const X of A){X.byteOffset=z.byteOffset,E.push(X);const t=E.length-1,A=this.getPropertiesWithBufferView(X);for(const E of A)E.bufferView=t;z.writeTypedArray(this._bufferViewToData.get(X)),this._bufferViewToData.delete(X)}return z.getOutputData()}createBufferView(E,t){const z={buffer:0,byteOffset:void 0,byteLength:E.byteLength,byteStride:t};return this._bufferViewToData.set(z,E),z}createAccessor(E,t,z,A,X,R,u){this._verifyBufferView(E);const p={bufferView:void 0,componentType:z,count:A,type:t,min:null===R||void 0===R?void 0:R.min,max:null===R||void 0===R?void 0:R.max,normalized:u,byteOffset:X};return this.setBufferView(p,E),this._accessorToBufferView.set(p,E),p}setBufferView(E,t){this._verifyBufferView(t);this.getPropertiesWithBufferView(t).push(E)}removeBufferView(E){const t=this.getPropertiesWithBufferView(E);for(const z of t)void 0!==z.bufferView&&delete z.bufferView;this._bufferViewToData.delete(E),this._bufferViewToProperties.delete(E),this._accessorToBufferView.forEach(((t,z)=>{t===E&&(void 0!==z.byteOffset&&delete z.byteOffset,this._accessorToBufferView.delete(z))}))}getBufferView(E){const t=this._accessorToBufferView.get(E);return this._verifyBufferView(t),t}getPropertiesWithBufferView(E){return this._verifyBufferView(E),this._bufferViewToProperties.set(E,this._bufferViewToProperties.get(E)??[]),this._bufferViewToProperties.get(E)}getData(E){return this._verifyBufferView(E),this._bufferViewToData.get(E)}_verifyBufferView(E){if(void 0===E||!this._bufferViewToData.has(E))throw new Error(`BufferView ${E} not found in BufferManager.`)}}var hE,dE=z(12256),yE=z(12272),OE=z(12304),cE=z(12175),aE=z(12342),LE=z(12355),mt=z(12250),WE=z(12361);!function(E){E[E.INTANGENT=0]="INTANGENT",E[E.OUTTANGENT=1]="OUTTANGENT"}(hE||(hE={}));class IE{static _IsTransformable(E){return E&&(E instanceof h.d||E instanceof dE.d||E instanceof WE.d)}static _CreateNodeAnimation(E,t,z,A,R){if(this._IsTransformable(E)){const u=[],p=[],C=t.getKeys(),Z=IE._CalculateMinMaxKeyFrames(C),H=IE._DeduceInterpolation(C,z,A),h=H.interpolationType,d=H.shouldBakeAnimation;if(d?IE._CreateBakedAnimation(E,t,z,Z.min,Z.max,t.framePerSecond,R,u,p,Z,A):"LINEAR"===h||"STEP"===h?IE._CreateLinearOrStepAnimation(E,t,z,u,p,A):"CUBICSPLINE"===h?IE._CreateCubicSplineAnimation(E,t,z,u,p,A):IE._CreateBakedAnimation(E,t,z,Z.min,Z.max,t.framePerSecond,R,u,p,Z,A),u.length&&p.length){return{inputs:u,outputs:p,samplerInterpolation:h,inputsMin:d?Z.min:X.Tools.FloatRound(Z.min/t.framePerSecond),inputsMax:d?Z.max:X.Tools.FloatRound(Z.max/t.framePerSecond)}}}return null}static _DeduceAnimationInfo(E){let t=null,z="VEC3",A=!1;const R=E.targetProperty.split(".");switch(R[0]){case"cp":t="scale";break;case"position":t="translation";break;case"rotation":z="VEC4",t="rotation";break;case"rotationQuaternion":z="VEC4",A=!0,t="rotation";break;case"influence":z="SCALAR",t="weights";break;default:X.Tools.Error(`Unsupported animatable property ${R[0]}`)}return t?{animationChannelTargetPath:t,dataAccessorType:z,useQuaternion:A}:(X.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(E,t,z,A,X,R,u,p,C,Z,H){let h;if(IE._IsTransformable(E)&&E.animations)for(const d of E.animations){if(H&&!H(d))continue;const X=IE._DeduceAnimationInfo(d);X&&(h={name:d.name,samplers:[],channels:[]},IE._AddAnimation(`${d.name}`,d.hasRunningRuntimeAnimations?t:h,E,d,X.dataAccessorType,X.animationChannelTargetPath,A,R,u,p,X.useQuaternion,C,Z),h.samplers.length&&h.channels.length&&z.push(h))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(E,t,z,A,X,R,u,p,C,Z,H){let h;if(E instanceof mt.e){const X=E.morphTargetManager;if(X)for(let d=0;d<X.numTargets;++d){const y=X.getTarget(d);for(const O of y.animations){if(H&&!H(O))continue;const y=new aE.c(`${O.name}`,"influence",O.framePerSecond,O.dataType,O.loopMode,O.enableBlending),c=[],a=O.getKeys();for(let E=0;E<a.length;++E){const t=a[E];for(let E=0;E<X.numTargets;++E)E==d?c.push(t):c.push({frame:t.frame,value:0})}y.setKeys(c);const L=IE._DeduceAnimationInfo(y);L&&(h={name:y.name,samplers:[],channels:[]},IE._AddAnimation(O.name,O.hasRunningRuntimeAnimations?t:h,E,y,L.dataAccessorType,L.animationChannelTargetPath,A,R,u,p,L.useQuaternion,C,Z,X.numTargets),h.samplers.length&&h.channels.length&&z.push(h))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(E,t,z,A,X,R,u,p,C){let Z;if(E.animationGroups){const h=E.animationGroups;for(const d of h){const h=new Map,y=new Map,O=new Set,c=d.to-d.from;Z={name:d.name,channels:[],samplers:[]};for(let t=0;t<d.targetedAnimations.length;++t){const c=d.targetedAnimations[t],a=c.target,L=c.animation;if(C&&!C(L))continue;const mE=p.has(a);if(this._IsTransformable(a)||1===a.length&&this._IsTransformable(a[0])){const E=IE._DeduceAnimationInfo(c.animation);if(E){const t=this._IsTransformable(a)?a:this._IsTransformable(a[0])?a[0]:null;t&&IE._AddAnimation(`${L.name}`,Z,t,L,E.dataAccessorType,E.animationChannelTargetPath,z,A,X,R,E.useQuaternion,u,mE)}}else if(a instanceof LE.c||1===a.length&&a[0]instanceof LE.c){if(IE._DeduceAnimationInfo(c.animation)){const t=a instanceof LE.c?a:a[0];if(t){const z=E.morphTargetManagers.find((E=>{for(let z=0;z<E.numTargets;++z)if(E.getTarget(z)===t)return!0;return!1}));if(z){const A=E.meshes.find((E=>E.morphTargetManager===z));var H;if(A)h.has(A)||h.set(A,new Map),null===(H=h.get(A))||void 0===H||H.set(t,L),O.add(A),y.set(A,L)}}}}}O.forEach((E=>{const t=E.morphTargetManager;let p=null;const C=[],H=y.get(E).getKeys(),O=H.length;for(let z=0;z<O;++z)for(let A=0;A<t.numTargets;++A){const X=t.getTarget(A),R=h.get(E);if(R){const t=R.get(X);t?(p||(p=new aE.c(`${d.name}_${E.name}_MorphWeightAnimation`,"influence",t.framePerSecond,aE.c.ANIMATIONTYPE_FLOAT,t.loopMode,t.enableBlending)),C.push(t.getKeys()[z])):C.push({frame:d.from+c/O*z,value:X.influence,inTangent:H[0].inTangent?0:void 0,outTangent:H[0].outTangent?0:void 0})}}p.setKeys(C);const a=IE._DeduceAnimationInfo(p);a&&IE._AddAnimation(`${d.name}_${E.name}_MorphWeightAnimation`,Z,E,p,a.dataAccessorType,a.animationChannelTargetPath,z,A,X,R,a.useQuaternion,u,!1,null===t||void 0===t?void 0:t.numTargets)})),Z.channels.length&&Z.samplers.length&&t.push(Z)}}}static _AddAnimation(E,t,z,X,R,u,p,C,Z,H,h,d,y,O){const c=IE._CreateNodeAnimation(z,X,u,h,d);let a,L,mE,W,I,e;if(c){if(O){let E=0,t=0;const z=[];for(;c.inputs.length>0;)t=c.inputs.shift(),E%O==0&&z.push(t),E++;c.inputs=z}const E=p.get(z),X=new Float32Array(c.inputs);a=C.createBufferView(X),L=C.createAccessor(a,"SCALAR",5126,c.inputs.length,void 0,{min:[c.inputsMin],max:[c.inputsMax]}),H.push(L),mE=H.length-1;const Z=new A.Quaternion,h=new A.Lt,d=new A.Lt,D=z instanceof dE.d,S=U(R),l=new Float32Array(c.outputs.length*S);c.outputs.forEach((function(E,t){let z=E;switch(u){case"translation":y&&(A.Lt.FromArrayToRef(E,0,d),G(d),d.toArray(z));break;case"rotation":4===E.length?A.Quaternion.FromArrayToRef(E,0,Z):(z=new Array(4),A.Lt.FromArrayToRef(E,0,h),A.Quaternion.FromEulerVectorToRef(h,Z)),y&&(N(Z),D&&P(Z)),Z.toArray(z)}l.set(z,t*S)})),a=C.createBufferView(l),L=C.createAccessor(a,R,5126,c.outputs.length),H.push(L),W=H.length-1,I={interpolation:c.samplerInterpolation,input:mE,output:W},t.samplers.push(I),e={sampler:t.samplers.length-1,target:{node:E,path:u}},t.channels.push(e)}}static _CreateBakedAnimation(E,t,z,R,u,p,C,Z,H,h,d){let y;const O=A.Quaternion.Identity();let c,a=null,L=null,mE=null,W=null,I=null,e=null;h.min=X.Tools.FloatRound(R/p);const D=t.getKeys();for(let A=0,S=D.length;A<S;++A){if(e=null,mE=D[A],A+1<S)if(W=D[A+1],mE.value.equals&&mE.value.equals(W.value)||mE.value===W.value){if(0!==A)continue;e=mE.frame}else e=W.frame;else{if(I=D[A-1],mE.value.equals&&mE.value.equals(I.value)||mE.value===I.value)continue;e=u}if(e)for(let A=mE.frame;A<=e;A+=C){if(c=X.Tools.FloatRound(A/p),c===a)continue;a=c,L=c;const R={key:0,repeatCount:0,loopMode:t.loopMode};y=t._interpolate(A,R),IE._SetInterpolatedValue(E,y,c,t,z,O,Z,H,d)}}L&&(h.max=L)}static _ConvertFactorToVector3OrQuaternion(E,t,z,R,u){const p=IE._GetBasePositionRotationOrScale(t,R,u),C=z.targetProperty.split("."),Z=C?C[1]:"",H=u?A.Quaternion.St(p).normalize():A.Lt.St(p);switch(Z){case"x":case"y":case"z":H[Z]=E;break;case"w":H.w=E;break;default:X.Tools.Error(`glTFAnimation: Unsupported component name "${Z}"!`)}return H}static _SetInterpolatedValue(E,t,z,X,R,u,p,C,Z){let H;p.push(z),"weights"!==R?(X.dataType===aE.c.ANIMATIONTYPE_FLOAT&&(t=this._ConvertFactorToVector3OrQuaternion(t,E,X,R,Z)),"rotation"===R?(Z?u=t:(H=t,A.Quaternion.RotationYawPitchRollToRef(H.y,H.x,H.z,u)),C.push(u.upE())):(H=t,C.push(H.upE()))):C.push([t])}static _CreateLinearOrStepAnimation(E,t,z,A,X,R){for(const u of t.getKeys())A.push(u.frame/t.framePerSecond),IE._AddKeyframeValue(u,t,X,z,E,R)}static _CreateCubicSplineAnimation(E,t,z,A,X,R){t.getKeys().forEach((function(u){A.push(u.frame/t.framePerSecond),IE._AddSplineTangent(hE.INTANGENT,X,z,"CUBICSPLINE",u,R),IE._AddKeyframeValue(u,t,X,z,E,R),IE._AddSplineTangent(hE.OUTTANGENT,X,z,"CUBICSPLINE",u,R)}))}static _GetBasePositionRotationOrScale(E,t,z){let X;if("rotation"===t)if(z){X=(E.rotationQuaternion??A.Quaternion.Identity()).upE()}else{X=(E.rotation??A.Lt.Zero()).upE()}else if("translation"===t){X=(E.position??A.Lt.Zero()).upE()}else{X=(E.cp??A.Lt.One()).upE()}return X}static _AddKeyframeValue(E,t,z,R,u,p){let C;const Z=t.dataType;if(Z===aE.c.ANIMATIONTYPE_VECTOR3){let t=E.value.upE();if("rotation"===R){const E=A.Lt.St(t);t=A.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).upE()}z.push(t)}else if(Z===aE.c.ANIMATIONTYPE_FLOAT){if("weights"===R)z.push([E.value]);else if(C=this._ConvertFactorToVector3OrQuaternion(E.value,u,t,R,p),C){if("rotation"===R){const E=p?C:A.Quaternion.RotationYawPitchRoll(C.y,C.x,C.z).normalize();z.push(E.upE())}z.push(C.upE())}}else Z===aE.c.ANIMATIONTYPE_QUATERNION?z.push(E.value.normalize().upE()):X.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(E,t,z){let A,X,R=!1;if("rotation"===t&&!z)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let u=0,p=E.length;u<p;++u)if(X=E[u],X.inTangent||X.outTangent)if(A){if("CUBICSPLINE"!==A){A="LINEAR",R=!0;break}}else A="CUBICSPLINE";else if(A){if("CUBICSPLINE"===A||X.interpolation&&1===X.interpolation&&"STEP"!==A){A="LINEAR",R=!0;break}}else A=X.interpolation&&1===X.interpolation?"STEP":"LINEAR";return A||(A="LINEAR"),{interpolationType:A,shouldBakeAnimation:R}}static _AddSplineTangent(E,t,z,X,R,u){let p;const C=E===hE.INTANGENT?R.inTangent:R.outTangent;if("CUBICSPLINE"===X){if("rotation"===z)if(C)if(u)p=C.upE();else{const E=C;p=A.Quaternion.RotationYawPitchRoll(E.y,E.x,E.z).upE()}else p=[0,0,0,0];else p="weights"===z?C?[C]:[0]:C?C.upE():[0,0,0];t.push(p)}}static _CalculateMinMaxKeyFrames(E){let t=1/0,z=-1/0;return E.forEach((function(E){t=Math.min(t,E.frame),z=Math.max(z,E.frame)})),{min:t,max:z}}}function eE(E,t,z,R,u,p){const C={attributes:{},influence:E.influence,name:E.name},Z=t.hp;if(!Z)return X.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),C;const h=p?-1:1,d=A.Lt.Zero();let y=0,O=0;if(E.hasPositions){const R=E.getPositions(),p=Z.getVerticesData(H.f.PositionKind);if(p){const E=new Float32Array(p.length),t=[1/0,1/0,1/0],X=[-1/0,-1/0,-1/0];O=p.length/3,y=0;for(let z=y;z<O;++z){const u=A.Lt.St(p,3*z);A.Lt.St(R,3*z).subtractToRef(u,d),d.x*=h,t[0]=Math.min(t[0],d.x),X[0]=Math.max(X[0],d.x),t[1]=Math.min(t[1],d.y),X[1]=Math.max(X[1],d.y),t[2]=Math.min(t[2],d.z),X[2]=Math.max(X[2],d.z),E[3*z]=d.x,E[3*z+1]=d.y,E[3*z+2]=d.z}const Z=z.createBufferView(E,12),H=z.createAccessor(Z,"VEC3",5126,R.length/3,0,{min:t,max:X});u.push(H),C.attributes.POSITION=u.length-1}else X.Tools.Warn(`Morph target positions for mesh ${t.name} were not exported. Mesh does not have position vertex data`)}if(E.hasNormals){const R=E.getNormals(),p=Z.getVerticesData(H.f.NormalKind);if(p){const E=new Float32Array(p.length);O=p.length/3,y=0;for(let z=y;z<O;++z){const t=A.Lt.St(p,3*z).normalize();A.Lt.St(R,3*z).normalize().subtractToRef(t,d),E[3*z]=d.x*h,E[3*z+1]=d.y,E[3*z+2]=d.z}const t=z.createBufferView(E,12),X=z.createAccessor(t,"VEC3",5126,R.length/3,0);u.push(X),C.attributes.NORMAL=u.length-1}else X.Tools.Warn(`Morph target normals for mesh ${t.name} were not exported. Mesh does not have normals vertex data`)}if(E.hasTangents){const R=E.getTangents(),p=Z.getVerticesData(H.f.TangentKind);if(p){O=p.length/4;const E=new Float32Array(3*O);y=0;for(let z=y;z<O;++z){const t=A.Lt.St(p,4*z);Y(t);const X=A.Lt.St(R,3*z);Y(X),X.subtractToRef(t,d),E[3*z]=d.x*h,E[3*z+1]=d.y,E[3*z+2]=d.z}const t=z.createBufferView(E,12),X=z.createAccessor(t,"VEC3",5126,O,0);u.push(X),C.attributes.TANGENT=u.length-1}else X.Tools.Warn(`Morph target tangents for mesh ${t.name} were not exported. Mesh does not have tangents vertex data`)}if(E.hasColors){const R=E.getColors(),p=Z.getVerticesData(H.f.ColorKind),h=Z.getVertexBuffer(H.f.ColorKind);if(p&&h){const E=h.getSize();O=p.length/E;const t=new Float32Array(O*E);y=0;for(let z=y;z<O;++z)if(3===E){const X=A.Lt.St(p,z*E);A.Lt.St(R,z*E).subtractToRef(X,d),t[3*z]=d.x,t[3*z+1]=d.y,t[3*z+2]=d.z}else if(4===E){const X=new A.Vector4,u=A.Vector4.St(p,z*E);A.Vector4.St(R,z*E).subtractToRef(u,X),t[4*z]=X.x,t[4*z+1]=X.y,t[4*z+2]=X.z,t[4*z+3]=X.w}else X.Tools.Warn(`Unsupported number of components for color attribute: ${E}`);const Z=z.createBufferView(t,4*E),H=z.createAccessor(Z,3===E?"VEC3":"VEC4",5126,O,0);u.push(H),C.attributes.COLOR_0=u.length-1}else X.Tools.Warn(`Morph target colors for mesh ${t.name} were not exported. Mesh does not have colors vertex data`)}return C}var DE=z(12369),SE=z(12205),lE=z(12190),fE=z(11766);class KE{}KE.DEFAULT_COLOR=a.Dt.White(),KE.DEFAULT_WIDTH_ATTENUATED=1,KE.DEFAULT_WIDTH=.1;var FE=z(12028),BE=z(12376);class bE{static ConvertPoints(E,t){if(E.length&&Array.isArray(E)&&"number"===typeof E[0])return[E];if(E.length&&Array.isArray(E[0])&&"number"===typeof E[0][0])return E;if(E.length&&!Array.isArray(E[0])&&E[0]instanceof A.Lt){const t=[];for(let z=0;z<E.length;z++){const A=E[z];t.push(A.x,A.y,A.z)}return[t]}if(E.length>0&&Array.isArray(E[0])&&E[0].length>0&&E[0][0]instanceof A.Lt){const t=[],z=E;for(const E of z)t.push(E.flatMap((E=>[E.x,E.y,E.z])));return t}if(E instanceof Float32Array){if(null!==t&&void 0!==t&&t.floatArrayStride){const z=[],A=3*t.floatArrayStride;for(let t=0;t<E.length;t+=A){const X=new Array(A);for(let z=0;z<A;z++)X[z]=E[t+z];z.push(X)}return z}return[Array.from(E)]}if(E.length&&E[0]instanceof Float32Array){const t=[];for(const z of E)t.push(Array.from(z));return t}return[]}static OmitZeroLengthPredicate(E,t,z){const A=[];return t.Wt(E).lengthSquared()>0&&A.push([E,t]),z.Wt(t).lengthSquared()>0&&A.push([t,z]),E.Wt(z).lengthSquared()>0&&A.push([z,E]),0===A.length?null:A}static OmitDuplicatesPredicate(E,t,z,A){const X=[];return bE._SearchInPoints(E,t,A)||X.push([E,t]),bE._SearchInPoints(t,z,A)||X.push([t,z]),bE._SearchInPoints(z,E,A)||X.push([z,E]),0===X.length?null:X}static _SearchInPoints(E,t,z){for(const u of z)for(let z=0;z<u.length;z++){var A,X,R;if(null!==(A=u[z])&&void 0!==A&&A.equals(E))if(null!==(X=u[z+1])&&void 0!==X&&X.equals(t)||null!==(R=u[z-1])&&void 0!==R&&R.equals(t))return!0}return!1}static MeshesToLines(E,t){const z=[];for(let X=0;X<E.length;X++){const R=E[X],u=R.getVerticesData(H.f.PositionKind),p=R.dp();if(u&&p)for(let E=0,C=0;E<p.length;E++){const Z=3*p[C++],H=3*p[C++],h=3*p[C++],d=new A.Lt(u[Z],u[Z+1],u[Z+2]),y=new A.Lt(u[H],u[H+1],u[H+2]),O=new A.Lt(u[h],u[h+1],u[h+2]);if(t){const A=t(d,y,O,z,E,Z,R,X,u,p);if(A)for(const E of A)z.push(E)}else z.push([d,y],[y,O],[O,d])}}return z}static ToVector3Array(E){if(Array.isArray(E[0])){const t=[],z=E;for(const E of z){const z=[];for(let t=0;t<E.length;t+=3)z.push(new A.Lt(E[t],E[t+1],E[t+2]));t.push(z)}return t}const t=E,z=[];for(let X=0;X<t.length;X+=3)z.push(new A.Lt(t[X],t[X+1],t[X+2]));return z}static ToNumberArray(E){return E.flatMap((E=>[E.x,E.y,E.z]))}static GetPointsCountInfo(E){const t=new Array(E.length);let z=0;for(let A=E.length;A--;)t[A]=E[A].length/3,z+=t[A];return{total:z,counts:t}}static GetLineLength(E){if(0===E.length)return 0;let t;t="number"===typeof E[0]?bE.ToVector3Array(E):E;const z=A.TmpVectors.Lt[0];let X=0;for(let A=0;A<t.length-1;A++){const E=t[A];X+=t[A+1].subtractToRef(E,z).length()}return X}static GetLineLengthArray(E){const t=new Float32Array(E.length/3);let z=0;for(let A=0,X=E.length/3-1;A<X;A++){let X=E[3*A+0],R=E[3*A+1],u=E[3*A+2];X-=E[3*A+3],R-=E[3*A+4],u-=E[3*A+5];z+=Math.sqrt(X*X+R*R+u*u),t[A+1]=z}return t}static SegmentizeSegmentByCount(E,t,z){const X=[],R=t.Wt(E),u=A.TmpVectors.Lt[0];u.ap(z);const p=A.TmpVectors.Lt[1];R.divideToRef(u,p);let C=E.clone();X.push(C);for(let A=0;A<z;A++)C=C.clone(),X.push(C.addInPlace(p));return X}static SegmentizeLineBySegmentLength(E,t){const z=E[0]instanceof A.Lt?bE.GetLineSegments(E):"number"===typeof E[0]?bE.GetLineSegments(bE.ToVector3Array(E)):E,X=[];for(const A of z)if(A.length>t){const E=bE.SegmentizeSegmentByCount(A.point1,A.point2,Math.ceil(A.length/t));for(const t of E)X.push(t)}else X.push(A.point1),X.push(A.point2);return X}static SegmentizeLineBySegmentCount(E,t){const z="number"===typeof E[0]?bE.ToVector3Array(E):E,A=bE.GetLineLength(z)/t;return bE.SegmentizeLineBySegmentLength(z,A)}static GetLineSegments(E){const t=[];for(let z=0;z<E.length-1;z++){const A=E[z],X=E[z+1],R=X.Wt(A).length();t.push({point1:A,point2:X,length:R})}return t}static GetMinMaxSegmentLength(E){const t=bE.GetLineSegments(E).sort((E=>E.length));return{min:t[0].length,max:t[t.length-1].length}}static GetPositionOnLineByVisibility(E,t,z){let X=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const R=t*z;let u=0,p=0;const C=E.length;for(let A=0;A<C;A++){if(R<=u+E[A].length){p=A;break}u+=E[A].length}const Z=(R-u)/E[p].length;return E[p].point2.subtractToRef(E[p].point1,A.TmpVectors.Lt[0]),A.TmpVectors.Lt[1]=A.TmpVectors.Lt[0].multiplyByFloats(Z,Z,Z),X||A.TmpVectors.Lt[1].addInPlace(E[p].point1),A.TmpVectors.Lt[1].clone()}static GetCircleLinePoints(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,X=arguments.length>3&&void 0!==arguments[3]?arguments[3]:E,R=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/t;const u=[];for(let p=0;p<=t;p++)u.push(new A.Lt(Math.cos(p*R)*E,Math.sin(p*R)*X,z));return u}static GetBezierLinePoints(E,t,z,A){return FE.c.CreateQuadraticBezier(E,t,z,A).getPoints().flatMap((E=>[E.x,E.y,E.z]))}static GetArrowCap(E,t,z,A,X){let R=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,u=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[E.clone(),E.add(t.multiplyByFloats(z,z,z))],widths:[A,X,R,u]}}static GetPointsFromText(E,t,z,A){let X=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,R=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const u=[],p=(0,BE.c)(E,t,z,A);for(const C of p){for(const E of C.paths){const t=[],z=E.getPoints();for(const E of z)t.push(E.x,E.y,X);u.push(t)}if(R)for(const E of C.holes){const t=[],z=E.getPoints();for(const E of z)t.push(E.x,E.y,X);u.push(t)}}return u}static Color3toRGBAUint8(E){const t=new Uint8Array(4*E.length);for(let z=0,A=0;z<E.length;z++)t[A++]=255*E[z].r,t[A++]=255*E[z].g,t[A++]=255*E[z].b,t[A++]=255;return t}static CreateColorsTexture(E,t,z,A){const X=A.getEngine().getCaps().maxTextureSize??1,R=t.length>X?X:t.length,u=Math.ceil(t.length/X);u>1&&(t=[...t,...Array(R*u-t.length).fill(t[0])]);const p=bE.Color3toRGBAUint8(t),C=new D.d(p,R,u,O.e.TEXTUREFORMAT_RGBA,A,!1,!0,z);return C.name=E,C}static PrepareEmptyColorsTexture(E){if(!KE.EmptyColorsTexture){const t=new Uint8Array(4);KE.EmptyColorsTexture=new D.d(t,1,1,O.e.TEXTUREFORMAT_RGBA,E,!1,!1,D.d.NEAREST_NEAREST),KE.EmptyColorsTexture.name="grlEmptyColorsTexture"}return KE.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var E;null===(E=KE.EmptyColorsTexture)||void 0===E||E.dispose(),KE.EmptyColorsTexture=null}static BooleanToNumber(E){return E?1:0}}class xE extends lE.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class JE extends SE.c{isCompatible(E){return!0}constructor(E,t,z){var X;z=z||{color:KE.DEFAULT_COLOR};const R=new xE;R.GREASED_LINE_HAS_COLOR=!!z.color&&!z.useColors,R.GREASED_LINE_SIZE_ATTENUATION=z.sizeAttenuation??!1,R.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===z.colorDistributionType,R.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(t??E.lE()).useRightHandedSystem,R.GREASED_LINE_CAMERA_FACING=z.cameraFacing??!0,super(E,JE.GREASED_LINE_MATERIAL_NAME,200,R,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(X=z)||void 0===X?void 0:X.forceGLSL)||JE.ForceGLSL,this._scene=t??E.lE(),this._engine=this._scene.getEngine(),this._cameraFacing=z.cameraFacing??!0,this.visibility=z.visibility??1,this.useDash=z.useDash??!1,this.dashRatio=z.dashRatio??.5,this.dashOffset=z.dashOffset??0,this.width=z.width?z.width:z.sizeAttenuation?KE.DEFAULT_WIDTH_ATTENUATED:KE.DEFAULT_WIDTH,this._sizeAttenuation=z.sizeAttenuation??!1,this.colorMode=z.colorMode??0,this._color=z.color??null,this.useColors=z.useColors??!1,this._colorsDistributionType=z.colorDistributionType??0,this.colorsSampling=z.colorsSampling??D.d.NEAREST_NEAREST,this._colors=z.BE??null,this.dashCount=z.dashCount??1,this.resolution=z.resolution??new A.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),z.colorsTexture?this.colorsTexture=z.colorsTexture:this._colors?this.colorsTexture=bE.CreateColorsTexture(`${E.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??KE.DEFAULT_COLOR,bE.PrepareEmptyColorsTexture(this._scene)),this._engine.IX.add((()=>{bE.DisposeEmptyColorsTexture()}))}getAttributes(E){E.push("grl_offsets"),E.push("grl_widths"),E.push("grl_colorPointers"),E.push("grl_counters"),this._cameraFacing?(E.push("grl_previousAndSide"),E.push("grl_nextAndCounters")):E.push("grl_slopes")}getSamplers(E){E.push("grl_colors")}getActiveTextures(E){this.colorsTexture&&E.push(this.colorsTexture)}getUniforms(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&t.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===E&&t.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:t,vertex:this._cameraFacing&&this._isGLSL(E)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(E)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(E){if(this._cameraFacing){E.Zp("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||E.Zp("viewProjection",this._scene.getTransformMatrix());const t=A.TmpVectors.Vector4[0];t.x=this._aspect,t.y=this._resolution.x,t.z=this._resolution.y,t.w=this.width,E.updateVector4("grl_aspect_resolution_lineWidth",t)}const t=A.TmpVectors.Vector4[0];t.x=bE.BooleanToNumber(this.useDash),t.y=this._dashArray,t.z=this.dashOffset,t.w=this.dashRatio,E.updateVector4("grl_dashOptions",t);const z=A.TmpVectors.Vector4[1];z.x=this.colorMode,z.y=this.visibility,z.z=this.colorsTexture?this.colorsTexture.getSize().width:0,z.w=bE.BooleanToNumber(this.useColors),E.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",z),this._color&&E.updateColor3("grl_singleColor",this._color);const X=this.colorsTexture??KE.EmptyColorsTexture;E.setTexture("grl_colors",X),E.updateFloat2("grl_textureSize",(null===X||void 0===X?void 0:X.getSize().width)??1,(null===X||void 0===X?void 0:X.getSize().height)??1)}prepareDefines(E,t,z){E.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,E.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,E.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,E.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=t.useRightHandedSystem,E.GREASED_LINE_CAMERA_FACING=this._cameraFacing,E.GREASED_LINE_USE_OFFSETS=!!z.offsets}getClassName(){return JE.GREASED_LINE_MATERIAL_NAME}getCustomCode(E){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(t)?function(E,t){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return t&&(E["!gl_Position\\=viewProjection\\*worldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(E,this._cameraFacing):function(E,t){if("vertex"===E){const E={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return t&&(E["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),E}return"fragment"===E?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(E,this._cameraFacing)}dispose(){var E;null===(E=this.colorsTexture)||void 0===E||E.dispose(),super.dispose()}get BE(){return this._colors}set BE(E){this.setColors(E)}setColors(E){var t;let z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(t=this._colors)||void 0===t?void 0:t.length)??0;var R;if(this._colors=E,null!==E&&0!==E.length){if(!z||A)if(this.colorsTexture&&X===E.length&&!A){const t=bE.Color3toRGBAUint8(E);this.colorsTexture.update(t)}else{var u;null===(u=this.colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=bE.CreateColorsTexture(`${this._material.name}-colors-texture`,E,this.colorsSampling,this._scene)}}else null===(R=this.colorsTexture)||void 0===R||R.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.markAllDefinesAsDirty()}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==E||null!==this._color&&null===E?(this._color=E,t||this.markAllDefinesAsDirty()):this._color=E}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(E){this._aspect=E.x/E.y,this._resolution=E}serialize(){const E=super.serialize(),t={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(t.BE=this._colors),this._color&&(t.color=this._color),E.greasedLineMaterialOptions=t,E}parse(E,t,z){var A;super.parse(E,t,z);const X=E.greasedLineMaterialOptions;null===(A=this.colorsTexture)||void 0===A||A.dispose(),X.color&&this.setColor(X.color,!0),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.BE&&(this.BE=X.BE),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),this.BE?this.colorsTexture=bE.CreateColorsTexture(`${this._material.name}-colors-texture`,this.BE,this.colorsSampling,t):bE.PrepareEmptyColorsTexture(t),this.markAllDefinesAsDirty()}copyTo(E){var t;const z=E;null===(t=z.colorsTexture)||void 0===t||t.dispose(),this._colors&&(z.colorsTexture=bE.CreateColorsTexture(`${z._material.name}-colors-texture`,this._colors,z.colorsSampling,this._scene)),z.setColor(this.color,!0),z.colorsDistributionType=this.colorsDistributionType,z.colorsSampling=this.colorsSampling,z.colorMode=this.colorMode,z.useColors=this.useColors,z.visibility=this.visibility,z.useDash=this.useDash,z.dashCount=this.dashCount,z.dashRatio=this.dashRatio,z.dashOffset=this.dashOffset,z.width=this.width,z.sizeAttenuation=this.sizeAttenuation,z.resolution=this.resolution,z.markAllDefinesAsDirty()}_isGLSL(E){return 0===E||this._forceGLSL}}JE.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",JE.ForceGLSL=!1,(0,fE.f)(`BABYLON.${JE.GREASED_LINE_MATERIAL_NAME}`,JE);var VE=z(12238),rE=z(11647),iE=z(12046),gE=z(11756);class oE extends iE.ShaderMaterial{constructor(E,t,X){const R=t.getEngine(),u=R.isWebGPU&&!(X.forceGLSL||oE.ForceGLSL),p=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];t.useRightHandedSystem&&p.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const C=["position","grl_widths","grl_offsets","grl_colorPointers"];X.cameraFacing?(p.push("GREASED_LINE_CAMERA_FACING"),C.push("grl_previousAndSide","grl_nextAndCounters")):(C.push("grl_slopes"),C.push("grl_counters"));const Z=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(u||Z.push("world","viewProjection","view","projection"),super(E,t,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:u?["Scene","Mesh"]:void 0,attributes:C,uniforms:Z,samplers:u?[]:["grlColors"],defines:p,extraInitializationsAsync:async()=>{u?await Promise.all([z.e(66).then(z.bind(z,14885)),z.e(75).then(z.bind(z,14889))]):await Promise.all([z.e(69).then(z.bind(z,14893)),z.e(76).then(z.bind(z,14900))])},shaderLanguage:u?1:0}),this._color=a.Dt.White(),this._colorsDistributionType=0,this._colorsTexture=null,X=X||{color:KE.DEFAULT_COLOR},this.visibility=X.visibility??1,this.useDash=X.useDash??!1,this.dashRatio=X.dashRatio??.5,this.dashOffset=X.dashOffset??0,this.dashCount=X.dashCount??1,this.width=X.width?X.width:X.sizeAttenuation&&X.cameraFacing?KE.DEFAULT_WIDTH_ATTENUATED:KE.DEFAULT_WIDTH,this.sizeAttenuation=X.sizeAttenuation??!1,this.color=X.color??a.Dt.White(),this.useColors=X.useColors??!1,this.colorsDistributionType=X.colorDistributionType??0,this.colorsSampling=X.colorsSampling??D.d.NEAREST_NEAREST,this.colorMode=X.colorMode??0,this._colors=X.BE??null,this._cameraFacing=X.cameraFacing??!0,this.resolution=X.resolution??new A.Vector2(R.getRenderWidth(),R.getRenderHeight()),X.colorsTexture?this.colorsTexture=X.colorsTexture:this._colors?this.colorsTexture=bE.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,t):(this._color=this._color??KE.DEFAULT_COLOR,this.colorsTexture=bE.PrepareEmptyColorsTexture(t)),u){const E=new gE.d;E.setParameters(),E.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",E)}R.IX.add((()=>{bE.DisposeEmptyColorsTexture()}))}dispose(){var E;null===(E=this._colorsTexture)||void 0===E||E.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new A.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get BE(){return this._colors}set BE(E){this.setColors(E)}setColors(E){var t;let z=arguments.length>1&&void 0!==arguments[1]&&arguments[1],A=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const X=(null===(t=this._colors)||void 0===t?void 0:t.length)??0;var R;if(this._colors=E,null!==E&&0!==E.length){if(!z||A)if(this._colorsTexture&&X===E.length&&!A){const t=bE.Color3toRGBAUint8(E);this._colorsTexture.update(t)}else{var u;null===(u=this._colorsTexture)||void 0===u||u.dispose(),this.colorsTexture=bE.CreateColorsTexture(`${this.name}-colors-texture`,E,this.colorsSampling,this.lE())}}else null===(R=this._colorsTexture)||void 0===R||R.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(E){this._colorsTexture=E,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(E){this._width=E,this.setFloat("grlWidth",E)}get useColors(){return this._useColors}set useColors(E){this._useColors=E,this.setFloat("grlUseColors",bE.BooleanToNumber(E))}get colorsSampling(){return this._colorsSampling}set colorsSampling(E){this._colorsSampling=E}get visibility(){return this._visibility}set visibility(E){this._visibility=E,this.setFloat("grlVisibility",E)}get useDash(){return this._useDash}set useDash(E){this._useDash=E,this.setFloat("grlUseDash",bE.BooleanToNumber(E))}get dashOffset(){return this._dashOffset}set dashOffset(E){this._dashOffset=E,this.setFloat("grlDashOffset",E)}get dashRatio(){return this._dashRatio}set dashRatio(E){this._dashRatio=E,this.setFloat("grlDashRatio",E)}get dashCount(){return this._dashCount}set dashCount(E){this._dashCount=E,this._dashArray=1/E,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(E){this._sizeAttenuation=E,this.setFloat("grlSizeAttenuation",bE.BooleanToNumber(E))}get color(){return this._color}set color(E){this.setColor(E)}setColor(E){E=E??KE.DEFAULT_COLOR,this._color=E,this.setColor3("grlColor",E)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(E){this._colorsDistributionType=E,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(E){this._colorMode=E,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(E){this._resolution=E,this.setVector2("grlResolution",E),this.setFloat("grlAspect",E.x/E.y)}serialize(){const E=super.serialize(),t={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(t.BE=this._colors),E.greasedLineMaterialOptions=t,E}parse(E,t,z){var A;const X=E.greasedLineMaterialOptions;null===(A=this._colorsTexture)||void 0===A||A.dispose(),X.color&&(this.color=X.color),X.colorDistributionType&&(this.colorsDistributionType=X.colorDistributionType),X.colorsSampling&&(this.colorsSampling=X.colorsSampling),X.colorMode&&(this.colorMode=X.colorMode),X.useColors&&(this.useColors=X.useColors),X.visibility&&(this.visibility=X.visibility),X.useDash&&(this.useDash=X.useDash),X.dashCount&&(this.dashCount=X.dashCount),X.dashRatio&&(this.dashRatio=X.dashRatio),X.dashOffset&&(this.dashOffset=X.dashOffset),X.width&&(this.width=X.width),X.sizeAttenuation&&(this.sizeAttenuation=X.sizeAttenuation),X.resolution&&(this.resolution=X.resolution),X.BE?this.colorsTexture=bE.CreateColorsTexture(`${this.name}-colors-texture`,X.BE,this.colorsSampling,this.lE()):this.colorsTexture=bE.PrepareEmptyColorsTexture(t),this._cameraFacing=X.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var QE,TE,qE;oE.ForceGLSL=!1,function(E){E[E.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",E[E.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(QE||(QE={})),function(E){E[E.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",E[E.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",E[E.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(TE||(TE={})),function(E){E[E.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",E[E.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",E[E.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",E[E.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",E[E.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(qE||(qE={}));class ME extends mt.e{constructor(E,t,z){super(E,t,null,null,!1,!1),this.name=E,this._options=z,this._lazy=!1,this._updatable=!1,this._engine=t.getEngine(),this._lazy=z.lazy??!1,this._updatable=z.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=z.colorPointers??[],this._widths=z.widths??new Array(z.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(E){let t=0;for(const A of this._points)t+=A.length;const z=t/3*2-this._widths.length;for(let A=0;A<z;A++)this._widths.push(E)}updateLazy(){var E,t;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(E=this._options.ribbonOptions)||void 0===E?void 0:E.smoothShading),!this.VE&&this.refreshBoundingInfo(),null===(t=this.greasedLineMaterial)||void 0===t||t.updateLazy()}addPoints(E,t){for(const z of E)this._points.push(z);this._lazy||this.setPoints(this._points,t)}dispose(E){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(E,t)}isLazy(){return this._lazy}get bE(){return this._uvs}set bE(E){this._uvs=E instanceof Float32Array?E:new Float32Array(E),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(E){this.material instanceof oE&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===E||void 0===E?void 0:E.length)>0),this._offsets=E,this._offsetsBuffer?this._offsetsBuffer.update(E):this._createOffsetsBuffer(E)}get widths(){return this._widths}set widths(E){this._widths=E,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(E)}get colorPointers(){return this._colorPointers}set colorPointers(E){this._colorPointers=E,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(E)}get greasedLineMaterial(){var E,t;if(this.material&&this.material instanceof oE)return this.material;const z=null===(E=this.material)||void 0===E||null===(t=E.pluginManager)||void 0===t?void 0:t.getPlugin(JE.GREASED_LINE_MATERIAL_NAME);return z||void 0}get points(){const E=[];return rE.d.DeepCopy(this._points,E),E}setPoints(E,t){this._points=bE.ConvertPoints(E,(null===t||void 0===t?void 0:t.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==t&&void 0!==t&&t.colorPointers||this._updateColorPointers(),this._setPoints(this._points,t)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,bE:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(E){super.serialize(E),E.type=this.getClassName(),E.lineOptions=this._createLineOptions()}_createVertexBuffers(){let E=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const t=new VE.c;return t.KE=this._vertexPositions,t.indices=this._indices,t.bE=this._uvs,E&&(t.FE=[],VE.c.ComputeNormals(this._vertexPositions,this._indices,t.FE)),t.JE(this,this._options.updatable),t}_createOffsetsBuffer(E){const t=this._scene.getEngine(),z=new H.b(t,E,this._updatable,3);this.setVerticesBuffer(z.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=z}}class wE{constructor(E,t){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=E,this.wasAddedByNoopNode=t}getIndicesAccessor(E,t,z,A,X){var R,u,p,C;return null===(R=this._indicesAccessorMap.get(E))||void 0===R||null===(u=R.get(t))||void 0===u||null===(p=u.get(z))||void 0===p||null===(C=p.get(A))||void 0===C?void 0:C.get(X)}setIndicesAccessor(E,t,z,A,X,R){let u=this._indicesAccessorMap.get(E);u||(u=new Map,this._indicesAccessorMap.set(E,u));let p=u.get(t);p||(p=new Map,u.set(t,p));let C=p.get(z);C||(C=new Map,p.set(z,C));let Z=C.get(A);Z||(Z=new Map,C.set(A,Z)),Z.set(X,R)}pushExportedNode(E){this._exportedNodes.has(E)||this._exportedNodes.add(E)}getNodesSet(){return this._exportedNodes}getVertexBufferView(E){return this._vertexBufferViewMap.get(E)}setVertexBufferView(E,t){this._vertexBufferViewMap.set(E,t)}setRemappedBufferView(E,t,z){this._remappedBufferView.set(E,new Map),this._remappedBufferView.get(E).set(t,z)}getRemappedBufferView(E,t){var z;return null===(z=this._remappedBufferView.get(E))||void 0===z?void 0:z.get(t)}getVertexAccessor(E,t,z){var A,X;return null===(A=this._vertexAccessorMap.get(E))||void 0===A||null===(X=A.get(t))||void 0===X?void 0:X.get(z)}setVertexAccessor(E,t,z,A){let X=this._vertexAccessorMap.get(E);X||(X=new Map,this._vertexAccessorMap.set(E,X));let R=X.get(t);R||(R=new Map,X.set(t,R)),R.set(z,A)}hasVertexColorAlpha(E){return this._vertexMapColorAlpha.get(E)||!1}setHasVertexColorAlpha(E,t){return this._vertexMapColorAlpha.set(E,t)}getMesh(E){return this._meshMap.get(E)}setMesh(E,t){this._meshMap.set(E,t)}bindMorphDataToMesh(E,t){const z=this._meshMorphTargetMap.get(E)||[];this._meshMorphTargetMap.set(E,z),-1===z.indexOf(t)&&z.push(t)}getMorphTargetsFromMesh(E){return this._meshMorphTargetMap.get(E)}}class nE{_ApplyExtension(E,t,z,A){if(z>=t.length)return Promise.resolve(E);const X=A(t[z],E);return X?X.then((async E=>E?await this._ApplyExtension(E,t,z+1,A):null)):this._ApplyExtension(E,t,z+1,A)}_ApplyExtensions(E,t){const z=[];for(const A of nE._ExtensionNames)z.push(this._extensions[A]);return this._ApplyExtension(E,z,0,t)}_extensionsPreExportTextureAsync(E,t,z){return this._ApplyExtensions(t,((t,A)=>t.preExportTextureAsync&&t.preExportTextureAsync(E,A,z)))}_extensionsPostExportNodeAsync(E,t,z,A,X){return this._ApplyExtensions(t,((t,R)=>t.postExportNodeAsync&&t.postExportNodeAsync(E,R,z,A,X,this._bufferManager)))}_extensionsPostExportMaterialAsync(E,t,z){return this._ApplyExtensions(t,((t,A)=>t.postExportMaterialAsync&&t.postExportMaterialAsync(E,A,z)))}_extensionsPostExportMaterialAdditionalTextures(E,t,z){const A=[];for(const X of nE._ExtensionNames){const R=this._extensions[X];R.postExportMaterialAdditionalTextures&&A.push(...R.postExportMaterialAdditionalTextures(E,t,z))}return A}_extensionsPostExportTextures(E,t,z){for(const A of nE._ExtensionNames){const X=this._extensions[A];X.postExportTexture&&X.postExportTexture(E,t,z)}}_extensionsPostExportMeshPrimitive(E){for(const t of nE._ExtensionNames){const z=this._extensions[t];z.postExportMeshPrimitive&&z.postExportMeshPrimitive(E,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const E of nE._ExtensionNames){const t=this._extensions[E];t.preGenerateBinaryAsync&&await t.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(E){for(const t of nE._ExtensionNames){const z=this._extensions[t];z.enabled&&E(z)}}_extensionsOnExporting(){this._forEachExtensions((E=>{var t,z,A;E.wasUsed&&((t=this._glTF).extensionsUsed||(t.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(E.name)&&this._glTF.extensionsUsed.push(E.name),E.required&&((z=this._glTF).extensionsRequired||(z.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(E.name)&&this._glTF.extensionsRequired.push(E.name)),(A=this._glTF).extensions||(A.extensions={}),E.onExporting&&E.onExporting())}))}_loadExtensions(){for(const E of nE._ExtensionNames){const t=nE._ExtensionFactories[E](this);this._extensions[E]=t}}constructor(){let E=arguments.length>0&&void 0!==arguments[0]?arguments[0]:c.d.LastCreatedScene,t=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${O.e.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new g(this),this._extensions={},this._bufferManager=new HE,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!E)throw new Error("No scene available to export");this._babylonScene=E,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:E=>{var t;return null===E||void 0===E||null===(t=E.zp)||void 0===t?void 0:t.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...t},this._loadExtensions()}dispose(){for(const E in this._extensions){this._extensions[E].dispose()}}get options(){return this._options}static RegisterExtension(E,t){nE.UnregisterExtension(E)&&X.Tools.Warn(`Extension with the name ${E} already exists`),nE._ExtensionFactories[E]=t,nE._ExtensionNames.push(E)}static UnregisterExtension(E){if(!nE._ExtensionFactories[E])return!1;delete nE._ExtensionFactories[E];const t=nE._ExtensionNames.indexOf(E);return-1!==t&&nE._ExtensionNames.splice(t,1),!0}_generateJSON(E,t,z){const A={byteLength:E};return A.byteLength&&(this._glTF.buffers=[A]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.It=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(A.uri=t+".bin"),z?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(E){const t=await this._generateBinaryAsync();this._extensionsOnExporting();const z=this._generateJSON(t.byteLength,E,!0),A=new Blob([t],{type:"application/octet-stream"}),X=E+".gltf",R=E+".bin",u=new Z;if(u.files[X]=z,u.files[R]=A,this._imageData)for(const p in this._imageData)u.files[p]=new Blob([this._imageData[p].data],{type:this._imageData[p].mimeType});return u}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(E){const t=E%4;return 0===t?t:4-t}async generateGLBAsync(E){this._shouldUseGlb=!0;const t=await this._generateBinaryAsync();this._extensionsOnExporting();const z=this._generateJSON(t.byteLength),A=E+".glb";let X,R=z.length;if("undefined"!==typeof TextEncoder){X=(new TextEncoder).encode(z),R=X.length}const u=this._getPadding(R),p=this._getPadding(t.byteLength),C=28+R+u+t.byteLength+p,H=new CE(C);if(H.writeUInt32(1179937895),H.writeUInt32(2),H.writeUInt32(C),H.writeUInt32(R+u),H.writeUInt32(1313821514),X)H.writeTypedArray(X);else{const E="_".charCodeAt(0);for(let t=0;t<R;++t){const A=z.charCodeAt(t);A!=z.codePointAt(t)?H.writeUInt8(E):H.writeUInt8(A)}}for(let Z=0;Z<u;++Z)H.writeUInt8(32);H.writeUInt32(t.byteLength+p),H.writeUInt32(5130562),H.writeTypedArray(t);for(let Z=0;Z<p;++Z)H.writeUInt8(0);const h=new Z;return h.files[A]=new Blob([H.getOutputData()],{type:"application/octet-stream"}),h}_setNodeTransformation(E,t,z){if(t.getPivotPoint().equalsWithEpsilon(M,q.c)||X.Tools.Warn("Pivot points are not supported in the glTF serializer"),!t.position.equalsWithEpsilon(M,q.c)){const X=A.TmpVectors.Lt[0].R(t.position);z&&G(X),E.translation=X.upE()}t.cp.equalsWithEpsilon(n,q.c)||(E.scale=t.cp.upE());const R=t.rotationQuaternion||A.Quaternion.FromEulerAngles(t.rotation.x,t.rotation.y,t.rotation.z);R.equalsWithEpsilon(w,q.c)||(z&&N(R),E.rotation=R.normalize().upE())}_setCameraTransformation(E,t,z){if(!t.position.equalsWithEpsilon(M,q.c)){const X=A.TmpVectors.Lt[0].R(t.position);z&&G(X),E.translation=X.upE()}const X=t.rotationQuaternion||A.Quaternion.FromEulerAngles(t.rotation.x,t.rotation.y,t.rotation.z);z&&N(X),this._babylonScene.useRightHandedSystem||P(X),X.equalsWithEpsilon(w,q.c)||(E.rotation=X.upE())}_listAvailableCameras(){for(const E of this._babylonScene.cameras){const t={type:E.mode===dE.d.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(E.name&&(t.name=E.name),"perspective"===t.type)t.perspective={aspectRatio:E.getEngine().getAspectRatio(E),yfov:E.fovMode===dE.d.FOVMODE_VERTICAL_FIXED?E.fov:E.fov*E.getEngine().getAspectRatio(E),znear:E.Cp,zfar:E.maxZ};else if("orthographic"===t.type){const z=E.orthoLeft&&E.orthoRight?.5*(E.orthoRight-E.orthoLeft):.5*E.getEngine().getRenderWidth(),A=E.orthoBottom&&E.orthoTop?.5*(E.orthoTop-E.orthoBottom):.5*E.getEngine().getRenderHeight();t.orthographic={xmag:z,ymag:A,znear:E.Cp,zfar:E.maxZ}}this._camerasMap.set(E,t)}}_exportAndAssignCameras(){const E=Array.from(this._camerasMap.values());for(const t of E){const E=this._nodesCameraMap.get(t);if(void 0!==E){this._cameras.push(t);for(const t of E)t.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const t={joints:[]};this._skinMap.set(E,t)}}_exportAndAssignSkeletons(){for(const E of this._babylonScene.skeletons){if(E.bones.length<=0)continue;const t=this._skinMap.get(E);if(void 0==t)continue;const z={},A=[];let R=-1;for(let X=0;X<E.bones.length;++X){const t=E.bones[X],A=t.getIndex()??X;-1!==A&&(z[A]=t,A>R&&(R=A))}for(let E=0;E<=R;++E){const R=z[E];A.push(R.getAbsoluteInverseBindMatrix());const u=R.getTransformNode();if(null!==u){const E=this._nodeMap.get(u);u&&null!==E&&void 0!==E?t.joints.push(E):X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else X.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const u=this._nodesSkinMap.get(t);if(t.joints.length>0&&void 0!==u){const E=64*A.length,z=new Float32Array(E/4);A.forEach(((E,t)=>{z.set(E.m,16*t)}));const X=this._bufferManager.createBufferView(z);this._accessors.push(this._bufferManager.createAccessor(X,"MAT4",5126,A.length)),t.inverseBindMatrices=this._accessors.length-1,this._skins.push(t);for(const t of u)t.skin=this._skins.length-1}}}async _exportSceneAsync(){const E={nodes:[]};if(this._babylonScene.metadata){const t=this._options.metadataSelector(this._babylonScene.metadata);t&&(E.extras=t)}const t=new Array,z=new Array,A=new Array;for(const p of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&uE(p,this._babylonScene.useRightHandedSystem)?A.push(...p.getChildren()):this._babylonScene.useRightHandedSystem?t.push(p):z.push(p);this._listAvailableCameras(),this._listAvailableSkeletons();const X=new wE(!0,!1);E.nodes.push(...await this._exportNodesAsync(z,X));const R=new wE(!1,!1);E.nodes.push(...await this._exportNodesAsync(t,R));const u=new wE(!1,!0);E.nodes.push(...await this._exportNodesAsync(A,u)),E.nodes.length&&this._scenes.push(E),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&IE._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,X.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(E){let t=this._shouldExportNodeMap.get(E);return void 0===t&&(t=this._options.shouldExportNode(E),this._shouldExportNodeMap.set(E,t)),t}async _exportNodesAsync(E,t){const z=new Array;this._exportBuffers(E,t);for(const A of E)await this._exportNodeAsync(A,z,t);return z}_collectBuffers(E,t,z,A,X){if(this._shouldExportNode(E)&&E instanceof d.d&&E.hp){const R=E.hp.getVertexBuffers();if(R)for(const A in R){if(!k(A))continue;const u=R[A];X.setHasVertexColorAlpha(u,E.hasVertexAlpha);const p=u._buffer,C=t.get(p)||[];t.set(p,C),-1===C.indexOf(u)&&C.push(u);const Z=z.get(u)||[];z.set(u,Z),-1===Z.indexOf(E)&&Z.push(E)}const u=E.morphTargetManager;if(u)for(let t=0;t<u.numTargets;t++){const z=u.getTarget(t),X=A.get(z)||[];A.set(z,X),-1===X.indexOf(E)&&X.push(E)}}for(const R of E.getChildren())this._collectBuffers(R,t,z,A,X)}_exportBuffers(E,t){const z=new Map,A=new Map,X=new Map;for(const p of E)this._collectBuffers(p,z,A,X,t);const R=Array.from(z.keys());for(const p of R){const E=p.getData();if(!E)throw new Error("Buffer data is not available");const X=z.get(p);if(!X)continue;const R=X[0].byteStride;if(X.some((E=>E.byteStride!==R)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const u=zE(E).slice();for(const t of X){const E=A.get(t),{byteOffset:z,byteStride:X,componentCount:R,type:p,count:C,normalized:Z,kind:h}=j(t,E);switch(h){case H.f.NormalKind:case H.f.TangentKind:(0,o.h)(u,z,X,R,p,C,Z,(E=>{const t=Math.sqrt(E[0]*E[0]+E[1]*E[1]+E[2]*E[2]);if(t>0){const z=1/t;E[0]*=z,E[1]*=z,E[2]*=z}}));break;case H.f.ColorKind:{const t=E.filter((E=>E.material instanceof cE.et||null==E.material)).length;if(0==t)break;if(t!=E.length){Q.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}p==H.f.UNSIGNED_BYTE&&Q.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const A=new a.Dt,h=new a.Lp,d=this._babylonScene.getEngine().useExactSrgbConversions;(0,o.h)(u,z,X,R,p,C,Z,(E=>{3===E.length?(A.Dz(E,0),A.toLinearSpaceToRef(A,d),A.toArray(E,0)):(h.Dz(E,0),h.toLinearSpaceToRef(h,d),h.toArray(E,0))}))}}}if(t.convertToRightHanded){for(const E of X){const t=A.get(E),{byteOffset:z,byteStride:X,componentCount:R,type:p,count:C,normalized:Z,kind:h}=j(E,t);switch(h){case H.f.PositionKind:case H.f.NormalKind:case H.f.TangentKind:(0,o.h)(u,z,X,R,p,C,Z,(E=>{E[0]=-E[0]}))}}t.convertedToRightHandedBuffers.set(p,u)}const C=this._bufferManager.createBufferView(u,R);t.setVertexBufferView(p,C);const Z=new Map;for(const t of X){const E=A.get(t),{kind:z,totalVertices:X}=j(t,E);switch(z){case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:if(t.type==H.f.FLOAT){const E=t.getFloatData(X);null!==E&&Z.set(t,E)}}}0!==Z.size&&Q.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const h=Array.from(Z.keys());for(const z of h){const E=Z.get(z);if(!E)continue;const A=E.some((E=>E>=256)),X=new(A?Uint16Array:Uint8Array)(E.length);for(let t=0;t<E.length;t++)X[t]=E[t];const R=this._bufferManager.createBufferView(X,4*(A?2:1));t.setRemappedBufferView(p,z,R)}}const u=Array.from(X.keys());for(const p of u){const E=X.get(p);if(!E)continue;const z=eE(p,E[0],this._bufferManager,this._bufferViews,this._accessors,t.convertToRightHanded);for(const A of E)t.bindMorphDataToMesh(A,z)}}async _exportNodeAsync(E,t,z){let A=this._nodeMap.get(E);if(void 0!==A)return void(t.includes(A)||t.push(A));const X=await this._createNodeAsync(E,z);if(X){A=this._nodes.length,this._nodes.push(X),this._nodeMap.set(E,A),z.pushExportedNode(E),t.push(A);const R={name:"runtime animations",channels:[],samplers:[]},u=[];this._babylonScene.animationGroups.length||(IE._CreateMorphTargetAnimationFromMorphTargetAnimations(E,R,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,z.convertToRightHanded,this._options.shouldExportAnimation),E.animations.length&&IE._CreateNodeAnimationFromNodeAnimations(E,R,u,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,z.convertToRightHanded,this._options.shouldExportAnimation)),R.channels.length&&R.samplers.length&&this._animations.push(R),u.forEach((E=>{E.channels.length&&E.samplers.length&&this._animations.push(E)}))}const R=X?[]:t;for(const u of E.getChildren())await this._exportNodeAsync(u,R,z);X&&R.length&&(X.children=R)}async _createNodeAsync(E,t){if(!this._shouldExportNode(E))return null;const z={};if(E.name&&(z.name=E.name),E.metadata){const t=this._options.metadataSelector(E.metadata);t&&(z.extras=t)}if(E instanceof h.d&&(this._setNodeTransformation(z,E,t.convertToRightHanded),E instanceof d.d)){const X=E instanceof y.c?E.sourceMesh:E;if(X.Rp&&X.Rp.length>0&&(z.mesh=await this._exportMeshAsync(X,t)),E.skeleton){const t=this._skinMap.get(E.skeleton);var A;if(void 0!==t)void 0===this._nodesSkinMap.get(t)&&this._nodesSkinMap.set(t,[]),null===(A=this._nodesSkinMap.get(t))||void 0===A||A.push(z)}}if(E instanceof T.e){const A=this._camerasMap.get(E);if(A){var X;void 0===this._nodesCameraMap.get(A)&&this._nodesCameraMap.set(A,[]),this._setCameraTransformation(z,E,t.convertToRightHanded);const u=E.parent;if(null!==u&&tE(E,u)){const E=this._nodeMap.get(u);if(void 0!==E){var R;const t=this._nodes[E];return EE(z,t),null===(R=this._nodesCameraMap.get(A))||void 0===R||R.push(t),null}}null===(X=this._nodesCameraMap.get(A))||void 0===X||X.push(z)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",z,E,this._nodeMap,t.convertToRightHanded)?z:(Q.d.Warn(`Not exporting node ${E.name}`),null)}_exportIndices(E,t,z,A,X,u,p,C,Z){let H=E;Z.mode=v(u);const h=p!==R.b.CounterClockWiseSideOrientation,d=!C.wasAddedByNoopNode&&h,y=function(E){switch(E){case R.b.TriangleFillMode:case R.b.TriangleStripDrawMode:case R.b.TriangleFanDrawMode:return!0}return!1}(u)&&d;if(y){if(u===R.b.TriangleStripDrawMode||u===R.b.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");Z.mode=v(u);const p=t?new Uint32Array(A):new Uint16Array(A);if(E)for(let t=0;t+2<A;t+=3)p[t]=E[z+t]+X,p[t+1]=E[z+t+2]+X,p[t+2]=E[z+t+1]+X;else for(let E=0;E+2<A;E+=3)p[E]=E,p[E+1]=E+2,p[E+2]=E+1;H=p}else if(E&&0!==X){const R=t?new Uint32Array(A):new Uint16Array(A);for(let t=0;t<A;t++)R[t]=E[z+t]+X;H=R}if(H){let R=C.getIndicesAccessor(E,z,A,X,y);if(void 0===R){const u=function(E,t,z,A){if(E instanceof Uint16Array||E instanceof Uint32Array)return E;if(E instanceof Int32Array)return new Uint32Array(E.buffer,E.byteOffset,E.length);const X=E.slice(t,t+z);return A?new Uint32Array(X):new Uint16Array(X)}(H,0,A,t),p=this._bufferManager.createBufferView(u),Z=t?5125:5123;this._accessors.push(this._bufferManager.createAccessor(p,"SCALAR",Z,A,0)),R=this._accessors.length-1,C.setIndicesAccessor(E,z,A,X,y,R)}Z.indices=R}}_exportVertexBuffer(E,t,z,A,X,R){const u=E.getKind();if(!k(u))return;if(u.startsWith("uv")&&!this._options.exportUnusedUVs&&(!t||!this._materialNeedsUVsSet.has(t)))return;let p=X.getVertexAccessor(E,z,A);if(void 0===p){const t=X.convertedToRightHandedBuffers.get(E._buffer)||E._buffer.getData(),R=u===H.f.PositionKind?function(E,t,z,A){const{byteOffset:X,byteStride:R,type:u,normalized:p}=t,C=t.getSize(),Z=new Array(C).fill(1/0),H=new Array(C).fill(-1/0);return(0,o.h)(E,X+z*R,R,C,u,A*C,p,(E=>{for(let t=0;t<C;t++)Z[t]=Math.min(Z[t],E[t]),H[t]=Math.max(H[t],E[t])})),{min:Z,max:H}}(t,E,z,A):void 0,C=(u===H.f.MatricesIndicesKind||u===H.f.MatricesIndicesExtraKind)&&E.type===H.f.FLOAT,Z=C?H.f.UNSIGNED_BYTE:E.type,h=C?void 0:E.normalized,d=C?X.getRemappedBufferView(E._buffer,E):X.getVertexBufferView(E._buffer),y=E.byteOffset+z*E.byteStride;this._accessors.push(this._bufferManager.createAccessor(d,function(E,t){if(E==H.f.ColorKind)return t?"VEC4":"VEC3";switch(E){case H.f.PositionKind:case H.f.NormalKind:return"VEC3";case H.f.TangentKind:case H.f.MatricesIndicesKind:case H.f.MatricesIndicesExtraKind:case H.f.MatricesWeightsKind:case H.f.MatricesWeightsExtraKind:return"VEC4";case H.f.UVKind:case H.f.UV2Kind:case H.f.UV3Kind:case H.f.UV4Kind:case H.f.UV5Kind:case H.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${E}`)}(u,X.hasVertexColorAlpha(E)),Z,A,y,R,h)),p=this._accessors.length-1,X.setVertexAccessor(E,z,A,p)}R.attributes[function(E){switch(E){case H.f.PositionKind:return"POSITION";case H.f.NormalKind:return"NORMAL";case H.f.TangentKind:return"TANGENT";case H.f.ColorKind:return"COLOR_0";case H.f.UVKind:return"TEXCOORD_0";case H.f.UV2Kind:return"TEXCOORD_1";case H.f.UV3Kind:return"TEXCOORD_2";case H.f.UV4Kind:return"TEXCOORD_3";case H.f.UV5Kind:return"TEXCOORD_4";case H.f.UV6Kind:return"TEXCOORD_5";case H.f.MatricesIndicesKind:return"JOINTS_0";case H.f.MatricesIndicesExtraKind:return"JOINTS_1";case H.f.MatricesWeightsKind:return"WEIGHTS_0";case H.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${E}`)}(u)]=p}async _exportMaterialAsync(E,t,z,A){let X=this._materialMap.get(E);if(void 0===X){const A=t&&Object.keys(t).some((E=>E.startsWith("uv")));if((E=E instanceof yE.d?E.mC[z.materialIndex]:E)instanceof OE.b)X=await this._materialExporter.exportPBRMaterialAsync(E,"image/png",A);else{if(!(E instanceof cE.et))return void Q.d.Warn(`Unsupported material '${E.name}' with type ${E.getClassName()}`);X=await this._materialExporter.exportStandardMaterialAsync(E,"image/png",A)}this._materialMap.set(E,X)}A.material=X}async _exportMeshAsync(E,t){var z;let A=t.getMesh(E);if(void 0!==A)return A;const X={primitives:[]};A=this._meshes.length,this._meshes.push(X),t.setMesh(E,A);const u=E.isUnIndexed?null:E.dp(),p=null===(z=E.hp)||void 0===z?void 0:z.getVertexBuffers(),C=t.getMorphTargetsFromMesh(E),Z=E instanceof DE.d,H=E instanceof ME,h=E.Rp;if(p&&h&&h.length>0)for(const O of h){const z={attributes:{}},A=O.oE()||this._babylonScene.defaultMaterial;if(H){var d,y;const t={name:A.name},X=E,R=a.Dt.White(),u=(null===(d=X.material)||void 0===d?void 0:d.alpha)??1,p=(null===(y=X.greasedLineMaterial)||void 0===y?void 0:y.color)??R;(!p.equalsWithEpsilon(R,q.c)||u<1)&&(t.pbrMetallicRoughness={baseColorFactor:[...p.upE(),u]}),this._materials.push(t),z.material=this._materials.length-1}else if(Z){const t={name:A.name},X=E;(!X.color.equalsWithEpsilon(a.Dt.White(),q.c)||X.alpha<1)&&(t.pbrMetallicRoughness={baseColorFactor:[...X.color.upE(),X.alpha]}),this._materials.push(t),z.material=this._materials.length-1}else await this._exportMaterialAsync(A,p,O,z);const h=Z||H?R.b.LineListDrawMode:E.overrideRenderingFillMode??A.fillMode,c=A._getEffectiveOrientation(E);this._exportIndices(u,u?(0,o.b)(u,O.indexCount,O.indexStart,O.verticesStart):O.verticesCount>65535,u?O.indexStart:O.verticesStart,u?O.indexCount:O.verticesCount,-O.verticesStart,h,c,t,z);for(const E of Object.values(p))this._exportVertexBuffer(E,A,O.verticesStart,O.verticesCount,t,z);if(C){z.targets=[];for(const E of C)z.targets.push(E.attributes)}X.primitives.push(z),this._extensionsPostExportMeshPrimitive(z)}if(C){X.weights=[],X.extras||(X.extras={}),X.extras.targetNames=[];for(const E of C)X.weights.push(E.influence),X.extras.targetNames.push(E.name)}return A}}nE._ExtensionNames=new Array,nE._ExtensionFactories={};class sE{static async GLTFAsync(E,t,z){z&&z.exportWithoutWaitingForScene||await E.whenReadyAsync();const A=new nE(E,z),X=await A.generateGLTFAsync(t.replace(/\.[^/.]+$/,""));return A.dispose(),X}static async GLBAsync(E,t,z){z&&z.exportWithoutWaitingForScene||await E.whenReadyAsync();const A=new nE(E,z),X=await A.generateGLBAsync(t.replace(/\.[^/.]+$/,""));return A.dispose(),X}}z(12389);const jE="EXT_mesh_gpu_instancing";class UE{constructor(E){this.name=jE,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(E,t,z,X,R,u){return await new Promise((E=>{if(t&&z instanceof mt.e&&z.hasThinInstances&&this._exporter){this._wasUsed=!0;const E=A.Lt.Zero(),X=A.Quaternion.Identity(),p=A.Lt.One(),C=z.thinInstanceGetWorldMatrices(),Z=A.TmpVectors.Lt[2],H=A.TmpVectors.Quaternion[1],h=A.TmpVectors.Lt[3];let d=!1,y=!1,O=!1;const c=new Float32Array(3*z.Wp),a=new Float32Array(4*z.Wp),L=new Float32Array(3*z.Wp);let mE=0;for(const t of C)t.decompose(h,H,Z),R&&(G(Z),N(H)),c.set(Z.upE(),3*mE),a.set(H.normalize().upE(),4*mE),L.set(h.upE(),3*mE),d=d||!Z.equalsWithEpsilon(E),y=y||!H.equalsWithEpsilon(X),O=O||!h.equalsWithEpsilon(p),mE++;const W={attributes:{}};d&&(W.attributes.TRANSLATION=this._buildAccessor(c,"VEC3",z.Wp,u)),y&&(W.attributes.ROTATION=this._buildAccessor(a,"VEC4",z.Wp,u)),O&&(W.attributes.SCALE=this._buildAccessor(L,"VEC3",z.Wp,u)),t.extensions=t.extensions||{},t.extensions[jE]=W}E(t)}))}_buildAccessor(E,t,z,A){const X=A.createBufferView(E),R=A.createAccessor(X,t,5126,z);return this._exporter._accessors.push(R),this._exporter._accessors.length-1}}nE.RegisterExtension(jE,(E=>new UE(E)));var kE=z(12392),vE=z(12406),YE=z(12415),GE=z(12422);function NE(E){return E===YE.c.PositionKind?"POSITION":E===YE.c.NormalKind?"NORMAL":E===YE.c.ColorKind?"COLOR":E.startsWith(YE.c.UVKind)?"TEX_COORD":"GENERIC"}const PE={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Et extends kE.c{static get DefaultAvailable(){return(0,kE.g)(Et.DefaultConfiguration)}static get Default(){return Et._Default??(Et._Default=new Et),Et._Default}static ResetDefault(E){Et._Default&&(E||Et._Default.dispose(),Et._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(E,t){return{module:await(t||DracoEncoderModule)({wasmBinary:E})}}_getWorkerContent(){return`${vE.g}(${vE.h})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Et.DefaultConfiguration)}async _encodeAsync(E,t,z){const A=z?(0,GE.e)(PE,z):PE;if(this._workerPoolPromise){const z=await this._workerPoolPromise;return await new Promise(((X,R)=>{z.push(((z,u)=>{const p=E=>{z.removeEventListener("error",p),z.removeEventListener("message",C),R(E),u()},C=E=>{"encodeMeshDone"===E.data.id&&(z.removeEventListener("error",p),z.removeEventListener("message",C),X(E.data.encodedMeshData),u())};z.addEventListener("error",p),z.addEventListener("message",C);const Z=[];for(const t of E)Z.push(t.data.buffer);t&&Z.push(t.buffer),z.postMessage({id:"encodeMesh",attributes:E,indices:t,options:A},Z)}))}))}if(this._modulePromise){const z=await this._modulePromise;return(0,vE.g)(z.module,E,t,A)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(E,t){if(0==E.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");E instanceof mt.e&&E.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===t||void 0===t?void 0:t.method)&&(Q.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),t.method="MESH_SEQUENTIAL_ENCODING");const z=function(E){let t=E.dp(void 0,!0);return!t||t instanceof Uint32Array||t instanceof Uint16Array||(t=((0,o.b)(t,t.length)?Uint32Array:Uint16Array).from(t)),t}(E),A=function(E,t){const z=[];for(const A of E.getVerticesDataKinds()){if(null!==t&&void 0!==t&&t.includes(A)){if(A===YE.c.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const X=E.getVertexBuffer(A),R=X.getSize(),u=(0,o.s)(X.getData(),R,X.type,X.byteOffset,X.byteStride,X.normalized,E.getTotalVertices(),!0);z.push({kind:A,dracoName:NE(A),size:R,data:u})}return z}(E,null===t||void 0===t?void 0:t.excludedAttributes);return await this._encodeAsync(A,z,t)}}Et.DefaultConfiguration={wasmUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${X.Tools._DefaultCdnUrl}/draco_encoder.js`},Et._Default=null;const tt="KHR_draco_mesh_compression";class zt{get wasUsed(){return this._wasUsed}constructor(E){this.name=tt,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===E.options.meshCompressionMethod&&Et.DefaultAvailable}dispose(){}postExportMeshPrimitive(E,t,z){if(!this.enabled)return;if(4!==E.mode&&5!==E.mode)return void Q.d.Warn("Cannot compress primitive with mode "+E.mode+".");const A=[],X=[];let R=null;if(void 0!==E.indices){const u=z[E.indices],p=t.getBufferView(u);R=t.getData(p).slice(),A.push(p),X.push(u)}const u=[];for(const[H,h]of Object.entries(E.attributes)){const E=z[h],R=t.getBufferView(E),C=U(E.type),Z=(0,o.s)(t.getData(R),C,E.componentType,E.byteOffset||0,R.byteStride||(0,o.m)(E.componentType)*C,E.normalized||!1,E.count,!0);u.push({kind:H,dracoName:(p=H,"POSITION"===p?"POSITION":"NORMAL"===p?"NORMAL":p.startsWith("COLOR")?"COLOR":p.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:U(E.type),data:Z}),A.push(R),X.push(E)}var p;const C={method:E.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},Z=Et.Default._encodeAsync(u,R,C).then((z=>{if(!z)return void Q.d.Error("Draco encoding failed for primitive.");const R={bufferView:-1,attributes:z.attributeIds},u=t.createBufferView(z.data);t.setBufferView(R,u);for(const E of A)this._bufferViewsUsed.add(E);for(const E of X)this._accessorsUsed.add(E);E.extensions||(E.extensions={}),E.extensions[tt]=R})).catch((E=>{Q.d.Error("Draco encoding failed for primitive: "+E)}));this._encodePromises.push(Z),this._wasUsed=!0}async preGenerateBinaryAsync(E){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((t=>{E.getPropertiesWithBufferView(t).every((E=>this._accessorsUsed.has(E)))&&E.removeBufferView(t)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}nE.RegisterExtension(tt,(E=>new zt(E)));var At=z(12424);const Xt="KHR_lights_punctual",Rt={name:"",color:[1,1,1],Ip:1,range:Number.MAX_VALUE},ut={innerConeAngle:0,outerConeAngle:Math.PI/4},pt=A.Lt.Backward();class Ct{constructor(E){this.name=Xt,this.enabled=!0,this.required=!1,this._exporter=E}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Xt]=this._lights}async postExportNodeAsync(E,t,z,X,R){return await new Promise((u=>{if(!(z instanceof WE.d))return void u(t);const p=z.getTypeID()==WE.d.LIGHTTYPEID_POINTLIGHT?"point":z.getTypeID()==WE.d.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":z.getTypeID()==WE.d.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!p||!(z instanceof At.c))return Q.d.Warn(`${E}: Light ${z.name} is not supported in ${Xt}`),void u(t);if(z.falloffType!==WE.d.FALLOFF_GLTF&&Q.d.Warn(`${E}: Light falloff for ${z.name} does not match the ${Xt} specification!`),!z.position.equalsToFloats(0,0,0)){const E=A.TmpVectors.Lt[0].R(z.position);R&&G(E),t.translation=E.upE()}if("point"!==p){const E=z.direction.normalizeToRef(A.TmpVectors.Lt[0]);R&&G(E);const X=A.Quaternion.FromUnitVectorsToRef(pt,E,A.TmpVectors.Quaternion[0]);A.Quaternion.IsIdentity(X)||(t.rotation=X.upE())}const C={type:p,name:z.name,color:z.ep.upE(),Ip:z.Ip,range:z.range};if(AE(C,Rt),"spot"===p){const E=z;C.spot={innerConeAngle:E.innerAngle/2,outerConeAngle:E.angle/2},AE(C.spot,ut)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(C);const Z={tz:this._lights.lights.length-1},H=z.parent;if(H&&tE(z,H)){const E=X.get(H);if(E){const z=this._exporter._nodes[E];return EE(t,z),z.extensions||(z.extensions={}),z.extensions[Xt]=Z,void u(null)}}t.extensions||(t.extensions={}),t.extensions[Xt]=Z,u(t)}))}}nE.RegisterExtension(Xt,(E=>new Ct(E)));var Zt=z(12324);const Ht="KHR_materials_anisotropy";class ht{constructor(E){this.name=Ht,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof Zt.d&&z.anisotropy.isEnabled&&!z.anisotropy.legacy?(z.anisotropy.texture&&A.push(z.anisotropy.texture),A):[]}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof Zt.d){if(!z.anisotropy.isEnabled||z.anisotropy.legacy)return void E(t);this._wasUsed=!0,t.extensions=t.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(z.anisotropy.texture),X={anisotropyStrength:z.anisotropy.Ip,anisotropyRotation:z.anisotropy.angle,anisotropyTexture:A??void 0};null!==X.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(z),t.extensions[Ht]=X}E(t)}))}}nE.RegisterExtension(Ht,(E=>new ht(E)));const dt="KHR_materials_clearcoat";class yt{constructor(E){this.name=dt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof Zt.d&&z.clearCoat.isEnabled?(z.clearCoat.texture&&A.push(z.clearCoat.texture),!z.clearCoat.useRoughnessFromMainTexture&&z.clearCoat.textureRoughness&&A.push(z.clearCoat.textureRoughness),z.clearCoat.bumpTexture&&A.push(z.clearCoat.bumpTexture),A):[]}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof Zt.d){if(!z.clearCoat.isEnabled)return void E(t);this._wasUsed=!0,t.extensions=t.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(z.clearCoat.texture);let R;R=z.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(z.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(z.clearCoat.textureRoughness),z.clearCoat.isTintEnabled&&X.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${z.name}`),z.clearCoat.remapF0OnInterfaceChange&&X.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${z.name}`);const u=this._exporter._materialExporter.getTextureInfo(z.clearCoat.bumpTexture),p={clearcoatFactor:z.clearCoat.Ip,clearcoatTexture:A??void 0,clearcoatRoughnessFactor:z.clearCoat.roughness,clearcoatRoughnessTexture:R??void 0,clearcoatNormalTexture:u??void 0};null===p.clearcoatTexture&&null===p.clearcoatRoughnessTexture&&null===p.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(z),t.extensions[dt]=p}E(t)}))}}nE.RegisterExtension(dt,(E=>new yt(E)));const Ot="KHR_materials_diffuse_transmission";function ct(E,t){const z=t.subSurface;let A=null;return z.translucencyIntensityTexture?A=z.translucencyIntensityTexture:z.thicknessTexture&&z.useMaskFromThicknessTexture&&(A=z.thicknessTexture),A&&!z.useGltfStyleTextures?(Q.d.Warn(`${E}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${t.name}`,1),null):A}class at{constructor(E){this.name=Ot,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];if(z instanceof OE.b&&this._isExtensionEnabled(z)){const t=ct(E,z);return t&&A.push(t),z.subSurface.translucencyColorTexture&&A.push(z.subSurface.translucencyColorTexture),A}return A}_isExtensionEnabled(E){if(E.unlit)return!1;const t=E.subSurface;return!!t.isTranslucencyEnabled&&(!E.unlit&&!t.useAlbedoToTintTranslucency&&t.useGltfStyleTextures&&1===t.volumeIndexOfRefraction&&0===t.minimumThickness&&0===t.maximumThickness)}postExportMaterialAsync(E,t,z){return new Promise((A=>{if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0;const A=z.subSurface,X=ct(E,z),R=0==A.translucencyIntensity?void 0:A.translucencyIntensity,u=this._exporter._materialExporter.getTextureInfo(X)??void 0,p=!A.translucencyColor||A.translucencyColor.equalsFloats(1,1,1)?void 0:A.translucencyColor.upE(),C=this._exporter._materialExporter.getTextureInfo(A.translucencyColorTexture)??void 0,Z={diffuseTransmissionFactor:R,diffuseTransmissionTexture:u,diffuseTransmissionColorFactor:p,diffuseTransmissionColorTexture:C};(u||C)&&this._exporter._materialNeedsUVsSet.add(z),t.extensions=t.extensions||{},t.extensions[Ot]=Z}A(t)}))}}nE.RegisterExtension(Ot,(E=>new at(E)));const Lt="KHR_materials_dispersion";class mz{constructor(){this.name=Lt,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){if(E.unlit)return!1;const t=E.subSurface;return!(!t.isRefractionEnabled&&!t.isDispersionEnabled)}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0;const E={dispersion:z.subSurface.dispersion};t.extensions=t.extensions||{},t.extensions[Lt]=E}E(t)}))}}nE.RegisterExtension(Lt,(()=>new mz));const Wt="KHR_materials_emissive_strength";class It{constructor(){this.name=Wt,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(E,t,z){return await new Promise((E=>{if(!(z instanceof OE.b))return E(t);const A=z.emissiveColor.upE(),X=Math.max(...A);if(X>1){this._wasUsed=!0,t.extensions||(t.extensions={});const E={emissiveStrength:X},A=z.emissiveColor.scale(1/E.emissiveStrength);t.emissiveFactor=A.upE(),t.extensions[Wt]=E}return E(t)}))}}nE.RegisterExtension(Wt,(E=>new It));const et="KHR_materials_ior";class Dt{constructor(){this.name=et,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.indexOfRefraction&&1.5!=E.indexOfRefraction)}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0;const E={ior:z.indexOfRefraction};t.extensions=t.extensions||{},t.extensions[et]=E}E(t)}))}}nE.RegisterExtension(et,(E=>new Dt));const St="KHR_materials_iridescence";class lt{constructor(E){this.name=St,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof Zt.d&&z.iridescence.isEnabled?(z.iridescence.texture&&A.push(z.iridescence.texture),z.iridescence.thicknessTexture&&z.iridescence.thicknessTexture!==z.iridescence.texture&&A.push(z.iridescence.thicknessTexture),A):[]}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof Zt.d){if(!z.iridescence.isEnabled)return void E(t);this._wasUsed=!0,t.extensions=t.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(z.iridescence.texture),X=this._exporter._materialExporter.getTextureInfo(z.iridescence.thicknessTexture),R={iridescenceFactor:z.iridescence.Ip,iridescenceIor:z.iridescence.indexOfRefraction,iridescenceThicknessMinimum:z.iridescence.minimumThickness,iridescenceThicknessMaximum:z.iridescence.maximumThickness,iridescenceTexture:A??void 0,iridescenceThicknessTexture:X??void 0};null===R.iridescenceTexture&&null===R.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(z),t.extensions[St]=R}E(t)}))}}nE.RegisterExtension(St,(E=>new lt(E)));const ft="KHR_materials_sheen";class Kt{constructor(E){this.name=ft,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){return z instanceof OE.b&&z.sheen.isEnabled&&z.sheen.texture?[z.sheen.texture]:[]}async postExportMaterialAsync(E,t,z){return await new Promise((E=>{if(z instanceof OE.b){if(!z.sheen.isEnabled)return void E(t);this._wasUsed=!0,null==t.extensions&&(t.extensions={});const A={sheenColorFactor:z.sheen.color.upE(),sheenRoughnessFactor:z.sheen.roughness??0};null===A.sheenColorTexture&&null===A.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(z),z.sheen.texture&&(A.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(z.sheen.texture)??void 0),z.sheen.textureRoughness&&!z.sheen.useRoughnessFromMainTexture?A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(z.sheen.textureRoughness)??void 0:z.sheen.texture&&z.sheen.useRoughnessFromMainTexture&&(A.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(z.sheen.texture)??void 0),t.extensions[ft]=A}E(t)}))}}nE.RegisterExtension(ft,(E=>new Kt(E)));const Ft="KHR_materials_specular";class Bt{constructor(E){this.name=Ft,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof OE.b&&this._isExtensionEnabled(z)?(z.metallicReflectanceTexture&&A.push(z.metallicReflectanceTexture),z.reflectanceTexture&&A.push(z.reflectanceTexture),A):A}_isExtensionEnabled(E){return!E.unlit&&(void 0!=E.metallicF0Factor&&1!=E.metallicF0Factor||void 0!=E.metallicReflectanceColor&&!E.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.metallicReflectanceTexture||null!=E.reflectanceTexture}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0,t.extensions=t.extensions||{};const E=this._exporter._materialExporter.getTextureInfo(z.metallicReflectanceTexture)??void 0,A=this._exporter._materialExporter.getTextureInfo(z.reflectanceTexture)??void 0,X={specularFactor:1==z.metallicF0Factor?void 0:z.metallicF0Factor,specularTexture:E,specularColorFactor:z.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:z.metallicReflectanceColor.upE(),specularColorTexture:A};this._hasTexturesExtension(z)&&this._exporter._materialNeedsUVsSet.add(z),t.extensions[Ft]=X}E(t)}))}}nE.RegisterExtension(Ft,(E=>new Bt(E)));const bt="KHR_materials_transmission";class xt{constructor(E){this.name=bt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof OE.b&&this._isExtensionEnabled(z)?(z.subSurface.thicknessTexture&&A.push(z.subSurface.thicknessTexture),A):A}_isExtensionEnabled(E){if(E.unlit)return!1;const t=E.subSurface;return t.isRefractionEnabled&&void 0!=t.refractionIntensity&&0!=t.refractionIntensity||this._hasTexturesExtension(E)}_hasTexturesExtension(E){return null!=E.subSurface.refractionIntensityTexture}async postExportMaterialAsync(E,t,z){if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0;const A=z.subSurface,X={transmissionFactor:0===A.refractionIntensity?void 0:A.refractionIntensity};if(this._hasTexturesExtension(z)&&this._exporter._materialNeedsUVsSet.add(z),A.refractionIntensityTexture)if(A.useGltfStyleTextures){const E=await this._exporter._materialExporter.exportTextureAsync(A.refractionIntensityTexture,"image/png");E&&(X.transmissionTexture=E)}else Q.d.Warn(`${E}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);t.extensions||(t.extensions={}),t.extensions[bt]=X}return t}}nE.RegisterExtension(bt,(E=>new xt(E)));const Jt="KHR_materials_unlit";class Vt{constructor(){this.name=Jt,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(E,t,z){return new Promise((E=>{let A=!1;z instanceof OE.b?A=z.unlit:z instanceof cE.et&&(A=z.disableLighting),A&&(this._wasUsed=!0,null==t.extensions&&(t.extensions={}),t.extensions[Jt]={}),E(t)}))}}nE.RegisterExtension(Jt,(()=>new Vt));const rt="KHR_materials_volume";class it{constructor(E){this.name=rt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof OE.b&&this._isExtensionEnabled(z)?(z.subSurface.thicknessTexture&&A.push(z.subSurface.thicknessTexture),A):A}_isExtensionEnabled(E){if(E.unlit)return!1;const t=E.subSurface;return!(!t.isRefractionEnabled&&!t.isTranslucencyEnabled)&&(void 0!=t.maximumThickness&&0!=t.maximumThickness||void 0!=t.tintColorAtDistance&&t.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=t.tintColor&&t.tintColor!=a.Dt.White()||this._hasTexturesExtension(E))}_hasTexturesExtension(E){return null!=E.subSurface.thicknessTexture}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof OE.b&&this._isExtensionEnabled(z)){this._wasUsed=!0;const E=z.subSurface,A={thicknessFactor:0==E.maximumThickness?void 0:E.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(E.thicknessTexture)??void 0,attenuationDistance:E.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:E.tintColorAtDistance,attenuationColor:E.tintColor.equalsFloats(1,1,1)?void 0:E.tintColor.upE()};this._hasTexturesExtension(z)&&this._exporter._materialNeedsUVsSet.add(z),t.extensions=t.extensions||{},t.extensions[rt]=A}E(t)}))}}nE.RegisterExtension(rt,(E=>new it(E)));const gt="EXT_materials_diffuse_roughness";class ot{constructor(E){this.name=gt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=E}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(E,t,z){const A=[];return z instanceof Zt.d&&z._baseDiffuseRoughness?(z._baseDiffuseRoughnessTexture&&A.push(z._baseDiffuseRoughnessTexture),A):[]}postExportMaterialAsync(E,t,z){return new Promise((E=>{if(z instanceof Zt.d){if(!z._baseDiffuseRoughness)return void E(t);this._wasUsed=!0,t.extensions=t.extensions||{};const A=this._exporter._materialExporter.getTextureInfo(z._baseDiffuseRoughnessTexture),X={diffuseRoughnessFactor:z._baseDiffuseRoughness,diffuseRoughnessTexture:A??void 0};null!==X.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(z),t.extensions[gt]=X}E(t)}))}}nE.RegisterExtension(gt,(E=>new ot(E)));const Qt="KHR_texture_transform";class Tt{constructor(){this.name=Qt,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(E,t,z){if(z.lE()||X.Tools.Warn(`${E}: /*@__KEY__*/"scene" is not defined for Babylon texture ${z.name}!`),(0!==z.uAng||0!==z.vAng)&&(X.Tools.Warn(`${E}: Texture ${z.name} with rotation in the u or v axis is not supported in glTF.`),0!==z.uRotationCenter||0!==z.vRotationCenter))return;const A={};let R=!1;if(0===z.uOffset&&0===z.vOffset||(A.offset=[z.uOffset,z.vOffset],R=!0),1===z.uScale&&1===z.vScale||(A.scale=[z.uScale,z.vScale],R=!0),0!==z.wAng){if(0!==z.uRotationCenter||0!==z.vRotationCenter){if(z.homogeneousRotationInUVTransform&&z.uScale!==z.vScale)return void X.Tools.Warn(`${E}: Texture ${z.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Qt}.`);X.Tools.Warn(`${E}: Texture ${z.name} with non-origin rotation center will be exported using an adjusted offset with ${Qt}.`),A.offset=function(E){const{uOffset:t,vOffset:z,uRotationCenter:A,vRotationCenter:X,uScale:R,vScale:u,wAng:p}=E,C=Math.cos(p),Z=Math.sin(p),H=A*R,h=X*u;return[t+(H*(1-C)+h*Z),z+(h*(1-C)-H*Z)]}(z)}A.rotation=-z.wAng,R=!0}0!==z.coordinatesIndex&&(A.texCoord=z.coordinatesIndex,R=!0),R&&(this._wasUsed=!0,t.extensions||(t.extensions={}),t.extensions[Qt]=A)}}nE.RegisterExtension(Qt,(()=>new Tt));class qt{static CreateSTL(E){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",X=arguments.length>3&&void 0!==arguments[3]&&arguments[3],R=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],u=arguments.length>5&&void 0!==arguments[5]&&arguments[5],p=arguments.length>6&&void 0!==arguments[6]&&arguments[6],C=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const Z=function(E,t,z){const X=[3*E[z],3*E[z+1],3*E[z+2]],R=[new A.Lt(t[X[0]],t[X[0]+2],t[X[0]+1]),new A.Lt(t[X[1]],t[X[1]+2],t[X[1]+1]),new A.Lt(t[X[2]],t[X[2]+2],t[X[2]+1])],u=R[0].Wt(R[1]),p=R[2].Wt(R[1]);return{v:R,n:A.Lt.Cross(p,u).normalize()}},h=function(E,t,z,A){return t=d(E,t,z.x,A),t=d(E,t,z.y,A),d(E,t,z.z,A)},d=function(E,t,z,A){return E.setFloat32(t,z,A),t+4},O=function(E){if(p){let t=E;E instanceof y.c&&(t=E.sourceMesh);const z=t.getVerticesData(H.f.PositionKind,!0,!0);if(!z)return[];const X=A.Lt.Zero();let R;for(R=0;R<z.length;R+=3)A.Lt.TransformCoordinatesFromFloatsToRef(z[R],z[R+1],z[R+2],E.Hp(!0),X).toArray(z,R);return z}return E.getVerticesData(H.f.PositionKind)||[]};p&&(u=!0);let c="",a=0,L=0;if(X){for(let z=0;z<E.length;z++){const t=E[z].dp();a+=t?t.length/3:0}const t=new ArrayBuffer(84+50*a);c=new DataView(t),L+=80,c.setUint32(L,a,R),L+=4}else C||(c="solid stlmesh\r\n");for(let A=0;A<E.length;A++){const t=E[A];!X&&C&&(c+="solid "+t.name+"\r\n"),!u&&t instanceof mt.e&&t.bakeCurrentTransformIntoVertices();const z=O(t),p=t.dp()||[];for(let E=0;E<p.length;E+=3){const t=Z(p,z,E);X?(L=h(c,L,t.n,R),L=h(c,L,t.v[0],R),L=h(c,L,t.v[1],R),L=h(c,L,t.v[2],R),L+=2):(c+="\tfacet normal "+t.n.x+" "+t.n.y+" "+t.n.z+"\r\n",c+="\t\touter loop\r\n",c+="\t\t\tvertex "+t.v[0].x+" "+t.v[0].y+" "+t.v[0].z+"\r\n",c+="\t\t\tvertex "+t.v[1].x+" "+t.v[1].y+" "+t.v[1].z+"\r\n",c+="\t\t\tvertex "+t.v[2].x+" "+t.v[2].y+" "+t.v[2].z+"\r\n",c+="\t\tendloop\r\n",c+="\tendfacet\r\n")}!X&&C&&(c+="endsolid "+name+"\r\n")}if(X||C||(c+="endsolid stlmesh"),t){const E=document.createElement("a"),t=new Blob([c],{type:"application/octet-stream"});E.href=window.URL.createObjectURL(t),E.download=z+".stl",E.click()}return c}}function Mt(E,t){let z=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const A=[];for(let X=0;X<E.length/z;X++){const R=E[X*z],u=E[X*z+1],p=E[X*z+2];A.push(`(${R.toPrecision(t.precision)}, ${u.toPrecision(t.precision)}, ${p.toPrecision(t.precision)})`)}return A.join(", ")}function wt(E,t){const z=[];for(let A=0;A<E.length/2;A++){const X=E[2*A],R=E[2*A+1];z.push(`(${X.toPrecision(t.precision)}, ${(1-R).toPrecision(t.precision)})`)}return z.join(", ")}function nt(E,t){const z=E.getVerticesData(H.f.PositionKind),A=E.getVerticesData(H.f.NormalKind);if(z&&A)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(E){var t;const z=null!==(t=E.dp())&&void 0!==t&&t.length?E.getTotalIndices():E.getTotalVertices();return Array(z/3).fill(3).join(", ")}(E)}]\n\t\tint[] faceVertexIndices = [${function(E){const t=E.dp(),z=[];if(null!==t)for(let A=0;A<t.length;A++)z.push(t[A]);else{const t=E.getTotalVertices();for(let E=0;E<t;E++)z.push(E)}return z.join(", ")}(E)}]\n\t\tnormal3f[] normals = [${Mt(A,t)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Mt(z,t)}]\n        ${function(E,t){let z="";for(let X=0;X<4;X++){const A=X>0?X:"",R=E.getVerticesData(H.f.UVKind+(A?A+1:""));R&&(z+=`\n\t\ttexCoord2f[] primvars:st${A} = [${wt(R,t)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const A=E.getVerticesData(H.f.ColorKind);return A&&(z+=`\n\tcolor3f[] primvars:displayColor = [${Mt(A,t,A.length/E.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),z}(E,t)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function st(E,t){return`\n        def "Geometry"\n        {\n        ${nt(E,t)}\n        }\n        `}function jt(E){let t='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return t+=E,fflate.strToU8(t)}function Ut(E){const t=E.m;return`( ${kt(t,0)}, ${kt(t,4)}, ${kt(t,8)}, ${kt(t,12)} )`}function kt(E,t){return`(${E[t+0]}, ${E[t+1]}, ${E[t+2]}, ${E[t+3]})`}function vt(E){const t="Object_"+E.uniqueId,z=function(E){const t=E.getWorldMatrix().clone(),z=E.lE().useRightHandedSystem;if(!z){let A=E.parent;for(;A;){if(uE(A,z)){t.multiplyToRef(A.getWorldMatrix().invert(),t);break}A=A.parent}}return t.determinant()<0&&X.Tools.Warn(`Exporting mesh ${E.name} with negative scale. Result may look incorrect in destination engine.`),t}(E),A=Ut(z);return`def Xform "${t}" (\n\tprepend references = @./geometries/Geometry_${E.hp.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${A}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${E.material.uniqueId}>\n}\n\n`}function Yt(E){switch(E){case S.d.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case S.d.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case S.d.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function Gt(E){return`(${E.x}, ${E.y})`}function Nt(E){return`(${E.r}, ${E.g}, ${E.b})`}function Pt(E,t,z,X,R,u){const p=E.getInternalTexture().uniqueId+"_"+E.invertY;R[p]=E;const C=E.coordinatesIndex>0?"st"+E.coordinatesIndex:"st",Z=new A.Vector2(E.uScale,E.vScale),H=new A.Vector2(E.uOffset,E.vOffset),h=E.wAng,d=Math.sin(h),y=Math.cos(h);return H.y=1-H.y-Z.y,H.x+=d*Z.x,H.y+=(1-y)*Z.y,`\n    def Shader "PrimvarReader_${z}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${C}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${z}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${t.uniqueId}/PrimvarReader_${z}.outputs:result>\n        float inputs:rotation = ${(h*(180/Math.PI)).toFixed(u.precision)}\n        float2 inputs:scale = ${Gt(Z)}\n        float2 inputs:translation = ${Gt(H)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${E.uniqueId}_${z}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${p}.png@\n        float2 inputs:st.connect = </Materials/Material_${t.uniqueId}/Transform2d_${z}.outputs:result>\n        ${X?"float4 inputs:scale = "+function(E){return`(${E.r}, ${E.g}, ${E.b}, 1.0)`}(X):""}\n        token inputs:sourceColorSpace = "${E.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Yt(E.wrapU)}"\n        token inputs:wrapT = "${Yt(E.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${t.needAlphaBlending()?"float outputs:a":""}\n    }`}function Ez(E,t,z){const A="\t\t\t",X=[],R=[],{diffuseMap:u,ep:p,alphaCutOff:C,emissiveMap:Z,emissive:H,normalMap:h,roughnessMap:d,roughnessChannel:y,roughness:O,metalnessMap:c,metalnessChannel:L,metalness:mE,aoMap:W,aoMapChannel:I,aoMapIntensity:e,alphaMap:D,ior:S,clearCoatEnabled:l,clearCoat:f,clearCoatMap:K,clearCoatRoughness:F,clearCoatRoughnessMap:B}=function(E){const t={diffuseMap:null,ep:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return E instanceof cE.et?{...t,diffuseMap:E.diffuseTexture,ep:E.diffuseColor,alphaCutOff:E.alphaCutOff,emissiveMap:E.emissiveTexture,emissive:E.emissiveColor,roughness:1,alphaMap:E.opacityTexture}:E instanceof Zt.d?{...t,diffuseMap:E._albedoTexture,ep:E._albedoColor,alphaCutOff:E._alphaCutOff,emissiveMap:E._emissiveTexture,emissive:E._emissiveColor,normalMap:E._bumpTexture,roughnessMap:E._metallicTexture,roughnessChannel:E._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:E._roughness??1,metalnessMap:E._metallicTexture,metalnessChannel:E._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:E._metallic??0,aoMap:E._ambientTexture,aoMapChannel:E._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:E._ambientTextureStrength,alphaMap:E._opacityTexture,ior:E.subSurface.indexOfRefraction,clearCoatEnabled:E.clearCoat.isEnabled,clearCoat:E.clearCoat.Ip,clearCoatMap:E.clearCoat.texture,clearCoatRoughness:E.clearCoat.roughness,clearCoatRoughnessMap:E.clearCoat.useRoughnessFromMainTexture?E.clearCoat.texture:E.clearCoat.textureRoughness}:t}(E);return null!==u?(X.push(`${A}color3f inputs:diffuseColor.connect = </Materials/Material_${E.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:rgb>`),E.needAlphaBlending()?X.push(`${A}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`):E.needAlphaTesting()&&(X.push(`${A}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${u.uniqueId}_diffuse.outputs:a>`),X.push(`${A}float inputs:opacityThreshold = ${C}`)),R.push(Pt(u,E,"diffuse",p,t,z))):X.push(`${A}color3f inputs:diffuseColor = ${Nt(p||a.Dt.White())}`),null!==Z?(X.push(`${A}color3f inputs:emissiveColor.connect = </Materials/Material_${E.uniqueId}/Texture_${Z.uniqueId}_emissive.outputs:rgb>`),R.push(Pt(Z,E,"emissive",H,t,z))):H&&H.toLuminance()>0&&X.push(`${A}color3f inputs:emissiveColor = ${Nt(H)}`),null!==h&&(X.push(`${A}normal3f inputs:normal.connect = </Materials/Material_${E.uniqueId}/Texture_${h.uniqueId}_normal.outputs:rgb>`),R.push(Pt(h,E,"normal",null,t,z))),null!==W&&(X.push(`${A}float inputs:occlusion.connect = </Materials/Material_${E.uniqueId}/Texture_${W.uniqueId}_occlusion.outputs:${I}>`),R.push(Pt(W,E,"occlusion",new a.Dt(e,e,e),t,z))),null!==d?(X.push(`${A}float inputs:roughness.connect = </Materials/Material_${E.uniqueId}/Texture_${d.uniqueId}_roughness.outputs:${y}>`),R.push(Pt(d,E,"roughness",new a.Dt(O,O,O),t,z))):X.push(`${A}float inputs:roughness = ${O}`),null!==c?(X.push(`${A}float inputs:metallic.connect = </Materials/Material_${E.uniqueId}/Texture_${c.uniqueId}_metallic.outputs:${L}>`),R.push(Pt(c,E,"metallic",new a.Dt(mE,mE,mE),t,z))):X.push(`${A}float inputs:metallic = ${mE}`),null!==D?(X.push(`${A}float inputs:opacity.connect = </Materials/Material_${E.uniqueId}/Texture_${D.uniqueId}_opacity.outputs:r>`),X.push(`${A}float inputs:opacityThreshold = 0.0001`),R.push(Pt(D,E,"opacity",null,t,z))):X.push(`${A}float inputs:opacity = ${E.alpha}`),l&&(null!==K?(X.push(`${A}float inputs:clearcoat.connect = </Materials/Material_${E.uniqueId}/Texture_${K.uniqueId}_clearcoat.outputs:r>`),R.push(Pt(K,E,"clearcoat",new a.Dt(f,f,f),t,z))):X.push(`${A}float inputs:clearcoat = ${f}`),null!==B?(X.push(`${A}float inputs:clearcoatRoughness.connect = </Materials/Material_${E.uniqueId}/Texture_${B.uniqueId}_clearcoatRoughness.outputs:g>`),R.push(Pt(B,E,"clearcoatRoughness",new a.Dt(F,F,F),t,z))):X.push(`${A}float inputs:clearcoatRoughness = ${F}`)),X.push(`${A}float inputs:ior = ${S}`),`\n\tdef Material "Material_${E.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${X.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${E.uniqueId}/PreviewSurface.outputs:surface>\n\n${R.join("\n")}\n\n\t}\n`}async function tz(E,t,z){const R={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...t};"undefined"===typeof fflate&&await X.Tools.LoadScriptAsync(R.fflateUrl);const u={};u[R.modelFileName]=null;let p='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';p+=function(E){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===E.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${E.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${E.planeAnchoringAlignment}"`:""}\n            `}(R);const C={};for(const A of E.meshes){if(0===A.getTotalVertices())continue;const E=A,t=E.hp,Z=E.material;if(!Z||!t||z&&!z(E))continue;if(-1!==["et","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(Z.getClassName())){const z="geometries/Geometry_"+t.uniqueId+".usda";if(!(z in u)){const E=st(t,R);u[z]=jt(E)}Z.uniqueId in C||(C[Z.uniqueId]=Z),p+=vt(E)}else X.Tools.Warn("USDZExportAsync does not support this material type: "+Z.getClassName())}E.activeCamera&&R.exportCamera&&(p+=function(E,t){const z="Camera_"+E.uniqueId,X=Ut(A.Matrix.RotationY(Math.PI).multiply(E.getWorldMatrix()));if(E.mode===S.d.ORTHOGRAPHIC_CAMERA)return`def Camera "${z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.Cp.toPrecision(t.precision)}, ${E.maxZ.toPrecision(t.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(E.orthoLeft||1)+Math.abs(E.orthoRight||1))).toPrecision(t.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(E.orthoTop||1)+Math.abs(E.orthoBottom||1))).toPrecision(t.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const A=E.getEngine().getAspectRatio(E),R=t.cameraSensorWidth||35;return`def Camera "${z}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${X}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${E.Cp.toPrecision(t.precision)}, ${E.maxZ.toPrecision(t.precision)})\n\t\t\tfloat focalLength = ${(R/(2*Math.tan(.5*E.fov))).toPrecision(t.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(R*A).toPrecision(t.precision)}\n\t\t\tfloat verticalAperture = ${(R/A).toPrecision(t.precision)}            \n\t\t}\n\t\n\t`}}(E.activeCamera,R)),p+="\n            }\n        }\n    }";const Z={};p+=function(E,t,z){const A=[];for(const X in E){const R=E[X];A.push(Ez(R,t,z))}return`\n    def "Materials"\n{\n${A.join("")}\n}\n\n`}(C,Z,R),u[R.modelFileName]=fflate.strToU8(p);for(const A in Z){const E=Z[A],t=E.getSize(),z=await E.readPixels();if(!z)throw new Error("Texture data is not available");const X=await l.DumpTools.DumpDataAsync(t.width,t.height,z,"image/png",void 0,!1,!0);u[`textures/Texture_${A}.png`]=new Uint8Array(X).slice()}let H=0;for(const A in u){const E=u[A];if(!E)continue;H+=34+A.length;const t=63&H;if(4!==t){const z=new Uint8Array(64-t);u[A]=[E,{extra:{12345:z}}]}H=E.length}return fflate.zipSync(u,{level:0})}}}]);