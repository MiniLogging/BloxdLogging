"use strict";(self.webpackChunkbloxd=self.webpackChunkbloxd||[]).push([[26],{11624:(Z,x,F)=>{F.r(x),F.d(x,{EXT_materials_diffuse_roughness:()=>Nx,EXT_mesh_gpu_instancing:()=>nZ,GLTF2Export:()=>gZ,GLTFData:()=>t,KHR_draco_mesh_compression:()=>Fx,KHR_lights_punctual:()=>dx,KHR_materials_anisotropy:()=>cx,KHR_materials_clearcoat:()=>Jx,KHR_materials_diffuse_transmission:()=>kx,KHR_materials_dispersion:()=>mx,KHR_materials_emissive_strength:()=>Lx,KHR_materials_ior:()=>Sx,KHR_materials_iridescence:()=>yx,KHR_materials_sheen:()=>Rx,KHR_materials_specular:()=>vx,KHR_materials_transmission:()=>ix,KHR_materials_unlit:()=>bx,KHR_materials_volume:()=>wx,KHR_texture_transform:()=>Ax,OBJExport:()=>Y,STLExport:()=>hx,USDZExportAsync:()=>xF,_ConvertToGLTFPBRMetallicRoughness:()=>e,_SolveMetallic:()=>i,__IGLTFExporterExtension:()=>j});var u=F(11179),G=F(10994),f=F(11523);class Y{static OBJ(Z,x,F,Y){const j=[];let d=1,t=1;x&&(F||(F="mat"),j.push("mtllib "+F+".mtl"));for(let o=0;o<Z.length;o++){const F=Z[o],c=F.name||`mesh${o}}`;j.push(`o ${c}`);let s=null;if(Y){const Z=F.Qf(!0);s=new u.Matrix,Z.invertToRef(s),F.bakeTransformIntoVertices(Z)}if(x){const Z=F.material;Z&&j.push("usemtl "+Z.id)}const J=F.af;if(!J){G.Tools.Warn("No geometry is present on the mesh");continue}const p=J.getVerticesData("position"),U=J.getVerticesData("normal"),k=J.getVerticesData("uv"),M=J.cj();let m=0,C=0;if(!p||!M){G.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const L=Z[0].KZ().useRightHandedSystem?1:-1;for(let Z=0;Z<p.length;Z+=3)j.push("v "+p[Z]*L+" "+p[Z+1]+" "+p[Z+2]),m++;if(null!=U)for(let Z=0;Z<U.length;Z+=3)j.push("vn "+U[Z]*L+" "+U[Z+1]+" "+U[Z+2]);if(null!=k)for(let Z=0;Z<k.length;Z+=2)j.push("vt "+k[Z]+" "+k[Z+1]),C++;const H=["","",""],S=(F.material||F.KZ().defaultMaterial)._getEffectiveOrientation(F),[K,y]=S===f.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let Z=0;Z<M.length;Z+=3){const x=[String(M[Z]+d),String(M[Z+K]+d),String(M[Z+y]+d)],F=[String(M[Z]+t),String(M[Z+K]+t),String(M[Z+y]+t)],u=x,G=null!=k?F:H,f=null!=U?x:H;j.push("f "+u[0]+"/"+G[0]+"/"+f[0]+" "+u[1]+"/"+G[1]+"/"+f[1]+" "+u[2]+"/"+G[2]+"/"+f[2])}Y&&s&&F.bakeTransformIntoVertices(s),d+=m,t+=C}return j.join("\n")}static MTL(Z){const x=[],F=Z.material;x.push("newmtl mat1"),x.push("  Ns "+F.specularPower.toFixed(4)),x.push("  Ni 1.5000"),x.push("  d "+F.alpha.toFixed(4)),x.push("  Tr 0.0000"),x.push("  Tf 1.0000 1.0000 1.0000"),x.push("  illum 2"),x.push("  Ka "+F.ambientColor.r.toFixed(4)+" "+F.ambientColor.g.toFixed(4)+" "+F.ambientColor.b.toFixed(4)),x.push("  Kd "+F.diffuseColor.r.toFixed(4)+" "+F.diffuseColor.g.toFixed(4)+" "+F.diffuseColor.b.toFixed(4)),x.push("  Ks "+F.specularColor.r.toFixed(4)+" "+F.specularColor.g.toFixed(4)+" "+F.specularColor.b.toFixed(4)),x.push("  Ke "+F.emissiveColor.r.toFixed(4)+" "+F.emissiveColor.g.toFixed(4)+" "+F.emissiveColor.b.toFixed(4));F.ambientTexture&&x.push("  map_Ka "+F.ambientTexture.name),F.diffuseTexture&&x.push("  map_Kd "+F.diffuseTexture.name),F.specularTexture&&x.push("  map_Ks "+F.specularTexture.name),F.bumpTexture&&x.push("  map_bump -imfchan z "+F.bumpTexture.name),F.opacityTexture&&x.push("  map_d "+F.opacityTexture.name);return x.join("\n")}}var j=0,d=F(11041);class t{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const Z in this.files){const x=this.files[Z],F=new Blob([x],{type:(0,d.g)(Z)});G.Tools.Download(F,Z)}}}var o=F(11265),c=F(11627),s=F(11642),J=F(11664),p=F(11319),U=F(11037),k=F(11230),M=F(11194);const m=M.HighestCommonFactor,C={...M,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:m};var L=F(11442),H=F(11157),S=F(11694),K=F(11697),y=F(11433);const q=1e-6,R=new k.Lx(.04,.04,.04),B=1024,v=k.Lx.White(),l=k.Lx.Black();function i(Z,x,F){if(x<R.r)return 0;const u=R.r,G=Z*F/(1-R.r)+x-2*R.r,f=G*G-4*u*(R.r-x);return C.Clamp((-G+Math.sqrt(f))/(2*u),0,1)}function e(Z){const x=Z.diffuseColor.toLinearSpace(Z.KZ().getEngine().useExactSrgbConversions).scale(.5),F=Z.alpha,G=function(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new u.Vector2(0,1),F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new u.Vector2(0,.1),G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new u.Vector2(0,.1),f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new u.Vector2(1300,.1);return function(Z,x,F,u,G){return(1-Z)*(1-Z)*(1-Z)*x+3*(1-Z)*(1-Z)*Z*F+3*(1-Z)*Z*Z*u+Z*Z*Z*G}(Math.pow(Z/f.x,.333333),x.y,F.y,G.y,f.y)}(C.Clamp(Z.specularPower,0,B));return{baseColorFactor:[x.r,x.g,x.b,F],metallicFactor:0,roughnessFactor:G}}function b(Z,x){x.needAlphaBlending()?Z.alphaMode="BLEND":x.needAlphaTesting()&&(Z.alphaMode="MASK",Z.alphaCutoff=x.alphaCutOff)}function E(Z,x,F){const u=new Uint8Array(Z*x*4);for(let G=0;G<u.length;G+=4)u[G]=u[G+1]=u[G+2]=u[G+3]=255;return S.d.CreateRGBATexture(u,Z,x,F)}function w(Z){if(Z instanceof Uint8Array){const x=Z.length,F=new Float32Array(Z.length);for(let u=0;u<x;++u)F[u]=Z[u]/255;return F}if(Z instanceof Float32Array)return Z;throw new Error("Unsupported pixel format!")}class T{constructor(Z){this._exporter=Z,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(Z){return Z?this._textureMap.get(Z)??null:null}async exportStandardMaterialAsync(Z,x,F){const u=e(Z),f={name:Z.name};if(null==Z.sj||Z.sj||(Z.twoSidedLighting||G.Tools.Warn(Z.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),f.doubleSided=!0),F){const F=[],G=Z.diffuseTexture;G&&F.push(this.exportTextureAsync(G,x).then((Z=>{Z&&(u.baseColorTexture=Z)})));const Y=Z.bumpTexture;Y&&F.push(this.exportTextureAsync(Y,x).then((Z=>{Z&&(f.normalTexture=Z,1!==Y.level&&(f.normalTexture.scale=Y.level))})));const j=Z.emissiveTexture;j&&(f.emissiveFactor=[1,1,1],F.push(this.exportTextureAsync(j,x).then((Z=>{Z&&(f.emissiveTexture=Z)}))));const d=Z.ambientTexture;d&&F.push(this.exportTextureAsync(d,x).then((Z=>{if(Z){const x={index:Z.index};f.occlusionTexture=x}}))),F.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(F))}(Z.alpha<1||Z.opacityTexture)&&(Z.alphaMode===K.e.ALPHA_COMBINE?f.alphaMode="BLEND":G.Tools.Warn(Z.name+": glTF 2.0 does not support alpha mode: "+Z.alphaMode.toString())),Z.emissiveColor&&!Z.emissiveColor.equalsWithEpsilon(l,q)&&(f.emissiveFactor=Z.emissiveColor.Wf()),f.pbrMetallicRoughness=u,b(f,Z),await this._finishMaterialAsync(f,Z,x);const Y=this._exporter._materials;return Y.push(f),Y.length-1}async _finishMaterialAsync(Z,x,F){const u=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",Z,x),G=[];for(const f of u)G.push(this.exportTextureAsync(f,F));await Promise.all(G),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",Z,x)}async _getImageDataAsync(Z,x,u,G){const f=K.e.TEXTURETYPE_UNSIGNED_BYTE,Y=this._exporter._babylonScene,j=Y.getEngine(),d=j.createRawTexture(Z,x,u,K.e.TEXTUREFORMAT_RGBA,!1,!0,H.c.NEAREST_SAMPLINGMODE,null,f);j.isWebGPU?await F.e(51).then(F.bind(F,13737)):await F.e(52).then(F.bind(F,13746)),await L.i.ApplyPostProcess("pass",d,Y,f,K.e.TEXTURE_NEAREST_SAMPLINGMODE,K.e.TEXTUREFORMAT_RGBA);const t=await j._readTexturePixels(d,x,u);return await y.DumpTools.DumpDataAsync(x,u,t,G,void 0,!0,!0)}_resizeTexturesToSameDimensions(Z,x,F){const u=Z?Z.getSize():{width:0,height:0},G=x?x.getSize():{width:0,height:0};let f,Y;return u.width<G.width?(f=Z&&Z instanceof H.c?L.i.CreateResizedCopy(Z,G.width,G.height,!0):E(G.width,G.height,F),Y=x):u.width>G.width?(Y=x&&x instanceof H.c?L.i.CreateResizedCopy(x,u.width,u.height,!0):E(u.width,u.height,F),f=Z):(f=Z,Y=x),{texture1:f,texture2:Y}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Z,x,F,u){const G=new Array;if(!Z&&!x)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const f=Z?Z.KZ():x?x.KZ():null;if(f){var Y;const j=this._resizeTexturesToSameDimensions(Z,x,f),d=null===(Y=j.texture1)||void 0===Y?void 0:Y.getSize();let t,o;const c=d.width,s=d.height,J=await j.texture1.readPixels(),p=await j.texture2.readPixels();if(!J)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(t=w(J),!p)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");o=w(p);const U=o.byteLength,M=new Uint8Array(U),m=new Uint8Array(U),C=4,L=l;let H=0,S=0;for(let Z=0;Z<s;++Z)for(let x=0;x<c;++x){const u=(c*Z+x)*C,G={diffuseColor:new k.Lx(t[u],t[u+1],t[u+2]).toLinearSpace(f.getEngine().useExactSrgbConversions).multiply(F.diffuseColor),specularColor:new k.Lx(o[u],o[u+1],o[u+2]).toLinearSpace(f.getEngine().useExactSrgbConversions).multiply(F.specularColor),glossiness:o[u+3]*F.glossiness},Y=this._convertSpecularGlossinessToMetallicRoughness(G);L.r=Math.max(L.r,Y.baseColor.r),L.g=Math.max(L.g,Y.baseColor.g),L.b=Math.max(L.b,Y.baseColor.b),H=Math.max(H,Y.metallic),S=Math.max(S,Y.roughness),m[u]=255*Y.baseColor.r,m[u+1]=255*Y.baseColor.g,m[u+2]=255*Y.baseColor.b,m[u+3]=j.texture1.Af?255*t[u+3]:255,M[u]=0,M[u+1]=255*Y.roughness,M[u+2]=255*Y.metallic,M[u+3]=255}const K={baseColor:L,metallic:H,roughness:S};let y=!1,R=!1;for(let Z=0;Z<s;++Z)for(let x=0;x<c;++x){const F=(c*Z+x)*C;m[F]/=K.baseColor.r>q?K.baseColor.r:1,m[F+1]/=K.baseColor.g>q?K.baseColor.g:1,m[F+2]/=K.baseColor.b>q?K.baseColor.b:1;const u=k.Lx.FromInts(m[F],m[F+1],m[F+2]).toGammaSpace(f.getEngine().useExactSrgbConversions);m[F]=255*u.r,m[F+1]=255*u.g,m[F+2]=255*u.b,u.equalsWithEpsilon(v,q)||(R=!0),M[F+1]/=K.roughness>q?K.roughness:1,M[F+2]/=K.metallic>q?K.metallic:1;k.Lx.FromInts(255,M[F+1],M[F+2]).equalsWithEpsilon(v,q)||(y=!0)}return y&&G.push(this._getImageDataAsync(M,c,s,u).then((Z=>{K.metallicRoughnessTextureData=Z}))),R&&G.push(this._getImageDataAsync(m,c,s,u).then((Z=>{K.baseColorTextureData=Z}))),await Promise.all(G).then((()=>K))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(Z){const x=this._getPerceivedBrightness(Z.diffuseColor),F=this._getPerceivedBrightness(Z.specularColor),u=1-this._getMaxComponent(Z.specularColor),G=i(x,F,u),f=Z.diffuseColor.scale(u/(1-R.r)/Math.max(1-G)),Y=Z.specularColor.Mx(R.scale(1-G)).scale(1/Math.max(G));let j=k.Lx.Lerp(f,Y,G*G);j=j.clampToRef(0,1,j);return{baseColor:j,metallic:G,roughness:1-Z.glossiness}}_getPerceivedBrightness(Z){return Z?Math.sqrt(.299*Z.r*Z.r+.587*Z.g*Z.g+.114*Z.b*Z.b):0}_getMaxComponent(Z){return Z?Math.max(Z.r,Math.max(Z.g,Z.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(Z,x,F,u){const G=[],f={baseColor:Z._albedoColor,metallic:Z._metallic,roughness:Z._roughness};if(u){Z._albedoTexture&&G.push(this.exportTextureAsync(Z._albedoTexture,x).then((Z=>{Z&&(F.baseColorTexture=Z)})));const u=Z._metallicTexture;u&&G.push(this.exportTextureAsync(u,x).then((Z=>{Z&&(F.metallicRoughnessTexture=Z)})))}return G.length>0&&(this._exporter._materialNeedsUVsSet.add(Z),await Promise.all(G)),f}_getTextureSampler(Z){const x={};if(!Z||!(Z instanceof H.c))return x;const F=this._getGLTFTextureWrapMode(Z.wrapU);10497!==F&&(x.wrapS=F);const u=this._getGLTFTextureWrapMode(Z.wrapV);switch(10497!==u&&(x.wrapT=u),Z.samplingMode){case H.c.LINEAR_LINEAR:x.magFilter=9729,x.minFilter=9729;break;case H.c.LINEAR_NEAREST:x.magFilter=9729,x.minFilter=9728;break;case H.c.NEAREST_LINEAR:x.magFilter=9728,x.minFilter=9729;break;case H.c.NEAREST_LINEAR_MIPLINEAR:x.magFilter=9728,x.minFilter=9987;break;case H.c.NEAREST_NEAREST:x.magFilter=9728,x.minFilter=9728;break;case H.c.NEAREST_LINEAR_MIPNEAREST:x.magFilter=9728,x.minFilter=9985;break;case H.c.LINEAR_NEAREST_MIPNEAREST:x.magFilter=9729,x.minFilter=9984;break;case H.c.LINEAR_NEAREST_MIPLINEAR:x.magFilter=9729,x.minFilter=9986;break;case H.c.NEAREST_NEAREST_MIPLINEAR:x.magFilter=9728,x.minFilter=9986;break;case H.c.LINEAR_LINEAR_MIPLINEAR:x.magFilter=9729,x.minFilter=9987;break;case H.c.LINEAR_LINEAR_MIPNEAREST:x.magFilter=9729,x.minFilter=9985;break;case H.c.NEAREST_NEAREST_MIPNEAREST:x.magFilter=9728,x.minFilter=9984}return x}_getGLTFTextureWrapMode(Z){switch(Z){case H.c.WRAP_ADDRESSMODE:return 10497;case H.c.CLAMP_ADDRESSMODE:return 33071;case H.c.MIRROR_ADDRESSMODE:return 33648;default:return G.Tools.Error(`Unsupported Texture Wrap Mode ${Z}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(Z,x,F,u){const G={diffuseColor:Z._albedoColor,specularColor:Z._reflectivityColor,glossiness:Z._microSurface},f=Z._albedoTexture,Y=Z._reflectivityTexture,j=Z._useMicroSurfaceFromReflectivityMapAlpha;if(Y&&!j)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((f||Y)&&u){this._exporter._materialNeedsUVsSet.add(Z);const u=this._exportTextureSampler(f||Y),j=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(f,Y,G,x),d=this._exporter._textures;if(j.baseColorTextureData){const Z=this._exportImage(`baseColor${d.length}`,x,j.baseColorTextureData);F.baseColorTexture=this._exportTextureInfo(Z,u,null===f||void 0===f?void 0:f.coordinatesIndex)}if(j.metallicRoughnessTextureData){const Z=this._exportImage(`metallicRoughness${d.length}`,x,j.metallicRoughnessTextureData);F.metallicRoughnessTexture=this._exportTextureInfo(Z,u,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}return j}return this._convertSpecularGlossinessToMetallicRoughness(G)}async exportPBRMaterialAsync(Z,x,F){const u={},G={name:Z.name},f=Z.isMetallicWorkflow();if(f){const x=Z._albedoColor,F=Z.alpha;x&&(u.baseColorFactor=[x.r,x.g,x.b,F])}const Y=f?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(Z,x,u,F):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(Z,x,u,F);await this._setMetallicRoughnessPbrMaterialAsync(Y,Z,G,u,x,F),await this._finishMaterialAsync(G,Z,x);const j=this._exporter._materials;return j.push(G),j.length-1}async _setMetallicRoughnessPbrMaterialAsync(Z,x,F,u,f,Y){if(b(F,x),Z.baseColor.equalsWithEpsilon(v,q)&&C.WithinEpsilon(x.alpha,1,q)||(u.baseColorFactor=[Z.baseColor.r,Z.baseColor.g,Z.baseColor.b,x.alpha]),null!=Z.metallic&&1!==Z.metallic&&(u.metallicFactor=Z.metallic),null!=Z.roughness&&1!==Z.roughness&&(u.roughnessFactor=Z.roughness),null==x.sj||x.sj||(x._twoSidedLighting||G.Tools.Warn(x.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),F.doubleSided=!0),Y){const Z=[],u=x._bumpTexture;u&&Z.push(this.exportTextureAsync(u,f).then((Z=>{Z&&(F.normalTexture=Z,1!==u.level&&(F.normalTexture.scale=u.level))})));const G=x._ambientTexture;G&&Z.push(this.exportTextureAsync(G,f).then((Z=>{if(Z){const u={index:Z.index,texCoord:Z.texCoord,extensions:Z.extensions};F.occlusionTexture=u;const G=x._ambientTextureStrength;G&&(u.strength=G)}})));const Y=x._emissiveTexture;Y&&Z.push(this.exportTextureAsync(Y,f).then((Z=>{Z&&(F.emissiveTexture=Z)}))),Z.length>0&&(this._exporter._materialNeedsUVsSet.add(x),await Promise.all(Z))}const j=x._emissiveColor;j.equalsWithEpsilon(l,q)||(F.emissiveFactor=j.Wf()),F.pbrMetallicRoughness=u}_getPixelsFromTextureAsync(Z){return function(Z){switch(Z){case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case K.e.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case K.e.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case K.e.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case K.e.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(Z.textureFormat)?(0,L.f)(Z,Z._texture.width,Z._texture.height):(Z.textureType,K.e.TEXTURETYPE_UNSIGNED_BYTE,Z.readPixels())}async exportTextureAsync(Z,x){const F=this._exporter._extensionsPreExportTextureAsync("exporter",Z,x);return F?await F.then((async F=>F?await this._exportTextureInfoAsync(F,x):await this._exportTextureInfoAsync(Z,x))):await this._exportTextureInfoAsync(Z,x)}async _exportTextureInfoAsync(Z,x){let F=this._textureMap.get(Z);if(!F){const u=await this._getPixelsFromTextureAsync(Z);if(!u)return null;const f=this._exportTextureSampler(Z),Y=Z.mimeType;if(Y)switch(Y){case"image/jpeg":case"image/png":case"image/webp":x=Y;break;default:G.Tools.Warn(`Unsupported media type: ${Y}. Exporting texture as PNG.`)}const j=this._internalTextureToImage,d=Z.getInternalTexture().uniqueId;j[d]||(j[d]={});let t=j[d][x];if(void 0===t){const F=Z.getSize();t=(async()=>{const G=await this._getImageDataAsync(u,F.width,F.height,x);return this._exportImage(Z.name,x,G)})(),j[d][x]=t}F=this._exportTextureInfo(await t,f,Z.coordinatesIndex),this._textureMap.set(Z,F),this._exporter._extensionsPostExportTextures("exporter",F,Z)}return F}_exportImage(Z,x,F){const u=this._exporter._images;let f;if(this._exporter._shouldUseGlb){f={name:Z,mimeType:x,bufferView:void 0};const u=this._exporter._bufferManager.createBufferView(new Uint8Array(F));this._exporter._bufferManager.setBufferView(f,u)}else{const Y=Z.replace(/\.\/|\/|\.\\|\\/g,"_"),j=function(Z){switch(Z){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(x);let d=Y+j;u.some((Z=>Z.uri===d))&&(d=`${Y}_${G.Tools.RandomId()}${j}`),f={name:Z,uri:d},this._exporter._imageData[d]={data:F,mimeType:x}}return u.push(f),u.length-1}_exportTextureInfo(Z,x,F){const u=this._exporter._textures;let G=u.findIndex((F=>F.sampler==x&&F.source===Z));-1===G&&(G=u.length,u.push({source:Z,sampler:x}));const f={index:G};return F&&(f.texCoord=F),f}_exportTextureSampler(Z){const x=this._getTextureSampler(Z),F=this._exporter._samplers,u=F.findIndex((Z=>Z.minFilter===x.minFilter&&Z.magFilter===x.magFilter&&Z.wrapS===x.wrapS&&Z.wrapT===x.wrapT));return-1!==u?u:(F.push(x),F.length-1)}}var N=F(11271),W=F(11012),A=F(11706),h=F(11188);const X=u.kx.Zero(),D=u.Quaternion.Identity(),Q=u.kx.One(),g=new u.kx(-1,1,1);function O(Z,x){const{byteOffset:F,byteStride:u,type:G,normalized:f}=Z,Y=Z.getSize(),j=x.reduce(((Z,x)=>x.getTotalVertices()>Z?x.getTotalVertices():Z),-Number.MAX_VALUE);return{byteOffset:F,byteStride:u,componentCount:Y,type:G,count:j*Y,normalized:f,totalVertices:j,kind:Z.getKind()}}function n(Z){switch(Z){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function V(Z){switch(Z){case o.f.PositionKind:case o.f.NormalKind:case o.f.TangentKind:case o.f.ColorKind:case o.f.MatricesIndicesKind:case o.f.MatricesIndicesExtraKind:case o.f.MatricesWeightsKind:case o.f.MatricesWeightsExtraKind:case o.f.UVKind:case o.f.UV2Kind:case o.f.UV3Kind:case o.f.UV4Kind:case o.f.UV5Kind:case o.f.UV6Kind:return!0}return!1}function a(Z){switch(Z){case f.e.TriangleFillMode:return 4;case f.e.TriangleStripDrawMode:return 5;case f.e.TriangleFanDrawMode:return 6;case f.e.PointListDrawMode:case f.e.PointFillMode:return 0;case f.e.LineLoopDrawMode:return 2;case f.e.LineListDrawMode:return 1;case f.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${Z}`)}function I(Z){const x=Math.sqrt(Z.x*Z.x+Z.y*Z.y+Z.z*Z.z);x>0&&(Z.x/=x,Z.y/=x,Z.z/=x)}function r(Z){return Z.x*=-1,Z}function z(Z){if(Z.x*Z.x+Z.y*Z.y>.5){const x=Math.abs(Z.x),F=Math.abs(Z.y);if(x>F){const F=Math.sign(Z.x);Z.x=x,Z.y*=-F,Z.z*=-F,Z.w*=F}else{const x=Math.sign(Z.y);Z.x*=-x,Z.y=F,Z.z*=x,Z.w*=-x}}else{const x=Math.abs(Z.z),F=Math.abs(Z.w);if(x>F){const F=Math.sign(Z.z);Z.x*=-F,Z.y*=F,Z.z=x,Z.w*=-F}else{const x=Math.sign(Z.w);Z.x*=x,Z.y*=-x,Z.z*=-x,Z.w=F}}return Z}function P(Z){Z.Jj(-Z.z,Z.w,Z.x,-Z.y)}function ZZ(Z,x){const F=u.kx.FromArrayToRef(x.translation||[0,0,0],0,u.TmpVectors.kx[0]),G=u.Quaternion.FromArrayToRef(x.rotation||[0,0,0,1],0,u.TmpVectors.Quaternion[0]),f=u.Matrix.ComposeToRef(Q,G,F,u.TmpVectors.Matrix[0]),Y=u.kx.FromArrayToRef(Z.translation||[0,0,0],0,u.TmpVectors.kx[2]),j=u.Quaternion.FromArrayToRef(Z.rotation||[0,0,0,1],0,u.TmpVectors.Quaternion[1]),d=u.Matrix.ComposeToRef(Q,j,Y,u.TmpVectors.Matrix[1]);f.multiplyToRef(d,d),d.decompose(void 0,G,F),F.equalsWithEpsilon(X,h.e)?delete x.translation:x.translation=F.Wf(),G.equalsWithEpsilon(D,h.e)?delete x.rotation:x.rotation=G.Wf(),x.scale&&delete x.scale}function xZ(Z,x){if(!(x instanceof c.d))return!1;if(!(1===x.getChildren().length&&0===Z.getChildren().length&&Z.parent===x))return!1;const F=Z.KZ(),u=Z instanceof A.d&&!F.useRightHandedSystem?g:Q;return!!x.pj.equalsWithEpsilon(u,h.e)||(W.d.Warn(`Cannot collapse node ${Z.name} into parent node ${x.name} with modified scaling.`),!1)}function FZ(Z){if(Z instanceof Array){const x=new Float32Array(Z);return new Uint8Array(x.buffer,x.byteOffset,x.byteLength)}return ArrayBuffer.isView(Z)?new Uint8Array(Z.buffer,Z.byteOffset,Z.byteLength):new Uint8Array(Z)}function uZ(Z,x){for(const[F,u]of Object.entries(Z)){const G=x[F];(Array.isArray(u)&&Array.isArray(G)&&GZ(u,G)||u===G)&&delete Z[F]}return Z}function GZ(Z,x){return Z.length===x.length&&Z.every(((Z,F)=>Z===x[F]))}const fZ=u.Matrix.Compose(new u.kx(-1,1,1),u.Quaternion.Identity(),u.kx.Zero());function YZ(Z,x){if(!(Z instanceof c.d))return!1;if(x){if(!Z.getWorldMatrix().equalsWithEpsilon(u.Matrix.IdentityReadOnly,h.e))return!1}else{if(!Z.getWorldMatrix().multiplyToRef(fZ,u.TmpVectors.Matrix[0]).equalsWithEpsilon(u.Matrix.IdentityReadOnly,h.e))return!1}return!(Z instanceof s.c&&Z.af)}const jZ=new Map([[Int8Array,(Z,x,F)=>Z.setInt8(x,F)],[Uint8Array,(Z,x,F)=>Z.setUint8(x,F)],[Uint8ClampedArray,(Z,x,F)=>Z.setUint8(x,F)],[Int16Array,(Z,x,F)=>Z.setInt16(x,F,!0)],[Uint16Array,(Z,x,F)=>Z.setUint16(x,F,!0)],[Int32Array,(Z,x,F)=>Z.setInt32(x,F,!0)],[Uint32Array,(Z,x,F)=>Z.setUint32(x,F,!0)],[Float32Array,(Z,x,F)=>Z.setFloat32(x,F,!0)],[Float64Array,(Z,x,F)=>Z.setFloat64(x,F,!0)]]);class dZ{writeTypedArray(Z){this._checkGrowBuffer(Z.byteLength);const x=jZ.get(Z.constructor);for(let F=0;F<Z.length;F++)x(this._dataView,this._byteOffset,Z[F]),this._byteOffset+=Z.BYTES_PER_ELEMENT}constructor(Z){this._data=new Uint8Array(Z),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(Z){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,Z),this._byteOffset++}writeInt8(Z){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,Z),this._byteOffset++}writeInt16(Z){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,Z,!0),this._byteOffset+=2}writeUInt16(Z){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,Z,!0),this._byteOffset+=2}writeInt32(Z){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,Z,!0),this._byteOffset+=4}writeUInt32(Z){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat32(Z){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,Z,!0),this._byteOffset+=4}writeFloat64(Z){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,Z,!0),this._byteOffset+=8}_checkGrowBuffer(Z){const x=this.byteOffset+Z;if(x>this._data.byteLength){const Z=new Uint8Array(2*x);Z.set(this._data),this._data=Z,this._dataView=new DataView(this._data.buffer)}}}function tZ(Z){return Z%4===0?4:Z%2===0?2:1}class oZ{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(Z){let x=0;this._bufferViewToData.forEach((Z=>{x+=Z.byteLength}));const F=new dZ(x),u=Array.from(this._bufferViewToData.keys()).sort(((Z,x)=>tZ(x.byteLength)-tZ(Z.byteLength)));for(const G of u){G.byteOffset=F.byteOffset,Z.push(G);const x=Z.length-1,u=this.getPropertiesWithBufferView(G);for(const Z of u)Z.bufferView=x;F.writeTypedArray(this._bufferViewToData.get(G)),this._bufferViewToData.delete(G)}return F.getOutputData()}createBufferView(Z,x){const F={buffer:0,byteOffset:void 0,byteLength:Z.byteLength,byteStride:x};return this._bufferViewToData.set(F,Z),F}createAccessor(Z,x,F,u,G,f,Y){this._verifyBufferView(Z);const j={bufferView:void 0,componentType:F,count:u,type:x,min:null===f||void 0===f?void 0:f.min,max:null===f||void 0===f?void 0:f.max,normalized:Y,byteOffset:G};return this.setBufferView(j,Z),this._accessorToBufferView.set(j,Z),j}setBufferView(Z,x){this._verifyBufferView(x);this.getPropertiesWithBufferView(x).push(Z)}removeBufferView(Z){const x=this.getPropertiesWithBufferView(Z);for(const F of x)void 0!==F.bufferView&&delete F.bufferView;this._bufferViewToData.delete(Z),this._bufferViewToProperties.delete(Z),this._accessorToBufferView.forEach(((x,F)=>{x===Z&&(void 0!==F.byteOffset&&delete F.byteOffset,this._accessorToBufferView.delete(F))}))}getBufferView(Z){const x=this._accessorToBufferView.get(Z);return this._verifyBufferView(x),x}getPropertiesWithBufferView(Z){return this._verifyBufferView(Z),this._bufferViewToProperties.set(Z,this._bufferViewToProperties.get(Z)??[]),this._bufferViewToProperties.get(Z)}getData(Z){return this._verifyBufferView(Z),this._bufferViewToData.get(Z)}_verifyBufferView(Z){if(void 0===Z||!this._bufferViewToData.has(Z))throw new Error(`BufferView ${Z} not found in BufferManager.`)}}var cZ,sZ=F(11673),JZ=F(11689),pZ=F(11710),UZ=F(11580),kZ=F(11745),MZ=F(11755),mZ=F(11671),CZ=F(11764);!function(Z){Z[Z.INTANGENT=0]="INTANGENT",Z[Z.OUTTANGENT=1]="OUTTANGENT"}(cZ||(cZ={}));class LZ{static _IsTransformable(Z){return Z&&(Z instanceof c.d||Z instanceof sZ.c||Z instanceof CZ.e)}static _CreateNodeAnimation(Z,x,F,u,f){if(this._IsTransformable(Z)){const Y=[],j=[],d=x.getKeys(),t=LZ._CalculateMinMaxKeyFrames(d),o=LZ._DeduceInterpolation(d,F,u),c=o.interpolationType,s=o.shouldBakeAnimation;if(s?LZ._CreateBakedAnimation(Z,x,F,t.min,t.max,x.framePerSecond,f,Y,j,t,u):"LINEAR"===c||"STEP"===c?LZ._CreateLinearOrStepAnimation(Z,x,F,Y,j,u):"CUBICSPLINE"===c?LZ._CreateCubicSplineAnimation(Z,x,F,Y,j,u):LZ._CreateBakedAnimation(Z,x,F,t.min,t.max,x.framePerSecond,f,Y,j,t,u),Y.length&&j.length){return{inputs:Y,outputs:j,samplerInterpolation:c,inputsMin:s?t.min:G.Tools.FloatRound(t.min/x.framePerSecond),inputsMax:s?t.max:G.Tools.FloatRound(t.max/x.framePerSecond)}}}return null}static _DeduceAnimationInfo(Z){let x=null,F="VEC3",u=!1;const f=Z.targetProperty.split(".");switch(f[0]){case"pj":x="scale";break;case"position":x="translation";break;case"rotation":F="VEC4",x="rotation";break;case"rotationQuaternion":F="VEC4",u=!0,x="rotation";break;case"influence":F="SCALAR",x="weights";break;default:G.Tools.Error(`Unsupported animatable property ${f[0]}`)}return x?{animationChannelTargetPath:x,dataAccessorType:F,useQuaternion:u}:(G.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(Z,x,F,u,G,f,Y,j,d,t,o){let c;if(LZ._IsTransformable(Z)&&Z.animations)for(const s of Z.animations){if(o&&!o(s))continue;const G=LZ._DeduceAnimationInfo(s);G&&(c={name:s.name,samplers:[],channels:[]},LZ._AddAnimation(`${s.name}`,s.hasRunningRuntimeAnimations?x:c,Z,s,G.dataAccessorType,G.animationChannelTargetPath,u,f,Y,j,G.useQuaternion,d,t),c.samplers.length&&c.channels.length&&F.push(c))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(Z,x,F,u,G,f,Y,j,d,t,o){let c;if(Z instanceof mZ.d){const G=Z.morphTargetManager;if(G)for(let s=0;s<G.numTargets;++s){const J=G.getTarget(s);for(const p of J.animations){if(o&&!o(p))continue;const J=new kZ.d(`${p.name}`,"influence",p.framePerSecond,p.dataType,p.loopMode,p.enableBlending),U=[],k=p.getKeys();for(let Z=0;Z<k.length;++Z){const x=k[Z];for(let Z=0;Z<G.numTargets;++Z)Z==s?U.push(x):U.push({frame:x.frame,value:0})}J.setKeys(U);const M=LZ._DeduceAnimationInfo(J);M&&(c={name:J.name,samplers:[],channels:[]},LZ._AddAnimation(p.name,p.hasRunningRuntimeAnimations?x:c,Z,J,M.dataAccessorType,M.animationChannelTargetPath,u,f,Y,j,M.useQuaternion,d,t,G.numTargets),c.samplers.length&&c.channels.length&&F.push(c))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(Z,x,F,u,G,f,Y,j,d){let t;if(Z.animationGroups){const c=Z.animationGroups;for(const s of c){const c=new Map,J=new Map,p=new Set,U=s.to-s.from;t={name:s.name,channels:[],samplers:[]};for(let x=0;x<s.targetedAnimations.length;++x){const U=s.targetedAnimations[x],k=U.target,M=U.animation;if(d&&!d(M))continue;const m=j.has(k);if(this._IsTransformable(k)||1===k.length&&this._IsTransformable(k[0])){const Z=LZ._DeduceAnimationInfo(U.animation);if(Z){const x=this._IsTransformable(k)?k:this._IsTransformable(k[0])?k[0]:null;x&&LZ._AddAnimation(`${M.name}`,t,x,M,Z.dataAccessorType,Z.animationChannelTargetPath,F,u,G,f,Z.useQuaternion,Y,m)}}else if(k instanceof MZ.c||1===k.length&&k[0]instanceof MZ.c){if(LZ._DeduceAnimationInfo(U.animation)){const x=k instanceof MZ.c?k:k[0];if(x){const F=Z.morphTargetManagers.find((Z=>{for(let F=0;F<Z.numTargets;++F)if(Z.getTarget(F)===x)return!0;return!1}));if(F){const u=Z.meshes.find((Z=>Z.morphTargetManager===F));var o;if(u)c.has(u)||c.set(u,new Map),null===(o=c.get(u))||void 0===o||o.set(x,M),p.add(u),J.set(u,M)}}}}}p.forEach((Z=>{const x=Z.morphTargetManager;let j=null;const d=[],o=J.get(Z).getKeys(),p=o.length;for(let F=0;F<p;++F)for(let u=0;u<x.numTargets;++u){const G=x.getTarget(u),f=c.get(Z);if(f){const x=f.get(G);x?(j||(j=new kZ.d(`${s.name}_${Z.name}_MorphWeightAnimation`,"influence",x.framePerSecond,kZ.d.ANIMATIONTYPE_FLOAT,x.loopMode,x.enableBlending)),d.push(x.getKeys()[F])):d.push({frame:s.from+U/p*F,value:G.influence,inTangent:o[0].inTangent?0:void 0,outTangent:o[0].outTangent?0:void 0})}}j.setKeys(d);const k=LZ._DeduceAnimationInfo(j);k&&LZ._AddAnimation(`${s.name}_${Z.name}_MorphWeightAnimation`,t,Z,j,k.dataAccessorType,k.animationChannelTargetPath,F,u,G,f,k.useQuaternion,Y,!1,null===x||void 0===x?void 0:x.numTargets)})),t.channels.length&&t.samplers.length&&x.push(t)}}}static _AddAnimation(Z,x,F,G,f,Y,j,d,t,o,c,s,J,p){const U=LZ._CreateNodeAnimation(F,G,Y,c,s);let k,M,m,C,L,H;if(U){if(p){let Z=0,x=0;const F=[];for(;U.inputs.length>0;)x=U.inputs.shift(),Z%p==0&&F.push(x),Z++;U.inputs=F}const Z=j.get(F),G=new Float32Array(U.inputs);k=d.createBufferView(G),M=d.createAccessor(k,"SCALAR",5126,U.inputs.length,void 0,{min:[U.inputsMin],max:[U.inputsMax]}),o.push(M),m=o.length-1;const t=new u.Quaternion,c=new u.kx,s=new u.kx,S=F instanceof sZ.c,K=n(f),y=new Float32Array(U.outputs.length*K);U.outputs.forEach((function(Z,x){let F=Z;switch(Y){case"translation":J&&(u.kx.FromArrayToRef(Z,0,s),r(s),s.toArray(F));break;case"rotation":4===Z.length?u.Quaternion.FromArrayToRef(Z,0,t):(F=new Array(4),u.kx.FromArrayToRef(Z,0,c),u.Quaternion.FromEulerVectorToRef(c,t)),J&&(z(t),S&&P(t)),t.toArray(F)}y.set(F,x*K)})),k=d.createBufferView(y),M=d.createAccessor(k,f,5126,U.outputs.length),o.push(M),C=o.length-1,L={interpolation:U.samplerInterpolation,input:m,output:C},x.samplers.push(L),H={sampler:x.samplers.length-1,target:{node:Z,path:Y}},x.channels.push(H)}}static _CreateBakedAnimation(Z,x,F,f,Y,j,d,t,o,c,s){let J;const p=u.Quaternion.Identity();let U,k=null,M=null,m=null,C=null,L=null,H=null;c.min=G.Tools.FloatRound(f/j);const S=x.getKeys();for(let u=0,K=S.length;u<K;++u){if(H=null,m=S[u],u+1<K)if(C=S[u+1],m.value.equals&&m.value.equals(C.value)||m.value===C.value){if(0!==u)continue;H=m.frame}else H=C.frame;else{if(L=S[u-1],m.value.equals&&m.value.equals(L.value)||m.value===L.value)continue;H=Y}if(H)for(let u=m.frame;u<=H;u+=d){if(U=G.Tools.FloatRound(u/j),U===k)continue;k=U,M=U;const f={key:0,repeatCount:0,loopMode:x.loopMode};J=x._interpolate(u,f),LZ._SetInterpolatedValue(Z,J,U,x,F,p,t,o,s)}}M&&(c.max=M)}static _ConvertFactorToVector3OrQuaternion(Z,x,F,f,Y){const j=LZ._GetBasePositionRotationOrScale(x,f,Y),d=F.targetProperty.split("."),t=d?d[1]:"",o=Y?u.Quaternion.Hx(j).normalize():u.kx.Hx(j);switch(t){case"x":case"y":case"z":o[t]=Z;break;case"w":o.w=Z;break;default:G.Tools.Error(`glTFAnimation: Unsupported component name "${t}"!`)}return o}static _SetInterpolatedValue(Z,x,F,G,f,Y,j,d,t){let o;j.push(F),"weights"!==f?(G.dataType===kZ.d.ANIMATIONTYPE_FLOAT&&(x=this._ConvertFactorToVector3OrQuaternion(x,Z,G,f,t)),"rotation"===f?(t?Y=x:(o=x,u.Quaternion.RotationYawPitchRollToRef(o.y,o.x,o.z,Y)),d.push(Y.Wf())):(o=x,d.push(o.Wf()))):d.push([x])}static _CreateLinearOrStepAnimation(Z,x,F,u,G,f){for(const Y of x.getKeys())u.push(Y.frame/x.framePerSecond),LZ._AddKeyframeValue(Y,x,G,F,Z,f)}static _CreateCubicSplineAnimation(Z,x,F,u,G,f){x.getKeys().forEach((function(Y){u.push(Y.frame/x.framePerSecond),LZ._AddSplineTangent(cZ.INTANGENT,G,F,"CUBICSPLINE",Y,f),LZ._AddKeyframeValue(Y,x,G,F,Z,f),LZ._AddSplineTangent(cZ.OUTTANGENT,G,F,"CUBICSPLINE",Y,f)}))}static _GetBasePositionRotationOrScale(Z,x,F){let G;if("rotation"===x)if(F){G=(Z.rotationQuaternion??u.Quaternion.Identity()).Wf()}else{G=(Z.rotation??u.kx.Zero()).Wf()}else if("translation"===x){G=(Z.position??u.kx.Zero()).Wf()}else{G=(Z.pj??u.kx.One()).Wf()}return G}static _AddKeyframeValue(Z,x,F,f,Y,j){let d;const t=x.dataType;if(t===kZ.d.ANIMATIONTYPE_VECTOR3){let x=Z.value.Wf();if("rotation"===f){const Z=u.kx.Hx(x);x=u.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).Wf()}F.push(x)}else if(t===kZ.d.ANIMATIONTYPE_FLOAT){if("weights"===f)F.push([Z.value]);else if(d=this._ConvertFactorToVector3OrQuaternion(Z.value,Y,x,f,j),d){if("rotation"===f){const Z=j?d:u.Quaternion.RotationYawPitchRoll(d.y,d.x,d.z).normalize();F.push(Z.Wf())}F.push(d.Wf())}}else t===kZ.d.ANIMATIONTYPE_QUATERNION?F.push(Z.value.normalize().Wf()):G.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(Z,x,F){let u,G,f=!1;if("rotation"===x&&!F)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let Y=0,j=Z.length;Y<j;++Y)if(G=Z[Y],G.inTangent||G.outTangent)if(u){if("CUBICSPLINE"!==u){u="LINEAR",f=!0;break}}else u="CUBICSPLINE";else if(u){if("CUBICSPLINE"===u||G.interpolation&&1===G.interpolation&&"STEP"!==u){u="LINEAR",f=!0;break}}else u=G.interpolation&&1===G.interpolation?"STEP":"LINEAR";return u||(u="LINEAR"),{interpolationType:u,shouldBakeAnimation:f}}static _AddSplineTangent(Z,x,F,G,f,Y){let j;const d=Z===cZ.INTANGENT?f.inTangent:f.outTangent;if("CUBICSPLINE"===G){if("rotation"===F)if(d)if(Y)j=d.Wf();else{const Z=d;j=u.Quaternion.RotationYawPitchRoll(Z.y,Z.x,Z.z).Wf()}else j=[0,0,0,0];else j="weights"===F?d?[d]:[0]:d?d.Wf():[0,0,0];x.push(j)}}static _CalculateMinMaxKeyFrames(Z){let x=1/0,F=-1/0;return Z.forEach((function(Z){x=Math.min(x,Z.frame),F=Math.max(F,Z.frame)})),{min:x,max:F}}}function HZ(Z,x,F,f,Y,j){const d={attributes:{},influence:Z.influence,name:Z.name},t=x.af;if(!t)return G.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),d;const c=j?-1:1,s=u.kx.Zero();let J=0,p=0;if(Z.hasPositions){const f=Z.getPositions(),j=t.getVerticesData(o.f.PositionKind);if(j){const Z=new Float32Array(j.length),x=[1/0,1/0,1/0],G=[-1/0,-1/0,-1/0];p=j.length/3,J=0;for(let F=J;F<p;++F){const Y=u.kx.Hx(j,3*F);u.kx.Hx(f,3*F).subtractToRef(Y,s),s.x*=c,x[0]=Math.min(x[0],s.x),G[0]=Math.max(G[0],s.x),x[1]=Math.min(x[1],s.y),G[1]=Math.max(G[1],s.y),x[2]=Math.min(x[2],s.z),G[2]=Math.max(G[2],s.z),Z[3*F]=s.x,Z[3*F+1]=s.y,Z[3*F+2]=s.z}const t=F.createBufferView(Z,12),o=F.createAccessor(t,"VEC3",5126,f.length/3,0,{min:x,max:G});Y.push(o),d.attributes.POSITION=Y.length-1}else G.Tools.Warn(`Morph target positions for mesh ${x.name} were not exported. Mesh does not have position vertex data`)}if(Z.hasNormals){const f=Z.getNormals(),j=t.getVerticesData(o.f.NormalKind);if(j){const Z=new Float32Array(j.length);p=j.length/3,J=0;for(let F=J;F<p;++F){const x=u.kx.Hx(j,3*F).normalize();u.kx.Hx(f,3*F).normalize().subtractToRef(x,s),Z[3*F]=s.x*c,Z[3*F+1]=s.y,Z[3*F+2]=s.z}const x=F.createBufferView(Z,12),G=F.createAccessor(x,"VEC3",5126,f.length/3,0);Y.push(G),d.attributes.NORMAL=Y.length-1}else G.Tools.Warn(`Morph target normals for mesh ${x.name} were not exported. Mesh does not have normals vertex data`)}if(Z.hasTangents){const f=Z.getTangents(),j=t.getVerticesData(o.f.TangentKind);if(j){p=j.length/4;const Z=new Float32Array(3*p);J=0;for(let F=J;F<p;++F){const x=u.kx.Hx(j,4*F);I(x);const G=u.kx.Hx(f,3*F);I(G),G.subtractToRef(x,s),Z[3*F]=s.x*c,Z[3*F+1]=s.y,Z[3*F+2]=s.z}const x=F.createBufferView(Z,12),G=F.createAccessor(x,"VEC3",5126,p,0);Y.push(G),d.attributes.TANGENT=Y.length-1}else G.Tools.Warn(`Morph target tangents for mesh ${x.name} were not exported. Mesh does not have tangents vertex data`)}if(Z.hasColors){const f=Z.getColors(),j=t.getVerticesData(o.f.ColorKind),c=t.getVertexBuffer(o.f.ColorKind);if(j&&c){const Z=c.getSize();p=j.length/Z;const x=new Float32Array(p*Z);J=0;for(let F=J;F<p;++F)if(3===Z){const G=u.kx.Hx(j,F*Z);u.kx.Hx(f,F*Z).subtractToRef(G,s),x[3*F]=s.x,x[3*F+1]=s.y,x[3*F+2]=s.z}else if(4===Z){const G=new u.Vector4,Y=u.Vector4.Hx(j,F*Z);u.Vector4.Hx(f,F*Z).subtractToRef(Y,G),x[4*F]=G.x,x[4*F+1]=G.y,x[4*F+2]=G.z,x[4*F+3]=G.w}else G.Tools.Warn(`Unsupported number of components for color attribute: ${Z}`);const t=F.createBufferView(x,4*Z),o=F.createAccessor(t,3===Z?"VEC3":"VEC4",5126,p,0);Y.push(o),d.attributes.COLOR_0=Y.length-1}else G.Tools.Warn(`Morph target colors for mesh ${x.name} were not exported. Mesh does not have colors vertex data`)}return d}var SZ=F(11767),KZ=F(11607),yZ=F(11592),qZ=F(11136);class RZ{}RZ.DEFAULT_COLOR=k.Lx.White(),RZ.DEFAULT_WIDTH_ATTENUATED=1,RZ.DEFAULT_WIDTH=.1;var BZ=F(11424),vZ=F(11774);class lZ{static ConvertPoints(Z,x){if(Z.length&&Array.isArray(Z)&&"number"===typeof Z[0])return[Z];if(Z.length&&Array.isArray(Z[0])&&"number"===typeof Z[0][0])return Z;if(Z.length&&!Array.isArray(Z[0])&&Z[0]instanceof u.kx){const x=[];for(let F=0;F<Z.length;F++){const u=Z[F];x.push(u.x,u.y,u.z)}return[x]}if(Z.length>0&&Array.isArray(Z[0])&&Z[0].length>0&&Z[0][0]instanceof u.kx){const x=[],F=Z;for(const Z of F)x.push(Z.flatMap((Z=>[Z.x,Z.y,Z.z])));return x}if(Z instanceof Float32Array){if(null!==x&&void 0!==x&&x.floatArrayStride){const F=[],u=3*x.floatArrayStride;for(let x=0;x<Z.length;x+=u){const G=new Array(u);for(let F=0;F<u;F++)G[F]=Z[x+F];F.push(G)}return F}return[Array.from(Z)]}if(Z.length&&Z[0]instanceof Float32Array){const x=[];for(const F of Z)x.push(Array.from(F));return x}return[]}static OmitZeroLengthPredicate(Z,x,F){const u=[];return x.Mx(Z).lengthSquared()>0&&u.push([Z,x]),F.Mx(x).lengthSquared()>0&&u.push([x,F]),Z.Mx(F).lengthSquared()>0&&u.push([F,Z]),0===u.length?null:u}static OmitDuplicatesPredicate(Z,x,F,u){const G=[];return lZ._SearchInPoints(Z,x,u)||G.push([Z,x]),lZ._SearchInPoints(x,F,u)||G.push([x,F]),lZ._SearchInPoints(F,Z,u)||G.push([F,Z]),0===G.length?null:G}static _SearchInPoints(Z,x,F){for(const Y of F)for(let F=0;F<Y.length;F++){var u,G,f;if(null!==(u=Y[F])&&void 0!==u&&u.equals(Z))if(null!==(G=Y[F+1])&&void 0!==G&&G.equals(x)||null!==(f=Y[F-1])&&void 0!==f&&f.equals(x))return!0}return!1}static MeshesToLines(Z,x){const F=[];for(let G=0;G<Z.length;G++){const f=Z[G],Y=f.getVerticesData(o.f.PositionKind),j=f.cj();if(Y&&j)for(let Z=0,d=0;Z<j.length;Z++){const t=3*j[d++],o=3*j[d++],c=3*j[d++],s=new u.kx(Y[t],Y[t+1],Y[t+2]),J=new u.kx(Y[o],Y[o+1],Y[o+2]),p=new u.kx(Y[c],Y[c+1],Y[c+2]);if(x){const u=x(s,J,p,F,Z,t,f,G,Y,j);if(u)for(const Z of u)F.push(Z)}else F.push([s,J],[J,p],[p,s])}}return F}static ToVector3Array(Z){if(Array.isArray(Z[0])){const x=[],F=Z;for(const Z of F){const F=[];for(let x=0;x<Z.length;x+=3)F.push(new u.kx(Z[x],Z[x+1],Z[x+2]));x.push(F)}return x}const x=Z,F=[];for(let G=0;G<x.length;G+=3)F.push(new u.kx(x[G],x[G+1],x[G+2]));return F}static ToNumberArray(Z){return Z.flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetPointsCountInfo(Z){const x=new Array(Z.length);let F=0;for(let u=Z.length;u--;)x[u]=Z[u].length/3,F+=x[u];return{total:F,counts:x}}static GetLineLength(Z){if(0===Z.length)return 0;let x;x="number"===typeof Z[0]?lZ.ToVector3Array(Z):Z;const F=u.TmpVectors.kx[0];let G=0;for(let u=0;u<x.length-1;u++){const Z=x[u];G+=x[u+1].subtractToRef(Z,F).length()}return G}static GetLineLengthArray(Z){const x=new Float32Array(Z.length/3);let F=0;for(let u=0,G=Z.length/3-1;u<G;u++){let G=Z[3*u+0],f=Z[3*u+1],Y=Z[3*u+2];G-=Z[3*u+3],f-=Z[3*u+4],Y-=Z[3*u+5];F+=Math.sqrt(G*G+f*f+Y*Y),x[u+1]=F}return x}static SegmentizeSegmentByCount(Z,x,F){const G=[],f=x.Mx(Z),Y=u.TmpVectors.kx[0];Y.Uj(F);const j=u.TmpVectors.kx[1];f.divideToRef(Y,j);let d=Z.clone();G.push(d);for(let u=0;u<F;u++)d=d.clone(),G.push(d.addInPlace(j));return G}static SegmentizeLineBySegmentLength(Z,x){const F=Z[0]instanceof u.kx?lZ.GetLineSegments(Z):"number"===typeof Z[0]?lZ.GetLineSegments(lZ.ToVector3Array(Z)):Z,G=[];for(const u of F)if(u.length>x){const Z=lZ.SegmentizeSegmentByCount(u.point1,u.point2,Math.ceil(u.length/x));for(const x of Z)G.push(x)}else G.push(u.point1),G.push(u.point2);return G}static SegmentizeLineBySegmentCount(Z,x){const F="number"===typeof Z[0]?lZ.ToVector3Array(Z):Z,u=lZ.GetLineLength(F)/x;return lZ.SegmentizeLineBySegmentLength(F,u)}static GetLineSegments(Z){const x=[];for(let F=0;F<Z.length-1;F++){const u=Z[F],G=Z[F+1],f=G.Mx(u).length();x.push({point1:u,point2:G,length:f})}return x}static GetMinMaxSegmentLength(Z){const x=lZ.GetLineSegments(Z).sort((Z=>Z.length));return{min:x[0].length,max:x[x.length-1].length}}static GetPositionOnLineByVisibility(Z,x,F){let G=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const f=x*F;let Y=0,j=0;const d=Z.length;for(let u=0;u<d;u++){if(f<=Y+Z[u].length){j=u;break}Y+=Z[u].length}const t=(f-Y)/Z[j].length;return Z[j].point2.subtractToRef(Z[j].point1,u.TmpVectors.kx[0]),u.TmpVectors.kx[1]=u.TmpVectors.kx[0].multiplyByFloats(t,t,t),G||u.TmpVectors.kx[1].addInPlace(Z[j].point1),u.TmpVectors.kx[1].clone()}static GetCircleLinePoints(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,G=arguments.length>3&&void 0!==arguments[3]?arguments[3]:Z,f=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/x;const Y=[];for(let j=0;j<=x;j++)Y.push(new u.kx(Math.cos(j*f)*Z,Math.sin(j*f)*G,F));return Y}static GetBezierLinePoints(Z,x,F,u){return BZ.d.CreateQuadraticBezier(Z,x,F,u).getPoints().flatMap((Z=>[Z.x,Z.y,Z.z]))}static GetArrowCap(Z,x,F,u,G){let f=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,Y=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[Z.clone(),Z.add(x.multiplyByFloats(F,F,F))],widths:[u,G,f,Y]}}static GetPointsFromText(Z,x,F,u){let G=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,f=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const Y=[],j=(0,vZ.e)(Z,x,F,u);for(const d of j){for(const Z of d.paths){const x=[],F=Z.getPoints();for(const Z of F)x.push(Z.x,Z.y,G);Y.push(x)}if(f)for(const Z of d.holes){const x=[],F=Z.getPoints();for(const Z of F)x.push(Z.x,Z.y,G);Y.push(x)}}return Y}static Color3toRGBAUint8(Z){const x=new Uint8Array(4*Z.length);for(let F=0,u=0;F<Z.length;F++)x[u++]=255*Z[F].r,x[u++]=255*Z[F].g,x[u++]=255*Z[F].b,x[u++]=255;return x}static CreateColorsTexture(Z,x,F,u){const G=u.getEngine().getCaps().maxTextureSize??1,f=x.length>G?G:x.length,Y=Math.ceil(x.length/G);Y>1&&(x=[...x,...Array(f*Y-x.length).fill(x[0])]);const j=lZ.Color3toRGBAUint8(x),d=new S.d(j,f,Y,p.b.TEXTUREFORMAT_RGBA,u,!1,!0,F);return d.name=Z,d}static PrepareEmptyColorsTexture(Z){if(!RZ.EmptyColorsTexture){const x=new Uint8Array(4);RZ.EmptyColorsTexture=new S.d(x,1,1,p.b.TEXTUREFORMAT_RGBA,Z,!1,!1,S.d.NEAREST_NEAREST),RZ.EmptyColorsTexture.name="grlEmptyColorsTexture"}return RZ.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var Z;null===(Z=RZ.EmptyColorsTexture)||void 0===Z||Z.dispose(),RZ.EmptyColorsTexture=null}static BooleanToNumber(Z){return Z?1:0}}class iZ extends yZ.b{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class eZ extends KZ.b{isCompatible(Z){return!0}constructor(Z,x,F){var G;F=F||{color:RZ.DEFAULT_COLOR};const f=new iZ;f.GREASED_LINE_HAS_COLOR=!!F.color&&!F.useColors,f.GREASED_LINE_SIZE_ATTENUATION=F.sizeAttenuation??!1,f.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===F.colorDistributionType,f.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(x??Z.KZ()).useRightHandedSystem,f.GREASED_LINE_CAMERA_FACING=F.cameraFacing??!0,super(Z,eZ.GREASED_LINE_MATERIAL_NAME,200,f,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(G=F)||void 0===G?void 0:G.forceGLSL)||eZ.ForceGLSL,this._scene=x??Z.KZ(),this._engine=this._scene.getEngine(),this._cameraFacing=F.cameraFacing??!0,this.visibility=F.visibility??1,this.useDash=F.useDash??!1,this.dashRatio=F.dashRatio??.5,this.dashOffset=F.dashOffset??0,this.width=F.width?F.width:F.sizeAttenuation?RZ.DEFAULT_WIDTH_ATTENUATED:RZ.DEFAULT_WIDTH,this._sizeAttenuation=F.sizeAttenuation??!1,this.colorMode=F.colorMode??0,this._color=F.color??null,this.useColors=F.useColors??!1,this._colorsDistributionType=F.colorDistributionType??0,this.colorsSampling=F.colorsSampling??S.d.NEAREST_NEAREST,this._colors=F.BZ??null,this.dashCount=F.dashCount??1,this.resolution=F.resolution??new u.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),F.colorsTexture?this.colorsTexture=F.colorsTexture:this._colors?this.colorsTexture=lZ.CreateColorsTexture(`${Z.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??RZ.DEFAULT_COLOR,lZ.PrepareEmptyColorsTexture(this._scene)),this._engine.Uf.add((()=>{lZ.DisposeEmptyColorsTexture()}))}getAttributes(Z){Z.push("grl_offsets"),Z.push("grl_widths"),Z.push("grl_colorPointers"),Z.push("grl_counters"),this._cameraFacing?(Z.push("grl_previousAndSide"),Z.push("grl_nextAndCounters")):Z.push("grl_slopes")}getSamplers(Z){Z.push("grl_colors")}getActiveTextures(Z){this.colorsTexture&&Z.push(this.colorsTexture)}getUniforms(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const x=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&x.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===Z&&x.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:x,vertex:this._cameraFacing&&this._isGLSL(Z)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(Z)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(Z){if(this._cameraFacing){Z.Xf("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||Z.Xf("viewProjection",this._scene.getTransformMatrix());const x=u.TmpVectors.Vector4[0];x.x=this._aspect,x.y=this._resolution.x,x.z=this._resolution.y,x.w=this.width,Z.updateVector4("grl_aspect_resolution_lineWidth",x)}const x=u.TmpVectors.Vector4[0];x.x=lZ.BooleanToNumber(this.useDash),x.y=this._dashArray,x.z=this.dashOffset,x.w=this.dashRatio,Z.updateVector4("grl_dashOptions",x);const F=u.TmpVectors.Vector4[1];F.x=this.colorMode,F.y=this.visibility,F.z=this.colorsTexture?this.colorsTexture.getSize().width:0,F.w=lZ.BooleanToNumber(this.useColors),Z.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",F),this._color&&Z.updateColor3("grl_singleColor",this._color);const G=this.colorsTexture??RZ.EmptyColorsTexture;Z.setTexture("grl_colors",G),Z.updateFloat2("grl_textureSize",(null===G||void 0===G?void 0:G.getSize().width)??1,(null===G||void 0===G?void 0:G.getSize().height)??1)}prepareDefines(Z,x,F){Z.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,Z.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,Z.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,Z.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=x.useRightHandedSystem,Z.GREASED_LINE_CAMERA_FACING=this._cameraFacing,Z.GREASED_LINE_USE_OFFSETS=!!F.offsets}getClassName(){return eZ.GREASED_LINE_MATERIAL_NAME}getCustomCode(Z){let x=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(x)?function(Z,x){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return x&&(Z["!gl_Position\\=viewProjection\\*worldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(Z,this._cameraFacing):function(Z,x){if("vertex"===Z){const Z={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return x&&(Z["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),Z}return"fragment"===Z?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(Z,this._cameraFacing)}dispose(){var Z;null===(Z=this.colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}get BZ(){return this._colors}set BZ(Z){this.setColors(Z)}setColors(Z){var x;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var f;if(this._colors=Z,null!==Z&&0!==Z.length){if(!F||u)if(this.colorsTexture&&G===Z.length&&!u){const x=lZ.Color3toRGBAUint8(Z);this.colorsTexture.update(x)}else{var Y;null===(Y=this.colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=lZ.CreateColorsTexture(`${this._material.name}-colors-texture`,Z,this.colorsSampling,this._scene)}}else null===(f=this.colorsTexture)||void 0===f||f.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.markAllDefinesAsDirty()}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==Z||null!==this._color&&null===Z?(this._color=Z,x||this.markAllDefinesAsDirty()):this._color=Z}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(Z){this._aspect=Z.x/Z.y,this._resolution=Z}serialize(){const Z=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(x.BZ=this._colors),this._color&&(x.color=this._color),Z.greasedLineMaterialOptions=x,Z}parse(Z,x,F){var u;super.parse(Z,x,F);const G=Z.greasedLineMaterialOptions;null===(u=this.colorsTexture)||void 0===u||u.dispose(),G.color&&this.setColor(G.color,!0),G.colorDistributionType&&(this.colorsDistributionType=G.colorDistributionType),G.BZ&&(this.BZ=G.BZ),G.colorsSampling&&(this.colorsSampling=G.colorsSampling),G.colorMode&&(this.colorMode=G.colorMode),G.useColors&&(this.useColors=G.useColors),G.visibility&&(this.visibility=G.visibility),G.useDash&&(this.useDash=G.useDash),G.dashCount&&(this.dashCount=G.dashCount),G.dashRatio&&(this.dashRatio=G.dashRatio),G.dashOffset&&(this.dashOffset=G.dashOffset),G.width&&(this.width=G.width),G.sizeAttenuation&&(this.sizeAttenuation=G.sizeAttenuation),G.resolution&&(this.resolution=G.resolution),this.BZ?this.colorsTexture=lZ.CreateColorsTexture(`${this._material.name}-colors-texture`,this.BZ,this.colorsSampling,x):lZ.PrepareEmptyColorsTexture(x),this.markAllDefinesAsDirty()}copyTo(Z){var x;const F=Z;null===(x=F.colorsTexture)||void 0===x||x.dispose(),this._colors&&(F.colorsTexture=lZ.CreateColorsTexture(`${F._material.name}-colors-texture`,this._colors,F.colorsSampling,this._scene)),F.setColor(this.color,!0),F.colorsDistributionType=this.colorsDistributionType,F.colorsSampling=this.colorsSampling,F.colorMode=this.colorMode,F.useColors=this.useColors,F.visibility=this.visibility,F.useDash=this.useDash,F.dashCount=this.dashCount,F.dashRatio=this.dashRatio,F.dashOffset=this.dashOffset,F.width=this.width,F.sizeAttenuation=this.sizeAttenuation,F.resolution=this.resolution,F.markAllDefinesAsDirty()}_isGLSL(Z){return 0===Z||this._forceGLSL}}eZ.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",eZ.ForceGLSL=!1,(0,qZ.g)(`BABYLON.${eZ.GREASED_LINE_MATERIAL_NAME}`,eZ);var bZ=F(11647),EZ=F(11018),wZ=F(11445),TZ=F(11121);class NZ extends wZ.ShaderMaterial{constructor(Z,x,G){const f=x.getEngine(),Y=f.isWebGPU&&!(G.forceGLSL||NZ.ForceGLSL),j=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];x.useRightHandedSystem&&j.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const d=["position","grl_widths","grl_offsets","grl_colorPointers"];G.cameraFacing?(j.push("GREASED_LINE_CAMERA_FACING"),d.push("grl_previousAndSide","grl_nextAndCounters")):(d.push("grl_slopes"),d.push("grl_counters"));const t=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(Y||t.push("world","viewProjection","view","projection"),super(Z,x,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:Y?["Scene","Mesh"]:void 0,attributes:d,uniforms:t,samplers:Y?[]:["grlColors"],defines:j,extraInitializationsAsync:async()=>{Y?await Promise.all([F.e(66).then(F.bind(F,14390)),F.e(75).then(F.bind(F,14394))]):await Promise.all([F.e(69).then(F.bind(F,14403)),F.e(76).then(F.bind(F,14405))])},shaderLanguage:Y?1:0}),this._color=k.Lx.White(),this._colorsDistributionType=0,this._colorsTexture=null,G=G||{color:RZ.DEFAULT_COLOR},this.visibility=G.visibility??1,this.useDash=G.useDash??!1,this.dashRatio=G.dashRatio??.5,this.dashOffset=G.dashOffset??0,this.dashCount=G.dashCount??1,this.width=G.width?G.width:G.sizeAttenuation&&G.cameraFacing?RZ.DEFAULT_WIDTH_ATTENUATED:RZ.DEFAULT_WIDTH,this.sizeAttenuation=G.sizeAttenuation??!1,this.color=G.color??k.Lx.White(),this.useColors=G.useColors??!1,this.colorsDistributionType=G.colorDistributionType??0,this.colorsSampling=G.colorsSampling??S.d.NEAREST_NEAREST,this.colorMode=G.colorMode??0,this._colors=G.BZ??null,this._cameraFacing=G.cameraFacing??!0,this.resolution=G.resolution??new u.Vector2(f.getRenderWidth(),f.getRenderHeight()),G.colorsTexture?this.colorsTexture=G.colorsTexture:this._colors?this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,x):(this._color=this._color??RZ.DEFAULT_COLOR,this.colorsTexture=lZ.PrepareEmptyColorsTexture(x)),Y){const Z=new TZ.d;Z.setParameters(),Z.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",Z)}f.Uf.add((()=>{lZ.DisposeEmptyColorsTexture()}))}dispose(){var Z;null===(Z=this._colorsTexture)||void 0===Z||Z.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new u.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get BZ(){return this._colors}set BZ(Z){this.setColors(Z)}setColors(Z){var x;let F=arguments.length>1&&void 0!==arguments[1]&&arguments[1],u=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const G=(null===(x=this._colors)||void 0===x?void 0:x.length)??0;var f;if(this._colors=Z,null!==Z&&0!==Z.length){if(!F||u)if(this._colorsTexture&&G===Z.length&&!u){const x=lZ.Color3toRGBAUint8(Z);this._colorsTexture.update(x)}else{var Y;null===(Y=this._colorsTexture)||void 0===Y||Y.dispose(),this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,Z,this.colorsSampling,this.KZ())}}else null===(f=this._colorsTexture)||void 0===f||f.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(Z){this._colorsTexture=Z,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(Z){this._width=Z,this.setFloat("grlWidth",Z)}get useColors(){return this._useColors}set useColors(Z){this._useColors=Z,this.setFloat("grlUseColors",lZ.BooleanToNumber(Z))}get colorsSampling(){return this._colorsSampling}set colorsSampling(Z){this._colorsSampling=Z}get visibility(){return this._visibility}set visibility(Z){this._visibility=Z,this.setFloat("grlVisibility",Z)}get useDash(){return this._useDash}set useDash(Z){this._useDash=Z,this.setFloat("grlUseDash",lZ.BooleanToNumber(Z))}get dashOffset(){return this._dashOffset}set dashOffset(Z){this._dashOffset=Z,this.setFloat("grlDashOffset",Z)}get dashRatio(){return this._dashRatio}set dashRatio(Z){this._dashRatio=Z,this.setFloat("grlDashRatio",Z)}get dashCount(){return this._dashCount}set dashCount(Z){this._dashCount=Z,this._dashArray=1/Z,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(Z){this._sizeAttenuation=Z,this.setFloat("grlSizeAttenuation",lZ.BooleanToNumber(Z))}get color(){return this._color}set color(Z){this.setColor(Z)}setColor(Z){Z=Z??RZ.DEFAULT_COLOR,this._color=Z,this.setColor3("grlColor",Z)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(Z){this._colorsDistributionType=Z,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(Z){this._colorMode=Z,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(Z){this._resolution=Z,this.setVector2("grlResolution",Z),this.setFloat("grlAspect",Z.x/Z.y)}serialize(){const Z=super.serialize(),x={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(x.BZ=this._colors),Z.greasedLineMaterialOptions=x,Z}parse(Z,x,F){var u;const G=Z.greasedLineMaterialOptions;null===(u=this._colorsTexture)||void 0===u||u.dispose(),G.color&&(this.color=G.color),G.colorDistributionType&&(this.colorsDistributionType=G.colorDistributionType),G.colorsSampling&&(this.colorsSampling=G.colorsSampling),G.colorMode&&(this.colorMode=G.colorMode),G.useColors&&(this.useColors=G.useColors),G.visibility&&(this.visibility=G.visibility),G.useDash&&(this.useDash=G.useDash),G.dashCount&&(this.dashCount=G.dashCount),G.dashRatio&&(this.dashRatio=G.dashRatio),G.dashOffset&&(this.dashOffset=G.dashOffset),G.width&&(this.width=G.width),G.sizeAttenuation&&(this.sizeAttenuation=G.sizeAttenuation),G.resolution&&(this.resolution=G.resolution),G.BZ?this.colorsTexture=lZ.CreateColorsTexture(`${this.name}-colors-texture`,G.BZ,this.colorsSampling,this.KZ()):this.colorsTexture=lZ.PrepareEmptyColorsTexture(x),this._cameraFacing=G.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var WZ,AZ,hZ;NZ.ForceGLSL=!1,function(Z){Z[Z.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",Z[Z.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(WZ||(WZ={})),function(Z){Z[Z.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",Z[Z.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",Z[Z.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(AZ||(AZ={})),function(Z){Z[Z.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",Z[Z.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",Z[Z.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",Z[Z.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",Z[Z.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(hZ||(hZ={}));class XZ extends mZ.d{constructor(Z,x,F){super(Z,x,null,null,!1,!1),this.name=Z,this._options=F,this._lazy=!1,this._updatable=!1,this._engine=x.getEngine(),this._lazy=F.lazy??!1,this._updatable=F.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=F.colorPointers??[],this._widths=F.widths??new Array(F.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(Z){let x=0;for(const u of this._points)x+=u.length;const F=x/3*2-this._widths.length;for(let u=0;u<F;u++)this._widths.push(Z)}updateLazy(){var Z,x;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(Z=this._options.ribbonOptions)||void 0===Z?void 0:Z.smoothShading),!this.eZ&&this.refreshBoundingInfo(),null===(x=this.greasedLineMaterial)||void 0===x||x.updateLazy()}addPoints(Z,x){for(const F of Z)this._points.push(F);this._lazy||this.setPoints(this._points,x)}dispose(Z){let x=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(Z,x)}isLazy(){return this._lazy}get vZ(){return this._uvs}set vZ(Z){this._uvs=Z instanceof Float32Array?Z:new Float32Array(Z),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(Z){this.material instanceof NZ&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===Z||void 0===Z?void 0:Z.length)>0),this._offsets=Z,this._offsetsBuffer?this._offsetsBuffer.update(Z):this._createOffsetsBuffer(Z)}get widths(){return this._widths}set widths(Z){this._widths=Z,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(Z)}get colorPointers(){return this._colorPointers}set colorPointers(Z){this._colorPointers=Z,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(Z)}get greasedLineMaterial(){var Z,x;if(this.material&&this.material instanceof NZ)return this.material;const F=null===(Z=this.material)||void 0===Z||null===(x=Z.pluginManager)||void 0===x?void 0:x.getPlugin(eZ.GREASED_LINE_MATERIAL_NAME);return F||void 0}get points(){const Z=[];return EZ.b.DeepCopy(this._points,Z),Z}setPoints(Z,x){this._points=lZ.ConvertPoints(Z,(null===x||void 0===x?void 0:x.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==x&&void 0!==x&&x.colorPointers||this._updateColorPointers(),this._setPoints(this._points,x)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,vZ:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(Z){super.serialize(Z),Z.type=this.getClassName(),Z.lineOptions=this._createLineOptions()}_createVertexBuffers(){let Z=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const x=new bZ.c;return x.qZ=this._vertexPositions,x.indices=this._indices,x.vZ=this._uvs,Z&&(x.RZ=[],bZ.c.ComputeNormals(this._vertexPositions,this._indices,x.RZ)),x.iZ(this,this._options.updatable),x}_createOffsetsBuffer(Z){const x=this._scene.getEngine(),F=new o.e(x,Z,this._updatable,3);this.setVerticesBuffer(F.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=F}}class DZ{constructor(Z,x){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=Z,this.wasAddedByNoopNode=x}getIndicesAccessor(Z,x,F,u,G){var f,Y,j,d;return null===(f=this._indicesAccessorMap.get(Z))||void 0===f||null===(Y=f.get(x))||void 0===Y||null===(j=Y.get(F))||void 0===j||null===(d=j.get(u))||void 0===d?void 0:d.get(G)}setIndicesAccessor(Z,x,F,u,G,f){let Y=this._indicesAccessorMap.get(Z);Y||(Y=new Map,this._indicesAccessorMap.set(Z,Y));let j=Y.get(x);j||(j=new Map,Y.set(x,j));let d=j.get(F);d||(d=new Map,j.set(F,d));let t=d.get(u);t||(t=new Map,d.set(u,t)),t.set(G,f)}pushExportedNode(Z){this._exportedNodes.has(Z)||this._exportedNodes.add(Z)}getNodesSet(){return this._exportedNodes}getVertexBufferView(Z){return this._vertexBufferViewMap.get(Z)}setVertexBufferView(Z,x){this._vertexBufferViewMap.set(Z,x)}setRemappedBufferView(Z,x,F){this._remappedBufferView.set(Z,new Map),this._remappedBufferView.get(Z).set(x,F)}getRemappedBufferView(Z,x){var F;return null===(F=this._remappedBufferView.get(Z))||void 0===F?void 0:F.get(x)}getVertexAccessor(Z,x,F){var u,G;return null===(u=this._vertexAccessorMap.get(Z))||void 0===u||null===(G=u.get(x))||void 0===G?void 0:G.get(F)}setVertexAccessor(Z,x,F,u){let G=this._vertexAccessorMap.get(Z);G||(G=new Map,this._vertexAccessorMap.set(Z,G));let f=G.get(x);f||(f=new Map,G.set(x,f)),f.set(F,u)}hasVertexColorAlpha(Z){return this._vertexMapColorAlpha.get(Z)||!1}setHasVertexColorAlpha(Z,x){return this._vertexMapColorAlpha.set(Z,x)}getMesh(Z){return this._meshMap.get(Z)}setMesh(Z,x){this._meshMap.set(Z,x)}bindMorphDataToMesh(Z,x){const F=this._meshMorphTargetMap.get(Z)||[];this._meshMorphTargetMap.set(Z,F),-1===F.indexOf(x)&&F.push(x)}getMorphTargetsFromMesh(Z){return this._meshMorphTargetMap.get(Z)}}class QZ{_ApplyExtension(Z,x,F,u){if(F>=x.length)return Promise.resolve(Z);const G=u(x[F],Z);return G?G.then((async Z=>Z?await this._ApplyExtension(Z,x,F+1,u):null)):this._ApplyExtension(Z,x,F+1,u)}_ApplyExtensions(Z,x){const F=[];for(const u of QZ._ExtensionNames)F.push(this._extensions[u]);return this._ApplyExtension(Z,F,0,x)}_extensionsPreExportTextureAsync(Z,x,F){return this._ApplyExtensions(x,((x,u)=>x.preExportTextureAsync&&x.preExportTextureAsync(Z,u,F)))}_extensionsPostExportNodeAsync(Z,x,F,u,G){return this._ApplyExtensions(x,((x,f)=>x.postExportNodeAsync&&x.postExportNodeAsync(Z,f,F,u,G,this._bufferManager)))}_extensionsPostExportMaterialAsync(Z,x,F){return this._ApplyExtensions(x,((x,u)=>x.postExportMaterialAsync&&x.postExportMaterialAsync(Z,u,F)))}_extensionsPostExportMaterialAdditionalTextures(Z,x,F){const u=[];for(const G of QZ._ExtensionNames){const f=this._extensions[G];f.postExportMaterialAdditionalTextures&&u.push(...f.postExportMaterialAdditionalTextures(Z,x,F))}return u}_extensionsPostExportTextures(Z,x,F){for(const u of QZ._ExtensionNames){const G=this._extensions[u];G.postExportTexture&&G.postExportTexture(Z,x,F)}}_extensionsPostExportMeshPrimitive(Z){for(const x of QZ._ExtensionNames){const F=this._extensions[x];F.postExportMeshPrimitive&&F.postExportMeshPrimitive(Z,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const Z of QZ._ExtensionNames){const x=this._extensions[Z];x.preGenerateBinaryAsync&&await x.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(Z){for(const x of QZ._ExtensionNames){const F=this._extensions[x];F.enabled&&Z(F)}}_extensionsOnExporting(){this._forEachExtensions((Z=>{var x,F,u;Z.wasUsed&&((x=this._glTF).extensionsUsed||(x.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(Z.name)&&this._glTF.extensionsUsed.push(Z.name),Z.required&&((F=this._glTF).extensionsRequired||(F.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(Z.name)&&this._glTF.extensionsRequired.push(Z.name)),(u=this._glTF).extensions||(u.extensions={}),Z.onExporting&&Z.onExporting())}))}_loadExtensions(){for(const Z of QZ._ExtensionNames){const x=QZ._ExtensionFactories[Z](this);this._extensions[Z]=x}}constructor(){let Z=arguments.length>0&&void 0!==arguments[0]?arguments[0]:U.c.LastCreatedScene,x=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${p.b.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new T(this),this._extensions={},this._bufferManager=new oZ,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!Z)throw new Error("No scene available to export");this._babylonScene=Z,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:Z=>{var x;return null===Z||void 0===Z||null===(x=Z.Cf)||void 0===x?void 0:x.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...x},this._loadExtensions()}dispose(){for(const Z in this._extensions){this._extensions[Z].dispose()}}get options(){return this._options}static RegisterExtension(Z,x){QZ.UnregisterExtension(Z)&&G.Tools.Warn(`Extension with the name ${Z} already exists`),QZ._ExtensionFactories[Z]=x,QZ._ExtensionNames.push(Z)}static UnregisterExtension(Z){if(!QZ._ExtensionFactories[Z])return!1;delete QZ._ExtensionFactories[Z];const x=QZ._ExtensionNames.indexOf(Z);return-1!==x&&QZ._ExtensionNames.splice(x,1),!0}_generateJSON(Z,x,F){const u={byteLength:Z};return u.byteLength&&(this._glTF.buffers=[u]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.mx=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(u.uri=x+".bin"),F?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(Z){const x=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(x.byteLength,Z,!0),u=new Blob([x],{type:"application/octet-stream"}),G=Z+".gltf",f=Z+".bin",Y=new t;if(Y.files[G]=F,Y.files[f]=u,this._imageData)for(const j in this._imageData)Y.files[j]=new Blob([this._imageData[j].data],{type:this._imageData[j].mimeType});return Y}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(Z){const x=Z%4;return 0===x?x:4-x}async generateGLBAsync(Z){this._shouldUseGlb=!0;const x=await this._generateBinaryAsync();this._extensionsOnExporting();const F=this._generateJSON(x.byteLength),u=Z+".glb";let G,f=F.length;if("undefined"!==typeof TextEncoder){G=(new TextEncoder).encode(F),f=G.length}const Y=this._getPadding(f),j=this._getPadding(x.byteLength),d=28+f+Y+x.byteLength+j,o=new dZ(d);if(o.writeUInt32(1179937895),o.writeUInt32(2),o.writeUInt32(d),o.writeUInt32(f+Y),o.writeUInt32(1313821514),G)o.writeTypedArray(G);else{const Z="_".charCodeAt(0);for(let x=0;x<f;++x){const u=F.charCodeAt(x);u!=F.codePointAt(x)?o.writeUInt8(Z):o.writeUInt8(u)}}for(let t=0;t<Y;++t)o.writeUInt8(32);o.writeUInt32(x.byteLength+j),o.writeUInt32(5130562),o.writeTypedArray(x);for(let t=0;t<j;++t)o.writeUInt8(0);const c=new t;return c.files[u]=new Blob([o.getOutputData()],{type:"application/octet-stream"}),c}_setNodeTransformation(Z,x,F){if(x.getPivotPoint().equalsWithEpsilon(X,h.e)||G.Tools.Warn("Pivot points are not supported in the glTF serializer"),!x.position.equalsWithEpsilon(X,h.e)){const G=u.TmpVectors.kx[0].G(x.position);F&&r(G),Z.translation=G.Wf()}x.pj.equalsWithEpsilon(Q,h.e)||(Z.scale=x.pj.Wf());const f=x.rotationQuaternion||u.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);f.equalsWithEpsilon(D,h.e)||(F&&z(f),Z.rotation=f.normalize().Wf())}_setCameraTransformation(Z,x,F){if(!x.position.equalsWithEpsilon(X,h.e)){const G=u.TmpVectors.kx[0].G(x.position);F&&r(G),Z.translation=G.Wf()}const G=x.rotationQuaternion||u.Quaternion.FromEulerAngles(x.rotation.x,x.rotation.y,x.rotation.z);F&&z(G),this._babylonScene.useRightHandedSystem||P(G),G.equalsWithEpsilon(D,h.e)||(Z.rotation=G.Wf())}_listAvailableCameras(){for(const Z of this._babylonScene.cameras){const x={type:Z.mode===sZ.c.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(Z.name&&(x.name=Z.name),"perspective"===x.type)x.perspective={aspectRatio:Z.getEngine().getAspectRatio(Z),yfov:Z.fovMode===sZ.c.FOVMODE_VERTICAL_FIXED?Z.fov:Z.fov*Z.getEngine().getAspectRatio(Z),znear:Z.hf,zfar:Z.maxZ};else if("orthographic"===x.type){const F=Z.orthoLeft&&Z.orthoRight?.5*(Z.orthoRight-Z.orthoLeft):.5*Z.getEngine().getRenderWidth(),u=Z.orthoBottom&&Z.orthoTop?.5*(Z.orthoTop-Z.orthoBottom):.5*Z.getEngine().getRenderHeight();x.orthographic={xmag:F,ymag:u,znear:Z.hf,zfar:Z.maxZ}}this._camerasMap.set(Z,x)}}_exportAndAssignCameras(){const Z=Array.from(this._camerasMap.values());for(const x of Z){const Z=this._nodesCameraMap.get(x);if(void 0!==Z){this._cameras.push(x);for(const x of Z)x.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const x={joints:[]};this._skinMap.set(Z,x)}}_exportAndAssignSkeletons(){for(const Z of this._babylonScene.skeletons){if(Z.bones.length<=0)continue;const x=this._skinMap.get(Z);if(void 0==x)continue;const F={},u=[];let f=-1;for(let G=0;G<Z.bones.length;++G){const x=Z.bones[G],u=x.getIndex()??G;-1!==u&&(F[u]=x,u>f&&(f=u))}for(let Z=0;Z<=f;++Z){const f=F[Z];u.push(f.getAbsoluteInverseBindMatrix());const Y=f.getTransformNode();if(null!==Y){const Z=this._nodeMap.get(Y);Y&&null!==Z&&void 0!==Z?x.joints.push(Z):G.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else G.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const Y=this._nodesSkinMap.get(x);if(x.joints.length>0&&void 0!==Y){const Z=64*u.length,F=new Float32Array(Z/4);u.forEach(((Z,x)=>{F.set(Z.m,16*x)}));const G=this._bufferManager.createBufferView(F);this._accessors.push(this._bufferManager.createAccessor(G,"MAT4",5126,u.length)),x.inverseBindMatrices=this._accessors.length-1,this._skins.push(x);for(const x of Y)x.skin=this._skins.length-1}}}async _exportSceneAsync(){const Z={nodes:[]};if(this._babylonScene.metadata){const x=this._options.metadataSelector(this._babylonScene.metadata);x&&(Z.extras=x)}const x=new Array,F=new Array,u=new Array;for(const j of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&YZ(j,this._babylonScene.useRightHandedSystem)?u.push(...j.getChildren()):this._babylonScene.useRightHandedSystem?x.push(j):F.push(j);this._listAvailableCameras(),this._listAvailableSkeletons();const G=new DZ(!0,!1);Z.nodes.push(...await this._exportNodesAsync(F,G));const f=new DZ(!1,!1);Z.nodes.push(...await this._exportNodesAsync(x,f));const Y=new DZ(!1,!0);Z.nodes.push(...await this._exportNodesAsync(u,Y)),Z.nodes.length&&this._scenes.push(Z),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&LZ._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,G.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(Z){let x=this._shouldExportNodeMap.get(Z);return void 0===x&&(x=this._options.shouldExportNode(Z),this._shouldExportNodeMap.set(Z,x)),x}async _exportNodesAsync(Z,x){const F=new Array;this._exportBuffers(Z,x);for(const u of Z)await this._exportNodeAsync(u,F,x);return F}_collectBuffers(Z,x,F,u,G){if(this._shouldExportNode(Z)&&Z instanceof s.c&&Z.af){const f=Z.af.getVertexBuffers();if(f)for(const u in f){if(!V(u))continue;const Y=f[u];G.setHasVertexColorAlpha(Y,Z.hasVertexAlpha);const j=Y._buffer,d=x.get(j)||[];x.set(j,d),-1===d.indexOf(Y)&&d.push(Y);const t=F.get(Y)||[];F.set(Y,t),-1===t.indexOf(Z)&&t.push(Z)}const Y=Z.morphTargetManager;if(Y)for(let x=0;x<Y.numTargets;x++){const F=Y.getTarget(x),G=u.get(F)||[];u.set(F,G),-1===G.indexOf(Z)&&G.push(Z)}}for(const f of Z.getChildren())this._collectBuffers(f,x,F,u,G)}_exportBuffers(Z,x){const F=new Map,u=new Map,G=new Map;for(const j of Z)this._collectBuffers(j,F,u,G,x);const f=Array.from(F.keys());for(const j of f){const Z=j.getData();if(!Z)throw new Error("Buffer data is not available");const G=F.get(j);if(!G)continue;const f=G[0].byteStride;if(G.some((Z=>Z.byteStride!==f)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const Y=FZ(Z).slice();for(const x of G){const Z=u.get(x),{byteOffset:F,byteStride:G,componentCount:f,type:j,count:d,normalized:t,kind:c}=O(x,Z);switch(c){case o.f.NormalKind:case o.f.TangentKind:(0,N.h)(Y,F,G,f,j,d,t,(Z=>{const x=Math.sqrt(Z[0]*Z[0]+Z[1]*Z[1]+Z[2]*Z[2]);if(x>0){const F=1/x;Z[0]*=F,Z[1]*=F,Z[2]*=F}}));break;case o.f.ColorKind:{const x=Z.filter((Z=>Z.material instanceof UZ.Cx||null==Z.material)).length;if(0==x)break;if(x!=Z.length){W.d.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}j==o.f.UNSIGNED_BYTE&&W.d.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const u=new k.Lx,c=new k.kj,s=this._babylonScene.getEngine().useExactSrgbConversions;(0,N.h)(Y,F,G,f,j,d,t,(Z=>{3===Z.length?(u.mF(Z,0),u.toLinearSpaceToRef(u,s),u.toArray(Z,0)):(c.mF(Z,0),c.toLinearSpaceToRef(c,s),c.toArray(Z,0))}))}}}if(x.convertToRightHanded){for(const Z of G){const x=u.get(Z),{byteOffset:F,byteStride:G,componentCount:f,type:j,count:d,normalized:t,kind:c}=O(Z,x);switch(c){case o.f.PositionKind:case o.f.NormalKind:case o.f.TangentKind:(0,N.h)(Y,F,G,f,j,d,t,(Z=>{Z[0]=-Z[0]}))}}x.convertedToRightHandedBuffers.set(j,Y)}const d=this._bufferManager.createBufferView(Y,f);x.setVertexBufferView(j,d);const t=new Map;for(const x of G){const Z=u.get(x),{kind:F,totalVertices:G}=O(x,Z);switch(F){case o.f.MatricesIndicesKind:case o.f.MatricesIndicesExtraKind:if(x.type==o.f.FLOAT){const Z=x.getFloatData(G);null!==Z&&t.set(x,Z)}}}0!==t.size&&W.d.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const c=Array.from(t.keys());for(const F of c){const Z=t.get(F);if(!Z)continue;const u=Z.some((Z=>Z>=256)),G=new(u?Uint16Array:Uint8Array)(Z.length);for(let x=0;x<Z.length;x++)G[x]=Z[x];const f=this._bufferManager.createBufferView(G,4*(u?2:1));x.setRemappedBufferView(j,F,f)}}const Y=Array.from(G.keys());for(const j of Y){const Z=G.get(j);if(!Z)continue;const F=HZ(j,Z[0],this._bufferManager,this._bufferViews,this._accessors,x.convertToRightHanded);for(const u of Z)x.bindMorphDataToMesh(u,F)}}async _exportNodeAsync(Z,x,F){let u=this._nodeMap.get(Z);if(void 0!==u)return void(x.includes(u)||x.push(u));const G=await this._createNodeAsync(Z,F);if(G){u=this._nodes.length,this._nodes.push(G),this._nodeMap.set(Z,u),F.pushExportedNode(Z),x.push(u);const f={name:"runtime animations",channels:[],samplers:[]},Y=[];this._babylonScene.animationGroups.length||(LZ._CreateMorphTargetAnimationFromMorphTargetAnimations(Z,f,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation),Z.animations.length&&LZ._CreateNodeAnimationFromNodeAnimations(Z,f,Y,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,F.convertToRightHanded,this._options.shouldExportAnimation)),f.channels.length&&f.samplers.length&&this._animations.push(f),Y.forEach((Z=>{Z.channels.length&&Z.samplers.length&&this._animations.push(Z)}))}const f=G?[]:x;for(const Y of Z.getChildren())await this._exportNodeAsync(Y,f,F);G&&f.length&&(G.children=f)}async _createNodeAsync(Z,x){if(!this._shouldExportNode(Z))return null;const F={};if(Z.name&&(F.name=Z.name),Z.metadata){const x=this._options.metadataSelector(Z.metadata);x&&(F.extras=x)}if(Z instanceof c.d&&(this._setNodeTransformation(F,Z,x.convertToRightHanded),Z instanceof s.c)){const G=Z instanceof J.d?Z.sourceMesh:Z;if(G.bf&&G.bf.length>0&&(F.mesh=await this._exportMeshAsync(G,x)),Z.skeleton){const x=this._skinMap.get(Z.skeleton);var u;if(void 0!==x)void 0===this._nodesSkinMap.get(x)&&this._nodesSkinMap.set(x,[]),null===(u=this._nodesSkinMap.get(x))||void 0===u||u.push(F)}}if(Z instanceof A.d){const u=this._camerasMap.get(Z);if(u){var G;void 0===this._nodesCameraMap.get(u)&&this._nodesCameraMap.set(u,[]),this._setCameraTransformation(F,Z,x.convertToRightHanded);const Y=Z.parent;if(null!==Y&&xZ(Z,Y)){const Z=this._nodeMap.get(Y);if(void 0!==Z){var f;const x=this._nodes[Z];return ZZ(F,x),null===(f=this._nodesCameraMap.get(u))||void 0===f||f.push(x),null}}null===(G=this._nodesCameraMap.get(u))||void 0===G||G.push(F)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",F,Z,this._nodeMap,x.convertToRightHanded)?F:(W.d.Warn(`Not exporting node ${Z.name}`),null)}_exportIndices(Z,x,F,u,G,Y,j,d,t){let o=Z;t.mode=a(Y);const c=j!==f.e.CounterClockWiseSideOrientation,s=!d.wasAddedByNoopNode&&c,J=function(Z){switch(Z){case f.e.TriangleFillMode:case f.e.TriangleStripDrawMode:case f.e.TriangleFanDrawMode:return!0}return!1}(Y)&&s;if(J){if(Y===f.e.TriangleStripDrawMode||Y===f.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");t.mode=a(Y);const j=x?new Uint32Array(u):new Uint16Array(u);if(Z)for(let x=0;x+2<u;x+=3)j[x]=Z[F+x]+G,j[x+1]=Z[F+x+2]+G,j[x+2]=Z[F+x+1]+G;else for(let Z=0;Z+2<u;Z+=3)j[Z]=Z,j[Z+1]=Z+2,j[Z+2]=Z+1;o=j}else if(Z&&0!==G){const f=x?new Uint32Array(u):new Uint16Array(u);for(let x=0;x<u;x++)f[x]=Z[F+x]+G;o=f}if(o){let f=d.getIndicesAccessor(Z,F,u,G,J);if(void 0===f){const Y=function(Z,x,F,u){if(Z instanceof Uint16Array||Z instanceof Uint32Array)return Z;if(Z instanceof Int32Array)return new Uint32Array(Z.buffer,Z.byteOffset,Z.length);const G=Z.slice(x,x+F);return u?new Uint32Array(G):new Uint16Array(G)}(o,0,u,x),j=this._bufferManager.createBufferView(Y),t=x?5125:5123;this._accessors.push(this._bufferManager.createAccessor(j,"SCALAR",t,u,0)),f=this._accessors.length-1,d.setIndicesAccessor(Z,F,u,G,J,f)}t.indices=f}}_exportVertexBuffer(Z,x,F,u,G,f){const Y=Z.getKind();if(!V(Y))return;if(Y.startsWith("uv")&&!this._options.exportUnusedUVs&&(!x||!this._materialNeedsUVsSet.has(x)))return;let j=G.getVertexAccessor(Z,F,u);if(void 0===j){const x=G.convertedToRightHandedBuffers.get(Z._buffer)||Z._buffer.getData(),f=Y===o.f.PositionKind?function(Z,x,F,u){const{byteOffset:G,byteStride:f,type:Y,normalized:j}=x,d=x.getSize(),t=new Array(d).fill(1/0),o=new Array(d).fill(-1/0);return(0,N.h)(Z,G+F*f,f,d,Y,u*d,j,(Z=>{for(let x=0;x<d;x++)t[x]=Math.min(t[x],Z[x]),o[x]=Math.max(o[x],Z[x])})),{min:t,max:o}}(x,Z,F,u):void 0,d=(Y===o.f.MatricesIndicesKind||Y===o.f.MatricesIndicesExtraKind)&&Z.type===o.f.FLOAT,t=d?o.f.UNSIGNED_BYTE:Z.type,c=d?void 0:Z.normalized,s=d?G.getRemappedBufferView(Z._buffer,Z):G.getVertexBufferView(Z._buffer),J=Z.byteOffset+F*Z.byteStride;this._accessors.push(this._bufferManager.createAccessor(s,function(Z,x){if(Z==o.f.ColorKind)return x?"VEC4":"VEC3";switch(Z){case o.f.PositionKind:case o.f.NormalKind:return"VEC3";case o.f.TangentKind:case o.f.MatricesIndicesKind:case o.f.MatricesIndicesExtraKind:case o.f.MatricesWeightsKind:case o.f.MatricesWeightsExtraKind:return"VEC4";case o.f.UVKind:case o.f.UV2Kind:case o.f.UV3Kind:case o.f.UV4Kind:case o.f.UV5Kind:case o.f.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${Z}`)}(Y,G.hasVertexColorAlpha(Z)),t,u,J,f,c)),j=this._accessors.length-1,G.setVertexAccessor(Z,F,u,j)}f.attributes[function(Z){switch(Z){case o.f.PositionKind:return"POSITION";case o.f.NormalKind:return"NORMAL";case o.f.TangentKind:return"TANGENT";case o.f.ColorKind:return"COLOR_0";case o.f.UVKind:return"TEXCOORD_0";case o.f.UV2Kind:return"TEXCOORD_1";case o.f.UV3Kind:return"TEXCOORD_2";case o.f.UV4Kind:return"TEXCOORD_3";case o.f.UV5Kind:return"TEXCOORD_4";case o.f.UV6Kind:return"TEXCOORD_5";case o.f.MatricesIndicesKind:return"JOINTS_0";case o.f.MatricesIndicesExtraKind:return"JOINTS_1";case o.f.MatricesWeightsKind:return"WEIGHTS_0";case o.f.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${Z}`)}(Y)]=j}async _exportMaterialAsync(Z,x,F,u){let G=this._materialMap.get(Z);if(void 0===G){const u=x&&Object.keys(x).some((Z=>Z.startsWith("uv")));if((Z=Z instanceof JZ.d?Z.Mj[F.materialIndex]:Z)instanceof pZ.c)G=await this._materialExporter.exportPBRMaterialAsync(Z,"image/png",u);else{if(!(Z instanceof UZ.Cx))return void W.d.Warn(`Unsupported material '${Z.name}' with type ${Z.getClassName()}`);G=await this._materialExporter.exportStandardMaterialAsync(Z,"image/png",u)}this._materialMap.set(Z,G)}u.material=G}async _exportMeshAsync(Z,x){var F;let u=x.getMesh(Z);if(void 0!==u)return u;const G={primitives:[]};u=this._meshes.length,this._meshes.push(G),x.setMesh(Z,u);const Y=Z.isUnIndexed?null:Z.cj(),j=null===(F=Z.af)||void 0===F?void 0:F.getVertexBuffers(),d=x.getMorphTargetsFromMesh(Z),t=Z instanceof SZ.e,o=Z instanceof XZ,c=Z.bf;if(j&&c&&c.length>0)for(const p of c){const F={attributes:{}},u=p.TZ()||this._babylonScene.defaultMaterial;if(o){var s,J;const x={name:u.name},G=Z,f=k.Lx.White(),Y=(null===(s=G.material)||void 0===s?void 0:s.alpha)??1,j=(null===(J=G.greasedLineMaterial)||void 0===J?void 0:J.color)??f;(!j.equalsWithEpsilon(f,h.e)||Y<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...j.Wf(),Y]}),this._materials.push(x),F.material=this._materials.length-1}else if(t){const x={name:u.name},G=Z;(!G.color.equalsWithEpsilon(k.Lx.White(),h.e)||G.alpha<1)&&(x.pbrMetallicRoughness={baseColorFactor:[...G.color.Wf(),G.alpha]}),this._materials.push(x),F.material=this._materials.length-1}else await this._exportMaterialAsync(u,j,p,F);const c=t||o?f.e.LineListDrawMode:Z.overrideRenderingFillMode??u.fillMode,U=u._getEffectiveOrientation(Z);this._exportIndices(Y,Y?(0,N.c)(Y,p.indexCount,p.indexStart,p.verticesStart):p.verticesCount>65535,Y?p.indexStart:p.verticesStart,Y?p.indexCount:p.verticesCount,-p.verticesStart,c,U,x,F);for(const Z of Object.values(j))this._exportVertexBuffer(Z,u,p.verticesStart,p.verticesCount,x,F);if(d){F.targets=[];for(const Z of d)F.targets.push(Z.attributes)}G.primitives.push(F),this._extensionsPostExportMeshPrimitive(F)}if(d){G.weights=[],G.extras||(G.extras={}),G.extras.targetNames=[];for(const Z of d)G.weights.push(Z.influence),G.extras.targetNames.push(Z.name)}return u}}QZ._ExtensionNames=new Array,QZ._ExtensionFactories={};class gZ{static async GLTFAsync(Z,x,F){F&&F.exportWithoutWaitingForScene||await Z.whenReadyAsync();const u=new QZ(Z,F),G=await u.generateGLTFAsync(x.replace(/\.[^/.]+$/,""));return u.dispose(),G}static async GLBAsync(Z,x,F){F&&F.exportWithoutWaitingForScene||await Z.whenReadyAsync();const u=new QZ(Z,F),G=await u.generateGLBAsync(x.replace(/\.[^/.]+$/,""));return u.dispose(),G}}F(11783);const OZ="EXT_mesh_gpu_instancing";class nZ{constructor(Z){this.name=OZ,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(Z,x,F,G,f,Y){return await new Promise((Z=>{if(x&&F instanceof mZ.d&&F.hasThinInstances&&this._exporter){this._wasUsed=!0;const Z=u.kx.Zero(),G=u.Quaternion.Identity(),j=u.kx.One(),d=F.thinInstanceGetWorldMatrices(),t=u.TmpVectors.kx[2],o=u.TmpVectors.Quaternion[1],c=u.TmpVectors.kx[3];let s=!1,J=!1,p=!1;const U=new Float32Array(3*F.mj),k=new Float32Array(4*F.mj),M=new Float32Array(3*F.mj);let m=0;for(const x of d)x.decompose(c,o,t),f&&(r(t),z(o)),U.set(t.Wf(),3*m),k.set(o.normalize().Wf(),4*m),M.set(c.Wf(),3*m),s=s||!t.equalsWithEpsilon(Z),J=J||!o.equalsWithEpsilon(G),p=p||!c.equalsWithEpsilon(j),m++;const C={attributes:{}};s&&(C.attributes.TRANSLATION=this._buildAccessor(U,"VEC3",F.mj,Y)),J&&(C.attributes.ROTATION=this._buildAccessor(k,"VEC4",F.mj,Y)),p&&(C.attributes.SCALE=this._buildAccessor(M,"VEC3",F.mj,Y)),x.extensions=x.extensions||{},x.extensions[OZ]=C}Z(x)}))}_buildAccessor(Z,x,F,u){const G=u.createBufferView(Z),f=u.createAccessor(G,x,5126,F);return this._exporter._accessors.push(f),this._exporter._accessors.length-1}}QZ.RegisterExtension(OZ,(Z=>new nZ(Z)));var VZ=F(11787),aZ=F(11799),IZ=F(11808),rZ=F(11817);function zZ(Z){return Z===IZ.d.PositionKind?"POSITION":Z===IZ.d.NormalKind?"NORMAL":Z===IZ.d.ColorKind?"COLOR":Z.startsWith(IZ.d.UVKind)?"TEX_COORD":"GENERIC"}const PZ={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class Zx extends VZ.d{static get DefaultAvailable(){return(0,VZ.i)(Zx.DefaultConfiguration)}static get Default(){return Zx._Default??(Zx._Default=new Zx),Zx._Default}static ResetDefault(Z){Zx._Default&&(Z||Zx._Default.dispose(),Zx._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(Z,x){return{module:await(x||DracoEncoderModule)({wasmBinary:Z})}}_getWorkerContent(){return`${aZ.j}(${aZ.k})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:Zx.DefaultConfiguration)}async _encodeAsync(Z,x,F){const u=F?(0,rZ.c)(PZ,F):PZ;if(this._workerPoolPromise){const F=await this._workerPoolPromise;return await new Promise(((G,f)=>{F.push(((F,Y)=>{const j=Z=>{F.removeEventListener("error",j),F.removeEventListener("message",d),f(Z),Y()},d=Z=>{"encodeMeshDone"===Z.data.id&&(F.removeEventListener("error",j),F.removeEventListener("message",d),G(Z.data.encodedMeshData),Y())};F.addEventListener("error",j),F.addEventListener("message",d);const t=[];for(const x of Z)t.push(x.data.buffer);x&&t.push(x.buffer),F.postMessage({id:"encodeMesh",attributes:Z,indices:x,options:u},t)}))}))}if(this._modulePromise){const F=await this._modulePromise;return(0,aZ.j)(F.module,Z,x,u)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(Z,x){if(0==Z.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");Z instanceof mZ.d&&Z.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===x||void 0===x?void 0:x.method)&&(W.d.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),x.method="MESH_SEQUENTIAL_ENCODING");const F=function(Z){let x=Z.cj(void 0,!0);return!x||x instanceof Uint32Array||x instanceof Uint16Array||(x=((0,N.c)(x,x.length)?Uint32Array:Uint16Array).from(x)),x}(Z),u=function(Z,x){const F=[];for(const u of Z.getVerticesDataKinds()){if(null!==x&&void 0!==x&&x.includes(u)){if(u===IZ.d.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const G=Z.getVertexBuffer(u),f=G.getSize(),Y=(0,N.q)(G.getData(),f,G.type,G.byteOffset,G.byteStride,G.normalized,Z.getTotalVertices(),!0);F.push({kind:u,dracoName:zZ(u),size:f,data:Y})}return F}(Z,null===x||void 0===x?void 0:x.excludedAttributes);return await this._encodeAsync(u,F,x)}}Zx.DefaultConfiguration={wasmUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${G.Tools._DefaultCdnUrl}/draco_encoder.js`},Zx._Default=null;const xx="KHR_draco_mesh_compression";class Fx{get wasUsed(){return this._wasUsed}constructor(Z){this.name=xx,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===Z.options.meshCompressionMethod&&Zx.DefaultAvailable}dispose(){}postExportMeshPrimitive(Z,x,F){if(!this.enabled)return;if(4!==Z.mode&&5!==Z.mode)return void W.d.Warn("Cannot compress primitive with mode "+Z.mode+".");const u=[],G=[];let f=null;if(void 0!==Z.indices){const Y=F[Z.indices],j=x.getBufferView(Y);f=x.getData(j).slice(),u.push(j),G.push(Y)}const Y=[];for(const[o,c]of Object.entries(Z.attributes)){const Z=F[c],f=x.getBufferView(Z),d=n(Z.type),t=(0,N.q)(x.getData(f),d,Z.componentType,Z.byteOffset||0,f.byteStride||(0,N.m)(Z.componentType)*d,Z.normalized||!1,Z.count,!0);Y.push({kind:o,dracoName:(j=o,"POSITION"===j?"POSITION":"NORMAL"===j?"NORMAL":j.startsWith("COLOR")?"COLOR":j.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:n(Z.type),data:t}),u.push(f),G.push(Z)}var j;const d={method:Z.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},t=Zx.Default._encodeAsync(Y,f,d).then((F=>{if(!F)return void W.d.Error("Draco encoding failed for primitive.");const f={bufferView:-1,attributes:F.attributeIds},Y=x.createBufferView(F.data);x.setBufferView(f,Y);for(const Z of u)this._bufferViewsUsed.add(Z);for(const Z of G)this._accessorsUsed.add(Z);Z.extensions||(Z.extensions={}),Z.extensions[xx]=f})).catch((Z=>{W.d.Error("Draco encoding failed for primitive: "+Z)}));this._encodePromises.push(t),this._wasUsed=!0}async preGenerateBinaryAsync(Z){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((x=>{Z.getPropertiesWithBufferView(x).every((Z=>this._accessorsUsed.has(Z)))&&Z.removeBufferView(x)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}QZ.RegisterExtension(xx,(Z=>new Fx(Z)));var ux=F(11820);const Gx="KHR_lights_punctual",fx={name:"",color:[1,1,1],Cj:1,range:Number.MAX_VALUE},Yx={innerConeAngle:0,outerConeAngle:Math.PI/4},jx=u.kx.Backward();class dx{constructor(Z){this.name=Gx,this.enabled=!0,this.required=!1,this._exporter=Z}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[Gx]=this._lights}async postExportNodeAsync(Z,x,F,G,f){return await new Promise((Y=>{if(!(F instanceof CZ.e))return void Y(x);const j=F.getTypeID()==CZ.e.LIGHTTYPEID_POINTLIGHT?"point":F.getTypeID()==CZ.e.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":F.getTypeID()==CZ.e.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!j||!(F instanceof ux.e))return W.d.Warn(`${Z}: Light ${F.name} is not supported in ${Gx}`),void Y(x);if(F.falloffType!==CZ.e.FALLOFF_GLTF&&W.d.Warn(`${Z}: Light falloff for ${F.name} does not match the ${Gx} specification!`),!F.position.equalsToFloats(0,0,0)){const Z=u.TmpVectors.kx[0].G(F.position);f&&r(Z),x.translation=Z.Wf()}if("point"!==j){const Z=F.direction.normalizeToRef(u.TmpVectors.kx[0]);f&&r(Z);const G=u.Quaternion.FromUnitVectorsToRef(jx,Z,u.TmpVectors.Quaternion[0]);u.Quaternion.IsIdentity(G)||(x.rotation=G.Wf())}const d={type:j,name:F.name,color:F.Lj.Wf(),Cj:F.Cj,range:F.range};if(uZ(d,fx),"spot"===j){const Z=F;d.spot={innerConeAngle:Z.innerAngle/2,outerConeAngle:Z.angle/2},uZ(d.spot,Yx)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(d);const t={jf:this._lights.lights.length-1},o=F.parent;if(o&&xZ(F,o)){const Z=G.get(o);if(Z){const F=this._exporter._nodes[Z];return ZZ(x,F),F.extensions||(F.extensions={}),F.extensions[Gx]=t,void Y(null)}}x.extensions||(x.extensions={}),x.extensions[Gx]=t,Y(x)}))}}QZ.RegisterExtension(Gx,(Z=>new dx(Z)));var tx=F(11725);const ox="KHR_materials_anisotropy";class cx{constructor(Z){this.name=ox,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof tx.e&&F.anisotropy.isEnabled&&!F.anisotropy.legacy?(F.anisotropy.texture&&u.push(F.anisotropy.texture),u):[]}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof tx.e){if(!F.anisotropy.isEnabled||F.anisotropy.legacy)return void Z(x);this._wasUsed=!0,x.extensions=x.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(F.anisotropy.texture),G={anisotropyStrength:F.anisotropy.Cj,anisotropyRotation:F.anisotropy.angle,anisotropyTexture:u??void 0};null!==G.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(F),x.extensions[ox]=G}Z(x)}))}}QZ.RegisterExtension(ox,(Z=>new cx(Z)));const sx="KHR_materials_clearcoat";class Jx{constructor(Z){this.name=sx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof tx.e&&F.clearCoat.isEnabled?(F.clearCoat.texture&&u.push(F.clearCoat.texture),!F.clearCoat.useRoughnessFromMainTexture&&F.clearCoat.textureRoughness&&u.push(F.clearCoat.textureRoughness),F.clearCoat.bumpTexture&&u.push(F.clearCoat.bumpTexture),u):[]}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof tx.e){if(!F.clearCoat.isEnabled)return void Z(x);this._wasUsed=!0,x.extensions=x.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture);let f;f=F.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(F.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(F.clearCoat.textureRoughness),F.clearCoat.isTintEnabled&&G.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${F.name}`),F.clearCoat.remapF0OnInterfaceChange&&G.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${F.name}`);const Y=this._exporter._materialExporter.getTextureInfo(F.clearCoat.bumpTexture),j={clearcoatFactor:F.clearCoat.Cj,clearcoatTexture:u??void 0,clearcoatRoughnessFactor:F.clearCoat.roughness,clearcoatRoughnessTexture:f??void 0,clearcoatNormalTexture:Y??void 0};null===j.clearcoatTexture&&null===j.clearcoatRoughnessTexture&&null===j.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),x.extensions[sx]=j}Z(x)}))}}QZ.RegisterExtension(sx,(Z=>new Jx(Z)));const px="KHR_materials_diffuse_transmission";function Ux(Z,x){const F=x.subSurface;let u=null;return F.translucencyIntensityTexture?u=F.translucencyIntensityTexture:F.thicknessTexture&&F.useMaskFromThicknessTexture&&(u=F.thicknessTexture),u&&!F.useGltfStyleTextures?(W.d.Warn(`${Z}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${x.name}`,1),null):u}class kx{constructor(Z){this.name=px,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];if(F instanceof pZ.c&&this._isExtensionEnabled(F)){const x=Ux(Z,F);return x&&u.push(x),F.subSurface.translucencyColorTexture&&u.push(F.subSurface.translucencyColorTexture),u}return u}_isExtensionEnabled(Z){if(Z.unlit)return!1;const x=Z.subSurface;return!!x.isTranslucencyEnabled&&(!Z.unlit&&!x.useAlbedoToTintTranslucency&&x.useGltfStyleTextures&&1===x.volumeIndexOfRefraction&&0===x.minimumThickness&&0===x.maximumThickness)}postExportMaterialAsync(Z,x,F){return new Promise((u=>{if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const u=F.subSurface,G=Ux(Z,F),f=0==u.translucencyIntensity?void 0:u.translucencyIntensity,Y=this._exporter._materialExporter.getTextureInfo(G)??void 0,j=!u.translucencyColor||u.translucencyColor.equalsFloats(1,1,1)?void 0:u.translucencyColor.Wf(),d=this._exporter._materialExporter.getTextureInfo(u.translucencyColorTexture)??void 0,t={diffuseTransmissionFactor:f,diffuseTransmissionTexture:Y,diffuseTransmissionColorFactor:j,diffuseTransmissionColorTexture:d};(Y||d)&&this._exporter._materialNeedsUVsSet.add(F),x.extensions=x.extensions||{},x.extensions[px]=t}u(x)}))}}QZ.RegisterExtension(px,(Z=>new kx(Z)));const Mx="KHR_materials_dispersion";class mx{constructor(){this.name=Mx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){if(Z.unlit)return!1;const x=Z.subSurface;return!(!x.isRefractionEnabled&&!x.isDispersionEnabled)}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const Z={dispersion:F.subSurface.dispersion};x.extensions=x.extensions||{},x.extensions[Mx]=Z}Z(x)}))}}QZ.RegisterExtension(Mx,(()=>new mx));const Cx="KHR_materials_emissive_strength";class Lx{constructor(){this.name=Cx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(Z,x,F){return await new Promise((Z=>{if(!(F instanceof pZ.c))return Z(x);const u=F.emissiveColor.Wf(),G=Math.max(...u);if(G>1){this._wasUsed=!0,x.extensions||(x.extensions={});const Z={emissiveStrength:G},u=F.emissiveColor.scale(1/Z.emissiveStrength);x.emissiveFactor=u.Wf(),x.extensions[Cx]=Z}return Z(x)}))}}QZ.RegisterExtension(Cx,(Z=>new Lx));const Hx="KHR_materials_ior";class Sx{constructor(){this.name=Hx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.indexOfRefraction&&1.5!=Z.indexOfRefraction)}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const Z={ior:F.indexOfRefraction};x.extensions=x.extensions||{},x.extensions[Hx]=Z}Z(x)}))}}QZ.RegisterExtension(Hx,(Z=>new Sx));const Kx="KHR_materials_iridescence";class yx{constructor(Z){this.name=Kx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof tx.e&&F.iridescence.isEnabled?(F.iridescence.texture&&u.push(F.iridescence.texture),F.iridescence.thicknessTexture&&F.iridescence.thicknessTexture!==F.iridescence.texture&&u.push(F.iridescence.thicknessTexture),u):[]}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof tx.e){if(!F.iridescence.isEnabled)return void Z(x);this._wasUsed=!0,x.extensions=x.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(F.iridescence.texture),G=this._exporter._materialExporter.getTextureInfo(F.iridescence.thicknessTexture),f={iridescenceFactor:F.iridescence.Cj,iridescenceIor:F.iridescence.indexOfRefraction,iridescenceThicknessMinimum:F.iridescence.minimumThickness,iridescenceThicknessMaximum:F.iridescence.maximumThickness,iridescenceTexture:u??void 0,iridescenceThicknessTexture:G??void 0};null===f.iridescenceTexture&&null===f.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(F),x.extensions[Kx]=f}Z(x)}))}}QZ.RegisterExtension(Kx,(Z=>new yx(Z)));const qx="KHR_materials_sheen";class Rx{constructor(Z){this.name=qx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){return F instanceof pZ.c&&F.sheen.isEnabled&&F.sheen.texture?[F.sheen.texture]:[]}async postExportMaterialAsync(Z,x,F){return await new Promise((Z=>{if(F instanceof pZ.c){if(!F.sheen.isEnabled)return void Z(x);this._wasUsed=!0,null==x.extensions&&(x.extensions={});const u={sheenColorFactor:F.sheen.color.Wf(),sheenRoughnessFactor:F.sheen.roughness??0};null===u.sheenColorTexture&&null===u.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(F),F.sheen.texture&&(u.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),F.sheen.textureRoughness&&!F.sheen.useRoughnessFromMainTexture?u.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.textureRoughness)??void 0:F.sheen.texture&&F.sheen.useRoughnessFromMainTexture&&(u.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(F.sheen.texture)??void 0),x.extensions[qx]=u}Z(x)}))}}QZ.RegisterExtension(qx,(Z=>new Rx(Z)));const Bx="KHR_materials_specular";class vx{constructor(Z){this.name=Bx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof pZ.c&&this._isExtensionEnabled(F)?(F.metallicReflectanceTexture&&u.push(F.metallicReflectanceTexture),F.reflectanceTexture&&u.push(F.reflectanceTexture),u):u}_isExtensionEnabled(Z){return!Z.unlit&&(void 0!=Z.metallicF0Factor&&1!=Z.metallicF0Factor||void 0!=Z.metallicReflectanceColor&&!Z.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.metallicReflectanceTexture||null!=Z.reflectanceTexture}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0,x.extensions=x.extensions||{};const Z=this._exporter._materialExporter.getTextureInfo(F.metallicReflectanceTexture)??void 0,u=this._exporter._materialExporter.getTextureInfo(F.reflectanceTexture)??void 0,G={specularFactor:1==F.metallicF0Factor?void 0:F.metallicF0Factor,specularTexture:Z,specularColorFactor:F.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:F.metallicReflectanceColor.Wf(),specularColorTexture:u};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),x.extensions[Bx]=G}Z(x)}))}}QZ.RegisterExtension(Bx,(Z=>new vx(Z)));const lx="KHR_materials_transmission";class ix{constructor(Z){this.name=lx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof pZ.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&u.push(F.subSurface.thicknessTexture),u):u}_isExtensionEnabled(Z){if(Z.unlit)return!1;const x=Z.subSurface;return x.isRefractionEnabled&&void 0!=x.refractionIntensity&&0!=x.refractionIntensity||this._hasTexturesExtension(Z)}_hasTexturesExtension(Z){return null!=Z.subSurface.refractionIntensityTexture}async postExportMaterialAsync(Z,x,F){if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const u=F.subSurface,G={transmissionFactor:0===u.refractionIntensity?void 0:u.refractionIntensity};if(this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),u.refractionIntensityTexture)if(u.useGltfStyleTextures){const Z=await this._exporter._materialExporter.exportTextureAsync(u.refractionIntensityTexture,"image/png");Z&&(G.transmissionTexture=Z)}else W.d.Warn(`${Z}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);x.extensions||(x.extensions={}),x.extensions[lx]=G}return x}}QZ.RegisterExtension(lx,(Z=>new ix(Z)));const ex="KHR_materials_unlit";class bx{constructor(){this.name=ex,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{let u=!1;F instanceof pZ.c?u=F.unlit:F instanceof UZ.Cx&&(u=F.disableLighting),u&&(this._wasUsed=!0,null==x.extensions&&(x.extensions={}),x.extensions[ex]={}),Z(x)}))}}QZ.RegisterExtension(ex,(()=>new bx));const Ex="KHR_materials_volume";class wx{constructor(Z){this.name=Ex,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof pZ.c&&this._isExtensionEnabled(F)?(F.subSurface.thicknessTexture&&u.push(F.subSurface.thicknessTexture),u):u}_isExtensionEnabled(Z){if(Z.unlit)return!1;const x=Z.subSurface;return!(!x.isRefractionEnabled&&!x.isTranslucencyEnabled)&&(void 0!=x.maximumThickness&&0!=x.maximumThickness||void 0!=x.tintColorAtDistance&&x.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=x.tintColor&&x.tintColor!=k.Lx.White()||this._hasTexturesExtension(Z))}_hasTexturesExtension(Z){return null!=Z.subSurface.thicknessTexture}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof pZ.c&&this._isExtensionEnabled(F)){this._wasUsed=!0;const Z=F.subSurface,u={thicknessFactor:0==Z.maximumThickness?void 0:Z.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(Z.thicknessTexture)??void 0,attenuationDistance:Z.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:Z.tintColorAtDistance,attenuationColor:Z.tintColor.equalsFloats(1,1,1)?void 0:Z.tintColor.Wf()};this._hasTexturesExtension(F)&&this._exporter._materialNeedsUVsSet.add(F),x.extensions=x.extensions||{},x.extensions[Ex]=u}Z(x)}))}}QZ.RegisterExtension(Ex,(Z=>new wx(Z)));const Tx="EXT_materials_diffuse_roughness";class Nx{constructor(Z){this.name=Tx,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=Z}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(Z,x,F){const u=[];return F instanceof tx.e&&F._baseDiffuseRoughness?(F._baseDiffuseRoughnessTexture&&u.push(F._baseDiffuseRoughnessTexture),u):[]}postExportMaterialAsync(Z,x,F){return new Promise((Z=>{if(F instanceof tx.e){if(!F._baseDiffuseRoughness)return void Z(x);this._wasUsed=!0,x.extensions=x.extensions||{};const u=this._exporter._materialExporter.getTextureInfo(F._baseDiffuseRoughnessTexture),G={diffuseRoughnessFactor:F._baseDiffuseRoughness,diffuseRoughnessTexture:u??void 0};null!==G.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(F),x.extensions[Tx]=G}Z(x)}))}}QZ.RegisterExtension(Tx,(Z=>new Nx(Z)));const Wx="KHR_texture_transform";class Ax{constructor(){this.name=Wx,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(Z,x,F){if(F.KZ()||G.Tools.Warn(`${Z}: /*@__KEY__*/"scene" is not defined for Babylon texture ${F.name}!`),(0!==F.uAng||0!==F.vAng)&&(G.Tools.Warn(`${Z}: Texture ${F.name} with rotation in the u or v axis is not supported in glTF.`),0!==F.uRotationCenter||0!==F.vRotationCenter))return;const u={};let f=!1;if(0===F.uOffset&&0===F.vOffset||(u.offset=[F.uOffset,F.vOffset],f=!0),1===F.uScale&&1===F.vScale||(u.scale=[F.uScale,F.vScale],f=!0),0!==F.wAng){if(0!==F.uRotationCenter||0!==F.vRotationCenter){if(F.homogeneousRotationInUVTransform&&F.uScale!==F.vScale)return void G.Tools.Warn(`${Z}: Texture ${F.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${Wx}.`);G.Tools.Warn(`${Z}: Texture ${F.name} with non-origin rotation center will be exported using an adjusted offset with ${Wx}.`),u.offset=function(Z){const{uOffset:x,vOffset:F,uRotationCenter:u,vRotationCenter:G,uScale:f,vScale:Y,wAng:j}=Z,d=Math.cos(j),t=Math.sin(j),o=u*f,c=G*Y;return[x+(o*(1-d)+c*t),F+(c*(1-d)-o*t)]}(F)}u.rotation=-F.wAng,f=!0}0!==F.coordinatesIndex&&(u.texCoord=F.coordinatesIndex,f=!0),f&&(this._wasUsed=!0,x.extensions||(x.extensions={}),x.extensions[Wx]=u)}}QZ.RegisterExtension(Wx,(()=>new Ax));class hx{static CreateSTL(Z){let x=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",G=arguments.length>3&&void 0!==arguments[3]&&arguments[3],f=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],Y=arguments.length>5&&void 0!==arguments[5]&&arguments[5],j=arguments.length>6&&void 0!==arguments[6]&&arguments[6],d=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const t=function(Z,x,F){const G=[3*Z[F],3*Z[F+1],3*Z[F+2]],f=[new u.kx(x[G[0]],x[G[0]+2],x[G[0]+1]),new u.kx(x[G[1]],x[G[1]+2],x[G[1]+1]),new u.kx(x[G[2]],x[G[2]+2],x[G[2]+1])],Y=f[0].Mx(f[1]),j=f[2].Mx(f[1]);return{v:f,n:u.kx.Cross(j,Y).normalize()}},c=function(Z,x,F,u){return x=s(Z,x,F.x,u),x=s(Z,x,F.y,u),s(Z,x,F.z,u)},s=function(Z,x,F,u){return Z.setFloat32(x,F,u),x+4},p=function(Z){if(j){let x=Z;Z instanceof J.d&&(x=Z.sourceMesh);const F=x.getVerticesData(o.f.PositionKind,!0,!0);if(!F)return[];const G=u.kx.Zero();let f;for(f=0;f<F.length;f+=3)u.kx.TransformCoordinatesFromFloatsToRef(F[f],F[f+1],F[f+2],Z.Qf(!0),G).toArray(F,f);return F}return Z.getVerticesData(o.f.PositionKind)||[]};j&&(Y=!0);let U="",k=0,M=0;if(G){for(let F=0;F<Z.length;F++){const x=Z[F].cj();k+=x?x.length/3:0}const x=new ArrayBuffer(84+50*k);U=new DataView(x),M+=80,U.setUint32(M,k,f),M+=4}else d||(U="solid stlmesh\r\n");for(let u=0;u<Z.length;u++){const x=Z[u];!G&&d&&(U+="solid "+x.name+"\r\n"),!Y&&x instanceof mZ.d&&x.bakeCurrentTransformIntoVertices();const F=p(x),j=x.cj()||[];for(let Z=0;Z<j.length;Z+=3){const x=t(j,F,Z);G?(M=c(U,M,x.n,f),M=c(U,M,x.v[0],f),M=c(U,M,x.v[1],f),M=c(U,M,x.v[2],f),M+=2):(U+="\tfacet normal "+x.n.x+" "+x.n.y+" "+x.n.z+"\r\n",U+="\t\touter loop\r\n",U+="\t\t\tvertex "+x.v[0].x+" "+x.v[0].y+" "+x.v[0].z+"\r\n",U+="\t\t\tvertex "+x.v[1].x+" "+x.v[1].y+" "+x.v[1].z+"\r\n",U+="\t\t\tvertex "+x.v[2].x+" "+x.v[2].y+" "+x.v[2].z+"\r\n",U+="\t\tendloop\r\n",U+="\tendfacet\r\n")}!G&&d&&(U+="endsolid "+name+"\r\n")}if(G||d||(U+="endsolid stlmesh"),x){const Z=document.createElement("a"),x=new Blob([U],{type:"application/octet-stream"});Z.href=window.URL.createObjectURL(x),Z.download=F+".stl",Z.click()}return U}}function Xx(Z,x){let F=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const u=[];for(let G=0;G<Z.length/F;G++){const f=Z[G*F],Y=Z[G*F+1],j=Z[G*F+2];u.push(`(${f.toPrecision(x.precision)}, ${Y.toPrecision(x.precision)}, ${j.toPrecision(x.precision)})`)}return u.join(", ")}function Dx(Z,x){const F=[];for(let u=0;u<Z.length/2;u++){const G=Z[2*u],f=Z[2*u+1];F.push(`(${G.toPrecision(x.precision)}, ${(1-f).toPrecision(x.precision)})`)}return F.join(", ")}function Qx(Z,x){const F=Z.getVerticesData(o.f.PositionKind),u=Z.getVerticesData(o.f.NormalKind);if(F&&u)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(Z){var x;const F=null!==(x=Z.cj())&&void 0!==x&&x.length?Z.getTotalIndices():Z.getTotalVertices();return Array(F/3).fill(3).join(", ")}(Z)}]\n\t\tint[] faceVertexIndices = [${function(Z){const x=Z.cj(),F=[];if(null!==x)for(let u=0;u<x.length;u++)F.push(x[u]);else{const x=Z.getTotalVertices();for(let Z=0;Z<x;Z++)F.push(Z)}return F.join(", ")}(Z)}]\n\t\tnormal3f[] normals = [${Xx(u,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${Xx(F,x)}]\n        ${function(Z,x){let F="";for(let G=0;G<4;G++){const u=G>0?G:"",f=Z.getVerticesData(o.f.UVKind+(u?u+1:""));f&&(F+=`\n\t\ttexCoord2f[] primvars:st${u} = [${Dx(f,x)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const u=Z.getVerticesData(o.f.ColorKind);return u&&(F+=`\n\tcolor3f[] primvars:displayColor = [${Xx(u,x,u.length/Z.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),F}(Z,x)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function gx(Z,x){return`\n        def "Geometry"\n        {\n        ${Qx(Z,x)}\n        }\n        `}function Ox(Z){let x='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return x+=Z,fflate.strToU8(x)}function nx(Z){const x=Z.m;return`( ${Vx(x,0)}, ${Vx(x,4)}, ${Vx(x,8)}, ${Vx(x,12)} )`}function Vx(Z,x){return`(${Z[x+0]}, ${Z[x+1]}, ${Z[x+2]}, ${Z[x+3]})`}function ax(Z){const x="Object_"+Z.uniqueId,F=function(Z){const x=Z.getWorldMatrix().clone(),F=Z.KZ().useRightHandedSystem;if(!F){let u=Z.parent;for(;u;){if(YZ(u,F)){x.multiplyToRef(u.getWorldMatrix().invert(),x);break}u=u.parent}}return x.determinant()<0&&G.Tools.Warn(`Exporting mesh ${Z.name} with negative scale. Result may look incorrect in destination engine.`),x}(Z),u=nx(F);return`def Xform "${x}" (\n\tprepend references = @./geometries/Geometry_${Z.af.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${u}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${Z.material.uniqueId}>\n}\n\n`}function Ix(Z){switch(Z){case K.e.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case K.e.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case K.e.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function rx(Z){return`(${Z.x}, ${Z.y})`}function zx(Z){return`(${Z.r}, ${Z.g}, ${Z.b})`}function Px(Z,x,F,G,f,Y){const j=Z.getInternalTexture().uniqueId+"_"+Z.invertY;f[j]=Z;const d=Z.coordinatesIndex>0?"st"+Z.coordinatesIndex:"st",t=new u.Vector2(Z.uScale,Z.vScale),o=new u.Vector2(Z.uOffset,Z.vOffset),c=Z.wAng,s=Math.sin(c),J=Math.cos(c);return o.y=1-o.y-t.y,o.x+=s*t.x,o.y+=(1-J)*t.y,`\n    def Shader "PrimvarReader_${F}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${d}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${F}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${x.uniqueId}/PrimvarReader_${F}.outputs:result>\n        float inputs:rotation = ${(c*(180/Math.PI)).toFixed(Y.precision)}\n        float2 inputs:scale = ${rx(t)}\n        float2 inputs:translation = ${rx(o)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${Z.uniqueId}_${F}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${j}.png@\n        float2 inputs:st.connect = </Materials/Material_${x.uniqueId}/Transform2d_${F}.outputs:result>\n        ${G?"float4 inputs:scale = "+function(Z){return`(${Z.r}, ${Z.g}, ${Z.b}, 1.0)`}(G):""}\n        token inputs:sourceColorSpace = "${Z.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${Ix(Z.wrapU)}"\n        token inputs:wrapT = "${Ix(Z.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${x.needAlphaBlending()?"float outputs:a":""}\n    }`}function ZF(Z,x,F){const u="\t\t\t",G=[],f=[],{diffuseMap:Y,Lj:j,alphaCutOff:d,emissiveMap:t,emissive:o,normalMap:c,roughnessMap:s,roughnessChannel:J,roughness:p,metalnessMap:U,metalnessChannel:M,metalness:m,aoMap:C,aoMapChannel:L,aoMapIntensity:H,alphaMap:S,ior:K,clearCoatEnabled:y,clearCoat:q,clearCoatMap:R,clearCoatRoughness:B,clearCoatRoughnessMap:v}=function(Z){const x={diffuseMap:null,Lj:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return Z instanceof UZ.Cx?{...x,diffuseMap:Z.diffuseTexture,Lj:Z.diffuseColor,alphaCutOff:Z.alphaCutOff,emissiveMap:Z.emissiveTexture,emissive:Z.emissiveColor,roughness:1,alphaMap:Z.opacityTexture}:Z instanceof tx.e?{...x,diffuseMap:Z._albedoTexture,Lj:Z._albedoColor,alphaCutOff:Z._alphaCutOff,emissiveMap:Z._emissiveTexture,emissive:Z._emissiveColor,normalMap:Z._bumpTexture,roughnessMap:Z._metallicTexture,roughnessChannel:Z._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:Z._roughness??1,metalnessMap:Z._metallicTexture,metalnessChannel:Z._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:Z._metallic??0,aoMap:Z._ambientTexture,aoMapChannel:Z._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:Z._ambientTextureStrength,alphaMap:Z._opacityTexture,ior:Z.subSurface.indexOfRefraction,clearCoatEnabled:Z.clearCoat.isEnabled,clearCoat:Z.clearCoat.Cj,clearCoatMap:Z.clearCoat.texture,clearCoatRoughness:Z.clearCoat.roughness,clearCoatRoughnessMap:Z.clearCoat.useRoughnessFromMainTexture?Z.clearCoat.texture:Z.clearCoat.textureRoughness}:x}(Z);return null!==Y?(G.push(`${u}color3f inputs:diffuseColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:rgb>`),Z.needAlphaBlending()?G.push(`${u}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`):Z.needAlphaTesting()&&(G.push(`${u}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${Y.uniqueId}_diffuse.outputs:a>`),G.push(`${u}float inputs:opacityThreshold = ${d}`)),f.push(Px(Y,Z,"diffuse",j,x,F))):G.push(`${u}color3f inputs:diffuseColor = ${zx(j||k.Lx.White())}`),null!==t?(G.push(`${u}color3f inputs:emissiveColor.connect = </Materials/Material_${Z.uniqueId}/Texture_${t.uniqueId}_emissive.outputs:rgb>`),f.push(Px(t,Z,"emissive",o,x,F))):o&&o.toLuminance()>0&&G.push(`${u}color3f inputs:emissiveColor = ${zx(o)}`),null!==c&&(G.push(`${u}normal3f inputs:normal.connect = </Materials/Material_${Z.uniqueId}/Texture_${c.uniqueId}_normal.outputs:rgb>`),f.push(Px(c,Z,"normal",null,x,F))),null!==C&&(G.push(`${u}float inputs:occlusion.connect = </Materials/Material_${Z.uniqueId}/Texture_${C.uniqueId}_occlusion.outputs:${L}>`),f.push(Px(C,Z,"occlusion",new k.Lx(H,H,H),x,F))),null!==s?(G.push(`${u}float inputs:roughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${s.uniqueId}_roughness.outputs:${J}>`),f.push(Px(s,Z,"roughness",new k.Lx(p,p,p),x,F))):G.push(`${u}float inputs:roughness = ${p}`),null!==U?(G.push(`${u}float inputs:metallic.connect = </Materials/Material_${Z.uniqueId}/Texture_${U.uniqueId}_metallic.outputs:${M}>`),f.push(Px(U,Z,"metallic",new k.Lx(m,m,m),x,F))):G.push(`${u}float inputs:metallic = ${m}`),null!==S?(G.push(`${u}float inputs:opacity.connect = </Materials/Material_${Z.uniqueId}/Texture_${S.uniqueId}_opacity.outputs:r>`),G.push(`${u}float inputs:opacityThreshold = 0.0001`),f.push(Px(S,Z,"opacity",null,x,F))):G.push(`${u}float inputs:opacity = ${Z.alpha}`),y&&(null!==R?(G.push(`${u}float inputs:clearcoat.connect = </Materials/Material_${Z.uniqueId}/Texture_${R.uniqueId}_clearcoat.outputs:r>`),f.push(Px(R,Z,"clearcoat",new k.Lx(q,q,q),x,F))):G.push(`${u}float inputs:clearcoat = ${q}`),null!==v?(G.push(`${u}float inputs:clearcoatRoughness.connect = </Materials/Material_${Z.uniqueId}/Texture_${v.uniqueId}_clearcoatRoughness.outputs:g>`),f.push(Px(v,Z,"clearcoatRoughness",new k.Lx(B,B,B),x,F))):G.push(`${u}float inputs:clearcoatRoughness = ${B}`)),G.push(`${u}float inputs:ior = ${K}`),`\n\tdef Material "Material_${Z.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${G.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${Z.uniqueId}/PreviewSurface.outputs:surface>\n\n${f.join("\n")}\n\n\t}\n`}async function xF(Z,x,F){const f={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...x};"undefined"===typeof fflate&&await G.Tools.LoadScriptAsync(f.fflateUrl);const Y={};Y[f.modelFileName]=null;let j='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';j+=function(Z){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===Z.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${Z.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${Z.planeAnchoringAlignment}"`:""}\n            `}(f);const d={};for(const u of Z.meshes){if(0===u.getTotalVertices())continue;const Z=u,x=Z.af,t=Z.material;if(!t||!x||F&&!F(Z))continue;if(-1!==["Cx","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(t.getClassName())){const F="geometries/Geometry_"+x.uniqueId+".usda";if(!(F in Y)){const Z=gx(x,f);Y[F]=Ox(Z)}t.uniqueId in d||(d[t.uniqueId]=t),j+=ax(Z)}else G.Tools.Warn("USDZExportAsync does not support this material type: "+t.getClassName())}Z.activeCamera&&f.exportCamera&&(j+=function(Z,x){const F="Camera_"+Z.uniqueId,G=nx(u.Matrix.RotationY(Math.PI).multiply(Z.getWorldMatrix()));if(Z.mode===K.e.ORTHOGRAPHIC_CAMERA)return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${G}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.hf.toPrecision(x.precision)}, ${Z.maxZ.toPrecision(x.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(Z.orthoLeft||1)+Math.abs(Z.orthoRight||1))).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(Z.orthoTop||1)+Math.abs(Z.orthoBottom||1))).toPrecision(x.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const u=Z.getEngine().getAspectRatio(Z),f=x.cameraSensorWidth||35;return`def Camera "${F}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${G}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${Z.hf.toPrecision(x.precision)}, ${Z.maxZ.toPrecision(x.precision)})\n\t\t\tfloat focalLength = ${(f/(2*Math.tan(.5*Z.fov))).toPrecision(x.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(f*u).toPrecision(x.precision)}\n\t\t\tfloat verticalAperture = ${(f/u).toPrecision(x.precision)}            \n\t\t}\n\t\n\t`}}(Z.activeCamera,f)),j+="\n            }\n        }\n    }";const t={};j+=function(Z,x,F){const u=[];for(const G in Z){const f=Z[G];u.push(ZF(f,x,F))}return`\n    def "Materials"\n{\n${u.join("")}\n}\n\n`}(d,t,f),Y[f.modelFileName]=fflate.strToU8(j);for(const u in t){const Z=t[u],x=Z.getSize(),F=await Z.readPixels();if(!F)throw new Error("Texture data is not available");const G=await y.DumpTools.DumpDataAsync(x.width,x.height,F,"image/png",void 0,!1,!0);Y[`textures/Texture_${u}.png`]=new Uint8Array(G).slice()}let o=0;for(const u in Y){const Z=Y[u];if(!Z)continue;o+=34+u.length;const x=63&o;if(4!==x){const F=new Uint8Array(64-x);Y[u]=[Z,{extra:{12345:F}}]}o=Z.length}return fflate.zipSync(Y,{level:0})}}}]);