"use strict";(self.mo7o6813fhb=self.mo7o6813fhb||[]).push([[26],{12825:(t,U,y)=>{y.r(U),y.d(U,{EXT_materials_diffuse_roughness:()=>nU,EXT_mesh_gpu_instancing:()=>At,GLTF2Export:()=>Zt,GLTFData:()=>G,KHR_draco_mesh_compression:()=>yU,KHR_lights_punctual:()=>PU,KHR_materials_anisotropy:()=>LU,KHR_materials_clearcoat:()=>QU,KHR_materials_diffuse_transmission:()=>wU,KHR_materials_dispersion:()=>lU,KHR_materials_emissive_strength:()=>BU,KHR_materials_ior:()=>pU,KHR_materials_iridescence:()=>fU,KHR_materials_sheen:()=>NU,KHR_materials_specular:()=>JU,KHR_materials_transmission:()=>dU,KHR_materials_unlit:()=>HU,KHR_materials_volume:()=>oU,KHR_texture_transform:()=>vU,OBJExport:()=>mt,STLExport:()=>OU,USDZExportAsync:()=>Uy,_ConvertToGLTFPBRMetallicRoughness:()=>q,_SolveMetallic:()=>d,__IGLTFExporterExtension:()=>X});var I=y(12386),r=y(12198),Y=y(12741);class mt{static OBJ(t,U,y,mt){const X=[];let P=1,G=1;U&&(y||(y="mat"),X.push("mtllib "+y+".mtl"));for(let M=0;M<t.length;M++){const y=t[M],L=y.name||`mesh${M}}`;X.push(`o ${L}`);let h=null;if(mt){const t=y.SX(!0);h=new I.Matrix,t.invertToRef(h),y.bakeTransformIntoVertices(t)}if(U){const t=y.material;t&&X.push("usemtl "+t.id)}const Q=y.NX;if(!Q){r.Tools.Warn("No geometry is present on the mesh");continue}const F=Q.getVerticesData("position"),E=Q.getVerticesData("normal"),w=Q.getVerticesData("uv"),D=Q.jX();let l=0,g=0;if(!F||!D){r.Tools.Warn("There are no position vertices or indices on the mesh!");continue}const B=t[0].St().useRightHandedSystem?1:-1;for(let t=0;t<F.length;t+=3)X.push("v "+F[t]*B+" "+F[t+1]+" "+F[t+2]),l++;if(null!=E)for(let t=0;t<E.length;t+=3)X.push("vn "+E[t]*B+" "+E[t+1]+" "+E[t+2]);if(null!=w)for(let t=0;t<w.length;t+=2)X.push("vt "+w[t]+" "+w[t+1]),g++;const b=["","",""],p=(y.material||y.St().defaultMaterial)._getEffectiveOrientation(y),[c,f]=p===Y.e.ClockWiseSideOrientation?[2,1]:[1,2];for(let t=0;t<D.length;t+=3){const U=[String(D[t]+P),String(D[t+c]+P),String(D[t+f]+P)],y=[String(D[t]+G),String(D[t+c]+G),String(D[t+f]+G)],I=U,r=null!=w?y:b,Y=null!=E?U:b;X.push("f "+I[0]+"/"+r[0]+"/"+Y[0]+" "+I[1]+"/"+r[1]+"/"+Y[1]+" "+I[2]+"/"+r[2]+"/"+Y[2])}mt&&h&&y.bakeTransformIntoVertices(h),P+=l,G+=g}return X.join("\n")}static MTL(t){const U=[],y=t.material;U.push("newmtl mat1"),U.push("  Ns "+y.specularPower.toFixed(4)),U.push("  Ni 1.5000"),U.push("  d "+y.alpha.toFixed(4)),U.push("  Tr 0.0000"),U.push("  Tf 1.0000 1.0000 1.0000"),U.push("  illum 2"),U.push("  Ka "+y.ambientColor.r.toFixed(4)+" "+y.ambientColor.g.toFixed(4)+" "+y.ambientColor.b.toFixed(4)),U.push("  Kd "+y.diffuseColor.r.toFixed(4)+" "+y.diffuseColor.g.toFixed(4)+" "+y.diffuseColor.b.toFixed(4)),U.push("  Ks "+y.specularColor.r.toFixed(4)+" "+y.specularColor.g.toFixed(4)+" "+y.specularColor.b.toFixed(4)),U.push("  Ke "+y.emissiveColor.r.toFixed(4)+" "+y.emissiveColor.g.toFixed(4)+" "+y.emissiveColor.b.toFixed(4));y.ambientTexture&&U.push("  map_Ka "+y.ambientTexture.name),y.diffuseTexture&&U.push("  map_Kd "+y.diffuseTexture.name),y.specularTexture&&U.push("  map_Ks "+y.specularTexture.name),y.bumpTexture&&U.push("  map_bump -imfchan z "+y.bumpTexture.name),y.opacityTexture&&U.push("  map_d "+y.opacityTexture.name);return U.join("\n")}}var X=0,P=y(12253);class G{constructor(){this.files={}}get glTFFiles(){return this.files}downloadFiles(){for(const t in this.files){const U=this.files[t],y=new Blob([U],{type:(0,P.i)(t)});r.Tools.Download(y,t)}}}var M=y(12480),L=y(12831),h=y(12844),Q=y(12864),F=y(12537),E=y(12250),w=y(12442),D=y(12404);const l=D.HighestCommonFactor,g={...D,TwoPi:2*Math.PI,Sign:Math.sign,Log2:Math.log2,HCF:l};var B=y(12640),b=y(12361),p=y(12899),c=y(12906),f=y(12635);const S=1e-6,N=new w.bU(.04,.04,.04),j=1024,J=w.bU.White(),a=w.bU.Black();function d(t,U,y){if(U<N.r)return 0;const I=N.r,r=t*y/(1-N.r)+U-2*N.r,Y=r*r-4*I*(N.r-U);return g.Clamp((-r+Math.sqrt(Y))/(2*I),0,1)}function q(t){const U=t.diffuseColor.toLinearSpace(t.St().getEngine().useExactSrgbConversions).scale(.5),y=t.alpha,r=function(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:new I.Vector2(0,1),y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new I.Vector2(0,.1),r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new I.Vector2(0,.1),Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:new I.Vector2(1300,.1);return function(t,U,y,I,r){return(1-t)*(1-t)*(1-t)*U+3*(1-t)*(1-t)*t*y+3*(1-t)*t*t*I+t*t*t*r}(Math.pow(t/Y.x,.333333),U.y,y.y,r.y,Y.y)}(g.Clamp(t.specularPower,0,j));return{baseColorFactor:[U.r,U.g,U.b,y],metallicFactor:0,roughnessFactor:r}}function H(t,U){U.needAlphaBlending()?t.alphaMode="BLEND":U.needAlphaTesting()&&(t.alphaMode="MASK",t.alphaCutoff=U.alphaCutOff)}function e(t,U,y){const I=new Uint8Array(t*U*4);for(let r=0;r<I.length;r+=4)I[r]=I[r+1]=I[r+2]=I[r+3]=255;return p.b.CreateRGBATexture(I,t,U,y)}function o(t){if(t instanceof Uint8Array){const U=t.length,y=new Float32Array(t.length);for(let I=0;I<U;++I)y[I]=t[I]/255;return y}if(t instanceof Float32Array)return t;throw new Error("Unsupported pixel format!")}class V{constructor(t){this._exporter=t,this._textureMap=new Map,this._internalTextureToImage={}}getTextureInfo(t){return t?this._textureMap.get(t)??null:null}async exportStandardMaterialAsync(t,U,y){const I=q(t),Y={name:t.name};if(null==t.JX||t.JX||(t.twoSidedLighting||r.Tools.Warn(t.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),Y.doubleSided=!0),y){const y=[],r=t.diffuseTexture;r&&y.push(this.exportTextureAsync(r,U).then((t=>{t&&(I.baseColorTexture=t)})));const mt=t.bumpTexture;mt&&y.push(this.exportTextureAsync(mt,U).then((t=>{t&&(Y.normalTexture=t,1!==mt.level&&(Y.normalTexture.scale=mt.level))})));const X=t.emissiveTexture;X&&(Y.emissiveFactor=[1,1,1],y.push(this.exportTextureAsync(X,U).then((t=>{t&&(Y.emissiveTexture=t)}))));const P=t.ambientTexture;P&&y.push(this.exportTextureAsync(P,U).then((t=>{if(t){const U={index:t.index};Y.occlusionTexture=U}}))),y.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(y))}(t.alpha<1||t.opacityTexture)&&(t.alphaMode===c.b.ALPHA_COMBINE?Y.alphaMode="BLEND":r.Tools.Warn(t.name+": glTF 2.0 does not support alpha mode: "+t.alphaMode.toString())),t.emissiveColor&&!t.emissiveColor.equalsWithEpsilon(a,S)&&(Y.emissiveFactor=t.emissiveColor.bX()),Y.pbrMetallicRoughness=I,H(Y,t),await this._finishMaterialAsync(Y,t,U);const mt=this._exporter._materials;return mt.push(Y),mt.length-1}async _finishMaterialAsync(t,U,y){const I=this._exporter._extensionsPostExportMaterialAdditionalTextures("exportMaterial",t,U),r=[];for(const Y of I)r.push(this.exportTextureAsync(Y,y));await Promise.all(r),await this._exporter._extensionsPostExportMaterialAsync("exportMaterial",t,U)}async _getImageDataAsync(t,U,I,r){const Y=c.b.TEXTURETYPE_UNSIGNED_BYTE,mt=this._exporter._babylonScene,X=mt.getEngine(),P=X.createRawTexture(t,U,I,c.b.TEXTUREFORMAT_RGBA,!1,!0,b.d.NEAREST_SAMPLINGMODE,null,Y);X.isWebGPU?await y.e(51).then(y.bind(y,14638)):await y.e(52).then(y.bind(y,14647)),await B.j.ApplyPostProcess("pass",P,mt,Y,c.b.TEXTURE_NEAREST_SAMPLINGMODE,c.b.TEXTUREFORMAT_RGBA);const G=await X._readTexturePixels(P,U,I);return await f.DumpTools.DumpDataAsync(U,I,G,r,void 0,!0,!0)}_resizeTexturesToSameDimensions(t,U,y){const I=t?t.getSize():{width:0,height:0},r=U?U.getSize():{width:0,height:0};let Y,mt;return I.width<r.width?(Y=t&&t instanceof b.d?B.j.CreateResizedCopy(t,r.width,r.height,!0):e(r.width,r.height,y),mt=U):I.width>r.width?(mt=U&&U instanceof b.d?B.j.CreateResizedCopy(U,I.width,I.height,!0):e(I.width,I.height,y),Y=t):(Y=t,mt=U),{texture1:Y,texture2:mt}}async _convertSpecularGlossinessTexturesToMetallicRoughnessAsync(t,U,y,I){const r=new Array;if(!t&&!U)return await Promise.reject("diffuse and specular glossiness textures are not defined!");const Y=t?t.St():U?U.St():null;if(Y){var mt;const X=this._resizeTexturesToSameDimensions(t,U,Y),P=null===(mt=X.texture1)||void 0===mt?void 0:mt.getSize();let G,M;const L=P.width,h=P.height,Q=await X.texture1.readPixels(),F=await X.texture2.readPixels();if(!Q)return await Promise.reject("Failed to retrieve pixels from diffuse texture!");if(G=o(Q),!F)return await Promise.reject("Failed to retrieve pixels from specular glossiness texture!");M=o(F);const E=M.byteLength,D=new Uint8Array(E),l=new Uint8Array(E),g=4,B=a;let b=0,p=0;for(let t=0;t<h;++t)for(let U=0;U<L;++U){const I=(L*t+U)*g,r={diffuseColor:new w.bU(G[I],G[I+1],G[I+2]).toLinearSpace(Y.getEngine().useExactSrgbConversions).multiply(y.diffuseColor),specularColor:new w.bU(M[I],M[I+1],M[I+2]).toLinearSpace(Y.getEngine().useExactSrgbConversions).multiply(y.specularColor),glossiness:M[I+3]*y.glossiness},mt=this._convertSpecularGlossinessToMetallicRoughness(r);B.r=Math.max(B.r,mt.baseColor.r),B.g=Math.max(B.g,mt.baseColor.g),B.b=Math.max(B.b,mt.baseColor.b),b=Math.max(b,mt.metallic),p=Math.max(p,mt.roughness),l[I]=255*mt.baseColor.r,l[I+1]=255*mt.baseColor.g,l[I+2]=255*mt.baseColor.b,l[I+3]=X.texture1.pX?255*G[I+3]:255,D[I]=0,D[I+1]=255*mt.roughness,D[I+2]=255*mt.metallic,D[I+3]=255}const c={baseColor:B,metallic:b,roughness:p};let f=!1,N=!1;for(let t=0;t<h;++t)for(let U=0;U<L;++U){const y=(L*t+U)*g;l[y]/=c.baseColor.r>S?c.baseColor.r:1,l[y+1]/=c.baseColor.g>S?c.baseColor.g:1,l[y+2]/=c.baseColor.b>S?c.baseColor.b:1;const I=w.bU.FromInts(l[y],l[y+1],l[y+2]).toGammaSpace(Y.getEngine().useExactSrgbConversions);l[y]=255*I.r,l[y+1]=255*I.g,l[y+2]=255*I.b,I.equalsWithEpsilon(J,S)||(N=!0),D[y+1]/=c.roughness>S?c.roughness:1,D[y+2]/=c.metallic>S?c.metallic:1;w.bU.FromInts(255,D[y+1],D[y+2]).equalsWithEpsilon(J,S)||(f=!0)}return f&&r.push(this._getImageDataAsync(D,L,h,I).then((t=>{c.metallicRoughnessTextureData=t}))),N&&r.push(this._getImageDataAsync(l,L,h,I).then((t=>{c.baseColorTextureData=t}))),await Promise.all(r).then((()=>c))}return await Promise.reject("_ConvertSpecularGlossinessTexturesToMetallicRoughness: Scene from textures is missing!")}_convertSpecularGlossinessToMetallicRoughness(t){const U=this._getPerceivedBrightness(t.diffuseColor),y=this._getPerceivedBrightness(t.specularColor),I=1-this._getMaxComponent(t.specularColor),r=d(U,y,I),Y=t.diffuseColor.scale(I/(1-N.r)/Math.max(1-r)),mt=t.specularColor.lU(N.scale(1-r)).scale(1/Math.max(r));let X=w.bU.Lerp(Y,mt,r*r);X=X.clampToRef(0,1,X);return{baseColor:X,metallic:r,roughness:1-t.glossiness}}_getPerceivedBrightness(t){return t?Math.sqrt(.299*t.r*t.r+.587*t.g*t.g+.114*t.b*t.b):0}_getMaxComponent(t){return t?Math.max(t.r,Math.max(t.g,t.b)):0}async _convertMetalRoughFactorsToMetallicRoughnessAsync(t,U,y,I){const r=[],Y={baseColor:t._albedoColor,metallic:t._metallic,roughness:t._roughness};if(I){t._albedoTexture&&r.push(this.exportTextureAsync(t._albedoTexture,U).then((t=>{t&&(y.baseColorTexture=t)})));const I=t._metallicTexture;I&&r.push(this.exportTextureAsync(I,U).then((t=>{t&&(y.metallicRoughnessTexture=t)})))}return r.length>0&&(this._exporter._materialNeedsUVsSet.add(t),await Promise.all(r)),Y}_getTextureSampler(t){const U={};if(!t||!(t instanceof b.d))return U;const y=this._getGLTFTextureWrapMode(t.wrapU);10497!==y&&(U.wrapS=y);const I=this._getGLTFTextureWrapMode(t.wrapV);switch(10497!==I&&(U.wrapT=I),t.samplingMode){case b.d.LINEAR_LINEAR:U.magFilter=9729,U.minFilter=9729;break;case b.d.LINEAR_NEAREST:U.magFilter=9729,U.minFilter=9728;break;case b.d.NEAREST_LINEAR:U.magFilter=9728,U.minFilter=9729;break;case b.d.NEAREST_LINEAR_MIPLINEAR:U.magFilter=9728,U.minFilter=9987;break;case b.d.NEAREST_NEAREST:U.magFilter=9728,U.minFilter=9728;break;case b.d.NEAREST_LINEAR_MIPNEAREST:U.magFilter=9728,U.minFilter=9985;break;case b.d.LINEAR_NEAREST_MIPNEAREST:U.magFilter=9729,U.minFilter=9984;break;case b.d.LINEAR_NEAREST_MIPLINEAR:U.magFilter=9729,U.minFilter=9986;break;case b.d.NEAREST_NEAREST_MIPLINEAR:U.magFilter=9728,U.minFilter=9986;break;case b.d.LINEAR_LINEAR_MIPLINEAR:U.magFilter=9729,U.minFilter=9987;break;case b.d.LINEAR_LINEAR_MIPNEAREST:U.magFilter=9729,U.minFilter=9985;break;case b.d.NEAREST_NEAREST_MIPNEAREST:U.magFilter=9728,U.minFilter=9984}return U}_getGLTFTextureWrapMode(t){switch(t){case b.d.WRAP_ADDRESSMODE:return 10497;case b.d.CLAMP_ADDRESSMODE:return 33071;case b.d.MIRROR_ADDRESSMODE:return 33648;default:return r.Tools.Error(`Unsupported Texture Wrap Mode ${t}!`),10497}}async _convertSpecGlossFactorsToMetallicRoughnessAsync(t,U,y,I){const r={diffuseColor:t._albedoColor,specularColor:t._reflectivityColor,glossiness:t._microSurface},Y=t._albedoTexture,mt=t._reflectivityTexture,X=t._useMicroSurfaceFromReflectivityMapAlpha;if(mt&&!X)return await Promise.reject("_ConvertPBRMaterial: Glossiness values not included in the reflectivity texture are currently not supported");if((Y||mt)&&I){this._exporter._materialNeedsUVsSet.add(t);const I=this._exportTextureSampler(Y||mt),X=await this._convertSpecularGlossinessTexturesToMetallicRoughnessAsync(Y,mt,r,U),P=this._exporter._textures;if(X.baseColorTextureData){const t=this._exportImage(`baseColor${P.length}`,U,X.baseColorTextureData);y.baseColorTexture=this._exportTextureInfo(t,I,null===Y||void 0===Y?void 0:Y.coordinatesIndex)}if(X.metallicRoughnessTextureData){const t=this._exportImage(`metallicRoughness${P.length}`,U,X.metallicRoughnessTextureData);y.metallicRoughnessTexture=this._exportTextureInfo(t,I,null===mt||void 0===mt?void 0:mt.coordinatesIndex)}return X}return this._convertSpecularGlossinessToMetallicRoughness(r)}async exportPBRMaterialAsync(t,U,y){const I={},r={name:t.name},Y=t.isMetallicWorkflow();if(Y){const U=t._albedoColor,y=t.alpha;U&&(I.baseColorFactor=[U.r,U.g,U.b,y])}const mt=Y?await this._convertMetalRoughFactorsToMetallicRoughnessAsync(t,U,I,y):await this._convertSpecGlossFactorsToMetallicRoughnessAsync(t,U,I,y);await this._setMetallicRoughnessPbrMaterialAsync(mt,t,r,I,U,y),await this._finishMaterialAsync(r,t,U);const X=this._exporter._materials;return X.push(r),X.length-1}async _setMetallicRoughnessPbrMaterialAsync(t,U,y,I,Y,mt){if(H(y,U),t.baseColor.equalsWithEpsilon(J,S)&&g.WithinEpsilon(U.alpha,1,S)||(I.baseColorFactor=[t.baseColor.r,t.baseColor.g,t.baseColor.b,U.alpha]),null!=t.metallic&&1!==t.metallic&&(I.metallicFactor=t.metallic),null!=t.roughness&&1!==t.roughness&&(I.roughnessFactor=t.roughness),null==U.JX||U.JX||(U._twoSidedLighting||r.Tools.Warn(U.name+": Back-face culling disabled and two-sided lighting disabled is not supported in glTF."),y.doubleSided=!0),mt){const t=[],I=U._bumpTexture;I&&t.push(this.exportTextureAsync(I,Y).then((t=>{t&&(y.normalTexture=t,1!==I.level&&(y.normalTexture.scale=I.level))})));const r=U._ambientTexture;r&&t.push(this.exportTextureAsync(r,Y).then((t=>{if(t){const I={index:t.index,texCoord:t.texCoord,extensions:t.extensions};y.occlusionTexture=I;const r=U._ambientTextureStrength;r&&(I.strength=r)}})));const mt=U._emissiveTexture;mt&&t.push(this.exportTextureAsync(mt,Y).then((t=>{t&&(y.emissiveTexture=t)}))),t.length>0&&(this._exporter._materialNeedsUVsSet.add(U),await Promise.all(t))}const X=U._emissiveColor;X.equalsWithEpsilon(a,S)||(y.emissiveFactor=X.bX()),y.pbrMetallicRoughness=I}_getPixelsFromTextureAsync(t){return function(t){switch(t){case c.b.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM:case c.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT:case c.b.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT:case c.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT:case c.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT:case c.b.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1:case c.b.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT:case c.b.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:case c.b.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL:case c.b.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2:case c.b.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2:case c.b.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC:case c.b.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:return!0;default:return!1}}(t.textureFormat)?(0,B.g)(t,t._texture.width,t._texture.height):(t.textureType,c.b.TEXTURETYPE_UNSIGNED_BYTE,t.readPixels())}async exportTextureAsync(t,U){const y=this._exporter._extensionsPreExportTextureAsync("exporter",t,U);return y?await y.then((async y=>y?await this._exportTextureInfoAsync(y,U):await this._exportTextureInfoAsync(t,U))):await this._exportTextureInfoAsync(t,U)}async _exportTextureInfoAsync(t,U){let y=this._textureMap.get(t);if(!y){const I=await this._getPixelsFromTextureAsync(t);if(!I)return null;const Y=this._exportTextureSampler(t),mt=t.mimeType;if(mt)switch(mt){case"image/jpeg":case"image/png":case"image/webp":U=mt;break;default:r.Tools.Warn(`Unsupported media type: ${mt}. Exporting texture as PNG.`)}const X=this._internalTextureToImage,P=t.getInternalTexture().uniqueId;X[P]||(X[P]={});let G=X[P][U];if(void 0===G){const y=t.getSize();G=(async()=>{const r=await this._getImageDataAsync(I,y.width,y.height,U);return this._exportImage(t.name,U,r)})(),X[P][U]=G}y=this._exportTextureInfo(await G,Y,t.coordinatesIndex),this._textureMap.set(t,y),this._exporter._extensionsPostExportTextures("exporter",y,t)}return y}_exportImage(t,U,y){const I=this._exporter._images;let Y;if(this._exporter._shouldUseGlb){Y={name:t,mimeType:U,bufferView:void 0};const I=this._exporter._bufferManager.createBufferView(new Uint8Array(y));this._exporter._bufferManager.setBufferView(Y,I)}else{const mt=t.replace(/\.\/|\/|\.\\|\\/g,"_"),X=function(t){switch(t){case"image/jpeg":return".jpg";case"image/png":return".png";case"image/webp":return".webp";case"image/avif":return".avif"}}(U);let P=mt+X;I.some((t=>t.uri===P))&&(P=`${mt}_${r.Tools.RandomId()}${X}`),Y={name:t,uri:P},this._exporter._imageData[P]={data:y,mimeType:U}}return I.push(Y),I.length-1}_exportTextureInfo(t,U,y){const I=this._exporter._textures;let r=I.findIndex((y=>y.sampler==U&&y.source===t));-1===r&&(r=I.length,I.push({source:t,sampler:U}));const Y={index:r};return y&&(Y.texCoord=y),Y}_exportTextureSampler(t){const U=this._getTextureSampler(t),y=this._exporter._samplers,I=y.findIndex((t=>t.minFilter===U.minFilter&&t.magFilter===U.magFilter&&t.wrapS===U.wrapS&&t.wrapT===U.wrapT));return-1!==I?I:(y.push(U),y.length-1)}}var n=y(12491),i=y(12221),v=y(12908),O=y(12392);const k=I.DU.Zero(),s=I.Quaternion.Identity(),x=I.DU.One(),Z=new I.DU(-1,1,1);function W(t,U){const{byteOffset:y,byteStride:I,type:r,normalized:Y}=t,mt=t.getSize(),X=U.reduce(((t,U)=>U.getTotalVertices()>t?U.getTotalVertices():t),-Number.MAX_VALUE);return{byteOffset:y,byteStride:I,componentCount:mt,type:r,count:X*mt,normalized:Y,totalVertices:X,kind:t.getKind()}}function A(t){switch(t){case"MAT2":case"VEC4":return 4;case"MAT3":return 9;case"MAT4":return 16;case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3}}function K(t){switch(t){case M.e.PositionKind:case M.e.NormalKind:case M.e.TangentKind:case M.e.ColorKind:case M.e.MatricesIndicesKind:case M.e.MatricesIndicesExtraKind:case M.e.MatricesWeightsKind:case M.e.MatricesWeightsExtraKind:case M.e.UVKind:case M.e.UV2Kind:case M.e.UV3Kind:case M.e.UV4Kind:case M.e.UV5Kind:case M.e.UV6Kind:return!0}return!1}function C(t){switch(t){case Y.e.TriangleFillMode:return 4;case Y.e.TriangleStripDrawMode:return 5;case Y.e.TriangleFanDrawMode:return 6;case Y.e.PointListDrawMode:case Y.e.PointFillMode:return 0;case Y.e.LineLoopDrawMode:return 2;case Y.e.LineListDrawMode:return 1;case Y.e.LineStripDrawMode:return 3}throw new Error(`Unknown fill mode: ${t}`)}function R(t){const U=Math.sqrt(t.x*t.x+t.y*t.y+t.z*t.z);U>0&&(t.x/=U,t.y/=U,t.z/=U)}function u(t){return t.x*=-1,t}function T(t){if(t.x*t.x+t.y*t.y>.5){const U=Math.abs(t.x),y=Math.abs(t.y);if(U>y){const y=Math.sign(t.x);t.x=U,t.y*=-y,t.z*=-y,t.w*=y}else{const U=Math.sign(t.y);t.x*=-U,t.y=y,t.z*=U,t.w*=-U}}else{const U=Math.abs(t.z),y=Math.abs(t.w);if(U>y){const y=Math.sign(t.z);t.x*=-y,t.y*=y,t.z=U,t.w*=-y}else{const U=Math.sign(t.w);t.x*=U,t.y*=-U,t.z*=-U,t.w=y}}return t}function z(t){t.aX(-t.z,t.w,t.x,-t.y)}function tt(t,U){const y=I.DU.FromArrayToRef(U.translation||[0,0,0],0,I.TmpVectors.DU[0]),r=I.Quaternion.FromArrayToRef(U.rotation||[0,0,0,1],0,I.TmpVectors.Quaternion[0]),Y=I.Matrix.ComposeToRef(x,r,y,I.TmpVectors.Matrix[0]),mt=I.DU.FromArrayToRef(t.translation||[0,0,0],0,I.TmpVectors.DU[2]),X=I.Quaternion.FromArrayToRef(t.rotation||[0,0,0,1],0,I.TmpVectors.Quaternion[1]),P=I.Matrix.ComposeToRef(x,X,mt,I.TmpVectors.Matrix[1]);Y.multiplyToRef(P,P),P.decompose(void 0,r,y),y.equalsWithEpsilon(k,O.b)?delete U.translation:U.translation=y.bX(),r.equalsWithEpsilon(s,O.b)?delete U.rotation:U.rotation=r.bX(),U.scale&&delete U.scale}function Ut(t,U){if(!(U instanceof L.d))return!1;if(!(1===U.getChildren().length&&0===t.getChildren().length&&t.parent===U))return!1;const y=t.St(),I=t instanceof v.c&&!y.useRightHandedSystem?Z:x;return!!U.dX.equalsWithEpsilon(I,O.b)||(i.b.Warn(`Cannot collapse node ${t.name} into parent node ${U.name} with modified scaling.`),!1)}function yt(t){if(t instanceof Array){const U=new Float32Array(t);return new Uint8Array(U.buffer,U.byteOffset,U.byteLength)}return ArrayBuffer.isView(t)?new Uint8Array(t.buffer,t.byteOffset,t.byteLength):new Uint8Array(t)}function It(t,U){for(const[y,I]of Object.entries(t)){const r=U[y];(Array.isArray(I)&&Array.isArray(r)&&rt(I,r)||I===r)&&delete t[y]}return t}function rt(t,U){return t.length===U.length&&t.every(((t,y)=>t===U[y]))}const Yt=I.Matrix.Compose(new I.DU(-1,1,1),I.Quaternion.Identity(),I.DU.Zero());function mU(t,U){if(!(t instanceof L.d))return!1;if(U){if(!t.getWorldMatrix().equalsWithEpsilon(I.Matrix.IdentityReadOnly,O.b))return!1}else{if(!t.getWorldMatrix().multiplyToRef(Yt,I.TmpVectors.Matrix[0]).equalsWithEpsilon(I.Matrix.IdentityReadOnly,O.b))return!1}return!(t instanceof h.c&&t.NX)}const Xt=new Map([[Int8Array,(t,U,y)=>t.setInt8(U,y)],[Uint8Array,(t,U,y)=>t.setUint8(U,y)],[Uint8ClampedArray,(t,U,y)=>t.setUint8(U,y)],[Int16Array,(t,U,y)=>t.setInt16(U,y,!0)],[Uint16Array,(t,U,y)=>t.setUint16(U,y,!0)],[Int32Array,(t,U,y)=>t.setInt32(U,y,!0)],[Uint32Array,(t,U,y)=>t.setUint32(U,y,!0)],[Float32Array,(t,U,y)=>t.setFloat32(U,y,!0)],[Float64Array,(t,U,y)=>t.setFloat64(U,y,!0)]]);class Pt{writeTypedArray(t){this._checkGrowBuffer(t.byteLength);const U=Xt.get(t.constructor);for(let y=0;y<t.length;y++)U(this._dataView,this._byteOffset,t[y]),this._byteOffset+=t.BYTES_PER_ELEMENT}constructor(t){this._data=new Uint8Array(t),this._dataView=new DataView(this._data.buffer),this._byteOffset=0}get byteOffset(){return this._byteOffset}getOutputData(){return new Uint8Array(this._data.buffer,0,this._byteOffset)}writeUInt8(t){this._checkGrowBuffer(1),this._dataView.setUint8(this._byteOffset,t),this._byteOffset++}writeInt8(t){this._checkGrowBuffer(1),this._dataView.setInt8(this._byteOffset,t),this._byteOffset++}writeInt16(t){this._checkGrowBuffer(2),this._dataView.setInt16(this._byteOffset,t,!0),this._byteOffset+=2}writeUInt16(t){this._checkGrowBuffer(2),this._dataView.setUint16(this._byteOffset,t,!0),this._byteOffset+=2}writeInt32(t){this._checkGrowBuffer(4),this._dataView.setInt32(this._byteOffset,t,!0),this._byteOffset+=4}writeUInt32(t){this._checkGrowBuffer(4),this._dataView.setUint32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat32(t){this._checkGrowBuffer(4),this._dataView.setFloat32(this._byteOffset,t,!0),this._byteOffset+=4}writeFloat64(t){this._checkGrowBuffer(8),this._dataView.setFloat64(this._byteOffset,t,!0),this._byteOffset+=8}_checkGrowBuffer(t){const U=this.byteOffset+t;if(U>this._data.byteLength){const t=new Uint8Array(2*U);t.set(this._data),this._data=t,this._dataView=new DataView(this._data.buffer)}}}function Gt(t){return t%4===0?4:t%2===0?2:1}class Mt{constructor(){this._bufferViewToData=new Map,this._bufferViewToProperties=new Map,this._accessorToBufferView=new Map}generateBinary(t){let U=0;this._bufferViewToData.forEach((t=>{U+=t.byteLength}));const y=new Pt(U),I=Array.from(this._bufferViewToData.keys()).sort(((t,U)=>Gt(U.byteLength)-Gt(t.byteLength)));for(const r of I){r.byteOffset=y.byteOffset,t.push(r);const U=t.length-1,I=this.getPropertiesWithBufferView(r);for(const t of I)t.bufferView=U;y.writeTypedArray(this._bufferViewToData.get(r)),this._bufferViewToData.delete(r)}return y.getOutputData()}createBufferView(t,U){const y={buffer:0,byteOffset:void 0,byteLength:t.byteLength,byteStride:U};return this._bufferViewToData.set(y,t),y}createAccessor(t,U,y,I,r,Y,mt){this._verifyBufferView(t);const X={bufferView:void 0,componentType:y,count:I,type:U,min:null===Y||void 0===Y?void 0:Y.min,max:null===Y||void 0===Y?void 0:Y.max,normalized:mt,byteOffset:r};return this.setBufferView(X,t),this._accessorToBufferView.set(X,t),X}setBufferView(t,U){this._verifyBufferView(U);this.getPropertiesWithBufferView(U).push(t)}removeBufferView(t){const U=this.getPropertiesWithBufferView(t);for(const y of U)void 0!==y.bufferView&&delete y.bufferView;this._bufferViewToData.delete(t),this._bufferViewToProperties.delete(t),this._accessorToBufferView.forEach(((U,y)=>{U===t&&(void 0!==y.byteOffset&&delete y.byteOffset,this._accessorToBufferView.delete(y))}))}getBufferView(t){const U=this._accessorToBufferView.get(t);return this._verifyBufferView(U),U}getPropertiesWithBufferView(t){return this._verifyBufferView(t),this._bufferViewToProperties.set(t,this._bufferViewToProperties.get(t)??[]),this._bufferViewToProperties.get(t)}getData(t){return this._verifyBufferView(t),this._bufferViewToData.get(t)}_verifyBufferView(t){if(void 0===t||!this._bufferViewToData.has(t))throw new Error(`BufferView ${t} not found in BufferManager.`)}}var Lt,ht=y(12876),Qt=y(12890),Ft=y(12915),Et=y(12794),wt=y(12956),Dt=y(12969),lt=y(12868),gt=y(12978);!function(t){t[t.INTANGENT=0]="INTANGENT",t[t.OUTTANGENT=1]="OUTTANGENT"}(Lt||(Lt={}));class Bt{static _IsTransformable(t){return t&&(t instanceof L.d||t instanceof ht.e||t instanceof gt.c)}static _CreateNodeAnimation(t,U,y,I,Y){if(this._IsTransformable(t)){const mt=[],X=[],P=U.getKeys(),G=Bt._CalculateMinMaxKeyFrames(P),M=Bt._DeduceInterpolation(P,y,I),L=M.interpolationType,h=M.shouldBakeAnimation;if(h?Bt._CreateBakedAnimation(t,U,y,G.min,G.max,U.framePerSecond,Y,mt,X,G,I):"LINEAR"===L||"STEP"===L?Bt._CreateLinearOrStepAnimation(t,U,y,mt,X,I):"CUBICSPLINE"===L?Bt._CreateCubicSplineAnimation(t,U,y,mt,X,I):Bt._CreateBakedAnimation(t,U,y,G.min,G.max,U.framePerSecond,Y,mt,X,G,I),mt.length&&X.length){return{inputs:mt,outputs:X,samplerInterpolation:L,inputsMin:h?G.min:r.Tools.FloatRound(G.min/U.framePerSecond),inputsMax:h?G.max:r.Tools.FloatRound(G.max/U.framePerSecond)}}}return null}static _DeduceAnimationInfo(t){let U=null,y="VEC3",I=!1;const Y=t.targetProperty.split(".");switch(Y[0]){case"dX":U="scale";break;case"position":U="translation";break;case"rotation":y="VEC4",U="rotation";break;case"rotationQuaternion":y="VEC4",I=!0,U="rotation";break;case"influence":y="SCALAR",U="weights";break;default:r.Tools.Error(`Unsupported animatable property ${Y[0]}`)}return U?{animationChannelTargetPath:U,dataAccessorType:y,useQuaternion:I}:(r.Tools.Error("animation channel target path and data accessor type could be deduced"),null)}static _CreateNodeAnimationFromNodeAnimations(t,U,y,I,r,Y,mt,X,P,G,M){let L;if(Bt._IsTransformable(t)&&t.animations)for(const h of t.animations){if(M&&!M(h))continue;const r=Bt._DeduceAnimationInfo(h);r&&(L={name:h.name,samplers:[],channels:[]},Bt._AddAnimation(`${h.name}`,h.hasRunningRuntimeAnimations?U:L,t,h,r.dataAccessorType,r.animationChannelTargetPath,I,Y,mt,X,r.useQuaternion,P,G),L.samplers.length&&L.channels.length&&y.push(L))}}static _CreateMorphTargetAnimationFromMorphTargetAnimations(t,U,y,I,r,Y,mt,X,P,G,M){let L;if(t instanceof lt.c){const r=t.morphTargetManager;if(r)for(let h=0;h<r.numTargets;++h){const Q=r.getTarget(h);for(const F of Q.animations){if(M&&!M(F))continue;const Q=new wt.e(`${F.name}`,"influence",F.framePerSecond,F.dataType,F.loopMode,F.enableBlending),E=[],w=F.getKeys();for(let t=0;t<w.length;++t){const U=w[t];for(let t=0;t<r.numTargets;++t)t==h?E.push(U):E.push({frame:U.frame,value:0})}Q.setKeys(E);const D=Bt._DeduceAnimationInfo(Q);D&&(L={name:Q.name,samplers:[],channels:[]},Bt._AddAnimation(F.name,F.hasRunningRuntimeAnimations?U:L,t,Q,D.dataAccessorType,D.animationChannelTargetPath,I,Y,mt,X,D.useQuaternion,P,G,r.numTargets),L.samplers.length&&L.channels.length&&y.push(L))}}}}static _CreateNodeAndMorphAnimationFromAnimationGroups(t,U,y,I,r,Y,mt,X,P){let G;if(t.animationGroups){const L=t.animationGroups;for(const h of L){const L=new Map,Q=new Map,F=new Set,E=h.to-h.from;G={name:h.name,channels:[],samplers:[]};for(let U=0;U<h.targetedAnimations.length;++U){const E=h.targetedAnimations[U],w=E.target,D=E.animation;if(P&&!P(D))continue;const l=X.has(w);if(this._IsTransformable(w)||1===w.length&&this._IsTransformable(w[0])){const t=Bt._DeduceAnimationInfo(E.animation);if(t){const U=this._IsTransformable(w)?w:this._IsTransformable(w[0])?w[0]:null;U&&Bt._AddAnimation(`${D.name}`,G,U,D,t.dataAccessorType,t.animationChannelTargetPath,y,I,r,Y,t.useQuaternion,mt,l)}}else if(w instanceof Dt.d||1===w.length&&w[0]instanceof Dt.d){if(Bt._DeduceAnimationInfo(E.animation)){const U=w instanceof Dt.d?w:w[0];if(U){const y=t.morphTargetManagers.find((t=>{for(let y=0;y<t.numTargets;++y)if(t.getTarget(y)===U)return!0;return!1}));if(y){const I=t.meshes.find((t=>t.morphTargetManager===y));var M;if(I)L.has(I)||L.set(I,new Map),null===(M=L.get(I))||void 0===M||M.set(U,D),F.add(I),Q.set(I,D)}}}}}F.forEach((t=>{const U=t.morphTargetManager;let X=null;const P=[],M=Q.get(t).getKeys(),F=M.length;for(let y=0;y<F;++y)for(let I=0;I<U.numTargets;++I){const r=U.getTarget(I),Y=L.get(t);if(Y){const U=Y.get(r);U?(X||(X=new wt.e(`${h.name}_${t.name}_MorphWeightAnimation`,"influence",U.framePerSecond,wt.e.ANIMATIONTYPE_FLOAT,U.loopMode,U.enableBlending)),P.push(U.getKeys()[y])):P.push({frame:h.from+E/F*y,value:r.influence,inTangent:M[0].inTangent?0:void 0,outTangent:M[0].outTangent?0:void 0})}}X.setKeys(P);const w=Bt._DeduceAnimationInfo(X);w&&Bt._AddAnimation(`${h.name}_${t.name}_MorphWeightAnimation`,G,t,X,w.dataAccessorType,w.animationChannelTargetPath,y,I,r,Y,w.useQuaternion,mt,!1,null===U||void 0===U?void 0:U.numTargets)})),G.channels.length&&G.samplers.length&&U.push(G)}}}static _AddAnimation(t,U,y,r,Y,mt,X,P,G,M,L,h,Q,F){const E=Bt._CreateNodeAnimation(y,r,mt,L,h);let w,D,l,g,B,b;if(E){if(F){let t=0,U=0;const y=[];for(;E.inputs.length>0;)U=E.inputs.shift(),t%F==0&&y.push(U),t++;E.inputs=y}const t=X.get(y),r=new Float32Array(E.inputs);w=P.createBufferView(r),D=P.createAccessor(w,"SCALAR",5126,E.inputs.length,void 0,{min:[E.inputsMin],max:[E.inputsMax]}),M.push(D),l=M.length-1;const G=new I.Quaternion,L=new I.DU,h=new I.DU,p=y instanceof ht.e,c=A(Y),f=new Float32Array(E.outputs.length*c);E.outputs.forEach((function(t,U){let y=t;switch(mt){case"translation":Q&&(I.DU.FromArrayToRef(t,0,h),u(h),h.toArray(y));break;case"rotation":4===t.length?I.Quaternion.FromArrayToRef(t,0,G):(y=new Array(4),I.DU.FromArrayToRef(t,0,L),I.Quaternion.FromEulerVectorToRef(L,G)),Q&&(T(G),p&&z(G)),G.toArray(y)}f.set(y,U*c)})),w=P.createBufferView(f),D=P.createAccessor(w,Y,5126,E.outputs.length),M.push(D),g=M.length-1,B={interpolation:E.samplerInterpolation,input:l,output:g},U.samplers.push(B),b={sampler:U.samplers.length-1,target:{node:t,path:mt}},U.channels.push(b)}}static _CreateBakedAnimation(t,U,y,Y,mt,X,P,G,M,L,h){let Q;const F=I.Quaternion.Identity();let E,w=null,D=null,l=null,g=null,B=null,b=null;L.min=r.Tools.FloatRound(Y/X);const p=U.getKeys();for(let I=0,c=p.length;I<c;++I){if(b=null,l=p[I],I+1<c)if(g=p[I+1],l.value.equals&&l.value.equals(g.value)||l.value===g.value){if(0!==I)continue;b=l.frame}else b=g.frame;else{if(B=p[I-1],l.value.equals&&l.value.equals(B.value)||l.value===B.value)continue;b=mt}if(b)for(let I=l.frame;I<=b;I+=P){if(E=r.Tools.FloatRound(I/X),E===w)continue;w=E,D=E;const Y={key:0,repeatCount:0,loopMode:U.loopMode};Q=U._interpolate(I,Y),Bt._SetInterpolatedValue(t,Q,E,U,y,F,G,M,h)}}D&&(L.max=D)}static _ConvertFactorToVector3OrQuaternion(t,U,y,Y,mt){const X=Bt._GetBasePositionRotationOrScale(U,Y,mt),P=y.targetProperty.split("."),G=P?P[1]:"",M=mt?I.Quaternion.pU(X).normalize():I.DU.pU(X);switch(G){case"x":case"y":case"z":M[G]=t;break;case"w":M.w=t;break;default:r.Tools.Error(`glTFAnimation: Unsupported component name "${G}"!`)}return M}static _SetInterpolatedValue(t,U,y,r,Y,mt,X,P,G){let M;X.push(y),"weights"!==Y?(r.dataType===wt.e.ANIMATIONTYPE_FLOAT&&(U=this._ConvertFactorToVector3OrQuaternion(U,t,r,Y,G)),"rotation"===Y?(G?mt=U:(M=U,I.Quaternion.RotationYawPitchRollToRef(M.y,M.x,M.z,mt)),P.push(mt.bX())):(M=U,P.push(M.bX()))):P.push([U])}static _CreateLinearOrStepAnimation(t,U,y,I,r,Y){for(const mt of U.getKeys())I.push(mt.frame/U.framePerSecond),Bt._AddKeyframeValue(mt,U,r,y,t,Y)}static _CreateCubicSplineAnimation(t,U,y,I,r,Y){U.getKeys().forEach((function(mt){I.push(mt.frame/U.framePerSecond),Bt._AddSplineTangent(Lt.INTANGENT,r,y,"CUBICSPLINE",mt,Y),Bt._AddKeyframeValue(mt,U,r,y,t,Y),Bt._AddSplineTangent(Lt.OUTTANGENT,r,y,"CUBICSPLINE",mt,Y)}))}static _GetBasePositionRotationOrScale(t,U,y){let r;if("rotation"===U)if(y){r=(t.rotationQuaternion??I.Quaternion.Identity()).bX()}else{r=(t.rotation??I.DU.Zero()).bX()}else if("translation"===U){r=(t.position??I.DU.Zero()).bX()}else{r=(t.dX??I.DU.One()).bX()}return r}static _AddKeyframeValue(t,U,y,Y,mt,X){let P;const G=U.dataType;if(G===wt.e.ANIMATIONTYPE_VECTOR3){let U=t.value.bX();if("rotation"===Y){const t=I.DU.pU(U);U=I.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).bX()}y.push(U)}else if(G===wt.e.ANIMATIONTYPE_FLOAT){if("weights"===Y)y.push([t.value]);else if(P=this._ConvertFactorToVector3OrQuaternion(t.value,mt,U,Y,X),P){if("rotation"===Y){const t=X?P:I.Quaternion.RotationYawPitchRoll(P.y,P.x,P.z).normalize();y.push(t.bX())}y.push(P.bX())}}else G===wt.e.ANIMATIONTYPE_QUATERNION?y.push(t.value.normalize().bX()):r.Tools.Error("glTFAnimation: Unsupported key frame values for animation!")}static _DeduceInterpolation(t,U,y){let I,r,Y=!1;if("rotation"===U&&!y)return{interpolationType:"LINEAR",shouldBakeAnimation:!0};for(let mt=0,X=t.length;mt<X;++mt)if(r=t[mt],r.inTangent||r.outTangent)if(I){if("CUBICSPLINE"!==I){I="LINEAR",Y=!0;break}}else I="CUBICSPLINE";else if(I){if("CUBICSPLINE"===I||r.interpolation&&1===r.interpolation&&"STEP"!==I){I="LINEAR",Y=!0;break}}else I=r.interpolation&&1===r.interpolation?"STEP":"LINEAR";return I||(I="LINEAR"),{interpolationType:I,shouldBakeAnimation:Y}}static _AddSplineTangent(t,U,y,r,Y,mt){let X;const P=t===Lt.INTANGENT?Y.inTangent:Y.outTangent;if("CUBICSPLINE"===r){if("rotation"===y)if(P)if(mt)X=P.bX();else{const t=P;X=I.Quaternion.RotationYawPitchRoll(t.y,t.x,t.z).bX()}else X=[0,0,0,0];else X="weights"===y?P?[P]:[0]:P?P.bX():[0,0,0];U.push(X)}}static _CalculateMinMaxKeyFrames(t){let U=1/0,y=-1/0;return t.forEach((function(t){U=Math.min(U,t.frame),y=Math.max(y,t.frame)})),{min:U,max:y}}}function bt(t,U,y,Y,mt,X){const P={attributes:{},influence:t.influence,name:t.name},G=U.NX;if(!G)return r.Tools.Warn("Attempted to export morph target data from a mesh without geometry. This should not happen."),P;const L=X?-1:1,h=I.DU.Zero();let Q=0,F=0;if(t.hasPositions){const Y=t.getPositions(),X=G.getVerticesData(M.e.PositionKind);if(X){const t=new Float32Array(X.length),U=[1/0,1/0,1/0],r=[-1/0,-1/0,-1/0];F=X.length/3,Q=0;for(let y=Q;y<F;++y){const mt=I.DU.pU(X,3*y);I.DU.pU(Y,3*y).subtractToRef(mt,h),h.x*=L,U[0]=Math.min(U[0],h.x),r[0]=Math.max(r[0],h.x),U[1]=Math.min(U[1],h.y),r[1]=Math.max(r[1],h.y),U[2]=Math.min(U[2],h.z),r[2]=Math.max(r[2],h.z),t[3*y]=h.x,t[3*y+1]=h.y,t[3*y+2]=h.z}const G=y.createBufferView(t,12),M=y.createAccessor(G,"VEC3",5126,Y.length/3,0,{min:U,max:r});mt.push(M),P.attributes.POSITION=mt.length-1}else r.Tools.Warn(`Morph target positions for mesh ${U.name} were not exported. Mesh does not have position vertex data`)}if(t.hasNormals){const Y=t.getNormals(),X=G.getVerticesData(M.e.NormalKind);if(X){const t=new Float32Array(X.length);F=X.length/3,Q=0;for(let y=Q;y<F;++y){const U=I.DU.pU(X,3*y).normalize();I.DU.pU(Y,3*y).normalize().subtractToRef(U,h),t[3*y]=h.x*L,t[3*y+1]=h.y,t[3*y+2]=h.z}const U=y.createBufferView(t,12),r=y.createAccessor(U,"VEC3",5126,Y.length/3,0);mt.push(r),P.attributes.NORMAL=mt.length-1}else r.Tools.Warn(`Morph target normals for mesh ${U.name} were not exported. Mesh does not have normals vertex data`)}if(t.hasTangents){const Y=t.getTangents(),X=G.getVerticesData(M.e.TangentKind);if(X){F=X.length/4;const t=new Float32Array(3*F);Q=0;for(let y=Q;y<F;++y){const U=I.DU.pU(X,4*y);R(U);const r=I.DU.pU(Y,3*y);R(r),r.subtractToRef(U,h),t[3*y]=h.x*L,t[3*y+1]=h.y,t[3*y+2]=h.z}const U=y.createBufferView(t,12),r=y.createAccessor(U,"VEC3",5126,F,0);mt.push(r),P.attributes.TANGENT=mt.length-1}else r.Tools.Warn(`Morph target tangents for mesh ${U.name} were not exported. Mesh does not have tangents vertex data`)}if(t.hasColors){const Y=t.getColors(),X=G.getVerticesData(M.e.ColorKind),L=G.getVertexBuffer(M.e.ColorKind);if(X&&L){const t=L.getSize();F=X.length/t;const U=new Float32Array(F*t);Q=0;for(let y=Q;y<F;++y)if(3===t){const r=I.DU.pU(X,y*t);I.DU.pU(Y,y*t).subtractToRef(r,h),U[3*y]=h.x,U[3*y+1]=h.y,U[3*y+2]=h.z}else if(4===t){const r=new I.Vector4,mt=I.Vector4.pU(X,y*t);I.Vector4.pU(Y,y*t).subtractToRef(mt,r),U[4*y]=r.x,U[4*y+1]=r.y,U[4*y+2]=r.z,U[4*y+3]=r.w}else r.Tools.Warn(`Unsupported number of components for color attribute: ${t}`);const G=y.createBufferView(U,4*t),M=y.createAccessor(G,3===t?"VEC3":"VEC4",5126,F,0);mt.push(M),P.attributes.COLOR_0=mt.length-1}else r.Tools.Warn(`Morph target colors for mesh ${U.name} were not exported. Mesh does not have colors vertex data`)}return P}var pt=y(12982),ct=y(12814),ft=y(12800),St=y(12338);class Nt{}Nt.DEFAULT_COLOR=w.bU.White(),Nt.DEFAULT_WIDTH_ATTENUATED=1,Nt.DEFAULT_WIDTH=.1;var jt=y(12623),Jt=y(12986);class at{static ConvertPoints(t,U){if(t.length&&Array.isArray(t)&&"number"===typeof t[0])return[t];if(t.length&&Array.isArray(t[0])&&"number"===typeof t[0][0])return t;if(t.length&&!Array.isArray(t[0])&&t[0]instanceof I.DU){const U=[];for(let y=0;y<t.length;y++){const I=t[y];U.push(I.x,I.y,I.z)}return[U]}if(t.length>0&&Array.isArray(t[0])&&t[0].length>0&&t[0][0]instanceof I.DU){const U=[],y=t;for(const t of y)U.push(t.flatMap((t=>[t.x,t.y,t.z])));return U}if(t instanceof Float32Array){if(null!==U&&void 0!==U&&U.floatArrayStride){const y=[],I=3*U.floatArrayStride;for(let U=0;U<t.length;U+=I){const r=new Array(I);for(let y=0;y<I;y++)r[y]=t[U+y];y.push(r)}return y}return[Array.from(t)]}if(t.length&&t[0]instanceof Float32Array){const U=[];for(const y of t)U.push(Array.from(y));return U}return[]}static OmitZeroLengthPredicate(t,U,y){const I=[];return U.lU(t).lengthSquared()>0&&I.push([t,U]),y.lU(U).lengthSquared()>0&&I.push([U,y]),t.lU(y).lengthSquared()>0&&I.push([y,t]),0===I.length?null:I}static OmitDuplicatesPredicate(t,U,y,I){const r=[];return at._SearchInPoints(t,U,I)||r.push([t,U]),at._SearchInPoints(U,y,I)||r.push([U,y]),at._SearchInPoints(y,t,I)||r.push([y,t]),0===r.length?null:r}static _SearchInPoints(t,U,y){for(const mt of y)for(let y=0;y<mt.length;y++){var I,r,Y;if(null!==(I=mt[y])&&void 0!==I&&I.equals(t))if(null!==(r=mt[y+1])&&void 0!==r&&r.equals(U)||null!==(Y=mt[y-1])&&void 0!==Y&&Y.equals(U))return!0}return!1}static MeshesToLines(t,U){const y=[];for(let r=0;r<t.length;r++){const Y=t[r],mt=Y.getVerticesData(M.e.PositionKind),X=Y.jX();if(mt&&X)for(let t=0,P=0;t<X.length;t++){const G=3*X[P++],M=3*X[P++],L=3*X[P++],h=new I.DU(mt[G],mt[G+1],mt[G+2]),Q=new I.DU(mt[M],mt[M+1],mt[M+2]),F=new I.DU(mt[L],mt[L+1],mt[L+2]);if(U){const I=U(h,Q,F,y,t,G,Y,r,mt,X);if(I)for(const t of I)y.push(t)}else y.push([h,Q],[Q,F],[F,h])}}return y}static ToVector3Array(t){if(Array.isArray(t[0])){const U=[],y=t;for(const t of y){const y=[];for(let U=0;U<t.length;U+=3)y.push(new I.DU(t[U],t[U+1],t[U+2]));U.push(y)}return U}const U=t,y=[];for(let r=0;r<U.length;r+=3)y.push(new I.DU(U[r],U[r+1],U[r+2]));return y}static ToNumberArray(t){return t.flatMap((t=>[t.x,t.y,t.z]))}static GetPointsCountInfo(t){const U=new Array(t.length);let y=0;for(let I=t.length;I--;)U[I]=t[I].length/3,y+=U[I];return{total:y,counts:U}}static GetLineLength(t){if(0===t.length)return 0;let U;U="number"===typeof t[0]?at.ToVector3Array(t):t;const y=I.TmpVectors.DU[0];let r=0;for(let I=0;I<U.length-1;I++){const t=U[I];r+=U[I+1].subtractToRef(t,y).length()}return r}static GetLineLengthArray(t){const U=new Float32Array(t.length/3);let y=0;for(let I=0,r=t.length/3-1;I<r;I++){let r=t[3*I+0],Y=t[3*I+1],mt=t[3*I+2];r-=t[3*I+3],Y-=t[3*I+4],mt-=t[3*I+5];y+=Math.sqrt(r*r+Y*Y+mt*mt),U[I+1]=y}return U}static SegmentizeSegmentByCount(t,U,y){const r=[],Y=U.lU(t),mt=I.TmpVectors.DU[0];mt.qX(y);const X=I.TmpVectors.DU[1];Y.divideToRef(mt,X);let P=t.clone();r.push(P);for(let I=0;I<y;I++)P=P.clone(),r.push(P.addInPlace(X));return r}static SegmentizeLineBySegmentLength(t,U){const y=t[0]instanceof I.DU?at.GetLineSegments(t):"number"===typeof t[0]?at.GetLineSegments(at.ToVector3Array(t)):t,r=[];for(const I of y)if(I.length>U){const t=at.SegmentizeSegmentByCount(I.point1,I.point2,Math.ceil(I.length/U));for(const U of t)r.push(U)}else r.push(I.point1),r.push(I.point2);return r}static SegmentizeLineBySegmentCount(t,U){const y="number"===typeof t[0]?at.ToVector3Array(t):t,I=at.GetLineLength(y)/U;return at.SegmentizeLineBySegmentLength(y,I)}static GetLineSegments(t){const U=[];for(let y=0;y<t.length-1;y++){const I=t[y],r=t[y+1],Y=r.lU(I).length();U.push({point1:I,point2:r,length:Y})}return U}static GetMinMaxSegmentLength(t){const U=at.GetLineSegments(t).sort((t=>t.length));return{min:U[0].length,max:U[U.length-1].length}}static GetPositionOnLineByVisibility(t,U,y){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const Y=U*y;let mt=0,X=0;const P=t.length;for(let I=0;I<P;I++){if(Y<=mt+t[I].length){X=I;break}mt+=t[I].length}const G=(Y-mt)/t[X].length;return t[X].point2.subtractToRef(t[X].point1,I.TmpVectors.DU[0]),I.TmpVectors.DU[1]=I.TmpVectors.DU[0].multiplyByFloats(G,G,G),r||I.TmpVectors.DU[1].addInPlace(t[X].point1),I.TmpVectors.DU[1].clone()}static GetCircleLinePoints(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t,Y=arguments.length>4&&void 0!==arguments[4]?arguments[4]:2*Math.PI/U;const mt=[];for(let X=0;X<=U;X++)mt.push(new I.DU(Math.cos(X*Y)*t,Math.sin(X*Y)*r,y));return mt}static GetBezierLinePoints(t,U,y,I){return jt.h.CreateQuadraticBezier(t,U,y,I).getPoints().flatMap((t=>[t.x,t.y,t.z]))}static GetArrowCap(t,U,y,I,r){let Y=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,mt=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;return{points:[t.clone(),t.add(U.multiplyByFloats(y,y,y))],widths:[I,r,Y,mt]}}static GetPointsFromText(t,U,y,I){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,Y=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const mt=[],X=(0,Jt.c)(t,U,y,I);for(const P of X){for(const t of P.paths){const U=[],y=t.getPoints();for(const t of y)U.push(t.x,t.y,r);mt.push(U)}if(Y)for(const t of P.holes){const U=[],y=t.getPoints();for(const t of y)U.push(t.x,t.y,r);mt.push(U)}}return mt}static Color3toRGBAUint8(t){const U=new Uint8Array(4*t.length);for(let y=0,I=0;y<t.length;y++)U[I++]=255*t[y].r,U[I++]=255*t[y].g,U[I++]=255*t[y].b,U[I++]=255;return U}static CreateColorsTexture(t,U,y,I){const r=I.getEngine().getCaps().maxTextureSize??1,Y=U.length>r?r:U.length,mt=Math.ceil(U.length/r);mt>1&&(U=[...U,...Array(Y*mt-U.length).fill(U[0])]);const X=at.Color3toRGBAUint8(U),P=new p.b(X,Y,mt,F.c.TEXTUREFORMAT_RGBA,I,!1,!0,y);return P.name=t,P}static PrepareEmptyColorsTexture(t){if(!Nt.EmptyColorsTexture){const U=new Uint8Array(4);Nt.EmptyColorsTexture=new p.b(U,1,1,F.c.TEXTUREFORMAT_RGBA,t,!1,!1,p.b.NEAREST_NEAREST),Nt.EmptyColorsTexture.name="grlEmptyColorsTexture"}return Nt.EmptyColorsTexture}static DisposeEmptyColorsTexture(){var t;null===(t=Nt.EmptyColorsTexture)||void 0===t||t.dispose(),Nt.EmptyColorsTexture=null}static BooleanToNumber(t){return t?1:0}}class dt extends ft.e{constructor(){super(...arguments),this.GREASED_LINE_HAS_COLOR=!1,this.GREASED_LINE_SIZE_ATTENUATION=!1,this.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=!1,this.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=!1,this.GREASED_LINE_CAMERA_FACING=!0,this.GREASED_LINE_USE_OFFSETS=!1}}class qt extends ct.b{isCompatible(t){return!0}constructor(t,U,y){var r;y=y||{color:Nt.DEFAULT_COLOR};const Y=new dt;Y.GREASED_LINE_HAS_COLOR=!!y.color&&!y.useColors,Y.GREASED_LINE_SIZE_ATTENUATION=y.sizeAttenuation??!1,Y.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===y.colorDistributionType,Y.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=(U??t.St()).useRightHandedSystem,Y.GREASED_LINE_CAMERA_FACING=y.cameraFacing??!0,super(t,qt.GREASED_LINE_MATERIAL_NAME,200,Y,!0,!0),this.colorsTexture=null,this._forceGLSL=!1,this._forceGLSL=(null===(r=y)||void 0===r?void 0:r.forceGLSL)||qt.ForceGLSL,this._scene=U??t.St(),this._engine=this._scene.getEngine(),this._cameraFacing=y.cameraFacing??!0,this.visibility=y.visibility??1,this.useDash=y.useDash??!1,this.dashRatio=y.dashRatio??.5,this.dashOffset=y.dashOffset??0,this.width=y.width?y.width:y.sizeAttenuation?Nt.DEFAULT_WIDTH_ATTENUATED:Nt.DEFAULT_WIDTH,this._sizeAttenuation=y.sizeAttenuation??!1,this.colorMode=y.colorMode??0,this._color=y.color??null,this.useColors=y.useColors??!1,this._colorsDistributionType=y.colorDistributionType??0,this.colorsSampling=y.colorsSampling??p.b.NEAREST_NEAREST,this._colors=y.dt??null,this.dashCount=y.dashCount??1,this.resolution=y.resolution??new I.Vector2(this._engine.getRenderWidth(),this._engine.getRenderHeight()),y.colorsTexture?this.colorsTexture=y.colorsTexture:this._colors?this.colorsTexture=at.CreateColorsTexture(`${t.name}-colors-texture`,this._colors,this.colorsSampling,this._scene):(this._color=this._color??Nt.DEFAULT_COLOR,at.PrepareEmptyColorsTexture(this._scene)),this._engine.FX.add((()=>{at.DisposeEmptyColorsTexture()}))}getAttributes(t){t.push("grl_offsets"),t.push("grl_widths"),t.push("grl_colorPointers"),t.push("grl_counters"),this._cameraFacing?(t.push("grl_previousAndSide"),t.push("grl_nextAndCounters")):t.push("grl_slopes")}getSamplers(t){t.push("grl_colors")}getActiveTextures(t){this.colorsTexture&&t.push(this.colorsTexture)}getUniforms(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const U=[{name:"grl_singleColor",size:3,type:"vec3"},{name:"grl_textureSize",size:2,type:"vec2"},{name:"grl_dashOptions",size:4,type:"vec4"},{name:"grl_colorMode_visibility_colorsWidth_useColors",size:4,type:"vec4"}];return this._cameraFacing&&U.push({name:"grl_projection",size:16,type:"mat4"},{name:"grl_aspect_resolution_lineWidth",size:4,type:"vec4"}),1===t&&U.push({name:"viewProjection",size:16,type:"mat4"}),{ubo:U,vertex:this._cameraFacing&&this._isGLSL(t)?"\n                    uniform vec4 grl_aspect_resolution_lineWidth;\n                    uniform mat4 grl_projection;\n    ":"",fragment:this._isGLSL(t)?"\n                    uniform vec4 grl_dashOptions;\n                    uniform vec2 grl_textureSize;\n                    uniform vec4 grl_colorMode_visibility_colorsWidth_useColors;\n                    uniform vec3 grl_singleColor;\n    ":""}}get isEnabled(){return!0}bindForSubMesh(t){if(this._cameraFacing){t.fX("grl_projection",this._scene.getProjectionMatrix()),this._isGLSL(this._material.shaderLanguage)||t.fX("viewProjection",this._scene.getTransformMatrix());const U=I.TmpVectors.Vector4[0];U.x=this._aspect,U.y=this._resolution.x,U.z=this._resolution.y,U.w=this.width,t.updateVector4("grl_aspect_resolution_lineWidth",U)}const U=I.TmpVectors.Vector4[0];U.x=at.BooleanToNumber(this.useDash),U.y=this._dashArray,U.z=this.dashOffset,U.w=this.dashRatio,t.updateVector4("grl_dashOptions",U);const y=I.TmpVectors.Vector4[1];y.x=this.colorMode,y.y=this.visibility,y.z=this.colorsTexture?this.colorsTexture.getSize().width:0,y.w=at.BooleanToNumber(this.useColors),t.updateVector4("grl_colorMode_visibility_colorsWidth_useColors",y),this._color&&t.updateColor3("grl_singleColor",this._color);const r=this.colorsTexture??Nt.EmptyColorsTexture;t.setTexture("grl_colors",r),t.updateFloat2("grl_textureSize",(null===r||void 0===r?void 0:r.getSize().width)??1,(null===r||void 0===r?void 0:r.getSize().height)??1)}prepareDefines(t,U,y){t.GREASED_LINE_HAS_COLOR=!!this.color&&!this.useColors,t.GREASED_LINE_SIZE_ATTENUATION=this._sizeAttenuation,t.GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE=1===this._colorsDistributionType,t.GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM=U.useRightHandedSystem,t.GREASED_LINE_CAMERA_FACING=this._cameraFacing,t.GREASED_LINE_USE_OFFSETS=!!y.offsets}getClassName(){return qt.GREASED_LINE_MATERIAL_NAME}getCustomCode(t){let U=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return this._isGLSL(U)?function(t,U){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute float grl_widths;\n                attribute vec3 grl_offsets;\n                attribute float grl_colorPointers;\n                varying float grlCounters;\n                varying float grlColorPointer;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute vec4 grl_previousAndSide;\n                    attribute vec4 grl_nextAndCounters;\n\n                    vec2 grlFix( vec4 i, float aspect ) {\n                        vec2 res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute vec3 grl_slopes;\n                    attribute float grl_counters;\n                #endif\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    vec3 grlPositionOffset = grl_offsets;\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grl_offsets) + (grl_slopes * grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                grlColorPointer = grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    float grlAspect = grl_aspect_resolution_lineWidth.x;\n                    float grlBaseWidth = grl_aspect_resolution_lineWidth.w;\n\n                    vec3 grlPrevious = grl_previousAndSide.xyz;\n                    float grlSide = grl_previousAndSide.w;\n\n                    vec3 grlNext = grl_nextAndCounters.xyz;\n                    grlCounters = grl_nextAndCounters.w;\n                    float grlWidth = grlBaseWidth * grl_widths;\n                    \n                    vec3 worldDir = normalize(grlNext - grlPrevious);\n                    vec3 nearPosition = positionUpdated + (worldDir * 0.001);\n                    mat4 grlMatrix = viewProjection * finalWorld;\n                    vec4 grlFinalPosition = grlMatrix * vec4(positionUpdated , 1.0);\n                    vec4 screenNearPos = grlMatrix * vec4(nearPosition, 1.0);\n                    vec2 grlLinePosition = grlFix(grlFinalPosition, grlAspect);\n                    vec2 grlLineNearPosition = grlFix(screenNearPos, grlAspect);\n                    vec2 grlDir = normalize(grlLineNearPosition - grlLinePosition);\n\n                    vec4 grlNormal = vec4(-grlDir.y, grlDir.x, 0., 1.);\n\n                    #ifdef GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM\n                        grlNormal.xy *= -.5 * grlWidth;\n                    #else\n                        grlNormal.xy *= .5 * grlWidth;\n                    #endif\n\n                    grlNormal *= grl_projection;\n\n                    #ifdef GREASED_LINE_SIZE_ATTENUATION\n                        grlNormal.xy *= grlFinalPosition.w;\n                        grlNormal.xy /= (vec4(grl_aspect_resolution_lineWidth.yz, 0., 1.) * grl_projection).xy;\n                    #endif\n\n                    grlFinalPosition.xy += grlNormal.xy * grlSide;\n                    gl_Position = grlFinalPosition;\n\n                    vPositionW = vec3(grlFinalPosition);\n                #else\n                    grlCounters = grl_counters;\n                #endif\n                "};return U&&(t["!gl_Position\\=viewProjection\\*worldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying float grlCounters;\n                    varying float grlColorPointer;\n                    uniform sampler2D grl_colors;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    float grlColorMode = grl_colorMode_visibility_colorsWidth_useColors.x;\n                    float grlVisibility = grl_colorMode_visibility_colorsWidth_useColors.y;\n                    float grlColorsWidth = grl_colorMode_visibility_colorsWidth_useColors.z;\n                    float grlUseColors = grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    float grlUseDash = grl_dashOptions.x;\n                    float grlDashArray = grl_dashOptions.y;\n                    float grlDashOffset = grl_dashOptions.z;\n                    float grlDashRatio = grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(grlCounters, grlVisibility);\n                    if(grlFinalColor.a == 0.) discard;\n\n                    if(grlUseDash == 1.){\n                        grlFinalColor.a *= ceil(mod(grlCounters + grlDashOffset, grlDashArray) - (grlDashArray * grlDashRatio));\n                        if (grlFinalColor.a == 0.) discard;\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor.rgb = grl_singleColor;\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor.rgb += grl_singleColor;\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor.rgb *= grl_singleColor;\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                vec4 grlColor = texture2D(grl_colors, vec2(grlCounters, 0.), 0.);\n                            #else\n                                vec2 lookup = vec2(fract(grlColorPointer / grl_textureSize.x), 1.0 - floor(grlColorPointer / grl_textureSize.x) / max(grl_textureSize.y - 1.0, 1.0));\n                                vec4 grlColor = texture2D(grl_colors, lookup, 0.0);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n                "}:null}(t,this._cameraFacing):function(t,U){if("vertex"===t){const t={CUSTOM_VERTEX_DEFINITIONS:"\n                attribute grl_widths: f32;\n                attribute grl_colorPointers: f32;\n                varying grlCounters: f32;\n                varying grlColorPointer: f32;\n\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    attribute grl_offsets: vec3f;   \n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    attribute grl_previousAndSide : vec4f;\n                    attribute grl_nextAndCounters : vec4f;\n\n                    fn grlFix(i: vec4f, aspect: f32) -> vec2f {\n                        var res = i.xy / i.w;\n                        res.x *= aspect;\n                        return res;\n                    }\n                #else\n                    attribute grl_slopes: f32;\n                    attribute grl_counters: f32;\n                #endif\n\n\n                ",CUSTOM_VERTEX_UPDATE_POSITION:"\n                #ifdef GREASED_LINE_USE_OFFSETS\n                    var grlPositionOffset: vec3f = input.grl_offsets;\n                #else\n                    var grlPositionOffset = vec3f(0.);\n                #endif\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n                    positionUpdated += grlPositionOffset;\n                #else\n                    positionUpdated = (positionUpdated + grlPositionOffset) + (input.grl_slopes * input.grl_widths);\n                #endif\n                ",CUSTOM_VERTEX_MAIN_END:"\n                vertexOutputs.grlColorPointer = input.grl_colorPointers;\n\n                #ifdef GREASED_LINE_CAMERA_FACING\n\n                    let grlAspect: f32 = uniforms.grl_aspect_resolution_lineWidth.x;\n                    let grlBaseWidth: f32 = uniforms.grl_aspect_resolution_lineWidth.w;\n\n                    let grlPrevious: vec3f = input.grl_previousAndSide.xyz;\n                    let grlSide: f32 = input.grl_previousAndSide.w;\n\n                    let grlNext: vec3f = input.grl_nextAndCounters.xyz;\n                    vertexOutputs.grlCounters = input.grl_nextAndCounters.w;\n\n                    let grlWidth: f32 = grlBaseWidth * input.grl_widths;\n\n                    let worldDir: vec3f = normalize(grlNext - grlPrevious);\n                    let nearPosition: vec3f = positionUpdated + (worldDir * 0.001);\n                    let grlMatrix: mat4x4f = uniforms.viewProjection * finalWorld;\n                    let grlFinalPosition: vec4f = grlMatrix * vec4f(positionUpdated, 1.0); \n                    let screenNearPos: vec4f = grlMatrix * vec4(nearPosition, 1.0);\n                    let grlLinePosition: vec2f = grlFix(grlFinalPosition, grlAspect);\n                    let grlLineNearPosition: vec2f = grlFix(screenNearPos, grlAspect);\n                    let grlDir: vec2f = normalize(grlLineNearPosition - grlLinePosition);\n\n                    var grlNormal: vec4f = vec4f(-grlDir.y, grlDir.x, 0.0, 1.0);\n\n                    let grlHalfWidth: f32 = 0.5 * grlWidth;\n                    #if defined(GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM)\n                        grlNormal.x *= -grlHalfWidth;\n                        grlNormal.y *= -grlHalfWidth;\n                    #else\n                        grlNormal.x *= grlHalfWidth;\n                        grlNormal.y *= grlHalfWidth;\n                    #endif\n\n                    grlNormal *= uniforms.grl_projection;\n\n                    #if defined(GREASED_LINE_SIZE_ATTENUATION)\n                        grlNormal.x *= grlFinalPosition.w;\n                        grlNormal.y *= grlFinalPosition.w;\n\n                        let pr = vec4f(uniforms.grl_aspect_resolution_lineWidth.yz, 0.0, 1.0) * uniforms.grl_projection;\n                        grlNormal.x /= pr.x;\n                        grlNormal.y /= pr.y;\n                    #endif\n\n                    vertexOutputs.position = vec4f(grlFinalPosition.xy + grlNormal.xy * grlSide, grlFinalPosition.z, grlFinalPosition.w);\n                    vertexOutputs.vPositionW = vertexOutputs.position.xyz;\n                \n                #else\n                    vertexOutputs.grlCounters = input.grl_counters;\n                #endif\n                "};return U&&(t["!vertexOutputs\\.position\\s=\\sscene\\.viewProjection\\s\\*\\sworldPos;"]="//"),t}return"fragment"===t?{CUSTOM_FRAGMENT_DEFINITIONS:"\n                    #ifdef PBR\n                         #define grlFinalColor finalColor\n                    #else\n                         #define grlFinalColor color\n                    #endif\n\n                    varying grlCounters: f32;\n                    varying grlColorPointer: 32;\n\n                    var grl_colors: texture_2d<f32>;\n                    var grl_colorsSampler: sampler;\n                ",CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR:"\n                    let grlColorMode: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.x;\n                    let grlVisibility: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.y;\n                    let grlColorsWidth: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.z;\n                    let grlUseColors: f32 = uniforms.grl_colorMode_visibility_colorsWidth_useColors.w;\n\n                    let grlUseDash: f32 = uniforms.grl_dashOptions.x;\n                    let grlDashArray: f32 = uniforms.grl_dashOptions.y;\n                    let grlDashOffset: f32 = uniforms.grl_dashOptions.z;\n                    let grlDashRatio: f32 = uniforms.grl_dashOptions.w;\n\n                    grlFinalColor.a *= step(fragmentInputs.grlCounters, grlVisibility);\n                    if (grlFinalColor.a == 0.0) {\n                        discard;\n                    }\n\n                    if (grlUseDash == 1.0) {\n                        let dashPosition = (fragmentInputs.grlCounters + grlDashOffset) % grlDashArray;\n                        grlFinalColor.a *= ceil(dashPosition - (grlDashArray * grlDashRatio));\n\n                        if (grlFinalColor.a == 0.0) {\n                            discard;\n                        }\n                    }\n\n                    #ifdef GREASED_LINE_HAS_COLOR\n                        if (grlColorMode == 0.) {\n                            grlFinalColor = vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 1.) {\n                            grlFinalColor += vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        } else if (grlColorMode == 2.) {\n                            grlFinalColor *= vec4f(uniforms.grl_singleColor, grlFinalColor.a);\n                        }\n                    #else\n                        if (grlUseColors == 1.) {\n                            #ifdef GREASED_LINE_COLOR_DISTRIBUTION_TYPE_LINE\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, vec2f(fragmentInputs.grlCounters, 0.));\n                            #else\n                                let lookup: vec2f = vec2(fract(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x), 1.0 - floor(fragmentInputs.grlColorPointer / uniforms.grl_textureSize.x) / max(uniforms.grl_textureSize.y - 1.0, 1.0));\n                                let grlColor: vec4f = textureSample(grl_colors, grl_colorsSampler, lookup);\n                            #endif\n                            if (grlColorMode == 0.) {\n                                grlFinalColor = grlColor;\n                            } else if (grlColorMode == 1.) {\n                                grlFinalColor += grlColor;\n                            } else if (grlColorMode == 2.) {\n                                grlFinalColor *= grlColor;\n                            }\n                        }\n                    #endif\n\n\n                "}:null}(t,this._cameraFacing)}dispose(){var t;null===(t=this.colorsTexture)||void 0===t||t.dispose(),super.dispose()}get dt(){return this._colors}set dt(t){this.setColors(t)}setColors(t){var U;let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var Y;if(this._colors=t,null!==t&&0!==t.length){if(!y||I)if(this.colorsTexture&&r===t.length&&!I){const U=at.Color3toRGBAUint8(t);this.colorsTexture.update(U)}else{var mt;null===(mt=this.colorsTexture)||void 0===mt||mt.dispose(),this.colorsTexture=at.CreateColorsTexture(`${this._material.name}-colors-texture`,t,this.colorsSampling,this._scene)}}else null===(Y=this.colorsTexture)||void 0===Y||Y.dispose()}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.markAllDefinesAsDirty()}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];null===this._color&&null!==t||null!==this._color&&null===t?(this._color=t,U||this.markAllDefinesAsDirty()):this._color=t}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this.markAllDefinesAsDirty()}get resolution(){return this._resolution}set resolution(t){this._aspect=t.x/t.y,this._resolution=t}serialize(){const t=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this.colorsSampling,colorMode:this.colorMode,dashCount:this._dashCount,dashOffset:this.dashOffset,dashRatio:this.dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this.useColors,useDash:this.useDash,visibility:this.visibility,width:this.width};return this._colors&&(U.dt=this._colors),this._color&&(U.color=this._color),t.greasedLineMaterialOptions=U,t}parse(t,U,y){var I;super.parse(t,U,y);const r=t.greasedLineMaterialOptions;null===(I=this.colorsTexture)||void 0===I||I.dispose(),r.color&&this.setColor(r.color,!0),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.dt&&(this.dt=r.dt),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),this.dt?this.colorsTexture=at.CreateColorsTexture(`${this._material.name}-colors-texture`,this.dt,this.colorsSampling,U):at.PrepareEmptyColorsTexture(U),this.markAllDefinesAsDirty()}copyTo(t){var U;const y=t;null===(U=y.colorsTexture)||void 0===U||U.dispose(),this._colors&&(y.colorsTexture=at.CreateColorsTexture(`${y._material.name}-colors-texture`,this._colors,y.colorsSampling,this._scene)),y.setColor(this.color,!0),y.colorsDistributionType=this.colorsDistributionType,y.colorsSampling=this.colorsSampling,y.colorMode=this.colorMode,y.useColors=this.useColors,y.visibility=this.visibility,y.useDash=this.useDash,y.dashCount=this.dashCount,y.dashRatio=this.dashRatio,y.dashOffset=this.dashOffset,y.width=this.width,y.sizeAttenuation=this.sizeAttenuation,y.resolution=this.resolution,y.markAllDefinesAsDirty()}_isGLSL(t){return 0===t||this._forceGLSL}}qt.GREASED_LINE_MATERIAL_NAME="GreasedLinePluginMaterial",qt.ForceGLSL=!1,(0,St.f)(`BABYLON.${qt.GREASED_LINE_MATERIAL_NAME}`,qt);var Ht=y(12853),et=y(12229),ot=y(12647),Vt=y(12324);class nt extends ot.ShaderMaterial{constructor(t,U,r){const Y=U.getEngine(),mt=Y.isWebGPU&&!(r.forceGLSL||nt.ForceGLSL),X=["COLOR_DISTRIBUTION_TYPE_LINE 1.","COLOR_DISTRIBUTION_TYPE_SEGMENT 0.","COLOR_MODE_SET 0.","COLOR_MODE_ADD 1.","COLOR_MODE_MULTIPLY 2."];U.useRightHandedSystem&&X.push("GREASED_LINE_RIGHT_HANDED_COORDINATE_SYSTEM");const P=["position","grl_widths","grl_offsets","grl_colorPointers"];r.cameraFacing?(X.push("GREASED_LINE_CAMERA_FACING"),P.push("grl_previousAndSide","grl_nextAndCounters")):(P.push("grl_slopes"),P.push("grl_counters"));const G=["grlColorsWidth","grlUseColors","grlWidth","grlColor","grl_colorModeAndColorDistributionType","grlResolution","grlAspect","grlAizeAttenuation","grlDashArray","grlDashOffset","grlDashRatio","grlUseDash","grlVisibility","grlColors"];if(mt||G.push("world","viewProjection","view","projection"),super(t,U,{vertex:"greasedLine",fragment:"greasedLine"},{uniformBuffers:mt?["Scene","Mesh"]:void 0,attributes:P,uniforms:G,samplers:mt?[]:["grlColors"],defines:X,extraInitializationsAsync:async()=>{mt?await Promise.all([y.e(66).then(y.bind(y,15300)),y.e(75).then(y.bind(y,15302))]):await Promise.all([y.e(69).then(y.bind(y,15306)),y.e(76).then(y.bind(y,15308))])},shaderLanguage:mt?1:0}),this._color=w.bU.White(),this._colorsDistributionType=0,this._colorsTexture=null,r=r||{color:Nt.DEFAULT_COLOR},this.visibility=r.visibility??1,this.useDash=r.useDash??!1,this.dashRatio=r.dashRatio??.5,this.dashOffset=r.dashOffset??0,this.dashCount=r.dashCount??1,this.width=r.width?r.width:r.sizeAttenuation&&r.cameraFacing?Nt.DEFAULT_WIDTH_ATTENUATED:Nt.DEFAULT_WIDTH,this.sizeAttenuation=r.sizeAttenuation??!1,this.color=r.color??w.bU.White(),this.useColors=r.useColors??!1,this.colorsDistributionType=r.colorDistributionType??0,this.colorsSampling=r.colorsSampling??p.b.NEAREST_NEAREST,this.colorMode=r.colorMode??0,this._colors=r.dt??null,this._cameraFacing=r.cameraFacing??!0,this.resolution=r.resolution??new I.Vector2(Y.getRenderWidth(),Y.getRenderHeight()),r.colorsTexture?this.colorsTexture=r.colorsTexture:this._colors?this.colorsTexture=at.CreateColorsTexture(`${this.name}-colors-texture`,this._colors,this.colorsSampling,U):(this._color=this._color??Nt.DEFAULT_COLOR,this.colorsTexture=at.PrepareEmptyColorsTexture(U)),mt){const t=new Vt.e;t.setParameters(),t.samplingMode=this.colorsSampling,this.setTextureSampler("grlColorsSampler",t)}Y.FX.add((()=>{at.DisposeEmptyColorsTexture()}))}dispose(){var t;null===(t=this._colorsTexture)||void 0===t||t.dispose(),super.dispose()}_setColorModeAndColorDistributionType(){this.setVector2("grl_colorModeAndColorDistributionType",new I.Vector2(this._colorMode,this._colorsDistributionType))}updateLazy(){this._colors&&this.setColors(this._colors,!1,!0)}get dt(){return this._colors}set dt(t){this.setColors(t)}setColors(t){var U;let y=arguments.length>1&&void 0!==arguments[1]&&arguments[1],I=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=(null===(U=this._colors)||void 0===U?void 0:U.length)??0;var Y;if(this._colors=t,null!==t&&0!==t.length){if(!y||I)if(this._colorsTexture&&r===t.length&&!I){const U=at.Color3toRGBAUint8(t);this._colorsTexture.update(U)}else{var mt;null===(mt=this._colorsTexture)||void 0===mt||mt.dispose(),this.colorsTexture=at.CreateColorsTexture(`${this.name}-colors-texture`,t,this.colorsSampling,this.St())}}else null===(Y=this._colorsTexture)||void 0===Y||Y.dispose()}get colorsTexture(){return this._colorsTexture??null}set colorsTexture(t){this._colorsTexture=t,this.setFloat("grlColorsWidth",this._colorsTexture.getSize().width),this.setTexture("grlColors",this._colorsTexture)}get width(){return this._width}set width(t){this._width=t,this.setFloat("grlWidth",t)}get useColors(){return this._useColors}set useColors(t){this._useColors=t,this.setFloat("grlUseColors",at.BooleanToNumber(t))}get colorsSampling(){return this._colorsSampling}set colorsSampling(t){this._colorsSampling=t}get visibility(){return this._visibility}set visibility(t){this._visibility=t,this.setFloat("grlVisibility",t)}get useDash(){return this._useDash}set useDash(t){this._useDash=t,this.setFloat("grlUseDash",at.BooleanToNumber(t))}get dashOffset(){return this._dashOffset}set dashOffset(t){this._dashOffset=t,this.setFloat("grlDashOffset",t)}get dashRatio(){return this._dashRatio}set dashRatio(t){this._dashRatio=t,this.setFloat("grlDashRatio",t)}get dashCount(){return this._dashCount}set dashCount(t){this._dashCount=t,this._dashArray=1/t,this.setFloat("grlDashArray",this._dashArray)}get sizeAttenuation(){return this._sizeAttenuation}set sizeAttenuation(t){this._sizeAttenuation=t,this.setFloat("grlSizeAttenuation",at.BooleanToNumber(t))}get color(){return this._color}set color(t){this.setColor(t)}setColor(t){t=t??Nt.DEFAULT_COLOR,this._color=t,this.setColor3("grlColor",t)}get colorsDistributionType(){return this._colorsDistributionType}set colorsDistributionType(t){this._colorsDistributionType=t,this._setColorModeAndColorDistributionType()}get colorMode(){return this._colorMode}set colorMode(t){this._colorMode=t,this._setColorModeAndColorDistributionType()}get resolution(){return this._resolution}set resolution(t){this._resolution=t,this.setVector2("grlResolution",t),this.setFloat("grlAspect",t.x/t.y)}serialize(){const t=super.serialize(),U={colorDistributionType:this._colorsDistributionType,colorsSampling:this._colorsSampling,colorMode:this._colorMode,color:this._color,dashCount:this._dashCount,dashOffset:this._dashOffset,dashRatio:this._dashRatio,resolution:this._resolution,sizeAttenuation:this._sizeAttenuation,useColors:this._useColors,useDash:this._useDash,visibility:this._visibility,width:this._width,cameraFacing:this._cameraFacing};return this._colors&&(U.dt=this._colors),t.greasedLineMaterialOptions=U,t}parse(t,U,y){var I;const r=t.greasedLineMaterialOptions;null===(I=this._colorsTexture)||void 0===I||I.dispose(),r.color&&(this.color=r.color),r.colorDistributionType&&(this.colorsDistributionType=r.colorDistributionType),r.colorsSampling&&(this.colorsSampling=r.colorsSampling),r.colorMode&&(this.colorMode=r.colorMode),r.useColors&&(this.useColors=r.useColors),r.visibility&&(this.visibility=r.visibility),r.useDash&&(this.useDash=r.useDash),r.dashCount&&(this.dashCount=r.dashCount),r.dashRatio&&(this.dashRatio=r.dashRatio),r.dashOffset&&(this.dashOffset=r.dashOffset),r.width&&(this.width=r.width),r.sizeAttenuation&&(this.sizeAttenuation=r.sizeAttenuation),r.resolution&&(this.resolution=r.resolution),r.dt?this.colorsTexture=at.CreateColorsTexture(`${this.name}-colors-texture`,r.dt,this.colorsSampling,this.St()):this.colorsTexture=at.PrepareEmptyColorsTexture(U),this._cameraFacing=r.cameraFacing??!0,this.setDefine("GREASED_LINE_CAMERA_FACING",this._cameraFacing)}}var it,vt,Ot;nt.ForceGLSL=!1,function(t){t[t.POINTS_MODE_POINTS=0]="POINTS_MODE_POINTS",t[t.POINTS_MODE_PATHS=1]="POINTS_MODE_PATHS"}(it||(it={})),function(t){t[t.FACES_MODE_SINGLE_SIDED=0]="FACES_MODE_SINGLE_SIDED",t[t.FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING=1]="FACES_MODE_SINGLE_SIDED_NO_BACKFACE_CULLING",t[t.FACES_MODE_DOUBLE_SIDED=2]="FACES_MODE_DOUBLE_SIDED"}(vt||(vt={})),function(t){t[t.AUTO_DIRECTIONS_FROM_FIRST_SEGMENT=0]="AUTO_DIRECTIONS_FROM_FIRST_SEGMENT",t[t.AUTO_DIRECTIONS_FROM_ALL_SEGMENTS=1]="AUTO_DIRECTIONS_FROM_ALL_SEGMENTS",t[t.AUTO_DIRECTIONS_ENHANCED=2]="AUTO_DIRECTIONS_ENHANCED",t[t.AUTO_DIRECTIONS_FACE_TO=3]="AUTO_DIRECTIONS_FACE_TO",t[t.AUTO_DIRECTIONS_NONE=99]="AUTO_DIRECTIONS_NONE"}(Ot||(Ot={}));class kt extends lt.c{constructor(t,U,y){super(t,U,null,null,!1,!1),this.name=t,this._options=y,this._lazy=!1,this._updatable=!1,this._engine=U.getEngine(),this._lazy=y.lazy??!1,this._updatable=y.updatable??!1,this._vertexPositions=[],this._indices=[],this._uvs=[],this._points=[],this._colorPointers=y.colorPointers??[],this._widths=y.widths??new Array(y.points.length).fill(1)}getClassName(){return"GreasedLineMesh"}_updateWidthsWithValue(t){let U=0;for(const I of this._points)U+=I.length;const y=U/3*2-this._widths.length;for(let I=0;I<y;I++)this._widths.push(t)}updateLazy(){var t,U;this._setPoints(this._points),this._options.colorPointers||this._updateColorPointers(),this._createVertexBuffers(null===(t=this._options.ribbonOptions)||void 0===t?void 0:t.smoothShading),!this.ot&&this.refreshBoundingInfo(),null===(U=this.greasedLineMaterial)||void 0===U||U.updateLazy()}addPoints(t,U){for(const y of t)this._points.push(y);this._lazy||this.setPoints(this._points,U)}dispose(t){let U=arguments.length>1&&void 0!==arguments[1]&&arguments[1];super.dispose(t,U)}isLazy(){return this._lazy}get qt(){return this._uvs}set qt(t){this._uvs=t instanceof Float32Array?t:new Float32Array(t),this._createVertexBuffers()}get offsets(){return this._offsets}set offsets(t){this.material instanceof nt&&this.material.setDefine("GREASED_LINE_USE_OFFSETS",(null===t||void 0===t?void 0:t.length)>0),this._offsets=t,this._offsetsBuffer?this._offsetsBuffer.update(t):this._createOffsetsBuffer(t)}get widths(){return this._widths}set widths(t){this._widths=t,this._lazy||this._widthsBuffer&&this._widthsBuffer.update(t)}get colorPointers(){return this._colorPointers}set colorPointers(t){this._colorPointers=t,this._lazy||this._colorPointersBuffer&&this._colorPointersBuffer.update(t)}get greasedLineMaterial(){var t,U;if(this.material&&this.material instanceof nt)return this.material;const y=null===(t=this.material)||void 0===t||null===(U=t.pluginManager)||void 0===U?void 0:U.getPlugin(qt.GREASED_LINE_MATERIAL_NAME);return y||void 0}get points(){const t=[];return et.d.DeepCopy(this._points,t),t}setPoints(t,U){this._points=at.ConvertPoints(t,(null===U||void 0===U?void 0:U.pointsOptions)??this._options.pointsOptions),this._updateWidths(),null!==U&&void 0!==U&&U.colorPointers||this._updateColorPointers(),this._setPoints(this._points,U)}_initGreasedLine(){this._vertexPositions=[],this._indices=[],this._uvs=[]}_createLineOptions(){return{points:this._points,colorPointers:this._colorPointers,lazy:this._lazy,updatable:this._updatable,qt:this._uvs,widths:this._widths,ribbonOptions:this._options.ribbonOptions}}serialize(t){super.serialize(t),t.type=this.getClassName(),t.lineOptions=this._createLineOptions()}_createVertexBuffers(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const U=new Ht.b;return U.jt=this._vertexPositions,U.indices=this._indices,U.qt=this._uvs,t&&(U.Jt=[],Ht.b.ComputeNormals(this._vertexPositions,this._indices,U.Jt)),U.et(this,this._options.updatable),U}_createOffsetsBuffer(t){const U=this._scene.getEngine(),y=new M.b(U,t,this._updatable,3);this.setVerticesBuffer(y.createVertexBuffer("grl_offsets",0,3)),this._offsetsBuffer=y}}class st{constructor(t,U){this._indicesAccessorMap=new Map,this._vertexBufferViewMap=new Map,this._vertexAccessorMap=new Map,this._remappedBufferView=new Map,this._meshMorphTargetMap=new Map,this._vertexMapColorAlpha=new Map,this._exportedNodes=new Set,this._meshMap=new Map,this.convertedToRightHandedBuffers=new Map,this.convertToRightHanded=t,this.wasAddedByNoopNode=U}getIndicesAccessor(t,U,y,I,r){var Y,mt,X,P;return null===(Y=this._indicesAccessorMap.get(t))||void 0===Y||null===(mt=Y.get(U))||void 0===mt||null===(X=mt.get(y))||void 0===X||null===(P=X.get(I))||void 0===P?void 0:P.get(r)}setIndicesAccessor(t,U,y,I,r,Y){let mt=this._indicesAccessorMap.get(t);mt||(mt=new Map,this._indicesAccessorMap.set(t,mt));let X=mt.get(U);X||(X=new Map,mt.set(U,X));let P=X.get(y);P||(P=new Map,X.set(y,P));let G=P.get(I);G||(G=new Map,P.set(I,G)),G.set(r,Y)}pushExportedNode(t){this._exportedNodes.has(t)||this._exportedNodes.add(t)}getNodesSet(){return this._exportedNodes}getVertexBufferView(t){return this._vertexBufferViewMap.get(t)}setVertexBufferView(t,U){this._vertexBufferViewMap.set(t,U)}setRemappedBufferView(t,U,y){this._remappedBufferView.set(t,new Map),this._remappedBufferView.get(t).set(U,y)}getRemappedBufferView(t,U){var y;return null===(y=this._remappedBufferView.get(t))||void 0===y?void 0:y.get(U)}getVertexAccessor(t,U,y){var I,r;return null===(I=this._vertexAccessorMap.get(t))||void 0===I||null===(r=I.get(U))||void 0===r?void 0:r.get(y)}setVertexAccessor(t,U,y,I){let r=this._vertexAccessorMap.get(t);r||(r=new Map,this._vertexAccessorMap.set(t,r));let Y=r.get(U);Y||(Y=new Map,r.set(U,Y)),Y.set(y,I)}hasVertexColorAlpha(t){return this._vertexMapColorAlpha.get(t)||!1}setHasVertexColorAlpha(t,U){return this._vertexMapColorAlpha.set(t,U)}getMesh(t){return this._meshMap.get(t)}setMesh(t,U){this._meshMap.set(t,U)}bindMorphDataToMesh(t,U){const y=this._meshMorphTargetMap.get(t)||[];this._meshMorphTargetMap.set(t,y),-1===y.indexOf(U)&&y.push(U)}getMorphTargetsFromMesh(t){return this._meshMorphTargetMap.get(t)}}class xt{_ApplyExtension(t,U,y,I){if(y>=U.length)return Promise.resolve(t);const r=I(U[y],t);return r?r.then((async t=>t?await this._ApplyExtension(t,U,y+1,I):null)):this._ApplyExtension(t,U,y+1,I)}_ApplyExtensions(t,U){const y=[];for(const I of xt._ExtensionNames)y.push(this._extensions[I]);return this._ApplyExtension(t,y,0,U)}_extensionsPreExportTextureAsync(t,U,y){return this._ApplyExtensions(U,((U,I)=>U.preExportTextureAsync&&U.preExportTextureAsync(t,I,y)))}_extensionsPostExportNodeAsync(t,U,y,I,r){return this._ApplyExtensions(U,((U,Y)=>U.postExportNodeAsync&&U.postExportNodeAsync(t,Y,y,I,r,this._bufferManager)))}_extensionsPostExportMaterialAsync(t,U,y){return this._ApplyExtensions(U,((U,I)=>U.postExportMaterialAsync&&U.postExportMaterialAsync(t,I,y)))}_extensionsPostExportMaterialAdditionalTextures(t,U,y){const I=[];for(const r of xt._ExtensionNames){const Y=this._extensions[r];Y.postExportMaterialAdditionalTextures&&I.push(...Y.postExportMaterialAdditionalTextures(t,U,y))}return I}_extensionsPostExportTextures(t,U,y){for(const I of xt._ExtensionNames){const r=this._extensions[I];r.postExportTexture&&r.postExportTexture(t,U,y)}}_extensionsPostExportMeshPrimitive(t){for(const U of xt._ExtensionNames){const y=this._extensions[U];y.postExportMeshPrimitive&&y.postExportMeshPrimitive(t,this._bufferManager,this._accessors)}}async _extensionsPreGenerateBinaryAsync(){for(const t of xt._ExtensionNames){const U=this._extensions[t];U.preGenerateBinaryAsync&&await U.preGenerateBinaryAsync(this._bufferManager)}}_forEachExtensions(t){for(const U of xt._ExtensionNames){const y=this._extensions[U];y.enabled&&t(y)}}_extensionsOnExporting(){this._forEachExtensions((t=>{var U,y,I;t.wasUsed&&((U=this._glTF).extensionsUsed||(U.extensionsUsed=[]),-1===this._glTF.extensionsUsed.indexOf(t.name)&&this._glTF.extensionsUsed.push(t.name),t.required&&((y=this._glTF).extensionsRequired||(y.extensionsRequired=[]),-1===this._glTF.extensionsRequired.indexOf(t.name)&&this._glTF.extensionsRequired.push(t.name)),(I=this._glTF).extensions||(I.extensions={}),t.onExporting&&t.onExporting())}))}_loadExtensions(){for(const t of xt._ExtensionNames){const U=xt._ExtensionFactories[t](this);this._extensions[t]=U}}constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:E.d.LastCreatedScene,U=arguments.length>1?arguments[1]:void 0;if(this._glTF={asset:{generator:`Babylon.js v${F.c.Version}`,version:"2.0"}},this._animations=[],this._accessors=[],this._bufferViews=[],this._cameras=[],this._images=[],this._materials=[],this._meshes=[],this._nodes=[],this._samplers=[],this._scenes=[],this._skins=[],this._textures=[],this._imageData={},this._shouldUseGlb=!1,this._materialExporter=new V(this),this._extensions={},this._bufferManager=new Mt,this._shouldExportNodeMap=new Map,this._nodeMap=new Map,this._materialMap=new Map,this._camerasMap=new Map,this._nodesCameraMap=new Map,this._skinMap=new Map,this._nodesSkinMap=new Map,this._materialNeedsUVsSet=new Set,!t)throw new Error("No scene available to export");this._babylonScene=t,this._options={shouldExportNode:()=>!0,shouldExportAnimation:()=>!0,metadataSelector:t=>{var U;return null===t||void 0===t||null===(U=t.lX)||void 0===U?void 0:U.extras},animationSampleRate:1/60,exportWithoutWaitingForScene:!1,exportUnusedUVs:!1,removeNoopRootNodes:!0,includeCoordinateSystemConversionNodes:!1,meshCompressionMethod:"None",...U},this._loadExtensions()}dispose(){for(const t in this._extensions){this._extensions[t].dispose()}}get options(){return this._options}static RegisterExtension(t,U){xt.UnregisterExtension(t)&&r.Tools.Warn(`Extension with the name ${t} already exists`),xt._ExtensionFactories[t]=U,xt._ExtensionNames.push(t)}static UnregisterExtension(t){if(!xt._ExtensionFactories[t])return!1;delete xt._ExtensionFactories[t];const U=xt._ExtensionNames.indexOf(t);return-1!==U&&xt._ExtensionNames.splice(U,1),!0}_generateJSON(t,U,y){const I={byteLength:t};return I.byteLength&&(this._glTF.buffers=[I]),this._nodes&&this._nodes.length&&(this._glTF.nodes=this._nodes),this._meshes&&this._meshes.length&&(this._glTF.meshes=this._meshes),this._scenes&&this._scenes.length&&(this._glTF.scenes=this._scenes,this._glTF.gU=0),this._cameras&&this._cameras.length&&(this._glTF.cameras=this._cameras),this._bufferViews&&this._bufferViews.length&&(this._glTF.bufferViews=this._bufferViews),this._accessors&&this._accessors.length&&(this._glTF.accessors=this._accessors),this._animations&&this._animations.length&&(this._glTF.animations=this._animations),this._materials&&this._materials.length&&(this._glTF.materials=this._materials),this._textures&&this._textures.length&&(this._glTF.textures=this._textures),this._samplers&&this._samplers.length&&(this._glTF.samplers=this._samplers),this._skins&&this._skins.length&&(this._glTF.skins=this._skins),this._images&&this._images.length&&(this._glTF.images=this._images),this._shouldUseGlb||(I.uri=U+".bin"),y?JSON.stringify(this._glTF,null,2):JSON.stringify(this._glTF)}async generateGLTFAsync(t){const U=await this._generateBinaryAsync();this._extensionsOnExporting();const y=this._generateJSON(U.byteLength,t,!0),I=new Blob([U],{type:"application/octet-stream"}),r=t+".gltf",Y=t+".bin",mt=new G;if(mt.files[r]=y,mt.files[Y]=I,this._imageData)for(const X in this._imageData)mt.files[X]=new Blob([this._imageData[X].data],{type:this._imageData[X].mimeType});return mt}async _generateBinaryAsync(){return await this._exportSceneAsync(),await this._extensionsPreGenerateBinaryAsync(),this._bufferManager.generateBinary(this._bufferViews)}_getPadding(t){const U=t%4;return 0===U?U:4-U}async generateGLBAsync(t){this._shouldUseGlb=!0;const U=await this._generateBinaryAsync();this._extensionsOnExporting();const y=this._generateJSON(U.byteLength),I=t+".glb";let r,Y=y.length;if("undefined"!==typeof TextEncoder){r=(new TextEncoder).encode(y),Y=r.length}const mt=this._getPadding(Y),X=this._getPadding(U.byteLength),P=28+Y+mt+U.byteLength+X,M=new Pt(P);if(M.writeUInt32(1179937895),M.writeUInt32(2),M.writeUInt32(P),M.writeUInt32(Y+mt),M.writeUInt32(1313821514),r)M.writeTypedArray(r);else{const t="_".charCodeAt(0);for(let U=0;U<Y;++U){const I=y.charCodeAt(U);I!=y.codePointAt(U)?M.writeUInt8(t):M.writeUInt8(I)}}for(let G=0;G<mt;++G)M.writeUInt8(32);M.writeUInt32(U.byteLength+X),M.writeUInt32(5130562),M.writeTypedArray(U);for(let G=0;G<X;++G)M.writeUInt8(0);const L=new G;return L.files[I]=new Blob([M.getOutputData()],{type:"application/octet-stream"}),L}_setNodeTransformation(t,U,y){if(U.getPivotPoint().equalsWithEpsilon(k,O.b)||r.Tools.Warn("Pivot points are not supported in the glTF serializer"),!U.position.equalsWithEpsilon(k,O.b)){const r=I.TmpVectors.DU[0].Y(U.position);y&&u(r),t.translation=r.bX()}U.dX.equalsWithEpsilon(x,O.b)||(t.scale=U.dX.bX());const Y=U.rotationQuaternion||I.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);Y.equalsWithEpsilon(s,O.b)||(y&&T(Y),t.rotation=Y.normalize().bX())}_setCameraTransformation(t,U,y){if(!U.position.equalsWithEpsilon(k,O.b)){const r=I.TmpVectors.DU[0].Y(U.position);y&&u(r),t.translation=r.bX()}const r=U.rotationQuaternion||I.Quaternion.FromEulerAngles(U.rotation.x,U.rotation.y,U.rotation.z);y&&T(r),this._babylonScene.useRightHandedSystem||z(r),r.equalsWithEpsilon(s,O.b)||(t.rotation=r.bX())}_listAvailableCameras(){for(const t of this._babylonScene.cameras){const U={type:t.mode===ht.e.PERSPECTIVE_CAMERA?"perspective":"orthographic"};if(t.name&&(U.name=t.name),"perspective"===U.type)U.perspective={aspectRatio:t.getEngine().getAspectRatio(t),yfov:t.fovMode===ht.e.FOVMODE_VERTICAL_FIXED?t.fov:t.fov*t.getEngine().getAspectRatio(t),znear:t.cX,zfar:t.maxZ};else if("orthographic"===U.type){const y=t.orthoLeft&&t.orthoRight?.5*(t.orthoRight-t.orthoLeft):.5*t.getEngine().getRenderWidth(),I=t.orthoBottom&&t.orthoTop?.5*(t.orthoTop-t.orthoBottom):.5*t.getEngine().getRenderHeight();U.orthographic={xmag:y,ymag:I,znear:t.cX,zfar:t.maxZ}}this._camerasMap.set(t,U)}}_exportAndAssignCameras(){const t=Array.from(this._camerasMap.values());for(const U of t){const t=this._nodesCameraMap.get(U);if(void 0!==t){this._cameras.push(U);for(const U of t)U.camera=this._cameras.length-1}}}_listAvailableSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const U={joints:[]};this._skinMap.set(t,U)}}_exportAndAssignSkeletons(){for(const t of this._babylonScene.skeletons){if(t.bones.length<=0)continue;const U=this._skinMap.get(t);if(void 0==U)continue;const y={},I=[];let Y=-1;for(let r=0;r<t.bones.length;++r){const U=t.bones[r],I=U.getIndex()??r;-1!==I&&(y[I]=U,I>Y&&(Y=I))}for(let t=0;t<=Y;++t){const Y=y[t];I.push(Y.getAbsoluteInverseBindMatrix());const mt=Y.getTransformNode();if(null!==mt){const t=this._nodeMap.get(mt);mt&&null!==t&&void 0!==t?U.joints.push(t):r.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}else r.Tools.Warn("Exporting a bone without a linked transform node is currently unsupported")}const mt=this._nodesSkinMap.get(U);if(U.joints.length>0&&void 0!==mt){const t=64*I.length,y=new Float32Array(t/4);I.forEach(((t,U)=>{y.set(t.m,16*U)}));const r=this._bufferManager.createBufferView(y);this._accessors.push(this._bufferManager.createAccessor(r,"MAT4",5126,I.length)),U.inverseBindMatrices=this._accessors.length-1,this._skins.push(U);for(const U of mt)U.skin=this._skins.length-1}}}async _exportSceneAsync(){const t={nodes:[]};if(this._babylonScene.metadata){const U=this._options.metadataSelector(this._babylonScene.metadata);U&&(t.extras=U)}const U=new Array,y=new Array,I=new Array;for(const X of this._babylonScene.rootNodes)this._options.removeNoopRootNodes&&!this._options.includeCoordinateSystemConversionNodes&&mU(X,this._babylonScene.useRightHandedSystem)?I.push(...X.getChildren()):this._babylonScene.useRightHandedSystem?U.push(X):y.push(X);this._listAvailableCameras(),this._listAvailableSkeletons();const r=new st(!0,!1);t.nodes.push(...await this._exportNodesAsync(y,r));const Y=new st(!1,!1);t.nodes.push(...await this._exportNodesAsync(U,Y));const mt=new st(!1,!0);t.nodes.push(...await this._exportNodesAsync(I,mt)),t.nodes.length&&this._scenes.push(t),this._exportAndAssignCameras(),this._exportAndAssignSkeletons(),this._babylonScene.animationGroups.length&&Bt._CreateNodeAndMorphAnimationFromAnimationGroups(this._babylonScene,this._animations,this._nodeMap,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,r.getNodesSet(),this._options.shouldExportAnimation)}_shouldExportNode(t){let U=this._shouldExportNodeMap.get(t);return void 0===U&&(U=this._options.shouldExportNode(t),this._shouldExportNodeMap.set(t,U)),U}async _exportNodesAsync(t,U){const y=new Array;this._exportBuffers(t,U);for(const I of t)await this._exportNodeAsync(I,y,U);return y}_collectBuffers(t,U,y,I,r){if(this._shouldExportNode(t)&&t instanceof h.c&&t.NX){const Y=t.NX.getVertexBuffers();if(Y)for(const I in Y){if(!K(I))continue;const mt=Y[I];r.setHasVertexColorAlpha(mt,t.hasVertexAlpha);const X=mt._buffer,P=U.get(X)||[];U.set(X,P),-1===P.indexOf(mt)&&P.push(mt);const G=y.get(mt)||[];y.set(mt,G),-1===G.indexOf(t)&&G.push(t)}const mt=t.morphTargetManager;if(mt)for(let U=0;U<mt.numTargets;U++){const y=mt.getTarget(U),r=I.get(y)||[];I.set(y,r),-1===r.indexOf(t)&&r.push(t)}}for(const Y of t.getChildren())this._collectBuffers(Y,U,y,I,r)}_exportBuffers(t,U){const y=new Map,I=new Map,r=new Map;for(const X of t)this._collectBuffers(X,y,I,r,U);const Y=Array.from(y.keys());for(const X of Y){const t=X.getData();if(!t)throw new Error("Buffer data is not available");const r=y.get(X);if(!r)continue;const Y=r[0].byteStride;if(r.some((t=>t.byteStride!==Y)))throw new Error("Vertex buffers pointing to the same buffer must have the same byte stride");const mt=yt(t).slice();for(const U of r){const t=I.get(U),{byteOffset:y,byteStride:r,componentCount:Y,type:X,count:P,normalized:G,kind:L}=W(U,t);switch(L){case M.e.NormalKind:case M.e.TangentKind:(0,n.h)(mt,y,r,Y,X,P,G,(t=>{const U=Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2]);if(U>0){const y=1/U;t[0]*=y,t[1]*=y,t[2]*=y}}));break;case M.e.ColorKind:{const U=t.filter((t=>t.material instanceof Et.BU||null==t.material)).length;if(0==U)break;if(U!=t.length){i.b.Warn("Not converting vertex color space, as buffer is shared by StandardMaterials and other material types. Results may look incorrect.");break}X==M.e.UNSIGNED_BYTE&&i.b.Warn("Converting uint8 vertex colors to linear space. Results may look incorrect.");const I=new w.bU,L=new w.HX,h=this._babylonScene.getEngine().useExactSrgbConversions;(0,n.h)(mt,y,r,Y,X,P,G,(t=>{3===t.length?(I.Dy(t,0),I.toLinearSpaceToRef(I,h),I.toArray(t,0)):(L.Dy(t,0),L.toLinearSpaceToRef(L,h),L.toArray(t,0))}))}}}if(U.convertToRightHanded){for(const t of r){const U=I.get(t),{byteOffset:y,byteStride:r,componentCount:Y,type:X,count:P,normalized:G,kind:L}=W(t,U);switch(L){case M.e.PositionKind:case M.e.NormalKind:case M.e.TangentKind:(0,n.h)(mt,y,r,Y,X,P,G,(t=>{t[0]=-t[0]}))}}U.convertedToRightHandedBuffers.set(X,mt)}const P=this._bufferManager.createBufferView(mt,Y);U.setVertexBufferView(X,P);const G=new Map;for(const U of r){const t=I.get(U),{kind:y,totalVertices:r}=W(U,t);switch(y){case M.e.MatricesIndicesKind:case M.e.MatricesIndicesExtraKind:if(U.type==M.e.FLOAT){const t=U.getFloatData(r);null!==t&&G.set(U,t)}}}0!==G.size&&i.b.Warn("Joints conversion needed: some joints are stored as floats in Babylon but GLTF requires UNSIGNED BYTES. We will perform the conversion but this might lead to unused data in the buffer.");const L=Array.from(G.keys());for(const y of L){const t=G.get(y);if(!t)continue;const I=t.some((t=>t>=256)),r=new(I?Uint16Array:Uint8Array)(t.length);for(let U=0;U<t.length;U++)r[U]=t[U];const Y=this._bufferManager.createBufferView(r,4*(I?2:1));U.setRemappedBufferView(X,y,Y)}}const mt=Array.from(r.keys());for(const X of mt){const t=r.get(X);if(!t)continue;const y=bt(X,t[0],this._bufferManager,this._bufferViews,this._accessors,U.convertToRightHanded);for(const I of t)U.bindMorphDataToMesh(I,y)}}async _exportNodeAsync(t,U,y){let I=this._nodeMap.get(t);if(void 0!==I)return void(U.includes(I)||U.push(I));const r=await this._createNodeAsync(t,y);if(r){I=this._nodes.length,this._nodes.push(r),this._nodeMap.set(t,I),y.pushExportedNode(t),U.push(I);const Y={name:"runtime animations",channels:[],samplers:[]},mt=[];this._babylonScene.animationGroups.length||(Bt._CreateMorphTargetAnimationFromMorphTargetAnimations(t,Y,mt,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,y.convertToRightHanded,this._options.shouldExportAnimation),t.animations.length&&Bt._CreateNodeAnimationFromNodeAnimations(t,Y,mt,this._nodeMap,this._nodes,this._bufferManager,this._bufferViews,this._accessors,this._animationSampleRate,y.convertToRightHanded,this._options.shouldExportAnimation)),Y.channels.length&&Y.samplers.length&&this._animations.push(Y),mt.forEach((t=>{t.channels.length&&t.samplers.length&&this._animations.push(t)}))}const Y=r?[]:U;for(const mt of t.getChildren())await this._exportNodeAsync(mt,Y,y);r&&Y.length&&(r.children=Y)}async _createNodeAsync(t,U){if(!this._shouldExportNode(t))return null;const y={};if(t.name&&(y.name=t.name),t.metadata){const U=this._options.metadataSelector(t.metadata);U&&(y.extras=U)}if(t instanceof L.d&&(this._setNodeTransformation(y,t,U.convertToRightHanded),t instanceof h.c)){const r=t instanceof Q.c?t.sourceMesh:t;if(r.BX&&r.BX.length>0&&(y.mesh=await this._exportMeshAsync(r,U)),t.skeleton){const U=this._skinMap.get(t.skeleton);var I;if(void 0!==U)void 0===this._nodesSkinMap.get(U)&&this._nodesSkinMap.set(U,[]),null===(I=this._nodesSkinMap.get(U))||void 0===I||I.push(y)}}if(t instanceof v.c){const I=this._camerasMap.get(t);if(I){var r;void 0===this._nodesCameraMap.get(I)&&this._nodesCameraMap.set(I,[]),this._setCameraTransformation(y,t,U.convertToRightHanded);const mt=t.parent;if(null!==mt&&Ut(t,mt)){const t=this._nodeMap.get(mt);if(void 0!==t){var Y;const U=this._nodes[t];return tt(y,U),null===(Y=this._nodesCameraMap.get(I))||void 0===Y||Y.push(U),null}}null===(r=this._nodesCameraMap.get(I))||void 0===r||r.push(y)}}return await this._extensionsPostExportNodeAsync("exportNodeAsync",y,t,this._nodeMap,U.convertToRightHanded)?y:(i.b.Warn(`Not exporting node ${t.name}`),null)}_exportIndices(t,U,y,I,r,mt,X,P,G){let M=t;G.mode=C(mt);const L=X!==Y.e.CounterClockWiseSideOrientation,h=!P.wasAddedByNoopNode&&L,Q=function(t){switch(t){case Y.e.TriangleFillMode:case Y.e.TriangleStripDrawMode:case Y.e.TriangleFanDrawMode:return!0}return!1}(mt)&&h;if(Q){if(mt===Y.e.TriangleStripDrawMode||mt===Y.e.TriangleFanDrawMode)throw new Error("Triangle strip/fan fill mode is not implemented");G.mode=C(mt);const X=U?new Uint32Array(I):new Uint16Array(I);if(t)for(let U=0;U+2<I;U+=3)X[U]=t[y+U]+r,X[U+1]=t[y+U+2]+r,X[U+2]=t[y+U+1]+r;else for(let t=0;t+2<I;t+=3)X[t]=t,X[t+1]=t+2,X[t+2]=t+1;M=X}else if(t&&0!==r){const Y=U?new Uint32Array(I):new Uint16Array(I);for(let U=0;U<I;U++)Y[U]=t[y+U]+r;M=Y}if(M){let Y=P.getIndicesAccessor(t,y,I,r,Q);if(void 0===Y){const mt=function(t,U,y,I){if(t instanceof Uint16Array||t instanceof Uint32Array)return t;if(t instanceof Int32Array)return new Uint32Array(t.buffer,t.byteOffset,t.length);const r=t.slice(U,U+y);return I?new Uint32Array(r):new Uint16Array(r)}(M,0,I,U),X=this._bufferManager.createBufferView(mt),G=U?5125:5123;this._accessors.push(this._bufferManager.createAccessor(X,"SCALAR",G,I,0)),Y=this._accessors.length-1,P.setIndicesAccessor(t,y,I,r,Q,Y)}G.indices=Y}}_exportVertexBuffer(t,U,y,I,r,Y){const mt=t.getKind();if(!K(mt))return;if(mt.startsWith("uv")&&!this._options.exportUnusedUVs&&(!U||!this._materialNeedsUVsSet.has(U)))return;let X=r.getVertexAccessor(t,y,I);if(void 0===X){const U=r.convertedToRightHandedBuffers.get(t._buffer)||t._buffer.getData(),Y=mt===M.e.PositionKind?function(t,U,y,I){const{byteOffset:r,byteStride:Y,type:mt,normalized:X}=U,P=U.getSize(),G=new Array(P).fill(1/0),M=new Array(P).fill(-1/0);return(0,n.h)(t,r+y*Y,Y,P,mt,I*P,X,(t=>{for(let U=0;U<P;U++)G[U]=Math.min(G[U],t[U]),M[U]=Math.max(M[U],t[U])})),{min:G,max:M}}(U,t,y,I):void 0,P=(mt===M.e.MatricesIndicesKind||mt===M.e.MatricesIndicesExtraKind)&&t.type===M.e.FLOAT,G=P?M.e.UNSIGNED_BYTE:t.type,L=P?void 0:t.normalized,h=P?r.getRemappedBufferView(t._buffer,t):r.getVertexBufferView(t._buffer),Q=t.byteOffset+y*t.byteStride;this._accessors.push(this._bufferManager.createAccessor(h,function(t,U){if(t==M.e.ColorKind)return U?"VEC4":"VEC3";switch(t){case M.e.PositionKind:case M.e.NormalKind:return"VEC3";case M.e.TangentKind:case M.e.MatricesIndicesKind:case M.e.MatricesIndicesExtraKind:case M.e.MatricesWeightsKind:case M.e.MatricesWeightsExtraKind:return"VEC4";case M.e.UVKind:case M.e.UV2Kind:case M.e.UV3Kind:case M.e.UV4Kind:case M.e.UV5Kind:case M.e.UV6Kind:return"VEC2"}throw new Error(`Unknown kind ${t}`)}(mt,r.hasVertexColorAlpha(t)),G,I,Q,Y,L)),X=this._accessors.length-1,r.setVertexAccessor(t,y,I,X)}Y.attributes[function(t){switch(t){case M.e.PositionKind:return"POSITION";case M.e.NormalKind:return"NORMAL";case M.e.TangentKind:return"TANGENT";case M.e.ColorKind:return"COLOR_0";case M.e.UVKind:return"TEXCOORD_0";case M.e.UV2Kind:return"TEXCOORD_1";case M.e.UV3Kind:return"TEXCOORD_2";case M.e.UV4Kind:return"TEXCOORD_3";case M.e.UV5Kind:return"TEXCOORD_4";case M.e.UV6Kind:return"TEXCOORD_5";case M.e.MatricesIndicesKind:return"JOINTS_0";case M.e.MatricesIndicesExtraKind:return"JOINTS_1";case M.e.MatricesWeightsKind:return"WEIGHTS_0";case M.e.MatricesWeightsExtraKind:return"WEIGHTS_1"}throw new Error(`Unknown kind: ${t}`)}(mt)]=X}async _exportMaterialAsync(t,U,y,I){let r=this._materialMap.get(t);if(void 0===r){const I=U&&Object.keys(U).some((t=>t.startsWith("uv")));if((t=t instanceof Qt.c?t.eX[y.materialIndex]:t)instanceof Ft.d)r=await this._materialExporter.exportPBRMaterialAsync(t,"image/png",I);else{if(!(t instanceof Et.BU))return void i.b.Warn(`Unsupported material '${t.name}' with type ${t.getClassName()}`);r=await this._materialExporter.exportStandardMaterialAsync(t,"image/png",I)}this._materialMap.set(t,r)}I.material=r}async _exportMeshAsync(t,U){var y;let I=U.getMesh(t);if(void 0!==I)return I;const r={primitives:[]};I=this._meshes.length,this._meshes.push(r),U.setMesh(t,I);const mt=t.isUnIndexed?null:t.jX(),X=null===(y=t.NX)||void 0===y?void 0:y.getVertexBuffers(),P=U.getMorphTargetsFromMesh(t),G=t instanceof pt.d,M=t instanceof kt,L=t.BX;if(X&&L&&L.length>0)for(const F of L){const y={attributes:{}},I=F.vt()||this._babylonScene.defaultMaterial;if(M){var h,Q;const U={name:I.name},r=t,Y=w.bU.White(),mt=(null===(h=r.material)||void 0===h?void 0:h.alpha)??1,X=(null===(Q=r.greasedLineMaterial)||void 0===Q?void 0:Q.color)??Y;(!X.equalsWithEpsilon(Y,O.b)||mt<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...X.bX(),mt]}),this._materials.push(U),y.material=this._materials.length-1}else if(G){const U={name:I.name},r=t;(!r.color.equalsWithEpsilon(w.bU.White(),O.b)||r.alpha<1)&&(U.pbrMetallicRoughness={baseColorFactor:[...r.color.bX(),r.alpha]}),this._materials.push(U),y.material=this._materials.length-1}else await this._exportMaterialAsync(I,X,F,y);const L=G||M?Y.e.LineListDrawMode:t.overrideRenderingFillMode??I.fillMode,E=I._getEffectiveOrientation(t);this._exportIndices(mt,mt?(0,n.b)(mt,F.indexCount,F.indexStart,F.verticesStart):F.verticesCount>65535,mt?F.indexStart:F.verticesStart,mt?F.indexCount:F.verticesCount,-F.verticesStart,L,E,U,y);for(const t of Object.values(X))this._exportVertexBuffer(t,I,F.verticesStart,F.verticesCount,U,y);if(P){y.targets=[];for(const t of P)y.targets.push(t.attributes)}r.primitives.push(y),this._extensionsPostExportMeshPrimitive(y)}if(P){r.weights=[],r.extras||(r.extras={}),r.extras.targetNames=[];for(const t of P)r.weights.push(t.influence),r.extras.targetNames.push(t.name)}return I}}xt._ExtensionNames=new Array,xt._ExtensionFactories={};class Zt{static async GLTFAsync(t,U,y){y&&y.exportWithoutWaitingForScene||await t.whenReadyAsync();const I=new xt(t,y),r=await I.generateGLTFAsync(U.replace(/\.[^/.]+$/,""));return I.dispose(),r}static async GLBAsync(t,U,y){y&&y.exportWithoutWaitingForScene||await t.whenReadyAsync();const I=new xt(t,y),r=await I.generateGLBAsync(U.replace(/\.[^/.]+$/,""));return I.dispose(),r}}y(12995);const Wt="EXT_mesh_gpu_instancing";class At{constructor(t){this.name=Wt,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}async postExportNodeAsync(t,U,y,r,Y,mt){return await new Promise((t=>{if(U&&y instanceof lt.c&&y.hasThinInstances&&this._exporter){this._wasUsed=!0;const t=I.DU.Zero(),r=I.Quaternion.Identity(),X=I.DU.One(),P=y.thinInstanceGetWorldMatrices(),G=I.TmpVectors.DU[2],M=I.TmpVectors.Quaternion[1],L=I.TmpVectors.DU[3];let h=!1,Q=!1,F=!1;const E=new Float32Array(3*y.oX),w=new Float32Array(4*y.oX),D=new Float32Array(3*y.oX);let l=0;for(const U of P)U.decompose(L,M,G),Y&&(u(G),T(M)),E.set(G.bX(),3*l),w.set(M.normalize().bX(),4*l),D.set(L.bX(),3*l),h=h||!G.equalsWithEpsilon(t),Q=Q||!M.equalsWithEpsilon(r),F=F||!L.equalsWithEpsilon(X),l++;const g={attributes:{}};h&&(g.attributes.TRANSLATION=this._buildAccessor(E,"VEC3",y.oX,mt)),Q&&(g.attributes.ROTATION=this._buildAccessor(w,"VEC4",y.oX,mt)),F&&(g.attributes.SCALE=this._buildAccessor(D,"VEC3",y.oX,mt)),U.extensions=U.extensions||{},U.extensions[Wt]=g}t(U)}))}_buildAccessor(t,U,y,I){const r=I.createBufferView(t),Y=I.createAccessor(r,U,5126,y);return this._exporter._accessors.push(Y),this._exporter._accessors.length-1}}xt.RegisterExtension(Wt,(t=>new At(t)));var Kt=y(12998),Ct=y(13008),Rt=y(13015),ut=y(13020);function Tt(t){return t===Rt.e.PositionKind?"POSITION":t===Rt.e.NormalKind?"NORMAL":t===Rt.e.ColorKind?"COLOR":t.startsWith(Rt.e.UVKind)?"TEX_COORD":"GENERIC"}const zt={decodeSpeed:5,encodeSpeed:5,method:"MESH_EDGEBREAKER_ENCODING",quantizationBits:{POSITION:14,NORMAL:10,COLOR:8,TEX_COORD:12,GENERIC:12}};class tU extends Kt.e{static get DefaultAvailable(){return(0,Kt.i)(tU.DefaultConfiguration)}static get Default(){return tU._Default??(tU._Default=new tU),tU._Default}static ResetDefault(t){tU._Default&&(t||tU._Default.dispose(),tU._Default=null)}_isModuleAvailable(){return"undefined"!==typeof DracoEncoderModule}async _createModuleAsync(t,U){return{module:await(U||DracoEncoderModule)({wasmBinary:t})}}_getWorkerContent(){return`${Ct.h}(${Ct.l})()`}constructor(){super(arguments.length>0&&void 0!==arguments[0]?arguments[0]:tU.DefaultConfiguration)}async _encodeAsync(t,U,y){const I=y?(0,ut.d)(zt,y):zt;if(this._workerPoolPromise){const y=await this._workerPoolPromise;return await new Promise(((r,Y)=>{y.push(((y,mt)=>{const X=t=>{y.removeEventListener("error",X),y.removeEventListener("message",P),Y(t),mt()},P=t=>{"encodeMeshDone"===t.data.id&&(y.removeEventListener("error",X),y.removeEventListener("message",P),r(t.data.encodedMeshData),mt())};y.addEventListener("error",X),y.addEventListener("message",P);const G=[];for(const U of t)G.push(U.data.buffer);U&&G.push(U.buffer),y.postMessage({id:"encodeMesh",attributes:t,indices:U,options:I},G)}))}))}if(this._modulePromise){const y=await this._modulePromise;return(0,Ct.h)(y.module,t,U,I)}throw new Error("Draco encoder module is not available")}async encodeMeshAsync(t,U){if(0==t.getTotalVertices())throw new Error("Cannot compress geometry with Draco. There are no vertices.");t instanceof lt.c&&t.morphTargetManager&&"MESH_EDGEBREAKER_ENCODING"===(null===U||void 0===U?void 0:U.method)&&(i.b.Warn("Cannot use Draco EDGEBREAKER method with morph targets. Falling back to SEQUENTIAL method."),U.method="MESH_SEQUENTIAL_ENCODING");const y=function(t){let U=t.jX(void 0,!0);return!U||U instanceof Uint32Array||U instanceof Uint16Array||(U=((0,n.b)(U,U.length)?Uint32Array:Uint16Array).from(U)),U}(t),I=function(t,U){const y=[];for(const I of t.getVerticesDataKinds()){if(null!==U&&void 0!==U&&U.includes(I)){if(I===Rt.e.PositionKind)throw new Error("Cannot exclude position attribute from Draco encoding.");continue}const r=t.getVertexBuffer(I),Y=r.getSize(),mt=(0,n.u)(r.getData(),Y,r.type,r.byteOffset,r.byteStride,r.normalized,t.getTotalVertices(),!0);y.push({kind:I,dracoName:Tt(I),size:Y,data:mt})}return y}(t,null===U||void 0===U?void 0:U.excludedAttributes);return await this._encodeAsync(I,y,U)}}tU.DefaultConfiguration={wasmUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder_wasm_wrapper.js`,wasmBinaryUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder.wasm`,fallbackUrl:`${r.Tools._DefaultCdnUrl}/draco_encoder.js`},tU._Default=null;const UU="KHR_draco_mesh_compression";class yU{get wasUsed(){return this._wasUsed}constructor(t){this.name=UU,this.required=!0,this._bufferViewsUsed=new Set,this._accessorsUsed=new Set,this._encodePromises=[],this._wasUsed=!1,this.enabled="Draco"===t.options.meshCompressionMethod&&tU.DefaultAvailable}dispose(){}postExportMeshPrimitive(t,U,y){if(!this.enabled)return;if(4!==t.mode&&5!==t.mode)return void i.b.Warn("Cannot compress primitive with mode "+t.mode+".");const I=[],r=[];let Y=null;if(void 0!==t.indices){const mt=y[t.indices],X=U.getBufferView(mt);Y=U.getData(X).slice(),I.push(X),r.push(mt)}const mt=[];for(const[M,L]of Object.entries(t.attributes)){const t=y[L],Y=U.getBufferView(t),P=A(t.type),G=(0,n.u)(U.getData(Y),P,t.componentType,t.byteOffset||0,Y.byteStride||(0,n.o)(t.componentType)*P,t.normalized||!1,t.count,!0);mt.push({kind:M,dracoName:(X=M,"POSITION"===X?"POSITION":"NORMAL"===X?"NORMAL":X.startsWith("COLOR")?"COLOR":X.startsWith("TEXCOORD")?"TEX_COORD":"GENERIC"),size:A(t.type),data:G}),I.push(Y),r.push(t)}var X;const P={method:t.targets?"MESH_SEQUENTIAL_ENCODING":"MESH_EDGEBREAKER_ENCODING"},G=tU.Default._encodeAsync(mt,Y,P).then((y=>{if(!y)return void i.b.Error("Draco encoding failed for primitive.");const Y={bufferView:-1,attributes:y.attributeIds},mt=U.createBufferView(y.data);U.setBufferView(Y,mt);for(const t of I)this._bufferViewsUsed.add(t);for(const t of r)this._accessorsUsed.add(t);t.extensions||(t.extensions={}),t.extensions[UU]=Y})).catch((t=>{i.b.Error("Draco encoding failed for primitive: "+t)}));this._encodePromises.push(G),this._wasUsed=!0}async preGenerateBinaryAsync(t){this.enabled&&(await Promise.all(this._encodePromises),this._bufferViewsUsed.forEach((U=>{t.getPropertiesWithBufferView(U).every((t=>this._accessorsUsed.has(t)))&&t.removeBufferView(U)})),this._bufferViewsUsed.clear(),this._accessorsUsed.clear())}}xt.RegisterExtension(UU,(t=>new yU(t)));var IU=y(13026);const rU="KHR_lights_punctual",YU={name:"",color:[1,1,1],VX:1,range:Number.MAX_VALUE},my={innerConeAngle:0,outerConeAngle:Math.PI/4},XU=I.DU.Backward();class PU{constructor(t){this.name=rU,this.enabled=!0,this.required=!1,this._exporter=t}dispose(){this._lights=null}get wasUsed(){return!!this._lights}onExporting(){this._exporter._glTF.extensions[rU]=this._lights}async postExportNodeAsync(t,U,y,r,Y){return await new Promise((mt=>{if(!(y instanceof gt.c))return void mt(U);const X=y.getTypeID()==gt.c.LIGHTTYPEID_POINTLIGHT?"point":y.getTypeID()==gt.c.LIGHTTYPEID_DIRECTIONALLIGHT?"directional":y.getTypeID()==gt.c.LIGHTTYPEID_SPOTLIGHT?"spot":null;if(!X||!(y instanceof IU.e))return i.b.Warn(`${t}: Light ${y.name} is not supported in ${rU}`),void mt(U);if(y.falloffType!==gt.c.FALLOFF_GLTF&&i.b.Warn(`${t}: Light falloff for ${y.name} does not match the ${rU} specification!`),!y.position.equalsToFloats(0,0,0)){const t=I.TmpVectors.DU[0].Y(y.position);Y&&u(t),U.translation=t.bX()}if("point"!==X){const t=y.direction.normalizeToRef(I.TmpVectors.DU[0]);Y&&u(t);const r=I.Quaternion.FromUnitVectorsToRef(XU,t,I.TmpVectors.Quaternion[0]);I.Quaternion.IsIdentity(r)||(U.rotation=r.bX())}const P={type:X,name:y.name,color:y.nX.bX(),VX:y.VX,range:y.range};if(It(P,YU),"spot"===X){const t=y;P.spot={innerConeAngle:t.innerAngle/2,outerConeAngle:t.angle/2},It(P.spot,my)}this._lights||(this._lights={lights:[]}),this._lights.lights.push(P);const G={br:this._lights.lights.length-1},M=y.parent;if(M&&Ut(y,M)){const t=r.get(M);if(t){const y=this._exporter._nodes[t];return tt(U,y),y.extensions||(y.extensions={}),y.extensions[rU]=G,void mt(null)}}U.extensions||(U.extensions={}),U.extensions[rU]=G,mt(U)}))}}xt.RegisterExtension(rU,(t=>new PU(t)));var GU=y(12933);const MU="KHR_materials_anisotropy";class LU{constructor(t){this.name=MU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof GU.c&&y.anisotropy.isEnabled&&!y.anisotropy.legacy?(y.anisotropy.texture&&I.push(y.anisotropy.texture),I):[]}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof GU.c){if(!y.anisotropy.isEnabled||y.anisotropy.legacy)return void t(U);this._wasUsed=!0,U.extensions=U.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(y.anisotropy.texture),r={anisotropyStrength:y.anisotropy.VX,anisotropyRotation:y.anisotropy.angle,anisotropyTexture:I??void 0};null!==r.anisotropyTexture&&this._exporter._materialNeedsUVsSet.add(y),U.extensions[MU]=r}t(U)}))}}xt.RegisterExtension(MU,(t=>new LU(t)));const hU="KHR_materials_clearcoat";class QU{constructor(t){this.name=hU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof GU.c&&y.clearCoat.isEnabled?(y.clearCoat.texture&&I.push(y.clearCoat.texture),!y.clearCoat.useRoughnessFromMainTexture&&y.clearCoat.textureRoughness&&I.push(y.clearCoat.textureRoughness),y.clearCoat.bumpTexture&&I.push(y.clearCoat.bumpTexture),I):[]}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof GU.c){if(!y.clearCoat.isEnabled)return void t(U);this._wasUsed=!0,U.extensions=U.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(y.clearCoat.texture);let Y;Y=y.clearCoat.useRoughnessFromMainTexture?this._exporter._materialExporter.getTextureInfo(y.clearCoat.texture):this._exporter._materialExporter.getTextureInfo(y.clearCoat.textureRoughness),y.clearCoat.isTintEnabled&&r.Tools.Warn(`Clear Color tint is not supported for glTF export. Ignoring for: ${y.name}`),y.clearCoat.remapF0OnInterfaceChange&&r.Tools.Warn(`Clear Color F0 remapping is not supported for glTF export. Ignoring for: ${y.name}`);const mt=this._exporter._materialExporter.getTextureInfo(y.clearCoat.bumpTexture),X={clearcoatFactor:y.clearCoat.VX,clearcoatTexture:I??void 0,clearcoatRoughnessFactor:y.clearCoat.roughness,clearcoatRoughnessTexture:Y??void 0,clearcoatNormalTexture:mt??void 0};null===X.clearcoatTexture&&null===X.clearcoatRoughnessTexture&&null===X.clearcoatRoughnessTexture||this._exporter._materialNeedsUVsSet.add(y),U.extensions[hU]=X}t(U)}))}}xt.RegisterExtension(hU,(t=>new QU(t)));const FU="KHR_materials_diffuse_transmission";function EU(t,U){const y=U.subSurface;let I=null;return y.translucencyIntensityTexture?I=y.translucencyIntensityTexture:y.thicknessTexture&&y.useMaskFromThicknessTexture&&(I=y.thicknessTexture),I&&!y.useGltfStyleTextures?(i.b.Warn(`${t}: Translucency intensity texture is not supported when useGltfStyleTextures = false. Ignoring for: ${U.name}`,1),null):I}class wU{constructor(t){this.name=FU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];if(y instanceof Ft.d&&this._isExtensionEnabled(y)){const U=EU(t,y);return U&&I.push(U),y.subSurface.translucencyColorTexture&&I.push(y.subSurface.translucencyColorTexture),I}return I}_isExtensionEnabled(t){if(t.unlit)return!1;const U=t.subSurface;return!!U.isTranslucencyEnabled&&(!t.unlit&&!U.useAlbedoToTintTranslucency&&U.useGltfStyleTextures&&1===U.volumeIndexOfRefraction&&0===U.minimumThickness&&0===U.maximumThickness)}postExportMaterialAsync(t,U,y){return new Promise((I=>{if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0;const I=y.subSurface,r=EU(t,y),Y=0==I.translucencyIntensity?void 0:I.translucencyIntensity,mt=this._exporter._materialExporter.getTextureInfo(r)??void 0,X=!I.translucencyColor||I.translucencyColor.equalsFloats(1,1,1)?void 0:I.translucencyColor.bX(),P=this._exporter._materialExporter.getTextureInfo(I.translucencyColorTexture)??void 0,G={diffuseTransmissionFactor:Y,diffuseTransmissionTexture:mt,diffuseTransmissionColorFactor:X,diffuseTransmissionColorTexture:P};(mt||P)&&this._exporter._materialNeedsUVsSet.add(y),U.extensions=U.extensions||{},U.extensions[FU]=G}I(U)}))}}xt.RegisterExtension(FU,(t=>new wU(t)));const DU="KHR_materials_dispersion";class lU{constructor(){this.name=DU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){if(t.unlit)return!1;const U=t.subSurface;return!(!U.isRefractionEnabled&&!U.isDispersionEnabled)}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0;const t={dispersion:y.subSurface.dispersion};U.extensions=U.extensions||{},U.extensions[DU]=t}t(U)}))}}xt.RegisterExtension(DU,(()=>new lU));const gU="KHR_materials_emissive_strength";class BU{constructor(){this.name=gU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}async postExportMaterialAsync(t,U,y){return await new Promise((t=>{if(!(y instanceof Ft.d))return t(U);const I=y.emissiveColor.bX(),r=Math.max(...I);if(r>1){this._wasUsed=!0,U.extensions||(U.extensions={});const t={emissiveStrength:r},I=y.emissiveColor.scale(1/t.emissiveStrength);U.emissiveFactor=I.bX(),U.extensions[gU]=t}return t(U)}))}}xt.RegisterExtension(gU,(t=>new BU));const bU="KHR_materials_ior";class pU{constructor(){this.name=bU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.indexOfRefraction&&1.5!=t.indexOfRefraction)}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0;const t={ior:y.indexOfRefraction};U.extensions=U.extensions||{},U.extensions[bU]=t}t(U)}))}}xt.RegisterExtension(bU,(t=>new pU));const cU="KHR_materials_iridescence";class fU{constructor(t){this.name=cU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof GU.c&&y.iridescence.isEnabled?(y.iridescence.texture&&I.push(y.iridescence.texture),y.iridescence.thicknessTexture&&y.iridescence.thicknessTexture!==y.iridescence.texture&&I.push(y.iridescence.thicknessTexture),I):[]}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof GU.c){if(!y.iridescence.isEnabled)return void t(U);this._wasUsed=!0,U.extensions=U.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(y.iridescence.texture),r=this._exporter._materialExporter.getTextureInfo(y.iridescence.thicknessTexture),Y={iridescenceFactor:y.iridescence.VX,iridescenceIor:y.iridescence.indexOfRefraction,iridescenceThicknessMinimum:y.iridescence.minimumThickness,iridescenceThicknessMaximum:y.iridescence.maximumThickness,iridescenceTexture:I??void 0,iridescenceThicknessTexture:r??void 0};null===Y.iridescenceTexture&&null===Y.iridescenceThicknessTexture||this._exporter._materialNeedsUVsSet.add(y),U.extensions[cU]=Y}t(U)}))}}xt.RegisterExtension(cU,(t=>new fU(t)));const SU="KHR_materials_sheen";class NU{constructor(t){this.name=SU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){return y instanceof Ft.d&&y.sheen.isEnabled&&y.sheen.texture?[y.sheen.texture]:[]}async postExportMaterialAsync(t,U,y){return await new Promise((t=>{if(y instanceof Ft.d){if(!y.sheen.isEnabled)return void t(U);this._wasUsed=!0,null==U.extensions&&(U.extensions={});const I={sheenColorFactor:y.sheen.color.bX(),sheenRoughnessFactor:y.sheen.roughness??0};null===I.sheenColorTexture&&null===I.sheenRoughnessTexture||this._exporter._materialNeedsUVsSet.add(y),y.sheen.texture&&(I.sheenColorTexture=this._exporter._materialExporter.getTextureInfo(y.sheen.texture)??void 0),y.sheen.textureRoughness&&!y.sheen.useRoughnessFromMainTexture?I.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(y.sheen.textureRoughness)??void 0:y.sheen.texture&&y.sheen.useRoughnessFromMainTexture&&(I.sheenRoughnessTexture=this._exporter._materialExporter.getTextureInfo(y.sheen.texture)??void 0),U.extensions[SU]=I}t(U)}))}}xt.RegisterExtension(SU,(t=>new NU(t)));const jU="KHR_materials_specular";class JU{constructor(t){this.name=jU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof Ft.d&&this._isExtensionEnabled(y)?(y.metallicReflectanceTexture&&I.push(y.metallicReflectanceTexture),y.reflectanceTexture&&I.push(y.reflectanceTexture),I):I}_isExtensionEnabled(t){return!t.unlit&&(void 0!=t.metallicF0Factor&&1!=t.metallicF0Factor||void 0!=t.metallicReflectanceColor&&!t.metallicReflectanceColor.equalsFloats(1,1,1)||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.metallicReflectanceTexture||null!=t.reflectanceTexture}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0,U.extensions=U.extensions||{};const t=this._exporter._materialExporter.getTextureInfo(y.metallicReflectanceTexture)??void 0,I=this._exporter._materialExporter.getTextureInfo(y.reflectanceTexture)??void 0,r={specularFactor:1==y.metallicF0Factor?void 0:y.metallicF0Factor,specularTexture:t,specularColorFactor:y.metallicReflectanceColor.equalsFloats(1,1,1)?void 0:y.metallicReflectanceColor.bX(),specularColorTexture:I};this._hasTexturesExtension(y)&&this._exporter._materialNeedsUVsSet.add(y),U.extensions[jU]=r}t(U)}))}}xt.RegisterExtension(jU,(t=>new JU(t)));const aU="KHR_materials_transmission";class dU{constructor(t){this.name=aU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof Ft.d&&this._isExtensionEnabled(y)?(y.subSurface.thicknessTexture&&I.push(y.subSurface.thicknessTexture),I):I}_isExtensionEnabled(t){if(t.unlit)return!1;const U=t.subSurface;return U.isRefractionEnabled&&void 0!=U.refractionIntensity&&0!=U.refractionIntensity||this._hasTexturesExtension(t)}_hasTexturesExtension(t){return null!=t.subSurface.refractionIntensityTexture}async postExportMaterialAsync(t,U,y){if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0;const I=y.subSurface,r={transmissionFactor:0===I.refractionIntensity?void 0:I.refractionIntensity};if(this._hasTexturesExtension(y)&&this._exporter._materialNeedsUVsSet.add(y),I.refractionIntensityTexture)if(I.useGltfStyleTextures){const t=await this._exporter._materialExporter.exportTextureAsync(I.refractionIntensityTexture,"image/png");t&&(r.transmissionTexture=t)}else i.b.Warn(`${t}: Exporting a subsurface refraction intensity texture without \`useGltfStyleTextures\` is not supported`);U.extensions||(U.extensions={}),U.extensions[aU]=r}return U}}xt.RegisterExtension(aU,(t=>new dU(t)));const qU="KHR_materials_unlit";class HU{constructor(){this.name=qU,this.enabled=!0,this.required=!1,this._wasUsed=!1}get wasUsed(){return this._wasUsed}dispose(){}postExportMaterialAsync(t,U,y){return new Promise((t=>{let I=!1;y instanceof Ft.d?I=y.unlit:y instanceof Et.BU&&(I=y.disableLighting),I&&(this._wasUsed=!0,null==U.extensions&&(U.extensions={}),U.extensions[qU]={}),t(U)}))}}xt.RegisterExtension(qU,(()=>new HU));const eU="KHR_materials_volume";class oU{constructor(t){this.name=eU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof Ft.d&&this._isExtensionEnabled(y)?(y.subSurface.thicknessTexture&&I.push(y.subSurface.thicknessTexture),I):I}_isExtensionEnabled(t){if(t.unlit)return!1;const U=t.subSurface;return!(!U.isRefractionEnabled&&!U.isTranslucencyEnabled)&&(void 0!=U.maximumThickness&&0!=U.maximumThickness||void 0!=U.tintColorAtDistance&&U.tintColorAtDistance!=Number.POSITIVE_INFINITY||void 0!=U.tintColor&&U.tintColor!=w.bU.White()||this._hasTexturesExtension(t))}_hasTexturesExtension(t){return null!=t.subSurface.thicknessTexture}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof Ft.d&&this._isExtensionEnabled(y)){this._wasUsed=!0;const t=y.subSurface,I={thicknessFactor:0==t.maximumThickness?void 0:t.maximumThickness,thicknessTexture:this._exporter._materialExporter.getTextureInfo(t.thicknessTexture)??void 0,attenuationDistance:t.tintColorAtDistance==Number.POSITIVE_INFINITY?void 0:t.tintColorAtDistance,attenuationColor:t.tintColor.equalsFloats(1,1,1)?void 0:t.tintColor.bX()};this._hasTexturesExtension(y)&&this._exporter._materialNeedsUVsSet.add(y),U.extensions=U.extensions||{},U.extensions[eU]=I}t(U)}))}}xt.RegisterExtension(eU,(t=>new oU(t)));const VU="EXT_materials_diffuse_roughness";class nU{constructor(t){this.name=VU,this.enabled=!0,this.required=!1,this._wasUsed=!1,this._exporter=t}dispose(){}get wasUsed(){return this._wasUsed}postExportMaterialAdditionalTextures(t,U,y){const I=[];return y instanceof GU.c&&y._baseDiffuseRoughness?(y._baseDiffuseRoughnessTexture&&I.push(y._baseDiffuseRoughnessTexture),I):[]}postExportMaterialAsync(t,U,y){return new Promise((t=>{if(y instanceof GU.c){if(!y._baseDiffuseRoughness)return void t(U);this._wasUsed=!0,U.extensions=U.extensions||{};const I=this._exporter._materialExporter.getTextureInfo(y._baseDiffuseRoughnessTexture),r={diffuseRoughnessFactor:y._baseDiffuseRoughness,diffuseRoughnessTexture:I??void 0};null!==r.diffuseRoughnessTexture&&this._exporter._materialNeedsUVsSet.add(y),U.extensions[VU]=r}t(U)}))}}xt.RegisterExtension(VU,(t=>new nU(t)));const iU="KHR_texture_transform";class vU{constructor(){this.name=iU,this.enabled=!0,this.required=!1,this._wasUsed=!1}dispose(){}get wasUsed(){return this._wasUsed}postExportTexture(t,U,y){if(y.St()||r.Tools.Warn(`${t}: /*@__KEY__*/"scene" is not defined for Babylon texture ${y.name}!`),(0!==y.uAng||0!==y.vAng)&&(r.Tools.Warn(`${t}: Texture ${y.name} with rotation in the u or v axis is not supported in glTF.`),0!==y.uRotationCenter||0!==y.vRotationCenter))return;const I={};let Y=!1;if(0===y.uOffset&&0===y.vOffset||(I.offset=[y.uOffset,y.vOffset],Y=!0),1===y.uScale&&1===y.vScale||(I.scale=[y.uScale,y.vScale],Y=!0),0!==y.wAng){if(0!==y.uRotationCenter||0!==y.vRotationCenter){if(y.homogeneousRotationInUVTransform&&y.uScale!==y.vScale)return void r.Tools.Warn(`${t}: Texture ${y.name} with homogenousRotationInUVTransform, non-uniform scaling, and non-zero rotation cannot be exported with ${iU}.`);r.Tools.Warn(`${t}: Texture ${y.name} with non-origin rotation center will be exported using an adjusted offset with ${iU}.`),I.offset=function(t){const{uOffset:U,vOffset:y,uRotationCenter:I,vRotationCenter:r,uScale:Y,vScale:mt,wAng:X}=t,P=Math.cos(X),G=Math.sin(X),M=I*Y,L=r*mt;return[U+(M*(1-P)+L*G),y+(L*(1-P)-M*G)]}(y)}I.rotation=-y.wAng,Y=!0}0!==y.coordinatesIndex&&(I.texCoord=y.coordinatesIndex,Y=!0),Y&&(this._wasUsed=!0,U.extensions||(U.extensions={}),U.extensions[iU]=I)}}xt.RegisterExtension(iU,(()=>new vU));class OU{static CreateSTL(t){let U=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"stlmesh",r=arguments.length>3&&void 0!==arguments[3]&&arguments[3],Y=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],mt=arguments.length>5&&void 0!==arguments[5]&&arguments[5],X=arguments.length>6&&void 0!==arguments[6]&&arguments[6],P=arguments.length>7&&void 0!==arguments[7]&&arguments[7];const G=function(t,U,y){const r=[3*t[y],3*t[y+1],3*t[y+2]],Y=[new I.DU(U[r[0]],U[r[0]+2],U[r[0]+1]),new I.DU(U[r[1]],U[r[1]+2],U[r[1]+1]),new I.DU(U[r[2]],U[r[2]+2],U[r[2]+1])],mt=Y[0].lU(Y[1]),X=Y[2].lU(Y[1]);return{v:Y,n:I.DU.Cross(X,mt).normalize()}},L=function(t,U,y,I){return U=h(t,U,y.x,I),U=h(t,U,y.y,I),h(t,U,y.z,I)},h=function(t,U,y,I){return t.setFloat32(U,y,I),U+4},F=function(t){if(X){let U=t;t instanceof Q.c&&(U=t.sourceMesh);const y=U.getVerticesData(M.e.PositionKind,!0,!0);if(!y)return[];const r=I.DU.Zero();let Y;for(Y=0;Y<y.length;Y+=3)I.DU.TransformCoordinatesFromFloatsToRef(y[Y],y[Y+1],y[Y+2],t.SX(!0),r).toArray(y,Y);return y}return t.getVerticesData(M.e.PositionKind)||[]};X&&(mt=!0);let E="",w=0,D=0;if(r){for(let y=0;y<t.length;y++){const U=t[y].jX();w+=U?U.length/3:0}const U=new ArrayBuffer(84+50*w);E=new DataView(U),D+=80,E.setUint32(D,w,Y),D+=4}else P||(E="solid stlmesh\r\n");for(let I=0;I<t.length;I++){const U=t[I];!r&&P&&(E+="solid "+U.name+"\r\n"),!mt&&U instanceof lt.c&&U.bakeCurrentTransformIntoVertices();const y=F(U),X=U.jX()||[];for(let t=0;t<X.length;t+=3){const U=G(X,y,t);r?(D=L(E,D,U.n,Y),D=L(E,D,U.v[0],Y),D=L(E,D,U.v[1],Y),D=L(E,D,U.v[2],Y),D+=2):(E+="\tfacet normal "+U.n.x+" "+U.n.y+" "+U.n.z+"\r\n",E+="\t\touter loop\r\n",E+="\t\t\tvertex "+U.v[0].x+" "+U.v[0].y+" "+U.v[0].z+"\r\n",E+="\t\t\tvertex "+U.v[1].x+" "+U.v[1].y+" "+U.v[1].z+"\r\n",E+="\t\t\tvertex "+U.v[2].x+" "+U.v[2].y+" "+U.v[2].z+"\r\n",E+="\t\tendloop\r\n",E+="\tendfacet\r\n")}!r&&P&&(E+="endsolid "+name+"\r\n")}if(r||P||(E+="endsolid stlmesh"),U){const t=document.createElement("a"),U=new Blob([E],{type:"application/octet-stream"});t.href=window.URL.createObjectURL(U),t.download=y+".stl",t.click()}return E}}function kU(t,U){let y=arguments.length>2&&void 0!==arguments[2]?arguments[2]:3;const I=[];for(let r=0;r<t.length/y;r++){const Y=t[r*y],mt=t[r*y+1],X=t[r*y+2];I.push(`(${Y.toPrecision(U.precision)}, ${mt.toPrecision(U.precision)}, ${X.toPrecision(U.precision)})`)}return I.join(", ")}function sU(t,U){const y=[];for(let I=0;I<t.length/2;I++){const r=t[2*I],Y=t[2*I+1];y.push(`(${r.toPrecision(U.precision)}, ${(1-Y).toPrecision(U.precision)})`)}return y.join(", ")}function xU(t,U){const y=t.getVerticesData(M.e.PositionKind),I=t.getVerticesData(M.e.NormalKind);if(y&&I)return`\n\tdef Mesh "Geometry"\n\t{\n\t\tint[] faceVertexCounts = [${function(t){var U;const y=null!==(U=t.jX())&&void 0!==U&&U.length?t.getTotalIndices():t.getTotalVertices();return Array(y/3).fill(3).join(", ")}(t)}]\n\t\tint[] faceVertexIndices = [${function(t){const U=t.jX(),y=[];if(null!==U)for(let I=0;I<U.length;I++)y.push(U[I]);else{const U=t.getTotalVertices();for(let t=0;t<U;t++)y.push(t)}return y.join(", ")}(t)}]\n\t\tnormal3f[] normals = [${kU(I,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)\n\t\tpoint3f[] points = [${kU(y,U)}]\n        ${function(t,U){let y="";for(let r=0;r<4;r++){const I=r>0?r:"",Y=t.getVerticesData(M.e.UVKind+(I?I+1:""));Y&&(y+=`\n\t\ttexCoord2f[] primvars:st${I} = [${sU(Y,U)}] (\n\t\t\tinterpolation = "vertex"\n\t\t)`)}const I=t.getVerticesData(M.e.ColorKind);return I&&(y+=`\n\tcolor3f[] primvars:displayColor = [${kU(I,U,I.length/t.getTotalVertices())}] (\n\t\tinterpolation = "vertex"\n\t\t)`),y}(t,U)}\n\t\tuniform token subdivisionScheme = "none"\n\t}\n`}function ZU(t,U){return`\n        def "Geometry"\n        {\n        ${xU(t,U)}\n        }\n        `}function WU(t){let U='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';return U+=t,fflate.strToU8(U)}function AU(t){const U=t.m;return`( ${KU(U,0)}, ${KU(U,4)}, ${KU(U,8)}, ${KU(U,12)} )`}function KU(t,U){return`(${t[U+0]}, ${t[U+1]}, ${t[U+2]}, ${t[U+3]})`}function CU(t){const U="Object_"+t.uniqueId,y=function(t){const U=t.getWorldMatrix().clone(),y=t.St().useRightHandedSystem;if(!y){let I=t.parent;for(;I;){if(mU(I,y)){U.multiplyToRef(I.getWorldMatrix().invert(),U);break}I=I.parent}}return U.determinant()<0&&r.Tools.Warn(`Exporting mesh ${t.name} with negative scale. Result may look incorrect in destination engine.`),U}(t),I=AU(y);return`def Xform "${U}" (\n\tprepend references = @./geometries/Geometry_${t.NX.uniqueId}.usda@</Geometry>\n\tprepend apiSchemas = ["MaterialBindingAPI"]\n)\n{\n\tmatrix4d xformOp:transform = ${I}\n\tuniform token[] xformOpOrder = ["xformOp:transform"]\t\n\n    rel material:binding = </Materials/Material_${t.material.uniqueId}>\n}\n\n`}function RU(t){switch(t){case c.b.TEXTURE_CLAMP_ADDRESSMODE:return"clamp";case c.b.TEXTURE_MIRROR_ADDRESSMODE:return"mirror";case c.b.TEXTURE_WRAP_ADDRESSMODE:default:return"repeat"}}function uU(t){return`(${t.x}, ${t.y})`}function TU(t){return`(${t.r}, ${t.g}, ${t.b})`}function zU(t,U,y,r,Y,mt){const X=t.getInternalTexture().uniqueId+"_"+t.invertY;Y[X]=t;const P=t.coordinatesIndex>0?"st"+t.coordinatesIndex:"st",G=new I.Vector2(t.uScale,t.vScale),M=new I.Vector2(t.uOffset,t.vOffset),L=t.wAng,h=Math.sin(L),Q=Math.cos(L);return M.y=1-M.y-G.y,M.x+=h*G.x,M.y+=(1-Q)*G.y,`\n    def Shader "PrimvarReader_${y}"\n    {\n        uniform token info:id = "UsdPrimvarReader_float2"\n        float2 inputs:fallback = (0.0, 0.0)\n        token inputs:varname = "${P}"\n        float2 outputs:result\n    }\n\n    def Shader "Transform2d_${y}"\n    {\n        uniform token info:id = "UsdTransform2d"\n        token inputs:in.connect = </Materials/Material_${U.uniqueId}/PrimvarReader_${y}.outputs:result>\n        float inputs:rotation = ${(L*(180/Math.PI)).toFixed(mt.precision)}\n        float2 inputs:scale = ${uU(G)}\n        float2 inputs:translation = ${uU(M)}\n        float2 outputs:result\n    }\n\n    def Shader "Texture_${t.uniqueId}_${y}"\n    {\n        uniform token info:id = "UsdUVTexture"\n        asset inputs:file = @textures/Texture_${X}.png@\n        float2 inputs:st.connect = </Materials/Material_${U.uniqueId}/Transform2d_${y}.outputs:result>\n        ${r?"float4 inputs:scale = "+function(t){return`(${t.r}, ${t.g}, ${t.b}, 1.0)`}(r):""}\n        token inputs:sourceColorSpace = "${t.gammaSpace?"raw":"sRGB"}"\n        token inputs:wrapS = "${RU(t.wrapU)}"\n        token inputs:wrapT = "${RU(t.wrapV)}"\n        float outputs:r\n        float outputs:g\n        float outputs:b\n        float3 outputs:rgb\n        ${U.needAlphaBlending()?"float outputs:a":""}\n    }`}function ty(t,U,y){const I="\t\t\t",r=[],Y=[],{diffuseMap:mt,nX:X,alphaCutOff:P,emissiveMap:G,emissive:M,normalMap:L,roughnessMap:h,roughnessChannel:Q,roughness:F,metalnessMap:E,metalnessChannel:D,metalness:l,aoMap:g,aoMapChannel:B,aoMapIntensity:b,alphaMap:p,ior:c,clearCoatEnabled:f,clearCoat:S,clearCoatMap:N,clearCoatRoughness:j,clearCoatRoughnessMap:J}=function(t){const U={diffuseMap:null,nX:null,alphaCutOff:0,emissiveMap:null,emissive:null,normalMap:null,roughnessMap:null,roughnessChannel:"a",roughness:0,metalnessMap:null,metalnessChannel:"r",metalness:0,aoMap:null,aoMapChannel:"rgb",aoMapIntensity:0,alphaMap:null,ior:1,clearCoatEnabled:!1,clearCoat:0,clearCoatMap:null,clearCoatRoughness:0,clearCoatRoughnessMap:null};return t instanceof Et.BU?{...U,diffuseMap:t.diffuseTexture,nX:t.diffuseColor,alphaCutOff:t.alphaCutOff,emissiveMap:t.emissiveTexture,emissive:t.emissiveColor,roughness:1,alphaMap:t.opacityTexture}:t instanceof GU.c?{...U,diffuseMap:t._albedoTexture,nX:t._albedoColor,alphaCutOff:t._alphaCutOff,emissiveMap:t._emissiveTexture,emissive:t._emissiveColor,normalMap:t._bumpTexture,roughnessMap:t._metallicTexture,roughnessChannel:t._useRoughnessFromMetallicTextureAlpha?"a":"g",roughness:t._roughness??1,metalnessMap:t._metallicTexture,metalnessChannel:t._useMetallnessFromMetallicTextureBlue?"b":"r",metalness:t._metallic??0,aoMap:t._ambientTexture,aoMapChannel:t._useAmbientInGrayScale?"r":"rgb",aoMapIntensity:t._ambientTextureStrength,alphaMap:t._opacityTexture,ior:t.subSurface.indexOfRefraction,clearCoatEnabled:t.clearCoat.isEnabled,clearCoat:t.clearCoat.VX,clearCoatMap:t.clearCoat.texture,clearCoatRoughness:t.clearCoat.roughness,clearCoatRoughnessMap:t.clearCoat.useRoughnessFromMainTexture?t.clearCoat.texture:t.clearCoat.textureRoughness}:U}(t);return null!==mt?(r.push(`${I}color3f inputs:diffuseColor.connect = </Materials/Material_${t.uniqueId}/Texture_${mt.uniqueId}_diffuse.outputs:rgb>`),t.needAlphaBlending()?r.push(`${I}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${mt.uniqueId}_diffuse.outputs:a>`):t.needAlphaTesting()&&(r.push(`${I}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${mt.uniqueId}_diffuse.outputs:a>`),r.push(`${I}float inputs:opacityThreshold = ${P}`)),Y.push(zU(mt,t,"diffuse",X,U,y))):r.push(`${I}color3f inputs:diffuseColor = ${TU(X||w.bU.White())}`),null!==G?(r.push(`${I}color3f inputs:emissiveColor.connect = </Materials/Material_${t.uniqueId}/Texture_${G.uniqueId}_emissive.outputs:rgb>`),Y.push(zU(G,t,"emissive",M,U,y))):M&&M.toLuminance()>0&&r.push(`${I}color3f inputs:emissiveColor = ${TU(M)}`),null!==L&&(r.push(`${I}normal3f inputs:normal.connect = </Materials/Material_${t.uniqueId}/Texture_${L.uniqueId}_normal.outputs:rgb>`),Y.push(zU(L,t,"normal",null,U,y))),null!==g&&(r.push(`${I}float inputs:occlusion.connect = </Materials/Material_${t.uniqueId}/Texture_${g.uniqueId}_occlusion.outputs:${B}>`),Y.push(zU(g,t,"occlusion",new w.bU(b,b,b),U,y))),null!==h?(r.push(`${I}float inputs:roughness.connect = </Materials/Material_${t.uniqueId}/Texture_${h.uniqueId}_roughness.outputs:${Q}>`),Y.push(zU(h,t,"roughness",new w.bU(F,F,F),U,y))):r.push(`${I}float inputs:roughness = ${F}`),null!==E?(r.push(`${I}float inputs:metallic.connect = </Materials/Material_${t.uniqueId}/Texture_${E.uniqueId}_metallic.outputs:${D}>`),Y.push(zU(E,t,"metallic",new w.bU(l,l,l),U,y))):r.push(`${I}float inputs:metallic = ${l}`),null!==p?(r.push(`${I}float inputs:opacity.connect = </Materials/Material_${t.uniqueId}/Texture_${p.uniqueId}_opacity.outputs:r>`),r.push(`${I}float inputs:opacityThreshold = 0.0001`),Y.push(zU(p,t,"opacity",null,U,y))):r.push(`${I}float inputs:opacity = ${t.alpha}`),f&&(null!==N?(r.push(`${I}float inputs:clearcoat.connect = </Materials/Material_${t.uniqueId}/Texture_${N.uniqueId}_clearcoat.outputs:r>`),Y.push(zU(N,t,"clearcoat",new w.bU(S,S,S),U,y))):r.push(`${I}float inputs:clearcoat = ${S}`),null!==J?(r.push(`${I}float inputs:clearcoatRoughness.connect = </Materials/Material_${t.uniqueId}/Texture_${J.uniqueId}_clearcoatRoughness.outputs:g>`),Y.push(zU(J,t,"clearcoatRoughness",new w.bU(j,j,j),U,y))):r.push(`${I}float inputs:clearcoatRoughness = ${j}`)),r.push(`${I}float inputs:ior = ${c}`),`\n\tdef Material "Material_${t.uniqueId}"\n\t{\n\t\tdef Shader "PreviewSurface"\n\t\t{\n\t\t\tuniform token info:id = "UsdPreviewSurface"\n${r.join("\n")}\n\t\t\tint inputs:useSpecularWorkflow = 0\n\t\t\ttoken outputs:surface\n\t\t}\n\n\t\ttoken outputs:surface.connect = </Materials/Material_${t.uniqueId}/PreviewSurface.outputs:surface>\n\n${Y.join("\n")}\n\n\t}\n`}async function Uy(t,U,y){const Y={fflateUrl:"https://unpkg.com/fflate@0.8.2",includeAnchoringProperties:!0,anchoringType:"plane",planeAnchoringAlignment:"horizontal",modelFileName:"model.usda",precision:5,exportCamera:!1,cameraSensorWidth:35,...U};"undefined"===typeof fflate&&await r.Tools.LoadScriptAsync(Y.fflateUrl);const mt={};mt[Y.modelFileName]=null;let X='#usda 1.0\n    (\n        customLayerData = {\n            string creator = "Babylon.js USDZExportAsync"\n        }\n        defaultPrim = "Root"\n        metersPerUnit = 1\n        upAxis = "Y"\n    )';X+=function(t){return`def Xform "Root"\n    {\n        def Scope "Scenes" (\n            kind = "sceneLibrary"\n        )\n        {\n            def Xform "Scene" (\n                customData = {\n                    bool preliminary_collidesWithEnvironment = 0\n                    string sceneName = "Scene"\n                }\n                sceneName = "Scene"\n            )\n            {${!0===t.includeAnchoringProperties?`\n\t\ttoken preliminary:anchoring:type = "${t.anchoringType}"\n\t\ttoken preliminary:planeAnchoring:alignment = "${t.planeAnchoringAlignment}"`:""}\n            `}(Y);const P={};for(const I of t.meshes){if(0===I.getTotalVertices())continue;const t=I,U=t.NX,G=t.material;if(!G||!U||y&&!y(t))continue;if(-1!==["BU","PBRMaterial","PBRMetallicRoughnessMaterial"].indexOf(G.getClassName())){const y="geometries/Geometry_"+U.uniqueId+".usda";if(!(y in mt)){const t=ZU(U,Y);mt[y]=WU(t)}G.uniqueId in P||(P[G.uniqueId]=G),X+=CU(t)}else r.Tools.Warn("USDZExportAsync does not support this material type: "+G.getClassName())}t.activeCamera&&Y.exportCamera&&(X+=function(t,U){const y="Camera_"+t.uniqueId,r=AU(I.Matrix.RotationY(Math.PI).multiply(t.getWorldMatrix()));if(t.mode===c.b.ORTHOGRAPHIC_CAMERA)return`def Camera "${y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${r}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.cX.toPrecision(U.precision)}, ${t.maxZ.toPrecision(U.precision)})\n\t\t\tfloat horizontalAperture = ${(10*(Math.abs(t.orthoLeft||1)+Math.abs(t.orthoRight||1))).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(10*(Math.abs(t.orthoTop||1)+Math.abs(t.orthoBottom||1))).toPrecision(U.precision)}\n\t\t\ttoken projection = "orthographic"\n\t\t}\n\t\n\t`;{const I=t.getEngine().getAspectRatio(t),Y=U.cameraSensorWidth||35;return`def Camera "${y}"\n\t\t{\n\t\t\tmatrix4d xformOp:transform = ${r}\n\t\t\tuniform token[] xformOpOrder = ["xformOp:transform"]\n\n\t\t\tfloat2 clippingRange = (${t.cX.toPrecision(U.precision)}, ${t.maxZ.toPrecision(U.precision)})\n\t\t\tfloat focalLength = ${(Y/(2*Math.tan(.5*t.fov))).toPrecision(U.precision)}\n            token projection = "perspective"\n\t\t\tfloat horizontalAperture = ${(Y*I).toPrecision(U.precision)}\n\t\t\tfloat verticalAperture = ${(Y/I).toPrecision(U.precision)}            \n\t\t}\n\t\n\t`}}(t.activeCamera,Y)),X+="\n            }\n        }\n    }";const G={};X+=function(t,U,y){const I=[];for(const r in t){const Y=t[r];I.push(ty(Y,U,y))}return`\n    def "Materials"\n{\n${I.join("")}\n}\n\n`}(P,G,Y),mt[Y.modelFileName]=fflate.strToU8(X);for(const I in G){const t=G[I],U=t.getSize(),y=await t.readPixels();if(!y)throw new Error("Texture data is not available");const r=await f.DumpTools.DumpDataAsync(U.width,U.height,y,"image/png",void 0,!1,!0);mt[`textures/Texture_${I}.png`]=new Uint8Array(r).slice()}let M=0;for(const I in mt){const t=mt[I];if(!t)continue;M+=34+I.length;const U=63&M;if(4!==U){const y=new Uint8Array(64-U);mt[I]=[t,{extra:{12345:y}}]}M=t.length}return fflate.zipSync(mt,{level:0})}}}]);